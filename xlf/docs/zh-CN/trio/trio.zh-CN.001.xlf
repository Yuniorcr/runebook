<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="trio">
    <body>
      <group id="trio">
        <trans-unit id="bef2203120014b5ce1e1289eaeb349f7fcdca3b8" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2017 Nathaniel J. Smith</source>
          <target state="translated">分级为4 +&amp;copy;2017 Nathaniel J.Smith</target>
        </trans-unit>
        <trans-unit id="ec517f2497a37647b77da539c8fae55191e1180f" translate="yes" xml:space="preserve">
          <source>&amp;hellip;but sometimes things aren&amp;rsquo;t so simple, and this trick comes in handy.</source>
          <target state="translated">&amp;hellip;但是有时候事情并不是那么简单，这个技巧派上用场了。</target>
        </trans-unit>
        <trans-unit id="4fb6d2402a1cbcb31359bea4775e8e1f08d418c1" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Closing&amp;rdquo; a &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; will close any pipes to the child and wait for it to exit; if cancelled, the child will be forcibly killed and we will ensure it has finished exiting before allowing the cancellation to propagate.</source>
          <target state="translated">&amp;ldquo;关闭&amp;rdquo; &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt;将关闭通往子进程的所有管道，并等待其退出；如果取消，则该儿童将被强行杀死，我们将确保退出该儿童之前，允许其传播。</target>
        </trans-unit>
        <trans-unit id="f0f4adc8aea427469a8601d79f1dcd868ba5e686" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Someone&amp;rdquo; calls &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; on the current task, and &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; returns or raises whatever value or error was passed to &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;某人&amp;rdquo; 在当前任务上调用&lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt;，而&lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt;返回或引发传递给&lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; 的&lt;/a&gt;任何值或错误。</target>
        </trans-unit>
        <trans-unit id="ccf9abfb241d7f438ec2c11e44c2435737b57df1" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">(&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="d8c7444763b78bba23c7dd50562415180fa069af" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">(&lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="d0f014a4da71f7c88640d008d942aaa519cd93be" translate="yes" xml:space="preserve">
          <source>(Remember how in the tutorial we emphasized the importance of the &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#async-sandwich&quot;&gt;&amp;ldquo;async sandwich&amp;rdquo;&lt;/a&gt;, and the way it means that &lt;code&gt;await&lt;/code&gt; ends up being a marker that shows when you&amp;rsquo;re calling a function that calls a function that &amp;hellip; eventually calls one of Trio&amp;rsquo;s built-in async functions? The transitivity of async-ness is a technical requirement that Python imposes, but since it exactly matches the transitivity of checkpoint-ness, we&amp;rsquo;re able to exploit it to help you keep track of checkpoints. Pretty sneaky, eh?)</source>
          <target state="translated">（请记住，在本教程中我们如何强调&lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#async-sandwich&quot;&gt;&amp;ldquo;异步三明治&amp;rdquo;&lt;/a&gt;的重要性，以及它意味着 &lt;code&gt;await&lt;/code&gt; 最终成为一个标记，该标记在您调用某个函数时显示，该函数最终会调用Trio构建的函数之一-in async functions？异步性的可传递性是Python强制执行的一项技术要求，但由于它与checkpoint-ness的可传递性完全匹配，因此我们可以利用它来帮助您跟踪检查点。 ？）</target>
        </trans-unit>
        <trans-unit id="d296b42ed1d09870d027c1410c66d13e95252382" translate="yes" xml:space="preserve">
          <source>(Terminology: in Trio, &amp;ldquo;aborting&amp;rdquo; is the process of attempting to interrupt a blocked task to deliver a cancellation.)</source>
          <target state="translated">（术语：在Trio中，&amp;ldquo;中止&amp;rdquo;是尝试中断被阻止的任务以提供取消的过程。）</target>
        </trans-unit>
        <trans-unit id="de6b4e9bc8ed194603578653ce489207afc96512" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; is Trio&amp;rsquo;s &amp;ldquo;hazardous materials&amp;rdquo; layer: it contains APIs useful for introspecting and extending Trio. If you&amp;rsquo;re writing ordinary, everyday code, then you can ignore this module completely. But sometimes you need something a bit lower level. Here are some examples of situations where you should reach for &lt;a href=&quot;#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt;是Trio的&amp;ldquo;危险材料&amp;rdquo;层：它包含用于自省和扩展Trio的API。如果您正在编写普通的日常代码，则可以完全忽略此模块。但是有时您需要一些较低的级别。以下是一些您应该接触&lt;a href=&quot;#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt;的情况的示例：</target>
        </trans-unit>
        <trans-unit id="16172e29d7c65bbb8fa0ac4bcac9e89dc906f3a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; completes while &lt;code&gt;afn(*args)&lt;/code&gt; is running, then &lt;code&gt;afn&lt;/code&gt; is likely to raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt;, and this will propagate out into</source>
          <target state="translated">&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果在运行 &lt;code&gt;afn(*args)&lt;/code&gt; 时对&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt;的相应调用完成，则 &lt;code&gt;afn&lt;/code&gt; 可能会引发&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; &lt;/a&gt;，这将传播到</target>
        </trans-unit>
        <trans-unit id="4522539e2495d37a3558c4aca9b0391fd5659005" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; completes while &lt;code&gt;afn(*args)&lt;/code&gt; is running, then &lt;code&gt;afn&lt;/code&gt; is likely to raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt;, and this will propagate out into</source>
          <target state="translated">&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果在运行 &lt;code&gt;afn(*args)&lt;/code&gt; 时完成对&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; &lt;/a&gt;的相应调用，则 &lt;code&gt;afn&lt;/code&gt; 可能会引发&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; &lt;/a&gt;，这将传播到</target>
        </trans-unit>
        <trans-unit id="82a5777a254e3527db31e1099d99402997315cfe" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you already closed this &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt;&lt;code&gt;MemoryReceiveChannel&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果您已经关闭了此&lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt; &lt;code&gt;MemoryReceiveChannel&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="5221ef4c341ee662700ec147b45ff87a5fc43280" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you already closed this &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果您已经关闭了此&lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="50829a08be317170d9f389e8760f1224e6c7231b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt;&lt;code&gt;MemoryReceiveChannel&lt;/code&gt;&lt;/a&gt; also expose several more features beyond the core channel interface:</source>
          <target state="translated">&lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt; &lt;code&gt;MemoryReceiveChannel&lt;/code&gt; &lt;/a&gt;还提供了核心通道接口之外的更多功能：</target>
        </trans-unit>
        <trans-unit id="1191d82fd801b160f1e9a28e8ee8a9d0ce275626" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; implements the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface. In order to make sure your process doesn&amp;rsquo;t end up getting abandoned by mistake or after an exception, you can use &lt;code&gt;async with&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt;实现&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt;接口。为了确保您的过程不会因错误或异常而被放弃，可以将 &lt;code&gt;async with&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="766c979a03f106b8bb33b1bc540b87ed5047ca18" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.RunFinishedError&quot;&gt;&lt;code&gt;RunFinishedError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has already completed.</source>
          <target state="translated">&lt;a href=&quot;#trio.RunFinishedError&quot;&gt; &lt;code&gt;RunFinishedError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果对&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt;的相应调用已经完成。</target>
        </trans-unit>
        <trans-unit id="d2116e282390c51e8b03416366342a5e08cc1519" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.RunFinishedError&quot;&gt;&lt;code&gt;RunFinishedError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; has already completed.</source>
          <target state="translated">&lt;a href=&quot;#trio.RunFinishedError&quot;&gt; &lt;code&gt;RunFinishedError&lt;/code&gt; &lt;/a&gt; -如果给相应的呼叫&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; &lt;/a&gt;已经完成。</target>
        </trans-unit>
        <trans-unit id="e4d06d67b4f7143ccd7e612116d631feb4897116" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SSLListener&quot;&gt;&lt;code&gt;SSLListener&lt;/code&gt;&lt;/a&gt; wraps around another Listener, and converts all incoming connections to encrypted connections by wrapping them in a &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.SSLListener&quot;&gt; &lt;code&gt;SSLListener&lt;/code&gt; &lt;/a&gt;环绕另一个Listener，并通过将所有传入连接包装在&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 中&lt;/a&gt;来将其转换为加密连接。</target>
        </trans-unit>
        <trans-unit id="27eb0e1aa9b6f01d4feddc5e9ef9d83ad48d2eb4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; wraps an arbitrary &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, and allows you to perform encrypted communication over it using the usual &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; interface. You pass regular data to &lt;a href=&quot;#trio.SSLStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;, then it encrypts it and sends the encrypted data on the underlying &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;; &lt;a href=&quot;#trio.SSLStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt; takes encrypted data out of the underlying &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; and decrypts it before returning it.</source>
          <target state="translated">&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;包装任意的&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;，并允许您使用常规的&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;接口对其进行加密通信。您将常规数据传递给&lt;a href=&quot;#trio.SSLStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt;，然后将其加密并在基础&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;上发送加密的数据；&lt;a href=&quot;#trio.SSLStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt;将加密的数据从底层&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; 中&lt;/a&gt;取出，并在返回之前对其进行解密。</target>
        </trans-unit>
        <trans-unit id="8d9019328b65e5c7fec599529982887ad00ddabc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;trio.SSLStream&lt;/code&gt;&lt;/a&gt; is a &amp;ldquo;stream adapter&amp;rdquo; that can take any object that implements the &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;trio.abc.Stream&lt;/code&gt;&lt;/a&gt; interface, and convert it into an encrypted stream. In Trio the standard way to speak SSL over the network is to wrap an &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; around a &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;trio.SSLStream&lt;/code&gt; &lt;/a&gt;是一个&amp;ldquo;流适配器&amp;rdquo;，可以接受实现&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;trio.abc.Stream&lt;/code&gt; &lt;/a&gt;接口的任何对象，并将其转换为加密的流。在三人说话SSL在网络上的标准方法是包装一个&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;围绕&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39dc95c50403cd2d43435da845f9299acf4c54d8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.SSLListener&quot;&gt;&lt;code&gt;SSLListener&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#trio.SSLListener&quot;&gt; &lt;code&gt;SSLListener&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b9f488f7b849505fd8967b05648e0aff408e168" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9511dac7a7d7e0421ef833ef7c70c4edf0bb546" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;trio.SocketStream&lt;/code&gt;&lt;/a&gt; wraps a raw socket (like a TCP connection over the network), and converts it to the standard stream interface.</source>
          <target state="translated">&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;trio.SocketStream&lt;/code&gt; &lt;/a&gt;包装原始套接字（如通过网络的TCP连接），并将其转换为标准流接口。</target>
        </trans-unit>
        <trans-unit id="ae6277fd3b5f495c7e304f8c1c45ef5f868ae8e7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; objects implement the methods in the &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt; interface. They also have two additional public attributes:</source>
          <target state="translated">&lt;a href=&quot;#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt;对象实现&lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; &lt;/a&gt;接口中的方法。它们还具有两个附加的公共属性：</target>
        </trans-unit>
        <trans-unit id="c670588016ac1f9cc12493b77b445b2978d80770" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.StapledStream&quot;&gt;trio.StapledStream&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;None&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.StapledStream&quot;&gt;trio.StapledStream&lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;无&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b58648e3befd84ce4fcd29135a2a900554b16eca" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt;&lt;code&gt;StrictFIFOLock&lt;/code&gt;&lt;/a&gt; provides an alternative. We can rewrite our example like:</source>
          <target state="translated">&lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt; &lt;code&gt;StrictFIFOLock&lt;/code&gt; &lt;/a&gt;提供了一种替代方法。我们可以将示例重写为：</target>
        </trans-unit>
        <trans-unit id="fdc2626d3ed97353c2976e470d8167af2d83cc59" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.TASK_STATUS_IGNORED&quot;&gt;&lt;code&gt;trio.TASK_STATUS_IGNORED&lt;/code&gt;&lt;/a&gt; is a special global object with a do-nothing &lt;code&gt;started&lt;/code&gt; method. This way your function supports being called either like &lt;code&gt;await nursery.start(async_fn, arg1,
arg2)&lt;/code&gt; or directly like &lt;code&gt;await async_fn(arg1, arg2)&lt;/code&gt;, and either way it can call &lt;code&gt;task_status.started()&lt;/code&gt; without worrying about which mode it&amp;rsquo;s in. Defining your function like this will make it obvious to readers that it supports being used in both modes.</source>
          <target state="translated">&lt;a href=&quot;#trio.TASK_STATUS_IGNORED&quot;&gt; &lt;code&gt;trio.TASK_STATUS_IGNORED&lt;/code&gt; &lt;/a&gt;是一个特殊的全局对象，具有不执行任何操作的 &lt;code&gt;started&lt;/code&gt; 方法。这样，您的函数支持像 &lt;code&gt;await nursery.start(async_fn, arg1, arg2)&lt;/code&gt; 类的调用，或者直接像 &lt;code&gt;await async_fn(arg1, arg2)&lt;/code&gt; 类的函数一样被调用，并且无论哪种方式，它都可以调用 &lt;code&gt;task_status.started()&lt;/code&gt; 而不必担心它处于哪种模式。像这样定义您的功能将使读者明显地知道它支持在两种模式下使用。</target>
        </trans-unit>
        <trans-unit id="f2b2153e4fdf6d653827336465dc85f015afdc90" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.TooSlowError&quot;&gt;&lt;code&gt;TooSlowError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception is raised in this scope and caught by the context manager.</source>
          <target state="translated">&lt;a href=&quot;#trio.TooSlowError&quot;&gt; &lt;code&gt;TooSlowError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果在此范围内引发&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;异常并被上下文管理器捕获。</target>
        </trans-unit>
        <trans-unit id="b00c291635e865ead631ad77bb672261484f29e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.TrioInternalError&quot;&gt;&lt;code&gt;TrioInternalError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if an unexpected error is encountered inside Trio&amp;rsquo;s internal machinery. This is a bug and you should &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;let us know&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.TrioInternalError&quot;&gt; &lt;code&gt;TrioInternalError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果在Trio的内部机器内部遇到意外错误。这是一个错误，您应该&lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;让我们知道&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="549feaf6540c3715124d879f456890f89951c201" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if no tokens are available.</source>
          <target state="translated">&lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果没有令牌可用。</target>
        </trans-unit>
        <trans-unit id="3f9ca7941e6449091fb63e720a3c660944189b07" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the lock is currently held.</source>
          <target state="translated">&lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果当前持有锁。</target>
        </trans-unit>
        <trans-unit id="dc0a5bb70c6ad1196434a26fc4621b6dd99c673f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the lock is held.</source>
          <target state="translated">&lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; -&lt;/a&gt;如果持有锁。</target>
        </trans-unit>
        <trans-unit id="849c0db0436a026adf0117e8229b6378d06e4c9b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the value is zero.</source>
          <target state="translated">&lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果值为零。</target>
        </trans-unit>
        <trans-unit id="9d933041f11b3862064d016fb63e7fd87b9bf8e6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; objects guarantee that if their &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; method is cancelled, then they will still close the resource (albeit in a potentially ungraceful fashion). &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt;&lt;code&gt;aclose_forcefully()&lt;/code&gt;&lt;/a&gt; is a convenience function that exploits this behavior to let you force a resource to be closed without blocking: it works by calling &lt;code&gt;await resource.aclose()&lt;/code&gt; and then cancelling it immediately.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt;对象保证，如果取消了其&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt;方法，则它们仍将关闭资源（尽管可能以不合习惯的方式）。&lt;a href=&quot;#trio.aclose_forcefully&quot;&gt; &lt;code&gt;aclose_forcefully()&lt;/code&gt; &lt;/a&gt;是一种便利函数，利用此行为使您可以强制关闭资源而不阻塞：它通过调用 &lt;code&gt;await resource.aclose()&lt;/code&gt; 然后立即取消它来工作。</target>
        </trans-unit>
        <trans-unit id="d1c77ff1d57034f8744ad3c068e6cd1972fa4642" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt;对象还实现&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt;接口，因此可以通过调用&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt;或使用 &lt;code&gt;async with&lt;/code&gt; 块的异步对象来关闭它们。</target>
        </trans-unit>
        <trans-unit id="902354761b623469449754ba405ab35807f70b82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async
with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt;对象还实现&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt;接口，因此可以通过调用&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose&lt;/code&gt; &lt;/a&gt;或使用 &lt;code&gt;async with&lt;/code&gt; 块的 async来关闭它们。</target>
        </trans-unit>
        <trans-unit id="2f8bab82170865ea40192808e48763d40474bfdf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt;对象还实现&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt;接口，因此可以通过调用&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt;或使用 &lt;code&gt;async with&lt;/code&gt; 块的异步对象来关闭它们。</target>
        </trans-unit>
        <trans-unit id="91e0fccdabd247d7386e1ff9a0f28c9659425e93" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; objects can be used in &lt;code&gt;async for&lt;/code&gt; loops. Each iteration will produce an arbitrary sized chunk of bytes, like calling &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some&lt;/code&gt;&lt;/a&gt; with no arguments. Every chunk will contain at least one byte, and the loop automatically exits when reaching end-of-file.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt;对象可以在 &lt;code&gt;async for&lt;/code&gt; 循环中使用。每次迭代都会产生任意大小的字节块，例如调用无参数的&lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some&lt;/code&gt; &lt;/a&gt;。每个块将至少包含一个字节，并且到达文件末尾时，循环会自动退出。</target>
        </trans-unit>
        <trans-unit id="9c08869ed76667edaa59772101eee697d85a3831" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;trio.abc.ReceiveStream&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;None&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;trio.abc.ReceiveStream&lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;无&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14d3253b8802ee45d506acd8a102a38c9d357ad1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async
with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; &lt;/a&gt;对象还实现&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt;接口，因此可以通过调用&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose&lt;/code&gt; &lt;/a&gt;或使用 &lt;code&gt;async with&lt;/code&gt; 块的 async来关闭它们。</target>
        </trans-unit>
        <trans-unit id="f29f1ba8ee04eadcbae71b426c5b4c069cccaf21" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a035426238cc1a5b76516260e0a92a86d67708e5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt;对象还实现&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt;接口，因此可以通过调用&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt;或使用 &lt;code&gt;async with&lt;/code&gt; 块的异步对象来关闭它们。</target>
        </trans-unit>
        <trans-unit id="0d28528d08e13f2a598e7a5c2f5e861d2e65160d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a0c215248a8073bfb6e7bd36af3aa832920275a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;trio.abc.SendStream&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;None&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;trio.abc.SendStream&lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;无&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85d41edb56002d937851f7956c119621d70006ba" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7777fb2718686935e4d26fd0d8f654ba9dc32d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt;&lt;code&gt;FdStream&lt;/code&gt;&lt;/a&gt; supports wrapping Unix files (such as a pipe or TTY) as a stream.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt; &lt;code&gt;FdStream&lt;/code&gt; &lt;/a&gt;支持将Unix文件（例如管道或TTY）包装为流。</target>
        </trans-unit>
        <trans-unit id="1651f3be898b718cb8da61e7478aa37060209193" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.hazmat.RunVar&quot;&gt;&lt;code&gt;RunVar&lt;/code&gt;&lt;/a&gt; objects are similar to context variable objects, except that they are shared across a single call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; rather than a single task.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.RunVar&quot;&gt; &lt;code&gt;RunVar&lt;/code&gt; &lt;/a&gt;对象与上下文变量对象相似，不同之处在于它们通过对&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt;的单个调用而不是单个任务共享。</target>
        </trans-unit>
        <trans-unit id="028c21704b3033e686082fe0983e0e4f6f9f902e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt; and all the other cancellation facilities provided by Trio are ultimately implemented in terms of &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">&lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt;和Trio提供的所有其他取消功能最终都是根据&lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt;对象实现的。</target>
        </trans-unit>
        <trans-unit id="5faaf57ec2674b73c0641070aa02d4d816051ce1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.open_process&quot;&gt;&lt;code&gt;trio.open_process&lt;/code&gt;&lt;/a&gt; starts a process in the background and returns a &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object to let you interact with it. Using it requires a bit more code than &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process&lt;/code&gt;&lt;/a&gt;, but exposes additional capabilities: back-and-forth communication, processing output as soon as it is generated, and so forth. It is modelled after the standard library &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.open_process&quot;&gt; &lt;code&gt;trio.open_process&lt;/code&gt; &lt;/a&gt;在后台启动一个进程，并返回一个&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt;对象，以便您与其进行交互。使用它比&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process&lt;/code&gt; &lt;/a&gt;需要更多的代码，但具有其他功能：来回通信，在生成输出后立即处理输出，等等。它是根据标准库&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt;建模的。</target>
        </trans-unit>
        <trans-unit id="6597caa4903e6c646d0ff25b3284f9e477331f08" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;trio.run_process()&lt;/code&gt;&lt;/a&gt; runs a process from start to finish and returns a &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;CompletedProcess&lt;/code&gt;&lt;/a&gt; object describing its outputs and return value. This is what you should reach for if you want to run a process to completion before continuing, while possibly sending it some input or capturing its output. It is modelled after the standard &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt;&lt;code&gt;subprocess.run()&lt;/code&gt;&lt;/a&gt; with some additional features and safer defaults.</source>
          <target state="translated">&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;trio.run_process()&lt;/code&gt; 从头到尾&lt;/a&gt;运行一个进程，并返回描述其输出和返回值的&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;CompletedProcess&lt;/code&gt; &lt;/a&gt;对象。如果要在继续之前运行流程以使其完成，同时又可能发送一些输入或捕获其输出，则应该达到此目的。它是在标准&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt; &lt;code&gt;subprocess.run()&lt;/code&gt; &lt;/a&gt;之后建模的，具有一些其他功能和更安全的默认设置。</target>
        </trans-unit>
        <trans-unit id="97ef0dba9d3e1bd15283cea463e9501d21dba9ba" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.socket.SocketType&quot;&gt;&lt;code&gt;trio.socket.SocketType&lt;/code&gt;&lt;/a&gt; is an abstract class and cannot be instantiated directly; you get concrete socket objects by calling constructors like &lt;a href=&quot;#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt;. However, you can use it to check if an object is a Trio socket via &lt;code&gt;isinstance(obj, trio.socket.SocketType)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.socket.SocketType&quot;&gt; &lt;code&gt;trio.socket.SocketType&lt;/code&gt; &lt;/a&gt;是一个抽象类，不能直接实例化；您可以通过调用诸如&lt;a href=&quot;#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; 的&lt;/a&gt;构造函数来获得具体的套接字对象。但是，您可以使用它通过 &lt;code&gt;isinstance(obj, trio.socket.SocketType)&lt;/code&gt; 检查对象是否为Trio套接字。</target>
        </trans-unit>
        <trans-unit id="ce4adfdbfdc2bb800ee793718d23c2370de1bab3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.testing.MockClock&quot;&gt;&lt;code&gt;trio.testing.MockClock&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;reference-core#trio.abc.Clock&quot;&gt;&lt;code&gt;Clock&lt;/code&gt;&lt;/a&gt; with a few tricks up its sleeve to help you efficiently test code involving timeouts:</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.MockClock&quot;&gt; &lt;code&gt;trio.testing.MockClock&lt;/code&gt; &lt;/a&gt;是一个带有一些窍门的&lt;a href=&quot;reference-core#trio.abc.Clock&quot;&gt; &lt;code&gt;Clock&lt;/code&gt; &lt;/a&gt;，可帮助您有效地测试涉及超时的代码：</target>
        </trans-unit>
        <trans-unit id="05e5c6ddb0d8d65635c282460582a76e6cd7126f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;, in turn, is implemented using the low-ish level classes &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;. These are implementations of (you guessed it) &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;trio.abc.SendStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;trio.abc.ReceiveStream&lt;/code&gt;&lt;/a&gt; that on their own, aren&amp;rsquo;t attached to anything &amp;ndash; &amp;ldquo;sending&amp;rdquo; and &amp;ldquo;receiving&amp;rdquo; just put data into and get data out of a private internal buffer that each object owns. They also have some interesting hooks you can set, that let you customize the behavior of their methods. This is where you can insert the evil, if you want it. &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt; takes advantage of these hooks in a relatively boring way: it just sets it up so that when you call &lt;code&gt;sendall&lt;/code&gt;, or when you close the send stream, then it automatically triggers a call to &lt;a href=&quot;#trio.testing.memory_stream_pump&quot;&gt;&lt;code&gt;memory_stream_pump()&lt;/code&gt;&lt;/a&gt;, which is a convenience function that takes data out of a &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt;&amp;acute;s buffer and puts it into a &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;&amp;acute;s buffer. But that&amp;rsquo;s just the default &amp;ndash; you can replace this with whatever arbitrary behavior you want.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt;依次使用低级别的类&lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; &lt;/a&gt;实现 memory_stream_one_way_pair（）。这些是&lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;trio.abc.SendStream&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;trio.abc.ReceiveStream&lt;/code&gt; 的&lt;/a&gt;实现（您猜对了），它们自己没有附加任何内容-&amp;ldquo;发送&amp;rdquo;和&amp;ldquo;接收&amp;rdquo;只是将数据放入私有区或从私有取出数据每个对象拥有的内部缓冲区。他们还可以设置一些有趣的钩子，使您可以自定义其方法的行为。如果需要，可以在此处插入邪恶。&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt;以一种相对无聊的方式利用了这些钩子：它只是对其进行设置，以便在调用 &lt;code&gt;sendall&lt;/code&gt; 时，或者关闭发送流时，它会自动触发对&lt;a href=&quot;#trio.testing.memory_stream_pump&quot;&gt; &lt;code&gt;memory_stream_pump()&lt;/code&gt; &lt;/a&gt;的调用，这是一个便捷函数，它将数据从&lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt;的缓冲区中取出，并将其放入&lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; &lt;/a&gt;的缓冲区中。但这只是默认设置-您可以将其替换为所需的任意行为。</target>
        </trans-unit>
        <trans-unit id="9d5e9dba828116b86ced1fe89ee88168dd4d81c5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt;&lt;code&gt;memory_stream_pair()&lt;/code&gt;&lt;/a&gt; gives you a pair of connected, bidirectional streams. It&amp;rsquo;s like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt;&lt;code&gt;socket.socketpair()&lt;/code&gt;&lt;/a&gt;, but without any involvement from that pesky operating system and its networking stack.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt; &lt;code&gt;memory_stream_pair()&lt;/code&gt; &lt;/a&gt;为您提供了一对连接的双向流。就像&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt; &lt;code&gt;socket.socketpair()&lt;/code&gt; 一样&lt;/a&gt;，但是没有任何讨厌的操作系统及其网络堆栈的参与。</target>
        </trans-unit>
        <trans-unit id="608590cb52eebdf3161902f8706901acac61ca21" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/enum.html#enum.Enum&quot;&gt;&lt;code&gt;enum.Enum&lt;/code&gt;&lt;/a&gt; used as the return value from abort functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/enum.html#enum.Enum&quot;&gt; &lt;code&gt;enum.Enum&lt;/code&gt; &lt;/a&gt;用作中止函数的返回值。</target>
        </trans-unit>
        <trans-unit id="6402fdb9fc1a5631193223a95083a060da7e2668" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if a checkpoint was executed.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果执行了检查点。</target>
        </trans-unit>
        <trans-unit id="f90e2933d92ae8a2459cc2bcf2cd6da6697d864d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if a test fails.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果测试失败。</target>
        </trans-unit>
        <trans-unit id="82d82d3e6eb3abe1e3946fd8f65ce6b023bd7885" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if no checkpoint was executed.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果未执行检查点。</target>
        </trans-unit>
        <trans-unit id="220ac26f9cd9eb78e827fe89be8de614e42a8708" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if no &lt;code&gt;trio_token&lt;/code&gt; was provided, and we can&amp;rsquo;t infer one from context.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果未提供 &lt;code&gt;trio_token&lt;/code&gt; ，并且我们无法从上下文中推断出一个。</target>
        </trans-unit>
        <trans-unit id="c4b7b16bc7e58f53144d0aba28de13f544017169" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; &amp;ndash; Whatever &lt;code&gt;sync_fn(*args)&lt;/code&gt; raises.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; &amp;ndash;引发 &lt;code&gt;sync_fn(*args)&lt;/code&gt; 的任何事件。</target>
        </trans-unit>
        <trans-unit id="c66cac55224b866c757ccbd926086af93e8dbe90" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the instrument is not currently active. This could occur either because you never added it, or because you added it and then it raised an unhandled exception and was automatically deactivated.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果仪器当前未激活。发生这种情况的原因可能是您从未添加过它，或者是添加了它然后引发了未处理的异常并被自动停用。</target>
        </trans-unit>
        <trans-unit id="0789287a862ca78af3db9ec09864f9caee6d9ff8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection is &lt;em&gt;enabled&lt;/em&gt; by default; if you want &lt;code&gt;sync_fn&lt;/code&gt; to be interruptible by control-C, then you need to use &lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt;&lt;code&gt;disable_ki_protection()&lt;/code&gt;&lt;/a&gt; explicitly.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt;默认情况下， KeyboardInterrupt保护&lt;em&gt;处于启用状态&lt;/em&gt;；如果希望 &lt;code&gt;sync_fn&lt;/code&gt; 被control-C中断，则需要显式使用&lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt; &lt;code&gt;disable_ki_protection()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d338b5dcc6a2ea187ea6e503786905d62394bb9d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; If the handle is invalid, e.g. when it is already closed.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果句柄无效，例如已关闭。</target>
        </trans-unit>
        <trans-unit id="1eb12bd422acc39baf4fc829d812f0628bebdc08" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; If the socket file could not be connected to.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果套接字文件无法连接。</target>
        </trans-unit>
        <trans-unit id="c9321e21ed7e147c3ad7da16f75cebd93a1ea481" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if an error is encountered starting or communicating with the process</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果在启动或与进程通信时遇到错误</target>
        </trans-unit>
        <trans-unit id="fe1846f55ded122f0371eb200f705368a43f5442" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the connection fails.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果连接失败。</target>
        </trans-unit>
        <trans-unit id="fd16cd8999185f6d888fdea658dd8fa4b7c2a88a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the process spawning fails, for example because the specified command could not be found.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果进程产生失败，例如，因为找不到指定的命令。</target>
        </trans-unit>
        <trans-unit id="fbf301bdc49ec83493d111216f646a567eac9758" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the underlying call to &lt;code&gt;accept&lt;/code&gt; raises an unexpected error.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果对 &lt;code&gt;accept&lt;/code&gt; 的基础调用引发意外错误。</target>
        </trans-unit>
        <trans-unit id="81892ce0edb345342bb81a23b92e24b5a76b2e45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; If AF_UNIX sockets are not supported.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果不支持AF_UNIX套接字。</target>
        </trans-unit>
        <trans-unit id="820245345a01caefa04db07ba22a6f2b08955270" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; If this nursery is no longer open (i.e. its &lt;code&gt;async with&lt;/code&gt; block has exited).</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果该苗圃不再打开（即，其 &lt;code&gt;async with&lt;/code&gt; 块的异步已退出）。</target>
        </trans-unit>
        <trans-unit id="05d203f34970a37d3b8654fc60575144620cd718" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;code&gt;borrower&lt;/code&gt; already holds one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果 &lt;code&gt;borrower&lt;/code&gt; 已经持有此麻袋的令牌之一。</target>
        </trans-unit>
        <trans-unit id="9caa41b116381d44b1035bd6583d9b2734e0bd7f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;code&gt;borrower&lt;/code&gt; task already holds one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果 &lt;code&gt;borrower&lt;/code&gt; 任务已经持有此麻袋的令牌之一。</target>
        </trans-unit>
        <trans-unit id="1523a22843113284427f0c91f6126a1a2875b26a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if not inside a call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果不在调用&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; 内&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9229918d00657fe5d5a04b1e6686e28c8ea7f6a4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the calling task does not hold the lock.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果调用任务未持有锁。</target>
        </trans-unit>
        <trans-unit id="7ee4591b74dc354d3a927e5412ee4a989fbf872b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the current task already holds one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果当前任务已经持有此麻袋的令牌之一。</target>
        </trans-unit>
        <trans-unit id="a28b63ca276986b36ae501abe3cb5e7f8942f1e1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the current task has not acquired one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果当前任务尚未获取此麻袋的令牌之一。</target>
        </trans-unit>
        <trans-unit id="a7febb292cf405a27200ef3bde9ebf3b57367acd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the given borrower has not acquired one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果给定的借方尚未获得此麻袋的令牌之一。</target>
        </trans-unit>
        <trans-unit id="85a07d923bf91b8e2edc651f5b71c48321c79d50" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you try calling this from inside the Trio thread, which would otherwise cause a deadlock.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果尝试从Trio线程内部调用此函数，否则将导致死锁。</target>
        </trans-unit>
        <trans-unit id="c49c0535d85c7b0fde828d34a6e9b90598bccef2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you try to use this anywhere except Python&amp;rsquo;s main thread. (This is a Python limitation.)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果您尝试在Python主线程以外的任何地方使用此代码。（这是Python的限制。）</target>
        </trans-unit>
        <trans-unit id="da83362d474942ed0891ee40b74e3b969d32a746" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if any of the passed in objects are not instances of &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果任何传入的对象不是&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; 的&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="e359768ef7fbd567a74c4408d6fd2e1dc9d6267b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#UnicodeError&quot;&gt;&lt;code&gt;UnicodeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;code&gt;stdin&lt;/code&gt; is specified as a Unicode string, rather than bytes</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#UnicodeError&quot;&gt; &lt;code&gt;UnicodeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果将 &lt;code&gt;stdin&lt;/code&gt; 指定为Unicode字符串而不是字节</target>
        </trans-unit>
        <trans-unit id="a88563ac21fdb3a838f11487d501cc35ef5e4a02" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;em&gt;seconds&lt;/em&gt; is less than zero.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果&lt;em&gt;秒数&lt;/em&gt;小于零。</target>
        </trans-unit>
        <trans-unit id="a61df9e89e060351c934beaaef21748cc2170785" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;em&gt;seconds&lt;/em&gt; is negative.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果&lt;em&gt;秒&lt;/em&gt;为负数。</target>
        </trans-unit>
        <trans-unit id="1b01b5d6e9534f01004484190f2fdfa1fac4b540" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if incrementing the value would cause it to exceed &lt;a href=&quot;#trio.Semaphore.max_value&quot;&gt;&lt;code&gt;max_value&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果增加值将导致其超过&lt;a href=&quot;#trio.Semaphore.max_value&quot;&gt; &lt;code&gt;max_value&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1fdec5829d0e7488e736c422c9e29e0a932a83e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if multiple redirections are specified for the same stream, e.g., both &lt;code&gt;capture_stdout=True&lt;/code&gt; and &lt;code&gt;stdout=subprocess.DEVNULL&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果为同一流指定了多个重定向，例如， &lt;code&gt;capture_stdout=True&lt;/code&gt; 和 &lt;code&gt;stdout=subprocess.DEVNULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d46a94b78faa648664980bba903f899cd3b403f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if timeout is less than zero.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果超时小于零。</target>
        </trans-unit>
        <trans-unit id="ac60b6da0a8198ebedacab39a16e315085e433dc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you try to pass a negative value for &lt;code&gt;seconds&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果您尝试传递负值 &lt;code&gt;seconds&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afe3c25042b0b29f15a85aa8688cec2acdbadf92" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getdefaulttimeout&quot;&gt;&lt;code&gt;getdefaulttimeout()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.setdefaulttimeout&quot;&gt;&lt;code&gt;setdefaulttimeout()&lt;/code&gt;&lt;/a&gt;: instead, use Trio&amp;rsquo;s standard support for &lt;a href=&quot;reference-core#cancellation&quot;&gt;Cancellation and timeouts&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getdefaulttimeout&quot;&gt; &lt;code&gt;getdefaulttimeout()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.setdefaulttimeout&quot;&gt; &lt;code&gt;setdefaulttimeout()&lt;/code&gt; &lt;/a&gt;：相反，请使用Trio对&lt;a href=&quot;reference-core#cancellation&quot;&gt; Cancellation和timeouts&lt;/a&gt;的标准支持。</target>
        </trans-unit>
        <trans-unit id="348e9e4e99c81e1efbcca8c3f74caec5f6b5fad8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getfqdn&quot;&gt;&lt;code&gt;getfqdn()&lt;/code&gt;&lt;/a&gt;: obsolete; use &lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;AI_CANONNAME&lt;/code&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getfqdn&quot;&gt; &lt;code&gt;getfqdn()&lt;/code&gt; &lt;/a&gt;：已过时；使用带有 &lt;code&gt;AI_CANONNAME&lt;/code&gt; 标志的&lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db0936a9e91afbf5ae1135fd9360542a5d0606c9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyname&quot;&gt;&lt;code&gt;gethostbyname()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyname_ex&quot;&gt;&lt;code&gt;gethostbyname_ex()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyaddr&quot;&gt;&lt;code&gt;gethostbyaddr()&lt;/code&gt;&lt;/a&gt;: obsolete; use &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getnameinfo&quot;&gt;&lt;code&gt;getnameinfo()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyname&quot;&gt; &lt;code&gt;gethostbyname()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyname_ex&quot;&gt; &lt;code&gt;gethostbyname_ex()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyaddr&quot;&gt; &lt;code&gt;gethostbyaddr()&lt;/code&gt; &lt;/a&gt;：已过时；使用&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getnameinfo&quot;&gt; &lt;code&gt;getnameinfo()&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="17d69c94218d1ebabadf6e649a8c2e3df496a1d5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getservbyname&quot;&gt;&lt;code&gt;getservbyname()&lt;/code&gt;&lt;/a&gt;: obsolete and &lt;a href=&quot;https://bugs.python.org/issue30482&quot;&gt;buggy&lt;/a&gt;; instead, do:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getservbyname&quot;&gt; &lt;code&gt;getservbyname()&lt;/code&gt; &lt;/a&gt;：已过时且有&lt;a href=&quot;https://bugs.python.org/issue30482&quot;&gt;错误&lt;/a&gt;；相反，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="5eacd97b4458f5aa1b57894879655db6e99850c1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getservbyport&quot;&gt;&lt;code&gt;getservbyport()&lt;/code&gt;&lt;/a&gt;: obsolete and &lt;a href=&quot;https://bugs.python.org/issue30482&quot;&gt;buggy&lt;/a&gt;; instead, do:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getservbyport&quot;&gt; &lt;code&gt;getservbyport()&lt;/code&gt; &lt;/a&gt;：已过时且有&lt;a href=&quot;https://bugs.python.org/issue30482&quot;&gt;错误&lt;/a&gt;；相反，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="b5eb0f9ecdc2cf9e2ee4edbc8624978be2e45ca0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.makefile&quot;&gt;&lt;code&gt;makefile()&lt;/code&gt;&lt;/a&gt;: Python&amp;rsquo;s file-like API is synchronous, so it can&amp;rsquo;t be implemented on top of an async socket.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.makefile&quot;&gt; &lt;code&gt;makefile()&lt;/code&gt; &lt;/a&gt;：Python的类似文件的API是同步的，因此不能在异步套接字的顶部实现。</target>
        </trans-unit>
        <trans-unit id="a9fd2568d3df3a54030ed0a7a247ae1b1458a624" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.recvmsg&quot;&gt;&lt;code&gt;recvmsg()&lt;/code&gt;&lt;/a&gt; (if available)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.recvmsg&quot;&gt; &lt;code&gt;recvmsg()&lt;/code&gt; &lt;/a&gt;（如果有）</target>
        </trans-unit>
        <trans-unit id="64a9f06a1eda38f9e0eed41e97838ad4116deb4a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.recvmsg_into&quot;&gt;&lt;code&gt;recvmsg_into()&lt;/code&gt;&lt;/a&gt; (if available)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.recvmsg_into&quot;&gt; &lt;code&gt;recvmsg_into()&lt;/code&gt; &lt;/a&gt;（如果可用）</target>
        </trans-unit>
        <trans-unit id="b1886c3f9044cff76ab5db335decfb991adc0b02" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.sendall&quot;&gt;&lt;code&gt;sendall()&lt;/code&gt;&lt;/a&gt;: Could be supported, but you&amp;rsquo;re better off using the higher-level &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt;, and specifically its &lt;a href=&quot;#trio.SocketStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; method, which also does additional error checking.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.sendall&quot;&gt; &lt;code&gt;sendall()&lt;/code&gt; &lt;/a&gt;：可以支持，但是最好使用更高级别的&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt;，尤其是它的&lt;a href=&quot;#trio.SocketStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt;方法，该方法还会执行其他错误检查。</target>
        </trans-unit>
        <trans-unit id="b80ffb80eda2ef62aa200fd82d0be12179b5658b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.sendmsg&quot;&gt;&lt;code&gt;sendmsg()&lt;/code&gt;&lt;/a&gt; (if available)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.sendmsg&quot;&gt; &lt;code&gt;sendmsg()&lt;/code&gt; &lt;/a&gt;（如果有）</target>
        </trans-unit>
        <trans-unit id="bf8f587cd6689ebc86645620fca231f8542839a6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.setblocking&quot;&gt;&lt;code&gt;setblocking()&lt;/code&gt;&lt;/a&gt;: Trio sockets always act like blocking sockets; if you need to read/write from multiple sockets at once, then create multiple tasks.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.setblocking&quot;&gt; &lt;code&gt;setblocking()&lt;/code&gt; &lt;/a&gt;：Trio套接字始终像阻塞套接字一样工作；如果您需要一次从多个套接字读取/写入，则创建多个任务。</target>
        </trans-unit>
        <trans-unit id="ad8b8dcdfd05706ebbce9d91167f8e26de5f6cc6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.settimeout&quot;&gt;&lt;code&gt;settimeout()&lt;/code&gt;&lt;/a&gt;: see &lt;a href=&quot;reference-core#cancellation&quot;&gt;Cancellation and timeouts&lt;/a&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.settimeout&quot;&gt; &lt;code&gt;settimeout()&lt;/code&gt; &lt;/a&gt;：请参见&lt;a href=&quot;reference-core#cancellation&quot;&gt;取消和超时&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63172ffa4cb84d85aa2280ba0d689e49680e3cf7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;bytes&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytearray&quot;&gt;bytearray&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;字节&lt;/a&gt;或字节&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytearray&quot;&gt;数组&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d9a159b020f5a5f92930f5910448af6b6024ec6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;str&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;list&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;str&lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;列表&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="169c0c7f34d41eeaedba1af87df42a6c0801aba5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;subprocess.CalledProcessError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;code&gt;check=False&lt;/code&gt; is not passed and the process exits with a nonzero exit status</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;subprocess.CalledProcessError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果未通过 &lt;code&gt;check=False&lt;/code&gt; 且进程以非零退出状态退出</target>
        </trans-unit>
        <trans-unit id="45c49afc36a9666b9a231b13adcca1634eef0223" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;communicate()&lt;/code&gt;&lt;/a&gt; is not provided as a method on &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; objects; use &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; instead, or write the loop yourself if you have unusual needs. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;communicate()&lt;/code&gt;&lt;/a&gt; has quite unusual cancellation behavior in the standard library (on some platforms it spawns a background thread which continues to read from the child process even after the timeout has expired) and we wanted to provide an interface with fewer surprises.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;communicate()&lt;/code&gt; &lt;/a&gt;在&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt;对象上未提供 communication（）作为方法；请改用&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt;，如果有特殊需要，请自己编写循环。&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;communicate()&lt;/code&gt; &lt;/a&gt;在标准库中具有非常不正常的取消行为（在某些平台上，它会生成一个后台线程，即使超时已过期，该线程仍会继续从子进程读取），我们希望提供一个具有更少惊喜的接口。</target>
        </trans-unit>
        <trans-unit id="2f50b4f2871137e469bff365fb01f51208de17a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if something has gone wrong, and the channel is broken.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果出现问题，并且通道中断。</target>
        </trans-unit>
        <trans-unit id="f0979f0e1697acb335032a114b3342bce2855877" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if something has gone wrong, and the channel is broken. For example, you may get this if the receiver has already been closed.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果出现问题，并且通道中断。例如，如果接收器已经关闭，则可能会收到此消息。</target>
        </trans-unit>
        <trans-unit id="8e6bb7cd4db6ec2b88972d932c91f5595667a94f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if something has gone wrong, and the stream is broken.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果出现问题，并且流中断。</target>
        </trans-unit>
        <trans-unit id="b93fe7550e185e7bdcf056cf2aab816e875bc344" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task is already executing a &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;HalfCloseableStream.send_eof()&lt;/code&gt;&lt;/a&gt; on this stream.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果另一个任务已在此流上执行&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;HalfCloseableStream.send_eof()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4baab643c3e32e1ea96c8a8b00719b50047605f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task is already executing a &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; on this stream.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果另一个任务已在此流上执行&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a2451843bb01fc131a8d404e2893ebcd1964f7fa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task is already waiting for the given socket to become readable.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果另一个任务已经在等待给定的套接字变得可读。</target>
        </trans-unit>
        <trans-unit id="ca0b61e8669b4d0cbf2a0227e7a1ecd7f2f0eea9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task is already waiting for the given socket to become writable.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果另一个任务已经在等待给定套接字变为可写状态。</target>
        </trans-unit>
        <trans-unit id="a7e3b99113902fc66735a64cb19e67c7bfc85de4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if two tasks attempt to call &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; on the same listener at the same time.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果两个任务试图同时在同一侦听器上调用&lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a02bb442196558eb15b2a8fa432cccf8bd2cab8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if two tasks attempt to call &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt; on the same stream at the same time.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果两个任务试图同时在同一流上调用&lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77d6c6089e93746cb93c8d866005f76290c5d564" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; some channels allow multiple tasks to call &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; at the same time, but others don&amp;rsquo;t. If you try to call &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; simultaneously from multiple tasks on a channel that doesn&amp;rsquo;t support it, then you can get &lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;BusyResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;一些通道允许多个任务同时调用&lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt;，而其他通道则不允许。如果您尝试从不支持频道的多个任务中同时调用&lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt;，则可以获取&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;BusyResourceError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d1c202ed75f39c32ad05b7c4535716ce47ebdf27" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; some channels allow multiple tasks to call &lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; at the same time, but others don&amp;rsquo;t. If you try to call &lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; simultaneously from multiple tasks on a channel that doesn&amp;rsquo;t support it, then you can get &lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;BusyResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;一些通道允许多个任务同时调用&lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;，而其他通道则不允许。如果您尝试从不支持该通道的多个任务中同时调用&lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;，则可以获取&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;BusyResourceError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e49b6f53c167deed4c6f74f872864d447920b7d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you already closed the socket.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果您已经关闭套接字。</target>
        </trans-unit>
        <trans-unit id="33039c1212f13a8f732f7e2da9d59ab6907c8278" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task calls &lt;a href=&quot;#trio.hazmat.notify_closing&quot;&gt;&lt;code&gt;notify_closing()&lt;/code&gt;&lt;/a&gt; while this function is still working.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; -&lt;/a&gt;如果在此函数仍在工作时另一个任务调用&lt;a href=&quot;#trio.hazmat.notify_closing&quot;&gt; &lt;code&gt;notify_closing()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="739f1b24bdaf701e82803b6e061c7bba5c4ad049" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果您先前关闭了此&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="663a046b61214a99317618df73de81f588f099ec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt; object, or if another task closes it while &lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果您先前关闭了此&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; &lt;/a&gt;对象，或者在&lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt;运行时另一个任务关闭了它。</target>
        </trans-unit>
        <trans-unit id="bbd2472c216fa77160785a706f4a34fb23febe0f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this listener object, or if another task closes this listener object while &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果您先前关闭了此侦听器对象，或者在&lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt;运行时另一个任务关闭了此侦听器对象。</target>
        </trans-unit>
        <trans-unit id="afd68c5665d9d4aea771006164e62b59cd9b5100" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this stream object, or if another task closes this stream object while &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果您先前关闭了此流对象，或者在&lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt;运行时另一个任务关闭了此流对象。</target>
        </trans-unit>
        <trans-unit id="b28dacbe058ec2a8d8214f4169b49933e418573a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this stream object, or if another task closes this stream object while &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果您先前关闭了此流对象，或者在&lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt;运行时另一个任务关闭了此流对象。</target>
        </trans-unit>
        <trans-unit id="4f700d42049380feaaff1f42e46ee8e755181a04" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this stream object, or if another task closes this stream object while &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果您先前关闭了此流对象，或者在&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt;运行时另一个任务关闭了此流对象。</target>
        </trans-unit>
        <trans-unit id="b8815102cec16d6dd7a950d42fde656e3466c9f4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this stream object, or if another task closes this stream object while &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果您先前关闭了此流对象，或者在运行&lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt;时另一个任务关闭了此流对象。</target>
        </trans-unit>
        <trans-unit id="49dec4aedbef1954e897290d01837d539edf6748" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.EndOfChannel&quot;&gt;&lt;code&gt;trio.EndOfChannel&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the sender has been closed cleanly, and no more objects are coming. This is not an error condition.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.EndOfChannel&quot;&gt; &lt;code&gt;trio.EndOfChannel&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果发送方已完全关闭，并且不再有其他对象。这不是错误情况。</target>
        </trans-unit>
        <trans-unit id="ebe40cdb42b8ee71ac10e277e89b41a334433b37" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.RunFinishedError&quot;&gt;&lt;code&gt;trio.RunFinishedError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the associated call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has already exited. (Any call that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; raise this error is guaranteed to be fully processed before &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; exits.)</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.RunFinishedError&quot;&gt; &lt;code&gt;trio.RunFinishedError&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果对&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt;的关联调用已退出。（任何&lt;em&gt;不会&lt;/em&gt;引发此错误的调用&lt;em&gt;都&lt;/em&gt;可以保证在&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt;退出之前已得到完全处理。）</target>
        </trans-unit>
        <trans-unit id="53b89351a19b01031449bc62fdf5c0206532a0a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.WouldBlock&quot;&gt;&lt;code&gt;trio.WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if no data is available to retrieve.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.WouldBlock&quot;&gt; &lt;code&gt;trio.WouldBlock&lt;/code&gt; &lt;/a&gt; &amp;ndash;如果没有数据可检索。</target>
        </trans-unit>
        <trans-unit id="ad34061454ddafc79274fd334d162936866c646a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**options&lt;/code&gt; &amp;ndash; &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; also accepts any &lt;a href=&quot;#subprocess-options&quot;&gt;general subprocess options&lt;/a&gt; and passes them on to the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; constructor. This includes the &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; options, which provide additional redirection possibilities such as &lt;code&gt;stderr=subprocess.STDOUT&lt;/code&gt;, &lt;code&gt;stdout=subprocess.DEVNULL&lt;/code&gt;, or file descriptors.</source>
          <target state="translated">&lt;code&gt;**options&lt;/code&gt; &amp;ndash; &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt;也接受任何&lt;a href=&quot;#subprocess-options&quot;&gt;常规的子流程选项&lt;/a&gt;，并将它们传递给&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt;构造函数。这包括 &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 选项，它们提供了其他重定向可能性，例如 &lt;code&gt;stderr=subprocess.STDOUT&lt;/code&gt; ， &lt;code&gt;stdout=subprocess.DEVNULL&lt;/code&gt; 或文件描述符。</target>
        </trans-unit>
        <trans-unit id="3764750810169a9d10ba875c5f1a6c7742a2021f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**options&lt;/code&gt; &amp;ndash; Other &lt;a href=&quot;#subprocess-options&quot;&gt;general subprocess options&lt;/a&gt; are also accepted.</source>
          <target state="translated">&lt;code&gt;**options&lt;/code&gt; &amp;ndash;其他&lt;a href=&quot;#subprocess-options&quot;&gt;常规子流程选项&lt;/a&gt;也被接受。</target>
        </trans-unit>
        <trans-unit id="41febbb3b0834802a6746a8f5643cd9a2661975f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*args&lt;/code&gt; &amp;ndash; Positional arguments to pass to sync_fn. If you need keyword arguments, use &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; &amp;ndash;传递给sync_fn的位置参数。如果需要关键字参数，请使用&lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6494d56ff44c758f33670f78cf4b315c1ac6a7ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Anything else&lt;/code&gt; &amp;ndash; if &lt;code&gt;async_fn&lt;/code&gt; raises an exception, then &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; propagates it.</source>
          <target state="translated">&lt;code&gt;Anything else&lt;/code&gt; &amp;ndash;如果 &lt;code&gt;async_fn&lt;/code&gt; 引发异常，则&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt;传播该异常。</target>
        </trans-unit>
        <trans-unit id="083b984922795569d238527957c899850bfdf049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EMFILE&lt;/code&gt;: process is out of file descriptors</source>
          <target state="translated">&lt;code&gt;EMFILE&lt;/code&gt; ：进程超出文件描述符</target>
        </trans-unit>
        <trans-unit id="e6185dc2a89485bb87a58b6a4de5be31b3888068" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ENFILE&lt;/code&gt;: system is out of file descriptors</source>
          <target state="translated">&lt;code&gt;ENFILE&lt;/code&gt; ：系统文件描述符不足</target>
        </trans-unit>
        <trans-unit id="aa0e28c33bc1490f1c0a230755aa6bd6eeabb6cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ENOBUFS&lt;/code&gt;, &lt;code&gt;ENOMEM&lt;/code&gt;: the kernel hit some sort of memory limitation when trying to create a socket object</source>
          <target state="translated">&lt;code&gt;ENOBUFS&lt;/code&gt; ， &lt;code&gt;ENOMEM&lt;/code&gt; ：尝试创建套接字对象时内核遇到某种内存限制</target>
        </trans-unit>
        <trans-unit id="d1ebb1933006763cb904d2510939655ae79810f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__aenter__&lt;/code&gt;, &lt;code&gt;__aexit__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__aenter__&lt;/code&gt; ， &lt;code&gt;__aexit__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53d9542cd2795bd32a4641b28995e15220369c03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__aiter__&lt;/code&gt;, &lt;code&gt;__anext__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__aiter__&lt;/code&gt; ， &lt;code&gt;__anext__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f721b10bca9ebf38d8f9a3b21ed2543d633607e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abort_func&lt;/code&gt; &amp;ndash; Same as for &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;, except that it must return &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt;&lt;code&gt;Abort.FAILED&lt;/code&gt;&lt;/a&gt;. (If it returned &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt;, then Trio would attempt to reschedule the detached task directly without going through &lt;a href=&quot;#trio.hazmat.reattach_detached_coroutine_object&quot;&gt;&lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt;&lt;/a&gt;, which would be bad.) Your &lt;code&gt;abort_func&lt;/code&gt; should still arrange for whatever the coroutine object is doing to be cancelled, and then reattach to Trio and call the &lt;code&gt;raise_cancel&lt;/code&gt; callback, if possible.</source>
          <target state="translated">&lt;code&gt;abort_func&lt;/code&gt; &amp;ndash;与&lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt;相同，只不过它必须返回&lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt; &lt;code&gt;Abort.FAILED&lt;/code&gt; &lt;/a&gt;。（如果返回&lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt;，则Trio将尝试直接重新计划已分离的任务，而无需经过 &lt;code&gt;abort_func&lt;/code&gt; &lt;a href=&quot;#trio.hazmat.reattach_detached_coroutine_object&quot;&gt; &lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt; &lt;/a&gt;，这很不好。）您的abort_func仍应安排协程对象正在执行的操作被取消，然后重新附加。转到Trio，并在可能的情况下调用 &lt;code&gt;raise_cancel&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="cc87db35f7da4123b104b2897e7467f605432bdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; &amp;ndash; Positional arguments for &lt;code&gt;async_fn&lt;/code&gt;. If you want to pass keyword arguments, use &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; &amp;ndash; &lt;code&gt;async_fn&lt;/code&gt; 的位置参数。如果要传递关键字参数，请使用&lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f222164120ff2300840b55152e8406e1404dbe95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; &amp;ndash; Positional arguments to be passed to &lt;em&gt;async_fn&lt;/em&gt;. If you need to pass keyword arguments, then use &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; &amp;ndash;传递给&lt;em&gt;async_fn的&lt;/em&gt;位置参数。如果需要传递关键字参数，请使用&lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23a7b12dd1ab3f6f8a5d8f9fc0a01d9470689cab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async_fn&lt;/code&gt; &amp;ndash; An async callable.</source>
          <target state="translated">&lt;code&gt;async_fn&lt;/code&gt; &amp;ndash;一个异步可调用对象。</target>
        </trans-unit>
        <trans-unit id="6c052d400da7804ef69953fd35006966364a4f70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async_fn&lt;/code&gt; &amp;ndash; An async function.</source>
          <target state="translated">&lt;code&gt;async_fn&lt;/code&gt; &amp;ndash;一个异步函数。</target>
        </trans-unit>
        <trans-unit id="d16ff931501131ab166e17998e960d09e520902f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autojump_threshold&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the initial &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;autojump_threshold&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;）&amp;ndash;初始&lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cad07808ed4a54386ed965aafec76c4909fc661" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backlog&lt;/code&gt; &amp;ndash; The listen backlog, or None to have a good default picked. Passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;backlog&lt;/code&gt; &amp;ndash;收听待办事项，或者选择无，以选择默认值。传递给&lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eca11bd3398470cc2c5ce63c03786d3b1c4e8b0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backlog&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; See &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;backlog&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;）&amp;ndash;有关详细信息，请参见&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64c93d1c8e192537d2c9150114742d87244de77a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backlog&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The listen backlog to use. If you leave this as &lt;code&gt;None&lt;/code&gt; then Trio will pick a good default. (Currently: whatever your system has configured as the maximum backlog.)</source>
          <target state="translated">&lt;code&gt;backlog&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要使用的监听待办事项。如果将其保留为 &lt;code&gt;None&lt;/code&gt; ,则Trio将选择一个很好的默认值。（当前：无论您的系统配置为最大积压量。）</target>
        </trans-unit>
        <trans-unit id="ea4466c20b949ea4de4e437c5d6e61f834979d8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;borrowed_tokens&lt;/code&gt;: The number of tokens currently borrowed from the sack.</source>
          <target state="translated">&lt;code&gt;borrowed_tokens&lt;/code&gt; ：当前从麻袋中借用的令牌数。</target>
        </trans-unit>
        <trans-unit id="f6feab6d08fc0dda319bdf0f73f68dcba1e57757" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;borrower&lt;/code&gt; &amp;ndash; A &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;trio.hazmat.Task&lt;/code&gt;&lt;/a&gt; or arbitrary opaque object used to record who is borrowing this token. This is used by &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; to allow threads to &amp;ldquo;hold tokens&amp;rdquo;, with the intention in the future of using it to &lt;a href=&quot;https://github.com/python-trio/trio/issues/182&quot;&gt;allow deadlock detection and other useful things&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;borrower&lt;/code&gt; &amp;ndash;一个&lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt; &lt;code&gt;trio.hazmat.Task&lt;/code&gt; &lt;/a&gt;或任意不透明对象，用于记录谁在借用此令牌。这是用来通过&lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt;，以允许线程&amp;ldquo;持有令牌&amp;rdquo;，意图在未来使用它的&lt;a href=&quot;https://github.com/python-trio/trio/issues/182&quot;&gt;允许死锁检测和其他有用的东西&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63ae0d201a862df2c367dba8dbfef938bd550ac5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;borrower&lt;/code&gt; &amp;ndash; A &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;trio.hazmat.Task&lt;/code&gt;&lt;/a&gt; or arbitrary opaque object used to record who is borrowing this token; see &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of_nowait&quot;&gt;&lt;code&gt;acquire_on_behalf_of_nowait()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;borrower&lt;/code&gt; &amp;ndash;一个&lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt; &lt;code&gt;trio.hazmat.Task&lt;/code&gt; &lt;/a&gt;或任意不透明对象，用于记录谁在借用此令牌；有关详细信息，请参见&lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of_nowait&quot;&gt; &lt;code&gt;acquire_on_behalf_of_nowait()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c743acc9bc3e0874e5e27c3b6b53de4664abf68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;borrowers&lt;/code&gt;: A list of all tasks or other entities that currently hold a token.</source>
          <target state="translated">&lt;code&gt;borrowers&lt;/code&gt; ：当前持有令牌的所有任务或其他实体的列表。</target>
        </trans-unit>
        <trans-unit id="1ca252a9fc4a071afa1f0757fac085d9e3af70bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;broken1&lt;/code&gt; raises &lt;code&gt;KeyError&lt;/code&gt;. &lt;code&gt;broken2&lt;/code&gt; raises &lt;code&gt;IndexError&lt;/code&gt;. Obviously &lt;code&gt;parent&lt;/code&gt; should raise some error, but what? In some sense, the answer should be &amp;ldquo;both of these at once&amp;rdquo;, but in Python there can only be one exception at a time.</source>
          <target state="translated">&lt;code&gt;broken1&lt;/code&gt; 引发 &lt;code&gt;KeyError&lt;/code&gt; 异常。 &lt;code&gt;broken2&lt;/code&gt; 引发 &lt;code&gt;IndexError&lt;/code&gt; 。显然 &lt;code&gt;parent&lt;/code&gt; 应该提出一些错误，但是呢？从某种意义上说，答案应该是&amp;ldquo;一次全部&amp;rdquo;，但是在Python中一次只能有一个例外。</target>
        </trans-unit>
        <trans-unit id="e6eac22d9cac1a7ccb41256738a04eb6479e905d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cancellable&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Whether to allow cancellation of this operation. See discussion below.</source>
          <target state="translated">&lt;code&gt;cancellable&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;）&amp;ndash;是否允许取消此操作。请参阅下面的讨论。</target>
        </trans-unit>
        <trans-unit id="8460d73c85eb9a74fa84dacb8fc1250ae2e1d5e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;capture_stderr&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; If true, capture the bytes that the subprocess writes to its standard error stream and return them in the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; attribute of the returned &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;CompletedProcess&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;code&gt;capture_stderr&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;）&amp;ndash;如果为true，则捕获子进程写入其标准错误流的字节，并在返回的&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;CompletedProcess&lt;/code&gt; &lt;/a&gt;对象的&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt;属性中返回它们。</target>
        </trans-unit>
        <trans-unit id="f9d55fd3be056b54509b1cd066b363be0eb761cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;capture_stdout&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; If true, capture the bytes that the subprocess writes to its standard output stream and return them in the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; attribute of the returned &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;CompletedProcess&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;code&gt;capture_stdout&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;）&amp;ndash;如果为true，则捕获子进程写入其标准输出流的字节，并在返回的&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;CompletedProcess&lt;/code&gt; &lt;/a&gt;对象的&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;属性中返回它们。</target>
        </trans-unit>
        <trans-unit id="26e5c9c34fe9d980bcf61b99ecb8d833e5c6a87f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; If false, don&amp;rsquo;t validate that the subprocess exits successfully. You should be sure to check the &lt;code&gt;returncode&lt;/code&gt; attribute of the returned object if you pass &lt;code&gt;check=False&lt;/code&gt;, so that errors don&amp;rsquo;t pass silently.</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;）&amp;ndash;如果为false，则不验证子进程是否成功退出。如果传递 &lt;code&gt;check=False&lt;/code&gt; ，则应确保检查返回对象的 &lt;code&gt;returncode&lt;/code&gt; 属性，以使错误不会静默传递。</target>
        </trans-unit>
        <trans-unit id="198b0222758f8b2ab4eae3d94ae5d1370fc0fc2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clock&lt;/code&gt; &amp;ndash; &lt;code&gt;None&lt;/code&gt; to use the default system-specific monotonic clock; otherwise, an object implementing the &lt;a href=&quot;#trio.abc.Clock&quot;&gt;&lt;code&gt;trio.abc.Clock&lt;/code&gt;&lt;/a&gt; interface, like (for example) a &lt;a href=&quot;reference-testing#trio.testing.MockClock&quot;&gt;&lt;code&gt;trio.testing.MockClock&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;code&gt;clock&lt;/code&gt; &amp;ndash; &lt;code&gt;None&lt;/code&gt; 使用默认的系统特定单调时钟；否则，一个实现&lt;a href=&quot;#trio.abc.Clock&quot;&gt; &lt;code&gt;trio.abc.Clock&lt;/code&gt; &lt;/a&gt;接口的对象，例如（例如）&lt;a href=&quot;reference-testing#trio.testing.MockClock&quot;&gt; &lt;code&gt;trio.testing.MockClock&lt;/code&gt; &lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="860eda59b396acc32f124935a38e145c0d3045f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clogged_stream_maker&lt;/code&gt; &amp;ndash; Either None, or an async function similar to stream_maker, but with the extra property that the returned stream is in a state where &lt;code&gt;send_all&lt;/code&gt; and &lt;code&gt;wait_send_all_might_not_block&lt;/code&gt; will block until &lt;code&gt;receive_some&lt;/code&gt; has been called. This allows for more thorough testing of some edge cases, especially around &lt;code&gt;wait_send_all_might_not_block&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;clogged_stream_maker&lt;/code&gt; &amp;ndash;无，或类似于stream_maker的异步函数，但具有额外的属性，即返回的流处于 &lt;code&gt;send_all&lt;/code&gt; 和 &lt;code&gt;wait_send_all_might_not_block&lt;/code&gt; 处于阻塞状态，直到 &lt;code&gt;receive_some&lt;/code&gt; 的状态。这样可以对某些边缘情况进行更彻底的测试，尤其是在 &lt;code&gt;wait_send_all_might_not_block&lt;/code&gt; 周围。</target>
        </trans-unit>
        <trans-unit id="e779fb27fea43c8724925ef19c2fe9fd192b6d5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;close_hook&lt;/code&gt; &amp;ndash; A synchronous function, or None. Called from &lt;a href=&quot;#trio.testing.MemoryReceiveStream.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MemoryReceiveStream.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;close_hook&lt;/code&gt; &amp;ndash;同步函数，或无。从&lt;a href=&quot;#trio.testing.MemoryReceiveStream.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#trio.testing.MemoryReceiveStream.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt;调用。可以做任何你喜欢的事。</target>
        </trans-unit>
        <trans-unit id="8a2c41d8353693c8e391e1e84e166ceb5376daec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;close_hook&lt;/code&gt; &amp;ndash; A synchronous function, or None. Called from &lt;a href=&quot;#trio.testing.MemorySendStream.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MemorySendStream.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;close_hook&lt;/code&gt; &amp;ndash;同步函数，或无。从&lt;a href=&quot;#trio.testing.MemorySendStream.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#trio.testing.MemorySendStream.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt;调用。可以做任何你喜欢的事。</target>
        </trans-unit>
        <trans-unit id="7c0ec103234df050921b19320c94e21db604369a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;command&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;&lt;em&gt;list&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The command to run. Typically this is a sequence of strings such as &lt;code&gt;['ls', '-l', 'directory with spaces']&lt;/code&gt;, where the first element names the executable to invoke and the other elements specify its arguments. With &lt;code&gt;shell=True&lt;/code&gt; in the &lt;code&gt;**options&lt;/code&gt;, or on Windows, &lt;code&gt;command&lt;/code&gt; may alternatively be a string, which will be parsed following platform-dependent &lt;a href=&quot;#subprocess-quoting&quot;&gt;quoting rules&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;&lt;em&gt;list&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要运行的命令。通常，这是一个字符串序列，例如 &lt;code&gt;['ls', '-l', 'directory with spaces']&lt;/code&gt; ，其中第一个元素命名要调用的可执行文件，其他元素指定其参数。使用 &lt;code&gt;**options&lt;/code&gt; 中的 &lt;code&gt;shell=True&lt;/code&gt; 或在Windows上， &lt;code&gt;command&lt;/code&gt; 也可以是字符串，将根据平台相关的&lt;a href=&quot;#subprocess-quoting&quot;&gt;引用规则&lt;/a&gt;进行解析。</target>
        </trans-unit>
        <trans-unit id="40140e686bf510b2f8293cc2dd5df21d12c89cf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the number of tasks to move.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要移动的任务数。</target>
        </trans-unit>
        <trans-unit id="0379bcb0cf80c0ae9106a2c0e8751a5cad9def29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the number of tasks to unpark.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要取消驻留的任务数。</target>
        </trans-unit>
        <trans-unit id="690dccb2485b6c1efd90c85b494cf8f0b08f1e98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current_buffer_used&lt;/code&gt;: The number of items currently stored in the channel buffer.</source>
          <target state="translated">&lt;code&gt;current_buffer_used&lt;/code&gt; ：当前存储在通道缓冲区中的项目数。</target>
        </trans-unit>
        <trans-unit id="dadcc8231dcf4bb29a9204af389689c14e03ab19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytearray&quot;&gt;&lt;em&gt;bytearray&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#memoryview&quot;&gt;&lt;em&gt;memoryview&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The data to send.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;字节&lt;/em&gt;&lt;/a&gt;&lt;em&gt;，&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytearray&quot;&gt;&lt;em&gt;字节组&lt;/em&gt;&lt;/a&gt;&lt;em&gt;，或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#memoryview&quot;&gt;&lt;em&gt;memoryview&lt;/em&gt;&lt;/a&gt;） -的数据要发送。</target>
        </trans-unit>
        <trans-unit id="9e0bcc2df98273163a158aa7256e7c594257e9ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deadline&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The absolute time of the next deadline, according to this clock.</source>
          <target state="translated">&lt;code&gt;deadline&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;）&amp;ndash;根据该时钟的下一个截止日期的绝对时间。</target>
        </trans-unit>
        <trans-unit id="6fb54f7efa2bdbb464a3fe3aba7d3a68dc645d31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deadline&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The deadline.</source>
          <target state="translated">&lt;code&gt;deadline&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;）&amp;ndash;截止日期。</target>
        </trans-unit>
        <trans-unit id="8667fcbc6dd78d180064c9e81498909f565d4887" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deadline&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The time at which we should wake up again. May be in the past, in which case this function executes a checkpoint but does not block.</source>
          <target state="translated">&lt;code&gt;deadline&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;浮动&lt;/em&gt;&lt;/a&gt;）&amp;ndash;我们应该再次醒来的时间。可能是过去的情况，在这种情况下，此函数将执行检查点，但不会阻塞。</target>
        </trans-unit>
        <trans-unit id="77800851c9fc95abd8c97c6f9ad88ec4eff08a62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exceptions&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;&lt;em&gt;list&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The exceptions</source>
          <target state="translated">&lt;code&gt;exceptions&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;&lt;em&gt;列表&lt;/em&gt;&lt;/a&gt;）&amp;ndash;例外</target>
        </trans-unit>
        <trans-unit id="d5fa2991cffd7cd3200dc0f2e56873f167c346ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fd&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The fd to be wrapped.</source>
          <target state="translated">&lt;code&gt;fd&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要包装的fd。</target>
        </trans-unit>
        <trans-unit id="6415289b25910c926cfd7391cdb9f60b2e28f3d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file&lt;/code&gt; &amp;ndash; a &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;文件对象&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f0bf27129b492aab1ef62b22db0bcaa1bf5497cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The filename to open the connection to.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;字符串&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;字节&lt;/em&gt;&lt;/a&gt;）&amp;ndash;打开连接的文件名。</target>
        </trans-unit>
        <trans-unit id="87836835d2fe68db69d0949466e77097175300f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;final_outcome&lt;/code&gt; (&lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;em&gt;outcome.Outcome&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Trio acts as if the current task exited with the given return value or exception.</source>
          <target state="translated">&lt;code&gt;final_outcome&lt;/code&gt; （&lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;em&gt;outcome.Outcome&lt;/em&gt;&lt;/a&gt;） -仿佛当前任务与给定的返回值或异常退出三重奏的作用。</target>
        </trans-unit>
        <trans-unit id="157ed0b8e932f730a0991b1a4ea88e6876050de6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle&lt;/code&gt; &amp;ndash; A Win32 object handle, as a Python integer.</source>
          <target state="translated">&lt;code&gt;handle&lt;/code&gt; &amp;ndash;一个Win32对象句柄，为Python整数。</target>
        </trans-unit>
        <trans-unit id="e1f256647adeb8c7357b02329e2fb43f4013fc47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; &amp;ndash; A callable that takes an atomic (non-MultiError) exception as input, and returns either a new exception object or None.</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; &amp;ndash; 处理程序 &amp;ndash;一个可调用的方法，将原子（非MultiError）异常作为输入，并返回新的异常对象或None。</target>
        </trans-unit>
        <trans-unit id="e21bd96821ba01f78d8d00051deaba8766ae0ec1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; &amp;ndash; An async callable, that will be invoked like &lt;code&gt;handler_nursery.start_soon(handler, stream)&lt;/code&gt; for each incoming connection.</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; &amp;ndash;一个异步可调用对象，它将为每个传入连接像 &lt;code&gt;handler_nursery.start_soon(handler, stream)&lt;/code&gt; 一样被调用。</target>
        </trans-unit>
        <trans-unit id="a3090b03f0ea95979f385025f5e9b720564d49b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; &amp;ndash; The handler to start for each incoming connection. Passed to &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; &amp;ndash;为每个传入连接启动的处理程序。传递给&lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc9c1209bc96d45713b43b4c11b9c22fcd87dff4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; &amp;ndash; as for &lt;a href=&quot;#trio.MultiError.filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; &amp;ndash;对于&lt;a href=&quot;#trio.MultiError.filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56eeeda767ac09256570229477d193d581421b60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler_nursery&lt;/code&gt; &amp;ndash; The nursery to start handlers in, or None to use an internal nursery. Passed to &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;handler_nursery&lt;/code&gt; &amp;ndash;要在其中启动处理程序的托儿所，或&amp;ldquo;无&amp;rdquo;以使用内部托儿所。传递给&lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4af545c35c53e61365a8ac2fa1e98f8b1d35398e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler_nursery&lt;/code&gt; &amp;ndash; The nursery used to start handlers, or any object with a &lt;code&gt;start_soon&lt;/code&gt; method. If &lt;code&gt;None&lt;/code&gt; (the default), then &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; will create a new nursery internally and use that.</source>
          <target state="translated">&lt;code&gt;handler_nursery&lt;/code&gt; &amp;ndash;用于启动处理程序或任何具有 &lt;code&gt;start_soon&lt;/code&gt; 方法的对象的托儿所。如果 &lt;code&gt;None&lt;/code&gt; （默认值），那么&lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt;将在内部创建一个新的托儿所并使用它。</target>
        </trans-unit>
        <trans-unit id="bebdc09baf7871b5bce3ae32b267627c6ae9fe02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;happy_eyeballs_delay&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; How many seconds to wait for each connection attempt to succeed or fail before getting impatient and starting another one in parallel. Set to &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;math.inf&lt;/code&gt;&lt;/a&gt; if you want to limit to only one connection attempt at a time (like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.create_connection&quot;&gt;&lt;code&gt;socket.create_connection()&lt;/code&gt;&lt;/a&gt;). Default: 0.3 (300 ms).</source>
          <target state="translated">&lt;code&gt;happy_eyeballs_delay&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;）&amp;ndash;在失去耐心并并行启动另一个连接之前，等待每个连接尝试成功或失败的秒数。如果您想一次只限制一次连接尝试，请设置为&lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;math.inf&lt;/code&gt; &lt;/a&gt;（例如&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.create_connection&quot;&gt; &lt;code&gt;socket.create_connection()&lt;/code&gt; &lt;/a&gt;）。默认值：0.3（300毫秒）。</target>
        </trans-unit>
        <trans-unit id="affa03c7e502c2fc86242cb0d11615285683394e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;happy_eyeballs_delay&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; See &lt;a href=&quot;#trio.open_tcp_stream&quot;&gt;&lt;code&gt;open_tcp_stream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;happy_eyeballs_delay&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;）&amp;ndash;请参见&lt;a href=&quot;#trio.open_tcp_stream&quot;&gt; &lt;code&gt;open_tcp_stream()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dbac9a1a6994581b4b38e452eec92143adbf0523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The host to connect to. We require the server to have a TLS certificate valid for this hostname.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;字节&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要连接的主机。我们要求服务器具有对此主机名有效的TLS证书。</target>
        </trans-unit>
        <trans-unit id="8f31351856ccab3985f0e467499257fe16d6e8cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The host to connect to. Can be an IPv4 address, IPv6 address, or a hostname.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要连接的主机。可以是IPv4地址，IPv6地址或主机名。</target>
        </trans-unit>
        <trans-unit id="85169f444121eecc3bcbc7a396753fa7e069ed42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The address to bind to; use &lt;code&gt;None&lt;/code&gt; to bind to the wildcard address. See &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;，&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要绑定的地址；使用 &lt;code&gt;None&lt;/code&gt; 绑定到通配符地址。参见&lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b00dff8ee9e060b0c31fa547f761bf83cd361d67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The address to bind to; use &lt;code&gt;None&lt;/code&gt; to bind to the wildcard address. Ultimately passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;，&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要绑定的地址；使用 &lt;code&gt;None&lt;/code&gt; 绑定到通配符地址。最终传递给&lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc4d39307a6d0cd1247b70528e7586e71641b59a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The host interface to listen on; use &lt;code&gt;None&lt;/code&gt; to bind to the wildcard address. Passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;，&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要监听的主机接口；使用 &lt;code&gt;None&lt;/code&gt; 绑定到通配符地址。传递给&lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3396b6088cb6d8d54f175511526c66926034c4de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;bytes-like&lt;/em&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;，&lt;/em&gt;&lt;em&gt;类似字节&lt;/em&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;无&lt;/em&gt;&lt;/a&gt;）&amp;ndash;</target>
        </trans-unit>
        <trans-unit id="074be0b2389e540f899b65e8e67b72f995eaf623" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hostname_resolver&lt;/code&gt; (&lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;em&gt;trio.abc.HostnameResolver&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The new custom hostname resolver, or None to restore the default behavior.</source>
          <target state="translated">&lt;code&gt;hostname_resolver&lt;/code&gt; （&lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;em&gt;trio.abc.HostnameResolver&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;）&amp;ndash;新的自定义主机名解析器，或者为None以恢复默认行为。</target>
        </trans-unit>
        <trans-unit id="0d50447b98e80a0aea797f5d7a937152a4614467" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;）&amp;ndash;</target>
        </trans-unit>
        <trans-unit id="5babef15cad79840bbc9adbb50fdc59ccaa1cac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Passed on to &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;）&amp;ndash;传递给&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27c5784b8bbd8392a7507a351b92d3c67de27f32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; See &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;）&amp;ndash;有关详细信息，请参见&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="187c968d569e623f5011cfb88a3f14e72456d0d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Set this to True if you want to use &amp;ldquo;HTTPS-style&amp;rdquo; TLS. See &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;）&amp;ndash;如果要使用&amp;ldquo; HTTPS样式&amp;rdquo; TLS，请将其设置为True。有关详细信息，请参见&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d55552e0dd68f23f3e02c52abf767ab3de478c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Set this to True if you&amp;rsquo;re connecting to a web server. See &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; for details. Default: False.</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;）&amp;ndash;如果要连接到Web服务器，请将其设置为True。有关详细信息，请参见&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;。默认值：False。</target>
        </trans-unit>
        <trans-unit id="5707c6a5ce826447ce17e91733c254fe69ab1010" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initial_value&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; A non-negative integer giving semaphore&amp;rsquo;s initial value.</source>
          <target state="translated">&lt;code&gt;initial_value&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;）&amp;ndash;一个非负整数，给出信号量的初始值。</target>
        </trans-unit>
        <trans-unit id="14019ce35d114be701b9b9da974d5295aa5190b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instrument&lt;/code&gt; (&lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;em&gt;trio.abc.Instrument&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The instrument to activate.</source>
          <target state="translated">&lt;code&gt;instrument&lt;/code&gt; （&lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;em&gt;trio.abc.Instrument&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要激活的工具。</target>
        </trans-unit>
        <trans-unit id="55e2a6f69308acbcba045cfc0acd6c283a528e56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instrument&lt;/code&gt; (&lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;em&gt;trio.abc.Instrument&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The instrument to de-activate.</source>
          <target state="translated">&lt;code&gt;instrument&lt;/code&gt; （&lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;em&gt;trio.abc.Instrument&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要&lt;em&gt;停用&lt;/em&gt;的工具。</target>
        </trans-unit>
        <trans-unit id="58bb2b928e47ff336aa159dab8cacf8b0830e93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instruments&lt;/code&gt; (list of &lt;a href=&quot;reference-hazmat#trio.abc.Instrument&quot;&gt;&lt;code&gt;trio.abc.Instrument&lt;/code&gt;&lt;/a&gt; objects) &amp;ndash; Any instrumentation you want to apply to this run. This can also be modified during the run; see &lt;a href=&quot;reference-hazmat#instrumentation&quot;&gt;Instrument API&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;instruments&lt;/code&gt; （&lt;a href=&quot;reference-hazmat#trio.abc.Instrument&quot;&gt; &lt;code&gt;trio.abc.Instrument&lt;/code&gt; &lt;/a&gt;对象的列表）&amp;ndash;您要应用于此运行的任何仪器。也可以在运行期间进行修改；参见&lt;a href=&quot;reference-hazmat#instrumentation&quot;&gt;Instrument API&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ae228be9cdd956ffb549d3563e530e30e9b16eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_statistics&lt;/code&gt; (object): Some statistics from Trio&amp;rsquo;s I/O backend. This always has an attribute &lt;code&gt;backend&lt;/code&gt; which is a string naming which operating-system-specific I/O backend is in use; the other attributes vary between backends.</source>
          <target state="translated">&lt;code&gt;io_statistics&lt;/code&gt; （对象）：来自Trio的I / O后端的一些统计信息。它始终具有一个属性 &lt;code&gt;backend&lt;/code&gt; ，该后端是一个字符串命名，使用的是特定于操作系统的I / O后端。其他属性在后端之间有所不同。</target>
        </trans-unit>
        <trans-unit id="caa0288e42c5ed7aa4d4abe45de8d1a8397f2ac7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limiter&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;em&gt;CapacityLimiter-like object&lt;/em&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;limiter&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;无&lt;/em&gt;&lt;/a&gt;&lt;em&gt;，或&lt;/em&gt;&lt;em&gt;类似CapacityLimiter的对象&lt;/em&gt;）&amp;ndash;</target>
        </trans-unit>
        <trans-unit id="e6b3136ebabc2e2d4a623b203fdbb4407f1a6cf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;listeners&lt;/code&gt; &amp;ndash; A list of &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; objects. &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; takes responsibility for closing them.</source>
          <target state="translated">&lt;code&gt;listeners&lt;/code&gt; &amp;ndash; &lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt;对象列表。&lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt;负责关闭它们。</target>
        </trans-unit>
        <trans-unit id="603520e5b0c2ec38ba7849c079a95865966b8532" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock&lt;/code&gt; (&lt;a href=&quot;#trio.Lock&quot;&gt;&lt;em&gt;Lock&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the lock object to use. If given, must be a &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;trio.Lock&lt;/code&gt;&lt;/a&gt;. If None, a new &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; will be allocated and used.</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; （&lt;a href=&quot;#trio.Lock&quot;&gt;&lt;em&gt;Lock&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要使用的锁定对象。如果给定，则必须为&lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;trio.Lock&lt;/code&gt; &lt;/a&gt;。如果为None，将分配并使用一个新的&lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f95ec20797af7c898f2ac2ba1019bff94a70685" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock_statistics&lt;/code&gt;: The result of calling the underlying &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;s &lt;a href=&quot;#trio.Lock.statistics&quot;&gt;&lt;code&gt;statistics()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;lock_statistics&lt;/code&gt; ：调用基础&lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;#trio.Lock.statistics&quot;&gt; &lt;code&gt;statistics()&lt;/code&gt; &lt;/a&gt;方法的结果。</target>
        </trans-unit>
        <trans-unit id="618a487482254c3b69d5735a445c55798f94a09f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;locked&lt;/code&gt;: boolean indicating whether the lock is held.</source>
          <target state="translated">&lt;code&gt;locked&lt;/code&gt; ：布尔值，指示是否持有锁。</target>
        </trans-unit>
        <trans-unit id="f10292d0fadb857c306a0dc5948de94c6800fa10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_buffer_size&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;em&gt;math.inf&lt;/em&gt;) &amp;ndash; The maximum number of items that can be buffered in the channel before &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; blocks. Choosing a sensible value here is important to ensure that backpressure is communicated promptly and avoid unnecessary latency; see &lt;a href=&quot;#channel-buffering&quot;&gt;Buffering in channels&lt;/a&gt; for more details. If in doubt, use 0.</source>
          <target state="translated">&lt;code&gt;max_buffer_size&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;em&gt;math.inf&lt;/em&gt;）&amp;ndash; &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt;块之前可以在通道中缓冲的最大项目数。在此处选择一个合理的值对于确保及时传达背压并避免不必要的延迟很重要。有关更多详细信息，请参见&lt;a href=&quot;#channel-buffering&quot;&gt;在通道中缓冲&lt;/a&gt;。如有疑问，请使用0。</target>
        </trans-unit>
        <trans-unit id="c36c15f6dc63bafb000356c2e369cf94cea73a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_buffer_size&lt;/code&gt;: The maximum number of items allowed in the buffer, as passed to &lt;a href=&quot;#trio.open_memory_channel&quot;&gt;&lt;code&gt;open_memory_channel()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;max_buffer_size&lt;/code&gt; ：传递给&lt;a href=&quot;#trio.open_memory_channel&quot;&gt; &lt;code&gt;open_memory_channel()&lt;/code&gt; &lt;/a&gt;的缓冲区中允许的最大项目数。</target>
        </trans-unit>
        <trans-unit id="fb8421a300b0d79f331765927482a9927d7ef8ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_bytes&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The maximum number of bytes to return. Must be greater than zero. Optional; if omitted, then the stream object is free to pick a reasonable default.</source>
          <target state="translated">&lt;code&gt;max_bytes&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要返回的最大字节数。必须大于零。可选的; 如果省略，则流对象可以自由选择合理的默认值。</target>
        </trans-unit>
        <trans-unit id="64d7e5bd2cb1a725ab3e6f7c27796809e159dfc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_bytes&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The maximum amount of data to retrieve. None (the default) means to retrieve all the data that&amp;rsquo;s present (but still blocks until at least one byte is available).</source>
          <target state="translated">&lt;code&gt;max_bytes&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要检索的最大数据量。无（默认）是指检索存在的所有数据（但仍会阻塞，直到至少有一个字节可用为止）。</target>
        </trans-unit>
        <trans-unit id="1c0b9268404ebe0c19a43e52b1e0a3c679151746" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_bytes&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The maximum amount of data to transfer in this call, or None to transfer all available data.</source>
          <target state="translated">&lt;code&gt;max_bytes&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;）&amp;ndash;在此调用中要传输的最大数据量，或在None时传输所有可用数据。</target>
        </trans-unit>
        <trans-unit id="73ab6bec5c64069d56daa42b165b5ad34cc59b85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_value&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; If given, makes this a &amp;ldquo;bounded&amp;rdquo; semaphore that raises an error if the value is about to exceed the given &lt;code&gt;max_value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;max_value&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;）&amp;ndash;如果给定，则使它成为&amp;ldquo;有界&amp;rdquo;信号量，如果值即将超过给定的 &lt;code&gt;max_value&lt;/code&gt; ,则会引发错误。</target>
        </trans-unit>
        <trans-unit id="a7f5017fe0d3b3ed322b7919d7d0f3d41211f091" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;memory_receive_stream&lt;/code&gt; (&lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;em&gt;MemoryReceiveStream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream to put data into.</source>
          <target state="translated">&lt;code&gt;memory_receive_stream&lt;/code&gt; （&lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;em&gt;MemoryReceiveStream&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要放入数据的流。</target>
        </trans-unit>
        <trans-unit id="654314fb938a88ac66124f8a48ddf7ed1de7b204" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;memory_send_stream&lt;/code&gt; (&lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;em&gt;MemorySendStream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream to get data from.</source>
          <target state="translated">&lt;code&gt;memory_send_stream&lt;/code&gt; （&lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;em&gt;MemorySendStream&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要从中获取数据的流。</target>
        </trans-unit>
        <trans-unit id="f87ec8fb8d6920675823afbf0256991664011220" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The number of tasks to wake.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要唤醒的任务数。</target>
        </trans-unit>
        <trans-unit id="706088dfef3e603575862e367adff10e8633b7eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; &amp;ndash; The name for this task. Only used for debugging/introspection (e.g. &lt;code&gt;repr(task_obj)&lt;/code&gt;). If this isn&amp;rsquo;t a string, &lt;a href=&quot;#trio.Nursery.start_soon&quot;&gt;&lt;code&gt;start_soon()&lt;/code&gt;&lt;/a&gt; will try to make it one. A common use case is if you&amp;rsquo;re wrapping a function before spawning a new task, you might pass the original function as the &lt;code&gt;name=&lt;/code&gt; to make debugging easier.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; -此任务的名称。仅用于调试/自检（例如 &lt;code&gt;repr(task_obj)&lt;/code&gt; ）。如果不是字符串，则&lt;a href=&quot;#trio.Nursery.start_soon&quot;&gt; &lt;code&gt;start_soon()&lt;/code&gt; &lt;/a&gt;会尝试将其设置为一个。一个常见的用例是，如果在产生新任务之前包装了一个函数，则可以将原始函数作为 &lt;code&gt;name=&lt;/code&gt; 传递，以使调试更加容易。</target>
        </trans-unit>
        <trans-unit id="85f9eda5653f8aa6042815ed9751de5914613b1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; &amp;ndash; The name for this task. Only used for debugging/introspection (e.g. &lt;code&gt;repr(task_obj)&lt;/code&gt;). If this isn&amp;rsquo;t a string, &lt;a href=&quot;#trio.hazmat.spawn_system_task&quot;&gt;&lt;code&gt;spawn_system_task()&lt;/code&gt;&lt;/a&gt; will try to make it one. A common use case is if you&amp;rsquo;re wrapping a function before spawning a new task, you might pass the original function as the &lt;code&gt;name=&lt;/code&gt; to make debugging easier.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; -此任务的名称。仅用于调试/自检（例如 &lt;code&gt;repr(task_obj)&lt;/code&gt; ）。如果这不是字符串，&lt;a href=&quot;#trio.hazmat.spawn_system_task&quot;&gt; &lt;code&gt;spawn_system_task()&lt;/code&gt; &lt;/a&gt;会尝试将其设置为一个。一个常见的用例是，如果在产生新任务之前包装了一个函数，则可以将原始函数作为 &lt;code&gt;name=&lt;/code&gt; 传递，以使调试更加容易。</target>
        </trans-unit>
        <trans-unit id="39ac8639a60221cedf2bb1578c2d5ec107ccc51d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_lot&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;em&gt;ParkingLot&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the parking lot to move tasks to.</source>
          <target state="translated">&lt;code&gt;new_lot&lt;/code&gt; （&lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;em&gt;ParkingLot&lt;/em&gt;&lt;/a&gt;）&amp;ndash;将任务移至的停车场。</target>
        </trans-unit>
        <trans-unit id="35e6f7353e18ba4378af44a443eab3903e024291" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;next_send&lt;/code&gt; (&lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;em&gt;outcome.Outcome&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the value (or error) to return (or raise) from &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;next_send&lt;/code&gt; （&lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;em&gt;outcome.Outcome&lt;/em&gt;&lt;/a&gt;） -值（或错误）从返回（或提高）&lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af7731c5998c5de2534323659b85fd3f1e7fa3a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_receive_channels&lt;/code&gt;: Likewise, but for open &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt;&lt;code&gt;MemoryReceiveChannel&lt;/code&gt;&lt;/a&gt; endpoints.</source>
          <target state="translated">&lt;code&gt;open_receive_channels&lt;/code&gt; ：同样，但用于开放的&lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt; &lt;code&gt;MemoryReceiveChannel&lt;/code&gt; &lt;/a&gt;端点。</target>
        </trans-unit>
        <trans-unit id="264c8c4e59d3770d771de5e9cb09326c7244420f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_send_channels&lt;/code&gt;: The number of open &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; endpoints pointing to this channel. Initially 1, but can be increased by &lt;a href=&quot;#trio.MemorySendChannel.clone&quot;&gt;&lt;code&gt;MemorySendChannel.clone()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;open_send_channels&lt;/code&gt; ：指向此通道的打开的&lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt;端点的数量。最初为1，但可以通过&lt;a href=&quot;#trio.MemorySendChannel.clone&quot;&gt; &lt;code&gt;MemorySendChannel.clone()&lt;/code&gt; &lt;/a&gt;增加。</target>
        </trans-unit>
        <trans-unit id="f687cd0584184d32b7163dd5ec69eb308effa6c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;owner&lt;/code&gt;: the &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;trio.hazmat.Task&lt;/code&gt;&lt;/a&gt; currently holding the lock, or None if the lock is not held.</source>
          <target state="translated">&lt;code&gt;owner&lt;/code&gt; ：当前持有锁的&lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt; &lt;code&gt;trio.hazmat.Task&lt;/code&gt; ;&lt;/a&gt;如果未持有锁，则为None。</target>
        </trans-unit>
        <trans-unit id="1201160a78a8e4af5f332f34959d7081ecbb90c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; &amp;ndash; The port to listen on. Use 0 to let the kernel pick an open port. Passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; &amp;ndash;要监听的端口。使用0让内核选择一个开放的端口。传递给&lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bbf694beba17ba8adf62f6d69c28af08e967d77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;）&amp;ndash;</target>
        </trans-unit>
        <trans-unit id="6d4d205a129177b41813c6bde450d0de597a83b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The port to connect to.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要连接的端口。</target>
        </trans-unit>
        <trans-unit id="688b71efb4d8d1187d700c0a0a375d12061437c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The port to listen on. See &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要监听的端口。参见&lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6309fbbaf79fb15176a3bcd81d0cc6f8c70527f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The port to listen on. Use 0 to let the kernel pick an open port. Ultimately passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要监听的端口。使用0让内核选择一个开放的端口。最终传递给&lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="891c4fdd705213cb6ca14177bb92af31c1871a82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rate&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the initial &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;rate&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;）&amp;ndash;初始&lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99c33b6b52375c26e1c14f1877e1ed8f50108db9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receive_some_hook&lt;/code&gt; &amp;ndash; An async function, or None. Called from &lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;receive_some_hook&lt;/code&gt; &amp;ndash;异步函数，或无。从&lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; 调用&lt;/a&gt;。可以做任何你喜欢的事。</target>
        </trans-unit>
        <trans-unit id="05cee52381c53f6a92a6ebb9f868a6940a98367b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receive_stream&lt;/code&gt; (&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;em&gt;ReceiveStream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream to use for receiving.</source>
          <target state="translated">&lt;code&gt;receive_stream&lt;/code&gt; （&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;em&gt;ReceiveStream&lt;/em&gt;&lt;/a&gt;）&amp;ndash;用于接收的流。</target>
        </trans-unit>
        <trans-unit id="83019553ed11c5b0a2f12316aebdf4dfe58596ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;restrict_keyboard_interrupt_to_checkpoints&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;restrict_keyboard_interrupt_to_checkpoints&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;）&amp;ndash;</target>
        </trans-unit>
        <trans-unit id="80c4c0dd0899149a98e2267e9e03ce41e17d8e50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;root_exc&lt;/code&gt; &amp;ndash; An exception, often (though not necessarily) a &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;root_exc&lt;/code&gt; &amp;ndash;一个异常，通常（但不一定）是&lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23ac615251cbc92f776d4eb5dd37246a0f6e203a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_sync_soon_queue_size&lt;/code&gt; (int): The number of unprocessed callbacks queued via &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt;&lt;code&gt;trio.hazmat.TrioToken.run_sync_soon()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;run_sync_soon_queue_size&lt;/code&gt; （int）：通过&lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt; &lt;code&gt;trio.hazmat.TrioToken.run_sync_soon()&lt;/code&gt; &lt;/a&gt;排队的未处理的回调数。</target>
        </trans-unit>
        <trans-unit id="0a7302082e39ea79ec9eaeeeac0d9e7da2f2ba73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The number of seconds to sleep. May be zero to insert a checkpoint without actually blocking.</source>
          <target state="translated">&lt;code&gt;seconds&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;）&amp;ndash;睡眠的秒数。在不实际阻止的情况下插入检查点可能为零。</target>
        </trans-unit>
        <trans-unit id="71ade4f6da2a5244cad20deaa5a3a696936a36b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The timeout.</source>
          <target state="translated">&lt;code&gt;seconds&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;）&amp;ndash;超时。</target>
        </trans-unit>
        <trans-unit id="32fe1f6ae1e106de0d3baafe02009b4b950630f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the number of seconds to jump the clock forward.</source>
          <target state="translated">&lt;code&gt;seconds&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;）&amp;ndash;向前跳时钟的秒数。</target>
        </trans-unit>
        <trans-unit id="18d4f5b4bc1104d436c602e9f9a08574a1159caf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds_to_next_deadline&lt;/code&gt; (float): The time until the next pending cancel scope deadline. May be negative if the deadline has expired but we haven&amp;rsquo;t yet processed cancellations. May be &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt; if there are no pending deadlines.</source>
          <target state="translated">&lt;code&gt;seconds_to_next_deadline&lt;/code&gt; （浮动）：直到下一个挂起的取消作用域截止日期的时间。如果截止日期已过，但我们尚未处理取消，则可能为负。如果没有等待的截止日期，则可能为&lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="425704c4d337d3cfd23941c9ff81629105fbe7a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;send_all_hook&lt;/code&gt; &amp;ndash; An async function, or None. Called from &lt;a href=&quot;#trio.testing.MemorySendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;send_all_hook&lt;/code&gt; &amp;ndash;异步函数，或无。从&lt;a href=&quot;#trio.testing.MemorySendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt;调用。可以做任何你喜欢的事。</target>
        </trans-unit>
        <trans-unit id="c64d4f7072233419756f70e991aa5c980c32bdd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;send_stream&lt;/code&gt; (&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;em&gt;SendStream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream to use for sending.</source>
          <target state="translated">&lt;code&gt;send_stream&lt;/code&gt; （&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;em&gt;SendStream&lt;/em&gt;&lt;/a&gt;）&amp;ndash;用于发送的流。</target>
        </trans-unit>
        <trans-unit id="eaaf6a4ba68b4eabf4bb722fc4dec40bd05dc617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server_hostname&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The name of the server being connected to. Used for &lt;a href=&quot;https://en.wikipedia.org/wiki/Server_Name_Indication&quot;&gt;SNI&lt;/a&gt; and for validating the server&amp;rsquo;s certificate (if hostname checking is enabled). This is effectively mandatory for clients, and actually mandatory if &lt;code&gt;ssl_context.check_hostname&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;server_hostname&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要连接的服务器的名称。用于&lt;a href=&quot;https://en.wikipedia.org/wiki/Server_Name_Indication&quot;&gt;SNI&lt;/a&gt;和验证服务器的证书（如果启用了主机名检查）。这对于客户端实际上是强制性的，如果 &lt;code&gt;ssl_context.check_hostname&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ，则实际上是强制性的。</target>
        </trans-unit>
        <trans-unit id="5fce58df86f9353ab8c11cd3da5a14acf3b35213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server_side&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Whether this stream is acting as a client or server. Defaults to False, i.e. client mode.</source>
          <target state="translated">&lt;code&gt;server_side&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;）&amp;ndash;该流是充当客户端还是服务器。默认为False，即客户端模式。</target>
        </trans-unit>
        <trans-unit id="fd831c422b81adc17c1c840d7c7aa39b79546dcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signals&lt;/code&gt; &amp;ndash; the signals to listen for.</source>
          <target state="translated">&lt;code&gt;signals&lt;/code&gt; &amp;ndash;要监听的信号。</target>
        </trans-unit>
        <trans-unit id="625912886efc60b616144fe727ff83d70132ecbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;socket&lt;/code&gt; &amp;ndash; The Trio socket object to wrap. Must have type &lt;code&gt;SOCK_STREAM&lt;/code&gt;, and be connected.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; &amp;ndash;要包装的Trio套接字对象。必须具有 &lt;code&gt;SOCK_STREAM&lt;/code&gt; 类型，并已连接。</target>
        </trans-unit>
        <trans-unit id="2c1de1f3e683851cbc2557271aa46b50d8af5d8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;socket&lt;/code&gt; &amp;ndash; The Trio socket object to wrap. Must have type &lt;code&gt;SOCK_STREAM&lt;/code&gt;, and be listening.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; &amp;ndash;要包装的Trio套接字对象。必须具有 &lt;code&gt;SOCK_STREAM&lt;/code&gt; 类型，并且正在侦听。</target>
        </trans-unit>
        <trans-unit id="ce3d562bcdafe947f34d36bf33565287516fe229" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;socket_factory&lt;/code&gt; (&lt;a href=&quot;#trio.abc.SocketFactory&quot;&gt;&lt;em&gt;trio.abc.SocketFactory&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The new custom socket factory, or None to restore the default behavior.</source>
          <target state="translated">&lt;code&gt;socket_factory&lt;/code&gt; （&lt;a href=&quot;#trio.abc.SocketFactory&quot;&gt;&lt;em&gt;trio.abc.SocketFactory&lt;/em&gt;&lt;/a&gt;&lt;em&gt;或&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;）&amp;ndash;新的自定义套接字工厂，或者为None来恢复默认行为。</target>
        </trans-unit>
        <trans-unit id="bd2352b22dc29b6e0af410069d9b9b812fbb387b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;socket_listener&lt;/code&gt; (&lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt;&lt;em&gt;SocketListener&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The &lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt; to connect to.</source>
          <target state="translated">&lt;code&gt;socket_listener&lt;/code&gt; （&lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt;&lt;em&gt;SocketListener&lt;/em&gt;&lt;/a&gt;）&amp;ndash; 要连接的&lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7938a9a43d222d0ab03f10ecc37e3195daae0b3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; or None) &amp;ndash; The SSL context to use. If None (the default), &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt;&lt;code&gt;ssl.create_default_context()&lt;/code&gt;&lt;/a&gt; will be called to create a context.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt;或无）&amp;ndash;要使用的SSL上下文。如果为None（默认值），&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt; &lt;code&gt;ssl.create_default_context()&lt;/code&gt; &lt;/a&gt;调用ssl.create_default_context（）创建上下文。</target>
        </trans-unit>
        <trans-unit id="aa3044a40c6a954d50347bd2af50ae331d1a87b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; that will be used for incoming connections.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;）&amp;ndash; 将用于传入连接的&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2fb8dccd8c914b1156c75e0c98d5855b88fb786" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; used for this connection. Required. Usually created by calling &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt;&lt;code&gt;ssl.create_default_context()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;）&amp;ndash; 用于此连接的&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt;。需要。通常通过调用&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt; &lt;code&gt;ssl.create_default_context()&lt;/code&gt; &lt;/a&gt;创建。</target>
        </trans-unit>
        <trans-unit id="1ab419f61b2ec42100b332c8c5e546b3e229c548" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The SSL context to use for all incoming connections.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;）&amp;ndash;用于所有传入连接的SSL上下文。</target>
        </trans-unit>
        <trans-unit id="7755b90b4b9fc8ce6579cc8ad4420b411fd8ae29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The SSL context to use for all incoming connections. Passed to &lt;a href=&quot;#trio.open_ssl_over_tcp_listeners&quot;&gt;&lt;code&gt;open_ssl_over_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;）&amp;ndash;用于所有传入连接的SSL上下文。传递给&lt;a href=&quot;#trio.open_ssl_over_tcp_listeners&quot;&gt; &lt;code&gt;open_ssl_over_tcp_listeners()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47ae01c666f68b1ba6200b2b9ccda68490f6c9ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stderr&lt;/code&gt; &amp;ndash; Like &lt;code&gt;stdin&lt;/code&gt;, but for the child process&amp;rsquo;s standard error stream. An additional value &lt;code&gt;subprocess.STDOUT&lt;/code&gt; is supported, which causes the child&amp;rsquo;s standard output and standard error messages to be intermixed on a single standard output stream, attached to whatever the &lt;code&gt;stdout&lt;/code&gt; option says to attach it to.</source>
          <target state="translated">&lt;code&gt;stderr&lt;/code&gt; &amp;ndash;与 &lt;code&gt;stdin&lt;/code&gt; 相似，但用于子进程的标准错误流。支持附加值 &lt;code&gt;subprocess.STDOUT&lt;/code&gt; ，这会使子级的标准输出和标准错误消息混合在单个标准输出流上，并附加到 &lt;code&gt;stdout&lt;/code&gt; 选项说要附加的内容上。</target>
        </trans-unit>
        <trans-unit id="c233d6ac159ddccb9de47ea18b335506c1a26ee1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stdin&lt;/code&gt; &amp;ndash; Specifies what the child process&amp;rsquo;s standard input stream should connect to: output written by the parent (&lt;code&gt;subprocess.PIPE&lt;/code&gt;), nothing (&lt;code&gt;subprocess.DEVNULL&lt;/code&gt;), or an open file (pass a file descriptor or something whose &lt;code&gt;fileno&lt;/code&gt; method returns one). If &lt;code&gt;stdin&lt;/code&gt; is unspecified, the child process will have the same standard input stream as its parent.</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; &amp;ndash;指定子进程的标准输入流应连接到的内容：父级写的输出（ &lt;code&gt;subprocess.PIPE&lt;/code&gt; ），什么都没有（ &lt;code&gt;subprocess.DEVNULL&lt;/code&gt; ）或打开的文件（传递文件描述符或通过其 &lt;code&gt;fileno&lt;/code&gt; 方法返回一个的东西）。如果未指定 &lt;code&gt;stdin&lt;/code&gt; ，则子进程将具有与其父进程相同的标准输入流。</target>
        </trans-unit>
        <trans-unit id="68f9d2012a908ef5a582d735d8be7fe63553ac43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stdin&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, file descriptor, or None) &amp;ndash; The bytes to provide to the subprocess on its standard input stream, or &lt;code&gt;None&lt;/code&gt; if the subprocess&amp;rsquo;s standard input should come from the same place as the parent Trio process&amp;rsquo;s standard input. As is the case with the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module, you can also pass a file descriptor or an object with a &lt;code&gt;fileno()&lt;/code&gt; method, in which case the subprocess&amp;rsquo;s standard input will come from that file.</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;，文件描述符或无）&amp;ndash;要在其标准输入流上提供给子流程的字节，如果子流程的标准输入应与父Trio流程的标准输入来自同一位置，则为 &lt;code&gt;None&lt;/code&gt; 。与&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt;模块一样，您也可以使用 &lt;code&gt;fileno()&lt;/code&gt; 方法传递文件描述符或对象，在这种情况下，子流程的标准输入将来自该文件。</target>
        </trans-unit>
        <trans-unit id="e980d52d16fce215767351c556fb552a1d5bffb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stdout&lt;/code&gt; &amp;ndash; Like &lt;code&gt;stdin&lt;/code&gt;, but for the child process&amp;rsquo;s standard output stream.</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; &amp;ndash;与 &lt;code&gt;stdin&lt;/code&gt; 类似，但用于子进程的标准输出流。</target>
        </trans-unit>
        <trans-unit id="5307a9d2c47f82bfe292dd0f7ce82f7c44754b75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stream_maker&lt;/code&gt; &amp;ndash; An async (!) function which returns a connected (&lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;) pair.</source>
          <target state="translated">&lt;code&gt;stream_maker&lt;/code&gt; &amp;ndash;一个异步（！）函数，该函数返回已连接的（&lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt;）对。</target>
        </trans-unit>
        <trans-unit id="dbaffedf99c9721b690ce581e56db550d6d1ce43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync_fn&lt;/code&gt; &amp;ndash; An arbitrary synchronous callable.</source>
          <target state="translated">&lt;code&gt;sync_fn&lt;/code&gt; &amp;ndash;任意同步可调用对象。</target>
        </trans-unit>
        <trans-unit id="0478602722f26cd556aa77b98959d5d47941b3ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The Trio task object that the current coroutine was detached from.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; （&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;Task&lt;/em&gt;&lt;/a&gt;）&amp;ndash;当前协程脱离的Trio任务对象。</target>
        </trans-unit>
        <trans-unit id="b8540abdbca36847f75a769a7abd2d0aeb3a94bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The finished task.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; （&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;）&amp;ndash;完成的任务。</target>
        </trans-unit>
        <trans-unit id="9fe76481d8eeaa8a4dbfc030b4847cce9b1efec0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The new task.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; （&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;）&amp;ndash;新任务。</target>
        </trans-unit>
        <trans-unit id="d8ba5f2e7e8869d83cfd9584d7d5035aefd3d68c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The task that became runnable.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; （&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;）&amp;ndash;可运行的任务。</target>
        </trans-unit>
        <trans-unit id="e010b6c5f0a9add2aefa00fbb0bedba0ed588d62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The task that is about to run.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; （&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;）&amp;ndash;将要运行的任务。</target>
        </trans-unit>
        <trans-unit id="0e0338010b8d26f21da19458356f1578f75bde21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The task that just ran.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; （&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;）&amp;ndash;刚刚运行的任务。</target>
        </trans-unit>
        <trans-unit id="7c992fd8856aef4de8e76153f474f4c8723fe894" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the task to be rescheduled. Must be blocked in a call to &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; （&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要重新安排的任务。必须在对&lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt;的调用中被阻止。</target>
        </trans-unit>
        <trans-unit id="0ae78f69e427f390674360603ae4a398cb896dc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task_status&lt;/code&gt; &amp;ndash; This function can be used with &lt;code&gt;nursery.start&lt;/code&gt;, which will return &lt;code&gt;listeners&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;task_status&lt;/code&gt; &amp;ndash;此函数可以与 &lt;code&gt;nursery.start&lt;/code&gt; 一起使用，它将返回 &lt;code&gt;listeners&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03c2e8a6341af61c1b587cccedca6d25b6d39287" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task_status&lt;/code&gt; &amp;ndash; This function can be used with &lt;code&gt;nursery.start&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;task_status&lt;/code&gt; &amp;ndash;该功能可以与 &lt;code&gt;nursery.start&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="ea5a3fe7122dd4cee3302c7652c5eb464ad1bdb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_living&lt;/code&gt; (int): The number of tasks that have been spawned and not yet exited.</source>
          <target state="translated">&lt;code&gt;tasks_living&lt;/code&gt; （int）：已产生但尚未退出的任务数。</target>
        </trans-unit>
        <trans-unit id="739001bea8c2726faa18e2b481895d4d53e1551e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_runnable&lt;/code&gt; (int): The number of tasks that are currently queued on the run queue (as opposed to blocked waiting for something to happen).</source>
          <target state="translated">&lt;code&gt;tasks_runnable&lt;/code&gt; （int）：当前在运行队列中排队的任务数（与阻塞等待发生的情况相对）。</target>
        </trans-unit>
        <trans-unit id="e37bd999a2be9d0cca34acb9d5d7f7c484e06fb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;#trio.CapacityLimiter.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of&quot;&gt;&lt;code&gt;acquire_on_behalf_of()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; ：在此&lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;#trio.CapacityLimiter.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of&quot;&gt; &lt;code&gt;acquire_on_behalf_of()&lt;/code&gt; &lt;/a&gt;方法上被阻止的任务数。</target>
        </trans-unit>
        <trans-unit id="fda1f91fcfe6da6aebf6c3579f8a0aea2a69bb4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this condition&amp;rsquo;s &lt;a href=&quot;#trio.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; ：在此条件的&lt;a href=&quot;#trio.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt;方法中阻止的任务数。</target>
        </trans-unit>
        <trans-unit id="1d6625cb145e1100cf7de52ec9dbb0be655857c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this event&amp;rsquo;s &lt;a href=&quot;#trio.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; ：在此事件的&lt;a href=&quot;#trio.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt;方法上阻止的任务数。</target>
        </trans-unit>
        <trans-unit id="e3ad2f4331209803091e2db33eab0ce1205d0f5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this lock&amp;rsquo;s &lt;a href=&quot;#trio.Lock.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; ：在此锁的&lt;a href=&quot;#trio.Lock.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt;方法上阻止的任务数。</target>
        </trans-unit>
        <trans-unit id="88bbbe67dedd42251a847f6ee743ed43450b6469" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this lot&amp;rsquo;s &lt;a href=&quot;#trio.hazmat.ParkingLot.park&quot;&gt;&lt;code&gt;park()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; ：在该批次的&lt;a href=&quot;#trio.hazmat.ParkingLot.park&quot;&gt; &lt;code&gt;park()&lt;/code&gt; &lt;/a&gt;方法上被阻止的任务数。</target>
        </trans-unit>
        <trans-unit id="18db8acf9a54103d76ab78ccb127f37723ab2017" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this semaphore&amp;rsquo;s &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; ：在此信号量的&lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt;方法上阻塞的任务数。</target>
        </trans-unit>
        <trans-unit id="92e56ab1340f6bde5ee56f317abacbf5eef96b0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting_receive&lt;/code&gt;: The number of tasks blocked in &lt;code&gt;receive&lt;/code&gt; on this channel (summing over all clones).</source>
          <target state="translated">&lt;code&gt;tasks_waiting_receive&lt;/code&gt; ：此通道上 &lt;code&gt;receive&lt;/code&gt; 阻止的任务数（所有克隆的总和）。</target>
        </trans-unit>
        <trans-unit id="0743f953431a2d7039e1416f4aef32455fe417ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting_send&lt;/code&gt;: The number of tasks blocked in &lt;code&gt;send&lt;/code&gt; on this channel (summing over all clones).</source>
          <target state="translated">&lt;code&gt;tasks_waiting_send&lt;/code&gt; ：在此通道上 &lt;code&gt;send&lt;/code&gt; 阻止的任务数（所有克隆的总和）。</target>
        </trans-unit>
        <trans-unit id="b0cd806769a469c3eb7d185d3d55b124c346a956" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The number of seconds we are willing to wait.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;）&amp;ndash;我们愿意等待的秒数。</target>
        </trans-unit>
        <trans-unit id="6772102160e6a83ff561040a822f5e931e792a0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The number of seconds we were willing to wait. This much time may or may not have elapsed, depending on whether any I/O was ready.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;）&amp;ndash;我们愿意等待的秒数。根据是否有任何I / O准备就绪，该时间可能已经过去，也可能尚未过去。</target>
        </trans-unit>
        <trans-unit id="3f8da86bd9fc94c0ef68f668c12ad19f82b44ae2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_tokens&lt;/code&gt;: The total number of tokens in the sack. Usually this will be larger than &lt;code&gt;borrowed_tokens&lt;/code&gt;, but it&amp;rsquo;s possibly for it to be smaller if &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt;&lt;code&gt;total_tokens&lt;/code&gt;&lt;/a&gt; was recently decreased.</source>
          <target state="translated">&lt;code&gt;total_tokens&lt;/code&gt; ：麻袋中的令牌总数。通常这将是大于 &lt;code&gt;borrowed_tokens&lt;/code&gt; ，但它可能为它是较小的，如果&lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt; &lt;code&gt;total_tokens&lt;/code&gt; &lt;/a&gt;最近下降。</target>
        </trans-unit>
        <trans-unit id="721ef0f3e300e7cf8f0edc1509d146331ba8b835" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transport_listener&lt;/code&gt; (&lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;em&gt;Listener&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The listener whose incoming connections will be wrapped in &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;transport_listener&lt;/code&gt; （&lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;em&gt;Listener&lt;/em&gt;&lt;/a&gt;）&amp;ndash;传入连接将包装在&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 中&lt;/a&gt;的侦听&lt;em&gt;器&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3ed9c34eae37c5affb57d8b6c4c9bf845d60f0ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transport_stream&lt;/code&gt; (&lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;em&gt;Stream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream used to transport encrypted data. Required.</source>
          <target state="translated">&lt;code&gt;transport_stream&lt;/code&gt; （&lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;em&gt;Stream&lt;/em&gt;&lt;/a&gt;）&amp;ndash;用于传输加密数据的流。需要。</target>
        </trans-unit>
        <trans-unit id="3dd6532c01255f0b97ed0d038d5e4c93bf4f8295" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#object&quot;&gt;&lt;em&gt;object&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The object to send.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#object&quot;&gt;&lt;em&gt;对象&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要发送的对象。</target>
        </trans-unit>
        <trans-unit id="37cab4c9f0aba80ee1245aa0200db8f3d11b2ff6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wait_send_all_might_not_block_hook&lt;/code&gt; &amp;ndash; An async function, or None. Called from &lt;a href=&quot;#trio.testing.MemorySendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;wait_send_all_might_not_block_hook&lt;/code&gt; &amp;ndash;异步函数，或无。从&lt;a href=&quot;#trio.testing.MemorySendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt;调用。可以做任何你喜欢的事。</target>
        </trans-unit>
        <trans-unit id="b3286b37b0ab654001d8174fc1c05a0b46882511" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield_value&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#object&quot;&gt;&lt;em&gt;object&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The object to yield to the current coroutine runner.</source>
          <target state="translated">&lt;code&gt;yield_value&lt;/code&gt; （&lt;a href=&quot;https://docs.python.org/3/library/functions.html#object&quot;&gt;&lt;em&gt;object&lt;/em&gt;&lt;/a&gt;）&amp;ndash;要屈服于当前协程运行器的对象。</target>
        </trans-unit>
        <trans-unit id="e5296fdbf5d6b180a8671cf7d7109308b00db56b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Channels&lt;/em&gt; allow you to safely and conveniently send objects between different tasks. They&amp;rsquo;re particularly useful for implementing producer/consumer patterns.</source>
          <target state="translated">&lt;em&gt;通道&lt;/em&gt;使您可以安全方便地在不同任务之间发送对象。它们对于实现生产者/消费者模式特别有用。</target>
        </trans-unit>
        <trans-unit id="eca91e08a24f38ddbaffe627fc1ea7890d9eef8a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fd&lt;/em&gt; must refer to a file that is open for reading and/or writing and supports non-blocking I/O (pipes and TTYs will work, on-disk files probably not). The returned stream takes ownership of the fd, so closing the stream will close the fd too. As with &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fdopen&quot;&gt;&lt;code&gt;os.fdopen&lt;/code&gt;&lt;/a&gt;, you should not directly use an fd after you have wrapped it in a stream using this function.</source>
          <target state="translated">&lt;em&gt;fd&lt;/em&gt;必须引用已打开以进行读取和/或写入并且支持非阻塞I / O的文件（管道和TTY可以工作，磁盘上的文件可能不工作）。返回的流将拥有fd的所有权，因此关闭流也将关闭fd。与&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fdopen&quot;&gt; &lt;code&gt;os.fdopen&lt;/code&gt; 一样&lt;/a&gt;，使用此功能将fd包装在流中后，不应直接使用fd。</target>
        </trans-unit>
        <trans-unit id="3a449a1116492e7a682dcafdf8f3b0e17dad5450" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cancellation handling&lt;/strong&gt;: Cancellation is a tricky issue here, because neither Python nor the operating systems it runs on provide any general mechanism for cancelling an arbitrary synchronous function running in a thread. This function will always check for cancellation on entry, before starting the thread. But once the thread is running, there are two ways it can handle being cancelled:</source>
          <target state="translated">&lt;strong&gt;取消处理&lt;/strong&gt;：在这里取消是一个棘手的问题，因为Python及其运行的操作系统都没有提供任何通用机制来取消线程中运行的任意同步函数。在启动线程之前，此函数将始终检查输入是否取消。但是，一旦线程运行，它可以通过两种方式处理被取消的情况：</target>
        </trans-unit>
        <trans-unit id="4033660c96d382fe67327d68e57a52697f397ff3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Error checking:&lt;/strong&gt; If the subprocess exits with a nonzero status code, indicating failure, &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; raises a &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;subprocess.CalledProcessError&lt;/code&gt;&lt;/a&gt; exception rather than returning normally. The captured outputs are still available as the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; attributes of that exception. To disable this behavior, so that &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; returns normally even if the subprocess exits abnormally, pass &lt;code&gt;check=False&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;错误检查：&lt;/strong&gt;如果子流程退出以非零状态码，指示故障，&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt;提出了一个&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;subprocess.CalledProcessError&lt;/code&gt; &lt;/a&gt;例外，而不是正常返回。捕获的输出仍然可以用作该异常的&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt;属性。要禁用此行为，以便即使子&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt;异常退出，run_process（）也会正常返回，请传递 &lt;code&gt;check=False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="289917c607cf1cbd1dadecced88ba530f15b1d0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you&amp;rsquo;re not sure what to do, then we recommend that you use async disk I/O by default,&lt;/strong&gt; because it makes your code more robust when conditions are bad, especially with regards to tail latencies; this improves the chances that what your users see matches what you saw in testing. Blocking the main thread stops &lt;em&gt;all&lt;/em&gt; tasks from running for that time. 10,000 &amp;micro;s is 10 ms, and it doesn&amp;rsquo;t take many 10 ms glitches to start adding up to &lt;a href=&quot;https://google.com/search?q=latency+cost&quot;&gt;real money&lt;/a&gt;; async disk I/O can help prevent those. Just don&amp;rsquo;t expect it to be magic, and be aware of the tradeoffs.</source>
          <target state="translated">&lt;strong&gt;如果您不确定该怎么做，那么我们建议您默认使用异步磁盘I / O，&lt;/strong&gt;因为这样可以在条件不好的情况下（尤其是在尾部延迟方面）使代码更健壮。这样可以提高用户看到的内容与测试中看到的内容相匹配的机会。阻塞主线程将阻止&lt;em&gt;所有&lt;/em&gt;任务在该时间运行。 10,000 &amp;micro;s是10毫秒，开始累加&lt;a href=&quot;https://google.com/search?q=latency+cost&quot;&gt;真钱&lt;/a&gt;不需要花费10毫秒的毛刺。异步磁盘I / O可以帮助防止这些情况。只是不要指望它是魔术，并且要注意折衷。</target>
        </trans-unit>
        <trans-unit id="ec61bac9cf0621f9189209568ab5b25a5e169125" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input:&lt;/strong&gt; The subprocess&amp;rsquo;s standard input stream is set up to receive the bytes provided as &lt;code&gt;stdin&lt;/code&gt;. Once the given input has been fully delivered, or if none is provided, the subprocess will receive end-of-file when reading from its standard input. Alternatively, if you want the subprocess to read its standard input from the same place as the parent Trio process, you can pass &lt;code&gt;stdin=None&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;输入：&lt;/strong&gt;子进程的标准输入流已设置为接收作为 &lt;code&gt;stdin&lt;/code&gt; 提供的字节。一旦完全交付给定的输入，或者如果未提供任何内容，则从其标准输入读取时，子流程将接收文件结束。另外，如果你想子进程读取来自同一个地方作为父三重奏进程的标准输入，你可以通过 &lt;code&gt;stdin=None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23eb20482732e41e1dcfc558eb1f0c5909afb9bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Locating a Trio Token&lt;/strong&gt;: There are two ways to specify which &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; loop to reenter:</source>
          <target state="translated">&lt;strong&gt;查找Trio令牌&lt;/strong&gt;：有两种方法可以指定要重新输入的&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; &lt;/a&gt;循环：</target>
        </trans-unit>
        <trans-unit id="ade3e064f41faa18672b1500d3135b5e95f57be0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt; By default, any output produced by the subprocess is passed through to the standard output and error streams of the parent Trio process. If you would like to capture this output and do something with it, you can pass &lt;code&gt;capture_stdout=True&lt;/code&gt; to capture the subprocess&amp;rsquo;s standard output, and/or &lt;code&gt;capture_stderr=True&lt;/code&gt; to capture its standard error. Captured data is provided as the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; attributes of the returned &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;CompletedProcess&lt;/code&gt;&lt;/a&gt; object. The value for any stream that was not captured will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;输出：&lt;/strong&gt;默认情况下，子流程产生的任何输出都会传递到父Trio流程的标准输出和错误流。如果要捕获此输出并对其进行处理，则可以传递 &lt;code&gt;capture_stdout=True&lt;/code&gt; 来捕获子流程的标准输出，和/或 &lt;code&gt;capture_stderr=True&lt;/code&gt; 来捕获其标准错误。提供捕获的数据作为返回的&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;CompletedProcess&lt;/code&gt; &lt;/a&gt;对象的&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;和/或&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt;属性。未捕获的任何流的值将为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbb197b3ed5b21d6850b4b2a58d709428c2897e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;: you should set &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; to be at least as large as the largest cushion you plan to pass to &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;摘要&lt;/strong&gt;：您应该将&lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt;设置为至少与计划传递给&lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt;的最大缓冲一样大。</target>
        </trans-unit>
        <trans-unit id="9a93be6ab8e66c257afb2ac1fd8e3333d8c144f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why do we even support unbounded buffers then?&lt;/strong&gt; Good question! Despite everything we saw above, there are times when you actually do need an unbounded buffer. For example, consider a web crawler that uses a channel to keep track of all the URLs it still wants to crawl. Each crawler runs a loop where it takes a URL from the channel, fetches it, checks the HTML for outgoing links, and then adds the new URLs to the channel. This creates a &lt;em&gt;circular flow&lt;/em&gt;, where each consumer is also a producer. In this case, if your channel buffer gets full, then the crawlers will block when they try to add new URLs to the channel, and if all the crawlers got blocked, then they aren&amp;rsquo;t taking any URLs out of the channel, so they&amp;rsquo;re stuck forever in a deadlock. Using an unbounded channel avoids this, because it means that &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; never blocks.</source>
          <target state="translated">&lt;strong&gt;那为什么我们甚至还支持无界缓冲区？&lt;/strong&gt;好问题！尽管我们在上面看到了所有内容，但有时您确实确实需要无限制的缓冲区。例如，考虑一个使用通道来跟踪它仍要爬网的所有URL的Web爬网程序。每个搜寻器都运行一个循环，在该循环中，它从通道中获取URL，将其获取，检查HTML中是否存在传出链接，然后将新的URL添加到通道中。这产生了&lt;em&gt;循环流&lt;/em&gt;，每个消费者也是生产者。在这种情况下，如果您的频道缓冲区已满，那么当爬网程序尝试将新的URL添加到该频道时，它们将被阻止，并且如果所有的搜寻器都被阻止，则它们不会从该频道中删除任何URL，因此它们永远陷入僵局。使用无限制通道可以避免这种情况，因为这意味着&lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt;永远不会阻塞。</target>
        </trans-unit>
        <trans-unit id="61c1f9736d24eb4a5f410bfc1a0e81ddee3b2303" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; becomes associated with some cancellable work when it is used as a context manager surrounding that work:</source>
          <target state="translated">当将&lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt;用作围绕该工作的上下文管理器时，它便与某些可取消的工作相关联：</target>
        </trans-unit>
        <trans-unit id="a0510c2529df08b033b6321c0cd65ef6eedc4913" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; object can be used as an async context manager to acquire the underlying lock; it blocks on entry but not on exit.</source>
          <target state="translated">甲&lt;a href=&quot;#trio.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt;对象可以被用作一个异步上下文管理器获得的底层锁; 它在进入时阻止，但在退出时不阻止。</target>
        </trans-unit>
        <trans-unit id="d1612df0d1097f5f2b176bcdf71abac20673f554" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; object can be used as an async context manager; it blocks on entry but not on exit.</source>
          <target state="translated">甲&lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt;对象可以被用作一个异步上下文管理器; 它在进入时阻止，但在退出时不阻止。</target>
        </trans-unit>
        <trans-unit id="6e7aa4ad7cc8923cf4918bb861708c0d650fa365" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.Semaphore&quot;&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/a&gt; object can be used as an async context manager; it blocks on entry but not on exit.</source>
          <target state="translated">甲&lt;a href=&quot;#trio.Semaphore&quot;&gt; &lt;code&gt;Semaphore&lt;/code&gt; &lt;/a&gt;对象可以被用作一个异步上下文管理器; 它在进入时阻止，但在退出时不阻止。</target>
        </trans-unit>
        <trans-unit id="2225f74cfd04c73fc7aee7e342aaa8719e9fe2d8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.abc.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is an object that implements both the &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt; interfaces, so you can both send and receive objects.</source>
          <target state="translated">一个&lt;a href=&quot;#trio.abc.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;是一个对象，同时实现&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt;接口，这样你就可以同时发送和接收的对象。</target>
        </trans-unit>
        <trans-unit id="d210e54abe986047092d797dd411bd7168065d1c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; for SSL/TLS-encrypted servers.</source>
          <target state="translated">一个&lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt;的SSL / TLS加密的服务器。</target>
        </trans-unit>
        <trans-unit id="625e56299f375edf78936391d427832e256f3e3c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; that uses a listening socket to accept incoming connections as &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">一个&lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt;使用一个监听套接字来接受传入的连接作为&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="c7bf989c710ce969c51f1aa9b39c8b49c0a3cd5d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; is an object that implements both the &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; interfaces.</source>
          <target state="translated">甲&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;是一个对象，同时实现&lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt;接口。</target>
        </trans-unit>
        <trans-unit id="258acf0a9f20fc356fa0b1a9bdbc98d32d8b2654" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object represents a concurrent &amp;ldquo;thread&amp;rdquo; of execution. It has no public constructor; Trio internally creates a &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object for each call to &lt;code&gt;nursery.start(...)&lt;/code&gt; or &lt;code&gt;nursery.start_soon(...)&lt;/code&gt;.</source>
          <target state="translated">甲&lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;对象表示执行的并发&amp;ldquo;线程&amp;rdquo;。它没有公共构造函数。Trio在内部为每次对 &lt;code&gt;nursery.start(...)&lt;/code&gt; 或 &lt;code&gt;nursery.start_soon(...)&lt;/code&gt; 调用创建一个&lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="ca7636a2d3c1be65ee986f9b4d165ad21f51d1e5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt; wrapper that executes blocking methods in &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个执行&lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt;阻塞方法的&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; &lt;/a&gt;包装器。</target>
        </trans-unit>
        <trans-unit id="1b73143bafd8aa0311b134e354003b25e9991581" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;subprocess.CompletedProcess&lt;/code&gt;&lt;/a&gt; instance describing the return code and outputs.</source>
          <target state="translated">一个&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;subprocess.CompletedProcess&lt;/code&gt; &lt;/a&gt;实例，它描述返回码和输出。</target>
        </trans-unit>
        <trans-unit id="3be56645eaeb3a24943a947fc261ff21539eecaa" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://en.wikipedia.org/wiki/Semaphore_(programming)&quot;&gt;semaphore&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Semaphore_(programming)&quot;&gt;信号&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe7ca899d2980900500c0380ec6e876d53eec217" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cancellation scope&lt;/em&gt;: the link between a unit of cancellable work and Trio&amp;rsquo;s cancellation system.</source>
          <target state="translated">一个&lt;em&gt;取消范围&lt;/em&gt;：撤销的工作单位和三星的消除系统之间的联系。</target>
        </trans-unit>
        <trans-unit id="5032c512330d88fc246829f10b8a02efcc6498a0" translate="yes" xml:space="preserve">
          <source>A brief tour of Trio&amp;rsquo;s internals</source>
          <target state="translated">Trio内部构造简介</target>
        </trans-unit>
        <trans-unit id="7d074c399cd96f916fd6ae7cb18a4c9e7ecd005a" translate="yes" xml:space="preserve">
          <source>A checkpoint is two things:</source>
          <target state="translated">一个检查站是两件事。</target>
        </trans-unit>
        <trans-unit id="866f38d604fe1cc0aa45f8909eeb748dc3ad3412" translate="yes" xml:space="preserve">
          <source>A child process. Like &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">一个子进程。类似于&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="da50d5e4a3b8f345208749e9b95ed3c3e12c049e" translate="yes" xml:space="preserve">
          <source>A classic &lt;a href=&quot;https://en.wikipedia.org/wiki/Lock_(computer_science)&quot;&gt;mutex&lt;/a&gt;.</source>
          <target state="translated">一个经典的&lt;a href=&quot;https://en.wikipedia.org/wiki/Lock_(computer_science)&quot;&gt;互斥锁&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9952ba6442045d780e56a579e1a2d3ed0b1e2bd5" translate="yes" xml:space="preserve">
          <source>A classic &lt;a href=&quot;https://en.wikipedia.org/wiki/Monitor_(synchronization)&quot;&gt;condition variable&lt;/a&gt;, similar to &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Condition&quot;&gt;&lt;code&gt;threading.Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">经典的&lt;a href=&quot;https://en.wikipedia.org/wiki/Monitor_(synchronization)&quot;&gt;条件变量&lt;/a&gt;，类似于&lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Condition&quot;&gt; &lt;code&gt;threading.Condition&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67b2307e53f7065cdcc0a477bac65ac935a07e91" translate="yes" xml:space="preserve">
          <source>A common convention for Unix daemons is that they should reload their configuration when they receive a &lt;code&gt;SIGHUP&lt;/code&gt;. Here&amp;rsquo;s a sketch of what that might look like using &lt;a href=&quot;#trio.open_signal_receiver&quot;&gt;&lt;code&gt;open_signal_receiver()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Unix守护程序的通用约定是，它们在收到 &lt;code&gt;SIGHUP&lt;/code&gt; 时应重新加载其配置。这是使用&lt;a href=&quot;#trio.open_signal_receiver&quot;&gt; &lt;code&gt;open_signal_receiver()&lt;/code&gt; &lt;/a&gt;可能看起来像的草图：</target>
        </trans-unit>
        <trans-unit id="479b35c63d61c382de8e69c12e513c7d2895b948" translate="yes" xml:space="preserve">
          <source>A context manager for catching signals.</source>
          <target state="translated">一个用于捕捉信号的上下文管理器。</target>
        </trans-unit>
        <trans-unit id="d9a5508851c7e6da4d695e1f4368dbb4ae12c3ad" translate="yes" xml:space="preserve">
          <source>A context which may be used to spawn (or cancel) child tasks.</source>
          <target state="translated">可用于生成(或取消)子任务的上下文。</target>
        </trans-unit>
        <trans-unit id="6aeeaa351c9c07a00161cba202d64ab2ab24477f" translate="yes" xml:space="preserve">
          <source>A convenience class for forcing code in different tasks to run in an explicit linear order.</source>
          <target state="translated">一个方便的类,用于强制不同任务中的代码以明确的线性顺序运行。</target>
        </trans-unit>
        <trans-unit id="4fd174db16d5e267b3cf62d87b5c941ad8eebc38" translate="yes" xml:space="preserve">
          <source>A custom implementation of &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; 的&lt;/a&gt;自定义实现。</target>
        </trans-unit>
        <trans-unit id="4d8aae5f3ee79493cbf98ec8a47b0dfd039c01e4" translate="yes" xml:space="preserve">
          <source>A custom implementation of &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt;&lt;code&gt;getnameinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt; &lt;code&gt;getnameinfo()&lt;/code&gt; 的&lt;/a&gt;自定义实现。</target>
        </trans-unit>
        <trans-unit id="4c96cb1bc50af7354b9f19f6a1c590cece36bddb" translate="yes" xml:space="preserve">
          <source>A fair wait queue with cancellation and requeueing.</source>
          <target state="translated">公平的等待队列,取消和重新排队。</target>
        </trans-unit>
        <trans-unit id="6549ee3a2faaf405d0715d67d2765d3f4964e0b1" translate="yes" xml:space="preserve">
          <source>A kinder, gentler GIL</source>
          <target state="translated">一个孩子,更温柔的GIL</target>
        </trans-unit>
        <trans-unit id="fd218172690cec772655bedac675b0ffeb843ce6" translate="yes" xml:space="preserve">
          <source>A new &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">一个新的&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="5580dae5a64338462ab0b4ded8e52746c9e9530a" translate="yes" xml:space="preserve">
          <source>A new &lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt;&lt;code&gt;FdStream&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">一个新的&lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt; &lt;code&gt;FdStream&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="b7ab10dae01d56e576130b3136cffdd323dcafa7" translate="yes" xml:space="preserve">
          <source>A new exception object in which each component exception &lt;code&gt;exc&lt;/code&gt; has been replaced by the result of running &lt;code&gt;handler(exc)&lt;/code&gt; &amp;ndash; or, if &lt;code&gt;handler&lt;/code&gt; returned None for all the inputs, returns None.</source>
          <target state="translated">一个新的异常对象，其中每个组件异常 &lt;code&gt;exc&lt;/code&gt; 已由运行 &lt;code&gt;handler(exc)&lt;/code&gt; 的结果替换-或者，如果 &lt;code&gt;handler&lt;/code&gt; 对所有输入均返回None，则返回None。</target>
        </trans-unit>
        <trans-unit id="089ece0cda1cb42c55a75d324e06b234d0a9acd8" translate="yes" xml:space="preserve">
          <source>A pair &lt;code&gt;(send_channel, receive_channel)&lt;/code&gt;. If you have trouble remembering which order these go in, remember: data flows from left &amp;rarr; right.</source>
          <target state="translated">一对 &lt;code&gt;(send_channel, receive_channel)&lt;/code&gt; 。如果您无法记住这些顺序，请记住：数据从左&amp;rarr;右流动。</target>
        </trans-unit>
        <trans-unit id="cd247a767092b84dd5e844b058c845103caf05f4" translate="yes" xml:space="preserve">
          <source>A pair &lt;code&gt;(transport_stream, trailing_bytes)&lt;/code&gt;, where &lt;code&gt;transport_stream&lt;/code&gt; is the underlying transport stream, and &lt;code&gt;trailing_bytes&lt;/code&gt; is a byte string. Since &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t necessarily know where the end of the encrypted data will be, it can happen that it accidentally reads too much from the underlying stream. &lt;code&gt;trailing_bytes&lt;/code&gt; contains this extra data; you should process it as if it was returned from a call to &lt;code&gt;transport_stream.receive_some(...)&lt;/code&gt;.</source>
          <target state="translated">一对 &lt;code&gt;(transport_stream, trailing_bytes)&lt;/code&gt; ，其中 &lt;code&gt;transport_stream&lt;/code&gt; 是基础传输流， &lt;code&gt;trailing_bytes&lt;/code&gt; 是字节字符串。由于&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;不一定知道加密数据的末尾在哪里，因此可能会偶然从基础流中读取过多内容。 &lt;code&gt;trailing_bytes&lt;/code&gt; 包含这些额外的数据；您应该像处理它一样从调用 &lt;code&gt;transport_stream.receive_some(...)&lt;/code&gt; 返回它。</target>
        </trans-unit>
        <trans-unit id="0588df8a0bae45e29e38622a0505c5a7de73534e" translate="yes" xml:space="preserve">
          <source>A pair of &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; objects that are connected so that data automatically flows from one to the other in both directions.</source>
          <target state="translated">连接了一对&lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt;对象，以便数据自动在两个方向上从一个流向另一个。</target>
        </trans-unit>
        <trans-unit id="a6e442a4c39e80b90dffce3b49a6e8bdd58ab33b" translate="yes" xml:space="preserve">
          <source>A pure &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoint&lt;/a&gt;.</source>
          <target state="translated">一个纯粹的&lt;a href=&quot;reference-core#checkpoints&quot;&gt;检查站&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4cd63d27ef50a64a84701fc8cbaeb490e2d4d44" translate="yes" xml:space="preserve">
          <source>A return statement will not cancel the nursery if it still has tasks running:</source>
          <target state="translated">如果仍有任务在运行,返回语句将不会取消苗圃。</target>
        </trans-unit>
        <trans-unit id="031c15f98d537a5e074447bce8e5ff119937e3b5" translate="yes" xml:space="preserve">
          <source>A return value of &lt;code&gt;b&quot;&quot;&lt;/code&gt; (an empty bytestring) indicates that the stream has reached end-of-file. Implementations should be careful that they return &lt;code&gt;b&quot;&quot;&lt;/code&gt; if, and only if, the stream has reached end-of-file!</source>
          <target state="translated">返回值 &lt;code&gt;b&quot;&quot;&lt;/code&gt; （空字节串）表示流已到达文件末尾。实现应谨慎，只有在流到达文件末尾时，它们才返回 &lt;code&gt;b&quot;&quot;&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="8bdf7ef69126ff7409e786016de2f34e5ff450c0" translate="yes" xml:space="preserve">
          <source>A semaphore holds an integer value, which can be incremented by calling &lt;a href=&quot;#trio.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; and decremented by calling &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; &amp;ndash; but the value is never allowed to drop below zero. If the value is zero, then &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; will block until someone calls &lt;a href=&quot;#trio.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">信号量包含一个整数值，可以通过调用&lt;a href=&quot;#trio.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt;来增加它的值，并且可以通过调用&lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt;来使它的值减少&amp;ndash;但是绝对不允许该值降至零以下。如果该值为零，则&lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt;将阻塞，直到有人调用&lt;a href=&quot;#trio.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt;为止。</target>
        </trans-unit>
        <trans-unit id="bce2812b0b52deb7bf2bba57f134e10e9513a206" translate="yes" xml:space="preserve">
          <source>A silly way to make a stream that echoes back whatever you write to it:</source>
          <target state="translated">一个愚蠢的方法,让一个流,无论你写什么东西给它,它都会呼应回来。</target>
        </trans-unit>
        <trans-unit id="5df2f3e939d31936762bec3597f6b2da00f2cb48" translate="yes" xml:space="preserve">
          <source>A simple channel example</source>
          <target state="translated">一个简单的通道例子</target>
        </trans-unit>
        <trans-unit id="95282c07f98577f2f962ac30d0752ad31f56c132" translate="yes" xml:space="preserve">
          <source>A simple timeout example</source>
          <target state="translated">一个简单的超时例子</target>
        </trans-unit>
        <trans-unit id="6e235d2e02ac1d060d2ff3c65495448b073d204e" translate="yes" xml:space="preserve">
          <source>A slightly trickier case is a function like:</source>
          <target state="translated">稍微棘手一点的情况是这样的函数。</target>
        </trans-unit>
        <trans-unit id="5626a02a8af093a360fe62102133baa49c34f588" translate="yes" xml:space="preserve">
          <source>A standard interface for interacting with bidirectional byte streams.</source>
          <target state="translated">用于与双向字节流交互的标准接口。</target>
        </trans-unit>
        <trans-unit id="0a1d52474b9106e18b98b94a4317b363829ea98d" translate="yes" xml:space="preserve">
          <source>A standard interface for interacting with bidirectional channels.</source>
          <target state="translated">一个与双向通道交互的标准接口。</target>
        </trans-unit>
        <trans-unit id="faa046132b99538769350e2cef5d5bc2e1a88a00" translate="yes" xml:space="preserve">
          <source>A standard interface for listening for incoming connections.</source>
          <target state="translated">一个用于监听传入连接的标准接口。</target>
        </trans-unit>
        <trans-unit id="84688c296d643fb8558b4282dbf67d4d6c682eac" translate="yes" xml:space="preserve">
          <source>A standard interface for receiving Python objects from some sender.</source>
          <target state="translated">一个从某个发送方接收Python对象的标准接口。</target>
        </trans-unit>
        <trans-unit id="19bdeadce2bcad6dfc143ef126e57402024bb864" translate="yes" xml:space="preserve">
          <source>A standard interface for receiving data on a byte stream.</source>
          <target state="translated">用于接收字节流数据的标准接口。</target>
        </trans-unit>
        <trans-unit id="f9ec745dcf68e43c09d13825380bfc3153b5f42a" translate="yes" xml:space="preserve">
          <source>A standard interface for resources that needs to be cleaned up, and where that cleanup may require blocking operations.</source>
          <target state="translated">一个标准的接口,用于需要清理的资源,以及清理可能需要阻断操作的地方。</target>
        </trans-unit>
        <trans-unit id="246a1fe88a6077a51a4b1ab320703dd1fe24b852" translate="yes" xml:space="preserve">
          <source>A standard interface for sending Python objects to some receiver.</source>
          <target state="translated">一个标准的接口,用于发送Python对象到一些接收者。</target>
        </trans-unit>
        <trans-unit id="6961f254e4e81df4b566ce4a2dff920fb070922a" translate="yes" xml:space="preserve">
          <source>A standard interface for sending data on a byte stream.</source>
          <target state="translated">一个在字节流上发送数据的标准接口。</target>
        </trans-unit>
        <trans-unit id="b4cf06c3ae923d1d511d1dc400d9c860ddef6e9c" translate="yes" xml:space="preserve">
          <source>A stream connected to the child&amp;rsquo;s standard error stream: when the child writes to standard error, the written bytes become available for you to read here. Only available if the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; was constructed using &lt;code&gt;stderr=PIPE&lt;/code&gt;; otherwise this will be None.</source>
          <target state="translated">流连接到子级的标准错误流：当子级写入标准错误时，已写入的字节可供您在此处读取。仅在使用 &lt;code&gt;stderr=PIPE&lt;/code&gt; 构建&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt;时可用；否则，将为&amp;ldquo;无&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c6f0c220a8ef83c061ac018592a158c1acea362e" translate="yes" xml:space="preserve">
          <source>A stream connected to the child&amp;rsquo;s standard input stream: when you write bytes here, they become available for the child to read. Only available if the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; was constructed using &lt;code&gt;stdin=PIPE&lt;/code&gt;; otherwise this will be None.</source>
          <target state="translated">流连接到孩子的标准输入流：当您在此处写入字节时，它们可供孩子读取。仅在使用 &lt;code&gt;stdin=PIPE&lt;/code&gt; 构造&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt;时可用；否则，将为&amp;ldquo;无&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="84f88943d222d5c08ff49d881c72a9de6313f085" translate="yes" xml:space="preserve">
          <source>A stream connected to the child&amp;rsquo;s standard output stream: when the child writes to standard output, the written bytes become available for you to read here. Only available if the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; was constructed using &lt;code&gt;stdout=PIPE&lt;/code&gt;; otherwise this will be None.</source>
          <target state="translated">流连接到子级的标准输出流：当子级写入标准输出时，已写入的字节将变为可用，供您在此处读取。仅在使用 &lt;code&gt;stdout=PIPE&lt;/code&gt; 构建&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt;时可用；否则，将为&amp;ldquo;无&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="954ca7723aafc90b8ae2473f0d14253858c192e4" translate="yes" xml:space="preserve">
          <source>A stream that sends data to the child&amp;rsquo;s standard input and receives from the child&amp;rsquo;s standard output. Only available if both &lt;a href=&quot;#trio.Process.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.Process.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; are available; otherwise this will be None.</source>
          <target state="translated">将数据发送到孩子的标准输入并从孩子的标准输出接收的流。仅在&lt;a href=&quot;#trio.Process.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#trio.Process.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;均可用时才可用；否则，将为&amp;ldquo;无&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4156e909e8dc71d5689a050c51a8b9b787486dce" translate="yes" xml:space="preserve">
          <source>A tuple (&lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;), where the &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt; has its hooks set up so that it calls &lt;a href=&quot;#trio.testing.memory_stream_pump&quot;&gt;&lt;code&gt;memory_stream_pump()&lt;/code&gt;&lt;/a&gt; from its &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt;&lt;code&gt;send_all_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MemorySendStream.close_hook&quot;&gt;&lt;code&gt;close_hook&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个元组（&lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; &lt;/a&gt;），其中&lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt;设置了其钩子，以便从其&lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt; &lt;code&gt;send_all_hook&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#trio.testing.MemorySendStream.close_hook&quot;&gt; &lt;code&gt;close_hook&lt;/code&gt; &lt;/a&gt;调用&lt;a href=&quot;#trio.testing.memory_stream_pump&quot;&gt; &lt;code&gt;memory_stream_pump()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efcdeb1e57aeec9fabc1211f5ee625ae661f04ca" translate="yes" xml:space="preserve">
          <source>A tuple (&lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">一个元组（&lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="41812fde4d36fb61daec4837f44446d9e7c30dff" translate="yes" xml:space="preserve">
          <source>A tuple (&lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">一个元组（&lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3b58de50a23919a1f3f8642bdd5fcb86f500f20f" translate="yes" xml:space="preserve">
          <source>A user-controllable clock suitable for writing tests.</source>
          <target state="translated">一个用户可控的时钟,适合编写测试。</target>
        </trans-unit>
        <trans-unit id="d394b71cb15d8736cdfc1fc9fa37b4073ac2c1e7" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; where tasks are guaranteed to acquire the lock in strict first-come-first-served order.</source>
          <target state="translated">&lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; 的&lt;/a&gt;一种变体，可以确保任务按照严格的先到先服务顺序获得锁。</target>
        </trans-unit>
        <trans-unit id="360867cd6ca0456c8287b5d11df4b1f0bd3a3ed9" translate="yes" xml:space="preserve">
          <source>A waitable boolean value useful for inter-task synchronization, inspired by &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt;&lt;code&gt;threading.Event&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">受&lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt; &lt;code&gt;threading.Event&lt;/code&gt; &lt;/a&gt;启发的可等待的布尔值，用于任务间同步。</target>
        </trans-unit>
        <trans-unit id="888df3bc904f11ac7d98b120089cf5c393ec278c" translate="yes" xml:space="preserve">
          <source>API details</source>
          <target state="translated">API详情</target>
        </trans-unit>
        <trans-unit id="a135b59a972e5d51e9898c53214e86f0658cc125" translate="yes" xml:space="preserve">
          <source>API overview</source>
          <target state="translated">API概述</target>
        </trans-unit>
        <trans-unit id="98f04167dd579d54364beef9c72aecdee3543412" translate="yes" xml:space="preserve">
          <source>Abstract base class</source>
          <target state="translated">抽象基类</target>
        </trans-unit>
        <trans-unit id="d8218637bd5929185efd6cedd428b196f3c683f3" translate="yes" xml:space="preserve">
          <source>Abstract base classes</source>
          <target state="translated">抽象基类</target>
        </trans-unit>
        <trans-unit id="934a206c7fa94c5e3b940f49138774a9bc4b9522" translate="yes" xml:space="preserve">
          <source>Accept an incoming connection.</source>
          <target state="translated">接受一个传入的连接。</target>
        </trans-unit>
        <trans-unit id="f980df6a8d9e94749c222bab10788f1acc9910d2" translate="yes" xml:space="preserve">
          <source>Accept the next connection and wrap it in an &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">接受下一个连接并将其包装在&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01859c9721d844b4c97719553bfc101a5661028b" translate="yes" xml:space="preserve">
          <source>Accessing this attribute does not check for termination; use &lt;a href=&quot;#trio.Process.poll&quot;&gt;&lt;code&gt;poll()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Process.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; for that.</source>
          <target state="translated">访问此属性不会检查是否终止。为此使用&lt;a href=&quot;#trio.Process.poll&quot;&gt; &lt;code&gt;poll()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#trio.Process.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a24b8c73dc58f01619f8b157ef4dbb8d1cabc7f7" translate="yes" xml:space="preserve">
          <source>Acquire the lock, blocking if necessary.</source>
          <target state="translated">获取锁,必要时进行阻断。</target>
        </trans-unit>
        <trans-unit id="f62f5263a0efafa3ea2f701a6b780bcf9b854b41" translate="yes" xml:space="preserve">
          <source>Acquire the underlying lock, blocking if necessary.</source>
          <target state="translated">获取底层锁,必要时阻断。</target>
        </trans-unit>
        <trans-unit id="c33c4bb3cd6a08c2b5c643cb02e11bb07b5a62c3" translate="yes" xml:space="preserve">
          <source>Adds an end-of-file marker to the internal buffer.</source>
          <target state="translated">在内部缓冲区中添加一个文件结束标记。</target>
        </trans-unit>
        <trans-unit id="84752f69bde810200a7a75068013277cd2c18314" translate="yes" xml:space="preserve">
          <source>Adds these abstract methods&amp;hellip;</source>
          <target state="translated">添加这些抽象方法&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9ffc61eebd04b52ced9a43b69b164c475720e17f" translate="yes" xml:space="preserve">
          <source>After construction, you can interact with the child process by writing data to its &lt;a href=&quot;#trio.Process.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; stream (a &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;), reading data from its &lt;a href=&quot;#trio.Process.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#trio.Process.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; streams (both &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;s), sending it signals using &lt;a href=&quot;#trio.Process.terminate&quot;&gt;&lt;code&gt;terminate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.Process.kill&quot;&gt;&lt;code&gt;kill&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#trio.Process.send_signal&quot;&gt;&lt;code&gt;send_signal&lt;/code&gt;&lt;/a&gt;, and waiting for it to exit using &lt;a href=&quot;#trio.Process.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">项目建成后，可以通过将数据写入到其与子进程交互&lt;a href=&quot;#trio.Process.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;流（&lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt;），读取其数据&lt;a href=&quot;#trio.Process.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;和/或&lt;a href=&quot;#trio.Process.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt;流（既&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; S），将其发送信号使用&lt;a href=&quot;#trio.Process.terminate&quot;&gt; &lt;code&gt;terminate&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#trio.Process.kill&quot;&gt; &lt;code&gt;kill&lt;/code&gt; &lt;/a&gt;，或&lt;a href=&quot;#trio.Process.send_signal&quot;&gt; &lt;code&gt;send_signal&lt;/code&gt; &lt;/a&gt;和等待它退出使用&lt;a href=&quot;#trio.Process.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;。有关详细信息，请参见&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fda6461f3015f34ff1df74c1242f7e0c19473185" translate="yes" xml:space="preserve">
          <source>After creating a stream pair, you can send data back and forth, which is enough for simple tests:</source>
          <target state="translated">创建流对后,可以来回发送数据,这对于简单的测试来说已经足够了。</target>
        </trans-unit>
        <trans-unit id="5bdd9f5cfc1e60752e0ba39124a981ddc11ba5c6" translate="yes" xml:space="preserve">
          <source>All calls with &lt;code&gt;idempotent=False&lt;/code&gt; are processed in strict first-in first-out order.</source>
          <target state="translated">所有 &lt;code&gt;idempotent=False&lt;/code&gt; 的呼叫均按照严格的先进先出顺序处理。</target>
        </trans-unit>
        <trans-unit id="c364f3240a303cebaff74b8113e96934d193acdf" translate="yes" xml:space="preserve">
          <source>All environments provide the following functions:</source>
          <target state="translated">所有环境都提供以下功能:</target>
        </trans-unit>
        <trans-unit id="516b45d89e54cbc171ce25d82e3ea1e166f44bfe" translate="yes" xml:space="preserve">
          <source>All methods and attributes &lt;em&gt;not&lt;/em&gt; mentioned above are identical to their equivalents in &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">上面&lt;em&gt;未&lt;/em&gt;提及的所有方法和属性都与&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; 中&lt;/a&gt;的等效方法相同：</target>
        </trans-unit>
        <trans-unit id="9763027b87405de48bf6b0814b614c809653c3a9" translate="yes" xml:space="preserve">
          <source>All of Trio&amp;rsquo;s subprocess APIs accept the numerous keyword arguments used by the standard &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module to control the environment in which a process starts and the mechanisms used for communicating with it. These may be passed wherever you see &lt;code&gt;**options&lt;/code&gt; in the documentation below. See the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#popen-constructor&quot;&gt;full list&lt;/a&gt; or just the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#frequently-used-arguments&quot;&gt;frequently used ones&lt;/a&gt; in the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; documentation. (You may need to &lt;code&gt;import
subprocess&lt;/code&gt; in order to access constants such as &lt;code&gt;PIPE&lt;/code&gt; or &lt;code&gt;DEVNULL&lt;/code&gt;.)</source>
          <target state="translated">Trio的所有子流程API均接受标准&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt;模块所使用的众多关键字参数，以控制流程启动的环境以及与之通信的机制。只要您在下面的文档中看到 &lt;code&gt;**options&lt;/code&gt; ，就可以通过这些选项。请参阅&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#popen-constructor&quot;&gt;完整列表&lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt;文档中的仅&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#frequently-used-arguments&quot;&gt;常用&lt;/a&gt;列表。（您可能需要 &lt;code&gt;import subprocess&lt;/code&gt; 才能访问诸如 &lt;code&gt;PIPE&lt;/code&gt; 或 &lt;code&gt;DEVNULL&lt;/code&gt; 之类的常量。）</target>
        </trans-unit>
        <trans-unit id="2aa180e59f7357f8747d01d26ff0c904e97ad5cf" translate="yes" xml:space="preserve">
          <source>All of these hooks are also exposed as attributes on the object, and you can change them at any time.</source>
          <target state="translated">所有这些钩子也都作为对象上的属性暴露出来,你可以在任何时候改变它们。</target>
        </trans-unit>
        <trans-unit id="f1538bc660a990864dbaf1ef24a3d075fd3a9b8f" translate="yes" xml:space="preserve">
          <source>Also, &lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt; correctly uses IDNA 2008 to process non-ASCII domain names. (&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt;&lt;code&gt;socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt; uses IDNA 2003, which can give the wrong result in some cases and cause you to connect to a different host than the one you intended; see &lt;a href=&quot;https://bugs.python.org/issue17305&quot;&gt;bpo-17305&lt;/a&gt;.)</source>
          <target state="translated">另外，&lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt;正确使用IDNA 2008处理非ASCII域名。（&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt; &lt;code&gt;socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt;使用IDNA 2003，在某些情况下可能会产生错误的结果，并导致您连接到与预期主机不同的主机；请参阅&lt;a href=&quot;https://bugs.python.org/issue17305&quot;&gt;bpo-17305&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="83cf84f8a5bf0d4f53335a628e0369d2475a03db" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/glossary.html#term-asynchronous-file-object&quot;&gt;asynchronous file object&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/glossary.html#term-asynchronous-file-object&quot;&gt;异步文件对象&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a3d704b1065f4c2eb639c6f993e214ab9654318" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/glossary.html#term-asynchronous-file-object&quot;&gt;asynchronous file object&lt;/a&gt; that wraps &lt;code&gt;file&lt;/code&gt;</source>
          <target state="translated">包装 &lt;code&gt;file&lt;/code&gt; 的&lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/glossary.html#term-asynchronous-file-object&quot;&gt;异步文件对象&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a802ab3679dc10b4fe79e97e5a8ff9d668b3ca83" translate="yes" xml:space="preserve">
          <source>An event object has an internal boolean flag, representing whether the event has happened yet. The flag is initially False, and the &lt;a href=&quot;#trio.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; method waits until the flag is True. If the flag is already True, then &lt;a href=&quot;#trio.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; returns immediately. (If the event has already happened, there&amp;rsquo;s nothing to wait for.) The &lt;a href=&quot;#trio.Event.set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; method sets the flag to True, and wakes up any waiters.</source>
          <target state="translated">事件对象具有内部布尔标志，表示事件是否已经发生。该标志最初为False，并且&lt;a href=&quot;#trio.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt;方法等待，直到该标志为True。如果该标志已经为True，则&lt;a href=&quot;#trio.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt;立即返回。 （如果事件已经发生，则无需等待。）&lt;a href=&quot;#trio.Event.set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt;方法将标志设置为True，并唤醒所有侍者。</target>
        </trans-unit>
        <trans-unit id="4d52ab6eac96066995c3946164709bf9e329f2bc" translate="yes" xml:space="preserve">
          <source>An example of when this is useful is if you&amp;rsquo;re implementing something like &lt;a href=&quot;reference-io#trio.SSLStream&quot;&gt;&lt;code&gt;trio.SSLStream&lt;/code&gt;&lt;/a&gt; or an HTTP/2 server using &lt;a href=&quot;https://hyper-h2.readthedocs.io/&quot;&gt;h2&lt;/a&gt;, where you have multiple concurrent tasks that are interacting with a shared state machine, and at unpredictable moments the state machine requests that a chunk of data be sent over the network. (For example, when using h2 simply reading incoming data can occasionally &lt;a href=&quot;https://http2.github.io/http2-spec/#PING&quot;&gt;create outgoing data to send&lt;/a&gt;.) The challenge is to make sure that these chunks are sent in the correct order, without being garbled.</source>
          <target state="translated">一个有用的例子是，如果您正在使用&lt;a href=&quot;https://hyper-h2.readthedocs.io/&quot;&gt;h2&lt;/a&gt;实现诸如&lt;a href=&quot;reference-io#trio.SSLStream&quot;&gt; &lt;code&gt;trio.SSLStream&lt;/code&gt; &lt;/a&gt;或HTTP / 2服务器之类的东西，其中您有多个并发任务正在与共享状态机交互，并且在不可预知的时刻状态机请求通过网络发送大量数据。 （例如，使用h2时，仅读取传入的数据有时可能会&lt;a href=&quot;https://http2.github.io/http2-spec/#PING&quot;&gt;创建要发送的传出数据&lt;/a&gt;。）面临的挑战是确保这些块以正确的顺序发送而不会出现乱码。</target>
        </trans-unit>
        <trans-unit id="14aa51805b5668de90eaf69ef2c36108d5a6ef09" translate="yes" xml:space="preserve">
          <source>An example of where you&amp;rsquo;d use this is in implementing something like &lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run()&lt;/code&gt;&lt;/a&gt;, which uses &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt;&lt;code&gt;TrioToken.run_sync_soon()&lt;/code&gt;&lt;/a&gt; to get into the Trio thread. &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt;&lt;code&gt;run_sync_soon()&lt;/code&gt;&lt;/a&gt; callbacks are run with &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection enabled, and &lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run()&lt;/code&gt;&lt;/a&gt; takes advantage of this to safely set up the machinery for sending a response back to the original thread, but then uses &lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt;&lt;code&gt;disable_ki_protection()&lt;/code&gt;&lt;/a&gt; when entering the user-provided function.</source>
          <target state="translated">使用此示例的一个例子是实现类似&lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run()&lt;/code&gt; 的&lt;/a&gt;东西，该东西使用&lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt; &lt;code&gt;TrioToken.run_sync_soon()&lt;/code&gt; &lt;/a&gt;进入Trio线程。&lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt; &lt;code&gt;run_sync_soon()&lt;/code&gt; &lt;/a&gt;回调在启用&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt;保护的情况下运行，并且&lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run()&lt;/code&gt; &lt;/a&gt;利用此优势来安全地设置用于将响应发送回原始线程的机制，但是在进入用户&lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt; &lt;code&gt;disable_ki_protection()&lt;/code&gt; &lt;/a&gt;时使用disable_ki_protection（）提供的功能。</target>
        </trans-unit>
        <trans-unit id="a1f0bedbb145e5a1e2bbf357cfd642611519001c" translate="yes" xml:space="preserve">
          <source>An example of where you&amp;rsquo;d use this is on the &lt;code&gt;__exit__&lt;/code&gt; implementation for something like a &lt;a href=&quot;reference-core#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;, where a poorly-timed &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; could leave the lock in an inconsistent state and cause a deadlock.</source>
          <target state="translated">在 &lt;code&gt;__exit__&lt;/code&gt; 实现上使用诸如&lt;a href=&quot;reference-core#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; 之&lt;/a&gt;类的示例的地方，在该示例中，时间不佳的&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt;可能会使锁处于不一致状态并导致死锁。</target>
        </trans-unit>
        <trans-unit id="3d53f85c599291f0aa7ad06a498910662abac5c1" translate="yes" xml:space="preserve">
          <source>An exception that contains other exceptions; also known as an &amp;ldquo;inception&amp;rdquo;.</source>
          <target state="translated">包含其他异常的异常；也称为&amp;ldquo;盗梦空间&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8b5a92674abba02060ea334d3fa2bbc5aa4e8e09" translate="yes" xml:space="preserve">
          <source>An extremely elaborate way to print the numbers 0-5, in order:</source>
          <target state="translated">一种极其复杂的方式,按顺序打印数字0-5。</target>
        </trans-unit>
        <trans-unit id="7aef88f6225e778c97ecaab42341e3b25ab9147f" translate="yes" xml:space="preserve">
          <source>An implementation of the &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt;&lt;/a&gt; interface based on a raw network socket.</source>
          <target state="translated">基于原始网络套接字的&lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt; &lt;/a&gt;接口的实现。</target>
        </trans-unit>
        <trans-unit id="695564b638fa254ea364510c5e05e8097f7591d5" translate="yes" xml:space="preserve">
          <source>An in-memory &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">内存中的&lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b2a920b465cb25d11c71e2cdaf24856da6d63c8" translate="yes" xml:space="preserve">
          <source>An in-memory &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">内存中的&lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f30ba4d9f6910fed9a58bf0bd0f5800556c4cba6" translate="yes" xml:space="preserve">
          <source>An object for controlling access to a resource with limited capacity.</source>
          <target state="translated">用于控制对容量有限的资源的访问的对象。</target>
        </trans-unit>
        <trans-unit id="ba8865459d8776bfdcb6f4f08bb9a46b051e09e7" translate="yes" xml:space="preserve">
          <source>An object representing the incoming connection. In practice this is generally some kind of &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, but in principle you could also define a &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; that returned, say, channel objects.</source>
          <target state="translated">表示传入连接的对象。实际上，这通常是某种&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;，但原则上您还可以定义一个返回例如通道对象的&lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb005736155e148aa00fb56e6e1d90e65b11f9f4" translate="yes" xml:space="preserve">
          <source>An object used to limit the number of simultaneous threads. Most commonly this will be a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt;, but it could be anything providing compatible &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of&quot;&gt;&lt;code&gt;acquire_on_behalf_of()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.CapacityLimiter.release_on_behalf_of&quot;&gt;&lt;code&gt;release_on_behalf_of()&lt;/code&gt;&lt;/a&gt; methods. This function will call &lt;code&gt;acquire_on_behalf_of&lt;/code&gt; before starting the thread, and &lt;code&gt;release_on_behalf_of&lt;/code&gt; after the thread has finished.</source>
          <target state="translated">用于限制并发线程数的对象。通常，这将是&lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt;，但也可以是提供兼容的&lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of&quot;&gt; &lt;code&gt;acquire_on_behalf_of()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#trio.CapacityLimiter.release_on_behalf_of&quot;&gt; &lt;code&gt;release_on_behalf_of()&lt;/code&gt; &lt;/a&gt;方法的任何东西。该函数将在启动线程之前调用 &lt;code&gt;acquire_on_behalf_of&lt;/code&gt; ，并在线程完成之后调用 &lt;code&gt;release_on_behalf_of&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d44602f4de12292ecf6bdcbd9eb7906b8d75b788" translate="yes" xml:space="preserve">
          <source>An opaque object representing a single call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个不透明的对象，表示对&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt;的单个调用。</target>
        </trans-unit>
        <trans-unit id="8149f28272227a8e81084653973e770e45c26b37" translate="yes" xml:space="preserve">
          <source>And both of these raise nothing at all:</source>
          <target state="translated">而这两点根本就没有提高。</target>
        </trans-unit>
        <trans-unit id="83af1c669b4bec1a968e9180163f131b881c991c" translate="yes" xml:space="preserve">
          <source>And crucially, if you try to borrow a token but the sack is empty, then you have to wait for another task to finish what it&amp;rsquo;s doing and put its token back first before you can take it and continue.</source>
          <target state="translated">至关重要的是，如果您尝试借用令牌但麻袋是空的，那么您必须等待其他任务完成其工作并将其令牌放回第一位，然后才能继续使用。</target>
        </trans-unit>
        <trans-unit id="e9441ac9e6468a96d8d53ae170751b3641f022f8" translate="yes" xml:space="preserve">
          <source>And here&amp;rsquo;s a simple test using our modified stream objects:</source>
          <target state="translated">这是使用修改后的流对象的简单测试：</target>
        </trans-unit>
        <trans-unit id="292b64b01e8fc7f9c6c766b1d0e5576718c411ae" translate="yes" xml:space="preserve">
          <source>And here&amp;rsquo;s the interface to implement if you want to build your own &lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;code&gt;Instrument&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果要构建自己的&lt;a href=&quot;#trio.abc.Instrument&quot;&gt; &lt;code&gt;Instrument&lt;/code&gt; &lt;/a&gt;，这是要实现的接口：</target>
        </trans-unit>
        <trans-unit id="e471a70c4adc5a5fbd1f21459bce94d3eae6d3d6" translate="yes" xml:space="preserve">
          <source>And if you combine pipelines with () grouping, you can need even more levels of escaping:</source>
          <target state="translated">而如果将管道与()分组结合起来,你可能需要更多层次的逃避。</target>
        </trans-unit>
        <trans-unit id="33a00a0e43b4ec4919fc3243ac05e9ba6405d86a" translate="yes" xml:space="preserve">
          <source>And if you&amp;rsquo;re implementing a server, you can use &lt;a href=&quot;#trio.SSLListener&quot;&gt;&lt;code&gt;SSLListener&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果要实现服务器，则可以使用&lt;a href=&quot;#trio.SSLListener&quot;&gt; &lt;code&gt;SSLListener&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="ba0a6a620759e481fb4465edb6928ab1b2715ba4" translate="yes" xml:space="preserve">
          <source>And in some very, very unusual circumstances, it even makes sense to transfer a single coroutine object back and forth between different coroutine runners. That&amp;rsquo;s what this section is about. This is an &lt;em&gt;extremely&lt;/em&gt; exotic use case, and assumes a lot of expertise in how Python async/await works internally. For motivating examples, see &lt;a href=&quot;https://github.com/python-trio/trio-asyncio/issues/42&quot;&gt;trio-asyncio issue #42&lt;/a&gt;, and &lt;a href=&quot;https://github.com/python-trio/trio/issues/649&quot;&gt;trio issue #649&lt;/a&gt;. For more details on how coroutines work, we recommend Andr&amp;eacute; Caron&amp;rsquo;s &lt;a href=&quot;https://github.com/AndreLouisCaron/a-tale-of-event-loops&quot;&gt;A tale of event loops&lt;/a&gt;, or going straight to &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;PEP 492&lt;/a&gt; for the full details.</source>
          <target state="translated">在某些非常非常不寻常的情况下，甚至可以在不同的协程运行者之间来回移动单个协程对象。这就是本节的内容。这是一个&lt;em&gt;非常&lt;/em&gt;奇特的用例，并且在Python异步/等待如何内部工作方面具有很多专业知识。有关激励示例，请参见&lt;a href=&quot;https://github.com/python-trio/trio-asyncio/issues/42&quot;&gt;trio-asyncio问题＃42&lt;/a&gt;和&lt;a href=&quot;https://github.com/python-trio/trio/issues/649&quot;&gt;trio问题＃649&lt;/a&gt;。有关协程如何工作的更多详细信息，我们建议您使用Andr&amp;eacute;Caron的&lt;a href=&quot;https://github.com/AndreLouisCaron/a-tale-of-event-loops&quot;&gt;&amp;ldquo;事件循环的故事&amp;rdquo;&lt;/a&gt;，或直接转到&lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;PEP 492&lt;/a&gt;以获取全部详细信息。</target>
        </trans-unit>
        <trans-unit id="619d03500f6db41ec6806aedd9a5bd864e1f9ac0" translate="yes" xml:space="preserve">
          <source>And of course these can be mixed and matched at will.</source>
          <target state="translated">当然这些也可以随意混搭。</target>
        </trans-unit>
        <trans-unit id="5fe22b10355ca18b089c78c28baddac1ad66a2f8" translate="yes" xml:space="preserve">
          <source>And once you have a reference to a nursery object, you can start children in that nursery:</source>
          <target state="translated">而一旦你有了一个托儿所对象的引用,你就可以在这个托儿所里开始生孩子。</target>
        </trans-unit>
        <trans-unit id="0c8b7b10833f094016e1717309592388a4e1b78e" translate="yes" xml:space="preserve">
          <source>And second, the cost of a disk operation is incredibly bimodal. Sometimes, the data you need is already cached in RAM, and then accessing it is very, very fast &amp;ndash; calling &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.FileIO&quot;&gt;&lt;code&gt;io.FileIO&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;code&gt;read&lt;/code&gt; method on a cached file takes on the order of ~1 &amp;micro;s. But when the data isn&amp;rsquo;t cached, then accessing it is much, much slower: the average is ~100 &amp;micro;s for SSDs and ~10,000 &amp;micro;s for spinning disks, and if you look at tail latencies then for both types of storage you&amp;rsquo;ll see cases where occasionally some operation will be 10x or 100x slower than average. And that&amp;rsquo;s assuming your program is the only thing trying to use that disk &amp;ndash; if you&amp;rsquo;re on some oversold cloud VM fighting for I/O with other tenants then who knows what will happen. And some operations can require multiple disk accesses.</source>
          <target state="translated">其次，磁盘操作的成本是双峰的。有时，您需要的数据已经缓存在RAM中，然后以非常非常快的速度对其进行访问- 在缓存的文件上调用&lt;a href=&quot;https://docs.python.org/3/library/io.html#io.FileIO&quot;&gt; &lt;code&gt;io.FileIO&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;read&lt;/code&gt; 方法大约需要1 &amp;micro;s。但是，当不缓存数据时，访问数据的速度将大大降低：SSD的平均速度约为100 &amp;micro;s，旋转磁盘的平均速度约为10,000 &amp;micro;s，如果您查看延迟时间，那么两种类型的存储都会查看某些情况下某些操作有时会比平均速度慢10倍或100倍的情况。并假设您的程序是尝试使用该磁盘的唯一方法&amp;ndash;如果您在某个超卖的云虚拟机上与其他租户争夺I / O，那么谁知道会发生什么。并且某些操作可能需要多个磁盘访问。</target>
        </trans-unit>
        <trans-unit id="feeca190f93d22f58d615ed4fd1614a4269d6897" translate="yes" xml:space="preserve">
          <source>And then it hangs forever. (Use control-C to quit.)</source>
          <target state="translated">然后就永远挂了。(使用control-C退出。)</target>
        </trans-unit>
        <trans-unit id="211d7d50556ec8f345832762c8c8fe21c2c79327" translate="yes" xml:space="preserve">
          <source>And these concrete methods.</source>
          <target state="translated">而这些具体方法。</target>
        </trans-unit>
        <trans-unit id="f27d0a8c5e5faf3e87bb41b32a3eb3c34a5ef14f" translate="yes" xml:space="preserve">
          <source>Another approach would be to attempt to connect to all of the addresses at the same time, in parallel, and then use whichever connection succeeds first, abandoning the others. This would be fast, but create a lot of unnecessary load on the network and the remote server.</source>
          <target state="translated">另一种方法是尝试同时并行连接到所有的地址,然后使用最先成功的连接,放弃其他的连接。这样做的速度很快,但会给网络和远程服务器带来很多不必要的负担。</target>
        </trans-unit>
        <trans-unit id="540e6b0386e96589ef7bf08cc766b92ef3f1c782" translate="yes" xml:space="preserve">
          <source>Another way to think of it: a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; is like a sofa with a fixed number of seats, and if they&amp;rsquo;re all taken then you have to wait for someone to get up before you can sit down.</source>
          <target state="translated">另一种思考的方式是：&lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt;就像是一个有固定座位数的沙发，如果所有座位都被占用，则必须等待某人起床才能坐下。</target>
        </trans-unit>
        <trans-unit id="3c598eda8f7e244d58a5c6244a28edd77a41d473" translate="yes" xml:space="preserve">
          <source>Any ordering guarantees apply separately to &lt;code&gt;idempotent=False&lt;/code&gt; and &lt;code&gt;idempotent=True&lt;/code&gt; calls; there&amp;rsquo;s no rule for how calls in the different categories are ordered with respect to each other.</source>
          <target state="translated">任何订购保证分别适用于 &lt;code&gt;idempotent=False&lt;/code&gt; 和 &lt;code&gt;idempotent=True&lt;/code&gt; 调用；对于不同类别的呼叫如何相对于彼此排序，没有任何规则。</target>
        </trans-unit>
        <trans-unit id="41b988d7261002f6ebec68c073ec1cadb529e763" translate="yes" xml:space="preserve">
          <source>Any required IDNA encoding is handled before calling this function; your implementation can assume that it will never see U-labels like &lt;code&gt;&quot;caf&amp;eacute;.com&quot;&lt;/code&gt;, and only needs to handle A-labels like &lt;code&gt;b&quot;xn--caf-dma.com&quot;&lt;/code&gt;.</source>
          <target state="translated">在调用此函数之前，将处理所有必需的IDNA编码。您的实现可以假定它将永远不会看到类似 &lt;code&gt;&quot;caf&amp;eacute;.com&quot;&lt;/code&gt; U标签，而只需要处理诸如&amp;ldquo; &lt;code&gt;b&quot;xn--caf-dma.com&quot;&lt;/code&gt; 这样的A标签。</target>
        </trans-unit>
        <trans-unit id="bb6e5d4e2297b46370edf9d7a6dce06b7d28b0e4" translate="yes" xml:space="preserve">
          <source>Any unhandled exceptions are re-raised inside the parent task. If there are multiple exceptions, then they&amp;rsquo;re collected up into a single &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">所有未处理的异常都会在父任务中重新引发。如果存在多个异常，则将它们收集到一个&lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt;异常中。</target>
        </trans-unit>
        <trans-unit id="a144cdd6ad89d2a3f0faf4bb094aa9a40f041001" translate="yes" xml:space="preserve">
          <source>Appends the given data to the internal buffer.</source>
          <target state="translated">将给定数据添加到内部缓冲区。</target>
        </trans-unit>
        <trans-unit id="41199e1703298a10d2448f0613b291ab0cfa02d6" translate="yes" xml:space="preserve">
          <source>Apply the given &lt;code&gt;handler&lt;/code&gt; to all the exceptions in &lt;code&gt;root_exc&lt;/code&gt;.</source>
          <target state="translated">将给定的 &lt;code&gt;handler&lt;/code&gt; 应用于 &lt;code&gt;root_exc&lt;/code&gt; 中的所有异常。</target>
        </trans-unit>
        <trans-unit id="ddb0e258362b5452ce82961901033b9428777b28" translate="yes" xml:space="preserve">
          <source>Arguments and return values are identical to &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt;&lt;code&gt;socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt;, except that this version is async.</source>
          <target state="translated">参数和返回值与&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt; &lt;code&gt;socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt;相同，除了此版本是异步的。</target>
        </trans-unit>
        <trans-unit id="1799c1804f821db693151ce3817c600ec5a0e3f6" translate="yes" xml:space="preserve">
          <source>Arguments and return values are identical to &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getnameinfo&quot;&gt;&lt;code&gt;socket.getnameinfo()&lt;/code&gt;&lt;/a&gt;, except that this version is async.</source>
          <target state="translated">参数和返回值与&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getnameinfo&quot;&gt; &lt;code&gt;socket.getnameinfo()&lt;/code&gt; &lt;/a&gt;相同，除了此版本是异步的。</target>
        </trans-unit>
        <trans-unit id="c2c4d14e88fd37145f6bdde6cffa4dfeb02c80f4" translate="yes" xml:space="preserve">
          <source>As a young project, Trio is currently quite aggressive about deprecating and/or removing functionality that we realize was a bad idea. If you use Trio, you should subscribe to &lt;a href=&quot;https://github.com/python-trio/trio/issues/1&quot;&gt;issue #1&lt;/a&gt; to get information about upcoming deprecations and other backwards compatibility breaking changes.</source>
          <target state="translated">作为一个年轻的项目，Trio目前在淘汰和/或删除我们认为不是一个好主意的功能方面非常积极。如果您使用Trio，则应该订阅&lt;a href=&quot;https://github.com/python-trio/trio/issues/1&quot;&gt;问题1，&lt;/a&gt;以获取有关即将到来的弃用和其他向后兼容性突破性更改的信息。</target>
        </trans-unit>
        <trans-unit id="2d0994996832e530b1ae6097f1cb664a72a0eaff" translate="yes" xml:space="preserve">
          <source>As an example of what this means, here&amp;rsquo;s a small program in which two tasks compete for a lock. Notice that the task which releases the lock always immediately attempts to re-acquire it, before the other task has a chance to run. (And remember that we&amp;rsquo;re doing cooperative multi-tasking here, so it&amp;rsquo;s actually &lt;em&gt;deterministic&lt;/em&gt; that the task releasing the lock will call &lt;a href=&quot;#trio.Lock.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; before the other task wakes up; in Trio releasing a lock is not a checkpoint.) With an unfair lock, this would result in the same task holding the lock forever and the other task being starved out. But if you run this, you&amp;rsquo;ll see that the two tasks politely take turns:</source>
          <target state="translated">例如，这是一个小程序，其中两个任务竞争一个锁。请注意，在另一个任务有机会运行之前，释放锁的任务总是立即尝试重新获取它。（并且请记住，我们在这里正在执行协作式多任务处理，因此实际上&lt;em&gt;可以确定地&lt;/em&gt;是，释放锁的任务将在另一个任务唤醒之前调用&lt;a href=&quot;#trio.Lock.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt;；在Trio中释放锁不是检查点。）锁定，这将导致同一任务永远持有该锁定，而另一任务被饿死。但是，如果运行此命令，则会发现两个任务礼貌地轮流执行：</target>
        </trans-unit>
        <trans-unit id="4929afd212841a7b80b8527c2843abff4b732394" translate="yes" xml:space="preserve">
          <source>Async and cancellable variant of &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx&quot;&gt;WaitForSingleObject&lt;/a&gt;. Windows only.</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx&quot;&gt;WaitForSingleObject的&lt;/a&gt;异步和可取消变体。仅Windows。</target>
        </trans-unit>
        <trans-unit id="3b88c3f510d5347e19a68032dd5e36b530c8b07c" translate="yes" xml:space="preserve">
          <source>Async cleanup operations &amp;ndash; like &lt;code&gt;__aexit__&lt;/code&gt; methods or async close methods &amp;ndash; are cancellable just like anything else &lt;em&gt;except&lt;/em&gt; that if they are cancelled, they still perform a minimum level of cleanup before raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">异步清理操作（如 &lt;code&gt;__aexit__&lt;/code&gt; 方法或异步关闭方法）与其他任何事物一样可以取消，&lt;em&gt;除了&lt;/em&gt;如果取消它们，它们在执行&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;之前仍会执行最低级别的清理。</target>
        </trans-unit>
        <trans-unit id="7ce82e511d085dd23f703422ef525137aa3279ed" translate="yes" xml:space="preserve">
          <source>Async file objects can be used as async iterators to iterate over the lines of the file:</source>
          <target state="translated">异步文件对象可以作为异步迭代器来迭代文件的行。</target>
        </trans-unit>
        <trans-unit id="aa3c3b6b8715de81fa4c30bebbf1834d4a54fc9d" translate="yes" xml:space="preserve">
          <source>Async file objects implement Trio&amp;rsquo;s &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface: you close them by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;close&lt;/code&gt; (!!), and they can be used as async context managers. Like all &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; methods, the &lt;code&gt;aclose&lt;/code&gt; method on async file objects is guaranteed to close the file before returning, even if it is cancelled or otherwise raises an error.</source>
          <target state="translated">异步文件对象实现Trio的&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt;接口：您通过调用&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt;而不是 &lt;code&gt;close&lt;/code&gt; （!!）来关闭它们，它们可以用作异步上下文管理器。与所有&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt;方法一样，异步文件对象上的 &lt;code&gt;aclose&lt;/code&gt; 方法可确保在返回之前关闭文件，即使该文件已取消或以其他方式引发错误。</target>
        </trans-unit>
        <trans-unit id="5ef2ec7c086db048016785067a80b5c302021dc3" translate="yes" xml:space="preserve">
          <source>Async functions</source>
          <target state="translated">异步功能</target>
        </trans-unit>
        <trans-unit id="ad0ef1eb3a3323f023e10b1311f762ecdd88f1d8" translate="yes" xml:space="preserve">
          <source>Async methods: if any of the following methods are present, then they&amp;rsquo;re re-exported as an async method: &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;read1&lt;/code&gt;, &lt;code&gt;readall&lt;/code&gt;, &lt;code&gt;readinto&lt;/code&gt;, &lt;code&gt;readline&lt;/code&gt;, &lt;code&gt;readlines&lt;/code&gt;, &lt;code&gt;seek&lt;/code&gt;, &lt;code&gt;tell&lt;/code&gt;, &lt;code&gt;truncate&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writelines&lt;/code&gt;, &lt;code&gt;readinto1&lt;/code&gt;, &lt;code&gt;peek&lt;/code&gt;, &lt;code&gt;detach&lt;/code&gt;.</source>
          <target state="translated">异步方法：如果存在以下任何方法，则将它们重新导出为异步方法： &lt;code&gt;flush&lt;/code&gt; ， &lt;code&gt;read&lt;/code&gt; ， &lt;code&gt;read1&lt;/code&gt; ， &lt;code&gt;readall&lt;/code&gt; ， &lt;code&gt;readinto&lt;/code&gt; ，readinto， &lt;code&gt;readline&lt;/code&gt; ， &lt;code&gt;readlines&lt;/code&gt; ， &lt;code&gt;seek&lt;/code&gt; ， &lt;code&gt;tell&lt;/code&gt; ， &lt;code&gt;truncate&lt;/code&gt; ， &lt;code&gt;write&lt;/code&gt; ， &lt;code&gt;writelines&lt;/code&gt; ， &lt;code&gt;readinto1&lt;/code&gt; ， &lt;code&gt;peek&lt;/code&gt; ， &lt;code&gt;detach&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df5103c1d76d680bba6764bfa32d48a6b5502e54" translate="yes" xml:space="preserve">
          <source>AsyncResource</source>
          <target state="translated">AsyncResource</target>
        </trans-unit>
        <trans-unit id="334f22a36314907eaa8b814dd48f1292097dd241" translate="yes" xml:space="preserve">
          <source>Asynchronous file interface</source>
          <target state="translated">异步文件接口</target>
        </trans-unit>
        <trans-unit id="56e1586c4db07663ccb34d08c64207ff46c03226" translate="yes" xml:space="preserve">
          <source>Asynchronous file interface.wrapped</source>
          <target state="translated">异步文件接口.wrapped</target>
        </trans-unit>
        <trans-unit id="0076fe4764abf6551bbbe5999752efce8a89e22f" translate="yes" xml:space="preserve">
          <source>Asynchronous file objects</source>
          <target state="translated">异步文件对象</target>
        </trans-unit>
        <trans-unit id="667673e6e7517b69bb54c30591ebb1af1ea7f64f" translate="yes" xml:space="preserve">
          <source>Asynchronous filesystem I/O</source>
          <target state="translated">异步文件系统I/O</target>
        </trans-unit>
        <trans-unit id="1474e40071f7e113106e68f95d2c73a27282f008" translate="yes" xml:space="preserve">
          <source>Asynchronous path objects</source>
          <target state="translated">异步路径对象</target>
        </trans-unit>
        <trans-unit id="546381f9589ee22e6d37c1fe83d5cd5cbd4791b1" translate="yes" xml:space="preserve">
          <source>Asynchronous version of &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.open&quot;&gt;&lt;code&gt;io.open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/io.html#io.open&quot;&gt; &lt;code&gt;io.open()&lt;/code&gt; 的&lt;/a&gt;异步版本。</target>
        </trans-unit>
        <trans-unit id="64e84334e28bf171e5da15b38a549d66423494e6" translate="yes" xml:space="preserve">
          <source>At that point there are again two possibilities. You can simply ignore the cancellation altogether: wait for the operation to complete and then reschedule and continue as normal. (For example, this is what &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; does if cancellation is disabled.) The other possibility is that the &lt;code&gt;abort_func&lt;/code&gt; does succeed in cancelling the operation, but for some reason isn&amp;rsquo;t able to report that right away. (Example: on Windows, it&amp;rsquo;s possible to request that an async (&amp;ldquo;overlapped&amp;rdquo;) I/O operation be cancelled, but this request is &lt;em&gt;also&lt;/em&gt; asynchronous &amp;ndash; you don&amp;rsquo;t find out until later whether the operation was actually cancelled or not.) To report a delayed cancellation, then you should reschedule the task yourself, and call the &lt;code&gt;raise_cancel&lt;/code&gt; callback passed to &lt;code&gt;abort_func&lt;/code&gt; to raise a &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;) exception into this task. Either of the approaches sketched below can work:</source>
          <target state="translated">到那时，又有两种可能性。您可以简单地完全忽略取消：等待操作完成，然后重新安排时间，然后照常继续。 （例如，如果禁用取消，这就是&lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; 的&lt;/a&gt;工作。）另一种可能性是 &lt;code&gt;abort_func&lt;/code&gt; 确实可以成功取消该操作，但是由于某种原因无法立即报告该操作。 （示例：在Windows上，可以请求取消异步（&amp;ldquo;重叠&amp;rdquo;）I / O操作，但是此请求&lt;em&gt;也是&lt;/em&gt;异步的&amp;ndash;您直到稍后才知道该操作是否实际上被取消。）要报告延迟的取消，那么您应该自己重新安排任务的时间，并调用 &lt;code&gt;raise_cancel&lt;/code&gt; 传递给 &lt;code&gt;abort_func&lt;/code&gt; 的回调将引发&lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;（或可能是&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt;）异常进入此任务。下面概述的任何一种方法都可以起作用：</target>
        </trans-unit>
        <trans-unit id="687169aaa57a138b6171d6746f9a863ca2e934f3" translate="yes" xml:space="preserve">
          <source>At the other extreme, you can make the buffer unbounded by using &lt;code&gt;open_memory_channel(math.inf)&lt;/code&gt;. In this case, &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;always&lt;/em&gt; returns immediately. Normally, this is a bad idea. To see why, consider a program where the producer runs more quickly than the consumer:</source>
          <target state="translated">在另一个极端，您可以使用 &lt;code&gt;open_memory_channel(math.inf)&lt;/code&gt; 使缓冲区无界。在这种情况下，&lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt;&lt;em&gt;总是&lt;/em&gt;立即返回。通常，这是一个坏主意。要了解原因，请考虑一个程序，其中生产者比消费者更快地运行：</target>
        </trans-unit>
        <trans-unit id="b3c94195e485ebf930152b3b8ee9cf75902195a0" translate="yes" xml:space="preserve">
          <source>Attempt to acquire the lock, without blocking.</source>
          <target state="translated">试图获得锁,而不阻挡。</target>
        </trans-unit>
        <trans-unit id="222d279c3d693f924ccc7de907d970a895a42260" translate="yes" xml:space="preserve">
          <source>Attempt to acquire the underlying lock, without blocking.</source>
          <target state="translated">试图获取底层锁,而不阻挡。</target>
        </trans-unit>
        <trans-unit id="ef0a1a4841da5c985f3f0b3eae640e79b9971ed9" translate="yes" xml:space="preserve">
          <source>Attempt to decrement the semaphore value, without blocking.</source>
          <target state="translated">试图在不阻塞的情况下,递减旗语值。</target>
        </trans-unit>
        <trans-unit id="ec34329b732495345fe5c3d52450653e57f36518" translate="yes" xml:space="preserve">
          <source>Attempt to receive an incoming object, blocking if necessary.</source>
          <target state="translated">试图接收一个传入的对象,必要时进行阻断。</target>
        </trans-unit>
        <trans-unit id="cf506448c157bc98fe2eec29fc3993723c6b3208" translate="yes" xml:space="preserve">
          <source>Attempt to send an object through the channel, blocking if necessary.</source>
          <target state="translated">试图通过通道发送一个对象,必要时进行阻断。</target>
        </trans-unit>
        <trans-unit id="a4d81396d4ea19197dfceaa774ef776332674285" translate="yes" xml:space="preserve">
          <source>Attribution</source>
          <target state="translated">Attribution</target>
        </trans-unit>
        <trans-unit id="1d5232d8974b6129a9030ab048587c67ca7be343" translate="yes" xml:space="preserve">
          <source>Avoid instantiating &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt; directly. A newly constructed &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; has less secure defaults than one returned by &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt;&lt;code&gt;ssl.create_default_context()&lt;/code&gt;&lt;/a&gt;, dramatically so before Python 3.6.</source>
          <target state="translated">避免直接实例化&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; &lt;/a&gt;。与&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt; &lt;code&gt;ssl.create_default_context()&lt;/code&gt; &lt;/a&gt;返回的默认值相比，新构建的&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; 的&lt;/a&gt;安全默认值安全性较低，在Python 3.6之前是如此。</target>
        </trans-unit>
        <trans-unit id="ba279a92ffbafb8cc72dbd38711f804d9d1b907b" translate="yes" xml:space="preserve">
          <source>Avoids implicitly chaining the &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; with any errors raised by &lt;code&gt;attempt_operation&lt;/code&gt; or &lt;code&gt;wait_for_operation_to_be_ready&lt;/code&gt;, by keeping the &lt;code&gt;while True:&lt;/code&gt; loop outside of the &lt;code&gt;except BlockingIOError:&lt;/code&gt; block.</source>
          <target state="translated">通过将 &lt;code&gt;while True:&lt;/code&gt; 循环保持在 &lt;code&gt;except BlockingIOError:&lt;/code&gt; 块除外的外部， &lt;code&gt;attempt_operation&lt;/code&gt; 隐式链接&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; &lt;/a&gt;和tryp_op​​eration或 &lt;code&gt;wait_for_operation_to_be_ready&lt;/code&gt; 引发的任何错误。</target>
        </trans-unit>
        <trans-unit id="31c7739aa209904fd9ba8df9b1d7877f93e87a25" translate="yes" xml:space="preserve">
          <source>Background: Why is async file I/O useful? The answer may surprise you</source>
          <target state="translated">背景:为什么异步文件I/O有用?为什么异步文件I/O有用?答案可能会让你大吃一惊</target>
        </trans-unit>
        <trans-unit id="db8c739d137036e869b27d3cd349fef1d54e3fdc" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;trio.abc.AsyncResource&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">基础：&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;trio.abc.AsyncResource&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e1388bfa18042159b536ccc6a59591396e82930" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;trio.abc.AsyncResource&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.Generic&quot;&gt;&lt;code&gt;typing.Generic&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">基础：&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;trio.abc.AsyncResource&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.Generic&quot;&gt; &lt;code&gt;typing.Generic&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a07e9c5dc09b0fdf3f845a0fb5af7389bc3e353" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">基础：&lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d77761b5945e21f05a6d9cadcfc66f09270cc4b" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;trio.abc.Listener&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">基础：&lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;trio.abc.Listener&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f328a04e58d3412dae1f568fe492e46d265a0c88" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;trio.abc.SendChannel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">基础：&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;trio.abc.SendChannel&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92038ea6f8a928181a4be9c9cf1e7731b00e53e5" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;trio.abc.SendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;trio.abc.ReceiveStream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">基础：&lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;trio.abc.SendStream&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;trio.abc.ReceiveStream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8714f32f570efd29c979c0a1881e76c7d8b385e4" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;trio.abc.Stream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">基础：&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;trio.abc.Stream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7267bc2117470326945d1c053489fd33d1ef228e" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#FutureWarning&quot;&gt;&lt;code&gt;FutureWarning&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">根据：&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#FutureWarning&quot;&gt; &lt;code&gt;FutureWarning&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5134303d2391790237c513240fb89f5fad90b2ad" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt;&lt;code&gt;trio.abc.Stream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">基础：&lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt; &lt;code&gt;trio.abc.Stream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13b5e07d4d8d4268f2b1632299d27a69609c9e40" translate="yes" xml:space="preserve">
          <source>Basically the idea is that if you have code or tests that use sleeps and timeouts, you can use this to make it run much faster, totally automatically. (At least, as long as those sleeps/timeouts are happening inside Trio; if your test involves talking to external service and waiting for it to timeout then obviously we can&amp;rsquo;t help you there.)</source>
          <target state="translated">基本上，这个想法是，如果您有使用睡眠和超时​​的代码或测试，则可以使用它来使其运行得更快，完全自动。（至少，只要这些睡眠/超时是在Trio内部发生的；如果您的测试涉及与外部服务进行对话并等待其超时，那么显然我们将无法为您提供帮助。）</target>
        </trans-unit>
        <trans-unit id="4390bc06787e8e996759d199f6a1f87bed1460ad" translate="yes" xml:space="preserve">
          <source>Be very careful to only use this decorator on functions that you know will either exit in bounded time, or else pass through a checkpoint regularly. (Of course all of your functions should have this property, but if you mess it up here then you won&amp;rsquo;t even be able to use control-C to escape!)</source>
          <target state="translated">请务必仅在您知道会在限定时间内退出或定期通过检查点的函数上使用此装饰器。（当然，所有函数都应具有此属性，但是如果您在此处将其弄乱了，那么您甚至将无法使用control-C进行转义！）</target>
        </trans-unit>
        <trans-unit id="f9a3eaabb5b822719bebd3e8a1b70ac9540e12dc" translate="yes" xml:space="preserve">
          <source>Before the child calls &lt;code&gt;task_status.started()&lt;/code&gt;, it&amp;rsquo;s effectively run underneath the call to &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;: if it raises an exception then that exception is reported by &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;, and does &lt;em&gt;not&lt;/em&gt; propagate out of the nursery. If &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; is cancelled, then the child task is also cancelled.</source>
          <target state="translated">孩子调用之前 &lt;code&gt;task_status.started()&lt;/code&gt; ，它有效地调用下面运行&lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt;：如果它抛出一个异常，则该异常被报道&lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt;，并没有&lt;em&gt;不&lt;/em&gt;传播幼儿园了。如果&lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt;被取消，则子任务也被取消。</target>
        </trans-unit>
        <trans-unit id="b4738e9dc47bf1e56e7606833bf5d66a428561b1" translate="yes" xml:space="preserve">
          <source>Before you begin</source>
          <target state="translated">在你开始之前</target>
        </trans-unit>
        <trans-unit id="6884e4f2d15ab622c9f8cbc3212f45de64615bea" translate="yes" xml:space="preserve">
          <source>Block until it&amp;rsquo;s possible that &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; might not block.</source>
          <target state="translated">阻塞，直到&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt;可能不会阻塞为止。</target>
        </trans-unit>
        <trans-unit id="17ae3ed338c93b1631e5994bf9cacece02cc9e67" translate="yes" xml:space="preserve">
          <source>Block until the internal flag value becomes True.</source>
          <target state="translated">阻止,直到内部标志值变为True。</target>
        </trans-unit>
        <trans-unit id="315b58797295c4e9ab36672b064ff4cedf0b8cef" translate="yes" xml:space="preserve">
          <source>Block until the kernel reports that the given object is readable.</source>
          <target state="translated">阻止,直到内核报告给定对象可读。</target>
        </trans-unit>
        <trans-unit id="c30db991fe44ffdb355948594f4b7365cf09c9d1" translate="yes" xml:space="preserve">
          <source>Block until the kernel reports that the given object is writable.</source>
          <target state="translated">封锁,直到内核报告给定对象可写为止。</target>
        </trans-unit>
        <trans-unit id="fdf86495cf9c07d20eda78e1274970ceb5c363a7" translate="yes" xml:space="preserve">
          <source>Block until the process exits.</source>
          <target state="translated">阻止,直到进程退出。</target>
        </trans-unit>
        <trans-unit id="6ff527ef5176f8e0ddcdc55991a82729810d38d5" translate="yes" xml:space="preserve">
          <source>Block until there are no runnable tasks.</source>
          <target state="translated">阻止,直到没有可运行的任务。</target>
        </trans-unit>
        <trans-unit id="caa9b1343024d62a02aab103e75d10940fa49af7" translate="yes" xml:space="preserve">
          <source>Blocking and non-blocking methods</source>
          <target state="translated">阻断和非阻断方法</target>
        </trans-unit>
        <trans-unit id="84ce31b1f7f4ca1f1ba81c9b7ae32f8c48ff831b" translate="yes" xml:space="preserve">
          <source>Borrow a token from the sack on behalf of &lt;code&gt;borrower&lt;/code&gt;, blocking if necessary.</source>
          <target state="translated">代表 &lt;code&gt;borrower&lt;/code&gt; 从麻袋中借出令牌，如有必要，将其冻结。</target>
        </trans-unit>
        <trans-unit id="7b27cb01fa52d37acba5b81c12f4fcd1e8bf0f72" translate="yes" xml:space="preserve">
          <source>Borrow a token from the sack on behalf of &lt;code&gt;borrower&lt;/code&gt;, without blocking.</source>
          <target state="translated">代表 &lt;code&gt;borrower&lt;/code&gt; 从麻袋中借出令牌，而不会阻止。</target>
        </trans-unit>
        <trans-unit id="9e07ec7dd71dfd4d21fe8bb1251d8339701ccce3" translate="yes" xml:space="preserve">
          <source>Borrow a token from the sack, blocking if necessary.</source>
          <target state="translated">从麻袋里借一块令牌,必要时挡住。</target>
        </trans-unit>
        <trans-unit id="d7f7be4a505172b9a7559a09e6a12361762ade09" translate="yes" xml:space="preserve">
          <source>Borrow a token from the sack, without blocking.</source>
          <target state="translated">从麻袋里借一块令牌,不阻挡。</target>
        </trans-unit>
        <trans-unit id="f1496c7a3db3e007c3057cc8783649b651817057" translate="yes" xml:space="preserve">
          <source>Both hooks are also exposed as attributes on the object, and you can change them at any time.</source>
          <target state="translated">这两个钩子也作为对象上的属性暴露出来,你可以随时改变它们。</target>
        </trans-unit>
        <trans-unit id="5dfefbef8c6a0e9381ea95ae6338587f901c36ba" translate="yes" xml:space="preserve">
          <source>Broadcasting an event with &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt;广播事件</target>
        </trans-unit>
        <trans-unit id="352d325bf39240b4196dfbd3a6f4f8e3e54c1c98" translate="yes" xml:space="preserve">
          <source>Buffering in channels</source>
          <target state="translated">通道中的缓冲</target>
        </trans-unit>
        <trans-unit id="5615f1a1d3e7ea5900f404cdff5bd7a1d2d99a9e" translate="yes" xml:space="preserve">
          <source>Bug tracker and source code: &lt;a href=&quot;https://github.com/python-trio/trio&quot;&gt;https://github.com/python-trio/trio&lt;/a&gt;</source>
          <target state="translated">错误跟踪器和源代码：&lt;a href=&quot;https://github.com/python-trio/trio&quot;&gt;https&lt;/a&gt; : //github.com/python-trio/trio</target>
        </trans-unit>
        <trans-unit id="6c85441cc2270b299d4d728765785da223b4dbba" translate="yes" xml:space="preserve">
          <source>But even more interestingly, you can set &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; to zero or a small value, and then it will watch the execution of the run loop, and any time things have settled down and everyone&amp;rsquo;s waiting for a timeout, it jumps the clock forward to that timeout. In many cases this allows natural-looking code involving timeouts to be automatically run at near full CPU utilization with no changes. (Thanks to &lt;a href=&quot;https://github.com/majek/fluxcapacitor&quot;&gt;fluxcapacitor&lt;/a&gt; for this awesome idea.)</source>
          <target state="translated">但更有趣的是，您可以将&lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt;设置为零或一个较小的值，然后它将监视run循环的执行，并且在情况稳定下来并且每个人都在等待超时时，它将时钟跳到该超时。在许多情况下，这使包含超时的看上去自然的代码可以自动以接近CPU的全部利用率运行而无需更改。 （感谢&lt;a href=&quot;https://github.com/majek/fluxcapacitor&quot;&gt;fluxcapacitor&lt;/a&gt;这个好主意。）</target>
        </trans-unit>
        <trans-unit id="c336aec89fecde4ca2a292b930cbc2263a0dcb64" translate="yes" xml:space="preserve">
          <source>But here&amp;rsquo;s the problem: for any individual I/O operation, there&amp;rsquo;s no way to know in advance whether it&amp;rsquo;s going to be one of the fast ones or one of the slow ones, so you can&amp;rsquo;t pick and choose. When you switch to async file I/O, it makes all the fast operations slower, and all the slow operations faster. Is that a win? In terms of overall speed, it&amp;rsquo;s hard to say: it depends what kind of disks you&amp;rsquo;re using and your kernel&amp;rsquo;s disk cache hit rate, which in turn depends on your file access patterns, how much spare RAM you have, the load on your service, &amp;hellip; all kinds of things. If the answer is important to you, then there&amp;rsquo;s no substitute for measuring your code&amp;rsquo;s actual behavior in your actual deployment environment. But what we &lt;em&gt;can&lt;/em&gt; say is that async disk I/O makes performance much more predictable across a wider range of runtime conditions.</source>
          <target state="translated">但这就是问题所在：对于任何单独的I / O操作，都无法事先知道它是快速操作之一还是慢速操作之一，因此您无法选择。当您切换到异步文件I / O时，它将使所有快速操作变慢，并且所有慢速操作变快。那是胜利吗？就整体速度而言，很难说：这取决于您使用的是哪种类型的磁盘以及内核的磁盘高速缓存命中率，而后者又取决于您的文件访问模式，您拥有多少备用RAM以及您的负载。服务，&amp;hellip;&amp;hellip;各种各样的东西。如果答案对您很重要，那么没有什么可以替代在实际部署环境中衡量代码的实际行为的。但是我们&lt;em&gt;可以&lt;/em&gt; 可以说，异步磁盘I / O使性能在更广泛的运行时条件范围内更加可预测。</target>
        </trans-unit>
        <trans-unit id="673eaaa36b6ee6e4487e1b49cb9a7a9b9b02d009" translate="yes" xml:space="preserve">
          <source>But if we want to write correct code in practice, then this principle is a little too sloppy and imprecise to be useful. How do we know which functions might block? What if a function blocks sometimes, but not others, depending on the arguments passed / network speed / phase of the moon? How do we figure out where the checkpoints are when we&amp;rsquo;re stressed and sleep deprived but still want to get this code review right, and would prefer to reserve our mental energy for thinking about the actual logic instead of worrying about checkpoints?</source>
          <target state="translated">但是，如果我们想在实践中编写正确的代码，则此原则过于草率和不精确，无法使用。我们如何知道哪些功能可能会阻塞？如果某个函数有时会阻塞，而其他函数不会阻塞，那取决于传递的参数/网络速度/月相，该怎么办？当我们感到压力和睡眠不足，但仍然希望正确进行代码审查时，我们如何弄清楚检查点在哪里？宁愿保留我们的精力来思考实际逻辑，而不必担心检查点？</target>
        </trans-unit>
        <trans-unit id="28b63c1792b2c52de75b3ab70de595321eeb55ea" translate="yes" xml:space="preserve">
          <source>But if you read the docs for &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;, you&amp;rsquo;ll see that all the pieces involved in wiring this up are public APIs, so you can adjust to suit the requirements of your tests. For example, here&amp;rsquo;s how to tweak a stream so that data flowing from left to right trickles in one byte at a time (but data flowing from right to left proceeds at full speed):</source>
          <target state="translated">但是，如果您阅读了&lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt;的文档，则会发现所有与之相关的部分都是公共API，因此您可以进行调整以适应测试需求。例如，以下是调整流的方法，以使从左向右流的数据一次在一个字节中滴流（但是从右向左流的数据以全速行进）：</target>
        </trans-unit>
        <trans-unit id="f830b9d400aed457d194359f0503b1ff2760384a" translate="yes" xml:space="preserve">
          <source>But of course, Trio isn&amp;rsquo;t the only coroutine runner in Python &amp;ndash; &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; has one, other event loops have them, you can even define your own.</source>
          <target state="translated">但是，当然，Trio并不是Python中唯一的协程运行器&lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; &lt;/a&gt;有一个，其他事件循环也有，甚至您可以定义自己的。</target>
        </trans-unit>
        <trans-unit id="9fceeabff672914a12928d15cad77ad846e4d22d" translate="yes" xml:space="preserve">
          <source>But this can be problematic. If you&amp;rsquo;re using h2 then &lt;em&gt;usually&lt;/em&gt; reading incoming data doesn&amp;rsquo;t create the need to send any data, so we don&amp;rsquo;t want to force every task that tries to read from the network to sit and wait a potentially long time for &lt;code&gt;sendall&lt;/code&gt; to finish. And in some situations this could even potentially cause a deadlock, if the remote peer is waiting for you to read some data before it accepts the data you&amp;rsquo;re sending.</source>
          <target state="translated">但这可能是有问题的。如果您使用的是h2，那么&lt;em&gt;通常&lt;/em&gt;读取传入数据并不需要发送任何数据，因此我们不想强迫试图从网络读取的每项任务都处于等待状态，并且可能要等待很长时间才能将 &lt;code&gt;sendall&lt;/code&gt; 发送给完。在某些情况下，如果远程对等端在接受您要发送的数据之前等待您读取一些数据，则甚至可能导致死锁。</target>
        </trans-unit>
        <trans-unit id="412c1b16e781ad814146eddc07e4fd649b546625" translate="yes" xml:space="preserve">
          <source>But this is more error-prone, especially if you use a loop to spawn the producers/consumers.</source>
          <target state="translated">但这比较容易出错,尤其是当你使用循环来生成生产者/消费者的时候。</target>
        </trans-unit>
        <trans-unit id="530bcde7f320efe9c1c4e3043d433d9a24c64568" translate="yes" xml:space="preserve">
          <source>But, even if that happens, we&amp;rsquo;re not out of the woods yet! After the producers exit, the two consumers race to be the first to notice that the &lt;code&gt;send_channel&lt;/code&gt; has closed. Suppose that X wins the race. It exits its &lt;code&gt;async for&lt;/code&gt; loop, then exits the &lt;code&gt;async with&lt;/code&gt; block&amp;hellip; and closes the &lt;code&gt;receive_channel&lt;/code&gt;, while Y is still using it. Again, this causes a crash.</source>
          <target state="translated">但是，即使发生这种情况，我们仍未走出困境！生产者退出后，两个消费者 &lt;code&gt;send_channel&lt;/code&gt; 注意到send_channel已关闭。假设X赢得比赛。它退出其 &lt;code&gt;async for&lt;/code&gt; 循环，然后退出 &lt;code&gt;async with&lt;/code&gt; block&amp;hellip; 的异步并关闭 &lt;code&gt;receive_channel&lt;/code&gt; ，而Y仍在使用它。同样，这会导致崩溃。</target>
        </trans-unit>
        <trans-unit id="16f5c9c07cafa159b445098218243944b7cef14f" translate="yes" xml:space="preserve">
          <source>But, of course, the entire point of an async library is to let you do multiple things at once. The one and only way to do that in Trio is through the task spawning interface. So if you want your program to walk &lt;em&gt;and&lt;/em&gt; chew gum, this is the section for you.</source>
          <target state="translated">但是，当然，异步库的全部目的是让您一次执行多项操作。在Trio中做到这一点的唯一方法是通过任务生成界面。因此，如果您想让程序走路&lt;em&gt;和&lt;/em&gt;嚼口香糖，这是适合您的部分。</target>
        </trans-unit>
        <trans-unit id="08e147f3bc16786707a8ac015a5f1b0329a64f59" translate="yes" xml:space="preserve">
          <source>By convention, a return code of zero indicates success. On UNIX, negative values indicate termination due to a signal, e.g., -11 if terminated by signal 11 (&lt;code&gt;SIGSEGV&lt;/code&gt;). On Windows, a process that exits due to a call to &lt;a href=&quot;#trio.Process.terminate&quot;&gt;&lt;code&gt;Process.terminate()&lt;/code&gt;&lt;/a&gt; will have an exit status of 1.</source>
          <target state="translated">按照惯例，返回码为零表示成功。在UNIX上，负值表示由于信号而终止，例如，如果由信号11（ &lt;code&gt;SIGSEGV&lt;/code&gt; ）终止，则为-11 。在Windows上，由于调用&lt;a href=&quot;#trio.Process.terminate&quot;&gt; &lt;code&gt;Process.terminate()&lt;/code&gt; &lt;/a&gt;而退出的进程的退出状态为1。</target>
        </trans-unit>
        <trans-unit id="3a7a80e6ffbfb28cc8f945974fc47d089de603d5" translate="yes" xml:space="preserve">
          <source>By default for TCP sockets, &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt; enables &lt;code&gt;TCP_NODELAY&lt;/code&gt;, and (on platforms where it&amp;rsquo;s supported) enables &lt;code&gt;TCP_NOTSENT_LOWAT&lt;/code&gt; with a reasonable buffer size (currently 16 KiB) &amp;ndash; see &lt;a href=&quot;https://github.com/python-trio/trio/issues/72&quot;&gt;issue #72&lt;/a&gt; for discussion. You can of course override these defaults by calling &lt;a href=&quot;#trio.SocketStream.setsockopt&quot;&gt;&lt;code&gt;setsockopt()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">默认情况下，对于TCP套接字，&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt;启用 &lt;code&gt;TCP_NODELAY&lt;/code&gt; ，并且（在受支持的平台上）启用具有合理缓冲区大小（当前为16 KiB）的 &lt;code&gt;TCP_NOTSENT_LOWAT&lt;/code&gt; &amp;ndash;请参见&lt;a href=&quot;https://github.com/python-trio/trio/issues/72&quot;&gt;问题＃72&lt;/a&gt;。您当然可以通过调用&lt;a href=&quot;#trio.SocketStream.setsockopt&quot;&gt; &lt;code&gt;setsockopt()&lt;/code&gt; &lt;/a&gt;覆盖这些默认值。</target>
        </trans-unit>
        <trans-unit id="60f1cefb4d269d53a93fd1da99c35ecbcaa23759" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; uses a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; to limit the number of threads running at once; see &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt;&lt;code&gt;trio.to_thread.current_default_thread_limiter&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt;使用&lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt;限制一次运行的线程数。有关详细信息，请参见&lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt; &lt;code&gt;trio.to_thread.current_default_thread_limiter&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f9393fd07494846f3c9bd78e82bb2a27abf584b" translate="yes" xml:space="preserve">
          <source>By default, Trio uses an unspecified monotonic clock, but this can be changed by passing a custom clock object to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; (e.g. for testing).</source>
          <target state="translated">默认情况下，Trio使用未指定的单调时钟，但是可以通过将自定义时钟对象传递给&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt;来更改（例如，用于测试）。</target>
        </trans-unit>
        <trans-unit id="479052e549b38b3cf5c8f080e4bba3e93ef2d967" translate="yes" xml:space="preserve">
          <source>By default, Trio&amp;rsquo;s &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt;&lt;code&gt;getnameinfo()&lt;/code&gt;&lt;/a&gt; functions use the standard system resolver functions. This function allows you to customize that behavior. The main intended use case is for testing, but it might also be useful for using third-party resolvers like &lt;a href=&quot;https://c-ares.haxx.se/&quot;&gt;c-ares&lt;/a&gt; (though be warned that these rarely make perfect drop-in replacements for the system resolver). See &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;code&gt;trio.abc.HostnameResolver&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">默认情况下，Trio的&lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt; &lt;code&gt;getnameinfo()&lt;/code&gt; &lt;/a&gt;函数使用标准的系统解析器函数。此功能允许您自定义该行为。主要的预期用例是进行测试，但对于使用诸如&lt;a href=&quot;https://c-ares.haxx.se/&quot;&gt;c-ares之&lt;/a&gt;类的第三方解析器也可能很有用（尽管请注意，这些解析器很少能完美替代系统解析器）。有关更多详细信息，请参见&lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt; &lt;code&gt;trio.abc.HostnameResolver&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5700d3cb14d3369161e0910959cf3905cb1f858" translate="yes" xml:space="preserve">
          <source>By default, it starts at time 0, and clock time only advances when you explicitly call &lt;a href=&quot;#trio.testing.MockClock.jump&quot;&gt;&lt;code&gt;jump()&lt;/code&gt;&lt;/a&gt;. This provides an extremely controllable clock for testing.</source>
          <target state="translated">默认情况下，它从时间0开始，并且时钟时间仅在显式调用&lt;a href=&quot;#trio.testing.MockClock.jump&quot;&gt; &lt;code&gt;jump()&lt;/code&gt; &lt;/a&gt;时才增加。这为测试提供了极为可控的时钟。</target>
        </trans-unit>
        <trans-unit id="b58f2f817ed55edb23f17dd398967d3698d94d89" translate="yes" xml:space="preserve">
          <source>By default, system tasks have &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection &lt;em&gt;enabled&lt;/em&gt;. If you want your task to be interruptible by control-C, then you need to use &lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt;&lt;code&gt;disable_ki_protection()&lt;/code&gt;&lt;/a&gt; explicitly (and come up with some plan for what to do with a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;, given that system tasks aren&amp;rsquo;t allowed to raise exceptions).</source>
          <target state="translated">默认情况下，系统任务&lt;em&gt;启用了&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt;保护。如果希望您的任务可以被Control-C中断，则需要显式使用&lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt; &lt;code&gt;disable_ki_protection()&lt;/code&gt; &lt;/a&gt;（并提出一些与&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt;一起使用的计划，因为不允许系统任务引发异常）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c5a4be5f8c5502c9f134af83e0fc52fbf1d81d1" translate="yes" xml:space="preserve">
          <source>By default, this will print &lt;code&gt;b&quot;12345&quot;&lt;/code&gt; and then immediately exit; with our trickle stream it instead sleeps 1 second, then prints &lt;code&gt;b&quot;1&quot;&lt;/code&gt;, then sleeps 1 second, then prints &lt;code&gt;b&quot;2&quot;&lt;/code&gt;, etc.</source>
          <target state="translated">默认情况下，这将打印 &lt;code&gt;b&quot;12345&quot;&lt;/code&gt; ，然后立即退出；使用我们的trick流，它改为睡眠1秒，然后打印 &lt;code&gt;b&quot;1&quot;&lt;/code&gt; ，然后睡眠1秒，然后打印 &lt;code&gt;b&quot;2&quot;&lt;/code&gt; ，依此类推。</target>
        </trans-unit>
        <trans-unit id="eadf7b64718fcecec9e169b6cd95cc0cf6518eb8" translate="yes" xml:space="preserve">
          <source>Call this before closing a file descriptor or &lt;code&gt;SOCKET&lt;/code&gt; handle that another task might be waiting on. This will cause any &lt;a href=&quot;#trio.hazmat.wait_readable&quot;&gt;&lt;code&gt;wait_readable&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.hazmat.wait_writable&quot;&gt;&lt;code&gt;wait_writable&lt;/code&gt;&lt;/a&gt; calls to immediately raise &lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在关闭可能正在等待其他任务的文件描述符或 &lt;code&gt;SOCKET&lt;/code&gt; 句柄之前调用此函数。这将导致任何&lt;a href=&quot;#trio.hazmat.wait_readable&quot;&gt; &lt;code&gt;wait_readable&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#trio.hazmat.wait_writable&quot;&gt; &lt;code&gt;wait_writable&lt;/code&gt; &lt;/a&gt;调用立即引发&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8bc1558d2fe1a2c54a2a164cbb59e5c8c644a3a1" translate="yes" xml:space="preserve">
          <source>Called after handling pending I/O.</source>
          <target state="translated">处理完待处理的I/O后调用。</target>
        </trans-unit>
        <trans-unit id="f8bfde0992ada594581390a46c166b77baca3161" translate="yes" xml:space="preserve">
          <source>Called at the beginning of &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt;的开头调用。</target>
        </trans-unit>
        <trans-unit id="1f2793beb004add327f22b3156bfba07b27d6e11" translate="yes" xml:space="preserve">
          <source>Called at the beginning of the run.</source>
          <target state="translated">在运行之初就叫。</target>
        </trans-unit>
        <trans-unit id="f7acf6acc0d0f3320d572dca39e7a7e07743123e" translate="yes" xml:space="preserve">
          <source>Called before blocking to wait for I/O readiness.</source>
          <target state="translated">在阻塞前调用,以等待I/O准备就绪。</target>
        </trans-unit>
        <trans-unit id="1f142fccb8ca1dc1831e93b467e4f3395cda028f" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由&lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="29c1d3563dccbfdd83877b549758692595c9c581" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt;&lt;code&gt;trio.socket.getnameinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由&lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt; &lt;code&gt;trio.socket.getnameinfo()&lt;/code&gt; &lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="aed9b81d2c1131bfffe4d070ed0619e875566978" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由&lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="8d66f6f8b90776c10ddba63543e685f9f3d93f60" translate="yes" xml:space="preserve">
          <source>Called immediately before we resume running the given task.</source>
          <target state="translated">在我们恢复运行给定任务之前立即调用。</target>
        </trans-unit>
        <trans-unit id="261a5d5178d7387f8183212c0cd69cb1977900da" translate="yes" xml:space="preserve">
          <source>Called just before &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">在&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt;返回之前调用。</target>
        </trans-unit>
        <trans-unit id="b884c70436293eb060bb3491a325d480b9671ac9" translate="yes" xml:space="preserve">
          <source>Called when the given task becomes runnable.</source>
          <target state="translated">当给定任务可运行时调用。</target>
        </trans-unit>
        <trans-unit id="35ab13509c0b0bba5b8df114b0b980a549bd6031" translate="yes" xml:space="preserve">
          <source>Called when the given task exits.</source>
          <target state="translated">当给定任务退出时调用。</target>
        </trans-unit>
        <trans-unit id="626700fae10a1356415b4972c54ece4515e4c958" translate="yes" xml:space="preserve">
          <source>Called when the given task is created.</source>
          <target state="translated">在创建任务时调用。</target>
        </trans-unit>
        <trans-unit id="233443fcf281f0b8386a0968b812f850857ffd12" translate="yes" xml:space="preserve">
          <source>Called when we return to the main run loop after a task has yielded.</source>
          <target state="translated">当我们在任务产生后返回主运行循环时调用。</target>
        </trans-unit>
        <trans-unit id="a2e360b3ae69814d2bc4f200eb26320d68ccd43c" translate="yes" xml:space="preserve">
          <source>Calling:</source>
          <target state="translated">Calling:</target>
        </trans-unit>
        <trans-unit id="ca6c307d3032f60efa049582739a99b205d7915a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;aclose&lt;/code&gt; on both underlying streams.</source>
          <target state="translated">在两个基础流上调用 &lt;code&gt;aclose&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08c519dcd2a8fb0112b30c9b37377bc0d2e81245" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;self.receive_stream.receive_some&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;self.receive_stream.receive_some&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8772d34b9efd174bb2bc372d12b3a9aef3fdba3c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;self.send_stream.send_all&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;self.send_stream.send_all&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="689c7ef3178baffe7752a81f89957ee75f40366d" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;self.send_stream.wait_send_all_might_not_block&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;self.send_stream.wait_send_all_might_not_block&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6dcbaa082561c00fc529f363d4aea0631e29f017" translate="yes" xml:space="preserve">
          <source>Calls the &lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some_hook&quot;&gt;&lt;code&gt;receive_some_hook&lt;/code&gt;&lt;/a&gt; (if any), and then retrieves data from the internal buffer, blocking if necessary.</source>
          <target state="translated">调用&lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some_hook&quot;&gt; &lt;code&gt;receive_some_hook&lt;/code&gt; &lt;/a&gt;（如果有），然后从内部缓冲区中检索数据，必要时进行阻塞。</target>
        </trans-unit>
        <trans-unit id="a6e5e384d9f188aacab0c35281723d4e24af136b" translate="yes" xml:space="preserve">
          <source>Calls the &lt;a href=&quot;#trio.testing.MemorySendStream.wait_send_all_might_not_block_hook&quot;&gt;&lt;code&gt;wait_send_all_might_not_block_hook&lt;/code&gt;&lt;/a&gt; (if any), and then returns immediately.</source>
          <target state="translated">调用&lt;a href=&quot;#trio.testing.MemorySendStream.wait_send_all_might_not_block_hook&quot;&gt; &lt;code&gt;wait_send_all_might_not_block_hook&lt;/code&gt; &lt;/a&gt;（如果有），然后立即返回。</target>
        </trans-unit>
        <trans-unit id="f10923fa9e8e643d29ab59bd93446bf992a6d907" translate="yes" xml:space="preserve">
          <source>Cancel scopes are not reusable or reentrant; that is, each cancel scope can be used for at most one &lt;code&gt;with&lt;/code&gt; block. (You&amp;rsquo;ll get a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; if you violate this rule.)</source>
          <target state="translated">取消范围不可重用或可重入；也就是说，每个取消作用域最多可 &lt;code&gt;with&lt;/code&gt; 一个块一起使用。（如果违反此规则，则会收到&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="81686d1e66168847e2ace4f30aee9372739e14a4" translate="yes" xml:space="preserve">
          <source>Cancellation API details</source>
          <target state="translated">取消API详情</target>
        </trans-unit>
        <trans-unit id="d6d584a8ce62812cd18c2c454f3ca9d1ca893f41" translate="yes" xml:space="preserve">
          <source>Cancellation and primitive operations</source>
          <target state="translated">取消和基本操作</target>
        </trans-unit>
        <trans-unit id="bef7bb5e57e5a92b8be6213bc977ef4ea4184ce0" translate="yes" xml:space="preserve">
          <source>Cancellation and timeouts</source>
          <target state="translated">取消和超时</target>
        </trans-unit>
        <trans-unit id="59b0482bdded1133e8a5fead2d8afd30f974346d" translate="yes" xml:space="preserve">
          <source>Cancellation semantics</source>
          <target state="translated">取消语义</target>
        </trans-unit>
        <trans-unit id="94d6332b8909ea75970b6b4fdc80b35ecc20fba7" translate="yes" xml:space="preserve">
          <source>Cancellations in Trio are &amp;ldquo;level triggered&amp;rdquo;, meaning that once a block has been cancelled, &lt;em&gt;all&lt;/em&gt; cancellable operations in that block will keep raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. This helps avoid some pitfalls around resource clean-up. For example, imagine that we have a function that connects to a remote server and sends some messages, and then cleans up on the way out:</source>
          <target state="translated">Trio中的取消是&amp;ldquo;级别触发&amp;rdquo;的，这意味着一旦取消了一个块，该块中的&lt;em&gt;所有&lt;/em&gt;可取消操作将继续引发&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;。这有助于避免资源清理方面的一些陷阱。例如，假设我们有一个功能可以连接到远程服务器并发送一些消息，然后清除出路：</target>
        </trans-unit>
        <trans-unit id="0d2c360a80f52470e7f8b83eff4301ca10ff10b3" translate="yes" xml:space="preserve">
          <source>Cancels this scope immediately.</source>
          <target state="translated">立即取消这个范围。</target>
        </trans-unit>
        <trans-unit id="31ceffa7c4fe7185611cc1eb3c159aad57550985" translate="yes" xml:space="preserve">
          <source>Channel objects can be closed by calling &lt;a href=&quot;reference-io#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose&lt;/code&gt;&lt;/a&gt; or using &lt;code&gt;async with&lt;/code&gt;. They are &lt;em&gt;not&lt;/em&gt; automatically closed when garbage collected. Closing memory channels isn&amp;rsquo;t mandatory, but it is generally a good idea, because it helps avoid situations where tasks get stuck waiting on a channel when there&amp;rsquo;s no-one on the other side. See &lt;a href=&quot;#channel-shutdown&quot;&gt;Clean shutdown with channels&lt;/a&gt; for details.</source>
          <target state="translated">可以通过调用&lt;a href=&quot;reference-io#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose&lt;/code&gt; &lt;/a&gt;或使用 &lt;code&gt;async with&lt;/code&gt; 来关闭通道对象。收集垃圾时它们&lt;em&gt;不会&lt;/em&gt;自动关闭。关闭内存通道不是强制性的，但这通常是一个好主意，因为它有助于避免在另一方没有人的情况下任务在通道上卡住的情况。有关详细信息，请参见&lt;a href=&quot;#channel-shutdown&quot;&gt;使用通道清除关机&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5beb5dd56408be62815ea722ff005781ac57b3c1" translate="yes" xml:space="preserve">
          <source>Cheat sheet:</source>
          <target state="translated">小抄。</target>
        </trans-unit>
        <trans-unit id="5d0402051b976bb8c461f7092dd83b539f201202" translate="yes" xml:space="preserve">
          <source>Check if the process has exited yet.</source>
          <target state="translated">检查流程是否已经退出。</target>
        </trans-unit>
        <trans-unit id="99dce9cfa994376c7012637e31516c6ac05c9b2e" translate="yes" xml:space="preserve">
          <source>Check that &lt;a href=&quot;reference-core#trio.sleep&quot;&gt;&lt;code&gt;trio.sleep()&lt;/code&gt;&lt;/a&gt; is a checkpoint, even if it doesn&amp;rsquo;t block:</source>
          <target state="translated">检查&lt;a href=&quot;reference-core#trio.sleep&quot;&gt; &lt;code&gt;trio.sleep()&lt;/code&gt; &lt;/a&gt;是否为检查点，即使它没有阻塞：</target>
        </trans-unit>
        <trans-unit id="9dd73b1e659a659ad6d4dcaea475a5cc4de5b8c4" translate="yes" xml:space="preserve">
          <source>Check the current value of an option on the underlying socket.</source>
          <target state="translated">检查底层套接字上期权的当前值。</target>
        </trans-unit>
        <trans-unit id="20967b01d8903985483d3209955125b8ee51474f" translate="yes" xml:space="preserve">
          <source>Check whether the calling code has &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection enabled.</source>
          <target state="translated">检查调用代码是否已启用&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt;保护。</target>
        </trans-unit>
        <trans-unit id="88e1669ff508c58005f68fe9617b0958a0b4a996" translate="yes" xml:space="preserve">
          <source>Check whether the lock is currently held.</source>
          <target state="translated">检查当前是否被锁住。</target>
        </trans-unit>
        <trans-unit id="5ae0d67fbacc52e0c961355167ed1dcc9fdc273e" translate="yes" xml:space="preserve">
          <source>Check whether the socket is readable or not.</source>
          <target state="translated">检查插座是否可读。</target>
        </trans-unit>
        <trans-unit id="4008592f35f63d2ce5cf53beec32dcc247cc261c" translate="yes" xml:space="preserve">
          <source>Check whether the underlying lock is currently held.</source>
          <target state="translated">检查当前是否持有标的锁。</target>
        </trans-unit>
        <trans-unit id="a2b3a59adb81ffe32d8631c171b886f3d460360a" translate="yes" xml:space="preserve">
          <source>Checkpoints</source>
          <target state="translated">Checkpoints</target>
        </trans-unit>
        <trans-unit id="aad917cb07530e653ce3782a304aa67132789402" translate="yes" xml:space="preserve">
          <source>Child tasks and cancellation</source>
          <target state="translated">儿童任务和取消</target>
        </trans-unit>
        <trans-unit id="01c92ef80410cf8e2458b13dd6e02e97ff4b05f5" translate="yes" xml:space="preserve">
          <source>Clean shutdown with channels</source>
          <target state="translated">带通道的清洁关机</target>
        </trans-unit>
        <trans-unit id="784258aa3e82bf98876fffb3b3acb5f4cbe86b6c" translate="yes" xml:space="preserve">
          <source>Cleanly close down the SSL/TLS encryption layer, allowing the underlying stream to be used for unencrypted communication.</source>
          <target state="translated">清晰地关闭SSL/TLS加密层,允许底层流用于未加密的通信。</target>
        </trans-unit>
        <trans-unit id="5fa38c822c36efd1393228e6e95fbf224d0de0c2" translate="yes" xml:space="preserve">
          <source>Clone this receive channel object.</source>
          <target state="translated">克隆这个接收通道对象。</target>
        </trans-unit>
        <trans-unit id="26f9ba049c495ce23a501d2faccd6b6380ec2d77" translate="yes" xml:space="preserve">
          <source>Clone this send channel object.</source>
          <target state="translated">克隆这个发送通道对象。</target>
        </trans-unit>
        <trans-unit id="53b3076f17b316cb84b6c29640d7e43f09e5ae18" translate="yes" xml:space="preserve">
          <source>Close an async resource or async generator immediately, without blocking to do any graceful cleanup.</source>
          <target state="translated">立即关闭一个异步资源或异步生成器,而不阻止做任何优雅的清理。</target>
        </trans-unit>
        <trans-unit id="035296db4c7f1acd83221d71dd8e4179d8a62b32" translate="yes" xml:space="preserve">
          <source>Close any pipes we have to the process (both input and output) and wait for it to exit.</source>
          <target state="translated">关闭我们与进程的任何管道(包括输入和输出),并等待它退出。</target>
        </trans-unit>
        <trans-unit id="588a267fa1c5900f167e70a9805d55eb4e9fae92" translate="yes" xml:space="preserve">
          <source>Close the transport listener.</source>
          <target state="translated">关闭传输监听器。</target>
        </trans-unit>
        <trans-unit id="92a76bf8154c807de0dcad6ffb92786e9a377d3f" translate="yes" xml:space="preserve">
          <source>Close this listener and its underlying socket.</source>
          <target state="translated">关闭这个监听器和它的底层套接字。</target>
        </trans-unit>
        <trans-unit id="a357d054163bbdbd417f533dddc5214d41ff476e" translate="yes" xml:space="preserve">
          <source>Close this resource, possibly blocking.</source>
          <target state="translated">关闭这个资源,可能会阻断。</target>
        </trans-unit>
        <trans-unit id="264398069882e7753347718021d0c9c51b7ce8fc" translate="yes" xml:space="preserve">
          <source>Code of Conduct</source>
          <target state="translated">行为守则</target>
        </trans-unit>
        <trans-unit id="746e8bd7005ece0b3884461868490a2886db15a2" translate="yes" xml:space="preserve">
          <source>Code of conduct: Contributors are requested to follow our &lt;a href=&quot;https://trio.readthedocs.io/en/latest/code-of-conduct.html&quot;&gt;code of conduct&lt;/a&gt; in all project spaces.</source>
          <target state="translated">行为准则：请贡献者在所有项目空间中遵守我们&lt;a href=&quot;https://trio.readthedocs.io/en/latest/code-of-conduct.html&quot;&gt;的行为准则&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d28ccf5a13cb7101b38230ecb28bea934cb4291f" translate="yes" xml:space="preserve">
          <source>Combine this path with one or several arguments, and return a new path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).</source>
          <target state="translated">将这个路径与一个或几个参数结合起来,然后返回一个新的路径,代表一个子路径(如果所有的参数都是相对路径)或者一个完全不同的路径(如果其中一个参数是锚定的)。</target>
        </trans-unit>
        <trans-unit id="65245cc21eba1d1c7e7fddcf1b4438e65f650376" translate="yes" xml:space="preserve">
          <source>Compute the real time until the given deadline.</source>
          <target state="translated">计算给定的截止日期前的实时时间。</target>
        </trans-unit>
        <trans-unit id="d188261dfbdc2cfd51eb5fff57de708b9c31454d" translate="yes" xml:space="preserve">
          <source>Connect the socket to a remote address.</source>
          <target state="translated">将插座连接到远程地址。</target>
        </trans-unit>
        <trans-unit id="800add8197c9d879f3f1a2c8248892a00488ba45" translate="yes" xml:space="preserve">
          <source>Connect to the given &lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">连接到给定的&lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="698feffa6fbdf24c6dd24be1554ee55fedb5f42d" translate="yes" xml:space="preserve">
          <source>Connect to the given host and port over TCP.</source>
          <target state="translated">通过TCP连接到指定的主机和端口。</target>
        </trans-unit>
        <trans-unit id="dd0929c6d129ec17dfa57ea8a0921e4c15b090b4" translate="yes" xml:space="preserve">
          <source>Connecting to an in-process socket server</source>
          <target state="translated">连接到进程内套接字服务器</target>
        </trans-unit>
        <trans-unit id="4b801243997b335019aa4cb1a2eda249a55d038e" translate="yes" xml:space="preserve">
          <source>Contains all the child &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; objects which are still running.</source>
          <target state="translated">包含所有仍在运行的子&lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="3bddea3d2467ed7b12f0ab27cd877bc1cf844289" translate="yes" xml:space="preserve">
          <source>Contributing to Trio and related projects</source>
          <target state="translated">对Trio和相关项目的贡献</target>
        </trans-unit>
        <trans-unit id="dd8d019f05b4b5b283596920dd515b31a77df643" translate="yes" xml:space="preserve">
          <source>Contributor guide: &lt;a href=&quot;https://trio.readthedocs.io/en/latest/contributing.html&quot;&gt;https://trio.readthedocs.io/en/latest/contributing.html&lt;/a&gt;</source>
          <target state="translated">贡献者指南：&lt;a href=&quot;https://trio.readthedocs.io/en/latest/contributing.html&quot;&gt;https&lt;/a&gt; : //trio.readthedocs.io/en/latest/contributing.html</target>
        </trans-unit>
        <trans-unit id="0e29f2bf28ae181dcc1f858f04d215a291dc038c" translate="yes" xml:space="preserve">
          <source>Convert a blocking operation into an async operation using a thread.</source>
          <target state="translated">使用线程将阻塞操作转换为异步操作。</target>
        </trans-unit>
        <trans-unit id="276de9a62bb932e4c343f213f05d286af43a0d3e" translate="yes" xml:space="preserve">
          <source>Convert a standard library &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt; object into a Trio socket object.</source>
          <target state="translated">将标准库&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt;对象转换为Trio套接字对象。</target>
        </trans-unit>
        <trans-unit id="c024281ced10e6a1d03ece9c47de83e6ef569254" translate="yes" xml:space="preserve">
          <source>Create &lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt; objects to listen for TCP connections.</source>
          <target state="translated">创建&lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt;对象以侦听TCP连接。</target>
        </trans-unit>
        <trans-unit id="e347faadc22e2b28043f6892d02ba59794212183" translate="yes" xml:space="preserve">
          <source>Create a connected, pure Python, unidirectional stream where data flows in lockstep.</source>
          <target state="translated">创建一个连接的、纯Python的、单向的数据流,数据以锁步的方式流动。</target>
        </trans-unit>
        <trans-unit id="2be9228bbeea61d2f22276d384ece99dd757e610" translate="yes" xml:space="preserve">
          <source>Create a connected, pure-Python, bidirectional stream where data flows in lockstep.</source>
          <target state="translated">创建一个连接的、纯Python的、双向的数据流,其中数据以锁定的方式流动。</target>
        </trans-unit>
        <trans-unit id="afd5545b50d0fd9918e03f162eea8fed63bbf9a5" translate="yes" xml:space="preserve">
          <source>Create a connected, pure-Python, bidirectional stream with infinite buffering and flexible configuration options.</source>
          <target state="translated">创建一个具有无限缓冲和灵活配置选项的连接的、纯Python的、双向的流。</target>
        </trans-unit>
        <trans-unit id="16fd426e055ccfde61ebd50613e240b90a4120de" translate="yes" xml:space="preserve">
          <source>Create a connected, pure-Python, unidirectional stream with infinite buffering and flexible configuration options.</source>
          <target state="translated">创建一个连接的、纯Python的、具有无限缓冲和灵活配置选项的单向流。</target>
        </trans-unit>
        <trans-unit id="4c5674378b77c928b661f2f5d24e4b5af9e0efb8" translate="yes" xml:space="preserve">
          <source>Create a new Trio socket, like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建一个新的Trio套接字，例如&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6d00615f23bd18743bd5e4f3fbb5bf3051fd73f" translate="yes" xml:space="preserve">
          <source>Create and return a socket object.</source>
          <target state="translated">创建并返回一个socket对象。</target>
        </trans-unit>
        <trans-unit id="9cf47fcd675898eff0e3b8e79ec7d8b7bb8c7284" translate="yes" xml:space="preserve">
          <source>Creates a cancel scope with the given deadline, and raises an error if it is actually cancelled.</source>
          <target state="translated">用给定的截止日期创建一个取消作用域,并在实际取消时引发一个错误。</target>
        </trans-unit>
        <trans-unit id="f93b3b45c8ea9164c989693e6fa16a0100351871" translate="yes" xml:space="preserve">
          <source>Creates a cancel scope with the given timeout, and raises an error if it is actually cancelled.</source>
          <target state="translated">用给定的超时时间创建一个取消作用域,并在实际取消时引发一个错误。</target>
        </trans-unit>
        <trans-unit id="c3f897b8e6c02e94ce9b26b00cb7864784b899fb" translate="yes" xml:space="preserve">
          <source>Creates a child task, scheduling &lt;code&gt;await async_fn(*args)&lt;/code&gt;.</source>
          <target state="translated">创建一个子任务，调度 &lt;code&gt;await async_fn(*args)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee1e2c14a1406cbe854dca9278d7dd0b325b77bc" translate="yes" xml:space="preserve">
          <source>Creates and initalizes a child task.</source>
          <target state="translated">创建并启动一个儿童任务。</target>
        </trans-unit>
        <trans-unit id="b2bec567835477658a29d71119dd0209ee2ddec3" translate="yes" xml:space="preserve">
          <source>Creating a nursery also implicitly creates a cancellation scope, which is exposed as the &lt;a href=&quot;#trio.Nursery.cancel_scope&quot;&gt;&lt;code&gt;cancel_scope&lt;/code&gt;&lt;/a&gt; attribute. This is used internally to implement the logic where if an error occurs then &lt;code&gt;__aexit__&lt;/code&gt; cancels all children, but you can use it for other things, e.g. if you want to explicitly cancel all children in response to some external event.</source>
          <target state="translated">创建托儿所还会隐式创建取消范围，该范围显示为&lt;a href=&quot;#trio.Nursery.cancel_scope&quot;&gt; &lt;code&gt;cancel_scope&lt;/code&gt; &lt;/a&gt;属性。这在内部用于实现逻辑，如果发生错误，则 &lt;code&gt;__aexit__&lt;/code&gt; 取消所有子级，但是您可以将其用于其他用途，例如，如果要响应某个外部事件而显式取消所有子级。</target>
        </trans-unit>
        <trans-unit id="7e6dfd567b7a3307a537cbe53c08739b6a191602" translate="yes" xml:space="preserve">
          <source>Currently the following fields are defined:</source>
          <target state="translated">目前定义了以下字段:</target>
        </trans-unit>
        <trans-unit id="b917c15a50ea6342a17c9063be5bcf13e4adf47b" translate="yes" xml:space="preserve">
          <source>Currently, &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt;&lt;code&gt;StrictFIFOLock&lt;/code&gt;&lt;/a&gt; is simply an alias for &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;, but (a) this may not always be true in the future, especially if Trio ever implements &lt;a href=&quot;https://github.com/python-trio/trio/issues/32&quot;&gt;more sophisticated scheduling policies&lt;/a&gt;, and (b) the above code is relying on a pretty subtle property of its lock. Using a &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt;&lt;code&gt;StrictFIFOLock&lt;/code&gt;&lt;/a&gt; acts as an executable reminder that you&amp;rsquo;re relying on this property.</source>
          <target state="translated">当前，&lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt; &lt;code&gt;StrictFIFOLock&lt;/code&gt; &lt;/a&gt;只是&lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt;的别名，但是（a）将来可能并非总是如此，特别是如果Trio实现了&lt;a href=&quot;https://github.com/python-trio/trio/issues/32&quot;&gt;更复杂的调度策略时&lt;/a&gt;，并且（b）上面的代码依赖于它的相当微妙的属性。锁。使用&lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt; &lt;code&gt;StrictFIFOLock&lt;/code&gt; &lt;/a&gt;可以作为可执行文件提醒您依赖此属性。</target>
        </trans-unit>
        <trans-unit id="c8852ce839266b1032f3de681f74884aa8adf52b" translate="yes" xml:space="preserve">
          <source>Currently, Trio always uses unbuffered byte streams for communicating with a process, so it does not support the &lt;code&gt;encoding&lt;/code&gt;, &lt;code&gt;errors&lt;/code&gt;, &lt;code&gt;universal_newlines&lt;/code&gt; (alias &lt;code&gt;text&lt;/code&gt; in 3.7+), and &lt;code&gt;bufsize&lt;/code&gt; options.</source>
          <target state="translated">目前，三星始终使用无缓冲的字节流与过程进行通信，所以它不支持的 &lt;code&gt;encoding&lt;/code&gt; ， &lt;code&gt;errors&lt;/code&gt; ， &lt;code&gt;universal_newlines&lt;/code&gt; （别名 &lt;code&gt;text&lt;/code&gt; 在3.7+）和 &lt;code&gt;bufsize&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="a22eac18305a1e1dc5892e7f5be351ae472656bb" translate="yes" xml:space="preserve">
          <source>Custom supervisors</source>
          <target state="translated">定制监督员</target>
        </trans-unit>
        <trans-unit id="37671df58880918e942ce4bc136b98bb7f52aac2" translate="yes" xml:space="preserve">
          <source>Debugging and instrumentation</source>
          <target state="translated">调试和仪表化</target>
        </trans-unit>
        <trans-unit id="ac0a627ff292b052255162959a08edc910141a7f" translate="yes" xml:space="preserve">
          <source>Decorator that marks the given regular function, generator function, async function, or async generator function as protected against &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;, i.e., the code inside this function &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; be rudely interrupted by &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;. (Though if it contains any &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoints&lt;/a&gt;, then it can still receive &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at those. This is considered a polite interruption.)</source>
          <target state="translated">装饰器将给定的常规函数​​，生成器函数，异步函数或异步生成器函数标记为受&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt;保护，即，该函数内的代码&lt;em&gt;不会&lt;/em&gt;被&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt;粗暴地打断。（尽管它包含任何&lt;a href=&quot;reference-core#checkpoints&quot;&gt;检查点&lt;/a&gt;，但仍可以在这些检查点处接收&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt;。这被视为礼貌的中断。）</target>
        </trans-unit>
        <trans-unit id="f21a3283f7231f03c1af0a06d7cc4980ad8fdace" translate="yes" xml:space="preserve">
          <source>Decorator that marks the given regular function, generator function, async function, or async generator function as unprotected against &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;, i.e., the code inside this function &lt;em&gt;can&lt;/em&gt; be rudely interrupted by &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at any moment.</source>
          <target state="translated">装饰器将给定的常规函数​​，生成器函数，异步函数或异步生成器函数标记为不受&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; 的&lt;/a&gt;保护，即，该函数中的代码&lt;em&gt;随时都&lt;/em&gt;可以被&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt;粗暴地中断。</target>
        </trans-unit>
        <trans-unit id="2e2a5cb3fa4689c389726d66d794778a89c63a2e" translate="yes" xml:space="preserve">
          <source>Decrement the semaphore value, blocking if necessary to avoid letting it drop below zero.</source>
          <target state="translated">递减旗语值,必要时进行阻塞,避免让旗语值降到零以下。</target>
        </trans-unit>
        <trans-unit id="39db43b218a6486fec3ada3896d1474afb067886" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, though this can be overridden by the &lt;code&gt;shield=&lt;/code&gt; argument to the &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">默认值为&lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt;，尽管可以被&lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt;构造函数的 &lt;code&gt;shield=&lt;/code&gt; 参数覆盖。</target>
        </trans-unit>
        <trans-unit id="dcda29f4558d93a7bbbd6d484ebff9ce0dc4358d" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;math.inf&lt;/code&gt;&lt;/a&gt;, which means &amp;ldquo;no deadline&amp;rdquo;, though this can be overridden by the &lt;code&gt;deadline=&lt;/code&gt; argument to the &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">默认值为&lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;math.inf&lt;/code&gt; &lt;/a&gt;，表示&amp;ldquo;无截止日期&amp;rdquo;，尽管可以由&lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt;构造函数的duration &lt;code&gt;deadline=&lt;/code&gt; 参数覆盖。</target>
        </trans-unit>
        <trans-unit id="d1d70f0971455d22b791a3109b5b80c647c7c40a" translate="yes" xml:space="preserve">
          <source>Design and internals</source>
          <target state="translated">设计和内部结构</target>
        </trans-unit>
        <trans-unit id="7cca6a5cf867780c8e3f34ab51803e9dfcfd0b0c" translate="yes" xml:space="preserve">
          <source>Despite the name, this class currently inherits from &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#FutureWarning&quot;&gt;&lt;code&gt;FutureWarning&lt;/code&gt;&lt;/a&gt;, not &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#DeprecationWarning&quot;&gt;&lt;code&gt;DeprecationWarning&lt;/code&gt;&lt;/a&gt;, because while we&amp;rsquo;re in young-and-aggressive mode we want these warnings to be visible by default. You can hide them by installing a filter or with the &lt;code&gt;-W&lt;/code&gt; switch: see the &lt;a href=&quot;https://docs.python.org/3/library/warnings.html#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">尽管有名称，该类当前继承自&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#FutureWarning&quot;&gt; &lt;code&gt;FutureWarning&lt;/code&gt; &lt;/a&gt;，而不是&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#DeprecationWarning&quot;&gt; &lt;code&gt;DeprecationWarning&lt;/code&gt; &lt;/a&gt;，因为在我们处于积极进取的新模式时，我们希望这些警告在默认情况下可见。您可以通过安装过滤器或使用 &lt;code&gt;-W&lt;/code&gt; 开关隐藏它们：有关详细信息，请参阅&lt;a href=&quot;https://docs.python.org/3/library/warnings.html#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="d07097459810ff8d556f864eef0251cbd4763961" translate="yes" xml:space="preserve">
          <source>Different environments expose different low-level APIs for performing async I/O. &lt;a href=&quot;#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; exposes these APIs in a relatively direct way, so as to allow maximum power and flexibility for higher level code. However, this means that the exact API provided may vary depending on what system Trio is running on.</source>
          <target state="translated">不同的环境会公开用于执行异步I / O的不同的低级API。&lt;a href=&quot;#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt;以相对直接的方式公开这些API，以便为更高级别的代码提供最大的功能和灵活性。但是，这意味着所提供的确切API可能会根据运行Trio的系统而有所不同。</target>
        </trans-unit>
        <trans-unit id="d53b85148fd0778fe09804c73cc97015c67517b5" translate="yes" xml:space="preserve">
          <source>Discards any pending data from the internal buffer, and marks this stream as closed.</source>
          <target state="translated">丢弃内部缓冲区的任何待处理数据,并将此流标记为关闭。</target>
        </trans-unit>
        <trans-unit id="eb69b4f0d0a5c5bb423cba52d380509e75983c19" translate="yes" xml:space="preserve">
          <source>Discussion forum: &lt;a href=&quot;https://trio.discourse.group&quot;&gt;https://trio.discourse.group&lt;/a&gt;</source>
          <target state="translated">讨论论坛：&lt;a href=&quot;https://trio.discourse.group&quot;&gt;https&lt;/a&gt;：//trio.discourse.group</target>
        </trans-unit>
        <trans-unit id="cc6639be7bef8ebc4645daa5f535d0c081d565f7" translate="yes" xml:space="preserve">
          <source>Do any setup this clock might need.</source>
          <target state="translated">做任何设置这个时钟可能需要。</target>
        </trans-unit>
        <trans-unit id="3746016608ec0fb055b71a5ef557a7383f775460" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t confuse this with the &lt;a href=&quot;https://en.wikipedia.org/wiki/Leaky_bucket&quot;&gt;&amp;ldquo;leaky bucket&amp;rdquo;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Token_bucket&quot;&gt;&amp;ldquo;token bucket&amp;rdquo;&lt;/a&gt; algorithms used to limit bandwidth usage on networks. The basic idea of using tokens to track a resource limit is similar, but this is a very simple sack where tokens aren&amp;rsquo;t automatically created or destroyed over time; they&amp;rsquo;re just borrowed and then put back.</source>
          <target state="translated">请勿将其与用于限制网络带宽使用的&lt;a href=&quot;https://en.wikipedia.org/wiki/Leaky_bucket&quot;&gt;&amp;ldquo;泄漏存储桶&amp;rdquo;&lt;/a&gt;或&lt;a href=&quot;https://en.wikipedia.org/wiki/Token_bucket&quot;&gt;&amp;ldquo;令牌存储桶&amp;rdquo;&lt;/a&gt;算法混淆。使用令牌来跟踪资源限制的基本思想是相似的，但这是一个非常简单的麻袋，其中令牌不会随着时间的流逝而自动创建或销毁。他们只是借来然后放回去。</target>
        </trans-unit>
        <trans-unit id="49e4cf834c2c18317da25833af31c4c049a6fee9" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t worry &amp;ndash; Trio&amp;rsquo;s got your back. Since checkpoints are important and ubiquitous, we make it as simple as possible to keep track of them. Here are the rules:</source>
          <target state="translated">别担心-Trio帮了您大忙。由于检查点很重要且无处不在，因此使跟踪它们变得尽可能简单。规则如下：</target>
        </trans-unit>
        <trans-unit id="913f6fc58a1e961561938ad5dac8c30039297367" translate="yes" xml:space="preserve">
          <source>Due to limitations of the underlying operating system APIs, it is not always possible to properly cancel a connection attempt once it has begun. If &lt;a href=&quot;#trio.socket.SocketType.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; is cancelled, and is unable to abort the connection attempt, then it will:</source>
          <target state="translated">由于底层操作系统API的限制，一旦连接尝试开始，不一定总能正确取消它。如果&lt;a href=&quot;#trio.socket.SocketType.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt;被取消，并且无法中止连接尝试，则它将：</target>
        </trans-unit>
        <trans-unit id="f3a5eb11d87d8dcf932da28283e1ab1bca1ea3f4" translate="yes" xml:space="preserve">
          <source>Each call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has exactly one associated &lt;a href=&quot;#trio.hazmat.TrioToken&quot;&gt;&lt;code&gt;TrioToken&lt;/code&gt;&lt;/a&gt; object, so you can use it to identify a particular call.</source>
          <target state="translated">每次对&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; 的&lt;/a&gt;调用都只有一个关联的&lt;a href=&quot;#trio.hazmat.TrioToken&quot;&gt; &lt;code&gt;TrioToken&lt;/code&gt; &lt;/a&gt;对象，因此您可以使用它来标识特定的调用。</target>
        </trans-unit>
        <trans-unit id="65e85ee667572f1c414cc77a68130d34982ee8c4" translate="yes" xml:space="preserve">
          <source>Each standard stream is only available if you specify that a pipe should be created for it. For example, if you pass &lt;code&gt;stdin=subprocess.PIPE&lt;/code&gt;, you can write to the &lt;a href=&quot;#trio.Process.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; stream, else &lt;a href=&quot;#trio.Process.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">仅当您指定应为其创建管道时，每个标准流才可用。例如，如果传递 &lt;code&gt;stdin=subprocess.PIPE&lt;/code&gt; ，则可以写入&lt;a href=&quot;#trio.Process.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;流，否则&lt;a href=&quot;#trio.Process.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;将为 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1a68ba745dd4b45565cc59ceb8fbfb0631b79b4" translate="yes" xml:space="preserve">
          <source>Encrypt some data and then send it on the underlying transport.</source>
          <target state="translated">加密一些数据,然后在底层传输上发送。</target>
        </trans-unit>
        <trans-unit id="0b4c62f9905e08096736c80be6b7ec40116ed5ed" translate="yes" xml:space="preserve">
          <source>Encrypted communication using SSL/TLS.</source>
          <target state="translated">使用SSL/TLS加密通信。</target>
        </trans-unit>
        <trans-unit id="86de1bfa52c3e4766f699ef16765dbd03a3319f9" translate="yes" xml:space="preserve">
          <source>Enforcement Examples</source>
          <target state="translated">执法实例</target>
        </trans-unit>
        <trans-unit id="30ad3a9a2afb2111b7765c691e99a5da39f50d0f" translate="yes" xml:space="preserve">
          <source>Ensure that the initial handshake has completed.</source>
          <target state="translated">确保初始握手已经完成。</target>
        </trans-unit>
        <trans-unit id="f2da480b2f64c9d3565292a14c9f547cfaf97f33" translate="yes" xml:space="preserve">
          <source>Entering Trio</source>
          <target state="translated">进入三重奏</target>
        </trans-unit>
        <trans-unit id="9abc3cbe1eb3dbb9c76b4daff2806c46dd7c2398" translate="yes" xml:space="preserve">
          <source>Entering the context manager is synchronous (not a checkpoint); exiting it calls &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt;. The default implementations of &lt;code&gt;__aenter__&lt;/code&gt; and &lt;code&gt;__aexit__&lt;/code&gt; should be adequate for all subclasses.</source>
          <target state="translated">进入上下文管理器是同步的（不是检查点）；退出它会调用&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;__aenter__&lt;/code&gt; 和 &lt;code&gt;__aexit__&lt;/code&gt; 的默认实现应适合所有子类。</target>
        </trans-unit>
        <trans-unit id="bd77c7c89aaac60eda264bbe76c2fb3877f1bec7" translate="yes" xml:space="preserve">
          <source>Entering this context manager starts listening for the given signals and returns an async iterator; exiting the context manager stops listening.</source>
          <target state="translated">进入该上下文管理器开始监听给定的信号,并返回一个异步迭代器;退出上下文管理器则停止监听。</target>
        </trans-unit>
        <trans-unit id="577a6f5217758f5680c1ac4ab28d646c851b6515" translate="yes" xml:space="preserve">
          <source>Equivalent to (but potentially more efficient than):</source>
          <target state="translated">相当于(但可能比):</target>
        </trans-unit>
        <trans-unit id="ff71f1502a09a0efc6bf6b8df7b2130d8639c933" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;await trio.sleep(0)&lt;/code&gt; (which is implemented by calling &lt;a href=&quot;#trio.hazmat.checkpoint&quot;&gt;&lt;code&gt;checkpoint()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">等效于 &lt;code&gt;await trio.sleep(0)&lt;/code&gt; （通过调用&lt;a href=&quot;#trio.hazmat.checkpoint&quot;&gt; &lt;code&gt;checkpoint()&lt;/code&gt; &lt;/a&gt;实现）。</target>
        </trans-unit>
        <trans-unit id="f382ebfc0131e10b8880c5dcb889ae9616bf535a" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;await sleep(math.inf)&lt;/code&gt;.</source>
          <target state="translated">等效于调用 &lt;code&gt;await sleep(math.inf)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f06260807eabf1e2cdab615aead6b6fb18bc907c" translate="yes" xml:space="preserve">
          <source>Error handling:</source>
          <target state="translated">错误处理。</target>
        </trans-unit>
        <trans-unit id="5ee23a39f0b9c090f3744086941471cc71f4df96" translate="yes" xml:space="preserve">
          <source>Errors in multiple child tasks</source>
          <target state="translated">多个儿童任务中的错误</target>
        </trans-unit>
        <trans-unit id="e0ace80de082dc37e3d719147a18d3df854a1b73" translate="yes" xml:space="preserve">
          <source>Essentially, the body of the &lt;code&gt;async with&lt;/code&gt; block acts like an initial task that&amp;rsquo;s running inside the nursery, and then each call to &lt;code&gt;nursery.start_soon&lt;/code&gt; adds another task that runs in parallel. Two crucial things to keep in mind:</source>
          <target state="translated">本质上， &lt;code&gt;async with&lt;/code&gt; 块的主体就像在苗圃内部运行的初始任务一样，然后每次对 &lt;code&gt;nursery.start_soon&lt;/code&gt; 调用都会添加另一个并行运行的任务。需要牢记的两个关键事项：</target>
        </trans-unit>
        <trans-unit id="94511c8fe5d02860cbae8a93867794aff11407ac" translate="yes" xml:space="preserve">
          <source>Every call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; has an associated clock.</source>
          <target state="translated">每个对&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; 的&lt;/a&gt;调用都有一个关联的时钟。</target>
        </trans-unit>
        <trans-unit id="6da5df3c0217f2dd602bff18b094f6738fa41e40" translate="yes" xml:space="preserve">
          <source>Every successful execution path passes through a checkpoint (assuming that &lt;code&gt;wait_for_operation_to_be_ready&lt;/code&gt; is an unconditional checkpoint)</source>
          <target state="translated">每个成功的执行路径都会经过一个检查点（假设 &lt;code&gt;wait_for_operation_to_be_ready&lt;/code&gt; 是一个无条件检查点）</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="950f4fc18cdc90c9c93a02882a39bdff0c115ba2" translate="yes" xml:space="preserve">
          <source>Example implementations</source>
          <target state="translated">实施例</target>
        </trans-unit>
        <trans-unit id="65cee81e771dd281fa49a0152c7e600fa8e0a7ec" translate="yes" xml:space="preserve">
          <source>Example output (yours may differ slightly):</source>
          <target state="translated">输出示例(您的输出可能略有不同)。</target>
        </trans-unit>
        <trans-unit id="9684bdcdfe4872be868a6df199c0d4c63ad6a6b9" translate="yes" xml:space="preserve">
          <source>Example use case: drawing a visualization of the task tree in a debugger.</source>
          <target state="translated">用例:在调试器中绘制任务树的可视化。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="ccf1573108e16e6d38ba26ddc8eacf022ebd30f9" translate="yes" xml:space="preserve">
          <source>Exceptions and warnings</source>
          <target state="translated">例外情况和警告</target>
        </trans-unit>
        <trans-unit id="a5ef272f6a2530c8104c0aa1dff5bd1ca42d05ac" translate="yes" xml:space="preserve">
          <source>Execute a child program in a new process.</source>
          <target state="translated">在新进程中执行子程序。</target>
        </trans-unit>
        <trans-unit id="9a507f0e5168c6ed30b03a96ee64617f5b05c7fe" translate="yes" xml:space="preserve">
          <source>Fairness</source>
          <target state="translated">Fairness</target>
        </trans-unit>
        <trans-unit id="36ebc08b0a99d629a11b0e8b00f5c5994c6741e9" translate="yes" xml:space="preserve">
          <source>First we do all our interaction with the state machine in a single scheduling quantum (notice there are no &lt;code&gt;await&lt;/code&gt;s in there), so it&amp;rsquo;s automatically atomic with respect to other tasks. And then if and only if we have data to send, we get in line to send it &amp;ndash; and &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt;&lt;code&gt;StrictFIFOLock&lt;/code&gt;&lt;/a&gt; guarantees that each task will send its data in the same order that the state machine generated it.</source>
          <target state="translated">首先，我们在单个调度范围内完成与状态机的所有交互（注意那里没有 &lt;code&gt;await&lt;/code&gt; ），因此对于其他任务，它是自动原子的。然后，当且仅当我们有要发送的数据时，我们才排队发送数据&lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt; &lt;code&gt;StrictFIFOLock&lt;/code&gt; &lt;/a&gt;保证每个任务将按照状态机生成数据的顺序发送数据。</target>
        </trans-unit>
        <trans-unit id="39aad0e951ec2a465a7527afcee9229d642c5338" translate="yes" xml:space="preserve">
          <source>First, Trio provides analogues to all the standard library functions that return socket objects; their interface is identical, except that they&amp;rsquo;re modified to return Trio socket objects instead:</source>
          <target state="translated">首先，Trio为返回套接字对象的所有标准库函数提供了类似物。它们的接口是相同的，只不过它们被修改为返回Trio套接字对象：</target>
        </trans-unit>
        <trans-unit id="87b15f31f9acbf1b346b9723758dae62bdd83b37" translate="yes" xml:space="preserve">
          <source>First, and most obviously, everything is made &amp;ldquo;Trio-style&amp;rdquo;: blocking methods become async methods, and the following attributes are &lt;em&gt;not&lt;/em&gt; supported:</source>
          <target state="translated">首先，也是最明显的是，一切都变成了&amp;ldquo; Trio风格&amp;rdquo;：阻塞方法变成异步方法，并且&lt;em&gt;不&lt;/em&gt;支持以下属性：</target>
        </trans-unit>
        <trans-unit id="3d0602bcf5eefcc21823064ff06ea71c922833a9" translate="yes" xml:space="preserve">
          <source>First, right now no mainstream operating system offers a generic, reliable, native API for async file or filesystem operations, so we have to fake it by using threads (specifically, &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt;). This is cheap but isn&amp;rsquo;t free: on a typical PC, dispatching to a worker thread adds something like ~100 &amp;micro;s of overhead to each operation. (&amp;ldquo;&amp;micro;s&amp;rdquo; is pronounced &amp;ldquo;microseconds&amp;rdquo;, and there are 1,000,000 &amp;micro;s in a second. Note that all the numbers here are going to be rough orders of magnitude to give you a sense of scale; if you need precise numbers for your environment, measure!)</source>
          <target state="translated">首先，目前还没有主流操作系统为异步文件或文件系统操作提供通用，可靠的本机API，因此我们必须使用线程（特别是&lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt;）来伪造它。这很便宜，但不是免费的：在典型的PC上，分派给工作线程会为每个操作增加大约100 &amp;micro;s的开销。 （&amp;ldquo; &amp;micro;s&amp;rdquo;的发音为&amp;ldquo;微秒&amp;rdquo;，在一秒内为1,000,000 &amp;micro;s。请注意，此处的所有数字都将是一个大致的数量级，以便为您带来规模感；如果您需要针对环境的精确数字，测量！）</target>
        </trans-unit>
        <trans-unit id="a05d658dc1c542b05e5284639df77ae27e0c00f0" translate="yes" xml:space="preserve">
          <source>For a clock using wall-time, this should be something like:</source>
          <target state="translated">对于使用墙面时间的时钟,应该是这样的。</target>
        </trans-unit>
        <trans-unit id="48709ea5cba4eb96bb491cf99f5fd3676afdc21d" translate="yes" xml:space="preserve">
          <source>For example, closing a TLS-wrapped socket normally involves sending a notification to the remote peer, so that they can be cryptographically assured that you really meant to close the socket, and your connection wasn&amp;rsquo;t just broken by a man-in-the-middle attacker. But handling this robustly is a bit tricky. Remember our &lt;a href=&quot;#blocking-cleanup-example&quot;&gt;example&lt;/a&gt; above where the blocking &lt;code&gt;send_goodbye_msg&lt;/code&gt; caused problems? That&amp;rsquo;s exactly how closing a TLS socket works: if the remote peer has disappeared, then our code may never be able to actually send our shutdown notification, and it would be nice if it didn&amp;rsquo;t block forever trying. Therefore, the method for closing a TLS-wrapped socket will &lt;em&gt;try&lt;/em&gt; to send that notification &amp;ndash; and if it gets cancelled, then it will give up on sending the message, but &lt;em&gt;will&lt;/em&gt; still close the underlying socket before raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;, so at least you don&amp;rsquo;t leak that resource.</source>
          <target state="translated">例如，关闭TLS封装的套接字通常涉及向远程对等方发送通知，以便可以通过加密方式确保您确实打算关闭该套接字，并且连接不仅仅被人为破坏。 -中间攻击者。但是，稳健地处理此问题有些棘手。还记得上面的&lt;a href=&quot;#blocking-cleanup-example&quot;&gt;示例&lt;/a&gt;，其中阻塞 &lt;code&gt;send_goodbye_msg&lt;/code&gt; 导致了问题吗？这正是关闭TLS套接字的工作方式：如果远程对等点消失了，那么我们的代码可能永远无法真正发送我们的关闭通知，并且如果它不会永远阻止尝试，那就太好了。因此，关闭TLS包装的套接字的方法将&lt;em&gt;尝试&lt;/em&gt;发送该通知-如果它被取消，那么它将放弃发送消息，但&lt;em&gt;将&lt;/em&gt;仍接近底层套接字之前募集&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;，这样至少你不泄露该资源。</target>
        </trans-unit>
        <trans-unit id="a6f008f9eefbcebe7ebf5b1aab36adf73fbe45fd" translate="yes" xml:space="preserve">
          <source>For example, consider this naive extension of our previous example, now with two producers and two consumers:</source>
          <target state="translated">例如,考虑一下我们前一个例子的天真扩展,现在有两个生产者和两个消费者。</target>
        </trans-unit>
        <trans-unit id="3c9f550fd71ac17462b4162b1e8a8748f24bd870" translate="yes" xml:space="preserve">
          <source>For example, here&amp;rsquo;s a function that takes a list of functions, runs them all concurrently, and returns the result from the one that finishes first:</source>
          <target state="translated">例如，这是一个函数，它接收一系列函数，并发运行它们，并从最先完成的函数返回结果：</target>
        </trans-unit>
        <trans-unit id="3e1b83209368f33cb57342986c90a06fb5c4a5ce" translate="yes" xml:space="preserve">
          <source>For example, if two tasks try to send data through the same socket at the same time, Trio will raise &lt;a href=&quot;#trio.BusyResourceError&quot;&gt;&lt;code&gt;BusyResourceError&lt;/code&gt;&lt;/a&gt; instead of letting the data get scrambled.</source>
          <target state="translated">例如，如果两个任务试图同时通过同一套接字发送数据，则Trio将引发&lt;a href=&quot;#trio.BusyResourceError&quot;&gt; &lt;code&gt;BusyResourceError&lt;/code&gt; &lt;/a&gt;而不是使数据混乱。</target>
        </trans-unit>
        <trans-unit id="a9203322c4e642fda52a346d7a4dd7f31f89ac48" translate="yes" xml:space="preserve">
          <source>For example, suppose we call &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; on a TLS-encrypted connection. This requires sending a &amp;ldquo;goodbye&amp;rdquo; message; but if the peer has become non-responsive, then our attempt to send this message might block forever, and eventually time out and be cancelled. In this case the &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; will immediately close the underlying transport stream using &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt;&lt;code&gt;trio.aclose_forcefully()&lt;/code&gt;&lt;/a&gt; before raising &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">例如，假设我们在TLS加密的连接上调用&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt;。这需要发送&amp;ldquo;再见&amp;rdquo;消息；但是，如果对等方变得无响应，则我们发送此消息的尝试可能会永远受阻，最终超时并被取消。在这种情况下，&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt;上方法&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;将立即靠近底层传输流使用&lt;a href=&quot;#trio.aclose_forcefully&quot;&gt; &lt;code&gt;trio.aclose_forcefully()&lt;/code&gt; &lt;/a&gt;提高前&lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b30a4a3439bea3af8a737486ca4c36858c90d06" translate="yes" xml:space="preserve">
          <source>For example, you might get this if you try to send data on a stream where the remote side has already closed the connection.</source>
          <target state="translated">例如,如果你试图在一个远程端已经关闭连接的流上发送数据,你可能会得到这样的结果。</target>
        </trans-unit>
        <trans-unit id="f909978159a531021ff533705ba1c50305ee5043" translate="yes" xml:space="preserve">
          <source>For more information, read the &lt;a href=&quot;https://docs.python.org/3.7/library/contextvars.html&quot;&gt;contextvar docs&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请阅读&lt;a href=&quot;https://docs.python.org/3.7/library/contextvars.html&quot;&gt;contextvar docs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3cbd4cf4a20b121cf25b4d8a86f46de892ed87cc" translate="yes" xml:space="preserve">
          <source>For name lookup, Trio provides the standard functions, but with some changes:</source>
          <target state="translated">对于名称查询,Trio提供了标准的功能,但有一些变化。</target>
        </trans-unit>
        <trans-unit id="cd4c0d3d9c603b00054846d54595ca9a7a4e9da3" translate="yes" xml:space="preserve">
          <source>For operations that have a non-blocking variant, the blocking and non-blocking variants are different methods with names like &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;X_nowait&lt;/code&gt;, respectively. (This is similar to &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Queue&quot;&gt;&lt;code&gt;queue.Queue&lt;/code&gt;&lt;/a&gt;, but unlike most of the classes in &lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt;.) We like this approach because it allows us to make the blocking version async and the non-blocking version sync.</source>
          <target state="translated">对于具有非阻塞变体的操作，阻塞和非阻塞变体是不同的方法，其名称分别类似于 &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;X_nowait&lt;/code&gt; 。 （这与&lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Queue&quot;&gt; &lt;code&gt;queue.Queue&lt;/code&gt; &lt;/a&gt;类似，但是与&lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt;大多数类不同。）我们喜欢这种方法，因为它允许我们使阻塞版本异步和非阻塞版本同步。</target>
        </trans-unit>
        <trans-unit id="af7c11a85341c774f7f483b666e5435a2c7dc4ac" translate="yes" xml:space="preserve">
          <source>For reading and writing to files and file-like objects, Trio also provides a mechanism for wrapping any synchronous file-like object into an asynchronous interface. If you have a &lt;a href=&quot;#trio.Path&quot;&gt;&lt;code&gt;trio.Path&lt;/code&gt;&lt;/a&gt; object you can get one of these by calling its &lt;a href=&quot;#trio.Path.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; method; or if you know the file&amp;rsquo;s name you can open it directly with &lt;a href=&quot;#trio.open_file&quot;&gt;&lt;code&gt;trio.open_file()&lt;/code&gt;&lt;/a&gt;. Alternatively, if you already have an open file-like object, you can wrap it with &lt;a href=&quot;#trio.wrap_file&quot;&gt;&lt;code&gt;trio.wrap_file()&lt;/code&gt;&lt;/a&gt; &amp;ndash; one case where this is especially useful is to wrap &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; when writing tests.</source>
          <target state="translated">为了读取和写入文件和类似文件的对象，Trio还提供了一种机制，用于将任何类似同步文件的对象包装到异步接口中。如果您有一个&lt;a href=&quot;#trio.Path&quot;&gt; &lt;code&gt;trio.Path&lt;/code&gt; &lt;/a&gt;对象，则可以通过调用其&lt;a href=&quot;#trio.Path.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt;方法来获得其中的一个。或者，如果您知道文件的名称，则可以直接使用&lt;a href=&quot;#trio.open_file&quot;&gt; &lt;code&gt;trio.open_file()&lt;/code&gt; &lt;/a&gt;打开它。另外，如果您已经有一个打开的类似文件的对象，则可以使用&lt;a href=&quot;#trio.wrap_file&quot;&gt; &lt;code&gt;trio.wrap_file()&lt;/code&gt; &lt;/a&gt;包装它-一种特别有用的情况是在编写测试时包装&lt;a href=&quot;https://docs.python.org/3/library/io.html#io.BytesIO&quot;&gt; &lt;code&gt;io.BytesIO&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3/library/io.html#io.StringIO&quot;&gt; &lt;code&gt;io.StringIO&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82ef028042140eef57f0f36ca8b9b254552de55e" translate="yes" xml:space="preserve">
          <source>Fortunately this isn&amp;rsquo;t as bad as it sounds, because the HTTP protocol already includes its own equivalent of &lt;code&gt;close_notify&lt;/code&gt;, so doing this again at the SSL/TLS level is redundant. But not all protocols do! Therefore, by default Trio implements the safer standard-compliant version (&lt;code&gt;https_compatible=False&lt;/code&gt;). But if you&amp;rsquo;re speaking HTTPS or some other protocol where &lt;code&gt;close_notify&lt;/code&gt;s are commonly skipped, then you should set &lt;code&gt;https_compatible=True&lt;/code&gt;; with this setting, Trio will neither expect nor send &lt;code&gt;close_notify&lt;/code&gt; messages.</source>
          <target state="translated">幸运的是，这并没有听起来那么糟糕，因为HTTP协议已经包含了自己的 &lt;code&gt;close_notify&lt;/code&gt; 等效项，因此在SSL / TLS级别再次进行此操作是多余的。但是，并非所有协议都可以！因此，默认情况下，Trio实现更安全的标准兼容版本（ &lt;code&gt;https_compatible=False&lt;/code&gt; ）。但是，如果您使用的是HTTPS或通常跳过 &lt;code&gt;close_notify&lt;/code&gt; 的其他协议，则应设置 &lt;code&gt;https_compatible=True&lt;/code&gt; ；使用此设置，Trio既不会期望也不会发送 &lt;code&gt;close_notify&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="d15dc5d1075d65dae25982087c3ad3acc292130c" translate="yes" xml:space="preserve">
          <source>From inside the worker thread, you can get back into Trio using the functions in &lt;a href=&quot;#module-trio.from_thread&quot;&gt;&lt;code&gt;trio.from_thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从辅助线程内部，您可以使用&lt;a href=&quot;#module-trio.from_thread&quot;&gt; &lt;code&gt;trio.from_thread&lt;/code&gt; 中&lt;/a&gt;的函数返回Trio 。</target>
        </trans-unit>
        <trans-unit id="096bafb1ad02c5e340fc0cffb7efac1d03c6fdd6" translate="yes" xml:space="preserve">
          <source>Further reading:</source>
          <target state="translated">进一步阅读:</target>
        </trans-unit>
        <trans-unit id="14b4abcfb38d8e2bedf23453f682373a91ca1df3" translate="yes" xml:space="preserve">
          <source>General principles</source>
          <target state="translated">一般原则</target>
        </trans-unit>
        <trans-unit id="1d33591f44b73461a418fdd7300d5ea81ebd01a0" translate="yes" xml:space="preserve">
          <source>Generally the way it works is that before calling this function, you make arrangements for &amp;ldquo;someone&amp;rdquo; to call &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; on the current task at some later point.</source>
          <target state="translated">通常，它的工作方式是在调用此函数之前，先安排&amp;ldquo;某人&amp;rdquo; 在稍后的某个时刻对当前任务调用&lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e36516ef81e825f5f1a9afc1d80d86f1816a2bbe" translate="yes" xml:space="preserve">
          <source>Generally you should call this function just once, right at the beginning of your program.</source>
          <target state="translated">一般来说,你应该只调用这个函数一次,就在你的程序的开头。</target>
        </trans-unit>
        <trans-unit id="6dbd080c65cdd758570339c25de579b2dd1b8134" translate="yes" xml:space="preserve">
          <source>Generally, the API exposed by &lt;a href=&quot;#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt; mirrors that of the standard library &lt;a href=&quot;https://docs.python.org/3/library/socket.html#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; module. Most constants (like &lt;code&gt;SOL_SOCKET&lt;/code&gt;) and simple utilities (like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.inet_aton&quot;&gt;&lt;code&gt;inet_aton()&lt;/code&gt;&lt;/a&gt;) are simply re-exported unchanged. But there are also some differences, which are described here.</source>
          <target state="translated">通常，&lt;a href=&quot;#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; &lt;/a&gt;公开的API 反映了标准库&lt;a href=&quot;https://docs.python.org/3/library/socket.html#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt;模块的API 。大多数常量（如 &lt;code&gt;SOL_SOCKET&lt;/code&gt; ）和简单的实用程序（如&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.inet_aton&quot;&gt; &lt;code&gt;inet_aton()&lt;/code&gt; &lt;/a&gt;）都可以直接不变地重新导出。但是也存在一些差异，在此进行描述。</target>
        </trans-unit>
        <trans-unit id="df6e0ad77a1d03e22e4e78c091cdce9b18814852" translate="yes" xml:space="preserve">
          <source>Generic stream tools</source>
          <target state="translated">通用流工具</target>
        </trans-unit>
        <trans-unit id="c61ec329c35890384eca7f8141d511f90a23bba7" translate="yes" xml:space="preserve">
          <source>Get the default &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; used by &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">获取&lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync&lt;/code&gt; &lt;/a&gt;使用的默认&lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="424f1939c9512c36dd942c09a91b79a3e7cd2f59" translate="yes" xml:space="preserve">
          <source>Getting back into the Trio thread from another thread</source>
          <target state="translated">从另一条线上回到Trio线上</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">开始</target>
        </trans-unit>
        <trans-unit id="f1f01defeb8ad40ed473adada63fd85ed9fd2cce" translate="yes" xml:space="preserve">
          <source>Global state: system tasks and run-local variables</source>
          <target state="translated">全局状态:系统任务和运行的局部变量</target>
        </trans-unit>
        <trans-unit id="3d2cbcea420fd9b8c76106a48d0b289d21c579de" translate="yes" xml:space="preserve">
          <source>Global statistics</source>
          <target state="translated">全球统计</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="823619e079c311b099f1d0e427a584eafcd6ed06" translate="yes" xml:space="preserve">
          <source>Governance</source>
          <target state="translated">Governance</target>
        </trans-unit>
        <trans-unit id="d134414d4290b4888745f30ed9ef9d0af9f97f62" translate="yes" xml:space="preserve">
          <source>Gracefully shut down this connection, and close the underlying transport.</source>
          <target state="translated">优雅地关闭这个连接,并关闭底层传输。</target>
        </trans-unit>
        <trans-unit id="51de6467e4ce05659d97203c6f4fe5fb2686e910" translate="yes" xml:space="preserve">
          <source>Handing off live coroutine objects between coroutine runners</source>
          <target state="translated">在coroutine runners之间交接活的coroutine对象。</target>
        </trans-unit>
        <trans-unit id="f88d04389b281b3967803afb4eaa851b991783bb" translate="yes" xml:space="preserve">
          <source>Handling cancellation</source>
          <target state="translated">处理取消</target>
        </trans-unit>
        <trans-unit id="cbf0820fc59d334aedf8e7fb6d8f0d097b139af9" translate="yes" xml:space="preserve">
          <source>Here if one or more of the racing functions raises an unhandled exception then Trio&amp;rsquo;s normal handling kicks in: it cancels the others and then propagates the exception. If you want different behavior, you can get that by adding a &lt;code&gt;try&lt;/code&gt; block to the &lt;code&gt;jockey&lt;/code&gt; function to catch exceptions and handle them however you like.</source>
          <target state="translated">在这里，如果一个或多个赛车功能引发未处理的异常，则Trio的常规处理开始：它取消其他功能，然后传播该异常。如果您想要不同的行为，则可以通过在 &lt;code&gt;jockey&lt;/code&gt; 函数中添加一个 &lt;code&gt;try&lt;/code&gt; 块来捕获异常并按自己喜欢的方式处理它们，从而实现这一点。</target>
        </trans-unit>
        <trans-unit id="a81e9adeb9b0a32b3517c84f273b1dbbc540cd6e" translate="yes" xml:space="preserve">
          <source>Here the function acts as a checkpoint if you call it with &lt;code&gt;should_sleep&lt;/code&gt; set to a true value, but not otherwise. This is why we emphasize that Trio&amp;rsquo;s own async functions are &lt;em&gt;unconditional&lt;/em&gt; checkpoints: they &lt;em&gt;always&lt;/em&gt; check for cancellation and check for scheduling, regardless of what arguments they&amp;rsquo;re passed. If you find an async function in Trio that doesn&amp;rsquo;t follow this rule, then it&amp;rsquo;s a bug and you should &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;let us know&lt;/a&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;should_sleep&lt;/code&gt; 设置为true值的情况下调用该函数，则该函数将充当检查点，但在其他情况下则不会。这就是为什么我们强调Trio自己的异步函数是&lt;em&gt;无条件的&lt;/em&gt;检查点：它们&lt;em&gt;始终&lt;/em&gt;检查取消和检查调度，而不管它们传递了什么参数。如果您在Trio中发现一个不遵循此规则的异步函数，则说明它是一个错误，您应该&lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;通知我们&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e1243ad2370c1dcec5bc84d902878d0e26a4267" translate="yes" xml:space="preserve">
          <source>Here we pass clones into the tasks, but never close the original objects. That means we have 3 send channel objects (the original + two clones), but we only close 2 of them, so the consumers will hang around forever waiting for that last one to be closed.</source>
          <target state="translated">在这里,我们将克隆对象传递到任务中,但从不关闭原始对象。这意味着我们有3个发送通道对象(原始对象+两个克隆对象),但我们只关闭了其中的2个,所以消费者将永远挂在那里等待最后一个对象被关闭。</target>
        </trans-unit>
        <trans-unit id="5b795a1957f433bb2a1910c85c849c3c303650bd" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a new version that fixes this: it produces the same output as the previous version, and then exits cleanly. The only change is the addition of &lt;code&gt;async with&lt;/code&gt; blocks inside the producer and consumer:</source>
          <target state="translated">这是一个修复此问题的新版本：它产生与先前版本相同的输出，然后干净地退出。唯一的变化是在生产者和使用者中添加了 &lt;code&gt;async with&lt;/code&gt; 块：</target>
        </trans-unit>
        <trans-unit id="d543e0e7e6827ddd190eadb52f0c6857ef3a5feb" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a rule of thumb for designing good Trio-style (&amp;ldquo;trionic&amp;rdquo;?) APIs: if you&amp;rsquo;re writing a reusable function, then you shouldn&amp;rsquo;t take a &lt;code&gt;timeout=&lt;/code&gt; parameter, and instead let your caller worry about it. This has several advantages. First, it leaves the caller&amp;rsquo;s options open for deciding how they prefer to handle timeouts &amp;ndash; for example, they might find it easier to work with absolute deadlines instead of relative timeouts. If they&amp;rsquo;re the ones calling into the cancellation machinery, then they get to pick, and you don&amp;rsquo;t have to worry about it. Second, and more importantly, this makes it easier for others to re-use your code. If you write a &lt;code&gt;http_get&lt;/code&gt; function, and then I come along later and write a &lt;code&gt;log_in_to_twitter&lt;/code&gt; function that needs to internally make several &lt;code&gt;http_get&lt;/code&gt; calls, I don&amp;rsquo;t want to have to figure out how to configure the individual timeouts on each of those calls &amp;ndash; and with Trio&amp;rsquo;s timeout system, it&amp;rsquo;s totally unnecessary.</source>
          <target state="translated">这是设计良好的Trio样式（&amp;ldquo; trionic&amp;rdquo;？）API的经验法则：如果要编写可重用的函数，则不应该使用 &lt;code&gt;timeout=&lt;/code&gt; 参数，而应让调用者担心它。这有几个优点。首先，它使呼叫者的选项处于打开状态，以便确定他们更喜欢如何处理超时&amp;ndash;例如，他们可能会发现使用绝对期限而不是相对超时更容易。如果他们是要求取消机制的人，那么他们就可以选择，而您不必担心。其次，更重要的是，这使其他人更容易重用您的代码。如果您编写了一个 &lt;code&gt;http_get&lt;/code&gt; 函数，然后稍后再介绍一个 &lt;code&gt;log_in_to_twitter&lt;/code&gt; 函数，则需要在内部进行多个 &lt;code&gt;http_get&lt;/code&gt; 调用，我不需要弄清楚如何在每个调用中配置单独的超时-使用Trio的超时系统，完全没有必要。</target>
        </trans-unit>
        <trans-unit id="601515a8d1630148f164b880c80a648ba993177c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple example of how to use memory channels:</source>
          <target state="translated">这是一个如何使用内存通道的简单示例：</target>
        </trans-unit>
        <trans-unit id="8f8dd0477dbd6951adf860111366384234489b4a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a toy example demonstrating how to use &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">这是一个玩具示例，演示如何使用&lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="0f597430db412dbd7530fb06efa92bf6cd1e97b4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example lock class implemented using &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; directly. This implementation has a number of flaws, including lack of fairness, O(n) cancellation, missing error checking, failure to insert a checkpoint on the non-blocking path, etc. If you really want to implement your own lock, then you should study the implementation of &lt;a href=&quot;reference-core#trio.Lock&quot;&gt;&lt;code&gt;trio.Lock&lt;/code&gt;&lt;/a&gt; and use &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt;, which handles some of these issues for you. But this does serve to illustrate the basic structure of the &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; API:</source>
          <target state="translated">这是直接使用&lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt;实现的示例锁类。此实现具有许多缺陷，包括缺乏公平性，O（n）取消，缺少错误检查，无法在非阻塞路径上插入检查点等。如果您确实要实现自己的锁，则应该研究&lt;a href=&quot;reference-core#trio.Lock&quot;&gt; &lt;code&gt;trio.Lock&lt;/code&gt; &lt;/a&gt;的实现并使用&lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt;，它可以为您解决其中的一些问题。但这确实说明了&lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; API 的基本结构：</target>
        </trans-unit>
        <trans-unit id="c83ac7bfeff92f8dfada15c124f96bd3c69d8174" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of one way to test that Trio&amp;rsquo;s locks are fair: we take the lock in the parent, start a child, wait for the child to be blocked waiting for the lock (!), and then check that we can&amp;rsquo;t release and immediately re-acquire the lock:</source>
          <target state="translated">这是测试Trio锁是否公平的一种方法的示例：我们将锁放在父级中，启动一个子级，等待子级被阻塞以等待该锁（！），然后检查是否无法释放并立即重新获取锁：</target>
        </trans-unit>
        <trans-unit id="79a379c34c53ce83d07e71356345ea69136a74d1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example:</source>
          <target state="translated">这是一个例子：</target>
        </trans-unit>
        <trans-unit id="2c595ce4e33c82227dd77fbbfecca01edd89f970" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the idea: whenever you call a cancellable function like &lt;code&gt;await
trio.sleep(...)&lt;/code&gt; or &lt;code&gt;await sock.recv(...)&lt;/code&gt; &amp;ndash; see &lt;a href=&quot;#checkpoints&quot;&gt;Checkpoints&lt;/a&gt; &amp;ndash; then the first thing that function does is to check if there&amp;rsquo;s a surrounding cancel scope whose timeout has expired, or otherwise been cancelled. If so, then instead of performing the requested operation, the function fails immediately with a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception. In this example, this probably happens somewhere deep inside the bowels of &lt;code&gt;do_http_get&lt;/code&gt;. The exception then propagates out like any normal exception (you could even catch it if you wanted, but that&amp;rsquo;s generally a bad idea), until it reaches the &lt;code&gt;with move_on_after(...):&lt;/code&gt;. And at this point, the &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception has done its job &amp;ndash; it&amp;rsquo;s successfully unwound the whole cancelled scope &amp;ndash; so &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt; catches it, and execution continues as normal after the &lt;code&gt;with&lt;/code&gt; block. And this all works correctly even if you have nested cancel scopes, because every &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; object carries an invisible marker that makes sure that the cancel scope that triggered it is the only one that will catch it.</source>
          <target state="translated">这是一个主意：每当调用诸如 &lt;code&gt;await trio.sleep(...)&lt;/code&gt; 或 &lt;code&gt;await sock.recv(...)&lt;/code&gt; 等可取消函数&amp;ndash;请参阅&lt;a href=&quot;#checkpoints&quot;&gt;Checkpoints&lt;/a&gt; &amp;ndash;那么该函数要做的第一件事就是检查是否存在周围的取消范围的超时时间已到期，或已被取消。如果是这样，则该函数将立即失败，并显示&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;异常，而不是执行请求的操作。在此示例中，这可能发生在 &lt;code&gt;do_http_get&lt;/code&gt; 肠内深处。然后，该异常会像任何普通异常一样传播出去（您甚至可以根据需要捕获它，但这通常是个坏主意），直到 &lt;code&gt;with move_on_after(...):&lt;/code&gt; 到达该异常为止。在这一点上，&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;异常已经完成了它的工作-它成功地取消了整个取消的作用域-因此&lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt;捕获了它，并且在 &lt;code&gt;with&lt;/code&gt; 块之后照常继续执行。即使您嵌套了取消作用域，这一切也都可以正常工作，因为每个被&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;对象都带有一个不可见的标记，可确保触发它的取消作用域是唯一捕获它的对象。</target>
        </trans-unit>
        <trans-unit id="2aeb6b45dd0d2ee97bc472ed237a9f484260072d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the rule: if it&amp;rsquo;s in the &lt;code&gt;trio&lt;/code&gt; namespace, and you use &lt;code&gt;await&lt;/code&gt; to call it, then it&amp;rsquo;s cancellable (see &lt;a href=&quot;#checkpoints&quot;&gt;Checkpoints&lt;/a&gt; above). Cancellable means:</source>
          <target state="translated">这是规则：如果它在 &lt;code&gt;trio&lt;/code&gt; 名称空间中，并且您使用 &lt;code&gt;await&lt;/code&gt; 来调用它，那么它是可取消的（请参见上面的&lt;a href=&quot;#checkpoints&quot;&gt;Checkpoints&lt;/a&gt;）。可取消的方式是：</target>
        </trans-unit>
        <trans-unit id="777ee510025095ed8e8d6f657cb98b0a5e34e261" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what&amp;rsquo;s happening: suppose that producer A finishes first. It exits, and its &lt;code&gt;async with&lt;/code&gt; block closes the &lt;code&gt;send_channel&lt;/code&gt;. But wait! Producer B was still using that &lt;code&gt;send_channel&lt;/code&gt;&amp;hellip; so the next time B calls &lt;code&gt;send&lt;/code&gt;, it gets a &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这是发生了什么：假设生产者A首先完成。它退出，并且 &lt;code&gt;async with&lt;/code&gt; block的异步关闭 &lt;code&gt;send_channel&lt;/code&gt; 。但是等等！生产者B仍在使用该 &lt;code&gt;send_channel&lt;/code&gt; &amp;hellip;因此，下一次B调用 &lt;code&gt;send&lt;/code&gt; 时，它将收到&lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21160ad4219648df73489cb933286e7bc3e46257" translate="yes" xml:space="preserve">
          <source>High-level design principles</source>
          <target state="translated">高级别的设计原则</target>
        </trans-unit>
        <trans-unit id="69ab5602e01ae3ddb7b5d822e4e060677004c139" translate="yes" xml:space="preserve">
          <source>How does this work? There&amp;rsquo;s no magic here: Trio is built using ordinary Python functionality, so we can&amp;rsquo;t just abandon the code inside the &lt;code&gt;with&lt;/code&gt; block. Instead, we take advantage of Python&amp;rsquo;s standard way of aborting a large and complex piece of code: we raise an exception.</source>
          <target state="translated">如何运作？这里没有魔术：Trio使用普通的Python功能构建，因此我们不能仅仅放弃 &lt;code&gt;with&lt;/code&gt; 块中的代码。取而代之的是，我们利用Python中止大型和复杂代码段的标准方法：我们引发了一个异常。</target>
        </trans-unit>
        <trans-unit id="5e1b1c64688e250f0fe5f3bee97484ef0ed62473" translate="yes" xml:space="preserve">
          <source>How many seconds of clock time pass per second of real time. Default is 0.0, i.e. the clock only advances through manuals calls to &lt;a href=&quot;#trio.testing.MockClock.jump&quot;&gt;&lt;code&gt;jump()&lt;/code&gt;&lt;/a&gt; or when the &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; is triggered. You can assign to this attribute to change it.</source>
          <target state="translated">每秒每秒经过多少秒的时钟时间。默认值为0.0，即时钟仅通过手动调用&lt;a href=&quot;#trio.testing.MockClock.jump&quot;&gt; &lt;code&gt;jump()&lt;/code&gt; &lt;/a&gt;或触发&lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt;时才前进。您可以分配给该属性以对其进行更改。</target>
        </trans-unit>
        <trans-unit id="33d8a0f4d3b4758420f6c0a759a3cf2ef4fe9541" translate="yes" xml:space="preserve">
          <source>However, closing one of the objects does not close the other, and receivers don&amp;rsquo;t get &lt;a href=&quot;#trio.EndOfChannel&quot;&gt;&lt;code&gt;EndOfChannel&lt;/code&gt;&lt;/a&gt; until &lt;em&gt;all&lt;/em&gt; clones have been closed.</source>
          <target state="translated">但是，关闭一个对象不会关闭另一个对象，并且在关闭&lt;em&gt;所有&lt;/em&gt;克隆之前，接收者不会获得&lt;a href=&quot;#trio.EndOfChannel&quot;&gt; &lt;code&gt;EndOfChannel&lt;/code&gt; &lt;/a&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f56ebfbbd55d6021396bb3e5231e9f349c9e50c" translate="yes" xml:space="preserve">
          <source>However, closing one of the objects does not close the other, and the underlying channel is not closed until all clones are closed. (If you&amp;rsquo;re familiar with &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt;&lt;code&gt;os.dup&lt;/code&gt;&lt;/a&gt;, then this is a similar idea.)</source>
          <target state="translated">但是，关闭一个对象不会关闭另一个对象，并且在关闭所有克隆之前，不会关闭基础通道。（如果您熟悉&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt; &lt;code&gt;os.dup&lt;/code&gt; &lt;/a&gt;，那么这是一个类似的想法。）</target>
        </trans-unit>
        <trans-unit id="b8a37d3b1ef08026c956e9210fe57a016a1abeb9" translate="yes" xml:space="preserve">
          <source>However, on most runs, that&amp;rsquo;s not what happens &amp;ndash; the first part of the output is OK, and then when we get to the end the program crashes with &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;. If you run the program a few times, you&amp;rsquo;ll see that sometimes the traceback shows &lt;code&gt;send&lt;/code&gt; crashing, and other times it shows &lt;code&gt;receive&lt;/code&gt; crashing, and you might even find that on some runs it doesn&amp;rsquo;t crash at all.</source>
          <target state="translated">但是，在大多数运行中，不会发生这种情况&amp;ndash;输出的第一部分正常，然后到最后，程序因&lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; &lt;/a&gt;崩溃。如果您多次运行该程序，您会发现有时回溯显示 &lt;code&gt;send&lt;/code&gt; 崩溃，而有时它显示 &lt;code&gt;receive&lt;/code&gt; 崩溃，您甚至可能发现在某些运行中它根本不会崩溃。</target>
        </trans-unit>
        <trans-unit id="2312758fa0e741bf556c7094e1d6c332983a60b2" translate="yes" xml:space="preserve">
          <source>However, this part of the standard is widely ignored by real-world HTTPS implementations, which means that if you want to interoperate with them, then you NEED to ignore it too.</source>
          <target state="translated">然而,这部分标准被现实世界中的HTTPS实现广泛忽视,这意味着如果你想与它们互操作,那么你也必须忽视它。</target>
        </trans-unit>
        <trans-unit id="19b03b1b6c37147d5d29f006e500a4ed4c113fb9" translate="yes" xml:space="preserve">
          <source>I get:</source>
          <target state="translated">我明白了</target>
        </trans-unit>
        <trans-unit id="42b70820829e53baf48333e3880927dee7edb161" translate="yes" xml:space="preserve">
          <source>I/O in Trio</source>
          <target state="translated">三重奏中的I/O</target>
        </trans-unit>
        <trans-unit id="47c6b8c8f8e1a0dd24d9a8ac6524551b9a4890aa" translate="yes" xml:space="preserve">
          <source>IMPORTANT: This method may block in order to perform a &amp;ldquo;graceful&amp;rdquo; shutdown. But, if this fails, then it still &lt;em&gt;must&lt;/em&gt; close any underlying resources before returning. An error from this method indicates a failure to achieve grace, &lt;em&gt;not&lt;/em&gt; a failure to close the connection.</source>
          <target state="translated">重要说明：此方法可能会阻塞，以执行&amp;ldquo;正常&amp;rdquo;关闭。但是，如果失败，那么它仍然&lt;em&gt;必须&lt;/em&gt;在返回之前关闭所有基础资源。此方法的错误表示无法实现宽限期，&lt;em&gt;而不是&lt;/em&gt;无法关闭连接。</target>
        </trans-unit>
        <trans-unit id="659eab4e70caa38a30f16d960317cd3d960b3e36" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cancellable=False&lt;/code&gt;, the function ignores the cancellation and keeps going, just like if we had called &lt;code&gt;sync_fn&lt;/code&gt; synchronously. This is the default behavior.</source>
          <target state="translated">如果 &lt;code&gt;cancellable=False&lt;/code&gt; ，则该函数将忽略取消并继续运行，就像我们已同步调用 &lt;code&gt;sync_fn&lt;/code&gt; 一样。这是默认行为。</target>
        </trans-unit>
        <trans-unit id="1965c60e86c5c7cf8307b3f7f4c630c274d05a7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cancellable=True&lt;/code&gt;, then this function immediately raises &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. In this case &lt;strong&gt;the thread keeps running in background&lt;/strong&gt; &amp;ndash; we just abandon it to do whatever it&amp;rsquo;s going to do, and silently discard any return value or errors that it raises. Only use this if you know that the operation is safe and side-effect free. (For example: &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt; is uses a thread with &lt;code&gt;cancellable=True&lt;/code&gt;, because it doesn&amp;rsquo;t really affect anything if a stray hostname lookup keeps running in the background.)</source>
          <target state="translated">如果 &lt;code&gt;cancellable=True&lt;/code&gt; ，则此函数立即引发&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;。在这种情况下&lt;strong&gt;，线程将一直在后台运行&lt;/strong&gt; &amp;ndash;我们只是放弃它来做它将要做的一切，而无声地丢弃任何返回值或它引起的错误。仅当您知道该操作安全且无副作用时，才使用此功能。（例如：&lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt;使用的线程具有 &lt;code&gt;cancellable=True&lt;/code&gt; ，因为如果在后台运行杂散的主机名查找，它实际上并没有任何影响。）</target>
        </trans-unit>
        <trans-unit id="aba6364461f29e62fe17876f0b5c22b5417e80da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;handler&lt;/code&gt; neglects to close the &lt;code&gt;stream&lt;/code&gt;, then it will be closed using &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt;&lt;code&gt;trio.aclose_forcefully()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;handler&lt;/code&gt; 忽略关闭 &lt;code&gt;stream&lt;/code&gt; ，则将使用&lt;a href=&quot;#trio.aclose_forcefully&quot;&gt; &lt;code&gt;trio.aclose_forcefully()&lt;/code&gt; &lt;/a&gt;将其关闭。</target>
        </trans-unit>
        <trans-unit id="1277a00b059c5d2c5ef7f7646d1c9134594a5431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;handler&lt;/code&gt; raises an exception, then this function doesn&amp;rsquo;t do anything special to catch it &amp;ndash; so by default the exception will propagate out and crash your server. If you don&amp;rsquo;t want this, then catch exceptions inside your &lt;code&gt;handler&lt;/code&gt;, or use a &lt;code&gt;handler_nursery&lt;/code&gt; object that responds to exceptions in some other way.</source>
          <target state="translated">如果 &lt;code&gt;handler&lt;/code&gt; 引发异常，则此函数不会对其进行任何特殊处理-因此，默认情况下，该异常将传播出去并使服务器崩溃。如果您不希望这样做，则可以在 &lt;code&gt;handler&lt;/code&gt; 捕获异常，或使用以其他方式响应异常的 &lt;code&gt;handler_nursery&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="16a7aaf08e8695ea95415710c3e4758bb8256152" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;host&lt;/code&gt; is given as a numeric IP address, then &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; may handle the request itself rather than calling this method.</source>
          <target state="translated">如果将 &lt;code&gt;host&lt;/code&gt; 用作数字IP地址，则&lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt;可以自行处理请求，而不是调用此方法。</target>
        </trans-unit>
        <trans-unit id="a97d3af5b4523fc19e8fe52ab6041ae3db11563e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;https_compatible&lt;/code&gt; is False (the default), then this attempts to first send a &lt;code&gt;close_notify&lt;/code&gt; and then close the underlying stream by calling its &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">如果 &lt;code&gt;https_compatible&lt;/code&gt; 为False（默认设置），则这将尝试首先发送 &lt;code&gt;close_notify&lt;/code&gt; ，然后通过调用其&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt;方法关闭基础流。</target>
        </trans-unit>
        <trans-unit id="25ae479bd9da72823057df9f18d1514f989532e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;https_compatible&lt;/code&gt; is set to True, then this simply closes the underlying stream and marks this stream as closed.</source>
          <target state="translated">如果 &lt;code&gt;https_compatible&lt;/code&gt; 设置为True，则仅关闭基础流并将该流标记为已关闭。</target>
        </trans-unit>
        <trans-unit id="0f881d1427bb56edf169a6edeb8c1efed87b6b6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;idempotent=True&lt;/code&gt;, then &lt;code&gt;sync_fn&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt; must be hashable, and Trio will make a best-effort attempt to discard any call submission which is equal to an already-pending call. Trio will make an attempt to process these in first-in first-out order, but no guarantees. (Currently processing is FIFO on CPython 3.6 and PyPy, but not CPython 3.5.)</source>
          <target state="translated">如果 &lt;code&gt;idempotent=True&lt;/code&gt; ，则 &lt;code&gt;sync_fn&lt;/code&gt; 和 &lt;code&gt;args&lt;/code&gt; 必须是可哈希化的，并且Trio将尽最大努力尝试放弃任何与已在进行中的呼叫相等的呼叫提交。Trio将尝试以先进先出的顺序处理这些内容，但不能保证。（当前处理是在CPython 3.6和PyPy上的FIFO，但不是CPython 3.5。）</target>
        </trans-unit>
        <trans-unit id="6640f3a40179fca8c977825590b8d93ee250b08e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;instrument&lt;/code&gt; is already active, does nothing.</source>
          <target state="translated">如果 &lt;code&gt;instrument&lt;/code&gt; 已经激活，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="ef01b2d7eadb45a6611959bf01ff860e59edfd28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(exceptions) == 1&lt;/code&gt;, returns that exception. This means that a call to &lt;code&gt;MultiError(...)&lt;/code&gt; is not guaranteed to return a &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; object!</source>
          <target state="translated">如果 &lt;code&gt;len(exceptions) == 1&lt;/code&gt; ，则返回该异常。这意味着不能保证对 &lt;code&gt;MultiError(...)&lt;/code&gt; 的调用会返回&lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt;对象！</target>
        </trans-unit>
        <trans-unit id="5484f23b9c8687e23e7ba9482accdacff5d91e96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.send_stream.send_eof&lt;/code&gt; exists, then calls it. Otherwise, calls &lt;code&gt;self.send_stream.aclose()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;self.send_stream.send_eof&lt;/code&gt; 存在，则调用它。否则，调用 &lt;code&gt;self.send_stream.aclose()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e565b179b461394dd0ee23418e2601771bf98c83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_fn&lt;/code&gt; raises an exception, then it&amp;rsquo;s converted into a &lt;a href=&quot;reference-core#trio.TrioInternalError&quot;&gt;&lt;code&gt;TrioInternalError&lt;/code&gt;&lt;/a&gt; and &lt;em&gt;all&lt;/em&gt; tasks are cancelled. You should be careful that &lt;code&gt;sync_fn&lt;/code&gt; doesn&amp;rsquo;t crash.</source>
          <target state="translated">如果 &lt;code&gt;sync_fn&lt;/code&gt; 引发异常，那么它将转换为&lt;a href=&quot;reference-core#trio.TrioInternalError&quot;&gt; &lt;code&gt;TrioInternalError&lt;/code&gt; &lt;/a&gt;并取消&lt;em&gt;所有&lt;/em&gt;任务。您应注意 &lt;code&gt;sync_fn&lt;/code&gt; 不会崩溃。</target>
        </trans-unit>
        <trans-unit id="990c927a59e2e05acc2c85e7b9eca515a354fef6" translate="yes" xml:space="preserve">
          <source>If None (the default), uses the default &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt;, as returned by &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt;&lt;code&gt;current_default_thread_limiter()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果为None（默认值），则使用&lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt; &lt;code&gt;current_default_thread_limiter()&lt;/code&gt; &lt;/a&gt;返回的默认&lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d05809aaddc05f620de4ba89c04d5864f1d6c4f" translate="yes" xml:space="preserve">
          <source>If a cancel scope becomes cancelled before entering its &lt;code&gt;with&lt;/code&gt; block, the &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception will be raised at the first checkpoint inside the &lt;code&gt;with&lt;/code&gt; block. This allows a &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; to be created in one &lt;a href=&quot;#tasks&quot;&gt;task&lt;/a&gt; and passed to another, so that the first task can later cancel some work inside the second.</source>
          <target state="translated">如果取消作用域在进入其 &lt;code&gt;with&lt;/code&gt; 块之前被取消，则&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;异常将在 &lt;code&gt;with&lt;/code&gt; 块内的第一个检查点引发。这允许在一个&lt;a href=&quot;#tasks&quot;&gt;任务中&lt;/a&gt;创建&lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt;并将其传递给另一个任务，以便第一个任务以后可以取消第二个任务中的某些工作。</target>
        </trans-unit>
        <trans-unit id="b027817cbeed64537f5db91f3d08fdc471481eee" translate="yes" xml:space="preserve">
          <source>If a system task raises an exception, then it&amp;rsquo;s converted into a &lt;a href=&quot;reference-core#trio.TrioInternalError&quot;&gt;&lt;code&gt;TrioInternalError&lt;/code&gt;&lt;/a&gt; and &lt;em&gt;all&lt;/em&gt; tasks are cancelled. If you write a system task, you should be careful to make sure it doesn&amp;rsquo;t crash.</source>
          <target state="translated">如果系统任务引发异常，那么它将转换为&lt;a href=&quot;reference-core#trio.TrioInternalError&quot;&gt; &lt;code&gt;TrioInternalError&lt;/code&gt; &lt;/a&gt;并取消&lt;em&gt;所有&lt;/em&gt;任务。如果编写系统任务，则应小心确保它不会崩溃。</target>
        </trans-unit>
        <trans-unit id="4571550f4a15d7bae0009643f675312fe0036d78" translate="yes" xml:space="preserve">
          <source>If an EOF has already been sent, then this method should silently succeed.</source>
          <target state="translated">如果已经发送了一个EOF,那么这个方法应该默默地成功。</target>
        </trans-unit>
        <trans-unit id="45296ea408223fb4af1c47429fd38b83d611bdcc" translate="yes" xml:space="preserve">
          <source>If any task inside the nursery finishes with an unhandled exception, then the nursery immediately cancels all the tasks inside the nursery.</source>
          <target state="translated">如果苗圃内的任何一个任务在完成时出现了未处理的异常,那么苗圃会立即取消苗圃内的所有任务。</target>
        </trans-unit>
        <trans-unit id="ad7600a810bc11f91c2adfea072e298afde04ee1" translate="yes" xml:space="preserve">
          <source>If called with an &lt;code&gt;nbytes&lt;/code&gt; that&amp;rsquo;s greater than zero, then it will call &lt;code&gt;sock.recv&lt;/code&gt; at least once, and &lt;code&gt;recv&lt;/code&gt; is an async Trio function, and thus an unconditional checkpoint. So in this case, &lt;code&gt;recv_exactly&lt;/code&gt; acts as a checkpoint. But if we do &lt;code&gt;await
recv_exactly(sock, 0)&lt;/code&gt;, then it will immediately return an empty buffer without executing a checkpoint. If this were a function in Trio itself, then this wouldn&amp;rsquo;t be acceptable, but you may decide you don&amp;rsquo;t want to worry about this kind of minor edge case in your own code.</source>
          <target state="translated">如果使用大于零的 &lt;code&gt;nbytes&lt;/code&gt; 进行调用，则它将至少调用一次 &lt;code&gt;sock.recv&lt;/code&gt; ，并且 &lt;code&gt;recv&lt;/code&gt; 是异步Trio函数，因此是无条件检查点。因此，在这种情况下， &lt;code&gt;recv_exactly&lt;/code&gt; 充当检查点。但是，如果我们 &lt;code&gt;await recv_exactly(sock, 0)&lt;/code&gt; ，它将立即返回一个空缓冲区，而无需执行检查点。如果这是Trio本身的功能，那么这是不可接受的，但是您可能会决定不想担心自己的代码中的这种次要情况。</target>
        </trans-unit>
        <trans-unit id="02f5a27e4bd7755771be91835c2cda91fa8349fe" translate="yes" xml:space="preserve">
          <source>If cancelled, &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; terminates the subprocess and waits for it to exit before propagating the cancellation, like &lt;a href=&quot;#trio.Process.aclose&quot;&gt;&lt;code&gt;Process.aclose()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果取消，则&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt;终止子进程并等待其退出，然后再传播取消，例如&lt;a href=&quot;#trio.Process.aclose&quot;&gt; &lt;code&gt;Process.aclose()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="888cc7e58c3e7e821d20edf2b5cd73ba760154df" translate="yes" xml:space="preserve">
          <source>If cancelled, kills the process and waits for it to finish exiting before propagating the cancellation.</source>
          <target state="translated">如果取消,则杀死该进程,并等待它完成退出后再传播取消。</target>
        </trans-unit>
        <trans-unit id="cf2c140a05a78875d1f5d24dc874e16f64335dfa" translate="yes" xml:space="preserve">
          <source>If implementing this interface, you should consider whether you can go one step further and implement &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果实现此接口，则应考虑是否可以更进一步并实现&lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0275957337e1463961ce555770ceadbe862e0b84" translate="yes" xml:space="preserve">
          <source>If it blocks, and while it&amp;rsquo;s blocked then one of the scopes around it becomes cancelled, it will return early and raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果它被阻止，并且在被阻止时，它周围的范围之一将被取消，它将提早返回并引发&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd4041956ee7f9741134e0f1a0b8493a10950c30" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s already True, then this method returns immediately.</source>
          <target state="translated">如果已经为True，则此方法立即返回。</target>
        </trans-unit>
        <trans-unit id="56f1b3116eaca611475f7b84d97f7ac70972c4ee" translate="yes" xml:space="preserve">
          <source>If the child task passes a value to &lt;code&gt;task_status.started(value)&lt;/code&gt;, then &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; returns this value. Otherwise it returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">如果子任务将值传递给 &lt;code&gt;task_status.started(value)&lt;/code&gt; ，则&lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt;返回此值。否则返回 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37629b81efe2e8c145a2a531927b3cf8393e1bc1" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;host&lt;/code&gt; has multiple IP addresses associated with it, then we have a problem: which one do we use?</source>
          <target state="translated">如果给定的 &lt;code&gt;host&lt;/code&gt; 具有多个与之关联的IP地址，那么我们就会遇到一个问题：我们使用哪个？</target>
        </trans-unit>
        <trans-unit id="4375ef471535703a9908dadea8805978038773d1" translate="yes" xml:space="preserve">
          <source>If the initial handshake has already completed, this returns immediately without doing anything (except executing a checkpoint).</source>
          <target state="translated">如果初始握手已经完成,则立即返回,不做任何事情(除了执行一个检查点)。</target>
        </trans-unit>
        <trans-unit id="150a98efd2d67aeeb90753e4ff853b2109055a98" translate="yes" xml:space="preserve">
          <source>If the initial handshake is already in progress in another task, this waits for it to complete and then returns.</source>
          <target state="translated">如果最初的握手已经在另一个任务中进行,这将等待它完成,然后返回。</target>
        </trans-unit>
        <trans-unit id="c19f10e7d00e86fc95aa255c1ac054018dc1a174" translate="yes" xml:space="preserve">
          <source>If the resource is already closed, then this method should silently succeed.</source>
          <target state="translated">如果资源已经被关闭,那么这个方法应该默默地成功。</target>
        </trans-unit>
        <trans-unit id="9062a923df80e6fab65b8657d9f6a2b9026d5861" translate="yes" xml:space="preserve">
          <source>If there are fewer than &lt;code&gt;count&lt;/code&gt; tasks parked, then reparks as many tasks as are available and then returns successfully.</source>
          <target state="translated">如果所驻留的任务数量少于 &lt;code&gt;count&lt;/code&gt; ，那么请重新驻留尽可能多的任务，然后成功返回。</target>
        </trans-unit>
        <trans-unit id="377149956a1262f83743260fb07d31b29a188c54" translate="yes" xml:space="preserve">
          <source>If there are multiple tasks blocked in &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt;, then the one with the shortest &lt;code&gt;cushion&lt;/code&gt; is the one woken (and this task becoming unblocked resets the timers for the remaining tasks). If there are multiple tasks that have exactly the same &lt;code&gt;cushion&lt;/code&gt;, then the one with the lowest &lt;code&gt;tiebreaker&lt;/code&gt; value is woken first. And if there are multiple tasks with the same &lt;code&gt;cushion&lt;/code&gt; and the same &lt;code&gt;tiebreaker&lt;/code&gt;, then all are woken.</source>
          <target state="translated">如果&lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; 中&lt;/a&gt;有多个任务被阻塞，则 &lt;code&gt;cushion&lt;/code&gt; 时间最短的一个是被唤醒的（此任务变为非阻塞状态会重置其余任务的计时器）。如果有多个任务具有完全相同的 &lt;code&gt;cushion&lt;/code&gt; ，那么将首先唤醒具有最低 &lt;code&gt;tiebreaker&lt;/code&gt; 值的任务。并且如果有多个任务使用相同的 &lt;code&gt;cushion&lt;/code&gt; 和相同的 &lt;code&gt;tiebreaker&lt;/code&gt; ，则所有任务都被唤醒。</target>
        </trans-unit>
        <trans-unit id="755478d189f177af5d89c78e624e31c6791f6834" translate="yes" xml:space="preserve">
          <source>If this is called in a context where a cancellation is currently active (i.e., a blocking call will immediately raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;), then returned deadline is &lt;code&gt;-inf&lt;/code&gt;. If it is called in a context where no scopes have a deadline set, it returns &lt;code&gt;inf&lt;/code&gt;.</source>
          <target state="translated">如果在当前处于取消状态的上下文中调用此方法（即阻塞调用将立即引发&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;），则返回的截止日期为 &lt;code&gt;-inf&lt;/code&gt; 。如果在没有设置任何期限的上下文中调用它，则返回 &lt;code&gt;inf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d92a60f2ce7686f3c19dfb6575e2c818916fdf31" translate="yes" xml:space="preserve">
          <source>If this method is cancelled while the initial handshake or a renegotiation are in progress, then it may leave the &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; in an unusable state. If this happens then any future attempt to use the object will raise &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果在进行初始握手或重新协商时取消此方法，则它可能会使&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;处于无法使用的状态。如果发生这种情况，那么将来使用该对象的任何尝试都会引发&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b9129f4324a3c372997bd08724529da9bd32054" translate="yes" xml:space="preserve">
          <source>If this method is cancelled, then it may leave the &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; in an unusable state. If this happens then any attempt to use the object will raise &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果取消此方法，则可能使&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;处于不可用状态。如果发生这种情况，那么使用该对象的任何尝试都会引发&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c31c3e3ccb4521109d40e0f73cc0c0ff055f6741" translate="yes" xml:space="preserve">
          <source>If this method is cancelled, then it may leave the &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; in an unusable state. If this happens then any future attempt to use the object will raise &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果取消此方法，则可能使&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;处于不可用状态。如果发生这种情况，那么将来使用该对象的任何尝试都会引发&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="620d8617d908554f99b026fef5e4bce4f30f46da" translate="yes" xml:space="preserve">
          <source>If this stream has been closed, an empty bytearray. Otherwise, the requested data.</source>
          <target state="translated">如果这个流已经被关闭,则是一个空的字节数组。否则,为所请求的数据。</target>
        </trans-unit>
        <trans-unit id="01544d5318e6f8b44b1d61a7fe422bbe176746e1" translate="yes" xml:space="preserve">
          <source>If we didn&amp;rsquo;t re-acquire the lock before waking up, and &lt;a href=&quot;#trio.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; were cancelled here, then we&amp;rsquo;d crash in &lt;code&gt;condition.__aexit__&lt;/code&gt; when we tried to release the lock we no longer held.</source>
          <target state="translated">如果我们在醒来之前没有重新获取该锁，并且这里的&lt;a href=&quot;#trio.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt;被取消，那么我们将 &lt;code&gt;condition.__aexit__&lt;/code&gt; 当我们试图释放不再持有的锁时。</target>
        </trans-unit>
        <trans-unit id="286548126cabde1417f66f615fe9ea5965912a79" translate="yes" xml:space="preserve">
          <source>If you call an async function provided by Trio (&lt;code&gt;await
&amp;lt;something in trio&amp;gt;&lt;/code&gt;), and it doesn&amp;rsquo;t raise an exception, then it &lt;em&gt;always&lt;/em&gt; acts as a checkpoint. (If it does raise an exception, it might act as a checkpoint or might not.)</source>
          <target state="translated">如果调用Trio提供的异步函数（ &lt;code&gt;await &amp;lt;something in trio&amp;gt;&lt;/code&gt; ），并且它不会引发异常，则它&lt;em&gt;始终&lt;/em&gt;充当检查点。（如果确实引发异常，则它可能充当检查点，也可能不充当检查点。）</target>
        </trans-unit>
        <trans-unit id="fbdcd39191ff9bf10dd31ff815198d56d63dedd7" translate="yes" xml:space="preserve">
          <source>If you do want to be careful, or if you have some CPU-bound code that doesn&amp;rsquo;t have enough checkpoints in it, then it&amp;rsquo;s useful to know that &lt;code&gt;await trio.sleep(0)&lt;/code&gt; is an idiomatic way to execute a checkpoint without doing anything else, and that &lt;a href=&quot;reference-testing#trio.testing.assert_checkpoints&quot;&gt;&lt;code&gt;trio.testing.assert_checkpoints()&lt;/code&gt;&lt;/a&gt; can be used to test that an arbitrary block of code contains a checkpoint.</source>
          <target state="translated">如果确实要小心，或者如果您有一些CPU约束的代码中没有足够的检查点，那么知道 &lt;code&gt;await trio.sleep(0)&lt;/code&gt; 是不执行检查点的惯用方式是很有用的其他任何东西，该&lt;a href=&quot;reference-testing#trio.testing.assert_checkpoints&quot;&gt; &lt;code&gt;trio.testing.assert_checkpoints()&lt;/code&gt; &lt;/a&gt;可用于测试任意代码块是否包含检查点。</target>
        </trans-unit>
        <trans-unit id="2f265254292033b2d3c37d7b404f709ecf9005d4" translate="yes" xml:space="preserve">
          <source>If you get lost or confused&amp;hellip;</source>
          <target state="translated">如果您迷路或困惑...</target>
        </trans-unit>
        <trans-unit id="0d5e059f915ee38aa02ece60adf78aaec1b32ce6" translate="yes" xml:space="preserve">
          <source>If you have a custom hostname resolver, then implementing &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;code&gt;HostnameResolver&lt;/code&gt;&lt;/a&gt; allows you to register this to be used by Trio.</source>
          <target state="translated">如果您有一个自定义的主机名解析器，则实现&lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt; &lt;code&gt;HostnameResolver&lt;/code&gt; &lt;/a&gt;允许您注册供Trio使用的主机名。</target>
        </trans-unit>
        <trans-unit id="36078a151ccd458996ba1aa8099651b56e2af5bc" translate="yes" xml:space="preserve">
          <source>If you have a specific interface you want to bind to, pass its IP address or hostname here. If a hostname resolves to multiple IP addresses, this function will open one listener on each of them.</source>
          <target state="translated">如果你想绑定一个特定的接口,请在这里传递它的 IP 地址或主机名。如果一个主机名解析到多个IP地址,这个函数将在每个IP地址上打开一个监听器。</target>
        </trans-unit>
        <trans-unit id="7591ea78cf8028ce1427e112792af18d3864711d" translate="yes" xml:space="preserve">
          <source>If you have code that was written to use &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt;&lt;code&gt;ssl.SSLSocket&lt;/code&gt;&lt;/a&gt; and now you&amp;rsquo;re porting it to Trio, then it may be useful to know that a difference between &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt;&lt;code&gt;ssl.SSLSocket&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;https_compatible=True&lt;/code&gt; behavior by default.</source>
          <target state="translated">如果您已经编写了使用&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt; &lt;code&gt;ssl.SSLSocket&lt;/code&gt; 的&lt;/a&gt;代码，并且现在将其移植到Trio，那么了解&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt; &lt;code&gt;ssl.SSLSocket&lt;/code&gt; &lt;/a&gt;之间的区别可能是很有用的，因为&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt;默认情况下实现了 &lt;code&gt;https_compatible=True&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="4abae696645e70fb575d1bdc420f51262668ed04" translate="yes" xml:space="preserve">
          <source>If you have multiple decorators on the same function, then this should be at the bottom of the stack (closest to the actual function).</source>
          <target state="translated">如果你在同一个函数上有多个装饰符,那么这个应该在堆栈的底部(最接近实际函数的位置)。</target>
        </trans-unit>
        <trans-unit id="128c75659cdce10482417b79d20ee7014fe95a07" translate="yes" xml:space="preserve">
          <source>If you have two different file descriptors for sending and receiving, and want to bundle them together into a single bidirectional &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, then use &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;trio.StapledStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果您有两个不同的文件描述符用于发送和接收，并且想要将它们捆绑在一起成为一个单一的双向&lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;，则可以使用&lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;trio.StapledStream&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="01311317ab6fdc5abc001bd1faede4dd410963a9" translate="yes" xml:space="preserve">
          <source>If you only run subprocesses without &lt;code&gt;shell=True&lt;/code&gt; and on UNIX, that&amp;rsquo;s all you need to know about specifying the command. If you use &lt;code&gt;shell=True&lt;/code&gt; or run on Windows, you probably should read the rest of this section to be aware of potential pitfalls.</source>
          <target state="translated">如果仅在没有 &lt;code&gt;shell=True&lt;/code&gt; 的情况下在UNIX上运行子进程，那么这就是指定命令所需的全部知识。如果使用 &lt;code&gt;shell=True&lt;/code&gt; 或在Windows上运行，则可能应该阅读本节的其余部分以了解潜在的陷阱。</target>
        </trans-unit>
        <trans-unit id="f7360df706636e337b70ce5ebedc83a7dc602aa0" translate="yes" xml:space="preserve">
          <source>If you run this program, you&amp;rsquo;ll see output like:</source>
          <target state="translated">如果运行此程序，将看到类似以下的输出：</target>
        </trans-unit>
        <trans-unit id="11df8229fc6ec0bf8c5039502d2ef765262f6ef2" translate="yes" xml:space="preserve">
          <source>If you run this, it prints:</source>
          <target state="translated">如果你运行这个,它打印。</target>
        </trans-unit>
        <trans-unit id="29e33e39e5f4c64e7e7902552bf27f16a4cc81b1" translate="yes" xml:space="preserve">
          <source>If you spawn a &lt;a href=&quot;#subprocess&quot;&gt;Spawning subprocesses&lt;/a&gt;, you can get a &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; that lets you write to its stdin, and a &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; that lets you read from its stdout. If for some reason you wanted to speak SSL to a subprocess, you could use a &lt;a href=&quot;#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; to combine its stdin/stdout into a single bidirectional &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, and then wrap that in an &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果生成&lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#subprocess&quot;&gt;子流程&lt;/a&gt;，则可以获取一个SendStream，让您对其标准输入进行写入，以及一个&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt;，让您从其stdout中进行读取。如果由于某种原因，你想讲SSL的子进程，你可以使用一个&lt;a href=&quot;#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt;它的标准输入/输出组合成一个单一的双向&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;，然后包裹在一个&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="ab3304f0b7f762b993b24e90fc2ed83703c668e7" translate="yes" xml:space="preserve">
          <source>If you try to call it when inside a cancelled scope, then it will raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您尝试在取消范围内调用它，则它将引发&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cb8ad089db9738a30a52161499bfc8d1fd20710" translate="yes" xml:space="preserve">
          <source>If you use 0 as your port, then the kernel will automatically pick an arbitrary open port. But be careful: if you use this feature when binding to multiple IP addresses, then each IP address will get its own random port, and the returned listeners will probably be listening on different ports. In particular, this will happen if you use &lt;code&gt;host=None&lt;/code&gt; &amp;ndash; which is the default &amp;ndash; because in this case &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt; will bind to both the IPv4 wildcard address (&lt;code&gt;0.0.0.0&lt;/code&gt;) and also the IPv6 wildcard address (&lt;code&gt;::&lt;/code&gt;).</source>
          <target state="translated">如果使用0作为端口，则内核将自动选择一个任意打开的端口。但请注意：如果在绑定到多个IP地址时使用此功能，则每个IP地址将获得其自己的随机端口，并且返回的侦听器可能正在不同的端口上侦听。特别是，如果您使用 &lt;code&gt;host=None&lt;/code&gt; （这是默认设置），则会发生这种情况，因为在这种情况下，&lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt;将绑定到IPv4通配符地址（ &lt;code&gt;0.0.0.0&lt;/code&gt; ）和IPv6通配符地址（ &lt;code&gt;::&lt;/code&gt; :）。</target>
        </trans-unit>
        <trans-unit id="88ea13f3432ce0d9874ea1805ddf2510d4d0a998" translate="yes" xml:space="preserve">
          <source>If you use this method, you might also want to read up on &lt;code&gt;TCP_NOTSENT_LOWAT&lt;/code&gt;.</source>
          <target state="translated">如果使用此方法，则可能还需要阅读 &lt;code&gt;TCP_NOTSENT_LOWAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f6ced9e55c1c268f602e730722b3278b20ae5e9" translate="yes" xml:space="preserve">
          <source>If you want more control than &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; affords, you can use &lt;a href=&quot;#trio.open_process&quot;&gt;&lt;code&gt;trio.open_process&lt;/code&gt;&lt;/a&gt; to spawn a subprocess, and then interact with it using the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">如果您想要的控件超出了&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt;提供的范围，则可以使用&lt;a href=&quot;#trio.open_process&quot;&gt; &lt;code&gt;trio.open_process&lt;/code&gt; &lt;/a&gt;生成子&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt;，然后使用Process接口与其进行交互。</target>
        </trans-unit>
        <trans-unit id="d6f6793bc982be8f22f967ad6a21c35ccf9672fe" translate="yes" xml:space="preserve">
          <source>If you want to bind to the wildcard address on both IPv4 and IPv6, in order to accept connections on all available interfaces, then pass &lt;code&gt;None&lt;/code&gt;. This is the default.</source>
          <target state="translated">如果要绑定到IPv4和IPv6上的通配符地址，为了接受所有可用接口上的连接，请传递 &lt;code&gt;None&lt;/code&gt; 。这是默认值。</target>
        </trans-unit>
        <trans-unit id="cc32146617cf84e9f0d7584624d5d7d483182905" translate="yes" xml:space="preserve">
          <source>If you want to capture both stdout and stderr but mixed together in the order they were printed, use: &lt;code&gt;capture_stdout=True, stderr=subprocess.STDOUT&lt;/code&gt;. This directs the child&amp;rsquo;s stderr into its stdout, so the combined output will be available in the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">如果要同时捕获stdout和stderr，但要按照打印顺序将它们混合在一起，请使用： &lt;code&gt;capture_stdout=True, stderr=subprocess.STDOUT&lt;/code&gt; 。这会将孩子的stderr引导到其stdout中，因此合并的输出将在&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;属性中可用。</target>
        </trans-unit>
        <trans-unit id="af86717e438853496483f21a6a34b9a46aaba18a" translate="yes" xml:space="preserve">
          <source>If you want to capture both stdout and stderr while keeping them separate, pass &lt;code&gt;capture_stdout=True, capture_stderr=True&lt;/code&gt;.</source>
          <target state="translated">如果要同时捕获stdout和stderr并将它们分开，则传递 &lt;code&gt;capture_stdout=True, capture_stderr=True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a38252b45e1e41c55aef1d759da898cbd8aba075" translate="yes" xml:space="preserve">
          <source>If you want to impose a timeout on a function, and then do some recovery if it timed out:</source>
          <target state="translated">如果你想对一个函数施加一个超时,然后在它超时的情况下做一些恢复。</target>
        </trans-unit>
        <trans-unit id="79b96112188d56b28253e13ce6571d9e8abdac13" translate="yes" xml:space="preserve">
          <source>If you want to impose a timeout on a function, and then if it times out then just give up and raise an error for your caller to deal with:</source>
          <target state="translated">如果你想对一个函数施加一个超时,然后如果它超时了,那么就直接放弃,并提出一个错误让你的调用者来处理。</target>
        </trans-unit>
        <trans-unit id="3f808a75d4604bc4da76b55cf7478ba608c98efb" translate="yes" xml:space="preserve">
          <source>If you want to impose a timeout on a function, but you don&amp;rsquo;t care whether it timed out or not:</source>
          <target state="translated">如果您想对某个函数施加超时，但是您不在乎它是否超时：</target>
        </trans-unit>
        <trans-unit id="8a1518753dc6c14afc1ab9954c1aa2f9c4537ee9" translate="yes" xml:space="preserve">
          <source>If you want to perform general filesystem operations like creating and listing directories, renaming files, or checking file metadata &amp;ndash; or if you just want a friendly way to work with filesystem paths &amp;ndash; then you want &lt;a href=&quot;#trio.Path&quot;&gt;&lt;code&gt;trio.Path&lt;/code&gt;&lt;/a&gt;. It&amp;rsquo;s an asyncified replacement for the standard library&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt;, and provides the same comprehensive set of operations.</source>
          <target state="translated">如果要执行一般的文件系统操作，例如创建和列出目录，重命名文件或检查文件元数据&amp;ndash;或者只想使用一种友好的方法来处理文件系统路径&amp;ndash;那么就需要&lt;a href=&quot;#trio.Path&quot;&gt; &lt;code&gt;trio.Path&lt;/code&gt; &lt;/a&gt;。它是标准库的&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; &lt;/a&gt;的异步替换，并提供了相同的综合操作集。</target>
        </trans-unit>
        <trans-unit id="5c2ff5e1676e07dfee499073adaeae46d1a263de" translate="yes" xml:space="preserve">
          <source>If you want to receive Python objects rather than raw bytes, see &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要接收Python对象而不是原始字节，请参见&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d873431abf560f99e75a2d91264bee1f1cb0ab51" translate="yes" xml:space="preserve">
          <source>If you want to receive raw bytes rather than Python objects, see &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要接收原始字节而不是Python对象，请参见&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58a3ef3ebf410f4e73e5e916a21fac2377aedcd3" translate="yes" xml:space="preserve">
          <source>If you want to see the effect of the consumer exiting early, try adding a &lt;code&gt;break&lt;/code&gt; statement to the &lt;code&gt;async for&lt;/code&gt; loop &amp;ndash; you should see a &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt;&lt;code&gt;BrokenResourceError&lt;/code&gt;&lt;/a&gt; from the producer.</source>
          <target state="translated">如果您希望看到使用者提前退出的影响，请尝试在 &lt;code&gt;async for&lt;/code&gt; 循环中添加一个 &lt;code&gt;break&lt;/code&gt; 语句&amp;ndash;您应该&lt;a href=&quot;#trio.BrokenResourceError&quot;&gt; &lt;code&gt;BrokenResourceError&lt;/code&gt; &lt;/a&gt;从生产者那里看到BrokenResourceError。</target>
        </trans-unit>
        <trans-unit id="9d4b21118989033e089c8ae10cb1be03ab62b474" translate="yes" xml:space="preserve">
          <source>If you want to send Python objects rather than raw bytes, see &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要发送Python对象而不是原始字节，请参见&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2bfa949577a81d6ee39c408b0060d9b3a9b1359f" translate="yes" xml:space="preserve">
          <source>If you want to send raw bytes rather than Python objects, see &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要发送原始字节而不是Python对象，请参见&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="15078494d6548257baf334a23f5ce3f1047e5763" translate="yes" xml:space="preserve">
          <source>If you want to stress test a protocol implementation, one nice trick is to use the &lt;a href=&quot;https://docs.python.org/3/library/random.html#module-random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; module (preferably with a fixed seed) to move random numbers of bytes at a time, and insert random sleeps in between them. You can also set up a custom &lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some_hook&quot;&gt;&lt;code&gt;receive_some_hook&lt;/code&gt;&lt;/a&gt; if you want to manipulate things on the receiving side, and not just the sending side.</source>
          <target state="translated">如果要对协议实现进行压力测试，一个不错的技巧是使用&lt;a href=&quot;https://docs.python.org/3/library/random.html#module-random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt;模块（最好使用固定种子）一次移动随机数的字节，然后在它们之间插入随机睡眠。如果要在接收方而不是发送方进行操作，还可以设置自定义的&lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some_hook&quot;&gt; &lt;code&gt;receive_some_hook&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f91fa402eff1105a1adeaf1e1e3e650782929273" translate="yes" xml:space="preserve">
          <source>If you want to use Trio, then the first thing you have to do is call &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果要使用Trio，那么要做的第一件事就是调用&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="21c7da565039fca46c6760ffc74fa89fb0eba0cd" translate="yes" xml:space="preserve">
          <source>If you want to use only IPv4, or only IPv6, but want to accept on all interfaces, pass the family-specific wildcard address: &lt;code&gt;&quot;0.0.0.0&quot;&lt;/code&gt; for IPv4-only and &lt;code&gt;&quot;::&quot;&lt;/code&gt; for IPv6-only.</source>
          <target state="translated">如果要仅使用IPv4或仅使用IPv6，但要在所有接口上接受，请传递家族专用的通配符地址： &lt;code&gt;&quot;0.0.0.0&quot;&lt;/code&gt; （仅用于IPv4）和 &lt;code&gt;&quot;::&quot;&lt;/code&gt; （仅用于IPv6）。</target>
        </trans-unit>
        <trans-unit id="409a1ee1102eee81503ac9b40ded20152aafe6b5" translate="yes" xml:space="preserve">
          <source>If you write a custom class implementing the Trio socket interface, then you can use a &lt;a href=&quot;#trio.abc.SocketFactory&quot;&gt;&lt;code&gt;SocketFactory&lt;/code&gt;&lt;/a&gt; to get Trio to use it.</source>
          <target state="translated">如果编写实现Trio套接字接口的自定义类，则可以使用&lt;a href=&quot;#trio.abc.SocketFactory&quot;&gt; &lt;code&gt;SocketFactory&lt;/code&gt; &lt;/a&gt;来使Trio使用它。</target>
        </trans-unit>
        <trans-unit id="d6034aab77a6f216c1ab5b1d5c3f35931c5c8769" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a mad scientist or otherwise feel the need to take direct control over the PASSAGE OF TIME ITSELF, then you can implement a custom &lt;a href=&quot;#trio.abc.Clock&quot;&gt;&lt;code&gt;Clock&lt;/code&gt;&lt;/a&gt; class:</source>
          <target state="translated">如果您是一个疯狂的科学家，或者以其他方式感到需要直接控制&amp;ldquo;通过时间&amp;rdquo;，那么可以实现一个自定义&lt;a href=&quot;#trio.abc.Clock&quot;&gt; &lt;code&gt;Clock&lt;/code&gt; &lt;/a&gt;类：</target>
        </trans-unit>
        <trans-unit id="ce8031c58c1526815dbf37b52fa1e2d05777dd57" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with semaphores, then you can think of this as a restricted semaphore that&amp;rsquo;s specialized for one common use case, with additional error checking. For a more traditional semaphore, see &lt;a href=&quot;#trio.Semaphore&quot;&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您熟悉信号量，则可以将其视为专用于一种常见用例并带有附加错误检查的受限信号量。有关更传统的信号灯，请参见&lt;a href=&quot;#trio.Semaphore&quot;&gt; &lt;code&gt;Semaphore&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ee1d508a124c1215a7b5f07506c4f3b67f9cb32" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking for a &lt;a href=&quot;#trio.Semaphore&quot;&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/a&gt; to limit the number of tasks that can access some resource simultaneously, then consider using a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您正在寻找一个&lt;a href=&quot;#trio.Semaphore&quot;&gt; &lt;code&gt;Semaphore&lt;/code&gt; &lt;/a&gt;来限制可以同时访问某些资源的任务数量，那么可以考虑使用&lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2ceab8baefc8898008496db6707ffc21bacfe8c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; together, then you have to be careful. Setting &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; acts like a background task calling:</source>
          <target state="translated">如果同时使用&lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt;，则必须小心。设置&lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt;就像调用后台任务一样：</target>
        </trans-unit>
        <trans-unit id="08c549cf9087de57658bffaeb40cba21be44321a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve used other I/O frameworks, you may have encountered the concept of a &amp;ldquo;thread pool&amp;rdquo;, which is most commonly implemented as a fixed size collection of threads that hang around waiting for jobs to be assigned to them. These solve two different problems: First, re-using the same threads over and over is more efficient than starting and stopping a new thread for every job you need done; basically, the pool acts as a kind of cache for idle threads. And second, having a fixed size avoids getting into a situation where 100,000 jobs are submitted simultaneously, and then 100,000 threads are spawned and the system gets overloaded and crashes. Instead, the N threads start executing the first N jobs, while the other (100,000 - N) jobs sit in a queue and wait their turn. Which is generally what you want, and this is how &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; works by default.</source>
          <target state="translated">如果您使用了其他I / O框架，则可能会遇到&amp;ldquo;线程池&amp;rdquo;的概念，该概念最常见的实现是固定大小的线程集合，这些线程徘徊在等待分配作业的状态。这些解决了两​​个不同的问题：首先，一遍又一遍地重复使用相同的线程比开始和停止需要执行的每个作业的新线程要有效。基本上，池充当闲置线程的一种缓存。其次，具有固定大小可以避免陷入同时提交100,000个作业，然后产生100,000个线程，系统过载和崩溃的情况。取而代之的是，N个线程开始执行前N个作业，而其他（100,000-N）个作业排在队列中并等待轮换。通常，这是您想要的，这就是方法&lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt;默认工作。</target>
        </trans-unit>
        <trans-unit id="3b707c51adeef615b8afcc1a6c139b7761d771ed" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve used the &lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; modules, you may be familiar with &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Queue&quot;&gt;&lt;code&gt;queue.Queue&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue&quot;&gt;&lt;code&gt;asyncio.Queue&lt;/code&gt;&lt;/a&gt;. In Trio, &lt;a href=&quot;#trio.open_memory_channel&quot;&gt;&lt;code&gt;open_memory_channel()&lt;/code&gt;&lt;/a&gt; is what you use when you&amp;rsquo;re looking for a queue. The main difference is that Trio splits the classic queue interface up into two objects. The advantage of this is that it makes it possible to put the two ends in different processes without rewriting your code, and that we can close the two sides separately.</source>
          <target state="translated">如果您使用过&lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; &lt;/a&gt;模块，则可能对&lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Queue&quot;&gt; &lt;code&gt;queue.Queue&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue&quot;&gt; &lt;code&gt;asyncio.Queue&lt;/code&gt; &lt;/a&gt;很熟悉。在Trio中，&lt;a href=&quot;#trio.open_memory_channel&quot;&gt; &lt;code&gt;open_memory_channel()&lt;/code&gt; &lt;/a&gt;是您在查找队列时使用的东西。主要区别在于Trio将经典队列接口分为两个对象。这样做的好处是可以将两个端点放在不同的进程中而无需重写代码，并且我们可以分别封闭两个端点。</target>
        </trans-unit>
        <trans-unit id="1b07f876adc2ea078990a31a6d6fd87e7ced229f" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;abort_func&lt;/code&gt; raises an error, or returns any value other than &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt;&lt;code&gt;Abort.FAILED&lt;/code&gt;&lt;/a&gt;, then Trio will crash violently. Be careful! Similarly, it is entirely possible to deadlock a Trio program by failing to reschedule a blocked task, or cause havoc by calling &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; too many times. Remember what we said up above about how you should use a higher-level API if at all possible?</source>
          <target state="translated">如果您的 &lt;code&gt;abort_func&lt;/code&gt; 引发错误，或返回&lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt; &lt;code&gt;Abort.FAILED&lt;/code&gt; &lt;/a&gt;以外的其他任何值，则Trio会严重崩溃。小心！类似地，完全有可能由于无法重新计划被阻止的任务而使Trio程序死锁，或者通过多次调用&lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt;造成严重破坏。还记得我们上面说过的有关如何尽可能使用高级API的内容吗？</target>
        </trans-unit>
        <trans-unit id="1f6649636f5ec26220a403d0be3a3dfad0c81513" translate="yes" xml:space="preserve">
          <source>Immediately terminate the process.</source>
          <target state="translated">立即终止该进程。</target>
        </trans-unit>
        <trans-unit id="4f6dbe18b8350bccd3b6cbe5e585a2220801dfd1" translate="yes" xml:space="preserve">
          <source>In Trio, child tasks inherit the parent nursery&amp;rsquo;s cancel scopes. So in this example, both the child tasks will be cancelled when the timeout expires:</source>
          <target state="translated">在Trio中，子任务继承了父级托儿所的取消范围。因此，在此示例中，当超时到期时，两个子任务都将被取消：</target>
        </trans-unit>
        <trans-unit id="adca0c20a8b210b6d717b9f157a4e42c8458511e" translate="yes" xml:space="preserve">
          <source>In Trio, we standardize on the following conventions:</source>
          <target state="translated">在Trio中,我们以下列惯例为标准。</target>
        </trans-unit>
        <trans-unit id="eba0fbe044bed37d1ee5815afce7800f998f1460" translate="yes" xml:space="preserve">
          <source>In a perfect world, all third-party libraries and low-level APIs would be natively async and integrated into Trio, and all would be happiness and rainbows.</source>
          <target state="translated">在一个完美的世界里,所有的第三方库和低级API都将是原生异步并集成到Trio中,一切都将是幸福和彩虹。</target>
        </trans-unit>
        <trans-unit id="af175d3a175436652574281c086a32ff0684e455" translate="yes" xml:space="preserve">
          <source>In acknowledgment of this reality, Trio provides two useful utilities for working with real, operating-system level, &lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt;-module-style threads. First, if you&amp;rsquo;re in Trio but need to push some blocking I/O into a thread, there&amp;rsquo;s &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync&lt;/code&gt;&lt;/a&gt;. And if you&amp;rsquo;re in a thread and need to communicate back with Trio, you can use &lt;a href=&quot;#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.from_thread.run_sync&quot;&gt;&lt;code&gt;trio.from_thread.run_sync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">考虑到这一现实，Trio提供了两个有用的实用程序，用于处理真实的，操作系统级别的&lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt;模块样式的线程。首先，如果您在Trio中，但需要将一些阻塞的I / O推送到线程中，则有&lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync&lt;/code&gt; &lt;/a&gt;。而且，如果您处于线程中并且需要与Trio进行通讯，则可以使用&lt;a href=&quot;#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#trio.from_thread.run_sync&quot;&gt; &lt;code&gt;trio.from_thread.run_sync()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afb36f9e82fb37771a8f45c9fa49b6f8200dd4dc" translate="yes" xml:space="preserve">
          <source>In addition to fulfilling the &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; interfaces, the return objects also have a synchronous &lt;code&gt;close&lt;/code&gt; method.</source>
          <target state="translated">除了实现&lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt;接口之外，返回对象还具有同步 &lt;code&gt;close&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="b1f03f50ad28c191c6b6552e298ff38d97315bda" translate="yes" xml:space="preserve">
          <source>In addition to the methods below, you can use &lt;code&gt;len(parking_lot)&lt;/code&gt; to get the number of parked tasks, and &lt;code&gt;if parking_lot: ...&lt;/code&gt; to check whether there are any parked tasks.</source>
          <target state="translated">除了以下方法之外，您还可以使用 &lt;code&gt;len(parking_lot)&lt;/code&gt; 来获取停放的任务数，如果可以使用 &lt;code&gt;if parking_lot: ...&lt;/code&gt; 来查看是否有任何停放的任务。</target>
        </trans-unit>
        <trans-unit id="9e73f7536eb9efa30a32fd713063b04bc4ef0794" translate="yes" xml:space="preserve">
          <source>In addition to the standard channel methods, all memory channel objects provide a &lt;code&gt;statistics()&lt;/code&gt; method, which returns an object with the following fields:</source>
          <target state="translated">除了标准通道方法外，所有内存通道对象都提供了 &lt;code&gt;statistics()&lt;/code&gt; 方法，该方法返回具有以下字段的对象：</target>
        </trans-unit>
        <trans-unit id="443c7855adca91f5f4c2a290b45f592b6637683c" translate="yes" xml:space="preserve">
          <source>In addition, the following methods are similar to the equivalents in &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;, but have some Trio-specific quirks:</source>
          <target state="translated">此外，以下方法与&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; 中&lt;/a&gt;的等效方法相似，但具有一些Trio特定的怪癖：</target>
        </trans-unit>
        <trans-unit id="413061e58789aa3ae8c0df61031c67abdb592c3a" translate="yes" xml:space="preserve">
          <source>In addition, there is a new function to directly convert a standard library socket into a Trio socket:</source>
          <target state="translated">此外,还新增了一个功能,可以直接将标准库套接字转换为Trio套接字。</target>
        </trans-unit>
        <trans-unit id="425030d69a5c17d60c387cfd4bccb05160ac1b64" translate="yes" xml:space="preserve">
          <source>In any case it&amp;rsquo;s guaranteed that we only call the &lt;code&gt;abort_func&lt;/code&gt; at most once per call to &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在任何情况下，它保证了我们只能调用 &lt;code&gt;abort_func&lt;/code&gt; 最多每调用一次&lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef942a0c9203fcfec85a5301b86deb82c4607851" translate="yes" xml:space="preserve">
          <source>In the US it&amp;rsquo;s also common to see this word spelled &amp;ldquo;canceled&amp;rdquo;, with only one &amp;ldquo;l&amp;rdquo;. This is a &lt;a href=&quot;https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;amp;year_start=1800&amp;amp;year_end=2000&amp;amp;corpus=5&amp;amp;smoothing=3&amp;amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0&quot;&gt;recent&lt;/a&gt; and &lt;a href=&quot;https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;amp;year_start=1800&amp;amp;year_end=2000&amp;amp;corpus=18&amp;amp;smoothing=3&amp;amp;share=&amp;amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0&quot;&gt;US-specific&lt;/a&gt; innovation, and even in the US both forms are still commonly used. So for consistency with the rest of the world and with &amp;ldquo;cancellation&amp;rdquo; (which always has two &amp;ldquo;l&amp;rdquo;s), Trio uses the two &amp;ldquo;l&amp;rdquo; spelling everywhere.</source>
          <target state="translated">在美国，经常看到这个单词拼写为&amp;ldquo;取消&amp;rdquo;，只有一个&amp;ldquo; l&amp;rdquo;。这是一个&lt;a href=&quot;https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;amp;year_start=1800&amp;amp;year_end=2000&amp;amp;corpus=5&amp;amp;smoothing=3&amp;amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0&quot;&gt;近期&lt;/a&gt;和&lt;a href=&quot;https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;amp;year_start=1800&amp;amp;year_end=2000&amp;amp;corpus=18&amp;amp;smoothing=3&amp;amp;share=&amp;amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0&quot;&gt;美国特定的&lt;/a&gt;创新，即使在美国这两种形式仍在普遍使用。因此，为了与世界其他地方和&amp;ldquo;取消&amp;rdquo;（始终有两个&amp;ldquo; l&amp;rdquo;）保持一致，Trio在各处都使用了两个&amp;ldquo; l&amp;rdquo;拼写。</target>
        </trans-unit>
        <trans-unit id="16efeed4257a18bc9fdc35fc0ddc91451f889cf7" translate="yes" xml:space="preserve">
          <source>In the example above, we set &lt;code&gt;__cause__&lt;/code&gt; as a form of explicit context chaining. &lt;a href=&quot;#trio.MultiError.filter&quot;&gt;&lt;code&gt;MultiError.filter()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.MultiError.catch&quot;&gt;&lt;code&gt;MultiError.catch()&lt;/code&gt;&lt;/a&gt; also perform implicit exception chaining &amp;ndash; if you return a new exception object, then the new object&amp;rsquo;s &lt;code&gt;__context__&lt;/code&gt; attribute will automatically be set to the original exception.</source>
          <target state="translated">在上面的示例中，我们将 &lt;code&gt;__cause__&lt;/code&gt; 设置为显式上下文链接的一种形式。&lt;a href=&quot;#trio.MultiError.filter&quot;&gt; &lt;code&gt;MultiError.filter()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#trio.MultiError.catch&quot;&gt; &lt;code&gt;MultiError.catch()&lt;/code&gt; &lt;/a&gt;也执行隐式异常链接-如果返回新的异常对象，则新对象的 &lt;code&gt;__context__&lt;/code&gt; 属性将自动设置为原始异常。</target>
        </trans-unit>
        <trans-unit id="d6ba9aa5681eb07f3f85aaca6cead6a6a75b07e2" translate="yes" xml:space="preserve">
          <source>In the previous section you learned how to use virtual in-memory streams to test protocols that are written against Trio&amp;rsquo;s &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; abstraction. But what if you have more complicated networking code &amp;ndash; the kind of code that makes connections to multiple hosts, or opens a listening socket, or sends UDP packets?</source>
          <target state="translated">在上一节中，您学习了如何使用虚拟内存流来测试针对Trio的&lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;抽象编写的协议。但是，如果您有更复杂的网络代码，即与多个主机建立连接，打开侦听套接字或发送UDP数据包的代码，该怎么办？</target>
        </trans-unit>
        <trans-unit id="a0095c623d0110d9746feea443a0e6da70cddc6c" translate="yes" xml:space="preserve">
          <source>In the simplest case, you can apply a timeout to a block of code:</source>
          <target state="translated">在最简单的情况下,你可以对一个代码块应用超时。</target>
        </trans-unit>
        <trans-unit id="eff100c80ba5e97057de30f32a18adbad5a88b36" translate="yes" xml:space="preserve">
          <source>In this code, the outer scope will expire after 5 seconds, causing the &lt;a href=&quot;#trio.sleep&quot;&gt;&lt;code&gt;sleep()&lt;/code&gt;&lt;/a&gt; call to return early with a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception. Then this exception will propagate through the &lt;code&gt;with
move_on_after(10)&lt;/code&gt; line until it&amp;rsquo;s caught by the &lt;code&gt;with
move_on_after(5)&lt;/code&gt; context manager. So this code will print:</source>
          <target state="translated">在此代码中，外部作用域将在5秒后过期，从而导致&lt;a href=&quot;#trio.sleep&quot;&gt; &lt;code&gt;sleep()&lt;/code&gt; &lt;/a&gt;调用提前返回，并带有&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;异常。然后，此异常将通过 &lt;code&gt;with move_on_after(10)&lt;/code&gt; 行传播，直到被 &lt;code&gt;with move_on_after(5)&lt;/code&gt; 上下文管理器捕获为止。因此，此代码将打印：</target>
        </trans-unit>
        <trans-unit id="3fd39030cf0f9d49c7b4882dafc1867fcf325030" translate="yes" xml:space="preserve">
          <source>In this log, it&amp;rsquo;s hard to know which lines came from which request. (Did the request that started first also finish first, or not?) One way to solve this is to assign each request a unique identifier, and then include this identifier in each log message:</source>
          <target state="translated">在此日志中，很难知道哪些行来自哪个请求。（首先启动的请求是否也先完成？）解决此问题的一种方法是为每个请求分配一个唯一的标识符，然后在每个日志消息中包括该标识符：</target>
        </trans-unit>
        <trans-unit id="6c5f57d6f1f293c43f3e60c7da9a475c532f3702" translate="yes" xml:space="preserve">
          <source>Increment the semaphore value, possibly waking a task blocked in &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">增大信号量值，可能会唤醒被&lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt;阻塞的任务。</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="5e2d7833039dc978e6eb0d1055910e03a86a4609" translate="yes" xml:space="preserve">
          <source>Indices and tables</source>
          <target state="translated">指数和表格</target>
        </trans-unit>
        <trans-unit id="039860d992ee7e77987abc3b4a132dfd8deb034e" translate="yes" xml:space="preserve">
          <source>Inherits from&amp;hellip;</source>
          <target state="translated">继承自&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a760a6a6a56453764562801ae1f6e4d17df6981e" translate="yes" xml:space="preserve">
          <source>Inside Trio, we&amp;rsquo;re very picky about this, because Trio is the foundation of the whole system so we think it&amp;rsquo;s worth the extra effort to make things extra predictable. It&amp;rsquo;s up to you how picky you want to be in your code. To give you a more realistic example of what this kind of issue looks like in real life, consider this function:</source>
          <target state="translated">在Trio内部，我们对此非常挑剔，因为Trio是整个系统的基础，因此我们认为值得付出额外的精力来使事情更具可预测性。您可以根据自己的意愿来选择代码。为了给您一个更现实的例子，说明这种问题在现实生活中的样子，请考虑以下功能：</target>
        </trans-unit>
        <trans-unit id="4383f9af14e2a6238f0ca630f4abb63f780fec7f" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;with&lt;/code&gt; block, a cancellation of &lt;code&gt;cancel_scope&lt;/code&gt; (via a call to its &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt;&lt;code&gt;cancel()&lt;/code&gt;&lt;/a&gt; method or via the expiry of its &lt;a href=&quot;#trio.CancelScope.deadline&quot;&gt;&lt;code&gt;deadline&lt;/code&gt;&lt;/a&gt;) will immediately interrupt the &lt;code&gt;long_running_operation()&lt;/code&gt; by raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; at its next &lt;a href=&quot;#checkpoints&quot;&gt;checkpoint&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;with&lt;/code&gt; 块中，取消 &lt;code&gt;cancel_scope&lt;/code&gt; （通过调用&lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt; &lt;code&gt;cancel()&lt;/code&gt; &lt;/a&gt;方法或通过其&lt;a href=&quot;#trio.CancelScope.deadline&quot;&gt; &lt;code&gt;deadline&lt;/code&gt; &lt;/a&gt;的到期）将通过在下一个&lt;a href=&quot;#checkpoints&quot;&gt;checkpoint&lt;/a&gt;处引发&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;来立即中断 &lt;code&gt;long_running_operation()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc578a93a7ae18b3336261ddcddb492f729be12e" translate="yes" xml:space="preserve">
          <source>Install: &lt;code&gt;python3 -m pip install -U trio&lt;/code&gt; (or on Windows, maybe &lt;code&gt;py -3 -m pip install -U trio&lt;/code&gt;). No compiler needed.</source>
          <target state="translated">安装： &lt;code&gt;python3 -m pip install -U trio&lt;/code&gt; （或者在Windows上，可能是 &lt;code&gt;py -3 -m pip install -U trio&lt;/code&gt; ）。无需编译器。</target>
        </trans-unit>
        <trans-unit id="2b8599d5e978753d93f75d58a522579079b5ed94" translate="yes" xml:space="preserve">
          <source>Instances of this class implement a &lt;code&gt;__call__&lt;/code&gt; method which returns an async context manager. The idea is that you pass a sequence number to &lt;code&gt;__call__&lt;/code&gt; to say where this block of code should go in the linear sequence. Block 0 starts immediately, and then block N doesn&amp;rsquo;t start until block N-1 has finished.</source>
          <target state="translated">此类的实例实现 &lt;code&gt;__call__&lt;/code&gt; 方法，该方法返回异步上下文管理器。这个想法是，您将一个序列号传递给 &lt;code&gt;__call__&lt;/code&gt; ,以说明此代码块应在线性序列中的位置。块0立即开始，然后直到块N-1完成，块N才开始。</target>
        </trans-unit>
        <trans-unit id="3ec5b66be254478fa22108fac8f5d2812e01372a" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;ssl.SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt;, you create a &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">创建&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;，而不是使用&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;ssl.SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="627fcf03843dc8a8605eb47152a8672db7094c61" translate="yes" xml:space="preserve">
          <source>Instrument API</source>
          <target state="translated">仪器API</target>
        </trans-unit>
        <trans-unit id="05dc85f2b3ab4754451d1f9965930cf9da6a45a9" translate="yes" xml:space="preserve">
          <source>Instruments don&amp;rsquo;t have to inherit from this abstract base class, and all of these methods are optional. This class serves mostly as documentation.</source>
          <target state="translated">仪器不必从此抽象基类继承，并且所有这些方法都是可选的。此类主要用作文档。</target>
        </trans-unit>
        <trans-unit id="eca9838aabbb78d1b5e3acdb2dd4e57649569498" translate="yes" xml:space="preserve">
          <source>Inter-task ordering</source>
          <target state="translated">任务间排序</target>
        </trans-unit>
        <trans-unit id="636ae634805f18ba2489e4cf0305b910ad6e1ec2" translate="yes" xml:space="preserve">
          <source>Interacting with a process as it runs</source>
          <target state="translated">在进程运行时与之互动</target>
        </trans-unit>
        <trans-unit id="8d73f8d3b26a1a856cc0af59962f16a7a7926a99" translate="yes" xml:space="preserve">
          <source>Internally, Python&amp;rsquo;s async/await syntax is built around the idea of &amp;ldquo;coroutine objects&amp;rdquo; and &amp;ldquo;coroutine runners&amp;rdquo;. A coroutine object represents the state of an async callstack. But by itself, this is just a static object that sits there. If you want it to do anything, you need a coroutine runner to push it forward. Every Trio task has an associated coroutine object (see &lt;a href=&quot;#trio.hazmat.Task.coro&quot;&gt;&lt;code&gt;Task.coro&lt;/code&gt;&lt;/a&gt;), and the Trio scheduler acts as their coroutine runner.</source>
          <target state="translated">在内部，Python的async / await语法是围绕&amp;ldquo;协程对象&amp;rdquo;和&amp;ldquo;协程运行程序&amp;rdquo;的思想构建的。协程对象表示异步调用栈的状态。但是就其本身而言，这只是一个静态对象而已。如果您希望它执行任何操作，则需要协程运行程序将其向前推进。每个Trio任务都有一个关联的协程对象（请参阅&lt;a href=&quot;#trio.hazmat.Task.coro&quot;&gt; &lt;code&gt;Task.coro&lt;/code&gt; &lt;/a&gt;），并且Trio调度程序充当其协程运行器。</target>
        </trans-unit>
        <trans-unit id="211f3ecde809054095962b782038f30e2565b4f3" translate="yes" xml:space="preserve">
          <source>Internally, this class is implemented using an instance of &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;ssl.SSLObject&lt;/code&gt;&lt;/a&gt;, and all of &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s methods and attributes are re-exported as methods and attributes on this class. However, there is one difference: &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; has several methods that return information about the encrypted connection, like &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.cipher&quot;&gt;&lt;code&gt;cipher()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.selected_alpn_protocol&quot;&gt;&lt;code&gt;selected_alpn_protocol()&lt;/code&gt;&lt;/a&gt;. If you call them before the handshake, when they can&amp;rsquo;t possibly return useful data, then &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;ssl.SSLObject&lt;/code&gt;&lt;/a&gt; returns None, but &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;trio.SSLStream&lt;/code&gt;&lt;/a&gt; raises &lt;a href=&quot;#trio.NeedHandshakeError&quot;&gt;&lt;code&gt;NeedHandshakeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在内部，此类是使用&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;ssl.SSLObject&lt;/code&gt; &lt;/a&gt;的实例实现的，并且所有&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt;的方法和属性都重新导出为此类的方法和属性。但是，有一个区别：&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt;有几种方法可返回有关加密连接的信息，例如&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.cipher&quot;&gt; &lt;code&gt;cipher()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.selected_alpn_protocol&quot;&gt; &lt;code&gt;selected_alpn_protocol()&lt;/code&gt; &lt;/a&gt;。如果在握手之前调用它们，则当它们不可能返回有用的数据时，&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;ssl.SSLObject&lt;/code&gt; &lt;/a&gt;返回None，但是&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;trio.SSLStream&lt;/code&gt; &lt;/a&gt;会引发&lt;a href=&quot;#trio.NeedHandshakeError&quot;&gt; &lt;code&gt;NeedHandshakeError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aad10a74de784eb77b7994e8e3df391e71c75b48" translate="yes" xml:space="preserve">
          <source>Introduce a schedule point, but not a cancel point.</source>
          <target state="translated">引入一个计划点,但不是取消点。</target>
        </trans-unit>
        <trans-unit id="3a39def0776ba74eafe8baafe78545be2b62c2bf" translate="yes" xml:space="preserve">
          <source>Introspecting and extending Trio with &lt;code&gt;trio.hazmat&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;trio.hazmat&lt;/code&gt; 内省和扩展Trio</target>
        </trans-unit>
        <trans-unit id="f875ac8ad79c6803f9483ecd07dc8b2c5c1bf08d" translate="yes" xml:space="preserve">
          <source>Introspecting and extending Trio with trio.hazmat</source>
          <target state="translated">用trio.hazmat介绍和扩展Trio。</target>
        </trans-unit>
        <trans-unit id="0b7ac58e93ecd2e82e060a85238c964fc4eccff9" translate="yes" xml:space="preserve">
          <source>Issue a &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoint&lt;/a&gt; if the calling context has been cancelled.</source>
          <target state="translated">如果调用上下文已取消，则发出&lt;a href=&quot;reference-core#checkpoints&quot;&gt;检查点&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="887b272faffff6c3a2885420536e51339dbc8a6a" translate="yes" xml:space="preserve">
          <source>It does not block on entry; on exit it blocks until all child tasks have exited.</source>
          <target state="translated">它不会在进入时阻塞;在退出时阻塞,直到所有子任务退出。</target>
        </trans-unit>
        <trans-unit id="41ece27b44dd2fb5b5e3df97582a4f71e506eca1" translate="yes" xml:space="preserve">
          <source>It has no public constructor; instead, see &lt;a href=&quot;#trio.hazmat.current_trio_token&quot;&gt;&lt;code&gt;current_trio_token()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">它没有公共构造函数。相反，请参见&lt;a href=&quot;#trio.hazmat.current_trio_token&quot;&gt; &lt;code&gt;current_trio_token()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="447673e9dd692338c50de7bb68089f9e3af415fe" translate="yes" xml:space="preserve">
          <source>It lets the kernel pick a random open port, so your test suite doesn&amp;rsquo;t depend on any particular port being open.</source>
          <target state="translated">它允许内核选择一个随机的开放端口，因此您的测试套件不依赖于任何特定的开放端口。</target>
        </trans-unit>
        <trans-unit id="633fa68ba8c3421538913d615267233a7c6773ae" translate="yes" xml:space="preserve">
          <source>It lets you re-enter the Trio run loop from external threads or signal handlers. This is the low-level primitive that &lt;a href=&quot;reference-core#module-trio.to_thread&quot;&gt;&lt;code&gt;trio.to_thread()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-core#module-trio.from_thread&quot;&gt;&lt;code&gt;trio.from_thread&lt;/code&gt;&lt;/a&gt; use to communicate with worker threads, that &lt;a href=&quot;reference-io#trio.open_signal_receiver&quot;&gt;&lt;code&gt;trio.open_signal_receiver&lt;/code&gt;&lt;/a&gt; uses to receive notifications about signals, and so forth.</source>
          <target state="translated">它使您可以从外部线程或信号处理程序重新进入Trio运行循环。这是低级别的原语&lt;a href=&quot;reference-core#module-trio.to_thread&quot;&gt; &lt;code&gt;trio.to_thread()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;reference-core#module-trio.from_thread&quot;&gt; &lt;code&gt;trio.from_thread&lt;/code&gt; &lt;/a&gt;使用与工作线程进行通信，即&lt;a href=&quot;reference-io#trio.open_signal_receiver&quot;&gt; &lt;code&gt;trio.open_signal_receiver&lt;/code&gt; &lt;/a&gt;用途接收有关信号通知，等等。</target>
        </trans-unit>
        <trans-unit id="04dd56709d7215046123e0d08943911499806dfe" translate="yes" xml:space="preserve">
          <source>It may still be some time before it actually runs, if there are other runnable tasks ahead of it.</source>
          <target state="translated">如果前面还有其他可运行的任务,可能还需要一段时间才能真正运行。</target>
        </trans-unit>
        <trans-unit id="cdf4f355598208394d057b6e9e1b696ccd36f2db" translate="yes" xml:space="preserve">
          <source>It should attempt to clean up any state associated with this call, and in particular, arrange that &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; will &lt;em&gt;not&lt;/em&gt; be called later. If (and only if!) it is successful, then it should return &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt;, in which case the task will automatically be rescheduled with an appropriate &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">它应该尝试清理与此呼叫相关的任何状态，尤其是安排&lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt;将&lt;em&gt;不会&lt;/em&gt;被以后调用。如果成功（且仅当成功！），则应返回&lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt;，在这种情况下，任务将自动重新安排，并显示适当的&lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="84a6d66c512d9418dc7fbafea6c57006dc4ab36a" translate="yes" xml:space="preserve">
          <source>It sometimes happens that you want to connect to an HTTPS server, but you have to go through a web proxy&amp;hellip; and the proxy also uses HTTPS. So you end up having to do &lt;a href=&quot;https://daniel.haxx.se/blog/2016/11/26/https-proxy-with-curl/&quot;&gt;SSL-on-top-of-SSL&lt;/a&gt;. In Trio this is trivial &amp;ndash; just wrap your first &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; in a second &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">有时会发生您想要连接到HTTPS服务器的情况，但是您必须通过Web代理&amp;hellip;并且代理也使用HTTPS。因此，您最终不得不执行&lt;a href=&quot;https://daniel.haxx.se/blog/2016/11/26/https-proxy-with-curl/&quot;&gt;SSL-on-top-of-SSL&lt;/a&gt;。在Trio中，这很简单&amp;ndash;只需将您的第一个&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;包装在第二个&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 中&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="15180ba1a972d7f41d05f1bcb1b11159fd06fdaf" translate="yes" xml:space="preserve">
          <source>It uses the Listener object to find out which port was picked, so it can connect to the right place.</source>
          <target state="translated">它使用Listener对象找出被选取的端口,从而可以连接到正确的地方。</target>
        </trans-unit>
        <trans-unit id="8f96f61f491e94e6eed579393e73c5c30394e987" translate="yes" xml:space="preserve">
          <source>It waits for the server to be accepting connections on that port before &lt;code&gt;start&lt;/code&gt; returns, so there&amp;rsquo;s no race condition where the incoming connection arrives before the server is ready.</source>
          <target state="translated">在 &lt;code&gt;start&lt;/code&gt; 返回之前，它等待服务器接受该端口上的连接，因此在服务器准备就绪之前，进入连接到达之前不会出现竞争情况。</target>
        </trans-unit>
        <trans-unit id="3e4aef67556653c2e10c9ddc35f43ebcf2681e23" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a point where Trio checks for cancellation. For example, if the code that called your function set a timeout, and that timeout has expired, then the next time your function executes a checkpoint Trio will raise a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception. See &lt;a href=&quot;#cancellation&quot;&gt;Cancellation and timeouts&lt;/a&gt; below for more details.</source>
          <target state="translated">这是Trio检查取消的地方。例如，如果调用您的函数的代码设置了一个超时，并且该超时已过期，则下次函数执行检查点Trio时，将引发&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;异常。有关更多详细信息，请参见下面的&lt;a href=&quot;#cancellation&quot;&gt;取消和超时&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="41d67c32934a3fdf70e308bc3ec0237ebb3a5908" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a point where the Trio scheduler checks its scheduling policy to see if it&amp;rsquo;s a good time to switch to another task, and potentially does so. (Currently, this check is very simple: the scheduler always switches at every checkpoint. But &lt;a href=&quot;https://github.com/python-trio/trio/issues/32&quot;&gt;this might change in the future&lt;/a&gt;.)</source>
          <target state="translated">这是Trio调度程序检查其调度策略以查看是否是时候切换到另一个任务的好时机，并且有可能这样做。（当前，此检查非常简单：调度程序始终在每个检查点切换。但是&lt;a href=&quot;https://github.com/python-trio/trio/issues/32&quot;&gt;将来可能会改变&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="9feb70da8199f87a0468305b1613eb72121082b8" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also important in any long-running code to make sure that you regularly check for cancellation, because otherwise timeouts won&amp;rsquo;t work! This happens implicitly every time you call a cancellable operation; see &lt;a href=&quot;#cancellable-primitives&quot;&gt;below&lt;/a&gt; for details. If you have a task that has to do a lot of work without any I/O, then you can use &lt;code&gt;await sleep(0)&lt;/code&gt; to insert an explicit cancel+schedule point.</source>
          <target state="translated">在任何长时间运行的代码中，确保定期检查取消也很重要，因为否则超时将不起作用！每当您调用可取消的操作时，就会隐式发生。有关详情，请参见&lt;a href=&quot;#cancellable-primitives&quot;&gt;下文&lt;/a&gt;。如果您的任务必须执行很多工作而没有任何I / O，则可以使用 &lt;code&gt;await sleep(0)&lt;/code&gt; 插入一个显式的cancel + schedule点。</target>
        </trans-unit>
        <trans-unit id="3158edb2cb07aefc306e4b70006fb6942ffbee20" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible to check what the current effective deadline is, which is sometimes useful:</source>
          <target state="translated">也可以检查当前的有效截止日期是什么，有时很有用：</target>
        </trans-unit>
        <trans-unit id="028b2f8f16c5b9e63ae61fb6e6dada307141004f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s even possible for a fixed-size policy to cause unexpected &lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;deadlocks&lt;/a&gt;. Imagine a situation where we have two different types of blocking jobs that you want to run in the thread pool, type A and type B. Type A is pretty simple: it just runs and completes pretty quickly. But type B is more complicated: it has to stop in the middle and wait for some other work to finish, and that other work includes running a type A job. Now, suppose you submit N jobs of type B to the pool. They all start running, and then eventually end up submitting one or more jobs of type A. But since every thread in our pool is already busy, the type A jobs don&amp;rsquo;t actually start running &amp;ndash; they just sit in a queue waiting for the type B jobs to finish. But the type B jobs will never finish, because they&amp;rsquo;re waiting for the type A jobs. Our system has deadlocked. The ideal solution to this problem is to avoid having type B jobs in the first place &amp;ndash; generally it&amp;rsquo;s better to keep complex synchronization logic in the main Trio thread. But if you can&amp;rsquo;t do that, then you need a custom thread allocation policy that tracks separate limits for different types of jobs, and make it impossible for type B jobs to fill up all the slots that type A jobs need to run.</source>
          <target state="translated">固定大小的策略甚至可能导致意外的&lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;死锁&lt;/a&gt;。想象一下这样一种情况，我们要在线程池中运行两种不同类型的阻塞作业，即类型A和类型B。类型A非常简单：它运行并很快完成。但是类型B更为复杂：它必须停在中间并等待其他工作完成，而其他工作包括运行类型A作业。现在，假设您将N个B型作业提交到池中。它们都开始运行，然后最终提交一个或多个A类型的作业。但是由于池中的每个线程都已经繁忙，所以A类型的作业实际上并没有开始运行-他们只是坐在队列中等待B型作业完成。但是B型作业将永远不会完成，因为它们正在等待A型作业。我们的系统陷入僵局。解决此问题的理想方法是首先避免B型作业-通常最好在主Trio线程中保留复杂的同步逻辑。但是，如果您不能这样做，则需要一个自定义线程分配策略，该策略可以跟踪不同类型作业的单独限制，并使B型作业无法填充A型作业需要运行的所有插槽。</target>
        </trans-unit>
        <trans-unit id="afebfc9278bc2aa8347dcf570a97d23e86487e4e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s main use is to represent the situation when multiple child tasks all raise errors &amp;ldquo;in parallel&amp;rdquo;.</source>
          <target state="translated">它的主要用途是表示多个子任务都&amp;ldquo;并行&amp;rdquo;引发错误的情况。</target>
        </trans-unit>
        <trans-unit id="26f9b89089d0869162c76d5126491f1513bd67d7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to pass a nursery object into another task, which allows that task to start new child tasks in the first task&amp;rsquo;s nursery.</source>
          <target state="translated">可以将托儿所对象传递到另一个任务，这使该任务可以在第一个任务的托儿所中启动新的子任务。</target>
        </trans-unit>
        <trans-unit id="bfb0a395eef8d10797750c4bc8c7869ddcde8e1a" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s surprisingly easy to think that one&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection is enabled when it isn&amp;rsquo;t, or vice-versa. This function tells you what Trio thinks of the matter, which makes it useful for &lt;code&gt;assert&lt;/code&gt;s and unit tests.</source>
          <target state="translated">令人惊讶的是，很容易想到未启用它的&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt;保护，反之亦然。该函数告诉您Trio对问题的看法，这对于 &lt;code&gt;assert&lt;/code&gt; 和单元测试很有用。</target>
        </trans-unit>
        <trans-unit id="0d15b7a76653351f46b83405a4b54f98735b9042" translate="yes" xml:space="preserve">
          <source>Its public members are mostly useful for introspection and debugging:</source>
          <target state="translated">其公共成员主要用于反省和调试。</target>
        </trans-unit>
        <trans-unit id="545be0d53d794aaf39339209b55c20d210fc586f" translate="yes" xml:space="preserve">
          <source>Joining the team</source>
          <target state="translated">加入团队</target>
        </trans-unit>
        <trans-unit id="7673cd582fda3b7f7b13b3b20adaee67d3277fe9" translate="yes" xml:space="preserve">
          <source>Just make sure that you don&amp;rsquo;t write:</source>
          <target state="translated">只要确保您不写：</target>
        </trans-unit>
        <trans-unit id="a5d5b5c6bfe7553575cde5418f08d509d5536896" translate="yes" xml:space="preserve">
          <source>Kqueue-specific API</source>
          <target state="translated">Kqueue专用API</target>
        </trans-unit>
        <trans-unit id="d9fa2d2f6148e9b5ccb844620248db405f8fae9c" translate="yes" xml:space="preserve">
          <source>License: MIT or Apache 2, your choice</source>
          <target state="translated">许可证:麻省理工学院或Apache 2,你可以选择</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="1c6fb693fc4f098795743e41d419b3149fbcfbfb" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#trio.Nursery.start_soon&quot;&gt;&lt;code&gt;start_soon()&lt;/code&gt;&lt;/a&gt;, but blocks until the new task has finished initializing itself, and optionally returns some information from it.</source>
          <target state="translated">像&lt;a href=&quot;#trio.Nursery.start_soon&quot;&gt; &lt;code&gt;start_soon()&lt;/code&gt; &lt;/a&gt;，但块，直到新的任务已经完成初始化本身，以及可选返回从它的一些信息。</target>
        </trans-unit>
        <trans-unit id="5d6aaff931158c5ba7e26961a9b89a7d40bfe5ba" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.chmod&quot;&gt;&lt;code&gt;chmod()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.chmod&quot;&gt; &lt;code&gt;chmod()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="3ba838f0e35e06c2fb726a07ae29793e339bfe10" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.cwd&quot;&gt;&lt;code&gt;cwd()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.cwd&quot;&gt; &lt;code&gt;cwd()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="8c5a9d23abb5f6ad444cc24b04b27fe9e10a9442" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.exists&quot;&gt;&lt;code&gt;exists()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">像&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.exists&quot;&gt; &lt;code&gt;exists()&lt;/code&gt; &lt;/a&gt;，但是异步。</target>
        </trans-unit>
        <trans-unit id="8029effe0016a68af627078e548169d8a3b664b6" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.expanduser&quot;&gt;&lt;code&gt;expanduser()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.expanduser&quot;&gt; &lt;code&gt;expanduser()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="b0ea04f9f1e4f38a25764ce18a995446b4f28854" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob&quot;&gt;&lt;code&gt;glob()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">像&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob&quot;&gt; &lt;code&gt;glob()&lt;/code&gt; 一样&lt;/a&gt;，但是异步。</target>
        </trans-unit>
        <trans-unit id="6bd3ff84b863acbc6c9cce99ac69c33bd2909786" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.group&quot;&gt;&lt;code&gt;group()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.group&quot;&gt; &lt;code&gt;group()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="3c7cc416a3a8bb593ea6e8e88d3e887928347553" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.home&quot;&gt;&lt;code&gt;home()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.home&quot;&gt; &lt;code&gt;home()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="728cd83a8211f6734ef960185330051b8c20ab07" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_block_device&quot;&gt;&lt;code&gt;is_block_device()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_block_device&quot;&gt; &lt;code&gt;is_block_device()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="8357198911fe8c7b4765505acc1d51e94d363fe8" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_char_device&quot;&gt;&lt;code&gt;is_char_device()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_char_device&quot;&gt; &lt;code&gt;is_char_device()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="ed5693661e601d1afa38f136a0d4a3de1c725a7c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_dir&quot;&gt;&lt;code&gt;is_dir()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_dir&quot;&gt; &lt;code&gt;is_dir()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="6bf2ce402b5a06571ec3de8e0f0931b96a01a498" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_fifo&quot;&gt;&lt;code&gt;is_fifo()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_fifo&quot;&gt; &lt;code&gt;is_fifo()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="88810a7083f1ac5a369fdea2c965c22ad7623a35" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt;&lt;code&gt;is_file()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt; &lt;code&gt;is_file()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="61d10cc589f2610067e2e12e0e6fb88489b0ada2" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_socket&quot;&gt;&lt;code&gt;is_socket()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_socket&quot;&gt; &lt;code&gt;is_socket()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="ea98fc1e541c2149ddd3990468d1ad6ebb4ac1b4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_symlink&quot;&gt;&lt;code&gt;is_symlink()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_symlink&quot;&gt; &lt;code&gt;is_symlink()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="8a36e3cfed8e29bbe795e9ccce0d0fbf0b367ad5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.iterdir&quot;&gt;&lt;code&gt;pathlib.Path.iterdir()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.iterdir&quot;&gt; &lt;code&gt;pathlib.Path.iterdir()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="10fec790c4c6e2567f23d61565f736a38ac6732a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.lchmod&quot;&gt;&lt;code&gt;lchmod()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.lchmod&quot;&gt; &lt;code&gt;lchmod()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="27baac762d9c7f298a4f06767b1d507901aed386" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.lstat&quot;&gt;&lt;code&gt;lstat()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.lstat&quot;&gt; &lt;code&gt;lstat()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="0bd8091a0b0ceaf877772076df583a166ddd961c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir&quot;&gt;&lt;code&gt;mkdir()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir&quot;&gt; &lt;code&gt;mkdir()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="81ed714fc7a307ba54353248fdcbfcfa493b3ed0" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.owner&quot;&gt;&lt;code&gt;owner()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.owner&quot;&gt; &lt;code&gt;owner()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="9da40bbd79ff6bce0630d88aeb0d8aa86ff563c9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_bytes&quot;&gt;&lt;code&gt;read_bytes()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_bytes&quot;&gt; &lt;code&gt;read_bytes()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="05643660a056d15b3298760145d0de764a98bdc4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_text&quot;&gt;&lt;code&gt;read_text()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_text&quot;&gt; &lt;code&gt;read_text()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="f2ccca9c18dd36f4ae76b849609b73b1f637edf9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rename&quot;&gt;&lt;code&gt;rename()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">像&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rename&quot;&gt; &lt;code&gt;rename()&lt;/code&gt; 一样&lt;/a&gt;，但是异步。</target>
        </trans-unit>
        <trans-unit id="76951f8bac108e58977f3a4e8acfa6286eb8d22d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.replace&quot;&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.replace&quot;&gt; &lt;code&gt;replace()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="c3055a464134a4216721f8a866ac651e4570f06f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.resolve&quot;&gt;&lt;code&gt;resolve()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.resolve&quot;&gt; &lt;code&gt;resolve()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="582d833e4f101ac47d1717f59890a75fb92e760c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rglob&quot;&gt;&lt;code&gt;rglob()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rglob&quot;&gt; &lt;code&gt;rglob()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="fb2b385994122d22fd4d232559e18a11a60ac4e4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rmdir&quot;&gt;&lt;code&gt;rmdir()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rmdir&quot;&gt; &lt;code&gt;rmdir()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="9f63131435769ee3fb708892ef6a3216170a46f9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.samefile&quot;&gt;&lt;code&gt;samefile()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.samefile&quot;&gt; &lt;code&gt;samefile()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="aca6058c180917f2d39ac469babfe5a04db23516" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.stat&quot;&gt;&lt;code&gt;stat()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.stat&quot;&gt; &lt;code&gt;stat()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="7c17e79bf844528efb02f89a4dda1d3db03d70d8" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.symlink_to&quot;&gt;&lt;code&gt;symlink_to()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.symlink_to&quot;&gt; &lt;code&gt;symlink_to()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="f22e90e30bbe4e59bff5e37bbcb40e20951b2f52" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.touch&quot;&gt;&lt;code&gt;touch()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.touch&quot;&gt; &lt;code&gt;touch()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="58c2987df5b3af271a9c8db4100daec2f09bc978" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.unlink&quot;&gt;&lt;code&gt;unlink()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">像&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.unlink&quot;&gt; &lt;code&gt;unlink()&lt;/code&gt; 一样&lt;/a&gt;，但是异步。</target>
        </trans-unit>
        <trans-unit id="80edc61fe623d63b6acb59ba26df15585ede97f1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes&quot;&gt;&lt;code&gt;write_bytes()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes&quot;&gt; &lt;code&gt;write_bytes()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="1a4a32aa0a4740a573dfbedc612a5d244880ac5d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text&quot;&gt;&lt;code&gt;write_text()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text&quot;&gt; &lt;code&gt;write_text()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="9d2e0e0cca76297df2e87075fa4119c9402e1264" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.fromfd&quot;&gt;&lt;code&gt;socket.fromfd()&lt;/code&gt;&lt;/a&gt;, but returns a Trio socket object.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.fromfd&quot;&gt; &lt;code&gt;socket.fromfd()&lt;/code&gt; &lt;/a&gt;，但返回Trio套接字对象。</target>
        </trans-unit>
        <trans-unit id="331a6322c874ec83d06c6d08fb611b5f4faa1156" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.fromshare&quot;&gt;&lt;code&gt;socket.fromshare()&lt;/code&gt;&lt;/a&gt;, but returns a Trio socket object.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.fromshare&quot;&gt; &lt;code&gt;socket.fromshare()&lt;/code&gt; &lt;/a&gt;，但返回Trio套接字对象。</target>
        </trans-unit>
        <trans-unit id="e2dc4e28850f2e365df27694052bb1e0b1746a9c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getprotobyname&quot;&gt;&lt;code&gt;socket.getprotobyname()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">类似于&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getprotobyname&quot;&gt; &lt;code&gt;socket.getprotobyname()&lt;/code&gt; &lt;/a&gt;，但异步。</target>
        </trans-unit>
        <trans-unit id="de36e1033225ba39f47cc4b92c54ebfc92f0e4ce" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt;&lt;code&gt;socket.socketpair()&lt;/code&gt;&lt;/a&gt;, but returns a pair of Trio socket objects.</source>
          <target state="translated">与&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt; &lt;code&gt;socket.socketpair()&lt;/code&gt; &lt;/a&gt;类似，但返回一对Trio套接字对象。</target>
        </trans-unit>
        <trans-unit id="61c8f4b41ffadae4dad59039c078152bc2597395" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt;, but if there&amp;rsquo;s nothing ready to receive, raises &lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; instead of blocking.</source>
          <target state="translated">类似于&lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt;，但是如果没有准备好接收，则引发&lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; &lt;/a&gt;而不是阻塞。</target>
        </trans-unit>
        <trans-unit id="ec539be4b605bbd35ef9da29c0dc79d1cdf0bd6e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;, but if the channel&amp;rsquo;s buffer is full, raises &lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; instead of blocking.</source>
          <target state="translated">与&lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;相似，但是如果通道的缓冲区已满，则引发&lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; &lt;/a&gt;而不是阻塞。</target>
        </trans-unit>
        <trans-unit id="243773033574d612f4454d84b3c941029d2df11a" translate="yes" xml:space="preserve">
          <source>Listen for incoming TCP connections, and for each one start a task running &lt;code&gt;handler(stream)&lt;/code&gt;.</source>
          <target state="translated">侦听传入的TCP连接，并为每个连接启动一个运行 &lt;code&gt;handler(stream)&lt;/code&gt; 的任务。</target>
        </trans-unit>
        <trans-unit id="5d6bf85b52b590445a244abd378949eb3d59be0a" translate="yes" xml:space="preserve">
          <source>Listen for incoming connections on &lt;code&gt;listeners&lt;/code&gt;, and for each one start a task running &lt;code&gt;handler(stream)&lt;/code&gt;.</source>
          <target state="translated">侦听侦听器上的传入连接，并为每个 &lt;code&gt;listeners&lt;/code&gt; 启动一个运行 &lt;code&gt;handler(stream)&lt;/code&gt; 的任务。</target>
        </trans-unit>
        <trans-unit id="3f93b003cac3bafe43f93f4a3ced9aa90bc77fce" translate="yes" xml:space="preserve">
          <source>Listeners don&amp;rsquo;t generally raise &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;BrokenResourceError&lt;/code&gt;&lt;/a&gt;, because for listeners there is no general condition of &amp;ldquo;the network/remote peer broke the connection&amp;rdquo; that can be handled in a generic way, like there is for streams. Other errors &lt;em&gt;can&lt;/em&gt; occur and be raised from &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; &amp;ndash; for example, if you run out of file descriptors then you might get an &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; with its errno set to &lt;code&gt;EMFILE&lt;/code&gt;.</source>
          <target state="translated">侦听器通常不会引发&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;BrokenResourceError&lt;/code&gt; &lt;/a&gt;，因为对于侦听器而言，没有&amp;ldquo;网络/远程对等体断开连接&amp;rdquo;的一般条件可以通过通用方式来处理，就像流一样。&lt;em&gt;可能&lt;/em&gt;发生其他错误并从&lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt;引发该错误&amp;ndash;例如，如果用尽了文件描述符，则可能会收到一个&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;，其errno设置为 &lt;code&gt;EMFILE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fbdd9c2573faeae1c0dfd16bc50c0374a0de2ca" translate="yes" xml:space="preserve">
          <source>Logs the error to the standard library logger &lt;code&gt;trio.serve_listeners&lt;/code&gt; (level = ERROR, with exception information included). By default this causes it to be printed to stderr.</source>
          <target state="translated">将错误记录到标准库记录器 &lt;code&gt;trio.serve_listeners&lt;/code&gt; （级别= ERROR，包括异常信息）。默认情况下，这会将其打印到stderr。</target>
        </trans-unit>
        <trans-unit id="97f4c6bc248313454e7e7ff078c667720978c27a" translate="yes" xml:space="preserve">
          <source>Look up a name given a numeric address.</source>
          <target state="translated">查询一个给定数字地址的名字。</target>
        </trans-unit>
        <trans-unit id="4abb92fa47a0d5605410443253231d75eb0f04a0" translate="yes" xml:space="preserve">
          <source>Look up a numeric address given a name.</source>
          <target state="translated">查找一个给定名称的数字地址。</target>
        </trans-unit>
        <trans-unit id="1259ecea5b81acd627020537220f81aca7783275" translate="yes" xml:space="preserve">
          <source>Look up a protocol number by name. (Rarely used.)</source>
          <target state="translated">按名称查询协议号。(很少使用。)</target>
        </trans-unit>
        <trans-unit id="0392a16047d2b6a75f0f5ee3bfcd028004b4120c" translate="yes" xml:space="preserve">
          <source>Looking at this, you might wonder how you can tell whether the inner block timed out &amp;ndash; perhaps you want to do something different, like try a fallback procedure or report a failure to our caller. To make this easier, &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt;&amp;acute;s &lt;code&gt;__enter__&lt;/code&gt; function returns an object representing this cancel scope, which we can use to check whether this scope caught a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception:</source>
          <target state="translated">看着这个，您可能想知道如何判断内部块是否超时&amp;ndash;也许您想做一些不同的事情，例如尝试回退过程或向调用方报告失败。为了&lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt;，move_on_after（）的 &lt;code&gt;__enter__&lt;/code&gt; 函数返回一个表示取消范围的对象，我们可以用来检查该范围是否捕获了&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;异常：</target>
        </trans-unit>
        <trans-unit id="6ef282847417f9b8a3de2e592804abf1d9e73760" translate="yes" xml:space="preserve">
          <source>Low-level I/O primitives</source>
          <target state="translated">低级I/O基元</target>
        </trans-unit>
        <trans-unit id="9809ec59234a7fd4fad0458de06fb6ceef59377a" translate="yes" xml:space="preserve">
          <source>Low-level blocking</source>
          <target state="translated">低级阻断</target>
        </trans-unit>
        <trans-unit id="26b0d3fb85c1a77979b58fc0dcdac52cde7cf583" translate="yes" xml:space="preserve">
          <source>Low-level checkpoint functions</source>
          <target state="translated">低级检查点功能</target>
        </trans-unit>
        <trans-unit id="83e3f9dcd236493cb7f1a761c41a62a9d9243115" translate="yes" xml:space="preserve">
          <source>Low-level networking with &lt;a href=&quot;#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; &lt;/a&gt;进行低级联网</target>
        </trans-unit>
        <trans-unit id="a9c1d4245e788744e95621301756e1256b668cc4" translate="yes" xml:space="preserve">
          <source>Low-level networking with &lt;code&gt;trio.socket&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;trio.socket&lt;/code&gt; 进行低级联网</target>
        </trans-unit>
        <trans-unit id="7a7080e23ec2bf698dbac21fef72095025b7bd60" translate="yes" xml:space="preserve">
          <source>Lower-level synchronization primitives</source>
          <target state="translated">低级同步基元</target>
        </trans-unit>
        <trans-unit id="64c3a5b776dfc9fed8c84912a5b25137610b3851" translate="yes" xml:space="preserve">
          <source>Maintainer Enforcement Process</source>
          <target state="translated">维护者执行程序</target>
        </trans-unit>
        <trans-unit id="32ff137c78a32d8e8b4e8c2e8ca701567f8320ff" translate="yes" xml:space="preserve">
          <source>Make a TLS-encrypted Connection to the given host and port over TCP.</source>
          <target state="translated">通过TCP对给定的主机和端口进行TLS加密连接。</target>
        </trans-unit>
        <trans-unit id="6577f5e216517f3a725c9bdbffa4833cc30cdf56" translate="yes" xml:space="preserve">
          <source>Managing issues</source>
          <target state="translated">管理问题</target>
        </trans-unit>
        <trans-unit id="874fe6380efcf8567cd3945da6538e701efad61f" translate="yes" xml:space="preserve">
          <source>Managing multiple producers and/or multiple consumers</source>
          <target state="translated">管理多个生产者和/或多个消费者</target>
        </trans-unit>
        <trans-unit id="ce4b94ac2fcd6838a8a9dde11f20624bdeb42a0c" translate="yes" xml:space="preserve">
          <source>Manually advance the clock by the given number of seconds.</source>
          <target state="translated">手动将时钟提前给定秒数。</target>
        </trans-unit>
        <trans-unit id="7589bf933d13f8bfdcd3193c9dc3896e3e03bbe5" translate="yes" xml:space="preserve">
          <source>Many people expect that switching to from synchronous file I/O to async file I/O will always make their program faster. This is not true! If we just look at total throughput, then async file I/O might be faster, slower, or about the same, and it depends in a complicated way on things like your exact patterns of disk access, or how much RAM you have. The main motivation for async file I/O is not to improve throughput, but to &lt;strong&gt;reduce the frequency of latency glitches.&lt;/strong&gt;</source>
          <target state="translated">许多人期望从同步文件I / O切换到异步文件I / O总是可以使他们的程序更快。这不是真的！如果仅查看总吞吐量，那么异步文件I / O可能更快，更慢或大致相同，并且它以复杂的方式取决于诸如磁盘访问模式或拥有多少RAM之类的事情。异步文件I / O的主要动机不是提高吞吐量，而是&lt;strong&gt;减少延迟故障的频率。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="14b7986ca23831901ae0b3efc4ed19e3339816a9" translate="yes" xml:space="preserve">
          <source>Marks this stream as closed, and then calls the &lt;a href=&quot;#trio.testing.MemorySendStream.close_hook&quot;&gt;&lt;code&gt;close_hook&lt;/code&gt;&lt;/a&gt; (if any).</source>
          <target state="translated">将此流标记为已关闭，然后调用&lt;a href=&quot;#trio.testing.MemorySendStream.close_hook&quot;&gt; &lt;code&gt;close_hook&lt;/code&gt; &lt;/a&gt;（如果有）。</target>
        </trans-unit>
        <trans-unit id="12cc69819eb175688379de996ddca98b1fee239a" translate="yes" xml:space="preserve">
          <source>Memory channels allow multiple tasks to call &lt;a href=&quot;#trio.MemoryReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; at the same time. The first task will get the first item sent, the second task will get the second item sent, and so on.</source>
          <target state="translated">内存通道允许多个任务同时调用&lt;a href=&quot;#trio.MemoryReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt;。第一个任务将获取发送的第一项，第二个任务将获取发送的第二项，依此类推。</target>
        </trans-unit>
        <trans-unit id="9381ec63c31149e49413a93c0bb86c8b8276149d" translate="yes" xml:space="preserve">
          <source>Memory channels allow multiple tasks to call &lt;a href=&quot;#trio.MemorySendChannel.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; at the same time.</source>
          <target state="translated">内存通道允许多个任务同时调用&lt;a href=&quot;#trio.MemorySendChannel.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ebacba51b60d5a007ce59beb654e883261ff033" translate="yes" xml:space="preserve">
          <source>Memory channels are lightweight, cheap to allocate, and entirely in-memory. They don&amp;rsquo;t involve any operating-system resources, or any kind of serialization. They just pass Python objects directly between tasks (with a possible stop in an internal buffer along the way).</source>
          <target state="translated">内存通道重量轻，分配便宜且完全在内存中。它们不涉及任何操作系统资源或任何类型的序列化。它们只是在任务之间直接传递Python对象（可能会在过程中在内部缓冲区中停止）。</target>
        </trans-unit>
        <trans-unit id="3cb22c5e4eabc0e7d3ccf2b60e66f53421b63149" translate="yes" xml:space="preserve">
          <source>Module Index</source>
          <target state="translated">模块索引</target>
        </trans-unit>
        <trans-unit id="8d872704047e831df65df9aed5d46fc4c57e9bb3" translate="yes" xml:space="preserve">
          <source>Most errors coming from &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; are allowed to propagate out (crashing the server in the process). However, some errors &amp;ndash; those which indicate that the server is temporarily overloaded &amp;ndash; are handled specially. These are &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;s with one of the following errnos:</source>
          <target state="translated">大多数来自&lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; 的&lt;/a&gt;错误都可以传播出去（在此过程中使服务器崩溃）。但是，某些错误（表明服务器暂时超载的错误）会特别处理。这些是带有以下错误之一的&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a8cd11a5ccaa1971cc54179d399d4e54a3915836" translate="yes" xml:space="preserve">
          <source>Most libraries for concurrent programming let you start new child tasks (or threads, or whatever) willy-nilly, whenever and where-ever you feel like it. Trio is a bit different: you can&amp;rsquo;t start a child task unless you&amp;rsquo;re prepared to be a responsible parent. The way you demonstrate your responsibility is by creating a nursery:</source>
          <target state="translated">大多数用于并发编程的库使您可以随时随地启动新的子任务（或线程，或其他）。三重奏有些不同：除非您准备好成为负责任的父母，否则您无法启动子任务。您表现出责任的方式是创建一个苗圃：</target>
        </trans-unit>
        <trans-unit id="faa7a87e100ccbf148f4d32180dde3f6a74122cc" translate="yes" xml:space="preserve">
          <source>Most low-level operations in Trio provide a guarantee: if they raise &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt;, this means that they had no effect, so the system remains in a known state. This is &lt;strong&gt;not true&lt;/strong&gt; for &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;. If this operation raises &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt; (or any other exception for that matter), then it may have sent some, all, or none of the requested data, and there is no way to know which.</source>
          <target state="translated">Trio中的大多数低级操作提供了保证：如果它们引发了&lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; &lt;/a&gt;，则意味着它们没有作用，因此系统保持已知状态。这是&lt;strong&gt;不正确&lt;/strong&gt;的&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt;。如果此操作引发了&lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; &lt;/a&gt;（或与此有关的任何其他异常），则它可能已发送了一些，全部或没有请求的数据，并且无法知道哪个。</target>
        </trans-unit>
        <trans-unit id="93b72a6b4349c6293f75d57aad8d0127982f3ec5" translate="yes" xml:space="preserve">
          <source>Most users won&amp;rsquo;t need this, but it may be useful on cleanup paths where you can&amp;rsquo;t afford to block, or if you want to close a resource and don&amp;rsquo;t care about handling it gracefully. For example, if &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; encounters an error and cannot perform its own graceful close, then there&amp;rsquo;s no point in waiting to gracefully shut down the underlying transport either, so it calls &lt;code&gt;await
aclose_forcefully(self.transport_stream)&lt;/code&gt;.</source>
          <target state="translated">大多数用户不需要它，但是在您无法承受的清理路径上，或者您要关闭资源并且不关心优雅地处理它时，它可能很有用。例如，如果&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;遇到错误并且无法执行自己的正常关闭，那么也没有必要等待优雅地关闭基础传输，因此它调用 &lt;code&gt;await aclose_forcefully(self.transport_stream)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="263333d23c256397b1932a66d3b96bed36f57e27" translate="yes" xml:space="preserve">
          <source>Move all parked tasks from one &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; object to another.</source>
          <target state="translated">将所有停放的任务从一个&lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt;对象移动到另一个。</target>
        </trans-unit>
        <trans-unit id="d7821f30476ccc057b781233fe6a409ab7b1f821" translate="yes" xml:space="preserve">
          <source>Move parked tasks from one &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; object to another.</source>
          <target state="translated">将停放的任务从一个&lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt;对象移动到另一个。</target>
        </trans-unit>
        <trans-unit id="8bad03d4f386e821713ff697a351c0c7fddba714" translate="yes" xml:space="preserve">
          <source>Networking with Trio</source>
          <target state="translated">与Trio交流</target>
        </trans-unit>
        <trans-unit id="5ef93032cd6cb3e1deb49d648d00e034030e5fed" translate="yes" xml:space="preserve">
          <source>Normally, a Trio task doesn&amp;rsquo;t exit until its coroutine object exits. When you call this function, Trio acts like the coroutine object just exited and the task terminates with the given outcome. This is useful if you want to permanently switch the coroutine object over to a different coroutine runner.</source>
          <target state="translated">通常，Trio任务直到其协程对象退出后才会退出。当您调用此函数时，Trio的行为就像刚退出的协程对象一样，任务以给定的结果终止。如果您想将协程对象永久切换到其他协程运行器，这将很有用。</target>
        </trans-unit>
        <trans-unit id="498e98b1248914319c5ba185502949174d8f34bb" translate="yes" xml:space="preserve">
          <source>Normally, in Python, only one thing happens at a time, which means that only one thing can wrong at a time. Trio has no such limitation. Consider code like:</source>
          <target state="translated">通常情况下,在Python中,一次只能发生一件事,也就是说,一次只能错一件事。Trio没有这样的限制。考虑这样的代码。</target>
        </trans-unit>
        <trans-unit id="83d1bdb0177297f4b3942b5656e2acef994da375" translate="yes" xml:space="preserve">
          <source>Not constructed directly, use &lt;a href=&quot;#trio.open_nursery&quot;&gt;&lt;code&gt;open_nursery&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">不是直接构造的，而是使用&lt;a href=&quot;#trio.open_nursery&quot;&gt; &lt;code&gt;open_nursery&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eadd2611bf484c2f1c8acb474416269466aa9dc7" translate="yes" xml:space="preserve">
          <source>Not implemented yet!</source>
          <target state="translated">尚未实施!</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="c005918e9288af566376fbbfea029bf8b6679638" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;closed&amp;rdquo; here means that &lt;em&gt;your&lt;/em&gt; code closed the resource, generally by calling a method with a name like &lt;code&gt;close&lt;/code&gt; or &lt;code&gt;aclose&lt;/code&gt;, or by exiting a context manager. If a problem arises elsewhere &amp;ndash; for example, because of a network failure, or because a remote peer closed their end of a connection &amp;ndash; then that should be indicated by a different exception class, like &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt;&lt;code&gt;BrokenResourceError&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; subclass.</source>
          <target state="translated">请注意，此处的&amp;ldquo;关闭&amp;rdquo;意味着&lt;em&gt;您的&lt;/em&gt;代码通常通过调用名称如 &lt;code&gt;close&lt;/code&gt; 或 &lt;code&gt;aclose&lt;/code&gt; 的方法或退出上下文管理器来关闭资源。如果在其他地方出现问题（例如，由于网络故障或由于远程对等体关闭了连接的末端），则应由其他异常类（例如&lt;a href=&quot;#trio.BrokenResourceError&quot;&gt; &lt;code&gt;BrokenResourceError&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt;子类）来指示。</target>
        </trans-unit>
        <trans-unit id="e4c5fde44cdcbb0229d2ec83868918f591012895" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;cushion&lt;/code&gt; is measured in &lt;em&gt;real&lt;/em&gt; time, not the Trio clock time.</source>
          <target state="translated">请注意， &lt;code&gt;cushion&lt;/code&gt; 是&lt;em&gt;实时&lt;/em&gt;测量的，而不是Trio时钟时间。</target>
        </trans-unit>
        <trans-unit id="c2f474f246c27fafa3dfbf010e4d2f00c8ffe806" translate="yes" xml:space="preserve">
          <source>Note that for efficiency, the core run loop only checks for expired deadlines every once in a while. This means that in certain cases there may be a short delay between when the clock says the deadline should have expired, and when checkpoints start raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. This is a very obscure corner case that you&amp;rsquo;re unlikely to notice, but we document it for completeness. (If this &lt;em&gt;does&lt;/em&gt; cause problems for you, of course, then &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;we want to know!&lt;/a&gt;)</source>
          <target state="translated">请注意，为了提高效率，核心运行循环仅偶尔检查一次到期期限。这意味着，在某些情况下，从时钟说截止日期应该到期到检查点开始提出&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;之间，可能会有短暂的延迟。这是一个不太明显的特殊情况，您不太可能注意到，但为了完整起见我们将其记录在案。（当然，如果这&lt;em&gt;确实&lt;/em&gt;给您带来了问题，那么&lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;我们想知道！&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="a4da239427acde2c8d842bd9203aa10f330974e5" translate="yes" xml:space="preserve">
          <source>Note that if you leave the &lt;code&gt;with&lt;/code&gt; block while the iterator has unextracted signals still pending inside it, then they will be re-delivered using Python&amp;rsquo;s regular signal handling logic. This avoids a race condition when signals arrives just before we exit the &lt;code&gt;with&lt;/code&gt; block.</source>
          <target state="translated">请注意，如果在迭代器中仍有未提取的信号悬而未决的情况下离开 &lt;code&gt;with&lt;/code&gt; 块，则将使用Python的常规信号处理逻辑将其重新传递。当信号恰好在退出 &lt;code&gt;with&lt;/code&gt; 块之前到达时，这避免了竞争情况。</target>
        </trans-unit>
        <trans-unit id="712bd61d427cff2f726afa6001462d20b944b4f7" translate="yes" xml:space="preserve">
          <source>Note that it actually loads the whole directory list into memory immediately, during the initial call. (See &lt;a href=&quot;https://github.com/python-trio/trio/issues/501&quot;&gt;issue #501&lt;/a&gt; for discussion.)</source>
          <target state="translated">请注意，实际上是在初始调用期间立即将整个目录列表加载到内存中。（有关讨论，请参见&lt;a href=&quot;https://github.com/python-trio/trio/issues/501&quot;&gt;问题501。&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="18074fc1649e3851e18407e48fba948b511fbd36" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt; &amp;ldquo;takes ownership&amp;rdquo; of the given socket; closing the &lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt; will also close the socket.</source>
          <target state="translated">请注意，&lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt; &amp;ldquo;获得了&amp;rdquo;给定套接字的所有权；关闭&lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt;也会关闭套接字。</target>
        </trans-unit>
        <trans-unit id="2ad4e8916ad84553a99fb9d5ed08077c69f39ffa" translate="yes" xml:space="preserve">
          <source>Note that the scheduler has the option of ignoring this and continuing to run the current task if it decides this is appropriate (e.g. for increased efficiency).</source>
          <target state="translated">请注意,如果调度程序认为合适的话,它可以选择忽略这一点,继续运行当前的任务(例如为了提高效率)。</target>
        </trans-unit>
        <trans-unit id="a870766bee2cab11ad647d758a862b70449e3239" translate="yes" xml:space="preserve">
          <source>Note that these APIs are actually in &lt;a href=&quot;reference-io#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;trio.abc&lt;/code&gt;, but we document them here because they&amp;rsquo;re primarily intended for testing.</source>
          <target state="translated">请注意，这些API实际上位于&lt;a href=&quot;reference-io#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;trio.abc&lt;/code&gt; 中，但是我们在此处记录它们，因为它们主要用于测试。</target>
        </trans-unit>
        <trans-unit id="5f6717e388dfea4f31cd0847c699c3d8b947978c" translate="yes" xml:space="preserve">
          <source>Note that this function is async, and that it acts as a checkpoint, but unlike most async functions it cannot block indefinitely (at least, assuming the underlying resource object is correctly implemented).</source>
          <target state="translated">请注意,这个函数是异步的,它作为一个检查点,但与大多数异步函数不同的是,它不能无限期地阻塞(至少,假设底层资源对象被正确实现)。</target>
        </trans-unit>
        <trans-unit id="60263bbd81e421eab5c9b77a0bb97880024cfdea" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; an async function and you don&amp;rsquo;t use await when calling it. It sets up the new task, but then returns immediately, &lt;em&gt;before&lt;/em&gt; it has a chance to run. The new task won&amp;rsquo;t actually get a chance to do anything until some later point when you execute a checkpoint and the scheduler decides to run it. If you want to run a function and immediately wait for its result, then you don&amp;rsquo;t need a nursery; just use &lt;code&gt;await async_fn(*args)&lt;/code&gt;. If you want to wait for the task to initialize itself before continuing, see &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，这&lt;em&gt;不是&lt;/em&gt;异步函数，在调用它时不要使用await。它设置了新任务，但是&lt;em&gt;在&lt;/em&gt;有机会运行&lt;em&gt;之前&lt;/em&gt;立即返回。直到稍后执行检查点并且调度程序决定运行它时，新任务才真正有机会执行任何操作。如果您想运行一个函数并立即等待其结果，则不需要托儿所。只需使用 &lt;code&gt;await async_fn(*args)&lt;/code&gt; 。如果要等待任务初始化自身然后再继续，请参见&lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e596896727edc23e1453160d700101f2cccdb2ec" translate="yes" xml:space="preserve">
          <source>Note that this is a single 30 second timeout for the entire body of the &lt;code&gt;with&lt;/code&gt; statement. This is different from what you might have seen with other Python libraries, where timeouts often refer to something &lt;a href=&quot;http://docs.python-requests.org/en/master/user/quickstart/#timeouts&quot;&gt;more complicated&lt;/a&gt;. We think this way is easier to reason about.</source>
          <target state="translated">请注意，这是整个 &lt;code&gt;with&lt;/code&gt; 语句的30秒超时。这与您在其他Python库中可能看到的内容不同，在其他Python库中，超时通常表示&lt;a href=&quot;http://docs.python-requests.org/en/master/user/quickstart/#timeouts&quot;&gt;更复杂的内容&lt;/a&gt;。我们认为这种方式更容易推断。</target>
        </trans-unit>
        <trans-unit id="d90917fbab7be987474e0660b08f23d296f2c615" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt;, this does not take a &lt;code&gt;fileno=&lt;/code&gt; argument. If a &lt;code&gt;fileno=&lt;/code&gt; is specified, then &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt; returns a regular Trio socket object instead of calling this method.</source>
          <target state="translated">请注意，与&lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt;不同，此操作没有 &lt;code&gt;fileno=&lt;/code&gt; 参数。如果指定了 &lt;code&gt;fileno=&lt;/code&gt; ，则&lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt;返回常规的Trio套接字对象，而不是调用此方法。</target>
        </trans-unit>
        <trans-unit id="ee9f1e467c615fa7fe75945105dc0ba02d240448" translate="yes" xml:space="preserve">
          <source>Note that what matters here is the scopes that were active when &lt;a href=&quot;#trio.open_nursery&quot;&gt;&lt;code&gt;open_nursery()&lt;/code&gt;&lt;/a&gt; was called, &lt;em&gt;not&lt;/em&gt; the scopes active when &lt;code&gt;start_soon&lt;/code&gt; is called. So for example, the timeout block below does nothing at all:</source>
          <target state="translated">请注意，这里重要的是调用&lt;a href=&quot;#trio.open_nursery&quot;&gt; &lt;code&gt;open_nursery()&lt;/code&gt; &lt;/a&gt;时处于活动状态的作用域，而&lt;em&gt;不是&lt;/em&gt;调用 &lt;code&gt;start_soon&lt;/code&gt; 时处于活动状态的作用域。因此，例如，下面的超时块什么都不做：</target>
        </trans-unit>
        <trans-unit id="c0dd16afc9aa65302712b5fe96789de465a014cf" translate="yes" xml:space="preserve">
          <source>Note that you&amp;rsquo;ll need to save the current &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object to later resume; you can retrieve it with &lt;a href=&quot;#trio.hazmat.current_task&quot;&gt;&lt;code&gt;current_task()&lt;/code&gt;&lt;/a&gt;. You can also use this &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object to retrieve the coroutine object &amp;ndash; see &lt;a href=&quot;#trio.hazmat.Task.coro&quot;&gt;&lt;code&gt;Task.coro&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，您需要保存当前的&lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;对象，以便以后恢复。您可以使用&lt;a href=&quot;#trio.hazmat.current_task&quot;&gt; &lt;code&gt;current_task()&lt;/code&gt; &lt;/a&gt;检索它。您也可以使用此&lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;对象检索协程对象&amp;ndash;请参阅&lt;a href=&quot;#trio.hazmat.Task.coro&quot;&gt; &lt;code&gt;Task.coro&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd0ce03c8decb818ff508ff8fee1d404e44208e2" translate="yes" xml:space="preserve">
          <source>Notice a small trick we use: the code in &lt;code&gt;main&lt;/code&gt; creates clone objects to pass into all the child tasks, and then closes the original objects using &lt;code&gt;async with&lt;/code&gt;. Another option is to pass clones into all-but-one of the child tasks, and then pass the original object into the last task, like:</source>
          <target state="translated">请注意我们使用的一个小技巧： &lt;code&gt;main&lt;/code&gt; 中的代码创建克隆对象以传递到所有子任务中，然后使用 &lt;code&gt;async with&lt;/code&gt; 关闭原始对象。另一种选择是将克隆传递给所有子任务中的一个，然后将其传递给最后一个任务，例如：</target>
        </trans-unit>
        <trans-unit id="5d6fc1814d50a5f137f3e0720ddabca9f27c56cd" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;server&lt;/code&gt; opens a nursery and passes it to &lt;code&gt;new_connection_listener&lt;/code&gt;, and then &lt;code&gt;new_connection_listener&lt;/code&gt; is able to start new tasks as &amp;ldquo;siblings&amp;rdquo; of itself. Of course, in this case, we could just as well have written:</source>
          <target state="translated">请注意， &lt;code&gt;server&lt;/code&gt; 打开了一个托儿所，并将其传递给 &lt;code&gt;new_connection_listener&lt;/code&gt; ，然后 &lt;code&gt;new_connection_listener&lt;/code&gt; 能够以其自身的&amp;ldquo;兄弟姐妹&amp;rdquo;身份启动新任务。当然，在这种情况下，我们也可以这样写：</target>
        </trans-unit>
        <trans-unit id="e37b67492b27cf2315618722132887747e63dd5f" translate="yes" xml:space="preserve">
          <source>Now suppose that the remote server stops responding, so our call to &lt;code&gt;await conn.send_hello_msg()&lt;/code&gt; hangs forever. Fortunately, we were clever enough to put a timeout around this code, so eventually the timeout will expire and &lt;code&gt;send_hello_msg&lt;/code&gt; will raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. But then, in the &lt;code&gt;finally&lt;/code&gt; block, we make another blocking operation, which will also hang forever! At this point, if we were using &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; or another library with &amp;ldquo;edge-triggered&amp;rdquo; cancellation, we&amp;rsquo;d be in trouble: since our timeout already fired, it wouldn&amp;rsquo;t fire again, and at this point our application would lock up forever. But in Trio, this &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; happen: the &lt;code&gt;await
conn.send_goodbye_msg()&lt;/code&gt; call is still inside the cancelled block, so it will also raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">现在假设远程服务器停止响应，因此对 &lt;code&gt;await conn.send_hello_msg()&lt;/code&gt; 的调用将永远挂起。幸运的是，我们足够聪明地对此代码设置了超时，因此最终超时将到期，并且 &lt;code&gt;send_hello_msg&lt;/code&gt; 将引发&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;。但是，在 &lt;code&gt;finally&lt;/code&gt; 块中，我们进行了另一个阻塞操作，该操作也将永远挂起！在这一点上，如果我们使用&lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; &lt;/a&gt;或另一个具有&amp;ldquo;边缘触发&amp;rdquo;取消功能的库，则会遇到麻烦：由于超时已经触发，因此不会再次触发，并且此时我们的应用程序将永远锁定。但是在Trio中，这&lt;em&gt;不会&lt;/em&gt;发生： &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; 呼叫仍在被取消的区块内，因此也会引发&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="02c8f6d70943a7fac1506484bdd19fd986fc4dea" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;send&lt;/code&gt; calls wait for the &lt;code&gt;receive&lt;/code&gt; calls to finish, which forces the producer to slow down to match the consumer&amp;rsquo;s speed. (It might look strange that some values are reported as &amp;ldquo;Received&amp;rdquo; before they&amp;rsquo;re reported as &amp;ldquo;Sent&amp;rdquo;; this happens because the actual send/receive happen at the same time, so which line gets printed first is random.)</source>
          <target state="translated">现在， &lt;code&gt;send&lt;/code&gt; 呼叫等待 &lt;code&gt;receive&lt;/code&gt; 呼叫结束，这迫使生产者放慢速度以适应消费者的速度。（有些值在报告为&amp;ldquo;已发送&amp;rdquo;之前先报告为&amp;ldquo;已接收&amp;rdquo;，这似乎很奇怪；这是因为实际的发送/接收是同时发生的，因此首先打印的行是随机的。）</target>
        </trans-unit>
        <trans-unit id="4e56b32190bfb5370d26b04e4a28ca4757d98a90" translate="yes" xml:space="preserve">
          <source>Now try replacing &lt;code&gt;open_memory_channel(math.inf)&lt;/code&gt; with &lt;code&gt;open_memory_channel(0)&lt;/code&gt;, and run it again. We get output like:</source>
          <target state="translated">现在尝试将 &lt;code&gt;open_memory_channel(math.inf)&lt;/code&gt; 替换为 &lt;code&gt;open_memory_channel(0)&lt;/code&gt; ，然后再次运行。我们得到如下输出：</target>
        </trans-unit>
        <trans-unit id="adc4ba48cd9ba8dfc30133e2521b610c7b62038b" translate="yes" xml:space="preserve">
          <source>Now, here&amp;rsquo;s the problem: how does the logging code know what the request identifier is? One approach would be to explicitly pass it around to every function that might want to emit logs&amp;hellip; but that&amp;rsquo;s basically every function, because you never know when you might need to add a &lt;code&gt;log.debug(...)&lt;/code&gt; call to some utility function buried deep in the call stack, and when you&amp;rsquo;re in the middle of a debugging a nasty problem that last thing you want is to have to stop first and refactor everything to pass through the request identifier! Sometimes this is the right solution, but other times it would be much more convenient if we could store the identifier in a global variable, so that the logging function could look it up whenever it needed it. Except&amp;hellip; a global variable can only have one value at a time, so if we have multiple handlers running at once then this isn&amp;rsquo;t going to work. What we need is something that&amp;rsquo;s &lt;em&gt;like&lt;/em&gt; a global variable, but that can have different values depending on which request handler is accessing it.</source>
          <target state="translated">现在，问题来了：日志记录代码如何知道请求标识符是什么？一种方法是将其显式传递给可能想要发出日志的每个函数&amp;hellip;&amp;hellip;但是基本上就是每个函数，因为您永远不知道何时需要添加 &lt;code&gt;log.debug(...)&lt;/code&gt; 调用隐藏在调用堆栈中的某个实用程序函数，而当您在调试过程中遇到一个令人讨厌的问题时，您想要做的最后一件事就是必须首先停止并重构所有内容以通过请求标识符！有时这是正确的解决方案，但有时将标识符存储在全局变量中会更加方便，以便日志记录功能可以在需要时查找它。除了&amp;hellip;&amp;hellip;一个全局变量一次只能有一个值，因此如果我们一次运行多个处理程序，那么它将无法正常工作。我们需要的是一个&lt;em&gt;类似于&lt;/em&gt;全局变量的东西，但是根据哪个请求处理程序正在访问它，它可以具有不同的值。</target>
        </trans-unit>
        <trans-unit id="18a97ec0e1695e28d7a8fe2a6572b4583a7001e4" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try setting a small but nonzero buffer size, like &lt;code&gt;open_memory_channel(3)&lt;/code&gt;. what do you think will happen?</source>
          <target state="translated">现在，让我们尝试设置一个小的但非零的缓冲区大小，例如 &lt;code&gt;open_memory_channel(3)&lt;/code&gt; 。您认为会发生什么？</target>
        </trans-unit>
        <trans-unit id="fd5e18f90249b8669806f325c583b198ada3d939" translate="yes" xml:space="preserve">
          <source>Nurseries and spawning</source>
          <target state="translated">苗圃和产卵</target>
        </trans-unit>
        <trans-unit id="16d7703fe16bb0df95242d1426109cc4459c2e07" translate="yes" xml:space="preserve">
          <source>Nurseries ensure the absence of orphaned Tasks, since all running tasks will belong to an open Nursery.</source>
          <target state="translated">托管确保没有孤儿任务,因为所有正在运行的任务将属于一个开放的托管。</target>
        </trans-unit>
        <trans-unit id="20dca5710da376ad5a814a1da5182bc19a89b8b0" translate="yes" xml:space="preserve">
          <source>Objects that implement this interface can be used as async context managers, i.e., you can write:</source>
          <target state="translated">实现这个接口的对象可以作为异步上下文管理器使用,也就是说,你可以写。</target>
        </trans-unit>
        <trans-unit id="4b940f5465fbd6a31841a4291aeea0108a4130ad" translate="yes" xml:space="preserve">
          <source>Of course real producers and consumers are usually more complicated than this, and in some situations, a modest amount of buffering might improve throughput. But too much buffering wastes memory and increases latency, so if you want to tune your application you should experiment to see what value works best for you.</source>
          <target state="translated">当然真实的生产者和消费者通常比这更复杂,在某些情况下,适量的缓冲可能会提高吞吐量。但过多的缓冲会浪费内存并增加延迟,所以如果你想调整你的应用,你应该进行实验,看看什么值最适合你。</target>
        </trans-unit>
        <trans-unit id="e5af8fe33a8522754410781a2a311fe81b69b085" translate="yes" xml:space="preserve">
          <source>Of course we don&amp;rsquo;t generally like it when programs hang. What happened? The problem is that the producer sent 3 messages and then exited, but the consumer has no way to tell that the producer is gone: for all it knows, another message might be coming along any moment. So it hangs forever waiting for the 4th message.</source>
          <target state="translated">当然，当程序挂起时，我们通常不喜欢它。发生了什么？问题是生产者发送了3条消息，然后退出了，但是消费者没有办法告诉生产者已经走了：据它所知，随时可能会出现另一条消息。因此它将永远挂起，等待第四个消息。</target>
        </trans-unit>
        <trans-unit id="c0326ef61ce31f93eca90a3c1fc454c143eaee8a" translate="yes" xml:space="preserve">
          <source>Of course, if you really want to make another blocking call in your cleanup handler, Trio will let you; it&amp;rsquo;s trying to prevent you from accidentally shooting yourself in the foot. Intentional foot-shooting is no problem (or at least &amp;ndash; it&amp;rsquo;s not Trio&amp;rsquo;s problem). To do this, create a new scope, and set its &lt;a href=&quot;#trio.CancelScope.shield&quot;&gt;&lt;code&gt;shield&lt;/code&gt;&lt;/a&gt; attribute to &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">当然，如果您真的想在清理处理程序中进行另一个阻止调用，则Trio将允许您；这样做是为了防止您不小心将自己摔在脚上。故意踩脚是没有问题的（或者至少不是Trio的问题）。为此，创建一个新的作用域，并将其&lt;a href=&quot;#trio.CancelScope.shield&quot;&gt; &lt;code&gt;shield&lt;/code&gt; &lt;/a&gt;属性设置为&lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f3053b0a18145d078b6fd276d56918a38b129cb0" translate="yes" xml:space="preserve">
          <source>Of course, this rule doesn&amp;rsquo;t apply to APIs that need to impose internal timeouts. For example, if you write a &lt;code&gt;start_http_server&lt;/code&gt; function, then you probably should give your caller some way to configure timeouts on individual requests.</source>
          <target state="translated">当然，此规则不适用于需要施加内部超时的API。例如，如果您编写一个 &lt;code&gt;start_http_server&lt;/code&gt; 函数，则可能应该给调用方一些方式来配置各个请求的超时。</target>
        </trans-unit>
        <trans-unit id="7fd62c1a5622fc073c28a93c33b57b2cdd713f8e" translate="yes" xml:space="preserve">
          <source>On UNIX, &lt;code&gt;sig&lt;/code&gt; may be any signal defined in the &lt;a href=&quot;https://docs.python.org/3/library/signal.html#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; module, such as &lt;code&gt;signal.SIGINT&lt;/code&gt; or &lt;code&gt;signal.SIGTERM&lt;/code&gt;. On Windows, it may be anything accepted by the standard library &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.send_signal&quot;&gt;&lt;code&gt;subprocess.Popen.send_signal()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在UNIX上， &lt;code&gt;sig&lt;/code&gt; 可以是&lt;a href=&quot;https://docs.python.org/3/library/signal.html#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt;模块中定义的任何信号，例如 &lt;code&gt;signal.SIGINT&lt;/code&gt; 或 &lt;code&gt;signal.SIGTERM&lt;/code&gt; 。在Windows上，它可以是标准库&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.send_signal&quot;&gt; &lt;code&gt;subprocess.Popen.send_signal()&lt;/code&gt; &lt;/a&gt;接受的任何东西。</target>
        </trans-unit>
        <trans-unit id="bf6f1410af029c2960985ac658c1c9ea77c283a7" translate="yes" xml:space="preserve">
          <source>On UNIX, this is equivalent to &lt;code&gt;send_signal(signal.SIGKILL)&lt;/code&gt;. On Windows, it calls &lt;code&gt;TerminateProcess&lt;/code&gt;. In both cases, the process cannot prevent itself from being killed, but the termination will be delivered asynchronously; use &lt;a href=&quot;#trio.Process.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; if you want to ensure the process is actually dead before proceeding.</source>
          <target state="translated">在UNIX上，这等效于 &lt;code&gt;send_signal(signal.SIGKILL)&lt;/code&gt; 。在Windows上，它调用 &lt;code&gt;TerminateProcess&lt;/code&gt; 。在这两种情况下，该进程都无法防止其自身被杀死，但是终止将异步传递。如果要确保进程实际上已死，请使用&lt;a href=&quot;#trio.Process.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt;，然后再继续。</target>
        </trans-unit>
        <trans-unit id="093bb857c24ad88054bdae99c1ac11b6ac41ad98" translate="yes" xml:space="preserve">
          <source>On UNIX, this is equivalent to &lt;code&gt;send_signal(signal.SIGTERM)&lt;/code&gt;; by convention this requests graceful termination, but a misbehaving or buggy process might ignore it. On Windows, &lt;a href=&quot;#trio.Process.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt; forcibly terminates the process in the same manner as &lt;a href=&quot;#trio.Process.kill&quot;&gt;&lt;code&gt;kill()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在UNIX上，这等效于 &lt;code&gt;send_signal(signal.SIGTERM)&lt;/code&gt; ; 按照惯例，这要求正常终止，但是行为异常或错误的程序可能会忽略它。在Windows上，&lt;a href=&quot;#trio.Process.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt;以与&lt;a href=&quot;#trio.Process.kill&quot;&gt; &lt;code&gt;kill()&lt;/code&gt; &lt;/a&gt;相同的方式强制终止进程。</target>
        </trans-unit>
        <trans-unit id="63bccc32cfb24ea3be7c492da42e7d6931504b60" translate="yes" xml:space="preserve">
          <source>On Unix systems, &lt;code&gt;obj&lt;/code&gt; must either be an integer file descriptor, or else an object with a &lt;code&gt;.fileno()&lt;/code&gt; method which returns an integer file descriptor. Any kind of file descriptor can be passed, though the exact semantics will depend on your kernel. For example, this probably won&amp;rsquo;t do anything useful for on-disk files.</source>
          <target state="translated">在Unix系统上， &lt;code&gt;obj&lt;/code&gt; 必须是整数文件描述符，或者是带有 &lt;code&gt;.fileno()&lt;/code&gt; 方法的对象，该方法返回整数文件描述符。可以传递任何类型的文件描述符，尽管确切的语义将取决于您的内核。例如，这可能对磁盘文件没有任何帮助。</target>
        </trans-unit>
        <trans-unit id="a969b2d9ca8b91fa9abe22200e2f4c6b06299d74" translate="yes" xml:space="preserve">
          <source>On Windows systems, &lt;code&gt;obj&lt;/code&gt; must either be an integer &lt;code&gt;SOCKET&lt;/code&gt; handle, or else an object with a &lt;code&gt;.fileno()&lt;/code&gt; method which returns an integer &lt;code&gt;SOCKET&lt;/code&gt; handle. File descriptors aren&amp;rsquo;t supported, and neither are handles that refer to anything besides a &lt;code&gt;SOCKET&lt;/code&gt;.</source>
          <target state="translated">在Windows系统上， &lt;code&gt;obj&lt;/code&gt; 必须是整数 &lt;code&gt;SOCKET&lt;/code&gt; 句柄，或者是带有 &lt;code&gt;.fileno()&lt;/code&gt; 方法的对象，该方法返回整数 &lt;code&gt;SOCKET&lt;/code&gt; 句柄。不支持文件描述符，也没有引用 &lt;code&gt;SOCKET&lt;/code&gt; 之外的任何东西的句柄。</target>
        </trans-unit>
        <trans-unit id="fc652985d9f1e9dde967ef006b4df5bdb1adee42" translate="yes" xml:space="preserve">
          <source>On Windows with &lt;code&gt;shell=True&lt;/code&gt;, things get even more chaotic. Now there are two separate sets of quoting rules applied, one by the Windows command shell &lt;code&gt;CMD.EXE&lt;/code&gt; and one by the process being spawned, and they&amp;rsquo;re &lt;em&gt;different&lt;/em&gt;. (And there&amp;rsquo;s no &lt;a href=&quot;https://docs.python.org/3/library/shlex.html#shlex.quote&quot;&gt;&lt;code&gt;shlex.quote()&lt;/code&gt;&lt;/a&gt; to save you: it uses UNIX-style quoting rules, even on Windows.) Most special characters interpreted by the shell &lt;code&gt;&amp;amp;&amp;lt;&amp;gt;()^|&lt;/code&gt; are not treated as special if the shell thinks they&amp;rsquo;re inside double quotes, but &lt;code&gt;%FOO%&lt;/code&gt; environment variable substitutions still are, and the shell doesn&amp;rsquo;t provide any way to write a double quote inside a double-quoted string. Outside double quotes, any character (including a double quote) can be escaped using a leading &lt;code&gt;^&lt;/code&gt;. But since a pipeline is processed by running each command in the pipeline in a subshell, multiple layers of escaping can be needed:</source>
          <target state="translated">在具有 &lt;code&gt;shell=True&lt;/code&gt; 的 Windows上，事情变得更加混乱。现在有两套单独的报价规则，一套是Windows命令shell &lt;code&gt;CMD.EXE&lt;/code&gt; ，另一套是通过生成的进程，它们是&lt;em&gt;不同的&lt;/em&gt;。 （并且没有&lt;a href=&quot;https://docs.python.org/3/library/shlex.html#shlex.quote&quot;&gt; &lt;code&gt;shlex.quote()&lt;/code&gt; &lt;/a&gt;可以为您节省：即使在Windows上，它也使用UNIX风格的引用规则。）大多数特殊字符由shell &lt;code&gt;&amp;amp;&amp;lt;&amp;gt;()^|&lt;/code&gt; 如果Shell认为它们在双引号内，则不会被视为特殊字符，但是 &lt;code&gt;%FOO%&lt;/code&gt; 环境变量替换仍然存在，并且Shell不提供任何在双引号字符串内编写双引号的方法。除双引号外，任何字符（包括双引号）都可以使用引号转义 &lt;code&gt;^&lt;/code&gt; 。但是，由于通过在子外壳中运行管道中的每个命令来处理管道，因此可能需要多层转义：</target>
        </trans-unit>
        <trans-unit id="c24aef8753094fb445e161838d7875f71ea24d80" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;SO_REUSEADDR&lt;/code&gt; is not exported, because it&amp;rsquo;s a trap: the name is the same as Unix &lt;code&gt;SO_REUSEADDR&lt;/code&gt;, but the semantics are &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms740621(v=vs.85).aspx&quot;&gt;different and extremely broken&lt;/a&gt;. In the very rare cases where you actually want &lt;code&gt;SO_REUSEADDR&lt;/code&gt; on Windows, then it can still be accessed from the standard library&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/socket.html#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">在Windows上，不会导出 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; ，因为它是一个陷阱：名称与Unix &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 相同，但是语义&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms740621(v=vs.85).aspx&quot;&gt;不同并且极为混乱&lt;/a&gt;。在极少数情况下，您实际上希望在Windows上使用 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; ，那么仍然可以从标准库的&lt;a href=&quot;https://docs.python.org/3/library/socket.html#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt;模块中对其进行访问。</target>
        </trans-unit>
        <trans-unit id="1df29ab054edbd8897c505b18471d47700563f66" translate="yes" xml:space="preserve">
          <source>On Windows, the fundamental API for process spawning (the &lt;code&gt;CreateProcess()&lt;/code&gt; system call) takes a string, not a list, and it&amp;rsquo;s actually up to the child process to decide how it wants to split that string into individual arguments. Since the C language specifies that &lt;code&gt;main()&lt;/code&gt; should take a list of arguments, &lt;em&gt;most&lt;/em&gt; programs you encounter will follow the rules used by the Microsoft C/C++ runtime. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt;, and thus also Trio, uses these rules when it converts an argument sequence to a string, and they are &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#converting-argument-sequence&quot;&gt;documented&lt;/a&gt; alongside the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module. There is no documented Python standard library function that can directly perform that conversion, so even on Windows, you almost always want to pass an argument sequence rather than a string. But if the program you&amp;rsquo;re spawning doesn&amp;rsquo;t split its command line back into individual arguments in the standard way, you might need to pass a string to work around this. (Or you might just be out of luck: as far as I can tell, there&amp;rsquo;s simply no way to pass an argument containing a double-quote to a Windows batch file.)</source>
          <target state="translated">在Windows上，用于产生进程的基本API（ &lt;code&gt;CreateProcess()&lt;/code&gt; 系统调用）采用字符串而不是列表，实际上取决于子进程来决定如何将字符串拆分为各个参数。由于C语言指定 &lt;code&gt;main()&lt;/code&gt; 应采用参数列表，因此您遇到的&lt;em&gt;大多数&lt;/em&gt;程序将遵循Microsoft C / C ++运行时使用的规则。&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt;以及Trio在将参数序列转换为字符串时会使用这些规则，并在&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt;旁边&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#converting-argument-sequence&quot;&gt;记录&lt;/a&gt;这些规则模块。没有记录的Python标准库函数可以直接执行该转换，因此即使在Windows上，您几乎总是要传递参数序列而不是字符串。但是，如果您生成的程序没有以标准方式将其命令行拆分回各个参数，则可能需要传递字符串来解决此问题。（或者您可能不走运：据我所知，根本没有办法将包含双引号的参数传递给Windows批处理文件。）</target>
        </trans-unit>
        <trans-unit id="93793d84cc2eab9e78702720d98d47b6401fa3b1" translate="yes" xml:space="preserve">
          <source>On a socket, this corresponds to &lt;code&gt;shutdown(..., SHUT_WR)&lt;/code&gt; (&lt;a href=&quot;https://linux.die.net/man/2/shutdown&quot;&gt;man page&lt;/a&gt;).</source>
          <target state="translated">在套接字上，这对应于 &lt;code&gt;shutdown(..., SHUT_WR)&lt;/code&gt; （&lt;a href=&quot;https://linux.die.net/man/2/shutdown&quot;&gt;手册页&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4577b2431790155ff289f03b1c114b916f176a26" translate="yes" xml:space="preserve">
          <source>On an SSL/TLS-encrypted connection, the protocol doesn&amp;rsquo;t provide any way to do a unidirectional shutdown without closing the connection entirely, so &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, not &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在SSL / TLS加密的连接上，协议没有提供任何方法来完全关闭连接而不进行单向关闭，因此&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt;实现了&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;，而不是&lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d03a8ca5007fa469f6d5b1b6ccd1bc31dfaeda2f" translate="yes" xml:space="preserve">
          <source>On average, the producer sends ten messages per second, but the consumer only calls &lt;code&gt;receive&lt;/code&gt; once per second. That means that each second, the channel&amp;rsquo;s internal buffer has to grow to hold an extra nine items. After a minute, the buffer will have ~540 items in it; after an hour, that grows to ~32,400. Eventually, the program will run out of memory. And well before we run out of memory, our latency on handling individual messages will become abysmal. For example, at the one minute mark, the producer is sending message ~600, but the producer is still processing message ~60. Message 600 will have to sit in the channel for ~9 minutes before the consumer catches up and processes it.</source>
          <target state="translated">生产者平均每秒发送十条消息，但消费者每秒仅 &lt;code&gt;receive&lt;/code&gt; 一次呼叫。这意味着通道的内部缓冲区必须每秒增加以容纳额外的九个项目。一分钟后，缓冲区中将有约540个项目；一个小时后，这个数字增加到了32,400。最终，程序将耗尽内存。而且，在我们用尽内存之前，处理单个消息的延迟将变得非常糟糕。例如，在一分钟标记处，生产者正在发送消息〜600，但是生产者仍在处理消息〜60。在消费者赶上并处理消息之前，消息600必须在该通道中停留约9分钟。</target>
        </trans-unit>
        <trans-unit id="99d0a83dc0fc994fcf4f4fc337ee0f9989b01cda" translate="yes" xml:space="preserve">
          <source>On the path where we do end up blocking, we don&amp;rsquo;t pass through any schedule points before that, which avoids some unnecessary work.</source>
          <target state="translated">在最终导致阻塞的路径上，我们在此之前不会经过任何调度点，从而避免了一些不必要的工作。</target>
        </trans-unit>
        <trans-unit id="7ab0a659811c28a2e762a50d54ab27494f7938a1" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt; object is constructed, it implements the full &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt;&lt;/a&gt; interface. In addition, it provides a few extra features:</source>
          <target state="translated">一旦&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt;对象被构造，它实现了充分&lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt; &lt;/a&gt;接口。此外，它还提供了一些额外的功能：</target>
        </trans-unit>
        <trans-unit id="a64c9326dd46aad109181cb7ab1c383a9bdc1d7f" translate="yes" xml:space="preserve">
          <source>Once all the tasks have finished, then:</source>
          <target state="translated">当所有任务完成后,那么。</target>
        </trans-unit>
        <trans-unit id="c45afa168e0caa5cc229264e1df9c6831e79c284" translate="yes" xml:space="preserve">
          <source>Once this method completes, any other pending or future operations on this resource should generally raise &lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;, unless there&amp;rsquo;s a good reason to do otherwise.</source>
          <target state="translated">一旦该方法完成，对该资源的任何其他挂起或将来的操作通常应引发&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; &lt;/a&gt;，除非有充分的理由这样做。</target>
        </trans-unit>
        <trans-unit id="26c7df89ffd2d387f5d5beed48542e820db53c87" translate="yes" xml:space="preserve">
          <source>One approach would be to attempt to connect to the first one, and then if that fails, attempt to connect to the second one &amp;hellip; until we&amp;rsquo;ve tried all of them. But the problem with this is that if the first IP address is unreachable (for example, because it&amp;rsquo;s an IPv6 address and our network discards IPv6 packets), then we might end up waiting tens of seconds for the first connection attempt to timeout before we try the second address.</source>
          <target state="translated">一种方法是尝试连接到第一个，然后，如果失败，请尝试连接到第二个&amp;hellip;&amp;hellip;直到我们尝试了所有的所有方法。但是这样做的问题是，如果第一个IP地址不可达（例如，因为它是一个IPv6地址，并且我们的网络丢弃了IPv6数据包），那么在尝试尝试进行第一次连接超时之前，我们可能要等待数十秒钟第二个地址。</target>
        </trans-unit>
        <trans-unit id="17218738b7f51d71e3bf8c24ea0d43906f5453a7" translate="yes" xml:space="preserve">
          <source>One example of where this might be is useful is if your code is trying to decide whether to begin an expensive operation like an RPC call, but wants to skip it if it knows that it can&amp;rsquo;t possibly complete in the available time. Another example would be if you&amp;rsquo;re using a protocol like gRPC that &lt;a href=&quot;http://www.grpc.io/docs/guides/concepts.html#deadlines&quot;&gt;propagates timeout information to the remote peer&lt;/a&gt;; this function gives a way to fetch that information so you can send it along.</source>
          <target state="translated">一个可能有用的示例是，如果您的代码试图确定是否开始像RPC调用之类的昂贵操作，但是如果知道无法在可用时间内完成操作，则希望跳过该操作。另一个例子是，如果您使用的是gRPC之类的协议，该协议会将&lt;a href=&quot;http://www.grpc.io/docs/guides/concepts.html#deadlines&quot;&gt;超时信息传播到远程对等方&lt;/a&gt;；此功能提供了一种获取信息的方法，因此您可以将其发送出去。</target>
        </trans-unit>
        <trans-unit id="a0c0d7674af6ab050c1ac2ce111af25d5586750b" translate="yes" xml:space="preserve">
          <source>One of Trio&amp;rsquo;s core design principles is: &lt;em&gt;no implicit concurrency&lt;/em&gt;. Every function executes in a straightforward, top-to-bottom manner, finishing each operation before moving on to the next &amp;ndash; &lt;em&gt;like Guido intended&lt;/em&gt;.</source>
          <target state="translated">Trio的核心设计原则之一是：&lt;em&gt;没有隐式并发&lt;/em&gt;。每个功能都以直接，从上到下的方式执行，完成每个操作，然后再进行下一个操作- &lt;em&gt;如Guido所预期的那样&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="c5258410fd1961814ad646a55d204ab7988e49b2" translate="yes" xml:space="preserve">
          <source>One option would be to use a regular &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;, and wrap it around every interaction with the state machine:</source>
          <target state="translated">一种选择是使用常规&lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt;，并将其包装在与状态机的每次交互中：</target>
        </trans-unit>
        <trans-unit id="7e644ae43ba1462c7a0943dedaacaa1f10e95eff" translate="yes" xml:space="preserve">
          <source>One particularly challenging problem when testing network protocols is making sure that your implementation can handle data whose flow gets broken up in weird ways and arrives with weird timings: localhost connections tend to be much better behaved than real networks, so if you only test on localhost then you might get bitten later. To help you out, Trio provides some fully in-memory implementations of the stream interfaces (see &lt;a href=&quot;reference-io#abstract-stream-api&quot;&gt;The abstract Stream API&lt;/a&gt;), that let you write all kinds of interestingly evil tests.</source>
          <target state="translated">测试网络协议时，一个特别具有挑战性的问题是确保您的实现能够处理数据流，这些数据流以怪异的方式分解并以怪异的时间到达：本地主机连接的行为往往比真实网络好，因此，如果仅在本地主机上进行测试那么您以后可能会被咬。为了帮助您，Trio提供了一些流接口的完全内存实现（请参见&lt;a href=&quot;reference-io#abstract-stream-api&quot;&gt;The Abstract Stream API&lt;/a&gt;），使您可以编写各种有趣的测试。</target>
        </trans-unit>
        <trans-unit id="70024abc1516890206e396c0d84ab876e9506524" translate="yes" xml:space="preserve">
          <source>One thing to remember, though: cancel scopes are inherited from the nursery, &lt;strong&gt;not&lt;/strong&gt; from the task that calls &lt;code&gt;start_soon&lt;/code&gt;. So in this example, the timeout does &lt;em&gt;not&lt;/em&gt; apply to &lt;code&gt;child&lt;/code&gt; (or to anything else):</source>
          <target state="translated">但是要记住一件事：取消范围是从托儿所继承的，&lt;strong&gt;而不是&lt;/strong&gt;从调用 &lt;code&gt;start_soon&lt;/code&gt; 的任务继承的。因此，在这个例子中，超时也&lt;em&gt;没有&lt;/em&gt;适用于 &lt;code&gt;child&lt;/code&gt; （或任何其他类型）：</target>
        </trans-unit>
        <trans-unit id="beaeb02751f65d3130fef8613eaa9d036b7b827d" translate="yes" xml:space="preserve">
          <source>Open a channel for passing objects between tasks within a process.</source>
          <target state="translated">打开一个通道,用于在流程内的任务之间传递对象。</target>
        </trans-unit>
        <trans-unit id="6c62e1a69d21a32a529448d3d8f35daada8a1b66" translate="yes" xml:space="preserve">
          <source>Open the file pointed by this path and return a file object, as the built-in open() function does.</source>
          <target state="translated">打开这个路径所指向的文件,并返回一个文件对象,就像内置的open()函数一样。</target>
        </trans-unit>
        <trans-unit id="f3c5fe1c3751280d80986615a66056be1dd51489" translate="yes" xml:space="preserve">
          <source>Opens a connection to the specified &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_domain_socket&quot;&gt;Unix domain socket&lt;/a&gt;.</source>
          <target state="translated">打开到指定&lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_domain_socket&quot;&gt;Unix域套接字&lt;/a&gt;的连接。</target>
        </trans-unit>
        <trans-unit id="1901a0e40a967eefcb6e5dd3df1c5f153c15dbb3" translate="yes" xml:space="preserve">
          <source>Options for starting subprocesses</source>
          <target state="translated">启动子程序的选项</target>
        </trans-unit>
        <trans-unit id="efe8c1c73352ea2ed8175b8de72fc761dd83142c" translate="yes" xml:space="preserve">
          <source>Otherwise, it should return &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt;&lt;code&gt;Abort.FAILED&lt;/code&gt;&lt;/a&gt;. This means that the task can&amp;rsquo;t be cancelled at this time, and still has to make sure that &amp;ldquo;someone&amp;rdquo; eventually calls &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">否则，应返回&lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt; &lt;code&gt;Abort.FAILED&lt;/code&gt; &lt;/a&gt;。这意味着该任务目前无法取消，并且仍然必须确保&amp;ldquo;某人&amp;rdquo;最终调用&lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="456165d8c54895fc6bd4ac3bf65c943f1ea85b80" translate="yes" xml:space="preserve">
          <source>Otherwise, returns a new &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">否则，返回一个新的&lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="9ee75f95c72ccfd62a03a7e39dba3cd64ff33ea2" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;reference-core#cancellable-primitives&quot;&gt;cancellation semantics&lt;/a&gt; say that &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; should only be raised if the operation didn&amp;rsquo;t happen. Using &lt;a href=&quot;#trio.hazmat.cancel_shielded_checkpoint&quot;&gt;&lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt;&lt;/a&gt; on the early-exit branch accomplishes this.</source>
          <target state="translated">我们的&lt;a href=&quot;reference-core#cancellable-primitives&quot;&gt;取消语义&lt;/a&gt;表示，只有在未发生操作的情况下，才应引发&lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;。在早期退出分支上使用&lt;a href=&quot;#trio.hazmat.cancel_shielded_checkpoint&quot;&gt; &lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt; 可&lt;/a&gt;完成此操作。</target>
        </trans-unit>
        <trans-unit id="7db19939314aaad6d5ce1f4bdae93a6396ba0d3a" translate="yes" xml:space="preserve">
          <source>Our Pledge</source>
          <target state="translated">我们的承诺</target>
        </trans-unit>
        <trans-unit id="25e4d03f4e76d2bf2914327a45498edc72df108f" translate="yes" xml:space="preserve">
          <source>Our Standards</source>
          <target state="translated">我们的标准</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="4f2f5f60cf5ac63db9da317a29551d539455d423" translate="yes" xml:space="preserve">
          <source>Overview: abstract base classes for I/O</source>
          <target state="translated">概述:I/O的抽象基类</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="08f9f24653915627b70d1df0f7d09b16a85dfbbf" translate="yes" xml:space="preserve">
          <source>Park the current task until woken by a call to &lt;a href=&quot;#trio.hazmat.ParkingLot.unpark&quot;&gt;&lt;code&gt;unpark()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.hazmat.ParkingLot.unpark_all&quot;&gt;&lt;code&gt;unpark_all()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">停放当前任务，直到被调用&lt;a href=&quot;#trio.hazmat.ParkingLot.unpark&quot;&gt; &lt;code&gt;unpark()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#trio.hazmat.ParkingLot.unpark_all&quot;&gt; &lt;code&gt;unpark_all()&lt;/code&gt; &lt;/a&gt;唤醒。</target>
        </trans-unit>
        <trans-unit id="82d438cd7980583075141b24e8673a9713c1bf85" translate="yes" xml:space="preserve">
          <source>Partial exception for async context managers: Both the entry and exit of an &lt;code&gt;async with&lt;/code&gt; block are defined as async functions; but for a particular type of async context manager, it&amp;rsquo;s often the case that only one of them is able to block, which means only that one will act as a checkpoint. This is documented on a case-by-case basis.</source>
          <target state="translated">异步上下文管理器的部分异常： &lt;code&gt;async with&lt;/code&gt; 块的异步进入和退出都定义为异步函数；但是对于特定类型的异步上下文管理器，通常只有其中一个能够阻塞，这意味着只有一个可以充当检查点。这是逐案记录的。</target>
        </trans-unit>
        <trans-unit id="5a267b39a5eff3913f1dc319a58ba6d62432a28c" translate="yes" xml:space="preserve">
          <source>Pass a keyword argument, &lt;code&gt;trio_token&lt;/code&gt; specifiying a specific &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; loop to re-enter. This is useful in case you have a &amp;ldquo;foreign&amp;rdquo; thread, spawned using some other framework, and still want to enter Trio.</source>
          <target state="translated">传递关键字参数 &lt;code&gt;trio_token&lt;/code&gt; 指定一个特定的&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; &lt;/a&gt;循环以重新输入。如果您有使用其他框架生成的&amp;ldquo;外来&amp;rdquo;线程，并且仍想输入Trio，这将很有用。</target>
        </trans-unit>
        <trans-unit id="1aa5a7ccff5d4f3757f85c40b5dbca2bf8a5358c" translate="yes" xml:space="preserve">
          <source>Pause execution of the current task for the given number of seconds.</source>
          <target state="translated">暂停当前任务的执行,给定秒数。</target>
        </trans-unit>
        <trans-unit id="792724ee650d41a2261ab590c3c964ec9b82bf03" translate="yes" xml:space="preserve">
          <source>Pause execution of the current task forever (or until cancelled).</source>
          <target state="translated">永远暂停当前任务的执行(或直到取消)。</target>
        </trans-unit>
        <trans-unit id="63447823632f8be015880571aa87f00f9ebeabb5" translate="yes" xml:space="preserve">
          <source>Pause execution of the current task until the given time.</source>
          <target state="translated">暂停当前任务的执行,直到给定的时间。</target>
        </trans-unit>
        <trans-unit id="b7f07d2b14f04bdac99308eaf26585e7e40b3547" translate="yes" xml:space="preserve">
          <source>Perform a number of generic tests on a custom half-closeable stream implementation.</source>
          <target state="translated">在一个自定义的半封闭流实现上执行一些通用测试。</target>
        </trans-unit>
        <trans-unit id="c295fcaa1b20aada89b1b40cd2fbdfb23ce8e370" translate="yes" xml:space="preserve">
          <source>Perform a number of generic tests on a custom one-way stream implementation.</source>
          <target state="translated">在自定义的单向流实现上执行一些通用测试。</target>
        </trans-unit>
        <trans-unit id="7a62317ddba72606ceef522c1b86d0d79ca09d82" translate="yes" xml:space="preserve">
          <source>Perform a number of generic tests on a custom two-way stream implementation.</source>
          <target state="translated">在自定义的双向流实现上执行一些通用测试。</target>
        </trans-unit>
        <trans-unit id="42ff50b294fd4232d4b5ff341053088b57eb97c3" translate="yes" xml:space="preserve">
          <source>Permanently detach the current task from the Trio scheduler.</source>
          <target state="translated">将当前任务从Trio调度器中永久分离出来。</target>
        </trans-unit>
        <trans-unit id="f58fe36afb47440251499a789d28dbf3bd14b5c4" translate="yes" xml:space="preserve">
          <source>Personally, I find that events and channels are usually enough to implement most things I care about, and lead to easier to read code than the lower-level primitives discussed in this section. But if you need them, they&amp;rsquo;re here. (If you find yourself reaching for these because you&amp;rsquo;re trying to implement a new higher-level synchronization primitive, then you might also want to check out the facilities in &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; for a more direct exposure of Trio&amp;rsquo;s underlying synchronization logic. All of classes discussed in this section are implemented on top of the public APIs in &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt;; they don&amp;rsquo;t have any special access to Trio&amp;rsquo;s internals.)</source>
          <target state="translated">就我个人而言，我发现事件和通道通常足以实现我关心的大多数事情，并且比本节中讨论的较低级原语更易于阅读代码。但是，如果您需要它们，它们就在这里。（如果您由于尝试实现新的更高级别的同步原语而发现自己想要达到这些目的，那么您可能还想查看&lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; 中的功能&lt;/a&gt;，以更直接地了解Trio的基础同步逻辑。所有这些本节中讨论的类是在&lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt;的公共API 之上实现的；它们没有对Trio内部的任何特殊访问。）</target>
        </trans-unit>
        <trans-unit id="ffdc860af184791cfe1b4e1db983700a5c5843f4" translate="yes" xml:space="preserve">
          <source>Places the given data into the object&amp;rsquo;s internal buffer, and then calls the &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt;&lt;code&gt;send_all_hook&lt;/code&gt;&lt;/a&gt; (if any).</source>
          <target state="translated">将给定的数据放入对象的内部缓冲区，然后调用&lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt; &lt;code&gt;send_all_hook&lt;/code&gt; &lt;/a&gt;（如果有）。</target>
        </trans-unit>
        <trans-unit id="a8ca1fe734f90a81230ee63ca0ea8ac678831e87" translate="yes" xml:space="preserve">
          <source>Preparing a release</source>
          <target state="translated">筹备发布</target>
        </trans-unit>
        <trans-unit id="5020bb795052d80ec813c6028081ba9c1df6120b" translate="yes" xml:space="preserve">
          <source>Preparing pull requests</source>
          <target state="translated">准备拉动请求</target>
        </trans-unit>
        <trans-unit id="f302fc4ed754d1fbfb349262f16252b92e3cc560" translate="yes" xml:space="preserve">
          <source>Pretty much any code you write using Trio needs to have some strategy to handle &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exceptions &amp;ndash; even if you didn&amp;rsquo;t set a timeout, then your caller might (and probably will).</source>
          <target state="translated">使用Trio编写的几乎所有代码都需要采取某种策略来处理&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;异常-即使您未设置超时，调用者也可能（并且可能会）。</target>
        </trans-unit>
        <trans-unit id="af578c673cdef9a60b45069a7ffe307c6ff638e0" translate="yes" xml:space="preserve">
          <source>Prioritization Only Works When There&amp;rsquo;s Pending Data to Prioritize</source>
          <target state="translated">优先级仅在有待定数据时才起作用</target>
        </trans-unit>
        <trans-unit id="c58c7b026eae377fda9c29eb4891a26769146297" translate="yes" xml:space="preserve">
          <source>Pro-tip: you can insert sleep calls (like in our example above) to manipulate the flow of data across tasks&amp;hellip; and then use &lt;a href=&quot;#trio.testing.MockClock&quot;&gt;&lt;code&gt;MockClock&lt;/code&gt;&lt;/a&gt; and its &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; functionality to keep your test suite running quickly.</source>
          <target state="translated">专家提示：您可以插入睡眠调用（如上述示例中的操作）以处理跨任务的数据流&amp;hellip;，然后使用&lt;a href=&quot;#trio.testing.MockClock&quot;&gt; &lt;code&gt;MockClock&lt;/code&gt; &lt;/a&gt;及其&lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt;功能使测试套件快速运行。</target>
        </trans-unit>
        <trans-unit id="97cd9481f2b9c8a87285e30103998d87e6b076b4" translate="yes" xml:space="preserve">
          <source>Providing support</source>
          <target state="translated">提供支持</target>
        </trans-unit>
        <trans-unit id="c61469d5112d29c4d7b6879f0a1409fe87006118" translate="yes" xml:space="preserve">
          <source>Put a token back into the sack on behalf of &lt;code&gt;borrower&lt;/code&gt;.</source>
          <target state="translated">代表 &lt;code&gt;borrower&lt;/code&gt; 将令牌放回麻袋。</target>
        </trans-unit>
        <trans-unit id="e2750887dc705834ea27dfee8c5fa086a70d9316" translate="yes" xml:space="preserve">
          <source>Put a token back into the sack.</source>
          <target state="translated">把一块令牌放回袋子里。</target>
        </trans-unit>
        <trans-unit id="a3400133bd460916e5852bc1b4deaf18a2290d3e" translate="yes" xml:space="preserve">
          <source>Put the current task to sleep, with cancellation support.</source>
          <target state="translated">让当前任务进入睡眠状态,支持取消任务。</target>
        </trans-unit>
        <trans-unit id="ef10b7926486af74ce7f9c3ed42b7e35c433287a" translate="yes" xml:space="preserve">
          <source>Putting blocking I/O into worker threads</source>
          <target state="translated">将阻塞的I/O放入工作线程中</target>
        </trans-unit>
        <trans-unit id="0e3da495154b52a5558a5ade984baaf547b2ab19" translate="yes" xml:space="preserve">
          <source>Putting these together: if your data is in RAM then it should be clear that using a thread is a terrible idea &amp;ndash; if you add 100 &amp;micro;s of overhead to a 1 &amp;micro;s operation, then that&amp;rsquo;s a 100x slowdown! On the other hand, if your data&amp;rsquo;s on a spinning disk, then using a thread is &lt;em&gt;great&lt;/em&gt; &amp;ndash; instead of blocking the main thread and all tasks for 10,000 &amp;micro;s, we only block them for 100 &amp;micro;s and can spend the rest of that time running other tasks to get useful work done, which can effectively be a 100x speedup.</source>
          <target state="translated">将它们放在一起：如果您的数据位于RAM中，那么应该清楚地使用线程是一个糟糕的主意&amp;ndash;如果将100 &amp;micro;s的开销添加到1 &amp;micro;s的操作中，则速度将降低100倍！另一方面，如果您的数据在旋转的磁盘上，那么使用线程非常&lt;em&gt;有用&lt;/em&gt; &amp;ndash;与其将主线程和所有任务阻塞10,000 &amp;micro;s，不如将其阻塞100 &amp;micro;s，并将其余时间用于运行其他线程。任务来完成有用的工作，实际上可以使速度提高100倍。</target>
        </trans-unit>
        <trans-unit id="aa77250d0ce1f733a13fed899dc4e3331be06f66" translate="yes" xml:space="preserve">
          <source>Quoting: more than you wanted to know</source>
          <target state="translated">引用:比你想知道的还要多</target>
        </trans-unit>
        <trans-unit id="31385a56c42dea75b0abfee3d065ac3faad4e1e6" translate="yes" xml:space="preserve">
          <source>Raised by &lt;a href=&quot;#trio.fail_after&quot;&gt;&lt;code&gt;fail_after()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.fail_at&quot;&gt;&lt;code&gt;fail_at()&lt;/code&gt;&lt;/a&gt; if the timeout expires.</source>
          <target state="translated">如果超时到期，则由&lt;a href=&quot;#trio.fail_after&quot;&gt; &lt;code&gt;fail_after()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#trio.fail_at&quot;&gt; &lt;code&gt;fail_at()&lt;/code&gt; 引发&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec13ded90b55c99ffb9020ca292f5ffb665682a1" translate="yes" xml:space="preserve">
          <source>Raised by &lt;a href=&quot;#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run&lt;/code&gt;&lt;/a&gt; and similar functions if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has already finished.</source>
          <target state="translated">如果对&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt;的相应调用已经完成，则由&lt;a href=&quot;#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run&lt;/code&gt; &lt;/a&gt;和类似函数引发。</target>
        </trans-unit>
        <trans-unit id="b9a61e9f5e58cb8abe086249f57467b310df32e1" translate="yes" xml:space="preserve">
          <source>Raised by &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; if we encounter a bug in Trio, or (possibly) a misuse of one of the low-level &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; APIs.</source>
          <target state="translated">如果我们在Trio中遇到错误，或者（可能）滥用了一个低级&lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt; API ，则由&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt;引发。</target>
        </trans-unit>
        <trans-unit id="8913ddb4486c40268daf092227991759027600a9" translate="yes" xml:space="preserve">
          <source>Raised by &lt;code&gt;X_nowait&lt;/code&gt; functions if &lt;code&gt;X&lt;/code&gt; would block.</source>
          <target state="translated">如果 &lt;code&gt;X&lt;/code&gt; 阻塞，则由 &lt;code&gt;X_nowait&lt;/code&gt; 函数引发。</target>
        </trans-unit>
        <trans-unit id="f210751ec099645a40a15f671e5b2c8300437cce" translate="yes" xml:space="preserve">
          <source>Raised by blocking calls if the surrounding scope has been cancelled.</source>
          <target state="translated">如果周围的范围已被取消,则由阻断呼叫引起。</target>
        </trans-unit>
        <trans-unit id="8f507b1f0875891aee3cdb80c4efd15c0b85e4cb" translate="yes" xml:space="preserve">
          <source>Raised when a task attempts to use a resource that some other task is already using, and this would lead to bugs and nonsense.</source>
          <target state="translated">当一个任务试图使用其他任务已经在使用的资源时引发该事件,这将导致错误和无意义。</target>
        </trans-unit>
        <trans-unit id="c8678ba88e13f646dadb26c39c02dc28761beb10" translate="yes" xml:space="preserve">
          <source>Raised when an attempt to use a resource fails due to external circumstances.</source>
          <target state="translated">当由于外部环境导致资源使用失败时发生该事件。</target>
        </trans-unit>
        <trans-unit id="812be58660608d36377923c7fc9cb3158c9268d0" translate="yes" xml:space="preserve">
          <source>Raised when attempting to use a resource after it has been closed.</source>
          <target state="translated">当资源被关闭后试图使用时发生。</target>
        </trans-unit>
        <trans-unit id="e09a1bdfa7a2f8848cd0c16df3025ec969cf49ad" translate="yes" xml:space="preserve">
          <source>Raised when trying to receive from a &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt;&lt;/a&gt; that has no more data to receive.</source>
          <target state="translated">在尝试从没有更多数据要接收的&lt;a href=&quot;reference-io#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt; &lt;/a&gt;接收时引发。</target>
        </trans-unit>
        <trans-unit id="c36d9458e0d1baae7403b5ce642a78b09e4acc7f" translate="yes" xml:space="preserve">
          <source>Raises</source>
          <target state="translated">Raises</target>
        </trans-unit>
        <trans-unit id="f3b46f6055aeafb16858767d1f89c1b6e9dfb653" translate="yes" xml:space="preserve">
          <source>Raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; means that the operation &lt;em&gt;did not happen&lt;/em&gt;. If a Trio socket&amp;rsquo;s &lt;code&gt;send&lt;/code&gt; method raises &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;, then no data was sent. If a Trio socket&amp;rsquo;s &lt;code&gt;recv&lt;/code&gt; method raises &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; then no data was lost &amp;ndash; it&amp;rsquo;s still sitting in the socket receive buffer waiting for you to call &lt;code&gt;recv&lt;/code&gt; again. And so forth.</source>
          <target state="translated">引发&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;表示该操作&lt;em&gt;没有发生&lt;/em&gt;。如果Trio套接字的 &lt;code&gt;send&lt;/code&gt; 方法引发&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;，则没有数据发送。如果Trio套接字的 &lt;code&gt;recv&lt;/code&gt; 方法提高为&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;则不会丢失任何数据-它仍坐在套接字的接收缓冲区中，等待您再次调用 &lt;code&gt;recv&lt;/code&gt; 。依此类推。</target>
        </trans-unit>
        <trans-unit id="99957346670542dddfd38b8ffe66adc228aa621a" translate="yes" xml:space="preserve">
          <source>Read some data from the underlying transport, decrypt it, and return it.</source>
          <target state="translated">从底层传输中读取一些数据,解密后返回。</target>
        </trans-unit>
        <trans-unit id="622b17203422ddf9aae4a69b56f076465c09ce46" translate="yes" xml:space="preserve">
          <source>Read-write, &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;, default &lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;. So long as this is set to &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, then the code inside this scope will not receive &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exceptions from scopes that are outside this scope. They can still receive &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exceptions from (1) this scope, or (2) scopes inside this scope. You can modify this attribute:</source>
          <target state="translated">读写，&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;，默认为&lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt;。只要将其设置为&lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt;，该作用域内的代码就不会从该作用域外的作用域中接收&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;异常。他们仍然可以从（1）此范围或该范围内的（2）范围接收&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;异常。您可以修改此属性：</target>
        </trans-unit>
        <trans-unit id="41af808d2970aab6923b6bc6b45b747b999598be" translate="yes" xml:space="preserve">
          <source>Read-write, &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. An absolute time on the current run&amp;rsquo;s clock at which this scope will automatically become cancelled. You can adjust the deadline by modifying this attribute, e.g.:</source>
          <target state="translated">读写，&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt;。当前运行时钟上的绝对时间，该范围将自动取消。您可以通过修改此属性来调整截止日期，例如：</target>
        </trans-unit>
        <trans-unit id="458a6d137741ae6f23c3a174667c35e2505c63ff" translate="yes" xml:space="preserve">
          <source>Readonly &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;. Records whether cancellation has been requested for this scope, either by an explicit call to &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt;&lt;code&gt;cancel()&lt;/code&gt;&lt;/a&gt; or by the deadline expiring.</source>
          <target state="translated">只读&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;。记录是否已通过显式调用&lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt; &lt;code&gt;cancel()&lt;/code&gt; &lt;/a&gt;或截止期限到期来为此范围请求取消。</target>
        </trans-unit>
        <trans-unit id="988a546c2b4be4f19c6512e225ed82a3331a45e3" translate="yes" xml:space="preserve">
          <source>Readonly &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;. Records whether this scope caught a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception. This requires two things: (1) the &lt;code&gt;with&lt;/code&gt; block exited with a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception, and (2) this scope is the one that was responsible for triggering this &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">只读&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;。记录此范围是否捕获到&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;异常。这需要两件事：（1）以&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;异常退出 &lt;code&gt;with&lt;/code&gt; 块，以及（2）该作用域是负责触发此&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt;异常的作用域。</target>
        </trans-unit>
        <trans-unit id="7c5c60d4ed263e6221b1ceafb46f52538e92cf77" translate="yes" xml:space="preserve">
          <source>Real-time chat: &lt;a href=&quot;https://gitter.im/python-trio/general&quot;&gt;https://gitter.im/python-trio/general&lt;/a&gt;</source>
          <target state="translated">实时聊天：&lt;a href=&quot;https://gitter.im/python-trio/general&quot;&gt;https&lt;/a&gt;：//gitter.im/python-trio/general</target>
        </trans-unit>
        <trans-unit id="1b67be12710ea8d6de91ade39424c9d45cc879ca" translate="yes" xml:space="preserve">
          <source>Reattach a coroutine object that was detached using &lt;a href=&quot;#trio.hazmat.temporarily_detach_coroutine_object&quot;&gt;&lt;code&gt;temporarily_detach_coroutine_object()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">重新附加使用&lt;a href=&quot;#trio.hazmat.temporarily_detach_coroutine_object&quot;&gt; &lt;code&gt;temporarily_detach_coroutine_object()&lt;/code&gt; &lt;/a&gt;分离的协程对象。</target>
        </trans-unit>
        <trans-unit id="6b2f36e5ce6c6da01323540a9b37cff6c1903ffd" translate="yes" xml:space="preserve">
          <source>Regardless of these shenanigans, from &amp;ldquo;inside&amp;rdquo; Trio the passage of time still seems normal so long as you restrict yourself to Trio&amp;rsquo;s time functions (see &lt;a href=&quot;reference-core#time-and-clocks&quot;&gt;Time and clocks&lt;/a&gt;). Below is an example demonstrating two different ways of making time pass quickly. Notice how in both cases, the two tasks keep a consistent view of reality and events happen in the expected order, despite being wildly divorced from real time:</source>
          <target state="translated">无论这些恶作剧，只要您将自己限制在Trio的时间功能上（请参阅&lt;a href=&quot;reference-core#time-and-clocks&quot;&gt;Time and clocks&lt;/a&gt;），从&amp;ldquo;内部&amp;rdquo; Trio来看，时间的流逝仍然很正常。下面的示例演示了使时间快速流逝的两种不同方法。请注意，在两种情况下，尽管它们与实时情况大相径庭，但两个任务如何保持对现实的一致看法，并且事件以预期的顺序发生：</target>
        </trans-unit>
        <trans-unit id="795fd0408cfdff7a235327985444734ec64c8053" translate="yes" xml:space="preserve">
          <source>Regular (synchronous) functions never contain any checkpoints.</source>
          <target state="translated">常规(同步)函数从不包含任何检查点。</target>
        </trans-unit>
        <trans-unit id="5044ba0a5cf607ebea4e58623c6417cb87f682bb" translate="yes" xml:space="preserve">
          <source>Release history</source>
          <target state="translated">发行历史</target>
        </trans-unit>
        <trans-unit id="b5e4913e6b00fb0411556eedb8df5d4e15248e9e" translate="yes" xml:space="preserve">
          <source>Release the lock.</source>
          <target state="translated">松开锁。</target>
        </trans-unit>
        <trans-unit id="dfdddac609bc6525864a46420d173e2db58b56da" translate="yes" xml:space="preserve">
          <source>Release the underlying lock.</source>
          <target state="translated">释放基础锁。</target>
        </trans-unit>
        <trans-unit id="7416201cbf641c4c1cce64a7552e96979b9781a3" translate="yes" xml:space="preserve">
          <source>Represents a stream given the file descriptor to a pipe, TTY, etc.</source>
          <target state="translated">表示给定文件描述符到管道、TTY等的流。</target>
        </trans-unit>
        <trans-unit id="ffed6ffb11cd49ae283b146510b560db62b29b16" translate="yes" xml:space="preserve">
          <source>Reschedule the given task with the given &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;code&gt;outcome.Outcome&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用给定的&lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt; &lt;code&gt;outcome.Outcome&lt;/code&gt; &lt;/a&gt;重新安排给定的任务。</target>
        </trans-unit>
        <trans-unit id="4b80f008c17db60050b84c4982691f26b5d7ebd4" translate="yes" xml:space="preserve">
          <source>Resource handling:</source>
          <target state="translated">资源处理。</target>
        </trans-unit>
        <trans-unit id="f49ed1f90b5319324c89fc4cdc67d98d1d4982c1" translate="yes" xml:space="preserve">
          <source>Retrieve the &lt;a href=&quot;#trio.hazmat.TrioToken&quot;&gt;&lt;code&gt;TrioToken&lt;/code&gt;&lt;/a&gt; for the current call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">检索&lt;a href=&quot;#trio.hazmat.TrioToken&quot;&gt; &lt;code&gt;TrioToken&lt;/code&gt; &lt;/a&gt;以获取对&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt;的当前调用。</target>
        </trans-unit>
        <trans-unit id="36c54ed6ac80bc981ae8ce5652b7aa7a424a0fb5" translate="yes" xml:space="preserve">
          <source>Retrieves data from the internal buffer, blocking if necessary.</source>
          <target state="translated">从内部缓冲区检索数据,必要时进行阻塞。</target>
        </trans-unit>
        <trans-unit id="080bc476ce5968af592b5c6db511e128987c5764" translate="yes" xml:space="preserve">
          <source>Retrieves data from the internal buffer, but doesn&amp;rsquo;t block.</source>
          <target state="translated">从内部缓冲区检索数据，但不阻塞。</target>
        </trans-unit>
        <trans-unit id="4e1a7dbd8e538a02d36f4201744cfd7c212b56c8" translate="yes" xml:space="preserve">
          <source>Return True if the path contains one of the special names reserved by the system, if any.</source>
          <target state="translated">如果路径中包含系统保留的特殊名称,则返回True。</target>
        </trans-unit>
        <trans-unit id="2b7de1c01e3639d70c1301781596a03564716748" translate="yes" xml:space="preserve">
          <source>Return True if this path matches the given pattern.</source>
          <target state="translated">如果该路径符合给定的模式,则返回True。</target>
        </trans-unit>
        <trans-unit id="2c683d81b2e6785afd626708cbea723554ad9f98" translate="yes" xml:space="preserve">
          <source>Return a context manager that catches and re-throws exceptions after running &lt;a href=&quot;#trio.MultiError.filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt; on them.</source>
          <target state="translated">返回一个上下文管理器，该上下文管理&lt;a href=&quot;#trio.MultiError.filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt;在对它们运行filter（）之后捕获并重新抛出异常。</target>
        </trans-unit>
        <trans-unit id="74511c6068e3de9f3c1e1c2e39a44b3f12a40aef" translate="yes" xml:space="preserve">
          <source>Return a new path with the file name changed.</source>
          <target state="translated">返回一个改变了文件名的新路径。</target>
        </trans-unit>
        <trans-unit id="a4759abd8edb019bf0eb31c08f831d77c495f661" translate="yes" xml:space="preserve">
          <source>Return a new path with the file suffix changed (or added, if none).</source>
          <target state="translated">返回一个新的路径,文件后缀已经改变(如果没有,则添加)。</target>
        </trans-unit>
        <trans-unit id="8ce261ae05a052a4b5be129bb11ccb492e6a1503" translate="yes" xml:space="preserve">
          <source>Return an object containing debugging information.</source>
          <target state="translated">返回一个包含调试信息的对象。</target>
        </trans-unit>
        <trans-unit id="9e2277903dc895b3ac624e58f32470f044f28fb7" translate="yes" xml:space="preserve">
          <source>Return the &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object representing the current task.</source>
          <target state="translated">返回代表当前任务的&lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="40cff98535909e183f92699de8527946109d976c" translate="yes" xml:space="preserve">
          <source>Return the current time, according to this clock.</source>
          <target state="translated">根据这个时钟,返回当前时间。</target>
        </trans-unit>
        <trans-unit id="b9db5a47ba6655c11616c8e26b190ca54f43e5a1" translate="yes" xml:space="preserve">
          <source>Return the current value of the internal flag.</source>
          <target state="translated">返回内部标志的当前值。</target>
        </trans-unit>
        <trans-unit id="6de731f34f98b206fa3aeb0d1060258ec569f0dd" translate="yes" xml:space="preserve">
          <source>Return the path as a &amp;lsquo;file&amp;rsquo; URI.</source>
          <target state="translated">将路径作为&amp;ldquo;文件&amp;rdquo; URI返回。</target>
        </trans-unit>
        <trans-unit id="b492c123430d5d95ccde60278f71b4c1ea4e2eec" translate="yes" xml:space="preserve">
          <source>Return the relative path to another path identified by the passed arguments. If the operation is not possible (because this is not a subpath of the other path), raise ValueError.</source>
          <target state="translated">返回由传递的参数所确定的另一个路径的相对路径,如果操作不可能(因为这不是另一个路径的子路径),引发ValueError。如果操作不可能(因为这不是另一个路径的子路径),引发ValueError。</target>
        </trans-unit>
        <trans-unit id="8aff8be4dee4d25bccba9aa66ee0802992b16399" translate="yes" xml:space="preserve">
          <source>Return the string representation of the path with forward (/) slashes.</source>
          <target state="translated">返回带正向(/)斜线的路径字符串。</target>
        </trans-unit>
        <trans-unit id="41b1fb407b7fa442b77381701968fb175362cf78" translate="yes" xml:space="preserve">
          <source>Return type</source>
          <target state="translated">返回类型</target>
        </trans-unit>
        <trans-unit id="9582a02f141fc4b345b2936eba691cd0654efebc" translate="yes" xml:space="preserve">
          <source>Returns</source>
          <target state="translated">Returns</target>
        </trans-unit>
        <trans-unit id="c96e2a604937c0e7bde09850d1e81c88f183872e" translate="yes" xml:space="preserve">
          <source>Returns an async context manager which must be used to create a new &lt;a href=&quot;#trio.Nursery&quot;&gt;&lt;code&gt;Nursery&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回必须用于创建新&lt;a href=&quot;#trio.Nursery&quot;&gt; &lt;code&gt;Nursery&lt;/code&gt; &lt;/a&gt;的异步上下文管理器。</target>
        </trans-unit>
        <trans-unit id="80c3bba28aba9ac5aa2b9e543b569c7c5f7fea4f" translate="yes" xml:space="preserve">
          <source>Returns an object containing run-loop-level debugging information.</source>
          <target state="translated">返回一个包含运行循环级调试信息的对象。</target>
        </trans-unit>
        <trans-unit id="2cb60cb3bef90903444e5b5db55efe97c53982f7" translate="yes" xml:space="preserve">
          <source>Returns or raises whatever the given function returns or raises. It can also raise exceptions of its own:</source>
          <target state="translated">返回或引发任何给定函数返回或引发的异常。它也可以引发自己的异常。</target>
        </trans-unit>
        <trans-unit id="aa20168c5bc2ca247ebd21af6add01da22b9fffa" translate="yes" xml:space="preserve">
          <source>Returns or raises whatever value or exception the new coroutine runner uses to resume the coroutine.</source>
          <target state="translated">返回或引发新的coroutine runner用来恢复coroutine的任何值或异常。</target>
        </trans-unit>
        <trans-unit id="20294a5b79e17adf4e2aab73007106887f91c20b" translate="yes" xml:space="preserve">
          <source>Returns the current &lt;a href=&quot;reference-core#trio.abc.Clock&quot;&gt;&lt;code&gt;Clock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回当前的&lt;a href=&quot;reference-core#trio.abc.Clock&quot;&gt; &lt;code&gt;Clock&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="679a2125dd0230bf3c09de4ff94a0c29225879ae" translate="yes" xml:space="preserve">
          <source>Returns the current effective deadline for the current task.</source>
          <target state="translated">返回当前任务的有效期限。</target>
        </trans-unit>
        <trans-unit id="49f9754b2c2c4e3016fdc4a20e1aa41028fdabce" translate="yes" xml:space="preserve">
          <source>Returns the current root &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回当前的根&lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3612705c9bdde6883ff6d46dc9b98bfbf29c4eae" translate="yes" xml:space="preserve">
          <source>Returns the current time according to Trio&amp;rsquo;s internal clock.</source>
          <target state="translated">根据Trio的内部时钟返回当前时间。</target>
        </trans-unit>
        <trans-unit id="e44dffb19df07ef8414c3c376c6a86a1a10a965c" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;command&lt;/code&gt; in a subprocess, wait for it to complete, and return a &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;subprocess.CompletedProcess&lt;/code&gt;&lt;/a&gt; instance describing the results.</source>
          <target state="translated">在子流程中运行 &lt;code&gt;command&lt;/code&gt; ，等待其完成，然后返回描述结果的&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;subprocess.CompletedProcess&lt;/code&gt; &lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="9b56c81b5d7d12e057ce71207675707f4d4076b3" translate="yes" xml:space="preserve">
          <source>Run a Trio-flavored async function, and return the result.</source>
          <target state="translated">运行一个Trio风味的异步函数,并返回结果。</target>
        </trans-unit>
        <trans-unit id="174632bdc2efcc209e6ec485f5e4d89bb42f99f2" translate="yes" xml:space="preserve">
          <source>Run the given async function in the parent Trio thread, blocking until it is complete.</source>
          <target state="translated">在父Trio线程中运行给定的async函数,阻塞直到它完成。</target>
        </trans-unit>
        <trans-unit id="28b11b8b05a27dee7e81c6c4786ce2373923cc39" translate="yes" xml:space="preserve">
          <source>Run the given sync function in the parent Trio thread, blocking until it is complete.</source>
          <target state="translated">在父Trio线程中运行给定的同步函数,阻塞直到它完成。</target>
        </trans-unit>
        <trans-unit id="34ee226c47ee6762c22038b1355ef784957e69c9" translate="yes" xml:space="preserve">
          <source>Running a process and waiting for it to finish</source>
          <target state="translated">运行一个进程并等待其完成</target>
        </trans-unit>
        <trans-unit id="28b93c4a93cb10440b0c2043a668f9b2550390d8" translate="yes" xml:space="preserve">
          <source>SSL / TLS support</source>
          <target state="translated">支持SSL/TLS</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
