<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="75ed0e4c3e707db3a856bbf741157d893d97d363" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%P&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%P&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9896b573bad37d60bc8fb884379fcf3fc365f4a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%S&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%S&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92bf404cf95e198a295a8a621ad50b58943932d4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%T&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%T&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="44833d4b67b70212a4a5a546b0305b7af39688a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%V&lt;/em&gt; (must be first characters in argument)</source>
          <target state="translated">&lt;em&gt;％V&lt;/em&gt;（必须是参数中的第一个字符）</target>
        </trans-unit>
        <trans-unit id="62615fcc4d83690d4330befddb80607163f14aad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%aD&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%aD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="036354a2c01d667f2b8f40eb10f4f4b1808e5957" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%aE&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%aE&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0bfbb0a7fd12ec6681f55a5816e08b5cefa7b951" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%aI&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%aI&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf19b2a481ec2f153601515d190049678587c1d5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%aL&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%aL&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dbff977319f22d1d044d2269bd20b2bc2463728" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%aN&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%aN&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad3eac469f0878ba8c0e7a987d5b965c6bbd86ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%ad&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%ad&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64ce0c4e9863518493cecd19018a8b3b9fdc6804" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%ae&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%ae&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eaae437a01c6c768059ca41351f9bbd4cc1e6285" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%ai&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%ai&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="abb07a57da9c03ce404f7b1659da9839ccb354e8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%al&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%al&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="273ffb0626c7c25c8cb30ed43eacc59435a2e3b6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%an&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%an&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fd2b309862940d0a5b88963ea07a4d9e135ce93" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%ar&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%ar&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34c8ea2b0b19b218d3c5f58f3b03dea10a3a5094" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%as&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%as&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="113fadb5aa5e8fa20987952b3bf514d81c933e42" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%at&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%at&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97d8e17fc609c068fc3cbbfd0d7dd2951425e122" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%b&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%b&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="03fd38cb7854cd0149de3a70df1765366156ce6c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%cD&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%cD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39d49c61d1b434d9d74f76bb631cf58e91892f56" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%cE&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%cE&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5dc978edd842abc8e72314b50230e89593250474" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%cI&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%cI&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18abe3c593277871aba0dcd344e0a12fe58cdb85" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%cL&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%cL&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77e9aaa0a6b7a420e91cdab317fb475755760214" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%cN&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%cN&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="072221efaaaef8b69c4d8d92b340a38dbcb072d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%cd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%cd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9fee8653b33d7d09d2a9fd4445ee5fca767a4ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%ce&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%ce&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b04e40b7a4054b807432ad6e94d85de0c57d76f0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%ci&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%ci&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f685be2c977cd5d6f1b8f21898de779a482306b0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%cl&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%cl&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c70f5d474fce58ec972f64c84923a50d2edfd36" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%cn&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%cn&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="264f197e10c2835c3e446658f5d23a6274cd4e86" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%cr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%cr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f92beeb5902e6811bde798b6d0696d4b87dd991" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%cs&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%cs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="988dcb9f8cccf380ae847c89daa339e3e02027bd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%ct&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%ct&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c83c8c612b44f13e20295020f4f750afb5501b0e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%d&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%d&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fd6fc8780530397776c0cf559158e39eae45ebc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%e&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%e&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d208e73c219f2a298b483dd445a8f8be92b61514" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%f&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%f&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e96bcf2b717882aabe1fe5b69eb3986c489d2f7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%gD&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%gD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7e15967b6c4666115c7ba72d77caca8e7fa57fe4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%gE&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%gE&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66683808f295955e554e9106cb002100a80ce95f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%gN&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%gN&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ec91c9364e05c861d7f50c6c986259f5074f50b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%gd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%gd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87858a985253d9ad4b06f968f875cac0b8c808d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%ge&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%ge&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="811ecb17dad8e445289f8e7592e5c057af87a7a5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%gn&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%gn&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21864b2d89934a256a942cff7b98f2084be5fae0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%gs&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%gs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc8fee0497dd508d7115654102964957a3ac91bf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%h&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%h&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ca198b3dcbb1a33a7469fe36d7d37c1fc4acca6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%m&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%m&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="391f81332693d8589e68f4d4c914387c4b09417a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%n&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%n&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12128aa5c18831df537f79d120dcf453a3a82256" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%p&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%p&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1950e93b86335b0feb046f066edd6e1e1b613ee1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%s&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%s&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09784658ff8e2ded38c766050508d5defbcfb302" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%t&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%t&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db93689bd2c4086a1a76799710a8caa1e5e633db" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%w([&amp;lt;w&amp;gt;[,&amp;lt;i1&amp;gt;[,&amp;lt;i2&amp;gt;]]])&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%w([&amp;lt;w&amp;gt;[,&amp;lt;i1&amp;gt;[,&amp;lt;i2&amp;gt;]]])&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c890ad8994a324ca9385b760f55473a9e56bb29e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%x00&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%x00&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="32612fbb9a38d2ef016dbcf8dfa00aa9d1f92a54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;describeOutput&amp;gt;&lt;/em&gt;, e.g. &lt;em&gt;v1.7.4.2-679-g3bee7fb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;describeOutput&amp;gt;&lt;/em&gt;，例如&lt;em&gt;v1.7.4.2-679-g3bee7fb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a8bd55b9b4c0b3e70f528a0b5d43e8149074d66f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;refname&amp;gt;&lt;/em&gt;, e.g. &lt;em&gt;master&lt;/em&gt;, &lt;em&gt;heads/master&lt;/em&gt;, &lt;em&gt;refs/heads/master&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;refname&amp;gt;&lt;/em&gt;，例如&lt;em&gt;master&lt;/em&gt;，&lt;em&gt;heads / master&lt;/em&gt;，&lt;em&gt;refs / heads / master&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f3a741e156a801b10a13dd720cc4c28610da2e23" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;refname&amp;gt;@{&amp;lt;n&amp;gt;}&lt;/em&gt;, e.g. &lt;em&gt;master@{1}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;refname&amp;gt; @ {{n&amp;gt;}&lt;/em&gt;，例如&lt;em&gt;master @ {1}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5447b4106b2fc5b9503369d6ffeff019de63d322" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;:&amp;lt;path&amp;gt;&lt;/em&gt;, e.g. &lt;em&gt;HEAD:README&lt;/em&gt;, &lt;em&gt;master:./README&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt;：&amp;lt;path&amp;gt;&lt;/em&gt;，例如&lt;em&gt;HEAD：README&lt;/em&gt;，&lt;em&gt;master：./ README&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a95fdbc4b52aba363140cdf760b8b7b31fd659e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c4c4d99491bc88cd96a215c0d7870e6b9247fbb8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;^!&lt;/em&gt;, e.g. &lt;em&gt;HEAD^!&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ^！&lt;/em&gt;，例如&lt;em&gt;HEAD ^！&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d88a75edc6dde79893a34f055b129b4fce3f9c95" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;^-&amp;lt;n&amp;gt;&lt;/em&gt;, e.g. &lt;em&gt;HEAD^-, HEAD^-2&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ^-&amp;lt;n&amp;gt;&lt;/em&gt;，例如&lt;em&gt;HEAD ^-，HEAD ^ -2&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd6b4f3754d927108daf1980f82d26e72059bad7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;^@&lt;/em&gt;, e.g. &lt;em&gt;HEAD^@&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ^ @&lt;/em&gt;，例如&lt;em&gt;HEAD ^ @&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="24af80679bf977e641a791d973d768cd824252cf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;^[&amp;lt;n&amp;gt;]&lt;/em&gt;, e.g. &lt;em&gt;HEAD^, v1.5.1^0&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ^ [&amp;lt;n&amp;gt;]&lt;/em&gt;，例如&lt;em&gt;HEAD ^，v1.5.1 ^ 0&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41dcbb8437aef9023684ce8c5c99f7accf930e7b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;^{&amp;lt;type&amp;gt;}&lt;/em&gt;, e.g. &lt;em&gt;v0.99.8^{commit}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ^ {&amp;lt;type&amp;gt;}&lt;/em&gt;，例如&lt;em&gt;v0.99.8 ^ {commit}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f8c067bc9fae03ed7be61bf2de69f79b4f23892" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;^{/&amp;lt;text&amp;gt;}&lt;/em&gt;, e.g. &lt;em&gt;HEAD^{/fix nasty bug}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ^ {// text）}&lt;/em&gt;，例如&lt;em&gt;HEAD ^ {/ fix nasty bug}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38cc5071aeb99a9118ca376f1944b38b66cac00e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;^{}&lt;/em&gt;, e.g. &lt;em&gt;v0.99.8^{}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ^ {}&lt;/em&gt;，例如&lt;em&gt;v0.99.8 ^ {}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7e4d4df7091670340f697e194f19a68188eb74ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;~[&amp;lt;n&amp;gt;]&lt;/em&gt;, e.g. &lt;em&gt;HEAD~, master~3&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt;〜[&amp;lt;n&amp;gt;]&lt;/em&gt;，例如&lt;em&gt;HEAD〜，master〜3&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9df87b98598343ae206414b84b7ba21a719e6945" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev1&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev1&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="217c859144416ad739418e62347b5d523ccbaf25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev1&amp;gt;...&amp;lt;rev2&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev1&amp;gt;...&amp;lt;rev2&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fa5ceec7cd768a74031e2043be9619bd700f8d1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;sha1&amp;gt;&lt;/em&gt;, e.g. &lt;em&gt;dae86e1950b1277e545cee180551750029cfe735&lt;/em&gt;, &lt;em&gt;dae86e&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;sha1&amp;gt;&lt;/em&gt;，例如&lt;em&gt;dae86e1950b1277e545cee180551750029cfe735&lt;/em&gt;，&lt;em&gt;dae86e&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f65a058f32edc962d6bcb22998fdc1ddb656915a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;0xxx&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;0xxx&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="07710133768558b61a0c7e37c9c07783b0c0af3e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;:/&amp;lt;text&amp;gt;&lt;/em&gt;, e.g. &lt;em&gt;:/fix nasty bug&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;：/ &amp;lt;文本&amp;gt;&lt;/em&gt;，例如&lt;em&gt;：/ fix讨厌的bug&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c533bd4b9eb4cd60c235b4af7122202bc2dff3f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;:[&amp;lt;n&amp;gt;:]&amp;lt;path&amp;gt;&lt;/em&gt;, e.g. &lt;em&gt;:0:README&lt;/em&gt;, &lt;em&gt;:README&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;：[&amp;lt;n&amp;gt;：] &amp;lt;路径&amp;gt;&lt;/em&gt;，例如&lt;em&gt;：0：README&lt;/em&gt;，&lt;em&gt;：README&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86cfb2993d0ee4862b6d30e20fc03af834fab9da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;@&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;@&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5592cce6d8e5854157f5b37be8b8a1e6af0379b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;@{&amp;lt;n&amp;gt;}&lt;/em&gt;, e.g. &lt;em&gt;@{1}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;@ {&amp;lt;n&amp;gt;}&lt;/em&gt;，例如&lt;em&gt;@ {1}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="728371c67640f54e1e6e290952fb2e8d9066787a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;@{-&amp;lt;n&amp;gt;}&lt;/em&gt;, e.g. &lt;em&gt;@{-1}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;@ {-&amp;lt;n&amp;gt;}&lt;/em&gt;，例如&lt;em&gt;@ {-1}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf6a4bb1a502cdd1a279d16a904af761503de4dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;EMAIL&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;EMAIL&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="247da2407e255bdcc6d3712952ca60e956baecb3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[&amp;lt;branchname&amp;gt;]@{push}&lt;/em&gt;, e.g. &lt;em&gt;master@{push}&lt;/em&gt;, &lt;em&gt;@{push}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;[&amp;lt;branchname&amp;gt;] @ {push}&lt;/em&gt;，例如&lt;em&gt;master @ {push}&lt;/em&gt;，&lt;em&gt;@ {push}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="26594d935b9f7e632538381b6fe05c6a1687068d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[&amp;lt;branchname&amp;gt;]@{upstream}&lt;/em&gt;, e.g. &lt;em&gt;master@{upstream}&lt;/em&gt;, &lt;em&gt;@{u}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;[&amp;lt;branchname&amp;gt;] @ {upstream}&lt;/em&gt;，例如&lt;em&gt;master @ {upstream}&lt;/em&gt;，&lt;em&gt;@ {u}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ab93d7ba46a986eb7c3e1438226dabd9ac82e9fe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[&amp;lt;refname&amp;gt;]@{&amp;lt;date&amp;gt;}&lt;/em&gt;, e.g. &lt;em&gt;master@{yesterday}&lt;/em&gt;, &lt;em&gt;HEAD@{5 minutes ago}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;[&amp;lt;refname&amp;gt;] @ {&amp;lt;date&amp;gt;}&lt;/em&gt;，例如&lt;em&gt;master @ {yesterday}&lt;/em&gt;，&lt;em&gt;HEAD @ {5分钟前}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cd4bcb44e7191f2eb44cda4db023938a79831a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;^&amp;lt;rev&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;^&amp;lt;rev&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a478c982ab96d7b3cd7b2394477937eea1ef5707" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;^&amp;lt;rev&amp;gt;&lt;/em&gt; (caret) Notation</source>
          <target state="translated">&lt;em&gt;^ &amp;lt;rev&amp;gt;&lt;/em&gt;（脱字符）表示法</target>
        </trans-unit>
        <trans-unit id="6c5258bbe828a82728cc4ed33fa5b2a769a9f041" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;add&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;add&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5fb4eac9e523986275eaea65ae4aaa925a3134ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;all&lt;/em&gt; (or &lt;em&gt;world&lt;/em&gt; or &lt;em&gt;everybody&lt;/em&gt;)</source>
          <target state="translated">&lt;em&gt;所有&lt;/em&gt;（或&lt;em&gt;世界&lt;/em&gt;或&lt;em&gt;每个人&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="baa6f8f1c17b745f4aa5b2be2a362fd0f8e9285f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bidi-import&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bidi-import&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ed7df5ebe1d79a304627a7aadaf5a0927046cea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;blame&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;blame&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6de763113a8d904122c702f6cefd7c219b580297" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;branch&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;branch&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6636ab201288b670023e22d0d9e34461025f1b2e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;capabilities&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;capabilities&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79d9992bbf3dbb43b35277a95f1b9108ef1ed550" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;check-connectivity&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;check-connectivity&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="24d6101ef4a291c6beaf056fefdaccc2e424c5c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;clear&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;clear&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ddae6bcc795d419b1ffc77a3d17a0e4276f7f575" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;clone&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;clone&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8eddd1a18b6fc33d327779d06d93e03222940e1d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;commit-diff&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;commit-diff&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0ff51f08bd660342a0c1c80b89197cdaa755aca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;connect&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;connect&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bde2aabfe3d70165e234e4b00b2409c5fcd036c9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;connect&lt;/em&gt; &amp;lt;service&amp;gt;</source>
          <target state="translated">&lt;em&gt;连接&lt;/em&gt; &amp;lt;服务&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7c2320287db9afbf32136b4aeb8b8c3be4276dec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;create-ignore&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;create-ignore&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd4c4c97f36b2b62de11c34b4a27a2c761742b55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvs server&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;CVS服务器&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e49a24547f58bd02d543075f89ceed8c90d6d7d1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dcommit&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dcommit&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29a1329a0153d69adbf79d22da2d86026099cd1a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;diff&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;diff&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dadae45c2e0ed49ab92c21e51924b9c5c51ce2a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;disable&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;disable&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b451ef329785424729c63e2a3017984d3e643c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;export-marks&lt;/em&gt; &amp;lt;file&amp;gt;</source>
          <target state="translated">&lt;em&gt;出口标记&lt;/em&gt; &amp;lt;文件&amp;gt;</target>
        </trans-unit>
        <trans-unit id="35b45d112a98b2ca1521e95769372073007c885a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;export&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;export&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="069adc38be838320ed1d0aece7752fcbc214a54a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fetch&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fetch&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42d558b04f07f16944ece2169a0e3c3823b9025f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fetch&lt;/em&gt; &amp;lt;sha1&amp;gt; &amp;lt;name&amp;gt;</source>
          <target state="translated">&lt;em&gt;获取&lt;/em&gt; &amp;lt;sha1&amp;gt; &amp;lt;name&amp;gt;</target>
        </trans-unit>
        <trans-unit id="89dcac1ec2e46569b3edf183125a808da46f4c6f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;find-rev&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;find-rev&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1073814f068a39c89b0eede6d041e1faf4e59ac8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;forget&lt;/em&gt; &amp;lt;pathspec&amp;gt;</source>
          <target state="translated">&lt;em&gt;忘记&lt;/em&gt; &amp;lt;pathspec&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6f8f3fbb6ffe3b51991811f0c6531319170fdb21" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;gc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;gc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4af622a2a4f28a61d7a9f24cb930fffc6ba76491" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;get-url&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;get-url&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a9d6d2f21ff1ec0d69ee63760f22a3c5cbb084b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; (-p|--patch) [&amp;lt;tree-ish&amp;gt;] [--] [&amp;lt;pathspec&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt;（-p | --patch）[&amp;lt;tree-ish&amp;gt;] [-] [&amp;lt;pathspec&amp;gt; ...]</target>
        </trans-unit>
        <trans-unit id="228e3a4db67759d57c887f137171bceae52a6f8a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; --detach [&amp;lt;branch&amp;gt;]</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt; --detach [&amp;lt;分支&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="d8ead8dfc114c4f20b9d6ce6d106f2bc2ef44cf5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; -b|-B &amp;lt;new_branch&amp;gt; [&amp;lt;start point&amp;gt;]</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt; -b | -B &amp;lt;新分支&amp;gt; [&amp;lt;起点&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="e4b2375b489fba132766f1463af8f72171dbc00f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [&amp;lt;branch&amp;gt;]</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt; [&amp;lt;分支&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="9e1ee40d06e7050bf76fabde96c6e18bcdee66c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [--detach] &amp;lt;commit&amp;gt;</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt; [--detach] &amp;lt;提交&amp;gt;</target>
        </trans-unit>
        <trans-unit id="617a45295c12feb378bd11060f09979d655ab681" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [-f|--ours|--theirs|-m|--conflict=&amp;lt;style&amp;gt;] [&amp;lt;tree-ish&amp;gt;] --pathspec-from-file=&amp;lt;file&amp;gt; [--pathspec-file-nul]</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt; [-f |-我们||他们的| -m |-冲突= &amp;lt;样式&amp;gt;] [&amp;lt;树形&amp;gt;] --pathspec-from-file = &amp;lt;文件&amp;gt; [--pathspec-file- nul]</target>
        </trans-unit>
        <trans-unit id="f1d51fb50a15426c11b22d89a456ad62c37302f5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [-f|--ours|--theirs|-m|--conflict=&amp;lt;style&amp;gt;] [&amp;lt;tree-ish&amp;gt;] [--] &amp;lt;pathspec&amp;gt;&amp;hellip;​</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt; [-f |-我们的|-他们的| -m | --conflict = &amp;lt;style&amp;gt;] [&amp;lt;tree-ish&amp;gt;] [-] &amp;lt;pathspec&amp;gt; ...</target>
        </trans-unit>
        <trans-unit id="8c3a4a5dff582db446092ec31dff7ac07f6c56f2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git daemon&lt;/em&gt; as inetd server</source>
          <target state="translated">&lt;em&gt;git daemon&lt;/em&gt;作为inetd服务器</target>
        </trans-unit>
        <trans-unit id="644cb16bb367018811de44ec6a0f22813d106722" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git daemon&lt;/em&gt; as inetd server for virtual hosts</source>
          <target state="translated">&lt;em&gt;git守护程序&lt;/em&gt;作为虚拟主机的inetd服务器</target>
        </trans-unit>
        <trans-unit id="56394bb621be1c3ea64a9da0cc7c453f78c851ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git daemon&lt;/em&gt; as regular daemon for virtual hosts</source>
          <target state="translated">&lt;em&gt;git守护程序&lt;/em&gt;作为虚拟主机的常规守护程序</target>
        </trans-unit>
        <trans-unit id="eb95273e719d9bbb038ef063d4fe7199f2a7aaf4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;blob&amp;gt; &amp;lt;blob&amp;gt;</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;选项&amp;gt;] &amp;lt;blob&amp;gt; &amp;lt;blob&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1c0820ca6bb0780c196ed7a86287e4ecc94f9478" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt; &amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;选项&amp;gt;] &amp;lt;提交&amp;gt; &amp;lt;提交&amp;gt; [-] [&amp;lt;路径&amp;gt; ...</target>
        </trans-unit>
        <trans-unit id="1c00f2330de34632f28ea25bd937ad87e604196a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt; &amp;lt;commit&amp;gt;&amp;hellip;​ &amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;选项&amp;gt;] &amp;lt;提交&amp;gt; &amp;lt;提交&amp;gt; ... &amp;lt;&amp;lt;提交&amp;gt; [-] [&amp;lt;路径&amp;gt; ...</target>
        </trans-unit>
        <trans-unit id="0bddd1875bfd788184caf49193c3ba66e07b6e07" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;选项&amp;gt;] &amp;lt;提交&amp;gt; [-] [&amp;lt;路径&amp;gt; ...</target>
        </trans-unit>
        <trans-unit id="41d3be1f649e59b3792c69f12f6776a563b79a47" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt;..&amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;选项&amp;gt;] &amp;lt;提交&amp;gt; .. &amp;lt;提交&amp;gt; [-] [&amp;lt;路径&amp;gt; ...]</target>
        </trans-unit>
        <trans-unit id="bf5568faf67d40bb88542b7b67ef397df7105ffc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt;...&amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;选项&amp;gt;] &amp;lt;提交&amp;gt; ... &amp;lt;提交&amp;gt; [-] [&amp;lt;路径&amp;gt; ...]</target>
        </trans-unit>
        <trans-unit id="e447147bf3a29d6c97f55baf3c69e97f18f8eee8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] --cached [&amp;lt;commit&amp;gt;] [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;选项&amp;gt;]-缓存的[&amp;lt;commit&amp;gt;] [-] [&amp;lt;路径&amp;gt; ...]</target>
        </trans-unit>
        <trans-unit id="c9ef6ea9ee2e9e3a071717bb488d4f44e1fb4bda" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] --cached [--merge-base] [&amp;lt;commit&amp;gt;] [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] --cached [--merge-base] [&amp;lt;commit&amp;gt;] [-] [&amp;lt;path&amp;gt; ...]</target>
        </trans-unit>
        <trans-unit id="61d1c1e990e80e06e13a4eafe5a8bc5038d40599" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] --no-index [--] &amp;lt;path&amp;gt; &amp;lt;path&amp;gt;</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;选项&amp;gt;]-无索引[-] &amp;lt;路径&amp;gt; &amp;lt;路径&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6d86328721afc22cd489583dfba8df6685359245" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;选项&amp;gt;] [-] [&amp;lt;路径&amp;gt; ...]</target>
        </trans-unit>
        <trans-unit id="7c81645dbd00708439d85c76dadec7fb75c17956" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] [--merge-base] &amp;lt;commit&amp;gt; &amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;选项&amp;gt;] [-合并基础] &amp;lt;commit&amp;gt; &amp;lt;commit&amp;gt; [-] [&amp;lt;path&amp;gt; ...]</target>
        </trans-unit>
        <trans-unit id="e3453c9e134e20e25559107f3911fd6230cd8bc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git push&lt;/em&gt; uses a pair of commands, &lt;em&gt;git send-pack&lt;/em&gt; on your local machine, and &lt;em&gt;git-receive-pack&lt;/em&gt; on the remote machine. The communication between the two over the network internally uses an SSH connection.</source>
          <target state="translated">&lt;em&gt;git push&lt;/em&gt;使用一对命令，本地计算机上的&lt;em&gt;git send-pack&lt;/em&gt;和远程计算机上的&lt;em&gt;git-receive-pack&lt;/em&gt;。两者之间通过网络进行的通信内部使用SSH连接。</target>
        </trans-unit>
        <trans-unit id="fcf93dc31f705fddbb9194212d483f563999e11e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git receive-pack &amp;lt;argument&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;git receive-pack &amp;lt;参数&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc127848493f760fe053476520e3d12a67e1a15a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; (--patch | -p) [&amp;lt;tree-ish&amp;gt;] [--] [&amp;lt;pathspec&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git reset&lt;/em&gt;（--patch | -p）[&amp;lt;树形&amp;gt;] [-] [&amp;lt;pathspec&amp;gt; ...</target>
        </trans-unit>
        <trans-unit id="e0143ed9ababaeb97962f5daf71b285ee855acf6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; [&amp;lt;mode&amp;gt;] [&amp;lt;commit&amp;gt;]</source>
          <target state="translated">&lt;em&gt;git reset&lt;/em&gt; [&amp;lt;模式&amp;gt;] [&amp;lt;提交&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="9c8b6cc4b08d5db74f9966c865d7bdbc3e8057ff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; [-q] [&amp;lt;tree-ish&amp;gt;] [--] &amp;lt;pathspec&amp;gt;&amp;hellip;​</source>
          <target state="translated">&lt;em&gt;git reset&lt;/em&gt; [-q] [&amp;lt;tree-ish&amp;gt;] [-] &amp;lt;pathspec&amp;gt; ...</target>
        </trans-unit>
        <trans-unit id="3db1e64e46be79d2a9c84117847b63d5ab92c79c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; [-q] [--pathspec-from-file=&amp;lt;file&amp;gt; [--pathspec-file-nul]] [&amp;lt;tree-ish&amp;gt;]</source>
          <target state="translated">&lt;em&gt;git reset&lt;/em&gt; [-q] [--pathspec-from-file = &amp;lt;文件&amp;gt; [--pathspec-file-nul]] [&amp;lt;tree-ish&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="0c6a869ee4e5a3eb64f1df2a1d1670adf970a316" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git upload-archive &amp;lt;argument&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;git upload-archive &amp;lt;参数&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2be43a079baf397e7d9b3bb2f1f647a64854d22" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git upload-pack &amp;lt;argument&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;git upload-pack &amp;lt;参数&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6b0677a6a48058174b9c4662c9d2ba987db8c81" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;group&lt;/em&gt; (or &lt;em&gt;true&lt;/em&gt;)</source>
          <target state="translated">&lt;em&gt;组&lt;/em&gt;（或&lt;em&gt;true&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="55040b4473f65b2a2bbdfd28a71977476093b889" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;import-marks&lt;/em&gt; &amp;lt;file&amp;gt;</source>
          <target state="translated">&lt;em&gt;导入标记&lt;/em&gt; &amp;lt;文件&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e41133af30f1b5a3e614609c0efa62b0bd14788f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;import&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;import&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c7615a0bee74b428678cd3952d9a38bbd50138b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;import&lt;/em&gt; &amp;lt;name&amp;gt;</source>
          <target state="translated">&lt;em&gt;导入&lt;/em&gt; &amp;lt;名称&amp;gt;</target>
        </trans-unit>
        <trans-unit id="026584f5175b5bbc2ceb1f268e18940c0011aaec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;info&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;info&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e0a5f718f14de716a46db8b2404578b5920000d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;init&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;init&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="286e2b7b70dbf3ef029c4799f2f0e629b0a5aef4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;list for-push&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;推单&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be49361f1b70e440beb1d6cf2176c292c8e2abc7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;list&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;list&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a100b4c5979c283ac452823f58dbcc9e5048c7b8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;log&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;log&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="971c241f477dec4b57be5fc29faa14ab335706fa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;mkdirs&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;mkdirs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35b67dffbe62b7476ce92342433b831e27d5bcee" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;no-private-update&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;no-private-update&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a174c76dea793f056b89a441f20182238b3e3cd6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;object-format&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;object-format&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b76f729b2c8dd001b33a3965716abefb37454800" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option atomic&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;原子选项&lt;/em&gt; { &lt;em&gt;真&lt;/em&gt; | &lt;em&gt;假&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="c33bb338d193ab16d7a0168b421e3b698bb0bcbe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option check-connectivity&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;选项check-connectivity&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;假&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="9c99d5f55da3961c68109a0e1d9a50e706a2120b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option cloning&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;选项克隆&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;假&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="04bd7fa50536660a2d31774812bb98fb7a2abdff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option deepen-relative {'true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;选项deeper-relative {'true&lt;/em&gt; | &lt;em&gt;假&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="a98d1a36ae5cdad2003ea22f14ad851505cf3847" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option depth&lt;/em&gt; &amp;lt;depth&amp;gt;</source>
          <target state="translated">&lt;em&gt;选项深度&lt;/em&gt; &amp;lt;depth&amp;gt;</target>
        </trans-unit>
        <trans-unit id="82d6797af0a212ad278e2948eaeaaf74a72f680a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option followtags&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;选项followtags&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;假&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="9986eedd79cb9f9b7c70d2aedda0729823cac02a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option force&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;选择权&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;假&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="111ea29454b6330909016c9e45b9b66754df6b19" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option from-promisor&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;来自承诺者的选项&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;假&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="800dda6c88e8893c227fca8a8c94622ca67dc810" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option no-dependents&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;选项无依赖性&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;假&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="6d34f6b09c919f1b1416585cad7a0c757ef7810f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option object-format&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|algorithm}</source>
          <target state="translated">&lt;em&gt;选项对象格式&lt;/em&gt;{ &lt;em&gt;true&lt;/em&gt; |算法}</target>
        </trans-unit>
        <trans-unit id="7ea5bd740df1ec70168c7a478ecd00a132039f43" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option progress&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;选项进度&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;假&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="5dc4a2e0bb9f6060bdad740b788ef15fe9ea07c9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option pushcert&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;选项pushcert&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;假&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="59d5978dddebb71223de8e8f6a60d2e3e72c7a65" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option servpath &amp;lt;c-style-quoted-path&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;选项servpath &amp;lt;c-style-quoted-path&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ca7ff603e79015944d1670c4c4f6181601659ca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option update-shallow&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;选项update-shallow&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;假&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="0786067c699d96aadca89509b296234c78e51c6b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option verbosity&lt;/em&gt; &amp;lt;n&amp;gt;</source>
          <target state="translated">&lt;em&gt;选项详细程度&lt;/em&gt; &amp;lt;n&amp;gt;</target>
        </trans-unit>
        <trans-unit id="04c59238310bfcf16cbbb35553d54bbfdca9360e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;option&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="44f8139502701251329b628c8aa5e94fd7edfce3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option&lt;/em&gt; &amp;lt;name&amp;gt; &amp;lt;value&amp;gt;</source>
          <target state="translated">&lt;em&gt;选项&lt;/em&gt; &amp;lt;名称&amp;gt; &amp;lt;值&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ba27d70f1550f4f882b78e61655d5157efb6f50e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;propget&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;propget&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6756585c61f2a32bab572f78fd3126b296699695" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;proplist&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;proplist&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0e4008412d95ecd817c12ca15c192c575f546de4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;propset&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;propset&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4498ec3238e0f1d50b74e6af30a09c8f3309ba7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;prune&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;prune&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd31fb337461755bb5e3e31aef446948ecaa910d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;push&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;push&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11c969a81bfce4fd2324388518d5f5e17de0b527" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;push&lt;/em&gt; +&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;</source>
          <target state="translated">&lt;em&gt;推&lt;/em&gt; + &amp;lt;src&amp;gt;：&amp;lt;dst&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9117e882f570b9772bf4876578e36a25fc34732b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;qgit(1)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;qgit(1)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f7c74e3d1e10b38ac6169dc067698ef1a6ff4448" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;reapply&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;reapply&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50ee056d4ddb76ef51f00483fe7dba34b51a449f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;rebase&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;rebase&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18ea2b05c8f3c06fde58d0420744f0ca61045b90" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;refspec&lt;/em&gt; &amp;lt;refspec&amp;gt;</source>
          <target state="translated">&lt;em&gt;refspec&lt;/em&gt; &amp;lt;参考&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dd596b5091e1eb8368f579278c36824b713bc311" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;remaining&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;remaining&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d3ac08fba984c4fe2e39dbd6a9e3de5fb185a1f5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;remove&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;remove&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b73121d3aa4f1dd8fa730929ede8f4b312f32337" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;rename&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;rename&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d13cdb6fdbae20acc2c43402406d81568a2499c7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;reset&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;reset&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e4c4fda591f60696add6ae66730f4d8ec836d261" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;rm&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;rm&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e477dd12e9e0460380eeba036cb09372c938695d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-branches&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-branches&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e65afe49a6eeb7cf02d2f6043f28b8a4ff342bf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-head&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-head&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35f6993e8ee5f31dec406f06a31e049f29878752" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-tree&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-tree&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7eda17e1c12e721d23988d4fc5e20726a9c47abd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-url&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-url&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8687e363ac98f906ebed1b843dd4f64a34e3c7f4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6870a5d4b2985453a855890d8d72edfc3d70811" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;show-externals&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;show-externals&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fe1dc07bdefa3cf58064ba55fde45829ca1f136" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;show-ignore&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;show-ignore&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd0e49781a98f7911b34f1aee38b44f2e869f16f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;show&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;show&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0cc68266a42e8384ff3fa58baf8c34f3646c37ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;signed-tags&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;signed-tags&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b86cead65159d3e086c70f8b7b59218a58d3147e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stateless-connect&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;stateless-connect&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c4b47d3b1f6acb81c114d964233185b4c02ac419" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stateless-connect&lt;/em&gt; &amp;lt;service&amp;gt;</source>
          <target state="translated">&lt;em&gt;无状态连接&lt;/em&gt; &amp;lt;服务&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cbef19eb270f01c4c2c82d2d02a006f9e49ea17d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;status&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;status&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc5dcfd7fa2c24a533fa19007091483ece18fad4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;tag&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;tag&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96d7bc00171f5fd2b09f66cf504ac0023cca30dc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;tig(1)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;tig(1)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="139a3f1d23eafefa18ee2425482ff51b6f467d67" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;umask&lt;/em&gt; (or &lt;em&gt;false&lt;/em&gt;)</source>
          <target state="translated">&lt;em&gt;umask&lt;/em&gt;（或&lt;em&gt;false&lt;/em&gt;）</target>
        </trans-unit>
        <trans-unit id="9c0e9959206cb6877a60069410fa385eb4f78805" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;unchanged&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;unchanged&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ecf8aa641ca5e9e706fa0d63103b28681ce2dc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;unset&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;unset&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c1802e8d4ef28dec4be0233820e8c05c3d927de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;unspecified&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;unspecified&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b312ee3f358f78767b6a06231fbf44287808e9ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;update&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;update&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5aed0d22d6992ee80ec4d657f0cd95ab429e2ec9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;verify&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;verify&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f49b6f6188963904d82e1623f3020436895b7e2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;write&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;write&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8172ae9dcfb804bff8895259fe3102a0316b0619" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; The latter form is just a short-hand of &lt;code&gt;git checkout topic&lt;/code&gt; followed by &lt;code&gt;git rebase master&lt;/code&gt;. When rebase exits &lt;code&gt;topic&lt;/code&gt; will remain the checked-out branch.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;后一种形式只是 &lt;code&gt;git checkout topic&lt;/code&gt; 的缩写，其次是 &lt;code&gt;git rebase master&lt;/code&gt; 。当退出基准库时， &lt;code&gt;topic&lt;/code&gt; 将保留为已签出分支。</target>
        </trans-unit>
        <trans-unit id="b03388fb9a3fc2d66d455eba38ee0aa1f510dfbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; the changes introduced by the commits, and which are not reverted by subsequent commits, will still be in the rewritten branch. If you want to throw out &lt;code&gt;changes&lt;/code&gt; together with the commits, you should use the interactive mode of &lt;code&gt;git rebase&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;，由提交引起的更改，并且随后的提交不会恢复的更改，仍将在重写分支中。如果要与提交一起放弃 &lt;code&gt;changes&lt;/code&gt; ，则应使用 &lt;code&gt;git rebase&lt;/code&gt; 的交互模式。</target>
        </trans-unit>
        <trans-unit id="34561b8d811663906f33af73652542d0fcde7357" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;code&gt;$my_url&lt;/code&gt;, &lt;code&gt;$my_uri&lt;/code&gt;, and &lt;code&gt;$base_url&lt;/code&gt; are overwritten with their default values before every request, so if you want to change them, be sure to set this variable to true or a code reference effecting the desired changes.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;$my_url&lt;/code&gt; ， &lt;code&gt;$my_uri&lt;/code&gt; 和 &lt;code&gt;$base_url&lt;/code&gt; 在每次请求前都会被其默认值覆盖，因此，如果要更改它们，请确保将此变量设置为true或实现所需更改的代码引用。</target>
        </trans-unit>
        <trans-unit id="09aea3b60370a4f963c3a85b4699f5aaace7982e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Do &lt;strong&gt;not&lt;/strong&gt; use this option unless you have read the note for &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;'s &lt;code&gt;--reference&lt;/code&gt;, &lt;code&gt;--shared&lt;/code&gt;, and &lt;code&gt;--dissociate&lt;/code&gt; options carefully.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：不要&lt;strong&gt;没有&lt;/strong&gt;，除非你有阅读的说明使用该选项&lt;a href=&quot;git-clone&quot;&gt;的git克隆[1]&lt;/a&gt;的 &lt;code&gt;--reference&lt;/code&gt; ， &lt;code&gt;--shared&lt;/code&gt; 和 &lt;code&gt;--dissociate&lt;/code&gt; 仔细选择。</target>
        </trans-unit>
        <trans-unit id="7c9dfe7ce0f5b8ee96b2cbc1652fb8a81531cced" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This command honors &lt;code&gt;.git/info/grafts&lt;/code&gt; file and refs in the &lt;code&gt;refs/replace/&lt;/code&gt; namespace. If you have any grafts or replacement refs defined, running this command will make them permanent.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此命令 &lt;code&gt;.git/info/grafts&lt;/code&gt; &lt;code&gt;refs/replace/&lt;/code&gt; 名称空间中的.git / info / grafts文件和refs 。如果定义了任何嫁接或替换引用，则运行此命令将使它们永久化。</target>
        </trans-unit>
        <trans-unit id="d30c68c37350410fb672027924f29f5f9ab1c98c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This command is temporarily disabled if your libcurl is older than 7.16, as the combination has been reported not to work and sometimes corrupts repository.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：如果您的libcurl早于7.16，则暂时禁用此命令，因为据报道该组合无效，有时会破坏存储库。</target>
        </trans-unit>
        <trans-unit id="f74ae839c695329bca37194e38c0f34b77fadce9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This is intended for cleaning metadata, prefer the &lt;code&gt;--whitespace=fix&lt;/code&gt; mode of &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt; for correcting whitespace of patches or files in the repository.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这用于清理元数据，更喜欢使用&lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt;的 &lt;code&gt;--whitespace=fix&lt;/code&gt; 模式来更正存储库中补丁或文件的空白。</target>
        </trans-unit>
        <trans-unit id="585c6ddedc01781dae2a49fca690af8a9afad0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: for a file to be highlighted, its syntax type must be detected and that syntax must be supported by &quot;highlight&quot;. The default syntax detection is minimal, and there are many supported syntax types with no detection by default. There are three options for adding syntax detection. The first and second priority are &lt;code&gt;%highlight_basename&lt;/code&gt; and &lt;code&gt;%highlight_ext&lt;/code&gt;, which detect based on basename (the full filename, for example &quot;Makefile&quot;) and extension (for example &quot;sh&quot;). The keys of these hashes are the basename and extension, respectively, and the value for a given key is the name of the syntax to be passed via &lt;code&gt;--syntax &amp;lt;syntax&amp;gt;&lt;/code&gt; to &quot;highlight&quot;. The last priority is the &quot;highlight&quot; configuration of &lt;code&gt;Shebang&lt;/code&gt; regular expressions to detect the language based on the first line in the file, (for example, matching the line &quot;#!/bin/bash&quot;). See the highlight documentation and the default config at /etc/highlight/filetypes.conf for more details.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：对于要突出显示的文件，必须检测其语法类型，并且&amp;ldquo; highlight&amp;rdquo;必须支持该语法。默认语法检测是最少的，并且默认情况下有许多受支持的语法类型没有检测到。有三种添加语法检测的选项。第一个和第二个优先级是 &lt;code&gt;%highlight_basename&lt;/code&gt; 和 &lt;code&gt;%highlight_ext&lt;/code&gt; ，它们基于基本名称（完整文件名，例如&amp;ldquo; Makefile&amp;rdquo;）和扩展名（例如&amp;ldquo; sh&amp;rdquo;）进行检测。这些哈希的键分别是基本名称和扩展名，给定键的值是要通过 &lt;code&gt;--syntax &amp;lt;syntax&amp;gt;&lt;/code&gt; 传递给&amp;ldquo; highlight&amp;rdquo; 的语法的名称。最后优先事项是&amp;ldquo;突出显示&amp;rdquo; &lt;code&gt;Shebang&lt;/code&gt; 正则表达式以根据文件的第一行检测语言（例如，与&amp;ldquo;＃！/ bin / bash&amp;rdquo;行匹配）。有关更多详细信息，请参见/etc/highlight/filetypes.conf中的突出显示文档和默认配置。</target>
        </trans-unit>
        <trans-unit id="9b9b27f31414016f32b35409236f195a9797bba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: see the NOTE for the &lt;code&gt;--reference&lt;/code&gt; option.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：有关 &lt;code&gt;--reference&lt;/code&gt; 选项的信息，请参阅&amp;ldquo;注意&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="5918a0077865239a25fcfe555ed0525b81a0cce2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: see the NOTE for the &lt;code&gt;--shared&lt;/code&gt; option, and also the &lt;code&gt;--dissociate&lt;/code&gt; option.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：请参阅该注意 &lt;code&gt;--shared&lt;/code&gt; 选项，也是 &lt;code&gt;--dissociate&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="cb7c79db74439daa322af5432c4cb38d74b773b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: this is a possibly dangerous operation; do &lt;strong&gt;not&lt;/strong&gt; use it unless you understand the implications (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这可能是危险的操作；你&lt;strong&gt;不&lt;/strong&gt;，除非你理解的含义使用它（见&lt;a href=&quot;git-rebase&quot;&gt;混帐底垫[1]&lt;/a&gt;了解详细信息）。</target>
        </trans-unit>
        <trans-unit id="fd8f10a91cc32941d397d3cbd72284f0494472a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: this is a possibly dangerous operation; do &lt;strong&gt;not&lt;/strong&gt; use it unless you understand what it does. If you clone your repository using this option and then delete branches (or use any other Git command that makes any existing commit unreferenced) in the source repository, some objects may become unreferenced (or dangling). These objects may be removed by normal Git operations (such as &lt;code&gt;git commit&lt;/code&gt;) which automatically call &lt;code&gt;git gc --auto&lt;/code&gt;. (See &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.) If these objects are removed and were referenced by the cloned repository, then the cloned repository will become corrupt.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这可能是危险的操作；你&lt;strong&gt;不&lt;/strong&gt;，除非你了解它使用它。如果使用此选项克隆存储库，然后在源存储库中删除分支（或使用任何其他使未提交的现有提交的Git命令），则某些对象可能会变为未引用（或悬空）。这些对象可以通过自动调用 &lt;code&gt;git gc --auto&lt;/code&gt; 的常规Git操作（例如 &lt;code&gt;git commit&lt;/code&gt; ）删除。 （请参阅&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;。）如果删除了这些对象并由克隆的存储库引用了这些对象，则克隆的存储库将损坏。</target>
        </trans-unit>
        <trans-unit id="712e882beefd494ed11253317cebeacda8705864" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: this is a possibly dangerous operation; do &lt;strong&gt;not&lt;/strong&gt; use it unless you understand what it does. If you clone your repository using this option and then delete branches (or use any other Git command that makes any existing commit unreferenced) in the source repository, some objects may become unreferenced (or dangling). These objects may be removed by normal Git operations (such as &lt;code&gt;git commit&lt;/code&gt;) which automatically call &lt;code&gt;git maintenance run --auto&lt;/code&gt;. (See &lt;a href=&quot;git-maintenance&quot;&gt;git-maintenance[1]&lt;/a&gt;.) If these objects are removed and were referenced by the cloned repository, then the cloned repository will become corrupt.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这可能是危险的操作；你&lt;strong&gt;不&lt;/strong&gt;，除非你了解它使用它。如果使用此选项克隆存储库，然后在源存储库中删除分支（或使用任何其他Git命令使所有现有提交变为未引用），则某些对象可能会变为未引用（或悬空）。可以通过正常的Git操作（例如 &lt;code&gt;git commit&lt;/code&gt; ）删除这些对象，这些操作会自动调用 &lt;code&gt;git maintenance run --auto&lt;/code&gt; 。 （请参阅&lt;a href=&quot;git-maintenance&quot;&gt;git-maintenance [1]&lt;/a&gt;。）如果删除了这些对象并由克隆的存储库引用了这些对象，则克隆的存储库将损坏。</target>
        </trans-unit>
        <trans-unit id="7c66780d5bfd012adc7033c6c0a4c5d63ded1f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; gitk (unlike &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;) currently only understands this option if you specify it &quot;glued together&quot; with its argument. Do &lt;strong&gt;not&lt;/strong&gt; put a space after &lt;code&gt;-L&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; gitk（与&lt;a href=&quot;git-log&quot;&gt;git-log [1]不同&lt;/a&gt;）仅在您将其选项与参数&amp;ldquo;粘合&amp;rdquo;在一起时才理解此选项。难道&lt;strong&gt;不是&lt;/strong&gt;后加一个空格 &lt;code&gt;-L&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55897d0bbd0f3ca4e5eda8d2fd483ad8d798dcb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that no feature is overridable by default.</source>
          <target state="translated">&lt;strong&gt;请注意&lt;/strong&gt;，默认情况下没有功能可以覆盖。</target>
        </trans-unit>
        <trans-unit id="02ea3f041b0ba373c69cf48b5644925866c5ecea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that rename and especially copy detection can be quite CPU-intensive. Note also that non Git tools can have problems with patches generated with options mentioned above, especially when they involve file copies ('-C') or criss-cross renames ('-B').</source>
          <target state="translated">&lt;strong&gt;请注意&lt;/strong&gt;，重命名（尤其是复制检测）可能会占用大量CPU。还要注意，非Git工具在使用上述选项生成的补丁程序中可能会有问题，尤其是当它们涉及文件副本（'-C'）或纵横交错的重命名（'-B'）时。</target>
        </trans-unit>
        <trans-unit id="902c07c8249a8df193537556ae95a34d36a6294b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that this requires to be set for each request, so either &lt;code&gt;$per_request_config&lt;/code&gt; must be false, or the above must be put in code referenced by &lt;code&gt;$per_request_config&lt;/code&gt;;</source>
          <target state="translated">&lt;strong&gt;请注意&lt;/strong&gt;，这需要为每个请求设置，因此 &lt;code&gt;$per_request_config&lt;/code&gt; 必须为false，或者以上内容必须放入 &lt;code&gt;$per_request_config&lt;/code&gt; 引用的代码中；</target>
        </trans-unit>
        <trans-unit id="e45e1902bb87b0712f0e2420e234000a3f2ef680" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Also you can have a plain text file &lt;code&gt;.git&lt;/code&gt; at the root of your working tree, containing &lt;code&gt;gitdir: &amp;lt;path&amp;gt;&lt;/code&gt; to point at the real directory that has the repository. This mechanism is often used for a working tree of a submodule checkout, to allow you in the containing superproject to &lt;code&gt;git checkout&lt;/code&gt; a branch that does not have the submodule. The &lt;code&gt;checkout&lt;/code&gt; has to remove the entire submodule working tree, without losing the submodule repository.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：另外，您还可以在工作树的根 &lt;code&gt;.git&lt;/code&gt; 中具有纯文本文件.git，其中包含 &lt;code&gt;gitdir: &amp;lt;path&amp;gt;&lt;/code&gt; 指向具有存储库的真实目录。此机制通常用于子模块检出的工作树，以允许您在包含的超级项目中 &lt;code&gt;git checkout&lt;/code&gt; 没有子模块的分支。该 &lt;code&gt;checkout&lt;/code&gt; 有权删除整个子模块的工作树，又不失子模块库。</target>
        </trans-unit>
        <trans-unit id="71fa00b64eae5b5c3890d9bb37bfa403b32cff82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: there is also a legacy &lt;code&gt;$stylesheet&lt;/code&gt; configuration variable, which was used by older gitweb. If &lt;code&gt;$stylesheet&lt;/code&gt; variable is defined, only CSS stylesheet given by this variable is used by gitweb.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：还有一个旧的 &lt;code&gt;$stylesheet&lt;/code&gt; 配置变量，该变量由较旧的gitweb使用。如果定义了 &lt;code&gt;$stylesheet&lt;/code&gt; 变量，则gitweb仅使用此变量给定的CSS样式表。</target>
        </trans-unit>
        <trans-unit id="22d7c2a95cf98eb3222f8ef736d4c5d7e8f5f3e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notice&lt;/strong&gt; that in this case you don&amp;rsquo;t need special settings for &lt;code&gt;@stylesheets&lt;/code&gt;, &lt;code&gt;$my_uri&lt;/code&gt; and &lt;code&gt;$home_link&lt;/code&gt;, but you lose &quot;dumb client&quot; access to your project .git dirs (described in &quot;Single URL for gitweb and for fetching&quot; section). A possible workaround for the latter is the following: in your project root dir (e.g. &lt;code&gt;/pub/git&lt;/code&gt;) have the projects named &lt;strong&gt;without&lt;/strong&gt; a .git extension (e.g. &lt;code&gt;/pub/git/project&lt;/code&gt; instead of &lt;code&gt;/pub/git/project.git&lt;/code&gt;) and configure Apache as follows:</source>
          <target state="translated">&lt;strong&gt;请注意&lt;/strong&gt;，在这种情况下，您不需要为 &lt;code&gt;@stylesheets&lt;/code&gt; ， &lt;code&gt;$my_uri&lt;/code&gt; 和 &lt;code&gt;$home_link&lt;/code&gt; 进行特殊设置，但是您将失去对项目.git dirs的&amp;ldquo;哑客户端&amp;rdquo;访问权限（在&amp;ldquo;用于gitweb和获取的单个URL&amp;rdquo;部分中进行了描述） 。后者的可能解决方法如下：在项目的根目录（例如 &lt;code&gt;/pub/git&lt;/code&gt; ）中，将项目命名为&lt;strong&gt;不&lt;/strong&gt;带.git扩展名（例如 &lt;code&gt;/pub/git/project&lt;/code&gt; 而不是 &lt;code&gt;/pub/git/project.git&lt;/code&gt; ）并按以下方式配置Apache：</target>
        </trans-unit>
        <trans-unit id="07043eaeaff4821b6e3d2bf0596ce3d880d9918c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Parent:&lt;/strong&gt; All files immediately inside a directory are included.</source>
          <target state="translated">&lt;strong&gt;父级：&lt;/strong&gt;包括目录内的所有文件。</target>
        </trans-unit>
        <trans-unit id="32959a6518e6c4e84b5303e691c25180330dfdcb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Recursive:&lt;/strong&gt; All paths inside a directory are included.</source>
          <target state="translated">&lt;strong&gt;递归：&lt;/strong&gt;包含目录内的所有路径。</target>
        </trans-unit>
        <trans-unit id="e44ad2e7b5c600612a0a8797303bea45f315c6d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; for certain situations the import leads to incorrect results. Please see the section &lt;a href=&quot;#issues&quot;&gt;ISSUES&lt;/a&gt; for further reference.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;在某些情况下，导入会导致错误的结果。请参阅&amp;ldquo; &lt;a href=&quot;#issues&quot;&gt;问题&lt;/a&gt; &amp;rdquo;部分以获取更多参考。</target>
        </trans-unit>
        <trans-unit id="a9194839c57ad7da4a8bab5e0d40ab32351d35b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt;&lt;code&gt;git cvsimport&lt;/code&gt; uses cvsps version 2, which is considered deprecated; it does not work with cvsps version 3 and later. If you are performing a one-shot import of a CVS repository consider using &lt;a href=&quot;http://cvs2svn.tigris.org/cvs2git.html&quot;&gt;cvs2git&lt;/a&gt; or &lt;a href=&quot;http://www.catb.org/esr/cvs-fast-export/&quot;&gt;cvs-fast-export&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt; &lt;code&gt;git cvsimport&lt;/code&gt; 使用cvsps版本2，该版本已被弃用；它不适用于cvsps版本3和更高版本。如果要一次性导入CVS存储库，请考虑使用&lt;a href=&quot;http://cvs2svn.tigris.org/cvs2git.html&quot;&gt;cvs2git&lt;/a&gt;或&lt;a href=&quot;http://www.catb.org/esr/cvs-fast-export/&quot;&gt;cvs-fast-export&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="56bcd3ed1b5437dcaa0e279477dd7d4ed74ad36f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;! The rewritten history will have different object names for all the objects and will not converge with the original branch. You will not be able to easily push and distribute the rewritten branch on top of the original branch. Please do not use this command if you do not know the full implications, and avoid using it anyway, if a simple single commit would suffice to fix your problem. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for further information about rewriting published history.)</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;！重写的历史记录将为所有对象使用不同的对象名称，并且不会与原始分支收敛。您将无法轻松地将重写的分支推送并分发到原始分支的顶部。如果您不了解全部含义，请不要使用此命令；如果简单的一次提交就可以解决您的问题，请不要使用此命令。（有关重写已发布历史的更多信息，请参见&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]中&lt;/a&gt;的&amp;ldquo;从UPSTREAM REBASE恢复&amp;rdquo;一节。）</target>
        </trans-unit>
        <trans-unit id="1c57eef2952dcc7cbcb3f3594949c7f400ccd82e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Running &lt;code&gt;git merge&lt;/code&gt; with non-trivial uncommitted changes is discouraged: while possible, it may leave you in a state that is hard to back out of in the case of a conflict.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：不建议运行 &lt;code&gt;git merge&lt;/code&gt; 并进行重要的未提交更改：尽管有可能，但如果发生冲突，可能会使您处于难以退缩的状态。</target>
        </trans-unit>
        <trans-unit id="5bab61eb53176449e25c2c82f172b82cb13ffb9d" translate="yes" xml:space="preserve">
          <source>?</source>
          <target state="translated">?</target>
        </trans-unit>
        <trans-unit id="2e41f73876997d3719c74ffacd713f8bedda0ef1" translate="yes" xml:space="preserve">
          <source>@diff_opts</source>
          <target state="translated">@diff_opts</target>
        </trans-unit>
        <trans-unit id="ece9251682dfe6d86397776eeae7c5bceec968bb" translate="yes" xml:space="preserve">
          <source>@extra_breadcrumbs</source>
          <target state="translated">@extra_breadcrumbs</target>
        </trans-unit>
        <trans-unit id="d642d6b3afbdc1fe579a545767dd08c49fb22d26" translate="yes" xml:space="preserve">
          <source>@git_base_url_list</source>
          <target state="translated">@git_base_url_list</target>
        </trans-unit>
        <trans-unit id="d1cb9d322cf309d895cfe28288e26547a4f2023b" translate="yes" xml:space="preserve">
          <source>@stylesheets</source>
          <target state="translated">@stylesheets</target>
        </trans-unit>
        <trans-unit id="17f8f0c63a0ac553bacb3cc13b4bba7ffe3a1b0c" translate="yes" xml:space="preserve">
          <source>A &quot;blob&quot; is just file data, which we can also examine with cat-file:</source>
          <target state="translated">&quot;blob &quot;就是文件数据,我们也可以用cat-file来检查。</target>
        </trans-unit>
        <trans-unit id="48346c16ecaa075a67739766a897040a2f3413ba" translate="yes" xml:space="preserve">
          <source>A &quot;blob&quot; object is nothing but a binary blob of data. It doesn&amp;rsquo;t refer to anything else or have attributes of any kind.</source>
          <target state="translated">&amp;ldquo; blob&amp;rdquo;对象不过是二进制数据blob。它没有引用任何其他内容或具有任何种类的属性。</target>
        </trans-unit>
        <trans-unit id="fffc79f737d10e95dda9a92d156263709aad0d05" translate="yes" xml:space="preserve">
          <source>A &quot;branch&quot; is a line of development. The most recent &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; on a branch is referred to as the tip of that branch. The tip of the branch is referenced by a branch &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;, which moves forward as additional development is done on the branch. A single Git &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; can track an arbitrary number of branches, but your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is associated with just one of them (the &quot;current&quot; or &quot;checked out&quot; branch), and &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; points to that branch.</source>
          <target state="translated">&amp;ldquo;分支&amp;rdquo;是一条发展线。分支上的最新&lt;a href=&quot;#def_commit&quot;&gt;提交&lt;/a&gt;称为该分支的尖端。分支的尖端由分支&lt;a href=&quot;#def_head&quot;&gt;头&lt;/a&gt;引用，该分支随着分支上的其他开发工作而前进。一个Git&lt;a href=&quot;#def_repository&quot;&gt;存储库&lt;/a&gt;可以跟踪任意数量的分支，但是您的&lt;a href=&quot;#def_working_tree&quot;&gt;工作树&lt;/a&gt;仅与其中一个分支（&amp;ldquo;当前&amp;rdquo;或&amp;ldquo;已签出&amp;rdquo;分支）相关联，并且&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;指向该分支。</target>
        </trans-unit>
        <trans-unit id="78bff4978d5abc6efec633665a6a6e240b98928c" translate="yes" xml:space="preserve">
          <source>A &quot;branch&quot; is an active line of development. The most recent &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; on a branch is referred to as the tip of that branch. The tip of the branch is referenced by a branch &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;, which moves forward as additional development is done on the branch. A single Git &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; can track an arbitrary number of branches, but your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is associated with just one of them (the &quot;current&quot; or &quot;checked out&quot; branch), and &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; points to that branch.</source>
          <target state="translated">&amp;ldquo;分支机构&amp;rdquo;是积极的发展路线。分支上的最新&lt;a href=&quot;#def_commit&quot;&gt;提交&lt;/a&gt;称为该分支的尖端。分支的尖端由一个分支&lt;a href=&quot;#def_head&quot;&gt;头&lt;/a&gt;引用，该分支头随着分支上的其他开发工作而前进。一个Git &lt;a href=&quot;#def_repository&quot;&gt;存储库&lt;/a&gt;可以跟踪任意数量的分支，但是您的&lt;a href=&quot;#def_working_tree&quot;&gt;工作树&lt;/a&gt;仅与其中一个分支（&amp;ldquo;当前&amp;rdquo;或&amp;ldquo;已签出&amp;rdquo;分支）相关联，并且&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;指向该分支。</target>
        </trans-unit>
        <trans-unit id="a01578f0bd22457eb0af668d78f12e9483b4aa95" translate="yes" xml:space="preserve">
          <source>A &quot;combined diff&quot; format looks like this:</source>
          <target state="translated">一个 &quot;组合差异 &quot;的格式是这样的。</target>
        </trans-unit>
        <trans-unit id="3fd53e12d383c6d235aea40bfa1170ca1c16d64c" translate="yes" xml:space="preserve">
          <source>A &quot;light&quot; tag is technically nothing more than a branch, except we put it in the &lt;code&gt;.git/refs/tags/&lt;/code&gt; subdirectory instead of calling it a &lt;code&gt;head&lt;/code&gt;. So the simplest form of tag involves nothing more than</source>
          <target state="translated">从技术上讲，&amp;ldquo;轻&amp;rdquo;标签只是一个分支，只是我们将其放在 &lt;code&gt;.git/refs/tags/&lt;/code&gt; 子目录中，而不是将其称为 &lt;code&gt;head&lt;/code&gt; 。因此，最简单的标签形式仅涉及</target>
        </trans-unit>
        <trans-unit id="79a6a59906f3a3c6cb0aaa94c5e091d6ff4d2697" translate="yes" xml:space="preserve">
          <source>A &quot;patch ID&quot; is nothing but a sum of SHA-1 of the file diffs associated with a patch, with whitespace and line numbers ignored. As such, it&amp;rsquo;s &quot;reasonably stable&quot;, but at the same time also reasonably unique, i.e., two patches that have the same &quot;patch ID&quot; are almost guaranteed to be the same thing.</source>
          <target state="translated">&amp;ldquo;补丁程序ID&amp;rdquo;不过是与补丁程序相关的文件差异的SHA-1之和，忽略了空格和行号。这样，它是&amp;ldquo;合理稳定的&amp;rdquo;，但同时也具有合理的唯一性，即，具有相同&amp;ldquo;补丁ID&amp;rdquo;的两个补丁几乎可以保证是同一对象。</target>
        </trans-unit>
        <trans-unit id="12c2193bcd0be75dda12f0549bb6c953d953abdc" translate="yes" xml:space="preserve">
          <source>A &quot;proxy command&quot; to execute (as &lt;code&gt;command host port&lt;/code&gt;) instead of establishing direct connection to the remote server when using the Git protocol for fetching. If the variable value is in the &quot;COMMAND for DOMAIN&quot; format, the command is applied only on hostnames ending with the specified domain string. This variable may be set multiple times and is matched in the given order; the first match wins.</source>
          <target state="translated">使用Git协议进行抓取时，要执行&amp;ldquo;代理命令&amp;rdquo;（作为 &lt;code&gt;command host port&lt;/code&gt; ），而不是建立与远程服务器的直接连接。如果变量值为&amp;ldquo; COMMAND for DOMAIN&amp;rdquo;格式，则该命令仅适用于以指定域字符串结尾的主机名。可以多次设置此变量，并按给定顺序进行匹配；第一场比赛获胜。</target>
        </trans-unit>
        <trans-unit id="b4f3117f71091d9312b93d71f6f1f95e92690216" translate="yes" xml:space="preserve">
          <source>A &quot;refspec&quot; is used by &lt;a href=&quot;#def_fetch&quot;&gt;fetch&lt;/a&gt; and &lt;a href=&quot;#def_push&quot;&gt;push&lt;/a&gt; to describe the mapping between remote &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; and local ref.</source>
          <target state="translated">&lt;a href=&quot;#def_fetch&quot;&gt;提取&lt;/a&gt;和&lt;a href=&quot;#def_push&quot;&gt;推送&lt;/a&gt;使用&amp;ldquo; refspec&amp;rdquo; 来描述远程&lt;a href=&quot;#def_ref&quot;&gt;引用&lt;/a&gt;和本地引用之间的映射。</target>
        </trans-unit>
        <trans-unit id="d877d63b6b5e9d7da0337dffb75c191c08f97905" translate="yes" xml:space="preserve">
          <source>A &quot;release&quot; tree into which tested patches are moved for final sanity checking, and as a vehicle to send them upstream to Linus (by sending him a &quot;please pull&quot; request.)</source>
          <target state="translated">一棵 &quot;发布 &quot;树,经过测试的补丁将被移入其中进行最后的安全检查,并作为将它们发送到上游的Linus的工具(通过向他发送 &quot;请拉 &quot;请求)。</target>
        </trans-unit>
        <trans-unit id="5ff4d6ad0b357610ea5d99a54033d43fa5c5c86c" translate="yes" xml:space="preserve">
          <source>A &quot;test&quot; tree into which patches are initially placed so that they can get some exposure when integrated with other ongoing development. This tree is available to Andrew for pulling into -mm whenever he wants.</source>
          <target state="translated">一棵 &quot;测试 &quot;树,补丁会被放入其中,以便它们在与其他正在进行的开发整合时能够得到一些曝光。安德鲁可以随时将这棵树拉入-mm中。</target>
        </trans-unit>
        <trans-unit id="b1289678cb38397cef5e65878a2c6bc1fc5330f7" translate="yes" xml:space="preserve">
          <source>A &amp;lt;refspec&amp;gt; may contain a &lt;code&gt;*&lt;/code&gt; in its &amp;lt;src&amp;gt; to indicate a simple pattern match. Such a refspec functions like a glob that matches any ref with the same prefix. A pattern &amp;lt;refspec&amp;gt; must have a &lt;code&gt;*&lt;/code&gt; in both the &amp;lt;src&amp;gt; and &amp;lt;dst&amp;gt;. It will map refs to the destination by replacing the &lt;code&gt;*&lt;/code&gt; with the contents matched from the source.</source>
          <target state="translated">&amp;lt;refspec&amp;gt;的&amp;lt;src &amp;gt;中可能包含 &lt;code&gt;*&lt;/code&gt; ，表示简单的模式匹配。这样的refspec就像glob一样，可以匹配具有相同前缀的所有ref。模式&amp;lt;refspec&amp;gt;的&amp;lt;src&amp;gt;和&amp;lt;dst&amp;gt;都必须带有 &lt;code&gt;*&lt;/code&gt; 。通过将 &lt;code&gt;*&lt;/code&gt; 替换为源中匹配的内容，它将引用映射到目标。</target>
        </trans-unit>
        <trans-unit id="f3ec64c5418b4e1b2393cccdbc573a28510a5c03" translate="yes" xml:space="preserve">
          <source>A 1-based counter incremented by one for every path.</source>
          <target state="translated">以1为基础的计数器,每条路径递增1。</target>
        </trans-unit>
        <trans-unit id="0615d3cb94994b8c99f6c3eb1d8a16fe3788d798" translate="yes" xml:space="preserve">
          <source>A 256-entry fan-out table just like v1.</source>
          <target state="translated">和v1一样的256进扇形台。</target>
        </trans-unit>
        <trans-unit id="b5bb9a8b1ee368142624185fa1ae5c67aeb898ce" translate="yes" xml:space="preserve">
          <source>A 4-byte magic number &lt;code&gt;\377tOc&lt;/code&gt; which is an unreasonable fanout[0] value.</source>
          <target state="translated">一个4字节的幻数 &lt;code&gt;\377tOc&lt;/code&gt; ，这是一个不合理的fanout [0]值。</target>
        </trans-unit>
        <trans-unit id="7a1ce6a5d795c5121faecb5f38bcdfbcd91b2ab7" translate="yes" xml:space="preserve">
          <source>A 4-byte version number (= 2)</source>
          <target state="translated">4个字节的版本号(=2)</target>
        </trans-unit>
        <trans-unit id="8bede587e880e37efdb2a5ef16eda4ba90c67697" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_blob_object&quot;&gt;&quot;blob&quot; object&lt;/a&gt; is used to store file data.</source>
          <target state="translated">阿&lt;a href=&quot;#def_blob_object&quot;&gt;&amp;ldquo;斑点&amp;rdquo;对象&lt;/a&gt;被用于存储文件数据。</target>
        </trans-unit>
        <trans-unit id="d54288b35ef53475c72a23d4daf82b2c03c4a8f0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_commit_object&quot;&gt;&quot;commit&quot; object&lt;/a&gt; ties such directory hierarchies together into a &lt;a href=&quot;#def_DAG&quot;&gt;directed acyclic graph&lt;/a&gt; of revisions&amp;mdash;​each commit contains the object name of exactly one tree designating the directory hierarchy at the time of the commit. In addition, a commit refers to &quot;parent&quot; commit objects that describe the history of how we arrived at that directory hierarchy.</source>
          <target state="translated">一个&lt;a href=&quot;#def_commit_object&quot;&gt;``提交''对象&lt;/a&gt;将这样的目录层次结构捆绑在一起，形成有&lt;a href=&quot;#def_DAG&quot;&gt;向&lt;/a&gt;修订的有向无环图 -每个提交都包含恰好在提交时指定目录层次结构的一棵树的对象名称。另外，提交是指&amp;ldquo;父&amp;rdquo;提交对象，这些对象描述了我们如何到达该目录层次结构的历史。</target>
        </trans-unit>
        <trans-unit id="8530617aaaf740a14961ad3389fd991b174e36b0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt; contains a (possibly empty) list of the logical predecessor(s) in the line of development, i.e. its parents.</source>
          <target state="translated">一个&lt;a href=&quot;#def_commit_object&quot;&gt;commit对象&lt;/a&gt;包含在发展线的逻辑前身的（可能为空）列表（S），即其父母。</target>
        </trans-unit>
        <trans-unit id="cb0f59568c969c04ae2919aa1276ec43b776c9bd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt; or an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; that can be recursively dereferenced to a commit object. The following are all commit-ishes: a commit object, a &lt;a href=&quot;#def_tag_object&quot;&gt;tag object&lt;/a&gt; that points to a commit object, a tag object that points to a tag object that points to a commit object, etc.</source>
          <target state="translated">甲&lt;a href=&quot;#def_commit_object&quot;&gt;commit对象&lt;/a&gt;或一个&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;可以被递归地解除引用到一个提交对象。以下是所有提交-ishes：提交对象，&lt;a href=&quot;#def_tag_object&quot;&gt;标签对象&lt;/a&gt;是指向一个commit对象，标签对象指向一个标签对象指向一个commit对象，等等。</target>
        </trans-unit>
        <trans-unit id="e6389313e21c94c3cd1f531678dbaff3d7f4b17f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;named reference&lt;/a&gt; to the &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; at the tip of a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. Heads are stored in a file in &lt;code&gt;$GIT_DIR/refs/heads/&lt;/code&gt; directory, except when using packed refs. (See &lt;a href=&quot;git-pack-refs&quot;&gt;git-pack-refs[1]&lt;/a&gt;.)</source>
          <target state="translated">甲&lt;a href=&quot;#def_ref&quot;&gt;命名引用&lt;/a&gt;到&lt;a href=&quot;#def_commit&quot;&gt;提交&lt;/a&gt;在尖端&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;。头存储在 &lt;code&gt;$GIT_DIR/refs/heads/&lt;/code&gt; 目录中的文件中，除非使用打包的引用。（请参阅&lt;a href=&quot;git-pack-refs&quot;&gt;git-pack-refs [1]&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="0b389d584563a677fb26744bbc70caa1d1f76e96" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; that is used to follow changes from another &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. It typically looks like 'refs/remotes/foo/bar' (indicating that it tracks a branch named 'bar' in a remote named 'foo'), and matches the right-hand-side of a configured fetch &lt;a href=&quot;#def_refspec&quot;&gt;refspec&lt;/a&gt;. A remote-tracking branch should not contain direct modifications or have local commits made to it.</source>
          <target state="translated">一个&lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt;用来跟随另一个&lt;a href=&quot;#def_repository&quot;&gt;仓库的&lt;/a&gt;变化。它通常看起来像'refs / remotes / foo / bar'（表明它在名为'foo'的远程目录中跟踪了名为'bar'的分支），并且与已配置的&lt;a href=&quot;#def_refspec&quot;&gt;fref refspec&lt;/a&gt;的右侧匹配。远程跟踪分支不应包含直接修改或对其进行本地提交。</target>
        </trans-unit>
        <trans-unit id="ace242fdc7f696a4feaa54f7241c321210896890" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; that is used to follow changes from another &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. It typically looks like &lt;code&gt;refs/remotes/foo/bar&lt;/code&gt; (indicating that it tracks a branch named &lt;code&gt;bar&lt;/code&gt; in a remote named &lt;code&gt;foo&lt;/code&gt;), and matches the right-hand-side of a configured fetch &lt;a href=&quot;#def_refspec&quot;&gt;refspec&lt;/a&gt;. A remote-tracking branch should not contain direct modifications or have local commits made to it.</source>
          <target state="translated">一个&lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt;用来跟随另一个&lt;a href=&quot;#def_repository&quot;&gt;仓库的&lt;/a&gt;变化。它通常看起来像 &lt;code&gt;refs/remotes/foo/bar&lt;/code&gt; （表明它在名为 &lt;code&gt;foo&lt;/code&gt; 的远程目录中跟踪名为 &lt;code&gt;bar&lt;/code&gt; 的分支），并且与已配置的&lt;a href=&quot;#def_refspec&quot;&gt;fref refspec&lt;/a&gt;的右侧匹配。远程跟踪分支不应包含直接修改或对其进行本地提交。</target>
        </trans-unit>
        <trans-unit id="bbf1d644e82a336ab047afaf23e6c38f6d2319f7" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; under &lt;code&gt;refs/tags/&lt;/code&gt; namespace that points to an object of an arbitrary type (typically a tag points to either a &lt;a href=&quot;#def_tag_object&quot;&gt;tag&lt;/a&gt; or a &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;). In contrast to a &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;, a tag is not updated by the &lt;code&gt;commit&lt;/code&gt; command. A Git tag has nothing to do with a Lisp tag (which would be called an &lt;a href=&quot;#def_object_type&quot;&gt;object type&lt;/a&gt; in Git&amp;rsquo;s context). A tag is most typically used to mark a particular point in the commit ancestry &lt;a href=&quot;#def_chain&quot;&gt;chain&lt;/a&gt;.</source>
          <target state="translated">甲&lt;a href=&quot;#def_ref&quot;&gt;REF&lt;/a&gt;下 &lt;code&gt;refs/tags/&lt;/code&gt; 命名空间点到任意类型的对象（通常是标记指向任一个&lt;a href=&quot;#def_tag_object&quot;&gt;标签&lt;/a&gt;或一个&lt;a href=&quot;#def_commit_object&quot;&gt;commit对象&lt;/a&gt;）。与&lt;a href=&quot;#def_head&quot;&gt;head相比&lt;/a&gt;， &lt;code&gt;commit&lt;/code&gt; 命令不会更新标签。Git标记与Lisp标记（在Git的上下文中称为&lt;a href=&quot;#def_object_type&quot;&gt;对象类型&lt;/a&gt;）无关。标签最通常用于标记提交祖先&lt;a href=&quot;#def_chain&quot;&gt;链中&lt;/a&gt;的特定点。</target>
        </trans-unit>
        <trans-unit id="fc46cfe77ce6b43ff04fe1e7aebea708602c159d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; that holds the history of a separate project inside another repository (the latter of which is called &lt;a href=&quot;#def_superproject&quot;&gt;superproject&lt;/a&gt;).</source>
          <target state="translated">一个&lt;a href=&quot;#def_repository&quot;&gt;存储库&lt;/a&gt;，用于保存另一个存储库中另一个项目的历史（另一个存储库称为&lt;a href=&quot;#def_superproject&quot;&gt;superproject&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6438f4d0a1f63f0722cdeaf18b4e76a69d1faf0a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; that references repositories of other projects in its working tree as &lt;a href=&quot;#def_submodule&quot;&gt;submodules&lt;/a&gt;. The superproject knows about the names of (but does not hold copies of) commit objects of the contained submodules.</source>
          <target state="translated">一个&lt;a href=&quot;#def_repository&quot;&gt;仓库&lt;/a&gt;，在其工作树作为参考其它项目库&lt;a href=&quot;#def_submodule&quot;&gt;子模块&lt;/a&gt;。超级项目知道所包含子模块的提交对象的名称（但不保存其副本）。</target>
        </trans-unit>
        <trans-unit id="0c5fd39e912fa9dd55cd15e3992de80c831bb2a4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; which is used to track the same project but resides somewhere else. To communicate with remotes, see &lt;a href=&quot;#def_fetch&quot;&gt;fetch&lt;/a&gt; or &lt;a href=&quot;#def_push&quot;&gt;push&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;#def_repository&quot;&gt;仓库&lt;/a&gt;，用来跟踪同一项目，但居住在其他地方。要与遥控器通信，请参阅&lt;a href=&quot;#def_fetch&quot;&gt;提取&lt;/a&gt;或&lt;a href=&quot;#def_push&quot;&gt;推送&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="328013b8812fa91caece6ff64eff68b5bce54efc" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_shallow_clone&quot;&gt;shallow clone&lt;/a&gt; is created by specifying the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;&lt;code&gt;--depth&lt;/code&gt; switch. The depth can later be changed with the &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;&lt;code&gt;--depth&lt;/code&gt; switch, or full history restored with &lt;code&gt;--unshallow&lt;/code&gt;.</source>
          <target state="translated">甲&lt;a href=&quot;#def_shallow_clone&quot;&gt;浅克隆&lt;/a&gt;是通过指定所创建的&lt;a href=&quot;git-clone&quot;&gt;GIT中克隆[1] &lt;/a&gt; &lt;code&gt;--depth&lt;/code&gt; 开关。以后可以使用&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1] &lt;/a&gt; &lt;code&gt;--depth&lt;/code&gt; 开关更改深度，或者使用 &lt;code&gt;--unshallow&lt;/code&gt; 恢复完整历史记录。</target>
        </trans-unit>
        <trans-unit id="4f6e57120855e95e9e182d5d994eedc42293e0e9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_shallow_clone&quot;&gt;shallow clone&lt;/a&gt;, with its truncated history, is useful when one is interested only in recent history of a project and getting full history from the upstream is expensive.</source>
          <target state="translated">如果只对项目的最新历史感兴趣，而从上游获取完整历史记录则很昂贵，那么&lt;a href=&quot;#def_shallow_clone&quot;&gt;浅浅的克隆&lt;/a&gt;及其历史将被截断。</target>
        </trans-unit>
        <trans-unit id="5a5040a665f644abaf265d1f9e647b81d27b4cfd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_tag_object&quot;&gt;&quot;tag&quot; object&lt;/a&gt; symbolically identifies and can be used to sign other objects. It contains the object name and type of another object, a symbolic name (of course!) and, optionally, a signature.</source>
          <target state="translated">阿&lt;a href=&quot;#def_tag_object&quot;&gt;&amp;ldquo;标签&amp;rdquo;对象&lt;/a&gt;象征性地识别并可以被用于签署的其他对象。它包含对象名称和另一个对象的类型，符号名称（当然！）以及（可选）签名。</target>
        </trans-unit>
        <trans-unit id="300bf6998ca24b2549892a071c929ed803f223bb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_tree_object&quot;&gt;&quot;tree&quot; object&lt;/a&gt; ties one or more &quot;blob&quot; objects into a directory structure. In addition, a tree object can refer to other tree objects, thus creating a directory hierarchy.</source>
          <target state="translated">一个&lt;a href=&quot;#def_tree_object&quot;&gt;&amp;ldquo;树&amp;rdquo;对象&lt;/a&gt;联系一个或多个&amp;ldquo;斑点&amp;rdquo;对象到一个目录结构。另外，树对象可以引用其他树对象，从而创建目录层次结构。</target>
        </trans-unit>
        <trans-unit id="e7b0ce7b8c7522d74c7f9ad5ab8411731aaf299c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; or an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; that can be recursively dereferenced to a tree object. Dereferencing a &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt; yields the tree object corresponding to the &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;'s top &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt;. The following are all tree-ishes: a &lt;a href=&quot;#def_commit-ish&quot;&gt;commit-ish&lt;/a&gt;, a tree object, a &lt;a href=&quot;#def_tag_object&quot;&gt;tag object&lt;/a&gt; that points to a tree object, a tag object that points to a tag object that points to a tree object, etc.</source>
          <target state="translated">甲&lt;a href=&quot;#def_tree_object&quot;&gt;树对象&lt;/a&gt;或一个&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;可以被递归地解除引用到一个树的对象。取消引用&lt;a href=&quot;#def_commit_object&quot;&gt;提交对象将&lt;/a&gt;产生与&lt;a href=&quot;#def_revision&quot;&gt;修订版本&lt;/a&gt;的顶层&lt;a href=&quot;#def_directory&quot;&gt;目录&lt;/a&gt;相对应的树对象。以下是所有树ishes：一个&lt;a href=&quot;#def_commit-ish&quot;&gt;提交十岁上下&lt;/a&gt;，树对象，&lt;a href=&quot;#def_tag_object&quot;&gt;标签对象&lt;/a&gt;是指向一个树对象，标签对象指向一个标签对象指向一个树对象，等等。</target>
        </trans-unit>
        <trans-unit id="6766aaa194eae4342acb9b6eb8fe5dbb99ba5e2c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is clean, if it corresponds to the &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt; referenced by the current &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;. Also see &quot;&lt;a href=&quot;#def_dirty&quot;&gt;dirty&lt;/a&gt;&quot;.</source>
          <target state="translated">如果&lt;a href=&quot;#def_working_tree&quot;&gt;工作树&lt;/a&gt;与当前&lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;引用的&lt;a href=&quot;#def_revision&quot;&gt;修订&lt;/a&gt;相对应，则它是干净的。另请参阅&amp;ldquo; &lt;a href=&quot;#def_dirty&quot;&gt;脏&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="910148d563c361f2f9ac9396584595cbecacd2d1" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is said to be &quot;dirty&quot; if it contains modifications which have not been &lt;a href=&quot;#def_commit&quot;&gt;committed&lt;/a&gt; to the current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;#def_working_tree&quot;&gt;工作树&lt;/a&gt;包含尚未&lt;a href=&quot;#def_commit&quot;&gt;提交&lt;/a&gt;给当前&lt;a href=&quot;#def_branch&quot;&gt;分支的&lt;/a&gt;修改，则称该工作树为&amp;ldquo;脏&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="7cef23a772a587d1dc5174a039d5d2a56a2421b3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; string must use UNIX-style directory separators (forward slash &lt;code&gt;/&lt;/code&gt;), may contain any byte other than &lt;code&gt;LF&lt;/code&gt;, and must not start with double quote (&lt;code&gt;&quot;&lt;/code&gt;).</source>
          <target state="translated">一个 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 字符串必须使用UNIX样式的目录分隔符（正斜杠 &lt;code&gt;/&lt;/code&gt; ），可能含有比其他任何字节 &lt;code&gt;LF&lt;/code&gt; ，并不得与双引号（启动 &lt;code&gt;&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="25aaa39fff8a33da0ed231c681da2d1cc8f12d2e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; specification can be either a single pattern, or a pair of such patterns separated by a colon &quot;:&quot; (this means that a ref name cannot have a colon in it). A single pattern &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is just a shorthand for &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 规范可以是一个单一的图案，或一对这样的图案的由冒号&amp;ldquo;：&amp;rdquo;分隔（这意味着一个裁判名不能在它一个冒号）。单个模式 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 只是 &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="5e4a35cc1f6ad4a24fbad41012f4dee139cf11ca" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;-&lt;/code&gt; character in the column N means that the line appears in fileN but it does not appear in the result. A &lt;code&gt;+&lt;/code&gt; character in the column N means that the line appears in the result, and fileN does not have that line (in other words, the line was added, from the point of view of that parent).</source>
          <target state="translated">甲 &lt;code&gt;-&lt;/code&gt; 字符列中N表示该行中出现fileN但它不会出现在结果中。甲 &lt;code&gt;+&lt;/code&gt; 在列N表示该行中出现的结果，和fileN不具有行字符（换句话说，加入线，从该父的点）。</target>
        </trans-unit>
        <trans-unit id="2f763d8aeb342898c485136e58023ca41a911c41" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;fetch&lt;/code&gt; request can take the following arguments:</source>
          <target state="translated">一个 &lt;code&gt;fetch&lt;/code&gt; 请求可以采用下列参数：</target>
        </trans-unit>
        <trans-unit id="cdc49de55f827e970a03efc67dad77118b50f2b5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;filecopy&lt;/code&gt; command takes effect immediately. Once the source location has been copied to the destination any future commands applied to the source location will not impact the destination of the copy.</source>
          <target state="translated">一个 &lt;code&gt;filecopy&lt;/code&gt; 命令立即生效。将源位置复制到目标位置后，以后再应用到源位置的任何命令都不会影响副本的目标位置。</target>
        </trans-unit>
        <trans-unit id="4b84f934e1b33bd4484622bc003d74b0f10abf36" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;filerename&lt;/code&gt; command takes effect immediately. Once the source location has been renamed to the destination any future commands applied to the source location will create new files there and not impact the destination of the rename.</source>
          <target state="translated">一个 &lt;code&gt;filerename&lt;/code&gt; 命令立即生效。一旦将源位置重命名为目标位置，则任何将来应用于该源位置的命令都将在该位置创建新文件，并且不会影响重命名的目标位置。</target>
        </trans-unit>
        <trans-unit id="e7ce3d61d685b39ad1b7df023b9aae5356d34434" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;filter&lt;/code&gt; attribute can be set to a string value that names a filter driver specified in the configuration.</source>
          <target state="translated">甲 &lt;code&gt;filter&lt;/code&gt; 属性可以被设置为名称的过滤驱动器在配置中指定的字符串值。</target>
        </trans-unit>
        <trans-unit id="ca1b84b3e4f681759dcd049b031dfc1f3c0de5ed" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gitattributes&lt;/code&gt; file is a simple text file that gives &lt;code&gt;attributes&lt;/code&gt; to pathnames.</source>
          <target state="translated">一个 &lt;code&gt;gitattributes&lt;/code&gt; 文件是一个简单的文本文件，让 &lt;code&gt;attributes&lt;/code&gt; 到路径名。</target>
        </trans-unit>
        <trans-unit id="271f2fe7522d4b1b6340e70ddfeda05a8efa8336" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gitignore&lt;/code&gt; file ensures that certain file(s) which are not tracked by Git remain untracked. However, sometimes particular file(s) may have been tracked before adding them into the &lt;code&gt;.gitignore&lt;/code&gt;, hence they still remain tracked. To untrack and ignore files/patterns, use &lt;code&gt;git rm --cached &amp;lt;file/pattern&amp;gt;&lt;/code&gt; and add a pattern to &lt;code&gt;.gitignore&lt;/code&gt; that matches the &amp;lt;file&amp;gt;. See &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for details.</source>
          <target state="translated">甲 &lt;code&gt;gitignore&lt;/code&gt; 文件确保某些文件（一个或多个），其不通过GIT中跟踪保持未跟踪。但是，有时在将特定文件添加到 &lt;code&gt;.gitignore&lt;/code&gt; 之前已对其进行了跟踪，因此它们仍然保持跟踪状态。要取消跟踪并忽略文件/模式，请使用 &lt;code&gt;git rm --cached &amp;lt;file/pattern&amp;gt;&lt;/code&gt; 并向 &lt;code&gt;.gitignore&lt;/code&gt; 添加与&amp;lt;file&amp;gt;匹配的模式。有关详细信息，请参见&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d66ea4477ef0ba53ddd8e40294e2410ce0649ca9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gitignore&lt;/code&gt; file specifies intentionally untracked files that Git should ignore. Files already tracked by Git are not affected; see the NOTES below for details.</source>
          <target state="translated">一个 &lt;code&gt;gitignore&lt;/code&gt; 文件指定故意未跟踪文件的Git应该忽略。Git已经跟踪的文件不受影响；有关详细信息，请参见下面的注释。</target>
        </trans-unit>
        <trans-unit id="6e637494c00a4030e3a229e0cf561d46671742b0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;map&lt;/code&gt; function is available that takes an &quot;original sha1 id&quot; argument and outputs a &quot;rewritten sha1 id&quot; if the commit has been already rewritten, and &quot;original sha1 id&quot; otherwise; the &lt;code&gt;map&lt;/code&gt; function can return several ids on separate lines if your commit filter emitted multiple commits.</source>
          <target state="translated">可用的 &lt;code&gt;map&lt;/code&gt; 函数带有&amp;ldquo;原始sha1 id&amp;rdquo;参数，如果提交已经被重写，则输出&amp;ldquo;重写的sha1 id&amp;rdquo;，否则输出&amp;ldquo;原始sha1 id&amp;rdquo;；如果您的提交过滤器发出了多个提交，则 &lt;code&gt;map&lt;/code&gt; 函数可以在单独的行上返回多个ID。</target>
        </trans-unit>
        <trans-unit id="e0c17077eaabfda4b09416a4110316c7774b1c6b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;mark&lt;/code&gt; command may optionally appear, requesting fast-import to save a reference to the newly created commit for future use by the frontend (see below for format). It is very common for frontends to mark every commit they create, thereby allowing future branch creation from any imported commit.</source>
          <target state="translated">一个 &lt;code&gt;mark&lt;/code&gt; 命令可以有选择地出现，请求快速导入保存到新创建的一个参考承诺为将来由前端使用（见下文格式）。前端标记它们创建的每个提交非常普遍，从而允许将来从任何导入的提交创建分支。</target>
        </trans-unit>
        <trans-unit id="9b43e35048f39cc98d8056bd70595785c095f7f4" translate="yes" xml:space="preserve">
          <source>A CVS server emulator for Git</source>
          <target state="translated">一个用于Git的CVS服务器仿真器</target>
        </trans-unit>
        <trans-unit id="3e3ff03f4c98647bf647b09b5bdb954580631a8b" translate="yes" xml:space="preserve">
          <source>A Git Glossary</source>
          <target state="translated">Git词汇表</target>
        </trans-unit>
        <trans-unit id="73c6af424b5233a47f9e018124045fddd95ea342" translate="yes" xml:space="preserve">
          <source>A Git core tutorial for developers</source>
          <target state="translated">开发者的Git核心教程</target>
        </trans-unit>
        <trans-unit id="499e3b350610a0a7f42474bdeb7c1c19319ba58c" translate="yes" xml:space="preserve">
          <source>A Git project normally consists of a working directory with a &quot;.git&quot; subdirectory at the top level. The .git directory contains, among other things, a compressed object database representing the complete history of the project, an &quot;index&quot; file which links that history to the current contents of the working tree, and named pointers into that history such as tags and branch heads.</source>
          <target state="translated">一个Git项目通常由一个工作目录和一个顶层的&quot;.git &quot;子目录组成。.git目录中包含了一个压缩对象数据库,它代表了项目的完整历史,一个 &quot;索引 &quot;文件,它将历史与工作树的当前内容联系起来,以及进入历史的命名指针,如标签和分支头。</target>
        </trans-unit>
        <trans-unit id="25a40623b731bcb70270f3faeba427fe44362569" translate="yes" xml:space="preserve">
          <source>A Git repository comes in two different flavours:</source>
          <target state="translated">一个Git仓库有两种不同的味道。</target>
        </trans-unit>
        <trans-unit id="d81aa8115ce6f03214fb303ff61bdf68ead1b6d0" translate="yes" xml:space="preserve">
          <source>A GnuPG signed tag object will be created when &lt;code&gt;-s&lt;/code&gt; or &lt;code&gt;-u
&amp;lt;keyid&amp;gt;&lt;/code&gt; is used. When &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is not used, the committer identity for the current user is used to find the GnuPG key for signing. The configuration variable &lt;code&gt;gpg.program&lt;/code&gt; is used to specify custom GnuPG binary.</source>
          <target state="translated">当使用 &lt;code&gt;-s&lt;/code&gt; 或 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 时，将创建一个GnuPG签名标签对象。如果不使用 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; ,则使用当前用户的提交者身份来查找用于签名的GnuPG密钥。配置变量 &lt;code&gt;gpg.program&lt;/code&gt; 用于指定自定义GnuPG二进制文件。</target>
        </trans-unit>
        <trans-unit id="79ace8057741243c07f0a9c439ea72cf149ebea7" translate="yes" xml:space="preserve">
          <source>A POSIX Extended Regular Expression used to determine what is a &quot;word&quot; when performing word-by-word difference calculations. Character sequences that match the regular expression are &quot;words&quot;, all other characters are &lt;strong&gt;ignorable&lt;/strong&gt; whitespace.</source>
          <target state="translated">POSIX扩展正则表达式，用于在执行逐字差异计算时确定什么是&amp;ldquo;字&amp;rdquo;。与正则表达式匹配的字符序列是&amp;ldquo;单词&amp;rdquo;，所有其他字符都是可&lt;strong&gt;忽略的&lt;/strong&gt;空格。</target>
        </trans-unit>
        <trans-unit id="d4b36e18a0d1a006f1ac7d7980a588087d5b430d" translate="yes" xml:space="preserve">
          <source>A Tcl/Tk based graphical interface to review modified files, stage them into the index, enter a commit message and record the new commit onto the current branch. This interface is an alternative to the less interactive &lt;code&gt;git commit&lt;/code&gt; program.</source>
          <target state="translated">基于Tcl / Tk的图形界面，用于查看已修改的文件，将其暂存到索引中，输入提交消息并将新的提交记录到当前分支中。此接口是交互性较低的 &lt;code&gt;git commit&lt;/code&gt; 程序的替代方法。</target>
        </trans-unit>
        <trans-unit id="4b96204f8a09a4e60b67d30c184c76ab3aa13246" translate="yes" xml:space="preserve">
          <source>A Tcl/Tk based graphical user interface to Git. &lt;code&gt;git gui&lt;/code&gt; focuses on allowing users to make changes to their repository by making new commits, amending existing ones, creating branches, performing local merges, and fetching/pushing to remote repositories.</source>
          <target state="translated">一个基于Tcl / Tk的Git图形用户界面。 &lt;code&gt;git gui&lt;/code&gt; 专注于允许用户通过提交新提交，修改现有提交，创建分支，执行本地合并以及获取/推送到远程存储库来更改其存储库。</target>
        </trans-unit>
        <trans-unit id="24909c1b0660496a6bde046217501091c32d35a8" translate="yes" xml:space="preserve">
          <source>A URL identifying the server. Use an &lt;code&gt;imap://&lt;/code&gt; prefix for non-secure connections and an &lt;code&gt;imaps://&lt;/code&gt; prefix for secure connections. Ignored when imap.tunnel is set, but required otherwise.</source>
          <target state="translated">标识服务器的URL。对于非安全连接，请使用 &lt;code&gt;imap://&lt;/code&gt; 前缀，对于安全连接，请使用 &lt;code&gt;imaps://&lt;/code&gt; 前缀。设置imap.tunnel时将被忽略，但否则是必需的。</target>
        </trans-unit>
        <trans-unit id="11e4f1c46822a29c15a31d1976020e3202745e04" translate="yes" xml:space="preserve">
          <source>A URL of the form &lt;code&gt;&amp;lt;transport&amp;gt;::&amp;lt;address&amp;gt;&lt;/code&gt; explicitly instructs Git to invoke &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt; as the second argument. If such a URL is encountered directly on the command line, the first argument is &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt;, and if it is encountered in a configured remote, the first argument is the name of that remote.</source>
          <target state="translated">形式的URL &lt;code&gt;&amp;lt;transport&amp;gt;::&amp;lt;address&amp;gt;&lt;/code&gt; 明确地指示GIT中调用 &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; 与 &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt; 作为第二个参数。如果在命令行上直接遇到这样的URL，则第一个参数是 &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt; ，如果在已配置的远程中遇到它，则第一个参数是该远程的名称。</target>
        </trans-unit>
        <trans-unit id="bd88b7183354ef38e42a5694ea11c6ad40c90a63" translate="yes" xml:space="preserve">
          <source>A bare repository is normally an appropriately named &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt; with a &lt;code&gt;.git&lt;/code&gt; suffix that does not have a locally checked-out copy of any of the files under revision control. That is, all of the Git administrative and control files that would normally be present in the hidden &lt;code&gt;.git&lt;/code&gt; sub-directory are directly present in the &lt;code&gt;repository.git&lt;/code&gt; directory instead, and no other files are present and checked out. Usually publishers of public repositories make bare repositories available.</source>
          <target state="translated">裸存储库通常是带有 &lt;code&gt;.git&lt;/code&gt; 后缀的适当命名的&lt;a href=&quot;#def_directory&quot;&gt;目录&lt;/a&gt;，该目录没有受版本控制的任何文件的本地检出副本。也就是说，通常会出现在隐藏的 &lt;code&gt;.git&lt;/code&gt; 子目录中的所有Git管理和控制文件都直接存在于 &lt;code&gt;repository.git&lt;/code&gt; 目录中，而没有其他文件存在并检出。通常，公共存储库的发布者会提供裸存储库。</target>
        </trans-unit>
        <trans-unit id="fab59df7bed21e1355a3a3fdd6c1ee8b01aad2ba" translate="yes" xml:space="preserve">
          <source>A birds-eye view of Git&amp;rsquo;s source code</source>
          <target state="translated">鸟瞰Git的源代码</target>
        </trans-unit>
        <trans-unit id="23e4eeef8aa3fdcfbc58a9b30e01464d317f5146" translate="yes" xml:space="preserve">
          <source>A bit more elaborate report on tags, demonstrating that the format may be an entire script:</source>
          <target state="translated">关于标签的报告更详细一些,证明格式可能是一整个脚本。</target>
        </trans-unit>
        <trans-unit id="146b6a7f060c34e94845d66a1242bb6c9a7f4e58" translate="yes" xml:space="preserve">
          <source>A blank line matches no files, so it can serve as a separator for readability.</source>
          <target state="translated">空行不匹配任何文件,所以可以作为分隔符,方便阅读。</target>
        </trans-unit>
        <trans-unit id="556a519047d3c2b7e5ab74e824666155b316bdbf" translate="yes" xml:space="preserve">
          <source>A boolean or int to specify the level of verbose with &lt;code&gt;git commit&lt;/code&gt;. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">布尔值或整数值，用于指定 &lt;code&gt;git commit&lt;/code&gt; 的详细级别。参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df9e4313a71ccb8b0351ad99469fa4eb3f3f9ac9" translate="yes" xml:space="preserve">
          <source>A boolean that controls whether to generate a cover-letter when format-patch is invoked, but in addition can be set to &quot;auto&quot;, to generate a cover-letter only when there&amp;rsquo;s more than one patch. Default is false.</source>
          <target state="translated">一个布尔值，用于控制在调用format-patch时是否生成封面信，但可以将其设置为&amp;ldquo; auto&amp;rdquo;，仅在有多个修补程序时才生成封面信。默认为false。</target>
        </trans-unit>
        <trans-unit id="5594a28e2c0e4043dd1d1bbbff86fb17f935ca8e" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in hints (e.g. when a push failed, see &lt;code&gt;advice.*&lt;/code&gt; for a list). May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the error output goes to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">一个布尔值，用于在提示中启用/禁用颜色（例如，当推送失败时，请参阅 &lt;code&gt;advice.*&lt;/code&gt; 以获取列表）。可以设置为 &lt;code&gt;always&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; （或 &lt;code&gt;never&lt;/code&gt; ）或 &lt;code&gt;auto&lt;/code&gt; （或 &lt;code&gt;true&lt;/code&gt; ），在这种情况下，仅当错误输出到达终端时才使用颜色。如果未设置，则使用 &lt;code&gt;color.ui&lt;/code&gt; 的值（默认情况下为 &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2fbf675a2936dcecf3b1a2336c5df4b332604e58" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in push errors. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the error output goes to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">启用/禁用推送错误中的颜色的布尔值。可以设置为 &lt;code&gt;always&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; （或 &lt;code&gt;never&lt;/code&gt; ）或 &lt;code&gt;auto&lt;/code&gt; （或 &lt;code&gt;true&lt;/code&gt; ），在这种情况下，仅当错误输出到达终端时才使用颜色。如果未设置，则使用 &lt;code&gt;color.ui&lt;/code&gt; 的值（默认情况下为 &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="423a3d788dfbe4bee04a423e0b36c0319dcd4d83" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in the output of &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the output is to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">在&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;的输出中启用/禁用颜色的布尔值。可以设置为 &lt;code&gt;always&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; （或 &lt;code&gt;never&lt;/code&gt; ）或 &lt;code&gt;auto&lt;/code&gt; （或 &lt;code&gt;true&lt;/code&gt; ），在这种情况下，仅当输出到终端时才使用颜色。如果未设置，则使用 &lt;code&gt;color.ui&lt;/code&gt; 的值（默认情况下为 &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6f2e2c7e2ba4cb7674d5cd8117d8f0b42a85dae9" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in the output of &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the output is to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">在&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt;的输出中启用/禁用颜色的布尔值。可以设置为 &lt;code&gt;always&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; （或 &lt;code&gt;never&lt;/code&gt; ）或 &lt;code&gt;auto&lt;/code&gt; （或 &lt;code&gt;true&lt;/code&gt; ），在这种情况下，仅当输出到终端时才使用颜色。如果未设置，则使用 &lt;code&gt;color.ui&lt;/code&gt; 的值（默认情况下为 &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fd3e78cce49781de5f532bd4c5e0796c9098f940" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in the output of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the output is to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">在&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;的输出中启用/禁用颜色的布尔值。可以设置为 &lt;code&gt;always&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; （或 &lt;code&gt;never&lt;/code&gt; ）或 &lt;code&gt;auto&lt;/code&gt; （或 &lt;code&gt;true&lt;/code&gt; ），在这种情况下，仅当输出到终端时才使用颜色。如果未设置，则使用 &lt;code&gt;color.ui&lt;/code&gt; 的值（默认情况下为 &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="297391e190582ac1cb26cf2a45a94d7b84f1e151" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color when pushes are rejected. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the error output goes to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">拒绝推送时启用/禁用颜色的布尔值。可以设置为 &lt;code&gt;always&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; （或 &lt;code&gt;never&lt;/code&gt; ）或 &lt;code&gt;auto&lt;/code&gt; （或 &lt;code&gt;true&lt;/code&gt; ），在这种情况下，仅当错误输出到达终端时才使用颜色。如果未设置，则使用 &lt;code&gt;color.ui&lt;/code&gt; 的值（默认情况下为 &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7bd8faf8bbae108bc3e3db709a35680c5dec839a" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable colored output when the pager is in use (default is true).</source>
          <target state="translated">在使用寻呼机时启用/禁用彩色输出的布尔值(默认为true)。</target>
        </trans-unit>
        <trans-unit id="d29f1ced583e3f5a70811c52e97c2481cc279f73" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable inclusion of status information in the commit message template when using an editor to prepare the commit message. Defaults to true.</source>
          <target state="translated">一个布尔值,用于在编辑器准备提交信息时,启用或禁用将状态信息包含在提交信息模板中。默认值为true。</target>
        </trans-unit>
        <trans-unit id="c2d858807e8af6ae2203a74b627cef96e1757782" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable the use of html encoding when sending a patch. An html encoded patch will be bracketed with &amp;lt;pre&amp;gt; and have a content type of text/html. Ironically, enabling this option causes Thunderbird to send the patch as a plain/text, format=fixed email. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">发送补丁程序时启用/禁用html编码的布尔值。html编码的修补程序将用&amp;lt;pre&amp;gt;括起来，并具有text / html的内容类型。具有讽刺意味的是，启用此选项会使Thunderbird将修补程序以纯文本/格式=固定的电子邮件发送。默认值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3f4c2eeab634e1e21aa0984b28bad1eef24f55b" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable verification of the server certificate used by the SSL/TLS connection. Default is &lt;code&gt;true&lt;/code&gt;. Ignored when imap.tunnel is set.</source>
          <target state="translated">一个布尔值，用于启用/禁用SSL / TLS连接使用的服务器证书的验证。默认值为 &lt;code&gt;true&lt;/code&gt; 。设置imap.tunnel时被忽略。</target>
        </trans-unit>
        <trans-unit id="2ba56edef0f759e6a6fb72f98e61ae0b81ab53f7" translate="yes" xml:space="preserve">
          <source>A boolean to inhibit the standard behavior of printing a space before each empty output line. Defaults to false.</source>
          <target state="translated">一个布尔值,用于抑制在每个空输出行前打印空格的标准行为。默认值为false。</target>
        </trans-unit>
        <trans-unit id="aa4f8a419cff5bc7a9aa83bbb22ddc4383ad75de" translate="yes" xml:space="preserve">
          <source>A boolean to make git-clean do nothing unless given -f, -i or -n. Defaults to true.</source>
          <target state="translated">除非给定 -f、-i 或 -n,否则让 git-clean 什么都不做的布尔值。默认为true。</target>
        </trans-unit>
        <trans-unit id="8ac4f1587b4bbb5651120aa9065e93380285e902" translate="yes" xml:space="preserve">
          <source>A boolean to specify whether all commits should be GPG signed. Use of this option when doing operations such as rebase can result in a large number of commits being signed. It may be convenient to use an agent to avoid typing your GPG passphrase several times.</source>
          <target state="translated">一个布尔值,用于指定是否所有提交都要进行GPG签名。当进行诸如rebase这样的操作时,使用这个选项会导致大量的提交被签署。使用代理可以避免多次输入GPG口令。</target>
        </trans-unit>
        <trans-unit id="285446918c9332ac6592ad772bc51e35d0bb94c4" translate="yes" xml:space="preserve">
          <source>A boolean to specify whether all tags should be GPG signed. Use of this option when running in an automated script can result in a large number of tags being signed. It is therefore convenient to use an agent to avoid typing your gpg passphrase several times. Note that this option doesn&amp;rsquo;t affect tag signing behavior enabled by &quot;-u &amp;lt;keyid&amp;gt;&quot; or &quot;--local-user=&amp;lt;keyid&amp;gt;&quot; options.</source>
          <target state="translated">一个布尔值，用于指定是否所有标签都应进行GPG签名。在自动化脚本中运行时使用此选项可能会导致对大量标签进行签名。因此，使用代理来避免多次键入gpg密码很方便。请注意，此选项不会影响&amp;ldquo; -u &amp;lt;keyid&amp;gt;&amp;rdquo;或&amp;ldquo; --local-user = &amp;lt;keyid&amp;gt;&amp;rdquo;选项启用的标记签名行为。</target>
        </trans-unit>
        <trans-unit id="8196128852a99f0296cb3a9178bf0edc9d5e344a" translate="yes" xml:space="preserve">
          <source>A boolean to specify whether annotated tags created should be GPG signed. If &lt;code&gt;--annotate&lt;/code&gt; is specified on the command line, it takes precedence over this option.</source>
          <target state="translated">一个布尔值，用于指定创建的带注释的标签是否应进行GPG签名。如果在命令行上指定了 &lt;code&gt;--annotate&lt;/code&gt; ，则它优先于此选项。</target>
        </trans-unit>
        <trans-unit id="e95ae970d328003d484aaeb100825d3fb66dda25" translate="yes" xml:space="preserve">
          <source>A boolean value which lets you enable the &lt;code&gt;--base=auto&lt;/code&gt; option of format-patch by default.</source>
          <target state="translated">一个布尔值，可让您默认启用format-patch 的 &lt;code&gt;--base=auto&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="a980cf709aa06b2fd9c4272bf89b914aa272bf0a" translate="yes" xml:space="preserve">
          <source>A boolean value which lets you enable the &lt;code&gt;--base=auto&lt;/code&gt; option of format-patch by default. Can also be set to &quot;whenAble&quot; to allow enabling &lt;code&gt;--base=auto&lt;/code&gt; if a suitable base is available, but to skip adding base info otherwise without the format dying.</source>
          <target state="translated">一个布尔值，可让您默认启用format-patch的 &lt;code&gt;--base=auto&lt;/code&gt; 选项。也可以设置为&amp;ldquo; whenAble&amp;rdquo;以允许启用 &lt;code&gt;--base=auto&lt;/code&gt; (如果有合适的基准），但是跳过添加基准信息，否则格式不会消失。</target>
        </trans-unit>
        <trans-unit id="c2d1c05ed407a32104ad2e8d69662cea8851ea3e" translate="yes" xml:space="preserve">
          <source>A boolean value which lets you enable the &lt;code&gt;-s/--signoff&lt;/code&gt; option of format-patch by default. &lt;strong&gt;Note:&lt;/strong&gt; Adding the &lt;code&gt;Signed-off-by&lt;/code&gt; trailer to a patch should be a conscious act and means that you certify you have the rights to submit this work under the same open source license. Please see the &lt;code&gt;SubmittingPatches&lt;/code&gt; document for further discussion.</source>
          <target state="translated">一个布尔值，可让您默认启用format-patch的 &lt;code&gt;-s/--signoff&lt;/code&gt; 选项。&lt;strong&gt;注意：&lt;/strong&gt;在补丁程序中添加基于 &lt;code&gt;Signed-off-by&lt;/code&gt; 预告片应该是有意识的举动，这意味着您证明自己有权在相同的开源许可证下提交此作品。请参阅 &lt;code&gt;SubmittingPatches&lt;/code&gt; 文档以进行进一步的讨论。</target>
        </trans-unit>
        <trans-unit id="98939eb557a27a368986b34536ff6c8cd4c36abd" translate="yes" xml:space="preserve">
          <source>A boolean value which lets you enable the &lt;code&gt;-s/--signoff&lt;/code&gt; option of format-patch by default. &lt;strong&gt;Note:&lt;/strong&gt; Adding the Signed-off-by: line to a patch should be a conscious act and means that you certify you have the rights to submit this work under the same open source license. Please see the &lt;code&gt;SubmittingPatches&lt;/code&gt; document for further discussion.</source>
          <target state="translated">一个布尔值，可让您默认启用format-patch 的 &lt;code&gt;-s/--signoff&lt;/code&gt; 选项。&lt;strong&gt;注意：&lt;/strong&gt;在补丁程序中添加&amp;ldquo;签名人：&amp;rdquo;行应该是有意识的举动，这意味着您证明自己有权在相同的开源许可证下提交此作品。请参阅 &lt;code&gt;SubmittingPatches&lt;/code&gt; 文档以进行进一步讨论。</target>
        </trans-unit>
        <trans-unit id="52843a970e21e2ecc8fa28c4ccdfeaf085918760" translate="yes" xml:space="preserve">
          <source>A boolean which can enable or disable sequence numbers in patch subjects. It defaults to &quot;auto&quot; which enables it only if there is more than one patch. It can be enabled or disabled for all messages by setting it to &quot;true&quot; or &quot;false&quot;. See --numbered option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">一个布尔值，可以启用或禁用补丁程序主题中的序列号。它默认为&amp;ldquo;自动&amp;rdquo;，仅当有多个补丁时才启用。通过将其设置为&amp;ldquo; true&amp;rdquo;或&amp;ldquo; false&amp;rdquo;，可以为所有消息启用或禁用它。参见&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]中的&lt;/a&gt; --numbered选项。</target>
        </trans-unit>
        <trans-unit id="4eaf2f30624eb10b8aee0a4842fe24fd9d5d1733" translate="yes" xml:space="preserve">
          <source>A boolean which disables using of EPSV ftp command by curl. This can helpful with some &quot;poor&quot; ftp servers which don&amp;rsquo;t support EPSV mode. Can be overridden by the &lt;code&gt;GIT_CURL_FTP_NO_EPSV&lt;/code&gt; environment variable. Default is false (curl will use EPSV).</source>
          <target state="translated">一个布尔值，通过curl禁用EPSV ftp命令的使用。这对于某些不支持EPSV模式的&amp;ldquo;较差&amp;rdquo;的ftp服务器可能会有所帮助。可以被 &lt;code&gt;GIT_CURL_FTP_NO_EPSV&lt;/code&gt; 环境变量覆盖。默认值为false（curl将使用EPSV）。</target>
        </trans-unit>
        <trans-unit id="a40656baca50661122d33e0890da13d751ed316a" translate="yes" xml:space="preserve">
          <source>A built-in pattern is provided for all languages listed in the previous section.</source>
          <target state="translated">上一节中列出的所有语言都提供了一个内置模式。</target>
        </trans-unit>
        <trans-unit id="302353030177edeeb70686cd4f5139eb1acdd092" translate="yes" xml:space="preserve">
          <source>A bundle from a recipient repository&amp;rsquo;s point of view is just like a regular repository which it fetches or pulls from. You can, for example, map references when fetching:</source>
          <target state="translated">从收件人存储库的角度来看，捆绑包就像它从中获取或提取的常规存储库一样。例如，您可以在获取时映射参考：</target>
        </trans-unit>
        <trans-unit id="1a5fcdefb11694692ac802e09961aef7e73e5df0" translate="yes" xml:space="preserve">
          <source>A caveat is that older reflog entries in your repository may be expired by &lt;code&gt;git gc&lt;/code&gt;. If B0 no longer appears in the reflog of the remote-tracking branch &lt;code&gt;origin/master&lt;/code&gt;, the &lt;code&gt;--fork-point&lt;/code&gt; mode obviously cannot find it and fails, avoiding to give a random and useless result (such as the parent of B0, like the same command without the &lt;code&gt;--fork-point&lt;/code&gt; option gives).</source>
          <target state="translated">需要注意的是，您的存储库中较旧的reflog条目可能已由 &lt;code&gt;git gc&lt;/code&gt; 过期。如果B0不再出现在远程跟踪分支的 &lt;code&gt;origin/master&lt;/code&gt; 的引用日志中，则 &lt;code&gt;--fork-point&lt;/code&gt; 模式显然找不到并失败，从而避免给出随机且无用的结果（例如B0的父项，例如没有 &lt;code&gt;--fork-point&lt;/code&gt; 选项给出的相同命令）。</target>
        </trans-unit>
        <trans-unit id="e9b2d53c7c7f7197e6449bea92bdc1e149be79ae" translate="yes" xml:space="preserve">
          <source>A changelist that contains only excluded files will be imported as an empty commit if this boolean option is set to true.</source>
          <target state="translated">如果这个布林选项被设置为 &quot;true&quot;,那么只包含排除的文件的变更列表将被导入为空提交。</target>
        </trans-unit>
        <trans-unit id="1fded59f54db89df8b3f442b60da3137cb35cf1c" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;#def_ref&quot;&gt;refs&lt;/a&gt; together with an &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; containing all objects which are &lt;a href=&quot;#def_reachable&quot;&gt;reachable&lt;/a&gt; from the refs, possibly accompanied by meta data from one or more &lt;a href=&quot;#def_porcelain&quot;&gt;porcelains&lt;/a&gt;. A repository can share an object database with other repositories via &lt;a href=&quot;#def_alternate_object_database&quot;&gt;alternates mechanism&lt;/a&gt;.</source>
          <target state="translated">一组&lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt;以及一个&lt;a href=&quot;#def_object_database&quot;&gt;对象数据库，&lt;/a&gt;其中包含ref &lt;a href=&quot;#def_reachable&quot;&gt;可以到达的&lt;/a&gt;所有对象，并可能附带来自一个或多个&lt;a href=&quot;#def_porcelain&quot;&gt;瓷器的&lt;/a&gt;元数据。存储库可以通过&lt;a href=&quot;#def_alternate_object_database&quot;&gt;替代机制&lt;/a&gt;与其他存储库共享对象数据库。</target>
        </trans-unit>
        <trans-unit id="df01e27bf740894293c8642767b5b6f6ba2bfe1f" translate="yes" xml:space="preserve">
          <source>A collection of files with stat information, whose contents are stored as objects. The index is a stored version of your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;. Truth be told, it can also contain a second, and even a third version of a working tree, which are used when &lt;a href=&quot;#def_merge&quot;&gt;merging&lt;/a&gt;.</source>
          <target state="translated">具有统计信息的文件的集合，其内容存储为对象。索引是&lt;a href=&quot;#def_working_tree&quot;&gt;工作树&lt;/a&gt;的存储版本。说实话，它还可以包含工作树的第二个甚至第三个版本，这些版本在&lt;a href=&quot;#def_merge&quot;&gt;合并&lt;/a&gt;时使用。</target>
        </trans-unit>
        <trans-unit id="52a6e96629904ef8963fcbbd33f5c0e5160e4b14" translate="yes" xml:space="preserve">
          <source>A colon &lt;code&gt;:&lt;/code&gt; is used as in &lt;code&gt;srcref:dstref&lt;/code&gt; to mean &quot;use srcref&amp;rsquo;s value and store it in dstref&quot; in fetch and push operations. It may also be used to select a specific object such as with 'git cat-file': &quot;git cat-file blob v1.3.3:refs.c&quot;.</source>
          <target state="translated">在 &lt;code&gt;srcref:dstref&lt;/code&gt; 中使用冒号 &lt;code&gt;:&lt;/code&gt; 表示获取和推送操作中的&amp;ldquo;使用srcref的值并将其存储在dstref中&amp;rdquo;。它也可以用来选择特定的对象，例如'git cat-file'：&amp;ldquo; git cat-file blob v1.3.3：refs.c&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0fa4235099cacbb93254de4106a73880e13a4bbc" translate="yes" xml:space="preserve">
          <source>A colon, followed by a slash, followed by a text, names a commit whose commit message matches the specified regular expression. This name returns the youngest matching commit which is reachable from any ref, including HEAD. The regular expression can match any part of the commit message. To match messages starting with a string, one can use e.g. &lt;code&gt;:/^foo&lt;/code&gt;. The special sequence &lt;code&gt;:/!&lt;/code&gt; is reserved for modifiers to what is matched. &lt;code&gt;:/!-foo&lt;/code&gt; performs a negative match, while &lt;code&gt;:/!!foo&lt;/code&gt; matches a literal &lt;code&gt;!&lt;/code&gt; character, followed by &lt;code&gt;foo&lt;/code&gt;. Any other sequence beginning with &lt;code&gt;:/!&lt;/code&gt; is reserved for now. Depending on the given text, the shell&amp;rsquo;s word splitting rules might require additional quoting.</source>
          <target state="translated">冒号，后跟斜杠，后跟文本，命名其提交消息与指定正则表达式匹配的提交。此名称返回可从任何引用（包括HEAD）访问的最年轻的匹配提交。正则表达式可以匹配提交消息的任何部分。为了匹配以字符串开头的消息，可以使用例如 &lt;code&gt;:/^foo&lt;/code&gt; 。特殊顺序 &lt;code&gt;:/!&lt;/code&gt; 为匹配项保留修饰符。 &lt;code&gt;:/!-foo&lt;/code&gt; 执行否定匹配，而 &lt;code&gt;:/!!foo&lt;/code&gt; 匹配文字 &lt;code&gt;!&lt;/code&gt; 字符，后跟 &lt;code&gt;foo&lt;/code&gt; 。以 &lt;code&gt;:/!&lt;/code&gt; 开头的任何其他序列暂时保留。根据给定的文本，shell的分词规则可能需要附加引号。</target>
        </trans-unit>
        <trans-unit id="13756e35429ac459169fe4f0ae98f0d2e3c822ed" translate="yes" xml:space="preserve">
          <source>A colon, optionally followed by a stage number (0 to 3) and a colon, followed by a path, names a blob object in the index at the given path. A missing stage number (and the colon that follows it) names a stage 0 entry. During a merge, stage 1 is the common ancestor, stage 2 is the target branch&amp;rsquo;s version (typically the current branch), and stage 3 is the version from the branch which is being merged.</source>
          <target state="translated">冒号（可选后跟阶段号（0到3））和冒号（后跟路径）在给定路径的索引中命名blob对象。缺少的阶段号（及其后的冒号）将命名为阶段0条目。在合并过程中，阶段1是公共祖先，阶段2是目标分支的版本（通常是当前分支），阶段3是要合并的分支的版本。</target>
        </trans-unit>
        <trans-unit id="8caa5f563f7545c6d876e685c6213fbb94df9ad3" translate="yes" xml:space="preserve">
          <source>A comma and/or whitespace separated list of encodings that Git performs UTF-8 round trip checks on if they are used in an &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute (see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;). The default value is &lt;code&gt;SHIFT-JIS&lt;/code&gt;.</source>
          <target state="translated">如果用在 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性中（请参阅&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;），Git会执行以逗号和/或空格分隔的编码列表，以进行UTF-8往返检查。默认值为 &lt;code&gt;SHIFT-JIS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b2d1e893ce7e09a76d55d9b9450e681bcdfc845" translate="yes" xml:space="preserve">
          <source>A comma separated list of &lt;code&gt;--dirstat&lt;/code&gt; parameters specifying the default behavior of the &lt;code&gt;--dirstat&lt;/code&gt; option to &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and friends. The defaults can be overridden on the command line (using &lt;code&gt;--dirstat=&amp;lt;param1,param2,...&amp;gt;&lt;/code&gt;). The fallback defaults (when not changed by &lt;code&gt;diff.dirstat&lt;/code&gt;) are &lt;code&gt;changes,noncumulative,3&lt;/code&gt;. The following parameters are available:</source>
          <target state="translated">&lt;code&gt;--dirstat&lt;/code&gt; 参数的逗号分隔列表，指定&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;和其朋友使用 &lt;code&gt;--dirstat&lt;/code&gt; 选项的默认行为。可以在命令行上覆盖默认值（使用 &lt;code&gt;--dirstat=&amp;lt;param1,param2,...&amp;gt;&lt;/code&gt; ）。后备默认值（未由 &lt;code&gt;diff.dirstat&lt;/code&gt; &lt;code&gt;changes,noncumulative,3&lt;/code&gt; 时）为changes，noncumulative，3。可以使用以下参数：</target>
        </trans-unit>
        <trans-unit id="90c61024b3e6d8b4fd7db663d99f9e656029c4cd" translate="yes" xml:space="preserve">
          <source>A comma separated list of common whitespace problems to notice. &lt;code&gt;git diff&lt;/code&gt; will use &lt;code&gt;color.diff.whitespace&lt;/code&gt; to highlight them, and &lt;code&gt;git apply --whitespace=error&lt;/code&gt; will consider them as errors. You can prefix &lt;code&gt;-&lt;/code&gt; to disable any of them (e.g. &lt;code&gt;-trailing-space&lt;/code&gt;):</source>
          <target state="translated">以逗号分隔的常见空白问题列表，需要注意。 &lt;code&gt;git diff&lt;/code&gt; 将使用 &lt;code&gt;color.diff.whitespace&lt;/code&gt; 突出显示它们，而 &lt;code&gt;git apply --whitespace=error&lt;/code&gt; 会将它们视为错误。您可以添加前缀 &lt;code&gt;-&lt;/code&gt; 以禁用其中的任何一个（例如 &lt;code&gt;-trailing-space&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="b1f12d6e1196c6283625769763bfec7de0f553d4" translate="yes" xml:space="preserve">
          <source>A comma-separated list of &quot;important&quot; environment variables that should be recorded in the trace2 output. For example, &lt;code&gt;GIT_HTTP_USER_AGENT,GIT_CONFIG&lt;/code&gt; would cause the trace2 output to contain events listing the overrides for HTTP user agent and the location of the Git configuration file (assuming any are set). May be overriden by the &lt;code&gt;GIT_TRACE2_ENV_VARS&lt;/code&gt; environment variable. Unset by default.</source>
          <target state="translated">以逗号分隔的&amp;ldquo;重要&amp;rdquo;环境变量列表，应将其记录在trace2输出中。例如， &lt;code&gt;GIT_HTTP_USER_AGENT,GIT_CONFIG&lt;/code&gt; 将导致trace2输出包含列出HTTP用户代理覆盖和Git配置文件位置（假定已设置）的事件。可以被 &lt;code&gt;GIT_TRACE2_ENV_VARS&lt;/code&gt; 环境变量覆盖。默认情况下未设置。</target>
        </trans-unit>
        <trans-unit id="bb282cbfbc43caeda403e67d10ddbed3e0b9cd80" translate="yes" xml:space="preserve">
          <source>A comma-separated list of patterns of &quot;important&quot; config settings that should be recorded in the trace2 output. For example, &lt;code&gt;core.*,remote.*.url&lt;/code&gt; would cause the trace2 output to contain events listing each configured remote. May be overridden by the &lt;code&gt;GIT_TRACE2_CONFIG_PARAMS&lt;/code&gt; environment variable. Unset by default.</source>
          <target state="translated">以逗号分隔的&amp;ldquo;重要&amp;rdquo;配置设置的模式列表，应记录在trace2输出中。例如， &lt;code&gt;core.*,remote.*.url&lt;/code&gt; 将导致trace2输出包含列出每个已配置遥控器的事件。可以被 &lt;code&gt;GIT_TRACE2_CONFIG_PARAMS&lt;/code&gt; 环境变量覆盖。默认情况下未设置。</target>
        </trans-unit>
        <trans-unit id="5fab91cb4daf1c47222fcbb845cf8839d9381cfa" translate="yes" xml:space="preserve">
          <source>A commit comment is read from stdin. If a changelog entry is not provided via &quot;&amp;lt;&quot; redirection, &lt;code&gt;git commit-tree&lt;/code&gt; will just wait for one to be entered and terminated with ^D.</source>
          <target state="translated">从stdin中读取提交注释。如果未通过&amp;ldquo; &amp;lt;&amp;rdquo;重定向提供更改日志条目，则 &lt;code&gt;git commit-tree&lt;/code&gt; 将仅等待输入并以^ D终止。</target>
        </trans-unit>
        <trans-unit id="3c1dc52f2c7f4f92de3fbbe4920a9bf34ad24479" translate="yes" xml:space="preserve">
          <source>A commit encapsulates:</source>
          <target state="translated">提交的内容包括:</target>
        </trans-unit>
        <trans-unit id="acc26f5acfd22e9eac8779b8f191ce6307d46b3a" translate="yes" xml:space="preserve">
          <source>A commit is usually created by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, which creates a commit whose parent is normally the current HEAD, and whose tree is taken from the content currently stored in the index.</source>
          <target state="translated">提交通常由&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;创建，该提交创建一个提交，该提交的父级通常是当前HEAD，并且其树是从当前存储在索引中的内容中提取的。</target>
        </trans-unit>
        <trans-unit id="cdd78b04bea05d29acf58eb590016b304b9a695a" translate="yes" xml:space="preserve">
          <source>A commit object may have any number of parents. With exactly one parent, it is an ordinary commit. Having more than one parent makes the commit a merge between several lines of history. Initial (root) commits have no parents.</source>
          <target state="translated">一个提交对象可以有任何数量的父对象。如果只有一个父对象,它就是一个普通的提交。如果有多个父提交对象,则该提交是几行历史的合并。初始(根)提交没有父对象。</target>
        </trans-unit>
        <trans-unit id="f73e034726177d0d1de0cc7cb0b4640f70795d7d" translate="yes" xml:space="preserve">
          <source>A commit&amp;rsquo;s reachable set is the commit itself and the commits in its ancestry chain.</source>
          <target state="translated">提交的可到达集合是提交本身及其祖先链中的提交。</target>
        </trans-unit>
        <trans-unit id="9f0c7cb4b676d44b852130363daf17e0059e5d35" translate="yes" xml:space="preserve">
          <source>A common idiom to check &quot;fast-forward-ness&quot; between two commits A and B is (or at least used to be) to compute the merge base between A and B, and check if it is the same as A, in which case, A is an ancestor of B. You will see this idiom used often in older scripts.</source>
          <target state="translated">检查A和B两个提交之间的 &quot;快进性 &quot;的一个常见习惯是(至少过去是这样)计算A和B之间的合并基数,并检查它是否与A相同,在这种情况下,A是B的祖先。</target>
        </trans-unit>
        <trans-unit id="efeda38b74e243af3941ca4cb1afcb6d50536c89" translate="yes" xml:space="preserve">
          <source>A common perception of maintenance is that it is merely fixing bugs. However, studies and surveys over the years have indicated that the majority, over 80%, of the maintenance effort is used for non-corrective actions (Pigosky 1997). This perception is perpetuated by users submitting problem reports that in reality are functionality enhancements to the system.</source>
          <target state="translated">人们对维护的普遍看法是,维护仅仅是修复错误。然而,多年来的研究和调查表明,大多数维护工作,即80%以上的维护工作都用于非纠正行动(Pigosky 1997)。这种观念由于用户提交问题报告而得以延续,而实际上这些问题报告是对系统功能的增强。</target>
        </trans-unit>
        <trans-unit id="197af13fb9a6e5b93cb17a698b162888ff484ba7" translate="yes" xml:space="preserve">
          <source>A common problem users face when looking at simplified history is that a commit they know changed a file somehow does not appear in the file&amp;rsquo;s simplified history. Let&amp;rsquo;s demonstrate a new example and show how options such as &lt;code&gt;--full-history&lt;/code&gt; and &lt;code&gt;--simplify-merges&lt;/code&gt; works in that case:</source>
          <target state="translated">用户在查看简化历史记录时遇到的一个常见问题是，他们知道以某种方式更改文件的提交不会出现在文件的简化历史记录中。让我们演示一个新示例，并说明 &lt;code&gt;--full-history&lt;/code&gt; 和 &lt;code&gt;--simplify-merges&lt;/code&gt; merges之类的选项在这种情况下如何工作：</target>
        </trans-unit>
        <trans-unit id="5edc728da69ffd96fd56c998aef47f3f04d15f9f" translate="yes" xml:space="preserve">
          <source>A common shorthand for &lt;code&gt;git diff-files -p&lt;/code&gt; is to just write &lt;code&gt;git
diff&lt;/code&gt;, which will do the same thing.</source>
          <target state="translated">&lt;code&gt;git diff-files -p&lt;/code&gt; 的常见简写就是只写 &lt;code&gt;git diff&lt;/code&gt; ，这会做同样的事情。</target>
        </trans-unit>
        <trans-unit id="14a9ba1b1e1a8bc290e55e84eb3c20bc97ffb373" translate="yes" xml:space="preserve">
          <source>A common working pattern is to fetch the latest changes from the p4 depot and merge them with local uncommitted changes. Often, the p4 repository is the ultimate location for all code, thus a rebase workflow makes sense. This command does &lt;code&gt;git p4 sync&lt;/code&gt; followed by &lt;code&gt;git rebase&lt;/code&gt; to move local commits on top of updated p4 changes.</source>
          <target state="translated">一种常见的工作模式是从p4软件仓库获取最新更改，并将其与本地未提交的更改合并。通常，p4存储库是所有代码的最终存储位置，因此重新设计工作流才有意义。此命令执行 &lt;code&gt;git p4 sync&lt;/code&gt; 然后执行 &lt;code&gt;git rebase&lt;/code&gt; ,以在更新的p4更改之上移动本地提交。</target>
        </trans-unit>
        <trans-unit id="a4fa8348285318059dfacd14294d170b4fc808f0" translate="yes" xml:space="preserve">
          <source>A complete 40 byte or abbreviated commit SHA-1 in hex.</source>
          <target state="translated">一个完整的40个字节或缩写的十六进制提交SHA-1。</target>
        </trans-unit>
        <trans-unit id="02926b5c0160f21e1aa42320ded7f690bec583ac" translate="yes" xml:space="preserve">
          <source>A configuration identity. When given, causes values in the &lt;code&gt;sendemail.&amp;lt;identity&amp;gt;&lt;/code&gt; subsection to take precedence over values in the &lt;code&gt;sendemail&lt;/code&gt; section. The default identity is the value of &lt;code&gt;sendemail.identity&lt;/code&gt;.</source>
          <target state="translated">配置标识。如果指定，则使 &lt;code&gt;sendemail.&amp;lt;identity&amp;gt;&lt;/code&gt; 子节中的值优先于 &lt;code&gt;sendemail&lt;/code&gt; 节中的值。默认身份是 &lt;code&gt;sendemail.identity&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="35d1e222ae59833da8390e3205af99d5791ad8cb" translate="yes" xml:space="preserve">
          <source>A conflict occurs if both &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt; have changes in a common segment of lines. If a conflict is found, &lt;code&gt;git merge-file&lt;/code&gt; normally outputs a warning and brackets the conflict with lines containing &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; and &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; markers. A typical conflict will look like this:</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt; 在同一行线段中都有更改，则会发生冲突。如果发现冲突，则 &lt;code&gt;git merge-file&lt;/code&gt; 通常会输出警告，并使用包含&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;和&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;标记的行将冲突括起来。典型的冲突如下所示：</target>
        </trans-unit>
        <trans-unit id="07bd76c9e5bd5a5c306cd10ddbfbe3c7ac2875c0" translate="yes" xml:space="preserve">
          <source>A convenience alias for &lt;code&gt;--only-trailers --only-input
--unfold&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--only-trailers --only-input --unfold&lt;/code&gt; 便捷别名。</target>
        </trans-unit>
        <trans-unit id="97978af293e3af436b507f6dc4b9076f9f973577" translate="yes" xml:space="preserve">
          <source>A debug option to help with future &quot;partial clone&quot; development. This option specifies how missing objects are handled.</source>
          <target state="translated">一个调试选项,以帮助未来的 &quot;部分克隆 &quot;开发。这个选项指定了如何处理丢失的对象。</target>
        </trans-unit>
        <trans-unit id="26d7d5495841c41cd87cf2e545d3c8aff9d18129" translate="yes" xml:space="preserve">
          <source>A default username, if one is not provided in the URL.</source>
          <target state="translated">一个默认的用户名,如果URL中没有提供。</target>
        </trans-unit>
        <trans-unit id="cba5596219f17f93a98404ea4497b915ef344a8c" translate="yes" xml:space="preserve">
          <source>A delimiter string is used to mark the end of the data. fast-import will compute the length by searching for the delimiter. This format is primarily useful for testing and is not recommended for real data.</source>
          <target state="translated">定界符字符串用来标记数据的结束,fast-import会通过搜索定界符来计算长度。这种格式主要用于测试,不建议用于真实数据。</target>
        </trans-unit>
        <trans-unit id="21e88086f294c6f14da1c8f79767c0e47b61a6a2" translate="yes" xml:space="preserve">
          <source>A developer working as a participant in a group project needs to learn how to communicate with others, and uses these commands in addition to the ones needed by a standalone developer.</source>
          <target state="translated">一个开发者作为小组项目的参与者,需要学习如何与他人交流,除了独立开发者需要的命令外,还需要使用这些命令。</target>
        </trans-unit>
        <trans-unit id="aa00f0c6fcff7a20980dde937b6f2c6eff19948d" translate="yes" xml:space="preserve">
          <source>A directory to add to the whitelist of allowed directories. Unless --strict-paths is specified this will also include subdirectories of each named directory.</source>
          <target state="translated">要添加到允许目录白名单中的目录。除非指定了 --strict-paths,否则这也将包括每个命名目录的子目录。</target>
        </trans-unit>
        <trans-unit id="a72583fc1f6c7369768db5e1d7fb0e226e0f4e70" translate="yes" xml:space="preserve">
          <source>A double-dot &lt;code&gt;..&lt;/code&gt; is often used as in &lt;code&gt;ref1..ref2&lt;/code&gt;, and in some contexts this notation means &lt;code&gt;^ref1 ref2&lt;/code&gt; (i.e. not in &lt;code&gt;ref1&lt;/code&gt; and in &lt;code&gt;ref2&lt;/code&gt;).</source>
          <target state="translated">通常在 &lt;code&gt;ref1..ref2&lt;/code&gt; 中使用双点 &lt;code&gt;..&lt;/code&gt; ，在某些情况下，该符号表示 &lt;code&gt;^ref1 ref2&lt;/code&gt; （即不在 &lt;code&gt;ref1&lt;/code&gt; 和 &lt;code&gt;ref2&lt;/code&gt; 中）。</target>
        </trans-unit>
        <trans-unit id="8cdb3523eaeda3961c032ea5c0f58f6c364cd9b3" translate="yes" xml:space="preserve">
          <source>A dumb server that does not do on-the-fly pack generations must have some auxiliary information files in $GIT_DIR/info and $GIT_OBJECT_DIRECTORY/info directories to help clients discover what references and packs the server has. This command generates such auxiliary files.</source>
          <target state="translated">一个不进行即时包生成的傻瓜服务器必须在 $GIT_DIR/info 和 $GIT_OBJECT_DIRECTORY/info 目录下有一些辅助信息文件,以帮助客户发现服务器有哪些引用和包。这个命令可以生成这样的辅助文件。</target>
        </trans-unit>
        <trans-unit id="3e6068affbbe0ff6a579ff1d24351f9cddf70755" translate="yes" xml:space="preserve">
          <source>A fairly central person acting as the integrator in a group project receives changes made by others, reviews and integrates them and publishes the result for others to use, using these commands in addition to the ones needed by participants.</source>
          <target state="translated">在一个小组项目中,一个相当核心的人作为整合者,接收他人所做的修改,对其进行审核和整合,并将结果发布给他人使用,除了参与者需要的命令外,还使用这些命令。</target>
        </trans-unit>
        <trans-unit id="62b9ceab10a1cb84bc6e55a7f4299b34b10f0e2f" translate="yes" xml:space="preserve">
          <source>A fast-forward is a special type of &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; where you have a &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt; and you are &quot;merging&quot; another &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;'s changes that happen to be a descendant of what you have. In such a case, you do not make a new &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt;&lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; but instead just update to his revision. This will happen frequently on a &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branch&lt;/a&gt; of a remote &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;.</source>
          <target state="translated">快进是一种特殊的&lt;a href=&quot;#def_merge&quot;&gt;合并&lt;/a&gt;类型，其中您有一个&lt;a href=&quot;#def_revision&quot;&gt;修订版本，&lt;/a&gt;并且您正在&amp;ldquo;合并&amp;rdquo;另一个&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;的更改，而这些更改恰好是您所拥有的后代。在这种情况下，您无需进行新的&lt;a href=&quot;#def_merge&quot;&gt;合并&lt;/a&gt;&lt;a href=&quot;#def_commit&quot;&gt;提交&lt;/a&gt;，而只需对其版本进行更新即可。这将经常在远程&lt;a href=&quot;#def_repository&quot;&gt;存储库&lt;/a&gt;的&lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;远程跟踪分支&lt;/a&gt;上发生。</target>
        </trans-unit>
        <trans-unit id="f1639e68ef8005bf8b9fd0a9765a95c3e36366d5" translate="yes" xml:space="preserve">
          <source>A fast-forward looks something like this:</source>
          <target state="translated">快进的样子是这样的。</target>
        </trans-unit>
        <trans-unit id="b2e7c39642f6628198b3a6330b5201dad9a7aff7" translate="yes" xml:space="preserve">
          <source>A fatal error was encountered.</source>
          <target state="translated">遇到了一个致命的错误。</target>
        </trans-unit>
        <trans-unit id="0b2eaf514674a6a55b836d451eca54479349bb70" translate="yes" xml:space="preserve">
          <source>A feature release is created from the &lt;code&gt;master&lt;/code&gt; branch, since &lt;code&gt;master&lt;/code&gt; tracks the commits that should go into the next feature release.</source>
          <target state="translated">从 &lt;code&gt;master&lt;/code&gt; 分支创建功能版本，因为 &lt;code&gt;master&lt;/code&gt; 跟踪应该进入下一个功能版本的提交。</target>
        </trans-unit>
        <trans-unit id="6fec1b632e27b6702e3f256a53ccc077c022a8bd" translate="yes" xml:space="preserve">
          <source>A fetch stores a copy of the latest changes from the remote repository, without modifying the working tree or current branch. You can then at your leisure inspect, merge, rebase on top of, or ignore the upstream changes. A pull consists of a fetch followed immediately by either a merge or rebase. See &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">访存可从远程存储库中存储最新更改的副本，而无需修改工作树或当前分支。然后，您可以在闲暇时检查，合并，基于其基础或忽略上游更改。拉取由读取，紧随其后的合并或变基组成。参见&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="74ba6f95b54ef3076dd734e20033705f91d3f8bd" translate="yes" xml:space="preserve">
          <source>A few configuration variables (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) can make it easy to push both branches to your public tree. (See &lt;a href=&quot;#setting-up-a-public-repository&quot;&gt;Setting up a public repository&lt;/a&gt;.)</source>
          <target state="translated">一些配置变量（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）可以使将两个分支都推入公共树变得容易。（请参阅&lt;a href=&quot;#setting-up-a-public-repository&quot;&gt;设置公共存储库&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="9b328fdc14f23c3b282a30f44ac30ff04e6b3868" translate="yes" xml:space="preserve">
          <source>A few more notes on matching via &lt;code&gt;gitdir&lt;/code&gt; and &lt;code&gt;gitdir/i&lt;/code&gt;:</source>
          <target state="translated">有关通过 &lt;code&gt;gitdir&lt;/code&gt; 和 &lt;code&gt;gitdir/i&lt;/code&gt; 进行匹配的更多说明：</target>
        </trans-unit>
        <trans-unit id="74c1c3db8333ea0856e57a216b0202a880b8b0fd" translate="yes" xml:space="preserve">
          <source>A field name to sort on. Prefix &lt;code&gt;-&lt;/code&gt; to sort in descending order of the value. When unspecified, &lt;code&gt;refname&lt;/code&gt; is used. You may use the --sort=&amp;lt;key&amp;gt; option multiple times, in which case the last key becomes the primary key.</source>
          <target state="translated">要排序的字段名称。前缀 &lt;code&gt;-&lt;/code&gt; 以值的降序排序。如果未指定，则使用 &lt;code&gt;refname&lt;/code&gt; 。您可以多次使用--sort = &amp;lt;key&amp;gt;选项，在这种情况下，最后一个键成为主键。</target>
        </trans-unit>
        <trans-unit id="13fa2104992d30057f7ee2ca78ba1b9cc1b33c21" translate="yes" xml:space="preserve">
          <source>A filter driver consists of a &lt;code&gt;clean&lt;/code&gt; command and a &lt;code&gt;smudge&lt;/code&gt; command, either of which can be left unspecified. Upon checkout, when the &lt;code&gt;smudge&lt;/code&gt; command is specified, the command is fed the blob object from its standard input, and its standard output is used to update the worktree file. Similarly, the &lt;code&gt;clean&lt;/code&gt; command is used to convert the contents of worktree file upon checkin. By default these commands process only a single blob and terminate. If a long running &lt;code&gt;process&lt;/code&gt; filter is used in place of &lt;code&gt;clean&lt;/code&gt; and/or &lt;code&gt;smudge&lt;/code&gt; filters, then Git can process all blobs with a single filter command invocation for the entire life of a single Git command, for example &lt;code&gt;git add --all&lt;/code&gt;. If a long running &lt;code&gt;process&lt;/code&gt; filter is configured then it always takes precedence over a configured single blob filter. See section below for the description of the protocol used to communicate with a &lt;code&gt;process&lt;/code&gt; filter.</source>
          <target state="translated">筛选器驱动程序由 &lt;code&gt;clean&lt;/code&gt; 命令和 &lt;code&gt;smudge&lt;/code&gt; 命令组成，这两个命令都可以不指定。签出后，当指定了 &lt;code&gt;smudge&lt;/code&gt; 命令时，将从标准输入中为blob对象提供命令，并使用其标准输出来更新工作树文件。同样， &lt;code&gt;clean&lt;/code&gt; 命令用于在签入时转换工作树文件的内容。默认情况下，这些命令仅处理单个Blob并终止。如果使用运行时间较长的 &lt;code&gt;process&lt;/code&gt; 过滤器代替 &lt;code&gt;clean&lt;/code&gt; 和/或 &lt;code&gt;smudge&lt;/code&gt; 过滤器，则Git可以在单个Git命令的整个生命周期内通过一次过滤器命令调用来处理所有Blob。 &lt;code&gt;git add --all&lt;/code&gt; 。如果配置了长时间运行的 &lt;code&gt;process&lt;/code&gt; 过滤器，则它始终优先于已配置的单个Blob过滤器。有关用于与 &lt;code&gt;process&lt;/code&gt; 过滤器通信的协议的说明，请参见下面的部分。</target>
        </trans-unit>
        <trans-unit id="a399e6db3987e04a0a954aa555198a880460b1b3" translate="yes" xml:space="preserve">
          <source>A format string, as specified in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, to be used for the todo list during an interactive rebase. The format will automatically have the long commit hash prepended to the format.</source>
          <target state="translated">&lt;a href=&quot;git-log&quot;&gt;git-log [1]中&lt;/a&gt;指定的格式字符串，在交互式变基期间将用于待办事项列表。该格式将自动在格式前面添加长提交哈希。</target>
        </trans-unit>
        <trans-unit id="3ef0d2618bd1f2707924d8265b8cbc81cb0f4df7" translate="yes" xml:space="preserve">
          <source>A formatted and hyperlinked copy of the latest Git documentation can be viewed at &lt;a href=&quot;https://git.github.io/htmldocs/git.html&quot;&gt;https://git.github.io/htmldocs/git.html&lt;/a&gt; or &lt;a href=&quot;index&quot;&gt;https://git-scm.com/docs&lt;/a&gt;.</source>
          <target state="translated">可以在&lt;a href=&quot;https://git.github.io/htmldocs/git.html&quot;&gt;https://git.github.io/htmldocs/git.html&lt;/a&gt;或&lt;a href=&quot;index&quot;&gt;https://git-scm.com/docs上&lt;/a&gt;查看最新的Git文档的格式和超链接副本。</target>
        </trans-unit>
        <trans-unit id="1611e58cf3ba6bbcadd845b19a6529d9c8709a09" translate="yes" xml:space="preserve">
          <source>A freshly cloned repository contains a single branch head, by default named &quot;master&quot;, with the working directory initialized to the state of the project referred to by that branch head.</source>
          <target state="translated">一个新鲜克隆的版本库包含一个分支头,默认命名为 &quot;master&quot;,工作目录初始化为该分支头所引用的项目状态。</target>
        </trans-unit>
        <trans-unit id="9361f96571e895bc96ccb37b799d33736e1313bd" translate="yes" xml:space="preserve">
          <source>A frontend set up this way can use &lt;code&gt;progress&lt;/code&gt;, &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, and &lt;code&gt;cat-blob&lt;/code&gt; commands to read information from the import in progress.</source>
          <target state="translated">以这种方式设置的前端可以使用 &lt;code&gt;progress&lt;/code&gt; ， &lt;code&gt;get-mark&lt;/code&gt; ， &lt;code&gt;ls&lt;/code&gt; 和 &lt;code&gt;cat-blob&lt;/code&gt; 命令从正在进行的导入中读取信息。</target>
        </trans-unit>
        <trans-unit id="5ec35e8b31b58ee10f23bf6c56b94488c655953e" translate="yes" xml:space="preserve">
          <source>A general note on safety: supplying this option without an expected value, i.e. as &lt;code&gt;--force-with-lease&lt;/code&gt; or &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;&lt;/code&gt; interacts very badly with anything that implicitly runs &lt;code&gt;git fetch&lt;/code&gt; on the remote to be pushed to in the background, e.g. &lt;code&gt;git fetch origin&lt;/code&gt; on your repository in a cronjob.</source>
          <target state="translated">关于安全性的一般说明：提供此选项时不提供预期值，即 &lt;code&gt;--force-with-lease&lt;/code&gt; 或 &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;&lt;/code&gt; 与在远程运行隐式运行 &lt;code&gt;git fetch&lt;/code&gt; 的任何内容的交互都非常糟糕推送到后台，例如 &lt;code&gt;git fetch origin&lt;/code&gt; 在cronjob中获取存储库中的origin。</target>
        </trans-unit>
        <trans-unit id="0ed755acace2a48ffeeff6fb565baf90507fd745" translate="yes" xml:space="preserve">
          <source>A git repository can support multiple working trees, allowing you to check out more than one branch at a time. With &lt;code&gt;git worktree add&lt;/code&gt; a new working tree is associated with the repository. This new working tree is called a &quot;linked working tree&quot; as opposed to the &quot;main working tree&quot; prepared by &quot;git init&quot; or &quot;git clone&quot;. A repository has one main working tree (if it&amp;rsquo;s not a bare repository) and zero or more linked working trees. When you are done with a linked working tree, remove it with &lt;code&gt;git worktree remove&lt;/code&gt;.</source>
          <target state="translated">一个git仓库可以支持多个工作树，允许您一次签出多个分支。使用 &lt;code&gt;git worktree add&lt;/code&gt; 新的工作树与存储库相关联。与通过&amp;ldquo; git init&amp;rdquo;或&amp;ldquo; git clone&amp;rdquo;准备的&amp;ldquo;主工作树&amp;rdquo;相对，该新工作树称为&amp;ldquo;链接工作树&amp;rdquo;。存储库有一个主工作树（如果不是裸存储库）和零个或多个链接的工作树。完成链接的工作树后，请使用 &lt;code&gt;git worktree remove&lt;/code&gt; 将其删除。</target>
        </trans-unit>
        <trans-unit id="f741e1b0eda9fb3d26b53c2f7cc5921496de9343" translate="yes" xml:space="preserve">
          <source>A git repository can support multiple working trees, allowing you to check out more than one branch at a time. With &lt;code&gt;git worktree add&lt;/code&gt; a new working tree is associated with the repository. This new working tree is called a &quot;linked working tree&quot; as opposed to the &quot;main working tree&quot; prepared by &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; or &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;. A repository has one main working tree (if it&amp;rsquo;s not a bare repository) and zero or more linked working trees. When you are done with a linked working tree, remove it with &lt;code&gt;git worktree remove&lt;/code&gt;.</source>
          <target state="translated">一个git仓库可以支持多个工作树，从而允许您一次签出多个分支。使用 &lt;code&gt;git worktree add&lt;/code&gt; 一个新的与存储库相关联的工作树。与由&lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt;或&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;准备的&amp;ldquo;主工作树&amp;rdquo;相对，该新工作树称为&amp;ldquo;链接工作树&amp;rdquo; 。存储库具有一个主工作树（如果不是裸存储库）和零个或多个链接的工作树。完成链接的工作树后，请使用 &lt;code&gt;git worktree remove&lt;/code&gt; 将其删除。</target>
        </trans-unit>
        <trans-unit id="bb35f01e2c3f5716f9ff7a011caefd2667f92277" translate="yes" xml:space="preserve">
          <source>A glob pattern that matches branch or tag names under refs/. For example, if you have many topic branches under refs/heads/topic, giving &lt;code&gt;topic/*&lt;/code&gt; would show all of them.</source>
          <target state="translated">与refs /下的分支或标记名称匹配的全局模式。例如，如果您在refs / heads / topic下有很多主题分支，则给 &lt;code&gt;topic/*&lt;/code&gt; 将显示所有这些分支。</target>
        </trans-unit>
        <trans-unit id="190546c0fc74bb90a9365e134f633644e2a48fc0" translate="yes" xml:space="preserve">
          <source>A globbing refspec must have a non-empty RHS (i.e. must store what were fetched in remote-tracking branches), and its LHS and RHS must end with &lt;code&gt;/*&lt;/code&gt;. The above specifies that all remote branches are tracked using remote-tracking branches in &lt;code&gt;refs/remotes/origin/&lt;/code&gt; hierarchy under the same name.</source>
          <target state="translated">全局引用规范必须具有非空的RHS（即必须存储在远程跟踪分支中获取的内容），并且其LHS和RHS必须以 &lt;code&gt;/*&lt;/code&gt; 结尾。上面指定了所有远程分支都使用 &lt;code&gt;refs/remotes/origin/&lt;/code&gt; 层次结构中的远程跟踪分支以相同的名称进行跟踪。</target>
        </trans-unit>
        <trans-unit id="45b9d757fdd2ed971a566d8afcb44af578620a00" translate="yes" xml:space="preserve">
          <source>A good place to start is with the contents of the initial commit, with:</source>
          <target state="translated">一个好的开始是初始提交的内容,与。</target>
        </trans-unit>
        <trans-unit id="9d5629e7ec2db5ea11dbadd12ca8d2c545f75144" translate="yes" xml:space="preserve">
          <source>A handy way to push the current branch to the same name on the remote.</source>
          <target state="translated">一个方便的方法,可以将当前分支推送到远程的同一名称。</target>
        </trans-unit>
        <trans-unit id="8420ab633ffe4ffea61082096882d33b9782db25" translate="yes" xml:space="preserve">
          <source>A header appears at the beginning and consists of the following:</source>
          <target state="translated">头部出现一个标题,由以下内容组成:</target>
        </trans-unit>
        <trans-unit id="bd26c474482563b0a0cde7feb34691662847c30b" translate="yes" xml:space="preserve">
          <source>A helper advertising the capability &lt;code&gt;refspec refs/heads/*:refs/svn/origin/branches/*&lt;/code&gt; is saying that, when it is asked to &lt;code&gt;import refs/heads/topic&lt;/code&gt;, the stream it outputs will update the &lt;code&gt;refs/svn/origin/branches/topic&lt;/code&gt; ref.</source>
          <target state="translated">宣传能力 &lt;code&gt;refspec refs/heads/*:refs/svn/origin/branches/*&lt;/code&gt; 的助手说，当要求 &lt;code&gt;import refs/heads/topic&lt;/code&gt; ，其输出的流将更新 &lt;code&gt;refs/svn/origin/branches/topic&lt;/code&gt; 参考</target>
        </trans-unit>
        <trans-unit id="a8a80004c991a3f9b4309875108440f77b31093a" translate="yes" xml:space="preserve">
          <source>A html file (HTML fragment) which is included on the gitweb project &quot;summary&quot; page inside &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; block element. You can use it for longer description of a project, to provide links (for example to project&amp;rsquo;s homepage), etc. This is recognized only if XSS prevention is off (&lt;code&gt;$prevent_xss&lt;/code&gt; is false, see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;); a way to include a README safely when XSS prevention is on may be worked out in the future.</source>
          <target state="translated">一个html文件（HTML片段），包含在 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 块元素内的gitweb项目&amp;ldquo;摘要&amp;rdquo;页面上。您可以将其用于项目的详细描述，提供链接（例如，指向项目的主页）等。仅当XSS防护功能关闭（ &lt;code&gt;$prevent_xss&lt;/code&gt; 为false，请参见&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt;）时，此方法才能被识别。将来可能会找到一种在启用XSS防护时安全地包含README的方法。</target>
        </trans-unit>
        <trans-unit id="5fd437060459f74aebbd18b9e1cd799a77abb2e3" translate="yes" xml:space="preserve">
          <source>A human-readable explanation. In the case of successfully fetched refs, no explanation is needed. For a failed ref, the reason for failure is described.</source>
          <target state="translated">一个人类可读的解释。对于成功获取的裁判,不需要解释。对于失败的参考文献,则说明失败的原因。</target>
        </trans-unit>
        <trans-unit id="41f2620460bac465215c8ebb35f39e6332181467" translate="yes" xml:space="preserve">
          <source>A human-readable explanation. In the case of successfully pushed refs, no explanation is needed. For a failed ref, the reason for failure is described.</source>
          <target state="translated">一个人类可读的解释。对于成功推送的裁判,不需要解释。对于失败的裁判,则说明失败的原因。</target>
        </trans-unit>
        <trans-unit id="7a9b8dd4dd7232e67cd2ac62d96fc72ced1418df" translate="yes" xml:space="preserve">
          <source>A leading &quot;&lt;code&gt;**&lt;/code&gt;&quot; followed by a slash means match in all directories. For example, &quot;&lt;code&gt;**/foo&lt;/code&gt;&quot; matches file or directory &quot;&lt;code&gt;foo&lt;/code&gt;&quot; anywhere, the same as pattern &quot;&lt;code&gt;foo&lt;/code&gt;&quot;. &quot;&lt;code&gt;**/foo/bar&lt;/code&gt;&quot; matches file or directory &quot;&lt;code&gt;bar&lt;/code&gt;&quot; anywhere that is directly under directory &quot;&lt;code&gt;foo&lt;/code&gt;&quot;.</source>
          <target state="translated">前导&amp;ldquo; &lt;code&gt;**&lt;/code&gt; &amp;rdquo;后跟斜杠表示在所有目录中均匹配。例如，&amp;ldquo; &lt;code&gt;**/foo&lt;/code&gt; &amp;rdquo; 在任何地方都匹配文件或目录&amp;ldquo; &lt;code&gt;foo&lt;/code&gt; &amp;rdquo;，与模式&amp;ldquo; &lt;code&gt;foo&lt;/code&gt; &amp;rdquo; 相同。&amp;ldquo; &lt;code&gt;**/foo/bar&lt;/code&gt; &amp;rdquo; 在目录&amp;ldquo; &lt;code&gt;foo&lt;/code&gt; &amp;rdquo; 下的任何位置匹配文件或目录&amp;ldquo; &lt;code&gt;bar&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="97f6b7568cdd7cd0d826aa05b6dbc1219066bda8" translate="yes" xml:space="preserve">
          <source>A leading &amp;ldquo;&lt;strong&gt;&amp;rdquo; followed by a slash means match in all directories. For example, &amp;ldquo;&lt;/strong&gt;/foo&amp;rdquo; matches file or directory &amp;ldquo;foo&amp;rdquo; anywhere, the same as pattern &amp;ldquo;foo&amp;rdquo;. &amp;ldquo;**/foo/bar&amp;rdquo; matches file or directory &amp;ldquo;bar&amp;rdquo; anywhere that is directly under directory &amp;ldquo;foo&amp;rdquo;.</source>
          <target state="translated">前导&amp;ldquo; &lt;strong&gt;&amp;rdquo;后跟斜杠表示在所有目录中均匹配。例如，&amp;ldquo;&lt;/strong&gt; / foo&amp;rdquo;在任何位置都匹配文件或目录&amp;ldquo; foo&amp;rdquo;，与模式&amp;ldquo; foo&amp;rdquo;相同。&amp;ldquo; ** / foo / bar&amp;rdquo;与文件或目录&amp;ldquo; bar&amp;rdquo;匹配，直接位于目录&amp;ldquo; foo&amp;rdquo;下。</target>
        </trans-unit>
        <trans-unit id="2c8f962f2c5484e8e35937a88a5b10524899265d" translate="yes" xml:space="preserve">
          <source>A line starting with # serves as a comment. Put a backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;) in front of the first hash for patterns that begin with a hash.</source>
          <target state="translated">以＃开头的行用作注释。对于以哈希开头的模式，请在第一个哈希之前放置反斜杠（&amp;ldquo; &lt;code&gt;\&lt;/code&gt; &amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="93ea1d2be8a3f17ecb8e1b8c1df7c56dd65b653c" translate="yes" xml:space="preserve">
          <source>A line that defines a value can be continued to the next line by ending it with a &lt;code&gt;\&lt;/code&gt;; the backquote and the end-of-line are stripped. Leading whitespaces after &lt;code&gt;name =&lt;/code&gt;, the remainder of the line after the first comment character &lt;code&gt;#&lt;/code&gt; or &lt;code&gt;;&lt;/code&gt;, and trailing whitespaces of the line are discarded unless they are enclosed in double quotes. Internal whitespaces within the value are retained verbatim.</source>
          <target state="translated">定义值的行可以通过以 &lt;code&gt;\&lt;/code&gt; 结束而继续到下一行。反引号和行尾被删除。 &lt;code&gt;name =&lt;/code&gt; 之后的前导空格，第一个注释字符 &lt;code&gt;#&lt;/code&gt; 或 &lt;code&gt;;&lt;/code&gt; 之后的其余行 ，除非该行的尾部空格用双引号引起来，否则将被丢弃。值内的内部空格逐字保留。</target>
        </trans-unit>
        <trans-unit id="a28fcbbaf3322dfc2cd1a1b29e1a2bcbe8fb4570" translate="yes" xml:space="preserve">
          <source>A line that defines a value can be continued to the next line by ending it with a &lt;code&gt;\&lt;/code&gt;; the backslash and the end-of-line are stripped. Leading whitespaces after &lt;code&gt;name =&lt;/code&gt;, the remainder of the line after the first comment character &lt;code&gt;#&lt;/code&gt; or &lt;code&gt;;&lt;/code&gt;, and trailing whitespaces of the line are discarded unless they are enclosed in double quotes. Internal whitespaces within the value are retained verbatim.</source>
          <target state="translated">定义值的行可以通过以 &lt;code&gt;\&lt;/code&gt; 结尾结束而继续到下一行。反斜杠和行尾被去除。 &lt;code&gt;name =&lt;/code&gt; 之后的前导空格，第一个注释字符 &lt;code&gt;#&lt;/code&gt; 或 &lt;code&gt;;&lt;/code&gt; 之后的其余行，除非该行的尾部空格用双引号引起来，否则将被丢弃。值内的内部空格逐字保留。</target>
        </trans-unit>
        <trans-unit id="e045379bf9ceca1c017025a4aa6255f96ea8439c" translate="yes" xml:space="preserve">
          <source>A list of SSL ciphers to use when negotiating an SSL connection. The available ciphers depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_CIPHER_LIST&lt;/code&gt; option; see the libcurl documentation for more details on the format of this list.</source>
          <target state="translated">协商SSL连接时要使用的SSL密码列表。可用的密码取决于libcurl是针对NSS还是针对OpenSSL构建的，以及所使用的加密库的特定配置。在内部，这会设置 &lt;code&gt;CURLOPT_SSL_CIPHER_LIST&lt;/code&gt; 选项；有关此列表格式的更多详细信息，请参见libcurl文档。</target>
        </trans-unit>
        <trans-unit id="6c29c3e295aee253a56f78c75eca16ee4e34a579" translate="yes" xml:space="preserve">
          <source>A list of arguments, acceptable to &lt;code&gt;git rev-parse&lt;/code&gt; and &lt;code&gt;git rev-list&lt;/code&gt; (and containing a named ref, see SPECIFYING REFERENCES below), that specifies the specific objects and references to transport. For example, &lt;code&gt;master~10..master&lt;/code&gt; causes the current master reference to be packaged along with all objects added since its 10th ancestor commit. There is no explicit limit to the number of references and objects that may be packaged.</source>
          <target state="translated">&lt;code&gt;git rev-parse&lt;/code&gt; 和 &lt;code&gt;git rev-list&lt;/code&gt; 可接受的参数列表（并包含命名的ref，请参见下面的&amp;ldquo;指定参考&amp;rdquo;），用于指定要传输的特定对象和引用。例如， &lt;code&gt;master~10..master&lt;/code&gt; 导致将当前的master引用与自其第十个祖先提交以来添加的所有对象一起打包。对可以打包的引用和对象的数量没有明确的限制。</target>
        </trans-unit>
        <trans-unit id="420b50217489bdf5f6fb9acc6b31c779455eb7fa" translate="yes" xml:space="preserve">
          <source>A list of arguments, acceptable to &lt;code&gt;git rev-parse&lt;/code&gt; and &lt;code&gt;git rev-list&lt;/code&gt;, that specifies the specific objects and references to export. For example, &lt;code&gt;master~10..master&lt;/code&gt; causes the current master reference to be exported along with all objects added since its 10th ancestor commit and (unless the --reference-excluded-parents option is specified) all files common to master~9 and master~10.</source>
          <target state="translated">&lt;code&gt;git rev-parse&lt;/code&gt; 和 &lt;code&gt;git rev-list&lt;/code&gt; 可接受的参数列表，用于指定要导出的特定对象和引用。例如， &lt;code&gt;master~10..master&lt;/code&gt; 导致当前主引用与所有自其第十个祖先提交以来添加的对象一起导出，并且（除非指定了--reference-excluded-parents选项）所有master〜9和主人〜10。</target>
        </trans-unit>
        <trans-unit id="fb05e036e321c60d20fab2990848c796c4fdcdc0" translate="yes" xml:space="preserve">
          <source>A list of colors, separated by commas, that can be used to draw history lines in &lt;code&gt;git log --graph&lt;/code&gt;.</source>
          <target state="translated">用逗号分隔的颜色列表，可用于在 &lt;code&gt;git log --graph&lt;/code&gt; 中绘制历史记录行。</target>
        </trans-unit>
        <trans-unit id="4a1df4463e366ffdf2ab4e340e7deb2135f625d6" translate="yes" xml:space="preserve">
          <source>A list of enabled hooks</source>
          <target state="translated">启用的钩子列表</target>
        </trans-unit>
        <trans-unit id="bf5bc7dd64f11fdc046f9ab831535ad5346e3642" translate="yes" xml:space="preserve">
          <source>A list of metadata for the ith object ID including:</source>
          <target state="translated">第i个对象ID的元数据清单,包括:</target>
        </trans-unit>
        <trans-unit id="71a1660072afab5f192d304c6526e11a86c64fed" translate="yes" xml:space="preserve">
          <source>A list of objects, where each &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; in the list contains a reference to its successor (for example, the successor of a &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; could be one of its &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt;).</source>
          <target state="translated">对象列表，其中列表中的每个&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;都包含对其后继对象的引用（例如，&lt;a href=&quot;#def_commit&quot;&gt;提交&lt;/a&gt;的后继对象可以是&lt;a href=&quot;#def_parent&quot;&gt;其父对象之一&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b5ed6b3e420a3426ad69e7d40c511b1585c55951" translate="yes" xml:space="preserve">
          <source>A list of packfile names.</source>
          <target state="translated">包装文件名称的列表;</target>
        </trans-unit>
        <trans-unit id="eacf8acfc6a510356f2536425e15b68215e037b6" translate="yes" xml:space="preserve">
          <source>A list of references used to limit the references reported as available. This is principally of use to &lt;code&gt;git fetch&lt;/code&gt;, which expects to receive only those references asked for and not necessarily everything in the pack (in this case, &lt;code&gt;git bundle&lt;/code&gt; acts like &lt;code&gt;git fetch-pack&lt;/code&gt;).</source>
          <target state="translated">引用列表，用于限制报告为可用的引用。这主要是用于 &lt;code&gt;git fetch&lt;/code&gt; ，它希望仅接收所要求的那些引用，而不一定接收包中的所有内容（在这种情况下， &lt;code&gt;git bundle&lt;/code&gt; 的作用类似于 &lt;code&gt;git fetch-pack&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="97e674656171c048f36512c6e555d0bf166acfba" translate="yes" xml:space="preserve">
          <source>A listing will be written to stdout providing the association of temporary file names to tracked path names. The listing format has two variations:</source>
          <target state="translated">一个列表将被写入stdout,提供临时文件名与跟踪路径名的关联。列表格式有两种变化。</target>
        </trans-unit>
        <trans-unit id="4f1fa860bd3075a2f2e7d9bfa6fd3e508ce503b8" translate="yes" xml:space="preserve">
          <source>A long running filter demo implementation can be found in &lt;code&gt;contrib/long-running-filter/example.pl&lt;/code&gt; located in the Git core repository. If you develop your own long running filter process then the &lt;code&gt;GIT_TRACE_PACKET&lt;/code&gt; environment variables can be very helpful for debugging (see &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;).</source>
          <target state="translated">可以在Git核心存储库中的 &lt;code&gt;contrib/long-running-filter/example.pl&lt;/code&gt; 中找到长期运行的过滤器演示实现。如果您开发自己的长期运行的过滤器过程，那么 &lt;code&gt;GIT_TRACE_PACKET&lt;/code&gt; 环境变量对于调试非常有用（请参见&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0c85a74fa5c3962acf646f43bc3d679fdbcbb049" translate="yes" xml:space="preserve">
          <source>A mapping will override any user information from P4. Mappings for multiple P4 user can be defined.</source>
          <target state="translated">一个映射将覆盖任何来自P4的用户信息。可以定义多个P4用户的映射。</target>
        </trans-unit>
        <trans-unit id="f830620e3507664edd811855851325f3aba696d1" translate="yes" xml:space="preserve">
          <source>A mark reference, &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; is the mark number.</source>
          <target state="translated">标记参考 &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; 是标记编号。</target>
        </trans-unit>
        <trans-unit id="baabb9591c6356cfbcbcedc1f1f1f517fd26280b" translate="yes" xml:space="preserve">
          <source>A merge is made by combining the changes made in &lt;code&gt;branchname&lt;/code&gt; and the changes made up to the latest commit in your current branch since their histories forked. The work tree is overwritten by the result of the merge when this combining is done cleanly, or overwritten by a half-merged results when this combining results in conflicts. Therefore, if you have uncommitted changes touching the same files as the ones impacted by the merge, Git will refuse to proceed. Most of the time, you will want to commit your changes before you can merge, and if you don&amp;rsquo;t, then &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; can take these changes away while you&amp;rsquo;re doing the merge, and reapply them afterwards.</source>
          <target state="translated">通过合并 &lt;code&gt;branchname&lt;/code&gt; 进行的更改和自分支中的历史记录以来当前分支中最新提交所做的更改，可以进行合并。干净地进行合并时，工作树将被合并的结果覆盖，而当合并导致冲突时，工作树将被半合并的结果覆盖。因此，如果您有未提交的更改涉及与合并影响的文件相同的文件，则Git将拒绝继续。在大多数情况下，您会希望在合并之前先提交更改，如果不这样做，则&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;可以在合并时取消这些更改，然后再重新应用。</target>
        </trans-unit>
        <trans-unit id="e4d489b543f60fc98d2a6018d75091a747eea01a" translate="yes" xml:space="preserve">
          <source>A merged version reconciling the changes from all branches to be merged is committed, and your &lt;code&gt;HEAD&lt;/code&gt;, index, and working tree are updated to it. It is possible to have modifications in the working tree as long as they do not overlap; the update will preserve them.</source>
          <target state="translated">提交了一个合并版本，该版本协调了要合并的所有分支的更改，并且 &lt;code&gt;HEAD&lt;/code&gt; ，索引和工作树也已更新到该版本。只要它们不重叠，就有可能在工作树中进行修改。更新将保留它们。</target>
        </trans-unit>
        <trans-unit id="556c7318c2e7e187ba3d844ceeba1d7c90165db2" translate="yes" xml:space="preserve">
          <source>A minimal repository browser and Git tool output highlighter written in C using Ncurses.</source>
          <target state="translated">一个使用Ncurses用C语言编写的最小版本库浏览器和Git工具输出高亮程序。</target>
        </trans-unit>
        <trans-unit id="0f82fb44f773fe4ef6363789a0bed7a920af8c57" translate="yes" xml:space="preserve">
          <source>A minor issue, but users who have a goal to update all names and emails in a repository may be led to --env-filter which will only update authors and committers, missing taggers.</source>
          <target state="translated">一个小问题,但如果用户的目标是更新版本库中的所有名字和电子邮件,可能会被引导到--env-filter,这将只更新作者和提交者,缺少标记者。</target>
        </trans-unit>
        <trans-unit id="ee7974b838cbb4f29c64d1d141d31a017781be24" translate="yes" xml:space="preserve">
          <source>A more detailed explanation follows.</source>
          <target state="translated">下面再详细解释一下。</target>
        </trans-unit>
        <trans-unit id="1294d206b2b9b4a7e8a2c5b691b195e05326798f" translate="yes" xml:space="preserve">
          <source>A naive color-coded diff of diffs is actually a bit hard to read, though, as it colors the entire lines red or green. The line that added &quot;What is unexpected&quot; in the old commit, for example, is completely red, even if the intent of the old commit was to add something.</source>
          <target state="translated">不过一个天真的彩色编码的 diffs 其实有点难读,因为它把整行都染成了红色或绿色。比如老提交中添加了 &quot;意料之外的东西 &quot;的那一行就完全是红色的,即使老提交的本意是添加一些东西。</target>
        </trans-unit>
        <trans-unit id="f995936d742d7948d27ea58d580269673915afeb" translate="yes" xml:space="preserve">
          <source>A name referring to a list of repositories as the value of remotes.&amp;lt;group&amp;gt; in the configuration file. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">该名称引用存储库列表作为配置文件中remotes。&amp;lt;group&amp;gt;的值。（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="285bedb08cb2a07c72d29f3452de603f4eff78e2" translate="yes" xml:space="preserve">
          <source>A name that begins with &lt;code&gt;refs/&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) that points to an &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt; or another ref (the latter is called a &lt;a href=&quot;#def_symref&quot;&gt;symbolic ref&lt;/a&gt;). For convenience, a ref can sometimes be abbreviated when used as an argument to a Git command; see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details. Refs are stored in the &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;.</source>
          <target state="translated">以 &lt;code&gt;refs/&lt;/code&gt; 开头的名称（例如 &lt;code&gt;refs/heads/master&lt;/code&gt; ），指向一个&lt;a href=&quot;#def_object_name&quot;&gt;对象名称&lt;/a&gt;或另一个ref（后者称为&lt;a href=&quot;#def_symref&quot;&gt;符号ref&lt;/a&gt;）。为了方便起见，有时在将ref用作Git命令的参数时会缩写ref；有关详细信息，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;。引用存储在&lt;a href=&quot;#def_repository&quot;&gt;存储库中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7703b2466f10a68f3b1c01b58b3d6c6dd1bbbf9e" translate="yes" xml:space="preserve">
          <source>A newly created object is stored in its own file. The objects are splayed over 256 subdirectories using the first two characters of the sha1 object name to keep the number of directory entries in &lt;code&gt;objects&lt;/code&gt; itself to a manageable number. Objects found here are often called &lt;code&gt;unpacked&lt;/code&gt; (or &lt;code&gt;loose&lt;/code&gt;) objects.</source>
          <target state="translated">新创建的对象存储在其自己的文件中。使用sha1对象名称的前两个字符在256个子目录中扩展对象，以使 &lt;code&gt;objects&lt;/code&gt; 本身中的目录条目数保持在可管理的数量。在这里找到的对象通常称为 &lt;code&gt;unpacked&lt;/code&gt; （或 &lt;code&gt;loose&lt;/code&gt; ）的对象。</target>
        </trans-unit>
        <trans-unit id="4642a2b17c96a073cdb3a7085d71034eb452a227" translate="yes" xml:space="preserve">
          <source>A non-ambiguous short name of the objects name. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode.</source>
          <target state="translated">对象名称的一个非含糊的简称。选项core.warningAmbiguousRefs用于选择严格的缩写模式。</target>
        </trans-unit>
        <trans-unit id="969533e24645fc570f9e6901a33806920e5cb706" translate="yes" xml:space="preserve">
          <source>A note on commit messages: Though not required, it&amp;rsquo;s a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.</source>
          <target state="translated">关于提交消息的注释：尽管不是必需的，但是最好以一条简短的（少于50个字符的）短行来概述提交更改，然后以空行然后再进行更全面的描述来开始提交消息。直到提交消息中的第一行空白为止的文本都被视为提交标题，并且该标题在整个Git中都会使用。例如，&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;将提交转换为电子邮件，并在主题行上使用标题，在正文中使用其余提交。</target>
        </trans-unit>
        <trans-unit id="4dfc512a94e79667c45c7af73a6fa69e373a158c" translate="yes" xml:space="preserve">
          <source>A number controlling how many seconds to delay before showing optional progress indicators. Defaults to 2.</source>
          <target state="translated">控制在显示可选进度指示器之前要延迟多少秒的数字。默认值为2。</target>
        </trans-unit>
        <trans-unit id="678367292507a434e0e80079657b6dfcb1357dad" translate="yes" xml:space="preserve">
          <source>A number controlling the amount of output shown by the recursive merge strategy. Overrides merge.verbosity. See &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;</source>
          <target state="translated">一个数字，控制递归合并策略显示的输出量。覆盖merge.verbosity。见&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b6753b358cd59601b720b7e321e301f821aeaac" translate="yes" xml:space="preserve">
          <source>A number of commands are useful for keeping track of what you&amp;rsquo;re about to commit:</source>
          <target state="translated">许多命令可用于跟踪您将要提交的内容：</target>
        </trans-unit>
        <trans-unit id="9a527e05c01a1cd1e2fbbfb008d8a0a9991b3e36" translate="yes" xml:space="preserve">
          <source>A number of other receive.* config options are available to tweak its behavior, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">还有许多其他的receive。*配置选项可用来调整其行为，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2735235afad8c3de74567bf475c2f66e22a1a38" translate="yes" xml:space="preserve">
          <source>A one-shot pull is a sign that a commit history is now crossing the boundary between one circle of people (e.g. &quot;people who are primarily interested in the networking part of the kernel&quot;) who may have their own set of tags (e.g. &quot;this is the third release candidate from the networking group to be proposed for general consumption with 2.6.21 release&quot;) to another circle of people (e.g. &quot;people who integrate various subsystem improvements&quot;). The latter are usually not interested in the detailed tags used internally in the former group (that is what &quot;internal&quot; means). That is why it is desirable not to follow tags automatically in this case.</source>
          <target state="translated">一次性拉取标志着一个提交历史现在正在跨越一个圈子的人(比如 &quot;主要对内核的网络部分感兴趣的人&quot;)与另一个圈子的人(比如 &quot;整合各种子系统改进的人&quot;)之间的边界,这些人可能有自己的一套标签(比如 &quot;这是网络组的第三个发布候选版本,将与2.6.21版本一起提出供一般人使用&quot;)。后者通常对前一个组内部使用的详细标签不感兴趣(这就是 &quot;内部 &quot;的意思)。这就是为什么在这种情况下最好不要自动跟随标签。</target>
        </trans-unit>
        <trans-unit id="9cabaac84bf06e47bfc060c7436d54129d5c9635" translate="yes" xml:space="preserve">
          <source>A pack index file (.idx) is generated for fast, random access to the objects in the pack. Placing both the index file (.idx) and the packed archive (.pack) in the pack/ subdirectory of $GIT_OBJECT_DIRECTORY (or any of the directories on $GIT_ALTERNATE_OBJECT_DIRECTORIES) enables Git to read from the pack archive.</source>
          <target state="translated">一个pack索引文件(.idx)被生成,以便快速、随机地访问pack中的对象。将索引文件 (.idx)和打包后的存档 (.pack)放在 $GIT_OBJECT_DIRECTORY 的 pack/子目录下 (或 $GIT_ALTERNATE_OBJECT_DIRECTORIES 的任何一个目录下),就可以让 Git 从打包后的存档中读取。</target>
        </trans-unit>
        <trans-unit id="397ffaa6c68ed0147644cba4450a6f826844c8cb" translate="yes" xml:space="preserve">
          <source>A pack is a collection of objects, individually compressed, with delta compression applied, stored in a single file, with an associated index file.</source>
          <target state="translated">一个包是一个对象的集合,单独压缩,应用delta压缩,存储在一个文件中,并有一个相关的索引文件。</target>
        </trans-unit>
        <trans-unit id="f35f65ed82291bd06ac4c67bd1644d87a71cb117" translate="yes" xml:space="preserve">
          <source>A packed archive can express the base object of a delta as either a 20-byte object name or as an offset in the stream, but ancient versions of Git don&amp;rsquo;t understand the latter. By default, &lt;code&gt;git pack-objects&lt;/code&gt; only uses the former format for better compatibility. This option allows the command to use the latter format for compactness. Depending on the average delta chain length, this option typically shrinks the resulting packfile by 3-5 per-cent.</source>
          <target state="translated">压缩档案可以将增量的基础对象表示为20字节的对象名称，也可以表示为流中的偏移量，但是Git的古代版本不理解后者。默认情况下， &lt;code&gt;git pack-objects&lt;/code&gt; 仅使用前一种格式以获得更好的兼容性。此选项允许命令使用后一种格式来简化。根据平均增量链长度，此选项通常会将生成的packfile缩小3-5％。</target>
        </trans-unit>
        <trans-unit id="60fd37e1abf8d7c37fbc7d9812df5fcd79af795e" translate="yes" xml:space="preserve">
          <source>A packed archive is an efficient way to transfer a set of objects between two repositories as well as an access efficient archival format. In a packed archive, an object is either stored as a compressed whole or as a difference from some other object. The latter is often called a delta.</source>
          <target state="translated">压缩档案是在两个存储库之间传输一组对象的有效方法,也是一种有效的档案格式。在打包档案中,一个对象要么作为一个压缩的整体,要么作为与其他对象的差异来存储。后者通常被称为delta。</target>
        </trans-unit>
        <trans-unit id="bf032ee74744146d5a15b7c697cecedcaf0b0c4f" translate="yes" xml:space="preserve">
          <source>A paragraph in the commit log message. This can be given more than once and each &amp;lt;message&amp;gt; becomes its own paragraph.</source>
          <target state="translated">提交日志消息中的一个段落。可以多次给出此信息，并且每个&amp;lt;message&amp;gt;都将成为其自己的段落。</target>
        </trans-unit>
        <trans-unit id="8ae6bc184aa1a805bb37320ee63c3bc2d3ceedc5" translate="yes" xml:space="preserve">
          <source>A particularly useful way is to see if an added file has lines created by copy-and-paste from existing files. Sometimes this indicates that the developer was being sloppy and did not refactor the code properly. You can first find the commit that introduced the file with:</source>
          <target state="translated">一个特别有用的方法是查看一个新增的文件是否有从现有文件中复制粘贴而产生的行。有时这表明开发者很马虎,没有正确重构代码。你可以先找到引入该文件的提交。</target>
        </trans-unit>
        <trans-unit id="70409c2f17849d4a005f3c1893f70bfb2726cd34" translate="yes" xml:space="preserve">
          <source>A path can use C-style string quoting; this is accepted in all cases and mandatory if the filename starts with double quote or contains &lt;code&gt;LF&lt;/code&gt;. In C-style quoting, the complete name should be surrounded with double quotes, and any &lt;code&gt;LF&lt;/code&gt;, backslash, or double quote characters must be escaped by preceding them with a backslash (e.g., &lt;code&gt;&quot;path/with\n, \\ and \&quot; in it&quot;&lt;/code&gt;).</source>
          <target state="translated">路径可以使用C样式的字符串引用；如果文件名以双引号开头或包含 &lt;code&gt;LF&lt;/code&gt; ,则在所有情况下均接受此命令，并且是强制性的。在C样式的引号中，全名应该用双引号引起来，并且任何 &lt;code&gt;LF&lt;/code&gt; ，反斜杠或双引号字符都必须在其前面加上反斜杠来进行转义（例如， &lt;code&gt;&quot;path/with\n, \\ and \&quot; in it&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bd2947c5ab63d63637e419f1d545864acc22513b" translate="yes" xml:space="preserve">
          <source>A path to which the &lt;code&gt;diff&lt;/code&gt; attribute is set is treated as text, even when they contain byte values that normally never appear in text files, such as NUL.</source>
          <target state="translated">设置 &lt;code&gt;diff&lt;/code&gt; 属性的路径被视为文本，即使它们包含通常从不出现在文本文件中的字节值（例如NUL）也是如此。</target>
        </trans-unit>
        <trans-unit id="c497cf3cb539fc75cfa79107d99052fa1c172747" translate="yes" xml:space="preserve">
          <source>A path to which the &lt;code&gt;diff&lt;/code&gt; attribute is unset will generate &lt;code&gt;Binary files differ&lt;/code&gt; (or a binary patch, if binary patches are enabled).</source>
          <target state="translated">未设置 &lt;code&gt;diff&lt;/code&gt; 属性的路径将生成 &lt;code&gt;Binary files differ&lt;/code&gt; （如果启用了二进制修补程序，则二进制文件会有所不同）。</target>
        </trans-unit>
        <trans-unit id="88c800d486d5ce3a0265a47a1feb9f3c335f6f77" translate="yes" xml:space="preserve">
          <source>A path to which the &lt;code&gt;diff&lt;/code&gt; attribute is unspecified first gets its contents inspected, and if it looks like text and is smaller than core.bigFileThreshold, it is treated as text. Otherwise it would generate &lt;code&gt;Binary files differ&lt;/code&gt;.</source>
          <target state="translated">首先检查未指定 &lt;code&gt;diff&lt;/code&gt; 属性的路径的内容，如果该路径看起来像文本，并且小于core.bigFileThreshold，则将其视为文本。否则会生成与 &lt;code&gt;Binary files differ&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1de5fce3d256d15d9371f68eb7be9e8c39bff70d" translate="yes" xml:space="preserve">
          <source>A pathspec that begins with a colon &lt;code&gt;:&lt;/code&gt; has special meaning. In the short form, the leading colon &lt;code&gt;:&lt;/code&gt; is followed by zero or more &quot;magic signature&quot; letters (which optionally is terminated by another colon &lt;code&gt;:&lt;/code&gt;), and the remainder is the pattern to match against the path. The &quot;magic signature&quot; consists of ASCII symbols that are neither alphanumeric, glob, regex special characters nor colon. The optional colon that terminates the &quot;magic signature&quot; can be omitted if the pattern begins with a character that does not belong to &quot;magic signature&quot; symbol set and is not a colon.</source>
          <target state="translated">以冒号开头的pathspec &lt;code&gt;:&lt;/code&gt; 具有特殊的意义。在简短形式中，前导冒号 &lt;code&gt;:&lt;/code&gt; 后跟零个或多个&amp;ldquo;魔术签名&amp;rdquo;字母（可以选择由另一个冒号 &lt;code&gt;:&lt;/code&gt; 终止），其余为与路径匹配的模式。&amp;ldquo;魔术签名&amp;rdquo;由ASCII符号组成，它们既不是字母数字，全局，正则表达式特殊字符也不是冒号。如果模式以不属于&amp;ldquo;魔术签名&amp;rdquo;符号集且不是冒号的字符开头，则可以省略终止&amp;ldquo;魔术签名&amp;rdquo;的可选冒号。</target>
        </trans-unit>
        <trans-unit id="5dbd2b8e2f5a79d8f4767d53dab7382344add01a" translate="yes" xml:space="preserve">
          <source>A pathspec with only a colon means &quot;there is no pathspec&quot;. This form should not be combined with other pathspec.</source>
          <target state="translated">只有冒号的路径规格表示 &quot;没有路径规格&quot;。这种形式不应与其他路径规格合并。</target>
        </trans-unit>
        <trans-unit id="905a72351f89ce389bbe3fe0bc52dfbff0e65e1a" translate="yes" xml:space="preserve">
          <source>A pattern specified on the command line with --exclude or read from the file specified with --exclude-from is relative to the top of the directory tree. A pattern read from a file specified by --exclude-per-directory is relative to the directory that the pattern file appears in.</source>
          <target state="translated">在命令行中用--exclude指定的模式或从--exclud-from指定的文件中读取的模式是相对于目录树的顶部而言的。从--exclude-per-directory指定的文件中读取的模式是相对于模式文件所在的目录而言的。</target>
        </trans-unit>
        <trans-unit id="543c0b6dffa14304d5bbca9c7badb06a27012480" translate="yes" xml:space="preserve">
          <source>A plain file &lt;code&gt;.git&lt;/code&gt; at the root of a working tree that points at the directory that is the real repository.</source>
          <target state="translated">位于工作树根目录的纯文件 &lt;code&gt;.git&lt;/code&gt; 指向实际存储库的目录。</target>
        </trans-unit>
        <trans-unit id="d67f2fd432760e7725d26e3c634fda7223350a3d" translate="yes" xml:space="preserve">
          <source>A portable graphical interface to Git</source>
          <target state="translated">Git的便携式图形界面</target>
        </trans-unit>
        <trans-unit id="de9f6646a7f195313b665f81866ba2d97ea2d1a5" translate="yes" xml:space="preserve">
          <source>A project will often generate files that you do 'not' want to track with Git. This typically includes files generated by a build process or temporary backup files made by your editor. Of course, 'not' tracking files with Git is just a matter of 'not' calling &lt;code&gt;git add&lt;/code&gt; on them. But it quickly becomes annoying to have these untracked files lying around; e.g. they make &lt;code&gt;git add .&lt;/code&gt; practically useless, and they keep showing up in the output of &lt;code&gt;git status&lt;/code&gt;.</source>
          <target state="translated">一个项目通常会生成您不想使用Git跟踪的文件。这通常包括由构建过程生成的文件或由编辑器生成的临时备份文件。当然，&amp;ldquo;不&amp;rdquo;使用Git跟踪文件只是&amp;ldquo;不&amp;rdquo;在文件上调用 &lt;code&gt;git add&lt;/code&gt; 的问题。但是，将这些未跟踪的文件放在一起很快变得很烦人。例如他们使 &lt;code&gt;git add .&lt;/code&gt; 几乎没有用，并且它们会不断出现在 &lt;code&gt;git status&lt;/code&gt; 的输出中。</target>
        </trans-unit>
        <trans-unit id="257e75db65122bff5f846fed19aa444a60cd8028" translate="yes" xml:space="preserve">
          <source>A project will often generate files that you do &lt;code&gt;not&lt;/code&gt; want to track with Git. This typically includes files generated by a build process or temporary backup files made by your editor. Of course, &lt;code&gt;not&lt;/code&gt; tracking files with Git is just a matter of &lt;code&gt;not&lt;/code&gt; calling &lt;code&gt;git add&lt;/code&gt; on them. But it quickly becomes annoying to have these untracked files lying around; e.g. they make &lt;code&gt;git add .&lt;/code&gt; practically useless, and they keep showing up in the output of &lt;code&gt;git status&lt;/code&gt;.</source>
          <target state="translated">一个项目往往会生成文件，你 &lt;code&gt;not&lt;/code&gt; 希望跟踪使用Git。这通常包括由构建过程生成的文件或由编辑器生成的临时备份文件。当然， &lt;code&gt;not&lt;/code&gt; 使用Git跟踪文件只是 &lt;code&gt;not&lt;/code&gt; 它们调用 &lt;code&gt;git add&lt;/code&gt; 的问题。但是，将这些未跟踪的文件摆在身边很快变得很烦人。例如，他们使 &lt;code&gt;git add .&lt;/code&gt; 实际上几乎没有用，并且它们一直显示在 &lt;code&gt;git status&lt;/code&gt; 的输出中。</target>
        </trans-unit>
        <trans-unit id="6db2ee1a1d750a2aa19ca518ec09fb893a88a85d" translate="yes" xml:space="preserve">
          <source>A range of commits could also be removed with rebase. If we have the following situation:</source>
          <target state="translated">也可以用rebase删除一系列的提交。如果我们有以下情况。</target>
        </trans-unit>
        <trans-unit id="a9d115fddbdf7f10bd3b9f771bde1590c6813bbd" translate="yes" xml:space="preserve">
          <source>A really simple TCP Git daemon that normally listens on port &quot;DEFAULT_GIT_PORT&quot; aka 9418. It waits for a connection asking for a service, and will serve that service if it is enabled.</source>
          <target state="translated">一个非常简单的 TCP Git 守护进程,通常监听端口为 &quot;DEFAULT_GIT_PORT&quot; 也就是 9418。它等待一个请求服务的连接,如果服务被启用,它将为该服务提供服务。</target>
        </trans-unit>
        <trans-unit id="3eaf62e43457d050db3acd458814891c29242983" translate="yes" xml:space="preserve">
          <source>A really simple server for Git repositories</source>
          <target state="translated">一个真正简单的Git仓库服务器。</target>
        </trans-unit>
        <trans-unit id="d9323a3a61d783f2901a029c1a9555370896ed64" translate="yes" xml:space="preserve">
          <source>A recommended practice to deal with a repository with too many refs is to pack its refs with &lt;code&gt;--all&lt;/code&gt; once, and occasionally run &lt;code&gt;git pack-refs&lt;/code&gt;. Tags are by definition stationary and are not expected to change. Branch heads will be packed with the initial &lt;code&gt;pack-refs --all&lt;/code&gt;, but only the currently active branch heads will become unpacked, and the next &lt;code&gt;pack-refs&lt;/code&gt; (without &lt;code&gt;--all&lt;/code&gt;) will leave them unpacked.</source>
          <target state="translated">值得推荐的做法来处理太多裁判的存储库是收拾它裁判 &lt;code&gt;--all&lt;/code&gt; 一次，偶尔运行 &lt;code&gt;git pack-refs&lt;/code&gt; 。根据定义，标签是固定的，并且不会更改。分支头将使用初始 &lt;code&gt;pack-refs --all&lt;/code&gt; ，但仅当前活动的分支头将被解压缩，而下一个 &lt;code&gt;pack-refs&lt;/code&gt; （不带 &lt;code&gt;--all&lt;/code&gt; ）将使其解压缩。</target>
        </trans-unit>
        <trans-unit id="69fd7125bed2f55c76f0826ae0ec95817fbc826b" translate="yes" xml:space="preserve">
          <source>A recommended work cycle for a &quot;subsystem maintainer&quot; who works on that project and has an own &quot;public repository&quot; goes like this:</source>
          <target state="translated">对于在该项目中工作的 &quot;子系统维护者 &quot;来说,一个推荐的工作周期是这样的,他有一个自己的 &quot;公共仓库&quot;。</target>
        </trans-unit>
        <trans-unit id="4fc51d6ef6719c059d48b71f7162885a19b6d5bb" translate="yes" xml:space="preserve">
          <source>A recommended work cycle for an &quot;individual developer&quot; who does not have a &quot;public&quot; repository is somewhat different. It goes like this:</source>
          <target state="translated">对于没有 &quot;公共 &quot;版本库的 &quot;个人开发者 &quot;来说,推荐的工作周期有些不同。它是这样的。</target>
        </trans-unit>
        <trans-unit id="d5352ae383650a2fe850c6303d60d8b60b542b21" translate="yes" xml:space="preserve">
          <source>A recommended workflow for a &quot;project lead&quot; goes like this:</source>
          <target state="translated">推荐的 &quot;项目负责人 &quot;的工作流程是这样的。</target>
        </trans-unit>
        <trans-unit id="265a7c950336ee05f26938c5f28759002d86d93b" translate="yes" xml:space="preserve">
          <source>A ref followed by the suffix &lt;code&gt;@&lt;/code&gt; with a date specification enclosed in a brace pair (e.g. &lt;code&gt;{yesterday}&lt;/code&gt;, &lt;code&gt;{1 month 2 weeks 3 days 1 hour 1 second ago}&lt;/code&gt; or &lt;code&gt;{1979-02-26 18:30:00}&lt;/code&gt;) specifies the value of the ref at a prior point in time. This suffix may only be used immediately following a ref name and the ref must have an existing log (&lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt;). Note that this looks up the state of your &lt;strong&gt;local&lt;/strong&gt; ref at a given time; e.g., what was in your local &lt;code&gt;master&lt;/code&gt; branch last week. If you want to look at commits made during certain times, see &lt;code&gt;--since&lt;/code&gt; and &lt;code&gt;--until&lt;/code&gt;.</source>
          <target state="translated">引用后跟带后缀 &lt;code&gt;@&lt;/code&gt; 的括号中带有日期说明（例如 &lt;code&gt;{yesterday}&lt;/code&gt; ， &lt;code&gt;{1 month 2 weeks 3 days 1 hour 1 second ago}&lt;/code&gt; 或 &lt;code&gt;{1979-02-26 18:30:00}&lt;/code&gt; ）先前时间点的ref值。该后缀只能在引用名称之后立即使用，并且该引用必须具有现有日志（ &lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt; ）。注意，这会在给定的时间查找&lt;strong&gt;本地&lt;/strong&gt;引用的状态；例如，上周您的本地 &lt;code&gt;master&lt;/code&gt; 分支中的内容。如果要查看在特定时间进行的提交，请参阅 &lt;code&gt;--since&lt;/code&gt; 和 &lt;code&gt;--until&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51716c72ef284c873d21cfca784e510780211d59" translate="yes" xml:space="preserve">
          <source>A ref followed by the suffix &lt;code&gt;@&lt;/code&gt; with an ordinal specification enclosed in a brace pair (e.g. &lt;code&gt;{1}&lt;/code&gt;, &lt;code&gt;{15}&lt;/code&gt;) specifies the n-th prior value of that ref. For example &lt;code&gt;master@{1}&lt;/code&gt; is the immediate prior value of &lt;code&gt;master&lt;/code&gt; while &lt;code&gt;master@{5}&lt;/code&gt; is the 5th prior value of &lt;code&gt;master&lt;/code&gt;. This suffix may only be used immediately following a ref name and the ref must have an existing log (&lt;code&gt;$GIT_DIR/logs/&amp;lt;refname&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">带有后缀 &lt;code&gt;@&lt;/code&gt; 的 ref后面带有大括号对中的序号规范（例如 &lt;code&gt;{1}&lt;/code&gt; ， &lt;code&gt;{15}&lt;/code&gt; ）指定该ref的第n个先验值。例如 &lt;code&gt;master@{1}&lt;/code&gt; 是直接前值 &lt;code&gt;master&lt;/code&gt; 而 &lt;code&gt;master@{5}&lt;/code&gt; 是第5现有值 &lt;code&gt;master&lt;/code&gt; 。该后缀只能在引用名称之后立即使用，并且该引用必须具有现有日志（ &lt;code&gt;$GIT_DIR/logs/&amp;lt;refname&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c828d8d799658a52963b92e85f92230ddce05633" translate="yes" xml:space="preserve">
          <source>A reference is used in Git to specify branches and tags. A branch head is stored in the &lt;code&gt;refs/heads&lt;/code&gt; hierarchy, while a tag is stored in the &lt;code&gt;refs/tags&lt;/code&gt; hierarchy of the ref namespace (typically in &lt;code&gt;$GIT_DIR/refs/heads&lt;/code&gt; and &lt;code&gt;$GIT_DIR/refs/tags&lt;/code&gt; directories or, as entries in file &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; if refs are packed by &lt;code&gt;git gc&lt;/code&gt;).</source>
          <target state="translated">在Git中使用引用来指定分支和标签。分支头存储在 &lt;code&gt;refs/heads&lt;/code&gt; 层次结构中，而标记存储在ref名称空间的 &lt;code&gt;refs/tags&lt;/code&gt; 层次结构中（通常在 &lt;code&gt;$GIT_DIR/refs/heads&lt;/code&gt; 和 &lt;code&gt;$GIT_DIR/refs/tags&lt;/code&gt; 目录中，或者作为文件中的条目） &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; 如果引用由 &lt;code&gt;git gc&lt;/code&gt; 打包）。</target>
        </trans-unit>
        <trans-unit id="199d9188e1602cc5ab2dbdeca79c96ef9dded776" translate="yes" xml:space="preserve">
          <source>A reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;. When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, the latest stash is assumed (that is, &lt;code&gt;stash@{0}&lt;/code&gt;).</source>
          <target state="translated">形式为 &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 引用。如果未给出 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; ，则采用最新的存储（即 &lt;code&gt;stash@{0}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="38b0c287bc0250d0d7c7ad1e770e07055b7fabea" translate="yes" xml:space="preserve">
          <source>A reflog shows the local &quot;history&quot; of a ref. In other words, it can tell you what the 3rd last revision in &lt;code&gt;this&lt;/code&gt; repository was, and what was the current state in &lt;code&gt;this&lt;/code&gt; repository, yesterday 9:14pm. See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; for details.</source>
          <target state="translated">引用日志显示引用的本地&amp;ldquo;历史&amp;rdquo;。换句话说，它可以告诉您昨天晚上9:14 ， &lt;code&gt;this&lt;/code&gt; 存储库中的第三个修订版本是什么，以及 &lt;code&gt;this&lt;/code&gt; 存储库中的当前状态是什么。有关详细信息，请参见&lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5d85fab27e60023cfb23c382a480074950bc3b6" translate="yes" xml:space="preserve">
          <source>A regular &lt;code&gt;D..M&lt;/code&gt; computes the set of commits that are ancestors of &lt;code&gt;M&lt;/code&gt;, but excludes the ones that are ancestors of &lt;code&gt;D&lt;/code&gt;. This is useful to see what happened to the history leading to &lt;code&gt;M&lt;/code&gt; since &lt;code&gt;D&lt;/code&gt;, in the sense that &amp;ldquo;what does &lt;code&gt;M&lt;/code&gt; have that did not exist in &lt;code&gt;D&lt;/code&gt;&amp;rdquo;. The result in this example would be all the commits, except &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; (and &lt;code&gt;D&lt;/code&gt; itself, of course).</source>
          <target state="translated">常规 &lt;code&gt;D..M&lt;/code&gt; 计算作为 &lt;code&gt;M&lt;/code&gt; 的祖先的提交集，但不包括作为 &lt;code&gt;D&lt;/code&gt; 的祖先的提交集。这对于了解自 &lt;code&gt;D&lt;/code&gt; 以来导致 &lt;code&gt;M&lt;/code&gt; 的历史发生了什么很有用，即&amp;ldquo; &lt;code&gt;M&lt;/code&gt; 在 &lt;code&gt;D&lt;/code&gt; 中不存在什么&amp;rdquo;。此示例中的结果将是所有提交，除了 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; （当然还有 &lt;code&gt;D&lt;/code&gt; 本身）。</target>
        </trans-unit>
        <trans-unit id="2ed028af5f97bfe4672822d1dbdbcfbdfebcb455" translate="yes" xml:space="preserve">
          <source>A regular Git &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is used by a developer to identify a conceptual line of development. Since branches are very easy and inexpensive, it is often desirable to have several small branches that each contain very well defined concepts or small incremental yet related changes.</source>
          <target state="translated">常规Git &lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;，供开发人员用来标识开发的概念线。由于分支非常容易且便宜，因此通常希望有几个小分支，每个分支都包含定义明确的概念或小的增量而又相关的更改。</target>
        </trans-unit>
        <trans-unit id="2a66b0bccadf6b4b35ab899aad4e51fd773c916c" translate="yes" xml:space="preserve">
          <source>A remote branch name for tracking updates in the upstream submodule. If the option is not specified, it defaults to &lt;code&gt;master&lt;/code&gt;. A special value of &lt;code&gt;.&lt;/code&gt; is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository. See the &lt;code&gt;--remote&lt;/code&gt; documentation in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; for details.</source>
          <target state="translated">远程分支名称，用于跟踪上游子模块中的更新。如果未指定该选项，则默认为 &lt;code&gt;master&lt;/code&gt; 。的特殊值 &lt;code&gt;.&lt;/code&gt; 用于表示子模块中的分支名称应与当前存储库中的当前分支相同。有关 &lt;code&gt;--remote&lt;/code&gt; 信息，请参见&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]中&lt;/a&gt;的--remote文档。</target>
        </trans-unit>
        <trans-unit id="8604e0756efd07146f34033a41aaf331102e52fc" translate="yes" xml:space="preserve">
          <source>A remote branch name for tracking updates in the upstream submodule. If the option is not specified, it defaults to the remote &lt;code&gt;HEAD&lt;/code&gt;. A special value of &lt;code&gt;.&lt;/code&gt; is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository. See the &lt;code&gt;--remote&lt;/code&gt; documentation in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; for details.</source>
          <target state="translated">远程分支名称，用于跟踪上游子模块中的更新。如果未指定该选项，则默认为远程 &lt;code&gt;HEAD&lt;/code&gt; 。的特殊值 &lt;code&gt;.&lt;/code&gt; 用于表示子模块中的分支名称应与当前存储库中的当前分支相同。有关 &lt;code&gt;--remote&lt;/code&gt; 信息，请参见&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]中&lt;/a&gt;的--remote文档。</target>
        </trans-unit>
        <trans-unit id="8a9a8ecf4e3c29353c757ea95408f73fb557ebe2" translate="yes" xml:space="preserve">
          <source>A remote host to house the repository. When this part is specified, &lt;code&gt;git-receive-pack&lt;/code&gt; is invoked via ssh.</source>
          <target state="translated">用来存储资源库的远程主机。指定此部分后， &lt;code&gt;git-receive-pack&lt;/code&gt; 通过ssh调用git-receive-pack。</target>
        </trans-unit>
        <trans-unit id="cd3cc062c2af6416292b0ef7c3779dab312dd5ae" translate="yes" xml:space="preserve">
          <source>A repeated field which contains a pathspec used to match against a submodule&amp;rsquo;s path to determine if the submodule is of interest to git commands. See &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for details.</source>
          <target state="translated">一个重复的字段，其中包含一个pathspec，用于与子模块的路径进行匹配，以确定git命令是否对该子模块感兴趣。有关详细信息，请参见&lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4f31deb02430ad940d40632dc48c6584b615bca" translate="yes" xml:space="preserve">
          <source>A repository administrator uses the following tools to set up and maintain access to the repository by developers.</source>
          <target state="translated">版本库管理员使用以下工具来设置和维护开发者对版本库的访问。</target>
        </trans-unit>
        <trans-unit id="291ca170f72d7ae46d3d06abf11420385d3bc632" translate="yes" xml:space="preserve">
          <source>A repository browser written in C++ using Qt.</source>
          <target state="translated">一个使用Qt用C++编写的版本库浏览器。</target>
        </trans-unit>
        <trans-unit id="4f0e13fa1004207d77a93fcbfe7ad39156045662" translate="yes" xml:space="preserve">
          <source>A repository that was cloned independently and later added as a submodule or old setups have the submodules git directory inside the submodule instead of embedded into the superprojects git directory.</source>
          <target state="translated">一个独立克隆的版本库,后来被添加为子模块,或者旧的设置中,子模块git目录在子模块里面,而不是嵌入到超级项目git目录中。</target>
        </trans-unit>
        <trans-unit id="e2e984261a0bc7837fbb8a0ec46d94f09fd20ad4" translate="yes" xml:space="preserve">
          <source>A repository, however, may be on a filesystem that handles the filemode correctly, and this variable is set to &lt;code&gt;true&lt;/code&gt; when created, but later may be made accessible from another environment that loses the filemode (e.g. exporting ext4 via CIFS mount, visiting a Cygwin created repository with Git for Windows or Eclipse). In such a case it may be necessary to set this variable to &lt;code&gt;false&lt;/code&gt;. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">但是，存储库可能位于正确处理文件模式的文件系统上，并且在创建该变量时将其设置为 &lt;code&gt;true&lt;/code&gt; ，但以后可以从丢失文件模式的另一个环境中进行访问（例如，通过CIFS挂载导出ext4，访问Cygwin使用Windows或Eclipse的Git创建存储库）。在这种情况下，可能有必要将此变量设置为 &lt;code&gt;false&lt;/code&gt; 。参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78ddd4f9a8a430a958f1b8538f7d6f7067859a81" translate="yes" xml:space="preserve">
          <source>A response cannot have both &quot;ACK&quot; lines as well as a &quot;NAK&quot; line.</source>
          <target state="translated">一个响应不能同时有 &quot;ACK &quot;行和 &quot;NAK &quot;行。</target>
        </trans-unit>
        <trans-unit id="2e8097366b5d40667e4abf117fd6ca3ad0717782" translate="yes" xml:space="preserve">
          <source>A revision parameter &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; typically, but not necessarily, names a commit object. It uses what is called an &lt;code&gt;extended SHA-1&lt;/code&gt; syntax. Here are various ways to spell object names. The ones listed near the end of this list name trees and blobs contained in a commit.</source>
          <target state="translated">修订版参数 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 通常（但不一定）命名提交对象。它使用所谓的 &lt;code&gt;extended SHA-1&lt;/code&gt; 语法。以下是拼写对象名称的各种方法。在此列表末尾附近列出的名称为提交中包含的树和斑点。</target>
        </trans-unit>
        <trans-unit id="62c6349b68cd7c10517a568cd609971cc38e5788" translate="yes" xml:space="preserve">
          <source>A sample script called &lt;code&gt;git merge-one-file&lt;/code&gt; is included in the distribution.</source>
          <target state="translated">该发行版中包含 &lt;code&gt;git merge-one-file&lt;/code&gt; 名为git merge-one-file的示例脚本。</target>
        </trans-unit>
        <trans-unit id="120e3b8f4ab8d187e55b285ecbd0489d8d26eb44" translate="yes" xml:space="preserve">
          <source>A separate reflog is kept for the HEAD, so</source>
          <target state="translated">头部单独保留了一个reflog,所以。</target>
        </trans-unit>
        <trans-unit id="d91dd506db610265c4f5339a204fd581531aedbc" translate="yes" xml:space="preserve">
          <source>A server which decides to communicate (based on a request from a client) using protocol version 2, notifies the client by sending a version string in its initial response followed by an advertisement of its capabilities. Each capability is a key with an optional value. Clients must ignore all unknown keys. Semantics of unknown values are left to the definition of each key. Some capabilities will describe commands which can be requested to be executed by the client.</source>
          <target state="translated">决定使用协议版本2进行通信的服务器(根据客户机的请求),通过在其初始响应中发送一个版本字符串来通知客户机,然后公布其能力。每一个能力都是一个带有可选值的键。客户端必须忽略所有未知的键。未知值的语义由每个键的定义来决定。一些能力将描述可以被客户端请求执行的命令。</target>
        </trans-unit>
        <trans-unit id="1df310f47acb8f98df997eb87d57f9f09ca45534" translate="yes" xml:space="preserve">
          <source>A set of objects which have been compressed into one file (to save space or to transmit them efficiently).</source>
          <target state="translated">一组对象被压缩成一个文件(以节省空间或有效传输)。</target>
        </trans-unit>
        <trans-unit id="760738014c8d15080dd8ad99ff6f8946e9b78b3f" translate="yes" xml:space="preserve">
          <source>A shallow &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; has an incomplete history some of whose &lt;a href=&quot;#def_commit&quot;&gt;commits&lt;/a&gt; have &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt; cauterized away (in other words, Git is told to pretend that these commits do not have the parents, even though they are recorded in the &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;). This is sometimes useful when you are interested only in the recent history of a project even though the real history recorded in the upstream is much larger. A shallow repository is created by giving the &lt;code&gt;--depth&lt;/code&gt; option to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;, and its history can be later deepened with &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">一个浅层&lt;a href=&quot;#def_repository&quot;&gt;存储库&lt;/a&gt;的历史记录不完整，其中一些&lt;a href=&quot;#def_commit&quot;&gt;提交&lt;/a&gt;已被&lt;a href=&quot;#def_parent&quot;&gt;父母&lt;/a&gt;淘汰（换句话说，告诉Git假装这些提交没有父母，即使它们已记录在&lt;a href=&quot;#def_commit_object&quot;&gt;提交对象中&lt;/a&gt;）。即使您只对项目的最近历史感兴趣，即使上游记录的实际历史要大得多，有时这也很有用。通过给&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;提供 &lt;code&gt;--depth&lt;/code&gt; 选项可以创建一个浅薄的存储库，以后可以使用&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;来深化其历史记录。</target>
        </trans-unit>
        <trans-unit id="84d2217cabdf29712dcb12dec7c077c5557961f7" translate="yes" xml:space="preserve">
          <source>A similar notation &lt;code&gt;r1...r2&lt;/code&gt; is called symmetric difference of &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; and is defined as &lt;code&gt;r1 r2 --not $(git merge-base --all r1 r2)&lt;/code&gt;. It is the set of commits that are reachable from either one of &lt;code&gt;r1&lt;/code&gt; (left side) or &lt;code&gt;r2&lt;/code&gt; (right side) but not from both.</source>
          <target state="translated">相似的符号 &lt;code&gt;r1...r2&lt;/code&gt; 称为 &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;r2&lt;/code&gt; 的对称差，定义为 &lt;code&gt;r1 r2 --not $(git merge-base --all r1 r2)&lt;/code&gt; 不是$（git merge-base --all r1 r2）。这是一组可从 &lt;code&gt;r1&lt;/code&gt; （左侧）或 &lt;code&gt;r2&lt;/code&gt; （右侧）中的任何一个而不是两者都到达的提交。</target>
        </trans-unit>
        <trans-unit id="03b58226721c4cc7166ad8aeab7f1974a94bf09d" translate="yes" xml:space="preserve">
          <source>A similar situation may exist if you have many refs outside of &lt;code&gt;refs/heads/&lt;/code&gt; and &lt;code&gt;refs/tags/&lt;/code&gt; that point to related objects (e.g., &lt;code&gt;refs/pull&lt;/code&gt; or &lt;code&gt;refs/changes&lt;/code&gt; used by some hosting providers). By default, clients fetch only heads and tags, and deltas against objects found only in those other groups cannot be sent as-is.</source>
          <target state="translated">如果您在 &lt;code&gt;refs/heads/&lt;/code&gt; 和 &lt;code&gt;refs/tags/&lt;/code&gt; 之外有很多指向相关对象的 &lt;code&gt;refs/pull&lt;/code&gt; （例如，某些托管服务提供商使用的refs / pull或 &lt;code&gt;refs/changes&lt;/code&gt; )，则可能存在类似情况。默认情况下，客户端仅获取标头和标签，并且仅按原样发送针对仅在其他组中找到的对象的增量。</target>
        </trans-unit>
        <trans-unit id="b8ed03d108643fd395f938fb72a9354bf316277b" translate="yes" xml:space="preserve">
          <source>A simple CGI program to serve the contents of a Git repository to Git clients accessing the repository over http:// and https:// protocols. The program supports clients fetching using both the smart HTTP protocol and the backwards-compatible dumb HTTP protocol, as well as clients pushing using the smart HTTP protocol.</source>
          <target state="translated">一个简单的CGI程序,用于向通过http://和https://协议访问仓库的Git客户端提供Git仓库的内容。该程序支持客户端使用智能 HTTP 协议和向后兼容的哑巴 HTTP 协议获取内容,也支持客户端使用智能 HTTP 协议推送内容。</target>
        </trans-unit>
        <trans-unit id="b1195c95166bae01312d67abaddce937f83d9362" translate="yes" xml:space="preserve">
          <source>A simple example showing the use of shell eval on the output, demonstrating the use of --shell. List the prefixes of all heads:</source>
          <target state="translated">一个简单的例子,展示了shell eval对输出的使用,演示了-shell的使用。列出所有头的前缀。</target>
        </trans-unit>
        <trans-unit id="c189ba8d16025c20dba9fcda55d122bc7aead222" translate="yes" xml:space="preserve">
          <source>A simple script to set up &lt;code&gt;gitweb&lt;/code&gt; and a web server for browsing the local repository.</source>
          <target state="translated">一个简单的脚本，用于设置 &lt;code&gt;gitweb&lt;/code&gt; 和用于浏览本地存储库的Web服务器。</target>
        </trans-unit>
        <trans-unit id="24dbbf1a98e941496d92210bf8c09236d984ac48" translate="yes" xml:space="preserve">
          <source>A single Git repository can maintain multiple branches of development. To create a new branch named &quot;experimental&quot;, use</source>
          <target state="translated">一个 Git 仓库可以维护多个开发分支。要创建一个名为 &quot;experimental &quot;的新分支,请使用</target>
        </trans-unit>
        <trans-unit id="25083b025a2b5a403b052b2229f06625158a6247" translate="yes" xml:space="preserve">
          <source>A single Git repository can track development on multiple branches. It does this by keeping a list of &lt;a href=&quot;#def_head&quot;&gt;heads&lt;/a&gt; which reference the latest commit on each branch; the &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; command shows you the list of branch heads:</source>
          <target state="translated">单个Git存储库可以跟踪多个分支上的开发。它通过保留引用每个分支上的最新提交的&lt;a href=&quot;#def_head&quot;&gt;头&lt;/a&gt;列表来实现。在&lt;a href=&quot;git-branch&quot;&gt;git的分支[1]&lt;/a&gt;命令你节目分公司负责人名单：</target>
        </trans-unit>
        <trans-unit id="7288da94d33c9eb52ba6940278539d1555cfdfd9" translate="yes" xml:space="preserve">
          <source>A single character indicating the status of the ref:</source>
          <target state="translated">表示裁判状态的单个字符。</target>
        </trans-unit>
        <trans-unit id="31c723ae3e05980f7081e5473a8ac04766150ab6" translate="yes" xml:space="preserve">
          <source>A single commit, &amp;lt;since&amp;gt;, specifies that the commits leading to the tip of the current branch that are not in the history that leads to the &amp;lt;since&amp;gt; to be output.</source>
          <target state="translated">单个提交&amp;lt;since&amp;gt;，指定导致导致当前分支的尖端的提交不在历史记录中，而该历史记录导致无法输出&amp;lt;since&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="d66b9962c6b8969581e4f00aff7618bfe88dca4e" translate="yes" xml:space="preserve">
          <source>A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, &quot;&lt;code&gt;a/**/b&lt;/code&gt;&quot; matches &quot;&lt;code&gt;a/b&lt;/code&gt;&quot;, &quot;&lt;code&gt;a/x/b&lt;/code&gt;&quot;, &quot;&lt;code&gt;a/x/y/b&lt;/code&gt;&quot; and so on.</source>
          <target state="translated">斜杠后跟两个连续的星号，然后斜杠匹配零个或多个目录。例如，&amp;ldquo; &lt;code&gt;a/**/b&lt;/code&gt; &amp;rdquo;匹配&amp;ldquo; &lt;code&gt;a/b&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;a/x/b&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;a/x/y/b&lt;/code&gt; &amp;rdquo;等等。</target>
        </trans-unit>
        <trans-unit id="4e21b6b860da30d1826bc3bb029200d80cc11cad" translate="yes" xml:space="preserve">
          <source>A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, &amp;ldquo;a/**/b&amp;rdquo; matches &amp;ldquo;a/b&amp;rdquo;, &amp;ldquo;a/x/b&amp;rdquo;, &amp;ldquo;a/x/y/b&amp;rdquo; and so on.</source>
          <target state="translated">斜杠后跟两个连续的星号，然后斜杠匹配零个或多个目录。例如，&amp;ldquo; a / ** / b&amp;rdquo;匹配&amp;ldquo; a / b&amp;rdquo;，&amp;ldquo; a / x / b&amp;rdquo;，&amp;ldquo; a / x / y / b&amp;rdquo;等。</target>
        </trans-unit>
        <trans-unit id="7c9431663a53487c588fbbedb283ae62fa2894ff" translate="yes" xml:space="preserve">
          <source>A slightly deprecated way to store shorthands to be used to specify a URL to &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt;. A file can be stored as &lt;code&gt;branches/&amp;lt;name&amp;gt;&lt;/code&gt; and then &lt;code&gt;name&lt;/code&gt; can be given to these commands in place of &lt;code&gt;repository&lt;/code&gt; argument. See the REMOTES section in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; for details. This mechanism is legacy and not likely to be found in modern repositories. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/branches&quot; will be used instead.</source>
          <target state="translated">一种不推荐使用的存储速记方式，用于指定 &lt;code&gt;git fetch&lt;/code&gt; ， &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git push&lt;/code&gt; 的URL 。可以将文件存储为 &lt;code&gt;branches/&amp;lt;name&amp;gt;&lt;/code&gt; ，然后可以为这些命令指定 &lt;code&gt;name&lt;/code&gt; 来代替 &lt;code&gt;repository&lt;/code&gt; 参数。有关详细信息，请参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]中&lt;/a&gt;的REMOTES部分。这种机制是遗留的，不太可能在现代存储库中找到。如果设置了$ GIT_COMMON_DIR，将忽略该目录，而将使用&amp;ldquo; $ GIT_COMMON_DIR / branches&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="abbe30d91a78c1b581b029eea169d6574e2c5cb4" translate="yes" xml:space="preserve">
          <source>A sorted list of object IDs.</source>
          <target state="translated">对象ID的排序列表。</target>
        </trans-unit>
        <trans-unit id="3047be03f0d3ecaf4a4a3e674d103af6ab32bc53" translate="yes" xml:space="preserve">
          <source>A special notation &quot;&lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt;..&lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot; can be used as a short-hand for &quot;^'&amp;lt;commit1&amp;gt;' &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot;. For example, either of the following may be used interchangeably:</source>
          <target state="translated">特殊符号&amp;ldquo; &lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt; .. &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt; &amp;rdquo;可以用作&amp;ldquo; ^'&amp;lt;commit1&amp;gt;' &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt; &amp;rdquo;的简写。例如，以下任何一种都可以互换使用：</target>
        </trans-unit>
        <trans-unit id="7f04b75c4a71a67f88cb97a7461a54292078c16c" translate="yes" xml:space="preserve">
          <source>A special notation &quot;&lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt;..&lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot; can be used as a short-hand for &quot;^&lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot;. For example, either of the following may be used interchangeably:</source>
          <target state="translated">特殊符号&amp;ldquo; &lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt; .. &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt; &amp;rdquo;可以用作&amp;ldquo; ^ &lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt; &amp;rdquo;的简写。例如，以下任何一种都可以互换使用：</target>
        </trans-unit>
        <trans-unit id="2a3908ea4f3253577085936fe5b76bc16ca04e0c" translate="yes" xml:space="preserve">
          <source>A special work-flow to process regressions can give great results.</source>
          <target state="translated">流程回归的特殊工作流程可以带来很好的效果。</target>
        </trans-unit>
        <trans-unit id="43ce84536299a4f1684c7f29def2c093aadc39c2" translate="yes" xml:space="preserve">
          <source>A standalone individual developer does not exchange patches with other people, and works alone in a single repository, using the following commands.</source>
          <target state="translated">独立的个人开发者不与其他人交换补丁,单独在一个版本库中工作,使用以下命令。</target>
        </trans-unit>
        <trans-unit id="6d0b6db37ed70c0023a81918dabe38bb8d99cf58" translate="yes" xml:space="preserve">
          <source>A stash entry is represented as a commit whose tree records the state of the working directory, and its first parent is the commit at &lt;code&gt;HEAD&lt;/code&gt; when the entry was created. The tree of the second parent records the state of the index when the entry is made, and it is made a child of the &lt;code&gt;HEAD&lt;/code&gt; commit. The ancestry graph looks like this:</source>
          <target state="translated">存储项表示为提交，其树记录了工作目录的状态，其第一个父级是创建条目时在 &lt;code&gt;HEAD&lt;/code&gt; 的提交。第二个父级的树记录创建条目时的索引状态，并使其成为 &lt;code&gt;HEAD&lt;/code&gt; 提交的子级。血统图如下所示：</target>
        </trans-unit>
        <trans-unit id="36a517b64103a2430e203bb84a9e73d7f028600f" translate="yes" xml:space="preserve">
          <source>A string that interpolates &lt;code&gt;%(fieldname)&lt;/code&gt; from a branch ref being shown and the object it points at. The format is the same as that of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;.</source>
          <target state="translated">从显示的分支引用及其指向的对象插入 &lt;code&gt;%(fieldname)&lt;/code&gt; 的字符串。格式与&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9edde80e52399b826b491130bef9d05b3925669d" translate="yes" xml:space="preserve">
          <source>A string that interpolates &lt;code&gt;%(fieldname)&lt;/code&gt; from a ref being shown and the object it points at. If &lt;code&gt;fieldname&lt;/code&gt; is prefixed with an asterisk (&lt;code&gt;*&lt;/code&gt;) and the ref points at a tag object, use the value for the field in the object which the tag object refers to (instead of the field in the tag object). When unspecified, &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; defaults to &lt;code&gt;%(objectname) SPC %(objecttype) TAB %(refname)&lt;/code&gt;. It also interpolates &lt;code&gt;%%&lt;/code&gt; to &lt;code&gt;%&lt;/code&gt;, and &lt;code&gt;%xx&lt;/code&gt; where &lt;code&gt;xx&lt;/code&gt; are hex digits interpolates to character with hex code &lt;code&gt;xx&lt;/code&gt;; for example &lt;code&gt;%00&lt;/code&gt; interpolates to &lt;code&gt;\0&lt;/code&gt; (NUL), &lt;code&gt;%09&lt;/code&gt; to &lt;code&gt;\t&lt;/code&gt; (TAB) and &lt;code&gt;%0a&lt;/code&gt; to &lt;code&gt;\n&lt;/code&gt; (LF).</source>
          <target state="translated">从显示的引用及其指向的对象插入 &lt;code&gt;%(fieldname)&lt;/code&gt; 的字符串。如果 &lt;code&gt;fieldname&lt;/code&gt; 带有星号（ &lt;code&gt;*&lt;/code&gt; ）前缀，并且ref指向标记对象，则使用标记对象所引用的对象中字段的值（而不是标记对象中的字段）。未指定时， &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 默认为 &lt;code&gt;%(objectname) SPC %(objecttype) TAB %(refname)&lt;/code&gt; 。它还插值 &lt;code&gt;%%&lt;/code&gt; 至 &lt;code&gt;%&lt;/code&gt; ，和 &lt;code&gt;%xx&lt;/code&gt; 其中 &lt;code&gt;xx&lt;/code&gt; 是十六进制数字内插与十六进制代码字符 &lt;code&gt;xx&lt;/code&gt; ;例如 &lt;code&gt;%00&lt;/code&gt; 插值到 &lt;code&gt;\0&lt;/code&gt; （NUL）， &lt;code&gt;%09&lt;/code&gt; 至 &lt;code&gt;\t&lt;/code&gt; （TAB）和 &lt;code&gt;%0a&lt;/code&gt; 至 &lt;code&gt;\n&lt;/code&gt; （LF）。</target>
        </trans-unit>
        <trans-unit id="9cb129a282a3da00e35f465609f9329380941366" translate="yes" xml:space="preserve">
          <source>A string that interpolates &lt;code&gt;%(fieldname)&lt;/code&gt; from a tag ref being shown and the object it points at. The format is the same as that of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. When unspecified, defaults to &lt;code&gt;%(refname:strip=2)&lt;/code&gt;.</source>
          <target state="translated">从显示的标记ref及其指向的对象插入 &lt;code&gt;%(fieldname)&lt;/code&gt; 的字符串。格式与&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]相同&lt;/a&gt;。未指定时，默认为 &lt;code&gt;%(refname:strip=2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0560022c11ba0c716585e6d8f8913228ee3e6c3e" translate="yes" xml:space="preserve">
          <source>A submodule can be deinitialized by running &lt;code&gt;git submodule deinit&lt;/code&gt;. Besides emptying the working directory, this command only modifies the superproject&amp;rsquo;s &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file, so the superproject&amp;rsquo;s history is not affected. This can be undone using &lt;code&gt;git submodule init&lt;/code&gt;.</source>
          <target state="translated">可以通过运行 &lt;code&gt;git submodule deinit&lt;/code&gt; 来初始化子模块。除了清空工作目录之外，此命令仅修改超级项目的 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件，因此超级项目的历史记录不受影响。这可以使用 &lt;code&gt;git submodule init&lt;/code&gt; 撤消。</target>
        </trans-unit>
        <trans-unit id="7b89540955e10e5feb43789fbebb00e44fcb9843" translate="yes" xml:space="preserve">
          <source>A submodule is a repository embedded inside another repository. The submodule has its own history; the repository it is embedded in is called a superproject.</source>
          <target state="translated">子模块是嵌入在另一个版本库中的版本库,子模块有自己的历史,它所嵌入的版本库被称为超级项目。子模块有自己的历史,它所嵌入的版本库被称为超级项目。</target>
        </trans-unit>
        <trans-unit id="e88b5d8fa1cd6a4cae09ba91d60ef7a2df883ac3" translate="yes" xml:space="preserve">
          <source>A submodule is considered active,</source>
          <target state="translated">一个子模块被认为是活跃的。</target>
        </trans-unit>
        <trans-unit id="a4216bd581f8b9370ea9e414788282e84b57f684" translate="yes" xml:space="preserve">
          <source>A submodule is considered up to date when the HEAD is the same as recorded in the index, no tracked files are modified and no untracked files that aren&amp;rsquo;t ignored are present in the submodules work tree. Ignored files are deemed expendable and won&amp;rsquo;t stop a submodule&amp;rsquo;s work tree from being removed.</source>
          <target state="translated">当HEAD与索引中记录的相同时，子模块被认为是最新的，子模块工作树中不存在任何被跟踪的文件被修改且没有被忽略的未跟踪的文件。被忽略的文件被认为是消耗性的，不会阻止子模块的工作树被删除。</target>
        </trans-unit>
        <trans-unit id="df342118147abc0cd90ff22df7d540bbed94c62e" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;:&lt;/code&gt; followed by a path names the blob or tree at the given path in the tree-ish object named by the part before the colon. A path starting with &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;../&lt;/code&gt; is relative to the current working directory. The given path will be converted to be relative to the working tree&amp;rsquo;s root directory. This is most useful to address a blob or tree from a commit or tree that has the same tree structure as the working tree.</source>
          <target state="translated">后缀 &lt;code&gt;:&lt;/code&gt; 后跟一个路径，该路径在由冒号前的部分命名的树状对象中给定路径处的名称为blob或树。以 &lt;code&gt;./&lt;/code&gt; 或 &lt;code&gt;../&lt;/code&gt; 开头的路径是相对于当前工作目录的。给定的路径将被转换为相对于工作树的根目录。这对于处理具有与工作树相同的树结构的提交或树中的Blob或树非常有用。</target>
        </trans-unit>
        <trans-unit id="7e785e37b028efe6293e2efb14cf20d30e4be808" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an at sign is the same as listing all parents of &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; (meaning, include anything reachable from its parents, but not the commit itself).</source>
          <target state="translated">后缀 &lt;code&gt;^&lt;/code&gt; 后跟一个at符号与列出 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 的所有父代相同（意味着，包括其父代可以到达的所有内容，但不包括提交本身）。</target>
        </trans-unit>
        <trans-unit id="234f424b36b663492de634fe2e068b47127b2353" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an empty brace pair means the object could be a tag, and dereference the tag recursively until a non-tag object is found.</source>
          <target state="translated">后缀 &lt;code&gt;^&lt;/code&gt; 后跟一个空括号，表示该对象可能是标签，并递归地取消引用该标签，直到找到非标签对象为止。</target>
        </trans-unit>
        <trans-unit id="e176abe5e6fcc215a4e351cefa8ffc3e524bb3aa" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an exclamation mark is the same as giving commit &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; and then all its parents prefixed with &lt;code&gt;^&lt;/code&gt; to exclude them (and their ancestors).</source>
          <target state="translated">后缀 &lt;code&gt;^&lt;/code&gt; 接着感叹号相同给予提交 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 然后将其所有父母前缀 &lt;code&gt;^&lt;/code&gt; 将它们排除在外（和它们的祖先）。</target>
        </trans-unit>
        <trans-unit id="079cde747b39722224d412153b37c2370e8debbb" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an object type name enclosed in brace pair means dereference the object at &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; recursively until an object of type &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is found or the object cannot be dereferenced anymore (in which case, barf). For example, if &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; is a commit-ish, &lt;code&gt;&amp;lt;rev&amp;gt;^{commit}&lt;/code&gt; describes the corresponding commit object. Similarly, if &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; is a tree-ish, &lt;code&gt;&amp;lt;rev&amp;gt;^{tree}&lt;/code&gt; describes the corresponding tree object. &lt;code&gt;&amp;lt;rev&amp;gt;^0&lt;/code&gt; is a short-hand for &lt;code&gt;&amp;lt;rev&amp;gt;^{commit}&lt;/code&gt;.</source>
          <target state="translated">后缀 &lt;code&gt;^&lt;/code&gt; 后跟括号对中的对象类型名称表示递归地在 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 处取消引用该对象，直到找到 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 类型的对象或该对象不再被取消引用（在这种情况下为barf）。例如，如果 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 是一个commit-ish，则 &lt;code&gt;&amp;lt;rev&amp;gt;^{commit}&lt;/code&gt; 描述相应的提交对象。同样，如果 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 是树状的，则 &lt;code&gt;&amp;lt;rev&amp;gt;^{tree}&lt;/code&gt; 描述相应的树对象。 &lt;code&gt;&amp;lt;rev&amp;gt;^0&lt;/code&gt; 是 &lt;code&gt;&amp;lt;rev&amp;gt;^{commit}&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="fffb9575171f3ccde74304b43fe061daf6edfa9e" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; to a revision parameter means the first parent of that commit object. &lt;code&gt;^&amp;lt;n&amp;gt;&lt;/code&gt; means the &amp;lt;n&amp;gt;th parent (i.e. &lt;code&gt;&amp;lt;rev&amp;gt;^&lt;/code&gt; is equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^1&lt;/code&gt;). As a special rule, &lt;code&gt;&amp;lt;rev&amp;gt;^0&lt;/code&gt; means the commit itself and is used when &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; is the object name of a tag object that refers to a commit object.</source>
          <target state="translated">修订参数的后缀 &lt;code&gt;^&lt;/code&gt; 表示该提交对象的第一个父对象。 &lt;code&gt;^&amp;lt;n&amp;gt;&lt;/code&gt; 表示第n个父对象（即 &lt;code&gt;&amp;lt;rev&amp;gt;^&lt;/code&gt; 等效于 &lt;code&gt;&amp;lt;rev&amp;gt;^1&lt;/code&gt; ）。作为特殊规则， &lt;code&gt;&amp;lt;rev&amp;gt;^0&lt;/code&gt; 表示提交本身，并且当 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 是引用提交对象的标记对象的对象名称时使用。</target>
        </trans-unit>
        <trans-unit id="4abb972743010d92ad3a5190f17461682915e18a" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; to a revision parameter, followed by a brace pair that contains a text led by a slash, is the same as the &lt;code&gt;:/fix nasty bug&lt;/code&gt; syntax below except that it returns the youngest matching commit which is reachable from the &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; before &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">修订参数的后缀 &lt;code&gt;^&lt;/code&gt; ，然后是包含斜杠开头的文本的大括号对，与下面的 &lt;code&gt;:/fix nasty bug&lt;/code&gt; 语法相同，除了它返回可从 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 访问的最年轻的匹配提交。在 &lt;code&gt;^&lt;/code&gt; 之前。</target>
        </trans-unit>
        <trans-unit id="9efdcb3b13d0c9c0789d26cd7ee831f4aca0612a" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;~&lt;/code&gt; to a revision parameter means the first parent of that commit object. A suffix &lt;code&gt;~&amp;lt;n&amp;gt;&lt;/code&gt; to a revision parameter means the commit object that is the &amp;lt;n&amp;gt;th generation ancestor of the named commit object, following only the first parents. I.e. &lt;code&gt;&amp;lt;rev&amp;gt;~3&lt;/code&gt; is equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^^^&lt;/code&gt; which is equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^1^1^1&lt;/code&gt;. See below for an illustration of the usage of this form.</source>
          <target state="translated">版本参数的后缀 &lt;code&gt;~&lt;/code&gt; 表示该提交对象的第一个父对象。修订版参数的后缀 &lt;code&gt;~&amp;lt;n&amp;gt;&lt;/code&gt; 表示提交对象，它是指定提交对象的第n代祖先，仅在第一个父对象之后。即 &lt;code&gt;&amp;lt;rev&amp;gt;~3&lt;/code&gt; &lt;code&gt;&amp;lt;rev&amp;gt;^^^&lt;/code&gt; 等效于&amp;lt;rev&amp;gt; ^^^，等效于 &lt;code&gt;&amp;lt;rev&amp;gt;^1^1^1&lt;/code&gt; 。有关此表格用法的说明，请参见下文。</target>
        </trans-unit>
        <trans-unit id="08cd172649a72cf4ad5161e6315024c0dfabce75" translate="yes" xml:space="preserve">
          <source>A symbolic ref is a regular file that stores a string that begins with &lt;code&gt;ref: refs/&lt;/code&gt;. For example, your &lt;code&gt;.git/HEAD&lt;/code&gt; is a regular file whose contents is &lt;code&gt;ref: refs/heads/master&lt;/code&gt;.</source>
          <target state="translated">符号ref是一个常规文件，其中存储了以 &lt;code&gt;ref: refs/&lt;/code&gt; 开头的字符串。例如，您的 &lt;code&gt;.git/HEAD&lt;/code&gt; 是常规文件，其内容为 &lt;code&gt;ref: refs/heads/master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f6a4a117c3c9029c31388fc9b0d710a83f42f4d" translate="yes" xml:space="preserve">
          <source>A symbolic ref name. E.g. &lt;code&gt;master&lt;/code&gt; typically means the commit object referenced by &lt;code&gt;refs/heads/master&lt;/code&gt;. If you happen to have both &lt;code&gt;heads/master&lt;/code&gt; and &lt;code&gt;tags/master&lt;/code&gt;, you can explicitly say &lt;code&gt;heads/master&lt;/code&gt; to tell Git which one you mean. When ambiguous, a &lt;code&gt;&amp;lt;refname&amp;gt;&lt;/code&gt; is disambiguated by taking the first match in the following rules:</source>
          <target state="translated">符号引用名称。例如 &lt;code&gt;master&lt;/code&gt; 通常是指 &lt;code&gt;refs/heads/master&lt;/code&gt; 引用的提交对象。如果您碰巧同时拥有 &lt;code&gt;heads/master&lt;/code&gt; 和 &lt;code&gt;tags/master&lt;/code&gt; ，则可以明确地说出 &lt;code&gt;heads/master&lt;/code&gt; 来告诉Git您是什么意思。当模棱两可时，通过遵循以下规则中的第一个匹配项来消除 &lt;code&gt;&amp;lt;refname&amp;gt;&lt;/code&gt; 的歧义：</target>
        </trans-unit>
        <trans-unit id="2a9339c8e09a3c8f9775daba35ba89a601eb61af" translate="yes" xml:space="preserve">
          <source>A symref (see glossary) to the &lt;code&gt;refs/heads/&lt;/code&gt; namespace describing the currently active branch. It does not mean much if the repository is not associated with any working tree (i.e. a &lt;code&gt;bare&lt;/code&gt; repository), but a valid Git repository &lt;strong&gt;must&lt;/strong&gt; have the HEAD file; some porcelains may use it to guess the designated &quot;default&quot; branch of the repository (usually &lt;code&gt;master&lt;/code&gt;). It is legal if the named branch &lt;code&gt;name&lt;/code&gt; does not (yet) exist. In some legacy setups, it is a symbolic link instead of a symref that points at the current branch.</source>
          <target state="translated">到 &lt;code&gt;refs/heads/&lt;/code&gt; 名称空间的symref（请参阅词汇表），描述了当前活动的分支。如果存储库没有与任何工作树（即 &lt;code&gt;bare&lt;/code&gt; 存储库）相关联，这并不意味着什么，但是有效的Git存储库&lt;strong&gt;必须&lt;/strong&gt;具有HEAD文件；有些瓷器可能会用它来猜测存储库的指定&amp;ldquo;默认&amp;rdquo;分支（通常是 &lt;code&gt;master&lt;/code&gt; ）。如果命名分支 &lt;code&gt;name&lt;/code&gt; 尚不存在，则是合法的。在某些旧式设置中，它是一个符号链接，而不是指向当前分支的symref。</target>
        </trans-unit>
        <trans-unit id="29c5b752bfbf12baa27c0d09bf45852511199efe" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_head&quot;&gt;头&lt;/a&gt;的同义词。</target>
        </trans-unit>
        <trans-unit id="6a76d6428fd9851f11221d0de44fe9ce84899c23" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;code&gt;--right-only --cherry-mark --no-merges&lt;/code&gt;; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with &lt;code&gt;git log --cherry upstream...mybranch&lt;/code&gt;, similar to &lt;code&gt;git cherry upstream mybranch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--right-only --cherry-mark --no-merges&lt;/code&gt; 的同义词；有用的是将输出限制在我们这边的提交上，并使用 &lt;code&gt;git log --cherry upstream...mybranch&lt;/code&gt; 标记已应用于派生历史的另一端的提交，类似于 &lt;code&gt;git cherry upstream mybranch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="868704b8b35cf6bb729f23c31a6430d7399400cb" translate="yes" xml:space="preserve">
          <source>A table of 4-byte CRC32 values of the packed object data. This is new in v2 so compressed data can be copied directly from pack to pack during repacking without undetected data corruption.</source>
          <target state="translated">包装对象数据的4字节CRC32值表。这是在v2中新增的,因此压缩数据可以在重新打包时直接从一个包复制到另一个包,而不会被发现数据损坏。</target>
        </trans-unit>
        <trans-unit id="b9c572354f0344d27ffddcbe955d1d768c1138c7" translate="yes" xml:space="preserve">
          <source>A table of 4-byte offset values (in network byte order). These are usually 31-bit pack file offsets, but large offsets are encoded as an index into the next table with the msbit set.</source>
          <target state="translated">一个4字节偏移值的表格(按网络字节顺序)。这些通常是31位的包文件偏移值,但大的偏移值被编码为下一个表的索引,并设置了msbit。</target>
        </trans-unit>
        <trans-unit id="115de84d2ad1c82aefd29447ce36382b5a4e7147" translate="yes" xml:space="preserve">
          <source>A table of 8-byte offset entries (empty for pack files less than 2 GiB). Pack files are organized with heavily used objects toward the front, so most object references should not need to refer to this table.</source>
          <target state="translated">一个8字节偏移量的表格(对于小于2GB的包文件来说是空的)。包文件是以大量使用的对象在前面组织的,所以大多数对象引用不需要参考这个表。</target>
        </trans-unit>
        <trans-unit id="9b489f426a28ee960ee163d6ec7cd47d15e9a4e2" translate="yes" xml:space="preserve">
          <source>A table of sorted 20-byte SHA-1 object names. These are packed together without offset values to reduce the cache footprint of the binary search for a specific object name.</source>
          <target state="translated">一个20字节SHA-1对象名的排序表。这些名称被打包在一起,没有偏移值,以减少二进制搜索特定对象名称的缓存空间。</target>
        </trans-unit>
        <trans-unit id="edf2ea82a914be349ea057cd8f9ba4108e7b2f82" translate="yes" xml:space="preserve">
          <source>A table of sorted object names. These are packed together without offset values to reduce the cache footprint of the binary search for a specific object name.</source>
          <target state="translated">一个排序的对象名称表。这些表被打包在一起,没有偏移值,以减少二进制搜索特定对象名称的缓存足迹。</target>
        </trans-unit>
        <trans-unit id="04b73c881d8049c32b44bc4f672cd5152d4e0c48" translate="yes" xml:space="preserve">
          <source>A tag is created with &lt;a href=&quot;git-mktag&quot;&gt;git-mktag[1]&lt;/a&gt;, and the signature can be verified by &lt;a href=&quot;git-verify-tag&quot;&gt;git-verify-tag[1]&lt;/a&gt;, though it is normally simpler to use &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; for both.</source>
          <target state="translated">使用&lt;a href=&quot;git-mktag&quot;&gt;git-mktag [1]&lt;/a&gt;创建一个标签，并且可以通过&lt;a href=&quot;git-verify-tag&quot;&gt;git-verify-tag [1]验证&lt;/a&gt;签名，尽管通常使用&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;都更简单。</target>
        </trans-unit>
        <trans-unit id="27736fe1ba37175d3cc5e2ce129ab17b8daa1329" translate="yes" xml:space="preserve">
          <source>A tag object contains an object, object type, tag name, the name of the person (&quot;tagger&quot;) who created the tag, and a message, which may contain a signature, as can be seen using &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt;:</source>
          <target state="translated">标签对象包含一个对象，对象类型，标签名称，创建标签的人员的名称（&amp;ldquo; tagger&amp;rdquo;）以及一条消息，其中可能包含签名，如使用&lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1 ]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="460cd2951f141993dd60da4f89bc9632bc5240a6" translate="yes" xml:space="preserve">
          <source>A tag signature file, to be fed to this command&amp;rsquo;s standard input, has a very simple fixed format: four lines of</source>
          <target state="translated">标记签名文件将被馈送到该命令的标准输入，其格式非常简单：四行</target>
        </trans-unit>
        <trans-unit id="c9577e2a94118633866403eba48d1b01fa7f34b6" translate="yes" xml:space="preserve">
          <source>A text file containing the absolute path back to the .git file that points to here. This is used to check if the linked repository has been manually removed and there is no need to keep this directory any more. The mtime of this file should be updated every time the linked repository is accessed.</source>
          <target state="translated">一个文本文件,包含指向这里的.git文件的绝对路径。这个文件用来检查链接的仓库是否已经被手动删除,是否不需要再保留这个目录。这个文件的mtime应该在每次访问链接仓库时更新。</target>
        </trans-unit>
        <trans-unit id="e6620ed6a8dd7fc370324b4a637371aff9ccd2b8" translate="yes" xml:space="preserve">
          <source>A textconv, by comparison, is much more limiting. You provide a transformation of the data into a line-oriented text format, and Git uses its regular diff tools to generate the output. There are several advantages to choosing this method:</source>
          <target state="translated">相比之下,textconv的局限性更大。你提供了一个将数据转换为面向行的文本格式,然后 Git 使用常规的 diff 工具来生成输出。选择这种方法有几个好处。</target>
        </trans-unit>
        <trans-unit id="20ee50ebcc035e786bc0063549e7c3be96310965" translate="yes" xml:space="preserve">
          <source>A tilde &lt;code&gt;~&lt;/code&gt; and caret &lt;code&gt;^&lt;/code&gt; are used to introduce the postfix &lt;code&gt;nth parent&lt;/code&gt; and &lt;code&gt;peel onion&lt;/code&gt; operation.</source>
          <target state="translated">代字号 &lt;code&gt;~&lt;/code&gt; 和脱字号 &lt;code&gt;^&lt;/code&gt; 用于引入后缀 &lt;code&gt;nth parent&lt;/code&gt; 和 &lt;code&gt;peel onion&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="8b05115bcd451b82846a70dc0f8122c29671169c" translate="yes" xml:space="preserve">
          <source>A trailing &quot;&lt;code&gt;/**&lt;/code&gt;&quot; matches everything inside. For example, &quot;&lt;code&gt;abc/**&lt;/code&gt;&quot; matches all files inside directory &quot;&lt;code&gt;abc&lt;/code&gt;&quot;, relative to the location of the &lt;code&gt;.gitignore&lt;/code&gt; file, with infinite depth.</source>
          <target state="translated">尾部的&amp;ldquo; &lt;code&gt;/**&lt;/code&gt; &amp;rdquo;匹配其中的所有内容。例如，相对于 &lt;code&gt;.gitignore&lt;/code&gt; 文件的位置，&amp;ldquo; &lt;code&gt;abc/**&lt;/code&gt; &amp;rdquo;匹配目录&amp;ldquo; &lt;code&gt;abc&lt;/code&gt; &amp;rdquo; 内的所有文件的深度是无限的。</target>
        </trans-unit>
        <trans-unit id="c57747a45d9976be1263b4b7a69a5ab667656384" translate="yes" xml:space="preserve">
          <source>A trailing &quot;&lt;code&gt;/**&lt;/code&gt;&quot; matches everything inside. For example, &quot;&lt;code&gt;abc/**&lt;/code&gt;&quot; matches all files inside directory &quot;abc&quot;, relative to the location of the &lt;code&gt;.gitignore&lt;/code&gt; file, with infinite depth.</source>
          <target state="translated">尾部的&amp;ldquo; &lt;code&gt;/**&lt;/code&gt; &amp;rdquo;匹配其中的所有内容。例如，相对于 &lt;code&gt;.gitignore&lt;/code&gt; 文件的位置，&amp;ldquo; &lt;code&gt;abc/**&lt;/code&gt; &amp;rdquo;匹配目录&amp;ldquo; abc&amp;rdquo;内的所有文件，并且深度无限。</target>
        </trans-unit>
        <trans-unit id="ed5db9c2038caa3b11960feb667ae09ddbf5220c" translate="yes" xml:space="preserve">
          <source>A trailing &amp;ldquo;/&lt;strong&gt;&amp;rdquo; matches everything inside. For example, &amp;ldquo;abc/&lt;/strong&gt;&amp;rdquo; matches all files inside directory &quot;abc&quot;, relative to the location of the &lt;code&gt;.gitignore&lt;/code&gt; file, with infinite depth.</source>
          <target state="translated">尾部的&amp;ldquo; / &lt;strong&gt;&amp;rdquo;匹配内部的所有内容。例如，&lt;/strong&gt;相对于 &lt;code&gt;.gitignore&lt;/code&gt; 文件的位置&lt;strong&gt;，&amp;ldquo; abc /&lt;/strong&gt; &amp;rdquo;匹配目录&amp;ldquo; abc&amp;rdquo;内的所有文件的深度是无限的。</target>
        </trans-unit>
        <trans-unit id="1ffbc3235b6f3805e76da872c4d7da43eac01de9" translate="yes" xml:space="preserve">
          <source>A tree can be created with &lt;a href=&quot;git-write-tree&quot;&gt;git-write-tree[1]&lt;/a&gt; and its data can be accessed by &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt;. Two trees can be compared with &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;git-write-tree&quot;&gt;git-write-tree [1]&lt;/a&gt;创建树，并且可以通过&lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt;访问其数据。可以将两棵树与&lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree [1]进行比较&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71ac2a6922ce84e247da3afac7c8eab10ddc8e0d" translate="yes" xml:space="preserve">
          <source>A tree can refer to one or more &quot;blob&quot; objects, each corresponding to a file. In addition, a tree can also refer to other tree objects, thus creating a directory hierarchy. You can examine the contents of any tree using ls-tree (remember that a long enough initial portion of the SHA-1 will also work):</source>
          <target state="translated">一棵树可以指一个或多个 &quot;blob &quot;对象,每个对象对应一个文件。此外,一棵树还可以引用其他树对象,从而创建一个目录层次结构。你可以使用ls-tree检查任何一棵树的内容(记住,SHA-1的初始部分足够长也可以)。</target>
        </trans-unit>
        <trans-unit id="e1209e9c61fb0516db9ff029636bbf64b5f2cc24" translate="yes" xml:space="preserve">
          <source>A tutorial introduction to Git</source>
          <target state="translated">Git的教程介绍</target>
        </trans-unit>
        <trans-unit id="d1c7062a7de157bc933159ad8235a59f59c324f8" translate="yes" xml:space="preserve">
          <source>A tutorial introduction to Git: part two</source>
          <target state="translated">Git入门教程:第二部分</target>
        </trans-unit>
        <trans-unit id="20d6593ce00c8f4a86630f0208b8c6cb9ed9de85" translate="yes" xml:space="preserve">
          <source>A typical frontend for fast-import tends to weigh in at approximately 200 lines of Perl/Python/Ruby code. Most developers have been able to create working importers in just a couple of hours, even though it is their first exposure to fast-import, and sometimes even to Git. This is an ideal situation, given that most conversion tools are throw-away (use once, and never look back).</source>
          <target state="translated">一个典型的fast-import前端往往重约200行Perl/python/Ruby代码。大多数开发者都能在几个小时内创建出可用的导入器,尽管他们是第一次接触快速导入,有时甚至是第一次接触 Git。这是一个理想的情况,因为大多数转换工具都是一次性的(使用一次,就不会再回头)。</target>
        </trans-unit>
        <trans-unit id="e8135e3fa6705c7716d147bd5d8e6059fc5669c5" translate="yes" xml:space="preserve">
          <source>A typical integrator&amp;rsquo;s Git day.</source>
          <target state="translated">典型的集成商的Git日。</target>
        </trans-unit>
        <trans-unit id="cf9ceecdb03729fb43526343794e6a94c95fe225" translate="yes" xml:space="preserve">
          <source>A typical output of &lt;code&gt;git range-diff&lt;/code&gt; would look like this:</source>
          <target state="translated">&lt;code&gt;git range-diff&lt;/code&gt; 的典型输出如下所示：</target>
        </trans-unit>
        <trans-unit id="e41e892a94b26f51f6da2faaf7e783142c2d2445" translate="yes" xml:space="preserve">
          <source>A typical use of notes is to supplement a commit message without changing the commit itself. Notes can be shown by &lt;code&gt;git log&lt;/code&gt; along with the original commit message. To distinguish these notes from the message stored in the commit object, the notes are indented like the message, after an unindented line saying &quot;Notes (&amp;lt;refname&amp;gt;):&quot; (or &quot;Notes:&quot; for &lt;code&gt;refs/notes/commits&lt;/code&gt;).</source>
          <target state="translated">notes的典型用法是在不更改提交本身的情况下补充提交消息。注释可以由 &lt;code&gt;git log&lt;/code&gt; 以及原始提交消息显示。为了将这些注释与存储在提交对象中的消息区分开，注释像消息一样缩进，在未缩进的行之后写着&amp;ldquo; Notes（&amp;lt;refname&amp;gt;）：&amp;rdquo;（对于 &lt;code&gt;refs/notes/commits&lt;/code&gt; ,则为&amp;ldquo; Notes：&amp;rdquo; ）。</target>
        </trans-unit>
        <trans-unit id="eaee94e7a5daaa0b37c741d247267e9c8d3bd828" translate="yes" xml:space="preserve">
          <source>A useful minimum set of commands for Everyday Git</source>
          <target state="translated">对日常Git有用的最低限度命令集</target>
        </trans-unit>
        <trans-unit id="f6b5db3f89763f637b749fc5b0ec07665392a318" translate="yes" xml:space="preserve">
          <source>A v2 server would reply:</source>
          <target state="translated">v2服务器会回复。</target>
        </trans-unit>
        <trans-unit id="814fa5229889141123953471b46691119165aa04" translate="yes" xml:space="preserve">
          <source>A value j referring to the jth packfile.</source>
          <target state="translated">指向第j个包装文件的数值j。</target>
        </trans-unit>
        <trans-unit id="0db561a50c25f0c87e4728686c752358969a2d04" translate="yes" xml:space="preserve">
          <source>A value of 0 will give some reasonable default. If unset, it defaults to 1.</source>
          <target state="translated">值为0会给出一些合理的默认值。如果未设置,则默认为1。</target>
        </trans-unit>
        <trans-unit id="aa0ad35cb8bc2af5f4d79278f7255026ebe99d79" translate="yes" xml:space="preserve">
          <source>A variable that takes a pathname value can be given a string that begins with &quot;&lt;code&gt;~/&lt;/code&gt;&quot; or &quot;&lt;code&gt;~user/&lt;/code&gt;&quot;, and the usual tilde expansion happens to such a string: &lt;code&gt;~/&lt;/code&gt; is expanded to the value of &lt;code&gt;$HOME&lt;/code&gt;, and &lt;code&gt;~user/&lt;/code&gt; to the specified user&amp;rsquo;s home directory.</source>
          <target state="translated">可以给一个带有路径名值的变量一个以&amp;ldquo; &lt;code&gt;~/&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;~user/&lt;/code&gt; &amp;rdquo; 开头的字符串，通常的波浪号扩展会发生在这样的字符串上： &lt;code&gt;~/&lt;/code&gt; 扩展为 &lt;code&gt;$HOME&lt;/code&gt; 的值，而 &lt;code&gt;~user/&lt;/code&gt; 到指定用户的主目录。</target>
        </trans-unit>
        <trans-unit id="e794a6fd78ae6c428e6284131fe5a2e63e70771b" translate="yes" xml:space="preserve">
          <source>A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">对于不存在的refs会发出警告,但不匹配任何refs的glob会被默默忽略。</target>
        </trans-unit>
        <trans-unit id="fd32407bcc9b7692e9e0052b8179af70723a8a0f" translate="yes" xml:space="preserve">
          <source>A whole-repository format version bump should only be part of a change that cannot be independently versioned. For instance, if one were to change the reachability rules for objects, or the rules for locking refs, that would require a bump of the repository format version.</source>
          <target state="translated">整个版本库格式的版本调整应该是不能独立进行版本调整的变更的一部分。例如,如果要改变对象的可达性规则,或者锁定参考文献的规则,就需要对版本库格式的版本进行调整。</target>
        </trans-unit>
        <trans-unit id="5bfda56601f95323dd8aca6fc5f3876aceac9edc" translate="yes" xml:space="preserve">
          <source>A zero exit from the update hook allows the ref to be updated. Exiting with a non-zero status prevents &lt;code&gt;git receive-pack&lt;/code&gt; from updating that ref.</source>
          <target state="translated">更新挂钩的零出口允许对引用进行更新。以非零状态退出会阻止 &lt;code&gt;git receive-pack&lt;/code&gt; 更新该引用。</target>
        </trans-unit>
        <trans-unit id="daa85a6ac2fd33dacf832ee98a538368318a091a" translate="yes" xml:space="preserve">
          <source>A: addition of a file</source>
          <target state="translated">答:增加一个文件</target>
        </trans-unit>
        <trans-unit id="8e39d81ad3ae332d60cc3e83e97303a91d0b4f70" translate="yes" xml:space="preserve">
          <source>ALERT ALERT ALERT! The Git &quot;merge object order&quot; is different from the RCS &lt;code&gt;merge&lt;/code&gt; program merge object order. In the above ordering, the original is first. But the argument order to the 3-way merge program &lt;code&gt;merge&lt;/code&gt; is to have the original in the middle. Don&amp;rsquo;t ask me why.</source>
          <target state="translated">警报警报！Git的&amp;ldquo;合并对象顺序&amp;rdquo;与RCS &lt;code&gt;merge&lt;/code&gt; 程序合并对象顺序不同。在上述顺序中，原件是第一位。但是三向合并程序 &lt;code&gt;merge&lt;/code&gt; 的参数顺序是将原始文件放在中间。不要问我为什么。</target>
        </trans-unit>
        <trans-unit id="4508200e35a10a4b1f04bf5f137007ce3e238313" translate="yes" xml:space="preserve">
          <source>Abbreviate the object name. When using &lt;code&gt;--hash&lt;/code&gt;, you do not have to say &lt;code&gt;--hash --abbrev&lt;/code&gt;; &lt;code&gt;--hash=n&lt;/code&gt; would do.</source>
          <target state="translated">缩写对象名称。使用 &lt;code&gt;--hash&lt;/code&gt; 时，不必说 &lt;code&gt;--hash --abbrev&lt;/code&gt; ; &lt;code&gt;--hash=n&lt;/code&gt; 可以。</target>
        </trans-unit>
        <trans-unit id="73bf43580d9c77cf2c146fe7b7b0ac96cfdd25cc" translate="yes" xml:space="preserve">
          <source>Abbreviating long options</source>
          <target state="translated">缩略长期权</target>
        </trans-unit>
        <trans-unit id="df0f0090a24082d1353e139667cbd879cef89ee9" translate="yes" xml:space="preserve">
          <source>Abort the current conflict resolution process, and try to reconstruct the pre-merge state.</source>
          <target state="translated">中止当前的冲突解决过程,并尝试重建合并前的状态。</target>
        </trans-unit>
        <trans-unit id="2c9bdb3481f87d016776b3e9fe055e0e08b17764" translate="yes" xml:space="preserve">
          <source>Abort the current conflict resolution process, and try to reconstruct the pre-merge state. If an autostash entry is present, apply it to the worktree.</source>
          <target state="translated">中止当前的冲突解决过程,并尝试重建合并前的状态。如果存在自动缓存条目,将其应用于工作树。</target>
        </trans-unit>
        <trans-unit id="97a8cc5ece3d7d535580e6c4ba9d955b1cbee507" translate="yes" xml:space="preserve">
          <source>Abort the patching operation but keep HEAD and the index untouched.</source>
          <target state="translated">中止修补操作,但保留HEAD和索引不动。</target>
        </trans-unit>
        <trans-unit id="d8af665ebaab7b8a3f7a19d579a76f94def56137" translate="yes" xml:space="preserve">
          <source>Abort the rebase operation and reset HEAD to the original branch. If &amp;lt;branch&amp;gt; was provided when the rebase operation was started, then HEAD will be reset to &amp;lt;branch&amp;gt;. Otherwise HEAD will be reset to where it was when the rebase operation was started.</source>
          <target state="translated">终止变基操作并将HEAD重置为原始分支。如果在启动基准操作时提供了&amp;lt;branch&amp;gt;，则HEAD将重置为&amp;lt;branch&amp;gt;。否则，HEAD将被重置为开始变基操作时的位置。</target>
        </trans-unit>
        <trans-unit id="e1a60cae95d240ebe223133619984451eb8da56d" translate="yes" xml:space="preserve">
          <source>Abort the rebase operation but HEAD is not reset back to the original branch. The index and working tree are also left unchanged as a result.</source>
          <target state="translated">终止重垒操作,但HEAD并没有被重置回原来的分支。索引和工作树也因此保持不变。</target>
        </trans-unit>
        <trans-unit id="dadb38a3988ca24e3d15cd3fb6752f37603a89f5" translate="yes" xml:space="preserve">
          <source>Abort the rebase operation but HEAD is not reset back to the original branch. The index and working tree are also left unchanged as a result. If a temporary stash entry was created using --autostash, it will be saved to the stash list.</source>
          <target state="translated">终止重垒操作,但HEAD并没有被重置回原来的分支。索引和工作树也不会因此而改变。如果使用--autostash创建了一个临时储藏条目,它将被保存到储藏列表中。</target>
        </trans-unit>
        <trans-unit id="b3d9e340762213f6aa557fb380c457beb7949eda" translate="yes" xml:space="preserve">
          <source>Abort the transaction, releasing all locks if the transaction is in prepared state.</source>
          <target state="translated">终止事务,如果事务处于准备状态,则释放所有锁。</target>
        </trans-unit>
        <trans-unit id="348ed40ffd74f6eb0fbdde58a662f091cfe18d08" translate="yes" xml:space="preserve">
          <source>Abort/reset an in-progress &lt;code&gt;git notes merge&lt;/code&gt;, i.e. a notes merge with conflicts. This simply removes all files related to the notes merge.</source>
          <target state="translated">中止/重置进行中的 &lt;code&gt;git notes merge&lt;/code&gt; ，即具有冲突的注释合并。这只是删除与笔记合并有关的所有文件。</target>
        </trans-unit>
        <trans-unit id="26d78acc57b2d47f1ebfb75a2f9bb6687faa0fcc" translate="yes" xml:space="preserve">
          <source>About ten years ago did i do my first &lt;code&gt;bisection&lt;/code&gt; of a Linux patch queue. That was prior the Git (and even prior the BitKeeper) days. I literally days spent sorting out patches, creating what in essence were standalone commits that i guessed to be related to that bug.</source>
          <target state="translated">大约十年前，我做我的第一个 &lt;code&gt;bisection&lt;/code&gt; 一个Linux补丁队列。那是在Git之前（甚至在BitKeeper之前）。实际上，我花了几天的时间整理补丁，创建实质上是我认为与该bug相关的独立提交的东西。</target>
        </trans-unit>
        <trans-unit id="7a17b1a2762f733cbf8fe0ce3ae058c1fb64af21" translate="yes" xml:space="preserve">
          <source>Absolute filesystem path which will be prepended to project path; the path to repository is &lt;code&gt;$projectroot/$project&lt;/code&gt;. Set to &lt;code&gt;$GITWEB_PROJECTROOT&lt;/code&gt; during installation. This variable has to be set correctly for gitweb to find repositories.</source>
          <target state="translated">绝对文件系统路径，将在项目路径之前添加；仓库的路径是 &lt;code&gt;$projectroot/$project&lt;/code&gt; 。在安装过程中设置为 &lt;code&gt;$GITWEB_PROJECTROOT&lt;/code&gt; 。必须正确设置此变量，以便gitweb查找存储库。</target>
        </trans-unit>
        <trans-unit id="d79da395b5d7a09c6439a5f2660d8c568186ab7e" translate="yes" xml:space="preserve">
          <source>Abstract</source>
          <target state="translated">Abstract</target>
        </trans-unit>
        <trans-unit id="17286b3ab79f469f1686313022a96ba044391703" translate="yes" xml:space="preserve">
          <source>Accelerated static Apache 2.x</source>
          <target state="translated">加速静态 Apache 2.x</target>
        </trans-unit>
        <trans-unit id="52790b3bcb573f6e8573cdbe7b68a8e690d099eb" translate="yes" xml:space="preserve">
          <source>Access control: By restricting user access to submodules, this can be used to implement read/write policies for different users.</source>
          <target state="translated">访问控制。通过限制用户对子模块的访问,可用于对不同用户实施读/写政策。</target>
        </trans-unit>
        <trans-unit id="5d9540ff93a75d47409d6a0aa37491da117ecdf8" translate="yes" xml:space="preserve">
          <source>Acknowledgments</source>
          <target state="translated">Acknowledgments</target>
        </trans-unit>
        <trans-unit id="478ae85b8fa23d44da84a56a398158571f09f29c" translate="yes" xml:space="preserve">
          <source>Act as though the corresponding command-line option with a leading &lt;code&gt;--&lt;/code&gt; was passed on the command line (see OPTIONS, above).</source>
          <target state="translated">就像在命令行上传递了带有引号 &lt;code&gt;--&lt;/code&gt; 的相应命令行选项一样（请参见上面的选项）。</target>
        </trans-unit>
        <trans-unit id="6478562162279a99d43ca11e0923b34140a68ad3" translate="yes" xml:space="preserve">
          <source>Actions, and urls</source>
          <target state="translated">行动和尿素</target>
        </trans-unit>
        <trans-unit id="3894e58bd38733ccd4747f0674e47d077bbb6100" translate="yes" xml:space="preserve">
          <source>Actions:</source>
          <target state="translated">Actions:</target>
        </trans-unit>
        <trans-unit id="8c5178bf114268e42ef635c5fbc78f8654415410" translate="yes" xml:space="preserve">
          <source>Activate recording of resolved conflicts, so that identical conflict hunks can be resolved automatically, should they be encountered again. By default, &lt;a href=&quot;git-rerere&quot;&gt;git-rerere[1]&lt;/a&gt; is enabled if there is an &lt;code&gt;rr-cache&lt;/code&gt; directory under the &lt;code&gt;$GIT_DIR&lt;/code&gt;, e.g. if &quot;rerere&quot; was previously used in the repository.</source>
          <target state="translated">激活记录已解决的冲突，以便在再次遇到相同的冲突块时可以自动解决它们。默认情况下，如果 &lt;code&gt;$GIT_DIR&lt;/code&gt; 下有一个 &lt;code&gt;rr-cache&lt;/code&gt; 目录，则启用&lt;a href=&quot;git-rerere&quot;&gt;git-rerere [1]&lt;/a&gt;，例如，如果以前在存储库中使用了&amp;ldquo; rerere&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f02f312753d69f3d534d52a8b88d589eac9ef0bb" translate="yes" xml:space="preserve">
          <source>Active branches have the same overhead as inactive branches, but also contain copies of every tree that has been recently modified on that branch. If subtree &lt;code&gt;include&lt;/code&gt; has not been modified since the branch became active, its contents will not be loaded into memory, but if subtree &lt;code&gt;src&lt;/code&gt; has been modified by a commit since the branch became active, then its contents will be loaded in memory.</source>
          <target state="translated">活动分支与非活动分支具有相同的开销，但也包含该分支上最近修改的每棵树的副本。如果自分支变为活动状态以来未修改子树 &lt;code&gt;include&lt;/code&gt; ，则其内容不会加载到内存中，但是如果自分支变为活动以来已通过提交修改了子树 &lt;code&gt;src&lt;/code&gt; ，则其内容将被加载到内存中。</target>
        </trans-unit>
        <trans-unit id="19a0105409fd4103b8842eb13af0140d95a67fb2" translate="yes" xml:space="preserve">
          <source>Active submodules</source>
          <target state="translated">活动的子模块</target>
        </trans-unit>
        <trans-unit id="8a0a4ffd02b3e3415f28bfa49ecef06eac3d36bf" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;, but is used by &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; documentation for details.</source>
          <target state="translated">行为类似于 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ，但由&lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]&lt;/a&gt;代替&lt;a href=&quot;git-fsck&quot;&gt;git-fsck [1]使用&lt;/a&gt;。有关详细信息，请参见 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="8a2b29e689f134a6c33caf76c2612bd809b36f86" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;, but is used by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; documentation for details.</source>
          <target state="translated">行为类似于 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ，但由&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;代替&lt;a href=&quot;git-fsck&quot;&gt;git-fsck [1]使用&lt;/a&gt;。有关详细信息，请参见 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="53c1b47e4f88ea8cc86f31135daa96f65e495e4d" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.skipList&lt;/code&gt;, but is used by &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.skipList&lt;/code&gt; documentation for details.</source>
          <target state="translated">行为类似于 &lt;code&gt;fsck.skipList&lt;/code&gt; ，但由&lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]&lt;/a&gt;代替&lt;a href=&quot;git-fsck&quot;&gt;git-fsck [1]使用&lt;/a&gt;。有关详细信息，请参见 &lt;code&gt;fsck.skipList&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="31c02a316f685de03eb757b49fbbce21e75b00c4" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.skipList&lt;/code&gt;, but is used by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.skipList&lt;/code&gt; documentation for details.</source>
          <target state="translated">行为类似于 &lt;code&gt;fsck.skipList&lt;/code&gt; ，但由&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;代替&lt;a href=&quot;git-fsck&quot;&gt;git-fsck [1]使用&lt;/a&gt;。有关详细信息，请参见 &lt;code&gt;fsck.skipList&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="7be512addc100ee865f5152fbfe972087266ea03" translate="yes" xml:space="preserve">
          <source>Actual behavior</source>
          <target state="translated">实际行为</target>
        </trans-unit>
        <trans-unit id="bb483d422626db8f460b089acb2b2a17f42ef653" translate="yes" xml:space="preserve">
          <source>Actually write the object into the object database.</source>
          <target state="translated">实际上是把对象写进对象数据库。</target>
        </trans-unit>
        <trans-unit id="9ae5ee2ecd5525bbb102db4f0d78bb539c98b2b0" translate="yes" xml:space="preserve">
          <source>Adapting your work-flow</source>
          <target state="translated">调整您的工作流程</target>
        </trans-unit>
        <trans-unit id="febbcaaccd6732ef0fbf603adeb6e4b1534f2caf" translate="yes" xml:space="preserve">
          <source>Add &quot;glob&quot; magic to all pathspec. This is equivalent to setting the &lt;code&gt;GIT_GLOB_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;. Disabling globbing on individual pathspecs can be done using pathspec magic &quot;:(literal)&quot;</source>
          <target state="translated">向所有pathspec添加&amp;ldquo; glob&amp;rdquo;魔术。这等效于将 &lt;code&gt;GIT_GLOB_PATHSPECS&lt;/code&gt; 环境变量设置为 &lt;code&gt;1&lt;/code&gt; 。可以使用pathspec magic&amp;ldquo;：（literal）&amp;rdquo;禁用单个pathspec上的globing</target>
        </trans-unit>
        <trans-unit id="7a1c5ad83cb656e31e0abe5871946adce7f2dbed" translate="yes" xml:space="preserve">
          <source>Add &quot;icase&quot; magic to all pathspec. This is equivalent to setting the &lt;code&gt;GIT_ICASE_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">向所有pathspec添加&amp;ldquo; icase&amp;rdquo;魔术。这等效于将 &lt;code&gt;GIT_ICASE_PATHSPECS&lt;/code&gt; 环境变量设置为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38d537b0a7b0bc1a6255114f214ad3b7382addc5" translate="yes" xml:space="preserve">
          <source>Add &quot;literal&quot; magic to all pathspec. This is equivalent to setting the &lt;code&gt;GIT_NOGLOB_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;. Enabling globbing on individual pathspecs can be done using pathspec magic &quot;:(glob)&quot;</source>
          <target state="translated">向所有pathspec添加&amp;ldquo;文字&amp;rdquo;魔术。这等效于将 &lt;code&gt;GIT_NOGLOB_PATHSPECS&lt;/code&gt; 环境变量设置为 &lt;code&gt;1&lt;/code&gt; 。可以使用pathspec magic&amp;ldquo;：（glob）&amp;rdquo;在单个pathspec上启用globing</target>
        </trans-unit>
        <trans-unit id="5a692c67e8b6f449d83f8b5219858b8b4cd34c65" translate="yes" xml:space="preserve">
          <source>Add (or prevent adding) the &quot;X-Mailer:&quot; header. By default, the header is added, but it can be turned off by setting the &lt;code&gt;sendemail.xmailer&lt;/code&gt; configuration variable to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">添加（或防止添加）&amp;ldquo; X-Mailer：&amp;rdquo;标题。默认情况下，将添加标头，但是可以通过将 &lt;code&gt;sendemail.xmailer&lt;/code&gt; 配置变量设置为 &lt;code&gt;false&lt;/code&gt; 来关闭标头。</target>
        </trans-unit>
        <trans-unit id="875e6f546a41d1d0704772304d2d43d72adc62d9" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;Signed-off-by:&lt;/code&gt; line to the commit message, using the committer identity of yourself. See the signoff option in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more information.</source>
          <target state="translated">使用您自己的提交者身份将&amp;ldquo; &lt;code&gt;Signed-off-by:&lt;/code&gt; 行添加到提交消息中。有关更多信息，请参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]中&lt;/a&gt;的signoff选项。</target>
        </trans-unit>
        <trans-unit id="ed47084b5999b126507c3c0b45a1bb8e478c76b6" translate="yes" xml:space="preserve">
          <source>Add Signed-off-by line at the end of the commit message. See the signoff option in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more information.</source>
          <target state="translated">在提交消息的末尾添加&amp;ldquo;按行签名&amp;rdquo;行。有关更多信息，请参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]中&lt;/a&gt;的signoff选项。</target>
        </trans-unit>
        <trans-unit id="290e4752e9d079cc99d7e2f47d052706296ff714" translate="yes" xml:space="preserve">
          <source>Add Signed-off-by line by the committer at the end of the commit log message. The meaning of a signoff depends on the project, but it typically certifies that committer has the rights to submit this work under the same license and agrees to a Developer Certificate of Origin (see &lt;a href=&quot;http://developercertificate.org/&quot;&gt;http://developercertificate.org/&lt;/a&gt; for more information).</source>
          <target state="translated">在提交日志消息的末尾添加由提交者签名的行。签名的含义取决于项目，但是通常可以证明提交者有权按照相同的许可证提交此作品，并同意开发者原产地证书（有关更多信息，请参见&lt;a href=&quot;http://developercertificate.org/&quot;&gt;http://developercertificate.org/&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="780762089271321ecfe958d672a214a85e1519d6" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Cc:&lt;/code&gt; header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form &lt;code&gt;--no-cc&lt;/code&gt; discards all &lt;code&gt;Cc:&lt;/code&gt; headers added so far (from config or command line).</source>
          <target state="translated">将 &lt;code&gt;Cc:&lt;/code&gt; 标头添加到电子邮件标头。除了任何已配置的标头之外，它可以多次使用。否定形式 &lt;code&gt;--no-cc&lt;/code&gt; 会丢弃到目前为止（从配置或命令行）添加的所有 &lt;code&gt;Cc:&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="ee7701fb474747c5b74516af829e74a1b309150b" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Signed-off-by:&lt;/code&gt; line to the commit message, using the committer identity of yourself. See the signoff option in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more information.</source>
          <target state="translated">使用您自己的提交者身份在提交消息中添加&amp;ldquo; &lt;code&gt;Signed-off-by:&lt;/code&gt; 行。有关更多信息，请参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]中&lt;/a&gt;的signoff选项。</target>
        </trans-unit>
        <trans-unit id="02bde52a21dbff5cbc2429add98116eb4d8f2e73" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Signed-off-by&lt;/code&gt; trailer at the end of the commit message. See the signoff option in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more information.</source>
          <target state="translated">在提交消息的末尾添加&amp;ldquo;已 &lt;code&gt;Signed-off-by&lt;/code&gt; 预告片。有关更多信息，请参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]中&lt;/a&gt;的signoff选项。</target>
        </trans-unit>
        <trans-unit id="8661d9ca330b4e0d62116002eff973a22aed49c6" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Signed-off-by&lt;/code&gt; trailer by the committer at the end of the commit log message. The meaning of a signoff depends on the project to which you&amp;rsquo;re committing. For example, it may certify that the committer has the rights to submit the work under the project&amp;rsquo;s license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See &lt;a href=&quot;http://developercertificate.org&quot;&gt;http://developercertificate.org&lt;/a&gt; for the one used by the Linux kernel and Git projects.) Consult the documentation or leadership of the project to which you&amp;rsquo;re contributing to understand how the signoffs are used in that project.</source>
          <target state="translated">添加 &lt;code&gt;Signed-off-by&lt;/code&gt; 由提交者在提交日志信息的末尾拖车。签核的含义取决于您要提交的项目。例如，它可以证明提交者有权在项目的许可下提交作品，或同意某些贡献者的代表，例如开发者原产地证书。（有关Linux内核和Git项目使用的工具，请参阅&lt;a href=&quot;http://developercertificate.org&quot;&gt;http://developercertificate.org&lt;/a&gt;。）请查阅您正在贡献的项目的文档或领导，以了解在该项目中如何使用签名。</target>
        </trans-unit>
        <trans-unit id="2d24bba5c471371e4f546b5382a422d6eb1fe77a" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Signed-off-by&lt;/code&gt; trailer to all the rebased commits. Note that if &lt;code&gt;--interactive&lt;/code&gt; is given then only commits marked to be picked, edited or reworded will have the trailer added.</source>
          <target state="translated">向所有重新提交的提交中添加一个基于 &lt;code&gt;Signed-off-by&lt;/code&gt; 预告片。请注意，如果给出了 &lt;code&gt;--interactive&lt;/code&gt; ，则仅标记为被选择，编辑或改写的提交将添加预告片。</target>
        </trans-unit>
        <trans-unit id="6b44f4f19612409c4fbf3ef36d5b06f22e4ab378" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Signed-off-by&lt;/code&gt; trailer to the commit message, using the committer identity of yourself. See the signoff option in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more information.</source>
          <target state="translated">使用您自己的提交者身份，将&amp;ldquo; &lt;code&gt;Signed-off-by&lt;/code&gt; 预告片添加到提交消息中。有关更多信息，请参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]中&lt;/a&gt;的signoff选项。</target>
        </trans-unit>
        <trans-unit id="1d5ee25b8be312a8351ef48a09ee57bfe0ac5407" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;To:&lt;/code&gt; header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form &lt;code&gt;--no-to&lt;/code&gt; discards all &lt;code&gt;To:&lt;/code&gt; headers added so far (from config or command line).</source>
          <target state="translated">在电子邮件标题中添加 &lt;code&gt;To:&lt;/code&gt; 标题。除任何已配置的标头外，它可以多次使用。否定形式 &lt;code&gt;--no-to&lt;/code&gt; 丢弃到目前为止（从配置或命令行）添加的所有 &lt;code&gt;To:&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="1d75fe65b404604e5ef539902b9de029d2905810" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;verify&lt;/code&gt; subcommand to the &lt;code&gt;git midx&lt;/code&gt; builtin to verify the contents of the multi-pack-index file match the offsets listed in the corresponding pack-indexes.</source>
          <target state="translated">向内置的 &lt;code&gt;git midx&lt;/code&gt; 中添加一个 &lt;code&gt;verify&lt;/code&gt; 子命令，以验证multi-pack-index文件的内容与相应的pack- indexs中列出的偏移量匹配。</target>
        </trans-unit>
        <trans-unit id="f049bd4f468982bc6e0cdfee8fd216a0b6cab6f3" translate="yes" xml:space="preserve">
          <source>Add a Signed-off-by: trailer to all the rebased commits. Note that if &lt;code&gt;--interactive&lt;/code&gt; is given then only commits marked to be picked, edited or reworded will have the trailer added.</source>
          <target state="translated">向所有重新提交的提交添加一个&amp;ldquo;签名人：&amp;rdquo;预告片。注意，如果给出了 &lt;code&gt;--interactive&lt;/code&gt; ，那么只有标记为被选中，编辑或改写的提交才会添加预告片。</target>
        </trans-unit>
        <trans-unit id="ced7c6e6677217cd2f3e27d5808cd7af3f82dcc9" translate="yes" xml:space="preserve">
          <source>Add a new remote, fetch, and check out a branch from it</source>
          <target state="translated">添加一个新的远程,获取,并从中检查出一个分支。</target>
        </trans-unit>
        <trans-unit id="67a238044913b3fe4075d66007f3a1c6a266ec59" translate="yes" xml:space="preserve">
          <source>Add a non-tracked file to the archive. Can be repeated to add multiple files. The path of the file in the archive is built by concatenating the value for &lt;code&gt;--prefix&lt;/code&gt; (if any) and the basename of &amp;lt;file&amp;gt;.</source>
          <target state="translated">将未跟踪的文件添加到存档中。可以重复添加多个文件。存档中文件的路径是通过串联 &lt;code&gt;--prefix&lt;/code&gt; 的值（如果有）和&amp;lt;file&amp;gt;的基本名称来构建的。</target>
        </trans-unit>
        <trans-unit id="c09eb40cb56d6e15f176719436ccb9ad1d152bed" translate="yes" xml:space="preserve">
          <source>Add a remote named &amp;lt;name&amp;gt; for the repository at &amp;lt;url&amp;gt;. The command &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; can then be used to create and update remote-tracking branches &amp;lt;name&amp;gt;/&amp;lt;branch&amp;gt;.</source>
          <target state="translated">在&amp;lt;url&amp;gt;为存储库添加一个名为&amp;lt;name&amp;gt;的远程目录。然后可以使用命令 &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 创建和更新远程跟踪分支&amp;lt;名称&amp;gt; / &amp;lt;分支&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="d7b8618aa62adcdff8f32f43f7ea6da4fbbc410b" translate="yes" xml:space="preserve">
          <source>Add a section on working with other version control systems, including CVS, Subversion, and just imports of series of release tarballs.</source>
          <target state="translated">增加一个关于与其他版本控制系统合作的部分,包括CVS、Subversion,以及只是导入一系列发布的tarballs。</target>
        </trans-unit>
        <trans-unit id="a6c8ce810b46aeac59b7c7fbb4f0eb1c414e0fbc" translate="yes" xml:space="preserve">
          <source>Add a signature to each message produced. Per RFC 3676 the signature is separated from the body by a line with '-- ' on it. If the signature option is omitted the signature defaults to the Git version number.</source>
          <target state="translated">为每条产生的电文添加一个签名。根据RFC 3676的规定,签名与正文之间用一行'--'隔开,如果省略签名选项,则签名默认为Git版本号。如果省略签名选项,则签名默认为 Git 版本号。</target>
        </trans-unit>
        <trans-unit id="d67013d040b00288c354d7feb55fb2074c49fc78" translate="yes" xml:space="preserve">
          <source>Add a tag reference in &lt;code&gt;refs/tags/&lt;/code&gt;, unless &lt;code&gt;-d/-l/-v&lt;/code&gt; is given to delete, list or verify tags.</source>
          <target state="translated">在 &lt;code&gt;refs/tags/&lt;/code&gt; 添加标签引用，除非给出 &lt;code&gt;-d/-l/-v&lt;/code&gt; 来删除，列出或验证标签。</target>
        </trans-unit>
        <trans-unit id="c3ba9550fdf49f0f7ec1ed9c2838f550f0841180" translate="yes" xml:space="preserve">
          <source>Add all existing files to the index.</source>
          <target state="translated">将所有现有文件添加到索引中。</target>
        </trans-unit>
        <trans-unit id="61e0fed7e8f28eb826825866ef9181c8986ab6b6" translate="yes" xml:space="preserve">
          <source>Add an arbitrary header to the email headers. This is in addition to any configured headers, and may be used multiple times. For example, &lt;code&gt;--add-header=&quot;Organization: git-foo&quot;&lt;/code&gt;. The negated form &lt;code&gt;--no-add-header&lt;/code&gt; discards &lt;strong&gt;all&lt;/strong&gt; (&lt;code&gt;To:&lt;/code&gt;, &lt;code&gt;Cc:&lt;/code&gt;, and custom) headers added so far from config or command line.</source>
          <target state="translated">将任意标题添加到电子邮件标题。除任何已配置的标头外，它可以多次使用。例如，-- &lt;code&gt;--add-header=&quot;Organization: git-foo&quot;&lt;/code&gt; 。否定形式 &lt;code&gt;--no-add-header&lt;/code&gt; 丢弃到目前为止从config或命令行添加的&lt;strong&gt;所有&lt;/strong&gt;（ &lt;code&gt;To:&lt;/code&gt; ， &lt;code&gt;Cc:&lt;/code&gt; 和custom）标头。</target>
        </trans-unit>
        <trans-unit id="3eb694979cbe30dcf490050a0765be211e88b887" translate="yes" xml:space="preserve">
          <source>Add an extra directive to the output for commits and blobs, &lt;code&gt;original-oid &amp;lt;SHA1SUM&amp;gt;&lt;/code&gt;. While such directives will likely be ignored by importers such as git-fast-import, it may be useful for intermediary filters (e.g. for rewriting commit messages which refer to older commits, or for stripping blobs by id).</source>
          <target state="translated">在输出中为commit和blob添加一个额外的指令， &lt;code&gt;original-oid &amp;lt;SHA1SUM&amp;gt;&lt;/code&gt; 指令&amp;lt;SHA1SUM&amp;gt;。尽管此类指令可能会被git-fast-import之类的导入器忽略，但它对于中间过滤器可能很有用（例如，用于重写引用较早提交的提交消息，或用于通过id删除blob）。</target>
        </trans-unit>
        <trans-unit id="d3d9056473fe07372c67f810c3055c3b46a20590" translate="yes" xml:space="preserve">
          <source>Add authorship information. Adds Author line, and Committer (if different from Author) to the message.</source>
          <target state="translated">添加作者信息。在消息中添加作者行和提交者(如果与作者不同)。</target>
        </trans-unit>
        <trans-unit id="b495931d52e43ecbfb5286b0146fb64097586eff" translate="yes" xml:space="preserve">
          <source>Add file contents to the index</source>
          <target state="translated">将文件内容添加到索引中</target>
        </trans-unit>
        <trans-unit id="c35a311c3337f0cc2cbd68316a0fe51132f8719c" translate="yes" xml:space="preserve">
          <source>Add modified contents in the working tree interactively to the index. Optional path arguments may be supplied to limit operation to a subset of the working tree. See &amp;ldquo;Interactive mode&amp;rdquo; for details.</source>
          <target state="translated">以交互方式将工作树中的修改内容添加到索引。可以提供可选的路径参数，以将操作限制为工作树的子集。有关详细信息，请参见&amp;ldquo;交互模式&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f89fde681339a37c16082b848c84b533f9b8eb78" translate="yes" xml:space="preserve">
          <source>Add more good examples. Entire sections of just cookbook examples might be a good idea; maybe make an &quot;advanced examples&quot; section a standard end-of-chapter section?</source>
          <target state="translated">增加更多的好例子。整整一节的烹饪书例子可能是个好主意;也许可以把 &quot;高级例子 &quot;一节作为标准的章节结束部分?</target>
        </trans-unit>
        <trans-unit id="e557ff36381109d45439d6a8300a1119a6fdeb9a" translate="yes" xml:space="preserve">
          <source>Add notes for a given object (defaults to HEAD). Abort if the object already has notes (use &lt;code&gt;-f&lt;/code&gt; to overwrite existing notes). However, if you&amp;rsquo;re using &lt;code&gt;add&lt;/code&gt; interactively (using an editor to supply the notes contents), then - instead of aborting - the existing notes will be opened in the editor (like the &lt;code&gt;edit&lt;/code&gt; subcommand).</source>
          <target state="translated">添加给定对象的注释（默认为HEAD）。如果对象已经有注释，则中止（使用 &lt;code&gt;-f&lt;/code&gt; 覆盖现有注释）。但是，如果您以交互方式使用 &lt;code&gt;add&lt;/code&gt; （使用编辑器来提供注释内容），那么-而不是中止-现有的注释将在编辑器中打开（如 &lt;code&gt;edit&lt;/code&gt; 子命令）。</target>
        </trans-unit>
        <trans-unit id="cc2ade0db6bb50863f06b44fc9c06dfd60dcfff0" translate="yes" xml:space="preserve">
          <source>Add or inspect object notes</source>
          <target state="translated">添加或检查对象注释</target>
        </trans-unit>
        <trans-unit id="384163813513712116bc610979aaf5a161ff795b" translate="yes" xml:space="preserve">
          <source>Add or parse structured information in commit messages</source>
          <target state="translated">在提交消息中添加或解析结构化信息。</target>
        </trans-unit>
        <trans-unit id="4e875c484b14b19240ea9be7566dd014f5c8ec38" translate="yes" xml:space="preserve">
          <source>Add the given merge information during the dcommit (e.g. &lt;code&gt;--mergeinfo=&quot;/branches/foo:1-10&quot;&lt;/code&gt;). All svn server versions can store this information (as a property), and svn clients starting from version 1.5 can make use of it. To specify merge information from multiple branches, use a single space character between the branches (&lt;code&gt;--mergeinfo=&quot;/branches/foo:1-10 /branches/bar:3,5-6,8&quot;&lt;/code&gt;)</source>
          <target state="translated">在dcommit期间添加给定的合并信息（例如 &lt;code&gt;--mergeinfo=&quot;/branches/foo:1-10&quot;&lt;/code&gt; ）。所有svn服务器版本都可以存储此信息（作为属性），而从1.5版开始的svn客户端可以使用它。要指定来自多个分支的合并信息，请在分支之间使用单个空格字符（ &lt;code&gt;--mergeinfo=&quot;/branches/foo:1-10 /branches/bar:3,5-6,8&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3cd81f5530cb193ba26157e4348607aee6556490" translate="yes" xml:space="preserve">
          <source>Add the given repository as a submodule at the given path to the changeset to be committed next to the current project: the current project is termed the &quot;superproject&quot;.</source>
          <target state="translated">将给定的仓库作为子模块添加到给定路径的变更集中,并提交到当前项目旁边:当前项目被称为 &quot;超级项目&quot;。</target>
        </trans-unit>
        <trans-unit id="5cddbbcd4cc96cbfc64c9c4d6d8f5bcef7bbee43" translate="yes" xml:space="preserve">
          <source>Add the standard Git exclusions: .git/info/exclude, .gitignore in each directory, and the user&amp;rsquo;s global exclusion file.</source>
          <target state="translated">添加标准的Git排除项：.git / info / exclude，每个目录中的.gitignore以及用户的全局排除文件。</target>
        </trans-unit>
        <trans-unit id="9821869aa821996defeaba01e6c12538af610d55" translate="yes" xml:space="preserve">
          <source>Added content is represented by lines beginning with &quot;+&quot;. You can prevent staging any addition lines by deleting them.</source>
          <target state="translated">添加的内容用 &quot;+&quot;开头的行表示。您可以通过删除任何添加行来防止分期。</target>
        </trans-unit>
        <trans-unit id="afb70b05688a7cd869d2606481b27296b19719c8" translate="yes" xml:space="preserve">
          <source>Additional commands may be supported, as may be determined from capabilities reported by the helper.</source>
          <target state="translated">可以支持更多的命令,这可能是由帮助者报告的能力决定的。</target>
        </trans-unit>
        <trans-unit id="73160eb439c17b83bb173df83040945299062f05" translate="yes" xml:space="preserve">
          <source>Additional email headers to include in a patch to be submitted by mail. See &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">要通过邮件提交的补丁中包含的其他电子邮件标头。参见&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54ded2bd3477ca52f24ae225994ba73ed8ad29b3" translate="yes" xml:space="preserve">
          <source>Additional features not supported in the base command will be advertised as the value of the command in the capability advertisement in the form of a space separated list of features: &quot;&amp;lt;command&amp;gt;=&amp;lt;feature 1&amp;gt; &amp;lt;feature 2&amp;gt;&quot;</source>
          <target state="translated">基本命令中不支持的其他功能将在功能公告中以空格分隔的功能列表形式作为命令的值发布：&amp;ldquo; &amp;lt;命令&amp;gt; = &amp;lt;功能1&amp;gt; &amp;lt;功能2&amp;gt;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="fa12c13f7c5fa3298b908c7e9540ddac59b47249" translate="yes" xml:space="preserve">
          <source>Additional information about the object store is recorded in this directory.</source>
          <target state="translated">关于对象存储的其他信息记录在这个目录中。</target>
        </trans-unit>
        <trans-unit id="be06c5d8e7c3543b7023fd7faff294ed6ccc5563" translate="yes" xml:space="preserve">
          <source>Additional information about the repository is recorded in this directory. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/info&quot; will be used instead.</source>
          <target state="translated">关于版本库的附加信息会记录在这个目录中。如果设置了 $GIT_COMMON_DIR,这个目录将被忽略,而使用 &quot;$GIT_COMMON_DIR/info&quot;。</target>
        </trans-unit>
        <trans-unit id="e1d5079ec73555b8d437ff4e76ae398022d66054" translate="yes" xml:space="preserve">
          <source>Additional links to be added to the start of the breadcrumb trail before the home link, to pages that are logically &quot;above&quot; the gitweb projects list, such as the organization and department which host the gitweb server. Each element of the list is a reference to an array, in which element 0 is the link text (equivalent to &lt;code&gt;$home_link_str&lt;/code&gt;) and element 1 is the target URL (equivalent to &lt;code&gt;$home_link&lt;/code&gt;).</source>
          <target state="translated">附加链接将添加到主页链接之前的面包屑路径的开始，以逻辑上位于gitweb项目列表上方的页面，例如托管gitweb服务器的组织和部门。列表中的每个元素都是对数组的引用，其中元素0是链接文本（相当于 &lt;code&gt;$home_link_str&lt;/code&gt; ），元素1是目标URL（相当于 &lt;code&gt;$home_link&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d9432410873900e1c24cb64c2fa2f5825d3d685b" translate="yes" xml:space="preserve">
          <source>Additional option to &lt;code&gt;--full-history&lt;/code&gt; to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge.</source>
          <target state="translated">&lt;code&gt;--full-history&lt;/code&gt; 的附加选项，可从结果历史记录中删除一些不必要的合并，因为没有选定的提交会对此合并作出贡献。</target>
        </trans-unit>
        <trans-unit id="936252ffd07e8aa44edb6a58806e990e0e986320" translate="yes" xml:space="preserve">
          <source>Additional option to &lt;code&gt;--full-history&lt;/code&gt; to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">&lt;code&gt;--full-history&lt;/code&gt; 的附加选项，可从结果历史记录中删除一些不必要的合并，因为没有选定的提交会对此合并作出贡献。（有关详细说明，请参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;中的&amp;ldquo;历史记录简化&amp;rdquo; 。）</target>
        </trans-unit>
        <trans-unit id="639abe6e93382e14198d397d42d012876c506898" translate="yes" xml:space="preserve">
          <source>Additional options for cvsps. The options &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-A&lt;/code&gt; are implicit and should not be used here.</source>
          <target state="translated">cvsps的其他选项。选项 &lt;code&gt;-u&lt;/code&gt; 和 &lt;code&gt;-A&lt;/code&gt; 是隐式的，在这里不应该使用。</target>
        </trans-unit>
        <trans-unit id="126d4b07345ee8d93a4ae79da306723c896414b7" translate="yes" xml:space="preserve">
          <source>Additional recipients to include in a patch to be submitted by mail. See the --to and --cc options in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">要通过邮件提交的补丁中包含的其他收件人。请参阅&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]中&lt;/a&gt;的--to和--cc选项。</target>
        </trans-unit>
        <trans-unit id="37901b95369dc888aa41ab1e345bdcf6c9cbdd0a" translate="yes" xml:space="preserve">
          <source>Additionally, &quot;[PATCH]&quot; will be stripped from the commit description.</source>
          <target state="translated">此外,&quot;[PATCH]&quot;将从提交描述中删除。</target>
        </trans-unit>
        <trans-unit id="0bc71d2723c31c614f1b1ab35563bf6b0a57afff" translate="yes" xml:space="preserve">
          <source>Additionally, if you have a choice between storage formats that are text based or non-text based, we recommend storing files in the text format and, if necessary, transforming them into the other format. For example, a text-based SQL dump with one record per line will work much better for diffing and merging than an actual database file. Similarly, text-based formats such as Markdown and AsciiDoc will work better than binary formats such as Microsoft Word and PDF.</source>
          <target state="translated">此外,如果您可以在基于文本或非文本的存储格式之间进行选择,我们建议以文本格式存储文件,并在必要时将其转换为其他格式。例如,基于文本的SQL转储,每行只有一条记录,比实际的数据库文件更适合进行差异化和合并。同样,基于文本的格式,如Markdown和AsciiDoc比二进制格式,如Microsoft Word和PDF更好用。</target>
        </trans-unit>
        <trans-unit id="45f709ea6030431bf2cc526dc56f831bf13777f2" translate="yes" xml:space="preserve">
          <source>Additionally, it detects and handles renames and complete rewrites intelligently to produce a renaming patch. A renaming patch reduces the amount of text output, and generally makes it easier to review. Note that non-Git &quot;patch&quot; programs won&amp;rsquo;t understand renaming patches, so use it only when you know the recipient uses Git to apply your patch.</source>
          <target state="translated">此外，它可以检测并处理重命名并智能地完成重写以生成重命名补丁。重命名补丁程序会减少文本输出的数量，并且通常使复查更容易。请注意，非Git&amp;ldquo;补丁&amp;rdquo;程序不会理解重命名补丁，因此仅当您知道收件人使用Git来应用补丁时才使用它。</target>
        </trans-unit>
        <trans-unit id="7511556dc9bb42ef3e1b927086b0b7b0eb2fc510" translate="yes" xml:space="preserve">
          <source>Additionally, it will create a special branch named &lt;code&gt;&amp;lt;branchname&amp;gt;@&amp;lt;SVN-Revision&amp;gt;&lt;/code&gt;, where &amp;lt;SVN-Revision&amp;gt; is the SVN revision number the branch was copied from. This branch will point to the newly created parent commit of the branch. If in SVN the branch was deleted and later recreated from a different version, there will be multiple such branches with an &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">此外，它将创建一个名为 &lt;code&gt;&amp;lt;branchname&amp;gt;@&amp;lt;SVN-Revision&amp;gt;&lt;/code&gt; 的特殊分支，其中&amp;lt;SVN-Revision&amp;gt;是复制该分支的SVN版本号。该分支将指向该分支的新创建的父提交。如果在SVN中删除了该分支，后来又从其他版本重新创建，则会有多个带有 &lt;code&gt;@&lt;/code&gt; 的此类分支。</target>
        </trans-unit>
        <trans-unit id="c4aae954f8fe3ec994c11ca19a460c6f95d1b16b" translate="yes" xml:space="preserve">
          <source>Additionally, only one of these options can be used per svn-remote section because they affect the &lt;code&gt;git-svn-id:&lt;/code&gt; metadata line, except for rewriteRoot and rewriteUUID which can be used together.</source>
          <target state="translated">此外，每个选项只能在svn-remote部分中使用，因为它们会影响 &lt;code&gt;git-svn-id:&lt;/code&gt; 元数据行，但可以一起使用的rewriteRoot和rewriteUUID除外。</target>
        </trans-unit>
        <trans-unit id="629abb925697ea2611b60db0bc894374f52c4869" translate="yes" xml:space="preserve">
          <source>Additionally, the commit diff lines that are only present in the first commit range are shown &quot;dimmed&quot; (this can be overridden using the &lt;code&gt;color.diff.&amp;lt;slot&amp;gt;&lt;/code&gt; config setting where &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;contextDimmed&lt;/code&gt;, &lt;code&gt;oldDimmed&lt;/code&gt; and &lt;code&gt;newDimmed&lt;/code&gt;), and the commit diff lines that are only present in the second commit range are shown in bold (which can be overridden using the config settings &lt;code&gt;color.diff.&amp;lt;slot&amp;gt;&lt;/code&gt; with &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; being one of &lt;code&gt;contextBold&lt;/code&gt;, &lt;code&gt;oldBold&lt;/code&gt; or &lt;code&gt;newBold&lt;/code&gt;).</source>
          <target state="translated">此外，仅出现在第一个提交范围中的提交差异行显示为&amp;ldquo;变暗&amp;rdquo;（可以使用 &lt;code&gt;color.diff.&amp;lt;slot&amp;gt;&lt;/code&gt; 配置设置来覆盖，其中 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 是 &lt;code&gt;contextDimmed&lt;/code&gt; ， &lt;code&gt;oldDimmed&lt;/code&gt; 和 &lt;code&gt;newDimmed&lt;/code&gt; 之一），并且仅在第二个提交范围中出现的提交差异行以粗体显示（可以使用配置设置 &lt;code&gt;color.diff.&amp;lt;slot&amp;gt;&lt;/code&gt; 覆盖，其中 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 是 &lt;code&gt;contextBold&lt;/code&gt; ， &lt;code&gt;oldBold&lt;/code&gt; 或 &lt;code&gt;newBold&lt;/code&gt; 之一）。</target>
        </trans-unit>
        <trans-unit id="e3a92988309d106a41ec2c3de042e66fc0f8ee75" translate="yes" xml:space="preserve">
          <source>Additionally, the trailers as interpreted by &lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers[1]&lt;/a&gt; are obtained as &lt;code&gt;trailers&lt;/code&gt; (or by using the historical alias &lt;code&gt;contents:trailers&lt;/code&gt;). Non-trailer lines from the trailer block can be omitted with &lt;code&gt;trailers:only&lt;/code&gt;. Whitespace-continuations can be removed from trailers so that each trailer appears on a line by itself with its full content with &lt;code&gt;trailers:unfold&lt;/code&gt;. Both can be used together as &lt;code&gt;trailers:unfold,only&lt;/code&gt;.</source>
          <target state="translated">另外，由&lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers [1]解释的预告片&lt;/a&gt;作为 &lt;code&gt;trailers&lt;/code&gt; 获得（或通过使用历史别名 &lt;code&gt;contents:trailers&lt;/code&gt; ）获得。可以使用 &lt;code&gt;trailers:only&lt;/code&gt; 省略来自预告片块的非预告线。可以从预告片中删除空白连续符，以便每个预告片单独显示在一行中，并且其全部内容与 &lt;code&gt;trailers:unfold&lt;/code&gt; 相同。两者都可以一起用作 &lt;code&gt;trailers:unfold,only&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33cc6001363abb379cd9070769d41d2ac8c9a55b" translate="yes" xml:space="preserve">
          <source>Additionally, when a configured remote has &lt;code&gt;remote.&amp;lt;name&amp;gt;.vcs&lt;/code&gt; set to &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt;, Git explicitly invokes &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; as the first argument. If set, the second argument is &lt;code&gt;remote.&amp;lt;name&amp;gt;.url&lt;/code&gt;; otherwise, the second argument is omitted.</source>
          <target state="translated">此外，当已配置的远程服务器将 &lt;code&gt;remote.&amp;lt;name&amp;gt;.vcs&lt;/code&gt; 设置为 &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; 时，Git会以 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 作为第一个参数显式调用 &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; 。如果设置，则第二个参数为 &lt;code&gt;remote.&amp;lt;name&amp;gt;.url&lt;/code&gt; ；否则，省略第二个参数。</target>
        </trans-unit>
        <trans-unit id="6af479ae4e97a30fad59cd7baeb4a449867877a2" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;replace&lt;/code&gt; reference in &lt;code&gt;refs/replace/&lt;/code&gt; namespace.</source>
          <target state="translated">在 &lt;code&gt;refs/replace/&lt;/code&gt; 名称空间中添加 &lt;code&gt;replace&lt;/code&gt; 引用。</target>
        </trans-unit>
        <trans-unit id="4797f43101a1e293589022c56a6d2c722d2df1bd" translate="yes" xml:space="preserve">
          <source>Adds a new line to the option without altering any existing values. This is the same as providing &lt;code&gt;^$&lt;/code&gt; as the &lt;code&gt;value-pattern&lt;/code&gt; in &lt;code&gt;--replace-all&lt;/code&gt;.</source>
          <target state="translated">在选项中添加新行，而不更改任何现有值。这与在 &lt;code&gt;--replace-all&lt;/code&gt; 中提供 &lt;code&gt;^$&lt;/code&gt; 作为 &lt;code&gt;value-pattern&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="067f226622dab621132cf8ecc0c9775fffa56382" translate="yes" xml:space="preserve">
          <source>Adds a new line to the option without altering any existing values. This is the same as providing &lt;code&gt;^$&lt;/code&gt; as the value_regex in &lt;code&gt;--replace-all&lt;/code&gt;.</source>
          <target state="translated">在选项中添加新行，而不更改任何现有值。这与在 &lt;code&gt;--replace-all&lt;/code&gt; 中提供 &lt;code&gt;^$&lt;/code&gt; 作为value_regex 相同。</target>
        </trans-unit>
        <trans-unit id="25827132716a81d21acebe34dd646ff14930968e" translate="yes" xml:space="preserve">
          <source>Adds a remote named &amp;lt;name&amp;gt; for the repository at &amp;lt;url&amp;gt;. The command &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; can then be used to create and update remote-tracking branches &amp;lt;name&amp;gt;/&amp;lt;branch&amp;gt;.</source>
          <target state="translated">在&amp;lt;url&amp;gt;为存储库添加一个名为&amp;lt;name&amp;gt;的远程目录。然后可以使用命令 &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 创建和更新远程跟踪分支&amp;lt;名称&amp;gt; / &amp;lt;分支&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="ab8c59cb65189781a225d03eb525c1d3e35346e1" translate="yes" xml:space="preserve">
          <source>Adds content from all &lt;code&gt;*.txt&lt;/code&gt; files under &lt;code&gt;Documentation&lt;/code&gt; directory and its subdirectories:</source>
          <target state="translated">从 &lt;code&gt;Documentation&lt;/code&gt; 目录及其子目录下的所有 &lt;code&gt;*.txt&lt;/code&gt; 文件添加内容：</target>
        </trans-unit>
        <trans-unit id="d2a8bde384697b7b35dc55b38f84a5bc59a23070" translate="yes" xml:space="preserve">
          <source>Adds the file to the index again.</source>
          <target state="translated">再次将该文件添加到索引中。</target>
        </trans-unit>
        <trans-unit id="9deafeaa2ae3e0af3bf37dc46c067f8db67dd63a" translate="yes" xml:space="preserve">
          <source>Adds, removes, or reads notes attached to objects, without touching the objects themselves.</source>
          <target state="translated">在不接触对象本身的情况下,添加、删除或读取对象上的注释。</target>
        </trans-unit>
        <trans-unit id="b8f333e4ae95f720feba6eabc8b0ae852b99b985" translate="yes" xml:space="preserve">
          <source>Administering</source>
          <target state="translated">Administering</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="c98cde56602b5dbe18cd13dfc6b1296aba3da4ee" translate="yes" xml:space="preserve">
          <source>Advanced branch management</source>
          <target state="translated">高级分支机构管理</target>
        </trans-unit>
        <trans-unit id="63c9e0bac98e698a29bdae673d4e9edfa151c025" translate="yes" xml:space="preserve">
          <source>Advanced options</source>
          <target state="translated">高级选项</target>
        </trans-unit>
        <trans-unit id="5126907c1aaa23aea7d546c880913def66c36620" translate="yes" xml:space="preserve">
          <source>Advanced shared repository management</source>
          <target state="translated">高级共享存储库管理</target>
        </trans-unit>
        <trans-unit id="1b3bdc1b24cf17ee4a466d753939342282e0d80f" translate="yes" xml:space="preserve">
          <source>Advanced web server setup</source>
          <target state="translated">高级网络服务器设置</target>
        </trans-unit>
        <trans-unit id="b6a2eaecb555069cd46a3c234e96420e295802e9" translate="yes" xml:space="preserve">
          <source>Advertise the URL of &lt;code&gt;proj.git&lt;/code&gt;. Anybody else should then be able to clone or pull from that URL, for example with a command line like:</source>
          <target state="translated">宣传 &lt;code&gt;proj.git&lt;/code&gt; 的URL 。然后，其他任何人都应该能够从该URL进行克隆或提取，例如，使用以下命令行：</target>
        </trans-unit>
        <trans-unit id="789a67096a4646c15f2aa6086486ffd34077e411" translate="yes" xml:space="preserve">
          <source>Advice on how to set your identity configuration when your information is guessed from the system username and domain name.</source>
          <target state="translated">建议从系统用户名和域名猜测你的信息时,如何设置你的身份配置。</target>
        </trans-unit>
        <trans-unit id="a821447d06e24bab231c15461aafe7618db95e5a" translate="yes" xml:space="preserve">
          <source>Advice on what to do when you&amp;rsquo;ve accidentally added one git repo inside of another.</source>
          <target state="translated">当您不小心在另一个git repo中添加了一个git repo时该怎么做的建议。</target>
        </trans-unit>
        <trans-unit id="3d483bea154d1589851e27e82350c90b66804ae7" translate="yes" xml:space="preserve">
          <source>Advice shown by various commands when conflicts prevent the operation from being performed.</source>
          <target state="translated">当发生冲突无法进行操作时,各种命令所显示的建议。</target>
        </trans-unit>
        <trans-unit id="f6a85c6f280ebe2521ee45431f06743254445adc" translate="yes" xml:space="preserve">
          <source>Advice shown if a hook is ignored because the hook is not set as executable.</source>
          <target state="translated">如果因为钩子没有被设置为可执行,而忽略了该钩子,则显示的建议。</target>
        </trans-unit>
        <trans-unit id="94667464d70841fb0d303f0566cdfefaa202fbb7" translate="yes" xml:space="preserve">
          <source>Advice shown if a user attempts to add an ignored file to the index.</source>
          <target state="translated">如果用户试图将一个被忽略的文件添加到索引中,则显示的建议。</target>
        </trans-unit>
        <trans-unit id="860ec9915ca898e80b509fbd6387408b77665509" translate="yes" xml:space="preserve">
          <source>Advice shown if a user attempts to recursively tag a tag object.</source>
          <target state="translated">当用户试图递归标记一个标记对象时显示的建议。</target>
        </trans-unit>
        <trans-unit id="380186874c1d8ce69a1886939554074230a69de1" translate="yes" xml:space="preserve">
          <source>Advice shown if a user runs the add command without providing the pathspec parameter.</source>
          <target state="translated">如果用户在没有提供pathspec参数的情况下运行add命令,则会显示建议。</target>
        </trans-unit>
        <trans-unit id="4564a8cef9c264afd1da9386fe52f7316f5ca2ba" translate="yes" xml:space="preserve">
          <source>Advice shown when &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; takes a long time to calculate forced updates after ref updates, or to warn that the check is disabled.</source>
          <target state="translated">当&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;需要很长的时间来计算ref更新之后的强制更新，或警告禁用检查时，显示的建议。</target>
        </trans-unit>
        <trans-unit id="1d65ddbca3a799ed312f569d4aeb5502874161b1" translate="yes" xml:space="preserve">
          <source>Advice shown when &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; refuses to merge to avoid overwriting local changes.</source>
          <target state="translated">当示出建议&lt;a href=&quot;git-merge&quot;&gt;的git合并[1]&lt;/a&gt;拒绝合并，以避免覆盖的局部变化。</target>
        </trans-unit>
        <trans-unit id="b0d8f2ca61900be48cc5b75f8552ddc63690e847" translate="yes" xml:space="preserve">
          <source>Advice shown when &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; fails due to a non-fast-forward update to the current branch.</source>
          <target state="translated">当&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;由于对当前分支的非快进更新而失败时显示的建议。</target>
        </trans-unit>
        <trans-unit id="4568fed53b701ea10d314b56862ee812cfea2bea" translate="yes" xml:space="preserve">
          <source>Advice shown when a sequencer command is already in progress.</source>
          <target state="translated">当定序器命令已在进行中时显示的建议。</target>
        </trans-unit>
        <trans-unit id="9ae8580cfe92126e912e3c0a9b1125abf0c3f017" translate="yes" xml:space="preserve">
          <source>Advice shown when a submodule.alternateErrorStrategy option configured to &quot;die&quot; causes a fatal error.</source>
          <target state="translated">当配置为 &quot;die &quot;的submodule.alternateErrorStrategy选项导致致命错误时显示的建议。</target>
        </trans-unit>
        <trans-unit id="df663a838b7df94d5ce12ffdd49a91bc903ea158" translate="yes" xml:space="preserve">
          <source>Advice shown when the argument to &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; and &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; ambiguously resolves to a remote tracking branch on more than one remote in situations where an unambiguous argument would have otherwise caused a remote-tracking branch to be checked out. See the &lt;code&gt;checkout.defaultRemote&lt;/code&gt; configuration variable for how to set a given remote to used by default in some situations where this advice would be printed.</source>
          <target state="translated">当在明确的参数会导致检出远程跟踪分支的情况下，当&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;和&lt;a href=&quot;git-switch&quot;&gt;git-switch [1]的参数&lt;/a&gt;模糊地解析到多个远程站点上的远程跟踪分支时显示的建议。请参阅 &lt;code&gt;checkout.defaultRemote&lt;/code&gt; 配置变量，以了解如何在打印此建议的某些情况下将给定的遥控器设置为默认使用。</target>
        </trans-unit>
        <trans-unit id="287a70bfe9316e6c27233404e6ef7bfe75cf2ade" translate="yes" xml:space="preserve">
          <source>Advice shown when you ran &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and pushed &lt;code&gt;matching refs&lt;/code&gt; explicitly (i.e. you used &lt;code&gt;:&lt;/code&gt;, or specified a refspec that isn&amp;rsquo;t your current branch) and it resulted in a non-fast-forward error.</source>
          <target state="translated">当您运行&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;并显式推送 &lt;code&gt;matching refs&lt;/code&gt; （即您使用了 &lt;code&gt;:&lt;/code&gt; ，或者指定了不是当前分支的refspec）显示了建议，这导致了非快进错误。</target>
        </trans-unit>
        <trans-unit id="c04cbde1130eafb3edca74961656b00234c5044b" translate="yes" xml:space="preserve">
          <source>Advice shown when you used &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; or &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; to move to the detach HEAD state, to instruct how to create a local branch after the fact.</source>
          <target state="translated">当您使用&lt;a href=&quot;git-switch&quot;&gt;git-switch [1]&lt;/a&gt;或&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;移至分离HEAD状态时，将显示建议，以指导如何在事后创建本地分支。</target>
        </trans-unit>
        <trans-unit id="ef27fc3c51d0563e2cd508226536f4e82abdea97" translate="yes" xml:space="preserve">
          <source>Advice that shows the location of the patch file when &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; fails to apply it.</source>
          <target state="translated">当&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;无法应用补丁文件时，显示补丁文件位置的建议。</target>
        </trans-unit>
        <trans-unit id="28a199e10db511a76b4343fb1d5d8f81b83d30fa" translate="yes" xml:space="preserve">
          <source>Advice to consider using the &lt;code&gt;--quiet&lt;/code&gt; option to &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt; when the command takes more than 2 seconds to enumerate unstaged changes after reset.</source>
          <target state="translated">建议在命令花费2秒钟以上的时间来枚举重置后的未暂存更改时，考虑使用 &lt;code&gt;--quiet&lt;/code&gt; 选项来&lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c591e1c0c160f4739a66ef35a070ea84c2e7f3a4" translate="yes" xml:space="preserve">
          <source>Advise to consider using the &lt;code&gt;-u&lt;/code&gt; option to &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; when the command takes more than 2 seconds to enumerate untracked files.</source>
          <target state="translated">建议在命令花费2秒钟以上的时间来枚举未跟踪的文件时，考虑对&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;使用 &lt;code&gt;-u&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="5496dea1231cd43f3ddab3a40907ffb3e37af6ae" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;attr:&lt;/code&gt; comes a space separated list of &quot;attribute requirements&quot;, all of which must be met in order for the path to be considered a match; this is in addition to the usual non-magic pathspec pattern matching. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;attr:&lt;/code&gt; 之后：出现一个用空格分隔的&amp;ldquo;属性要求&amp;rdquo;列表，必须满足所有条件才能将路径视为匹配项；这是通常的非魔术路径规范模式匹配的补充。参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a429914950c338a68e237d8a7583b13b733a18d9" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;collapsing&lt;/code&gt; operation, paths that are different in three trees are left in non-zero stages. At this point, you can inspect the index file with this command:</source>
          <target state="translated">后 &lt;code&gt;collapsing&lt;/code&gt; 操作，在三棵树是不同的路径被留在非零阶段。此时，您可以使用以下命令检查索引文件：</target>
        </trans-unit>
        <trans-unit id="f8a35b13d3b2d2c3173fb0d4b6b82c758bbe9442" translate="yes" xml:space="preserve">
          <source>After Git received the pathnames, it will request the corresponding blobs again. These requests contain a pathname and an empty content section. The filter is expected to respond with the smudged content in the usual way as explained above.</source>
          <target state="translated">Git 收到路径名后,会再次请求相应的 blobs。这些请求包含一个路径名和一个空的内容部分。过滤器要以上面解释的通常方式响应污点内容。</target>
        </trans-unit>
        <trans-unit id="66031e0774792924c3ad30f78f9d0c8073d135a9" translate="yes" xml:space="preserve">
          <source>After a &lt;code&gt;git merge&lt;/code&gt; stops due to conflicts you can conclude the merge by running &lt;code&gt;git merge --continue&lt;/code&gt; (see &quot;HOW TO RESOLVE CONFLICTS&quot; section below).</source>
          <target state="translated">由于冲突而停止 &lt;code&gt;git merge&lt;/code&gt; 后，您可以通过运行 &lt;code&gt;git merge --continue&lt;/code&gt; 结束合并（请参见下面的&amp;ldquo;如何解决冲突&amp;rdquo;部分）。</target>
        </trans-unit>
        <trans-unit id="fe72261aa48e1b3f091f59d72477eebdd075b990" translate="yes" xml:space="preserve">
          <source>After a bisect session, to clean up the bisection state and return to the original HEAD, issue the following command:</source>
          <target state="translated">在一次二分法会话后,要清理二分法状态并返回到原来的HEAD,请发出以下命令。</target>
        </trans-unit>
        <trans-unit id="47c118266972ae017fd4f07d4eca9db22855faae" translate="yes" xml:space="preserve">
          <source>After a failed merge, show refs that touch files having a conflict and don&amp;rsquo;t exist on all heads to merge.</source>
          <target state="translated">合并失败后，请显示引用碰到有冲突且并非所有要合并的文件的引用。</target>
        </trans-unit>
        <trans-unit id="4ca7401582c91e911d7f14741ffa269af2ed6e2a" translate="yes" xml:space="preserve">
          <source>After a feature release, the integration branch &lt;code&gt;next&lt;/code&gt; may optionally be rewound and rebuilt from the tip of &lt;code&gt;master&lt;/code&gt; using the surviving topics on &lt;code&gt;next&lt;/code&gt;:</source>
          <target state="translated">在发布功能之后，可以使用 &lt;code&gt;next&lt;/code&gt; 上尚存的主题从 &lt;code&gt;master&lt;/code&gt; 的尖端重新集成并重新构建 &lt;code&gt;next&lt;/code&gt; 集成分支：</target>
        </trans-unit>
        <trans-unit id="1ee4d8fb94bffa7e70baa538f9ff73a2b240bae8" translate="yes" xml:space="preserve">
          <source>After a feature release, you need to manage your maintenance branches.</source>
          <target state="translated">功能发布后,你需要管理你的维护分支。</target>
        </trans-unit>
        <trans-unit id="745f4d981edc1fae67ad7a65eae4ba7b48a51d0c" translate="yes" xml:space="preserve">
          <source>After a merge (initiated by &lt;code&gt;git merge&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt;) stops because of conflicts, cleanly merged paths are already staged to be committed for you, and paths that conflicted are left in unmerged state. You would have to first check which paths are conflicting with &lt;code&gt;git status&lt;/code&gt; and after fixing them manually in your working tree, you would stage the result as usual with &lt;code&gt;git add&lt;/code&gt;:</source>
          <target state="translated">由于冲突而导致的合并（由 &lt;code&gt;git merge&lt;/code&gt; 或 &lt;code&gt;git pull&lt;/code&gt; 发起）停止后，干净合并的路径已经准备好为您提交，而冲突的路径则处于未合并状态。您必须首先检查哪些路径与 &lt;code&gt;git status&lt;/code&gt; 冲突，并在您的工作树中手动修复它们后，将像往常一样使用 &lt;code&gt;git add&lt;/code&gt; 暂存结果：</target>
        </trans-unit>
        <trans-unit id="10502b7e8b48a8dee46e24b2019e9f5e468162f8" translate="yes" xml:space="preserve">
          <source>After a patch failure (e.g. attempting to apply conflicting patch), the user has applied it by hand and the index file stores the result of the application. Make a commit using the authorship and commit log extracted from the e-mail message and the current index file, and continue.</source>
          <target state="translated">补丁失败后(如尝试应用冲突的补丁),用户已手工应用,索引文件存储了应用的结果。使用从邮件信息和当前索引文件中提取的作者和提交日志进行提交,然后继续。</target>
        </trans-unit>
        <trans-unit id="5aad77091cab70cb7dbe8f7ee76657f4f26524af" translate="yes" xml:space="preserve">
          <source>After a path matches any non-exclude pathspec, it will be run through all exclude pathspecs (magic signature: &lt;code&gt;!&lt;/code&gt; or its synonym &lt;code&gt;^&lt;/code&gt;). If it matches, the path is ignored. When there is no non-exclude pathspec, the exclusion is applied to the result set as if invoked without any pathspec.</source>
          <target state="translated">路径匹配任何非排除路径规范后，它将通过所有排除路径规范运行（魔术签名： &lt;code&gt;!&lt;/code&gt; 或其同义词 &lt;code&gt;^&lt;/code&gt; ）。如果匹配，则忽略该路径。如果没有非排除路径规范，则排除将应用于结果集，就像在没有任何路径规范的情况下调用一样。</target>
        </trans-unit>
        <trans-unit id="e532f3552d5348fdc5f1bdf8915328d4f66e0e76" translate="yes" xml:space="preserve">
          <source>After a successful merge, update the files in the work tree with the result of the merge.</source>
          <target state="translated">合并成功后,用合并的结果更新工作树中的文件。</target>
        </trans-unit>
        <trans-unit id="f915a9b6a0d7dfb5ab76e6778aa20c487e2e4897" translate="yes" xml:space="preserve">
          <source>After a while, you will have a number of branches, and despite the well chosen names you picked for each of them, you may forget what they are for, or what status they are in. To get a reminder of what changes are in a specific branch, use:</source>
          <target state="translated">一段时间后,你会有很多分支,尽管你为每个分支选了很好的名字,但你可能会忘记它们是做什么用的,或者它们处于什么状态。要想提醒你某个特定分支有什么变化,请使用。</target>
        </trans-unit>
        <trans-unit id="a21e19052101e64abbac6635b64126db7893d400" translate="yes" xml:space="preserve">
          <source>After about 13 tests (in this case), it will output the commit id of the guilty commit. You can then examine the commit with &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, find out who wrote it, and mail them your bug report with the commit id. Finally, run</source>
          <target state="translated">经过大约13次测试（在这种情况下），它将输出有罪提交的提交ID。然后，您可以使用&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;来检查提交，找出是谁编写的，然后将带有提交ID的错误报告发送给他们。最后跑</target>
        </trans-unit>
        <trans-unit id="39d63924c0ad3d41ed7256461fb0f8cabfcd6c6b" translate="yes" xml:space="preserve">
          <source>After all other processing, if at least one ref was updated, and if $GIT_DIR/hooks/post-update file exists and is executable, then post-update will be called with the list of refs that have been updated. This can be used to implement any repository wide cleanup tasks.</source>
          <target state="translated">在所有其他处理之后,如果至少有一个 ref 被更新,并且如果 $GIT_DIR/hooks/post-update 文件存在并且是可执行的,那么 post-update 将会被调用,其中包含已经更新的 ref 的列表。这可以用来实现任何版本库范围内的清理任务。</target>
        </trans-unit>
        <trans-unit id="63a0e4603dcf967bd9664f6f3fe860af10658058" translate="yes" xml:space="preserve">
          <source>After all refs were updated (or attempted to be updated), if any ref update was successful, and if $GIT_DIR/hooks/post-receive file exists and is executable, it will be invoked once with no parameters. The standard input of the hook will be one line for each successfully updated ref:</source>
          <target state="translated">在所有 refs 被更新(或试图更新)后,如果任何 ref 更新成功,并且如果 $GIT_DIR/hooks/post-receive 文件存在并且可执行,它将被调用一次,没有参数。钩子的标准输入将是每一个成功更新的 ref 的一行。</target>
        </trans-unit>
        <trans-unit id="df214f68fd91640cff1f194bcc254ff88f0793ee" translate="yes" xml:space="preserve">
          <source>After an attempt to merge stops with conflicts, show the commits on the history between two branches (i.e. the HEAD and the MERGE_HEAD) that modify the conflicted files and do not exist on all the heads being merged.</source>
          <target state="translated">在一次尝试合并因冲突而停止后,在历史记录上显示两个分支(即head和merge_head)之间修改冲突文件的提交,并且不存在于所有被合并的head上。</target>
        </trans-unit>
        <trans-unit id="6855a297433d6efa583ee53f54f77288a36a4a3c" translate="yes" xml:space="preserve">
          <source>After committing, do not rebase or reset.</source>
          <target state="translated">提交后,请勿重垒或重置。</target>
        </trans-unit>
        <trans-unit id="a6cb6cc7533103000a5b985188fd777c705ca2f2" translate="yes" xml:space="preserve">
          <source>After configuring the remote, the following three commands will do the same thing:</source>
          <target state="translated">配置好遥控器后,下面的三个命令也会做同样的事情。</target>
        </trans-unit>
        <trans-unit id="38c4cb5f4b09781b6323bee4b2e059f8adaf4c9f" translate="yes" xml:space="preserve">
          <source>After creating a packfile, print a line of data to &amp;lt;file&amp;gt; listing the filename of the packfile and the last commit on each branch that was written to that packfile. This information may be useful after importing projects whose total object set exceeds the 4 GiB packfile limit, as these commits can be used as edge points during calls to &lt;code&gt;git pack-objects&lt;/code&gt;.</source>
          <target state="translated">创建一个打包文件后，将数据行打印到&amp;lt;file&amp;gt;，列出打包文件的文件名以及写入该打包文件的每个分支上的最后一次提交。导入总对象集超过4 GiB packfile限制的项目后，此信息可能很有用，因为这些提交可以在调用 &lt;code&gt;git pack-objects&lt;/code&gt; 期间用作边缘点。</target>
        </trans-unit>
        <trans-unit id="7eb0f12cc4760d99513845842d5818989334b063" translate="yes" xml:space="preserve">
          <source>After creating commits on a local branch, update the remote branch with your commits:</source>
          <target state="translated">在本地分支上创建提交后,用你的提交更新远程分支。</target>
        </trans-unit>
        <trans-unit id="d35d26dae79ab6ed7b967d8dc4249bb1ae7ac970" translate="yes" xml:space="preserve">
          <source>After deciding the fate for all hunks, if there is any hunk that was chosen, the index is updated with the selected hunks.</source>
          <target state="translated">在决定了所有hunks的命运后,如果有任何hunks被选中,索引就会与被选中的hunks一起更新。</target>
        </trans-unit>
        <trans-unit id="1e8e9a912ee46d43880271748ff8431413ab88e6" translate="yes" xml:space="preserve">
          <source>After each line that describes a file, add more data about its cache entry. This is intended to show as much information as possible for manual inspection; the exact format may change at any time.</source>
          <target state="translated">在描述文件的每一行之后,添加更多关于其缓存条目的数据。这样做的目的是为了显示尽可能多的信息,以便于人工检查;确切的格式可能随时改变。</target>
        </trans-unit>
        <trans-unit id="8e22ef2eb3af8a0d0bd459bef01ed36acc704c46" translate="yes" xml:space="preserve">
          <source>After each step you can verify that</source>
          <target state="translated">在每个步骤之后,您可以验证</target>
        </trans-unit>
        <trans-unit id="715ed76b18490d22ccb88eb785651c8c2059a4a7" translate="yes" xml:space="preserve">
          <source>After editing the p4 change message, &lt;code&gt;git p4&lt;/code&gt; makes sure that the description really was changed by looking at the file modification time. This option disables that test.</source>
          <target state="translated">编辑p4更改消息后， &lt;code&gt;git p4&lt;/code&gt; 通过查看文件修改时间来确保描述确实被更改。此选项禁用该测试。</target>
        </trans-unit>
        <trans-unit id="efcca15ec51efe3416c95ceb171efbcf6537ffe0" translate="yes" xml:space="preserve">
          <source>After examining those changes, Alice could merge the changes into her master branch:</source>
          <target state="translated">在研究了这些变化之后,爱丽丝就可以将这些变化合并到她的主枝中。</target>
        </trans-unit>
        <trans-unit id="6432877f7b94f7bff8d7c5100d32a9aa8ff2a2de" translate="yes" xml:space="preserve">
          <source>After fast-import terminates the frontend will need to do &lt;code&gt;rm .git/TAG_FIXUP&lt;/code&gt; to remove the dummy branch.</source>
          <target state="translated">快速导入终止后，前端将需要执行 &lt;code&gt;rm .git/TAG_FIXUP&lt;/code&gt; 删除虚拟分支。</target>
        </trans-unit>
        <trans-unit id="7ccac6fd0d710a221bb8914388317ad9efd2c0ef" translate="yes" xml:space="preserve">
          <source>After finding out a common ancestor commit, the second step is this:</source>
          <target state="translated">找出共同的祖先犯后,第二步就是这样。</target>
        </trans-unit>
        <trans-unit id="a0f8226e38e0606c48953eb6013c6b55022869a5" translate="yes" xml:space="preserve">
          <source>After having marked revisions as good or bad, issue the following command to show what has been done so far:</source>
          <target state="translated">在将修订标记为好或坏之后,发出以下命令来显示到目前为止所做的事情。</target>
        </trans-unit>
        <trans-unit id="e71b173e36cfeb3adc5bac23b7ebbe3f932f83d8" translate="yes" xml:space="preserve">
          <source>After importing the stream, you can then run &lt;code&gt;git rev-list foo -- bar.c&lt;/code&gt; in the anonymized repository.</source>
          <target state="translated">导入流后，您可以在匿名存储库中运行 &lt;code&gt;git rev-list foo -- bar.c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e80bd551ece50cfc5fc850da2031735d0adb9a3e" translate="yes" xml:space="preserve">
          <source>After inspecting the result of the merge, you may find that the change in the other branch is unsatisfactory. Running &lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; will let you go back to where you were, but it will discard your local changes, which you do not want. &lt;code&gt;git reset --merge&lt;/code&gt; keeps your local changes.</source>
          <target state="translated">在检查合并结果之后，您可能会发现另一个分支中的更改不令人满意。运行 &lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; 将使您返回到原来的位置，但是它将丢弃您不需要的本地更改。 &lt;code&gt;git reset --merge&lt;/code&gt; 保留您的本地更改。</target>
        </trans-unit>
        <trans-unit id="6ff21b83188a31a6207ce191dc61f50a691f861b" translate="yes" xml:space="preserve">
          <source>After inspecting what Bob did, if there is nothing urgent, Alice may decide to continue working without pulling from Bob. If Bob&amp;rsquo;s history does have something Alice would immediately need, Alice may choose to stash her work-in-progress first, do a &quot;pull&quot;, and then finally unstash her work-in-progress on top of the resulting history.</source>
          <target state="translated">在检查了鲍勃所做的事情之后，如果没有紧急情况，爱丽丝可以决定继续工作，而无需离开鲍勃。如果Bob的历史记录确实有Alice急需的东西，Alice可以选择先隐藏她的在制品，进行&amp;ldquo;拉动&amp;rdquo;，然后最后在所得的历史记录上隐藏她的在制品。</target>
        </trans-unit>
        <trans-unit id="03d5abbf7626dec9ccf7afab1dc07b8795265376" translate="yes" xml:space="preserve">
          <source>After making the selection, answer with an empty line to stage the contents of working tree files for selected paths in the index.</source>
          <target state="translated">在进行选择后,用空行回答,将索引中选定路径的工作树文件内容分期。</target>
        </trans-unit>
        <trans-unit id="dcd3f26f69bbd1d1c0b392e2f4a4b9463da76a66" translate="yes" xml:space="preserve">
          <source>After packing, if the newly created packs make some existing packs redundant, remove the redundant packs. Also run &lt;code&gt;git prune-packed&lt;/code&gt; to remove redundant loose object files.</source>
          <target state="translated">打包后，如果新创建的包使某些现有包变得多余，请删除冗余包。还要运行 &lt;code&gt;git prune-packed&lt;/code&gt; 来删除多余的松散对象文件。</target>
        </trans-unit>
        <trans-unit id="6310edfcb7521ec31d9b130cb6ae6f20fea23aff" translate="yes" xml:space="preserve">
          <source>After performing a merge, the original file with conflict markers can be saved as a file with a &lt;code&gt;.orig&lt;/code&gt; extension. If this variable is set to &lt;code&gt;false&lt;/code&gt; then this file is not preserved. Defaults to &lt;code&gt;true&lt;/code&gt; (i.e. keep the backup files).</source>
          <target state="translated">执行合并后，带有冲突标记的原始文件可以另存为扩展名为 &lt;code&gt;.orig&lt;/code&gt; 的文件。如果将此变量设置为 &lt;code&gt;false&lt;/code&gt; ,则不会保留该文件。默认为 &lt;code&gt;true&lt;/code&gt; （即保留备份文件）。</target>
        </trans-unit>
        <trans-unit id="df243e176ddfa0cca8db617f9402400e5f7c60ba" translate="yes" xml:space="preserve">
          <source>After pushing your work to &lt;code&gt;mytree&lt;/code&gt;, you can use &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull[1]&lt;/a&gt; to prepare a &quot;please pull&quot; request message to send to Linus:</source>
          <target state="translated">将工作推送到 &lt;code&gt;mytree&lt;/code&gt; 后，可以使用&lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull [1]&lt;/a&gt;准备&amp;ldquo;请拉&amp;rdquo;请求消息以发送到Linus：</target>
        </trans-unit>
        <trans-unit id="8b7b502730a3874da935b609ad110273aca4a8d0" translate="yes" xml:space="preserve">
          <source>After receiving the capability advertisement, a client can then issue a request to select the command it wants with any particular capabilities or arguments. There is then an optional section where the client can provide any command specific parameters or queries. Only a single command can be requested at a time.</source>
          <target state="translated">在收到能力广告后,客户端可以发出请求,选择它想要的带有任何特定能力或参数的命令。然后有一个可选的部分,客户端可以提供任何命令的特定参数或查询。每次只能请求一个命令。</target>
        </trans-unit>
        <trans-unit id="d906effb7cd99af8f81c132d80d9dfe4320f7472" translate="yes" xml:space="preserve">
          <source>After receiving the pack from the client, &lt;code&gt;receive-pack&lt;/code&gt; may produce no output (if &lt;code&gt;--quiet&lt;/code&gt; was specified) while processing the pack, causing some networks to drop the TCP connection. With this option set, if &lt;code&gt;receive-pack&lt;/code&gt; does not transmit any data in this phase for &lt;code&gt;receive.keepAlive&lt;/code&gt; seconds, it will send a short keepalive packet. The default is 5 seconds; set to 0 to disable keepalives entirely.</source>
          <target state="translated">从客户端 &lt;code&gt;receive-pack&lt;/code&gt; ，receive-pack在处理数据包时可能不会产生任何输出（如果指定了 &lt;code&gt;--quiet&lt;/code&gt; ），从而导致某些网络断开TCP连接。设置此选项后，如果 &lt;code&gt;receive-pack&lt;/code&gt; 在此阶段在 &lt;code&gt;receive.keepAlive&lt;/code&gt; 秒内未传输任何数据，它将发送一个简短的keepalive数据包。默认值为5秒；设置为0可完全禁用Keepalive。</target>
        </trans-unit>
        <trans-unit id="0db356d4df77c5c16acb15ad22a97c7ea6f2c6df" translate="yes" xml:space="preserve">
          <source>After resolving conflicts and staging the result, &lt;code&gt;git ls-files -u&lt;/code&gt; would stop mentioning the conflicted path. When you are done, run &lt;code&gt;git commit&lt;/code&gt; to finally record the merge:</source>
          <target state="translated">解决冲突并暂存结果后， &lt;code&gt;git ls-files -u&lt;/code&gt; 将停止提及冲突路径。完成后，运行 &lt;code&gt;git commit&lt;/code&gt; 最终记录合并：</target>
        </trans-unit>
        <trans-unit id="8c30281e1be411a0e33e0f09c24d7eee56dd1d4d" translate="yes" xml:space="preserve">
          <source>After resolving the conflict in the obvious way (but before updating the index), the diff will look like:</source>
          <target state="translated">在用明显的方法解决冲突后(但在更新索引之前),diff会变成这样。</target>
        </trans-unit>
        <trans-unit id="60011229c2b6e9f4d0205ce31a17f85a92fcdccf" translate="yes" xml:space="preserve">
          <source>After resolving the conflict manually and updating the index with the desired resolution, you can continue the rebasing process with</source>
          <target state="translated">在手动解决冲突并以所需的解决方案更新索引后,您可以继续使用以下方法进行重基过程</target>
        </trans-unit>
        <trans-unit id="4f17f667d528a937d15361797e46f1a4fea1bdf2" translate="yes" xml:space="preserve">
          <source>After rewinding, the commit structure should look like this:</source>
          <target state="translated">回卷后,提交结构应该是这样的。</target>
        </trans-unit>
        <trans-unit id="b66a5176477ad671c21413d345a1019b22e18ec7" translate="yes" xml:space="preserve">
          <source>After running &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; to update the index entry, you can use &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt; to check the contents out of the index to the working tree. Alternatively, using &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt; and specifying a commit with &lt;code&gt;--source&lt;/code&gt;, you can copy the contents of a path out of a commit to the index and to the working tree in one go.</source>
          <target state="translated">运行 &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; 更新索引条目后，可以使用&lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt;将索引中的内容检出到工作树中。或者，使用&lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt;并使用 &lt;code&gt;--source&lt;/code&gt; 指定提交，您可以一次性将路径内容从提交复制到索引和工作树。</target>
        </trans-unit>
        <trans-unit id="18afdf4deff269ec9f25d6d6aebe21c179f08972" translate="yes" xml:space="preserve">
          <source>After running this &lt;code&gt;git push&lt;/code&gt; on the &lt;code&gt;satellite&lt;/code&gt; machine, you would ssh into the &lt;code&gt;mothership&lt;/code&gt; and run &lt;code&gt;git merge&lt;/code&gt; there to complete the emulation of &lt;code&gt;git pull&lt;/code&gt; that were run on &lt;code&gt;mothership&lt;/code&gt; to pull changes made on &lt;code&gt;satellite&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;satellite&lt;/code&gt; 计算机上运行此 &lt;code&gt;git push&lt;/code&gt; 之后，您将ssh进入 &lt;code&gt;mothership&lt;/code&gt; 并在其中运行 &lt;code&gt;git merge&lt;/code&gt; 来完成对在 &lt;code&gt;mothership&lt;/code&gt; 上运行的 &lt;code&gt;git pull&lt;/code&gt; 的仿真，以提取对 &lt;code&gt;satellite&lt;/code&gt; 所做的更改。</target>
        </trans-unit>
        <trans-unit id="de248d3c434336170b313b4a606fae76271119ac" translate="yes" xml:space="preserve">
          <source>After seeing a conflict, you can do two things:</source>
          <target state="translated">看到冲突后,你可以做两件事。</target>
        </trans-unit>
        <trans-unit id="f8a8b60b2d146b020baf249114d8bfb4056df2e3" translate="yes" xml:space="preserve">
          <source>After specifying --relative-marks the paths specified with --import-marks= and --export-marks= are relative to an internal directory in the current repository. In git-fast-import this means that the paths are relative to the .git/info/fast-import directory. However, other importers may use a different location.</source>
          <target state="translated">在指定--relative-marks之后,用--import-marks=和--export-marks=指定的路径是相对于当前版本库的内部目录的。在 git-fast-import 中,这意味着这些路径是相对于 .git/info/fast-import 目录的。然而,其他的导入器可能会使用不同的位置。</target>
        </trans-unit>
        <trans-unit id="55c65fc108282e758fad76a3e65ea8f48110fd1a" translate="yes" xml:space="preserve">
          <source>After staging changes to many files, you can alter the order the changes are recorded in, by giving pathnames to &lt;code&gt;git commit&lt;/code&gt;. When pathnames are given, the command makes a commit that only records the changes made to the named paths:</source>
          <target state="translated">在对许多文件进行更改后，可以通过为 &lt;code&gt;git commit&lt;/code&gt; 提供路径名来更改更改的记录顺序。给定路径名后，该命令将仅记录对命名路径所做的更改：</target>
        </trans-unit>
        <trans-unit id="e72be6c76fa86af29190b1a1f88fe08f999420ad" translate="yes" xml:space="preserve">
          <source>After step 7) (in the skip algorithm), we could check if the second commit has been skipped and return it if it is not the case. And in fact that was the algorithm we used from when &quot;git bisect skip&quot; was developed in Git version 1.5.4 (released on February 1st 2008) until Git version 1.6.4 (released July 29th 2009).</source>
          <target state="translated">在步骤7)(跳过算法中)之后,我们可以检查第二个提交是否被跳过,如果没有被跳过就返回。事实上,从Git 1.5.4版本(2008年2月1日发布)到Git 1.6.4版本(2009年7月29日发布),我们一直使用的就是这个算法。</target>
        </trans-unit>
        <trans-unit id="8ebae7c6dbdbd052d8e1deddf2741dfd39e2c5b6" translate="yes" xml:space="preserve">
          <source>After submitting, sync this named branch instead of the default p4/master. See the &quot;Sync options&quot; section above for more information.</source>
          <target state="translated">提交后,同步这个命名的分支,而不是默认的p4/master。更多信息请参见上面的 &quot;同步选项 &quot;部分。</target>
        </trans-unit>
        <trans-unit id="56b0b049063f0a3e5fb48dd65396ec13b42da44e" translate="yes" xml:space="preserve">
          <source>After that is done, you should be able to compose email as you otherwise would (cut + paste, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt;, etc), and the patches will not be mangled.</source>
          <target state="translated">完成之后，您应该能够像其他方式一样撰写电子邮件（剪切+粘贴， &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt; 等），并且补丁不会被破坏。</target>
        </trans-unit>
        <trans-unit id="bfac36870999dd7fd482f2000fa5fc0ffd3ce594" translate="yes" xml:space="preserve">
          <source>After that you can start bisecting as usual in the new branch and you should eventually find the first bad commit.</source>
          <target state="translated">之后,你就可以像往常一样在新的分支中开始进行二分法,最终你应该会找到第一个坏的提交。</target>
        </trans-unit>
        <trans-unit id="35f073b8aaf7a7d573c425aa250957facb3adf5b" translate="yes" xml:space="preserve">
          <source>After that, the easiest way to record all removals, additions, and modifications in the working tree is:</source>
          <target state="translated">之后,记录工作树中所有删除、添加和修改的最简单的方法就是。</target>
        </trans-unit>
        <trans-unit id="37ec20c881539f18de6028bfbfa7896bacec3155" translate="yes" xml:space="preserve">
          <source>After that, you can go back to what you were working on with &lt;code&gt;git stash pop&lt;/code&gt;:</source>
          <target state="translated">之后，您可以回到使用 &lt;code&gt;git stash pop&lt;/code&gt; 进行的工作：</target>
        </trans-unit>
        <trans-unit id="a18484e36aeec06b4dafe8bfc4dc2214df9ad775" translate="yes" xml:space="preserve">
          <source>After the basics are established, additional command information can be sent to Trace2 as it is discovered.</source>
          <target state="translated">在基础知识建立后,可以根据发现的情况向Trace2发送其他命令信息。</target>
        </trans-unit>
        <trans-unit id="9e00cd4b44746238e1913ce6a929735926105a52" translate="yes" xml:space="preserve">
          <source>After the clone is created, initialize and clone submodules within based on the provided pathspec. If no pathspec is provided, all submodules are initialized and cloned. This option can be given multiple times for pathspecs consisting of multiple entries. The resulting clone has &lt;code&gt;submodule.active&lt;/code&gt; set to the provided pathspec, or &quot;.&quot; (meaning all submodules) if no pathspec is provided.</source>
          <target state="translated">创建克隆后，根据提供的pathspec初始化并克隆其中的子模块。如果未提供pathspec，则将初始化并克隆所有子模块。对于由多个条目组成的路径规范，可以多次赋予此选项。所得克隆的 &lt;code&gt;submodule.active&lt;/code&gt; 设置为提供的pathspec或&amp;ldquo;。&amp;rdquo;。（表示所有子模块）（如果未提供pathspec）。</target>
        </trans-unit>
        <trans-unit id="512c768beb6f564041f676bad06ef4ee2a1c558f" translate="yes" xml:space="preserve">
          <source>After the clone, a plain &lt;code&gt;git fetch&lt;/code&gt; without arguments will update all the remote-tracking branches, and a &lt;code&gt;git pull&lt;/code&gt; without arguments will in addition merge the remote master branch into the current master branch, if any (this is untrue when &quot;--single-branch&quot; is given; see below).</source>
          <target state="translated">克隆之后，不带参数的纯 &lt;code&gt;git fetch&lt;/code&gt; 将更新所有远程跟踪分支，并且不带参数的 &lt;code&gt;git pull&lt;/code&gt; 将另外将远程master分支合并到当前的master分支中（如果有的话，这是不正确的（当&amp;ldquo; --single -branch&amp;rdquo;；请参见下文）。</target>
        </trans-unit>
        <trans-unit id="5cd7d7a65c5ebccd7e68c5c66967ea09b43d6139" translate="yes" xml:space="preserve">
          <source>After the last section, you should know how to manage topics. In general, you will not be the only person working on the project, so you will have to share your work.</source>
          <target state="translated">经过上一节的学习,你应该知道如何管理课题了。一般来说,你不会是唯一一个在项目中工作的人,所以你必须分享你的工作。</target>
        </trans-unit>
        <trans-unit id="d4845263a9667982d51c2722039eed2001af73b3" translate="yes" xml:space="preserve">
          <source>After this test merge, there are two ways to continue your work on the topic. The easiest is to build on top of the test merge commit &lt;code&gt;+&lt;/code&gt;, and when your work in the topic branch is finally ready, pull the topic branch into master, and/or ask the upstream to pull from you. By that time, however, the master or the upstream might have been advanced since the test merge &lt;code&gt;+&lt;/code&gt;, in which case the final commit graph would look like this:</source>
          <target state="translated">在此测试合并之后，有两种方法可以继续进行该主题的工作。最简单的方法是在测试合并commit &lt;code&gt;+&lt;/code&gt; 的基础上构建，并且当您在主题分支中的工作终于准备就绪时，将主题分支拉入master，和/或要求上游从您那里拉出。但是，到那时，从test merge &lt;code&gt;+&lt;/code&gt; 开始，可能已经对master或上游进行了升级，在这种情况下，最终提交图将如下所示：</target>
        </trans-unit>
        <trans-unit id="764e78b04901ecf447ad9f08fb14a4d7a3784873" translate="yes" xml:space="preserve">
          <source>After this three-way merge, the local modifications are &lt;code&gt;not&lt;/code&gt; registered in your index file, so &lt;code&gt;git diff&lt;/code&gt; would show you what changes you made since the tip of the new branch.</source>
          <target state="translated">在这种三向合并之后，本地修改 &lt;code&gt;not&lt;/code&gt; 在索引文件中注册，因此 &lt;code&gt;git diff&lt;/code&gt; 将向您显示自新分支的尖端以来所做的更改。</target>
        </trans-unit>
        <trans-unit id="9aab9481201d40d0fe77311ee6889968b015c0cc" translate="yes" xml:space="preserve">
          <source>After verifying the pack, show list of objects contained in the pack and a histogram of delta chain length.</source>
          <target state="translated">验证包后,显示包中包含的对象列表和三角链长度的直方图。</target>
        </trans-unit>
        <trans-unit id="9b8cdc248305abd7fd3ad025c5cea93360a62f47" translate="yes" xml:space="preserve">
          <source>After working in the wrong branch, switching to the correct branch would be done using:</source>
          <target state="translated">在错误的分支中工作后,切换到正确的分支将使用。</target>
        </trans-unit>
        <trans-unit id="eb228e2496a61023caca1aea4a6e82c2396eddae" translate="yes" xml:space="preserve">
          <source>After working on the &lt;code&gt;topic&lt;/code&gt; branch created with &lt;code&gt;git switch -c
topic origin/master&lt;/code&gt;, the history of remote-tracking branch &lt;code&gt;origin/master&lt;/code&gt; may have been rewound and rebuilt, leading to a history of this shape:</source>
          <target state="translated">在使用 &lt;code&gt;git switch -c topic origin/master&lt;/code&gt; 创建的 &lt;code&gt;topic&lt;/code&gt; 分支上进行工作之后，远程跟踪分支 &lt;code&gt;origin/master&lt;/code&gt; 的历史记录可能已经被重新记录和重建，从而形成了这种形状的历史记录：</target>
        </trans-unit>
        <trans-unit id="1c12d864e4ce5bf45abb0028f5de0df25bacff49" translate="yes" xml:space="preserve">
          <source>After working some more in the original repository, you can create an incremental bundle to update the other repository:</source>
          <target state="translated">在原版本库中再工作一段时间后,你可以创建一个增量捆绑来更新其他版本库。</target>
        </trans-unit>
        <trans-unit id="7c5cdbcbfaa82437e4a65c5f716c041276984b11" translate="yes" xml:space="preserve">
          <source>After writing a crash report fast-import will close the current packfile and export the marks table. This allows the frontend developer to inspect the repository state and resume the import from the point where it crashed. The modified branches and tags are not updated during a crash, as the import did not complete successfully. Branch and tag information can be found in the crash report and must be applied manually if the update is needed.</source>
          <target state="translated">写完崩溃报告后,fast-import会关闭当前的packfile,并导出标记表。这允许前台开发者检查仓库状态,并从崩溃的地方恢复导入。在崩溃期间,修改的分支和标记不会更新,因为导入没有成功完成。分支和标签信息可以在崩溃报告中找到,如果需要更新,必须手动应用。</target>
        </trans-unit>
        <trans-unit id="5c0e0972bba351246b0cebcda509c3b6e9fe7def" translate="yes" xml:space="preserve">
          <source>After you clone a repository and commit a few changes of your own, you may wish to check the original repository for updates and merge them into your own work.</source>
          <target state="translated">当你克隆了一个版本库并提交了一些你自己的修改后,你可能希望检查原始版本库的更新并将它们合并到你自己的工作中。</target>
        </trans-unit>
        <trans-unit id="11b2964f5fca0a040b3f9e0cd2999fe0e6cf0437" translate="yes" xml:space="preserve">
          <source>After you clone a repository and commit a few changes of your own, you may wish to check the original repository for updates.</source>
          <target state="translated">当你克隆了一个版本库并提交了一些你自己的修改后,你可能希望检查原始版本库的更新。</target>
        </trans-unit>
        <trans-unit id="5c1b426ddf419243558839a9a55a74c0218324ad" translate="yes" xml:space="preserve">
          <source>After you mastered the basic concepts, you can come back to this page to learn what commands Git offers. You can learn more about individual Git commands with &quot;git help command&quot;. &lt;a href=&quot;gitcli&quot;&gt;gitcli[7]&lt;/a&gt; manual page gives you an overview of the command-line command syntax.</source>
          <target state="translated">掌握了基本概念之后，您可以返回此页面来学习Git提供的命令。您可以使用&amp;ldquo; git help命令&amp;rdquo;了解有关单个Git命令的更多信息。&lt;a href=&quot;gitcli&quot;&gt;gitcli [7]&lt;/a&gt;手册页为您提供了命令行命令语法的概述。</target>
        </trans-unit>
        <trans-unit id="b3cf4e045979c169751c6df0015d31c55a03d7ee" translate="yes" xml:space="preserve">
          <source>After you&amp;rsquo;re done, start up &lt;code&gt;gitk --all&lt;/code&gt; to see graphically what the history looks like. Notice that &lt;code&gt;mybranch&lt;/code&gt; still exists, and you can switch to it, and continue to work with it if you want to. The &lt;code&gt;mybranch&lt;/code&gt; branch will not contain the merge, but next time you merge it from the &lt;code&gt;master&lt;/code&gt; branch, Git will know how you merged it, so you&amp;rsquo;ll not have to do &lt;code&gt;that&lt;/code&gt; merge again.</source>
          <target state="translated">完成后，启动 &lt;code&gt;gitk --all&lt;/code&gt; 以图形方式查看历史记录。请注意， &lt;code&gt;mybranch&lt;/code&gt; 仍然存在，您可以切换到它，并根据需要继续使用它。该 &lt;code&gt;mybranch&lt;/code&gt; 分支将不包含合并，但下次你从合并它的时间 &lt;code&gt;master&lt;/code&gt; 分支，Git会知道你是怎么融合它，所以你不必这样做 &lt;code&gt;that&lt;/code&gt; 再合并。</target>
        </trans-unit>
        <trans-unit id="c0a021ce8c26fc96dbae55d24cd95f42b33ecba6" translate="yes" xml:space="preserve">
          <source>Afterwards Git sends a list of &quot;key=value&quot; pairs terminated with a flush packet. The list will contain at least the filter command (based on the supported capabilities) and the pathname of the file to filter relative to the repository root. Right after the flush packet Git sends the content split in zero or more pkt-line packets and a flush packet to terminate content. Please note, that the filter must not send any response before it received the content and the final flush packet. Also note that the &quot;value&quot; of a &quot;key=value&quot; pair can contain the &quot;=&quot; character whereas the key would never contain that character.</source>
          <target state="translated">之后,Git会发送一个 &quot;key=value &quot;对的列表,并以刷新包结束。列表中至少会包含 filter 命令(基于支持的能力)和相对于仓库根目录的要过滤的文件路径名。就在刷新包之后,Git会将内容分成零个或多个pkt-line包和一个刷新包来终止内容。请注意,过滤器在收到内容和最后的flush包之前,一定不能发送任何响应。另外请注意,&quot;key=value &quot;对的 &quot;value &quot;可以包含&quot;=&quot;字符,而key永远不会包含该字符。</target>
        </trans-unit>
        <trans-unit id="08fb4f0b833d93afae381ddbd32b2e731f88bbea" translate="yes" xml:space="preserve">
          <source>Again, because this is a common operation, you can also just shorthand it with</source>
          <target state="translated">同样,因为这是一个常见的操作,你也可以直接用</target>
        </trans-unit>
        <trans-unit id="2a17673033ec7dbc230aa6a7992e711b3fbc3d4a" translate="yes" xml:space="preserve">
          <source>Again, normally you&amp;rsquo;d never actually do this by hand. There is a helpful script called &lt;code&gt;git commit&lt;/code&gt; that will do all of this for you. So you could have just written &lt;code&gt;git commit&lt;/code&gt; instead, and it would have done the above magic scripting for you.</source>
          <target state="translated">同样，通常您实际上不会手动进行此操作。有一个有用的脚本 &lt;code&gt;git commit&lt;/code&gt; ，它将为您完成所有这些工作。因此，您可以改为编写 &lt;code&gt;git commit&lt;/code&gt; ，它会为您完成上述魔术脚本。</target>
        </trans-unit>
        <trans-unit id="afde498ff4cd811d74693c0df59474ecda94165e" translate="yes" xml:space="preserve">
          <source>Again, this can all be simplified with</source>
          <target state="translated">同样,这一切都可以用</target>
        </trans-unit>
        <trans-unit id="b9b1fee6e50d3dc98fed5593a8e8c0ed94635339" translate="yes" xml:space="preserve">
          <source>Again, updating A with this commit will fast-forward and your push will be accepted.</source>
          <target state="translated">同样,用这个提交更新A会快进,你的推送会被接受。</target>
        </trans-unit>
        <trans-unit id="b1bfbc3378c5615b3a3120f32e2b4f7a040c60bb" translate="yes" xml:space="preserve">
          <source>Again, you should never do this to a commit that may already have been merged into another branch; use &lt;a href=&quot;git-revert&quot;&gt;git-revert[1]&lt;/a&gt; instead in that case.</source>
          <target state="translated">同样，永远不要对可能已经合并到另一个分支中的提交执行此操作；在这种情况下，请改用&lt;a href=&quot;git-revert&quot;&gt;git-revert [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ad4cd921bb660f6346bf34bcf03d35af1d89b1f" translate="yes" xml:space="preserve">
          <source>Aggregating short options</source>
          <target state="translated">合并空头期权</target>
        </trans-unit>
        <trans-unit id="b46eb2e49d59fe40f45432cfc2d93b9f3ec1b6f6" translate="yes" xml:space="preserve">
          <source>Aggressive</source>
          <target state="translated">Aggressive</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="f18c0f421eb67bfb50f4d3af9083503fd4868a13" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;--subject-prefix=&quot;RFC PATCH&quot;&lt;/code&gt;. RFC means &quot;Request For Comments&quot;; use this when sending an experimental patch for discussion rather than application.</source>
          <target state="translated">&lt;code&gt;--subject-prefix=&quot;RFC PATCH&quot;&lt;/code&gt; 别名。RFC的意思是&amp;ldquo;请求评论&amp;rdquo;；在发送实验性补丁进行讨论而非应用时使用此功能。</target>
        </trans-unit>
        <trans-unit id="33cafd3b08f6afce156de29f77fc37a32f1f3369" translate="yes" xml:space="preserve">
          <source>Alias for a --pretty= format string, as specified in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;. Any aliases defined here can be used just as the built-in pretty formats could. For example, running &lt;code&gt;git config pretty.changelog &quot;format:* %H %s&quot;&lt;/code&gt; would cause the invocation &lt;code&gt;git log --pretty=changelog&lt;/code&gt; to be equivalent to running &lt;code&gt;git log &quot;--pretty=format:* %H %s&quot;&lt;/code&gt;. Note that an alias with the same name as a built-in format will be silently ignored.</source>
          <target state="translated">--pretty =格式字符串的别名，如&lt;a href=&quot;git-log&quot;&gt;git-log [1]中&lt;/a&gt;所指定。此处定义的任何别名都可以像内置的漂亮格式一样使用。例如，运行 &lt;code&gt;git config pretty.changelog &quot;format:* %H %s&quot;&lt;/code&gt; 将导致调用 &lt;code&gt;git log --pretty=changelog&lt;/code&gt; 等效于运行 &lt;code&gt;git log &quot;--pretty=format:* %H %s&quot;&lt;/code&gt; 。请注意，与内置格式同名的别名将被忽略。</target>
        </trans-unit>
        <trans-unit id="5d1b325e842f25a822c4b269ff141ef39919c475" translate="yes" xml:space="preserve">
          <source>Alice can peek at what Bob did without merging first, using the &quot;fetch&quot; command; this allows Alice to inspect what Bob did, using a special symbol &quot;FETCH_HEAD&quot;, in order to determine if he has anything worth pulling, like this:</source>
          <target state="translated">爱丽丝可以在不合并的情况下,先用 &quot;fetch &quot;命令偷看鲍勃做了什么;这样,爱丽丝就可以用一个特殊的符号 &quot;FETCH_HEAD &quot;来检查鲍勃做了什么,以确定他是否有值得拔取的东西,比如这样。</target>
        </trans-unit>
        <trans-unit id="8e66fd3894cd9fabc7340a32ad3678d949571b95" translate="yes" xml:space="preserve">
          <source>Alice may want to view what both of them did since they forked. She can use three-dot form instead of the two-dot form:</source>
          <target state="translated">爱丽丝可能想查看他们两个人既然分叉了做了什么。她可以用三点形式代替两点形式。</target>
        </trans-unit>
        <trans-unit id="f40eaaa16860011566dbddc8353ce4cd5b34fb54" translate="yes" xml:space="preserve">
          <source>All 4-byte numbers are in network order.</source>
          <target state="translated">所有4字节的数字都是按网络顺序排列的。</target>
        </trans-unit>
        <trans-unit id="099269695c58af639142bdae5a91d1e49c0c2c94" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;CGI&lt;/code&gt; environment variables are available to each of the hooks invoked by the &lt;code&gt;git-receive-pack&lt;/code&gt;.</source>
          <target state="translated">所有 &lt;code&gt;CGI&lt;/code&gt; 环境变量对于 &lt;code&gt;git-receive-pack&lt;/code&gt; 调用的每个钩子都是可用的。</target>
        </trans-unit>
        <trans-unit id="f866a82b5ea8dc3929c4ad04564d5c3ed0ee42d8" translate="yes" xml:space="preserve">
          <source>All Trace2 API functions send a message to all of the active Trace2 Targets. This section describes the set of available messages.</source>
          <target state="translated">所有 Trace2 API 函数都会向所有活动的 Trace2 Targets 发送一条消息。本节介绍了一组可用的消息。</target>
        </trans-unit>
        <trans-unit id="8567b1f7f97dea5e233c49b40ba1a9668558e4c8" translate="yes" xml:space="preserve">
          <source>All URLs are normalized before attempting any matching (the password part, if embedded in the URL, is always ignored for matching purposes) so that equivalent URLs that are simply spelled differently will match properly. Environment variable settings always override any matches. The URLs that are matched against are those given directly to Git commands. This means any URLs visited as a result of a redirection do not participate in matching.</source>
          <target state="translated">在尝试任何匹配之前,所有的URL都会被规范化(如果密码部分被嵌入到URL中,那么在匹配时总是会被忽略),因此,仅仅是拼写不同的等价URL将被正确匹配。环境变量设置总是覆盖任何匹配。匹配的URL是那些直接给Git命令的URL。这意味着任何因重定向而访问的 URL 都不参与匹配。</target>
        </trans-unit>
        <trans-unit id="05f6595fa2f42cca20a6fe38ba56a9a1d90610fc" translate="yes" xml:space="preserve">
          <source>All actions except for those that list all available projects, in whatever form, require this parameter.</source>
          <target state="translated">除了以任何形式列出所有可用项目的动作外,所有动作都需要这个参数。</target>
        </trans-unit>
        <trans-unit id="bd0edf3d9b439beeaf5e567024d22155e2273f60" translate="yes" xml:space="preserve">
          <source>All changes already added to the index are left intact.</source>
          <target state="translated">所有已经添加到索引中的变化都保持不变。</target>
        </trans-unit>
        <trans-unit id="1aaff790885e322791dd026d468d21215c97d5ed" translate="yes" xml:space="preserve">
          <source>All changes in the split index are pushed back to the shared index file when the number of entries in the split index reaches a level specified by the splitIndex.maxPercentChange config variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">当拆分索引中的条目数达到splitIndex.maxPercentChange配置变量指定的级别（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）时，拆分索引中的所有更改都将推回到共享索引文件。</target>
        </trans-unit>
        <trans-unit id="2ee4593d03a3fe3f61740d3dea48d16adb304aaa" translate="yes" xml:space="preserve">
          <source>All changes made by commits in the current branch but that are not in &amp;lt;upstream&amp;gt; are saved to a temporary area. This is the same set of commits that would be shown by &lt;code&gt;git log &amp;lt;upstream&amp;gt;..HEAD&lt;/code&gt;; or by &lt;code&gt;git log 'fork_point'..HEAD&lt;/code&gt;, if &lt;code&gt;--fork-point&lt;/code&gt; is active (see the description on &lt;code&gt;--fork-point&lt;/code&gt; below); or by &lt;code&gt;git log HEAD&lt;/code&gt;, if the &lt;code&gt;--root&lt;/code&gt; option is specified.</source>
          <target state="translated">当前分支中的所有提交但未在&amp;lt;upstream&amp;gt;中的所有更改都保存到临时区域。这与 &lt;code&gt;git log &amp;lt;upstream&amp;gt;..HEAD&lt;/code&gt; 将显示的提交集相同。或通过 &lt;code&gt;git log 'fork_point'..HEAD&lt;/code&gt; ，如果 &lt;code&gt;--fork-point&lt;/code&gt; 是活动的（请参阅下面有关 &lt;code&gt;--fork-point&lt;/code&gt; 的描述）；或通过 &lt;code&gt;git log HEAD&lt;/code&gt; ，如果指定了 &lt;code&gt;--root&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="4bdf69f9f9acea0027f5883fae412fef01ef415d" translate="yes" xml:space="preserve">
          <source>All changes to the submodule&amp;rsquo;s work tree will be ignored, only committed differences between the HEAD of the submodule and its recorded state in the superproject are taken into account.</source>
          <target state="translated">子模块的工作树的所有更改都将被忽略，仅考虑子模块的HEAD及其在超级项目中的记录状态之间的已提交差异。</target>
        </trans-unit>
        <trans-unit id="0078bf2eb8fdaed52c7a49142c07f612f6194ca3" translate="yes" xml:space="preserve">
          <source>All commands except clone accept these options.</source>
          <target state="translated">除克隆外,所有命令都接受这些选项。</target>
        </trans-unit>
        <trans-unit id="747ced70d2f3d8a9f580e20c513a115bf4ca8d06" translate="yes" xml:space="preserve">
          <source>All commits in the simplified history are shown.</source>
          <target state="translated">简化历史中的所有提交都会显示。</target>
        </trans-unit>
        <trans-unit id="b7857a43f974cc0cc16fc43991167acda1bdb92d" translate="yes" xml:space="preserve">
          <source>All commits that are walked are included.</source>
          <target state="translated">所有走过的承诺都包括在内。</target>
        </trans-unit>
        <trans-unit id="d8c8c004ab3e327bb23a0e1cb06bdc4ffe16dbfd" translate="yes" xml:space="preserve">
          <source>All communication is done using packet-line framing, just as in v1. See &lt;code&gt;Documentation/technical/pack-protocol.txt&lt;/code&gt; and &lt;code&gt;Documentation/technical/protocol-common.txt&lt;/code&gt; for more information.</source>
          <target state="translated">就像在v1中一样，所有通信都是使用分组线框架完成的。有关更多信息，请参见 &lt;code&gt;Documentation/technical/pack-protocol.txt&lt;/code&gt; 和 &lt;code&gt;Documentation/technical/protocol-common.txt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c3a301219274de5dd57371abee3ab5a5312cbb7" translate="yes" xml:space="preserve">
          <source>All configuration variables can also be overridden for a specific method of access. Valid method names are &quot;ext&quot; (for SSH access) and &quot;pserver&quot;. The following example configuration would disable pserver access while still allowing access over SSH.</source>
          <target state="translated">所有的配置变量也可以被覆盖为特定的访问方法,有效的方法名称是 &quot;ext&quot;(用于SSH访问)和 &quot;pserver&quot;。有效的方法名称是 &quot;ext&quot;(用于SSH访问)和 &quot;pserver&quot;。下面的配置示例将禁用 pserver 访问,同时仍然允许通过 SSH 访问。</target>
        </trans-unit>
        <trans-unit id="59ca4fe2d0fe1a800f4976e6f9f37c5b67ee4941" translate="yes" xml:space="preserve">
          <source>All files from the branching point are added to a branch even if never added in CVS.</source>
          <target state="translated">所有来自分支点的文件都会被添加到分支中,即使从未在CVS中添加。</target>
        </trans-unit>
        <trans-unit id="f2751ce2c6eef82a246aaca1478ee0944abee964" translate="yes" xml:space="preserve">
          <source>All files matching a file extension in the list will be processed by the large file system. Do not prefix the extensions with &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">大型文件系统将处理列表中与文件扩展名匹配的所有文件。不要在扩展名前面加上 &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9eed6a91320d25f6961ad95b2f4c0551182ac97" translate="yes" xml:space="preserve">
          <source>All files with a compressed size exceeding the threshold will be processed by the large file system. This option might slow down your clone/sync process. By default the threshold is defined in bytes. Add the suffix k, m, or g to change the unit.</source>
          <target state="translated">所有压缩大小超过阈值的文件将由大文件系统处理。这个选项可能会减慢您的克隆/同步进程。默认情况下,阈值是以字节为单位定义的。添加后缀k、m或g来更改单位。</target>
        </trans-unit>
        <trans-unit id="cba8238b26241037a2d523c9dbfd57c6ef21fd9c" translate="yes" xml:space="preserve">
          <source>All files with an uncompressed size exceeding the threshold will be processed by the large file system. By default the threshold is defined in bytes. Add the suffix k, m, or g to change the unit.</source>
          <target state="translated">所有未压缩大小超过阈值的文件将由大文件系统处理。默认情况下,阈值是以字节为单位定义的。添加后缀k、m或g来改变单位。</target>
        </trans-unit>
        <trans-unit id="5faba2ec0a1d011ac70519fe6631987cdc41a2b9" translate="yes" xml:space="preserve">
          <source>All gitcvs variables except for &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; and &lt;code&gt;gitcvs.allBinary&lt;/code&gt; can also be specified as &lt;code&gt;gitcvs.&amp;lt;access_method&amp;gt;.&amp;lt;varname&amp;gt;&lt;/code&gt; (where &lt;code&gt;access_method&lt;/code&gt; is one of &quot;ext&quot; and &quot;pserver&quot;) to make them apply only for the given access method.</source>
          <target state="translated">&lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 和 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; 以外的所有gitcvs变量也可以指定为 &lt;code&gt;gitcvs.&amp;lt;access_method&amp;gt;.&amp;lt;varname&amp;gt;&lt;/code&gt; （其中 &lt;code&gt;access_method&lt;/code&gt; 是&amp;ldquo; ext&amp;rdquo;和&amp;ldquo; pserver&amp;rdquo;之一）使它们仅适用于给定的访问方法。</target>
        </trans-unit>
        <trans-unit id="0e525a3897a3668ec85a1e3c0f8de71adbd85c9c" translate="yes" xml:space="preserve">
          <source>All guides...</source>
          <target state="translated">所有指南...</target>
        </trans-unit>
        <trans-unit id="307b90257cb7faef23bf2daa4065fa0e8e567b0e" translate="yes" xml:space="preserve">
          <source>All ignored and untracked files are also stashed and then cleaned up with &lt;code&gt;git clean&lt;/code&gt;.</source>
          <target state="translated">所有被忽略和未跟踪的文件也会被存放，然后用 &lt;code&gt;git clean&lt;/code&gt; 清理。</target>
        </trans-unit>
        <trans-unit id="e0e3bbc643fcf0e6f476c9a1c5f8183263c2a18a" translate="yes" xml:space="preserve">
          <source>All listed refs are deleted from the remote repository. This is the same as prefixing all refs with a colon.</source>
          <target state="translated">所有列出的参考文献都会从远程仓库中删除。这和在所有参考文献前加上冒号是一样的。</target>
        </trans-unit>
        <trans-unit id="0a04df7dc83d3748d4d9902845dfe236dbda3335" translate="yes" xml:space="preserve">
          <source>All objects are named by the SHA-1 hash of their contents, normally written as a string of 40 hex digits. Such names are globally unique. The entire history leading up to a commit can be vouched for by signing just that commit. A fourth object type, the tag, is provided for this purpose.</source>
          <target state="translated">所有对象都以其内容的SHA-1哈希值命名,通常写成一串40个十六进制数字。这样的名字是全球唯一的。提交前的整个历史可以通过签署该提交来证明。为此,我们提供了第四种对象类型--标签。</target>
        </trans-unit>
        <trans-unit id="5c22669562d39ab93b88e8b91c6653478eb31b9b" translate="yes" xml:space="preserve">
          <source>All objects have a statically determined &quot;type&quot; which identifies the format of the object (i.e. how it is used, and how it can refer to other objects). There are currently four different object types: &quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;, and &quot;tag&quot;.</source>
          <target state="translated">所有对象都有一个静态确定的 &quot;类型&quot;,它确定了对象的格式(即如何使用它,以及如何引用其他对象)。目前有四种不同的对象类型。&quot;blob&quot;、&quot;tree&quot;、&quot;commit &quot;和 &quot;tag&quot;。</target>
        </trans-unit>
        <trans-unit id="53b47e1baf96b9c8287456e674d706c2d2cb68d3" translate="yes" xml:space="preserve">
          <source>All of the ancestors of a given &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; are said to be &quot;reachable&quot; from that commit. More generally, one &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; is reachable from another if we can reach the one from the other by a &lt;a href=&quot;#def_chain&quot;&gt;chain&lt;/a&gt; that follows &lt;a href=&quot;#def_tag&quot;&gt;tags&lt;/a&gt; to whatever they tag, &lt;a href=&quot;#def_commit_object&quot;&gt;commits&lt;/a&gt; to their parents or trees, and &lt;a href=&quot;#def_tree_object&quot;&gt;trees&lt;/a&gt; to the trees or &lt;a href=&quot;#def_blob_object&quot;&gt;blobs&lt;/a&gt; that they contain.</source>
          <target state="translated">某个给定&lt;a href=&quot;#def_commit&quot;&gt;提交的&lt;/a&gt;所有祖先都可以从该提交&amp;ldquo;到达&amp;rdquo;。更笼统地说，如果我们可以通过一条&lt;a href=&quot;#def_chain&quot;&gt;链&lt;/a&gt;从另一个&lt;a href=&quot;#def_object&quot;&gt;物体&lt;/a&gt;到达另一个物体，那么该链就可以跟随&lt;a href=&quot;#def_tag&quot;&gt;标签&lt;/a&gt;到标签所标记的内容，&lt;a href=&quot;#def_commit_object&quot;&gt;提交&lt;/a&gt;给它们的父代或树木，以及&lt;a href=&quot;#def_tree_object&quot;&gt;树&lt;/a&gt;到它们所包含的树木或&lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c914353521a7fcdc1482a5e3cfa2c2db891768c9" translate="yes" xml:space="preserve">
          <source>All of the changes that Git was able to merge automatically are already added to the index file, so &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; shows only the conflicts. It uses an unusual syntax:</source>
          <target state="translated">Git能够自动合并的所有更改已经添加到索引文件中，因此&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;仅显示冲突。它使用一种不寻常的语法：</target>
        </trans-unit>
        <trans-unit id="0851367bef62c00e23b203fa9f1e02fbe0c27531" translate="yes" xml:space="preserve">
          <source>All of the following examples map &lt;code&gt;http://$hostname/git/foo/bar.git&lt;/code&gt; to &lt;code&gt;/var/www/git/foo/bar.git&lt;/code&gt;.</source>
          <target state="translated">以下所有示例均将 &lt;code&gt;http://$hostname/git/foo/bar.git&lt;/code&gt; 映射到 &lt;code&gt;/var/www/git/foo/bar.git&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a148afed6f28c8ecd0df018991ec0db90af85d7" translate="yes" xml:space="preserve">
          <source>All of the rules described above about what&amp;rsquo;s not allowed as an update can be overridden by adding an the optional leading &lt;code&gt;+&lt;/code&gt; to a refspec (or using &lt;code&gt;--force&lt;/code&gt; command line option). The only exception to this is that no amount of forcing will make the &lt;code&gt;refs/heads/*&lt;/code&gt; namespace accept a non-commit object. Hooks and configuration can also override or amend these rules, see e.g. &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;code&gt;pre-receive&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; in &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">可以通过在refspec中添加可选的前导 &lt;code&gt;+&lt;/code&gt; （或使用 &lt;code&gt;--force&lt;/code&gt; 命令行选项）来覆盖上述所有有关不允许更新的规则。唯一的例外是没有任何强制将使 &lt;code&gt;refs/heads/*&lt;/code&gt; 名称空间接受非提交对象。钩和配置也可以覆盖或修改这些规则，参见例如 &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; 在&lt;a href=&quot;git-config&quot;&gt;GIT-配置[1]&lt;/a&gt;和 &lt;code&gt;pre-receive&lt;/code&gt; 和 &lt;code&gt;update&lt;/code&gt; 在&lt;a href=&quot;githooks&quot;&gt;githooks [5] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82a27511d4b01630cccb325b4298d897b1527c61" translate="yes" xml:space="preserve">
          <source>All of these also allow you to omit the refspec from the command line because they each contain a refspec which git will use by default.</source>
          <target state="translated">所有这些都允许你在命令行中省略 refspec,因为它们都包含了 git 默认使用的 refspec。</target>
        </trans-unit>
        <trans-unit id="c91f646c685a7dfcf5e56237f918748518206037" translate="yes" xml:space="preserve">
          <source>All of these objects are stored under their SHA-1 names inside the Git directory:</source>
          <target state="translated">所有这些对象都存储在Git目录下的SHA-1名下。</target>
        </trans-unit>
        <trans-unit id="dcd6cc66ca5ed15a438644763fc31848cb788922" translate="yes" xml:space="preserve">
          <source>All of those examples use request rewriting, and need &lt;code&gt;mod_rewrite&lt;/code&gt; (or equivalent; examples below are written for Apache).</source>
          <target state="translated">所有这些示例都使用请求重写，并且需要 &lt;code&gt;mod_rewrite&lt;/code&gt; （或等效命令；以下示例是为Apache编写的）。</target>
        </trans-unit>
        <trans-unit id="555f29027228e8eb9986b68d870b32cd598f6835" translate="yes" xml:space="preserve">
          <source>All offset and size bytes are optional. This is to reduce the instruction size when encoding small offsets or sizes. The first seven bits in the first octet determines which of the next seven octets is present. If bit zero is set, offset1 is present. If bit one is set offset2 is present and so on.</source>
          <target state="translated">所有偏移量和大小字节都是可选的。这是为了在对小偏移量或大小进行编码时减少指令大小。第一个八位字节中的前七个位决定了接下来七个八位字节中的哪一个是存在的。如果位0被设置,则偏移量1存在。如果设置位1,则偏移量2存在,以此类推。</target>
        </trans-unit>
        <trans-unit id="64104629c1b1b50c9f411fd4ec6fd95dec11f7bd" translate="yes" xml:space="preserve">
          <source>All packs except the largest pack and those marked with a &lt;code&gt;.keep&lt;/code&gt; files are consolidated into a single pack. When this option is used, &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; is ignored.</source>
          <target state="translated">除了最大的包和标有 &lt;code&gt;.keep&lt;/code&gt; 文件的包之外的所有包都合并到一个包中。使用此选项时，将忽略 &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e92b55fa77d7332620f31b40a70c7222a88db6aa" translate="yes" xml:space="preserve">
          <source>All public Trace2 functions and macros are defined in &lt;code&gt;trace2.h&lt;/code&gt; and &lt;code&gt;trace2.c&lt;/code&gt;. All public symbols are prefixed with &lt;code&gt;trace2_&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;trace2.h&lt;/code&gt; 和 &lt;code&gt;trace2.c&lt;/code&gt; 中定义了所有公共Trace2函数和宏。所有公共符号均以 &lt;code&gt;trace2_&lt;/code&gt; 为前缀。</target>
        </trans-unit>
        <trans-unit id="872d9d2cb78e2e8d2f37173a02b50fa38f291d05" translate="yes" xml:space="preserve">
          <source>All recent commands (including stream comments, file changes and progress commands) are shown in the command history within the crash report, but raw file data and commit messages are excluded from the crash report. This exclusion saves space within the report file and reduces the amount of buffering that fast-import must perform during execution.</source>
          <target state="translated">所有最近的命令(包括流注释、文件更改和进度命令)都会显示在崩溃报告中的命令历史记录中,但原始文件数据和提交消息不包括在崩溃报告中。这种排除可以节省报告文件的空间,并减少fast-import在执行过程中必须执行的缓冲量。</target>
        </trans-unit>
        <trans-unit id="0d43876445b213dd01218535a02d26c66dcd613b" translate="yes" xml:space="preserve">
          <source>All refs under &lt;code&gt;refs/tags&lt;/code&gt; are pushed, in addition to refspecs explicitly listed on the command line.</source>
          <target state="translated">除了在命令行上明确列出的refspecs之外，还会推送 &lt;code&gt;refs/tags&lt;/code&gt; 下的所有refs 。</target>
        </trans-unit>
        <trans-unit id="c5bff800f470ce2148eed81904a64139c855aaa1" translate="yes" xml:space="preserve">
          <source>All submodules which are cloned will be shallow with a depth of 1.</source>
          <target state="translated">所有被克隆的子模块都会很浅,深度为1。</target>
        </trans-unit>
        <trans-unit id="f0007b01191229097f0830c36da052c040ebd97d" translate="yes" xml:space="preserve">
          <source>All submodules which are cloned will use the status of the submodule&amp;rsquo;s remote-tracking branch to update the submodule, rather than the superproject&amp;rsquo;s recorded SHA-1. Equivalent to passing &lt;code&gt;--remote&lt;/code&gt; to &lt;code&gt;git submodule update&lt;/code&gt;.</source>
          <target state="translated">克隆的所有子模块将使用子模块的远程跟踪分支的状态来更新子模块，而不是超级项目的已记录SHA-1。等效于将 &lt;code&gt;--remote&lt;/code&gt; 传递给 &lt;code&gt;git submodule update&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a786f92eda8c2712ba677e1c4004bf3ff8163928" translate="yes" xml:space="preserve">
          <source>All such extra objects are removed.</source>
          <target state="translated">所有这些额外的对象都被移除。</target>
        </trans-unit>
        <trans-unit id="308cf0e6d77f72bd2adee2732440a8d78d5aacdb" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;file1&lt;/code&gt; files in the output refer to files before the commit, and all the &lt;code&gt;file2&lt;/code&gt; files refer to files after the commit. It is incorrect to apply each change to each file sequentially. For example, this patch will swap a and b:</source>
          <target state="translated">输出中的所有 &lt;code&gt;file1&lt;/code&gt; 文件都引用提交之前的文件，所有 &lt;code&gt;file2&lt;/code&gt; 文件都引用提交之后的文件。依次将每个更改应用于每个文件是不正确的。例如，此补丁将交换a和b：</target>
        </trans-unit>
        <trans-unit id="239d57c9bf513683c75ec610784ccebafe4aed25" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;git commit&lt;/code&gt; hooks are invoked with the environment variable &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; if the command will not bring up an editor to modify the commit message.</source>
          <target state="translated">如果该命令不会调出编辑器来修改提交消息，那么所有的 &lt;code&gt;git commit&lt;/code&gt; 钩子都将通过环境变量 &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="05af0c4256a038463a91f307f30a32fa481ee96d" translate="yes" xml:space="preserve">
          <source>All the operations required for normal use are supported, including checkout, diff, status, update, log, add, remove, commit.</source>
          <target state="translated">支持所有正常使用所需的操作,包括签出、差分、状态、更新、日志、添加、删除、提交。</target>
        </trans-unit>
        <trans-unit id="b2fe8473c593abf01d9d1e8a032df7ab79ebe59a" translate="yes" xml:space="preserve">
          <source>All the other lines (and the remainder of the line after the section header) are recognized as setting variables, in the form &lt;code&gt;name = value&lt;/code&gt; (or just &lt;code&gt;name&lt;/code&gt;, which is a short-hand to say that the variable is the boolean &quot;true&quot;). The variable names are case-insensitive, allow only alphanumeric characters and &lt;code&gt;-&lt;/code&gt;, and must start with an alphabetic character.</source>
          <target state="translated">所有其他行（以及节标题之后的行的其余部分）都被识别为设置变量，形式为 &lt;code&gt;name = value&lt;/code&gt; （或仅仅是 &lt;code&gt;name&lt;/code&gt; ，这是表示变量为布尔值&amp;ldquo; true&amp;rdquo;的简写形式） ）。变量名称不区分大小写，仅允许字母数字字符和 &lt;code&gt;-&lt;/code&gt; ，并且必须以字母字符开头。</target>
        </trans-unit>
        <trans-unit id="37ddc9bc522de0a239773cc3df5a07e1939ed991" translate="yes" xml:space="preserve">
          <source>All these options obviously only make sense if enforced by the server side. They have been implemented to resemble the &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; options as closely as possible.</source>
          <target state="translated">所有这些选项显然只有在服务器端强制执行时才有意义。它们已实现为与&lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt;选项尽可能相似。</target>
        </trans-unit>
        <trans-unit id="8b22c4f0e3bbf22138baec4c3149a4805b70efc2" translate="yes" xml:space="preserve">
          <source>All untracked files are also stashed and then cleaned up with &lt;code&gt;git clean&lt;/code&gt;.</source>
          <target state="translated">所有未跟踪的文件也会被藏起来，然后使用 &lt;code&gt;git clean&lt;/code&gt; 进行清理。</target>
        </trans-unit>
        <trans-unit id="5a78bca2d245f7f4e49ed3949e2005fd2e3b0774" translate="yes" xml:space="preserve">
          <source>All variables can also be set per access method, see &lt;a href=&quot;#configaccessmethod&quot;&gt;above&lt;/a&gt;.</source>
          <target state="translated">还可以按访问方法设置所有变量，请参见&lt;a href=&quot;#configaccessmethod&quot;&gt;上文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e67d43426c8567d2129159d2cb0396634aa4c2f" translate="yes" xml:space="preserve">
          <source>All writing options will per default write to the repository specific configuration file. Note that this also affects options like &lt;code&gt;--replace-all&lt;/code&gt; and &lt;code&gt;--unset&lt;/code&gt;. &lt;strong&gt;&lt;em&gt;git config&lt;/em&gt; will only ever change one file at a time&lt;/strong&gt;.</source>
          <target state="translated">默认情况下，所有写入选项都将写入存储库特定的配置文件。请注意，这也会影响 &lt;code&gt;--unset&lt;/code&gt; &lt;code&gt;--replace-all&lt;/code&gt; 和--unset之类的选项。&lt;strong&gt;&lt;em&gt;git config&lt;/em&gt;一次只能更改一个文件&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="95ccd528c2d028453ad3cf7d0223681cc63467f8" translate="yes" xml:space="preserve">
          <source>All you need to do is edit the files to resolve the conflicts, and then</source>
          <target state="translated">您需要做的是编辑文件以解决冲突,然后</target>
        </trans-unit>
        <trans-unit id="dd540fb2325b9250764db7424886c097360ae897" translate="yes" xml:space="preserve">
          <source>All you need to do is place the newly created bare Git repository in a directory that is exported by the web server, and make some adjustments to give web clients some extra information they need:</source>
          <target state="translated">你需要做的就是将新创建的裸Git仓库放在一个由Web服务器导出的目录中,并做一些调整,给Web客户端提供一些他们需要的额外信息。</target>
        </trans-unit>
        <trans-unit id="48af47b0afbfe999262fa68f40e97838cf256b84" translate="yes" xml:space="preserve">
          <source>Allow (or disallow) external text conversion filters to be run when comparing binary files. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, but not for &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; or diff plumbing commands.</source>
          <target state="translated">比较二进制文件时，允许（或禁止）外部文本转换过滤器运行。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。由于textconv过滤器通常是单向转换，因此产生的差异适合人类使用，但无法应用。因此，默认情况下，仅对&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;和&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;启用textconv过滤器，而不对&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;或diff plumbing命令启用。</target>
        </trans-unit>
        <trans-unit id="c181c3ddfb97039bcd6c32002cf12732d3862d70" translate="yes" xml:space="preserve">
          <source>Allow -s or -t to query broken/corrupt objects of unknown type.</source>
          <target state="translated">允许-s或-t查询未知类型的破损/损坏对象。</target>
        </trans-unit>
        <trans-unit id="faf02b1d62cc9d5575e2c1ae9bbaffbbe1cee9af" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;--stdin&lt;/code&gt; to hash any garbage into a loose object which might not otherwise pass standard object parsing or git-fsck checks. Useful for stress-testing Git itself or reproducing characteristics of corrupt or bogus objects encountered in the wild.</source>
          <target state="translated">允许 &lt;code&gt;--stdin&lt;/code&gt; 将任何垃圾散列到一个松散的对象中，否则该对象可能无法通过标准对象解析或git-fsck检查。可用于对Git本身进行压力测试，或重现野外遇到的损坏或伪造物体的特征。</target>
        </trans-unit>
        <trans-unit id="b8cf489219ee9e67f31bd43c44a93293049edf6e" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for an object that is reachable from any ref tip. However, note that calculating object reachability is computationally expensive. Defaults to &lt;code&gt;false&lt;/code&gt;. Even if this is false, a client may be able to steal objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">允许 &lt;code&gt;upload-pack&lt;/code&gt; 接受获取请求，该请求要求从任何参考提示中可以访问的对象。但是，请注意，计算对象的可达性在计算上是昂贵的。默认为 &lt;code&gt;false&lt;/code&gt; 。即使这是错误的，客户端也可以通过&lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt;手册页的&amp;ldquo;安全&amp;rdquo;部分中描述的技术来窃取对象。最好将私有数据保存在单独的存储库中。</target>
        </trans-unit>
        <trans-unit id="5c123f83ef289d2d1e91047a317113ed5e999032" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for any object at all. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">允许 &lt;code&gt;upload-pack&lt;/code&gt; 接受完全要求任何对象的提取请求。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7dac60bc93b481fbd44fafe13c497842d9a7d982" translate="yes" xml:space="preserve">
          <source>Allow adding otherwise ignored files.</source>
          <target state="translated">允许添加其他忽略的文件。</target>
        </trans-unit>
        <trans-unit id="e0a681012f0189df01bc378cc160293747f7b006" translate="yes" xml:space="preserve">
          <source>Allow an empty note object to be stored. The default behavior is to automatically remove empty notes.</source>
          <target state="translated">允许存储一个空笔记对象。默认行为是自动删除空笔记。</target>
        </trans-unit>
        <trans-unit id="87f26de68d4ee0de2215d71b6377c359ff10beb5" translate="yes" xml:space="preserve">
          <source>Allow an external diff helper to be executed. If you set an external diff driver with &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;, you need to use this option with &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; and friends.</source>
          <target state="translated">允许执行外部差异助手。如果您使用&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;设置外部diff驱动程序，则需要将此选项与&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;和好友一起使用。</target>
        </trans-unit>
        <trans-unit id="73e430db92a123869cc3ef536d85d87d370ba895" translate="yes" xml:space="preserve">
          <source>Allow building of more than one tree object before exiting. Each tree is separated by as single blank line. The final new-line is optional. Note - if the &lt;code&gt;-z&lt;/code&gt; option is used, lines are terminated with NUL.</source>
          <target state="translated">退出之前，允许建立多个树对象。每棵树由单个空白行分隔。最后的换行符是可选的。注-如果使用 &lt;code&gt;-z&lt;/code&gt; 选项，则行以NUL终止。</target>
        </trans-unit>
        <trans-unit id="8e57d5c7661ffc2e9da98170f1d30b0c418901a9" translate="yes" xml:space="preserve">
          <source>Allow missing objects. The default behaviour (without this option) is to verify that each tree entry&amp;rsquo;s sha1 identifies an existing object. This option has no effect on the treatment of gitlink entries (aka &quot;submodules&quot;) which are always allowed to be missing.</source>
          <target state="translated">允许丢失物体。默认行为（不带此选项）是验证每个树条目的sha1是否标识一个现有对象。此选项对始终允许丢失的gitlink条目（也称为&amp;ldquo;子模块&amp;rdquo;）的处理没有影响。</target>
        </trans-unit>
        <trans-unit id="7a9030542d2938f9caeac64676db40e7417c42b9" translate="yes" xml:space="preserve">
          <source>Allow pulling from all directories that look like Git repositories (have the &lt;code&gt;objects&lt;/code&gt; and &lt;code&gt;refs&lt;/code&gt; subdirectories), even if they do not have the &lt;code&gt;git-daemon-export-ok&lt;/code&gt; file.</source>
          <target state="translated">即使没有 &lt;code&gt;git-daemon-export-ok&lt;/code&gt; 文件，也允许从看起来像Git存储库的所有目录中提取（具有 &lt;code&gt;objects&lt;/code&gt; 和 &lt;code&gt;refs&lt;/code&gt; 子目录）。</target>
        </trans-unit>
        <trans-unit id="98350181a43fb733be348f0d041de3f567196c13" translate="yes" xml:space="preserve">
          <source>Allow recursive removal when a leading directory name is given.</source>
          <target state="translated">当给定一个前导目录名时,允许递归删除。</target>
        </trans-unit>
        <trans-unit id="c333cb7fb684ac83dfac5b9ca4103644dc06e4b3" translate="yes" xml:space="preserve">
          <source>Allow several &amp;lt;repository&amp;gt; and &amp;lt;group&amp;gt; arguments to be specified. No &amp;lt;refspec&amp;gt;s may be specified.</source>
          <target state="translated">允许指定几个&amp;lt;repository&amp;gt;和&amp;lt;group&amp;gt;参数。不能指定&amp;lt;refspec&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="5913a64254a27922cb756768e473a3a0fc91c718" translate="yes" xml:space="preserve">
          <source>Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible.</source>
          <target state="translated">如果可能的话,允许重访机制用自动解决冲突的结果更新索引。</target>
        </trans-unit>
        <trans-unit id="e67909264741a3c975c7c69263b8cae851ce5588" translate="yes" xml:space="preserve">
          <source>Allow to extend .git/shallow if the new refs require it.</source>
          <target state="translated">如果新的参考文献要求,允许扩展.git/shallow。</target>
        </trans-unit>
        <trans-unit id="021daf7178c1ed944c38d8aa70956d32b2ff6625" translate="yes" xml:space="preserve">
          <source>Allow ~user notation to be used in requests. When specified with no parameter, requests to git://host/~alice/foo is taken as a request to access &lt;code&gt;foo&lt;/code&gt; repository in the home directory of user &lt;code&gt;alice&lt;/code&gt;. If &lt;code&gt;--user-path=path&lt;/code&gt; is specified, the same request is taken as a request to access &lt;code&gt;path/foo&lt;/code&gt; repository in the home directory of user &lt;code&gt;alice&lt;/code&gt;.</source>
          <target state="translated">允许在请求中使用〜用户符号。如果不指定任何参数，则对git：// host /〜alice / foo的请求将被视为访问用户 &lt;code&gt;alice&lt;/code&gt; 的主目录中的 &lt;code&gt;foo&lt;/code&gt; 存储库的请求。如果指定了 &lt;code&gt;--user-path=path&lt;/code&gt; ，则将同一请求作为访问用户 &lt;code&gt;alice&lt;/code&gt; 的主目录中的 &lt;code&gt;path/foo&lt;/code&gt; 存储库的请求。</target>
        </trans-unit>
        <trans-unit id="8f93db45d6bdb40051ed50b8cdab39b85ae36aa7" translate="yes" xml:space="preserve">
          <source>Allow/forbid overriding the site-wide default with per repository configuration. By default, all the services may be overridden.</source>
          <target state="translated">允许/禁止用每个存储库的配置覆盖整个站点的默认值。默认情况下,所有的服务都可以被覆盖。</target>
        </trans-unit>
        <trans-unit id="970c6f976b1a1113e48252fb665bb9621a059065" translate="yes" xml:space="preserve">
          <source>Allowing web browsing of a repository</source>
          <target state="translated">允许对存储库进行网络浏览</target>
        </trans-unit>
        <trans-unit id="2c735decb73a4c6a17889815dc7b443aeda53134" translate="yes" xml:space="preserve">
          <source>Allows overriding the default branch name e.g. when initializing a new repository or when cloning an empty repository.</source>
          <target state="translated">允许覆盖默认的分支名称,例如,当初始化一个新的版本库或克隆一个空版本库时。</target>
        </trans-unit>
        <trans-unit id="a8f99759b1b09bc7158e191889a1567fae09d468" translate="yes" xml:space="preserve">
          <source>Allows the pre-rebase hook to run, which is the default. This option can be used to override --no-verify. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">允许运行预变基挂钩，这是默认设置。此选项可用于覆盖--no-verify。另请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c6ea72ee13badd8d83db58afdf5e962ad300ef1" translate="yes" xml:space="preserve">
          <source>Allows to specify the commit message.</source>
          <target state="translated">允许指定提交信息。</target>
        </trans-unit>
        <trans-unit id="a2ec32ba2a953960fca003bf1ffa505bb688ba89" translate="yes" xml:space="preserve">
          <source>Also note that only one asterisk is allowed per word. For example:</source>
          <target state="translated">同时注意,每个字只允许有一个星号。例如:</target>
        </trans-unit>
        <trans-unit id="771cf844aea157583eecdff70f695735bc6a87ec" translate="yes" xml:space="preserve">
          <source>Also note that the above configuration can be performed by directly editing the file &lt;code&gt;.git/config&lt;/code&gt; instead of using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">还要注意，可以通过直接编辑文件 &lt;code&gt;.git/config&lt;/code&gt; 而不是使用&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;来执行上述配置。</target>
        </trans-unit>
        <trans-unit id="4107490214e5f413a9517623a2b64cb4835e7c24" translate="yes" xml:space="preserve">
          <source>Also note that we don&amp;rsquo;t require the commits that are kept to be descendants of a &quot;good&quot; commit. So in the following example, commits W and Z will be kept:</source>
          <target state="translated">还要注意，我们不需要保留为&amp;ldquo;良好&amp;rdquo;提交的后代的提交。因此，在以下示例中，将保留提交W和Z：</target>
        </trans-unit>
        <trans-unit id="f69166c2831d93f6b548f4895823501206c0d3ba" translate="yes" xml:space="preserve">
          <source>Also output details about the matching pattern (if any) for each given pathname. For precedence rules within and between exclude sources, see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="translated">还输出有关每个给定路径名的匹配模式（如果有）的详细信息。有关排除源之内和之间的优先级规则，请参见&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd9960d9f0773be5357485566c306db4c0f3e065" translate="yes" xml:space="preserve">
          <source>Also read the object names to remove notes from the standard input (there is no reason you cannot combine this with object names from the command line).</source>
          <target state="translated">同时读取对象名称,从标准输入中删除注释(没有理由不能从命令行中结合对象名称)。</target>
        </trans-unit>
        <trans-unit id="c7fa0726e69077445ae425465cf33ea62e9aedfc" translate="yes" xml:space="preserve">
          <source>Also search in ignored files by not honoring the &lt;code&gt;.gitignore&lt;/code&gt; mechanism. Only useful with &lt;code&gt;--untracked&lt;/code&gt;.</source>
          <target state="translated">还可以通过不遵守 &lt;code&gt;.gitignore&lt;/code&gt; 机制来搜索被忽略的文件。仅对 &lt;code&gt;--untracked&lt;/code&gt; 有用。</target>
        </trans-unit>
        <trans-unit id="05797f7578d1a6ba6a5217b9a350a9edbcb69fe4" translate="yes" xml:space="preserve">
          <source>Also you can use a regular expression to specify the line range:</source>
          <target state="translated">也可以使用正则表达式来指定行的范围。</target>
        </trans-unit>
        <trans-unit id="4774804d03b6c07565acb208c60c6e7cbe3431b2" translate="yes" xml:space="preserve">
          <source>Also, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; will list those files as &quot;unmerged&quot;, and the files with conflicts will have conflict markers added, like this:</source>
          <target state="translated">另外，&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;将这些文件列为&amp;ldquo;未合并&amp;rdquo;，并且有冲突的文件将添加冲突标记，如下所示：</target>
        </trans-unit>
        <trans-unit id="4527cea99021b273b3aba7b9a7e7a9bfd20d98e9" translate="yes" xml:space="preserve">
          <source>Also, note that a bare &lt;code&gt;git diff&lt;/code&gt; shows the changes to file.txt, but not the addition of closing.txt, because the version of closing.txt in the index file is identical to the one in the working directory.</source>
          <target state="translated">此外，请注意，裸露的 &lt;code&gt;git diff&lt;/code&gt; 显示对file.txt的更改，但未显示对shutdown.txt的添加，因为索引文件中的shutdown.txt的版本与工作目录中的版本相同。</target>
        </trans-unit>
        <trans-unit id="1948de62c9472dadd9b232c96fea0db542b4a7f1" translate="yes" xml:space="preserve">
          <source>Also, the poor performance of git-filter-branch often leads to safety issues:</source>
          <target state="translated">另外,git-filter-branch的性能不佳也经常导致安全问题。</target>
        </trans-unit>
        <trans-unit id="3d45b434e26b625e54920695d02b2fe8da737175" translate="yes" xml:space="preserve">
          <source>Also, the remote-tracking branch you use the &lt;code&gt;--fork-point&lt;/code&gt; mode with must be the one your topic forked from its tip. If you forked from an older commit than the tip, this mode would not find the fork point (imagine in the above sample history B0 did not exist, origin/master started at B1, moved to B2 and then B, and you forked your topic at origin/master^ when origin/master was B1; the shape of the history would be the same as above, without B0, and the parent of B1 is what &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; correctly finds, but the &lt;code&gt;--fork-point&lt;/code&gt; mode will not, because it is not one of the commits that used to be at the tip of origin/master).</source>
          <target state="translated">另外，使用 &lt;code&gt;--fork-point&lt;/code&gt; 模式的远程跟踪分支必须是您的主题从其技巧中派生的分支。如果您从比提示更早的提交进行分叉，则此模式将找不到分叉点（上述示例历史记录B0中的想象不存在，原点/主记录从B1开始，移至B2，然后移至B，然后分叉了主题在origin / master处，当origin / master是B1时；历史记录的形状将与上面相同，没有B0，并且B1的父级是 &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; 正确找到的，但是 &lt;code&gt;--fork-point&lt;/code&gt; 模式将不会，因为它不是以前位于源/主节点尖端的提交之一）。</target>
        </trans-unit>
        <trans-unit id="ac8d6fa69b9f440f0c0a5d003f6fd5f2f023c7f6" translate="yes" xml:space="preserve">
          <source>Also, these upper-case letters can be downcased to exclude. E.g. &lt;code&gt;--diff-filter=ad&lt;/code&gt; excludes added and deleted paths.</source>
          <target state="translated">同样，这些大写字母可以小写以排除。例如 &lt;code&gt;--diff-filter=ad&lt;/code&gt; 排除添加和删除的路径。</target>
        </trans-unit>
        <trans-unit id="2530a264943c28587e7428206ae85af163c3c029" translate="yes" xml:space="preserve">
          <source>Also, we do not call it &quot;cache&quot; any more, but rather &quot;index&quot;; however, the file is still called &lt;code&gt;cache.h&lt;/code&gt;. Remark: Not much reason to change it now, especially since there is no good single name for it anyway, because it is basically &lt;code&gt;the&lt;/code&gt; header file which is included by &lt;code&gt;all&lt;/code&gt; of Git&amp;rsquo;s C sources.</source>
          <target state="translated">同样，我们不再将其称为&amp;ldquo;缓存&amp;rdquo;，而是&amp;ldquo;索引&amp;rdquo;。但是，该文件仍称为 &lt;code&gt;cache.h&lt;/code&gt; 。备注：现在没有太多理由要更改它，特别是因为无论如何都没有一个好的名称，因为它基本上是 &lt;code&gt;all&lt;/code&gt; Git C源代码都包含 &lt;code&gt;the&lt;/code&gt; 头文件。</target>
        </trans-unit>
        <trans-unit id="4e6472f190ba1582b845a0ece02ff445cff78f4d" translate="yes" xml:space="preserve">
          <source>Also, when &lt;code&gt;--raw&lt;/code&gt; or &lt;code&gt;--numstat&lt;/code&gt; has been given, do not munge pathnames and use NULs as output field terminators.</source>
          <target state="translated">同样，在 &lt;code&gt;--raw&lt;/code&gt; 或 &lt;code&gt;--numstat&lt;/code&gt; 时，请勿更改路径名，并使用NUL作为输出字段终止符。</target>
        </trans-unit>
        <trans-unit id="a1a167e4e28bf08db5b93ca5300935fe27c039fa" translate="yes" xml:space="preserve">
          <source>Alter the sha1&amp;rsquo;s minimum display length in the output listing. The default value is 7 and can be overridden by the &lt;code&gt;core.abbrev&lt;/code&gt; config option.</source>
          <target state="translated">在输出列表中更改sha1的最小显示长度。默认值为7，可以被 &lt;code&gt;core.abbrev&lt;/code&gt; config选项覆盖。</target>
        </trans-unit>
        <trans-unit id="aadcacaf495c2512ca4329e0d847da152c0541e3" translate="yes" xml:space="preserve">
          <source>Alternate terms</source>
          <target state="translated">备用术语</target>
        </trans-unit>
        <trans-unit id="0712141dd1ece4a4773c0da1c80f1954ca0f9da5" translate="yes" xml:space="preserve">
          <source>Alternates, clone -reference, etc.</source>
          <target state="translated">替代、克隆-参考等。</target>
        </trans-unit>
        <trans-unit id="2ca863985e6b3522ed032957d62190302ca13b98" translate="yes" xml:space="preserve">
          <source>Alternative Git implementations (e.g. JGit or libgit2) and older Git versions (as of March 2018) do not support the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute. If you decide to use the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute in your repository, then it is strongly recommended to ensure that all clients working with the repository support it.</source>
          <target state="translated">替代的Git实现（例如JGit或libgit2）和较旧的Git版本（截至2018年3月）不支持 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性。如果决定在存储库中使用 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性，则强烈建议确保使用该存储库的所有客户端都支持该属性。</target>
        </trans-unit>
        <trans-unit id="9dbb61a2fa8dc0f3013308a0745fea72ba7b1a16" translate="yes" xml:space="preserve">
          <source>Alternative development models</source>
          <target state="translated">替代发展模式</target>
        </trans-unit>
        <trans-unit id="a7aefac2117f3e88573f4205384ee4d7a98e203b" translate="yes" xml:space="preserve">
          <source>Alternatively you can produce the password with perl&amp;rsquo;s crypt() operator:</source>
          <target state="translated">或者，您可以使用perl的crypt（）运算符生成密码：</target>
        </trans-unit>
        <trans-unit id="4ca416a8fe96dacfa9959132947eceee9f58da64" translate="yes" xml:space="preserve">
          <source>Alternatively, Git has a native protocol, or can use http; see &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; for details.</source>
          <target state="translated">另外，Git具有本机协议，或者可以使用http；有关详细信息，请参见&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7cf31ef819e05669294bc16a9923a23bdb2b7a01" translate="yes" xml:space="preserve">
          <source>Alternatively, if &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; config is not enabled or the attributes do not allow automatic detection for a filename, then the server uses the &lt;code&gt;gitcvs.allBinary&lt;/code&gt; config for the default setting. If &lt;code&gt;gitcvs.allBinary&lt;/code&gt; is set, then file not otherwise specified will default to &lt;code&gt;-kb&lt;/code&gt; mode. Otherwise the &lt;code&gt;-k&lt;/code&gt; mode is left blank. But if &lt;code&gt;gitcvs.allBinary&lt;/code&gt; is set to &quot;guess&quot;, then the correct &lt;code&gt;-k&lt;/code&gt; mode will be guessed based on the contents of the file.</source>
          <target state="translated">或者，如果未启用 &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 配置，或者属性不允许自动检测文件名，则服务器将 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; 配置用作默认设置。如果设置了 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; ，则未另行指定的文件将默认为 &lt;code&gt;-kb&lt;/code&gt; 模式。否则， &lt;code&gt;-k&lt;/code&gt; 模式将留空。但是，如果 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; 设置为&amp;ldquo; guess&amp;rdquo;，则将根据文件的内容猜测正确的 &lt;code&gt;-k&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="b1ff522462be60cebf023852e684a91e2d5544f7" translate="yes" xml:space="preserve">
          <source>Alternatively, if the variable is set to an absolute path (starting with a &lt;code&gt;/&lt;/code&gt; character), Git will interpret this as a file path and will try to append the trace messages to it.</source>
          <target state="translated">或者，如果将变量设置为绝对路径（以 &lt;code&gt;/&lt;/code&gt; 字符开头），则Git会将其解释为文件路径，并尝试将跟踪消息附加到该路径。</target>
        </trans-unit>
        <trans-unit id="4d07f3824238dc7367ab6d5b5e874d23e305b47d" translate="yes" xml:space="preserve">
          <source>Alternatively, if the variable is set to an absolute path (starting with a &lt;code&gt;/&lt;/code&gt; character), Git will interpret this as a file path and will try to append the trace messages to it. If the path already exists and is a directory, the trace messages will be written to files (one per process) in that directory, named according to the last component of the SID and an optional counter (to avoid filename collisions).</source>
          <target state="translated">或者，如果将变量设置为绝对路径（以 &lt;code&gt;/&lt;/code&gt; 字符开头），则Git会将其解释为文件路径，并尝试将跟踪消息附加到该路径。如果路径已经存在并且是目录，则跟踪消息将被写入该目录中的文件（每个进程一个），并根据SID的最后一个组件和一个可选的计数器进行命名（以避免文件名冲突）。</target>
        </trans-unit>
        <trans-unit id="c00302c08639585f72779e30a86782e24fd08ff9" translate="yes" xml:space="preserve">
          <source>Alternatively, instead of running &lt;code&gt;git add&lt;/code&gt; beforehand, you can use</source>
          <target state="translated">另外，您可以使用以下方法代替预先运行 &lt;code&gt;git add&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="530bb07d1f66513818e1b0385a8e30a51f6194af" translate="yes" xml:space="preserve">
          <source>Alternatively, note that</source>
          <target state="translated">或者,注意到</target>
        </trans-unit>
        <trans-unit id="3e90fb17ee6a04d2308756c054ccebe57c9372c1" translate="yes" xml:space="preserve">
          <source>Alternatively, specifying &lt;code&gt;--force-if-includes&lt;/code&gt; as an ancillary option along with &lt;code&gt;--force-with-lease[=&amp;lt;refname&amp;gt;]&lt;/code&gt; (i.e., without saying what exact commit the ref on the remote side must be pointing at, or which refs on the remote side are being protected) at the time of &quot;push&quot; will verify if updates from the remote-tracking refs that may have been implicitly updated in the background are integrated locally before allowing a forced update.</source>
          <target state="translated">或者，将 &lt;code&gt;--force-if-includes&lt;/code&gt; 与 &lt;code&gt;--force-with-lease[=&amp;lt;refname&amp;gt;]&lt;/code&gt; 一起指定为辅助选项（即，不用说远程参考必须指向哪个确切的提交，或者不指定哪个参考）。在&amp;ldquo;推送&amp;rdquo;时，远程端的refs受到保护）将在允许强制更新之前，验证是否已在本地集成了来自远程跟踪refs的更新（这些更新可能已在后台隐式更新）。</target>
        </trans-unit>
        <trans-unit id="f80a5d22f5c293edd914795b473129c37d7276c3" translate="yes" xml:space="preserve">
          <source>Alternatively, use &lt;code&gt;-z&lt;/code&gt; to specify in NUL-terminated format, without quoting:</source>
          <target state="translated">或者，使用 &lt;code&gt;-z&lt;/code&gt; 以NUL终止的格式指定，而无需引用：</target>
        </trans-unit>
        <trans-unit id="e5759528a9df2b3bafde33c91b20bb607bfb37f6" translate="yes" xml:space="preserve">
          <source>Alternatively, you can edit the working directory and update the index to fix your mistake, just as if you were going to &lt;a href=&quot;#how-to-make-a-commit&quot;&gt;create a new commit&lt;/a&gt;, then run</source>
          <target state="translated">另外，您可以编辑工作目录并更新索引以纠正错误，就像要&lt;a href=&quot;#how-to-make-a-commit&quot;&gt;创建一个新的commit一样&lt;/a&gt;，然后运行</target>
        </trans-unit>
        <trans-unit id="b15cfe3da911f6cecf33791979f852dbff3cfb5b" translate="yes" xml:space="preserve">
          <source>Alternatively, you can just use the non-standard extssh protocol that Eclipse offer. In that case CVS_SERVER is ignored, and you will have to replace the cvs utility on the server with &lt;code&gt;git-cvsserver&lt;/code&gt; or manipulate your &lt;code&gt;.bashrc&lt;/code&gt; so that calling &lt;code&gt;cvs&lt;/code&gt; effectively calls &lt;code&gt;git-cvsserver&lt;/code&gt;.</source>
          <target state="translated">另外，您可以只使用Eclipse提供的非标准extssh协议。在这种情况下，将忽略CVS_SERVER，并且您将不得不用 &lt;code&gt;git-cvsserver&lt;/code&gt; 替换服务器上的cvs实用程序或操纵 &lt;code&gt;.bashrc&lt;/code&gt; ,以便调用 &lt;code&gt;cvs&lt;/code&gt; 有效地调用 &lt;code&gt;git-cvsserver&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05fd4a6419394e16cfc11919ace1a8f856d1ec42" translate="yes" xml:space="preserve">
          <source>Alternatively, you can rebase your change between X and B on top of A, with &quot;git pull --rebase&quot;, and push the result back. The rebase will create a new commit D that builds the change between X and B on top of A.</source>
          <target state="translated">或者,你也可以用 &quot;git pull --rebase&quot;,将X和B之间的变更重新建立在A之上,并将结果推回。重基将创建一个新的提交D,在A的基础上建立X和B之间的变更。</target>
        </trans-unit>
        <trans-unit id="a49fa07d5474cf3dca63ac2a175c46a10b07f5f3" translate="yes" xml:space="preserve">
          <source>Alternatively, you can undo the &lt;code&gt;git rebase&lt;/code&gt; with</source>
          <target state="translated">另外，您也可以撤消 &lt;code&gt;git rebase&lt;/code&gt; 用</target>
        </trans-unit>
        <trans-unit id="029034bf1886e77ae0c4d532b4059fd9c7d41a52" translate="yes" xml:space="preserve">
          <source>Alternatively, you may often see this sort of thing done with the lower-level command &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;, which just lists the SHA-1&amp;rsquo;s of all the given commits:</source>
          <target state="translated">另外，您可能经常会看到使用较低级命令&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;完成的操作，该命令仅列出所有给定提交的SHA-1：</target>
        </trans-unit>
        <trans-unit id="bf28b03e83304f7cdad7262da1da6a80b8eb9f3d" translate="yes" xml:space="preserve">
          <source>Although Git includes its own porcelain layer, its low-level commands are sufficient to support development of alternative porcelains. Developers of such porcelains might start by reading about &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; and &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt;.</source>
          <target state="translated">尽管Git包括自己的瓷器层，但它的底层命令足以支持替代瓷器的开发。这类瓷器的开发人员可能会从阅读&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;和&lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]开始&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c4b8611028dc848ad4ee5788ef19d7585dae7a1" translate="yes" xml:space="preserve">
          <source>Although Git is a truly distributed system, it is often convenient to organize your project with an informal hierarchy of developers. Linux kernel development is run this way. There is a nice illustration (page 17, &quot;Merges to Mainline&quot;) in &lt;a href=&quot;https://web.archive.org/web/20120915203609/http://www.xenotime.net/linux/mentor/linux-mentoring-2006.pdf&quot;&gt;Randy Dunlap&amp;rsquo;s presentation&lt;/a&gt;.</source>
          <target state="translated">尽管Git是一个真正的分布式系统，但通常使用非正式的开发人员层次结构来组织项目非常方便。Linux内核开发是以这种方式运行的。&lt;a href=&quot;https://web.archive.org/web/20120915203609/http://www.xenotime.net/linux/mentor/linux-mentoring-2006.pdf&quot;&gt;Randy Dunlap的演示文稿中&lt;/a&gt;有一个很好的插图（第17页，&amp;ldquo;合并到主线&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="6f37ac3daafe831f82aec5b2cea866288f7330ab" translate="yes" xml:space="preserve">
          <source>Although both this option and --fork-point find the merge base between &amp;lt;upstream&amp;gt; and &amp;lt;branch&amp;gt;, this option uses the merge base as the &lt;code&gt;starting point&lt;/code&gt; on which new commits will be created, whereas --fork-point uses the merge base to determine the &lt;code&gt;set of commits&lt;/code&gt; which will be rebased.</source>
          <target state="translated">尽管此选项和--fork-point都找到了&amp;lt;upstream&amp;gt;和&amp;lt;branch&amp;gt;之间的合并基础，但是此选项使用合并基础作为创建新提交的 &lt;code&gt;starting point&lt;/code&gt; ，而--fork-point使用合并确定要重新确定基础 &lt;code&gt;set of commits&lt;/code&gt; 集。</target>
        </trans-unit>
        <trans-unit id="bc30d48b03921e7f964de7f07369eb4188785847" translate="yes" xml:space="preserve">
          <source>Although the object files are gone, any commands that refer to those objects will work exactly as they did before.</source>
          <target state="translated">虽然对象文件消失了,但任何引用这些对象的命令都会像以前一样工作。</target>
        </trans-unit>
        <trans-unit id="47f1282955f73f61669189722bd77f19d0aada5a" translate="yes" xml:space="preserve">
          <source>Although this bit looks similar to assume-unchanged bit, its goal is different from assume-unchanged bit&amp;rsquo;s. Skip-worktree also takes precedence over assume-unchanged bit when both are set.</source>
          <target state="translated">尽管此位看起来与假定不变的位相似，但其目标与假定不变的位不同。当两者都设置时，跳过工作树也优先于假定不变的位。</target>
        </trans-unit>
        <trans-unit id="d6138749eeae08edd7696427a93048315afbc7d0" translate="yes" xml:space="preserve">
          <source>Although we encourage that the commit log messages are encoded in UTF-8, both the core and Git Porcelain are designed not to force UTF-8 on projects. If all participants of a particular project find it more convenient to use legacy encodings, Git does not forbid it. However, there are a few things to keep in mind.</source>
          <target state="translated">虽然我们鼓励提交日志信息使用 UTF-8 编码,但核心和 Git Porcelain 的设计都不会强迫项目使用 UTF-8。如果某个项目的所有参与者都认为使用传统编码更方便,Git也不会禁止。不过,有几点需要注意。</target>
        </trans-unit>
        <trans-unit id="2138c97353c611a94eb25c7e6e46e48baedec73c" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;acknowledgments&quot;</source>
          <target state="translated">总是以 &quot;致谢 &quot;一节开头。</target>
        </trans-unit>
        <trans-unit id="e2fd2ed397536c82477394e8a15b0eb70ea28108" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;packfile&quot;</source>
          <target state="translated">总是以节头 &quot;packfile &quot;开始。</target>
        </trans-unit>
        <trans-unit id="e800f612b747be24c1ecc7958dae9ec5015af129" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;packfile-uris&quot;.</source>
          <target state="translated">始终以 &quot;packfile-uris &quot;节头开始。</target>
        </trans-unit>
        <trans-unit id="2a74cc6750711124d9f54ba56e439b92b2eb550a" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;shallow-info&quot;</source>
          <target state="translated">始终以 &quot;浅层信息 &quot;部分的标题开始。</target>
        </trans-unit>
        <trans-unit id="fa34aca91ee0baeaea0934aa3e08a4599c439042" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;wanted-refs&quot;.</source>
          <target state="translated">总是以 &quot;wanted-refs &quot;节标题开始。</target>
        </trans-unit>
        <trans-unit id="7e06c04cd8e1ea9ac30d6ef765d5374aeb2852d8" translate="yes" xml:space="preserve">
          <source>Always commit your fixes to the oldest supported branch that requires them. Then (periodically) merge the integration branches upwards into each other.</source>
          <target state="translated">总是将你的修复提交到需要修复的最老的支持分支。然后(定期)向上合并集成分支。</target>
        </trans-unit>
        <trans-unit id="740206082e01fd2ec3dbefb8f6cae1ac54979d66" translate="yes" xml:space="preserve">
          <source>Always output the long format (the tag, the number of commits and the abbreviated commit name) even when it matches a tag. This is useful when you want to see parts of the commit object name in &quot;describe&quot; output, even when the commit in question happens to be a tagged version. Instead of just emitting the tag name, it will describe such a commit as v1.2-0-gdeadbee (0th commit since tag v1.2 that points at object deadbee&amp;hellip;​.).</source>
          <target state="translated">即使匹配标签，也始终输出长格式（标签，提交次数和缩写的提交名称）。当您想在&amp;ldquo;描述&amp;rdquo;输出中看到提交对象名称的一部分时，即使当所讨论的提交恰好是标记版本时，这也很有用。它不仅描述标签名称，还将描述诸如v1.2-0-gdeadbee的提交（自标签v1.2以来的第0个提交，指向对象Deadbee ....）。</target>
        </trans-unit>
        <trans-unit id="10fe0db5ec22452b1b5e484a236c7996a8b1d4d4" translate="yes" xml:space="preserve">
          <source>Always publish the submodule change before publishing the change to the superproject that references it. If you forget to publish the submodule change, others won&amp;rsquo;t be able to clone the repository:</source>
          <target state="translated">在将更改发布到引用它的超级项目之前，请始终发布该子模块更改。如果您忘记发布子模块更改，则其他人将无法克隆存储库：</target>
        </trans-unit>
        <trans-unit id="30bc18fd1cd8bd10b1f49729296161d64c50a6de" translate="yes" xml:space="preserve">
          <source>Always use the current time and time zone. The literal &lt;code&gt;now&lt;/code&gt; must always be supplied for &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">始终使用当前时间和时区。 &lt;code&gt;now&lt;/code&gt; 必须始终为 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 提供文字。</target>
        </trans-unit>
        <trans-unit id="7f3edc64a04543ee397addec8da3ac8a7a4a6fa3" translate="yes" xml:space="preserve">
          <source>Always verify that the rewritten version is correct: The original refs, if different from the rewritten ones, will be stored in the namespace &lt;code&gt;refs/original/&lt;/code&gt;.</source>
          <target state="translated">始终验证重写的版本正确：原始引用（如果与重写的引用不同）将存储在命名空间 &lt;code&gt;refs/original/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c005cc3257b6a0770843066bf6334d49c090a4e" translate="yes" xml:space="preserve">
          <source>Among the &amp;lt;reference&amp;gt;s given, display only the ones that cannot be reached from any other &amp;lt;reference&amp;gt;.</source>
          <target state="translated">在给定的&amp;lt;reference&amp;gt;中，仅显示其他&amp;lt;reference&amp;gt;无法访问的那些。</target>
        </trans-unit>
        <trans-unit id="ac6d5f7660135e74c3b73d13034cd4552f455751" translate="yes" xml:space="preserve">
          <source>An &quot;annotated tag&quot; is actually a real Git object, and contains not only a pointer to the state you want to tag, but also a small tag name and message, along with optionally a PGP signature that says that yes, you really did that tag. You create these annotated tags with either the &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;-s&lt;/code&gt; flag to &lt;code&gt;git tag&lt;/code&gt;:</source>
          <target state="translated">&amp;ldquo;带注释的标签&amp;rdquo;实际上是一个真正的Git对象，它不仅包含指向您要标记的状态的指针，还包含一个小的标签名称和消息，以及一个可选的PGP签名，它说是的，您确实做到了标签。您可以使用 &lt;code&gt;git tag&lt;/code&gt; 的 &lt;code&gt;-a&lt;/code&gt; 或 &lt;code&gt;-s&lt;/code&gt; 标志创建这些带注释的标签：</target>
        </trans-unit>
        <trans-unit id="1268d4db5a16c4059e58835dc106857c027b0f95" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; which contains unmerged &lt;a href=&quot;#def_index_entry&quot;&gt;index entries&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;#def_index&quot;&gt;指数&lt;/a&gt;包含未合并的&lt;a href=&quot;#def_index_entry&quot;&gt;索引条目&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d934873e3d430ebe475eea94d0b0f9a9f43c9fd6" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; containing a &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; pointing to another object, which can contain a message just like a &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;. It can also contain a (PGP) signature, in which case it is called a &quot;signed tag object&quot;.</source>
          <target state="translated">一个&lt;a href=&quot;#def_object&quot;&gt;对象，&lt;/a&gt;其中的&lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt;指向另一个对象，该对象可以包含一条消息，就像&lt;a href=&quot;#def_commit_object&quot;&gt;commit对象一样&lt;/a&gt;。它还可以包含（PGP）签名，在这种情况下，它称为&amp;ldquo;签名标签对象&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="39ba7d0e69e6d58b366781bce9a8868629216c1c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; containing a list of file names and modes along with refs to the associated blob and/or tree objects. A &lt;a href=&quot;#def_tree&quot;&gt;tree&lt;/a&gt; is equivalent to a &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;#def_object&quot;&gt;对象，&lt;/a&gt;包含文件名和模式的列表以及对关联的Blob和/或树对象的引用。一&lt;a href=&quot;#def_tree&quot;&gt;棵树&lt;/a&gt;相当于一个&lt;a href=&quot;#def_directory&quot;&gt;目录&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c15d413f65deef5a874cba86dbad4625cd4cbd2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; used to temporarily store the contents of a &lt;a href=&quot;#def_dirty&quot;&gt;dirty&lt;/a&gt; working directory and the index for future reuse.</source>
          <target state="translated">一个&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;用于临时存储的内容&lt;a href=&quot;#def_dirty&quot;&gt;肮脏的&lt;/a&gt;工作目录，并为未来的再利用指标。</target>
        </trans-unit>
        <trans-unit id="0c263addb55b65fe527b2a21bf509fb6d214e692" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; which contains the information about a particular &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;, such as &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt;, committer, author, date and the &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; which corresponds to the top &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt; of the stored revision.</source>
          <target state="translated">一个&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;，其中包含有关特定&lt;a href=&quot;#def_revision&quot;&gt;修订版&lt;/a&gt;的信息，例如&lt;a href=&quot;#def_parent&quot;&gt;父母&lt;/a&gt;，提交者，作者，日期和与存储的修订版的顶层&lt;a href=&quot;#def_directory&quot;&gt;目录&lt;/a&gt;相对应的&lt;a href=&quot;#def_tree_object&quot;&gt;树对象&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa8c0584fca9913191dbab3d7a46ffea1d0255bd" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; which is not &lt;a href=&quot;#def_reachable&quot;&gt;reachable&lt;/a&gt; from a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;, &lt;a href=&quot;#def_tag&quot;&gt;tag&lt;/a&gt;, or any other reference.</source>
          <target state="translated">从&lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;，&lt;a href=&quot;#def_tag&quot;&gt;tag&lt;/a&gt;或任何其他引用无法&lt;a href=&quot;#def_reachable&quot;&gt;访问&lt;/a&gt;的&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fa11321cf1316d583795e0fa9253aae31456769" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_unreachable_object&quot;&gt;unreachable object&lt;/a&gt; which is not &lt;a href=&quot;#def_reachable&quot;&gt;reachable&lt;/a&gt; even from other unreachable objects; a dangling object has no references to it from any reference or &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; in the &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;#def_unreachable_object&quot;&gt;不可达目的&lt;/a&gt;这是不&lt;a href=&quot;#def_reachable&quot;&gt;可达的&lt;/a&gt;更从其他不可获得的对象; 一个悬空对象具有从任何参考或未被引用&lt;a href=&quot;#def_object&quot;&gt;的对象&lt;/a&gt;的&lt;a href=&quot;#def_repository&quot;&gt;储存库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f18e6fb49a003c4f6ae24bcf2f216e9b2db33c0" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;author&lt;/code&gt; command may optionally appear, if the author information might differ from the committer information. If &lt;code&gt;author&lt;/code&gt; is omitted then fast-import will automatically use the committer&amp;rsquo;s information for the author portion of the commit. See below for a description of the fields in &lt;code&gt;author&lt;/code&gt;, as they are identical to &lt;code&gt;committer&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;author&lt;/code&gt; 命令可以有选择地出现，如果作者的信息可能会从提交者信息不同。如果省略了 &lt;code&gt;author&lt;/code&gt; ，则快速导入将自动使用提交者的信息作为提交的作者部分。有关 &lt;code&gt;author&lt;/code&gt; 中字段的描述，请参见下文，因为它们与 &lt;code&gt;committer&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="2ca13f668178d4001fb40c21d014f07bacdba23a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;upload-archive&lt;/code&gt; also exists to serve &lt;code&gt;git archive&lt;/code&gt;.</source>
          <target state="translated">还存在一个 &lt;code&gt;upload-archive&lt;/code&gt; 服务于 &lt;code&gt;git archive&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2777cee48df007e662d7335b2a99199ee01a9bf5" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;object&lt;/em&gt; is identified by its 160-bit SHA-1 hash, aka &lt;em&gt;object name&lt;/em&gt;, and a reference to an object is always the 40-byte hex representation of that SHA-1 name. The files in the &lt;code&gt;refs&lt;/code&gt; subdirectory are expected to contain these hex references (usually with a final &lt;code&gt;\n&lt;/code&gt; at the end), and you should thus expect to see a number of 41-byte files containing these references in these &lt;code&gt;refs&lt;/code&gt; subdirectories when you actually start populating your tree.</source>
          <target state="translated">一个&lt;em&gt;目的&lt;/em&gt;是通过其160位的SHA-1散列识别的，又名&lt;em&gt;对象名&lt;/em&gt;，和到一个对象的引用始终是SHA-1名称的40字节的十六进制表示。 &lt;code&gt;refs&lt;/code&gt; 子目录中的文件应包含这些十六进制引用（通常在末尾带有 &lt;code&gt;\n&lt;/code&gt; ），因此，当您实际开始时，您应该期望在这些 &lt;code&gt;refs&lt;/code&gt; 子目录中看到许多包含这些引用的41字节文件填充您的树。</target>
        </trans-unit>
        <trans-unit id="a56c50d5220ee34a87c6403dce1dee00fe1f60bc" translate="yes" xml:space="preserve">
          <source>An advanced user may want to take a look at &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; after finishing this tutorial.</source>
          <target state="translated">在完成本教程之后，高级用户可能想看一下&lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ba7e65ac14d1c1843ebc23a20f7a824d2e90d69" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;--discard-changes&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--discard-changes&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="1c482877d68de7df403d2a569fe4e9b8337d6d28" translate="yes" xml:space="preserve">
          <source>An alternate participant submission mechanism is using the &lt;code&gt;git request-pull&lt;/code&gt; or pull-request mechanisms (e.g as used on GitHub (www.github.com) to notify your upstream of your contribution.</source>
          <target state="translated">另一种参与者提交机制是使用 &lt;code&gt;git request-pull&lt;/code&gt; 或pull-request机制（例如，在GitHub（www.github.com）上使用的机制）将您的贡献通知您的上游。</target>
        </trans-unit>
        <trans-unit id="4308fb9f973f309f701eb31f44b62bb9dad115a0" translate="yes" xml:space="preserve">
          <source>An alternative scp-like syntax may also be used with the ssh protocol:</source>
          <target state="translated">另一种类似scp的语法也可用于ssh协议。</target>
        </trans-unit>
        <trans-unit id="3e45d63c9493efc9c482c8956b2b502b296e599f" translate="yes" xml:space="preserve">
          <source>An alternative style can be used by setting the &quot;merge.conflictStyle&quot; configuration variable to &quot;diff3&quot;. In &quot;diff3&quot; style, the above conflict may look like this:</source>
          <target state="translated">通过设置 &quot;merge.conflictStyle &quot;配置变量为 &quot;diff3&quot;,可以使用另一种风格。在 &quot;diff3 &quot;风格下,上面的冲突可能是这样的。</target>
        </trans-unit>
        <trans-unit id="b9a3606b6f09bb975ca3b2fd930ed7cfdb47c5de" translate="yes" xml:space="preserve">
          <source>An application using git-credential will typically use &lt;code&gt;git
credential&lt;/code&gt; following these steps:</source>
          <target state="translated">使用git-credential的应用程序通常会按照以下步骤使用 &lt;code&gt;git credential&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ae3f33e4c0349221e2575da0576bccf42d579897" translate="yes" xml:space="preserve">
          <source>An asterisk &quot;&lt;code&gt;*&lt;/code&gt;&quot; matches anything except a slash. The character &quot;&lt;code&gt;?&lt;/code&gt;&quot; matches any one character except &quot;&lt;code&gt;/&lt;/code&gt;&quot;. The range notation, e.g. &lt;code&gt;[a-zA-Z]&lt;/code&gt;, can be used to match one of the characters in a range. See fnmatch(3) and the FNM_PATHNAME flag for a more detailed description.</source>
          <target state="translated">星号&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo;匹配除斜杠之外的所有内容。字符&amp;ldquo; &lt;code&gt;?&lt;/code&gt; &amp;rdquo;与&amp;ldquo; &lt;code&gt;/&lt;/code&gt; &amp;rdquo; 以外的任何一个字符匹配。范围符号，例如 &lt;code&gt;[a-zA-Z]&lt;/code&gt; ，可用于匹配范围中的字符之一。有关更多详细说明，请参见fnmatch（3）和FNM_PATHNAME标志。</target>
        </trans-unit>
        <trans-unit id="f92a93236adb7a911f096656f0a19e52c91fc87c" translate="yes" xml:space="preserve">
          <source>An editor will be fired up with all the commits in your current branch (ignoring merge commits), which come after the given commit. You can reorder the commits in this list to your heart&amp;rsquo;s content, and you can remove them. The list looks more or less like this:</source>
          <target state="translated">将使用当前分支中的所有提交（忽略合并提交）来激发编辑器，这些提交是在给定提交之后进行的。您可以将列表中的提交重新排序到您的心脏内容，然后可以将其删除。该列表大致如下所示：</target>
        </trans-unit>
        <trans-unit id="4a20a69211227e7acfb792d7e2f72fe61b4b109b" translate="yes" xml:space="preserve">
          <source>An element with an empty value can be used to clear the list of globs accumulated from previous configuration entries. When there is no &lt;code&gt;merge.suppressDest&lt;/code&gt; variable defined, the default value of &lt;code&gt;master&lt;/code&gt; is used for backward compatibility.</source>
          <target state="translated">具有空值的元素可用于清除从先前配置条目累积的全局列表。如果 &lt;code&gt;merge.suppressDest&lt;/code&gt; 变量，则将 &lt;code&gt;master&lt;/code&gt; 的默认值用于向后兼容。</target>
        </trans-unit>
        <trans-unit id="3034dd5f2cb814d90a3721e980abfe2559bdf7b3" translate="yes" xml:space="preserve">
          <source>An empty color string produces no color effect at all. This can be used to avoid coloring specific elements without disabling color entirely.</source>
          <target state="translated">空的颜色字符串不会产生任何颜色效果。这可以用来避免给特定元素着色,而不完全禁用颜色。</target>
        </trans-unit>
        <trans-unit id="2425d5d7f13cfb1e5013987fec335bdb279cc21f" translate="yes" xml:space="preserve">
          <source>An evil merge is a &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; that introduces changes that do not appear in any &lt;a href=&quot;#def_parent&quot;&gt;parent&lt;/a&gt;.</source>
          <target state="translated">邪恶合并是一种&lt;a href=&quot;#def_merge&quot;&gt;合并&lt;/a&gt;，它引入了未在任何&lt;a href=&quot;#def_parent&quot;&gt;父级中&lt;/a&gt;出现的更改。</target>
        </trans-unit>
        <trans-unit id="983a5c1c22b13082f53d4ffac58905fc5683444c" translate="yes" xml:space="preserve">
          <source>An example crash:</source>
          <target state="translated">一个例子崩溃。</target>
        </trans-unit>
        <trans-unit id="b7fefb821701ed8916b003bdc64ab026062f47d5" translate="yes" xml:space="preserve">
          <source>An example directly producing formatted text. Show the most recent 3 tagged commits:</source>
          <target state="translated">一个直接生成格式化文本的例子。显示最近的3个标签提交。</target>
        </trans-unit>
        <trans-unit id="07b3f3938c0999bf8d07073e13ae4fad78c37982" translate="yes" xml:space="preserve">
          <source>An example to show the usage of %(if)&amp;hellip;​%(then)&amp;hellip;​%(else)&amp;hellip;​%(end). This prefixes the current branch with a star.</source>
          <target state="translated">举例说明％（if）...％（then）...％（else）...％（end）的用法。这会在当前分支之前加星号。</target>
        </trans-unit>
        <trans-unit id="130d3057e79f4ea0755954d533ec854202e8c665" translate="yes" xml:space="preserve">
          <source>An example to show the usage of %(if)&amp;hellip;​%(then)&amp;hellip;​%(end). This prints the authorname, if present.</source>
          <target state="translated">一个示例显示％（if）...％（then）...％（end）的用法。这将显示作者姓名（如果存在）。</target>
        </trans-unit>
        <trans-unit id="0dd4a6b345a98548ae1d0552b0faaa4bc7a8afb7" translate="yes" xml:space="preserve">
          <source>An example to use customized color from the configuration in your script:</source>
          <target state="translated">在脚本中使用自定义颜色的例子。</target>
        </trans-unit>
        <trans-unit id="5e3fe250825ac46db801c9bc9679b73fba035132" translate="yes" xml:space="preserve">
          <source>An example value is &amp;ldquo;Tue Feb 6 11:22:18 2007 -0500&amp;rdquo;. The Git parser is accurate, but a little on the lenient side. It is the same parser used by &lt;code&gt;git am&lt;/code&gt; when applying patches received from email.</source>
          <target state="translated">示例值是&amp;ldquo; 2007年2月6日星期二11:22:18 -0500&amp;rdquo;。Git解析器是准确的，但宽大一点。它与 &lt;code&gt;git am&lt;/code&gt; 应用从电子邮件接收的补丁程序时使用的解析器相同。</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一个例子:</target>
        </trans-unit>
        <trans-unit id="67bf2af305e53a13545716b037aa5bc68e4afad9" translate="yes" xml:space="preserve">
          <source>An example: in an SVN repository with a standard trunk/tags/branches layout, a directory trunk/sub is created in r.100. In r.200, trunk/sub is branched by copying it to branches/. &lt;code&gt;git svn clone -s&lt;/code&gt; will then create a branch &lt;code&gt;sub&lt;/code&gt;. It will also create new Git commits for r.100 through r.199 and use these as the history of branch &lt;code&gt;sub&lt;/code&gt;. Thus there will be two Git commits for each revision from r.100 to r.199 (one containing trunk/, one containing trunk/sub/). Finally, it will create a branch &lt;code&gt;sub@200&lt;/code&gt; pointing to the new parent commit of branch &lt;code&gt;sub&lt;/code&gt; (i.e. the commit for r.200 and trunk/sub/).</source>
          <target state="translated">一个示例：在具有标准主干/标签/分支布局的SVN存储库中，在r.100中创建了目录主干/子目录。在r.200中，通过将trunk / sub复制到branchs /来进行分支。 &lt;code&gt;git svn clone -s&lt;/code&gt; 将创建一个分支 &lt;code&gt;sub&lt;/code&gt; 。它还将为r.100至r.199创建新的Git提交，并将它们用作分支 &lt;code&gt;sub&lt;/code&gt; 的历史记录。因此，从r.100到r.199的每个修订版将有两个Git提交（一个包含trunk /，一个包含trunk / sub /）。最后，它会创建一个分支 &lt;code&gt;sub@200&lt;/code&gt; 指向新的父提交的分支的 &lt;code&gt;sub&lt;/code&gt; （即提交了r.200和躯干/子/）。</target>
        </trans-unit>
        <trans-unit id="7e6df9fde9d9b1a6c24b6fde6ccfb6d951abd515" translate="yes" xml:space="preserve">
          <source>An existing tree object.</source>
          <target state="translated">一个现有的树对象。</target>
        </trans-unit>
        <trans-unit id="9c0f47829cd53aff363faaa441d2662f7d2a2298" translate="yes" xml:space="preserve">
          <source>An extended regular expression configuring a set of delta islands. See &quot;DELTA ISLANDS&quot; in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for details.</source>
          <target state="translated">配置一组增量岛的扩展正则表达式。有关详细信息，请参见&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]中的&lt;/a&gt; &amp;ldquo; DELTA ISLANDS&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="e8771c0542061da31756f7f028cf42efc80a6790" translate="yes" xml:space="preserve">
          <source>An integer -1..9, indicating a default compression level. -1 is the zlib default. 0 means no compression, and 1..9 are various speed/size tradeoffs, 9 being slowest. If set, this provides a default to other compression variables, such as &lt;code&gt;core.looseCompression&lt;/code&gt; and &lt;code&gt;pack.compression&lt;/code&gt;.</source>
          <target state="translated">整数-1..9，表示默认压缩级别。-1是zlib的默认值。0表示无压缩，而1..9是各种速度/大小的折衷方案，最慢的是9。如果设置，则为其他压缩变量提供默认值，例如 &lt;code&gt;core.looseCompression&lt;/code&gt; 和 &lt;code&gt;pack.compression&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="433b558671525ba8e4d4299bcca156947818bc47" translate="yes" xml:space="preserve">
          <source>An integer -1..9, indicating the compression level for objects in a pack file. -1 is the zlib default. 0 means no compression, and 1..9 are various speed/size tradeoffs, 9 being slowest. If not set, defaults to core.compression. If that is not set, defaults to -1, the zlib default, which is &quot;a default compromise between speed and compression (currently equivalent to level 6).&quot;</source>
          <target state="translated">一个整数 -1...9,表示压缩包文件中对象的压缩级别。-1是zlib的默认值,0表示不压缩,1...9是各种速度/大小的权衡,9是最慢的。0表示不压缩,1...9是各种速度/大小的折衷,9是最慢的。如果没有设置,默认为core.compression。如果不设置,默认为-1,即zlib默认值,这是 &quot;速度和压缩之间的默认折中值(目前相当于6级)&quot;。</target>
        </trans-unit>
        <trans-unit id="e06d94c2c1c7fdd4fbd64a16fb4219ebbe8c1e07" translate="yes" xml:space="preserve">
          <source>An integer -1..9, indicating the compression level for objects that are not in a pack file. -1 is the zlib default. 0 means no compression, and 1..9 are various speed/size tradeoffs, 9 being slowest. If not set, defaults to core.compression. If that is not set, defaults to 1 (best speed).</source>
          <target state="translated">一个整数-1...9,表示不在pack文件中的对象的压缩级别。-1是zlib的默认值。0表示不压缩,1...9是各种速度/大小的折衷,9是最慢的。如果没有设置,默认为core.compression。如果没有设置,默认为1(最佳速度)。</target>
        </trans-unit>
        <trans-unit id="7a8d9172fe4750854d99468288f15a393b3d2a0b" translate="yes" xml:space="preserve">
          <source>An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.</source>
          <target state="translated">一个整数参数指定一个截止百分比(默认为3%)。贡献小于这个百分比的目录不会显示在输出中。</target>
        </trans-unit>
        <trans-unit id="71479e10da1fa6d725307efac957175acd0b7dab" translate="yes" xml:space="preserve">
          <source>An integer port number to connect to on the server. Defaults to 143 for imap:// hosts and 993 for imaps:// hosts. Ignored when imap.tunnel is set.</source>
          <target state="translated">要连接到服务器上的整数端口号,对于imap://主机,默认为143,对于imaps://主机,默认为993。对于imap://主机,默认为143,对于imaps://主机,默认为993。设置imap.tunnel时忽略。</target>
        </trans-unit>
        <trans-unit id="a13bd69f2aba7e28daf03425a855478a0ac87c0e" translate="yes" xml:space="preserve">
          <source>An object to treat as the head of an unreachability trace.</source>
          <target state="translated">作为不可到达性跟踪头的对象。</target>
        </trans-unit>
        <trans-unit id="649450686ab487a5807b370d54f0bd2d0e6521d8" translate="yes" xml:space="preserve">
          <source>An offset within the jth packfile for the object.</source>
          <target state="translated">对象在jth packfile中的偏移量。</target>
        </trans-unit>
        <trans-unit id="13fd616698d842e6abe0ccbaaa14a722ac806da4" translate="yes" xml:space="preserve">
          <source>An optimized way to tell git &quot;all files have changed&quot; is to return the filename &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">告诉git&amp;ldquo;所有文件都已更改&amp;rdquo;的一种优化方法是返回文件名 &lt;code&gt;/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2683b05f238ac5f24ee58eef90d2e93c4d292853" translate="yes" xml:space="preserve">
          <source>An optional prefix &quot;&lt;code&gt;!&lt;/code&gt;&quot; which negates the pattern; any matching file excluded by a previous pattern will become included again. It is not possible to re-include a file if a parent directory of that file is excluded. Git doesn&amp;rsquo;t list excluded directories for performance reasons, so any patterns on contained files have no effect, no matter where they are defined. Put a backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;) in front of the first &quot;&lt;code&gt;!&lt;/code&gt;&quot; for patterns that begin with a literal &quot;&lt;code&gt;!&lt;/code&gt;&quot;, for example, &quot;&lt;code&gt;\!important!.txt&lt;/code&gt;&quot;.</source>
          <target state="translated">可选的前缀&amp;ldquo; &lt;code&gt;!&lt;/code&gt; &amp;rdquo;，用于否定模式；先前模式排除的所有匹配文件将再次包含在内。如果排除了该文件的父目录，则无法重新包含该文件。由于性能原因，Git不会列出被排除的目录，因此所包含文件上的任何模式均无效，无论它们在何处定义。对于以文字&amp;ldquo; &lt;code&gt;!&lt;/code&gt; &amp;rdquo; 开头的模式，例如&amp;ldquo; &lt;code&gt;\!important!.txt&lt;/code&gt; &amp;rdquo; ，在第一个&amp;ldquo; &lt;code&gt;!&lt;/code&gt; &amp;rdquo; 前面放置反斜杠（&amp;ldquo; &lt;code&gt;\&lt;/code&gt; &amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="72eb40b71a3ee1287d4bc59941eb7d52450fb0cd" translate="yes" xml:space="preserve">
          <source>An output line is formatted this way:</source>
          <target state="translated">输出行的格式是这样的。</target>
        </trans-unit>
        <trans-unit id="ec0a220b9a0ca7fed3c65efd073215d72dcdf226" translate="yes" xml:space="preserve">
          <source>An overview of recommended workflows with Git</source>
          <target state="translated">使用Git的推荐工作流程概述</target>
        </trans-unit>
        <trans-unit id="39328bc4d54c0b1f8244ab4fbfc2b0861f3ec8b7" translate="yes" xml:space="preserve">
          <source>An update will fail (without changing &amp;lt;ref&amp;gt;) if the current user is unable to create a new log file, append to the existing log file or does not have committer information available.</source>
          <target state="translated">如果当前用户无法创建新日志文件，追加到现有日志文件中或没有可用的提交者信息，则更新将失败（不更改&amp;lt;ref&amp;gt;）。</target>
        </trans-unit>
        <trans-unit id="dc6309284d4ffb9f9db9b99bb2400d242ab3d042" translate="yes" xml:space="preserve">
          <source>Ancillary Commands</source>
          <target state="translated">辅助命令</target>
        </trans-unit>
        <trans-unit id="690298b04d34764749d8b6b774f1017ccff2bdf1" translate="yes" xml:space="preserve">
          <source>And &quot;p4 branch -o branch1&quot; shows a View line that looks like:</source>
          <target state="translated">而 &quot;p4 branch -o branch1 &quot;显示的View行是这样的。</target>
        </trans-unit>
        <trans-unit id="06312e404b0eeaa83f6e7b08d3417e9f32eb7193" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;echo HEAD:link | git cat-file --batch --follow-symlinks&lt;/code&gt; would print the same thing, as would &lt;code&gt;HEAD:dir/link&lt;/code&gt;, as they both point at &lt;code&gt;HEAD:f&lt;/code&gt;.</source>
          <target state="translated">并 &lt;code&gt;echo HEAD:link | git cat-file --batch --follow-symlinks&lt;/code&gt; 将打印相同的内容，就像 &lt;code&gt;HEAD:dir/link&lt;/code&gt; 一样，因为它们都指向 &lt;code&gt;HEAD:f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8ef2a07032d9e5ab4fbc79e4cc5adecbcbea354" translate="yes" xml:space="preserve">
          <source>And after a few more steps like that, &quot;git bisect&quot; will eventually find a first bad commit:</source>
          <target state="translated">而经过这样的几步,&quot;git bisect &quot;最终会找到第一坏提交。</target>
        </trans-unit>
        <trans-unit id="5e2acfea5a7223f44ca9fe3e573c07079e7f8361" translate="yes" xml:space="preserve">
          <source>And even if a bisection fails today it tells us something valuable about the bug: that it&amp;rsquo;s non-deterministic - timing or kernel image layout dependent.</source>
          <target state="translated">即使今天对分失败了，它也告诉我们有关此错误的一些有价值的信息：它是不确定的-与时序或内核映像布局有关。</target>
        </trans-unit>
        <trans-unit id="85f0203157ace1141f1dde2ae30a3fa8a3636c88" translate="yes" xml:space="preserve">
          <source>And finally create the final commit.</source>
          <target state="translated">最后创建最后的提交。</target>
        </trans-unit>
        <trans-unit id="860e42dc488be31ffa7a020df965384765242565" translate="yes" xml:space="preserve">
          <source>And here is what Andreas said about this work-flow &lt;a href=&quot;#5&quot;&gt;[5]&lt;/a&gt;:</source>
          <target state="translated">这是Andreas对这个工作流程的评论&lt;a href=&quot;#5&quot;&gt;[5]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="01892e1eb858acb775eb9592a4003c7fc4445cdb" translate="yes" xml:space="preserve">
          <source>And if some bugs slip through your test suite, then you can add a test to your test suite. But if you want to use your new improved test suite to find where the bug slipped in, then you will either have to emulate a bisection process or you will perhaps bluntly test each commit backward starting from the &quot;bad&quot; commit you have which may be very wasteful.</source>
          <target state="translated">而如果一些bug从你的测试套件中溜走了,那么你可以在你的测试套件中增加一个测试。但是如果你想用你新改进的测试套件来找到bug溜进去的地方,那么你就必须模拟一个二分法的过程,或者你也许会直截了当地从你的 &quot;坏 &quot;提交开始向后测试每一个提交,这可能是非常浪费的。</target>
        </trans-unit>
        <trans-unit id="15b39a143fb8659118caee67f4b21c31bc36bf3c" translate="yes" xml:space="preserve">
          <source>And it is possible to replay it using:</source>
          <target state="translated">而且可以用重播。</target>
        </trans-unit>
        <trans-unit id="75822a1512d331a3d4633273030648c95f9328f4" translate="yes" xml:space="preserve">
          <source>And let&amp;rsquo;s take a commit X in the graph.</source>
          <target state="translated">让我们在图中进行一次提交X。</target>
        </trans-unit>
        <trans-unit id="f4b0d8092d1f5d252ea539a91373ab642092fc55" translate="yes" xml:space="preserve">
          <source>And move the first patch to the end of the list.</source>
          <target state="translated">并将第一个补丁移到列表的最后。</target>
        </trans-unit>
        <trans-unit id="43f0cc168dfe6f57e4c3a310a06a6b6b3c95713b" translate="yes" xml:space="preserve">
          <source>And of course you can combine all of these; the following finds commits since v2.5 which touch the &lt;code&gt;Makefile&lt;/code&gt; or any file under &lt;code&gt;fs&lt;/code&gt;:</source>
          <target state="translated">当然，您可以将所有这些结合起来。从v2.5版本开始，以下内容查找了涉及 &lt;code&gt;Makefile&lt;/code&gt; 或 &lt;code&gt;fs&lt;/code&gt; 下任何文件的提交：</target>
        </trans-unit>
        <trans-unit id="4c90b40159743f0c37c98cf280277c74b4f36f16" translate="yes" xml:space="preserve">
          <source>And testing can be done more often in special integration branches like linux-next for the linux kernel.</source>
          <target state="translated">而测试可以多在特殊的集成分支中进行,比如linux内核的linux-next。</target>
        </trans-unit>
        <trans-unit id="de647a064a0da49ca37de783bfbd65b321bef2ec" translate="yes" xml:space="preserve">
          <source>And then this is what Ingo Molnar (a well known Linux kernel developer) says about his use of git bisect:</source>
          <target state="translated">然后这是Ingo Molnar(一个很有名的Linux内核开发者)对他使用git bisect的评价。</target>
        </trans-unit>
        <trans-unit id="66491a56d29baec4b0beb6e367fe2e638c6cc60b" translate="yes" xml:space="preserve">
          <source>And then we can ask to see all the commits reachable from master but not from these other heads:</source>
          <target state="translated">然后我们可以要求查看所有从主控端可以接触到的提交,但从这些其他的头端却无法接触到。</target>
        </trans-unit>
        <trans-unit id="a65c6aab9ccb89445d5895ed004afd6ead95252c" translate="yes" xml:space="preserve">
          <source>And then:</source>
          <target state="translated">然后。</target>
        </trans-unit>
        <trans-unit id="dc5ba14bf614a8d9b59a130fcae6a5153ba0970b" translate="yes" xml:space="preserve">
          <source>And this is nice because at step 2) we compute number_of_ancestors(X) and so at step 3) we compute f(X).</source>
          <target state="translated">这很好,因为在第2步)我们计算了ncestors(X)的数量,所以在第3步)我们计算了f(X)。</target>
        </trans-unit>
        <trans-unit id="8cc4b2a34ee7e169dafe705c6dd15bf4f2ab80f2" translate="yes" xml:space="preserve">
          <source>And this is true because at step 1) b) we remove the ancestors of the &quot;good&quot; commits.</source>
          <target state="translated">这是真的,因为在步骤1)b)中,我们删除了 &quot;好 &quot;的提交的祖先。</target>
        </trans-unit>
        <trans-unit id="42d3703f66b9dc1860841e2625f510f6dad5a4b2" translate="yes" xml:space="preserve">
          <source>And this is where we create the &lt;code&gt;.git/refs/heads/master&lt;/code&gt; file which is pointed at by &lt;code&gt;HEAD&lt;/code&gt;. This file is supposed to contain the reference to the top-of-tree of the master branch, and since that&amp;rsquo;s exactly what &lt;code&gt;git commit-tree&lt;/code&gt; spits out, we can do this all with a sequence of simple shell commands:</source>
          <target state="translated">这就是我们创建 &lt;code&gt;HEAD&lt;/code&gt; 指向的 &lt;code&gt;.git/refs/heads/master&lt;/code&gt; 文件的地方。该文件应该包含对master分支的树顶的引用，并且由于这正是 &lt;code&gt;git commit-tree&lt;/code&gt; 吐出的内容，因此我们可以使用一系列简单的shell命令来完成所有操作：</target>
        </trans-unit>
        <trans-unit id="e7a1c872c4878ac6e52bac1154940404cb212eeb" translate="yes" xml:space="preserve">
          <source>And when we are finished we can use &quot;git bisect reset&quot; to go back to the branch we were in before we started bisecting:</source>
          <target state="translated">而当我们完成后,我们可以使用 &quot;git bisect reset &quot;来回到我们开始bisecting之前的分支。</target>
        </trans-unit>
        <trans-unit id="36ca616a13091cd678c7050cbd59b751c0ca0cb5" translate="yes" xml:space="preserve">
          <source>And yes it can happen in practice that people working on one branch are not aware that people working on another branch fixed a bug! It could also happen that F fixed more than one bug or that it is a revert of some big development effort that was not ready to be released.</source>
          <target state="translated">是的,在实践中可能会发生这样的情况:在一个分支上工作的人不知道在另一个分支上工作的人修复了一个bug!也可能发生F修复了一个以上的bug,或者它是对一些还没有准备好发布的大型开发工作的还原。也有可能发生的情况是,F修复了不止一个bug,或者它是一些大的开发工作的还原,但还没有准备好发布。</target>
        </trans-unit>
        <trans-unit id="dc2b5b20cbff6f0447bfb79a46815513c19063a1" translate="yes" xml:space="preserve">
          <source>And, as you can see with cat-file, this new entry refers to the current contents of the file:</source>
          <target state="translated">而且,正如你用cat-file可以看到的那样,这个新条目指的是文件的当前内容。</target>
        </trans-unit>
        <trans-unit id="a03f7e1dc1779f7a6b6058b743b6c59117c067d5" translate="yes" xml:space="preserve">
          <source>Annotate file lines with commit information</source>
          <target state="translated">用提交信息对文件行进行注释</target>
        </trans-unit>
        <trans-unit id="fe64bd304ff43d1f92c6b0e9e2636f5e1954515e" translate="yes" xml:space="preserve">
          <source>Annotate only the given line range. May be specified multiple times. Overlapping ranges are allowed.</source>
          <target state="translated">只对给定的行范围进行注释。可以指定多次。允许重叠的范围。</target>
        </trans-unit>
        <trans-unit id="68c2ff3ed69e66559e67604162ce24ef4a00bdf5" translate="yes" xml:space="preserve">
          <source>Annotate only the line range given by &lt;code&gt;&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;&lt;/code&gt;, or by the function name regex &lt;code&gt;&amp;lt;funcname&amp;gt;&lt;/code&gt;. May be specified multiple times. Overlapping ranges are allowed.</source>
          <target state="translated">仅注释由 &lt;code&gt;&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;&lt;/code&gt; 或函数名称regex &lt;code&gt;&amp;lt;funcname&amp;gt;&lt;/code&gt; 给出的行范围。可以指定多次。允许重叠范围。</target>
        </trans-unit>
        <trans-unit id="a4227402e63911eeddf3891b83571a9d301c5199" translate="yes" xml:space="preserve">
          <source>Annotated tags are meant for release while lightweight tags are meant for private or temporary object labels. For this reason, some git commands for naming objects (like &lt;code&gt;git describe&lt;/code&gt;) will ignore lightweight tags by default.</source>
          <target state="translated">带注释的标签用于释放，而轻量标签则用于私有或临时对象标签。因此，默认情况下，一些用于命名对象的git命令（例如 &lt;code&gt;git describe&lt;/code&gt; ）将忽略轻量级标签。</target>
        </trans-unit>
        <trans-unit id="fb074164892a20bb11edd02087ea8ad1467c6bc3" translate="yes" xml:space="preserve">
          <source>Annotated tags can be accidentally converted to lightweight tags, due to either of two issues:</source>
          <target state="translated">由于两个问题中的任何一个,注释标签可能会被意外地转换为轻量级标签。</target>
        </trans-unit>
        <trans-unit id="78661c20ec385a35ca13b1d1faa523521f8f6f6e" translate="yes" xml:space="preserve">
          <source>Annotates each line in the given file with information from the commit which introduced the line. Optionally annotates from a given revision.</source>
          <target state="translated">在给定的文件中,用引入该行的提交信息对每一行进行注释。可以选择从给定的修订版中进行注释。</target>
        </trans-unit>
        <trans-unit id="372eac78f459ab911a94fedbdc320e48ccdbf71b" translate="yes" xml:space="preserve">
          <source>Annotates each line in the given file with information from the revision which last modified the line. Optionally, start annotating from the given revision.</source>
          <target state="translated">在给定的文件中,用最后修改该行的版本信息对每一行进行注释。可以选择从给定的修订版开始注解。</target>
        </trans-unit>
        <trans-unit id="b09d247a13d19963c95ef0e9b47f19d8e2953d8d" translate="yes" xml:space="preserve">
          <source>Anonymize the contents of the repository while still retaining the shape of the history and stored tree. See the section on &lt;code&gt;ANONYMIZING&lt;/code&gt; below.</source>
          <target state="translated">匿名存储库的内容，同时仍保留历史记录和存储树的形状。请参阅下面有关 &lt;code&gt;ANONYMIZING&lt;/code&gt; 的部分。</target>
        </trans-unit>
        <trans-unit id="a01e013ecca5b260c6867926bf1ecfcf398d9ba1" translate="yes" xml:space="preserve">
          <source>Anonymizing</source>
          <target state="translated">Anonymizing</target>
        </trans-unit>
        <trans-unit id="40a85528d14ebc97736a92adba47c86eb9ff2aeb" translate="yes" xml:space="preserve">
          <source>Another example of --onto option is to rebase part of a branch. If we have the following situation:</source>
          <target state="translated">另一个使用--to选项的例子是对一个分支的一部分进行重垒。如果我们有以下情况。</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">另一个例子:</target>
        </trans-unit>
        <trans-unit id="11987472d58c6aa8430ac38a3fd3bf9cba4916dd" translate="yes" xml:space="preserve">
          <source>Another example: Find out what to do in order to make some script a builtin:</source>
          <target state="translated">另一个例子。找出该怎么做才能使一些脚本成为内置的。</target>
        </trans-unit>
        <trans-unit id="065628e1fb0324bb656fd86df1e08ab2f4715fb3" translate="yes" xml:space="preserve">
          <source>Another good idea is to have good commit messages. They can be very helpful to understand why some changes were made.</source>
          <target state="translated">另一个好主意是有好的提交信息。这些信息对于理解为什么要做一些修改是非常有帮助的。</target>
        </trans-unit>
        <trans-unit id="32dd386169e45600451de31b5f03542af4e30d00" translate="yes" xml:space="preserve">
          <source>Another nice thing you can do is:</source>
          <target state="translated">你可以做的另一件好事是。</target>
        </trans-unit>
        <trans-unit id="9242e709d07837df4600256193a227ac34a2269c" translate="yes" xml:space="preserve">
          <source>Another option is &quot;updateInstead&quot; which will update the working tree if pushing into the current branch. This option is intended for synchronizing working directories when one side is not easily accessible via interactive ssh (e.g. a live web site, hence the requirement that the working directory be clean). This mode also comes in handy when developing inside a VM to test and fix code on different Operating Systems.</source>
          <target state="translated">另一个选项是 &quot;updateInstead&quot;,如果推入当前分支,它将更新工作树。这个选项是为了在一方不方便通过交互式ssh访问时同步工作目录(例如一个实时网站,因此要求工作目录是干净的)。在虚拟机内开发时,这个模式也很方便,可以在不同的操作系统上测试和修复代码。</target>
        </trans-unit>
        <trans-unit id="41abbfafae0720017768935474ce8290c706a151" translate="yes" xml:space="preserve">
          <source>Another possible improvement to &quot;git bisect&quot; would be to optionally add some redundancy to the tests performed so that it would be more reliable when tracking sporadic bugs.</source>
          <target state="translated">对 &quot;git bisect &quot;的另一个可能的改进是在执行的测试中选择性地增加一些冗余,这样在跟踪零星bug时就会更可靠。</target>
        </trans-unit>
        <trans-unit id="0a6527778973bccd7f71c735f492db2e31da9fa5" translate="yes" xml:space="preserve">
          <source>Another special notation is &quot;&lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt;&amp;hellip;​&lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot; which is useful for merges. The resulting set of commits is the symmetric difference between the two operands. The following two commands are equivalent:</source>
          <target state="translated">另一个特殊的符号是&amp;ldquo; &lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt; ... &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt; &amp;rdquo;是用于合并有用的。提交的结果集是两个操作数之间的对称差。以下两个命令是等效的：</target>
        </trans-unit>
        <trans-unit id="26135d7c8f5f59da8beefa37e9b70a51b7cf91c1" translate="yes" xml:space="preserve">
          <source>Another tricky thing is fully repopulating the working directory when you no longer want sparse checkout. You cannot just disable &quot;sparse checkout&quot; because skip-worktree bits are still in the index and your working directory is still sparsely populated. You should re-populate the working directory with the &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; file content as follows:</source>
          <target state="translated">另一个棘手的事情是，当您不再需要稀疏签出时，完全重新填充工作目录。您不能仅禁用&amp;ldquo;稀疏签出&amp;rdquo;，因为skip-worktree位仍在索引中，并且您的工作目录仍是稀疏填充的。您应该使用 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 文件内容重新填充工作目录，如下所示：</target>
        </trans-unit>
        <trans-unit id="ecb7d4f32d7593e5037a022410f521fabccc479c" translate="yes" xml:space="preserve">
          <source>Another use of the content filtering is to store the content that cannot be directly used in the repository (e.g. a UUID that refers to the true content stored outside Git, or an encrypted content) and turn it into a usable form upon checkout (e.g. download the external content, or decrypt the encrypted content).</source>
          <target state="translated">内容过滤的另一个用途是将不能直接在版本库中使用的内容(如指存储在Git之外的真实内容的UUID,或加密内容)存储起来,并在结账时将其变成可用的形式(如下载外部内容,或解密加密内容)。</target>
        </trans-unit>
        <trans-unit id="1d8a0103b0697a268e7a45a45f3916e77fac0c3e" translate="yes" xml:space="preserve">
          <source>Another useful tool, especially if you do not always work in X-Window environment, is &lt;code&gt;git show-branch&lt;/code&gt;.</source>
          <target state="translated">另一个有用的工具是 &lt;code&gt;git show-branch&lt;/code&gt; ，特别是如果您不总是在X-Window环境中工作时。</target>
        </trans-unit>
        <trans-unit id="d7b5fb1eb9536e4fd859b841771a0add7272b354" translate="yes" xml:space="preserve">
          <source>Another way to collaborate is by using a model similar to that commonly used in CVS, where several developers with special rights all push to and pull from a single shared repository. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt; for instructions on how to set this up.</source>
          <target state="translated">协作的另一种方式是使用类似于CVS中常用的模型，在该模型中，具有特殊权限的几个开发人员都向一个共享存储库中推送和提取。有关如何设置的说明，请参见&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27bf2b0b2701454d4c7012f3aa28342f714d532f" translate="yes" xml:space="preserve">
          <source>Another way to submit changes to a project is to tell the maintainer of that project to pull the changes from your repository using &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;. In the section &quot;&lt;a href=&quot;#getting-updates-With-git-pull&quot;&gt;Getting updates with &lt;code&gt;git pull&lt;/code&gt;&lt;/a&gt;&quot; we described this as a way to get updates from the &quot;main&quot; repository, but it works just as well in the other direction.</source>
          <target state="translated">向项目提交更改的另一种方法是告诉项目的维护者使用&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;从存储库中提取更改。在&amp;ldquo; &lt;a href=&quot;#getting-updates-With-git-pull&quot;&gt;使用 &lt;code&gt;git pull&lt;/code&gt; &lt;/a&gt;获取更新 &amp;rdquo;部分中，我们将其描述为从&amp;ldquo;主&amp;rdquo;存储库获取更新的一种方式，但在另一个方向上也同样有效。</target>
        </trans-unit>
        <trans-unit id="85d232111ed1b21837987efa570715d6d841ade7" translate="yes" xml:space="preserve">
          <source>Any Git command accepting any &amp;lt;object&amp;gt; can also use the following symbolic notation:</source>
          <target state="translated">任何接受任何&amp;lt;object&amp;gt;的Git命令也可以使用以下符号表示法：</target>
        </trans-unit>
        <trans-unit id="2637aa3ab721e22e9e92fa0dc5c3b142c43c70b8" translate="yes" xml:space="preserve">
          <source>Any Git command that needs to know a commit can take any of these names. For example:</source>
          <target state="translated">任何需要了解提交情况的 Git 命令都可以使用这些名称。比如说</target>
        </trans-unit>
        <trans-unit id="17e0ecc60216ae45d014af4558855c0627e28395" translate="yes" xml:space="preserve">
          <source>Any URL that starts with this value will be rewritten to start, instead, with &amp;lt;base&amp;gt;. In cases where some site serves a large number of repositories, and serves them with multiple access methods, and some users need to use different access methods, this feature allows people to specify any of the equivalent URLs and have Git automatically rewrite the URL to the best alternative for the particular user, even for a never-before-seen repository on the site. When more than one insteadOf strings match a given URL, the longest match is used.</source>
          <target state="translated">以该值开头的所有URL都将改写为以&amp;lt;base&amp;gt;开头。如果某些站点提供大量存储库，并通过多种访问方法为它们提供服务，而某些用户需要使用不同的访问方法，则此功能允许用户指定任何等效的URL，并让Git自动将URL重写为特定用户的最佳选择，即使是网站上前所未有的存储库。如果有多个notOfOf字符串与给定的URL匹配，则使用最长的匹配。</target>
        </trans-unit>
        <trans-unit id="589cf27f168023444a88c2fd0201931be3237bfb" translate="yes" xml:space="preserve">
          <source>Any URL that starts with this value will not be pushed to; instead, it will be rewritten to start with &amp;lt;base&amp;gt;, and the resulting URL will be pushed to. In cases where some site serves a large number of repositories, and serves them with multiple access methods, some of which do not allow push, this feature allows people to specify a pull-only URL and have Git automatically use an appropriate URL to push, even for a never-before-seen repository on the site. When more than one pushInsteadOf strings match a given URL, the longest match is used. If a remote has an explicit pushurl, Git will ignore this setting for that remote.</source>
          <target state="translated">以该值开头的任何URL都不会被推送到；相反，它将被重写以&amp;lt;base&amp;gt;开头，并将结果URL推送到。如果某些站点提供大量存储库，并通过多种访问方法为它们提供服务，而其中某些访问方法不允许推送，则此功能使人们可以指定仅拉动的URL，并让Git自动使用适当的URL进行推送，即使是网站上从未见过的存储库。当多个pushInsteadOf字符串与给定URL匹配时，将使用最长的匹配项。如果一个遥控器有一个明确的pushurl，Git将忽略该遥控器的此设置。</target>
        </trans-unit>
        <trans-unit id="82a7e54a4e4438b5714cd3ea8d9c648126a4d9c8" translate="yes" xml:space="preserve">
          <source>Any arguments that control the behaviour of the action.</source>
          <target state="translated">任何控制动作行为的参数。</target>
        </trans-unit>
        <trans-unit id="90454bd170fd9408c974e42887247b5e22880026" translate="yes" xml:space="preserve">
          <source>Any commit messages that specify an encoding will become corrupted by the rewrite; git-filter-branch ignores the encoding, takes the original bytes, and feeds it to commit-tree without telling it the proper encoding. (This happens whether or not --msg-filter is used.)</source>
          <target state="translated">任何指定编码的提交消息都会被重写破坏;git-filter-branch会忽略编码,获取原始字节,并将其反馈给提交树,而不告诉它正确的编码。(无论是否使用--msg-filter,这种情况都会发生。)</target>
        </trans-unit>
        <trans-unit id="5b932d4d430aaf425c61def387b1d5f7272350dc" translate="yes" xml:space="preserve">
          <source>Any commits (or tags) that have already been marked will not be exported again. If the backend uses a similar --import-marks file, this allows for incremental bidirectional exporting of the repository by keeping the marks the same across runs.</source>
          <target state="translated">任何已经被标记的提交(或标记)将不会被再次导出。如果后端使用了类似的 --import-marks 文件,则可以通过在不同的运行中保持相同的标记来实现增量式双向导出版本库。</target>
        </trans-unit>
        <trans-unit id="f3f9b66d28d85d6e19fdb5a2a58f610b82508a43" translate="yes" xml:space="preserve">
          <source>Any corrupt objects you will have to find in backups or other archives (i.e., you can just remove them and do an &lt;code&gt;rsync&lt;/code&gt; with some other site in the hopes that somebody else has the object you have corrupted).</source>
          <target state="translated">您必须在备份或其他存档中找到任何损坏的对象（即，您可以删除它们并与其他站点进行 &lt;code&gt;rsync&lt;/code&gt; ，以希望其他人拥有您损坏的对象）。</target>
        </trans-unit>
        <trans-unit id="881f628d30dc8f906e6314a57d637b480027cf97" translate="yes" xml:space="preserve">
          <source>Any diff-generating command can take the &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;--cc&lt;/code&gt; option to produce a &lt;code&gt;combined diff&lt;/code&gt; when showing a merge. This is the default format when showing merges with &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; or &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;. Note also that you can give the &lt;code&gt;-m&lt;/code&gt; option to any of these commands to force generation of diffs with individual parents of a merge.</source>
          <target state="translated">显示合并时，任何diff生成命令都可以使用 &lt;code&gt;-c&lt;/code&gt; 或 &lt;code&gt;--cc&lt;/code&gt; 选项来生成 &lt;code&gt;combined diff&lt;/code&gt; 。当显示与&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;或&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;合并时，这是默认格式。还请注意，您可以为这些命令中的任何一个提供 &lt;code&gt;-m&lt;/code&gt; 选项，以强制使用合并的各个父项生成差异。</target>
        </trans-unit>
        <trans-unit id="693fa01c32bbb0a692d5b48b48158d26bcd64f81" translate="yes" xml:space="preserve">
          <source>Any line that is added in one location and was removed in another location will be colored with &lt;code&gt;color.diff.newMoved&lt;/code&gt;. Similarly &lt;code&gt;color.diff.oldMoved&lt;/code&gt; will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.</source>
          <target state="translated">在一个位置添加并在另一位置删除的任何行都将使用 &lt;code&gt;color.diff.newMoved&lt;/code&gt; 进行着色。同样， &lt;code&gt;color.diff.oldMoved&lt;/code&gt; 将用于在diff中其他位置添加的删除行。此模式可以拾取任何已移动的行，但是在查看是否确定代码块是否被正确排列的情况下，它并不是很有用。</target>
        </trans-unit>
        <trans-unit id="7e51f4c4f56de2a2384662213d8799137a1187ad" translate="yes" xml:space="preserve">
          <source>Any nontrivial feature will require several patches to implement, and may get extra bugfixes or improvements during its lifetime.</source>
          <target state="translated">任何非平凡的功能都需要几个补丁来实现,并且可能在其生命周期内得到额外的错误修复或改进。</target>
        </trans-unit>
        <trans-unit id="d98b5885c45b32a708919758a9a90750e9cf4885" translate="yes" xml:space="preserve">
          <source>Any object with modification time newer than the &lt;code&gt;--prune&lt;/code&gt; date is kept, along with everything reachable from it.</source>
          <target state="translated">保留修改时间比 &lt;code&gt;--prune&lt;/code&gt; 日期新的任何对象，以及所有可以到达的对象。</target>
        </trans-unit>
        <trans-unit id="57cde5a06f278fc117497921cb6730239da3eb9d" translate="yes" xml:space="preserve">
          <source>Any objects created by the &lt;code&gt;pre-receive&lt;/code&gt; hook will be created in the quarantine directory (and migrated only if it succeeds).</source>
          <target state="translated">由 &lt;code&gt;pre-receive&lt;/code&gt; 挂钩创建的任何对象都将在隔离目录中创建（并且仅在成功时迁移）。</target>
        </trans-unit>
        <trans-unit id="5f15852fd98f4e7d5fcff8be14576b9b3b53c8dc" translate="yes" xml:space="preserve">
          <source>Any of the credential.* options above can be applied selectively to some credentials. For example &quot;credential.https://example.com.username&quot; would set the default username only for https connections to example.com. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for details on how URLs are matched.</source>
          <target state="translated">可以将上述任何credential。*选项选择性地应用于某些凭据。例如，&amp;ldquo; credential.https：//example.com.username&amp;rdquo;将仅为与example.com的https连接设置默认用户名。有关如何匹配URL的详细信息，请参见&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bac0fc50e3c83a77179d2fb9959cd57efc236587" translate="yes" xml:space="preserve">
          <source>Any of the http.* options above can be applied selectively to some URLs. For a config key to match a URL, each element of the config key is compared to that of the URL, in the following order:</source>
          <target state="translated">上述http.*选项中的任何一个都可以选择性地应用于某些URL。为了使配置密钥与URL相匹配,配置密钥的每个元素都会与URL的元素进行比较,顺序如下。</target>
        </trans-unit>
        <trans-unit id="3dafc51d2498886776211f48626918bab9502059" translate="yes" xml:space="preserve">
          <source>Any other arguments are passed directly to &lt;code&gt;git log&lt;/code&gt;</source>
          <target state="translated">任何其他参数直接传递到 &lt;code&gt;git log&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41dff852ecf280a28625475c8607b0ee485f1ab1" translate="yes" xml:space="preserve">
          <source>Any other exit code will abort the bisect process. It should be noted that a program that terminates via &lt;code&gt;exit(-1)&lt;/code&gt; leaves $? = 255, (see the exit(3) manual page), as the value is chopped with &lt;code&gt;&amp;amp; 0377&lt;/code&gt;.</source>
          <target state="translated">任何其他退出代码将中止二等分过程。应该注意的是，通过 &lt;code&gt;exit(-1)&lt;/code&gt; 终止的程序会留下$?。= 255，（请参见exit（3）手册页），因为该值用 &lt;code&gt;&amp;amp; 0377&lt;/code&gt; 斩波了。</target>
        </trans-unit>
        <trans-unit id="642004f414daf9dcdfd792ec1198534a94bdecbe" translate="yes" xml:space="preserve">
          <source>Any other value causes Git to act as if &lt;code&gt;text&lt;/code&gt; has been left unspecified.</source>
          <target state="translated">任何其他值都会导致Git像未指定 &lt;code&gt;text&lt;/code&gt; 工作。</target>
        </trans-unit>
        <trans-unit id="c934a0e2885189af1607d7090f7bdedd35f47c56" translate="yes" xml:space="preserve">
          <source>Any submodule changes are reported as modified &lt;code&gt;M&lt;/code&gt; instead of &lt;code&gt;m&lt;/code&gt; or single &lt;code&gt;?&lt;/code&gt;.</source>
          <target state="translated">任何子模块更改都报告为已修改 &lt;code&gt;M&lt;/code&gt; 而不是 &lt;code&gt;m&lt;/code&gt; 或单个 &lt;code&gt;?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c7f540cc43682f246f3211715ad8ff43ff2cc9b" translate="yes" xml:space="preserve">
          <source>Any valid Git SHA-1 expression that resolves to a commit. See &amp;ldquo;SPECIFYING REVISIONS&amp;rdquo; in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details.</source>
          <target state="translated">任何可解析为提交的有效Git SHA-1表达式。有关详细信息，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]中的&lt;/a&gt; &amp;ldquo;指定版本&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="f7d956d491ba987cc8588aff431085dc6fef94e0" translate="yes" xml:space="preserve">
          <source>Anyway &quot;git rebase&quot; can be used to linearize history. This can be used either to avoid merging in the first place. Or it can be used to bisect on a linear history instead of the non linear one, as this should give more information in case of a semantic change in one branch.</source>
          <target state="translated">总之 &quot;git rebase &quot;可以用来线性化历史。这可以用来避免在第一时间进行合并。或者,它可以用来在线性历史上进行二分,而不是在非线性历史上进行二分,因为在一个分支发生语义变化的情况下,这应该会提供更多信息。</target>
        </trans-unit>
        <trans-unit id="0e59b76f5bd0befb4dbe4de65fbbfc975d414db1" translate="yes" xml:space="preserve">
          <source>Anyway one can notice in the above special branch example that the Z' and Z commits should point to the same source code state (the same &quot;tree&quot; in git parlance). That&amp;rsquo;s because Z' result from applying the same changes as Z just in a slightly different order.</source>
          <target state="translated">无论如何，可以在上面的特殊分支示例中注意到Z'和Z提交应指向相同的源代码状态（在git术语中为相同的&amp;ldquo;树&amp;rdquo;）。这是因为Z'是由于应用与Z相同的更改（只是顺序略有不同）而产生的。</target>
        </trans-unit>
        <trans-unit id="b6009c11bd52cccb479f468a5d30bb80204ccc20" translate="yes" xml:space="preserve">
          <source>Anyway, as we mentioned previously, you normally never actually take a look at the objects themselves, and typing long 40-character hex names is not something you&amp;rsquo;d normally want to do. The above digression was just to show that &lt;code&gt;git update-index&lt;/code&gt; did something magical, and actually saved away the contents of your files into the Git object database.</source>
          <target state="translated">无论如何，正如我们之前提到的，通常您通常不会真正查看对象本身，并且通常不希望输入40个字符的十六进制长名称。上面的论述只是为了说明 &lt;code&gt;git update-index&lt;/code&gt; 做了一些神奇的事情，实际上将文件内容保存到了Git对象数据库中。</target>
        </trans-unit>
        <trans-unit id="868e50b230265adc5a12e0fabfef64c97f0dfb44" translate="yes" xml:space="preserve">
          <source>Anyway, let&amp;rsquo;s exit &lt;code&gt;gitk&lt;/code&gt; (&lt;code&gt;^Q&lt;/code&gt; or the File menu), and decide that we want to merge the work we did on the &lt;code&gt;mybranch&lt;/code&gt; branch into the &lt;code&gt;master&lt;/code&gt; branch (which is currently our &lt;code&gt;HEAD&lt;/code&gt; too). To do that, there&amp;rsquo;s a nice script called &lt;code&gt;git merge&lt;/code&gt;, which wants to know which branches you want to resolve and what the merge is all about:</source>
          <target state="translated">无论如何，让我们退出 &lt;code&gt;gitk&lt;/code&gt; （ &lt;code&gt;^Q&lt;/code&gt; 或&amp;ldquo;文件&amp;rdquo;菜单），并决定我们要将合并在 &lt;code&gt;mybranch&lt;/code&gt; 分支上所做的工作合并到 &lt;code&gt;master&lt;/code&gt; 分支（当前也是 &lt;code&gt;HEAD&lt;/code&gt; ）中。为此，有一个不错的脚本 &lt;code&gt;git merge&lt;/code&gt; ，它想要知道您要解析的分支以及合并的全部内容：</target>
        </trans-unit>
        <trans-unit id="4dd4f1d29aada84809b848ed1f3cfeec94f509cd" translate="yes" xml:space="preserve">
          <source>Anyway, once you are sure that you&amp;rsquo;re not interested in any dangling state, you can just prune all unreachable objects:</source>
          <target state="translated">无论如何，一旦确定对任何悬挂状态都不感兴趣，就可以修剪所有无法到达的对象：</target>
        </trans-unit>
        <trans-unit id="0af8b356773c7cf5ba56c2406453ade92d5ac3c1" translate="yes" xml:space="preserve">
          <source>Apache 2.x</source>
          <target state="translated">Apache 2.x</target>
        </trans-unit>
        <trans-unit id="62093635aebe85cb9943f4c0313c4cb13ae431e5" translate="yes" xml:space="preserve">
          <source>Apache as CGI</source>
          <target state="translated">Apache作为CGI</target>
        </trans-unit>
        <trans-unit id="fcf355a3b504d322d867b3a7779ff63edb5eff93" translate="yes" xml:space="preserve">
          <source>Apache must be configured to support CGI scripts in the directory in which gitweb is installed. Let&amp;rsquo;s assume that it is &lt;code&gt;/var/www/cgi-bin&lt;/code&gt; directory.</source>
          <target state="translated">必须在安装gitweb的目录中将Apache配置为支持CGI脚本。假设它是 &lt;code&gt;/var/www/cgi-bin&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="adce44ce9fd05dba8366c6738436e24094334a46" translate="yes" xml:space="preserve">
          <source>Apache with FastCGI</source>
          <target state="translated">Apache与FastCGI</target>
        </trans-unit>
        <trans-unit id="154d9ee4c57b9c60297467031aab475139a92de6" translate="yes" xml:space="preserve">
          <source>Apache with mod_perl, via ModPerl::Registry</source>
          <target state="translated">使用mod_perl的Apache,通过ModPerl::Registry。</target>
        </trans-unit>
        <trans-unit id="0e7319c6d9f1793811603c0e586a372fe36cd4e3" translate="yes" xml:space="preserve">
          <source>Apart from supporting file annotation, Git also supports searching the development history for when a code snippet occurred in a change. This makes it possible to track when a code snippet was added to a file, moved or copied between files, and eventually deleted or replaced. It works by searching for a text string in the diff. A small example of the pickaxe interface that searches for &lt;code&gt;blame_usage&lt;/code&gt;:</source>
          <target state="translated">除了支持文件注释外，Git还支持搜索开发历史记录以查找代码段在更改中何时发生。这样就可以跟踪何时将代码段添加到文件，在文件之间移动或复制以及最终删除或替换。它通过在diff中搜索文本字符串来工作。一个用于搜索 &lt;code&gt;blame_usage&lt;/code&gt; 的镐接口的小例子：</target>
        </trans-unit>
        <trans-unit id="0d7464dc71494394ceb8bfdacf997c37cf7b2fe0" translate="yes" xml:space="preserve">
          <source>Append &quot;exec &amp;lt;cmd&amp;gt;&quot; after each line creating a commit in the final history. &amp;lt;cmd&amp;gt; will be interpreted as one or more shell commands. Any command that fails will interrupt the rebase, with exit code 1.</source>
          <target state="translated">在最终历史记录中创建提交的每一行之后，添加&amp;ldquo; exec &amp;lt;cmd&amp;gt;&amp;rdquo;。&amp;lt;cmd&amp;gt;将被解释为一个或多个shell命令。任何失败的命令都将以退出代码1中断重新定位。</target>
        </trans-unit>
        <trans-unit id="ef04cef4b0401f57059733c71c586ba695e16618" translate="yes" xml:space="preserve">
          <source>Append ref names and object names of fetched refs to the existing contents of &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt;. Without this option old data in &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; will be overwritten.</source>
          <target state="translated">将获取的引用的引用名称和对象名称追加到 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 的现有内容中。如果没有此选项， &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 中的旧数据将被覆盖。</target>
        </trans-unit>
        <trans-unit id="94dedcc5d01b91b42b1e3ae2801d2b001bfa9291" translate="yes" xml:space="preserve">
          <source>Append the notes (see &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;) for the commit after the three-dash line.</source>
          <target state="translated">在三点划线后附加注释（请参阅&lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt;）以进行提交。</target>
        </trans-unit>
        <trans-unit id="60b0cf67b9a78690ab42bf05c5a970037b617230" translate="yes" xml:space="preserve">
          <source>Append this string to each commit message. Set to empty string to disable this feature. Defaults to &quot;via git-CVS emulator&quot;.</source>
          <target state="translated">将此字符串添加到每个提交消息中。设为空则禁用此功能。默认为 &quot;通过 git-CVS 模拟器&quot;。</target>
        </trans-unit>
        <trans-unit id="2373a40d8b684d9b213d526a29e87b69fa3f0b45" translate="yes" xml:space="preserve">
          <source>Append to the notes of an existing object (defaults to HEAD). Creates a new notes object if needed.</source>
          <target state="translated">附加到现有对象的注释中(默认为HEAD)。如果需要,创建一个新的笔记对象。</target>
        </trans-unit>
        <trans-unit id="64fff387ef07a8a383c37886a7516866c065d733" translate="yes" xml:space="preserve">
          <source>Appendix a: git quick reference</source>
          <target state="translated">附录a:git快速参考</target>
        </trans-unit>
        <trans-unit id="505428ce9360d60afb175c3a83b181da98dfd5f0" translate="yes" xml:space="preserve">
          <source>Appendix b: notes and todo list for this manual</source>
          <target state="translated">附录b:本手册的说明和待办事项清单</target>
        </trans-unit>
        <trans-unit id="0cd05b54bd7b3a6c1bc46851a5cc57ae9e4714f4" translate="yes" xml:space="preserve">
          <source>Applies a quilt patchset onto the current Git branch, preserving the patch boundaries, patch order, and patch descriptions present in the quilt patchset.</source>
          <target state="translated">将拼布补丁集应用到当前 Git 分支上,保留拼布补丁集中的补丁边界、补丁顺序和补丁描述。</target>
        </trans-unit>
        <trans-unit id="a7cac5d66c52938bbdbd6bb2ccc1b2a1e469d6e9" translate="yes" xml:space="preserve">
          <source>Applies a quilt patchset onto the current branch</source>
          <target state="translated">在当前分支上应用拼布补丁集。</target>
        </trans-unit>
        <trans-unit id="0ace5fe552ca52b3206a5bd3ee6c81166a6d4e30" translate="yes" xml:space="preserve">
          <source>Apply a commit to the p4 workspace, opening, adding and deleting files in p4 as for a normal submit operation. Do not issue the final &quot;p4 submit&quot;, but instead print a message about how to submit manually or revert. This option always stops after the first (oldest) commit. Git tags are not exported to p4.</source>
          <target state="translated">向p4工作区应用提交,像正常的提交操作一样在p4中打开、添加和删除文件。不要发出最终的 &quot;p4提交&quot;,而是打印一条关于如何手动提交或恢复的消息。这个选项总是在第一个(最老的)提交之后停止。Git 标签不会被导出到 p4 中。</target>
        </trans-unit>
        <trans-unit id="48f2321ef5db21359607b635bc37d95c3c3f6949" translate="yes" xml:space="preserve">
          <source>Apply a patch to files and/or to the index</source>
          <target state="translated">为文件和/或索引打上补丁</target>
        </trans-unit>
        <trans-unit id="bd267fa176f80df21611314430fb619c6c0ca823" translate="yes" xml:space="preserve">
          <source>Apply a patch without touching the working tree. Instead take the cached data, apply the patch, and store the result in the index without using the working tree. This implies &lt;code&gt;--index&lt;/code&gt;.</source>
          <target state="translated">贴上补丁而不碰到工作树。取而代之的是获取缓存的数据，应用补丁，然后将结果存储在索引中，而无需使用工作树。这意味着 &lt;code&gt;--index&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e6f2e44329517aef587c18d6b7620bb801018d0" translate="yes" xml:space="preserve">
          <source>Apply a series of patches from a mailbox</source>
          <target state="translated">从邮箱中应用一系列补丁。</target>
        </trans-unit>
        <trans-unit id="7e0339ba7940213ee941e0cfb4df5c765eb525b6" translate="yes" xml:space="preserve">
          <source>Apply changes to files matching the given path pattern. This can be useful when importing patchsets, where you want to include certain files or directories.</source>
          <target state="translated">将更改应用到与给定路径模式相匹配的文件。这在导入补丁集时很有用,因为你想包含某些文件或目录。</target>
        </trans-unit>
        <trans-unit id="62ad9c2cc3b0c429c18e394c154429c6601a33bc" translate="yes" xml:space="preserve">
          <source>Apply it:</source>
          <target state="translated">应用它。</target>
        </trans-unit>
        <trans-unit id="9537fc12221a208866b0d5f4bdeb3c72a1e2302e" translate="yes" xml:space="preserve">
          <source>Apply the &quot;clean&quot; process freshly to all tracked files to forcibly add them again to the index. This is useful after changing &lt;code&gt;core.autocrlf&lt;/code&gt; configuration or the &lt;code&gt;text&lt;/code&gt; attribute in order to correct files added with wrong CRLF/LF line endings. This option implies &lt;code&gt;-u&lt;/code&gt;.</source>
          <target state="translated">对所有跟踪的文件重新进行&amp;ldquo;干净&amp;rdquo;处理，以将其再次强制添加到索引中。在更改 &lt;code&gt;core.autocrlf&lt;/code&gt; 配置或 &lt;code&gt;text&lt;/code&gt; 属性后，此功能很有用，以便更正添加有错误CRLF / LF行尾的文件。此选项暗含 &lt;code&gt;-u&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3387547d9c3f57336c6769472fbdaa2f41d8d54e" translate="yes" xml:space="preserve">
          <source>Apply the change introduced by the commit at the tip of the master branch and create a new commit with this change.</source>
          <target state="translated">应用主分支顶端的提交所带来的变化,并以此为基础创建一个新的提交。</target>
        </trans-unit>
        <trans-unit id="dcad7381c75ab9bcebba4ec36c60788e21cc232d" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by all commits on the master branch that touched README to the working tree and index, so the result can be inspected and made into a single new commit if suitable.</source>
          <target state="translated">将主分支上触及README的所有提交引入的修改应用到工作树和索引中,这样就可以检查结果,并在合适的情况下将其变成一个新的提交。</target>
        </trans-unit>
        <trans-unit id="0cd6111442f7f7c96f0cf43ef692ab3fd0aeaf35" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by all commits that are ancestors of maint or next, but not master or any of its ancestors. Note that the latter does not mean &lt;code&gt;maint&lt;/code&gt; and everything between &lt;code&gt;master&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;; specifically, &lt;code&gt;maint&lt;/code&gt; will not be used if it is included in &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">应用由maint或next的祖先提交的所有提交（而不是master或其任何祖先）提交的更改。注意后者并不意味着 &lt;code&gt;maint&lt;/code&gt; 以及 &lt;code&gt;master&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 之间的一切; 具体地， &lt;code&gt;maint&lt;/code&gt; 如果它被包括在将不被使用 &lt;code&gt;master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93bf7e7b652d09afeef199594d1b407f0e89fdfa" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by all commits that are ancestors of master but not of HEAD to produce new commits.</source>
          <target state="translated">应用作为master祖先但不是head祖先的所有提交所带来的变化来产生新的提交。</target>
        </trans-unit>
        <trans-unit id="267d59350d3cc9c55b8eac43fb7124a86e3e2e8d" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by some existing commits</source>
          <target state="translated">应用一些现有的提交所带来的变化</target>
        </trans-unit>
        <trans-unit id="4483cddab281b7008c2024c5cf39c925a712d6f4" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by the fifth and third last commits pointed to by master and create 2 new commits with these changes.</source>
          <target state="translated">应用master指向的第5次和第3次提交所带来的变化,并利用这些变化创建2个新的提交。</target>
        </trans-unit>
        <trans-unit id="32e6df839ae5866b7658a0152bc89b8703c2e9dc" translate="yes" xml:space="preserve">
          <source>Apply the patch in reverse.</source>
          <target state="translated">反过来敷贴。</target>
        </trans-unit>
        <trans-unit id="2a3b720a1d345274dfcc30d6bb5718ba5a7d893c" translate="yes" xml:space="preserve">
          <source>Apply the patch to both the index and the working tree (or merely check that it would apply cleanly to both if &lt;code&gt;--check&lt;/code&gt; is in effect). Note that &lt;code&gt;--index&lt;/code&gt; expects index entries and working tree copies for relevant paths to be identical (their contents and metadata such as file mode must match), and will raise an error if they are not, even if the patch would apply cleanly to both the index and the working tree in isolation.</source>
          <target state="translated">将补丁同时应用到索引和工作树（或者仅检查它是否适用于 &lt;code&gt;--check&lt;/code&gt; 生效的情况）。请注意，-- &lt;code&gt;--index&lt;/code&gt; 期望相关路径的索引条目和工作树副本是相同的（它们的内容和元数据（例如文件模式）必须匹配），并且如果它们不匹配，即使补丁会干净地应用于两者，它们也会引发错误。索引和孤立的工作树。</target>
        </trans-unit>
        <trans-unit id="23e8468c7e010cf39f5023f4c74def3832e8706a" translate="yes" xml:space="preserve">
          <source>Apply the patch to just the index, without touching the working tree. If &lt;code&gt;--check&lt;/code&gt; is in effect, merely check that it would apply cleanly to the index entry.</source>
          <target state="translated">将补丁仅应用到索引，而不接触工作树。如果 &lt;code&gt;--check&lt;/code&gt; 有效，则仅检查它是否可以干净地应用于索引条目。</target>
        </trans-unit>
        <trans-unit id="88f8070d0672eae136d921241ac9866b7f235114" translate="yes" xml:space="preserve">
          <source>Apply the specified refspec to each ref exported. Multiple of them can be specified.</source>
          <target state="translated">将指定的 refspec 应用于导出的每个 ref。可以指定多个refspec。</target>
        </trans-unit>
        <trans-unit id="7fd7e8ac68a94d08f0fdbfcbab3475962ee42209" translate="yes" xml:space="preserve">
          <source>Apply to the working tree and the index the changes introduced by the second last commit pointed to by master and by the last commit pointed to by next, but do not create any commit with these changes.</source>
          <target state="translated">将master指向的第二个最后提交和next指向的最后一个提交所带来的变化应用到工作树和索引中,但不使用这些变化创建任何提交。</target>
        </trans-unit>
        <trans-unit id="0cd32c5cf17ab15de02490afcc460874d487a4cd" translate="yes" xml:space="preserve">
          <source>Applying the state can fail with conflicts; in this case, it is not removed from the stash list. You need to resolve the conflicts by hand and call &lt;code&gt;git stash drop&lt;/code&gt; manually afterwards.</source>
          <target state="translated">应用状态可能会因冲突而失败；在这种情况下，它不会从存储列表中删除。您需要手动解决冲突，然后手动调用 &lt;code&gt;git stash drop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="956519c248d491798436fec0428abbdf91cbc909" translate="yes" xml:space="preserve">
          <source>Approach #1 (add-on)</source>
          <target state="translated">办法1(附加)</target>
        </trans-unit>
        <trans-unit id="57f019c85346bddb5f41fba94e7c74787f47bd0d" translate="yes" xml:space="preserve">
          <source>Approach #2 (configuration)</source>
          <target state="translated">办法2(配置)</target>
        </trans-unit>
        <trans-unit id="bb297e0ad30a52de0d35c2e51c324455cc5006ef" translate="yes" xml:space="preserve">
          <source>Approach #3 (external editor)</source>
          <target state="translated">办法3(外部编辑)</target>
        </trans-unit>
        <trans-unit id="6a4c02b7a9497dd0187742b95b941fbc3f472c18" translate="yes" xml:space="preserve">
          <source>Arbitrary extended SHA-1 expression (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;) that typically names a branch head or a tag.</source>
          <target state="translated">任意扩展的SHA-1表达式（请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;），通常用于命名分支头或标签。</target>
        </trans-unit>
        <trans-unit id="99d8ff22bcfacdaff98940313c6f7a07ddd4cf65" translate="yes" xml:space="preserve">
          <source>Archive/branch identifier in a format that &lt;code&gt;tla log&lt;/code&gt; understands.</source>
          <target state="translated">归档/分支标识符，采用 &lt;code&gt;tla log&lt;/code&gt; 可以理解的格式。</target>
        </trans-unit>
        <trans-unit id="872da414bff0647443183643c537cf06ff00de53" translate="yes" xml:space="preserve">
          <source>Argument --depth specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history.</source>
          <target state="translated">参数-深度指定从当前浅层边界提交的次数,而不是从每个远程分支历史记录的顶端提交的次数。</target>
        </trans-unit>
        <trans-unit id="5f7cc8b7282309c04b6094d3e942d3596636318c" translate="yes" xml:space="preserve">
          <source>Argument disambiguation</source>
          <target state="translated">辩论的歧义</target>
        </trans-unit>
        <trans-unit id="fd50e821541e889c251a37edf6c132e6475912dc" translate="yes" xml:space="preserve">
          <source>Arguments for &lt;code&gt;git rev-list&lt;/code&gt;. All positive refs included by these options are rewritten. You may also specify options such as &lt;code&gt;--all&lt;/code&gt;, but you must use &lt;code&gt;--&lt;/code&gt; to separate them from the &lt;code&gt;git filter-branch&lt;/code&gt; options. Implies &lt;a href=&quot;#Remap_to_ancestor&quot;&gt;Remap to ancestor&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git rev-list&lt;/code&gt; 的参数。这些选项包括的所有正参考均被重写。您还可以指定 &lt;code&gt;--all&lt;/code&gt; 之类的选项，但必须使用 &lt;code&gt;--&lt;/code&gt; 将其与 &lt;code&gt;git filter-branch&lt;/code&gt; 选项分开。暗示重新&lt;a href=&quot;#Remap_to_ancestor&quot;&gt;映射到祖先&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="345e43f16973168887e556514ee57c8062a62d30" translate="yes" xml:space="preserve">
          <source>Arranges for fast-import to save a reference to the current object, allowing the frontend to recall this object at a future point in time, without knowing its SHA-1. Here the current object is the object creation command the &lt;code&gt;mark&lt;/code&gt; command appears within. This can be &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;, and &lt;code&gt;blob&lt;/code&gt;, but &lt;code&gt;commit&lt;/code&gt; is the most common usage.</source>
          <target state="translated">安排快速导入以保存对当前对象的引用，从而使前端可以在将来的某个时间点撤回该对象，而无需知道其SHA-1。这里的当前对象是 &lt;code&gt;mark&lt;/code&gt; 命令出现在其中的对象创建命令。可以是 &lt;code&gt;commit&lt;/code&gt; ， &lt;code&gt;tag&lt;/code&gt; 和 &lt;code&gt;blob&lt;/code&gt; ，但是 &lt;code&gt;commit&lt;/code&gt; 是最常见的用法。</target>
        </trans-unit>
        <trans-unit id="63f07e2039af4b87f8fad3f523ac66820be39017" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;LF&lt;/code&gt; is not valid in a Git refname or SHA-1 expression, no quoting or escaping syntax is supported within &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">由于 &lt;code&gt;LF&lt;/code&gt; 在Git refname或SHA-1表达式中无效，因此 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 中不支持引号或转义语法。</target>
        </trans-unit>
        <trans-unit id="41e120dada68dd444b90dd5ea02098a2591a6678" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;checkpoint&lt;/code&gt; can require a significant amount of CPU time and disk IO (to compute the overall pack SHA-1 checksum, generate the corresponding index file, and update the refs) it can easily take several minutes for a single &lt;code&gt;checkpoint&lt;/code&gt; command to complete.</source>
          <target state="translated">由于一个 &lt;code&gt;checkpoint&lt;/code&gt; 可能需要大量的CPU时间和磁盘IO（以计算整体数据包SHA-1校验和，生成相应的索引文件并更新引用），因此单个 &lt;code&gt;checkpoint&lt;/code&gt; 命令很容易需要几分钟才能完成。</target>
        </trans-unit>
        <trans-unit id="166a62b6eeb6f3f2dc7d402191cdcd8e406a0b0d" translate="yes" xml:space="preserve">
          <source>As a consequence, if you want to merge two long-lived branches repeatedly, it&amp;rsquo;s best to always use a regular merge commit.</source>
          <target state="translated">因此，如果要重复合并两个长期分支，则最好始终使用常规合并提交。</target>
        </trans-unit>
        <trans-unit id="cdb295aae55f7fada69cf590bc90ed14f2b247f0" translate="yes" xml:space="preserve">
          <source>As a consequence, the &lt;code&gt;merge base&lt;/code&gt; is not necessarily contained in each of the commit arguments if more than two commits are specified. This is different from &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; when used with the &lt;code&gt;--merge-base&lt;/code&gt; option.</source>
          <target state="translated">因此，如果指定了两个以上的提交，则 &lt;code&gt;merge base&lt;/code&gt; 不一定包含在每个提交参数中。与 &lt;code&gt;--merge-base&lt;/code&gt; 选项一起使用时，这与&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt;不同。</target>
        </trans-unit>
        <trans-unit id="dbf2a4b63177a116bbc3cf47e4c27a09d7f0ef0f" translate="yes" xml:space="preserve">
          <source>As a convenience measure, &lt;code&gt;git merge&lt;/code&gt; automatically invokes &lt;code&gt;git rerere&lt;/code&gt; upon exiting with a failed automerge and &lt;code&gt;git rerere&lt;/code&gt; records the hand resolve when it is a new conflict, or reuses the earlier hand resolve when it is not. &lt;code&gt;git commit&lt;/code&gt; also invokes &lt;code&gt;git rerere&lt;/code&gt; when committing a merge result. What this means is that you do not have to do anything special yourself (besides enabling the rerere.enabled config variable).</source>
          <target state="translated">作为一种便利措施， &lt;code&gt;git merge&lt;/code&gt; 在退出时会自动调用 &lt;code&gt;git rerere&lt;/code&gt; ，但自动合并失败，并且 &lt;code&gt;git rerere&lt;/code&gt; 在新的冲突发生时记录手解析，或者在不存在冲突时重用较早的手解析。 &lt;code&gt;git commit&lt;/code&gt; 合并结果时，git commit还调用 &lt;code&gt;git rerere&lt;/code&gt; 。这意味着您不必自己做任何特别的事情（除了启用rerere.enabled配置变量外）。</target>
        </trans-unit>
        <trans-unit id="152aaf1da15e40e4974ab4fba1bc2c82b319de92" translate="yes" xml:space="preserve">
          <source>As a general rule, you should try to split your changes into small logical steps, and commit each of them. They should be consistent, working independently of any later commits, pass the test suite, etc. This makes the review process much easier, and the history much more useful for later inspection and analysis, for example with &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; and &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt;.</source>
          <target state="translated">通常，您应该尝试将更改分成较小的逻辑步骤，然后提交每个步骤。它们应保持一致，独立于以后的任何提交，通过测试套件等。这使得检查过程更加容易，并且历史记录对于以后的检查和分析也更加有用，例如使用&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;和&lt;a href=&quot;git-bisect&quot;&gt;git -bisect [1]&lt;/a&gt;。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
