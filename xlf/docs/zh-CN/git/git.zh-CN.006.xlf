<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="b4b929406272978e9913bc69bd98a25fedb2b075" translate="yes" xml:space="preserve">
          <source>If generating diffs, detect and report renames for each commit. For following files across renames while traversing history, see &lt;code&gt;--follow&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file&amp;rsquo;s size). For example, &lt;code&gt;-M90%&lt;/code&gt; means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn&amp;rsquo;t changed. Without a &lt;code&gt;%&lt;/code&gt; sign, the number is to be read as a fraction, with a decimal point before it. I.e., &lt;code&gt;-M5&lt;/code&gt; becomes 0.5, and is thus the same as &lt;code&gt;-M50%&lt;/code&gt;. Similarly, &lt;code&gt;-M05&lt;/code&gt; is the same as &lt;code&gt;-M5%&lt;/code&gt;. To limit detection to exact renames, use &lt;code&gt;-M100%&lt;/code&gt;. The default similarity index is 50%.</source>
          <target state="translated">如果生成差异，请检测并报告每次提交的重命名。有关在历史记录中遍历重命名文件的信息，请参阅 &lt;code&gt;--follow&lt;/code&gt; 。如果指定了 &lt;code&gt;n&lt;/code&gt; ，则它是相似性索引的阈值（即，与文件大小相比增加/删除的数量）。例如， &lt;code&gt;-M90%&lt;/code&gt; 表示如果文件的90％以上没有更改，则 Git应该将删除/添加对视为重命名。如果没有 &lt;code&gt;%&lt;/code&gt; 符号，则该数字应作为分数读取，并在其前面加上小数点。即， &lt;code&gt;-M5&lt;/code&gt; 变为0.5，因此与 &lt;code&gt;-M50%&lt;/code&gt; 相同。同样， &lt;code&gt;-M05&lt;/code&gt; 与 &lt;code&gt;-M5%&lt;/code&gt; 相同。要将检测限制为完全重命名，请使用 &lt;code&gt;-M100%&lt;/code&gt; 。默认相似度索引为50％。</target>
        </trans-unit>
        <trans-unit id="6bf34c88ee2af8f797d0000ddc97681383ffc8ba" translate="yes" xml:space="preserve">
          <source>If git fetch fails because the new head of a branch is not a descendant of the old head, you may force the update with:</source>
          <target state="translated">如果 git fetch 失败,因为一个分支的新头不是旧头的后裔,你可以用以下方法强制更新。</target>
        </trans-unit>
        <trans-unit id="e083719ea272a39b1421c558e4392c556db2e4ef" translate="yes" xml:space="preserve">
          <source>If given &lt;code&gt;--thread&lt;/code&gt;, &lt;code&gt;git-format-patch&lt;/code&gt; will generate &lt;code&gt;In-Reply-To&lt;/code&gt; and &lt;code&gt;References&lt;/code&gt; headers to make the second and subsequent patch mails appear as replies to the first mail; this also generates a &lt;code&gt;Message-Id&lt;/code&gt; header to reference.</source>
          <target state="translated">如果给定了 &lt;code&gt;--thread&lt;/code&gt; ，则 &lt;code&gt;git-format-patch&lt;/code&gt; 将生成 &lt;code&gt;In-Reply-To&lt;/code&gt; 和 &lt;code&gt;References&lt;/code&gt; 标头，以使第二个及后续的修补程序邮件作为对第一个邮件的答复出现。这还会生成要引用的 &lt;code&gt;Message-Id&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="b8bcbf4a83fcf4f75c98a2212241bdcbc1331a73" translate="yes" xml:space="preserve">
          <source>If given, limit the search to paths matching at least one pattern. Both leading paths match and glob(7) patterns are supported.</source>
          <target state="translated">如果给定,则将搜索范围限定为至少匹配一个模式的路径。同时支持前导路径匹配和 glob(7)模式。</target>
        </trans-unit>
        <trans-unit id="0f1d3c019382d162e2080cbdc28ed58b9e3bfa0a" translate="yes" xml:space="preserve">
          <source>If given, strings that substitute &lt;code&gt;%(fieldname)&lt;/code&gt; placeholders are quoted as string literals suitable for the specified host language. This is meant to produce a scriptlet that can directly be `eval`ed.</source>
          <target state="translated">如果给定，则替换 &lt;code&gt;%(fieldname)&lt;/code&gt; 占位符的字符串将作为适合于指定宿主语言的字符串文字引用。这意味着产生一个可以直接评估的脚本。</target>
        </trans-unit>
        <trans-unit id="fbaedaa3bd6d3e9940a1f51ae6f8f8f02a814640" translate="yes" xml:space="preserve">
          <source>If history is linear and HEAD is an ancestor of next, update the working tree and advance the HEAD pointer to match next. Otherwise, apply the changes introduced by those commits that are in next but not HEAD to the current branch, creating a new commit for each new change.</source>
          <target state="translated">如果历史是线性的,而且 HEAD 是 next 的祖先,那么更新工作树,并将 HEAD 指针向前推进以匹配 next。否则,就将 next 中的提交引入的变化应用到当前分支,但不是 HEAD,为每个新变化创建一个新的提交。</target>
        </trans-unit>
        <trans-unit id="c5f1ba7eca8a5dae95e4277b8eb6e331cbac924e" translate="yes" xml:space="preserve">
          <source>If it does not apply correctly, there can be various reasons.</source>
          <target state="translated">如果不能正确应用,可能有多种原因。</target>
        </trans-unit>
        <trans-unit id="50113fb63d9da87174eb94266585c5426270510c" translate="yes" xml:space="preserve">
          <source>If it does not support the requested operation (e.g., a read-only store), it should silently ignore the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="527b079607be5b2a4ead185d633224b57d83444a" translate="yes" xml:space="preserve">
          <source>If it exits with non-zero status, then the working tree will not be committed after applying the patch.</source>
          <target state="translated">如果它以非零状态退出,那么在应用补丁后,工作树将不会被提交。</target>
        </trans-unit>
        <trans-unit id="769efb2c6e10769ef0506d8fb6e30821bd41e6ea" translate="yes" xml:space="preserve">
          <source>If it happens that one merge base is bad, then the bisection process is stopped with a message like:</source>
          <target state="translated">如果发生一个合并基数不好的情况,那么就会用类似这样的消息来停止二分过程。</target>
        </trans-unit>
        <trans-unit id="d7b7066e9f3ba640d6b7d345ddda270a80c2a559" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;after&lt;/code&gt;, then each new trailer will appear just after the last trailer with the same &amp;lt;token&amp;gt;.</source>
          <target state="translated">如果 &lt;code&gt;after&lt;/code&gt; ，则每个新的预告片将出现在具有相同&amp;lt;token&amp;gt;的最后一个预告片之后。</target>
        </trans-unit>
        <trans-unit id="f2bafbae3498cf1dc8b7c4f581b63d0bfa115d9a" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;before&lt;/code&gt;, then each new trailer will appear just before the first trailer with the same &amp;lt;token&amp;gt;.</source>
          <target state="translated">如果 &lt;code&gt;before&lt;/code&gt; ，则每个新的预告片将出现在具有相同&amp;lt;token&amp;gt;的第一个预告片之前。</target>
        </trans-unit>
        <trans-unit id="76425e0a50de1913b3cc7557f216714041d9e64a" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;end&lt;/code&gt;, then each new trailer will appear at the end of the existing trailers.</source>
          <target state="translated">如果是 &lt;code&gt;end&lt;/code&gt; ，那么每个新的预告片将出现在现有预告片的末尾。</target>
        </trans-unit>
        <trans-unit id="df34e468f7176e0de86a55be70b61c5f69c7697c" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;start&lt;/code&gt;, then each new trailer will appear at the start, instead of the end, of the existing trailers.</source>
          <target state="translated">如果是 &lt;code&gt;start&lt;/code&gt; ，则每个新的预告片将出现在现有预告片的开始处，而不是结尾处。</target>
        </trans-unit>
        <trans-unit id="4def1637480df26c3310f2a04dde58c55a8e6a6e" translate="yes" xml:space="preserve">
          <source>If it is set to true, git-fetch-pack will check all fetched objects. See &lt;code&gt;transfer.fsckObjects&lt;/code&gt; for what&amp;rsquo;s checked. Defaults to false. If not set, the value of &lt;code&gt;transfer.fsckObjects&lt;/code&gt; is used instead.</source>
          <target state="translated">如果将其设置为true，则git-fetch-pack将检查所有提取的对象。有关检查内容，请参见 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; 。默认为false。如果未设置，则使用 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="c85a90553a06232b5ee8a2aebb2a31cb696c1660" translate="yes" xml:space="preserve">
          <source>If it is set to true, git-receive-pack will check all received objects. See &lt;code&gt;transfer.fsckObjects&lt;/code&gt; for what&amp;rsquo;s checked. Defaults to false. If not set, the value of &lt;code&gt;transfer.fsckObjects&lt;/code&gt; is used instead.</source>
          <target state="translated">如果设置为true，git-receive-pack将检查所有接收到的对象。有关检查内容，请参见 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; 。默认为false。如果未设置，则使用 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="f046c10bd7462cc956529dcbe0a86de2200086ed" translate="yes" xml:space="preserve">
          <source>If it turns out whatever you have done is worth keeping, you can always create a new name for it (without switching away):</source>
          <target state="translated">如果发现你所做的任何事情都值得保留,你可以随时为它创建一个新的名字(不需要转走)。</target>
        </trans-unit>
        <trans-unit id="4d0ff556eb63bcc0fd849ad26a1310c3a4323d31" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s not set, filesystem directory&amp;rsquo;s owner is used (via GECOS field, i.e. real name field from &lt;strong&gt;getpwuid&lt;/strong&gt;(3)) if &lt;code&gt;$projects_list&lt;/code&gt; is unset (gitweb scans &lt;code&gt;$projectroot&lt;/code&gt; for repositories); if &lt;code&gt;$projects_list&lt;/code&gt; points to file with list of repositories, then project owner defaults to value from this file for given repository.</source>
          <target state="translated">如果未设置，则如果未设置 &lt;code&gt;$projects_list&lt;/code&gt; （gitweb扫描 &lt;code&gt;$projectroot&lt;/code&gt; 以查找存储库），则使用文件系统目录的所有者（通过GECOS字段，即&lt;strong&gt;getpwuid&lt;/strong&gt;（3）的实名字段）；如果 &lt;code&gt;$projects_list&lt;/code&gt; 指向带有存储库列表的文件，则项目所有者默认为给定存储库的文件值。</target>
        </trans-unit>
        <trans-unit id="1cadf23ffce6eccc7a87c304031ef4b8e4d3adc6" translate="yes" xml:space="preserve">
          <source>If large offsets are required, we use another list of large offsets similar to version 2 pack-indexes.</source>
          <target state="translated">如果需要大偏移量,我们使用另一个类似于第2版pack-index的大偏移量列表。</target>
        </trans-unit>
        <trans-unit id="960d179c1e161024bf740912a06839844c1002e6" translate="yes" xml:space="preserve">
          <source>If left to accumulate, these stale references might make performance worse on big and busy repos that have a lot of branch churn, and e.g. make the output of commands like &lt;code&gt;git branch -a --contains
&amp;lt;commit&amp;gt;&lt;/code&gt; needlessly verbose, as well as impacting anything else that&amp;rsquo;ll work with the complete set of known references.</source>
          <target state="translated">如果任其累积，这些陈旧的引用可能会使 &lt;code&gt;git branch -a --contains &amp;lt;commit&amp;gt;&lt;/code&gt; ，繁忙的大型回购协议的性能变差，例如使git branch -a等命令的输出包含不必要的冗长冗长的commit和影响可以与所有已知参考文献一起使用的所有其他内容。</target>
        </trans-unit>
        <trans-unit id="703f6583148f1f4b148dcc92cca37187812e5840" translate="yes" xml:space="preserve">
          <source>If merge is called without any commit argument, merge the upstream branches configured for the current branch by using their last observed values stored in their remote-tracking branches. The values of the &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.merge&lt;/code&gt; that name the branches at the remote named by &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.remote&lt;/code&gt; are consulted, and then they are mapped via &lt;code&gt;remote.&amp;lt;remote&amp;gt;.fetch&lt;/code&gt; to their corresponding remote-tracking branches, and the tips of these tracking branches are merged.</source>
          <target state="translated">如果在没有任何提交参数的情况下调用了merge，请使用存储在其远程跟踪分支中的最后观察值来合并为当前分支配置的上游分支。 &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.merge&lt;/code&gt; 的值合并在一起，在以 &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.remote&lt;/code&gt; 命名的远程上命名分支。然后，它们通过 &lt;code&gt;remote.&amp;lt;remote&amp;gt;.fetch&lt;/code&gt; 到其相应的remote-跟踪分支，并且这些跟踪分支的提示已合并。</target>
        </trans-unit>
        <trans-unit id="115451ca901f83782dcbbcd683a49aed658e9f54" translate="yes" xml:space="preserve">
          <source>If more than one --branches (or --tags) option was given to the &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; command, you must provide the location of the branch (or tag) you wish to create in the SVN repository. &amp;lt;path&amp;gt; specifies which path to use to create the branch or tag and should match the pattern on the left-hand side of one of the configured branches or tags refspecs. You can see these refspecs with the commands</source>
          <target state="translated">如果为 &lt;code&gt;init&lt;/code&gt; 或 &lt;code&gt;clone&lt;/code&gt; 命令提供了多个--branches（或--tags）选项，则必须提供要在SVN信息库中创建的分支（或标签）的位置。&amp;lt;path&amp;gt;指定用于创建分支或标记的路径，并且应与已配置的分支或标记refspecs之一左侧的模式匹配。您可以使用以下命令查看这些参考规范</target>
        </trans-unit>
        <trans-unit id="720d1ff370baad05fcb8565540994e450819ec63" translate="yes" xml:space="preserve">
          <source>If more than one suffixes match the same tagname, then that tagname will be sorted according to the suffix which starts at the earliest position in the tagname. If more than one different matching suffixes start at that earliest position, then that tagname will be sorted according to the longest of those suffixes. The sorting order between different suffixes is undefined if they are in multiple config files.</source>
          <target state="translated">如果有多个后缀与同一个tagname匹配,那么该tagname将根据tagname中最早开始的后缀进行排序。如果有多个不同的后缀匹配,那么这个tagname将按照后缀中最长的那个开始排序。如果不同的后缀在多个配置文件中,那么不同后缀之间的排序顺序是未定义的。</target>
        </trans-unit>
        <trans-unit id="e3ac1856f1f0f57064ddb5057de6638c24881f47" translate="yes" xml:space="preserve">
          <source>If multiple tags were found during the walk then the tag which has the fewest commits different from the input commit-ish will be selected and output. Here fewest commits different is defined as the number of commits which would be shown by &lt;code&gt;git log tag..input&lt;/code&gt; will be the smallest number of commits possible.</source>
          <target state="translated">如果在步行过程中找到多个标签，则将选择并输出提交次数最少的标签，该标签与输入的提交内容不同。这里最少的不同提交定义为 &lt;code&gt;git log tag..input&lt;/code&gt; 显示的提交数量。.input将是可能的最小提交数量。</target>
        </trans-unit>
        <trans-unit id="a7822ac9c32ce308a5503a1fdd5fe89ff6cb69d3" translate="yes" xml:space="preserve">
          <source>If neither of the above exist then &lt;code&gt;$XDG_CONFIG_HOME/git/gitk&lt;/code&gt; is created and used by default. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is not set it defaults to &lt;code&gt;$HOME/.config&lt;/code&gt; in all cases.</source>
          <target state="translated">如果以上都不存在，则默认创建并使用 &lt;code&gt;$XDG_CONFIG_HOME/git/gitk&lt;/code&gt; 。如果未设置 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; 则在所有情况下均默认为 &lt;code&gt;$HOME/.config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd81c5109f07b879105adf39e250a5f3aca1a356" translate="yes" xml:space="preserve">
          <source>If neither was used, but &lt;code&gt;--date&lt;/code&gt; was given on the command line, show the timestamp in the format requested by &lt;code&gt;--date&lt;/code&gt;.</source>
          <target state="translated">如果没有使用，但 &lt;code&gt;--date&lt;/code&gt; 在命令行上给出，显示在所要求的格式时间戳 &lt;code&gt;--date&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3bb0635e00afaf46918027a40807c06a70ce207" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;pathspec&amp;gt; is given when &lt;code&gt;-A&lt;/code&gt; option is used, all files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories).</source>
          <target state="translated">如果在使用 &lt;code&gt;-A&lt;/code&gt; 选项时未给出&amp;lt;pathspec&amp;gt; ，则会更新整个工作树中的所有文件（Git的旧版本用于将更新限制为当前目录及其子目录）。</target>
        </trans-unit>
        <trans-unit id="4b6e9bfea0c02571aea512af96edfe88c9715f04" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;pathspec&amp;gt; is given when &lt;code&gt;-u&lt;/code&gt; option is used, all tracked files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories).</source>
          <target state="translated">如果在使用 &lt;code&gt;-u&lt;/code&gt; 选项时未给出&amp;lt;pathspec&amp;gt; ，则会更新整个工作树中的所有跟踪文件（旧版本的Git用于将更新限制为当前目录及其子目录）。</target>
        </trans-unit>
        <trans-unit id="4b6d20762b018937bfcb3d137cde943022a33140" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;--decorate-refs&lt;/code&gt; is given, pretend as if all refs were included. For each candidate, do not use it for decoration if it matches any patterns given to &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; or if it doesn&amp;rsquo;t match any of the patterns given to &lt;code&gt;--decorate-refs&lt;/code&gt;.</source>
          <target state="translated">如果未 &lt;code&gt;--decorate-refs&lt;/code&gt; ，则假装好像所有的refs都包括在内。对于每个候选，如果它匹配给任何模式不使用它的装饰 &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; ，或者如果它不匹配任何给定的模式 &lt;code&gt;--decorate-refs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7cc86d2479ae0db7a8477b9df1f3902cf870395" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;--decorate-refs&lt;/code&gt; is given, pretend as if all refs were included. For each candidate, do not use it for decoration if it matches any patterns given to &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; or if it doesn&amp;rsquo;t match any of the patterns given to &lt;code&gt;--decorate-refs&lt;/code&gt;. The &lt;code&gt;log.excludeDecoration&lt;/code&gt; config option allows excluding refs from the decorations, but an explicit &lt;code&gt;--decorate-refs&lt;/code&gt; pattern will override a match in &lt;code&gt;log.excludeDecoration&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2ed2d5d960c224ec529b5f6156261c52081093" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;-b&lt;/code&gt; option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the &quot;*&quot;. This would tell us to use &lt;code&gt;hack&lt;/code&gt; as the local branch when branching off of &lt;code&gt;origin/hack&lt;/code&gt; (or &lt;code&gt;remotes/origin/hack&lt;/code&gt;, or even &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt;). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with &lt;code&gt;-b&lt;/code&gt; in such a case.</source>
          <target state="translated">如果未提供 &lt;code&gt;-b&lt;/code&gt; 选项，则通过查看为相应远程配置的refspec的本地部分，然后将初始部分剥离为&amp;ldquo; *&amp;rdquo;，将从远程跟踪分支派生新分支的名称。 &amp;rdquo;。这将告诉我们在分支 &lt;code&gt;origin/hack&lt;/code&gt; （或 &lt;code&gt;remotes/origin/hack&lt;/code&gt; ，甚至 &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt; ）时，将 &lt;code&gt;hack&lt;/code&gt; 用作本地分支。如果给定名称没有斜杠，或者上述猜测结果为空名称，则猜测被中止。在这种情况下，可以使用 &lt;code&gt;-b&lt;/code&gt; 显式命名。</target>
        </trans-unit>
        <trans-unit id="4b362c22d46cf3c9ce26cb952c31ebfa05896260" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;-c&lt;/code&gt; option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the &quot;*&quot;. This would tell us to use &lt;code&gt;hack&lt;/code&gt; as the local branch when branching off of &lt;code&gt;origin/hack&lt;/code&gt; (or &lt;code&gt;remotes/origin/hack&lt;/code&gt;, or even &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt;). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with &lt;code&gt;-c&lt;/code&gt; in such a case.</source>
          <target state="translated">如果未提供 &lt;code&gt;-c&lt;/code&gt; 选项，则通过查看为相应远程配置的refspec的本地部分，然后将初始部分剥离为&amp;ldquo; *&amp;rdquo;，将从远程跟踪分支派生新分支的名称。 &amp;rdquo;。这将告诉我们在分支 &lt;code&gt;origin/hack&lt;/code&gt; （或 &lt;code&gt;remotes/origin/hack&lt;/code&gt; ，甚至 &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt; ）时，将 &lt;code&gt;hack&lt;/code&gt; 用作本地分支。如果给定名称没有斜杠，或者上述猜测结果为空名称，则猜测被中止。在这种情况下，可以使用 &lt;code&gt;-c&lt;/code&gt; 显式命名。</target>
        </trans-unit>
        <trans-unit id="f5eb9ed53cf409691a2adb1a958e7a2a354184a7" translate="yes" xml:space="preserve">
          <source>If no branch is specified and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; is used, then &lt;code&gt;git worktree add&lt;/code&gt; defaults to creating a new branch from HEAD. If &lt;code&gt;worktree.guessRemote&lt;/code&gt; is set to true, &lt;code&gt;worktree add&lt;/code&gt; tries to find a remote-tracking branch whose name uniquely matches the new branch name. If such a branch exists, it is checked out and set as &quot;upstream&quot; for the new branch. If no such match can be found, it falls back to creating a new branch from the current HEAD.</source>
          <target state="translated">如果未指定分支，并且未使用 &lt;code&gt;-b&lt;/code&gt; 或 &lt;code&gt;-B&lt;/code&gt; 或 &lt;code&gt;--detach&lt;/code&gt; ，则 &lt;code&gt;git worktree add&lt;/code&gt; 默认值以从HEAD创建新分支。如果 &lt;code&gt;worktree.guessRemote&lt;/code&gt; 设置为true，则 &lt;code&gt;worktree add&lt;/code&gt; 尝试查找其名称与新分支名称唯一匹配的远程跟踪分支。如果存在这样的分支，则将其检出并设置为新分支的&amp;ldquo;上游&amp;rdquo;。如果找不到这样的匹配项，则将退回到从当前HEAD创建新分支的位置。</target>
        </trans-unit>
        <trans-unit id="cd840721ca4f2ba5f348ba0cdeddc96e7d47ba2a" translate="yes" xml:space="preserve">
          <source>If no command-line option is passed, the &lt;code&gt;help.format&lt;/code&gt; configuration variable will be checked. The following values are supported for this variable; they make &lt;code&gt;git help&lt;/code&gt; behave as their corresponding command- line option:</source>
          <target state="translated">如果没有传递命令行选项，将检查 &lt;code&gt;help.format&lt;/code&gt; 配置变量。此变量支持以下值；它们使 &lt;code&gt;git help&lt;/code&gt; 表现为它们相应的命令行选项：</target>
        </trans-unit>
        <trans-unit id="48f09dc10a5152e65a114506d3daba225636a70e" translate="yes" xml:space="preserve">
          <source>If no commit ID is found, &lt;code&gt;git get-tar-commit-id&lt;/code&gt; quietly exists with a return code of 1. This can happen if the archive had not been created using &lt;code&gt;git archive&lt;/code&gt; or if the first parameter of &lt;code&gt;git archive&lt;/code&gt; had been a tree ID instead of a commit ID or tag.</source>
          <target state="translated">如果没有提交ID被找到， &lt;code&gt;git get-tar-commit-id&lt;/code&gt; 为1。返回代码，如果档案尚未使用创建这可能发生悄然存在 &lt;code&gt;git archive&lt;/code&gt; 或者如果第一个参数 &lt;code&gt;git archive&lt;/code&gt; 一直是树ID而不是提交ID或标签。</target>
        </trans-unit>
        <trans-unit id="daf3aead6a5bfcff96ae9ec0da48e9d2be49b75e" translate="yes" xml:space="preserve">
          <source>If no commit is given from the command line, merge the remote-tracking branches that the current branch is configured to use as its upstream. See also the configuration section of this manual page.</source>
          <target state="translated">如果没有从命令行给出提交,则合并当前分支被配置为其上游的远程跟踪分支。也请参见本手册页面的配置部分。</target>
        </trans-unit>
        <trans-unit id="7188b50eb220f479115e7bb7b4e8a6b937273e6f" translate="yes" xml:space="preserve">
          <source>If no format is specified, the default format is &lt;code&gt;%(objectname)
%(objecttype) %(objectsize)&lt;/code&gt;.</source>
          <target state="translated">如果未指定格式，则默认格式为 &lt;code&gt;%(objectname) %(objecttype) %(objectsize)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e72375796417844d20df5e1c264d965559c3c0c9" translate="yes" xml:space="preserve">
          <source>If no further options are given, all reading options will read all of these files that are available. If the global or the system-wide configuration file are not available they will be ignored. If the repository configuration file is not available or readable, &lt;code&gt;git config&lt;/code&gt; will exit with a non-zero error code. However, in neither case will an error message be issued.</source>
          <target state="translated">如果没有给出其他选项，则所有读取选项将读取所有这些可用文件。如果全局或系统范围的配置文件不可用，则将忽略它们。如果存储库配置文件不可用或不可读，则 &lt;code&gt;git config&lt;/code&gt; 将以非零错误代码退出。但是，在任何情况下都不会发出错误消息。</target>
        </trans-unit>
        <trans-unit id="542c100edd4ea5b59ab171a7795bc617673af483" translate="yes" xml:space="preserve">
          <source>If no objects are given, &lt;code&gt;git fsck&lt;/code&gt; defaults to using the index file, all SHA-1 references in &lt;code&gt;refs&lt;/code&gt; namespace, and all reflogs (unless --no-reflogs is given) as heads.</source>
          <target state="translated">如果未提供任何对象，则 &lt;code&gt;git fsck&lt;/code&gt; 默认使用索引文件， &lt;code&gt;refs&lt;/code&gt; 名称空间中的所有SHA-1引用以及所有reflogs（除非给出了--no-reflogs）作为头。</target>
        </trans-unit>
        <trans-unit id="3ac71fd77839914951c054588c999a4a8ef138ac" translate="yes" xml:space="preserve">
          <source>If no revisions are passed on the command line and either standard input is not a terminal or there is no current branch, &lt;code&gt;git shortlog&lt;/code&gt; will output a summary of the log read from standard input, without reference to the current repository.</source>
          <target state="translated">如果没有在命令行上传递任何修订，并且标准输入不是终端或没有当前分支，则 &lt;code&gt;git shortlog&lt;/code&gt; 将输出从标准输入读取的日志的摘要，而不会引用当前存储库。</target>
        </trans-unit>
        <trans-unit id="abf7234009b8e35c90eeb194fcd9fd8cfced1763" translate="yes" xml:space="preserve">
          <source>If no username is set for a network authentication, use this username by default. See credential.&amp;lt;context&amp;gt;.* below, and &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt;.</source>
          <target state="translated">如果未为网络身份验证设置用户名，则默认使用此用户名。请参阅下面的credential。&amp;lt;context&amp;gt;。*和&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68bd2465b7813ae05686685c60e9c1221c412754" translate="yes" xml:space="preserve">
          <source>If non-zero, all packs larger than this limit are kept when &lt;code&gt;git gc&lt;/code&gt; is run. This is very similar to &lt;code&gt;--keep-base-pack&lt;/code&gt; except that all packs that meet the threshold are kept, not just the base pack. Defaults to zero. Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">如果非零，则在运行 &lt;code&gt;git gc&lt;/code&gt; 时将保留所有大于此限制的包。这与 &lt;code&gt;--keep-base-pack&lt;/code&gt; 非常相似，只是保留所有符合阈值的包，而不仅仅是基本包。默认为零。支持 &lt;code&gt;k&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; 或 &lt;code&gt;g&lt;/code&gt; 的通用单位后缀。</target>
        </trans-unit>
        <trans-unit id="80f929e50dc4409c5d26df44de311be2ffed8079" translate="yes" xml:space="preserve">
          <source>If none of &lt;code&gt;--stdin&lt;/code&gt;, &lt;code&gt;--all&lt;/code&gt;, or &lt;code&gt;--&lt;/code&gt; is used, the first argument will be treated as an attribute and the rest of the arguments as pathnames.</source>
          <target state="translated">如果不使用 &lt;code&gt;--stdin&lt;/code&gt; ，-- &lt;code&gt;--all&lt;/code&gt; 或 &lt;code&gt;--&lt;/code&gt; ，则第一个参数将被视为属性，其余参数将被视为路径名。</target>
        </trans-unit>
        <trans-unit id="af13390230f0ed2d9d7a8cd452e31841984f2fea" translate="yes" xml:space="preserve">
          <source>If not set (default), it means that this feature is disabled.</source>
          <target state="translated">如果没有设置(默认),则表示该功能被禁用。</target>
        </trans-unit>
        <trans-unit id="ffeb0befbf6f99dd0616072c3aff8f91a09da3dd" translate="yes" xml:space="preserve">
          <source>If not set explicitly with &lt;code&gt;--file&lt;/code&gt;, there are four files where &lt;code&gt;git config&lt;/code&gt; will search for configuration options:</source>
          <target state="translated">如果未使用 &lt;code&gt;--file&lt;/code&gt; 进行显式设置，则 &lt;code&gt;git config&lt;/code&gt; 将在四个文件中搜索配置选项：</target>
        </trans-unit>
        <trans-unit id="42b0a7358d3a7018936abd1faefcf6d947a2a30c" translate="yes" xml:space="preserve">
          <source>If not set explicitly with &lt;code&gt;--file&lt;/code&gt;, there are two files where git-credential-store will search for credentials in order of precedence:</source>
          <target state="translated">如果未使用 &lt;code&gt;--file&lt;/code&gt; 明确设置，则有两个文件，其中git-credential-store将按优先级搜索凭据：</target>
        </trans-unit>
        <trans-unit id="7dcc101d67cdfa1a1e655970a079699595239b44" translate="yes" xml:space="preserve">
          <source>If not set in the environment, the list of notes to copy depends on the &lt;code&gt;notes.rewrite.&amp;lt;command&amp;gt;&lt;/code&gt; and &lt;code&gt;notes.rewriteRef&lt;/code&gt; settings.</source>
          <target state="translated">如果未在环境中设置， &lt;code&gt;notes.rewrite.&amp;lt;command&amp;gt;&lt;/code&gt; 复制的注释列表取决于notes.rewrite。&amp;lt;command&amp;gt;和 &lt;code&gt;notes.rewriteRef&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="324a704070b71849b1d4e1ca6f933c2b17a7a16e" translate="yes" xml:space="preserve">
          <source>If not specified, the contents are restored from &lt;code&gt;HEAD&lt;/code&gt; if &lt;code&gt;--staged&lt;/code&gt; is given, otherwise from the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f85a49fbdf8e068a215ef9d6f0bd6bbfeb7a4e" translate="yes" xml:space="preserve">
          <source>If not specified, the default restore source for the working tree is the index, and the default restore source for the index is &lt;code&gt;HEAD&lt;/code&gt;. When both &lt;code&gt;--staged&lt;/code&gt; and &lt;code&gt;--worktree&lt;/code&gt; are specified, &lt;code&gt;--source&lt;/code&gt; must also be specified.</source>
          <target state="translated">如果未指定，则工作树的默认还原源是索引，索引的默认还原源是 &lt;code&gt;HEAD&lt;/code&gt; 。同时指定 &lt;code&gt;--staged&lt;/code&gt; 和 &lt;code&gt;--worktree&lt;/code&gt; 时，还必须指定 &lt;code&gt;--source&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56d3a4f46f938bb42b1fca6d786b8e7fc54bbe14" translate="yes" xml:space="preserve">
          <source>If nothing matches, &lt;code&gt;git show-ref&lt;/code&gt; will return an error code of 1, and in the case of verification, it will show an error message.</source>
          <target state="translated">如果没有匹配项，则 &lt;code&gt;git show-ref&lt;/code&gt; 将返回错误代码1，在进行验证的情况下，它将显示错误消息。</target>
        </trans-unit>
        <trans-unit id="b1f5a8844fabfc412b2762d5d95a3c4d967624ca" translate="yes" xml:space="preserve">
          <source>If one of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is passed, the command creates a &lt;code&gt;tag&lt;/code&gt; object, and requires a tag message. Unless &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; or &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; is given, an editor is started for the user to type in the tag message.</source>
          <target state="translated">如果传递了 &lt;code&gt;-a&lt;/code&gt; ， &lt;code&gt;-s&lt;/code&gt; 或 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 之一，则该命令将创建 &lt;code&gt;tag&lt;/code&gt; 对象，并需要标记消息。除非给出 &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; 或 &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; ，否则将启动编辑器供用户键入标记消息。</target>
        </trans-unit>
        <trans-unit id="2202ccf1357459c2102fac8580d0b9c370cb2843" translate="yes" xml:space="preserve">
          <source>If one or more &amp;lt;file&amp;gt; parameters are given, the merge tool program will be run to resolve differences on each file (skipping those without conflicts). Specifying a directory will include all unresolved files in that path. If no &amp;lt;file&amp;gt; names are specified, &lt;code&gt;git mergetool&lt;/code&gt; will run the merge tool program on every file with merge conflicts.</source>
          <target state="translated">如果给出一个或多个&amp;lt;file&amp;gt;参数，将运行合并工具程序来解决每个文件上的差异（跳过那些没有冲突的文件）。指定目录将包含该路径中所有未解析的文件。如果未指定&amp;lt;file&amp;gt;名称，则 &lt;code&gt;git mergetool&lt;/code&gt; 将在每个存在合并冲突的文件上运行合并工具程序。</target>
        </trans-unit>
        <trans-unit id="ce7c35e9da7a7a12641957ffb2984ef7917b0e3e" translate="yes" xml:space="preserve">
          <source>If one or more patterns are given, only refs are shown that match against at least one pattern, either using fnmatch(3) or literally, in the latter case matching completely or from the beginning up to a slash.</source>
          <target state="translated">如果给出了一个或多个模式,则只显示与至少一个模式匹配的参考文献,可以使用fnmatch(3),也可以按字面意思显示,在后一种情况下,可以完全匹配,也可以从开头一直匹配到斜线。</target>
        </trans-unit>
        <trans-unit id="d335af2a37a580d9863e5a06bbfa0d646026268f" translate="yes" xml:space="preserve">
          <source>If one wishes to use the ref &lt;code&gt;ref/notes/true&lt;/code&gt;, please use that literal instead.</source>
          <target state="translated">如果希望使用ref &lt;code&gt;ref/notes/true&lt;/code&gt; ，请改用该文字。</target>
        </trans-unit>
        <trans-unit id="c90c8ad16602dc9d2f205c9d917c69aa3c723c01" translate="yes" xml:space="preserve">
          <source>If only &amp;lt;infd&amp;gt; is given, it is assumed to be a bidirectional socket connected to remote Git server (git-upload-pack, git-receive-pack or git-upload-archive). If both &amp;lt;infd&amp;gt; and &amp;lt;outfd&amp;gt; are given, they are assumed to be pipes connected to a remote Git server (&amp;lt;infd&amp;gt; being the inbound pipe and &amp;lt;outfd&amp;gt; being the outbound pipe.</source>
          <target state="translated">如果仅给出&amp;lt;infd&amp;gt;，则假定它是连接到远程Git服务器的双向套接字（git-upload-pack，git-receive-pack或git-upload-archive）。如果同时给出了&amp;lt;infd&amp;gt;和&amp;lt;outfd&amp;gt;，则假定它们是连接到远程Git服务器的管道（&amp;lt;infd&amp;gt;是入站管道，&amp;lt;outfd&amp;gt;是出站管道。</target>
        </trans-unit>
        <trans-unit id="ce722a3060a9ef1801cda4fdb7cc3661d10ec67c" translate="yes" xml:space="preserve">
          <source>If only 1 tree is specified, &lt;code&gt;git read-tree&lt;/code&gt; operates as if the user did not specify &lt;code&gt;-m&lt;/code&gt;, except that if the original index has an entry for a given pathname, and the contents of the path match with the tree being read, the stat info from the index is used. (In other words, the index&amp;rsquo;s stat()s take precedence over the merged tree&amp;rsquo;s).</source>
          <target state="translated">如果仅指定了1棵树，则 &lt;code&gt;git read-tree&lt;/code&gt; 的运行方式类似于用户未指定 &lt;code&gt;-m&lt;/code&gt; ，除非原始索引具有给定路径名的条目，并且路径的内容与正在读取的树匹配，否则使用来自索引的统计信息。（换句话说，索引的stat（）优先于合并的树）。</target>
        </trans-unit>
        <trans-unit id="ed44ceba40face622ee83aefe1801bafac3f799c" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;check-connectivity&lt;/code&gt; is requested, the helper must output &lt;code&gt;connectivity-ok&lt;/code&gt; if the clone is self-contained and connected.</source>
          <target state="translated">如果请求选项 &lt;code&gt;check-connectivity&lt;/code&gt; ，则如果克隆是自包含的且已连接，则帮助程序必须输出 &lt;code&gt;connectivity-ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d94f0028bb24f94910f79bf2b787bad6af3cf852" translate="yes" xml:space="preserve">
          <source>If other people are pulling from your repository over dumb transport protocols (HTTP), you need to keep this repository &lt;code&gt;dumb transport friendly&lt;/code&gt;. After &lt;code&gt;git init&lt;/code&gt;, &lt;code&gt;$GIT_DIR/hooks/post-update.sample&lt;/code&gt; copied from the standard templates would contain a call to &lt;code&gt;git update-server-info&lt;/code&gt; but you need to manually enable the hook with &lt;code&gt;mv post-update.sample post-update&lt;/code&gt;. This makes sure &lt;code&gt;git update-server-info&lt;/code&gt; keeps the necessary files up to date.</source>
          <target state="translated">如果其他人通过哑传输协议（HTTP）从您的存储库中拉出，则需要保持该存储库的 &lt;code&gt;dumb transport friendly&lt;/code&gt; 。之后 &lt;code&gt;git init&lt;/code&gt; ， &lt;code&gt;$GIT_DIR/hooks/post-update.sample&lt;/code&gt; 从标准模板复制将包含一个呼叫 &lt;code&gt;git update-server-info&lt;/code&gt; ，但你必须手动启用与钩 &lt;code&gt;mv post-update.sample post-update&lt;/code&gt; 。这可以确保 &lt;code&gt;git update-server-info&lt;/code&gt; 保持必要的文件为最新。</target>
        </trans-unit>
        <trans-unit id="e17148a8f3d2ab81971460344696589bc00ec7fe" translate="yes" xml:space="preserve">
          <source>If provided, the results are limited to a subset of files matching one of the provided pathspecs.</source>
          <target state="translated">如果提供,则结果仅限于与所提供的路径规格之一相匹配的文件子集。</target>
        </trans-unit>
        <trans-unit id="c6bf36e1017847984a394e553be49b7f1e0149c6" translate="yes" xml:space="preserve">
          <source>If separate &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; commands are used in a &lt;code&gt;commit&lt;/code&gt; the timestamps may not match, as the system clock will be polled twice (once for each command). The only way to ensure that both author and committer identity information has the same timestamp is to omit &lt;code&gt;author&lt;/code&gt; (thus copying from &lt;code&gt;committer&lt;/code&gt;) or to use a date format other than &lt;code&gt;now&lt;/code&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;commit&lt;/code&gt; 中使用了单独的 &lt;code&gt;author&lt;/code&gt; 和 &lt;code&gt;committer&lt;/code&gt; 命令，则时间戳可能不匹配，因为系统时钟将被轮询两次（每个命令一次）。确保作者和提交者身份信息都具有相同时间戳的唯一方法是忽略 &lt;code&gt;author&lt;/code&gt; （因此从 &lt;code&gt;committer&lt;/code&gt; 者复制）或使用不同于 &lt;code&gt;now&lt;/code&gt; 的日期格式。</target>
        </trans-unit>
        <trans-unit id="866d5a5839fdc5ae41f48af4bbd37789bc250691" translate="yes" xml:space="preserve">
          <source>If set &lt;code&gt;--base=auto&lt;/code&gt; in cmdline, it will track base commit automatically, the base commit will be the merge base of tip commit of the remote-tracking branch and revision-range specified in cmdline. For a local branch, you need to track a remote branch by &lt;code&gt;git branch
--set-upstream-to&lt;/code&gt; before using this option.</source>
          <target state="translated">如果在cmdline中设置 &lt;code&gt;--base=auto&lt;/code&gt; ，它将自动跟踪基本提交，该基本提交将是远程跟踪分支的尖端提交和在cmdline中指定的修订范围的合并基础。对于本地分支，在使用此选项之前，需要通过 &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; 跟踪远程分支。</target>
        </trans-unit>
        <trans-unit id="c4e55e2ff9b8cf62b34b50d7d6b4a09bd94fb5d9" translate="yes" xml:space="preserve">
          <source>If set to &quot;auto&quot;, &lt;code&gt;git-commit&lt;/code&gt; would select a character that is not the beginning character of any line in existing commit messages.</source>
          <target state="translated">如果设置为&amp;ldquo; auto&amp;rdquo;，则 &lt;code&gt;git-commit&lt;/code&gt; 将选择一个字符，该字符不是现有提交消息中任何行的开始字符。</target>
        </trans-unit>
        <trans-unit id="3cb1da898d09757c537ab553b3fe27d9de1953ee" translate="yes" xml:space="preserve">
          <source>If set to &quot;warn&quot;, git rebase -i will print a warning if some commits are removed (e.g. a line was deleted), however the rebase will still proceed. If set to &quot;error&quot;, it will print the previous warning and stop the rebase, &lt;code&gt;git rebase --edit-todo&lt;/code&gt; can then be used to correct the error. If set to &quot;ignore&quot;, no checking is done. To drop a commit without warning or error, use the &lt;code&gt;drop&lt;/code&gt; command in the todo list. Defaults to &quot;ignore&quot;.</source>
          <target state="translated">如果设置为&amp;ldquo; warn&amp;rdquo;，则git rebase -i将在删除某些提交（例如删除一行）时显示警告，但是重新设置仍将继续。如果设置为&amp;ldquo;错误&amp;rdquo;，它将打印先前的警告并停止变基，然后可以使用 &lt;code&gt;git rebase --edit-todo&lt;/code&gt; 来更正该错误。如果设置为&amp;ldquo;忽略&amp;rdquo;，则不进行检查。要在没有警告或错误的情况下删除提交，请使用待办事项列表中的 &lt;code&gt;drop&lt;/code&gt; 命令。默认为&amp;ldquo;忽略&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ac8b0270c3c47d08febdcf04811ec5325e6bcef3" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;0&lt;/code&gt;, Git will complete any requested operation without performing any optional sub-operations that require taking a lock. For example, this will prevent &lt;code&gt;git status&lt;/code&gt; from refreshing the index as a side effect. This is useful for processes running in the background which do not want to cause lock contention with other operations on the repository. Defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">如果设置为 &lt;code&gt;0&lt;/code&gt; ，则Git将完成任何请求的操作，而无需执行任何需要进行锁定的可选子操作。例如，这将防止 &lt;code&gt;git status&lt;/code&gt; 刷新索引作为副作用。这对于在后台运行且不希望与存储库上的其他操作引起锁争用的进程很有用。默认为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d1e5156e1d430a4750260179109e036962ca85d" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;1&lt;/code&gt;, include broken or badly named refs when iterating over lists of refs. In a normal, non-corrupted repository, this does nothing. However, enabling it may help git to detect and abort some operations in the presence of broken refs. Git sets this variable automatically when performing destructive operations like &lt;a href=&quot;git-prune&quot;&gt;git-prune[1]&lt;/a&gt;. You should not need to set it yourself unless you want to be paranoid about making sure an operation has touched every ref (e.g., because you are cloning a repository to make a backup).</source>
          <target state="translated">如果设置为 &lt;code&gt;1&lt;/code&gt; ，则在遍历引用列表时包括损坏的或命名错误的引用。在正常的，未损坏的存储库中，此操作无效。但是，启用它可能有助于git在存在损坏的引用的情况下检测并中止某些操作。当执行破坏性操作（如&lt;a href=&quot;git-prune&quot;&gt;git-prune [1]）&lt;/a&gt;时，Git自动设置此变量。除非您想确保操作已触及每个引用（例如，因为要克隆存储库以进行备份），否则您无需自己进行设置。</target>
        </trans-unit>
        <trans-unit id="721e268a3bbca2372f644ef6baf34d6bc14a8b54" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt;, behave as if the &lt;code&gt;--no-replace-objects&lt;/code&gt; option was given on the command line. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; and &lt;a href=&quot;git-replace&quot;&gt;git-replace[1]&lt;/a&gt; for more information.</source>
          <target state="translated">如果设置为 &lt;code&gt;false&lt;/code&gt; ，则其行为就像在命令行上给出了 &lt;code&gt;--no-replace-objects&lt;/code&gt; 选项。有关更多信息，请参见&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;和&lt;a href=&quot;git-replace&quot;&gt;git-replace [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f2d027bcde6fa30d6f1d075f8f588cf0e958fbb" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;git diff&lt;/code&gt; does not show changes outside of the directory and show pathnames relative to the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c80e3d63d134dccb3136c655fb06b3aa0219fb0" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;yes&lt;/code&gt;, print an ellipsis following an (abbreviated) SHA-1 value. This affects indications of detached HEADs (&lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;) and the raw diff output (&lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;). Printing an ellipsis in the cases mentioned is no longer considered adequate and support for it is likely to be removed in the foreseeable future (along with the variable).</source>
          <target state="translated">如果设置为 &lt;code&gt;yes&lt;/code&gt; ，则在（缩写的）SHA-1值后打印省略号。这会影响分离的HEAD（&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;）和原始diff输出（&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;）的指示。在上述情况下，打印省略号已不再被认为是足够的，并且在可预见的将来（包括变量）可能会删除对它的支持。</target>
        </trans-unit>
        <trans-unit id="03e97ab625ba0ca85ff94dae74e07745d32e9ba5" translate="yes" xml:space="preserve">
          <source>If set to a colon-separated list of protocols, behave as if &lt;code&gt;protocol.allow&lt;/code&gt; is set to &lt;code&gt;never&lt;/code&gt;, and each of the listed protocols has &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; set to &lt;code&gt;always&lt;/code&gt; (overriding any existing configuration). In other words, any protocol not mentioned will be disallowed (i.e., this is a whitelist, not a blacklist). See the description of &lt;code&gt;protocol.allow&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for more details.</source>
          <target state="translated">如果设置为以冒号分隔的协议列表，则其行为就像将 &lt;code&gt;protocol.allow&lt;/code&gt; 设置为 &lt;code&gt;never&lt;/code&gt; ，并且列出的每个协议都将 &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; 设置为 &lt;code&gt;always&lt;/code&gt; （覆盖任何现有配置）。换句话说，任何未提及的协议都是不允许的（即，这是白名单，而不是黑名单）。看到的描述 &lt;code&gt;protocol.allow&lt;/code&gt; 在&lt;a href=&quot;git-config&quot;&gt;GIT-配置[1]&lt;/a&gt;的更多细节。</target>
        </trans-unit>
        <trans-unit id="3efcc8bea067f2176f4b0bb44941378607e1ec05" translate="yes" xml:space="preserve">
          <source>If set to an algorithm, indicate that the caller wants to interact with the remote side using that algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02bbac09e65cccb0fb85d779cd5ffdc25f0fea6" translate="yes" xml:space="preserve">
          <source>If set to either a valid &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; or a true value, moved lines in a diff are colored differently, for details of valid modes see &lt;code&gt;--color-moved&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. If simply set to true the default color mode will be used. When set to false, moved lines are not colored.</source>
          <target state="translated">如果设置为一个有效的 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 或真值，在一个diff移动的行的颜色不同，为有效模式的细节，参见 &lt;code&gt;--color-moved&lt;/code&gt; 在&lt;a href=&quot;git-diff&quot;&gt;GIT-DIFF [1] &lt;/a&gt;。如果仅将其设置为true，则将使用默认颜色模式。设置为false时，移动的行不着色。</target>
        </trans-unit>
        <trans-unit id="d2017527381afe3327ef07745ea82e7ee1e2ae55" translate="yes" xml:space="preserve">
          <source>If set to true enable &lt;code&gt;--autosquash&lt;/code&gt; option by default.</source>
          <target state="translated">如果设置为true ，则默认情况下启用 &lt;code&gt;--autosquash&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="7630a0d058d7490b6c2c7394afc94b9292f8389f" translate="yes" xml:space="preserve">
          <source>If set to true enable &lt;code&gt;--follow-tags&lt;/code&gt; option by default. You may override this configuration at time of push by specifying &lt;code&gt;--no-follow-tags&lt;/code&gt;.</source>
          <target state="translated">如果设置为true ，则默认情况下启用 &lt;code&gt;--follow-tags&lt;/code&gt; 选项。您可以在推送时通过指定 &lt;code&gt;--no-follow-tags&lt;/code&gt; 覆盖此配置。</target>
        </trans-unit>
        <trans-unit id="64fe3b4eafd82bc5365512adbc156f5096a46d37" translate="yes" xml:space="preserve">
          <source>If set to true or &quot;refuse&quot;, git-receive-pack will deny a ref update to the currently checked out branch of a non-bare repository. Such a push is potentially dangerous because it brings the HEAD out of sync with the index and working tree. If set to &quot;warn&quot;, print a warning of such a push to stderr, but allow the push to proceed. If set to false or &quot;ignore&quot;, allow such pushes with no message. Defaults to &quot;refuse&quot;.</source>
          <target state="translated">如果设置为 &quot;true &quot;或 &quot;reject&quot;,git-receive-pack将拒绝对非废弃仓库的当前签出分支进行ref更新。这样的推送有潜在的危险性,因为它会使 HEAD 与索引和工作树不同步。如果设置为 &quot;warning&quot;,则将这种推送的警告打印到stderr,但允许推送继续。如果设置为false或 &quot;ignore&quot;,允许这样的推送,但不发消息。默认值为 &quot;拒绝&quot;。</target>
        </trans-unit>
        <trans-unit id="d09a3b8e56d92fdf26b71ac7a66610897ebf56ec" translate="yes" xml:space="preserve">
          <source>If set to true, .git/shallow can be updated when new refs require new shallow roots. Otherwise those refs are rejected.</source>
          <target state="translated">如果设置为 &quot;true&quot;,当新的参考文献需要新的浅层根时,可以更新.git/shallow。否则,这些引用将被拒绝。</target>
        </trans-unit>
        <trans-unit id="54bb951308d4910fbcee8b759c22be8fe1cad2d9" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; will display the number of entries currently stashed away. Defaults to false.</source>
          <target state="translated">如果设置为true，&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;将显示当前藏匿的条目数。默认为false。</target>
        </trans-unit>
        <trans-unit id="3713c634b09bf65bc394c012cee94ba42c596b9c" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; will insert a comment prefix before each output line (starting with &lt;code&gt;core.commentChar&lt;/code&gt;, i.e. &lt;code&gt;#&lt;/code&gt; by default). This was the behavior of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; in Git 1.8.4 and previous. Defaults to false.</source>
          <target state="translated">如果设置为true，&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;将在每条输出行之前插入一个注释前缀（以 &lt;code&gt;core.commentChar&lt;/code&gt; 开头，即默认为 &lt;code&gt;#&lt;/code&gt; ）。这是Git 1.8.4及以前版本中&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;的行为。默认为false。</target>
        </trans-unit>
        <trans-unit id="9b89821396e7eac11e5ad2faf8d7540e7c67829b" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;code&gt;git rebase&lt;/code&gt; will use abbreviated command names in the todo list resulting in something like this:</source>
          <target state="translated">如果设置为true，则 &lt;code&gt;git rebase&lt;/code&gt; 将在todo列表中使用缩写的命令名称，结果如下：</target>
        </trans-unit>
        <trans-unit id="a871da2391e5e77cb10a7b13bd4e3a7269114ee0" translate="yes" xml:space="preserve">
          <source>If set to true, do not allow checkout of paths that would be considered equivalent to &lt;code&gt;.git&lt;/code&gt; on an HFS+ filesystem. Defaults to &lt;code&gt;true&lt;/code&gt; on Mac OS, and &lt;code&gt;false&lt;/code&gt; elsewhere.</source>
          <target state="translated">如果设置为true，则不允许签出在HFS +文件系统上等同于 &lt;code&gt;.git&lt;/code&gt; 的路径。在Mac OS上默认为 &lt;code&gt;true&lt;/code&gt; ,在其他地方默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b91b7e4dfffb3891da9de8dba8ed2d19154ae38" translate="yes" xml:space="preserve">
          <source>If set to true, do not allow checkout of paths that would cause problems with the NTFS filesystem, e.g. conflict with 8.3 &quot;short&quot; names. Defaults to &lt;code&gt;true&lt;/code&gt; on Windows, and &lt;code&gt;false&lt;/code&gt; elsewhere.</source>
          <target state="translated">如果设置为true，则不允许签出可能导致NTFS文件系统出现问题的路径，例如与8.3&amp;ldquo;短&amp;rdquo;名称冲突。在Windows上默认为 &lt;code&gt;true&lt;/code&gt; ,在其他地方默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54ccdbeca4965b6fc3cb17a6075d84092d7309ba" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;--extended-regexp&lt;/code&gt; option by default. This option is ignored when the &lt;code&gt;grep.patternType&lt;/code&gt; option is set to a value other than &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果设置为true， &lt;code&gt;--extended-regexp&lt;/code&gt; 默认启用--extended-regexp选项。当 &lt;code&gt;grep.patternType&lt;/code&gt; 选项设置为 &lt;code&gt;default&lt;/code&gt; 以外的值时，将忽略此选项。</target>
        </trans-unit>
        <trans-unit id="30887a5524c263667737b125eed1b7397b4d3c85" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;--full-name&lt;/code&gt; option by default.</source>
          <target state="translated">如果设置为true，则默认启用 &lt;code&gt;--full-name&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="a770bd77a59ee1eda1723cd39df7104106a40a38" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;-n&lt;/code&gt; option by default.</source>
          <target state="translated">如果设置为true，则默认启用 &lt;code&gt;-n&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="2ae1bc4fce8b6029e6cbb4c5d0167ebeeaacf37d" translate="yes" xml:space="preserve">
          <source>If set to true, enable the &lt;code&gt;--column&lt;/code&gt; option by default.</source>
          <target state="translated">如果设置为true，则默认启用 &lt;code&gt;--column&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="1f2144fe2d27e9e20f68c9036ebab8459a790815" translate="yes" xml:space="preserve">
          <source>If set to true, fall back to git grep --no-index if git grep is executed outside of a git repository. Defaults to false.</source>
          <target state="translated">如果设置为true,如果git grep在git仓库外执行,则回到git grep --no-index。默认为false。</target>
        </trans-unit>
        <trans-unit id="25ad8c4a959eb80b90f95ddbc01fcd1f2b16d26e" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update that deletes the currently checked out branch of a non-bare repository.</source>
          <target state="translated">如果设置为 &quot;true&quot;,git-receive-pack 将拒绝删除非废弃仓库的当前检查出分支的 ref 更新。</target>
        </trans-unit>
        <trans-unit id="f7f0fff426d74ea17456c56eae07f347498018a4" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update that deletes the ref. Use this to prevent such a ref deletion via a push.</source>
          <target state="translated">如果设置为 &quot;true&quot;,git-receive-pack 将拒绝删除 ref 的更新。使用此功能可以防止通过推送删除 ref。</target>
        </trans-unit>
        <trans-unit id="bc6468d5687d1713aadc8dfe39af8a6b8a9b584c" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update which is not a fast-forward. Use this to prevent such an update via a push, even if that push is forced. This configuration variable is set when initializing a shared repository.</source>
          <target state="translated">如果设置为 &quot;true&quot;,git-receive-pack 将拒绝非快进的 ref 更新。使用这个变量可以防止通过推送进行这样的更新,即使推送是强制的。这个配置变量会在初始化共享仓库时设置。</target>
        </trans-unit>
        <trans-unit id="aa5f05e34699c4bff5b25fced7ce1653e77528d2" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will run git-update-server-info after receiving data from git-push and updating refs.</source>
          <target state="translated">如果设置为 &quot;true&quot;,git-receive-pack会在接收到git-push的数据后运行git-update-server-info并更新refs。</target>
        </trans-unit>
        <trans-unit id="875b965a1988574b490477056983b56357db9a5f" translate="yes" xml:space="preserve">
          <source>If set to true, makes &lt;code&gt;git repack&lt;/code&gt; act as if &lt;code&gt;--delta-islands&lt;/code&gt; was passed. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果设置为true，则使 &lt;code&gt;git repack&lt;/code&gt; 像传递 &lt;code&gt;--delta-islands&lt;/code&gt; 一样起作用。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a3fff86e688774493783e955a40569a2b6cd00b" translate="yes" xml:space="preserve">
          <source>If set to true, makes &lt;code&gt;git repack&lt;/code&gt; act as if &lt;code&gt;--pack-kept-objects&lt;/code&gt; was passed. See &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; for details. Defaults to &lt;code&gt;false&lt;/code&gt; normally, but &lt;code&gt;true&lt;/code&gt; if a bitmap index is being written (either via &lt;code&gt;--write-bitmap-index&lt;/code&gt; or &lt;code&gt;repack.writeBitmaps&lt;/code&gt;).</source>
          <target state="translated">如果设置为true，则使 &lt;code&gt;git repack&lt;/code&gt; 像传递 &lt;code&gt;--pack-kept-objects&lt;/code&gt; 一样起作用。有关详细信息，请参见&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;。默认为 &lt;code&gt;false&lt;/code&gt; 正常，但 &lt;code&gt;true&lt;/code&gt; 如果位图索引被写入（通过 &lt;code&gt;--write-bitmap-index&lt;/code&gt; 或 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f4685adbf82f5fe84483ac0a4116dbb7a4fa6307" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;git diff&lt;/code&gt; does not show any source or destination prefix.</source>
          <target state="translated">如果设置，则 &lt;code&gt;git diff&lt;/code&gt; 不显示任何源或目标前缀。</target>
        </trans-unit>
        <trans-unit id="407c23ddaf3ebfe9c20e0dd5ae2fc627eb8b4502" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;git diff&lt;/code&gt; uses a prefix pair that is different from the standard &quot;a/&quot; and &quot;b/&quot; depending on what is being compared. When this configuration is in effect, reverse diff output also swaps the order of the prefixes:</source>
          <target state="translated">如果设置，则 &lt;code&gt;git diff&lt;/code&gt; 使用的前缀对与标准&amp;ldquo; a /&amp;rdquo;和&amp;ldquo; b /&amp;rdquo;不同，具体取决于所比较的对象。当此配置生效时，reverse diff输出还将交换前缀的顺序：</target>
        </trans-unit>
        <trans-unit id="ce70dfc2b2921383247fcc52103661d4583ff009" translate="yes" xml:space="preserve">
          <source>If set, by default &quot;git config&quot; reads from both &quot;config&quot; and &quot;config.worktree&quot; file from GIT_DIR in that order. In multiple working directory mode, &quot;config&quot; file is shared while &quot;config.worktree&quot; is per-working directory (i.e., it&amp;rsquo;s in GIT_COMMON_DIR/worktrees/&amp;lt;id&amp;gt;/config.worktree)</source>
          <target state="translated">如果设置，默认情况下，&amp;ldquo; git config&amp;rdquo;将从GIT_DIR的&amp;ldquo; config&amp;rdquo;和&amp;ldquo; config.worktree&amp;rdquo;文件中依次读取。在多个工作目录模式下，&amp;ldquo; config&amp;rdquo;文件是共享的，而&amp;ldquo; config.worktree&amp;rdquo;是每个工作目录（即，它位于GIT_COMMON_DIR / worktrees / &amp;lt;id&amp;gt; /config.worktree中）</target>
        </trans-unit>
        <trans-unit id="8558e4c58eead00c8757e7213c096b3a4293d44c" translate="yes" xml:space="preserve">
          <source>If set, clients will attempt to communicate with a server using the specified protocol version. If the server does not support it, communication falls back to version 0. If unset, the default is &lt;code&gt;2&lt;/code&gt;. Supported versions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b176f794890668142b94887636cc924076126a16" translate="yes" xml:space="preserve">
          <source>If set, keywords at the start of the line are highlighted. The keywords are &quot;error&quot;, &quot;warning&quot;, &quot;hint&quot; and &quot;success&quot;, and are matched case-insensitively. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;). If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">如果设置，则突出显示行首的关键字。关键字是&amp;ldquo;错误&amp;rdquo;，&amp;ldquo;警告&amp;rdquo;，&amp;ldquo;提示&amp;rdquo;和&amp;ldquo;成功&amp;rdquo;，并且不区分大小写地匹配。可以设置为 &lt;code&gt;always&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; （或 &lt;code&gt;never&lt;/code&gt; ）或 &lt;code&gt;auto&lt;/code&gt; （或 &lt;code&gt;true&lt;/code&gt; ）。如果未设置，则使用 &lt;code&gt;color.ui&lt;/code&gt; 的值（默认情况下为 &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b183dd8c0ffee365fe58a6a334a19fb15f9512f0" translate="yes" xml:space="preserve">
          <source>If set, prints debugging information about various reads/writes.</source>
          <target state="translated">如果设置,打印各种读/写的调试信息。</target>
        </trans-unit>
        <trans-unit id="b8c5d5bfb05b8eec245d869376183965da454ecd" translate="yes" xml:space="preserve">
          <source>If set, provide a user defined default policy for all protocols which don&amp;rsquo;t explicitly have a policy (&lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt;). By default, if unset, known-safe protocols (http, https, git, ssh, file) have a default policy of &lt;code&gt;always&lt;/code&gt;, known-dangerous protocols (ext) have a default policy of &lt;code&gt;never&lt;/code&gt;, and all other protocols have a default policy of &lt;code&gt;user&lt;/code&gt;. Supported policies:</source>
          <target state="translated">如果设置，请为所有没有明确指定策略的 &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; （protocol。&amp;lt;name&amp;gt; .allow）提供用户定义的默认策略。默认情况下，如果未设置，则已知安全协议（http，https，git，ssh，文件）的默认策略为 &lt;code&gt;always&lt;/code&gt; ，已知危险协议（ext）的默认策略为 &lt;code&gt;never&lt;/code&gt; ，所有其他协议的默认策略为的 &lt;code&gt;user&lt;/code&gt; 。支持的政策：</target>
        </trans-unit>
        <trans-unit id="8d4a6e984ec5e0aad11e32a678cf60da360c5f1c" translate="yes" xml:space="preserve">
          <source>If set, specifies the outgoing SMTP server option to use. Default value can be specified by the &lt;code&gt;sendemail.smtpServerOption&lt;/code&gt; configuration option.</source>
          <target state="translated">如果设置，则指定要使用的传出SMTP服务器选项。可以通过 &lt;code&gt;sendemail.smtpServerOption&lt;/code&gt; 配置选项指定默认值。</target>
        </trans-unit>
        <trans-unit id="0fab27431c274f5a81ff1327c3c271e3371074f0" translate="yes" xml:space="preserve">
          <source>If set, specifies the outgoing SMTP server to use (e.g. &lt;code&gt;smtp.example.com&lt;/code&gt; or a raw IP address). Alternatively it can specify a full pathname of a sendmail-like program instead; the program must support the &lt;code&gt;-i&lt;/code&gt; option. Default value can be specified by the &lt;code&gt;sendemail.smtpServer&lt;/code&gt; configuration option; the built-in default is to search for &lt;code&gt;sendmail&lt;/code&gt; in &lt;code&gt;/usr/sbin&lt;/code&gt;, &lt;code&gt;/usr/lib&lt;/code&gt; and $PATH if such program is available, falling back to &lt;code&gt;localhost&lt;/code&gt; otherwise.</source>
          <target state="translated">如果设置，则指定要使用的传出SMTP服务器（例如 &lt;code&gt;smtp.example.com&lt;/code&gt; 或原始IP地址）。另外，它可以指定类似sendmail的程序的完整路径名。该程序必须支持 &lt;code&gt;-i&lt;/code&gt; 选项。可以通过 &lt;code&gt;sendemail.smtpServer&lt;/code&gt; 配置选项指定默认值。内置的默认值是在 &lt;code&gt;/usr/sbin&lt;/code&gt; ， &lt;code&gt;/usr/lib&lt;/code&gt; 和$ PATH中搜索 &lt;code&gt;sendmail&lt;/code&gt; （如果有此程序可用），否则返回 &lt;code&gt;localhost&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95132676994fa7152c54abc8928412e3414f6991" translate="yes" xml:space="preserve">
          <source>If set, store cookies received during requests to the file specified by http.cookieFile. Has no effect if http.cookieFile is unset.</source>
          <target state="translated">如果设置,则将请求过程中收到的 cookie 保存到 http.cookieFile 指定的文件中。如果http.cookieFile未设置,则没有任何影响。</target>
        </trans-unit>
        <trans-unit id="9802dde85fc0323285bb8c0402ffcc333cf47ed2" translate="yes" xml:space="preserve">
          <source>If set, the value of this variable is used as a command which will identify all files that may have changed since the requested date/time. This information is used to speed up git by avoiding unnecessary processing of files that have not changed. See the &quot;fsmonitor-watchman&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">如果设置，则此变量的值用作命令，该命令将标识自请求的日期/时间以来可能已更改的所有文件。通过避免不必要地处理未更改的文件，此信息可用于加快git。请参阅&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;的&amp;ldquo; fsmonitor-watchman&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="9612a7f8efdd3501a24381e7aae358082b8ef892" translate="yes" xml:space="preserve">
          <source>If some &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; arguments are also passed on the command line, when a &lt;code&gt;trailer.&amp;lt;token&amp;gt;.command&lt;/code&gt; is configured, the command will also be executed for each of these arguments. And the &amp;lt;value&amp;gt; part of these arguments, if any, will be used to replace the &lt;code&gt;$ARG&lt;/code&gt; string in the command.</source>
          <target state="translated">如果在命令行上也传递了某些 &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 参数，则在配置了 &lt;code&gt;trailer.&amp;lt;token&amp;gt;.command&lt;/code&gt; ，还将为每个这些参数执行命令。这些参数的&amp;lt;value&amp;gt;部分（如果有的话）将用于替换命令中的 &lt;code&gt;$ARG&lt;/code&gt; 字符串。</target>
        </trans-unit>
        <trans-unit id="00679e1f1be4cb3b83ae3531e0f65d104df1ba84" translate="yes" xml:space="preserve">
          <source>If some files could not be added because of errors indexing them, do not abort the operation, but continue adding the others. The command shall still exit with non-zero status. The configuration variable &lt;code&gt;add.ignoreErrors&lt;/code&gt; can be set to true to make this the default behaviour.</source>
          <target state="translated">如果由于索引错误而无法添加某些文件，请不要中止该操作，而要继续添加其他文件。该命令仍将以非零状态退出。可以将配置变量 &lt;code&gt;add.ignoreErrors&lt;/code&gt; 设置为true，以使其成为默认行为。</target>
        </trans-unit>
        <trans-unit id="02424da36361565abc928c3cd12899bb91686b1d" translate="yes" xml:space="preserve">
          <source>If some of the merge bases are skipped, then the bisection process continues, but the following message is printed for each skipped merge base:</source>
          <target state="translated">如果跳过了一些合并基点,则继续进行二分法,但对每个跳过的合并基点会打印以下信息。</target>
        </trans-unit>
        <trans-unit id="c23bec329e1ab3f8ab844a76b3b2aad8e4c54310" translate="yes" xml:space="preserve">
          <source>If somebody got a release tag from you, you cannot just change the tag for them by updating your own one. This is a big security issue, in that people MUST be able to trust their tag-names. If you really want to do the insane thing, you need to just fess up to it, and tell people that you messed up. You can do that by making a very public announcement saying:</source>
          <target state="translated">如果有人从你那里得到了一个发布标签,你不能通过更新你自己的标签来改变他们的标签。这是一个很大的安全问题,因为人们必须能够信任他们的标签名。如果你真的想做这种疯狂的事情,你需要承认,并告诉人们你搞砸了。你可以做一个非常公开的声明说:</target>
        </trans-unit>
        <trans-unit id="9c1822b09998ebb74d19f39d240afd93e64789bf" translate="yes" xml:space="preserve">
          <source>If someone else administers the server, they should tell you what directory to put the repository in, and what &lt;code&gt;git://&lt;/code&gt; URL it will appear at. You can then skip to the section &quot;&lt;a href=&quot;#pushing-changes-to-a-public-repository&quot;&gt;Pushing changes to a public repository&lt;/a&gt;&quot;, below.</source>
          <target state="translated">如果其他人管理服务器，他们应该告诉您将存储库放在哪个目录，以及它将出现在哪个 &lt;code&gt;git://&lt;/code&gt; URL。然后，您可以跳到下面的&amp;ldquo;将&lt;a href=&quot;#pushing-changes-to-a-public-repository&quot;&gt;更改推送到公共存储库&lt;/a&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="4199717fddcec6935af08019e365f779fa359364" translate="yes" xml:space="preserve">
          <source>If specified twice, show in addition the unified diff between what would be committed and the worktree files, i.e. the unstaged changes to tracked files.</source>
          <target state="translated">如果指定了两次,则另外显示将提交的内容和工作树文件之间的统一差异,即对跟踪文件的非阶段性修改。</target>
        </trans-unit>
        <trans-unit id="fcf7bcff6fb66a8267ebcd9b00a7e09f8cfe6596" translate="yes" xml:space="preserve">
          <source>If that version is broken, type</source>
          <target state="translated">如果该版本已损坏,请输入</target>
        </trans-unit>
        <trans-unit id="c26c727c738ef7a0a9fa459f5d8c7e2c7478ba23" translate="yes" xml:space="preserve">
          <source>If the &quot;pattern&quot; URL does include a path component, then this too must match exactly: the context &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; will match a config entry for &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; (in addition to matching the config entry for &lt;code&gt;https://example.com&lt;/code&gt;) but will not match a config entry for &lt;code&gt;https://example.com/bar&lt;/code&gt;.</source>
          <target state="translated">如果&amp;ldquo;模式&amp;rdquo; URL包括路径组件，那么这个也必须完全匹配：上下文 &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; 将匹配一个配置项 &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; （除了匹配 &lt;code&gt;https://example.com&lt;/code&gt; 的配置条目），但不匹配 &lt;code&gt;https://example.com/bar&lt;/code&gt; 的配置条目。</target>
        </trans-unit>
        <trans-unit id="c4d8f312459b1b390b1c7f9b1bd219e73052861c" translate="yes" xml:space="preserve">
          <source>If the &amp;lt;value&amp;gt; part of any trailer contains only whitespace, the whole trailer will be removed from the resulting message. This applies to existing trailers as well as new trailers.</source>
          <target state="translated">如果任何预告片的&amp;lt;value&amp;gt;部分仅包含空格，则整个预告片将从结果消息中删除。这适用于现有的拖车以及新的拖车。</target>
        </trans-unit>
        <trans-unit id="b64722d374d9ba94f59d4b75e0b20b3d04a38c9e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$GIT_DIR&lt;/code&gt; environment variable is set then it specifies a path to use instead of &lt;code&gt;./.git&lt;/code&gt; for the base of the repository.</source>
          <target state="translated">如果设置了 &lt;code&gt;$GIT_DIR&lt;/code&gt; 环境变量，则它将指定用于存储库基础的路径，而不是 &lt;code&gt;./.git&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="010f47d5eb5a20440d8f9779a052d1045e200486" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--anonymize&lt;/code&gt; option is given, git will attempt to remove all identifying information from the repository while still retaining enough of the original tree and history patterns to reproduce some bugs. The goal is that a git bug which is found on a private repository will persist in the anonymized repository, and the latter can be shared with git developers to help solve the bug.</source>
          <target state="translated">如果给出了 &lt;code&gt;--anonymize&lt;/code&gt; 选项，则git将尝试从存储库中删除所有标识信息，同时仍保留足够的原始树和历史记录模式来重现一些错误。目的是在私有存储库中找到一个git bug，将其保留在匿名存储库中，后者可以与git开发人员共享以帮助解决该错误。</target>
        </trans-unit>
        <trans-unit id="c4c6f80eebbd991a705883e3a7ddf7805d5a2ad9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--autosquash&lt;/code&gt; option is enabled by default using the configuration variable &lt;code&gt;rebase.autoSquash&lt;/code&gt;, this option can be used to override and disable this setting.</source>
          <target state="translated">如果默认情况下使用配置变量 &lt;code&gt;rebase.autoSquash&lt;/code&gt; 启用了 &lt;code&gt;--autosquash&lt;/code&gt; 选项，则可以使用此选项覆盖和禁用此设置。</target>
        </trans-unit>
        <trans-unit id="0cf1db99e3ec777fa9fc759a96b9df8702668643" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--done&lt;/code&gt; command-line option or &lt;code&gt;feature done&lt;/code&gt; command is in use, the &lt;code&gt;done&lt;/code&gt; command is mandatory and marks the end of the stream.</source>
          <target state="translated">如果使用了 &lt;code&gt;--done&lt;/code&gt; 命令行选项或 &lt;code&gt;feature done&lt;/code&gt; 命令，则 &lt;code&gt;done&lt;/code&gt; 命令是强制性的，并标记流的结尾。</target>
        </trans-unit>
        <trans-unit id="a0c52682314428d0b2cfaeb79c7cb6ca41bbd107" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--include-untracked&lt;/code&gt; option is used, all untracked files are also stashed and then cleaned up with &lt;code&gt;git clean&lt;/code&gt;, leaving the working directory in a very clean state. If the &lt;code&gt;--all&lt;/code&gt; option is used instead then the ignored files are stashed and cleaned in addition to the untracked files.</source>
          <target state="translated">如果使用了 &lt;code&gt;--include-untracked&lt;/code&gt; 选项，则所有未跟踪的文件也会被保存，然后使用 &lt;code&gt;git clean&lt;/code&gt; 进行清理，使工作目录处于非常干净的状态。如果改用 &lt;code&gt;--all&lt;/code&gt; 选项，则除了未跟踪的文件外，还将隐藏和清除被忽略的文件。</target>
        </trans-unit>
        <trans-unit id="bbfa929c9630d94c6f050152effe58514108dc44" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--index&lt;/code&gt; option is used, then tries to reinstate not only the working tree&amp;rsquo;s changes, but also the index&amp;rsquo;s ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally).</source>
          <target state="translated">如果使用 &lt;code&gt;--index&lt;/code&gt; 选项，则不仅尝试恢复工作树的更改，而且尝试恢复索引的更改。但是，当您有冲突时（存储在索引中，因此您不再可以像以前一样应用更改），这可能会失败。</target>
        </trans-unit>
        <trans-unit id="f3433648ddba23324bfe890535ea8fba49406cc9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--keep-index&lt;/code&gt; option is used, all changes already added to the index are left intact.</source>
          <target state="translated">如果使用 &lt;code&gt;--keep-index&lt;/code&gt; 选项，则已添加到索引的所有更改均保持不变。</target>
        </trans-unit>
        <trans-unit id="f0b71e8c338c336264145f9c00a25064d3a5d745" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--multiple&lt;/code&gt; option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings &lt;code&gt;fetch.parallel&lt;/code&gt; and &lt;code&gt;submodule.fetchJobs&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">如果指定了 &lt;code&gt;--multiple&lt;/code&gt; 选项，则将并行获取不同的遥控器。如果获取多个子模块，则将并行获取它们。要独立控制它们，请使用配置设置 &lt;code&gt;fetch.parallel&lt;/code&gt; 和 &lt;code&gt;submodule.fetchJobs&lt;/code&gt; （请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="86926b76e3db734e6c786d5fed43f678b858b280" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is not set, &lt;code&gt;git log&lt;/code&gt; is used instead. You can also give command-line options such as &lt;code&gt;-p&lt;/code&gt; and &lt;code&gt;--stat&lt;/code&gt;.</source>
          <target state="translated">如果未设置 &lt;code&gt;DISPLAY&lt;/code&gt; 环境变量，则改用 &lt;code&gt;git log&lt;/code&gt; 。您还可以提供命令行选项，例如 &lt;code&gt;-p&lt;/code&gt; 和 &lt;code&gt;--stat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d759f2e991e02f3a71fd36511a7699e5f49db70c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GIT_ASKPASS&lt;/code&gt; environment variable is set, the program specified by the variable is invoked. A suitable prompt is provided to the program on the command line, and the user&amp;rsquo;s input is read from its standard output.</source>
          <target state="translated">如果设置了 &lt;code&gt;GIT_ASKPASS&lt;/code&gt; 环境变量，则将调用由该变量指定的程序。在命令行上会向程序提供适当的提示，并从其标准输出中读取用户的输入。</target>
        </trans-unit>
        <trans-unit id="4b682e3beccdc952b131cf46cc2adb457e7b0390" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable is set then it specifies a path to use instead of the default &lt;code&gt;.git&lt;/code&gt; for the base of the repository. The &lt;code&gt;--git-dir&lt;/code&gt; command-line option also sets this value.</source>
          <target state="translated">如果设置了 &lt;code&gt;GIT_DIR&lt;/code&gt; 环境变量，则它为存储库的基础指定要使用的路径，而不是默认的 &lt;code&gt;.git&lt;/code&gt; 。该 &lt;code&gt;--git-dir&lt;/code&gt; 命令行选项还设置这个值。</target>
        </trans-unit>
        <trans-unit id="643cae995a607334b36d06d83fbe3fb662a8bb45" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;done&lt;/code&gt; feature is not in use, treated as if EOF was read. This can be used to tell fast-import to finish early.</source>
          <target state="translated">如果未使用 &lt;code&gt;done&lt;/code&gt; 功能，则将其视为已读取EOF。这可以用来告诉快速导入提前完成。</target>
        </trans-unit>
        <trans-unit id="18aa9d79f5a644e72e69f66c98e1e834c977b6b0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;filter&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request:</source>
          <target state="translated">如果发布了 &lt;code&gt;filter&lt;/code&gt; 功能，则可以在客户端的请求中包含以下参数：</target>
        </trans-unit>
        <trans-unit id="338c6269ff70e3588bd2606af346bee907c22325" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;git credential&lt;/code&gt; knew about the password, this step may not have involved the user actually typing this password (the user may have typed a password to unlock the keychain instead, or no user interaction was done if the keychain was already unlocked) before it returned &lt;code&gt;password=secr3t&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;git credential&lt;/code&gt; 知道密码，则此步骤可能尚未涉及用户实际输入此密码（用户可能已键入密码来解锁钥匙串，或者如果钥匙链已解锁，则用户未进行任何交互）。返回的 &lt;code&gt;password=secr3t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="042e7419aeefb97aea8089e7aef725093dfeada4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;packfile-uris&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request as well as the potential addition of the &lt;code&gt;packfile-uris&lt;/code&gt; section in the server&amp;rsquo;s response as explained below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7bad5825e1ca0d0f2641273cfd194a2b47fe7f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ref-in-want&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request as well as the potential addition of the &lt;code&gt;wanted-refs&lt;/code&gt; section in the server&amp;rsquo;s response as explained below.</source>
          <target state="translated">如果发布了需要 &lt;code&gt;ref-in-want&lt;/code&gt; 功能，则可以在客户端的请求中以及服务器响应中可能添加的 &lt;code&gt;wanted-refs&lt;/code&gt; 部分中包含以下自变量，如下所述。</target>
        </trans-unit>
        <trans-unit id="8ee9fffd993cfbf2d4a66bab484646e0aab5c31d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shallow&lt;/code&gt; feature is advertised the following arguments can be included in the clients request as well as the potential addition of the &lt;code&gt;shallow-info&lt;/code&gt; section in the server&amp;rsquo;s response as explained below.</source>
          <target state="translated">如果发布了 &lt;code&gt;shallow&lt;/code&gt; 功能，则可以在客户端请求中包括以下参数，以及在服务器响应中可能增加 &lt;code&gt;shallow-info&lt;/code&gt; 部分，如下所述。</target>
        </trans-unit>
        <trans-unit id="cc56c6c35649e4cbd1848d389261cbadfd34e234" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sideband-all&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request:</source>
          <target state="translated">如果发布了 &lt;code&gt;sideband-all&lt;/code&gt; 功能，则客户端的请求中可以包含以下参数：</target>
        </trans-unit>
        <trans-unit id="5221b8fce1b302181f6152b9a7b516c793a8424a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;text&lt;/code&gt; attribute is unspecified, Git uses the &lt;code&gt;core.autocrlf&lt;/code&gt; configuration variable to determine if the file should be converted.</source>
          <target state="translated">如果未指定 &lt;code&gt;text&lt;/code&gt; 属性，则Git使用 &lt;code&gt;core.autocrlf&lt;/code&gt; 配置变量来确定是否应转换文件。</target>
        </trans-unit>
        <trans-unit id="501d792e8a9528e67beb280aae4c4f6b3a3116f1" translate="yes" xml:space="preserve">
          <source>If the Git configuration variable clean.requireForce is not set to false, &lt;code&gt;git clean&lt;/code&gt; will refuse to delete files or directories unless given -f or -i. Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given.</source>
          <target state="translated">如果Git配置变量clean.requireForce未设置为false，除非给定-f或-i，否则 &lt;code&gt;git clean&lt;/code&gt; 将拒绝删除文件或目录。除非给出第二个-f，否则Git将拒绝修改未跟踪的嵌套git存储库（带有.git子目录的目录）。</target>
        </trans-unit>
        <trans-unit id="1a08af52d1bb96063df69a1ba9c6458415ca2e42" translate="yes" xml:space="preserve">
          <source>If the HTTP transfer speed is less than &lt;code&gt;http.lowSpeedLimit&lt;/code&gt; for longer than &lt;code&gt;http.lowSpeedTime&lt;/code&gt; seconds, the transfer is aborted. Can be overridden by the &lt;code&gt;GIT_HTTP_LOW_SPEED_LIMIT&lt;/code&gt; and &lt;code&gt;GIT_HTTP_LOW_SPEED_TIME&lt;/code&gt; environment variables.</source>
          <target state="translated">如果HTTP传输速度小于 &lt;code&gt;http.lowSpeedLimit&lt;/code&gt; 的时间超过 &lt;code&gt;http.lowSpeedTime&lt;/code&gt; 秒，则传输将中止。可以被 &lt;code&gt;GIT_HTTP_LOW_SPEED_LIMIT&lt;/code&gt; 和 &lt;code&gt;GIT_HTTP_LOW_SPEED_TIME&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="6c44d5cf7886c82987c35de787d30a82008f591b" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;approve&lt;/code&gt; or &lt;code&gt;reject&lt;/code&gt;, no output should be emitted.</source>
          <target state="translated">如果操作是 &lt;code&gt;approve&lt;/code&gt; 或 &lt;code&gt;reject&lt;/code&gt; ，则不应发出任何输出。</target>
        </trans-unit>
        <trans-unit id="a7a299c18f6719e8e8b963c0bc834abd5de39626" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;approve&lt;/code&gt;, git-credential will send the description to any configured credential helpers, which may store the credential for later use.</source>
          <target state="translated">如果操作被 &lt;code&gt;approve&lt;/code&gt; ，则git-credential会将描述发送给任何已配置的凭据帮助器，该帮助器可以存储该凭据以供以后使用。</target>
        </trans-unit>
        <trans-unit id="7fc4d66ebd944d4cf73c3d3a8712c0dec288c62f" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;fill&lt;/code&gt;, git-credential will attempt to add &quot;username&quot; and &quot;password&quot; attributes to the description by reading config files, by contacting any configured credential helpers, or by prompting the user. The username and password attributes of the credential description are then printed to stdout together with the attributes already provided.</source>
          <target state="translated">如果操作为 &lt;code&gt;fill&lt;/code&gt; ，则git-credential将尝试通过读取配置文件，联系任何已配置的凭据帮助程序或提示用户来向描述中添加&amp;ldquo;用户名&amp;rdquo;和&amp;ldquo;密码&amp;rdquo;属性。然后将凭证描述的用户名和密码属性与已经提供的属性一起打印到stdout。</target>
        </trans-unit>
        <trans-unit id="194451718843bfcaf463de902599c24ff69e0de0" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;reject&lt;/code&gt;, git-credential will send the description to any configured credential helpers, which may erase any stored credential matching the description.</source>
          <target state="translated">如果该操作被 &lt;code&gt;reject&lt;/code&gt; ，则git-credential会将描述发送给任何已配置的凭据帮助器，这些帮助器可能会删除所有与该描述匹配的存储凭据。</target>
        </trans-unit>
        <trans-unit id="d8fc44b68b56d1ac1b923c6197e4ad961f9ec579" translate="yes" xml:space="preserve">
          <source>If the alias expansion is prefixed with an exclamation point, it will be treated as a shell command. For example, defining &lt;code&gt;alias.new = !gitk --all --not ORIG_HEAD&lt;/code&gt;, the invocation &lt;code&gt;git new&lt;/code&gt; is equivalent to running the shell command &lt;code&gt;gitk --all --not ORIG_HEAD&lt;/code&gt;. Note that shell commands will be executed from the top-level directory of a repository, which may not necessarily be the current directory. &lt;code&gt;GIT_PREFIX&lt;/code&gt; is set as returned by running &lt;code&gt;git rev-parse --show-prefix&lt;/code&gt; from the original current directory. See &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">如果别名扩展名带有感叹号作为前缀，它将被视为shell命令。例如，定义 &lt;code&gt;alias.new = !gitk --all --not ORIG_HEAD&lt;/code&gt; ，调用 &lt;code&gt;git new&lt;/code&gt; 等效于运行shell命令 &lt;code&gt;gitk --all --not ORIG_HEAD&lt;/code&gt; 。请注意，shell命令将从存储库的顶级目录执行，该目录不一定是当前目录。通过从原始当前目录运行 &lt;code&gt;git rev-parse --show-prefix&lt;/code&gt; 将 &lt;code&gt;GIT_PREFIX&lt;/code&gt; 设置为返回。参见&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81bb3cca543b16e19f5e2adb35c917e85fde2f7d" translate="yes" xml:space="preserve">
          <source>If the amount of memory estimated for &lt;code&gt;git repack&lt;/code&gt; to run smoothly is not available and &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; is not set, the largest pack will also be excluded (this is the equivalent of running &lt;code&gt;git gc&lt;/code&gt; with &lt;code&gt;--keep-base-pack&lt;/code&gt;).</source>
          <target state="translated">如果无法估计 &lt;code&gt;git repack&lt;/code&gt; 平稳运行所需的内存量，并且未设置 &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; ，则最大包也将被排除（这与使用 &lt;code&gt;git gc&lt;/code&gt; 和 &lt;code&gt;--keep-base-pack&lt;/code&gt; 等效）。</target>
        </trans-unit>
        <trans-unit id="28ae5c748411e761b0bfb160798c17e5330bf010" translate="yes" xml:space="preserve">
          <source>If the anonymized repository shows the bug, it may be worth sharing &lt;code&gt;anon-stream&lt;/code&gt; along with a regular bug report. Note that the anonymized stream compresses very well, so gzipping it is encouraged. If you want to examine the stream to see that it does not contain any private data, you can peruse it directly before sending. You may also want to try:</source>
          <target state="translated">如果匿名存储库显示该错误，则可能值得将 &lt;code&gt;anon-stream&lt;/code&gt; 与常规错误报告一起共享。请注意，匿名流的压缩效果非常好，因此建议将其压缩。如果要检查流以查看其中不包含任何私有数据，则可以在发送之前直接细读它。您可能还想尝试：</target>
        </trans-unit>
        <trans-unit id="723ec66f7929012c8a6ac732a23c4db7a105b505" translate="yes" xml:space="preserve">
          <source>If the attribute &lt;code&gt;export-subst&lt;/code&gt; is set for a file then Git will expand several placeholders when adding this file to an archive. The expansion depends on the availability of a commit ID, i.e., if &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; has been given a tree instead of a commit or a tag then no replacement will be done. The placeholders are the same as those for the option &lt;code&gt;--pretty=format:&lt;/code&gt; of &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, except that they need to be wrapped like this: &lt;code&gt;$Format:PLACEHOLDERS$&lt;/code&gt; in the file. E.g. the string &lt;code&gt;$Format:%H$&lt;/code&gt; will be replaced by the commit hash.</source>
          <target state="translated">如果为文件设置了属性 &lt;code&gt;export-subst&lt;/code&gt; ,则在将此文件添加到归档文件时，Git将扩展几个占位符。扩展取决于提交ID的可用性，即，如果给&lt;a href=&quot;git-archive&quot;&gt;git-archive [1]&lt;/a&gt;树而不是提交或标签，那么将不会进行替换。占位符与&lt;a href=&quot;git-log&quot;&gt;git-log [1]的&lt;/a&gt; &lt;code&gt;--pretty=format:&lt;/code&gt; 选项的占位符相同，除了它们需要像这样包装： &lt;code&gt;$Format:PLACEHOLDERS$&lt;/code&gt; 在文件中。例如，字符串 &lt;code&gt;$Format:%H$&lt;/code&gt; 将被提交哈希替换。</target>
        </trans-unit>
        <trans-unit id="bd056a8735e1abbf79ce6a360a1a80c3f28cbbd6" translate="yes" xml:space="preserve">
          <source>If the attribute export-subst is set for a file then Git will expand several placeholders when adding this file to an archive. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">如果为文件设置了属性export-subst，则在将此文件添加到归档文件时，Git将扩展几个占位符。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da80064c2ffb4013d75c1676828faa86849266b6" translate="yes" xml:space="preserve">
          <source>If the bisection process is driven manually, you can use &quot;git bisect skip&quot; to do the same thing. (In fact the special exit code 125 makes &quot;git bisect run&quot; use &quot;git bisect skip&quot; in the background.)</source>
          <target state="translated">如果双分过程是手动驱动的,你可以使用 &quot;git bisect skip &quot;来做同样的事情,(事实上,特殊的退出代码125使得 &quot;git bisect run &quot;在后台使用 &quot;git bisect skip&quot;)。事实上,特殊的退出代码125使得 &quot;git bisect run &quot;在后台使用 &quot;git bisect skip&quot;)。</target>
        </trans-unit>
        <trans-unit id="92ad120c671c36b884538f372611cf38d29a6827" translate="yes" xml:space="preserve">
          <source>If the branch exists in multiple remotes and one of them is named by the &lt;code&gt;checkout.defaultRemote&lt;/code&gt; configuration variable, we&amp;rsquo;ll use that one for the purposes of disambiguation, even if the &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; isn&amp;rsquo;t unique across all remotes. Set it to e.g. &lt;code&gt;checkout.defaultRemote=origin&lt;/code&gt; to always checkout remote branches from there if &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is ambiguous but exists on the &lt;code&gt;origin&lt;/code&gt; remote. See also &lt;code&gt;checkout.defaultRemote&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">如果分支存在于多个远程站点中，并且其中一个分支由 &lt;code&gt;checkout.defaultRemote&lt;/code&gt; 配置变量命名，则出于消除歧义的目的，即使 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 在所有远程站点中并非唯一，我们也将使用该分支。将其设置为例如 &lt;code&gt;checkout.defaultRemote=origin&lt;/code&gt; ,以始终在 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 不明确但存在于 &lt;code&gt;origin&lt;/code&gt; 远程站点上的情况下从那里签出远程分支。还参见 &lt;code&gt;checkout.defaultRemote&lt;/code&gt; 在&lt;a href=&quot;git-config&quot;&gt;GIT-配置[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c39c5c03f65f2a5b7cc29c6c30fb330e225795da" translate="yes" xml:space="preserve">
          <source>If the changes are independent enough, Git will automatically complete the merge and commit the result (or reuse an existing commit in case of &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;, see below). On the other hand, if there are conflicts&amp;mdash;​for example, if the same file is modified in two different ways in the remote branch and the local branch&amp;mdash;​then you are warned; the output may look something like this:</source>
          <target state="translated">如果更改足够独立，则Git将自动完成合并并提交结果（或在&lt;a href=&quot;#fast-forwards&quot;&gt;快进的&lt;/a&gt;情况下重用现有的提交，请参见下文）。另一方面，如果存在冲突-例如，如果在远程分支和本地分支中以两种不同的方式修改了同一文件-那么将警告您; 输出可能如下所示：</target>
        </trans-unit>
        <trans-unit id="288f48e57898c3a0706dea1db36d760600650737" translate="yes" xml:space="preserve">
          <source>If the changes don&amp;rsquo;t conflict, you&amp;rsquo;re done. If there are conflicts, markers will be left in the problematic files showing the conflict;</source>
          <target state="translated">如果更改不冲突，就完成了。如果存在冲突，标记将留在有问题的文件中，以显示冲突；</target>
        </trans-unit>
        <trans-unit id="0c9dca535f00f8f010f3f51cbdf5a64ba071ad26" translate="yes" xml:space="preserve">
          <source>If the checkout is done via rebase, local submodule commits are rebased as well.</source>
          <target state="translated">如果通过rebase进行签出,本地子模块的提交也会被重新基于。</target>
        </trans-unit>
        <trans-unit id="da1ce847fd50c0ebce51907161b2297389c68a97" translate="yes" xml:space="preserve">
          <source>If the command contains the &lt;code&gt;$ARG&lt;/code&gt; string, this string will be replaced with the &amp;lt;value&amp;gt; part of an existing trailer with the same &amp;lt;token&amp;gt;, if any, before the command is launched.</source>
          <target state="translated">如果命令包含 &lt;code&gt;$ARG&lt;/code&gt; 字符串，则在启动命令之前，此字符串将替换为具有相同&amp;lt;token&amp;gt;（如果有）的现有预告片的&amp;lt;value&amp;gt;部分。</target>
        </trans-unit>
        <trans-unit id="d68b3a0db25981cb416126191f5f7a8b40a5795b" translate="yes" xml:space="preserve">
          <source>If the commit is a merge commit, you must tell &lt;code&gt;git cvsexportcommit&lt;/code&gt; what parent the changeset should be done against.</source>
          <target state="translated">如果提交是合并提交，则必须告诉 &lt;code&gt;git cvsexportcommit&lt;/code&gt; 更改集应针对哪个父级。</target>
        </trans-unit>
        <trans-unit id="50eff6c32d5b1376396b813f799767464152ed15" translate="yes" xml:space="preserve">
          <source>If the commit is a merge, and if the pretty-format is not &lt;code&gt;oneline&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt; or &lt;code&gt;raw&lt;/code&gt;, an additional line is inserted before the &lt;code&gt;Author:&lt;/code&gt; line. This line begins with &quot;Merge: &quot; and the hashes of ancestral commits are printed, separated by spaces. Note that the listed commits may not necessarily be the list of the &lt;strong&gt;direct&lt;/strong&gt; parent commits if you have limited your view of history: for example, if you are only interested in changes related to a certain directory or file.</source>
          <target state="translated">如果提交是合并，并且如果pretty-format格式不是 &lt;code&gt;oneline&lt;/code&gt; ， &lt;code&gt;email&lt;/code&gt; 或 &lt;code&gt;raw&lt;/code&gt; ，则在 &lt;code&gt;Author:&lt;/code&gt; 行之前插入另一行。该行以&amp;ldquo; Merge：&amp;rdquo;开头，并打印祖先提交的哈希，并用空格分隔。请注意，如果您限制了历史记录的视图，例如，如果您仅对与某个目录或文件相关的更改感兴趣，则列出的提交不一定是&lt;strong&gt;直接&lt;/strong&gt;父提交的列表。</target>
        </trans-unit>
        <trans-unit id="fb562926c30c7dcdbad03cee2dab579f6b030079" translate="yes" xml:space="preserve">
          <source>If the commit is done directly by using &lt;code&gt;git&lt;/code&gt; (as opposed to using &lt;code&gt;git-cvsserver&lt;/code&gt;) the update will need to happen on the next repository access by &lt;code&gt;git-cvsserver&lt;/code&gt;, independent of access method and requested operation.</source>
          <target state="translated">如果使用 &lt;code&gt;git&lt;/code&gt; （而不是使用 &lt;code&gt;git-cvsserver&lt;/code&gt; ）直接完成提交，则更新将需要在 &lt;code&gt;git-cvsserver&lt;/code&gt; 的下一个存储库访问中进行，而与访问方法和所请求的操作无关。</target>
        </trans-unit>
        <trans-unit id="f829bbddf6f6f452756492321328ac75e498d9d9" translate="yes" xml:space="preserve">
          <source>If the config option &lt;code&gt;uploadArchive.allowUnreachable&lt;/code&gt; is true, these rules are ignored, and clients may use arbitrary sha1 expressions. This is useful if you do not care about the privacy of unreachable objects, or if your object database is already publicly available for access via non-smart-http.</source>
          <target state="translated">如果配置选项 &lt;code&gt;uploadArchive.allowUnreachable&lt;/code&gt; 为true，则将忽略这些规则，并且客户端可以使用任意sha1表达式。如果您不关心无法访问的对象的私密性，或者您的对象数据库已经公开可用于通过非smart-http访问，这将很有用。</target>
        </trans-unit>
        <trans-unit id="a1bf5bff98f507f37d5394622406355fb10d8518" translate="yes" xml:space="preserve">
          <source>If the config variable &lt;code&gt;status.relativePaths&lt;/code&gt; is set to false, then all paths shown are relative to the repository root, not to the current directory.</source>
          <target state="translated">如果将配置变量 &lt;code&gt;status.relativePaths&lt;/code&gt; 设置为false，则显示的所有路径都相对于存储库根目录，而不是相对于当前目录。</target>
        </trans-unit>
        <trans-unit id="15abc3d7884a27f6ef940ec31e7ff01ecc03f9f0" translate="yes" xml:space="preserve">
          <source>If the configuration variable &lt;code&gt;instaweb.browser&lt;/code&gt; is not set, &lt;code&gt;web.browser&lt;/code&gt; will be used instead if it is defined. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3ff15aa0e04d429d03e9f6131934c58fa371f6" translate="yes" xml:space="preserve">
          <source>If the configuration variable &lt;code&gt;instaweb.browser&lt;/code&gt; is not set, &lt;code&gt;web.browser&lt;/code&gt; will be used instead if it is defined. See git-web{litdd}browse[1] for more information about this.</source>
          <target state="translated">如果未设置配置变量 &lt;code&gt;instaweb.browser&lt;/code&gt; ，则将使用 &lt;code&gt;web.browser&lt;/code&gt; (如果已定义）。有关更多信息，请参见git-web {litdd} browse [1]。</target>
        </trans-unit>
        <trans-unit id="63b229ee2ee5c7c387585f3ec858739b37c09980" translate="yes" xml:space="preserve">
          <source>If the current HEAD is the same as the parent of the cherry-pick&amp;rsquo;ed commit, then a fast forward to this commit will be performed.</source>
          <target state="translated">如果当前HEAD与Cherry-pick提交的提交的父节点相同，则将快速前进到该提交。</target>
        </trans-unit>
        <trans-unit id="7ca0a51612928d164dbfccc37787084c17e98850" translate="yes" xml:space="preserve">
          <source>If the custom merge tool correctly indicates the success of a merge resolution with its exit code, then the configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.trustExitCode&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;git mergetool&lt;/code&gt; will prompt the user to indicate the success of the resolution after the custom tool has exited.</source>
          <target state="translated">如果自定义合并工具及其退出代码正确地指示了合并解决方案的成功，则可以将配置变量 &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.trustExitCode&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 。否则， &lt;code&gt;git mergetool&lt;/code&gt; 将在退出自定义工具后提示用户指示解析成功。</target>
        </trans-unit>
        <trans-unit id="36390d22499feba94308c3d2a6c08dfbe3009ec3" translate="yes" xml:space="preserve">
          <source>If the exit status is non-zero, &lt;code&gt;git commit&lt;/code&gt; will abort.</source>
          <target state="translated">如果退出状态为非零，则 &lt;code&gt;git commit&lt;/code&gt; 将中止。</target>
        </trans-unit>
        <trans-unit id="ffb6fc6e4737a7b7be769bd191cc211dd325235f" translate="yes" xml:space="preserve">
          <source>If the file &lt;code&gt;.mailmap&lt;/code&gt; exists at the toplevel of the repository, or at the location pointed to by the mailmap.file or mailmap.blob configuration options, it is used to map author and committer names and email addresses to canonical real names and email addresses.</source>
          <target state="translated">如果文件 &lt;code&gt;.mailmap&lt;/code&gt; 存在于存储库的顶层，或者存在于mailmap.file或mailmap.blob配置选项所指向的位置，则它用于将作者和提交者的名称以及电子邮件地址映射为规范的真实名称和电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="7142e4ddc34f82f593252b78cfae14d3292c9524" translate="yes" xml:space="preserve">
          <source>If the file gc.log exists, then &lt;code&gt;git gc --auto&lt;/code&gt; will print its content and exit with status zero instead of running unless that file is more than &lt;code&gt;gc.logExpiry&lt;/code&gt; old. Default is &quot;1.day&quot;. See &lt;code&gt;gc.pruneExpire&lt;/code&gt; for more ways to specify its value.</source>
          <target state="translated">如果文件gc.log存在，则 &lt;code&gt;git gc --auto&lt;/code&gt; 将打印其内容并以零状态退出，而不是运行，除非该文件大于 &lt;code&gt;gc.logExpiry&lt;/code&gt; 旧文件。默认值为&amp;ldquo; 1.day&amp;rdquo;。有关更多指定其值的方法，请参见 &lt;code&gt;gc.pruneExpire&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7333f3457fce187a5640d74385a1bbc89a0c5a97" translate="yes" xml:space="preserve">
          <source>If the filter command (a string value) is defined via &lt;code&gt;filter.&amp;lt;driver&amp;gt;.process&lt;/code&gt; then Git can process all blobs with a single filter invocation for the entire life of a single Git command. This is achieved by using the long-running process protocol (described in technical/long-running-process-protocol.txt).</source>
          <target state="translated">如果通过 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.process&lt;/code&gt; 定义了过滤器命令（字符串值），则Git可以在单个Git命令的整个生命周期内通过一次过滤器调用来处理所有Blob。这是通过使用长时间运行的过程协议（在technical / long-running-process-protocol.txt中描述）来实现的。</target>
        </trans-unit>
        <trans-unit id="edaaa7b77ca9e9ee284b92c3f4abf94dbe583827" translate="yes" xml:space="preserve">
          <source>If the filter dies during the communication or does not adhere to the protocol then Git will stop the filter process and restart it with the next file that needs to be processed. Depending on the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; flag Git will interpret that as error.</source>
          <target state="translated">如果过滤器在通信过程中死机或不遵守协议，则Git将停止过滤器过程，并使用下一个需要处理的文件重新启动它。取决于 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; 标志Git会将其解释为错误。</target>
        </trans-unit>
        <trans-unit id="5e14f4a25e8ac87108268501a2fbb6eaeaabe84f" translate="yes" xml:space="preserve">
          <source>If the filter experiences an error during processing, then it can send the status &quot;error&quot; after the content was (partially or completely) sent.</source>
          <target state="translated">如果过滤器在处理过程中遇到错误,那么它可以在内容(部分或全部)发送后发送状态 &quot;错误&quot;。</target>
        </trans-unit>
        <trans-unit id="4bace70b57e96bff11ceac069e6098423752b6f8" translate="yes" xml:space="preserve">
          <source>If the filter supports the &quot;delay&quot; capability then it must support the &quot;list_available_blobs&quot; command. If Git sends this command, then the filter is expected to return a list of pathnames representing blobs that have been delayed earlier and are now available. The list must be terminated with a flush packet followed by a &quot;success&quot; status that is also terminated with a flush packet. If no blobs for the delayed paths are available, yet, then the filter is expected to block the response until at least one blob becomes available. The filter can tell Git that it has no more delayed blobs by sending an empty list. As soon as the filter responds with an empty list, Git stops asking. All blobs that Git has not received at this point are considered missing and will result in an error.</source>
          <target state="translated">如果过滤器支持 &quot;延迟 &quot;功能,那么它必须支持 &quot;list_available_blobs &quot;命令。如果 Git 发送了这个命令,那么过滤器将返回一个代表之前被延迟的、现在可用的 blobs 的路径名列表。列表必须以一个刷新包结束,然后以一个刷新包结束 &quot;成功 &quot;状态。如果被延迟的路径中还没有可用的blob,那么过滤器会阻止响应,直到至少有一个blob可用。过滤器可以通过发送一个空列表来告诉Git,它已经没有延迟的blob了。一旦过滤器响应了一个空列表,Git 就会停止询问。所有在这个时候还没有收到的 blolob 都会被认为是缺失的,并导致错误。</target>
        </trans-unit>
        <trans-unit id="03052ebbe356e67d3f76578abb0f90e9da0b94ac" translate="yes" xml:space="preserve">
          <source>If the filter supports the &quot;delay&quot; capability, then Git can send the flag &quot;can-delay&quot; after the filter command and pathname. This flag denotes that the filter can delay filtering the current blob (e.g. to compensate network latencies) by responding with no content but with the status &quot;delayed&quot; and a flush packet.</source>
          <target state="translated">如果过滤器支持 &quot;延迟 &quot;功能,那么Git可以在过滤器命令和路径名后面发送 &quot;can-delay &quot;标志。这个标志表示过滤器可以延迟过滤当前的blob(例如,为了补偿网络延迟),响应时不显示内容,只显示 &quot;delayed &quot;状态和一个刷新包。</target>
        </trans-unit>
        <trans-unit id="13eec1f811a3745751e3462b5df9eab594af45cb" translate="yes" xml:space="preserve">
          <source>If the format is set to &quot;auto:foo&quot; and the pager is in use, format &quot;foo&quot; will be the used for the date format. Otherwise &quot;default&quot; will be used.</source>
          <target state="translated">如果格式被设置为 &quot;auto:foo&quot;,并且寻呼机正在使用,那么日期格式将使用 &quot;foo&quot;。否则将使用 &quot;默认&quot;。</target>
        </trans-unit>
        <trans-unit id="7402fa03babc6cbdcbdc9c0c2d38f35b3f77eedb" translate="yes" xml:space="preserve">
          <source>If the given object refers to a blob, it will be described as &lt;code&gt;&amp;lt;commit-ish&amp;gt;:&amp;lt;path&amp;gt;&lt;/code&gt;, such that the blob can be found at &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; in the &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, which itself describes the first commit in which this blob occurs in a reverse revision walk from HEAD.</source>
          <target state="translated">如果给定对象引用一个Blob，则将其描述为 &lt;code&gt;&amp;lt;commit-ish&amp;gt;:&amp;lt;path&amp;gt;&lt;/code&gt; ，以便可以在 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 中的&amp;lt; &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 处找到该blob，该对象本身描述了以下内容中的第一个提交该斑点出现在从HEAD进行的反向修订中。</target>
        </trans-unit>
        <trans-unit id="5e980dfa1f5a4a3edafff4113df2abbd7d17f577" translate="yes" xml:space="preserve">
          <source>If the helper string begins with &quot;!&quot;, it is considered a shell snippet, and everything after the &quot;!&quot; becomes the command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228c738194bda1bc3c409314b8269609d7c41e0b" translate="yes" xml:space="preserve">
          <source>If the hook exits with non-zero status, none of the refs will be updated. If the hook exits with zero, updating of individual refs can still be prevented by the &lt;a href=&quot;#update&quot;&gt;&lt;em&gt;update&lt;/em&gt;&lt;/a&gt; hook.</source>
          <target state="translated">如果挂钩以非零状态退出，则不会更新任何引用。如果该挂钩以零退出，则仍然可以通过&lt;a href=&quot;#update&quot;&gt;&lt;em&gt;update&lt;/em&gt;&lt;/a&gt;挂钩来阻止单个引用的&lt;em&gt;更新&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8439515eb9b2d0e08bb52156ea070a5b55f21477" translate="yes" xml:space="preserve">
          <source>If the ignore-paths configuration key is set, and the command-line option is also given, both regular expressions will be used.</source>
          <target state="translated">如果设置了ignore-paths配置键,并且还给出了命令行选项,则会使用这两种正则表达式。</target>
        </trans-unit>
        <trans-unit id="e545fa5704075d5dfeae5601c6d9858dfebf0464" translate="yes" xml:space="preserve">
          <source>If the ignore-refs configuration key is set, and the command-line option is also given, both regular expressions will be used.</source>
          <target state="translated">如果设置了ignore-refs配置键,并且还给出了命令行选项,则会使用这两种正则表达式。</target>
        </trans-unit>
        <trans-unit id="f1e0ea5f0e79a32b5a2b025af2eaf1eb5f6a9a8a" translate="yes" xml:space="preserve">
          <source>If the last path components in the working tree&amp;rsquo;s path is unique among working trees, it can be used to identify a working tree. For example if you only have two working trees, at &lt;code&gt;/abc/def/ghi&lt;/code&gt; and &lt;code&gt;/abc/def/ggg&lt;/code&gt;, then &lt;code&gt;ghi&lt;/code&gt; or &lt;code&gt;def/ghi&lt;/code&gt; is enough to point to the former working tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368e2e291b26f0dca547e5b1c9de986c75896687" translate="yes" xml:space="preserve">
          <source>If the last path components in the working tree&amp;rsquo;s path is unique among working trees, it can be used to identify worktrees. For example if you only have two working trees, at &quot;/abc/def/ghi&quot; and &quot;/abc/def/ggg&quot;, then &quot;ghi&quot; or &quot;def/ghi&quot; is enough to point to the former working tree.</source>
          <target state="translated">如果工作树路径中的最后路径组件在工作树之间是唯一的，则可以使用它来标识工作树。例如，如果您只有两个工作树，分别在&amp;ldquo; / abc / def / ghi&amp;rdquo;和&amp;ldquo; / abc / def / ggg&amp;rdquo;，则&amp;ldquo; ghi&amp;rdquo;或&amp;ldquo; def / ghi&amp;rdquo;足以指向前一个工作树。</target>
        </trans-unit>
        <trans-unit id="a77fa7a1d051613196a1695412c9a05d33f69ded" translate="yes" xml:space="preserve">
          <source>If the local offset is not available in the source material, use &amp;ldquo;+0000&amp;rdquo;, or the most common local offset. For example many organizations have a CVS repository which has only ever been accessed by users who are located in the same location and time zone. In this case a reasonable offset from UTC could be assumed.</source>
          <target state="translated">如果源材料中没有局部偏移，请使用&amp;ldquo; +0000&amp;rdquo;或最常用的局部偏移。例如，许多组织都有一个CVS存储库，只有位于相同位置和时区的用户才可以访问它。在这种情况下，可以假设与UTC有合理的抵销。</target>
        </trans-unit>
        <trans-unit id="178f63f22948e35272dd2355f9864ebc5b092dbe" translate="yes" xml:space="preserve">
          <source>If the maintainer tells you that your patch no longer applies to the current upstream, you will have to rebase your topic (you cannot use a merge because you cannot format-patch merges):</source>
          <target state="translated">如果维护者告诉你,你的补丁不再适用于当前的上游,你将不得不重新建立你的主题(你不能使用合并,因为你不能格式化补丁合并)。</target>
        </trans-unit>
        <trans-unit id="9b0ae610cbbc854a9104beb55038f8e674b12699" translate="yes" xml:space="preserve">
          <source>If the merge cannot be carried out automatically, the conflicts need to be resolved and the result committed separately (see &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;). At that point, this hook will not be executed, but the &lt;code&gt;pre-commit&lt;/code&gt; hook will, if it is enabled.</source>
          <target state="translated">如果无法自动执行合并，则需要解决冲突，并分别提交结果（请参见&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;）。届时，该挂钩将不会被执行，但如果启用了 &lt;code&gt;pre-commit&lt;/code&gt; 挂钩，则它将被执行。</target>
        </trans-unit>
        <trans-unit id="e1f358924aaa72264d85ec0ddf7ef92dd8191058" translate="yes" xml:space="preserve">
          <source>If the merge fails because it is not a fast-forward, then it is possible some fixes on &lt;code&gt;maint&lt;/code&gt; were missed in the feature release. This will not happen if the content of the branches was verified as described in the previous section.</source>
          <target state="translated">如果合并由于不是快进而失败，则可能在功能版本中遗漏了对 &lt;code&gt;maint&lt;/code&gt; 的一些修复。如果分支的内容已按照上一节中的说明进行了验证，则不会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="39e28c0246f221ccbae77af3a33cb0a2f4910f1f" translate="yes" xml:space="preserve">
          <source>If the number of objects fetched over the Git native transfer is below this limit, then the objects will be unpacked into loose object files. However if the number of received objects equals or exceeds this limit then the received pack will be stored as a pack, after adding any missing delta bases. Storing the pack from a push can make the push operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">如果通过Git本机传输获取的对象数量低于此限制，则这些对象将被解压缩到松散的对象文件中。但是，如果接收到的对象数等于或超过此限制，则在添加任何缺失的增量基数之后，接收到的数据包将存储为一个数据包。通过推入存储包可以使推入操作更快地完成，尤其是在慢速文件系统上。如果未设置，则使用 &lt;code&gt;transfer.unpackLimit&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="ba1c0757ead2b007fd4bc7bc8fe3299d5f283bd7" translate="yes" xml:space="preserve">
          <source>If the number of objects imported by &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import[1]&lt;/a&gt; is below this limit, then the objects will be unpacked into loose object files. However if the number of imported objects equals or exceeds this limit then the pack will be stored as a pack. Storing the pack from a fast-import can make the import operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">如果&lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import [1]导入&lt;/a&gt;的对象数低于此限制，则这些对象将被解压缩到松散的对象文件中。但是，如果导入的对象数等于或超过此限制，则该包将作为包存储。通过快速导入存储包可以使导入操作更快地完成，尤其是在文件系统较慢的情况下。如果未设置，则使用 &lt;code&gt;transfer.unpackLimit&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="66dbfca32684aa415437926e2128b562d1010471" translate="yes" xml:space="preserve">
          <source>If the number of objects received in a push is below this limit then the objects will be unpacked into loose object files. However if the number of received objects equals or exceeds this limit then the received pack will be stored as a pack, after adding any missing delta bases. Storing the pack from a push can make the push operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">如果在一次推送中收到的对象数量低于此限制，则这些对象将被解压缩到松散的对象文件中。但是，如果接收到的对象数等于或超过此限制，则在添加任何缺失的增量基数之后，接收到的数据包将存储为一个数据包。通过推送存储数据包可以使推送操作更快地完成，尤其是在文件系统较慢的情况下。如果未设置，则使用 &lt;code&gt;transfer.unpackLimit&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e5106f465347ea1c1f64d4a4e406ce8334671d0b" translate="yes" xml:space="preserve">
          <source>If the object being copied out to a temporary file is a symbolic link the content of the link will be written to a normal file. It is up to the end-user or the Porcelain to make use of this information.</source>
          <target state="translated">如果被复制到临时文件的对象是一个符号链接,那么链接的内容将被写入一个正常的文件。终端用户或瓷器要利用这些信息。</target>
        </trans-unit>
        <trans-unit id="0199138006db8140692b7fdc79404759dcaa332d" translate="yes" xml:space="preserve">
          <source>If the object is stored as a delta on-disk, this expands to the 40-hex sha1 of the delta base object. Otherwise, expands to the null sha1 (40 zeroes). See &lt;code&gt;CAVEATS&lt;/code&gt; below.</source>
          <target state="translated">如果对象存储为增量磁盘上的内容，则该对象将扩展为增量基础对象的40十六进制sha1。否则，扩展为空sha1（40个零）。见 &lt;code&gt;CAVEATS&lt;/code&gt; 以下。</target>
        </trans-unit>
        <trans-unit id="bd902b813b2d32a3c916d53036b9b4661bcff5a2" translate="yes" xml:space="preserve">
          <source>If the object storage directory is specified via the &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; environment variable then the sha1 directories are created underneath - otherwise the default &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory is used.</source>
          <target state="translated">如果通过 &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; 环境变量指定了对象存储目录，则将在下面创建sha1目录-否则，将使用默认的 &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="5445d9592417f6217da69d0d0ffe49e2288619f2" translate="yes" xml:space="preserve">
          <source>If the object storage directory is specified via this environment variable then the sha1 directories are created underneath - otherwise the default &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory is used.</source>
          <target state="translated">如果通过此环境变量指定对象存储目录，则会在下面创建sha1目录-否则，将使用默认的 &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="5f2dc3f2759f3e631848eb5ab78d16a8be4a1f31" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--all&lt;/code&gt; or &lt;code&gt;-a&lt;/code&gt; is given, all available commands are printed on the standard output.</source>
          <target state="translated">如果给出选项 &lt;code&gt;--all&lt;/code&gt; 或 &lt;code&gt;-a&lt;/code&gt; ，则所有可用命令都将打印在标准输出上。</target>
        </trans-unit>
        <trans-unit id="5db3d9ce81a9166e23fdfafcb7cf25752ff75423" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--guide&lt;/code&gt; or &lt;code&gt;-g&lt;/code&gt; is given, a list of the useful Git guides is also printed on the standard output.</source>
          <target state="translated">如果给出了 &lt;code&gt;--guide&lt;/code&gt; 或 &lt;code&gt;-g&lt;/code&gt; 选项，则还会在标准输出上打印有用的Git指南列表。</target>
        </trans-unit>
        <trans-unit id="401de2382d11b6e27d9e64da4738d460ce293134" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--guides&lt;/code&gt; or &lt;code&gt;-g&lt;/code&gt; is given, a list of the Git concept guides is also printed on the standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d4a6b6cbe8c87e55028aafc6f2a3b165e3a3fa" translate="yes" xml:space="preserve">
          <source>If the patch contains any changes to submodules then &lt;code&gt;git apply&lt;/code&gt; treats these changes as follows.</source>
          <target state="translated">如果补丁包含对子模块的任何更改，则 &lt;code&gt;git apply&lt;/code&gt; 将按以下方式处理这些更改。</target>
        </trans-unit>
        <trans-unit id="bc5f440658cbf7f8fc36476e96067d0db070086e" translate="yes" xml:space="preserve">
          <source>If the pattern does not start with either &lt;code&gt;~/&lt;/code&gt;, &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**/&lt;/code&gt; will be automatically prepended. For example, the pattern &lt;code&gt;foo/bar&lt;/code&gt; becomes &lt;code&gt;**/foo/bar&lt;/code&gt; and would match &lt;code&gt;/any/path/to/foo/bar&lt;/code&gt;.</source>
          <target state="translated">如果模式不以任何启动 &lt;code&gt;~/&lt;/code&gt; ， &lt;code&gt;./&lt;/code&gt; 或 &lt;code&gt;/&lt;/code&gt; ， &lt;code&gt;**/&lt;/code&gt; 将自动前缀。例如，模式 &lt;code&gt;foo/bar&lt;/code&gt; 变为 &lt;code&gt;**/foo/bar&lt;/code&gt; ，它将与 &lt;code&gt;/any/path/to/foo/bar&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="cdf2b04ab13a298c669a989712845f14a413f23b" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; will be automatically added. For example, the pattern &lt;code&gt;foo/&lt;/code&gt; becomes &lt;code&gt;foo/**&lt;/code&gt;. In other words, it matches &quot;foo&quot; and everything inside, recursively.</source>
          <target state="translated">如果模式以 &lt;code&gt;/&lt;/code&gt; 结尾，则会自动添加 &lt;code&gt;**&lt;/code&gt; 。例如，模式 &lt;code&gt;foo/&lt;/code&gt; 变为 &lt;code&gt;foo/**&lt;/code&gt; 。换句话说，它递归地匹配&amp;ldquo; foo&amp;rdquo;和里面的所有东西。</target>
        </trans-unit>
        <trans-unit id="ead2b404e5878a53eb56a401706bd4f86f5cdd4b" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; will be automatically added. For example, the pattern &lt;code&gt;foo/&lt;/code&gt; becomes &lt;code&gt;foo/**&lt;/code&gt;. In other words, it matches all branches that begin with &lt;code&gt;foo/&lt;/code&gt;. This is useful if your branches are organized hierarchically and you would like to apply a configuration to all the branches in that hierarchy.</source>
          <target state="translated">如果模式以 &lt;code&gt;/&lt;/code&gt; 结尾，则会自动添加 &lt;code&gt;**&lt;/code&gt; 。例如，模式 &lt;code&gt;foo/&lt;/code&gt; 变为 &lt;code&gt;foo/**&lt;/code&gt; 。换句话说，它匹配以 &lt;code&gt;foo/&lt;/code&gt; 开头的所有分支。如果您的分支机构是按层次结构组织的，并且您希望将配置应用于该层次结构中的所有分支机构，则这将很有用。</target>
        </trans-unit>
        <trans-unit id="f1c8abd89592d50ca8ca62bbaec12c523f709263" translate="yes" xml:space="preserve">
          <source>If the pattern starts with &lt;code&gt;./&lt;/code&gt;, it is replaced with the directory containing the current config file.</source>
          <target state="translated">如果模式以 &lt;code&gt;./&lt;/code&gt; 开头，则将其替换为包含当前配置文件的目录。</target>
        </trans-unit>
        <trans-unit id="f924b2c312a1632ec51dd0f0353e6842160ab641" translate="yes" xml:space="preserve">
          <source>If the pattern starts with &lt;code&gt;~/&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; will be substituted with the content of the environment variable &lt;code&gt;HOME&lt;/code&gt;.</source>
          <target state="translated">如果模式以 &lt;code&gt;~/&lt;/code&gt; 开头，则 &lt;code&gt;~&lt;/code&gt; 将替换为环境变量 &lt;code&gt;HOME&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="25b5ae377df44f33ba840cf2411c6edf767c0d5b" translate="yes" xml:space="preserve">
          <source>If the pre-receive hook exits with a non-zero exit status no updates will be performed, and the update, post-receive and post-update hooks will not be invoked either. This can be useful to quickly bail out if the update is not to be supported.</source>
          <target state="translated">如果pre-receive钩子的退出状态为非零,则不会执行更新,更新、post-receive和post-update钩子也不会被调用。如果不支持更新,这对于快速保释是很有用的。</target>
        </trans-unit>
        <trans-unit id="0131da637807c8654fda6294e521f8e5e74d9c2b" translate="yes" xml:space="preserve">
          <source>If the problematic commit is the most recent commit, and you have not yet made that commit public, then you may just &lt;a href=&quot;#undoing-a-merge&quot;&gt;destroy it using &lt;code&gt;git reset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果有问题的提交是最新的提交，而您尚未将该提交公开，那么您可以&lt;a href=&quot;#undoing-a-merge&quot;&gt;使用 &lt;code&gt;git reset&lt;/code&gt; &lt;/a&gt;销毁它。</target>
        </trans-unit>
        <trans-unit id="1f275a1769b3300733689c93e8034126052b9dd7" translate="yes" xml:space="preserve">
          <source>If the project list is taken from a file (&lt;code&gt;$projects_list&lt;/code&gt; points to a file), forks are only recognized if they are listed after the main project in that file.</source>
          <target state="translated">如果项目列表是从文件中获取的（ &lt;code&gt;$projects_list&lt;/code&gt; 指向文件），则仅当分叉在该文件中的主项目之后列出时才被识别。</target>
        </trans-unit>
        <trans-unit id="cabde5708a0c59fc40ce3c5aef7bb8948c87aab4" translate="yes" xml:space="preserve">
          <source>If the reference repository is on the local machine, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to obtain objects from the reference repository. Using an already existing repository as an alternate will require fewer objects to be copied from the repository being cloned, reducing network and local storage costs. When using the &lt;code&gt;--reference-if-able&lt;/code&gt;, a non existing directory is skipped with a warning instead of aborting the clone.</source>
          <target state="translated">如果参考存储库位于本地计算机上，则自动设置 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; 从参考存储库获取对象。使用现有的存储库作为备用存储库将需要从要克隆的存储库中复制较少的对象，从而降低了网络和本地存储成本。使用 &lt;code&gt;--reference-if-able&lt;/code&gt; 时，将通过警告跳过不存在的目录，而不是中止克隆。</target>
        </trans-unit>
        <trans-unit id="5ea9c0fb462e839210565ca58d9885017561c1be" translate="yes" xml:space="preserve">
          <source>If the refspec is a globbing one, nothing is merged.</source>
          <target state="translated">如果refspec是一个globbing的,什么都不会被合并。</target>
        </trans-unit>
        <trans-unit id="67d81d9e5d98e20a38ce258501ea936cdaf3477e" translate="yes" xml:space="preserve">
          <source>If the remote has enabled the options &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt;, &lt;code&gt;uploadpack.allowReachableSHA1InWant&lt;/code&gt;, or &lt;code&gt;uploadpack.allowAnySHA1InWant&lt;/code&gt;, they may alternatively be 40-hex sha1s present on the remote.</source>
          <target state="translated">如果遥控器启用了选项 &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt; ， &lt;code&gt;uploadpack.allowReachableSHA1InWant&lt;/code&gt; 或 &lt;code&gt;uploadpack.allowAnySHA1InWant&lt;/code&gt; ，则它们可以是遥控器上存在的40进制sha1。</target>
        </trans-unit>
        <trans-unit id="43fe46812af3fc1b263ad2f17ddd0dcd8b849c57" translate="yes" xml:space="preserve">
          <source>If the remote is fetched successfully, add upstream (tracking) reference, used by argument-less &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; and other commands. For more information, see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b40a2dab8bd4f0c4875755d97441dd96a4edce1" translate="yes" xml:space="preserve">
          <source>If the remote is fetched successfully, pull and add upstream (tracking) reference, used by argument-less &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; and other commands. For more information, see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">如果成功获取了远程，请拉入并添加上游（跟踪）引用，该引用由无参数&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;和其他命令使用。有关详细信息，请参阅 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 和 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 在&lt;a href=&quot;git-config&quot;&gt;GIT-配置[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc0cb0804e07bed75e0e991fffdc9aae616f339a" translate="yes" xml:space="preserve">
          <source>If the remote side supports it, annotated tags objects will be downloaded on the same connection as the other objects if the object the tag references is downloaded. The caller must otherwise determine the tags this option made available.</source>
          <target state="translated">如果远端支持,如果标签引用的对象被下载,则注释的标签对象将与其他对象在同一连接上下载。调用者必须以其他方式确定这个选项所提供的标签。</target>
        </trans-unit>
        <trans-unit id="b72444ac7244fe67691159600db782df37b1532c" translate="yes" xml:space="preserve">
          <source>If the repository is bare, &lt;code&gt;--no-checkout&lt;/code&gt; is assumed.</source>
          <target state="translated">如果存储库是 &lt;code&gt;--no-checkout&lt;/code&gt; 则假定--no-checkout。</target>
        </trans-unit>
        <trans-unit id="36e50561f165c018ae6f119c2c6f3e5164508f60" translate="yes" xml:space="preserve">
          <source>If the repository is specified as a local path (e.g., &lt;code&gt;/path/to/repo&lt;/code&gt;), this is the default, and --local is essentially a no-op. If the repository is specified as a URL, then this flag is ignored (and we never use the local optimizations). Specifying &lt;code&gt;--no-local&lt;/code&gt; will override the default when &lt;code&gt;/path/to/repo&lt;/code&gt; is given, using the regular Git transport instead.</source>
          <target state="translated">如果将存储库指定为本地路径（例如 &lt;code&gt;/path/to/repo&lt;/code&gt; ），则这是默认设置，而--local本质上是no-op。如果将存储库指定为URL，则将忽略此标志（并且我们永远不会使用本地优化）。当给出 &lt;code&gt;/path/to/repo&lt;/code&gt; 时，指定 &lt;code&gt;--no-local&lt;/code&gt; 将覆盖默认值，而改用常规Git传输。</target>
        </trans-unit>
        <trans-unit id="9c19da211c253af2b7a5a65c4c24c5e8a4f73309" translate="yes" xml:space="preserve">
          <source>If the result content is empty then the filter is expected to respond with a &quot;success&quot; status and a flush packet to signal the empty content.</source>
          <target state="translated">如果结果内容是空的,那么过滤器要响应一个 &quot;成功 &quot;状态和一个刷新数据包来提示空内容。</target>
        </trans-unit>
        <trans-unit id="87bdb08d6c6927271153931ec7c3dbb32bf0435b" translate="yes" xml:space="preserve">
          <source>If the server has found a suitable cut point and has decided to send a &quot;ready&quot; line, then the server can decide to (as an optimization) omit any &quot;ACK&quot; lines it would have sent during its response. This is because the server will have already determined the objects it plans to send to the client and no further negotiation is needed.</source>
          <target state="translated">如果服务器找到了一个合适的切入点,并决定发送一个 &quot;准备好了 &quot;的行,那么服务器可以决定(作为一种优化)省略它在响应过程中本来要发送的任何 &quot;ACK &quot;行。这是因为服务器将已经确定了它计划向客户端发送的对象,不需要再进行协商。</target>
        </trans-unit>
        <trans-unit id="b994a26dfc45bfc84fb73ef67436c3f647661961" translate="yes" xml:space="preserve">
          <source>If the size of the incoming pack stream is larger than this limit, then git-receive-pack will error out, instead of accepting the pack file. If not set or set to 0, then the size is unlimited.</source>
          <target state="translated">如果传入的包流的大小大于这个限制,那么git-receive-pack会出错,而不是接受包文件。如果没有设置或者设置为0,那么大小是无限的。</target>
        </trans-unit>
        <trans-unit id="ff78750ae83975fe12661694a886f60b06a8fa31" translate="yes" xml:space="preserve">
          <source>If the source material uses RFC 2822 style dates, the frontend should let fast-import handle the parsing and conversion (rather than attempting to do it itself) as the Git parser has been well tested in the wild.</source>
          <target state="translated">如果源材料使用RFC 2822风格的日期,前端应该让fast-import来处理解析和转换(而不是尝试自己来做),因为Git解析器已经在野外进行了很好的测试。</target>
        </trans-unit>
        <trans-unit id="3c8cd70e721e8a0b9cd7092e81bbbfc31a3bd8bd" translate="yes" xml:space="preserve">
          <source>If the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories.</source>
          <target state="translated">如果源存储库是完整的,则将浅层存储库转换为完整的存储库,消除浅层存储库带来的所有限制。</target>
        </trans-unit>
        <trans-unit id="9e6d3a4e3136a4838fe6f50fd9653c6cb56b6d6c" translate="yes" xml:space="preserve">
          <source>If the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository.</source>
          <target state="translated">如果源库较浅,则尽可能多地获取,使当前库与源库具有相同的历史。</target>
        </trans-unit>
        <trans-unit id="de8398976a760845a7849338955a9624333ab515" translate="yes" xml:space="preserve">
          <source>If the starting point is specified as &lt;code&gt;ref@{Nth}&lt;/code&gt;, show the index format.</source>
          <target state="translated">如果起点指定为 &lt;code&gt;ref@{Nth}&lt;/code&gt; ，则显示索引格式。</target>
        </trans-unit>
        <trans-unit id="6a2386c7d64f544644194a06f1f15e00500df35a" translate="yes" xml:space="preserve">
          <source>If the starting point was specified as &lt;code&gt;ref@{now}&lt;/code&gt;, show the timestamp format.</source>
          <target state="translated">如果起点指定为 &lt;code&gt;ref@{now}&lt;/code&gt; ，则显示时间戳记格式。</target>
        </trans-unit>
        <trans-unit id="a401b7c4a3b36e61e5b713fb185191570664ec06" translate="yes" xml:space="preserve">
          <source>If the submodule has never been initialized, this is the only place where submodule configuration is found. It serves as the last fallback to specify where to obtain the submodule from.</source>
          <target state="translated">如果子模块从来没有被初始化过,这是唯一能找到子模块配置的地方。它作为最后的后备,指定从哪里获得子模块。</target>
        </trans-unit>
        <trans-unit id="c93d30e9eb4c6197dacc1ad5f6b79e20616e783c" translate="yes" xml:space="preserve">
          <source>If the submodule is not yet initialized, and you just want to use the setting as stored in &lt;code&gt;.gitmodules&lt;/code&gt;, you can automatically initialize the submodule with the &lt;code&gt;--init&lt;/code&gt; option.</source>
          <target state="translated">如果子模块尚未初始化，而您只想使用 &lt;code&gt;.gitmodules&lt;/code&gt; 中存储的设置，则可以使用 &lt;code&gt;--init&lt;/code&gt; 选项自动初始化子模块。</target>
        </trans-unit>
        <trans-unit id="02845d91bbeb482c77721be199fb493e9af0747b" translate="yes" xml:space="preserve">
          <source>If the submodule is not yet initialized, then the configuration inside the submodule does not exist yet, so where to obtain the submodule from is configured here for example.</source>
          <target state="translated">如果子模块还没有初始化,那么子模块里面的配置就还不存在,所以从哪里获取子模块就在这里配置,比如。</target>
        </trans-unit>
        <trans-unit id="ae19e2f586d76eb404950c906a0e28fc48bd4144" translate="yes" xml:space="preserve">
          <source>If the target branch in refs/remotes/p4-unshelved already exists, the old one will be renamed.</source>
          <target state="translated">如果 refs/remotes/p4-unshelved 中的目标分支已经存在,旧的分支将被重新命名。</target>
        </trans-unit>
        <trans-unit id="2f7883dbe6de00b83ac31c035cb47ace7f18b215" translate="yes" xml:space="preserve">
          <source>If the timestamp order of different files cross the revision order within the commit matching time window the order of commits may be wrong.</source>
          <target state="translated">如果在提交匹配时间窗口内,不同文件的时间戳顺序与修订顺序交叉,则提交顺序可能会出错。</target>
        </trans-unit>
        <trans-unit id="9e02bc5f839968fa2bd55c9715c548322d410f70" translate="yes" xml:space="preserve">
          <source>If the update is done via merge, the submodule conflicts are resolved and checked out.</source>
          <target state="translated">如果通过合并的方式进行更新,则解决了子模块的冲突,并检查出来。</target>
        </trans-unit>
        <trans-unit id="e429444552f2f76afd93b7eab781098fd53d76ab" translate="yes" xml:space="preserve">
          <source>If the upstream branch already contains a change you have made (e.g., because you mailed a patch which was applied upstream), then that commit will be skipped. For example, running &lt;code&gt;git rebase master&lt;/code&gt; on the following history (in which &lt;code&gt;A'&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; introduce the same set of changes, but have different committer information):</source>
          <target state="translated">如果上游分支已经包含您所做的更改（例如，因为您邮寄了在上游应用的补丁程序），则将跳过该提交。例如，根据以下历史记录运行 &lt;code&gt;git rebase master&lt;/code&gt; （其中 &lt;code&gt;A'&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 引入了相同的更改集，但是提交者信息不同）：</target>
        </trans-unit>
        <trans-unit id="8dd2ebfbc7db6f2a970a9204f7e4fecacb05b440" translate="yes" xml:space="preserve">
          <source>If the user is driving it, then at each step of the search, the user will have to test the current commit and say if it is &quot;good&quot; or &quot;bad&quot; using the &quot;git bisect good&quot; or &quot;git bisect bad&quot; commands respectively that have been described above. For example:</source>
          <target state="translated">如果是由用户来驱动,那么在搜索的每一步,用户都要分别用上面介绍过的 &quot;git一分为二好 &quot;或 &quot;git一分为二坏 &quot;命令来测试当前的提交,并说出是 &quot;好 &quot;还是 &quot;坏&quot;。例如:&quot;git bisect good &quot;命令</target>
        </trans-unit>
        <trans-unit id="6929af54c2109d01f0c27eda6b64b41906b00393" translate="yes" xml:space="preserve">
          <source>If the user provides a --tag-name-filter that maps multiple tags to the same name, no warning or error is provided; git-filter-branch simply overwrites each tag in some undocumented pre-defined order resulting in only one tag at the end. (A git-filter-branch regression test requires this surprising behavior.)</source>
          <target state="translated">如果用户提供了一个 --tag-name-filter,将多个标签映射到相同的名称上,那么不会提供任何警告或错误;git-filter-branch 只是简单地以某种未记录的预定义顺序覆盖每个标签,导致最后只有一个标签。(git-filter-branch的回归测试需要这种令人惊讶的行为。)</target>
        </trans-unit>
        <trans-unit id="115afcefe8deea6713a6376b9b3612622ce5ff41" translate="yes" xml:space="preserve">
          <source>If the user running &lt;code&gt;git p4 submit&lt;/code&gt; does not exist in the p4 user map, &lt;code&gt;git p4&lt;/code&gt; exits. This option can be used to force submission regardless.</source>
          <target state="translated">如果运行 &lt;code&gt;git p4 submit&lt;/code&gt; Submit的用户在p4用户映射中不存在，则 &lt;code&gt;git p4&lt;/code&gt; 退出。无论如何，都可以使用此选项强制提交。</target>
        </trans-unit>
        <trans-unit id="4ce7fbc3c51757d8b6052ea0a42e4807120e305f" translate="yes" xml:space="preserve">
          <source>If the value is boolean, turns on or off pagination of the output of a particular Git subcommand when writing to a tty. Otherwise, turns on pagination for the subcommand using the pager specified by the value of &lt;code&gt;pager.&amp;lt;cmd&amp;gt;&lt;/code&gt;. If &lt;code&gt;--paginate&lt;/code&gt; or &lt;code&gt;--no-pager&lt;/code&gt; is specified on the command line, it takes precedence over this option. To disable pagination for all commands, set &lt;code&gt;core.pager&lt;/code&gt; or &lt;code&gt;GIT_PAGER&lt;/code&gt; to &lt;code&gt;cat&lt;/code&gt;.</source>
          <target state="translated">如果值为boolean，则在写入tty时打开或关闭特定Git子命令输出的分页。否则，请使用 &lt;code&gt;pager.&amp;lt;cmd&amp;gt;&lt;/code&gt; 的值指定的寻呼机为子命令打开分页。如果在命令行上指定了 &lt;code&gt;--paginate&lt;/code&gt; 或 &lt;code&gt;--no-pager&lt;/code&gt; ，它将优先于此选项。要禁用所有命令的分页，请将 &lt;code&gt;core.pager&lt;/code&gt; 或 &lt;code&gt;GIT_PAGER&lt;/code&gt; 设置为 &lt;code&gt;cat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d03e93ea222dab8f641cb8201b06b8ce56eb4397" translate="yes" xml:space="preserve">
          <source>If the variable is set to an integer value greater than 2 and lower than 10 (strictly) then Git will interpret this value as an open file descriptor and will try to write the trace messages into this file descriptor.</source>
          <target state="translated">如果将这个变量设置为大于2而小于10的整数值(严格来说),那么Git将把这个值解释为一个打开的文件描述符,并会尝试将跟踪信息写入这个文件描述符中。</target>
        </trans-unit>
        <trans-unit id="68e78b3aa184c7970e4ea72bcfa1c35c1841182d" translate="yes" xml:space="preserve">
          <source>If there are a large number of similarly-named remote repositories and you want to use a different format for them (such that the URLs you use will be rewritten into URLs that work), you can create a configuration section of the form:</source>
          <target state="translated">如果有大量类似名称的远程仓库,而你想对它们使用不同的格式(这样你使用的URL将被重写成可以使用的URL),你可以创建一个表格的配置部分。</target>
        </trans-unit>
        <trans-unit id="1add756b76a7c17e78b77f722a60e35881bd1c18" translate="yes" xml:space="preserve">
          <source>If there are conflicts, the user should edit the result and delete one of the alternatives. When &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, or &lt;code&gt;--union&lt;/code&gt; option is in effect, however, these conflicts are resolved favouring lines from &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt;, lines from &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt;, or lines from both respectively. The length of the conflict markers can be given with the &lt;code&gt;--marker-size&lt;/code&gt; option.</source>
          <target state="translated">如果存在冲突，则用户应编辑结果并删除替代方法之一。 &lt;code&gt;--ours&lt;/code&gt; ，当--ours，-- &lt;code&gt;--theirs&lt;/code&gt; 或 &lt;code&gt;--union&lt;/code&gt; 选项生效时，这些冲突可以通过 &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt; 中的行， &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt; 中的行或这两者来解决。冲突标记的长度可以使用 &lt;code&gt;--marker-size&lt;/code&gt; 选项指定。</target>
        </trans-unit>
        <trans-unit id="86762a48683c371a4cc7c3de1cb012419562ae87" translate="yes" xml:space="preserve">
          <source>If there are multiple branches, doing &lt;code&gt;git p4 sync&lt;/code&gt; will automatically use the &quot;BRANCH DETECTION&quot; algorithm to try to partition new changes into the right branch. This can be overridden with the &lt;code&gt;--branch&lt;/code&gt; option to specify just a single branch to update.</source>
          <target state="translated">如果有多个分支，则执行 &lt;code&gt;git p4 sync&lt;/code&gt; 将自动使用&amp;ldquo; BRANCH DETECTION&amp;rdquo;算法尝试将新更改划分到正确的分支中。可以使用 &lt;code&gt;--branch&lt;/code&gt; 选项将其覆盖，以仅指定一个要更新的分支。</target>
        </trans-unit>
        <trans-unit id="618accc0d1d550b6b8ec069f55b5b09af649e985" translate="yes" xml:space="preserve">
          <source>If there are multiple instances of the &lt;code&gt;credential.helper&lt;/code&gt; configuration variable, each helper will be tried in turn, and may provide a username, password, or nothing. Once Git has acquired both a username and a password, no more helpers will be tried.</source>
          <target state="translated">如果存在 &lt;code&gt;credential.helper&lt;/code&gt; 配置变量的多个实例，则将依次尝试每个帮助程序，并且可能不提供用户名，密码或什么都不提供。一旦Git同时获得了用户名和密码，就不会再尝试其他帮助程序了。</target>
        </trans-unit>
        <trans-unit id="af9d46d5bd3ac828de63ddb9d4effe59327aaa5a" translate="yes" xml:space="preserve">
          <source>If there are other repositories that you also use frequently, you can create similar configuration options to save typing; for example,</source>
          <target state="translated">如果有其他你也经常使用的资源库,你可以创建类似的配置选项,以节省打字;例如。</target>
        </trans-unit>
        <trans-unit id="591918eb06b2723ac86bd0a089445e6e294cf8c5" translate="yes" xml:space="preserve">
          <source>If there exist packfiles in the pack directory not registered in the MIDX, then those packfiles are loaded into the &lt;code&gt;packed_git&lt;/code&gt; list and &lt;code&gt;packed_git_mru&lt;/code&gt; cache.</source>
          <target state="translated">如果在pack目录中存在未在MIDX中注册的packfile，则这些packfile将被加载到 &lt;code&gt;packed_git&lt;/code&gt; 列表和 &lt;code&gt;packed_git_mru&lt;/code&gt; 缓存中。</target>
        </trans-unit>
        <trans-unit id="03e18f44da1b610f354ea9baeb478307ccf925f8" translate="yes" xml:space="preserve">
          <source>If there is a separator at the beginning or middle (or both) of the pattern, then the pattern is relative to the directory level of the particular &lt;code&gt;.gitignore&lt;/code&gt; file itself. Otherwise the pattern may also match at any level below the &lt;code&gt;.gitignore&lt;/code&gt; level.</source>
          <target state="translated">如果在模式的开头或中间（或两者）都存在分隔符，则该模式是相对于特定 &lt;code&gt;.gitignore&lt;/code&gt; 文件本身的目录级别的。否则，模式也可能在 &lt;code&gt;.gitignore&lt;/code&gt; 级别以下的任何级别匹配。</target>
        </trans-unit>
        <trans-unit id="73c5dbd4863767291eb0584c1211aa56213f1838" translate="yes" xml:space="preserve">
          <source>If there is a separator at the end of the pattern then the pattern will only match directories, otherwise the pattern can match both files and directories.</source>
          <target state="translated">如果模式末尾有分隔符,那么该模式将只匹配目录,否则该模式可以同时匹配文件和目录。</target>
        </trans-unit>
        <trans-unit id="7e5e3b6d9186f0b0d9ca9ea83f70b7fee637fea2" translate="yes" xml:space="preserve">
          <source>If there is a separator, then the key will be used instead of both the &amp;lt;token&amp;gt; and the default separator when adding the trailer.</source>
          <target state="translated">如果有分隔符，则在添加预告片时将使用键代替&amp;lt;token&amp;gt;和默认分隔符。</target>
        </trans-unit>
        <trans-unit id="110096af5aaaf08aca8aad30cdfe6c3abec7eaf2" translate="yes" xml:space="preserve">
          <source>If there is no file or subtree at that path, &lt;code&gt;git fast-import&lt;/code&gt; will instead report</source>
          <target state="translated">如果在该路径下没有文件或子树，则 &lt;code&gt;git fast-import&lt;/code&gt; 会报告</target>
        </trans-unit>
        <trans-unit id="1db0218c6ea3cc08d2d45a6158a3df08d714812b" translate="yes" xml:space="preserve">
          <source>If there is no parameter given by the user, use &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果用户未提供任何参数，请改用 &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08079a827cded7daddc3f36e473048d3482101ec" translate="yes" xml:space="preserve">
          <source>If there is only one &amp;lt;tree-ish&amp;gt; given, the commit is compared with its parents (see --stdin below).</source>
          <target state="translated">如果仅给出一个&amp;lt;tree-ish&amp;gt;，则将该提交与其父级进行比较（请参见下面的--stdin）。</target>
        </trans-unit>
        <trans-unit id="f3b2c7580e6489ea5e91cbe02a9f524e00ba7a5a" translate="yes" xml:space="preserve">
          <source>If there were more commits on the &lt;em&gt;master&lt;/em&gt; branch after the merge, the merge commit itself would not be shown by &lt;em&gt;git show-branch&lt;/em&gt; by default. You would need to provide &lt;code&gt;--sparse&lt;/code&gt; option to make the merge commit visible in this case.</source>
          <target state="translated">如果合并后&lt;em&gt;master&lt;/em&gt;分支上有更多提交，默认情况下&lt;em&gt;git show-branch&lt;/em&gt;不会显示合并提交本身。在这种情况下，您需要提供 &lt;code&gt;--sparse&lt;/code&gt; 选项以使合并提交可见。</target>
        </trans-unit>
        <trans-unit id="0ab64f384f8b476963c3f64ac176ef68ee6de9f2" translate="yes" xml:space="preserve">
          <source>If there were uncommitted worktree changes present when the merge started, &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to reconstruct these changes. It is therefore recommended to always commit or stash your changes before running &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">如果合并开始时存在未提交的工作树更改，则 &lt;code&gt;git merge --abort&lt;/code&gt; 在某些情况下将无法重构这些更改。因此，建议始终在运行 &lt;code&gt;git merge&lt;/code&gt; 之前提交或存储更改。</target>
        </trans-unit>
        <trans-unit id="967d5740c3c32e83504fdb7318f7465d81e3c6cb" translate="yes" xml:space="preserve">
          <source>If this atom is used in the output string, input lines are split at the first whitespace boundary. All characters before that whitespace are considered to be the object name; characters after that first run of whitespace (i.e., the &quot;rest&quot; of the line) are output in place of the &lt;code&gt;%(rest)&lt;/code&gt; atom.</source>
          <target state="translated">如果在输出字符串中使用此原子，则输入行将在第一个空白边界处拆分。空白之前的所有字符均被视为对象名称；在第一个空白行之后的字符（即行的&amp;ldquo;其余&amp;rdquo;）将代替 &lt;code&gt;%(rest)&lt;/code&gt; 原子输出。</target>
        </trans-unit>
        <trans-unit id="4b6208e01f164e5f8b5cfeffb592a9b059f78c4e" translate="yes" xml:space="preserve">
          <source>If this attribute is not set or has an invalid value, the value of the &lt;code&gt;gui.encoding&lt;/code&gt; configuration variable is used instead (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">如果此属性未设置或具有无效值，则 &lt;code&gt;gui.encoding&lt;/code&gt; 配置变量的值（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d21856ae35021bd75d04c1b344656e77c3e714d8" translate="yes" xml:space="preserve">
          <source>If this config variable is set, diff generation is not performed using the internal diff machinery, but using the given command. Can be overridden with the &amp;lsquo;GIT_EXTERNAL_DIFF&amp;rsquo; environment variable. The command is called with parameters as described under &quot;git Diffs&quot; in &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;. Note: if you want to use an external diff program only on a subset of your files, you might want to use &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; instead.</source>
          <target state="translated">如果设置了此配置变量，则不使用内部差异机制来执行差异生成，而是使用给定命令。可以用'GIT_EXTERNAL_DIFF'环境变量覆盖。使用&lt;a href=&quot;git&quot;&gt;git [1]中&lt;/a&gt; &amp;ldquo; git Diffs&amp;rdquo;下描述的参数调用该命令。注意：如果只想在文件的子集上使用外部diff程序，则可能要改用&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c67dbd9b5b9d0c250d594cf0e82ea55d38dac133" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to &quot;1&quot;, then commands such as &lt;code&gt;git blame&lt;/code&gt; (in incremental mode), &lt;code&gt;git rev-list&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt;, &lt;code&gt;git check-attr&lt;/code&gt; and &lt;code&gt;git check-ignore&lt;/code&gt; will force a flush of the output stream after each record have been flushed. If this variable is set to &quot;0&quot;, the output of these commands will be done using completely buffered I/O. If this environment variable is not set, Git will choose buffered or record-oriented flushing based on whether stdout appears to be redirected to a file or not.</source>
          <target state="translated">如果此环境变量设置为&amp;ldquo; 1&amp;rdquo;，则诸如 &lt;code&gt;git blame&lt;/code&gt; （增量模式）， &lt;code&gt;git rev-list&lt;/code&gt; ， &lt;code&gt;git log&lt;/code&gt; ， &lt;code&gt;git check-attr&lt;/code&gt; 和 &lt;code&gt;git check-ignore&lt;/code&gt; 之类的命令将在每次执行后强制刷新输出流记录已被刷新。如果将此变量设置为&amp;ldquo; 0&amp;rdquo;，则将使用完全缓冲的I / O完成这些命令的输出。如果未设置此环境变量，则Git将根据stdout是否似乎重定向到文件来选择缓冲刷新或面向记录的刷新。</target>
        </trans-unit>
        <trans-unit id="3c510f35b5c52541d7f8ff48371ed312cadc959c" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to &lt;code&gt;0&lt;/code&gt;, git will not prompt on the terminal (e.g., when asking for HTTP authentication).</source>
          <target state="translated">如果此环境变量设置为 &lt;code&gt;0&lt;/code&gt; ，则git不会在终端上提示（例如，在请求HTTP身份验证时）。</target>
        </trans-unit>
        <trans-unit id="f0e0816f1f387058c1f2d75f7ff32a01f9295472" translate="yes" xml:space="preserve">
          <source>If this environment variable is set, it overrides Git&amp;rsquo;s autodetection whether &lt;code&gt;GIT_SSH&lt;/code&gt;/&lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt;/&lt;code&gt;core.sshCommand&lt;/code&gt; refer to OpenSSH, plink or tortoiseplink. This variable overrides the config setting &lt;code&gt;ssh.variant&lt;/code&gt; that serves the same purpose.</source>
          <target state="translated">如果设置了此环境变量，则无论 &lt;code&gt;GIT_SSH&lt;/code&gt; / &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; / &lt;code&gt;core.sshCommand&lt;/code&gt; 引用OpenSSH，plink还是tortoiseplink ，它都会覆盖Git的自动检测。此变量将覆盖具有相同目的的配置设置 &lt;code&gt;ssh.variant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81f782a4dbe0e346a4da365c1a6b3a9cbeb4a6e2" translate="yes" xml:space="preserve">
          <source>If this environment variable is set, then Git commands which need to acquire passwords or passphrases (e.g. for HTTP or IMAP authentication) will call this program with a suitable prompt as command-line argument and read the password from its STDOUT. See also the &lt;code&gt;core.askPass&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">如果设置了此环境变量，则需要获取密码或密码短语的Git命令（例如，用于HTTP或IMAP身份验证）将使用适当的提示符作为命令行参数来调用该程序，并从其STDOUT中读取密码。另请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]中&lt;/a&gt;的 &lt;code&gt;core.askPass&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="372352ecb2d8c55afffa99890c0eb497f2b1382d" translate="yes" xml:space="preserve">
          <source>If this feature is enabled, gitweb considers projects in subdirectories of project root (basename) to be forks of existing projects. For each project &lt;code&gt;$projname.git&lt;/code&gt;, projects in the &lt;code&gt;$projname/&lt;/code&gt; directory and its subdirectories will not be shown in the main projects list. Instead, a '+' mark is shown next to &lt;code&gt;$projname&lt;/code&gt;, which links to a &quot;forks&quot; view that lists all the forks (all projects in &lt;code&gt;$projname/&lt;/code&gt; subdirectory). Additionally a &quot;forks&quot; view for a project is linked from project summary page.</source>
          <target state="translated">如果启用了此功能，则gitweb会将项目根目录（基本名称）的子目录中的项目视为现有项目的分支。对于每个项目 &lt;code&gt;$projname.git&lt;/code&gt; ， &lt;code&gt;$projname/&lt;/code&gt; 目录及其子目录中的项目将不会显示在主项目列表中。而是在 &lt;code&gt;$projname&lt;/code&gt; 旁边显示一个'+'标记，该标记链接到列出所有分叉（ &lt;code&gt;$projname/&lt;/code&gt; 子目录中的所有项目）的&amp;ldquo; forks&amp;rdquo;视图。另外，从项目摘要页面链接了项目的&amp;ldquo;分叉&amp;rdquo;视图。</target>
        </trans-unit>
        <trans-unit id="728d51c620f0870eff1b0d62261ab6934369adf2" translate="yes" xml:space="preserve">
          <source>If this field has a true value then the given feature is overridable, which means that it can be configured (or enabled/disabled) on a per-repository basis.</source>
          <target state="translated">如果该字段的值为真,那么给定的功能是可覆盖的,这意味着它可以在每个存储库的基础上进行配置(或启用/禁用)。</target>
        </trans-unit>
        <trans-unit id="582826e66f53339e6d7b4dc6a0d6a2edeb312487" translate="yes" xml:space="preserve">
          <source>If this file exists, $GIT_COMMON_DIR (see &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;) will be set to the path specified in this file if it is not explicitly set. If the specified path is relative, it is relative to $GIT_DIR. The repository with commondir is incomplete without the repository pointed by &quot;commondir&quot;.</source>
          <target state="translated">如果此文件存在，则$ GIT_COMMON_DIR（请参见&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;）将设置为该文件中指定的路径（如果未明确设置）。如果指定的路径是相对的，则相对于$ GIT_DIR。没有&amp;ldquo; commondir&amp;rdquo;指向的存储库，具有commondir的存储库是不完整的。</target>
        </trans-unit>
        <trans-unit id="1e44552a87aaa0e818702548719ba07ebc0f8696" translate="yes" xml:space="preserve">
          <source>If this file exists, the linked working tree may be on a portable device and not available. The presence of this file prevents &lt;code&gt;worktrees/&amp;lt;id&amp;gt;&lt;/code&gt; from being pruned either automatically or manually by &lt;code&gt;git worktree prune&lt;/code&gt;. The file may contain a string explaining why the repository is locked.</source>
          <target state="translated">如果此文件存在，则链接的工作树可能在便携式设备上并且不可用。此文件的存在可防止 &lt;code&gt;git worktree prune&lt;/code&gt; 自动或手动修剪工作 &lt;code&gt;worktrees/&amp;lt;id&amp;gt;&lt;/code&gt; 。该文件可能包含解释存储库为何被锁定的字符串。</target>
        </trans-unit>
        <trans-unit id="6849302064fdf0db00fe326dd1a92636c39a6d43" translate="yes" xml:space="preserve">
          <source>If this hook exits with a non-zero status, &lt;code&gt;git push&lt;/code&gt; will abort without pushing anything. Information about why the push is rejected may be sent to the user by writing to standard error.</source>
          <target state="translated">如果该钩子以非零状态退出，则 &lt;code&gt;git push&lt;/code&gt; 将中止而不推送任何内容。关于为什么拒绝推送的信息可以通过写入标准错误来发送给用户。</target>
        </trans-unit>
        <trans-unit id="9e422a5c19027398b3db2e62a2dfa8c2a2031ac5" translate="yes" xml:space="preserve">
          <source>If this is reinitialization, the repository will be moved to the specified path.</source>
          <target state="translated">如果是重新初始化,版本库将被移动到指定的路径。</target>
        </trans-unit>
        <trans-unit id="ae49e42c53a829e13a69befb7e448cbf7a3ab5aa" translate="yes" xml:space="preserve">
          <source>If this is set to code reference, it will be run once for each request. You can set parts of configuration that change per session this way. For example, one might use the following code in a gitweb configuration file</source>
          <target state="translated">如果将其设置为代码引用,则每次请求都会运行一次。你可以通过这种方式设置每次会话改变的配置部分。例如,我们可以在gitweb配置文件中使用以下代码</target>
        </trans-unit>
        <trans-unit id="2ecaf4f8ea5745cd5a451b94ab44dd28ff120dab" translate="yes" xml:space="preserve">
          <source>If this is set to true, the &lt;code&gt;git stash show&lt;/code&gt; command without an option will show diffstat of the stash entry. Defaults to true. See description of &lt;code&gt;show&lt;/code&gt; command in &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">如果将其设置为true，则不带选项的 &lt;code&gt;git stash show&lt;/code&gt; 命令将显示stash条目的diffstat。默认为true。参见&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;中 &lt;code&gt;show&lt;/code&gt; 命令的描述。</target>
        </trans-unit>
        <trans-unit id="ee4998fa7e703962f55f3297f84fc3b952ae4a7f" translate="yes" xml:space="preserve">
          <source>If this is set to true, the &lt;code&gt;git stash show&lt;/code&gt; command without an option will show the stash entry in patch form. Defaults to false. See description of &lt;code&gt;show&lt;/code&gt; command in &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">如果将其设置为true，则不带选项的 &lt;code&gt;git stash show&lt;/code&gt; 命令将以补丁程序形式显示stash条目。默认为false。参见&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;中 &lt;code&gt;show&lt;/code&gt; 命令的描述。</target>
        </trans-unit>
        <trans-unit id="7e98f4c395c1b49b1de4c0111925dea856a6d079" translate="yes" xml:space="preserve">
          <source>If this is set, add emails found in Signed-off-by: or Cc: lines to the cc list. Default is the value of &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; configuration value; if that is unspecified, default to --signed-off-by-cc.</source>
          <target state="translated">如果已设置，则将在&amp;ldquo;签名人：&amp;rdquo;或&amp;ldquo;抄送：&amp;rdquo;行中找到的电子邮件添加到抄送列表。默认值为 &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; 的配置值；如果未指定，则默认为--signed-off-by-cc。</target>
        </trans-unit>
        <trans-unit id="6cf7f20765eaeb225b14832d24072d63179e161f" translate="yes" xml:space="preserve">
          <source>If this is set, do not add the From: address to the cc: list. Default is the value of &lt;code&gt;sendemail.suppressFrom&lt;/code&gt; configuration value; if that is unspecified, default to --no-suppress-from.</source>
          <target state="translated">如果已设置，则不要将&amp;ldquo;发件人：&amp;rdquo;地址添加到&amp;ldquo;抄送：&amp;rdquo;列表中。默认值为 &lt;code&gt;sendemail.suppressFrom&lt;/code&gt; 配置值；如果未指定，则默认为--no-suppress-from。</target>
        </trans-unit>
        <trans-unit id="048d4528d0951754849879e2b4b5802f6461c9fb" translate="yes" xml:space="preserve">
          <source>If this is set, each email will be sent as a reply to the previous email sent. If disabled with &quot;--no-chain-reply-to&quot;, all emails after the first will be sent as replies to the first email sent. When using this, it is recommended that the first file given be an overview of the entire patch series. Disabled by default, but the &lt;code&gt;sendemail.chainReplyTo&lt;/code&gt; configuration variable can be used to enable it.</source>
          <target state="translated">如果设置了此选项，则将发送每封电子邮件作为对先前发送的电子邮件的答复。如果通过&amp;ldquo; --no-chain-reply-to&amp;rdquo;禁用，则第一个电子邮件之后的所有电子邮件将作为对第一个电子邮件的答复发送。使用此功能时，建议给定的第一个文件是整个补丁系列的概述。默认情况下处于禁用状态，但是 &lt;code&gt;sendemail.chainReplyTo&lt;/code&gt; 配置变量可用于启用它。</target>
        </trans-unit>
        <trans-unit id="b4073ff276c4f44294d676470e6aaaeb5a46458f" translate="yes" xml:space="preserve">
          <source>If this is set, emails found in Cc: headers in the first patch of the series (typically the cover letter) are added to the cc list for each email set. Default is the value of &lt;code&gt;sendemail.cccover&lt;/code&gt; configuration value; if that is unspecified, default to --no-cc-cover.</source>
          <target state="translated">如果设置了此选项，则将在该系列的第一个补丁程序的&amp;ldquo;抄送::&amp;rdquo;标题中找到的电子邮件（通常为求职信）添加到每个电子邮件集的抄送列表中。默认值为 &lt;code&gt;sendemail.cccover&lt;/code&gt; 的配置值；如果未指定，则默认为--no-cc-cover。</target>
        </trans-unit>
        <trans-unit id="c3505cfc9a16fb3a406321b32681f1c27b3f4828" translate="yes" xml:space="preserve">
          <source>If this is set, emails found in To: headers in the first patch of the series (typically the cover letter) are added to the to list for each email set. Default is the value of &lt;code&gt;sendemail.tocover&lt;/code&gt; configuration value; if that is unspecified, default to --no-to-cover.</source>
          <target state="translated">如果设置了此选项，则将在该系列的第一个补丁程序的&amp;ldquo;收件人：&amp;rdquo;标题中找到的电子邮件（通常为求职信）添加到每个电子邮件集的&amp;ldquo;收件人&amp;rdquo;列表中。默认值为 &lt;code&gt;sendemail.tocover&lt;/code&gt; 配置值；如果未指定，则默认为--no-to-cover。</target>
        </trans-unit>
        <trans-unit id="bd074611e2ce23fe3651c7c21615bc5d5c90b653" translate="yes" xml:space="preserve">
          <source>If this is set, the In-Reply-To and References headers will be added to each email sent. Whether each mail refers to the previous email (&lt;code&gt;deep&lt;/code&gt; threading per &lt;code&gt;git format-patch&lt;/code&gt; wording) or to the first email (&lt;code&gt;shallow&lt;/code&gt; threading) is governed by &quot;--[no-]chain-reply-to&quot;.</source>
          <target state="translated">如果设置了此选项，则&amp;ldquo;回复至&amp;rdquo;和&amp;ldquo;引用&amp;rdquo;标题将被添加到每个发送的电子邮件中。无论每个邮件是指以前的电子邮件（ &lt;code&gt;deep&lt;/code&gt; 每线程 &lt;code&gt;git format-patch&lt;/code&gt; 措辞），或第一封邮件（ &lt;code&gt;shallow&lt;/code&gt; 线程）被管辖&amp;ldquo; - [无糖]链回复&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="83fefd231faf2237df4d2ca57ddb91f5733dd174" translate="yes" xml:space="preserve">
          <source>If this option is also present in the submodules entry in .git/config of the superproject, the setting there will override the one found in .gitmodules.</source>
          <target state="translated">如果这个选项也存在于超级项目的.git/config中的子模块条目中,那里的设置将覆盖.gitmodules中的设置。</target>
        </trans-unit>
        <trans-unit id="b576cec09f399abde10801d9e3b482a3974a7942" translate="yes" xml:space="preserve">
          <source>If this option is set, &lt;code&gt;upload-pack&lt;/code&gt; will support partial clone and partial fetch object filtering.</source>
          <target state="translated">如果设置此选项，则 &lt;code&gt;upload-pack&lt;/code&gt; 将支持部分克隆和部分提取对象过滤。</target>
        </trans-unit>
        <trans-unit id="46df2747ed059ec465747bf23f6d93b6698f2ce3" translate="yes" xml:space="preserve">
          <source>If this option is set, &lt;code&gt;upload-pack&lt;/code&gt; will support the &lt;code&gt;ref-in-want&lt;/code&gt; feature of the protocol version 2 &lt;code&gt;fetch&lt;/code&gt; command. This feature is intended for the benefit of load-balanced servers which may not have the same view of what OIDs their refs point to due to replication delay.</source>
          <target state="translated">如果设置此选项，则 &lt;code&gt;upload-pack&lt;/code&gt; 将支持协议版本2 &lt;code&gt;fetch&lt;/code&gt; 命令的 &lt;code&gt;ref-in-want&lt;/code&gt; 功能。此功能旨在使负载平衡的服务器受益，由于复制延迟，这些服务器可能无法对其引用指向的OID拥有相同的看法。</target>
        </trans-unit>
        <trans-unit id="3691063a71adef86ec77db2886b5e8b672228551" translate="yes" xml:space="preserve">
          <source>If this option is set, when &lt;code&gt;upload-pack&lt;/code&gt; would run &lt;code&gt;git pack-objects&lt;/code&gt; to create a packfile for a client, it will run this shell command instead. The &lt;code&gt;pack-objects&lt;/code&gt; command and arguments it &lt;code&gt;would&lt;/code&gt; have run (including the &lt;code&gt;git pack-objects&lt;/code&gt; at the beginning) are appended to the shell command. The stdin and stdout of the hook are treated as if &lt;code&gt;pack-objects&lt;/code&gt; itself was run. I.e., &lt;code&gt;upload-pack&lt;/code&gt; will feed input intended for &lt;code&gt;pack-objects&lt;/code&gt; to the hook, and expects a completed packfile on stdout.</source>
          <target state="translated">如果设置了此选项，则当 &lt;code&gt;upload-pack&lt;/code&gt; 运行 &lt;code&gt;git pack-objects&lt;/code&gt; 为客户端创建一个packfile时，它将运行此shell命令。该 &lt;code&gt;pack-objects&lt;/code&gt; 的命令，它的参数 &lt;code&gt;would&lt;/code&gt; 已经运行（包括 &lt;code&gt;git pack-objects&lt;/code&gt; 开头）被附加到shell命令。钩子的stdin和stdout被视为已运行 &lt;code&gt;pack-objects&lt;/code&gt; 本身。也就是说， &lt;code&gt;upload-pack&lt;/code&gt; 会将旨在用于 &lt;code&gt;pack-objects&lt;/code&gt; 输入提供给钩子，并期望在stdout上具有完整的packfile。</target>
        </trans-unit>
        <trans-unit id="043d313af4e6bae8eb0dfe37d6ed595c4f6e4603" translate="yes" xml:space="preserve">
          <source>If this option is specified and &lt;code&gt;git svn&lt;/code&gt; encounters an SVN committer name that does not exist in the authors-file, &lt;code&gt;git svn&lt;/code&gt; will abort operation. The user will then have to add the appropriate entry. Re-running the previous &lt;code&gt;git svn&lt;/code&gt; command after the authors-file is modified should continue operation.</source>
          <target state="translated">如果指定了此选项，并且 &lt;code&gt;git svn&lt;/code&gt; 遇到authors文件中不存在的SVN提交者名称，则 &lt;code&gt;git svn&lt;/code&gt; 将中止操作。然后，用户将必须添加适当的条目。修改authors-file后重新运行上一个 &lt;code&gt;git svn&lt;/code&gt; 命令应继续操作。</target>
        </trans-unit>
        <trans-unit id="68c99ad12996bd9192637a1c1520fb2b24def75b" translate="yes" xml:space="preserve">
          <source>If this option is specified, for each SVN committer name that does not exist in the authors file, the given file is executed with the committer name as the first argument. The program is expected to return a single line of the form &quot;Name &amp;lt;email&amp;gt;&quot; or &quot;Name &amp;lt;&amp;gt;&quot;, which will be treated as if included in the authors file.</source>
          <target state="translated">如果指定了此选项，那么对于authors文件中不存在的每个SVN提交者名称，将使用提交者名称作为第一个参数来执行给定文件。该程序应返回格式为&amp;ldquo;名称&amp;lt;email&amp;gt;&amp;rdquo;或&amp;ldquo;名称&amp;lt;&amp;gt;&amp;rdquo;的单行，将其视为包含在作者文件中。</target>
        </trans-unit>
        <trans-unit id="9706c1068d7b5bd67656b65aa296c50f3e651323" translate="yes" xml:space="preserve">
          <source>If this variable is not specified, it defaults to &lt;code&gt;normal&lt;/code&gt;. This variable can be overridden with the -u|--untracked-files option of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">如果未指定此变量，则默认为 &lt;code&gt;normal&lt;/code&gt; 。可以使用&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;和&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;的-u | --untracked-files选项覆盖此变量。</target>
        </trans-unit>
        <trans-unit id="9b0cae3fed40383cf5d614f1da46a2c524e4930e" translate="yes" xml:space="preserve">
          <source>If this variable is set to &quot;1&quot;, &quot;2&quot; or &quot;true&quot; (comparison is case insensitive), trace messages will be printed to stderr.</source>
          <target state="translated">如果这个变量被设置为 &quot;1&quot;、&quot;2 &quot;或 &quot;true&quot;(比较不区分大小写),跟踪信息将被打印到stderr。</target>
        </trans-unit>
        <trans-unit id="c1357386502b4e540a41766c550326b57fc0ea56" translate="yes" xml:space="preserve">
          <source>If this variable is set to a path, non-worktree files that are normally in $GIT_DIR will be taken from this path instead. Worktree-specific files such as HEAD or index are taken from $GIT_DIR. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; and &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt; for details. This variable has lower precedence than other path variables such as GIT_INDEX_FILE, GIT_OBJECT_DIRECTORY&amp;hellip;​</source>
          <target state="translated">如果将此变量设置为路径，则将从该路径中获取通常位于$ GIT_DIR中的非工作树文件。特定于工作树的文件（例如HEAD或index）是从$ GIT_DIR获取的。有关详细信息，请参见&lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt;和&lt;a href=&quot;git-worktree&quot;&gt;git-worktree [1]&lt;/a&gt;。此变量的优先级低于其他路径变量，例如GIT_INDEX_FILE，GIT_OBJECT_DIRECTORY ...</target>
        </trans-unit>
        <trans-unit id="8249d2ab5516fac15cd6ed908f0ba3c1a12338b5" translate="yes" xml:space="preserve">
          <source>If this variable is set, &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; will use the specified command instead of &lt;code&gt;ssh&lt;/code&gt; when they need to connect to a remote system. The command is in the same form as the &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; environment variable and is overridden when the environment variable is set.</source>
          <target state="translated">如果设置了此变量，则当 &lt;code&gt;git fetch&lt;/code&gt; 和 &lt;code&gt;git push&lt;/code&gt; 需要连接到远程系统时，它们将使用指定的命令而不是 &lt;code&gt;ssh&lt;/code&gt; 。该命令与 &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; 环境变量的格式相同，并且在设置环境变量后将被覆盖。</target>
        </trans-unit>
        <trans-unit id="e4e675f6ba8abd4a71f30087b18137ff3c23311f" translate="yes" xml:space="preserve">
          <source>If this variable is set, the default hash algorithm for new repositories will be set to this value. This value is currently ignored when cloning; the setting of the remote repository is used instead. The default is &quot;sha1&quot;. THIS VARIABLE IS EXPERIMENTAL! See &lt;code&gt;--object-format&lt;/code&gt; in &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af55b279f11e2f816fa42fab0cbda45b206e1ef" translate="yes" xml:space="preserve">
          <source>If timestamps of commits in the CVS repository are not stable enough to be used for ordering commits changes may show up in the wrong order.</source>
          <target state="translated">如果 CVS 仓库中的提交时间戳不够稳定,无法用于排序提交,那么更改可能会以错误的顺序显示。</target>
        </trans-unit>
        <trans-unit id="51615abc07df5f5fedb19397be1e475bae29e04c" translate="yes" xml:space="preserve">
          <source>If true (default), a single editor instance will be spawned to edit files you have to edit (patches when &lt;code&gt;--annotate&lt;/code&gt; is used, and the summary when &lt;code&gt;--compose&lt;/code&gt; is used). If false, files will be edited one after the other, spawning a new editor each time.</source>
          <target state="translated">如果为真（默认），一个编辑器实例会催生你必须编辑编辑文件（当补丁 &lt;code&gt;--annotate&lt;/code&gt; 使用，并在总结 &lt;code&gt;--compose&lt;/code&gt; 使用）。如果为false，文件将被一个接一个地编辑，每次都产生一个新的编辑器。</target>
        </trans-unit>
        <trans-unit id="6c99dc0ffc12cab74a91d9cd9821ddfe241990c4" translate="yes" xml:space="preserve">
          <source>If true prevents displaying information about repository owner.</source>
          <target state="translated">如果为真,则防止显示版本库所有者的信息。</target>
        </trans-unit>
        <trans-unit id="fad7b766b28596874c184072e4308f81cec3bb8e" translate="yes" xml:space="preserve">
          <source>If true the web server started by &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; will be bound to the local IP (127.0.0.1).</source>
          <target state="translated">如果为true，则由&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;启动的Web服务器将绑定到本地IP（127.0.0.1）。</target>
        </trans-unit>
        <trans-unit id="24fc21f99a5940a5b287a59503e7df044758b9be" translate="yes" xml:space="preserve">
          <source>If true this repository is assumed to be &lt;code&gt;bare&lt;/code&gt; and has no working directory associated with it. If this is the case a number of commands that require a working directory will be disabled, such as &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; or &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;.</source>
          <target state="translated">如果为true，则假定此存储库是 &lt;code&gt;bare&lt;/code&gt; ，并且没有与之关联的工作目录。如果是这种情况，则会禁用许多需要工作目录的命令，例如&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;或&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18d14681f32fdc08f62b0e7a189d6a89008757fd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;git gui blame&lt;/code&gt; uses &lt;code&gt;-C&lt;/code&gt; instead of &lt;code&gt;-C -C&lt;/code&gt; for original location detection. It makes blame significantly faster on huge repositories at the expense of less thorough copy detection.</source>
          <target state="translated">如果为true，则 &lt;code&gt;git gui blame&lt;/code&gt; 使用 &lt;code&gt;-C&lt;/code&gt; 代替 &lt;code&gt;-C -C&lt;/code&gt; 进行原始位置检测。它使大型存储库的责备速度明显加快，但代价是复制检测不彻底。</target>
        </trans-unit>
        <trans-unit id="a4dc06197e1e60c2601c1eee394ecb56132cf3c4" translate="yes" xml:space="preserve">
          <source>If true, Git will avoid using lstat() calls to detect if files have changed by setting the &quot;assume-unchanged&quot; bit for those tracked files which it has updated identically in both the index and working tree.</source>
          <target state="translated">如果为 &quot;true&quot;,Git会通过设置 &quot;assume-unchanged &quot;位来避免使用lstat()调用来检测文件是否发生了变化,这些文件在索引和工作树中的更新都是相同的。</target>
        </trans-unit>
        <trans-unit id="f52d8aadd1ed60dd80b38e7a96aadc385cabb931" translate="yes" xml:space="preserve">
          <source>If true, Git will warn you if the ref name you passed it is ambiguous and might match multiple refs in the repository. True by default.</source>
          <target state="translated">如果为真,Git 会警告你,如果你传递给它的 refs 名称不明确,可能与版本库中的多个 refs 匹配。默认为true。</target>
        </trans-unit>
        <trans-unit id="b4f1cbcb9d6580097e1319f75786e1aefcc4a19a" translate="yes" xml:space="preserve">
          <source>If true, allow clients to use &lt;code&gt;git archive --remote&lt;/code&gt; to request any tree, whether reachable from the ref tips or not. See the discussion in the &quot;SECURITY&quot; section of &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt; for more details. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果为true，则允许客户端使用 &lt;code&gt;git archive --remote&lt;/code&gt; 来请求任何树，无论是否可以通过ref提示访问。有关更多详细信息，请参见&lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]&lt;/a&gt;的&amp;ldquo;安全性&amp;rdquo;部分中的讨论。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9577d8134a35c2d555845d35ede1972ec309a7fc" translate="yes" xml:space="preserve">
          <source>If true, enable &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; for use by remote clients via &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt;. Defaults to false for user-defined formats, but true for the &quot;tar.gz&quot; and &quot;tgz&quot; formats.</source>
          <target state="translated">如果为true，则通过&lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]&lt;/a&gt;启用 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 供远程客户端使用。对于用户定义的格式，默认为false；对于&amp;ldquo; tar.gz&amp;rdquo;和&amp;ldquo; tgz&amp;rdquo;格式，默认为true。</target>
        </trans-unit>
        <trans-unit id="5f15956c2db32b4b1b45dac474661942b8aa7008" translate="yes" xml:space="preserve">
          <source>If true, fetch will automatically behave as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line. See also &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; and the PRUNING section of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">如果为true，则提取将自动执行，就像在命令行上给出了 &lt;code&gt;--prune&lt;/code&gt; 选项一样。另请参见 &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; 和&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]的&lt;/a&gt;PRUNING部分。</target>
        </trans-unit>
        <trans-unit id="7d985f4709f0d26edc0babef707e65f833d349aa" translate="yes" xml:space="preserve">
          <source>If true, fetch will automatically behave as if the &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; refspec was provided when pruning, if not set already. This allows for setting both this option and &lt;code&gt;fetch.prune&lt;/code&gt; to maintain a 1=1 mapping to upstream refs. See also &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; and the PRUNING section of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">如果为true，则修剪时会自动提供好像 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; refspec的行为（如果尚未设置）。这允许同时设置此选项和 &lt;code&gt;fetch.prune&lt;/code&gt; ,以保持与上游引用的1 = 1映射。另请参见 &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; 和&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]的&lt;/a&gt;PRUNING部分。</target>
        </trans-unit>
        <trans-unit id="2de6ae2b37da0c5dc299e33fe86fea1c6d9d4a0f" translate="yes" xml:space="preserve">
          <source>If true, git-am will call git-mailsplit for patches in mbox format with parameter &lt;code&gt;--keep-cr&lt;/code&gt;. In this case git-mailsplit will not remove &lt;code&gt;\r&lt;/code&gt; from lines ending with &lt;code&gt;\r\n&lt;/code&gt;. Can be overridden by giving &lt;code&gt;--no-keep-cr&lt;/code&gt; from the command line. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;, &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit[1]&lt;/a&gt;.</source>
          <target state="translated">如果为true，git-am将使用参数 &lt;code&gt;--keep-cr&lt;/code&gt; 调用git-mailsplit以获得mbox格式的补丁。在这种情况下，git-mailsplit不会从 &lt;code&gt;\r\n&lt;/code&gt; 结尾的行中删除 &lt;code&gt;\r&lt;/code&gt; 。可以通过在命令行中使用 &lt;code&gt;--no-keep-cr&lt;/code&gt; 来覆盖它。参见&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;，&lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e94bf962607289b1694c70432d3fab451c61737d" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--abbrev-commit&lt;/code&gt;. You may override this option with &lt;code&gt;--no-abbrev-commit&lt;/code&gt;.</source>
          <target state="translated">如果为true，则使&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;，&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;和&lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt;假定 &lt;code&gt;--abbrev-commit&lt;/code&gt; 。您可以使用 &lt;code&gt;--no-abbrev-commit&lt;/code&gt; 覆盖此选项。</target>
        </trans-unit>
        <trans-unit id="f7c96ef3a79b38b8c56dee4db799ed4d172ce90c" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--show-signature&lt;/code&gt;.</source>
          <target state="translated">如果为true，则使&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;，&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;和&lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt;假定 &lt;code&gt;--show-signature&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cb33eaf81fb27f3c3d3ba0e81d6670ba0d0bfaf" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--use-mailmap&lt;/code&gt;, otherwise assume &lt;code&gt;--no-use-mailmap&lt;/code&gt;. True by default.</source>
          <target state="translated">如果为true，则使&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;，&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;和&lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt;假定 &lt;code&gt;--use-mailmap&lt;/code&gt; ，否则假定 &lt;code&gt;--no-use-mailmap&lt;/code&gt; 。默认为True。</target>
        </trans-unit>
        <trans-unit id="672cef13127670a717c7a3aa65681a15ad776d1b" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt; (and therefore &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;) act by default as if the --scissors option was provided on the command-line. When active, this features removes everything from the message body before a scissors line (i.e. consisting mainly of &quot;&amp;gt;8&quot;, &quot;8&amp;lt;&quot; and &quot;-&quot;).</source>
          <target state="translated">如果为true，则默认情况下使&lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]&lt;/a&gt;（并因此使&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;）起作用，就像在命令行上提供了--scissors选项一样。启用后，此功能会删除剪刀行之前的消息正文中的所有内容（即主要由&amp;ldquo;&amp;gt; 8&amp;rdquo;，&amp;ldquo; 8 &amp;lt;&amp;rdquo;和&amp;ldquo;-&amp;rdquo;组成）。</target>
        </trans-unit>
        <trans-unit id="d25b510a17b04a17cfbdc40d0999d1586f4d5f91" translate="yes" xml:space="preserve">
          <source>If true, makes Git check if converting &lt;code&gt;CRLF&lt;/code&gt; is reversible when end-of-line conversion is active. Git will verify if a command modifies a file in the work tree either directly or indirectly. For example, committing a file followed by checking out the same file should yield the original file in the work tree. If this is not the case for the current setting of &lt;code&gt;core.autocrlf&lt;/code&gt;, Git will reject the file. The variable can be set to &quot;warn&quot;, in which case Git will only warn about an irreversible conversion but continue the operation.</source>
          <target state="translated">如果为true，则在行尾转换处于活动状态时，让Git检查转换 &lt;code&gt;CRLF&lt;/code&gt; 是否可逆。Git将验证命令是否直接或间接修改了工作树中的文件。例如，提交文件然后签出相同文件应在工作树中产生原始文件。如果对于 &lt;code&gt;core.autocrlf&lt;/code&gt; 的当前设置不是这种情况，Git将拒绝该文件。变量可以设置为&amp;ldquo;警告&amp;rdquo;，在这种情况下，Git仅警告不可逆的转换，而是继续操作。</target>
        </trans-unit>
        <trans-unit id="3a6f979740fe111373346b7083b54b9e059af003" translate="yes" xml:space="preserve">
          <source>If true, omit the column with date of the most current commit on the projects list page. It can save a bit of I/O and a fork per repository.</source>
          <target state="translated">如果为真,则省略项目列表页中最近一次提交的日期一栏。这可以节省一点 I/O 和每个仓库的分叉。</target>
        </trans-unit>
        <trans-unit id="9e101a02df349b50a39b60288665a643391bcf24" translate="yes" xml:space="preserve">
          <source>If true, pushing to this remote will automatically behave as if the &lt;code&gt;--mirror&lt;/code&gt; option was given on the command line.</source>
          <target state="translated">如果为true，则推送到该远程服务器将自动执行行为，就像在命令行上给出了 &lt;code&gt;--mirror&lt;/code&gt; 选项一样。</target>
        </trans-unit>
        <trans-unit id="561edb27b58ccdfdecb1aae75865de22935f3cd3" translate="yes" xml:space="preserve">
          <source>If true, some gitweb features are disabled to prevent content in repositories from launching cross-site scripting (XSS) attacks. Set this to true if you don&amp;rsquo;t trust the content of your repositories. False by default (set to 0).</source>
          <target state="translated">如果为true，则会禁用某些gitweb功能，以防止存储库中的内容发起跨站点脚本（XSS）攻击。如果您不信任存储库的内容，请将其设置为true。默认情况下为False（设置为0）。</target>
        </trans-unit>
        <trans-unit id="698e5f4a0ab76eb97600c890fa9adac3c5e93fa4" translate="yes" xml:space="preserve">
          <source>If true, the initial commit will be shown as a big creation event. This is equivalent to a diff against an empty tree. Tools like &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; or &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;, which normally hide the root commit will now show it. True by default.</source>
          <target state="translated">如果为true，则初始提交将显示为大型创建事件。这等效于对空树的差异。像&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;或&lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]这样的工具&lt;/a&gt;，通常会隐藏根提交，现在将显示它。默认为True。</target>
        </trans-unit>
        <trans-unit id="7f4771e5273a3a0e51423699c29e2caf790623f9" translate="yes" xml:space="preserve">
          <source>If true, the server will look up the end-of-line conversion attributes for files to determine the &lt;code&gt;-k&lt;/code&gt; modes to use. If the attributes force Git to treat a file as text, the &lt;code&gt;-k&lt;/code&gt; mode will be left blank so CVS clients will treat it as text. If they suppress text conversion, the file will be set with &lt;code&gt;-kb&lt;/code&gt; mode, which suppresses any newline munging the client might otherwise do. If the attributes do not allow the file type to be determined, then &lt;code&gt;gitcvs.allBinary&lt;/code&gt; is used. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">如果为true，则服务器将查找文件的行尾转换属性，以确定要使用的 &lt;code&gt;-k&lt;/code&gt; 模式。如果属性强制Git将文件视为文本，则 &lt;code&gt;-k&lt;/code&gt; 模式将留为空白，因此CVS客户端会将其视为文本。如果他们禁止文本转换，则将使用 &lt;code&gt;-kb&lt;/code&gt; 模式设置文件，该模式将禁止客户端可能以其他方式换行。如果属性不允许确定文件类型，则使用 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; 。参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36ac6e641c359be495ff334484c92173e0b7c3c8" translate="yes" xml:space="preserve">
          <source>If true, the split-index feature of the index will be used. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;. False by default.</source>
          <target state="translated">如果为true，将使用索引的split-index功能。参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;。默认为False。</target>
        </trans-unit>
        <trans-unit id="521397cd2bc3f328c7b75df2807813cd34103bfb" translate="yes" xml:space="preserve">
          <source>If true, then gc will rewrite the commit-graph file when &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; is run. When using &lt;code&gt;git gc --auto&lt;/code&gt; the commit-graph will be updated if housekeeping is required. Default is true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for details.</source>
          <target state="translated">如果为true，则在运行&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;时gc将重写提交图文件。当使用 &lt;code&gt;git gc --auto&lt;/code&gt; 时，如果需要管家，提交图将被更新。默认为true。有关详细信息，请参见&lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="902fdcf00401d2e7de222ff42ce846a756cbb163" translate="yes" xml:space="preserve">
          <source>If true, then git will read the commit-graph file (if it exists) to parse the graph structure of commits. Defaults to true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for more information.</source>
          <target state="translated">如果为true，则git将读取提交图文件（如果存在）以解析提交的图结构。默认为true。有关更多信息，请参见&lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca076926e8bbfce2f59c8069a39ed42dca4bb470" translate="yes" xml:space="preserve">
          <source>If true, then git will use the changed-path Bloom filters in the commit-graph file (if it exists, and they are present). Defaults to true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615bfb2827e0f7022b5822b60fa7f8c63365efe6" translate="yes" xml:space="preserve">
          <source>If true, this is equivalent to the --verify-signatures command line option. See &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details.</source>
          <target state="translated">如果为true，则等效于--verify-signatures命令行选项。有关详细信息，请参见&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ab6fd64e80cf040c0dbc59c3bda45e3cb1c29b3" translate="yes" xml:space="preserve">
          <source>If true, this remote will be skipped by default when updating using &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; or the &lt;code&gt;update&lt;/code&gt; subcommand of &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">如果为true，则在使用&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;或&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;的 &lt;code&gt;update&lt;/code&gt; 子命令进行更新时，默认情况下将跳过此远程控制器。</target>
        </trans-unit>
        <trans-unit id="537153cdd9a230b7ef7748cee5c002a80aec5646" translate="yes" xml:space="preserve">
          <source>If we compute the following non optimal function on it:</source>
          <target state="translated">如果我们对其计算以下非最优函数。</target>
        </trans-unit>
        <trans-unit id="b2bbf437e467ca2cfec5d122277b398062cce56a" translate="yes" xml:space="preserve">
          <source>If we examined all this history together in one repository, it will look like:</source>
          <target state="translated">如果我们把所有这些历史都放在一个仓库里一起研究,它就会像。</target>
        </trans-unit>
        <trans-unit id="f77fa3523026c17c64002e6f77dd7e18ad8c7cf7" translate="yes" xml:space="preserve">
          <source>If we have moved away from commit &lt;code&gt;f&lt;/code&gt;, then we must first recover its object name (typically by using git reflog), and then we can create a reference to it. For example, to see the last two commits to which &lt;code&gt;HEAD&lt;/code&gt; referred, we can use either of these commands:</source>
          <target state="translated">如果我们离开了commit &lt;code&gt;f&lt;/code&gt; ，那么我们必须首先恢复其对象名（通常使用git reflog），然后才能创建对其的引用。例如，要查看 &lt;code&gt;HEAD&lt;/code&gt; 引用的最后两个提交，我们可以使用以下命令之一：</target>
        </trans-unit>
        <trans-unit id="1d5fb2a96e98dbf044763df4f4d84c289b1a7a1e" translate="yes" xml:space="preserve">
          <source>If we look at the way commits are created under the cover, we&amp;rsquo;ll see that there are more flexible ways creating commits.</source>
          <target state="translated">如果我们看一下在幕后创建提交的方式，我们会发现创建提交的方式更加灵活。</target>
        </trans-unit>
        <trans-unit id="2a7aed1833634138d2979858dc472c551054c3f5" translate="yes" xml:space="preserve">
          <source>If we need to talk about a particular commit, the character &quot;o&quot; may be replaced with another letter or number.</source>
          <target state="translated">如果我们需要谈论某个特定的提交,&quot;o &quot;字可以用其他字母或数字代替。</target>
        </trans-unit>
        <trans-unit id="73117dc442919d58c7658111f0e65fc3ffc2d92d" translate="yes" xml:space="preserve">
          <source>If width is &lt;code&gt;0&lt;/code&gt; (zero) then indent the lines of the output without wrapping them.</source>
          <target state="translated">如果width为 &lt;code&gt;0&lt;/code&gt; （零），则在不换行的情况下缩进输出的行。</target>
        </trans-unit>
        <trans-unit id="a0f8f4ea612137fd1324a3c99aa8cca8319d30d8" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;+&lt;/code&gt; (plus sign) after &lt;code&gt;%&lt;/code&gt; of a placeholder, a line-feed is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.</source>
          <target state="translated">如果在占位符的 &lt;code&gt;%&lt;/code&gt; 之后添加 &lt;code&gt;+&lt;/code&gt; （加号），则当且仅当占位符扩展为非空字符串时，才在扩展名之前插入换行符。</target>
        </trans-unit>
        <trans-unit id="f83e564943919127dff3b2d8ad2099402ce321cb" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;-&lt;/code&gt; (minus sign) after &lt;code&gt;%&lt;/code&gt; of a placeholder, all consecutive line-feeds immediately preceding the expansion are deleted if and only if the placeholder expands to an empty string.</source>
          <target state="translated">如果在占位符的 &lt;code&gt;%&lt;/code&gt; 之后添加 &lt;code&gt;-&lt;/code&gt; （减号），则仅当占位符扩展为空字符串时，才会删除紧接扩展之前的所有连续换行符。</target>
        </trans-unit>
        <trans-unit id="a78fb3b12f14b3649d1e2f03162a9771701e268a" translate="yes" xml:space="preserve">
          <source>If you add a ` ` (space) after &lt;code&gt;%&lt;/code&gt; of a placeholder, a space is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.</source>
          <target state="translated">如果在占位符的 &lt;code&gt;%&lt;/code&gt; 之后添加一个`（空格），则当且仅当占位符扩展为非空字符串时，才在扩展之前插入一个空格。</target>
        </trans-unit>
        <trans-unit id="2c694abd299e141b455acf195b0e2c24045c8fb9" translate="yes" xml:space="preserve">
          <source>If you allow overriding for the snapshot feature, you can specify which snapshot formats are globally disabled. You can also add any command-line options you want (such as setting the compression level). For instance, you can disable Zip compressed snapshots and set &lt;strong&gt;gzip&lt;/strong&gt;(1) to run at level 6 by adding the following lines to your gitweb configuration file:</source>
          <target state="translated">如果允许替代快照功能，则可以指定全局禁用哪些快照格式。您还可以添加所需的任何命令行选项（例如设置压缩级别）。例如，通过向gitweb配置文件中添加以下行，可以禁用Zip压缩快照并将&lt;strong&gt;gzip&lt;/strong&gt;（1）设置为在第6级运行：</target>
        </trans-unit>
        <trans-unit id="1eda80bb2b9aeb620d19886733f7a0a33613b07f" translate="yes" xml:space="preserve">
          <source>If you already use &lt;code&gt;mod_userdir&lt;/code&gt; in your virtual host or you don&amp;rsquo;t want to use the '~' as first character, just comment or remove the second rewrite rule, and uncomment one of the following according to what you want.</source>
          <target state="translated">如果您已经在虚拟主机中使用了 &lt;code&gt;mod_userdir&lt;/code&gt; ，或者不想将'〜'用作第一个字符，则只需注释或删除第二个重写规则，然后根据需要取消注释以下一项。</target>
        </trans-unit>
        <trans-unit id="28aab4433d981c882862a14d41ff2a1b6ecf68f5" translate="yes" xml:space="preserve">
          <source>If you also want to see complete diffs at each step, use</source>
          <target state="translated">如果你也想看到每一步的完整差异,使用</target>
        </trans-unit>
        <trans-unit id="cc8e02bd7d5fd8efba31a3f28960e44c003964ed" translate="yes" xml:space="preserve">
          <source>If you and the maintainer both have accounts on the same machine, then you can just pull changes from each other&amp;rsquo;s repositories directly; commands that accept repository URLs as arguments will also accept a local directory name:</source>
          <target state="translated">如果您和维护者都在同一台计算机上拥有帐户，那么您可以直接从彼此的存储库中提取更改；接受存储库URL作为参数的命令还将接受本地目录名称：</target>
        </trans-unit>
        <trans-unit id="41ebdd5e935074b399d696e8dc1f4204152e3f63" translate="yes" xml:space="preserve">
          <source>If you are a contributor that sends changes upstream in the form of emails, you should use topic branches as usual (see above). Then use &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; to generate the corresponding emails (highly recommended over manually formatting them because it makes the maintainer&amp;rsquo;s life easier).</source>
          <target state="translated">如果您是以电子邮件形式向上游发送更改的贡献者，则应照常使用主题分支（请参见上文）。然后使用&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;生成相应的电子邮件（强烈建议您不要手动格式化电子邮件，因为这样会使维护人员的工作更加轻松）。</target>
        </trans-unit>
        <trans-unit id="f7586aada4dc4dabc26450bca6e988967f6c8334" translate="yes" xml:space="preserve">
          <source>If you are a maintainer and would like to merge other people&amp;rsquo;s topic branches to the integration branches, they will typically send a request to do so by mail. Such a request looks like</source>
          <target state="translated">如果您是维护者，并且希望将其他人的主题分支合并到集成分支，则他们通常会通过邮件发送请求。这样的请求看起来像</target>
        </trans-unit>
        <trans-unit id="6a4170b1f048a116a2a20a0123a6634648180f67" translate="yes" xml:space="preserve">
          <source>If you are coming from a CVS background, the style of cooperation suggested in the previous section may be new to you. You do not have to worry. Git supports the &quot;shared public repository&quot; style of cooperation you are probably more familiar with as well.</source>
          <target state="translated">如果您来自CVS背景,上一节中建议的合作方式可能对您来说是陌生的。你不必担心。Git 支持你可能更熟悉的 &quot;共享公共仓库 &quot;式的合作。</target>
        </trans-unit>
        <trans-unit id="d473d9569ed7194445a9c66a5a376371d037be9a" translate="yes" xml:space="preserve">
          <source>If you are creating a branch that you want to switch to immediately, it is easier to use the &quot;git switch&quot; command with its &lt;code&gt;-c&lt;/code&gt; option to do the same thing with a single command.</source>
          <target state="translated">如果要创建要立即切换到的分支，则使用带有它的 &lt;code&gt;-c&lt;/code&gt; 选项的&amp;ldquo; git switch&amp;rdquo;命令可以更容易地通过单个命令执行相同的操作。</target>
        </trans-unit>
        <trans-unit id="882d5e43cce8c196ac8e463999e712ea9e114942" translate="yes" xml:space="preserve">
          <source>If you are following somebody else&amp;rsquo;s tree, you are most likely using remote-tracking branches (eg. &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;). You usually want the tags from the other end.</source>
          <target state="translated">如果您跟随别人的树，则很可能使用远程跟踪分支（例如 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; ）。通常，您需要另一端的标签。</target>
        </trans-unit>
        <trans-unit id="0f51d0b61f348c2beb156a534ba33bcb5f141385" translate="yes" xml:space="preserve">
          <source>If you are going to offer CVS access via pserver, add a line in /etc/inetd.conf like</source>
          <target state="translated">如果你打算通过 pserver 提供 CVS 访问,在 /etc/inetd.conf 中添加一行,如</target>
        </trans-unit>
        <trans-unit id="e1c58ac4057b121c58f1f5681f07adc3f2f06c66" translate="yes" xml:space="preserve">
          <source>If you are instead primarily interested in using Git to fetch a project, for example, to test the latest version, you may prefer to start with the first two chapters of &lt;a href=&quot;user-manual&quot;&gt;The Git User&amp;rsquo;s Manual&lt;/a&gt;.</source>
          <target state="translated">如果您主要是对使用Git来获取项目（例如，测试最新版本）感兴趣，则可能更喜欢从&lt;a href=&quot;user-manual&quot;&gt;《 Git用户手册》&lt;/a&gt;的前两章开始。</target>
        </trans-unit>
        <trans-unit id="9ce35cf81da423ef90a67288a1d702b7e25d4c6b" translate="yes" xml:space="preserve">
          <source>If you are interested in more details of the revision walking process, just have a look at the first implementation of &lt;code&gt;cmd_log()&lt;/code&gt;; call &lt;code&gt;git show v1.3.0&lt;sub&gt;155^2&lt;/sub&gt;4&lt;/code&gt; and scroll down to that function (note that you no longer need to call &lt;code&gt;setup_pager()&lt;/code&gt; directly).</source>
          <target state="translated">如果您对修订修订过程的更多细节感兴趣，只需看一下 &lt;code&gt;cmd_log()&lt;/code&gt; 的第一个实现即可；调用 &lt;code&gt;git show v1.3.0&lt;sub&gt;155^2&lt;/sub&gt;4&lt;/code&gt; 并向下滚动到该函数（请注意，您不再需要直接调用 &lt;code&gt;setup_pager()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9ac179f42cb3351e666e44e39b35f145be521392" translate="yes" xml:space="preserve">
          <source>If you are interested in more details of the revision walking process, just have a look at the first implementation of &lt;code&gt;cmd_log()&lt;/code&gt;; call &lt;code&gt;git show v1.3.0~155^2~4&lt;/code&gt; and scroll down to that function (note that you no longer need to call &lt;code&gt;setup_pager()&lt;/code&gt; directly).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b0f41c084141a75721908d0d5d7971792ac89f" translate="yes" xml:space="preserve">
          <source>If you are not absolutely sure that the intermediate revisions are consistent (they compile, pass the testsuite, etc.) you should use &lt;code&gt;git stash&lt;/code&gt; to stash away the not-yet-committed changes after each commit, test, and amend the commit if fixes are necessary.</source>
          <target state="translated">如果您不确定中间版本是否一致（它们可以编译，通过测试套件等），则应在每次提交，测试和修订（如果有修正）后使用 &lt;code&gt;git stash&lt;/code&gt; 存放尚未提交的更改。是必要的。</target>
        </trans-unit>
        <trans-unit id="f188b17d328d7a9e1b61bcc0d2e0defbbf399561" translate="yes" xml:space="preserve">
          <source>If you are only interested in changes of the currently initialized submodules with respect to the commit recorded in the index or the HEAD, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; will provide that information too (and can also report changes to a submodule&amp;rsquo;s work tree).</source>
          <target state="translated">如果您只对当前初始化的子模块相对于索引或HEAD中记录的提交的更改感兴趣，则&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;和&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;也将提供该信息（并且还可以将更改报告给子模块的工作树）。</target>
        </trans-unit>
        <trans-unit id="9fb9a58a453e5ac1de19a98e53575241a40d1da0" translate="yes" xml:space="preserve">
          <source>If you are paranoid, running &lt;code&gt;git verify-pack&lt;/code&gt; command would detect if you have a corrupt pack, but do not worry too much. Our programs are always perfect ;-).</source>
          <target state="translated">如果您偏执狂，运行 &lt;code&gt;git verify-pack&lt;/code&gt; 命令将检测您是否有损坏的背包，但不要太担心。我们的程序总是完美的;-)。</target>
        </trans-unit>
        <trans-unit id="277e03057ecd44d387d6f501d21982d9ff59224b" translate="yes" xml:space="preserve">
          <source>If you are repacking very old imported data (e.g. older than the last year), consider expending some extra CPU time and supplying --window=50 (or higher) when you run &lt;code&gt;git repack&lt;/code&gt;. This will take longer, but will also produce a smaller packfile. You only need to expend the effort once, and everyone using your project will benefit from the smaller repository.</source>
          <target state="translated">如果您要重新打包非常旧的导入数据（例如，比去年旧），请考虑花费一些额外的CPU时间并在运行 &lt;code&gt;git repack&lt;/code&gt; 时提供--window = 50（或更高）。这将花费更长的时间，但也会产生一个较小的packfile。您只需花费一次工作，每个使用您的项目的人都会从较小的存储库中受益。</target>
        </trans-unit>
        <trans-unit id="c500814f6020ec6c3d1c5a9b455910ea7fc36da1" translate="yes" xml:space="preserve">
          <source>If you are using &quot;git bisect run&quot;, you can use the same manual fix up as above, and then start another &quot;git bisect run&quot; in the special branch. Or as the &quot;git bisect&quot; man page says, the script passed to &quot;git bisect run&quot; can apply a patch before it compiles and test the software &lt;a href=&quot;#8&quot;&gt;[8]&lt;/a&gt;. The patch should turn a current untestable commits into a testable one. So the testing will result in &quot;good&quot; or &quot;bad&quot; and &quot;git bisect&quot; will be able to find the first bad commit. And the script should not forget to remove the patch once the testing is done before exiting from the script.</source>
          <target state="translated">如果使用&amp;ldquo; git bisect run&amp;rdquo;，则可以使用与上述相同的手动修复，然后在特殊分支中启动另一个&amp;ldquo; git bisect run&amp;rdquo;。或如&amp;ldquo; git bisect&amp;rdquo;手册页所述，传递给&amp;ldquo; git bisect run&amp;rdquo;的脚本可以在编译和测试软件之前应用补丁&lt;a href=&quot;#8&quot;&gt;[8]&lt;/a&gt;。该修补程序应将当前无法测试的提交变成可测试的提交。因此，测试将导致&amp;ldquo;好&amp;rdquo;或&amp;ldquo;坏&amp;rdquo;，而&amp;ldquo; git bisect&amp;rdquo;将能够找到第一个错误的提交。测试结束后，脚本还应该忘记删除补丁，然后再退出脚本。</target>
        </trans-unit>
        <trans-unit id="c6c0585fbbb0e19d850e67091effac179b4cf010" translate="yes" xml:space="preserve">
          <source>If you blow the index away entirely, you generally haven&amp;rsquo;t lost any information as long as you have the name of the tree that it described.</source>
          <target state="translated">如果您完全破坏了索引，那么只要知道它描述的树的名称，通常就不会丢失任何信息。</target>
        </trans-unit>
        <trans-unit id="2d2eeeb68a563ca60a2c585f75afbad9b4a5940e" translate="yes" xml:space="preserve">
          <source>If you both have a test suite and use git bisect, then it becomes less important to check that all tests pass after each commit. Though of course it is probably a good idea to have some checks to avoid breaking too many things because it could make bisecting other bugs more difficult.</source>
          <target state="translated">如果你们都有一个测试套件并使用 git bisect,那么在每次提交后检查所有测试是否通过就变得不那么重要了。当然,有一些检查以避免破坏太多东西可能是个好主意,因为这可能会使其他bug的双解更加困难。</target>
        </trans-unit>
        <trans-unit id="7c966eb4fc191c72371d7ddd65b21062f03ccb57" translate="yes" xml:space="preserve">
          <source>If you can do that, you can now recreate the missing object with</source>
          <target state="translated">如果你能做到这一点,你现在可以用</target>
        </trans-unit>
        <trans-unit id="5c6e6ccfdc26bd491d9ed428be6d535f807a44d7" translate="yes" xml:space="preserve">
          <source>If you choose to wait for the repack, don&amp;rsquo;t try to run benchmarks or performance tests until repacking is completed. fast-import outputs suboptimal packfiles that are simply never seen in real use situations.</source>
          <target state="translated">如果您选择等待重新打包，请在重新打包完成之前不要尝试运行基准测试或性能测试。快速导入输出的次优包文件在实际使用情况下根本看不到。</target>
        </trans-unit>
        <trans-unit id="db9a66177c2b117d0740a2ed1a511dcc1bea6811" translate="yes" xml:space="preserve">
          <source>If you decide that you&amp;rsquo;d rather see version 2.6.17, you can modify the current branch to point at v2.6.17 instead, with</source>
          <target state="translated">如果您决定查看版本2.6.17，则可以修改当前分支以指向v2.6.17，</target>
        </trans-unit>
        <trans-unit id="c943de9e92fabf055b174eed9b10ced62cf6d401" translate="yes" xml:space="preserve">
          <source>If you decide you want the history back, you can always create a new reference pointing to it, for example, a new branch:</source>
          <target state="translated">如果你决定要回历史,你可以随时创建一个新的引用,例如,一个新的分支。</target>
        </trans-unit>
        <trans-unit id="1f288af5e76ef5a4f231f5810c9960b284e03991" translate="yes" xml:space="preserve">
          <source>If you develop on a branch crazy-idea, then regret it, you can always delete the branch with</source>
          <target state="translated">如果你在一个疯狂想法的分支上开发,然后后悔了,你可以随时用以下方法删除这个分支</target>
        </trans-unit>
        <trans-unit id="6d7822c644d713e2101d339a30a68a502f988e1b" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t specify the CVSROOT/CVS_SERVER directly in the checkout command, automatically saving it in your &lt;code&gt;CVS/Root&lt;/code&gt; files, then you need to set them explicitly in your environment. CVSROOT should be set as per normal, but the directory should point at the appropriate Git repo. As above, for SSH clients &lt;code&gt;not&lt;/code&gt; restricted to &lt;code&gt;git-shell&lt;/code&gt;, CVS_SERVER should be set to &lt;code&gt;git-cvsserver&lt;/code&gt;.</source>
          <target state="translated">如果您没有在checkout命令中直接指定CVSROOT / CVS_SERVER，而是将其自动保存在 &lt;code&gt;CVS/Root&lt;/code&gt; 文件中，则需要在您的环境中显式设置它们。应该按照常规设置CVSROOT，但是目录应指向相应的Git存储库。如上所述，SSH客户端 &lt;code&gt;not&lt;/code&gt; 局限于 &lt;code&gt;git-shell&lt;/code&gt; ，CVS_SERVER应设置为 &lt;code&gt;git-cvsserver&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="467e5efa7fe7a25688df5c19177b2c4b9a971487" translate="yes" xml:space="preserve">
          <source>If you discover that you made a mistake in specifying the status of a revision, you can save the output of this command to a file, edit it to remove the incorrect entries, and then issue the following commands to return to a corrected state:</source>
          <target state="translated">如果你发现你在指定修订版状态时犯了错误,你可以将这个命令的输出保存到一个文件中,编辑它以删除错误的条目,然后再发出以下命令以返回到一个正确的状态。</target>
        </trans-unit>
        <trans-unit id="fdb535b3114700ba9158b47e1cadbbb4ffee0391" translate="yes" xml:space="preserve">
          <source>If you do merge, note the following rule: &lt;code&gt;git svn dcommit&lt;/code&gt; will attempt to commit on top of the SVN commit named in</source>
          <target state="translated">如果合并，请注意以下规则： &lt;code&gt;git svn dcommit&lt;/code&gt; 将尝试在命名为的SVN提交之上进行提交</target>
        </trans-unit>
        <trans-unit id="d7d53a76c809507d4642710878a2561fe720cf02" translate="yes" xml:space="preserve">
          <source>If you do not have &lt;code&gt;mod_rewrite&lt;/code&gt; available to match against the query string, it is sufficient to just protect &lt;code&gt;git-receive-pack&lt;/code&gt; itself, like:</source>
          <target state="translated">如果您没有可用于与查询字符串匹配的 &lt;code&gt;mod_rewrite&lt;/code&gt; ，仅保护 &lt;code&gt;git-receive-pack&lt;/code&gt; 本身就足够了，例如：</target>
        </trans-unit>
        <trans-unit id="61817ad83cf40051c64b68562493dd77ca2fe6f8" translate="yes" xml:space="preserve">
          <source>If you do not have this configuration variable, the value of &lt;code&gt;i18n.commitEncoding&lt;/code&gt; is used instead.</source>
          <target state="translated">如果没有此配置变量，则使用 &lt;code&gt;i18n.commitEncoding&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="14f3fbb24beba0c7fa85b6385a5b3979968f4593" translate="yes" xml:space="preserve">
          <source>If you do not know the encoding of a file, then you can use the &lt;code&gt;file&lt;/code&gt; command to guess the encoding:</source>
          <target state="translated">如果您不知道文件的编码，则可以使用 &lt;code&gt;file&lt;/code&gt; 命令猜测编码：</target>
        </trans-unit>
        <trans-unit id="371074e4db6e9a2527bbe63c09ef576231a57ee5" translate="yes" xml:space="preserve">
          <source>If you do not want this feature on your server just remove the second rewrite rule.</source>
          <target state="translated">如果你不想在你的服务器上使用这个功能,只需要删除第二个重写规则。</target>
        </trans-unit>
        <trans-unit id="b68a865397b0b847cde7a3d94bca4e3b8a2b1c61" translate="yes" xml:space="preserve">
          <source>If you do not want to lose your work (history from X to B) or the work by the other person (history from X to A), you would need to first fetch the history from the repository, create a history that contains changes done by both parties, and push the result back.</source>
          <target state="translated">如果不想丢失自己的工作(从X到B的历史)或对方的工作(从X到A的历史),就需要先从版本库中获取历史,创建一个包含双方所做修改的历史,并将结果推送回来。</target>
        </trans-unit>
        <trans-unit id="86c596eda084e162303624098fd515841984d889" translate="yes" xml:space="preserve">
          <source>If you do this, then you should make a public announcement indicating that &lt;code&gt;next&lt;/code&gt; was rewound and rebuilt.</source>
          <target state="translated">如果执行此操作，则应该发布公共公告，指示 &lt;code&gt;next&lt;/code&gt; 已倒带并已重建。</target>
        </trans-unit>
        <trans-unit id="325a3c2222e4d4aaa5c937ccab45f34c95352c49" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to continue with that right away, a few other digressions that may be interesting at this point are:</source>
          <target state="translated">如果您不想立即继续进行此操作，那么此时可能需要注意的其他一些问题是：</target>
        </trans-unit>
        <trans-unit id="bf36326b8dfc35954574299040bce7c304964cb4" translate="yes" xml:space="preserve">
          <source>If you enable PATH_INFO usage in gitweb by putting</source>
          <target state="translated">如果您在gitweb中通过将</target>
        </trans-unit>
        <trans-unit id="3e267e16654424679545d579a56c2fc25a567700" translate="yes" xml:space="preserve">
          <source>If you examine the file &lt;code&gt;.git/config&lt;/code&gt;, you will see that Git has added a new stanza:</source>
          <target state="translated">如果检查文件 &lt;code&gt;.git/config&lt;/code&gt; ，您将看到Git添加了一个新的节：</target>
        </trans-unit>
        <trans-unit id="adaf459f23d870ce117760016108b7b8ca67ba63" translate="yes" xml:space="preserve">
          <source>If you examine the resulting commit using gitk, you will see that it has two parents, one pointing to the top of the current branch, and one to the top of the other branch.</source>
          <target state="translated">如果你用 gitk 检查结果,你会发现它有两个父分支,一个指向当前分支的顶部,一个指向另一个分支的顶部。</target>
        </trans-unit>
        <trans-unit id="f87315138be947ec0afa0ac1351920e4dfe2a0c2" translate="yes" xml:space="preserve">
          <source>If you find some reason to set this option to &lt;code&gt;false&lt;/code&gt;, other than one-off testing, you should report the behavior difference as a bug in Git (see &lt;a href=&quot;https://git-scm.com/community&quot;&gt;https://git-scm.com/community&lt;/a&gt; for details).</source>
          <target state="translated">如果您发现某个原因将此选项设置为 &lt;code&gt;false&lt;/code&gt; ，而不是一次性测试，则应将行为差异报告为Git中的错误（有关详细信息，请参见&lt;a href=&quot;https://git-scm.com/community&quot;&gt;https://git-scm.com/community&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bbcb62743d9f0aa650833d05c94c3e3db4eb4e0d" translate="yes" xml:space="preserve">
          <source>If you find you forked off the wrong branch and want to move it &quot;back in time&quot;, use &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">如果发现分支错误，并希望将其&amp;ldquo;移回&amp;rdquo;时间，请使用&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12cef549aa55079a651285c652b78bc4bc8af80c" translate="yes" xml:space="preserve">
          <source>If you find you need new features from the branch &lt;code&gt;other&lt;/code&gt; to continue working on your topic, merge &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;topic&lt;/code&gt;. (However, do not do this &quot;just habitually&quot;, see below.)</source>
          <target state="translated">如果发现需要 &lt;code&gt;other&lt;/code&gt; 分支的新功能才能继续处理您的主题，请将 &lt;code&gt;other&lt;/code&gt; 合并到 &lt;code&gt;topic&lt;/code&gt; 。（但是，请不要&amp;ldquo;习惯性地&amp;rdquo;执行此操作，请参见下文。）</target>
        </trans-unit>
        <trans-unit id="c89cdceb268014744fee40998409a87331a70cef" translate="yes" xml:space="preserve">
          <source>If you followed the last paragraph, you will now have many small topic branches, and occasionally wonder how they interact. Perhaps the result of merging them does not even work? But on the other hand, we want to avoid merging them anywhere &quot;stable&quot; because such merges cannot easily be undone.</source>
          <target state="translated">如果你按照上一段的说法,你现在会有很多小的主题分支,偶尔会想知道它们是如何互动的。也许合并它们的结果根本不起作用?但另一方面,我们要避免将它们合并到任何 &quot;稳定 &quot;的地方,因为这种合并不容易撤销。</target>
        </trans-unit>
        <trans-unit id="f8ccc691fa447494e794dd8643eee96c05ab0ca5" translate="yes" xml:space="preserve">
          <source>If you get stuck and decide to just give up and throw the whole mess away, you can always return to the pre-merge state with</source>
          <target state="translated">如果你被卡住了,决定放弃并把整个烂摊子扔掉,你可以随时用以下方法回到合并前的状态</target>
        </trans-unit>
        <trans-unit id="8d7c02e3dd22e344be3301eb8a2278c07f5b614c" translate="yes" xml:space="preserve">
          <source>If you grasp the ideas in that initial commit, you should check out a more recent version and skim &lt;code&gt;cache.h&lt;/code&gt;, &lt;code&gt;object.h&lt;/code&gt; and &lt;code&gt;commit.h&lt;/code&gt;.</source>
          <target state="translated">如果您在最初的提交中掌握了这些想法，则应该签出较新的版本并 &lt;code&gt;cache.h&lt;/code&gt; ， &lt;code&gt;object.h&lt;/code&gt; 和 &lt;code&gt;commit.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b91c4875b14e285ca788a5bd5edf75dfcd9633ab" translate="yes" xml:space="preserve">
          <source>If you have a clone of git.git itself, the output of &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; can show you the authors for specific parts of the project.</source>
          <target state="translated">如果您本身具有git.git的克隆，则&lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt;和&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]的输出&lt;/a&gt;可以向您显示项目特定部分的作者。</target>
        </trans-unit>
        <trans-unit id="d76da65add1ab668fa52a438912f17a42719fc64" translate="yes" xml:space="preserve">
          <source>If you have a repository where all the branches of interest exist as subdirectories of a single depot path, you can use &lt;code&gt;--detect-branches&lt;/code&gt; when cloning or syncing to have &lt;code&gt;git p4&lt;/code&gt; automatically find subdirectories in p4, and to generate these as branches in Git.</source>
          <target state="translated">如果您有一个存储库，其中所有感兴趣的分支都作为单个软件仓库路径的子目录存在，则可以在克隆或同步时使用 &lt;code&gt;--detect-branches&lt;/code&gt; 以使 &lt;code&gt;git p4&lt;/code&gt; 在p4中自动找到子目录，并在Git中将其生成为分支。</target>
        </trans-unit>
        <trans-unit id="0a6081c46922db10b6bc6f47a7f76b221a6196d2" translate="yes" xml:space="preserve">
          <source>If you have a script that can tell if the current source code is good or bad, you can bisect by issuing the command:</source>
          <target state="translated">如果你有一个脚本,可以判断当前的源代码是好是坏,你可以通过发出命令来进行二分。</target>
        </trans-unit>
        <trans-unit id="863f4e57810f45268a83fecc8614e1be7d434564" translate="yes" xml:space="preserve">
          <source>If you have added attributes to a file that cause the canonical repository format for that file to change, such as adding a clean/smudge filter or text/eol/ident attributes, merging anything where the attribute is not in place would normally cause merge conflicts.</source>
          <target state="translated">如果你给一个文件添加了属性,导致该文件的规范仓库格式发生变化,比如添加了clean/mudge过滤器或text/eol/ident属性,合并任何属性不到位的地方通常会导致合并冲突。</target>
        </trans-unit>
        <trans-unit id="0176ab2e378e3df6f1e24b7af5113bcd1e2d5987" translate="yes" xml:space="preserve">
          <source>If you have an old Git that does not understand the version 2 &lt;code&gt;*.idx&lt;/code&gt; file, cloning or fetching over a non native protocol (e.g. &quot;http&quot;) that will copy both &lt;code&gt;*.pack&lt;/code&gt; file and corresponding &lt;code&gt;*.idx&lt;/code&gt; file from the other side may give you a repository that cannot be accessed with your older version of Git. If the &lt;code&gt;*.pack&lt;/code&gt; file is smaller than 2 GB, however, you can use &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack[1]&lt;/a&gt; on the *.pack file to regenerate the &lt;code&gt;*.idx&lt;/code&gt; file.</source>
          <target state="translated">如果您的旧Git无法理解版本2 &lt;code&gt;*.idx&lt;/code&gt; 文件，请通过非本地协议（例如&amp;ldquo; http&amp;rdquo;）进行克隆或获取，该协议将从另一端复制 &lt;code&gt;*.pack&lt;/code&gt; 文件和相应的 &lt;code&gt;*.idx&lt;/code&gt; 文件可能会为您提供一个旧版本Git无法访问的存储库。但是，如果 &lt;code&gt;*.pack&lt;/code&gt; 文件小于2 GB，则可以在* .pack文件上使用&lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack [1]&lt;/a&gt;重新生成 &lt;code&gt;*.idx&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="1c4d7bfb0f77357b6cf0e14e83f75e3ad3892e2a" translate="yes" xml:space="preserve">
          <source>If you have an unfortunate branch that is named &lt;code&gt;hello.c&lt;/code&gt;, this step would be confused as an instruction to switch to that branch. You should instead write:</source>
          <target state="translated">如果您有一个不幸的分支，名为 &lt;code&gt;hello.c&lt;/code&gt; ，则此步骤会被混淆为切换到该分支的指令。您应该改写：</target>
        </trans-unit>
        <trans-unit id="6748330dc78a7c7da8f6ed8d92c497a5f2638cdd" translate="yes" xml:space="preserve">
          <source>If you have imported some changes from another VCS and would like to add tags for major releases of your work, it is useful to be able to specify the date to embed inside of the tag object; such data in the tag object affects, for example, the ordering of tags in the gitweb interface.</source>
          <target state="translated">如果您从另一个 VCS 导入了一些变更,并且想为您的作品的主要版本添加标签,那么能够指定要嵌入到标签对象中的日期是很有用的;例如,标签对象中的这些数据会影响 gitweb 界面中标签的排序。</target>
        </trans-unit>
        <trans-unit id="d87d691ee6c65f8321e66034d85f79793605b8a9" translate="yes" xml:space="preserve">
          <source>If you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">如果您对一个或多个文件进行了本地修改,而这些修改在当前分支和您要切换的分支之间是不同的,那么为了在上下文中保留您的修改,该命令将拒绝切换分支。但是,如果使用这个选项,当前分支、工作树内容和新分支之间的三方合并就会完成,你将在新分支上。</target>
        </trans-unit>
        <trans-unit id="8478bf298413f91bee793cf9d5101299eaa200bd" translate="yes" xml:space="preserve">
          <source>If you have multifactor authentication setup on your gmail account, you will need to generate an app-specific password for use with &lt;code&gt;git send-email&lt;/code&gt;. Visit &lt;a href=&quot;https://security.google.com/settings/security/apppasswords&quot;&gt;https://security.google.com/settings/security/apppasswords&lt;/a&gt; to create it.</source>
          <target state="translated">如果您在gmail帐户上设置了多因素身份验证设置，则需要生成与 &lt;code&gt;git send-email&lt;/code&gt; 结合使用的应用专用密码。访问&lt;a href=&quot;https://security.google.com/settings/security/apppasswords&quot;&gt;https://security.google.com/settings/security/apppasswords&lt;/a&gt;进行创建。</target>
        </trans-unit>
        <trans-unit id="a8709177c278b5c18333d173ba933d08e65c6841" translate="yes" xml:space="preserve">
          <source>If you have some initial content (say, a tarball):</source>
          <target state="translated">如果你有一些初始内容(比如,一个焦油球)。</target>
        </trans-unit>
        <trans-unit id="495e5ec3bcea1de47c24c2073588d5c3b0cf061c" translate="yes" xml:space="preserve">
          <source>If you have these three &lt;code&gt;gitattributes&lt;/code&gt; file:</source>
          <target state="translated">如果您具有以下三个 &lt;code&gt;gitattributes&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="8c8ea948fec03c8051df6ee29e66dada48224b15" translate="yes" xml:space="preserve">
          <source>If you have uncommitted changes in your submodule working tree, &lt;code&gt;git
submodule update&lt;/code&gt; will not overwrite them. Instead, you get the usual warning about not being able switch from a dirty branch.</source>
          <target state="translated">如果您在子模块工作树中有未提交的更改，则 &lt;code&gt;git submodule update&lt;/code&gt; 不会覆盖它们。相反，您会收到有关无法从脏分支切换的常见警告。</target>
        </trans-unit>
        <trans-unit id="4ccda3cb1e710a989feb173887174c1818fd9d4a" translate="yes" xml:space="preserve">
          <source>If you intend that your next commit should record all modifications of tracked files in the working tree and record all removals of files that have been removed from the working tree with &lt;code&gt;rm&lt;/code&gt; (as opposed to &lt;code&gt;git rm&lt;/code&gt;), use &lt;code&gt;git commit -a&lt;/code&gt;, as it will automatically notice and record all removals. You can also have a similar effect without committing by using &lt;code&gt;git add -u&lt;/code&gt;.</source>
          <target state="translated">如果您打算下一次提交应在工作树中记录对跟踪文件的所有修改，并记录所有使用 &lt;code&gt;rm&lt;/code&gt; （而不是 &lt;code&gt;git rm&lt;/code&gt; ）从工作树中删除的文件的删除，请使用 &lt;code&gt;git commit -a&lt;/code&gt; ，因为将自动通知并记录所有清除情况。您也可以通过使用 &lt;code&gt;git add -u&lt;/code&gt; 来实现类似的效果而无需提交。</target>
        </trans-unit>
        <trans-unit id="5223949abb561108f8606da60ebd3c3b78a9872c" translate="yes" xml:space="preserve">
          <source>If you intend to set up a shared public repository that all developers can read/write, or if you want to use &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;, then you probably want to make a bare clone of the imported repository, and use the clone as the shared repository. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">如果打算建立一个所有开发人员都可以读取/写入的共享公共存储库，或者要使用&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;，则可能要对导入的存储库进行裸克隆，并使用克隆作为共享存储库。参见&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e8fe75eb0be8caf3b1c84cce78f8d98c5c3831c" translate="yes" xml:space="preserve">
          <source>If you just have a few changes, the simplest way to submit them may just be to send them as patches in email:</source>
          <target state="translated">如果你只是有一些改动,最简单的提交方式可能只是将它们作为补丁以电子邮件的形式发送。</target>
        </trans-unit>
        <trans-unit id="c3509063d9c8d28fc350d64af9974d7f7ad07d9f" translate="yes" xml:space="preserve">
          <source>If you just need to use Git as a revision control system you may prefer to start with &quot;A Tutorial Introduction to Git&quot; (&lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt;) or &lt;a href=&quot;user-manual&quot;&gt;the Git User Manual&lt;/a&gt;.</source>
          <target state="translated">如果只需要将Git用作版本控制系统，则可能更喜欢从&amp;ldquo; Git教程简介&amp;rdquo;（&lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt;）或&lt;a href=&quot;user-manual&quot;&gt;Git用户手册开始&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a839fbf210e306e2136c31f2a968baa357075d1" translate="yes" xml:space="preserve">
          <source>If you just want to edit the commit message for a commit, replace the command &quot;pick&quot; with the command &quot;reword&quot;.</source>
          <target state="translated">如果你只是想编辑一个提交的提交信息,用 &quot;reword &quot;命令代替 &quot;pick &quot;命令。</target>
        </trans-unit>
        <trans-unit id="1a22bf44debddb2b1654740b48fdcb88c27e49eb" translate="yes" xml:space="preserve">
          <source>If you just want to get the newest copies of the integration branches, staying up to date is easy too:</source>
          <target state="translated">如果你只是想获得最新的集成分支副本,保持更新也很容易。</target>
        </trans-unit>
        <trans-unit id="5a13a90084d33cb33125eb2c50fff6e07ce8c0d9" translate="yes" xml:space="preserve">
          <source>If you just want to look at an old version of the file, without modifying the working directory, you can do that with &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;:</source>
          <target state="translated">如果您只想查看文件的旧版本，而不修改工作目录，则可以使用&lt;a href=&quot;git-show&quot;&gt;git-show [1]来完成&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="5af7e34f55f5a635b889f9cb9a1ef742b6e402c4" translate="yes" xml:space="preserve">
          <source>If you just want to run git as if it was started in &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; then use &lt;code&gt;git -C &amp;lt;path&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f30cb563d71e3909ec492d5d34c92facf1030b" translate="yes" xml:space="preserve">
          <source>If you just want to verify whether a given tagged version contains a given commit, you could use &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt;:</source>
          <target state="translated">如果只想验证给定的标记版本是否包含给定的提交，则可以使用&lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d8a6261ebe4a4d52d4d9a2234a54f319605d4abc" translate="yes" xml:space="preserve">
          <source>If you keep your primary branches immediately under &lt;code&gt;refs/heads&lt;/code&gt;, and topic branches in subdirectories of it, having the following in the configuration file may help:</source>
          <target state="translated">如果将主分支紧紧放在 &lt;code&gt;refs/heads&lt;/code&gt; 下，并将主题分支保留在子目录下，则在配置文件中包含以下内容可能会有所帮助：</target>
        </trans-unit>
        <trans-unit id="933889a0268ded50e3304543b4e7167783337a6d" translate="yes" xml:space="preserve">
          <source>If you know beforehand more than one good commit, you can narrow the bisect space down by specifying all of the good commits immediately after the bad commit when issuing the &lt;code&gt;bisect start&lt;/code&gt; command:</source>
          <target state="translated">如果您事先知道一个以上的良好提交，则可以通过在发出 &lt;code&gt;bisect start&lt;/code&gt; 命令时在错误提交之后立即指定所有良好提交来缩小bisect空间：</target>
        </trans-unit>
        <trans-unit id="0d0efb22e26170e5f6a2a2c939fcf419b948a8aa" translate="yes" xml:space="preserve">
          <source>If you know up to what commit the intended recipient repository should have the necessary objects, you can use that knowledge to specify the basis, giving a cut-off point to limit the revisions and objects that go in the resulting bundle. The previous example used the lastR2bundle tag for this purpose, but you can use any other options that you would give to the &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; command. Here are more examples:</source>
          <target state="translated">如果您知道预定的收件人存储库应具有必要的对象的提交内容，则可以使用该知识来指定基础，并给出一个切入点来限制修订和对象组合中的对象。前面的示例为此目的使用了lastR2bundle标记，但是您可以使用提供给&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;命令的任何其他选项。这里有更多示例：</target>
        </trans-unit>
        <trans-unit id="6178dcf6380091f437345048b81ae6acd9e3fdb2" translate="yes" xml:space="preserve">
          <source>If you leave out the commit name, &lt;code&gt;git grep&lt;/code&gt; will search any of the files it manages in your current directory. So</source>
          <target state="translated">如果你离开了提交姓名， &lt;code&gt;git grep&lt;/code&gt; 将搜索任何它所管理的文件，在当前目录。所以</target>
        </trans-unit>
        <trans-unit id="1d3a773743dd2af35a158be46f7bad29aaa6f592" translate="yes" xml:space="preserve">
          <source>If you like to live dangerously, you can replace &lt;strong&gt;all&lt;/strong&gt; core.gitproxy by a new one with</source>
          <target state="translated">如果你喜欢惊险的生活，你可以取代&lt;strong&gt;所有&lt;/strong&gt;通过一个新的使用core.gitproxy</target>
        </trans-unit>
        <trans-unit id="9bff9b22c3bcd9cedd5449471391b1cdf79647bb" translate="yes" xml:space="preserve">
          <source>If you make a commit and then find a mistake immediately after that, you can recover from it with &lt;code&gt;git reset&lt;/code&gt;.</source>
          <target state="translated">如果您提交了一个提交，然后立即发现错误，则可以使用 &lt;code&gt;git reset&lt;/code&gt; 从中恢复。</target>
        </trans-unit>
        <trans-unit id="de1cbbe8d26471b895b54a3d07b205ed1595e0f4" translate="yes" xml:space="preserve">
          <source>If you make a commit that you later wish you hadn&amp;rsquo;t, there are two fundamentally different ways to fix the problem:</source>
          <target state="translated">如果您提交了以后不希望的提交，则有两种根本不同的方法可以解决此问题：</target>
        </trans-unit>
        <trans-unit id="99ec09f13fb1346102b0f372f091bd234e630539" translate="yes" xml:space="preserve">
          <source>If you make it (very) clear that this branch is going to be deleted right after the testing, you can even publish this branch, for example to give the testers a chance to work with it, or other developers a chance to see if their in-progress work will be compatible. &lt;code&gt;git.git&lt;/code&gt; has such an official throw-away integration branch called &lt;code&gt;pu&lt;/code&gt;.</source>
          <target state="translated">如果您（非常）清楚地表明该分支将在测试后立即删除，则您甚至可以发布此分支，例如，给测试人员一个使用它的机会，或者让其他开发人员一个机会查看他们是否正在进行的工作将是兼容的。 &lt;code&gt;git.git&lt;/code&gt; 有这样一个正式的一次性集成分支 &lt;code&gt;pu&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2711d396bb29a520681068259bdc58e0b9b32fcb" translate="yes" xml:space="preserve">
          <source>If you make it (very) clear that this branch is going to be deleted right after the testing, you can even publish this branch, for example to give the testers a chance to work with it, or other developers a chance to see if their in-progress work will be compatible. &lt;code&gt;git.git&lt;/code&gt; has such an official throw-away integration branch called &lt;code&gt;seen&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d532db8eaaa16fed286ca601d3c879ce0db79d29" translate="yes" xml:space="preserve">
          <source>If you make the decision to start your new branch at some other point in the history than the current &lt;code&gt;HEAD&lt;/code&gt;, you can do so by just telling &lt;code&gt;git checkout&lt;/code&gt; what the base of the checkout would be. In other words, if you have an earlier tag or branch, you&amp;rsquo;d just do</source>
          <target state="translated">如果您决定在历史记录中不同于当前 &lt;code&gt;HEAD&lt;/code&gt; 的其他位置处开始新分支，则只需告诉 &lt;code&gt;git checkout&lt;/code&gt; 结帐的基础即可。换句话说，如果您有较早的标记或分支，则只需</target>
        </trans-unit>
        <trans-unit id="9f31f9c748a9e0ffbef8f11bc85a6ff4ec5b3e8d" translate="yes" xml:space="preserve">
          <source>If you make the decision to start your new branch at some other point in the history than the current &lt;code&gt;HEAD&lt;/code&gt;, you can do so by just telling &lt;code&gt;git switch&lt;/code&gt; what the base of the checkout would be. In other words, if you have an earlier tag or branch, you&amp;rsquo;d just do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef318d408cfc2262e9ecdfec6313bac5c50bc49a" translate="yes" xml:space="preserve">
          <source>If you manually move a linked working tree, you need to update the &lt;code&gt;gitdir&lt;/code&gt; file in the entry&amp;rsquo;s directory. For example, if a linked working tree is moved to &lt;code&gt;/newpath/test-next&lt;/code&gt; and its &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt;, then update &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; to reference &lt;code&gt;/newpath/test-next&lt;/code&gt; instead.</source>
          <target state="translated">如果您手动移动链接的工作树，则需要更新条目目录中的 &lt;code&gt;gitdir&lt;/code&gt; 文件。例如，如果链接的工作树移至 &lt;code&gt;/newpath/test-next&lt;/code&gt; 且其 &lt;code&gt;.git&lt;/code&gt; 文件指向 &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; ，则更新 &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; 改为引用 &lt;code&gt;/newpath/test-next&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0359d10c71e55182679347b30eaf723b449ffc8c" translate="yes" xml:space="preserve">
          <source>If you manually move a linked working tree, you need to update the &lt;code&gt;gitdir&lt;/code&gt; file in the entry&amp;rsquo;s directory. For example, if a linked working tree is moved to &lt;code&gt;/newpath/test-next&lt;/code&gt; and its &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt;, then update &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; to reference &lt;code&gt;/newpath/test-next&lt;/code&gt; instead. Better yet, run &lt;code&gt;git worktree repair&lt;/code&gt; to reestablish the connection automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb87bde3a880515ee52eb5a157ecf80cef103126" translate="yes" xml:space="preserve">
          <source>If you mistakenly drop or clear stash entries, they cannot be recovered through the normal safety mechanisms. However, you can try the following incantation to get a list of stash entries that are still in your repository, but not reachable any more:</source>
          <target state="translated">如果您错误地删除或清除了暂存条目,它们将无法通过正常的安全机制恢复。然而,你可以尝试以下的咒语来获取仍然在你的版本库中,但无法再获取的储藏条目列表。</target>
        </trans-unit>
        <trans-unit id="110b0b8058519e9efd87b798163b83180b4fd090" translate="yes" xml:space="preserve">
          <source>If you need to add &lt;code&gt;Acked-by&lt;/code&gt; lines to, say, the last 10 commits (none of which is a merge), use this command:</source>
          <target state="translated">如果您需要向最后10次提交中添加 &lt;code&gt;Acked-by&lt;/code&gt; 行（没有一个是合并），请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="a06310bf48a43d3f06d75e4fe748345a055d13a9" translate="yes" xml:space="preserve">
          <source>If you need to amend commits from deeper in your history, you can use &lt;a href=&quot;#interactive-rebase&quot;&gt;interactive rebase&amp;rsquo;s &lt;code&gt;edit&lt;/code&gt; instruction&lt;/a&gt;.</source>
          <target state="translated">如果您需要更深地修改历史记录，则可以使用&lt;a href=&quot;#interactive-rebase&quot;&gt;交互式变基的 &lt;code&gt;edit&lt;/code&gt; 指令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f26f13a2edb916f980bf0b233ef42611b499ae1c" translate="yes" xml:space="preserve">
          <source>If you need to make any further adjustments, do so now, and then add any newly modified content to the index. Finally, commit your changes with:</source>
          <target state="translated">如果你需要做任何进一步的调整,现在就做,然后将任何新修改的内容添加到索引中。最后,用以下方法提交你的修改。</target>
        </trans-unit>
        <trans-unit id="b7346c069533043ab7106064793cec780b496e9d" translate="yes" xml:space="preserve">
          <source>If you need to pass multiple options, separate them with a comma.</source>
          <target state="translated">如果您需要传递多个选项,请用逗号将它们分开。</target>
        </trans-unit>
        <trans-unit id="809b912a9ed5d5a0eab31e3007d95029a30a63c6" translate="yes" xml:space="preserve">
          <source>If you need to reorder or edit a number of commits in a branch, it may be easier to use &lt;code&gt;git rebase -i&lt;/code&gt;, which allows you to reorder and squash commits, as well as marking them for individual editing during the rebase. See &lt;a href=&quot;#interactive-rebase&quot;&gt;Using interactive rebases&lt;/a&gt; for details, and &lt;a href=&quot;#reordering-patch-series&quot;&gt;Reordering or selecting from a patch series&lt;/a&gt; for alternatives.</source>
          <target state="translated">如果您需要对分支中的多个提交进行重新排序或编辑，则使用 &lt;code&gt;git rebase -i&lt;/code&gt; 可能更容易，它允许您对提交进行重新排序和压缩，以及将它们标记为在重新设置期间进行单独编辑。有关详细信息，请参见&lt;a href=&quot;#interactive-rebase&quot;&gt;使用交互式基准库&lt;/a&gt;；有关替代方法，请参见&lt;a href=&quot;#reordering-patch-series&quot;&gt;重新排序或从补丁程序系列&lt;/a&gt;中选择。</target>
        </trans-unit>
        <trans-unit id="653cbb8173c66cbe6d9c641e8756d2055e0c1628" translate="yes" xml:space="preserve">
          <source>If you never pushed anything out, just re-tag it. Use &quot;-f&quot; to replace the old one. And you&amp;rsquo;re done.</source>
          <target state="translated">如果您从未推出任何东西，只需重新标记即可。使用&amp;ldquo; -f&amp;rdquo;代替旧的。这样就完成了。</target>
        </trans-unit>
        <trans-unit id="e0169e9e6701b28da91f9800a1f0eacd543a0e6b" translate="yes" xml:space="preserve">
          <source>If you now continue development as usual, and eventually merge &lt;code&gt;topic&lt;/code&gt; to &lt;code&gt;subsystem&lt;/code&gt;, the commits from &lt;code&gt;subsystem&lt;/code&gt; will remain duplicated forever:</source>
          <target state="translated">如果您现在照常继续开发，并最终将 &lt;code&gt;topic&lt;/code&gt; 合并到 &lt;code&gt;subsystem&lt;/code&gt; ，则来自 &lt;code&gt;subsystem&lt;/code&gt; 的提交将永远重复：</target>
        </trans-unit>
        <trans-unit id="d9ba20830393f58c8170e264c4d66d9dd0605070" translate="yes" xml:space="preserve">
          <source>If you now run</source>
          <target state="translated">如果你现在运行</target>
        </trans-unit>
        <trans-unit id="ee95c7e5ff1bbdc349787f30139d15eef70dff52" translate="yes" xml:space="preserve">
          <source>If you only want to remove the local checkout of a submodule from your work tree without committing the removal, use &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;&lt;code&gt;deinit&lt;/code&gt; instead. Also see &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for details on submodule removal.</source>
          <target state="translated">如果只想从工作树中删除子模块的本地签出而不提交删除，请改用&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1] &lt;/a&gt; &lt;code&gt;deinit&lt;/code&gt; 。另请参见&lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt;以获取有关子模块删除的详细信息。</target>
        </trans-unit>
        <trans-unit id="de4ecb2fda4e4a17fa4230cd7b06e657b6ab1e40" translate="yes" xml:space="preserve">
          <source>If you plan to publish this repository to be accessed over http, you should do &lt;code&gt;mv my-git.git/hooks/post-update.sample
my-git.git/hooks/post-update&lt;/code&gt; at this point. This makes sure that every time you push into this repository, &lt;code&gt;git update-server-info&lt;/code&gt; is run.</source>
          <target state="translated">如果计划发布此存储库以通过http进行访问，则此时应执行 &lt;code&gt;mv my-git.git/hooks/post-update.sample my-git.git/hooks/post-update&lt;/code&gt; 。这样可以确保每次您推送到该存储库时，都会运行 &lt;code&gt;git update-server-info&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dce58b5a972f1c023066ee29ac3c991fde1e2420" translate="yes" xml:space="preserve">
          <source>If you present all of your changes as a single patch (or commit), they may find that it is too much to digest all at once.</source>
          <target state="translated">如果你把所有的改动都以一个补丁(或提交)的形式呈现,他们可能会发现一次消化不了太多的内容。</target>
        </trans-unit>
        <trans-unit id="6e4131986cf58f7abe3d9d87945a8e4a59143945" translate="yes" xml:space="preserve">
          <source>If you present them with the entire history of your work, complete with mistakes, corrections, and dead ends, they may be overwhelmed.</source>
          <target state="translated">如果你向他们介绍你工作的全部历史,包括错误、更正和死胡同,他们可能会不知所措。</target>
        </trans-unit>
        <trans-unit id="21ee16e384bb8d43949dac71aebc6ab455b71a15" translate="yes" xml:space="preserve">
          <source>If you provide a &lt;code&gt;directory&lt;/code&gt;, the command is run inside it. If this directory does not exist, it will be created.</source>
          <target state="translated">如果提供 &lt;code&gt;directory&lt;/code&gt; ，则命令将在其中运行。如果此目录不存在，将创建它。</target>
        </trans-unit>
        <trans-unit id="e318df70fba90a3c817f7eb76621f705fc69949d" translate="yes" xml:space="preserve">
          <source>If you pushed your change to a branch whose name is different from the one you have locally, e.g.</source>
          <target state="translated">如果您将您的更改推送到与您在本地拥有的分支名称不同的分支,如</target>
        </trans-unit>
        <trans-unit id="f36c21fb05ddb2d8eeea70a503cb3c797b4a7baa" translate="yes" xml:space="preserve">
          <source>If you really don&amp;rsquo;t want to clone it, for whatever reasons, check the following points instead (in this order). This is a very destructive approach, so &lt;strong&gt;make a backup&lt;/strong&gt; or go back to cloning it. You have been warned.</source>
          <target state="translated">如果您确实不想克隆它，则无论出于何种原因，请（按此顺序）检查以下几点。这是一种非常具有破坏性的方法，因此请&lt;strong&gt;进行备份&lt;/strong&gt;或重新克隆它。你被警告了。</target>
        </trans-unit>
        <trans-unit id="3a0d5ef629f0a421a47e2200b4c6f6985f396b8e" translate="yes" xml:space="preserve">
          <source>If you really want to remove a submodule from the repository and commit that use &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt; instead. See &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for removal options.</source>
          <target state="translated">如果您确实要从存储库中删除一个子模块并使用&lt;a href=&quot;git-rm&quot;&gt;git-rm [1]&lt;/a&gt;进行提交。有关删除选项，请参见&lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5e65b5631472cf01bf2ff6d1fb37eb4b5d6b41d" translate="yes" xml:space="preserve">
          <source>If you really want to use &lt;code&gt;konqueror&lt;/code&gt;, then you can use something like the following:</source>
          <target state="translated">如果您确实想使用 &lt;code&gt;konqueror&lt;/code&gt; ，那么可以使用类似以下的内容：</target>
        </trans-unit>
        <trans-unit id="e3a8dad6f18366292640cec2d899866b39003a2b" translate="yes" xml:space="preserve">
          <source>If you receive such a patch series (as maintainer, or perhaps as a reader of the mailing list it was sent to), save the mails to files, create a new topic branch and use &lt;code&gt;git am&lt;/code&gt; to import the commits:</source>
          <target state="translated">如果您收到这样的补丁系列（作为维护者，或者作为其发送到的邮件列表的阅读者），请将邮件保存到文件中，创建一个新的主题分支，并使用 &lt;code&gt;git am&lt;/code&gt; 导入提交：</target>
        </trans-unit>
        <trans-unit id="8122cfb5e210d22279775f15b8524f8a454a6069" translate="yes" xml:space="preserve">
          <source>If you receive the SHA-1 name of a blob from one source, and its contents from another (possibly untrusted) source, you can still trust that those contents are correct as long as the SHA-1 name agrees. This is because the SHA-1 is designed so that it is infeasible to find different contents that produce the same hash.</source>
          <target state="translated">如果你从一个源头收到一个blob的SHA-1名称,而它的内容来自另一个(可能是不信任的)源头,只要SHA-1名称一致,你仍然可以相信这些内容是正确的。这是因为SHA-1的设计使得找到产生相同哈希值的不同内容是不可行的。</target>
        </trans-unit>
        <trans-unit id="72b668cfa18e4e3a824ca9d20a1fa4e3cde95d1f" translate="yes" xml:space="preserve">
          <source>If you recognize such corruption early you can easily fix it by setting the conversion type explicitly in .gitattributes. Right after committing you still have the original file in your work tree and this file is not yet corrupted. You can explicitly tell Git that this file is binary and Git will handle the file appropriately.</source>
          <target state="translated">如果你能及早发现这种损坏,你可以通过在.gitattributes中明确设置转换类型来轻松修复。在提交之后,你的工作树中仍然有原始文件,而这个文件还没有损坏。你可以明确地告诉Git这个文件是二进制的,Git会适当地处理这个文件。</target>
        </trans-unit>
        <trans-unit id="6d44148625d48b9905fb64fc2d01c214d013573d" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git branch&lt;/code&gt; at this point, you&amp;rsquo;ll see that Git has temporarily moved you in &quot;(no branch)&quot;. HEAD is now detached from any branch and points directly to a commit (with commit id 65934) that is reachable from &quot;master&quot; but not from v2.6.18. Compile and test it, and see whether it crashes. Assume it does crash. Then:</source>
          <target state="translated">如果此时运行 &lt;code&gt;git branch&lt;/code&gt; ，您将看到Git暂时将您移至&amp;ldquo;（无分支）&amp;rdquo;中。HEAD现在从任何分支中分离出来，并直接指向可从&amp;ldquo; master&amp;rdquo;而非v2.6.18访问的提交（提交ID为65934）。编译并测试它，看看它是否崩溃。假设它确实崩溃了。然后：</target>
        </trans-unit>
        <trans-unit id="e4f37857c4f0244dcc0891e65a70e27a5bbdffad" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; later, the remote-tracking branches for the named &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; will be updated.</source>
          <target state="translated">如果稍后运行 &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; ，则名为 &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; 的远程跟踪分支将被更新。</target>
        </trans-unit>
        <trans-unit id="086aebbf0140fb264a45c34927db290b089af7f6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git repack&lt;/code&gt; again at this point, it will say &quot;Nothing new to pack.&quot;. Once you continue your development and accumulate the changes, running &lt;code&gt;git repack&lt;/code&gt; again will create a new pack, that contains objects created since you packed your repository the last time. We recommend that you pack your project soon after the initial import (unless you are starting your project from scratch), and then run &lt;code&gt;git repack&lt;/code&gt; every once in a while, depending on how active your project is.</source>
          <target state="translated">如果此时再次运行 &lt;code&gt;git repack&lt;/code&gt; ，它将显示&amp;ldquo;没有新内容可打包&amp;rdquo;。一旦继续开发并累积更改，再次运行 &lt;code&gt;git repack&lt;/code&gt; 将创建一个新的包，其中包含自上次打包存储库以来创建的对象。我们建议您在首次导入后立即打包项目（除非您从头开始创建项目），然后 &lt;code&gt;git repack&lt;/code&gt; 运行git repack，这取决于项目的活跃程度。</target>
        </trans-unit>
        <trans-unit id="f6784580fd898de2457fa8e4a33fffee5347973c" translate="yes" xml:space="preserve">
          <source>If you simply want to have CRLF line endings in your working directory regardless of the repository you are working with, you can set the config variable &quot;core.autocrlf&quot; without using any attributes.</source>
          <target state="translated">如果你只是想在你的工作目录下有CRLF行结尾,而不管你使用的是什么版本库,你可以设置配置变量 &quot;core.autocrlf &quot;而不使用任何属性。</target>
        </trans-unit>
        <trans-unit id="7c25024f01247f9dfa8226991c206d71987ca030" translate="yes" xml:space="preserve">
          <source>If you suspect that any of these issues may apply to the repository you want to import, consider using cvs2git:</source>
          <target state="translated">如果你怀疑这些问题可能适用于你要导入的版本库,考虑使用 cvs2git。</target>
        </trans-unit>
        <trans-unit id="d4145f8caae501b7db828bb5aa5f527a21b88535" translate="yes" xml:space="preserve">
          <source>If you think you have found a git bug, you can start by exporting an anonymized stream of the whole repository:</source>
          <target state="translated">如果你认为你发现了一个git bug,你可以从导出整个版本库的匿名流开始。</target>
        </trans-unit>
        <trans-unit id="846aba2aee9d2174839c8e896f13afd75da487fc" translate="yes" xml:space="preserve">
          <source>If you tried a merge which resulted in complex conflicts and want to start over, you can recover with &lt;code&gt;git merge --abort&lt;/code&gt;.</source>
          <target state="translated">如果您尝试了导致复杂冲突的合并并且想要重新开始，则可以使用 &lt;code&gt;git merge --abort&lt;/code&gt; 恢复。</target>
        </trans-unit>
        <trans-unit id="0e65bb746f0318eba11b3455708b3d4c243b8cb3" translate="yes" xml:space="preserve">
          <source>If you tried a pull which resulted in complex conflicts and would want to start over, you can recover with &lt;code&gt;git reset&lt;/code&gt;.</source>
          <target state="translated">如果您尝试执行一次拉动操作而导致复杂的冲突并希望重新开始，则可以使用 &lt;code&gt;git reset&lt;/code&gt; 恢复。</target>
        </trans-unit>
        <trans-unit id="a4f4230d5ba7e1273c96751869d78c8666680eb6" translate="yes" xml:space="preserve">
          <source>If you try and cheat and try to make git-filter-branch only work on files modified in a commit, then two things happen</source>
          <target state="translated">如果你试着让git-filter-branch只对提交中修改过的文件起作用,那么会发生两件事</target>
        </trans-unit>
        <trans-unit id="8c2ff328d40e63aa92549620e7b30dc7bd79b356" translate="yes" xml:space="preserve">
          <source>If you use any of the options marked &quot;Turns off &lt;code&gt;apply&lt;/code&gt;&quot; above, &lt;code&gt;git apply&lt;/code&gt; reads and outputs the requested information without actually applying the patch. Give this flag after those flags to also apply the patch.</source>
          <target state="translated">如果您使用上面标记为&amp;ldquo;关闭 &lt;code&gt;apply&lt;/code&gt; &amp;rdquo;的任何选项，则 &lt;code&gt;git apply&lt;/code&gt; 会读取并输出请求的信息，而无需实际应用补丁。在这些标志之后加上此标志也可以应用补丁。</target>
        </trans-unit>
        <trans-unit id="9ac6e5a034fc806d1c17415da5d8566070ff7060" translate="yes" xml:space="preserve">
          <source>If you use the rewrite rules from the example you &lt;strong&gt;might&lt;/strong&gt; also need something like the following in your gitweb configuration file (&lt;code&gt;/etc/gitweb.conf&lt;/code&gt; following example):</source>
          <target state="translated">如果您使用示例中的重写规则，则在gitweb配置文件（以下示例为 &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; ）中&lt;strong&gt;可能&lt;/strong&gt;还需要以下内容：</target>
        </trans-unit>
        <trans-unit id="7b6c2f4a6c5d4d8aeea38b5e0c4e8e111c81122f" translate="yes" xml:space="preserve">
          <source>If you want a shared repository, you will need to make a bare clone of the imported directory, as described above. Then treat the imported directory as another development clone for purposes of merging incremental imports.</source>
          <target state="translated">如果你想要一个共享的仓库,你将需要如上所述,对导入的目录进行裸克隆。然后将导入的目录视为另一个开发克隆,以达到合并增量导入的目的。</target>
        </trans-unit>
        <trans-unit id="f7444f839f8aa37b3a95b6650647c55221c170f1" translate="yes" xml:space="preserve">
          <source>If you want command input to still be interpreted as usual by &lt;code&gt;git rev-parse&lt;/code&gt; before the output is shell quoted, see the &lt;code&gt;--sq&lt;/code&gt; option.</source>
          <target state="translated">如果您希望命令输入仍然被 &lt;code&gt;git rev-parse&lt;/code&gt; 解释为通常的，然后 &lt;code&gt;--sq&lt;/code&gt; 外壳引号括起来，请参阅--sq选项。</target>
        </trans-unit>
        <trans-unit id="54d050e248b6c4afcd2cdb81603440db07ba11e1" translate="yes" xml:space="preserve">
          <source>If you want to break the dependency of a repository cloned with &lt;code&gt;--shared&lt;/code&gt; on its source repository, you can simply run &lt;code&gt;git repack -a&lt;/code&gt; to copy all objects from the source repository into a pack in the cloned repository.</source>
          <target state="translated">如果要打破在源存储库上用 &lt;code&gt;--shared&lt;/code&gt; 克隆的存储库的依赖性，只需运行 &lt;code&gt;git repack -a&lt;/code&gt; 即可将源存储库中的所有对象复制到克隆存储库中的包中。</target>
        </trans-unit>
        <trans-unit id="175eedbbcb252ccb8b65afc8343c53ee6468a326" translate="yes" xml:space="preserve">
          <source>If you want to check out &lt;code&gt;all&lt;/code&gt; C source files out of the index, you can say</source>
          <target state="translated">如果要从索引中检出 &lt;code&gt;all&lt;/code&gt; C源文件，可以说</target>
        </trans-unit>
        <trans-unit id="e8498bad4ba6680850d835a14e8199fc54c7601f" translate="yes" xml:space="preserve">
          <source>If you want to delete an entry for a multivar (like core.gitproxy above), you have to provide a regex matching the value of exactly one line.</source>
          <target state="translated">如果你想删除一个多变量的条目(就像上面的core.gitproxy),你必须提供一个正好匹配一行值的regex。</target>
        </trans-unit>
        <trans-unit id="b6ce9e2807ee6d14a7a74a4824bf5e00e758331b" translate="yes" xml:space="preserve">
          <source>If you want to enable (or disable) this feature, it is easier to use the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) than using the &lt;code&gt;--fsmonitor&lt;/code&gt; option to &lt;code&gt;git update-index&lt;/code&gt; in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable in your &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; just once and have it affect all repositories you touch.</source>
          <target state="translated">如果要启用（或禁用）此功能，则使用 &lt;code&gt;core.fsmonitor&lt;/code&gt; 配置变量（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）比使用 &lt;code&gt;--fsmonitor&lt;/code&gt; 选项在每个存储库中 &lt;code&gt;git update-index&lt;/code&gt; 容易得多。您希望对使用的所有存储库都这样做，因为您只需在 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 一次配置变量，就可以影响您接触的所有存储库。</target>
        </trans-unit>
        <trans-unit id="fade353b5f9f7d0b204907810eaa983a2e094489" translate="yes" xml:space="preserve">
          <source>If you want to enable (or disable) this feature, it is easier to use the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) than using the &lt;code&gt;--untracked-cache&lt;/code&gt; option to &lt;code&gt;git update-index&lt;/code&gt; in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable to &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;) in your &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; just once and have it affect all repositories you touch.</source>
          <target state="translated">如果要启用（或禁用）此功能，则使用 &lt;code&gt;core.untrackedCache&lt;/code&gt; 配置变量（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）比使用 &lt;code&gt;--untracked-cache&lt;/code&gt; 选项在每个存储库中 &lt;code&gt;git update-index&lt;/code&gt; 容易，尤其是如果您想在使用的所有存储库中都这样做，因为您可以在 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 中将配置变量设置为 &lt;code&gt;true&lt;/code&gt; （或 &lt;code&gt;false&lt;/code&gt; ）一次，并使其影响您触摸的所有存储库。</target>
        </trans-unit>
        <trans-unit id="58323cdd8a68e6e1cc6d62c47524db6593349b87" translate="yes" xml:space="preserve">
          <source>If you want to ensure that text files that any contributor introduces to the repository have their line endings normalized, you can set the &lt;code&gt;text&lt;/code&gt; attribute to &quot;auto&quot; for &lt;code&gt;all&lt;/code&gt; files.</source>
          <target state="translated">如果要确保任何贡献者介绍到存储库的文本文件的行尾均已标准化，则可以将 &lt;code&gt;all&lt;/code&gt; 文件的 &lt;code&gt;text&lt;/code&gt; 属性设置为&amp;ldquo; auto&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="46aa6af5bcc60a63656632720781ded6cb9a0464" translate="yes" xml:space="preserve">
          <source>If you want to fold two or more commits into one, replace the command &quot;pick&quot; for the second and subsequent commits with &quot;squash&quot; or &quot;fixup&quot;. If the commits had different authors, the folded commit will be attributed to the author of the first commit. The suggested commit message for the folded commit is the concatenation of the commit messages of the first commit and of those with the &quot;squash&quot; command, but omits the commit messages of commits with the &quot;fixup&quot; command.</source>
          <target state="translated">如果您想将两个或多个提交合并为一个,请用 &quot;压扁 &quot;或 &quot;修正 &quot;命令替换第二个及后续提交的 &quot;pick &quot;命令。如果两个提交的作者不同,折叠后的提交将归属于第一个提交的作者。建议折叠后的提交信息是第一次提交和使用 &quot;压扁 &quot;命令的提交信息的合并,但省略使用 &quot;固定 &quot;命令的提交信息。</target>
        </trans-unit>
        <trans-unit id="a1fc176bf758306e3705a3dd88ad77db4fb55698" translate="yes" xml:space="preserve">
          <source>If you want to have one URL for both gitweb and your &lt;code&gt;http://&lt;/code&gt; repositories, you can configure Apache like this:</source>
          <target state="translated">如果您想为gitweb和您的 &lt;code&gt;http://&lt;/code&gt; 存储库同时使用一个URL ，则可以这样配置Apache：</target>
        </trans-unit>
        <trans-unit id="23a694ff61b56e5a1054639701ce379b6eeb6564" translate="yes" xml:space="preserve">
          <source>If you want to know all the values for a multivar, do:</source>
          <target state="translated">如果你想知道一个多变量的所有值,可以这样做。</target>
        </trans-unit>
        <trans-unit id="be838b052e83d8fa0d4980781547923358bc58d3" translate="yes" xml:space="preserve">
          <source>If you want to make a change within a submodule and you have a detached head, then you should create or checkout a branch, make your changes, publish the change within the submodule, and then update the superproject to reference the new commit:</source>
          <target state="translated">如果你想在一个子模块中进行修改,并且你有一个分离的头,那么你应该创建或签出一个分支,进行修改,在子模块中发布修改,然后更新超级项目来引用新的提交。</target>
        </trans-unit>
        <trans-unit id="f02c3e1c88ba7fbd299965b88348f8af1bb2eec2" translate="yes" xml:space="preserve">
          <source>If you want to make sure that the output actually names an object in your object database and/or can be used as a specific type of object you require, you can add the &lt;code&gt;^{type}&lt;/code&gt; peeling operator to the parameter. For example, &lt;code&gt;git rev-parse &quot;$VAR^{commit}&quot;&lt;/code&gt; will make sure &lt;code&gt;$VAR&lt;/code&gt; names an existing object that is a commit-ish (i.e. a commit, or an annotated tag that points at a commit). To make sure that &lt;code&gt;$VAR&lt;/code&gt; names an existing object of any type, &lt;code&gt;git rev-parse &quot;$VAR^{object}&quot;&lt;/code&gt; can be used.</source>
          <target state="translated">如果要确保输出实际上在对象数据库中命名了一个对象和/或可以用作所需的特定类型的对象，则可以在参数中添加 &lt;code&gt;^{type}&lt;/code&gt; 剥离操作符。例如， &lt;code&gt;git rev-parse &quot;$VAR^{commit}&quot;&lt;/code&gt; 将确保 &lt;code&gt;$VAR&lt;/code&gt; 命名一个已有提交的对象（即，提交或指向提交的带注释的标签）。为了确保 &lt;code&gt;$VAR&lt;/code&gt; 命名任何类型的现有对象，可以使用 &lt;code&gt;git rev-parse &quot;$VAR^{object}&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="136531f3c928e37ad60b2649b3285deac4e99b46" translate="yes" xml:space="preserve">
          <source>If you want to refer to a git refspec that has characters that are not allowed by CVS, you have two options. First, it may just work to supply the git refspec directly to the appropriate CVS -r argument; some CVS clients don&amp;rsquo;t seem to do much sanity checking of the argument. Second, if that fails, you can use a special character escape mechanism that only uses characters that are valid in CVS tags. A sequence of 4 or 5 characters of the form (underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;), dash (&lt;code&gt;&quot;-&quot;&lt;/code&gt;), one or two characters, and dash (&lt;code&gt;&quot;-&quot;&lt;/code&gt;)) can encode various characters based on the one or two letters: &lt;code&gt;&quot;s&quot;&lt;/code&gt; for slash (&lt;code&gt;&quot;/&quot;&lt;/code&gt;), &lt;code&gt;&quot;p&quot;&lt;/code&gt; for period (&lt;code&gt;&quot;.&quot;&lt;/code&gt;), &lt;code&gt;&quot;u&quot;&lt;/code&gt; for underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;), or two hexadecimal digits for any byte value at all (typically an ASCII number, or perhaps a part of a UTF-8 encoded character).</source>
          <target state="translated">如果要引用的git refspec具有CVS不允许的字符，则有两个选择。首先，将git refspec直接提供给适当的CVS -r参数可能会起作用；一些CVS客户似乎对参数的理智性检查不多。其次，如果失败，则可以使用特殊的字符转义机制，该机制仅使用CVS标签中有效的字符。一个4或5个字符的序列，其形式（下划线（ &lt;code&gt;&quot;_&quot;&lt;/code&gt; ），破折号（ &lt;code&gt;&quot;-&quot;&lt;/code&gt; ），一个或两个字符和破折号（ &lt;code&gt;&quot;-&quot;&lt;/code&gt; ））可以基于一个或两个字母对各种字符进行编码： &lt;code&gt;&quot;s&quot;&lt;/code&gt; 代表斜杠（ &lt;code&gt;&quot;/&quot;&lt;/code&gt; ）， &lt;code&gt;&quot;p&quot;&lt;/code&gt; 代表句点（ &lt;code&gt;&quot;.&quot;&lt;/code&gt; ）， &lt;code&gt;&quot;u&quot;&lt;/code&gt; 表示下划线（ &lt;code&gt;&quot;_&quot;&lt;/code&gt; ），或者任何字节值都等于两个十六进制数字（通常是ASCII数字，或者可能是UTF-8编码字符的一部分）。</target>
        </trans-unit>
        <trans-unit id="e8beaf63d7e0d62995b4c7a9252b3f2ea0574fab" translate="yes" xml:space="preserve">
          <source>If you want to replace many blobs, trees or commits that are part of a string of commits, you may just want to create a replacement string of commits and then only replace the commit at the tip of the target string of commits with the commit at the tip of the replacement string of commits.</source>
          <target state="translated">如果你想替换属于一个提交字符串的许多blobs、树或提交,你可能只想创建一个替换的提交字符串,然后只将目标提交字符串顶端的提交替换为替换的提交字符串顶端的提交。</target>
        </trans-unit>
        <trans-unit id="44f075cf045ec7b6bbf9c6b54de29b3e2085d2d6" translate="yes" xml:space="preserve">
          <source>If you want to restore &lt;code&gt;all&lt;/code&gt; C source files to match the version in the index, you can say</source>
          <target state="translated">如果要还原 &lt;code&gt;all&lt;/code&gt; C源文件以匹配索引中的版本，则可以说</target>
        </trans-unit>
        <trans-unit id="7bbbea69a50b6a93a6b75d0ba68d2bc45319d47b" translate="yes" xml:space="preserve">
          <source>If you want to rewrite URLs for push only, you can create a configuration section of the form:</source>
          <target state="translated">如果你想重写URL只用于推送,你可以在表单中创建一个配置部分。</target>
        </trans-unit>
        <trans-unit id="295a38729bbd2cc488fb271a44e4d101d6ee7a15" translate="yes" xml:space="preserve">
          <source>If you want to show differences between binary or specially-formatted blobs in your repository, you can choose to use either an external diff command, or to use textconv to convert them to a diff-able text format. Which method you choose depends on your exact situation.</source>
          <target state="translated">如果你想在你的版本库中显示二进制或特殊格式的blobs之间的差异,你可以选择使用外部的diff命令,或者使用textconv将它们转换为可差异的文本格式。选择哪种方法取决于你的具体情况。</target>
        </trans-unit>
        <trans-unit id="e3f3cfd8a6d2a1c0d741f6415c0be4ad8848457f" translate="yes" xml:space="preserve">
          <source>If you want to show other people your bisection process, you can get a log using for example:</source>
          <target state="translated">如果你想向其他人展示你的二分法过程,你可以使用例如得到一个日志。</target>
        </trans-unit>
        <trans-unit id="07b554efbcde38cd3d8cb2b2cd3fe1b74a5f9d9d" translate="yes" xml:space="preserve">
          <source>If you want to start a disconnected history that records a set of paths that is totally different from the one of &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;, then you should clear the index and the working tree right after creating the orphan branch by running &lt;code&gt;git rm -rf .&lt;/code&gt; from the top level of the working tree. Afterwards you will be ready to prepare your new files, repopulating the working tree, by copying them from elsewhere, extracting a tarball, etc.</source>
          <target state="translated">如果要启动一个断开的历史记录，该历史记录记录的路径集与 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 的路径完全不同，则应在创建孤儿分支后通过运行 &lt;code&gt;git rm -rf .&lt;/code&gt; 清除索引和工作树。从工作树的顶层开始。之后，您将准备好准备新文件，重新填充工作树，从其他位置复制它们，提取压缩包等。</target>
        </trans-unit>
        <trans-unit id="5dc24ba332edd3d8bebaa76b808aacd296106da2" translate="yes" xml:space="preserve">
          <source>If you want to start a new branch from a remote branch of the same name:</source>
          <target state="translated">如果你想从一个同名的远程分支开始一个新的分支。</target>
        </trans-unit>
        <trans-unit id="b533f775f69c9c29e40e15bb405c24bc01b04dac" translate="yes" xml:space="preserve">
          <source>If you want to use gitweb with several project roots you can edit your Apache virtual host and gitweb configuration files in the following way.</source>
          <target state="translated">如果你想在多个项目根使用gitweb,你可以通过以下方式编辑Apache虚拟主机和gitweb配置文件。</target>
        </trans-unit>
        <trans-unit id="cced0d77bb2b4a5861e7555078781fd81234d732" translate="yes" xml:space="preserve">
          <source>If you want to, you can use &lt;code&gt;git cat-file&lt;/code&gt; to look at those objects, but you&amp;rsquo;ll have to use the object name, not the filename of the object:</source>
          <target state="translated">如果愿意，可以使用 &lt;code&gt;git cat-file&lt;/code&gt; 查看这些对象，但必须使用对象名称，而不是对象的文件名：</target>
        </trans-unit>
        <trans-unit id="9eff57ed3284da22d90930841774b80f0270e4be" translate="yes" xml:space="preserve">
          <source>If you wish the exclude patterns to affect only certain repositories (instead of every repository for a given project), you may instead put them in a file in your repository named &lt;code&gt;.git/info/exclude&lt;/code&gt;, or in any file specified by the &lt;code&gt;core.excludesFile&lt;/code&gt; configuration variable. Some Git commands can also take exclude patterns directly on the command line. See &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for the details.</source>
          <target state="translated">如果希望排除模式仅影响某些存储库（而不是给定项目的每个存储库），则可以将它们放在存储库中名为 &lt;code&gt;.git/info/exclude&lt;/code&gt; 的文件中，或放置在 &lt;code&gt;core.excludesFile&lt;/code&gt; 指定的任何文件中。 excludesFile配置变量。一些Git命令还可以直接在命令行上采用排除模式。有关详细信息，请参见&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3a956a01313129dd0835296263e6883d7abec99" translate="yes" xml:space="preserve">
          <source>If you wish to affect only a single repository (i.e., to assign attributes to files that are particular to one user&amp;rsquo;s workflow for that repository), then attributes should be placed in the &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file. Attributes which should be version-controlled and distributed to other repositories (i.e., attributes of interest to all users) should go into &lt;code&gt;.gitattributes&lt;/code&gt; files. Attributes that should affect all repositories for a single user should be placed in a file specified by the &lt;code&gt;core.attributesFile&lt;/code&gt; configuration option (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Its default value is $XDG_CONFIG_HOME/git/attributes. If $XDG_CONFIG_HOME is either not set or empty, $HOME/.config/git/attributes is used instead. Attributes for all users on a system should be placed in the &lt;code&gt;$(prefix)/etc/gitattributes&lt;/code&gt; file.</source>
          <target state="translated">如果只希望影响单个存储库（即，为该存储库的一个用户工作流程特有的文件分配属性），则应将属性放在 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 文件中。应该由版本控制并分发到其他存储库的属性（即，所有用户都感兴趣的属性）应放入 &lt;code&gt;.gitattributes&lt;/code&gt; 文件中。应该影响单个用户所有存储库的属性应放置在 &lt;code&gt;core.attributesFile&lt;/code&gt; 配置选项指定的文件中（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。其默认值为$ XDG_CONFIG_HOME / git / attributes。如果$ XDG_CONFIG_HOME未设置或为空，则使用$ HOME / .config / git / attributes。系统上所有用户的属性都应放在 &lt;code&gt;$(prefix)/etc/gitattributes&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="8bef77486a59978a04a1c46b2c068b3863595296" translate="yes" xml:space="preserve">
          <source>If you work with other people, you will need commands listed in the &lt;a href=&quot;#PARTICIPANT&quot;&gt;Individual Developer (Participant)&lt;/a&gt; section as well.</source>
          <target state="translated">如果您与其他人一起工作，则还需要&amp;ldquo; &lt;a href=&quot;#PARTICIPANT&quot;&gt;个人开发人员（参与者）&amp;rdquo;&lt;/a&gt;部分中列出的命令。</target>
        </trans-unit>
        <trans-unit id="4cb8198fe4b8e422fe561ded3cf681f52266950f" translate="yes" xml:space="preserve">
          <source>If you would like the daemon to exit early, forgetting all cached credentials before their timeout, you can issue an &lt;code&gt;exit&lt;/code&gt; action:</source>
          <target state="translated">如果您希望守护程序提前退出，并在所有缓存的凭据超时之前忘记所有凭据，则可以执行 &lt;code&gt;exit&lt;/code&gt; 操作：</target>
        </trans-unit>
        <trans-unit id="6fb92003fb885c97541d201047e1ea900190bac9" translate="yes" xml:space="preserve">
          <source>If you would like to use your own terms instead of &quot;bad&quot;/&quot;good&quot; or &quot;new&quot;/&quot;old&quot;, you can choose any names you like (except existing bisect subcommands like &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt;, &amp;hellip;​) by starting the bisection using</source>
          <target state="translated">如果您想使用自己的术语而不是&amp;ldquo;坏&amp;rdquo; /&amp;ldquo;好&amp;rdquo;或&amp;ldquo;新&amp;rdquo; /&amp;ldquo;旧&amp;rdquo;，则可以通过启动以下命令来选择所需的任何名称（现有的bisect子命令除外，如 &lt;code&gt;reset&lt;/code&gt; ， &lt;code&gt;start&lt;/code&gt; ，&amp;hellip;）。二等分使用</target>
        </trans-unit>
        <trans-unit id="ac9785fae40224d0d9d1a9569429bd18f0ceb511" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re releasing a new version of a software project, you may want to simultaneously make a changelog to include in the release announcement.</source>
          <target state="translated">如果要发布软件项目的新版本，则可能需要同时进行更改日志以将其包含在发行公告中。</target>
        </trans-unit>
        <trans-unit id="6cd2cc907ee3e17f5caea471b5027cb72158e075" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve been committing small enough changes, you may now have a good shot at reconstructing the contents of the in-between state 4b9458b.</source>
          <target state="translated">如果您已进行了足够小的更改，则现在可以很好地重构中间状态4b9458b的内容。</target>
        </trans-unit>
        <trans-unit id="5516e4c9c575f8921939c0e95aa6e39fac3c93e0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve configured a web server that isn&amp;rsquo;t listed here for gitweb, please send in the instructions so they can be included in a future release.</source>
          <target state="translated">如果您为gitweb配置的Web服务器未在此处列出，请发送说明，以便将来的发行版中可以包含它们。</target>
        </trans-unit>
        <trans-unit id="2ca9c9b64a14bae5a21173833d4a0e06ad289f34" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve messed up the working tree, but haven&amp;rsquo;t yet committed your mistake, you can return the entire working tree to the last committed state with</source>
          <target state="translated">如果您弄乱了工作树，但尚未犯错，则可以使用以下命令将整个工作树返回到最后的提交状态：</target>
        </trans-unit>
        <trans-unit id="346e091fa815a370c1b9ad910c5cda575a1ee6ab" translate="yes" xml:space="preserve">
          <source>If your Gmail account is set to another language than English, the name of the &quot;Drafts&quot; folder will be localized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bdd278937e1b543d6e4ef46f26f74578bcd1798" translate="yes" xml:space="preserve">
          <source>If your branch was based on &amp;lt;upstream&amp;gt; but &amp;lt;upstream&amp;gt; was rewound and your branch contains commits which were dropped, this option can be used with &lt;code&gt;--keep-base&lt;/code&gt; in order to drop those commits from your branch.</source>
          <target state="translated">如果您的分支基于&amp;lt;upstream&amp;gt;，但已 &lt;code&gt;--keep-base&lt;/code&gt; &amp;lt;upstream&amp;gt;并且您的分支包含已删除的提交，则此选项可与--keep-base一起使用，以便从您的分支中删除这些提交。</target>
        </trans-unit>
        <trans-unit id="862f720d820aceb82a46583ae7c2b519ed5f9115" translate="yes" xml:space="preserve">
          <source>If your editor or some other system is running &lt;code&gt;git fetch&lt;/code&gt; in the background for you a way to mitigate this is to simply set up another remote:</source>
          <target state="translated">如果您的编辑器或其他系统在后台运行 &lt;code&gt;git fetch&lt;/code&gt; 来缓解这种情况，则可以简单地设置另一个远程方式：</target>
        </trans-unit>
        <trans-unit id="233e7aed3c7b3f81991c7f01f9bc6c69656e4a7c" translate="yes" xml:space="preserve">
          <source>If your repository contains one or more submodules, then submodules are populated based on interactions with the &lt;code&gt;git submodule&lt;/code&gt; command. Specifically, &lt;code&gt;git submodule init -- &amp;lt;path&amp;gt;&lt;/code&gt; will ensure the submodule at &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is present, while &lt;code&gt;git submodule deinit [-f] -- &amp;lt;path&amp;gt;&lt;/code&gt; will remove the files for the submodule at &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; (including any untracked files, uncommitted changes, and unpushed history). Similar to how sparse-checkout removes files from the working tree but still leaves entries in the index, deinitialized submodules are removed from the working directory but still have an entry in the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc3997d817725ac54010e2c723e5760c4e0b90b" translate="yes" xml:space="preserve">
          <source>If your repository contains one or more submodules, then those submodules will appear based on which you initialized with the &lt;code&gt;git submodule&lt;/code&gt; command. If your sparse-checkout patterns exclude an initialized submodule, then that submodule will still appear in your working directory.</source>
          <target state="translated">如果您的存储库包含一个或多个子模块，则这些子模块将根据您使用 &lt;code&gt;git submodule&lt;/code&gt; 命令进行初始化的方式显示。如果您的稀疏签出模式不包含已初始化的子模块，则该子模块仍将出现在您的工作目录中。</target>
        </trans-unit>
        <trans-unit id="17a3911595f90d594aeea889e0f0755079e1efba" translate="yes" xml:space="preserve">
          <source>If, in the middle of a bisect session, you know that the suggested revision is not a good one to test (e.g. it fails to build and you know that the failure does not have anything to do with the bug you are chasing), you can manually select a nearby commit and test that one instead.</source>
          <target state="translated">如果在一分为二的会话中,你知道建议的修订版不是一个好的测试版本 (例如,它不能构建,而且你知道这个失败与你正在追寻的 bug 没有任何关系),你可以手动选择一个附近的提交,然后测试那个版本。</target>
        </trans-unit>
        <trans-unit id="4eaf7ef623b220dfff5cf0aad12284c2791aab6b" translate="yes" xml:space="preserve">
          <source>Ignore carriage-return at the end of line when doing a comparison.</source>
          <target state="translated">在进行比较时,忽略行末的回车。</target>
        </trans-unit>
        <trans-unit id="14129ef50a9ff92ecf5a9d9520de0a5438b9b27c" translate="yes" xml:space="preserve">
          <source>Ignore case differences between the patterns and the files.</source>
          <target state="translated">忽略模式和文件之间的大小写差异。</target>
        </trans-unit>
        <trans-unit id="93adbe048de005f652abeded323ffca0e07802f9" translate="yes" xml:space="preserve">
          <source>Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.</source>
          <target state="translated">忽略空白字符数量的变化。这将忽略行末的空白字符,并将所有其他由一个或多个空白字符组成的序列视为相等。</target>
        </trans-unit>
        <trans-unit id="dceba3e490b99e465dabc6c0a6eb46378a762d2c" translate="yes" xml:space="preserve">
          <source>Ignore changes in whitespace at EOL.</source>
          <target state="translated">忽略EOL时whitespace的变化。</target>
        </trans-unit>
        <trans-unit id="0e8a5619a2125f597eccb060c4d8cfcacf8da768" translate="yes" xml:space="preserve">
          <source>Ignore changes made by the revision when assigning blame, as if the change never happened. Lines that were changed or added by an ignored commit will be blamed on the previous commit that changed that line or nearby lines. This option may be specified multiple times to ignore more than one revision. If the &lt;code&gt;blame.markIgnoredLines&lt;/code&gt; config option is set, then lines that were changed by an ignored commit and attributed to another commit will be marked with a &lt;code&gt;?&lt;/code&gt; in the blame output. If the &lt;code&gt;blame.markUnblamableLines&lt;/code&gt; config option is set, then those lines touched by an ignored commit that we could not attribute to another revision are marked with a &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">分配责任时，忽略修订版本所做的更改，就好像从未发生过更改一样。被忽略的提交更改或添加的行将归咎于更改该行或附近行的先前提交。可以多次指定此选项以忽略多个修订。如果设置了 &lt;code&gt;blame.markIgnoredLines&lt;/code&gt; 配置选项，则被忽略的提交更改并归属于另一个提交的行将标记为 &lt;code&gt;?&lt;/code&gt; 。在怪输出。如果设置了 &lt;code&gt;blame.markUnblamableLines&lt;/code&gt; config选项，那么那些我们无法归因于另一个修订版本的被忽略提交触及的行将用 &lt;code&gt;*&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="847c383f096e8b2857c23f7df697a300205d1cde" translate="yes" xml:space="preserve">
          <source>Ignore changes to submodules in the diff generation. &amp;lt;when&amp;gt; can be either &quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot; or &quot;all&quot;, which is the default. Using &quot;none&quot; will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the &lt;code&gt;ignore&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;. When &quot;untracked&quot; is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using &quot;dirty&quot; ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using &quot;all&quot; hides all changes to submodules.</source>
          <target state="translated">忽略diff生成中对子模块的更改。 &amp;lt;when&amp;gt;可以是&amp;ldquo; none&amp;rdquo;，&amp;ldquo; untracked&amp;rdquo;，&amp;ldquo; dirty&amp;rdquo;或&amp;ldquo; all&amp;rdquo;，这是默认值。使用&amp;ldquo;无&amp;rdquo;，将考虑修改的子模块时，它或者包含未跟踪或修改的文件或它的头的不同之处的提交记录在上层项目和可用于覆盖任何设置的 &lt;code&gt;ignore&lt;/code&gt; 在选项&lt;a href=&quot;git-config&quot;&gt;GIT-配置[1]&lt;/a&gt;或&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [ 5]&lt;/a&gt;。使用&amp;ldquo;未跟踪&amp;rdquo;时，子模块仅包含未跟踪的内容（但仍会对其进行扫描以查找修改的内容），因此不会被视为脏模块。使用&amp;ldquo;脏&amp;rdquo;会忽略对子模块工作树的所有更改，仅显示对存储在超级项目中的提交所做的更改（直到1.7.0为止都是这样）。使用&amp;ldquo;全部&amp;rdquo;将隐藏对子模块的所有更改。</target>
        </trans-unit>
        <trans-unit id="0a92f8e585ade182f513a5692eb0bb44a7e837dd" translate="yes" xml:space="preserve">
          <source>Ignore changes to submodules when looking for changes. &amp;lt;when&amp;gt; can be either &quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot; or &quot;all&quot;, which is the default. Using &quot;none&quot; will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the &lt;code&gt;ignore&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;. When &quot;untracked&quot; is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using &quot;dirty&quot; ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior before 1.7.0). Using &quot;all&quot; hides all changes to submodules (and suppresses the output of submodule summaries when the config option &lt;code&gt;status.submoduleSummary&lt;/code&gt; is set).</source>
          <target state="translated">查找更改时，请忽略对子模块的更改。 &amp;lt;when&amp;gt;可以是&amp;ldquo; none&amp;rdquo;，&amp;ldquo; untracked&amp;rdquo;，&amp;ldquo; dirty&amp;rdquo;或&amp;ldquo; all&amp;rdquo;，这是默认值。使用&amp;ldquo;无&amp;rdquo;，将考虑修改的子模块时，它或者包含未跟踪或修改的文件或它的头的不同之处的提交记录在上层项目和可用于覆盖任何设置的 &lt;code&gt;ignore&lt;/code&gt; 在选项&lt;a href=&quot;git-config&quot;&gt;GIT-配置[1]&lt;/a&gt;或&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [ 5]&lt;/a&gt;。当使用&amp;ldquo;未跟踪&amp;rdquo;时，子模块仅包含未跟踪的内容（但仍会对其进行扫描以查找修改的内容），因此不会被视为脏模块。使用&amp;ldquo; dirty&amp;rdquo;将忽略对子模块工作树的所有更改，仅显示对存储在超级项目中的提交的更改（这是1.7.0之前的行为）。使用&amp;ldquo;全部&amp;rdquo;将隐藏 &lt;code&gt;status.submoduleSummary&lt;/code&gt; 模块的所有更改（并在配置选项status.submoduleSummary设置后抑制子模块摘要的输出）。</target>
        </trans-unit>
        <trans-unit id="f616e5a6b317fb9674ab4a6ecd11655583864222" translate="yes" xml:space="preserve">
          <source>Ignore changes whose lines are all blank.</source>
          <target state="translated">忽略行均为空白的变化。</target>
        </trans-unit>
        <trans-unit id="6b93913a06aa23ba136e18a208983b558968a818" translate="yes" xml:space="preserve">
          <source>Ignore refs for branches or tags matching the Perl regular expression. A &quot;negative look-ahead assertion&quot; like &lt;code&gt;^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$&lt;/code&gt; can be used to allow only certain refs.</source>
          <target state="translated">忽略与Perl正则表达式匹配的分支或标签的引用。像 &lt;code&gt;^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$&lt;/code&gt; 类的&amp;ldquo;否定超前断言&amp;rdquo; 可以用于仅允许某些refs。</target>
        </trans-unit>
        <trans-unit id="cca615474ea8523b5665d433104181e17b949af0" translate="yes" xml:space="preserve">
          <source>Ignore revisions listed in &lt;code&gt;file&lt;/code&gt;, which must be in the same format as an &lt;code&gt;fsck.skipList&lt;/code&gt;. This option may be repeated, and these files will be processed after any files specified with the &lt;code&gt;blame.ignoreRevsFile&lt;/code&gt; config option. An empty file name, &lt;code&gt;&quot;&quot;&lt;/code&gt;, will clear the list of revs from previously processed files.</source>
          <target state="translated">忽略 &lt;code&gt;file&lt;/code&gt; 中列出的修订，该修订必须与 &lt;code&gt;fsck.skipList&lt;/code&gt; 的格式相同。可以重复执行此选项，并且在使用 &lt;code&gt;blame.ignoreRevsFile&lt;/code&gt; 配置选项指定的任何文件之后，将处理这些文件。空文件名 &lt;code&gt;&quot;&quot;&lt;/code&gt; 将清除先前处理过的文件的转速列表。</target>
        </trans-unit>
        <trans-unit id="0cee361918756e813fbfde1e81b931c608ea0bab" translate="yes" xml:space="preserve">
          <source>Ignore revisions listed in the file, one unabbreviated object name per line, in &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. Whitespace and comments beginning with &lt;code&gt;#&lt;/code&gt; are ignored. This option may be repeated multiple times. Empty file names will reset the list of ignored revisions. This option will be handled before the command line option &lt;code&gt;--ignore-revs-file&lt;/code&gt;.</source>
          <target state="translated">忽略文件中列出的修订，即&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]中&lt;/a&gt;每行一个未缩写的对象名称。空格和以 &lt;code&gt;#&lt;/code&gt; 开头的注释将被忽略。此选项可以重复多次。空文件名将重置忽略的修订列表。将在命令行选项 &lt;code&gt;--ignore-revs-file&lt;/code&gt; 之前处理此选项。</target>
        </trans-unit>
        <trans-unit id="ecf2829d6b1d696605f65878628b97d7705cf8bc" translate="yes" xml:space="preserve">
          <source>Ignore scissors lines (see &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;).</source>
          <target state="translated">忽略剪刀行（请参阅&lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2348d1bd6f42459d3ee1b173782de699bb2835d4" translate="yes" xml:space="preserve">
          <source>Ignore scissors lines. Useful for overriding mailinfo.scissors settings.</source>
          <target state="translated">忽略剪刀线。用于覆盖mailinfo.scissors设置。</target>
        </trans-unit>
        <trans-unit id="df44e8d5c0f3cfab7d419d47fcf746abf35ec612" translate="yes" xml:space="preserve">
          <source>Ignore whitespace differences when trying to reconcile differences. Currently, each backend implements an approximation of this behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c0493eeab50cd9f84c9bb7fb54695bfa5cd858" translate="yes" xml:space="preserve">
          <source>Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.</source>
          <target state="translated">比较行时忽略空白。即使一行有空白,而另一行没有空白,也会忽略差异。</target>
        </trans-unit>
        <trans-unit id="f41139f9e81b5ab318787773cf3063813dbcefdd" translate="yes" xml:space="preserve">
          <source>Ignore whitespace when comparing the parent&amp;rsquo;s version and the child&amp;rsquo;s to find where the lines came from.</source>
          <target state="translated">比较父级和子级的版本以查找行的来源时，请忽略空格。</target>
        </trans-unit>
        <trans-unit id="67259bef7d0f56e262c4cda325ae4b91dc800c88" translate="yes" xml:space="preserve">
          <source>Ignored files are not listed, unless &lt;code&gt;--ignored&lt;/code&gt; option is in effect, in which case &lt;code&gt;XY&lt;/code&gt; are &lt;code&gt;!!&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;--ignored&lt;/code&gt; 选项生效，否则未列出被忽略的文件，在这种情况下 &lt;code&gt;XY&lt;/code&gt; 为 &lt;code&gt;!!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a64e868764637ce6fa403b78bdbf74f10990fd5" translate="yes" xml:space="preserve">
          <source>Ignored items have the following format:</source>
          <target state="translated">忽略的项目有以下格式:</target>
        </trans-unit>
        <trans-unit id="fe5aad4a58f02d9cd03afd86649692db9ed515bd" translate="yes" xml:space="preserve">
          <source>Ignores missing files during a --refresh</source>
          <target state="translated">忽略在--刷新期间丢失的文件</target>
        </trans-unit>
        <trans-unit id="87a5b84b90eaf9c6a4ea4cf7776f8cdbe987e92e" translate="yes" xml:space="preserve">
          <source>Ignoring files</source>
          <target state="translated">忽略文件</target>
        </trans-unit>
        <trans-unit id="d83f269a97cfa5cb2870ace661718351e9ef1d6f" translate="yes" xml:space="preserve">
          <source>Imagine that on top of the public commit P, you applied well-known patches X, Y and Z from somebody else, and then built your three-patch series A, B, C, the history would be like:</source>
          <target state="translated">想象一下,在公共提交P之上,你应用了别人的知名补丁X、Y、Z,然后构建了你的三补丁系列A、B、C,历史会是这样的。</target>
        </trans-unit>
        <trans-unit id="220433d0f0fcbc1334d4126616d73a1ad095f039" translate="yes" xml:space="preserve">
          <source>Imagine that you built your work on your &lt;code&gt;master&lt;/code&gt; branch on top of the &lt;code&gt;v1.0&lt;/code&gt; release, and want it to be integrated to the project. First you push that change to your public repository for others to see:</source>
          <target state="translated">想象一下，您是在 &lt;code&gt;v1.0&lt;/code&gt; 版本之上的 &lt;code&gt;master&lt;/code&gt; 分支上构建工作的，并希望将其集成到项目中。首先，您将该更改推送到公共存储库中，以供其他人查看：</target>
        </trans-unit>
        <trans-unit id="d92dfaf42e4c06410357fc423fdf173e48ba5a6c" translate="yes" xml:space="preserve">
          <source>Imagine that you have to rebase what you have already published. You will have to bypass the &quot;must fast-forward&quot; rule in order to replace the history you originally published with the rebased history. If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with her commit, and blindly pushing with &lt;code&gt;--force&lt;/code&gt; will lose her work.</source>
          <target state="translated">想象一下，您必须重新整理已经发布的内容。您必须绕过&amp;ldquo;必须快速转发&amp;rdquo;规则，才能用重新设置的历史记录替换最初发布的历史记录。如果您在改建基地时在原始历史的基础上建立了其他人，则远程分支的尖端可能随着她的提交而前进，而盲目用 &lt;code&gt;--force&lt;/code&gt; 推动将失去她的工作。</target>
        </trans-unit>
        <trans-unit id="8a9ff0ad91f2190aebd8f7874a38eff49a81d587" translate="yes" xml:space="preserve">
          <source>Imagine this history:</source>
          <target state="translated">想象一下这段历史。</target>
        </trans-unit>
        <trans-unit id="db144a77867a22b1db2aa0f495d3082ced7cfb54" translate="yes" xml:space="preserve">
          <source>Imitate &lt;code&gt;git clone&lt;/code&gt; but track only selected branches</source>
          <target state="translated">模仿 &lt;code&gt;git clone&lt;/code&gt; 但只跟踪选定的分支</target>
        </trans-unit>
        <trans-unit id="4a694f013e1a15bee19331c0c7b9e3ce34840db9" translate="yes" xml:space="preserve">
          <source>Imitate a CVS server. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">模仿CVS服务器。参见&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="f1c03dca591efe03ac168cd03c30c9d29e88acc3" translate="yes" xml:space="preserve">
          <source>Import Now, Repack Later</source>
          <target state="translated">现在导入,以后重新包装</target>
        </trans-unit>
        <trans-unit id="b3e1462f677f3a661ca64753ac202708178b3a16" translate="yes" xml:space="preserve">
          <source>Import a GNU Arch repository into Git</source>
          <target state="translated">将 GNU Arch 仓库导入 Git</target>
        </trans-unit>
        <trans-unit id="502aadd2b2c2382144812aea24a52e335147d4a4" translate="yes" xml:space="preserve">
          <source>Import all changes from both named depot paths into a single repository. Only files below these directories are included. There is not a subdirectory in Git for each &quot;proj1&quot; and &quot;proj2&quot;. You must use the &lt;code&gt;--destination&lt;/code&gt; option when specifying more than one depot path. The revision specifier must be specified identically on each depot path. If there are files in the depot paths with the same name, the path with the most recently updated version of the file is the one that appears in Git.</source>
          <target state="translated">将所有更改从两个命名的仓库路径导入到单个存储库中。仅包括这些目录下的文件。 Git中没有每个&amp;ldquo; proj1&amp;rdquo;和&amp;ldquo; proj2&amp;rdquo;的子目录。指定多个仓库路径时，必须使用 &lt;code&gt;--destination&lt;/code&gt; 选项。在每个软件仓库路径上必须相同地指定修订说明符。如果软件仓库路径中存在相同名称的文件，则具有最新版本文件的路径就是Git中显示的路径。</target>
        </trans-unit>
        <trans-unit id="90051e560d673faccfb0bfe61644ca104b05b719" translate="yes" xml:space="preserve">
          <source>Import all commits, including recent ones. cvsimport by default skips commits that have a timestamp less than 10 minutes ago.</source>
          <target state="translated">cvsimport 默认跳过时间戳小于 10 分钟前的提交。</target>
        </trans-unit>
        <trans-unit id="3ffbc41d8e969bcf6a3014a353f6e7a2bfd3e3ba" translate="yes" xml:space="preserve">
          <source>Import at most &lt;code&gt;n&lt;/code&gt; changes, rather than the entire range of changes included in the given revision specifier. A typical usage would be use &lt;code&gt;@all&lt;/code&gt; as the revision specifier, but then to use &lt;code&gt;--max-changes 1000&lt;/code&gt; to import only the last 1000 revisions rather than the entire revision history.</source>
          <target state="translated">最多导入 &lt;code&gt;n&lt;/code&gt; 个更改，而不是给定修订说明符中包含的整个更改范围。典型的用法是使用 &lt;code&gt;@all&lt;/code&gt; 作为修订说明符，然后使用 &lt;code&gt;--max-changes 1000&lt;/code&gt; 仅导入最后的1000个修订，而不是整个修订历史。</target>
        </trans-unit>
        <trans-unit id="a203d27ce8c09d6ab5f978bc976ed19c7da8bd29" translate="yes" xml:space="preserve">
          <source>Import changes into &amp;lt;ref&amp;gt; instead of refs/remotes/p4/master. If &amp;lt;ref&amp;gt; starts with refs/, it is used as is. Otherwise, if it does not start with p4/, that prefix is added.</source>
          <target state="translated">将更改导入&amp;lt;ref&amp;gt;而不是refs / remotes / p4 / master。如果&amp;lt;ref&amp;gt;以refs /开头，则按原样使用。否则，如果它不是以p4 /开头，则会添加该前缀。</target>
        </trans-unit>
        <trans-unit id="3446130415616c26cfbd9b0cb3b27c636fdfb1f4" translate="yes" xml:space="preserve">
          <source>Import exactly the p4 change numbers listed in &lt;code&gt;file&lt;/code&gt;, one per line. Normally, &lt;code&gt;git p4&lt;/code&gt; inspects the current p4 repository state and detects the changes it should import.</source>
          <target state="translated">准确导入 &lt;code&gt;file&lt;/code&gt; 中列出的p4更改编号，每行一个。通常， &lt;code&gt;git p4&lt;/code&gt; 检查当前p4存储库状态并检测应导入的更改。</target>
        </trans-unit>
        <trans-unit id="051514630860e82d8e6dfeb8000cb04203f0530f" translate="yes" xml:space="preserve">
          <source>Import from and submit to Perforce repositories</source>
          <target state="translated">从Perforce资源库导入并提交到Perforce资源库。</target>
        </trans-unit>
        <trans-unit id="bc1da86269dd0fa043570d9e0331c263ee1c8e9b" translate="yes" xml:space="preserve">
          <source>Import labels from p4 into Git.</source>
          <target state="translated">将标签从p4导入到Git中。</target>
        </trans-unit>
        <trans-unit id="01c4fe3eff92a8abc6c7acba932cff943343d8ce" translate="yes" xml:space="preserve">
          <source>Import one commit for each change in the history of that depot path.</source>
          <target state="translated">为该仓库路径历史上的每一个变化导入一个提交。</target>
        </trans-unit>
        <trans-unit id="5fa6a825ca52ecc53990e4e3e6add862904fa4f4" translate="yes" xml:space="preserve">
          <source>Import one commit with all files in the &lt;code&gt;#head&lt;/code&gt; change under that tree.</source>
          <target state="translated">导入一次提交，其中 &lt;code&gt;#head&lt;/code&gt; 更改中的所有文件都在该树下。</target>
        </trans-unit>
        <trans-unit id="1a475e0c7f94606844ba9fa0d34742cd54c3d13c" translate="yes" xml:space="preserve">
          <source>Import only changes 1 through 6.</source>
          <target state="translated">只导入1到6的变化。</target>
        </trans-unit>
        <trans-unit id="e9848e9219c243527c0682e352e98364329421b1" translate="yes" xml:space="preserve">
          <source>Import p4 labels into git, as per --import-labels.</source>
          <target state="translated">按照--import-labels,将p4标签导入git。</target>
        </trans-unit>
        <trans-unit id="34d234038bf4e799d075c2933026167918f64329" translate="yes" xml:space="preserve">
          <source>Import p4 labels.</source>
          <target state="translated">导入p4标签。</target>
        </trans-unit>
        <trans-unit id="2f4ea105dee6a1ad94ce6623f490fbb875775ee0" translate="yes" xml:space="preserve">
          <source>Import-only: don&amp;rsquo;t perform a checkout after importing. This option ensures the working directory and index remain untouched and will not create them if they do not exist.</source>
          <target state="translated">仅导入：导入后不执行结帐。此选项确保工作目录和索引保持不变，并且如果不存在则不会创建它们。</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="a64c4afd3bd1cef7955450469801cfbdf061341b" translate="yes" xml:space="preserve">
          <source>Important note! If you have any local changes in these branches, then this merge will create a commit object in the history (with no local changes Git will simply do a &quot;fast-forward&quot; merge). Many people dislike the &quot;noise&quot; that this creates in the Linux history, so you should avoid doing this capriciously in the &lt;code&gt;release&lt;/code&gt; branch, as these noisy commits will become part of the permanent history when you ask Linus to pull from the release branch.</source>
          <target state="translated">重要的提示！如果您在这些分支中有任何本地更改，则此合并将在历史记录中创建一个提交对象（不进行任何本地更改，Git只会进行&amp;ldquo;快进&amp;rdquo;合并）。许多人不喜欢它在Linux历史记录中造成的&amp;ldquo;噪音&amp;rdquo;，因此您应该避免在 &lt;code&gt;release&lt;/code&gt; 分支中反复进行此操作，因为当您要求Linus从发行分支中退出时，这些嘈杂的提交将成为永久历史的一部分。</target>
        </trans-unit>
        <trans-unit id="a87b614cdbaa5301ddda5b9a1cda5205ccdf1bbc" translate="yes" xml:space="preserve">
          <source>Importing a cvs archive</source>
          <target state="translated">导入一个cvs存档</target>
        </trans-unit>
        <trans-unit id="3e30801aed656938780d8d09defb05967bf70053" translate="yes" xml:space="preserve">
          <source>Importing a new project</source>
          <target state="translated">导入一个新项目</target>
        </trans-unit>
        <trans-unit id="7d3eb76e15d3e80f60fde0cbe9f4a9a66f1cc724" translate="yes" xml:space="preserve">
          <source>Importing or exporting patches:</source>
          <target state="translated">导入或导出补丁。</target>
        </trans-unit>
        <trans-unit id="8c866a3a4bff8b0052306000b7abfebb33a38b38" translate="yes" xml:space="preserve">
          <source>Importing patches to a project</source>
          <target state="translated">导入补丁到项目中</target>
        </trans-unit>
        <trans-unit id="19051f1cf9bd70907beeecdf5147851f44537c38" translate="yes" xml:space="preserve">
          <source>Importing these tags as-is in Git is impossible without making at least one commit which &amp;ldquo;fixes up&amp;rdquo; the files to match the content of the tag. Use fast-import&amp;rsquo;s &lt;code&gt;reset&lt;/code&gt; command to reset a dummy branch outside of your normal branch space to the base commit for the tag, then commit one or more file fixup commits, and finally tag the dummy branch.</source>
          <target state="translated">如果不进行至少一个&amp;ldquo;固定&amp;rdquo;文件以匹配标签内容的提交，则无法在Git中按原样导入这些标签。使用fast-import的 &lt;code&gt;reset&lt;/code&gt; 命令将正常分支空间之外的虚拟分支重置为标签的基本提交，然后提交一个或多个文件修正提交，最后标记该虚拟分支。</target>
        </trans-unit>
        <trans-unit id="ffa5110d0a0de3d5244ac22023669387afe15c4d" translate="yes" xml:space="preserve">
          <source>Imports a CVS repository into Git. It will either create a new repository, or incrementally import into an existing one.</source>
          <target state="translated">将 CVS 仓库导入 Git。它将创建一个新的仓库,或者逐步导入现有的仓库。</target>
        </trans-unit>
        <trans-unit id="189a5fab4172fe96418112b3abf1f29736c5a78f" translate="yes" xml:space="preserve">
          <source>Imports a project from one or more GNU Arch repositories. It will follow branches and repositories within the namespaces defined by the &amp;lt;archive/branch&amp;gt; parameters supplied. If it cannot find the remote branch a merge comes from it will just import it as a regular commit. If it can find it, it will mark it as a merge whenever possible (see discussion below).</source>
          <target state="translated">从一个或多个GNU Arch存储库导入项目。它将遵循由提供的&amp;lt;archive / branch&amp;gt;参数定义的名称空间中的分支和存储库。如果找不到远程分支，则来自合并的合并会将其作为常规提交导入。如果可以找到它，它将尽可能将其标记为合并（请参见下面的讨论）。</target>
        </trans-unit>
        <trans-unit id="0e7ba011d44c49f30a4b102d2d50cfa93397d28b" translate="yes" xml:space="preserve">
          <source>Imports the full contents of the head revision from the given p4 depot path into a single commit in the Git branch &lt;code&gt;refs/remotes/p4/master&lt;/code&gt;.</source>
          <target state="translated">从给定的p4库路径中导入head修订的全部内容到Git分支 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; 中的单个提交中。</target>
        </trans-unit>
        <trans-unit id="bc75793944c924c387fa08f2263917093a9e6ee9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt; jargon, &quot;cherry pick&quot; means to choose a subset of changes out of a series of changes (typically commits) and record them as a new series of changes on top of a different codebase. In Git, this is performed by the &quot;git cherry-pick&quot; command to extract the change introduced by an existing &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; and to record it based on the tip of the current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; as a new commit.</source>
          <target state="translated">用&lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt;术语来说，&amp;ldquo;樱桃选择&amp;rdquo;是指从一系列更改（通常是提交）中选择一个更改子集，并将其记录为不同代码库之上的一系列新更改。在Git中，这是通过&amp;ldquo; git cherry-pick&amp;rdquo;命令执行的，以提取现有&lt;a href=&quot;#def_commit&quot;&gt;提交所&lt;/a&gt;引入的更改，并基于当前&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;的尖端将其记录为新提交。</target>
        </trans-unit>
        <trans-unit id="5a7b7bab83d67b10ed8bbe7275df22f645616a7a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--parseopt&lt;/code&gt; mode, &lt;code&gt;git rev-parse&lt;/code&gt; helps massaging options to bring to shell scripts the same facilities C builtins have. It works as an option normalizer (e.g. splits single switches aggregate values), a bit like &lt;code&gt;getopt(1)&lt;/code&gt; does.</source>
          <target state="translated">在 &lt;code&gt;--parseopt&lt;/code&gt; 模式下， &lt;code&gt;git rev-parse&lt;/code&gt; 有助于按摩选项以将与C内建函数相同的功能带入shell脚本。它用作选项规范化器（例如，拆分单个开关的聚合值），就像 &lt;code&gt;getopt(1)&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="a61808962b5b6bb1a272b1dd2c4e90c87c42eb63" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--sq-quote&lt;/code&gt; mode, &lt;code&gt;git rev-parse&lt;/code&gt; echoes on the standard output a single line suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt;. This line is made by normalizing the arguments following &lt;code&gt;--sq-quote&lt;/code&gt;. Nothing other than quoting the arguments is done.</source>
          <target state="translated">在 &lt;code&gt;--sq-quote&lt;/code&gt; 模式下， &lt;code&gt;git rev-parse&lt;/code&gt; 在标准输出上回显适合 &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; 的一行。这行是通过规范 &lt;code&gt;--sq-quote&lt;/code&gt; 之后的参数来完成的。除了引用参数外，什么也没有做。</target>
        </trans-unit>
        <trans-unit id="02025b63af6480e186ac72d3a5a618d5536d1d9c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--stdin&lt;/code&gt; mode, take lines in the format</source>
          <target state="translated">在 &lt;code&gt;--stdin&lt;/code&gt; 模式下，采用以下格式的行</target>
        </trans-unit>
        <trans-unit id="46fb44ff2c3ae3502717728ebf0f15532f206b66" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt; contains just &amp;ldquo;foo&amp;rdquo;.</source>
          <target state="translated">在 &lt;code&gt;A&lt;/code&gt; 中， &lt;code&gt;foo&lt;/code&gt; 仅包含&amp;ldquo; foo&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0e95077ff33e18325bb9215a9cc5764269fc90de" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;dbDriver&lt;/code&gt; and &lt;code&gt;dbUser&lt;/code&gt; you can use the following variables:</source>
          <target state="translated">在 &lt;code&gt;dbDriver&lt;/code&gt; 和 &lt;code&gt;dbUser&lt;/code&gt; 中，可以使用以下变量：</target>
        </trans-unit>
        <trans-unit id="6c351c60eb0e6d6c6a7b2ff86bb73c9f63bc0dc3" translate="yes" xml:space="preserve">
          <source>In Git 1.7.0 or later, to cancel a conflicting merge, use &lt;code&gt;git reset --merge&lt;/code&gt;. &lt;strong&gt;Warning&lt;/strong&gt;: In older versions of Git, running &lt;code&gt;git pull&lt;/code&gt; with uncommitted changes is discouraged: while possible, it leaves you in a state that may be hard to back out of in the case of a conflict.</source>
          <target state="translated">在Git 1.7.0或更高版本中，要取消有冲突的合并，请使用 &lt;code&gt;git reset --merge&lt;/code&gt; 。&lt;strong&gt;警告&lt;/strong&gt;：在较旧版本的Git中，不建议运行 &lt;code&gt;git pull&lt;/code&gt; 并进行未提交的更改：尽管有可能，但它会使您处于在发生冲突的情况下很难退出的状态。</target>
        </trans-unit>
        <trans-unit id="e5fbbb479d61fa23b446f30021dbc9109422a0ad" translate="yes" xml:space="preserve">
          <source>In Git like in many other Version Control Systems (VCS), the different states of the data that is managed by the system are called commits. And, as VCS are mostly used to manage software source code, sometimes &quot;interesting&quot; changes of behavior in the software are introduced in some commits.</source>
          <target state="translated">在Git中和其他许多版本控制系统(VCS)一样,系统管理的数据的不同状态被称为提交。而且,由于VCS大多是用来管理软件源代码的,所以有时在一些提交中会引入软件中 &quot;有趣 &quot;的行为变化。</target>
        </trans-unit>
        <trans-unit id="8b9196b57e8598c90aa9a79e64e11940ec4bed09" translate="yes" xml:space="preserve">
          <source>In Git&amp;rsquo;s context, synonym for &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt;.</source>
          <target state="translated">在Git的上下文中，&lt;a href=&quot;#def_object_name&quot;&gt;对象名的&lt;/a&gt;同义词。</target>
        </trans-unit>
        <trans-unit id="644d8f376b3ac284860f081b25e96334d4db2911" translate="yes" xml:space="preserve">
          <source>In Git, there are two kinds of tags, a &quot;light&quot; one, and an &quot;annotated tag&quot;.</source>
          <target state="translated">在Git中,有两种标签,一种是 &quot;轻 &quot;标签,一种是 &quot;注释标签&quot;。</target>
        </trans-unit>
        <trans-unit id="1e877f57bcce771b4a2551649d22c402a8ae8603" translate="yes" xml:space="preserve">
          <source>In SVN, it is possible (though discouraged) to commit changes to a tag (because a tag is just a directory copy, thus technically the same as a branch). When cloning an SVN repository, &lt;code&gt;git svn&lt;/code&gt; cannot know if such a commit to a tag will happen in the future. Thus it acts conservatively and imports all SVN tags as branches, prefixing the tag name with &lt;code&gt;tags/&lt;/code&gt;.</source>
          <target state="translated">在SVN中，可以（尽管不鼓励）将更改提交给标签（因为标签只是目录副本，因此在技术上与分支相同）。克隆SVN储存库时， &lt;code&gt;git svn&lt;/code&gt; 无法知道将来是否会对标签进行这种提交。因此，它会保守地执行操作，并将所有SVN标签作为分支导入，并在标签名称前加上 &lt;code&gt;tags/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c215580302a5f52c2e27d45d0d7c1d84a4eccdbe" translate="yes" xml:space="preserve">
          <source>In Thunderbird 2: Edit..Preferences..Composition, wrap plain text messages at 0</source>
          <target state="translated">在Thunderbird 2中:Edit.Preferences.Composition,将纯文本信息包裹在0。</target>
        </trans-unit>
        <trans-unit id="f440374532f0b3d43494a1b042e56f8d4bce5f5d" translate="yes" xml:space="preserve">
          <source>In Thunderbird 3: Edit..Preferences..Advanced..Config Editor. Search for &quot;mail.wrap_long_lines&quot;. Toggle it to make sure it is set to &lt;code&gt;false&lt;/code&gt;. Also, search for &quot;mailnews.wraplength&quot; and set the value to 0.</source>
          <target state="translated">在Thunderbird 3中：Edit..Preferences..Advanced..Config编辑器。搜索&amp;ldquo; mail.wrap_long_lines&amp;rdquo;。切换它以确保将其设置为 &lt;code&gt;false&lt;/code&gt; 。此外，搜索&amp;ldquo; mailnews.wraplength&amp;rdquo;并将其值设置为0。</target>
        </trans-unit>
        <trans-unit id="17583a69f7262368825714769d6089546a690b45" translate="yes" xml:space="preserve">
          <source>In a fast-forward update from A to B, the set of commits that the original commit A built on top of is a subset of the commits the new commit B builds on top of. Hence, it does not lose any history.</source>
          <target state="translated">在从 A 到 B 的快进更新中,原来的提交 A 在上面建立的提交集是新的提交 B 在上面建立的提交集的一个子集。因此,它不会丢失任何历史记录。</target>
        </trans-unit>
        <trans-unit id="3d5b5c31f19f75af08174ee7bc83bae8bb6f0e50" translate="yes" xml:space="preserve">
          <source>In a normal repository, this tends to work automatically. The objects are mostly reachable from the branches and tags, and that&amp;rsquo;s what clients fetch. Any deltas we find on the server are likely to be between objects the client has or will have.</source>
          <target state="translated">在普通存储库中，这往往会自动运行。这些对象大部分可以从分支和标签访问，而这正是客户端获取的对象。我们在服务器上发现的任何增量都可能在客户端拥有或将要拥有的对象之间。</target>
        </trans-unit>
        <trans-unit id="8fbcefe66dafd74525f6b8ab70d285c817dc5cf1" translate="yes" xml:space="preserve">
          <source>In a repository using the traditional SHA-1, pack checksums, index checksums, and object IDs (object names) mentioned below are all computed using SHA-1. Similarly, in SHA-256 repositories, these values are computed using SHA-256.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="566e8925a0c194716258bb9a397f522567172cf6" translate="yes" xml:space="preserve">
          <source>In a situation where topic consisted of three commits, and the maintainer applied two of them, the situation might look like:</source>
          <target state="translated">如果主题包括三个提交,而维护者应用了其中的两个,情况可能是这样的。</target>
        </trans-unit>
        <trans-unit id="ee8b5fc930f29435d4aa076d7196ceac4e277fb2" translate="yes" xml:space="preserve">
          <source>In a workflow employing relatively long lived topic branches, the developer sometimes needs to resolve the same conflicts over and over again until the topic branches are done (either merged to the &quot;release&quot; branch, or sent out and accepted upstream).</source>
          <target state="translated">在一个采用相对较长寿命的主题分支的工作流中,开发人员有时需要反复解决相同的冲突,直到主题分支完成(或者合并到 &quot;发布 &quot;分支,或者发送出去并被上游接受)。</target>
        </trans-unit>
        <trans-unit id="f7c91952cc20e93e498fb039cc3dfb4469b10f04" translate="yes" xml:space="preserve">
          <source>In addition there are a number of other widely deployed hosting, browsing and reviewing solutions such as:</source>
          <target state="translated">此外,还有一些其他广泛部署的托管、浏览和审查解决方案,如。</target>
        </trans-unit>
        <trans-unit id="666628046a18a0e7af967b1de7c1a7d7baa813ae" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;--full-index&lt;/code&gt;, output a binary diff that can be applied with &lt;code&gt;git-apply&lt;/code&gt;. Implies &lt;code&gt;--patch&lt;/code&gt;.</source>
          <target state="translated">除了 &lt;code&gt;--full-index&lt;/code&gt; 之外，输出一个可以与 &lt;code&gt;git-apply&lt;/code&gt; 一起应用的二进制差异。意味着 &lt;code&gt;--patch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f6c767f6bc5922d93e508ae1661b26c77720a8f" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;-M&lt;/code&gt;, detect lines moved or copied from other files that were modified in the same commit. This is useful when you reorganize your program and move code around across files. When this option is given twice, the command additionally looks for copies from other files in the commit that creates the file. When this option is given three times, the command additionally looks for copies from other files in any commit.</source>
          <target state="translated">除了 &lt;code&gt;-M&lt;/code&gt; 之外，还检测从同一提交中修改的其他文件移动或复制的行。当您重新组织程序并在文件之间四处移动代码时，这很有用。两次给出此选项时，该命令还会在创建文件的提交中从其他文件中查找副本。给出此选项3次后，该命令还会在任何提交中从其他文件中查找副本。</target>
        </trans-unit>
        <trans-unit id="1888d5f31940dfed593ca4ff2d62ba84db0ce760" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;.gitattributes&lt;/code&gt; (per-directory) and &lt;code&gt;.git/info/attributes&lt;/code&gt;, Git looks into this file for attributes (see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;). Path expansions are made the same way as for &lt;code&gt;core.excludesFile&lt;/code&gt;. Its default value is &lt;code&gt;$XDG_CONFIG_HOME/git/attributes&lt;/code&gt;. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is either not set or empty, &lt;code&gt;$HOME/.config/git/attributes&lt;/code&gt; is used instead.</source>
          <target state="translated">除了 &lt;code&gt;.gitattributes&lt;/code&gt; （按目录）和 &lt;code&gt;.git/info/attributes&lt;/code&gt; 之外，Git &lt;a href=&quot;gitattributes&quot;&gt;还在&lt;/a&gt;此文件中查找属性（请参阅gitattributes [5]）。路径扩展的方式与 &lt;code&gt;core.excludesFile&lt;/code&gt; 相同。其默认值为 &lt;code&gt;$XDG_CONFIG_HOME/git/attributes&lt;/code&gt; 。如果 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; 未设置或为空，则使用 &lt;code&gt;$HOME/.config/git/attributes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a80ff33db6a243344cb7df3dd9b8d8d41e916e5f" translate="yes" xml:space="preserve">
          <source>In addition to HEAD, there are several other special names for commits:</source>
          <target state="translated">除了HEAD之外,还有其他几种特殊的提交名称。</target>
        </trans-unit>
        <trans-unit id="3d952784176d6003ec5b2f9f790384bd9b8c8247" translate="yes" xml:space="preserve">
          <source>In addition to being the staging area for new commits, the index file is also populated from the object database when checking out a branch, and is used to hold the trees involved in a merge operation. See &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; and the relevant man pages for details.</source>
          <target state="translated">除了作为新提交的暂存区之外，在签出分支时还从对象数据库中填充索引文件，并且该索引文件用于保存合并操作中涉及的树。有关详细信息，请参见&lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt;和相关的手册页。</target>
        </trans-unit>
        <trans-unit id="e26ec25b7f02c15aecd179e2dad4bd1f6afe8d5c" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with at most the specified number of one-line descriptions from the actual commits that are being merged. Defaults to false, and true is a synonym for 20.</source>
          <target state="translated">除了分支名称外,在日志信息中最多添加指定数量的实际提交的单行描述。默认为false,true是20的同义词。</target>
        </trans-unit>
        <trans-unit id="c5e07d7771d3e15091a04a68ed9a697dc979376c" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with one-line descriptions from at most &amp;lt;n&amp;gt; actual commits that are being merged. See also &lt;a href=&quot;git-fmt-merge-msg&quot;&gt;git-fmt-merge-msg[1]&lt;/a&gt;.</source>
          <target state="translated">除了分支名称之外，最多还用&amp;lt;n&amp;gt;个正在合并的实际提交中的单行描述填充日志消息。另见&lt;a href=&quot;git-fmt-merge-msg&quot;&gt;git-fmt-merge-msg [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53e8184a4fded8ffd5d3887baaffe37015550f76" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with one-line descriptions from the actual commits that are being merged. At most &amp;lt;n&amp;gt; commits from each merge parent will be used (20 if &amp;lt;n&amp;gt; is omitted). This overrides the &lt;code&gt;merge.log&lt;/code&gt; configuration variable.</source>
          <target state="translated">除了分支名称之外，还使用来自正在合并的实际提交的单行描述填充日志消息。最多使用每个合并父级的&amp;lt;n&amp;gt;提交（如果省略&amp;lt;n&amp;gt;，则为20）。这将覆盖 &lt;code&gt;merge.log&lt;/code&gt; 配置变量。</target>
        </trans-unit>
        <trans-unit id="6235bcb46867554949f149e203ea63eff52ea516" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with the branch description text associated with them. Defaults to false.</source>
          <target state="translated">除了分支名称外,还在日志信息中填入与其相关的分支描述文字。默认为false。</target>
        </trans-unit>
        <trans-unit id="f62e3d2f843321847fb42ac94f40312c54d52ccf" translate="yes" xml:space="preserve">
          <source>In addition to labelling blobs and commits with mark ids, also label tags. This is useful in conjunction with &lt;code&gt;--export-marks&lt;/code&gt; and &lt;code&gt;--import-marks&lt;/code&gt;, and is also useful (and necessary) for exporting of nested tags. It does not hurt other cases and would be the default, but many fast-import frontends are not prepared to accept tags with mark identifiers.</source>
          <target state="translated">除了使用标记ID标记Blob和提交外，还标记标签。与 &lt;code&gt;--export-marks&lt;/code&gt; 和 &lt;code&gt;--import-marks&lt;/code&gt; 结合使用时，这对导出嵌套标记也很有用（并且是必需的）。它不会损害其他情况，并且将是默认情况，但是许多快速导入的前端并不准备接受带有标记标识符的标签。</target>
        </trans-unit>
        <trans-unit id="22782295e6ea8ee2d620246684c55c016d61141f" translate="yes" xml:space="preserve">
          <source>In addition to objects reachable from any of our references, keep objects reachable from listed &amp;lt;head&amp;gt;s.</source>
          <target state="translated">除了可从我们的任何参考文献中获取的对象外，还应使对象从列出的&amp;lt;head&amp;gt;中可获取。</target>
        </trans-unit>
        <trans-unit id="99c28f63ba36fb0fcaa38897708f95d9a693e369" translate="yes" xml:space="preserve">
          <source>In addition to saving you keystrokes, &lt;code&gt;git pull&lt;/code&gt; also helps you by producing a default commit message documenting the branch and repository that you pulled from.</source>
          <target state="translated">除了保存击键， &lt;code&gt;git pull&lt;/code&gt; 还可以通过生成默认提交消息来帮助您，该消息记录了从中提取的分支和存储库。</target>
        </trans-unit>
        <trans-unit id="7129d0d8ea665296c3d9391d29a173f1ab2fc5f1" translate="yes" xml:space="preserve">
          <source>In addition to searching in the tracked files in the working tree, search also in untracked files.</source>
          <target state="translated">除了在工作树中的跟踪文件中搜索,还可以在未跟踪的文件中搜索。</target>
        </trans-unit>
        <trans-unit id="d5b7aa3ae2fa07bc2a7838db49f832f9fd332a95" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; markers, it uses another &lt;code&gt;|||||||&lt;/code&gt; marker that is followed by the original text. You can tell that the original just stated a fact, and your side simply gave in to that statement and gave up, while the other side tried to have a more positive attitude. You can sometimes come up with a better resolution by viewing the original.</source>
          <target state="translated">除 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;=======&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 标记外，它还使用 &lt;code&gt;|||||||&lt;/code&gt; |标记，后跟原始文字。您可以说原件只是陈述了一个事实，而您一方只是屈服于该声明而放弃了，而另一方则试图采取更积极的态度。有时您可以通过查看原件来获得更好的分辨率。</target>
        </trans-unit>
        <trans-unit id="3a9ee73184ef3bce8e3d7aa50aca9c03ee962a97" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; listed on the command line, read them from the standard input. If a &lt;code&gt;--&lt;/code&gt; separator is seen, stop reading commits and start reading paths to limit the result.</source>
          <target state="translated">除了命令行中列出的 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 之外，还可以从标准输入中读取它们。如果看到 &lt;code&gt;--&lt;/code&gt; 分隔符，请停止读取提交并开始读取路径以限制结果。</target>
        </trans-unit>
        <trans-unit id="e57f382f37af963780a48b9b24f281a677f73e3f" translate="yes" xml:space="preserve">
          <source>In addition to the above settings, you can change whether TREESAME affects inclusion:</source>
          <target state="translated">除了上述设置外,您还可以更改TREESAME是否影响收录。</target>
        </trans-unit>
        <trans-unit id="15a1839e21183f6c87dd1989058c966575a3a5b3" translate="yes" xml:space="preserve">
          <source>In addition to the above two patterns, we also expect that all files in the root directory are included. If a recursive pattern is added, then all leading directories are added as parent patterns.</source>
          <target state="translated">除了以上两种模式外,我们还希望根目录下的所有文件都被包含在内。如果添加了递归模式,那么所有前导目录都会被添加为父模式。</target>
        </trans-unit>
        <trans-unit id="5cdd7d140b9026d9dc5fc6d397fdc9a74057bb4e" translate="yes" xml:space="preserve">
          <source>In addition to the above, for commit and tag objects, the header field names (&lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;parent&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, and &lt;code&gt;tag&lt;/code&gt;) can be used to specify the value in the header field.</source>
          <target state="translated">除上述内容外，对于提交和标记对象，标头字段名称（ &lt;code&gt;tree&lt;/code&gt; ， &lt;code&gt;parent&lt;/code&gt; ， &lt;code&gt;object&lt;/code&gt; ， &lt;code&gt;type&lt;/code&gt; 和 &lt;code&gt;tag&lt;/code&gt; ）可用于指定标头字段中的值。</target>
        </trans-unit>
        <trans-unit id="0cd22d754613826bc7df21407a063908e095a28b" translate="yes" xml:space="preserve">
          <source>In addition to the above, for commit and tag objects, the header field names (&lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;parent&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, and &lt;code&gt;tag&lt;/code&gt;) can be used to specify the value in the header field. Fields &lt;code&gt;tree&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt; can also be used with modifier &lt;code&gt;:short&lt;/code&gt; and &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt; just like &lt;code&gt;objectname&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da373db26873c5d2b59dd68ca741f2f25c73567" translate="yes" xml:space="preserve">
          <source>In addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3a21fa25ba67eb3d7f9da7f4344fe1b071989c" translate="yes" xml:space="preserve">
          <source>In addition to the names of files that have been changed, also show the textual changes that are staged to be committed (i.e., like the output of &lt;code&gt;git diff --cached&lt;/code&gt;). If &lt;code&gt;-v&lt;/code&gt; is specified twice, then also show the changes in the working tree that have not yet been staged (i.e., like the output of &lt;code&gt;git diff&lt;/code&gt;).</source>
          <target state="translated">除了已更改文件的名称外，还显示已暂存的文本更改（即，例如 &lt;code&gt;git diff --cached&lt;/code&gt; 的输出）。如果两次指定了 &lt;code&gt;-v&lt;/code&gt; ，那么还将显示尚未上演的工作树中的更改（即，类似于 &lt;code&gt;git diff&lt;/code&gt; 的输出）。</target>
        </trans-unit>
        <trans-unit id="9d2884340103002807461c187c73c074fbbd3657" translate="yes" xml:space="preserve">
          <source>In addition to the object pointed by it, show the underlying ref pointed by it when showing a symbolic ref. Currently, upload-pack only shows the symref HEAD, so it will be the only one shown by ls-remote.</source>
          <target state="translated">除了它所指向的对象外,在显示符号ref时,还要显示它所指向的底层ref,目前upload-pack只显示symref HEAD,所以ls-remote将只显示它。目前,upload-pack只显示符号ref HEAD,所以它将是ls-remote唯一显示的对象。</target>
        </trans-unit>
        <trans-unit id="6c7a07603f44cd9719a4b680d9f7256b9473029e" translate="yes" xml:space="preserve">
          <source>In addition to the patches, generate a cover letter file containing the branch description, shortlog and the overall diffstat. You can fill in a description in the file before sending it out.</source>
          <target state="translated">除了补丁之外,还要生成一个包含分支描述、shortlog和整体diffstat的cover letter文件。你可以在文件中填写描述,然后再发送出去。</target>
        </trans-unit>
        <trans-unit id="102ba20e10a0928862b597a4b85d8411aa7a16cb" translate="yes" xml:space="preserve">
          <source>In addition to the text-based messages available in &lt;code&gt;GIT_TRACE2&lt;/code&gt;, this setting writes a column-based format for understanding nesting regions. See &lt;code&gt;GIT_TRACE2&lt;/code&gt; for available trace output options and &lt;a href=&quot;api-trace2&quot;&gt;Trace2 documentation&lt;/a&gt; for full details.</source>
          <target state="translated">除了 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 中可用的基于文本的消息外，此设置还编写了基于列的格式以了解嵌套区域。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE2&lt;/code&gt; ；有关完整的详细信息，请参见Trace2 &lt;a href=&quot;api-trace2&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="547bdce4dd37bfda9e1c54bdf493ad3c6de08ff9" translate="yes" xml:space="preserve">
          <source>In addition, any unrecognized string that has a &lt;code&gt;%&lt;/code&gt; in it is interpreted as if it has &lt;code&gt;tformat:&lt;/code&gt; in front of it. For example, these two are equivalent:</source>
          <target state="translated">此外，任何无法识别的字符串中包含 &lt;code&gt;%&lt;/code&gt; 的字符串都将被解释为前面带有 &lt;code&gt;tformat:&lt;/code&gt; 。例如，这两个是等效的：</target>
        </trans-unit>
        <trans-unit id="bc74e38407c657e1d62a835de829f2a0637ff932" translate="yes" xml:space="preserve">
          <source>In addition, if the variable is set to &lt;code&gt;af_unix:[&amp;lt;socket_type&amp;gt;:]&amp;lt;absolute-pathname&amp;gt;&lt;/code&gt;, Git will try to open the path as a Unix Domain Socket. The socket type can be either &lt;code&gt;stream&lt;/code&gt; or &lt;code&gt;dgram&lt;/code&gt;.</source>
          <target state="translated">另外，如果将变量设置为 &lt;code&gt;af_unix:[&amp;lt;socket_type&amp;gt;:]&amp;lt;absolute-pathname&amp;gt;&lt;/code&gt; ，则Git会尝试将路径作为Unix域套接字打开。套接字类型可以是 &lt;code&gt;stream&lt;/code&gt; 或 &lt;code&gt;dgram&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdc73bece50193400c9954e5c33b0d5db46ea312" translate="yes" xml:space="preserve">
          <source>In addition, some Git commands (such as &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; and &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;) can also take revision parameters which denote other objects than commits, e.g. blobs (&quot;files&quot;) or trees (&quot;directories of files&quot;).</source>
          <target state="translated">另外，某些Git命令（例如&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;和&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;）也可以采用修订参数，这些参数表示提交以外的其他对象，例如blob（&amp;ldquo;文件&amp;rdquo;）或树（&amp;ldquo;文件目录&amp;rdquo;）。 ）。</target>
        </trans-unit>
        <trans-unit id="9c0114752cc3965279675b92f9d509a7719a899c" translate="yes" xml:space="preserve">
          <source>In addition, the date part is accepted in the following formats: &lt;code&gt;YYYY.MM.DD&lt;/code&gt;, &lt;code&gt;MM/DD/YYYY&lt;/code&gt; and &lt;code&gt;DD.MM.YYYY&lt;/code&gt;.</source>
          <target state="translated">此外，日期部分接受以下格式： &lt;code&gt;YYYY.MM.DD&lt;/code&gt; ， &lt;code&gt;MM/DD/YYYY&lt;/code&gt; 和 &lt;code&gt;DD.MM.YYYY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b090b5874a4f9cb2a75963ffefe67f7cff33a14b" translate="yes" xml:space="preserve">
          <source>In addition, the following pairs of options are incompatible:</source>
          <target state="translated">此外,以下几对选项是不兼容的:</target>
        </trans-unit>
        <trans-unit id="c9eac4f7a75d08c8d5ecd2f93cae76dbdd2c65fb" translate="yes" xml:space="preserve">
          <source>In addition, there are a number of optional keys:</source>
          <target state="translated">此外,还有一些可选键。</target>
        </trans-unit>
        <trans-unit id="3170175bde47695f8d16d1aa859fc39830538d4d" translate="yes" xml:space="preserve">
          <source>In all &quot;keep index&quot; cases, the index entry stays as in the original index file. If the entry is not up to date, &lt;code&gt;git read-tree&lt;/code&gt; keeps the copy in the work tree intact when operating under the -u flag.</source>
          <target state="translated">在所有&amp;ldquo;保留索引&amp;rdquo;情况下，索引条目都保留在原始索引文件中。如果该条目不是最新的，则在-u标志下进行操作时， &lt;code&gt;git read-tree&lt;/code&gt; 会将副本保留在工作树中。</target>
        </trans-unit>
        <trans-unit id="518e45973547d44ae8b0cf643cea7c8e1439a6f7" translate="yes" xml:space="preserve">
          <source>In all of these cases, the commands themselves first optionally limit the two sets of files by any pathspecs given on their command-lines, and compare corresponding paths in the two resulting sets of files.</source>
          <target state="translated">在所有这些情况下,命令本身首先通过命令行中给出的任何路径规格对两组文件进行选择性限制,并比较两组结果文件中的对应路径。</target>
        </trans-unit>
        <trans-unit id="a976d8376129a573bbe9b45628bf2bdf5e1fe7e1" translate="yes" xml:space="preserve">
          <source>In an environment that restricts the users' access only to git commands over the wire, this hook can be used to implement access control without relying on filesystem ownership and group membership. See &lt;a href=&quot;git-shell&quot;&gt;git-shell[1]&lt;/a&gt; for how you might use the login shell to restrict the user&amp;rsquo;s access to only git commands.</source>
          <target state="translated">在限制用户只能通过网络访问git命令的环境中，此钩子可用于实现访问控制，而无需依赖文件系统所有权和组成员身份。请参阅&lt;a href=&quot;git-shell&quot;&gt;git-shell [1]&lt;/a&gt;了解如何使用登录shell来限制用户仅对git命令的访问。</target>
        </trans-unit>
        <trans-unit id="9220471bbc29ec41ed13c216a79cb80f852ef698" translate="yes" xml:space="preserve">
          <source>In any case, a field name that refers to a field inapplicable to the object referred by the ref does not cause an error. It returns an empty string instead.</source>
          <target state="translated">在任何情况下,如果一个字段名指向的字段与 ref 引用的对象不适用,都不会导致错误。它将返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="3ed3c4a7faef04068c3d21c5e427f36b63dea04c" translate="yes" xml:space="preserve">
          <source>In both cases, all bytes are treated as-is (i.e., there is no quoting, and one cannot transmit a value with newline or NUL in it). The list of attributes is terminated by a blank line or end-of-file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cc553818c07e93d42b2d9a9da22e8f0487ba9d" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the commit specification expressions also accepted by &lt;code&gt;from&lt;/code&gt; (see above).</source>
          <target state="translated">在这两种格式中， &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 是 &lt;code&gt;from&lt;/code&gt; 也接受的任何提交规范表达式（请参见上文）。</target>
        </trans-unit>
        <trans-unit id="9838d0f6a0615e5345bacba941fa3a7ae58fc03e" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is the type of file entry, specified in octal. Git only supports the following modes:</source>
          <target state="translated">在两种格式中， &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 是文件条目的类型，以八进制指定。Git仅支持以下模式：</target>
        </trans-unit>
        <trans-unit id="e124f640b7099c2dfc555e83763a437b341aea9d" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is the complete path of the file to be added (if not already existing) or modified (if already existing).</source>
          <target state="translated">在这两种格式中， &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 是要添加（如果尚未存在）或修改（如果已经存在）的文件的完整路径。</target>
        </trans-unit>
        <trans-unit id="e22465a192b99fdb8a38ceb6e2163b1bb2a55eaa" translate="yes" xml:space="preserve">
          <source>In both formats RS (the record separator) is newline by default but will be the null byte if -z was passed on the command line. The temporary file names are always safe strings; they will never contain directory separators or whitespace characters. The path field is always relative to the current directory and the temporary file names are always relative to the top level directory.</source>
          <target state="translated">在这两种格式中,RS(记录分隔符)默认为换行,但如果在命令行中传递了-z,则为空字节。临时文件名总是安全的字符串;它们永远不会包含目录分隔符或空白字符。路径字段总是相对于当前目录,临时文件名总是相对于顶层目录。</target>
        </trans-unit>
        <trans-unit id="bbdfd88cae7c8d5fe4027454edb7c9f3a518f214" translate="yes" xml:space="preserve">
          <source>In both rename and copy detection, the same &quot;extent of changes&quot; algorithm used in diffcore-break is used to determine if two files are &quot;similar enough&quot;, and can be customized to use a similarity score different from the default of 50% by giving a number after the &quot;-M&quot; or &quot;-C&quot; option (e.g. &quot;-M8&quot; to tell it to use 8/10 = 80%).</source>
          <target state="translated">在重命名和复制检测中,与diffcore-break中使用的 &quot;变化范围 &quot;算法相同,用于确定两个文件是否 &quot;足够相似&quot;,并且可以通过在&quot;-M &quot;或&quot;-C &quot;选项后给出一个数字(例如&quot;-M8 &quot;告诉它使用8/10=80%),自定义使用不同于默认的50%的相似度分数。</target>
        </trans-unit>
        <trans-unit id="cef1680a7a27c73f800aa2ae728f37bb9ebeed5c" translate="yes" xml:space="preserve">
          <source>In case &amp;lt;old&amp;gt; and &amp;lt;new&amp;gt; are the same, and &amp;lt;old&amp;gt; is a file under &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; or &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;, the remote is converted to the configuration file format.</source>
          <target state="translated">如果&amp;lt;old&amp;gt;和&amp;lt;new&amp;gt;相同，并且&amp;lt;old&amp;gt;是 &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 或 &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 下的文件，则远程将转换为配置文件格式。</target>
        </trans-unit>
        <trans-unit id="77e55c61e61a6a73beec771303a37403de7ae828" translate="yes" xml:space="preserve">
          <source>In case (some of) these environment variables are not set, the information is taken from the configuration items &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt;, or, if not present, the environment variable EMAIL, or, if that is not set, system user name and the hostname used for outgoing mail (taken from &lt;code&gt;/etc/mailname&lt;/code&gt; and falling back to the fully qualified hostname when that file does not exist).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3736cf7c9e88d8830feeb4facce5d47bac7822e0" translate="yes" xml:space="preserve">
          <source>In case (some of) these environment variables are not set, the information is taken from the configuration items user.name and user.email, or, if not present, the environment variable EMAIL, or, if that is not set, system user name and the hostname used for outgoing mail (taken from &lt;code&gt;/etc/mailname&lt;/code&gt; and falling back to the fully qualified hostname when that file does not exist).</source>
          <target state="translated">如果未设置（其中的）某些环境变量，则该信息来自配置项user.name和user.email，或者（如果不存在）环境变量EMAIL，或者（如果未设置）系统用户名称和用于传出邮件的主机名（取自 &lt;code&gt;/etc/mailname&lt;/code&gt; ，当该文件不存在时退回到标准主机名）。</target>
        </trans-unit>
        <trans-unit id="fab172a52a0d96a15d352f159439993a534e8fe5" translate="yes" xml:space="preserve">
          <source>In case of conflict, &lt;code&gt;git rebase&lt;/code&gt; will stop at the first problematic commit and leave conflict markers in the tree. You can use &lt;code&gt;git diff&lt;/code&gt; to locate the markers (&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;) and make edits to resolve the conflict. For each file you edit, you need to tell Git that the conflict has been resolved, typically this would be done with</source>
          <target state="translated">如果发生冲突， &lt;code&gt;git rebase&lt;/code&gt; 将在第一个有问题的提交时停止，并在树中保留冲突标记。您可以使用 &lt;code&gt;git diff&lt;/code&gt; 定位标记（&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;）并进行编辑以解决冲突。对于您编辑的每个文件，您需要告诉Git冲突已解决，通常可以通过以下方法完成</target>
        </trans-unit>
        <trans-unit id="8de3ddb587a19db9387af113a7f3cb72b19328d0" translate="yes" xml:space="preserve">
          <source>In case of failure in the output of &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt;, show directions on how to proceed from the current state.</source>
          <target state="translated">如果&lt;a href=&quot;git-rm&quot;&gt;git-rm [1]&lt;/a&gt;输出失败，请显示有关如何从当前状态进行操作的说明。</target>
        </trans-unit>
        <trans-unit id="1ca6e2b22c66fb3bb4920e7b16e070cab433e13d" translate="yes" xml:space="preserve">
          <source>In case the filter cannot or does not want to process the content as well as any future content for the lifetime of the Git process, then it is expected to respond with an &quot;abort&quot; status at any point in the protocol.</source>
          <target state="translated">如果过滤器不能或不想在Git进程的生命周期内处理该内容以及任何未来的内容,那么它将在协议中的任何时候以 &quot;中止 &quot;状态响应。</target>
        </trans-unit>
        <trans-unit id="a44b155f3278323b322b1edffc06fec805c87137" translate="yes" xml:space="preserve">
          <source>In case the filter cannot or does not want to process the content, it is expected to respond with an &quot;error&quot; status.</source>
          <target state="translated">如果过滤器不能或不想处理该内容,预计它将以 &quot;错误 &quot;状态响应。</target>
        </trans-unit>
        <trans-unit id="063d2c577358a9002bf9810cc43ec764ca0682e1" translate="yes" xml:space="preserve">
          <source>In command synopses, the word &quot;tree-ish&quot; is sometimes used to designate such an argument.</source>
          <target state="translated">在命令提要中,有时用 &quot;树状 &quot;一词来指定这样的论点。</target>
        </trans-unit>
        <trans-unit id="0cb56babf143d18da14e8d5b38b880de0eb432ae" translate="yes" xml:space="preserve">
          <source>In compact output mode, specified with configuration variable fetch.output, if either entire &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; is found in the other string, it will be substituted with &lt;code&gt;*&lt;/code&gt; in the other string. For example, &lt;code&gt;master -&amp;gt; origin/master&lt;/code&gt; becomes &lt;code&gt;master -&amp;gt; origin/*&lt;/code&gt;.</source>
          <target state="translated">在紧凑输出模式下，使用配置变量fetch.output指定，如果在另一个字符串中找到整个 &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; ，则它将在另一个字符串中用 &lt;code&gt;*&lt;/code&gt; 代替。例如， &lt;code&gt;master -&amp;gt; origin/master&lt;/code&gt; 变为 &lt;code&gt;master -&amp;gt; origin/*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17a206b483cbd4faf3ff1c681d69d041ba456195" translate="yes" xml:space="preserve">
          <source>In contrast to a regular interactive rebase, there are &lt;code&gt;label&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt; and &lt;code&gt;merge&lt;/code&gt; commands in addition to &lt;code&gt;pick&lt;/code&gt; ones.</source>
          <target state="translated">与常规的交互式rebase相比，除了 &lt;code&gt;pick&lt;/code&gt; 之外，还有 &lt;code&gt;label&lt;/code&gt; ， &lt;code&gt;reset&lt;/code&gt; 和 &lt;code&gt;merge&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="a91f8ccdcda758152dfb84f7e032555a6abd0478" translate="yes" xml:space="preserve">
          <source>In contrast, a non-fast-forward update will lose history. For example, suppose you and somebody else started at the same commit X, and you built a history leading to commit B while the other person built a history leading to commit A. The history looks like this:</source>
          <target state="translated">相反,非快进式更新会丢失历史记录。例如,假设你和其他人从同一个提交X开始,你建立了一个通往提交B的历史,而其他人建立了一个通往提交A的历史。历史记录是这样的。</target>
        </trans-unit>
        <trans-unit id="732c99dfb4118d47f73ec2f7f549a4abcdf7b217" translate="yes" xml:space="preserve">
          <source>In detecting regressions introduced through the merging of a branch, the merge commit will be identified as introduction of the bug and its ancestors will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b2f985753911580a2527f5513df7870e7e2eaf" translate="yes" xml:space="preserve">
          <source>In editing files, git-filter-branch by design checks out each and every commit as it existed in the original repo. If your repo has 10\^5 files and 10\^5 commits, but each commit only modifies 5 files, then git-filter-branch will make you do 10\^10 modifications, despite only having (at most) 5*10^5 unique blobs.</source>
          <target state="translated">在编辑文件时,git-filter-branch的设计是检查出每一个提交,因为它存在于原始repo中,如果你的repo有10^5个文件和10^5个提交,但每个提交只修改了5个文件,那么git-filter-branch会让你做10^10个修改,尽管只有()个提交。如果你的 repo 有 10^5 个文件和 10^5 个提交,但每个提交只修改了 5 个文件,那么 git-filter-branch 会让你做 10^10 个修改,尽管只有(最多)5*10^5 个唯一的 blobs。</target>
        </trans-unit>
        <trans-unit id="2e3fe33f9a577c2f8225b1f2426166ec832bed24" translate="yes" xml:space="preserve">
          <source>In editing files, git-filter-branch by design checks out each and every commit as it existed in the original repo. If your repo has &lt;code&gt;10^5&lt;/code&gt; files and &lt;code&gt;10^5&lt;/code&gt; commits, but each commit only modifies five files, then git-filter-branch will make you do &lt;code&gt;10^10&lt;/code&gt; modifications, despite only having (at most) &lt;code&gt;5*10^5&lt;/code&gt; unique blobs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a532459a44f155e770ddc46e416638b81292d839" translate="yes" xml:space="preserve">
          <source>In either format, values can be specified in any form that Git recognizes as an object name. Commands in any other format or a repeated &amp;lt;ref&amp;gt; produce an error. Command meanings are:</source>
          <target state="translated">无论采用哪种格式，都可以用Git识别为对象名称的任何形式指定值。任何其他格式的命令或重复的&amp;lt;ref&amp;gt;都会产生错误。命令的含义是：</target>
        </trans-unit>
        <trans-unit id="9c49e183be0df7128f7b7d238522888866505455" translate="yes" xml:space="preserve">
          <source>In fact development teams often maintain both a development branch and a maintenance branch, and it would be quite easy for them if &quot;git bisect&quot; just worked when they want to bisect a regression on the development branch that is not on the maintenance branch. They should be able to start bisecting using:</source>
          <target state="translated">事实上,开发团队经常会同时维护一个开发分支和一个维护分支,如果 &quot;git bisect &quot;能在他们想把一个不在维护分支上的回归分支一分为二的时候发挥作用,那对他们来说就很容易了。他们应该可以使用 git bisect 来进行二分。</target>
        </trans-unit>
        <trans-unit id="49c9270dc1d07096e092a06d8107784ae1248f61" translate="yes" xml:space="preserve">
          <source>In fact it&amp;rsquo;s invaluable because there are bugs i would never even &lt;code&gt;try&lt;/code&gt; to debug if it wasn&amp;rsquo;t for git bisect. In the past there were bug patterns that were immediately hopeless for me to debug - at best i could send the crash/bug signature to lkml and hope that someone else can think of something.</source>
          <target state="translated">实际上，它是无价的，因为如果不是git bisect，有一些错误我什至都不会 &lt;code&gt;try&lt;/code&gt; 调试。过去，错误模式使我无法立即调试-充其量我可以将崩溃/错误签名发送给lkml，并希望其他人可以想到一些东西。</target>
        </trans-unit>
        <trans-unit id="4d0defa9e6e327fdaa3580beb798bb05e9bb4ad4" translate="yes" xml:space="preserve">
          <source>In fact it&amp;rsquo;s this last feature that &quot;sold&quot; it to the Git community, so it is now in the &quot;master&quot; branch of Git&amp;rsquo;s Git repository and it should be released in Git 1.6.5 in October or November 2009.</source>
          <target state="translated">实际上，正是这最后一个功能将其&amp;ldquo;出售&amp;rdquo;给了Git社区，因此它现在位于Git Git存储库的&amp;ldquo; master&amp;rdquo;分支中，并且应该在2009年10月或2009年11月在Git 1.6.5中发布。</target>
        </trans-unit>
        <trans-unit id="a503332ebe0b76ca226cc7fab9355da1cbc846ca" translate="yes" xml:space="preserve">
          <source>In fact people are specially interested in commits that introduce a &quot;bad&quot; behavior, called a bug or a regression. They are interested in these commits because a commit (hopefully) contains a very small set of source code changes. And it&amp;rsquo;s much easier to understand and properly fix a problem when you only need to check a very small set of changes, than when you don&amp;rsquo;t know where look in the first place.</source>
          <target state="translated">实际上，人们对引入&amp;ldquo;不良&amp;rdquo;行为（称为错误或回归）的提交特别感兴趣。他们对这些提交很感兴趣，因为提交（希望）包含很少的源代码更改集。当您只需要检查很少的更改集时，比起您一开始不知道查找位置时，要容易理解和正确解决问题。</target>
        </trans-unit>
        <trans-unit id="ef62eb9471b68497e696b504f306bae12d5b62ac" translate="yes" xml:space="preserve">
          <source>In fact the problem is that big software often has many different configuration options and that each test case should pass for each configuration after each commit. So if you have for each release: N configurations, M commits and T test cases, you should perform:</source>
          <target state="translated">其实问题在于,大的软件往往有很多不同的配置选项,每次提交后,每个配置的测试用例都应该通过。所以如果你对每个版本都有 N个配置,M个提交和T个测试用例,你应该执行:</target>
        </trans-unit>
        <trans-unit id="99977c45d37760acd8d4612dba46dd63b60c39cd" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;git bisect&lt;/code&gt; can be used to find the commit that changed &lt;strong&gt;any&lt;/strong&gt; property of your project; e.g., the commit that fixed a bug, or the commit that caused a benchmark&amp;rsquo;s performance to improve. To support this more general usage, the terms &quot;old&quot; and &quot;new&quot; can be used in place of &quot;good&quot; and &quot;bad&quot;, or you can choose your own terms. See section &quot;Alternate terms&quot; below for more information.</source>
          <target state="translated">实际上， &lt;code&gt;git bisect&lt;/code&gt; 可用于查找更改了&lt;strong&gt;任何内容&lt;/strong&gt;的提交。&lt;strong&gt;&lt;/strong&gt;项目属性。例如，修复了错误的提交，或导致基准性能提高的提交。为了支持这种更通用的用法，可以使用术语&amp;ldquo;旧&amp;rdquo;和&amp;ldquo;新&amp;rdquo;代替&amp;ldquo;好&amp;rdquo;和&amp;ldquo;坏&amp;rdquo;，或者您可以选择自己的术语。有关更多信息，请参见下面的&amp;ldquo;备用术语&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="7071f9821fe5bdd2a61f333d551d92b1d1a7cc62" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;git diff-index --cached&lt;/code&gt;&lt;strong&gt;should&lt;/strong&gt; always be entirely equivalent to actually doing a &lt;code&gt;git write-tree&lt;/code&gt; and comparing that. Except this one is much nicer for the case where you just want to check where you are.</source>
          <target state="translated">实际上， &lt;code&gt;git diff-index --cached&lt;/code&gt; &lt;strong&gt;应该&lt;/strong&gt;总是完全等同于实际执行 &lt;code&gt;git write-tree&lt;/code&gt; 并进行比较。除此之外，对于您只想检查自己的位置的情况，它要好得多。</target>
        </trans-unit>
        <trans-unit id="4ed30cb15a7bebad154936439885b3df49088a74" translate="yes" xml:space="preserve">
          <source>In fact, as you did that, if you now look into your object directory, you&amp;rsquo;ll notice that Git will have added two new objects to the object database. If you did exactly the steps above, you should now be able to do</source>
          <target state="translated">实际上，这样做之后，如果现在查看对象目录，您会注意到Git将向对象数据库添加两个新对象。如果您完全按照上述步骤操作，则现在应该可以</target>
        </trans-unit>
        <trans-unit id="c9492aea4e59a8249b05f0197902254019664286" translate="yes" xml:space="preserve">
          <source>In fact, if you have &lt;code&gt;master&lt;/code&gt; checked out, then this branch has been configured by &lt;code&gt;git clone&lt;/code&gt; to get changes from the HEAD branch of the origin repository. So often you can accomplish the above with just a simple</source>
          <target state="translated">实际上，如果您已将 &lt;code&gt;master&lt;/code&gt; 检出，则 &lt;code&gt;git clone&lt;/code&gt; 已将该分支配置为从原始存储库的HEAD分支获取更改。因此，通常您只需一个简单的步骤即可完成上述操作</target>
        </trans-unit>
        <trans-unit id="c5bd224f8ecefe700eae1705d4f2a63ae227649f" translate="yes" xml:space="preserve">
          <source>In fact, in &lt;a href=&quot;#git-concepts&quot;&gt;Git concepts&lt;/a&gt; we shall see that everything stored in Git history, including file data and directory contents, is stored in an object with a name that is a hash of its contents.</source>
          <target state="translated">实际上，在&lt;a href=&quot;#git-concepts&quot;&gt;Git概念中，&lt;/a&gt;我们将看到Git历史记录中存储的所有内容（包括文件数据和目录内容）都存储在对象中，该对象的名称是其内容的哈希。</target>
        </trans-unit>
        <trans-unit id="9ce4601e5a5f52f186df099525d9504862a821c8" translate="yes" xml:space="preserve">
          <source>In fact, together with the &lt;code&gt;git rev-list&lt;/code&gt; program (which generates a list of revisions), &lt;code&gt;git diff-tree&lt;/code&gt; ends up being a veritable fount of changes. You can emulate &lt;code&gt;git log&lt;/code&gt;, &lt;code&gt;git log -p&lt;/code&gt;, etc. with a trivial script that pipes the output of &lt;code&gt;git rev-list&lt;/code&gt; to &lt;code&gt;git diff-tree --stdin&lt;/code&gt;, which was exactly how early versions of &lt;code&gt;git log&lt;/code&gt; were implemented.</source>
          <target state="translated">实际上，与 &lt;code&gt;git rev-list&lt;/code&gt; 程序（生成修订列表）一起， &lt;code&gt;git diff-tree&lt;/code&gt; 最终是名副其实的变更源。您可以使用简单的脚本模拟 &lt;code&gt;git log&lt;/code&gt; ， &lt;code&gt;git log -p&lt;/code&gt; 等，该脚本将 &lt;code&gt;git rev-list&lt;/code&gt; 的输出传递到 &lt;code&gt;git diff-tree --stdin&lt;/code&gt; ，这正是 &lt;code&gt;git log&lt;/code&gt; 的早期版本的实现方式。</target>
        </trans-unit>
        <trans-unit id="da9de14a63db6e5a8e5a19a81e9a6160f95eb222" translate="yes" xml:space="preserve">
          <source>In fact, we can perform all the normal Git operations. But, let&amp;rsquo;s look at what happens when we then checkout &lt;code&gt;master&lt;/code&gt;:</source>
          <target state="translated">实际上，我们可以执行所有正常的Git操作。但是，让我们看看当我们结帐 &lt;code&gt;master&lt;/code&gt; 时会发生什么：</target>
        </trans-unit>
        <trans-unit id="728d90294e037628a986d3380572564cc895d389" translate="yes" xml:space="preserve">
          <source>In future versions we may learn to support patterns containing \0 for more search backends, until then we&amp;rsquo;ll die when the pattern type in question doesn&amp;rsquo;t support them.</source>
          <target state="translated">在未来的版本中，我们可能会学习支持包含\ 0的模式以用于更多搜索后端，直到那时，如果所讨论的模式类型不支持它们，我们就会死掉。</target>
        </trans-unit>
        <trans-unit id="674a2666658c40a25d4cd65b3ea28af975f1fa97" translate="yes" xml:space="preserve">
          <source>In general a client can request to speak protocol v2 by sending &lt;code&gt;version=2&lt;/code&gt; through the respective side-channel for the transport being used which inevitably sets &lt;code&gt;GIT_PROTOCOL&lt;/code&gt;. More information can be found in &lt;code&gt;pack-protocol.txt&lt;/code&gt; and &lt;code&gt;http-protocol.txt&lt;/code&gt;. In all cases the response from the server is the capability advertisement.</source>
          <target state="translated">通常，客户端可以通过通过用于正在使用的传输的相应边信道发送 &lt;code&gt;version=2&lt;/code&gt; 来请求说出协议v2，这不可避免地会设置 &lt;code&gt;GIT_PROTOCOL&lt;/code&gt; 。可以在 &lt;code&gt;pack-protocol.txt&lt;/code&gt; 和 &lt;code&gt;http-protocol.txt&lt;/code&gt; 中找到更多信息。在所有情况下，服务器的响应都是能力通告。</target>
        </trans-unit>
        <trans-unit id="1aaa12db7c29bdac4538baf95940db6bed82a0b8" translate="yes" xml:space="preserve">
          <source>In general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository. Depending on the transport protocol, some of this information may be absent.</source>
          <target state="translated">一般来说,URL包含有关传输协议的信息、远程服务器的地址和通往存储库的路径。根据传输协议的不同,其中一些信息可能不存在。</target>
        </trans-unit>
        <trans-unit id="811906db3a55c059a1cd7d72b959827c93f94a02" translate="yes" xml:space="preserve">
          <source>In general, all pseudo refs are per working tree and all refs starting with &quot;refs/&quot; are shared. Pseudo refs are ones like HEAD which are directly under GIT_DIR instead of inside GIT_DIR/refs. There is one exception to this: refs inside refs/bisect and refs/worktree is not shared.</source>
          <target state="translated">一般来说,所有的伪参考都是每个工作树,所有以 &quot;refs/&quot;开头的参考都是共享的。伪 refs 是指像 HEAD 这样直接在 GIT_DIR 下的 refs,而不是在 GIT_DIR/refs 内。有一个例外:refs/bisect和refs/worktree里面的refs是不共享的。</target>
        </trans-unit>
        <trans-unit id="c1959905d09bef6c12ae8c7983e3b002ca1126c5" translate="yes" xml:space="preserve">
          <source>In general, all pseudo refs are per working tree and all refs starting with &lt;code&gt;refs/&lt;/code&gt; are shared. Pseudo refs are ones like &lt;code&gt;HEAD&lt;/code&gt; which are directly under &lt;code&gt;$GIT_DIR&lt;/code&gt; instead of inside &lt;code&gt;$GIT_DIR/refs&lt;/code&gt;. There are exceptions, however: refs inside &lt;code&gt;refs/bisect&lt;/code&gt; and &lt;code&gt;refs/worktree&lt;/code&gt; are not shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e394e7bf320940c252fcc858f73aeff38e0e3c05" translate="yes" xml:space="preserve">
          <source>In general, it is better to enumerate existing objects with problems with &lt;code&gt;fsck.skipList&lt;/code&gt;, instead of listing the kind of breakages these problematic objects share to be ignored, as doing the latter will allow new instances of the same breakages go unnoticed.</source>
          <target state="translated">通常，最好使用 &lt;code&gt;fsck.skipList&lt;/code&gt; 枚举有问题的现有对象，而不是列出这些有问题的对象共享的损坏类型，因为这样做会忽略相同损坏的新实例。</target>
        </trans-unit>
        <trans-unit id="7dc03507399a3b4938c051e86309da2b5ba01f5b" translate="yes" xml:space="preserve">
          <source>In general, the interrogate commands do not touch the files in the working tree.</source>
          <target state="translated">一般情况下,询问命令不会触及工作树中的文件。</target>
        </trans-unit>
        <trans-unit id="0830c69bce9b1a4ab3ff9dbb3ca0e63e381af048" translate="yes" xml:space="preserve">
          <source>In general, using</source>
          <target state="translated">一般来说,使用</target>
        </trans-unit>
        <trans-unit id="37034b2d8b34e79ca4767d593d59ca39d0651fd5" translate="yes" xml:space="preserve">
          <source>In here all submodules except &lt;code&gt;baz&lt;/code&gt; (foo, bar, bob) are active. &lt;code&gt;foo&lt;/code&gt; due to its own active flag and all the others due to the submodule active pathspec, which specifies that any submodule starting with &lt;code&gt;b&lt;/code&gt; except &lt;code&gt;baz&lt;/code&gt; are also active, regardless of the presence of the .url field.</source>
          <target state="translated">在这里，除 &lt;code&gt;baz&lt;/code&gt; （foo，bar，bob）之外的所有子模块都处于活动状态。 &lt;code&gt;foo&lt;/code&gt; 由于其自己的活动标志而所有其他原因归因于子模块的活动pathspec，它指定了除 &lt;code&gt;baz&lt;/code&gt; 以外以 &lt;code&gt;b&lt;/code&gt; 开头的任何子模块也都处于活动状态，而不管是否存在.url字段。</target>
        </trans-unit>
        <trans-unit id="f129c819372eb3b42173e4b2d9e114ef285b7635" translate="yes" xml:space="preserve">
          <source>In interactive commands, allow the user to provide one-letter input with a single key (i.e., without hitting enter). Currently this is used by the &lt;code&gt;--patch&lt;/code&gt; mode of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;, &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;, &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;, and &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;. Note that this setting is silently ignored if portable keystroke input is not available; requires the Perl module Term::ReadKey.</source>
          <target state="translated">在交互式命令中，允许用户使用单个键提供一个字母的输入（即，无需按回车键）。当前，它由&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;，&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;，&lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt;，&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;，&lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt;和&lt;a href=&quot;git-stash&quot;&gt;git-stash&lt;/a&gt;的 &lt;code&gt;--patch&lt;/code&gt; 模式使用[1]。请注意，如果便携式按键输入不可用，此设置将被忽略。需要Perl模块Term :: ReadKey。</target>
        </trans-unit>
        <trans-unit id="1d1c8ed607ef3eefbb04beacb314688e02741550" translate="yes" xml:space="preserve">
          <source>In interactive mode, you can mark commits with the action &quot;edit&quot;. However, this does not necessarily mean that &lt;code&gt;git rebase&lt;/code&gt; expects the result of this edit to be exactly one commit. Indeed, you can undo the commit, or you can add other commits. This can be used to split a commit into two:</source>
          <target state="translated">在交互模式下，您可以使用操作&amp;ldquo; edit&amp;rdquo;标记提交。但是，这并不一定意味着 &lt;code&gt;git rebase&lt;/code&gt; 期望此编辑的结果恰好是一次提交。实际上，您可以撤消提交，也可以添加其他提交。这可用于将提交分为两部分：</target>
        </trans-unit>
        <trans-unit id="15b1add937944ed893f52c8ec0293a4127b76c00" translate="yes" xml:space="preserve">
          <source>In its first form, the command provides the content or the type of an object in the repository. The type is required unless &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; is used to find the object type, or &lt;code&gt;-s&lt;/code&gt; is used to find the object size, or &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt; is used (which imply type &quot;blob&quot;).</source>
          <target state="translated">在第一种形式中，命令提供存储库中对象的内容或类型。除非使用 &lt;code&gt;-t&lt;/code&gt; 或 &lt;code&gt;-p&lt;/code&gt; 查找对象类型，或者使用 &lt;code&gt;-s&lt;/code&gt; 查找对象大小，或者使用 &lt;code&gt;--textconv&lt;/code&gt; 或 &lt;code&gt;--filters&lt;/code&gt; （暗示类型为&amp;ldquo; blob&amp;rdquo;），否则该类型是必需的。</target>
        </trans-unit>
        <trans-unit id="1ce9842f8f482fa7cd77bb4bd4603b72b75e4e0b" translate="yes" xml:space="preserve">
          <source>In its most compact form, this instruction only takes up one byte (0x80) with both offset and size omitted, which will have default values zero. There is another exception: size zero is automatically converted to 0x10000.</source>
          <target state="translated">在最紧凑的形式下,这条指令只占用一个字节(0x80),偏移量和大小都被省略,它的默认值将为零。还有一个例外:大小为零会自动转换为0x10000。</target>
        </trans-unit>
        <trans-unit id="ed6a0138b63bece5f8693e0a03055de4444b4006" translate="yes" xml:space="preserve">
          <source>In its simplest form, &lt;code&gt;git worktree add &amp;lt;path&amp;gt;&lt;/code&gt; automatically creates a new branch whose name is the final component of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, which is convenient if you plan to work on a new topic. For instance, &lt;code&gt;git
worktree add ../hotfix&lt;/code&gt; creates new branch &lt;code&gt;hotfix&lt;/code&gt; and checks it out at path &lt;code&gt;../hotfix&lt;/code&gt;. To instead work on an existing branch in a new working tree, use &lt;code&gt;git worktree add &amp;lt;path&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt;. On the other hand, if you just plan to make some experimental changes or do testing without disturbing existing development, it is often convenient to create a &lt;code&gt;throwaway&lt;/code&gt; working tree not associated with any branch. For instance, &lt;code&gt;git worktree add -d &amp;lt;path&amp;gt;&lt;/code&gt; creates a new working tree with a detached &lt;code&gt;HEAD&lt;/code&gt; at the same commit as the current branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70413e1dbdf33a9cdd6044f089c7e374f7b737c4" translate="yes" xml:space="preserve">
          <source>In mathematical terms, what we are looking for is some sort of a minimum cost bipartite matching; &lt;code&gt;1&lt;/code&gt; is matched to &lt;code&gt;C&lt;/code&gt; at some cost, etc. The underlying graph is in fact a complete bipartite graph; the cost we associate with every edge is the size of the diff between the two commits' patches. To explain also new commits, we introduce dummy nodes on both sides:</source>
          <target state="translated">用数学术语来说，我们正在寻找的是某种最低成本的双向匹配。 &lt;code&gt;1&lt;/code&gt; 在某种程度上与 &lt;code&gt;C&lt;/code&gt; 匹配，等等。基础图实际上是一个完整的二部图。我们与每个边缘相关联的成本是两次提交的补丁之间差异的大小。为了解释新提交，我们在两侧都引入了虚拟节点：</target>
        </trans-unit>
        <trans-unit id="abc4a2c282027431dbb87981bf40f5240785d9ef" translate="yes" xml:space="preserve">
          <source>In modern git, you can say this in a more direct way:</source>
          <target state="translated">在现代git中,你可以用更直接的方式来表达。</target>
        </trans-unit>
        <trans-unit id="1cd9dc714cc1317fe8fea12649b27b5eeab6e568" translate="yes" xml:space="preserve">
          <source>In most cases, this means the attributes given in the input will be repeated in the output, but Git may also modify the credential description, for example by removing the &lt;code&gt;path&lt;/code&gt; attribute when the protocol is HTTP(s) and &lt;code&gt;credential.useHttpPath&lt;/code&gt; is false.</source>
          <target state="translated">在大多数情况下，这意味着输入中给定的属性将在输出中重复，但是Git可能还会修改凭据描述，例如，当协议为HTTP并且 &lt;code&gt;credential.useHttpPath&lt;/code&gt; 为.useHttpPath为false 时，通过删除 &lt;code&gt;path&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="c12479d09bff69f421dbf9e45fddc92269d1f574" translate="yes" xml:space="preserve">
          <source>In most cases, users should run &lt;em&gt;git gc&lt;/em&gt;, which calls &lt;em&gt;git prune&lt;/em&gt;. See the section &quot;NOTES&quot;, below.</source>
          <target state="translated">在大多数情况下，用户应运行&lt;em&gt;git gc&lt;/em&gt;，它调用&lt;em&gt;git prune&lt;/em&gt;。请参阅下面的&amp;ldquo;注意&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="6d4e8e52070be526725731839d6ade7553803d5e" translate="yes" xml:space="preserve">
          <source>In most cases, users will not need to call &lt;code&gt;git prune&lt;/code&gt; directly, but should instead call &lt;code&gt;git gc&lt;/code&gt;, which handles pruning along with many other housekeeping tasks.</source>
          <target state="translated">在大多数情况下，用户不需要直接调用 &lt;code&gt;git prune&lt;/code&gt; ，而应调用 &lt;code&gt;git gc&lt;/code&gt; ，它可以处理修剪以及许多其他内部管理任务。</target>
        </trans-unit>
        <trans-unit id="7de19f518cc5353753469bfb19c4e4f93734f02e" translate="yes" xml:space="preserve">
          <source>In multiple working trees, some refs may be shared between all working trees and some refs are local. One example is &lt;code&gt;HEAD&lt;/code&gt; which is different for each working tree. This section is about the sharing rules and how to access refs of one working tree from another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1d2a97ebd3bb9e2d938b11b92fc4a8e0c826fa" translate="yes" xml:space="preserve">
          <source>In multiple working trees, some refs may be shared between all working trees, some refs are local. One example is HEAD is different for all working trees. This section is about the sharing rules and how to access refs of one working tree from another.</source>
          <target state="translated">在多个工作树中,有些参照物可能是所有工作树之间共享的,有些参照物是本地的。其中一个例子是HEAD对于所有工作树来说都是不同的,这一节是关于共享规则和如何从另一工作树访问一个工作树的refs。本节主要介绍共享规则以及如何从另一棵工作树中访问一棵工作树的 refs。</target>
        </trans-unit>
        <trans-unit id="fef9e754382e4f5002bb7f83483631df5de227e1" translate="yes" xml:space="preserve">
          <source>In older Git versions it could be easily forgotten to commit new or modified files in a submodule, which silently leads to similar problems as not pushing the submodule changes. Starting with Git 1.7.0 both &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git diff&lt;/code&gt; in the superproject show submodules as modified when they contain new or modified files to protect against accidentally committing such a state. &lt;code&gt;git
diff&lt;/code&gt; will also add a &lt;code&gt;-dirty&lt;/code&gt; to the work tree side when generating patch output or used with the &lt;code&gt;--submodule&lt;/code&gt; option:</source>
          <target state="translated">在较早的Git版本中，很容易忘记在子模块中提交新文件或修改过的文件，这无声地导致了类似的问题，因为没有推送子模块的更改。从Git 1.7.0开始，超级项目中的 &lt;code&gt;git status&lt;/code&gt; 和 &lt;code&gt;git diff&lt;/code&gt; 都会在子模块包含新文件或已修改文件时将其显示为已修改，以防止意外提交这种状态。 &lt;code&gt;git diff&lt;/code&gt; 也将增加一个 &lt;code&gt;-dirty&lt;/code&gt; 生成补丁输出或与使用时的工作树边 &lt;code&gt;--submodule&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="cea51be0687534aeac695491ce11f4552163d8c9" translate="yes" xml:space="preserve">
          <source>In order to allow extensions that add extra data to the MIDX, we organize the body into &quot;chunks&quot; and provide a lookup table at the beginning of the body. The header includes certain length values, such as the number of packs, the number of base MIDX files, hash lengths and types.</source>
          <target state="translated">为了允许在MIDX中添加额外数据的扩展,我们将正文组织成 &quot;块&quot;,并在正文的开头提供一个查找表。头部包括一定的长度值,如包的数量、基础MIDX文件的数量、哈希长度和类型。</target>
        </trans-unit>
        <trans-unit id="f6b8f2c2e89120a466dd40e221531b6adf7a10b9" translate="yes" xml:space="preserve">
          <source>In order to determine what URL to use to fetch from, the value of the configuration &lt;code&gt;remote.&amp;lt;origin&amp;gt;.url&lt;/code&gt; is consulted and if there is not any such variable, the value on the &lt;code&gt;URL:&lt;/code&gt; line in &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; is used.</source>
          <target state="translated">为了确定要使用的URL，请查询配置 &lt;code&gt;remote.&amp;lt;origin&amp;gt;.url&lt;/code&gt; 值，如果没有任何此类变量，则 &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; &lt;code&gt;URL:&lt;/code&gt; 行上的值&amp;gt;被使用。</target>
        </trans-unit>
        <trans-unit id="1bb65c849d69cb9e41866b99d141938531c8bf39" translate="yes" xml:space="preserve">
          <source>In order to determine what remote branches to fetch (and optionally store in the remote-tracking branches) when the command is run without any refspec parameters on the command line, values of the configuration variable &lt;code&gt;remote.&amp;lt;origin&amp;gt;.fetch&lt;/code&gt; are consulted, and if there aren&amp;rsquo;t any, &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; is consulted and its &lt;code&gt;Pull:&lt;/code&gt; lines are used. In addition to the refspec formats described in the OPTIONS section, you can have a globbing refspec that looks like this:</source>
          <target state="translated">为了确定在命令行上没有任何refspec参数的情况下运行命令时要获取的远程分支（并有选择地存储在远程跟踪分支中），请查询配置变量 &lt;code&gt;remote.&amp;lt;origin&amp;gt;.fetch&lt;/code&gt; 的值，以及如果没有，则查询 &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; 并使用其 &lt;code&gt;Pull:&lt;/code&gt; 行。除了&amp;ldquo;选项&amp;rdquo;部分中描述的refspec格式外，您还可以使用如下所示的lobref refspec：</target>
        </trans-unit>
        <trans-unit id="b571757e7fe93a92c37f6bdbb5b1d110de433e8f" translate="yes" xml:space="preserve">
          <source>In order to ensure a current tracking branch state, &lt;code&gt;update --remote&lt;/code&gt; fetches the submodule&amp;rsquo;s remote repository before calculating the SHA-1. If you don&amp;rsquo;t want to fetch, you should use &lt;code&gt;submodule update
--remote --no-fetch&lt;/code&gt;.</source>
          <target state="translated">为了确保当前跟踪分支状态，在计算SHA-1之前， &lt;code&gt;update --remote&lt;/code&gt; 将获取子模块的远程存储库。如果您不想获取，则应使用 &lt;code&gt;submodule update --remote --no-fetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ecc869f1231e06aba76a745114504d0b9155917" translate="yes" xml:space="preserve">
          <source>In order to have configuration specific to working trees, you can turn on &quot;worktreeConfig&quot; extension, e.g.:</source>
          <target state="translated">为了拥有特定于工作树的配置,你可以打开 &quot;worktreeConfig &quot;扩展,例如。</target>
        </trans-unit>
        <trans-unit id="1e42ca6d9de6de9f8c6bfadac339f32432bf0913" translate="yes" xml:space="preserve">
          <source>In order to have configuration specific to working trees, you can turn on the &lt;code&gt;worktreeConfig&lt;/code&gt; extension, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb76ce16c3a3c52ec0347fc95609ba6324ad6c16" translate="yes" xml:space="preserve">
          <source>In order to protect the privacy of objects that have been removed from history but may not yet have been pruned, &lt;code&gt;git-upload-archive&lt;/code&gt; avoids serving archives for commits and trees that are not reachable from the repository&amp;rsquo;s refs. However, because calculating object reachability is computationally expensive, &lt;code&gt;git-upload-archive&lt;/code&gt; implements a stricter but easier-to-check set of rules:</source>
          <target state="translated">为了保护已从历史记录中删除但尚未被修剪的对象的私密性， &lt;code&gt;git-upload-archive&lt;/code&gt; 避免为无法从存储库的引用访问的提交和树提供归档。但是，由于计算对象的可到达性在计算上非常昂贵，因此 &lt;code&gt;git-upload-archive&lt;/code&gt; 实现了一套更严格但更易于检查的规则：</target>
        </trans-unit>
        <trans-unit id="17696fe6311cd47e2efc1108f911bdeb8c2c0989" translate="yes" xml:space="preserve">
          <source>In order to set &quot;assume unchanged&quot; bit, use &lt;code&gt;--assume-unchanged&lt;/code&gt; option. To unset, use &lt;code&gt;--no-assume-unchanged&lt;/code&gt;. To see which files have the &quot;assume unchanged&quot; bit set, use &lt;code&gt;git ls-files -v&lt;/code&gt; (see &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt;).</source>
          <target state="translated">为了设置&amp;ldquo;假定不变&amp;rdquo;位，请使用 &lt;code&gt;--assume-unchanged&lt;/code&gt; 选项。要取消设置，请使用 &lt;code&gt;--no-assume-unchanged&lt;/code&gt; 。要查看设置了&amp;ldquo;假定未更改&amp;rdquo;位 &lt;code&gt;git ls-files -v&lt;/code&gt; ，请使用git ls-files -v（请参阅&lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="267b1e8e9ade7b3919e26586bb280b53787cfd98" translate="yes" xml:space="preserve">
          <source>In other messages Andreas says that they also use the &quot;best practices&quot; described above: small logical commits, topic branches, no evil merge,&amp;hellip;​ These practices all improve the bisectability of the commit graph, by making it easier and more useful to bisect.</source>
          <target state="translated">在其他消息中，安德烈亚斯（Andreas）表示他们还使用上述的``最佳实践''：小的逻辑提交，主题分支，没有邪恶的合并.........这些实践都通过使二等分变得更容易和有用，从而提高了提交图的二等分性。 。</target>
        </trans-unit>
        <trans-unit id="cbba08cd602a94910294469b1bfe69221cf43d34" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;--merge&lt;/code&gt; does something like a &lt;code&gt;git read-tree -u -m &amp;lt;commit&amp;gt;&lt;/code&gt;, but carries forward unmerged index entries.</source>
          <target state="translated">换句话说，-- &lt;code&gt;--merge&lt;/code&gt; 类似于 &lt;code&gt;git read-tree -u -m &amp;lt;commit&amp;gt;&lt;/code&gt; ，但是会携带未合并的索引条目。</target>
        </trans-unit>
        <trans-unit id="2c3347c08edbf67732cb77724b9990f6671bac50" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;git diff-files&lt;/code&gt; always shows us the difference between what is recorded in the index, and what is currently in the working tree. That&amp;rsquo;s very useful.</source>
          <target state="translated">换句话说， &lt;code&gt;git diff-files&lt;/code&gt; 总是向我们显示索引中记录的内容与工作树中当前记录之间的差异。这非常有用。</target>
        </trans-unit>
        <trans-unit id="7466e77eb24cbec56937901c0950f635d6a29d08" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;git diff-index&lt;/code&gt; normally compares a tree against the working tree, but when given the &lt;code&gt;--cached&lt;/code&gt; flag, it is told to instead compare against just the index cache contents, and ignore the current working tree state entirely. Since we just wrote the index file to HEAD, doing &lt;code&gt;git diff-index --cached -p HEAD&lt;/code&gt; should thus return an empty set of differences, and that&amp;rsquo;s exactly what it does.</source>
          <target state="translated">换句话说， &lt;code&gt;git diff-index&lt;/code&gt; 通常将树与工作树进行比较，但是当给 &lt;code&gt;--cached&lt;/code&gt; 标志时，将告诉它仅与索引缓存内容进行比较，并完全忽略当前工作树状态。由于我们只是将索引文件写入了HEAD，因此执行 &lt;code&gt;git diff-index --cached -p HEAD&lt;/code&gt; 应该会返回一组空的差异，这正是它的作用。</target>
        </trans-unit>
        <trans-unit id="8c2ef787b7de3a9f3b5df9786c452fde9692465e" translate="yes" xml:space="preserve">
          <source>In other words, there is no need to worry about what exists only in the working tree. When you have local changes in a part of the project that is not involved in the merge, your changes do not interfere with the merge, and are kept intact. When they &lt;strong&gt;do&lt;/strong&gt; interfere, the merge does not even start (&lt;code&gt;git read-tree&lt;/code&gt; complains loudly and fails without modifying anything). In such a case, you can simply continue doing what you were in the middle of doing, and when your working tree is ready (i.e. you have finished your work-in-progress), attempt the merge again.</source>
          <target state="translated">换句话说，无需担心仅存在于工作树中的内容。当您在项目中不参与合并的部分进行本地更改时，您的更改不会干扰合并，并且会保持原样。当它们&lt;strong&gt;确实&lt;/strong&gt;干扰时，合并甚至不会开始（ &lt;code&gt;git read-tree&lt;/code&gt; 大声抱怨，并且在不进行任何修改的情况下失败）。在这种情况下，您可以简单地继续进行操作，然后在工作树准备就绪（即，您已经完成正在进行的工作）后，再次尝试合并。</target>
        </trans-unit>
        <trans-unit id="5a674f35b2eda0a90a7f397ea7dadc5a212b7275" translate="yes" xml:space="preserve">
          <source>In other words, while a &quot;tree&quot; represents a particular directory state of a working directory, a &quot;commit&quot; represents that state in time, and explains how we got there.</source>
          <target state="translated">换句话说,&quot;树 &quot;代表了一个工作目录的特定目录状态,而 &quot;提交 &quot;则代表了这个状态的时间,并解释了我们是如何到达那里的。</target>
        </trans-unit>
        <trans-unit id="857191c898a7fbefd37c145d86f76b0005dd57eb" translate="yes" xml:space="preserve">
          <source>In other words, you can easily validate a whole archive by just sending out a single email that tells the people the name (SHA-1 hash) of the top commit, and digitally sign that email using something like GPG/PGP.</source>
          <target state="translated">换句话说,你可以很容易地验证整个存档,只需发送一封邮件,告诉人们顶级提交的名称(SHA-1哈希值),并使用类似GPG/PGP的数字签名。</target>
        </trans-unit>
        <trans-unit id="e52122aac7e01b0550d02d6bfc5c4fbaa85b48ac" translate="yes" xml:space="preserve">
          <source>In our example of only two files, we did not have unchanged files so only &lt;code&gt;example&lt;/code&gt; resulted in collapsing. But in real-life large projects, when only a small number of files change in one commit, this &lt;code&gt;collapsing&lt;/code&gt; tends to trivially merge most of the paths fairly quickly, leaving only a handful of real changes in non-zero stages.</source>
          <target state="translated">在只有两个文件的示例中，我们没有不变的文件，因此只有 &lt;code&gt;example&lt;/code&gt; 导致崩溃。但是在现实生活中的大型项目中，当一次提交中只有少量文件发生更改时，这种 &lt;code&gt;collapsing&lt;/code&gt; 往往会相当快地琐碎地合并大多数路径，而在非零阶段仅留下少量实际更改。</target>
        </trans-unit>
        <trans-unit id="a3569415a118c16e9c5d7e18e58096bbd8336f98" translate="yes" xml:space="preserve">
          <source>In our example, when you do the test merge, the manual resolution is recorded, and it will be reused when you do the actual merge later with the updated master and topic branch, as long as the recorded resolution is still applicable.</source>
          <target state="translated">在我们的例子中,当你进行测试合并时,手动的解析会被记录下来,以后进行实际合并时,只要记录的解析还适用,更新的主分支和主题分支就会被重复使用。</target>
        </trans-unit>
        <trans-unit id="8e5ca17ff33890ba6e129c741e431196f019fa29" translate="yes" xml:space="preserve">
          <source>In overlay mode, the command never removes files when restoring. In no-overlay mode, tracked files that do not appear in the &lt;code&gt;--source&lt;/code&gt; tree are removed, to make them match &lt;code&gt;&amp;lt;tree&amp;gt;&lt;/code&gt; exactly. The default is no-overlay mode.</source>
          <target state="translated">在覆盖模式下，该命令从不会在还原时删除文件。在无覆盖模式下，将删除未显示在 &lt;code&gt;--source&lt;/code&gt; 树中的跟踪文件，以使其与 &lt;code&gt;&amp;lt;tree&amp;gt;&lt;/code&gt; 完全匹配。默认为无覆盖模式。</target>
        </trans-unit>
        <trans-unit id="5b1c0d5c1dcebbb2369ea9f003ec30402ee8a395" translate="yes" xml:space="preserve">
          <source>In particular, let&amp;rsquo;s not even check in the two files into Git yet, we&amp;rsquo;ll start off by adding another line to &lt;code&gt;hello&lt;/code&gt; first:</source>
          <target state="translated">特别是，我们什至不将两个文件都检入到Git中，我们首先要向 &lt;code&gt;hello&lt;/code&gt; 添加另一行：</target>
        </trans-unit>
        <trans-unit id="d0e454374a9a3ee3d6a441cd0674139a3f061022" translate="yes" xml:space="preserve">
          <source>In particular, the &lt;code&gt;refs&lt;/code&gt; subdirectory will contain two other subdirectories, named &lt;code&gt;heads&lt;/code&gt; and &lt;code&gt;tags&lt;/code&gt; respectively. They do exactly what their names imply: they contain references to any number of different &lt;code&gt;heads&lt;/code&gt; of development (aka &lt;code&gt;branches&lt;/code&gt;), and to any &lt;code&gt;tags&lt;/code&gt; that you have created to name specific versions in your repository.</source>
          <target state="translated">特别是， &lt;code&gt;refs&lt;/code&gt; 子目录将包含另外两个子目录，分别称为 &lt;code&gt;heads&lt;/code&gt; 和 &lt;code&gt;tags&lt;/code&gt; 。它们完全按照其名称所隐含的含义进行操作：它们包含对许多不同的开发 &lt;code&gt;heads&lt;/code&gt; 人（即aka &lt;code&gt;branches&lt;/code&gt; ）的引用，以及对您创建的用于在存储库中命名特定版本的任何 &lt;code&gt;tags&lt;/code&gt; 引用。</target>
        </trans-unit>
        <trans-unit id="2037a0a7d55894c0e552cd3905604e14aef5f5cc" translate="yes" xml:space="preserve">
          <source>In practice, you can interleave and repeat steps 1 and 2 as many times as you want: in order to keep track of what you want committed at step 3, Git maintains a snapshot of the tree&amp;rsquo;s contents in a special staging area called &quot;the index.&quot;</source>
          <target state="translated">实际上，您可以根据需要交错和重复执行步骤1和2多次：为了跟踪在步骤3中要提交的内容，Git在称为&amp;ldquo;索引&amp;rdquo;的特殊暂存区中维护树内容的快照。 &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f0e4ad3997791ffc68facd5c602055afb63229a5" translate="yes" xml:space="preserve">
          <source>In principle, a note is a regular Git blob, and any kind of (non-)format is accepted. You can binary-safely create notes from arbitrary files using &lt;code&gt;git hash-object&lt;/code&gt;:</source>
          <target state="translated">原则上，音符是常规的Git Blob，并且可以接受任何类型的（非）格式。您可以使用 &lt;code&gt;git hash-object&lt;/code&gt; 从任意文件二进制安全地创建注释：</target>
        </trans-unit>
        <trans-unit id="4601fb728bee4aeccfe338414983070eaafe0d7b" translate="yes" xml:space="preserve">
          <source>In protocol v2 communication is command oriented. When first contacting a server a list of capabilities will advertised. Some of these capabilities will be commands which a client can request be executed. Once a command has completed, a client can reuse the connection and request that other commands be executed.</source>
          <target state="translated">在协议v2中,通信是面向命令的。当第一次与服务器联系时,将公布一个能力列表。其中一些功能是客户端可以请求执行的命令。一旦一个命令完成,客户端可以重新使用连接并请求执行其他命令。</target>
        </trans-unit>
        <trans-unit id="f1e89ddf0408f3e3f9aa71b3da7906ab579cf106" translate="yes" xml:space="preserve">
          <source>In protocol v2 these special packets will have the following semantics:</source>
          <target state="translated">在协议v2中,这些特殊数据包将具有以下语义。</target>
        </trans-unit>
        <trans-unit id="0b2a25ba5b09240510379a9523ee7fbbaeebe9c6" translate="yes" xml:space="preserve">
          <source>In some cases it is possible that the new head will &lt;strong&gt;not&lt;/strong&gt; actually be a descendant of the old head. For example, the developer may have realized she made a serious mistake, and decided to backtrack, resulting in a situation like:</source>
          <target state="translated">在某些情况下，新头实际上可能&lt;strong&gt;不是&lt;/strong&gt;旧头的后代。例如，开发人员可能已经意识到她犯了一个严重的错误，并决定回溯，从而导致如下情况：</target>
        </trans-unit>
        <trans-unit id="013d925394580efad8fc98d09cd78b65808be1a0" translate="yes" xml:space="preserve">
          <source>In some cases like for kernel development it can be worth developing complex scripts to be able to fully automate bisecting.</source>
          <target state="translated">在某些情况下,比如内核开发,值得开发复杂的脚本,以便能够完全自动化地进行二分法。</target>
        </trans-unit>
        <trans-unit id="0a49ce3de43e8ee8d78f327f1f504c6a86228a99" translate="yes" xml:space="preserve">
          <source>In some situations the reflog may not be able to save you. For example, suppose you delete a branch, then realize you need the history it contained. The reflog is also deleted; however, if you have not yet pruned the repository, then you may still be able to find the lost commits in the dangling objects that &lt;code&gt;git fsck&lt;/code&gt; reports. See &lt;a href=&quot;#dangling-objects&quot;&gt;Dangling objects&lt;/a&gt; for the details.</source>
          <target state="translated">在某些情况下，引用日志可能无法保存您。例如，假设您删除了一个分支，然后意识到您需要该分支包含的历史记录。引用日志也被删除；但是，如果尚未修剪存储库，则仍然可以在 &lt;code&gt;git fsck&lt;/code&gt; 报告的悬挂对象中找到丢失的提交。有关详细信息，请参见&lt;a href=&quot;#dangling-objects&quot;&gt;悬挂对象&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f2c24901ef5f6fa3a7b78ff609de06af9cfd2f7" translate="yes" xml:space="preserve">
          <source>In sparse checkout mode, &lt;code&gt;git checkout -- &amp;lt;paths&amp;gt;&lt;/code&gt; would update only entries matched by &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; and sparse patterns in &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt;. This option ignores the sparse patterns and adds back any files in &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在稀疏签出模式下， &lt;code&gt;git checkout -- &amp;lt;paths&amp;gt;&lt;/code&gt; 将仅更新与 &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; 匹配的条目以及 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 稀疏模式。此选项将忽略稀疏模式，并添加回 &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; 中的所有文件。</target>
        </trans-unit>
        <trans-unit id="91e2068ee07240a386da6a01584d7cb7bf48667f" translate="yes" xml:space="preserve">
          <source>In sparse checkout mode, by default is to only update entries matched by &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; and sparse patterns in $GIT_DIR/info/sparse-checkout. This option ignores the sparse patterns and unconditionally restores any files in &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在稀疏签出模式下，默认情况下仅更新$ GIT_DIR / info / sparse-checkout中与 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 匹配的条目和稀疏模式。此选项将忽略稀疏模式，并无条件还原 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 中的所有文件。</target>
        </trans-unit>
        <trans-unit id="9805e95abc4cc7297991de78ec147328f379f9f9" translate="yes" xml:space="preserve">
          <source>In such a case, &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; would return the parent of B0 in the above picture, but B0^..D is &lt;strong&gt;not&lt;/strong&gt; the range of commits you would want to replay on top of B (it includes B0, which is not what you wrote; it is a commit the other side discarded when it moved its tip from B0 to B1).</source>
          <target state="translated">在这种情况下， &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; 将返回上图中的B0的父级，但是B0 ^ .. D &lt;strong&gt;并不是&lt;/strong&gt;您想在B之上重播的提交范围（它包括B0，这不是您写的内容；它是另一端在将其笔尖从B0移至B1时放弃的提交）。</target>
        </trans-unit>
        <trans-unit id="38c59b4cda1fb890b6373e0ee120752a69f46faf" translate="yes" xml:space="preserve">
          <source>In such a case, you can &quot;unwrap&quot; the tag yourself before feeding it to &lt;code&gt;git merge&lt;/code&gt;, or pass &lt;code&gt;--ff-only&lt;/code&gt; when you do not have any work on your own. e.g.</source>
          <target state="translated">在这种情况下，您可以在将标签提供给 &lt;code&gt;git merge&lt;/code&gt; 之前自己&amp;ldquo;解开&amp;rdquo;标签，或者 &lt;code&gt;--ff-only&lt;/code&gt; 在没有任何工作时才传递--ff-。例如</target>
        </trans-unit>
        <trans-unit id="122c6a9f6232138a6047defa817d1eec04cb3f10" translate="yes" xml:space="preserve">
          <source>In such a case, you do not want to automatically follow the other person&amp;rsquo;s tags.</source>
          <target state="translated">在这种情况下，您不想自动关注其他人的标签。</target>
        </trans-unit>
        <trans-unit id="14b066e7c220e701d278a048087bd2ff212888b8" translate="yes" xml:space="preserve">
          <source>In such cases it can be very confusing to use the terms &quot;good&quot; and &quot;bad&quot; to refer to &quot;the state before the change&quot; and &quot;the state after the change&quot;. So instead, you can use the terms &quot;old&quot; and &quot;new&quot;, respectively, in place of &quot;good&quot; and &quot;bad&quot;. (But note that you cannot mix &quot;good&quot; and &quot;bad&quot; with &quot;old&quot; and &quot;new&quot; in a single session.)</source>
          <target state="translated">在这种情况下,如果用 &quot;好 &quot;和 &quot;坏 &quot;来指代 &quot;变化前的状态 &quot;和 &quot;变化后的状态&quot;,会让人非常困惑。所以,你可以分别用 &quot;旧 &quot;和 &quot;新 &quot;来代替 &quot;好 &quot;和 &quot;坏&quot;。但要注意的是,不能在一个环节中把 &quot;好 &quot;和 &quot;坏 &quot;与 &quot;旧 &quot;和 &quot;新 &quot;混合使用)。</target>
        </trans-unit>
        <trans-unit id="abac94a936763ce45a21b8291dbe11f8fcd73ae6" translate="yes" xml:space="preserve">
          <source>In such cases, git-cherry shows a concise summary of what has yet to be applied:</source>
          <target state="translated">在这种情况下,git-cherry会显示出尚未应用的简明摘要。</target>
        </trans-unit>
        <trans-unit id="46cccce64f7cd9f50066dd3d9623630b5fee1925" translate="yes" xml:space="preserve">
          <source>In that case, &lt;code&gt;git pull&lt;/code&gt; can do the fetch and merge in one go, as follows.</source>
          <target state="translated">在这种情况下， &lt;code&gt;git pull&lt;/code&gt; 可以一次性进行提取和合并，如下所示。</target>
        </trans-unit>
        <trans-unit id="52b267d7dd12ef4e2f7423310ff8cbe9ef5b3665" translate="yes" xml:space="preserve">
          <source>In that case, the fix is easy because &lt;code&gt;git rebase&lt;/code&gt; knows to skip changes that are already present in the new upstream (unless &lt;code&gt;--reapply-cherry-picks&lt;/code&gt; is given). So if you say (assuming you&amp;rsquo;re on &lt;code&gt;topic&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724c7d4dfedb54b8a53a948ec5bdabaee78995fb" translate="yes" xml:space="preserve">
          <source>In that case, the fix is easy because &lt;code&gt;git rebase&lt;/code&gt; knows to skip changes that are already present in the new upstream. So if you say (assuming you&amp;rsquo;re on &lt;code&gt;topic&lt;/code&gt;)</source>
          <target state="translated">在这种情况下，修复很容易，因为 &lt;code&gt;git rebase&lt;/code&gt; 知道跳过新上游中已经存在的更改。因此，如果您说（假设您正在讨论 &lt;code&gt;topic&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e2f5cdfecd5b61a82b453fde83701ee64b8d8237" translate="yes" xml:space="preserve">
          <source>In that case, you can still force Git to update to the new head, as described in the following section. However, note that in the situation above this may mean losing the commits labeled &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, unless you&amp;rsquo;ve already created a reference of your own pointing to them.</source>
          <target state="translated">在这种情况下，您仍然可以强制Git更新到新的磁头，如以下部分所述。但是，请注意，在上述情况下，这可能意味着丢失标 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的提交，除非您已经创建了自己指向它们的引用。</target>
        </trans-unit>
        <trans-unit id="23201c1eda40e4016771870c9d54dd5324857456" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;git push&lt;/code&gt; command above we specify the name of the remote branch to update (&lt;code&gt;master&lt;/code&gt;). If we leave that out, &lt;code&gt;git push&lt;/code&gt; tries to update any branches in the remote repository that have the same name as a branch in the local repository. So the last &lt;code&gt;push&lt;/code&gt; can be done with either of:</source>
          <target state="translated">在上面的 &lt;code&gt;git push&lt;/code&gt; 命令中，我们指定要更新的远程分支的名称（ &lt;code&gt;master&lt;/code&gt; ）。如果我们不考虑这一点，则 &lt;code&gt;git push&lt;/code&gt; 会尝试更新远程存储库中与本地存储库中的分支同名的所有分支。因此，可以使用以下任一方法完成最后一次 &lt;code&gt;push&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="090c003198124abd0a59f9db99cb23a0a9d08a0d" translate="yes" xml:space="preserve">
          <source>In the above config only the submodule &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are active, &lt;code&gt;bar&lt;/code&gt; due to (1) and &lt;code&gt;baz&lt;/code&gt; due to (3). &lt;code&gt;foo&lt;/code&gt; is inactive because (1) takes precedence over (3)</source>
          <target state="translated">在上面的配置中，只有子模块 &lt;code&gt;bar&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt; 处于活动状态， &lt;code&gt;bar&lt;/code&gt; 由于（1）而 &lt;code&gt;baz&lt;/code&gt; 由于（3）。 &lt;code&gt;foo&lt;/code&gt; 是无效的，因为（1）优先于（3）</target>
        </trans-unit>
        <trans-unit id="f2615d435cf358760e53af78267e9744a2a4cd7e" translate="yes" xml:space="preserve">
          <source>In the above example output, the function signature was changed from both files (hence two &lt;code&gt;-&lt;/code&gt; removals from both file1 and file2, plus &lt;code&gt;++&lt;/code&gt; to mean one line that was added does not appear in either file1 or file2). Also eight other lines are the same from file1 but do not appear in file2 (hence prefixed with &lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">在上面的示例输出中，两个文件都更改了函数签名（因此两个 &lt;code&gt;-&lt;/code&gt; 均被删除-从file1和file2中删除，再加上 &lt;code&gt;++&lt;/code&gt; 表示添加的一行不会出现在file1或file2中）。另外，file1中的其他八行相同，但未出现在file2中（因此以 &lt;code&gt;+&lt;/code&gt; 开头）。</target>
        </trans-unit>
        <trans-unit id="236d1518399c3b158b7b503f699f9dfd06244979" translate="yes" xml:space="preserve">
          <source>In the above example we have N = 8, so this will give:</source>
          <target state="translated">在上面的例子中,我们有N=8,所以会得到。</target>
        </trans-unit>
        <trans-unit id="4faa5ab35bd05c089c7f00cb50d40bc6a34dd151" translate="yes" xml:space="preserve">
          <source>In the case where the input consists entirely of whitespace characters, no output will be produced.</source>
          <target state="translated">如果输入完全由空白字符组成,则不会产生输出。</target>
        </trans-unit>
        <trans-unit id="6722ed28b0a968c96593a6b207713cd0f24f7d3a" translate="yes" xml:space="preserve">
          <source>In the check-in codepath, the worktree file is first converted with &lt;code&gt;filter&lt;/code&gt; driver (if specified and corresponding driver defined), then the result is processed with &lt;code&gt;ident&lt;/code&gt; (if specified), and then finally with &lt;code&gt;text&lt;/code&gt; (again, if specified and applicable).</source>
          <target state="translated">在签入代码路径中，首先使用以下命令转换工作树文件： &lt;code&gt;filter&lt;/code&gt; 驱动程序（如果已指定并定义了相应的驱动程序），然后使用 &lt;code&gt;ident&lt;/code&gt; （如果已指定）处理结果，然后最后使用 &lt;code&gt;text&lt;/code&gt; （同样，如果已指定并且适用）处理结果。</target>
        </trans-unit>
        <trans-unit id="41a87794ee334f48f97053e2010dfe2b224b3e78" translate="yes" xml:space="preserve">
          <source>In the check-out codepath, the blob content is first converted with &lt;code&gt;text&lt;/code&gt;, and then &lt;code&gt;ident&lt;/code&gt; and fed to &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">在签出代码路径中，首先将Blob内容转换为 &lt;code&gt;text&lt;/code&gt; ，然后进行 &lt;code&gt;ident&lt;/code&gt; 并馈给 &lt;code&gt;filter&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="113fa915b38684bf235e931affc2401ec6de4a63" translate="yes" xml:space="preserve">
          <source>In the cone mode case, the &lt;code&gt;git sparse-checkout list&lt;/code&gt; subcommand will list the directories that define the recursive patterns. For the example sparse-checkout file above, the output is as follows:</source>
          <target state="translated">在锥模式下， &lt;code&gt;git sparse-checkout list&lt;/code&gt; 子命令将列出定义递归模式的目录。对于上面的示例稀疏签出文件，输出如下：</target>
        </trans-unit>
        <trans-unit id="50d1a515997c60c54243bae252639aa03db105b6" translate="yes" xml:space="preserve">
          <source>In the default overlay mode, &lt;code&gt;git checkout&lt;/code&gt; never removes files from the index or the working tree. When specifying &lt;code&gt;--no-overlay&lt;/code&gt;, files that appear in the index and working tree, but not in &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; are removed, to make them match &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; exactly.</source>
          <target state="translated">在默认的覆盖模式下， &lt;code&gt;git checkout&lt;/code&gt; 永远不会从索引或工作树中删除文件。指定 &lt;code&gt;--no-overlay&lt;/code&gt; 时，将删除出现在索引和工作树中但未出现在 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 中的文件，以使其与 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 完全匹配。</target>
        </trans-unit>
        <trans-unit id="6cdd96542ff31058533f7beb40eadd124991c8c5" translate="yes" xml:space="preserve">
          <source>In the early days, Git (in the tradition of UNIX) was a bunch of programs which were extremely simple, and which you used in scripts, piping the output of one into another. This turned out to be good for initial development, since it was easier to test new things. However, recently many of these parts have become builtins, and some of the core has been &quot;libified&quot;, i.e. put into libgit.a for performance, portability reasons, and to avoid code duplication.</source>
          <target state="translated">在早期,Git(UNIX 的传统)是一堆极其简单的程序,你可以用脚本,将一个程序的输出用管道连接到另一个程序中。这对最初的开发来说是很好的,因为它更容易测试新东西。然而,最近,这些部分中的许多都变成了内建,一些核心已经被 &quot;libified&quot;,即为了性能、可移植性和避免代码重复而放到libgit.a中。</target>
        </trans-unit>
        <trans-unit id="5c0100c9df6abb7d7f1348c7fe307c535cc01a6e" translate="yes" xml:space="preserve">
          <source>In the examples, the following &lt;code&gt;.gitattributes&lt;/code&gt; file is used:</source>
          <target state="translated">在示例中，使用以下 &lt;code&gt;.gitattributes&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="cc3fe53f7a76d1235b536b2f3e4aace1aeafd632" translate="yes" xml:space="preserve">
          <source>In the external editor window, read in the patch file and exit the editor normally.</source>
          <target state="translated">在外部编辑器窗口中,读入补丁文件,正常退出编辑器。</target>
        </trans-unit>
        <trans-unit id="8ef2e6de3f32f727ff12807f3683863dc57cb535" translate="yes" xml:space="preserve">
          <source>In the first form, it renames &amp;lt;source&amp;gt;, which must exist and be either a file, symlink or directory, to &amp;lt;destination&amp;gt;. In the second form, the last argument has to be an existing directory; the given sources will be moved into this directory.</source>
          <target state="translated">在第一种形式中，它将&amp;lt;source&amp;gt;重命名为&amp;lt;destination&amp;gt;，该源必须存在并且可以是文件，符号链接或目录。在第二种形式中，最后一个参数必须是现有目录。给定的源将移动到该目录中。</target>
        </trans-unit>
        <trans-unit id="76aeefd352a6b656fb05dc49a2aa92d1acbe97ce" translate="yes" xml:space="preserve">
          <source>In the first three forms, copy entries from &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; to the index. In the last form, set the current branch head (&lt;code&gt;HEAD&lt;/code&gt;) to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;, optionally modifying index and working tree to match. The &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; defaults to &lt;code&gt;HEAD&lt;/code&gt; in all forms.</source>
          <target state="translated">在前三种形式中，将条目从 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 复制到索引。在最后一种形式中，将当前分支头（ &lt;code&gt;HEAD&lt;/code&gt; ）设置为 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; ，可以选择修改索引和工作树以使其匹配。所述 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; / &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 默认为 &lt;code&gt;HEAD&lt;/code&gt; 各种形式。</target>
        </trans-unit>
        <trans-unit id="ef10a113d8afc34781099a24e1e343890650a1e1" translate="yes" xml:space="preserve">
          <source>In the following example, the developer works on a topic branch that refactors the way buttons are defined, and on another topic branch that uses that refactoring to implement a &quot;Report a bug&quot; button. The output of &lt;code&gt;git log --graph --format=%s -5&lt;/code&gt; may look like this:</source>
          <target state="translated">在下面的示例中，开发人员在一个主题分支上工作，该分支重构按钮的定义方式，在另一个主题分支上使用该重构实现&amp;ldquo;报告错误&amp;rdquo;按钮。 &lt;code&gt;git log --graph --format=%s -5&lt;/code&gt; 的输出可能如下所示：</target>
        </trans-unit>
        <trans-unit id="e8d35f4a27576cd3ee599047c232398088d285ec" translate="yes" xml:space="preserve">
          <source>In the following, we list all defined capabilities and for each we list which commands a helper with that capability must provide.</source>
          <target state="translated">在下面,我们列出了所有定义的能力,并为每个能力列出了具有该能力的助手必须提供的命令。</target>
        </trans-unit>
        <trans-unit id="c56abbab61e08007b56db2739d2660b32ff3baf6" translate="yes" xml:space="preserve">
          <source>In the following, we say that commit X is &quot;reachable&quot; from commit Y if commit X is an ancestor of commit Y. Equivalently, you could say that Y is a descendant of X, or that there is a chain of parents leading from commit Y to commit X.</source>
          <target state="translated">在下文中,我们说,如果提交X是提交Y的祖先,那么提交X是可以从提交Y &quot;到达 &quot;的。同样,你也可以说Y是X的后代,或者说有一条从提交Y到提交X的父母链。</target>
        </trans-unit>
        <trans-unit id="2ab0015fa4bf468aa51dfb7b06e67d10a59ee05a" translate="yes" xml:space="preserve">
          <source>In the following, we will always refer to the same example history to illustrate the differences between simplification settings. We assume that you are filtering for a file &lt;code&gt;foo&lt;/code&gt; in this commit graph:</source>
          <target state="translated">在下文中，我们将始终参考相同的示例历史记录，以说明简化设置之间的差异。我们假设您正在此提交图中过滤文件 &lt;code&gt;foo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1a1825758e9c1b0f3cada9dea61b97f18e404ba1" translate="yes" xml:space="preserve">
          <source>In the ideal world, you could have realized that the earlier commit did not belong to the new topic when you created and switched to &lt;code&gt;branch2&lt;/code&gt; (i.e. &lt;code&gt;git switch -c branch2 start&lt;/code&gt;), but nobody is perfect.</source>
          <target state="translated">在理想的世界中，您可能已经意识到，当您创建并切换到 &lt;code&gt;branch2&lt;/code&gt; 时，较早的提交不属于新主题（即 &lt;code&gt;git switch -c branch2 start&lt;/code&gt; ），但是没有人是完美的。</target>
        </trans-unit>
        <trans-unit id="d370a0f8ed20ae4cd4e933b9beff011b3187e6ad" translate="yes" xml:space="preserve">
          <source>In the long form, the leading colon &lt;code&gt;:&lt;/code&gt; is followed by an open parenthesis &lt;code&gt;(&lt;/code&gt;, a comma-separated list of zero or more &quot;magic words&quot;, and a close parentheses &lt;code&gt;)&lt;/code&gt;, and the remainder is the pattern to match against the path.</source>
          <target state="translated">在长格式中，前导冒号 &lt;code&gt;:&lt;/code&gt; 后跟一个开放的括号 &lt;code&gt;(&lt;/code&gt; ，用逗号分隔的零个或多个&amp;ldquo;魔术词&amp;rdquo;列表，以及一个封闭的括号 &lt;code&gt;)&lt;/code&gt; ，其余为与路径匹配的模式。</target>
        </trans-unit>
        <trans-unit id="ecbb466c633c8f376663d1974093b0b801e94fbc" translate="yes" xml:space="preserve">
          <source>In the main Thunderbird window, &lt;code&gt;before&lt;/code&gt; you open the compose window for the patch, use Tools&amp;rarr;about:config to set the following to the indicated values:</source>
          <target state="translated">在Thunderbird主窗口中， &lt;code&gt;before&lt;/code&gt; 打开补丁的撰写窗口之前，使用工具&amp;rarr;关于：配置将以下设置为指示的值：</target>
        </trans-unit>
        <trans-unit id="3f70c7e45d5c392e715fb2023b23a65e5f20b82a" translate="yes" xml:space="preserve">
          <source>In the output from &lt;code&gt;git show-branch&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt; should have everything &lt;code&gt;ko/master&lt;/code&gt; has, and &lt;code&gt;next&lt;/code&gt; should have everything &lt;code&gt;ko/next&lt;/code&gt; has, etc.</source>
          <target state="translated">在 &lt;code&gt;git show-branch&lt;/code&gt; 的输出中， &lt;code&gt;master&lt;/code&gt; 应该拥有 &lt;code&gt;ko/master&lt;/code&gt; 拥有的一切， &lt;code&gt;next&lt;/code&gt; 应该拥有 &lt;code&gt;ko/next&lt;/code&gt; 拥有的一切，依此类推。</target>
        </trans-unit>
        <trans-unit id="9fb474287214ed4886618f1399ff63bbd11f6810" translate="yes" xml:space="preserve">
          <source>In the pager (&lt;code&gt;less&lt;/code&gt;), just search for &quot;bundle&quot;, go a few lines back, and see that it is in commit 18449ab0. Now just copy this object name, and paste it into the command line</source>
          <target state="translated">在分页器（ &lt;code&gt;less&lt;/code&gt; ）中，仅搜索&amp;ldquo; bundle&amp;rdquo;，向后移几行，然后查看它是否在commit 18449ab0中。现在只需复制该对象名称，并将其粘贴到命令行中</target>
        </trans-unit>
        <trans-unit id="5fc7016d20b7cd82938bb283d4d8443cc61835c8" translate="yes" xml:space="preserve">
          <source>In the past, &lt;code&gt;.git/HEAD&lt;/code&gt; was a symbolic link pointing at &lt;code&gt;refs/heads/master&lt;/code&gt;. When we wanted to switch to another branch, we did &lt;code&gt;ln -sf refs/heads/newbranch .git/HEAD&lt;/code&gt;, and when we wanted to find out which branch we are on, we did &lt;code&gt;readlink .git/HEAD&lt;/code&gt;. But symbolic links are not entirely portable, so they are now deprecated and symbolic refs (as described above) are used by default.</source>
          <target state="translated">过去， &lt;code&gt;.git/HEAD&lt;/code&gt; 是指向 &lt;code&gt;refs/heads/master&lt;/code&gt; 的符号链接。当我们想切换到另一个分支时，我们做了 &lt;code&gt;ln -sf refs/heads/newbranch .git/HEAD&lt;/code&gt; ，当我们想知道我们在哪个分支上时，我们做了 &lt;code&gt;readlink .git/HEAD&lt;/code&gt; 。但是符号链接并不是完全可移植的，因此现在不建议使用它们，并且默认情况下使用符号引用（如上所述）。</target>
        </trans-unit>
        <trans-unit id="8dfab80b468101639bf9d627830b7559e865891a" translate="yes" xml:space="preserve">
          <source>In the previous example, when updating an existing branch, &lt;code&gt;git fetch&lt;/code&gt; checks to make sure that the most recent commit on the remote branch is a descendant of the most recent commit on your copy of the branch before updating your copy of the branch to point at the new commit. Git calls this process a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;.</source>
          <target state="translated">在上一个示例中，在更新现有分支时， &lt;code&gt;git fetch&lt;/code&gt; 会检查以确保在更新分支副本以指向之前，远程分支上的最新提交是分支副本上最新提交的后代。新的提交。Git将此过程称为&lt;a href=&quot;#fast-forwards&quot;&gt;快速前进&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39fc6243d8461e10163ad54b5cc61dfd9c9ca8f0" translate="yes" xml:space="preserve">
          <source>In the process of undoing a previous bad change, you may find it useful to check out an older version of a particular file using &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;. The command</source>
          <target state="translated">在撤消以前的重大更改的过程中，您可能会发现使用&lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt;签出特定文件的旧版本很有用。命令</target>
        </trans-unit>
        <trans-unit id="ce5a30d6d89274fe8c4b93a655981ad3cb2875fa" translate="yes" xml:space="preserve">
          <source>In the process, it may discover conflicts. In that case it will stop and allow you to fix the conflicts; after fixing conflicts, use &lt;code&gt;git add&lt;/code&gt; to update the index with those contents, and then, instead of running &lt;code&gt;git commit&lt;/code&gt;, just run</source>
          <target state="translated">在此过程中，它可能会发现冲突。在这种情况下，它将停止并允许您解决冲突。解决冲突后，使用 &lt;code&gt;git add&lt;/code&gt; 用这些内容更新索引，然后运行 &lt;code&gt;git commit&lt;/code&gt; ，而不是运行</target>
        </trans-unit>
        <trans-unit id="ecd16080120d9546efe5335b66c01332d8bc5340" translate="yes" xml:space="preserve">
          <source>In the second form, a list of objects (separated by linefeeds) is provided on stdin, and the SHA-1, type, and size of each object is printed on stdout. The output format can be overridden using the optional &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; argument. If either &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt; was specified, the input is expected to list the object names followed by the path name, separated by a single whitespace, so that the appropriate drivers can be determined.</source>
          <target state="translated">在第二种形式中，在stdin上提供了一个对象列表（由换行分隔），每个对象的SHA-1，类型和大小都打印在stdout上。可以使用可选的 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 参数覆盖输出格式。如果指定了 &lt;code&gt;--textconv&lt;/code&gt; 或 &lt;code&gt;--filters&lt;/code&gt; ，则预期输入将列出对象名称，然后列出路径名称，并用单个空格分隔，以便可以确定适当的驱动程序。</target>
        </trans-unit>
        <trans-unit id="909b0b19015ead3714bd1690a7877da1cf97f4fa" translate="yes" xml:space="preserve">
          <source>In the short-format, the status of each path is shown as one of these forms</source>
          <target state="translated">在短格式中,每个路径的状态显示为以下形式之一</target>
        </trans-unit>
        <trans-unit id="abe3a521aeac4a8adcc3faf0711763fbfd40b505" translate="yes" xml:space="preserve">
          <source>In the simple form, each line in the file consists of the canonical real name of an author, whitespace, and an email address used in the commit (enclosed by &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;) to map to the name. For example:</source>
          <target state="translated">以简单的形式，文件中的每一行都包含作者的规范实名，空格和在提交中（用 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 包围）映射到该名称的电子邮件地址。例如：</target>
        </trans-unit>
        <trans-unit id="eecf34aeaad64fff7ea38378d33edc5335145626" translate="yes" xml:space="preserve">
          <source>In these cases you can tell Git the encoding of a file in the working directory with the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute. If a file with this attribute is added to Git, then Git re-encodes the content from the specified encoding to UTF-8. Finally, Git stores the UTF-8 encoded content in its internal data structure (called &quot;the index&quot;). On checkout the content is re-encoded back to the specified encoding.</source>
          <target state="translated">在这些情况下，您可以使用 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性告诉Git工作目录中文件的编码。如果将具有此属性的文件添加到Git，则Git会将内容从指定的编码重新编码为UTF-8。最后，Git将UTF-8编码的内容存储在其内部数据结构（称为&amp;ldquo;索引&amp;rdquo;）中。签出时，内容将重新编码回指定的编码。</target>
        </trans-unit>
        <trans-unit id="5322604525a9aed1b9bf470c8d7df77aa5a14cc1" translate="yes" xml:space="preserve">
          <source>In these tables, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; are some different states of a file. For example, the first line of the first table means that if a file is in state &lt;code&gt;A&lt;/code&gt; in the working tree, in state &lt;code&gt;B&lt;/code&gt; in the index, in state &lt;code&gt;C&lt;/code&gt; in &lt;code&gt;HEAD&lt;/code&gt; and in state &lt;code&gt;D&lt;/code&gt; in the target, then &lt;code&gt;git reset --soft
target&lt;/code&gt; will leave the file in the working tree in state &lt;code&gt;A&lt;/code&gt; and in the index in state &lt;code&gt;B&lt;/code&gt;. It resets (i.e. moves) the &lt;code&gt;HEAD&lt;/code&gt; (i.e. the tip of the current branch, if you are on one) to &lt;code&gt;target&lt;/code&gt; (which has the file in state &lt;code&gt;D&lt;/code&gt;).</source>
          <target state="translated">在这些表中， &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 是文件的某些不同状态。例如，第一表装置的第一行，如果一个文件是在状态 &lt;code&gt;A&lt;/code&gt; 在工作树，在状态 &lt;code&gt;B&lt;/code&gt; 在索引中，在状态 &lt;code&gt;C&lt;/code&gt; 在 &lt;code&gt;HEAD&lt;/code&gt; 和状态 &lt;code&gt;D&lt;/code&gt; 中的目标，然后 &lt;code&gt;git reset --soft target&lt;/code&gt; 会将文件置于状态 &lt;code&gt;A&lt;/code&gt; 的工作树中和状态 &lt;code&gt;B&lt;/code&gt; 的索引中。它重置（即移动） &lt;code&gt;HEAD&lt;/code&gt; （即当前分支的尖端，如果您在其中），将其 &lt;code&gt;target&lt;/code&gt; （文件处于状态） &lt;code&gt;D&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="31d8ef3e97391069cf0655f41499162005f123c2" translate="yes" xml:space="preserve">
          <source>In these two shorthand notations, you can omit one end and let it default to HEAD. For example, &lt;code&gt;origin..&lt;/code&gt; is a shorthand for &lt;code&gt;origin..HEAD&lt;/code&gt; and asks &quot;What did I do since I forked from the origin branch?&quot; Similarly, &lt;code&gt;..origin&lt;/code&gt; is a shorthand for &lt;code&gt;HEAD..origin&lt;/code&gt; and asks &quot;What did the origin do since I forked from them?&quot; Note that &lt;code&gt;..&lt;/code&gt; would mean &lt;code&gt;HEAD..HEAD&lt;/code&gt; which is an empty range that is both reachable and unreachable from HEAD.</source>
          <target state="translated">在这两种简写形式中，您可以省略一端并将其默认设置为HEAD。例如， &lt;code&gt;origin..&lt;/code&gt; 是 &lt;code&gt;origin..HEAD&lt;/code&gt; 的简写，并询问&amp;ldquo;自从origin分支分支以来我做了什么？&amp;rdquo;同样， &lt;code&gt;..origin&lt;/code&gt; 是一个速记 &lt;code&gt;HEAD..origin&lt;/code&gt; ，并询问&amp;ldquo;什么了，因为我从他们分叉的起源吗？&amp;rdquo;请注意， &lt;code&gt;..&lt;/code&gt; 表示 &lt;code&gt;HEAD..HEAD&lt;/code&gt; ，这是一个空范围，从HEAD可以到达和不可到达。</target>
        </trans-unit>
        <trans-unit id="fda0649080e4ad73be213a95d0150567b39a9905" translate="yes" xml:space="preserve">
          <source>In this case Git will attempt to undo the old change while leaving intact any changes made since then. If more recent changes overlap with the changes to be reverted, then you will be asked to fix conflicts manually, just as in the case of &lt;a href=&quot;#resolving-a-merge&quot;&gt;resolving a merge&lt;/a&gt;.</source>
          <target state="translated">在这种情况下，Git将尝试撤消旧更改，同时保留此后所做的任何更改。如果最近的更改与要还原的更改重叠，则将要求您手动解决冲突，就像&lt;a href=&quot;#resolving-a-merge&quot;&gt;解决merge一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7e31e9f418486f831893dd264d133713a86e996" translate="yes" xml:space="preserve">
          <source>In this case if you are bisecting manually, what you can do is create a special branch that starts just before the BBC. The first commit in this branch should be the BBC with the BFC squashed into it. And the other commits in the branch should be the commits between BBC and BFC rebased on the first commit of the branch and then the commit after BFC also rebased on.</source>
          <target state="translated">在这种情况下,如果你是手动分割,你可以做的是创建一个特殊的分支,从BBC之前开始。这个分支中的第一个提交应该是BBC和BFC之间的提交。而该分支中的其他提交应该是BBC和BFC之间的提交,以该分支的第一个提交为基础,然后BFC之后的提交也以这个分支为基础。</target>
        </trans-unit>
        <trans-unit id="717fbe628e5024a7ab31b6335fd291caf38b26b3" translate="yes" xml:space="preserve">
          <source>In this case this creates a totally new commit that is not related to anything else. Normally you do this only &lt;strong&gt;once&lt;/strong&gt; for a project ever, and all later commits will be parented on top of an earlier commit.</source>
          <target state="translated">在这种情况下，这将创建一个与其他任何内容都不相关的全新提交。通常情况下，你这样做只是&lt;strong&gt;一次&lt;/strong&gt;为一个项目永远，其随后所有的提交将在较早提交顶部父。</target>
        </trans-unit>
        <trans-unit id="8d602afd53dc502b1f39532e44b808e7e4006de6" translate="yes" xml:space="preserve">
          <source>In this case we say that the HEAD is &quot;detached&quot;.</source>
          <target state="translated">在这种情况下,我们说HEAD是 &quot;分离 &quot;的。</target>
        </trans-unit>
        <trans-unit id="84d70e62f46cda65cca1be0dfe61a185714e74d6" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;git fetch&lt;/code&gt; will fail, and print out a warning.</source>
          <target state="translated">在这种情况下， &lt;code&gt;git fetch&lt;/code&gt; 将失败，并打印出警告。</target>
        </trans-unit>
        <trans-unit id="ec2a36fb392a8671d4d7ad6f96adda81069f0cb4" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; command makes sure that no local change is lost as the result of this &quot;merge&quot;. Here are the &quot;carry forward&quot; rules, where &quot;I&quot; denotes the index, &quot;clean&quot; means that index and work tree coincide, and &quot;exists&quot;/&quot;nothing&quot; refer to the presence of a path in the specified commit:</source>
          <target state="translated">在这种情况下， &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; 命令可确保不会因&amp;ldquo;合并&amp;rdquo;而丢失任何本地更改。以下是&amp;ldquo;继承&amp;rdquo;规则，其中&amp;ldquo; I&amp;rdquo;表示索引，&amp;ldquo;干净&amp;rdquo;表示索引与工作树重合，而&amp;ldquo;存在&amp;rdquo; /&amp;ldquo;无&amp;rdquo;表示在指定的提交中存在路径：</target>
        </trans-unit>
        <trans-unit id="53de38de1c4937be3492ea2adad08075be0660b2" translate="yes" xml:space="preserve">
          <source>In this case, though, Git may not eventually be able to tell the first bad one between some first skipped commits and a later bad commit.</source>
          <target state="translated">不过在这种情况下,Git可能最终无法分辨出一些先跳过的提交和后来的坏提交之间的第一坏。</target>
        </trans-unit>
        <trans-unit id="cc3568a850f36cf3d79c68cf0d9db0591ec5b81e" translate="yes" xml:space="preserve">
          <source>In this case, when &lt;code&gt;git bisect run&lt;/code&gt; finishes, bisect/bad will refer to a commit that has at least one parent whose reachable graph is fully traversable in the sense required by &lt;code&gt;git pack objects&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，当 &lt;code&gt;git bisect run&lt;/code&gt; 完成时，bisect / bad将引用一个提交，该提交至少具有一个父级，其可达图在 &lt;code&gt;git pack objects&lt;/code&gt; 要求的意义上是完全可遍历的。</target>
        </trans-unit>
        <trans-unit id="052b0bf9d817f9d1efdbc01c640d54d8fda7ad16" translate="yes" xml:space="preserve">
          <source>In this example preload_index() was executed by the &lt;code&gt;main&lt;/code&gt; thread and started the &lt;code&gt;preload&lt;/code&gt; region. Seven threads, named &lt;code&gt;th01:preload_thread&lt;/code&gt; through &lt;code&gt;th07:preload_thread&lt;/code&gt;, were started. Events from each thread are atomically appended to the shared target stream as they occur so they may appear in random order with respect other threads. Finally, the main thread waits for the threads to finish and leaves the region.</source>
          <target state="translated">在此示例中，preload_index（）由 &lt;code&gt;main&lt;/code&gt; 线程执行并启动了 &lt;code&gt;preload&lt;/code&gt; 区域。启动了七个线程，分别名为 &lt;code&gt;th01:preload_thread&lt;/code&gt; 到 &lt;code&gt;th07:preload_thread&lt;/code&gt; 。来自每个线程的事件在发生时都原子地附加到共享目标流，因此它们相对于其他线程可能以随机顺序出现。最后，主线程等待线程完成并离开区域。</target>
        </trans-unit>
        <trans-unit id="8e1c791b90ef2153c52f59ff823e2b7a9d806696" translate="yes" xml:space="preserve">
          <source>In this example, &quot;origin&quot; is called a remote repository, or &quot;remote&quot; for short. The branches of this repository are called &quot;remote branches&quot; from our point of view. The remote-tracking branches listed above were created based on the remote branches at clone time and will be updated by &lt;code&gt;git fetch&lt;/code&gt; (hence &lt;code&gt;git pull&lt;/code&gt;) and &lt;code&gt;git push&lt;/code&gt;. See &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;Updating a repository with git fetch&lt;/a&gt; for details.</source>
          <target state="translated">在此示例中，&amp;ldquo;来源&amp;rdquo;称为远程存储库，简称为&amp;ldquo;远程&amp;rdquo;。从我们的角度来看，该存储库的分支称为&amp;ldquo;远程分支&amp;rdquo;。上面列出的远程跟踪分支是在克隆时基于远程分支创建的，将通过 &lt;code&gt;git fetch&lt;/code&gt; （因此 &lt;code&gt;git pull&lt;/code&gt; ）和 &lt;code&gt;git push&lt;/code&gt; 进行更新。有关详细&lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;信息，&lt;/a&gt;请参见使用git fetch更新存储库。</target>
        </trans-unit>
        <trans-unit id="888891869abe63aa603e61303e6b4eda4f092540" translate="yes" xml:space="preserve">
          <source>In this example, scanning for untracked files ran from +0.012568 to +0.027149 (since the process started) and took 0.014581 seconds.</source>
          <target state="translated">在这个例子中,扫描未跟踪的文件从+0.012568运行到+0.027149(自进程开始),耗时0.014581秒。</target>
        </trans-unit>
        <trans-unit id="06524b5c41784cbbacde83bd5045f27a411dfe64" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;ko&lt;/code&gt; shorthand points at the Git maintainer&amp;rsquo;s repository at kernel.org, and looks like this:</source>
          <target state="translated">在此示例中， &lt;code&gt;ko&lt;/code&gt; 速记指向kernel.org上Git维护者的存储库，如下所示：</target>
        </trans-unit>
        <trans-unit id="f509bc56ecf3e22348180170f4391a6c5749bec9" translate="yes" xml:space="preserve">
          <source>In this example, the preload region took 0.009122 seconds. The 7 threads took between 0.006069 and 0.008947 seconds to work on their portion of the index. Thread &quot;th01&quot; worked on 508 items at offset 0. Thread &quot;th02&quot; worked on 508 items at offset 2032. Thread &quot;th04&quot; worked on 508 items at offset 508.</source>
          <target state="translated">在这个例子中,预加载区域用了0.009122秒。7个线程花了0.006069到0.008947秒的时间来处理他们的索引部分,线程 &quot;th01 &quot;在偏移量0处处理508个项目,线程 &quot;th02 &quot;在偏移量2032处处理508个项目。线程 &quot;th01 &quot;在偏移量为0时处理了508个项目。 线程 &quot;th02 &quot;在偏移量为2032时处理了508个项目。线程 &quot;th04 &quot;在偏移量为508时工作了508个项目。</target>
        </trans-unit>
        <trans-unit id="24b2f8c33beed03671571687642648d3c34d3255" translate="yes" xml:space="preserve">
          <source>In this example, the root-level directory &lt;code&gt;/pub&lt;/code&gt; will contain a subdirectory for each virtual host IP address supported. Repositories can still be accessed by hostname though, assuming they correspond to these IP addresses.</source>
          <target state="translated">在此示例中，根目录 &lt;code&gt;/pub&lt;/code&gt; 将包含每个支持的虚拟主机IP地址的子目录。仍然可以通过主机名访问存储库，前提是它们对应于这些IP地址。</target>
        </trans-unit>
        <trans-unit id="1b3657f6aff85ab6f6a5a7f723164213b6e98109" translate="yes" xml:space="preserve">
          <source>In this example, the root-level directory &lt;code&gt;/pub&lt;/code&gt; will contain a subdirectory for each virtual host name supported. Further, both hosts advertise repositories simply as &lt;code&gt;git://www.example.com/software/repo.git&lt;/code&gt;. For pre-1.4.0 clients, a symlink from &lt;code&gt;/software&lt;/code&gt; into the appropriate default repository could be made as well.</source>
          <target state="translated">在此示例中，根目录 &lt;code&gt;/pub&lt;/code&gt; 将为每个受支持的虚拟主机名包含一个子目录。此外，两个主机都只是以 &lt;code&gt;git://www.example.com/software/repo.git&lt;/code&gt; 的形式发布存储库。对于1.4.0之前的客户端，也可以建立从 &lt;code&gt;/software&lt;/code&gt; 到适当的默认存储库的符号链接。</target>
        </trans-unit>
        <trans-unit id="4f73381570064f6ad92295b54ae4d9111ba415e0" translate="yes" xml:space="preserve">
          <source>In this example, there are 3 old and 3 new commits, where the developer removed the 3rd, added a new one before the first two, and modified the commit message of the 2nd commit as well its diff.</source>
          <target state="translated">在这个例子中,有3个旧的提交和3个新的提交,开发者删除了第3个提交,在前两个提交之前增加了一个新的提交,并修改了第2个提交的提交信息以及它的差异。</target>
        </trans-unit>
        <trans-unit id="5f85b35b8b6aae26894cfdfbe33e3822a8120573" translate="yes" xml:space="preserve">
          <source>In this example, we passed &quot;grep &lt;code&gt;^SUBLEVEL = 25&lt;/code&gt; Makefile&quot; as parameter to &quot;git bisect run&quot;. This means that at each step, the grep command we passed will be launched. And if it exits with code 0 (that means success) then git bisect will mark the current state as &quot;good&quot;. If it exits with code 1 (or any code between 1 and 127 included, except the special code 125), then the current state will be marked as &quot;bad&quot;.</source>
          <target state="translated">在此示例中，我们将&amp;ldquo; grep &lt;code&gt;^SUBLEVEL = 25&lt;/code&gt; Makefile&amp;rdquo;作为参数传递给&amp;ldquo; git bisect run&amp;rdquo;。这意味着在每个步骤中，我们传递的grep命令都会启动。如果它以代码0退出（表示成功），则git bisect将当前状态标记为&amp;ldquo;良好&amp;rdquo;。如果以代码1（或特殊代码125除外，包括1到127之间的任何代码）退出，则当前状态将标记为&amp;ldquo;不良&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="eee8776c9677f60ee6e97b993bed2ed1a91281bf" translate="yes" xml:space="preserve">
          <source>In this format, each line is output after a header; the header at the minimum has the first line which has:</source>
          <target state="translated">在这种格式中,每一行都是在页眉之后输出的;页眉最小的第一行有。</target>
        </trans-unit>
        <trans-unit id="991df4351922c60c45e086aff27d9273fe47de49" translate="yes" xml:space="preserve">
          <source>In this format, use 40 &quot;0&quot; to specify a zero value, and use the empty string to specify a missing value.</source>
          <target state="translated">在这种格式中,用40&quot;0 &quot;来指定一个零值,用空字符串来指定一个缺失值。</target>
        </trans-unit>
        <trans-unit id="b4a37ae142e5dfb709dfd08bf26fc04d26f39f66" translate="yes" xml:space="preserve">
          <source>In this mode, specific configuration stays in the path pointed by &lt;code&gt;git
rev-parse --git-path config.worktree&lt;/code&gt;. You can add or update configuration in this file with &lt;code&gt;git config --worktree&lt;/code&gt;. Older Git versions will refuse to access repositories with this extension.</source>
          <target state="translated">在这种模式下，特定配置保留在 &lt;code&gt;git rev-parse --git-path config.worktree&lt;/code&gt; 。您可以使用 &lt;code&gt;git config --worktree&lt;/code&gt; 在此文件中添加或更新配置。较旧的Git版本将拒绝访问具有此扩展名的存储库。</target>
        </trans-unit>
        <trans-unit id="26cf2860c6712d39e5cbcd807f1756d9308dfdb3" translate="yes" xml:space="preserve">
          <source>In this mode, the index is split into two files, $GIT_DIR/index and $GIT_DIR/sharedindex.&amp;lt;SHA-1&amp;gt;. Changes are accumulated in $GIT_DIR/index, the split index, while the shared index file contains all index entries and stays unchanged.</source>
          <target state="translated">在此模式下，索引分为两个文件：$ GIT_DIR / index和$ GIT_DIR / sharedindex。&amp;lt;SHA-1&amp;gt;。更改累积在拆分索引$ GIT_DIR / index中，而共享索引文件包含所有索引条目，并且保持不变。</target>
        </trans-unit>
        <trans-unit id="ffc9d6f506ae4dc0ef8e821987c60f58237503b7" translate="yes" xml:space="preserve">
          <source>In this mode, the server will not request authentication until the client actually starts the object negotiation phase of the push, rather than during the initial contact. For this reason, you must also enable the &lt;code&gt;http.receivepack&lt;/code&gt; config option in any repositories that should accept a push. The default behavior, if &lt;code&gt;http.receivepack&lt;/code&gt; is not set, is to reject any pushes by unauthenticated users; the initial request will therefore report &lt;code&gt;403 Forbidden&lt;/code&gt; to the client, without even giving an opportunity for authentication.</source>
          <target state="translated">在这种模式下，服务器将不请求身份验证，直到客户端实际开始推送的对象协商阶段，而不是在初始联系期间。因此，还必须在应接受推送的任何存储库中启用 &lt;code&gt;http.receivepack&lt;/code&gt; config选项。如果未设置 &lt;code&gt;http.receivepack&lt;/code&gt; ，则默认行为是拒绝未经身份验证的用户进行任何推送；因此，初始请求将向客户端报告&amp;ldquo; &lt;code&gt;403 Forbidden&lt;/code&gt; &amp;rdquo;，甚至没有机会进行身份验证。</target>
        </trans-unit>
        <trans-unit id="427d8f8d92a71761648b972f0beb3c2aad83aaaa" translate="yes" xml:space="preserve">
          <source>In this more general usage, you provide &lt;code&gt;git bisect&lt;/code&gt; with a &quot;new&quot; commit that has some property and an &quot;old&quot; commit that doesn&amp;rsquo;t have that property. Each time &lt;code&gt;git bisect&lt;/code&gt; checks out a commit, you test if that commit has the property. If it does, mark the commit as &quot;new&quot;; otherwise, mark it as &quot;old&quot;. When the bisection is done, &lt;code&gt;git bisect&lt;/code&gt; will report which commit introduced the property.</source>
          <target state="translated">在这种更一般的用法中，您为 &lt;code&gt;git bisect&lt;/code&gt; 提供了具有某些属性的&amp;ldquo;新&amp;rdquo;提交和不具有该属性的&amp;ldquo;旧&amp;rdquo;提交。每次 &lt;code&gt;git bisect&lt;/code&gt; 检出一个提交时，您都要测试该提交是否具有该属性。如果是，则将提交标记为&amp;ldquo;新&amp;rdquo;；否则，将其标记为&amp;ldquo;旧&amp;rdquo;。当二等分完成后， &lt;code&gt;git bisect&lt;/code&gt; 将报告引入该属性的提交。</target>
        </trans-unit>
        <trans-unit id="c1e29a4968fef09e4ce2211e751712b57ac5f128" translate="yes" xml:space="preserve">
          <source>In this view, we see all of the important single-parent changes from &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;X&lt;/code&gt;. We also see the carefully-resolved merge &lt;code&gt;M&lt;/code&gt; and the not-so-carefully-resolved merge &lt;code&gt;R&lt;/code&gt;. This is usually enough information to determine why the commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; &quot;disappeared&quot; from history in the default view. However, there are a few issues with this approach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6da0601a9e7aee317ec7d6d594e01f938b779c4" translate="yes" xml:space="preserve">
          <source>In unusual scenarios, you may not be able to create files larger than a certain size on your filesystem, and this option can be used to tell the command to split the output packfile into multiple independent packfiles, each not larger than the given size. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. The minimum size allowed is limited to 1 MiB. This option prevents the creation of a bitmap index. The default is unlimited, unless the config variable &lt;code&gt;pack.packSizeLimit&lt;/code&gt; is set.</source>
          <target state="translated">在不常见的情况下，您可能无法在文件系统上创建大于特定大小的文件，并且此选项可用于告诉命令将输出packfile拆分为多个独立的packfile，每个都不大于给定的大小。大小可以后缀&amp;ldquo; k&amp;rdquo;，&amp;ldquo; m&amp;rdquo;或&amp;ldquo; g&amp;rdquo;。允许的最小大小限制为1 MiB。此选项可防止创建位图索引。除非设置了配置变量 &lt;code&gt;pack.packSizeLimit&lt;/code&gt; ，否则默认值为无限制。</target>
        </trans-unit>
        <trans-unit id="4e6119784d7cd9e9e9f521473e212223da8f242e" translate="yes" xml:space="preserve">
          <source>In versions of Git before 2.23.0 patterns containing \0 would be silently considered fixed. This was never documented, there were also odd and undocumented interactions between e.g. non-ASCII patterns containing \0 and &lt;code&gt;--ignore-case&lt;/code&gt;.</source>
          <target state="translated">在2.23.0之前的Git版本中，包含\ 0的模式将被静默地视为固定。这从未被记录过，例如在包含\ 0和 &lt;code&gt;--ignore-case&lt;/code&gt; 的非ASCII模式之间也存在奇怪而未记录的交互。</target>
        </trans-unit>
        <trans-unit id="5da95a93eebb0b267da3b6f30d0296fee9bbc09f" translate="yes" xml:space="preserve">
          <source>Inactive branches are stored in a structure which uses 96 or 120 bytes (32 bit or 64 bit systems, respectively), plus the length of the branch name (typically under 200 bytes), per branch. fast-import will easily handle as many as 10,000 inactive branches in under 2 MiB of memory.</source>
          <target state="translated">非活动分支被存储在一个结构中,该结构使用96或120个字节(分别为32位或64位系统),加上每个分支名称的长度(通常低于200个字节)。fast-import可以轻松地处理多达10,000个非活动分支,内存不足2 MiB。</target>
        </trans-unit>
        <trans-unit id="40bf5b4a4e7b04d6908a8f7645b8e99e811e42d8" translate="yes" xml:space="preserve">
          <source>Include Some Progress Messages</source>
          <target state="translated">包括一些进展信息</target>
        </trans-unit>
        <trans-unit id="d1a7a0c5683de418c5f98fc4beae70e15874a175" translate="yes" xml:space="preserve">
          <source>Include a line &amp;ldquo;log size &amp;lt;number&amp;gt;&amp;rdquo; in the output for each commit, where &amp;lt;number&amp;gt; is the length of that commit&amp;rsquo;s message in bytes. Intended to speed up tools that read log messages from &lt;code&gt;git log&lt;/code&gt; output by allowing them to allocate space in advance.</source>
          <target state="translated">在每个提交的输出中包括一行&amp;ldquo;日志大小&amp;lt;number&amp;gt;&amp;rdquo;，其中&amp;lt;number&amp;gt;是该提交消息的长度（以字节为单位）。旨在通过允许工具事先分配空间来加快从 &lt;code&gt;git log&lt;/code&gt; 输出中读取日志消息的工具。</target>
        </trans-unit>
        <trans-unit id="af14d11414c6ac75b39c95b283e5bcf0f4ccb002" translate="yes" xml:space="preserve">
          <source>Include additional statistics at the end of blame output.</source>
          <target state="translated">在责备输出的末尾包括额外的统计数字。</target>
        </trans-unit>
        <trans-unit id="67b90ce59db96c9a579b89f0489d7d9769ae1702" translate="yes" xml:space="preserve">
          <source>Include all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that &quot;first introduced&quot; a change to a branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c5e0ca752d4a1deb14e562052c4b503ef081b0" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from &amp;lt;rev&amp;gt; (i.e. &amp;lt;rev&amp;gt; and its ancestors).</source>
          <target state="translated">包括从&amp;lt;rev&amp;gt;（例如，&amp;lt;rev&amp;gt;及其祖先）可以访问的提交。</target>
        </trans-unit>
        <trans-unit id="9605f416b0921199291f14b56df68cc8fe57350a" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from &amp;lt;rev2&amp;gt; but exclude those that are reachable from &amp;lt;rev1&amp;gt;. When either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">包括从&amp;lt;rev2&amp;gt;可访问的提交，但排除从&amp;lt;rev1&amp;gt;可访问的提交。省略&amp;lt;rev1&amp;gt;或&amp;lt;rev2&amp;gt;时，默认为 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce2adffe692042c194b87264e9afec51300d7f42" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; but exclude those that are reachable from both. When either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">包括从&amp;lt;rev1&amp;gt;或&amp;lt;rev2&amp;gt;均可访问的提交，但排除从两者均可访问的提交。省略&amp;lt;rev1&amp;gt;或&amp;lt;rev2&amp;gt;时，默认为 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1236fce64f1fb93f2ef7dcc7912c2d79c1d22c1" translate="yes" xml:space="preserve">
          <source>Include cross-references to the glossary, where appropriate.</source>
          <target state="translated">酌情包括与词汇表的相互参照。</target>
        </trans-unit>
        <trans-unit id="ac12c15729a8f56d7cafe2e8c1b0d7927d0e53f1" translate="yes" xml:space="preserve">
          <source>Include debugging information related to the movement of lines between files (see &lt;code&gt;-C&lt;/code&gt;) and lines moved within a file (see &lt;code&gt;-M&lt;/code&gt;). The first number listed is the score. This is the number of alphanumeric characters detected as having been moved between or within files. This must be above a certain threshold for &lt;code&gt;git blame&lt;/code&gt; to consider those lines of code to have been moved.</source>
          <target state="translated">包括与文件之间的行移动（请参阅 &lt;code&gt;-C&lt;/code&gt; ）和文件内移动的行（请参阅 &lt;code&gt;-M&lt;/code&gt; ）有关的调试信息。列出的第一个数字是分数。这是检测到在文件之间或文件内移动的字母数字字符的数量。对于 &lt;code&gt;git blame&lt;/code&gt; ,必须考虑到已移动这些代码行，该值必须高于某个阈值。</target>
        </trans-unit>
        <trans-unit id="eac52c02432a2a159a563ec983012928139e33b8" translate="yes" xml:space="preserve">
          <source>Include objects in &lt;code&gt;.keep&lt;/code&gt; files when repacking. Note that we still do not delete &lt;code&gt;.keep&lt;/code&gt; packs after &lt;code&gt;pack-objects&lt;/code&gt; finishes. This means that we may duplicate objects, but this makes the option safe to use when there are concurrent pushes or fetches. This option is generally only useful if you are writing bitmaps with &lt;code&gt;-b&lt;/code&gt; or &lt;code&gt;repack.writeBitmaps&lt;/code&gt;, as it ensures that the bitmapped packfile has the necessary objects.</source>
          <target state="translated">重新打包时，请在 &lt;code&gt;.keep&lt;/code&gt; 文件中包含对象。请注意，在 &lt;code&gt;pack-objects&lt;/code&gt; 完成后，我们仍然不删除 &lt;code&gt;.keep&lt;/code&gt; 打包。这意味着我们可以复制对象，但是当存在并发推送或提取操作时，此选项可以安全使用。该选项通常仅在使用 &lt;code&gt;-b&lt;/code&gt; 或 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; 编写位图时才有用，因为它可以确保位图包文件具有必要的对象。</target>
        </trans-unit>
        <trans-unit id="3b3acf7c7b624670bc98269d1db58c312d8f1ad9" translate="yes" xml:space="preserve">
          <source>Include patch text in the output.</source>
          <target state="translated">在输出中加入补丁文本。</target>
        </trans-unit>
        <trans-unit id="7f58d83c9ac95ca37a657dfc92f2d025971598c2" translate="yes" xml:space="preserve">
          <source>Include the output of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; in the commit message template when using an editor to prepare the commit message. Defaults to on, but can be used to override configuration variable commit.status.</source>
          <target state="translated">使用编辑器准备提交消息时，请将&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;的输出包括在提交消息模板中。默认值为on，但可用于覆盖配置变量commit.status。</target>
        </trans-unit>
        <trans-unit id="798a42403927f2977bd316b8bb1bba46f3e2c944" translate="yes" xml:space="preserve">
          <source>Include unasked-for annotated tags if the object they reference was included in the resulting packfile. This can be useful to send new tags to native Git clients.</source>
          <target state="translated">如果引用的对象被包含在生成的 packfile 中,则包含未被问及的注释标签。这对于向本地 Git 客户端发送新的标签很有用。</target>
        </trans-unit>
        <trans-unit id="c5f574d342fa2383147936f6ccc821ddf1edb5ef" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to add a new file or change the content of an existing file. This command has two different means of specifying the content of the file.</source>
          <target state="translated">包含在 &lt;code&gt;commit&lt;/code&gt; 命令中以添加新文件或更改现有文件的内容。此命令有两种不同的方法来指定文件的内容。</target>
        </trans-unit>
        <trans-unit id="8dfee16c07e63cf25f2958c656ce64f423b1c0b9" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to remove a file or recursively delete an entire directory from the branch. If the file or directory removal makes its parent directory empty, the parent directory will be automatically removed too. This cascades up the tree until the first non-empty directory or the root is reached.</source>
          <target state="translated">包含在 &lt;code&gt;commit&lt;/code&gt; 命令中以删除文件或从分支递归删除整个目录。如果文件或目录删除使其父目录为空，则父目录也将被自动删除。这将级联树，直到到达第一个非空目录或根。</target>
        </trans-unit>
        <trans-unit id="87d365412b703101b1d281d9e93e3f278251dd0d" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to remove all files (and also all directories) from the branch. This command resets the internal branch structure to have no files in it, allowing the frontend to subsequently add all interesting files from scratch.</source>
          <target state="translated">包含在 &lt;code&gt;commit&lt;/code&gt; 命令中，用于从分支中删除所有文件（以及所有目录）。此命令将内部分支结构重置为其中没有文件，从而允许前端随后从头开始添加所有有趣的文件。</target>
        </trans-unit>
        <trans-unit id="28dccd9788a09aa2f373fa8c25c3b39e9406a080" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt;&lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; command to add a new note annotating a &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; or change this annotation contents. Internally it is similar to filemodify 100644 on &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; path (maybe split into subdirectories). It&amp;rsquo;s not advised to use any other commands to write to the &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; tree except &lt;code&gt;filedeleteall&lt;/code&gt; to delete all existing notes in this tree. This command has two different means of specifying the content of the note.</source>
          <target state="translated">包含在 &lt;code&gt;commit&lt;/code&gt; &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; 命令中，用于添加注释 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 的新注释或更改此注释内容。在内部，它类似于 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 路径上的filemodify 100644 （可能被拆分为子目录）。除了 &lt;code&gt;filedeleteall&lt;/code&gt; 删除该树中所有现有的注释外，不建议使用任何其他命令写入 &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; 树。此命令有两种不同的方法来指定注释的内容。</target>
        </trans-unit>
        <trans-unit id="db54974f7f0ad531e35648ba85b9388029b4d7ef" translate="yes" xml:space="preserve">
          <source>Includes</source>
          <target state="translated">Includes</target>
        </trans-unit>
        <trans-unit id="de153f024523e4c2c467ece94c841922a681ecff" translate="yes" xml:space="preserve">
          <source>Includes one additional ancestor commit. The additional ancestry link does not change the way the tree state is built at this commit. If the &lt;code&gt;from&lt;/code&gt; command is omitted when creating a new branch, the first &lt;code&gt;merge&lt;/code&gt; commit will be the first ancestor of the current commit, and the branch will start out with no files. An unlimited number of &lt;code&gt;merge&lt;/code&gt; commands per commit are permitted by fast-import, thereby establishing an n-way merge.</source>
          <target state="translated">包括一个附加的祖先提交。附加的祖先链接不会更改在此提交时构建树状态的方式。如果在创建新分支时省略了 &lt;code&gt;from&lt;/code&gt; 命令，则第一个 &lt;code&gt;merge&lt;/code&gt; 提交将是当前提交的第一个祖先，并且该分支将开始时不包含任何文件。快速导入允许每次提交无限数量的 &lt;code&gt;merge&lt;/code&gt; 命令，从而建立n路合并。</target>
        </trans-unit>
        <trans-unit id="8623cf320c015aba351966293c038ddef6f53905" translate="yes" xml:space="preserve">
          <source>Incompatible options</source>
          <target state="translated">不兼容的选项</target>
        </trans-unit>
        <trans-unit id="9020a39adcad5a9de717e37976fa2cef184a1df6" translate="yes" xml:space="preserve">
          <source>Incorporates changes from a remote repository into the current branch. In its default mode, &lt;code&gt;git pull&lt;/code&gt; is shorthand for &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt;.</source>
          <target state="translated">将更改从远程存储库合并到当前分支。在默认模式下， &lt;code&gt;git pull&lt;/code&gt; 是 &lt;code&gt;git fetch&lt;/code&gt; 的简写，其次是 &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d61077e89adde5af7a04457989a77b3c48490ae" translate="yes" xml:space="preserve">
          <source>Incorporates changes from the named commits (since the time their histories diverged from the current branch) into the current branch. This command is used by &lt;code&gt;git pull&lt;/code&gt; to incorporate changes from another repository and can be used by hand to merge changes from one branch into another.</source>
          <target state="translated">将命名提交中的更改（自其历史记录与当前分支分开以来的时间）合并到当前分支中。 &lt;code&gt;git pull&lt;/code&gt; 使用此命令来合并来自另一个存储库的更改，并且可以手动使用它来将一个分支中的更改合并到另一个分支中。</target>
        </trans-unit>
        <trans-unit id="709702f7f984cb3913cdb163bc5d2fe003c81b05" translate="yes" xml:space="preserve">
          <source>Incremental output</source>
          <target state="translated">递增产出</target>
        </trans-unit>
        <trans-unit id="571937052d91a812bc84d435a3200a79bb1a0ee1" translate="yes" xml:space="preserve">
          <source>Indeed untestable commits are often untestable because a breakage was introduced at one time, and that breakage was fixed only after many other commits were introduced.</source>
          <target state="translated">事实上不可测试的提交往往是不可测试的,因为一次引入了一个破绽,而这个破绽是在引入了许多其他提交之后才被修复的。</target>
        </trans-unit>
        <trans-unit id="78699f384a94184571a61ab6b2f36f5cdf341b61" translate="yes" xml:space="preserve">
          <source>Indicate that only the objects wanted need to be fetched, not their dependents.</source>
          <target state="translated">表示只需要获取想要的对象,而不是它们的依赖关系。</target>
        </trans-unit>
        <trans-unit id="d063c49b2950871e5e846c69f89ed3fa8315be66" translate="yes" xml:space="preserve">
          <source>Indicate that these objects are being fetched from a promisor.</source>
          <target state="translated">表示这些对象是从一个承诺者那里获取的。</target>
        </trans-unit>
        <trans-unit id="d4b8f31320c23f43d173d656edb4ca6c63551ac5" translate="yes" xml:space="preserve">
          <source>Indicates a blob object name.</source>
          <target state="translated">表示blob对象名称。</target>
        </trans-unit>
        <trans-unit id="6d441ed12cf0b86c55591d731de178963fe6c1ee" translate="yes" xml:space="preserve">
          <source>Indicates a commit object name.</source>
          <target state="translated">表示提交对象的名称。</target>
        </trans-unit>
        <trans-unit id="e89d58f77c5643f4921d84ac3c1216b6dc569e02" translate="yes" xml:space="preserve">
          <source>Indicates a commit or tag object name. A command that takes a &amp;lt;commit-ish&amp;gt; argument ultimately wants to operate on a &amp;lt;commit&amp;gt; object but automatically dereferences &amp;lt;tag&amp;gt; objects that point at a &amp;lt;commit&amp;gt;.</source>
          <target state="translated">指示提交或标记对象名称。带有&amp;lt;commit-ish&amp;gt;参数的命令最终希望对&amp;lt;commit&amp;gt;对象进行操作，但会自动取消引用指向&amp;lt;commit&amp;gt;的&amp;lt;tag&amp;gt;对象。</target>
        </trans-unit>
        <trans-unit id="31963740af1f01e0807009b4b0a81e30ade64f1a" translate="yes" xml:space="preserve">
          <source>Indicates a filename - almost always relative to the root of the tree structure &lt;code&gt;GIT_INDEX_FILE&lt;/code&gt; describes.</source>
          <target state="translated">表示文件名-几乎总是相对于 &lt;code&gt;GIT_INDEX_FILE&lt;/code&gt; 描述的树结构的根。</target>
        </trans-unit>
        <trans-unit id="c59be5c9a5ab736a07e28f031fa629ea1cac80d9" translate="yes" xml:space="preserve">
          <source>Indicates a tree object name.</source>
          <target state="translated">表示树对象的名称。</target>
        </trans-unit>
        <trans-unit id="0236f6573fabb077368d656582f35373ba9e33e6" translate="yes" xml:space="preserve">
          <source>Indicates a tree, commit or tag object name. A command that takes a &amp;lt;tree-ish&amp;gt; argument ultimately wants to operate on a &amp;lt;tree&amp;gt; object but automatically dereferences &amp;lt;commit&amp;gt; and &amp;lt;tag&amp;gt; objects that point at a &amp;lt;tree&amp;gt;.</source>
          <target state="translated">指示树，提交或标记对象名称。带有&amp;lt;tree-ish&amp;gt;参数的命令最终希望对&amp;lt;tree&amp;gt;对象进行操作，但会自动取消引用指向&amp;lt;tree&amp;gt;的&amp;lt;commit&amp;gt;和&amp;lt;tag&amp;gt;对象。</target>
        </trans-unit>
        <trans-unit id="73ecb0013f5389f15738299d7b0ca5b5c29b261f" translate="yes" xml:space="preserve">
          <source>Indicates that an object type is required. Currently one of: &lt;code&gt;blob&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, or &lt;code&gt;tag&lt;/code&gt;.</source>
          <target state="translated">指示需要一个对象类型。当前的值之一： &lt;code&gt;blob&lt;/code&gt; ， &lt;code&gt;tree&lt;/code&gt; ， &lt;code&gt;commit&lt;/code&gt; 或 &lt;code&gt;tag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db4dbaff6f210d92fcd8a0947f8ffe2ad6166cf6" translate="yes" xml:space="preserve">
          <source>Indicates the object name for any type of object.</source>
          <target state="translated">表示任何类型对象的对象名称。</target>
        </trans-unit>
        <trans-unit id="c66f56b69efd11f38dd2949f22030f51d42bccb8" translate="yes" xml:space="preserve">
          <source>Individual developer (participant)</source>
          <target state="translated">个人开发者(参与者)</target>
        </trans-unit>
        <trans-unit id="dc704b04bf6fc4b099b66d2f7d86d56e0d061d7a" translate="yes" xml:space="preserve">
          <source>Individual developer (standalone)</source>
          <target state="translated">个人开发者(独立)</target>
        </trans-unit>
        <trans-unit id="a964b0aa320ab2176eba7cb0319b97ea34b340ac" translate="yes" xml:space="preserve">
          <source>Individually replay all rebased commits instead of fast-forwarding over the unchanged ones. This ensures that the entire history of the rebased branch is composed of new commits.</source>
          <target state="translated">单独重放所有基于重定向的提交,而不是快进到未修改的提交。这样可以确保整个基于分支的历史是由新的提交组成的。</target>
        </trans-unit>
        <trans-unit id="0eb5ed506e4923c28d7f4a8aa69efe99b3ad75d1" translate="yes" xml:space="preserve">
          <source>Information</source>
          <target state="translated">Information</target>
        </trans-unit>
        <trans-unit id="9bceb94c72e397fee5b7ad78b8c9312ee6319e43" translate="yes" xml:space="preserve">
          <source>Information about what is to be pushed is provided on the hook&amp;rsquo;s standard input with lines of the form:</source>
          <target state="translated">在钩子的标准输入中提供了有关要推送的内容的信息，格式为：</target>
        </trans-unit>
        <trans-unit id="43d35f7b76c469225469fd7a04662a08053d1e63" translate="yes" xml:space="preserve">
          <source>Initial client request</source>
          <target state="translated">最初的客户请求</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="1b499097655f7a7af4711e162d7e54be3deca803" translate="yes" xml:space="preserve">
          <source>Initialization happens in &lt;code&gt;main()&lt;/code&gt;. Behind the scenes, an &lt;code&gt;atexit&lt;/code&gt; and &lt;code&gt;signal&lt;/code&gt; handler are registered.</source>
          <target state="translated">初始化发生在 &lt;code&gt;main()&lt;/code&gt; 中。在幕后，注册了 &lt;code&gt;atexit&lt;/code&gt; 和 &lt;code&gt;signal&lt;/code&gt; 处理程序。</target>
        </trans-unit>
        <trans-unit id="42e32f1c6a8cf663f45361425590d312db136ea3" translate="yes" xml:space="preserve">
          <source>Initialize and modify the sparse-checkout</source>
          <target state="translated">初始化并修改稀疏结账。</target>
        </trans-unit>
        <trans-unit id="5be83bd5256f93987e394207f3c5233baf2d713e" translate="yes" xml:space="preserve">
          <source>Initialize and modify the sparse-checkout configuration, which reduces the checkout to a set of paths given by a list of patterns.</source>
          <target state="translated">初始化并修改稀疏签出配置,它将签出简化为一组由模式列表给出的路径。</target>
        </trans-unit>
        <trans-unit id="825b58a6f65001fb659dd3ff519bf4df985a29aa" translate="yes" xml:space="preserve">
          <source>Initialize the sparse-checkout file so the working directory starts with only the files in the root of the repository. The sparse-checkout file can be modified to grow the working directory as needed.</source>
          <target state="translated">初始化sparse-checkout文件,使工作目录仅以版本库根目录中的文件开始。Sparse-checkout文件可以根据需要进行修改以增加工作目录。</target>
        </trans-unit>
        <trans-unit id="9e0eca47ea83eb468f0ac7fe2e029fd23bbe773e" translate="yes" xml:space="preserve">
          <source>Initialize the submodules recorded in the index (which were added and committed elsewhere) by setting &lt;code&gt;submodule.$name.url&lt;/code&gt; in .git/config. It uses the same setting from &lt;code&gt;.gitmodules&lt;/code&gt; as a template. If the URL is relative, it will be resolved using the default remote. If there is no default remote, the current repository will be assumed to be upstream.</source>
          <target state="translated">通过在.git / config中设置 &lt;code&gt;submodule.$name.url&lt;/code&gt; 来初始化记录在索引中的子模块（已在其他位置添加并提交）。它使用 &lt;code&gt;.gitmodules&lt;/code&gt; 中的相同设置作为模板。如果URL是相对的，则将使用默认的远程服务器来解析。如果没有默认的远程服务器，则假定当前存储库位于上游。</target>
        </trans-unit>
        <trans-unit id="52f8f7589ec2fc901a83216cac5106872728a87d" translate="yes" xml:space="preserve">
          <source>Initialize, update or inspect submodules</source>
          <target state="translated">初始化、更新或检查子模块</target>
        </trans-unit>
        <trans-unit id="0d880d50dc463cd4220f01bcf54c48c1f2d57098" translate="yes" xml:space="preserve">
          <source>Initializes an empty Git repository with additional metadata directories for &lt;code&gt;git svn&lt;/code&gt;. The Subversion URL may be specified as a command-line argument, or as full URL arguments to -T/-t/-b. Optionally, the target directory to operate on can be specified as a second argument. Normally this command initializes the current directory.</source>
          <target state="translated">使用 &lt;code&gt;git svn&lt;/code&gt; 的其他元数据目录初始化一个空的Git存储库。Subversion URL可以指定为命令行参数，也可以指定为-T / -t / -b的完整URL参数。（可选）可以将要操作的目标目录指定为第二个参数。通常，此命令将初始化当前目录。</target>
        </trans-unit>
        <trans-unit id="01c2c8357a87e8a6148f1dd9a9c884aae5e4de53" translate="yes" xml:space="preserve">
          <source>Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.</source>
          <target state="translated">初始忽略移动检测中的任何whitepace,然后只有在每行whitepace变化相同的情况下,才将移动的代码块归为一个块。这与其他模式是不兼容的。</target>
        </trans-unit>
        <trans-unit id="229b7991e581f774e065f13c78dfa8719c8c393f" translate="yes" xml:space="preserve">
          <source>Inline data format</source>
          <target state="translated">内联数据格式</target>
        </trans-unit>
        <trans-unit id="7c7935726f449ea7185a4fe42a9ddf2d1c53a2e4" translate="yes" xml:space="preserve">
          <source>Input Format</source>
          <target state="translated">输入格式</target>
        </trans-unit>
        <trans-unit id="1b77a7f4983f9ce773f466c761a7f6e9771bf925" translate="yes" xml:space="preserve">
          <source>Input format</source>
          <target state="translated">输入格式</target>
        </trans-unit>
        <trans-unit id="789cc08a97020bab893e17ca6133192d1f9f1dac" translate="yes" xml:space="preserve">
          <source>Input is of the &quot;mboxrd&quot; format and &quot;^&amp;gt;+From &quot; line escaping is reversed.</source>
          <target state="translated">输入为&amp;ldquo; mboxrd&amp;rdquo;格式，并且&amp;ldquo; ^&amp;gt; + From&amp;rdquo;换行符相反。</target>
        </trans-unit>
        <trans-unit id="26242e7bd97bd8eebf44f9f25f143aed3a9bdc4d" translate="yes" xml:space="preserve">
          <source>Input/output format</source>
          <target state="translated">输入/输出格式</target>
        </trans-unit>
        <trans-unit id="4038e1c7ebc07b210c228498bd5816f54233b768" translate="yes" xml:space="preserve">
          <source>Insert &lt;code&gt;progress&lt;/code&gt; statements every &amp;lt;n&amp;gt; objects, to be shown by &lt;code&gt;git fast-import&lt;/code&gt; during import.</source>
          <target state="translated">在每个&amp;lt;n&amp;gt;对象中插入 &lt;code&gt;progress&lt;/code&gt; 语句，以在 &lt;code&gt;git fast-import&lt;/code&gt; 期间由git fast-import显示。</target>
        </trans-unit>
        <trans-unit id="39c559793b49987eea00aba844e216707b6e7dcc" translate="yes" xml:space="preserve">
          <source>Insert custom links to the action bar of all project pages. This allows you to link to third-party scripts integrating into gitweb.</source>
          <target state="translated">在所有项目页面的操作栏中插入自定义链接。这允许你链接到集成到gitweb的第三方脚本。</target>
        </trans-unit>
        <trans-unit id="ce8fd02283c353dc3cacd2d3e6c1eab64a1913a3" translate="yes" xml:space="preserve">
          <source>Inside double quotes, double quote &lt;code&gt;&quot;&lt;/code&gt; and backslash &lt;code&gt;\&lt;/code&gt; characters must be escaped: use &lt;code&gt;\&quot;&lt;/code&gt; for &lt;code&gt;&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt; for &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">在双引号中，必须对双引号 &lt;code&gt;&quot;&lt;/code&gt; 和反斜杠 &lt;code&gt;\&lt;/code&gt; 字符进行转义：使用 &lt;code&gt;\&quot;&lt;/code&gt; 表示 &lt;code&gt;&quot;&lt;/code&gt; ，使用 &lt;code&gt;\\&lt;/code&gt; 表示 &lt;code&gt;\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab67c68674bb4a9f1f690fac98c95aa9c2e1e750" translate="yes" xml:space="preserve">
          <source>Inspecting changes</source>
          <target state="translated">检查变化</target>
        </trans-unit>
        <trans-unit id="ecf21e44dd8609734c0bc387cabc376ab485d9f8" translate="yes" xml:space="preserve">
          <source>Inspection and Comparison</source>
          <target state="translated">检查和比较</target>
        </trans-unit>
        <trans-unit id="e0c3f2780ee983978068137722cf2d423843d21f" translate="yes" xml:space="preserve">
          <source>Inspects, updates and manages submodules.</source>
          <target state="translated">检查、更新和管理子模块。</target>
        </trans-unit>
        <trans-unit id="d9fb6eb12bbc11fdad6f18ee5bfa79361ddad72b" translate="yes" xml:space="preserve">
          <source>Install the Toggle Word Wrap add-on that is available from &lt;a href=&quot;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&quot;&gt;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&lt;/a&gt; It adds a menu entry &quot;Enable Word Wrap&quot; in the composer&amp;rsquo;s &quot;Options&quot; menu that you can tick off. Now you can compose the message as you otherwise do (cut + paste, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt;, etc), but you have to insert line breaks manually in any text that you type.</source>
          <target state="translated">安装可从&lt;a href=&quot;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&quot;&gt;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&lt;/a&gt;获得的Toggle Word Wrap附加组件，它在作曲家的&amp;ldquo;选项&amp;rdquo;菜单中添加菜单项&amp;ldquo; Enable Word Wrap&amp;rdquo;，该菜单项您可以勾选。现在，您可以像其他方式一样编写消息（剪切+粘贴， &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt; 等），但是您必须在键入的任何文本中手动插入换行符。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="7fad939655efbad1612ce7f4867922684d56913b" translate="yes" xml:space="preserve">
          <source>Instantly browse your working repository in gitweb</source>
          <target state="translated">在gitweb中即时浏览你的工作仓库。</target>
        </trans-unit>
        <trans-unit id="53c902fb07156c6117155b6a0b0738c7ca12a6bf" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;git bisect visualize&lt;/code&gt; and then &lt;code&gt;git reset --hard
fb47ddb2db&lt;/code&gt;, you might just want to tell Git that you want to skip the current commit:</source>
          <target state="translated">而不是 &lt;code&gt;git bisect visualize&lt;/code&gt; 然后 &lt;code&gt;git reset --hard fb47ddb2db&lt;/code&gt; ，您可能只想告诉Git您要跳过当前提交：</target>
        </trans-unit>
        <trans-unit id="483617d942bddc8b6c044cd054e06089960e1981" translate="yes" xml:space="preserve">
          <source>Instead of a commit id on the command line (which is not expected in this case), &lt;code&gt;git http-fetch&lt;/code&gt; expects lines on stdin in the format</source>
          <target state="translated">&lt;code&gt;git http-fetch&lt;/code&gt; 期望stdin上的行采用以下格式，而不是命令行上的提交ID（在这种情况下是不希望的）</target>
        </trans-unit>
        <trans-unit id="78b5184ca479cbe7999ac4fee6c0be2a7fd5b77a" translate="yes" xml:space="preserve">
          <source>Instead of a commit id on the command line (which is not expected in this case), &lt;code&gt;git http-fetch&lt;/code&gt; fetches the packfile directly at the given URL and uses index-pack to generate corresponding .idx and .keep files. The hash is used to determine the name of the temporary file and is arbitrary. The output of index-pack is printed to stdout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978fdd37a8d1d967862cc9e916d011571d6998cf" translate="yes" xml:space="preserve">
          <source>Instead of an absolute timestamp relative timestamps work as well, e.g. 2.weeks.ago is valid to address anything older than 2 weeks.</source>
          <target state="translated">相对时间戳也可以代替绝对时间戳,例如:2.weeks.ago对任何超过2周的内容都有效。</target>
        </trans-unit>
        <trans-unit id="ad6345e758058b67dc8e001b3a11fe48b9b5f52b" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, output a condensed summary of information obtained from git diff extended headers, such as creations, renames and mode changes. Turns off &quot;apply&quot;.</source>
          <target state="translated">不应用补丁,而是输出从 git diff 扩展头中获取的信息的精简摘要,如创建、重命名和模式更改。关闭 &quot;应用&quot;。</target>
        </trans-unit>
        <trans-unit id="5429abc21a21a789987424e6c0ab7612e06a85eb" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, output diffstat for the input. Turns off &quot;apply&quot;.</source>
          <target state="translated">不应用补丁,而是输出输入的diffstat。关闭 &quot;应用&quot;。</target>
        </trans-unit>
        <trans-unit id="881bf52883e6605d5234b3f22aaf3b7b4afc6968" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, see if the patch is applicable to the current working tree and/or the index file and detects errors. Turns off &quot;apply&quot;.</source>
          <target state="translated">不应用补丁,而是查看补丁是否适用于当前工作树和/或索引文件,并检测错误。关闭 &quot;应用&quot;。</target>
        </trans-unit>
        <trans-unit id="6e355f85b13671d925fde0c740a0dbae977bb0bc" translate="yes" xml:space="preserve">
          <source>Instead of basing a new branch on current HEAD (the default), use:</source>
          <target state="translated">与其在当前的HEAD(默认)上新建一个分支,不如使用。</target>
        </trans-unit>
        <trans-unit id="54f9cd044bb973ffe696d82cb4d71b8b1fd61c38" translate="yes" xml:space="preserve">
          <source>Instead of calling cvsps, read the provided cvsps output file. Useful for debugging or when cvsps is being handled outside cvsimport.</source>
          <target state="translated">不调用 cvsps,而是读取提供的 cvsps 输出文件。对调试或当 cvsps 在 cvsimport 外处理时很有用。</target>
        </trans-unit>
        <trans-unit id="bb5ec3e62f50f37c713576e81a7468472cf1721e" translate="yes" xml:space="preserve">
          <source>Instead of checking out unmerged entries, copy out the files from named stage. &amp;lt;number&amp;gt; must be between 1 and 3. Note: --stage=all automatically implies --temp.</source>
          <target state="translated">无需签出未合并的条目，而是从命名阶段复制文件。&amp;lt;number&amp;gt;必须介于1到3之间。注意：--stage = all自动表示--temp。</target>
        </trans-unit>
        <trans-unit id="15d18d5e837d77d2ad93145197274038afcfa944" translate="yes" xml:space="preserve">
          <source>Instead of choosing a nearby commit by yourself, you can ask Git to do it for you by issuing the command:</source>
          <target state="translated">与其自己选择附近的提交,不如让 Git 代为选择。</target>
        </trans-unit>
        <trans-unit id="071c6c805d6df82b0ae0937a6e3d6e7d94979975" translate="yes" xml:space="preserve">
          <source>Instead of comparing with the tip of &quot;test&quot; branch, compare with the tip of the current branch, but limit the comparison to the file &quot;test&quot;.</source>
          <target state="translated">不与 &quot;test &quot;分支的顶端进行比较,而是与当前分支的顶端进行比较,但将比较范围限制在 &quot;test &quot;文件上。</target>
        </trans-unit>
        <trans-unit id="17207c6e7e5006477485c406ccec2ab95d9a0907" translate="yes" xml:space="preserve">
          <source>Instead of considering only the 10 most recent tags as candidates to describe the input commit-ish consider up to &amp;lt;n&amp;gt; candidates. Increasing &amp;lt;n&amp;gt; above 10 will take slightly longer but may produce a more accurate result. An &amp;lt;n&amp;gt; of 0 will cause only exact matches to be output.</source>
          <target state="translated">与其仅考虑10个最新标签作为描述输入提交的候选对象，不如考虑最多&amp;lt;n&amp;gt;个候选对象。将&amp;lt;n&amp;gt;增加到10以上将花费更长的时间，但可能会产生更准确的结果。&amp;lt;n&amp;gt;为0将导致仅输出完全匹配项。</target>
        </trans-unit>
        <trans-unit id="3d51a8a573b601f04a9b432f10be7818f6056cab" translate="yes" xml:space="preserve">
          <source>Instead of copying the files to the working directory write the content to temporary files. The temporary name associations will be written to stdout.</source>
          <target state="translated">不把文件复制到工作目录中,而是把内容写入临时文件。临时名称关联将被写入stdout。</target>
        </trans-unit>
        <trans-unit id="aece37f2a7e1b433117b2533e4c10ff1af967895" translate="yes" xml:space="preserve">
          <source>Instead of explicitly specifying which refs to update, update all heads that locally exist.</source>
          <target state="translated">不需要明确指定要更新哪些refs,而是更新本地存在的所有头。</target>
        </trans-unit>
        <trans-unit id="c9dd00560176cb59ca6811a38f98f0a00cea59a2" translate="yes" xml:space="preserve">
          <source>Instead of finding the tag that predates the commit, find the tag that comes after the commit, and thus contains it. Automatically implies --tags.</source>
          <target state="translated">不要找在提交之前的标签,而要找在提交之后的标签,从而包含它。自动意味着-tags。</target>
        </trans-unit>
        <trans-unit id="c3bcf62d531bd115333abb263736c08fc67412f8" translate="yes" xml:space="preserve">
          <source>Instead of having gitweb find repositories by scanning filesystem starting from $projectroot, you can provide a pre-generated list of visible projects by setting &lt;code&gt;$projects_list&lt;/code&gt; to point to a plain text file with a list of projects (with some additional info).</source>
          <target state="translated">而不是让gitweb通过扫描从$ projectroot开始的文件系统来查找存储库，而是可以通过将 &lt;code&gt;$projects_list&lt;/code&gt; 设置为指向包含项目列表（带有一些附加信息）的纯文本文件，来提供可见项目的预生成列表。</target>
        </trans-unit>
        <trans-unit id="b8a426e0ceafe99f9ee69973b04f605e2dee7cb4" translate="yes" xml:space="preserve">
          <source>Instead of incrementally packing the unpacked objects, pack everything referenced into a single pack. Especially useful when packing a repository that is used for private development. Use with &lt;code&gt;-d&lt;/code&gt;. This will clean up the objects that &lt;code&gt;git prune&lt;/code&gt; leaves behind, but &lt;code&gt;git fsck --full --dangling&lt;/code&gt; shows as dangling.</source>
          <target state="translated">与其增量打包未打包的对象，不如将所有引用的对象打包到一个包中。打包用于私有开发的存储库时特别有用。与 &lt;code&gt;-d&lt;/code&gt; 一起使用。这将清除 &lt;code&gt;git prune&lt;/code&gt; 留下的对象，但是 &lt;code&gt;git fsck --full --dangling&lt;/code&gt; 显示为悬挂。</target>
        </trans-unit>
        <trans-unit id="f1ffab5966e331d53c3cb8a3d86f241f936c7bef" translate="yes" xml:space="preserve">
          <source>Instead of initializing the repository as a directory to either &lt;code&gt;$GIT_DIR&lt;/code&gt; or &lt;code&gt;./.git/&lt;/code&gt;, create a text file there containing the path to the actual repository. This file acts as filesystem-agnostic Git symbolic link to the repository.</source>
          <target state="translated">无需将存储库初始化为 &lt;code&gt;$GIT_DIR&lt;/code&gt; 或 &lt;code&gt;./.git/&lt;/code&gt; 的目录，而是在其中创建一个包含实际存储库路径的文本文件。该文件充当与存储库无关的文件系统Git符号链接。</target>
        </trans-unit>
        <trans-unit id="f0ef88b9adcd939e8a3f3a231e5d0c4737f1545c" translate="yes" xml:space="preserve">
          <source>Instead of leaving conflicts in the file, resolve conflicts favouring our (or their or both) side of the lines.</source>
          <target state="translated">不要在文件中留下冲突,而要解决有利于我方(或他们或双方)的冲突。</target>
        </trans-unit>
        <trans-unit id="ca8be3d7e71d110990923e82a424a61c61fcfea3" translate="yes" xml:space="preserve">
          <source>Instead of making a tar archive from the local repository, retrieve a tar archive from a remote repository. Note that the remote repository may place restrictions on which sha1 expressions may be allowed in &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;. See &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt; for details.</source>
          <target state="translated">与其从本地存储库制作tar归档，不如从远程存储库检索tar归档。请注意，远程存储库可能对 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 中可能允许的sha1表达式进行限制。有关详细信息，请参见&lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f9313c2b37d59bfbfa07ff3336c61ac5f242846" translate="yes" xml:space="preserve">
          <source>Instead of multiple service names, multiple commands will be supported by a single service</source>
          <target state="translated">一个服务将代替多个服务名称,支持多个命令。</target>
        </trans-unit>
        <trans-unit id="9913e3351ae1177f0328b10cfa41d1a78100d839" translate="yes" xml:space="preserve">
          <source>Instead of naming each ref to push, specifies that all refs under &lt;code&gt;refs/&lt;/code&gt; (which includes but is not limited to &lt;code&gt;refs/heads/&lt;/code&gt;, &lt;code&gt;refs/remotes/&lt;/code&gt;, and &lt;code&gt;refs/tags/&lt;/code&gt;) be mirrored to the remote repository. Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end. This is the default if the configuration option &lt;code&gt;remote.&amp;lt;remote&amp;gt;.mirror&lt;/code&gt; is set.</source>
          <target state="translated">而不是命名每个ref推送，而是指定 &lt;code&gt;refs/&lt;/code&gt; 下的所有ref （包括但不限于 &lt;code&gt;refs/heads/&lt;/code&gt; ， &lt;code&gt;refs/remotes/&lt;/code&gt; 和 &lt;code&gt;refs/tags/&lt;/code&gt; ）都镜像到远程存储库。新创建的本地裁判将被推送到远程端，本地更新的裁判将在远程端强制更新，而已删除的裁判将从远程端删除。如果设置了配置选项 &lt;code&gt;remote.&amp;lt;remote&amp;gt;.mirror&lt;/code&gt; 则这是默认设置。</target>
        </trans-unit>
        <trans-unit id="9634150ab7e71bf3eb3f2b25ec8ede96c11d4e06" translate="yes" xml:space="preserve">
          <source>Instead of naming the commits using the path to reach them from heads (e.g. &quot;master~2&quot; to mean the grandparent of &quot;master&quot;), name them with the unique prefix of their object names.</source>
          <target state="translated">不要用从头到尾的路径来命名提交(例如 &quot;master~2 &quot;表示 &quot;master &quot;的祖辈),而是用其对象名的唯一前缀来命名。</target>
        </trans-unit>
        <trans-unit id="17b0b1c8040238e6478f5b3afd0b8cbc3b08f080" translate="yes" xml:space="preserve">
          <source>Instead of placing the cloned repository where it is supposed to be, place the cloned repository at the specified directory, then make a filesystem-agnostic Git symbolic link to there. The result is Git repository can be separated from working tree.</source>
          <target state="translated">不把克隆的仓库放在它应该在的地方,而是把克隆的仓库放在指定的目录下,然后做一个与文件系统无关的 Git 符号链接到那里。其结果是Git仓库可以与工作树分离。</target>
        </trans-unit>
        <trans-unit id="22fb130092ca941fcb14aff3909ae71b595afba3" translate="yes" xml:space="preserve">
          <source>Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository&amp;rsquo;s HEAD, point to &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; branch instead. In a non-bare repository, this is the branch that will be checked out. &lt;code&gt;--branch&lt;/code&gt; can also take tags and detaches the HEAD at that commit in the resulting repository.</source>
          <target state="translated">不要将新创建的HEAD指向克隆存储库的HEAD所指向的分支，而是指向 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 分支。在非裸仓库中，这是将被检出的分支。 &lt;code&gt;--branch&lt;/code&gt; 还可以获取标签，并在结果存储库中的提交时分离HEAD。</target>
        </trans-unit>
        <trans-unit id="33ebce829b735e00e4c7bea8b4f644ee8c315aa6" translate="yes" xml:space="preserve">
          <source>Instead of printing both the SHA-1 and the name, print only the name. If given with --tags the usual tag prefix of &quot;tags/&quot; is also omitted from the name, matching the output of &lt;code&gt;git-describe&lt;/code&gt; more closely.</source>
          <target state="translated">而不是同时打印SHA-1和名称，仅打印名称。如果使用--tags给出，则名称中也将省略通常的标签前缀&amp;ldquo; tags /&amp;rdquo;，从而更紧密地匹配 &lt;code&gt;git-describe&lt;/code&gt; 的输出。</target>
        </trans-unit>
        <trans-unit id="064cb6e81b93b30bcf346d10dc97336e618d6fae" translate="yes" xml:space="preserve">
          <source>Instead of printing merge bases, print a minimal subset of the supplied commits with the same ancestors. In other words, among the commits given, list those which cannot be reached from any other. This mimics the behavior of &lt;code&gt;git show-branch --independent&lt;/code&gt;.</source>
          <target state="translated">除了打印合并库外，还可以打印具有相同祖先的最小提交子集。换句话说，在给定的提交中，列出了其他任何无法到达的提交。这模仿了 &lt;code&gt;git show-branch --independent&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="323f56e14b223cf1dac7d6a09fb1d2d15675463d" translate="yes" xml:space="preserve">
          <source>Instead of printing the paths that are excluded, for each path that matches an exclude pattern, print the exclude pattern together with the path. (Matching an exclude pattern usually means the path is excluded, but if the pattern begins with &lt;code&gt;!&lt;/code&gt; then it is a negated pattern and matching it means the path is NOT excluded.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a77a1e8325cae4bfdfe406c89eaae3fe4ca07d52" translate="yes" xml:space="preserve">
          <source>Instead of reading a list of objects on stdin, perform the requested batch operation on all objects in the repository and any alternate object stores (not just reachable objects). Requires &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; be specified. Note that the objects are visited in order sorted by their hashes.</source>
          <target state="translated">与其在stdin上读取对象列表，不如对存储库中的所有对象以及任何备用对象存储（不仅仅是可访问的对象）执行请求的批处理操作。需要指定 &lt;code&gt;--batch&lt;/code&gt; 或 &lt;code&gt;--batch-check&lt;/code&gt; 。请注意，对象是按其哈希排序的。</target>
        </trans-unit>
        <trans-unit id="d4a14000f7e28706a0e6c2e4729bb02543a4d281" translate="yes" xml:space="preserve">
          <source>Instead of reading tree object(s) into the index, just empty it.</source>
          <target state="translated">不把树对象读到索引中,而只是清空它。</target>
        </trans-unit>
        <trans-unit id="5828d05fd5c0a35f4392daf67536f9a77ece2b90" translate="yes" xml:space="preserve">
          <source>Instead of running &lt;code&gt;git repack&lt;/code&gt; you can also run &lt;code&gt;git gc
--aggressive&lt;/code&gt;, which will also optimize other things after an import (e.g. pack loose refs). As noted in the &quot;AGGRESSIVE&quot; section in &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; the &lt;code&gt;--aggressive&lt;/code&gt; option will find new deltas with the &lt;code&gt;-f&lt;/code&gt; option to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. For the reasons elaborated on above using &lt;code&gt;--aggressive&lt;/code&gt; after a fast-import is one of the few cases where it&amp;rsquo;s known to be worthwhile.</source>
          <target state="translated">除了运行 &lt;code&gt;git repack&lt;/code&gt; 外,您还可以运行 &lt;code&gt;git gc --aggressive&lt;/code&gt; ，它还会在导入后优化其他内容（例如，打包松散的引用）。如&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;的&amp;ldquo; &lt;code&gt;--aggressive&lt;/code&gt; &amp;rdquo;部分所述，-- aggressive选项将使用&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;的 &lt;code&gt;-f&lt;/code&gt; 选项查找新的增量。出于上述原因，在快速导入后使用 &lt;code&gt;--aggressive&lt;/code&gt; 是众所周知的少数值得使用的情况之一。</target>
        </trans-unit>
        <trans-unit id="27d7e1d82cdbf4a022b1041bc3a4b5c02db03622" translate="yes" xml:space="preserve">
          <source>Instead of running one of the known diff tools, &lt;code&gt;git difftool&lt;/code&gt; can be customized to run an alternative program by specifying the command line to invoke in a configuration variable &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt;.</source>
          <target state="translated">可以通过指定命令行以在配置变量 &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 调用来自定义 &lt;code&gt;git difftool&lt;/code&gt; ,以运行替代程序，而不是运行已知的diff工具之一。</target>
        </trans-unit>
        <trans-unit id="0a6ec50c9a1e350ef9a3f4f762c317cd2d6e8233" translate="yes" xml:space="preserve">
          <source>Instead of running one of the known merge tool programs, &lt;code&gt;git mergetool&lt;/code&gt; can be customized to run an alternative program by specifying the command line to invoke in a configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt;.</source>
          <target state="translated">通过指定在配置变量 &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 调用的命令行，可以自定义 &lt;code&gt;git mergetool&lt;/code&gt; 来运行替代程序，而不是运行已知的合并工具程序之一。</target>
        </trans-unit>
        <trans-unit id="09dffc4d1650e5ccccc05b0bf19a3e3e59eb7116" translate="yes" xml:space="preserve">
          <source>Instead of searching tracked files in the working tree, search blobs in the given trees.</source>
          <target state="translated">而不是在工作树中搜索跟踪的文件,而是在给定的树中搜索 blobs。</target>
        </trans-unit>
        <trans-unit id="31ae83b44368ffd8feca3b205d3db8ea7d6a3c5c" translate="yes" xml:space="preserve">
          <source>Instead of searching tracked files in the working tree, search blobs registered in the index file.</source>
          <target state="translated">不搜索工作树中的跟踪文件,而是搜索在索引文件中注册的 blobs。</target>
        </trans-unit>
        <trans-unit id="55e6c9aa38dceb73a0632da59bc95f69bdfc3cb4" translate="yes" xml:space="preserve">
          <source>Instead of showing every matched line, show only the names of files that contain (or do not contain) matches. For better compatibility with &lt;code&gt;git diff&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt; is a synonym for &lt;code&gt;--files-with-matches&lt;/code&gt;.</source>
          <target state="translated">不显示所有匹配的行，而仅显示包含（或不包含）匹配项的文件名。为了更好地与 &lt;code&gt;git diff&lt;/code&gt; 兼容， &lt;code&gt;--name-only&lt;/code&gt; &lt;code&gt;--files-with-matches&lt;/code&gt; only是--files-with-matches的同义词。</target>
        </trans-unit>
        <trans-unit id="f1fdcf67f0afaa931922f6239ba4fdd53758ce0d" translate="yes" xml:space="preserve">
          <source>Instead of showing every matched line, show the number of lines that match.</source>
          <target state="translated">不显示每个匹配的行,而是显示匹配的行数。</target>
        </trans-unit>
        <trans-unit id="9ddb49ffe2885e9ce52c33a63e80e23af2a075a9" translate="yes" xml:space="preserve">
          <source>Instead of showing the commit list, determine possible merge bases for the specified commits. All merge bases will be contained in all specified commits. This is different from how &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt; handles the case of three or more commits.</source>
          <target state="translated">为显示指定的提交确定可能的合并基础，而不是显示提交列表。所有合并基础将包含在所有指定的提交中。这与&lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]&lt;/a&gt;处理三个或更多提交的情况不同。</target>
        </trans-unit>
        <trans-unit id="6ba3d7561fe60e77ce239084badd1d1856e50d97" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal commit object name, show only a partial prefix. Non default number of digits can be specified with &quot;--abbrev=&amp;lt;n&amp;gt;&quot; (which also modifies diff output, if it is displayed).</source>
          <target state="translated">不显示完整的40字节十六进制提交对象名称，而仅显示部分前缀。可以使用&amp;ldquo; --abbrev = &amp;lt;n&amp;gt;&amp;rdquo;指定非默认位数（如果显示的话，它也会修改diff输出）。</target>
        </trans-unit>
        <trans-unit id="7d6a3b8755cc865088fd97c8d79f6b68eb4292bc" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object lines, show only a partial prefix. Non default number of digits can be specified with --abbrev=&amp;lt;n&amp;gt;.</source>
          <target state="translated">不显示完整的40字节十六进制对象行，而仅显示部分前缀。可以使用--abbrev = &amp;lt;n&amp;gt;指定非默认位数。</target>
        </trans-unit>
        <trans-unit id="58ecb5df7fcdb6c0e019f4aa574b567ad3276395" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show only a partial prefix. In diff-patch output format, &lt;code&gt;--full-index&lt;/code&gt; takes higher precedence, i.e. if &lt;code&gt;--full-index&lt;/code&gt; is specified, full blob names will be shown regardless of &lt;code&gt;--abbrev&lt;/code&gt;. Non default number of digits can be specified with &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd3315e868be633e341c6b1fc6b217d4459f224" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show only a partial prefix. This is independent of the &lt;code&gt;--full-index&lt;/code&gt; option above, which controls the diff-patch output format. Non default number of digits can be specified with &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">与其以diff-raw格式的输出和diff-tree标头行显示完整的40字节十六进制对象名，而仅显示部分前缀。这与上面的 &lt;code&gt;--full-index&lt;/code&gt; 选项无关，后者控制diff-patch输出格式。可以使用 &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt; 指定非默认位数。</target>
        </trans-unit>
        <trans-unit id="0ac504d3062e8b5bad74846fd627b7807bedc4f2" translate="yes" xml:space="preserve">
          <source>Instead of showing the path names relative to the current working directory, show the full path names.</source>
          <target state="translated">不显示相对于当前工作目录的路径名,而是显示完整的路径名。</target>
        </trans-unit>
        <trans-unit id="5f0ed09aafafab46ef0c48e35d2b30851c21ae6a" translate="yes" xml:space="preserve">
          <source>Instead of staging files after each individual change, you can tell &lt;code&gt;git commit&lt;/code&gt; to notice the changes to the files whose contents are tracked in your working tree and do corresponding &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git rm&lt;/code&gt; for you. That is, this example does the same as the earlier example if there is no other change in your working tree:</source>
          <target state="translated">您可以让 &lt;code&gt;git commit&lt;/code&gt; 注意到在工作树中跟踪其内容的文件的更改，而不是在每次单独更改后暂存文件，并为您执行相应的 &lt;code&gt;git add&lt;/code&gt; 和 &lt;code&gt;git rm&lt;/code&gt; 。也就是说，如果您的工作树没有其他更改，那么此示例与先前的示例相同：</target>
        </trans-unit>
        <trans-unit id="a675a0b8f5c03b948f0d18f87a17852f45d21abd" translate="yes" xml:space="preserve">
          <source>Instead of stopping at the first failed merge, do all of them in one shot - continue with merging even when previous merges returned errors, and only return the error code after all the merges.</source>
          <target state="translated">不要停留在第一次失败的合并上,而是一次性完成所有的合并--即使之前的合并返回错误,也要继续进行合并,只有在所有合并后才返回错误代码。</target>
        </trans-unit>
        <trans-unit id="de32bccd3ddde71a98cffd2de1232e1c99dfd513" translate="yes" xml:space="preserve">
          <source>Instead of submitting create a series of shelved changelists. After creating each shelve, the relevant files are reverted/deleted. If you have multiple commits pending multiple shelves will be created.</source>
          <target state="translated">而不是提交创建一系列搁置的变更列表。在创建每个架子后,相关文件会被还原/删除。如果你有多个待提交的提交,就会创建多个架子。</target>
        </trans-unit>
        <trans-unit id="140c71a8b471c44c130e5b1eee8b0237e8238e05" translate="yes" xml:space="preserve">
          <source>Instead of taking list of paths from the command line, read list of paths from the standard input. Paths are separated by LF (i.e. one path per line) by default.</source>
          <target state="translated">不从命令行中获取路径列表,而是从标准输入中读取路径列表。默认情况下,路径用LF分隔(即每行一个路径)。</target>
        </trans-unit>
        <trans-unit id="f4ba2e4e1080efba3c28ca42286f9295fb7a6889" translate="yes" xml:space="preserve">
          <source>Instead of the commit subject, use some other information to describe each commit. &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can be any string accepted by the &lt;code&gt;--format&lt;/code&gt; option of &lt;code&gt;git log&lt;/code&gt;, such as &lt;code&gt;* [%h] %s&lt;/code&gt;. (See the &quot;PRETTY FORMATS&quot; section of &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.)</source>
          <target state="translated">代替提交主题，使用其他一些信息来描述每个提交。 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 可以是 &lt;code&gt;git log&lt;/code&gt; 的 &lt;code&gt;--format&lt;/code&gt; 选项接受的任何字符串，例如 &lt;code&gt;* [%h] %s&lt;/code&gt; 。（请参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;的&amp;ldquo; PRETTY FORMATS&amp;rdquo;一节。）</target>
        </trans-unit>
        <trans-unit id="a4e872330a2ee34ffbac6bb806a9bf43b1d76b3c" translate="yes" xml:space="preserve">
          <source>Instead of the content, show the object size identified by &amp;lt;object&amp;gt;.</source>
          <target state="translated">代替内容，显示由&amp;lt;object&amp;gt;标识的对象大小。</target>
        </trans-unit>
        <trans-unit id="f066e23ab4bd2d63e94325b4a2a048945fb424e1" translate="yes" xml:space="preserve">
          <source>Instead of the content, show the object type identified by &amp;lt;object&amp;gt;.</source>
          <target state="translated">代替内容，显示由&amp;lt;object&amp;gt;标识的对象类型。</target>
        </trans-unit>
        <trans-unit id="01b660ce7f25b8747605b72657d7e3925704df33" translate="yes" xml:space="preserve">
          <source>Instead of the default &quot;symref&quot; format for HEAD and other symbolic reference files, use symbolic links. This is sometimes needed to work with old scripts that expect HEAD to be a symbolic link.</source>
          <target state="translated">对于HEAD和其他符号引用文件,使用符号链接而不是默认的 &quot;symref &quot;格式。有时需要这样做,以配合那些期望HEAD是一个符号链接的旧脚本。</target>
        </trans-unit>
        <trans-unit id="f146d5682a8b5a97d10d05b37274aa1ba3a49c07" translate="yes" xml:space="preserve">
          <source>Instead of the default 4 digits with leading zeros, different precision can be specified for the generated filenames.</source>
          <target state="translated">可以为生成的文件名指定不同的精度,而不是默认的带前导零的4位数。</target>
        </trans-unit>
        <trans-unit id="e1d28ba0f9256454e559ca46e186461c224089ef" translate="yes" xml:space="preserve">
          <source>Instead of the first handful of characters, show the full pre- and post-image blob object names on the &quot;index&quot; line when generating patch format output.</source>
          <target state="translated">在生成补丁格式输出时,在 &quot;索引 &quot;行上显示完整的图像前和图像后blob对象名称,而不是前几个字符。</target>
        </trans-unit>
        <trans-unit id="e3b6588aa8ce45f7528fa4adfa5f41dc47858a56" translate="yes" xml:space="preserve">
          <source>Instead of the normal operation, dump the shorthand alias names from the configured alias file(s), one per line in alphabetical order. Note, this only includes the alias name and not its expanded email addresses. See &lt;code&gt;sendemail.aliasesfile&lt;/code&gt; for more information about aliases.</source>
          <target state="translated">代替正常操作，转储已配置别名文件中的速记别名名称，以字母顺序每行一个。请注意，这仅包括别名，而不包括其扩展的电子邮件地址。有关别名的更多信息，请参见 &lt;code&gt;sendemail.aliasesfile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77a59d82290cfd961dc9ff35f15683facfa89709" translate="yes" xml:space="preserve">
          <source>Instead of the standard &lt;code&gt;[PATCH]&lt;/code&gt; prefix in the subject line, instead use &lt;code&gt;[&amp;lt;subject prefix&amp;gt;]&lt;/code&gt;. This allows for useful naming of a patch series, and can be combined with the &lt;code&gt;--numbered&lt;/code&gt; option.</source>
          <target state="translated">代替主题行中的标准 &lt;code&gt;[PATCH]&lt;/code&gt; 前缀，而使用 &lt;code&gt;[&amp;lt;subject prefix&amp;gt;]&lt;/code&gt; 。这样可以对补丁系列进行有用的命名，并且可以与 &lt;code&gt;--numbered&lt;/code&gt; 选项结合使用。</target>
        </trans-unit>
        <trans-unit id="440b20677cca3bad5d5589368544d09ff6997de8" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;, you can also choose just to update one branch at a time, and to store it locally under an arbitrary name:</source>
          <target state="translated">除了使用&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]之外&lt;/a&gt;，您还可以选择仅一次更新一个分支，并以任意名称在本地存储它：</target>
        </trans-unit>
        <trans-unit id="c80da0469d96c6db5cfae1c5b4b2cc65c570bdb0" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;.patch&lt;/code&gt; as the suffix for generated filenames, use specified suffix. A common alternative is &lt;code&gt;--suffix=.txt&lt;/code&gt;. Leaving this empty will remove the &lt;code&gt;.patch&lt;/code&gt; suffix.</source>
          <target state="translated">不要使用 &lt;code&gt;.patch&lt;/code&gt; 作为生成的文件名的后缀，而应使用指定的后缀。一个常见的替代方法是 &lt;code&gt;--suffix=.txt&lt;/code&gt; 。将其保留为空将删除 &lt;code&gt;.patch&lt;/code&gt; 后缀。</target>
        </trans-unit>
        <trans-unit id="f82d2e94f21038afaa9f1d66d3a9a0e365538f7c" translate="yes" xml:space="preserve">
          <source>Instead of using only the annotated tags, use any ref found in &lt;code&gt;refs/&lt;/code&gt; namespace. This option enables matching any known branch, remote-tracking branch, or lightweight tag.</source>
          <target state="translated">不仅要使用带注释的标签， &lt;code&gt;refs/&lt;/code&gt; 使用在refs /名称空间中找到的所有ref 。使用此选项可以匹配任何已知分支，远程跟踪分支或轻量级标记。</target>
        </trans-unit>
        <trans-unit id="1177311a3949b6b80d45daef7bf2616b79441b65" translate="yes" xml:space="preserve">
          <source>Instead of using only the annotated tags, use any tag found in &lt;code&gt;refs/tags&lt;/code&gt; namespace. This option enables matching a lightweight (non-annotated) tag.</source>
          <target state="translated">不仅要使用带注释的标签，还可以使用在 &lt;code&gt;refs/tags&lt;/code&gt; 名称空间中找到的任何标签。使用此选项可以匹配轻量级（无注释）标签。</target>
        </trans-unit>
        <trans-unit id="525df652b887a2877266435635ef66426239fc1d" translate="yes" xml:space="preserve">
          <source>Instead of using the author date of the original commit, use the current time as the author date of the rebased commit. This option implies &lt;code&gt;--force-rebase&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4860002e825b16be9527700d7d5e647a6362a7ef" translate="yes" xml:space="preserve">
          <source>Instead of using the current time as the committer date, use the author date of the commit being rebased as the committer date. This option implies &lt;code&gt;--force-rebase&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa50874379be0d623d79d8af182cc42f83a49b1c" translate="yes" xml:space="preserve">
          <source>Instead of using the default 7 hexadecimal digits as the abbreviated object name, use &amp;lt;n&amp;gt; digits, or as many digits as needed to form a unique object name. An &amp;lt;n&amp;gt; of 0 will suppress long format, only showing the closest tag.</source>
          <target state="translated">不要使用默认的7位十六进制数字作为缩写对象名称，而应使用&amp;lt;n&amp;gt;位数字，或根据需要使用任意多个数字来形成唯一的对象名称。&amp;lt;n&amp;gt;为0将禁止长格式，仅显示最接近的标记。</target>
        </trans-unit>
        <trans-unit id="183487409af3884cbc9c819c550a69752622875c" translate="yes" xml:space="preserve">
          <source>Instead of using the default 7+1 hexadecimal digits as the abbreviated object name, use &amp;lt;n&amp;gt;+1 digits. Note that 1 column is used for a caret to mark the boundary commit.</source>
          <target state="translated">代替使用默认的7 + 1十六进制数字作为缩写对象名称，而使用&amp;lt;n&amp;gt; +1数字。请注意，1列用于插入标记以标记边界提交。</target>
        </trans-unit>
        <trans-unit id="ee5547b5d72f6d52e84d0986cad360b6f68e956a" translate="yes" xml:space="preserve">
          <source>Instead of using the remote name &lt;code&gt;origin&lt;/code&gt; to keep track of the upstream repository, use &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">代替使用远程名称 &lt;code&gt;origin&lt;/code&gt; 来跟踪上游存储库，而使用 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acaf18a5ec5cac3fd2f3b3d56ba27133d9e16abf" translate="yes" xml:space="preserve">
          <source>Instead of using the tip of the current branch, compare with the tip of &quot;test&quot; branch.</source>
          <target state="translated">不使用当前分支的提示,而是与 &quot;测试 &quot;分支的提示进行比较。</target>
        </trans-unit>
        <trans-unit id="0e0bb2a4d944b8f5531055e279607820e676a94b" translate="yes" xml:space="preserve">
          <source>Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, &lt;code&gt;^commit&lt;/code&gt;, &lt;code&gt;commit1..commit2&lt;/code&gt;, and &lt;code&gt;commit1...commit2&lt;/code&gt; notations cannot be used).</source>
          <target state="translated">与其遍历提交祖先链，不如将reflog条目从最新的提交到较旧的。使用此选项时，您无法指定要排除的提交（即，不能使用 &lt;code&gt;^commit&lt;/code&gt; ， &lt;code&gt;commit1..commit2&lt;/code&gt; 和 &lt;code&gt;commit1...commit2&lt;/code&gt; 表示法）。</target>
        </trans-unit>
        <trans-unit id="00c411b0a21221afdc6e21c624bf253d7212e3a9" translate="yes" xml:space="preserve">
          <source>Instead of writing the results out to &lt;code&gt;$GIT_INDEX_FILE&lt;/code&gt;, write the resulting index in the named file. While the command is operating, the original index file is locked with the same mechanism as usual. The file must allow to be rename(2)ed into from a temporary file that is created next to the usual index file; typically this means it needs to be on the same filesystem as the index file itself, and you need write permission to the directories the index file and index output file are located in.</source>
          <target state="translated">不要将结果写到 &lt;code&gt;$GIT_INDEX_FILE&lt;/code&gt; ，而是将结果索引写到命名文件中。当命令运行时，原始索引文件使用与通常相同的机制锁定。该文件必须允许从在通常的索引文件旁边创建的临时文件重命名（2）为该文件；通常，这意味着它必须与索引文件本身在同一文件系统上，并且您需要对索引文件和索引输出文件所在的目录具有写许可权。</target>
        </trans-unit>
        <trans-unit id="ef06396aed739ff032fb1ddeda938ad4cf5e4280" translate="yes" xml:space="preserve">
          <source>Instruct Git to avoid trying to guess defaults for &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;user.name&lt;/code&gt;, and instead retrieve the values only from the configuration. For example, if you have multiple email addresses and would like to use a different one for each repository, then with this configuration option set to &lt;code&gt;true&lt;/code&gt; in the global config along with a name, Git will prompt you to set up an email before making new commits in a newly cloned repository. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">指示Git避免尝试猜测 &lt;code&gt;user.email&lt;/code&gt; 和 &lt;code&gt;user.name&lt;/code&gt; 的默认值，而是仅从配置中检索值。例如，如果您有多个电子邮件地址，并且希望为每个存储库使用不同的电子邮件地址，则在全局配置中将此配置选项设置为 &lt;code&gt;true&lt;/code&gt; 并加上名称，Git会提示您在创建新电子邮件之前先设置电子邮件提交到新克隆的存储库中。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a592acd9f11ad3bff77a1878bfa756913e7df3fe" translate="yes" xml:space="preserve">
          <source>Instruction to add new data</source>
          <target state="translated">添加新数据的指令</target>
        </trans-unit>
        <trans-unit id="c222c271406b6a5c2fcfc84ba72b7981aee6b09e" translate="yes" xml:space="preserve">
          <source>Instruction to copy from base object</source>
          <target state="translated">从基础对象复制的指令</target>
        </trans-unit>
        <trans-unit id="6131d2bc98a67fbf2df419d53c2a5951a56eb747" translate="yes" xml:space="preserve">
          <source>Instructs the remote helper that any subsequent input is part of a fast-import stream (generated by &lt;code&gt;git fast-export&lt;/code&gt;) containing objects which should be pushed to the remote.</source>
          <target state="translated">指示远程帮助程序任何后续输入是快速导入流（由 &lt;code&gt;git fast-export&lt;/code&gt; 生成）的一部分，该流包含应推送到远程的对象。</target>
        </trans-unit>
        <trans-unit id="563eacc97631ea8eeadfe6b54ffbd63455326490" translate="yes" xml:space="preserve">
          <source>Integer. Specifies desired depth of nested regions in the event output. Regions deeper than this value will be omitted. May be overridden by the &lt;code&gt;GIT_TRACE2_EVENT_NESTING&lt;/code&gt; environment variable. Defaults to 2.</source>
          <target state="translated">整数。在事件输出中指定所需的嵌套区域深度。比此值更深的区域将被省略。可以被 &lt;code&gt;GIT_TRACE2_EVENT_NESTING&lt;/code&gt; 环境变量覆盖。默认为2</target>
        </trans-unit>
        <trans-unit id="f3e0144605c9578fc597fd7ff39de75aab2afefe" translate="yes" xml:space="preserve">
          <source>Integer. When writing trace files to a target directory, do not write additional traces if we would exceed this many files. Instead, write a sentinel file that will block further tracing to this directory. Defaults to 0, which disables this check.</source>
          <target state="translated">整数。当向目标目录写入跟踪文件时,如果我们会超过这个数量,就不要再写入额外的跟踪文件。相反,写一个哨兵文件,以阻止对该目录的进一步追踪。缺省值为0,禁用该检查。</target>
        </trans-unit>
        <trans-unit id="a6768cae9c51930f13c302375f3385c6c77b2104" translate="yes" xml:space="preserve">
          <source>Integrator</source>
          <target state="translated">Integrator</target>
        </trans-unit>
        <trans-unit id="e30f6e398ba3d7dd3d6ee2f7d0d8940d3116f2a5" translate="yes" xml:space="preserve">
          <source>Interacting with Others</source>
          <target state="translated">与他人互动</target>
        </trans-unit>
        <trans-unit id="e9854d76872b55831675241f09e80f37f1939cea" translate="yes" xml:space="preserve">
          <source>Interaction between checkin/checkout attributes</source>
          <target state="translated">签到/结账属性之间的互动</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">互动模式</target>
        </trans-unit>
        <trans-unit id="fb0ea93fbb85b738df0bd31fcf1bc9eb5468d22b" translate="yes" xml:space="preserve">
          <source>Interactive use</source>
          <target state="translated">互动式使用</target>
        </trans-unit>
        <trans-unit id="94db97a8381d05a800daa18ce0818d37326de61f" translate="yes" xml:space="preserve">
          <source>Interactively choose hunks of patch between the index and the work tree and add them to the index. This gives the user a chance to review the difference before adding modified contents to the index.</source>
          <target state="translated">在索引和工作树之间交互式地选择补丁块,并将其添加到索引中。这让用户有机会在添加修改内容到索引之前查看其差异。</target>
        </trans-unit>
        <trans-unit id="bfdd4f344b8dfb9b5f469d3e0a6945b89367454c" translate="yes" xml:space="preserve">
          <source>Interactively select hunks from the diff between HEAD and the working tree to be stashed. The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942e3b50f8575a931a7b62b4970978b40b59bcee" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (or the index, if unspecified) and the working tree. The chosen hunks are then applied in reverse to the working tree (and if a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; was specified, the index).</source>
          <target state="translated">交互地选择 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; （或索引，如果未指定）和工作树之间的差异中的块。然后，将所选的块块反向应用于工作树（如果指定了 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; ，则为索引）。</target>
        </trans-unit>
        <trans-unit id="6b61a0bfaba36c21326a6cc1d8076250bbb8f781" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the index and &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (defaults to &lt;code&gt;HEAD&lt;/code&gt;). The chosen hunks are applied in reverse to the index.</source>
          <target state="translated">在索引和 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 之间的差异中交互选择块（默认为 &lt;code&gt;HEAD&lt;/code&gt; ）。所选的块被反向应用于索引。</target>
        </trans-unit>
        <trans-unit id="11c4e8d4b31fcec1faa8b21ab916ae6d7ecd6196" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the restore source and the restore location. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">在还原源和还原位置之间的差异中以交互方式选择块。请参阅&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;的&amp;ldquo;交互模式&amp;rdquo;部分，以了解如何操作 &lt;code&gt;--patch&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="37d460e42c18dd6a2f67dd6cfcf736b2dc4e3735" translate="yes" xml:space="preserve">
          <source>Internal detail of implementation. What is important is that if this field is not present then per-repository override for given feature is not supported.</source>
          <target state="translated">实现的内部细节。重要的是,如果这个字段不存在,那么就不支持对给定特性的每个存储库覆盖。</target>
        </trans-unit>
        <trans-unit id="fcd742802f00593c0aa9a5d67d6ee0045ea54dd6" translate="yes" xml:space="preserve">
          <source>Internal helper commands</source>
          <target state="translated">内部辅助命令</target>
        </trans-unit>
        <trans-unit id="99089329f972015329c6ab2c5f20f49ab1b0fb2e" translate="yes" xml:space="preserve">
          <source>Internal variable identifying the repository format and layout version.</source>
          <target state="translated">识别存储库格式和布局版本的内部变量。</target>
        </trans-unit>
        <trans-unit id="d2a9fe262eee692f1042088fcd5412df8b02ed0e" translate="yes" xml:space="preserve">
          <source>Internal variable which enables various workarounds to enable Git to work better on filesystems that are not case sensitive, like APFS, HFS+, FAT, NTFS, etc. For example, if a directory listing finds &quot;makefile&quot; when Git expects &quot;Makefile&quot;, Git will assume it is really the same file, and continue to remember it as &quot;Makefile&quot;.</source>
          <target state="translated">内部变量,可以让 Git 在不区分大小写的文件系统上更好地工作,比如 APFS、HFS+、FAT、NTFS 等。例如,如果目录列表中发现 &quot;makefile&quot;,而Git期望的是 &quot;Makefile&quot;,那么Git会认为这确实是同一个文件,并继续将其记为 &quot;Makefile&quot;。</target>
        </trans-unit>
        <trans-unit id="fd5dd045ecadbef7edb9976d5bf76d5e7548b5a7" translate="yes" xml:space="preserve">
          <source>Interpret &amp;lt;refname&amp;gt; as a reference name pattern for a refspec (as used with remote repositories). If this option is enabled, &amp;lt;refname&amp;gt; is allowed to contain a single &lt;code&gt;*&lt;/code&gt; in the refspec (e.g., &lt;code&gt;foo/bar*/baz&lt;/code&gt; or &lt;code&gt;foo/bar*baz/&lt;/code&gt; but not &lt;code&gt;foo/bar*/baz*&lt;/code&gt;).</source>
          <target state="translated">将&amp;lt;refname&amp;gt;解释为refspec的引用名称模式（与远程存储库一起使用）。如果启用此选项，则&amp;lt;refname&amp;gt;允许在refspec中包含单个 &lt;code&gt;*&lt;/code&gt; （例如 &lt;code&gt;foo/bar*/baz&lt;/code&gt; 或 &lt;code&gt;foo/bar*baz/&lt;/code&gt; 但不包含 &lt;code&gt;foo/bar*/baz*&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="670ef7722a61e3342fef6602c3dc04b50457ccb3" translate="yes" xml:space="preserve">
          <source>Interpret all preceding arguments as attributes and all following arguments as path names.</source>
          <target state="translated">将前面的所有参数解释为属性,将后面的所有参数解释为路径名。</target>
        </trans-unit>
        <trans-unit id="c75cadb4ae816991e0dd6b40f2cda63b6ea63eb7" translate="yes" xml:space="preserve">
          <source>Interrogation commands</source>
          <target state="translated">讯问命令</target>
        </trans-unit>
        <trans-unit id="f1e6fa1e2ddb5fcd808e3092148f74242800360f" translate="yes" xml:space="preserve">
          <source>Interrogators:</source>
          <target state="translated">Interrogators:</target>
        </trans-unit>
        <trans-unit id="8b0b6bf2544da29702a138cd7dd487472490ccff" translate="yes" xml:space="preserve">
          <source>Interrupt transfer after &amp;lt;n&amp;gt; seconds of inactivity.</source>
          <target state="translated">闲置&amp;lt;n&amp;gt;秒后中断传输。</target>
        </trans-unit>
        <trans-unit id="fb3e70f97505597e5558a144342f8608c6471e9a" translate="yes" xml:space="preserve">
          <source>Interruptability</source>
          <target state="translated">Interruptability</target>
        </trans-unit>
        <trans-unit id="9f1df172d790d81927bf10eb32b7a53862fd94a5" translate="yes" xml:space="preserve">
          <source>Interrupted workflow</source>
          <target state="translated">工作流程中断</target>
        </trans-unit>
        <trans-unit id="b566252f7afe805214a7771e6b2a586b4e458c82" translate="yes" xml:space="preserve">
          <source>Introduction to &quot;git bisect&quot;</source>
          <target state="translated">&quot;git bisect &quot;介绍</target>
        </trans-unit>
        <trans-unit id="273a20c96a580af6e0e1fc6c4491680cd6e13de6" translate="yes" xml:space="preserve">
          <source>Intuitiveness is not the goal here. Repeatability is. The reason for the &quot;no arguments means no work&quot; behavior is that from scripts you are supposed to be able to do:</source>
          <target state="translated">直观性不是这里的目标。可重复性才是。之所以有 &quot;没有参数就意味着没有工作 &quot;的行为,是因为从脚本中你应该能够做到。</target>
        </trans-unit>
        <trans-unit id="6a9b44369c96eafd66d755034e5ce80488ad8832" translate="yes" xml:space="preserve">
          <source>Invocation</source>
          <target state="translated">Invocation</target>
        </trans-unit>
        <trans-unit id="1d5f124f7b2f261867ec41e2c056658bb6e88c34" translate="yes" xml:space="preserve">
          <source>Invoke a text editor (see GIT_EDITOR in &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt;) to edit an introductory message for the patch series.</source>
          <target state="translated">调用文本编辑器（请参阅&lt;a href=&quot;git-var&quot;&gt;git-var [1]中的&lt;/a&gt; GIT_EDITOR ）来编辑补丁系列的介绍性消息。</target>
        </trans-unit>
        <trans-unit id="9ba2ef7b89376be98d487b046c212677da3221b4" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged).</source>
          <target state="translated">提交成功的机械合并之前，请调用编辑器以进一步编辑自动生成的合并消息，以便用户可以解释并证明合并的合理性。所述 &lt;code&gt;--no-edit&lt;/code&gt; 选项可用于接受自动生成的消息（这通常泄气）。</target>
        </trans-unit>
        <trans-unit id="a978683542367bbc42f0a41dd9d11a4a00c553d9" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged). The &lt;code&gt;--edit&lt;/code&gt; (or &lt;code&gt;-e&lt;/code&gt;) option is still useful if you are giving a draft message with the &lt;code&gt;-m&lt;/code&gt; option from the command line and want to edit it in the editor.</source>
          <target state="translated">提交成功的机械合并之前，请调用编辑器以进一步编辑自动生成的合并消息，以便用户可以解释并证明合并的合理性。所述 &lt;code&gt;--no-edit&lt;/code&gt; 选项可用于接受自动生成的消息（这通常泄气）。该 &lt;code&gt;--edit&lt;/code&gt; （或 &lt;code&gt;-e&lt;/code&gt; ）选项仍然是有用的，如果你给同一个消息草稿 &lt;code&gt;-m&lt;/code&gt; 命令行选项，并希望在编辑器中编辑它。</target>
        </trans-unit>
        <trans-unit id="ab51558f752b86c08b9c277e1cd35bd4f5da28bc" translate="yes" xml:space="preserve">
          <source>Invoke the sendemail-validate hook if present (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">调用sendemail-validate挂钩（如果存在）（请参阅&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6307458f7efb25e5d4237ad7a4e972e464f2ab54" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git archive --remote&lt;/code&gt; and sends a generated archive to the other end over the Git protocol.</source>
          <target state="translated">由 &lt;code&gt;git archive --remote&lt;/code&gt; 调用，并通过Git协议将生成的存档发送到另一端。</target>
        </trans-unit>
        <trans-unit id="4591feb10dd06f62e310d9c287cf3f981ce9babf" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git fetch-pack&lt;/code&gt;, learns what objects the other side is missing, and sends them after packing.</source>
          <target state="translated">由 &lt;code&gt;git fetch-pack&lt;/code&gt; 调用，了解另一侧缺少哪些对象，并在打包后将其发送。</target>
        </trans-unit>
        <trans-unit id="a7f91dd525c007f2b681e8a032a0618f9a34ea1c" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git send-pack&lt;/code&gt; and updates the repository with the information fed from the remote end.</source>
          <target state="translated">由 &lt;code&gt;git send-pack&lt;/code&gt; 调用，并使用远程端提供的信息更新存储库。</target>
        </trans-unit>
        <trans-unit id="d65563f7b9f547034dceec39b8ac04f9c683c150" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-receive-pack&lt;/code&gt; on a possibly remote repository, and updates it from the current repository, sending named refs.</source>
          <target state="translated">在可能的远程存储库上调用 &lt;code&gt;git-receive-pack&lt;/code&gt; ，并从当前存储库更新它，发送命名的refs。</target>
        </trans-unit>
        <trans-unit id="b53ca0a7337f2511de77389036559a87c502bc3d" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-upload-pack&lt;/code&gt; on a possibly remote repository and asks it to send objects missing from this repository, to update the named heads. The list of commits available locally is found out by scanning the local refs/ hierarchy and sent to &lt;code&gt;git-upload-pack&lt;/code&gt; running on the other end.</source>
          <target state="translated">在可能是远程的存储库上调用 &lt;code&gt;git-upload-pack&lt;/code&gt; ，并要求它发送该存储库中缺少的对象，以更新命名的头部。通过扫描本地引用/层次结构可以找到本地可用的提交列表，并将其发送到另一端运行的 &lt;code&gt;git-upload-pack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a31ffeaabebc608f725ad5aea0019f330d8c2ea7" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;git add -e&lt;/code&gt; or selecting &lt;code&gt;e&lt;/code&gt; from the interactive hunk selector will open a patch in your editor; after the editor exits, the result is applied to the index. You are free to make arbitrary changes to the patch, but note that some changes may have confusing results, or even result in a patch that cannot be applied. If you want to abort the operation entirely (i.e., stage nothing new in the index), simply delete all lines of the patch. The list below describes some common things you may see in a patch, and which editing operations make sense on them.</source>
          <target state="translated">调用 &lt;code&gt;git add -e&lt;/code&gt; 或从交互式块选择器中选择 &lt;code&gt;e&lt;/code&gt; 将在编辑器中打开一个补丁。编辑器退出后，结果将应用于索引。您可以随意对补丁进行任何更改，但是请注意，某些更改可能会导致混乱的结果，甚至导致无法应用的补丁。如果要完全中止该操作（即，暂无索引中的新内容），只需删除补丁的所有行。下面的列表描述了您可能会在补丁中看到的一些常见内容，以及对其进行哪些编辑操作才有意义。</target>
        </trans-unit>
        <trans-unit id="7eda501750cd6c5e49ea1b4fd74542b592feab87" translate="yes" xml:space="preserve">
          <source>Involving QA people and if possible end users</source>
          <target state="translated">让QA人员,如果可能的话,让最终用户参与进来</target>
        </trans-unit>
        <trans-unit id="4ddb9cd693a2e162ef85f6fbfe4abc845111ebb9" translate="yes" xml:space="preserve">
          <source>Is a synonym for &lt;code&gt;zebra&lt;/code&gt;. This may change to a more sensible mode in the future.</source>
          <target state="translated">是 &lt;code&gt;zebra&lt;/code&gt; 的同义词。将来可能会更改为更明智的模式。</target>
        </trans-unit>
        <trans-unit id="4f13daaae3d7fc7ba5d15c4ccfc54188d83d267e" translate="yes" xml:space="preserve">
          <source>Is used as suggested name when creating new branches using the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;.</source>
          <target state="translated">在使用&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt;创建新分支时用作建议名称。</target>
        </trans-unit>
        <trans-unit id="6f3229278b909458bc76fcc500cf44677191a296" translate="yes" xml:space="preserve">
          <source>Islands are configured via the &lt;code&gt;pack.island&lt;/code&gt; option, which can be specified multiple times. Each value is a left-anchored regular expressions matching refnames. For example:</source>
          <target state="translated">通过 &lt;code&gt;pack.island&lt;/code&gt; 选项可以配置孤岛，可以多次指定。每个值都是与引用名称匹配的左锚正则表达式。例如：</target>
        </trans-unit>
        <trans-unit id="30ce4cb25faae86427d8ac22e8f50a0a74f3f393" translate="yes" xml:space="preserve">
          <source>Issues</source>
          <target state="translated">Issues</target>
        </trans-unit>
        <trans-unit id="0120e142d77ed0c1102a3548e5e6ca12ae1c469b" translate="yes" xml:space="preserve">
          <source>Issues which are security relevant should be disclosed privately to the Git Security mailing list &amp;lt;&lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">与安全相关的问题应在Git Security邮件列表&amp;lt; &lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt; &amp;gt;中私下披露。</target>
        </trans-unit>
        <trans-unit id="7e6ca0d89968d14a4a145a03ebcf512ab164b2cf" translate="yes" xml:space="preserve">
          <source>Issuing a &lt;code&gt;filedeleteall&lt;/code&gt; followed by the needed &lt;code&gt;filemodify&lt;/code&gt; commands to set the correct content will produce the same results as sending only the needed &lt;code&gt;filemodify&lt;/code&gt; and &lt;code&gt;filedelete&lt;/code&gt; commands. The &lt;code&gt;filedeleteall&lt;/code&gt; approach may however require fast-import to use slightly more memory per active branch (less than 1 MiB for even most large projects); so frontends that can easily obtain only the affected paths for a commit are encouraged to do so.</source>
          <target state="translated">发出 &lt;code&gt;filedeleteall&lt;/code&gt; ,后跟所需的 &lt;code&gt;filemodify&lt;/code&gt; 命令以设置正确的内容，将产生与仅发送所需的 &lt;code&gt;filemodify&lt;/code&gt; 和 &lt;code&gt;filedelete&lt;/code&gt; 命令相同的结果。但是， &lt;code&gt;filedeleteall&lt;/code&gt; 方法可能需要快速导入，以在每个活动分支中使用更多的内存（对于大多数大型项目，其内存不足1 MiB）。因此，鼓励那些可以轻松仅获取受影响路径的提交的前端这样做。</target>
        </trans-unit>
        <trans-unit id="bdf45bc4332be1bec5eceb55b9547e5441cbefc8" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s clone path to the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file and adds this file to the index, ready to be committed.</source>
          <target state="translated">它将子模块的克隆路径添加到&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;文件，并将此文件添加到索引，准备提交。</target>
        </trans-unit>
        <trans-unit id="8c81521fe76c33a9e0c12152a7126a3168cdc6bc" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s current commit ID to the index, ready to be committed.</source>
          <target state="translated">它将子模块的当前提交ID添加到索引中，准备提交。</target>
        </trans-unit>
        <trans-unit id="d31bfc2387ea73611500553c1004cb0667d4f160" translate="yes" xml:space="preserve">
          <source>It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number &lt;code&gt;m&lt;/code&gt; controls this aspect of the -B option (defaults to 60%). &lt;code&gt;-B/70%&lt;/code&gt; specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).</source>
          <target state="translated">它影响的是更改方式，即完全重写文件，而不是将一系列删除和插入与很少几行恰好在文本上作为上下文相匹配的行混合在一起，而是将所有旧内容都删除后再加上一个一次插入所有新内容，数字 &lt;code&gt;m&lt;/code&gt; 控制-B选项的这一方面（默认为60％）。 &lt;code&gt;-B/70%&lt;/code&gt; 指定结果中应保留少于原始值的30％，以便Git认为它是完全重写的（即，否则，所得的补丁将是一系列删除和插入以及上下文行混合在一起）。</target>
        </trans-unit>
        <trans-unit id="3769038328418f1b146bfedf460a0d4ea1eab91b" translate="yes" xml:space="preserve">
          <source>It also allows a &quot;ref&quot; file to be a symbolic pointer to another ref file by starting with the four-byte header sequence of &quot;ref:&quot;.</source>
          <target state="translated">它还允许一个 &quot;ref &quot;文件以 &quot;ref:&quot;四个字节的头序列开始,成为另一个ref文件的符号指针。</target>
        </trans-unit>
        <trans-unit id="c1a8e562ae70e23b9286b736cb60f8fd411f796d" translate="yes" xml:space="preserve">
          <source>It can also be useful in scripts passed to &quot;git bisect run&quot; to &quot;exit 255&quot; if some very abnormal situation is detected.</source>
          <target state="translated">在传递给 &quot;git bisect run &quot;的脚本中,如果检测到一些非常不正常的情况,&quot;exit 255 &quot;也会很有用。</target>
        </trans-unit>
        <trans-unit id="79b5b9aab5919bae0a6145dab082f1d19cd80f67" translate="yes" xml:space="preserve">
          <source>It can be cumbersome to input the same credentials over and over. Git provides two methods to reduce this annoyance:</source>
          <target state="translated">一遍遍地输入相同的凭证会很麻烦。Git 提供了两种方法来减少这种烦恼。</target>
        </trans-unit>
        <trans-unit id="4e1aaed29365e5e25e94340f3a0f563a3458fb95" translate="yes" xml:space="preserve">
          <source>It can be used to inspect the current working tree and refuse to make a commit if it does not pass certain test.</source>
          <target state="translated">它可以用来检查当前的工作树,如果它没有通过某些测试,则拒绝提交。</target>
        </trans-unit>
        <trans-unit id="15367977bf1bc97e62677f2311accebdf50497b6" translate="yes" xml:space="preserve">
          <source>It can efficiently represent information about merge conflicts between different tree objects, allowing each pathname to be associated with sufficient information about the trees involved that you can create a three-way merge between them.</source>
          <target state="translated">它可以有效地表示不同树对象之间的合并冲突信息,允许每个路径名与所涉及的树的足够信息相关联,你可以在它们之间创建一个三向合并。</target>
        </trans-unit>
        <trans-unit id="61f59429096395b0e09a9585119ef97dbe0f3099" translate="yes" xml:space="preserve">
          <source>It cannot show more than 29 branches and commits at a time.</source>
          <target state="translated">它不能同时显示超过29个分支和提交。</target>
        </trans-unit>
        <trans-unit id="84908290c2ad8351819557b635db90afccbc35f1" translate="yes" xml:space="preserve">
          <source>It clones the submodule from &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; to the given &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; under the current directory and by default checks out the master branch.</source>
          <target state="translated">它将子模块从 &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; 克隆到当前目录下的给定 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; ，并且默认情况下检出master分支。</target>
        </trans-unit>
        <trans-unit id="d2f2a22f8382dea93b62981d5e21e0c74a8c6b46" translate="yes" xml:space="preserve">
          <source>It could also be used to log the old..new status. However, it does not know the entire set of branches, so it would end up firing one e-mail per ref when used naively, though. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook is more suited to that.</source>
          <target state="translated">它也可以用来记录old..new状态。但是，它不知道整个分支机构，因此，如果天真地使用它，最终将为每个引用触发一封电子邮件。该&lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;-收到后&lt;/em&gt;&lt;/a&gt;钩更适合一点。</target>
        </trans-unit>
        <trans-unit id="784deb932c786d53caa1d9cefe7cd05964d957b0" translate="yes" xml:space="preserve">
          <source>It defaults to &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt;, which colors everything older than one year blue, recent changes between one month and one year old are kept white, and lines introduced within the last month are colored red.</source>
          <target state="translated">它默认为 &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt; ，该颜色将所有超过一年的颜色都涂成蓝色，一个月到一岁之间的最近更改保持白色，而上个月引入的线条被涂成红色。</target>
        </trans-unit>
        <trans-unit id="91de163844ee67c93c1b1c843cc5bef0832c9f25" translate="yes" xml:space="preserve">
          <source>It does its best to do the safe thing, it will check that the files are unchanged and up to date in the CVS checkout, and it will not autocommit by default.</source>
          <target state="translated">它尽量做到安全,它会在CVS的签出中检查文件是否没有变化,是否是最新的,它默认不会自动提交。</target>
        </trans-unit>
        <trans-unit id="92564150ed02a0207f639f4b1e8f897270e7157d" translate="yes" xml:space="preserve">
          <source>It does this by storing some additional data for each entry (such as the last modified time). This data is not displayed above, and is not stored in the created tree object, but it can be used to determine quickly which files in the working directory differ from what was stored in the index, and thus save Git from having to read all of the data from such files to look for changes.</source>
          <target state="translated">它通过为每个条目存储一些额外的数据(比如最后一次修改时间)来实现。这些数据不会显示在上面,也不会存储在创建的树对象中,但它可以用来快速确定工作目录中的哪些文件与索引中存储的不同,从而节省Git从这些文件中读取所有数据来查找修改。</target>
        </trans-unit>
        <trans-unit id="af8ba1869bb0a79ae9cea38b1af5617b9069dca1" translate="yes" xml:space="preserve">
          <source>It enables git to work together with a file system monitor (see the &quot;fsmonitor-watchman&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;) that can inform it as to what files have been modified. This enables git to avoid having to lstat() every file to find modified files.</source>
          <target state="translated">它使git可以与文件系统监视器（请参阅&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;的&amp;ldquo; fsmonitor-watchman&amp;rdquo;部分）一起使用，可以通知它已修改了哪些文件。这使git避免必须对每个文件进行lstat（）查找修改后的文件。</target>
        </trans-unit>
        <trans-unit id="af9f31199487ba705eebc5dd4bc13449d71955c8" translate="yes" xml:space="preserve">
          <source>It expects to be dealing with one project only. If it sees branches that have different roots, it will refuse to run. In that case, edit your &amp;lt;archive/branch&amp;gt; parameters to define clearly the scope of the import.</source>
          <target state="translated">它期望只处理一个项目。如果发现分支具有不同的根，它将拒绝运行。在这种情况下，请编辑您的&amp;lt;archive / branch&amp;gt;参数以明确定义导入范围。</target>
        </trans-unit>
        <trans-unit id="d015f51d5305572fa694969daaad327b702a39d6" translate="yes" xml:space="preserve">
          <source>It helps to divide these functions into groups for discussion purposes.</source>
          <target state="translated">为了讨论的目的,将这些功能分成几组是有帮助的。</target>
        </trans-unit>
        <trans-unit id="cf8815ec8cef4d3d8f9a8adf49f25148a4887929" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;unix
timestamp&amp;gt;&lt;/code&gt; is the number of seconds since the UNIX epoch. &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is &lt;code&gt;+0100&lt;/code&gt;.</source>
          <target state="translated">它是 &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;&amp;lt;unix timestamp&amp;gt;&lt;/code&gt; 是自UNIX时代以来的秒数。 &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; 是相对于UTC的正或负偏移。例如，CET（比UTC提前1小时）为 &lt;code&gt;+0100&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f4ae55d14bc9f41dc555ac55a4684de8bea2c17" translate="yes" xml:space="preserve">
          <source>It is OK to include files which have not actually changed. All changes including newly-created and deleted files should be included. When files are renamed, both the old and the new name should be included.</source>
          <target state="translated">可以包括没有实际改变的文件。所有的变化,包括新创建和删除的文件都应该包括在内。当文件被重新命名时,应包括新旧名称。</target>
        </trans-unit>
        <trans-unit id="854a36265382bec82daa5a74f777ff212834a549" translate="yes" xml:space="preserve">
          <source>It is a good idea to introduce yourself to Git with your name and public email address before doing any operation. The easiest way to do so is:</source>
          <target state="translated">在进行任何操作之前,最好先向Git介绍自己的名字和公共邮箱地址。最简单的方法是</target>
        </trans-unit>
        <trans-unit id="0dc733d75bf5327e08cfc3134be1a3042cbb2515" translate="yes" xml:space="preserve">
          <source>It is a rough equivalent for:</source>
          <target state="translated">它大致相当于:</target>
        </trans-unit>
        <trans-unit id="95c229774b9b51315840e554d56265719cd8be5c" translate="yes" xml:space="preserve">
          <source>It is also a good idea when using any VCS to have only one small logical change in each commit.</source>
          <target state="translated">在使用任何VCS时,每次提交时只做一个小的逻辑修改也是一个好主意。</target>
        </trans-unit>
        <trans-unit id="6c5a3acbba80472c3128c6339cb1639b4bd8a27a" translate="yes" xml:space="preserve">
          <source>It is also permitted for a notes ref to point directly to a tree object, in which case the history of the notes can be read with &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">还允许注释ref直接指向树对象，在这种情况下，可以使用 &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt; 读取注释的历史记录。</target>
        </trans-unit>
        <trans-unit id="b16dc4f2558875d3f67cc118d8aee343695acae5" translate="yes" xml:space="preserve">
          <source>It is also possible to fetch a subset of branches or tags by using a comma-separated list of names within braces. For example:</source>
          <target state="translated">也可以通过在括号内使用逗号分隔的名称列表来获取分支或标签的子集。例如:</target>
        </trans-unit>
        <trans-unit id="12b7523072e662c296ea1a80ba59ec7ed5fcb7e4" translate="yes" xml:space="preserve">
          <source>It is also possible to introduce completely new merge commits from scratch by adding a command of the form &lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt;. This form will generate a tentative commit message and always open an editor to let the user edit it. This can be useful e.g. when a topic branch turns out to address more than a single concern and wants to be split into two or even more topic branches. Consider this todo list:</source>
          <target state="translated">通过添加 &lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt; 形式的命令，也可以从头开始引入全新的合并提交。此表单将生成一个临时提交消息，并始终打开编辑器让用户对其进行编辑。这可能很有用，例如，当一个主题分支最终解决的不仅仅是单个关注点，并且想要被拆分为两个或更多主题分支时。考虑以下待办事项清单：</target>
        </trans-unit>
        <trans-unit id="e8d4e8a65d3b558ba4900bdd06798676f68d11ad" translate="yes" xml:space="preserve">
          <source>It is also possible to provide true CVS access to a Git repository, so that developers can still use CVS; see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details.</source>
          <target state="translated">还可以提供对Git存储库的真正CVS访问，以便开发人员仍可以使用CVS。有关详细信息，请参见&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3fcb2e34d6c27144258c45911fcc9298afaeeefa" translate="yes" xml:space="preserve">
          <source>It is also possible to replace commits further back in the history, but this is an advanced topic to be left for &lt;a href=&quot;#cleaning-up-history&quot;&gt;another chapter&lt;/a&gt;.</source>
          <target state="translated">也可以在历史上更远的地方替换提交，但这是高级话题，需要&lt;a href=&quot;#cleaning-up-history&quot;&gt;再上一章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14665d6ab0c5fa19cd26aec534fecd5dda3c4692" translate="yes" xml:space="preserve">
          <source>It is also run after &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;, unless the &lt;code&gt;--no-checkout&lt;/code&gt; (&lt;code&gt;-n&lt;/code&gt;) option is used. The first parameter given to the hook is the null-ref, the second the ref of the new HEAD and the flag is always 1. Likewise for &lt;code&gt;git worktree add&lt;/code&gt; unless &lt;code&gt;--no-checkout&lt;/code&gt; is used.</source>
          <target state="translated">它也会在&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;之后运行，除非使用 &lt;code&gt;--no-checkout&lt;/code&gt; （ &lt;code&gt;-n&lt;/code&gt; ）选项。赋予钩子的第一个参数是null-ref，第二个参数是新HEAD的ref，并且标记始终为1。同样，对于 &lt;code&gt;git worktree add&lt;/code&gt; ,除非使用 &lt;code&gt;--no-checkout&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bf0b4701dd5a8615d5c5a4270f19ec18f43aa49" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;dst&amp;gt; matches more than one remote refs.</source>
          <target state="translated">如果&amp;lt;dst&amp;gt;匹配多个远程引用，则错误。</target>
        </trans-unit>
        <trans-unit id="47ed8fd8a6ccf512f8dd41b7de1bb50b3d494692" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;src&amp;gt; does not match exactly one of the local refs.</source>
          <target state="translated">如果&amp;lt;src&amp;gt;与本地引用之一不完全匹配，则会出现错误。</target>
        </trans-unit>
        <trans-unit id="08551e573ca80a9130c1ec33d2456a204ee6a838" translate="yes" xml:space="preserve">
          <source>It is an error to specify a ref that does not pass &quot;git check-ref-format&quot; scrutiny. Duplicated values are filtered.</source>
          <target state="translated">指定一个没有通过 &quot;git check-ref-format &quot;检查的 ref 是一个错误。重复的值会被过滤掉。</target>
        </trans-unit>
        <trans-unit id="91dc5c05cc945b2e35d03a4d25f4568585356b02" translate="yes" xml:space="preserve">
          <source>It is assumed that any handshaking procedures have already been completed (such as sending service request for git://) before this helper is started.</source>
          <target state="translated">假设在启动这个帮助程序之前,所有的握手程序都已经完成了(比如为git://发送服务请求)。</target>
        </trans-unit>
        <trans-unit id="7a3002fc7973dbc26474a90f4bdcb162301b4e67" translate="yes" xml:space="preserve">
          <source>It is currently only possible to recreate the merge commits using the &lt;code&gt;recursive&lt;/code&gt; merge strategy; Different merge strategies can be used only via explicit &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; commands.</source>
          <target state="translated">当前只能使用 &lt;code&gt;recursive&lt;/code&gt; 合并策略来重新创建合并提交。只能通过显式 &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; 命令使用不同的合并策略。</target>
        </trans-unit>
        <trans-unit id="bd70cf0a22a7ad38ee60197dd400f891cf0d57a3" translate="yes" xml:space="preserve">
          <source>It is expected that the content of the commit object you created while following the example above generates a different SHA-1 hash than the one shown above because the commit object records the time when it was created and the name of the person performing the commit.</source>
          <target state="translated">预计您在按照上面的例子创建的提交对象的内容会产生与上面所示不同的SHA-1哈希值,因为提交对象记录了创建的时间和执行提交的人的名字。</target>
        </trans-unit>
        <trans-unit id="f78a88555b80a7cb6f279e6cf8551b4ade125a2a" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines (this example shows a merge with two parents):</source>
          <target state="translated">它的后面是一个或多个扩展的标题行(这个例子显示的是两个父行的合并)。</target>
        </trans-unit>
        <trans-unit id="4d181ca929d0bcae1d19e843f3c648e99a609d36" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines:</source>
          <target state="translated">它的后面是一个或多个扩展的标题行。</target>
        </trans-unit>
        <trans-unit id="a6770fb3a63d614ebdc42bea002a81ec83ae2568" translate="yes" xml:space="preserve">
          <source>It is followed by two-line from-file/to-file header</source>
          <target state="translated">后面是两行从文件到文件的标题</target>
        </trans-unit>
        <trans-unit id="31bbdf9a81fa3062a8106d3f0d5511057b4a5222" translate="yes" xml:space="preserve">
          <source>It is highly functional. However, not all methods are implemented, and for those methods that are implemented, not all switches are implemented.</source>
          <target state="translated">它的功能很强。但是,并不是所有的方法都能实现,对于那些实现了的方法,也不是所有的开关都能实现。</target>
        </trans-unit>
        <trans-unit id="13209c7d424e2b65e2d35ccb5123d7d58e26c1e7" translate="yes" xml:space="preserve">
          <source>It is important to realize that at this point nothing refers to commit &lt;code&gt;f&lt;/code&gt;. Eventually commit &lt;code&gt;f&lt;/code&gt; (and by extension commit &lt;code&gt;e&lt;/code&gt;) will be deleted by the routine Git garbage collection process, unless we create a reference before that happens. If we have not yet moved away from commit &lt;code&gt;f&lt;/code&gt;, any of these will create a reference to it:</source>
          <target state="translated">重要的是要意识到，在这一点上，没有什么涉及提交 &lt;code&gt;f&lt;/code&gt; 。最终，提交 &lt;code&gt;f&lt;/code&gt; （以及扩展名为commit &lt;code&gt;e&lt;/code&gt; ）将被例程Git垃圾回收过程删除，除非我们在此之前创建了引用。如果我们还没有离开commit &lt;code&gt;f&lt;/code&gt; ，那么任何一个都会创建对它的引用：</target>
        </trans-unit>
        <trans-unit id="15e77b99d56294dd4d998fab1260c89fc2b1f677" translate="yes" xml:space="preserve">
          <source>It is likely that you will be pulling from the same remote repository from time to time. As a short hand, you can store the remote repository URL in the local repository&amp;rsquo;s config file like this:</source>
          <target state="translated">您可能会不时从同一远程存储库中提取信息。简而言之，您可以将远程存储库URL存储在本地存储库的配置文件中，如下所示：</target>
        </trans-unit>
        <trans-unit id="e468ce82ca7a37df3e0ccb7eddd0ee514020b622" translate="yes" xml:space="preserve">
          <source>It is likely that you will be working on more than one thing at a time. It is easy to manage those more-or-less independent tasks using branches with Git.</source>
          <target state="translated">你很可能同时在做一件以上的事情。使用 Git 的分支可以轻松管理这些或多或少独立的任务。</target>
        </trans-unit>
        <trans-unit id="cdfac588afc71ee687618e7ec3bc2f824e200606" translate="yes" xml:space="preserve">
          <source>It is not always easy for new developers to find their way through Git&amp;rsquo;s source code. This section gives you a little guidance to show where to start.</source>
          <target state="translated">对于新开发人员而言，通过Git的源代码找到自己的路并不总是那么容易。本节为您提供一些指导，以显示从哪里开始。</target>
        </trans-unit>
        <trans-unit id="deded1cb8baf6033568ee8de4cb9cb55818cb450" translate="yes" xml:space="preserve">
          <source>It is not recommended to use this feature if you intend to export changes back to CVS again later with &lt;code&gt;git cvsexportcommit&lt;/code&gt;.</source>
          <target state="translated">如果您打算稍后使用 &lt;code&gt;git cvsexportcommit&lt;/code&gt; 再次将更改导出回CVS，则不建议使用此功能。</target>
        </trans-unit>
        <trans-unit id="598d612724092a05c80fc92ca656e4e685e7e227" translate="yes" xml:space="preserve">
          <source>It is obviously a good idea not to have commits with changes that knowingly break things, even if some other commits later fix the breakage.</source>
          <target state="translated">很明显,不要让提交者在明知故犯的情况下进行修改,即使后来有其他提交者修复了错误,这也是一个好主意。</target>
        </trans-unit>
        <trans-unit id="8402ec5252190f6132c0772d2b1eafbec27785df" translate="yes" xml:space="preserve">
          <source>It is possible that a merge failure will prevent this process from being completely automatic. You will have to resolve any such merge failure and run &lt;code&gt;git rebase --continue&lt;/code&gt;. Another option is to bypass the commit that caused the merge failure with &lt;code&gt;git rebase --skip&lt;/code&gt;. To check out the original &amp;lt;branch&amp;gt; and remove the .git/rebase-apply working files, use the command &lt;code&gt;git rebase --abort&lt;/code&gt; instead.</source>
          <target state="translated">合并失败可能会阻止此过程完全自动化。您将必须解决任何此类合并失败并运行 &lt;code&gt;git rebase --continue&lt;/code&gt; 。另一个选择是使用 &lt;code&gt;git rebase --skip&lt;/code&gt; 绕过导致合并失败的提交。要检出原始的&amp;lt;branch&amp;gt;并删除.git / rebase-apply工作文件，请改用 &lt;code&gt;git rebase --abort&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="2ea7f2913c3e95cfd4ae5ff1f6d8aecb190ef204" translate="yes" xml:space="preserve">
          <source>It is possible to construct these old form repositories manually.</source>
          <target state="translated">可以手动构建这些旧的表格库。</target>
        </trans-unit>
        <trans-unit id="548453998a9c855739e7eb9ec21e0581e0ed374b" translate="yes" xml:space="preserve">
          <source>It is possible to disable use of replacement references for any command using the &lt;code&gt;--no-replace-objects&lt;/code&gt; option just after &lt;code&gt;git&lt;/code&gt;.</source>
          <target state="translated">可以在 &lt;code&gt;git&lt;/code&gt; 之后使用 &lt;code&gt;--no-replace-objects&lt;/code&gt; 选项禁用任何命令的替换引用。</target>
        </trans-unit>
        <trans-unit id="c06956dd566d0990dc7bdbc85eb39fd34edd8452" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header that looks like this:</source>
          <target state="translated">它的前面有一个 &quot;git diff &quot;头,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="fae83443f259566d0e3ea169c2bee02ad7796585" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header, that looks like this (when the &lt;code&gt;-c&lt;/code&gt; option is used):</source>
          <target state="translated">它前面带有&amp;ldquo; git diff&amp;rdquo;标头，如下所示（使用 &lt;code&gt;-c&lt;/code&gt; 选项时）：</target>
        </trans-unit>
        <trans-unit id="41c2e2ee7c9260a90ac9d47c12dc86595dc670c7" translate="yes" xml:space="preserve">
          <source>It is purely performance optimization, originally intended for MacOS X, where recursive directory traversal is slow. Gitweb follows symbolic links, but it detects cycles, ignoring any duplicate files and directories.</source>
          <target state="translated">这是纯粹的性能优化,最初是为MacOS X设计的,因为在MacOS X中,递归目录遍历很慢。Gitweb遵循符号链接,但它会检测循环,忽略任何重复的文件和目录。</target>
        </trans-unit>
        <trans-unit id="bcd29e9bb49344b0e527480d5a1209557826cefc" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; always be encoded using UTF-8.</source>
          <target state="translated">建议始终使用UTF-8 对 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 进行编码。</target>
        </trans-unit>
        <trans-unit id="987c2f12e083069e2c3c6529da1c2b8427b5d901" translate="yes" xml:space="preserve">
          <source>It is safer if both &lt;code&gt;test.sh&lt;/code&gt; and &lt;code&gt;check_test_case.sh&lt;/code&gt; are outside the repository to prevent interactions between the bisect, make and test processes and the scripts.</source>
          <target state="translated">如果 &lt;code&gt;test.sh&lt;/code&gt; 和 &lt;code&gt;check_test_case.sh&lt;/code&gt; 都在存储库之外，则更安全，以防止bisect，make和test进程与脚本之间的交互。</target>
        </trans-unit>
        <trans-unit id="07dbd897b2b790cda3e0cd6c93a27be05c0967a5" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to be able to checkout a commit that is not at the tip of any named branch, or even to create a new commit that is not referenced by a named branch. Let&amp;rsquo;s look at what happens when we checkout commit &lt;code&gt;b&lt;/code&gt; (here we show two ways this may be done):</source>
          <target state="translated">有时能够检出不在任何命名分支的尖端的提交，或者甚至创建未被命名分支引用的新提交，这很有用。让我们看一下在检出commit &lt;code&gt;b&lt;/code&gt; 时会发生什么（这里显示了两种方法可以完成）：</target>
        </trans-unit>
        <trans-unit id="19dd47dcbbf16a9cccaac6e901efe1eb6d41c6b4" translate="yes" xml:space="preserve">
          <source>It is still your responsibility to make sure that the email message sent by your email program meets the standards of your project. Many projects do not like patches to be attached. Some mail agents will transform patches (e.g. wrap lines, send them as format=flowed) in ways that make them fail. You will get angry flames ridiculing you if you don&amp;rsquo;t check this.</source>
          <target state="translated">确保您的电子邮件程序发送的电子邮件符合项目标准仍然是您的责任。许多项目不喜欢附加补丁。一些邮件代理将转换补丁程序（例如换行，以format = flowed格式发送），使补丁程序失败。如果不检查，您会生气的火焰嘲笑您。</target>
        </trans-unit>
        <trans-unit id="446989de9f552ff7a375d76851b391396cb21747" translate="yes" xml:space="preserve">
          <source>It is unlikely that you would have any conflicts here &amp;hellip;​ but you might if you spent a while on this step and had also pulled new versions from upstream.</source>
          <target state="translated">您不太可能在这里发生任何冲突...但是如果您花了一些时间在此步骤上并且还从上游拉出了新版本，则可能会发生冲突。</target>
        </trans-unit>
        <trans-unit id="5d35217f8f6c81e1e684634a0bdd90859d19f06a" translate="yes" xml:space="preserve">
          <source>It is up to the user to ensure that no In-Reply-To header already exists when &lt;code&gt;git send-email&lt;/code&gt; is asked to add it (especially note that &lt;code&gt;git format-patch&lt;/code&gt; can be configured to do the threading itself). Failure to do so may not produce the expected result in the recipient&amp;rsquo;s MUA.</source>
          <target state="translated">当要求 &lt;code&gt;git send-email&lt;/code&gt; 添加标题时，要由用户确保不存在In-Reply-To标头（尤其要注意，可以将 &lt;code&gt;git format-patch&lt;/code&gt; 配置为执行线程本身）。否则可能不会在收件人的MUA中产生预期的结果。</target>
        </trans-unit>
        <trans-unit id="28ab82f4261b972bffcbd084fca6120764f529fe" translate="yes" xml:space="preserve">
          <source>It is useful when you&amp;rsquo;re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into &lt;code&gt;-S&lt;/code&gt;, and keep going until you get the very first version of the block.</source>
          <target state="translated">当您正在寻找确切的代码块（例如结构），并且想知道该块自首次出现以来的历史记录时，它很有用：迭代使用该功能将原图像中的有趣块反馈到 &lt;code&gt;-S&lt;/code&gt; ，继续进行直到获得该块的第一个版本。</target>
        </trans-unit>
        <trans-unit id="212ba732375c1f9e18ce6b37fe943bc0a79e8a67" translate="yes" xml:space="preserve">
          <source>It is very important that the basis used be held by the destination. It is okay to err on the side of caution, causing the bundle file to contain objects already in the destination, as these are ignored when unpacking at the destination.</source>
          <target state="translated">使用的基础由目的地持有是非常重要的。谨慎起见,使捆绑文件包含已经在目的地的对象是可以的,因为这些对象在目的地解包时被忽略。</target>
        </trans-unit>
        <trans-unit id="f89d35d0ac276c4d31876791b9f069b985ca50ec" translate="yes" xml:space="preserve">
          <source>It may well be that among networking people, they may want to exchange the tags internal to their group, but in that workflow they are most likely tracking each other&amp;rsquo;s progress by having remote-tracking branches. Again, the heuristic to automatically follow such tags is a good thing.</source>
          <target state="translated">可能是在联网人员中，他们可能希望交换小组内部的标签，但是在该工作流程中，他们很可能会通过拥有远程跟踪分支机构来互相跟踪彼此的进度。同样，自动跟踪此类标签的启发式方法也是一件好事。</target>
        </trans-unit>
        <trans-unit id="b30dde80280e412c885fe09e1718d04b65bebbd4" translate="yes" xml:space="preserve">
          <source>It must be readable in order, from beginning to end, by someone intelligent with a basic grasp of the UNIX command line, but without any special knowledge of Git. If necessary, any other prerequisites should be specifically mentioned as they arise.</source>
          <target state="translated">它必须能让一个基本掌握 UNIX 命令行的聪明人从头到尾按顺序读懂,但不需要任何特殊的 Git 知识。如有必要,应在出现任何其他先决条件时具体说明。</target>
        </trans-unit>
        <trans-unit id="105999ab02cc181d3d21d02fda72679e92aee0b2" translate="yes" xml:space="preserve">
          <source>It should be stressed that this hierarchy is purely &lt;strong&gt;informal&lt;/strong&gt;. There is nothing fundamental in Git that enforces the &quot;chain of patch flow&quot; this hierarchy implies. You do not have to pull from only one remote repository.</source>
          <target state="translated">应该强调的是，这种等级制度纯粹是&lt;strong&gt;非正式的&lt;/strong&gt;。在Git中，没有什么根本可以执行此层次结构所暗示的&amp;ldquo;补丁流链&amp;rdquo;。您不必仅从一个远程存储库中提取。</target>
        </trans-unit>
        <trans-unit id="7beffad8901e95a09a82e88d22525a3cad3065d8" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add--interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593ae3fc1288babccd02a202f40d492d26634f5a" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add{litdd}interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="translated">它表明foo.png与HEAD有区别（但是是二进制的，因此行数无法显示），索引副本和工作树版本之间也没有区别（如果工作树版本也不同，则将显示 &lt;code&gt;binary&lt;/code&gt; 代替 &lt;code&gt;nothing&lt;/code&gt; ）。另一个文件git-add {litdd} interactive.perl，如果您提交索引中的内容，则添加403行，并删除35行，但是工作树文件有进一步的修改（一个添加和一个删除）。</target>
        </trans-unit>
        <trans-unit id="1f22531fd9489cd1b4496c81c3454037c20af1a5" translate="yes" xml:space="preserve">
          <source>It takes a variable number of parameters, each of which is the name of ref that was actually updated.</source>
          <target state="translated">它需要一个数量不等的参数,每个参数都是实际更新的 ref 的名称。</target>
        </trans-unit>
        <trans-unit id="8d1640303505dff202eb78d383641a82298beff2" translate="yes" xml:space="preserve">
          <source>It takes on the standard input the specification of the options to parse and understand, and echoes on the standard output a string suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt; to replace the arguments with normalized ones. In case of error, it outputs usage on the standard error stream, and exits with code 129.</source>
          <target state="translated">它采用标准输入来解析和理解选项的规范，并在标准输出上回显适合 &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; 的字符串，以用规范化参数替换参数。如果发生错误，它将在标准错误流上输出使用情况，并以代码129退出。</target>
        </trans-unit>
        <trans-unit id="9fc9d0adb73a5f351f66393e06f90ebbcd611062" translate="yes" xml:space="preserve">
          <source>It takes one to three parameters. The first is the name of the file that contains the commit log message. The second is the source of the commit message, and can be: &lt;code&gt;message&lt;/code&gt; (if a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option was given); &lt;code&gt;template&lt;/code&gt; (if a &lt;code&gt;-t&lt;/code&gt; option was given or the configuration option &lt;code&gt;commit.template&lt;/code&gt; is set); &lt;code&gt;merge&lt;/code&gt; (if the commit is a merge or a &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; file exists); &lt;code&gt;squash&lt;/code&gt; (if a &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; file exists); or &lt;code&gt;commit&lt;/code&gt;, followed by a commit SHA-1 (if a &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt; or &lt;code&gt;--amend&lt;/code&gt; option was given).</source>
          <target state="translated">它需要一到三个参数。第一个是包含提交日志消息的文件的名称。第二个是提交消息的来源，可以是： &lt;code&gt;message&lt;/code&gt; （如果给出了 &lt;code&gt;-m&lt;/code&gt; 或 &lt;code&gt;-F&lt;/code&gt; 选项）； &lt;code&gt;template&lt;/code&gt; （如果提供了 &lt;code&gt;-t&lt;/code&gt; 选项或设置了配置选项 &lt;code&gt;commit.template&lt;/code&gt; ）； &lt;code&gt;merge&lt;/code&gt; （如果提交是合并或存在 &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; 文件）； &lt;code&gt;squash&lt;/code&gt; （如果存在 &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; 文件）; 或 &lt;code&gt;commit&lt;/code&gt; ，然后是SHA-1提交（如果是 &lt;code&gt;-c&lt;/code&gt; ， &lt;code&gt;-C&lt;/code&gt; 或 &lt;code&gt;--amend&lt;/code&gt; 选项）。</target>
        </trans-unit>
        <trans-unit id="ee62cbb1781a10ccff3a10f01577042e41951364" translate="yes" xml:space="preserve">
          <source>It tells you that it did an &quot;Automatic merge&quot;, which failed due to conflicts in &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">它告诉您它执行了&amp;ldquo;自动合并&amp;rdquo;，由于 &lt;code&gt;hello&lt;/code&gt; 中的冲突而失败。</target>
        </trans-unit>
        <trans-unit id="31dbee78e4c488ce29554dd490d874937eb736b5" translate="yes" xml:space="preserve">
          <source>It used to be that the command defaulted to do &lt;code&gt;-x&lt;/code&gt; described above, and &lt;code&gt;-r&lt;/code&gt; was to disable it. Now the default is not to do &lt;code&gt;-x&lt;/code&gt; so this option is a no-op.</source>
          <target state="translated">过去，该命令默认执行上述的 &lt;code&gt;-x&lt;/code&gt; ，而 &lt;code&gt;-r&lt;/code&gt; 则禁用它。现在默认为不执行 &lt;code&gt;-x&lt;/code&gt; ,因此此选项为无操作。</target>
        </trans-unit>
        <trans-unit id="d5579126502958d7cf2a79d1e6eb0f1ab9f1fb74" translate="yes" xml:space="preserve">
          <source>It uses &lt;code&gt;showbranch.default&lt;/code&gt; multi-valued configuration items if no &amp;lt;rev&amp;gt; or &amp;lt;glob&amp;gt; is given on the command line.</source>
          <target state="translated">如果在命令行上没有给出&amp;lt;rev&amp;gt;或&amp;lt;glob&amp;gt;，它将使用 &lt;code&gt;showbranch.default&lt;/code&gt; 多值配置项。</target>
        </trans-unit>
        <trans-unit id="c599d3ca0dc61039dd83109e0beef002f0abd196" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;--export-all&lt;/code&gt; parameter is specified). If you pass some directory paths as &lt;code&gt;git daemon&lt;/code&gt; arguments, you can further restrict the offers to a whitelist comprising of those.</source>
          <target state="translated">它会验证目录中是否包含魔术文件&amp;ldquo; git-daemon-export-ok&amp;rdquo;，并且它将拒绝导出任何未明确标记为要导出的Git目录（除非指定了 &lt;code&gt;--export-all&lt;/code&gt; 参数） ）。如果您将某些目录路径作为 &lt;code&gt;git daemon&lt;/code&gt; 参数传递，则可以进一步将商品限制为包含这些商品的白名单。</target>
        </trans-unit>
        <trans-unit id="3fd1b09d35c94e426d7de9278697f8281d2f9b0b" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable is set).</source>
          <target state="translated">它会验证目录中是否包含魔术文件&amp;ldquo; git-daemon-export-ok&amp;rdquo;，并且它将拒绝导出任何未显式标记为要导出的Git目录（除非设置了 &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; 环境变量）。</target>
        </trans-unit>
        <trans-unit id="6a949f37aaca4177eee5df32a3761a98f4054a56" translate="yes" xml:space="preserve">
          <source>It was a tool of absolute last resort. I&amp;rsquo;d rather spend days looking at printk output than do a manual &lt;code&gt;patch bisection&lt;/code&gt;.</source>
          <target state="translated">这是绝对不得已的工具。我宁愿花几天的时间查看printk的输出，也不愿进行手工的 &lt;code&gt;patch bisection&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="839ea1dcb179bd0fd1a734d84c9b044b60c7a423" translate="yes" xml:space="preserve">
          <source>It will be useful to have a Git repository to experiment with as you read this manual.</source>
          <target state="translated">在阅读本手册的过程中,有一个 Git 仓库进行实验会很有用。</target>
        </trans-unit>
        <trans-unit id="a1e588b366d6eee7b2a111ab040de25b982fdb3f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible for a push to fail in this way when other people have the right to push to the same repository. In that case, the correct solution is to retry the push after first updating your work: either by a pull, or by a fetch followed by a rebase; see the &lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;next section&lt;/a&gt; and &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt; for more.</source>
          <target state="translated">当其他人有权推送到同一存储库时，推送也可能以这种方式失败。在这种情况下，正确的解决方案是在首先更新您的工作后重试推送：通过拉取，先获取后重新设置基准；请参阅&lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;下一节&lt;/a&gt;和&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt;了解更多信息。</target>
        </trans-unit>
        <trans-unit id="c8e637a625c72275676a912327970832afbb1fc7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s especially instructive to look at &quot;commit&quot; objects, since those tend to be small and fairly self-explanatory. In particular, if you follow the convention of having the top commit name in &lt;code&gt;.git/HEAD&lt;/code&gt;, you can do</source>
          <target state="translated">查看&amp;ldquo;提交&amp;rdquo;对象特别有启发性，因为这些对象通常很小并且很容易解释。特别是，如果遵循 &lt;code&gt;.git/HEAD&lt;/code&gt; 中具有最高提交名称的约定，则可以执行</target>
        </trans-unit>
        <trans-unit id="ebca6c1346b961bb4e2f8a08e1112a09cf4c4143" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s far too easy to accidentally mix up old and new history. It&amp;rsquo;s still possible with any tool, but git-filter-branch almost invites it. If lucky, the only downside is users getting frustrated that they don&amp;rsquo;t know how to shrink their repo and remove the old stuff. If unlucky, they merge old and new history and end up with multiple &quot;copies&quot; of each commit, some of which have unwanted or sensitive files and others which don&amp;rsquo;t. This comes about in multiple different ways:</source>
          <target state="translated">意外地混淆了新旧历史，这太容易了。仍然可以使用任何工具，但是git-filter-branch几乎可以邀请它。如果幸运的话，唯一的缺点就是用户会沮丧，因为他们不知道如何缩减存储库并删除旧内容。如果不走运，它们将合并新旧历史，并最终每次提交具有多个&amp;ldquo;副本&amp;rdquo;，其中一些包含不需要的文件或敏感文件，而另一些则没有。这以多种不同的方式实现：</target>
        </trans-unit>
        <trans-unit id="7fb3124f269af4d6382e41b308c15a44d9e7c09f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not safe to run &lt;code&gt;git submodule update&lt;/code&gt; if you&amp;rsquo;ve made and committed changes within a submodule without checking out a branch first. They will be silently overwritten:</source>
          <target state="translated">如果您在子模块中进行了更改并提交了更改而不先检出分支，则运行 &lt;code&gt;git submodule update&lt;/code&gt; 是不安全的。它们将被默默覆盖：</target>
        </trans-unit>
        <trans-unit id="199b24a07e7c4f542f5c9b6cd233e68c58c149e6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to push any type of object to any namespace outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt;. In the case of tags and commits, these will be treated as if they were the commits inside &lt;code&gt;refs/heads/*&lt;/code&gt; for the purposes of whether the update is allowed.</source>
          <target state="translated">可以将任何类型的对象推送到 &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 之外的任何名称空间。对于标记和提交，出于是否允许更新的目的，将它们视为 &lt;code&gt;refs/heads/*&lt;/code&gt; 中的提交。</target>
        </trans-unit>
        <trans-unit id="cd25bf8e6a6252931a48d686e2c25ca4a7c9f16e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s probably not worth it to use this option on a given repository without running tailored performance benchmarks on it. It takes a lot more time, and the resulting space/delta optimization may or may not be worth it. Not using this at all is the right trade-off for most users and their repositories.</source>
          <target state="translated">如果不在其上运行定制的性能基准，则在给定的存储库上使用此选项可能不值得。这需要花费更多时间，并且最终的空间/增量优化可能值得也可能不值得。对于大多数用户及其存储库，完全不使用此功能是正确的权衡。</target>
        </trans-unit>
        <trans-unit id="6c2d9fe7b4d73e7c5f324adf6070448f4f753fb5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s reasonable to e.g. configure &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; in &lt;code&gt;~/.gitconfig&lt;/code&gt; to have tags pruned whenever &lt;code&gt;git fetch --prune&lt;/code&gt; is run, without making every invocation of &lt;code&gt;git fetch&lt;/code&gt; without &lt;code&gt;--prune&lt;/code&gt; an error.</source>
          <target state="translated">合理的 &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; 是，例如，在 &lt;code&gt;~/.gitconfig&lt;/code&gt; 配置fetch.pruneTags = true， &lt;code&gt;git fetch --prune&lt;/code&gt; 在运行git fetch --prune时删除标签，而不会使没有 &lt;code&gt;--prune&lt;/code&gt; 的 &lt;code&gt;git fetch&lt;/code&gt; 每次调用都出错。</target>
        </trans-unit>
        <trans-unit id="b2ec8a66f406e3cd9a737fd2597d771efa24775d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually much more common that you merge with somebody else than merging with your own branches, so it&amp;rsquo;s worth pointing out that Git makes that very easy too, and in fact, it&amp;rsquo;s not that different from doing a &lt;code&gt;git merge&lt;/code&gt;. In fact, a remote merge ends up being nothing more than &quot;fetch the work from a remote repository into a temporary tag&quot; followed by a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">与其他人合并通常比与自己的分支合并更普遍，因此值得指出的是Git也使合并变得非常容易，实际上，与 &lt;code&gt;git merge&lt;/code&gt; 并没有什么不同。实际上，远程合并最终不过是&amp;ldquo;从远程存储库中获取工作到临时标记中&amp;rdquo;，然后是 &lt;code&gt;git merge&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09aeea995eee0f7341283401be15ea3abb990fd5" translate="yes" xml:space="preserve">
          <source>Iterate over all refs that match &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; and show them according to the given &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;, after sorting them according to the given set of &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; is given, stop after showing that many refs. The interpolated values in &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can optionally be quoted as string literals in the specified host language allowing their direct evaluation in that language.</source>
          <target state="translated">根据给定的 &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; 设置对所有符合 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 的 ref进行迭代，并根据给定的 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 显示它们。如果给出了 &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; ,则在显示很多引用后停止。 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 中的内插值可以选择用指定的宿主语言引用为字符串文字，从而允许使用该语言直接评估。</target>
        </trans-unit>
        <trans-unit id="ddf6f030820afdde653bed6b6ae7f0e48144f06d" translate="yes" xml:space="preserve">
          <source>Join two or more development histories together</source>
          <target state="translated">将两个或更多的发展历史连接在一起</target>
        </trans-unit>
        <trans-unit id="045fff3a75d61e019edb089792c9fca9353d7073" translate="yes" xml:space="preserve">
          <source>Just as the filesystem &lt;code&gt;.&lt;/code&gt; (period) refers to the current directory, using a &lt;code&gt;.&lt;/code&gt; as a repository name in Git (a dot-repository) is a relative path and means your current repository.</source>
          <target state="translated">就像文件系统一样 &lt;code&gt;.&lt;/code&gt; （句点）使用指向当前目录 &lt;code&gt;.&lt;/code&gt; 作为Git中的存储库名称（点存储库）是相对路径，表示您当前的存储库。</target>
        </trans-unit>
        <trans-unit id="dec0baabf794bebc3957d3bc4ac6d462cd46c778" translate="yes" xml:space="preserve">
          <source>Just doing &lt;code&gt;git checkout-index&lt;/code&gt; does nothing. You probably meant &lt;code&gt;git checkout-index -a&lt;/code&gt;. And if you want to force it, you want &lt;code&gt;git checkout-index -f -a&lt;/code&gt;.</source>
          <target state="translated">只是做 &lt;code&gt;git checkout-index&lt;/code&gt; 没有任何作用。您可能是说 &lt;code&gt;git checkout-index -a&lt;/code&gt; 。如果要强制执行此操作，则需要 &lt;code&gt;git checkout-index -f -a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4909a5e9d012cc77cb3f33966c75c24bd556a2c1" translate="yes" xml:space="preserve">
          <source>Just in case you are doing something exotic, it should be noted that all of the &amp;lt;commit&amp;gt; in the above description, except in the last two forms that use &quot;..&quot; notations, can be any &amp;lt;tree&amp;gt;.</source>
          <target state="translated">以防万一，您正在做一些奇特的事情，应该注意的是，上述描述中的所有&amp;lt;commit&amp;gt;，除了使用&amp;ldquo; ..&amp;rdquo;符号的最后两种形式之外，都可以是任何&amp;lt;tree&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="4be9ee55a1cb0649bc08a5f7fcba1609e56fcabe" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;push&lt;/code&gt;, a batch sequence of one or more &lt;code&gt;import&lt;/code&gt; is terminated with a blank line. For each batch of &lt;code&gt;import&lt;/code&gt;, the remote helper should produce a fast-import stream terminated by a &lt;code&gt;done&lt;/code&gt; command.</source>
          <target state="translated">就像 &lt;code&gt;push&lt;/code&gt; 一样，一个或多个 &lt;code&gt;import&lt;/code&gt; 的批处理序列以空行终止。对于每一批 &lt;code&gt;import&lt;/code&gt; ，远程帮助程序都应生成一个快速 &lt;code&gt;done&lt;/code&gt; 流，该流由完成的命令终止。</target>
        </trans-unit>
        <trans-unit id="586f68de6dc69eba27bb1d4e9d9bb6d0f56b4317" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (GMail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="translated">只需确保在电子邮件客户端中禁用换行即可（GMail的Web界面无论如何都会换行，因此您需要使用真正的IMAP客户端）。</target>
        </trans-unit>
        <trans-unit id="40ff32435dadcaf90c9ed938f5946c67e774e649" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (Gmail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="b97e8895c584b11a83b65d2dacb8c53b7178dd19" translate="yes" xml:space="preserve">
          <source>KMail</source>
          <target state="translated">KMail</target>
        </trans-unit>
        <trans-unit id="2341c447151da84825db8427aea972cadd7288d2" translate="yes" xml:space="preserve">
          <source>Keep a list of repositories you work with regularly:</source>
          <target state="translated">保存一个你经常合作的存储库的列表。</target>
        </trans-unit>
        <trans-unit id="2367d7104c669108a5a4faee96aaf23e4129a768" translate="yes" xml:space="preserve">
          <source>Keep changes in working tree while discarding some previous commits</source>
          <target state="translated">保留工作树中的变化,同时丢弃一些以前的提交。</target>
        </trans-unit>
        <trans-unit id="efc112fed108eb2af53bef134295307559c52881" translate="yes" xml:space="preserve">
          <source>Keep downloaded pack.</source>
          <target state="translated">保持下载的数据包。</target>
        </trans-unit>
        <trans-unit id="9b356018df37cea79789cf69374ce84ecae93c35" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;*&lt;/code&gt; (asterisk) wildcard of the local ref (right of the &lt;code&gt;:&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; be the farthest right path component; however the remote wildcard may be anywhere as long as it&amp;rsquo;s an independent path component (surrounded by &lt;code&gt;/&lt;/code&gt; or EOL). This type of configuration is not automatically created by &lt;code&gt;init&lt;/code&gt; and should be manually entered with a text-editor or using &lt;code&gt;git config&lt;/code&gt;.</source>
          <target state="translated">请记住，在 &lt;code&gt;*&lt;/code&gt; 地方裁判的（星号）通配符（右的 &lt;code&gt;:&lt;/code&gt; ）&lt;strong&gt;必须&lt;/strong&gt;是最右侧的路径组件; 但是，远程通配符可以是任意位置，只要它是一个独立的路径组件（由 &lt;code&gt;/&lt;/code&gt; 或EOL 包围）即可。这种类型的配置不是由 &lt;code&gt;init&lt;/code&gt; 自动创建的，应使用文本编辑器或 &lt;code&gt;git config&lt;/code&gt; 手动输入。</target>
        </trans-unit>
        <trans-unit id="f28d8482458ad8eaca4da9ce6d9f18435a267b61" translate="yes" xml:space="preserve">
          <source>Keep repeating the process: compile the tree, test it, and depending on whether it is good or bad run &lt;code&gt;git bisect good&lt;/code&gt; or &lt;code&gt;git bisect bad&lt;/code&gt; to ask for the next commit that needs testing.</source>
          <target state="translated">继续重复该过程：编译树，对其进行测试，然后根据它的好坏运行 &lt;code&gt;git bisect good&lt;/code&gt; 或 &lt;code&gt;git bisect bad&lt;/code&gt; ,以请求下一个需要测试的提交。</target>
        </trans-unit>
        <trans-unit id="4faf21022722c230f52c5287ce302764467e820e" translate="yes" xml:space="preserve">
          <source>Keep the commits that do not change anything from its parents in the result.</source>
          <target state="translated">保留结果中对其父母没有任何改变的承诺。</target>
        </trans-unit>
        <trans-unit id="ea4937dada87f98e69877594a5bd03ebc5a4fc74" translate="yes" xml:space="preserve">
          <source>Keep the current index contents, and read the contents of the named tree-ish under the directory at &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. The command will refuse to overwrite entries that already existed in the original index file.</source>
          <target state="translated">保留当前的索引内容，并在 &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; 目录下读取命名的tree-ish的内容。该命令将拒绝覆盖原始索引文件中已经存在的条目。</target>
        </trans-unit>
        <trans-unit id="d737c66ea055bf55ed844d15e52460a96096a67f" translate="yes" xml:space="preserve">
          <source>Keep the version from your branch in the work tree, but leave the path in the conflicted state for the user to sort out.</source>
          <target state="translated">在工作树中保留你的分支中的版本,但把路径留在冲突的状态中,让用户来整理。</target>
        </trans-unit>
        <trans-unit id="f9e507eaf43dc998f773c565be5cccbd49c418b4" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without a race condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e57eb6304d53fb35eb7b893fc3d7458db2c90c" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without race condition.</source>
          <target state="translated">创建后将工作树锁定。这等效于 &lt;code&gt;git worktree add&lt;/code&gt; 之后的 &lt;code&gt;git worktree lock&lt;/code&gt; ，但没有竞争条件。</target>
        </trans-unit>
        <trans-unit id="b288ae9d082d21fcccb8cbea92de9e2fd90c35f9" translate="yes" xml:space="preserve">
          <source>Keep unreachable objects in loose form. This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">将无法触及的物体保持在松散状态。这意味着 &lt;code&gt;--revs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fef7648dce54325886b4bd2e05123b8e3f3ba8b" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;project lead&quot; and possibly your &quot;sub-subsystem maintainers&quot;.</source>
          <target state="translated">继续在你的主仓库中工作。你的修改包括你自己的修改,你通过电子邮件收到的补丁,以及从你的 &quot;项目负责人 &quot;和可能的 &quot;子系统维护者 &quot;的 &quot;公共 &quot;仓库中拉出的合并。</target>
        </trans-unit>
        <trans-unit id="ca6eb7beb12ef44a32102578e1d606b2be688242" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;subsystem maintainers&quot;.</source>
          <target state="translated">继续在你的主仓库中工作。你的修改包括你自己的修改,你通过电子邮件收到的补丁,以及从你的 &quot;子系统维护者 &quot;的 &quot;公共 &quot;版本库中提取的合并。</target>
        </trans-unit>
        <trans-unit id="04e2360cc7b28c2ccb26642bb98ceb0fcbba2f5a" translate="yes" xml:space="preserve">
          <source>Keeping a patch series up to date using git rebase</source>
          <target state="translated">使用git rebase使补丁系列保持最新状态</target>
        </trans-unit>
        <trans-unit id="b81b785228a23fa6b75a5abffb474819b40a8136" translate="yes" xml:space="preserve">
          <source>Kill keywords: will extract files with &lt;code&gt;-kk&lt;/code&gt; from the CVS archive to avoid noisy changesets. Highly recommended, but off by default to preserve compatibility with early imported trees.</source>
          <target state="translated">Kill关键字：将使用 &lt;code&gt;-kk&lt;/code&gt; 从CVS存档中提取文件，以避免产生嘈杂的变更集。高度推荐，但默认情况下处于禁用状态，以保持与早期导入树的兼容性。</target>
        </trans-unit>
        <trans-unit id="02658e782a0ecc008f0ca6ffc2a20f7bdbee96d7" translate="yes" xml:space="preserve">
          <source>Label for the &quot;home link&quot; at the top of all pages, leading to &lt;code&gt;$home_link&lt;/code&gt; (usually the main gitweb page, which contains the projects list). It is used as the first component of gitweb&amp;rsquo;s &quot;breadcrumb trail&quot;: &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt;. Can be set at build time using the &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; variable. By default it is set to &quot;projects&quot;, as this link leads to the list of projects. Another popular choice is to set it to the name of site. Note that it is treated as raw HTML so it should not be set from untrusted sources.</source>
          <target state="translated">所有页面顶部的&amp;ldquo;主链接&amp;rdquo;标签，指向 &lt;code&gt;$home_link&lt;/code&gt; （通常是gitweb主页面，其中包含项目列表）。它用作gitweb的&amp;ldquo;面包屑跟踪&amp;rdquo;的第一个组件： &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt; 。可以在构建时使用 &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; 变量进行设置。默认情况下，它设置为&amp;ldquo;项目&amp;rdquo;，因为此链接指向项目列表。另一个流行的选择是将其设置为站点名称。请注意，它被视为原始HTML，因此不应从不受信任的来源进行设置。</target>
        </trans-unit>
        <trans-unit id="f135ec40c7a65e232b6284c7eadaae14bc4ec8e7" translate="yes" xml:space="preserve">
          <source>Labelling of conflicts markers</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
