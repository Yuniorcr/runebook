<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="1128ceb9ee850f084ee9c90bbc32c35e1a0677f6" translate="yes" xml:space="preserve">
          <source>Do not set up &quot;upstream&quot; configuration, even if the branch.autoSetupMerge configuration variable is true.</source>
          <target state="translated">不要设置 &quot;上游 &quot;配置,即使 branch.autoSetupMerge 配置变量为真。</target>
        </trans-unit>
        <trans-unit id="040575d6c90a48f5c39a665aeb7044e9eb43b684" translate="yes" xml:space="preserve">
          <source>Do not show a diffstat as part of the rebase process.</source>
          <target state="translated">不要在rebase过程中显示diffstat。</target>
        </trans-unit>
        <trans-unit id="6441f1c36e56fb2fa459a5f0796f9c305a9cf68e" translate="yes" xml:space="preserve">
          <source>Do not show any source or destination prefix.</source>
          <target state="translated">不要显示任何源或目的前缀。</target>
        </trans-unit>
        <trans-unit id="c24868a69fc39c6ac2b9ca770ce8aa6841828fe0" translate="yes" xml:space="preserve">
          <source>Do not show naming strings for each commit.</source>
          <target state="translated">不要显示每次提交的命名字符串。</target>
        </trans-unit>
        <trans-unit id="8fa5b27db8fcf759f01b0280edfd6b3431051bf3" translate="yes" xml:space="preserve">
          <source>Do not show notes. This negates the above &lt;code&gt;--notes&lt;/code&gt; option, by resetting the list of notes refs from which notes are shown. Options are parsed in the order given on the command line, so e.g. &quot;--notes --notes=foo --no-notes --notes=bar&quot; will only show notes from &quot;refs/notes/bar&quot;.</source>
          <target state="translated">不要显示笔记。通过重置显示注释的注释引用列表，可以取消上述 &lt;code&gt;--notes&lt;/code&gt; 选项。选项是按照命令行中给定的顺序进行解析的，因此&amp;ldquo; --notes --notes = foo --no-notes --notes = bar&amp;rdquo;将仅显示&amp;ldquo; refs / notes / bar&amp;rdquo;中的注释。</target>
        </trans-unit>
        <trans-unit id="9b02c841f1914bb7e6442db5b21cd8ed24132388" translate="yes" xml:space="preserve">
          <source>Do not show peeled tags or pseudorefs like &lt;code&gt;HEAD&lt;/code&gt; in the output.</source>
          <target state="translated">不要在输出中显示剥离的标签或伪引用（例如 &lt;code&gt;HEAD&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="2e0add30bcab4fc1d372892ee84a569922f89e58" translate="yes" xml:space="preserve">
          <source>Do not show the progress.</source>
          <target state="translated">不要显示进度。</target>
        </trans-unit>
        <trans-unit id="bb40d4a42e4bfb4ff33aaa6fa93d55da54d2c4f4" translate="yes" xml:space="preserve">
          <source>Do not strip/add &lt;code&gt;[PATCH]&lt;/code&gt; from the first line of the commit log message.</source>
          <target state="translated">不要从提交日志消息的第一行剥离/添加 &lt;code&gt;[PATCH]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa99438dbaa0b24c2ee497186eaab642c50dd94c" translate="yes" xml:space="preserve">
          <source>Do not sync p4/master with Perforce following a submit. Implies git-p4.disableRebase.</source>
          <target state="translated">在提交后,不要将 p4/master 与 Perforce 同步。意味着 git-p4.disableRebase。</target>
        </trans-unit>
        <trans-unit id="7b33c8101974f45df18e3e02278464887692318a" translate="yes" xml:space="preserve">
          <source>Do not treat &lt;code&gt;---&lt;/code&gt; as the end of the commit message. Use this when you know your input contains just the commit message itself (and not an email or the output of &lt;code&gt;git format-patch&lt;/code&gt;).</source>
          <target state="translated">不要将 &lt;code&gt;---&lt;/code&gt; 视为提交消息的结尾。当您知道您的输入仅包含提交消息本身（而不是电子邮件或 &lt;code&gt;git format-patch&lt;/code&gt; 的输出）时，请使用此选项。</target>
        </trans-unit>
        <trans-unit id="be1e8c28e0eca20ad17d3a007d8e373df410066a" translate="yes" xml:space="preserve">
          <source>Do not treat root commits as boundaries in &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. This option defaults to false.</source>
          <target state="translated">在&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]中&lt;/a&gt;不要将根提交视为边界。此选项默认为false。</target>
        </trans-unit>
        <trans-unit id="1ff1f1d3f9c5e718776c8b3b20fdd0d08c30cdae" translate="yes" xml:space="preserve">
          <source>Do not treat root commits as boundaries. This can also be controlled via the &lt;code&gt;blame.showRoot&lt;/code&gt; config option.</source>
          <target state="translated">不要将根提交视为边界。也可以通过 &lt;code&gt;blame.showRoot&lt;/code&gt; 配置选项进行控制。</target>
        </trans-unit>
        <trans-unit id="24a9efa9a70e1fda7e6a923e07fce62a5dfc6f39" translate="yes" xml:space="preserve">
          <source>Do not trust the line counts in the hunk headers, but infer them by inspecting the patch (e.g. after editing the patch without adjusting the hunk headers appropriately).</source>
          <target state="translated">不要相信hunk headers中的行数,而是通过检查补丁来推断(例如,在编辑补丁后没有适当调整hunk headers)。</target>
        </trans-unit>
        <trans-unit id="ab779b8d99fe56229fa093a46cdef1a09efa24ca" translate="yes" xml:space="preserve">
          <source>Do not try &amp;lt;directory&amp;gt;/.git/ if &amp;lt;directory&amp;gt; is no Git directory.</source>
          <target state="translated">如果&amp;lt;directory&amp;gt;不是Git目录，请不要尝试&amp;lt;directory&amp;gt; /。git /。</target>
        </trans-unit>
        <trans-unit id="5c47444dc7f2fc014cd4e67acdf260f62a7c8e62" translate="yes" xml:space="preserve">
          <source>Do not try to update submodules. This option is only respected when passed before --refresh.</source>
          <target state="translated">不要尝试更新子模块。只有在--refresh之前通过时,才会尊重这个选项。</target>
        </trans-unit>
        <trans-unit id="2177408392188ae81b2d122883b73ab471a2d934" translate="yes" xml:space="preserve">
          <source>Do not update the server information with &lt;code&gt;git update-server-info&lt;/code&gt;. This option skips updating local catalog files needed to publish this repository (or a direct copy of it) over HTTP or FTP. See &lt;a href=&quot;git-update-server-info&quot;&gt;git-update-server-info[1]&lt;/a&gt;.</source>
          <target state="translated">不要使用 &lt;code&gt;git update-server-info&lt;/code&gt; 更新服务器信息。此选项跳过通过HTTP或FTP发布发布此存储库（或其直接副本）所需的更新本地目录文件。参见&lt;a href=&quot;git-update-server-info&quot;&gt;git-update-server-info [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5053c19fad3601db22669a9dc4a1e312a5878c5e" translate="yes" xml:space="preserve">
          <source>Do not use any ref whose name matches a given shell pattern. The pattern can be one of branch name, tag name or fully qualified ref name. If given multiple times, a ref will be excluded when it matches any of the given patterns. When used together with --refs, a ref will be used as a match only when it matches at least one --refs pattern and does not match any --exclude patterns. Use &lt;code&gt;--no-exclude&lt;/code&gt; to clear the list of exclude patterns.</source>
          <target state="translated">不要使用名称与给定的外壳模式匹配的任何引用。该模式可以是分支名称，标记名称或标准引用名称之一。如果多次给定，则当ref与任何给定模式匹配时，它将被排除。与--refs一起使用时，仅当ref至少匹配一个--refs模式且不匹配任何--exclude模式时，ref才用作匹配项。使用 &lt;code&gt;--no-exclude&lt;/code&gt; 清除排除模式列表。</target>
        </trans-unit>
        <trans-unit id="267f50c7506b016b112f51819982f3c9ad863c01" translate="yes" xml:space="preserve">
          <source>Do not use branch names, but only tags to name the commits</source>
          <target state="translated">不要使用分支名,而只用标签来命名提交的内容</target>
        </trans-unit>
        <trans-unit id="5e1b9e0ae819ac2e51b8b3ec6d4f3a636596bd47" translate="yes" xml:space="preserve">
          <source>Do not use local URLs here if you plan to publish your superproject!</source>
          <target state="translated">如果您计划发布您的超级项目,请不要在这里使用本地URL!</target>
        </trans-unit>
        <trans-unit id="2120668c1016ed8353ecc179a2be3de457f3b18c" translate="yes" xml:space="preserve">
          <source>Do not use replacement refs to replace Git objects. See &lt;a href=&quot;git-replace&quot;&gt;git-replace[1]&lt;/a&gt; for more information.</source>
          <target state="translated">不要使用替换引用来替换Git对象。有关更多信息，请参见&lt;a href=&quot;git-replace&quot;&gt;git-replace [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46609390af561170d35a55596a89f9a47d125a47" translate="yes" xml:space="preserve">
          <source>Do not use the --amend option of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; on a change you&amp;rsquo;ve already dcommitted. It is considered bad practice to --amend commits you&amp;rsquo;ve already pushed to a remote repository for other users, and dcommit with SVN is analogous to that.</source>
          <target state="translated">请勿在已&lt;a href=&quot;git-commit&quot;&gt;提交&lt;/a&gt;的更改上使用git-commit [1]的--amend选项。-修改已经推送给其他用户的远程存储库的提交，这是一种不好的做法，而使用SVN进行dcommit与此类似。</target>
        </trans-unit>
        <trans-unit id="6b2f85cff30ddf16b20f53be5327aa0354418c7a" translate="yes" xml:space="preserve">
          <source>Do not verify the pack contents; only show the histogram of delta chain length. With &lt;code&gt;--verbose&lt;/code&gt;, list of objects is also shown.</source>
          <target state="translated">不要检查包装内容物；仅显示增量链长度的直方图。使用 &lt;code&gt;--verbose&lt;/code&gt; ，还显示对象列表。</target>
        </trans-unit>
        <trans-unit id="a72712d97eed5eb258082e78ab4de395a4c06778" translate="yes" xml:space="preserve">
          <source>Do nothing; only show what would happen</source>
          <target state="translated">什么都不做,只显示会发生什么</target>
        </trans-unit>
        <trans-unit id="c577d001dfd39377917177f9d18813c77808015f" translate="yes" xml:space="preserve">
          <source>Do some work in the newly created Git repository:</source>
          <target state="translated">在新创建的Git仓库中做一些工作。</target>
        </trans-unit>
        <trans-unit id="d54d62a688502dd57d02a2d25bcfc45fa6646725" translate="yes" xml:space="preserve">
          <source>Do we want to maintain that ability or simply write to the existing Trace2 targets (and convert &amp;lt;key&amp;gt; to a &quot;category&quot;).</source>
          <target state="translated">我们要保持这种能力还是只写现有的Trace2目标（并将&amp;lt;key&amp;gt;转换为&amp;ldquo;类别&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="93e5f9e78ae780b1443364c8b7bf637aab6beb2e" translate="yes" xml:space="preserve">
          <source>Do your work in your repository on &lt;code&gt;master&lt;/code&gt; branch.</source>
          <target state="translated">在 &lt;code&gt;master&lt;/code&gt; 分支的存储库中进行工作。</target>
        </trans-unit>
        <trans-unit id="5732ac98ebf7d9e51cffa639f3f3c4cdaefb04a8" translate="yes" xml:space="preserve">
          <source>Does not have a default value; you must configure this variable to enable note rewriting.</source>
          <target state="translated">没有默认值,你必须配置这个变量才能启用笔记重写。</target>
        </trans-unit>
        <trans-unit id="2a5f7374d914462e8df26d1af49c06790c2a1cc2" translate="yes" xml:space="preserve">
          <source>Does not have a default value; you must configure this variable to enable note rewriting. Set it to &lt;code&gt;refs/notes/commits&lt;/code&gt; to enable rewriting for the default commit notes.</source>
          <target state="translated">没有默认值；您必须配置此变量以启用便笺重写。将其设置为 &lt;code&gt;refs/notes/commits&lt;/code&gt; 以启用对默认提交说明的重写。</target>
        </trans-unit>
        <trans-unit id="42b7d5032e74e82b8de24d902e036f1902672dbe" translate="yes" xml:space="preserve">
          <source>Does not touch the index file or the working tree at all (but resets the head to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;, just like all modes do). This leaves all your changed files &quot;Changes to be committed&quot;, as &lt;code&gt;git status&lt;/code&gt; would put it.</source>
          <target state="translated">完全不触摸索引文件或工作树（而是将头重置为 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; ，就像所有模式一样）。就像 &lt;code&gt;git status&lt;/code&gt; 那样，这会将所有更改的文件保留为&amp;ldquo;要提交的更改&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="b8aff1882bc4744bec2ac3cf958c11aa9673615c" translate="yes" xml:space="preserve">
          <source>Does this seem a bit complicated? It &lt;strong&gt;should&lt;/strong&gt; be. There is no way that it would be correct to just &quot;fix&quot; it automatically. People need to know that their tags might have been changed.</source>
          <target state="translated">这看起来有点复杂吗？它&lt;strong&gt;应该&lt;/strong&gt;是。仅仅自动&amp;ldquo;修复&amp;rdquo;它是不可能的。人们需要知道他们的标签可能已更改。</target>
        </trans-unit>
        <trans-unit id="61f5489636e8756fab43669da94d9c6eb1552eb4" translate="yes" xml:space="preserve">
          <source>Doing a &lt;code&gt;git describe&lt;/code&gt; on a tag-name will just show the tag name:</source>
          <target state="translated">在标记名上执行 &lt;code&gt;git describe&lt;/code&gt; 只会显示标记名：</target>
        </trans-unit>
        <trans-unit id="4b69a1e19eb2053bb173df0509ff0e4b7b042821" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t actually add the file(s), just show if they exist and/or will be ignored.</source>
          <target state="translated">实际上不添加文件，仅显示它们是否存在和/或将被忽略。</target>
        </trans-unit>
        <trans-unit id="f54d87f7c2ff7fc56cad12eba47750dc91bee0b4" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t actually remove any file(s). Instead, just show if they exist in the index and would otherwise be removed by the command.</source>
          <target state="translated">实际上不删除任何文件。而是仅显示它们是否存在于索引中，否则将被命令删除。</target>
        </trans-unit>
        <trans-unit id="3c2e4a22e8795c4f8e08b8be88d75867a6768a7f" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t actually remove any objects, only show those that would have been removed.</source>
          <target state="translated">实际上不删除任何对象，仅显示将要删除的对象。</target>
        </trans-unit>
        <trans-unit id="8a190a462c45d47d231a38f49fbd7f2f651bc199" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t actually remove anything, just show what would be done.</source>
          <target state="translated">实际上不删除任何内容，只是显示将要执行的操作。</target>
        </trans-unit>
        <trans-unit id="788dd7013c132044903c150a0852f5a8328a9d58" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t add the file(s), but only refresh their stat() information in the index.</source>
          <target state="translated">不添加文件，而仅刷新索引中的stat（）信息。</target>
        </trans-unit>
        <trans-unit id="f4886df5278511a526465d27599221df6718296c" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allow recursing into subdirectories</source>
          <target state="translated">不允许递归到子目录</target>
        </trans-unit>
        <trans-unit id="2b7948ae75b37ecb202b98940fbd260554ad9c60" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t apply changes to files matching the given path pattern. This can be useful when importing patchsets, where you want to exclude certain files or directories.</source>
          <target state="translated">不要将更改应用于与给定路径模式匹配的文件。在导入要排除某些文件或目录的补丁集时，这很有用。</target>
        </trans-unit>
        <trans-unit id="2f2b3b379c55090808ba7e10cb915259f5f77fb1" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t bother trying to optimize the frontend to stick to one branch at a time during an import. Although doing so might be slightly faster for fast-import, it tends to increase the complexity of the frontend code considerably.</source>
          <target state="translated">在导入过程中，不必费心尝试优化前端以一次坚持一个分支。尽管这样做对于快速导入可能会稍快一些，但它往往会大大增加前端代码的复杂性。</target>
        </trans-unit>
        <trans-unit id="9fcb0638343c39672840bc9fb655ac9cf336ccdb" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t check for &lt;code&gt;gitcvs.enabled&lt;/code&gt; in config. You also have to specify a list of allowed directories (see below) if you want to use this option.</source>
          <target state="translated">不要在配置中检查 &lt;code&gt;gitcvs.enabled&lt;/code&gt; 。如果要使用此选项，还必须指定允许目录的列表（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="f17e0ba24864a0b6291f2e5b252834a0764b0842" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t checkout new files, only refresh files already checked out.</source>
          <target state="translated">不签出新文件，仅刷新已签出的文件。</target>
        </trans-unit>
        <trans-unit id="22dcca7d230068e332b541f07dc3e71c28dc5b04" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t clone any tags, and set &lt;code&gt;remote.&amp;lt;remote&amp;gt;.tagOpt=--no-tags&lt;/code&gt; in the config, ensuring that future &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt; operations won&amp;rsquo;t follow any tags. Subsequent explicit tag fetches will still work, (see &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">不要克隆任何标签，并设置 &lt;code&gt;remote.&amp;lt;remote&amp;gt;.tagOpt=--no-tags&lt;/code&gt; 配置中没有标签，确保将来的 &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git fetch&lt;/code&gt; 操作不会跟随任何标签。随后的显式标签获取仍将起作用（请参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3928941c430ea9498986b54cb54f9b256c71e581" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t confuse that object with the file &lt;code&gt;hello&lt;/code&gt; itself. The object is literally just those specific &lt;strong&gt;contents&lt;/strong&gt; of the file, and however much you later change the contents in file &lt;code&gt;hello&lt;/code&gt;, the object we just looked at will never change. Objects are immutable.</source>
          <target state="translated">不要将该对象与文件 &lt;code&gt;hello&lt;/code&gt; 本身混淆。该对象实际上只是文件的那些特定&lt;strong&gt;内容&lt;/strong&gt;，但是以后您在文件 &lt;code&gt;hello&lt;/code&gt; 中更改内容时，我们刚刚查看的对象将永远不会更改。对象是不可变的。</target>
        </trans-unit>
        <trans-unit id="cf554901f1ba37dc7b685eec286604a92a0846c0" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t look in the index when undertaking the checks. This can be used to debug why a path became tracked by e.g. &lt;code&gt;git add .&lt;/code&gt; and was not ignored by the rules as expected by the user or when developing patterns including negation to match a path previously added with &lt;code&gt;git add -f&lt;/code&gt;.</source>
          <target state="translated">进行检查时不要查看索引。这可以用来调试为什么 &lt;code&gt;git add .&lt;/code&gt; 跟踪路径的原因。并没有被用户期望的规则忽略，也没有在开发包括否定的模式以匹配先前使用 &lt;code&gt;git add -f&lt;/code&gt; 添加的路径时被用户忽略。</target>
        </trans-unit>
        <trans-unit id="5a869b3f77007c08fe64b3ee7ff33b9bfbbe7c94" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t match the pattern in binary files.</source>
          <target state="translated">与二进制文件中的模式不匹配。</target>
        </trans-unit>
        <trans-unit id="5a5ec41a36a96759ae5f2ddb0abb3aacee88e9b9" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t output anything, just set exit status. This is only valid with a single pathname.</source>
          <target state="translated">不输出任何内容，只需设置退出状态即可。仅对单个路径名有效。</target>
        </trans-unit>
        <trans-unit id="c7bdd135c2e86877ecc2a31a6eaa651f0cae6dc5" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t print anything to standard output. This form is primarily meant to allow the caller to test the exit status to see if a range of objects is fully connected (or not). It is faster than redirecting stdout to &lt;code&gt;/dev/null&lt;/code&gt; as the output does not have to be formatted.</source>
          <target state="translated">不要将任何内容打印到标准输出。这种形式主要是为了允许调用者测试退出状态，以查看一定范围内的对象是否完全连接。它比将stdout重定向到 &lt;code&gt;/dev/null&lt;/code&gt; 更快，因为不必格式化输出。</target>
        </trans-unit>
        <trans-unit id="0fe178924f571848754ae3ca5c4cf62bf5caeff8" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t prompt before each invocation of the merge resolution program. This is the default if the merge resolution program is explicitly specified with the &lt;code&gt;--tool&lt;/code&gt; option or with the &lt;code&gt;merge.tool&lt;/code&gt; configuration variable.</source>
          <target state="translated">在每次调用合并解析程序之前不要提示。这是默认的，如果合并的决议程序明确地指定 &lt;code&gt;--tool&lt;/code&gt; 选项或 &lt;code&gt;merge.tool&lt;/code&gt; 配置变量。</target>
        </trans-unit>
        <trans-unit id="aa836ce110cb6ce4b0a545e26c40cb721f663696" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t require an exact match if given an SVN revision, instead find the commit corresponding to the state of the SVN repository (on the current branch) at the specified revision.</source>
          <target state="translated">如果给定了SVN修订版，则不需要完全匹配，而是在指定的修订版中找到与SVN存储库状态（在当前分支上）相对应的提交。</target>
        </trans-unit>
        <trans-unit id="30faa3ecbc3ccb0ab260167231bedadc40f9ae9d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t require an exact match if given an SVN revision; if there is not an exact match return the closest match searching forward in the history.</source>
          <target state="translated">如果提供了SVN版本，则不需要完全匹配；如果没有精确匹配，则返回历史记录中向前搜索的最接近的匹配。</target>
        </trans-unit>
        <trans-unit id="ef2daf7d2683c0bf520ff3f8d38713d17a81ee22" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t require objects present in packs from alternate object directories to be present in local packs.</source>
          <target state="translated">不需要本地对象中包含备用对象目录中包含的对象。</target>
        </trans-unit>
        <trans-unit id="e1e770659b3cd4fc8fd1b8c1f885e57fa2890f04" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t rescan the working directory for changes after the tool finishes execution.</source>
          <target state="translated">工具执行完毕后，请勿重新扫描工作目录以查找更改。</target>
        </trans-unit>
        <trans-unit id="1955458ea299c15696f62795bf10129efdff9000" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use the standard ignore rules (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), but still use the ignore rules given with &lt;code&gt;-e&lt;/code&gt; options from the command line. This allows removing all untracked files, including build products. This can be used (possibly in conjunction with &lt;code&gt;git restore&lt;/code&gt; or &lt;code&gt;git reset&lt;/code&gt;) to create a pristine working directory to test a clean build.</source>
          <target state="translated">不要使用标准的忽略规则（请参阅&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;），但仍要使用命令行中 &lt;code&gt;-e&lt;/code&gt; 选项提供的忽略规则。这允许删除所有未跟踪的文件，包括构建产品。可以使用它（可能与 &lt;code&gt;git restore&lt;/code&gt; 或 &lt;code&gt;git reset&lt;/code&gt; 结合使用）创建一个原始的工作目录以测试干净的构建。</target>
        </trans-unit>
        <trans-unit id="95e3ebfd9dfe40579e0e7bb35d42c2f1d1029d68" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t worry about the fact that the file that the &lt;code&gt;HEAD&lt;/code&gt; link points to doesn&amp;rsquo;t even exist yet &amp;mdash; you haven&amp;rsquo;t created the commit that will start your &lt;code&gt;HEAD&lt;/code&gt; development branch yet.</source>
          <target state="translated">不必担心 &lt;code&gt;HEAD&lt;/code&gt; 链接指向的文件甚至还不存在的事实-您尚未创建将启动 &lt;code&gt;HEAD&lt;/code&gt; 开发分支的提交。</target>
        </trans-unit>
        <trans-unit id="1da5527fefac2ac016e63872cd219c0c8262438e" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t write objects with broken content or links.</source>
          <target state="translated">不要写内容或链接损坏的对象。</target>
        </trans-unit>
        <trans-unit id="e7a1a9f0e0a5a192e64b7762fcd9606f05d43ef7" translate="yes" xml:space="preserve">
          <source>Dotted Range Notations</source>
          <target state="translated">虚线范围符号</target>
        </trans-unit>
        <trans-unit id="fe1f0cdd2295f0fc3d04581839d09ed55a16a282" translate="yes" xml:space="preserve">
          <source>Download from a remote Git repository via HTTP</source>
          <target state="translated">通过HTTP从远程Git仓库下载。</target>
        </trans-unit>
        <trans-unit id="836b914c612e9d15306b7c7c51825eb694378b40" translate="yes" xml:space="preserve">
          <source>Download objects and refs from another repository</source>
          <target state="translated">从其他资源库下载对象和参考资料</target>
        </trans-unit>
        <trans-unit id="8d0359221c31b38a499fab5fd3539fb10094e3f5" translate="yes" xml:space="preserve">
          <source>Downloader from http and https URL first obtains the topmost commit object name from the remote site by looking at the specified refname under &lt;code&gt;repo.git/refs/&lt;/code&gt; directory, and then tries to obtain the commit object by downloading from &lt;code&gt;repo.git/objects/xx/xxx...&lt;/code&gt; using the object name of that commit object. Then it reads the commit object to find out its parent commits and the associate tree object; it repeats this process until it gets all the necessary objects. Because of this behavior, they are sometimes also called &lt;code&gt;commit walkers&lt;/code&gt;.</source>
          <target state="translated">从http和https URL的下载程序首先通过查看 &lt;code&gt;repo.git/refs/&lt;/code&gt; 目录下的指定refname来从远程站点获取最高的提交对象名称，然后尝试通过从 &lt;code&gt;repo.git/objects/xx/xxx...&lt;/code&gt; 下载来获取提交对象。/ xxx ...使用该提交对象的对象名称。然后，它读取提交对象以找出其父提交和关联树对象；它重复此过程，直到获得所有必需的对象。由于这种行为，它们有时也称为 &lt;code&gt;commit walkers&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="412ca0a4593b6bb25e0ce340f46f24955e9564f1" translate="yes" xml:space="preserve">
          <source>Downloads a remote Git repository via HTTP.</source>
          <target state="translated">通过 HTTP 下载远程 Git 仓库。</target>
        </trans-unit>
        <trans-unit id="d85415280c4796b4419737c81adcd5229edbb60b" translate="yes" xml:space="preserve">
          <source>Draw a text-based graphical representation of the commit history on the left hand side of the output. This may cause extra lines to be printed in between commits, in order for the graph history to be drawn properly. Cannot be combined with &lt;code&gt;--no-walk&lt;/code&gt;.</source>
          <target state="translated">在输出的左侧绘制提交历史记录的基于文本的图形表示。这可能会导致在两次提交之间打印额外的行，以便正确绘制图形历史记录。不能与 &lt;code&gt;--no-walk&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="b9a3e66d069ffbfcdae00ac848d80a3d7117cd5f" translate="yes" xml:space="preserve">
          <source>Driving a bisection automatically</source>
          <target state="translated">自动驱动二段式</target>
        </trans-unit>
        <trans-unit id="8c3114460a846e0f3462ade2fcc59d06117961f0" translate="yes" xml:space="preserve">
          <source>Driving a bisection manually</source>
          <target state="translated">手动驱动二段式</target>
        </trans-unit>
        <trans-unit id="cae458d58531d4d41393b21599b7e5c5946ef1f2" translate="yes" xml:space="preserve">
          <source>Dry run. Check the pack file without actually unpacking the objects.</source>
          <target state="translated">干运行。在不实际解压对象的情况下检查包文件。</target>
        </trans-unit>
        <trans-unit id="5c890eaf0d21c06618fd87da2696a29e291c6564" translate="yes" xml:space="preserve">
          <source>Due to historical reasons a relative &lt;code&gt;filename&lt;/code&gt; is first searched relative to the current directory for &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;clone&lt;/code&gt; and relative to the root of the working tree for &lt;code&gt;fetch&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is not found, it is searched like any other command in &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">由于历史原因，首先要相对于当前目录搜索一个相对 &lt;code&gt;filename&lt;/code&gt; 以进行 &lt;code&gt;init&lt;/code&gt; 和 &lt;code&gt;clone&lt;/code&gt; 以及相对于工作树的根目录进行 &lt;code&gt;fetch&lt;/code&gt; 。如果未找到 &lt;code&gt;filename&lt;/code&gt; ，则会像 &lt;code&gt;$PATH&lt;/code&gt; 任何其他命令一样搜索它。</target>
        </trans-unit>
        <trans-unit id="7ad95c4fe8f7afde6130611f6d6b430e519d5657" translate="yes" xml:space="preserve">
          <source>Due to limitations of the current implementation, some configuration variables do not take effect until after the initial fetch and checkout. Configuration variables known to not take effect are: &lt;code&gt;remote.&amp;lt;name&amp;gt;.mirror&lt;/code&gt; and &lt;code&gt;remote.&amp;lt;name&amp;gt;.tagOpt&lt;/code&gt;. Use the corresponding &lt;code&gt;--mirror&lt;/code&gt; and &lt;code&gt;--no-tags&lt;/code&gt; options instead.</source>
          <target state="translated">由于当前实施方式的限制，某些配置变量要等到初始获取和签出后才能生效。已知不会生效的配置变量是： &lt;code&gt;remote.&amp;lt;name&amp;gt;.mirror&lt;/code&gt; 和 &lt;code&gt;remote.&amp;lt;name&amp;gt;.tagOpt&lt;/code&gt; 。请改用相应的 &lt;code&gt;--mirror&lt;/code&gt; 和 &lt;code&gt;--no-tags&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="d45f204a58b5658a36a8173fede6b8a78f6ae4f4" translate="yes" xml:space="preserve">
          <source>Due to the immutable nature of Git objects, old objects can be archived into shared, read-only directories. This variable specifies a &quot;:&quot; separated (on Windows &quot;;&quot; separated) list of Git object directories which can be used to search for Git objects. New objects will not be written to these directories.</source>
          <target state="translated">由于 Git 对象的不可更改性,旧的对象可以被归档到共享的只读目录中,这个变量指定了一个以&quot;:&quot;分隔(在 Windows 中以&quot;;&quot;分隔)的 Git 对象目录列表,用来搜索 Git 对象。这个变量指定了一个以&quot;:&quot;分隔(在 Windows 中以&quot;;&quot;分隔)的 Git 对象目录列表,可以用来搜索 Git 对象。新的对象不会被写入这些目录。</target>
        </trans-unit>
        <trans-unit id="0f5d7ad945110923c581691c469acfd9049cddb1" translate="yes" xml:space="preserve">
          <source>Due to the lack of accurate tree information (arising from constructing fake ancestors with the limited information available in patches), directory rename detection is disabled in the apply backend. Disabled directory rename detection means that if one side of history renames a directory and the other adds new files to the old directory, then the new files will be left behind in the old directory without any warning at the time of rebasing that you may want to move these files into the new directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b7a95dc6b5470754cb8fce020cce7d3aab1ac0" translate="yes" xml:space="preserve">
          <source>Due to the non-quarantine nature of the &lt;code&gt;fetch.fsckObjects&lt;/code&gt; implementation it cannot be relied upon to leave the object store clean like &lt;code&gt;receive.fsckObjects&lt;/code&gt; can.</source>
          <target state="translated">由于 &lt;code&gt;fetch.fsckObjects&lt;/code&gt; 实现的非隔离性质，因此不能像 &lt;code&gt;receive.fsckObjects&lt;/code&gt; 一样依靠它来保持对象存储的整洁。</target>
        </trans-unit>
        <trans-unit id="68e19d88dc6eefe7753376e94bb2d970e8771158" translate="yes" xml:space="preserve">
          <source>Dumps the internal marks table to &amp;lt;file&amp;gt; when complete. Marks are written one per line as &lt;code&gt;:markid SHA-1&lt;/code&gt;. Frontends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs. As &amp;lt;file&amp;gt; is only opened and truncated at checkpoint (or completion) the same path can also be safely given to --import-marks.</source>
          <target state="translated">完成后将内部标记表转储到&amp;lt;file&amp;gt;。标记每行写为 &lt;code&gt;:markid SHA-1&lt;/code&gt; 。前端可以使用此文件在完成导入后验证导入，或在增量运行中保存标记表。由于&amp;lt;file&amp;gt;仅在检查点（或完成点）打开和截断，因此也可以安全地给--import-marks提供相同的路径。</target>
        </trans-unit>
        <trans-unit id="d5f9d9df34707e95a5d4be8e3705f8049d385295" translate="yes" xml:space="preserve">
          <source>Dumps the internal marks table to &amp;lt;file&amp;gt; when complete. Marks are written one per line as &lt;code&gt;:markid SHA-1&lt;/code&gt;. Only marks for revisions are dumped; marks for blobs are ignored. Backends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs. As &amp;lt;file&amp;gt; is only opened and truncated at completion, the same path can also be safely given to --import-marks. The file will not be written if no new object has been marked/exported.</source>
          <target state="translated">完成后将内部标记表转储到&amp;lt;file&amp;gt;。标记每行写为 &lt;code&gt;:markid SHA-1&lt;/code&gt; 。仅转储修订标记；斑点标记将被忽略。后端可以使用此文件在完成导入后验证导入，或在增量运行中保存标记表。由于&amp;lt;file&amp;gt;仅在完成时打开和截断，因此也可以安全地给--import-marks提供相同的路径。如果未标记/导出新对象，则不会写入文件。</target>
        </trans-unit>
        <trans-unit id="aec3ad9b971b7ff8255345b154c94258f560f0d2" translate="yes" xml:space="preserve">
          <source>During a merge, the working tree files are updated to reflect the result of the merge. Among the changes made to the common ancestor&amp;rsquo;s version, non-overlapping ones (that is, you changed an area of the file while the other side left that area intact, or vice versa) are incorporated in the final result verbatim. When both sides made changes to the same area, however, Git cannot randomly pick one side over the other, and asks you to resolve it by leaving what both sides did to that area.</source>
          <target state="translated">在合并期间，将更新工作树文件以反映合并结果。在对共同祖先版本所做的更改中，非重叠更改（即，您更改了文件区域，而另一侧则保留了该区域，反之亦然）被逐字包含在最终结果中。但是，当双方对同一区域进行更改时，Git不能随机选择另一侧，而要求您通过将双方所做的事情留给该区域来解决。</target>
        </trans-unit>
        <trans-unit id="d0b0f9a14f12b4d06a31ddb153754d3c653f1bb2" translate="yes" xml:space="preserve">
          <source>During fsck git may find issues with legacy data which wouldn&amp;rsquo;t be generated by current versions of git, and which wouldn&amp;rsquo;t be sent over the wire if &lt;code&gt;transfer.fsckObjects&lt;/code&gt; was set. This feature is intended to support working with legacy repositories containing such data.</source>
          <target state="translated">在fsck期间，git可能会发现遗留数据的问题，这些问题不会由git的当前版本生成，并且如果设置了 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; ,则不会通过网络发送。此功能旨在支持使用包含此类数据的旧版存储库。</target>
        </trans-unit>
        <trans-unit id="0eedfc5c015b233e6082e4e46ded41bc5da25b25" translate="yes" xml:space="preserve">
          <source>During the merge, the index holds three versions of each file. Each of these three &quot;file stages&quot; represents a different version of the file:</source>
          <target state="translated">在合并过程中,索引持有每个文件的三个版本。这三个 &quot;文件阶段 &quot;中的每一个都代表了文件的不同版本。</target>
        </trans-unit>
        <trans-unit id="338f11841fc746012903e84c16b88356c6508da5" translate="yes" xml:space="preserve">
          <source>During the normal execution of several Git commands, call-outs are made to optional scripts that allow a developer to add functionality or checking. Typically, the hooks allow for a command to be pre-verified and potentially aborted, and allow for a post-notification after the operation is done. The hook scripts are found in the &lt;code&gt;$GIT_DIR/hooks/&lt;/code&gt; directory, and are enabled by simply removing the &lt;code&gt;.sample&lt;/code&gt; suffix from the filename. In earlier versions of Git you had to make them executable.</source>
          <target state="translated">在正常执行几个Git命令期间，将对可选脚本进行调用，这些脚本允许开发人员添加功能或检查。通常，钩子允许对命令进行预验证并可能中止，并在操作完成后允许进行后通知。钩子脚本位于 &lt;code&gt;$GIT_DIR/hooks/&lt;/code&gt; 目录中，只需从文件名中删除 &lt;code&gt;.sample&lt;/code&gt; 后缀即可启用它们。在早期版本的Git中，您必须使它们可执行。</target>
        </trans-unit>
        <trans-unit id="0c9afe2970bcd3db38ea14d913886ce00bad52d6" translate="yes" xml:space="preserve">
          <source>E.g, &lt;code&gt;format:&quot;The author of %h was %an, %ar%nThe title was &amp;gt;&amp;gt;%s&amp;lt;&amp;lt;%n&quot;&lt;/code&gt; would show something like this:</source>
          <target state="translated">例如， &lt;code&gt;format:&quot;The author of %h was %an, %ar%nThe title was &amp;gt;&amp;gt;%s&amp;lt;&amp;lt;%n&quot;&lt;/code&gt; 将显示如下内容：</target>
        </trans-unit>
        <trans-unit id="f48496348ce670a87dfe7a89fce6efc7850de45b" translate="yes" xml:space="preserve">
          <source>EVENT Format</source>
          <target state="translated">事件格式</target>
        </trans-unit>
        <trans-unit id="6c7b6f5f1d21b52d57339a7396d0f52ff8e6b468" translate="yes" xml:space="preserve">
          <source>Each &quot;index&quot; entry has two bits worth of &quot;stage&quot; state. stage 0 is the normal one, and is the only one you&amp;rsquo;d see in any kind of normal use.</source>
          <target state="translated">每个&amp;ldquo;索引&amp;rdquo;条目都有两个位的&amp;ldquo;阶段&amp;rdquo;状态值。阶段0是正常阶段，并且是您在任何正常使用情况下都会看到的唯一阶段。</target>
        </trans-unit>
        <trans-unit id="81f54a7f6a9b658757fad1b0dd5d1a9971c93ea4" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;%feature&lt;/code&gt; hash element is a hash reference and has the following structure:</source>
          <target state="translated">每个 &lt;code&gt;%feature&lt;/code&gt; 哈希元素都是一个哈希引用，并具有以下结构：</target>
        </trans-unit>
        <trans-unit id="b26592933b83f1f492565be647afc2706b49b317" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;-p&lt;/code&gt; indicates the id of a parent commit object.</source>
          <target state="translated">每个 &lt;code&gt;-p&lt;/code&gt; 指示父提交对象的ID。</target>
        </trans-unit>
        <trans-unit id="28c6016fba0ad5f1dd3d6f3368983aadf37364e2" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;git -C &amp;lt;repo&amp;gt; &amp;lt;arguments&amp;gt;&lt;/code&gt; subprocess inherits the standard file descriptors &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, and &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a09fd45cc17448d565b97a290193dc0600d3ce" translate="yes" xml:space="preserve">
          <source>Each action is implemented as a subroutine, and must be present in %actions hash. Some actions are disabled by default, and must be turned on via feature mechanism. For example to enable &lt;code&gt;blame&lt;/code&gt; view add the following to gitweb configuration file:</source>
          <target state="translated">每个操作均作为子例程实现，并且必须存在于％actions哈希中。默认情况下，某些操作是禁用的，必须通过功能机制将其打开。例如，要启用 &lt;code&gt;blame&lt;/code&gt; 视图，请将以下内容添加到gitweb配置文件中：</target>
        </trans-unit>
        <trans-unit id="4a431caa46e2fb6d34e98615d6339148b9977f86" translate="yes" xml:space="preserve">
          <source>Each attribute can be in one of these states for a given path:</source>
          <target state="translated">对于一个给定的路径,每个属性都可以处于这些状态中的一种。</target>
        </trans-unit>
        <trans-unit id="80fa6b90c4af909cefe5f1fba5144ae109300923" translate="yes" xml:space="preserve">
          <source>Each blame entry always starts with a line of:</source>
          <target state="translated">每个责备条目总是以一行开始。</target>
        </trans-unit>
        <trans-unit id="2235e2f29b242d64317e253060371b53dfcfe3a6" translate="yes" xml:space="preserve">
          <source>Each command for the &lt;code&gt;proc-receive&lt;/code&gt; hook may point to a pseudo-reference and always has a zero-old as its old-oid, while the &lt;code&gt;proc-receive&lt;/code&gt; hook may update an alternate reference and the alternate reference may exist already with a non-zero old-oid. For this case, this hook will use &quot;option&quot; directives to report extended attributes for the reference given by the leading &quot;ok&quot; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890525cbde82d7616c57fdec079512ee27038efd" translate="yes" xml:space="preserve">
          <source>Each commit imported by &lt;code&gt;git p4&lt;/code&gt; has a line at the end of the log message indicating the p4 depot location and change number. This line is used by later &lt;code&gt;git p4 sync&lt;/code&gt; operations to know which p4 changes are new.</source>
          <target state="translated">&lt;code&gt;git p4&lt;/code&gt; 导入的每个提交在日志消息的末尾都有一行，指示p4库的位置和更改号。以后的 &lt;code&gt;git p4 sync&lt;/code&gt; 操作使用此行来知道哪些p4更改是新的。</target>
        </trans-unit>
        <trans-unit id="0d7aba1c95771e1fa299e8f177a2cb8fdb72c0d3" translate="yes" xml:space="preserve">
          <source>Each event is a JSON-object containing multiple key/value pairs written as a single line and followed by a LF.</source>
          <target state="translated">每个事件是一个JSON对象,包含多个键/值对,写成一行,后面跟着一个LF。</target>
        </trans-unit>
        <trans-unit id="93024a055d9225f66feed1627e9698b1aeced23b" translate="yes" xml:space="preserve">
          <source>Each group of changes (called a &quot;hunk&quot;) in the textual diff output is prefixed with a line of the form:</source>
          <target state="translated">文本差异输出中的每一组变化(称为 &quot;hunk&quot;)都在前面加了一行,形式为:。</target>
        </trans-unit>
        <trans-unit id="227cc42fafaaa73089d47f3a2585fc225301de56" translate="yes" xml:space="preserve">
          <source>Each helper is specified by a single string in the configuration variable &lt;code&gt;credential.helper&lt;/code&gt; (and others, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). The string is transformed by Git into a command to be executed using these rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82afba91b0fbc1511d9d66475a7a1226634e3792" translate="yes" xml:space="preserve">
          <source>Each instruction has variable length. Instruction type is determined by the seventh bit of the first octet. The following diagrams follow the convention in RFC 1951 (Deflate compressed data format).</source>
          <target state="translated">每条指令的长度是可变的。指令类型由第一个八位组的第七位决定。以下图表遵循RFC 1951(Deflate压缩数据格式)中的约定。</target>
        </trans-unit>
        <trans-unit id="e70c1e613f5f534aeea8db8eaf0d4059228f6833" translate="yes" xml:space="preserve">
          <source>Each line in &lt;code&gt;gitattributes&lt;/code&gt; file is of form:</source>
          <target state="translated">&lt;code&gt;gitattributes&lt;/code&gt; 文件中的每一行都是以下形式：</target>
        </trans-unit>
        <trans-unit id="1c072d6c2cdd76489a2967b2e7ee81381c672ff3" translate="yes" xml:space="preserve">
          <source>Each line in a &lt;code&gt;gitignore&lt;/code&gt; file specifies a pattern. When deciding whether to ignore a path, Git normally checks &lt;code&gt;gitignore&lt;/code&gt; patterns from multiple sources, with the following order of precedence, from highest to lowest (within one level of precedence, the last matching pattern decides the outcome):</source>
          <target state="translated">&lt;code&gt;gitignore&lt;/code&gt; 文件中的每一行都指定一个模式。在决定是否忽略路径时，Git通常会从多个来源检查 &lt;code&gt;gitignore&lt;/code&gt; 模式，并按照从高到低的顺序（从一个优先级，最后一个匹配模式决定结果）：</target>
        </trans-unit>
        <trans-unit id="d043aa624315c625b39f19b7c5a71a08d0fbefd2" translate="yes" xml:space="preserve">
          <source>Each line of options has this format:</source>
          <target state="translated">每一行的选项都有这样的格式。</target>
        </trans-unit>
        <trans-unit id="ce263659ab1a0135f8fda2a68c8ecc96cb2e4b52" translate="yes" xml:space="preserve">
          <source>Each line of the &lt;code&gt;git ls-files --unmerged&lt;/code&gt; output begins with the blob mode bits, blob SHA-1, 'stage number', and the filename. The 'stage number' is Git&amp;rsquo;s way to say which tree it came from: stage 1 corresponds to the &lt;code&gt;$orig&lt;/code&gt; tree, stage 2 to the &lt;code&gt;HEAD&lt;/code&gt; tree, and stage 3 to the &lt;code&gt;$target&lt;/code&gt; tree.</source>
          <target state="translated">&lt;code&gt;git ls-files --unmerged&lt;/code&gt; 输出的每一行都以blob模式位，blob SHA-1，&amp;ldquo;阶段号&amp;rdquo;和文件名开头。 &amp;ldquo;阶段号&amp;rdquo;是Git表示它来自哪棵树的方式：阶段1对应于 &lt;code&gt;$orig&lt;/code&gt; 树，阶段2对应于 &lt;code&gt;HEAD&lt;/code&gt; 树，阶段3对应于 &lt;code&gt;$target&lt;/code&gt; 树。</target>
        </trans-unit>
        <trans-unit id="a2e72e23a1ee3c2cf405696e86ad1ef3c4d6f422" translate="yes" xml:space="preserve">
          <source>Each line of the &lt;code&gt;git ls-files --unmerged&lt;/code&gt; output begins with the blob mode bits, blob SHA-1, &lt;code&gt;stage number&lt;/code&gt;, and the filename. The &lt;code&gt;stage number&lt;/code&gt; is Git&amp;rsquo;s way to say which tree it came from: stage 1 corresponds to the &lt;code&gt;$orig&lt;/code&gt; tree, stage 2 to the &lt;code&gt;HEAD&lt;/code&gt; tree, and stage 3 to the &lt;code&gt;$target&lt;/code&gt; tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac1b4287ed9a44af81d40c798f15ea7666d1fc7e" translate="yes" xml:space="preserve">
          <source>Each linked working tree has a private sub-directory in the repository&amp;rsquo;s $GIT_DIR/worktrees directory. The private sub-directory&amp;rsquo;s name is usually the base name of the linked working tree&amp;rsquo;s path, possibly appended with a number to make it unique. For example, when &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; the command &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; creates the linked working tree in &lt;code&gt;/path/other/test-next&lt;/code&gt; and also creates a &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; directory (or &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; if &lt;code&gt;test-next&lt;/code&gt; is already taken).</source>
          <target state="translated">每个链接的工作树在存储库的$ GIT_DIR / worktrees目录中都有一个私有子目录。私有子目录的名称通常是链接的工作树路径的基本名称，可能还会附加一个数字以使其唯一。例如，当 &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; 命令 &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; 创建的链接工作树 &lt;code&gt;/path/other/test-next&lt;/code&gt; ，也创建了一个 &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; 目录（如果已使用 &lt;code&gt;test-next&lt;/code&gt; ,则为 &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="08c05bcbce27635e929ab0aeef0154946c733deb" translate="yes" xml:space="preserve">
          <source>Each linked working tree has a private sub-directory in the repository&amp;rsquo;s &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; directory. The private sub-directory&amp;rsquo;s name is usually the base name of the linked working tree&amp;rsquo;s path, possibly appended with a number to make it unique. For example, when &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; the command &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; creates the linked working tree in &lt;code&gt;/path/other/test-next&lt;/code&gt; and also creates a &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; directory (or &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; if &lt;code&gt;test-next&lt;/code&gt; is already taken).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e13434b85bdba9c36937ef9acd2f33c427adfe8" translate="yes" xml:space="preserve">
          <source>Each of the attribute requirements for the path takes one of these forms:</source>
          <target state="translated">路径的每个属性要求都有以下几种形式。</target>
        </trans-unit>
        <trans-unit id="58398b8104bc9622bb9865f6e7c9793546a9471d" translate="yes" xml:space="preserve">
          <source>Each of the four branches is usually a direct descendant of the one above it.</source>
          <target state="translated">四个分支中的每一个通常都是它上面那个分支的直系子孙。</target>
        </trans-unit>
        <trans-unit id="dfc2dc1cc1f2e4f6e3d7ce6e6191c01415d0880b" translate="yes" xml:space="preserve">
          <source>Each of these options must appear first on the command line.</source>
          <target state="translated">这些选项中的每一个都必须首先出现在命令行中。</target>
        </trans-unit>
        <trans-unit id="79d9036a8f3f011f6caea432d8fa6198deb15d8c" translate="yes" xml:space="preserve">
          <source>Each other line contains a single pattern.</source>
          <target state="translated">其他每一行都包含一个图案。</target>
        </trans-unit>
        <trans-unit id="36e6db0cb81d09d2c644d8a7c4b702648cc38f78" translate="yes" xml:space="preserve">
          <source>Each patch can be applied in order.</source>
          <target state="translated">每个贴片都可以按顺序应用。</target>
        </trans-unit>
        <trans-unit id="6d39c2ae5926cd9b5a6631ab32e0430d3e598f09" translate="yes" xml:space="preserve">
          <source>Each patch includes a single logical change, together with a message explaining the change.</source>
          <target state="translated">每个补丁都包括一个单一的逻辑变化,以及解释该变化的信息。</target>
        </trans-unit>
        <trans-unit id="493d693b4f2b5ea37d0460dc9ff9f76e6d401041" translate="yes" xml:space="preserve">
          <source>Each pattern pair consists of the source side (before the colon) and the destination side (after the colon). The ref to be pushed is determined by finding a match that matches the source side, and where it is pushed is determined by using the destination side.</source>
          <target state="translated">每个模式对由源侧(冒号前)和目的侧(冒号后)组成。要推送的 ref 是通过找到与源侧匹配的匹配项来确定的,而推送的位置是通过目的侧来确定的。</target>
        </trans-unit>
        <trans-unit id="b313cea753099ce8f3968fb8a5c9e65e86c611ac" translate="yes" xml:space="preserve">
          <source>Each pattern pair consists of the source side (before the colon) and the destination side (after the colon). The ref to be pushed is determined by finding a match that matches the source side, and where it is pushed is determined by using the destination side. The rules used to match a ref are the same rules used by &lt;code&gt;git rev-parse&lt;/code&gt; to resolve a symbolic ref name. See &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">每个模式对均由源侧（在冒号之前）和目标侧（在冒号之后）组成。通过查找与源端匹配的匹配项来确定要推送的ref，并通过使用目标端来确定将其推送到何处。用于匹配引用的规则与 &lt;code&gt;git rev-parse&lt;/code&gt; 用于解析符号引用名称的规则相同。参见&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2aa7f4f33bfb7b26b4af691cb7e2c6d52612b8b" translate="yes" xml:space="preserve">
          <source>Each remote helper is expected to support only a subset of commands. The operations a helper supports are declared to Git in the response to the &lt;code&gt;capabilities&lt;/code&gt; command (see COMMANDS, below).</source>
          <target state="translated">期望每个远程帮助程序仅支持命令的子集。在对 &lt;code&gt;capabilities&lt;/code&gt; 命令的响应中，将帮助程序支持的操作声明给Git （请参阅下面的COMMANDS）。</target>
        </trans-unit>
        <trans-unit id="640db855296fc622a8934e713d8f1835acdff3f5" translate="yes" xml:space="preserve">
          <source>Each time a new shared index file is created, the old shared index files are deleted if their modification time is older than what is specified by the splitIndex.sharedIndexExpire config variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">每次创建新的共享索引文件时，如果旧的共享索引文件的修改时间早于splitIndex.sharedIndexExpire配置变量（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）所指定的修改时间，则它们将被删除。</target>
        </trans-unit>
        <trans-unit id="6b67247d73793e579b74a9b09ccf935b5a398f89" translate="yes" xml:space="preserve">
          <source>Each time a superproject update moves a populated submodule (e.g. when switching between commits before and after the move) a stale submodule checkout will remain in the old location and an empty directory will appear in the new location. To populate the submodule again in the new location the user will have to run &quot;git submodule update&quot; afterwards. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. Both steps will be obsolete when recursive submodule update has been implemented.</source>
          <target state="translated">每次超级项目更新移动一个已填充的子模块时(例如在移动前后的提交之间切换时),一个陈旧的子模块签出会留在旧位置,而新位置会出现一个空目录。如果要在新位置重新填充子模块,用户必须在之后运行 &quot;git submodule update&quot;。只有在使用git文件时,删除旧目录才是安全的,否则子模块的历史也会被删除。当实现了递归子模块更新后,这两个步骤都将被淘汰。</target>
        </trans-unit>
        <trans-unit id="70398d4e57fc6de31488380bf7caac1138d58530" translate="yes" xml:space="preserve">
          <source>Each time a superproject update removes a populated submodule (e.g. when switching between commits before and after the removal) a stale submodule checkout will remain in the old location. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. This step will be obsolete when recursive submodule update has been implemented.</source>
          <target state="translated">每次超级项目更新删除一个填充的子模块时(例如在删除前后的提交之间切换时),一个陈旧的子模块签出会保留在旧的位置。只有在使用gitfile的时候,删除旧目录才是安全的,否则子模块的历史也会被删除。当实现了递归子模块更新后,这一步将被淘汰。</target>
        </trans-unit>
        <trans-unit id="49035126eea24f612f322a34d235d8eeac55e17a" translate="yes" xml:space="preserve">
          <source>Each time you resolve the conflicts in a file and update the index:</source>
          <target state="translated">每次解决文件中的冲突并更新索引。</target>
        </trans-unit>
        <trans-unit id="91df855bba63011edb2c56419d0fb8efa1e50e11" translate="yes" xml:space="preserve">
          <source>Earlier we said that trivial merges are done inside &lt;code&gt;git read-tree -m&lt;/code&gt;. For example, if the file did not change from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; or &lt;code&gt;$target&lt;/code&gt;, or if the file changed from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;$target&lt;/code&gt; the same way, obviously the final outcome is what is in &lt;code&gt;HEAD&lt;/code&gt;. What the above example shows is that file &lt;code&gt;hello.c&lt;/code&gt; was changed from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;$target&lt;/code&gt; in a different way. You could resolve this by running your favorite 3-way merge program, e.g. &lt;code&gt;diff3&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, or Git&amp;rsquo;s own merge-file, on the blob objects from these three stages yourself, like this:</source>
          <target state="translated">之前我们说过，琐碎的合并是在 &lt;code&gt;git read-tree -m&lt;/code&gt; 内部完成的。例如，如果文件没有从 &lt;code&gt;$orig&lt;/code&gt; 更改为 &lt;code&gt;HEAD&lt;/code&gt; 或 &lt;code&gt;$target&lt;/code&gt; ，或者文件从 &lt;code&gt;$orig&lt;/code&gt; 更改为 &lt;code&gt;HEAD&lt;/code&gt; ,而 &lt;code&gt;$orig&lt;/code&gt; 更改 &lt;code&gt;$target&lt;/code&gt; ，则最终结果显然是 &lt;code&gt;HEAD&lt;/code&gt; 。什么上面的例子中显示的是该文件 &lt;code&gt;hello.c&lt;/code&gt; 从改变 &lt;code&gt;$orig&lt;/code&gt; 到 &lt;code&gt;HEAD&lt;/code&gt; 和 &lt;code&gt;$orig&lt;/code&gt; 到 &lt;code&gt;$target&lt;/code&gt; 以不同的方式。您可以通过运行您喜欢的3向合并程序来解决此问题，例如 &lt;code&gt;diff3&lt;/code&gt; ， &lt;code&gt;merge&lt;/code&gt; 或Git自己的合并文件，位于您自己来自这三个阶段的blob对象上，如下所示：</target>
        </trans-unit>
        <trans-unit id="cf0ee6adeaeadff98f7e216b0d8eb81b31226098" translate="yes" xml:space="preserve">
          <source>Earlier, we saw that one file under &lt;code&gt;.git/objects/??/&lt;/code&gt; directory is stored for each Git object you create. This representation is efficient to create atomically and safely, but not so convenient to transport over the network. Since Git objects are immutable once they are created, there is a way to optimize the storage by &quot;packing them together&quot;. The command</source>
          <target state="translated">之前，我们看到为您创建的每个Git对象都在 &lt;code&gt;.git/objects/??/&lt;/code&gt; 目录下存储了一个文件。这种表示方式可以有效地原子安全地创建，但是在网络上传输却不那么方便。由于Git对象一旦创建便是不可变的，因此有一种方法可以通过&amp;ldquo;将它们打包在一起&amp;rdquo;来优化存储。命令</target>
        </trans-unit>
        <trans-unit id="b4c8a83331a00582f4030fa5296077717cda7730" translate="yes" xml:space="preserve">
          <source>Ease of use. It is often much simpler to write a binary to text transformation than it is to perform your own diff. In many cases, existing programs can be used as textconv filters (e.g., exif, odt2txt).</source>
          <target state="translated">易用性。编写一个二进制到文本的转换通常比你自己执行diff要简单得多。在许多情况下,现有的程序可以用作文本转换过滤器(例如,exif、odt2txt)。</target>
        </trans-unit>
        <trans-unit id="b4d52eb229c8c557c44ab0035085b989953060f9" translate="yes" xml:space="preserve">
          <source>Easily extendable as capabilities are moved into their own section of the protocol, no longer being hidden behind a NUL byte and limited by the size of a pkt-line</source>
          <target state="translated">当功能被移到协议的自己的部分时,易于扩展,不再被隐藏在NUL字节后面,也不再受限于pkt-line的大小。</target>
        </trans-unit>
        <trans-unit id="c0ecd6c3f25fc4cb4d76566a21fece2ca48f95ab" translate="yes" xml:space="preserve">
          <source>Easy case: The changes are literally the same.</source>
          <target state="translated">简单的案例。字面上的变化是一样的。</target>
        </trans-unit>
        <trans-unit id="d4f35a5d52e75e1ab425158dcb45339db600d3f4" translate="yes" xml:space="preserve">
          <source>Eclipse 3.0, 3.1.2 on MacOSX (see Eclipse CVS Client Notes)</source>
          <target state="translated">MacOSX上的Eclipse 3.0、3.1.2 (见Eclipse CVS客户端说明)</target>
        </trans-unit>
        <trans-unit id="f5e176bd2c2df731632b9ca0ee7983e84b3d8517" translate="yes" xml:space="preserve">
          <source>Eclipse cvs client notes</source>
          <target state="translated">Eclipse cvs 客户端注释</target>
        </trans-unit>
        <trans-unit id="ea0675157801730c96e515d20a6ad02ac765e6d4" translate="yes" xml:space="preserve">
          <source>Edit an object&amp;rsquo;s content interactively. The existing content for &amp;lt;object&amp;gt; is pretty-printed into a temporary file, an editor is launched on the file, and the result is parsed to create a new object of the same type as &amp;lt;object&amp;gt;. A replacement ref is then created to replace &amp;lt;object&amp;gt; with the newly created object. See &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; for details about how the editor will be chosen.</source>
          <target state="translated">交互式编辑对象的内容。&amp;lt;object&amp;gt;的现有内容被漂亮地打印到一个临时文件中，在该文件上启动编辑器，然后解析结果以创建与&amp;lt;object&amp;gt;相同类型的新对象。然后创建替换引用，以将&amp;lt;object&amp;gt;替换为新创建的对象。有关如何选择编辑器的详细信息，请参见&lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f76fc2a41a48ffbf729f7fe389bfe3f0b08de68" translate="yes" xml:space="preserve">
          <source>Edit the commit message before committing to SVN. This is off by default for objects that are commits, and forced on when committing tree objects.</source>
          <target state="translated">在提交到SVN之前编辑提交信息。对于提交的对象,默认情况下是关闭的,当提交树状对象时,则强制开启。</target>
        </trans-unit>
        <trans-unit id="c92b0955a7a67e8bc1f5f7afd177ec4ed55d0e4c" translate="yes" xml:space="preserve">
          <source>Edit the files in place.</source>
          <target state="translated">就地编辑文件。</target>
        </trans-unit>
        <trans-unit id="b87cea5cffa31e45fd50bcd7540894242796f029" translate="yes" xml:space="preserve">
          <source>Edit the notes for a given object (defaults to HEAD).</source>
          <target state="translated">编辑给定对象的注释(默认为HEAD)。</target>
        </trans-unit>
        <trans-unit id="81933d4e997d5f22262236af308c480381855b0f" translate="yes" xml:space="preserve">
          <source>Edit the todo list during an interactive rebase.</source>
          <target state="translated">在交互式重启期间编辑待办事项列表。</target>
        </trans-unit>
        <trans-unit id="f392476dbdf7968fc4726a7173f15cf238dddd46" translate="yes" xml:space="preserve">
          <source>Editing patches</source>
          <target state="translated">编辑补丁</target>
        </trans-unit>
        <trans-unit id="8f25a859269ca51039632dd6bba28fb061cfb8d4" translate="yes" xml:space="preserve">
          <source>Effects</source>
          <target state="translated">Effects</target>
        </trans-unit>
        <trans-unit id="7002bc1d2bcb94f212817ade973f1baffe1d4266" translate="yes" xml:space="preserve">
          <source>Either a &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;, or a &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; together with the dependent &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; and tree objects (i.e. a stored representation of a working tree).</source>
          <target state="translated">一个&lt;a href=&quot;#def_working_tree&quot;&gt;工作树&lt;/a&gt;，或一个&lt;a href=&quot;#def_tree_object&quot;&gt;树对象&lt;/a&gt;以及相关的&lt;a href=&quot;#def_blob_object&quot;&gt;Blob&lt;/a&gt;和树对象（即工作树的存储表示）。</target>
        </trans-unit>
        <trans-unit id="bc0851580574fafe647ac3b5e7bd049ba47eee8d" translate="yes" xml:space="preserve">
          <source>Either the hash or the filename under [URL]/refs/ to pull.</source>
          <target state="translated">拉取[URL]/refs/下的哈希或文件名。</target>
        </trans-unit>
        <trans-unit id="3c055884457fa0453683ceee26bbe41d08beb912" translate="yes" xml:space="preserve">
          <source>Either way, if you have a string of untestable commits, it might happen that the regression you are looking for has been introduced by one of these untestable commits. In this case it&amp;rsquo;s not possible to tell for sure which commit introduced the regression.</source>
          <target state="translated">无论哪种方式，如果您有一串不可测的提交，则可能是您正在寻找的回归是由这些不可测的提交之一引入的。在这种情况下，无法确定是哪个提交引入了回归。</target>
        </trans-unit>
        <trans-unit id="84add5b2952787581cb9a8851eef63d1ec75d22b" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="translated">Email</target>
        </trans-unit>
        <trans-unit id="727400f70d8ff4dd021cd3b46cd8407431accd18" translate="yes" xml:space="preserve">
          <source>Empty commits</source>
          <target state="translated">空的承诺</target>
        </trans-unit>
        <trans-unit id="64c856db8d7087653e88ddbd52d985c5029c26f3" translate="yes" xml:space="preserve">
          <source>Empty context lines that do not have &lt;code&gt;any&lt;/code&gt; whitespace.</source>
          <target state="translated">没有 &lt;code&gt;any&lt;/code&gt; 空格的空上下文行。</target>
        </trans-unit>
        <trans-unit id="bc35de4b332414e34ea66c4e2722d1b3c677ee26" translate="yes" xml:space="preserve">
          <source>Enable &quot;sparse checkout&quot; feature. See &lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout[1]&lt;/a&gt; for more information.</source>
          <target state="translated">启用&amp;ldquo;稀疏签出&amp;rdquo;功能。有关更多信息，请参见&lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1506b425dd0a659b4e3f7dbaad1db76c1920ca2" translate="yes" xml:space="preserve">
          <source>Enable (1) or disable (0) debug output. If enabled, SMTP commands and replies will be printed. Useful to debug TLS connection and authentication problems.</source>
          <target state="translated">启用 (1)或禁用 (0)调试输出。如果启用,将打印SMTP命令和回复。对调试TLS连接和验证问题很有用。</target>
        </trans-unit>
        <trans-unit id="5ca5f9ffb4eef636571b0732ca8e82f4b117bf57" translate="yes" xml:space="preserve">
          <source>Enable Git&amp;rsquo;s password prompt for the SSL certificate. Otherwise OpenSSL will prompt the user, possibly many times, if the certificate or private key is encrypted. Can be overridden by the &lt;code&gt;GIT_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; environment variable.</source>
          <target state="translated">为SSL证书启用Git的密码提示。否则，如果证书或私钥已加密，则OpenSSL可能会多次提示用户。可以被 &lt;code&gt;GIT_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="22af37288ef16d6e96158d900edae0bae2453223" translate="yes" xml:space="preserve">
          <source>Enable Git&amp;rsquo;s password prompt for the proxy SSL certificate. Otherwise OpenSSL will prompt the user, possibly many times, if the certificate or private key is encrypted. Can be overriden by the &lt;code&gt;GIT_PROXY_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202cfbf6c643ccf61c3e6855fb4942a959d7c88c" translate="yes" xml:space="preserve">
          <source>Enable and configure &quot;patches&quot; view, which displays list of commits in email (plain text) output format; see also &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;. The value is the maximum number of patches in a patchset generated in &quot;patches&quot; view. Set the &lt;code&gt;default&lt;/code&gt; field to a list containing single item of or to an empty list to disable patch view, or to a list containing a single negative number to remove any limit. Default value is 16.</source>
          <target state="translated">启用并配置&amp;ldquo;补丁&amp;rdquo;视图，以电子邮件（纯文本）输出格式显示提交列表；另见&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;。该值是在&amp;ldquo;补丁&amp;rdquo;视图中生成的补丁集中最大补丁数。将 &lt;code&gt;default&lt;/code&gt; 字段设置为包含单个项目的列表，或设置为空列表以禁用补丁程序视图，或设置为包含单个负数的列表以消除任何限制。预设值为16。</target>
        </trans-unit>
        <trans-unit id="3ec940cc58a7e0a3ca8323d3832e04ecb527aead" translate="yes" xml:space="preserve">
          <source>Enable and configure the &quot;snapshot&quot; action, which allows user to download a compressed archive of any tree or commit, as produced by &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; and possibly additionally compressed. This can potentially generate high traffic if you have large project.</source>
          <target state="translated">启用并配置&amp;ldquo;快照&amp;rdquo;操作，该操作允许用户下载由&lt;a href=&quot;git-archive&quot;&gt;git-archive [1]生成&lt;/a&gt;并可能附加压缩的任何树或提交的压缩存档。如果您有大型项目，这可能会产生高流量。</target>
        </trans-unit>
        <trans-unit id="875ff7ca114490b100a4ae7597d23eb505e57466" translate="yes" xml:space="preserve">
          <source>Enable and configure the ability to change a common time zone for dates in gitweb output via JavaScript. Dates in gitweb output include authordate and committerdate in &quot;commit&quot;, &quot;commitdiff&quot; and &quot;log&quot; views, and taggerdate in &quot;tag&quot; view. Enabled by default.</source>
          <target state="translated">启用并配置通过 JavaScript 更改 gitweb 输出中的日期的通用时区的功能。gitweb输出的日期包括 &quot;commit&quot;、&quot;commitdiff &quot;和 &quot;log &quot;视图中的authordate和committerdate,以及 &quot;tag &quot;视图中的taggerdate。默认为启用。</target>
        </trans-unit>
        <trans-unit id="e1b8a656580e419265edb3d93e7fbf612f88122b" translate="yes" xml:space="preserve">
          <source>Enable config options that are new to Git, and are being considered for future defaults. Config settings included here may be added or removed with each release, including minor version updates. These settings may have unintended interactions since they are so new. Please enable this setting if you are interested in providing feedback on experimental features. The new default values are:</source>
          <target state="translated">启用 Git 的新配置选项,并考虑将其作为未来的默认值。这里的配置设置可能会在每次发布时被添加或删除,包括小版本更新。由于这些设置太新,可能会产生一些意外的互动。如果您对提供实验性功能的反馈感兴趣,请启用此设置。新的默认值是</target>
        </trans-unit>
        <trans-unit id="8740fb3b16d2502b6a07330a252227f128574417" translate="yes" xml:space="preserve">
          <source>Enable config options that optimize for repos with many files in the working directory. With many files, commands such as &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git checkout&lt;/code&gt; may be slow and these new defaults improve performance:</source>
          <target state="translated">启用可优化回购的配置选项，其中包含工作目录中的许多文件。对于许多文件，诸如 &lt;code&gt;git status&lt;/code&gt; 和 &lt;code&gt;git checkout&lt;/code&gt; 之类的命令可能会很慢，并且这些新的默认设置可提高性能：</target>
        </trans-unit>
        <trans-unit id="b62688a948f16b8896e24589781ecaee64693ffd" translate="yes" xml:space="preserve">
          <source>Enable displaying how much time and how many Git commands it took to generate and display each page in the page footer (at the bottom of page). For example the footer might contain: &quot;This page took 6.53325 seconds and 13 Git commands to generate.&quot; Disabled by default.</source>
          <target state="translated">启用在页面页脚(页面底部)显示每页生成并显示所花的时间和Git命令数量。例如页脚可能包含:&quot;本页面生成耗时6.53325秒,生成13条Git命令。&quot; 默认为禁用。</target>
        </trans-unit>
        <trans-unit id="c9bd131fb11e7d8a575c789c619c56115c835cfc" translate="yes" xml:space="preserve">
          <source>Enable displaying remote heads (remote-tracking branches) in the &quot;heads&quot; list. In most cases the list of remote-tracking branches is an unnecessary internal private detail, and this feature is therefore disabled by default. &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;, which is usually used to browse local repositories, enables and uses this feature.</source>
          <target state="translated">启用在&amp;ldquo;标题&amp;rdquo;列表中显示远程标题（远程跟踪分支）。在大多数情况下，远程跟踪分支列表是不必要的内部私有详细信息，因此默认情况下禁用此功能。&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;（通常用于浏览本地存储库）启用并使用此功能。</target>
        </trans-unit>
        <trans-unit id="39da6c4d119e094eeb647ff45a2f63bf34d04c9c" translate="yes" xml:space="preserve">
          <source>Enable grep search, which lists the files in currently selected tree (directory) containing the given string; see &lt;a href=&quot;git-grep&quot;&gt;git-grep[1]&lt;/a&gt;. This can be potentially CPU-intensive, of course. Enabled by default.</source>
          <target state="translated">启用grep搜索，该搜索将列出当前所选树（目录）中包含给定字符串的文件；参见&lt;a href=&quot;git-grep&quot;&gt;git-grep [1]&lt;/a&gt;。当然，这可能会占用大量CPU资源。默认启用。</target>
        </trans-unit>
        <trans-unit id="393e4a210cdfd96d50c3abf9958899d9c77b22c9" translate="yes" xml:space="preserve">
          <source>Enable more strict checking, namely to catch a file mode recorded with g+w bit set, which was created by older versions of Git. Existing repositories, including the Linux kernel, Git itself, and sparse repository have old objects that triggers this check, but it is recommended to check new projects with this flag.</source>
          <target state="translated">启用更严格的检查,即抓取g+w位设置记录的文件模式,这是由旧版本的Git创建的。现有的仓库,包括 Linux 内核、Git 本身和稀疏仓库都有旧的对象会触发这个检查,但建议用这个标志检查新项目。</target>
        </trans-unit>
        <trans-unit id="8081f1426d8047f2f5c9039fb2b3187c4aed51ad" translate="yes" xml:space="preserve">
          <source>Enable multipart/mixed attachments as the default for &lt;code&gt;format-patch&lt;/code&gt;. The value can also be a double quoted string which will enable attachments as the default and set the value as the boundary. See the --attach option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">启用多部分/混合附件作为 &lt;code&gt;format-patch&lt;/code&gt; 的默认值。该值也可以是双引号字符串，该字符串将使附件成为默认值，并将该值设置为边界。参见&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]中&lt;/a&gt;的--attach选项。</target>
        </trans-unit>
        <trans-unit id="d973b021f64131371542864785f310ed020b9e66" translate="yes" xml:space="preserve">
          <source>Enable or disable files system monitor feature. These options take effect whatever the value of the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">启用或禁用文件系统监视器功能。无论 &lt;code&gt;core.fsmonitor&lt;/code&gt; 配置变量的值如何，这些选项都会生效（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。但是，当更改与配置值不符时，会发出警告，因为配置值将在下次读取索引时生效，这将删除该选项的预期效果。</target>
        </trans-unit>
        <trans-unit id="d83423bb73684fa975c3f77aeba009920792cf88" translate="yes" xml:space="preserve">
          <source>Enable or disable split index mode. If split-index mode is already enabled and &lt;code&gt;--split-index&lt;/code&gt; is given again, all changes in $GIT_DIR/index are pushed back to the shared index file.</source>
          <target state="translated">启用或禁用拆分索引模式。如果已经启用了分割索引模式​​，并且再次给出了 &lt;code&gt;--split-index&lt;/code&gt; ,则$ GIT_DIR / index中的所有更改都将推回到共享索引文件中。</target>
        </trans-unit>
        <trans-unit id="f8b0173e3fdc03c4e03595346f1584e741b798c1" translate="yes" xml:space="preserve">
          <source>Enable or disable untracked cache feature. Please use &lt;code&gt;--test-untracked-cache&lt;/code&gt; before enabling it.</source>
          <target state="translated">启用或禁用未跟踪的缓存功能。启用前请使用 &lt;code&gt;--test-untracked-cache&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d058dbf876c4efd16b9ed5eae486a10be79bb86" translate="yes" xml:space="preserve">
          <source>Enable parallel index preload for operations like &lt;code&gt;git diff&lt;/code&gt;</source>
          <target state="translated">为 &lt;code&gt;git diff&lt;/code&gt; 之类的操作启用并行索引预加载</target>
        </trans-unit>
        <trans-unit id="1aa8a755e195170094ad7c0108b7874b637b96b6" translate="yes" xml:space="preserve">
          <source>Enable showing size of blobs (ordinary files) in a &quot;tree&quot; view, in a separate column, similar to what &lt;code&gt;ls -l&lt;/code&gt; does; see description of &lt;code&gt;-l&lt;/code&gt; option in &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt; manpage. This costs a bit of I/O. Enabled by default.</source>
          <target state="translated">启用在&amp;ldquo;树&amp;rdquo;视图的单独列中显示blob（普通文件）大小的功能，类似于 &lt;code&gt;ls -l&lt;/code&gt; 所做的；请参见&lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt;联机帮助页中的 &lt;code&gt;-l&lt;/code&gt; 选项的说明。这会花费一些I / O。默认启用。</target>
        </trans-unit>
        <trans-unit id="72fa50bb7bb0362a9a5efa2aa6f34941c4906089" translate="yes" xml:space="preserve">
          <source>Enable stricter reference checking by requiring an exact ref path. Aside from returning an error code of 1, it will also print an error message if &lt;code&gt;--quiet&lt;/code&gt; was not specified.</source>
          <target state="translated">通过要求精确的引用路径来启用更严格的引用检查。如果未指定 &lt;code&gt;--quiet&lt;/code&gt; ，则除了返回错误代码1之外，它还会打印一条错误消息。</target>
        </trans-unit>
        <trans-unit id="48730f76cba5f67862630837d3f93d8ce9288066" translate="yes" xml:space="preserve">
          <source>Enable text search, which will list the commits which match author, committer or commit text to a given string; see the description of &lt;code&gt;--author&lt;/code&gt;, &lt;code&gt;--committer&lt;/code&gt; and &lt;code&gt;--grep&lt;/code&gt; options in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; manpage. Enabled by default.</source>
          <target state="translated">启用文本搜索，它将列出与作者，提交者或将文本匹配到给定字符串的提交；看到的描述 &lt;code&gt;--author&lt;/code&gt; ， &lt;code&gt;--committer&lt;/code&gt; 和 &lt;code&gt;--grep&lt;/code&gt; 在选项&lt;a href=&quot;git-log&quot;&gt;GIT-日志[1]&lt;/a&gt;手册页。默认启用。</target>
        </trans-unit>
        <trans-unit id="5bf942f17a0adbd66d5dff03794ede7ed6ce3a03" translate="yes" xml:space="preserve">
          <source>Enable the &quot;blame&quot; and &quot;blame_incremental&quot; blob views, showing for each line the last commit that modified it; see &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. This can be very CPU-intensive and is therefore disabled by default.</source>
          <target state="translated">启用&amp;ldquo; blame&amp;rdquo;和&amp;ldquo; blame_incremental&amp;rdquo; blob视图，为每行显示最后修改它的提交；参见&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;。这可能会占用大量CPU，因此默认情况下处于禁用状态。</target>
        </trans-unit>
        <trans-unit id="d7fc03efc211d064bf3be01f125339a0be59fcba" translate="yes" xml:space="preserve">
          <source>Enable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; setting. If the sparse-checkout file does not exist, then populate it with patterns that match every file in the root directory and no other directories, then will remove all directories tracked by Git. Add patterns to the sparse-checkout file to repopulate the working directory.</source>
          <target state="translated">启用 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 设置。如果稀疏检出文件不存在，则使用与根目录中的每个文件匹配且与其他目录不匹配的模式填充该文件，然后将删除Git跟踪的所有目录。将模式添加到稀疏检出文件以重新填充工作目录。</target>
        </trans-unit>
        <trans-unit id="388296e4f7d314018094f8c18fc5c6de39a494b4" translate="yes" xml:space="preserve">
          <source>Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.</source>
          <target state="translated">启用启发式,移动 diff hunk 的边界,使补丁更容易阅读。这是默认的。</target>
        </trans-unit>
        <trans-unit id="01f1f887420f77509dbb30a6ca88007ca92eded6" translate="yes" xml:space="preserve">
          <source>Enable the reflog. Updates to a ref &amp;lt;ref&amp;gt; is logged to the file &quot;&lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt;&quot;, by appending the new and old SHA-1, the date/time and the reason of the update, but only when the file exists. If this configuration variable is set to &lt;code&gt;true&lt;/code&gt;, missing &quot;&lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt;&quot; file is automatically created for branch heads (i.e. under &lt;code&gt;refs/heads/&lt;/code&gt;), remote refs (i.e. under &lt;code&gt;refs/remotes/&lt;/code&gt;), note refs (i.e. under &lt;code&gt;refs/notes/&lt;/code&gt;), and the symbolic ref &lt;code&gt;HEAD&lt;/code&gt;. If it is set to &lt;code&gt;always&lt;/code&gt;, then a missing reflog is automatically created for any ref under &lt;code&gt;refs/&lt;/code&gt;.</source>
          <target state="translated">启用引用日志。通过附加新旧SHA-1，更新的日期/时间和原因（仅当文件存在时），将对ref &amp;lt;ref&amp;gt;的更新记录到文件&amp;ldquo; &lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt; &amp;rdquo;中。如果此配置变量设置为 &lt;code&gt;true&lt;/code&gt; ，缺失&amp;ldquo; &lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt; &amp;rdquo;文件是为分支头自动创建（即下 &lt;code&gt;refs/heads/&lt;/code&gt; ），远程参考文献（即下 &lt;code&gt;refs/remotes/&lt;/code&gt; ），音符参（即在 &lt;code&gt;refs/notes/&lt;/code&gt; ）和符号ref &lt;code&gt;HEAD&lt;/code&gt; 。如果它被设置为 &lt;code&gt;always&lt;/code&gt; ，那么缺少引用日志自动为下任裁判创建 &lt;code&gt;refs/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b50a25e099857665aa0b9ce95777350330756bcc" translate="yes" xml:space="preserve">
          <source>Enable the so called pickaxe search, which will list the commits that introduced or removed a given string in a file. This can be practical and quite faster alternative to &quot;blame&quot; action, but it is still potentially CPU-intensive. Enabled by default.</source>
          <target state="translated">启用所谓的 &quot;皮卡索搜索&quot;,它将列出在文件中引入或删除某个字符串的提交。这比起 &quot;责备 &quot;操作更实用、更快速,但仍有可能耗费CPU。默认情况下是启用的。</target>
        </trans-unit>
        <trans-unit id="e8928096a1d83fe75290fee4b17a3faa5d2c2864" translate="yes" xml:space="preserve">
          <source>Enable the specified feature. This requires that fast-import supports the specified feature, and aborts if it does not.</source>
          <target state="translated">启用指定的功能。这要求fast-import支持指定的功能,如果不支持,则中止。</target>
        </trans-unit>
        <trans-unit id="cb33ed4fbb60981dda9e34bad99e8fe5205271b1" translate="yes" xml:space="preserve">
          <source>Enable/disable the service site-wide per default. Note that a service disabled site-wide can still be enabled per repository if it is marked overridable and the repository enables the service with a configuration item.</source>
          <target state="translated">根据默认情况在整个站点启用/禁用服务。请注意,如果服务被标记为可覆盖,并且版本库通过配置项启用了服务,那么仍然可以在每个版本库中启用全站点禁用的服务。</target>
        </trans-unit>
        <trans-unit id="35a563959614f6c71c72cc0395ec6a9ebde3235d" translate="yes" xml:space="preserve">
          <source>Enables (or disables) progress messages displayed by the transport helper during a command.</source>
          <target state="translated">启用(或禁用)传输辅助程序在命令期间显示的进度信息。</target>
        </trans-unit>
        <trans-unit id="c889da55fe7b392cff2ceaa7f38c976ee6969838" translate="yes" xml:space="preserve">
          <source>Enables a curl full trace dump of all incoming and outgoing data, including descriptive information, of the git transport protocol. This is similar to doing curl &lt;code&gt;--trace-ascii&lt;/code&gt; on the command line. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ef71c7bfb2fa4d7687d0c6a055c6d9acec70dd" translate="yes" xml:space="preserve">
          <source>Enables a curl full trace dump of all incoming and outgoing data, including descriptive information, of the git transport protocol. This is similar to doing curl &lt;code&gt;--trace-ascii&lt;/code&gt; on the command line. This option overrides setting the &lt;code&gt;GIT_CURL_VERBOSE&lt;/code&gt; environment variable. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">对git传输协议的所有传入和传出数据（包括描述性信息）启用curl完整跟踪转储。这类似于在命令行上执行curl &lt;code&gt;--trace-ascii&lt;/code&gt; 。此选项将覆盖设置 &lt;code&gt;GIT_CURL_VERBOSE&lt;/code&gt; 环境变量。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6691f775d187ea6f64d054b6823e9e86f9c085bf" translate="yes" xml:space="preserve">
          <source>Enables general trace messages, e.g. alias expansion, built-in command execution and external command execution.</source>
          <target state="translated">启用一般的跟踪信息,如别名扩展、内置命令执行和外部命令执行。</target>
        </trans-unit>
        <trans-unit id="e48905b14288617c8ceaa87834665d923c04c051" translate="yes" xml:space="preserve">
          <source>Enables more detailed trace messages from the &quot;trace2&quot; library. Output from &lt;code&gt;GIT_TRACE2&lt;/code&gt; is a simple text-based format for human readability.</source>
          <target state="translated">启用来自&amp;ldquo; trace2&amp;rdquo;库的更详细的跟踪消息。 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 的输出是一种简单的基于文本的格式，易于阅读。</target>
        </trans-unit>
        <trans-unit id="660988c86be3da054f2d2df3321eefbdd55b0999" translate="yes" xml:space="preserve">
          <source>Enables performance related trace messages, e.g. total execution time of each Git command. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">启用与性能相关的跟踪消息，例如，每个Git命令的总执行时间。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc7b8ed816ac9633bd1375cea1e49bf11b8f4cfe" translate="yes" xml:space="preserve">
          <source>Enables the &quot;cone mode&quot; of the sparse checkout feature. When the sparse-checkout file contains a limited set of patterns, then this mode provides significant performance advantages. See &lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout[1]&lt;/a&gt; for more information.</source>
          <target state="translated">启用稀疏签出功能的&amp;ldquo;圆锥模式&amp;rdquo;。当稀疏签出文件包含一组有限的模式时，此模式将提供明显的性能优势。有关更多信息，请参见&lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69a28feccce4c72bcadfb900d39f7f184847d39a" translate="yes" xml:space="preserve">
          <source>Enables trace messages for all accesses to any packs. For each access, the pack file name and an offset in the pack is recorded. This may be helpful for troubleshooting some pack-related performance problems. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">启用对任何包的所有访问的跟踪消息。对于每次访问，都会记录包文件名和包中的偏移量。这可能有助于解决某些与包装有关的性能问题。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="facc11ad57d6672e51f919b154eb028564e3944e" translate="yes" xml:space="preserve">
          <source>Enables trace messages for all packets coming in or out of a given program. This can help with debugging object negotiation or other protocol issues. Tracing is turned off at a packet starting with &quot;PACK&quot; (but see &lt;code&gt;GIT_TRACE_PACKFILE&lt;/code&gt; below). See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">为进出给定程序的所有数据包启用跟踪消息。这可以帮助调试对象协商或其他协议问题。对于以&amp;ldquo; PACK&amp;rdquo;开头的数据包，将关闭跟踪（但请参见下面的 &lt;code&gt;GIT_TRACE_PACKFILE&lt;/code&gt; ）。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="edb9b39606e0f9447b27a5131ddede4062e0f50d" translate="yes" xml:space="preserve">
          <source>Enables trace messages for operations on the ref database. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a96e0b90f936140e14c4f59157281584502b280" translate="yes" xml:space="preserve">
          <source>Enables trace messages for the filesystem monitor extension. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">为文件系统监视器扩展启用跟踪消息。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="226b098ac2b03df2efedb4d6f3177d8a53d1323d" translate="yes" xml:space="preserve">
          <source>Enables trace messages printing the .git, working tree and current working directory after Git has completed its setup phase. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">在Git完成设置阶段后，启用跟踪消息，以打印.git，工作树和当前工作目录。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0876ec8b14060e46110f6e776b65e26631e1613f" translate="yes" xml:space="preserve">
          <source>Enables trace messages that can help debugging fetching / cloning of shallow repositories. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">启用跟踪消息，可以帮助调试浅存储库的获取/克隆。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9d84b12f1c34508f5365e4fa51faae6983f4d76" translate="yes" xml:space="preserve">
          <source>Enables tracing of packfiles sent or received by a given program. Unlike other trace output, this trace is verbatim: no headers, and no quoting of binary data. You almost certainly want to direct into a file (e.g., &lt;code&gt;GIT_TRACE_PACKFILE=/tmp/my.pack&lt;/code&gt;) rather than displaying it on the terminal or mixing it with other trace output.</source>
          <target state="translated">启用对给定程序发送或接收的packfile的跟踪。与其他跟踪输出不同，此跟踪是逐字记录的：没有标题，也没有引用二进制数据。几乎可以肯定，您希望直接导入文件（例如， &lt;code&gt;GIT_TRACE_PACKFILE=/tmp/my.pack&lt;/code&gt; ），而不是在终端上显示该文件或将其与其他跟踪输出混合。</target>
        </trans-unit>
        <trans-unit id="e7a1430764d62a995667824305a6bb53b99cb2fa" translate="yes" xml:space="preserve">
          <source>Enabling a Target</source>
          <target state="translated">启用目标</target>
        </trans-unit>
        <trans-unit id="619b6ac53993b275b163fbd1d47132e1851812f0" translate="yes" xml:space="preserve">
          <source>Encode email headers that have non-ASCII characters with &quot;Q-encoding&quot; (described in RFC 2047) for email transmission. Defaults to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae00f8479c80f28e526371cda478b9f2e76f78a" translate="yes" xml:space="preserve">
          <source>Encode email headers that have non-ASCII characters with &quot;Q-encoding&quot; (described in RFC 2047), instead of outputting the headers verbatim. Defaults to the value of the &lt;code&gt;format.encodeEmailHeaders&lt;/code&gt; configuration variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff218bfdfe647deb6f8afd9e1fb8602500fad3a" translate="yes" xml:space="preserve">
          <source>Encoding to use when displaying logs. (See &lt;code&gt;Discussion&lt;/code&gt; above.) Defaults to the value of &lt;code&gt;i18n.commitEncoding&lt;/code&gt; if set, and UTF-8 otherwise.</source>
          <target state="translated">显示日志时使用的编码。（请参阅上面的 &lt;code&gt;Discussion&lt;/code&gt; 。）如果设置，则默认为 &lt;code&gt;i18n.commitEncoding&lt;/code&gt; 的值，否则为UTF-8。</target>
        </trans-unit>
        <trans-unit id="89269a8275f94980b4ffe877e221e0d466987782" translate="yes" xml:space="preserve">
          <source>End-of-line conversion</source>
          <target state="translated">线端转换</target>
        </trans-unit>
        <trans-unit id="ab7c0d7ed2b514b7971808ab6a9cdbd8fa7e7be5" translate="yes" xml:space="preserve">
          <source>Enhanced option parser</source>
          <target state="translated">增强的选项解析器</target>
        </trans-unit>
        <trans-unit id="d48b2fd91c06d512d371b7025cd11deeb23b34ad" translate="yes" xml:space="preserve">
          <source>Ensure at least &amp;lt;n&amp;gt; lines of surrounding context match before and after each change. When fewer lines of surrounding context exist they all must match. By default no context is ever ignored.</source>
          <target state="translated">在每次更改之前和之后，请确保至少有&amp;lt;n&amp;gt;行周围上下文匹配。当周围环境的行数减少时，它们都必须匹配。默认情况下，不会忽略任何上下文。</target>
        </trans-unit>
        <trans-unit id="40fd8773c6f206a9063f0067c04f352f2f44d8bc" translate="yes" xml:space="preserve">
          <source>Ensure at least &amp;lt;n&amp;gt; lines of surrounding context match before and after each change. When fewer lines of surrounding context exist they all must match. By default no context is ever ignored. Implies --apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6825ec27b2b654ed999d31628f8e31396467a23b" translate="yes" xml:space="preserve">
          <source>Ensure mod_cgi, mod_alias, and mod_env are enabled, set GIT_PROJECT_ROOT (or DocumentRoot) appropriately, and create a ScriptAlias to the CGI:</source>
          <target state="translated">确保mod_cgi、mod_alias和mod_env被启用,适当地设置GIT_PROJECT_ROOT(或DocumentRoot),并为CGI创建一个ScriptAlias。</target>
        </trans-unit>
        <trans-unit id="136727d71b4774df6f61241cd1f96329e996c416" translate="yes" xml:space="preserve">
          <source>Ensure that &lt;code&gt;mod_cgi&lt;/code&gt;, &lt;code&gt;mod_alias&lt;/code&gt;, &lt;code&gt;mod_auth&lt;/code&gt;, &lt;code&gt;mod_setenv&lt;/code&gt; are loaded, then set &lt;code&gt;GIT_PROJECT_ROOT&lt;/code&gt; appropriately and redirect all requests to the CGI:</source>
          <target state="translated">确保已加载 &lt;code&gt;mod_cgi&lt;/code&gt; ， &lt;code&gt;mod_alias&lt;/code&gt; ， &lt;code&gt;mod_auth&lt;/code&gt; ， &lt;code&gt;mod_setenv&lt;/code&gt; ，然后适当设置 &lt;code&gt;GIT_PROJECT_ROOT&lt;/code&gt; 并将所有请求重定向到CGI：</target>
        </trans-unit>
        <trans-unit id="05b99bf62f144f697a8ee2786cac4dbb9ea1f0fb" translate="yes" xml:space="preserve">
          <source>Ensures that a reference name is well formed</source>
          <target state="translated">确保参考名称的形成良好。</target>
        </trans-unit>
        <trans-unit id="ced8b1d7750a47c0481b135a1b95578c79b545a4" translate="yes" xml:space="preserve">
          <source>Ensuring good performance</source>
          <target state="translated">确保良好的业绩</target>
        </trans-unit>
        <trans-unit id="bbdd824923a22a7ee366da56344be9b791387ca5" translate="yes" xml:space="preserve">
          <source>Ensuring reliability</source>
          <target state="translated">确保可靠性</target>
        </trans-unit>
        <trans-unit id="35254b488f033ee2fce6cea7c360bd0f51157448" translate="yes" xml:space="preserve">
          <source>Enter &lt;code&gt;git name-rev&lt;/code&gt;:</source>
          <target state="translated">输入 &lt;code&gt;git name-rev&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="35cd2b0a8df7f89252ec5f994efe80c34ae3bb81" translate="yes" xml:space="preserve">
          <source>Entries that begin with &lt;code&gt;&quot;&lt;/code&gt; (double-quote) will be interpreted as C-style quoted paths, removing leading and trailing double-quotes and respecting backslash escapes. E.g., the value &lt;code&gt;&quot;path-with-\&quot;-and-:-in-it&quot;:vanilla-path&lt;/code&gt; has two paths: &lt;code&gt;path-with-&quot;-and-:-in-it&lt;/code&gt; and &lt;code&gt;vanilla-path&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;&quot;&lt;/code&gt; （双引号）开头的条目将被解释为C样式的带引号的路径，删除前导和尾随的双引号并遵守反斜杠转义符。例如，值 &lt;code&gt;&quot;path-with-\&quot;-and-:-in-it&quot;:vanilla-path&lt;/code&gt; 有两条路径： &lt;code&gt;path-with-&quot;-and-:-in-it&lt;/code&gt; 和 &lt;code&gt;vanilla-path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="8403ba2a4a5aa9baffc30d3d46a39f555141e42f" translate="yes" xml:space="preserve">
          <source>Environment and configuration variables</source>
          <target state="translated">环境和配置变量</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="translated">环境变量</target>
        </trans-unit>
        <trans-unit id="2e9c1d645028b692809462da156b1ceab497759c" translate="yes" xml:space="preserve">
          <source>Environment variables passed to command</source>
          <target state="translated">传递给命令的环境变量</target>
        </trans-unit>
        <trans-unit id="0939f663868ba2e69e812a3d630f787f9c5cfc8e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt;, with &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1 if not given.</source>
          <target state="translated">等效于 &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt; ，如果未给出 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1。</target>
        </trans-unit>
        <trans-unit id="0c3185db11169cc7a29ed7dd80f79aa18ce0f759" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;--word-diff=color&lt;/code&gt; plus (if a regex was specified) &lt;code&gt;--word-diff-regex=&amp;lt;regex&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;--word-diff=color&lt;/code&gt; plus（如果指定了正则表达式）-- &lt;code&gt;--word-diff-regex=&amp;lt;regex&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fce804cbafec5e50fdfe3953fee8d48f776185de" translate="yes" xml:space="preserve">
          <source>Equivalent to passing &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt;. Note that &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; does not need to be the exact branch point of the branches. Example: after rebasing a branch &lt;code&gt;my-topic&lt;/code&gt;, &lt;code&gt;git range-diff my-topic@{u} my-topic@{1} my-topic&lt;/code&gt; would show the differences introduced by the rebase.</source>
          <target state="translated">等效于传递 &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt; 。请注意， &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; 不必是分支的确切分支点。示例：在对分支 &lt;code&gt;my-topic&lt;/code&gt; 重新设置基础之后， &lt;code&gt;git range-diff my-topic@{u} my-topic@{1} my-topic&lt;/code&gt; 将显示重新引入的差异。</target>
        </trans-unit>
        <trans-unit id="fee223c131ae45dd7f0054cc61edf8587521b104" translate="yes" xml:space="preserve">
          <source>Equivalent to passing &lt;code&gt;&amp;lt;rev2&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;rev1&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">等效于传递 &lt;code&gt;&amp;lt;rev2&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;rev1&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9b3a0b879a412ed7b377d180ca1727a3b8f2d6d" translate="yes" xml:space="preserve">
          <source>Error out if the stream ends without a &lt;code&gt;done&lt;/code&gt; command. Without this feature, errors causing the frontend to end abruptly at a convenient point in the stream can go undetected. This may occur, for example, if an import front end dies in mid-operation without emitting SIGTERM or SIGKILL at its subordinate git fast-import instance.</source>
          <target state="translated">如果流在没有 &lt;code&gt;done&lt;/code&gt; 命令的情况下结束，则会出错。如果没有此功能，则导致前端在流中的方便点突然终止的错误可能无法检测到。例如，如果导入前端在操作中死亡而在其下属git fast-import实例中未发出SIGTERM或SIGKILL，则可能发生这种情况。</target>
        </trans-unit>
        <trans-unit id="137e434092ea32c83e7a34f0c9bc0aa62d172e84" translate="yes" xml:space="preserve">
          <source>Especially useful for interoperability with a foreign versioning system.</source>
          <target state="translated">对于与国外版本系统的互操作性特别有用。</target>
        </trans-unit>
        <trans-unit id="058d99599bd9d3348c2826266e98651571ad20e7" translate="yes" xml:space="preserve">
          <source>Evaluates an arbitrary shell command in each checked out submodule. The command has access to the variables $name, $sm_path, $displaypath, $sha1 and $toplevel: $name is the name of the relevant submodule section in &lt;code&gt;.gitmodules&lt;/code&gt;, $sm_path is the path of the submodule as recorded in the immediate superproject, $displaypath contains the relative path from the current working directory to the submodules root directory, $sha1 is the commit as recorded in the immediate superproject, and $toplevel is the absolute path to the top-level of the immediate superproject. Note that to avoid conflicts with &lt;code&gt;$PATH&lt;/code&gt; on Windows, the &lt;code&gt;$path&lt;/code&gt; variable is now a deprecated synonym of &lt;code&gt;$sm_path&lt;/code&gt; variable. Any submodules defined in the superproject but not checked out are ignored by this command. Unless given &lt;code&gt;--quiet&lt;/code&gt;, foreach prints the name of each submodule before evaluating the command. If &lt;code&gt;--recursive&lt;/code&gt; is given, submodules are traversed recursively (i.e. the given shell command is evaluated in nested submodules as well). A non-zero return from the command in any submodule causes the processing to terminate. This can be overridden by adding &lt;code&gt;|| :&lt;/code&gt; to the end of the command.</source>
          <target state="translated">在每个检出的子模块中评估一个任意的shell命令。该命令可以访问变量$ name，$ sm_path，$ displaypath，$ sha1和$ toplevel：$ name是 &lt;code&gt;.gitmodules&lt;/code&gt; 中相关子模块部分的名称，$ sm_path是直接超级项目中记录的子模块的路径，$ displaypath包含从当前工作目录到子模块根目录的相对路径，$ sha1是即时超级项目中记录的提交，而$ toplevel是即时超级项目顶层的绝对路径。请注意，为避免与Windows 上的 &lt;code&gt;$PATH&lt;/code&gt; 冲突，现在 &lt;code&gt;$path&lt;/code&gt; 变量已弃用 &lt;code&gt;$sm_path&lt;/code&gt; 同义词变量。该命令将忽略在超级项目中定义但未检出的所有子模块。除非给出 &lt;code&gt;--quiet&lt;/code&gt; ，否则foreach在评估命令之前会打印每个子模块的名称。如果给出了 &lt;code&gt;--recursive&lt;/code&gt; ，则递归遍历子模块（即，给定的shell命令也在嵌套子模块中求值）。任何子模块中命令的非零返回都会导致处理终止。可以通过添加 &lt;code&gt;|| :&lt;/code&gt; 来覆盖：到命令末尾。</target>
        </trans-unit>
        <trans-unit id="3346640c72369c22dbe8ece1ce186df75f62b7da" translate="yes" xml:space="preserve">
          <source>Even if you don&amp;rsquo;t need to edit files but only want to e.g. rename or remove some and thus can avoid checking out each file (i.e. you can use --index-filter), you still are passing shell snippets for your filters. This means that for every commit, you have to have a prepared git repo where those filters can be run. That&amp;rsquo;s a significant setup.</source>
          <target state="translated">即使您不需要编辑文件，而只想重命名或删除某些文件，从而避免检出每个文件（例如，可以使用--index-filter），您仍将传递shell片段作为过滤器。这意味着对于每次提交，您都必须有一个准备好的git repo，可以在其中运行那些过滤器。这是一个重要的设置。</target>
        </trans-unit>
        <trans-unit id="5eb6ad0af0ebc64a82d836be8d647670a50936f8" translate="yes" xml:space="preserve">
          <source>Even if you hide refs, a client may still be able to steal the target objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">即使您隐藏了引用，客户端也仍然可以通过&lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt;手册页的&amp;ldquo;安全&amp;rdquo;部分中介绍的技术来窃取目标对象。最好将私有数据保存在单独的存储库中。</target>
        </trans-unit>
        <trans-unit id="631b3a432b8ec594fabc393b96af10483ed3b9bf" translate="yes" xml:space="preserve">
          <source>Even if you may have local modifications in your working tree, you can safely say &lt;code&gt;git pull&lt;/code&gt; when you know that the change in the other branch does not overlap with them.</source>
          <target state="translated">即使您在工作树中进行了局部修改，当您知道另一个分支中的更改与它们没有重叠时，也可以放心地说 &lt;code&gt;git pull&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9dc426299074d12c83589e674bb08692f265116" translate="yes" xml:space="preserve">
          <source>Even when version sort is used in &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;, tagnames with the same base version but different suffixes are still sorted lexicographically, resulting e.g. in prerelease tags appearing after the main release (e.g. &quot;1.0-rc1&quot; after &quot;1.0&quot;). This variable can be specified to determine the sorting order of tags with different suffixes.</source>
          <target state="translated">即使在&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]中&lt;/a&gt;使用了版本排序，具有相同基本版本但后缀不同的标记名仍按字典顺序进行排序，从而导致例如在主发行版之后出现预发行版标记（例如，&amp;ldquo; 1.0&amp;rdquo;之后的&amp;ldquo; 1.0-rc1&amp;rdquo;） 。可以指定此变量来确定具有不同后缀的标签的排序顺序。</target>
        </trans-unit>
        <trans-unit id="9e079d1f744d65307fba536fb55c673ed5690ed3" translate="yes" xml:space="preserve">
          <source>Event-Specific Key/Value Pairs</source>
          <target state="translated">事件特定的键/值对</target>
        </trans-unit>
        <trans-unit id="574b5ade849d92dcfbdbf5ca26c3f1b37761f49f" translate="yes" xml:space="preserve">
          <source>Events are written as lines of the form:</source>
          <target state="translated">事件写成行的形式。</target>
        </trans-unit>
        <trans-unit id="af0aec79a3d13a4c4b91dbf7a8bc02d48eb692d6" translate="yes" xml:space="preserve">
          <source>Eventually the conclusion started with:</source>
          <target state="translated">最终结论是:</target>
        </trans-unit>
        <trans-unit id="e1529d50cc2b2be76fa87bc3d3169dd428571183" translate="yes" xml:space="preserve">
          <source>Eventually there will be no more revisions left to inspect, and the command will print out a description of the first bad commit. The reference &lt;code&gt;refs/bisect/bad&lt;/code&gt; will be left pointing at that commit.</source>
          <target state="translated">最终将没有更多的修订需要检查，该命令将打印出第一个错误提交的描述。参考 &lt;code&gt;refs/bisect/bad&lt;/code&gt; 将指向该提交。</target>
        </trans-unit>
        <trans-unit id="33494a61e10c94c6a655dac5cf7ce556eb778f1d" translate="yes" xml:space="preserve">
          <source>Every change in the history of a project is represented by a commit. The &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; command shows the most recent commit on the current branch:</source>
          <target state="translated">项目历史中的每个更改都由提交表示。在&lt;a href=&quot;git-show&quot;&gt;GIT中出现[1]&lt;/a&gt;命令显示最近提交的当前分支：</target>
        </trans-unit>
        <trans-unit id="c0294fb403c28f35bf86f99624f936e70c163f9d" translate="yes" xml:space="preserve">
          <source>Every commit (except the very first commit in a project) also has a parent commit which shows what happened before this commit. Following the chain of parents will eventually take you back to the beginning of the project.</source>
          <target state="translated">每一个提交(除了项目中的第一个提交)都有一个父提交,它显示了这个提交之前发生的事情。沿着父提交的链条,你最终会回到项目的开始。</target>
        </trans-unit>
        <trans-unit id="2fd9540af511da41e4e859d7e772df1cd2e0716c" translate="yes" xml:space="preserve">
          <source>Every commit has a 40-hexdigit id, sometimes called the &quot;object name&quot; or the &quot;SHA-1 id&quot;, shown on the first line of the &lt;code&gt;git show&lt;/code&gt; output. You can usually refer to a commit by a shorter name, such as a tag or a branch name, but this longer name can also be useful. Most importantly, it is a globally unique name for this commit: so if you tell somebody else the object name (for example in email), then you are guaranteed that name will refer to the same commit in their repository that it does in yours (assuming their repository has that commit at all). Since the object name is computed as a hash over the contents of the commit, you are guaranteed that the commit can never change without its name also changing.</source>
          <target state="translated">每个提交都有一个40进制的ID，有时也称为&amp;ldquo;对象名称&amp;rdquo;或&amp;ldquo; SHA-1 ID&amp;rdquo;，显示在 &lt;code&gt;git show&lt;/code&gt; 输出的第一行。通常，您可以使用较短的名称（例如标记或分支名称）来引用提交，但是该较长的名称也很有用。最重要的是，它是此提交的全局唯一名称：因此，如果您告诉其他人对象名称（例如在电子邮件中），则可以确保该名称将引用其存储库中与您自己的存储库相同的提交（假设他们的存储库完全具有该提交）。由于对象名称是作为提交内容上的哈希值计算的，因此可以保证，在提交名称也未更改的情况下，提交将永远不会更改。</target>
        </trans-unit>
        <trans-unit id="2c58cc3c4a4eeeefba12cfd52db7d6b22833ae51" translate="yes" xml:space="preserve">
          <source>Every commit usually has one &quot;parent&quot; commit which points to the previous state of the project:</source>
          <target state="translated">每个提交通常都有一个 &quot;父 &quot;提交,它指向项目的前一个状态。</target>
        </trans-unit>
        <trans-unit id="1a873d3296fdc5740fd2d57065300557ff50e9de" translate="yes" xml:space="preserve">
          <source>Every git repository is marked with a numeric version in the &lt;code&gt;core.repositoryformatversion&lt;/code&gt; key of its &lt;code&gt;config&lt;/code&gt; file. This version specifies the rules for operating on the on-disk repository data. An implementation of git which does not understand a particular version advertised by an on-disk repository MUST NOT operate on that repository; doing so risks not only producing wrong results, but actually losing data.</source>
          <target state="translated">每个git存储库在其 &lt;code&gt;config&lt;/code&gt; 文件的 &lt;code&gt;core.repositoryformatversion&lt;/code&gt; 键中均标记有数字版本。此版本指定了对磁盘存储库数据进行操作的规则。 git的实现不能理解磁盘存储库发布的特定版本，因此不得在该存储库上运行；这样做不仅有可能产生错误的结果，而且还会丢失数据。</target>
        </trans-unit>
        <trans-unit id="62d7b4b8755b9c58dc64c45f9e43e9a1848ebae6" translate="yes" xml:space="preserve">
          <source>Every helper must support the &quot;capabilities&quot; command, which Git uses to determine what other commands the helper will accept. Those other commands can be used to discover and update remote refs, transport objects between the object database and the remote repository, and update the local object store.</source>
          <target state="translated">每个辅助程序都必须支持 &quot;capabilities &quot;命令,Git用它来决定该辅助程序会接受哪些其他命令。这些命令可以用来发现和更新远程 refs,在对象数据库和远程仓库之间传输对象,以及更新本地对象存储。</target>
        </trans-unit>
        <trans-unit id="a5adcecab706a9dd84c1d3eebe8cd1a4069a04b5" translate="yes" xml:space="preserve">
          <source>Every non-overlapping match of the &amp;lt;regex&amp;gt; is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append &lt;code&gt;|[^[:space:]]&lt;/code&gt; to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline.</source>
          <target state="translated">&amp;lt;regex&amp;gt;的每个非重叠匹配都被视为一个单词。这些匹配之间的任何内容都被视为空格，并且为了发现差异而忽略（！）。您可能要在正则表达式后附加 &lt;code&gt;|[^[:space:]]&lt;/code&gt; ，以确保它与所有非空白字符匹配。包含换行符的匹配会在换行符处被静默截断（！）。</target>
        </trans-unit>
        <trans-unit id="ca9e8deab33d39332d7b528ab194c9573c58ac97" translate="yes" xml:space="preserve">
          <source>Every notes change creates a new commit at the specified notes ref. You can therefore inspect the history of the notes by invoking, e.g., &lt;code&gt;git log -p notes/commits&lt;/code&gt;. Currently the commit message only records which operation triggered the update, and the commit authorship is determined according to the usual rules (see &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;). These details may change in the future.</source>
          <target state="translated">每次注释更改都会在指定的注释引用处创建一个新提交。因此，您可以通过调用检查注释的历史记录，例如 &lt;code&gt;git log -p notes/commits&lt;/code&gt; 。当前，提交消息仅记录哪个操作触发了更新，并且提交作者身份是根据通常的规则确定的（请参阅&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;）。这些细节将来可能会更改。</target>
        </trans-unit>
        <trans-unit id="5bfad9a034d5ed29730f0b4fba66efb6b1249b9d" translate="yes" xml:space="preserve">
          <source>Every once in a while have your frontend emit a &lt;code&gt;progress&lt;/code&gt; message to fast-import. The contents of the messages are entirely free-form, so one suggestion would be to output the current month and year each time the current commit date moves into the next month. Your users will feel better knowing how much of the data stream has been processed.</source>
          <target state="translated">偶尔让您的前端发出 &lt;code&gt;progress&lt;/code&gt; 消息以快速导入。消息的内容完全是自由格式，因此建议每当当前提交日期移至下个月时，输出当前月份和年份。了解多少数据流已被处理，您的用户会感觉更好。</target>
        </trans-unit>
        <trans-unit id="cda48ad1074123130b527f02f3f1db8c4fd5c129" translate="yes" xml:space="preserve">
          <source>Every once in a while, &lt;code&gt;git repack&lt;/code&gt; the public repository. Go back to step 5. and continue working.</source>
          <target state="translated">&lt;code&gt;git repack&lt;/code&gt; 偶尔会重新打包公共存储库。返回第5步，继续工作。</target>
        </trans-unit>
        <trans-unit id="0196a37f323e9613bd5e5c6dc6db74a2907c6a83" translate="yes" xml:space="preserve">
          <source>Every time a client connects, first run an external command specified by the &amp;lt;path&amp;gt; with service name (e.g. &quot;upload-pack&quot;), path to the repository, hostname (%H), canonical hostname (%CH), IP address (%IP), and TCP port (%P) as its command-line arguments. The external command can decide to decline the service by exiting with a non-zero status (or to allow it by exiting with a zero status). It can also look at the $REMOTE_ADDR and &lt;code&gt;$REMOTE_PORT&lt;/code&gt; environment variables to learn about the requestor when making this decision.</source>
          <target state="translated">每次客户端连接时，首先运行由&amp;lt;path&amp;gt;指定的外部命令，该命令带有服务名称（例如&amp;ldquo; upload-pack&amp;rdquo;），存储库的路径，主机名（％H），规范主机名（％CH），IP地址（ ％IP）和TCP端口（％P）作为其命令行参数。外部命令可以决定通过以非零状态退出来拒绝服务（或通过以零状态退出来允许服务）。它还可以查看$ REMOTE_ADDR和 &lt;code&gt;$REMOTE_PORT&lt;/code&gt; 环境变量，以在做出此决定时了解请求者。</target>
        </trans-unit>
        <trans-unit id="ed1e82e85b3b43f7a452c7545f1946734ba8fe78" translate="yes" xml:space="preserve">
          <source>Everyday Git</source>
          <target state="translated">每天的Git</target>
        </trans-unit>
        <trans-unit id="30edee05f0b86fdef0d1b80bced0b054568a2749" translate="yes" xml:space="preserve">
          <source>Everyday Git With 20 Commands Or So</source>
          <target state="translated">20条左右的日常Git命令</target>
        </trans-unit>
        <trans-unit id="0043a64d3fef8a7a23f6cd840b45f8af10f67f75" translate="yes" xml:space="preserve">
          <source>Exact byte count format</source>
          <target state="translated">准确的字节数格式</target>
        </trans-unit>
        <trans-unit id="6e07117d26445f4c876a2dd689294f11cef857f4" translate="yes" xml:space="preserve">
          <source>Examining an old version without creating a new branch</source>
          <target state="translated">在不创建新分支的情况下检查旧版本。</target>
        </trans-unit>
        <trans-unit id="d496fa33f8661db7b0850d74bbd80c109526f113" translate="yes" xml:space="preserve">
          <source>Examining branches from a remote repository</source>
          <target state="translated">从远程仓库检查分支</target>
        </trans-unit>
        <trans-unit id="bb504595062729729e7244c3229ce860c38e6b76" translate="yes" xml:space="preserve">
          <source>Examining dangling objects</source>
          <target state="translated">检查悬空物体</target>
        </trans-unit>
        <trans-unit id="9cb0f2fbccfd2e1df3b3fea66d90520dda3d9cf1" translate="yes" xml:space="preserve">
          <source>Examining the data</source>
          <target state="translated">审查数据</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="cfd85acb33cc1367c953b61c1f0a7ad60c2565a2" translate="yes" xml:space="preserve">
          <source>Example 1: Your history contains commits by two authors, Jane and Joe, whose names appear in the repository under several forms:</source>
          <target state="translated">例1:你的历史记录中包含了两位作者Jane和Joe的提交,他们的名字以多种形式出现在版本库中。</target>
        </trans-unit>
        <trans-unit id="aa58f391e50840be9e94b87f72faa5f731cb5766" translate="yes" xml:space="preserve">
          <source>Example 2: Your repository contains commits from the following authors:</source>
          <target state="translated">例2:你的版本库包含了以下作者的提交。</target>
        </trans-unit>
        <trans-unit id="8a76cea78511b0d3032b5011d701b256e4fa824c" translate="yes" xml:space="preserve">
          <source>Example contents:</source>
          <target state="translated">内容示例:</target>
        </trans-unit>
        <trans-unit id="ee2fa80210fe959342ddb79b523484b1b7a07d33" translate="yes" xml:space="preserve">
          <source>Example to exclude everything except a specific directory &lt;code&gt;foo/bar&lt;/code&gt; (note the &lt;code&gt;/*&lt;/code&gt; - without the slash, the wildcard would also exclude everything within &lt;code&gt;foo/bar&lt;/code&gt;):</source>
          <target state="translated">排除特定目录 &lt;code&gt;foo/bar&lt;/code&gt; 以外的所有内容的示例（请注意 &lt;code&gt;/*&lt;/code&gt; -不带斜杠，通配符还将排除 &lt;code&gt;foo/bar&lt;/code&gt; 内的所有内容）：</target>
        </trans-unit>
        <trans-unit id="59e08af9047abc909e804faec8919301def86320" translate="yes" xml:space="preserve">
          <source>Example trace2 api usage</source>
          <target state="translated">trace2 api使用示例</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="523ae6b1873ceced0f776c362dc256ed64902255" translate="yes" xml:space="preserve">
          <source>Example: If you know that there was some test case for &lt;code&gt;git bundle&lt;/code&gt;, but do not remember where it was (yes, you &lt;code&gt;could&lt;/code&gt;&lt;code&gt;git grep bundle t/&lt;/code&gt;, but that does not illustrate the point!):</source>
          <target state="translated">示例：如果您知道 &lt;code&gt;git bundle&lt;/code&gt; 有一些测试用例，但不记得它在哪里（是的，您 &lt;code&gt;could&lt;/code&gt; &lt;code&gt;git grep bundle t/&lt;/code&gt; ，但这不能说明问题！）：</target>
        </trans-unit>
        <trans-unit id="14e4d3109673cecf5094a599bce7b8cb418a458c" translate="yes" xml:space="preserve">
          <source>Example: Let commits &lt;code&gt;1--2&lt;/code&gt; be the first iteration of a patch series and &lt;code&gt;A--C&lt;/code&gt; the second iteration. Let&amp;rsquo;s assume that &lt;code&gt;A&lt;/code&gt; is a cherry-pick of &lt;code&gt;2,&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; is a cherry-pick of &lt;code&gt;1&lt;/code&gt; but with a small modification (say, a fixed typo). Visualize the commits as a bipartite graph:</source>
          <target state="translated">示例：提交 &lt;code&gt;1--2&lt;/code&gt; 是补丁系列的第一次迭代，而 &lt;code&gt;A--C&lt;/code&gt; 是第二次迭代。让我们假设 &lt;code&gt;A&lt;/code&gt; 是樱桃挑 &lt;code&gt;2,&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 是樱桃挑 &lt;code&gt;1&lt;/code&gt; 但是具有小的修改（比方说，一个固定的错字）。将提交可视化为二部图：</target>
        </trans-unit>
        <trans-unit id="d3bad2d15f343f55dc9f681daca1b6f3326d18b3" translate="yes" xml:space="preserve">
          <source>Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: &lt;code&gt;--dirstat=files,10,cumulative&lt;/code&gt;.</source>
          <target state="translated">示例：以下内容将对更改的文件进行计数，同时忽略目录少于更改的文件总量的10％，并在父目录中累积子目录计数：-- &lt;code&gt;--dirstat=files,10,cumulative&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5998a18b5c87282a79f47b763c8725aa5e8349e" translate="yes" xml:space="preserve">
          <source>Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: &lt;code&gt;files,10,cumulative&lt;/code&gt;.</source>
          <target state="translated">示例：以下内容将对更改的文件进行计数，同时忽略目录少于更改的文件总量的10％，并在父目录中累积子目录计数： &lt;code&gt;files,10,cumulative&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7fe9add2c66b1dd7342bec4baea68d566885937" translate="yes" xml:space="preserve">
          <source>Example: let&amp;rsquo;s say I had renamed &lt;code&gt;commit.c&lt;/code&gt; to &lt;code&gt;git-commit.c&lt;/code&gt;, and I had done an &lt;code&gt;update-index&lt;/code&gt; to make that effective in the index file. &lt;code&gt;git diff-files&lt;/code&gt; wouldn&amp;rsquo;t show anything at all, since the index file matches my working directory. But doing a &lt;code&gt;git diff-index&lt;/code&gt; does:</source>
          <target state="translated">示例：假设我已将 &lt;code&gt;commit.c&lt;/code&gt; 重命名为 &lt;code&gt;git-commit.c&lt;/code&gt; ，并且我做了一个 &lt;code&gt;update-index&lt;/code&gt; 以使其在索引文件中生效。 &lt;code&gt;git diff-files&lt;/code&gt; 根本不显示任何内容，因为索引文件与我的工作目录匹配。但是做一个 &lt;code&gt;git diff-index&lt;/code&gt; 可以：</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="22540b4db15515332cef1b1a56998eebfeba111a" translate="yes" xml:space="preserve">
          <source>Examples for &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;--cc&lt;/code&gt; without &lt;code&gt;--combined-all-paths&lt;/code&gt;:</source>
          <target state="translated">不带 &lt;code&gt;--combined-all-paths&lt;/code&gt; 的 &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;--cc&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="6ba2b2f11f2e1285e022c78a54e28e01334ece54" translate="yes" xml:space="preserve">
          <source>Examples when &lt;code&gt;--combined-all-paths&lt;/code&gt; added to either &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;--cc&lt;/code&gt;:</source>
          <target state="translated">当将实施例 &lt;code&gt;--combined-all-paths&lt;/code&gt; 添加到任 &lt;code&gt;-c&lt;/code&gt; 或 &lt;code&gt;--cc&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b280d2c89a83a2bacb63527574e5853bea86f936" translate="yes" xml:space="preserve">
          <source>Examples.</source>
          <target state="translated">Examples.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="24d0d5f830ca936a2b1158c4418847e58a17c132" translate="yes" xml:space="preserve">
          <source>Except for the &lt;code&gt;simple&lt;/code&gt; variant, command-line parameters are likely to change as git gains new features.</source>
          <target state="translated">除了 &lt;code&gt;simple&lt;/code&gt; 变体，命令行参数可能会随着git获得新功能而改变。</target>
        </trans-unit>
        <trans-unit id="16cb9d6dc5634fc561d2d614f979976dfee73770" translate="yes" xml:space="preserve">
          <source>Except in a fast-forward merge (see above), the branches to be merged must be tied together by a merge commit that has both of them as its parents.</source>
          <target state="translated">除了在快进合并中(见上文),要合并的分支必须通过合并提交将它们都作为父分支绑在一起。</target>
        </trans-unit>
        <trans-unit id="262c2a4eb81a10a2c9efd3343c2ae85fe92bbd6e" translate="yes" xml:space="preserve">
          <source>Exclude commits that are reachable from &amp;lt;rev&amp;gt; (i.e. &amp;lt;rev&amp;gt; and its ancestors).</source>
          <target state="translated">排除可从&amp;lt;rev&amp;gt;访问的提交（即&amp;lt;rev&amp;gt;及其祖先）。</target>
        </trans-unit>
        <trans-unit id="f270c263f13543cd4c2b3020f92a691a85883aa7" translate="yes" xml:space="preserve">
          <source>Exclude patterns</source>
          <target state="translated">排除模式</target>
        </trans-unit>
        <trans-unit id="87263b3bb52abcdab4a719253ddba1eca4b803f6" translate="yes" xml:space="preserve">
          <source>Exclude selected depot paths when cloning or syncing.</source>
          <target state="translated">克隆或同步时排除所选的仓库路径。</target>
        </trans-unit>
        <trans-unit id="80be5859c8610b0a7e5a0e2227ba09cb8e75bd2e" translate="yes" xml:space="preserve">
          <source>Exclude the given pack from repacking. This is the equivalent of having &lt;code&gt;.keep&lt;/code&gt; file on the pack. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; is the pack file name without leading directory (e.g. &lt;code&gt;pack-123.pack&lt;/code&gt;). The option could be specified multiple times to keep multiple packs.</source>
          <target state="translated">将给定的包装排除在重新包装之外。这相当于在包装上包含 &lt;code&gt;.keep&lt;/code&gt; 文件。 &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; 是没有前导目录的包文件名（例如 &lt;code&gt;pack-123.pack&lt;/code&gt; ）。可以多次指定该选项以保留多个包装。</target>
        </trans-unit>
        <trans-unit id="c21ad96ce2991b5c76c93826f8c1c709d756ef00" translate="yes" xml:space="preserve">
          <source>Exclude the specified patterns from the log decorations. This is similar to the &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; command-line option, but the config option can be overridden by the &lt;code&gt;--decorate-refs&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f719c666cee23f0f1f956fb1a3762ec3484afe81" translate="yes" xml:space="preserve">
          <source>Existing trailers are extracted from the input message by looking for a group of one or more lines that (i) is all trailers, or (ii) contains at least one Git-generated or user-configured trailer and consists of at least 25% trailers. The group must be preceded by one or more empty (or whitespace-only) lines. The group must either be at the end of the message or be the last non-whitespace lines before a line that starts with &lt;code&gt;---&lt;/code&gt; (followed by a space or the end of the line). Such three minus signs start the patch part of the message. See also &lt;code&gt;--no-divider&lt;/code&gt; below.</source>
          <target state="translated">通过查找一组以下一条或多条行来从输入消息中提取现有的预告片：（i）是所有预告片，或（ii）包含至少一个Git生成或用户配置的预告片，并且由至少25％的预告片组成。该组之前必须有一个或多个空行（或仅空白行）。该组必须在消息的末尾，或者是以 &lt;code&gt;---&lt;/code&gt; 开头的行之前的最后一个非空白行（后跟空格或行末）。这三个减号开始消息的补丁部分。另请参见下面的 &lt;code&gt;--no-divider&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3460174eb1c6ec5b3dd3ca9e87848d068de28a1" translate="yes" xml:space="preserve">
          <source>Exit code between 128 and 255 are special to &quot;git bisect run&quot;. They make it stop immediately the bisection process. This is useful for example if the command passed takes too long to complete, because you can kill it with a signal and it will stop the bisection process.</source>
          <target state="translated">128 和 255 之间的退出代码是 &quot;git bisect run &quot;的专用代码。它们会让它立即停止二分法进程。这很有用,比如说,如果传递的命令需要很长时间才能完成,你可以用一个信号来杀死它,它就会停止二分法进程。</target>
        </trans-unit>
        <trans-unit id="1de8b457f24c5f9f27dc6145c115a0b05b79738e" translate="yes" xml:space="preserve">
          <source>Exit difftool if the invoked diff tool returns a non-zero exit status.</source>
          <target state="translated">如果调用的diff工具返回非零的退出状态,则退出difftool。</target>
        </trans-unit>
        <trans-unit id="105ec316e78b2e21f4200658aebb690c6bfce1c8" translate="yes" xml:space="preserve">
          <source>Exit status</source>
          <target state="translated">退出状态</target>
        </trans-unit>
        <trans-unit id="3a152e1aa09a1f7c436eafcd44ff191b58dde03b" translate="yes" xml:space="preserve">
          <source>Exit with a zero status even if no files matched.</source>
          <target state="translated">即使没有匹配的文件,也以零状态退出。</target>
        </trans-unit>
        <trans-unit id="f661c1461c19e28f4ca3bd981e37f108a510e5f9" translate="yes" xml:space="preserve">
          <source>Exit with status &quot;2&quot; when no matching refs are found in the remote repository. Usually the command exits with status &quot;0&quot; to indicate it successfully talked with the remote repository, whether it found any matching refs.</source>
          <target state="translated">当在远程仓库中没有找到匹配的参考文献时,以状态 &quot;2 &quot;退出。通常情况下,无论是否找到匹配的参考文献,命令都会以状态 &quot;0 &quot;退出,表示成功地与远程仓库对话。</target>
        </trans-unit>
        <trans-unit id="a5a799b0a561590f135d49ee5ebae00be685efb3" translate="yes" xml:space="preserve">
          <source>Exit with zero status if &amp;lt;object&amp;gt; exists and is a valid object. If &amp;lt;object&amp;gt; is of an invalid format exit with non-zero and emits an error on stderr.</source>
          <target state="translated">如果&amp;lt;object&amp;gt;存在并且是有效对象，则以零状态退出。如果&amp;lt;object&amp;gt;的格式无效，则退出非零值，并在stderr上发出错误。</target>
        </trans-unit>
        <trans-unit id="a4fd2157951095e7b5d26b7c3906810fced8fee9" translate="yes" xml:space="preserve">
          <source>Expand the URL of the given remote repository taking into account any &quot;url.&amp;lt;base&amp;gt;.insteadOf&quot; config setting (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) and exit without talking to the remote.</source>
          <target state="translated">考虑任何&amp;ldquo; url。&amp;lt;base&amp;gt; .insteadOf&amp;rdquo;配置设置（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;），展开给定远程存储库的URL，然后不与远程对话进行退出。</target>
        </trans-unit>
        <trans-unit id="2cc1aba644e1cb9b53414cf05c3ac97f0df75a06" translate="yes" xml:space="preserve">
          <source>Expected behavior</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a1b2399131b1d56f52c1e5725ea0754c8c3b25" translate="yes" xml:space="preserve">
          <source>Experimental. If set, clients will attempt to communicate with a server using the specified protocol version. If unset, no attempt will be made by the client to communicate using a particular protocol version, this results in protocol version 0 being used. Supported versions:</source>
          <target state="translated">实验性的,如果设置了,客户机将尝试使用指定的协议版本与服务器通信。如果设置,客户端将尝试使用指定的协议版本与服务器进行通信。如果未设置,客户端将不尝试使用特定的协议版本进行通信,这将导致协议版本0被使用。支持的版本。</target>
        </trans-unit>
        <trans-unit id="374e58867af910990ca1f09ab8f9576e68a9b14e" translate="yes" xml:space="preserve">
          <source>Experimental; for internal use only. Can attempt to connect to a remote server for communication using git&amp;rsquo;s wire-protocol version 2. See the documentation for the stateless-connect command for more information.</source>
          <target state="translated">实验；仅限内部使用。可以尝试使用git的线协议版本2连接到远程服务器进行通信。有关更多信息，请参阅stateless-connect命令的文档。</target>
        </trans-unit>
        <trans-unit id="a6c1ea190613127e3c33180eee19de027a289612" translate="yes" xml:space="preserve">
          <source>Experimental; for internal use only. Connects to the given remote service for communication using git&amp;rsquo;s wire-protocol version 2. Valid replies to this command are empty line (connection established), &lt;code&gt;fallback&lt;/code&gt; (no smart transport support, fall back to dumb transports) and just exiting with error message printed (can&amp;rsquo;t connect, don&amp;rsquo;t bother trying to fall back). After line feed terminating the positive (empty) response, the output of the service starts. Messages (both request and response) must consist of zero or more PKT-LINEs, terminating in a flush packet. Response messages will then have a response end packet after the flush packet to indicate the end of a response. The client must not expect the server to store any state in between request-response pairs. After the connection ends, the remote helper exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed48ec751df29bb5c7b56db740a48bfdffd6f47" translate="yes" xml:space="preserve">
          <source>Experimental; for internal use only. Connects to the given remote service for communication using git&amp;rsquo;s wire-protocol version 2. Valid replies to this command are empty line (connection established), &lt;code&gt;fallback&lt;/code&gt; (no smart transport support, fall back to dumb transports) and just exiting with error message printed (can&amp;rsquo;t connect, don&amp;rsquo;t bother trying to fall back). After line feed terminating the positive (empty) response, the output of the service starts. Messages (both request and response) must consist of zero or more PKT-LINEs, terminating in a flush packet. The client must not expect the server to store any state in between request-response pairs. After the connection ends, the remote helper exits.</source>
          <target state="translated">实验；仅限内部使用。使用git的线协议版本2连接到给定的远程服务以进行通信。对此命令的有效答复是空行（建立连接）， &lt;code&gt;fallback&lt;/code&gt; （不支持智能传输，回退到哑传输）并且仅退出并显示错误消息（无法连接，也不必费心尝试回退）。在换行符终止肯定（空）响应之后，服务的输出开始。消息（请求和响应）必须由零个或多个PKT-LINE组成，并以刷新数据包终止。客户端不得期望服务器在请求-响应对之间存储任何状态。连接结束后，远程帮助程序将退出。</target>
        </trans-unit>
        <trans-unit id="f42570a67193591ebd77042c9107ccd33737edfb" translate="yes" xml:space="preserve">
          <source>Expert users may consider scheduling their own maintenance tasks using a different schedule than is available through &lt;code&gt;git maintenance start&lt;/code&gt; and Git configuration options. These users should be aware of the object database lock and how concurrent &lt;code&gt;git maintenance run&lt;/code&gt; commands behave. Further, the &lt;code&gt;git gc&lt;/code&gt; command should not be combined with &lt;code&gt;git maintenance run&lt;/code&gt; commands. &lt;code&gt;git gc&lt;/code&gt; modifies the object database but does not take the lock in the same way as &lt;code&gt;git maintenance run&lt;/code&gt;. If possible, use &lt;code&gt;git maintenance run --task=gc&lt;/code&gt; instead of &lt;code&gt;git gc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e024c1b1cf5dfc23f1661897286cc082f5684cef" translate="yes" xml:space="preserve">
          <source>Expire all reflogs with &lt;code&gt;git reflog expire --expire=now --all&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;git reflog expire --expire=now --all&lt;/code&gt; 所有reflog过期-expire = now --all。</target>
        </trans-unit>
        <trans-unit id="4f38f9dff86033ea204fa903651e0d6603ef28dd" translate="yes" xml:space="preserve">
          <source>Explicitly allow or ban the object filter corresponding to &lt;code&gt;&amp;lt;filter&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;filter&amp;gt;&lt;/code&gt; may be one of: &lt;code&gt;blob:none&lt;/code&gt;, &lt;code&gt;blob:limit&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;sparse:oid&lt;/code&gt;, or &lt;code&gt;combine&lt;/code&gt;. If using combined filters, both &lt;code&gt;combine&lt;/code&gt; and all of the nested filter kinds must be allowed. Defaults to &lt;code&gt;uploadpackfilter.allow&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee5da57f58adf9c1ddf8dd03613cf7957a586adf" translate="yes" xml:space="preserve">
          <source>Exploring git history</source>
          <target state="translated">探索git历史</target>
        </trans-unit>
        <trans-unit id="89032b84259ca753da6ee3335cc874eda5aea88c" translate="yes" xml:space="preserve">
          <source>Exploring history</source>
          <target state="translated">探索历史</target>
        </trans-unit>
        <trans-unit id="9594b6cd33e22cedcea0b51e30d878456e8b0103" translate="yes" xml:space="preserve">
          <source>Export Git tags to p4 labels, as per --export-labels.</source>
          <target state="translated">根据--export-labels,将Git标签导出为p4标签。</target>
        </trans-unit>
        <trans-unit id="1d5637309048195a7021fdbec654e04c3399ceec" translate="yes" xml:space="preserve">
          <source>Export a single commit to a CVS checkout</source>
          <target state="translated">导出一个单一的提交到CVS签出。</target>
        </trans-unit>
        <trans-unit id="3b1e75b4d51f1271061fcd403a0829e4ee2dbe12" translate="yes" xml:space="preserve">
          <source>Export files with a prefix</source>
          <target state="translated">导出文件前缀为</target>
        </trans-unit>
        <trans-unit id="265e5cf875ec82b17c2d01a82792a32a43a95b55" translate="yes" xml:space="preserve">
          <source>Export tags from Git as p4 labels. Tags found in Git are applied to the perforce working directory.</source>
          <target state="translated">将Git中的标签导出为p4标签。在Git中找到的标签会应用到perforce工作目录中。</target>
        </trans-unit>
        <trans-unit id="e1e5965077094d7c4756e516413e72a854f313c9" translate="yes" xml:space="preserve">
          <source>Exporting a Git repository via the Git protocol</source>
          <target state="translated">通过Git协议导出Git仓库。</target>
        </trans-unit>
        <trans-unit id="70581f8681dac905a7c1fddd025df98d77759bfd" translate="yes" xml:space="preserve">
          <source>Exporting a git repository via HTTP</source>
          <target state="translated">通过HTTP导出git仓库。</target>
        </trans-unit>
        <trans-unit id="7d0c2b669436b3c66b28c30bf0f8b2f1227f2bfb" translate="yes" xml:space="preserve">
          <source>Exports a commit from Git to a CVS checkout, making it easier to merge patches from a Git repository into a CVS repository.</source>
          <target state="translated">将 Git 中的提交导出到 CVS 签出,使合并 Git 仓库中的补丁到 CVS 仓库变得更加容易。</target>
        </trans-unit>
        <trans-unit id="91d81689bc4c223caafef827873bd7159612ae71" translate="yes" xml:space="preserve">
          <source>External Systems</source>
          <target state="translated">外部系统</target>
        </trans-unit>
        <trans-unit id="fa9abe3df3ff3676c618be0248e4529ceae9c936" translate="yes" xml:space="preserve">
          <source>External data format</source>
          <target state="translated">外部数据格式</target>
        </trans-unit>
        <trans-unit id="0b01e11ac46c849a71c428abcd94e12009d5387f" translate="yes" xml:space="preserve">
          <source>Extract all commits that lead to &lt;code&gt;origin&lt;/code&gt; since the inception of the project:</source>
          <target state="translated">提取自项目开始以来所有导致 &lt;code&gt;origin&lt;/code&gt; 提交：</target>
        </trans-unit>
        <trans-unit id="86dd39e46e8ada53c01392c7b98857ff781b5490" translate="yes" xml:space="preserve">
          <source>Extract all commits which are in the current branch but not in the origin branch:</source>
          <target state="translated">提取当前分支中的所有提交,但不在原始分支中。</target>
        </trans-unit>
        <trans-unit id="293a4ac8183e30cb22a3c912e62cea8f83a17a45" translate="yes" xml:space="preserve">
          <source>Extract commit ID from an archive created using git-archive</source>
          <target state="translated">从使用git-archive创建的存档中提取提交ID。</target>
        </trans-unit>
        <trans-unit id="e52c75685be818f69a594f72535500e2b5f0de7d" translate="yes" xml:space="preserve">
          <source>Extract commits between revisions R1 and R2, and apply them on top of the current branch using &lt;code&gt;git am&lt;/code&gt; to cherry-pick them:</source>
          <target state="translated">提取修订版R1和R2之间的提交，并使用 &lt;code&gt;git am&lt;/code&gt; 将它们应用于当前分支的顶部以挑选它们：</target>
        </trans-unit>
        <trans-unit id="a8d5387dbff833fee6e262477f3c484440daa076" translate="yes" xml:space="preserve">
          <source>Extract the last commit as a patch, and add a &lt;code&gt;Cc&lt;/code&gt; and a &lt;code&gt;Reviewed-by&lt;/code&gt; trailer to it:</source>
          <target state="translated">将最后一次提交提取为补丁，并向其中添加 &lt;code&gt;Cc&lt;/code&gt; 和&amp;ldquo; &lt;code&gt;Reviewed-by&lt;/code&gt; 预告片：</target>
        </trans-unit>
        <trans-unit id="d9851ec1c9a62576efac72204eb04797ad73e77a" translate="yes" xml:space="preserve">
          <source>Extract three topmost commits from the current branch and format them as e-mailable patches:</source>
          <target state="translated">从当前分支中提取三个最重要的提交,并将其格式化为可发送邮件的补丁。</target>
        </trans-unit>
        <trans-unit id="849870ce78e05c63608a62580dff149aaa2767a8" translate="yes" xml:space="preserve">
          <source>Extracted diagnostics</source>
          <target state="translated">提取的诊断方法</target>
        </trans-unit>
        <trans-unit id="fd728d82ed551d8e8658407681eee58615e4b172" translate="yes" xml:space="preserve">
          <source>Extracts patch and authorship from a single e-mail message</source>
          <target state="translated">从单一的电子邮件信息中提取补丁和作者身份。</target>
        </trans-unit>
        <trans-unit id="77dbd3520a3a25fa2f64b3a79e8cdd2c5b438dfc" translate="yes" xml:space="preserve">
          <source>False by default.</source>
          <target state="translated">默认为False。</target>
        </trans-unit>
        <trans-unit id="8f5880afd2dba5ba402b936eb6b908e040c6c17a" translate="yes" xml:space="preserve">
          <source>Fast-forward merge</source>
          <target state="translated">快进合并</target>
        </trans-unit>
        <trans-unit id="235360a9581b02e6b66f950074d19d23f01883c5" translate="yes" xml:space="preserve">
          <source>Fast-forward merges</source>
          <target state="translated">快进合并</target>
        </trans-unit>
        <trans-unit id="4b4c24663902945e814f463b99629f081662828a" translate="yes" xml:space="preserve">
          <source>Features in &lt;code&gt;%feature&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;%feature&lt;/code&gt; features中的功能</target>
        </trans-unit>
        <trans-unit id="ac7a3c81a6bcc5d5ecdbb8a42e39a3cabf204420" translate="yes" xml:space="preserve">
          <source>Fetch &amp;lt;n&amp;gt; log entries per request when scanning Subversion history. The default is 100. For very large Subversion repositories, larger values may be needed for &lt;code&gt;clone&lt;/code&gt;/&lt;code&gt;fetch&lt;/code&gt; to complete in reasonable time. But overly large values may lead to higher memory usage and request timeouts.</source>
          <target state="translated">扫描Subversion历史记录时，每个请求获取&amp;lt;n&amp;gt;个日志条目。默认值为100。对于很大的Subversion存储库，可能需要更大的值才能在合理的时间内完成 &lt;code&gt;clone&lt;/code&gt; / &lt;code&gt;fetch&lt;/code&gt; 。但是太大的值可能导致更高的内存使用率和请求超时。</target>
        </trans-unit>
        <trans-unit id="5fa9cbd39c84571e7bd481863d7516ff6663aa26" translate="yes" xml:space="preserve">
          <source>Fetch a &quot;thin&quot; pack, which records objects in deltified form based on objects not included in the pack to reduce network traffic.</source>
          <target state="translated">取一个 &quot;瘦 &quot;包,根据包中未包含的对象,以deltified的形式记录对象,以减少网络流量。</target>
        </trans-unit>
        <trans-unit id="bfa61173eb5ea4c62442430cdd5a0f9a2ccdc304" translate="yes" xml:space="preserve">
          <source>Fetch a branch from a different repository, and give it a new name in your repository:</source>
          <target state="translated">从不同的版本库中获取一个分支,并在你的版本库中给它一个新的名字。</target>
        </trans-unit>
        <trans-unit id="5f0a6423762963194f97ca1e3c9e8131a33fa3bd" translate="yes" xml:space="preserve">
          <source>Fetch a branch in a different Git repository, then merge into the current branch:</source>
          <target state="translated">在另一个 Git 仓库中获取一个分支,然后合并到当前分支。</target>
        </trans-unit>
        <trans-unit id="4b2c92720b4e036e2e3a513a4ac4888b092fd45b" translate="yes" xml:space="preserve">
          <source>Fetch all remote refs.</source>
          <target state="translated">获取所有远程参考资料。</target>
        </trans-unit>
        <trans-unit id="fc6f62670a87982450c7fd1465c966b498d51b73" translate="yes" xml:space="preserve">
          <source>Fetch all remotes.</source>
          <target state="translated">获取所有遥控器。</target>
        </trans-unit>
        <trans-unit id="7176a82579f2b775ede7e6b5698f625105e5e80d" translate="yes" xml:space="preserve">
          <source>Fetch all tags from the remote (i.e., fetch remote tags &lt;code&gt;refs/tags/*&lt;/code&gt; into local tags with the same name), in addition to whatever else would otherwise be fetched. Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see &lt;code&gt;--prune&lt;/code&gt;).</source>
          <target state="translated">从远程获取所有标签（即，将远程标签 &lt;code&gt;refs/tags/*&lt;/code&gt; 提取到具有相同名称的本地标签中），以及其他可能会获取的内容。即使使用--prune，单独使用此选项也不会对标签进行修剪（尽管如果标签也是显式 &lt;code&gt;--prune&lt;/code&gt; 的目标，标签也可能会被修剪；请参阅--prune）。</target>
        </trans-unit>
        <trans-unit id="24eb114caf72bd86613f02567ef244ced32c67f3" translate="yes" xml:space="preserve">
          <source>Fetch branches and/or tags (collectively, &quot;refs&quot;) from one or more other repositories, along with the objects necessary to complete their histories. Remote-tracking branches are updated (see the description of &amp;lt;refspec&amp;gt; below for ways to control this behavior).</source>
          <target state="translated">从一个或多个其他存储库中获取分支和/或标签（统称为&amp;ldquo; refs&amp;rdquo;），以及完成其历史记录所需的对象。远程跟踪分支已更新（有关控制此行为的方法，请参见下面的&amp;lt;refspec&amp;gt;描述）。</target>
        </trans-unit>
        <trans-unit id="31082e75ce46d9d1d50a3e2e4d3442657ed8677f" translate="yes" xml:space="preserve">
          <source>Fetch from and integrate with another repository or a local branch</source>
          <target state="translated">从另一个存储库或本地分支中获取并整合。</target>
        </trans-unit>
        <trans-unit id="31bd9486b123aa2097f6934aa8fc09cb0582f241" translate="yes" xml:space="preserve">
          <source>Fetch master, using file descriptor #17 to communicate with git-upload-pack.</source>
          <target state="translated">获取master,使用文件描述符#17与git-upload-pack通信。</target>
        </trans-unit>
        <trans-unit id="c7b7a55dc86420061c3ee2c8e313312034e265da" translate="yes" xml:space="preserve">
          <source>Fetch only from the SVN parent of the current HEAD.</source>
          <target state="translated">只从当前HEAD的SVN父节点获取。</target>
        </trans-unit>
        <trans-unit id="ab869fa62e8a09f8f5c922fc9c36375323cdbbc8" translate="yes" xml:space="preserve">
          <source>Fetch unfetched revisions from the Subversion remote we are tracking. The name of the [svn-remote &quot;&amp;hellip;​&quot;] section in the $GIT_DIR/config file may be specified as an optional command-line argument.</source>
          <target state="translated">从我们正在跟踪的Subversion远程中获取未获取的修订。$ GIT_DIR / config文件中[svn-remote&amp;ldquo;&amp;hellip;&amp;rdquo;&amp;ldquo;]节的名称可以指定为可选的命令行参数。</target>
        </trans-unit>
        <trans-unit id="280e77f3e0aa84ca742f26ca190cb5692edeefd2" translate="yes" xml:space="preserve">
          <source>Fetch updates for remotes or remote groups in the repository as defined by &lt;code&gt;remotes.&amp;lt;group&amp;gt;&lt;/code&gt;. If neither group nor remote is specified on the command line, the configuration parameter remotes.default will be used; if remotes.default is not defined, all remotes which do not have the configuration parameter &lt;code&gt;remote.&amp;lt;name&amp;gt;.skipDefaultUpdate&lt;/code&gt; set to true will be updated. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a003694d110886a95c99728ccaa08a956586a4" translate="yes" xml:space="preserve">
          <source>Fetch updates for remotes or remote groups in the repository as defined by remotes.&amp;lt;group&amp;gt;. If neither group nor remote is specified on the command line, the configuration parameter remotes.default will be used; if remotes.default is not defined, all remotes which do not have the configuration parameter remote.&amp;lt;name&amp;gt;.skipDefaultUpdate set to true will be updated. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">按照remotes。&amp;lt;group&amp;gt;的定义，获取存储库中的远程服务器或远程组的更新。如果在命令行上未指定group或remote，则将使用配置参数remotes.default；如果未定义remotes.default，则将更新所有未将配置参数remote。&amp;lt;name&amp;gt; .skipDefaultUpdate设置为true的远程。（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="82e98a6b98be0542f3ca46bd6c66454d11bde6bb" translate="yes" xml:space="preserve">
          <source>Fetches the given object, writing the necessary objects to the database. Fetch commands are sent in a batch, one per line, terminated with a blank line. Outputs a single blank line when all fetch commands in the same batch are complete. Only objects which were reported in the output of &lt;code&gt;list&lt;/code&gt; with a sha1 may be fetched this way.</source>
          <target state="translated">提取给定的对象，将必要的对象写入数据库。提取命令以批处理方式发送，每行一个，以空行终止。当同一批中的所有提取命令完成时，输出单个空白行。只有用sha1 在 &lt;code&gt;list&lt;/code&gt; 的输出中报告的对象才可以这种方式获取。</target>
        </trans-unit>
        <trans-unit id="5e512ef616863b90580db01bc69e67097028beb3" translate="yes" xml:space="preserve">
          <source>Fetching a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; means to get the branch&amp;rsquo;s &lt;a href=&quot;#def_head_ref&quot;&gt;head ref&lt;/a&gt; from a remote &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;, to find out which objects are missing from the local &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt;, and to get them, too. See also &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">提取&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;意味着从远程&lt;a href=&quot;#def_repository&quot;&gt;存储库&lt;/a&gt;获取分支的&lt;a href=&quot;#def_head_ref&quot;&gt;head ref&lt;/a&gt;，从本地&lt;a href=&quot;#def_object_database&quot;&gt;对象数据库中&lt;/a&gt;找出哪些对象丢失，并且也要获取它们。另见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca528f4260a5f0ff38dd8302ddb33ede05c8ee7e" translate="yes" xml:space="preserve">
          <source>Fetching branches from other repositories</source>
          <target state="translated">从其他资源库中获取分支。</target>
        </trans-unit>
        <trans-unit id="38fdecc5037849cb76e9ff10175400ab8d8520f4" translate="yes" xml:space="preserve">
          <source>Fetching from a remote repository is done by, unsurprisingly, &lt;code&gt;git fetch&lt;/code&gt;:</source>
          <target state="translated">毫不奇怪，从远程存储库中获取是通过 &lt;code&gt;git fetch&lt;/code&gt; 完成的：</target>
        </trans-unit>
        <trans-unit id="66837c163f00048d36bcb5882cef29f3589ed957" translate="yes" xml:space="preserve">
          <source>Fetching individual branches</source>
          <target state="translated">获取单个分支</target>
        </trans-unit>
        <trans-unit id="95fb769cdd33ccd5fcde15b12c59c0228df81279" translate="yes" xml:space="preserve">
          <source>Field names</source>
          <target state="translated">外地名称</target>
        </trans-unit>
        <trans-unit id="7d4e1fd5661dae539542971bb6b2fc728d599c94" translate="yes" xml:space="preserve">
          <source>Fields that have name-email-date tuple as its value (&lt;code&gt;author&lt;/code&gt;, &lt;code&gt;committer&lt;/code&gt;, and &lt;code&gt;tagger&lt;/code&gt;) can be suffixed with &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, and &lt;code&gt;date&lt;/code&gt; to extract the named component.</source>
          <target state="translated">可以将name-email-date元组作为其值的字段（ &lt;code&gt;author&lt;/code&gt; ， &lt;code&gt;committer&lt;/code&gt; 和 &lt;code&gt;tagger&lt;/code&gt; ）后缀 &lt;code&gt;name&lt;/code&gt; ， &lt;code&gt;email&lt;/code&gt; 和 &lt;code&gt;date&lt;/code&gt; ,以提取命名的组件。</target>
        </trans-unit>
        <trans-unit id="f890c334357c63fe5c4a4300d447bac89c08dc17" translate="yes" xml:space="preserve">
          <source>Fields that have name-email-date tuple as its value (&lt;code&gt;author&lt;/code&gt;, &lt;code&gt;committer&lt;/code&gt;, and &lt;code&gt;tagger&lt;/code&gt;) can be suffixed with &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, and &lt;code&gt;date&lt;/code&gt; to extract the named component. For email fields (&lt;code&gt;authoremail&lt;/code&gt;, &lt;code&gt;committeremail&lt;/code&gt; and &lt;code&gt;taggeremail&lt;/code&gt;), &lt;code&gt;:trim&lt;/code&gt; can be appended to get the email without angle brackets, and &lt;code&gt;:localpart&lt;/code&gt; to get the part before the &lt;code&gt;@&lt;/code&gt; symbol out of the trimmed email.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed2ff2065be5f4efd23916d9b5c024804bb05ec6" translate="yes" xml:space="preserve">
          <source>Fields use modified URI encoding, defined in RFC 3986, section 2.1 (Percent-Encoding), or rather &quot;Query string encoding&quot; (see &lt;a href=&quot;https://en.wikipedia.org/wiki/Query_string#URL_encoding&quot;&gt;https://en.wikipedia.org/wiki/Query_string#URL_encoding&lt;/a&gt;), the difference being that SP (&quot; &quot;) can be encoded as &quot;+&quot; (and therefore &quot;+&quot; has to be also percent-encoded).</source>
          <target state="translated">字段使用RFC 3986第2.1节（百分比编码）中定义的经过修改的URI编码，或者更确切地说是&amp;ldquo;查询字符串编码&amp;rdquo;（请参阅&lt;a href=&quot;https://en.wikipedia.org/wiki/Query_string#URL_encoding&quot;&gt;https://en.wikipedia.org/wiki/Query_string#URL_encoding&lt;/a&gt;），区别在于SP （&amp;ldquo;&amp;rdquo;）可以编码为&amp;ldquo; +&amp;rdquo;（因此，&amp;ldquo; +&amp;rdquo;也必须进行百分比编码）。</target>
        </trans-unit>
        <trans-unit id="ff9cc1a6f5bb5a91d014bd56871d8a7e6dedf925" translate="yes" xml:space="preserve">
          <source>Fighting regressions overview</source>
          <target state="translated">打击倒退现象概述</target>
        </trans-unit>
        <trans-unit id="dc286ffc3d263eab0659e5254ed6cbdfe1ed4661" translate="yes" xml:space="preserve">
          <source>Figuring out why this works is left as an exercise to the (advanced) student. The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt;, and &lt;a href=&quot;git-hash-object&quot;&gt;git-hash-object[1]&lt;/a&gt; man pages may prove helpful.</source>
          <target state="translated">弄清楚为什么这样做有效，这是（高级）学生的一项练习。在&lt;a href=&quot;git-log&quot;&gt;git的日志[1] &lt;/a&gt;，&lt;a href=&quot;git-diff-tree&quot;&gt;混帐的Diff-树[1] &lt;/a&gt;，并&lt;a href=&quot;git-hash-object&quot;&gt;与git -哈希对象[1]&lt;/a&gt;手册页可以证明是有益的。</target>
        </trans-unit>
        <trans-unit id="39b2ed94cef5d6961eea0620d66a925578f2f283" translate="yes" xml:space="preserve">
          <source>File containing the SSL certificate when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_CERT&lt;/code&gt; environment variable.</source>
          <target state="translated">提取或通过HTTPS推送时包含SSL证书的文件。可以被 &lt;code&gt;GIT_SSL_CERT&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="e3b34071a7a6143f1cfbfe18d8122a378b6725a7" translate="yes" xml:space="preserve">
          <source>File containing the SSL private key when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_KEY&lt;/code&gt; environment variable.</source>
          <target state="translated">提取或通过HTTPS推送时包含SSL私钥的文件。可以被 &lt;code&gt;GIT_SSL_KEY&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="a25f7e6a9a15db1a7bb16a1513a308705fbf008c" translate="yes" xml:space="preserve">
          <source>File containing the certificates to verify the peer with when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_CAINFO&lt;/code&gt; environment variable.</source>
          <target state="translated">包含用于在对HTTPS进行获取或推送时验证对等方的证书的文件。可以被 &lt;code&gt;GIT_SSL_CAINFO&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="51de61b9fb1649e39093ab80c2a7df2f9e16643a" translate="yes" xml:space="preserve">
          <source>File globbing matches across directory boundaries. Thus, given two directories &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;d2&lt;/code&gt;, there is a difference between using &lt;code&gt;git rm 'd*'&lt;/code&gt; and &lt;code&gt;git rm 'd/*'&lt;/code&gt;, as the former will also remove all of directory &lt;code&gt;d2&lt;/code&gt;.</source>
          <target state="translated">文件遍历跨目录边界匹配。因此，在给定两个目录 &lt;code&gt;d&lt;/code&gt; 和 &lt;code&gt;d2&lt;/code&gt; 的情况下，使用 &lt;code&gt;git rm 'd*'&lt;/code&gt; 和 &lt;code&gt;git rm 'd/*'&lt;/code&gt; 存在区别，因为前者还将删除所有目录 &lt;code&gt;d2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46bdca067f191e47ac236c4a9946147313edeadf" translate="yes" xml:space="preserve">
          <source>File inclusion (&lt;code&gt;:include: /path/name&lt;/code&gt;) is not supported.</source>
          <target state="translated">不支持文件包含（ &lt;code&gt;:include: /path/name&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0052ebd08e3dda2e68d8ee7b082b7c890d6ddeef" translate="yes" xml:space="preserve">
          <source>File indicating how to order files within a diff. See the &lt;code&gt;-O&lt;/code&gt; option to &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; for details. If &lt;code&gt;diff.orderFile&lt;/code&gt; is a relative pathname, it is treated as relative to the top of the working tree.</source>
          <target state="translated">指示如何在差异内排序文件的文件。有关详细信息，请参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;的 &lt;code&gt;-O&lt;/code&gt; 选项。如果 &lt;code&gt;diff.orderFile&lt;/code&gt; 是相对路径名，则将其视为相对于工作树顶部的路径。</target>
        </trans-unit>
        <trans-unit id="f2b61a4d1705fa3305542b48c5c1ffd38b30200f" translate="yes" xml:space="preserve">
          <source>File modes are printed as 6-digit octal numbers including the file type and file permission bits.</source>
          <target state="translated">文件模式以6位八进制数字打印,包括文件类型和文件权限位。</target>
        </trans-unit>
        <trans-unit id="cd4c7b960aaa326dfff2bf746e515a16b2b5bd4d" translate="yes" xml:space="preserve">
          <source>File system monitor</source>
          <target state="translated">文件系统监控</target>
        </trans-unit>
        <trans-unit id="dab1e8f60ab6cd6f09a76739b1f40f880fb79310" translate="yes" xml:space="preserve">
          <source>File to use for (filename extension based) guessing of MIME types before trying &lt;code&gt;/etc/mime.types&lt;/code&gt;. &lt;strong&gt;NOTE&lt;/strong&gt; that this path, if relative, is taken as relative to the current Git repository, not to CGI script. If unset, only &lt;code&gt;/etc/mime.types&lt;/code&gt; is used (if present on filesystem). If no mimetypes file is found, mimetype guessing based on extension of file is disabled. Unset by default.</source>
          <target state="translated">尝试 &lt;code&gt;/etc/mime.types&lt;/code&gt; 之前用于MIME类型猜测（基于文件扩展名）的文件。&lt;strong&gt;注意&lt;/strong&gt;，该路径（如果是相对路径）被视为相对于当前Git存储库，而不是相对于CGI脚本。如果未设置，则仅使用 &lt;code&gt;/etc/mime.types&lt;/code&gt; （如果存在于文件系统上）。如果未找到mimetypes文件，则将禁用基于文件扩展名的mimetype猜测。默认情况下未设置。</target>
        </trans-unit>
        <trans-unit id="f045415cfa170f304a990874fe0966e6d4eacafb" translate="yes" xml:space="preserve">
          <source>File with repository URL (used for clone and fetch), one per line. Displayed in the project summary page. You can use multiple-valued &lt;code&gt;gitweb.url&lt;/code&gt; repository configuration variable for that, but the file takes precedence.</source>
          <target state="translated">带有存储库URL（用于克隆和提取）的文件，每行一个。显示在项目摘要页面中。您可以 &lt;code&gt;gitweb.url&lt;/code&gt; 使用多值gitweb.url存储库配置变量，但文件优先。</target>
        </trans-unit>
        <trans-unit id="f73380191ad1f1caa70019147dbb81cb74dd0fbd" translate="yes" xml:space="preserve">
          <source>File/directory structure</source>
          <target state="translated">文件/目录结构</target>
        </trans-unit>
        <trans-unit id="ee97d026e695edaa3af17191656d312a0a7a2ccb" translate="yes" xml:space="preserve">
          <source>Filenames with spaces are often mishandled by shell snippets since they cause problems for shell pipelines. Not everyone is familiar with find -print0, xargs -0, git-ls-files -z, etc. Even people who are familiar with these may assume such flags are not relevant because someone else renamed any such files in their repo back before the person doing the filtering joined the project. And often, even those familiar with handling arguments with spaces may not do so just because they aren&amp;rsquo;t in the mindset of thinking about everything that could possibly go wrong.</source>
          <target state="translated">带空格的文件名通常会被shell片段错误处理，因为它们会引起shell管道问题。并非每个人都熟悉find -print0，xargs -0，git-ls-files -z等。即使是熟悉这些内容的人也可能会认为这样的标记是不相关的，因为其他人在回购文件之前将其重命名为此类文件。过滤人员加入了该项目。通常，即使是那些熟悉使用空格处理参数的人，也可能不会这样做，因为他们不在考虑可能出错的所有事物的思维方式上。</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="669b1abdd74168ff79423d155c9ddb7e43a80b6e" translate="yes" xml:space="preserve">
          <source>Files (and pointers to subtrees) within active trees require 52 or 64 bytes (32/64 bit platforms) per entry. To conserve space, file and tree names are pooled in a common string table, allowing the filename &amp;ldquo;Makefile&amp;rdquo; to use just 16 bytes (after including the string header overhead) no matter how many times it occurs within the project.</source>
          <target state="translated">活动树中的文件（和指向子树的指针）每个条目需要52或64个字节（32/64位平台）。为了节省空间，文件名和树名被合并在一个公共的字符串表中，无论文件在项目中出现了多少次，文件名&amp;ldquo; Makefile&amp;rdquo;仅使用16个字节（包括字符串头文件的开销）。</target>
        </trans-unit>
        <trans-unit id="94bbb76c1352043c45a00df324ef04fea70e6730" translate="yes" xml:space="preserve">
          <source>Files and directories in the template directory whose name do not start with a dot will be copied to the &lt;code&gt;$GIT_DIR&lt;/code&gt; after it is created.</source>
          <target state="translated">模板目录中名称不以点开头的文件和目录将在创建后复制到 &lt;code&gt;$GIT_DIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1270c9a81ec2853fddc0c884f8ccb1e8a45b97e" translate="yes" xml:space="preserve">
          <source>Files and directories with the attribute &lt;code&gt;export-ignore&lt;/code&gt; won&amp;rsquo;t be added to archive files.</source>
          <target state="translated">具有 &lt;code&gt;export-ignore&lt;/code&gt; 属性的文件和目录不会添加到存档文件中。</target>
        </trans-unit>
        <trans-unit id="e3974c4c3ce398cf177c9471660017bb110038df" translate="yes" xml:space="preserve">
          <source>Files and directories with the attribute export-ignore won&amp;rsquo;t be added to archive files. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">具有export-ignore属性的文件和目录不会添加到存档文件中。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7b0ec5c5be81a4a3b161d0317a98cc9a7a62cb3" translate="yes" xml:space="preserve">
          <source>Files larger than this size are stored deflated, without attempting delta compression. Storing large files without delta compression avoids excessive memory usage, at the slight expense of increased disk usage. Additionally files larger than this size are always treated as binary.</source>
          <target state="translated">大于此大小的文件将被放气存储,而不会尝试进行delta压缩。存储大文件时不进行delta压缩,可以避免过度使用内存,但会增加磁盘的使用量。此外,大于此大小的文件总是被视为二进制文件。</target>
        </trans-unit>
        <trans-unit id="b57b0d88e9fd775cd564cc119a3989093d68ff8d" translate="yes" xml:space="preserve">
          <source>Files to act on. Note that files beginning with &lt;code&gt;.&lt;/code&gt; are discarded. This includes &lt;code&gt;./file&lt;/code&gt; and &lt;code&gt;dir/./file&lt;/code&gt;. If you don&amp;rsquo;t want this, then use cleaner names. The same applies to directories ending &lt;code&gt;/&lt;/code&gt; and paths with &lt;code&gt;//&lt;/code&gt;</source>
          <target state="translated">要执行的文件。请注意，以开头的文件 &lt;code&gt;.&lt;/code&gt; 被丢弃。这包括 &lt;code&gt;./file&lt;/code&gt; 和 &lt;code&gt;dir/./file&lt;/code&gt; 。如果您不想这样做，请使用更干净的名称。这同样适用于以 &lt;code&gt;/&lt;/code&gt; 结尾的目录和以 &lt;code&gt;//&lt;/code&gt; 结尾的路径</target>
        </trans-unit>
        <trans-unit id="a229bb6156d5f90b453ca5e0ca33977f1a3e6a8a" translate="yes" xml:space="preserve">
          <source>Files to add content from. Fileglobs (e.g. &lt;code&gt;*.c&lt;/code&gt;) can be given to add all matching files. Also a leading directory name (e.g. &lt;code&gt;dir&lt;/code&gt; to add &lt;code&gt;dir/file1&lt;/code&gt; and &lt;code&gt;dir/file2&lt;/code&gt;) can be given to update the index to match the current state of the directory as a whole (e.g. specifying &lt;code&gt;dir&lt;/code&gt; will record not just a file &lt;code&gt;dir/file1&lt;/code&gt; modified in the working tree, a file &lt;code&gt;dir/file2&lt;/code&gt; added to the working tree, but also a file &lt;code&gt;dir/file3&lt;/code&gt; removed from the working tree). Note that older versions of Git used to ignore removed files; use &lt;code&gt;--no-all&lt;/code&gt; option if you want to add modified or new files but ignore removed ones.</source>
          <target state="translated">要添加内容的文件。可以指定Fileglob（例如 &lt;code&gt;*.c&lt;/code&gt; ）来添加所有匹配的文件。另外一家领先的目录名称（例如 &lt;code&gt;dir&lt;/code&gt; 添加 &lt;code&gt;dir/file1&lt;/code&gt; 和 &lt;code&gt;dir/file2&lt;/code&gt; ）可以提供给更新索引的目录的当前状态匹配作为一个整体（例如指定 &lt;code&gt;dir&lt;/code&gt; 会记录不只是一个文件 &lt;code&gt;dir/file1&lt;/code&gt; 修改在工作树中，将文件 &lt;code&gt;dir/file2&lt;/code&gt; 添加到工作树中，而且还将文件 &lt;code&gt;dir/file3&lt;/code&gt; 从工作树中删除）。请注意，旧版的Git曾经忽略已删除的文件。如果要添加修改的文件或新文件，但忽略已删除的文件，请使用 &lt;code&gt;--no-all&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="965ffdf35ae99a80180c99419426ec2062c992e9" translate="yes" xml:space="preserve">
          <source>Files to remove. A leading directory name (e.g. &lt;code&gt;dir&lt;/code&gt; to remove &lt;code&gt;dir/file1&lt;/code&gt; and &lt;code&gt;dir/file2&lt;/code&gt;) can be given to remove all files in the directory, and recursively all sub-directories, but this requires the &lt;code&gt;-r&lt;/code&gt; option to be explicitly given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fcfbd1668d25020111102295bf825ad36cd4ad7" translate="yes" xml:space="preserve">
          <source>Files to remove. Fileglobs (e.g. &lt;code&gt;*.c&lt;/code&gt;) can be given to remove all matching files. If you want Git to expand file glob characters, you may need to shell-escape them. A leading directory name (e.g. &lt;code&gt;dir&lt;/code&gt; to remove &lt;code&gt;dir/file1&lt;/code&gt; and &lt;code&gt;dir/file2&lt;/code&gt;) can be given to remove all files in the directory, and recursively all sub-directories, but this requires the &lt;code&gt;-r&lt;/code&gt; option to be explicitly given.</source>
          <target state="translated">要删除的文件。可以指定Fileglob（例如 &lt;code&gt;*.c&lt;/code&gt; ）来删除所有匹配的文件。如果您希望Git扩展文件Glob字符，则可能需要对它们进行脱壳。可以指定一个领先的目录名（例如 &lt;code&gt;dir&lt;/code&gt; 来删除 &lt;code&gt;dir/file1&lt;/code&gt; 和 &lt;code&gt;dir/file2&lt;/code&gt; ）来删除目录中的所有文件，以及递归地删除所有子目录，但这需要显式地指定 &lt;code&gt;-r&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="d69266d087a66debaeaa16301b1f83a323ef3a05" translate="yes" xml:space="preserve">
          <source>Files to show. If no files are given all files which match the other specified criteria are shown.</source>
          <target state="translated">要显示的文件。如果没有给定文件,则显示所有符合其他指定条件的文件。</target>
        </trans-unit>
        <trans-unit id="94b61f142196a44a91e5065c7d0adcb5cad7dae3" translate="yes" xml:space="preserve">
          <source>Files with conflicts are marked specially in the index, so until you resolve the problem and update the index, &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; will fail:</source>
          <target state="translated">有冲突的文件在索引中特别标记，因此在解决问题并更新索引之前，&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;将失败：</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="1cf100e1097311bd9759a52dc063dba54a0c3fc0" translate="yes" xml:space="preserve">
          <source>Finalize an in-progress &lt;code&gt;git notes merge&lt;/code&gt;. Use this option when you have resolved the conflicts that &lt;code&gt;git notes merge&lt;/code&gt; stored in .git/NOTES_MERGE_WORKTREE. This amends the partial merge commit created by &lt;code&gt;git notes merge&lt;/code&gt; (stored in .git/NOTES_MERGE_PARTIAL) by adding the notes in .git/NOTES_MERGE_WORKTREE. The notes ref stored in the .git/NOTES_MERGE_REF symref is updated to the resulting commit.</source>
          <target state="translated">完成正在进行的 &lt;code&gt;git notes merge&lt;/code&gt; 。解决了 &lt;code&gt;git notes merge&lt;/code&gt; 存储在.git / NOTES_MERGE_WORKTREE中的冲突时，请使用此选项。这通过在.git / NOTES_MERGE_WORKTREE中添加注释来修正由 &lt;code&gt;git notes merge&lt;/code&gt; （存储在.git / NOTES_MERGE_PARTIAL中）创建的部分合并提交。存储在.git / NOTES_MERGE_REF symref中的注释ref被更新为最终提交。</target>
        </trans-unit>
        <trans-unit id="9eb00b677ea152c9f2f0f234add05ac350dd5a77" translate="yes" xml:space="preserve">
          <source>Finally it examines &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt;. This file is used to override the in-tree settings. The first line is a match, and &lt;code&gt;foo&lt;/code&gt; is set, &lt;code&gt;bar&lt;/code&gt; is reverted to unspecified state, and &lt;code&gt;baz&lt;/code&gt; is unset.</source>
          <target state="translated">最后，它检查 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 。该文件用于覆盖树内设置。第一行是一个匹配项，并且设置了 &lt;code&gt;foo&lt;/code&gt; ， &lt;code&gt;bar&lt;/code&gt; 还原为未指定状态，并且未设置 &lt;code&gt;baz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="331d183abb3e32c5b94fe163358b0bd60def41df" translate="yes" xml:space="preserve">
          <source>Finally, if &lt;code&gt;--expire-time=&amp;lt;datetime&amp;gt;&lt;/code&gt; is not specified, let &lt;code&gt;datetime&lt;/code&gt; be the current time. After writing the split commit-graph, delete all unused commit-graph whose modified times are older than &lt;code&gt;datetime&lt;/code&gt;.</source>
          <target state="translated">最后，如果未指定 &lt;code&gt;--expire-time=&amp;lt;datetime&amp;gt;&lt;/code&gt; ，则将 &lt;code&gt;datetime&lt;/code&gt; 设为当前时间。写入拆分提交图后，删除所有修改时间早于 &lt;code&gt;datetime&lt;/code&gt; 的未使用提交图。</target>
        </trans-unit>
        <trans-unit id="43d1a6457be0c846de5bf38ab3298d9d3628832d" translate="yes" xml:space="preserve">
          <source>Finally, it is possible to specify an arbitrary perl subroutine that will be called for each repository to determine if it can be exported. The subroutine receives an absolute path to the project (repository) as its only parameter (i.e. &quot;$projectroot/$project&quot;).</source>
          <target state="translated">最后,可以指定一个任意的perl子程序,它将被调用以确定每个版本库是否可以导出。该子程序接收项目(仓库)的绝对路径作为唯一参数(即&quot;$projectroot/$project&quot;)。</target>
        </trans-unit>
        <trans-unit id="24d1078763f97a2ccc23634e9fb57ca6945117cd" translate="yes" xml:space="preserve">
          <source>Finally, it&amp;rsquo;s worth looking at the effect of &lt;code&gt;git add&lt;/code&gt; on the index file:</source>
          <target state="translated">最后，值得研究 &lt;code&gt;git add&lt;/code&gt; 对索引文件的影响：</target>
        </trans-unit>
        <trans-unit id="8264955cf61255273040b40a18d8fbbb22fa2f72" translate="yes" xml:space="preserve">
          <source>Finally, most commands that take filenames will optionally allow you to precede any filename by a commit, to specify a particular version of the file:</source>
          <target state="translated">最后,大多数使用文件名的命令都会允许你在任何文件名前加上一个提交,以指定文件的特定版本。</target>
        </trans-unit>
        <trans-unit id="6c56e02ffa0dc0d04395282d17622dfa271e848b" translate="yes" xml:space="preserve">
          <source>Finally, runs of whitespace are normalized to a single ASCII space character.</source>
          <target state="translated">最后,空白字符的运行被归一化为一个ASCII空格字符。</target>
        </trans-unit>
        <trans-unit id="f254df0ed5803ab0d672797542ab7bd433761746" translate="yes" xml:space="preserve">
          <source>Finally, see &lt;a href=&quot;#todo&quot;&gt;Notes and todo list for this manual&lt;/a&gt; for ways that you can help make this manual more complete.</source>
          <target state="translated">最后，请参阅&lt;a href=&quot;#todo&quot;&gt;本手册的&amp;ldquo;注释&amp;rdquo;和&amp;ldquo;待办事项&amp;rdquo;列表，&lt;/a&gt;以帮助您使本手册更加完整。</target>
        </trans-unit>
        <trans-unit id="0f28877b4b3e20afaa3344b89d8d8e7dd3cc9a77" translate="yes" xml:space="preserve">
          <source>Finally, the list of matching commits is shown in the order of the second commit range, with unmatched commits being inserted just after all of their ancestors have been shown.</source>
          <target state="translated">最后,匹配的提交列表按照第二个提交范围的顺序显示,未匹配的提交会在所有的祖先显示之后插入。</target>
        </trans-unit>
        <trans-unit id="9a3fea8b3f0925da6c2b86381c6c149ac6f29683" translate="yes" xml:space="preserve">
          <source>Finally, there are a few odds and ends which are not purely moving from one representation to the other:</source>
          <target state="translated">最后,还有一些零碎的东西,并不是单纯的从一种表示方式转移到另一种表示方式。</target>
        </trans-unit>
        <trans-unit id="3fe4e962ec8320ef45c1375652f3937a50d04ca2" translate="yes" xml:space="preserve">
          <source>Finally, there is a fifth simplification mode available:</source>
          <target state="translated">最后,还有第五种简化模式可供选择。</target>
        </trans-unit>
        <trans-unit id="be9a3fea0f82381aa185e3a3e7bc70453cddfef1" translate="yes" xml:space="preserve">
          <source>Finally, these options can be combined with a layout option (defaults to &lt;code&gt;nodense&lt;/code&gt;):</source>
          <target state="translated">最后，这些选项可以与布局选项结合使用（默认为 &lt;code&gt;nodense&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="20a1c9ffc616ee01b8dce65bdb93f7148cbfeb85" translate="yes" xml:space="preserve">
          <source>Find a helper.</source>
          <target state="translated">找个帮手。</target>
        </trans-unit>
        <trans-unit id="30d88faf5655c44ff9e677fe0e00c8e9ca77aa3d" translate="yes" xml:space="preserve">
          <source>Find a ref that matches &lt;code&gt;experimental&lt;/code&gt; in the &lt;code&gt;origin&lt;/code&gt; repository (e.g. &lt;code&gt;refs/heads/experimental&lt;/code&gt;), and delete it.</source>
          <target state="translated">在 &lt;code&gt;origin&lt;/code&gt; 存储库中找到与 &lt;code&gt;experimental&lt;/code&gt; 匹配的参考（例如 &lt;code&gt;refs/heads/experimental&lt;/code&gt; ），然后将其删除。</target>
        </trans-unit>
        <trans-unit id="ef251b247769ae2bcbe4a6086b08e0deff95b9d6" translate="yes" xml:space="preserve">
          <source>Find a ref that matches &lt;code&gt;master&lt;/code&gt; in the source repository (most likely, it would find &lt;code&gt;refs/heads/master&lt;/code&gt;), and update the same ref (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) in &lt;code&gt;origin&lt;/code&gt; repository with it. If &lt;code&gt;master&lt;/code&gt; did not exist remotely, it would be created.</source>
          <target state="translated">查找匹配的裁判 &lt;code&gt;master&lt;/code&gt; 源代码库（最有可能的，它会找 &lt;code&gt;refs/heads/master&lt;/code&gt; ），并更新相同REF（例如 &lt;code&gt;refs/heads/master&lt;/code&gt; ）的 &lt;code&gt;origin&lt;/code&gt; 与它库。如果 &lt;code&gt;master&lt;/code&gt; 不存在于远程，它将被创建。</target>
        </trans-unit>
        <trans-unit id="ccef9d1bcc3ad53f8d4e9015291e141315fc185c" translate="yes" xml:space="preserve">
          <source>Find as good common ancestors as possible for a merge</source>
          <target state="translated">尽可能找到好的共同祖先进行合并。</target>
        </trans-unit>
        <trans-unit id="d3f173da3a7dce0bd9994325b78952d16aab8240" translate="yes" xml:space="preserve">
          <source>Find commits yet to be applied to upstream</source>
          <target state="translated">查找尚未应用到上游的提交内容</target>
        </trans-unit>
        <trans-unit id="f766cd71208fbf6c57bd1c63b40f06ddd3b5b9dc" translate="yes" xml:space="preserve">
          <source>Find first tagged version including a given fix</source>
          <target state="translated">查找包含给定修复的第一个标记版本</target>
        </trans-unit>
        <trans-unit id="df9e9c717faf5fac976a38f227398efdc30aeda9" translate="yes" xml:space="preserve">
          <source>Find redundant pack files</source>
          <target state="translated">查找多余的包文件</target>
        </trans-unit>
        <trans-unit id="44f9539ac1c361035e9a88da329c269fe8a0f4cb" translate="yes" xml:space="preserve">
          <source>Find symbolic names for given revs</source>
          <target state="translated">查找给定转速的符号名称</target>
        </trans-unit>
        <trans-unit id="f381cb9cf3280c2142361c5998997b7124410055" translate="yes" xml:space="preserve">
          <source>Find the color configured for &lt;code&gt;name&lt;/code&gt; (e.g. &lt;code&gt;color.diff.new&lt;/code&gt;) and output it as the ANSI color escape sequence to the standard output. The optional &lt;code&gt;default&lt;/code&gt; parameter is used instead, if there is no color configured for &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">找到为 &lt;code&gt;name&lt;/code&gt; 配置的颜色（例如 &lt;code&gt;color.diff.new&lt;/code&gt; ），并将其作为ANSI颜色转义序列输出到标准输出。如果没有为 &lt;code&gt;name&lt;/code&gt; 配置颜色，则使用可选的 &lt;code&gt;default&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="40d2e7dbd88f8b4a905f40b739ac46054d6c280f" translate="yes" xml:space="preserve">
          <source>Find the color setting for &lt;code&gt;name&lt;/code&gt; (e.g. &lt;code&gt;color.diff&lt;/code&gt;) and output &quot;true&quot; or &quot;false&quot;. &lt;code&gt;stdout-is-tty&lt;/code&gt; should be either &quot;true&quot; or &quot;false&quot;, and is taken into account when configuration says &quot;auto&quot;. If &lt;code&gt;stdout-is-tty&lt;/code&gt; is missing, then checks the standard output of the command itself, and exits with status 0 if color is to be used, or exits with status 1 otherwise. When the color setting for &lt;code&gt;name&lt;/code&gt; is undefined, the command uses &lt;code&gt;color.ui&lt;/code&gt; as fallback.</source>
          <target state="translated">查找 &lt;code&gt;name&lt;/code&gt; 的颜色设置（例如 &lt;code&gt;color.diff&lt;/code&gt; ），然后输出&amp;ldquo; true&amp;rdquo;或&amp;ldquo; false&amp;rdquo;。 &lt;code&gt;stdout-is-tty&lt;/code&gt; 应该为&amp;ldquo; true&amp;rdquo;或&amp;ldquo; false&amp;rdquo;，并且在配置显示为&amp;ldquo; auto&amp;rdquo;时将其考虑在内。如果缺少 &lt;code&gt;stdout-is-tty&lt;/code&gt; ，则检查命令本身的标准输出，如果要使用颜色，则以状态0退出，否则以状态1退出。当 &lt;code&gt;name&lt;/code&gt; 的颜色设置未定义时，该命令将使用 &lt;code&gt;color.ui&lt;/code&gt; 作为后备。</target>
        </trans-unit>
        <trans-unit id="df59454620e80f086423090568733ac46b2847e0" translate="yes" xml:space="preserve">
          <source>Find the point at which a branch (or any history that leads to &amp;lt;commit&amp;gt;) forked from another branch (or any reference) &amp;lt;ref&amp;gt;. This does not just look for the common ancestor of the two commits, but also takes into account the reflog of &amp;lt;ref&amp;gt; to see if the history leading to &amp;lt;commit&amp;gt; forked from an earlier incarnation of the branch &amp;lt;ref&amp;gt; (see discussion on this mode below).</source>
          <target state="translated">查找分支（或导致&amp;lt;commit&amp;gt;的任何历史记录）与另一个分支（或任何引用）&amp;lt;ref&amp;gt;分叉的点。这不仅要查找两次提交的共同祖先，而且还要考虑&amp;lt;ref&amp;gt;的引用日志，以查看导致&amp;lt;commit&amp;gt;的历史记录是否来自分支&amp;lt;ref&amp;gt;的早期化身（请参见下面的此模式）。</target>
        </trans-unit>
        <trans-unit id="9da189d134fc7190f0c6c1f5c3193ab5948bf13c" translate="yes" xml:space="preserve">
          <source>Finding commits referencing a file with given content</source>
          <target state="translated">寻找引用给定内容的文件的提交。</target>
        </trans-unit>
        <trans-unit id="e333b71e49766be9f1d76f262411fa340daf0c70" translate="yes" xml:space="preserve">
          <source>Finding commits which commit messages matches given search term.</source>
          <target state="translated">寻找符合指定搜索条件的提交信息。</target>
        </trans-unit>
        <trans-unit id="1eaaf96aa600c577b3f3a9747228f1b65b0ceefc" translate="yes" xml:space="preserve">
          <source>Finding files</source>
          <target state="translated">查找文件</target>
        </trans-unit>
        <trans-unit id="2fc00785f4570abeeda498c54f0284462aed8b44" translate="yes" xml:space="preserve">
          <source>Finding performance regressions</source>
          <target state="translated">寻找业绩回归</target>
        </trans-unit>
        <trans-unit id="bc2b131e580f41edfbbcd8f6c9c60a09f1a25b76" translate="yes" xml:space="preserve">
          <source>Finds symbolic names suitable for human digestion for revisions given in any format parsable by &lt;code&gt;git rev-parse&lt;/code&gt;.</source>
          <target state="translated">查找适合人类消化的符号名称，以 &lt;code&gt;git rev-parse&lt;/code&gt; 可解析的任何格式给出的修订版本。</target>
        </trans-unit>
        <trans-unit id="7d4b2472daa261c193507bf4d856ace529dabcc6" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s assume your &lt;code&gt;topic&lt;/code&gt; is based on branch &lt;code&gt;next&lt;/code&gt;. For example, a feature developed in &lt;code&gt;topic&lt;/code&gt; depends on some functionality which is found in &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">首先，假设您的 &lt;code&gt;topic&lt;/code&gt; 基于 &lt;code&gt;next&lt;/code&gt; 。例如，在 &lt;code&gt;topic&lt;/code&gt; 开发的功能取决于 &lt;code&gt;next&lt;/code&gt; 中找到的某些功能。</target>
        </trans-unit>
        <trans-unit id="ed8007e4d48fad1e0a696af768b6078f3fa95c0a" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s define &quot;best bisection point&quot;. We will say that a commit X is a best bisection point or a best bisection commit if knowing its state (&quot;good&quot; or &quot;bad&quot;) gives as much information as possible whether the state of the commit happens to be &quot;good&quot; or &quot;bad&quot;.</source>
          <target state="translated">首先让我们定义&amp;ldquo;最佳平分点&amp;rdquo;。我们将说，如果知道提交状态（&amp;ldquo;好&amp;rdquo;或&amp;ldquo;坏&amp;rdquo;）给出了尽可能多的信息（无论提交状态是&amp;ldquo;好&amp;rdquo;还是&amp;ldquo;好&amp;rdquo;，则提交X是最佳二等分点或最佳二等分提交）。坏&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ee7f8a8fdabeacb4105bb68c4dfba6a20cea041f" translate="yes" xml:space="preserve">
          <source>First merges by themselves can introduce some regressions even when the merge needs no source code conflict resolution. This is because a semantic change can happen in one branch while the other branch is not aware of it.</source>
          <target state="translated">即使在合并不需要解决源代码冲突的情况下,第一次合并本身也会引入一些回归。这是因为语义上的变化可能发生在一个分支中,而另一个分支却不知道。</target>
        </trans-unit>
        <trans-unit id="05a55fcafe087cbd44c02228e1ac75a34a01c1f1" translate="yes" xml:space="preserve">
          <source>First, build a history graph in the same way that &lt;code&gt;--full-history&lt;/code&gt; with parent rewriting does (see above).</source>
          <target state="translated">首先，以与带有父级重写的 &lt;code&gt;--full-history&lt;/code&gt; 相同的方式构建历史记录图（请参见上文）。</target>
        </trans-unit>
        <trans-unit id="08310df25f406cc10b8d6127f9ec844567b780fb" translate="yes" xml:space="preserve">
          <source>First, if you wish to continue to release maintenance fixes for the feature release made before the recent one, then you must create another branch to track commits for that previous release.</source>
          <target state="translated">首先,如果你希望继续发布最近发布的功能版本之前的维护修复,那么你必须创建另一个分支来跟踪之前版本的提交。</target>
        </trans-unit>
        <trans-unit id="3f7b81f4c441b31ef96f877571ae9e6d0b762fd6" translate="yes" xml:space="preserve">
          <source>First, in .gitattributes, you would assign the &lt;code&gt;diff&lt;/code&gt; attribute for paths.</source>
          <target state="translated">首先，在.gitattributes中，您将为路径分配 &lt;code&gt;diff&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="b3f5f5cacf6c72eb426cf54eb30cee145c3bf1f2" translate="yes" xml:space="preserve">
          <source>First, install version 2.1 or higher of cvsps from &lt;a href=&quot;https://github.com/andreyvit/cvsps&quot;&gt;https://github.com/andreyvit/cvsps&lt;/a&gt; and make sure it is in your path. Then cd to a checked out CVS working directory of the project you are interested in and run &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport[1]&lt;/a&gt;:</source>
          <target state="translated">首先，从&lt;a href=&quot;https://github.com/andreyvit/cvsps&quot;&gt;https://github.com/andreyvit/cvsps&lt;/a&gt;安装2.1版或更高版本的cvsps，并确保它在您的路径中。然后cd到您感兴趣的项目的已检出CVS工作目录，并运行&lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport [1]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="576e890855dbcdc8bc3ac7fde0afbe81b0fdd016" translate="yes" xml:space="preserve">
          <source>First, note that you can get documentation for a command such as &lt;code&gt;git log --graph&lt;/code&gt; with:</source>
          <target state="translated">首先，请注意，您可以使用以下命令获取命令的文档，例如 &lt;code&gt;git log --graph&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9a679f4d1f2379fb3e8b418dd1cdea69390f805f" translate="yes" xml:space="preserve">
          <source>First, reset the history back one commit so that we remove the original commit, but leave the working tree with all the changes. The -N ensures that any new files added with &lt;code&gt;HEAD&lt;/code&gt; are still marked so that &lt;code&gt;git add -p&lt;/code&gt; will find them.</source>
          <target state="translated">首先，将历史记录重置为一次提交，以便我们删除原始提交，但保留所有更改并保留工作树。-N确保仍将标记有 &lt;code&gt;HEAD&lt;/code&gt; 添加的任何新文件，以便 &lt;code&gt;git add -p&lt;/code&gt; 可以找到它们。</target>
        </trans-unit>
        <trans-unit id="eac258ebc7c4ff84505375d195a1e24d04961706" translate="yes" xml:space="preserve">
          <source>First, use &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;; for example:</source>
          <target state="translated">首先，使用&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;；例如：</target>
        </trans-unit>
        <trans-unit id="af62e3f15d84326a813952b253791dac4ec57aaa" translate="yes" xml:space="preserve">
          <source>First, you need to create an empty repository on the remote machine that will house your public repository. This empty repository will be populated and be kept up to date by pushing into it later. Obviously, this repository creation needs to be done only once.</source>
          <target state="translated">首先,你需要在远程机器上创建一个空仓库,用来存放你的公共仓库。这个空仓库将被填充,并在以后通过推入它来保持更新。很明显,这个版本库的创建只需要做一次。</target>
        </trans-unit>
        <trans-unit id="52835c0708aa62a7396cacc7dfc2df24ce8a002c" translate="yes" xml:space="preserve">
          <source>Fix a &quot;thin&quot; pack produced by &lt;code&gt;git pack-objects --thin&lt;/code&gt; (see &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for details) by adding the excluded objects the deltified objects are based on to the pack. This option only makes sense in conjunction with --stdin.</source>
          <target state="translated">通过将经过精简的对象所基于的排除对象添加到包中，来修复由 &lt;code&gt;git pack-objects --thin&lt;/code&gt; 生成的&amp;ldquo;瘦&amp;rdquo;包（有关详细信息，请参见&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;）。该选项仅与--stdin一起使用才有意义。</target>
        </trans-unit>
        <trans-unit id="6bef9039e49cd5a1bb992311087de16992b814ac" translate="yes" xml:space="preserve">
          <source>Fix the ignore-paths or SVN permissions problem that caused &quot;r2&quot; to be incomplete in the first place. Then:</source>
          <target state="translated">修正首先导致 &quot;r2 &quot;不完整的ignore-paths或SVN权限问题。然后:</target>
        </trans-unit>
        <trans-unit id="bf5e51b162922584144bf607debb47b58ed7a8df" translate="yes" xml:space="preserve">
          <source>Fixing a mistake by rewriting history</source>
          <target state="translated">通过重写历史来修正错误</target>
        </trans-unit>
        <trans-unit id="afb2d222f3591d3622f9d0c44f698fe7e6dc0a83" translate="yes" xml:space="preserve">
          <source>Fixing a mistake with a new commit</source>
          <target state="translated">用新的提交修正错误</target>
        </trans-unit>
        <trans-unit id="c169f9b52cd517560d8a456346335c3aedbfac2b" translate="yes" xml:space="preserve">
          <source>Fixing mistakes</source>
          <target state="translated">修正错误</target>
        </trans-unit>
        <trans-unit id="de18d069db0d9d56daecfccdb3a27275518bc1f7" translate="yes" xml:space="preserve">
          <source>Flags and parameters to be parsed.</source>
          <target state="translated">要解析的标志和参数。</target>
        </trans-unit>
        <trans-unit id="8a2fcacfdef0a8b1fd083381230b0ac0cbbdea61" translate="yes" xml:space="preserve">
          <source>Follow merge ancestry and attempt to import trees that have been merged from. Specify a depth greater than 1 if patch logs have been pruned.</source>
          <target state="translated">按照合并祖先,并尝试导入已合并的树木从。如果补丁日志已被修剪,则指定深度大于1。</target>
        </trans-unit>
        <trans-unit id="fc08e4a2c4c96e25ad3223cdd944785cb30a915c" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48973c6479f97ed9cbdd1aa747abb3d724dfc88" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This is useful when you wish to not match tags on branches merged in the history of the target commit.</source>
          <target state="translated">当看到合并提交时,只跟随第一个父提交。当您希望不匹配目标提交历史中合并的分支上的标签时,这很有用。</target>
        </trans-unit>
        <trans-unit id="37deb1921d5628bb8484cd98e5d1812d850199d4" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This option can be used to determine when a line was introduced to a particular integration branch, rather than when it was introduced to the history overall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592429d37f44072b1083ee8b6715edf266446955" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67b9781a4352de8f66549a8b248fd66aceb7858" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge. Cannot be combined with --bisect.</source>
          <target state="translated">看到合并提交后只关注第一个父提交。这个选项可以让你在查看某个特性分支的演变时有更好的概览,因为合并到特性分支中的提交往往只是为了不时地调整到上游的更新,而这个选项可以让你忽略历史上由这种合并带来的单个提交。不能与 --bisect 结合使用。</target>
        </trans-unit>
        <trans-unit id="1b82a1274463e2bfba901905e39b02d331c44520" translate="yes" xml:space="preserve">
          <source>Following general best practices</source>
          <target state="translated">遵循一般最佳做法</target>
        </trans-unit>
        <trans-unit id="788b60e8a3fa302c96ca5000ec7c36053afb1c38" translate="yes" xml:space="preserve">
          <source>Following the headers, a series of lines are printed for tracked entries. One of three different line formats may be used to describe an entry depending on the type of change. Tracked entries are printed in an undefined order; parsers should allow for a mixture of the 3 line types in any order.</source>
          <target state="translated">在页眉之后,打印一系列跟踪条目的行。根据更改的类型,可以使用三种不同的行格式之一来描述条目。追踪条目以未定义的顺序打印;解析器应允许以任何顺序混合使用这三种行类型。</target>
        </trans-unit>
        <trans-unit id="0af351e25b3235e5cb0b144d879a5948cd0b6627" translate="yes" xml:space="preserve">
          <source>Following the tracked entries (and if requested), a series of lines will be printed for untracked and then ignored items found in the worktree.</source>
          <target state="translated">在跟踪的条目之后(如果有要求),将打印一系列工作树中发现的未跟踪和忽略的条目。</target>
        </trans-unit>
        <trans-unit id="18388d4087a6542b5572bea29a06b35e2aae5326" translate="yes" xml:space="preserve">
          <source>Following these N lines, one-line log for each commit is displayed, indented N places. If a commit is on the I-th branch, the I-th indentation character shows a &lt;code&gt;+&lt;/code&gt; sign; otherwise it shows a space. Merge commits are denoted by a &lt;code&gt;-&lt;/code&gt; sign. Each commit shows a short name that can be used as an extended SHA-1 to name that commit.</source>
          <target state="translated">在这N行之后，显示每次提交的单行日志，缩进了N个位置。如果提交在第I个分支上，则第I个缩进字符显示一个 &lt;code&gt;+&lt;/code&gt; 号；否则显示空格。合并提交由 &lt;code&gt;-&lt;/code&gt; 符号表示。每个提交都显示一个短名称，可用作扩展的SHA-1来命名该提交。</target>
        </trans-unit>
        <trans-unit id="348633bb6883a2c8b3944ebb9c0c3986369c6bb3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;--cc&lt;/code&gt;, only the destination or final path is shown even if the file was renamed on any side of history. With &lt;code&gt;--combined-all-paths&lt;/code&gt;, the name of the path in each parent is shown followed by the name of the path in the merge commit.</source>
          <target state="translated">对于 &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;--cc&lt;/code&gt; ，即使文件在历史记录的任何一边被重命名，也仅显示目的地或最终路径。使用 &lt;code&gt;--combined-all-paths&lt;/code&gt; ，将显示每个父级中路径的名称，然后显示合并提交中路径的名称。</target>
        </trans-unit>
        <trans-unit id="299f58cbaec7164b54b0f4129532e8b5c1642be3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt;, display the urls that will be used for copying when creating the branch or tag.</source>
          <target state="translated">对于 &lt;code&gt;branch&lt;/code&gt; 和 &lt;code&gt;tag&lt;/code&gt; ，显示创建分支或标签时将用于复制的网址。</target>
        </trans-unit>
        <trans-unit id="007222e8d7dfa1e11f08c139bdea5864653b03fb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;dcommit&lt;/code&gt;, print out the series of Git arguments that would show which diffs would be committed to SVN.</source>
          <target state="translated">对于 &lt;code&gt;dcommit&lt;/code&gt; ，请打印出一系列Git参数，该参数将显示将哪些差异提交给SVN。</target>
        </trans-unit>
        <trans-unit id="7661574c1331f1ffadb88e65b09fb7bbb3d5b369" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;rebase&lt;/code&gt;, display the local branch associated with the upstream svn repository associated with the current branch and the URL of svn repository that will be fetched from.</source>
          <target state="translated">对于 &lt;code&gt;rebase&lt;/code&gt; ，显示与与当前分支关联的上游svn信息库关联的本地分支以及将从中获取的svn信息库的URL。</target>
        </trans-unit>
        <trans-unit id="8054fb75013a9d33733a54185710f048c11e6754" translate="yes" xml:space="preserve">
          <source>For Git developers, &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; goes into detail on the lower-level Git mechanisms involved in, for example, creating a new commit.</source>
          <target state="translated">对于Git开发人员，&lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt;详细介绍了例如创建新提交所涉及的低级Git机制。</target>
        </trans-unit>
        <trans-unit id="9c7a8b6d1a7a0700f3cd22ce6172861bfe044c11" translate="yes" xml:space="preserve">
          <source>For SSH clients that will make commits, make sure their server-side .ssh/environment files (or .bashrc, etc., according to their specific shell) export appropriate values for GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_COMMITTER_NAME, and GIT_COMMITTER_EMAIL. For SSH clients whose login shell is bash, .bashrc may be a reasonable alternative.</source>
          <target state="translated">对于要进行提交的 SSH 客户端,确保他们的服务器端 .ssh/environment 文件 (或 .bashrc 等,根据他们特定的 shell)为 GIT_AUTHOR_NAME、GIT_AUTHOR_EMAIL、GIT_COMMITTER_NAME 和 GIT_COMMITTER_EMAIL 输出适当的值。对于登录 shell 是 bash 的 SSH 客户端,.bashrc 可能是一个合理的选择。</target>
        </trans-unit>
        <trans-unit id="e127a96a43fc87667b0c86a8698d094b3fabedbe" translate="yes" xml:space="preserve">
          <source>For URLs in &lt;code&gt;https://weak.example.com&lt;/code&gt;, &lt;code&gt;http.sslVerify&lt;/code&gt; is set to false, while it is set to &lt;code&gt;true&lt;/code&gt; for all others:</source>
          <target state="translated">对于 &lt;code&gt;https://weak.example.com&lt;/code&gt; 中的 URL ， &lt;code&gt;http.sslVerify&lt;/code&gt; 设置为false，而其他所有URL 设置为 &lt;code&gt;true&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="701bbbb19204ae1c36fbfa4b6462dff9d4624e60" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;get&lt;/code&gt; operation, the helper should produce a list of attributes on stdout in the same format (see &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt; for common attributes). A helper is free to produce a subset, or even no values at all if it has nothing useful to provide. Any provided attributes will overwrite those already known about by Git&amp;rsquo;s credential subsystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef97080144d6e0b76f4c32d65bbd8d420f1d9d3f" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;store&lt;/code&gt; or &lt;code&gt;erase&lt;/code&gt; operation, the helper&amp;rsquo;s output is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c95f036bd90f837a4d78c935d1c885601df8ec" translate="yes" xml:space="preserve">
          <source>For a custom merge command, specify whether the exit code of the merge command can be used to determine whether the merge was successful. If this is not set to true then the merge target file timestamp is checked and the merge assumed to have been successful if the file has been updated, otherwise the user is prompted to indicate the success of the merge.</source>
          <target state="translated">对于自定义的合并命令,指定是否可以使用合并命令的退出代码来判断合并是否成功。如果没有设置为 &quot;true&quot;,则检查合并目标文件的时间戳,如果文件已经更新,则假设合并成功,否则会提示用户说明合并成功。</target>
        </trans-unit>
        <trans-unit id="832a920de5e5a1607e20fda89c6b16105d6a3d66" translate="yes" xml:space="preserve">
          <source>For a description of which objects are considered for pruning, see &lt;code&gt;git fsck&lt;/code&gt;'s --unreachable option.</source>
          <target state="translated">有关考虑修剪哪些对象的描述，请参见 &lt;code&gt;git fsck&lt;/code&gt; 的--unreachable选项。</target>
        </trans-unit>
        <trans-unit id="7772aa877c345ccdb695091fd19f024126a4a0b8" translate="yes" xml:space="preserve">
          <source>For a detailed description of &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; see above under &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">有关 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 的详细说明，请参见上文 &lt;code&gt;from&lt;/code&gt; 中的内容。</target>
        </trans-unit>
        <trans-unit id="97b7c41fd980027cd240574fa45f8b9cf3a30c50" translate="yes" xml:space="preserve">
          <source>For a detailed description of &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; see above under &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">有关 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 的详细说明，请参见上文 &lt;code&gt;commit&lt;/code&gt; 和 &lt;code&gt;from&lt;/code&gt; 下的内容。</target>
        </trans-unit>
        <trans-unit id="c4f4b9fba6569cfb2eebe32e9b505f5e163da8ae" translate="yes" xml:space="preserve">
          <source>For a failed update, more details are given:</source>
          <target state="translated">对于失败的更新,会给出更多细节。</target>
        </trans-unit>
        <trans-unit id="243468740a36ab67df241df82903537b2a102239" translate="yes" xml:space="preserve">
          <source>For a more complete list of ways to spell &amp;lt;commit&amp;gt;, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;. However, &quot;diff&quot; is about comparing two &lt;code&gt;endpoints&lt;/code&gt;, not ranges, and the range notations (&quot;&amp;lt;commit&amp;gt;..&amp;lt;commit&amp;gt;&quot; and &quot;&amp;lt;commit&amp;gt;...&amp;lt;commit&amp;gt;&quot;) do not mean a range as defined in the &quot;SPECIFYING RANGES&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">有关拼写&amp;lt;commit&amp;gt;的方法的完整列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]中的&lt;/a&gt; &amp;ldquo;指定修订版&amp;rdquo;部分。但是，&amp;ldquo; diff&amp;rdquo;是关于比较两个 &lt;code&gt;endpoints&lt;/code&gt; 而不是范围，并且范围符号（&amp;ldquo; &amp;lt;commit&amp;gt; .. &amp;lt;commit&amp;gt;&amp;rdquo;和&amp;ldquo; &amp;lt;commit&amp;gt; ... &amp;lt;commit&amp;gt;&amp;rdquo;）并不表示&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]中&lt;/a&gt;的&amp;ldquo;指定范围&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="80d1eb4ba7c1d828db1e0d707b3b97b45d1d7903" translate="yes" xml:space="preserve">
          <source>For a more complete list of ways to spell &amp;lt;commit&amp;gt;, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;. However, &quot;diff&quot; is about comparing two &lt;code&gt;endpoints&lt;/code&gt;, not ranges, and the range notations (&lt;code&gt;&amp;lt;commit&amp;gt;..&amp;lt;commit&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;commit&amp;gt;...&amp;lt;commit&amp;gt;&lt;/code&gt;) do not mean a range as defined in the &quot;SPECIFYING RANGES&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef391cab8f8e654bd28a4ebab3ff359b2dd758d" translate="yes" xml:space="preserve">
          <source>For a more complete list of ways to spell object names, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">有关拼写对象名称的方法的完整列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]中的&lt;/a&gt; &amp;ldquo;指定修订版&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="ffb03e9988d5aab6ca13a5c4410e25c3bc4d2c1f" translate="yes" xml:space="preserve">
          <source>For a more detailed discussion of the procedure and additional tips, see the &quot;INTERACTIVE MODE&quot; section of &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">有关该过程的更多详细讨论和其他技巧，请参见&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;的&amp;ldquo;交互模式&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="21840545ec0ef1fb11dadc3e0bd425ddda71d447" translate="yes" xml:space="preserve">
          <source>For a path that is unmerged, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 1 parameter, &amp;lt;path&amp;gt;.</source>
          <target state="translated">对于未合并的路径，将使用1个参数&amp;lt;path&amp;gt;调用 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf84b30d98b0b2aee4084cebd6a510d7735317e2" translate="yes" xml:space="preserve">
          <source>For a regular file &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;echo HEAD:f | git cat-file --batch&lt;/code&gt; would print</source>
          <target state="translated">对于常规文件 &lt;code&gt;f&lt;/code&gt; ， &lt;code&gt;echo HEAD:f | git cat-file --batch&lt;/code&gt; 将打印</target>
        </trans-unit>
        <trans-unit id="3d0f9234523f6052cd5829e5dd1cdac95a9b09fd" translate="yes" xml:space="preserve">
          <source>For a simple local test, you can use &lt;a href=&quot;git-remote-ext&quot;&gt;git-remote-ext[1]&lt;/a&gt;:</source>
          <target state="translated">对于简单的本地测试，可以使用&lt;a href=&quot;git-remote-ext&quot;&gt;git-remote-ext [1]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="428bfb3c06af83865df8238da30e9618f9cb0a09" translate="yes" xml:space="preserve">
          <source>For a successfully fetched ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to &lt;code&gt;git log&lt;/code&gt; (this is &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; in most cases, and &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; for forced non-fast-forward updates).</source>
          <target state="translated">对于成功获取的ref，摘要以适合用作 &lt;code&gt;git log&lt;/code&gt; 参数的形式显示了ref的旧值和新值（在大多数情况下为 &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; ，而 &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; 用于强制非快进更新）。</target>
        </trans-unit>
        <trans-unit id="95550d69988e7a758b9c94b13942bde9ad57e2ef" translate="yes" xml:space="preserve">
          <source>For a successfully pushed ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to &lt;code&gt;git log&lt;/code&gt; (this is &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; in most cases, and &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; for forced non-fast-forward updates).</source>
          <target state="translated">对于成功推入的ref，摘要以适合用作 &lt;code&gt;git log&lt;/code&gt; 参数的形式显示该ref的旧值和新值（在大多数情况下为 &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; ，而 &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; 用于强制非快进更新）。</target>
        </trans-unit>
        <trans-unit id="d2bfe73291a6ef412f90bf2eac1210664a9553b3" translate="yes" xml:space="preserve">
          <source>For all objects, the following names can be used:</source>
          <target state="translated">对于所有对象,可以使用以下名称:</target>
        </trans-unit>
        <trans-unit id="96992b112d12dd337ecf884c867dcddc44e026cf" translate="yes" xml:space="preserve">
          <source>For all options that output values and/or keys, always end values with the null character (instead of a newline). Use newline instead as a delimiter between key and value. This allows for secure parsing of the output without getting confused e.g. by values that contain line breaks.</source>
          <target state="translated">对于所有输出值和/或键的选项,总是以空字符(而不是换行)结束值。使用换行符作为键和值之间的分隔符。这样可以安全地解析输出,而不会被包含换行符的值所混淆。</target>
        </trans-unit>
        <trans-unit id="8ac2c111de5df363fa2f5b2b630af5f75a90bcb1" translate="yes" xml:space="preserve">
          <source>For an unmerged path, instead of recording a single mode/SHA-1 pair, the index records up to three such pairs; one from tree O in stage 1, A in stage 2, and B in stage 3. This information can be used by the user (or the porcelain) to see what should eventually be recorded at the path. (see &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt; for more information on state)</source>
          <target state="translated">对于未合并的路径，该索引最多可以记录三对这样的对，而不是记录一个模式/ SHA-1对。其中一个来自第1阶段的树O，第2阶段的A，第3阶段的B。用户（或瓷器）可以使用此信息来查看最终应在路径上记录的内容。（有关状态的更多信息，请参见&lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="43b2d74a2014d25aa6c53b32650e8baad61de67e" translate="yes" xml:space="preserve">
          <source>For any commit graph, you can see the number associated with each commit using &quot;git rev-list --bisect-all&quot;.</source>
          <target state="translated">对于任何一个提交图,你都可以使用 &quot;git rev-list --bisect-all &quot;查看与每个提交相关的数量。</target>
        </trans-unit>
        <trans-unit id="672441c22b399b226ed91a2cbed5740025f9d076" translate="yes" xml:space="preserve">
          <source>For any remote-tracking branch &lt;code&gt;%(upstream)&lt;/code&gt;, &lt;code&gt;%(upstream:remotename)&lt;/code&gt; and &lt;code&gt;%(upstream:remoteref)&lt;/code&gt; refer to the name of the remote and the name of the tracked remote ref, respectively. In other words, the remote-tracking branch can be updated explicitly and individually by using the refspec &lt;code&gt;%(upstream:remoteref):%(upstream)&lt;/code&gt; to fetch from &lt;code&gt;%(upstream:remotename)&lt;/code&gt;.</source>
          <target state="translated">对于任何远程跟踪分支 &lt;code&gt;%(upstream)&lt;/code&gt; ， &lt;code&gt;%(upstream:remotename)&lt;/code&gt; 和 &lt;code&gt;%(upstream:remoteref)&lt;/code&gt; ，分别引用远程名称和跟踪的远程引用名称。换句话说，可以通过使用refspec &lt;code&gt;%(upstream:remoteref):%(upstream)&lt;/code&gt; 从 &lt;code&gt;%(upstream:remotename)&lt;/code&gt; 获取显式且单独地更新远程跟踪分支。</target>
        </trans-unit>
        <trans-unit id="242026e8d7d0593118b4fae738fc0c3f1a90be23" translate="yes" xml:space="preserve">
          <source>For atomicity, &lt;code&gt;git apply&lt;/code&gt; by default fails the whole patch and does not touch the working tree when some of the hunks do not apply. This option makes it apply the parts of the patch that are applicable, and leave the rejected hunks in corresponding *.rej files.</source>
          <target state="translated">对于原子性，默认情况下 &lt;code&gt;git apply&lt;/code&gt; 会使整个补丁失效，并且当某些块不适用时，不会触及工作树。此选项使它应用补丁的适用部分，并将拒绝的块放到相应的* .rej文件中。</target>
        </trans-unit>
        <trans-unit id="8d098e130baba0ccc99da718229f5fc6bc213a77" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the &lt;code&gt;crlf&lt;/code&gt; attribute is interpreted as follows:</source>
          <target state="translated">为了向后兼容， &lt;code&gt;crlf&lt;/code&gt; 属性的解释如下：</target>
        </trans-unit>
        <trans-unit id="816a47e0ab5f0e7c8c410570167eb66d775695ae" translate="yes" xml:space="preserve">
          <source>For best consistency with &lt;code&gt;cvs&lt;/code&gt;, it is probably best to override the defaults by setting &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; to true, and &lt;code&gt;gitcvs.allBinary&lt;/code&gt; to &quot;guess&quot;.</source>
          <target state="translated">为了与 &lt;code&gt;cvs&lt;/code&gt; 保持最佳一致性，最好将 &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 设置为true，并将 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; 设置为&amp;ldquo; guess&amp;rdquo; 来覆盖默认值。</target>
        </trans-unit>
        <trans-unit id="bad93aa83b2df49f46d609a291da6014ee26a719" translate="yes" xml:space="preserve">
          <source>For best results, &lt;code&gt;clean&lt;/code&gt; should not alter its output further if it is run twice (&quot;clean&amp;rarr;clean&quot; should be equivalent to &quot;clean&quot;), and multiple &lt;code&gt;smudge&lt;/code&gt; commands should not alter &lt;code&gt;clean&lt;/code&gt;'s output (&quot;smudge&amp;rarr;smudge&amp;rarr;clean&quot; should be equivalent to &quot;clean&quot;). See the section on merging below.</source>
          <target state="translated">为了获得最佳结果， &lt;code&gt;clean&lt;/code&gt; 如果运行两次，则不应进一步更改其输出（&amp;ldquo; clean&amp;rarr;clean&amp;rdquo;应等效于&amp;ldquo; clean&amp;rdquo;），并且多个 &lt;code&gt;smudge&lt;/code&gt; 命令不应更改 &lt;code&gt;clean&lt;/code&gt; 的输出（&amp;ldquo; smudge&amp;rarr;smudge&amp;rarr;clean&amp;rdquo;）应该等同于&amp;ldquo;干净&amp;rdquo;）。请参阅下面的合并部分。</target>
        </trans-unit>
        <trans-unit id="8d3928084bacb031775f5d7bad0ceaa321b4778c" translate="yes" xml:space="preserve">
          <source>For blobs and trees, you can&amp;rsquo;t do the same, but you can still examine them. You can just do</source>
          <target state="translated">对于斑点和树木，您无法执行相同的操作，但仍可以对其进行检查。你可以做</target>
        </trans-unit>
        <trans-unit id="d0eec01499f14d036682e7faa93df840595c4ccf" translate="yes" xml:space="preserve">
          <source>For commit and tag objects, the special &lt;code&gt;creatordate&lt;/code&gt; and &lt;code&gt;creator&lt;/code&gt; fields will correspond to the appropriate date or name-email-date tuple from the &lt;code&gt;committer&lt;/code&gt; or &lt;code&gt;tagger&lt;/code&gt; fields depending on the object type. These are intended for working on a mix of annotated and lightweight tags.</source>
          <target state="translated">对于提交和标记对象，特殊的 &lt;code&gt;creatordate&lt;/code&gt; 和 &lt;code&gt;creator&lt;/code&gt; 字段将对应于来自 &lt;code&gt;committer&lt;/code&gt; 或 &lt;code&gt;tagger&lt;/code&gt; 字段的适当日期或名称-电子邮件日期元组，具体取决于对象类型。这些旨在用于带注释的标签和轻量级标签的混合。</target>
        </trans-unit>
        <trans-unit id="f1ce66454707d43159aa08f01addd1a2cbbd5b3f" translate="yes" xml:space="preserve">
          <source>For commits it shows the log message and textual diff. It also presents the merge commit in a special format as produced by &lt;code&gt;git diff-tree --cc&lt;/code&gt;.</source>
          <target state="translated">对于提交，它将显示日志消息和文本差异。它还以 &lt;code&gt;git diff-tree --cc&lt;/code&gt; 产生的特殊格式显示合并提交。</target>
        </trans-unit>
        <trans-unit id="65305ecf02c6387d8a2b51f2d0ea21b43d00656b" translate="yes" xml:space="preserve">
          <source>For commits which do not start empty but become empty after rebasing, see the --empty flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5788d84088826961fe0565ab052c9c41c47117d5" translate="yes" xml:space="preserve">
          <source>For commits, you can just use:</source>
          <target state="translated">对于提交,你可以直接使用。</target>
        </trans-unit>
        <trans-unit id="600c796c6fdee3517d0340d7c98d0e629e148085" translate="yes" xml:space="preserve">
          <source>For conflicting paths, the index file records up to three versions, as described in the &quot;TRUE MERGE&quot; section of &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;. The working tree files will include a description of the conflict bracketed by the usual conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">对于冲突的路径，索引文件最多记录三个版本，如&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;的&amp;ldquo; TRUE MERGE&amp;rdquo;部分所述。工作树文件将包含对冲突的描述，并用通常的冲突标记 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 括起来。</target>
        </trans-unit>
        <trans-unit id="35aa73e9eb71becc5a3756c0cf556cc7d0b77d41" translate="yes" xml:space="preserve">
          <source>For conflicting paths, the index file records up to three versions: stage 1 stores the version from the common ancestor, stage 2 from &lt;code&gt;HEAD&lt;/code&gt;, and stage 3 from &lt;code&gt;MERGE_HEAD&lt;/code&gt; (you can inspect the stages with &lt;code&gt;git ls-files -u&lt;/code&gt;). The working tree files contain the result of the &quot;merge&quot; program; i.e. 3-way merge results with familiar conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;===&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">对于冲突的路径，索引文件最多记录三个版本：阶段1存储公共祖先的版本，阶段2存储 &lt;code&gt;HEAD&lt;/code&gt; 的阶段，阶段3 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 阶段3 （您可以使用 &lt;code&gt;git ls-files -u&lt;/code&gt; 检查阶段）。工作树文件包含&amp;ldquo;合并&amp;rdquo;程序的结果；即，使用熟悉的冲突标记 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;===&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 进行三路合并。</target>
        </trans-unit>
        <trans-unit id="c510e3299937ea0538fccd000bff523a37215fe6" translate="yes" xml:space="preserve">
          <source>For consistency, we also try such a trick if &lt;code&gt;browser.konqueror.path&lt;/code&gt; is set to something like &lt;code&gt;A_PATH_TO/konqueror&lt;/code&gt;. That means we will try to launch &lt;code&gt;A_PATH_TO/kfmclient&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a860b5275da5a9c9fab93cf772cd75bc2e0f4eb" translate="yes" xml:space="preserve">
          <source>For consistency, we also try such a trick if &lt;code&gt;man.konqueror.path&lt;/code&gt; is set to something like &lt;code&gt;A_PATH_TO/konqueror&lt;/code&gt;. That means we will try to launch &lt;code&gt;A_PATH_TO/kfmclient&lt;/code&gt; instead.</source>
          <target state="translated">为了保持一致性，如果将 &lt;code&gt;man.konqueror.path&lt;/code&gt; 设置为 &lt;code&gt;A_PATH_TO/konqueror&lt;/code&gt; 之类的内容，我们也可以尝试这种技巧。这意味着我们将尝试改为启动 &lt;code&gt;A_PATH_TO/kfmclient&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="303c07dbeb4d9b201e995967f10cae861d7b985d" translate="yes" xml:space="preserve">
          <source>For convenience, this data is saved to &lt;code&gt;$GIT_DIR/cvs-authors&lt;/code&gt; each time the &lt;code&gt;-A&lt;/code&gt; option is provided and read from that same file each time &lt;code&gt;git cvsimport&lt;/code&gt; is run.</source>
          <target state="translated">为了方便起见，每次提供 &lt;code&gt;-A&lt;/code&gt; 选项时，此数据都保存到 &lt;code&gt;$GIT_DIR/cvs-authors&lt;/code&gt; 中，并在每次运行 &lt;code&gt;git cvsimport&lt;/code&gt; 时从同一文件中读取。</target>
        </trans-unit>
        <trans-unit id="bc9270ed7ea5a3e841c3245ec308c8ddd86f1b91" translate="yes" xml:space="preserve">
          <source>For credential lookups, the files are read in the order given above, with the first matching credential found taking precedence over credentials found in files further down the list.</source>
          <target state="translated">对于凭证查询,按照上面给出的顺序读取文件,找到的第一个匹配的凭证优先于在列表中更下方的文件中找到的凭证。</target>
        </trans-unit>
        <trans-unit id="78e4826a9de5d7b3349b3c973d4bc09ea13a37ed" translate="yes" xml:space="preserve">
          <source>For each &amp;ldquo;Name &amp;lt;user@host&amp;gt;&amp;rdquo; or &amp;ldquo;&amp;lt;user@host&amp;gt;&amp;rdquo; from the command-line or standard input (when using &lt;code&gt;--stdin&lt;/code&gt;), look up the person&amp;rsquo;s canonical name and email address (see &quot;Mapping Authors&quot; below). If found, print them; otherwise print the input as-is.</source>
          <target state="translated">对于命令行或标准输入中的每个&amp;ldquo;名称&amp;lt;user @ host&amp;gt;&amp;rdquo;或&amp;ldquo; &amp;lt;user @ host&amp;gt;&amp;rdquo;（使用 &lt;code&gt;--stdin&lt;/code&gt; 时），请查找此人的规范名称和电子邮件地址（请参阅下面的&amp;ldquo;映射作者&amp;rdquo;） ）。如果找到，请打印；否则按原样打印输入。</target>
        </trans-unit>
        <trans-unit id="317daaebd1883bdffebfa8e7b1777b5a4f83c1ca" translate="yes" xml:space="preserve">
          <source>For each &amp;lt;pathspec&amp;gt; given on command line, descend at most &amp;lt;depth&amp;gt; levels of directories. A value of -1 means no limit. This option is ignored if &amp;lt;pathspec&amp;gt; contains active wildcards. In other words if &quot;a*&quot; matches a directory named &quot;a*&quot;, &quot;*&quot; is matched literally so --max-depth is still effective.</source>
          <target state="translated">对于命令行中给定的每个&amp;lt;pathspec&amp;gt;，请在目录的最多&amp;lt;depth&amp;gt;级别进行降级。值-1表示没有限制。如果&amp;lt;pathspec&amp;gt;包含活动通配符，则忽略此选项。换句话说，如果&amp;ldquo; a *&amp;rdquo;与名为&amp;ldquo; a *&amp;rdquo;的目录匹配，则&amp;ldquo; *&amp;rdquo;在字面上匹配，因此--max-depth仍然有效。</target>
        </trans-unit>
        <trans-unit id="5e28a0aae950ca165e06c71e20e1b405d570f17a" translate="yes" xml:space="preserve">
          <source>For each URI the server sends, it sends a hash of the pack&amp;rsquo;s contents (as output by git index-pack) followed by the URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf7cc0cba8ed8b7ebafa73d62528bdea5d7f903" translate="yes" xml:space="preserve">
          <source>For each commit a separate file is created in the current directory.</source>
          <target state="translated">每一次提交都会在当前目录下创建一个单独的文件。</target>
        </trans-unit>
        <trans-unit id="6e5eb78674e89f34ddd48ded79bd04ac86b27923" translate="yes" xml:space="preserve">
          <source>For each commit, show a summary of changes using the raw diff format. See the &quot;RAW OUTPUT FORMAT&quot; section of &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. This is different from showing the log itself in raw format, which you can achieve with &lt;code&gt;--format=raw&lt;/code&gt;.</source>
          <target state="translated">对于每个提交，请使用原始的diff格式显示更改摘要。请参阅&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;的&amp;ldquo;原始输出格式&amp;rdquo;部分。这与以原始格式显示日志本身不同，您可以使用 &lt;code&gt;--format=raw&lt;/code&gt; 来实现。</target>
        </trans-unit>
        <trans-unit id="334d2ef126bc398bc9fdce4f33bf828f0bbaab0d" translate="yes" xml:space="preserve">
          <source>For each commit-ish supplied, &lt;code&gt;git describe&lt;/code&gt; will first look for a tag which tags exactly that commit. Annotated tags will always be preferred over lightweight tags, and tags with newer dates will always be preferred over tags with older dates. If an exact match is found, its name will be output and searching will stop.</source>
          <target state="translated">对于每个提供的提交， &lt;code&gt;git describe&lt;/code&gt; 将首先寻找一个标签，该标签准确地标记了该提交。带注释的标签将始终比轻量级标签更受青睐，具有较新日期的标签将始终具有较早日期的标签。如果找到完全匹配的内容，则将输出其名称并停止搜索。</target>
        </trans-unit>
        <trans-unit id="499cd7809be15aac9ff7cdcafa51d0930d0f78d9" translate="yes" xml:space="preserve">
          <source>For each contact, a single line is output, terminated by a newline. If the name is provided or known to the &lt;code&gt;mailmap&lt;/code&gt;, &amp;ldquo;Name &amp;lt;user@host&amp;gt;&amp;rdquo; is printed; otherwise only &amp;ldquo;&amp;lt;user@host&amp;gt;&amp;rdquo; is printed.</source>
          <target state="translated">对于每个触点，输出一行，并以换行符终止。如果该名称已提供或为 &lt;code&gt;mailmap&lt;/code&gt; 所知，则将打印 &amp;ldquo;名称&amp;lt;user @ host&amp;gt;&amp;rdquo;；否则，仅打印&amp;ldquo; &amp;lt;user @ host&amp;gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0e11740c89977d85e4dd98daa923a91e3f5130da" translate="yes" xml:space="preserve">
          <source>For each patch the code attempts to extract the author from the patch description. If that fails it falls back to the author specified with --author. If the --author flag was not given the patch description is displayed and the user is asked to interactively enter the author of the patch.</source>
          <target state="translated">对于每个补丁,代码会尝试从补丁描述中提取作者。如果失败了,就会回到用 --author 指定的作者。如果没有给定 --author 标志,则会显示补丁描述,并要求用户交互式地输入补丁的作者。</target>
        </trans-unit>
        <trans-unit id="5681283d451e4fc4fc0ca3089786f576c8a1186d" translate="yes" xml:space="preserve">
          <source>For each path &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called, two environment variables, &lt;code&gt;GIT_DIFF_PATH_COUNTER&lt;/code&gt; and &lt;code&gt;GIT_DIFF_PATH_TOTAL&lt;/code&gt; are set.</source>
          <target state="translated">对于每个路径 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; ，都设置了两个环境变量 &lt;code&gt;GIT_DIFF_PATH_COUNTER&lt;/code&gt; 和 &lt;code&gt;GIT_DIFF_PATH_TOTAL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17e261e522ccbc792cc7bd181c9a0bd755a56975" translate="yes" xml:space="preserve">
          <source>For each pathname given via the command-line or from a file via &lt;code&gt;--stdin&lt;/code&gt;, check whether the file is excluded by .gitignore (or other input files to the exclude mechanism) and output the path if it is excluded.</source>
          <target state="translated">对于通过命令行或通过 &lt;code&gt;--stdin&lt;/code&gt; 从文件中给定的每个路径名，请检查文件是否被.gitignore排除（或排除机制的其他输入文件），并输出该路径（如果已排除）。</target>
        </trans-unit>
        <trans-unit id="3b2b4e958456928c896ce5a2236319df3a467837" translate="yes" xml:space="preserve">
          <source>For each reference update that was added to the transaction, the hook receives on standard input a line of the format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b8eb760e478aaaedca171d489f16e4864063c9" translate="yes" xml:space="preserve">
          <source>For each repo that you want accessible from CVS you need to edit config in the repo and add the following section.</source>
          <target state="translated">对于每个你想从CVS访问的repo,你需要在repo中编辑config,并添加以下部分。</target>
        </trans-unit>
        <trans-unit id="4a6b07eab1d3f6d06954967f77b7754d8ea06736" translate="yes" xml:space="preserve">
          <source>For every branch that is up to date or successfully pushed, add upstream (tracking) reference, used by argument-less &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; and other commands. For more information, see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">对于每个最新的或成功推送的分支，请添加上游（跟踪）引用，该引用由无参数&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;和其他命令使用。有关详细信息，请参阅 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 在&lt;a href=&quot;git-config&quot;&gt;GIT-配置[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="288f34b4fe961722eeaf789d738c3abe79ce0128" translate="yes" xml:space="preserve">
          <source>For every pathname, this command will list if each attribute is &lt;code&gt;unspecified&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, or &lt;code&gt;unset&lt;/code&gt; as a gitattribute on that pathname.</source>
          <target state="translated">对于每个路径名，此命令将列出每个属性是否在该路径名上 &lt;code&gt;unspecified&lt;/code&gt; ， &lt;code&gt;set&lt;/code&gt; 或未 &lt;code&gt;unset&lt;/code&gt; 为gitattribute。</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">比如说</target>
        </trans-unit>
        <trans-unit id="b8684a0f4f3937af285df51bf478195b9b43d0d0" translate="yes" xml:space="preserve">
          <source>For example &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; by default (unless &lt;code&gt;--export-all&lt;/code&gt; option is used) allows pulling only for those repositories that have &lt;code&gt;git-daemon-export-ok&lt;/code&gt; file. Adding</source>
          <target state="translated">例如，默认情况下&lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt;（除非 &lt;code&gt;--export-all&lt;/code&gt; 选项）仅允许提取具有 &lt;code&gt;git-daemon-export-ok&lt;/code&gt; 文件的存储库。新增中</target>
        </trans-unit>
        <trans-unit id="46e0aea8ec6e607a64677afaf2a0016d08ab966a" translate="yes" xml:space="preserve">
          <source>For example David Miller wrote &lt;a href=&quot;#6&quot;&gt;[6]&lt;/a&gt;:</source>
          <target state="translated">例如，大卫&amp;middot;米勒（David Miller）写道&lt;a href=&quot;#6&quot;&gt;[6]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="0e389491903e64c421beccd08371ba327e60cc0c" translate="yes" xml:space="preserve">
          <source>For example an effect from the submodule&amp;rsquo;s &lt;code&gt;.gitignore&lt;/code&gt; file would be observed when you run &lt;code&gt;git status --ignore-submodules=none&lt;/code&gt; in the superproject. This collects information from the submodule&amp;rsquo;s working directory by running &lt;code&gt;status&lt;/code&gt; in the submodule while paying attention to the &lt;code&gt;.gitignore&lt;/code&gt; file of the submodule.</source>
          <target state="translated">例如，当您在超级项目中运行 &lt;code&gt;git status --ignore-submodules=none&lt;/code&gt; 时，将观察到子模块 &lt;code&gt;.gitignore&lt;/code&gt; 文件的效果。这将通过在子模块中运行 &lt;code&gt;status&lt;/code&gt; 来从子模块的工作目录中收集信息，同时注意子模块的 &lt;code&gt;.gitignore&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="56e9b1c030d9ba0ed8f301bc4d928b5ec348ecfb" translate="yes" xml:space="preserve">
          <source>For example if commit &lt;code&gt;foo&lt;/code&gt; has been replaced by commit &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">例如，如果将 &lt;code&gt;foo&lt;/code&gt; 替换为commit &lt;code&gt;bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fc4ffa566856e8487717cc75478e8ddebf738773" translate="yes" xml:space="preserve">
          <source>For example if repositories you are hosting use &quot;phtml&quot; extension for PHP files, and you want to have correct syntax-highlighting for those files, you can add the following to gitweb configuration:</source>
          <target state="translated">例如,如果你的版本库使用 &quot;phtml &quot;作为PHP文件的扩展名,而你想让这些文件有正确的语法高亮显示,你可以在gitweb配置中添加以下内容。</target>
        </trans-unit>
        <trans-unit id="5154cf5119ca3a0384ad194cc198ec59c07c7ac1" translate="yes" xml:space="preserve">
          <source>For example if we start with a graph like this:</source>
          <target state="translated">例如,如果我们从这样的图形开始。</target>
        </trans-unit>
        <trans-unit id="011e69a8d88e3f2ecd0b2c97750e695437a8b7be" translate="yes" xml:space="preserve">
          <source>For example one branch can change the semantic of a function while the other branch add more calls to the same function.</source>
          <target state="translated">例如,一个分支可以改变一个函数的语义,而另一个分支则为同一个函数增加更多的调用。</target>
        </trans-unit>
        <trans-unit id="948250d1153d7a9c5c187de68da76cbf9fe7a0b6" translate="yes" xml:space="preserve">
          <source>For example since all normal branches are stored under &lt;code&gt;refs/heads/&lt;/code&gt; name the tag fixup branch &lt;code&gt;TAG_FIXUP&lt;/code&gt;. This way it is impossible for the fixup branch used by the importer to have namespace conflicts with real branches imported from the source (the name &lt;code&gt;TAG_FIXUP&lt;/code&gt; is not &lt;code&gt;refs/heads/TAG_FIXUP&lt;/code&gt;).</source>
          <target state="translated">例如，由于所有常规分支都存储在 &lt;code&gt;refs/heads/&lt;/code&gt; 名称下，因此标签fixup分支 &lt;code&gt;TAG_FIXUP&lt;/code&gt; 。这样，导入程序所使用的fixup分支就不可能与从源导入的真实分支发生名称空间冲突（名称 &lt;code&gt;TAG_FIXUP&lt;/code&gt; 不是 &lt;code&gt;refs/heads/TAG_FIXUP&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4be01aa529e151bdbbe73a5ece143631e964e4ac" translate="yes" xml:space="preserve">
          <source>For example some test suites could be run automatically at night with some unusual (or even random) configurations. And if a regression is found by a test suite, then &quot;git bisect&quot; can be automatically launched, and its result can be emailed to the author of the first bad commit found by &quot;git bisect&quot;, and perhaps other people too. And a new entry in the bug tracking system could be automatically created too.</source>
          <target state="translated">比如一些测试套件可以在晚上自动运行一些异常(甚至是随机)的配置。如果一个测试套件发现了回归,那么 &quot;git bisect &quot;可以自动启动,其结果可以通过电子邮件发给 &quot;git bisect &quot;发现的第一个坏提交的作者,也许还有其他人。而且还可以在错误跟踪系统中自动创建一个新的条目。</target>
        </trans-unit>
        <trans-unit id="8bbfe98ebcd584e72bba80caca0bbe3de761fb8b" translate="yes" xml:space="preserve">
          <source>For example using:</source>
          <target state="translated">例如使用:</target>
        </trans-unit>
        <trans-unit id="b2715e2afcd57211e00aecf4fa8f8efd172203eb" translate="yes" xml:space="preserve">
          <source>For example with the following graph where H is the &quot;bad&quot; commit and A and D are some parents of some &quot;good&quot; commits:</source>
          <target state="translated">比如下面这个图,H是 &quot;坏 &quot;的提交,A和D是一些 &quot;好 &quot;的提交的父代。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="33f7a1b1f9148ad49a81c77432db9d624e3ed14b" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--batch&lt;/code&gt; without a custom format would produce:</source>
          <target state="translated">例如，没有自定义格式的 &lt;code&gt;--batch&lt;/code&gt; 将产生：</target>
        </trans-unit>
        <trans-unit id="f103141294055917b49b4ff3b11f28f0e7b09a93" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--cherry-pick --right-only A...B&lt;/code&gt; omits those commits from &lt;code&gt;B&lt;/code&gt; which are in &lt;code&gt;A&lt;/code&gt; or are patch-equivalent to a commit in &lt;code&gt;A&lt;/code&gt;. In other words, this lists the &lt;code&gt;+&lt;/code&gt; commits from &lt;code&gt;git cherry A B&lt;/code&gt;. More precisely, &lt;code&gt;--cherry-pick --right-only --no-merges&lt;/code&gt; gives the exact list.</source>
          <target state="translated">例如， &lt;code&gt;--cherry-pick --right-only A...B&lt;/code&gt; 省略了从这些提交 &lt;code&gt;B&lt;/code&gt; 它们是 &lt;code&gt;A&lt;/code&gt; 或是补丁相当于犯 &lt;code&gt;A&lt;/code&gt; 。换句话说，这列出了 &lt;code&gt;git cherry A B&lt;/code&gt; 的 &lt;code&gt;+&lt;/code&gt; 提交。更准确地说，-- &lt;code&gt;--cherry-pick --right-only --no-merges&lt;/code&gt; 给出了确切的列表。</target>
        </trans-unit>
        <trans-unit id="f8a58c9ab1aebec2fe76ee8cb4f7dc47b3afba08" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--word-diff-regex=.&lt;/code&gt; will treat each character as a word and, correspondingly, show differences character by character.</source>
          <target state="translated">例如，-- &lt;code&gt;--word-diff-regex=.&lt;/code&gt; 会将每个字符视为一个单词，并相应地逐字符显示差异。</target>
        </trans-unit>
        <trans-unit id="9497e805114a62dd0cfbb0fd446cb80188b76834" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;git bisect reset bisect/bad&lt;/code&gt; will check out the first bad revision, while &lt;code&gt;git bisect reset HEAD&lt;/code&gt; will leave you on the current bisection commit and avoid switching commits at all.</source>
          <target state="translated">例如， &lt;code&gt;git bisect reset bisect/bad&lt;/code&gt; 将签出第一个错误的修订版，而 &lt;code&gt;git bisect reset HEAD&lt;/code&gt; 将使您进入当前的二分提交，而根本避免切换提交。</target>
        </trans-unit>
        <trans-unit id="fe1483bfc3665f725dee6688f5887a817d1f226c" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;main-worktree/HEAD&lt;/code&gt; or &lt;code&gt;main-worktree/refs/bisect/good&lt;/code&gt; resolve to the same value as the main working tree&amp;rsquo;s &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;refs/bisect/good&lt;/code&gt; respectively. Similarly, &lt;code&gt;worktrees/foo/HEAD&lt;/code&gt; or &lt;code&gt;worktrees/bar/refs/bisect/bad&lt;/code&gt; are the same as &lt;code&gt;$GIT_COMMON_DIR/worktrees/foo/HEAD&lt;/code&gt; and &lt;code&gt;$GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="138442d2b65de29c2047a8caafb4d9bebbf214b3" translate="yes" xml:space="preserve">
          <source>For example, Documentation/*.jpg will match all .jpg files in the Documentation subtree, including Documentation/chapter_1/figure_1.jpg.</source>
          <target state="translated">例如,Documentation/*.jpg将匹配Documentation子树中的所有.jpg文件,包括Documentation/chapter_1/figure_1.jpg。</target>
        </trans-unit>
        <trans-unit id="0d743ee5b8f526c69043aec1a6e6a8e47be44f66" translate="yes" xml:space="preserve">
          <source>For example, Microsoft Visual Studio resources files (&lt;code&gt;*.rc&lt;/code&gt;) or PowerShell script files (&lt;code&gt;*.ps1&lt;/code&gt;) are sometimes encoded in UTF-16. If you declare &lt;code&gt;*.ps1&lt;/code&gt; as files as UTF-16 and you add &lt;code&gt;foo.ps1&lt;/code&gt; with a &lt;code&gt;working-tree-encoding&lt;/code&gt; enabled Git client, then &lt;code&gt;foo.ps1&lt;/code&gt; will be stored as UTF-8 internally. A client without &lt;code&gt;working-tree-encoding&lt;/code&gt; support will checkout &lt;code&gt;foo.ps1&lt;/code&gt; as UTF-8 encoded file. This will typically cause trouble for the users of this file.</source>
          <target state="translated">例如，Microsoft Visual Studio资源文件（ &lt;code&gt;*.rc&lt;/code&gt; ）或PowerShell脚本文件（ &lt;code&gt;*.ps1&lt;/code&gt; ）有时使用UTF-16编码。如果将 &lt;code&gt;*.ps1&lt;/code&gt; 声明为UTF-16文件，并添加 &lt;code&gt;foo.ps1&lt;/code&gt; 了 &lt;code&gt;working-tree-encoding&lt;/code&gt; Git客户端 &lt;code&gt;foo.ps1&lt;/code&gt; ，则foo.ps1将在内部存储为UTF-8。不支持 &lt;code&gt;working-tree-encoding&lt;/code&gt; 客户端会将 &lt;code&gt;foo.ps1&lt;/code&gt; 检出为UTF-8编码文件。这通常会给该文件的用户带来麻烦。</target>
        </trans-unit>
        <trans-unit id="1ed869792207741cfe6bed98106c7b8b8a3d4f0d" translate="yes" xml:space="preserve">
          <source>For example, a patch that talks about updating &lt;code&gt;a/git-gui.sh&lt;/code&gt; to &lt;code&gt;b/git-gui.sh&lt;/code&gt; can be applied to the file in the working tree &lt;code&gt;modules/git-gui/git-gui.sh&lt;/code&gt; by running &lt;code&gt;git apply --directory=modules/git-gui&lt;/code&gt;.</source>
          <target state="translated">例如，可以通过运行 &lt;code&gt;git apply --directory=modules/git-gui&lt;/code&gt; &lt;code&gt;a/git-gui.sh&lt;/code&gt; 将 &lt;code&gt;b/git-gui.sh&lt;/code&gt; 更新为b / git-gui.sh的补丁应用于工作树 &lt;code&gt;modules/git-gui/git-gui.sh&lt;/code&gt; /git-gui/git-gui.sh中的文件- -directory = modules / git-gui。</target>
        </trans-unit>
        <trans-unit id="ce77d8f6da94ff85eab04ae4cdac09d8840be36a" translate="yes" xml:space="preserve">
          <source>For example, a pattern &lt;code&gt;doc/frotz/&lt;/code&gt; matches &lt;code&gt;doc/frotz&lt;/code&gt; directory, but not &lt;code&gt;a/doc/frotz&lt;/code&gt; directory; however &lt;code&gt;frotz/&lt;/code&gt; matches &lt;code&gt;frotz&lt;/code&gt; and &lt;code&gt;a/frotz&lt;/code&gt; that is a directory (all paths are relative from the &lt;code&gt;.gitignore&lt;/code&gt; file).</source>
          <target state="translated">例如，模式 &lt;code&gt;doc/frotz/&lt;/code&gt; 匹配 &lt;code&gt;doc/frotz&lt;/code&gt; 目录，但不匹配 &lt;code&gt;a/doc/frotz&lt;/code&gt; 目录；但是 &lt;code&gt;frotz/&lt;/code&gt; 匹配 &lt;code&gt;frotz&lt;/code&gt; 和 &lt;code&gt;a/frotz&lt;/code&gt; （所有路径都是 &lt;code&gt;.gitignore&lt;/code&gt; 文件的相对路径）。</target>
        </trans-unit>
        <trans-unit id="67b1d0bce407e8b4870f6f6a95250837544f5b7b" translate="yes" xml:space="preserve">
          <source>For example, an attempt to rearrange</source>
          <target state="translated">例如,试图重新排列</target>
        </trans-unit>
        <trans-unit id="5bf319ce2803b376c46250398e2ab2c650bad072" translate="yes" xml:space="preserve">
          <source>For example, at the time this page was written, the &lt;a href=&quot;http://repo.or.cz&quot;&gt;http://repo.or.cz&lt;/a&gt; Git hosting site set it to the following to enable graphical log (using the third party tool &lt;strong&gt;git-browser&lt;/strong&gt;):</source>
          <target state="translated">例如，在编写此页面时，&lt;a href=&quot;http://repo.or.cz&quot;&gt;http：&lt;/a&gt; //repo.or.cz Git托管站点将其设置为以下内容以启用图形日志（使用第三方工具&lt;strong&gt;git-browser&lt;/strong&gt;）：</target>
        </trans-unit>
        <trans-unit id="ff9841351106eb72affbaa34cd9000cbe695e6c0" translate="yes" xml:space="preserve">
          <source>For example, consider a git repository containing:</source>
          <target state="translated">例如,考虑一个包含以下内容的git仓库。</target>
        </trans-unit>
        <trans-unit id="aa3e19341d33b69e0c7637f09cb4c872d477e052" translate="yes" xml:space="preserve">
          <source>For example, for the above graph, a command like:</source>
          <target state="translated">例如,对于上面的图形,可以使用如下命令。</target>
        </trans-unit>
        <trans-unit id="e5fffc70646f6a27f7f67e5894c9b6fc5ccd683b" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;$projectroot&lt;/code&gt; is set to &quot;/srv/git&quot; by putting the following in gitweb config file:</source>
          <target state="translated">例如，如果通过将以下内容放入gitweb配置文件中，将 &lt;code&gt;$projectroot&lt;/code&gt; 设置为&amp;ldquo; / srv / git&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="852dc3836c1061d866e063a7498878f33ef3ce12" translate="yes" xml:space="preserve">
          <source>For example, if the P4 repository structure is:</source>
          <target state="translated">例如,如果P4库的结构是。</target>
        </trans-unit>
        <trans-unit id="36dce8b0d031af7904e6cd8255529f9ec8396929" translate="yes" xml:space="preserve">
          <source>For example, if the file you want to change is some sort of config file, the repository can include a sample config file that can then be copied into the ignored name and modified. The repository can even include a script to treat the sample file as a template, modifying and copying it automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4035b3eacf18f396eb5e00ae6815d18cf72feae5" translate="yes" xml:space="preserve">
          <source>For example, if the value for this option is &quot;%=$&quot;, then only lines using the format &lt;code&gt;&amp;lt;token&amp;gt;&amp;lt;sep&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt; with &amp;lt;sep&amp;gt; containing &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; and then spaces will be considered trailers. And &lt;code&gt;%&lt;/code&gt; will be the default separator used, so by default trailers will appear like: &lt;code&gt;&amp;lt;token&amp;gt;% &amp;lt;value&amp;gt;&lt;/code&gt; (one percent sign and one space will appear between the token and the value).</source>
          <target state="translated">例如，如果此选项的值为&amp;ldquo;％= $&amp;rdquo;，则仅将格式为 &lt;code&gt;&amp;lt;token&amp;gt;&amp;lt;sep&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt; 且&amp;lt;sep&amp;gt;包含 &lt;code&gt;%&lt;/code&gt; ， &lt;code&gt;=&lt;/code&gt; 或 &lt;code&gt;$&lt;/code&gt; 的行视为空格。并且 &lt;code&gt;%&lt;/code&gt; 将是默认使用的分隔符，因此默认情况下，尾部将显示为： &lt;code&gt;&amp;lt;token&amp;gt;% &amp;lt;value&amp;gt;&lt;/code&gt; （令牌和值之间将出现一个百分号和一个空格）。</target>
        </trans-unit>
        <trans-unit id="534223d4530dd35132999074203db95c4ecee123" translate="yes" xml:space="preserve">
          <source>For example, if this variable is set to &quot;refs/for&quot;, pushing to reference such as &quot;refs/for/master&quot; will not create or update a reference named &quot;refs/for/master&quot;, but may create or update a pull request directly by running the hook &quot;proc-receive&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5103535d9f29750b8c9135f826c57c311f8eeae1" translate="yes" xml:space="preserve">
          <source>For example, if we want a password for &lt;code&gt;https://example.com/foo.git&lt;/code&gt;, we might generate the following credential description (don&amp;rsquo;t forget the blank line at the end; it tells &lt;code&gt;git credential&lt;/code&gt; that the application finished feeding all the information it has):</source>
          <target state="translated">例如，如果我们想要 &lt;code&gt;https://example.com/foo.git&lt;/code&gt; 的密码，我们可能会生成以下凭证描述（不要忘了最后的空行；它告诉 &lt;code&gt;git credential&lt;/code&gt; 应用程序完成了所有输入它具有的信息）：</target>
        </trans-unit>
        <trans-unit id="bb2f882b3f8efdae1333b719a705576641ca3f31" translate="yes" xml:space="preserve">
          <source>For example, if you are looking for a commit that introduced a performance regression, you might use</source>
          <target state="translated">例如,如果您正在寻找一个引入性能回归的提交,您可以使用</target>
        </trans-unit>
        <trans-unit id="68d306989ac898943c9324c1636692924527fd1d" translate="yes" xml:space="preserve">
          <source>For example, if you have this topology:</source>
          <target state="translated">例如,如果你有这样的拓扑结构。</target>
        </trans-unit>
        <trans-unit id="a61cdb8cd8334eeef24d9dfefb310bcbd689195c" translate="yes" xml:space="preserve">
          <source>For example, if you have two branches, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, a usual way to list all commits on only one side of them is with &lt;code&gt;--left-right&lt;/code&gt; (see the example below in the description of the &lt;code&gt;--left-right&lt;/code&gt; option). However, it shows the commits that were cherry-picked from the other branch (for example, &amp;ldquo;3rd on b&amp;rdquo; may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output.</source>
          <target state="translated">例如，如果您有两个分支 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ，则仅在它们的一侧列出所有提交的常用方法是使用 &lt;code&gt;--left-right&lt;/code&gt; （请参阅下面的示例，在 &lt;code&gt;--left-right&lt;/code&gt; 选项的说明中） 。但是，它显示的是从另一个分支挑选的提交（例如，&amp;ldquo; 3rd on b&amp;rdquo;可能是从分支A挑选的）。使用此选项，这样的提交对将从输出中排除。</target>
        </trans-unit>
        <trans-unit id="fe897c525854ed4ff520e569183f4547ca07cbf6" translate="yes" xml:space="preserve">
          <source>For example, if you use mod_perl to run the script, and have dumb HTTP protocol authentication configured for your repositories, you can use the following hook to allow access only if the user is authorized to read the files:</source>
          <target state="translated">例如,如果你使用mod_perl运行脚本,并为你的仓库配置了哑巴HTTP协议认证,你可以使用下面的钩子,只有当用户被授权读取文件时才允许访问。</target>
        </trans-unit>
        <trans-unit id="86c7872b373de97c557b525ebe5143ba729f1f41" translate="yes" xml:space="preserve">
          <source>For example, if you want to reorder the last 5 commits, such that what was HEAD~4 becomes the new HEAD. To achieve that, you would call &lt;code&gt;git rebase&lt;/code&gt; like this:</source>
          <target state="translated">例如，如果要重新排序最后5次提交，则原来HEAD〜4成为新的HEAD。为此，您可以像这样调用 &lt;code&gt;git rebase&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3cb17626983b1627f4a677c41e03478d83711c28" translate="yes" xml:space="preserve">
          <source>For example, imagine you store the refs for each fork in &lt;code&gt;refs/virtual/ID&lt;/code&gt;, where &lt;code&gt;ID&lt;/code&gt; is a numeric identifier. You might then configure:</source>
          <target state="translated">例如，假设您将每个分叉的 &lt;code&gt;refs/virtual/ID&lt;/code&gt; 存储在refs / virtual / ID中，其中 &lt;code&gt;ID&lt;/code&gt; 是数字标识符。然后，您可以配置：</target>
        </trans-unit>
        <trans-unit id="30bbf60289c9238f0d33e5175010f4e252c9853c" translate="yes" xml:space="preserve">
          <source>For example, in .gitattributes, you would assign the &lt;code&gt;filter&lt;/code&gt; attribute for paths.</source>
          <target state="translated">例如，在.gitattributes中，您将为路径分配 &lt;code&gt;filter&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="c7b53804fabf5a8d611f469400f3d23e0cdaf582" translate="yes" xml:space="preserve">
          <source>For example, in a commit history like this:</source>
          <target state="translated">例如,在这样的提交历史中。</target>
        </trans-unit>
        <trans-unit id="806ca5f41259915dee6774976f8cdf13ec61deac" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say that you have worked on your working directory, updated some files in the index and are ready to commit. You want to see exactly &lt;strong&gt;what&lt;/strong&gt; you are going to commit, without having to write a new tree object and compare it that way, and to do that, you just do</source>
          <target state="translated">例如，假设您已经在工作目录中工作，更新了索引中的一些文件并准备提交。你想看看到底&lt;strong&gt;什么&lt;/strong&gt;你要提交，而无需编写一个新的树对象，并比较这种方式，要做到这一点，你只是做</target>
        </trans-unit>
        <trans-unit id="476c3fc4a50784809d3ca0defbcdf28a5bcb4395" translate="yes" xml:space="preserve">
          <source>For example, main-worktree/HEAD or main-worktree/refs/bisect/good resolve to the same value as the main working tree&amp;rsquo;s HEAD and refs/bisect/good respectively. Similarly, worktrees/foo/HEAD or worktrees/bar/refs/bisect/bad are the same as GIT_COMMON_DIR/worktrees/foo/HEAD and GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad.</source>
          <target state="translated">例如，main-worktree / HEAD或main-worktree / refs / bisect / good分别解析为与主工作树的HEAD和refs / bisect / good相同的值。同样，工作树/ foo / HEAD或工作树/ bar / refs / bisect / bad与GIT_COMMON_DIR / worktrees / foo / HEAD和GIT_COMMON_DIR / worktrees / bar / refs / bisect / bad相同。</target>
        </trans-unit>
        <trans-unit id="266db89f5ed370855ec231f0d9586be36c8c2a06" translate="yes" xml:space="preserve">
          <source>For example, running &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; generates this tree object from the index, stores it in the object database, and uses it as the tree object associated with the new commit.</source>
          <target state="translated">例如，运行&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;从索引生成此树对象，将其存储在对象数据库中，并将其用作与新提交关联的树对象。</target>
        </trans-unit>
        <trans-unit id="9241280c5dcf375f9e4ee8c8496a1f68f481ea18" translate="yes" xml:space="preserve">
          <source>For example, starting with this index:</source>
          <target state="translated">比如说,从这个指数开始。</target>
        </trans-unit>
        <trans-unit id="37236815fc65047678c9d53df59b5a94b9133df3" translate="yes" xml:space="preserve">
          <source>For example, the following fetch command spawned ssh, index-pack, rev-list, and gc. This example also shows that fetch took 5.199 seconds and of that 4.932 was in ssh.</source>
          <target state="translated">例如,下面的fetch命令产生了ssh、index-pack、rev-list和gc。这个例子还显示,fetch用了5.199秒,其中4.932秒在ssh中。</target>
        </trans-unit>
        <trans-unit id="675eb647719ee2ad2bd9af2ee96b8f7029195efd" translate="yes" xml:space="preserve">
          <source>For example, the following setting produces a breadcrumb trail like &quot;home / dev / projects / &amp;hellip;​&quot; where &quot;projects&quot; is the home link.</source>
          <target state="translated">例如，以下设置将生成痕迹痕迹，例如``home / dev / projects / ...''，其中``projects''是home链接。</target>
        </trans-unit>
        <trans-unit id="f229d0901b53da5a8037ba5b963ab5e1b0a84fc7" translate="yes" xml:space="preserve">
          <source>For example, the hook can simply run &lt;code&gt;git read-tree -u -m HEAD &quot;$1&quot;&lt;/code&gt; in order to emulate &lt;code&gt;git fetch&lt;/code&gt; that is run in the reverse direction with &lt;code&gt;git push&lt;/code&gt;, as the two-tree form of &lt;code&gt;git read-tree -u -m&lt;/code&gt; is essentially the same as &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt; that switches branches while keeping the local changes in the working tree that do not interfere with the difference between the branches.</source>
          <target state="translated">例如，该钩子可以简单地运行 &lt;code&gt;git read-tree -u -m HEAD &quot;$1&quot;&lt;/code&gt; 来模拟以 &lt;code&gt;git push&lt;/code&gt; 在相反方向上运行的 &lt;code&gt;git fetch&lt;/code&gt; ，作为 &lt;code&gt;git read-tree -u -m&lt;/code&gt; 的两树形式-m本质上与 &lt;code&gt;git switch&lt;/code&gt; 或 &lt;code&gt;git checkout&lt;/code&gt; 相同，后者在保持工作树中的本地更改不干扰分支之间的差异的同时切换分支。</target>
        </trans-unit>
        <trans-unit id="2232af53268b39393df426da2516589a0d0a00e9" translate="yes" xml:space="preserve">
          <source>For example, the multithreaded preload-index code can be instrumented with a region around the thread pool and then per-thread start and exit events within the threadproc.</source>
          <target state="translated">例如,多线程预加载-索引代码可以用线程池周围的区域进行检测,然后在线程proc内进行每线程的启动和退出事件。</target>
        </trans-unit>
        <trans-unit id="c6165309453e90635fafde69fa6a0dbf363059c7" translate="yes" xml:space="preserve">
          <source>For example, there can be a &quot;main&quot; branch, and a &quot;dev&quot; branch that was forked of the main branch at a commit named &quot;D&quot; like this:</source>
          <target state="translated">例如,可以有一个 &quot;main &quot;分支,还有一个 &quot;dev &quot;分支,它是在主分支的基础上分叉出来的,提交时命名为 &quot;D&quot;,就像这样。</target>
        </trans-unit>
        <trans-unit id="fc0695ddae75754b17aaf6b6d741676357b02fb6" translate="yes" xml:space="preserve">
          <source>For example, this configuration:</source>
          <target state="translated">比如说,这个配置。</target>
        </trans-unit>
        <trans-unit id="03526c1b7e3b294cd55189c8a4305129233dcf64" translate="yes" xml:space="preserve">
          <source>For example, this line in &lt;code&gt;.gitattributes&lt;/code&gt; can be used to tell the merge machinery to leave much longer (instead of the usual 7-character-long) conflict markers when merging the file &lt;code&gt;Documentation/git-merge.txt&lt;/code&gt; results in a conflict.</source>
          <target state="translated">例如，当合并文件 &lt;code&gt;Documentation/git-merge.txt&lt;/code&gt; 导致冲突时， &lt;code&gt;.gitattributes&lt;/code&gt; 中的这一行可用于告诉合并机制留下更长的时间（而不是通常的7个字符长）的冲突标记。</target>
        </trans-unit>
        <trans-unit id="0b89cc0f3038d951dcea25e6121459d7deb13668" translate="yes" xml:space="preserve">
          <source>For example, to default to pushing only the current branch to &lt;code&gt;origin&lt;/code&gt; use &lt;code&gt;git config remote.origin.push HEAD&lt;/code&gt;. Any valid &amp;lt;refspec&amp;gt; (like the ones in the examples below) can be configured as the default for &lt;code&gt;git push origin&lt;/code&gt;.</source>
          <target state="translated">例如，默认为仅将当前分支推送到 &lt;code&gt;origin&lt;/code&gt; 使用 &lt;code&gt;git config remote.origin.push HEAD&lt;/code&gt; 。可以将任何有效的&amp;lt;refspec&amp;gt;（如以下示例中的那些）配置为 &lt;code&gt;git push origin&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="119ea88469245e9be5ce50fb433af7f4a91870c1" translate="yes" xml:space="preserve">
          <source>For example, to show the diff of the exif information of a file instead of the binary information (assuming you have the exif tool installed), add the following section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file):</source>
          <target state="translated">例如，要显示文件的exif信息的差异而不是二进制信息（假设您已安装exif工具），请将以下部分添加到 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件（或 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 文件）中：</target>
        </trans-unit>
        <trans-unit id="7996ef34273d5eb8d30c25fa5552327664d83956" translate="yes" xml:space="preserve">
          <source>For example, we could run maintenance on each of a list of repositories stored in a &lt;code&gt;maintenance.repo&lt;/code&gt; config variable using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf3c72a4130dae24f8e93d376c795356d04a806" translate="yes" xml:space="preserve">
          <source>For example, with this topology:</source>
          <target state="translated">例如,在这种拓扑结构下。</target>
        </trans-unit>
        <trans-unit id="9026d38d92fad70bfcca633c7e54419876aa74d7" translate="yes" xml:space="preserve">
          <source>For example, with this:</source>
          <target state="translated">比如说,有了这个。</target>
        </trans-unit>
        <trans-unit id="94a38b75a57da5e0f9eccf5408c94c3056500ecd" translate="yes" xml:space="preserve">
          <source>For example, you can choose a single person to maintain the project&amp;rsquo;s primary public repository. Other developers then clone this repository and each work in their own clone. When they have a series of changes that they&amp;rsquo;re happy with, they ask the maintainer to pull from the branch containing the changes. The maintainer reviews their changes and pulls them into the primary repository, which other developers pull from as necessary to stay coordinated. The Linux kernel and other projects use variants of this model.</source>
          <target state="translated">例如，您可以选择一个人来维护项目的主要公共资源库。然后其他开发人员克隆此存储库，每个人都在自己的克隆中工作。当他们对一系列更改感到满意时，他们要求维护者从包含更改的分支中撤出。维护者检查他们的更改并将其存储到主存储库中，其他开发人员可根据需要从主存储库中获取该存储库以保持协调。Linux内核和其他项目使用此模型的变体。</target>
        </trans-unit>
        <trans-unit id="0740e14a7a7f21956f0379ce28c5b2be003ef53b" translate="yes" xml:space="preserve">
          <source>For example, you&amp;rsquo;d want to do this after doing a &lt;code&gt;git read-tree&lt;/code&gt;, to link up the stat index details with the proper files.</source>
          <target state="translated">例如，您要在执行 &lt;code&gt;git read-tree&lt;/code&gt; 之后执行此操作，以将stat索引详细信息与适当的文件链接起来。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="0af803cded757214a9f60d6e61360566eb8261f1" translate="yes" xml:space="preserve">
          <source>For git&amp;rsquo;s pre-defined color slots, the attributes are meant to be reset at the beginning of each item in the colored output. So setting &lt;code&gt;color.decorate.branch&lt;/code&gt; to &lt;code&gt;black&lt;/code&gt; will paint that branch name in a plain &lt;code&gt;black&lt;/code&gt;, even if the previous thing on the same output line (e.g. opening parenthesis before the list of branch names in &lt;code&gt;log --decorate&lt;/code&gt; output) is set to be painted with &lt;code&gt;bold&lt;/code&gt; or some other attribute. However, custom log formats may do more complicated and layered coloring, and the negated forms may be useful there.</source>
          <target state="translated">对于git的预定义颜色插槽，应在彩色输出中每个项目的开头重置属性。因此，将 &lt;code&gt;color.decorate.branch&lt;/code&gt; 设置为 &lt;code&gt;black&lt;/code&gt; 会将该分支名称涂成纯 &lt;code&gt;black&lt;/code&gt; ，即使同一输出行上的前一个内容（例如，在 &lt;code&gt;log --decorate&lt;/code&gt; 输出中的分支名称列表之前打开括号）也设置为涂上 &lt;code&gt;bold&lt;/code&gt; 或其他属性。但是，自定义日志格式可能会进行更复杂和分层的着色，而否定的形式可能会有用。</target>
        </trans-unit>
        <trans-unit id="e39902dddf1a6f048d53b1c87575ee4b12254521" translate="yes" xml:space="preserve">
          <source>For hints on submission using the IMAP interface, see the EXAMPLE section of &lt;a href=&quot;git-imap-send&quot;&gt;git-imap-send[1]&lt;/a&gt;.</source>
          <target state="translated">有关使用IMAP界面提交的提示，请参见&lt;a href=&quot;git-imap-send&quot;&gt;git-imap-send [1]&lt;/a&gt;的示例部分。</target>
        </trans-unit>
        <trans-unit id="30ba9877f29cd2e9b6e46df54ef9603700cf47bd" translate="yes" xml:space="preserve">
          <source>For hints on using &lt;code&gt;git send-email&lt;/code&gt; to send your patches through the GMail SMTP server, see the EXAMPLE section of &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;.</source>
          <target state="translated">有关使用 &lt;code&gt;git send-email&lt;/code&gt; 通过GMail SMTP服务器发送补丁的提示，请参见&lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt;的示例部分。</target>
        </trans-unit>
        <trans-unit id="98a5ba2755b886f28a6b38a3063fb22b4953fd08" translate="yes" xml:space="preserve">
          <source>For instance, if the command &lt;code&gt;git push origin master:foreign&lt;/code&gt; were run the hook would receive a line like the following:</source>
          <target state="translated">例如，如果运行命令 &lt;code&gt;git push origin master:foreign&lt;/code&gt; ,则该钩子将收到如下一行：</target>
        </trans-unit>
        <trans-unit id="b7654d69e08e0a1f9383662a9764223dc833d854" translate="yes" xml:space="preserve">
          <source>For instance, if the main working tree (or bare repository) is moved, linked working trees will be unable to locate it. Running &lt;code&gt;repair&lt;/code&gt; in the main working tree will reestablish the connection from linked working trees back to the main working tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0da88c77b6050a1f8498227b0e9ea61aad1dd42" translate="yes" xml:space="preserve">
          <source>For instance, if you configured the &lt;code&gt;diff.algorithm&lt;/code&gt; variable to a non-default value and want to use the default one, then you have to use &lt;code&gt;--diff-algorithm=default&lt;/code&gt; option.</source>
          <target state="translated">例如，如果您将 &lt;code&gt;diff.algorithm&lt;/code&gt; 变量配置为非默认值，并希望使用默认值，则必须使用 &lt;code&gt;--diff-algorithm=default&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="c03b6c2e674301ea043615909864bcef9fc3a8b4" translate="yes" xml:space="preserve">
          <source>For instance, imagine we are accessing &lt;code&gt;https://example.com/foo.git&lt;/code&gt;. When Git looks into a config file to see if a section matches this context, it will consider the two a match if the context is a more-specific subset of the pattern in the config file. For example, if you have this in your config file:</source>
          <target state="translated">例如，假设我们正在访问 &lt;code&gt;https://example.com/foo.git&lt;/code&gt; 。当Git查看配置文件以查看某节是否与此上下文匹配时，如果上下文是配置文件中模式的更特定子集，它将认为两者匹配。例如，如果您的配置文件中包含以下内容：</target>
        </trans-unit>
        <trans-unit id="160dca6e4172cec7a014617ee2140fea1d612055" translate="yes" xml:space="preserve">
          <source>For internal use only. Used in handshaking the wire protocol. Contains a colon &lt;code&gt;:&lt;/code&gt; separated list of keys with optional values &lt;code&gt;key[=value]&lt;/code&gt;. Presence of unknown keys and values must be ignored.</source>
          <target state="translated">仅限内部使用。用于握手协议。包含冒号 &lt;code&gt;:&lt;/code&gt; 包含可选值 &lt;code&gt;key[=value]&lt;/code&gt; 的键的分隔列表。必须忽略未知键和值的存在。</target>
        </trans-unit>
        <trans-unit id="7c3c8218b8f3420e2d309aa9107b8abd4e99e346" translate="yes" xml:space="preserve">
          <source>For local repositories, also supported by Git natively, the following syntaxes may be used:</source>
          <target state="translated">对于本地仓库,也是 Git 本身支持的,可以使用以下语法。</target>
        </trans-unit>
        <trans-unit id="cc185d3a233093301eeacaae1d44792c3563d415" translate="yes" xml:space="preserve">
          <source>For more detailed explanation on these common options, see also &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt;.</source>
          <target state="translated">有关这些常见选项的更多详细说明，另请参见&lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cfb518a2bdb468f6a1698c12278a7c2890c2e01b" translate="yes" xml:space="preserve">
          <source>For more details about the &amp;lt;pathspec&amp;gt; syntax, see the &lt;code&gt;pathspec&lt;/code&gt; entry in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">有关&amp;lt;pathspec&amp;gt;语法的更多详细信息，请参见&lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]中&lt;/a&gt;的 &lt;code&gt;pathspec&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="f0360b14fd2012ea432fadffcf3782c95bbb3d96" translate="yes" xml:space="preserve">
          <source>For more details, see the &lt;code&gt;pathspec&lt;/code&gt; entry in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]中&lt;/a&gt;的 &lt;code&gt;pathspec&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="dee223e709585f8622ae3db9c408c2275df286e3" translate="yes" xml:space="preserve">
          <source>For more information about submodules, see &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt;.</source>
          <target state="translated">有关子模块的更多信息，请参见&lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf4d0c9e8fd0a561af6eb800b4aa95d1953e08dc" translate="yes" xml:space="preserve">
          <source>For non-linear topology, such as</source>
          <target state="translated">对于非线性拓扑结构,如</target>
        </trans-unit>
        <trans-unit id="6869cf2d54fdd333756ee082074da9e8aa4cabf1" translate="yes" xml:space="preserve">
          <source>For now, the paranoid need to find some way to emulate the quarantine environment if they&amp;rsquo;d like the same protection as &quot;push&quot;. E.g. in the case of an internal mirror do the mirroring in two steps, one to fetch the untrusted objects, and then do a second &quot;push&quot; (which will use the quarantine) to another internal repo, and have internal clients consume this pushed-to repository, or embargo internal fetches and only allow them once a full &quot;fsck&quot; has run (and no new fetches have happened in the meantime).</source>
          <target state="translated">就目前而言，偏执狂需要找到某种方法来模拟隔离环境，如果他们想要与&amp;ldquo;推送&amp;rdquo;相同的保护。例如，如果是内部镜像，则分两步进行镜像，第一步是获取不受信任的对象，然后对另一个内部仓库执行第二次&amp;ldquo;推送&amp;rdquo;（将使用隔离区），并让内部客户端使用此推送-到存储库或禁止内部访存，并且仅在运行完整的&amp;ldquo; fsck&amp;rdquo;之后允许它们（并且在此期间未发生新的访存）。</target>
        </trans-unit>
        <trans-unit id="133fa5a74f060c815b7406a1ab993c4e06ad0024" translate="yes" xml:space="preserve">
          <source>For open source projects it can be a good way to get more useful contributions from end users, and to introduce them to QA and development activities.</source>
          <target state="translated">对于开源项目来说,从最终用户那里获得更多有用的贡献,并将他们介绍给QA和开发活动是一个很好的方式。</target>
        </trans-unit>
        <trans-unit id="dd41930f44da136ca06d3f66916ab11faa591b27" translate="yes" xml:space="preserve">
          <source>For our first example, we&amp;rsquo;re going to start a totally new repository from scratch, with no pre-existing files, and we&amp;rsquo;ll call it &lt;code&gt;git-tutorial&lt;/code&gt;. To start up, create a subdirectory for it, change into that subdirectory, and initialize the Git infrastructure with &lt;code&gt;git init&lt;/code&gt;:</source>
          <target state="translated">对于第一个示例，我们将从头开始一个全新的存储库，不包含任何预先存在的文件，我们将其称为 &lt;code&gt;git-tutorial&lt;/code&gt; 。首先，为其创建一个子目录，切换到该子目录，然后使用 &lt;code&gt;git init&lt;/code&gt; 初始化Git基础架构：</target>
        </trans-unit>
        <trans-unit id="5307fd3985478faa6faac86f16463cb9c367c366" translate="yes" xml:space="preserve">
          <source>For paths with merge conflicts, &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; show the modification states of each side of the merge. For paths that do not have merge conflicts, &lt;code&gt;X&lt;/code&gt; shows the status of the index, and &lt;code&gt;Y&lt;/code&gt; shows the status of the work tree. For untracked paths, &lt;code&gt;XY&lt;/code&gt; are &lt;code&gt;??&lt;/code&gt;. Other status codes can be interpreted as follows:</source>
          <target state="translated">对于具有合并冲突的路径， &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;Y&lt;/code&gt; 显示合并每一侧的修改状态。对于没有合并冲突的路径， &lt;code&gt;X&lt;/code&gt; 显示索引状态， &lt;code&gt;Y&lt;/code&gt; 显示工作树状态。对于未跟踪的路径， &lt;code&gt;XY&lt;/code&gt; 为 &lt;code&gt;??&lt;/code&gt; 。。其他状态代码可以解释如下：</target>
        </trans-unit>
        <trans-unit id="7032989b4e615b54922dcaa29834b5d11069ae03" translate="yes" xml:space="preserve">
          <source>For people who do parsing: to make it more robust, just ignore any lines between the first and last one (&quot;&amp;lt;sha1&amp;gt;&quot; and &quot;filename&quot; lines) where you do not recognize the tag words (or care about that particular one) at the beginning of the &quot;extended information&quot; lines. That way, if there is ever added information (like the commit encoding or extended commit commentary), a blame viewer will not care.</source>
          <target state="translated">对于进行解析的人员：要使其更健壮，只需忽略第一行和最后一行之间的任何行（&amp;ldquo; &amp;lt;sha1&amp;gt;&amp;rdquo;和&amp;ldquo;文件名&amp;rdquo;行），在这些行中您不会识别标记词（或关心该特定词）在&amp;ldquo;扩展信息&amp;rdquo;行的开头。这样，如果曾经添加过任何信息（例如提交编码或扩展的提交注释），则责备查看器将不在乎。</target>
        </trans-unit>
        <trans-unit id="d3a8933e3664a281a0f1007219c1a5fb906f5b9c" translate="yes" xml:space="preserve">
          <source>For performance reasons, by default, &lt;code&gt;-C&lt;/code&gt; option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one &lt;code&gt;-C&lt;/code&gt; option has the same effect.</source>
          <target state="translated">出于性能原因，默认情况下， &lt;code&gt;-C&lt;/code&gt; 选项仅在副本的原始文件在同一变更集中被修改时才查找副本。该标志使命令检查未修改的文件作为副本源的候选对象。对于大型项目，这是非常昂贵的操作，因此请谨慎使用。提供多个 &lt;code&gt;-C&lt;/code&gt; 选项具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="9b9345e0345532d160619f268731569cef16617e" translate="yes" xml:space="preserve">
          <source>For plain blobs, it shows the plain contents.</source>
          <target state="translated">对于纯色斑块,它显示的是纯色内容。</target>
        </trans-unit>
        <trans-unit id="9e1c4f262d546f1a8d01796c1dc838262d4af7ed" translate="yes" xml:space="preserve">
          <source>For precedence rules within and between exclude sources, see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e52f5f667fd4d7c4b839fc8977488698f28dddb" translate="yes" xml:space="preserve">
          <source>For projects with few developers, or for synchronizing a few private repositories, this may be all you need.</source>
          <target state="translated">对于开发人员较少的项目,或者同步几个私有仓库,这可能是你所需要的。</target>
        </trans-unit>
        <trans-unit id="0fbf0a1225d8cd0da43e8dc6b186868e699b6219" translate="yes" xml:space="preserve">
          <source>For quickly making a snapshot, you can omit &quot;push&quot;. In this mode, non-option arguments are not allowed to prevent a misspelled subcommand from making an unwanted stash entry. The two exceptions to this are &lt;code&gt;stash -p&lt;/code&gt; which acts as alias for &lt;code&gt;stash push -p&lt;/code&gt; and pathspec elements, which are allowed after a double hyphen &lt;code&gt;--&lt;/code&gt; for disambiguation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513a986f0bbc369f77d7fc94a6a47375b99e8d89" translate="yes" xml:space="preserve">
          <source>For quickly making a snapshot, you can omit &quot;push&quot;. In this mode, non-option arguments are not allowed to prevent a misspelled subcommand from making an unwanted stash entry. The two exceptions to this are &lt;code&gt;stash -p&lt;/code&gt; which acts as alias for &lt;code&gt;stash push -p&lt;/code&gt; and pathspecs, which are allowed after a double hyphen &lt;code&gt;--&lt;/code&gt; for disambiguation.</source>
          <target state="translated">为了快速制作快照，您可以省略&amp;ldquo; push&amp;rdquo;。在这种模式下，不允许使用非选项参数来防止拼写错误的子命令产生不必要的隐藏项。这两个例外是 &lt;code&gt;stash -p&lt;/code&gt; ，它用作 &lt;code&gt;stash push -p&lt;/code&gt; 和pathspecs的别名，在双连字符后允许使用 &lt;code&gt;--&lt;/code&gt; 以消除歧义。</target>
        </trans-unit>
        <trans-unit id="10b29e2b2e8e16a8f0d937588e990a303d5a39cb" translate="yes" xml:space="preserve">
          <source>For reading options: read only from global &lt;code&gt;~/.gitconfig&lt;/code&gt; and from &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">对于读取选项：仅从全局 &lt;code&gt;~/.gitconfig&lt;/code&gt; 和 &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; 读取，而不是从所有可用文件中读取。</target>
        </trans-unit>
        <trans-unit id="f670c3a49f96ee071030446b2338be3d3b61c282" translate="yes" xml:space="preserve">
          <source>For reading options: read only from system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">对于读取选项：仅从系统范围的 &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; 而不是所有可用文件中读取。</target>
        </trans-unit>
        <trans-unit id="1a0b8cd1ef1778fc9e72b8ac1ede20b2c02305dd" translate="yes" xml:space="preserve">
          <source>For reading options: read only from the repository &lt;code&gt;.git/config&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">对于读取选项：仅从存储库 &lt;code&gt;.git/config&lt;/code&gt; 读取，而不从所有可用文件读取。</target>
        </trans-unit>
        <trans-unit id="52ad1818a91b579273748ec3f745c2ea8925da11" translate="yes" xml:space="preserve">
          <source>For remote helpers that implement &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt;, this capability allows the refs to be constrained to a private namespace, instead of writing to refs/heads or refs/remotes directly. It is recommended that all importers providing the &lt;code&gt;import&lt;/code&gt; capability use this. It&amp;rsquo;s mandatory for &lt;code&gt;export&lt;/code&gt;.</source>
          <target state="translated">对于实现 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;export&lt;/code&gt; 的远程帮助程序，此功能允许将引用限制为私有名称空间，而不是直接写给ref / heads或ref / remotes。建议所有提供 &lt;code&gt;import&lt;/code&gt; 功能的进口商都使用此功能。对 &lt;code&gt;export&lt;/code&gt; 是强制性的。</target>
        </trans-unit>
        <trans-unit id="443450d98036603164f83ff3df4c2bf679d11741" translate="yes" xml:space="preserve">
          <source>For remotes that require curl (http, https and ftp), the URL to the proxy to use for that remote. Set to the empty string to disable proxying for that remote.</source>
          <target state="translated">对于需要curl的远程(http、https和ftp),该远程要使用的代理URL。如果设置为空,则禁用该远程的代理。</target>
        </trans-unit>
        <trans-unit id="8af93420a9afb3e813edb57f9ce58a35a5de2989" translate="yes" xml:space="preserve">
          <source>For remotes that require curl (http, https and ftp), the method to use for authenticating against the proxy in use (probably set in &lt;code&gt;remote.&amp;lt;name&amp;gt;.proxy&lt;/code&gt;). See &lt;code&gt;http.proxyAuthMethod&lt;/code&gt;.</source>
          <target state="translated">对于需要curl的远程服务器（http，https和ftp），用于对使用中的代理进行身份验证的方法（可能在 &lt;code&gt;remote.&amp;lt;name&amp;gt;.proxy&lt;/code&gt; ）。请参阅 &lt;code&gt;http.proxyAuthMethod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff12c5f69e6a4dbe2b8b7bc739ac234198e179f4" translate="yes" xml:space="preserve">
          <source>For scripting, you can ask it to be quiet with the &quot;--quiet&quot; flag, which allows you to do things like</source>
          <target state="translated">对于脚本,你可以用&quot;--quiet &quot;标志让它安静下来,这可以让你做一些事情,如</target>
        </trans-unit>
        <trans-unit id="6ad68ca568ca7f00dfca41d4efe640136cb611e6" translate="yes" xml:space="preserve">
          <source>For some frontends, though, it is useful to be able to read back data from the current repository as it is being updated (for example when the source material describes objects in terms of patches to be applied to previously imported objects). This can be accomplished by connecting the frontend and fast-import via bidirectional pipes:</source>
          <target state="translated">不过对于一些前端来说,能够在更新时从当前存储库中读回数据是很有用的(例如当源材料以补丁的方式描述对象时,将其应用于之前导入的对象)。这可以通过双向管道连接前端和快速导入来实现。</target>
        </trans-unit>
        <trans-unit id="b5ea8ea5b2c1cd3e6d47c32a09c62d3c70b6ee6f" translate="yes" xml:space="preserve">
          <source>For some interesting examples of Git use, see the &lt;a href=&quot;howto-index&quot;&gt;howtos&lt;/a&gt;.</source>
          <target state="translated">有关Git使用的一些有趣示例，请参阅&lt;a href=&quot;howto-index&quot;&gt;howtos&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd917a632df420113bd1fa62c1a75d6d0838fcf8" translate="yes" xml:space="preserve">
          <source>For sorting purposes, fields with numeric values sort in numeric order (&lt;code&gt;objectsize&lt;/code&gt;, &lt;code&gt;authordate&lt;/code&gt;, &lt;code&gt;committerdate&lt;/code&gt;, &lt;code&gt;creatordate&lt;/code&gt;, &lt;code&gt;taggerdate&lt;/code&gt;). All other fields are used to sort in their byte-value order.</source>
          <target state="translated">出于排序目的，具有数字值的字段按数字顺序排序（ &lt;code&gt;objectsize&lt;/code&gt; ， &lt;code&gt;authordate&lt;/code&gt; ， &lt;code&gt;committerdate&lt;/code&gt; ， &lt;code&gt;creatordate&lt;/code&gt; 和 &lt;code&gt;taggerdate&lt;/code&gt; ）。所有其他字段均按其字节值顺序进行排序。</target>
        </trans-unit>
        <trans-unit id="032b282727ffc0c1c45df3e884598bae17ea6ac4" translate="yes" xml:space="preserve">
          <source>For specifying settings like &lt;code&gt;verbosity&lt;/code&gt; (how much output to write to stderr) and &lt;code&gt;depth&lt;/code&gt; (how much history is wanted in the case of a shallow clone) that affect how other commands are carried out.</source>
          <target state="translated">用于指定影响其他命令执行方式的设置，例如 &lt;code&gt;verbosity&lt;/code&gt; （向stderr写入多少输出）和 &lt;code&gt;depth&lt;/code&gt; （在浅克隆的情况下需要多少历史记录）。</target>
        </trans-unit>
        <trans-unit id="c02205be8f69628f646f89a0276ec82187cc890c" translate="yes" xml:space="preserve">
          <source>For submodules, this setting can be overridden using the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; config setting.</source>
          <target state="translated">对于子模块，可以使用 &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 配置设置来覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="c4b69b6e908fa58f8bfb0090b464d01ba7afd33a" translate="yes" xml:space="preserve">
          <source>For such a test, you need to merge master and topic somehow. One way to do it is to pull master into the topic branch:</source>
          <target state="translated">对于这样的测试,你需要以某种方式将master和topic合并。一种方法是将master拉入topic分支。</target>
        </trans-unit>
        <trans-unit id="e3a970f50f86b7e372ecc38ba0a4b965f601d385" translate="yes" xml:space="preserve">
          <source>For tags, it shows the tag message and the referenced objects.</source>
          <target state="translated">对于标签,它显示标签信息和被引用的对象。</target>
        </trans-unit>
        <trans-unit id="e66e4764a23ddc1ac17a40208b614c40e3d1e8cd" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;squash&lt;/code&gt; and &lt;code&gt;fixup&lt;/code&gt; operation, all commits that were squashed are listed as being rewritten to the squashed commit. This means that there will be several lines sharing the same &lt;code&gt;new-sha1&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;squash&lt;/code&gt; 和 &lt;code&gt;fixup&lt;/code&gt; 操作，所有被压扁的提交都将被重写为被压扁的提交。这意味着将有几条线共享相同的 &lt;code&gt;new-sha1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0288085d533925ac75b1f295d9e834640d8fad16" translate="yes" xml:space="preserve">
          <source>For the complete list of paths which Git checks for references, and the order it uses to decide which to choose when there are multiple references with the same shorthand name, see the &quot;SPECIFYING REVISIONS&quot; section of &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">有关Git检查引用的路径的完整列表，以及当存在多个具有相同速记名称的引用时，它用来决定选择哪个顺序的顺序，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]的&lt;/a&gt; &amp;ldquo; SPECIFYING REVISIONS&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="44d025151b0ff5e996c1070f067a89933eee64e1" translate="yes" xml:space="preserve">
          <source>For the initial import, &lt;code&gt;git archimport&lt;/code&gt; expects to find itself in an empty directory. To follow the development of a project that uses Arch, rerun &lt;code&gt;git archimport&lt;/code&gt; with the same parameters as the initial import to perform incremental imports.</source>
          <target state="translated">对于初始导入， &lt;code&gt;git archimport&lt;/code&gt; 期望在一个空目录中找到自己。要跟踪使用Arch的项目的开发，请使用与初始导入相同的参数重新运行 &lt;code&gt;git archimport&lt;/code&gt; ，以执行增量导入。</target>
        </trans-unit>
        <trans-unit id="c91c81358174e9b87a92bafd019b5720cbf2a8d2" translate="yes" xml:space="preserve">
          <source>For the purpose of breaking a filepair, diffcore-break examines the extent of changes between the contents of the files before and after modification (i.e. the contents that have &quot;bcd1234&amp;hellip;​&quot; and &quot;0123456&amp;hellip;​&quot; as their SHA-1 content ID, in the above example). The amount of deletion of original contents and insertion of new material are added together, and if it exceeds the &quot;break score&quot;, the filepair is broken into two. The break score defaults to 50% of the size of the smaller of the original and the result (i.e. if the edit shrinks the file, the size of the result is used; if the edit lengthens the file, the size of the original is used), and can be customized by giving a number after &quot;-B&quot; option (e.g. &quot;-B75&quot; to tell it to use 75%).</source>
          <target state="translated">为了破坏文件对，diffcore-break在修改前后检查文件内容之间的变化程度（即，以&amp;ldquo; bcd1234&amp;hellip;&amp;rdquo;和&amp;ldquo; 0123456 ...&amp;rdquo;作为SHA-1内容ID的内容） ，在上面的示例中）。原始内容的删除量和新材料的插入量加在一起，并且如果超过&amp;ldquo;中断得分&amp;rdquo;，则文件对将分为两部分。断裂分数默认为原始值和结果较小值的50％（即，如果编辑缩小文件，则使用结果的大小；如果编辑使文件变长，则使用原始值的大小） ），并且可以通过在&amp;ldquo; -B&amp;rdquo;选项后加一个数字进行自定义（例如，&amp;ldquo;-B75&amp;rdquo;表示要使用75％）。</target>
        </trans-unit>
        <trans-unit id="62f1a958bc660b7d22544723f673271098befa81" translate="yes" xml:space="preserve">
          <source>For the purpose of merging broken filepairs back, it uses a different &quot;extent of changes&quot; computation from the ones used by diffcore-break and diffcore-rename. It counts only the deletion from the original, and does not count insertion. If you removed only 10 lines from a 100-line document, even if you added 910 new lines to make a new 1000-line document, you did not do a complete rewrite. diffcore-break breaks such a case in order to help diffcore-rename to consider such filepairs as candidate of rename/copy detection, but if filepairs broken that way were not matched with other filepairs to create rename/copy, then this transformation merges them back into the original &quot;modification&quot;.</source>
          <target state="translated">为了将断裂的文件对合并回来,它使用了与 diffcore-break 和 diffcore-rename 不同的 &quot;变化范围 &quot;计算方法。它只计算从原始文件中删除的内容,而不计算插入的内容。diffcore-break 打破了这样的情况,以帮助 diffcore-rename 将这样的文件对作为重命名/复制检测的候选文件,但如果这样打破的文件对没有与其他文件对进行匹配以创建重命名/复制,那么这种转换将它们合并回原来的 &quot;修改&quot;。</target>
        </trans-unit>
        <trans-unit id="6ab2225889ebaecccd59bff89db6e9b9331d68f2" translate="yes" xml:space="preserve">
          <source>For the sake of clarity, let&amp;rsquo;s stay with &lt;code&gt;git cat-file&lt;/code&gt;, because it</source>
          <target state="translated">为了清楚起见，让我们继续使用 &lt;code&gt;git cat-file&lt;/code&gt; ，因为它</target>
        </trans-unit>
        <trans-unit id="3256aa918e5b4c1710b691c8cd23b5d5181ec72c" translate="yes" xml:space="preserve">
          <source>For the sake of simplicity and interoperating with Subversion, it is recommended that all &lt;code&gt;git svn&lt;/code&gt; users clone, fetch and dcommit directly from the SVN server, and avoid all &lt;code&gt;git clone&lt;/code&gt;/&lt;code&gt;pull&lt;/code&gt;/&lt;code&gt;merge&lt;/code&gt;/&lt;code&gt;push&lt;/code&gt; operations between Git repositories and branches. The recommended method of exchanging code between Git branches and users is &lt;code&gt;git format-patch&lt;/code&gt; and &lt;code&gt;git am&lt;/code&gt;, or just 'dcommit&amp;rsquo;ing to the SVN repository.</source>
          <target state="translated">为了简化和与Subversion互操作，建议所有 &lt;code&gt;git svn&lt;/code&gt; 用户直接从SVN服务器进行克隆，获取和dcommit，并避免在Git存储库和分支之间进行所有 &lt;code&gt;git clone&lt;/code&gt; / &lt;code&gt;pull&lt;/code&gt; / &lt;code&gt;merge&lt;/code&gt; / &lt;code&gt;push&lt;/code&gt; 操作。在Git分支和用户之间交换代码的推荐方法是 &lt;code&gt;git format-patch&lt;/code&gt; 和 &lt;code&gt;git am&lt;/code&gt; ，或者只是&amp;ldquo;提交&amp;rdquo;到SVN存储库。</target>
        </trans-unit>
        <trans-unit id="2279b6e7f152e69847961316b26521ce7eeaaca8" translate="yes" xml:space="preserve">
          <source>For these commands, specifying a single revision, using the notation described in the previous section, means the set of commits &lt;code&gt;reachable&lt;/code&gt; from the given commit.</source>
          <target state="translated">对于这些命令，使用上一节中描述的符号指定单个修订版本，意味着从给定提交 &lt;code&gt;reachable&lt;/code&gt; 的一组提交。</target>
        </trans-unit>
        <trans-unit id="bd23aa2eb5a5735171ddacb742b9284ac1e13d5d" translate="yes" xml:space="preserve">
          <source>For this example, suppose &lt;code&gt;I&lt;/code&gt; created &lt;code&gt;file.txt&lt;/code&gt; which was modified by &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;X&lt;/code&gt; in different ways. The single-parent commits &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt;, and &lt;code&gt;Y&lt;/code&gt; do not change &lt;code&gt;file.txt&lt;/code&gt;. The merge commit &lt;code&gt;M&lt;/code&gt; was created by resolving the merge conflict to include both changes from &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; and hence is not TREESAME to either. The merge commit &lt;code&gt;R&lt;/code&gt;, however, was created by ignoring the contents of &lt;code&gt;file.txt&lt;/code&gt; at &lt;code&gt;M&lt;/code&gt; and taking only the contents of &lt;code&gt;file.txt&lt;/code&gt; at &lt;code&gt;X&lt;/code&gt;. Hence, &lt;code&gt;R&lt;/code&gt; is TREESAME to &lt;code&gt;X&lt;/code&gt; but not &lt;code&gt;M&lt;/code&gt;. Finally, the natural merge resolution to create &lt;code&gt;N&lt;/code&gt; is to take the contents of &lt;code&gt;file.txt&lt;/code&gt; at &lt;code&gt;R&lt;/code&gt;, so &lt;code&gt;N&lt;/code&gt; is TREESAME to &lt;code&gt;R&lt;/code&gt; but not &lt;code&gt;C&lt;/code&gt;. The merge commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; are TREESAME to their first parents, but not to their second parents, &lt;code&gt;Z&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74da4e1940c3e7e40b0478bfdb6a84a981ccd45c" translate="yes" xml:space="preserve">
          <source>For this reason it is strongly recommended that users repack the repository with &lt;code&gt;git repack -a -d&lt;/code&gt; after fast-import completes, allowing Git to reorganize the packfiles for faster data access. If blob deltas are suboptimal (see above) then also adding the &lt;code&gt;-f&lt;/code&gt; option to force recomputation of all deltas can significantly reduce the final packfile size (30-50% smaller can be quite typical).</source>
          <target state="translated">因此，强烈建议用户在快速导入完成后使用 &lt;code&gt;git repack -a -d&lt;/code&gt; 重新打包存储库，以允许Git重新组织打包文件以加快数据访问速度。如果Blob增量不理想（请参见上文），则还添加 &lt;code&gt;-f&lt;/code&gt; 选项以强制重新计算所有增量可以显着减小最终packfile的大小（通常减小30％至50％）。</target>
        </trans-unit>
        <trans-unit id="0c101be68a53a28136d34207f208a2b09cd96fd2" translate="yes" xml:space="preserve">
          <source>For transports that SVN handles authentication for (http, https, and plain svn), specify the username. For other transports (e.g. &lt;code&gt;svn+ssh://&lt;/code&gt;), you must include the username in the URL, e.g. &lt;code&gt;svn+ssh://foo@svn.bar.com/project&lt;/code&gt;</source>
          <target state="translated">对于SVN处理（http，https和svn）身份验证的传输，请指定用户名。对于其他传输方式（例如 &lt;code&gt;svn+ssh://&lt;/code&gt; ），必须在URL中包含用户名，例如 &lt;code&gt;svn+ssh://foo@svn.bar.com/project&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="884bf4d941685ae2ac82a222d5a5cd34350cf6bb" translate="yes" xml:space="preserve">
          <source>For trees, it shows the names (equivalent to &lt;code&gt;git ls-tree&lt;/code&gt; with --name-only).</source>
          <target state="translated">对于树，它显示名称（相当于 &lt;code&gt;git ls-tree&lt;/code&gt; 和--name-only）。</target>
        </trans-unit>
        <trans-unit id="add825378fcd5c043a391a94c20d1353e2f3f4d7" translate="yes" xml:space="preserve">
          <source>For true distributed development that supports proper merging, published branches should never be rewritten.</source>
          <target state="translated">对于真正的分布式开发来说,支持适当的合并,发布的分支绝对不应该被重写。</target>
        </trans-unit>
        <trans-unit id="3d68fc99046b8e48302665b1b866f7694067fd6a" translate="yes" xml:space="preserve">
          <source>For use with --textconv or --filters, to allow specifying an object name and a path separately, e.g. when it is difficult to figure out the revision from which the blob came.</source>
          <target state="translated">与--textconv或--filters一起使用,允许分别指定对象名称和路径,例如,当难以确定blob的修订版本时。</target>
        </trans-unit>
        <trans-unit id="e72ffb4fac055436e16518cc2f4fb21127e4cb40" translate="yes" xml:space="preserve">
          <source>For writing options: write to global &lt;code&gt;~/.gitconfig&lt;/code&gt; file rather than the repository &lt;code&gt;.git/config&lt;/code&gt;, write to &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; file if this file exists and the &lt;code&gt;~/.gitconfig&lt;/code&gt; file doesn&amp;rsquo;t.</source>
          <target state="translated">对于写选项：写到全局 &lt;code&gt;~/.gitconfig&lt;/code&gt; 文件而不是存储库 &lt;code&gt;.git/config&lt;/code&gt; ，写到 &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; 文件（如果该文件存在而 &lt;code&gt;~/.gitconfig&lt;/code&gt; 文件不存在）。</target>
        </trans-unit>
        <trans-unit id="1d4f90bdceeed64344a78d1a30eb973c4a695eed" translate="yes" xml:space="preserve">
          <source>For writing options: write to system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; rather than the repository &lt;code&gt;.git/config&lt;/code&gt;.</source>
          <target state="translated">对于写选项：写到系统范围的 &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; 而不是存储库 &lt;code&gt;.git/config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab6a40ba6d951665186720914cfcdda1831523bb" translate="yes" xml:space="preserve">
          <source>For writing options: write to the repository &lt;code&gt;.git/config&lt;/code&gt; file. This is the default behavior.</source>
          <target state="translated">对于写选项：写到仓库 &lt;code&gt;.git/config&lt;/code&gt; 文件。这是默认行为。</target>
        </trans-unit>
        <trans-unit id="1b61f0964f0c12ab159b1b9cbdaad36acf5d4cd8" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;git gc&lt;/code&gt; to run even if there may be another &lt;code&gt;git gc&lt;/code&gt; instance running on this repository.</source>
          <target state="translated">即使该存储库上可能正在运行另一个 &lt;code&gt;git gc&lt;/code&gt; 实例，也要强制 &lt;code&gt;git gc&lt;/code&gt; 运行。</target>
        </trans-unit>
        <trans-unit id="a59f7a2d2743e4a0d5cd2ef8ccde3326876216c1" translate="yes" xml:space="preserve">
          <source>Force an update only if the tip of the remote-tracking ref has been integrated locally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2041f78f7b4213165ad0484df1b0863ad820d047" translate="yes" xml:space="preserve">
          <source>Force renaming or moving of a file even if the target exists</source>
          <target state="translated">即使目标存在,也要强制重命名或移动文件。</target>
        </trans-unit>
        <trans-unit id="ecd78b0e67ad331a13ae4cb8f4e6a9ed04fc189e" translate="yes" xml:space="preserve">
          <source>Force the cloning process from a repository on a local filesystem to copy the files under the &lt;code&gt;.git/objects&lt;/code&gt; directory instead of using hardlinks. This may be desirable if you are trying to make a back-up of your repository.</source>
          <target state="translated">强制从本地文件系统上的存储库进行克隆过程，以复制 &lt;code&gt;.git/objects&lt;/code&gt; 目录下的文件，而不使用硬链接。如果您要备份存储库，则这可能是理想的。</target>
        </trans-unit>
        <trans-unit id="5aad6db9c36a2f2837e6ea58135f2a7c135ffcc5" translate="yes" xml:space="preserve">
          <source>Force the merge even if the files are not up to date.</source>
          <target state="translated">即使文件不是最新的,也要强制合并。</target>
        </trans-unit>
        <trans-unit id="b35554b966d1f9e773a7eeb185af7c152ef043be" translate="yes" xml:space="preserve">
          <source>Force the parent commit, even if it is not a direct parent.</source>
          <target state="translated">强制父级提交,即使它不是直接父级。</target>
        </trans-unit>
        <trans-unit id="8fd0762700f6c31dd37961618e48e9600a28f63f" translate="yes" xml:space="preserve">
          <source>Force updating modified existing branches, even if doing so would cause commits to be lost (as the new commit does not contain the old commit).</source>
          <target state="translated">强制更新已修改的分支,即使这样做会导致提交丢失(因为新提交不包含旧提交)。</target>
        </trans-unit>
        <trans-unit id="3c16110b137eeeb074b6bb1a45d5cee67e8b8d7d" translate="yes" xml:space="preserve">
          <source>Forces fast-import to close the current packfile, generate its unique SHA-1 checksum and index, and start a new packfile. This command is optional and is not needed to perform an import.</source>
          <target state="translated">强制 fast-import 关闭当前的 packfile,生成其唯一的 SHA-1 校验和和索引,并开始一个新的 packfile。这个命令是可选的,在执行导入时不需要。</target>
        </trans-unit>
        <trans-unit id="1a687c2c8da515bb3889e24f9c0c80b813b24084" translate="yes" xml:space="preserve">
          <source>Forces fast-import to close the current packfile, start a new one, and to save out all current branch refs, tags and marks.</source>
          <target state="translated">强制 fast-import 关闭当前的 packfile,启动一个新的 packfile,并保存所有当前分支的 refs、tag 和 marks。</target>
        </trans-unit>
        <trans-unit id="434a9daac438458d6a5542866bf4627ab056ebc0" translate="yes" xml:space="preserve">
          <source>Forcing git fetch to do non-fast-forward updates</source>
          <target state="translated">强制git fetch进行非快进式更新</target>
        </trans-unit>
        <trans-unit id="07c2be944c0e6602c04932a6e3d9ec7d07d27d65" translate="yes" xml:space="preserve">
          <source>Forget about the current merge in progress. Leave the index and the working tree as-is.</source>
          <target state="translated">忘记当前正在进行的合并。让索引和工作树保持原样。</target>
        </trans-unit>
        <trans-unit id="b7fac01fb2068412feecd8f7081be42b5f011f68" translate="yes" xml:space="preserve">
          <source>Forget about the current merge in progress. Leave the index and the working tree as-is. If &lt;code&gt;MERGE_AUTOSTASH&lt;/code&gt; is present, the stash entry will be saved to the stash list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81bdf759eac78632844fbde02bcf81c1762add7d" translate="yes" xml:space="preserve">
          <source>Forget about the current operation in progress. Can be used to clear the sequencer state after a failed cherry-pick or revert.</source>
          <target state="translated">忘记当前正在进行的操作。可用于清除选取或还原失败后的音序器状态。</target>
        </trans-unit>
        <trans-unit id="bc2093ee15e651049bc58aa54bb94be570859e07" translate="yes" xml:space="preserve">
          <source>Format data by columns:</source>
          <target state="translated">按列格式化数据。</target>
        </trans-unit>
        <trans-unit id="74cf0d3233deb63a1885a09b7a59d2c4cacb7451" translate="yes" xml:space="preserve">
          <source>Format data by rows:</source>
          <target state="translated">按行格式化数据。</target>
        </trans-unit>
        <trans-unit id="1490d94054ac9f1a7565287cb4c10caa7d0a3ff1" translate="yes" xml:space="preserve">
          <source>Format of the file(s) specified in sendemail.aliasesFile. Must be one of &lt;code&gt;mutt&lt;/code&gt;, &lt;code&gt;mailrc&lt;/code&gt;, &lt;code&gt;pine&lt;/code&gt;, &lt;code&gt;elm&lt;/code&gt;, or &lt;code&gt;gnus&lt;/code&gt;, or &lt;code&gt;sendmail&lt;/code&gt;.</source>
          <target state="translated">sendemail.aliasesFile中指定的文件格式。必须是 &lt;code&gt;mutt&lt;/code&gt; ， &lt;code&gt;mailrc&lt;/code&gt; ， &lt;code&gt;pine&lt;/code&gt; ， &lt;code&gt;elm&lt;/code&gt; 或 &lt;code&gt;gnus&lt;/code&gt; 或 &lt;code&gt;sendmail&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="85b75659b13a3c18419a2059ae24d18f7aec62d9" translate="yes" xml:space="preserve">
          <source>Format of the resulting archive: &lt;code&gt;tar&lt;/code&gt; or &lt;code&gt;zip&lt;/code&gt;. If this option is not given, and the output file is specified, the format is inferred from the filename if possible (e.g. writing to &quot;foo.zip&quot; makes the output to be in the zip format). Otherwise the output format is &lt;code&gt;tar&lt;/code&gt;.</source>
          <target state="translated">生成的存档的格式： &lt;code&gt;tar&lt;/code&gt; 或 &lt;code&gt;zip&lt;/code&gt; 。如果未指定此选项，并且指定了输出文件，则从文件名推断格式（例如，写入&amp;ldquo; foo.zip&amp;rdquo;将使输出为zip格式）。否则，输出格式为 &lt;code&gt;tar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2804d9f16a38553f8238529c90d66e7d7426c150" translate="yes" xml:space="preserve">
          <source>Formats</source>
          <target state="translated">Formats</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="97808e16f7b3e0748cf911affe6a2e5f5336bd69" translate="yes" xml:space="preserve">
          <source>Fortunately, Git also keeps a log, called a &quot;reflog&quot;, of all the previous values of each branch. So in this case you can still find the old history using, for example,</source>
          <target state="translated">幸运的是,Git还保存了一个日志,称为 &quot;reflog&quot;,记录了每个分支之前的所有值。所以在这种情况下,你仍然可以使用,例如,找到旧的历史记录。</target>
        </trans-unit>
        <trans-unit id="52aedb174e481572a146a6eee6e65f3145e19419" translate="yes" xml:space="preserve">
          <source>Fortunately, when you try and merge branches imported from Arch, Git will find a good merge base, and it has a good chance of identifying patches that have been traded out-of-sequence between the branches.</source>
          <target state="translated">幸运的是,当你尝试合并从Arch导入的分支时,Git会找到一个很好的合并基础,它有机会识别出分支之间被交易的不合顺序的补丁。</target>
        </trans-unit>
        <trans-unit id="f243a4b31e069ad1af1905a7b7ee3c0a6bc4a9d9" translate="yes" xml:space="preserve">
          <source>Freely Skip Around Branches</source>
          <target state="translated">自由地跳过分支</target>
        </trans-unit>
        <trans-unit id="4f5fb89546fa56451bf07260d4420bcc62940bb0" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions (FAQ)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6954599bb4bd53fc74592c122080450ce5ed81db" translate="yes" xml:space="preserve">
          <source>Frequently asked questions about using Git</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2451038a48527dcbeab53ccfe9fbac5f2cad0f" translate="yes" xml:space="preserve">
          <source>From a clean working directory:</source>
          <target state="translated">从一个干净的工作目录。</target>
        </trans-unit>
        <trans-unit id="e5d597f5b08d8d486fa4fe348997e77a44c54af8" translate="yes" xml:space="preserve">
          <source>From a remote repository:</source>
          <target state="translated">从远程存储库。</target>
        </trans-unit>
        <trans-unit id="288bfe5db4a5e76e3e6479e8536caa4995b7e02e" translate="yes" xml:space="preserve">
          <source>From a tarball:</source>
          <target state="translated">从一个焦油球。</target>
        </trans-unit>
        <trans-unit id="734c2e78c0e94a1be8f8ce3bed6beeb7e74b3905" translate="yes" xml:space="preserve">
          <source>From the Git 1.5.4 series and further, many Git commands (not all of them at the time of the writing though) come with an enhanced option parser.</source>
          <target state="translated">从Git 1.5.4系列开始,许多Git命令(虽然在写这篇文章的时候并不是所有的命令)都带有一个增强的选项解析器。</target>
        </trans-unit>
        <trans-unit id="a7a0e1c60991430a8700058d7dbaaa429f71c02b" translate="yes" xml:space="preserve">
          <source>From this point, the result of either of the following commands:</source>
          <target state="translated">从这一点来看,以下任一命令的结果。</target>
        </trans-unit>
        <trans-unit id="3e41340cee5d477151048da29744ee1316a7f6cb" translate="yes" xml:space="preserve">
          <source>Frontends may choose to issue checkpoints during extremely large and long running imports, or when they need to allow another Git process access to a branch. However given that a 30 GiB Subversion repository can be loaded into Git through fast-import in about 3 hours, explicit checkpointing may not be necessary.</source>
          <target state="translated">前端可能会选择在非常大和长时间的导入过程中,或者当他们需要允许另一个 Git 进程访问一个分支时,发出检查点。然而,考虑到一个30GiB的Subversion仓库可以在3小时内通过快速导入加载到Git中,明确的检查点可能没有必要。</target>
        </trans-unit>
        <trans-unit id="45f585d5b13263a74e89d30321fceb20439bc1e7" translate="yes" xml:space="preserve">
          <source>Frontends should prefer the &lt;code&gt;raw&lt;/code&gt; format if the source material already uses UNIX-epoch format, can be coaxed to give dates in that format, or its format is easily convertible to it, as there is no ambiguity in parsing.</source>
          <target state="translated">如果源资料已经使用UNIX-epoch格式，可以哄骗以该格式给出日期，或者其格式可以轻松转换为 &lt;code&gt;raw&lt;/code&gt; 格式，则前端应首选原始格式，因为在解析时不会产生歧义。</target>
        </trans-unit>
        <trans-unit id="f3cc2873d5f4e3e8be387b77133d15ba005de66f" translate="yes" xml:space="preserve">
          <source>Frontends which have efficient access to all revisions of a single file (for example reading an RCS/CVS ,v file) can choose to supply all revisions of that file as a sequence of consecutive &lt;code&gt;blob&lt;/code&gt; commands. This allows fast-import to deltify the different file revisions against each other, saving space in the final packfile. Marks can be used to later identify individual file revisions during a sequence of &lt;code&gt;commit&lt;/code&gt; commands.</source>
          <target state="translated">可以有效访问单个文件的所有修订版本（例如读取RCS / CVS，v文件）的前端可以选择提供该文件的所有修订版本，作为一系列连续的 &lt;code&gt;blob&lt;/code&gt; 命令。这样，快速导入就可以使不同的文件修订版相互抵销，从而节省了最终packfile中的空间。标记可用于以后在一系列 &lt;code&gt;commit&lt;/code&gt; 命令期间标识各个文件的修订版。</target>
        </trans-unit>
        <trans-unit id="3519d227e718b16c5b769aae01680cf2cd77dc46" translate="yes" xml:space="preserve">
          <source>Full URL and absolute URL of the gitweb script; in earlier versions of gitweb you might have need to set those variables, but now there should be no need to do it. See &lt;code&gt;$per_request_config&lt;/code&gt; if you need to set them still.</source>
          <target state="translated">gitweb脚本的完整URL和绝对URL；在早期版本的gitweb中，您可能需要设置这些变量，但现在应该不需要这样做了。如果需要仍然设置它们，请参见 &lt;code&gt;$per_request_config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a108e2708a06a554ba0c3dc09504268225bd27f7" translate="yes" xml:space="preserve">
          <source>Full pattern set</source>
          <target state="translated">全套图案</target>
        </trans-unit>
        <trans-unit id="b8fec8cb8e4460222f34da65fd7e0d2a0f5118ab" translate="yes" xml:space="preserve">
          <source>Function used to determine which repositories should be shown. This subroutine should take one parameter, the full path to a project, and if it returns true, that project will be included in the projects list and can be accessed through gitweb as long as it fulfills the other requirements described by $export_ok, $projects_list, and $projects_maxdepth. Example:</source>
          <target state="translated">用于决定哪些仓库应该被显示的函数。这个子程序应该接收一个参数,即项目的完整路径,如果返回 true,那么这个项目将被包含在项目列表中,只要满足 $export_ok、$projects_list 和 $projects_maxdepth 描述的其他要求,就可以通过 gitweb 访问。例如</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="953f869510869f147aa66935f6f2e4c1b01346f2" translate="yes" xml:space="preserve">
          <source>Fundamental data structures and utilities of Git. Exposes only limited source code management tools.</source>
          <target state="translated">Git的基本数据结构和实用工具。只暴露了有限的源代码管理工具。</target>
        </trans-unit>
        <trans-unit id="2a68bfcdf45f0d6508d348a650a90dad4898fc87" translate="yes" xml:space="preserve">
          <source>Further chapters cover more specialized topics.</source>
          <target state="translated">更多的章节涉及更多的专业主题。</target>
        </trans-unit>
        <trans-unit id="bc4614e5e44f10e9735555c384229ac13d88fcbe" translate="yes" xml:space="preserve">
          <source>Further documentation</source>
          <target state="translated">进一步的文件</target>
        </trans-unit>
        <trans-unit id="1a67b11bbb73911c0ea7f808bf383dac0f90b1d2" translate="yes" xml:space="preserve">
          <source>Further suppose that the other person already pushed changes leading to A back to the original repository from which you two obtained the original commit X.</source>
          <target state="translated">进一步假设另一个人已经把导致 A 的修改推送回了你们两个获得原始提交 X 的原始仓库。</target>
        </trans-unit>
        <trans-unit id="11dea5e071893c59426ef6a8d5f500708e7c087c" translate="yes" xml:space="preserve">
          <source>Further, remember how I said that &lt;code&gt;git write-tree&lt;/code&gt; writes the contents of the &lt;strong&gt;index&lt;/strong&gt; file to the tree, and thus what we just committed was in fact the &lt;strong&gt;original&lt;/strong&gt; contents of the file &lt;code&gt;hello&lt;/code&gt;, not the new ones. We did that on purpose, to show the difference between the index state, and the state in the working tree, and how they don&amp;rsquo;t have to match, even when we commit things.</source>
          <target state="translated">此外，请记住我说过 &lt;code&gt;git write-tree&lt;/code&gt; 将&lt;strong&gt;索引&lt;/strong&gt;文件的内容写到树上的事实，因此，我们刚刚提交的实际上是文件 &lt;code&gt;hello&lt;/code&gt; 的&lt;strong&gt;原始&lt;/strong&gt;内容，而不是新内容。我们故意这样做是为了显示索引状态与工作树中的状态之间的差异，以及即使在我们提交东西时它们也不必匹配。</target>
        </trans-unit>
        <trans-unit id="12a1c3eb3c3466df160e63355f0a70980e5d8a54" translate="yes" xml:space="preserve">
          <source>Further, several additional files are created or updated per commit by git-filter-branch. Some of these are for supporting the convenience functions provided by git-filter-branch (such as map()), while others are for keeping track of internal state (but could have also been accessed by user filters; one of git-filter-branch&amp;rsquo;s regression tests does so). This essentially amounts to using the filesystem as an IPC mechanism between git-filter-branch and the user-provided filters. Disks tend to be a slow IPC mechanism, and writing these files also effectively represents a forced synchronization point between separate processes that we hit with every commit.</source>
          <target state="translated">此外，git-filter-branch每次提交都会创建或更新几个其他文件。其中一些用于支持git-filter-branch提供的便利功能（例如map（）），而其他一些则用于跟踪内部状态（但用户过滤器也可以访问它； git-filter-分支机构的回归测试就是这样做的）。从本质上讲，这相当于将文件系统用作git-filter-branch和用户提供的过滤器之间的IPC机制。磁盘往往是一种慢速的IPC机制，并且写入这些文件也有效地代表了每次提交时我们击中的各个进程之间的强制同步点。</target>
        </trans-unit>
        <trans-unit id="48717135930571b8087beeed13bb405458558d68" translate="yes" xml:space="preserve">
          <source>Further, the above facts mean that there are multiple reasons that &quot;tracked&quot; files might not be present in the working copy: sparsity pattern application from sparse-checkout, and submodule initialization state. Thus, commands like &lt;code&gt;git grep&lt;/code&gt; that work on tracked files in the working copy may return results that are limited by either or both of these restrictions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca2383accb8da62a165b73e8556d1713934adf2" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;git read-tree&lt;/code&gt; has special-case logic that says: if you see a file that matches in all respects in the following states, it &quot;collapses&quot; back to &quot;stage0&quot;:</source>
          <target state="translated">此外， &lt;code&gt;git read-tree&lt;/code&gt; 具有特殊情况的逻辑，该逻辑表示：如果您在以下状态下看到在各个方面都匹配的文件，则它将&amp;ldquo;折叠&amp;rdquo;回到&amp;ldquo; stage0&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="31a08e0ad75da0260fa91bb8e152e897858a7305" translate="yes" xml:space="preserve">
          <source>Furthermore, passwords need not be specified in configuration files or on the command line. If a username has been specified (with &lt;code&gt;--smtp-user&lt;/code&gt; or a &lt;code&gt;sendemail.smtpUser&lt;/code&gt;), but no password has been specified (with &lt;code&gt;--smtp-pass&lt;/code&gt; or &lt;code&gt;sendemail.smtpPass&lt;/code&gt;), then a password is obtained using &lt;code&gt;git-credential&lt;/code&gt;.</source>
          <target state="translated">此外，无需在配置文件或命令行中指定密码。如果已指定用户名（使用 &lt;code&gt;--smtp-user&lt;/code&gt; 或 &lt;code&gt;sendemail.smtpUser&lt;/code&gt; ），但未指定密码（使用 &lt;code&gt;--smtp-pass&lt;/code&gt; 或 &lt;code&gt;sendemail.smtpPass&lt;/code&gt; ），则使用 &lt;code&gt;git-credential&lt;/code&gt; 获得密码。</target>
        </trans-unit>
        <trans-unit id="eebdda6fedb5243cc4950de3133a043a2ebece61" translate="yes" xml:space="preserve">
          <source>Furthermore, supplying &lt;code&gt;--aggressive&lt;/code&gt; will tweak the &lt;code&gt;--depth&lt;/code&gt; and &lt;code&gt;--window&lt;/code&gt; options passed to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. See the &lt;code&gt;gc.aggressiveDepth&lt;/code&gt; and &lt;code&gt;gc.aggressiveWindow&lt;/code&gt; settings below. By using a larger window size we&amp;rsquo;re more likely to find more optimal deltas.</source>
          <target state="translated">此外，提供 &lt;code&gt;--aggressive&lt;/code&gt; 将调整传递给&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;的 &lt;code&gt;--depth&lt;/code&gt; 和 &lt;code&gt;--window&lt;/code&gt; 选项。请参阅下面的 &lt;code&gt;gc.aggressiveDepth&lt;/code&gt; 和 &lt;code&gt;gc.aggressiveWindow&lt;/code&gt; 设置。通过使用更大的窗口尺寸，我们更有可能找到更多的最佳增量。</target>
        </trans-unit>
        <trans-unit id="c04d9fd3f33708a82d676293fc52e5a70fbf49e1" translate="yes" xml:space="preserve">
          <source>Future work</source>
          <target state="translated">今后的工作</target>
        </trans-unit>
        <trans-unit id="7fa52712e6497fe42aeefb82c610da75e312ec0f" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG</source>
          <target state="translated">GITWEB_CONFIG</target>
        </trans-unit>
        <trans-unit id="9636fb1dbafa2b47af9b2233bf38584401d20651" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG_COMMON</source>
          <target state="translated">GITWEB_CONFIG_COMMON</target>
        </trans-unit>
        <trans-unit id="f726c6360c3b65b3b136cb8ed08c06cd6bb3dc13" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG_SYSTEM</source>
          <target state="translated">GITWEB_CONFIG_SYSTEM</target>
        </trans-unit>
        <trans-unit id="7280da4640f08695fca3fbf79b196a715d6c95d5" translate="yes" xml:space="preserve">
          <source>GIT_ALTERNATE_OBJECT_DIRECTORIES</source>
          <target state="translated">GIT_ALTERNATE_OBJECT_DIRECTORIES</target>
        </trans-unit>
        <trans-unit id="964a2aa0953b5ffb1cfcd8b66bb3d22332570f05" translate="yes" xml:space="preserve">
          <source>GIT_AUTHOR_IDENT</source>
          <target state="translated">GIT_AUTHOR_IDENT</target>
        </trans-unit>
        <trans-unit id="725c6b7276951cf72d0731356407b6a84b3e59ef" translate="yes" xml:space="preserve">
          <source>GIT_COMMITTER_IDENT</source>
          <target state="translated">GIT_COMMITTER_IDENT</target>
        </trans-unit>
        <trans-unit id="3869ed3f7a51f55040f7a430ffe9ba97f98e246e" translate="yes" xml:space="preserve">
          <source>GIT_CONFIG</source>
          <target state="translated">GIT_CONFIG</target>
        </trans-unit>
        <trans-unit id="a5d490c74fb40af786be750b380476b10d1e4b69" translate="yes" xml:space="preserve">
          <source>GIT_CONFIG_NOSYSTEM</source>
          <target state="translated">GIT_CONFIG_NOSYSTEM</target>
        </trans-unit>
        <trans-unit id="01c412ca4d08642575a66ac381c4483c043b0ee1" translate="yes" xml:space="preserve">
          <source>GIT_CVSSERVER_BASE_PATH takes the place of the argument to --base-path.</source>
          <target state="translated">GIT_CVSSERVER_BASE_PATH 取代了 --base-path 的参数。</target>
        </trans-unit>
        <trans-unit id="4f0780cd85f15ce5f825b343d1c06abf4cfc9741" translate="yes" xml:space="preserve">
          <source>GIT_CVSSERVER_ROOT specifies a single-directory whitelist. The repository must still be configured to allow access through git-cvsserver, as described above.</source>
          <target state="translated">GIT_CVSSERVER_ROOT 指定了一个单一目录的白名单。仓库仍然必须被配置为允许通过 git-cvsserver 访问,如上所述。</target>
        </trans-unit>
        <trans-unit id="4ad19a85aef9ab4dcb6f62d95b8acf07e4c4828f" translate="yes" xml:space="preserve">
          <source>GIT_EDITOR</source>
          <target state="translated">GIT_EDITOR</target>
        </trans-unit>
        <trans-unit id="c8b3461d27dba4e8c6ce0c25c772c18d60c891a3" translate="yes" xml:space="preserve">
          <source>GIT_EXT_SERVICE</source>
          <target state="translated">GIT_EXT_SERVICE</target>
        </trans-unit>
        <trans-unit id="f4a08871056eea1076c323923e7cd2cd5fd6c0a8" translate="yes" xml:space="preserve">
          <source>GIT_EXT_SERVICE_NOPREFIX</source>
          <target state="translated">GIT_EXT_SERVICE_NOPREFIX</target>
        </trans-unit>
        <trans-unit id="08b684f4da6721d3a2c8e7b518324c7c98994b4e" translate="yes" xml:space="preserve">
          <source>GIT_INDEX_FILE</source>
          <target state="translated">GIT_INDEX_FILE</target>
        </trans-unit>
        <trans-unit id="cf57e9b3a04f2696e64705102232bab489ed97a5" translate="yes" xml:space="preserve">
          <source>GIT_OBJECT_DIRECTORY</source>
          <target state="translated">GIT_OBJECT_DIRECTORY</target>
        </trans-unit>
        <trans-unit id="924d60649d04fe751450b8bd3f1fc4a48bf559cb" translate="yes" xml:space="preserve">
          <source>GIT_PAGER</source>
          <target state="translated">GIT_PAGER</target>
        </trans-unit>
        <trans-unit id="ef2d6ed7bd1e2bfa87dc927172ada3fd1bdae6d2" translate="yes" xml:space="preserve">
          <source>GIT_TRANSLOOP_DEBUG</source>
          <target state="translated">GIT_TRANSLOOP_DEBUG</target>
        </trans-unit>
        <trans-unit id="a16f454460c35cd8704027fca6876a6a8646b0f2" translate="yes" xml:space="preserve">
          <source>GMail</source>
          <target state="translated">GMail</target>
        </trans-unit>
        <trans-unit id="cda466cee33ea6d923c0d1a6805da6ace37ac3f0" translate="yes" xml:space="preserve">
          <source>GMail does not have any way to turn off line wrapping in the web interface, so it will mangle any emails that you send. You can however use &quot;git send-email&quot; and send your patches through the GMail SMTP server, or use any IMAP email client to connect to the google IMAP server and forward the emails through that.</source>
          <target state="translated">GMail在网页界面上没有关闭行包装的功能,所以它会把你发送的邮件弄得乱七八糟,不过你可以使用 &quot;git send-email&quot;,通过GMail的SMTP服务器发送你的补丁,或者使用任何IMAP邮件客户端连接google的IMAP服务器,并通过它转发邮件。然而,你可以使用 &quot;git send-email&quot;,通过GMail SMTP服务器发送你的补丁,或者使用任何IMAP邮件客户端连接到google IMAP服务器,并通过它转发邮件。</target>
        </trans-unit>
        <trans-unit id="31f314da9a863256952d9852bb7b935e9c829e75" translate="yes" xml:space="preserve">
          <source>GPG sign pushes.</source>
          <target state="translated">GPG标志推。</target>
        </trans-unit>
        <trans-unit id="d2cc3c3070810078ed6b670e4bd5c8639504233f" translate="yes" xml:space="preserve">
          <source>GPG-sign commits. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space.</source>
          <target state="translated">GPG签名提交。所述 &lt;code&gt;keyid&lt;/code&gt; 的参数是可选的，并且默认为提交者身份; 如果指定，则必须将其固定在选项中，且不能留空格。</target>
        </trans-unit>
        <trans-unit id="b1aed1c7977c0e2de26949b45fd71f731a4b1c8b" translate="yes" xml:space="preserve">
          <source>GPG-sign commits. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. &lt;code&gt;--no-gpg-sign&lt;/code&gt; is useful to countermand a &lt;code&gt;--gpg-sign&lt;/code&gt; option given earlier on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064f918c2672d1e438a7a65cbdf8c083e0ff21e6" translate="yes" xml:space="preserve">
          <source>GPG-sign commits. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. &lt;code&gt;--no-gpg-sign&lt;/code&gt; is useful to countermand both &lt;code&gt;commit.gpgSign&lt;/code&gt; configuration variable, and earlier &lt;code&gt;--gpg-sign&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="280cb8af503fd81af0776da1e5da5b505a515ac5" translate="yes" xml:space="preserve">
          <source>GPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged. If &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;--no-signed&lt;/code&gt;, no signing will be attempted. If &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;--signed&lt;/code&gt;, the push will fail if the server does not support signed pushes. If set to &lt;code&gt;if-asked&lt;/code&gt;, sign if and only if the server supports signed pushes. The push will also fail if the actual call to &lt;code&gt;gpg --sign&lt;/code&gt; fails. See &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; for the details on the receiving end.</source>
          <target state="translated">GPG对推送请求进行签名，以更新接收方的ref，以使其可以通过挂钩进行检查和/或记录。如果为 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;--no-signed&lt;/code&gt; ，则不会尝试签名。如果为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;--signed&lt;/code&gt; ，则如果服务器不支持签名的推送，则推送将失败。如果设置为 &lt;code&gt;if-asked&lt;/code&gt; ，则仅在服务器支持签名推送时签名。如果对 &lt;code&gt;gpg --sign&lt;/code&gt; 的实际调用失败，则推送也将失败。有关接收端的详细信息，请参见&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="359179ddafe5ac57f233ce54be02401d37d2bd8b" translate="yes" xml:space="preserve">
          <source>GPG-sign the resulting merge commit. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space.</source>
          <target state="translated">GPG对结果合并提交签名。所述 &lt;code&gt;keyid&lt;/code&gt; 的参数是可选的，并且默认为提交者身份; 如果指定，则必须将其固定在选项中，且不能留空格。</target>
        </trans-unit>
        <trans-unit id="701d2f8958de65d8fe7b7eb1b839a88b4e25736c" translate="yes" xml:space="preserve">
          <source>GPG-sign the resulting merge commit. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. &lt;code&gt;--no-gpg-sign&lt;/code&gt; is useful to countermand both &lt;code&gt;commit.gpgSign&lt;/code&gt; configuration variable, and earlier &lt;code&gt;--gpg-sign&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524cceb20916aff43a2680247362fb603a1a49c8" translate="yes" xml:space="preserve">
          <source>Garbage collect all unreferenced objects with &lt;code&gt;git gc --prune=now&lt;/code&gt; (or if your git-gc is not new enough to support arguments to &lt;code&gt;--prune&lt;/code&gt;, use &lt;code&gt;git repack -ad; git prune&lt;/code&gt; instead).</source>
          <target state="translated">垃圾使用 &lt;code&gt;git gc --prune=now&lt;/code&gt; 收集所有未引用的对象（或者如果git-gc不够新，无法支持 &lt;code&gt;--prune&lt;/code&gt; 的参数，则使用 &lt;code&gt;git repack -ad; git prune&lt;/code&gt; -ad ;改为git prune）。</target>
        </trans-unit>
        <trans-unit id="5bcb5f8aaf1a9e559046fd7b5b3d79bbe4d3f426" translate="yes" xml:space="preserve">
          <source>General options</source>
          <target state="translated">一般选择</target>
        </trans-unit>
        <trans-unit id="a5879c5c764017ca2130842dc888dcc88c04c99e" translate="yes" xml:space="preserve">
          <source>General variables</source>
          <target state="translated">一般变量</target>
        </trans-unit>
        <trans-unit id="55fd2438a0c551b4e16240eed52ec4917c61134a" translate="yes" xml:space="preserve">
          <source>Generally speaking, rule (3) above is the simplest for users to specify. Authors of credential helpers should make an effort to assist their users by naming their program &quot;git-credential-$NAME&quot;, and putting it in the &lt;code&gt;$PATH&lt;/code&gt; or &lt;code&gt;$GIT_EXEC_PATH&lt;/code&gt; during installation, which will allow a user to enable it with &lt;code&gt;git config credential.helper $NAME&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e6a94549428bad778124c3c140042198abcb13" translate="yes" xml:space="preserve">
          <source>Generally this mode is used as an administrative interface to allow users to list repositories they have access to, create, delete, or rename repositories, or change repository descriptions and permissions.</source>
          <target state="translated">一般来说,这种模式是作为一个管理界面,允许用户列出他们可以访问的存储库,创建、删除或重命名存储库,或更改存储库描述和权限。</target>
        </trans-unit>
        <trans-unit id="5338e8546078668a151a9dabd932d38a31f12f5b" translate="yes" xml:space="preserve">
          <source>Generally, &lt;code&gt;git p4 clone&lt;/code&gt; is used to create a new Git directory from an existing p4 repository:</source>
          <target state="translated">通常， &lt;code&gt;git p4 clone&lt;/code&gt; 用于从现有的p4存储库创建新的Git目录：</target>
        </trans-unit>
        <trans-unit id="ad37ee86e2b3d890455e76bc1e7e0fc45d3460de" translate="yes" xml:space="preserve">
          <source>Generally, all Git operations work on the index file. Some operations work &lt;strong&gt;purely&lt;/strong&gt; on the index file (showing the current state of the index), but most operations move data between the index file and either the database or the working directory. Thus there are four main combinations:</source>
          <target state="translated">通常，所有Git操作都对索引文件起作用。一些操作&lt;strong&gt;仅&lt;/strong&gt;在索引文件上工作（显示索引的当前状态），但是大多数操作在索引文件与数据库或工作目录之间移动数据。因此，有四个主要组合：</target>
        </trans-unit>
        <trans-unit id="c30116e53a947e31daeae056572933416099fbe0" translate="yes" xml:space="preserve">
          <source>Generally, dangling objects aren&amp;rsquo;t anything to worry about. They can even be very useful: if you screw something up, the dangling objects can be how you recover your old tree (say, you did a rebase, and realized that you really didn&amp;rsquo;t want to&amp;mdash;​you can look at what dangling objects you have, and decide to reset your head to some old dangling state).</source>
          <target state="translated">通常，悬空对象无需担心。它们甚至可能非常有用：如果您弄砸了东西，那么悬空的对象可能就是您恢复老树的方式（例如，您进行了重新设置，并意识到您确实不想要-您可以查看悬空的对象物件，并决定将头部重设为旧的悬空状态）。</target>
        </trans-unit>
        <trans-unit id="aefb0f39d3bd01ba3e438537ce5e3b6f3d075591" translate="yes" xml:space="preserve">
          <source>Generate a &lt;code&gt;$GIT_DIR/cvs-revisions&lt;/code&gt; file containing a mapping from CVS revision numbers to newly-created Git commit IDs. The generated file will contain one line for each (filename, revision) pair imported; each line will look like</source>
          <target state="translated">生成一个 &lt;code&gt;$GIT_DIR/cvs-revisions&lt;/code&gt; 文件，其中包含从CVS版本号到新创建的Git提交ID的映射。对于每个导入的（文件名，修订）对，生成的文件将包含一行；每行看起来像</target>
        </trans-unit>
        <trans-unit id="d956a0b3c8358372085439a04d4b2593dd2bec54" translate="yes" xml:space="preserve">
          <source>Generate a credential description based on the context.</source>
          <target state="translated">根据上下文生成凭证描述。</target>
        </trans-unit>
        <trans-unit id="8b4e72c7495787832a335e23db7d41cdc955de4e" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;anchored diff&quot; algorithm.</source>
          <target state="translated">使用 &quot;锚定差异 &quot;算法生成一个差异。</target>
        </trans-unit>
        <trans-unit id="c65b3bd43c187f9009fd8be60c354464048bfb2c" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;histogram diff&quot; algorithm.</source>
          <target state="translated">使用 &quot;直方图差异 &quot;算法生成差异。</target>
        </trans-unit>
        <trans-unit id="5a810f6cb04f85c060e73d8366053dc83cbde1b6" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;patience diff&quot; algorithm.</source>
          <target state="translated">使用 &quot;耐心差异 &quot;算法生成差异。</target>
        </trans-unit>
        <trans-unit id="f50a5c7af33db239a645bbb0a36b9c949e7a8bfe" translate="yes" xml:space="preserve">
          <source>Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt;. The width of the filename part can be limited by giving another width &lt;code&gt;&amp;lt;name-width&amp;gt;&lt;/code&gt; after a comma. The width of the graph part can be limited by using &lt;code&gt;--stat-graph-width=&amp;lt;width&amp;gt;&lt;/code&gt; (affects all commands generating a stat graph) or by setting &lt;code&gt;diff.statGraphWidth=&amp;lt;width&amp;gt;&lt;/code&gt; (does not affect &lt;code&gt;git format-patch&lt;/code&gt;). By giving a third parameter &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;, you can limit the output to the first &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; lines, followed by &lt;code&gt;...&lt;/code&gt; if there are more.</source>
          <target state="translated">生成一个diffstat。默认情况下，文件名部分将使用必要的空间，而图形部分将使用其余空间。最大宽度默认为终端宽度，如果未连接到终端，则为80列，并且可以由 &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; 覆盖。文件名部分的宽度可以通过在逗号后面加上另一个宽度 &lt;code&gt;&amp;lt;name-width&amp;gt;&lt;/code&gt; 来限制。可以通过使用 &lt;code&gt;--stat-graph-width=&amp;lt;width&amp;gt;&lt;/code&gt; （影响生成统计图的所有命令）或设置 &lt;code&gt;diff.statGraphWidth=&amp;lt;width&amp;gt;&lt;/code&gt; （不影响 &lt;code&gt;git format-patch&lt;/code&gt; ）来限制图形部分的宽度。。通过提供第三个参数 &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; ，您可以将输出限制为前 &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; 行，其次是 &lt;code&gt;...&lt;/code&gt; 如果还有更多。</target>
        </trans-unit>
        <trans-unit id="9a58997012274b692734905439c472fc9bf49724" translate="yes" xml:space="preserve">
          <source>Generate a request asking your upstream project to pull changes into their tree. The request, printed to the standard output, begins with the branch description, summarizes the changes and indicates from where they can be pulled.</source>
          <target state="translated">生成一个请求,要求你的上游项目将变更拉到他们的树上。该请求打印到标准输出中,以分支描述开始,总结变化,并指出它们可以从哪里被拉取。</target>
        </trans-unit>
        <trans-unit id="e43be14252a09239d3a95e69575c334d9dcee155" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the default of 3. This value is overridden by the -U option.</source>
          <target state="translated">使用上下文的&amp;lt;n&amp;gt;行而不是默认值3生成差异。-U选项将覆盖此值。</target>
        </trans-unit>
        <trans-unit id="fea95dfcb58a42fac9dc224f2dbc963f2e3feb5f" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the usual three.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3fb6d76074c691f7bc9656642039721293ad30" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the usual three. Implies &lt;code&gt;--patch&lt;/code&gt;.</source>
          <target state="translated">用上下文的&amp;lt;n&amp;gt;行而不是通常的三行生成差异。意味着 &lt;code&gt;--patch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5423824f37bf5ebdc5aa787498e564ca92935ec4" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the usual three. Implies &lt;code&gt;--patch&lt;/code&gt;. Implies &lt;code&gt;-p&lt;/code&gt;.</source>
          <target state="translated">用上下文的&amp;lt;n&amp;gt;行而不是通常的三行生成差异。意味着 &lt;code&gt;--patch&lt;/code&gt; 。意味着 &lt;code&gt;-p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5ed7cc57b573e7d3d35a890e87a64e8016055b8" translate="yes" xml:space="preserve">
          <source>Generate patch (see section on generating patches).</source>
          <target state="translated">生成补丁(见生成补丁一节)。</target>
        </trans-unit>
        <trans-unit id="468bd18b2fd829a488878e7cd9b8b00c33a3bf5f" translate="yes" xml:space="preserve">
          <source>Generate patch (see section on generating patches). This is the default.</source>
          <target state="translated">生成补丁(参见生成补丁一节)。这是默认的。</target>
        </trans-unit>
        <trans-unit id="0305bd83d4a1ca283e78c45f30f1d98f9bb246bc" translate="yes" xml:space="preserve">
          <source>Generate plain patches without any diffstats.</source>
          <target state="translated">生成没有任何差异统计的纯补丁。</target>
        </trans-unit>
        <trans-unit id="0cceb279f32e8c4384bb0e8684243cdf862ab779" translate="yes" xml:space="preserve">
          <source>Generate the diff in raw format.</source>
          <target state="translated">生成原始格式的差异。</target>
        </trans-unit>
        <trans-unit id="c49c41c6395d0de919c07a57d58570e04e74713d" translate="yes" xml:space="preserve">
          <source>Generate the diff in raw format. This is the default.</source>
          <target state="translated">生成原始格式的差异。这是默认的。</target>
        </trans-unit>
        <trans-unit id="88ef8fc7ea6872f6140c434b84c60ed4bc477b71" translate="yes" xml:space="preserve">
          <source>Generates a summary of pending changes</source>
          <target state="translated">生成待定变更的摘要</target>
        </trans-unit>
        <trans-unit id="b812709580c6b66bf19a88239714db45c6f547d3" translate="yes" xml:space="preserve">
          <source>Generates an RSS (or Atom) feed of changes to repository.</source>
          <target state="translated">生成版本库变化的RSS(或Atom)源。</target>
        </trans-unit>
        <trans-unit id="6d3ce11672e300b3630956d5357a3f156d393821" translate="yes" xml:space="preserve">
          <source>Generating RSS and Atom feeds of commits, for any branch. The feeds are auto-discoverable in modern web browsers.</source>
          <target state="translated">为任何分支生成RSS和Atom提交源。在现代的网络浏览器中,feeds是可以自动发现的。</target>
        </trans-unit>
        <trans-unit id="39bd3cb8cae2c62c26836b759476b4dce92db62c" translate="yes" xml:space="preserve">
          <source>Generating diff text</source>
          <target state="translated">生成差异文本</target>
        </trans-unit>
        <trans-unit id="6e83f1be8cebf28e1aa935d46feefe8c9c9b6bff" translate="yes" xml:space="preserve">
          <source>Generating diffs</source>
          <target state="translated">生成差异</target>
        </trans-unit>
        <trans-unit id="d70a52c9081d71ce670fc7b47fc3bc012193cc1a" translate="yes" xml:space="preserve">
          <source>Generating patch text with -p</source>
          <target state="translated">用-p生成补丁文本</target>
        </trans-unit>
        <trans-unit id="6aeb48d435992fb6dfeaeb57975b9744c65abe0f" translate="yes" xml:space="preserve">
          <source>Generating projects list using gitweb</source>
          <target state="translated">使用gitweb生成项目列表</target>
        </trans-unit>
        <trans-unit id="77a43161f16023a4081e441eda8d16415635830a" translate="yes" xml:space="preserve">
          <source>Generic &amp;lt;revision range&amp;gt; expression (see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;) means the commits in the specified range.</source>
          <target state="translated">通用&amp;lt;revision range&amp;gt;表达式（请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;中的&amp;ldquo; SPECIFYING REVISIONS&amp;rdquo;部分）表示在指定范围内的提交。</target>
        </trans-unit>
        <trans-unit id="6a8b0f1bc43a4668545c1d049581bdef7899704d" translate="yes" xml:space="preserve">
          <source>Get and set repository or global options</source>
          <target state="translated">获取和设置版本库或全局选项</target>
        </trans-unit>
        <trans-unit id="e36c9f7c3a3791a600900bd999a01e746ced35ba" translate="yes" xml:space="preserve">
          <source>Get the value for a given key (optionally filtered by a regex matching the value). Returns error code 1 if the key was not found and the last value if multiple key values were found.</source>
          <target state="translated">获取一个给定键的值(可选择通过与该值匹配的regex进行过滤),如果没有找到键,则返回错误代码1,如果找到多个键,则返回最后一个值。如果没有找到键,返回错误代码1,如果找到多个键值,返回最后一个值。</target>
        </trans-unit>
        <trans-unit id="1ed0d09699cf6099e40ea031af476399c03ae869" translate="yes" xml:space="preserve">
          <source>Gets the Subversion property given as the first argument, for a file. A specific revision can be specified with -r/--revision.</source>
          <target state="translated">获取一个文件的Subversion属性,作为第一个参数。可以用-r/--revision指定一个特定的版本。</target>
        </trans-unit>
        <trans-unit id="516c94a58b7d13bbfd33d93293ff07c0a7a0cbf5" translate="yes" xml:space="preserve">
          <source>Getting and Creating Projects</source>
          <target state="translated">获取和创建项目</target>
        </trans-unit>
        <trans-unit id="970eb65fbea28c10c8dd662819611907796540db" translate="yes" xml:space="preserve">
          <source>Getting changes out is easy:</source>
          <target state="translated">把变化拿出来很容易。</target>
        </trans-unit>
        <trans-unit id="f3ce20bb7af9a1868b401164829dfe90efbb8e6d" translate="yes" xml:space="preserve">
          <source>Getting conflict-resolution help during a merge</source>
          <target state="translated">在合并过程中获得解决冲突的帮助</target>
        </trans-unit>
        <trans-unit id="060f712c74598ce01e86d56802d9344d8ed68bb7" translate="yes" xml:space="preserve">
          <source>Getting help</source>
          <target state="translated">获得帮助</target>
        </trans-unit>
        <trans-unit id="c459e54c0b44554b9b817457994c7c37528258a0" translate="yes" xml:space="preserve">
          <source>Getting updates with git pull</source>
          <target state="translated">用git pull获取更新</target>
        </trans-unit>
        <trans-unit id="5819778898df55e3a762f0c5728b457970d72cae" translate="yes" xml:space="preserve">
          <source>Git</source>
          <target state="translated">Git</target>
        </trans-unit>
        <trans-unit id="d732d81f4de6cbbc7c08999550694240dc675ed1" translate="yes" xml:space="preserve">
          <source>Git Commits</source>
          <target state="translated">承诺</target>
        </trans-unit>
        <trans-unit id="d0aaf3f6b8eb7d9c0d9e9cfe8351718f5fff142e" translate="yes" xml:space="preserve">
          <source>Git Diffs</source>
          <target state="translated">Git差异</target>
        </trans-unit>
        <trans-unit id="2f8f97d0e40130f1bd878938daff8ad22d7dc440" translate="yes" xml:space="preserve">
          <source>Git Native</source>
          <target state="translated">Git本地</target>
        </trans-unit>
        <trans-unit id="29dd0634894701f7508333c275f98d0f1320daee" translate="yes" xml:space="preserve">
          <source>Git Repository Layout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e98b90bf56079b25bb9356fe9439f3123affff" translate="yes" xml:space="preserve">
          <source>Git Thread Messages</source>
          <target state="translated">Git主题消息</target>
        </trans-unit>
        <trans-unit id="cae0e86da292416c6a36a0e4ce238566c9d247c3" translate="yes" xml:space="preserve">
          <source>Git Transport</source>
          <target state="translated">Git运输</target>
        </trans-unit>
        <trans-unit id="a7c39055264c29496e9ec925896bc3e3ec696cb4" translate="yes" xml:space="preserve">
          <source>Git allows you to specify scripts called &quot;hooks&quot; to be run at certain points. You can use these, for example, to send all commits to the shared repository to a mailing list. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">Git允许您指定称为&amp;ldquo;挂钩&amp;rdquo;的脚本，以便在某些时候运行。例如，您可以使用这些命令将对共享存储库的所有提交发送到邮件列表。参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d26d4c60652b93a42ab638ebb72c8ba6beaba72" translate="yes" xml:space="preserve">
          <source>Git also keeps a pristine copy of Alice&amp;rsquo;s master branch under the name &quot;origin/master&quot;:</source>
          <target state="translated">Git还以&amp;ldquo; origin / master&amp;rdquo;的名称保留了Alice的master分支的原始副本：</target>
        </trans-unit>
        <trans-unit id="1738762c7d776a74999cdf10e57649ca4dc7876a" translate="yes" xml:space="preserve">
          <source>Git also provides a tool called &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; (am stands for &quot;apply mailbox&quot;), for importing such an emailed series of patches. Just save all of the patch-containing messages, in order, into a single mailbox file, say &lt;code&gt;patches.mbox&lt;/code&gt;, then run</source>
          <target state="translated">Git还提供了一个名为&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;的工具（am代表&amp;ldquo;应用邮箱&amp;rdquo;），用于导入通过电子邮件发送的一系列补丁。只需按顺序将所有包含补丁程序的消息保存到单个邮箱文件（例如 &lt;code&gt;patches.mbox&lt;/code&gt; ，然后运行</target>
        </trans-unit>
        <trans-unit id="1dc53eccf42e15dc7948bd5d68aac36dca57063c" translate="yes" xml:space="preserve">
          <source>Git archive</source>
          <target state="translated">归档</target>
        </trans-unit>
        <trans-unit id="54c5b60d3b067a46392b8d1f7e7e747f00fb6589" translate="yes" xml:space="preserve">
          <source>Git can also be used in a CVS-like mode, with a central repository that various users push changes to; see &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">Git也可以在类似CVS的模式下使用，中央存储库可供各种用户将更改推送到其中。参见&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;和&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12dda0ab622d98c0bb3ecd2dcca2f78143c72090" translate="yes" xml:space="preserve">
          <source>Git can detect errors when it reads an object, by checking that the object&amp;rsquo;s name is still the SHA-1 hash of its contents.</source>
          <target state="translated">通过检查对象的名称仍然是其内容的SHA-1哈希，Git可以在读取对象时检测到错误。</target>
        </trans-unit>
        <trans-unit id="e99355d5c834d0a7e793f2a903c686c73ccc0248" translate="yes" xml:space="preserve">
          <source>Git can help you perform a three-way merge, which can in turn be used for a many-way merge by repeating the merge procedure several times. The usual situation is that you only do one three-way merge (reconciling two lines of history) and commit the result, but if you like to, you can merge several branches in one go.</source>
          <target state="translated">Git可以帮助你进行三向合并,而三向合并又可以通过重复几次合并过程来进行多向合并。通常情况下,您只需进行一次三向合并(调和两行历史记录)并提交结果,但如果您喜欢,您可以一次合并多个分支。</target>
        </trans-unit>
        <trans-unit id="9711e4cc3e77224217a8eadfcd9bddb77a1a6b3f" translate="yes" xml:space="preserve">
          <source>Git can quickly determine whether two objects are identical or not, just by comparing names.</source>
          <target state="translated">Git可以通过比较名称,快速判断两个对象是否相同。</target>
        </trans-unit>
        <trans-unit id="66761dbf024e7710e093b6a26bb079c9a462b99d" translate="yes" xml:space="preserve">
          <source>Git comes with a &quot;curl&quot; family of remote helpers, that handle various transport protocols, such as &lt;code&gt;git-remote-http&lt;/code&gt;, &lt;code&gt;git-remote-https&lt;/code&gt;, &lt;code&gt;git-remote-ftp&lt;/code&gt; and &lt;code&gt;git-remote-ftps&lt;/code&gt;. They implement the capabilities &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;option&lt;/code&gt;, and &lt;code&gt;push&lt;/code&gt;.</source>
          <target state="translated">Git带有一个&amp;ldquo; curl&amp;rdquo;远程帮助程序家族，可处理各种传输协议，例如 &lt;code&gt;git-remote-http&lt;/code&gt; ， &lt;code&gt;git-remote-https&lt;/code&gt; ， &lt;code&gt;git-remote-ftp&lt;/code&gt; 和 &lt;code&gt;git-remote-ftps&lt;/code&gt; 。它们实现了功能 &lt;code&gt;fetch&lt;/code&gt; ， &lt;code&gt;option&lt;/code&gt; 和 &lt;code&gt;push&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91008229119a3ca60fa9a13273e5a206ad3c01e1" translate="yes" xml:space="preserve">
          <source>Git command-line interface and conventions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590c7b2e50468cb97c1bacdf4c22b05f53204bcc" translate="yes" xml:space="preserve">
          <source>Git commands</source>
          <target state="translated">Git命令</target>
        </trans-unit>
        <trans-unit id="e6bbe100ffbb71b436da9280cdb6bde42146239e" translate="yes" xml:space="preserve">
          <source>Git commands that add repository data, such as &lt;code&gt;git add&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, are optimized for a responsive user experience. These commands do not take time to optimize the Git data, since such optimizations scale with the full size of the repository while these user commands each perform a relatively small action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748a4c7cdb8da160e4137b5f163f8f4f719642f9" translate="yes" xml:space="preserve">
          <source>Git concepts</source>
          <target state="translated">Git的概念</target>
        </trans-unit>
        <trans-unit id="23daed08ae51790de19c33ed17896e5944bcf442" translate="yes" xml:space="preserve">
          <source>Git considers each credential to have a context defined by a URL. This context is used to look up context-specific configuration, and is passed to any helpers, which may use it as an index into secure storage.</source>
          <target state="translated">Git认为每个凭证都有一个由URL定义的上下文。这个上下文用于查找特定的配置,并传递给任何帮助者,帮助者可以使用它作为安全存储的索引。</target>
        </trans-unit>
        <trans-unit id="50d371d1d26e20ed2106ca5d2c77efab159f6b5e" translate="yes" xml:space="preserve">
          <source>Git data exporter</source>
          <target state="translated">Git数据导出器</target>
        </trans-unit>
        <trans-unit id="df14b19afe5ac9b190d2e62a9bb072306d0becda" translate="yes" xml:space="preserve">
          <source>Git did not try to send the ref at all, typically because it is not a fast-forward and you did not force the update.</source>
          <target state="translated">Git根本没有尝试发送ref,一般是因为不是快进,你没有强制更新。</target>
        </trans-unit>
        <trans-unit id="2dac5af4573e16931bda9b37c2f40888a8b49b4e" translate="yes" xml:space="preserve">
          <source>Git diff features. By performing only the transformation step yourself, you can still utilize many of Git&amp;rsquo;s diff features, including colorization, word-diff, and combined diffs for merges.</source>
          <target state="translated">Git diff功能。通过仅自己执行转换步骤，您仍然可以利用Git的许多差异功能，包括着色，单词差异和合并的差异进行合并。</target>
        </trans-unit>
        <trans-unit id="4e4742213b12ec1297779eac50efdab191f84da4" translate="yes" xml:space="preserve">
          <source>Git differs from CVS in that every working tree contains a repository with a full copy of the project history, and no repository is inherently more important than any other. However, you can emulate the CVS model by designating a single shared repository which people can synchronize with; this document explains how to do that.</source>
          <target state="translated">Git 与 CVS 的不同之处在于,每个工作树都包含一个包含项目历史记录完整副本的仓库,而且没有一个仓库比其他仓库更重要。不过,你可以模仿 CVS 模式,指定一个人们可以同步的共享仓库;本文档将解释如何做到这一点。</target>
        </trans-unit>
        <trans-unit id="52ba75f7d53c0098d95000c61cda5fd5ea6917af" translate="yes" xml:space="preserve">
          <source>Git directory name</source>
          <target state="translated">Git目录名</target>
        </trans-unit>
        <trans-unit id="5d9fa4d20745d4b5b2bcfd60f9d543f73fbbd4e6" translate="yes" xml:space="preserve">
          <source>Git directory name, where all characters except for alphanumeric ones, &lt;code&gt;.&lt;/code&gt;, and &lt;code&gt;-&lt;/code&gt; are replaced with &lt;code&gt;_&lt;/code&gt; (this should make it easier to use the directory name in a filename if wanted)</source>
          <target state="translated">Git目录名称，其中所有字符（字母数字字符除外） &lt;code&gt;.&lt;/code&gt; ，和 &lt;code&gt;-&lt;/code&gt; 用 &lt;code&gt;_&lt;/code&gt; 替换（如果需要，这将使在文件名中使用目录名更加容易）</target>
        </trans-unit>
        <trans-unit id="9cf813a3cd69ecbe5e00c63d983206328e14b759" translate="yes" xml:space="preserve">
          <source>Git does not allow partial checkouts, so duplicating this approach in Git would force developers to keep a local copy of modules they are not interested in touching. Commits in an enormous checkout would be slower than you&amp;rsquo;d expect as Git would have to scan every directory for changes. If modules have a lot of local history, clones would take forever.</source>
          <target state="translated">Git不允许部分检出，因此在Git中复制此方法将迫使开发人员保留对其不感兴趣的模块的本地副本。由于Git必须扫描每个目录以查找更改，因此提交大量检出记录的速度将比您预期的慢。如果模块有很多本地历史记录，则克隆将永远花费。</target>
        </trans-unit>
        <trans-unit id="718598b117cdad22b8a0b122e08477cf8ade0f78" translate="yes" xml:space="preserve">
          <source>Git doesn&amp;rsquo;t provide a way to do this. The reason is that if Git needs to overwrite this file, such as during a checkout, it doesn&amp;rsquo;t know whether the changes to the file are precious and should be kept, or whether they are irrelevant and can safely be destroyed. Therefore, it has to take the safe route and always preserve them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b2d9679cf8575fc6c4cfb84434fb5d8180eb7ab" translate="yes" xml:space="preserve">
          <source>Git explained</source>
          <target state="translated">Git解释说</target>
        </trans-unit>
        <trans-unit id="97b68f2c19cbd9c04d7ca8ff88d2678de8cfd1c0" translate="yes" xml:space="preserve">
          <source>Git for CVS users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db9018815b17c54cf84524352784d68bf492b44" translate="yes" xml:space="preserve">
          <source>Git glossary</source>
          <target state="translated">Git词汇表</target>
        </trans-unit>
        <trans-unit id="11c6d04869311aae599c74c45ab29a30fd9dc2d3" translate="yes" xml:space="preserve">
          <source>Git has a default disposition of keeping data unless it&amp;rsquo;s explicitly thrown away; this extends to holding onto local references to branches on remotes that have themselves deleted those branches.</source>
          <target state="translated">Git的默认设置是保留数据，除非明确将其丢弃。这扩展到保留本地引用，这些引用本身已删除了那些分支。</target>
        </trans-unit>
        <trans-unit id="c792c246c2740fcc85816c7742979ab9c07c5067" translate="yes" xml:space="preserve">
          <source>Git has an internal interface for storing and retrieving credentials from system-specific helpers, as well as prompting the user for usernames and passwords. The git-credential command exposes this interface to scripts which may want to retrieve, store, or prompt for credentials in the same manner as Git. The design of this scriptable interface models the internal C API; see credential.h for more background on the concepts.</source>
          <target state="translated">Git 有一个内部接口,用于存储和检索系统特定助手的证书,以及提示用户输入用户名和密码。git-credential 命令向脚本开放了这个接口,脚本可以像 Git 一样检索、存储或提示用户输入凭证。这个可脚本接口的设计与内部的 C API 一样,请参见 credential.h 以了解更多的概念背景。</target>
        </trans-unit>
        <trans-unit id="b5c69a965c60312962f3f44179acdc3a60b40e17" translate="yes" xml:space="preserve">
          <source>Git has no way of knowing that the new head is an updated version of the old head; it treats this situation exactly the same as it would if two developers had independently done the work on the old and new heads in parallel. At this point, if someone attempts to merge the new head in to their branch, Git will attempt to merge together the two (old and new) lines of development, instead of trying to replace the old by the new. The results are likely to be unexpected.</source>
          <target state="translated">Git 无法知道新的开发头是旧开发头的更新版本;它对这种情况的处理方式与两个开发者同时独立完成新旧开发头的工作是一样的。此时,如果有人试图将新的头合并到自己的分支中,Git会试图将两条(新旧)开发线合并在一起,而不是试图用新的头取代旧的头。结果很可能会出乎意料。</target>
        </trans-unit>
        <trans-unit id="06c2297147a37b1c482365d9d8f31d8dedf40fc4" translate="yes" xml:space="preserve">
          <source>Git history is represented as a series of interrelated commits. We have already seen that the &lt;code&gt;git log&lt;/code&gt; command can list those commits. Note that first line of each git log entry also gives a name for the commit:</source>
          <target state="translated">Git历史记录表示为一系列相互关联的提交。我们已经看到 &lt;code&gt;git log&lt;/code&gt; 命令可以列出那些提交。请注意，每个git日志条目的第一行也为提交提供了名称：</target>
        </trans-unit>
        <trans-unit id="3e99ade0692d549a8a950dd96317ceaffb9107bb" translate="yes" xml:space="preserve">
          <source>Git imposes the following rules on how references are named:</source>
          <target state="translated">Git对引用的命名方式规定了以下规则。</target>
        </trans-unit>
        <trans-unit id="a288f739ab4cf5d9993c702076fe0dc6fc3ee3ba" translate="yes" xml:space="preserve">
          <source>Git internal format</source>
          <target state="translated">Git内部格式</target>
        </trans-unit>
        <trans-unit id="64a97e8eaa30379dfa62ee80bea9820c4fe8a22e" translate="yes" xml:space="preserve">
          <source>Git is a Distributed Version Control system (DVCS) created by Linus Torvalds and maintained by Junio Hamano.</source>
          <target state="translated">Git是一个分布式版本控制系统(DVCS),由Linus Torvalds创建并由Junio Hamano维护。</target>
        </trans-unit>
        <trans-unit id="f3967c7f5aeb4487a30c2b76c0330d8f45c7d45a" translate="yes" xml:space="preserve">
          <source>Git is a fast distributed revision control system.</source>
          <target state="translated">Git是一个快速的分布式修订控制系统。</target>
        </trans-unit>
        <trans-unit id="39998d13fc7a27f9efbe60a086c013b3bd3030af" translate="yes" xml:space="preserve">
          <source>Git is a fast, scalable, distributed revision control system with an unusually rich command set that provides both high-level operations and full access to internals.</source>
          <target state="translated">Git是一个快速的、可扩展的、分布式的修订控制系统,它拥有异常丰富的命令集,既能提供高级别的操作,又能完全访问内部。</target>
        </trans-unit>
        <trans-unit id="9fb5868e31358193ca8585301de5ca9891b34989" translate="yes" xml:space="preserve">
          <source>Git is best thought of as a tool for storing the history of a collection of files. It does this by storing compressed snapshots of the contents of a file hierarchy, together with &quot;commits&quot; which show the relationships between these snapshots.</source>
          <target state="translated">最好的理解是,Git是一个存储文件集合历史的工具,它通过存储文件层次结构的压缩快照,以及显示这些快照之间关系的 &quot;提交 &quot;来实现。它通过存储文件层次结构内容的压缩快照,以及显示这些快照之间关系的 &quot;提交 &quot;来实现。</target>
        </trans-unit>
        <trans-unit id="35ff36d5accbb4f2dda359fd3229598730d5aa08" translate="yes" xml:space="preserve">
          <source>Git is best thought of as a tool for storing the history of a collection of files. It stores the history as a compressed collection of interrelated snapshots of the project&amp;rsquo;s contents. In Git each such version is called a &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt;.</source>
          <target state="translated">最好将Git视为用于存储文件历史记录的工具。它将历史记录存储为项目内容相关快照的压缩集合。在Git中，每个这样的版本都称为&lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a9590b40529c70c530e12c39759365698786125" translate="yes" xml:space="preserve">
          <source>Git is built on a small number of simple but powerful ideas. While it is possible to get things done without understanding them, you will find Git much more intuitive if you do.</source>
          <target state="translated">Git 是建立在少量简单而强大的理念之上的。虽然不了解这些理念也可以完成任务,但如果了解了这些理念,你会发现Git更加直观。</target>
        </trans-unit>
        <trans-unit id="acccb72bd7439cce396900f6956100688cfe6ddd" translate="yes" xml:space="preserve">
          <source>Git is to some extent character encoding agnostic.</source>
          <target state="translated">Git在某种程度上是不可知的字符编码。</target>
        </trans-unit>
        <trans-unit id="db4366f04a4436ab91b01ad18e3f75e42a556e25" translate="yes" xml:space="preserve">
          <source>Git namespaces</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87c04c678f1edcfea18d0a701f5da80659e7540" translate="yes" xml:space="preserve">
          <source>Git neither stops nor restarts the filter process in case the &quot;error&quot;/&quot;abort&quot; status is set. However, Git sets its exit code according to the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; flag, mimicking the behavior of the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.clean&lt;/code&gt; / &lt;code&gt;filter.&amp;lt;driver&amp;gt;.smudge&lt;/code&gt; mechanism.</source>
          <target state="translated">如果设置了&amp;ldquo;错误&amp;rdquo; /&amp;ldquo;中止&amp;rdquo;状态，Git既不会停止也不会重新启动过滤过程。然而，GIT中根据设置它的退出代码 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; 标志，模仿的行为 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.clean&lt;/code&gt; / &lt;code&gt;filter.&amp;lt;driver&amp;gt;.smudge&lt;/code&gt; 机制。</target>
        </trans-unit>
        <trans-unit id="bcbcedc091eff7502178afecdce9f3afdc72dc05" translate="yes" xml:space="preserve">
          <source>Git provides extremely flexible and fast tools for exploring the history of a project.</source>
          <target state="translated">Git提供了极其灵活和快速的工具来探索项目的历史。</target>
        </trans-unit>
        <trans-unit id="38200bd70c851718b2397208bade5f568860b37a" translate="yes" xml:space="preserve">
          <source>Git recognizes files encoded in ASCII or one of its supersets (e.g. UTF-8, ISO-8859-1, &amp;hellip;​) as text files. Files encoded in certain other encodings (e.g. UTF-16) are interpreted as binary and consequently built-in Git text processing tools (e.g. &lt;code&gt;git diff&lt;/code&gt;) as well as most Git web front ends do not visualize the contents of these files by default.</source>
          <target state="translated">Git将以ASCII或其超集之一（例如UTF-8，ISO-8859-1等）编码的文件识别为文本文件。默认情况下，以某些其他编码（例如UTF-16）编码的文件被解释为二进制文件，因此内置的Git文本处理工具（例如 &lt;code&gt;git diff&lt;/code&gt; ）以及大多数Git Web前端都不可视化这些文件的内容。</target>
        </trans-unit>
        <trans-unit id="db884716c8275e6cfa36ed29dbc5d360bba57d0e" translate="yes" xml:space="preserve">
          <source>Git relies on the proper configuration of this variable for your operating and file system. Modifying this value may result in unexpected behavior.</source>
          <target state="translated">Git依赖于这个变量在你的操作系统和文件系统中的正确配置。修改这个变量可能会导致意外的行为。</target>
        </trans-unit>
        <trans-unit id="a66f7e50154ea192af5f4749135be70398075b72" translate="yes" xml:space="preserve">
          <source>Git repositories are normally totally self-sufficient and relocatable. Unlike CVS, for example, there is no separate notion of &quot;repository&quot; and &quot;working tree&quot;. A Git repository normally &lt;strong&gt;is&lt;/strong&gt; the working tree, with the local Git information hidden in the &lt;code&gt;.git&lt;/code&gt; subdirectory. There is nothing else. What you see is what you got.</source>
          <target state="translated">Git存储库通常是完全自给自足且可重定位的。例如，与CVS不同，没有&amp;ldquo;存储库&amp;rdquo;和&amp;ldquo;工作树&amp;rdquo;的单独概念。一个Git仓库通常&lt;strong&gt;是&lt;/strong&gt;工作树，本地的Git信息隐藏在 &lt;code&gt;.git&lt;/code&gt; 子目录中。没有别的了。所见即所得。</target>
        </trans-unit>
        <trans-unit id="cf8c005d3f0e4d9e1ff9d1e8d46ef8fd98f0bbf4" translate="yes" xml:space="preserve">
          <source>Git repository format versions</source>
          <target state="translated">Git仓库的格式版本</target>
        </trans-unit>
        <trans-unit id="cd868bd588534f7cc4b6680d57c0627b3503b53c" translate="yes" xml:space="preserve">
          <source>Git sends the remote helper a list of commands on standard input, one per line. The first command is always the &lt;code&gt;capabilities&lt;/code&gt; command, in response to which the remote helper must print a list of the capabilities it supports (see below) followed by a blank line. The response to the capabilities command determines what commands Git uses in the remainder of the command stream.</source>
          <target state="translated">Git向远程帮助程序发送标准输入上的命令列表，每行一个。第一个命令始终是 &lt;code&gt;capabilities&lt;/code&gt; 命令，作为响应，远程帮助程序必须打印其支持的功能列表（请参见下文），后跟空白行。对功能命令的响应确定了Git在命令流的其余部分中使用了哪些命令。</target>
        </trans-unit>
        <trans-unit id="49f2ae128519616ee7193d5988bcbce620249ed4" translate="yes" xml:space="preserve">
          <source>Git supports dividing the refs of a single repository into multiple namespaces, each of which has its own branches, tags, and HEAD. Git can expose each namespace as an independent repository to pull from and push to, while sharing the object store, and exposing all the refs to operations such as &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">Git支持将单个存储库的引用划分为多个命名空间，每个命名空间都有自己的分支，标签和HEAD。Git可以将每个名称空间公开为一个独立的存储库，以便在共享对象存储的同时从中推入和推入，并将所有ref公开给诸如&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]之类的操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da0d87f50d864c408fa4b395576786d97bb31ddd" translate="yes" xml:space="preserve">
          <source>Git supports ssh, git, http, and https protocols (in addition, ftp, and ftps can be used for fetching, but this is inefficient and deprecated; do not use it).</source>
          <target state="translated">Git支持ssh、git、http、https协议(此外,还可以使用ftp、ftps进行获取,但效率低下,已被废弃,请勿使用)。</target>
        </trans-unit>
        <trans-unit id="2cde7635ac8cf69f2e210aa19a54d3042440cb25" translate="yes" xml:space="preserve">
          <source>Git tracks content not files</source>
          <target state="translated">Git跟踪的是内容而不是文件</target>
        </trans-unit>
        <trans-unit id="d302527fd1d763cfe7e5d18396b3435236371be0" translate="yes" xml:space="preserve">
          <source>Git treats the pattern as a shell glob suitable for consumption by fnmatch(3) with the FNM_PATHNAME flag: wildcards in the pattern will not match a / in the pathname. For example, &quot;Documentation/*.html&quot; matches &quot;Documentation/git.html&quot; but not &quot;Documentation/ppc/ppc.html&quot; or &quot;tools/perf/Documentation/perf.html&quot;.</source>
          <target state="translated">Git 将模式视为适合由 fnmatch(3)用 FNM_PATHNAME 标志来使用的 shell glob:模式中的通配符不会与路径名中的/匹配,例如,&quot;Documentation/*.html&quot; 匹配 &quot;Documentation/git.html&quot; 而不匹配 &quot;Documentation/ppc/ppc.html&quot; 或 &quot;tools/perf/Documentation/perf.html&quot; 。例如,&quot;Documentation/*.html &quot;匹配 &quot;Documentation/git.html&quot;,但不匹配 &quot;Documentation/ppc/ppc.html &quot;或 &quot;tools/perf/Documentation/perf.html&quot;。</target>
        </trans-unit>
        <trans-unit id="f8bad0cd453249cf5d129aec87c3431738399e00" translate="yes" xml:space="preserve">
          <source>Git understands the following attributes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e54cce67cf2641b15706179b6168b5a2d3b1bcd" translate="yes" xml:space="preserve">
          <source>Git urls</source>
          <target state="translated">Git的尿性</target>
        </trans-unit>
        <trans-unit id="751190188de5688aa514632f7b1c3310593ad2c7" translate="yes" xml:space="preserve">
          <source>Git users can broadly be grouped into four categories for the purposes of describing here a small set of useful command for everyday Git.</source>
          <target state="translated">Git用户大致可以分为四类,在此介绍一小套日常Git的实用命令。</target>
        </trans-unit>
        <trans-unit id="b7ac07d144784e0a8c84df59d7316744b8847546" translate="yes" xml:space="preserve">
          <source>Git uses a simple text format to store customizations that are per repository and are per user. Such a configuration file may look like this:</source>
          <target state="translated">Git使用一种简单的文本格式来存储每个仓库和每个用户的自定义。这样的配置文件可能是这样的。</target>
        </trans-unit>
        <trans-unit id="172b4ceb66bee5a713d5dcc15584b89df5db983d" translate="yes" xml:space="preserve">
          <source>Git usually guesses correctly whether a blob contains text or binary data by examining the beginning of the contents. However, sometimes you may want to override its decision, either because a blob contains binary data later in the file, or because the content, while technically composed of text characters, is opaque to a human reader. For example, many postscript files contain only ASCII characters, but produce noisy and meaningless diffs.</source>
          <target state="translated">Git 通常会通过检查内容的开头来正确地猜测一个 blob 是包含文本还是二进制数据。然而,有时您可能想推翻它的决定,因为一个 blob 在文件的后面包含了二进制数据,或者虽然技术上是由文本字符组成的,但内容对人类读者来说是不透明的。例如,许多postscript文件只包含ASCII字符,但却产生了嘈杂而无意义的差异。</target>
        </trans-unit>
        <trans-unit id="8049931f388e861f0f1d36c522924184358c43ba" translate="yes" xml:space="preserve">
          <source>Git was started by Linus Torvalds, and is currently maintained by Junio C Hamano. Numerous contributions have come from the Git mailing list &amp;lt;&lt;a href=&quot;mailto:git@vger.kernel.org&quot;&gt;git@vger.kernel.org&lt;/a&gt;&amp;gt;. &lt;a href=&quot;http://www.openhub.net/p/git/contributors/summary&quot;&gt;http://www.openhub.net/p/git/contributors/summary&lt;/a&gt; gives you a more complete list of contributors.</source>
          <target state="translated">Git由Linus Torvalds启动，目前由Junio C Hamano维护。来自Git邮件列表&amp;lt; &lt;a href=&quot;mailto:git@vger.kernel.org&quot;&gt;git@vger.kernel.org&lt;/a&gt; &amp;gt;的贡献很多。&lt;a href=&quot;http://www.openhub.net/p/git/contributors/summary&quot;&gt;http://www.openhub.net/p/git/contributors/summary&lt;/a&gt;为您提供了更完整的贡献者列表。</target>
        </trans-unit>
        <trans-unit id="526caa17e283066f503c081c2465980601606a1b" translate="yes" xml:space="preserve">
          <source>Git web interface (web frontend to Git repositories)</source>
          <target state="translated">Git网络接口(Git仓库的网络前端)。</target>
        </trans-unit>
        <trans-unit id="041fb03988c0360186f3faf7d7f4aee25aff3a46" translate="yes" xml:space="preserve">
          <source>Git will apply each patch in order; if any conflicts are found, it will stop, and you can fix the conflicts as described in &quot;&lt;a href=&quot;#resolving-a-merge&quot;&gt;Resolving a merge&lt;/a&gt;&quot;. (The &lt;code&gt;-3&lt;/code&gt; option tells Git to perform a merge; if you would prefer it just to abort and leave your tree and index untouched, you may omit that option.)</source>
          <target state="translated">Git将按顺序应用每个补丁；如果发现任何冲突，它将停止，您可以按照&amp;ldquo; &lt;a href=&quot;#resolving-a-merge&quot;&gt;解决合并&lt;/a&gt; &amp;rdquo;中的说明解决冲突。（ &lt;code&gt;-3&lt;/code&gt; 选项告诉Git执行合并；如果您希望它仅中止并使树和索引保持不变，则可以忽略该选项。）</target>
        </trans-unit>
        <trans-unit id="5affbc744831be1e58dd602e173c2e8a9635241c" translate="yes" xml:space="preserve">
          <source>Git will fail (gracefully) in case it needs to modify this file in the index e.g. when merging in a commit; thus, in case the assumed-untracked file is changed upstream, you will need to handle the situation manually.</source>
          <target state="translated">如果Git需要修改索引中的这个文件,例如在提交中合并时,Git会失败(优雅地);因此,如果上游修改了假定未跟踪的文件,你将需要手动处理这种情况。</target>
        </trans-unit>
        <trans-unit id="48da4a71e3b0bf95013a3e083375ba4a4f8d9442" translate="yes" xml:space="preserve">
          <source>Git will limit what files it checks for changes as well as which directories are checked for untracked files based on the path names given.</source>
          <target state="translated">Git会根据给定的路径名,限制它检查哪些文件的变化,以及检查哪些目录的未跟踪文件。</target>
        </trans-unit>
        <trans-unit id="9b6711c26bfff56f55ea4e0cb9cd80ae556f923a" translate="yes" xml:space="preserve">
          <source>Git will reply</source>
          <target state="translated">Git会回复</target>
        </trans-unit>
        <trans-unit id="bca1285083439b77ee97a317766aadc935c0bbdf" translate="yes" xml:space="preserve">
          <source>Git will sometimes need credentials from the user in order to perform operations; for example, it may need to ask for a username and password in order to access a remote repository over HTTP. This manual describes the mechanisms Git uses to request these credentials, as well as some features to avoid inputting these credentials repeatedly.</source>
          <target state="translated">Git有时会需要用户提供凭证才能进行操作,例如,通过HTTP访问远程仓库时可能会要求用户提供用户名和密码。本手册介绍了 Git 用于请求这些凭证的机制,以及一些避免重复输入这些凭证的功能。</target>
        </trans-unit>
        <trans-unit id="8d4d562674abf840efcd10226ed9d3b454480154" translate="yes" xml:space="preserve">
          <source>Git works best when you store text files as UTF-8. Many programs on Windows support UTF-8, but some do not and only use the little-endian UTF-16 format, which Git detects as binary. If you can&amp;rsquo;t use UTF-8 with your programs, you can specify a working tree encoding that indicates which encoding your files should be checked out with, while still storing these files as UTF-8 in the repository. This allows tools like &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; to work as expected, while still allowing your tools to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4de92d6643474e91f15af2289a2ff1175302eb" translate="yes" xml:space="preserve">
          <source>Git writes temporary &lt;code&gt;BASE&lt;/code&gt;, &lt;code&gt;LOCAL&lt;/code&gt;, and &lt;code&gt;REMOTE&lt;/code&gt; versions of conflicting files in the worktree by default. Git will attempt to use a temporary directory for these files when set &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Git 默认情况下在工作树中写入冲突文件的 &lt;code&gt;BASE&lt;/code&gt; ， &lt;code&gt;LOCAL&lt;/code&gt; 和 &lt;code&gt;REMOTE&lt;/code&gt; 临时版本。设置为 &lt;code&gt;true&lt;/code&gt; 时，Git将尝试为这些文件使用临时目录。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24c7b4499addc9a93ccbe263411515a9a891fc27" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s ability to quickly import and merge patches allows a single maintainer to process incoming changes even at very high rates. And when that becomes too much, &lt;code&gt;git pull&lt;/code&gt; provides an easy way for that maintainer to delegate this job to other maintainers while still allowing optional review of incoming changes.</source>
          <target state="translated">Git快速导入和合并补丁的能力使单个维护者即使以很高的速度也能处理传入的更改。并且当它变得太多时， &lt;code&gt;git pull&lt;/code&gt; 提供了一种简便的方法，供该维护人员将该工作委派给其他维护人员，同时仍然允许对传入更改进行可选检查。</target>
        </trans-unit>
        <trans-unit id="9715a07ab0249fd3ddbc253711eb7248c1c1366b" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s i18n setup code for shell scripts</source>
          <target state="translated">Git的i18n shell脚本设置代码</target>
        </trans-unit>
        <trans-unit id="4917cf9f784e37253e2667c9ea0e66247909051b" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s submodule support allows a repository to contain, as a subdirectory, a checkout of an external project. Submodules maintain their own identity; the submodule support just stores the submodule repository location and commit ID, so other developers who clone the containing project (&quot;superproject&quot;) can easily clone all the submodules at the same revision. Partial checkouts of the superproject are possible: you can tell Git to clone none, some or all of the submodules.</source>
          <target state="translated">Git的子模块支持允许存储库包含外部项目的签出作为子目录。子模块保持自己的身份；子模块支持仅存储子模块存储库位置和提交ID，因此其他克隆包含项目（&amp;ldquo; superproject&amp;rdquo;）的开发人员可以轻松地克隆相同版本的所有子模块。可以对超级项目进行部分检出：您可以告诉Git不克隆任何，部分或全部子模块。</target>
        </trans-unit>
        <trans-unit id="f1ffaf3a57e8861e273a81c5d860f0898c1c6dac" translate="yes" xml:space="preserve">
          <source>Gitk was the first graphical repository browser. It&amp;rsquo;s written in tcl/tk.</source>
          <target state="translated">Gitk是第一个图形存储库浏览器。它是用tcl / tk编写的。</target>
        </trans-unit>
        <trans-unit id="969a3c97b510dcff0a924faf9dee287a0e5d94ec" translate="yes" xml:space="preserve">
          <source>Gitweb assumes this charset when a line contains non-UTF-8 characters. The fallback decoding is used without error checking, so it can be even &quot;utf-8&quot;. The value must be a valid encoding; see the &lt;strong&gt;Encoding::Supported&lt;/strong&gt;(3pm) man page for a list. The default is &quot;latin1&quot;, aka. &quot;iso-8859-1&quot;.</source>
          <target state="translated">当一行包含非UTF-8字符时，Gitweb将采用此字符集。使用后备解码无需进行错误检查，因此甚至可以是&amp;ldquo; utf-8&amp;rdquo;。该值必须是有效的编码；有关列表，请参见&lt;strong&gt;Encoding :: Supported&lt;/strong&gt;（3pm）手册页。默认为&amp;ldquo; latin1&amp;rdquo;。&amp;ldquo; iso-8859-1&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="23aa8c44f909f60d83eed1c6ecddb35429f0603e" translate="yes" xml:space="preserve">
          <source>Gitweb can show information from one or more Git repositories. These repositories have to be all on local filesystem, and have to share common repository root, i.e. be all under a single parent repository (but see also &quot;Advanced web server setup&quot; section, &quot;Webserver configuration with multiple projects' root&quot; subsection).</source>
          <target state="translated">Gitweb 可以显示一个或多个 Git 仓库的信息。这些仓库必须都在本地文件系统上,并且必须共享仓库根目录,也就是说,所有的仓库都在一个父仓库下(但也可以参考 &quot;高级网络服务器设置 &quot;部分,&quot;多项目根目录的网络服务器配置 &quot;部分)。</target>
        </trans-unit>
        <trans-unit id="80e6e4e3c32d8a850e194d0e624021eac7612871" translate="yes" xml:space="preserve">
          <source>Gitweb can use path_info (component) based URLs, or it can pass all necessary information via query parameters. The typical gitweb URLs are broken down in to five components:</source>
          <target state="translated">Gitweb可以使用基于path_info(组件)的URL,也可以通过查询参数传递所有必要的信息。典型的gitweb URL可以分解为五个组件。</target>
        </trans-unit>
        <trans-unit id="c91227cd181327062eb5ac3babb9dcdd0a92cc2a" translate="yes" xml:space="preserve">
          <source>Gitweb provides a web interface to Git repositories. Its features include:</source>
          <target state="translated">Gitweb为Git仓库提供了一个Web界面。它的功能包括:</target>
        </trans-unit>
        <trans-unit id="b64851fc263d72157b99e98603012bfc29c4f9ff" translate="yes" xml:space="preserve">
          <source>Gitweb reads configuration data from the following sources in the following order:</source>
          <target state="translated">Gitweb按以下顺序从以下来源读取配置数据。</target>
        </trans-unit>
        <trans-unit id="0b6ae99cd0fc07dd07b98d65f39c6a8d809c4979" translate="yes" xml:space="preserve">
          <source>Gitweb version, set automatically when creating gitweb.cgi from gitweb.perl. You might want to modify it if you are running modified gitweb, for example</source>
          <target state="translated">Gitweb 版本,从 gitweb.perl 创建 gitweb.cgi 时自动设置。如果你正在运行修改过的 gitweb,你可能需要修改它,比如说</target>
        </trans-unit>
        <trans-unit id="fcc44369541727be05647a1cc4996dbc27b86060" translate="yes" xml:space="preserve">
          <source>Gitweb works with Apache and FastCGI. First you need to rename, copy or symlink gitweb.cgi to gitweb.fcgi. Let&amp;rsquo;s assume that gitweb is installed in &lt;code&gt;/usr/share/gitweb&lt;/code&gt; directory. The following Apache configuration is suitable (UNTESTED!)</source>
          <target state="translated">Gitweb与Apache和FastCGI一起使用。首先，您需要将gitweb.cgi重命名，复制或符号链接到gitweb.fcgi。假设gitweb安装在 &lt;code&gt;/usr/share/gitweb&lt;/code&gt; 目录中。以下Apache配置是合适的（未测试！）</target>
        </trans-unit>
        <trans-unit id="42543af4180750540520e4da78d3e7076123fd5c" translate="yes" xml:space="preserve">
          <source>Give an object a human readable name based on an available ref</source>
          <target state="translated">根据现有的参考资料,给对象一个可读的名字。</target>
        </trans-unit>
        <trans-unit id="8a08e691bc874c43f32edff7b28078841082dfd2" translate="yes" xml:space="preserve">
          <source>Give push/pull only access to developers using git-over-ssh.</source>
          <target state="translated">只给使用git-over-ssh的开发者推/拉权限。</target>
        </trans-unit>
        <trans-unit id="098611c3aa4062358e82cce32a6cb2188462a62d" translate="yes" xml:space="preserve">
          <source>Give the output in an easy-to-parse format for scripts. This is similar to the short output, but will remain stable across Git versions and regardless of user configuration. See below for details.</source>
          <target state="translated">以易于脚本解析的格式给出输出。这与简短的输出类似,但在Git的各个版本中,无论用户如何配置,都会保持稳定。详情请看下文。</target>
        </trans-unit>
        <trans-unit id="4cab29647a0992b826e617662d099d2fa7b8c337" translate="yes" xml:space="preserve">
          <source>Give the output in the long-format. This is the default.</source>
          <target state="translated">提供长格式的输出。这是默认的。</target>
        </trans-unit>
        <trans-unit id="7b3a4cfa6cfda1ef4f79bab4a1d749c9c6c5f5f0" translate="yes" xml:space="preserve">
          <source>Give the output in the short-format.</source>
          <target state="translated">给出短式的输出。</target>
        </trans-unit>
        <trans-unit id="2dc950b47492cb25f78f25c843f0ed41c631283b" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;--delete&lt;/code&gt; and an additional argument, deletes the given symbolic ref.</source>
          <target state="translated">给定 &lt;code&gt;--delete&lt;/code&gt; 和附加参数，将删除给定的符号ref。</target>
        </trans-unit>
        <trans-unit id="e97e8a091675b0288dfc0175fdb5f7c838cea92d" translate="yes" xml:space="preserve">
          <source>Given N &amp;lt;references&amp;gt;, the first N lines are the one-line description from their commit message. The branch head that is pointed at by $GIT_DIR/HEAD is prefixed with an asterisk &lt;code&gt;*&lt;/code&gt; character while other heads are prefixed with a &lt;code&gt;!&lt;/code&gt; character.</source>
          <target state="translated">给定N个&amp;lt;references&amp;gt;，前N行是其提交消息中的单行描述。$ GIT_DIR / HEAD指向的分支头以星号 &lt;code&gt;*&lt;/code&gt; 字符为前缀，而其他头以 &lt;code&gt;!&lt;/code&gt; 为前缀。字符。</target>
        </trans-unit>
        <trans-unit id="a02a332c45eb3b9cf3b89841e8aa1ca85e593c49" translate="yes" xml:space="preserve">
          <source>Given a .git/config like this:</source>
          <target state="translated">给出这样的.git/config。</target>
        </trans-unit>
        <trans-unit id="e65ae867c8cb398abc725e8538eba217d02dbede" translate="yes" xml:space="preserve">
          <source>Given a commit, find out where it is relative to the local refs. Say somebody wrote you about that fantastic commit 33db5f4d9027a10e477ccf054b2c1ab94f74c85a. Of course, you look into the commit, but that only tells you what happened, but not the context.</source>
          <target state="translated">给定一个提交,找出它相对于本地参考文献的位置,比如有人给你写了33db5f4d9027a10e477ccf054b2c1ab94f74c85a这个神奇的提交,你就可以找到它的位置。假设有人给你写了一篇关于 33db5f4d9027a10e477ccf054b2c1ab94f74c85a 的精彩提交。当然,你查到了这个提交,但这只能告诉你发生了什么,但不能告诉你上下文。</target>
        </trans-unit>
        <trans-unit id="7ce01790b46379d506c51a1991e3ea26b3a8d244" translate="yes" xml:space="preserve">
          <source>Given one argument, reads which branch head the given symbolic ref refers to and outputs its path, relative to the &lt;code&gt;.git/&lt;/code&gt; directory. Typically you would give &lt;code&gt;HEAD&lt;/code&gt; as the &amp;lt;name&amp;gt; argument to see which branch your working tree is on.</source>
          <target state="translated">给定一个参数，读取给定符号ref指向哪个分支头，并输出相对于 &lt;code&gt;.git/&lt;/code&gt; 目录的路径。通常，您可以将 &lt;code&gt;HEAD&lt;/code&gt; 作为&amp;lt;name&amp;gt;参数，以查看工作树位于哪个分支上。</target>
        </trans-unit>
        <trans-unit id="ee9f44e6df9f9221a39559d12563d4ded15eb1ae" translate="yes" xml:space="preserve">
          <source>Given one or more existing commits, apply the change each one introduces, recording a new commit for each. This requires your working tree to be clean (no modifications from the HEAD commit).</source>
          <target state="translated">给定一个或多个现有的提交,应用每个提交所带来的变化,为每个提交记录一个新的提交。这需要你的工作树是干净的(没有从头提交的修改)。</target>
        </trans-unit>
        <trans-unit id="49cfc78f8193ed0e67ffaf9646d690418c000a33" translate="yes" xml:space="preserve">
          <source>Given one or more existing commits, revert the changes that the related patches introduce, and record some new commits that record them. This requires your working tree to be clean (no modifications from the HEAD commit).</source>
          <target state="translated">给定一个或多个现有的提交,恢复相关补丁所带来的变化,并记录一些新的提交,记录它们。这需要你的工作树是干净的(没有来自 HEAD 提交的修改)。</target>
        </trans-unit>
        <trans-unit id="b90c39be8f3013761513d522c230779e0af0700e" translate="yes" xml:space="preserve">
          <source>Given the following noisy input with &lt;code&gt;$&lt;/code&gt; indicating the end of a line:</source>
          <target state="translated">给定以下嘈杂的输入，其中 &lt;code&gt;$&lt;/code&gt; 表示行的结尾：</target>
        </trans-unit>
        <trans-unit id="9ae9c5ba5c0cae940c9ccda71b399bacf0ceae54" translate="yes" xml:space="preserve">
          <source>Given three arguments, stores the &amp;lt;newvalue&amp;gt; in the &amp;lt;ref&amp;gt;, possibly dereferencing the symbolic refs, after verifying that the current value of the &amp;lt;ref&amp;gt; matches &amp;lt;oldvalue&amp;gt;. E.g. &lt;code&gt;git update-ref refs/heads/master &amp;lt;newvalue&amp;gt; &amp;lt;oldvalue&amp;gt;&lt;/code&gt; updates the master branch head to &amp;lt;newvalue&amp;gt; only if its current value is &amp;lt;oldvalue&amp;gt;. You can specify 40 &quot;0&quot; or an empty string as &amp;lt;oldvalue&amp;gt; to make sure that the ref you are creating does not exist.</source>
          <target state="translated">给定三个参数，在验证&amp;lt;ref&amp;gt;的当前值与&amp;lt;oldvalue&amp;gt;匹配后，将&amp;lt;newvalue&amp;gt;存储在&amp;lt;ref&amp;gt;中，可能会取消引用符号ref。例如， &lt;code&gt;git update-ref refs/heads/master &amp;lt;newvalue&amp;gt; &amp;lt;oldvalue&amp;gt;&lt;/code&gt; 值&amp;gt;仅在其当前值为&amp;lt;旧值&amp;gt;时才将主分支头更新为&amp;lt;新值&amp;gt;。您可以将40&amp;ldquo; 0&amp;rdquo;或空字符串指定为&amp;lt;oldvalue&amp;gt;，以确保所创建的引用不存在。</target>
        </trans-unit>
        <trans-unit id="4d8bb10ba2f3cfa88afc4b8727de27fb3cab8018" translate="yes" xml:space="preserve">
          <source>Given three commits &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;git merge-base A B C&lt;/code&gt; will compute the merge base between &lt;code&gt;A&lt;/code&gt; and a hypothetical commit &lt;code&gt;M&lt;/code&gt;, which is a merge between &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;. For example, with this topology:</source>
          <target state="translated">给定三个提交 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; ， &lt;code&gt;git merge-base A B C&lt;/code&gt; 将计算 &lt;code&gt;A&lt;/code&gt; 与假设提交 &lt;code&gt;M&lt;/code&gt; 之间的合并基础，该提交M是 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 之间的合并。例如，使用此拓扑：</target>
        </trans-unit>
        <trans-unit id="be6c9bc842b0965134f1fb7992b74ba082dffe0f" translate="yes" xml:space="preserve">
          <source>Given two arguments, creates or updates a symbolic ref &amp;lt;name&amp;gt; to point at the given branch &amp;lt;ref&amp;gt;.</source>
          <target state="translated">给定两个参数，创建或更新符号ref &amp;lt;名称&amp;gt;以指向给定的分支&amp;lt;ref&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="7cc67b58b4d717f52eb7b590f0c2ac097c83b04a" translate="yes" xml:space="preserve">
          <source>Given two arguments, stores the &amp;lt;newvalue&amp;gt; in the &amp;lt;ref&amp;gt;, possibly dereferencing the symbolic refs. E.g. &lt;code&gt;git update-ref HEAD
&amp;lt;newvalue&amp;gt;&lt;/code&gt; updates the current branch head to the new object.</source>
          <target state="translated">给定两个参数，将&amp;lt;newvalue&amp;gt;存储在&amp;lt;ref&amp;gt;中，可能会取消引用符号ref。例如 &lt;code&gt;git update-ref HEAD &amp;lt;newvalue&amp;gt;&lt;/code&gt; 将当前分支头更新为新对象。</target>
        </trans-unit>
        <trans-unit id="931db30a85fe3ea596ac121ca8f065ad449ff885" translate="yes" xml:space="preserve">
          <source>Given two commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;git merge-base A B&lt;/code&gt; will output a commit which is reachable from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; through the parent relationship.</source>
          <target state="translated">给定两个提交 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;git merge-base A B&lt;/code&gt; 将输出一个提交，该提交可以通过父关系从 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 到达。</target>
        </trans-unit>
        <trans-unit id="b0c09289dc074c18ca9574b29845f64d7cae5bc3" translate="yes" xml:space="preserve">
          <source>Gives some information about the remote &amp;lt;name&amp;gt;.</source>
          <target state="translated">提供有关远程&amp;lt;名称&amp;gt;的一些信息。</target>
        </trans-unit>
        <trans-unit id="9466e3cfe4b90da05672816c37e48d04d2b0bacb" translate="yes" xml:space="preserve">
          <source>Giving these options is an error when used with &lt;code&gt;--inetd&lt;/code&gt;; use the facility of inet daemon to achieve the same before spawning &lt;code&gt;git daemon&lt;/code&gt; if needed.</source>
          <target state="translated">当与 &lt;code&gt;--inetd&lt;/code&gt; 一起使用时，给出这些选项是错误的。如果需要，可以在生成 &lt;code&gt;git daemon&lt;/code&gt; 之前使用inet守护程序的设施来实现相同目的。</target>
        </trans-unit>
        <trans-unit id="d0ec3ae2bdc4ccb842cc8f2251da67f38c6daf5a" translate="yes" xml:space="preserve">
          <source>Glob magic is incompatible with literal magic.</source>
          <target state="translated">Glob魔法与文字魔法是不相容的。</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="d8608c60e7a8f9d556f6c1f2aff537e2ce064bab" translate="yes" xml:space="preserve">
          <source>Go under &quot;Options&quot; in the Composer window and be sure that &quot;Word wrap&quot; is not set.</source>
          <target state="translated">在Composer窗口的 &quot;选项 &quot;下,确定 &quot;Word wrap &quot;没有被设置。</target>
        </trans-unit>
        <trans-unit id="c16a49b3ce3e17532ce6e118e23e9cba92fcb23b" translate="yes" xml:space="preserve">
          <source>Graduation</source>
          <target state="translated">Graduation</target>
        </trans-unit>
        <trans-unit id="7108295a48fb4030d059842641f3ed2f16dd90ea" translate="yes" xml:space="preserve">
          <source>Grafts enables two otherwise different lines of development to be joined together by recording fake ancestry information for commits. This way you can make Git pretend the set of &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt; a &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; has is different from what was recorded when the commit was created. Configured via the &lt;code&gt;.git/info/grafts&lt;/code&gt; file.</source>
          <target state="translated">嫁接通过记录用于提交的虚假祖先信息，可以使另外两个不同的开发线结合在一起。这样，您可以让Git假装&lt;a href=&quot;#def_commit&quot;&gt;提交所&lt;/a&gt;具有的&lt;a href=&quot;#def_parent&quot;&gt;父母&lt;/a&gt;与创建提交时所记录的父母不同。通过 &lt;code&gt;.git/info/grafts&lt;/code&gt; 文件配置。</target>
        </trans-unit>
        <trans-unit id="43addd483f6785ba3f74ca813174b30e77d7804f" translate="yes" xml:space="preserve">
          <source>Graphical alternative to git-commit</source>
          <target state="translated">git-commit的图形化替代方案</target>
        </trans-unit>
        <trans-unit id="7e3e6e185a96c1bddac8bacc3e22b2d8c14f25b3" translate="yes" xml:space="preserve">
          <source>Group commits based on &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;. If no &lt;code&gt;--group&lt;/code&gt; option is specified, the default is &lt;code&gt;author&lt;/code&gt;. &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="7138a51661947b19b5088da5a2bfede2876f49b9" translate="yes" xml:space="preserve">
          <source>HEAD</source>
          <target state="translated">HEAD</target>
        </trans-unit>
        <trans-unit id="f53aba93b9409d79b694657717f24476b7680a38" translate="yes" xml:space="preserve">
          <source>HEAD can also record a specific commit directly, instead of being a symref to point at the current branch. Such a state is often called &lt;code&gt;detached HEAD.&lt;/code&gt; See &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; for details.</source>
          <target state="translated">HEAD也可以直接记录特定的提交，而不必是指向当前分支的symref。这种状态通常称为 &lt;code&gt;detached HEAD.&lt;/code&gt; 有关详细信息，请参见&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="adaf1f885f4f48f7b3c5a9a2b8f4883bf35d0a07" translate="yes" xml:space="preserve">
          <source>HEAD: refers to the head of the current branch</source>
          <target state="translated">HEAD:指当前分支机构的负责人。</target>
        </trans-unit>
        <trans-unit id="408093a274a45499420aa72e738c6e970f863fed" translate="yes" xml:space="preserve">
          <source>HEADER:</source>
          <target state="translated">HEADER:</target>
        </trans-unit>
        <trans-unit id="bd0cfe599144b530c7c9685825d1a02a5377b64e" translate="yes" xml:space="preserve">
          <source>HTML snippet to be included in the &amp;lt;head&amp;gt; section of each page. Can be set using &lt;code&gt;GITWEB_SITE_HTML_HEAD_STRING&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">HTML片段包含在每个页面的&amp;lt;head&amp;gt;部分中。可以在构建时使用 &lt;code&gt;GITWEB_SITE_HTML_HEAD_STRING&lt;/code&gt; 进行设置。无默认值。</target>
        </trans-unit>
        <trans-unit id="cc56a2df9f8b6a66c5d2a6125ab52ed375e5152b" translate="yes" xml:space="preserve">
          <source>HTTP Transport</source>
          <target state="translated">HTTP传输</target>
        </trans-unit>
        <trans-unit id="d578fb1b4bb161c78cd19e50fcb2b009bf47fe3e" translate="yes" xml:space="preserve">
          <source>HTTP(S)</source>
          <target state="translated">HTTP(S)</target>
        </trans-unit>
        <trans-unit id="1ba3338bd0d397031ae85dc0347d63c94b00e5df" translate="yes" xml:space="preserve">
          <source>HTTP/1.1</source>
          <target state="translated">HTTP/1.1</target>
        </trans-unit>
        <trans-unit id="396826d4135990391d3176f7b40c9091eed2c0d3" translate="yes" xml:space="preserve">
          <source>HTTP/2</source>
          <target state="translated">HTTP/2</target>
        </trans-unit>
        <trans-unit id="80bde80e45cfc7c229d507fff6d534806b07378c" translate="yes" xml:space="preserve">
          <source>Hacking git</source>
          <target state="translated">黑进git</target>
        </trans-unit>
        <trans-unit id="f05112b4c52400e25d034f0dd761a59bb897fe7b" translate="yes" xml:space="preserve">
          <source>Halt the background maintenance schedule. The current repository is not removed from the list of maintained repositories, in case the background maintenance is restarted later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b8d31a4ffcd043a96008543e3e1f5d7eaf7692" translate="yes" xml:space="preserve">
          <source>Handling Renames</source>
          <target state="translated">处理重命名</target>
        </trans-unit>
        <trans-unit id="3049c71fe9126eefc3301476201dcd8b12bbbd85" translate="yes" xml:space="preserve">
          <source>Handling of svn branches</source>
          <target state="translated">处理svn分支</target>
        </trans-unit>
        <trans-unit id="b2bb788b2d8872820805621988d07bb34824ee87" translate="yes" xml:space="preserve">
          <source>Hard case: The changes are not the same.</source>
          <target state="translated">硬的情况下。变化是不一样的。</target>
        </trans-unit>
        <trans-unit id="d86493cd0a3bd6cc52c39427d91b4f3fb5f1ba0f" translate="yes" xml:space="preserve">
          <source>Has no effect if the ref does not have tracking information associated with it. All the options apart from &lt;code&gt;nobracket&lt;/code&gt; are mutually exclusive, but if used together the last option is selected.</source>
          <target state="translated">如果参考没有与之关联的跟踪信息，则无效。除 &lt;code&gt;nobracket&lt;/code&gt; 之外的所有选项都是互斥的，但如果一起使用，则选择最后一个选项。</target>
        </trans-unit>
        <trans-unit id="eee44516ee4e4873c5ecfb5a6805b0f8b1007d35" translate="yes" xml:space="preserve">
          <source>Hash object as it were located at the given path. The location of file does not directly influence on the hash value, but path is used to determine what Git filters should be applied to the object before it can be placed to the object database, and, as result of applying filters, the actual blob put into the object database may differ from the given file. This option is mainly useful for hashing temporary files located outside of the working directory or files read from stdin.</source>
          <target state="translated">对位于给定路径的对象进行哈希。文件的位置并不直接影响哈希值,但路径是用来决定在将对象放入对象数据库之前应该对其应用哪些 Git 过滤器,而且由于应用了过滤器,实际放入对象数据库的 blob 可能与给定文件不同。这个选项主要用于对工作目录之外的临时文件或从 stdin 读取的文件进行哈希处理。</target>
        </trans-unit>
        <trans-unit id="100c09777204f7d9c4d9c8cca2b2ca1117efcbe1" translate="yes" xml:space="preserve">
          <source>Hash the contents as is, ignoring any input filter that would have been chosen by the attributes mechanism, including the end-of-line conversion. If the file is read from standard input then this is always implied, unless the &lt;code&gt;--path&lt;/code&gt; option is given.</source>
          <target state="translated">散列内容，而不考虑属性机制选择的任何输入过滤器，包括行尾转换。如果从标准输入中读取文件，则始终暗含该 &lt;code&gt;--path&lt;/code&gt; ，除非给出了--path选项。</target>
        </trans-unit>
        <trans-unit id="f2ae7e4a6dc9825ef1a4868750168492eeaf6380" translate="yes" xml:space="preserve">
          <source>Have the server run as an inetd service. Implies --syslog (may be overridden with &lt;code&gt;--log-destination=&lt;/code&gt;). Incompatible with --detach, --port, --listen, --user and --group options.</source>
          <target state="translated">使服务器作为inetd服务运行。暗示--syslog（可以用 &lt;code&gt;--log-destination=&lt;/code&gt; 覆盖）。与--detach，--port，--listen，--user和--group选项不兼容。</target>
        </trans-unit>
        <trans-unit id="db301d2890ccaa14dc974751b62b359a359b6b5c" translate="yes" xml:space="preserve">
          <source>He also uses a set of temporary branches (&quot;topic branches&quot;), each containing a logical grouping of patches.</source>
          <target state="translated">他还使用了一组临时分支(&quot;主题分支&quot;),每个分支都包含了补丁的逻辑分组。</target>
        </trans-unit>
        <trans-unit id="c983e9a4d9daf24f5efac3a67c8f6c12bda32744" translate="yes" xml:space="preserve">
          <source>He uses two public branches:</source>
          <target state="translated">他使用了两个公共分支机构。</target>
        </trans-unit>
        <trans-unit id="08dac5b0781534f17eedb09bc82379faeed11d4a" translate="yes" xml:space="preserve">
          <source>Header lines start with &quot;#&quot; and are added in response to specific command line arguments. Parsers should ignore headers they don&amp;rsquo;t recognize.</source>
          <target state="translated">标题行以&amp;ldquo;＃&amp;rdquo;开头，​​并根据特定的命令行参数而添加。解析器应忽略不认识的标头。</target>
        </trans-unit>
        <trans-unit id="6f7a484a67443c5c4893cfcebc8516ecb7a4f1a2" translate="yes" xml:space="preserve">
          <source>Help parsing or adding &lt;code&gt;trailers&lt;/code&gt; lines, that look similar to RFC 822 e-mail headers, at the end of the otherwise free-form part of a commit message.</source>
          <target state="translated">在提交消息的其他自由格式部分的末尾，帮助解析或添加类似于RFC 822电子邮件标头的 &lt;code&gt;trailers&lt;/code&gt; 行。</target>
        </trans-unit>
        <trans-unit id="f07e99c3fb43a6bcfb5e09ad2c991cc9571165ae" translate="yes" xml:space="preserve">
          <source>Helper programs to interact with remote repositories</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f00958253572e7e593fd3637f7f812370db1d4" translate="yes" xml:space="preserve">
          <source>Helper to store credentials on disk</source>
          <target state="translated">在磁盘上存储证书的助手</target>
        </trans-unit>
        <trans-unit id="91ab6264d347386bb003d96ff4f148c65df714a3" translate="yes" xml:space="preserve">
          <source>Helper to temporarily store passwords in memory</source>
          <target state="translated">在内存中临时存储密码的助手。</target>
        </trans-unit>
        <trans-unit id="f8801cb816506b471cd751bc46c3d753c8b27a46" translate="yes" xml:space="preserve">
          <source>Hence</source>
          <target state="translated">Hence</target>
        </trans-unit>
        <trans-unit id="8286249a7e764f5f9777c2fc17e5230ccc1ef5fe" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the commit specification expressions also accepted by &lt;code&gt;from&lt;/code&gt; (see above).</source>
          <target state="translated">在这里， &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 是 &lt;code&gt;from&lt;/code&gt; 也接受的任何提交规范表达式（请参见上文）。</target>
        </trans-unit>
        <trans-unit id="3fb766f6c8298c39110428f8565787238a736366" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the following:</source>
          <target state="translated">这里的 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 是以下任意一项：</target>
        </trans-unit>
        <trans-unit id="85bca9b0f87b55d545a8c945215b23dd3bdbffcb" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set by a prior &lt;code&gt;blob&lt;/code&gt; command, or a full 40-byte SHA-1 of an existing Git blob object.</source>
          <target state="translated">在这里， &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 可以是先前的 &lt;code&gt;blob&lt;/code&gt; 命令设置的标记引用（ &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ），也可以是现有Git blob对象的完整40字节SHA-1。</target>
        </trans-unit>
        <trans-unit id="3f53683a6742f0030e51cf7120f8e28dba9865c5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is the person&amp;rsquo;s display name (for example &amp;ldquo;Com M Itter&amp;rdquo;) and &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; is the person&amp;rsquo;s email address (&amp;ldquo;cm@example.com&amp;rdquo;). &lt;code&gt;LT&lt;/code&gt; and &lt;code&gt;GT&lt;/code&gt; are the literal less-than (\x3c) and greater-than (\x3e) symbols. These are required to delimit the email address from the other fields in the line. Note that &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; are free-form and may contain any sequence of bytes, except &lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;GT&lt;/code&gt; and &lt;code&gt;LF&lt;/code&gt;. &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is typically UTF-8 encoded.</source>
          <target state="translated">这里的 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 是该人的显示名称（例如&amp;ldquo; Com M Itter&amp;rdquo;），而 &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; 是该人的电子邮件地址（&amp;ldquo; cm@example.com&amp;rdquo;）。 &lt;code&gt;LT&lt;/code&gt; 和 &lt;code&gt;GT&lt;/code&gt; 是文字小于（\ x3c）和大于（\ x3e）符号。这些是从行中其他字段分隔电子邮件地址所必需的。请注意， &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; 是自由格式的，并且可以包含任何字节序列，但 &lt;code&gt;LT&lt;/code&gt; ， &lt;code&gt;GT&lt;/code&gt; 和 &lt;code&gt;LF&lt;/code&gt; 除外。 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 通常是UTF-8编码的。</target>
        </trans-unit>
        <trans-unit id="88e3e34bac3d333854c449d8638faee3f973bc68" translate="yes" xml:space="preserve">
          <source>Here actual project root is passed to gitweb via &lt;code&gt;GITWEB_PROJECT_ROOT&lt;/code&gt; environment variable from a web server, so you need to put the following line in gitweb configuration file (&lt;code&gt;/etc/gitweb.conf&lt;/code&gt; in above example):</source>
          <target state="translated">这里实际的项目根目录是通过Web服务器上的 &lt;code&gt;GITWEB_PROJECT_ROOT&lt;/code&gt; 环境变量传递到gitweb的，因此您需要将以下行放入gitweb配置文件（上例中为 &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="87d852c017173b91ce004ba4ee55c454ec44074f" translate="yes" xml:space="preserve">
          <source>Here again it is a good point to take a pause.</source>
          <target state="translated">这里又是一个很好的点,要暂停一下。</target>
        </trans-unit>
        <trans-unit id="9d560d4da9e941f0111865584d812ed4b996ba31" translate="yes" xml:space="preserve">
          <source>Here are a handful of examples using the Loeliger illustration above, with each step in the notation&amp;rsquo;s expansion and selection carefully spelt out:</source>
          <target state="translated">以下是使用上述Loeliger插图的一些示例，并仔细说明了符号扩展和选择的每个步骤：</target>
        </trans-unit>
        <trans-unit id="917cc5ec6b02db542b24a5b6455b2e756b18d73b" translate="yes" xml:space="preserve">
          <source>Here are some example specifications:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6c1665b5306569c28a748694fd4e1b1e7a55db" translate="yes" xml:space="preserve">
          <source>Here are some hints on how to successfully submit patches inline using various mailers.</source>
          <target state="translated">下面是一些关于如何使用各种邮箱成功在线提交补丁的提示。</target>
        </trans-unit>
        <trans-unit id="1510576755c083f75778b41e3e15db4ef8738ed9" translate="yes" xml:space="preserve">
          <source>Here are some of the scripts that simplify all this even further.</source>
          <target state="translated">这里有一些脚本,可以进一步简化这一切。</target>
        </trans-unit>
        <trans-unit id="e7b17934614eee2f77ca3149426accc7b6e72d44" translate="yes" xml:space="preserve">
          <source>Here are the rules regarding the &quot;flags&quot; that you should follow when you are scripting Git:</source>
          <target state="translated">以下是关于 &quot;标志 &quot;的规则,你在编写Git脚本时应该遵守。</target>
        </trans-unit>
        <trans-unit id="04cdec1fa8a31abdd551dc359504457bc39d207b" translate="yes" xml:space="preserve">
          <source>Here is a hypothetical usage of the Trace2 API showing the intended usage (without worrying about the actual Git details).</source>
          <target state="translated">这里是Trace2 API的一个假设用法,显示了预期的用法(不用担心实际的Git细节)。</target>
        </trans-unit>
        <trans-unit id="ffd38e59dd005a380c8a8570731f44b027a45fba" translate="yes" xml:space="preserve">
          <source>Here is a list of the facilities provided by this option parser.</source>
          <target state="translated">下面是这个选项解析器提供的设施列表。</target>
        </trans-unit>
        <trans-unit id="e4035106d997a5f9ffd025f7ed0bd5862edf3733" translate="yes" xml:space="preserve">
          <source>Here is a picture that illustrates how various pieces fit together:</source>
          <target state="translated">下面是一张图片,说明各种部件是如何组合在一起的。</target>
        </trans-unit>
        <trans-unit id="303a3029ebdf1756e031ccbacc8dc586c90ed37d" translate="yes" xml:space="preserve">
          <source>Here is an ASCII art by Jon Loeliger that illustrates how various &lt;code&gt;diff-*&lt;/code&gt; commands compare things.</source>
          <target state="translated">这是Jon Loeliger的ASCII艺术，它说明了各种 &lt;code&gt;diff-*&lt;/code&gt; 命令如何进行比较。</target>
        </trans-unit>
        <trans-unit id="a1af358ae94ab7cd9ed6d1b4e51b99fcacedf212" translate="yes" xml:space="preserve">
          <source>Here is an example of a work-flow used by Andreas Ericsson:</source>
          <target state="translated">下面是Andreas Ericsson使用的一个工作流程的例子。</target>
        </trans-unit>
        <trans-unit id="186fb29b724fc88890a2b738e2f88d967cca2e57" translate="yes" xml:space="preserve">
          <source>Here is an example script that comes slightly modified from a real world script used by Junio Hamano &lt;a href=&quot;#4&quot;&gt;[4]&lt;/a&gt;.</source>
          <target state="translated">这是一个示例脚本，它是由Junio Hamano &lt;a href=&quot;#4&quot;&gt;[4]&lt;/a&gt;使用的真实脚本稍微修改的。</target>
        </trans-unit>
        <trans-unit id="ea2d28e72cba49a8087ea617856210e85cc4631a" translate="yes" xml:space="preserve">
          <source>Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right.</source>
          <target state="translated">下面是一个例子,作者是Jon Loeliger。提交节点B和C都是提交节点A的父节点。父提交节点从左到右排序。</target>
        </trans-unit>
        <trans-unit id="01a0e7181fc0932a87393a13bfb324333ce2de29" translate="yes" xml:space="preserve">
          <source>Here is how you would transplant a topic branch based on one branch to another, to pretend that you forked the topic branch from the latter branch, using &lt;code&gt;rebase --onto&lt;/code&gt;.</source>
          <target state="translated">这是您将基于一个分支的主题分支移植到另一个分支的方法，以使用 &lt;code&gt;rebase --onto&lt;/code&gt; 假装您从另一个分支派生了该主题分支。</target>
        </trans-unit>
        <trans-unit id="213d54b0bbf3a7f7afa040a26967e9f565627a3c" translate="yes" xml:space="preserve">
          <source>Here is what Ingo Molnar says about that &lt;a href=&quot;#7&quot;&gt;[7]&lt;/a&gt;:</source>
          <target state="translated">这是Ingo Molnar所说的&lt;a href=&quot;#7&quot;&gt;[7]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="0ace4715fac22315364196a248067a261a46ae73" translate="yes" xml:space="preserve">
          <source>Here usually &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; must be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set by a prior &lt;code&gt;blob&lt;/code&gt; command, or a full 40-byte SHA-1 of an existing Git blob object. If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;040000`&lt;/code&gt; then &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; must be the full 40-byte SHA-1 of an existing Git tree object or a mark reference set with &lt;code&gt;--import-marks&lt;/code&gt;.</source>
          <target state="translated">通常， &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 必须是由先前的 &lt;code&gt;blob&lt;/code&gt; 命令设置的标记引用（ &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ），或者是现有Git blob对象的完整40字节SHA-1。如果 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 是 &lt;code&gt;040000`&lt;/code&gt; ,则 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 必须是现有Git树对象的完整40字节SHA-1或使用 &lt;code&gt;--import-marks&lt;/code&gt; 设置的标记引用。</target>
        </trans-unit>
        <trans-unit id="2beb401ec57f79ec07666eedc396bc9251ab532b" translate="yes" xml:space="preserve">
          <source>Here we use a &lt;code&gt;test.sh&lt;/code&gt; custom script. In this script, if &lt;code&gt;make&lt;/code&gt; fails, we skip the current commit. &lt;code&gt;check_test_case.sh&lt;/code&gt; should &lt;code&gt;exit 0&lt;/code&gt; if the test case passes, and &lt;code&gt;exit 1&lt;/code&gt; otherwise.</source>
          <target state="translated">在这里，我们使用一个 &lt;code&gt;test.sh&lt;/code&gt; 自定义脚本。在此脚本中，如果 &lt;code&gt;make&lt;/code&gt; 失败，我们将跳过当前提交。如果测试用例通过，则 &lt;code&gt;check_test_case.sh&lt;/code&gt; 应该 &lt;code&gt;exit 0&lt;/code&gt; ，否则 &lt;code&gt;exit 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c65aa59e4c90d1dad65ae558dc71a05ca72658c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example to make it more clear:</source>
          <target state="translated">这是一个使它更加清楚的示例：</target>
        </trans-unit>
        <trans-unit id="f876057ef41997694291fae2bce19c94e2c8be27" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s where things get tricky and more specific. The pruning feature doesn&amp;rsquo;t actually care about branches, instead it&amp;rsquo;ll prune local &amp;lt;&amp;rarr; remote-references as a function of the refspec of the remote (see &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; and &lt;a href=&quot;#CRTB&quot;&gt;CONFIGURED REMOTE-TRACKING BRANCHES&lt;/a&gt; above).</source>
          <target state="translated">这是棘手且更具体的地方。修剪功能实际上并不关心分支，而是根据远程引用的规格修剪本地&amp;lt;&amp;rarr;远程引用（请参见上面的 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 和&lt;a href=&quot;#CRTB&quot;&gt;CONFIGURED REMOTE-TRACKING BRANCHES&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6e909debf7e14a75a50a127741701f06b0380ed1" translate="yes" xml:space="preserve">
          <source>Here, order matters, so the negative patterns are overridden by the positive patterns that appear lower in the file.</source>
          <target state="translated">在这里,顺序很重要,所以消极的模式会被文件中出现较低的积极模式所覆盖。</target>
        </trans-unit>
        <trans-unit id="e1c70b8a098f60c6e63dbb08701031f93ea135ff" translate="yes" xml:space="preserve">
          <source>Here, take a moment to look at the contents of &lt;code&gt;hello&lt;/code&gt;, and notice how they don&amp;rsquo;t contain the work we just did in &lt;code&gt;mybranch&lt;/code&gt; &amp;mdash; because that work hasn&amp;rsquo;t happened in the &lt;code&gt;master&lt;/code&gt; branch at all. Then do</source>
          <target state="translated">在这里，花点时间看一下 &lt;code&gt;hello&lt;/code&gt; 的内容，并注意它们如何不包含我们刚刚在 &lt;code&gt;mybranch&lt;/code&gt; 中所做的工作-因为该工作根本没有在 &lt;code&gt;master&lt;/code&gt; 分支中发生。然后做</target>
        </trans-unit>
        <trans-unit id="04fe7010553ef714229d324da3944b7bef8ef4bf" translate="yes" xml:space="preserve">
          <source>Here, the merge commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; contribute extra noise, as they did not actually contribute a change to &lt;code&gt;file.txt&lt;/code&gt;. They only merged a topic that was based on an older version of &lt;code&gt;file.txt&lt;/code&gt;. This is a common issue in repositories using a workflow where many contributors work in parallel and merge their topic branches along a single trunk: manu unrelated merges appear in the &lt;code&gt;--full-history&lt;/code&gt; results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3155f9e3fff9d9745dcec6fcafe4ea22b8525d" translate="yes" xml:space="preserve">
          <source>Here, the merge commits &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are included because they pulled the commits &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; into the base branch, respectively. These merges are the reason the commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; do not appear in the default history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77fbd432531fa44ab380c6d115f43ea2fbe9fc8" translate="yes" xml:space="preserve">
          <source>Here, we just added another line to &lt;code&gt;hello&lt;/code&gt;, and we used a shorthand for doing both &lt;code&gt;git update-index hello&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; by just giving the filename directly to &lt;code&gt;git commit&lt;/code&gt;, with an &lt;code&gt;-i&lt;/code&gt; flag (it tells Git to &lt;code&gt;include&lt;/code&gt; that file in addition to what you have done to the index file so far when making the commit). The &lt;code&gt;-m&lt;/code&gt; flag is to give the commit log message from the command line.</source>
          <target state="translated">在这里，我们只是向 &lt;code&gt;hello&lt;/code&gt; 添加了另一行，并且使用了简写方式来进行 &lt;code&gt;git update-index hello&lt;/code&gt; 和 &lt;code&gt;git commit&lt;/code&gt; ，方法是将文件名直接提供给 &lt;code&gt;git commit&lt;/code&gt; ，并带有 &lt;code&gt;-i&lt;/code&gt; 标志（它告诉Git 将该文件 &lt;code&gt;include&lt;/code&gt; 在到目前为止，除了对索引文件所做的一切之外）。该 &lt;code&gt;-m&lt;/code&gt; 标志是给从命令行提交日志信息。</target>
        </trans-unit>
        <trans-unit id="c1304382231014b423d405b863d67d13d9195107" translate="yes" xml:space="preserve">
          <source>Here, we see that the commits A and C (marked with &lt;code&gt;-&lt;/code&gt;) can be dropped from your &lt;code&gt;topic&lt;/code&gt; branch when you rebase it on top of &lt;code&gt;origin/master&lt;/code&gt;, while the commit B (marked with &lt;code&gt;+&lt;/code&gt;) still needs to be kept so that it will be sent to be applied to &lt;code&gt;origin/master&lt;/code&gt;.</source>
          <target state="translated">在这里，我们看到，当您将提交A和C（标记为 &lt;code&gt;-&lt;/code&gt; ）重新建立在 &lt;code&gt;origin/master&lt;/code&gt; 之上时，可以将其从 &lt;code&gt;topic&lt;/code&gt; 分支中删除，而仍然需要保留提交B（标记为 &lt;code&gt;+&lt;/code&gt; ），以便它将被发送到 &lt;code&gt;origin/master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cd618d5ab553d5bba621718fb5b54666be9377a" translate="yes" xml:space="preserve">
          <source>High-level commands (porcelain)</source>
          <target state="translated">高级命令(瓷器)</target>
        </trans-unit>
        <trans-unit id="1ac4e7d9472a79a55ebc3b6988fb3cc4f954a3f4" translate="yes" xml:space="preserve">
          <source>High-level operations such as &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt; work by moving data between the working tree, the index, and the object database. Git provides low-level operations which perform each of these steps individually.</source>
          <target state="translated">诸如&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;和&lt;a href=&quot;git-restore&quot;&gt;git-restore [1]之&lt;/a&gt;类的高级操作通过在工作树，索引和对象数据库之间移动数据来工作。Git提供了低级操作，这些操作分别执行每个步骤。</target>
        </trans-unit>
        <trans-unit id="c1ce0c926615015cc35af4d00f9f659a79fd9f67" translate="yes" xml:space="preserve">
          <source>Higher level SCMs may provide and manage additional information in the &lt;code&gt;$GIT_DIR&lt;/code&gt;.</source>
          <target state="translated">更高级别的SCM可以在 &lt;code&gt;$GIT_DIR&lt;/code&gt; 提供和管理其他信息。</target>
        </trans-unit>
        <trans-unit id="dd055ea7ea783c3a5765e06b74c033615ebf91a1" translate="yes" xml:space="preserve">
          <source>Highest and slowest compression level. You can specify any number from 1 to 9 to adjust compression speed and ratio.</source>
          <target state="translated">最高和最慢的压缩水平。您可以指定从1到9的任何数字来调整压缩速度和比率。</target>
        </trans-unit>
        <trans-unit id="dca5de829f06af308665d596314f33baa6a08d8b" translate="yes" xml:space="preserve">
          <source>Highlight changed words using only colors. Implies &lt;code&gt;--color&lt;/code&gt;.</source>
          <target state="translated">仅使用颜色突出显示更改的单词。表示 &lt;code&gt;--color&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d265b329d8480dd12ed84fd1552194f9ed45b640" translate="yes" xml:space="preserve">
          <source>Highlight whitespace errors in the &lt;code&gt;context&lt;/code&gt;, &lt;code&gt;old&lt;/code&gt; or &lt;code&gt;new&lt;/code&gt; lines of the diff. Multiple values are separated by comma, &lt;code&gt;none&lt;/code&gt; resets previous values, &lt;code&gt;default&lt;/code&gt; reset the list to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; is a shorthand for &lt;code&gt;old,new,context&lt;/code&gt;. The whitespace errors are colored with &lt;code&gt;color.diff.whitespace&lt;/code&gt;. The command line option &lt;code&gt;--ws-error-highlight=&amp;lt;kind&amp;gt;&lt;/code&gt; overrides this setting.</source>
          <target state="translated">在diff 的 &lt;code&gt;context&lt;/code&gt; ， &lt;code&gt;old&lt;/code&gt; 行或 &lt;code&gt;new&lt;/code&gt; 行中突出显示空白错误。多个值之间以逗号分隔， &lt;code&gt;none&lt;/code&gt; 一个值会重置先前的值， &lt;code&gt;default&lt;/code&gt; 会将列表重置为 &lt;code&gt;new&lt;/code&gt; ,而 &lt;code&gt;all&lt;/code&gt; 都是 &lt;code&gt;old,new,context&lt;/code&gt; 的简写。空格错误用 &lt;code&gt;color.diff.whitespace&lt;/code&gt; 上色。命令行选项 &lt;code&gt;--ws-error-highlight=&amp;lt;kind&amp;gt;&lt;/code&gt; 会覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="ad64982f5f47504010208292cc60b059ddb2341b" translate="yes" xml:space="preserve">
          <source>Highlight whitespace errors in the &lt;code&gt;context&lt;/code&gt;, &lt;code&gt;old&lt;/code&gt; or &lt;code&gt;new&lt;/code&gt; lines of the diff. Multiple values are separated by comma, &lt;code&gt;none&lt;/code&gt; resets previous values, &lt;code&gt;default&lt;/code&gt; reset the list to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; is a shorthand for &lt;code&gt;old,new,context&lt;/code&gt;. When this option is not given, and the configuration variable &lt;code&gt;diff.wsErrorHighlight&lt;/code&gt; is not set, only whitespace errors in &lt;code&gt;new&lt;/code&gt; lines are highlighted. The whitespace errors are colored with &lt;code&gt;color.diff.whitespace&lt;/code&gt;.</source>
          <target state="translated">在diff 的 &lt;code&gt;context&lt;/code&gt; ， &lt;code&gt;old&lt;/code&gt; 行或 &lt;code&gt;new&lt;/code&gt; 行中突出显示空白错误。多个值之间以逗号分隔， &lt;code&gt;none&lt;/code&gt; 一个值会重置先前的值， &lt;code&gt;default&lt;/code&gt; 会将列表重置为 &lt;code&gt;new&lt;/code&gt; ,而 &lt;code&gt;all&lt;/code&gt; 都是 &lt;code&gt;old,new,context&lt;/code&gt; 的简写。如果未指定此选项，并且未设置配置变量 &lt;code&gt;diff.wsErrorHighlight&lt;/code&gt; ，则仅高亮显示 &lt;code&gt;new&lt;/code&gt; 行中的空白错误。空格错误用 &lt;code&gt;color.diff.whitespace&lt;/code&gt; 上色。</target>
        </trans-unit>
        <trans-unit id="dd523af5eca7a4658a007786700bef0bcb653aea" translate="yes" xml:space="preserve">
          <source>Historical options for selecting a type specifier. Prefer instead &lt;code&gt;--type&lt;/code&gt; (see above).</source>
          <target state="translated">选择类型说明符的历史选项。请改用 &lt;code&gt;--type&lt;/code&gt; （请参见上文）。</target>
        </trans-unit>
        <trans-unit id="d2946930a6bea40f3723a867347d5f13a7e8b511" translate="yes" xml:space="preserve">
          <source>Historically we did not allow binary patch applied without an explicit permission from the user, and this flag was the way to do so. Currently we always allow binary patch application, so this is a no-op.</source>
          <target state="translated">历史上我们不允许在没有用户明确许可的情况下应用二进制补丁,这个标志就是这样做的。目前我们一直允许应用二进制补丁,所以这是不允许的。</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="7f2999a0b05d570915b660b4e452265d6ec70628" translate="yes" xml:space="preserve">
          <source>History Simplification</source>
          <target state="translated">历史简化</target>
        </trans-unit>
        <trans-unit id="bcdd29839bed9103f5dae5291b4dd975d75a9cc7" translate="yes" xml:space="preserve">
          <source>History traversing commands such as &lt;code&gt;git log&lt;/code&gt; operate on a set of commits, not just a single commit.</source>
          <target state="translated">诸如 &lt;code&gt;git log&lt;/code&gt; 之类的历史记录遍历命令对一组提交操作，而不仅仅是单个提交。</target>
        </trans-unit>
        <trans-unit id="173bd843bbaf623a85e5a648a6a9c500533027fc" translate="yes" xml:space="preserve">
          <source>Honor textconv filter settings.</source>
          <target state="translated">尊敬的textconv过滤器设置。</target>
        </trans-unit>
        <trans-unit id="be308a87ab32a83ddd6a199c65b0dc7cb4884727" translate="yes" xml:space="preserve">
          <source>Hook for submit</source>
          <target state="translated">用于提交的钩子</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="99dc1a330d0acc7fd52ca441a6ce9f9284dba47c" translate="yes" xml:space="preserve">
          <source>Hooks are customization scripts used by various Git commands. A handful of sample hooks are installed when &lt;code&gt;git init&lt;/code&gt; is run, but all of them are disabled by default. To enable, the &lt;code&gt;.sample&lt;/code&gt; suffix has to be removed from the filename by renaming. Read &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more details about each hook. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/hooks&quot; will be used instead.</source>
          <target state="translated">挂钩是各种Git命令使用的自定义脚本。运行 &lt;code&gt;git init&lt;/code&gt; 时会安装一些示例挂钩，但是默认情况下所有挂钩都处于禁用状态。要启用该 &lt;code&gt;.sample&lt;/code&gt; ，必须通过重命名从文件名中删除.sample后缀。阅读&lt;a href=&quot;githooks&quot;&gt;githooks [5]，&lt;/a&gt;以获得有关每个钩子的更多详细信息。如果设置了$ GIT_COMMON_DIR，将忽略该目录，而将使用&amp;ldquo; $ GIT_COMMON_DIR / hooks&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="06a3036cbe5b8e0ded4c91cf35d4acf2e8ad8f53" translate="yes" xml:space="preserve">
          <source>Hooks are programs you can place in a hooks directory to trigger actions at certain points in git&amp;rsquo;s execution. Hooks that don&amp;rsquo;t have the executable bit set are ignored.</source>
          <target state="translated">挂钩是可以放置在挂钩目录中的程序，可以在git执行的某些点触发动作。没有设置可执行位的钩子将被忽略。</target>
        </trans-unit>
        <trans-unit id="bf9a913e0a40d8bcbb788ae480caabb75549e706" translate="yes" xml:space="preserve">
          <source>Hooks can get their arguments via the environment, command-line arguments, and stdin. See the documentation for each hook below for details.</source>
          <target state="translated">钩子可以通过环境、命令行参数和stdin获得它们的参数。详情请看下面每个钩子的文档。</target>
        </trans-unit>
        <trans-unit id="ada52d2258e33812dc48261a96d9e1bee90a02e9" translate="yes" xml:space="preserve">
          <source>Hooks for submit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b25ef249acb89a2076c9e4eabf85c1464e0ce20" translate="yes" xml:space="preserve">
          <source>Hooks used by Git</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c7452920ac3fe30578ebea0bb92b7bf8bbfaa1" translate="yes" xml:space="preserve">
          <source>Host specified as an option to all p4 commands, with &lt;code&gt;-h &amp;lt;host&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4HOST&lt;/code&gt; can be used instead.</source>
          <target state="translated">使用 &lt;code&gt;-h &amp;lt;host&amp;gt;&lt;/code&gt; 将主机指定为所有p4命令的选项。可以代替使用环境变量 &lt;code&gt;P4HOST&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3a4f74d3860a1e7164c5016083b909a49e9f48e" translate="yes" xml:space="preserve">
          <source>Host/domain name (e.g., &lt;code&gt;example.com&lt;/code&gt; in &lt;code&gt;https://example.com/&lt;/code&gt;). This field must match between the config key and the URL. It is possible to specify a &lt;code&gt;*&lt;/code&gt; as part of the host name to match all subdomains at this level. &lt;code&gt;https://*.example.com/&lt;/code&gt; for example would match &lt;code&gt;https://foo.example.com/&lt;/code&gt;, but not &lt;code&gt;https://foo.bar.example.com/&lt;/code&gt;.</source>
          <target state="translated">主机/域名（例如， &lt;code&gt;example.com&lt;/code&gt; 在 &lt;code&gt;https://example.com/&lt;/code&gt; ）。此字段必须在配置密钥和URL之间匹配。可以在主机名中指定 &lt;code&gt;*&lt;/code&gt; 作为主机名的一部分，以匹配该级别的所有子域。例如， &lt;code&gt;https://*.example.com/&lt;/code&gt; 会匹配 &lt;code&gt;https://foo.example.com/&lt;/code&gt; ，但不会匹配 &lt;code&gt;https://foo.bar.example.com/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62bb4be23aa04882a53a58830164455da0d43aac" translate="yes" xml:space="preserve">
          <source>How Git stores objects efficiently: pack files</source>
          <target state="translated">Git如何高效存储对象:打包文件</target>
        </trans-unit>
        <trans-unit id="fc3082d534384228eeed70dd2356631d4f563e7e" translate="yes" xml:space="preserve">
          <source>How conflicts are presented</source>
          <target state="translated">如何呈现冲突</target>
        </trans-unit>
        <trans-unit id="5244849e32f335a105adeaedb7d0622dd5a4979d" translate="yes" xml:space="preserve">
          <source>How do I change the password or token I&amp;rsquo;ve saved in my credential manager?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ccb6c4c256587db55f527de1ac8216cdb87dd1a" translate="yes" xml:space="preserve">
          <source>How do I configure a different editor?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f36d36a2324ff8b7855eecf530bc9a1c32ff537f" translate="yes" xml:space="preserve">
          <source>How do I ignore changes to a tracked file?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45616205fd46cf85262b1b285b082de451adc398" translate="yes" xml:space="preserve">
          <source>How do I know if I want to do a fetch or a pull?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05c497e12027e0c373f593c1377168543f797ee" translate="yes" xml:space="preserve">
          <source>How do I read a password or token from an environment variable?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c891c94c10c831bda4b63b5799e39a9834d7dcc" translate="yes" xml:space="preserve">
          <source>How do I specify my credentials when pushing over HTTP?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5dca41244a6332e02250d3a1fc3bc07b57afe01" translate="yes" xml:space="preserve">
          <source>How do I use hooks to prevent users from making certain changes?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c343d29a2a8aba685ccf285d18515975b3161ef3" translate="yes" xml:space="preserve">
          <source>How do I use multiple accounts with the same hosting provider using HTTP?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17b6f490f5957bf480ef823ec20fdfb4358ca910" translate="yes" xml:space="preserve">
          <source>How do I use multiple accounts with the same hosting provider using SSH?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="632a7344e68629673f46b61122a8d717f4af38d1" translate="yes" xml:space="preserve">
          <source>How does the merge work?</source>
          <target state="translated">如何进行合并?</target>
        </trans-unit>
        <trans-unit id="ee0a93def9e459d81d86f0f444af48fed200edd7" translate="yes" xml:space="preserve">
          <source>How many HTTP requests to launch in parallel. Can be overridden by the &lt;code&gt;GIT_HTTP_MAX_REQUESTS&lt;/code&gt; environment variable. Default is 5.</source>
          <target state="translated">并行启动多少个HTTP请求。可以被 &lt;code&gt;GIT_HTTP_MAX_REQUESTS&lt;/code&gt; 环境变量覆盖。默认值为5。</target>
        </trans-unit>
        <trans-unit id="88ba6c6b51f5b68d7988ac607f3c426807b883bb" translate="yes" xml:space="preserve">
          <source>How to best handle custom GIT_TRACE_&amp;lt;key&amp;gt; messages?</source>
          <target state="translated">如何最好地处理自定义GIT_TRACE_ &amp;lt;key&amp;gt;消息？</target>
        </trans-unit>
        <trans-unit id="e6e1af910bb5a856e3b4ead0799265f2a1064f75" translate="yes" xml:space="preserve">
          <source>How to check out a different version of a project</source>
          <target state="translated">如何查看项目的不同版本?</target>
        </trans-unit>
        <trans-unit id="d2b9978a0ab6bcc1a292a13931b1286539811f55" translate="yes" xml:space="preserve">
          <source>How to get a Git repository</source>
          <target state="translated">如何获得Git仓库</target>
        </trans-unit>
        <trans-unit id="d7d2ba06f3721900039efaca56489e6a84b511d3" translate="yes" xml:space="preserve">
          <source>How to get a Git repository with minimal history</source>
          <target state="translated">如何让Git仓库的历史记录最小化?</target>
        </trans-unit>
        <trans-unit id="d757cda7bc3ea5053c7cf45f6afca8dbb51305c3" translate="yes" xml:space="preserve">
          <source>How to handle commits that are not empty to start and are not clean cherry-picks of any upstream commit, but which become empty after rebasing (because they contain a subset of already upstream changes). With drop (the default), commits that become empty are dropped. With keep, such commits are kept. With ask (implied by --interactive), the rebase will halt when an empty commit is applied allowing you to choose whether to drop it, edit files more, or just commit the empty changes. Other options, like --exec, will use the default of drop unless -i/--interactive is explicitly specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a7eba29926bb4a386242f44bbf4f12c6f691a0c" translate="yes" xml:space="preserve">
          <source>How to make a commit</source>
          <target state="translated">如何作出承诺</target>
        </trans-unit>
        <trans-unit id="a8f8fd0d0e36d30f7fbe331a10b1e8f318a5f903" translate="yes" xml:space="preserve">
          <source>How to merge</source>
          <target state="translated">如何合并</target>
        </trans-unit>
        <trans-unit id="813e8d48c24190b471043b3ab0d44e357c5f2791" translate="yes" xml:space="preserve">
          <source>How to resolve conflicts</source>
          <target state="translated">如何解决冲突</target>
        </trans-unit>
        <trans-unit id="93e750cda509aa41796eb9d7a6cb3afbf2365356" translate="yes" xml:space="preserve">
          <source>How to use bisect to find a regression</source>
          <target state="translated">如何使用二乘法寻找回归的方法?</target>
        </trans-unit>
        <trans-unit id="c54b4ab81b97a7d870be1fb485f52b39766adb14" translate="yes" xml:space="preserve">
          <source>However &amp;mdash; it&amp;rsquo;s such a common thing to &lt;code&gt;fetch&lt;/code&gt; and then immediately &lt;code&gt;merge&lt;/code&gt;, that it&amp;rsquo;s called &lt;code&gt;git pull&lt;/code&gt;, and you can simply do</source>
          <target state="translated">但是， &lt;code&gt;fetch&lt;/code&gt; 并立即 &lt;code&gt;merge&lt;/code&gt; 是很常见的事情，称为 &lt;code&gt;git pull&lt;/code&gt; ，您可以简单地执行</target>
        </trans-unit>
        <trans-unit id="d70de578cd37f18e0cd1ccdb7488c789f08117d4" translate="yes" xml:space="preserve">
          <source>However &amp;mdash; normally you&amp;rsquo;d never use &lt;code&gt;git write-tree&lt;/code&gt; on its own, because normally you always commit a tree into a commit object using the &lt;code&gt;git commit-tree&lt;/code&gt; command. In fact, it&amp;rsquo;s easier to not actually use &lt;code&gt;git write-tree&lt;/code&gt; on its own at all, but to just pass its result in as an argument to &lt;code&gt;git commit-tree&lt;/code&gt;.</source>
          <target state="translated">但是-通常您永远不会 &lt;code&gt;git write-tree&lt;/code&gt; 使用git write-tree，因为通常您总是使用 &lt;code&gt;git commit-tree&lt;/code&gt; 命令将树提交到提交对象中。实际上，完全不使用 &lt;code&gt;git write-tree&lt;/code&gt; 更容易，而是仅将其结果作为 &lt;code&gt;git commit-tree&lt;/code&gt; 的参数传递。</target>
        </trans-unit>
        <trans-unit id="b251a49d303741aee81dcafea3be641705e5d2d3" translate="yes" xml:space="preserve">
          <source>However repacking the repository is necessary to improve data locality and access performance. It can also take hours on extremely large projects (especially if -f and a large --window parameter is used). Since repacking is safe to run alongside readers and writers, run the repack in the background and let it finish when it finishes. There is no reason to wait to explore your new Git project!</source>
          <target state="translated">然而,为了提高数据的位置性和访问性能,重新打包存储库是必要的。在极其庞大的项目中,它也会花费数小时的时间(尤其是在使用-f和一个大的-窗口参数时)。由于重新打包是安全的,可以和读写器一起运行,所以在后台运行重新打包,完成后让它完成。没有理由等待探索你的新Git项目!</target>
        </trans-unit>
        <trans-unit id="4b948e81d3b66aa74b95ff1de52609dbf8f7d04b" translate="yes" xml:space="preserve">
          <source>However, Git does &lt;strong&gt;not&lt;/strong&gt; (and it should not) change tags behind users back. So if somebody already got the old tag, doing a &lt;code&gt;git pull&lt;/code&gt; on your tree shouldn&amp;rsquo;t just make them overwrite the old one.</source>
          <target state="translated">但是，Git不会（&lt;strong&gt;也不&lt;/strong&gt;应该）将用户背后的标签改回来。因此，如果有人已经获得了旧标签，那么对您的树执行 &lt;code&gt;git pull&lt;/code&gt; 不仅应该使他们覆盖旧标签。</target>
        </trans-unit>
        <trans-unit id="774132ee5dd559ea340879a21fd99f6ff4549c5d" translate="yes" xml:space="preserve">
          <source>However, an understanding of these low-level tools can be helpful if you want to understand Git&amp;rsquo;s internals.</source>
          <target state="translated">但是，如果您想了解Git的内部原理，那么对这些低级工具的了解可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="866f600e87142f901a49d55ea62ea322295c395d" translate="yes" xml:space="preserve">
          <source>However, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file you get a N+1 line from-file/to-file header, where N is the number of parents in the merge commit</source>
          <target state="translated">但是,如果提供了--combined-all-paths选项,你会得到一个N+1行的from-file/to-file文件头,其中N是合并提交中的父文件数量。</target>
        </trans-unit>
        <trans-unit id="24c47b91e42f0b5da2ef1b1de98db109a45643ab" translate="yes" xml:space="preserve">
          <source>However, if the current branch is an ancestor of the other&amp;mdash;​so every commit present in the current branch is already contained in the other branch&amp;mdash;​then Git just performs a &quot;fast-forward&quot;; the head of the current branch is moved forward to point at the head of the merged-in branch, without any new commits being created.</source>
          <target state="translated">但是，如果当前分支是另一个分支的祖先-因此当前分支中存在的每个提交都已经包含在另一个分支中-那么Git只会执行一个``快进''; 当前分支的头将向前移动以指向合并分支的头，而不会创建任何新的提交。</target>
        </trans-unit>
        <trans-unit id="38320aec0b4074b6ba1fc6f9446c9d65a3296509" translate="yes" xml:space="preserve">
          <source>However, if the file is absent from the tree of some commit, a simple &lt;code&gt;rm filename&lt;/code&gt; will fail for that tree and commit. Thus you may instead want to use &lt;code&gt;rm -f filename&lt;/code&gt; as the script.</source>
          <target state="translated">但是，如果某个提交树中没有该文件，则该树和提交的简单 &lt;code&gt;rm filename&lt;/code&gt; 名将失败。因此，您可能想使用 &lt;code&gt;rm -f filename&lt;/code&gt; 作为脚本。</target>
        </trans-unit>
        <trans-unit id="083d51e29026b4e1a08bfd658353fe31999e3907" translate="yes" xml:space="preserve">
          <source>However, if you decide to jump to a new version, or check out somebody else&amp;rsquo;s version, or just restore a previous tree, you&amp;rsquo;d populate your index file with read-tree, and then you need to check out the result with</source>
          <target state="translated">但是，如果您决定跳至新版本，或检出其他人的版本，或仅恢复先前的树，则将读取树填充到索引文件中，然后需要使用以下命令检出结果</target>
        </trans-unit>
        <trans-unit id="d73cbcd65f07eabb528955f0d408caeaef9ec132" translate="yes" xml:space="preserve">
          <source>However, if you have local changes in the working tree that would be overwritten by this merge, &lt;code&gt;git read-tree&lt;/code&gt; will refuse to run to prevent your changes from being lost.</source>
          <target state="translated">但是，如果您在工作树中有本地更改将被此合并覆盖，则 &lt;code&gt;git read-tree&lt;/code&gt; 将拒绝运行以防止您的更改丢失。</target>
        </trans-unit>
        <trans-unit id="0f801baa64ce652ffc6d36336f6a234c862e64a0" translate="yes" xml:space="preserve">
          <source>However, if you prefer to keep the history in mywork a simple series of commits without any merges, you may instead choose to use &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;:</source>
          <target state="translated">但是，如果您希望将历史记录保留在mywork中一系列简单的提交而没有任何合并，则可以选择使用&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="6a9f204773ec4f6bc12691a9ec080236d437d186" translate="yes" xml:space="preserve">
          <source>However, if you really only want to replace the line for the default proxy, i.e. the one without a &quot;for &amp;hellip;​&quot; postfix, do something like this:</source>
          <target state="translated">但是，如果您真的只想替换默认代理的行，即没有&amp;ldquo; for ...&amp;rdquo;后缀的行，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="fe54b4a5cce25da95a527e803024815678af4c5c" translate="yes" xml:space="preserve">
          <source>However, if you skip a commit adjacent to the one you are looking for, Git will be unable to tell exactly which of those commits was the first bad one.</source>
          <target state="translated">但是,如果跳过你正在寻找的相邻提交,Git 将无法准确判断出哪个提交是第一个坏的提交。</target>
        </trans-unit>
        <trans-unit id="e9adef201cc69834664c04ac9c044e6acc3b8daa" translate="yes" xml:space="preserve">
          <source>However, it is not necessary to create branches in p4 to be able to use them like branches. Because it is difficult to infer branch relationships automatically, a Git configuration setting &lt;code&gt;git-p4.branchList&lt;/code&gt; can be used to explicitly identify branch relationships. It is a list of &quot;source:destination&quot; pairs, like a simple p4 branch specification, where the &quot;source&quot; and &quot;destination&quot; are the path elements in the p4 repository. The example above relied on the presence of the p4 branch. Without p4 branches, the same result will occur with:</source>
          <target state="translated">但是，不必在p4中创建分支即可像分支一样使用它们。因为很难自动推断分支关系， &lt;code&gt;git-p4.branchList&lt;/code&gt; 可以使用Git配置设置git-p4.branchList来明确标识分支关系。它是&amp;ldquo; source：destination&amp;rdquo;对的列表，就像简单的p4分支规范一样，其中&amp;ldquo; source&amp;rdquo;和&amp;ldquo; destination&amp;rdquo;是p4存储库中的路径元素。上面的示例依赖于p4分支的存在。没有p4分支，将出现以下相同结果：</target>
        </trans-unit>
        <trans-unit id="c71bf4b100c16d667a048d4524ffef40edf8598e" translate="yes" xml:space="preserve">
          <source>However, one may also want to specify other diff driver attributes. For example, you might want to use &lt;code&gt;textconv&lt;/code&gt; to convert postscript files to an ASCII representation for human viewing, but otherwise treat them as binary files. You cannot specify both &lt;code&gt;-diff&lt;/code&gt; and &lt;code&gt;diff=ps&lt;/code&gt; attributes. The solution is to use the &lt;code&gt;diff.*.binary&lt;/code&gt; config option:</source>
          <target state="translated">但是，可能还需要指定其他差异驱动程序属性。例如，您可能希望使用 &lt;code&gt;textconv&lt;/code&gt; 将后记文件转换为ASCII表示形式以供人查看，但否则将它们视为二进制文件。您不能同时指定 &lt;code&gt;-diff&lt;/code&gt; 和 &lt;code&gt;diff=ps&lt;/code&gt; 属性。解决方案是使用 &lt;code&gt;diff.*.binary&lt;/code&gt; 配置选项：</target>
        </trans-unit>
        <trans-unit id="c15b1eea7ada51b9540f36c6d7433749c2518719" translate="yes" xml:space="preserve">
          <source>However, our next step is to commit the &lt;strong&gt;change&lt;/strong&gt; we did, and again, to understand what&amp;rsquo;s going on, keep in mind the difference between &quot;working tree contents&quot;, &quot;index file&quot; and &quot;committed tree&quot;. We have changes in the working tree that we want to commit, and we always have to work through the index file, so the first thing we need to do is to update the index cache:</source>
          <target state="translated">但是，我们的下一步是提交所做的&lt;strong&gt;更改&lt;/strong&gt;，然后再次了解正在发生的事情，请记住&amp;ldquo;工作树内容&amp;rdquo;，&amp;ldquo;索引文件&amp;rdquo;和&amp;ldquo;已提交树&amp;rdquo;之间的区别。我们要提交的工作树中有更改，并且我们始终必须遍历索引文件，因此，我们要做的第一件事是更新索引缓存：</target>
        </trans-unit>
        <trans-unit id="066e262ce5d073a40098065a4bfe593a37b357ee" translate="yes" xml:space="preserve">
          <source>However, since Git knows about them, you can now start using some of the most basic Git commands to manipulate the files or look at their status.</source>
          <target state="translated">不过,既然 Git 知道它们,你现在可以开始使用一些最基本的 Git 命令来操作文件或查看它们的状态了。</target>
        </trans-unit>
        <trans-unit id="2d4b86f86d3381add9d6753c2a6a37207cb69976" translate="yes" xml:space="preserve">
          <source>However, the &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; command provides a way to do this in one step:</source>
          <target state="translated">但是，&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;命令提供了一种一步执行此操作的方法：</target>
        </trans-unit>
        <trans-unit id="b2062c8611299450fbfa8b88f93e46840eed9772" translate="yes" xml:space="preserve">
          <source>However, the commits do not form a simple list; Git allows lines of development to diverge and then reconverge, and the point where two lines of development reconverge is called a &quot;merge&quot;. The commit representing a merge can therefore have more than one parent, with each parent representing the most recent commit on one of the lines of development leading to that point.</source>
          <target state="translated">然而,提交并不是一个简单的列表;Git 允许开发线分叉,然后重新融合,两个开发线重新融合的点被称为 &quot;合并&quot;,因此,代表合并的提交可以有多个父提交,每个父提交都代表导致该点的一个最新提交。因此,代表合并的提交可以有多个父提交,每个父提交代表通往该点的某条开发线的最新提交。</target>
        </trans-unit>
        <trans-unit id="dc3c84ebe58db76ac38c1e3a6d7daded7c305410" translate="yes" xml:space="preserve">
          <source>However, the more common way to do this is to maintain a separate public repository (usually on a different host) for others to pull changes from. This is usually more convenient, and allows you to cleanly separate private work in progress from publicly visible work.</source>
          <target state="translated">然而,更常见的方法是维护一个单独的公共仓库(通常是在不同的主机上),供其他人拉取更改。这通常是比较方便的,而且可以让你把正在进行的私人工作和公开可见的工作干净地分开。</target>
        </trans-unit>
        <trans-unit id="755c039a0c20727e4839caf6deef253d613f16de" translate="yes" xml:space="preserve">
          <source>However, there are cases in which your local changes do conflict with the upstream changes, and &lt;code&gt;git pull&lt;/code&gt; refuses to overwrite your changes. In such a case, you can stash your changes away, perform a pull, and then unstash, like this:</source>
          <target state="translated">但是，在某些情况下，本地更改与上游更改确实会冲突，并且 &lt;code&gt;git pull&lt;/code&gt; 拒绝覆盖您的更改。在这种情况下，您可以将更改保存起来，执行拉取，然后取消保存，如下所示：</target>
        </trans-unit>
        <trans-unit id="e43d419a26518c38e69ee02a5a541b221da6c649" translate="yes" xml:space="preserve">
          <source>However, there are legitimate reasons why a developer may want to recreate merge commits: to keep the branch structure (or &quot;commit topology&quot;) when working on multiple, inter-related branches.</source>
          <target state="translated">然而,有一些合理的理由让开发人员希望重新创建合并提交:在处理多个相互关联的分支时,保持分支结构(或 &quot;提交拓扑&quot;)。</target>
        </trans-unit>
        <trans-unit id="89adb927099ba4a8289673a41ab8ec24ea6e4abd" translate="yes" xml:space="preserve">
          <source>However, there is a situation in which it can be useful to violate this assumption.</source>
          <target state="translated">然而,在有些情况下,违反这一假设是有用的。</target>
        </trans-unit>
        <trans-unit id="b068287d80433091fc93a07d4af49d57d3676c5d" translate="yes" xml:space="preserve">
          <source>However, there is no particular reason to merge in one branch first and the other next, when what you have are a set of truly independent changes (if the order mattered, then they are not independent by definition). You could instead merge those two branches into the current branch at once. First let&amp;rsquo;s undo what we just did and start over. We would want to get the master branch before these two merges by resetting it to &lt;code&gt;master~2&lt;/code&gt;:</source>
          <target state="translated">但是，当您拥有的是一组真正独立的更改时（如果顺序很重要，那么根据定义它们就不是独立的），则没有特别的理由先合并到一个分支中，然后再合并到另一个分支中。您可以将这两个分支立即合并到当前分支中。首先，让我们撤消我们所做的一切，然后重新开始。我们希望通过恢复让这两个合并前的主分支 &lt;code&gt;master~2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="76dbad7bbd23560fcc8351e42a22aad055901cd6" translate="yes" xml:space="preserve">
          <source>However, these features fall short of a complete solution, so users who run commands concurrently have to live with some risk of corruption (which seems to be low in practice).</source>
          <target state="translated">然而,这些功能还没有达到一个完整的解决方案,所以同时运行命令的用户不得不承受一定的损坏风险(实践中似乎很低)。</target>
        </trans-unit>
        <trans-unit id="f41fcda082e8874086be41192b1abbea2d3295da" translate="yes" xml:space="preserve">
          <source>However, this is &lt;strong&gt;NOT&lt;/strong&gt; allowed for switches with an optional value, where the &lt;code&gt;stuck&lt;/code&gt; form must be used:</source>
          <target state="translated">然而，这是&lt;strong&gt;不&lt;/strong&gt;允许与可选的值，其中，所述开关 &lt;code&gt;stuck&lt;/code&gt; ，必须使用形式：</target>
        </trans-unit>
        <trans-unit id="4da9d9ef7c6a0e88df4192c01891a87d88664b48" translate="yes" xml:space="preserve">
          <source>However, this is only a convention, and you can name your branches anything you want, and don&amp;rsquo;t have to ever even &lt;code&gt;have&lt;/code&gt; a &lt;code&gt;master&lt;/code&gt; branch. A number of the Git tools will assume that &lt;code&gt;.git/HEAD&lt;/code&gt; is valid, though.</source>
          <target state="translated">但是，这只是一个约定，您可以根据需要命名分支，甚至 &lt;code&gt;have&lt;/code&gt; 拥有 &lt;code&gt;master&lt;/code&gt; 分支。不过，许多Git工具都假定 &lt;code&gt;.git/HEAD&lt;/code&gt; 是有效的。</target>
        </trans-unit>
        <trans-unit id="a7abfde622702125ddcfca8f6b53cf2f29202a6d" translate="yes" xml:space="preserve">
          <source>However, this last command can be dangerous in some cases&amp;mdash;​never throw away a commit you have already committed if that commit may itself have been merged into another branch, as doing so may confuse further merges.</source>
          <target state="translated">但是，在某些情况下，最后一个命令可能很危险-如果该提交本身可能已经合并到另一个分支中，则不要丢弃您已经提交的提交，因为这样做可能会使进一步的合并变得混乱。</target>
        </trans-unit>
        <trans-unit id="ba574b0c600bcf4947d9fc0b827ea5d5666b3028" translate="yes" xml:space="preserve">
          <source>However, when no confusion will result, we often just use the term &quot;branch&quot; both for branches and for branch heads.</source>
          <target state="translated">但是,在不会造成混淆的情况下,我们往往只用 &quot;分支 &quot;来表示分支和分支头。</target>
        </trans-unit>
        <trans-unit id="2952d19c4dc617ab4a4ae6abe65c729f11b54f82" translate="yes" xml:space="preserve">
          <source>However, when you do &lt;code&gt;git read-tree&lt;/code&gt; with three trees, the &quot;stage&quot; starts out at 1.</source>
          <target state="translated">但是，当您使用三棵树进行 &lt;code&gt;git read-tree&lt;/code&gt; 时，&amp;ldquo;阶段&amp;rdquo;从1开始。</target>
        </trans-unit>
        <trans-unit id="28dd1f9126b301b96d86409d92ae4b0d38938148" translate="yes" xml:space="preserve">
          <source>However, while there is nothing wrong with Git&amp;rsquo;s support for shared repositories, this mode of operation is not generally recommended, simply because the mode of collaboration that Git supports&amp;mdash;​by exchanging patches and pulling from public repositories&amp;mdash;​has so many advantages over the central shared repository:</source>
          <target state="translated">但是，尽管Git对共享存储库的支持没有错，但通常不建议使用这种操作模式，这仅仅是因为Git通过交换补丁程序并从公共存储库中获取支持所支持的协作模式具有许多优势。中央共享存储库：</target>
        </trans-unit>
        <trans-unit id="6ee73f3ad469e31cc982a856f9ec909f123f7a3b" translate="yes" xml:space="preserve">
          <source>However, you already dirtied the index (i.e. your index does not match the &lt;code&gt;HEAD&lt;/code&gt; commit). But you know the pull you are going to make does not affect &lt;code&gt;frotz.c&lt;/code&gt; or &lt;code&gt;filfre.c&lt;/code&gt;, so you revert the index changes for these two files. Your changes in working tree remain there.</source>
          <target state="translated">但是，您已经弄脏了索引（即您的索引与 &lt;code&gt;HEAD&lt;/code&gt; 提交不匹配）。但是您知道将要进行的拉动不会影响 &lt;code&gt;frotz.c&lt;/code&gt; 或 &lt;code&gt;filfre.c&lt;/code&gt; ，因此您可以还原这两个文件的索引更改。您在工作树中的更改将保留在那里。</target>
        </trans-unit>
        <trans-unit id="9e2e4a0fcb3942d8a82c6a2331932351c7c8a259" translate="yes" xml:space="preserve">
          <source>However, your &quot;wrong&quot; branch and correct &quot;mytopic&quot; branch may differ in files that you have modified locally, in which case the above switch would fail like this:</source>
          <target state="translated">但是,你的 &quot;错误 &quot;分支和正确的 &quot;mytopic &quot;分支可能在你本地修改的文件中有所不同,在这种情况下,上面的切换就会像这样失败。</target>
        </trans-unit>
        <trans-unit id="6a9281c350a487a356b48bdfa67abfef81982489" translate="yes" xml:space="preserve">
          <source>However, your &quot;wrong&quot; branch and correct &lt;code&gt;mytopic&lt;/code&gt; branch may differ in files that you have modified locally, in which case the above checkout would fail like this:</source>
          <target state="translated">但是，在本地修改的文件中，&amp;ldquo;错误&amp;rdquo;分支和正确的 &lt;code&gt;mytopic&lt;/code&gt; 分支可能会有所不同，在这种情况下，上述签出将失败，如下所示：</target>
        </trans-unit>
        <trans-unit id="aba6c7716c927b23fe0532abdd2a92255af0c41e" translate="yes" xml:space="preserve">
          <source>I asked Git to ignore various files, yet they are still tracked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf133288702a5baf1a98928a127236dfad5386f" translate="yes" xml:space="preserve">
          <source>I most actively use it during the merge window (when a lot of trees get merged upstream and when the influx of bugs is the highest) - and yes, there have been cases that i used it multiple times a day. My average is roughly once a day.</source>
          <target state="translated">我最积极地使用它在合并窗口期间(当很多树被合并到上游,当bug的涌入是最多的)-是的,有一些情况下,我用它一天多次。我的平均水平大概是一天一次。</target>
        </trans-unit>
        <trans-unit id="68f0106a1031d1af2737e13db22dd37fbfa774a7" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;m on Windows and git diff shows my files as having a &lt;code&gt;^M&lt;/code&gt; at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca6d8e8130ad25971674c7a1bb1360ef8a2628f" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;m on Windows and my text files are detected as binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee4207d261aeb0669000afd54b1bb8707b66f0e" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;ve made a change with a bug and it&amp;rsquo;s been included in the main branch. How should I undo it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1560bb64e063e20939b70200646f57cb896909d" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;ve made a mistake in the last commit. How do I change it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27777a39e933776b5c584d121830042fbc955f15" translate="yes" xml:space="preserve">
          <source>I.e. a fast-forward of commits and tags outside &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; is allowed, even in cases where what&amp;rsquo;s being fast-forwarded is not a commit, but a tag object which happens to point to a new commit which is a fast-forward of the commit the last tag (or commit) it&amp;rsquo;s replacing. Replacing a tag with an entirely different tag is also allowed, if it points to the same commit, as well as pushing a peeled tag, i.e. pushing the commit that existing tag object points to, or a new tag object which an existing commit points to.</source>
          <target state="translated">也就是说，即使在快速转发的内容不是提交，而是恰好指向新提交的tag对象的情况下，也允许在 &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 之外的提交和标签的快速转发提交的快进命令它将替换的最后一个标签（或提交）。如果标签指向相同的提交，也可以用完全不同的标签替换标签，并推送剥离的标签，即推送现有标签对象指向的提交，或推送现有提交指向的新标签对象。</target>
        </trans-unit>
        <trans-unit id="f6dcea8e2840d6db982f7ea79204e026c88b3ea6" translate="yes" xml:space="preserve">
          <source>I.e. create a &lt;code&gt;base&lt;/code&gt; tag for versions of the upstream code that you&amp;rsquo;ve seen and are willing to overwrite, then rewrite history, and finally force push changes to &lt;code&gt;master&lt;/code&gt; if the remote version is still at &lt;code&gt;base&lt;/code&gt;, regardless of what your local &lt;code&gt;remotes/origin/master&lt;/code&gt; has been updated to in the background.</source>
          <target state="translated">也就是说，为您已经看到并愿意覆盖的上游代码版本创建一个 &lt;code&gt;base&lt;/code&gt; 标记，然后重写历史记录，如果远程版本仍处于 &lt;code&gt;base&lt;/code&gt; ，则最终强制将更改推送到 &lt;code&gt;master&lt;/code&gt; 版本，而不管您本地的 &lt;code&gt;remotes/origin/master&lt;/code&gt; 是什么/ master已更新为后台。</target>
        </trans-unit>
        <trans-unit id="d160035a43dfa655c4a6e47190220d072175392c" translate="yes" xml:space="preserve">
          <source>IOW, you can use this thing to look for likely duplicate commits.</source>
          <target state="translated">也就是说,你可以用这个东西来寻找可能的重复提交。</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO 8601</target>
        </trans-unit>
        <trans-unit id="8927163ad4efa8aea54b9b8e320ebffea4053ff8" translate="yes" xml:space="preserve">
          <source>Id of a tree-ish.</source>
          <target state="translated">树状的ID。</target>
        </trans-unit>
        <trans-unit id="f64266dea77070f77d87b89cb3f30c2d11210170" translate="yes" xml:space="preserve">
          <source>Identifier terminology</source>
          <target state="translated">识别符术语</target>
        </trans-unit>
        <trans-unit id="2dd468355239de3fa1d047b407c0f3c35e4315ad" translate="yes" xml:space="preserve">
          <source>Identity-specific versions of the &lt;code&gt;sendemail.*&lt;/code&gt; parameters found below, taking precedence over those when this identity is selected, through either the command-line or &lt;code&gt;sendemail.identity&lt;/code&gt;.</source>
          <target state="translated">下面提供了 &lt;code&gt;sendemail.*&lt;/code&gt; 参数的特定于身份的版本，这些优先级高于通过命令行或 &lt;code&gt;sendemail.identity&lt;/code&gt; 选择该身份时的版本。</target>
        </trans-unit>
        <trans-unit id="05103278665252bd3225a3f315ada6e006bd41ae" translate="yes" xml:space="preserve">
          <source>If &amp;ldquo;:&amp;lt;funcname&amp;gt;&amp;rdquo; is given in place of &amp;lt;start&amp;gt; and &amp;lt;end&amp;gt;, it is a regular expression that denotes the range from the first funcname line that matches &amp;lt;funcname&amp;gt;, up to the next funcname line. &amp;ldquo;:&amp;lt;funcname&amp;gt;&amp;rdquo; searches from the end of the previous &lt;code&gt;-L&lt;/code&gt; range, if any, otherwise from the start of file. &amp;ldquo;^:&amp;lt;funcname&amp;gt;&amp;rdquo; searches from the start of file.</source>
          <target state="translated">如果用&amp;ldquo;：&amp;lt;funcname&amp;gt;&amp;rdquo;代替&amp;lt;start&amp;gt;和&amp;lt;end&amp;gt;，则它是一个正则表达式，表示从与&amp;lt;funcname&amp;gt;匹配的第一行funcname到下一个funcname行的范围。&amp;ldquo;：&amp;lt;funcname&amp;gt;&amp;rdquo;从上一个 &lt;code&gt;-L&lt;/code&gt; 范围的末尾（如果有）搜索，否则从文件的开头搜索。&amp;ldquo; ^：&amp;lt;funcname&amp;gt;&amp;rdquo;从文件的开头开始搜索。</target>
        </trans-unit>
        <trans-unit id="a70081d33e7c2f9862444b9de88b6fa456d0c4eb" translate="yes" xml:space="preserve">
          <source>If &amp;lt;branch&amp;gt; is specified, &lt;code&gt;git rebase&lt;/code&gt; will perform an automatic &lt;code&gt;git switch &amp;lt;branch&amp;gt;&lt;/code&gt; before doing anything else. Otherwise it remains on the current branch.</source>
          <target state="translated">如果指定了&amp;lt;branch&amp;gt;， &lt;code&gt;git rebase&lt;/code&gt; 将在执行其他操作之前执行自动 &lt;code&gt;git switch &amp;lt;branch&amp;gt;&lt;/code&gt; 。否则，它将保留在当前分支上。</target>
        </trans-unit>
        <trans-unit id="441a1b498aa3709837145817fb556c2b9312d349" translate="yes" xml:space="preserve">
          <source>If &amp;lt;commit-ish&amp;gt; is a branch name (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) and is not found, and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; are used, but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name, treat as equivalent to:</source>
          <target state="translated">如果&amp;lt;commit-ish&amp;gt;是分支名称（将其称为 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; ）并且未找到，并且 &lt;code&gt;-b&lt;/code&gt; 或 &lt;code&gt;-B&lt;/code&gt; 或 &lt;code&gt;--detach&lt;/code&gt; 均未使用，但是恰好在一个远程目录中存在一个跟踪分支（称为它 &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; ）具有匹配的名称，请等同于：</target>
        </trans-unit>
        <trans-unit id="a2dfa99d3d5ae08ba34d86a50dd72c99c275182b" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; does not match any remote ref, either</source>
          <target state="translated">如果&amp;lt;dst&amp;gt;与任何远程引用都不匹配，则</target>
        </trans-unit>
        <trans-unit id="a47c4a8533ef20594cec62184911d5ccc54294bc" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; doesn&amp;rsquo;t start with &lt;code&gt;refs/&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) we will try to infer where in &lt;code&gt;refs/*&lt;/code&gt; on the destination &amp;lt;repository&amp;gt; it belongs based on the type of &amp;lt;src&amp;gt; being pushed and whether &amp;lt;dst&amp;gt; is ambiguous.</source>
          <target state="translated">如果&amp;lt;dst&amp;gt;不是以 &lt;code&gt;refs/&lt;/code&gt; 开头（例如 &lt;code&gt;refs/heads/master&lt;/code&gt; ），我们将根据被推送的&amp;lt;src&amp;gt;类型以及是否&amp;lt; 来尝试推断目标&amp;lt;repository&amp;gt; 在 &lt;code&gt;refs/*&lt;/code&gt; 中的位置。 dst&amp;gt;不明确。</target>
        </trans-unit>
        <trans-unit id="055e400548fbd1f8dd3a927bc48c7fba28571578" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; unambiguously refers to a ref on the &amp;lt;repository&amp;gt; remote, then push to that ref.</source>
          <target state="translated">如果&amp;lt;dst&amp;gt;明确引用&amp;lt;repository&amp;gt;远程服务器上的引用，则推送至该引用。</target>
        </trans-unit>
        <trans-unit id="2f8ca0e0f80952529303f3d2318f597064384182" translate="yes" xml:space="preserve">
          <source>If &amp;lt;src&amp;gt; resolves to a ref starting with refs/heads/ or refs/tags/, then prepend that to &amp;lt;dst&amp;gt;.</source>
          <target state="translated">如果&amp;lt;src&amp;gt;解析为以refs / heads /或refs / tags /开头的ref，则将其前缀为&amp;lt;dst&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="22f62b9091f5d458969b188b7b4383b4ee480486" translate="yes" xml:space="preserve">
          <source>If &amp;lt;start&amp;gt; or &amp;lt;end&amp;gt; is a number, it specifies an absolute line number (lines count from 1).</source>
          <target state="translated">如果&amp;lt;start&amp;gt;或&amp;lt;end&amp;gt;是数字，则它指定绝对行号（行数从1开始）。</target>
        </trans-unit>
        <trans-unit id="3dcd00aaff1f71fc43821b3cae7ba5d1996fda2a" translate="yes" xml:space="preserve">
          <source>If &amp;lt;type&amp;gt; is specified, the raw (though uncompressed) contents of the &amp;lt;object&amp;gt; will be returned.</source>
          <target state="translated">如果指定了&amp;lt;type&amp;gt;，则将返回&amp;lt;object&amp;gt;的原始（尽管未压缩）内容。</target>
        </trans-unit>
        <trans-unit id="60fbab80da041fac4b578f6b9620a6e042d89ff6" translate="yes" xml:space="preserve">
          <source>If &amp;lt;upstream&amp;gt; is given on the command line, then the default is &lt;code&gt;--no-fork-point&lt;/code&gt;, otherwise the default is &lt;code&gt;--fork-point&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099d6bbda7b3ea83e2000830c8cd48d38a505e41" translate="yes" xml:space="preserve">
          <source>If &amp;lt;upstream&amp;gt; is not specified, the upstream configured in branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge options will be used (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details) and the &lt;code&gt;--fork-point&lt;/code&gt; option is assumed. If you are currently not on any branch or if the current branch does not have a configured upstream, the rebase will abort.</source>
          <target state="translated">如果未指定&amp;lt;upstream&amp;gt;，则将使用在branch。&amp;lt;name&amp;gt; .remote和branch。&amp;lt;name&amp;gt; .merge选项中配置的上游（有关详细信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）和 &lt;code&gt;--fork-point&lt;/code&gt; 选项假设。如果您当前不在任何分支上，或者当前分支上没有配置上游，则重新定位将中止。</target>
        </trans-unit>
        <trans-unit id="217621e5abfa606810a09d87aaa6c7fa540fc0fa" translate="yes" xml:space="preserve">
          <source>If --base-path is enabled and repo lookup fails, with this option &lt;code&gt;git daemon&lt;/code&gt; will attempt to lookup without prefixing the base path. This is useful for switching to --base-path usage, while still allowing the old paths.</source>
          <target state="translated">如果启用了--base-path，并且回购查找失败，则使用 &lt;code&gt;git daemon&lt;/code&gt; 这个选项将尝试在不添加基本路径前缀的情况下进行查找。这对于切换到--base-path用法非常有用，同时仍然允许使用旧路径。</target>
        </trans-unit>
        <trans-unit id="8fc1cea1e55be69663b951a920323d5b77c212cc" translate="yes" xml:space="preserve">
          <source>If --follow-symlinks is used, and a symlink in the repository points outside the repository, then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">如果使用--follow-symlinks，并且存储库中的符号链接指向存储库外部，则 &lt;code&gt;cat-file&lt;/code&gt; 将忽略任何自定义格式并打印：</target>
        </trans-unit>
        <trans-unit id="100e053a72420596d3d8e1af3be6193b59283565" translate="yes" xml:space="preserve">
          <source>If --follow-symlinks is used, the following error messages will be displayed:</source>
          <target state="translated">如果使用--follow-symlinks,将显示以下错误信息。</target>
        </trans-unit>
        <trans-unit id="d4456078eb18cc02d0f68997188ec86716309ba3" translate="yes" xml:space="preserve">
          <source>If --merge-base is given, instead of using &amp;lt;commit&amp;gt;, use the merge base of &amp;lt;commit&amp;gt; and HEAD. &lt;code&gt;git diff --merge-base A&lt;/code&gt; is equivalent to &lt;code&gt;git diff $(git merge-base A HEAD)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9e589feec01d86ec81a279ae143c03313c51c1" translate="yes" xml:space="preserve">
          <source>If --merge-base is given, use the merge base of the two commits for the &quot;before&quot; side. &lt;code&gt;git diff --merge-base A B&lt;/code&gt; is equivalent to &lt;code&gt;git diff $(git merge-base A B) B&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af2f9fd35f6354ba06f2224c3a1950a1f2e9539" translate="yes" xml:space="preserve">
          <source>If --no-deref is given, &amp;lt;ref&amp;gt; itself is overwritten, rather than the result of following the symbolic pointers.</source>
          <target state="translated">如果给出了--no-deref，则&amp;lt;ref&amp;gt;本身将被覆盖，而不是跟随符号指针的结果。</target>
        </trans-unit>
        <trans-unit id="09e3aecc968d12fb9705beff5237174e03c29bc7" translate="yes" xml:space="preserve">
          <source>If --porcelain is used, then each line of the output is of the form:</source>
          <target state="translated">如果使用--porcelain,那么输出的每一行都是这样的形式。</target>
        </trans-unit>
        <trans-unit id="f6d2b768e06f422855acdd627f6c6194c3c0ef9e" translate="yes" xml:space="preserve">
          <source>If --prune-empty is specified, sometimes empty commits are missed and left around anyway (a somewhat rare bug, but it happens&amp;hellip;​)</source>
          <target state="translated">如果指定了--prune-empty，则有时会遗漏空的提交并留下来（这是一个罕见的错误，但确实会发生...）</target>
        </trans-unit>
        <trans-unit id="e22868793c21cef41b42f4d8e7236df1fabd77b0" translate="yes" xml:space="preserve">
          <source>If --prune-empty is specified, then intentionally placed empty commits from before the filtering operation are also pruned instead of just pruning commits that became empty due to filtering rules.</source>
          <target state="translated">如果指定了 --prune-empty,那么在过滤操作之前有意放置的空提交也会被修剪,而不是仅仅修剪由于过滤规则而变成空的提交。</target>
        </trans-unit>
        <trans-unit id="a5f91d56ff44d75c2f6264bd8bf6a44ba8095c27" translate="yes" xml:space="preserve">
          <source>If --prune-empty isn&amp;rsquo;t specified, then the filtering process can create hoards of confusing empty commits</source>
          <target state="translated">如果未指定--prune-empty，则过滤过程可能会产生使空提交混淆的ho积</target>
        </trans-unit>
        <trans-unit id="2d1fd147af59c1bbe70034d2e19205e4683ec22e" translate="yes" xml:space="preserve">
          <source>If --refresh finds unmerged changes in the index, the default behavior is to error out. This option makes &lt;code&gt;git update-index&lt;/code&gt; continue anyway.</source>
          <target state="translated">如果--refresh在索引中发现未合并的更改，则默认行为是错误输出。这个选项使 &lt;code&gt;git update-index&lt;/code&gt; 仍然继续。</target>
        </trans-unit>
        <trans-unit id="a1d97a45ebe920517b85d93c5180821e570038df" translate="yes" xml:space="preserve">
          <source>If -b is used the short-format status is preceded by a line</source>
          <target state="translated">如果使用-b,则短格式状态前会有一行。</target>
        </trans-unit>
        <trans-unit id="a46e8db06d3992e975f7697afc61f277e4b431aa" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; or &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; is not selecting the key you want it to automatically when creating a signed tag or commit, you can override the default selection with this variable. This option is passed unchanged to gpg&amp;rsquo;s --local-user parameter, so you may specify a key using any method that gpg supports.</source>
          <target state="translated">如果&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;或&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;在创建签名标签或提交时未选择您希望其自动执行的键，则可以使用此变量覆盖默认选择。此选项未更改地传递给gpg的--local-user参数，因此您可以使用gpg支持的任何方法来指定键。</target>
        </trans-unit>
        <trans-unit id="2cf1a7ea3bd0bf42d7200bd0e5a09fa57461a419" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$GIT_DIR/&amp;lt;refname&amp;gt;&lt;/code&gt; exists, that is what you mean (this is usually useful only for &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;FETCH_HEAD&lt;/code&gt;, &lt;code&gt;ORIG_HEAD&lt;/code&gt;, &lt;code&gt;MERGE_HEAD&lt;/code&gt; and &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt;);</source>
          <target state="translated">如果 &lt;code&gt;$GIT_DIR/&amp;lt;refname&amp;gt;&lt;/code&gt; 存在，这就是您的意思（通常仅对 &lt;code&gt;HEAD&lt;/code&gt; ， &lt;code&gt;FETCH_HEAD&lt;/code&gt; ， &lt;code&gt;ORIG_HEAD&lt;/code&gt; ， &lt;code&gt;MERGE_HEAD&lt;/code&gt; 和 &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; 有用）；</target>
        </trans-unit>
        <trans-unit id="393d945c97962e065f70f0c395a4b7cc04c58275" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$GIT_DIR&lt;/code&gt; is not defined and the current directory is not detected to lie in a Git repository or work tree print a message to stderr and exit with nonzero status.</source>
          <target state="translated">如果未定义 &lt;code&gt;$GIT_DIR&lt;/code&gt; 并且未检测到当前目录位于Git存储库或工作树中，则向stderr发送一条消息，并以非零状态退出。</target>
        </trans-unit>
        <trans-unit id="b71bb32cc72ead271cb1dd3ba713d52586ceff1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$per_request_config&lt;/code&gt; is not a code reference, it is interpreted as boolean value. If it is true gitweb will process config files once per request, and if it is false gitweb will process config files only once, each time it is executed. True by default (set to 1).</source>
          <target state="translated">如果 &lt;code&gt;$per_request_config&lt;/code&gt; 不是代码引用，则将其解释为布尔值。如果为true，则gitweb将在每个请求中处理一次配置文件，如果为false，则gitweb每次执行时将仅处理配置文件一次。默认情况下为True（设置为1）。</target>
        </trans-unit>
        <trans-unit id="2006fc66d73a978df057f23b3e1521f13762b146" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$projects_list&lt;/code&gt; variable is unset, gitweb will recursively scan filesystem for Git repositories. The &lt;code&gt;$project_maxdepth&lt;/code&gt; is used to limit traversing depth, relative to &lt;code&gt;$projectroot&lt;/code&gt; (starting point); it means that directories which are further from &lt;code&gt;$projectroot&lt;/code&gt; than &lt;code&gt;$project_maxdepth&lt;/code&gt; will be skipped.</source>
          <target state="translated">如果未设置 &lt;code&gt;$projects_list&lt;/code&gt; 变量，则gitweb将递归扫描文件系统以查找Git存储库。的 &lt;code&gt;$project_maxdepth&lt;/code&gt; 用于限制横动深度，相对于 &lt;code&gt;$projectroot&lt;/code&gt; （起点）; 这意味着将跳过距离 &lt;code&gt;$projectroot&lt;/code&gt; 比 &lt;code&gt;$project_maxdepth&lt;/code&gt; 更远的目录。</target>
        </trans-unit>
        <trans-unit id="e1a24fe330082e54d9c17c846d5ecec5993c1e30" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is not found but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name and &lt;code&gt;--no-guess&lt;/code&gt; is not specified, treat as equivalent to</source>
          <target state="translated">如果未找到 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; ,但确实在一个具有匹配名称的远程（称为 &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; ）中存在一个跟踪分支，并且未指定 &lt;code&gt;--no-guess&lt;/code&gt; ，则将其等同于</target>
        </trans-unit>
        <trans-unit id="8d6aaf33671aeae0467cc81ab4a876d4297a1c66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is not found but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name, treat as equivalent to</source>
          <target state="translated">如果未找到 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; ,但确实在一个具有匹配名称的远程站点（称为 &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; ）中存在跟踪分支，则将其等同于</target>
        </trans-unit>
        <trans-unit id="d5e4daa5549f785c6c9358d5ddb62b147a25d8f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch name (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) and is not found, and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; are used, but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name, treat as equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34274f8acc6fb322cd63ad185064de80d714660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; used, then, as a convenience, the new working tree is associated with a branch (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) named after &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt;. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t exist, a new branch based on &lt;code&gt;HEAD&lt;/code&gt; is automatically created as if &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; was given. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does exist, it will be checked out in the new working tree, if it&amp;rsquo;s not checked out anywhere else, otherwise the command will refuse to create the working tree (unless &lt;code&gt;--force&lt;/code&gt; is used).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29cec940deeaa506fbdf23d2fcc19ea5029d5ef6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; used, then, as a convenience, the new worktree is associated with a branch (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) named after &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt;. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t exist, a new branch based on HEAD is automatically created as if &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; was given. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does exist, it will be checked out in the new worktree, if it&amp;rsquo;s not checked out anywhere else, otherwise the command will refuse to create the worktree (unless &lt;code&gt;--force&lt;/code&gt; is used).</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 被省略并且既不 &lt;code&gt;-b&lt;/code&gt; 也不 &lt;code&gt;-B&lt;/code&gt; 也不 &lt;code&gt;--detach&lt;/code&gt; 使用，那么，作为一种方便，新worktree与分支（称之为相关联 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; ）而得名 &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt; 。如果 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 不存在，则会自动创建一个基于HEAD的新分支，就像给出了 &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; 一样。如果 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 确实存在，它将在新的工作树中检出，如果未在其他任何地方检出，则该命令将拒绝创建工作树（除非使用 &lt;code&gt;--force&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="62b6dbbe2a25a278c760cd92507e0bb77e25690a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt;, if the first paragraph of the branch description is greater than 100 bytes, then the mode will be &lt;code&gt;message&lt;/code&gt;, otherwise &lt;code&gt;subject&lt;/code&gt; will be used.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 为 &lt;code&gt;auto&lt;/code&gt; ，则分支描述的第一段大于100个字节，则该模式为 &lt;code&gt;message&lt;/code&gt; ，否则将使用 &lt;code&gt;subject&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="563c89a3c046790f554398f75098f56ae60f56e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;message&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;, the cover letter subject will be populated with placeholder text. The body of the cover letter will be populated with the branch&amp;rsquo;s description. This is the default mode when no configuration nor command line option is specified.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 是 &lt;code&gt;message&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; ，则求职信主题将使用占位符文本填充。求职信的正文将填充分支的描述。当未指定配置或命令行选项时，这是默认模式。</target>
        </trans-unit>
        <trans-unit id="768e82f3c3c3a8afb9417d73246f89dace57fcaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;, both the cover letter subject and body will be populated with placeholder text.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 为 &lt;code&gt;none&lt;/code&gt; ，则求职信主题和正文均将填充占位符文本。</target>
        </trans-unit>
        <trans-unit id="3b18877d6ecf14744d4315ad4c41aafa8a39f64e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;subject&lt;/code&gt;, the first paragraph of the branch description will populate the cover letter subject. The remainder of the description will populate the body of the cover letter.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 为 &lt;code&gt;subject&lt;/code&gt; ，则分支描述的第一段将填充求职信主题。说明的其余部分将填充求职信的正文。</target>
        </trans-unit>
        <trans-unit id="5e29b380beb0930e1e749e4eaa468dd6abb12015" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; names an active submodule and the restore location includes the working tree, the submodule will only be updated if this option is given, in which case its working tree will be restored to the commit recorded in the superproject, and any local modifications overwritten. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, submodules working trees will not be updated. Just like &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc7051c213eefd2c9268c6d0376ec90a4e63b63" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; is a number, it specifies an absolute line number (lines count from 1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a4599482148106286830a5bf06a49e73c76aca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--autosquash&lt;/code&gt; is used, &quot;exec&quot; lines will not be appended for the intermediate commits, and will only appear at the end of each squash/fixup series.</source>
          <target state="translated">如果使用 &lt;code&gt;--autosquash&lt;/code&gt; ，则&amp;ldquo; exec&amp;rdquo;行将不会添加到中间提交中，而只会出现在每个squash / fixup系列的末尾。</target>
        </trans-unit>
        <trans-unit id="ab8e2bae185710923964a946f737935700b0fc1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--batch&lt;/code&gt; is specified, the object information is followed by the object contents (consisting of &lt;code&gt;%(objectsize)&lt;/code&gt; bytes), followed by a newline.</source>
          <target state="translated">如果指定了 &lt;code&gt;--batch&lt;/code&gt; ，则对象信息后跟对象内容（由 &lt;code&gt;%(objectsize)&lt;/code&gt; 个字节组成），后跟换行符。</target>
        </trans-unit>
        <trans-unit id="c868d58aa72d9bce1efba44bdbf844fae93d14ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; is given, &lt;code&gt;cat-file&lt;/code&gt; will read objects from stdin, one per line, and print information about them. By default, the whole line is considered as an object, as if it were fed to &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;--batch&lt;/code&gt; 或 &lt;code&gt;--batch-check&lt;/code&gt; ， &lt;code&gt;cat-file&lt;/code&gt; 将从stdin中读取对象，每行一个，并打印有关它们的信息。默认情况下，将整行视为对象，就像将其馈送到&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b49579ab9891477a433f3c4a7d881c054bf542d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--branch&lt;/code&gt; is given, a series of header lines are printed with information about the current branch.</source>
          <target state="translated">如果给出了 &lt;code&gt;--branch&lt;/code&gt; ，则会打印一系列标题行，其中包含有关当前分支的信息。</target>
        </trans-unit>
        <trans-unit id="92890e94239521769988796133cb653b32aed431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--cached&lt;/code&gt; is specified, it allows you to ask:</source>
          <target state="translated">如果指定了 &lt;code&gt;--cached&lt;/code&gt; ，则可以询问：</target>
        </trans-unit>
        <trans-unit id="cdc2c32e44cf382458d3759532d549dfd10bb0ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--cached&lt;/code&gt; is specified, this command will instead print the SHA-1 recorded in the superproject for each submodule.</source>
          <target state="translated">如果指定了 &lt;code&gt;--cached&lt;/code&gt; ，则此命令将为每个子模块打印记录在超级项目中的SHA-1。</target>
        </trans-unit>
        <trans-unit id="efe0936134ada9314d303de0a6d1675a3e22d7d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--force&lt;/code&gt; is specified, the submodule will be checked out (using &lt;code&gt;git checkout --force&lt;/code&gt;), even if the commit specified in the index of the containing repository already matches the commit checked out in the submodule.</source>
          <target state="translated">如果指定了 &lt;code&gt;--force&lt;/code&gt; ，则子模块将被检出（使用 &lt;code&gt;git checkout --force&lt;/code&gt; ），即使包含存储库的索引中指定的提交已经与子模块中检出的提交匹配。</target>
        </trans-unit>
        <trans-unit id="b5618fac3945aa3c15ec4d6ac940c3fc88cab042" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--force&lt;/code&gt; is specified, the submodule&amp;rsquo;s working tree will be removed even if it contains local modifications.</source>
          <target state="translated">如果指定了 &lt;code&gt;--force&lt;/code&gt; ，则子模块的工作树将被删除，即使它包含本地修改。</target>
        </trans-unit>
        <trans-unit id="95d47c3b72d050d56bd3bb3556c38937bb16f1f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--group&lt;/code&gt; is specified multiple times, commits are counted under each value (but again, only once per unique value in that commit). For example, &lt;code&gt;git shortlog --group=author --group=trailer:co-authored-by&lt;/code&gt; counts both authors and co-authors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2db79d4530ac333b81dd59fc3c02ca024b34411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--index&lt;/code&gt; is not specified, then the submodule commits in the patch are ignored and only the absence or presence of the corresponding subdirectory is checked and (if possible) updated.</source>
          <target state="translated">如果未指定 &lt;code&gt;--index&lt;/code&gt; ，则补丁中的子模块提交将被忽略，并且仅检查和删除（如果可能）相应子目录的存在。</target>
        </trans-unit>
        <trans-unit id="ab41ddd9d49ddaff35bf4379642301cf2f1054d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--index&lt;/code&gt; is specified (explicitly or implicitly), then the submodule commits must match the index exactly for the patch to apply. If any of the submodules are checked-out, then these check-outs are completely ignored, i.e., they are not required to be up to date or clean and they are not updated.</source>
          <target state="translated">如果（显式或隐式）指定了 &lt;code&gt;--index&lt;/code&gt; ，则子模块提交必须与索引完全匹配才能应用补丁。如果任何子模块都已检出，则这些检出将被完全忽略，即，不需要它们是最新的或干净的，并且它们不会更新。</target>
        </trans-unit>
        <trans-unit id="d7cd61ae0dde953250d385a6012605e922398ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--list&lt;/code&gt; is given, or if there are no non-option arguments, existing branches are listed; the current branch will be highlighted in green and marked with an asterisk. Any branches checked out in linked worktrees will be highlighted in cyan and marked with a plus sign. Option &lt;code&gt;-r&lt;/code&gt; causes the remote-tracking branches to be listed, and option &lt;code&gt;-a&lt;/code&gt; shows both local and remote branches.</source>
          <target state="translated">如果给出了 &lt;code&gt;--list&lt;/code&gt; ，或者没有非选项参数，则列出现有分支；当前分支将以绿色突出显示并标有星号。在链接的工作树中签出的所有分支将以青色突出显示并标有加号。选项 &lt;code&gt;-r&lt;/code&gt; 导致列出远程跟踪分支，选项 &lt;code&gt;-a&lt;/code&gt; 同时显示本地和远程分支。</target>
        </trans-unit>
        <trans-unit id="45b84e8c64b1db8d6046842947d0384f2fee755b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--log&lt;/code&gt; is specified, a shortlog of the commits being merged will be appended to the specified message.</source>
          <target state="translated">如果指定了 &lt;code&gt;--log&lt;/code&gt; ，则将合并的提交的简短日志附加到指定的消息中。</target>
        </trans-unit>
        <trans-unit id="1772a311632ebe173773fb98d78cf3669fc056b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--max-commits=&amp;lt;M&amp;gt;&lt;/code&gt; is specified with &lt;code&gt;M&lt;/code&gt; a positive integer, and the new tip file would have more than &lt;code&gt;M&lt;/code&gt; commits, then instead merge the new tip with the previous tip.</source>
          <target state="translated">如果为 &lt;code&gt;--max-commits=&amp;lt;M&amp;gt;&lt;/code&gt; 用 &lt;code&gt;M&lt;/code&gt; 指定一个正整数，并且新提示文件将具有 &lt;code&gt;M&lt;/code&gt; 个以上的提交，则将新提示与上一个提示合并。</target>
        </trans-unit>
        <trans-unit id="f4eab33758877fd85cebec91765014b4b92dc48c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into nested submodules, and show their status as well.</source>
          <target state="translated">如果指定了 &lt;code&gt;--recursive&lt;/code&gt; ，则此命令将递归到嵌套子模块中，并显示其状态。</target>
        </trans-unit>
        <trans-unit id="776298c85f9bd8538095ba7ea6588e9b7e4a25e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into the registered submodules, and sync any nested submodules within.</source>
          <target state="translated">如果指定了 &lt;code&gt;--recursive&lt;/code&gt; ，则此命令将递归到已注册的子模块中，并同步其中的任何嵌套子模块。</target>
        </trans-unit>
        <trans-unit id="1ddca2ea8ce5da739445e37cd4a4048560236396" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into the registered submodules, and update any nested submodules within.</source>
          <target state="translated">如果指定了 &lt;code&gt;--recursive&lt;/code&gt; ，则此命令将递归到已注册的子模块中，并更新其中的任何嵌套子模块。</target>
        </trans-unit>
        <trans-unit id="ccfd5529f6d32ddb692a0a0edb24e2ebd0aeb784" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--size-multiple=&amp;lt;X&amp;gt;&lt;/code&gt; is not specified, let &lt;code&gt;X&lt;/code&gt; equal 2. If the new tip file would have &lt;code&gt;N&lt;/code&gt; commits and the previous tip has &lt;code&gt;M&lt;/code&gt; commits and &lt;code&gt;X&lt;/code&gt; times &lt;code&gt;N&lt;/code&gt; is greater than &lt;code&gt;M&lt;/code&gt;, instead merge the two files into a single file.</source>
          <target state="translated">如果未指定 &lt;code&gt;--size-multiple=&amp;lt;X&amp;gt;&lt;/code&gt; ，则使 &lt;code&gt;X&lt;/code&gt; 等于2。如果新提示文件具有 &lt;code&gt;N&lt;/code&gt; 次提交，而前一个提示文件具有 &lt;code&gt;M&lt;/code&gt; 次提交，且 &lt;code&gt;X&lt;/code&gt; 倍 &lt;code&gt;N&lt;/code&gt; 大于 &lt;code&gt;M&lt;/code&gt; ，则将两个文件合并为一个文件。</target>
        </trans-unit>
        <trans-unit id="769d8817aa727ff62e14daf04f7de44e2d479abb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--split=no-merge&lt;/code&gt; is specified, a merge is never performed, and the remaining options are ignored. &lt;code&gt;--split=replace&lt;/code&gt; overwrites the existing chain with a new one. A bare &lt;code&gt;--split&lt;/code&gt; defers to the remaining options. (Note that merging a chain of commit graphs replaces the existing chain with a length-1 chain where the first and only incremental holds the entire graph).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75734f6686dc8bf756f12580f08ccb633b88773" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--stateless-rpc&lt;/code&gt; is specified together with this option then the list of refs must be in packet format (pkt-line). Each ref must be in a separate packet, and the list must end with a flush packet.</source>
          <target state="translated">如果与该选项一起指定了 &lt;code&gt;--stateless-rpc&lt;/code&gt; ,则引用列表必须为数据包格式（pkt行）。每个引用必须位于单独的数据包中，并且列表必须以刷新数据包结尾。</target>
        </trans-unit>
        <trans-unit id="d363c35441978c92ee5ead459023dfd1f9ed35c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--verbose&lt;/code&gt; is specified, the output is a series of lines of the form:</source>
          <target state="translated">如果指定了 &lt;code&gt;--verbose&lt;/code&gt; ，则输出为一系列形式的行：</target>
        </trans-unit>
        <trans-unit id="b441bd31aac4d2437fef46e0587314ace0da5e13" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-B&lt;/code&gt; is given, &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; is created if it doesn&amp;rsquo;t exist; otherwise, it is reset. This is the transactional equivalent of</source>
          <target state="translated">如果给定 &lt;code&gt;-B&lt;/code&gt; ，则创建 &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; ，如果它不存在；否则，将被重置。这是交易的等价物</target>
        </trans-unit>
        <trans-unit id="b749f9938784db5272ac47989617994390a95806" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-N&lt;/code&gt; is specified, removed paths are marked as intent-to-add (see &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;).</source>
          <target state="translated">如果指定了 &lt;code&gt;-N&lt;/code&gt; ，则将删除的路径标记为要添加的意图（请参见&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0d1031ba738c1e4895034c45a671bdfc4feb8ed4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-e&lt;/code&gt; is specified, no output, unless the &amp;lt;object&amp;gt; is malformed.</source>
          <target state="translated">如果指定了 &lt;code&gt;-e&lt;/code&gt; ，则没有输出，除非&amp;lt;object&amp;gt;格式错误。</target>
        </trans-unit>
        <trans-unit id="b39ecbbcbddbe2e5db1df9079f165a4a73917d14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; or &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; is given and &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, and &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; are absent, &lt;code&gt;-a&lt;/code&gt; is implied.</source>
          <target state="translated">如果 &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; 或 &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; 给出和 &lt;code&gt;-a&lt;/code&gt; ， &lt;code&gt;-s&lt;/code&gt; 和 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 不存在， &lt;code&gt;-a&lt;/code&gt; 是隐含的。</target>
        </trans-unit>
        <trans-unit id="c5ab965e580c550a049049c227e584f98537d08f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-m&lt;/code&gt; is specified, &lt;code&gt;git read-tree&lt;/code&gt; can perform 3 kinds of merge, a single tree merge if only 1 tree is given, a fast-forward merge with 2 trees, or a 3-way merge if 3 or more trees are provided.</source>
          <target state="translated">如果指定了 &lt;code&gt;-m&lt;/code&gt; ，则 &lt;code&gt;git read-tree&lt;/code&gt; 可以执行3种合并；如果仅给出1棵树，则可以进行单棵树合并；如果包含2棵树，则可以进行快进合并；如果提供3棵或3棵以上树，则可以进行3路合并。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
