<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="c2dfec9fbb580524d9c87ce7e3303a7b47cc295d" translate="yes" xml:space="preserve">
          <source>This is passed to both underlying git-fetch to squelch reporting of during transfer, and underlying git-merge to squelch output during merging.</source>
          <target state="translated">这将被传递给底层的 git-fetch 来压制传输过程中的报告,以及底层的 git-merge 来压制合并过程中的输出。</target>
        </trans-unit>
        <trans-unit id="3d17e8f742373c8bbf1871e58142a3d3c4b1c09b" translate="yes" xml:space="preserve">
          <source>This is per-repository enhancement / version of global prefix-based &lt;code&gt;@git_base_url_list&lt;/code&gt; gitweb configuration variable (see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;).</source>
          <target state="translated">这是基于存储库的增强功能/基于全局前缀的 &lt;code&gt;@git_base_url_list&lt;/code&gt; gitweb配置变量的版本（请参见&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a7bcc6783fe2c533eb40b84879a83d32f4d95dc9" translate="yes" xml:space="preserve">
          <source>This is similar to --symbolic, but it omits input that are not refs (i.e. branch or tag names; or more explicitly disambiguating &quot;heads/master&quot; form, when you want to name the &quot;master&quot; branch when there is an unfortunately named tag &quot;master&quot;), and show them as full refnames (e.g. &quot;refs/heads/master&quot;).</source>
          <target state="translated">这与 --symbolic 类似,但它省略了不是 refs 的输入(即分支或标记名称;或者更明确地以 &quot;head/master &quot;的形式,当你想命名 &quot;master &quot;分支时,不幸的是有一个命名为 &quot;master &quot;的标记),并将它们显示为完整的 refs 名称(例如 &quot;refs/heads/master&quot;)。</target>
        </trans-unit>
        <trans-unit id="4cae7dda407705febf1be1d8f0d77956238a429a" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;info/grafts&lt;/code&gt; but is internally used and maintained by shallow clone mechanism. See &lt;code&gt;--depth&lt;/code&gt; option to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; and &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;. This file is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/shallow&quot; will be used instead.</source>
          <target state="translated">这类似于 &lt;code&gt;info/grafts&lt;/code&gt; 但在内部由浅克隆机制使用和维护。参见&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;和&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]的&lt;/a&gt; &lt;code&gt;--depth&lt;/code&gt; 选项。如果设置了$ GIT_COMMON_DIR，该文件将被忽略，而将使用&amp;ldquo; $ GIT_COMMON_DIR / shallow&amp;rdquo;代替。</target>
        </trans-unit>
        <trans-unit id="44c5e44a5b0e8e88feba4a9ab4b3411e28cf0521" translate="yes" xml:space="preserve">
          <source>This is similar to the previous mode, but lets you use the interactive interface to show the &quot;diff&quot; output and choose which hunks to use in the result. See below for the description of &lt;code&gt;--patch&lt;/code&gt; option.</source>
          <target state="translated">这与以前的模式相似，但是允许您使用交互式界面显示&amp;ldquo; diff&amp;rdquo;输出并选择要在结果中使用的块。有关 &lt;code&gt;--patch&lt;/code&gt; 选项的说明，请参见下文。</target>
        </trans-unit>
        <trans-unit id="6d4677f97f18bb53a7088b838331f1fec5e57df8" translate="yes" xml:space="preserve">
          <source>This is synonymous to the earlier form (without the &quot;..&quot;) for viewing the changes between two arbitrary &amp;lt;commit&amp;gt;. If &amp;lt;commit&amp;gt; on one side is omitted, it will have the same effect as using HEAD instead.</source>
          <target state="translated">这与以前的形式（不带&amp;ldquo; ..&amp;rdquo;）的同义词相同，后者用于查看两个任意&amp;lt;commit&amp;gt;之间的更改。如果省略了一侧的&amp;lt;commit&amp;gt;，它将具有与使用HEAD相同的效果。</target>
        </trans-unit>
        <trans-unit id="53111542e6130a3092130c1b278f62eb8bf4f3d5" translate="yes" xml:space="preserve">
          <source>This is synonymous to the earlier form (without the &lt;code&gt;..&lt;/code&gt;) for viewing the changes between two arbitrary &amp;lt;commit&amp;gt;. If &amp;lt;commit&amp;gt; on one side is omitted, it will have the same effect as using HEAD instead.</source>
          <target state="translated">这与以前的形式（不带 &lt;code&gt;..&lt;/code&gt; ）同义，用于查看两个任意&amp;lt;commit&amp;gt;之间的更改。如果省略了一侧的&amp;lt;commit&amp;gt;，它将具有与使用HEAD相同的效果。</target>
        </trans-unit>
        <trans-unit id="4054020991b3f63ee43241d99b871a192e5f7888" translate="yes" xml:space="preserve">
          <source>This is synonymous to the previous form. If &amp;lt;commit&amp;gt; on one side is omitted, it will have the same effect as using HEAD instead.</source>
          <target state="translated">这与以前的形式同义。如果省略了一侧的&amp;lt;commit&amp;gt;，它将具有与使用HEAD相同的效果。</target>
        </trans-unit>
        <trans-unit id="75478eb48b06b2098532610f52369c54c5a35766" translate="yes" xml:space="preserve">
          <source>This is the Git native format and is &lt;code&gt;&amp;lt;time&amp;gt; SP &amp;lt;offutc&amp;gt;&lt;/code&gt;. It is also fast-import&amp;rsquo;s default format, if --date-format was not specified.</source>
          <target state="translated">这是Git本机格式，并且是 &lt;code&gt;&amp;lt;time&amp;gt; SP &amp;lt;offutc&amp;gt;&lt;/code&gt; 。如果未指定--date-format，它也是快速导入的默认格式。</target>
        </trans-unit>
        <trans-unit id="6bd79ba5c8340a61cc49527317aae865e2230698" translate="yes" xml:space="preserve">
          <source>This is the filter for performing the commit. If this filter is specified, it will be called instead of the &lt;code&gt;git commit-tree&lt;/code&gt; command, with arguments of the form &quot;&amp;lt;TREE_ID&amp;gt; [(-p &amp;lt;PARENT_COMMIT_ID&amp;gt;)&amp;hellip;​]&quot; and the log message on stdin. The commit id is expected on stdout.</source>
          <target state="translated">这是用于执行提交的过滤器。如果指定了该过滤器，它将被调用，而不是 &lt;code&gt;git commit-tree&lt;/code&gt; 命令，与以下形式的参数&amp;ldquo;&amp;lt;TREE_ID&amp;gt; [（-p &amp;lt;PARENT_COMMIT_ID&amp;gt;）...]&amp;rdquo;和在stdin日志消息。提交ID应该在标准输出上。</target>
        </trans-unit>
        <trans-unit id="ab02ed108f018595c9832dcfce47c6a593278667" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting tag names. When passed, it will be called for every tag ref that points to a rewritten object (or to a tag object which points to a rewritten object). The original tag name is passed via standard input, and the new tag name is expected on standard output.</source>
          <target state="translated">这是重写标签名的过滤器。通过后,它将对指向重写对象(或指向重写对象的标签对象)的每个标签 ref 进行调用。原始的标签名通过标准输入传递,而新的标签名则在标准输出中被期待。</target>
        </trans-unit>
        <trans-unit id="ec46b5cef98509f43f653471ea24de2e709b0b36" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the commit messages. The argument is evaluated in the shell with the original commit message on standard input; its standard output is used as the new commit message.</source>
          <target state="translated">这是用于重写提交信息的过滤器,参数在shell中用标准输入的原始提交信息进行评估,其标准输出作为新的提交信息。参数在shell中以标准输入的原始提交信息进行评估,其标准输出作为新的提交信息。</target>
        </trans-unit>
        <trans-unit id="baaf77805fbcb910ae11f451b39d9e38daaa6669" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the commit&amp;rsquo;s parent list. It will receive the parent string on stdin and shall output the new parent string on stdout. The parent string is in the format described in &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt;: empty for the initial commit, &quot;-p parent&quot; for a normal commit and &quot;-p parent1 -p parent2 -p parent3 &amp;hellip;​&quot; for a merge commit.</source>
          <target state="translated">这是用于重写提交的父列表的过滤器。它将在stdin上接收父字符串，并在stdout上输出新的父字符串。父字符串采用&lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]中&lt;/a&gt;描述的格式：初始提交为空，普通提交为&amp;ldquo; -p父&amp;rdquo;，合并为&amp;ldquo; -p父1 -p父2 -p父3&amp;hellip;&amp;rdquo;。承诺。</target>
        </trans-unit>
        <trans-unit id="ed6796eee1e84719fc79503aec05a2585b0a98ee" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the index. It is similar to the tree filter but does not check out the tree, which makes it much faster. Frequently used with &lt;code&gt;git rm --cached
--ignore-unmatch ...&lt;/code&gt;, see EXAMPLES below. For hairy cases, see &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">这是用于重写索引的过滤器。它类似于树过滤器，但不检出树，这使它更快。经常与 &lt;code&gt;git rm --cached --ignore-unmatch ...&lt;/code&gt; ，请参见下面的示例。对于多毛的情况，请参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84464b13412e29584cb64fc663c003212ddd470c" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the tree and its contents. The argument is evaluated in shell with the working directory set to the root of the checked out tree. The new tree is then used as-is (new files are auto-added, disappeared files are auto-removed - neither .gitignore files nor any other ignore rules &lt;strong&gt;HAVE ANY EFFECT&lt;/strong&gt;!).</source>
          <target state="translated">这是用于重写树及其内容的过滤器。该参数在shell中评估，且工作目录设置为检出树的根。然后新树被原样使用（新文件是自动添加的，消失的文件是自动删除-既不的.gitignore文件，也没有任何其他无视规则&lt;strong&gt;有任何影响&lt;/strong&gt;！）。</target>
        </trans-unit>
        <trans-unit id="ac6e8f6a01875184858c8585102e8f6aa273aee7" translate="yes" xml:space="preserve">
          <source>This is the format defined by the initial version of git, including but not limited to the format of the repository directory, the repository configuration file, and the object and ref storage. Specifying the complete behavior of git is beyond the scope of this document.</source>
          <target state="translated">这是git初始版本所定义的格式,包括但不限于版本库目录、版本库配置文件、对象和ref存储的格式。指定git的完整行为超出了本文档的范围。</target>
        </trans-unit>
        <trans-unit id="53064adeec7c86c12f0de7129be2018180dbdde8" translate="yes" xml:space="preserve">
          <source>This is the instruction format to copy a byte range from the source object. It encodes the offset to copy from and the number of bytes to copy. Offset and size are in little-endian order.</source>
          <target state="translated">这是从源对象中复制一个字节范围的指令格式。它对要复制的偏移量和要复制的字节数进行编码。偏移量和大小按小字节顺序排列。</target>
        </trans-unit>
        <trans-unit id="7c56810b4cb2a212f096564a869dc50ed111eb3c" translate="yes" xml:space="preserve">
          <source>This is the instruction reserved for future expansion.</source>
          <target state="translated">这是为将来的扩展而保留的指令。</target>
        </trans-unit>
        <trans-unit id="2ac15a186ae4c1add6605d649b034295db99bef1" translate="yes" xml:space="preserve">
          <source>This is the instruction to construct target object without the base object. The following data is appended to the target object. The first seven bits of the first octet determines the size of data in bytes. The size must be non-zero.</source>
          <target state="translated">这是在没有基础对象的情况下构造目标对象的指令。在目标对象中附加以下数据。第一个八位组的前七位决定数据的大小,单位是字节。大小必须为非零。</target>
        </trans-unit>
        <trans-unit id="109ca8035c1b87bb820c08a28a9de7b34fde1bb6" translate="yes" xml:space="preserve">
          <source>This is the opposite of &lt;code&gt;ours&lt;/code&gt;; note that, unlike &lt;code&gt;ours&lt;/code&gt;, there is no &lt;code&gt;theirs&lt;/code&gt; merge strategy to confuse this merge option with.</source>
          <target state="translated">这与 &lt;code&gt;ours&lt;/code&gt; 相反; 请注意，与 &lt;code&gt;ours&lt;/code&gt; 不同，没有 &lt;code&gt;theirs&lt;/code&gt; 合并策略可以混淆此合并选项。</target>
        </trans-unit>
        <trans-unit id="a470bc42a7932d13fef06a087064186d12eef547" translate="yes" xml:space="preserve">
          <source>This is the preferred method.</source>
          <target state="translated">这是首选的方法。</target>
        </trans-unit>
        <trans-unit id="d5ae5cf60359e7831f40d915d7567f63dc115a19" translate="yes" xml:space="preserve">
          <source>This is the same &lt;code&gt;git read-tree&lt;/code&gt; command we have already seen, but it takes three trees, unlike previous examples. This reads the contents of each tree into different &lt;code&gt;stage&lt;/code&gt; in the index file (the first tree goes to stage 1, the second to stage 2, etc.). After reading three trees into three stages, the paths that are the same in all three stages are &lt;code&gt;collapsed&lt;/code&gt; into stage 0. Also paths that are the same in two of three stages are collapsed into stage 0, taking the SHA-1 from either stage 2 or stage 3, whichever is different from stage 1 (i.e. only one side changed from the common ancestor).</source>
          <target state="translated">这是我们已经看到的相同的 &lt;code&gt;git read-tree&lt;/code&gt; 命令，但是它需要三棵树，这与前面的示例不同。这会将每个树的内容读入索引文件中的不同 &lt;code&gt;stage&lt;/code&gt; （第一棵树进入阶段1，第二棵树进入阶段2，依此类推）。将三棵树分为三个阶段后，在所有三个阶段中都相同的路径将 &lt;code&gt;collapsed&lt;/code&gt; 到阶段0中。还将在三个阶段中的两个阶段中相同的路径折叠到阶段0中，并从任一阶段2中获取SHA-1或第3阶段，与第1阶段中的任何一个都不相同（即，从共同祖先开始只改变了一侧）。</target>
        </trans-unit>
        <trans-unit id="d9a78198f4c718b4aad0f141375d5823cd8e39e3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;gitdir&lt;/code&gt; except that matching is done case-insensitively (e.g. on case-insensitive file systems)</source>
          <target state="translated">这与 &lt;code&gt;gitdir&lt;/code&gt; 相同，除了匹配不区分大小写（例如，不区分大小写的文件系统）</target>
        </trans-unit>
        <trans-unit id="6d8ef8c3ff85a1d3362ff60dea809d4867db08e2" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;raw&lt;/code&gt; except that no sanity checks on the numeric epoch and local offset are performed. This can be useful when trying to filter or import an existing history with e.g. bogus timezone values.</source>
          <target state="translated">除了不对数字纪元和本地偏移量执行完整性检查外，这与 &lt;code&gt;raw&lt;/code&gt; 相同。当尝试使用虚假的时区值过滤或导入现有历史记录时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="3d8eaa3e252f616f4794342341d2f4ec065a52c7" translate="yes" xml:space="preserve">
          <source>This is the standard email format as described by RFC 2822.</source>
          <target state="translated">这是RFC 2822所描述的标准电子邮件格式。</target>
        </trans-unit>
        <trans-unit id="b1825adadaae31865a7ba56f02eeaa58bb1a595e" translate="yes" xml:space="preserve">
          <source>This is the standard helper program to use with &lt;code&gt;git merge-index&lt;/code&gt; to resolve a merge after the trivial merge done with &lt;code&gt;git read-tree -m&lt;/code&gt;.</source>
          <target state="translated">这是与 &lt;code&gt;git merge-index&lt;/code&gt; 一起使用的标准帮助程序，用于在使用 &lt;code&gt;git read-tree -m&lt;/code&gt; 进行微不足道的合并后解决合并。</target>
        </trans-unit>
        <trans-unit id="f4605ef17a6ae238fb7ad1359ce2fc3809a170d2" translate="yes" xml:space="preserve">
          <source>This is the state of the index file and the working file after &lt;code&gt;git merge&lt;/code&gt; returns control back to you, leaving the conflicting merge for you to resolve. Notice that the path &lt;code&gt;hello&lt;/code&gt; is still unmerged, and what you see with &lt;code&gt;git diff&lt;/code&gt; at this point is differences since stage 2 (i.e. your version).</source>
          <target state="translated">这是 &lt;code&gt;git merge&lt;/code&gt; 将控制权交还给您后，索引文件和工作文件的状态，将冲突的合并留给您解决。请注意，路径 &lt;code&gt;hello&lt;/code&gt; 仍未合并，此时您在 &lt;code&gt;git diff&lt;/code&gt; 上看到的是第二阶段以来的差异（即您的版本）。</target>
        </trans-unit>
        <trans-unit id="885013fc19184ff3f87757857452f6badc7e664c" translate="yes" xml:space="preserve">
          <source>This is to emulate &lt;code&gt;git fetch&lt;/code&gt; run on the &lt;code&gt;mothership&lt;/code&gt; using &lt;code&gt;git
push&lt;/code&gt; that is run in the opposite direction in order to integrate the work done on &lt;code&gt;satellite&lt;/code&gt;, and is often necessary when you can only make connection in one way (i.e. satellite can ssh into mothership but mothership cannot initiate connection to satellite because the latter is behind a firewall or does not run sshd).</source>
          <target state="translated">这是为了使用相反方向运行的 &lt;code&gt;git push&lt;/code&gt; 模拟在 &lt;code&gt;mothership&lt;/code&gt; 上运行的 &lt;code&gt;git fetch&lt;/code&gt; ，以便集成在 &lt;code&gt;satellite&lt;/code&gt; 完成的工作，并且在您只能以一种方式建立连接时（例如，人造卫星可以ssh进入母舰）通常是必需的但母权关系无法启动与卫星的连接，因为后者位于防火墙后面或未运行sshd）。</target>
        </trans-unit>
        <trans-unit id="a0fbffa526980249cc459b3697ae082d2fb16d12" translate="yes" xml:space="preserve">
          <source>This is to view the changes between two arbitrary &amp;lt;commit&amp;gt;.</source>
          <target state="translated">这是为了查看两个任意&amp;lt;commit&amp;gt;之间的更改。</target>
        </trans-unit>
        <trans-unit id="2ccd3734f230a6bccf87e0841ef19acfd1763ec7" translate="yes" xml:space="preserve">
          <source>This is used if &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; does not resolve the correct &lt;code&gt;-kb&lt;/code&gt; mode to use. If true, all unresolved files are sent to the client in mode &lt;code&gt;-kb&lt;/code&gt;. This causes the client to treat them as binary files, which suppresses any newline munging it otherwise might do. Alternatively, if it is set to &quot;guess&quot;, then the contents of the file are examined to decide if it is binary, similar to &lt;code&gt;core.autocrlf&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 无法解析要使用的正确 &lt;code&gt;-kb&lt;/code&gt; 模式，则使用此方法。如果为true，则所有未解析的文件都以 &lt;code&gt;-kb&lt;/code&gt; 模式发送到客户端。这导致客户端将它们视为二进制文件，从而抑制了换行符，否则可能会造成麻烦。或者，如果将其设置为&amp;ldquo; guess&amp;rdquo;，则类似于 &lt;code&gt;core.autocrlf&lt;/code&gt; ，将检查文件的内容以确定它是否为二进制。</target>
        </trans-unit>
        <trans-unit id="414b7e001678a67515e35206eca5b23ff617a9b6" translate="yes" xml:space="preserve">
          <source>This is used to avoid unnecessary false hits when &lt;code&gt;git diff-files&lt;/code&gt; is run after &lt;code&gt;git read-tree&lt;/code&gt;.</source>
          <target state="translated">这用于避免在 &lt;code&gt;git read-tree&lt;/code&gt; 之后运行 &lt;code&gt;git diff-files&lt;/code&gt; 时产生不必要的错误命中。</target>
        </trans-unit>
        <trans-unit id="1756049aad8be96bbdbe029ae5b31f810c9534b0" translate="yes" xml:space="preserve">
          <source>This is used to imply --all-progress whenever progress display is activated. Unlike --all-progress this flag doesn&amp;rsquo;t actually force any progress display by itself.</source>
          <target state="translated">每当激活进度显示时，它用于表示--all-progress。与--all-progress不同，此标志实际上并不强制自己显示任何进度。</target>
        </trans-unit>
        <trans-unit id="fa389947911fb92b7cae5947eac62679e5095362" translate="yes" xml:space="preserve">
          <source>This is used to reorder the filepairs according to the user&amp;rsquo;s (or project&amp;rsquo;s) taste, and is controlled by the -O option to the &lt;code&gt;git diff-*&lt;/code&gt; commands.</source>
          <target state="translated">这用于根据用户（或项目）的喜好对文件对重新排序，并由 &lt;code&gt;git diff-*&lt;/code&gt; 命令的-O选项控制。</target>
        </trans-unit>
        <trans-unit id="e4698ff07eb1e8e63a5c87a4e409437aeb77e0b4" translate="yes" xml:space="preserve">
          <source>This is useful because it makes it easy to choose a good commit to test when you want to avoid to test some of them for some reason (they may not compile for example).</source>
          <target state="translated">这很有用,因为当你因为某些原因(例如,它们可能无法编译)而想避免测试某些提交时,可以很容易地选择一个好的提交进行测试。</target>
        </trans-unit>
        <trans-unit id="8b37ac2c46d9c49011957ba8051eb182f97c074f" translate="yes" xml:space="preserve">
          <source>This is useful if F and G were flawed in some way, or should not be part of topicA. Note that the argument to --onto and the &amp;lt;upstream&amp;gt; parameter can be any valid commit-ish.</source>
          <target state="translated">如果F和G以某种方式存在缺陷，或者不应该成为topicA的一部分，则这很有用。请注意，--onto的参数和&amp;lt;upstream&amp;gt;参数可以是任何有效的commit-ish。</target>
        </trans-unit>
        <trans-unit id="5add7a300e88f092e0ef1b21363222f3ece44ad7" translate="yes" xml:space="preserve">
          <source>This is useful if remote side is git:// server accessed over some tunnel.</source>
          <target state="translated">如果远端是通过某个隧道访问的git://服务器,这很有用。</target>
        </trans-unit>
        <trans-unit id="d562e00428aacff2db14167eb0ecbc7ee7ea6370" translate="yes" xml:space="preserve">
          <source>This is useful if the branch on which you ran &lt;code&gt;git stash push&lt;/code&gt; has changed enough that &lt;code&gt;git stash apply&lt;/code&gt; fails due to conflicts. Since the stash entry is applied on top of the commit that was HEAD at the time &lt;code&gt;git stash&lt;/code&gt; was run, it restores the originally stashed state with no conflicts.</source>
          <target state="translated">如果您在其上运行 &lt;code&gt;git stash push&lt;/code&gt; 的分支已更改得足够多，以至于 &lt;code&gt;git stash apply&lt;/code&gt; 由于冲突而失败，这将很有用。由于存储条目是在运行 &lt;code&gt;git stash&lt;/code&gt; 时是HEAD的提交之上应用的，因此它可以恢复原始存储状态，而不会发生冲突。</target>
        </trans-unit>
        <trans-unit id="30fcffaf45041b08cc97af9d1fa76a9ba0b33fa3" translate="yes" xml:space="preserve">
          <source>This is useful if you want to begin your message in a discussion thread with comments and suggestions on the message you are responding to, and to conclude it with a patch submission, separating the discussion and the beginning of the proposed commit log message with a scissors line.</source>
          <target state="translated">如果您想在讨论线程中以评论和建议开始您的消息,并以提交补丁结束,用剪刀线隔开讨论和提交日志消息的开头,这很有用。</target>
        </trans-unit>
        <trans-unit id="f93051fa336df47ab5f519702120e3efac9cd277" translate="yes" xml:space="preserve">
          <source>This is useful on systems where lstat() calls are very slow, such as CIFS/Microsoft Windows.</source>
          <target state="translated">这对那些调用lstat()很慢的系统很有用,比如CIFS/Microsoft Windows。</target>
        </trans-unit>
        <trans-unit id="6b9439a13a0f6c5a19da94d77f92d4a1ee7e5be6" translate="yes" xml:space="preserve">
          <source>This is useful when cherry-picking more than one commits' effect to your index in a row.</source>
          <target state="translated">当在一行中挑选多个提交的效果时,这很有用。</target>
        </trans-unit>
        <trans-unit id="ccb566ca825959d19feaead9d9434de1315351a7" translate="yes" xml:space="preserve">
          <source>This is useful when reverting more than one commits' effect to your index in a row.</source>
          <target state="translated">这在恢复一行中多个提交的效果时很有用。</target>
        </trans-unit>
        <trans-unit id="a6b3b2938023c6383383af34a5efd6428edcf530" translate="yes" xml:space="preserve">
          <source>This is useful when topicB does not depend on topicA.</source>
          <target state="translated">当话题B不依赖于话题A时,这很有用。</target>
        </trans-unit>
        <trans-unit id="804a7dc8302db74d34102cb378738f0047ef1777" translate="yes" xml:space="preserve">
          <source>This is usually not what an end user wants to run directly. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; instead.</source>
          <target state="translated">最终用户通常不想直接运行它。参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81deedcd021f1608f9f91f70a15e2349e22a39d7" translate="yes" xml:space="preserve">
          <source>This is what &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; generates. Most headers and MIME formatting are ignored.</source>
          <target state="translated">这就是&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;生成的。大多数标题和MIME格式都将被忽略。</target>
        </trans-unit>
        <trans-unit id="ca6a5c0a1684e36bc50c3e68cfccb9e6ebf59a4b" translate="yes" xml:space="preserve">
          <source>This is what causes Git to track the remote&amp;rsquo;s branches; you may modify or delete these configuration options by editing &lt;code&gt;.git/config&lt;/code&gt; with a text editor. (See the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.)</source>
          <target state="translated">这就是导致Git跟踪远程分支的原因。您可以通过使用文本编辑器编辑 &lt;code&gt;.git/config&lt;/code&gt; 来修改或删除这些配置选项。（有关详细信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;的&amp;ldquo; CONFIGURATION FILE&amp;rdquo;部分。）</target>
        </trans-unit>
        <trans-unit id="e49010e0ec73f433e7f19c2db7cbfd7081066732" translate="yes" xml:space="preserve">
          <source>This is why it is a bad idea to just chose the next best unskipped bisection commit when the first one has been skipped.</source>
          <target state="translated">这就是为什么当第一个跳过的时候,只选择下一个最好的未跳过的二段提交是个坏主意。</target>
        </trans-unit>
        <trans-unit id="b49b41d6b66c63a0b41c3cd8eb53b02ecb1e28e6" translate="yes" xml:space="preserve">
          <source>This leaves a copy of &lt;code&gt;next&lt;/code&gt; temporarily in FETCH_HEAD, and updates the remote-tracking branch &lt;code&gt;origin/next&lt;/code&gt;. The same can be done by invoking fetch and merge:</source>
          <target state="translated">这会在FETCH_HEAD中暂时保留 &lt;code&gt;next&lt;/code&gt; 的副本，并更新远程跟踪分支 &lt;code&gt;origin/next&lt;/code&gt; 。可以通过调用fetch和merge来完成相同的操作：</target>
        </trans-unit>
        <trans-unit id="51722bee7db4c41cee14b92ba092db0dce132718" translate="yes" xml:space="preserve">
          <source>This leaves a copy of &lt;code&gt;next&lt;/code&gt; temporarily in FETCH_HEAD, but does not update any remote-tracking branches. Using remote-tracking branches, the same can be done by invoking fetch and merge:</source>
          <target state="translated">这会在FETCH_HEAD中暂时保留 &lt;code&gt;next&lt;/code&gt; 的副本，但不会更新任何远程跟踪分支。使用远程跟踪分支，可以通过调用访存和合并来完成相同的工作：</target>
        </trans-unit>
        <trans-unit id="8d3c273456c213d2f0eef245650834ea18d26a16" translate="yes" xml:space="preserve">
          <source>This lets you choose one path out of a &lt;code&gt;status&lt;/code&gt; like selection. After choosing the path, it presents the diff between the index and the working tree file and asks you if you want to stage the change of each hunk. You can select one of the following options and type return:</source>
          <target state="translated">这使您可以从选择之类的 &lt;code&gt;status&lt;/code&gt; 选择一条路径。选择路径后，它将显示索引和工作树文件之间的差异，并询问您是否要暂存每个块的更改。您可以选择以下选项之一，然后键入return：</target>
        </trans-unit>
        <trans-unit id="060b46ed6fd409fbf360157d2f3c13ff3dcd2220" translate="yes" xml:space="preserve">
          <source>This lets you quit without do cleaning.</source>
          <target state="translated">这让你不需要做清洁就可以退出。</target>
        </trans-unit>
        <trans-unit id="aa41c7db3702739cc1b230bda0b83b675d7b2671" translate="yes" xml:space="preserve">
          <source>This lets you review what will be committed (i.e. between HEAD and index).</source>
          <target state="translated">这可以让你审查将被提交的内容(即HEAD和索引之间)。</target>
        </trans-unit>
        <trans-unit id="ca3fd0a1256c2900c49910f1d037599eb216d4ff" translate="yes" xml:space="preserve">
          <source>This list should contain the URI of gitweb&amp;rsquo;s standard stylesheet. The default URI of gitweb stylesheet can be set at build time using the &lt;code&gt;GITWEB_CSS&lt;/code&gt; makefile variable. Its default value is &lt;code&gt;static/gitweb.css&lt;/code&gt; (or &lt;code&gt;static/gitweb.min.css&lt;/code&gt; if the &lt;code&gt;CSSMIN&lt;/code&gt; variable is defined, i.e. if CSS minifier is used during build).</source>
          <target state="translated">该列表应包含gitweb标准样式表的URI。可以在构建时使用 &lt;code&gt;GITWEB_CSS&lt;/code&gt; makefile变量设置gitweb样式表的默认URI 。其默认值为 &lt;code&gt;static/gitweb.css&lt;/code&gt; （如果定义了 &lt;code&gt;CSSMIN&lt;/code&gt; 变量，则为 &lt;code&gt;static/gitweb.min.css&lt;/code&gt; ，即，如果在构建过程中使用了CSS minifier）。</target>
        </trans-unit>
        <trans-unit id="87db555786bcad0bd342abfeced795a76cdcb852" translate="yes" xml:space="preserve">
          <source>This lists the commits reachable from the previous version of the &lt;code&gt;master&lt;/code&gt; branch head. This syntax can be used with any Git command that accepts a commit, not just with &lt;code&gt;git log&lt;/code&gt;. Some other examples:</source>
          <target state="translated">这列出了从 &lt;code&gt;master&lt;/code&gt; 分支头的先前版本可到达的提交。此语法可以与任何接受提交的Git命令一起使用，而不仅限于 &lt;code&gt;git log&lt;/code&gt; 。其他一些例子：</target>
        </trans-unit>
        <trans-unit id="9d19ff56a7106ea2437dd5210773dc60fd2828eb" translate="yes" xml:space="preserve">
          <source>This looks up the &amp;lt;file&amp;gt;(s) in the index and, if there are any merge entries, passes the SHA-1 hash for those files as arguments 1, 2, 3 (empty argument if no file), and &amp;lt;file&amp;gt; as argument 4. File modes for the three files are passed as arguments 5, 6 and 7.</source>
          <target state="translated">这将在索引中查找&amp;lt;file&amp;gt;，如果有任何合并条目，则将这些文件的SHA-1散列作为参数1、2、3（如果没有文件，则为空参数）和&amp;lt;file&amp;gt;作为参数4。三个文件的文件模式作为参数5、6和7传递。</target>
        </trans-unit>
        <trans-unit id="6790f45ac4b6ed7e77775e3a5dfba68fc876105d" translate="yes" xml:space="preserve">
          <source>This makes a commit that records the modification to &lt;code&gt;Makefile&lt;/code&gt;. The changes staged for &lt;code&gt;hello.c&lt;/code&gt; and &lt;code&gt;hello.h&lt;/code&gt; are not included in the resulting commit. However, their changes are not lost &amp;mdash; they are still staged and merely held back. After the above sequence, if you do:</source>
          <target state="translated">这将记录对 &lt;code&gt;Makefile&lt;/code&gt; 的修改的提交。针对 &lt;code&gt;hello.c&lt;/code&gt; 和 &lt;code&gt;hello.h&lt;/code&gt; 进行的更改未包含在结果提交中。但是，它们的更改不会丢失-它们仍会上演，只是受阻。在上述顺序之后，如果您这样做：</target>
        </trans-unit>
        <trans-unit id="c23316330a20f8d3e00d74e273bc6ee3d02efbd7" translate="yes" xml:space="preserve">
          <source>This makes a new branch called &lt;code&gt;other&lt;/code&gt; from &lt;code&gt;master~5..master&lt;/code&gt; (i.e. if &lt;code&gt;master&lt;/code&gt; has linear history, it will take the last 5 commits).</source>
          <target state="translated">这使得所谓的新分支 &lt;code&gt;other&lt;/code&gt; 从 &lt;code&gt;master~5..master&lt;/code&gt; （即，如果 &lt;code&gt;master&lt;/code&gt; 有线性的历史，它将采取的最后5次提交）。</target>
        </trans-unit>
        <trans-unit id="b0ade35fb815795f98a8b6354752858acd9e1cfa" translate="yes" xml:space="preserve">
          <source>This makes sure that only the key/value pair for kernel.org is replaced.</source>
          <target state="translated">这将确保只有kernel.org的key/value对被替换。</target>
        </trans-unit>
        <trans-unit id="2d726c732ca5f310160366fecc16a8d1ede4f94c" translate="yes" xml:space="preserve">
          <source>This manual describes the convention used throughout Git CLI.</source>
          <target state="translated">本手册介绍了Git CLI中使用的惯例。</target>
        </trans-unit>
        <trans-unit id="40982f6c18ca56554ec412b18ace4f012d6c51fa" translate="yes" xml:space="preserve">
          <source>This manual is designed to be readable by someone with basic UNIX command-line skills, but no previous knowledge of Git.</source>
          <target state="translated">本手册的设计目的是为了让具有基本 UNIX 命令行技能,但没有 Git 知识的人也能阅读。</target>
        </trans-unit>
        <trans-unit id="1b4c4400f56ace6af78ca50c928fe7f5cfe13be6" translate="yes" xml:space="preserve">
          <source>This manual page describes only the most frequently used options.</source>
          <target state="translated">本手册页面只介绍最常用的选项。</target>
        </trans-unit>
        <trans-unit id="c74c8f67468f674a4bbb6cadbdb326520214aafb" translate="yes" xml:space="preserve">
          <source>This manual page describes only the most frequently used options. See &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; for a complete list.</source>
          <target state="translated">本手册页仅介绍最常用的选项。有关完整列表，请参见&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78fbc8bf0be13ddc4f9bce27ee4dc19783022a2b" translate="yes" xml:space="preserve">
          <source>This means &quot;show everything that is reachable from either one, but exclude anything that is reachable from both of them&quot;.</source>
          <target state="translated">这意味着 &quot;显示所有从任何一个地方可以到达的东西,但排除所有从两个地方都可以到达的东西&quot;。</target>
        </trans-unit>
        <trans-unit id="9f4c07f14694007bf95dcdb96bbfc3991db01ef3" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; is the opposite of &lt;code&gt;git add
&amp;lt;pathspec&amp;gt;&lt;/code&gt;. This command is equivalent to &lt;code&gt;git restore [--source=&amp;lt;tree-ish&amp;gt;] --staged &amp;lt;pathspec&amp;gt;...&lt;/code&gt;.</source>
          <target state="translated">这意味着 &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; 与 &lt;code&gt;git add &amp;lt;pathspec&amp;gt;&lt;/code&gt; 相反。此命令等同于 &lt;code&gt;git restore [--source=&amp;lt;tree-ish&amp;gt;] --staged &amp;lt;pathspec&amp;gt;...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="138908f8222de2b4daf75b57b97dc896b1845167" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;git reset -p&lt;/code&gt; is the opposite of &lt;code&gt;git add -p&lt;/code&gt;, i.e. you can use it to selectively reset hunks. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">这意味着 &lt;code&gt;git reset -p&lt;/code&gt; 与 &lt;code&gt;git add -p&lt;/code&gt; 相反，即，您可以使用它选择性地重置块。请参阅&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;的&amp;ldquo;交互模式&amp;rdquo;部分，以了解如何操作 &lt;code&gt;--patch&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="9c231d7cedbd657513f91f60869397c2bef2f37d" translate="yes" xml:space="preserve">
          <source>This means that it is often &quot;cheaper&quot; if QA people or end users can do it.</source>
          <target state="translated">这意味着,如果QA人员或终端用户能够做到这一点,往往会 &quot;更便宜&quot;。</target>
        </trans-unit>
        <trans-unit id="0ff1dc064f7e1f4d0872498ac05a21ade168adc9" translate="yes" xml:space="preserve">
          <source>This means that test suites are good to prevent some bugs from being committed and they are also quite good to tell you that you have some bugs. But they are not so good to tell you where some bugs have been introduced. To tell you that efficiently, git bisect is needed.</source>
          <target state="translated">这意味着,测试套件很好地防止了一些bug的发生,它们也很好地告诉你你有一些bug。但它们并不能很好地告诉你哪里引入了一些bug。为了有效地告诉你这些,需要使用git bisect。</target>
        </trans-unit>
        <trans-unit id="388b9571e5f1264e3be3a08ce2827efedebdef31" translate="yes" xml:space="preserve">
          <source>This means that the best bisection commits are the commits where the following function is maximum:</source>
          <target state="translated">这意味着,最好的二分提交是以下函数最大的提交。</target>
        </trans-unit>
        <trans-unit id="597961da0012b9cd684792dccd1c7471e5687e9f" translate="yes" xml:space="preserve">
          <source>This means that the trimmed &amp;lt;token&amp;gt; and &amp;lt;value&amp;gt; will be separated by &lt;code&gt;': '&lt;/code&gt; (one colon followed by one space).</source>
          <target state="translated">这意味着修剪的&amp;lt;token&amp;gt;和&amp;lt;value&amp;gt;将由 &lt;code&gt;': '&lt;/code&gt; 分隔（一个冒号后跟一个空格）。</target>
        </trans-unit>
        <trans-unit id="38ea5711a664516b71bd0eeea932fd8ac8d7c412" translate="yes" xml:space="preserve">
          <source>This means that we get rid of the uninteresting commits in the DAG.</source>
          <target state="translated">这意味着,我们要把DAG中不感兴趣的提交内容去掉。</target>
        </trans-unit>
        <trans-unit id="2454a8b57cbe01726a67b284a671cd468ecfe3a7" translate="yes" xml:space="preserve">
          <source>This means that you can do</source>
          <target state="translated">这意味着,你可以做</target>
        </trans-unit>
        <trans-unit id="4bfb7f09c9f4811c3630d40fb2caf5f3310e564e" translate="yes" xml:space="preserve">
          <source>This means that you can use &lt;code&gt;git checkout -p&lt;/code&gt; to selectively discard edits from your current working tree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">这意味着您可以使用 &lt;code&gt;git checkout -p&lt;/code&gt; 从当前工作树中有选择地放弃编辑。请参阅&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;的&amp;ldquo;交互模式&amp;rdquo;部分，以了解如何操作 &lt;code&gt;--patch&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="2db1fd51873ef2a0afca87fc61387f5a8891e2a5" translate="yes" xml:space="preserve">
          <source>This merges the changes from Bob&amp;rsquo;s &quot;master&quot; branch into Alice&amp;rsquo;s current branch. If Alice has made her own changes in the meantime, then she may need to manually fix any conflicts.</source>
          <target state="translated">这会将Bob的&amp;ldquo; master&amp;rdquo;分支中的更改合并到Alice的当前分支中。如果爱丽丝在此期间进行了自己的更改，则她可能需要手动解决所有冲突。</target>
        </trans-unit>
        <trans-unit id="cff3569519105ed116111cf73b4d626e89a75fc2" translate="yes" xml:space="preserve">
          <source>This merges the file listing in the directory cache index with the actual working directory list, and shows different combinations of the two.</source>
          <target state="translated">这将目录缓存索引中的文件列表与实际工作目录列表合并,并显示两者的不同组合。</target>
        </trans-unit>
        <trans-unit id="e550f0e6cba8953c27a9638529775caa0627f8ed" translate="yes" xml:space="preserve">
          <source>This might not be what you expect, i.e. you want to prune remote &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, but also explicitly fetch tags from it, so when you fetch from it you delete all your local tags, most of which may not have come from the &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; remote in the first place.</source>
          <target state="translated">这可能不是您所期望的，即您想修剪远程 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; ，但也要从中明确获取标签，因此，从中获取时，您将删除所有本地标签，其中大多数可能不是来自 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 首先是远程。</target>
        </trans-unit>
        <trans-unit id="c165a1bf0e23a30271149315bd9959512cec8cbc" translate="yes" xml:space="preserve">
          <source>This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get</source>
          <target state="translated">这种模式与默认模式有一点不同:始终遵循合并的所有父节点,即使对其中一方是TREESAME。即使合并中不止一方有提交的内容,也不意味着合并本身就是这样的! 在这个例子中,我们得到</target>
        </trans-unit>
        <trans-unit id="06118fd3f101fa40f7bcb707d4305013c9a74e7d" translate="yes" xml:space="preserve">
          <source>This mode has become the default in Git 2.0.</source>
          <target state="translated">这个模式在 Git 2.0 中已经成为默认模式。</target>
        </trans-unit>
        <trans-unit id="9c35450959e8c97cb733c60205966cdb68e529c7" translate="yes" xml:space="preserve">
          <source>This mode is designed for repositories with very large indexes, and aims at reducing the time it takes to repeatedly write these indexes.</source>
          <target state="translated">这种模式是为具有非常大的索引的存储库设计的,目的是减少重复编写这些索引的时间。</target>
        </trans-unit>
        <trans-unit id="660380648a3de0733323135a33a60c0126cae6f8" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to dump the internal marks table to &amp;lt;file&amp;gt; when complete. For details, read up on &lt;code&gt;--export-marks=&amp;lt;file&amp;gt;&lt;/code&gt; in &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;.</source>
          <target state="translated">这将修改 &lt;code&gt;export&lt;/code&gt; 功能，指示Git完成后将内部标记表转储到&amp;lt;file&amp;gt;。有关详细信息，关于读向上 &lt;code&gt;--export-marks=&amp;lt;file&amp;gt;&lt;/code&gt; 在&lt;a href=&quot;git-fast-export&quot;&gt;GIT中快速出口[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="59a5d5693433000c28979c8002984ee295ddd735" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to load the marks specified in &amp;lt;file&amp;gt; before processing any input. For details, read up on &lt;code&gt;--import-marks=&amp;lt;file&amp;gt;&lt;/code&gt; in &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;.</source>
          <target state="translated">这修改了 &lt;code&gt;export&lt;/code&gt; 功能，指示Git在处理任何输入之前加载&amp;lt;file&amp;gt;中指定的标记。有关详细信息，关于读向上 &lt;code&gt;--import-marks=&amp;lt;file&amp;gt;&lt;/code&gt; 在&lt;a href=&quot;git-fast-export&quot;&gt;GIT中快速出口[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29cca50076d9ab0c1672949be9f5cf285333ce65" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to pass &lt;code&gt;--signed-tags=verbatim&lt;/code&gt; to &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;. In the absence of this capability, Git will use &lt;code&gt;--signed-tags=warn-strip&lt;/code&gt;.</source>
          <target state="translated">这修改了 &lt;code&gt;export&lt;/code&gt; 功能，指示Git将 &lt;code&gt;--signed-tags=verbatim&lt;/code&gt; 传递给&lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export [1]&lt;/a&gt;。如果没有此功能，Git将使用 &lt;code&gt;--signed-tags=warn-strip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cd76e4b36f80f26235450d81c7340212de49a9e" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;import&lt;/code&gt; capability. The fast-import commands &lt;code&gt;cat-blob&lt;/code&gt; and &lt;code&gt;ls&lt;/code&gt; can be used by remote-helpers to retrieve information about blobs and trees that already exist in fast-import&amp;rsquo;s memory. This requires a channel from fast-import to the remote-helper. If it is advertised in addition to &quot;import&quot;, Git establishes a pipe from fast-import to the remote-helper&amp;rsquo;s stdin. It follows that Git and fast-import are both connected to the remote-helper&amp;rsquo;s stdin. Because Git can send multiple commands to the remote-helper it is required that helpers that use &lt;code&gt;bidi-import&lt;/code&gt; buffer all &lt;code&gt;import&lt;/code&gt; commands of a batch before sending data to fast-import. This is to prevent mixing commands and fast-import responses on the helper&amp;rsquo;s stdin.</source>
          <target state="translated">这将修改 &lt;code&gt;import&lt;/code&gt; 功能。远程帮助人员可以使用快速导入命令 &lt;code&gt;cat-blob&lt;/code&gt; 和 &lt;code&gt;ls&lt;/code&gt; 来检索有关快速导入内存中已经存在的blob和树的信息。这需要从快速导入到远程帮助者的通道。如果除了&amp;ldquo; import&amp;rdquo;以外还进行广告宣传，Git会建立一条从快速导入到远程帮助程序的stdin的管道。因此，Git和快速导入都连接到了远程帮助程序的stdin。因为Git可以向远程帮助程序发送多个命令，所以要求使用 &lt;code&gt;bidi-import&lt;/code&gt; 的帮助程序缓冲所有 &lt;code&gt;import&lt;/code&gt; 将数据发送到快速导入之前的批处理命令。这是为了防止在助手的stdin上混合命令和快速导入响应。</target>
        </trans-unit>
        <trans-unit id="18b230f7b58b67f5f52143b1696b5514cecb3bd1" translate="yes" xml:space="preserve">
          <source>This operation is safe even if Alice has uncommitted local changes. The range notation &quot;HEAD..FETCH_HEAD&quot; means &quot;show everything that is reachable from the FETCH_HEAD but exclude anything that is reachable from HEAD&quot;. Alice already knows everything that leads to her current state (HEAD), and reviews what Bob has in his state (FETCH_HEAD) that she has not seen with this command.</source>
          <target state="translated">即使Alice有未提交的本地变更,这个操作也是安全的。范围符号 &quot;HEAD...FETCH_HEAD &quot;的意思是 &quot;显示所有从FETCH_HEAD可以到达的东西,但排除任何从HEAD可以到达的东西&quot;。爱丽丝已经知道了所有通向她当前状态(HEAD)的东西,并回顾了Bob在他的状态(FETCH_HEAD)中有哪些她没有看到的东西,用这个命令。</target>
        </trans-unit>
        <trans-unit id="4d6058894e90e81912f089323abaddf6ff7286d2" translate="yes" xml:space="preserve">
          <source>This option affects options that expect path name like &lt;code&gt;--git-dir&lt;/code&gt; and &lt;code&gt;--work-tree&lt;/code&gt; in that their interpretations of the path names would be made relative to the working directory caused by the &lt;code&gt;-C&lt;/code&gt; option. For example the following invocations are equivalent:</source>
          <target state="translated">此选项会影响期望路径名称的选项，例如 &lt;code&gt;--git-dir&lt;/code&gt; 和 &lt;code&gt;--work-tree&lt;/code&gt; ，因为它们对路径名称的解释将相对于 &lt;code&gt;-C&lt;/code&gt; 选项引起的工作目录进行。例如，以下调用是等效的：</target>
        </trans-unit>
        <trans-unit id="2b42f3dc9742d00737d912066dfd2008f4af0874" translate="yes" xml:space="preserve">
          <source>This option allows you to say that you expect the history you are updating is what you rebased and want to replace. If the remote ref still points at the commit you specified, you can be sure that no other people did anything to the ref. It is like taking a &quot;lease&quot; on the ref without explicitly locking it, and the remote ref is updated only if the &quot;lease&quot; is still valid.</source>
          <target state="translated">这个选项允许你说你希望更新的历史记录是你重写的,并且要替换。如果远程 ref 仍然指向你指定的提交,你可以确定没有其他人对 ref 做过任何事情。这就像在没有明确锁定的情况下对 ref 进行了 &quot;租赁&quot;,只有在 &quot;租赁 &quot;仍然有效的情况下,远程 ref 才会被更新。</target>
        </trans-unit>
        <trans-unit id="a3080455c3c310acd65dd25e9f3c439906791e33" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-commit and commit-msg hooks. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">该选项绕过了pre-commit和commit-msg挂钩。另请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae0cb95b3299088da58c88ea10fd24e68d20bac1" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-merge and commit-msg hooks. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">此选项绕过pre-merge和commit-msg挂钩。另请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22c10b3b137f37c4d219034c9b73126392cd066c" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-rebase hook. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">此选项绕过了预变基挂钩。另请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e7eb09891c6b3b929ffed676724fa916ce9b73e" translate="yes" xml:space="preserve">
          <source>This option can be either set to a boolean value or to &lt;code&gt;on-demand&lt;/code&gt;. Setting it to a boolean changes the behavior of fetch and pull to unconditionally recurse into submodules when set to true or to not recurse at all when set to false. When set to &lt;code&gt;on-demand&lt;/code&gt; (the default value), fetch and pull will only recurse into a populated submodule when its superproject retrieves a commit that updates the submodule&amp;rsquo;s reference.</source>
          <target state="translated">该选项可以设置为布尔值，也可以设置为 &lt;code&gt;on-demand&lt;/code&gt; 。将其设置为布尔值会更改fetch和pull的行为，设置为true时将无条件地递归到子模块中，或者设置为false时则完全不递归。当设置为 &lt;code&gt;on-demand&lt;/code&gt; （默认值）时，仅当其超级项目检索提交以更新子模块的引用的提交时，提取和拉取才会递归到已填充的子模块中。</target>
        </trans-unit>
        <trans-unit id="5d7a21f2665910c78fd7ff132552ce53899e84c0" translate="yes" xml:space="preserve">
          <source>This option can be used along with &lt;code&gt;--bisect-vars&lt;/code&gt;, in this case, after all the sorted commit objects, there will be the same text as if &lt;code&gt;--bisect-vars&lt;/code&gt; had been used alone.</source>
          <target state="translated">此选项可以与 &lt;code&gt;--bisect-vars&lt;/code&gt; 一起使用，在这种情况下，在所有排序的提交对象之后，将具有与 &lt;code&gt;--bisect-vars&lt;/code&gt; 单独使用相同的文本。</target>
        </trans-unit>
        <trans-unit id="93ff5c11faab29c493dcd0eb330b2a514a09e43b" translate="yes" xml:space="preserve">
          <source>This option can be used several times to provide several detection regexes.</source>
          <target state="translated">这个选项可以多次使用,以提供多个检测重词。</target>
        </trans-unit>
        <trans-unit id="a9be17765d99ef763e2665079651c5e7b4e1ceec" translate="yes" xml:space="preserve">
          <source>This option can be used to control recursive fetching of this submodule. If this option is also present in the submodules entry in .git/config of the superproject, the setting there will override the one found in .gitmodules. Both settings can be overridden on the command line by using the &quot;--[no-]recurse-submodules&quot; option to &quot;git fetch&quot; and &quot;git pull&quot;.</source>
          <target state="translated">这个选项可以用来控制这个子模块的递归获取。如果这个选项也存在于超级项目的.git/config中的子模块条目中,那里的设置将覆盖.gitmodules中的设置。这两个设置都可以在命令行上通过使用&quot;--[no-]recurse-submodules &quot;选项来覆盖 &quot;git fetch &quot;和 &quot;git pull&quot;。</target>
        </trans-unit>
        <trans-unit id="4813ba4c4b012e94932c2c7e77e5d37eb750ee7d" translate="yes" xml:space="preserve">
          <source>This option can be used to control recursive fetching of this submodule. It can be overridden by using the --[no-]recurse-submodules command-line option to &quot;git fetch&quot; and &quot;git pull&quot;. This setting will override that from in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file.</source>
          <target state="translated">此选项可用于控制此子模块的递归提取。可以通过使用-[no-] recurse-submodules命令行选项来&amp;ldquo; git fetch&amp;rdquo;和&amp;ldquo; git pull&amp;rdquo;来覆盖它。此设置将覆盖&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;文件中的设置。</target>
        </trans-unit>
        <trans-unit id="dc1c2b92ebab0226490f8de8ccd94e6df6f7955b" translate="yes" xml:space="preserve">
          <source>This option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options).</source>
          <target state="translated">这个选项可以用来将命令行选项从文件列表中分离出来,(当文件名可能被误认为是命令行选项时很有用)。</target>
        </trans-unit>
        <trans-unit id="792e2c6acea003d2f54070521de0f6b1fb530a29" translate="yes" xml:space="preserve">
          <source>This option can be used to specify a shell command that will be called to automatically add or modify a trailer with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">此选项可用于指定shell命令，该命令将被调用以使用指定的&amp;lt;token&amp;gt;自动添加或修改预告片。</target>
        </trans-unit>
        <trans-unit id="3870831de784b5f9a3b27254aee6ab6f7a036b72" translate="yes" xml:space="preserve">
          <source>This option can only be used for one-shot imports as &lt;code&gt;git svn&lt;/code&gt; will not be able to fetch again without metadata. Additionally, if you lose your &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; files, &lt;code&gt;git svn&lt;/code&gt; will not be able to rebuild them.</source>
          <target state="translated">此选项只能用于一次导入，因为 &lt;code&gt;git svn&lt;/code&gt; 如果没有元数据将无法再次获取。此外，如果丢失了 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; 文件，则 &lt;code&gt;git svn&lt;/code&gt; 将无法重建它们。</target>
        </trans-unit>
        <trans-unit id="7745929fdc4d071dfa2f069450065a35fb03a357" translate="yes" xml:space="preserve">
          <source>This option can only be used together with --dry-run. By using this option the user can check if any of the given files would be ignored, no matter if they are already present in the work tree or not.</source>
          <target state="translated">这个选项只能和--dry-run一起使用。通过使用这个选项,用户可以检查是否会忽略任何给定的文件,无论它们是否已经存在于工作树中。</target>
        </trans-unit>
        <trans-unit id="2cd2090b6cd931e9fb6990b800f11805da77a460" translate="yes" xml:space="preserve">
          <source>This option cannot (currently) be used unless &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; is used.</source>
          <target state="translated">除非使用 &lt;code&gt;--batch&lt;/code&gt; 或 &lt;code&gt;--batch-check&lt;/code&gt; ,否则（当前）不能使用此选项。</target>
        </trans-unit>
        <trans-unit id="0bf834f696ae0c2ea43d0e8666eab0cbfdcf28f1" translate="yes" xml:space="preserve">
          <source>This option cannot be used with --stdin.</source>
          <target state="translated">这个选项不能和-stdin一起使用。</target>
        </trans-unit>
        <trans-unit id="bae4bbd32a33e184bd257e0ab24166cfba6c0a7d" translate="yes" xml:space="preserve">
          <source>This option changes the size of the buffer that Git uses when pushing data to a remote over HTTP or HTTPS. If the data is larger than this size, libcurl, which handles the HTTP support for Git, will use chunked transfer encoding since it isn&amp;rsquo;t known ahead of time what the size of the pushed data will be.</source>
          <target state="translated">当通过HTTP或HTTPS将数据推送到远程时，此选项更改Git使用的缓冲区的大小。如果数据大于此大小，则处理对Git的HTTP支持的libcurl将使用分块传输编码，因为事先不知道所推送数据的大小。</target>
        </trans-unit>
        <trans-unit id="882762ef26e2279478bc78603a1e7faf56dec8c3" translate="yes" xml:space="preserve">
          <source>This option controls if and under what conditions new commits of populated submodules should be fetched too. It can be used as a boolean option to completely disable recursion when set to &lt;code&gt;no&lt;/code&gt; or to unconditionally recurse into all populated submodules when set to &lt;code&gt;yes&lt;/code&gt;, which is the default when this option is used without any value. Use &lt;code&gt;on-demand&lt;/code&gt; to only recurse into a populated submodule when the superproject retrieves a commit that updates the submodule&amp;rsquo;s reference to a commit that isn&amp;rsquo;t already in the local submodule clone.</source>
          <target state="translated">此选项控制是否以及在什么条件下也应提取已填充子模块的新提交。设置为 &lt;code&gt;no&lt;/code&gt; 时，它可以用作布尔选项来完全禁用递归；设置为 &lt;code&gt;yes&lt;/code&gt; 时，它可以无条件地递归到所有填充的子模块中；这是使用此选项而没有任何值时的默认值。仅当超级项目检索到的提交会将子模块的引用更新为本地子模块克隆中尚未存在的提交时，才 &lt;code&gt;on-demand&lt;/code&gt; 使用以递归到已填充的子模块中。</target>
        </trans-unit>
        <trans-unit id="402f84a0bd330441925cd57436b80c9379eb3ea0" translate="yes" xml:space="preserve">
          <source>This option controls if and under what conditions new commits of populated submodules should be fetched too. It can be used as a boolean option to completely disable recursion when set to &lt;code&gt;no&lt;/code&gt; or to unconditionally recurse into all populated submodules when set to &lt;code&gt;yes&lt;/code&gt;, which is the default when this option is used without any value. Use &lt;code&gt;on-demand&lt;/code&gt; to only recurse into a populated submodule when the superproject retrieves a commit that updates the submodule&amp;rsquo;s reference to a commit that isn&amp;rsquo;t already in the local submodule clone. By default, &lt;code&gt;on-demand&lt;/code&gt; is used, unless &lt;code&gt;fetch.recurseSubmodules&lt;/code&gt; is set (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">此选项控制是否以及在什么条件下也应提取已填充子模块的新提交。设置为 &lt;code&gt;no&lt;/code&gt; 时，它可以用作布尔选项来完全禁用递归；设置为 &lt;code&gt;yes&lt;/code&gt; 时，它可以无条件地递归到所有填充的子模块中；这是使用此选项而没有任何值时的默认设置。仅当超级项目检索到的提交会将子模块的引用更新为本地子模块克隆中尚未存在的提交时，才 &lt;code&gt;on-demand&lt;/code&gt; 使用以递归到已填充的子模块中。默认情况下， &lt;code&gt;on-demand&lt;/code&gt; 使用，除非设置了 &lt;code&gt;fetch.recurseSubmodules&lt;/code&gt; （请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="69bffdffaf64305a520ea61fd7a4110a4c5bf981" translate="yes" xml:space="preserve">
          <source>This option controls if new commits of all populated submodules should be fetched and updated, too (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;).</source>
          <target state="translated">此选项控制是否也应提取并更新所有已填充子模块的新提交（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;和&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8666b4e7aa19effada757acd8dc6a366796aecc5" translate="yes" xml:space="preserve">
          <source>This option controls if new commits of populated submodules should be fetched, and if the working trees of active submodules should be updated, too (see &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;, &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;).</source>
          <target state="translated">此选项控制是否应提取已填充子模块的新提交，以及是否也应更新活动子模块的工作树（请参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;，&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;和&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="99e48667fde8ec2632838629a22c3bc7308b3012" translate="yes" xml:space="preserve">
          <source>This option controls whether &lt;code&gt;git fetch&lt;/code&gt; (and the underlying fetch in &lt;code&gt;git pull&lt;/code&gt;) will recursively fetch into populated submodules. This option can be set either to a boolean value or to &lt;code&gt;on-demand&lt;/code&gt;. Setting it to a boolean changes the behavior of fetch and pull to recurse unconditionally into submodules when set to true or to not recurse at all when set to false. When set to &lt;code&gt;on-demand&lt;/code&gt;, fetch and pull will only recurse into a populated submodule when its superproject retrieves a commit that updates the submodule&amp;rsquo;s reference. Defaults to &lt;code&gt;on-demand&lt;/code&gt;, or to the value of &lt;code&gt;submodule.recurse&lt;/code&gt; if set.</source>
          <target state="translated">此选项控制 &lt;code&gt;git fetch&lt;/code&gt; （以及 &lt;code&gt;git pull&lt;/code&gt; 中的基础提取）是否将递归地提取到填充的子模块中。该选项可以设置为布尔值或 &lt;code&gt;on-demand&lt;/code&gt; 。将其设置为布尔值会更改fetch和pull的行为，如果设置为true，则无条件地将其递归到子模块中；如果将其设置为false，则将其完全不递归。当设置为 &lt;code&gt;on-demand&lt;/code&gt; 时，仅当其父项目的提交检索到更新子模块引用的提交时，fetch和pull才会递归到已填充的子模块中。默认为 &lt;code&gt;on-demand&lt;/code&gt; ，或者为 &lt;code&gt;submodule.recurse&lt;/code&gt; 的值（如果已设置）。</target>
        </trans-unit>
        <trans-unit id="30828ff428cc76245c5c17e5cbd61f4d3413d1c5" translate="yes" xml:space="preserve">
          <source>This option determines how the commit message will be cleaned up before being passed on to the commit machinery. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more details. In particular, if the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is given a value of &lt;code&gt;scissors&lt;/code&gt;, scissors will be appended to &lt;code&gt;MERGE_MSG&lt;/code&gt; before being passed on in the case of a conflict.</source>
          <target state="translated">此选项确定在将提交消息传递到提交机器之前如何对其进行清理。有关更多详细信息，请参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;。特别是，如果为 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 赋予 &lt;code&gt;scissors&lt;/code&gt; 值，则在发生冲突时将在传递剪刀之前将其附加到 &lt;code&gt;MERGE_MSG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="286a93d0042817a6190102b1bfcb5df866579bac" translate="yes" xml:space="preserve">
          <source>This option determines how the merge message will be cleaned up before committing. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more details. In addition, if the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is given a value of &lt;code&gt;scissors&lt;/code&gt;, scissors will be appended to &lt;code&gt;MERGE_MSG&lt;/code&gt; before being passed on to the commit machinery in the case of a merge conflict.</source>
          <target state="translated">该选项确定提交前如何清除合并消息。有关更多详细信息，请参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;。另外，如果为 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 赋予 &lt;code&gt;scissors&lt;/code&gt; 值，则在发生合并冲突的情况下，剪刀将被附加到 &lt;code&gt;MERGE_MSG&lt;/code&gt; 上,然后传递给提交机制。</target>
        </trans-unit>
        <trans-unit id="4d1960d5d8472d2a194e5ec10acd8959326f748a" translate="yes" xml:space="preserve">
          <source>This option determines how the supplied commit message should be cleaned up before committing. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; can be &lt;code&gt;strip&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt;, &lt;code&gt;verbatim&lt;/code&gt;, &lt;code&gt;scissors&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">此选项确定在提交之前应如何清除提供的提交消息。所述 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 可以是 &lt;code&gt;strip&lt;/code&gt; ， &lt;code&gt;whitespace&lt;/code&gt; ， &lt;code&gt;verbatim&lt;/code&gt; ， &lt;code&gt;scissors&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5dab8a93409f72b36d8b46ab64625d688725721" translate="yes" xml:space="preserve">
          <source>This option does not (currently) work correctly when an object in the index is specified (e.g. &lt;code&gt;:link&lt;/code&gt; instead of &lt;code&gt;HEAD:link&lt;/code&gt;) rather than one in the tree.</source>
          <target state="translated">当在索引中指定一个对象（例如 &lt;code&gt;:link&lt;/code&gt; 而不是 &lt;code&gt;HEAD:link&lt;/code&gt; ）而不是树中的一个对象时，此选项（当前）无法正常工作。</target>
        </trans-unit>
        <trans-unit id="4255d9341f980babd777e06e825f8c27e78f42e4" translate="yes" xml:space="preserve">
          <source>This option enables a check that verifies if the tip of the remote-tracking ref is reachable from one of the &quot;reflog&quot; entries of the local branch based in it for a rewrite. The check ensures that any updates from the remote have been incorporated locally by rejecting the forced update if that is not the case.</source>
          <target state="translated">这个选项启用了一个检查,以验证远程跟踪 ref 的顶端是否可以从本地分支的 &quot;reflog &quot;条目中的一个条目到达,以便进行重写。如果不是这样的话,该检查可以通过拒绝强制更新来确保来自远程的任何更新都已经被纳入本地。</target>
        </trans-unit>
        <trans-unit id="d9ea124fbd7a15594b4c6836d821b0c2d1f565c3" translate="yes" xml:space="preserve">
          <source>This option forces conflicting hunks to be auto-resolved cleanly by favoring &lt;code&gt;our&lt;/code&gt; version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side.</source>
          <target state="translated">此选项通过支持 &lt;code&gt;our&lt;/code&gt; 版本来强制自动解决冲突的大块。合并结果中反映了与另一棵树不冲突的变化。对于二进制文件，全部内容都是从我们这边获取的。</target>
        </trans-unit>
        <trans-unit id="03e43ead906b5a3ebd0febb15138c0f0fef70180" translate="yes" xml:space="preserve">
          <source>This option identifies the file status with the following tags (followed by a space) at the start of each line:</source>
          <target state="translated">这个选项在每行开头用以下标签(后面加一个空格)来标识文件状态。</target>
        </trans-unit>
        <trans-unit id="11f1817b2bcb9580d82cb7eff477a970ee3352b6" translate="yes" xml:space="preserve">
          <source>This option is NOT recommended as it makes it difficult to track down old references to SVN revision numbers in existing documentation, bug reports, and archives. If you plan to eventually migrate from SVN to Git and are certain about dropping SVN history, consider &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; instead. filter-repo also allows reformatting of metadata for ease-of-reading and rewriting authorship info for non-&quot;svn.authorsFile&quot; users.</source>
          <target state="translated">不建议使用此选项，因为它会使您难以在现有文档，错误报告和档案中跟踪对SVN修订版号的旧引用。如果您打算最终从SVN迁移到Git，并且确定要删除SVN历史记录，请考虑使用&lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt;。filter-repo还允许重新格式化元数据，以方便非&amp;ldquo; svn.authorsFile&amp;rdquo;用户的阅读和重写作者信息。</target>
        </trans-unit>
        <trans-unit id="78790ec840bc0471b6e620b0edc9dccd8cb32215" translate="yes" xml:space="preserve">
          <source>This option is a more advanced form of &lt;code&gt;subtree&lt;/code&gt; strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.</source>
          <target state="translated">此选项是 &lt;code&gt;subtree&lt;/code&gt; 策略的一种更高级形式，其中该策略猜测合并时必须如何移动两棵树以相互匹配。而是将指定的路径添加前缀（或从开头剥离）以使两棵树的形状匹配。</target>
        </trans-unit>
        <trans-unit id="7e1a0662099548eacf19f027d973ae52cc900bb4" translate="yes" xml:space="preserve">
          <source>This option is deprecated in favour of &lt;code&gt;git stash push&lt;/code&gt;. It differs from &quot;stash push&quot; in that it cannot take pathspec. Instead, all non-option arguments are concatenated to form the stash message.</source>
          <target state="translated">不推荐使用此选项，而推荐使用 &lt;code&gt;git stash push&lt;/code&gt; 。它与&amp;ldquo;隐藏推送&amp;rdquo;的不同之处在于它不能采用pathspec。而是将所有非选项参数串联起来构成隐藏消息。</target>
        </trans-unit>
        <trans-unit id="4caf0764823caa06aa3cb192d447e797c84f9905" translate="yes" xml:space="preserve">
          <source>This option is deprecated in favour of &lt;code&gt;git stash push&lt;/code&gt;. It differs from &quot;stash push&quot; in that it cannot take pathspecs. Instead, all non-option arguments are concatenated to form the stash message.</source>
          <target state="translated">不推荐使用此选项，而推荐使用 &lt;code&gt;git stash push&lt;/code&gt; 。它与&amp;ldquo;隐藏推送&amp;rdquo;的不同之处在于它不能采用pathspec。而是将所有非选项参数串联起来构成隐藏消息。</target>
        </trans-unit>
        <trans-unit id="c02fef4ae69460732c7c3bd405bb6c17f43ad119" translate="yes" xml:space="preserve">
          <source>This option is equivalent to the &amp;lt;repository&amp;gt; argument. If both are specified, the command-line argument takes precedence.</source>
          <target state="translated">此选项等效于&amp;lt;repository&amp;gt;参数。如果两者都指定，则命令行参数优先。</target>
        </trans-unit>
        <trans-unit id="b7fdcf9707bc99b530bc435f0d474fdd1738b42d" translate="yes" xml:space="preserve">
          <source>This option is implicitly supplied if any other list-like option such as &lt;code&gt;--contains&lt;/code&gt; is provided. See the documentation for each of those options for details.</source>
          <target state="translated">如果提供了其他类似列表的选项（例如 &lt;code&gt;--contains&lt;/code&gt; ），则隐式提供此选项。有关每个选项的详细信息，请参见文档。</target>
        </trans-unit>
        <trans-unit id="710c94d6943c052c3ce9d72b355d1824bacce0cd" translate="yes" xml:space="preserve">
          <source>This option is only applicable in non-verbose mode.</source>
          <target state="translated">此选项仅适用于非言语模式。</target>
        </trans-unit>
        <trans-unit id="4cc49fd28601407189cb758fe5a41d5aaf8777ac" translate="yes" xml:space="preserve">
          <source>This option is only applicable when listing tags without annotation lines.</source>
          <target state="translated">此选项仅适用于列出没有注释行的标签时。</target>
        </trans-unit>
        <trans-unit id="ac28aa5e8f93911465d1aaa74ae4db50de2f286b" translate="yes" xml:space="preserve">
          <source>This option is only relevant if we are tracking branches (using one of the repository layout options --trunk, --tags, --branches, --stdlayout). For each tracked branch, try to find out where its revision was copied from, and set a suitable parent in the first Git commit for the branch. This is especially helpful when we&amp;rsquo;re tracking a directory that has been moved around within the repository. If this feature is disabled, the branches created by &lt;code&gt;git svn&lt;/code&gt; will all be linear and not share any history, meaning that there will be no information on where branches were branched off or merged. However, following long/convoluted histories can take a long time, so disabling this feature may speed up the cloning process. This feature is enabled by default, use --no-follow-parent to disable it.</source>
          <target state="translated">仅当我们跟踪分支时才使用此选项（使用存储库布局选项--trunk，-tags，-branches，-stdlayout中的一个）。对于每个跟踪的分支，尝试找出其修订版本从何处复制，并在该分支的第一个Git提交中设置合适的父级。当我们跟踪已在存储库中移动的目录时，这特别有用。如果禁用此功能，则由 &lt;code&gt;git svn&lt;/code&gt; 创建的分支将全部是线性的，并且不会共享任何历史记录，这意味着将没有关于分支在何处分支或合并的信息。但是，遵循较长/复杂的历史记录可能会花费很长时间，因此禁用此功能可能会加快克隆过程。默认情况下启用此功能，请使用--no-follow-parent禁用它。</target>
        </trans-unit>
        <trans-unit id="e12fdc170000781ad1c58dbca132db57e3472f94" translate="yes" xml:space="preserve">
          <source>This option is only used by Mac OS implementation of Git. When core.precomposeUnicode=true, Git reverts the unicode decomposition of filenames done by Mac OS. This is useful when sharing a repository between Mac OS and Linux or Windows. (Git for Windows 1.7.10 or higher is needed, or Git under cygwin 1.7). When false, file names are handled fully transparent by Git, which is backward compatible with older versions of Git.</source>
          <target state="translated">这个选项只在Mac OS实现的Git中使用。当core.precomposeUnicode=true时,Git会恢复Mac OS对文件名的unicode分解。这在 Mac OS 和 Linux 或 Windows 之间共享仓库时非常有用。(需要 Git for Windows 1.7.10 或更高版本,或 Git under cygwin 1.7)。当为 &quot;false &quot;时,Git对文件名的处理是完全透明的,这与旧版本的Git向后兼容。</target>
        </trans-unit>
        <trans-unit id="f6656985205e20f496a0b3074744f80ac096af4d" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;branch&lt;/code&gt;, &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;show&lt;/code&gt; commands.</source>
          <target state="translated">此选项仅对 &lt;code&gt;apply&lt;/code&gt; ， &lt;code&gt;branch&lt;/code&gt; ， &lt;code&gt;drop&lt;/code&gt; ， &lt;code&gt;pop&lt;/code&gt; ， &lt;code&gt;show&lt;/code&gt; 命令有效。</target>
        </trans-unit>
        <trans-unit id="ec6b30f54355307a9689dd1f0d561ef40fa56b3b" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;save&lt;/code&gt;, &lt;code&gt;store&lt;/code&gt; commands.</source>
          <target state="translated">此选项仅对 &lt;code&gt;apply&lt;/code&gt; ， &lt;code&gt;drop&lt;/code&gt; ， &lt;code&gt;pop&lt;/code&gt; ， &lt;code&gt;push&lt;/code&gt; ， &lt;code&gt;save&lt;/code&gt; 和 &lt;code&gt;store&lt;/code&gt; 命令有效。</target>
        </trans-unit>
        <trans-unit id="ca1fe023113c04188594b141d1e29c7346f8a146" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; commands.</source>
          <target state="translated">此选项仅对 &lt;code&gt;pop&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 命令有效。</target>
        </trans-unit>
        <trans-unit id="14a31933c42436b9e91daec147e769ddb8e06d57" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt; commands.</source>
          <target state="translated">此选项仅对 &lt;code&gt;push&lt;/code&gt; 和 &lt;code&gt;save&lt;/code&gt; 命令有效。</target>
        </trans-unit>
        <trans-unit id="1938ed399d7f045d62945a278113dd2db5e4506d" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;push&lt;/code&gt; command.</source>
          <target state="translated">此选项仅对 &lt;code&gt;push&lt;/code&gt; 命令有效。</target>
        </trans-unit>
        <trans-unit id="488a5b3855b8742f267f0b39339ad03e677bc10e" translate="yes" xml:space="preserve">
          <source>This option is only valid for add and update commands. Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.</source>
          <target state="translated">这个选项只对添加和更新命令有效。除非指定了 -q,否则当标准错误流连接到终端时,默认情况下会报告进度状态。即使标准错误流没有指向终端,该标志也会强制报告进度状态。</target>
        </trans-unit>
        <trans-unit id="564be2665790d0ee7a744865d472382d1cf20497" translate="yes" xml:space="preserve">
          <source>This option is only valid for add and update commands. These commands sometimes need to clone a remote repository. In this case, this option will be passed to the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; command.</source>
          <target state="translated">此选项仅对添加和更新命令有效。这些命令有时需要克隆远程存储库。在这种情况下，此选项将传递给&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="1175e1719609394666bffaa81ec16b8052e4a6b8" translate="yes" xml:space="preserve">
          <source>This option is only valid for add, deinit and update commands. When running add, allow adding an otherwise ignored submodule path. When running deinit the submodule working trees will be removed even if they contain local changes. When running update (only effective with the checkout procedure), throw away local changes in submodules when switching to a different commit; and always run a checkout operation in the submodule, even if the commit listed in the index of the containing repository matches the commit checked out in the submodule.</source>
          <target state="translated">这个选项只对add、deinit和update命令有效。当运行add时,允许添加一个否则被忽略的子模块路径。当运行deinit时,子模块工作树将被删除,即使它们包含本地变化。当运行 update 时(仅对 checkout 程序有效),当切换到不同的提交时,扔掉子模块中的本地变化;并且总是在子模块中运行 checkout 操作,即使包含仓库的索引中列出的提交与子模块中签出的提交相匹配。</target>
        </trans-unit>
        <trans-unit id="2de8d442aa39a274aaa4b758d62aa7d0adb622e3" translate="yes" xml:space="preserve">
          <source>This option is only valid for foreach, update, status and sync commands. Traverse submodules recursively. The operation is performed not only in the submodules of the current repo, but also in any nested submodules inside those submodules (and so on).</source>
          <target state="translated">这个选项只对foreach、update、status和sync命令有效。递归遍历子模块。该操作不仅在当前 repo 的子模块中执行,而且在这些子模块中的任何嵌套的子模块中执行(以此类推)。</target>
        </trans-unit>
        <trans-unit id="d01c54f91ad08eb6d9511d7549b500d6b89b1500" translate="yes" xml:space="preserve">
          <source>This option is only valid for status and summary commands. These commands typically use the commit found in the submodule HEAD, but with this option, the commit stored in the index is used instead.</source>
          <target state="translated">这个选项只对状态和摘要命令有效。这些命令通常使用子模块HEAD中的提交,但使用这个选项,会使用索引中存储的提交。</target>
        </trans-unit>
        <trans-unit id="7ba21174d5319ba108a98df185e2c79d000e199b" translate="yes" xml:space="preserve">
          <source>This option is only valid for the add command. It sets the submodule&amp;rsquo;s name to the given string instead of defaulting to its path. The name must be valid as a directory name and may not end with a &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">此选项仅对add命令有效。它将子模块的名称设置为给定的字符串，而不是默认使用其路径。该名称必须作为目录名称有效，并且不能以 &lt;code&gt;/&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="87ff71824f0ae07bd73763f995cf49d0ad4b94cd" translate="yes" xml:space="preserve">
          <source>This option is only valid for the deinit command. Unregister all submodules in the working tree.</source>
          <target state="translated">这个选项只对deinit命令有效。取消注册工作树中的所有子模块。</target>
        </trans-unit>
        <trans-unit id="f24783ef5194da88d7aca04af04dd4876a0ce3ed" translate="yes" xml:space="preserve">
          <source>This option is only valid for the summary command. Limit the summary size (number of commits shown in total). Giving 0 will disable the summary; a negative number means unlimited (the default). This limit only applies to modified submodules. The size is always limited to 1 for added/deleted/typechanged submodules.</source>
          <target state="translated">这个选项只对摘要命令有效。限制摘要的大小(总共显示的提交次数)。给予0将禁用摘要;负数表示无限制(默认)。这个限制只适用于修改过的子模块。对于添加/删除/类型改变的子模块,大小总是限制为1。</target>
        </trans-unit>
        <trans-unit id="ba7d2b303205764476dea6127f5143ab027381fd" translate="yes" xml:space="preserve">
          <source>This option is only valid for the summary command. This command compares the commit in the index with that in the submodule HEAD when this option is used.</source>
          <target state="translated">这个选项只对摘要命令有效。当使用该选项时,该命令将索引中的提交与子模块HEAD中的提交进行比较。</target>
        </trans-unit>
        <trans-unit id="0329e613a2d579c43cf813e4dcb872eed327d20c" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Checkout the commit recorded in the superproject on a detached HEAD in the submodule. This is the default behavior, the main use of this option is to override &lt;code&gt;submodule.$name.update&lt;/code&gt; when set to a value other than &lt;code&gt;checkout&lt;/code&gt;. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is either not explicitly set or set to &lt;code&gt;checkout&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">此选项仅对update命令有效。在子模块中的分离HEAD上签出超级项目中记录的提交。这是默认行为，当设置为 &lt;code&gt;checkout&lt;/code&gt; 以外的其他值时，此选项的主要用途是覆盖 &lt;code&gt;submodule.$name.update&lt;/code&gt; 。如果未显式设置键 &lt;code&gt;submodule.$name.update&lt;/code&gt; 或将其设置为 &lt;code&gt;checkout&lt;/code&gt; ，则此选项为隐式。</target>
        </trans-unit>
        <trans-unit id="7988d8bd0ba82c9f133c5f7cc525c2236228f253" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Clone new submodules in parallel with as many jobs. Defaults to the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; option.</source>
          <target state="translated">此选项仅对update命令有效。克隆新的子模块，同时包含尽可能多的作业。默认为 &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="d378f847e736854044b7df06d860154da6a30cd4" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Clone only one branch during update: HEAD or one specified by --branch.</source>
          <target state="translated">这个选项只对更新命令有效。在更新过程中只克隆一个分支:HEAD或由--branch指定的分支。</target>
        </trans-unit>
        <trans-unit id="de5e49243a4037b1b14e7038956130dc87de6d4f" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Don&amp;rsquo;t fetch new objects from the remote site.</source>
          <target state="translated">此选项仅对update命令有效。不要从远程站点获取新对象。</target>
        </trans-unit>
        <trans-unit id="f13e740e91a73f0a2574eefa11fc263894a39d8c" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Initialize all submodules for which &quot;git submodule init&quot; has not been called so far before updating.</source>
          <target state="translated">这个选项只对更新命令有效。在更新前,初始化所有尚未调用 &quot;git submodule init &quot;的子模块。</target>
        </trans-unit>
        <trans-unit id="78bb9a5b0867074719f5c17324b183ac216eed4e" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Instead of using the superproject&amp;rsquo;s recorded SHA-1 to update the submodule, use the status of the submodule&amp;rsquo;s remote-tracking branch. The remote used is branch&amp;rsquo;s remote (&lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt;), defaulting to &lt;code&gt;origin&lt;/code&gt;. The remote branch used defaults to &lt;code&gt;master&lt;/code&gt;, but the branch name may be overridden by setting the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; option in either &lt;code&gt;.gitmodules&lt;/code&gt; or &lt;code&gt;.git/config&lt;/code&gt; (with &lt;code&gt;.git/config&lt;/code&gt; taking precedence).</source>
          <target state="translated">此选项仅对update命令有效。不要使用超级项目记录的SHA-1更新子模块，而要使用子模块的远程跟踪分支的状态。所使用的远程是分支的远程（ &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; ），默认为 &lt;code&gt;origin&lt;/code&gt; 。使用的远程分支默认为 &lt;code&gt;master&lt;/code&gt; ，但是可以通过设置 &lt;code&gt;.gitmodules&lt;/code&gt; 或 &lt;code&gt;.git/config&lt;/code&gt; 中的 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 选项来覆盖分支名称（以 &lt;code&gt;.git/config&lt;/code&gt; 优先）。</target>
        </trans-unit>
        <trans-unit id="71febe80653ad4c9e80be61d4ea3dbe9011e0741" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Instead of using the superproject&amp;rsquo;s recorded SHA-1 to update the submodule, use the status of the submodule&amp;rsquo;s remote-tracking branch. The remote used is branch&amp;rsquo;s remote (&lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt;), defaulting to &lt;code&gt;origin&lt;/code&gt;. The remote branch used defaults to the remote &lt;code&gt;HEAD&lt;/code&gt;, but the branch name may be overridden by setting the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; option in either &lt;code&gt;.gitmodules&lt;/code&gt; or &lt;code&gt;.git/config&lt;/code&gt; (with &lt;code&gt;.git/config&lt;/code&gt; taking precedence).</source>
          <target state="translated">此选项仅对update命令有效。不要使用超级项目记录的SHA-1更新子模块，而要使用子模块的远程跟踪分支的状态。使用的远程是分支的远程（ &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; ），默认为 &lt;code&gt;origin&lt;/code&gt; 。使用的远程分支默认为远程 &lt;code&gt;HEAD&lt;/code&gt; ，但是可以通过在 &lt;code&gt;.gitmodules&lt;/code&gt; 或 &lt;code&gt;.git/config&lt;/code&gt; 中设置 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 选项来覆盖分支名称（以 &lt;code&gt;.git/config&lt;/code&gt; 优先）。</target>
        </trans-unit>
        <trans-unit id="c3d36d21960733622c3c4d0c9b1d02dde186ab4d" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Merge the commit recorded in the superproject into the current branch of the submodule. If this option is given, the submodule&amp;rsquo;s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve the resulting conflicts within the submodule with the usual conflict resolution tools. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is set to &lt;code&gt;merge&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">此选项仅对update命令有效。将超级项目中记录的提交合并到子模块的当前分支中。如果给出此选项，则不会分离子模块的HEAD。如果合并失败阻止了此过程，则必须使用常规的冲突解决工具来解决子模块内导致的冲突。如果键 &lt;code&gt;submodule.$name.update&lt;/code&gt; 设置为 &lt;code&gt;merge&lt;/code&gt; ，则此选项为隐式。</target>
        </trans-unit>
        <trans-unit id="24320b0a3d3cc55ac6e67c5111e4d5b2024f7768" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Rebase the current branch onto the commit recorded in the superproject. If this option is given, the submodule&amp;rsquo;s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve these failures with &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is set to &lt;code&gt;rebase&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">此选项仅对update命令有效。将当前分支重新基于超级项目中记录的提交。如果给出此选项，则不会分离子模块的HEAD。如果合并失败阻止了此过程，则必须使用&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;解决这些失败。如果密钥 &lt;code&gt;submodule.$name.update&lt;/code&gt; 设置为 &lt;code&gt;rebase&lt;/code&gt; ，则此选项为隐式。</target>
        </trans-unit>
        <trans-unit id="7010a654e778ac0c1da27a5e658bfb8f3af2d2b7" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. The initial clone of a submodule will use the recommended &lt;code&gt;submodule.&amp;lt;name&amp;gt;.shallow&lt;/code&gt; as provided by the &lt;code&gt;.gitmodules&lt;/code&gt; file by default. To ignore the suggestions use &lt;code&gt;--no-recommend-shallow&lt;/code&gt;.</source>
          <target state="translated">此选项仅对update命令有效。子模块的初始克隆将使用 &lt;code&gt;.gitmodules&lt;/code&gt; 文件默认提供的推荐 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.shallow&lt;/code&gt; 。要忽略建议，请使用 &lt;code&gt;--no-recommend-shallow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6d7b3753dd95003bf8a5d9061fa7c1fb4ce2aaa" translate="yes" xml:space="preserve">
          <source>This option is only valid when &quot;--rebase&quot; is used.</source>
          <target state="translated">这个选项只有在使用&quot;--rebase &quot;时才有效。</target>
        </trans-unit>
        <trans-unit id="98847da95477508a8a5d1e566e92d9a686be8a10" translate="yes" xml:space="preserve">
          <source>This option is particularly useful in avoiding false positives when a merged branch contained broken or non-buildable commits, but the merge itself was OK.</source>
          <target state="translated">当合并后的分支包含了破损的或不可构建的提交,但合并本身没有问题时,这个选项对避免误报特别有用。</target>
        </trans-unit>
        <trans-unit id="f287cb1cbdf50b2a99b97c922a7a8e625bb0e374" translate="yes" xml:space="preserve">
          <source>This option is passed through to &lt;code&gt;git pack-objects&lt;/code&gt;.</source>
          <target state="translated">此选项通过 &lt;code&gt;git pack-objects&lt;/code&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="4fbc055bad10c535a2fe42cbab527b95ac43fb4e" translate="yes" xml:space="preserve">
          <source>This option is primarily to help users who are used to older versions of Git, whose &quot;git add &amp;lt;pathspec&amp;gt;&amp;hellip;​&quot; was a synonym for &quot;git add --no-all &amp;lt;pathspec&amp;gt;&amp;hellip;​&quot;, i.e. ignored removed files.</source>
          <target state="translated">此选项主要是为习惯于旧版本Git的用户提供帮助，这些用户的&amp;ldquo; git add &amp;lt;pathspec&amp;gt;&amp;hellip;&amp;rdquo;是&amp;ldquo; git add --no-all &amp;lt;pathspec&amp;gt; ...&amp;rdquo;的同义词，即忽略已删除的文件。</target>
        </trans-unit>
        <trans-unit id="b78fb9017b343dcaa9f7e76e34c0b6aead88f71f" translate="yes" xml:space="preserve">
          <source>This option is similar to &lt;code&gt;--topo-order&lt;/code&gt; in the sense that no parent comes before all of its children, but otherwise commits are ordered according to their commit date.</source>
          <target state="translated">此选项与 &lt;code&gt;--topo-order&lt;/code&gt; 相似，在某种意义上，没有父级先于其所有子级出现，但其他提交是根据其提交日期排序的。</target>
        </trans-unit>
        <trans-unit id="45355afb761a7570eab836899016e010dbbaff37" translate="yes" xml:space="preserve">
          <source>This option is used internally to temporarily provide a non-negative default value for the --recurse-submodules option. All other methods of configuring fetch&amp;rsquo;s submodule recursion (such as settings in &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; and &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) override this option, as does specifying --[no-]recurse-submodules directly.</source>
          <target state="translated">此选项在内部用于临时为--recurse-submodules选项提供非负默认值。所有其他配置fetch的子模块递归的方法（例如&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;和&lt;a href=&quot;git-config&quot;&gt;git-config [1]中的设置&lt;/a&gt;）都会覆盖此选项，就像直接指定-[no-] recurse-submodules一样。</target>
        </trans-unit>
        <trans-unit id="37e6c888c3b366c4018908c683d3076036665dbd" translate="yes" xml:space="preserve">
          <source>This option is useful in the case where one is developing a feature on top of an upstream branch. While the feature is being worked on, the upstream branch may advance and it may not be the best idea to keep rebasing on top of the upstream but to keep the base commit as-is.</source>
          <target state="translated">当我们在上游分支的基础上开发一个特性时,这个选项是很有用的。当功能正在开发的时候,上游分支可能会前进,因此在上游分支的基础上继续重新归类可能不是最好的主意,而应该保持基础提交的原样。</target>
        </trans-unit>
        <trans-unit id="df85f593fd6f7620dd8216482ba39599038d6eaa" translate="yes" xml:space="preserve">
          <source>This option is valid for add and update commands. Create a &lt;code&gt;shallow&lt;/code&gt; clone with a history truncated to the specified number of revisions. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;</source>
          <target state="translated">此选项对添加和更新命令有效。创建一个 &lt;code&gt;shallow&lt;/code&gt; 副本，其历史记录被截断为指定的修订版本。参见&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ebd5b9556122446be4baef760f1327190ef9a1e0" translate="yes" xml:space="preserve">
          <source>This option makes it possible to choose what action will be performed when there is already at least one trailer with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">使用此选项可以选择在消息中已经存在至少一个具有相同&amp;lt;token&amp;gt;的预告片时执行的操作。</target>
        </trans-unit>
        <trans-unit id="ccc070d377579e85f01a8bc02ef61c868f5331ee" translate="yes" xml:space="preserve">
          <source>This option makes it possible to choose what action will be performed when there is not yet any trailer with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">此选项使您可以选择在消息中还没有任何具有相同&amp;lt;token&amp;gt;的预告片时将执行的操作。</target>
        </trans-unit>
        <trans-unit id="f87ac9b403a45c29acabaf374d53994925318884" translate="yes" xml:space="preserve">
          <source>This option may be given up to three times, and specifies labels to be used in place of the corresponding file names in conflict reports. That is, &lt;code&gt;git merge-file -L x -L y -L z a b c&lt;/code&gt; generates output that looks like it came from files x, y and z instead of from files a, b and c.</source>
          <target state="translated">该选项最多可给出3次，并指定用于代替冲突报告中相应文件名的标签。也就是说， &lt;code&gt;git merge-file -L x -L y -L z a b c&lt;/code&gt; 生成的输出看起来像是来自文件x，y和z而不是来自文件a，b和c。</target>
        </trans-unit>
        <trans-unit id="e631233708c2bfee4790b72e1f69b49f86a6c1ad" translate="yes" xml:space="preserve">
          <source>This option may be specified more than once.</source>
          <target state="translated">此选项可指定一次以上。</target>
        </trans-unit>
        <trans-unit id="ad4bbf67e7b293924d5786bf652c9c00512dbaee" translate="yes" xml:space="preserve">
          <source>This option may be specified more than once; if so, Git will report commits reachable from any of the given commits.</source>
          <target state="translated">这个选项可以指定多个,如果是这样的话,Git会报告从任何一个给定的提交到达的提交。</target>
        </trans-unit>
        <trans-unit id="02516672facfbf5a7b264eba6cd92c5455d92d79" translate="yes" xml:space="preserve">
          <source>This option may be specified multiple times.</source>
          <target state="translated">此选项可指定多次。</target>
        </trans-unit>
        <trans-unit id="b397b665066a62a5850aaf1e8487dea9e6d48e99" translate="yes" xml:space="preserve">
          <source>This option may be useful if you have CVS revision numbers stored in commit messages, bug-tracking systems, email archives, and the like.</source>
          <target state="translated">如果你的 CVS 版本号存储在提交信息、错误跟踪系统、电子邮件档案中,这个选项可能会很有用。</target>
        </trans-unit>
        <trans-unit id="5f0fddd7193d3e6d239ce8fc4bc7fc077dbf4105" translate="yes" xml:space="preserve">
          <source>This option may be useful when the test you would perform in each step does not require a checked out tree.</source>
          <target state="translated">当你在每个步骤中执行的测试不需要检查出的树时,这个选项可能很有用。</target>
        </trans-unit>
        <trans-unit id="17ca02a4d5f28c7e8971b8d1a382a0b6bcfa0d17" translate="yes" xml:space="preserve">
          <source>This option overrides this restriction if the current value of the remote ref is the expected value. &quot;git push&quot; fails otherwise.</source>
          <target state="translated">如果远程ref的当前值是预期值,这个选项会覆盖这个限制。否则 &quot;git push &quot;会失败。</target>
        </trans-unit>
        <trans-unit id="8d166b9e59f19f7598d41e509f594cbcbd0ac7f1" translate="yes" xml:space="preserve">
          <source>This option provides an additional limit on top of &lt;code&gt;--window&lt;/code&gt;; the window size will dynamically scale down so as to not take up more than &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; bytes in memory. This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. &lt;code&gt;--window-memory=0&lt;/code&gt; makes memory usage unlimited. The default is taken from the &lt;code&gt;pack.windowMemory&lt;/code&gt; configuration variable.</source>
          <target state="translated">此选项在 &lt;code&gt;--window&lt;/code&gt; 之上提供了一个额外的限制；窗口大小将动态缩小，以使内存中的字节数不超过 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 个字节。这在包含大型对象和小型对象的存储库中非常有用，这样不会因为一个大窗口而用完内存，但是仍然可以利用大窗口来存储较小的对象。大小可以后缀&amp;ldquo; k&amp;rdquo;，&amp;ldquo; m&amp;rdquo;或&amp;ldquo; g&amp;rdquo;。 &lt;code&gt;--window-memory=0&lt;/code&gt; 使内存使用不受限制。默认值来自 &lt;code&gt;pack.windowMemory&lt;/code&gt; 配置变量。</target>
        </trans-unit>
        <trans-unit id="b37ac455915a6998f49ecb85f682ef29dfba0c63" translate="yes" xml:space="preserve">
          <source>This option provides an additional limit on top of &lt;code&gt;--window&lt;/code&gt;; the window size will dynamically scale down so as to not take up more than &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; bytes in memory. This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. &lt;code&gt;--window-memory=0&lt;/code&gt; makes memory usage unlimited. The default is taken from the &lt;code&gt;pack.windowMemory&lt;/code&gt; configuration variable. Note that the actual memory usage will be the limit multiplied by the number of threads used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;.</source>
          <target state="translated">此选项在 &lt;code&gt;--window&lt;/code&gt; 之上提供了一个额外的限制；窗口大小将动态缩小，以使内存中的字节数不超过 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 个字节。这在包含大型对象和小型对象的存储库中非常有用，这样不会因为一个大窗口而用完内存，但是仍然可以利用大窗口来存储较小的对象。大小可以后缀&amp;ldquo; k&amp;rdquo;，&amp;ldquo; m&amp;rdquo;或&amp;ldquo; g&amp;rdquo;。 &lt;code&gt;--window-memory=0&lt;/code&gt; 使内存使用不受限制。默认值来自 &lt;code&gt;pack.windowMemory&lt;/code&gt; 配置变量。请注意，实际内存使用量将是限制乘以&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;使用的线程数。</target>
        </trans-unit>
        <trans-unit id="16a6b7273f3cccefcfa42e33a667c568aaee0875" translate="yes" xml:space="preserve">
          <source>This option sets how the tag message is cleaned up. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; can be one of &lt;code&gt;verbatim&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt; and &lt;code&gt;strip&lt;/code&gt;. The &lt;code&gt;strip&lt;/code&gt; mode is default. The &lt;code&gt;verbatim&lt;/code&gt; mode does not change message at all, &lt;code&gt;whitespace&lt;/code&gt; removes just leading/trailing whitespace lines and &lt;code&gt;strip&lt;/code&gt; removes both whitespace and commentary.</source>
          <target state="translated">此选项设置清除标签消息的方式。所述 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 可以是一个 &lt;code&gt;verbatim&lt;/code&gt; ， &lt;code&gt;whitespace&lt;/code&gt; 和 &lt;code&gt;strip&lt;/code&gt; 。所述 &lt;code&gt;strip&lt;/code&gt; 模式是默认值。的 &lt;code&gt;verbatim&lt;/code&gt; 模式完全不改变消息时， &lt;code&gt;whitespace&lt;/code&gt; 将删除刚刚前/后空白线和 &lt;code&gt;strip&lt;/code&gt; 同时去除空白和评注。</target>
        </trans-unit>
        <trans-unit id="1c04622cab5eac3fe5e20d1c189be97d2000ad23" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.ifexists&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">此选项采用与 &lt;code&gt;trailer.ifexists&lt;/code&gt; 配置变量相同的值，并且它将覆盖该选项为具有指定&amp;lt;token&amp;gt;的拖车指定的值。</target>
        </trans-unit>
        <trans-unit id="de59f6641e33166f78c75c60b985eacdf1d2a0ea" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.ifmissing&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">该选项采用与 &lt;code&gt;trailer.ifmissing&lt;/code&gt; 配置变量相同的值，并且它将覆盖该选项为具有指定&amp;lt;token&amp;gt;的拖车指定的值。</target>
        </trans-unit>
        <trans-unit id="6b156d8c8a67e1eaa9c71b8c4e454e308c17c450" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.where&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">该选项采用与 &lt;code&gt;trailer.where&lt;/code&gt; 配置变量相同的值，并且它将覆盖该选项为具有指定&amp;lt;token&amp;gt;的拖车指定的值。</target>
        </trans-unit>
        <trans-unit id="7df9ff293572a5c1527bce59783d9544419daa5b" translate="yes" xml:space="preserve">
          <source>This option tells where a new trailer will be added.</source>
          <target state="translated">这个选项告诉我们新的预告片将被添加到哪里。</target>
        </trans-unit>
        <trans-unit id="b36c69b0196d300061790058cdc0665affb9915e" translate="yes" xml:space="preserve">
          <source>This option tells which characters are recognized as trailer separators. By default only &lt;code&gt;:&lt;/code&gt; is recognized as a trailer separator, except that &lt;code&gt;=&lt;/code&gt; is always accepted on the command line for compatibility with other git commands.</source>
          <target state="translated">此选项告诉哪些字符被识别为尾部分隔符。默认情况下，仅 &lt;code&gt;:&lt;/code&gt; 被识别为尾部分隔符，但为了与其他git命令兼容，始终在命令行上接受 &lt;code&gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d89b4c86a97ff8d1caa3cc84d59173003c0040dc" translate="yes" xml:space="preserve">
          <source>This option will cause fast-export to issue a &quot;deleteall&quot; directive for each commit followed by a full list of all files in the commit (as opposed to just listing the files which are different from the commit&amp;rsquo;s first parent).</source>
          <target state="translated">此选项将导致快速导出为每个提交发出&amp;ldquo; deleteall&amp;rdquo;指令，后跟该提交中所有文件的完整列表（而不是仅列出与提交的第一个父文件不同的文件）。</target>
        </trans-unit>
        <trans-unit id="f143abcfc92e5721db51d7183ec9951b417133b6" translate="yes" xml:space="preserve">
          <source>This option will cause git-svn to attempt to automatically populate the svn:mergeinfo property in the SVN repository when possible. Currently, this can only be done when dcommitting non-fast-forward merges where all parents but the first have already been pushed into SVN.</source>
          <target state="translated">这个选项会让 git-svn 在可能的情况下尝试自动填充 SVN 仓库中的 svn:mergeinfo 属性。目前,只有在提交非快进式合并时,除了第一条以外的所有父版本都已经被推送到SVN中时,才能做到这一点。</target>
        </trans-unit>
        <trans-unit id="06697c041d5aacbd598da12e9917cf43b1b799c5" translate="yes" xml:space="preserve">
          <source>This option will cause the mapping from old to new objects to be loaded from named branch upon startup and saved as a new commit to that branch upon exit, enabling incremental of large trees. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does not exist it will be created.</source>
          <target state="translated">此选项将导致从旧对象到新对象的映射在启动时从命名分支加载，并在退出时另存为对该分支的新提交，从而启用大树的增量。如果 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 不存在，将创建它。</target>
        </trans-unit>
        <trans-unit id="dac1adaa75a920f5808dd15e4e9468c4b8319529" translate="yes" xml:space="preserve">
          <source>This output format is compatible with what &lt;code&gt;--index-info --stdin&lt;/code&gt; of &lt;code&gt;git update-index&lt;/code&gt; expects.</source>
          <target state="translated">这种输出格式是什么兼容 &lt;code&gt;--index-info --stdin&lt;/code&gt; 的 &lt;code&gt;git update-index&lt;/code&gt; 的期望。</target>
        </trans-unit>
        <trans-unit id="9b61a138f7f673e2e13a43bac58e20e6d27091cc" translate="yes" xml:space="preserve">
          <source>This outputs all the commit objects between the included and excluded commits, ordered by their distance to the included and excluded commits. Refs in &lt;code&gt;refs/bisect/&lt;/code&gt; are not used. The farthest from them is displayed first. (This is the only one displayed by &lt;code&gt;--bisect&lt;/code&gt;.)</source>
          <target state="translated">这将输出包含和排除提交之间的所有提交对象，并按它们到包含和排除提交的距离进行排序。未使用 &lt;code&gt;refs/bisect/&lt;/code&gt; 中的refs。离它们最远的位置将首先显示。（这是 &lt;code&gt;--bisect&lt;/code&gt; 显示的唯一一个。）</target>
        </trans-unit>
        <trans-unit id="c6b16b352aa83127a9d9220754dcd31555c3879e" translate="yes" xml:space="preserve">
          <source>This outputs something like this (the actual commit object names would be different)</source>
          <target state="translated">它的输出是这样的(实际的提交对象名称会有所不同</target>
        </trans-unit>
        <trans-unit id="05fcf2a461c52cf42967559d01dbd73ffe108135" translate="yes" xml:space="preserve">
          <source>This overrides a previous &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; setting and reads the default merge tool will be read from the configured &lt;code&gt;merge.tool&lt;/code&gt; variable.</source>
          <target state="translated">这将覆盖先前的 &lt;code&gt;-g&lt;/code&gt; 或 &lt;code&gt;--gui&lt;/code&gt; 设置，并从配置的 &lt;code&gt;merge.tool&lt;/code&gt; 变量中读取默认的合并工具。</target>
        </trans-unit>
        <trans-unit id="cf7619d964802ced013b07a7c34a4262a7e0e3f4" translate="yes" xml:space="preserve">
          <source>This page can be displayed with &lt;code&gt;git help help&lt;/code&gt; or &lt;code&gt;git help --help&lt;/code&gt;</source>
          <target state="translated">该页面可以显示 &lt;code&gt;git help help&lt;/code&gt; 或 &lt;code&gt;git help --help&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d990ef47ac594dcb10bc55890ec7a6963b3ffaed" translate="yes" xml:space="preserve">
          <source>This particular format is supplied as it&amp;rsquo;s short to implement and may be useful to a process that wants to create a new commit right now, without needing to use a working directory or &lt;code&gt;git update-index&lt;/code&gt;.</source>
          <target state="translated">提供这种特定格式是因为它的实现时间很短，它对于想要立即创建新提交的进程很有用，而无需使用工作目录或 &lt;code&gt;git update-index&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ace4cf0777df858ca1c6440d5cccb2ed6637934" translate="yes" xml:space="preserve">
          <source>This prints the name of a commit they are both based on. You should now look up the tree objects of those commits, which you can easily do with</source>
          <target state="translated">这将打印出它们都基于的提交的名称。现在您应该查找这些提交的树状对象,您可以使用</target>
        </trans-unit>
        <trans-unit id="65ce33f2a6f411ae54de75d77a4a5c5e2663fba3" translate="yes" xml:space="preserve">
          <source>This program computes which packs in your repository are redundant. The output is suitable for piping to &lt;code&gt;xargs rm&lt;/code&gt; if you are in the root of the repository.</source>
          <target state="translated">该程序计算存储库中的哪些包是多余的。如果您在存储库的根目录中，则该输出适合用于管道传输到 &lt;code&gt;xargs rm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dec60739fdc5804a4abedc6cf66847493211890" translate="yes" xml:space="preserve">
          <source>This program dumps the given revisions in a form suitable to be piped into &lt;code&gt;git fast-import&lt;/code&gt;.</source>
          <target state="translated">该程序将给定的修订版以适合管道传输到 &lt;code&gt;git fast-import&lt;/code&gt; 的形式转储。</target>
        </trans-unit>
        <trans-unit id="21943cdf9cd81593906492b86163eaa305da0be9" translate="yes" xml:space="preserve">
          <source>This program is usually not what the end user wants to run directly. Most end users want to use one of the existing frontend programs, which parses a specific type of foreign source and feeds the contents stored there to &lt;code&gt;git fast-import&lt;/code&gt;.</source>
          <target state="translated">该程序通常不是最终用户想要直接运行的程序。大多数最终用户都想使用现有的前端程序之一，该程序解析特定类型的外部源并将存储在那里的内容提供给 &lt;code&gt;git fast-import&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17acfb3fc2cc80c07ee41f3eeadca000eefd6ee0" translate="yes" xml:space="preserve">
          <source>This program searches the &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; for all objects that currently exist in a pack file as well as the independent object directories.</source>
          <target state="translated">该程序在 &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; 搜索包文件中当前存在的所有对象以及独立的对象目录。</target>
        </trans-unit>
        <trans-unit id="a85a25d731117b0f9fdffb50b50cd41a205c14dd" translate="yes" xml:space="preserve">
          <source>This public repository could further be mirrored, and that is how Git repositories at &lt;code&gt;kernel.org&lt;/code&gt; are managed.</source>
          <target state="translated">可以进一步镜像此公共存储库，这就是管理 &lt;code&gt;kernel.org&lt;/code&gt; 上的Git存储库的方式。</target>
        </trans-unit>
        <trans-unit id="3f74cf126c451b6a68e67763c97a8253f485453b" translate="yes" xml:space="preserve">
          <source>This puts a Git archive of the named CVS module in the directory &amp;lt;destination&amp;gt;, which will be created if necessary.</source>
          <target state="translated">这会将命名的CVS模块的Git存档放在目录&amp;lt;目标&amp;gt;中，该目录将在必要时创建。</target>
        </trans-unit>
        <trans-unit id="8831ce4f64ae931ef68e9c4eb0b8a48320fea478" translate="yes" xml:space="preserve">
          <source>This rebase can be performed using the &lt;code&gt;--rebase-merges&lt;/code&gt; option. It will generate a todo list looking like this:</source>
          <target state="translated">可以使用 &lt;code&gt;--rebase-merges&lt;/code&gt; 选项执行此重新设置。它将生成一个待办事项清单，如下所示：</target>
        </trans-unit>
        <trans-unit id="5e2dd779ca9f11c05d6bae58c7d8a031f404dc72" translate="yes" xml:space="preserve">
          <source>This ref is unchanged since the last import or fetch, although the helper cannot necessarily determine what value that produced.</source>
          <target state="translated">这个 ref 自上次导入或获取后没有变化,尽管帮助者不一定能确定产生了什么值。</target>
        </trans-unit>
        <trans-unit id="0e48a6f59fc5d06bf39a026582c3a2674a30ee86" translate="yes" xml:space="preserve">
          <source>This remote helper is transparently used by Git when you use commands such as &quot;git fetch &amp;lt;URL&amp;gt;&quot;, &quot;git clone &amp;lt;URL&amp;gt;&quot;, , &quot;git push &amp;lt;URL&amp;gt;&quot; or &quot;git remote add &amp;lt;nick&amp;gt; &amp;lt;URL&amp;gt;&quot;, where &amp;lt;URL&amp;gt; begins with &lt;code&gt;ext::&lt;/code&gt;. Examples:</source>
          <target state="translated">当您使用&amp;ldquo; git fetch &amp;lt;URL&amp;gt;&amp;rdquo;，&amp;ldquo; git clone &amp;lt;URL&amp;gt;&amp;rdquo;，&amp;ldquo; git push &amp;lt;URL&amp;gt;&amp;rdquo;或&amp;ldquo; git remote add &amp;lt;nick&amp;gt; &amp;lt;URL&amp;gt;&amp;rdquo;之类的命令时，Git会透明地使用此远程帮助器。 ，其中&amp;lt;URL&amp;gt;以 &lt;code&gt;ext::&lt;/code&gt; 开头。例子：</target>
        </trans-unit>
        <trans-unit id="76e69f76fb018209940d2bd178b055119cc99cef" translate="yes" xml:space="preserve">
          <source>This remote helper uses the specified &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; to connect to a remote Git server.</source>
          <target state="translated">该远程帮助程序使用指定的 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 连接到远程Git服务器。</target>
        </trans-unit>
        <trans-unit id="08f3058ad626936f077bcdb5101be9917b27eae0" translate="yes" xml:space="preserve">
          <source>This removes the &lt;code&gt;WIP&lt;/code&gt; commit from the commit history, and sets your working tree to the state just before you made that snapshot.</source>
          <target state="translated">这将从提交历史记录中删除 &lt;code&gt;WIP&lt;/code&gt; 提交，并将工作树设置为刚创建快照之前的状态。</target>
        </trans-unit>
        <trans-unit id="6cde691b95501235edce70baf30f3d475a6f05af" translate="yes" xml:space="preserve">
          <source>This removes the file from the index while keeping it in the working directory.</source>
          <target state="translated">这将从索引中删除文件,同时将其保留在工作目录中。</target>
        </trans-unit>
        <trans-unit id="f2e99bc05d5874bb5e940e93689126e6c4aa347e" translate="yes" xml:space="preserve">
          <source>This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the &lt;code&gt;recursive&lt;/code&gt; merge strategy.</source>
          <target state="translated">这样可以解析任意数量的head，但是合并的结果树始终是当前分支head的树，有效地忽略了所有其他分支的所有更改。它旨在取代侧支的旧开发历史。请注意，这与 &lt;code&gt;recursive&lt;/code&gt; 合并策略的-Xours选项不同。</target>
        </trans-unit>
        <trans-unit id="053dd73bd0ed92de95c5b132a1b4a0308f96cd04" translate="yes" xml:space="preserve">
          <source>This resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch.</source>
          <target state="translated">这可以解决两个以上头的情况,但拒绝做需要手动解决的复杂合并。它主要用于将主题分支头捆绑在一起。当拉取或合并多个分支时,这是默认的合并策略。</target>
        </trans-unit>
        <trans-unit id="e1337ea8d65ee53d09143c99f1f587dd31c2d238" translate="yes" xml:space="preserve">
          <source>This results in:</source>
          <target state="translated">这导致:</target>
        </trans-unit>
        <trans-unit id="a3acfff86d0ac3c7e1c1af7dc1decad57125efa5" translate="yes" xml:space="preserve">
          <source>This runs &lt;code&gt;git fsck --unreachable&lt;/code&gt; using all the refs available in &lt;code&gt;refs/&lt;/code&gt;, optionally with additional set of objects specified on the command line, and prunes all unpacked objects unreachable from any of these head objects from the object database. In addition, it prunes the unpacked objects that are also found in packs by running &lt;code&gt;git prune-packed&lt;/code&gt;. It also removes entries from .git/shallow that are not reachable by any ref.</source>
          <target state="translated">这将使用 &lt;code&gt;refs/&lt;/code&gt; 可用的所有ref 运行 &lt;code&gt;git fsck --unreachable&lt;/code&gt; ，还可以选择在命令行中指定其他对象集，并修剪所有从对象数据库中这些头对象中无法访问的所有未打包的对象。另外，它通过运行 &lt;code&gt;git prune-packed&lt;/code&gt; 来修剪在包中也可以找到的未打包对象。它还从.git / shallow中删除任何引用都无法访问的条目。</target>
        </trans-unit>
        <trans-unit id="66bb2cd044765c7338efb3b55d3b51e463e22970" translate="yes" xml:space="preserve">
          <source>This runs a virtual check-out and check-in of all three stages of a file when resolving a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See &quot;Merging branches with differing checkin/checkout attributes&quot; in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">解决三向合并时，这将对文件的所有三个阶段进行虚拟签出和签入。当合并具有不同原始过滤器或行尾规范化规则的分支时，应使用此选项。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]中的&lt;/a&gt; &amp;ldquo;合并具有不同签入/签出属性的分支&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="d37cfee1983b15d675f4e1a4163b8c978a492421" translate="yes" xml:space="preserve">
          <source>This says &quot;include everything in root, but nothing two levels below root.&quot;</source>
          <target state="translated">这句话说的是 &quot;把根部的所有东西都包括进去,但根部以下两层的东西都不包括进去&quot;。</target>
        </trans-unit>
        <trans-unit id="b3bd580b61f2b6d754a6c049f07ff919549d1439" translate="yes" xml:space="preserve">
          <source>This says &quot;include everything in root, but nothing two levels below root.&quot; If we then add the folder &lt;code&gt;A/B/C&lt;/code&gt; as a recursive pattern, the folders &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A/B&lt;/code&gt; are added as parent patterns. The resulting sparse-checkout file is now</source>
          <target state="translated">这表示&amp;ldquo;将所有内容都包含在根目录中，但不包括根目录下的两个级别&amp;rdquo;。如果随后将文件夹 &lt;code&gt;A/B/C&lt;/code&gt; 添加为递归模式，则文件夹 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;A/B&lt;/code&gt; 将作为父模式添加。现在生成的稀疏签出文件</target>
        </trans-unit>
        <trans-unit id="9f2fcd6a73ae4ce542d08fc5e7f799314e8e80fc" translate="yes" xml:space="preserve">
          <source>This script can be passed to &quot;git bisect run&quot; to find the commit that introduced a performance regression:</source>
          <target state="translated">这个脚本可以通过 &quot;git bisect run &quot;来找到引入性能回归的提交。</target>
        </trans-unit>
        <trans-unit id="72c86095923977328df35910b245e776428b840b" translate="yes" xml:space="preserve">
          <source>This script is included in various scripts to supply routines to parse files under $GIT_DIR/remotes/ and $GIT_DIR/branches/ and configuration variables that are related to fetching, pulling and pushing.</source>
          <target state="translated">这个脚本包含在各种脚本中,为解析$GIT_DIR/remotes/和$GIT_DIR/branches/下的文件提供例程,以及与取、拉、推相关的配置变量。</target>
        </trans-unit>
        <trans-unit id="0b782a6ea862c68f93c66ef721d84ace33a5ac1d" translate="yes" xml:space="preserve">
          <source>This script tries, as much as possible, to display the URLs and FILEs that are passed as arguments, as HTML pages in new tabs on an already opened web browser.</source>
          <target state="translated">这个脚本试图尽可能地将作为参数传递的URL和FILE以HTML页面的形式显示在已经打开的Web浏览器的新标签页中。</target>
        </trans-unit>
        <trans-unit id="a405ee4e7ff4cc67a738558081388543481850c0" translate="yes" xml:space="preserve">
          <source>This section can also be used by those who respond to &lt;code&gt;git
request-pull&lt;/code&gt; or pull-request on GitHub (www.github.com) to integrate the work of others into their history. A sub-area lieutenant for a repository will act both as a participant and as an integrator.</source>
          <target state="translated">响应GitHub（www.github.com）上的 &lt;code&gt;git request-pull&lt;/code&gt; 或pull-request 的人员也可以使用此部分，以将其他人的工作集成到他们的历史中。存储库的子区域副手将既充当参与者又充当集成者。</target>
        </trans-unit>
        <trans-unit id="53af582e47690e9820cb012bdcbccf97b8def7d3" translate="yes" xml:space="preserve">
          <source>This section explains how to configure some common webservers to run gitweb. In all cases, &lt;code&gt;/path/to/gitweb&lt;/code&gt; in the examples is the directory you ran installed gitweb in, and contains &lt;code&gt;gitweb_config.perl&lt;/code&gt;.</source>
          <target state="translated">本节说明如何配置一些常见的Web服务器以运行gitweb。在所有情况下，示例中的 &lt;code&gt;/path/to/gitweb&lt;/code&gt; 是您在其中安装gitweb的运行目录，其中包含 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79c0f1f15a38eae1b5cc2a5e381bfbc844ef9486" translate="yes" xml:space="preserve">
          <source>This section is only included if a packfile section is also included in the response.</source>
          <target state="translated">只有当响应中也包含Packfile部分时,才会包含这部分。</target>
        </trans-unit>
        <trans-unit id="f3cd5eb5a3885e012dabb05171cc566728c1791b" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git archive --remote&lt;/code&gt;. It is disabled by default, but a repository can enable it by setting &lt;code&gt;daemon.uploadarch&lt;/code&gt; configuration item to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这服务 &lt;code&gt;git archive --remote&lt;/code&gt; 。默认情况下禁用它，但是存储库可以通过将 &lt;code&gt;daemon.uploadarch&lt;/code&gt; 配置项设置为 &lt;code&gt;true&lt;/code&gt; 来启用它。</target>
        </trans-unit>
        <trans-unit id="a1fc9be9532fca80163bd11748e3553d0b5b85a4" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients. It is enabled by default, but a repository can disable it by setting &lt;code&gt;daemon.uploadpack&lt;/code&gt; configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">这为 &lt;code&gt;git fetch-pack&lt;/code&gt; 和 &lt;code&gt;git ls-remote&lt;/code&gt; 客户端提供服务。默认情况下启用它，但是存储库可以通过将 &lt;code&gt;daemon.uploadpack&lt;/code&gt; 配置项设置为 &lt;code&gt;false&lt;/code&gt; 来禁用它。</target>
        </trans-unit>
        <trans-unit id="ce507c3877f92fc6c1de609ca683d1e2a4e1b26f" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients. It is enabled by default, but a repository can disable it by setting this configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">这为 &lt;code&gt;git fetch-pack&lt;/code&gt; 和 &lt;code&gt;git ls-remote&lt;/code&gt; 客户端提供服务。默认情况下启用它，但是存储库可以通过将此配置项设置为 &lt;code&gt;false&lt;/code&gt; 来禁用它。</target>
        </trans-unit>
        <trans-unit id="f25bae0e6df9b1b4a76a588d485b17d422e56c18" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git send-pack&lt;/code&gt; clients, allowing anonymous push. It is disabled by default, as there is &lt;code&gt;no&lt;/code&gt; authentication in the protocol (in other words, anybody can push anything into the repository, including removal of refs). This is solely meant for a closed LAN setting where everybody is friendly. This service can be enabled by setting &lt;code&gt;daemon.receivepack&lt;/code&gt; configuration item to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这为 &lt;code&gt;git send-pack&lt;/code&gt; 客户端提供服务，允许匿名推送。默认情况下，它是禁用的，因为协议中 &lt;code&gt;no&lt;/code&gt; 身份验证（换句话说，任何人都可以将任何内容推送到存储库中，包括删除引用）。这仅适用于每个人都友好的封闭LAN设置。可以通过将 &lt;code&gt;daemon.receivepack&lt;/code&gt; 配置项设置为 &lt;code&gt;true&lt;/code&gt; 来启用此服务。</target>
        </trans-unit>
        <trans-unit id="6b2859849402fde4d51ffe73c129c97d00cb6083" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git send-pack&lt;/code&gt; clients, allowing push. It is disabled by default for anonymous users, and enabled by default for users authenticated by the web server. It can be disabled by setting this item to &lt;code&gt;false&lt;/code&gt;, or enabled for all users, including anonymous users, by setting it to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这为 &lt;code&gt;git send-pack&lt;/code&gt; 客户提供服务，允许推送。默认情况下，匿名用户禁用此功能，默认情况下，对于通过Web服务器认证的用户启用此功能。可以通过将此项目设置为 &lt;code&gt;false&lt;/code&gt; 来禁用它，或者通过将其设置为 &lt;code&gt;true&lt;/code&gt; 来为所有用户（包括匿名用户）启用。</target>
        </trans-unit>
        <trans-unit id="1d789007e515492a9cc42830b12a07ff1db6d084" translate="yes" xml:space="preserve">
          <source>This serves Git clients older than version 1.6.6 that are unable to use the upload pack service. When enabled, clients are able to read any file within the repository, including objects that are no longer reachable from a branch but are still present. It is enabled by default, but a repository can disable it by setting this configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">这为版本低于1.6.6的Git客户端提供服务，这些客户端无法使用上载包服务。启用后，客户端可以读取存储库中的任何文件，包括从分支不再可访问但仍然存在的对象。默认情况下启用它，但是存储库可以通过将此配置项设置为 &lt;code&gt;false&lt;/code&gt; 来禁用它。</target>
        </trans-unit>
        <trans-unit id="5456200c93d8963943eca093573a9d8938a4ea5f" translate="yes" xml:space="preserve">
          <source>This sets GIT_SVN_ID (instead of using the environment). This allows the user to override the default refname to fetch from when tracking a single URL. The &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;dcommit&lt;/code&gt; commands no longer require this switch as an argument.</source>
          <target state="translated">这将设置GIT_SVN_ID（而不是使用环境）。这允许用户在跟踪单个URL时覆盖要从中获取的默认refname。该 &lt;code&gt;log&lt;/code&gt; 和 &lt;code&gt;dcommit&lt;/code&gt; 命令不再需要这个开关作为参数。</target>
        </trans-unit>
        <trans-unit id="acb244d7aa46a820614aa10decb4464bc8ecabb6" translate="yes" xml:space="preserve">
          <source>This setting can be disabled by the &lt;code&gt;--no-notes&lt;/code&gt; option, overridden by the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable, and overridden by the &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt; option.</source>
          <target state="translated">可以通过 &lt;code&gt;--no-notes&lt;/code&gt; 选项禁用此设置，可以由 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 环境变量覆盖，而由 &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt; 选项覆盖。</target>
        </trans-unit>
        <trans-unit id="a8f435ef26eec94bd5c23846a74c0f4d57a87c8f" translate="yes" xml:space="preserve">
          <source>This setting can be overridden by passing the &lt;code&gt;--strategy&lt;/code&gt; option.</source>
          <target state="translated">可以通过传递 &lt;code&gt;--strategy&lt;/code&gt; 选项来覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="5d273f23cd160340c4f9b3fbc5a088c0fc2c32be" translate="yes" xml:space="preserve">
          <source>This setting can be overridden by the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable.</source>
          <target state="translated">可以通过 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 环境变量来覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="b28435a905552ea063d5203034696b428fdc0b87" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable, which must be a colon separated list of refs or globs.</source>
          <target state="translated">可以使用 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 环境变量来覆盖此设置，该环境变量必须是用冒号分隔的ref或glob列表。</target>
        </trans-unit>
        <trans-unit id="45473aa6b3903d5487aab6b473bcf528e266cdec" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_MODE&lt;/code&gt; environment variable.</source>
          <target state="translated">可以使用 &lt;code&gt;GIT_NOTES_REWRITE_MODE&lt;/code&gt; 环境变量来覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="39555b916eeeec115f6735665b5426bf964f4e52" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable, which must be a colon separated list of refs or globs.</source>
          <target state="translated">可以使用 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 环境变量来覆盖此设置，该环境变量必须是用冒号分隔的ref或glob列表。</target>
        </trans-unit>
        <trans-unit id="d17d74e5aa80b06bd416eb43f1c510767efc6dc8" translate="yes" xml:space="preserve">
          <source>This setting defaults to &quot;refs/notes/commits&quot;, and it can be overridden by the &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; environment variable. See &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;.</source>
          <target state="translated">此设置默认为&amp;ldquo; refs / notes / commits&amp;rdquo;，并且可以被 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 环境变量覆盖。参见&lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="843f7e48b1e3c030c426060d83a399e29388c249" translate="yes" xml:space="preserve">
          <source>This setting forces Git to normalize line endings for this file on checkin and convert them to CRLF when the file is checked out.</source>
          <target state="translated">这个设置会强制 Git 在签入时对该文件的行尾进行标准化处理,并在签出时将其转换为 CRLF。</target>
        </trans-unit>
        <trans-unit id="8c7bb001c250cfdf4247d252deb09b8b2c2a2839" translate="yes" xml:space="preserve">
          <source>This setting forces Git to normalize line endings to LF on checkin and prevents conversion to CRLF when the file is checked out.</source>
          <target state="translated">这个设置会强制 Git 在签入时将行尾规范化为 LF,并防止在签出时转换为 CRLF。</target>
        </trans-unit>
        <trans-unit id="886fc853da603148f91948f5793a0d1be70dc28a" translate="yes" xml:space="preserve">
          <source>This setting is automatically guessed by &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; when the repository was created. By default a repository that ends in &quot;/.git&quot; is assumed to be not bare (bare = false), while all other repositories are assumed to be bare (bare = true).</source>
          <target state="translated">创建存储库时，&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;或&lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt;会自动猜测此设置。默认情况下，以&amp;ldquo; /.git&amp;rdquo;结尾的存储库被假定为裸机（裸=假），而所有其他存储库被假定为裸机（裸= true）。</target>
        </trans-unit>
        <trans-unit id="a32da40367d476cb817ba2cfa99cb18bc04a7b3a" translate="yes" xml:space="preserve">
          <source>This setting overrides the default of the &lt;code&gt;--cleanup&lt;/code&gt; option in &lt;code&gt;git commit&lt;/code&gt;. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for details. Changing the default can be useful when you always want to keep lines that begin with comment character &lt;code&gt;#&lt;/code&gt; in your log message, in which case you would do &lt;code&gt;git config commit.cleanup whitespace&lt;/code&gt; (note that you will have to remove the help lines that begin with &lt;code&gt;#&lt;/code&gt; in the commit log template yourself, if you do this).</source>
          <target state="translated">此设置将覆盖 &lt;code&gt;git commit&lt;/code&gt; 中的 &lt;code&gt;--cleanup&lt;/code&gt; 选项的默认设置。有关详细信息，请参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;。当您始终希望在日志消息中保留以注释字符 &lt;code&gt;#&lt;/code&gt; 开头的行时，更改默认值会很有用，在这种情况下，您需要执行 &lt;code&gt;git config commit.cleanup whitespace&lt;/code&gt; （请注意，您必须删除以开头的帮助行 &lt;code&gt;#&lt;/code&gt; ，您自己可以在提交日志模板中）。</target>
        </trans-unit>
        <trans-unit id="e85001143ab4f6109a8db79b80d46592a3792b5e" translate="yes" xml:space="preserve">
          <source>This setting should be set to a comma-separated list of color and date settings, starting and ending with a color, the dates should be set from oldest to newest. The metadata will be colored given the colors if the line was introduced before the given timestamp, overwriting older timestamped colors.</source>
          <target state="translated">该设置应设置为以逗号分隔的颜色和日期设置列表,以颜色开始和结束,日期应从最旧到最新设置。如果该行是在给定时间戳之前引入的,元数据将被赋予颜色,覆盖较旧的时间戳颜色。</target>
        </trans-unit>
        <trans-unit id="1b39995bc064271da90ffd3401f4ace36766db6f" translate="yes" xml:space="preserve">
          <source>This setting writes a JSON-based format that is suited for machine interpretation. See &lt;code&gt;GIT_TRACE2&lt;/code&gt; for available trace output options and &lt;a href=&quot;api-trace2&quot;&gt;Trace2 documentation&lt;/a&gt; for full details.</source>
          <target state="translated">此设置将编写适合机器解释的基于JSON的格式。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE2&lt;/code&gt; ；有关完整的详细信息，请参见Trace2 &lt;a href=&quot;api-trace2&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d727921c238e28668ffb0dd7e4775077e3d6b368" translate="yes" xml:space="preserve">
          <source>This should be a colon-separated list of absolute paths. If set, it is a list of directories that Git should not chdir up into while looking for a repository directory (useful for excluding slow-loading network directories). It will not exclude the current working directory or a GIT_DIR set on the command line or in the environment. Normally, Git has to read the entries in this list and resolve any symlink that might be present in order to compare them with the current directory. However, if even this access is slow, you can add an empty entry to the list to tell Git that the subsequent entries are not symlinks and needn&amp;rsquo;t be resolved; e.g., &lt;code&gt;GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink&lt;/code&gt;.</source>
          <target state="translated">这应该是用冒号分隔的绝对路径列表。如果设置，则它是Git在查找存储库目录时不应该进入的目录列表（用于排除缓慢加载的网络目录）。它不会排除当前的工作目录或在命令行或环境中设置的GIT_DIR。通常，Git必须读取此列表中的条目并解析可能出现的任何符号链接，以便将它们与当前目录进行比较。但是，即使访问速度很慢，您也可以在列表中添加一个空条目，以告知Git后续条目不是符号链接，不需要解析；例如， &lt;code&gt;GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02391ad98329bedcf2ddfbe7ebdef774e4e7cc67" translate="yes" xml:space="preserve">
          <source>This should help you to submit patches inline using KMail.</source>
          <target state="translated">这应该可以帮助你使用KMail在线提交补丁。</target>
        </trans-unit>
        <trans-unit id="dc65a8c75ec971d079e04ac05264e8ee2fb908c8" translate="yes" xml:space="preserve">
          <source>This should make &quot;--pretty=oneline&quot; a whole lot more readable for people using 80-column terminals.</source>
          <target state="translated">这将使&quot;-pretty=oneline &quot;对于使用80列终端的人来说更加易读。</target>
        </trans-unit>
        <trans-unit id="cda899a68420b48633046b1cef20e4960b467a9e" translate="yes" xml:space="preserve">
          <source>This should make it easy to look up svn log messages when svn users refer to -r/--revision numbers.</source>
          <target state="translated">当svn用户参考-r/--revision号码时,这应该可以很容易地查找svn日志信息。</target>
        </trans-unit>
        <trans-unit id="3fce0b9f9a8369808848ec3f066c1735323bb111" translate="yes" xml:space="preserve">
          <source>This should not be confused with the &lt;code&gt;ours&lt;/code&gt; merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring &lt;code&gt;our&lt;/code&gt; history contains all that happened in it.</source>
          <target state="translated">这不应与 &lt;code&gt;ours&lt;/code&gt; 合并策略混淆，该策略甚至根本不看另一棵树包含的内容。它丢弃了另一棵树所做的一切，声明 &lt;code&gt;our&lt;/code&gt; 历史包含其中发生的所有事件。</target>
        </trans-unit>
        <trans-unit id="70d0ce2d7e7f48cdf303b28228ad271bde0b97ac" translate="yes" xml:space="preserve">
          <source>This shows that our resolved version deleted &quot;Hello world&quot; from the first parent, deleted &quot;Goodbye&quot; from the second parent, and added &quot;Goodbye world&quot;, which was previously absent from both.</source>
          <target state="translated">由此可见,我们的解决版删除了第一个父体中的 &quot;Hello world&quot;,删除了第二个父体中的 &quot;Goodbye&quot;,增加了之前两个父体都没有的 &quot;Goodbye world&quot;。</target>
        </trans-unit>
        <trans-unit id="e0fbc89a9eb1f686d88b41839c951cd18b86bf5e" translate="yes" xml:space="preserve">
          <source>This shows that you can do without a run script if you write the test on a single line.</source>
          <target state="translated">这说明,如果你把测试写在单行上,可以不用运行脚本。</target>
        </trans-unit>
        <trans-unit id="f580a082428b40358ee35f346bb87b38bbd6e3f8" translate="yes" xml:space="preserve">
          <source>This shows the change between HEAD and index (i.e. what will be committed if you say &lt;code&gt;git commit&lt;/code&gt;), and between index and working tree files (i.e. what you could stage further before &lt;code&gt;git commit&lt;/code&gt; using &lt;code&gt;git add&lt;/code&gt;) for each path. A sample output looks like this:</source>
          <target state="translated">这显示了每个路径的HEAD和index之间的变化（即，如果您说 &lt;code&gt;git commit&lt;/code&gt; ，将提交什么），以及索引和工作树文件之间的变化（即，您可以在使用 &lt;code&gt;git add&lt;/code&gt; 的 &lt;code&gt;git commit&lt;/code&gt; 之前进行进一步的转换）。示例输出如下所示：</target>
        </trans-unit>
        <trans-unit id="cdedf9c4235065dcc3b6a065543c259879fefa6b" translate="yes" xml:space="preserve">
          <source>This shows the files and directories to be deleted and issues an &quot;Input ignore patterns&amp;gt;&amp;gt;&quot; prompt. You can input space-separated patterns to exclude files and directories from deletion. E.g. &quot;*.c *.h&quot; will excludes files end with &quot;.c&quot; and &quot;.h&quot; from deletion. When you are satisfied with the filtered result, press ENTER (empty) back to the main menu.</source>
          <target state="translated">这显示了要删除的文件和目录，并发出&amp;ldquo;输入忽略模式&amp;gt;&amp;gt;&amp;rdquo;提示。您可以输入以空格分隔的模式，以从删除中排除文件和目录。例如，&amp;ldquo; *。c * .h&amp;rdquo;将删除以&amp;ldquo; .c&amp;rdquo;和&amp;ldquo; .h&amp;rdquo;结尾的文件。当您对过滤后的结果感到满意时，请按ENTER（空）回到主菜单。</target>
        </trans-unit>
        <trans-unit id="d76da1518821bfa115def32fd19d8e8b1e73d979" translate="yes" xml:space="preserve">
          <source>This shows the files and directories to be deleted and issues an &quot;Select items to delete&amp;gt;&amp;gt;&quot; prompt. When the prompt ends with double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; like this, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. &quot;2-5 7,9&quot; to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining items are selected. E.g. &quot;7-&quot; to choose 7,8,9 from the list. You can say &lt;code&gt;*&lt;/code&gt; to choose everything. Also when you are satisfied with the filtered result, press ENTER (empty) back to the main menu.</source>
          <target state="translated">这将显示要删除的文件和目录，并发出&amp;ldquo;选择要删除的项目&amp;gt;&amp;gt;&amp;rdquo;提示。当提示符以double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 这样结束时，您可以进行多个选择，并与空格或逗号连接。您也可以说范围。例如，&amp;ldquo; 2-5 7,9&amp;rdquo;从列表中选择2,3,4,5,7,9。如果省略范围中的第二个数字，则将选择所有剩余的项目。例如，&amp;ldquo; 7-&amp;rdquo;从列表中选择7,8,9。您可以说 &lt;code&gt;*&lt;/code&gt; 选择所有内容。同样，当您对过滤后的结果感到满意时，请按ENTER（空白）回到主菜单。</target>
        </trans-unit>
        <trans-unit id="53f59db63b45945049b0fe262d831991c1cb4a8d" translate="yes" xml:space="preserve">
          <source>This shows the status information and issues an &quot;Update&amp;gt;&amp;gt;&quot; prompt. When the prompt ends with double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. &quot;2-5 7,9&quot; to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining patches are taken. E.g. &quot;7-&quot; to choose 7,8,9 from the list. You can say &lt;code&gt;*&lt;/code&gt; to choose everything.</source>
          <target state="translated">这将显示状态信息并发出&amp;ldquo; Update &amp;gt;&amp;gt;&amp;rdquo;提示。当提示以双 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 结束时，您可以选择多个选项，并用空格或逗号连接。您也可以说范围。例如，&amp;ldquo; 2-5 7,9&amp;rdquo;从列表中选择2,3,4,5,7,9。如果忽略范围中的第二个数字，则会获取所有剩余的色块。例如，&amp;ldquo; 7-&amp;rdquo;从列表中选择7,8,9。您可以说 &lt;code&gt;*&lt;/code&gt; 选择所有内容。</target>
        </trans-unit>
        <trans-unit id="728eb7da1f0f1bff86889f4ac114a7967bd3817f" translate="yes" xml:space="preserve">
          <source>This snapshot is now stored in a temporary staging area which Git calls the &quot;index&quot;. You can permanently store the contents of the index in the repository with &lt;code&gt;git commit&lt;/code&gt;:</source>
          <target state="translated">现在，此快照存储在Git称为&amp;ldquo;索引&amp;rdquo;的临时登台区域中。您可以使用 &lt;code&gt;git commit&lt;/code&gt; 将索引的内容永久存储在存储库中：</target>
        </trans-unit>
        <trans-unit id="dfa3a419f48a4609a0668c69a143f543612e713a" translate="yes" xml:space="preserve">
          <source>This solution is not 100% bulletproof, in the sense that if some project has a named ref (branch, tag) starting with &lt;code&gt;git/&lt;/code&gt;, then paths such as</source>
          <target state="translated">从某种意义上说，如果某个项目具有以 &lt;code&gt;git/&lt;/code&gt; 开头的命名ref（分支，标签），则此解决方案不是100％防弹的</target>
        </trans-unit>
        <trans-unit id="02da975953020f9ebbe3388889e8a8406f05d0c7" translate="yes" xml:space="preserve">
          <source>This step and the next one could be combined into a single step with &quot;checkout -b my2.6.14 v2.6.14&quot;.</source>
          <target state="translated">这一步和下一步可以用 &quot;checkout -b my2.6.14 v2.6.14 &quot;合并成一个步骤。</target>
        </trans-unit>
        <trans-unit id="8693cc187fd5fbc9d2b5824a59520cb3030a07eb" translate="yes" xml:space="preserve">
          <source>This string config option provides a way to specify one of a few recommended schedules for background maintenance. This only affects which tasks are run during &lt;code&gt;git maintenance run --schedule=X&lt;/code&gt; commands, provided no &lt;code&gt;--task=&amp;lt;task&amp;gt;&lt;/code&gt; arguments are provided. Further, if a &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.schedule&lt;/code&gt; config value is set, then that value is used instead of the one provided by &lt;code&gt;maintenance.strategy&lt;/code&gt;. The possible strategy strings are:</source>
          <target state="translated">此字符串配置选项提供了一种方法，可以指定一些建议的后台维护计划之一。只要不提供 &lt;code&gt;--task=&amp;lt;task&amp;gt;&lt;/code&gt; 参数，这只会影响在 &lt;code&gt;git maintenance run --schedule=X&lt;/code&gt; 命令期间运行的任务。此外，如果设置了 &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.schedule&lt;/code&gt; 配置值，那么将使用该值而不是 &lt;code&gt;maintenance.strategy&lt;/code&gt; 提供的值。可能的策略字符串为：</target>
        </trans-unit>
        <trans-unit id="9b0b980e437fd3274de63464aa9184e42833d899" translate="yes" xml:space="preserve">
          <source>This suffix is also accepted when spelled in uppercase, and means the same thing no matter the case.</source>
          <target state="translated">这个后缀在拼成大写时也被接受,无论大小写都是一样的意思。</target>
        </trans-unit>
        <trans-unit id="01f381d8f83cae139b7e7ff06573574ebdbc8086" translate="yes" xml:space="preserve">
          <source>This supersedes the &lt;a href=&quot;#post-update&quot;&gt;&lt;em&gt;post-update&lt;/em&gt;&lt;/a&gt; hook in that it gets both old and new values of all the refs in addition to their names.</source>
          <target state="translated">这取代了&lt;a href=&quot;#post-update&quot;&gt;&lt;em&gt;更新后&lt;/em&gt;&lt;/a&gt;钩子，因为它除了获得所有引用的名称之外，还获取所有引用的旧值和新值。</target>
        </trans-unit>
        <trans-unit id="6339f7da558022ed0ae10f566dd01f30bb047e19" translate="yes" xml:space="preserve">
          <source>This synchronizes your public repository to match the named branch head (i.e. &lt;code&gt;master&lt;/code&gt; in this case) and objects reachable from them in your current repository.</source>
          <target state="translated">这将使您的公共存储库同步，以匹配命名的分支头（在这种情况下为 &lt;code&gt;master&lt;/code&gt; ）和在当前存储库中可从中访问的对象。</target>
        </trans-unit>
        <trans-unit id="0012e2584fc653cc03e6dda35ea11cbdc9f6c1a2" translate="yes" xml:space="preserve">
          <source>This syntax is only recognized if there are no slashes before the first colon. This helps differentiate a local path that contains a colon. For example the local path &lt;code&gt;foo:bar&lt;/code&gt; could be specified as an absolute path or &lt;code&gt;./foo:bar&lt;/code&gt; to avoid being misinterpreted as an ssh url.</source>
          <target state="translated">仅当第一个冒号之前没有斜杠时才能识别此语法。这有助于区分包含冒号的本地路径。例如，可以将本地路径 &lt;code&gt;foo:bar&lt;/code&gt; 指定为绝对路径，或者将 &lt;code&gt;./foo:bar&lt;/code&gt; 指定为避免被误解为ssh url。</target>
        </trans-unit>
        <trans-unit id="9f5d9872e03f1e6dd55415fa2249d9c84ea6f738" translate="yes" xml:space="preserve">
          <source>This takes a text file each of whose lines is a shell glob pattern. Filepairs that match a glob pattern on an earlier line in the file are output before ones that match a later line, and filepairs that do not match any glob pattern are output last.</source>
          <target state="translated">它接收一个文本文件,其每一行都是一个 shell glob 模式。匹配文件中较早一行的 glob 模式的文件对会在匹配较晚一行的文件对之前输出,不匹配任何 glob 模式的文件对会最后输出。</target>
        </trans-unit>
        <trans-unit id="b169549655fddd825e67d14c1591493d6ac0be03" translate="yes" xml:space="preserve">
          <source>This target is intended to be more of a summary (like GIT_TRACE) and less detailed than the other targets. It ignores thread, region, and data messages, for example.</source>
          <target state="translated">这个目标的目的是更多的是一个摘要(像GIT_TRACE),而不是像其他目标那样详细。例如,它忽略了线程、区域和数据消息。</target>
        </trans-unit>
        <trans-unit id="49bec15344e0cef74269dabec868d060f4c1b07d" translate="yes" xml:space="preserve">
          <source>This tells the bisect process that no commit after &lt;code&gt;v2.5&lt;/code&gt;, up to and including &lt;code&gt;v2.6&lt;/code&gt;, should be tested.</source>
          <target state="translated">这告诉bisect流程，在 &lt;code&gt;v2.5&lt;/code&gt; 之后（直到 &lt;code&gt;v2.6&lt;/code&gt; )（包括v2.6），不应该测试任何提交。</target>
        </trans-unit>
        <trans-unit id="1842bab1269e00a8bf77d06ee23570861225cc48" translate="yes" xml:space="preserve">
          <source>This tells the bisect process that the commits between &lt;code&gt;v2.5&lt;/code&gt; and &lt;code&gt;v2.6&lt;/code&gt; (inclusive) should be skipped.</source>
          <target state="translated">这告诉bisect进程应跳过 &lt;code&gt;v2.5&lt;/code&gt; 和 &lt;code&gt;v2.6&lt;/code&gt; （含）之间的提交。</target>
        </trans-unit>
        <trans-unit id="fb42c5eea9f7afe3662a07fd6af3c3105ab04e8f" translate="yes" xml:space="preserve">
          <source>This tells you that the immediately following version of the file was &quot;newsha&quot;, and that the immediately preceding version was &quot;oldsha&quot;. You also know the commit messages that went with the change from oldsha to 4b9458b and with the change from 4b9458b to newsha.</source>
          <target state="translated">这告诉你,紧接着文件的版本是 &quot;newsha&quot;,而之前的版本是 &quot;oldsha&quot;。你也知道从oldsha到4b9458b和从4b9458b到newsha的提交信息。</target>
        </trans-unit>
        <trans-unit id="055a35e65dbf599ed555247ef03e1960ff509b55" translate="yes" xml:space="preserve">
          <source>This tool is invoked via the typical Git setup process, which means that in some cases, it might not be able to launch - for example, if a relevant config file is unreadable. In this kind of scenario, it may be helpful to manually gather the kind of information listed above when manually asking for help.</source>
          <target state="translated">这个工具是通过典型的 Git 设置过程来调用的,这意味着在某些情况下,它可能无法启动-例如,如果相关配置文件无法读取。在这种情况下,在手动求助时,手动收集上面列出的那种信息可能会有帮助。</target>
        </trans-unit>
        <trans-unit id="8f1179423f3ea23a6c9e525ef159db41c1155b6a" translate="yes" xml:space="preserve">
          <source>This transformation is used to detect renames and copies, and is controlled by the -M option (to detect renames) and the -C option (to detect copies as well) to the &lt;code&gt;git diff-*&lt;/code&gt; commands. If the input contained these filepairs:</source>
          <target state="translated">此转换用于检测重命名和副本，并由 &lt;code&gt;git diff-*&lt;/code&gt; 命令的-M选项（用于检测重命名）和-C选项（也用于检测副本）控制。如果输入包含以下文件对：</target>
        </trans-unit>
        <trans-unit id="573190bccf8f2a4ea6fc33eedd23b4b8fc3f90f8" translate="yes" xml:space="preserve">
          <source>This transformation is used to merge filepairs broken by diffcore-break, and not transformed into rename/copy by diffcore-rename, back into a single modification. This always runs when diffcore-break is used.</source>
          <target state="translated">这个转换用于将被 diffcore-break 打断的文件对,以及没有被 diffcore-rename 转化为 rename/copy 的文件对,合并为一个修改。当使用diffcore-break时,这个转换总是会运行。</target>
        </trans-unit>
        <trans-unit id="448726c2164ad1aa28f4d84dcd657bc466764287" translate="yes" xml:space="preserve">
          <source>This transformation limits the set of filepairs to those that change specified strings between the preimage and the postimage in a certain way. -S&amp;lt;block of text&amp;gt; and -G&amp;lt;regular expression&amp;gt; options are used to specify different ways these strings are sought.</source>
          <target state="translated">这种转换将文件对的集合限制为以某种方式更改前映像和后映像之间的指定字符串的文件对。-S &amp;lt;文本块&amp;gt;和-G &amp;lt;正则表达式&amp;gt;选项用于指定搜索这些字符串的不同方式。</target>
        </trans-unit>
        <trans-unit id="eb01f7c28a2e42a179d9ca76727e0a7db6bb8dce" translate="yes" xml:space="preserve">
          <source>This transport can be used for both uploading and downloading, and requires you to have a log-in privilege over &lt;code&gt;ssh&lt;/code&gt; to the remote machine. It finds out the set of objects the other side lacks by exchanging the head commits both ends have and transfers (close to) minimum set of objects. It is by far the most efficient way to exchange Git objects between repositories.</source>
          <target state="translated">此传输可用于上载和下载，并且要求您具有通过 &lt;code&gt;ssh&lt;/code&gt; 登录到远程计算机的登录特权。它通过交换两端的头提交并转移（接近）最小对象集来找出另一侧缺少的对象集。到目前为止，这是在存储库之间交换Git对象的最有效方法。</target>
        </trans-unit>
        <trans-unit id="1e93313475dc2966a9b364d25d3e63ddb92cd35d" translate="yes" xml:space="preserve">
          <source>This transport is the same as SSH transport but uses &lt;code&gt;sh&lt;/code&gt; to run both ends on the local machine instead of running other end on the remote machine via &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">此传输与SSH传输相同，但是使用 &lt;code&gt;sh&lt;/code&gt; 在本地计算机上运行两端，而不是通过 &lt;code&gt;ssh&lt;/code&gt; 在远程计算机上运行另一端。</target>
        </trans-unit>
        <trans-unit id="187c060b77919e40b0db07be6c4444d6bedf0f1f" translate="yes" xml:space="preserve">
          <source>This transport was designed for anonymous downloading. Like SSH transport, it finds out the set of objects the downstream side lacks and transfers (close to) minimum set of objects.</source>
          <target state="translated">这种传输是为匿名下载设计的。像SSH传输一样,它找出下游方缺少的对象集,并传输(接近)最小对象集。</target>
        </trans-unit>
        <trans-unit id="a843c4941e9eb68216876c91a59842ae7d058faa" translate="yes" xml:space="preserve">
          <source>This tutorial explains how to import a new project into Git, make changes to it, and share changes with other developers.</source>
          <target state="translated">本教程介绍了如何将一个新项目导入Git,对其进行修改,并与其他开发者分享修改。</target>
        </trans-unit>
        <trans-unit id="586b98337ae35b657ccc9687b72106b49b3b174b" translate="yes" xml:space="preserve">
          <source>This tutorial explains how to use the &quot;core&quot; Git commands to set up and work with a Git repository.</source>
          <target state="translated">本教程将介绍如何使用 &quot;核心 &quot;Git命令来设置和使用Git仓库。</target>
        </trans-unit>
        <trans-unit id="4f3b7287fc4739a451de38537fb0637003a134c1" translate="yes" xml:space="preserve">
          <source>This tutorial should be enough to perform basic distributed revision control for your projects. However, to fully understand the depth and power of Git you need to understand two simple ideas on which it is based:</source>
          <target state="translated">这篇教程应该足以让你对项目进行基本的分布式修订控制。然而,要想充分理解 Git 的深度和威力,你需要了解它所基于的两个简单的理念。</target>
        </trans-unit>
        <trans-unit id="50b7797bad77b49520127714ff8a716873aad978" translate="yes" xml:space="preserve">
          <source>This updates (or creates, as necessary) branches &lt;code&gt;pu&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt; in the local repository by fetching from the branches (respectively) &lt;code&gt;pu&lt;/code&gt; and &lt;code&gt;maint&lt;/code&gt; from the remote repository.</source>
          <target state="translated">通过从远程存储库中的 &lt;code&gt;pu&lt;/code&gt; 和 &lt;code&gt;maint&lt;/code&gt; 分别获取分支，从而更新（或根据需要创建）本地存储库中的 &lt;code&gt;pu&lt;/code&gt; 和 &lt;code&gt;tmp&lt;/code&gt; 分支。</target>
        </trans-unit>
        <trans-unit id="3e7d31bbe83aa073e1058fe02ef8026a34345709" translate="yes" xml:space="preserve">
          <source>This updates (or creates, as necessary) branches &lt;code&gt;seen&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt; in the local repository by fetching from the branches (respectively) &lt;code&gt;seen&lt;/code&gt; and &lt;code&gt;maint&lt;/code&gt; from the remote repository.</source>
          <target state="translated">通过从远程存储库中分别 &lt;code&gt;seen&lt;/code&gt; 和 &lt;code&gt;maint&lt;/code&gt; 的分支中获取，这将更新（或根据需要创建）本地存储库中 &lt;code&gt;seen&lt;/code&gt; 和 &lt;code&gt;tmp&lt;/code&gt; 的分支。</target>
        </trans-unit>
        <trans-unit id="70ac0b727096d7231e8fdcdd112d1a04551c8ca8" translate="yes" xml:space="preserve">
          <source>This used to be the default, but not since Git 2.0 (&lt;code&gt;simple&lt;/code&gt; is the new default).</source>
          <target state="translated">这曾经是默认设置，但自Git 2.0起就没有了（ &lt;code&gt;simple&lt;/code&gt; 是新的默认设置）。</target>
        </trans-unit>
        <trans-unit id="fd75f35034e73b98112aaaf4198ee488b9e51804" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;--interactive&lt;/code&gt; machinery internally, but combining it with the &lt;code&gt;--interactive&lt;/code&gt; option explicitly is generally not a good idea unless you know what you are doing (see BUGS below).</source>
          <target state="translated">这在内部使用 &lt;code&gt;--interactive&lt;/code&gt; 机制，但是除非明确知道您在做什么，否则将它与 &lt;code&gt;--interactive&lt;/code&gt; 选项显式结合通常不是一个好主意（请参阅下面的BUGS）。</target>
        </trans-unit>
        <trans-unit id="665eaff82148d49a545a97a7903a8bf0d3754608" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;--interactive&lt;/code&gt; machinery internally, but it can be run without an explicit &lt;code&gt;--interactive&lt;/code&gt;.</source>
          <target state="translated">这在内部使用 &lt;code&gt;--interactive&lt;/code&gt; 机制，但无需显式 &lt;code&gt;--interactive&lt;/code&gt; 即可运行。</target>
        </trans-unit>
        <trans-unit id="5a59444b879ae5151f30b1cffe08974240ac7bdc" translate="yes" xml:space="preserve">
          <source>This uses the same two-dot range notation we saw earlier with &lt;code&gt;git log&lt;/code&gt;.</source>
          <target state="translated">这使用了我们之前在 &lt;code&gt;git log&lt;/code&gt; 中看到的相同的两点范围符号。</target>
        </trans-unit>
        <trans-unit id="94dc29f5a82c88ac8ea06389eebe7535e89a6fb1" translate="yes" xml:space="preserve">
          <source>This value is true by default in a repository that has a working directory associated with it, and false by default in a bare repository.</source>
          <target state="translated">这个值在有工作目录的版本库中默认为true,在裸版本库中默认为false。</target>
        </trans-unit>
        <trans-unit id="73a34f84ecc165ae3643b28ecca4c6c41f197412" translate="yes" xml:space="preserve">
          <source>This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value &quot;user&quot; indicates that the archiving user&amp;rsquo;s umask will be used instead. See umask(2) and &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt;.</source>
          <target state="translated">此变量可用于限制tar归档条目的权限位。默认值为0002，它将关闭世界写入位。特殊值&amp;ldquo; user&amp;rdquo;指示将改为使用归档用户的umask。参见umask（2）和&lt;a href=&quot;git-archive&quot;&gt;git-archive [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63a384d932515032afb2060852ce18cd5598c9ca" translate="yes" xml:space="preserve">
          <source>This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value &quot;user&quot; indicates that the archiving user&amp;rsquo;s umask will be used instead. See umask(2) for details. If &lt;code&gt;--remote&lt;/code&gt; is used then only the configuration of the remote repository takes effect.</source>
          <target state="translated">此变量可用于限制tar归档条目的权限位。默认值为0002，它将关闭世界写入位。特殊值&amp;ldquo; user&amp;rdquo;指示将改为使用归档用户的umask。有关详细信息，请参见umask（2）。如果使用 &lt;code&gt;--remote&lt;/code&gt; ，则仅远程存储库的配置生效。</target>
        </trans-unit>
        <trans-unit id="0afce327e7d4311118de1c5dc2faa8fa7a291053" translate="yes" xml:space="preserve">
          <source>This variable controls the event target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">此变量控制事件目标的目的地。它可以被 &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; 环境变量覆盖。下表显示了可能的值。</target>
        </trans-unit>
        <trans-unit id="b3073c2a2c3930628fae47eb515e2fe5729910f0" translate="yes" xml:space="preserve">
          <source>This variable controls the normal target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">此变量控制正常的目标位置。它可以被 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 环境变量覆盖。下表显示了可能的值。</target>
        </trans-unit>
        <trans-unit id="ab644894061fa15fc115b6d355d07c2965277303" translate="yes" xml:space="preserve">
          <source>This variable controls the performance target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">此变量控制性能目标。它可以被 &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; 环境变量覆盖。下表显示了可能的值。</target>
        </trans-unit>
        <trans-unit id="53008d90e6aae985c2e7839a77d7b54894ce429e" translate="yes" xml:space="preserve">
          <source>This variable controls the sort ordering of branches when displayed by &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;. Without the &quot;--sort=&amp;lt;value&amp;gt;&quot; option provided, the value of this variable will be used as the default. See &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt; field names for valid values.</source>
          <target state="translated">当由&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;显示时，此变量控制分支的排序顺序。如果不提供&amp;ldquo; --sort = &amp;lt;值&amp;gt;&amp;rdquo;选项，则此变量的值将用作默认值。有关有效值，请参见&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt;字段名称。</target>
        </trans-unit>
        <trans-unit id="ea1c7eb75a360c1f9f69915dbc32e427ddfb7ced" translate="yes" xml:space="preserve">
          <source>This variable controls the sort ordering of tags when displayed by &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;. Without the &quot;--sort=&amp;lt;value&amp;gt;&quot; option provided, the value of this variable will be used as the default.</source>
          <target state="translated">当由&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;显示时，此变量控制标签的排序顺序。如果不提供&amp;ldquo; --sort = &amp;lt;值&amp;gt;&amp;rdquo;选项，则此变量的值将用作默认值。</target>
        </trans-unit>
        <trans-unit id="c2680b6925a4a160ca8f3fee892cc23ec9be5f4f" translate="yes" xml:space="preserve">
          <source>This variable determines the default value for variables such as &lt;code&gt;color.diff&lt;/code&gt; and &lt;code&gt;color.grep&lt;/code&gt; that control the use of color per command family. Its scope will expand as more commands learn configuration to set a default for the &lt;code&gt;--color&lt;/code&gt; option. Set it to &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;never&lt;/code&gt; if you prefer Git commands not to use color unless enabled explicitly with some other configuration or the &lt;code&gt;--color&lt;/code&gt; option. Set it to &lt;code&gt;always&lt;/code&gt; if you want all output not intended for machine consumption to use color, to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt; (this is the default since Git 1.8.4) if you want such output to use color when written to the terminal.</source>
          <target state="translated">此变量确定诸如 &lt;code&gt;color.diff&lt;/code&gt; 和 &lt;code&gt;color.grep&lt;/code&gt; 之类的变量的默认值，这些变量控制每个命令系列对颜色的使用。随着更多命令学习配置以设置 &lt;code&gt;--color&lt;/code&gt; 选项的默认值，其范围将扩大。如果您不希望Git命令不使用颜色，除非将其与其他配置或 &lt;code&gt;--color&lt;/code&gt; 选项一起显式启用，否则将其设置为 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;never&lt;/code&gt; 设置颜色。将其设置为 &lt;code&gt;always&lt;/code&gt; ，如果你想不用于机器消耗的用色，所有输出 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;auto&lt;/code&gt; ，如果你想这样的输出使用的颜色，当写入到终端（这是因为Git的1.8.4默认值）。</target>
        </trans-unit>
        <trans-unit id="2eb6f1e33d90fc7fb4373fa1793932292fbc650d" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;transfer.hideRefs&lt;/code&gt;, but applies only to &lt;code&gt;receive-pack&lt;/code&gt; (and so affects pushes, but not fetches). An attempt to update or delete a hidden ref by &lt;code&gt;git push&lt;/code&gt; is rejected.</source>
          <target state="translated">此变量与 &lt;code&gt;transfer.hideRefs&lt;/code&gt; 相同，但仅适用于 &lt;code&gt;receive-pack&lt;/code&gt; （因此影响推送，但不影响提取）。拒绝通过 &lt;code&gt;git push&lt;/code&gt; 更新或删除隐藏引用的尝试。</target>
        </trans-unit>
        <trans-unit id="763a368531eb9d8bc40e93c6334e049f21620c45" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;transfer.hideRefs&lt;/code&gt;, but applies only to &lt;code&gt;upload-pack&lt;/code&gt; (and so affects only fetches, not pushes). An attempt to fetch a hidden ref by &lt;code&gt;git fetch&lt;/code&gt; will fail. See also &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt;.</source>
          <target state="translated">此变量与 &lt;code&gt;transfer.hideRefs&lt;/code&gt; 相同，但仅适用于 &lt;code&gt;upload-pack&lt;/code&gt; （因此仅影响提取，不影响推送）。尝试通过 &lt;code&gt;git fetch&lt;/code&gt; 提取隐藏的引用将失败。另请参见 &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75aa35a44ffd767e8a239dc01347d150ce1e39ed" translate="yes" xml:space="preserve">
          <source>This variable matters only when using persistent web environments that serve multiple requests using single gitweb instance, like mod_perl, FastCGI or Plackup.</source>
          <target state="translated">这个变量只有在使用持久化的网络环境,如mod_perl、FastCGI或Plackup,使用单个gitweb实例来服务多个请求时才有意义。</target>
        </trans-unit>
        <trans-unit id="c0526214b5c55d639fefd6a92d93b97ec2455930" translate="yes" xml:space="preserve">
          <source>This variable specifies a shell command through which the tar output generated by &lt;code&gt;git archive&lt;/code&gt; should be piped. The command is executed using the shell with the generated tar file on its standard input, and should produce the final output on its standard output. Any compression-level options will be passed to the command (e.g., &quot;-9&quot;). An output file with the same extension as &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; will be use this format if no other format is given.</source>
          <target state="translated">该变量指定一个shell命令，通过该命令可以将 &lt;code&gt;git archive&lt;/code&gt; 生成的tar输出通过管道传输。该命令是使用Shell执行的，其标准输入上带有生成的tar文件，并且应在其标准输出上生成最终输出。任何压缩级别的选项都将传递给命令（例如&amp;ldquo; -9&amp;rdquo;）。如果未指定其他格式，则扩展名与 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 相同的输出文件将使用此格式。</target>
        </trans-unit>
        <trans-unit id="99ffcf0d1fc58b3934082bac9786637cf3a8cdad" translate="yes" xml:space="preserve">
          <source>This view is similar to &lt;code&gt;shortlog&lt;/code&gt; view.</source>
          <target state="translated">该视图类似于 &lt;code&gt;shortlog&lt;/code&gt; 视图。</target>
        </trans-unit>
        <trans-unit id="16ae6576174eeb48325f0bfa3042bcb20d29d417" translate="yes" xml:space="preserve">
          <source>This was not the case in the initial release of this feature in v2.13.0, which only matched the realpath version. Configuration that wants to be compatible with the initial release of this feature needs to either specify only the realpath version, or both versions.</source>
          <target state="translated">这个功能在v2.13.0的初始版本中并不是这样的,它只匹配realpath版本。想要与该功能初始版本兼容的配置,需要只指定realpath版本,或者两个版本都指定。</target>
        </trans-unit>
        <trans-unit id="7c8d457b197b5558b7abfe068bcd1974205f94ad" translate="yes" xml:space="preserve">
          <source>This was optional in prior versions of git, but now it is the default. You can use &lt;code&gt;--no-utf8&lt;/code&gt; to override this.</source>
          <target state="translated">这在以前的git版本中是可选的，但现在是默认设置。您可以使用 &lt;code&gt;--no-utf8&lt;/code&gt; 覆盖它。</target>
        </trans-unit>
        <trans-unit id="314df942d006c94c85d3e8c8bfe0a0b8ef8308d1" translate="yes" xml:space="preserve">
          <source>This will again prompt you for a message describing the change, and then record a new version of the project.</source>
          <target state="translated">这将再次提示你输入描述更改的信息,然后记录项目的新版本。</target>
        </trans-unit>
        <trans-unit id="53cca56aaa41c3093032e1d720cb620b22717e06" translate="yes" xml:space="preserve">
          <source>This will cache the result of running &quot;exif&quot; on each blob indefinitely. If you change the textconv config variable for a diff driver, Git will automatically invalidate the cache entries and re-run the textconv filter. If you want to invalidate the cache manually (e.g., because your version of &quot;exif&quot; was updated and now produces better output), you can remove the cache manually with &lt;code&gt;git update-ref -d refs/notes/textconv/jpg&lt;/code&gt; (where &quot;jpg&quot; is the name of the diff driver, as in the example above).</source>
          <target state="translated">这将无限期地缓存在每个Blob上运行&amp;ldquo; exif&amp;rdquo;的结果。如果您更改了diff驱动程序的textconv配置变量，Git将自动使缓存条目无效并重新运行textconv过滤器。如果您想手动使缓存无效（例如，因为您的&amp;ldquo; exif&amp;rdquo;版本已更新，现在可以产生更好的输出），则可以使用 &lt;code&gt;git update-ref -d refs/notes/textconv/jpg&lt;/code&gt; （其中&amp;ldquo; jpg&amp;rdquo;是差异驱动程序的名称，如上例所示。</target>
        </trans-unit>
        <trans-unit id="3d17cc7dd2b4aac7e00ecd2628dbb99eefd074c7" translate="yes" xml:space="preserve">
          <source>This will cause Git to generate &lt;code&gt;Binary files differ&lt;/code&gt; (or a binary patch, if binary patches are enabled) instead of a regular diff.</source>
          <target state="translated">这将导致Git生成 &lt;code&gt;Binary files differ&lt;/code&gt; 常规差异的Binary文件（或二进制补丁，如果启用了二进制补丁）。</target>
        </trans-unit>
        <trans-unit id="dac66330b2bd98fcf90352c4cbeba694c8f4feb3" translate="yes" xml:space="preserve">
          <source>This will check out the currently cached copy of &lt;code&gt;Makefile&lt;/code&gt; into the file &lt;code&gt;.merged-Makefile&lt;/code&gt;.</source>
          <target state="translated">这会将当前缓存的 &lt;code&gt;Makefile&lt;/code&gt; 副本 &lt;code&gt;.merged-Makefile&lt;/code&gt; 到文件.merged-Makefile中。</target>
        </trans-unit>
        <trans-unit id="9acb73cd9d17d8ef0d5dfd6af35ea9d0a50c12ab" translate="yes" xml:space="preserve">
          <source>This will create a new commit which undoes the change in HEAD. You will be given a chance to edit the commit message for the new commit.</source>
          <target state="translated">这将创建一个新的提交,撤销对 HEAD 的修改。您将有机会编辑新提交的提交信息。</target>
        </trans-unit>
        <trans-unit id="85437cd96f5cff3dd194d542498fd954d1bf1e01" translate="yes" xml:space="preserve">
          <source>This will define a remote called &quot;origin&quot; in the resulting repository that lets you fetch and pull from the bundle. The $GIT_DIR/config file in R2 will have an entry like this:</source>
          <target state="translated">这将在生成的版本库中定义一个名为 &quot;origin &quot;的远程,让你从捆绑包中获取和拉取。在R2的$GIT_DIR/config文件中会有这样的条目。</target>
        </trans-unit>
        <trans-unit id="2986121c6e711f05b2ed0ba772dedbd8c66503ff" translate="yes" xml:space="preserve">
          <source>This will error out if $REV is empty or not a valid revision.</source>
          <target state="translated">如果$REV为空或不是一个有效的版本,这将会出错。</target>
        </trans-unit>
        <trans-unit id="c8b7e8566771f37a03bc25eaec95675ffe82ba31" translate="yes" xml:space="preserve">
          <source>This will export the whole repository and import it into the existing empty repository. Except for reencoding commits that are not in UTF-8, it would be a one-to-one mirror.</source>
          <target state="translated">这将导出整个版本库,并将其导入到现有的空版本库中。除了重新编码非 UTF-8 的提交,这将是一个一对一的镜像。</target>
        </trans-unit>
        <trans-unit id="5f851e29f67384fe2f487309701055635453a02c" translate="yes" xml:space="preserve">
          <source>This will list what commits you must have in order to extract from the bundle and will error out if you do not have them.</source>
          <target state="translated">这将列出你必须有哪些提交才能从 bundle 中提取,如果你没有这些提交,就会出错。</target>
        </trans-unit>
        <trans-unit id="7ed8616207d4b6e51bdcbe1e7b524863a0139782" translate="yes" xml:space="preserve">
          <source>This will open your editor with a list of steps to be taken to perform your rebase.</source>
          <target state="translated">这将打开你的编辑器,并列出执行你的重垒的步骤。</target>
        </trans-unit>
        <trans-unit id="e9e68cbb3d1c11da9ad7575ebecc630d58996f10" translate="yes" xml:space="preserve">
          <source>This will prompt you for a commit message. You&amp;rsquo;ve now stored the first version of your project in Git.</source>
          <target state="translated">这将提示您输入提交消息。现在，您已将项目的第一个版本存储在Git中。</target>
        </trans-unit>
        <trans-unit id="9229da0c83ee0b71f5a22085b5f3b7e07e9ec55a" translate="yes" xml:space="preserve">
          <source>This will remove each of your commits from mywork, temporarily saving them as patches (in a directory named &lt;code&gt;.git/rebase-apply&lt;/code&gt;), update mywork to point at the latest version of origin, then apply each of the saved patches to the new mywork. The result will look like:</source>
          <target state="translated">这将从mywork中删除您的每个提交，将它们临时保存为补丁（在名为 &lt;code&gt;.git/rebase-apply&lt;/code&gt; 的目录中），更新mywork以指向最新的原始版本，然后将每个保存的补丁应用于新的mywork 。结果将如下所示：</target>
        </trans-unit>
        <trans-unit id="1c98be5284d00528a6b74a33ba778d044a767668" translate="yes" xml:space="preserve">
          <source>This will result in only b (a and c are cleared).</source>
          <target state="translated">这将导致只有b(a和c被清除)。</target>
        </trans-unit>
        <trans-unit id="6c3d93fc8322db7b61293784540f1a03e7fd486e" translate="yes" xml:space="preserve">
          <source>This will run &lt;code&gt;git -C &amp;lt;repo&amp;gt; maintenance run&lt;/code&gt; for each value &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; in the multi-valued config variable &lt;code&gt;maintenance.repo&lt;/code&gt;.</source>
          <target state="translated">这将对多值配置变量 &lt;code&gt;maintenance.repo&lt;/code&gt; 中的每个值 &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; 运行 &lt;code&gt;git -C &amp;lt;repo&amp;gt; maintenance run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0385ed25689cd3e1167020ff6e8ba549d1603871" translate="yes" xml:space="preserve">
          <source>This will set the property &lt;code&gt;svn:keywords&lt;/code&gt; to &lt;code&gt;FreeBSD=%H&lt;/code&gt; for the file &lt;code&gt;devel/py-tipper/Makefile&lt;/code&gt;.</source>
          <target state="translated">这会将文件 &lt;code&gt;devel/py-tipper/Makefile&lt;/code&gt; 的 &lt;code&gt;svn:keywords&lt;/code&gt; 属性设置为 &lt;code&gt;FreeBSD=%H&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61383e31770f578e5ee86310440dccd09a4e5008" translate="yes" xml:space="preserve">
          <source>This will show &quot;refs/heads/master&quot; but also &quot;refs/remote/other-repo/master&quot;, if such references exists.</source>
          <target state="translated">这将显示 &quot;refs/heads/master&quot;,但也会显示 &quot;refs/remote/other-repo/master&quot;,如果存在这样的引用的话。</target>
        </trans-unit>
        <trans-unit id="23dd2de32c54566f1df1adf9f6794600102b9c2b" translate="yes" xml:space="preserve">
          <source>This will start to clean, and you must confirm one by one in order to delete items. Please note that this action is not as efficient as the above two actions.</source>
          <target state="translated">这样就会开始清理,必须逐一确认才能删除项目。请注意,这个动作的效率不如以上两个动作。</target>
        </trans-unit>
        <trans-unit id="9b7bbd24afc1c6a470a80ef47d5171b33809ea28" translate="yes" xml:space="preserve">
          <source>This works for any of the supported update procedures (&lt;code&gt;--checkout&lt;/code&gt;, &lt;code&gt;--rebase&lt;/code&gt;, etc.). The only change is the source of the target SHA-1. For example, &lt;code&gt;submodule update --remote --merge&lt;/code&gt; will merge upstream submodule changes into the submodules, while &lt;code&gt;submodule update
--merge&lt;/code&gt; will merge superproject gitlink changes into the submodules.</source>
          <target state="translated">这适用于任何受支持的更新过程（ &lt;code&gt;--checkout&lt;/code&gt; ，-- &lt;code&gt;--rebase&lt;/code&gt; 等）。唯一的变化是目标SHA-1的来源。例如， &lt;code&gt;submodule update --remote --merge&lt;/code&gt; 将上游子模块更改合并到子模块中，而 &lt;code&gt;submodule update --merge&lt;/code&gt; 将超级项目gitlink更改合并到子模块中。</target>
        </trans-unit>
        <trans-unit id="5a2ee7840b76b59e3aede30738fb578b292bc5f3" translate="yes" xml:space="preserve">
          <source>This works similarly to &lt;code&gt;svn update&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt; except that it preserves linear history with &lt;code&gt;git rebase&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt; for ease of dcommitting with &lt;code&gt;git svn&lt;/code&gt;.</source>
          <target state="translated">这与 &lt;code&gt;svn update&lt;/code&gt; 或 &lt;code&gt;git pull&lt;/code&gt; 相似，除了它使用 &lt;code&gt;git rebase&lt;/code&gt; 而不是 &lt;code&gt;git merge&lt;/code&gt; 保留线性历史记录，以便于 &lt;code&gt;git svn&lt;/code&gt; 提交。</target>
        </trans-unit>
        <trans-unit id="5bc6c0e59c3e651570d66e12101e9a57040fd659" translate="yes" xml:space="preserve">
          <source>This would leave only one merge commit when your topic branch is finally ready and merged into the master branch. This merge would require you to resolve the conflict, introduced by the commits marked with &lt;code&gt;*&lt;/code&gt;. However, this conflict is often the same conflict you resolved when you created the test merge you blew away. &lt;code&gt;git rerere&lt;/code&gt; helps you resolve this final conflicted merge using the information from your earlier hand resolve.</source>
          <target state="translated">当您的主题分支最终准备好并合并到master分支中时，这将只留下一个合并提交。这种合并将需要您解决由 &lt;code&gt;*&lt;/code&gt; 标记的提交引起的冲突。但是，此冲突通常与您创建的测试合并所消除的冲突相同。 &lt;code&gt;git rerere&lt;/code&gt; 帮助您使用较早的手动解决方法中的信息来解决此最终冲突的合并。</target>
        </trans-unit>
        <trans-unit id="dcd6f908de988995d9fff4cafd75d14bc0785c1a" translate="yes" xml:space="preserve">
          <source>This would leave the merge result in &lt;code&gt;hello.c~2&lt;/code&gt; file, along with conflict markers if there are conflicts. After verifying the merge result makes sense, you can tell Git what the final merge result for this file is by:</source>
          <target state="translated">如果存在冲突，这会将合并结果以及冲突标记保留在 &lt;code&gt;hello.c~2&lt;/code&gt; 文件中。验证合并结果有意义之后，可以通过以下方式告诉Git该文件的最终合并结果是什么：</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="ee3cacca7314105556d3050112f523980e59f973" translate="yes" xml:space="preserve">
          <source>Those snapshots aren&amp;rsquo;t necessarily all arranged in a single line from oldest to newest; instead, work may simultaneously proceed along parallel lines of development, called &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;, which may merge and diverge.</source>
          <target state="translated">这些快照不必从最旧到最新全部排列在一行中。取而代之的是，工作可以同时沿着并行的发展路线（称为&lt;a href=&quot;#def_branch&quot;&gt;分支）进行&lt;/a&gt;，分支可以合并和发散。</target>
        </trans-unit>
        <trans-unit id="7a5a53a50d0fbac4f3a27d9d2d5853146557d940" translate="yes" xml:space="preserve">
          <source>Though not required, it&amp;rsquo;s a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.</source>
          <target state="translated">尽管不是必需的，但最好以一条简短的（少于50个字符的）短行来概述所有更改，然后是空行，再进行更详尽的描述，以开始提交消息。直到提交消息中的第一行空白为止的文本都被视为提交标题，并且该标题在整个Git中都使用。例如，&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;将提交转换为电子邮件，并在主题行上使用标题，在正文中使用其余提交。</target>
        </trans-unit>
        <trans-unit id="fdd6ea0498f5dbe48e6926bc8c91e77146fa2184" translate="yes" xml:space="preserve">
          <source>Though, according to Wikipedia &lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt;:</source>
          <target state="translated">不过，根据维基百科&lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="18c9e3ce5bbbf77af11ba41f4d7a7d9b7a1aaa55" translate="yes" xml:space="preserve">
          <source>Thread Events</source>
          <target state="translated">主题活动</target>
        </trans-unit>
        <trans-unit id="8850eee2783cf53d0af71d524467316d7d06a850" translate="yes" xml:space="preserve">
          <source>Thread messages added to a thread-proc.</source>
          <target state="translated">线程消息添加到线程程序中。</target>
        </trans-unit>
        <trans-unit id="1501e9d814d273ed34cc6b50f1b5e25add4ac049" translate="yes" xml:space="preserve">
          <source>Three other shorthands exist, particularly useful for merge commits, for naming a set that is formed by a commit and its parent commits.</source>
          <target state="translated">另外还有三个速记,对于合并提交特别有用,用于命名一个由提交和其父提交组成的集合。</target>
        </trans-unit>
        <trans-unit id="8e23a87c8354d34eb4b513798d76048267e22ae4" translate="yes" xml:space="preserve">
          <source>Three steps:</source>
          <target state="translated">三个步骤。</target>
        </trans-unit>
        <trans-unit id="cf3d01be00b3333c6ca36b4d1bb0a1a1c357a43f" translate="yes" xml:space="preserve">
          <source>Throw-away integration</source>
          <target state="translated">抛弃式整合</target>
        </trans-unit>
        <trans-unit id="c4780f4837eebde8ca1de31df251ef05e2361eb2" translate="yes" xml:space="preserve">
          <source>Thunderbird</source>
          <target state="translated">Thunderbird</target>
        </trans-unit>
        <trans-unit id="d5e84648e0355ba1080675ff57a3c64a03a76a7c" translate="yes" xml:space="preserve">
          <source>Thunderbird in particular is known to be problematic. Thunderbird users may wish to visit this web page for more information: &lt;a href=&quot;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&quot;&gt;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&lt;/a&gt;</source>
          <target state="translated">尤其是雷鸟是有问题的。Thunderbird用户可能希望访问此网页以获取更多信息：&lt;a href=&quot;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&quot;&gt;http&lt;/a&gt; : //kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email</target>
        </trans-unit>
        <trans-unit id="da473e9b687406079cfbc2672fddb50595865b5d" translate="yes" xml:space="preserve">
          <source>Thus we see that this tree has one file in it. The SHA-1 hash is a reference to that file&amp;rsquo;s data:</source>
          <target state="translated">因此，我们看到该树中有一个文件。SHA-1哈希是对该文件数据的引用：</target>
        </trans-unit>
        <trans-unit id="309fb29079c2e5019b9d34cb235aee0452735a40" translate="yes" xml:space="preserve">
          <source>Thus you can, e.g., turn a library subdirectory into a repository of its own. Note the &lt;code&gt;--&lt;/code&gt; that separates &lt;code&gt;filter-branch&lt;/code&gt; options from revision options, and the &lt;code&gt;--all&lt;/code&gt; to rewrite all branches and tags.</source>
          <target state="translated">因此，您可以，例如，将库子目录变成其自己的存储库。请注意 &lt;code&gt;--&lt;/code&gt; 将 &lt;code&gt;filter-branch&lt;/code&gt; 选项与修订选项分开，以及 &lt;code&gt;--all&lt;/code&gt; 重写所有分支和标记。</target>
        </trans-unit>
        <trans-unit id="d35ca4f0ad7715e9f69a7f979c2424eb99273503" translate="yes" xml:space="preserve">
          <source>Thus, the following command:</source>
          <target state="translated">因此,下面的命令。</target>
        </trans-unit>
        <trans-unit id="77cc1ec67e1af48d92e062ee397960be200bdf58" translate="yes" xml:space="preserve">
          <source>Thus, we can provide O(log N) lookup time for any number of packfiles.</source>
          <target state="translated">因此,我们可以为任何数量的packfiles提供O(log N)的查找时间。</target>
        </trans-unit>
        <trans-unit id="ae19d34e63a0724afdaaeabe3d0fe80af7f9e778" translate="yes" xml:space="preserve">
          <source>Time and date specified by the ISO 8601 standard, for example &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;. The parser accepts a space instead of the &lt;code&gt;T&lt;/code&gt; character as well.</source>
          <target state="translated">ISO 8601标准指定的时间和日期，例如 &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; 。解析器也接受空格而不是 &lt;code&gt;T&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="3919d9be78625e6edbfd2764a9b0e03204c6c677" translate="yes" xml:space="preserve">
          <source>Time and date specified by the ISO 8601 standard, for example &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;. The parser accepts a space instead of the &lt;code&gt;T&lt;/code&gt; character as well. Fractional parts of a second will be ignored, for example &lt;code&gt;2005-04-07T22:13:13.019&lt;/code&gt; will be treated as &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;.</source>
          <target state="translated">ISO 8601标准指定的时间和日期，例如 &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; 。解析器也接受空格而不是 &lt;code&gt;T&lt;/code&gt; 字符。秒的小数部分将被忽略，例如 &lt;code&gt;2005-04-07T22:13:13.019&lt;/code&gt; 将被视为 &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bac72478f018c225224e8417f521a2dad6209d3" translate="yes" xml:space="preserve">
          <source>Time zone values can be &quot;local&quot; (for local time zone that browser uses), &quot;utc&quot; (what gitweb uses when JavaScript or this feature is disabled), or numerical time zones in the form of &quot;+/-HHMM&quot;, such as &quot;+0200&quot;.</source>
          <target state="translated">时区值可以是 &quot;local&quot;(浏览器使用的本地时区)、&quot;utc&quot; (当JavaScript或此功能被禁用时,gitweb使用的),或 &quot;+/-hhmm &quot;形式的数字时区,如 &quot;+0200&quot;。</target>
        </trans-unit>
        <trans-unit id="396a560fd1658574279d941c34737eda5359f4fc" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) between the moment the connection is established and the client request is received (typically a rather low value, since that should be basically immediate).</source>
          <target state="translated">从建立连接到收到客户端请求之间的超时时间(以秒为单位)(通常是一个相当低的值,因为这基本上应该是即时的)。</target>
        </trans-unit>
        <trans-unit id="0ae2f4dfeb0fa0aaf2833b3c271308d2190a4162" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) for specific client sub-requests. This includes the time it takes for the server to process the sub-request and the time spent waiting for the next client&amp;rsquo;s request.</source>
          <target state="translated">特定客户端子请求的超时（以秒为单位）。这包括服务器处理子请求所花费的时间以及等待下一个客户端请求所花费的时间。</target>
        </trans-unit>
        <trans-unit id="ad6b83abe0aada0e5e6aec8e7e7470429fd4ee37" translate="yes" xml:space="preserve">
          <source>Tips and tricks</source>
          <target state="translated">提示和技巧</target>
        </trans-unit>
        <trans-unit id="d7242682d2f91b131962f45ed3706e536d3cdcc6" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; more than two &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;.</source>
          <target state="translated">要&lt;a href=&quot;#def_merge&quot;&gt;合并&lt;/a&gt;两个以上的&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7305ba472ceab96976009902e7b731f8e52f311" translate="yes" xml:space="preserve">
          <source>To access refs, it&amp;rsquo;s best not to look inside &lt;code&gt;$GIT_DIR&lt;/code&gt; directly. Instead use commands such as &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; or &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref[1]&lt;/a&gt; which will handle refs correctly.</source>
          <target state="translated">要访问引用，最好不要直接查看 &lt;code&gt;$GIT_DIR&lt;/code&gt; 。而是使用诸如&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt;或&lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref [1]之类的命令&lt;/a&gt;来正确处理引用。</target>
        </trans-unit>
        <trans-unit id="7c181af3380fe2a4df836df7796a5de6ef8d47c5" translate="yes" xml:space="preserve">
          <source>To access refs, it&amp;rsquo;s best not to look inside GIT_DIR directly. Instead use commands such as &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; or &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref[1]&lt;/a&gt; which will handle refs correctly.</source>
          <target state="translated">要访问引用，最好不要直接查看GIT_DIR。而是使用诸如&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt;或&lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref [1]之类的命令&lt;/a&gt;来正确处理引用。</target>
        </trans-unit>
        <trans-unit id="bdc5ec95e827bdeffd1f9aab0bef5dd1e05d0443" translate="yes" xml:space="preserve">
          <source>To achieve this, try to split your work into small steps from the very beginning. It is always easier to squash a few commits together than to split one big commit into several. Don&amp;rsquo;t be afraid of making too small or imperfect steps along the way. You can always go back later and edit the commits with &lt;code&gt;git rebase --interactive&lt;/code&gt; before you publish them. You can use &lt;code&gt;git stash push --keep-index&lt;/code&gt; to run the test suite independent of other uncommitted changes; see the EXAMPLES section of &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">为此，请从一开始就尝试将您的工作分成几个小步骤。将几个提交挤压在一起总是比将一个大提交分成几份要容易得多。不要害怕沿途走得太小或不完美。您始终可以稍后再返回，并在发布之前使用 &lt;code&gt;git rebase --interactive&lt;/code&gt; 编辑提交。您可以使用 &lt;code&gt;git stash push --keep-index&lt;/code&gt; 独立于其他未提交的更改来运行测试套件。参见&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;的示例部分。</target>
        </trans-unit>
        <trans-unit id="0fad63887775e60c970096082173b077cbcda459" translate="yes" xml:space="preserve">
          <source>To actually match only values with an exclamation mark, you have to</source>
          <target state="translated">要想实际只匹配带感叹号的值,你需要</target>
        </trans-unit>
        <trans-unit id="0fea0d3a69770ac7053eba17165f8f811c0d830f" translate="yes" xml:space="preserve">
          <source>To add a new proxy, without altering any of the existing ones, use</source>
          <target state="translated">要添加一个新的代理,而不改变任何现有的代理,使用</target>
        </trans-unit>
        <trans-unit id="6a37f3f129452efb4608e170beca8c23ff8dc189" translate="yes" xml:space="preserve">
          <source>To aid in debugging frontends fast-import ignores any line that begins with &lt;code&gt;#&lt;/code&gt; (ASCII pound/hash) up to and including the line ending &lt;code&gt;LF&lt;/code&gt;. A comment line may contain any sequence of bytes that does not contain an LF and therefore may be used to include any detailed debugging information that might be specific to the frontend and useful when inspecting a fast-import data stream.</source>
          <target state="translated">为了帮助调试前端，快速导入会忽略任何以 &lt;code&gt;#&lt;/code&gt; （ASCII磅/哈希）开头的行，直到 &lt;code&gt;LF&lt;/code&gt; 为止。注释行可以包含不包含LF的任何字节序列，因此可以用来包含任何详细的调试信息，这些信息可能特定于前端，并且在检查快速导入数据流时很有用。</target>
        </trans-unit>
        <trans-unit id="285359187a2aff04e4ea763b2f3e4bbaf641190b" translate="yes" xml:space="preserve">
          <source>To assist in this, Git also provides the tag object&amp;hellip;​</source>
          <target state="translated">为此，Git还提供了标签对象...</target>
        </trans-unit>
        <trans-unit id="39ed0e01aa6b6521a62db21f8653937d0b5ccadd" translate="yes" xml:space="preserve">
          <source>To avoid common misconfiguration mistakes, &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; will abort with a warning if any configuration options for &quot;sendmail&quot; exist. Set this variable to bypass the check.</source>
          <target state="translated">为了避免常见的错误配置错误，如果存在&amp;ldquo; sendmail&amp;rdquo;的任何配置选项，则&lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt;将中止并显示警告。设置此变量以绕过检查。</target>
        </trans-unit>
        <trans-unit id="b0021f1eb05e23f63eb7ccc2f58c52546ee61585" translate="yes" xml:space="preserve">
          <source>To avoid deadlock, such frontends must completely consume any pending output from &lt;code&gt;progress&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;get-mark&lt;/code&gt;, and &lt;code&gt;cat-blob&lt;/code&gt; before performing writes to fast-import that might block.</source>
          <target state="translated">为避免死锁，此类前端必须完全消耗 &lt;code&gt;progress&lt;/code&gt; ， &lt;code&gt;ls&lt;/code&gt; ， &lt;code&gt;get-mark&lt;/code&gt; 和 &lt;code&gt;cat-blob&lt;/code&gt; 的所有待处理输出，然后再执行可能会阻止的快速导入的写操作。</target>
        </trans-unit>
        <trans-unit id="75e1daad195d404dc835c71216234df4a4676d4e" translate="yes" xml:space="preserve">
          <source>To avoid deleting a shared index file that is still used, its modification time is updated to the current time every time a new split index based on the shared index file is either created or read from.</source>
          <target state="translated">为了避免删除仍在使用的共享索引文件,每次创建或读取基于共享索引文件的新拆分索引时,其修改时间都会更新为当前时间。</target>
        </trans-unit>
        <trans-unit id="0b95bb4f949904cf33707d2a81be23c345f8e5aa" translate="yes" xml:space="preserve">
          <source>To avoid false positives (e.g. when a patch has been removed, and an unrelated patch has been added between two iterations of the same patch series), the cost matrix is extended to allow for that, by adding fixed-cost entries for wholesale deletes/adds.</source>
          <target state="translated">为了避免误报(例如,当一个补丁被删除,而在同一补丁系列的两次迭代之间又增加了一个不相关的补丁),成本矩阵进行了扩展,增加了大量删除/增加补丁的固定成本条目,以考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="0fd573776931ed5e5643654b60eb3896366ed973" translate="yes" xml:space="preserve">
          <source>To avoid interfering with other worktrees, it first enables the &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; setting and makes sure to set the &lt;code&gt;core.sparseCheckout&lt;/code&gt; setting in the worktree-specific config file.</source>
          <target state="translated">为了避免干扰其他工作树，它首先启用 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 设置，并确保在特定于工作树的配置文件中设置 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="3c2082115575958e10a9c1afdaf9ab0c9127b12a" translate="yes" xml:space="preserve">
          <source>To avoid recording unrelated changes in the merge commit, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; will also abort if there are any changes registered in the index relative to the &lt;code&gt;HEAD&lt;/code&gt; commit. (Special narrow exceptions to this rule may exist depending on which merge strategy is in use, but generally, the index must match HEAD.)</source>
          <target state="translated">为了避免在合并提交中记录无关的更改，如果在索引中相对于 &lt;code&gt;HEAD&lt;/code&gt; 提交注册了任何更改，则 &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git merge&lt;/code&gt; 也将中止。（根据所使用的合并策略，可能存在此规则的特殊狭义例外，但通常，索引必须与HEAD匹配。）</target>
        </trans-unit>
        <trans-unit id="3066556f3c40d15744968614a5fc8c1e23bf8a7b" translate="yes" xml:space="preserve">
          <source>To avoid typing long email addresses, point this to one or more email aliases files. You must also supply &lt;code&gt;sendemail.aliasFileType&lt;/code&gt;.</source>
          <target state="translated">为避免输入长电子邮件地址，请将其指向一个或多个电子邮件别名文件。您还必须提供 &lt;code&gt;sendemail.aliasFileType&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4b87fbf313d264308ea989e0e3b9a4c3d776c25" translate="yes" xml:space="preserve">
          <source>To bootstrap the process, you can first create a bundle that does not have any basis. You can use a tag to remember up to what commit you last processed, in order to make it easy to later update the other repository with an incremental bundle:</source>
          <target state="translated">为了引导这个过程,你可以先创建一个没有任何基础的 bundle。你可以使用一个标签来记住你最后处理的提交,以便于以后用一个增量的捆绑更新其他仓库。</target>
        </trans-unit>
        <trans-unit id="9d8840568125195e79747db7654d577582e9ce27" translate="yes" xml:space="preserve">
          <source>To change which notes are shown by &lt;code&gt;git log&lt;/code&gt;, see the &quot;notes.displayRef&quot; configuration in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">要更改 &lt;code&gt;git log&lt;/code&gt; 显示的注释，请参阅&lt;a href=&quot;git-log&quot;&gt;git-log [1]中&lt;/a&gt;的&amp;ldquo; notes.displayRef&amp;rdquo;配置。</target>
        </trans-unit>
        <trans-unit id="97883ec3271fcc02269394ee0880b3655a6f452f" translate="yes" xml:space="preserve">
          <source>To check out commit &lt;code&gt;HEAD~3&lt;/code&gt; for temporary inspection or experiment without creating a new branch:</source>
          <target state="translated">要在不创建新分支的情况下签出 &lt;code&gt;HEAD~3&lt;/code&gt; 进行临时检查或实验：</target>
        </trans-unit>
        <trans-unit id="d144f3be27bf6711b21fc83fdbf3f1e8ff9fc321" translate="yes" xml:space="preserve">
          <source>To commit a tree you have instantiated with &lt;code&gt;git write-tree&lt;/code&gt;, you&amp;rsquo;d create a &quot;commit&quot; object that refers to that tree and the history behind it&amp;mdash;​most notably the &quot;parent&quot; commits that preceded it in history.</source>
          <target state="translated">要提交使用 &lt;code&gt;git write-tree&lt;/code&gt; 实例化的树，您需要创建一个``提交''对象，该对象引用该树及其背后的历史记录-最值得注意的是在历史记录之前的``父''提交。</target>
        </trans-unit>
        <trans-unit id="05e44c536d85ee3801aa2c0d698cefa8d09c4c33" translate="yes" xml:space="preserve">
          <source>To completely remove a submodule, manually delete &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt;.</source>
          <target state="translated">要完全删除子模块，请手动删除 &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27c15a86c7e79c3805e163825e563ceb0da18b5a" translate="yes" xml:space="preserve">
          <source>To control which revisions to show, gitk supports most options applicable to the &lt;code&gt;git rev-list&lt;/code&gt; command. It also supports a few options applicable to the &lt;code&gt;git diff-*&lt;/code&gt; commands to control how the changes each commit introduces are shown. Finally, it supports some gitk-specific options.</source>
          <target state="translated">为了控制显示哪些修订，gitk支持适用于 &lt;code&gt;git rev-list&lt;/code&gt; 命令的大多数选项。它还支持适用于 &lt;code&gt;git diff-*&lt;/code&gt; 命令的一些选项，以控制如何显示每次提交引入的更改。最后，它支持一些特定于gitk的选项。</target>
        </trans-unit>
        <trans-unit id="777e371b82028c9765bc912013f44d79febb95a6" translate="yes" xml:space="preserve">
          <source>To cope with such a situation, after the inner &lt;code&gt;git bisect&lt;/code&gt; finds the next revision to test, the script can apply the patch before compiling, run the real test, and afterwards decide if the revision (possibly with the needed patch) passed the test and then rewind the tree to the pristine state. Finally the script should exit with the status of the real test to let the &lt;code&gt;git bisect run&lt;/code&gt; command loop determine the eventual outcome of the bisect session.</source>
          <target state="translated">为了解决这种情况，在内部 &lt;code&gt;git bisect&lt;/code&gt; 找到下一个要测试的修订版本之后，脚本可以在编译之前应用补丁，运行真实测试，然后确定该修订版本（可能带有所需的补丁）是否通过了测试，并且然后将树倒回原始状态。最后，脚本应以真实测试的状态退出，以使 &lt;code&gt;git bisect run&lt;/code&gt; 命令循环确定bisect会话的最终结果。</target>
        </trans-unit>
        <trans-unit id="8674c1ca562e6ecc34e19d2429ea897e7602bd28" translate="yes" xml:space="preserve">
          <source>To create your own local live copy of such a &quot;raw&quot; Git repository, you&amp;rsquo;d first create your own subdirectory for the project, and then copy the raw repository contents into the &lt;code&gt;.git&lt;/code&gt; directory. For example, to create your own copy of the Git repository, you&amp;rsquo;d do the following</source>
          <target state="translated">要创建此类&amp;ldquo;原始&amp;rdquo; Git存储库的本地实时副本，您首先需要为项目创建自己的子目录，然后将原始存储库内容复制到 &lt;code&gt;.git&lt;/code&gt; 目录中。例如，要创建自己的Git存储库副本，请执行以下操作</target>
        </trans-unit>
        <trans-unit id="495be7922d2a293092e6f366efd8045104e01478" translate="yes" xml:space="preserve">
          <source>To define a custom merge driver &lt;code&gt;filfre&lt;/code&gt;, add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">要定义自定义合并驱动程序 &lt;code&gt;filfre&lt;/code&gt; ，请在 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件（或 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 文件）中添加一个部分，如下所示：</target>
        </trans-unit>
        <trans-unit id="369d97c17e3edbb633e139fcbb4d6a1ea94c1201" translate="yes" xml:space="preserve">
          <source>To define an external diff driver &lt;code&gt;jcdiff&lt;/code&gt;, add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">要定义外部diff驱动程序 &lt;code&gt;jcdiff&lt;/code&gt; ，请在 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件（或 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 文件）中添加一个部分，如下所示：</target>
        </trans-unit>
        <trans-unit id="302897a013466c7a33ee45af87c508a98422abd4" translate="yes" xml:space="preserve">
          <source>To delete the entry for renames, do</source>
          <target state="translated">要删除重名的条目,请执行</target>
        </trans-unit>
        <trans-unit id="f31f6b0ae1c80bea942e287ae0ab318c31ede1f4" translate="yes" xml:space="preserve">
          <source>To determine the location of the repository on disk, &lt;code&gt;git http-backend&lt;/code&gt; concatenates the environment variables PATH_INFO, which is set automatically by the web server, and GIT_PROJECT_ROOT, which must be set manually in the web server configuration. If GIT_PROJECT_ROOT is not set, &lt;code&gt;git http-backend&lt;/code&gt; reads PATH_TRANSLATED, which is also set automatically by the web server.</source>
          <target state="translated">为了确定存储库在磁盘上的位置， &lt;code&gt;git http-backend&lt;/code&gt; 将环境变量PATH_INFO（由Web服务器自动设置）和GIT_PROJECT_ROOT串联在一起，后者必须在Web服务器配置中手动设置。如果未设置GIT_PROJECT_ROOT，则 &lt;code&gt;git http-backend&lt;/code&gt; 会读取PATH_TRANSLATED，它也会由Web服务器自动设置。</target>
        </trans-unit>
        <trans-unit id="b99f7180a07f9dbb13dde063c76c98dd5e2d7887" translate="yes" xml:space="preserve">
          <source>To disable features that accept parameters (are configurable), you need to set this element to empty list i.e. &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">要禁用接受参数的功能（可配置），您需要将此元素设置为空列表，即 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43f3c91605c9cb6d680c0ea9cf4c1bb2e77b4d9d" translate="yes" xml:space="preserve">
          <source>To disable interactive logins, displaying a greeting instead:</source>
          <target state="translated">要禁用交互式登录,显示问候语代替。</target>
        </trans-unit>
        <trans-unit id="2e78622c40c98dec97477af783b12ba20d12cc1a" translate="yes" xml:space="preserve">
          <source>To display the &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; man page, use &lt;code&gt;git help git&lt;/code&gt;.</source>
          <target state="translated">要显示&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;手册页，请使用 &lt;code&gt;git help git&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa4dddf358b16e56494c90923230fd025e6f958d" translate="yes" xml:space="preserve">
          <source>To do automatic tag object dereferencing, use the &quot;-d&quot; or &quot;--dereference&quot; flag, so you can do</source>
          <target state="translated">要进行自动的标签对象取消引用,使用&quot;-d &quot;或&quot;--dereference &quot;标志,因此您可以进行以下操作</target>
        </trans-unit>
        <trans-unit id="1e8ea8767cf483c97d6a2e7fcf2209ed742ecdf8" translate="yes" xml:space="preserve">
          <source>To do so, you can specify a &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; pattern with the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute. For example, the following pattern sets all C files to use UTF-16LE-BOM, which is a common encoding on Windows:</source>
          <target state="translated">为此，您可以使用 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性指定&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;模式。例如，以下模式将所有C文件设置为使用UTF-16LE-BOM，这是Windows上的常见编码：</target>
        </trans-unit>
        <trans-unit id="dc05ce874d6baee1eae11d94d6fd56f1e0a6d0ed" translate="yes" xml:space="preserve">
          <source>To do the merge, do</source>
          <target state="translated">要进行合并,请执行</target>
        </trans-unit>
        <trans-unit id="45ed93b09b65e276ec2ef33a1d9d7c3e10d14bfe" translate="yes" xml:space="preserve">
          <source>To do this, the current maintenance branch is copied to another branch named with the previous release version number (e.g. maint-X.Y.(Z-1) where X.Y.Z is the current release).</source>
          <target state="translated">要做到这一点,当前的维护分支会被复制到另一个以之前的版本号命名的分支上(例如maint-X.Y.(Z-1),其中X.Y.Z是当前的版本)。</target>
        </trans-unit>
        <trans-unit id="380aa6a091a04ad8bbf89399d1982760e370374e" translate="yes" xml:space="preserve">
          <source>To drop a commit, replace the command &quot;pick&quot; with &quot;drop&quot;, or just delete the matching line.</source>
          <target state="translated">要放弃一个提交,将命令 &quot;pick &quot;替换为 &quot;drop&quot;,或者直接删除匹配的行。</target>
        </trans-unit>
        <trans-unit id="e05b8854f808624747710c5e1d641ee4dabaf30c" translate="yes" xml:space="preserve">
          <source>To elaborate, &quot;reading&quot; means checking for file existence, reading file attributes or file content. The working directory version may be present or absent. If present, its content may match against the index version or not. Writing is not affected by this bit, content safety is still first priority. Note that Git &lt;code&gt;can&lt;/code&gt; update working directory file, that is marked skip-worktree, if it is safe to do so (i.e. working directory version matches index version)</source>
          <target state="translated">详细地说，&amp;ldquo;读取&amp;rdquo;是指检查文件是否存在，读取文件属性或文件内容。工作目录版本可能存在或不存在。如果存在，其内容可能与索引版本不匹配。写入不受此位影响，内容安全仍然是第一要务。注意，如果安全的话，Git &lt;code&gt;can&lt;/code&gt; 更新标记为skip-worktree的工作目录文件（例如，工作目录版本与索引版本匹配）。</target>
        </trans-unit>
        <trans-unit id="64ecd7272d648bbcdba5e527a1a80e43cb0705c5" translate="yes" xml:space="preserve">
          <source>To enable &lt;code&gt;git archive --remote&lt;/code&gt; and disable &lt;code&gt;git fetch&lt;/code&gt; against a repository, have the following in the configuration file in the repository (that is the file &lt;code&gt;config&lt;/code&gt; next to &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;refs&lt;/code&gt; and &lt;code&gt;objects&lt;/code&gt;).</source>
          <target state="translated">要对存储库启用 &lt;code&gt;git archive --remote&lt;/code&gt; 并禁用 &lt;code&gt;git fetch&lt;/code&gt; ，请在存储库的配置文件中添加以下内容（即 &lt;code&gt;HEAD&lt;/code&gt; ， &lt;code&gt;refs&lt;/code&gt; 和 &lt;code&gt;objects&lt;/code&gt; 旁边的文件 &lt;code&gt;config&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="af7d8457fff28a2087e0f74bc51d0468026a9bff" translate="yes" xml:space="preserve">
          <source>To enable a target, set the corresponding environment variable or system or global config value to one of the following:</source>
          <target state="translated">要启用目标,请将相应的环境变量或系统或全局配置值设置为以下之一。</target>
        </trans-unit>
        <trans-unit id="01e6eac26c3bbc386ab13c8cd6a9167801f24836" translate="yes" xml:space="preserve">
          <source>To enable anonymous read access but authenticated write access, require authorization for both the initial ref advertisement (which we detect as a push via the service parameter in the query string), and the receive-pack invocation itself:</source>
          <target state="translated">为了实现匿名的读访问,但认证的写访问,需要对初始ref广告(我们通过查询字符串中的service参数检测为推送)和receive-pack调用本身进行授权。</target>
        </trans-unit>
        <trans-unit id="9bda367b82f8881561a1128afb27f36988891c35" translate="yes" xml:space="preserve">
          <source>To enable anonymous read access but authenticated write access:</source>
          <target state="translated">启用匿名读取访问,但允许认证的写入访问。</target>
        </trans-unit>
        <trans-unit id="050d5472dcd3f05f019f9a8129d0bb6d5e205df8" translate="yes" xml:space="preserve">
          <source>To enable blame, pickaxe search, and snapshot support (allowing &quot;tar.gz&quot; and &quot;zip&quot; snapshots), while allowing individual projects to turn them off, put the following in your GITWEB_CONFIG file:</source>
          <target state="translated">要启用责备、pickaxe搜索和快照支持(允许 &quot;tar.gz &quot;和 &quot;zip &quot;快照),同时允许单个项目关闭它们,请在GITWEB_CONFIG文件中加入以下内容。</target>
        </trans-unit>
        <trans-unit id="fa7174e314ce7012972664ac5bcf82d4b390a6d5" translate="yes" xml:space="preserve">
          <source>To enable git-cvsserver access (which should generally have the &lt;code&gt;no-interactive-login&lt;/code&gt; example above as a prerequisite, as creating the git-shell-commands directory allows interactive logins):</source>
          <target state="translated">要启用git-cvsserver访问（通常应该具有上面的 &lt;code&gt;no-interactive-login&lt;/code&gt; 示例作为先决条件，因为创建git-shell-commands目录允许交互式登录）：</target>
        </trans-unit>
        <trans-unit id="69aa803d2928631745bb26ea6d720a34de175dd7" translate="yes" xml:space="preserve">
          <source>To enable that additional nice feature, when a bisection is started and when some good commits are not ancestors of the bad commit, we first compute the merge bases between the bad and the good commits and we chose these merge bases as the first commits that will be checked out and tested.</source>
          <target state="translated">为了实现这个额外的好功能,当开始一分为二的时候,当一些好的提交不是坏的提交的祖先时,我们首先计算坏的提交和好的提交之间的合并基数,我们选择这些合并基数作为首先要检查和测试的提交。</target>
        </trans-unit>
        <trans-unit id="ba44f6ad0a0230b79b3149aabc029b57fd7f22d9" translate="yes" xml:space="preserve">
          <source>To enable the sparse-checkout feature, run &lt;code&gt;git sparse-checkout init&lt;/code&gt; to initialize a simple sparse-checkout file and enable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; config setting. Then, run &lt;code&gt;git sparse-checkout set&lt;/code&gt; to modify the patterns in the sparse-checkout file.</source>
          <target state="translated">要启用稀疏签出功能，请运行 &lt;code&gt;git sparse-checkout init&lt;/code&gt; 初始化一个简单的稀疏签出文件并启用 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 配置设置。然后，运行 &lt;code&gt;git sparse-checkout set&lt;/code&gt; 来修改sparse-checkout文件中的模式。</target>
        </trans-unit>
        <trans-unit id="1318b73efc503f41a06d5d140c646ee25cf7e427" translate="yes" xml:space="preserve">
          <source>To exclude commits reachable from a commit, a prefix &lt;code&gt;^&lt;/code&gt; notation is used. E.g. &lt;code&gt;^r1 r2&lt;/code&gt; means commits reachable from &lt;code&gt;r2&lt;/code&gt; but exclude the ones reachable from &lt;code&gt;r1&lt;/code&gt; (i.e. &lt;code&gt;r1&lt;/code&gt; and its ancestors).</source>
          <target state="translated">为了从提交中排除可到达的提交，使用前缀 &lt;code&gt;^&lt;/code&gt; 表示法。例如 &lt;code&gt;^r1 r2&lt;/code&gt; 表示可从 &lt;code&gt;r2&lt;/code&gt; 到达的提交，但不包括可从 &lt;code&gt;r1&lt;/code&gt; 到达的提交（即 &lt;code&gt;r1&lt;/code&gt; 及其祖先）。</target>
        </trans-unit>
        <trans-unit id="a12d809ea9b20c2b561957b059e3fe943cb6e440" translate="yes" xml:space="preserve">
          <source>To find out how the result can be used, just read on in &lt;code&gt;cmd_cat_file()&lt;/code&gt;:</source>
          <target state="translated">要了解如何使用结果，只需在 &lt;code&gt;cmd_cat_file()&lt;/code&gt; 中继续阅读：</target>
        </trans-unit>
        <trans-unit id="338cdf0c3d82152dc96e1eae9cd9922bf736e76c" translate="yes" xml:space="preserve">
          <source>To get a checkout with the Eclipse CVS client:</source>
          <target state="translated">要用Eclipse CVS客户端进行结账。</target>
        </trans-unit>
        <trans-unit id="976f859125db1311d8f82bb8df703ef2ad537fd0" translate="yes" xml:space="preserve">
          <source>To get a reminder of the currently used terms, use</source>
          <target state="translated">要获得当前使用的术语的提醒,使用</target>
        </trans-unit>
        <trans-unit id="68b714c59ff5898ff58433a2938d52aeb27df43e" translate="yes" xml:space="preserve">
          <source>To get started with gitweb, run &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; from a Git repository. This would configure and start your web server, and run web browser pointing to gitweb.</source>
          <target state="translated">要开始使用gitweb，请从Git存储库运行&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;。这将配置并启动您的Web服务器，并运行指向gitweb的Web浏览器。</target>
        </trans-unit>
        <trans-unit id="bf62a03860b36b4b6a615592146052d88035a5f4" translate="yes" xml:space="preserve">
          <source>To get the &quot;base&quot; for the merge, look up the common parent of two commits:</source>
          <target state="translated">要想得到合并的 &quot;基数&quot;,就要查找两个提交的共同父体。</target>
        </trans-unit>
        <trans-unit id="ec1f343ca45777aa33e95b7222bfb7658aa36062" translate="yes" xml:space="preserve">
          <source>To get the feature/bugfix into an integration branch, simply merge it. If the topic has evolved further in the meantime, merge again. (Note that you do not necessarily have to merge it to the oldest integration branch first. For example, you can first merge a bugfix to &lt;code&gt;next&lt;/code&gt;, give it some testing time, and merge to &lt;code&gt;maint&lt;/code&gt; when you know it is stable.)</source>
          <target state="translated">要将功能/错误修正纳入集成分支，只需将其合并即可。如果与此同时话题进一步发展，请再次合并。（请注意，您不必一定要先将其合并到最早的集成分支。例如，您可以先将bugfix合并到 &lt;code&gt;next&lt;/code&gt; ，给它一些测试时间，然后在知道稳定后合并到 &lt;code&gt;maint&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="60ae758b58fc83602f1720fb9cc2f0f4fb30b090" translate="yes" xml:space="preserve">
          <source>To give some hard figures, we used to have an average report-to-fix cycle of 142.6 hours (according to our somewhat weird bug-tracker which just measures wall-clock time). Since we moved to Git, we&amp;rsquo;ve lowered that to 16.2 hours. Primarily because we can stay on top of the bug fixing now, and because everyone&amp;rsquo;s jockeying to get to fix bugs (we&amp;rsquo;re quite proud of how lazy we are to let Git find the bugs for us). Each new release results in ~40% fewer bugs (almost certainly due to how we now feel about writing tests).</source>
          <target state="translated">为了给出一些确切的数字，我们以前的平均报告到修复周期为142.6小时（根据我们有些奇怪的bug跟踪器（它仅测量挂钟时间））。自从我们迁移到Git以来，我们将其降低到16.2小时。主要是因为我们现在可以保持在bug修复的最前沿，并且因为每个人都在努力修复bug（我们为让Git为我们找到bug感到很懒惰而感到自豪）。每个新版本都会减少大约40％的错误（几乎可以肯定，这是由于我们现在对编写测试的感觉所致）。</target>
        </trans-unit>
        <trans-unit id="cc855cb566c405d222e3a3236275bbad376833c3" translate="yes" xml:space="preserve">
          <source>To help with that, &lt;code&gt;range&lt;/code&gt; uses the &lt;code&gt;--dual-color&lt;/code&gt; mode by default. In this mode, the diff of diffs will retain the original diff colors, and prefix the lines with -/+ markers that have their &lt;strong&gt;background&lt;/strong&gt; red or green, to make it more obvious that they describe how the diff itself changed.</source>
          <target state="translated">为了解决这个问题， &lt;code&gt;range&lt;/code&gt; 默认使用 &lt;code&gt;--dual-color&lt;/code&gt; 模式。在此模式下，差异的差异将保留原始差异颜色，并在带有-/ +标记的行前加上&lt;strong&gt;背景为&lt;/strong&gt;红色或绿色的标记，以使其更明显地描述差异本身的变化。</target>
        </trans-unit>
        <trans-unit id="096c5d9029f3f58b2af501ec17fb5d42ac0f73fe" translate="yes" xml:space="preserve">
          <source>To illustrate the difference between &lt;code&gt;-S&amp;lt;regex&amp;gt; --pickaxe-regex&lt;/code&gt; and &lt;code&gt;-G&amp;lt;regex&amp;gt;&lt;/code&gt;, consider a commit with the following diff in the same file:</source>
          <target state="translated">为了说明 &lt;code&gt;-S&amp;lt;regex&amp;gt; --pickaxe-regex&lt;/code&gt; 和 &lt;code&gt;-G&amp;lt;regex&amp;gt;&lt;/code&gt; 之间的区别，请考虑在同一文件中包含以下差异的提交：</target>
        </trans-unit>
        <trans-unit id="e67d6de21feaa90def83753eb253a23faea561fa" translate="yes" xml:space="preserve">
          <source>To illustrate, suppose you are in a situation where someone develops a &lt;code&gt;subsystem&lt;/code&gt; branch, and you are working on a &lt;code&gt;topic&lt;/code&gt; that is dependent on this &lt;code&gt;subsystem&lt;/code&gt;. You might end up with a history like the following:</source>
          <target state="translated">为了进行说明，假设您处于有人开发 &lt;code&gt;subsystem&lt;/code&gt; 分支的情况，并且您正在研究一个依赖于该 &lt;code&gt;subsystem&lt;/code&gt; 的 &lt;code&gt;topic&lt;/code&gt; 。您可能会得到如下所示的历史记录：</target>
        </trans-unit>
        <trans-unit id="a98d25733140cb4450fff563f123b0d4cafeb9f9" translate="yes" xml:space="preserve">
          <source>To interrupt the rebase (just like an &quot;edit&quot; command would do, but without cherry-picking any commit first), use the &quot;break&quot; command.</source>
          <target state="translated">要中断rebase(就像 &quot;edit &quot;命令一样,但不需要先挑出任何提交),使用 &quot;break &quot;命令。</target>
        </trans-unit>
        <trans-unit id="f6408dba3913ebdb903fdfce1d68f1906d3e56f0" translate="yes" xml:space="preserve">
          <source>To look at only non-zero stages, use &lt;code&gt;--unmerged&lt;/code&gt; flag:</source>
          <target state="translated">要仅查看非零阶段，请使用 &lt;code&gt;--unmerged&lt;/code&gt; 标志：</target>
        </trans-unit>
        <trans-unit id="5b273f729e50c3bb1996889c896c925cce764cd8" translate="yes" xml:space="preserve">
          <source>To make it readable, we can tell &lt;code&gt;git diff-files&lt;/code&gt; to output the differences as a patch, using the &lt;code&gt;-p&lt;/code&gt; flag:</source>
          <target state="translated">为了使其可读，我们可以使用 &lt;code&gt;-p&lt;/code&gt; 标志告诉 &lt;code&gt;git diff-files&lt;/code&gt; 将差异作为补丁输出：</target>
        </trans-unit>
        <trans-unit id="9fa7b34f2837aaeca157590c3f1e04cfe3400ecb" translate="yes" xml:space="preserve">
          <source>To make referencing the final pathname simpler, you can map each path component; so if you also anonymize &lt;code&gt;subdir&lt;/code&gt; to &lt;code&gt;publicdir&lt;/code&gt;, then the final pathname would be &lt;code&gt;publicdir/bar.c&lt;/code&gt;.</source>
          <target state="translated">为了简化对最终路径名的引用，可以映射每个路径组件。所以，如果你也匿名化 &lt;code&gt;subdir&lt;/code&gt; 到 &lt;code&gt;publicdir&lt;/code&gt; ，那么最终路径是 &lt;code&gt;publicdir/bar.c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5411ef1231b1da2dbabaf49f4348af685832f2f7" translate="yes" xml:space="preserve">
          <source>To move the whole tree into a subdirectory, or remove it from there:</source>
          <target state="translated">要将整棵树移到子目录中,或从子目录中删除它。</target>
        </trans-unit>
        <trans-unit id="9fef1883cb2bb53007927c93e3d8f7431145efad" translate="yes" xml:space="preserve">
          <source>To perform a three-way merge, you start with the two commits you want to merge, find their closest common parent (a third commit), and compare the trees corresponding to these three commits.</source>
          <target state="translated">要执行三向合并,先从要合并的两个提交开始,找到它们最接近的共同父代(第三个提交),然后比较这三个提交对应的树。</target>
        </trans-unit>
        <trans-unit id="a35f3e8a10774da4c0b0f3f87118660d7ef9889e" translate="yes" xml:space="preserve">
          <source>To place a higher stage entry to the index, the path should first be removed by feeding a mode=0 entry for the path, and then feeding necessary input lines in the third format.</source>
          <target state="translated">如果要将更高阶段的条目放到索引中,应先为路径输入一个mode=0的条目,然后再以第三种格式输入必要的输入行,将路径删除。</target>
        </trans-unit>
        <trans-unit id="26b0cbf1bc1090821ae6f59cac15f02ec7f562f8" translate="yes" xml:space="preserve">
          <source>To prepare for working on &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, switch to it by updating the index and the files in the working tree, and by pointing &lt;code&gt;HEAD&lt;/code&gt; at the branch. Local modifications to the files in the working tree are kept, so that they can be committed to the &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">要准备在 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 上工作，请通过更新工作树中的索引和文件，并将 &lt;code&gt;HEAD&lt;/code&gt; 指向分支来切换到该分支。保留对工作树中文件的本地修改，以便可以将其提交给 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13739c43ac679e23fc4c2d09478ac31e5293cb15" translate="yes" xml:space="preserve">
          <source>To pretend you have a file at path with mode and sha1, say:</source>
          <target state="translated">假设你在路径上有一个文件,用mode和sha1,比如。</target>
        </trans-unit>
        <trans-unit id="6785e6ba620455f331d4a09eb8363e2600eabf25" translate="yes" xml:space="preserve">
          <source>To prevent a $GIT_DIR/worktrees entry from being pruned (which can be useful in some situations, such as when the entry&amp;rsquo;s working tree is stored on a portable device), use the &lt;code&gt;git worktree lock&lt;/code&gt; command, which adds a file named &lt;code&gt;locked&lt;/code&gt; to the entry&amp;rsquo;s directory. The file contains the reason in plain text. For example, if a linked working tree&amp;rsquo;s &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; then a file named &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; will prevent the &lt;code&gt;test-next&lt;/code&gt; entry from being pruned. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for details.</source>
          <target state="translated">为了防止修剪$ GIT_DIR / worktrees条目（在某些情况下（例如，该条目的工作树存储在便携式设备上时，这 &lt;code&gt;git worktree lock&lt;/code&gt; 用）），请使用git worktree lock命令，该命令将一个名为 &lt;code&gt;locked&lt;/code&gt; 的文件添加到条目的目录。该文件以纯文本形式包含原因。例如，如果链接的工作树的 &lt;code&gt;.git&lt;/code&gt; 文件指向 &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; ,则名为 &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; 的文件将阻止 &lt;code&gt;test-next&lt;/code&gt; 删除下一个条目。有关详细信息，请参见&lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af2e73e27abe3e4382121e1f7c2af8f2dfcf3321" translate="yes" xml:space="preserve">
          <source>To prevent a &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; entry from being pruned (which can be useful in some situations, such as when the entry&amp;rsquo;s working tree is stored on a portable device), use the &lt;code&gt;git worktree lock&lt;/code&gt; command, which adds a file named &lt;code&gt;locked&lt;/code&gt; to the entry&amp;rsquo;s directory. The file contains the reason in plain text. For example, if a linked working tree&amp;rsquo;s &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; then a file named &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; will prevent the &lt;code&gt;test-next&lt;/code&gt; entry from being pruned. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for details.</source>
          <target state="translated">为了防止修剪 &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; 条目（在某些情况下（例如，当条目的工作树存储在便携式设备上时，这可能会很有用）），请使用 &lt;code&gt;git worktree lock&lt;/code&gt; 命令，该命令将一个名为 &lt;code&gt;locked&lt;/code&gt; 的文件添加到条目的目录。该文件以纯文本形式包含原因。例如，如果链接的工作树的 &lt;code&gt;.git&lt;/code&gt; 文件指向 &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; ,则名为 &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; 的文件将阻止 &lt;code&gt;test-next&lt;/code&gt; 修剪下一个条目。有关详细信息，请参见&lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46ac404b2baca4d3a659bb0594db0c41828389ed" translate="yes" xml:space="preserve">
          <source>To prevent these unnecessary merge conflicts, Git can be told to run a virtual check-out and check-in of all three stages of a file when resolving a three-way merge by setting the &lt;code&gt;merge.renormalize&lt;/code&gt; configuration variable. This prevents changes caused by check-in conversion from causing spurious merge conflicts when a converted file is merged with an unconverted file.</source>
          <target state="translated">为了防止这些不必要的合并冲突，在通过设置 &lt;code&gt;merge.renormalize&lt;/code&gt; 配置变量来解决三向合并时，可以告诉Git对文件的所有三个阶段运行虚拟检出和检入。当转换后的文件与未转换的文件合并时，这可以防止由签入转换引起的更改引起虚假合并冲突。</target>
        </trans-unit>
        <trans-unit id="91d260766aee213709a415223ac206b93100d7d5" translate="yes" xml:space="preserve">
          <source>To prune objects not used by your repository or another that borrows from your repository via its &lt;code&gt;.git/objects/info/alternates&lt;/code&gt;:</source>
          <target state="translated">要修剪存储库或通过其 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; 从存储库借用的另一个对象未​​使用的对象，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="2f63f42b98c259e7fd0384dd68939f7fc302c5eb" translate="yes" xml:space="preserve">
          <source>To prune references as part of your normal workflow without needing to remember to run that, set &lt;code&gt;fetch.prune&lt;/code&gt; globally, or &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; per-remote in the config. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">要在正常工作流程中修剪引用而不需要记住运行该引用，请在 &lt;code&gt;fetch.prune&lt;/code&gt; 全局设置fetch.prune或 &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; per-remote。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68bfae2792009c9d944a67bd77b4854e1c8c4d3e" translate="yes" xml:space="preserve">
          <source>To put the loose objects into a pack, just run git repack:</source>
          <target state="translated">要把松散的对象放入包中,只需运行git repack即可。</target>
        </trans-unit>
        <trans-unit id="8344caf5b982f9b0d4dc99f7ff5aa708ff0b3592" translate="yes" xml:space="preserve">
          <source>To query the value for a given key, do</source>
          <target state="translated">要查询一个给定的键的值,请执行</target>
        </trans-unit>
        <trans-unit id="6d7c1598e59e901d58d9b961c14fa449c82ef069" translate="yes" xml:space="preserve">
          <source>To reapply a series of changes from a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; to a different base, and reset the &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; of that branch to the result.</source>
          <target state="translated">要重新应用从&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;到其他基准的一系列更改，并将该分支的&lt;a href=&quot;#def_head&quot;&gt;开头&lt;/a&gt;重置为结果。</target>
        </trans-unit>
        <trans-unit id="25388a0bc929e9a0e4d2bb9d4d113e8444bb02a5" translate="yes" xml:space="preserve">
          <source>To remove a file from the index and from the working tree, use</source>
          <target state="translated">要从索引和工作树中删除一个文件,请使用</target>
        </trans-unit>
        <trans-unit id="c7850646e909d85f101794190a2e6f7a699e3e90" translate="yes" xml:space="preserve">
          <source>To remove commits authored by &quot;Darl McBribe&quot; from the history:</source>
          <target state="translated">从历史记录中删除 &quot;Darl McBribe &quot;撰写的提交。</target>
        </trans-unit>
        <trans-unit id="65692943c43d72ea453917ea884fccf3994fb56e" translate="yes" xml:space="preserve">
          <source>To remove selection, prefix the input with &lt;code&gt;-&lt;/code&gt; like this:</source>
          <target state="translated">要删除选择，请在输入之前添加 &lt;code&gt;-&lt;/code&gt; ,如下所示：</target>
        </trans-unit>
        <trans-unit id="9e91a512899aa79b93af123e6b1768a526248346" translate="yes" xml:space="preserve">
          <source>To repopulate the working directory with all files, use the &lt;code&gt;git sparse-checkout disable&lt;/code&gt; command.</source>
          <target state="translated">要用所有文件重新填充工作目录，请使用 &lt;code&gt;git sparse-checkout disable&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="5c497720a7ab3ae3ef408305ef475289bc14a521" translate="yes" xml:space="preserve">
          <source>To reproduce the entire p4 history in Git, use the &lt;code&gt;@all&lt;/code&gt; modifier on the depot path:</source>
          <target state="translated">要在Git中重现整个p4历史记录，请在仓库路径上使用 &lt;code&gt;@all&lt;/code&gt; 修饰符：</target>
        </trans-unit>
        <trans-unit id="d4609928d728916d052df2a3b481b65890e4b16e" translate="yes" xml:space="preserve">
          <source>To require authentication for both reads and writes, use a Location directive around the repository, or one of its parent directories:</source>
          <target state="translated">要要求对读和写进行认证,可以在版本库周围使用一个Location指令,或者它的一个父目录。</target>
        </trans-unit>
        <trans-unit id="10ebfb5ceb771c952eff2c39be3b852f1f654421" translate="yes" xml:space="preserve">
          <source>To require authentication for both reads and writes:</source>
          <target state="translated">要求对读和写进行认证。</target>
        </trans-unit>
        <trans-unit id="847928f545abee25f9f8e4e2cc396a049af86735" translate="yes" xml:space="preserve">
          <source>To restore a file in the index to match the version in &lt;code&gt;HEAD&lt;/code&gt; (this is the same as using &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;)</source>
          <target state="translated">恢复索引中的文件以匹配 &lt;code&gt;HEAD&lt;/code&gt; 中的版本（这与使用&lt;a href=&quot;git-reset&quot;&gt;git-reset [1]相同&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="21366b05c441f538e6886570018737e901640e49" translate="yes" xml:space="preserve">
          <source>To restore all files in the current directory</source>
          <target state="translated">要恢复当前目录下的所有文件</target>
        </trans-unit>
        <trans-unit id="0ab7e14988a23edeb341648ca7b63377b3dd49d2" translate="yes" xml:space="preserve">
          <source>To restrict rewriting to only part of the history, specify a revision range in addition to the new branch name. The new branch name will point to the top-most revision that a &lt;code&gt;git rev-list&lt;/code&gt; of this range will print.</source>
          <target state="translated">要将重写限制为仅历史记录的一部分，除了新的分支名称外，还要指定修订范围。新的分支名称将指向此范围的 &lt;code&gt;git rev-list&lt;/code&gt; 将打印的最高修订。</target>
        </trans-unit>
        <trans-unit id="4d880d7fd779c619b85e62692eb083b5f59e932e" translate="yes" xml:space="preserve">
          <source>To rewrite commits E,F,G,H, use one of these:</source>
          <target state="translated">要重写提交E,F,G,H,请使用其中之一。</target>
        </trans-unit>
        <trans-unit id="47b66273feb1f496168989ebee433bebb314fc85" translate="yes" xml:space="preserve">
          <source>To rewrite only commits D,E,F,G,H, but leave A, B and C alone, use:</source>
          <target state="translated">要只重写D,E,F,G,H,而不重写A,B,C,请使用。</target>
        </trans-unit>
        <trans-unit id="8c31d9c011b7c86062de888fb92cc01426b53584" translate="yes" xml:space="preserve">
          <source>To rewrite the repository to look as if &lt;code&gt;foodir/&lt;/code&gt; had been its project root, and discard all other history:</source>
          <target state="translated">要重写存储库，使其看起来好像 &lt;code&gt;foodir/&lt;/code&gt; 已经是其项目根，并丢弃所有其他历史记录：</target>
        </trans-unit>
        <trans-unit id="7c02b2b350476c8c24e25173b62f35a8ad0c0ae3" translate="yes" xml:space="preserve">
          <source>To see how submodule support works, create four example repositories that can be used later as a submodule:</source>
          <target state="translated">为了了解子模块支持是如何工作的,创建四个示例仓库,以后可以作为子模块使用。</target>
        </trans-unit>
        <trans-unit id="700bc56e5656b835e5cd7fa2e5386957dfc66eac" translate="yes" xml:space="preserve">
          <source>To see the currently remaining suspects in &lt;code&gt;gitk&lt;/code&gt;, issue the following command during the bisection process (the subcommand &lt;code&gt;view&lt;/code&gt; can be used as an alternative to &lt;code&gt;visualize&lt;/code&gt;):</source>
          <target state="translated">要查看 &lt;code&gt;gitk&lt;/code&gt; 中当前剩余的可疑对象，请在对分过程中发出以下命令（子命令 &lt;code&gt;view&lt;/code&gt; 可以用作 &lt;code&gt;visualize&lt;/code&gt; 的替代方法）：</target>
        </trans-unit>
        <trans-unit id="faa509deef7fcd4d518cc2cd2e577046b7eb747b" translate="yes" xml:space="preserve">
          <source>To see whether it has already been merged into the test or release branches, use:</source>
          <target state="translated">要查看它是否已经被合并到测试或发布分支中,使用。</target>
        </trans-unit>
        <trans-unit id="1e15ca1368deb202f467e491af7bfdb38f930af4" translate="yes" xml:space="preserve">
          <source>To serve gitweb at the same url, use a ScriptAliasMatch to only those URLs that &lt;code&gt;git http-backend&lt;/code&gt; can handle, and forward the rest to gitweb:</source>
          <target state="translated">要以相同的网址提供gitweb，请使用ScriptAliasMatch仅将 &lt;code&gt;git http-backend&lt;/code&gt; 可以处理的URL 转发给gitweb：</target>
        </trans-unit>
        <trans-unit id="3b5c2b799f6b39d60aa882699fc88e3eb3a77175" translate="yes" xml:space="preserve">
          <source>To serve multiple repositories from different &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; in a single repository:</source>
          <target state="translated">要在单个存储库中提供来自不同&lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt;的多个存储库：</target>
        </trans-unit>
        <trans-unit id="59fa97f902b7761eca14600ff37aff1758dec6bd" translate="yes" xml:space="preserve">
          <source>To set a commit (which typically is at the tip of another history) to be the parent of the current initial commit, in order to paste the other history behind the current history:</source>
          <target state="translated">将一个提交(通常是在另一个历史记录的顶端)设置为当前初始提交的父级,以便将其他历史记录粘贴在当前历史记录的后面。</target>
        </trans-unit>
        <trans-unit id="d091c25539483b5c5b3db274eae656a5f768704a" translate="yes" xml:space="preserve">
          <source>To set the date used in future tag objects, set the environment variable GIT_COMMITTER_DATE (see the later discussion of possible values; the most common form is &quot;YYYY-MM-DD HH:MM&quot;).</source>
          <target state="translated">要设置未来标签对象中使用的日期,请设置环境变量GIT_COMMITTER_DATE(参见后面对可能值的讨论;最常见的形式是 &quot;YYYY-MM-DD HH:MM&quot;)。</target>
        </trans-unit>
        <trans-unit id="0de4847876d8ab04ebb463613f39507d60c3b1a3" translate="yes" xml:space="preserve">
          <source>To set this up, first create your work tree by cloning Linus&amp;rsquo;s public tree:</source>
          <target state="translated">要进行设置，首先通过克隆Linus的公共树来创建工作树：</target>
        </trans-unit>
        <trans-unit id="6fdb47a7575f286ad7a6b8b651d8470ef2c51c01" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as a regular, non-inetd service that handles repositories for multiple virtual hosts based on their IP addresses, start the daemon like this:</source>
          <target state="translated">要将 &lt;code&gt;git daemon&lt;/code&gt; 设置为常规的非inetd服务，该服务根据虚拟主机的IP地址处理多个虚拟主机的存储库，请启动该守护进程，如下所示：</target>
        </trans-unit>
        <trans-unit id="cd4e85b93c0b5a71d973a240463742c429d6ce10" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as an inetd service that handles any repository under the whitelisted set of directories, /pub/foo and /pub/bar, place an entry like the following into /etc/inetd all on one line:</source>
          <target state="translated">要将 &lt;code&gt;git daemon&lt;/code&gt; 设置为可处理列入白名单的目录集/ pub / foo和/ pub / bar下的任何存储库的ine​​td服务，请在/ etc / inetd中将以下内容全部放入一行：</target>
        </trans-unit>
        <trans-unit id="d85d4c6ac447e3ea7881a95ee3354b641502c913" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as an inetd service that handles repositories for different virtual hosts, &lt;code&gt;www.example.com&lt;/code&gt; and &lt;code&gt;www.example.org&lt;/code&gt;, place an entry like the following into &lt;code&gt;/etc/inetd&lt;/code&gt; all on one line:</source>
          <target state="translated">要将 &lt;code&gt;git daemon&lt;/code&gt; 设置为可处理不同虚拟主机的存储库的ine​​td服务，请将 &lt;code&gt;www.example.com&lt;/code&gt; 和 &lt;code&gt;www.example.org&lt;/code&gt; 如下所示的条目放在 &lt;code&gt;/etc/inetd&lt;/code&gt; 中的所有行中：</target>
        </trans-unit>
        <trans-unit id="6d1dfa06a0b2e0253dac9a23d3e763ff2be4729c" translate="yes" xml:space="preserve">
          <source>To shelve changes instead of submitting, use &lt;code&gt;--shelve&lt;/code&gt; and &lt;code&gt;--update-shelve&lt;/code&gt;:</source>
          <target state="translated">要搁置更改而不是提交更改，请使用 &lt;code&gt;--shelve&lt;/code&gt; 和 &lt;code&gt;--update-shelve&lt;/code&gt; shelve：</target>
        </trans-unit>
        <trans-unit id="b19251adc869dd31b98316a2df3ca3e146f58f68" translate="yes" xml:space="preserve">
          <source>To show all references called &quot;master&quot;, whether tags or heads or anything else, and regardless of how deep in the reference naming hierarchy they are, use:</source>
          <target state="translated">要显示所有被称为 &quot;master &quot;的引用,无论是tag、head还是其他任何东西,也不管它们在引用命名层次结构中的位置有多深,请使用。</target>
        </trans-unit>
        <trans-unit id="51ec81ccf2337a76aefa897308cd08d96e515614" translate="yes" xml:space="preserve">
          <source>To show only tags, or only proper branch heads, use &quot;--tags&quot; and/or &quot;--heads&quot; respectively (using both means that it shows tags and heads, but not other random references under the refs/ subdirectory).</source>
          <target state="translated">要只显示标签,或者只显示正确的分支头,分别使用&quot;--tags &quot;和/或&quot;--heads&quot;(使用这两个词意味着它显示标签和头,但不显示refs/子目录下的其他随机引用)。</target>
        </trans-unit>
        <trans-unit id="864f9f1ee17e37f4b3823291b8524eebd5879fc4" translate="yes" xml:space="preserve">
          <source>To show that as an example, let&amp;rsquo;s go back to the git-tutorial repository we used earlier, and create a branch in it. You do that by simply just saying that you want to check out a new branch:</source>
          <target state="translated">为了说明这一点，让我们回到前面使用的git-tutorial存储库，并在其中创建一个分支。您只需说出要签出新的分支即可：</target>
        </trans-unit>
        <trans-unit id="acab411fa1b0a4e2f72e42b537e21a4bc08bf613" translate="yes" xml:space="preserve">
          <source>To simplify the discussion we will suppose that the untestable area is a simple string of commits and that it was created by a breakage introduced by one commit (let&amp;rsquo;s call it BBC for bisect breaking commit) and later fixed by another one (let&amp;rsquo;s call it BFC for bisect fixing commit).</source>
          <target state="translated">为了简化讨论，我们将假设不可测区域是一个简单的提交字符串，它是由一个提交引入的破损创建的（对于二等分断开提交，我们称之为BBC），后来又由另一个提交修复了（称为BFC）。对于等分修复提交）。</target>
        </trans-unit>
        <trans-unit id="975e3a9279c8287bca9f664bbcc61fee7baa93ca" translate="yes" xml:space="preserve">
          <source>To specify a branch other than the current one, use:</source>
          <target state="translated">要指定当前分支以外的分支,请使用。</target>
        </trans-unit>
        <trans-unit id="b6b6e95c2c1acd4004bc280690d73f7c9df3e3b0" translate="yes" xml:space="preserve">
          <source>To specify a namespace, set the &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; environment variable to the namespace. For each ref namespace, Git stores the corresponding refs in a directory under &lt;code&gt;refs/namespaces/&lt;/code&gt;. For example, &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; will store refs under &lt;code&gt;refs/namespaces/foo/&lt;/code&gt;. You can also specify namespaces via the &lt;code&gt;--namespace&lt;/code&gt; option to &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;.</source>
          <target state="translated">要指定名称空间，请将 &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; 环境变量设置为名称空间。对于每个ref名称空间，Git会将相应的refs存储在 &lt;code&gt;refs/namespaces/&lt;/code&gt; 下的目录中。例如， &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; 将引用存储在 &lt;code&gt;refs/namespaces/foo/&lt;/code&gt; 。您还可以通过&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;的 &lt;code&gt;--namespace&lt;/code&gt; 选项指定名称空间。</target>
        </trans-unit>
        <trans-unit id="8d8e0463dddb070b083bcb1d31f0cd304bcae1a2" translate="yes" xml:space="preserve">
          <source>To specify a single commit or a range of commits, use:</source>
          <target state="translated">要指定一个或一系列的提交,请使用。</target>
        </trans-unit>
        <trans-unit id="b6bdd73c5af990a9c308cb3582e6683a673000a9" translate="yes" xml:space="preserve">
          <source>To stop tracking a file that is currently tracked, use &lt;code&gt;git rm --cached&lt;/code&gt;.</source>
          <target state="translated">要停止跟踪当前跟踪的文件，请使用 &lt;code&gt;git rm --cached&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5aabd990937e7026d6c235ccca8da7a1bd54429f" translate="yes" xml:space="preserve">
          <source>To submit all changes that are in the current Git branch but not in the &lt;code&gt;p4/master&lt;/code&gt; branch, use:</source>
          <target state="translated">要提交当前Git分支中而不是 &lt;code&gt;p4/master&lt;/code&gt; 分支中的所有更改，请使用：</target>
        </trans-unit>
        <trans-unit id="4d37523ff8334f7ae27e64b17d4088a430f024d8" translate="yes" xml:space="preserve">
          <source>To submit patches using GMail&amp;rsquo;s IMAP interface, first, edit your ~/.gitconfig to specify your account settings:</source>
          <target state="translated">要使用GMail的IMAP界面提交补丁，请首先编辑〜/ .gitconfig以指定您的帐户设置：</target>
        </trans-unit>
        <trans-unit id="3829362b0206f78fb7e35755e5364f47036b822a" translate="yes" xml:space="preserve">
          <source>To support virtual hosting, an interpolated path template can be used to dynamically construct alternate paths. The template supports %H for the target hostname as supplied by the client but converted to all lowercase, %CH for the canonical hostname, %IP for the server&amp;rsquo;s IP address, %P for the port number, and %D for the absolute path of the named repository. After interpolation, the path is validated against the directory whitelist.</source>
          <target state="translated">为了支持虚拟主机，可以使用内插的路径模板动态构建备用路径。模板支持％H作为客户端提供的目标主机名，但转换为所有小写字母，％CH表示规范的主机名，％IP表示服务器的IP地址，％P表示端口号，％D表示绝对路径命名存储库。插值后，将根据目录白名单验证路径。</target>
        </trans-unit>
        <trans-unit id="5c5bebcfb262219afa24ad57e1be9ff8017de145" translate="yes" xml:space="preserve">
          <source>To switch back to the previous branch before we switched to mytopic (i.e. &quot;master&quot; branch):</source>
          <target state="translated">要切换回我们切换到mytopic之前的分支(即 &quot;主 &quot;分支)。</target>
        </trans-unit>
        <trans-unit id="f604bfa9fc2a5e3a8b43aed4c26f0a58bfbd1e14" translate="yes" xml:space="preserve">
          <source>To tell Git that yes, you really do realize that certain files no longer exist, or that new files should be added, you should use the &lt;code&gt;--remove&lt;/code&gt; and &lt;code&gt;--add&lt;/code&gt; flags respectively.</source>
          <target state="translated">告诉Git是的，您确实意识到某些文件不再存在，或者应该添加新文件，应该分别使用 &lt;code&gt;--remove&lt;/code&gt; 和 &lt;code&gt;--add&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="f3c508cb95e621506ae6e931b2fdadcaba14a047" translate="yes" xml:space="preserve">
          <source>To test the interaction of several topics, merge them into a throw-away branch. You must never base any work on such a branch!</source>
          <target state="translated">要测试几个主题的交互,请将它们合并到一个抛弃式分支中。你绝对不能在这样的分支上做任何工作!</target>
        </trans-unit>
        <trans-unit id="ded44bb687bc8a448accbaa8cf09bc1b10b3ff71" translate="yes" xml:space="preserve">
          <source>To that end, it first finds pairs of commits from both commit ranges that correspond with each other. Two commits are said to correspond when the diff between their patches (i.e. the author information, the commit message and the commit diff) is reasonably small compared to the patches' size. See ``Algorithm`` below for details.</source>
          <target state="translated">为此,它首先从两个提交范围中找到相互对应的提交对。当两个提交的补丁之间的差异(即作者信息、提交信息和提交差异)与补丁的大小相比相当小时,就被认为是对应的。详见下文 &quot;算法&quot;。</target>
        </trans-unit>
        <trans-unit id="28b9a65cbb97d3af18835efd06d4d171278e0508" translate="yes" xml:space="preserve">
          <source>To throw away part of the development, i.e. to assign the &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; to an earlier &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;.</source>
          <target state="translated">放弃部分开发内容，即将&lt;a href=&quot;#def_head&quot;&gt;磁头&lt;/a&gt;分配给较早的&lt;a href=&quot;#def_revision&quot;&gt;修订版&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2857b34f71a88c7afeb725363e4097e2e44ff45" translate="yes" xml:space="preserve">
          <source>To top it all off, even when users finally find working commands, they naturally want to share them. But they may be unaware that their repo didn&amp;rsquo;t have some special cases that someone else&amp;rsquo;s does. So, when someone else with a different repository runs the same commands, they get hit by the problems above. Or, the user just runs commands that really were vetted for special cases, but they run it on a different OS where it doesn&amp;rsquo;t work, as noted above.</source>
          <target state="translated">最重要的是，即使用户最终找到了有效的命令，他们自然也希望共享它们。但是他们可能不知道自己的仓库没有其他人做的特殊情况。因此，当其他人使用不同的存储库运行相同的命令时，他们会受到上述问题的打击。或者，用户仅运行确实经过特殊情况审查的命令，但如上所述，他们在不起作用的其他操作系统上运行该命令。</target>
        </trans-unit>
        <trans-unit id="c4d2ca21938c992db0b3b75cacfc935366e6629e" translate="yes" xml:space="preserve">
          <source>To update and refresh only the files already checked out</source>
          <target state="translated">只更新和刷新已经签出的文件。</target>
        </trans-unit>
        <trans-unit id="a8c26a487a2f6627cb1ef2fcc7d8934daa7b62d0" translate="yes" xml:space="preserve">
          <source>To update and refresh only the files already checked out:</source>
          <target state="translated">只更新和刷新已经签出的文件。</target>
        </trans-unit>
        <trans-unit id="ec65c1043e980aa5b1f1a444793e6e405a4b07fd" translate="yes" xml:space="preserve">
          <source>To update the index with the contents of a new or modified file, use</source>
          <target state="translated">要用新的或修改后的文件内容更新索引,使用</target>
        </trans-unit>
        <trans-unit id="693fe77a3dea0f3b3cf2c4a884d12237d7043db5" translate="yes" xml:space="preserve">
          <source>To update the resulting mine.git repository, you can fetch or pull after replacing the bundle stored at /home/me/tmp/file.bundle with incremental updates.</source>
          <target state="translated">要更新产生的mine.git仓库,你可以在将存储在/home/me/tmp/file.bundle的bundle替换为增量更新后,再取或拉。</target>
        </trans-unit>
        <trans-unit id="7804c7379482ba8df4ffa8604001ea71fae1937a" translate="yes" xml:space="preserve">
          <source>To use &quot;old&quot; and &quot;new&quot; instead of &quot;good&quot; and bad, you must run &lt;code&gt;git
bisect start&lt;/code&gt; without commits as argument and then run the following commands to add the commits:</source>
          <target state="translated">要使用&amp;ldquo;旧&amp;rdquo;和&amp;ldquo;新&amp;rdquo;而不是&amp;ldquo;好&amp;rdquo;和&amp;ldquo;坏&amp;rdquo;，必须运行不带提交的 &lt;code&gt;git bisect start&lt;/code&gt; ，然后运行以下命令来添加提交：</target>
        </trans-unit>
        <trans-unit id="288cf0a04f95ab8d9b3cedc9a80bcb75e1eb91a6" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;git send-email&lt;/code&gt; to send your patches through the GMail SMTP server, edit ~/.gitconfig to specify your account settings:</source>
          <target state="translated">要使用 &lt;code&gt;git send-email&lt;/code&gt; 通过GMail SMTP服务器发送补丁，请编辑〜/ .gitconfig以指定您的帐户设置：</target>
        </trans-unit>
        <trans-unit id="b24b5140a04c50c5ab1f6a8bf4b67a65e4b08446" translate="yes" xml:space="preserve">
          <source>To use a helper, you must first select one to use. Git currently includes the following helpers:</source>
          <target state="translated">要使用助记器,必须先选择一个助记器来使用。目前,Git 包含了以下几个辅助工具。</target>
        </trans-unit>
        <trans-unit id="36cbbd22949ca6f21f378ad7a2a2aecbfc17d31c" translate="yes" xml:space="preserve">
          <source>To use the tool, &lt;code&gt;imap.folder&lt;/code&gt; and either &lt;code&gt;imap.tunnel&lt;/code&gt; or &lt;code&gt;imap.host&lt;/code&gt; must be set to appropriate values.</source>
          <target state="translated">要使用该工具，必须将 &lt;code&gt;imap.folder&lt;/code&gt; 以及 &lt;code&gt;imap.tunnel&lt;/code&gt; 或 &lt;code&gt;imap.host&lt;/code&gt; 设置为适当的值。</target>
        </trans-unit>
        <trans-unit id="00e4f18d69f51ffe1eea42af728cb3d7bb0059ec" translate="yes" xml:space="preserve">
          <source>To use the tool, imap.folder and either imap.tunnel or imap.host must be set to appropriate values.</source>
          <target state="translated">要使用该工具,imap.folder和imap.tunnel或imap.host必须设置为适当的值。</target>
        </trans-unit>
        <trans-unit id="8b51a494019812910be0a147154b59e9ef1b84fa" translate="yes" xml:space="preserve">
          <source>To use this mode effectively, you have to make sure &lt;code&gt;all&lt;/code&gt; the branches you would push out are ready to be pushed out before running &lt;code&gt;git push&lt;/code&gt;, as the whole point of this mode is to allow you to push all of the branches in one go. If you usually finish work on only one branch and push out the result, while other branches are unfinished, this mode is not for you. Also this mode is not suitable for pushing into a shared central repository, as other people may add new branches there, or update the tip of existing branches outside your control.</source>
          <target state="translated">为了有效地使用此模式，您必须确保在运行 &lt;code&gt;git push&lt;/code&gt; 之前已准备好将要推出的 &lt;code&gt;all&lt;/code&gt; 分支都推出，因为此模式的要点是允许您一次推送所有分支。如果通常只在一个分支上完成工作并推出结果，而其他分支还没有完成，则此模式不适合您。同样，此模式也不适合推送到共享中央存储库中，因为其他人可能会在其中添加新分支，或在控件外部更新现有分支的尖端。</target>
        </trans-unit>
        <trans-unit id="0db2ead5af506998515a70d6693b9cc78c43968a" translate="yes" xml:space="preserve">
          <source>To verify that &lt;code&gt;master&lt;/code&gt; is indeed a superset of &lt;code&gt;maint&lt;/code&gt;, use git log:</source>
          <target state="translated">要验证 &lt;code&gt;master&lt;/code&gt; 确实是 &lt;code&gt;maint&lt;/code&gt; 的超集，请使用git log：</target>
        </trans-unit>
        <trans-unit id="25e07c07376edb7f994c3289d03610c1335d5288" translate="yes" xml:space="preserve">
          <source>Todo list</source>
          <target state="translated">所有名单</target>
        </trans-unit>
        <trans-unit id="feb6706843b17024c0f5d36ae4a2773f9f7a9d9e" translate="yes" xml:space="preserve">
          <source>Toggle the &quot;sparse&quot; algorithm to determine which objects to include in the pack, when combined with the &quot;--revs&quot; option. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. If this option is not included, it defaults to the value of &lt;code&gt;pack.useSparse&lt;/code&gt;, which is true unless otherwise specified.</source>
          <target state="translated">与&amp;ldquo; --revs&amp;rdquo;选项结合使用时，切换&amp;ldquo;稀疏&amp;rdquo;算法以确定要包含在包中的对象。该算法仅遍历出现在引入新对象的路径中的树。在计算包裹以发送小额零钱时，这可能具有显着的性能优势。但是，如果包含的提交包含某些类型的直接重命名，则可能会将额外的对象添加到打包文件中。如果不包括此选项，则默认为 &lt;code&gt;pack.useSparse&lt;/code&gt; 的值，除非另有说明，否则为true。</target>
        </trans-unit>
        <trans-unit id="44e89f12173f1b11f3c33dfcf393dbeb53d74231" translate="yes" xml:space="preserve">
          <source>Toggle the pre-push hook (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;). The default is --verify, giving the hook a chance to prevent the push. With --no-verify, the hook is bypassed completely.</source>
          <target state="translated">切换预推钩（请参阅&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;）。默认值为--verify，为挂钩提供了阻止推送的机会。使用--no-verify，挂钩将被完全绕过。</target>
        </trans-unit>
        <trans-unit id="e69b3ac557eee7192f98b057069c2f145301ef39" translate="yes" xml:space="preserve">
          <source>Topic branches</source>
          <target state="translated">主题分支</target>
        </trans-unit>
        <trans-unit id="99011a3381da15bff0042576b0bb55bb6ae9ffd0" translate="yes" xml:space="preserve">
          <source>TortoiseCVS</source>
          <target state="translated">TortoiseCVS</target>
        </trans-unit>
        <trans-unit id="9732ce69da01051c0a62cf40cfeb5063ebcf5c22" translate="yes" xml:space="preserve">
          <source>Trace the evolution of the line range given by &quot;&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;&quot; (or the function name regex &amp;lt;funcname&amp;gt;) within the &amp;lt;file&amp;gt;. You may not give any pathspec limiters. This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and &amp;lt;start&amp;gt; and &amp;lt;end&amp;gt; (or &amp;lt;funcname&amp;gt;) must exist in the starting revision. You can specify this option more than once. Implies &lt;code&gt;--patch&lt;/code&gt;. Patch output can be suppressed using &lt;code&gt;--no-patch&lt;/code&gt;, but other diff formats (namely &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--shortstat&lt;/code&gt;, &lt;code&gt;--dirstat&lt;/code&gt;, &lt;code&gt;--summary&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt;, &lt;code&gt;--name-status&lt;/code&gt;, &lt;code&gt;--check&lt;/code&gt;) are not currently implemented.</source>
          <target state="translated">跟踪&amp;lt;file&amp;gt;中&amp;ldquo; &amp;lt;start&amp;gt;，&amp;lt;end&amp;gt;&amp;rdquo;（或函数名regex &amp;lt;funcname&amp;gt;）给定的行范围的演变。您不得提供任何pathspec限制器。当前，这仅限于从单个修订版开始的遍历，即，您只能提供零个或一个正修订版参数，并且起始版本中必须存在&amp;lt;start&amp;gt;和&amp;lt;end&amp;gt;（或&amp;lt;funcname&amp;gt;）。您可以多次指定此选项。意味着 &lt;code&gt;--patch&lt;/code&gt; 。可以使用 &lt;code&gt;--no-patch&lt;/code&gt; 抑制补丁输出，但可以使用其他差异格式（即 &lt;code&gt;--raw&lt;/code&gt; ，-- &lt;code&gt;--numstat&lt;/code&gt; ，-- &lt;code&gt;--shortstat&lt;/code&gt; ，-- &lt;code&gt;--dirstat&lt;/code&gt; ，-- &lt;code&gt;--summary&lt;/code&gt; ， &lt;code&gt;--name-only&lt;/code&gt; name -only， &lt;code&gt;--name-status&lt;/code&gt; name -status， &lt;code&gt;--check&lt;/code&gt; ）目前尚未实现。</target>
        </trans-unit>
        <trans-unit id="b64ac9752a19150bbcc2229db77526c8ecf78f4e" translate="yes" xml:space="preserve">
          <source>Trace the evolution of the line range given by &lt;code&gt;&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;&lt;/code&gt;, or by the function name regex &lt;code&gt;&amp;lt;funcname&amp;gt;&lt;/code&gt;, within the &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt;. You may not give any pathspec limiters. This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; (or &lt;code&gt;&amp;lt;funcname&amp;gt;&lt;/code&gt;) must exist in the starting revision. You can specify this option more than once. Implies &lt;code&gt;--patch&lt;/code&gt;. Patch output can be suppressed using &lt;code&gt;--no-patch&lt;/code&gt;, but other diff formats (namely &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--shortstat&lt;/code&gt;, &lt;code&gt;--dirstat&lt;/code&gt;, &lt;code&gt;--summary&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt;, &lt;code&gt;--name-status&lt;/code&gt;, &lt;code&gt;--check&lt;/code&gt;) are not currently implemented.</source>
          <target state="translated">跟踪由给出的行范围的演进 &lt;code&gt;&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;&lt;/code&gt; ，或者通过函数名正则表达式 &lt;code&gt;&amp;lt;funcname&amp;gt;&lt;/code&gt; 时，内 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 。您不得提供任何pathspec限制器。当前仅限于从单个修订版本开始的遍历，即，您只能给出零个或一个正修订版本参数，并且起始版本中必须存在 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; （或 &lt;code&gt;&amp;lt;funcname&amp;gt;&lt;/code&gt; ）。您可以多次指定此选项。意味着 &lt;code&gt;--patch&lt;/code&gt; 。可以使用 &lt;code&gt;--no-patch&lt;/code&gt; 抑制补丁输出，但可以使用其他diff格式（即 &lt;code&gt;--raw&lt;/code&gt; ，-- &lt;code&gt;--numstat&lt;/code&gt; ，-- &lt;code&gt;--shortstat&lt;/code&gt; ， &lt;code&gt;--dirstat&lt;/code&gt; ，-- &lt;code&gt;--summary&lt;/code&gt; ， &lt;code&gt;--name-only&lt;/code&gt; name -only， &lt;code&gt;--name-status&lt;/code&gt; name -status， &lt;code&gt;--check&lt;/code&gt; ）当前未实现。</target>
        </trans-unit>
        <trans-unit id="324f1031e6064bf946ba7ad7de400c92a706ee71" translate="yes" xml:space="preserve">
          <source>Trace2 api</source>
          <target state="translated">Trace2 api</target>
        </trans-unit>
        <trans-unit id="f39bab439a6977ac76a84295e79b079d44b7d908" translate="yes" xml:space="preserve">
          <source>Trace2 config settings are only read from the system and global config files; repository local and worktree config files and &lt;code&gt;-c&lt;/code&gt; command line arguments are not respected.</source>
          <target state="translated">Trace2配置设置只能从系统和全局配置文件中读取；不遵守存储库本地和工作树配置文件以及 &lt;code&gt;-c&lt;/code&gt; 命令行参数。</target>
        </trans-unit>
        <trans-unit id="34f4d5fb2d35b898a8c6180c70ae5079360dafe0" translate="yes" xml:space="preserve">
          <source>Trace2 defines the following set of Trace2 Targets. Format details are given in a later section.</source>
          <target state="translated">Trace2 定义了以下一组 Trace2 Targets。格式细节将在后面的章节中给出。</target>
        </trans-unit>
        <trans-unit id="9cffe01770c87380a0c500c2ba4c5fe9919c83ec" translate="yes" xml:space="preserve">
          <source>Trace2 instrumentation throughout the Git code base sends Trace2 messages to the enabled Trace2 Targets. Targets transform these messages content into purpose-specific formats and write events to their data streams. In this manner, the Trace2 API can drive many different types of analysis.</source>
          <target state="translated">Git 代码库中的 Trace2 仪器会向启用的 Trace2 Targets 发送 Trace2 消息。Targets 将这些消息内容转化为特定目的的格式,并将事件写入其数据流。通过这种方式,Trace2 API 可以驱动许多不同类型的分析。</target>
        </trans-unit>
        <trans-unit id="78edf21cb8a1d6593bdb09f0d046c88dfeb5c5d1" translate="yes" xml:space="preserve">
          <source>Trace2 is controlled using &lt;code&gt;trace2.*&lt;/code&gt; config values in the system and global config files and &lt;code&gt;GIT_TRACE2*&lt;/code&gt; environment variables. Trace2 does not read from repo local or worktree config files or respect &lt;code&gt;-c&lt;/code&gt; command line config settings.</source>
          <target state="translated">使用系统和全局配置文件中的 &lt;code&gt;trace2.*&lt;/code&gt; 配置值以及 &lt;code&gt;GIT_TRACE2*&lt;/code&gt; 环境变量来控制Trace2。Trace2不会从存储库本地或工作树配置文件中读取数据，也不会遵循 &lt;code&gt;-c&lt;/code&gt; 命令行配置设置。</target>
        </trans-unit>
        <trans-unit id="952dc6d60a810a50f48d84409a5ca3162f18abfc" translate="yes" xml:space="preserve">
          <source>Trace2 is controlled using &lt;code&gt;trace2.&lt;/code&gt; config values in the system and global config files and &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variables. Trace2 does not read from repo local or worktree config files or respect &lt;code&gt;-c&lt;/code&gt; command line config settings.</source>
          <target state="translated">使用 &lt;code&gt;trace2.&lt;/code&gt; 控制Trace2。系统和全局配置文件中的配置值以及 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 环境变量。Trace2不会从存储库本地或工作树配置文件中读取数据，也不会遵循 &lt;code&gt;-c&lt;/code&gt; 命令行配置设置。</target>
        </trans-unit>
        <trans-unit id="20f68aac372bbc56e3b5b3e96aea0079529bedb9" translate="yes" xml:space="preserve">
          <source>Trace2 regions are similar to the existing trace_performance_enter() and trace_performance_leave() routines, but are thread safe and maintain per-thread stacks of timers.</source>
          <target state="translated">Trace2区域类似于现有的trace_performance_enter()和trace_performance_leave()例程,但是是线程安全的,并且维护每个线程的定时器堆栈。</target>
        </trans-unit>
        <trans-unit id="8bded73626b8544423d59c1c5a0c1bfb684cb12e" translate="yes" xml:space="preserve">
          <source>Trace2 target formats</source>
          <target state="translated">Trace2目标格式</target>
        </trans-unit>
        <trans-unit id="e4cb4d4e7e519744d1375eb303304baebc567ae9" translate="yes" xml:space="preserve">
          <source>Trace2 targets</source>
          <target state="translated">Trace2目标</target>
        </trans-unit>
        <trans-unit id="a0cfb1f78b98054b282b0aab138d8ea25f2c82bd" translate="yes" xml:space="preserve">
          <source>Tracking and contributing to an entire Subversion-managed project (complete with a trunk, tags and branches):</source>
          <target state="translated">跟踪和贡献于整个Subversion管理的项目(完整的主干、标签和分支)。</target>
        </trans-unit>
        <trans-unit id="847895b0cdb93b975e4c930f95d66dabeb1e64d2" translate="yes" xml:space="preserve">
          <source>Tracking and contributing to the trunk of a Subversion-managed project (ignoring tags and branches):</source>
          <target state="translated">追踪并贡献给Subversion管理的项目主干(忽略标签和分支)。</target>
        </trans-unit>
        <trans-unit id="667c19a45142471c0c20cc605b683a6a3152afb1" translate="yes" xml:space="preserve">
          <source>Traditionally, tips of branches and tags (collectively known as &lt;code&gt;refs&lt;/code&gt;) were stored one file per ref in a (sub)directory under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory. While many branch tips tend to be updated often, most tags and some branch tips are never updated. When a repository has hundreds or thousands of tags, this one-file-per-ref format both wastes storage and hurts performance.</source>
          <target state="translated">传统上，分支和标签的提示（统称为 &lt;code&gt;refs&lt;/code&gt; ）是每个ref文件在 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 目录下的（子）目录中存储一个文件。尽管许多分支提示往往会经常更新，但是大多数标记和某些分支提示从未更新。当存储库具有成百上千个标签时，这种&amp;ldquo;每个引用一个文件&amp;rdquo;的格式既浪费存储空间，又损害性能。</target>
        </trans-unit>
        <trans-unit id="a5cf7db57e9cf074478d171148671cc677faf56a" translate="yes" xml:space="preserve">
          <source>Trailing spaces are ignored unless they are quoted with backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;).</source>
          <target state="translated">除非用反斜杠（&amp;ldquo; &lt;code&gt;\&lt;/code&gt; &amp;rdquo;）引号，否则将忽略尾随空格。</target>
        </trans-unit>
        <trans-unit id="18baa50eee1aac68104e16bd4ad94c661cde3869" translate="yes" xml:space="preserve">
          <source>Transfer size: In its current form Git requires the whole working tree present. It does not allow partial trees to be transferred in fetch or clone. If the project you work on consists of multiple repositories tied together as submodules in a superproject, you can avoid fetching the working trees of the repositories you are not interested in.</source>
          <target state="translated">传输大小。在目前的形式下,Git需要整个工作树的存在。它不允许在fetch或clone中传输部分工作树。如果你的项目由多个仓库组成,并作为超级项目的子模块,你可以避免获取你不感兴趣的仓库的工作树。</target>
        </trans-unit>
        <trans-unit id="bdf6a912dffd18ed6042052fce8610d96ce56a71" translate="yes" xml:space="preserve">
          <source>Transform stdin by substituting all the 40-character SHA-1 hexes (say $hex) with &quot;$hex ($rev_name)&quot;. When used with --name-only, substitute with &quot;$rev_name&quot;, omitting $hex altogether. Intended for the scripter&amp;rsquo;s use.</source>
          <target state="translated">通过用&amp;ldquo; $ hex（$ rev_name）&amp;rdquo;替换所有40个字符的SHA-1十六进​​制（例如$ hex）来转换stdin。当与--name-only一起使用时，用&amp;ldquo; $ rev_name&amp;rdquo;代替，完全省略$ hex。供脚本编写者使用。</target>
        </trans-unit>
        <trans-unit id="fc873c381aea0c960eb3ebd47773defb66d7e124" translate="yes" xml:space="preserve">
          <source>Transmit &amp;lt;string&amp;gt; as a push option. As the push option must not contain LF or NUL characters, the string is not encoded.</source>
          <target state="translated">传输&amp;lt;string&amp;gt;作为推送选项。由于push选项中不得包含LF或NUL字符，因此不会对字符串进行编码。</target>
        </trans-unit>
        <trans-unit id="32bd61986aca00f68612950bbcdb4915d3d0e846" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. The server&amp;rsquo;s handling of server options, including unknown ones, is server-specific. When multiple &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line.</source>
          <target state="translated">使用协议版本2进行通信时，将给定的字符串传输到服务器。给定的字符串不得包含NUL或LF字符。服务器对服务器选项（包括未知选项）的处理是特定于服务器的。当给出多个 &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; 时，它们都将按照命令行中列出的顺序发送到另一端。</target>
        </trans-unit>
        <trans-unit id="39635a03df29b9789e505a1038590e24ea96c9e9" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. When multiple &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line.</source>
          <target state="translated">使用协议版本2进行通信时，将给定的字符串传输到服务器。给定的字符串不得包含NUL或LF字符。当给出多个 &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; 时，它们都将按照命令行中列出的顺序发送到另一端。</target>
        </trans-unit>
        <trans-unit id="2995fbcc2c84443582483713456b482a39b63e37" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character. When multiple &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line. When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; is given from the command line, the values of configuration variable &lt;code&gt;push.pushOption&lt;/code&gt; are used instead.</source>
          <target state="translated">将给定的字符串发送到服务器，服务器将它们传递到接收前和接收后钩子。给定的字符串不得包含NUL或LF字符。当给出多个 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 时，它们都将按照命令行中列出的顺序发送到另一端。如果在命令行中未提供 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; ， &lt;code&gt;push.pushOption&lt;/code&gt; 使用配置变量push.pushOption的值。</target>
        </trans-unit>
        <trans-unit id="9960fbc3363c91bebbbc4dae3127f4935a1a22d6" translate="yes" xml:space="preserve">
          <source>Treat all files as text.</source>
          <target state="translated">将所有文件视为文本。</target>
        </trans-unit>
        <trans-unit id="a08e9c61e543dccc4a24afe7a10c95737cbb1ca7" translate="yes" xml:space="preserve">
          <source>Treat pathspecs literally (i.e. no globbing, no pathspec magic). This is equivalent to setting the &lt;code&gt;GIT_LITERAL_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">从字面上对待pathspec（即，不要乱扔，没有pathspec魔术）。这等效于将 &lt;code&gt;GIT_LITERAL_PATHSPECS&lt;/code&gt; 环境变量设置为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8024445062b4bb90b2e84a4da6e0bb207f37b5f4" translate="yes" xml:space="preserve">
          <source>Treat the &amp;lt;string&amp;gt; given to &lt;code&gt;-S&lt;/code&gt; as an extended POSIX regular expression to match.</source>
          <target state="translated">将给予 &lt;code&gt;-S&lt;/code&gt; 的&amp;lt;string&amp;gt; 视为匹配的扩展POSIX正则表达式。</target>
        </trans-unit>
        <trans-unit id="72315ec1092243bb561e5b4697869abb3601099e" translate="yes" xml:space="preserve">
          <source>Treat the repository as a bare repository. If GIT_DIR environment is not set, it is set to the current working directory.</source>
          <target state="translated">将版本库作为裸库处理,如果没有设置GIT_DIR环境,则设置为当前工作目录。如果没有设置GIT_DIR环境,则设置为当前工作目录。</target>
        </trans-unit>
        <trans-unit id="1dad3a3b77cbf00bf58d87ee853af6d3cddb344a" translate="yes" xml:space="preserve">
          <source>Treat the revision argument as a &amp;lt;revision range&amp;gt;, even if it is just a single commit (that would normally be treated as a &amp;lt;since&amp;gt;). Note that root commits included in the specified range are always formatted as creation patches, independently of this flag.</source>
          <target state="translated">将修订版参数视为&amp;lt;修订版范围&amp;gt;，即使它只是一次提交（通常将被视为&amp;lt;since&amp;gt;）。请注意，包含在指定范围内的root提交始终被格式化为创建补丁，而与该标志无关。</target>
        </trans-unit>
        <trans-unit id="aa88eae97d6ad1936bc41000081122649aee8d74" translate="yes" xml:space="preserve">
          <source>Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;-b&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, &lt;code&gt;--ignore-space-at-eol&lt;/code&gt;, and &lt;code&gt;--ignore-cr-at-eol&lt;/code&gt;.</source>
          <target state="translated">为了进行三向合并，将具有指定空白类型更改的行视为未更改。空格更改与行的其他更改混合在一起将不被忽略。另请参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;-b&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; ，-- &lt;code&gt;--ignore-space-at-eol&lt;/code&gt; 和 &lt;code&gt;--ignore-cr-at-eol&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ddd0e484558c1f8e50a8fe3c2dc7499225a9297" translate="yes" xml:space="preserve">
          <source>Tree Object</source>
          <target state="translated">树形对象</target>
        </trans-unit>
        <trans-unit id="bce93b7f9d4c3064a3f582b574710500d7e5efb5" translate="yes" xml:space="preserve">
          <source>Tree and blob objects outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; will be treated the same way as if they were inside &lt;code&gt;refs/tags/*&lt;/code&gt;, any update of them will be rejected.</source>
          <target state="translated">&lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 之外的tree和blob对象将被视为与 &lt;code&gt;refs/tags/*&lt;/code&gt; 内的对象相同的方式对待，否则将拒绝更新它们。</target>
        </trans-unit>
        <trans-unit id="faed43d5018a65bdda1021ea817b81efdd882a1f" translate="yes" xml:space="preserve">
          <source>Tree objects as well as tag objects not pointing at commits, cannot be described. When describing blobs, the lightweight tags pointing at blobs are ignored, but the blob is still described as &amp;lt;committ-ish&amp;gt;:&amp;lt;path&amp;gt; despite the lightweight tag being favorable.</source>
          <target state="translated">无法描述树对象以及未指向提交的标记对象。在描述blob时，指向blob的轻量级标签将被忽略，但是尽管该轻量级标签是有利的，但该blob仍被描述为&amp;lt;committ-ish&amp;gt;：&amp;lt;path&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="d94a666a1561928de12071aa36f46464acd70f54" translate="yes" xml:space="preserve">
          <source>Tree to checkout from (when paths are given). If not specified, the index will be used.</source>
          <target state="translated">签出的树(给定路径时)。如果没有指定,将使用索引。</target>
        </trans-unit>
        <trans-unit id="fef8232d1c67b8b3403ba454c8ae3c965dc5fb72" translate="yes" xml:space="preserve">
          <source>Trees (aka directories) use just 12 bytes of memory on top of the memory required for their entries (see &amp;ldquo;per active file&amp;rdquo; below). The cost of a tree is virtually 0, as its overhead amortizes out over the individual file entries.</source>
          <target state="translated">树（又名目录）仅在其条目所需的内存之上使用12个字节的内存（请参见下面的&amp;ldquo;每个活动文件&amp;rdquo;）。一棵树的成本实际上为0，因为其开销在各个文件条目上摊销。</target>
        </trans-unit>
        <trans-unit id="2bb80d7d00c0395ecaf93c5dc9cd657c191b576d" translate="yes" xml:space="preserve">
          <source>Tries to reinstate not only the working tree&amp;rsquo;s changes, but also the index&amp;rsquo;s ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally).</source>
          <target state="translated">试图不仅恢复工作树的更改，而且恢复索引的更改。但是，当您有冲突时（存储在索引中，因此您不再可以像以前那样应用更改），这可能会失败。</target>
        </trans-unit>
        <trans-unit id="8797468d6463e4f71332170d9f50ca7fd321cc3a" translate="yes" xml:space="preserve">
          <source>Trivial merges are done by &lt;code&gt;git read-tree&lt;/code&gt; itself. Only conflicting paths will be in unmerged state when &lt;code&gt;git read-tree&lt;/code&gt; returns.</source>
          <target state="translated">琐碎的合并由 &lt;code&gt;git read-tree&lt;/code&gt; 本身完成。 &lt;code&gt;git read-tree&lt;/code&gt; 返回时，只有冲突的路径才会处于未合并状态。</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="c14d8e783a9f521d30b73eb971eac8f82acc62a0" translate="yes" xml:space="preserve">
          <source>True merge</source>
          <target state="translated">真正的合并</target>
        </trans-unit>
        <trans-unit id="33a579ffc0dccbff15be01734ea4138ea4e7635c" translate="yes" xml:space="preserve">
          <source>Trust</source>
          <target state="translated">Trust</target>
        </trans-unit>
        <trans-unit id="df8a0e781552ee165e12d7086194c5f37262dc36" translate="yes" xml:space="preserve">
          <source>Try to speed up the traversal using the pack bitmap index (if one is available). Note that when traversing with &lt;code&gt;--objects&lt;/code&gt;, trees and blobs will not have their associated path printed.</source>
          <target state="translated">尝试使用包位图索引（如果有）来加快遍历速度。请注意，使用 &lt;code&gt;--objects&lt;/code&gt; 遍历时，树和blob将不会打印其关联路径。</target>
        </trans-unit>
        <trans-unit id="db494399fc91d335ea933090c261cf51f7615da6" translate="yes" xml:space="preserve">
          <source>Try to update from the upstream resulted in a lot of conflicts; you were not ready to spend a lot of time merging right now, so you decide to do that later.</source>
          <target state="translated">尝试从上游更新导致了很多冲突,你现在还没准备好花大量时间合并,所以你决定以后再做。</target>
        </trans-unit>
        <trans-unit id="3a12d2b4901990f4e580a360ff850809fe3f67b9" translate="yes" xml:space="preserve">
          <source>Turn off any previous &lt;code&gt;--filter=&lt;/code&gt; argument.</source>
          <target state="translated">关闭任何以前的 &lt;code&gt;--filter=&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="34771065d121fc03fac8d38d540e254893826329" translate="yes" xml:space="preserve">
          <source>Turn off branch colors, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">即使配置文件将颜色输出设置为默认值，也要关闭分支颜色。与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="6d9cbb32ce6c68e264cdb30b91e954cf183958d3" translate="yes" xml:space="preserve">
          <source>Turn off colored diff. It is the same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">关闭彩色差异。它与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="3d9b2354f095eeb41acddbf4f3d69d4ac5775813" translate="yes" xml:space="preserve">
          <source>Turn off colored diff. This can be used to override configuration settings. It is the same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">关闭彩色差异。这可用于覆盖配置设置。它与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="8ad464ef4a6c59cdcb2319e829113b9b9a0202fe" translate="yes" xml:space="preserve">
          <source>Turn off colored output, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">即使配置文件将默认设置为彩色输出，也要关闭彩色输出。与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="a3a997309d5fb6a6ca30f0f6201f278a284d8e1e" translate="yes" xml:space="preserve">
          <source>Turn off match highlighting, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">即使配置文件将颜色输出设置为默认值，也要关闭匹配突出显示。与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d4fab0f230de92fdcff08739247b39013a4dcf91" translate="yes" xml:space="preserve">
          <source>Turn off move detection. This can be used to override configuration settings. It is the same as &lt;code&gt;--color-moved=no&lt;/code&gt;.</source>
          <target state="translated">关闭移动检测。这可用于覆盖配置设置。与 &lt;code&gt;--color-moved=no&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b0eb0b106db412297afc722cb22850ad8fd89466" translate="yes" xml:space="preserve">
          <source>Turn off rename detection, even when the configuration file gives the default to do so.</source>
          <target state="translated">关闭重命名检测,即使配置文件给出的默认是这样做。</target>
        </trans-unit>
        <trans-unit id="4e867193eda90e02a99d5e3b2d3aff016424ee32" translate="yes" xml:space="preserve">
          <source>Turn off rename detection. This overrides the &lt;code&gt;merge.renames&lt;/code&gt; configuration variable. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--no-renames&lt;/code&gt;.</source>
          <target state="translated">关闭重命名检测。这将覆盖 &lt;code&gt;merge.renames&lt;/code&gt; 配置变量。另请参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--no-renames&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29eb4a9a74bb1156273caaa264fc85825c0572ef" translate="yes" xml:space="preserve">
          <source>Turn on rename detection, optionally setting the similarity threshold. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--find-renames&lt;/code&gt;.</source>
          <target state="translated">打开重命名检测，可以选择设置相似性阈值。另见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--find-renames&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a279dbfc86c680add56c7a5993ef6023dec20637" translate="yes" xml:space="preserve">
          <source>Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the &lt;code&gt;merge.renames&lt;/code&gt; configuration variable. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--find-renames&lt;/code&gt;.</source>
          <target state="translated">打开重命名检测，可以选择设置相似性阈值。这是默认值。这将覆盖 &lt;code&gt;merge.renames&lt;/code&gt; 配置变量。另见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--find-renames&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9d077a66918e3017c929a4d5ef75e05f491a825" translate="yes" xml:space="preserve">
          <source>Turn on/off rename detection regardless of user configuration. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--no-renames&lt;/code&gt;.</source>
          <target state="translated">无论用户配置如何，都可以打开/关闭重命名检测。另请参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--no-renames&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff597cb2e8f500da1bb43f369ea55f0017801fbc" translate="yes" xml:space="preserve">
          <source>Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal.</source>
          <target state="translated">明确开启/关闭进度。如果两者都不指定,如果标准误差连接到终端,则显示进度。</target>
        </trans-unit>
        <trans-unit id="b63e204e5b5bb236923126ba202fed353f8079ec" translate="yes" xml:space="preserve">
          <source>Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal. Note that not all merge strategies may support progress reporting.</source>
          <target state="translated">明确开启/关闭进度。如果两者都不指定,如果标准误差连接到终端,则显示进度。注意,并非所有的合并策略都支持进度报告。</target>
        </trans-unit>
        <trans-unit id="ae22b8d4ecb731b706e41a653df929373ee8e8e0" translate="yes" xml:space="preserve">
          <source>Turns off any previous &lt;code&gt;--filter=&lt;/code&gt; argument.</source>
          <target state="translated">关闭任何以前的 &lt;code&gt;--filter=&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="954e9a2594b4d5687b25c9c1a8357bca3253b18f" translate="yes" xml:space="preserve">
          <source>Tweaking diff output</source>
          <target state="translated">调整差分输出</target>
        </trans-unit>
        <trans-unit id="aef2d842e6b781b12f96bc62f4ab607c12e12218" translate="yes" xml:space="preserve">
          <source>Two Tree Merge</source>
          <target state="translated">双树合并</target>
        </trans-unit>
        <trans-unit id="6bda5442e87e811366b94ce6966009ecac6ac5dc" translate="yes" xml:space="preserve">
          <source>Two consecutive asterisks (&quot;&lt;code&gt;**&lt;/code&gt;&quot;) in patterns matched against full pathname may have special meaning:</source>
          <target state="translated">模式中与完整路径名匹配的两个连续星号（&amp;ldquo; &lt;code&gt;**&lt;/code&gt; &amp;rdquo;）可能具有特殊含义：</target>
        </trans-unit>
        <trans-unit id="e187ca5222f2f1c9a298321896225faf75c5697a" translate="yes" xml:space="preserve">
          <source>Two consecutive asterisks (&amp;ldquo;**&amp;rdquo;) in patterns matched against full pathname may have special meaning:</source>
          <target state="translated">与完整路径名匹配的模式中的两个连续星号（&amp;ldquo; **&amp;rdquo;）可能具有特殊含义：</target>
        </trans-unit>
        <trans-unit id="fce699584c34eaef39ec9c341ad51961e194a419" translate="yes" xml:space="preserve">
          <source>Two special values are supported: &lt;code&gt;off&lt;/code&gt; will simply close the corresponding standard handle, and if &lt;code&gt;GIT_REDIRECT_STDERR&lt;/code&gt; is &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;, standard error will be redirected to the same handle as standard output.</source>
          <target state="translated">支持两个特殊值： &lt;code&gt;off&lt;/code&gt; 将仅关闭相应的标准句柄，并且如果 &lt;code&gt;GIT_REDIRECT_STDERR&lt;/code&gt; 为 &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; ，则将标准错误重定向到与标准输出相同的句柄。</target>
        </trans-unit>
        <trans-unit id="34a739d621f3038babff4f0f681d077135e77a75" translate="yes" xml:space="preserve">
          <source>Two things are interesting here:</source>
          <target state="translated">这里有两件事很有意思。</target>
        </trans-unit>
        <trans-unit id="ced48512ad4d3cb13ca20b7cb1f2f8e4abd0bc9d" translate="yes" xml:space="preserve">
          <source>Tying it all together</source>
          <target state="translated">把所有的事情联系在一起</target>
        </trans-unit>
        <trans-unit id="3a87a5a93967e0c0facb5bdbedab0a6936494920" translate="yes" xml:space="preserve">
          <source>Type 5 is reserved for future expansion. Type 0 is invalid.</source>
          <target state="translated">类型5是为将来的扩展保留的。类型0是无效的。</target>
        </trans-unit>
        <trans-unit id="e8e8d3184972cec12ef3bd94d7eec7947cbe4b53" translate="yes" xml:space="preserve">
          <source>Typical gitweb config files will only change starting (default) time zone, and leave other elements at their default values:</source>
          <target state="translated">典型的gitweb配置文件只会改变起始(默认)时区,而让其他元素保持默认值。</target>
        </trans-unit>
        <trans-unit id="3aa25a3911a2da2f000729dbc451ee040fee4a66" translate="yes" xml:space="preserve">
          <source>Typical usage is something like:</source>
          <target state="translated">典型的用法是这样的。</target>
        </trans-unit>
        <trans-unit id="db1f5b1028dc570d4bb8caccd45a45601a38210c" translate="yes" xml:space="preserve">
          <source>Typical use of git credential</source>
          <target state="translated">git证书的典型用法</target>
        </trans-unit>
        <trans-unit id="d63a8a509d39725ec5fc85189ba54ffbab2dd0bb" translate="yes" xml:space="preserve">
          <source>Typically it will be placed in a MUA&amp;rsquo;s drafts folder, edited to add timely commentary that should not go in the changelog after the three dashes, and then sent as a message whose body, in our example, starts with &quot;arch/arm config files were&amp;hellip;​&quot;. On the receiving end, readers can save interesting patches in a UNIX mailbox and apply them with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;.</source>
          <target state="translated">通常，它将放置在MUA的drafts文件夹中，进行编辑以添加及时的注释，该注释不应在三个破折号之后出现在变更日志中，然后作为消息发送，其主体在我们的示例中以&amp;ldquo; arch / arm配置文件开头&amp;hellip;&amp;rdquo;。在接收端，读者可以将有趣的补丁程序保存在UNIX邮箱中，并通过&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;应用它们。</target>
        </trans-unit>
        <trans-unit id="3b51965ce078cc4b0d9ecb0a1b113a383a8700dc" translate="yes" xml:space="preserve">
          <source>Typically such a variable may look like this:</source>
          <target state="translated">一般来说,这样的变量可能是这样的。</target>
        </trans-unit>
        <trans-unit id="9f47be9cc1e7fcec80fcc7e52dcbd486a27d2ee2" translate="yes" xml:space="preserve">
          <source>Typically this is run with a script calling Git&amp;rsquo;s imitation of the &lt;code&gt;merge&lt;/code&gt; command from the RCS package.</source>
          <target state="translated">通常，这是通过脚本调用Git模仿RCS包中的 &lt;code&gt;merge&lt;/code&gt; 命令来运行的。</target>
        </trans-unit>
        <trans-unit id="e4333d902cedfd0d4739277fdec621b3f9f09422" translate="yes" xml:space="preserve">
          <source>Typically this matches the real type of &amp;lt;object&amp;gt; but asking for a type that can trivially be dereferenced from the given &amp;lt;object&amp;gt; is also permitted. An example is to ask for a &quot;tree&quot; with &amp;lt;object&amp;gt; being a commit object that contains it, or to ask for a &quot;blob&quot; with &amp;lt;object&amp;gt; being a tag object that points at it.</source>
          <target state="translated">通常，它与&amp;lt;object&amp;gt;的实际类型匹配，但是也允许要求可以从给定的&amp;lt;object&amp;gt;取消引用的类型。一个示例是要求一个带有&amp;lt;object&amp;gt;作为包含它的提交对象的&amp;ldquo;树&amp;rdquo;，或者要求一个带有&amp;lt;object&amp;gt;是指向它的标记对象的&amp;ldquo; blob&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6b016c5601edd059fd8dc12bb8d8426b6525fff2" translate="yes" xml:space="preserve">
          <source>Typically you would first remove all tracked files from the working tree using this command:</source>
          <target state="translated">通常情况下,你会先用这个命令从工作树中删除所有跟踪的文件。</target>
        </trans-unit>
        <trans-unit id="3a2ee6ee14f11a86e1818d26c21e9493d38718f1" translate="yes" xml:space="preserve">
          <source>Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel.</source>
          <target state="translated">通常情况下,并行递归和多远程的获取会更快。默认情况下,检索是按顺序执行的,而不是并行的。</target>
        </trans-unit>
        <trans-unit id="94e92e77c127b9c8a314ec2c48c4916e008c6404" translate="yes" xml:space="preserve">
          <source>Typically, this is invoked as &lt;code&gt;git read-tree -m $H $M&lt;/code&gt;, where $H is the head commit of the current repository, and $M is the head of a foreign tree, which is simply ahead of $H (i.e. we are in a fast-forward situation).</source>
          <target state="translated">通常，这是作为 &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; 调用的，其中$ H是当前存储库的头提交，而$ M是外来树的头，仅在$ H之前（即，处于快速发展的状态）。</target>
        </trans-unit>
        <trans-unit id="0ada5827188094ef6e82c28e45e078ca96f54ca4" translate="yes" xml:space="preserve">
          <source>U: file is unmerged (you must complete the merge before it can be committed)</source>
          <target state="translated">U:文件未合并(必须在提交前完成合并)</target>
        </trans-unit>
        <trans-unit id="1a7a0d0dd35212ae4c8c4c873315c6e7e9351f3b" translate="yes" xml:space="preserve">
          <source>URI and label (title) for the Git logo link (or your site logo, if you chose to use different logo image). By default, these both refer to Git homepage, &lt;a href=&quot;https://git-scm.com&quot;&gt;https://git-scm.com&lt;/a&gt;; in the past, they pointed to Git documentation at &lt;a href=&quot;https://www.kernel.org&quot;&gt;https://www.kernel.org&lt;/a&gt;.</source>
          <target state="translated">Git徽标链接（或站点徽标，如果您选择使用其他徽标图像）的URI和标签（标题）。默认情况下，它们都指向Git主页&lt;a href=&quot;https://git-scm.com&quot;&gt;https://git-scm.com&lt;/a&gt; ; 过去，他们指向&lt;a href=&quot;https://www.kernel.org&quot;&gt;https://www.kernel.org&lt;/a&gt;上的Git文档。</target>
        </trans-unit>
        <trans-unit id="8561702ffd22bbb5ccd1a81c9c8d8cc77f16fa7e" translate="yes" xml:space="preserve">
          <source>Un-sets the previously set type specifier (if one was previously set). This option requests that &lt;code&gt;git config&lt;/code&gt; not canonicalize the retrieved variable. &lt;code&gt;--no-type&lt;/code&gt; has no effect without &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; or &lt;code&gt;--&amp;lt;type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">取消设置先前设置的类型说明符（如果先前已设置）。此选项要求 &lt;code&gt;git config&lt;/code&gt; 不规范检索到的变量。没有 &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; 或 &lt;code&gt;--&amp;lt;type&amp;gt;&lt;/code&gt; no &lt;code&gt;--no-type&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="911839695653d988872929c95814b8902e300040" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--pretty=oneline&lt;/code&gt;, the commit message is prefixed with this information on the same line. This option cannot be combined with &lt;code&gt;--reverse&lt;/code&gt;. See also &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;--pretty=oneline&lt;/code&gt; 下，提交消息在同一行上带有此信息的前缀。此选项不能与 &lt;code&gt;--reverse&lt;/code&gt; 结合使用。另见&lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64ba59969ba5a36d002d9a189101c624fcf7d3cc" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--pretty=reference&lt;/code&gt;, this information will not be shown at all.</source>
          <target state="translated">在 &lt;code&gt;--pretty=reference&lt;/code&gt; 下，此信息将完全不显示。</target>
        </trans-unit>
        <trans-unit id="c73a6e04cc57ad10ee4ae7284f559a5ae2a53d36" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, some versions of &lt;code&gt;diff&lt;/code&gt; do not correctly detect a missing new-line at the end of the file. As a result, patches created by such &lt;code&gt;diff&lt;/code&gt; programs do not record incomplete lines correctly. This option adds support for applying such patches by working around this bug.</source>
          <target state="translated">在某些情况下，某些版本的 &lt;code&gt;diff&lt;/code&gt; 无法正确检测到文件末尾缺少的换行符。结果，由此类 &lt;code&gt;diff&lt;/code&gt; 程序创建的补丁无法正确记录不完整的行。通过解决此错误，此选项增加了对应用此类修补程序的支持。</target>
        </trans-unit>
        <trans-unit id="67a27dbf5548d05ac63e85bd8b4c875d8f48c102" translate="yes" xml:space="preserve">
          <source>Understanding History: Commits</source>
          <target state="translated">了解历史。承诺</target>
        </trans-unit>
        <trans-unit id="9334dba95d5dfb2042093dd9adbddea5f77c5eb4" translate="yes" xml:space="preserve">
          <source>Understanding history: History diagrams</source>
          <target state="translated">了解历史。历史图表</target>
        </trans-unit>
        <trans-unit id="85bd1a7ea75afef7e0417cd2bf9d9f3cf13e5e08" translate="yes" xml:space="preserve">
          <source>Understanding history: What is a branch?</source>
          <target state="translated">了解历史。什么是分支?</target>
        </trans-unit>
        <trans-unit id="6d61d96a492f996316f1e84e66cbfde933315e2c" translate="yes" xml:space="preserve">
          <source>Understanding history: commits, parents, and reachability</source>
          <target state="translated">了解历史:承诺、父母和可达到性。</target>
        </trans-unit>
        <trans-unit id="afa47a28efb9d6631a7be02ac359bed5256995ce" translate="yes" xml:space="preserve">
          <source>Undo a commit and redo</source>
          <target state="translated">撤销提交并重做</target>
        </trans-unit>
        <trans-unit id="61cb90c052dfcd0fda883c6029d1d0fc0a0f4685" translate="yes" xml:space="preserve">
          <source>Undo a commit, making it a topic branch</source>
          <target state="translated">撤销提交,使其成为一个主题分支。</target>
        </trans-unit>
        <trans-unit id="93d74feb000c815128d68a09c83733db43b69c15" translate="yes" xml:space="preserve">
          <source>Undo a merge or pull</source>
          <target state="translated">撤销合并或拉动</target>
        </trans-unit>
        <trans-unit id="4728c70cd06347b5f285fb3e7887387303b3968e" translate="yes" xml:space="preserve">
          <source>Undo a merge or pull inside a dirty working tree</source>
          <target state="translated">撤销合并或拉入脏工作树内的操作。</target>
        </trans-unit>
        <trans-unit id="27b7abb5b90b7a2e8f00eaf74b6df8323ba7d926" translate="yes" xml:space="preserve">
          <source>Undo add</source>
          <target state="translated">撤销添加</target>
        </trans-unit>
        <trans-unit id="ca677a11d37ffdca5231911a194cc2fcdffc5a26" translate="yes" xml:space="preserve">
          <source>Undo commits permanently</source>
          <target state="translated">永久撤销承诺</target>
        </trans-unit>
        <trans-unit id="4180759bca2f04cde0ec69611cb0e0ec1cfe7139" translate="yes" xml:space="preserve">
          <source>Undoes the effects of &lt;code&gt;fetch&lt;/code&gt; back to the specified revision. This allows you to re-&lt;code&gt;fetch&lt;/code&gt; an SVN revision. Normally the contents of an SVN revision should never change and &lt;code&gt;reset&lt;/code&gt; should not be necessary. However, if SVN permissions change, or if you alter your --ignore-paths option, a &lt;code&gt;fetch&lt;/code&gt; may fail with &quot;not found in commit&quot; (file not previously visible) or &quot;checksum mismatch&quot; (missed a modification). If the problem file cannot be ignored forever (with --ignore-paths) the only way to repair the repo is to use &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">撤消 &lt;code&gt;fetch&lt;/code&gt; 指定修订的影响。这使您可以 &lt;code&gt;fetch&lt;/code&gt; SVN修订版。通常，SVN修订版的内容永远不应该更改，也不必 &lt;code&gt;reset&lt;/code&gt; 。但是，如果SVN权限发生更改，或者更改了--ignore-paths选项，则 &lt;code&gt;fetch&lt;/code&gt; 可能会失败，并显示&amp;ldquo;未在提交中找到&amp;rdquo;（以前不可见的文件）或&amp;ldquo;校验和不匹配&amp;rdquo;（缺少修改）。如果无法永久忽略问题文件（使用--ignore-paths），则修复存储库的唯一方法是使用 &lt;code&gt;reset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac1f58f831611819b4114b80dd55e3ce540d5b23" translate="yes" xml:space="preserve">
          <source>Undoing a merge</source>
          <target state="translated">撤销合并</target>
        </trans-unit>
        <trans-unit id="f552d5a5802e3df6273c784214def9840b82f594" translate="yes" xml:space="preserve">
          <source>Unfortunately this system becomes inefficient once a project has a lot of objects. Try this on an old project:</source>
          <target state="translated">不幸的是,一旦一个项目有很多对象,这个系统就会变得效率低下。在一个旧项目上试试这个。</target>
        </trans-unit>
        <trans-unit id="c7deb06b3e42a38e2b00598939aa39f8d24897bd" translate="yes" xml:space="preserve">
          <source>Unfortunately, the desired effect of cleaning up text files with mixed line endings and the undesired effect of corrupting binary files cannot be distinguished. In both cases CRLFs are removed in an irreversible way. For text files this is the right thing to do because CRLFs are line endings, while for binary files converting CRLFs corrupts data.</source>
          <target state="translated">遗憾的是,清理行尾混杂的文本文件的理想效果和破坏二进制文件的不理想效果无法区分。在这两种情况下,CRLFs都是以一种不可逆的方式被删除的。对于文本文件来说,这是正确的做法,因为CRLFs是行尾,而对于二进制文件来说,转换CRLFs会破坏数据。</target>
        </trans-unit>
        <trans-unit id="6da1ce58d3a6c34c76807dc44593d7cd8c6563b6" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;--text&lt;/code&gt; is supplied patches of binary files without a textconv filter will be ignored.</source>
          <target state="translated">除非提供了 &lt;code&gt;--text&lt;/code&gt; ,否则将忽略不具有textconv过滤器的二进制文件补丁。</target>
        </trans-unit>
        <trans-unit id="54cbf98b314812a07f65f95ae77e8608ddf0b26f" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-f&lt;/code&gt; is given, the &lt;code&gt;replace&lt;/code&gt; reference must not yet exist.</source>
          <target state="translated">除非给出 &lt;code&gt;-f&lt;/code&gt; ，否则 &lt;code&gt;replace&lt;/code&gt; 引用必须不存在。</target>
        </trans-unit>
        <trans-unit id="ec0a9816e3fe8947b4bfff6f5914c3288bed6fc9" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-f&lt;/code&gt; is given, the named tag must not yet exist.</source>
          <target state="translated">除非给出 &lt;code&gt;-f&lt;/code&gt; ，否则命名标记必须还不存在。</target>
        </trans-unit>
        <trans-unit id="7824ccb45f3d7be1fd07def25712792fbdf3f009" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git blame&lt;/code&gt; and &lt;code&gt;git annotate&lt;/code&gt; in older versions of git, the extent of the annotation can be limited to both line ranges and revision ranges. The &lt;code&gt;-L&lt;/code&gt; option, which limits annotation to a range of lines, may be specified multiple times.</source>
          <target state="translated">与 &lt;code&gt;git blame&lt;/code&gt; 和 &lt;code&gt;git annotate&lt;/code&gt; 在较早版本的git中不同，注释的范围可以限于行范围和修订范围。的 &lt;code&gt;-L&lt;/code&gt; 选项，这限制了注释的行范围的，可被指定多次。</target>
        </trans-unit>
        <trans-unit id="1fa5e3a4c28161d2ef67ee80d5624341cfa56be1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git diff-files&lt;/code&gt;, which showed the difference between the index file and the working tree, &lt;code&gt;git diff-index&lt;/code&gt; shows the differences between a committed &lt;strong&gt;tree&lt;/strong&gt; and either the index file or the working tree. In other words, &lt;code&gt;git diff-index&lt;/code&gt; wants a tree to be diffed against, and before we did the commit, we couldn&amp;rsquo;t do that, because we didn&amp;rsquo;t have anything to diff against.</source>
          <target state="translated">与 &lt;code&gt;git diff-files&lt;/code&gt; 不同，后者显示了索引文件和工作树之间的 &lt;code&gt;git diff-index&lt;/code&gt; ，而git diff-index显示了已提交的&lt;strong&gt;树&lt;/strong&gt;与索引文件或工作树之间的差异。换句话说， &lt;code&gt;git diff-index&lt;/code&gt; 希望与一棵树进行比较，而在我们提交之前，我们无法做到这一点，因为我们没有任何要针对的。</target>
        </trans-unit>
        <trans-unit id="a75073ebd9356a7219cb30b4bb866c17ce8b906c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;gitk&lt;/code&gt;, &lt;code&gt;git gui&lt;/code&gt; focuses on commit generation and single file annotation and does not show project history. It does however supply menu actions to start a &lt;code&gt;gitk&lt;/code&gt; session from within &lt;code&gt;git gui&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;gitk&lt;/code&gt; 不同， &lt;code&gt;git gui&lt;/code&gt; 专注于提交生成和单个文件注释，并且不显示项目历史记录。但是，它确实提供了菜单操作以从 &lt;code&gt;git gui&lt;/code&gt; 内部启动 &lt;code&gt;gitk&lt;/code&gt; 会话。</target>
        </trans-unit>
        <trans-unit id="cd17281830ac5a9aa50c0d768481eabf04240182" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;raw&lt;/code&gt; format above, the time zone/UTC offset information contained in an RFC 2822 date string is used to adjust the date value to UTC prior to storage. Therefore it is important that this information be as accurate as possible.</source>
          <target state="translated">与上面的 &lt;code&gt;raw&lt;/code&gt; 格式不同，RFC 2822日期字符串中包含的时区/ UTC偏移信息用于在存储之前将日期值调整为UTC。因此，重要的是此信息应尽可能准确。</target>
        </trans-unit>
        <trans-unit id="b9ebe23208a4d3f51d6690b78b04b40646f8e2f1" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;rfc2822&lt;/code&gt; format, this format is very strict. Any variation in formatting will cause fast-import to reject the value, and some sanity checks on the numeric values may also be performed.</source>
          <target state="translated">与 &lt;code&gt;rfc2822&lt;/code&gt; 格式不同，此格式非常严格。格式上的任何变化都将导致快速导入拒绝该值，并且可能还会对数字值进行一些完整性检查。</target>
        </trans-unit>
        <trans-unit id="422977ffd462a03a6cbce65db58b07001eb2214f" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;rfc2822&lt;/code&gt; format, this format is very strict. Any variation in formatting will cause fast-import to reject the value.</source>
          <target state="translated">与 &lt;code&gt;rfc2822&lt;/code&gt; 格式不同，此格式非常严格。格式上的任何变化都将导致快速导入拒绝该值。</target>
        </trans-unit>
        <trans-unit id="a5e8af576412d2facd9f39a0996da0da165c42ee" translate="yes" xml:space="preserve">
          <source>Unlike the Porcelain format, the filename information is always given and terminates the entry:</source>
          <target state="translated">与瓷器格式不同的是,总是给出文件名信息并终止条目。</target>
        </trans-unit>
        <trans-unit id="b603b31236d9df1a4442c23c62ea6317f2525837" translate="yes" xml:space="preserve">
          <source>Unlike the longhand form, when Alice fetches from Bob using a remote repository shorthand set up with &lt;code&gt;git remote&lt;/code&gt;, what was fetched is stored in a remote-tracking branch, in this case &lt;code&gt;bob/master&lt;/code&gt;. So after this:</source>
          <target state="translated">与长格式不同，当爱丽丝使用通过 &lt;code&gt;git remote&lt;/code&gt; 设置的远程存储库速记从Bob获取时，所获取的内容存储在远程跟踪分支中，在本例中为 &lt;code&gt;bob/master&lt;/code&gt; 。因此，在此之后：</target>
        </trans-unit>
        <trans-unit id="cc8e9909209a90f3a790bc3005980e8527de79e5" translate="yes" xml:space="preserve">
          <source>Unlike the traditional &lt;code&gt;unified&lt;/code&gt; diff format, which shows two files A and B with a single column that has &lt;code&gt;-&lt;/code&gt; (minus &amp;mdash; appears in A but removed in B), &lt;code&gt;+&lt;/code&gt; (plus &amp;mdash; missing in A but added to B), or &lt;code&gt;&quot; &quot;&lt;/code&gt; (space &amp;mdash; unchanged) prefix, this format compares two or more files file1, file2,&amp;hellip;​ with one file X, and shows how X differs from each of fileN. One column for each of fileN is prepended to the output line to note how X&amp;rsquo;s line is different from it.</source>
          <target state="translated">与传统的 &lt;code&gt;unified&lt;/code&gt; 差异格式不同，传统的差异格式显示两个文件A和B，其中一个列具有 &lt;code&gt;-&lt;/code&gt; （减号-在A中出现，但在B中删除）， &lt;code&gt;+&lt;/code&gt; （加号-在A中丢失但添加到B中）或 &lt;code&gt;&quot; &quot;&lt;/code&gt; （空格（未更改）前缀，此格式将两个或多个文件file1，file2 ...与一个文件X进行比较，并显示X与每个fileN有何不同。每个fileN的一列都位于输出行的前面，以指出X的行与之不同。</target>
        </trans-unit>
        <trans-unit id="71233552f2a4fc77054593fac1f6899dd0308229" translate="yes" xml:space="preserve">
          <source>Unlike variables like &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;core.editor&lt;/code&gt; the &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; and &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; variables will not fall back on the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; configuration if they aren&amp;rsquo;t set. To uniformly configure the same fsck settings in different circumstances all three of them they must all set to the same values.</source>
          <target state="translated">与 &lt;code&gt;color.ui&lt;/code&gt; 和 &lt;code&gt;core.editor&lt;/code&gt; 之 &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 变量不同，receive.fsck。&amp;lt;msg-id&amp;gt;和 &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 变量如果不包含在 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 配置中组。为了在不同的情况下统一配置相同的fsck设置，必须将这三个设置都设置为相同的值。</target>
        </trans-unit>
        <trans-unit id="00ee5ed7b48c819f6f323dbe1b9a72aef5a0c864" translate="yes" xml:space="preserve">
          <source>Unlike variables like &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;core.editor&lt;/code&gt; the &lt;code&gt;receive.fsck.skipList&lt;/code&gt; and &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; variables will not fall back on the &lt;code&gt;fsck.skipList&lt;/code&gt; configuration if they aren&amp;rsquo;t set. To uniformly configure the same fsck settings in different circumstances all three of them they must all set to the same values.</source>
          <target state="translated">与变量一样 &lt;code&gt;color.ui&lt;/code&gt; 和 &lt;code&gt;core.editor&lt;/code&gt; 的 &lt;code&gt;receive.fsck.skipList&lt;/code&gt; 和 &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; 变量将不会依傍 &lt;code&gt;fsck.skipList&lt;/code&gt; 如果未设置它们的配置。为了在不同的情况下统一配置相同的fsck设置，必须将这三个设置都设置为相同的值。</target>
        </trans-unit>
        <trans-unit id="8a3dffb4c65d7a1f27e907ef2a919885d1125ac9" translate="yes" xml:space="preserve">
          <source>Unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, any updates outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; will be accepted without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;), whether that&amp;rsquo;s swapping e.g. a tree object for a blob, or a commit for another commit that&amp;rsquo;s doesn&amp;rsquo;t have the previous commit as an ancestor etc.</source>
          <target state="translated">与使用&lt;a href=&quot;git-push&quot;&gt;git-push [1]推送&lt;/a&gt;时不同，在refspec（或 &lt;code&gt;--force&lt;/code&gt; ）中，在 &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 之外的任何更新都将在不带 &lt;code&gt;+&lt;/code&gt; 的情况下被接受，无论是将树对象交换为blob，或针对另一个不具有先前祖先提交的提交的提交等。</target>
        </trans-unit>
        <trans-unit id="2f2516ccb262ba2dda1eeb5218e911868837ce78" translate="yes" xml:space="preserve">
          <source>Unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, there is no configuration which&amp;rsquo;ll amend these rules, and nothing like a &lt;code&gt;pre-fetch&lt;/code&gt; hook analogous to the &lt;code&gt;pre-receive&lt;/code&gt; hook.</source>
          <target state="translated">与推动时不同&lt;a href=&quot;git-push&quot;&gt;的git推[1] &lt;/a&gt;，没有配置which'll修改这些规则，并没有像 &lt;code&gt;pre-fetch&lt;/code&gt; 钩类似于 &lt;code&gt;pre-receive&lt;/code&gt; 钩。</target>
        </trans-unit>
        <trans-unit id="fb79f423670171900d7e94880e8d45907e9f995c" translate="yes" xml:space="preserve">
          <source>Unlock a working tree, allowing it to be pruned, moved or deleted.</source>
          <target state="translated">解锁一棵工作树,允许它被修剪、移动或删除。</target>
        </trans-unit>
        <trans-unit id="b00eee8b49227caba98e5d68033660ff6076ebcc" translate="yes" xml:space="preserve">
          <source>Unmerged entries have the following format; the first character is a &quot;u&quot; to distinguish from ordinary changed entries.</source>
          <target state="translated">未合并的条目具有以下格式;第一个字符是 &quot;u&quot;,以区别于普通的更改条目。</target>
        </trans-unit>
        <trans-unit id="2c99cc569343579b221cd64026ecc62bb1c21d7b" translate="yes" xml:space="preserve">
          <source>Unpack objects from a packed archive</source>
          <target state="translated">从打包的档案中解压对象</target>
        </trans-unit>
        <trans-unit id="42e2a268d032a6abb00d4cbd80feaa1ecd7a75d6" translate="yes" xml:space="preserve">
          <source>Unreachable tags, commits, and trees will also be accessed to find the tips of dangling segments of history. Use &lt;code&gt;--no-dangling&lt;/code&gt; if you don&amp;rsquo;t care about this output and want to speed it up further.</source>
          <target state="translated">无法访问的标签，提交和树也将被访问，以找到悬空的历史片段的提示。如果您不关心此输出并希望进一步提高输出速度，请使用 &lt;code&gt;--no-dangling&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8a4efd1d470fc3c5ede97084c82a35b9804122a" translate="yes" xml:space="preserve">
          <source>Unregister the given submodules, i.e. remove the whole &lt;code&gt;submodule.$name&lt;/code&gt; section from .git/config together with their work tree. Further calls to &lt;code&gt;git submodule update&lt;/code&gt;, &lt;code&gt;git submodule foreach&lt;/code&gt; and &lt;code&gt;git submodule sync&lt;/code&gt; will skip any unregistered submodules until they are initialized again, so use this command if you don&amp;rsquo;t want to have a local checkout of the submodule in your working tree anymore.</source>
          <target state="translated">取消注册给定的子模块，即从.git / config中删除整个 &lt;code&gt;submodule.$name&lt;/code&gt; 部分及其工作树。进一步调用 &lt;code&gt;git submodule update&lt;/code&gt; ， &lt;code&gt;git submodule foreach&lt;/code&gt; 和 &lt;code&gt;git submodule sync&lt;/code&gt; 将跳过所有未注册的子模块，直到再次对其进行初始化为止，因此，如果您不想在工作树中再次使用该子模块，请使用此命令。</target>
        </trans-unit>
        <trans-unit id="1431f68f359f8699975be39dca08302c67d68d9e" translate="yes" xml:space="preserve">
          <source>Unset</source>
          <target state="translated">Unset</target>
        </trans-unit>
        <trans-unit id="8ff954e80b42b18d3d0fcda602d94db1e46da2d4" translate="yes" xml:space="preserve">
          <source>Unsetting the &lt;code&gt;text&lt;/code&gt; attribute on a path tells Git not to attempt any end-of-line conversion upon checkin or checkout.</source>
          <target state="translated">在路径上取消设置 &lt;code&gt;text&lt;/code&gt; 属性会告诉Git在签入或签出时不要尝试任何行尾转换。</target>
        </trans-unit>
        <trans-unit id="7f84947907454dd0cb412d2a8e5d5e3b9c2382f0" translate="yes" xml:space="preserve">
          <source>Unsetting the variable, or setting it to empty, &quot;0&quot; or &quot;false&quot; (case insensitive) disables trace messages.</source>
          <target state="translated">取消设置变量,或将其设置为空、&quot;0 &quot;或 &quot;false&quot;(不区分大小写),禁用跟踪信息。</target>
        </trans-unit>
        <trans-unit id="c176eff9c64fa28a4b6af1aa296cc1394bbf7a80" translate="yes" xml:space="preserve">
          <source>Unshelve</source>
          <target state="translated">Unshelve</target>
        </trans-unit>
        <trans-unit id="9fde2b36ff30053ad23e6a695929873244cc0367" translate="yes" xml:space="preserve">
          <source>Unshelve options</source>
          <target state="translated">解压选项</target>
        </trans-unit>
        <trans-unit id="004e593b6690fb3d48f4f5a86eac1cd13b5b2234" translate="yes" xml:space="preserve">
          <source>Unshelving will take a shelved P4 changelist, and produce the equivalent git commit in the branch refs/remotes/p4-unshelved/&amp;lt;changelist&amp;gt;.</source>
          <target state="translated">取消搁置将使用搁置的P4更改列表，并在分支refs / remotes / p4-unshelved / &amp;lt;changelist&amp;gt;中产生等效的git commit。</target>
        </trans-unit>
        <trans-unit id="a6e7eb706e115cdaf88206be37eb67b232d007bc" translate="yes" xml:space="preserve">
          <source>Unspecified</source>
          <target state="translated">Unspecified</target>
        </trans-unit>
        <trans-unit id="78f88266b367e8b6e086054e91f1ebc89e168d16" translate="yes" xml:space="preserve">
          <source>Until Git version 2.20, and unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, any updates to &lt;code&gt;refs/tags/*&lt;/code&gt; would be accepted without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches. Since Git version 2.20, fetching to update &lt;code&gt;refs/tags/*&lt;/code&gt; works the same way as when pushing. I.e. any updates will be rejected without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;).</source>
          <target state="translated">在Git 2.20之前，与使用&lt;a href=&quot;git-push&quot;&gt;git-push [1]推送&lt;/a&gt;时不同，在refspec（或 &lt;code&gt;--force&lt;/code&gt; ）中不带 &lt;code&gt;+&lt;/code&gt; 的任何对 &lt;code&gt;refs/tags/*&lt;/code&gt; 的更新将被接受。提取时，我们混杂地认为从远程进行的所有标签更新都是强制提取。从Git版本2.20开始，获取更新 &lt;code&gt;refs/tags/*&lt;/code&gt; 的方式与推送时相同。也就是说，任何更新将在refspec（或 &lt;code&gt;--force&lt;/code&gt; ）中不带 &lt;code&gt;+&lt;/code&gt; 的情况下被拒绝。</target>
        </trans-unit>
        <trans-unit id="9514c500d61430538679eec9081979b274172cf9" translate="yes" xml:space="preserve">
          <source>Untracked cache</source>
          <target state="translated">未跟踪的缓存</target>
        </trans-unit>
        <trans-unit id="614ce4ff1bf92552970ab54ff766006d0da693f9" translate="yes" xml:space="preserve">
          <source>Untracked items have the following format:</source>
          <target state="translated">未追踪项目的格式如下:</target>
        </trans-unit>
        <trans-unit id="1eade895e693b4111455eda06a87af1097cf4d6c" translate="yes" xml:space="preserve">
          <source>Untyped &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;, e.g. the contents of a file.</source>
          <target state="translated">无类型的&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;，例如文件的内容。</target>
        </trans-unit>
        <trans-unit id="7b839a219907b09268c047c522a03961e96bd78b" translate="yes" xml:space="preserve">
          <source>Unused configuration variable. Used in Git versions 2.20 and 2.21 as an escape hatch to enable the legacy shellscript implementation of rebase. Now the built-in rewrite of it in C is always used. Setting this will emit a warning, to alert any remaining users that setting this now does nothing.</source>
          <target state="translated">未使用的配置变量。在 Git 2.20 和 2.21 版本中,它被用来作为一个转义窗口,以启用传统的 shell 脚本实现 rebase。现在总是使用 C 语言的内置重写。设置这个变量会发出一个警告,以提醒其余用户,设置这个变量不会有任何作用。</target>
        </trans-unit>
        <trans-unit id="315fc3f07f41b1c3600ceb87f6a9f32b85f1da70" translate="yes" xml:space="preserve">
          <source>Unused configuration variable. Used in Git versions 2.22 to 2.26 as an escape hatch to enable the legacy shellscript implementation of stash. Now the built-in rewrite of it in C is always used. Setting this will emit a warning, to alert any remaining users that setting this now does nothing.</source>
          <target state="translated">未使用的配置变量。在 Git 2.22 到 2.26 版本中,它被用来作为一个转义窗口,以启用传统的 shellscript 实现 stash。现在总是使用 C 语言的内置重写。设置这个变量会发出一个警告,以提醒其余用户,设置这个变量不会有任何作用。</target>
        </trans-unit>
        <trans-unit id="ca31b4c795dcb03444e6d0c037dbcd47081c70a9" translate="yes" xml:space="preserve">
          <source>Update affected files from CVS repository before attempting export.</source>
          <target state="translated">在尝试导出之前,更新CVS仓库中受影响的文件。</target>
        </trans-unit>
        <trans-unit id="82e59b151c004802a1fa23ba3e75a68d14df0e2a" translate="yes" xml:space="preserve">
          <source>Update an existing shelved changelist with this commit. Implies --shelve. Repeat for multiple shelved changelists.</source>
          <target state="translated">用此提交更新已搁置的变更列表。意味着 --shelve。对多个搁置的变更列表重复此操作。</target>
        </trans-unit>
        <trans-unit id="5433caf2e572561b5bb38ff5e69b0263d08b90aa" translate="yes" xml:space="preserve">
          <source>Update and examine branches from the repository you cloned from:</source>
          <target state="translated">更新和检查你克隆的仓库中的分支。</target>
        </trans-unit>
        <trans-unit id="381f15e94e347f076ef71f417ee29b782a6dcc4d" translate="yes" xml:space="preserve">
          <source>Update auxiliary info file to help dumb servers</source>
          <target state="translated">更新辅助信息文件以帮助哑巴服务器。</target>
        </trans-unit>
        <trans-unit id="d94aecddb1a2d3c03afb4a7cf4e1bb3a0123c2c6" translate="yes" xml:space="preserve">
          <source>Update hook</source>
          <target state="translated">更新钩子</target>
        </trans-unit>
        <trans-unit id="e5f960e3f28d7d7ea59f8750682a356ae18535be" translate="yes" xml:space="preserve">
          <source>Update remote refs along with associated objects</source>
          <target state="translated">更新远程参考文献和相关对象</target>
        </trans-unit>
        <trans-unit id="ee3315ea0cbb49ab6105a89db0964480184c3ce9" translate="yes" xml:space="preserve">
          <source>Update the Git repository with recent changes from p4, rebasing your work on top:</source>
          <target state="translated">用p4的最新变化更新Git仓库,将你的工作重新建立在上面。</target>
        </trans-unit>
        <trans-unit id="5937294218e2d7b95b7b77414b52c326239ca8d5" translate="yes" xml:space="preserve">
          <source>Update the index by adding new files that are unknown to the index and files modified in the working tree, but ignore files that have been removed from the working tree. This option is a no-op when no &amp;lt;pathspec&amp;gt; is used.</source>
          <target state="translated">通过添加索引未知的新文件和在工作树中修改的文件来更新索引，但忽略已从工作树中删除的文件。当不使用&amp;lt;pathspec&amp;gt;时，此选项为no-op。</target>
        </trans-unit>
        <trans-unit id="94df66721f1bfd4990972c3f5f4a0d6b61f59f9e" translate="yes" xml:space="preserve">
          <source>Update the index just where it already has an entry matching &amp;lt;pathspec&amp;gt;. This removes as well as modifies index entries to match the working tree, but adds no new files.</source>
          <target state="translated">在索引已经具有与&amp;lt;pathspec&amp;gt;匹配的条目的地方更新索引。这会删除和修改索引条目以匹配工作树，但不会添加任何新文件。</target>
        </trans-unit>
        <trans-unit id="03d173e098621e3730258998672da85e88b347b1" translate="yes" xml:space="preserve">
          <source>Update the index not only where the working tree has a file matching &amp;lt;pathspec&amp;gt; but also where the index already has an entry. This adds, modifies, and removes index entries to match the working tree.</source>
          <target state="translated">不仅在工作树具有与&amp;lt;pathspec&amp;gt;匹配的文件的地方，而且在索引已经具有条目的地方，更新索引。这将添加，修改和删除索引条目以匹配工作树。</target>
        </trans-unit>
        <trans-unit id="1a6e291eaaa3e731de98429f7fb37fdac90f0a22" translate="yes" xml:space="preserve">
          <source>Update the object name stored in a ref safely</source>
          <target state="translated">安全地更新存储在ref中的对象名称</target>
        </trans-unit>
        <trans-unit id="00f0c8a1eac4ed2966a7d563ef87a6387d365dcf" translate="yes" xml:space="preserve">
          <source>Update the origin repository&amp;rsquo;s master branch with the dev branch, allowing non-fast-forward updates. &lt;strong&gt;This can leave unreferenced commits dangling in the origin repository.&lt;/strong&gt; Consider the following situation, where a fast-forward is not possible:</source>
          <target state="translated">使用dev分支更新原始存储库的master分支，从而允许非快速更新。&lt;strong&gt;这可能会使未引用的提交悬在原始存储库中。&lt;/strong&gt;请考虑以下情况，其中不可能实现快进：</target>
        </trans-unit>
        <trans-unit id="b73d3968359117cfd051c2e81a709d1d9e1579b7" translate="yes" xml:space="preserve">
          <source>Update the reference to the value of the top reflog entry (i.e. &amp;lt;ref&amp;gt;@{0}) if the previous top entry was pruned. (This option is ignored for symbolic references.)</source>
          <target state="translated">如果先前的顶部条目被修剪，则将引用更新为顶部条目列表的值（即&amp;lt;ref&amp;gt; @ {0}）。（对于符号引用，将忽略此选项。）</target>
        </trans-unit>
        <trans-unit id="d7c08d3ae4fbcbbf6a3dc89cdba309659a4395bc" translate="yes" xml:space="preserve">
          <source>Update the reflog for &amp;lt;name&amp;gt; with &amp;lt;reason&amp;gt;. This is valid only when creating or updating a symbolic ref.</source>
          <target state="translated">用&amp;lt;原因&amp;gt;更新&amp;lt;名称&amp;gt;的引用日志。仅在创建或更新符号引用时有效。</target>
        </trans-unit>
        <trans-unit id="d053e75e709458eca9f01e5c8910658ea18a25cf" translate="yes" xml:space="preserve">
          <source>Update the registered submodules to match what the superproject expects by cloning missing submodules, fetching missing commits in submodules and updating the working tree of the submodules. The &quot;updating&quot; can be done in several ways depending on command line options and the value of &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration variable. The command line option takes precedence over the configuration variable. If neither is given, a &lt;code&gt;checkout&lt;/code&gt; is performed. The &lt;code&gt;update&lt;/code&gt; procedures supported both from the command line as well as through the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration are:</source>
          <target state="translated">通过克隆丢失的子模块，在子模块中获取丢失的提交并更新子模块的工作树，更新已注册的子模块，以符合超级项目的期望。根据命令行选项和 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 配置变量的值，可以通过几种方式完成&amp;ldquo;更新&amp;rdquo; 。命令行选项优先于配置变量。如果两者均未给出，则执行 &lt;code&gt;checkout&lt;/code&gt; 。该 &lt;code&gt;update&lt;/code&gt; 程序的命令行以及通过所支持的两个 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 配置为：</target>
        </trans-unit>
        <trans-unit id="9a189cb9ecf6f808972788504f5218556d75488e" translate="yes" xml:space="preserve">
          <source>Update the remote-tracking branches for the repository you cloned from, then merge one of them into your current branch:</source>
          <target state="translated">更新你克隆的仓库的远程跟踪分支,然后将其中一个分支合并到你当前的分支中。</target>
        </trans-unit>
        <trans-unit id="b4a6a66956cae4a12a849cae6094fa1d9187d293" translate="yes" xml:space="preserve">
          <source>Update the remote-tracking branches:</source>
          <target state="translated">更新远程跟踪分支。</target>
        </trans-unit>
        <trans-unit id="6d5daf3e771e4022d14d6727e49c69b93e7e63af" translate="yes" xml:space="preserve">
          <source>Update the sparse-checkout file to include additional patterns. By default, these patterns are read from the command-line arguments, but they can be read from stdin using the &lt;code&gt;--stdin&lt;/code&gt; option. When &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled, the given patterns are interpreted as directory names as in the &lt;code&gt;set&lt;/code&gt; subcommand.</source>
          <target state="translated">更新稀疏签出文件以包括其他模式。默认情况下，这些模式是从命令行参数读取的，但是可以使用 &lt;code&gt;--stdin&lt;/code&gt; 选项从stdin读取它们。当 &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; 启用，给定的模式被解释为目录名作为 &lt;code&gt;set&lt;/code&gt; 子命令。</target>
        </trans-unit>
        <trans-unit id="f68dff1cbdca38d9a97763a1d9fd849e951b6a1b" translate="yes" xml:space="preserve">
          <source>Updates files in the working tree to match the version in the index or the specified tree. If no pathspec was given, &lt;code&gt;git checkout&lt;/code&gt; will also update &lt;code&gt;HEAD&lt;/code&gt; to set the specified branch as the current branch.</source>
          <target state="translated">更新工作树中的文件以匹配索引或指定树中的版本。如果没有给出pathspec， &lt;code&gt;git checkout&lt;/code&gt; 也会更新 &lt;code&gt;HEAD&lt;/code&gt; 以将指定的分支设置为当前分支。</target>
        </trans-unit>
        <trans-unit id="091bf3e8c6fb28b8688a9117ac018615896df561" translate="yes" xml:space="preserve">
          <source>Updates remote refs using local refs, while sending objects necessary to complete the given refs.</source>
          <target state="translated">使用本地参考文献更新远程参考文献,同时发送完成给定参考文献所需的对象。</target>
        </trans-unit>
        <trans-unit id="91ca9b60db53a2ebedea4c579e08371ec4025869" translate="yes" xml:space="preserve">
          <source>Updating A with the resulting merge commit will fast-forward and your push will be accepted.</source>
          <target state="translated">更新A并进行合并提交,会快速推进,你的推送会被接受。</target>
        </trans-unit>
        <trans-unit id="b1b31935884de26d68d690781ac1ec814b3bc924" translate="yes" xml:space="preserve">
          <source>Updating a repository with git fetch</source>
          <target state="translated">用git fetch更新版本库。</target>
        </trans-unit>
        <trans-unit id="c2ed1ab77aee7c3aaed70bc448641d662955a12f" translate="yes" xml:space="preserve">
          <source>Updating existing tests that assume GIT_TRACE format messages.</source>
          <target state="translated">更新现有的测试,假设GIT_TRACE格式的消息。</target>
        </trans-unit>
        <trans-unit id="c5ded60beb1b0eb17cab63a8e09a8acd2261286e" translate="yes" xml:space="preserve">
          <source>Updating the index did something else too: it created a &lt;code&gt;.git/index&lt;/code&gt; file. This is the index that describes your current working tree, and something you should be very aware of. Again, you normally never worry about the index file itself, but you should be aware of the fact that you have not actually really &quot;checked in&quot; your files into Git so far, you&amp;rsquo;ve only &lt;strong&gt;told&lt;/strong&gt; Git about them.</source>
          <target state="translated">更新索引也做了其他事情：它创建了一个 &lt;code&gt;.git/index&lt;/code&gt; 文件。这是描述您当前工作树的索引，您应该非常了解它。同样，您通常不必担心索引文件本身，但是您应该意识到，到目前为止，您还没有真正将文件&amp;ldquo;检入&amp;rdquo;到Git中，您只是&lt;strong&gt;告诉了&lt;/strong&gt; Git。</target>
        </trans-unit>
        <trans-unit id="583381e5edf6e3ab467919c38286667f0916979d" translate="yes" xml:space="preserve">
          <source>Upon completion, &amp;lt;branch&amp;gt; will be the current branch.</source>
          <target state="translated">完成后，&amp;lt;branch&amp;gt;将是当前分支。</target>
        </trans-unit>
        <trans-unit id="c956664b8da61af6d0e1bf33a6e1ff75cbe45ad1" translate="yes" xml:space="preserve">
          <source>Upon seeing an invalid object name in the input, pretend as if the bad input was not given.</source>
          <target state="translated">当看到输入中出现无效的对象名称时,就装作没有输入不良的样子。</target>
        </trans-unit>
        <trans-unit id="d725441fc805b8226e9417fb2c8cf53ac8d791d5" translate="yes" xml:space="preserve">
          <source>Upstream branch to compare against. May be any valid commit, not just an existing branch name. Defaults to the configured upstream for the current branch.</source>
          <target state="translated">与之比较的上游分支,可以是任何有效的提交,而不仅仅是现有的分支名。可以是任何有效的提交,而不仅仅是现有的分支名。默认为当前分支的上游配置。</target>
        </trans-unit>
        <trans-unit id="f5808323e4ba717fc383cb75e63b6cf3a4e857e7" translate="yes" xml:space="preserve">
          <source>Upstream branch to search for equivalent commits. Defaults to the upstream branch of HEAD.</source>
          <target state="translated">搜索等价提交的上游分支。默认为 HEAD 的上游分支。</target>
        </trans-unit>
        <trans-unit id="309bc26d3c4c2649258f95c7069216bb2a7ac5f4" translate="yes" xml:space="preserve">
          <source>Upstream location from which commits are identified to submit to p4. By default, this is the most recent p4 commit reachable from &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">确定提交要提交给p4的上游位置。默认情况下，这是 &lt;code&gt;HEAD&lt;/code&gt; 可访问的最新p4提交。</target>
        </trans-unit>
        <trans-unit id="df28f1403e8348eae4829434034d1a95e5fe659d" translate="yes" xml:space="preserve">
          <source>Url translation</source>
          <target state="translated">网址翻译</target>
        </trans-unit>
        <trans-unit id="7ae770d8c2db91584c78e413662ced65719f53ca" translate="yes" xml:space="preserve">
          <source>Usage of this flag will probably be rare, since you can get rid of commits that start empty by just firing up an interactive rebase and removing the lines corresponding to the commits you don&amp;rsquo;t want. This flag exists as a convenient shortcut, such as for cases where external tools generate many empty commits and you want them all removed.</source>
          <target state="translated">使用此标志可能很少见，因为您可以通过启动交互式rebase并删除与不需要的提交相对应的行来摆脱以空开头的提交。该标志作为便捷的快捷方式存在，例如，在外部工具生成许多空提交且您希望将其全部删除的情况下。</target>
        </trans-unit>
        <trans-unit id="f51159e5f3b0adbeed98e188d040286280a5320b" translate="yes" xml:space="preserve">
          <source>Usage text</source>
          <target state="translated">使用文本</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="6039144c2dc6586b6f3f0cb7423bcc0b3de0d0c1" translate="yes" xml:space="preserve">
          <source>Use &quot;patience diff&quot; algorithm when generating patches.</source>
          <target state="translated">生成补丁时使用 &quot;耐心差异 &quot;算法。</target>
        </trans-unit>
        <trans-unit id="1712fa1f1e6f89a27b7d3117ed39073a3258971d" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;dir&amp;gt; to store the resulting files, instead of the current working directory.</source>
          <target state="translated">使用&amp;lt;dir&amp;gt;存储结果文件，而不是当前工作目录。</target>
        </trans-unit>
        <trans-unit id="89ed1ad2d65d4e1af42e685a9ee22c739e5d2c9b" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;message&amp;gt; instead of the branch names for the first line of the log message. For use with &lt;code&gt;--log&lt;/code&gt;.</source>
          <target state="translated">使用&amp;lt;message&amp;gt;代替日志消息第一行的分支名称。与 &lt;code&gt;--log&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="a8e6c324c4e7440184ef28eb2f6fc1fca5a4a325" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;regex&amp;gt; to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies &lt;code&gt;--word-diff&lt;/code&gt; unless it was already enabled.</source>
          <target state="translated">使用&amp;lt;regex&amp;gt;来确定单词是什么，而不是将非空白行视为一个单词。也意味着 &lt;code&gt;--word-diff&lt;/code&gt; ,除非已启用。</target>
        </trans-unit>
        <trans-unit id="f70b8a97f949594b729b07efce2ca59a63023925" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;!&lt;/code&gt; to not make the corresponding negated long option available.</source>
          <target state="translated">使用 &lt;code&gt;!&lt;/code&gt; 使相应的取反加长选项不可用。</target>
        </trans-unit>
        <trans-unit id="f7924a219e6794d45a36b15b2c44738227b795ff" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; to set the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; explicitly. e.g., &quot;git remote set-head origin master&quot; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 显式设置symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 。例如，&amp;ldquo; git remote set-head source origin master&amp;rdquo;会将symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; 设置为 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 。仅当 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 已经存在时，这才起作用；如果不是，则必须先获取它。</target>
        </trans-unit>
        <trans-unit id="e726751622c7eadb004a31b60b5fa1e9cc1fbf90" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; to set the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; explicitly. e.g., &lt;code&gt;git
remote set-head origin master&lt;/code&gt; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 显式设置symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 。例如， &lt;code&gt;git remote set-head origin master&lt;/code&gt; 将把symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; 设置为 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 。仅当 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 已经存在时，这才起作用；如果不是，则必须先获取它。</target>
        </trans-unit>
        <trans-unit id="d950943422ee3b93275d1e4b1e510463e5b432e0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; to contact a running cache daemon (or start a new cache daemon if one is not started). Defaults to &lt;code&gt;$XDG_CACHE_HOME/git/credential/socket&lt;/code&gt; unless &lt;code&gt;~/.git-credential-cache/&lt;/code&gt; exists in which case &lt;code&gt;~/.git-credential-cache/socket&lt;/code&gt; is used instead. If your home directory is on a network-mounted filesystem, you may need to change this to a local filesystem. You must specify an absolute path.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 与正在运行的缓存守护程序联系（如果尚未启动，请启动一个新的缓存守护程序）。默认为 &lt;code&gt;$XDG_CACHE_HOME/git/credential/socket&lt;/code&gt; ，除非 &lt;code&gt;~/.git-credential-cache/&lt;/code&gt; 存在在这种情况下 &lt;code&gt;~/.git-credential-cache/socket&lt;/code&gt; 来代替。如果主目录位于网络安装的文件系统上，则可能需要将其更改为本地文件系统。您必须指定绝对路径。</target>
        </trans-unit>
        <trans-unit id="faabe60607ec900b5e4ad4f074b4870d8f9c10c6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; to lookup and store credentials. The file will have its filesystem permissions set to prevent other users on the system from reading it, but will not be encrypted or otherwise protected. If not specified, credentials will be searched for from &lt;code&gt;~/.git-credentials&lt;/code&gt; and &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt;, and credentials will be written to &lt;code&gt;~/.git-credentials&lt;/code&gt; if it exists, or &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; if it exists and the former does not. See also &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 查找和存储凭据。该文件将设置其文件系统权限，以防止系统上的其他用户读取该文件，但不会被加密或受到其他保护。如果没有指定，凭据将搜索从 &lt;code&gt;~/.git-credentials&lt;/code&gt; 和 &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; 和证书将被写入到 &lt;code&gt;~/.git-credentials&lt;/code&gt; ，如果它存在，或 &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; （如果存在）而前者则没有。另请参阅&lt;a href=&quot;#FILES&quot;&gt;文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aadb92eae500ef695bbe6a445720ce25246dd04e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;*&lt;/code&gt; to mean that this option should not be listed in the usage generated for the &lt;code&gt;-h&lt;/code&gt; argument. It&amp;rsquo;s shown for &lt;code&gt;--help-all&lt;/code&gt; as documented in &lt;a href=&quot;gitcli&quot;&gt;gitcli[7]&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;*&lt;/code&gt; 表示此选项不应在为 &lt;code&gt;-h&lt;/code&gt; 参数生成的用法中列出。如&lt;a href=&quot;gitcli&quot;&gt;gitcli [7]&lt;/a&gt;所示，它显示为 &lt;code&gt;--help-all&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bbcee2a044e9c08185b38acb1e1c57ceea88054" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--no-guess&lt;/code&gt; to disable this.</source>
          <target state="translated">使用 &lt;code&gt;--no-guess&lt;/code&gt; 禁用此功能。</target>
        </trans-unit>
        <trans-unit id="6deefc2a8fa6667ca14a90dee15faf81b1f0546a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-o master&lt;/code&gt; for continuing an import that was initially done by the old cvs2git tool.</source>
          <target state="translated">使用 &lt;code&gt;-o master&lt;/code&gt; 继续执行最初由旧cvs2git工具完成的导入。</target>
        </trans-unit>
        <trans-unit id="a4527eec708654a210ce88433047c8e573fb91f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-r&lt;/code&gt; together with &lt;code&gt;-d&lt;/code&gt; to delete remote-tracking branches. Note, that it only makes sense to delete remote-tracking branches if they no longer exist in the remote repository or if &lt;code&gt;git fetch&lt;/code&gt; was configured not to fetch them again. See also the &lt;code&gt;prune&lt;/code&gt; subcommand of &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; for a way to clean up all obsolete remote-tracking branches.</source>
          <target state="translated">与 &lt;code&gt;-d&lt;/code&gt; 一起使用 &lt;code&gt;-r&lt;/code&gt; 可以删除远程跟踪分支。请注意，仅当远程跟踪分支不再存在于远程存储库中或 &lt;code&gt;git fetch&lt;/code&gt; 配置为不再再次获取它们时，才有意义。另请参见&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;的 &lt;code&gt;prune&lt;/code&gt; 子命令，以清除所有过时的远程跟踪分支。</target>
        </trans-unit>
        <trans-unit id="eb7d25cab29167524de808a8da669505756898ee" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;=&lt;/code&gt; if the option takes an argument.</source>
          <target state="translated">如果该选项接受参数，则使用 &lt;code&gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d247642d4c8609f74c2030daa3d24c7c82d2e46d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;?&lt;/code&gt; to mean that the option takes an optional argument. You probably want to use the &lt;code&gt;--stuck-long&lt;/code&gt; mode to be able to unambiguously parse the optional argument.</source>
          <target state="translated">使用 &lt;code&gt;?&lt;/code&gt; 表示该选项采用可选参数。您可能希望使用 &lt;code&gt;--stuck-long&lt;/code&gt; 模式才能明确解析可选参数。</target>
        </trans-unit>
        <trans-unit id="7929eb6fd77d1ea35c9c481fc89518eafcc1cd45" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git bisect&lt;/code&gt; to get a short usage description, and &lt;code&gt;git bisect
help&lt;/code&gt; or &lt;code&gt;git bisect -h&lt;/code&gt; to get a long usage description.</source>
          <target state="translated">使用 &lt;code&gt;git bisect&lt;/code&gt; 可获得简短的用法说明，使用 &lt;code&gt;git bisect help&lt;/code&gt; 或 &lt;code&gt;git bisect -h&lt;/code&gt; 可获得较长的用法说明。</target>
        </trans-unit>
        <trans-unit id="599c65a25784af23c9351ba6f4874c534a65a263" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git cherry origin&lt;/code&gt; to see which ones of your patches were accepted, and/or use &lt;code&gt;git rebase origin&lt;/code&gt; to port your unmerged changes forward to the updated upstream.</source>
          <target state="translated">使用 &lt;code&gt;git cherry origin&lt;/code&gt; 查看被接受的补丁程序，和/或使用 &lt;code&gt;git rebase origin&lt;/code&gt; 将未合并的更改转发到更新的上游。</target>
        </trans-unit>
        <trans-unit id="f1986201248cbf297f2fb86d6f520b30d057ce7d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; or &lt;code&gt;git remote update&lt;/code&gt; to stay up to date.</source>
          <target state="translated">使用 &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; 或 &lt;code&gt;git remote update&lt;/code&gt; 保持最新。</target>
        </trans-unit>
        <trans-unit id="252ef42d37b56d31d5e5dc2525ae974052dfca91" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git format-patch origin&lt;/code&gt; to prepare patches for e-mail submission to your upstream and send it out. Go back to step 2. and continue.</source>
          <target state="translated">使用 &lt;code&gt;git format-patch origin&lt;/code&gt; 来准备补丁，以将电子邮件提交到上游并发送出去。返回第2步，然后继续。</target>
        </trans-unit>
        <trans-unit id="cd30f3ed950161de3f8267d9a18953af3c02784f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git mergetool&lt;/code&gt; to run one of several merge utilities to resolve merge conflicts. It is typically run after &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;git mergetool&lt;/code&gt; 运行多个合并实用程序之一来解决合并冲突。它通常在 &lt;code&gt;git merge&lt;/code&gt; 之后运行。</target>
        </trans-unit>
        <trans-unit id="6b298c06fc405635f29d06efdf0f42592d8075f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rev-parse&lt;/code&gt; in option parsing mode (see PARSEOPT section below).</source>
          <target state="translated">在选项解析模式下使用 &lt;code&gt;git rev-parse&lt;/code&gt; （请参阅下面的PARSEOPT部分）。</target>
        </trans-unit>
        <trans-unit id="7c9820d48befbd19730095f238fb8a15824823ad" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rev-parse&lt;/code&gt; in shell quoting mode (see SQ-QUOTE section below). In contrast to the &lt;code&gt;--sq&lt;/code&gt; option below, this mode does only quoting. Nothing else is done to command input.</source>
          <target state="translated">在shell引用模式下使用 &lt;code&gt;git rev-parse&lt;/code&gt; （请参阅下面的SQ-QUOTE部分）。与下面的 &lt;code&gt;--sq&lt;/code&gt; 选项相反，此模式仅引用。命令输入无其他操作。</target>
        </trans-unit>
        <trans-unit id="4c4d44083fa5e2a6971987cf935297be30994f4c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stash&lt;/code&gt; when you want to record the current state of the working directory and the index, but want to go back to a clean working directory. The command saves your local modifications away and reverts the working directory to match the &lt;code&gt;HEAD&lt;/code&gt; commit.</source>
          <target state="translated">当您想记录工作目录和索引的当前状态，但又想回到干净的工作目录时，请使用 &lt;code&gt;git stash&lt;/code&gt; 。该命令将您的本地修改保存下来，并还原工作目录以匹配 &lt;code&gt;HEAD&lt;/code&gt; 提交。</target>
        </trans-unit>
        <trans-unit id="41c11f9d8154a7d9c49ff48bc15e09cdeb4a9a5c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stripspace --strip-comments&lt;/code&gt; to obtain:</source>
          <target state="translated">使用 &lt;code&gt;git stripspace --strip-comments&lt;/code&gt; 获得：</target>
        </trans-unit>
        <trans-unit id="141b00818c5025cc15ff515d81283fc5705a8a4e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stripspace&lt;/code&gt; with no arguments to obtain:</source>
          <target state="translated">使用 &lt;code&gt;git stripspace&lt;/code&gt; 带参数的git stripspace获取：</target>
        </trans-unit>
        <trans-unit id="ae0479a18945009a7ebac30bdfceaa72c61a99c4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ident&lt;/code&gt; in the &lt;code&gt;From:&lt;/code&gt; header of each commit email. If the author ident of the commit is not textually identical to the provided &lt;code&gt;ident&lt;/code&gt;, place a &lt;code&gt;From:&lt;/code&gt; header in the body of the message with the original author. If no &lt;code&gt;ident&lt;/code&gt; is given, use the committer ident.</source>
          <target state="translated">在每个提交电子邮件的&amp;ldquo; &lt;code&gt;From:&lt;/code&gt; 标题中使用 &lt;code&gt;ident&lt;/code&gt; 。如果提交的作者身份与提供的 &lt;code&gt;ident&lt;/code&gt; 在文本上不相同，请在原始邮件的正文中放置一个 &lt;code&gt;From:&lt;/code&gt; 标头。如果没有给出 &lt;code&gt;ident&lt;/code&gt; ，则使用提交者标识。</target>
        </trans-unit>
        <trans-unit id="8fb68f530aa46816206d7ea34908da4d297edef3" translate="yes" xml:space="preserve">
          <source>Use IPv4 addresses only, ignoring IPv6 addresses.</source>
          <target state="translated">只使用IPv4地址,忽略IPv6地址。</target>
        </trans-unit>
        <trans-unit id="d89ac89f76f16a68a863b0d9f578ffd1a558d6b0" translate="yes" xml:space="preserve">
          <source>Use IPv6 addresses only, ignoring IPv4 addresses.</source>
          <target state="translated">只使用IPv6地址,忽略IPv4地址。</target>
        </trans-unit>
        <trans-unit id="23206ddfb8d01b68973d7bd9cccf799f208e3657" translate="yes" xml:space="preserve">
          <source>Use Message &amp;rarr; Insert file&amp;hellip;​ and insert the patch.</source>
          <target state="translated">使用消息&amp;rarr;插入文件...并插入补丁。</target>
        </trans-unit>
        <trans-unit id="1b7e380bb9ef947a64359e01f17ce54cd3bdece1" translate="yes" xml:space="preserve">
          <source>Use One Mark Per Commit</source>
          <target state="translated">每次承诺使用一个标记</target>
        </trans-unit>
        <trans-unit id="c24268aab2b43d4e294643c8fbcbd60d377e139b" translate="yes" xml:space="preserve">
          <source>Use POSIX extended/basic regexp for patterns. Default is to use basic regexp.</source>
          <target state="translated">对模式使用 POSIX 扩展/基本 regexp。默认是使用基本的regexp。</target>
        </trans-unit>
        <trans-unit id="36e96e4a2fd002679f3b794b4968539810c5c2eb" translate="yes" xml:space="preserve">
          <source>Use Perl-compatible regular expressions for patterns.</source>
          <target state="translated">对模式使用Perl兼容的正则表达式。</target>
        </trans-unit>
        <trans-unit id="fd46ce4ee0de88bb1a4ebb0e0c6375d24c2fb065" translate="yes" xml:space="preserve">
          <source>Use SO_REUSEADDR when binding the listening socket. This allows the server to restart without waiting for old connections to time out.</source>
          <target state="translated">在绑定监听套接字时,使用SO_REUSEADDR。这允许服务器重新启动,而不需要等待旧的连接超时。</target>
        </trans-unit>
        <trans-unit id="f351ffbdfc957393f82f6653e37778e19987b350" translate="yes" xml:space="preserve">
          <source>Use Tag Fixup Branches</source>
          <target state="translated">使用标签修复分支</target>
        </trans-unit>
        <trans-unit id="41019858ddf6bd113a2b54361af9c75b6d741367" translate="yes" xml:space="preserve">
          <source>Use \0 as the delimiter for pathnames in the output, and print them verbatim. Without this option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable core.quotePath (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">使用\ 0作为输出中路径名的分隔符，并逐字打印它们。如果没有此选项，则引用带有&amp;ldquo;不寻常&amp;rdquo;字符的路径名，如配置变量core.quotePath所述（参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="67640e675158aa473b8a69cc0cdb46fb8ed7283f" translate="yes" xml:space="preserve">
          <source>Use a &quot;stable&quot; sum of hashes as the patch ID. With this option:</source>
          <target state="translated">使用一个 &quot;稳定的 &quot;哈希值之和作为补丁ID。有了这个选项。</target>
        </trans-unit>
        <trans-unit id="0ec5feaf620cc0230519584645c952a1ae99d83c" translate="yes" xml:space="preserve">
          <source>Use a client spec to find the list of interesting files in p4. See the &quot;CLIENT SPEC&quot; section below.</source>
          <target state="translated">使用客户端规范来查找p4中有趣的文件列表。参见下面的 &quot;CLIENT SPEC &quot;部分。</target>
        </trans-unit>
        <trans-unit id="cf410607b4d646fae6b37dffcb3f37fcc481f52b" translate="yes" xml:space="preserve">
          <source>Use a mergetool. &lt;code&gt;git mergetool&lt;/code&gt; to launch a graphical mergetool which will work you through the merge.</source>
          <target state="translated">使用mergetool。 &lt;code&gt;git mergetool&lt;/code&gt; 启动图形化合并工具，它将通过合并工作。</target>
        </trans-unit>
        <trans-unit id="e7589df3d820308df2c8a838829de10cfbcf2077" translate="yes" xml:space="preserve">
          <source>Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde &lt;code&gt;~&lt;/code&gt; on a line of its own.</source>
          <target state="translated">使用专用于脚本的基于行的特殊格式。添加/删除/未更改的运行以通常的统一diff格式打印，从行首的 &lt;code&gt;+&lt;/code&gt; / &lt;code&gt;-&lt;/code&gt; /``字符开始，一直扩展到行尾。输入中的换行符由自己的一行上的波浪号 &lt;code&gt;~&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="77b024aefcbc37a1627539595d18a928f0842816" translate="yes" xml:space="preserve">
          <source>Use a tarball as a starting point for a new repository.</source>
          <target state="translated">使用一个 tar 包作为新版本库的起点。</target>
        </trans-unit>
        <trans-unit id="afac3b09febbe243aa11caf12f594c7284e7bf23" translate="yes" xml:space="preserve">
          <source>Use an &quot;unstable&quot; hash as the patch ID. With this option, the result produced is compatible with the patch-id value produced by git 1.9 and older. Users with pre-existing databases storing patch-ids produced by git 1.9 and older (who do not deal with reordered patches) may want to use this option.</source>
          <target state="translated">使用 &quot;不稳定 &quot;的哈希值作为补丁 ID。使用这个选项,产生的结果会与 git 1.9 及更早版本的补丁 ID 值兼容。如果用户的数据库中已经存储了 git 1.9 或更早版本的补丁 ID(不处理重新排序的补丁),可能会希望使用这个选项。</target>
        </trans-unit>
        <trans-unit id="ef4088fc09156b38070cb26da8281dc7bfd8c504" translate="yes" xml:space="preserve">
          <source>Use an atomic transaction for updating the refs. If any of the refs fails to update then the entire push will fail without changing any refs.</source>
          <target state="translated">使用原子事务来更新refs。如果任何一个refs未能更新,那么整个推送将失败,而不会改变任何refs。</target>
        </trans-unit>
        <trans-unit id="049c3e05f1b188c69413c7549059c67376f76ed1" translate="yes" xml:space="preserve">
          <source>Use an atomic transaction on the remote side if available. Either all refs are updated, or on error, no refs are updated. If the server does not support atomic pushes the push will fail.</source>
          <target state="translated">如果有的话,在远程端使用原子事务。要么更新所有refs,要么出错时不更新refs。如果服务器不支持原子推送,推送将失败。</target>
        </trans-unit>
        <trans-unit id="402b0ecf5212c8d413a7923b4b251cf4b803a260" translate="yes" xml:space="preserve">
          <source>Use applying strategies to rebase (calling &lt;code&gt;git-am&lt;/code&gt; internally). This option may become a no-op in the future once the merge backend handles everything the apply one does.</source>
          <target state="translated">使用应用策略进行基准调整（内部调用 &lt;code&gt;git-am&lt;/code&gt; ）。一旦合并后端处理了应用程序所做的所有操作，此选项将来可能就不再适用。</target>
        </trans-unit>
        <trans-unit id="e55fb404106de44576d9bc731a7fb4baf9a6337c" translate="yes" xml:space="preserve">
          <source>Use binary search to find the commit that introduced a bug</source>
          <target state="translated">使用二进制搜索来查找引入bug的提交。</target>
        </trans-unit>
        <trans-unit id="78ee9b127501691d305b39cc3fc13fc74a1d22a1" translate="yes" xml:space="preserve">
          <source>Use customized color for &lt;code&gt;git add --interactive&lt;/code&gt; and &lt;code&gt;git clean --interactive&lt;/code&gt; output. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; may be &lt;code&gt;prompt&lt;/code&gt;, &lt;code&gt;header&lt;/code&gt;, &lt;code&gt;help&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;, for four distinct types of normal output from interactive commands.</source>
          <target state="translated">对 &lt;code&gt;git add --interactive&lt;/code&gt; 和 &lt;code&gt;git clean --interactive&lt;/code&gt; 输出使用自定义颜色。对于来自交互命令的四种不同类型的常规输出， &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 可以是 &lt;code&gt;prompt&lt;/code&gt; ， &lt;code&gt;header&lt;/code&gt; ， &lt;code&gt;help&lt;/code&gt; 或 &lt;code&gt;error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf3aeb7f00c3d69ade01b5cc321078d4f50948ae" translate="yes" xml:space="preserve">
          <source>Use customized color for &lt;code&gt;git log --decorate&lt;/code&gt; output. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;branch&lt;/code&gt;, &lt;code&gt;remoteBranch&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;, &lt;code&gt;stash&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt; for local branches, remote-tracking branches, tags, stash and HEAD, respectively and &lt;code&gt;grafted&lt;/code&gt; for grafted commits.</source>
          <target state="translated">对 &lt;code&gt;git log --decorate&lt;/code&gt; 使用自定义颜色- 装饰输出。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 是本地分支，远程跟踪分支，tag，stash和HEAD 的 &lt;code&gt;branch&lt;/code&gt; ， &lt;code&gt;remoteBranch&lt;/code&gt; ， &lt;code&gt;tag&lt;/code&gt; ， &lt;code&gt;stash&lt;/code&gt; 或 &lt;code&gt;HEAD&lt;/code&gt; 之一，分别为嫁接的提交而被 &lt;code&gt;grafted&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29ecef38edab0e1998d46583be9558cf2a562eff" translate="yes" xml:space="preserve">
          <source>Use customized color for branch coloration. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;current&lt;/code&gt; (the current branch), &lt;code&gt;local&lt;/code&gt; (a local branch), &lt;code&gt;remote&lt;/code&gt; (a remote-tracking branch in refs/remotes/), &lt;code&gt;upstream&lt;/code&gt; (upstream tracking branch), &lt;code&gt;plain&lt;/code&gt; (other refs).</source>
          <target state="translated">使用自定义颜色进行分支着色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 是 &lt;code&gt;current&lt;/code&gt; （当前分支）， &lt;code&gt;local&lt;/code&gt; （本地分支）， &lt;code&gt;remote&lt;/code&gt; （refs / remotes /中的远程跟踪分支）， &lt;code&gt;upstream&lt;/code&gt; （上游跟踪分支）， &lt;code&gt;plain&lt;/code&gt; （其他ref）之一。</target>
        </trans-unit>
        <trans-unit id="fcdeebdb47ef8466da45d806c0dccf091f4447a0" translate="yes" xml:space="preserve">
          <source>Use customized color for diff colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; specifies which part of the patch to use the specified color, and is one of &lt;code&gt;context&lt;/code&gt; (context text - &lt;code&gt;plain&lt;/code&gt; is a historical synonym), &lt;code&gt;meta&lt;/code&gt; (metainformation), &lt;code&gt;frag&lt;/code&gt; (hunk header), &lt;code&gt;func&lt;/code&gt; (function in hunk header), &lt;code&gt;old&lt;/code&gt; (removed lines), &lt;code&gt;new&lt;/code&gt; (added lines), &lt;code&gt;commit&lt;/code&gt; (commit headers), &lt;code&gt;whitespace&lt;/code&gt; (highlighting whitespace errors), &lt;code&gt;oldMoved&lt;/code&gt; (deleted lines), &lt;code&gt;newMoved&lt;/code&gt; (added lines), &lt;code&gt;oldMovedDimmed&lt;/code&gt;, &lt;code&gt;oldMovedAlternative&lt;/code&gt;, &lt;code&gt;oldMovedAlternativeDimmed&lt;/code&gt;, &lt;code&gt;newMovedDimmed&lt;/code&gt;, &lt;code&gt;newMovedAlternative&lt;/code&gt;&lt;code&gt;newMovedAlternativeDimmed&lt;/code&gt; (See the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; setting of &lt;code&gt;--color-moved&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; for details), &lt;code&gt;contextDimmed&lt;/code&gt;, &lt;code&gt;oldDimmed&lt;/code&gt;, &lt;code&gt;newDimmed&lt;/code&gt;, &lt;code&gt;contextBold&lt;/code&gt;, &lt;code&gt;oldBold&lt;/code&gt;, and &lt;code&gt;newBold&lt;/code&gt; (see &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt; for details).</source>
          <target state="translated">使用自定义颜色进行diff着色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 指定补丁的哪一部分使用指定的颜色，并且是 &lt;code&gt;context&lt;/code&gt; （上下文文本- &lt;code&gt;plain&lt;/code&gt; 是历史同义词）， &lt;code&gt;meta&lt;/code&gt; （生成形式）， &lt;code&gt;frag&lt;/code&gt; （大块头）， &lt;code&gt;func&lt;/code&gt; （大块头中的函数）， &lt;code&gt;old&lt;/code&gt; （删除的行）， &lt;code&gt;new&lt;/code&gt; （添加的行）， &lt;code&gt;commit&lt;/code&gt; （提交标头）， &lt;code&gt;whitespace&lt;/code&gt; （突出显示空白错误）， &lt;code&gt;oldMoved&lt;/code&gt; （删除的行）， &lt;code&gt;newMoved&lt;/code&gt; （添加的行）， &lt;code&gt;oldMovedDimmed&lt;/code&gt; ， &lt;code&gt;oldMovedAlternative&lt;/code&gt; ， &lt;code&gt;oldMovedAlternativeDimmed&lt;/code&gt; ， &lt;code&gt;newMovedDimmed&lt;/code&gt; ， &lt;code&gt;newMovedAlternative&lt;/code&gt; &lt;code&gt;newMovedAlternativeDimmed&lt;/code&gt; （见 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 的设定 &lt;code&gt;--color-moved&lt;/code&gt; 在&lt;a href=&quot;git-diff&quot;&gt;GIT-DIFF [1]&lt;/a&gt;的详细信息）， &lt;code&gt;contextDimmed&lt;/code&gt; ， &lt;code&gt;oldDimmed&lt;/code&gt; ， &lt;code&gt;newDimmed&lt;/code&gt; ， &lt;code&gt;contextBold&lt;/code&gt; ， &lt;code&gt;oldBold&lt;/code&gt; ，和 &lt;code&gt;newBold&lt;/code&gt; （见&lt;a href=&quot;git-range-diff&quot;&gt;GIT-范围-DIFF [ 1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="799532fe06b09693cab5782f0c7b74d1305d2cb1" translate="yes" xml:space="preserve">
          <source>Use customized color for each remote keyword. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; may be &lt;code&gt;hint&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;success&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; which match the corresponding keyword.</source>
          <target state="translated">为每个远程关键字使用自定义颜色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 可以是 &lt;code&gt;hint&lt;/code&gt; ， &lt;code&gt;warning&lt;/code&gt; ， &lt;code&gt;success&lt;/code&gt; 或 &lt;code&gt;error&lt;/code&gt; ，它们与相应的关键字匹配。</target>
        </trans-unit>
        <trans-unit id="e8363e3bb3b19269f1bec63465f050d08c7400a8" translate="yes" xml:space="preserve">
          <source>Use customized color for grep colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; specifies which part of the line to use the specified color, and is one of</source>
          <target state="translated">使用自定义颜色进行grep着色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 指定使用指定颜色的行的哪一部分，并且是以下之一</target>
        </trans-unit>
        <trans-unit id="3d940f7a54cc13b6b8a420b163ce2b7e4ccedf38" translate="yes" xml:space="preserve">
          <source>Use customized color for hints.</source>
          <target state="translated">使用自定义颜色进行提示。</target>
        </trans-unit>
        <trans-unit id="a7bc0186c1d40a59aee910eedb6524484cbce3a0" translate="yes" xml:space="preserve">
          <source>Use customized color for push errors.</source>
          <target state="translated">使用自定义颜色进行推送错误。</target>
        </trans-unit>
        <trans-unit id="efd1e4b094e6a540e69b42772ae161651f4648a2" translate="yes" xml:space="preserve">
          <source>Use customized color for status colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;header&lt;/code&gt; (the header text of the status message), &lt;code&gt;added&lt;/code&gt; or &lt;code&gt;updated&lt;/code&gt; (files which are added but not committed), &lt;code&gt;changed&lt;/code&gt; (files which are changed but not added in the index), &lt;code&gt;untracked&lt;/code&gt; (files which are not tracked by Git), &lt;code&gt;branch&lt;/code&gt; (the current branch), &lt;code&gt;nobranch&lt;/code&gt; (the color the &lt;code&gt;no branch&lt;/code&gt; warning is shown in, defaulting to red), &lt;code&gt;localBranch&lt;/code&gt; or &lt;code&gt;remoteBranch&lt;/code&gt; (the local and remote branch names, respectively, when branch and tracking information is displayed in the status short-format), or &lt;code&gt;unmerged&lt;/code&gt; (files which have unmerged changes).</source>
          <target state="translated">使用自定义颜色进行状态着色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 是 &lt;code&gt;header&lt;/code&gt; （状态消息的标题文本），已 &lt;code&gt;added&lt;/code&gt; 或 &lt;code&gt;updated&lt;/code&gt; （已添加但未提交的文件），已 &lt;code&gt;changed&lt;/code&gt; （已更改但未添加到索引中的文件）， &lt;code&gt;untracked&lt;/code&gt; （未添加的文件）之一在以下位置显示分支和跟踪信息时，由Git跟踪）， &lt;code&gt;branch&lt;/code&gt; （当前分支）， &lt;code&gt;nobranch&lt;/code&gt; （显示 &lt;code&gt;no branch&lt;/code&gt; 警告的颜色，默认为红色）， &lt;code&gt;localBranch&lt;/code&gt; 或 &lt;code&gt;remoteBranch&lt;/code&gt; （分别为本地和远程分支名称）。状态短格式），或 &lt;code&gt;unmerged&lt;/code&gt; （具有未合并更改的文件）。</target>
        </trans-unit>
        <trans-unit id="42006ecfd08deb9b3ff0a3f1d7240d8f715710f3" translate="yes" xml:space="preserve">
          <source>Use customized color when a push was rejected.</source>
          <target state="translated">推送被拒绝时,使用自定义颜色。</target>
        </trans-unit>
        <trans-unit id="7714f2243f3ecb7a0c915a75f0d9677bee5cfddf" translate="yes" xml:space="preserve">
          <source>Use fixed strings for patterns (don&amp;rsquo;t interpret pattern as a regex).</source>
          <target state="translated">使用固定的字符串作为模式（不要将模式解释为正则表达式）。</target>
        </trans-unit>
        <trans-unit id="be83392780575c9c0f338875e4ab41fca7ad0580" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of Git objects. We check &lt;code&gt;&amp;lt;dir&amp;gt;/packs/multi-pack-index&lt;/code&gt; for the current MIDX file, and &lt;code&gt;&amp;lt;dir&amp;gt;/packs&lt;/code&gt; for the pack-files to index.</source>
          <target state="translated">将给定目录用于Git对象的位置。我们检查当前MIDX文件的 &lt;code&gt;&amp;lt;dir&amp;gt;/packs/multi-pack-index&lt;/code&gt; ，并检查要索引的pack-file的 &lt;code&gt;&amp;lt;dir&amp;gt;/packs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58e0e6d68f2b1086e2f61cc3ccf9bb473fce2cb1" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of packfiles and commit-graph file. This parameter exists to specify the location of an alternate that only has the objects directory, not a full &lt;code&gt;.git&lt;/code&gt; directory. The commit-graph file is expected to be in the &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; directory and the packfiles are expected to be in &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt;.</source>
          <target state="translated">将给定目录用于packfiles和commit-graph文件的位置。存在此参数以指定仅具有对象目录而不是完整的 &lt;code&gt;.git&lt;/code&gt; 目录的替代项的位置。提交图文件应位于 &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; 目录中，而packfile文件应位于 &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="034b8d3eb2bf376cba5a544572cc51a019ffd1af" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of packfiles and commit-graph file. This parameter exists to specify the location of an alternate that only has the objects directory, not a full &lt;code&gt;.git&lt;/code&gt; directory. The commit-graph file is expected to be in the &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; directory and the packfiles are expected to be in &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt;. If the directory could not be made into an absolute path, or does not match any known object directory, &lt;code&gt;git commit-graph ...&lt;/code&gt; will exit with non-zero status.</source>
          <target state="translated">将给定目录用于packfiles和commit-graph文件的位置。存在此参数是为了指定仅具有对象目录而不是完整的 &lt;code&gt;.git&lt;/code&gt; 目录的替代项的位置。提交图文件应位于 &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; 目录中，而packfile文件应位于 &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt; 中。如果无法将目录放入绝对路径或与任何已知对象目录都不匹配，则 &lt;code&gt;git commit-graph ...&lt;/code&gt; 将以非零状态退出。</target>
        </trans-unit>
        <trans-unit id="9e22ac3ec044552fceb6f971a8409c3fc735d918" translate="yes" xml:space="preserve">
          <source>Use gmail as the smtp server</source>
          <target state="translated">使用gmail作为smtp服务器</target>
        </trans-unit>
        <trans-unit id="243e0ec42451f8d223cf0a086b6e0d020fe017bc" translate="yes" xml:space="preserve">
          <source>Use hash &lt;code&gt;#&lt;/code&gt; for comments that are either on their own line, or after the email address.</source>
          <target state="translated">使用井号 &lt;code&gt;#&lt;/code&gt; 可以单独显示一行，也可以在电子邮件地址之后添加注释。</target>
        </trans-unit>
        <trans-unit id="fe4290ca9cf2dcf165b3911c20fcc8115cf36b09" translate="yes" xml:space="preserve">
          <source>Use libcurl to communicate with the IMAP server, unless tunneling into it. Ignored if Git was built without the USE_CURL_FOR_IMAP_SEND option set.</source>
          <target state="translated">使用 libcurl 与 IMAP 服务器通信,除非是通过隧道进入。如果 Git 在构建时没有设置 USE_CURL_FOR_IMAP_SEND 选项,则忽略。</target>
        </trans-unit>
        <trans-unit id="b43e2a7c9e04ff83908291bc454ceb95c66f26d2" translate="yes" xml:space="preserve">
          <source>Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt;.</source>
          <target state="translated">使用mailmap文件将作者和提交者的姓名和电子邮件地址映射到规范的真实姓名和电子邮件地址。参见&lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="869311b9e64386ec94c4224dbda98ca212bcb863" translate="yes" xml:space="preserve">
          <source>Use merging strategies to rebase. When the recursive (default) merge strategy is used, this allows rebase to be aware of renames on the upstream side.</source>
          <target state="translated">使用合并策略来rebase。当使用递归(默认)合并策略时,可以让rebase意识到上游侧的重名。</target>
        </trans-unit>
        <trans-unit id="07cf71eed9a3b36f45bcc6fde8a3af9707bd0146" translate="yes" xml:space="preserve">
          <source>Use merging strategies to rebase. When the recursive (default) merge strategy is used, this allows rebase to be aware of renames on the upstream side. This is the default.</source>
          <target state="translated">使用合并策略来rebase。当使用递归(默认)合并策略时,这允许rebase知道上游侧的重名。这是默认的。</target>
        </trans-unit>
        <trans-unit id="504dd078aaf1ec972f6af826bbe142e1450759fa" translate="yes" xml:space="preserve">
          <source>Use of &quot;topic branches&quot; solves these problems. The name is pretty self explanatory, with a caveat that comes from the &quot;merge upwards&quot; rule above:</source>
          <target state="translated">使用 &quot;主题分支 &quot;可以解决这些问题。这个名字很自圆其说,有一个注意事项,来自于上面的 &quot;向上合并 &quot;规则。</target>
        </trans-unit>
        <trans-unit id="2997460999cadfc1fcc5d52315d53b3d5efcd07d" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;dcommit&lt;/code&gt; is preferred to &lt;code&gt;set-tree&lt;/code&gt; (below).</source>
          <target state="translated">首选使用 &lt;code&gt;dcommit&lt;/code&gt; 来 &lt;code&gt;set-tree&lt;/code&gt; （如下）。</target>
        </trans-unit>
        <trans-unit id="6b08c4843a60fcea417d6fa6b7562621b3124054" translate="yes" xml:space="preserve">
          <source>Use of this utility is encouraged in favor of directly accessing files under the &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">鼓励使用此实用程序，以便直接访问 &lt;code&gt;.git&lt;/code&gt; 目录下的文件。</target>
        </trans-unit>
        <trans-unit id="3a96544176d9c64bcdfe76616987380a83e4f896" translate="yes" xml:space="preserve">
          <source>Use permissions reported by umask(2). The default, when &lt;code&gt;--shared&lt;/code&gt; is not specified.</source>
          <target state="translated">使用umask（2）报告的权限。默认值 &lt;code&gt;--shared&lt;/code&gt; 未指定。</target>
        </trans-unit>
        <trans-unit id="7b2e5a64a2bb1a5fbe6304abee401e1d3f35a8f4" translate="yes" xml:space="preserve">
          <source>Use reflog to find a better common ancestor between &amp;lt;upstream&amp;gt; and &amp;lt;branch&amp;gt; when calculating which commits have been introduced by &amp;lt;branch&amp;gt;.</source>
          <target state="translated">在计算&amp;lt;branch&amp;gt;引入了哪些提交时，使用reflog在&amp;lt;upstream&amp;gt;和&amp;lt;branch&amp;gt;之间找到更好的共同祖先。</target>
        </trans-unit>
        <trans-unit id="b40e39ff3f77007104d997879dd735023a9dca06" translate="yes" xml:space="preserve">
          <source>Use revisions from revs-file instead of calling &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;.</source>
          <target state="translated">使用revs-file中的修订，而不是调用&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efb298546ca010c6e357a2c3cc79d1b86fb2f356" translate="yes" xml:space="preserve">
          <source>Use the &quot;sparse&quot; algorithm to determine which objects to include in the pack, when combined with the &quot;--revs&quot; option. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames.</source>
          <target state="translated">当与&quot;--revs &quot;选项结合使用时,使用 &quot;sparse &quot;算法来决定哪些对象要包含在包中。这个算法只走出现在引入新对象的路径中的树。这在计算发送一个小变化的包时可以有显著的性能优势。然而,如果包含的提交包含某些类型的直接重命名,那么额外的对象有可能被添加到包文件中。</target>
        </trans-unit>
        <trans-unit id="0755f10a2fd51824d1737b45b49a4642d66873f8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--in-place&lt;/code&gt; option to edit a message file in place:</source>
          <target state="translated">使用 &lt;code&gt;--in-place&lt;/code&gt; 选项可就地编辑消息文件：</target>
        </trans-unit>
        <trans-unit id="55e7e1126d3aa0a5c8bf2360dfcd495bb1107882" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute only if you cannot store a file in UTF-8 encoding and if you want Git to be able to process the content as text.</source>
          <target state="translated">仅当您不能以UTF-8编码存储文件并且希望Git能够将内容作为文本处理时，才使用 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="b5ec705c3f1e9d70bd95302efbf5732684172042" translate="yes" xml:space="preserve">
          <source>Use the branch detection algorithm to find new paths in p4. It is documented below in &quot;BRANCH DETECTION&quot;.</source>
          <target state="translated">在p4中使用分支检测算法来寻找新的路径。下面在 &quot;BRANCH DETECTION &quot;中进行了说明。</target>
        </trans-unit>
        <trans-unit id="33ac56041ae34da6b3682a94d8a665913a47636a" translate="yes" xml:space="preserve">
          <source>Use the credential (e.g., access the URL with the username and password from step (2)), and see if it&amp;rsquo;s accepted.</source>
          <target state="translated">使用凭据（例如，使用步骤（2）中的用户名和密码访问URL），然后查看它是否被接受。</target>
        </trans-unit>
        <trans-unit id="4cfefdd524d37cf0c1fedc168c903048fc636bbd" translate="yes" xml:space="preserve">
          <source>Use the customized color for the part of git-blame output that is repeated meta information per line (such as commit id, author name, date and timezone). Defaults to cyan.</source>
          <target state="translated">为 git-blame 输出中每行重复元信息(如提交 ID、作者名、日期和时区)的部分使用自定义颜色。默认为青色。</target>
        </trans-unit>
        <trans-unit id="a024bae6c0f6ae8fa68e77c95e0c4f95100aa970" translate="yes" xml:space="preserve">
          <source>Use the diff tool specified by &amp;lt;tool&amp;gt;. Valid values include emerge, kompare, meld, and vimdiff. Run &lt;code&gt;git difftool --tool-help&lt;/code&gt; for the list of valid &amp;lt;tool&amp;gt; settings.</source>
          <target state="translated">使用&amp;lt;tool&amp;gt;指定的差异工具。有效值包括emerge，kompare，meld和vimdiff。运行 &lt;code&gt;git difftool --tool-help&lt;/code&gt; 以获得有效的&amp;lt;tool&amp;gt;设置列表。</target>
        </trans-unit>
        <trans-unit id="161588bc8b76efbad18d428ccf6e2f5e459908d1" translate="yes" xml:space="preserve">
          <source>Use the fast patchset import strategy. This can be significantly faster for large trees, but cannot handle directory renames or permissions changes. The default strategy is slow and safe.</source>
          <target state="translated">使用快速补丁集导入策略。这对于大型树来说,速度会显著加快,但不能处理目录重命名或权限更改。默认策略是缓慢而安全的。</target>
        </trans-unit>
        <trans-unit id="89541b63bc820ad5c76ea37101a62452ee62e61c" translate="yes" xml:space="preserve">
          <source>Use the following attributes if your &lt;code&gt;*.ps1&lt;/code&gt; files are UTF-16 little endian encoded without BOM and you want Git to use Windows line endings in the working directory (use &lt;code&gt;UTF-16LE-BOM&lt;/code&gt; instead of &lt;code&gt;UTF-16LE&lt;/code&gt; if you want UTF-16 little endian with BOM). Please note, it is highly recommended to explicitly define the line endings with &lt;code&gt;eol&lt;/code&gt; if the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute is used to avoid ambiguity.</source>
          <target state="translated">如果您的 &lt;code&gt;*.ps1&lt;/code&gt; 文件使用UTF-16小尾数编码而不带BOM，并且您希望Git在工作目录中使用Windows行尾（请使用 &lt;code&gt;UTF-16LE-BOM&lt;/code&gt; 而不是 &lt;code&gt;UTF-16LE&lt;/code&gt; )，请使用以下属性BOM的小尾数）。请注意，如果使用 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性以避免歧义，强烈建议使用 &lt;code&gt;eol&lt;/code&gt; 明确定义行尾。</target>
        </trans-unit>
        <trans-unit id="e5c2f58b6a6ebc713504e60181f4f0dd37da2d6d" translate="yes" xml:space="preserve">
          <source>Use the given &amp;lt;msg&amp;gt; as the commit message. If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs.</source>
          <target state="translated">使用给定的&amp;lt;msg&amp;gt;作为提交消息。如果给出了多个 &lt;code&gt;-m&lt;/code&gt; 选项，则它们的值将串联为单独的段落。</target>
        </trans-unit>
        <trans-unit id="be3b9715415e0357d3d87d01aa8f812c871fb1e1" translate="yes" xml:space="preserve">
          <source>Use the given &lt;code&gt;msg&lt;/code&gt; as the commit message. This option disables the &lt;code&gt;--edit&lt;/code&gt; option.</source>
          <target state="translated">使用给定的 &lt;code&gt;msg&lt;/code&gt; 作为提交消息。此选项禁用 &lt;code&gt;--edit&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="43103d879018fa15a44cefa9b3baec705e25165c" translate="yes" xml:space="preserve">
          <source>Use the given config file instead of the one specified by GIT_CONFIG.</source>
          <target state="translated">使用给定的配置文件代替GIT_CONFIG指定的文件。</target>
        </trans-unit>
        <trans-unit id="1af0579593d71707be713f8eac06f59e9d72c0da" translate="yes" xml:space="preserve">
          <source>Use the given config variable as a multi-valued list storing absolute path names. Iterate on that list of paths to run the given arguments.</source>
          <target state="translated">使用给定的配置变量作为一个多值列表,存储绝对路径名。在该路径列表上迭代运行给定参数。</target>
        </trans-unit>
        <trans-unit id="6d07104b51b424f44cb0346a9ac8f4116b0f06d7" translate="yes" xml:space="preserve">
          <source>Use the given exclude pattern in addition to the standard ignore rules (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;).</source>
          <target state="translated">除了标准的忽略规则（请参阅&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;）之外，还使用给定的排除模式。</target>
        </trans-unit>
        <trans-unit id="9a12bbd112f0b48f03fdbbbb0b9c68268bedd960" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy. If there is no &lt;code&gt;-s&lt;/code&gt; option &lt;code&gt;git merge-recursive&lt;/code&gt; is used instead. This implies --merge.</source>
          <target state="translated">使用给定的合并策略。如果没有 &lt;code&gt;-s&lt;/code&gt; 选项，则使用 &lt;code&gt;git merge-recursive&lt;/code&gt; 。这意味着--merge。</target>
        </trans-unit>
        <trans-unit id="aad779cdebc63bc4b25eb19e46a7b214101b70ea" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy. Should only be used once. See the MERGE STRATEGIES section in &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details.</source>
          <target state="translated">使用给定的合并策略。只能使用一次。有关详细信息，请参见&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]中的&amp;ldquo;合并&lt;/a&gt;策略&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="0d697cccd6049781089822f14d706ae91b43a781" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no &lt;code&gt;-s&lt;/code&gt; option, a built-in list of strategies is used instead (&lt;code&gt;git merge-recursive&lt;/code&gt; when merging a single head, &lt;code&gt;git merge-octopus&lt;/code&gt; otherwise).</source>
          <target state="translated">使用给定的合并策略；可以多次提供，以按应尝试的顺序指定它们。如果没有 &lt;code&gt;-s&lt;/code&gt; 选项，则使用内置策略列表代替（ &lt;code&gt;git merge-recursive&lt;/code&gt; 单个头部时使用git merge-recursive，否则使用 &lt;code&gt;git merge-octopus&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e15a6801b533c61848133f0481a1499ec359e784" translate="yes" xml:space="preserve">
          <source>Use the given note message (instead of prompting). If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs. Lines starting with &lt;code&gt;#&lt;/code&gt; and empty lines other than a single line between paragraphs will be stripped out.</source>
          <target state="translated">使用给定的注释消息（而不是提示）。如果给出了多个 &lt;code&gt;-m&lt;/code&gt; 选项，则它们的值将串联为单独的段落。以 &lt;code&gt;#&lt;/code&gt; 开头的行和段落之间的空行（段落之间的单行除外）将被删除。</target>
        </trans-unit>
        <trans-unit id="2301e57be484e5bf3374c6061960726be52acd3f" translate="yes" xml:space="preserve">
          <source>Use the given tag message (instead of prompting). If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs. Implies &lt;code&gt;-a&lt;/code&gt; if none of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is given.</source>
          <target state="translated">使用给定的标记消息（而不是提示）。如果给出了多个 &lt;code&gt;-m&lt;/code&gt; 选项，则它们的值将串联为单独的段落。意味着 &lt;code&gt;-a&lt;/code&gt; 如果没有的 &lt;code&gt;-a&lt;/code&gt; ， &lt;code&gt;-s&lt;/code&gt; ，或 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 给出。</target>
        </trans-unit>
        <trans-unit id="52a6c166f490dbb0be0d25b65f46015f7e67e623" translate="yes" xml:space="preserve">
          <source>Use the interactive patch selection interface to chose which changes to commit. See &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; for details.</source>
          <target state="translated">使用交互式补丁选择界面选择要提交的更改。有关详细信息，请参见&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7db128e87ada4e1ec3f3340d8431acfc429f3677" translate="yes" xml:space="preserve">
          <source>Use the merge resolution program specified by &amp;lt;tool&amp;gt;. Valid values include emerge, gvimdiff, kdiff3, meld, vimdiff, and tortoisemerge. Run &lt;code&gt;git mergetool --tool-help&lt;/code&gt; for the list of valid &amp;lt;tool&amp;gt; settings.</source>
          <target state="translated">使用&amp;lt;tool&amp;gt;指定的合并解决程序。有效值包括emerge，gvimdiff，kdiff3，meld，vimdiff和tortoisemerge。运行 &lt;code&gt;git mergetool --tool-help&lt;/code&gt; 以获得有效的&amp;lt;tool&amp;gt;设置列表。</target>
        </trans-unit>
        <trans-unit id="dcec4916e7483efe626c7c3cca0d933ec3eb9b91" translate="yes" xml:space="preserve">
          <source>Use the multi-pack-index file to track multiple packfiles using a single index. See &lt;a href=&quot;git-multi-pack-index&quot;&gt;git-multi-pack-index[1]&lt;/a&gt; for more information. Defaults to true.</source>
          <target state="translated">使用multi-pack-index文件可使用单个索引跟踪多个packfile。有关更多信息，请参见&lt;a href=&quot;git-multi-pack-index&quot;&gt;git-multi-pack-index [1]&lt;/a&gt;。默认为true。</target>
        </trans-unit>
        <trans-unit id="047156e36b9d6e8b2155d32a029545b1b026f10e" translate="yes" xml:space="preserve">
          <source>Use the multi-pack-index file to track multiple packfiles using a single index. See &lt;a href=&quot;multi-pack-index&quot;&gt;the multi-pack-index design document&lt;/a&gt;.</source>
          <target state="translated">使用multi-pack-index文件可使用单个索引跟踪多个packfile。请参阅&lt;a href=&quot;multi-pack-index&quot;&gt;multi-pack-index设计文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f14443aa07cf034aa00129ee21b4f7df2be49255" translate="yes" xml:space="preserve">
          <source>Use the partial clone feature and request that the server sends a subset of reachable objects according to a given object filter. When using &lt;code&gt;--filter&lt;/code&gt;, the supplied &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; is used for the partial clone filter. For example, &lt;code&gt;--filter=blob:none&lt;/code&gt; will filter out all blobs (file contents) until needed by Git. Also, &lt;code&gt;--filter=blob:limit=&amp;lt;size&amp;gt;&lt;/code&gt; will filter out all blobs of size at least &lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;. For more details on filter specifications, see the &lt;code&gt;--filter&lt;/code&gt; option in &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;.</source>
          <target state="translated">使用部分克隆功能，并请求服务器根据给定的对象过滤器发送可访问对象的子集。使用 &lt;code&gt;--filter&lt;/code&gt; 时，提供的 &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; 用于部分克隆过滤器。例如，-- &lt;code&gt;--filter=blob:none&lt;/code&gt; 会过滤掉所有Blob（文件内容），直到Git需要为止。同样，-- &lt;code&gt;--filter=blob:limit=&amp;lt;size&amp;gt;&lt;/code&gt; 将过滤掉大小至少为 &lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt; 的所有斑点。有关过滤器规范的更多详细信息，请参见&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]中&lt;/a&gt;的 &lt;code&gt;--filter&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="6bac5b4ccbcc396e691c8ba8f2af89d4f60c9270" translate="yes" xml:space="preserve">
          <source>Use the same output mode as &lt;a href=&quot;git-annotate&quot;&gt;git-annotate[1]&lt;/a&gt; (Default: off).</source>
          <target state="translated">使用与&lt;a href=&quot;git-annotate&quot;&gt;git-annotate [1]&lt;/a&gt;相同的输出模式（默认值：关闭）。</target>
        </trans-unit>
        <trans-unit id="0ed67a2ecd3a9ee96ae4cd7dcb45f48a2cf84bf4" translate="yes" xml:space="preserve">
          <source>Use the selected commit message without launching an editor. For example, &lt;code&gt;git commit --amend --no-edit&lt;/code&gt; amends a commit without changing its commit message.</source>
          <target state="translated">使用选定的提交消息而不启动编辑器。例如， &lt;code&gt;git commit --amend --no-edit&lt;/code&gt; 修改提交而不更改其提交消息。</target>
        </trans-unit>
        <trans-unit id="8e65c034e7da87d64be153e02b39a8529bd16f67" translate="yes" xml:space="preserve">
          <source>Use the source ref that matches &lt;code&gt;master&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) to update the ref that matches &lt;code&gt;satellite/master&lt;/code&gt; (most probably &lt;code&gt;refs/remotes/satellite/master&lt;/code&gt;) in the &lt;code&gt;mothership&lt;/code&gt; repository; do the same for &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;satellite/dev&lt;/code&gt;.</source>
          <target state="translated">使用与 &lt;code&gt;master&lt;/code&gt; 匹配的源ref （例如 &lt;code&gt;refs/heads/master&lt;/code&gt; ）来更新与 &lt;code&gt;mothership&lt;/code&gt; 库中的 &lt;code&gt;satellite/master&lt;/code&gt; 匹配的ref （最有可能是 &lt;code&gt;refs/remotes/satellite/master&lt;/code&gt; ）；对 &lt;code&gt;dev&lt;/code&gt; 和 &lt;code&gt;satellite/dev&lt;/code&gt; 做同样的事情。</target>
        </trans-unit>
        <trans-unit id="82b93c6560af27195da14e70510e2b3d8651c3b7" translate="yes" xml:space="preserve">
          <source>Use the specified HTTP protocol version when communicating with a server. If you want to force the default. The available and default version depend on libcurl. Actually the possible values of this option are:</source>
          <target state="translated">与服务器通信时使用指定的HTTP协议版本。如果你想强制使用默认版本。可用和默认版本取决于libcurl。其实这个选项的可能值是</target>
        </trans-unit>
        <trans-unit id="85fede53ff0add46d3665dfda925d3c1db752a7f" translate="yes" xml:space="preserve">
          <source>Use the specified HTTP protocol version when communicating with a server. If you want to force the default. The available and default version depend on libcurl. Currently the possible values of this option are:</source>
          <target state="translated">与服务器通信时使用指定的HTTP协议版本。如果你想强制使用默认版本。可用和默认版本取决于libcurl。目前该选项的可能值为</target>
        </trans-unit>
        <trans-unit id="becfdaabcf538340d904ac918eb155dd5d16c802" translate="yes" xml:space="preserve">
          <source>Use the specified URL to connect to the destination Subversion repository. This is useful in cases where the source SVN repository is read-only. This option overrides configuration property &lt;code&gt;commiturl&lt;/code&gt;.</source>
          <target state="translated">使用指定的URL连接到目标Subversion存储库。在源SVN存储库为只读的情况下，这很有用。此选项将覆盖配置属性 &lt;code&gt;commiturl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47ea3d46f75adaf5916e50431ef8bbea6e57dfd6" translate="yes" xml:space="preserve">
          <source>Use the specified browser. It must be in the list of supported browsers.</source>
          <target state="translated">使用指定的浏览器。它必须在支持的浏览器列表中。</target>
        </trans-unit>
        <trans-unit id="2c9d0a1d0fa5a2da07f63db4c5b77e59ec9169b0" translate="yes" xml:space="preserve">
          <source>Use the specified name for the initial branch in the newly created repository. If not specified, fall back to the default name (currently &lt;code&gt;master&lt;/code&gt;, but this is subject to change in the future; the name can be customized via the &lt;code&gt;init.defaultBranch&lt;/code&gt; configuration variable).</source>
          <target state="translated">为新创建的存储库中的初始分支使用指定的名称。如果未指定，请使用默认名称（当前为 &lt;code&gt;master&lt;/code&gt; ，但以后可能会更改；可以通过 &lt;code&gt;init.defaultBranch&lt;/code&gt; 配置变量自定义名称）。</target>
        </trans-unit>
        <trans-unit id="eded6790141cbbb141d77bfcf5fc351397828538" translate="yes" xml:space="preserve">
          <source>Use the specified name for the initial branch in the newly created repository. If not specified, fall back to the default name: &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">为新创建的存储库中的初始分支使用指定的名称。如果未指定，请使用默认名称 &lt;code&gt;master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e057e9e47493412f91dea4102ac0984cb71bdeb" translate="yes" xml:space="preserve">
          <source>Use the value of the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable to decide what to notice as error.</source>
          <target state="translated">使用 &lt;code&gt;core.whitespace&lt;/code&gt; 配置变量的值来确定要注意的错误。</target>
        </trans-unit>
        <trans-unit id="810f8c03feb9550dd6740190f543dbb37624e241" translate="yes" xml:space="preserve">
          <source>Use this custom program instead of &quot;&lt;code&gt;gpg&lt;/code&gt;&quot; found on &lt;code&gt;$PATH&lt;/code&gt; when making or verifying a PGP signature. The program must support the same command-line interface as GPG, namely, to verify a detached signature, &quot;&lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt;&quot; is run, and the program is expected to signal a good signature by exiting with code 0, and to generate an ASCII-armored detached signature, the standard input of &quot;&lt;code&gt;gpg -bsau $key&lt;/code&gt;&quot; is fed with the contents to be signed, and the program is expected to send the result to its standard output.</source>
          <target state="translated">制作或验证PGP签名时，请使用此自定义程序，而不要在 &lt;code&gt;$PATH&lt;/code&gt; 上找到&amp;ldquo; &lt;code&gt;gpg&lt;/code&gt; &amp;rdquo; 。该程序必须支持与GPG相同的命令行界面，即，验证分离的签名，运行&amp;ldquo; &lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt; &amp;rdquo;，并且该程序应通过退出代码来发出良好的签名信号0，并生成一个ASCII装甲的分离签名，&amp;ldquo; &lt;code&gt;gpg -bsau $key&lt;/code&gt; &amp;rdquo; 的标准输入被馈送了要签名的内容，程序期望将结果发送到其标准输出。</target>
        </trans-unit>
        <trans-unit id="a644dabd3c4c5e288aecaab3da05ddb8c7da086c" translate="yes" xml:space="preserve">
          <source>Use this for compatibility with old-style branch names used by earlier versions of &lt;code&gt;git archimport&lt;/code&gt;. Old-style branch names were category--branch, whereas new-style branch names are archive,category--branch--version. In both cases, names given on the command-line will override the automatically-generated ones.</source>
          <target state="translated">使用它与 &lt;code&gt;git archimport&lt;/code&gt; 的早期版本使用的旧式分支名称兼容。旧样式的分支名称是类别-分支，而新样式的分支名称是archive，category-分支-版本。在这两种情况下，命令行上给定的名称都将覆盖自动生成的名称。</target>
        </trans-unit>
        <trans-unit id="ad85fb495e355ea9ee99bf9caef60d6a5acc4df9" translate="yes" xml:space="preserve">
          <source>Use this for compatibility with old-style branch names used by earlier versions of &lt;code&gt;git archimport&lt;/code&gt;. Old-style branch names were category{litdd}branch, whereas new-style branch names are archive,category{litdd}branch{litdd}version. In both cases, names given on the command-line will override the automatically-generated ones.</source>
          <target state="translated">使用它与 &lt;code&gt;git archimport&lt;/code&gt; 的早期版本使用的旧式分支名称兼容。旧样式的分支名称是类别{litdd}分支，而新样式的分支名称是存档，类别{litdd}分支{litdd}版本。在这两种情况下，命令行上给定的名称都将覆盖自动生成的名称。</target>
        </trans-unit>
        <trans-unit id="f09efb8456c99114df5272977533145bfda3715e" translate="yes" xml:space="preserve">
          <source>Use this option to integrate changes from the upstream subproject with your submodule&amp;rsquo;s current HEAD. Alternatively, you can run &lt;code&gt;git pull&lt;/code&gt; from the submodule, which is equivalent except for the remote branch name: &lt;code&gt;update --remote&lt;/code&gt; uses the default upstream repository and &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt;, while &lt;code&gt;git pull&lt;/code&gt; uses the submodule&amp;rsquo;s &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;. Prefer &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; if you want to distribute the default upstream branch with the superproject and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; if you want a more native feel while working in the submodule itself.</source>
          <target state="translated">使用此选项可以将上游子项目中的更改与子模块的当前HEAD集成在一起。或者，您可以从子模块运行 &lt;code&gt;git pull&lt;/code&gt; ，除了远程分支名称外，它是等效的： &lt;code&gt;update --remote&lt;/code&gt; 使用默认的上游存储库和 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; ，而 &lt;code&gt;git pull&lt;/code&gt; 使用子模块的 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 。合并。身高 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; ，如果你想与上层项目和分发默认的上游分支 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 如果你想要一个更原始的感觉辅助模块本身工作时。</target>
        </trans-unit>
        <trans-unit id="205f9bc458a5cacd665ee1af1eac8a989bc13811" translate="yes" xml:space="preserve">
          <source>Use this option to set the namespace where the original commits will be stored. The default value is &lt;code&gt;refs/original&lt;/code&gt;.</source>
          <target state="translated">使用此选项设置将存储原始提交的名称空间。默认值为 &lt;code&gt;refs/original&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="978a87da673ee3d6baf57006a070d2ceaf2e0a29" translate="yes" xml:space="preserve">
          <source>Use this option to set the path to the temporary directory used for rewriting. When applying a tree filter, the command needs to temporarily check out the tree to some directory, which may consume considerable space in case of large projects. By default it does this in the &lt;code&gt;.git-rewrite/&lt;/code&gt; directory but you can override that choice by this parameter.</source>
          <target state="translated">使用此选项可以将路径设置为用于重写的临时目录。应用树过滤器时，该命令需要临时将树检出到某个目录，如果大型项目，这可能会占用大量空间。默认情况下，它在 &lt;code&gt;.git-rewrite/&lt;/code&gt; 目录中执行此操作，但是您可以通过此参数覆盖该选择。</target>
        </trans-unit>
        <trans-unit id="7dad6966beac366ffc5d985e757265d090b93f5a" translate="yes" xml:space="preserve">
          <source>Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.</source>
          <target state="translated">使用此选项可以解除阶段,只从索引中删除路径。工作树文件,无论是否被修改,都将被保留。</target>
        </trans-unit>
        <trans-unit id="22e3468b42fc7b02294ecbf3cdd521f378eedf7b" translate="yes" xml:space="preserve">
          <source>Use this to customize the program used for the signing format you chose. (see &lt;code&gt;gpg.program&lt;/code&gt; and &lt;code&gt;gpg.format&lt;/code&gt;) &lt;code&gt;gpg.program&lt;/code&gt; can still be used as a legacy synonym for &lt;code&gt;gpg.openpgp.program&lt;/code&gt;. The default value for &lt;code&gt;gpg.x509.program&lt;/code&gt; is &quot;gpgsm&quot;.</source>
          <target state="translated">使用此功能可自定义用于所选签名格式的程序。 （请参阅 &lt;code&gt;gpg.program&lt;/code&gt; 和 &lt;code&gt;gpg.format&lt;/code&gt; ） &lt;code&gt;gpg.program&lt;/code&gt; 仍可以用作 &lt;code&gt;gpg.openpgp.program&lt;/code&gt; 的旧同义词。 &lt;code&gt;gpg.x509.program&lt;/code&gt; 的默认值为&amp;ldquo; gpgsm&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2c0ec0febb1ffdfb71fd1faf1bdd4ef5cebdb7eb" translate="yes" xml:space="preserve">
          <source>Use this to specify the path to &lt;code&gt;git-upload-pack&lt;/code&gt; on the remote side, if is not found on your $PATH. Installations of sshd ignores the user&amp;rsquo;s environment setup scripts for login shells (e.g. .bash_profile) and your privately installed git may not be found on the system default $PATH. Another workaround suggested is to set up your $PATH in &quot;.bashrc&quot;, but this flag is for people who do not want to pay the overhead for non-interactive shells by having a lean .bashrc file (they set most of the things up in .bash_profile).</source>
          <target state="translated">如果在您的$ PATH中找不到 &lt;code&gt;git-upload-pack&lt;/code&gt; 的路径，可使用它来指定该路径。 sshd的安装将忽略用户用于登录Shell的环境设置脚本（例如.bash_profile），并且在系统默认$ PATH上可能找不到您私人安装的git。建议的另一种解决方法是在&amp;ldquo; .bashrc&amp;rdquo;中设置$ PATH，但是此标志适用于那些不想通过使用lean .bashrc文件来支付非交互式shell开销的人（它们将大部分内容设置为在.bash_profile中）。</target>
        </trans-unit>
        <trans-unit id="1f3cdffd9311e81ebd0ee41b41de344f546bb6a2" translate="yes" xml:space="preserve">
          <source>Used DBI driver. You can specify any available driver for this here, but it might not work. cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Please regard this as an experimental feature. May not contain colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;</source>
          <target state="translated">使用过的DBI驱动程序。您可以在此处指定任何可用的驱动程序，但可能无法使用。 cvsserver已通过 &lt;code&gt;DBD::SQLite&lt;/code&gt; 测试，据报告可与 &lt;code&gt;DBD::Pg&lt;/code&gt; ，并报告&lt;strong&gt;不适&lt;/strong&gt;用于 &lt;code&gt;DBD::mysql&lt;/code&gt; 。请将此作为实验功能。不得包含冒号（ &lt;code&gt;:&lt;/code&gt; ）。默认值： &lt;code&gt;SQLite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e96c8aa1d6db1322edc422d5cc1ffbd12e71daed" translate="yes" xml:space="preserve">
          <source>Used Perl DBI driver. You can specify any available driver for this here, but it might not work. git-cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Experimental feature. May not contain double colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">使用过的Perl DBI驱动程序。您可以在此处指定任何可用的驱动程序，但可能无法使用。 git-cvsserver已使用 &lt;code&gt;DBD::SQLite&lt;/code&gt; 进行了测试，据报告可与 &lt;code&gt;DBD::Pg&lt;/code&gt; ，并报告&lt;strong&gt;不适&lt;/strong&gt;用于 &lt;code&gt;DBD::mysql&lt;/code&gt; 。实验功能。但不能包含双冒号（ &lt;code&gt;:&lt;/code&gt; ）。默认值： &lt;code&gt;SQLite&lt;/code&gt; 。参见&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3dcc5e110a8886980641614ba00244bbf70eb3c6" translate="yes" xml:space="preserve">
          <source>Used as %(if)&amp;hellip;​%(then)&amp;hellip;​%(end) or %(if)&amp;hellip;​%(then)&amp;hellip;​%(else)&amp;hellip;​%(end). If there is an atom with value or string literal after the %(if) then everything after the %(then) is printed, else if the %(else) atom is used, then everything after %(else) is printed. We ignore space when evaluating the string before %(then), this is useful when we use the %(HEAD) atom which prints either &quot;*&quot; or &quot; &quot; and we want to apply the &lt;code&gt;if&lt;/code&gt; condition only on the &lt;code&gt;HEAD&lt;/code&gt; ref. Append &quot;:equals=&amp;lt;string&amp;gt;&quot; or &quot;:notequals=&amp;lt;string&amp;gt;&quot; to compare the value between the %(if:&amp;hellip;​) and %(then) atoms with the given string.</source>
          <target state="translated">用作％（if）...％（then）...％（end）或％（if）...％（then）...％（else）...％（end）。如果在％（if）后面有一个带有值或字符串文字的原子，那么将打印％（then）之后的所有内容，否则，如果使用％（else）原子，则将打印％（else）之后的所有内容。我们在评估％（then）之前的字符串时会忽略空格，当我们使用％（HEAD）原子打印&amp;ldquo; *&amp;rdquo;或&amp;ldquo;&amp;rdquo;并且我们只想在 &lt;code&gt;HEAD&lt;/code&gt; ref 上应用 &lt;code&gt;if&lt;/code&gt; 条件时，这很有用。附加&amp;ldquo;：equals = &amp;lt;string&amp;gt;&amp;rdquo;或&amp;ldquo;：notequals = &amp;lt;string&amp;gt;&amp;rdquo;可以比较％（if：&amp;hellip;）和％（then）原子与给定字符串之间的值。</target>
        </trans-unit>
        <trans-unit id="88972a7007de9e429d28d6bad7487052b23f9b65" translate="yes" xml:space="preserve">
          <source>Used to check that a bundle file is valid and will apply cleanly to the current repository. This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository. &lt;code&gt;git bundle&lt;/code&gt; prints a list of missing commits, if any, and exits with a non-zero status.</source>
          <target state="translated">用于检查捆绑文件是否有效，并将其干净地应用于当前存储库。这包括检查包格式本身，以及检查必备提交是否存在以及是否在当前存储库中完全链接。 &lt;code&gt;git bundle&lt;/code&gt; 打印丢失的提交列表（如果有），并以非零状态退出。</target>
        </trans-unit>
        <trans-unit id="a81dfbb4b6756f63bb43c72d54c78dd02ef851d4" translate="yes" xml:space="preserve">
          <source>Used to create a bundle named &lt;code&gt;file&lt;/code&gt;. This requires the &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; arguments to define the bundle contents. &lt;code&gt;options&lt;/code&gt; contains the options specific to the &lt;code&gt;git bundle create&lt;/code&gt; subcommand.</source>
          <target state="translated">用于创建名为 &lt;code&gt;file&lt;/code&gt; 的捆绑包。这需要 &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; 参数来定义分发包内容。 &lt;code&gt;options&lt;/code&gt; 包含特定于 &lt;code&gt;git bundle create&lt;/code&gt; 子命令的选项。</target>
        </trans-unit>
        <trans-unit id="fe127bac2ab0b61ffb60c0284f3741224c9951e1" translate="yes" xml:space="preserve">
          <source>Used to enforce or disable certificate revocation checks in cURL when http.sslBackend is set to &quot;schannel&quot;. Defaults to &lt;code&gt;true&lt;/code&gt; if unset. Only necessary to disable this if Git consistently errors and the message is about checking the revocation status of a certificate. This option is ignored if cURL lacks support for setting the relevant SSL option at runtime.</source>
          <target state="translated">当http.sslBackend设置为&amp;ldquo; schannel&amp;rdquo;时，用于强制或禁用cURL中的证书吊销检查。如果未设置，则默认为 &lt;code&gt;true&lt;/code&gt; 。只有在Git持续出错并且消息是关于检查证书的吊销状态时，才需要禁用此功能。如果cURL不支持在运行时设置相关SSL选项，则忽略此选项。</target>
        </trans-unit>
        <trans-unit id="526891fe0801e3a16c20e50ecde492e75d4f6490" translate="yes" xml:space="preserve">
          <source>Used to set the maximum load that we will still respond to gitweb queries. If the server load exceeds this value then gitweb will return &quot;503 Service Unavailable&quot; error. The server load is taken to be 0 if gitweb cannot determine its value. Currently it works only on Linux, where it uses &lt;code&gt;/proc/loadavg&lt;/code&gt;; the load there is the number of active tasks on the system &amp;mdash; processes that are actually running &amp;mdash; averaged over the last minute.</source>
          <target state="translated">用于设置我们仍将响应gitweb查询的最大负载。如果服务器负载超过此值，则gitweb将返回&amp;ldquo; 503 Service Unavailable&amp;rdquo;错误。如果gitweb无法确定其值，则将服务器负载视为0。目前，它仅在使用 &lt;code&gt;/proc/loadavg&lt;/code&gt; 的 Linux上有效；负载是系统上当前活动任务的数量（实际上是正在运行的进程）在最后一分钟内的平均值。</target>
        </trans-unit>
        <trans-unit id="184dba4369820f49a823e624aa006f74d3fc96ef" translate="yes" xml:space="preserve">
          <source>Used with --remote to specify the path to the &lt;code&gt;git-upload-archive&lt;/code&gt; on the remote side.</source>
          <target state="translated">与--remote一起使用，以指定远程端 &lt;code&gt;git-upload-archive&lt;/code&gt; 的路径。</target>
        </trans-unit>
        <trans-unit id="a985abb59dca2d23760f5b7ff00e7d00f2d0f353" translate="yes" xml:space="preserve">
          <source>Used with &lt;code&gt;--range-diff&lt;/code&gt;, tweak the heuristic which matches up commits between the previous and current series of patches by adjusting the creation/deletion cost fudge factor. See &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt;) for details.</source>
          <target state="translated">与 &lt;code&gt;--range-diff&lt;/code&gt; 一起使用，可通过调整创建/删除成本软键系数来调整启发式算法，以匹配先前和当前系列补丁之间的提交。有关详细信息，请参见&lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9777df5e2d0f3ca27a559e53074b9f39896040e8" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;fetch&lt;/code&gt; command.</source>
          <target state="translated">与 &lt;code&gt;fetch&lt;/code&gt; 命令一起使用。</target>
        </trans-unit>
        <trans-unit id="ea99fa3d480e34606197cb808cc4a18c1d6b1306" translate="yes" xml:space="preserve">
          <source>User Manual</source>
          <target state="translated">用户手册</target>
        </trans-unit>
        <trans-unit id="3d338fa6790366b9708dc60a5019a8d98f73c4b3" translate="yes" xml:space="preserve">
          <source>User configuration and preferences are stored at:</source>
          <target state="translated">用户配置和偏好存储在:</target>
        </trans-unit>
        <trans-unit id="ba3e3bfcde6395de2671f768450f02d32f692aba" translate="yes" xml:space="preserve">
          <source>User name (e.g., &lt;code&gt;user&lt;/code&gt; in &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt;). If the config key has a user name it must match the user name in the URL exactly. If the config key does not have a user name, that config key will match a URL with any user name (including none), but at a lower precedence than a config key with a user name.</source>
          <target state="translated">用户名（例如， &lt;code&gt;user&lt;/code&gt; 在 &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt; ）。如果config键具有用户名，则它必须与URL中的用户名完全匹配。如果配置密钥没有用户名，则该配置密钥将匹配具有任何用户名（包括无用户名）的URL，但其优先级低于具有用户名的配置密钥。</target>
        </trans-unit>
        <trans-unit id="9eabd3862d3bc88b6d20553afdc4c28a880bd15a" translate="yes" xml:space="preserve">
          <source>User specified as an option to all p4 commands, with &lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4USER&lt;/code&gt; can be used instead.</source>
          <target state="translated">使用 &lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt; 将用户指定为所有p4命令的选项。可以改为使用环境变量 &lt;code&gt;P4USER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3129c28f60cb352aa378d9055c2dee4b71cd917d" translate="yes" xml:space="preserve">
          <source>User-specific configuration file. Also called &quot;global&quot; configuration file.</source>
          <target state="translated">用户专用的配置文件,也叫 &quot;全局 &quot;配置文件。也叫 &quot;全局 &quot;配置文件。</target>
        </trans-unit>
        <trans-unit id="53b3f2b51348a1a5a4076e004425d0d150df3f8e" translate="yes" xml:space="preserve">
          <source>User-specific credentials file.</source>
          <target state="translated">用户专用凭证文件。</target>
        </trans-unit>
        <trans-unit id="fbb3c5af6a1b800cb6bfa442ae5c6ae5ee1a4454" translate="yes" xml:space="preserve">
          <source>Username for SMTP-AUTH. Default is the value of &lt;code&gt;sendemail.smtpUser&lt;/code&gt;; if a username is not specified (with &lt;code&gt;--smtp-user&lt;/code&gt; or &lt;code&gt;sendemail.smtpUser&lt;/code&gt;), then authentication is not attempted.</source>
          <target state="translated">SMTP-AUTH的用户名。默认值为 &lt;code&gt;sendemail.smtpUser&lt;/code&gt; 的值；如果未指定用户名（使用 &lt;code&gt;--smtp-user&lt;/code&gt; 或 &lt;code&gt;sendemail.smtpUser&lt;/code&gt; ），则不尝试身份验证。</target>
        </trans-unit>
        <trans-unit id="74498c0e6117d06ee988164e48dd06849a2a00fa" translate="yes" xml:space="preserve">
          <source>Users may find some cases where scheduled maintenance tasks do not run as frequently as intended. Each &lt;code&gt;git maintenance run&lt;/code&gt; command takes a lock on the repository&amp;rsquo;s object database, and this prevents other concurrent &lt;code&gt;git maintenance run&lt;/code&gt; commands from running on the same repository. Without this safeguard, competing processes could leave the repository in an unpredictable state.</source>
          <target state="translated">在某些情况下，用户可能会发现计划的维护任务没有按预期的频率运行。每个 &lt;code&gt;git maintenance run&lt;/code&gt; 命令都会锁定存储库的对象数据库，这会阻止其他并发的 &lt;code&gt;git maintenance run&lt;/code&gt; 命令在同一存储库上运行。没有这种保护措施，相互竞争的流程可能会使存储库处于不可预测的状态。</target>
        </trans-unit>
        <trans-unit id="dd5ba62269befa999225c8d360ebd4fd64f50001" translate="yes" xml:space="preserve">
          <source>Users may select an automated merge strategy from among the following using either -s/--strategy option or configuring notes.mergeStrategy accordingly:</source>
          <target state="translated">用户可以通过使用-s/--strategy选项或相应配置notes.mergeStrategy,从以下几项中选择自动合并策略。</target>
        </trans-unit>
        <trans-unit id="312954bd3f459a8154fbfda7b5edb71c57c929c2" translate="yes" xml:space="preserve">
          <source>Users migrating from CVS may also want to read &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">从CVS迁移的用户可能还想阅读&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bdfc1b01541d0790675419ccbb86b2582c7e882c" translate="yes" xml:space="preserve">
          <source>Users often try to use the assume-unchanged and skip-worktree bits to tell Git to ignore changes to files that are tracked. This does not work as expected, since Git may still check working tree files against the index when performing certain operations. In general, Git does not provide a way to ignore changes to tracked files, so alternate solutions are recommended.</source>
          <target state="translated">用户经常尝试使用 assume-unchanged 和 skip-worktree 位来告诉 Git 忽略对被跟踪文件的修改。这并没有达到预期的效果,因为在执行某些操作时,Git 仍会根据索引检查工作树文件。一般来说,Git 并没有提供一种方法来忽略对被跟踪文件的修改,所以建议采用其他的解决方案。</target>
        </trans-unit>
        <trans-unit id="d2fd200f233551c846ddc52433b7473972ba45cd" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;assume unchanged&amp;rdquo; bit</source>
          <target state="translated">使用&amp;ldquo;假定不变&amp;rdquo;位</target>
        </trans-unit>
        <trans-unit id="db59534f65c86c428a7a540c110ff1130d39acfc" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git add -A&amp;rdquo;</source>
          <target state="translated">使用&amp;ldquo; git add -A&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="3f756864c1cac8254338a14f16b7888b4cd11774" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git commit -a&amp;rdquo;</source>
          <target state="translated">使用&amp;ldquo; git commit -a&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="1ad6e2bdca2ef33d6f60d1165c40af77488df73e" translate="yes" xml:space="preserve">
          <source>Using --cacheinfo or --info-only</source>
          <target state="translated">使用 --cacheinfo 或 --info-only</target>
        </trans-unit>
        <trans-unit id="63a49bc3316ec7fe7ab1c50a106ab3c187422a12" translate="yes" xml:space="preserve">
          <source>Using --index-info</source>
          <target state="translated">使用--index-info</target>
        </trans-unit>
        <trans-unit id="9465002aca9e596e405478c595d6ec82ecf19f4d" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules can only fetch new commits in already checked out submodules right now. When e.g. upstream added a new submodule in the just fetched commits of the superproject the submodule itself cannot be fetched, making it impossible to check out that submodule later without having to do a fetch again. This is expected to be fixed in a future Git version.</source>
          <target state="translated">使用--recurse-submodules只能获取现在已经检查出来的子模块中的新提交。当上游在刚刚取回的超级项目提交中添加了一个新的子模块时,子模块本身就不能被取回,这就使得以后在不重新取回子模块的情况下,无法再检查出该子模块。这个问题预计会在未来的Git版本中得到修复。</target>
        </trans-unit>
        <trans-unit id="9ba2b3bf5dd0ae3395bffc9a6bf30c85dfb19a1b" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules' HEAD to be detached at that commit.</source>
          <target state="translated">使用--recurse-submodules会根据超级项目中记录的提交,通过递归调用read-tree来更新所有活动子模块的内容,同时设置子模块的head在该提交时被分离。</target>
        </trans-unit>
        <trans-unit id="3b6c4766d3d128d670a5d5adf42fc526da676a66" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules will update the content of all initialized submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules HEAD to be detached at that commit.</source>
          <target state="translated">使用--recurse-submodules会根据超级项目中记录的提交,通过递归调用read-tree来更新所有初始化的子模块的内容,也会设置子模块HEAD在该提交时被分离。</target>
        </trans-unit>
        <trans-unit id="8315f077dd8f5ad49468aff013d2df68acafcb5e" translate="yes" xml:space="preserve">
          <source>Using --refresh</source>
          <target state="translated">使用--刷新</target>
        </trans-unit>
        <trans-unit id="0565ce691b52b5953c2fb97dfb806a2f764f48e2" translate="yes" xml:space="preserve">
          <source>Using --temp or --stage=all</source>
          <target state="translated">使用--temp或--stage=全部。</target>
        </trans-unit>
        <trans-unit id="509888a40362653e71adbbdc6d4e59bc0d3d4ce4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--index-filter&lt;/code&gt; with &lt;code&gt;git rm&lt;/code&gt; yields a significantly faster version. Like with using &lt;code&gt;rm filename&lt;/code&gt;, &lt;code&gt;git rm --cached filename&lt;/code&gt; will fail if the file is absent from the tree of a commit. If you want to &quot;completely forget&quot; a file, it does not matter when it entered history, so we also add &lt;code&gt;--ignore-unmatch&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;git rm&lt;/code&gt; 上使用 &lt;code&gt;--index-filter&lt;/code&gt; 会产生明显更快的版本。就像使用 &lt;code&gt;rm filename&lt;/code&gt; 一样，如果提交树中没有该文件，则 &lt;code&gt;git rm --cached filename&lt;/code&gt; 将失败。如果您想&amp;ldquo;完全忘记&amp;rdquo;文件，则在输入历史记录时不要紧，因此我们还要添加 &lt;code&gt;--ignore-unmatch&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="802dbfe4495f98c59f087035f936edebe365e8d7" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all active submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless &lt;code&gt;-f&lt;/code&gt; is used. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, submodules working trees will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="translated">使用 &lt;code&gt;--recurse-submodules&lt;/code&gt; 将根据超级项目中记录的提交更新所有活动子模块的内容。如果子模块中的本地修改将被覆盖，则除非使用 &lt;code&gt;-f&lt;/code&gt; ,否则检出将失败。如果不使用任何内容（或 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ），则不会更新子模块的工作树。就像&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]一样&lt;/a&gt;，这将分离子模块的 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf5da0d2a32c5b7048069200ef431cff7653b1d4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all active submodules according to the commit recorded in the superproject. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, submodules working trees will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodules.</source>
          <target state="translated">使用 &lt;code&gt;--recurse-submodules&lt;/code&gt; 将根据超级项目中记录的提交更新所有活动子模块的内容。如果不使用任何内容（或 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ），则不会更新子模块的工作树。就像&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]一样&lt;/a&gt;，这将分离子模块的 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47e7ecf39552b28db7a0c771cb5239db7d4a81af" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless &lt;code&gt;-f&lt;/code&gt; is used. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="translated">使用 &lt;code&gt;--recurse-submodules&lt;/code&gt; 将根据超级项目中记录的提交更新所有初始化子模块的内容。如果子模块中的本地修改将被覆盖，则除非使用 &lt;code&gt;-f&lt;/code&gt; ,否则检出将失败。如果不使用任何内容（或 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ），则不会更新子模块的工作树。就像&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]一样&lt;/a&gt;，这将分离子模块的 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87e05fa35b92ebd2beac592a4000f99e52c8fa99" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodules.</source>
          <target state="translated">使用 &lt;code&gt;--recurse-submodules&lt;/code&gt; 将根据超级项目中记录的提交更新所有初始化子模块的内容。如果不使用任何内容（或 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ），则不会更新子模块的工作树。就像&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]一样&lt;/a&gt;，这将分离子模块的 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="131907fc18369579f75831dbffd3a45262caaa68" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-a&lt;/code&gt; would conflate &amp;lt;remote&amp;gt; with any local branches you happen to have been prefixed with the same &amp;lt;remote&amp;gt; pattern.</source>
          <target state="translated">使用 &lt;code&gt;-a&lt;/code&gt; 会将&amp;lt;remote&amp;gt;与您恰好以相同的&amp;lt;remote&amp;gt;模式作为前缀的任何本地分支合并。</target>
        </trans-unit>
        <trans-unit id="bc196497d8f80228e3ec0969c92ba077224b9158" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;git checkout-index&lt;/em&gt; to &quot;export an entire tree&quot;</source>
          <target state="translated">使用&lt;em&gt;git checkout-index&lt;/em&gt;来&amp;ldquo;导出整个树&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="bb5a1594f36aa9f526f3a0391e9aecb18bcb1ed6" translate="yes" xml:space="preserve">
          <source>Using Gmail&amp;rsquo;s IMAP interface:</source>
          <target state="translated">使用Gmail的IMAP界面：</target>
        </trans-unit>
        <trans-unit id="f145740948f023493614f8cb28fc352a33b08d80" translate="yes" xml:space="preserve">
          <source>Using a limit</source>
          <target state="translated">使用极限</target>
        </trans-unit>
        <trans-unit id="0d18e7415acaf5bf1693b96116e4340271619597" translate="yes" xml:space="preserve">
          <source>Using another project while maintaining independent history. Submodules allow you to contain the working tree of another project within your own working tree while keeping the history of both projects separate. Also, since submodules are fixed to an arbitrary version, the other project can be independently developed without affecting the superproject, allowing the superproject project to fix itself to new versions only when desired.</source>
          <target state="translated">使用另一个项目,同时保持独立的历史。子模块允许你在自己的工作树中包含另一个项目的工作树,同时保持两个项目的历史独立。另外,由于子模块固定为任意版本,所以另一个项目可以在不影响超级项目的情况下独立开发,允许超级项目项目只在需要的时候将自己固定为新版本。</target>
        </trans-unit>
        <trans-unit id="03266ad998c58f3651e774794904a59499884e04" translate="yes" xml:space="preserve">
          <source>Using complex scripts</source>
          <target state="translated">使用复杂的脚本</target>
        </trans-unit>
        <trans-unit id="9a4e17fa716627d801ba04248e7c13675c63f6bf" translate="yes" xml:space="preserve">
          <source>Using direct mode with SSL:</source>
          <target state="translated">使用直接模式与SSL。</target>
        </trans-unit>
        <trans-unit id="80be60b71aa62e009a5472e7b71ecca69fb605f2" translate="yes" xml:space="preserve">
          <source>Using direct mode:</source>
          <target state="translated">使用直接模式。</target>
        </trans-unit>
        <trans-unit id="1c1bc19943239ea53498134ee5024657c6f7482f" translate="yes" xml:space="preserve">
          <source>Using git for collaboration</source>
          <target state="translated">使用git进行协作</target>
        </trans-unit>
        <trans-unit id="e742dd237e897f0c09d1168ed38eeca1316d409b" translate="yes" xml:space="preserve">
          <source>Using interactive rebases</source>
          <target state="translated">使用互动式资料库</target>
        </trans-unit>
        <trans-unit id="16c9cb76d4ea0981714eee54828fc3305174e2d5" translate="yes" xml:space="preserve">
          <source>Using macro attributes</source>
          <target state="translated">使用宏属性</target>
        </trans-unit>
        <trans-unit id="0bcad514939a1a512d30defc1dd83a6988408bd1" translate="yes" xml:space="preserve">
          <source>Using more options generally further limits the output (e.g. &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; limits to commits newer than &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt;, and using it with &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; further limits to commits whose log message has a line that matches &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;), unless otherwise noted.</source>
          <target state="translated">使用更多选项通常会进一步限制输出（例如，-- &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; 限制用于提交比 &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt; 更新的提交，并将其与 &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; 一起使用进一步限制用于提交其日志消息具有与 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; ），除非另有说明。</target>
        </trans-unit>
        <trans-unit id="aab9e25047cbd960c71a3d6743c695a0fbcee99d" translate="yes" xml:space="preserve">
          <source>Using refspecs explicitly:</source>
          <target state="translated">明确使用refspecs。</target>
        </trans-unit>
        <trans-unit id="e240eb205361a2a50754a2cbbad5230917e3c8f6" translate="yes" xml:space="preserve">
          <source>Using test suites and git bisect together</source>
          <target state="translated">使用测试套件和git bisect一起使用。</target>
        </trans-unit>
        <trans-unit id="8fdfb0e1e33426ffa586ab6e967bc34118a45d25" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;--submodule=log&lt;/code&gt; option with &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; will provide that information too.</source>
          <target state="translated">在&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]中&lt;/a&gt;使用 &lt;code&gt;--submodule=log&lt;/code&gt; 选项也将提供该信息。</target>
        </trans-unit>
        <trans-unit id="d42f8d8f39d5c1ce54e65e242137998175012054" translate="yes" xml:space="preserve">
          <source>Using these options, &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; will act similar to the more specialized family of commit log tools: &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;</source>
          <target state="translated">使用这些选项，&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]的&lt;/a&gt;作用类似于更专业的提交日志工具系列：&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;，&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;和&lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a34d360db274a11502bc402ef7758f2bc5adf11b" translate="yes" xml:space="preserve">
          <source>Using this helper will store your passwords unencrypted on disk, protected only by filesystem permissions. If this is not an acceptable security tradeoff, try &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache[1]&lt;/a&gt;, or find a helper that integrates with secure storage provided by your operating system.</source>
          <target state="translated">使用此帮助程序会将密码未加密地存储在磁盘上，仅受文件系统权限保护。如果这不是可接受的安全性折衷方案，请尝试使用&lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache [1]&lt;/a&gt;或查找与操作系统提供的安全存储集成在一起的帮助程序。</target>
        </trans-unit>
        <trans-unit id="86d0ca06bdb5a3aacec696a9b10115a302a90ea4" translate="yes" xml:space="preserve">
          <source>Using this hook, it is easy to generate mails describing the updates to the repository. This example script sends one mail message per ref listing the commits pushed to the repository, and logs the push certificates of signed pushes with good signatures to a logger service:</source>
          <target state="translated">使用这个钩子,可以很容易地生成描述版本库更新的邮件。这个示例脚本为每个 ref 发送一封邮件,列出推送到版本库的提交信息,并将签名良好的推送证书记录到记录器服务。</target>
        </trans-unit>
        <trans-unit id="7ae98ad0643543d139a0ccded2d96be6c57e816c" translate="yes" xml:space="preserve">
          <source>Using this option for any other purpose (don&amp;rsquo;t ask) is very strongly discouraged.</source>
          <target state="translated">强烈建议不要将此选项用于其他目的（不要问）。</target>
        </trans-unit>
        <trans-unit id="ebe89d9e15d8a582f6b4a48c6c03d60cf9c673f1" translate="yes" xml:space="preserve">
          <source>Using tunnel mode:</source>
          <target state="translated">使用隧道模式。</target>
        </trans-unit>
        <trans-unit id="f17a1449e9ed80dcff59f550977b6693d42b10bf" translate="yes" xml:space="preserve">
          <source>Usual 3-way file level merge for text files. Conflicted regions are marked with conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. The version from your branch appears before the &lt;code&gt;=======&lt;/code&gt; marker, and the version from the merged branch appears after the &lt;code&gt;=======&lt;/code&gt; marker.</source>
          <target state="translated">文本文件的常规3向文件级合并。冲突区域用冲突标记 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;=======&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 标记。来自分支的版本显示在 &lt;code&gt;=======&lt;/code&gt; 标记之前，而来自合并分支的版本显示在 &lt;code&gt;=======&lt;/code&gt; 标记之后。</target>
        </trans-unit>
        <trans-unit id="6cb51fab051882aaba81e0715d7acfa80e2ce09c" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;git gc&lt;/code&gt; runs very quickly while providing good disk space utilization and performance. This option will cause &lt;code&gt;git gc&lt;/code&gt; to more aggressively optimize the repository at the expense of taking much more time. The effects of this optimization are mostly persistent. See the &quot;AGGRESSIVE&quot; section below for details.</source>
          <target state="translated">通常 &lt;code&gt;git gc&lt;/code&gt; 可以非常快速地运行，同时提供良好的磁盘空间利用率和性能。这个选项将使 &lt;code&gt;git gc&lt;/code&gt; 更加积极地优化存储库，但要花费更多时间。这种优化的效果大部分是持久的。有关详细信息，请参见下面的&amp;ldquo; AGGRESSIVE&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="da9e2cbf852524ee1edb371514af799c05f82c93" translate="yes" xml:space="preserve">
          <source>Usually a merge requires the index file as well as the files in the working tree to be up to date with the current head commit, in order not to lose local changes. This flag disables the check with the working tree and is meant to be used when creating a merge of trees that are not directly related to the current working tree status into a temporary index file.</source>
          <target state="translated">通常情况下,合并要求索引文件和工作树中的文件与当前的头提交保持一致,以避免丢失本地的变化。这个标志会禁用工作树的检查,用于将与当前工作树状态没有直接关系的树合并到临时索引文件中。</target>
        </trans-unit>
        <trans-unit id="27214bb5573e76f1f8a1f21396536681c10927d6" translate="yes" xml:space="preserve">
          <source>Usually a three-way merge by &lt;code&gt;git read-tree&lt;/code&gt; resolves the merge for really trivial cases and leaves other cases unresolved in the index, so that porcelains can implement different merge policies. This flag makes the command resolve a few more cases internally:</source>
          <target state="translated">通常，由 &lt;code&gt;git read-tree&lt;/code&gt; 进行的三路合并可解决真正琐碎的情况下的合并，而索引中未解决其他情况，以便瓷器可以实施不同的合并策略。此标志使命令可以在内部解决更多情况：</target>
        </trans-unit>
        <trans-unit id="1a018c180f83561166ef04fc1c1b049dd7bef5e3" translate="yes" xml:space="preserve">
          <source>Usually given &quot;&amp;lt;feature&amp;gt;&quot; is configurable via the &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; config variable in the per-repository Git configuration file.</source>
          <target state="translated">通常可以通过每个存储库Git配置文件中的 &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; config变量配置给定的&amp;ldquo; &amp;lt;feature&amp;gt;&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="06bd62b74600c2b58fc5390378d7102461c2b477" translate="yes" xml:space="preserve">
          <source>Usually it is easier to configure any desired options through your personal &lt;code&gt;.ssh/config&lt;/code&gt; file. Please consult your ssh documentation for further details.</source>
          <target state="translated">通常，通过您的个人 &lt;code&gt;.ssh/config&lt;/code&gt; 文件配置任何所需的选项会更容易。请查阅ssh文档以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="e92c22e35ceb9b2c8da5295a992718e30d5c9f60" translate="yes" xml:space="preserve">
          <source>Usually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command prevents you from making such a commit. This option bypasses the safety, and is primarily for use by foreign SCM interface scripts.</source>
          <target state="translated">通常记录一个与唯一父提交树完全相同的提交是一个错误,该命令可以防止你进行这样的提交。这个选项绕过了安全问题,主要用于国外SCM接口脚本。</target>
        </trans-unit>
        <trans-unit id="8ce3f0d516dc2a9d67b8e4ba143055eaf7bab452" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates a sequence of commits. This flag applies the changes necessary to cherry-pick each named commit to your working tree and the index, without making any commit. In addition, when this option is used, your index does not have to match the HEAD commit. The cherry-pick is done against the beginning state of your index.</source>
          <target state="translated">通常情况下,该命令会自动创建一个提交序列。这个标志将对工作树和索引进行必要的修改,以挑出每个命名的提交,而不进行任何提交。此外,当使用这个选项时,你的索引不必与 HEAD 提交匹配。挑拣是根据索引的起始状态进行的。</target>
        </trans-unit>
        <trans-unit id="55875ee1e78ad1cfc5a25d1e098bc17781327203" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates some commits with commit log messages stating which commits were reverted. This flag applies the changes necessary to revert the named commits to your working tree and the index, but does not make the commits. In addition, when this option is used, your index does not have to match the HEAD commit. The revert is done against the beginning state of your index.</source>
          <target state="translated">通常情况下,命令会自动创建一些提交,并在提交日志中说明哪些提交被还原。这个选项将对工作树和索引进行必要的修改,但不进行提交。此外,当使用这个选项时,您的索引不必与 HEAD 提交匹配。还原是根据索引的起始状态进行的。</target>
        </trans-unit>
        <trans-unit id="51d5f6e8faedb5ef4d1204f14e2f7ab2d7b77eaf" translate="yes" xml:space="preserve">
          <source>Usually the command stops output upon showing the commit that is the common ancestor of all the branches. This flag tells the command to go &amp;lt;n&amp;gt; more common commits beyond that. When &amp;lt;n&amp;gt; is negative, display only the &amp;lt;reference&amp;gt;s given, without showing the commit ancestry tree.</source>
          <target state="translated">通常，该命令会在显示所有分支的共同祖先的提交后停止输出。该标志告诉命令执行&amp;lt;n&amp;gt;个更常见的提交。当&amp;lt;n&amp;gt;为负数时，仅显示给定的&amp;lt;reference&amp;gt;，而不显示提交祖先树。</target>
        </trans-unit>
        <trans-unit id="972a81bf641e40fbeef4b825d75473d102daada5" translate="yes" xml:space="preserve">
          <source>Usually the easiest way to distinguish between these accounts is to use the username in the URL. For example, if you have the accounts &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; on &lt;code&gt;git.example.org&lt;/code&gt;, you can use the URLs &lt;a href=&quot;https://author@git.example.org/org1/project1.git&quot;&gt;https://author@git.example.org/org1/project1.git&lt;/a&gt; and &lt;a href=&quot;https://committer@git.example.org/org2/project2.git&quot;&gt;https://committer@git.example.org/org2/project2.git&lt;/a&gt;. This way, when you use a credential helper, it will automatically try to look up the correct credentials for your account. If you already have a remote set up, you can change the URL with something like &lt;code&gt;git remote set-url
origin https://author@git.example.org/org1/project1.git&lt;/code&gt; (see &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; for details).</source>
          <target state="translated">通常，区分这些帐户的最简单方法是使用URL中的用户名。例如，如果您在 &lt;code&gt;git.example.org&lt;/code&gt; 上具有帐户 &lt;code&gt;author&lt;/code&gt; 和 &lt;code&gt;committer&lt;/code&gt; 者，则可以使用URL &lt;a href=&quot;https://author@git.example.org/org1/project1.git&quot;&gt;https：//author@git.example.org/org1/project1.git&lt;/a&gt;和&lt;a href=&quot;https://committer@git.example.org/org2/project2.git&quot;&gt;https：//committer@git.example .org / org2 / project2.git&lt;/a&gt;。这样，当您使用凭据帮助程序时，它将自动尝试为您的帐户查找正确的凭据。如果您已经进行了远程设置，则可以使用 &lt;code&gt;git remote set-url origin https://author@git.example.org/org1/project1.git&lt;/code&gt; 类的名称来更改URL （有关详细信息，请参见&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="29097abe7ecd686605680556737a55dc5b7468af" translate="yes" xml:space="preserve">
          <source>Usually the object names are output in SHA-1 form (with possible &lt;code&gt;^&lt;/code&gt; prefix); this option makes them output in a form as close to the original input as possible.</source>
          <target state="translated">通常，对象名称以SHA-1格式输出（可能带有 &lt;code&gt;^&lt;/code&gt; 前缀）；此选项使它们以尽可能接近原始输入的形式输出。</target>
        </trans-unit>
        <trans-unit id="576f849692364345fa924f476c3413707294c315" translate="yes" xml:space="preserve">
          <source>Usually the output is made one line per flag and parameter. This option makes output a single line, properly quoted for consumption by shell. Useful when you expect your parameter to contain whitespaces and newlines (e.g. when using pickaxe &lt;code&gt;-S&lt;/code&gt; with &lt;code&gt;git diff-*&lt;/code&gt;). In contrast to the &lt;code&gt;--sq-quote&lt;/code&gt; option, the command input is still interpreted as usual.</source>
          <target state="translated">通常，每个标志和参数的输出为一行。此选项使输出单行，正确引用以供shell使用。当您希望参数包含空格和换行符时 &lt;code&gt;git diff-*&lt;/code&gt; 用（例如，当将pickaxe &lt;code&gt;-S&lt;/code&gt; 与git diff- *一起使用时）。与 &lt;code&gt;--sq-quote&lt;/code&gt; 选项相比，该命令输入仍然像往常一样被解释。</target>
        </trans-unit>
        <trans-unit id="52303fe63fddea8a07d49fe1df917ff950ba6541" translate="yes" xml:space="preserve">
          <source>Usually the program removes email cruft from the Subject: header line to extract the title line for the commit log message. This option prevents this munging, and is most useful when used to read back &lt;code&gt;git format-patch -k&lt;/code&gt; output.</source>
          <target state="translated">通常，程序从Subject：标题行中删除电子邮件碎片，以提取提交日志消息的标题行。这个选项防止这种麻烦，并且在用于回读 &lt;code&gt;git format-patch -k&lt;/code&gt; 输出时最有用。</target>
        </trans-unit>
        <trans-unit id="12904fba6e8c31d350b5463557502fba670802b3" translate="yes" xml:space="preserve">
          <source>Usually you cannot cherry-pick a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows cherry-pick to replay the change relative to the specified parent.</source>
          <target state="translated">通常情况下,你不能挑拣一个合并,因为你不知道合并的哪一边应该被视为主线。这个选项指定了主线的父号(从1开始),允许cherry-pick重放相对于指定父号的变化。</target>
        </trans-unit>
        <trans-unit id="8ec09d5ac366ce3cd2a5e3c6c67d0b4fe311e4bf" translate="yes" xml:space="preserve">
          <source>Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.</source>
          <target state="translated">通常情况下,你不能恢复合并,因为你不知道合并的哪一边应该被视为主线。这个选项指定了主线的父号(从1开始),并允许还原相对于指定父号的变化。</target>
        </trans-unit>
        <trans-unit id="6969d1a350dfc3fafb277e2e6995e5ac7a289ac5" translate="yes" xml:space="preserve">
          <source>Usually you should not need to change (adjust) any of configuration variables described below; they should be automatically set by gitweb to correct value.</source>
          <target state="translated">通常情况下,你不需要改变(调整)下面描述的任何配置变量,它们应该由gitweb自动设置为正确的值。</target>
        </trans-unit>
        <trans-unit id="b172c85defacdb686b541793ef9e8aeee0cdf60e" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git fetch&lt;/code&gt;, which is a higher level wrapper of this command, instead.</source>
          <target state="translated">通常，您会想使用 &lt;code&gt;git fetch&lt;/code&gt; ，它是此命令的高级包装。</target>
        </trans-unit>
        <trans-unit id="bec645de31c299cb10f93b6253e1e1669a5f0a31" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git push&lt;/code&gt;, which is a higher-level wrapper of this command, instead. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">通常，您会想使用 &lt;code&gt;git push&lt;/code&gt; ，它是此命令的高级包装。参见&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5982263578e4f00875c00a40da810fe92911cebc" translate="yes" xml:space="preserve">
          <source>Usually, &quot;git push&quot; refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it.</source>
          <target state="translated">通常,&quot;git push &quot;会拒绝更新不是本地 ref 祖先的远程 ref。</target>
        </trans-unit>
        <trans-unit id="f8497b6ab754b20f8d36f9efb8dfea581706bc5d" translate="yes" xml:space="preserve">
          <source>Usually, dangling blobs and trees aren&amp;rsquo;t very interesting. They&amp;rsquo;re almost always the result of either being a half-way mergebase (the blob will often even have the conflict markers from a merge in it, if you have had conflicting merges that you fixed up by hand), or simply because you interrupted a &lt;code&gt;git fetch&lt;/code&gt; with ^C or something like that, leaving &lt;code&gt;some&lt;/code&gt; of the new objects in the object database, but just dangling and useless.</source>
          <target state="translated">通常，悬挂的斑点和树木不是很有趣。它们几乎总是由于成为中途合并基础而产生的（如果您手动修复了冲突的合并，则blob甚至经常会在其中包含来自合并的冲突标记），或者仅仅是因为您打断了一个 &lt;code&gt;git fetch&lt;/code&gt; 与^ C或类似的东西，留下 &lt;code&gt;some&lt;/code&gt; 新对象的对象数据库中，但只是晃来晃去的和无用的。</target>
        </trans-unit>
        <trans-unit id="6811a338c6e88fac2f36caab99cbe1bb3018067b" translate="yes" xml:space="preserve">
          <source>Usually, if the password or token is invalid, Git will erase it and prompt for a new one. However, there are times when this doesn&amp;rsquo;t always happen. To change the password or token, you can erase the existing credentials and then Git will prompt for new ones. To erase credentials, use a syntax like the following (substituting your username and the hostname):</source>
          <target state="translated">通常，如果密码或令牌无效，Git会将其删除并提示输入新的密码。但是，有时这种情况并非总是会发生。要更改密码或令牌，您可以删除现有的凭据，然后Git会提示您输入新的凭据。要删除凭据，请使用以下语法（替换您的用户名和主机名）：</target>
        </trans-unit>
        <trans-unit id="ebecb811fcb50ea2c9e80ad196b73df5b02ee5fc" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when &lt;code&gt;--force-with-lease&lt;/code&gt; option is used, the command refuses to update a remote ref whose current value does not match what is expected.</source>
          <target state="translated">通常，该命令拒绝更新不是用于覆盖它的本地引用的祖先的远程引用。另外，当使用 &lt;code&gt;--force-with-lease&lt;/code&gt; 选项时，该命令将拒绝更新其当前值与预期值不匹配的远程引用。</target>
        </trans-unit>
        <trans-unit id="1039e5d0aca0474d85bb0cc56a14c21769cd56ed" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the check. What this means is that the remote repository can lose commits; use it with care.</source>
          <target state="translated">通常情况下,命令会拒绝更新一个不是用来覆盖它的本地 ref 的祖先的远程 ref。这个标志可以禁用检查。这意味着远程仓库可能会丢失提交,请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="b573cab97a4c7ff4e65c78f089627a289eeb14b6" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;'s include:</source>
          <target state="translated">有效的 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 包括：</target>
        </trans-unit>
        <trans-unit id="2f441e23dc9e42a84676feea9743dbd62f2c9b12" translate="yes" xml:space="preserve">
          <source>Valid object types are:</source>
          <target state="translated">有效的对象类型是:</target>
        </trans-unit>
        <trans-unit id="9b5bd1c32c0119d43f13ecb3f634510bb032afd7" translate="yes" xml:space="preserve">
          <source>Validate packed Git archive files</source>
          <target state="translated">验证打包的Git存档文件</target>
        </trans-unit>
        <trans-unit id="c95efe4a20b3c90ba09bca423cb347dacda4f997" translate="yes" xml:space="preserve">
          <source>Validates the GPG signature created by &lt;code&gt;git commit -S&lt;/code&gt;.</source>
          <target state="translated">验证 &lt;code&gt;git commit -S&lt;/code&gt; 创建的GPG签名。</target>
        </trans-unit>
        <trans-unit id="ee833db09826b15f6656c228fc09101a4d262c96" translate="yes" xml:space="preserve">
          <source>Validates the gpg signature created by &lt;code&gt;git tag&lt;/code&gt;.</source>
          <target state="translated">验证 &lt;code&gt;git tag&lt;/code&gt; 创建的gpg签名。</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="38ecbfb58a1b4075db82e349628396bb680485d8" translate="yes" xml:space="preserve">
          <source>Values for other tools can be used if there is a corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration entry (see below).</source>
          <target state="translated">如果有相应的 &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 配置条目（请参见下文），则可以使用其他工具的值。</target>
        </trans-unit>
        <trans-unit id="4590af9796b7774b94529a47844bbbd8cd70381f" translate="yes" xml:space="preserve">
          <source>Values obtained in later configuration files override values obtained earlier in the above sequence.</source>
          <target state="translated">在后来的配置文件中获得的值覆盖了上述序列中早期获得的值。</target>
        </trans-unit>
        <trans-unit id="42a2c91c112ab20fb86d229e79049c16aac8f47b" translate="yes" xml:space="preserve">
          <source>Values of many variables are treated as a simple string, but there are variables that take values of specific types and there are rules as to how to spell them.</source>
          <target state="translated">很多变量的值都是作为一个简单的字符串来处理的,但是有的变量取的是特定类型的值,如何拼写是有规则的。</target>
        </trans-unit>
        <trans-unit id="af6a117cf9cae5d8127a5c83e908e26e4094605c" translate="yes" xml:space="preserve">
          <source>Variable substitution</source>
          <target state="translated">可变式替代</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="36ae09eeb0daa8ef3fa73e86b507f064c6f1150e" translate="yes" xml:space="preserve">
          <source>Various Git commands use the following environment variables:</source>
          <target state="translated">各种Git命令都会使用以下环境变量。</target>
        </trans-unit>
        <trans-unit id="c808db304a88e67e4d99602bde96a3fd73a86c36" translate="yes" xml:space="preserve">
          <source>Various aspects of gitweb&amp;rsquo;s behavior can be controlled through the configuration file &lt;code&gt;gitweb_config.perl&lt;/code&gt; or &lt;code&gt;/etc/gitweb.conf&lt;/code&gt;. See the &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; for details.</source>
          <target state="translated">可以通过配置文件 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 或 &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; 来控制gitweb行为的各个方面。有关详细信息，请参见&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="514c3adc237433a43f04caf698ef6f51638f8f03" translate="yes" xml:space="preserve">
          <source>Various commands read from the configuration file and adjust their operation accordingly. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a list and more details about the configuration mechanism.</source>
          <target state="translated">从配置文件中读取各种命令，并相应地调整其操作。有关配置机制的列表和更多详细信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d741cda072f8e825584f9d44fb913d01a1b3645" translate="yes" xml:space="preserve">
          <source>Various values from structured fields in referenced objects can be used to interpolate into the resulting output, or as sort keys.</source>
          <target state="translated">引用对象中结构化字段的各种值可以用来插值到结果输出中,或者作为排序键。</target>
        </trans-unit>
        <trans-unit id="0e52597805b02b27bbf6fa8afb053d38cd1cf9a2" translate="yes" xml:space="preserve">
          <source>Various ways to check your working tree</source>
          <target state="translated">检查工作树的各种方法</target>
        </trans-unit>
        <trans-unit id="8a8830ff167eaa3505bc00fdd4111ea514743436" translate="yes" xml:space="preserve">
          <source>Verbose output.</source>
          <target state="translated">啰嗦的输出。</target>
        </trans-unit>
        <trans-unit id="5e80e8afa8277ee05efe0825f2f72b290ab38b7f" translate="yes" xml:space="preserve">
          <source>Verbose.</source>
          <target state="translated">Verbose.</target>
        </trans-unit>
        <trans-unit id="1eee329978eae57e0140879a7cb5a19a8e448f4c" translate="yes" xml:space="preserve">
          <source>Verbosely display information about the searching strategy being employed to standard error. The tag name will still be printed to standard out.</source>
          <target state="translated">以标准误差口头显示有关正在使用的搜索策略的信息。标签名称仍会被打印出来,达到标准误差。</target>
        </trans-unit>
        <trans-unit id="17eca013b0d71c76732d4067f559197bffc5dc5a" translate="yes" xml:space="preserve">
          <source>Verbosity: let &lt;code&gt;cvsimport&lt;/code&gt; report what it is doing.</source>
          <target state="translated">&lt;code&gt;cvsimport&lt;/code&gt; 程度：让cvsimport报告它在做什么。</target>
        </trans-unit>
        <trans-unit id="43241483b8c2e2b351480246076bc9d9d3aeeb38" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database</source>
          <target state="translated">验证数据库中对象的连接性和有效性。</target>
        </trans-unit>
        <trans-unit id="083f6e6fa7581860cb22a12637eec790f2c234d9" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database.</source>
          <target state="translated">验证数据库中对象的连接性和有效性。</target>
        </trans-unit>
        <trans-unit id="6f20b572e11a287b2200fc3c18b3124b41ee5e40" translate="yes" xml:space="preserve">
          <source>Verify &amp;lt;ref&amp;gt; against &amp;lt;oldvalue&amp;gt; but do not change it. If &amp;lt;oldvalue&amp;gt; is zero or missing, the ref must not exist.</source>
          <target state="translated">针对&amp;lt;oldvalue&amp;gt;验证&amp;lt;ref&amp;gt;，但不要更改它。如果&amp;lt;oldvalue&amp;gt;为零或丢失，则引用必须不存在。</target>
        </trans-unit>
        <trans-unit id="121ce6e2fb35359b4c456b6cab91a3389a1154d2" translate="yes" xml:space="preserve">
          <source>Verify &amp;lt;ref&amp;gt; against &amp;lt;oldvalue&amp;gt; but do not change it. If &amp;lt;oldvalue&amp;gt; zero or missing, the ref must not exist.</source>
          <target state="translated">针对&amp;lt;oldvalue&amp;gt;验证&amp;lt;ref&amp;gt;，但不要更改它。如果&amp;lt;oldvalue&amp;gt;为零或丢失，则引用必须不存在。</target>
        </trans-unit>
        <trans-unit id="f2a6ea4dcf4e13700439c2c62eb9c887c3645654" translate="yes" xml:space="preserve">
          <source>Verify that everything reachable from target is fetched. Used after an earlier fetch is interrupted.</source>
          <target state="translated">确认所有从target可以到达的东西都被取走了。在早先的获取被中断后使用。</target>
        </trans-unit>
        <trans-unit id="dc19dfe6277cd8889c0ce32fc30714a767c456fd" translate="yes" xml:space="preserve">
          <source>Verify that exactly one parameter is provided, and that it can be turned into a raw 20-byte SHA-1 that can be used to access the object database. If so, emit it to the standard output; otherwise, error out.</source>
          <target state="translated">验证是否正好提供了一个参数,并且它可以变成一个20字节的原始SHA-1,可以用来访问对象数据库。如果可以,则将其输出到标准输出;否则,出错。</target>
        </trans-unit>
        <trans-unit id="e921c65f691e2b371e3e29dc398bb292612d2860" translate="yes" xml:space="preserve">
          <source>Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key. If the tip commit of the side branch is not signed with a valid key, the merge is aborted.</source>
          <target state="translated">验证被合并的侧分支的提示提交是否用有效的密钥签署,即具有有效uid的密钥:在默认的信任模型中,这意味着签署密钥已经由受信任的密钥签署。如果侧分支的提示提交不是用有效的密钥签署的,合并就会中止。</target>
        </trans-unit>
        <trans-unit id="baf3600caf9cbc675ef33fe6c51f69bd006b47ea" translate="yes" xml:space="preserve">
          <source>Verify the GPG signature of the given tag names.</source>
          <target state="translated">验证给定标签名的 GPG 签名。</target>
        </trans-unit>
        <trans-unit id="2977304de3538ddff5d274481548280fa86926b6" translate="yes" xml:space="preserve">
          <source>Verify the MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">验证当前.git文件夹中packfiles的MIDX文件。</target>
        </trans-unit>
        <trans-unit id="593811a1bcc6cbc445bcfa7fdf52e4a760c41784" translate="yes" xml:space="preserve">
          <source>Verify the contents of the MIDX file.</source>
          <target state="translated">验证MIDX文件的内容。</target>
        </trans-unit>
        <trans-unit id="63de76d12bfde7fe2c14402fe2f03160cc3a7318" translate="yes" xml:space="preserve">
          <source>Version 1 porcelain format is similar to the short format, but is guaranteed not to change in a backwards-incompatible way between Git versions or based on user configuration. This makes it ideal for parsing by scripts. The description of the short format above also describes the porcelain format, with a few exceptions:</source>
          <target state="translated">第1版瓷器格式与短格式类似,但保证不会在Git版本之间或根据用户配置进行向后不兼容的改变。这使得它非常适合脚本的解析。上面对短格式的描述也是对瓷器格式的描述,但有一些例外。</target>
        </trans-unit>
        <trans-unit id="1bb30898712789d3819631e4bb7ad8cf32d20671" translate="yes" xml:space="preserve">
          <source>Version 1 takes two arguments, a version (1) and the time in elapsed nanoseconds since midnight, January 1, 1970.</source>
          <target state="translated">版本1需要两个参数,一个是版本(1),另一个是1970年1月1日午夜以来的经过的纳秒时间。</target>
        </trans-unit>
        <trans-unit id="33e409adcd5a97d5085c0477fcb4b42dc9a034a9" translate="yes" xml:space="preserve">
          <source>Version 2 format adds more detailed information about the state of the worktree and changed items. Version 2 also defines an extensible set of easy to parse optional headers.</source>
          <target state="translated">第2版格式增加了更多关于工作树状态和变更项的详细信息。第2版还定义了一套可扩展的、易于解析的可选头文件。</target>
        </trans-unit>
        <trans-unit id="2b8063c91f48f5daba279d42a4965f292b8198dd" translate="yes" xml:space="preserve">
          <source>Version 2 pack-*.idx files support packs larger than 4 gib, and</source>
          <target state="translated">第2版pack-*.idx文件支持大于4个gib的包,以及</target>
        </trans-unit>
        <trans-unit id="76b6cb1496a78fff149bd68b719a91ca0d69c9df" translate="yes" xml:space="preserve">
          <source>Version 2 takes two arguments, a version (2) and a token that is used for identifying changes since the token. For watchman this would be a clock id. This version must output to stdout the new token followed by a NUL before the list of files.</source>
          <target state="translated">版本2需要两个参数,一个是版本(2),一个是用于识别自标记以来的变化的标记。对于watchman来说,这应该是一个时钟ID。这个版本必须将新的标记输出到stdout,然后在文件列表前加上一个NUL。</target>
        </trans-unit>
        <trans-unit id="5a28a75eceea6b3fb1730e69daff64901cead811" translate="yes" xml:space="preserve">
          <source>Version 4 performs a simple pathname compression that reduces index size by 30%-50% on large repositories, which results in faster load time. Version 4 is relatively young (first released in 1.8.0 in October 2012). Other Git implementations such as JGit and libgit2 may not support it yet.</source>
          <target state="translated">第4版执行简单的路径名压缩,在大型资源库上减少30%-50%的索引大小,从而加快加载时间。第4版还比较年轻(2012年10月首次发布的1.8.0版本),其他Git实现如JGit和libgit2可能还不支持。其他Git实现,如JGit和libgit2可能还不支持。</target>
        </trans-unit>
        <trans-unit id="5b61ffa7c699cf77c98fcf76236048d42ca5d233" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">版本 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fc1164df4f366b4e06ce848f94e3799671648de" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">版本 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26980b77b1e7ef480646032aebce78732551db11" translate="yes" xml:space="preserve">
          <source>Versions of Git older than 1.7.7 don&amp;rsquo;t know about the &lt;code&gt;tar.gz&lt;/code&gt; format, you&amp;rsquo;ll need to use gzip explicitly:</source>
          <target state="translated">低于1.7.7的Git版本不了解 &lt;code&gt;tar.gz&lt;/code&gt; 格式，您需要明确使用gzip：</target>
        </trans-unit>
        <trans-unit id="48cda44638e8ce2f3c6e764951e4cd137e88bacc" translate="yes" xml:space="preserve">
          <source>Via the alternates mechanism, a &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; can inherit part of its &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; from another object database, which is called an &quot;alternate&quot;.</source>
          <target state="translated">通过备用机制，&lt;a href=&quot;#def_repository&quot;&gt;存储库&lt;/a&gt;可以从另一个对象数据库（称为&amp;ldquo;备用&amp;rdquo;）继承其&lt;a href=&quot;#def_object_database&quot;&gt;对象数据库的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="d75bfce3768015c62af9c4bd29fd7cad894764e0" translate="yes" xml:space="preserve">
          <source>Viewing everything that was changed in a revision, and step through revisions one at a time, viewing the history of the repository.</source>
          <target state="translated">查看修订中的所有变化,并逐一查看修订,查看版本库的历史。</target>
        </trans-unit>
        <trans-unit id="8e797001d4524362e7db8f18210266901eb28403" translate="yes" xml:space="preserve">
          <source>Viewing files in GUI tools</source>
          <target state="translated">在GUI工具中查看文件</target>
        </trans-unit>
        <trans-unit id="05c33ea7de1cccd62a72042e46bec3b3d340cf9f" translate="yes" xml:space="preserve">
          <source>Viewing multiple Git repositories with common root.</source>
          <target state="translated">用共同的根查看多个Git仓库。</target>
        </trans-unit>
        <trans-unit id="1439a80405107c5dd4ca129513bf97eb92ca8c3f" translate="yes" xml:space="preserve">
          <source>Viewing old file versions</source>
          <target state="translated">查看旧文件版本</target>
        </trans-unit>
        <trans-unit id="cba1ab24737b9af4081eae74baa579853869959f" translate="yes" xml:space="preserve">
          <source>Viewing project history</source>
          <target state="translated">查看项目历史</target>
        </trans-unit>
        <trans-unit id="48e788f7b4905bc5801452134707bb74e1fddd3c" translate="yes" xml:space="preserve">
          <source>Viewing the blame/annotation details of any file (if enabled).</source>
          <target state="translated">查看任何文件的责任/注释详情(如果启用)。</target>
        </trans-unit>
        <trans-unit id="afd57038f9956faea3beadae2f663a8f18e1dd6a" translate="yes" xml:space="preserve">
          <source>Viewing the contents of files in the repository at any revision.</source>
          <target state="translated">查看版本库中任何版本的文件内容。</target>
        </trans-unit>
        <trans-unit id="79e8c237bcc343324671ba4de89f13c4632b7437" translate="yes" xml:space="preserve">
          <source>Viewing the revision log of branches, history of files and directories, see what was changed when, by who.</source>
          <target state="translated">查看分支的修订日志、文件和目录的历史记录,查看什么时候、由谁修改了什么。</target>
        </trans-unit>
        <trans-unit id="5d3b4279714ad2970a30b9dfdfce1d9cde0d271d" translate="yes" xml:space="preserve">
          <source>Voila.</source>
          <target state="translated">Voila.</target>
        </trans-unit>
        <trans-unit id="f7dda342bfe7129409283096bf9eae6889a3617d" translate="yes" xml:space="preserve">
          <source>Waiting $&amp;lt;int&amp;gt; seconds before reconnecting to SMTP server. Used together with --batch-size option. Defaults to the &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; configuration variable.</source>
          <target state="translated">等待$ &amp;lt;int&amp;gt;秒，然后重新连接到SMTP服务器。与--batch-size选项一起使用。默认为 &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; 配置变量。</target>
        </trans-unit>
        <trans-unit id="6abfc589b188840a4520edd8282e2221d54aed84" translate="yes" xml:space="preserve">
          <source>Walk history forward instead of backward. Instead of showing the revision in which a line appeared, this shows the last revision in which a line has existed. This requires a range of revision like START..END where the path to blame exists in START. &lt;code&gt;git blame --reverse START&lt;/code&gt; is taken as &lt;code&gt;git blame
--reverse START..HEAD&lt;/code&gt; for convenience.</source>
          <target state="translated">向前走历史而不是向后走。与其显示行所在的修订，不显示行所在的最新修订。这就需要进行一系列修订，例如START..END，其中的归咎路径在START中。为方便起见，将 &lt;code&gt;git blame --reverse START&lt;/code&gt; 视为 &lt;code&gt;git blame --reverse START..HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="246770a4db6a59723366cd008c0806351012631a" translate="yes" xml:space="preserve">
          <source>Walk through the patches in the series and warn if we cannot find all of the necessary information to commit a patch. At the time of this writing only missing author information is warned about.</source>
          <target state="translated">走过系列的补丁,如果我们无法找到提交补丁的所有必要信息,就会发出警告。在写这篇文章的时候,只对缺少的作者信息进行警告。</target>
        </trans-unit>
        <trans-unit id="8741434725596a0a6dcba1ea6ce0540165fbeb38" translate="yes" xml:space="preserve">
          <source>Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.</source>
          <target state="translated">如果更改引入冲突标记或空白错误，则发出警告。哪些空白错误由 &lt;code&gt;core.whitespace&lt;/code&gt; 配置控制。默认情况下，尾随空格（包括仅由空格组成的行）以及在行的初始缩进内紧随其后是制表符的空格字符都被视为空格错误。如果发现问题，则以非零状态退出。与--exit-code不兼容。</target>
        </trans-unit>
        <trans-unit id="d0219dea42624b30174e17cfd1bb37d7d1a042a1" translate="yes" xml:space="preserve">
          <source>Warn of patches that contain lines longer than 998 characters unless a suitable transfer encoding (&lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, or &lt;code&gt;quoted-printable&lt;/code&gt;) is used; this is due to SMTP limits as described by &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txt&lt;/a&gt;.</source>
          <target state="translated">除非行中使用了适当的传输编码（ &lt;code&gt;auto&lt;/code&gt; ， &lt;code&gt;base64&lt;/code&gt; 或 &lt;code&gt;quoted-printable&lt;/code&gt; ），否则警告包含超过998个字符的行的修补程序；这是由于&lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txt中&lt;/a&gt;所述的SMTP限制所致。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="d9a62a2598117c2be58c53a722de6576cd225a89" translate="yes" xml:space="preserve">
          <source>Warnings are printed on the standard error output for any explicitly unsupported constructs, and any other lines that are not recognized by the parser.</source>
          <target state="translated">对于任何明确不支持的构造,以及任何其他不被解析器识别的行,都会在标准错误输出中打印警告。</target>
        </trans-unit>
        <trans-unit id="54490e8680807566a4db5e14166b54af9ee18d68" translate="yes" xml:space="preserve">
          <source>We already saw in &lt;a href=&quot;#understanding-commits&quot;&gt;Understanding History: Commits&lt;/a&gt; that all commits are stored under a 40-digit &quot;object name&quot;. In fact, all the information needed to represent the history of a project is stored in objects with such names. In each case the name is calculated by taking the SHA-1 hash of the contents of the object. The SHA-1 hash is a cryptographic hash function. What that means to us is that it is impossible to find two different objects with the same name. This has a number of advantages; among others:</source>
          <target state="translated">我们已经在&lt;a href=&quot;#understanding-commits&quot;&gt;了解历史记录：提交中&lt;/a&gt;看到所有提交都存储在40位&amp;ldquo;对象名&amp;rdquo;下。实际上，表示项目历史所需的所有信息都存储在具有此类名称的对象中。在每种情况下，名称都是通过获取对象内容的SHA-1哈希值来计算的。SHA-1哈希是一种加密哈希函数。对我们而言，这意味着不可能找到两个具有相同名称的不同对象。这具有许多优点。其中：</target>
        </trans-unit>
        <trans-unit id="e79afdd75f0417fa823f7b20619c450850fb2c27" translate="yes" xml:space="preserve">
          <source>We also recommend setting a &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; file to explicitly mark which files are text and which are binary. If you want Git to guess, you can set the attribute &lt;code&gt;text=auto&lt;/code&gt;. For example, the following might be appropriate in some projects:</source>
          <target state="translated">我们还建议您设置一个&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;文件，以明确标记哪些文件是文本文件，哪些文件是二进制文件。如果要让Git猜测，可以设置属性 &lt;code&gt;text=auto&lt;/code&gt; 。例如，在某些项目中，以下内容可能适用：</target>
        </trans-unit>
        <trans-unit id="d6fd523936a98d1231393ad2931c9779a4d79b0e" translate="yes" xml:space="preserve">
          <source>We are looking for a &quot;best&quot; explanation of the new series in terms of the old one. We can represent an &quot;explanation&quot; as an edge in the graph:</source>
          <target state="translated">我们正在寻找一个新系列对旧系列的 &quot;最佳 &quot;解释。我们可以用图中的一条边来表示 &quot;解释&quot;。</target>
        </trans-unit>
        <trans-unit id="9b940c15e60e8d5e30f8f0dd6fb317eefa03a3c7" translate="yes" xml:space="preserve">
          <source>We assume that GITWEB_CONFIG has its default Makefile value, namely &lt;code&gt;gitweb_config.perl&lt;/code&gt;. Put the following in &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; file:</source>
          <target state="translated">我们假设GITWEB_CONFIG具有默认的Makefile值，即 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 。将以下内容放入 &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="860f449f084465687d5f3065e9dcdf4471fe0c53" translate="yes" xml:space="preserve">
          <source>We assume the following in /etc/services</source>
          <target state="translated">我们在/etc/services中假设以下内容</target>
        </trans-unit>
        <trans-unit id="e666201c4a3affd420bf339541f1e66f556269f5" translate="yes" xml:space="preserve">
          <source>We assume you have already created a Git repository for your project, possibly created from scratch or from a tarball (see &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt;), or imported from an already existing CVS repository (see the next section).</source>
          <target state="translated">我们假设您已经为您的项目创建了一个Git存储库，可能是从头开始或从tarball创建的（请参阅&lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt;），或者是从已经存在的CVS存储库中导入的（请参阅下一节）。</target>
        </trans-unit>
        <trans-unit id="a35a2d4ac8af99272cba8ca44431c44847ef0735" translate="yes" xml:space="preserve">
          <source>We can also create a tag to refer to a particular commit; after running</source>
          <target state="translated">我们也可以创建一个标签来引用一个特定的提交;在运行了</target>
        </trans-unit>
        <trans-unit id="ec584a188dcd2e25a99263b54f2feb909dc57e99" translate="yes" xml:space="preserve">
          <source>We can ask Git about this particular object with the &lt;code&gt;cat-file&lt;/code&gt; command. Don&amp;rsquo;t copy the 40 hex digits from this example but use those from your own version. Note that you can shorten it to only a few characters to save yourself typing all 40 hex digits:</source>
          <target state="translated">我们可以使用 &lt;code&gt;cat-file&lt;/code&gt; 命令向Git询问有关此特定对象的信息。不要复制此示例中的40个十六进制数字，而应使用您自己的版本中的40个十六进制数字。请注意，您可以将其缩短为仅几个字符，以免自己键入所有40个十六进制数字：</target>
        </trans-unit>
        <trans-unit id="3d0c7ad92eed63e4b86ed7fcdbe0a2af116dc20a" translate="yes" xml:space="preserve">
          <source>We can further investigate the time spent scanning for untracked files.</source>
          <target state="translated">我们可以进一步调查扫描未被跟踪的文件所花费的时间。</target>
        </trans-unit>
        <trans-unit id="14c5f91f2f30d67e424b3d8fa6177783e08a84fd" translate="yes" xml:space="preserve">
          <source>We can get just the branch-head names, and remove &lt;code&gt;master&lt;/code&gt;, with the help of the standard utilities cut and grep:</source>
          <target state="translated">我们可以在标准实用程序cut和grep的帮助下，获取分支头名称，然后删除 &lt;code&gt;master&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a00f6027326a1e03d87c7714c37d6396c5fc0f07" translate="yes" xml:space="preserve">
          <source>We can get this using the following command:</source>
          <target state="translated">我们可以使用下面的命令来获得。</target>
        </trans-unit>
        <trans-unit id="308213d749ac73498be48acb36aa505b62d477c8" translate="yes" xml:space="preserve">
          <source>We can give this name to &lt;code&gt;git show&lt;/code&gt; to see the details about this commit.</source>
          <target state="translated">我们可以将此名称赋予 &lt;code&gt;git show&lt;/code&gt; 以查看有关此提交的详细信息。</target>
        </trans-unit>
        <trans-unit id="164a7b582707458e7c29a45bdd3cb932a29b3ca1" translate="yes" xml:space="preserve">
          <source>We can list all the heads in this repository with &lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref[1]&lt;/a&gt;:</source>
          <target state="translated">我们可以使用&lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref [1]&lt;/a&gt;列出该存储库中的所有头像：</target>
        </trans-unit>
        <trans-unit id="3342879e047ae36a38db13969064b38d54ccc902" translate="yes" xml:space="preserve">
          <source>We divide Git into high level (&quot;porcelain&quot;) commands and low level (&quot;plumbing&quot;) commands.</source>
          <target state="translated">我们将Git分为高层(&quot;瓷器&quot;)命令和低层(&quot;管道&quot;)命令。</target>
        </trans-unit>
        <trans-unit id="011f9d254149abd4e25f111f5f8f2bc847e7e4cc" translate="yes" xml:space="preserve">
          <source>We explain how to do this in the following sections.</source>
          <target state="translated">我们在下面的章节中解释如何做到这一点。</target>
        </trans-unit>
        <trans-unit id="4822ab43c46db1b5802e2f53899245649e4398bd" translate="yes" xml:space="preserve">
          <source>We formulate a set of &lt;code&gt;rules&lt;/code&gt; for quick reference, while the prose tries to motivate each of them. Do not always take them literally; you should value good reasons for your actions higher than manpages such as this one.</source>
          <target state="translated">我们制定了一套 &lt;code&gt;rules&lt;/code&gt; 供快速参考，而散文则试图激发它们中的每一个。不要总是从字面上看待它们。您应该认为自己的行为比此类手册更为重要。</target>
        </trans-unit>
        <trans-unit id="27af85d69b0e1da45afccff7b9c2331995331c55" translate="yes" xml:space="preserve">
          <source>We found that most commits on the graph may give quite a lot of information when they are tested. And the commits that will not on average give a lot of information are the one near the good and bad commits.</source>
          <target state="translated">我们发现,图上的大多数提交在测试时可能会提供相当多的信息。而那些平均不会提供大量信息的提交,则是靠近好的和坏的提交。</target>
        </trans-unit>
        <trans-unit id="319c4fde5f53d3ebfff60d2ca81633ff5c5e7332" translate="yes" xml:space="preserve">
          <source>We have already seen &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;how to keep remote-tracking branches up to date&lt;/a&gt; with &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;, and how to merge two branches. So you can merge in changes from the original repository&amp;rsquo;s master branch with:</source>
          <target state="translated">我们已经看到了&lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;如何&lt;/a&gt;使用&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1] &lt;/a&gt;来使远程跟踪分支保持最新状态，以及如何合并两个分支。因此，您可以将原始存储库的master分支中的更改合并到：</target>
        </trans-unit>
        <trans-unit id="9313b2be3fe8f9ef5431fd57e740ed2c389d7c2c" translate="yes" xml:space="preserve">
          <source>We have already seen how branches work previously, with &quot;fun and work&quot; example using two branches. The idea is the same if there are more than two branches. Let&amp;rsquo;s say you started out from &quot;master&quot; head, and have some new code in the &quot;master&quot; branch, and two independent fixes in the &quot;commit-fix&quot; and &quot;diff-fix&quot; branches:</source>
          <target state="translated">我们已经看到了分支以前是如何工作的，其中使用两个分支的&amp;ldquo;有趣并工作&amp;rdquo;示例。如果有两个以上的分支，则想法是相同的。假设您从&amp;ldquo; master&amp;rdquo;头开始，在&amp;ldquo; master&amp;rdquo;分支中有一些新代码，在&amp;ldquo; commit-fix&amp;rdquo;和&amp;ldquo; diff-fix&amp;rdquo;分支中有两个独立的修复程序：</target>
        </trans-unit>
        <trans-unit id="1170354586d8db2806a89632eb01397ff1d5b39a" translate="yes" xml:space="preserve">
          <source>We have seen several ways of naming commits already:</source>
          <target state="translated">我们已经看到了几种命名提交的方式。</target>
        </trans-unit>
        <trans-unit id="ea2d131015439270646c4d9deb94b3238eec4d65" translate="yes" xml:space="preserve">
          <source>We have seen that regressions are an important problem, and that &quot;git bisect&quot; has nice features that complement very well practices and other tools, especially test suites, that are generally used to fight regressions. But it might be needed to change some work-flows and (bad) habits to get the most out of it.</source>
          <target state="translated">我们已经看到,回归是一个重要的问题,&quot;git bisect &quot;有很好的功能,可以很好地补充实践和其他工具,尤其是测试套件,这些工具通常用于打击回归。但可能需要改变一些工作流程和(坏的)习惯,才能发挥它的最大作用。</target>
        </trans-unit>
        <trans-unit id="58d71328c844eab6bb246a8885f29a926cbaf29b" translate="yes" xml:space="preserve">
          <source>We have seen that test suites and git bisect are very powerful when used together. It can be even more powerful if you can combine them with other systems.</source>
          <target state="translated">我们已经看到,测试套件和git bisect一起使用时非常强大。如果你能把它们和其他系统结合起来,就会更加强大。</target>
        </trans-unit>
        <trans-unit id="0dc1429b571e4014b12f464201faf90142f01343" translate="yes" xml:space="preserve">
          <source>We ignore all SVN properties except svn:executable. Any unhandled properties are logged to $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log</source>
          <target state="translated">我们忽略除svn：executable之外的所有SVN属性。任何未处理的属性都记录到$ GIT_DIR / svn / &amp;lt;refname&amp;gt; /unhandled.log中</target>
        </trans-unit>
        <trans-unit id="5e0e70c2a550cebe0f64341bc25aba4f82846837" translate="yes" xml:space="preserve">
          <source>We said this tutorial shows what plumbing does to help you cope with the porcelain that isn&amp;rsquo;t flushing, but we so far did not talk about how the merge really works. If you are following this tutorial the first time, I&amp;rsquo;d suggest to skip to &quot;Publishing your work&quot; section and come back here later.</source>
          <target state="translated">我们说本教程显示了管道功能可以帮助您应对未冲洗的瓷器，但是到目前为止，我们还没有讨论合并的真正原理。如果您是第一次学习本教程，建议您跳到&amp;ldquo;发布您的作品&amp;rdquo;部分，稍后再回到这里。</target>
        </trans-unit>
        <trans-unit id="038e0426e816e440e5c183b0ccfae9faca0c65b5" translate="yes" xml:space="preserve">
          <source>We saw above that &lt;code&gt;origin&lt;/code&gt; is just a shortcut to refer to the repository that you originally cloned from. This information is stored in Git configuration variables, which you can see using &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">我们在上面看到了 &lt;code&gt;origin&lt;/code&gt; 只是引用您最初从其克隆的存储库的快捷方式。此信息存储在Git配置变量中，您可以使用&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;查看：</target>
        </trans-unit>
        <trans-unit id="789eeb5f51968bf21d9746b92623ca08838d8bcb" translate="yes" xml:space="preserve">
          <source>We saw earlier that &quot;git bisect skip&quot; is now using a PRNG to try to avoid areas in the commit graph where commits are untestable. The problem is that sometimes the first bad commit will be in an untestable area.</source>
          <target state="translated">我们之前看到,&quot;git bisect skip &quot;现在使用 PRNG 来避免提交图中不可测试的提交区域。问题是,有时第一个坏的提交会出现在不可测试的区域。</target>
        </trans-unit>
        <trans-unit id="e6f53989efc34bb4d6e54dcd09f15943b6a8a36c" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#conflict-resolution&quot;&gt;Getting conflict-resolution help during a merge&lt;/a&gt; that during a merge the index can store multiple versions of a single file (called &quot;stages&quot;). The third column in the &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; output above is the stage number, and will take on values other than 0 for files with merge conflicts.</source>
          <target state="translated">我们在&lt;a href=&quot;#conflict-resolution&quot;&gt;合并&lt;/a&gt;过程中获得解决冲突的帮助中看到，在合并过程中，索引可以存储单个文件的多个版本（称为&amp;ldquo;阶段&amp;rdquo;）。上面输出的&lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]中&lt;/a&gt;的第三列是阶段号，对于具有合并冲突的文件，它将采用非0的值。</target>
        </trans-unit>
        <trans-unit id="d5d682276e6a6d081a241de022b4ded4aef9c418" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;Fixing a mistake by rewriting history&lt;/a&gt; that you can replace the most recent commit using</source>
          <target state="translated">我们在&lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;通过改写历史记录&lt;/a&gt;来纠正错误中看到，您可以使用替换最近的提交</target>
        </trans-unit>
        <trans-unit id="aafdc07c8e0d9b297fcdd505608f380ef754ed45" translate="yes" xml:space="preserve">
          <source>We saw in part one of the tutorial that commits have names like this. It turns out that every object in the Git history is stored under a 40-digit hex name. That name is the SHA-1 hash of the object&amp;rsquo;s contents; among other things, this ensures that Git will never store the same data twice (since identical data is given an identical SHA-1 name), and that the contents of a Git object will never change (since that would change the object&amp;rsquo;s name as well). The 7 char hex strings here are simply the abbreviation of such 40 character long strings. Abbreviations can be used everywhere where the 40 character strings can be used, so long as they are unambiguous.</source>
          <target state="translated">我们在本教程的第一部分中看到，提交具有这样的名称。事实证明，Git历史记录中的每个对象都以40位十六进制名称存储。该名称是对象内容的SHA-1哈希值；除其他事项外，这确保Git永远不会将相同的数据存储两次（因为相同的数据被赋予相同的SHA-1名称），并且Git对象的内容将永远不会更改（因为这也会更改对象的名称） ）。这里的7个char十六进制字符串只是这种40个字符长的字符串的缩写。缩写可以在可以使用40个字符串的任何地方使用，只要它们没有歧义即可。</target>
        </trans-unit>
        <trans-unit id="09c046487d09b436218fe11aa8c1087251442281" translate="yes" xml:space="preserve">
          <source>We separate the porcelain commands into the main commands and some ancillary user utilities.</source>
          <target state="translated">我们将瓷器命令分为主命令和一些辅助用户实用程序。</target>
        </trans-unit>
        <trans-unit id="f2e875357a5ce85901234308b841a3138ebd851b" translate="yes" xml:space="preserve">
          <source>We should point out that &quot;habitually&quot; (regularly for no real reason) merging an integration branch into your topics &amp;mdash; and by extension, merging anything upstream into anything downstream on a regular basis &amp;mdash; is frowned upon:</source>
          <target state="translated">我们应该指出，&amp;ldquo;习惯性地&amp;rdquo;（通常没有任何正当理由）将集成分支合并到您的主题中，并且通过扩展，将上游的任何内容定期合并到下游的任何内容中，您不赞成这样做：</target>
        </trans-unit>
        <trans-unit id="3b0c2056ade966758c96efbd333ad03c787ca3ac" translate="yes" xml:space="preserve">
          <source>We start with one specialized tool that is useful for finding the commit that introduced a bug into a project.</source>
          <target state="translated">我们先从一个专门的工具开始,这个工具可以帮助我们找到将错误引入项目的提交。</target>
        </trans-unit>
        <trans-unit id="3bb7fbe62fd9b3fa1a7f67f6a431251fe7b02079" translate="yes" xml:space="preserve">
          <source>We start with the most important, the &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; and the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">我们从最重要的&lt;a href=&quot;#def_object_database&quot;&gt;对象数据库&lt;/a&gt;和&lt;a href=&quot;#def_index&quot;&gt;索引开始&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa1acdd625946113b786a5983b045431892f2e96" translate="yes" xml:space="preserve">
          <source>We supposed in the previous examples that the &quot;good&quot; commits were ancestors of the &quot;bad&quot; commit. But this is not a requirement of &quot;git bisect&quot;.</source>
          <target state="translated">在前面的例子中,我们认为 &quot;好的 &quot;提交是 &quot;坏的 &quot;提交的祖先,但这不是 &quot;git bisect &quot;的要求。但这不是 &quot;git bisect &quot;的要求。</target>
        </trans-unit>
        <trans-unit id="09e675bfb62532c536d372645ebddf19b07c5684" translate="yes" xml:space="preserve">
          <source>We want to make &lt;code&gt;topic&lt;/code&gt; forked from branch &lt;code&gt;master&lt;/code&gt;; for example, because the functionality on which &lt;code&gt;topic&lt;/code&gt; depends was merged into the more stable &lt;code&gt;master&lt;/code&gt; branch. We want our tree to look like this:</source>
          <target state="translated">我们要使分支 &lt;code&gt;master&lt;/code&gt; 分叉的 &lt;code&gt;topic&lt;/code&gt; ; 例如，因为 &lt;code&gt;topic&lt;/code&gt; 依赖的功能已合并到更稳定的 &lt;code&gt;master&lt;/code&gt; 分支中。我们希望我们的树看起来像这样：</target>
        </trans-unit>
        <trans-unit id="0fa006b18282abd83f954d3423dfd83f70f68c0d" translate="yes" xml:space="preserve">
          <source>We will introduce some tools that can help you do this, explain how to use them, and then explain some of the problems that can arise because you are rewriting history.</source>
          <target state="translated">我们将介绍一些可以帮助你做到这一点的工具,解释如何使用它们,然后解释一些因为你正在改写历史而可能出现的问题。</target>
        </trans-unit>
        <trans-unit id="e34d86d215639adac5ecaa74d7f70d803a2ef9de" translate="yes" xml:space="preserve">
          <source>We will sometimes represent Git history using diagrams like the one below. Commits are shown as &quot;o&quot;, and the links between them with lines drawn with - / and \. Time goes left to right:</source>
          <target state="translated">我们有时会用下面这样的图来表示 Git 的历史。承诺用 &quot;o &quot;表示,它们之间的联系用-/和\画出的线表示。时间从左到右。</target>
        </trans-unit>
        <trans-unit id="ab9fd84ced67b4e6059fb12091ba4144199c5397" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll assume that the problem is a single missing or corrupted blob, which is sometimes a solvable problem. (Recovering missing trees and especially commits is &lt;strong&gt;much&lt;/strong&gt; harder).</source>
          <target state="translated">我们假设问题是单个丢失或损坏的斑点，有时这是一个可以解决的问题。（恢复丢失的树，尤其是提交&lt;strong&gt;要&lt;/strong&gt;困难得多）。</target>
        </trans-unit>
        <trans-unit id="2aa7b1ec194976812ce4b6b3f7e0ba34eba549a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll keep this simple and stupid, so we&amp;rsquo;ll start off with populating a few trivial files just to get a feel for it.</source>
          <target state="translated">我们将使这个简单而愚蠢的事情变得如此，因此我们将从填充一些琐碎的文件开始，只是为了对此有所了解。</target>
        </trans-unit>
        <trans-unit id="2d4db37414a68811cd95f44af4830929ada62273" translate="yes" xml:space="preserve">
          <source>Webserver configuration</source>
          <target state="translated">网络服务器配置</target>
        </trans-unit>
        <trans-unit id="c0f36d74c982d11ffbdfaa17b6ab39308ec52a2f" translate="yes" xml:space="preserve">
          <source>Webserver configuration with multiple projects' root</source>
          <target state="translated">用多个项目的根配置Webserver</target>
        </trans-unit>
        <trans-unit id="ef6d4f2b2672206d0b50ce512c5b9cc1369fe95f" translate="yes" xml:space="preserve">
          <source>What an alias file in each format looks like can be found in the documentation of the email program of the same name. The differences and limitations from the standard formats are described below:</source>
          <target state="translated">每种格式的别名文件是什么样的,可以在同名电子邮件程序的文档中找到。与标准格式的区别和限制在下面描述。</target>
        </trans-unit>
        <trans-unit id="fa6325f935566c907b8b84855ddf6b390a1827e3" translate="yes" xml:space="preserve">
          <source>What are the 7 digits of hex that Git responded to the commit with?</source>
          <target state="translated">Git响应提交的7位十六进制数字是什么?</target>
        </trans-unit>
        <trans-unit id="1fd975aafde95925b137d84d61ec01ca393e6fe1" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;http.postBuffer&lt;/code&gt; really do?</source>
          <target state="translated">是什么 &lt;code&gt;http.postBuffer&lt;/code&gt; 真的？</target>
        </trans-unit>
        <trans-unit id="5fb651419665147da76edfca56099f33ccd0e645" translate="yes" xml:space="preserve">
          <source>What does this mean?</source>
          <target state="translated">这意味着什么?</target>
        </trans-unit>
        <trans-unit id="b77fdbd3385bc488b50aa891b5b4c124304a8f69" translate="yes" xml:space="preserve">
          <source>What is interesting too is that end users that are reporting bugs (or QA people that reproduced a bug) have access to the environment where the bug happens. So they can often more easily reproduce a regression. And if they can bisect, then more information will be extracted from the environment where the bug happens, which means that it will be easier to understand and then fix the bug.</source>
          <target state="translated">同样有趣的是,报告bug的最终用户(或重现bug的QA人员)可以访问bug发生的环境。所以他们往往可以更容易地重现一个回归。而如果他们能够一分为二,那么就会从bug发生的环境中提取更多的信息,这意味着会更容易理解然后修复bug。</target>
        </trans-unit>
        <trans-unit id="90fc9e2a4fe1cfe396d558392d2a0a41db650977" translate="yes" xml:space="preserve">
          <source>What kinds of problems can occur when merging long-lived branches with squash merges?</source>
          <target state="translated">长寿枝与瓜菜合并时,会出现什么样的问题?</target>
        </trans-unit>
        <trans-unit id="549056214cd4b23720c4559829b5b36cc5cf6d0c" translate="yes" xml:space="preserve">
          <source>What next?</source>
          <target state="translated">接下来呢?</target>
        </trans-unit>
        <trans-unit id="fe77441e9cc191fb4a5181d6f98e51e7bf6ce4ab" translate="yes" xml:space="preserve">
          <source>What people don&amp;rsquo;t get is that this is a situation where the &quot;end node principle&quot; applies. When you have limited resources (here: developers) you don&amp;rsquo;t push the bulk of the burden upon them. Instead you push things out to the resource you have a lot of, the end nodes (here: users), so that the situation actually scales.</source>
          <target state="translated">人们不明白的是，这种情况适用了&amp;ldquo;端节点原理&amp;rdquo;。当您的资源有限时（此处为开发人员），您不会将大量的负担加在他们身上。取而代之的是将内容推送到您拥有很多资源的终端节点（此处为用户），以便实际扩展情况。</target>
        </trans-unit>
        <trans-unit id="4adfddfda3ea247cced4c30354a360a26072f719" translate="yes" xml:space="preserve">
          <source>What should I put in &lt;code&gt;user.name&lt;/code&gt;?</source>
          <target state="translated">我应该在 &lt;code&gt;user.name&lt;/code&gt; 中输入什么？</target>
        </trans-unit>
        <trans-unit id="e4950cd435094a3f200db11a5c1b540d80d04769" translate="yes" xml:space="preserve">
          <source>What should you do when you tag a wrong commit and you would want to re-tag?</source>
          <target state="translated">当你标记了一个错误的提交,而你又想重新标记时,你应该怎么做?</target>
        </trans-unit>
        <trans-unit id="049920ec0574fb80b08ccee259e5814b007cd44c" translate="yes" xml:space="preserve">
          <source>What the -p option produces is slightly different from the traditional diff format:</source>
          <target state="translated">-p选项产生的东西与传统的diff格式略有不同。</target>
        </trans-unit>
        <trans-unit id="e27b60d4391d6c41de480e30a2d0df50a6723ae8" translate="yes" xml:space="preserve">
          <source>What to do when a push fails</source>
          <target state="translated">推送失败怎么办</target>
        </trans-unit>
        <trans-unit id="42a1dbf4390cedcf2f183fba444335bae8d5ae11" translate="yes" xml:space="preserve">
          <source>What you chose are then highlighted with &lt;code&gt;*&lt;/code&gt;, like this:</source>
          <target state="translated">然后，您选择的内容将以 &lt;code&gt;*&lt;/code&gt; 突出显示，如下所示：</target>
        </trans-unit>
        <trans-unit id="3ef265c44655b5cf934f7913a368fdf3c53af8a9" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the recommended way to store files in Git?</source>
          <target state="translated">在Git中存储文件的推荐方式是什么？</target>
        </trans-unit>
        <trans-unit id="e11a716b5dc9d27d9966b39b2c63b32b4c67e627" translate="yes" xml:space="preserve">
          <source>When &amp;lt;rev&amp;gt; is not specified, the command annotates the changes starting backwards from the working tree copy. This flag makes the command pretend as if the working tree copy has the contents of the named file (specify &lt;code&gt;-&lt;/code&gt; to make the command read from the standard input).</source>
          <target state="translated">如果未指定&amp;lt;rev&amp;gt;，则该命令注释从工作树副本向后开始的更改。该标志使命令假装为好像工作树副本具有命名文件的内容（指定 &lt;code&gt;-&lt;/code&gt; 使命令从标准输入中读取）。</target>
        </trans-unit>
        <trans-unit id="df8212af8d2323e7260f5fa3c4bc0bbc714643ff" translate="yes" xml:space="preserve">
          <source>When --fork-point is active, &lt;code&gt;fork_point&lt;/code&gt; will be used instead of &amp;lt;upstream&amp;gt; to calculate the set of commits to rebase, where &lt;code&gt;fork_point&lt;/code&gt; is the result of &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt;
&amp;lt;branch&amp;gt;&lt;/code&gt; command (see &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt;). If &lt;code&gt;fork_point&lt;/code&gt; ends up being empty, the &amp;lt;upstream&amp;gt; will be used as a fallback.</source>
          <target state="translated">当--fork-point处于活动状态时，将使用 &lt;code&gt;fork_point&lt;/code&gt; 而不是&amp;lt;upstream&amp;gt;来计算要变基的提交集，其中 &lt;code&gt;fork_point&lt;/code&gt; 是 &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt; 命令的结果（参见&lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]&lt;/a&gt;）。如果 &lt;code&gt;fork_point&lt;/code&gt; 最终为空，则&amp;lt;upstream&amp;gt;将用作后备。</target>
        </trans-unit>
        <trans-unit id="0b903c4e9a3738f389f65549fe23dcd21fd8909d" translate="yes" xml:space="preserve">
          <source>When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; is specified, it is the string that will be shown instead of the default one.</source>
          <target state="translated">当不使用--graph时，所有历史分支均被展平，这使得很难看到两个连续的提交不属于线性分支。在这种情况下，此选项在它们之间设置了障碍。如果指定了 &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; ，它将显示的是字符串，而不是默认的字符串。</target>
        </trans-unit>
        <trans-unit id="24ff3c267435a7dcecd3166ed52f8210a7c7f0de" translate="yes" xml:space="preserve">
          <source>When --stdout is specified then progress report is displayed during the object count and compression phases but inhibited during the write-out phase. The reason is that in some cases the output stream is directly linked to another command which may wish to display progress status of its own as it processes incoming pack data. This flag is like --progress except that it forces progress report for the write-out phase as well even if --stdout is used.</source>
          <target state="translated">当指定-stdout时,在对象计数和压缩阶段会显示进度报告,但在写入输出阶段会被禁止。原因是在某些情况下,输出流直接连接到另一个命令,而另一个命令可能希望在处理输入的数据包时显示自己的进度状态。这个标志和--progress一样,只是即使使用--stdout,它也会强制写入输出阶段的进度报告。</target>
        </trans-unit>
        <trans-unit id="d3e80ca53bd7d57db503ac84208eff0dbe6d901f" translate="yes" xml:space="preserve">
          <source>When -k is not in effect, all leading strings bracketed with &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; pairs are stripped. This option limits the stripping to only the pairs whose bracketed string contains the word &quot;PATCH&quot;.</source>
          <target state="translated">当-k无效时，将删除所有用 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 对括起来的前导字符串。此选项将剥离仅限于括号中的字符串包含单词&amp;ldquo; PATCH&amp;rdquo;的对。</target>
        </trans-unit>
        <trans-unit id="882475218cb0a9fc17e76a3d4266386adec5dd71" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;$@&quot;&lt;/code&gt; is &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; in the above example, the following usage text would be shown:</source>
          <target state="translated">在上面的示例中，当 &lt;code&gt;&quot;$@&quot;&lt;/code&gt; 为 &lt;code&gt;-h&lt;/code&gt; 或 &lt;code&gt;--help&lt;/code&gt; 时，将显示以下用法文本：</target>
        </trans-unit>
        <trans-unit id="d78a0cbb0812363470a0c64a4a94d40dd1da90bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--batch-all-objects&lt;/code&gt; is in use, visit objects in an order which may be more efficient for accessing the object contents than hash order. The exact details of the order are unspecified, but if you do not require a specific order, this should generally result in faster output, especially with &lt;code&gt;--batch&lt;/code&gt;. Note that &lt;code&gt;cat-file&lt;/code&gt; will still show each object only once, even if it is stored multiple times in the repository.</source>
          <target state="translated">当使用 &lt;code&gt;--batch-all-objects&lt;/code&gt; 时，以比散列顺序更有效的方式访问对象，以访问对象内容的顺序。该命令的确切详细信息尚未指定，但是如果您不需要特定的命令，则通常应能提高输出速度，尤其是使用 &lt;code&gt;--batch&lt;/code&gt; 时。请注意，即使 &lt;code&gt;cat-file&lt;/code&gt; 多次存储在存储库中，cat-file仍只会显示每个对象一次。</target>
        </trans-unit>
        <trans-unit id="95919047a579b82415a0ddd6c6f601bfbb7dc80f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--check&lt;/code&gt; is in effect, or when applying the patch (which is the default when none of the options that disables it is in effect), make sure the patch is applicable to what the current index file records. If the file to be patched in the working tree is not up to date, it is flagged as an error. This flag also causes the index file to be updated.</source>
          <target state="translated">当 &lt;code&gt;--check&lt;/code&gt; 生效时，或在应用补丁程序时（这是所有禁用它的选项都没有生效的默认设置），请确保该补丁程序适用于当前索引文件记录的内容。如果要在工作树中修补的文件不是最新的，则将其标记为错误。此标志还导致索引文件被更新。</target>
        </trans-unit>
        <trans-unit id="526cf7ed548b3415806841ff6b0e065a944a8f5e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--compose&lt;/code&gt; is used, git send-email will use the From, Subject, and In-Reply-To headers specified in the message. If the body of the message (what you type after the headers and a blank line) only contains blank (or Git: prefixed) lines, the summary won&amp;rsquo;t be sent, but From, Subject, and In-Reply-To headers will be used unless they are removed.</source>
          <target state="translated">当使用 &lt;code&gt;--compose&lt;/code&gt; 时，git send-email将使用消息中指定的From，Subject和In-Reply-To标头。如果邮件的正文（在标题和空白行之后键入的内容）仅包含空白行（或Git：带前缀的行），则不会发送摘要，但发件人，主题和In-Reply-To标头除非将其删除，否则将被使用。</target>
        </trans-unit>
        <trans-unit id="46dc43993fdd7156fca21e87a205fc0f333f2d9a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--cone&lt;/code&gt; is provided, the &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; setting is also set, allowing for better performance with a limited set of patterns (see &lt;code&gt;CONE PATTERN SET&lt;/code&gt; below).</source>
          <target state="translated">当 &lt;code&gt;--cone&lt;/code&gt; 被提供时， &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; 设置也被设定，允许与有限的一组图形（见更好的性能 &lt;code&gt;CONE PATTERN SET&lt;/code&gt; 下文）。</target>
        </trans-unit>
        <trans-unit id="ac6d168ca5e25a70ab78d5a850025a2ad07d998b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--exclude&lt;/code&gt; and &lt;code&gt;--include&lt;/code&gt; patterns are used, they are examined in the order they appear on the command line, and the first match determines if a patch to each path is used. A patch to a path that does not match any include/exclude pattern is used by default if there is no include pattern on the command line, and ignored if there is any include pattern.</source>
          <target state="translated">使用 &lt;code&gt;--exclude&lt;/code&gt; 和 &lt;code&gt;--include&lt;/code&gt; 模式时，将按照它们在命令行中出现的顺序进行检查，并且第一个匹配项确定是否使用了每个路径的补丁。如果命令行上没有包含模式，则默认使用与任何包含/排除模式都不匹配的路径的补丁程序；如果存在任何包含模式，则将忽略该补丁。</target>
        </trans-unit>
        <trans-unit id="febfb7b902fc970c3396f3068a5c66e59c7ec8ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--notes&lt;/code&gt; is in effect, the message from the notes is matched as if it were part of the log message.</source>
          <target state="translated">当 &lt;code&gt;--notes&lt;/code&gt; 生效时，便笺中的消息将被匹配，就好像它是日志消息的一部分一样。</target>
        </trans-unit>
        <trans-unit id="b84c74a91c715b3bf1b4e927529a07a15aed9721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--numstat&lt;/code&gt; has been given, do not munge pathnames, but use a NUL-terminated machine-readable format.</source>
          <target state="translated">当 &lt;code&gt;--numstat&lt;/code&gt; 已给出，不Munge时间路径名，而是用一个NULL结尾的机器可读的格式。</target>
        </trans-unit>
        <trans-unit id="d371e700585c518084c33d84fef0af43b13c3439" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt; or &lt;code&gt;--name-status&lt;/code&gt; has been given, do not munge pathnames and use NULs as output field terminators.</source>
          <target state="translated">当 &lt;code&gt;--raw&lt;/code&gt; ， &lt;code&gt;--numstat&lt;/code&gt; ， &lt;code&gt;--name-only&lt;/code&gt; 或 &lt;code&gt;--name-status&lt;/code&gt; 已经给出，不Munge时间路径名，并使用完全无效的输出字段终止符。</target>
        </trans-unit>
        <trans-unit id="e163d548a1a886a531d60736c2ba3e851388a10a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--root&lt;/code&gt; is specified the initial commit will be shown as a big creation event. This is equivalent to a diff against the NULL tree.</source>
          <target state="translated">当 &lt;code&gt;--root&lt;/code&gt; 指定初始提交将显示为一个大的创建事件。这等效于对NULL树的差异。</target>
        </trans-unit>
        <trans-unit id="8183759ad974b12070a46362dbaa27565534e645" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--show-pulls&lt;/code&gt; is paired with &lt;code&gt;--simplify-merges&lt;/code&gt;, the graph includes all of the necessary information:</source>
          <target state="translated">当 &lt;code&gt;--show-pulls&lt;/code&gt; 与 &lt;code&gt;--simplify-merges&lt;/code&gt; 配对时，该图包括所有必要的信息：</target>
        </trans-unit>
        <trans-unit id="5b88ba2b22685842fbd9b8b75fb2959da8ea9e8b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--stdin&lt;/code&gt; is specified, the command does not take &amp;lt;tree-ish&amp;gt; arguments from the command line. Instead, it reads lines containing either two &amp;lt;tree&amp;gt;, one &amp;lt;commit&amp;gt;, or a list of &amp;lt;commit&amp;gt; from its standard input. (Use a single space as separator.)</source>
          <target state="translated">当 &lt;code&gt;--stdin&lt;/code&gt; 被指定时，该命令不采取从命令行&amp;lt;树肥胖型&amp;gt;参数。而是从其标准输入中读取包含两个&amp;lt;tree&amp;gt;，一个&amp;lt;commit&amp;gt;或&amp;lt;commit&amp;gt;列表的行。（使用单个空格作为分隔符。）</target>
        </trans-unit>
        <trans-unit id="c23ac888d8fe422c1532e2aed10782043e7c6859" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--temp&lt;/code&gt; is used (or implied by &lt;code&gt;--stage=all&lt;/code&gt;) &lt;code&gt;git checkout-index&lt;/code&gt; will create a temporary file for each index entry being checked out. The index will not be updated with stat information. These options can be useful if the caller needs all stages of all unmerged entries so that the unmerged files can be processed by an external merge tool.</source>
          <target state="translated">当使用 &lt;code&gt;--temp&lt;/code&gt; （或由 &lt;code&gt;--stage=all&lt;/code&gt; 隐含）时， &lt;code&gt;git checkout-index&lt;/code&gt; 将为每个被检出的索引条目创建一个临时文件。该索引将不会使用统计信息进行更新。如果调用者需要所有未合并条目的所有阶段，以便外部合并工具可以处理未合并文件，则这些选项很有用。</target>
        </trans-unit>
        <trans-unit id="5c97ac9560dda79ead627bde39274f79b6e5dd8a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; are used without &lt;code&gt;--pickaxe-all&lt;/code&gt;, only filepairs that match their respective criterion are kept in the output. When &lt;code&gt;--pickaxe-all&lt;/code&gt; is used, if even one filepair matches their respective criterion in a changeset, the entire changeset is kept. This behavior is designed to make reviewing changes in the context of the whole changeset easier.</source>
          <target state="translated">在不带 &lt;code&gt;--pickaxe-all&lt;/code&gt; 的情况下使用 &lt;code&gt;-S&lt;/code&gt; 或 &lt;code&gt;-G&lt;/code&gt; 时，仅匹配其各自标准的文件对将保留在输出中。当使用 &lt;code&gt;--pickaxe-all&lt;/code&gt; 时，即使在变更集中一个文件对也符合其各自的标准，整个变更集也会保留。此行为旨在使在整个变更集的上下文中更轻松地检查变更。</target>
        </trans-unit>
        <trans-unit id="b7230470efbcbdb8b4c76cdcdcf3272fde68030f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; finds a change, show all the changes in that changeset, not just the files that contain the change in &amp;lt;string&amp;gt;.</source>
          <target state="translated">当 &lt;code&gt;-S&lt;/code&gt; 或 &lt;code&gt;-G&lt;/code&gt; 找到更改时，请显示该更改集中的所有更改，而不仅仅是显示&amp;lt;string&amp;gt;中包含更改的文件。</target>
        </trans-unit>
        <trans-unit id="b52ce403c26e2631158c50ee6bd3c17065ed82dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-u&lt;/code&gt; option is not used, untracked files and directories are shown (i.e. the same as specifying &lt;code&gt;normal&lt;/code&gt;), to help you avoid forgetting to add newly created files. Because it takes extra work to find untracked files in the filesystem, this mode may take some time in a large working tree. Consider enabling untracked cache and split index if supported (see &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; and &lt;code&gt;git update-index
--split-index&lt;/code&gt;), Otherwise you can use &lt;code&gt;no&lt;/code&gt; to have &lt;code&gt;git status&lt;/code&gt; return more quickly without showing untracked files.</source>
          <target state="translated">如果不使用 &lt;code&gt;-u&lt;/code&gt; 选项，则会显示未跟踪的文件和目录（即与指定 &lt;code&gt;normal&lt;/code&gt; 相同），以帮助您避免忘记添加新创建的文件。因为在文件系统中查找未跟踪的文件需要额外的工作，所以此模式在大型工作树中可能需要一些时间。如果支持，请考虑启用未跟踪的缓存和拆分索引（请参阅 &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; 和 &lt;code&gt;git update-index --split-index&lt;/code&gt; ），否则，可以使用 &lt;code&gt;no&lt;/code&gt; 来使 &lt;code&gt;git status&lt;/code&gt; 更快地返回，而不会显示未跟踪的文件。</target>
        </trans-unit>
        <trans-unit id="97c7c816e31485397947c4cd78f79e742f80ec39" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-z&lt;/code&gt; output option is in effect, the output is formatted this way:</source>
          <target state="translated">当 &lt;code&gt;-z&lt;/code&gt; output选项生效时，以这种方式格式化输出：</target>
        </trans-unit>
        <trans-unit id="2bf71954fc8fac90c9030e3b9b1232971580d22a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;FETCH_HEAD&lt;/code&gt; (and no other commit) is specified, the branches recorded in the &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; file by the previous invocation of &lt;code&gt;git fetch&lt;/code&gt; for merging are merged to the current branch.</source>
          <target state="translated">当 &lt;code&gt;FETCH_HEAD&lt;/code&gt; （并且没有其他提交）时，通过先前调用 &lt;code&gt;git fetch&lt;/code&gt; 进行合并而记录在 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 文件中的分支将合并到当前分支。</target>
        </trans-unit>
        <trans-unit id="30aaf2e9dd06a0335c5f1cb4c0791345a6730170" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled, the input list is considered a list of directories instead of sparse-checkout patterns. The command writes patterns to the sparse-checkout file to include all files contained in those directories (recursively) as well as files that are siblings of ancestor directories. The input format matches the output of &lt;code&gt;git ls-tree --name-only&lt;/code&gt;. This includes interpreting pathnames that begin with a double quote (&quot;) as C-style quoted strings.</source>
          <target state="translated">当 &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; 启用，输入列表被认为是目录，而不是稀疏结账模式的列表。该命令将模式写入稀疏检出文件，以包括（递归地）包含在那些目录中的所有文件以及作为祖先目录的同级文件。输入格式与 &lt;code&gt;git ls-tree --name-only&lt;/code&gt; 的输出匹配。这包括将以双引号（&amp;ldquo;）开头的路径名解释为C样式的带引号的字符串。</target>
        </trans-unit>
        <trans-unit id="a79eb2995cdbf5e2d0a3c4b4e62d970b5798ea30" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; is enabled, the config file &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; is read after &lt;code&gt;.git/config&lt;/code&gt; is.</source>
          <target state="translated">当 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 被启用，则配置文件 &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; 之后读取 &lt;code&gt;.git/config&lt;/code&gt; IS。</target>
        </trans-unit>
        <trans-unit id="093107f57324ea8ddf834562dc5da735634ce1c2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.fsckObjects&lt;/code&gt; or &lt;code&gt;receive.fsckObjects&lt;/code&gt; are not set, the value of this variable is used instead. Defaults to false.</source>
          <target state="translated">当未设置 &lt;code&gt;fetch.fsckObjects&lt;/code&gt; 或 &lt;code&gt;receive.fsckObjects&lt;/code&gt; 时，将使用此变量的值。默认为false。</target>
        </trans-unit>
        <trans-unit id="f0f4e4ab298d72d3ce878991ffe1cd2532ffab74" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.unpackLimit&lt;/code&gt; or &lt;code&gt;receive.unpackLimit&lt;/code&gt; are not set, the value of this variable is used instead. The default value is 100.</source>
          <target state="translated">当未设置 &lt;code&gt;fetch.unpackLimit&lt;/code&gt; 或 &lt;code&gt;receive.unpackLimit&lt;/code&gt; 时，将使用此变量的值。默认值为100。</target>
        </trans-unit>
        <trans-unit id="0f43e1a31ad9e45784cdafec68b8141e1a628402" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; is set, errors can be switched to warnings and vice versa by configuring the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; setting where the &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; is the fsck message ID and the value is one of &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;. For convenience, fsck prefixes the error/warning with the message ID, e.g. &quot;missingEmail: invalid author/committer line - missing email&quot; means that setting &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; will hide that issue.</source>
          <target state="translated">设置 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ，可以通过配置 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 设置将错误切换为警告，反之亦然，其中 &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; 是fsck消息ID，值是 &lt;code&gt;error&lt;/code&gt; 之一。， &lt;code&gt;warn&lt;/code&gt; 或 &lt;code&gt;ignore&lt;/code&gt; 。为了方便起见，fsck在错误/警告之前添加了消息ID，例如&amp;ldquo; missingEmail：无效的作者/提交者行-缺少电子邮件&amp;rdquo;表示设置 &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; 将隐藏该问题。</target>
        </trans-unit>
        <trans-unit id="ce3f108ee8253a42ecb067bc1a011bcbcd3ad290" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git apply&lt;/code&gt; is used as a &quot;better GNU patch&quot;, the user can pass the &lt;code&gt;--unsafe-paths&lt;/code&gt; option to override this safety check. This option has no effect when &lt;code&gt;--index&lt;/code&gt; or &lt;code&gt;--cached&lt;/code&gt; is in use.</source>
          <target state="translated">当 &lt;code&gt;git apply&lt;/code&gt; 用作&amp;ldquo;更好的GNU补丁&amp;rdquo;时，用户可以通过 &lt;code&gt;--unsafe-paths&lt;/code&gt; 选项来覆盖此安全检查。使用 &lt;code&gt;--index&lt;/code&gt; 或 &lt;code&gt;--cached&lt;/code&gt; 时，此选项无效。</target>
        </trans-unit>
        <trans-unit id="dea5ce8f581717a21d1ee89e4952655599f11488" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git difftool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;diff.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with the following variables available: &lt;code&gt;$LOCAL&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff pre-image and &lt;code&gt;$REMOTE&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff post-image. &lt;code&gt;$MERGED&lt;/code&gt; is the name of the file which is being compared. &lt;code&gt;$BASE&lt;/code&gt; is provided for compatibility with custom merge tool commands and has the same value as &lt;code&gt;$MERGED&lt;/code&gt;.</source>
          <target state="translated">当使用此工具（通过 &lt;code&gt;-t&lt;/code&gt; 或 &lt;code&gt;--tool&lt;/code&gt; 选项或 &lt;code&gt;diff.tool&lt;/code&gt; 配置变量）调用 &lt;code&gt;git difftool&lt;/code&gt; 时,将使用以下可用变量调用已配置的命令行： &lt;code&gt;$LOCAL&lt;/code&gt; 设置为临时名称包含差异前映像内容和 &lt;code&gt;$REMOTE&lt;/code&gt; 被设置为包含差异后映像内容的临时文件的名称。 &lt;code&gt;$MERGED&lt;/code&gt; 是要比较的文件的名称。提供 &lt;code&gt;$BASE&lt;/code&gt; 是为了与自定义合并工具命令兼容，并且具有与 &lt;code&gt;$MERGED&lt;/code&gt; 相同的值。</target>
        </trans-unit>
        <trans-unit id="02bc7953c8eb819402a97fdb05db86103d3e94f0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run with explicit branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin master&lt;/code&gt;, the &amp;lt;refspec&amp;gt;s given on the command line determine what are to be fetched (e.g. &lt;code&gt;master&lt;/code&gt; in the example, which is a short-hand for &lt;code&gt;master:&lt;/code&gt;, which in turn means &quot;fetch the &lt;code&gt;master&lt;/code&gt; branch but I do not explicitly say what remote-tracking branch to update with it from the command line&quot;), and the example command will fetch &lt;code&gt;only&lt;/code&gt; the &lt;code&gt;master&lt;/code&gt; branch. The &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values determine which remote-tracking branch, if any, is updated. When used in this way, the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values do not have any effect in deciding &lt;code&gt;what&lt;/code&gt; gets fetched (i.e. the values are not used as refspecs when the command-line lists refspecs); they are only used to decide &lt;code&gt;where&lt;/code&gt; the refs that are fetched are stored by acting as a mapping.</source>
          <target state="translated">当 &lt;code&gt;git fetch&lt;/code&gt; 与显式分支和/或标记一起运行以在命令行上进行获取时，例如 &lt;code&gt;git fetch origin master&lt;/code&gt; ，命令行上给出的&amp;lt;refspec&amp;gt;确定要获取的内容（例如，示例中的 &lt;code&gt;master&lt;/code&gt; ，即短手的 &lt;code&gt;master:&lt;/code&gt; ，这反过来又意味着&amp;ldquo;取 &lt;code&gt;master&lt;/code&gt; 分支，但我并没有明确说什么远程跟踪分支的命令行与它更新&amp;rdquo;），示例命令将获取 &lt;code&gt;only&lt;/code&gt; 的 &lt;code&gt;master&lt;/code&gt; 分支。所述 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 值确定哪个远程跟踪分支，如果有的话，将被更新。以这种方式使用时，将使用 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 值对确定 &lt;code&gt;what&lt;/code&gt; 获取的内容没有任何影响（即，当命令行列出refspecs时，这些值不用作refspecs）；它们仅用于决定 &lt;code&gt;where&lt;/code&gt; 是取出裁判被用作映射存储。</target>
        </trans-unit>
        <trans-unit id="d3bb27ea8d5739147518646e08d478432b5ac353" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run without specifying what branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values are used as the refspecs&amp;mdash;​they specify which refs to fetch and which local refs to update. The example above will fetch all branches that exist in the &lt;code&gt;origin&lt;/code&gt; (i.e. any ref that matches the left-hand side of the value, &lt;code&gt;refs/heads/*&lt;/code&gt;) and update the corresponding remote-tracking branches in the &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; hierarchy.</source>
          <target state="translated">在运行 &lt;code&gt;git fetch&lt;/code&gt; 时未指定要在命令行上提取的分支和/或标签的情况下，例如 &lt;code&gt;git fetch origin&lt;/code&gt; 或 &lt;code&gt;git fetch&lt;/code&gt; ， &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 值用作refspecs-它们指定要提取和提取的ref哪个本地参考要更新。上面的示例将获取 &lt;code&gt;origin&lt;/code&gt; 中存在的所有分支（即，与值的左侧匹配的所有ref &lt;code&gt;refs/heads/*&lt;/code&gt; ），并更新 &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; 中的相应远程跟踪分支。层次结构。</target>
        </trans-unit>
        <trans-unit id="6bfc306f6ccec6cbac00c82d44f7befe47671739" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part below. This option overrides that check.</source>
          <target state="translated">当 &lt;code&gt;git fetch&lt;/code&gt; 与 &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec一起使用时，它可能会拒绝更新本地分支，如下面的 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 部分所述。此选项将覆盖该检查。</target>
        </trans-unit>
        <trans-unit id="b8a0a18f13c1248a211519fc4b6c3ee775403075" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part of the &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; documentation. This option overrides that check.</source>
          <target state="translated">当 &lt;code&gt;git fetch&lt;/code&gt; 与 &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec一起使用时，它可能会拒绝更新本地分支，如&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;文档的 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 部分所述。此选项将覆盖该检查。</target>
        </trans-unit>
        <trans-unit id="946d45913d1a6d20975808ddb9f4de7a3a592055" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it calls &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt;. This config variable can be used to set a different grace period. The value &quot;now&quot; may be used to disable the grace period and prune &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; immediately, or &quot;never&quot; may be used to suppress pruning.</source>
          <target state="translated">当 &lt;code&gt;git gc&lt;/code&gt; 运行时，它会调用 &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt; 。此配置变量可用于设置不同的宽限期。值&amp;ldquo; now&amp;rdquo;可用于禁用宽限期并立即修剪 &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; ，或&amp;ldquo; never&amp;rdquo;可用于禁止修剪。</target>
        </trans-unit>
        <trans-unit id="bdaf9b565f5bc5effacd5e94ca1e6e23df9c9f7a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it will call &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt;. Override the grace period with this config variable. The value &quot;now&quot; may be used to disable this grace period and always prune unreachable objects immediately, or &quot;never&quot; may be used to suppress pruning. This feature helps prevent corruption when &lt;code&gt;git gc&lt;/code&gt; runs concurrently with another process writing to the repository; see the &quot;NOTES&quot; section of &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">当 &lt;code&gt;git gc&lt;/code&gt; 运行时，它会调用 &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt; 。使用此配置变量覆盖宽限期。值&amp;ldquo; now&amp;rdquo;可用于禁用此宽限期，并始终立即修剪不可达的对象，或者&amp;ldquo; never&amp;rdquo;可用于禁止修剪。当 &lt;code&gt;git gc&lt;/code&gt; 与另一个写入存储库的进程同时运行时，此功能有助于防止损坏。参见&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;的&amp;ldquo; NOTES&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="9771ab35f0db8c62ffb81b026ac116ab479df958" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git mergetool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;merge.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with &lt;code&gt;$BASE&lt;/code&gt; set to the name of a temporary file containing the common base for the merge, if available; &lt;code&gt;$LOCAL&lt;/code&gt; set to the name of a temporary file containing the contents of the file on the current branch; &lt;code&gt;$REMOTE&lt;/code&gt; set to the name of a temporary file containing the contents of the file to be merged, and &lt;code&gt;$MERGED&lt;/code&gt; set to the name of the file to which the merge tool should write the result of the merge resolution.</source>
          <target state="translated">当 &lt;code&gt;git mergetool&lt;/code&gt; 被调用与此工具（或者通过 &lt;code&gt;-t&lt;/code&gt; 或 &lt;code&gt;--tool&lt;/code&gt; 选项或 &lt;code&gt;merge.tool&lt;/code&gt; 配置变量）所配置的命令行将与被调用 &lt;code&gt;$BASE&lt;/code&gt; 设定为包含在共用基座的临时文件的名称合并（如果有）； &lt;code&gt;$LOCAL&lt;/code&gt; 设置为包含当前分支上文件内容的临时文件的名称； &lt;code&gt;$REMOTE&lt;/code&gt; 设置为包含要合并文件内容的临时文件的名称，而 &lt;code&gt;$MERGED&lt;/code&gt; 设置为合并工具应向其中写入合并解析结果的文件的名称。</target>
        </trans-unit>
        <trans-unit id="8d649c2a1b515f828b380ed0228639a9abf6f2e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-difftool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default diff tool will be read from the configured &lt;code&gt;diff.guitool&lt;/code&gt; variable instead of &lt;code&gt;diff.tool&lt;/code&gt;. The &lt;code&gt;--no-gui&lt;/code&gt; option can be used to override this setting. If &lt;code&gt;diff.guitool&lt;/code&gt; is not set, we will fallback in the order of &lt;code&gt;merge.guitool&lt;/code&gt;, &lt;code&gt;diff.tool&lt;/code&gt;, &lt;code&gt;merge.tool&lt;/code&gt; until a tool is found.</source>
          <target state="translated">当使用 &lt;code&gt;-g&lt;/code&gt; 或 &lt;code&gt;--gui&lt;/code&gt; 选项调用 &lt;code&gt;git-difftool&lt;/code&gt; 时,将从配置的 &lt;code&gt;diff.guitool&lt;/code&gt; 变量而不是 &lt;code&gt;diff.tool&lt;/code&gt; 中读取默认的diff工具。该 &lt;code&gt;--no-gui&lt;/code&gt; 选项可用于覆盖此设置。如果 &lt;code&gt;diff.guitool&lt;/code&gt; 没有设置，我们将在顺序后备 &lt;code&gt;merge.guitool&lt;/code&gt; ， &lt;code&gt;diff.tool&lt;/code&gt; ， &lt;code&gt;merge.tool&lt;/code&gt; 直到工具中找到。</target>
        </trans-unit>
        <trans-unit id="dab1778e78eece39a70fe4959b77fef05af95366" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-mergetool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default merge tool will be read from the configured &lt;code&gt;merge.guitool&lt;/code&gt; variable instead of &lt;code&gt;merge.tool&lt;/code&gt;. If &lt;code&gt;merge.guitool&lt;/code&gt; is not set, we will fallback to the tool configured under &lt;code&gt;merge.tool&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;git-mergetool&lt;/code&gt; 与调用 &lt;code&gt;-g&lt;/code&gt; 或 &lt;code&gt;--gui&lt;/code&gt; 选项默认合并工具会从配置的读取 &lt;code&gt;merge.guitool&lt;/code&gt; 变量，而不是 &lt;code&gt;merge.tool&lt;/code&gt; 。如果 &lt;code&gt;merge.guitool&lt;/code&gt; 没有设置，我们将回退到下配置的工具 &lt;code&gt;merge.tool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55d1f905322639499a3e0c7d64b920e915841fa1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;group&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), the repository is made shareable between several users in a group (making sure all the files and objects are group-writable). When &lt;code&gt;all&lt;/code&gt; (or &lt;code&gt;world&lt;/code&gt; or &lt;code&gt;everybody&lt;/code&gt;), the repository will be readable by all users, additionally to being group-shareable. When &lt;code&gt;umask&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;), Git will use permissions reported by umask(2). When &lt;code&gt;0xxx&lt;/code&gt;, where &lt;code&gt;0xxx&lt;/code&gt; is an octal number, files in the repository will have this mode value. &lt;code&gt;0xxx&lt;/code&gt; will override user&amp;rsquo;s umask value (whereas the other options will only override requested parts of the user&amp;rsquo;s umask value). Examples: &lt;code&gt;0660&lt;/code&gt; will make the repo read/write-able for the owner and group, but inaccessible to others (equivalent to &lt;code&gt;group&lt;/code&gt; unless umask is e.g. &lt;code&gt;0022&lt;/code&gt;). &lt;code&gt;0640&lt;/code&gt; is a repository that is group-readable but not group-writable. See &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;. False by default.</source>
          <target state="translated">如果为 &lt;code&gt;group&lt;/code&gt; （或 &lt;code&gt;true&lt;/code&gt; ），则使存储库在一个组中的多个用户之间可共享（确保所有文件和对象都是可写的）。当 &lt;code&gt;all&lt;/code&gt; （或 &lt;code&gt;world&lt;/code&gt; 或 &lt;code&gt;everybody&lt;/code&gt; ）时，除了可以组共享之外，所有用户都可以读取该存储库。当 &lt;code&gt;umask&lt;/code&gt; （或 &lt;code&gt;false&lt;/code&gt; ）时，Git将使用umask（2）报告的权限。当 &lt;code&gt;0xxx&lt;/code&gt; ，其中 &lt;code&gt;0xxx&lt;/code&gt; 是一个八进制数时，存储库中的文件将具有此模式值。 &lt;code&gt;0xxx&lt;/code&gt; 将覆盖用户的umask值（而其他选项将仅覆盖用户的umask值的请求部分）。例子： &lt;code&gt;0660&lt;/code&gt; 将使所有者和组可以读取/写入该存储库，但其他用户则无法访问该存储库（除非umask例如 &lt;code&gt;0022&lt;/code&gt; ,否则等效于 &lt;code&gt;group&lt;/code&gt; ）。 &lt;code&gt;0640&lt;/code&gt; 是可组读取但不可组写入的存储库。参见&lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt;。默认为False。</target>
        </trans-unit>
        <trans-unit id="0c640b1443fdc376fb0e05e5b19871e0f70bfa75" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;interactive&lt;/code&gt;, enable the interactive mode of rebase.</source>
          <target state="translated">当 &lt;code&gt;interactive&lt;/code&gt; ，使底垫的交互模式。</target>
        </trans-unit>
        <trans-unit id="fe63008459e29ff8faa8d062c0d12daf6ea858b2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;konqueror&lt;/code&gt; is specified by a command-line option or a configuration variable, we launch &lt;code&gt;kfmclient&lt;/code&gt; to try to open the HTML man page on an already opened konqueror in a new tab if possible.</source>
          <target state="translated">当通过命令行选项或配置变量指定 &lt;code&gt;konqueror&lt;/code&gt; 时，我们将启动 &lt;code&gt;kfmclient&lt;/code&gt; 尝试在新选项卡中打开已打开的konqueror上的HTML手册页。</target>
        </trans-unit>
        <trans-unit id="0e5d1d0d5309f291d73a19a6f71347b59d761978" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;konqueror&lt;/code&gt; is specified in the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable, we launch &lt;code&gt;kfmclient&lt;/code&gt; to try to open the man page on an already opened konqueror in a new tab if possible.</source>
          <target state="translated">当 &lt;code&gt;konqueror&lt;/code&gt; 在指定 &lt;code&gt;man.viewer&lt;/code&gt; 配置变量，我们推出 &lt;code&gt;kfmclient&lt;/code&gt; 尝试，如果能够在新标签中打开一个已经打开的Konqueror手册页。</target>
        </trans-unit>
        <trans-unit id="162b4f89725e01e084b1d2a9bb66f41a211da6f6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;matching&lt;/code&gt; mode is specified, paths that explicitly match an ignored pattern are shown. If a directory matches an ignore pattern, then it is shown, but not paths contained in the ignored directory. If a directory does not match an ignore pattern, but all contents are ignored, then the directory is not shown, but all contents are shown.</source>
          <target state="translated">当 &lt;code&gt;matching&lt;/code&gt; 指定模式，则明确匹配忽略图案路径被示出。如果目录匹配忽略模式，则显示该目录，但不显示忽略目录中包含的路径。如果目录与忽略模式不匹配，但是所有内容都将被忽略，则不会显示目录，但是会显示所有内容。</target>
        </trans-unit>
        <trans-unit id="7ee4878df1abaf60b54059eba9faa52c16598786" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;merges&lt;/code&gt; (or just &lt;code&gt;m&lt;/code&gt;), pass the &lt;code&gt;--rebase-merges&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">当 &lt;code&gt;merges&lt;/code&gt; （或只是 &lt;code&gt;m&lt;/code&gt; ），通过 &lt;code&gt;--rebase-merges&lt;/code&gt; 选项 &lt;code&gt;git rebase&lt;/code&gt; ，以便本地合并提交被包括在变基（见&lt;a href=&quot;git-rebase&quot;&gt;GIT-变基[1]&lt;/a&gt;的详细信息）。</target>
        </trans-unit>
        <trans-unit id="239b51beb1f8c13233881b0568518d58e269df96" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;merges&lt;/code&gt;, pass the &lt;code&gt;--rebase-merges&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">当 &lt;code&gt;merges&lt;/code&gt; ，通过 &lt;code&gt;--rebase-merges&lt;/code&gt; 选项 &lt;code&gt;git rebase&lt;/code&gt; ，以便本地合并提交被包括在变基（见&lt;a href=&quot;git-rebase&quot;&gt;GIT-变基[1]&lt;/a&gt;的详细信息）。</target>
        </trans-unit>
        <trans-unit id="26887709475bb99a484f3550dfcf66463a02ff1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), also pass &lt;code&gt;--preserve-merges&lt;/code&gt; along to &lt;code&gt;git rebase&lt;/code&gt; so that locally committed merge commits will not be flattened by running &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;preserve&lt;/code&gt; （弃用，取而代之的 &lt;code&gt;merges&lt;/code&gt; ），也通过 &lt;code&gt;--preserve-merges&lt;/code&gt; 一起 &lt;code&gt;git rebase&lt;/code&gt; ，使本地提交合并的提交将无法通过运行扁平 &lt;code&gt;git pull&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1aa5ac29106f7e567cb177a446057fe6893dfb3c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserve&lt;/code&gt; (or just &lt;code&gt;p&lt;/code&gt;, deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), also pass &lt;code&gt;--preserve-merges&lt;/code&gt; along to &lt;code&gt;git rebase&lt;/code&gt; so that locally committed merge commits will not be flattened by running &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;preserve&lt;/code&gt; （或只是 &lt;code&gt;p&lt;/code&gt; ，赞成不赞成的 &lt;code&gt;merges&lt;/code&gt; ），也通过 &lt;code&gt;--preserve-merges&lt;/code&gt; 一起 &lt;code&gt;git rebase&lt;/code&gt; ，使本地提交合并的提交将无法通过运行扁平 &lt;code&gt;git pull&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c040d756e251986ff4d930aa40402b774da81b76" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserveUser&lt;/code&gt; is true, &lt;code&gt;git p4&lt;/code&gt; normally dies if it cannot find an author in the p4 user map. This setting submits the change regardless.</source>
          <target state="translated">当 &lt;code&gt;preserveUser&lt;/code&gt; 为true时，如果 &lt;code&gt;git p4&lt;/code&gt; 在p4用户映射中找不到作者，通常会死亡。无论如何，此设置都会提交更改。</target>
        </trans-unit>
        <trans-unit id="f1cb457481e4cab2531cdb48fb2ed70a72c47f80" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;receive-pack&lt;/code&gt; takes in objects, they are placed into a temporary &quot;quarantine&quot; directory within the &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory and migrated into the main object store only after the &lt;code&gt;pre-receive&lt;/code&gt; hook has completed. If the push fails before then, the temporary directory is removed entirely.</source>
          <target state="translated">当 &lt;code&gt;receive-pack&lt;/code&gt; 接收对象时，仅在 &lt;code&gt;pre-receive&lt;/code&gt; 挂钩完成后，它们才会放入 &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; 目录中的临时&amp;ldquo;隔离&amp;rdquo;目录中，并迁移到主对象存储中。如果在此之前推送失败，则将临时目录完全删除。</target>
        </trans-unit>
        <trans-unit id="13eed45e8cb127a4420b06f0b52f497c696b7d45" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; is set to &quot;auto&quot;, the path is marked for automatic end-of-line conversion. If Git decides that the content is text, its line endings are converted to LF on checkin. When the file has been committed with CRLF, no conversion is done.</source>
          <target state="translated">当 &lt;code&gt;text&lt;/code&gt; 设置为&amp;ldquo;自动&amp;rdquo;时，该路径被标记为自动行尾转换。如果Git决定内容为文本，则其行尾在签入时将转换为LF。使用CRLF提交文件后，不会进行任何转换。</target>
        </trans-unit>
        <trans-unit id="2bb8610f0d3f51c94aca7dd51e3603814301750d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text=auto&lt;/code&gt; conversion is enabled in a cross-platform project using push and pull to a central repository the text files containing CRLFs should be normalized.</source>
          <target state="translated">当 &lt;code&gt;text=auto&lt;/code&gt; 转换是一个跨平台的项目中使用推拉到一个中央存储库包含CRLFs文本文件启用进行归一化。</target>
        </trans-unit>
        <trans-unit id="f1b569ad0a0d3f731d90377a830d25de99487fad" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;upload-pack&lt;/code&gt; has started &lt;code&gt;pack-objects&lt;/code&gt;, there may be a quiet period while &lt;code&gt;pack-objects&lt;/code&gt; prepares the pack. Normally it would output progress information, but if &lt;code&gt;--quiet&lt;/code&gt; was used for the fetch, &lt;code&gt;pack-objects&lt;/code&gt; will output nothing at all until the pack data begins. Some clients and networks may consider the server to be hung and give up. Setting this option instructs &lt;code&gt;upload-pack&lt;/code&gt; to send an empty keepalive packet every &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; seconds. Setting this option to 0 disables keepalive packets entirely. The default is 5 seconds.</source>
          <target state="translated">当 &lt;code&gt;upload-pack&lt;/code&gt; 开始 &lt;code&gt;pack-objects&lt;/code&gt; ， &lt;code&gt;pack-objects&lt;/code&gt; 准备打包时可能会有一段安静的时间。通常，它将输出进度信息，但是如果将 &lt;code&gt;--quiet&lt;/code&gt; 用于获取，则在压缩数据开始之前，压缩 &lt;code&gt;pack-objects&lt;/code&gt; 将什么也不输出。一些客户端和网络可能会认为服务器已挂起并放弃。设置此选项将指示 &lt;code&gt;upload-pack&lt;/code&gt; 每隔 &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; 秒发送一个空的keepalive数据包。将此选项设置为0将完全禁用keepalive数据包。默认值为5秒。</target>
        </trans-unit>
        <trans-unit id="09ea8c9e4617731ed2a0cdf40185d39ec477e171" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; is in effect, allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for an object at the tip of a hidden ref (by default, such a request is rejected). See also &lt;code&gt;uploadpack.hideRefs&lt;/code&gt;. Even if this is false, a client may be able to steal objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">当 &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; 生效时，允许 &lt;code&gt;upload-pack&lt;/code&gt; 接受在隐藏ref的尖端请求对象的获取请求（默认情况下，该请求被拒绝）。另请参见 &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; 。即使这是错误的，客户端也可以通过&lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt;手册页的&amp;ldquo;安全&amp;rdquo;部分中描述的技术来窃取对象。最好将私有数据保存在单独的存储库中。</target>
        </trans-unit>
        <trans-unit id="450f4babea27d38a629ee9743ca7ffcb90a8c4de" translate="yes" xml:space="preserve">
          <source>When Git does a normal merge between two branches, it considers exactly three points: the two branches and a third commit, called the &lt;code&gt;merge base&lt;/code&gt;, which is usually the common ancestor of the commits. The result of the merge is the sum of the changes between the merge base and each head. When you merge two branches with a regular merge commit, this results in a new commit which will end up as a merge base when they&amp;rsquo;re merged again, because there is now a new common ancestor. Git doesn&amp;rsquo;t have to consider changes that occurred before the merge base, so you don&amp;rsquo;t have to re-resolve any conflicts you resolved before.</source>
          <target state="translated">当Git在两个分支之间进行正常合并时，它将精确地考虑三个点：两个分支和第三个提交，称为 &lt;code&gt;merge base&lt;/code&gt; ，通常是提交的共同祖先。合并的结果是合并基础与每个磁头之间的变化之和。当您使用常规合并提交合并两个分支时，这将导致一个新提交，当再次合并它们时，该提交最终将作为合并基础，因为现在有了一个新的共同祖先。 Git不必考虑在合并基础之前发生的更改，因此您不必重新解决之前解决的任何冲突。</target>
        </trans-unit>
        <trans-unit id="5f953a201b0ae4d35f35034718b3114ef928787f" translate="yes" xml:space="preserve">
          <source>When Git doesn&amp;rsquo;t know how to handle a certain transport protocol, it attempts to use the &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used:</source>
          <target state="translated">当Git不知道如何处理某种传输协议时，它会尝试使用 &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; 远程帮助程序（如果存在）。要显式请求远程帮助者，可以使用以下语法：</target>
        </trans-unit>
        <trans-unit id="cf58a154a8f8fa8889640812d376b7964ce7bef2" translate="yes" xml:space="preserve">
          <source>When Git encounters a URL of the form &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; is a protocol that it cannot handle natively, it automatically invokes &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with the full URL as the second argument. If such a URL is encountered directly on the command line, the first argument is the same as the second, and if it is encountered in a configured remote, the first argument is the name of that remote.</source>
          <target state="translated">当Git遇到 &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt; 形式的URL时，其中 &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; 是它本身无法处理的协议，它会自动调用 &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; ，并将完整URL作为第二个参数。如果直接在命令行上遇到这样的URL，则第一个参数与第二个参数相同，如果在已配置的远程中遇到该URL，则第一个参数是该远程的名称。</target>
        </trans-unit>
        <trans-unit id="27018e5bb4c8622ebcfed2f81b80284203c3bc2f" translate="yes" xml:space="preserve">
          <source>When Git encounters the first file that needs to be cleaned or smudged, it starts the filter and performs the handshake. In the handshake, the welcome message sent by Git is &quot;git-filter-client&quot;, only version 2 is supported, and the supported capabilities are &quot;clean&quot;, &quot;smudge&quot;, and &quot;delay&quot;.</source>
          <target state="translated">当Git遇到第一个需要清理或污损的文件时,就会启动过滤器并进行握手。在握手过程中,Git发送的欢迎信息是 &quot;git-filter-client&quot;,只支持第2版,支持的功能是 &quot;clean&quot;、&quot;smudge &quot;和 &quot;delay&quot;。</target>
        </trans-unit>
        <trans-unit id="f51f886a7edb2e397d8670010685e9d17fb9bc09" translate="yes" xml:space="preserve">
          <source>When Git needs authentication for a particular URL context, credential-store will consider that context a pattern to match against each entry in the credentials file. If the protocol, hostname, and username (if we already have one) match, then the password is returned to Git. See the discussion of configuration in &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">当Git需要针对特定​​URL上下文进行身份验证时，凭据存储将认为该上下文是一种与凭据文件中每个条目匹配的模式。如果协议，主机名和用户名（如果已经有）匹配，那么密码将返回给Git。有关更多信息，请参见&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]中&lt;/a&gt;有关配置的讨论。</target>
        </trans-unit>
        <trans-unit id="fbdc4494c8c569621bd35073fd02055c267f7e54" translate="yes" xml:space="preserve">
          <source>When Git needs to show you a diff for the path with &lt;code&gt;diff&lt;/code&gt; attribute set to &lt;code&gt;jcdiff&lt;/code&gt;, it calls the command you specified with the above configuration, i.e. &lt;code&gt;j-c-diff&lt;/code&gt;, with 7 parameters, just like &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; program is called. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">当Git需要将 &lt;code&gt;diff&lt;/code&gt; 属性设置为 &lt;code&gt;jcdiff&lt;/code&gt; 的路径显示给您diff时，它将调用您使用上述配置指定的命令，即 &lt;code&gt;j-c-diff&lt;/code&gt; ，具有7个参数，就像 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 程序一样。有关详细信息，请参见&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb3065603615c6a64dfcb623c10f42c6b9e417fa" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;git push --signed&lt;/code&gt; sent a push certificate with a &quot;nonce&quot; that was issued by a receive-pack serving the same repository within this many seconds, export the &quot;nonce&quot; found in the certificate to &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; to the hooks (instead of what the receive-pack asked the sending side to include). This may allow writing checks in &lt;code&gt;pre-receive&lt;/code&gt; and &lt;code&gt;post-receive&lt;/code&gt; a bit easier. Instead of checking &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; environment variable that records by how many seconds the nonce is stale to decide if they want to accept the certificate, they only can check &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; is &lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;git push --signed&lt;/code&gt; 在这么多秒内发送带有服务于同一存储库的接收包发出的带有&amp;ldquo; nonce&amp;rdquo;的推送证书时，请将证书中找到的&amp;ldquo; nonce&amp;rdquo;导出到 &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; 到钩子（而不是接收包要求发送方包括什么）。这可能允许写入检查 &lt;code&gt;pre-receive&lt;/code&gt; 和 &lt;code&gt;post-receive&lt;/code&gt; 一个更容易一些。他们无需检查 &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; 环境变量来记录他们是否愿意接受证书， &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; 仅检查GIT_PUSH_CERT_NONCE_STATUS是 &lt;code&gt;OK&lt;/code&gt; 即可，该环境变量记录了随机数过时的秒数。</target>
        </trans-unit>
        <trans-unit id="f34a76491c47ddfcf2959dd6944574eeda479afa" translate="yes" xml:space="preserve">
          <source>When a command has finished, and the client has received the entire response from the server, a client can either request that another command be executed or can terminate the connection. A client may optionally send an empty request consisting of just a flush-pkt to indicate that no more requests will be made.</source>
          <target state="translated">当一条命令结束,客户端收到服务器的全部响应后,客户端可以请求执行另一条命令,也可以终止连接。客户端可以选择发送一个仅由flush-pkt组成的空请求,以表示不再发出请求。</target>
        </trans-unit>
        <trans-unit id="98e606d10b24cc0c03b08a4efd9e014e2a7d092f" translate="yes" xml:space="preserve">
          <source>When a commit is created in this state, the branch is updated to refer to the new commit. Specifically, &lt;code&gt;git commit&lt;/code&gt; creates a new commit &lt;code&gt;d&lt;/code&gt;, whose parent is commit &lt;code&gt;c&lt;/code&gt;, and then updates branch &lt;code&gt;master&lt;/code&gt; to refer to new commit &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;HEAD&lt;/code&gt; still refers to branch &lt;code&gt;master&lt;/code&gt; and so indirectly now refers to commit &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">在这种状态下创建提交后，分支将更新以引用新的提交。具体来说， &lt;code&gt;git commit&lt;/code&gt; 创建一个新的提交 &lt;code&gt;d&lt;/code&gt; ，其父为commit &lt;code&gt;c&lt;/code&gt; ，然后更新分支 &lt;code&gt;master&lt;/code&gt; 以引用新的提交 &lt;code&gt;d&lt;/code&gt; 。 &lt;code&gt;HEAD&lt;/code&gt; 仍然指分支 &lt;code&gt;master&lt;/code&gt; ，因此现在间接指commit &lt;code&gt;d&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b5e6d106b45c449ef3f9978fa7e9a2c319abd6d7" translate="yes" xml:space="preserve">
          <source>When a conflict occurs while rebasing, rebase stops and asks the user to resolve. Since the user may need to make notable changes while resolving conflicts, after conflicts are resolved and the user has run &lt;code&gt;git rebase --continue&lt;/code&gt;, the rebase should open an editor and ask the user to update the commit message. The merge backend does this, while the apply backend blindly applies the original commit message.</source>
          <target state="translated">当在重新设置基准时发生冲突时，重新设置基准将停止并要求用户解决。由于用户可能需要在解决冲突时进行显着更改，因此在解决冲突并运行 &lt;code&gt;git rebase --continue&lt;/code&gt; 之后，rebase应该打开编辑器并要求用户更新提交消息。合并后端会执行此操作，而应用后端则会盲目地应用原始提交消息。</target>
        </trans-unit>
        <trans-unit id="a1d656a10ad8d92cd23d5675fa9c3ba2b92a8d6f" translate="yes" xml:space="preserve">
          <source>When a curl trace is enabled (see &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; above), do not dump data (that is, only dump info lines and headers).</source>
          <target state="translated">启用卷曲跟踪时（请参见上面的 &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; ），请勿转储数据（即，仅转储信息行和标头）。</target>
        </trans-unit>
        <trans-unit id="855748d09cda03242c615ed9f83d928cff4dd252" translate="yes" xml:space="preserve">
          <source>When a fetch mirror is created with &lt;code&gt;--mirror=fetch&lt;/code&gt;, the refs will not be stored in the &lt;code&gt;refs/remotes/&lt;/code&gt; namespace, but rather everything in &lt;code&gt;refs/&lt;/code&gt; on the remote will be directly mirrored into &lt;code&gt;refs/&lt;/code&gt; in the local repository. This option only makes sense in bare repositories, because a fetch would overwrite any local commits.</source>
          <target state="translated">当使用 &lt;code&gt;--mirror=fetch&lt;/code&gt; 创建获取镜像时，参考不会存储在 &lt;code&gt;refs/remotes/&lt;/code&gt; 名称空间中，而是将远程 &lt;code&gt;refs/&lt;/code&gt; 中的所有内容直接镜像到本地存储库中的 &lt;code&gt;refs/&lt;/code&gt; 中。该选项仅在裸仓库中才有意义，因为获取将覆盖所有本地提交。</target>
        </trans-unit>
        <trans-unit id="747511f053f093bdd8637c2efa65029ba86d5e79" translate="yes" xml:space="preserve">
          <source>When a git process is a (direct or indirect) child of another git process, it inherits Trace2 context information. This allows the child to print the command hierarchy. This example shows gc as child[3] of fetch. When the gc process reports its name as &quot;gc&quot;, it also reports the hierarchy as &quot;fetch/gc&quot;. (In this example, trace2 messages from the child process is indented for clarity.)</source>
          <target state="translated">当一个 git 进程是另一个 git 进程的(直接或间接)子进程时,它会继承 Trace2 上下文信息。这允许子进程打印命令层次结构。这个例子显示 gc 是 fetch 的子进程[3]。当 gc 进程将自己的名字报告为 &quot;gc &quot;时,它也将层次结构报告为 &quot;fetch/gc&quot;。(在这个例子中,为了清楚起见,子进程的 trace2 消息被缩进了。)</target>
        </trans-unit>
        <trans-unit id="dcc866e382263d0b053b9eb6226d8321d2b6f3a3" translate="yes" xml:space="preserve">
          <source>When a helper is executed, it will have one &quot;operation&quot; argument appended to its command line, which is one of:</source>
          <target state="translated">当一个助记器被执行时,它的命令行会附加一个 &quot;操作 &quot;参数,该参数为:。</target>
        </trans-unit>
        <trans-unit id="79294381fcaa0a0dccaa2b41ac29dc7daa74e3f5" translate="yes" xml:space="preserve">
          <source>When a local branch is started off a remote-tracking branch, Git sets up the branch (specifically the &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries) so that &lt;code&gt;git pull&lt;/code&gt; will appropriately merge from the remote-tracking branch. This behavior may be changed via the global &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; configuration flag. That setting can be overridden by using the &lt;code&gt;--track&lt;/code&gt; and &lt;code&gt;--no-track&lt;/code&gt; options, and changed later using &lt;code&gt;git branch --set-upstream-to&lt;/code&gt;.</source>
          <target state="translated">当本地分支从远程跟踪分支启动时，Git会设置分支（特别是 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 和 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 配置条目），以便 &lt;code&gt;git pull&lt;/code&gt; 将适当地从远程分支合并。跟踪分支。可以通过全局 &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; 配置标志来更改此行为。可以使用 &lt;code&gt;--track&lt;/code&gt; 和 &lt;code&gt;--no-track&lt;/code&gt; 选项覆盖该设置，稍后使用 &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; 进行更改。</target>
        </trans-unit>
        <trans-unit id="dbb99a5451930fe8366dedb022737c46385ca3a6" translate="yes" xml:space="preserve">
          <source>When a merge commit is included by &lt;code&gt;--show-pulls&lt;/code&gt;, the merge is treated as if it &quot;pulled&quot; the change from another branch. When using &lt;code&gt;--show-pulls&lt;/code&gt; on this example (and no other options) the resulting graph is:</source>
          <target state="translated">如果 &lt;code&gt;--show-pulls&lt;/code&gt; 包含合并提交，则将合并视为从另一分支&amp;ldquo;拉&amp;rdquo;出更改。在此示例上使用 &lt;code&gt;--show-pulls&lt;/code&gt; 时（无其他选项），结果图为：</target>
        </trans-unit>
        <trans-unit id="8e12783acd89ac9262429bc89fcf85d9b95e88c1" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens during switching branches with the &lt;code&gt;-m&lt;/code&gt; option, you would see something like this:</source>
          <target state="translated">当使用 &lt;code&gt;-m&lt;/code&gt; 选项切换分支期间发生合并冲突时，您将看到类似以下内容：</target>
        </trans-unit>
        <trans-unit id="8b8f6236a48634fd451e67557b1ed432c992a4a6" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with &lt;code&gt;git add&lt;/code&gt; (or &lt;code&gt;git rm&lt;/code&gt; if the merge should result in deletion of the path).</source>
          <target state="translated">发生合并冲突时，冲突路径的索引条目将保持未合并状态，您需要解决冲突并使用 &lt;code&gt;git add&lt;/code&gt; （或 &lt;code&gt;git rm&lt;/code&gt; 标记已解决的路径，如果合并会导致路径的删除）。</target>
        </trans-unit>
        <trans-unit id="054b9e9957838ff74728498487ffff5f26346d88" translate="yes" xml:space="preserve">
          <source>When a merge isn&amp;rsquo;t resolved automatically, Git leaves the index and the working tree in a special state that gives you all the information you need to help resolve the merge.</source>
          <target state="translated">当合并不能自动解决时，Git会将索引和工作树置于特殊状态，为您提供帮助解决合并所需的所有信息。</target>
        </trans-unit>
        <trans-unit id="1d6b6e4ed4a39cb92155b19d26f3a8478b8d6d5c" translate="yes" xml:space="preserve">
          <source>When a new branch is created with &lt;code&gt;git branch&lt;/code&gt;, &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt; that tracks another branch, this variable tells Git to set up pull to rebase instead of merge (see &quot;branch.&amp;lt;name&amp;gt;.rebase&quot;). When &lt;code&gt;never&lt;/code&gt;, rebase is never automatically set to true. When &lt;code&gt;local&lt;/code&gt;, rebase is set to true for tracked branches of other local branches. When &lt;code&gt;remote&lt;/code&gt;, rebase is set to true for tracked branches of remote-tracking branches. When &lt;code&gt;always&lt;/code&gt;, rebase will be set to true for all tracking branches. See &quot;branch.autoSetupMerge&quot; for details on how to set up a branch to track another branch. This option defaults to never.</source>
          <target state="translated">当使用跟踪另一个分支的 &lt;code&gt;git branch&lt;/code&gt; ， &lt;code&gt;git switch&lt;/code&gt; 或 &lt;code&gt;git checkout&lt;/code&gt; 创建一个新分支时，此变量告诉Git设置对基础进行重载而不是合并的拉取（请参阅&amp;ldquo; branch。&amp;lt;name&amp;gt; .rebase&amp;rdquo;）。如果 &lt;code&gt;never&lt;/code&gt; ，则rebase永远不会自动设置为true。当 &lt;code&gt;local&lt;/code&gt; 时，对于其他本地分支的跟踪分支，rebase设置为true。当 &lt;code&gt;remote&lt;/code&gt; 时，远程跟踪分支的跟踪分支的rebase设置为true。当 &lt;code&gt;always&lt;/code&gt; ，底垫将被设置为true，所有跟踪的分支。有关如何设置分支以跟踪另一个分支的详细信息，请参见&amp;ldquo; branch.autoSetupMerge&amp;rdquo;。该选项默认为从不。</target>
        </trans-unit>
        <trans-unit id="ed0adff8e63a6741e1694d5ebc304264bd392424" translate="yes" xml:space="preserve">
          <source>When a patch failure occurs, &amp;lt;msg&amp;gt; will be printed to the screen before exiting. This overrides the standard message informing you to use &lt;code&gt;--continue&lt;/code&gt; or &lt;code&gt;--skip&lt;/code&gt; to handle the failure. This is solely for internal use between &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">当补丁失败时，&amp;lt;msg&amp;gt;将被打印到屏幕上，然后退出。这将覆盖标准消息，通知您使用 &lt;code&gt;--continue&lt;/code&gt; 或 &lt;code&gt;--skip&lt;/code&gt; 处理失败。这仅用于 &lt;code&gt;git rebase&lt;/code&gt; 和 &lt;code&gt;git am&lt;/code&gt; 之间的内部使用。</target>
        </trans-unit>
        <trans-unit id="d5b066fa036c4bb98c79472fbdf38de3d119f100" translate="yes" xml:space="preserve">
          <source>When a patch is part of an ongoing discussion, the patch generated by &lt;code&gt;git format-patch&lt;/code&gt; can be tweaked to take advantage of the &lt;code&gt;git am --scissors&lt;/code&gt; feature. After your response to the discussion comes a line that consists solely of &quot;&lt;code&gt;-- &amp;gt;8 --&lt;/code&gt;&quot; (scissors and perforation), followed by the patch with unnecessary header fields removed:</source>
          <target state="translated">当补丁是正在进行的讨论的一部分时，可以对 &lt;code&gt;git format-patch&lt;/code&gt; 生成的补丁进行调整，以利用 &lt;code&gt;git am --scissors&lt;/code&gt; 功能。在您对讨论的回答之后，出现了仅由&amp;ldquo; &lt;code&gt;-- &amp;gt;8 --&lt;/code&gt; &amp;rdquo;（剪刀和穿孔）组成的一行，其后是补丁，其中删除了不必要的标题字段：</target>
        </trans-unit>
        <trans-unit id="f3cb24e54c9837370739d06bd25b8c911a05ee6b" translate="yes" xml:space="preserve">
          <source>When a path is in the &quot;unmerged&quot; state, running &lt;code&gt;git update-index&lt;/code&gt; for that path tells Git to mark the path resolved.</source>
          <target state="translated">当路径处于&amp;ldquo;未合并&amp;rdquo;状态时，对该路径运行 &lt;code&gt;git update-index&lt;/code&gt; 会告诉Git标记已解析的路径。</target>
        </trans-unit>
        <trans-unit id="f8965008f9824bf8da0b033710c2d7ac1f3f6568" translate="yes" xml:space="preserve">
          <source>When a pure mode change is encountered (which has no index information), the information is read from the current index instead.</source>
          <target state="translated">当遇到纯模式变化时(没有索引信息),则从当前索引中读取信息代替。</target>
        </trans-unit>
        <trans-unit id="ef4651b07e5b8cb97cb93de85df1d7e556426d24" translate="yes" xml:space="preserve">
          <source>When a push mirror is created with &lt;code&gt;--mirror=push&lt;/code&gt;, then &lt;code&gt;git push&lt;/code&gt; will always behave as if &lt;code&gt;--mirror&lt;/code&gt; was passed.</source>
          <target state="translated">当使用 &lt;code&gt;--mirror=push&lt;/code&gt; 创建推送镜像时，则 &lt;code&gt;git push&lt;/code&gt; 将始终表现为 &lt;code&gt;--mirror&lt;/code&gt; 被传递。</target>
        </trans-unit>
        <trans-unit id="deb13d30f8ba66c920f6495f36b99921916b0fbc" translate="yes" xml:space="preserve">
          <source>When a rebase required merge conflicts to be resolved, compare the changes introduced by the rebase directly afterwards using:</source>
          <target state="translated">当一个rebase需要解决合并冲突时,使用以下方法直接比较rebase引入的变化。</target>
        </trans-unit>
        <trans-unit id="350766930233515327656bc7b70b13214a7aa33c" translate="yes" xml:space="preserve">
          <source>When a ref is updated, reflog entries are created to keep track of the reason why the ref was updated (which is typically the name of the high-level command that updated the ref), in addition to the old and new values of the ref. A scripted Porcelain command can use set_reflog_action helper function in &lt;code&gt;git-sh-setup&lt;/code&gt; to set its name to this variable when it is invoked as the top level command by the end user, to be recorded in the body of the reflog.</source>
          <target state="translated">更新参考时，除了参考的旧值和新值外，还将创建参考记录条目以跟踪更新参考的原因（通常是更新参考的高级命令的名称）。 。当最终用户将其作为顶层命令调用并记录在reflog的正文中时，脚本化的Porcelain命令可以在 &lt;code&gt;git-sh-setup&lt;/code&gt; 中使用set_reflog_action帮助函数将其名称设置为此变量。</target>
        </trans-unit>
        <trans-unit id="0a564cf0d83332d2cd6fd3ac884cec9942b078c7" translate="yes" xml:space="preserve">
          <source>When a repository is synchronized via &lt;code&gt;git push&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; objects packed in the source repository are usually stored unpacked in the destination. While this allows you to use different packing strategies on both ends, it also means you may need to repack both repositories every once in a while.</source>
          <target state="translated">当通过 &lt;code&gt;git push&lt;/code&gt; 和 &lt;code&gt;git pull&lt;/code&gt; 同步存储库时，打包在源存储库中的对象通常会解压缩存储在目标中。尽管这使您可以在两端使用不同的打包策略，但这也意味着您可能需要不时地重新打包两个存储库。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
