<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="39555b916eeeec115f6735665b5426bf964f4e52" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable, which must be a colon separated list of refs or globs.</source>
          <target state="translated">可以使用 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 环境变量来覆盖此设置，该环境变量必须是用冒号分隔的ref或glob列表。</target>
        </trans-unit>
        <trans-unit id="d17d74e5aa80b06bd416eb43f1c510767efc6dc8" translate="yes" xml:space="preserve">
          <source>This setting defaults to &quot;refs/notes/commits&quot;, and it can be overridden by the &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; environment variable. See &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;.</source>
          <target state="translated">此设置默认为&amp;ldquo; refs / notes / commits&amp;rdquo;，并且可以被 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 环境变量覆盖。参见&lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="843f7e48b1e3c030c426060d83a399e29388c249" translate="yes" xml:space="preserve">
          <source>This setting forces Git to normalize line endings for this file on checkin and convert them to CRLF when the file is checked out.</source>
          <target state="translated">这个设置会强制 Git 在签入时对该文件的行尾进行标准化处理,并在签出时将其转换为 CRLF。</target>
        </trans-unit>
        <trans-unit id="8c7bb001c250cfdf4247d252deb09b8b2c2a2839" translate="yes" xml:space="preserve">
          <source>This setting forces Git to normalize line endings to LF on checkin and prevents conversion to CRLF when the file is checked out.</source>
          <target state="translated">这个设置会强制 Git 在签入时将行尾规范化为 LF,并防止在签出时转换为 CRLF。</target>
        </trans-unit>
        <trans-unit id="886fc853da603148f91948f5793a0d1be70dc28a" translate="yes" xml:space="preserve">
          <source>This setting is automatically guessed by &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; when the repository was created. By default a repository that ends in &quot;/.git&quot; is assumed to be not bare (bare = false), while all other repositories are assumed to be bare (bare = true).</source>
          <target state="translated">创建存储库时，&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;或&lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt;会自动猜测此设置。默认情况下，以&amp;ldquo; /.git&amp;rdquo;结尾的存储库被假定为裸机（裸=假），而所有其他存储库被假定为裸机（裸= true）。</target>
        </trans-unit>
        <trans-unit id="a32da40367d476cb817ba2cfa99cb18bc04a7b3a" translate="yes" xml:space="preserve">
          <source>This setting overrides the default of the &lt;code&gt;--cleanup&lt;/code&gt; option in &lt;code&gt;git commit&lt;/code&gt;. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for details. Changing the default can be useful when you always want to keep lines that begin with comment character &lt;code&gt;#&lt;/code&gt; in your log message, in which case you would do &lt;code&gt;git config commit.cleanup whitespace&lt;/code&gt; (note that you will have to remove the help lines that begin with &lt;code&gt;#&lt;/code&gt; in the commit log template yourself, if you do this).</source>
          <target state="translated">此设置将覆盖 &lt;code&gt;git commit&lt;/code&gt; 中的 &lt;code&gt;--cleanup&lt;/code&gt; 选项的默认设置。有关详细信息，请参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;。当您始终希望在日志消息中保留以注释字符 &lt;code&gt;#&lt;/code&gt; 开头的行时，更改默认值会很有用，在这种情况下，您需要执行 &lt;code&gt;git config commit.cleanup whitespace&lt;/code&gt; （请注意，您必须删除以开头的帮助行 &lt;code&gt;#&lt;/code&gt; ，您自己可以在提交日志模板中）。</target>
        </trans-unit>
        <trans-unit id="e85001143ab4f6109a8db79b80d46592a3792b5e" translate="yes" xml:space="preserve">
          <source>This setting should be set to a comma-separated list of color and date settings, starting and ending with a color, the dates should be set from oldest to newest. The metadata will be colored given the colors if the line was introduced before the given timestamp, overwriting older timestamped colors.</source>
          <target state="translated">该设置应设置为以逗号分隔的颜色和日期设置列表,以颜色开始和结束,日期应从最旧到最新设置。如果该行是在给定时间戳之前引入的,元数据将被赋予颜色,覆盖较旧的时间戳颜色。</target>
        </trans-unit>
        <trans-unit id="1b39995bc064271da90ffd3401f4ace36766db6f" translate="yes" xml:space="preserve">
          <source>This setting writes a JSON-based format that is suited for machine interpretation. See &lt;code&gt;GIT_TRACE2&lt;/code&gt; for available trace output options and &lt;a href=&quot;api-trace2&quot;&gt;Trace2 documentation&lt;/a&gt; for full details.</source>
          <target state="translated">此设置将编写适合机器解释的基于JSON的格式。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE2&lt;/code&gt; ；有关完整的详细信息，请参见Trace2 &lt;a href=&quot;api-trace2&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d727921c238e28668ffb0dd7e4775077e3d6b368" translate="yes" xml:space="preserve">
          <source>This should be a colon-separated list of absolute paths. If set, it is a list of directories that Git should not chdir up into while looking for a repository directory (useful for excluding slow-loading network directories). It will not exclude the current working directory or a GIT_DIR set on the command line or in the environment. Normally, Git has to read the entries in this list and resolve any symlink that might be present in order to compare them with the current directory. However, if even this access is slow, you can add an empty entry to the list to tell Git that the subsequent entries are not symlinks and needn&amp;rsquo;t be resolved; e.g., &lt;code&gt;GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink&lt;/code&gt;.</source>
          <target state="translated">这应该是用冒号分隔的绝对路径列表。如果设置，则它是Git在查找存储库目录时不应该进入的目录列表（用于排除缓慢加载的网络目录）。它不会排除当前的工作目录或在命令行或环境中设置的GIT_DIR。通常，Git必须读取此列表中的条目并解析可能出现的任何符号链接，以便将它们与当前目录进行比较。但是，即使访问速度很慢，您也可以在列表中添加一个空条目，以告知Git后续条目不是符号链接，不需要解析；例如， &lt;code&gt;GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02391ad98329bedcf2ddfbe7ebdef774e4e7cc67" translate="yes" xml:space="preserve">
          <source>This should help you to submit patches inline using KMail.</source>
          <target state="translated">这应该可以帮助你使用KMail在线提交补丁。</target>
        </trans-unit>
        <trans-unit id="dc65a8c75ec971d079e04ac05264e8ee2fb908c8" translate="yes" xml:space="preserve">
          <source>This should make &quot;--pretty=oneline&quot; a whole lot more readable for people using 80-column terminals.</source>
          <target state="translated">这将使&quot;-pretty=oneline &quot;对于使用80列终端的人来说更加易读。</target>
        </trans-unit>
        <trans-unit id="cda899a68420b48633046b1cef20e4960b467a9e" translate="yes" xml:space="preserve">
          <source>This should make it easy to look up svn log messages when svn users refer to -r/--revision numbers.</source>
          <target state="translated">当svn用户参考-r/--revision号码时,这应该可以很容易地查找svn日志信息。</target>
        </trans-unit>
        <trans-unit id="3fce0b9f9a8369808848ec3f066c1735323bb111" translate="yes" xml:space="preserve">
          <source>This should not be confused with the &lt;code&gt;ours&lt;/code&gt; merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring &lt;code&gt;our&lt;/code&gt; history contains all that happened in it.</source>
          <target state="translated">这不应与 &lt;code&gt;ours&lt;/code&gt; 合并策略混淆，该策略甚至根本不看另一棵树包含的内容。它丢弃了另一棵树所做的一切，声明 &lt;code&gt;our&lt;/code&gt; 历史包含其中发生的所有事件。</target>
        </trans-unit>
        <trans-unit id="70d0ce2d7e7f48cdf303b28228ad271bde0b97ac" translate="yes" xml:space="preserve">
          <source>This shows that our resolved version deleted &quot;Hello world&quot; from the first parent, deleted &quot;Goodbye&quot; from the second parent, and added &quot;Goodbye world&quot;, which was previously absent from both.</source>
          <target state="translated">由此可见,我们的解决版删除了第一个父体中的 &quot;Hello world&quot;,删除了第二个父体中的 &quot;Goodbye&quot;,增加了之前两个父体都没有的 &quot;Goodbye world&quot;。</target>
        </trans-unit>
        <trans-unit id="e0fbc89a9eb1f686d88b41839c951cd18b86bf5e" translate="yes" xml:space="preserve">
          <source>This shows that you can do without a run script if you write the test on a single line.</source>
          <target state="translated">这说明,如果你把测试写在单行上,可以不用运行脚本。</target>
        </trans-unit>
        <trans-unit id="f580a082428b40358ee35f346bb87b38bbd6e3f8" translate="yes" xml:space="preserve">
          <source>This shows the change between HEAD and index (i.e. what will be committed if you say &lt;code&gt;git commit&lt;/code&gt;), and between index and working tree files (i.e. what you could stage further before &lt;code&gt;git commit&lt;/code&gt; using &lt;code&gt;git add&lt;/code&gt;) for each path. A sample output looks like this:</source>
          <target state="translated">这显示了每个路径的HEAD和index之间的变化（即，如果您说 &lt;code&gt;git commit&lt;/code&gt; ，将提交什么），以及索引和工作树文件之间的变化（即，您可以在使用 &lt;code&gt;git add&lt;/code&gt; 的 &lt;code&gt;git commit&lt;/code&gt; 之前进行进一步的转换）。示例输出如下所示：</target>
        </trans-unit>
        <trans-unit id="cdedf9c4235065dcc3b6a065543c259879fefa6b" translate="yes" xml:space="preserve">
          <source>This shows the files and directories to be deleted and issues an &quot;Input ignore patterns&amp;gt;&amp;gt;&quot; prompt. You can input space-separated patterns to exclude files and directories from deletion. E.g. &quot;*.c *.h&quot; will excludes files end with &quot;.c&quot; and &quot;.h&quot; from deletion. When you are satisfied with the filtered result, press ENTER (empty) back to the main menu.</source>
          <target state="translated">这显示了要删除的文件和目录，并发出&amp;ldquo;输入忽略模式&amp;gt;&amp;gt;&amp;rdquo;提示。您可以输入以空格分隔的模式，以从删除中排除文件和目录。例如，&amp;ldquo; *。c * .h&amp;rdquo;将删除以&amp;ldquo; .c&amp;rdquo;和&amp;ldquo; .h&amp;rdquo;结尾的文件。当您对过滤后的结果感到满意时，请按ENTER（空）回到主菜单。</target>
        </trans-unit>
        <trans-unit id="d76da1518821bfa115def32fd19d8e8b1e73d979" translate="yes" xml:space="preserve">
          <source>This shows the files and directories to be deleted and issues an &quot;Select items to delete&amp;gt;&amp;gt;&quot; prompt. When the prompt ends with double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; like this, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. &quot;2-5 7,9&quot; to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining items are selected. E.g. &quot;7-&quot; to choose 7,8,9 from the list. You can say &lt;code&gt;*&lt;/code&gt; to choose everything. Also when you are satisfied with the filtered result, press ENTER (empty) back to the main menu.</source>
          <target state="translated">这将显示要删除的文件和目录，并发出&amp;ldquo;选择要删除的项目&amp;gt;&amp;gt;&amp;rdquo;提示。当提示符以double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 这样结束时，您可以进行多个选择，并与空格或逗号连接。您也可以说范围。例如，&amp;ldquo; 2-5 7,9&amp;rdquo;从列表中选择2,3,4,5,7,9。如果省略范围中的第二个数字，则将选择所有剩余的项目。例如，&amp;ldquo; 7-&amp;rdquo;从列表中选择7,8,9。您可以说 &lt;code&gt;*&lt;/code&gt; 选择所有内容。同样，当您对过滤后的结果感到满意时，请按ENTER（空白）回到主菜单。</target>
        </trans-unit>
        <trans-unit id="53f59db63b45945049b0fe262d831991c1cb4a8d" translate="yes" xml:space="preserve">
          <source>This shows the status information and issues an &quot;Update&amp;gt;&amp;gt;&quot; prompt. When the prompt ends with double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. &quot;2-5 7,9&quot; to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining patches are taken. E.g. &quot;7-&quot; to choose 7,8,9 from the list. You can say &lt;code&gt;*&lt;/code&gt; to choose everything.</source>
          <target state="translated">这将显示状态信息并发出&amp;ldquo; Update &amp;gt;&amp;gt;&amp;rdquo;提示。当提示以双 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 结束时，您可以选择多个选项，并用空格或逗号连接。您也可以说范围。例如，&amp;ldquo; 2-5 7,9&amp;rdquo;从列表中选择2,3,4,5,7,9。如果忽略范围中的第二个数字，则会获取所有剩余的色块。例如，&amp;ldquo; 7-&amp;rdquo;从列表中选择7,8,9。您可以说 &lt;code&gt;*&lt;/code&gt; 选择所有内容。</target>
        </trans-unit>
        <trans-unit id="728eb7da1f0f1bff86889f4ac114a7967bd3817f" translate="yes" xml:space="preserve">
          <source>This snapshot is now stored in a temporary staging area which Git calls the &quot;index&quot;. You can permanently store the contents of the index in the repository with &lt;code&gt;git commit&lt;/code&gt;:</source>
          <target state="translated">现在，此快照存储在Git称为&amp;ldquo;索引&amp;rdquo;的临时登台区域中。您可以使用 &lt;code&gt;git commit&lt;/code&gt; 将索引的内容永久存储在存储库中：</target>
        </trans-unit>
        <trans-unit id="dfa3a419f48a4609a0668c69a143f543612e713a" translate="yes" xml:space="preserve">
          <source>This solution is not 100% bulletproof, in the sense that if some project has a named ref (branch, tag) starting with &lt;code&gt;git/&lt;/code&gt;, then paths such as</source>
          <target state="translated">从某种意义上说，如果某个项目具有以 &lt;code&gt;git/&lt;/code&gt; 开头的命名ref（分支，标签），则此解决方案不是100％防弹的</target>
        </trans-unit>
        <trans-unit id="02da975953020f9ebbe3388889e8a8406f05d0c7" translate="yes" xml:space="preserve">
          <source>This step and the next one could be combined into a single step with &quot;checkout -b my2.6.14 v2.6.14&quot;.</source>
          <target state="translated">这一步和下一步可以用 &quot;checkout -b my2.6.14 v2.6.14 &quot;合并成一个步骤。</target>
        </trans-unit>
        <trans-unit id="9b0b980e437fd3274de63464aa9184e42833d899" translate="yes" xml:space="preserve">
          <source>This suffix is also accepted when spelled in uppercase, and means the same thing no matter the case.</source>
          <target state="translated">这个后缀在拼成大写时也被接受,无论大小写都是一样的意思。</target>
        </trans-unit>
        <trans-unit id="01f381d8f83cae139b7e7ff06573574ebdbc8086" translate="yes" xml:space="preserve">
          <source>This supersedes the &lt;a href=&quot;#post-update&quot;&gt;&lt;em&gt;post-update&lt;/em&gt;&lt;/a&gt; hook in that it gets both old and new values of all the refs in addition to their names.</source>
          <target state="translated">这取代了&lt;a href=&quot;#post-update&quot;&gt;&lt;em&gt;更新后&lt;/em&gt;&lt;/a&gt;钩子，因为它除了获得所有引用的名称之外，还获取所有引用的旧值和新值。</target>
        </trans-unit>
        <trans-unit id="6339f7da558022ed0ae10f566dd01f30bb047e19" translate="yes" xml:space="preserve">
          <source>This synchronizes your public repository to match the named branch head (i.e. &lt;code&gt;master&lt;/code&gt; in this case) and objects reachable from them in your current repository.</source>
          <target state="translated">这将使您的公共存储库同步，以匹配命名的分支头（在这种情况下为 &lt;code&gt;master&lt;/code&gt; ）和在当前存储库中可从中访问的对象。</target>
        </trans-unit>
        <trans-unit id="0012e2584fc653cc03e6dda35ea11cbdc9f6c1a2" translate="yes" xml:space="preserve">
          <source>This syntax is only recognized if there are no slashes before the first colon. This helps differentiate a local path that contains a colon. For example the local path &lt;code&gt;foo:bar&lt;/code&gt; could be specified as an absolute path or &lt;code&gt;./foo:bar&lt;/code&gt; to avoid being misinterpreted as an ssh url.</source>
          <target state="translated">仅当第一个冒号之前没有斜杠时才能识别此语法。这有助于区分包含冒号的本地路径。例如，可以将本地路径 &lt;code&gt;foo:bar&lt;/code&gt; 指定为绝对路径，或者将 &lt;code&gt;./foo:bar&lt;/code&gt; 指定为避免被误解为ssh url。</target>
        </trans-unit>
        <trans-unit id="9f5d9872e03f1e6dd55415fa2249d9c84ea6f738" translate="yes" xml:space="preserve">
          <source>This takes a text file each of whose lines is a shell glob pattern. Filepairs that match a glob pattern on an earlier line in the file are output before ones that match a later line, and filepairs that do not match any glob pattern are output last.</source>
          <target state="translated">它接收一个文本文件,其每一行都是一个 shell glob 模式。匹配文件中较早一行的 glob 模式的文件对会在匹配较晚一行的文件对之前输出,不匹配任何 glob 模式的文件对会最后输出。</target>
        </trans-unit>
        <trans-unit id="b169549655fddd825e67d14c1591493d6ac0be03" translate="yes" xml:space="preserve">
          <source>This target is intended to be more of a summary (like GIT_TRACE) and less detailed than the other targets. It ignores thread, region, and data messages, for example.</source>
          <target state="translated">这个目标的目的是更多的是一个摘要(像GIT_TRACE),而不是像其他目标那样详细。例如,它忽略了线程、区域和数据消息。</target>
        </trans-unit>
        <trans-unit id="49bec15344e0cef74269dabec868d060f4c1b07d" translate="yes" xml:space="preserve">
          <source>This tells the bisect process that no commit after &lt;code&gt;v2.5&lt;/code&gt;, up to and including &lt;code&gt;v2.6&lt;/code&gt;, should be tested.</source>
          <target state="translated">这告诉bisect流程，在 &lt;code&gt;v2.5&lt;/code&gt; 之后（直到 &lt;code&gt;v2.6&lt;/code&gt; )（包括v2.6），不应该测试任何提交。</target>
        </trans-unit>
        <trans-unit id="1842bab1269e00a8bf77d06ee23570861225cc48" translate="yes" xml:space="preserve">
          <source>This tells the bisect process that the commits between &lt;code&gt;v2.5&lt;/code&gt; and &lt;code&gt;v2.6&lt;/code&gt; (inclusive) should be skipped.</source>
          <target state="translated">这告诉bisect进程应跳过 &lt;code&gt;v2.5&lt;/code&gt; 和 &lt;code&gt;v2.6&lt;/code&gt; （含）之间的提交。</target>
        </trans-unit>
        <trans-unit id="fb42c5eea9f7afe3662a07fd6af3c3105ab04e8f" translate="yes" xml:space="preserve">
          <source>This tells you that the immediately following version of the file was &quot;newsha&quot;, and that the immediately preceding version was &quot;oldsha&quot;. You also know the commit messages that went with the change from oldsha to 4b9458b and with the change from 4b9458b to newsha.</source>
          <target state="translated">这告诉你,紧接着文件的版本是 &quot;newsha&quot;,而之前的版本是 &quot;oldsha&quot;。你也知道从oldsha到4b9458b和从4b9458b到newsha的提交信息。</target>
        </trans-unit>
        <trans-unit id="8f1179423f3ea23a6c9e525ef159db41c1155b6a" translate="yes" xml:space="preserve">
          <source>This transformation is used to detect renames and copies, and is controlled by the -M option (to detect renames) and the -C option (to detect copies as well) to the &lt;code&gt;git diff-*&lt;/code&gt; commands. If the input contained these filepairs:</source>
          <target state="translated">此转换用于检测重命名和副本，并由 &lt;code&gt;git diff-*&lt;/code&gt; 命令的-M选项（用于检测重命名）和-C选项（也用于检测副本）控制。如果输入包含以下文件对：</target>
        </trans-unit>
        <trans-unit id="573190bccf8f2a4ea6fc33eedd23b4b8fc3f90f8" translate="yes" xml:space="preserve">
          <source>This transformation is used to merge filepairs broken by diffcore-break, and not transformed into rename/copy by diffcore-rename, back into a single modification. This always runs when diffcore-break is used.</source>
          <target state="translated">这个转换用于将被 diffcore-break 打断的文件对,以及没有被 diffcore-rename 转化为 rename/copy 的文件对,合并为一个修改。当使用diffcore-break时,这个转换总是会运行。</target>
        </trans-unit>
        <trans-unit id="448726c2164ad1aa28f4d84dcd657bc466764287" translate="yes" xml:space="preserve">
          <source>This transformation limits the set of filepairs to those that change specified strings between the preimage and the postimage in a certain way. -S&amp;lt;block of text&amp;gt; and -G&amp;lt;regular expression&amp;gt; options are used to specify different ways these strings are sought.</source>
          <target state="translated">这种转换将文件对的集合限制为以某种方式更改前映像和后映像之间的指定字符串的文件对。-S &amp;lt;文本块&amp;gt;和-G &amp;lt;正则表达式&amp;gt;选项用于指定搜索这些字符串的不同方式。</target>
        </trans-unit>
        <trans-unit id="eb01f7c28a2e42a179d9ca76727e0a7db6bb8dce" translate="yes" xml:space="preserve">
          <source>This transport can be used for both uploading and downloading, and requires you to have a log-in privilege over &lt;code&gt;ssh&lt;/code&gt; to the remote machine. It finds out the set of objects the other side lacks by exchanging the head commits both ends have and transfers (close to) minimum set of objects. It is by far the most efficient way to exchange Git objects between repositories.</source>
          <target state="translated">此传输可用于上载和下载，并且要求您具有通过 &lt;code&gt;ssh&lt;/code&gt; 登录到远程计算机的登录特权。它通过交换两端的头提交并转移（接近）最小对象集来找出另一侧缺少的对象集。到目前为止，这是在存储库之间交换Git对象的最有效方法。</target>
        </trans-unit>
        <trans-unit id="1e93313475dc2966a9b364d25d3e63ddb92cd35d" translate="yes" xml:space="preserve">
          <source>This transport is the same as SSH transport but uses &lt;code&gt;sh&lt;/code&gt; to run both ends on the local machine instead of running other end on the remote machine via &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">此传输与SSH传输相同，但是使用 &lt;code&gt;sh&lt;/code&gt; 在本地计算机上运行两端，而不是通过 &lt;code&gt;ssh&lt;/code&gt; 在远程计算机上运行另一端。</target>
        </trans-unit>
        <trans-unit id="187c060b77919e40b0db07be6c4444d6bedf0f1f" translate="yes" xml:space="preserve">
          <source>This transport was designed for anonymous downloading. Like SSH transport, it finds out the set of objects the downstream side lacks and transfers (close to) minimum set of objects.</source>
          <target state="translated">这种传输是为匿名下载设计的。像SSH传输一样,它找出下游方缺少的对象集,并传输(接近)最小对象集。</target>
        </trans-unit>
        <trans-unit id="a843c4941e9eb68216876c91a59842ae7d058faa" translate="yes" xml:space="preserve">
          <source>This tutorial explains how to import a new project into Git, make changes to it, and share changes with other developers.</source>
          <target state="translated">本教程介绍了如何将一个新项目导入Git,对其进行修改,并与其他开发者分享修改。</target>
        </trans-unit>
        <trans-unit id="586b98337ae35b657ccc9687b72106b49b3b174b" translate="yes" xml:space="preserve">
          <source>This tutorial explains how to use the &quot;core&quot; Git commands to set up and work with a Git repository.</source>
          <target state="translated">本教程将介绍如何使用 &quot;核心 &quot;Git命令来设置和使用Git仓库。</target>
        </trans-unit>
        <trans-unit id="4f3b7287fc4739a451de38537fb0637003a134c1" translate="yes" xml:space="preserve">
          <source>This tutorial should be enough to perform basic distributed revision control for your projects. However, to fully understand the depth and power of Git you need to understand two simple ideas on which it is based:</source>
          <target state="translated">这篇教程应该足以让你对项目进行基本的分布式修订控制。然而,要想充分理解 Git 的深度和威力,你需要了解它所基于的两个简单的理念。</target>
        </trans-unit>
        <trans-unit id="50b7797bad77b49520127714ff8a716873aad978" translate="yes" xml:space="preserve">
          <source>This updates (or creates, as necessary) branches &lt;code&gt;pu&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt; in the local repository by fetching from the branches (respectively) &lt;code&gt;pu&lt;/code&gt; and &lt;code&gt;maint&lt;/code&gt; from the remote repository.</source>
          <target state="translated">通过从远程存储库中的 &lt;code&gt;pu&lt;/code&gt; 和 &lt;code&gt;maint&lt;/code&gt; 分别获取分支，从而更新（或根据需要创建）本地存储库中的 &lt;code&gt;pu&lt;/code&gt; 和 &lt;code&gt;tmp&lt;/code&gt; 分支。</target>
        </trans-unit>
        <trans-unit id="3e7d31bbe83aa073e1058fe02ef8026a34345709" translate="yes" xml:space="preserve">
          <source>This updates (or creates, as necessary) branches &lt;code&gt;seen&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt; in the local repository by fetching from the branches (respectively) &lt;code&gt;seen&lt;/code&gt; and &lt;code&gt;maint&lt;/code&gt; from the remote repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70ac0b727096d7231e8fdcdd112d1a04551c8ca8" translate="yes" xml:space="preserve">
          <source>This used to be the default, but not since Git 2.0 (&lt;code&gt;simple&lt;/code&gt; is the new default).</source>
          <target state="translated">这曾经是默认设置，但自Git 2.0起就没有了（ &lt;code&gt;simple&lt;/code&gt; 是新的默认设置）。</target>
        </trans-unit>
        <trans-unit id="fd75f35034e73b98112aaaf4198ee488b9e51804" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;--interactive&lt;/code&gt; machinery internally, but combining it with the &lt;code&gt;--interactive&lt;/code&gt; option explicitly is generally not a good idea unless you know what you are doing (see BUGS below).</source>
          <target state="translated">这在内部使用 &lt;code&gt;--interactive&lt;/code&gt; 机制，但是除非明确知道您在做什么，否则将它与 &lt;code&gt;--interactive&lt;/code&gt; 选项显式结合通常不是一个好主意（请参阅下面的BUGS）。</target>
        </trans-unit>
        <trans-unit id="665eaff82148d49a545a97a7903a8bf0d3754608" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;--interactive&lt;/code&gt; machinery internally, but it can be run without an explicit &lt;code&gt;--interactive&lt;/code&gt;.</source>
          <target state="translated">这在内部使用 &lt;code&gt;--interactive&lt;/code&gt; 机制，但无需显式 &lt;code&gt;--interactive&lt;/code&gt; 即可运行。</target>
        </trans-unit>
        <trans-unit id="5a59444b879ae5151f30b1cffe08974240ac7bdc" translate="yes" xml:space="preserve">
          <source>This uses the same two-dot range notation we saw earlier with &lt;code&gt;git log&lt;/code&gt;.</source>
          <target state="translated">这使用了我们之前在 &lt;code&gt;git log&lt;/code&gt; 中看到的相同的两点范围符号。</target>
        </trans-unit>
        <trans-unit id="94dc29f5a82c88ac8ea06389eebe7535e89a6fb1" translate="yes" xml:space="preserve">
          <source>This value is true by default in a repository that has a working directory associated with it, and false by default in a bare repository.</source>
          <target state="translated">这个值在有工作目录的版本库中默认为true,在裸版本库中默认为false。</target>
        </trans-unit>
        <trans-unit id="73a34f84ecc165ae3643b28ecca4c6c41f197412" translate="yes" xml:space="preserve">
          <source>This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value &quot;user&quot; indicates that the archiving user&amp;rsquo;s umask will be used instead. See umask(2) and &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt;.</source>
          <target state="translated">此变量可用于限制tar归档条目的权限位。默认值为0002，它将关闭世界写入位。特殊值&amp;ldquo; user&amp;rdquo;指示将改为使用归档用户的umask。参见umask（2）和&lt;a href=&quot;git-archive&quot;&gt;git-archive [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63a384d932515032afb2060852ce18cd5598c9ca" translate="yes" xml:space="preserve">
          <source>This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value &quot;user&quot; indicates that the archiving user&amp;rsquo;s umask will be used instead. See umask(2) for details. If &lt;code&gt;--remote&lt;/code&gt; is used then only the configuration of the remote repository takes effect.</source>
          <target state="translated">此变量可用于限制tar归档条目的权限位。默认值为0002，它将关闭世界写入位。特殊值&amp;ldquo; user&amp;rdquo;指示将改为使用归档用户的umask。有关详细信息，请参见umask（2）。如果使用 &lt;code&gt;--remote&lt;/code&gt; ，则仅远程存储库的配置生效。</target>
        </trans-unit>
        <trans-unit id="0afce327e7d4311118de1c5dc2faa8fa7a291053" translate="yes" xml:space="preserve">
          <source>This variable controls the event target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">此变量控制事件目标的目的地。它可以被 &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; 环境变量覆盖。下表显示了可能的值。</target>
        </trans-unit>
        <trans-unit id="b3073c2a2c3930628fae47eb515e2fe5729910f0" translate="yes" xml:space="preserve">
          <source>This variable controls the normal target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">此变量控制正常的目标位置。它可以被 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 环境变量覆盖。下表显示了可能的值。</target>
        </trans-unit>
        <trans-unit id="ab644894061fa15fc115b6d355d07c2965277303" translate="yes" xml:space="preserve">
          <source>This variable controls the performance target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">此变量控制性能目标。它可以被 &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; 环境变量覆盖。下表显示了可能的值。</target>
        </trans-unit>
        <trans-unit id="53008d90e6aae985c2e7839a77d7b54894ce429e" translate="yes" xml:space="preserve">
          <source>This variable controls the sort ordering of branches when displayed by &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;. Without the &quot;--sort=&amp;lt;value&amp;gt;&quot; option provided, the value of this variable will be used as the default. See &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt; field names for valid values.</source>
          <target state="translated">当由&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;显示时，此变量控制分支的排序顺序。如果不提供&amp;ldquo; --sort = &amp;lt;值&amp;gt;&amp;rdquo;选项，则此变量的值将用作默认值。有关有效值，请参见&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt;字段名称。</target>
        </trans-unit>
        <trans-unit id="ea1c7eb75a360c1f9f69915dbc32e427ddfb7ced" translate="yes" xml:space="preserve">
          <source>This variable controls the sort ordering of tags when displayed by &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;. Without the &quot;--sort=&amp;lt;value&amp;gt;&quot; option provided, the value of this variable will be used as the default.</source>
          <target state="translated">当由&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;显示时，此变量控制标签的排序顺序。如果不提供&amp;ldquo; --sort = &amp;lt;值&amp;gt;&amp;rdquo;选项，则此变量的值将用作默认值。</target>
        </trans-unit>
        <trans-unit id="c2680b6925a4a160ca8f3fee892cc23ec9be5f4f" translate="yes" xml:space="preserve">
          <source>This variable determines the default value for variables such as &lt;code&gt;color.diff&lt;/code&gt; and &lt;code&gt;color.grep&lt;/code&gt; that control the use of color per command family. Its scope will expand as more commands learn configuration to set a default for the &lt;code&gt;--color&lt;/code&gt; option. Set it to &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;never&lt;/code&gt; if you prefer Git commands not to use color unless enabled explicitly with some other configuration or the &lt;code&gt;--color&lt;/code&gt; option. Set it to &lt;code&gt;always&lt;/code&gt; if you want all output not intended for machine consumption to use color, to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt; (this is the default since Git 1.8.4) if you want such output to use color when written to the terminal.</source>
          <target state="translated">此变量确定诸如 &lt;code&gt;color.diff&lt;/code&gt; 和 &lt;code&gt;color.grep&lt;/code&gt; 之类的变量的默认值，这些变量控制每个命令系列对颜色的使用。随着更多命令学习配置以设置 &lt;code&gt;--color&lt;/code&gt; 选项的默认值，其范围将扩大。如果您不希望Git命令不使用颜色，除非将其与其他配置或 &lt;code&gt;--color&lt;/code&gt; 选项一起显式启用，否则将其设置为 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;never&lt;/code&gt; 设置颜色。将其设置为 &lt;code&gt;always&lt;/code&gt; ，如果你想不用于机器消耗的用色，所有输出 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;auto&lt;/code&gt; ，如果你想这样的输出使用的颜色，当写入到终端（这是因为Git的1.8.4默认值）。</target>
        </trans-unit>
        <trans-unit id="2eb6f1e33d90fc7fb4373fa1793932292fbc650d" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;transfer.hideRefs&lt;/code&gt;, but applies only to &lt;code&gt;receive-pack&lt;/code&gt; (and so affects pushes, but not fetches). An attempt to update or delete a hidden ref by &lt;code&gt;git push&lt;/code&gt; is rejected.</source>
          <target state="translated">此变量与 &lt;code&gt;transfer.hideRefs&lt;/code&gt; 相同，但仅适用于 &lt;code&gt;receive-pack&lt;/code&gt; （因此影响推送，但不影响提取）。拒绝通过 &lt;code&gt;git push&lt;/code&gt; 更新或删除隐藏引用的尝试。</target>
        </trans-unit>
        <trans-unit id="763a368531eb9d8bc40e93c6334e049f21620c45" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;transfer.hideRefs&lt;/code&gt;, but applies only to &lt;code&gt;upload-pack&lt;/code&gt; (and so affects only fetches, not pushes). An attempt to fetch a hidden ref by &lt;code&gt;git fetch&lt;/code&gt; will fail. See also &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt;.</source>
          <target state="translated">此变量与 &lt;code&gt;transfer.hideRefs&lt;/code&gt; 相同，但仅适用于 &lt;code&gt;upload-pack&lt;/code&gt; （因此仅影响提取，不影响推送）。尝试通过 &lt;code&gt;git fetch&lt;/code&gt; 提取隐藏的引用将失败。另请参见 &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75aa35a44ffd767e8a239dc01347d150ce1e39ed" translate="yes" xml:space="preserve">
          <source>This variable matters only when using persistent web environments that serve multiple requests using single gitweb instance, like mod_perl, FastCGI or Plackup.</source>
          <target state="translated">这个变量只有在使用持久化的网络环境,如mod_perl、FastCGI或Plackup,使用单个gitweb实例来服务多个请求时才有意义。</target>
        </trans-unit>
        <trans-unit id="c0526214b5c55d639fefd6a92d93b97ec2455930" translate="yes" xml:space="preserve">
          <source>This variable specifies a shell command through which the tar output generated by &lt;code&gt;git archive&lt;/code&gt; should be piped. The command is executed using the shell with the generated tar file on its standard input, and should produce the final output on its standard output. Any compression-level options will be passed to the command (e.g., &quot;-9&quot;). An output file with the same extension as &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; will be use this format if no other format is given.</source>
          <target state="translated">该变量指定一个shell命令，通过该命令可以将 &lt;code&gt;git archive&lt;/code&gt; 生成的tar输出通过管道传输。该命令是使用Shell执行的，其标准输入上带有生成的tar文件，并且应在其标准输出上生成最终输出。任何压缩级别的选项都将传递给命令（例如&amp;ldquo; -9&amp;rdquo;）。如果未指定其他格式，则扩展名与 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 相同的输出文件将使用此格式。</target>
        </trans-unit>
        <trans-unit id="99ffcf0d1fc58b3934082bac9786637cf3a8cdad" translate="yes" xml:space="preserve">
          <source>This view is similar to &lt;code&gt;shortlog&lt;/code&gt; view.</source>
          <target state="translated">该视图类似于 &lt;code&gt;shortlog&lt;/code&gt; 视图。</target>
        </trans-unit>
        <trans-unit id="16ae6576174eeb48325f0bfa3042bcb20d29d417" translate="yes" xml:space="preserve">
          <source>This was not the case in the initial release of this feature in v2.13.0, which only matched the realpath version. Configuration that wants to be compatible with the initial release of this feature needs to either specify only the realpath version, or both versions.</source>
          <target state="translated">这个功能在v2.13.0的初始版本中并不是这样的,它只匹配realpath版本。想要与该功能初始版本兼容的配置,需要只指定realpath版本,或者两个版本都指定。</target>
        </trans-unit>
        <trans-unit id="7c8d457b197b5558b7abfe068bcd1974205f94ad" translate="yes" xml:space="preserve">
          <source>This was optional in prior versions of git, but now it is the default. You can use &lt;code&gt;--no-utf8&lt;/code&gt; to override this.</source>
          <target state="translated">这在以前的git版本中是可选的，但现在是默认设置。您可以使用 &lt;code&gt;--no-utf8&lt;/code&gt; 覆盖它。</target>
        </trans-unit>
        <trans-unit id="314df942d006c94c85d3e8c8bfe0a0b8ef8308d1" translate="yes" xml:space="preserve">
          <source>This will again prompt you for a message describing the change, and then record a new version of the project.</source>
          <target state="translated">这将再次提示你输入描述更改的信息,然后记录项目的新版本。</target>
        </trans-unit>
        <trans-unit id="53cca56aaa41c3093032e1d720cb620b22717e06" translate="yes" xml:space="preserve">
          <source>This will cache the result of running &quot;exif&quot; on each blob indefinitely. If you change the textconv config variable for a diff driver, Git will automatically invalidate the cache entries and re-run the textconv filter. If you want to invalidate the cache manually (e.g., because your version of &quot;exif&quot; was updated and now produces better output), you can remove the cache manually with &lt;code&gt;git update-ref -d refs/notes/textconv/jpg&lt;/code&gt; (where &quot;jpg&quot; is the name of the diff driver, as in the example above).</source>
          <target state="translated">这将无限期地缓存在每个Blob上运行&amp;ldquo; exif&amp;rdquo;的结果。如果您更改了diff驱动程序的textconv配置变量，Git将自动使缓存条目无效并重新运行textconv过滤器。如果您想手动使缓存无效（例如，因为您的&amp;ldquo; exif&amp;rdquo;版本已更新，现在可以产生更好的输出），则可以使用 &lt;code&gt;git update-ref -d refs/notes/textconv/jpg&lt;/code&gt; （其中&amp;ldquo; jpg&amp;rdquo;是差异驱动程序的名称，如上例所示。</target>
        </trans-unit>
        <trans-unit id="3d17cc7dd2b4aac7e00ecd2628dbb99eefd074c7" translate="yes" xml:space="preserve">
          <source>This will cause Git to generate &lt;code&gt;Binary files differ&lt;/code&gt; (or a binary patch, if binary patches are enabled) instead of a regular diff.</source>
          <target state="translated">这将导致Git生成 &lt;code&gt;Binary files differ&lt;/code&gt; 常规差异的Binary文件（或二进制补丁，如果启用了二进制补丁）。</target>
        </trans-unit>
        <trans-unit id="dac66330b2bd98fcf90352c4cbeba694c8f4feb3" translate="yes" xml:space="preserve">
          <source>This will check out the currently cached copy of &lt;code&gt;Makefile&lt;/code&gt; into the file &lt;code&gt;.merged-Makefile&lt;/code&gt;.</source>
          <target state="translated">这会将当前缓存的 &lt;code&gt;Makefile&lt;/code&gt; 副本 &lt;code&gt;.merged-Makefile&lt;/code&gt; 到文件.merged-Makefile中。</target>
        </trans-unit>
        <trans-unit id="9acb73cd9d17d8ef0d5dfd6af35ea9d0a50c12ab" translate="yes" xml:space="preserve">
          <source>This will create a new commit which undoes the change in HEAD. You will be given a chance to edit the commit message for the new commit.</source>
          <target state="translated">这将创建一个新的提交,撤销对 HEAD 的修改。您将有机会编辑新提交的提交信息。</target>
        </trans-unit>
        <trans-unit id="85437cd96f5cff3dd194d542498fd954d1bf1e01" translate="yes" xml:space="preserve">
          <source>This will define a remote called &quot;origin&quot; in the resulting repository that lets you fetch and pull from the bundle. The $GIT_DIR/config file in R2 will have an entry like this:</source>
          <target state="translated">这将在生成的版本库中定义一个名为 &quot;origin &quot;的远程,让你从捆绑包中获取和拉取。在R2的$GIT_DIR/config文件中会有这样的条目。</target>
        </trans-unit>
        <trans-unit id="2986121c6e711f05b2ed0ba772dedbd8c66503ff" translate="yes" xml:space="preserve">
          <source>This will error out if $REV is empty or not a valid revision.</source>
          <target state="translated">如果$REV为空或不是一个有效的版本,这将会出错。</target>
        </trans-unit>
        <trans-unit id="c8b7e8566771f37a03bc25eaec95675ffe82ba31" translate="yes" xml:space="preserve">
          <source>This will export the whole repository and import it into the existing empty repository. Except for reencoding commits that are not in UTF-8, it would be a one-to-one mirror.</source>
          <target state="translated">这将导出整个版本库,并将其导入到现有的空版本库中。除了重新编码非 UTF-8 的提交,这将是一个一对一的镜像。</target>
        </trans-unit>
        <trans-unit id="5f851e29f67384fe2f487309701055635453a02c" translate="yes" xml:space="preserve">
          <source>This will list what commits you must have in order to extract from the bundle and will error out if you do not have them.</source>
          <target state="translated">这将列出你必须有哪些提交才能从 bundle 中提取,如果你没有这些提交,就会出错。</target>
        </trans-unit>
        <trans-unit id="7ed8616207d4b6e51bdcbe1e7b524863a0139782" translate="yes" xml:space="preserve">
          <source>This will open your editor with a list of steps to be taken to perform your rebase.</source>
          <target state="translated">这将打开你的编辑器,并列出执行你的重垒的步骤。</target>
        </trans-unit>
        <trans-unit id="e9e68cbb3d1c11da9ad7575ebecc630d58996f10" translate="yes" xml:space="preserve">
          <source>This will prompt you for a commit message. You&amp;rsquo;ve now stored the first version of your project in Git.</source>
          <target state="translated">这将提示您输入提交消息。现在，您已将项目的第一个版本存储在Git中。</target>
        </trans-unit>
        <trans-unit id="9229da0c83ee0b71f5a22085b5f3b7e07e9ec55a" translate="yes" xml:space="preserve">
          <source>This will remove each of your commits from mywork, temporarily saving them as patches (in a directory named &lt;code&gt;.git/rebase-apply&lt;/code&gt;), update mywork to point at the latest version of origin, then apply each of the saved patches to the new mywork. The result will look like:</source>
          <target state="translated">这将从mywork中删除您的每个提交，将它们临时保存为补丁（在名为 &lt;code&gt;.git/rebase-apply&lt;/code&gt; 的目录中），更新mywork以指向最新的原始版本，然后将每个保存的补丁应用于新的mywork 。结果将如下所示：</target>
        </trans-unit>
        <trans-unit id="1c98be5284d00528a6b74a33ba778d044a767668" translate="yes" xml:space="preserve">
          <source>This will result in only b (a and c are cleared).</source>
          <target state="translated">这将导致只有b(a和c被清除)。</target>
        </trans-unit>
        <trans-unit id="0385ed25689cd3e1167020ff6e8ba549d1603871" translate="yes" xml:space="preserve">
          <source>This will set the property &lt;code&gt;svn:keywords&lt;/code&gt; to &lt;code&gt;FreeBSD=%H&lt;/code&gt; for the file &lt;code&gt;devel/py-tipper/Makefile&lt;/code&gt;.</source>
          <target state="translated">这会将文件 &lt;code&gt;devel/py-tipper/Makefile&lt;/code&gt; 的 &lt;code&gt;svn:keywords&lt;/code&gt; 属性设置为 &lt;code&gt;FreeBSD=%H&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61383e31770f578e5ee86310440dccd09a4e5008" translate="yes" xml:space="preserve">
          <source>This will show &quot;refs/heads/master&quot; but also &quot;refs/remote/other-repo/master&quot;, if such references exists.</source>
          <target state="translated">这将显示 &quot;refs/heads/master&quot;,但也会显示 &quot;refs/remote/other-repo/master&quot;,如果存在这样的引用的话。</target>
        </trans-unit>
        <trans-unit id="23dd2de32c54566f1df1adf9f6794600102b9c2b" translate="yes" xml:space="preserve">
          <source>This will start to clean, and you must confirm one by one in order to delete items. Please note that this action is not as efficient as the above two actions.</source>
          <target state="translated">这样就会开始清理,必须逐一确认才能删除项目。请注意,这个动作的效率不如以上两个动作。</target>
        </trans-unit>
        <trans-unit id="9b7bbd24afc1c6a470a80ef47d5171b33809ea28" translate="yes" xml:space="preserve">
          <source>This works for any of the supported update procedures (&lt;code&gt;--checkout&lt;/code&gt;, &lt;code&gt;--rebase&lt;/code&gt;, etc.). The only change is the source of the target SHA-1. For example, &lt;code&gt;submodule update --remote --merge&lt;/code&gt; will merge upstream submodule changes into the submodules, while &lt;code&gt;submodule update
--merge&lt;/code&gt; will merge superproject gitlink changes into the submodules.</source>
          <target state="translated">这适用于任何受支持的更新过程（ &lt;code&gt;--checkout&lt;/code&gt; ，-- &lt;code&gt;--rebase&lt;/code&gt; 等）。唯一的变化是目标SHA-1的来源。例如， &lt;code&gt;submodule update --remote --merge&lt;/code&gt; 将上游子模块更改合并到子模块中，而 &lt;code&gt;submodule update --merge&lt;/code&gt; 将超级项目gitlink更改合并到子模块中。</target>
        </trans-unit>
        <trans-unit id="5a2ee7840b76b59e3aede30738fb578b292bc5f3" translate="yes" xml:space="preserve">
          <source>This works similarly to &lt;code&gt;svn update&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt; except that it preserves linear history with &lt;code&gt;git rebase&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt; for ease of dcommitting with &lt;code&gt;git svn&lt;/code&gt;.</source>
          <target state="translated">这与 &lt;code&gt;svn update&lt;/code&gt; 或 &lt;code&gt;git pull&lt;/code&gt; 相似，除了它使用 &lt;code&gt;git rebase&lt;/code&gt; 而不是 &lt;code&gt;git merge&lt;/code&gt; 保留线性历史记录，以便于 &lt;code&gt;git svn&lt;/code&gt; 提交。</target>
        </trans-unit>
        <trans-unit id="5bc6c0e59c3e651570d66e12101e9a57040fd659" translate="yes" xml:space="preserve">
          <source>This would leave only one merge commit when your topic branch is finally ready and merged into the master branch. This merge would require you to resolve the conflict, introduced by the commits marked with &lt;code&gt;*&lt;/code&gt;. However, this conflict is often the same conflict you resolved when you created the test merge you blew away. &lt;code&gt;git rerere&lt;/code&gt; helps you resolve this final conflicted merge using the information from your earlier hand resolve.</source>
          <target state="translated">当您的主题分支最终准备好并合并到master分支中时，这将只留下一个合并提交。这种合并将需要您解决由 &lt;code&gt;*&lt;/code&gt; 标记的提交引起的冲突。但是，此冲突通常与您创建的测试合并所消除的冲突相同。 &lt;code&gt;git rerere&lt;/code&gt; 帮助您使用较早的手动解决方法中的信息来解决此最终冲突的合并。</target>
        </trans-unit>
        <trans-unit id="dcd6f908de988995d9fff4cafd75d14bc0785c1a" translate="yes" xml:space="preserve">
          <source>This would leave the merge result in &lt;code&gt;hello.c~2&lt;/code&gt; file, along with conflict markers if there are conflicts. After verifying the merge result makes sense, you can tell Git what the final merge result for this file is by:</source>
          <target state="translated">如果存在冲突，这会将合并结果以及冲突标记保留在 &lt;code&gt;hello.c~2&lt;/code&gt; 文件中。验证合并结果有意义之后，可以通过以下方式告诉Git该文件的最终合并结果是什么：</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="ee3cacca7314105556d3050112f523980e59f973" translate="yes" xml:space="preserve">
          <source>Those snapshots aren&amp;rsquo;t necessarily all arranged in a single line from oldest to newest; instead, work may simultaneously proceed along parallel lines of development, called &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;, which may merge and diverge.</source>
          <target state="translated">这些快照不必从最旧到最新全部排列在一行中。取而代之的是，工作可以同时沿着并行的发展路线（称为&lt;a href=&quot;#def_branch&quot;&gt;分支）进行&lt;/a&gt;，分支可以合并和发散。</target>
        </trans-unit>
        <trans-unit id="7a5a53a50d0fbac4f3a27d9d2d5853146557d940" translate="yes" xml:space="preserve">
          <source>Though not required, it&amp;rsquo;s a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.</source>
          <target state="translated">尽管不是必需的，但最好以一条简短的（少于50个字符的）短行来概述所有更改，然后是空行，再进行更详尽的描述，以开始提交消息。直到提交消息中的第一行空白为止的文本都被视为提交标题，并且该标题在整个Git中都使用。例如，&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;将提交转换为电子邮件，并在主题行上使用标题，在正文中使用其余提交。</target>
        </trans-unit>
        <trans-unit id="fdd6ea0498f5dbe48e6926bc8c91e77146fa2184" translate="yes" xml:space="preserve">
          <source>Though, according to Wikipedia &lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt;:</source>
          <target state="translated">不过，根据维基百科&lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="18c9e3ce5bbbf77af11ba41f4d7a7d9b7a1aaa55" translate="yes" xml:space="preserve">
          <source>Thread Events</source>
          <target state="translated">主题活动</target>
        </trans-unit>
        <trans-unit id="8850eee2783cf53d0af71d524467316d7d06a850" translate="yes" xml:space="preserve">
          <source>Thread messages added to a thread-proc.</source>
          <target state="translated">线程消息添加到线程程序中。</target>
        </trans-unit>
        <trans-unit id="1501e9d814d273ed34cc6b50f1b5e25add4ac049" translate="yes" xml:space="preserve">
          <source>Three other shorthands exist, particularly useful for merge commits, for naming a set that is formed by a commit and its parent commits.</source>
          <target state="translated">另外还有三个速记,对于合并提交特别有用,用于命名一个由提交和其父提交组成的集合。</target>
        </trans-unit>
        <trans-unit id="8e23a87c8354d34eb4b513798d76048267e22ae4" translate="yes" xml:space="preserve">
          <source>Three steps:</source>
          <target state="translated">三个步骤。</target>
        </trans-unit>
        <trans-unit id="cf3d01be00b3333c6ca36b4d1bb0a1a1c357a43f" translate="yes" xml:space="preserve">
          <source>Throw-away integration</source>
          <target state="translated">抛弃式整合</target>
        </trans-unit>
        <trans-unit id="c4780f4837eebde8ca1de31df251ef05e2361eb2" translate="yes" xml:space="preserve">
          <source>Thunderbird</source>
          <target state="translated">Thunderbird</target>
        </trans-unit>
        <trans-unit id="d5e84648e0355ba1080675ff57a3c64a03a76a7c" translate="yes" xml:space="preserve">
          <source>Thunderbird in particular is known to be problematic. Thunderbird users may wish to visit this web page for more information: &lt;a href=&quot;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&quot;&gt;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&lt;/a&gt;</source>
          <target state="translated">尤其是雷鸟是有问题的。Thunderbird用户可能希望访问此网页以获取更多信息：&lt;a href=&quot;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&quot;&gt;http&lt;/a&gt; : //kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email</target>
        </trans-unit>
        <trans-unit id="da473e9b687406079cfbc2672fddb50595865b5d" translate="yes" xml:space="preserve">
          <source>Thus we see that this tree has one file in it. The SHA-1 hash is a reference to that file&amp;rsquo;s data:</source>
          <target state="translated">因此，我们看到该树中有一个文件。SHA-1哈希是对该文件数据的引用：</target>
        </trans-unit>
        <trans-unit id="309fb29079c2e5019b9d34cb235aee0452735a40" translate="yes" xml:space="preserve">
          <source>Thus you can, e.g., turn a library subdirectory into a repository of its own. Note the &lt;code&gt;--&lt;/code&gt; that separates &lt;code&gt;filter-branch&lt;/code&gt; options from revision options, and the &lt;code&gt;--all&lt;/code&gt; to rewrite all branches and tags.</source>
          <target state="translated">因此，您可以，例如，将库子目录变成其自己的存储库。请注意 &lt;code&gt;--&lt;/code&gt; 将 &lt;code&gt;filter-branch&lt;/code&gt; 选项与修订选项分开，以及 &lt;code&gt;--all&lt;/code&gt; 重写所有分支和标记。</target>
        </trans-unit>
        <trans-unit id="d35ca4f0ad7715e9f69a7f979c2424eb99273503" translate="yes" xml:space="preserve">
          <source>Thus, the following command:</source>
          <target state="translated">因此,下面的命令。</target>
        </trans-unit>
        <trans-unit id="77cc1ec67e1af48d92e062ee397960be200bdf58" translate="yes" xml:space="preserve">
          <source>Thus, we can provide O(log N) lookup time for any number of packfiles.</source>
          <target state="translated">因此,我们可以为任何数量的packfiles提供O(log N)的查找时间。</target>
        </trans-unit>
        <trans-unit id="ae19d34e63a0724afdaaeabe3d0fe80af7f9e778" translate="yes" xml:space="preserve">
          <source>Time and date specified by the ISO 8601 standard, for example &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;. The parser accepts a space instead of the &lt;code&gt;T&lt;/code&gt; character as well.</source>
          <target state="translated">ISO 8601标准指定的时间和日期，例如 &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; 。解析器也接受空格而不是 &lt;code&gt;T&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="3919d9be78625e6edbfd2764a9b0e03204c6c677" translate="yes" xml:space="preserve">
          <source>Time and date specified by the ISO 8601 standard, for example &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;. The parser accepts a space instead of the &lt;code&gt;T&lt;/code&gt; character as well. Fractional parts of a second will be ignored, for example &lt;code&gt;2005-04-07T22:13:13.019&lt;/code&gt; will be treated as &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bac72478f018c225224e8417f521a2dad6209d3" translate="yes" xml:space="preserve">
          <source>Time zone values can be &quot;local&quot; (for local time zone that browser uses), &quot;utc&quot; (what gitweb uses when JavaScript or this feature is disabled), or numerical time zones in the form of &quot;+/-HHMM&quot;, such as &quot;+0200&quot;.</source>
          <target state="translated">时区值可以是 &quot;local&quot;(浏览器使用的本地时区)、&quot;utc&quot; (当JavaScript或此功能被禁用时,gitweb使用的),或 &quot;+/-hhmm &quot;形式的数字时区,如 &quot;+0200&quot;。</target>
        </trans-unit>
        <trans-unit id="396a560fd1658574279d941c34737eda5359f4fc" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) between the moment the connection is established and the client request is received (typically a rather low value, since that should be basically immediate).</source>
          <target state="translated">从建立连接到收到客户端请求之间的超时时间(以秒为单位)(通常是一个相当低的值,因为这基本上应该是即时的)。</target>
        </trans-unit>
        <trans-unit id="0ae2f4dfeb0fa0aaf2833b3c271308d2190a4162" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) for specific client sub-requests. This includes the time it takes for the server to process the sub-request and the time spent waiting for the next client&amp;rsquo;s request.</source>
          <target state="translated">特定客户端子请求的超时（以秒为单位）。这包括服务器处理子请求所花费的时间以及等待下一个客户端请求所花费的时间。</target>
        </trans-unit>
        <trans-unit id="ad6b83abe0aada0e5e6aec8e7e7470429fd4ee37" translate="yes" xml:space="preserve">
          <source>Tips and tricks</source>
          <target state="translated">提示和技巧</target>
        </trans-unit>
        <trans-unit id="d7242682d2f91b131962f45ed3706e536d3cdcc6" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; more than two &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;.</source>
          <target state="translated">要&lt;a href=&quot;#def_merge&quot;&gt;合并&lt;/a&gt;两个以上的&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7305ba472ceab96976009902e7b731f8e52f311" translate="yes" xml:space="preserve">
          <source>To access refs, it&amp;rsquo;s best not to look inside &lt;code&gt;$GIT_DIR&lt;/code&gt; directly. Instead use commands such as &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; or &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref[1]&lt;/a&gt; which will handle refs correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c181af3380fe2a4df836df7796a5de6ef8d47c5" translate="yes" xml:space="preserve">
          <source>To access refs, it&amp;rsquo;s best not to look inside GIT_DIR directly. Instead use commands such as &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; or &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref[1]&lt;/a&gt; which will handle refs correctly.</source>
          <target state="translated">要访问引用，最好不要直接查看GIT_DIR。而是使用诸如&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt;或&lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref [1]之类的命令&lt;/a&gt;来正确处理引用。</target>
        </trans-unit>
        <trans-unit id="bdc5ec95e827bdeffd1f9aab0bef5dd1e05d0443" translate="yes" xml:space="preserve">
          <source>To achieve this, try to split your work into small steps from the very beginning. It is always easier to squash a few commits together than to split one big commit into several. Don&amp;rsquo;t be afraid of making too small or imperfect steps along the way. You can always go back later and edit the commits with &lt;code&gt;git rebase --interactive&lt;/code&gt; before you publish them. You can use &lt;code&gt;git stash push --keep-index&lt;/code&gt; to run the test suite independent of other uncommitted changes; see the EXAMPLES section of &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">为此，请从一开始就尝试将您的工作分成几个小步骤。将几个提交挤压在一起总是比将一个大提交分成几份要容易得多。不要害怕沿途走得太小或不完美。您始终可以稍后再返回，并在发布之前使用 &lt;code&gt;git rebase --interactive&lt;/code&gt; 编辑提交。您可以使用 &lt;code&gt;git stash push --keep-index&lt;/code&gt; 独立于其他未提交的更改来运行测试套件。参见&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;的示例部分。</target>
        </trans-unit>
        <trans-unit id="0fad63887775e60c970096082173b077cbcda459" translate="yes" xml:space="preserve">
          <source>To actually match only values with an exclamation mark, you have to</source>
          <target state="translated">要想实际只匹配带感叹号的值,你需要</target>
        </trans-unit>
        <trans-unit id="0fea0d3a69770ac7053eba17165f8f811c0d830f" translate="yes" xml:space="preserve">
          <source>To add a new proxy, without altering any of the existing ones, use</source>
          <target state="translated">要添加一个新的代理,而不改变任何现有的代理,使用</target>
        </trans-unit>
        <trans-unit id="6a37f3f129452efb4608e170beca8c23ff8dc189" translate="yes" xml:space="preserve">
          <source>To aid in debugging frontends fast-import ignores any line that begins with &lt;code&gt;#&lt;/code&gt; (ASCII pound/hash) up to and including the line ending &lt;code&gt;LF&lt;/code&gt;. A comment line may contain any sequence of bytes that does not contain an LF and therefore may be used to include any detailed debugging information that might be specific to the frontend and useful when inspecting a fast-import data stream.</source>
          <target state="translated">为了帮助调试前端，快速导入会忽略任何以 &lt;code&gt;#&lt;/code&gt; （ASCII磅/哈希）开头的行，直到 &lt;code&gt;LF&lt;/code&gt; 为止。注释行可以包含不包含LF的任何字节序列，因此可以用来包含任何详细的调试信息，这些信息可能特定于前端，并且在检查快速导入数据流时很有用。</target>
        </trans-unit>
        <trans-unit id="285359187a2aff04e4ea763b2f3e4bbaf641190b" translate="yes" xml:space="preserve">
          <source>To assist in this, Git also provides the tag object&amp;hellip;​</source>
          <target state="translated">为此，Git还提供了标签对象...</target>
        </trans-unit>
        <trans-unit id="39ed0e01aa6b6521a62db21f8653937d0b5ccadd" translate="yes" xml:space="preserve">
          <source>To avoid common misconfiguration mistakes, &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; will abort with a warning if any configuration options for &quot;sendmail&quot; exist. Set this variable to bypass the check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0021f1eb05e23f63eb7ccc2f58c52546ee61585" translate="yes" xml:space="preserve">
          <source>To avoid deadlock, such frontends must completely consume any pending output from &lt;code&gt;progress&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;get-mark&lt;/code&gt;, and &lt;code&gt;cat-blob&lt;/code&gt; before performing writes to fast-import that might block.</source>
          <target state="translated">为避免死锁，此类前端必须完全消耗 &lt;code&gt;progress&lt;/code&gt; ， &lt;code&gt;ls&lt;/code&gt; ， &lt;code&gt;get-mark&lt;/code&gt; 和 &lt;code&gt;cat-blob&lt;/code&gt; 的所有待处理输出，然后再执行可能会阻止的快速导入的写操作。</target>
        </trans-unit>
        <trans-unit id="75e1daad195d404dc835c71216234df4a4676d4e" translate="yes" xml:space="preserve">
          <source>To avoid deleting a shared index file that is still used, its modification time is updated to the current time every time a new split index based on the shared index file is either created or read from.</source>
          <target state="translated">为了避免删除仍在使用的共享索引文件,每次创建或读取基于共享索引文件的新拆分索引时,其修改时间都会更新为当前时间。</target>
        </trans-unit>
        <trans-unit id="0b95bb4f949904cf33707d2a81be23c345f8e5aa" translate="yes" xml:space="preserve">
          <source>To avoid false positives (e.g. when a patch has been removed, and an unrelated patch has been added between two iterations of the same patch series), the cost matrix is extended to allow for that, by adding fixed-cost entries for wholesale deletes/adds.</source>
          <target state="translated">为了避免误报(例如,当一个补丁被删除,而在同一补丁系列的两次迭代之间又增加了一个不相关的补丁),成本矩阵进行了扩展,增加了大量删除/增加补丁的固定成本条目,以考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="0fd573776931ed5e5643654b60eb3896366ed973" translate="yes" xml:space="preserve">
          <source>To avoid interfering with other worktrees, it first enables the &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; setting and makes sure to set the &lt;code&gt;core.sparseCheckout&lt;/code&gt; setting in the worktree-specific config file.</source>
          <target state="translated">为了避免干扰其他工作树，它首先启用 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 设置，并确保在特定于工作树的配置文件中设置 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="3c2082115575958e10a9c1afdaf9ab0c9127b12a" translate="yes" xml:space="preserve">
          <source>To avoid recording unrelated changes in the merge commit, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; will also abort if there are any changes registered in the index relative to the &lt;code&gt;HEAD&lt;/code&gt; commit. (Special narrow exceptions to this rule may exist depending on which merge strategy is in use, but generally, the index must match HEAD.)</source>
          <target state="translated">为了避免在合并提交中记录无关的更改，如果在索引中相对于 &lt;code&gt;HEAD&lt;/code&gt; 提交注册了任何更改，则 &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git merge&lt;/code&gt; 也将中止。（根据所使用的合并策略，可能存在此规则的特殊狭义例外，但通常，索引必须与HEAD匹配。）</target>
        </trans-unit>
        <trans-unit id="3066556f3c40d15744968614a5fc8c1e23bf8a7b" translate="yes" xml:space="preserve">
          <source>To avoid typing long email addresses, point this to one or more email aliases files. You must also supply &lt;code&gt;sendemail.aliasFileType&lt;/code&gt;.</source>
          <target state="translated">为避免输入长电子邮件地址，请将其指向一个或多个电子邮件别名文件。您还必须提供 &lt;code&gt;sendemail.aliasFileType&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4b87fbf313d264308ea989e0e3b9a4c3d776c25" translate="yes" xml:space="preserve">
          <source>To bootstrap the process, you can first create a bundle that does not have any basis. You can use a tag to remember up to what commit you last processed, in order to make it easy to later update the other repository with an incremental bundle:</source>
          <target state="translated">为了引导这个过程,你可以先创建一个没有任何基础的 bundle。你可以使用一个标签来记住你最后处理的提交,以便于以后用一个增量的捆绑更新其他仓库。</target>
        </trans-unit>
        <trans-unit id="9d8840568125195e79747db7654d577582e9ce27" translate="yes" xml:space="preserve">
          <source>To change which notes are shown by &lt;code&gt;git log&lt;/code&gt;, see the &quot;notes.displayRef&quot; configuration in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">要更改 &lt;code&gt;git log&lt;/code&gt; 显示的注释，请参阅&lt;a href=&quot;git-log&quot;&gt;git-log [1]中&lt;/a&gt;的&amp;ldquo; notes.displayRef&amp;rdquo;配置。</target>
        </trans-unit>
        <trans-unit id="97883ec3271fcc02269394ee0880b3655a6f452f" translate="yes" xml:space="preserve">
          <source>To check out commit &lt;code&gt;HEAD~3&lt;/code&gt; for temporary inspection or experiment without creating a new branch:</source>
          <target state="translated">要在不创建新分支的情况下签出 &lt;code&gt;HEAD~3&lt;/code&gt; 进行临时检查或实验：</target>
        </trans-unit>
        <trans-unit id="d144f3be27bf6711b21fc83fdbf3f1e8ff9fc321" translate="yes" xml:space="preserve">
          <source>To commit a tree you have instantiated with &lt;code&gt;git write-tree&lt;/code&gt;, you&amp;rsquo;d create a &quot;commit&quot; object that refers to that tree and the history behind it&amp;mdash;​most notably the &quot;parent&quot; commits that preceded it in history.</source>
          <target state="translated">要提交使用 &lt;code&gt;git write-tree&lt;/code&gt; 实例化的树，您需要创建一个``提交''对象，该对象引用该树及其背后的历史记录-最值得注意的是在历史记录之前的``父''提交。</target>
        </trans-unit>
        <trans-unit id="05e44c536d85ee3801aa2c0d698cefa8d09c4c33" translate="yes" xml:space="preserve">
          <source>To completely remove a submodule, manually delete &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt;.</source>
          <target state="translated">要完全删除子模块，请手动删除 &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27c15a86c7e79c3805e163825e563ceb0da18b5a" translate="yes" xml:space="preserve">
          <source>To control which revisions to show, gitk supports most options applicable to the &lt;code&gt;git rev-list&lt;/code&gt; command. It also supports a few options applicable to the &lt;code&gt;git diff-*&lt;/code&gt; commands to control how the changes each commit introduces are shown. Finally, it supports some gitk-specific options.</source>
          <target state="translated">为了控制显示哪些修订，gitk支持适用于 &lt;code&gt;git rev-list&lt;/code&gt; 命令的大多数选项。它还支持适用于 &lt;code&gt;git diff-*&lt;/code&gt; 命令的一些选项，以控制如何显示每次提交引入的更改。最后，它支持一些特定于gitk的选项。</target>
        </trans-unit>
        <trans-unit id="777e371b82028c9765bc912013f44d79febb95a6" translate="yes" xml:space="preserve">
          <source>To cope with such a situation, after the inner &lt;code&gt;git bisect&lt;/code&gt; finds the next revision to test, the script can apply the patch before compiling, run the real test, and afterwards decide if the revision (possibly with the needed patch) passed the test and then rewind the tree to the pristine state. Finally the script should exit with the status of the real test to let the &lt;code&gt;git bisect run&lt;/code&gt; command loop determine the eventual outcome of the bisect session.</source>
          <target state="translated">为了解决这种情况，在内部 &lt;code&gt;git bisect&lt;/code&gt; 找到下一个要测试的修订版本之后，脚本可以在编译之前应用补丁，运行真实测试，然后确定该修订版本（可能带有所需的补丁）是否通过了测试，并且然后将树倒回原始状态。最后，脚本应以真实测试的状态退出，以使 &lt;code&gt;git bisect run&lt;/code&gt; 命令循环确定bisect会话的最终结果。</target>
        </trans-unit>
        <trans-unit id="8674c1ca562e6ecc34e19d2429ea897e7602bd28" translate="yes" xml:space="preserve">
          <source>To create your own local live copy of such a &quot;raw&quot; Git repository, you&amp;rsquo;d first create your own subdirectory for the project, and then copy the raw repository contents into the &lt;code&gt;.git&lt;/code&gt; directory. For example, to create your own copy of the Git repository, you&amp;rsquo;d do the following</source>
          <target state="translated">要创建此类&amp;ldquo;原始&amp;rdquo; Git存储库的本地实时副本，您首先需要为项目创建自己的子目录，然后将原始存储库内容复制到 &lt;code&gt;.git&lt;/code&gt; 目录中。例如，要创建自己的Git存储库副本，请执行以下操作</target>
        </trans-unit>
        <trans-unit id="495be7922d2a293092e6f366efd8045104e01478" translate="yes" xml:space="preserve">
          <source>To define a custom merge driver &lt;code&gt;filfre&lt;/code&gt;, add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">要定义自定义合并驱动程序 &lt;code&gt;filfre&lt;/code&gt; ，请在 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件（或 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 文件）中添加一个部分，如下所示：</target>
        </trans-unit>
        <trans-unit id="369d97c17e3edbb633e139fcbb4d6a1ea94c1201" translate="yes" xml:space="preserve">
          <source>To define an external diff driver &lt;code&gt;jcdiff&lt;/code&gt;, add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">要定义外部diff驱动程序 &lt;code&gt;jcdiff&lt;/code&gt; ，请在 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件（或 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 文件）中添加一个部分，如下所示：</target>
        </trans-unit>
        <trans-unit id="302897a013466c7a33ee45af87c508a98422abd4" translate="yes" xml:space="preserve">
          <source>To delete the entry for renames, do</source>
          <target state="translated">要删除重名的条目,请执行</target>
        </trans-unit>
        <trans-unit id="f31f6b0ae1c80bea942e287ae0ab318c31ede1f4" translate="yes" xml:space="preserve">
          <source>To determine the location of the repository on disk, &lt;code&gt;git http-backend&lt;/code&gt; concatenates the environment variables PATH_INFO, which is set automatically by the web server, and GIT_PROJECT_ROOT, which must be set manually in the web server configuration. If GIT_PROJECT_ROOT is not set, &lt;code&gt;git http-backend&lt;/code&gt; reads PATH_TRANSLATED, which is also set automatically by the web server.</source>
          <target state="translated">为了确定存储库在磁盘上的位置， &lt;code&gt;git http-backend&lt;/code&gt; 将环境变量PATH_INFO（由Web服务器自动设置）和GIT_PROJECT_ROOT串联在一起，后者必须在Web服务器配置中手动设置。如果未设置GIT_PROJECT_ROOT，则 &lt;code&gt;git http-backend&lt;/code&gt; 会读取PATH_TRANSLATED，它也会由Web服务器自动设置。</target>
        </trans-unit>
        <trans-unit id="b99f7180a07f9dbb13dde063c76c98dd5e2d7887" translate="yes" xml:space="preserve">
          <source>To disable features that accept parameters (are configurable), you need to set this element to empty list i.e. &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">要禁用接受参数的功能（可配置），您需要将此元素设置为空列表，即 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43f3c91605c9cb6d680c0ea9cf4c1bb2e77b4d9d" translate="yes" xml:space="preserve">
          <source>To disable interactive logins, displaying a greeting instead:</source>
          <target state="translated">要禁用交互式登录,显示问候语代替。</target>
        </trans-unit>
        <trans-unit id="2e78622c40c98dec97477af783b12ba20d12cc1a" translate="yes" xml:space="preserve">
          <source>To display the &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; man page, use &lt;code&gt;git help git&lt;/code&gt;.</source>
          <target state="translated">要显示&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;手册页，请使用 &lt;code&gt;git help git&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa4dddf358b16e56494c90923230fd025e6f958d" translate="yes" xml:space="preserve">
          <source>To do automatic tag object dereferencing, use the &quot;-d&quot; or &quot;--dereference&quot; flag, so you can do</source>
          <target state="translated">要进行自动的标签对象取消引用,使用&quot;-d &quot;或&quot;--dereference &quot;标志,因此您可以进行以下操作</target>
        </trans-unit>
        <trans-unit id="dc05ce874d6baee1eae11d94d6fd56f1e0a6d0ed" translate="yes" xml:space="preserve">
          <source>To do the merge, do</source>
          <target state="translated">要进行合并,请执行</target>
        </trans-unit>
        <trans-unit id="45ed93b09b65e276ec2ef33a1d9d7c3e10d14bfe" translate="yes" xml:space="preserve">
          <source>To do this, the current maintenance branch is copied to another branch named with the previous release version number (e.g. maint-X.Y.(Z-1) where X.Y.Z is the current release).</source>
          <target state="translated">要做到这一点,当前的维护分支会被复制到另一个以之前的版本号命名的分支上(例如maint-X.Y.(Z-1),其中X.Y.Z是当前的版本)。</target>
        </trans-unit>
        <trans-unit id="380aa6a091a04ad8bbf89399d1982760e370374e" translate="yes" xml:space="preserve">
          <source>To drop a commit, replace the command &quot;pick&quot; with &quot;drop&quot;, or just delete the matching line.</source>
          <target state="translated">要放弃一个提交,将命令 &quot;pick &quot;替换为 &quot;drop&quot;,或者直接删除匹配的行。</target>
        </trans-unit>
        <trans-unit id="e05b8854f808624747710c5e1d641ee4dabaf30c" translate="yes" xml:space="preserve">
          <source>To elaborate, &quot;reading&quot; means checking for file existence, reading file attributes or file content. The working directory version may be present or absent. If present, its content may match against the index version or not. Writing is not affected by this bit, content safety is still first priority. Note that Git &lt;code&gt;can&lt;/code&gt; update working directory file, that is marked skip-worktree, if it is safe to do so (i.e. working directory version matches index version)</source>
          <target state="translated">详细地说，&amp;ldquo;读取&amp;rdquo;是指检查文件是否存在，读取文件属性或文件内容。工作目录版本可能存在或不存在。如果存在，其内容可能与索引版本不匹配。写入不受此位影响，内容安全仍然是第一要务。注意，如果安全的话，Git &lt;code&gt;can&lt;/code&gt; 更新标记为skip-worktree的工作目录文件（例如，工作目录版本与索引版本匹配）。</target>
        </trans-unit>
        <trans-unit id="64ecd7272d648bbcdba5e527a1a80e43cb0705c5" translate="yes" xml:space="preserve">
          <source>To enable &lt;code&gt;git archive --remote&lt;/code&gt; and disable &lt;code&gt;git fetch&lt;/code&gt; against a repository, have the following in the configuration file in the repository (that is the file &lt;code&gt;config&lt;/code&gt; next to &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;refs&lt;/code&gt; and &lt;code&gt;objects&lt;/code&gt;).</source>
          <target state="translated">要对存储库启用 &lt;code&gt;git archive --remote&lt;/code&gt; 并禁用 &lt;code&gt;git fetch&lt;/code&gt; ，请在存储库的配置文件中添加以下内容（即 &lt;code&gt;HEAD&lt;/code&gt; ， &lt;code&gt;refs&lt;/code&gt; 和 &lt;code&gt;objects&lt;/code&gt; 旁边的文件 &lt;code&gt;config&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="af7d8457fff28a2087e0f74bc51d0468026a9bff" translate="yes" xml:space="preserve">
          <source>To enable a target, set the corresponding environment variable or system or global config value to one of the following:</source>
          <target state="translated">要启用目标,请将相应的环境变量或系统或全局配置值设置为以下之一。</target>
        </trans-unit>
        <trans-unit id="01e6eac26c3bbc386ab13c8cd6a9167801f24836" translate="yes" xml:space="preserve">
          <source>To enable anonymous read access but authenticated write access, require authorization for both the initial ref advertisement (which we detect as a push via the service parameter in the query string), and the receive-pack invocation itself:</source>
          <target state="translated">为了实现匿名的读访问,但认证的写访问,需要对初始ref广告(我们通过查询字符串中的service参数检测为推送)和receive-pack调用本身进行授权。</target>
        </trans-unit>
        <trans-unit id="9bda367b82f8881561a1128afb27f36988891c35" translate="yes" xml:space="preserve">
          <source>To enable anonymous read access but authenticated write access:</source>
          <target state="translated">启用匿名读取访问,但允许认证的写入访问。</target>
        </trans-unit>
        <trans-unit id="050d5472dcd3f05f019f9a8129d0bb6d5e205df8" translate="yes" xml:space="preserve">
          <source>To enable blame, pickaxe search, and snapshot support (allowing &quot;tar.gz&quot; and &quot;zip&quot; snapshots), while allowing individual projects to turn them off, put the following in your GITWEB_CONFIG file:</source>
          <target state="translated">要启用责备、pickaxe搜索和快照支持(允许 &quot;tar.gz &quot;和 &quot;zip &quot;快照),同时允许单个项目关闭它们,请在GITWEB_CONFIG文件中加入以下内容。</target>
        </trans-unit>
        <trans-unit id="fa7174e314ce7012972664ac5bcf82d4b390a6d5" translate="yes" xml:space="preserve">
          <source>To enable git-cvsserver access (which should generally have the &lt;code&gt;no-interactive-login&lt;/code&gt; example above as a prerequisite, as creating the git-shell-commands directory allows interactive logins):</source>
          <target state="translated">要启用git-cvsserver访问（通常应该具有上面的 &lt;code&gt;no-interactive-login&lt;/code&gt; 示例作为先决条件，因为创建git-shell-commands目录允许交互式登录）：</target>
        </trans-unit>
        <trans-unit id="69aa803d2928631745bb26ea6d720a34de175dd7" translate="yes" xml:space="preserve">
          <source>To enable that additional nice feature, when a bisection is started and when some good commits are not ancestors of the bad commit, we first compute the merge bases between the bad and the good commits and we chose these merge bases as the first commits that will be checked out and tested.</source>
          <target state="translated">为了实现这个额外的好功能,当开始一分为二的时候,当一些好的提交不是坏的提交的祖先时,我们首先计算坏的提交和好的提交之间的合并基数,我们选择这些合并基数作为首先要检查和测试的提交。</target>
        </trans-unit>
        <trans-unit id="ba44f6ad0a0230b79b3149aabc029b57fd7f22d9" translate="yes" xml:space="preserve">
          <source>To enable the sparse-checkout feature, run &lt;code&gt;git sparse-checkout init&lt;/code&gt; to initialize a simple sparse-checkout file and enable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; config setting. Then, run &lt;code&gt;git sparse-checkout set&lt;/code&gt; to modify the patterns in the sparse-checkout file.</source>
          <target state="translated">要启用稀疏签出功能，请运行 &lt;code&gt;git sparse-checkout init&lt;/code&gt; 初始化一个简单的稀疏签出文件并启用 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 配置设置。然后，运行 &lt;code&gt;git sparse-checkout set&lt;/code&gt; 来修改sparse-checkout文件中的模式。</target>
        </trans-unit>
        <trans-unit id="1318b73efc503f41a06d5d140c646ee25cf7e427" translate="yes" xml:space="preserve">
          <source>To exclude commits reachable from a commit, a prefix &lt;code&gt;^&lt;/code&gt; notation is used. E.g. &lt;code&gt;^r1 r2&lt;/code&gt; means commits reachable from &lt;code&gt;r2&lt;/code&gt; but exclude the ones reachable from &lt;code&gt;r1&lt;/code&gt; (i.e. &lt;code&gt;r1&lt;/code&gt; and its ancestors).</source>
          <target state="translated">为了从提交中排除可到达的提交，使用前缀 &lt;code&gt;^&lt;/code&gt; 表示法。例如 &lt;code&gt;^r1 r2&lt;/code&gt; 表示可从 &lt;code&gt;r2&lt;/code&gt; 到达的提交，但不包括可从 &lt;code&gt;r1&lt;/code&gt; 到达的提交（即 &lt;code&gt;r1&lt;/code&gt; 及其祖先）。</target>
        </trans-unit>
        <trans-unit id="a12d809ea9b20c2b561957b059e3fe943cb6e440" translate="yes" xml:space="preserve">
          <source>To find out how the result can be used, just read on in &lt;code&gt;cmd_cat_file()&lt;/code&gt;:</source>
          <target state="translated">要了解如何使用结果，只需在 &lt;code&gt;cmd_cat_file()&lt;/code&gt; 中继续阅读：</target>
        </trans-unit>
        <trans-unit id="338cdf0c3d82152dc96e1eae9cd9922bf736e76c" translate="yes" xml:space="preserve">
          <source>To get a checkout with the Eclipse CVS client:</source>
          <target state="translated">要用Eclipse CVS客户端进行结账。</target>
        </trans-unit>
        <trans-unit id="976f859125db1311d8f82bb8df703ef2ad537fd0" translate="yes" xml:space="preserve">
          <source>To get a reminder of the currently used terms, use</source>
          <target state="translated">要获得当前使用的术语的提醒,使用</target>
        </trans-unit>
        <trans-unit id="68b714c59ff5898ff58433a2938d52aeb27df43e" translate="yes" xml:space="preserve">
          <source>To get started with gitweb, run &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; from a Git repository. This would configure and start your web server, and run web browser pointing to gitweb.</source>
          <target state="translated">要开始使用gitweb，请从Git存储库运行&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;。这将配置并启动您的Web服务器，并运行指向gitweb的Web浏览器。</target>
        </trans-unit>
        <trans-unit id="bf62a03860b36b4b6a615592146052d88035a5f4" translate="yes" xml:space="preserve">
          <source>To get the &quot;base&quot; for the merge, look up the common parent of two commits:</source>
          <target state="translated">要想得到合并的 &quot;基数&quot;,就要查找两个提交的共同父体。</target>
        </trans-unit>
        <trans-unit id="ec1f343ca45777aa33e95b7222bfb7658aa36062" translate="yes" xml:space="preserve">
          <source>To get the feature/bugfix into an integration branch, simply merge it. If the topic has evolved further in the meantime, merge again. (Note that you do not necessarily have to merge it to the oldest integration branch first. For example, you can first merge a bugfix to &lt;code&gt;next&lt;/code&gt;, give it some testing time, and merge to &lt;code&gt;maint&lt;/code&gt; when you know it is stable.)</source>
          <target state="translated">要将功能/错误修正纳入集成分支，只需将其合并即可。如果与此同时话题进一步发展，请再次合并。（请注意，您不必一定要先将其合并到最早的集成分支。例如，您可以先将bugfix合并到 &lt;code&gt;next&lt;/code&gt; ，给它一些测试时间，然后在知道稳定后合并到 &lt;code&gt;maint&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="60ae758b58fc83602f1720fb9cc2f0f4fb30b090" translate="yes" xml:space="preserve">
          <source>To give some hard figures, we used to have an average report-to-fix cycle of 142.6 hours (according to our somewhat weird bug-tracker which just measures wall-clock time). Since we moved to Git, we&amp;rsquo;ve lowered that to 16.2 hours. Primarily because we can stay on top of the bug fixing now, and because everyone&amp;rsquo;s jockeying to get to fix bugs (we&amp;rsquo;re quite proud of how lazy we are to let Git find the bugs for us). Each new release results in ~40% fewer bugs (almost certainly due to how we now feel about writing tests).</source>
          <target state="translated">为了给出一些确切的数字，我们以前的平均报告到修复周期为142.6小时（根据我们有些奇怪的bug跟踪器（它仅测量挂钟时间））。自从我们迁移到Git以来，我们将其降低到16.2小时。主要是因为我们现在可以保持在bug修复的最前沿，并且因为每个人都在努力修复bug（我们为让Git为我们找到bug感到很懒惰而感到自豪）。每个新版本都会减少大约40％的错误（几乎可以肯定，这是由于我们现在对编写测试的感觉所致）。</target>
        </trans-unit>
        <trans-unit id="cc855cb566c405d222e3a3236275bbad376833c3" translate="yes" xml:space="preserve">
          <source>To help with that, &lt;code&gt;range&lt;/code&gt; uses the &lt;code&gt;--dual-color&lt;/code&gt; mode by default. In this mode, the diff of diffs will retain the original diff colors, and prefix the lines with -/+ markers that have their &lt;strong&gt;background&lt;/strong&gt; red or green, to make it more obvious that they describe how the diff itself changed.</source>
          <target state="translated">为了解决这个问题， &lt;code&gt;range&lt;/code&gt; 默认使用 &lt;code&gt;--dual-color&lt;/code&gt; 模式。在此模式下，差异的差异将保留原始差异颜色，并在带有-/ +标记的行前加上&lt;strong&gt;背景为&lt;/strong&gt;红色或绿色的标记，以使其更明显地描述差异本身的变化。</target>
        </trans-unit>
        <trans-unit id="096c5d9029f3f58b2af501ec17fb5d42ac0f73fe" translate="yes" xml:space="preserve">
          <source>To illustrate the difference between &lt;code&gt;-S&amp;lt;regex&amp;gt; --pickaxe-regex&lt;/code&gt; and &lt;code&gt;-G&amp;lt;regex&amp;gt;&lt;/code&gt;, consider a commit with the following diff in the same file:</source>
          <target state="translated">为了说明 &lt;code&gt;-S&amp;lt;regex&amp;gt; --pickaxe-regex&lt;/code&gt; 和 &lt;code&gt;-G&amp;lt;regex&amp;gt;&lt;/code&gt; 之间的区别，请考虑在同一文件中包含以下差异的提交：</target>
        </trans-unit>
        <trans-unit id="e67d6de21feaa90def83753eb253a23faea561fa" translate="yes" xml:space="preserve">
          <source>To illustrate, suppose you are in a situation where someone develops a &lt;code&gt;subsystem&lt;/code&gt; branch, and you are working on a &lt;code&gt;topic&lt;/code&gt; that is dependent on this &lt;code&gt;subsystem&lt;/code&gt;. You might end up with a history like the following:</source>
          <target state="translated">为了进行说明，假设您处于有人开发 &lt;code&gt;subsystem&lt;/code&gt; 分支的情况，并且您正在研究一个依赖于该 &lt;code&gt;subsystem&lt;/code&gt; 的 &lt;code&gt;topic&lt;/code&gt; 。您可能会得到如下所示的历史记录：</target>
        </trans-unit>
        <trans-unit id="a98d25733140cb4450fff563f123b0d4cafeb9f9" translate="yes" xml:space="preserve">
          <source>To interrupt the rebase (just like an &quot;edit&quot; command would do, but without cherry-picking any commit first), use the &quot;break&quot; command.</source>
          <target state="translated">要中断rebase(就像 &quot;edit &quot;命令一样,但不需要先挑出任何提交),使用 &quot;break &quot;命令。</target>
        </trans-unit>
        <trans-unit id="f6408dba3913ebdb903fdfce1d68f1906d3e56f0" translate="yes" xml:space="preserve">
          <source>To look at only non-zero stages, use &lt;code&gt;--unmerged&lt;/code&gt; flag:</source>
          <target state="translated">要仅查看非零阶段，请使用 &lt;code&gt;--unmerged&lt;/code&gt; 标志：</target>
        </trans-unit>
        <trans-unit id="5b273f729e50c3bb1996889c896c925cce764cd8" translate="yes" xml:space="preserve">
          <source>To make it readable, we can tell &lt;code&gt;git diff-files&lt;/code&gt; to output the differences as a patch, using the &lt;code&gt;-p&lt;/code&gt; flag:</source>
          <target state="translated">为了使其可读，我们可以使用 &lt;code&gt;-p&lt;/code&gt; 标志告诉 &lt;code&gt;git diff-files&lt;/code&gt; 将差异作为补丁输出：</target>
        </trans-unit>
        <trans-unit id="9fa7b34f2837aaeca157590c3f1e04cfe3400ecb" translate="yes" xml:space="preserve">
          <source>To make referencing the final pathname simpler, you can map each path component; so if you also anonymize &lt;code&gt;subdir&lt;/code&gt; to &lt;code&gt;publicdir&lt;/code&gt;, then the final pathname would be &lt;code&gt;publicdir/bar.c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5411ef1231b1da2dbabaf49f4348af685832f2f7" translate="yes" xml:space="preserve">
          <source>To move the whole tree into a subdirectory, or remove it from there:</source>
          <target state="translated">要将整棵树移到子目录中,或从子目录中删除它。</target>
        </trans-unit>
        <trans-unit id="9fef1883cb2bb53007927c93e3d8f7431145efad" translate="yes" xml:space="preserve">
          <source>To perform a three-way merge, you start with the two commits you want to merge, find their closest common parent (a third commit), and compare the trees corresponding to these three commits.</source>
          <target state="translated">要执行三向合并,先从要合并的两个提交开始,找到它们最接近的共同父代(第三个提交),然后比较这三个提交对应的树。</target>
        </trans-unit>
        <trans-unit id="a35f3e8a10774da4c0b0f3f87118660d7ef9889e" translate="yes" xml:space="preserve">
          <source>To place a higher stage entry to the index, the path should first be removed by feeding a mode=0 entry for the path, and then feeding necessary input lines in the third format.</source>
          <target state="translated">如果要将更高阶段的条目放到索引中,应先为路径输入一个mode=0的条目,然后再以第三种格式输入必要的输入行,将路径删除。</target>
        </trans-unit>
        <trans-unit id="26b0cbf1bc1090821ae6f59cac15f02ec7f562f8" translate="yes" xml:space="preserve">
          <source>To prepare for working on &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, switch to it by updating the index and the files in the working tree, and by pointing &lt;code&gt;HEAD&lt;/code&gt; at the branch. Local modifications to the files in the working tree are kept, so that they can be committed to the &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">要准备在 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 上工作，请通过更新工作树中的索引和文件，并将 &lt;code&gt;HEAD&lt;/code&gt; 指向分支来切换到该分支。保留对工作树中文件的本地修改，以便可以将其提交给 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13739c43ac679e23fc4c2d09478ac31e5293cb15" translate="yes" xml:space="preserve">
          <source>To pretend you have a file at path with mode and sha1, say:</source>
          <target state="translated">假设你在路径上有一个文件,用mode和sha1,比如。</target>
        </trans-unit>
        <trans-unit id="6785e6ba620455f331d4a09eb8363e2600eabf25" translate="yes" xml:space="preserve">
          <source>To prevent a $GIT_DIR/worktrees entry from being pruned (which can be useful in some situations, such as when the entry&amp;rsquo;s working tree is stored on a portable device), use the &lt;code&gt;git worktree lock&lt;/code&gt; command, which adds a file named &lt;code&gt;locked&lt;/code&gt; to the entry&amp;rsquo;s directory. The file contains the reason in plain text. For example, if a linked working tree&amp;rsquo;s &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; then a file named &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; will prevent the &lt;code&gt;test-next&lt;/code&gt; entry from being pruned. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for details.</source>
          <target state="translated">为了防止修剪$ GIT_DIR / worktrees条目（在某些情况下（例如，该条目的工作树存储在便携式设备上时，这 &lt;code&gt;git worktree lock&lt;/code&gt; 用）），请使用git worktree lock命令，该命令将一个名为 &lt;code&gt;locked&lt;/code&gt; 的文件添加到条目的目录。该文件以纯文本形式包含原因。例如，如果链接的工作树的 &lt;code&gt;.git&lt;/code&gt; 文件指向 &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; ,则名为 &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; 的文件将阻止 &lt;code&gt;test-next&lt;/code&gt; 删除下一个条目。有关详细信息，请参见&lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af2e73e27abe3e4382121e1f7c2af8f2dfcf3321" translate="yes" xml:space="preserve">
          <source>To prevent a &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; entry from being pruned (which can be useful in some situations, such as when the entry&amp;rsquo;s working tree is stored on a portable device), use the &lt;code&gt;git worktree lock&lt;/code&gt; command, which adds a file named &lt;code&gt;locked&lt;/code&gt; to the entry&amp;rsquo;s directory. The file contains the reason in plain text. For example, if a linked working tree&amp;rsquo;s &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; then a file named &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; will prevent the &lt;code&gt;test-next&lt;/code&gt; entry from being pruned. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ac404b2baca4d3a659bb0594db0c41828389ed" translate="yes" xml:space="preserve">
          <source>To prevent these unnecessary merge conflicts, Git can be told to run a virtual check-out and check-in of all three stages of a file when resolving a three-way merge by setting the &lt;code&gt;merge.renormalize&lt;/code&gt; configuration variable. This prevents changes caused by check-in conversion from causing spurious merge conflicts when a converted file is merged with an unconverted file.</source>
          <target state="translated">为了防止这些不必要的合并冲突，在通过设置 &lt;code&gt;merge.renormalize&lt;/code&gt; 配置变量来解决三向合并时，可以告诉Git对文件的所有三个阶段运行虚拟检出和检入。当转换后的文件与未转换的文件合并时，这可以防止由签入转换引起的更改引起虚假合并冲突。</target>
        </trans-unit>
        <trans-unit id="91d260766aee213709a415223ac206b93100d7d5" translate="yes" xml:space="preserve">
          <source>To prune objects not used by your repository or another that borrows from your repository via its &lt;code&gt;.git/objects/info/alternates&lt;/code&gt;:</source>
          <target state="translated">要修剪存储库或通过其 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; 从存储库借用的另一个对象未​​使用的对象，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="2f63f42b98c259e7fd0384dd68939f7fc302c5eb" translate="yes" xml:space="preserve">
          <source>To prune references as part of your normal workflow without needing to remember to run that, set &lt;code&gt;fetch.prune&lt;/code&gt; globally, or &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; per-remote in the config. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">要在正常工作流程中修剪引用而不需要记住运行该引用，请在 &lt;code&gt;fetch.prune&lt;/code&gt; 全局设置fetch.prune或 &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; per-remote。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68bfae2792009c9d944a67bd77b4854e1c8c4d3e" translate="yes" xml:space="preserve">
          <source>To put the loose objects into a pack, just run git repack:</source>
          <target state="translated">要把松散的对象放入包中,只需运行git repack即可。</target>
        </trans-unit>
        <trans-unit id="8344caf5b982f9b0d4dc99f7ff5aa708ff0b3592" translate="yes" xml:space="preserve">
          <source>To query the value for a given key, do</source>
          <target state="translated">要查询一个给定的键的值,请执行</target>
        </trans-unit>
        <trans-unit id="6d7c1598e59e901d58d9b961c14fa449c82ef069" translate="yes" xml:space="preserve">
          <source>To reapply a series of changes from a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; to a different base, and reset the &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; of that branch to the result.</source>
          <target state="translated">要重新应用从&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;到其他基准的一系列更改，并将该分支的&lt;a href=&quot;#def_head&quot;&gt;开头&lt;/a&gt;重置为结果。</target>
        </trans-unit>
        <trans-unit id="25388a0bc929e9a0e4d2bb9d4d113e8444bb02a5" translate="yes" xml:space="preserve">
          <source>To remove a file from the index and from the working tree, use</source>
          <target state="translated">要从索引和工作树中删除一个文件,请使用</target>
        </trans-unit>
        <trans-unit id="c7850646e909d85f101794190a2e6f7a699e3e90" translate="yes" xml:space="preserve">
          <source>To remove commits authored by &quot;Darl McBribe&quot; from the history:</source>
          <target state="translated">从历史记录中删除 &quot;Darl McBribe &quot;撰写的提交。</target>
        </trans-unit>
        <trans-unit id="65692943c43d72ea453917ea884fccf3994fb56e" translate="yes" xml:space="preserve">
          <source>To remove selection, prefix the input with &lt;code&gt;-&lt;/code&gt; like this:</source>
          <target state="translated">要删除选择，请在输入之前添加 &lt;code&gt;-&lt;/code&gt; ,如下所示：</target>
        </trans-unit>
        <trans-unit id="9e91a512899aa79b93af123e6b1768a526248346" translate="yes" xml:space="preserve">
          <source>To repopulate the working directory with all files, use the &lt;code&gt;git sparse-checkout disable&lt;/code&gt; command.</source>
          <target state="translated">要用所有文件重新填充工作目录，请使用 &lt;code&gt;git sparse-checkout disable&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="5c497720a7ab3ae3ef408305ef475289bc14a521" translate="yes" xml:space="preserve">
          <source>To reproduce the entire p4 history in Git, use the &lt;code&gt;@all&lt;/code&gt; modifier on the depot path:</source>
          <target state="translated">要在Git中重现整个p4历史记录，请在仓库路径上使用 &lt;code&gt;@all&lt;/code&gt; 修饰符：</target>
        </trans-unit>
        <trans-unit id="d4609928d728916d052df2a3b481b65890e4b16e" translate="yes" xml:space="preserve">
          <source>To require authentication for both reads and writes, use a Location directive around the repository, or one of its parent directories:</source>
          <target state="translated">要要求对读和写进行认证,可以在版本库周围使用一个Location指令,或者它的一个父目录。</target>
        </trans-unit>
        <trans-unit id="10ebfb5ceb771c952eff2c39be3b852f1f654421" translate="yes" xml:space="preserve">
          <source>To require authentication for both reads and writes:</source>
          <target state="translated">要求对读和写进行认证。</target>
        </trans-unit>
        <trans-unit id="847928f545abee25f9f8e4e2cc396a049af86735" translate="yes" xml:space="preserve">
          <source>To restore a file in the index to match the version in &lt;code&gt;HEAD&lt;/code&gt; (this is the same as using &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;)</source>
          <target state="translated">恢复索引中的文件以匹配 &lt;code&gt;HEAD&lt;/code&gt; 中的版本（这与使用&lt;a href=&quot;git-reset&quot;&gt;git-reset [1]相同&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="21366b05c441f538e6886570018737e901640e49" translate="yes" xml:space="preserve">
          <source>To restore all files in the current directory</source>
          <target state="translated">要恢复当前目录下的所有文件</target>
        </trans-unit>
        <trans-unit id="0ab7e14988a23edeb341648ca7b63377b3dd49d2" translate="yes" xml:space="preserve">
          <source>To restrict rewriting to only part of the history, specify a revision range in addition to the new branch name. The new branch name will point to the top-most revision that a &lt;code&gt;git rev-list&lt;/code&gt; of this range will print.</source>
          <target state="translated">要将重写限制为仅历史记录的一部分，除了新的分支名称外，还要指定修订范围。新的分支名称将指向此范围的 &lt;code&gt;git rev-list&lt;/code&gt; 将打印的最高修订。</target>
        </trans-unit>
        <trans-unit id="4d880d7fd779c619b85e62692eb083b5f59e932e" translate="yes" xml:space="preserve">
          <source>To rewrite commits E,F,G,H, use one of these:</source>
          <target state="translated">要重写提交E,F,G,H,请使用其中之一。</target>
        </trans-unit>
        <trans-unit id="47b66273feb1f496168989ebee433bebb314fc85" translate="yes" xml:space="preserve">
          <source>To rewrite only commits D,E,F,G,H, but leave A, B and C alone, use:</source>
          <target state="translated">要只重写D,E,F,G,H,而不重写A,B,C,请使用。</target>
        </trans-unit>
        <trans-unit id="8c31d9c011b7c86062de888fb92cc01426b53584" translate="yes" xml:space="preserve">
          <source>To rewrite the repository to look as if &lt;code&gt;foodir/&lt;/code&gt; had been its project root, and discard all other history:</source>
          <target state="translated">要重写存储库，使其看起来好像 &lt;code&gt;foodir/&lt;/code&gt; 已经是其项目根，并丢弃所有其他历史记录：</target>
        </trans-unit>
        <trans-unit id="7c02b2b350476c8c24e25173b62f35a8ad0c0ae3" translate="yes" xml:space="preserve">
          <source>To see how submodule support works, create four example repositories that can be used later as a submodule:</source>
          <target state="translated">为了了解子模块支持是如何工作的,创建四个示例仓库,以后可以作为子模块使用。</target>
        </trans-unit>
        <trans-unit id="700bc56e5656b835e5cd7fa2e5386957dfc66eac" translate="yes" xml:space="preserve">
          <source>To see the currently remaining suspects in &lt;code&gt;gitk&lt;/code&gt;, issue the following command during the bisection process (the subcommand &lt;code&gt;view&lt;/code&gt; can be used as an alternative to &lt;code&gt;visualize&lt;/code&gt;):</source>
          <target state="translated">要查看 &lt;code&gt;gitk&lt;/code&gt; 中当前剩余的可疑对象，请在对分过程中发出以下命令（子命令 &lt;code&gt;view&lt;/code&gt; 可以用作 &lt;code&gt;visualize&lt;/code&gt; 的替代方法）：</target>
        </trans-unit>
        <trans-unit id="faa509deef7fcd4d518cc2cd2e577046b7eb747b" translate="yes" xml:space="preserve">
          <source>To see whether it has already been merged into the test or release branches, use:</source>
          <target state="translated">要查看它是否已经被合并到测试或发布分支中,使用。</target>
        </trans-unit>
        <trans-unit id="1e15ca1368deb202f467e491af7bfdb38f930af4" translate="yes" xml:space="preserve">
          <source>To serve gitweb at the same url, use a ScriptAliasMatch to only those URLs that &lt;code&gt;git http-backend&lt;/code&gt; can handle, and forward the rest to gitweb:</source>
          <target state="translated">要以相同的网址提供gitweb，请使用ScriptAliasMatch仅将 &lt;code&gt;git http-backend&lt;/code&gt; 可以处理的URL 转发给gitweb：</target>
        </trans-unit>
        <trans-unit id="3b5c2b799f6b39d60aa882699fc88e3eb3a77175" translate="yes" xml:space="preserve">
          <source>To serve multiple repositories from different &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; in a single repository:</source>
          <target state="translated">要在单个存储库中提供来自不同&lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt;的多个存储库：</target>
        </trans-unit>
        <trans-unit id="59fa97f902b7761eca14600ff37aff1758dec6bd" translate="yes" xml:space="preserve">
          <source>To set a commit (which typically is at the tip of another history) to be the parent of the current initial commit, in order to paste the other history behind the current history:</source>
          <target state="translated">将一个提交(通常是在另一个历史记录的顶端)设置为当前初始提交的父级,以便将其他历史记录粘贴在当前历史记录的后面。</target>
        </trans-unit>
        <trans-unit id="d091c25539483b5c5b3db274eae656a5f768704a" translate="yes" xml:space="preserve">
          <source>To set the date used in future tag objects, set the environment variable GIT_COMMITTER_DATE (see the later discussion of possible values; the most common form is &quot;YYYY-MM-DD HH:MM&quot;).</source>
          <target state="translated">要设置未来标签对象中使用的日期,请设置环境变量GIT_COMMITTER_DATE(参见后面对可能值的讨论;最常见的形式是 &quot;YYYY-MM-DD HH:MM&quot;)。</target>
        </trans-unit>
        <trans-unit id="0de4847876d8ab04ebb463613f39507d60c3b1a3" translate="yes" xml:space="preserve">
          <source>To set this up, first create your work tree by cloning Linus&amp;rsquo;s public tree:</source>
          <target state="translated">要进行设置，首先通过克隆Linus的公共树来创建工作树：</target>
        </trans-unit>
        <trans-unit id="6fdb47a7575f286ad7a6b8b651d8470ef2c51c01" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as a regular, non-inetd service that handles repositories for multiple virtual hosts based on their IP addresses, start the daemon like this:</source>
          <target state="translated">要将 &lt;code&gt;git daemon&lt;/code&gt; 设置为常规的非inetd服务，该服务根据虚拟主机的IP地址处理多个虚拟主机的存储库，请启动该守护进程，如下所示：</target>
        </trans-unit>
        <trans-unit id="cd4e85b93c0b5a71d973a240463742c429d6ce10" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as an inetd service that handles any repository under the whitelisted set of directories, /pub/foo and /pub/bar, place an entry like the following into /etc/inetd all on one line:</source>
          <target state="translated">要将 &lt;code&gt;git daemon&lt;/code&gt; 设置为可处理列入白名单的目录集/ pub / foo和/ pub / bar下的任何存储库的ine​​td服务，请在/ etc / inetd中将以下内容全部放入一行：</target>
        </trans-unit>
        <trans-unit id="d85d4c6ac447e3ea7881a95ee3354b641502c913" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as an inetd service that handles repositories for different virtual hosts, &lt;code&gt;www.example.com&lt;/code&gt; and &lt;code&gt;www.example.org&lt;/code&gt;, place an entry like the following into &lt;code&gt;/etc/inetd&lt;/code&gt; all on one line:</source>
          <target state="translated">要将 &lt;code&gt;git daemon&lt;/code&gt; 设置为可处理不同虚拟主机的存储库的ine​​td服务，请将 &lt;code&gt;www.example.com&lt;/code&gt; 和 &lt;code&gt;www.example.org&lt;/code&gt; 如下所示的条目放在 &lt;code&gt;/etc/inetd&lt;/code&gt; 中的所有行中：</target>
        </trans-unit>
        <trans-unit id="6d1dfa06a0b2e0253dac9a23d3e763ff2be4729c" translate="yes" xml:space="preserve">
          <source>To shelve changes instead of submitting, use &lt;code&gt;--shelve&lt;/code&gt; and &lt;code&gt;--update-shelve&lt;/code&gt;:</source>
          <target state="translated">要搁置更改而不是提交更改，请使用 &lt;code&gt;--shelve&lt;/code&gt; 和 &lt;code&gt;--update-shelve&lt;/code&gt; shelve：</target>
        </trans-unit>
        <trans-unit id="b19251adc869dd31b98316a2df3ca3e146f58f68" translate="yes" xml:space="preserve">
          <source>To show all references called &quot;master&quot;, whether tags or heads or anything else, and regardless of how deep in the reference naming hierarchy they are, use:</source>
          <target state="translated">要显示所有被称为 &quot;master &quot;的引用,无论是tag、head还是其他任何东西,也不管它们在引用命名层次结构中的位置有多深,请使用。</target>
        </trans-unit>
        <trans-unit id="51ec81ccf2337a76aefa897308cd08d96e515614" translate="yes" xml:space="preserve">
          <source>To show only tags, or only proper branch heads, use &quot;--tags&quot; and/or &quot;--heads&quot; respectively (using both means that it shows tags and heads, but not other random references under the refs/ subdirectory).</source>
          <target state="translated">要只显示标签,或者只显示正确的分支头,分别使用&quot;--tags &quot;和/或&quot;--heads&quot;(使用这两个词意味着它显示标签和头,但不显示refs/子目录下的其他随机引用)。</target>
        </trans-unit>
        <trans-unit id="864f9f1ee17e37f4b3823291b8524eebd5879fc4" translate="yes" xml:space="preserve">
          <source>To show that as an example, let&amp;rsquo;s go back to the git-tutorial repository we used earlier, and create a branch in it. You do that by simply just saying that you want to check out a new branch:</source>
          <target state="translated">为了说明这一点，让我们回到前面使用的git-tutorial存储库，并在其中创建一个分支。您只需说出要签出新的分支即可：</target>
        </trans-unit>
        <trans-unit id="acab411fa1b0a4e2f72e42b537e21a4bc08bf613" translate="yes" xml:space="preserve">
          <source>To simplify the discussion we will suppose that the untestable area is a simple string of commits and that it was created by a breakage introduced by one commit (let&amp;rsquo;s call it BBC for bisect breaking commit) and later fixed by another one (let&amp;rsquo;s call it BFC for bisect fixing commit).</source>
          <target state="translated">为了简化讨论，我们将假设不可测区域是一个简单的提交字符串，它是由一个提交引入的破损创建的（对于二等分断开提交，我们称之为BBC），后来又由另一个提交修复了（称为BFC）。对于等分修复提交）。</target>
        </trans-unit>
        <trans-unit id="975e3a9279c8287bca9f664bbcc61fee7baa93ca" translate="yes" xml:space="preserve">
          <source>To specify a branch other than the current one, use:</source>
          <target state="translated">要指定当前分支以外的分支,请使用。</target>
        </trans-unit>
        <trans-unit id="b6b6e95c2c1acd4004bc280690d73f7c9df3e3b0" translate="yes" xml:space="preserve">
          <source>To specify a namespace, set the &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; environment variable to the namespace. For each ref namespace, Git stores the corresponding refs in a directory under &lt;code&gt;refs/namespaces/&lt;/code&gt;. For example, &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; will store refs under &lt;code&gt;refs/namespaces/foo/&lt;/code&gt;. You can also specify namespaces via the &lt;code&gt;--namespace&lt;/code&gt; option to &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;.</source>
          <target state="translated">要指定名称空间，请将 &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; 环境变量设置为名称空间。对于每个ref名称空间，Git会将相应的refs存储在 &lt;code&gt;refs/namespaces/&lt;/code&gt; 下的目录中。例如， &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; 将引用存储在 &lt;code&gt;refs/namespaces/foo/&lt;/code&gt; 。您还可以通过&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;的 &lt;code&gt;--namespace&lt;/code&gt; 选项指定名称空间。</target>
        </trans-unit>
        <trans-unit id="8d8e0463dddb070b083bcb1d31f0cd304bcae1a2" translate="yes" xml:space="preserve">
          <source>To specify a single commit or a range of commits, use:</source>
          <target state="translated">要指定一个或一系列的提交,请使用。</target>
        </trans-unit>
        <trans-unit id="b6bdd73c5af990a9c308cb3582e6683a673000a9" translate="yes" xml:space="preserve">
          <source>To stop tracking a file that is currently tracked, use &lt;code&gt;git rm --cached&lt;/code&gt;.</source>
          <target state="translated">要停止跟踪当前跟踪的文件，请使用 &lt;code&gt;git rm --cached&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5aabd990937e7026d6c235ccca8da7a1bd54429f" translate="yes" xml:space="preserve">
          <source>To submit all changes that are in the current Git branch but not in the &lt;code&gt;p4/master&lt;/code&gt; branch, use:</source>
          <target state="translated">要提交当前Git分支中而不是 &lt;code&gt;p4/master&lt;/code&gt; 分支中的所有更改，请使用：</target>
        </trans-unit>
        <trans-unit id="4d37523ff8334f7ae27e64b17d4088a430f024d8" translate="yes" xml:space="preserve">
          <source>To submit patches using GMail&amp;rsquo;s IMAP interface, first, edit your ~/.gitconfig to specify your account settings:</source>
          <target state="translated">要使用GMail的IMAP界面提交补丁，请首先编辑〜/ .gitconfig以指定您的帐户设置：</target>
        </trans-unit>
        <trans-unit id="3829362b0206f78fb7e35755e5364f47036b822a" translate="yes" xml:space="preserve">
          <source>To support virtual hosting, an interpolated path template can be used to dynamically construct alternate paths. The template supports %H for the target hostname as supplied by the client but converted to all lowercase, %CH for the canonical hostname, %IP for the server&amp;rsquo;s IP address, %P for the port number, and %D for the absolute path of the named repository. After interpolation, the path is validated against the directory whitelist.</source>
          <target state="translated">为了支持虚拟主机，可以使用内插的路径模板动态构建备用路径。模板支持％H作为客户端提供的目标主机名，但转换为所有小写字母，％CH表示规范的主机名，％IP表示服务器的IP地址，％P表示端口号，％D表示绝对路径命名存储库。插值后，将根据目录白名单验证路径。</target>
        </trans-unit>
        <trans-unit id="5c5bebcfb262219afa24ad57e1be9ff8017de145" translate="yes" xml:space="preserve">
          <source>To switch back to the previous branch before we switched to mytopic (i.e. &quot;master&quot; branch):</source>
          <target state="translated">要切换回我们切换到mytopic之前的分支(即 &quot;主 &quot;分支)。</target>
        </trans-unit>
        <trans-unit id="f604bfa9fc2a5e3a8b43aed4c26f0a58bfbd1e14" translate="yes" xml:space="preserve">
          <source>To tell Git that yes, you really do realize that certain files no longer exist, or that new files should be added, you should use the &lt;code&gt;--remove&lt;/code&gt; and &lt;code&gt;--add&lt;/code&gt; flags respectively.</source>
          <target state="translated">告诉Git是的，您确实意识到某些文件不再存在，或者应该添加新文件，应该分别使用 &lt;code&gt;--remove&lt;/code&gt; 和 &lt;code&gt;--add&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="f3c508cb95e621506ae6e931b2fdadcaba14a047" translate="yes" xml:space="preserve">
          <source>To test the interaction of several topics, merge them into a throw-away branch. You must never base any work on such a branch!</source>
          <target state="translated">要测试几个主题的交互,请将它们合并到一个抛弃式分支中。你绝对不能在这样的分支上做任何工作!</target>
        </trans-unit>
        <trans-unit id="ded44bb687bc8a448accbaa8cf09bc1b10b3ff71" translate="yes" xml:space="preserve">
          <source>To that end, it first finds pairs of commits from both commit ranges that correspond with each other. Two commits are said to correspond when the diff between their patches (i.e. the author information, the commit message and the commit diff) is reasonably small compared to the patches' size. See ``Algorithm`` below for details.</source>
          <target state="translated">为此,它首先从两个提交范围中找到相互对应的提交对。当两个提交的补丁之间的差异(即作者信息、提交信息和提交差异)与补丁的大小相比相当小时,就被认为是对应的。详见下文 &quot;算法&quot;。</target>
        </trans-unit>
        <trans-unit id="28b9a65cbb97d3af18835efd06d4d171278e0508" translate="yes" xml:space="preserve">
          <source>To throw away part of the development, i.e. to assign the &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; to an earlier &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;.</source>
          <target state="translated">放弃部分开发内容，即将&lt;a href=&quot;#def_head&quot;&gt;磁头&lt;/a&gt;分配给较早的&lt;a href=&quot;#def_revision&quot;&gt;修订版&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2857b34f71a88c7afeb725363e4097e2e44ff45" translate="yes" xml:space="preserve">
          <source>To top it all off, even when users finally find working commands, they naturally want to share them. But they may be unaware that their repo didn&amp;rsquo;t have some special cases that someone else&amp;rsquo;s does. So, when someone else with a different repository runs the same commands, they get hit by the problems above. Or, the user just runs commands that really were vetted for special cases, but they run it on a different OS where it doesn&amp;rsquo;t work, as noted above.</source>
          <target state="translated">最重要的是，即使用户最终找到了有效的命令，他们自然也希望共享它们。但是他们可能不知道自己的仓库没有其他人做的特殊情况。因此，当其他人使用不同的存储库运行相同的命令时，他们会受到上述问题的打击。或者，用户仅运行确实经过特殊情况审查的命令，但如上所述，他们在不起作用的其他操作系统上运行该命令。</target>
        </trans-unit>
        <trans-unit id="c4d2ca21938c992db0b3b75cacfc935366e6629e" translate="yes" xml:space="preserve">
          <source>To update and refresh only the files already checked out</source>
          <target state="translated">只更新和刷新已经签出的文件。</target>
        </trans-unit>
        <trans-unit id="a8c26a487a2f6627cb1ef2fcc7d8934daa7b62d0" translate="yes" xml:space="preserve">
          <source>To update and refresh only the files already checked out:</source>
          <target state="translated">只更新和刷新已经签出的文件。</target>
        </trans-unit>
        <trans-unit id="ec65c1043e980aa5b1f1a444793e6e405a4b07fd" translate="yes" xml:space="preserve">
          <source>To update the index with the contents of a new or modified file, use</source>
          <target state="translated">要用新的或修改后的文件内容更新索引,使用</target>
        </trans-unit>
        <trans-unit id="693fe77a3dea0f3b3cf2c4a884d12237d7043db5" translate="yes" xml:space="preserve">
          <source>To update the resulting mine.git repository, you can fetch or pull after replacing the bundle stored at /home/me/tmp/file.bundle with incremental updates.</source>
          <target state="translated">要更新产生的mine.git仓库,你可以在将存储在/home/me/tmp/file.bundle的bundle替换为增量更新后,再取或拉。</target>
        </trans-unit>
        <trans-unit id="7804c7379482ba8df4ffa8604001ea71fae1937a" translate="yes" xml:space="preserve">
          <source>To use &quot;old&quot; and &quot;new&quot; instead of &quot;good&quot; and bad, you must run &lt;code&gt;git
bisect start&lt;/code&gt; without commits as argument and then run the following commands to add the commits:</source>
          <target state="translated">要使用&amp;ldquo;旧&amp;rdquo;和&amp;ldquo;新&amp;rdquo;而不是&amp;ldquo;好&amp;rdquo;和&amp;ldquo;坏&amp;rdquo;，必须运行不带提交的 &lt;code&gt;git bisect start&lt;/code&gt; ，然后运行以下命令来添加提交：</target>
        </trans-unit>
        <trans-unit id="288cf0a04f95ab8d9b3cedc9a80bcb75e1eb91a6" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;git send-email&lt;/code&gt; to send your patches through the GMail SMTP server, edit ~/.gitconfig to specify your account settings:</source>
          <target state="translated">要使用 &lt;code&gt;git send-email&lt;/code&gt; 通过GMail SMTP服务器发送补丁，请编辑〜/ .gitconfig以指定您的帐户设置：</target>
        </trans-unit>
        <trans-unit id="b24b5140a04c50c5ab1f6a8bf4b67a65e4b08446" translate="yes" xml:space="preserve">
          <source>To use a helper, you must first select one to use. Git currently includes the following helpers:</source>
          <target state="translated">要使用助记器,必须先选择一个助记器来使用。目前,Git 包含了以下几个辅助工具。</target>
        </trans-unit>
        <trans-unit id="36cbbd22949ca6f21f378ad7a2a2aecbfc17d31c" translate="yes" xml:space="preserve">
          <source>To use the tool, &lt;code&gt;imap.folder&lt;/code&gt; and either &lt;code&gt;imap.tunnel&lt;/code&gt; or &lt;code&gt;imap.host&lt;/code&gt; must be set to appropriate values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e4f18d69f51ffe1eea42af728cb3d7bb0059ec" translate="yes" xml:space="preserve">
          <source>To use the tool, imap.folder and either imap.tunnel or imap.host must be set to appropriate values.</source>
          <target state="translated">要使用该工具,imap.folder和imap.tunnel或imap.host必须设置为适当的值。</target>
        </trans-unit>
        <trans-unit id="8b51a494019812910be0a147154b59e9ef1b84fa" translate="yes" xml:space="preserve">
          <source>To use this mode effectively, you have to make sure &lt;code&gt;all&lt;/code&gt; the branches you would push out are ready to be pushed out before running &lt;code&gt;git push&lt;/code&gt;, as the whole point of this mode is to allow you to push all of the branches in one go. If you usually finish work on only one branch and push out the result, while other branches are unfinished, this mode is not for you. Also this mode is not suitable for pushing into a shared central repository, as other people may add new branches there, or update the tip of existing branches outside your control.</source>
          <target state="translated">为了有效地使用此模式，您必须确保在运行 &lt;code&gt;git push&lt;/code&gt; 之前已准备好将要推出的 &lt;code&gt;all&lt;/code&gt; 分支都推出，因为此模式的要点是允许您一次推送所有分支。如果通常只在一个分支上完成工作并推出结果，而其他分支还没有完成，则此模式不适合您。同样，此模式也不适合推送到共享中央存储库中，因为其他人可能会在其中添加新分支，或在控件外部更新现有分支的尖端。</target>
        </trans-unit>
        <trans-unit id="0db2ead5af506998515a70d6693b9cc78c43968a" translate="yes" xml:space="preserve">
          <source>To verify that &lt;code&gt;master&lt;/code&gt; is indeed a superset of &lt;code&gt;maint&lt;/code&gt;, use git log:</source>
          <target state="translated">要验证 &lt;code&gt;master&lt;/code&gt; 确实是 &lt;code&gt;maint&lt;/code&gt; 的超集，请使用git log：</target>
        </trans-unit>
        <trans-unit id="25e07c07376edb7f994c3289d03610c1335d5288" translate="yes" xml:space="preserve">
          <source>Todo list</source>
          <target state="translated">所有名单</target>
        </trans-unit>
        <trans-unit id="feb6706843b17024c0f5d36ae4a2773f9f7a9d9e" translate="yes" xml:space="preserve">
          <source>Toggle the &quot;sparse&quot; algorithm to determine which objects to include in the pack, when combined with the &quot;--revs&quot; option. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. If this option is not included, it defaults to the value of &lt;code&gt;pack.useSparse&lt;/code&gt;, which is true unless otherwise specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e89f12173f1b11f3c33dfcf393dbeb53d74231" translate="yes" xml:space="preserve">
          <source>Toggle the pre-push hook (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;). The default is --verify, giving the hook a chance to prevent the push. With --no-verify, the hook is bypassed completely.</source>
          <target state="translated">切换预推钩（请参阅&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;）。默认值为--verify，为挂钩提供了阻止推送的机会。使用--no-verify，挂钩将被完全绕过。</target>
        </trans-unit>
        <trans-unit id="e69b3ac557eee7192f98b057069c2f145301ef39" translate="yes" xml:space="preserve">
          <source>Topic branches</source>
          <target state="translated">主题分支</target>
        </trans-unit>
        <trans-unit id="99011a3381da15bff0042576b0bb55bb6ae9ffd0" translate="yes" xml:space="preserve">
          <source>TortoiseCVS</source>
          <target state="translated">TortoiseCVS</target>
        </trans-unit>
        <trans-unit id="9732ce69da01051c0a62cf40cfeb5063ebcf5c22" translate="yes" xml:space="preserve">
          <source>Trace the evolution of the line range given by &quot;&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;&quot; (or the function name regex &amp;lt;funcname&amp;gt;) within the &amp;lt;file&amp;gt;. You may not give any pathspec limiters. This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and &amp;lt;start&amp;gt; and &amp;lt;end&amp;gt; (or &amp;lt;funcname&amp;gt;) must exist in the starting revision. You can specify this option more than once. Implies &lt;code&gt;--patch&lt;/code&gt;. Patch output can be suppressed using &lt;code&gt;--no-patch&lt;/code&gt;, but other diff formats (namely &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--shortstat&lt;/code&gt;, &lt;code&gt;--dirstat&lt;/code&gt;, &lt;code&gt;--summary&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt;, &lt;code&gt;--name-status&lt;/code&gt;, &lt;code&gt;--check&lt;/code&gt;) are not currently implemented.</source>
          <target state="translated">跟踪&amp;lt;file&amp;gt;中&amp;ldquo; &amp;lt;start&amp;gt;，&amp;lt;end&amp;gt;&amp;rdquo;（或函数名regex &amp;lt;funcname&amp;gt;）给定的行范围的演变。您不得提供任何pathspec限制器。当前，这仅限于从单个修订版开始的遍历，即，您只能提供零个或一个正修订版参数，并且起始版本中必须存在&amp;lt;start&amp;gt;和&amp;lt;end&amp;gt;（或&amp;lt;funcname&amp;gt;）。您可以多次指定此选项。意味着 &lt;code&gt;--patch&lt;/code&gt; 。可以使用 &lt;code&gt;--no-patch&lt;/code&gt; 抑制补丁输出，但可以使用其他差异格式（即 &lt;code&gt;--raw&lt;/code&gt; ，-- &lt;code&gt;--numstat&lt;/code&gt; ，-- &lt;code&gt;--shortstat&lt;/code&gt; ，-- &lt;code&gt;--dirstat&lt;/code&gt; ，-- &lt;code&gt;--summary&lt;/code&gt; ， &lt;code&gt;--name-only&lt;/code&gt; name -only， &lt;code&gt;--name-status&lt;/code&gt; name -status， &lt;code&gt;--check&lt;/code&gt; ）目前尚未实现。</target>
        </trans-unit>
        <trans-unit id="324f1031e6064bf946ba7ad7de400c92a706ee71" translate="yes" xml:space="preserve">
          <source>Trace2 api</source>
          <target state="translated">Trace2 api</target>
        </trans-unit>
        <trans-unit id="f39bab439a6977ac76a84295e79b079d44b7d908" translate="yes" xml:space="preserve">
          <source>Trace2 config settings are only read from the system and global config files; repository local and worktree config files and &lt;code&gt;-c&lt;/code&gt; command line arguments are not respected.</source>
          <target state="translated">Trace2配置设置只能从系统和全局配置文件中读取；不遵守存储库本地和工作树配置文件以及 &lt;code&gt;-c&lt;/code&gt; 命令行参数。</target>
        </trans-unit>
        <trans-unit id="34f4d5fb2d35b898a8c6180c70ae5079360dafe0" translate="yes" xml:space="preserve">
          <source>Trace2 defines the following set of Trace2 Targets. Format details are given in a later section.</source>
          <target state="translated">Trace2 定义了以下一组 Trace2 Targets。格式细节将在后面的章节中给出。</target>
        </trans-unit>
        <trans-unit id="9cffe01770c87380a0c500c2ba4c5fe9919c83ec" translate="yes" xml:space="preserve">
          <source>Trace2 instrumentation throughout the Git code base sends Trace2 messages to the enabled Trace2 Targets. Targets transform these messages content into purpose-specific formats and write events to their data streams. In this manner, the Trace2 API can drive many different types of analysis.</source>
          <target state="translated">Git 代码库中的 Trace2 仪器会向启用的 Trace2 Targets 发送 Trace2 消息。Targets 将这些消息内容转化为特定目的的格式,并将事件写入其数据流。通过这种方式,Trace2 API 可以驱动许多不同类型的分析。</target>
        </trans-unit>
        <trans-unit id="78edf21cb8a1d6593bdb09f0d046c88dfeb5c5d1" translate="yes" xml:space="preserve">
          <source>Trace2 is controlled using &lt;code&gt;trace2.*&lt;/code&gt; config values in the system and global config files and &lt;code&gt;GIT_TRACE2*&lt;/code&gt; environment variables. Trace2 does not read from repo local or worktree config files or respect &lt;code&gt;-c&lt;/code&gt; command line config settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952dc6d60a810a50f48d84409a5ca3162f18abfc" translate="yes" xml:space="preserve">
          <source>Trace2 is controlled using &lt;code&gt;trace2.&lt;/code&gt; config values in the system and global config files and &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variables. Trace2 does not read from repo local or worktree config files or respect &lt;code&gt;-c&lt;/code&gt; command line config settings.</source>
          <target state="translated">使用 &lt;code&gt;trace2.&lt;/code&gt; 控制Trace2。系统和全局配置文件中的配置值以及 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 环境变量。Trace2不会从存储库本地或工作树配置文件中读取数据，也不会遵循 &lt;code&gt;-c&lt;/code&gt; 命令行配置设置。</target>
        </trans-unit>
        <trans-unit id="20f68aac372bbc56e3b5b3e96aea0079529bedb9" translate="yes" xml:space="preserve">
          <source>Trace2 regions are similar to the existing trace_performance_enter() and trace_performance_leave() routines, but are thread safe and maintain per-thread stacks of timers.</source>
          <target state="translated">Trace2区域类似于现有的trace_performance_enter()和trace_performance_leave()例程,但是是线程安全的,并且维护每个线程的定时器堆栈。</target>
        </trans-unit>
        <trans-unit id="8bded73626b8544423d59c1c5a0c1bfb684cb12e" translate="yes" xml:space="preserve">
          <source>Trace2 target formats</source>
          <target state="translated">Trace2目标格式</target>
        </trans-unit>
        <trans-unit id="e4cb4d4e7e519744d1375eb303304baebc567ae9" translate="yes" xml:space="preserve">
          <source>Trace2 targets</source>
          <target state="translated">Trace2目标</target>
        </trans-unit>
        <trans-unit id="a0cfb1f78b98054b282b0aab138d8ea25f2c82bd" translate="yes" xml:space="preserve">
          <source>Tracking and contributing to an entire Subversion-managed project (complete with a trunk, tags and branches):</source>
          <target state="translated">跟踪和贡献于整个Subversion管理的项目(完整的主干、标签和分支)。</target>
        </trans-unit>
        <trans-unit id="847895b0cdb93b975e4c930f95d66dabeb1e64d2" translate="yes" xml:space="preserve">
          <source>Tracking and contributing to the trunk of a Subversion-managed project (ignoring tags and branches):</source>
          <target state="translated">追踪并贡献给Subversion管理的项目主干(忽略标签和分支)。</target>
        </trans-unit>
        <trans-unit id="667c19a45142471c0c20cc605b683a6a3152afb1" translate="yes" xml:space="preserve">
          <source>Traditionally, tips of branches and tags (collectively known as &lt;code&gt;refs&lt;/code&gt;) were stored one file per ref in a (sub)directory under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory. While many branch tips tend to be updated often, most tags and some branch tips are never updated. When a repository has hundreds or thousands of tags, this one-file-per-ref format both wastes storage and hurts performance.</source>
          <target state="translated">传统上，分支和标签的提示（统称为 &lt;code&gt;refs&lt;/code&gt; ）是每个ref文件在 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 目录下的（子）目录中存储一个文件。尽管许多分支提示往往会经常更新，但是大多数标记和某些分支提示从未更新。当存储库具有成百上千个标签时，这种&amp;ldquo;每个引用一个文件&amp;rdquo;的格式既浪费存储空间，又损害性能。</target>
        </trans-unit>
        <trans-unit id="a5cf7db57e9cf074478d171148671cc677faf56a" translate="yes" xml:space="preserve">
          <source>Trailing spaces are ignored unless they are quoted with backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;).</source>
          <target state="translated">除非用反斜杠（&amp;ldquo; &lt;code&gt;\&lt;/code&gt; &amp;rdquo;）引号，否则将忽略尾随空格。</target>
        </trans-unit>
        <trans-unit id="18baa50eee1aac68104e16bd4ad94c661cde3869" translate="yes" xml:space="preserve">
          <source>Transfer size: In its current form Git requires the whole working tree present. It does not allow partial trees to be transferred in fetch or clone. If the project you work on consists of multiple repositories tied together as submodules in a superproject, you can avoid fetching the working trees of the repositories you are not interested in.</source>
          <target state="translated">传输大小。在目前的形式下,Git需要整个工作树的存在。它不允许在fetch或clone中传输部分工作树。如果你的项目由多个仓库组成,并作为超级项目的子模块,你可以避免获取你不感兴趣的仓库的工作树。</target>
        </trans-unit>
        <trans-unit id="bdf6a912dffd18ed6042052fce8610d96ce56a71" translate="yes" xml:space="preserve">
          <source>Transform stdin by substituting all the 40-character SHA-1 hexes (say $hex) with &quot;$hex ($rev_name)&quot;. When used with --name-only, substitute with &quot;$rev_name&quot;, omitting $hex altogether. Intended for the scripter&amp;rsquo;s use.</source>
          <target state="translated">通过用&amp;ldquo; $ hex（$ rev_name）&amp;rdquo;替换所有40个字符的SHA-1十六进​​制（例如$ hex）来转换stdin。当与--name-only一起使用时，用&amp;ldquo; $ rev_name&amp;rdquo;代替，完全省略$ hex。供脚本编写者使用。</target>
        </trans-unit>
        <trans-unit id="fc873c381aea0c960eb3ebd47773defb66d7e124" translate="yes" xml:space="preserve">
          <source>Transmit &amp;lt;string&amp;gt; as a push option. As the push option must not contain LF or NUL characters, the string is not encoded.</source>
          <target state="translated">传输&amp;lt;string&amp;gt;作为推送选项。由于push选项中不得包含LF或NUL字符，因此不会对字符串进行编码。</target>
        </trans-unit>
        <trans-unit id="32bd61986aca00f68612950bbcdb4915d3d0e846" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. The server&amp;rsquo;s handling of server options, including unknown ones, is server-specific. When multiple &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line.</source>
          <target state="translated">使用协议版本2进行通信时，将给定的字符串传输到服务器。给定的字符串不得包含NUL或LF字符。服务器对服务器选项（包括未知选项）的处理是特定于服务器的。当给出多个 &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; 时，它们都将按照命令行中列出的顺序发送到另一端。</target>
        </trans-unit>
        <trans-unit id="39635a03df29b9789e505a1038590e24ea96c9e9" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. When multiple &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line.</source>
          <target state="translated">使用协议版本2进行通信时，将给定的字符串传输到服务器。给定的字符串不得包含NUL或LF字符。当给出多个 &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; 时，它们都将按照命令行中列出的顺序发送到另一端。</target>
        </trans-unit>
        <trans-unit id="2995fbcc2c84443582483713456b482a39b63e37" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character. When multiple &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line. When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; is given from the command line, the values of configuration variable &lt;code&gt;push.pushOption&lt;/code&gt; are used instead.</source>
          <target state="translated">将给定的字符串发送到服务器，服务器将它们传递到接收前和接收后钩子。给定的字符串不得包含NUL或LF字符。当给出多个 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 时，它们都将按照命令行中列出的顺序发送到另一端。如果在命令行中未提供 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; ， &lt;code&gt;push.pushOption&lt;/code&gt; 使用配置变量push.pushOption的值。</target>
        </trans-unit>
        <trans-unit id="9960fbc3363c91bebbbc4dae3127f4935a1a22d6" translate="yes" xml:space="preserve">
          <source>Treat all files as text.</source>
          <target state="translated">将所有文件视为文本。</target>
        </trans-unit>
        <trans-unit id="a08e9c61e543dccc4a24afe7a10c95737cbb1ca7" translate="yes" xml:space="preserve">
          <source>Treat pathspecs literally (i.e. no globbing, no pathspec magic). This is equivalent to setting the &lt;code&gt;GIT_LITERAL_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">从字面上对待pathspec（即，不要乱扔，没有pathspec魔术）。这等效于将 &lt;code&gt;GIT_LITERAL_PATHSPECS&lt;/code&gt; 环境变量设置为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8024445062b4bb90b2e84a4da6e0bb207f37b5f4" translate="yes" xml:space="preserve">
          <source>Treat the &amp;lt;string&amp;gt; given to &lt;code&gt;-S&lt;/code&gt; as an extended POSIX regular expression to match.</source>
          <target state="translated">将给予 &lt;code&gt;-S&lt;/code&gt; 的&amp;lt;string&amp;gt; 视为匹配的扩展POSIX正则表达式。</target>
        </trans-unit>
        <trans-unit id="72315ec1092243bb561e5b4697869abb3601099e" translate="yes" xml:space="preserve">
          <source>Treat the repository as a bare repository. If GIT_DIR environment is not set, it is set to the current working directory.</source>
          <target state="translated">将版本库作为裸库处理,如果没有设置GIT_DIR环境,则设置为当前工作目录。如果没有设置GIT_DIR环境,则设置为当前工作目录。</target>
        </trans-unit>
        <trans-unit id="1dad3a3b77cbf00bf58d87ee853af6d3cddb344a" translate="yes" xml:space="preserve">
          <source>Treat the revision argument as a &amp;lt;revision range&amp;gt;, even if it is just a single commit (that would normally be treated as a &amp;lt;since&amp;gt;). Note that root commits included in the specified range are always formatted as creation patches, independently of this flag.</source>
          <target state="translated">将修订版参数视为&amp;lt;修订版范围&amp;gt;，即使它只是一次提交（通常将被视为&amp;lt;since&amp;gt;）。请注意，包含在指定范围内的root提交始终被格式化为创建补丁，而与该标志无关。</target>
        </trans-unit>
        <trans-unit id="aa88eae97d6ad1936bc41000081122649aee8d74" translate="yes" xml:space="preserve">
          <source>Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;-b&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, &lt;code&gt;--ignore-space-at-eol&lt;/code&gt;, and &lt;code&gt;--ignore-cr-at-eol&lt;/code&gt;.</source>
          <target state="translated">为了进行三向合并，将具有指定空白类型更改的行视为未更改。空格更改与行的其他更改混合在一起将不被忽略。另请参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;-b&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; ，-- &lt;code&gt;--ignore-space-at-eol&lt;/code&gt; 和 &lt;code&gt;--ignore-cr-at-eol&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ddd0e484558c1f8e50a8fe3c2dc7499225a9297" translate="yes" xml:space="preserve">
          <source>Tree Object</source>
          <target state="translated">树形对象</target>
        </trans-unit>
        <trans-unit id="bce93b7f9d4c3064a3f582b574710500d7e5efb5" translate="yes" xml:space="preserve">
          <source>Tree and blob objects outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; will be treated the same way as if they were inside &lt;code&gt;refs/tags/*&lt;/code&gt;, any update of them will be rejected.</source>
          <target state="translated">&lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 之外的tree和blob对象将被视为与 &lt;code&gt;refs/tags/*&lt;/code&gt; 内的对象相同的方式对待，否则将拒绝更新它们。</target>
        </trans-unit>
        <trans-unit id="faed43d5018a65bdda1021ea817b81efdd882a1f" translate="yes" xml:space="preserve">
          <source>Tree objects as well as tag objects not pointing at commits, cannot be described. When describing blobs, the lightweight tags pointing at blobs are ignored, but the blob is still described as &amp;lt;committ-ish&amp;gt;:&amp;lt;path&amp;gt; despite the lightweight tag being favorable.</source>
          <target state="translated">无法描述树对象以及未指向提交的标记对象。在描述blob时，指向blob的轻量级标签将被忽略，但是尽管该轻量级标签是有利的，但该blob仍被描述为&amp;lt;committ-ish&amp;gt;：&amp;lt;path&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="d94a666a1561928de12071aa36f46464acd70f54" translate="yes" xml:space="preserve">
          <source>Tree to checkout from (when paths are given). If not specified, the index will be used.</source>
          <target state="translated">签出的树(给定路径时)。如果没有指定,将使用索引。</target>
        </trans-unit>
        <trans-unit id="fef8232d1c67b8b3403ba454c8ae3c965dc5fb72" translate="yes" xml:space="preserve">
          <source>Trees (aka directories) use just 12 bytes of memory on top of the memory required for their entries (see &amp;ldquo;per active file&amp;rdquo; below). The cost of a tree is virtually 0, as its overhead amortizes out over the individual file entries.</source>
          <target state="translated">树（又名目录）仅在其条目所需的内存之上使用12个字节的内存（请参见下面的&amp;ldquo;每个活动文件&amp;rdquo;）。一棵树的成本实际上为0，因为其开销在各个文件条目上摊销。</target>
        </trans-unit>
        <trans-unit id="2bb80d7d00c0395ecaf93c5dc9cd657c191b576d" translate="yes" xml:space="preserve">
          <source>Tries to reinstate not only the working tree&amp;rsquo;s changes, but also the index&amp;rsquo;s ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8797468d6463e4f71332170d9f50ca7fd321cc3a" translate="yes" xml:space="preserve">
          <source>Trivial merges are done by &lt;code&gt;git read-tree&lt;/code&gt; itself. Only conflicting paths will be in unmerged state when &lt;code&gt;git read-tree&lt;/code&gt; returns.</source>
          <target state="translated">琐碎的合并由 &lt;code&gt;git read-tree&lt;/code&gt; 本身完成。 &lt;code&gt;git read-tree&lt;/code&gt; 返回时，只有冲突的路径才会处于未合并状态。</target>
        </trans-unit>
        <trans-unit id="c14d8e783a9f521d30b73eb971eac8f82acc62a0" translate="yes" xml:space="preserve">
          <source>True merge</source>
          <target state="translated">真正的合并</target>
        </trans-unit>
        <trans-unit id="33a579ffc0dccbff15be01734ea4138ea4e7635c" translate="yes" xml:space="preserve">
          <source>Trust</source>
          <target state="translated">Trust</target>
        </trans-unit>
        <trans-unit id="df8a0e781552ee165e12d7086194c5f37262dc36" translate="yes" xml:space="preserve">
          <source>Try to speed up the traversal using the pack bitmap index (if one is available). Note that when traversing with &lt;code&gt;--objects&lt;/code&gt;, trees and blobs will not have their associated path printed.</source>
          <target state="translated">尝试使用包位图索引（如果有）来加快遍历速度。请注意，使用 &lt;code&gt;--objects&lt;/code&gt; 遍历时，树和blob将不会打印其关联路径。</target>
        </trans-unit>
        <trans-unit id="db494399fc91d335ea933090c261cf51f7615da6" translate="yes" xml:space="preserve">
          <source>Try to update from the upstream resulted in a lot of conflicts; you were not ready to spend a lot of time merging right now, so you decide to do that later.</source>
          <target state="translated">尝试从上游更新导致了很多冲突,你现在还没准备好花大量时间合并,所以你决定以后再做。</target>
        </trans-unit>
        <trans-unit id="3a12d2b4901990f4e580a360ff850809fe3f67b9" translate="yes" xml:space="preserve">
          <source>Turn off any previous &lt;code&gt;--filter=&lt;/code&gt; argument.</source>
          <target state="translated">关闭任何以前的 &lt;code&gt;--filter=&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="34771065d121fc03fac8d38d540e254893826329" translate="yes" xml:space="preserve">
          <source>Turn off branch colors, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">即使配置文件将颜色输出设置为默认值，也要关闭分支颜色。与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="6d9cbb32ce6c68e264cdb30b91e954cf183958d3" translate="yes" xml:space="preserve">
          <source>Turn off colored diff. It is the same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">关闭彩色差异。它与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="3d9b2354f095eeb41acddbf4f3d69d4ac5775813" translate="yes" xml:space="preserve">
          <source>Turn off colored diff. This can be used to override configuration settings. It is the same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">关闭彩色差异。这可用于覆盖配置设置。它与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="8ad464ef4a6c59cdcb2319e829113b9b9a0202fe" translate="yes" xml:space="preserve">
          <source>Turn off colored output, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">即使配置文件将默认设置为彩色输出，也要关闭彩色输出。与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="a3a997309d5fb6a6ca30f0f6201f278a284d8e1e" translate="yes" xml:space="preserve">
          <source>Turn off match highlighting, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">即使配置文件将颜色输出设置为默认值，也要关闭匹配突出显示。与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d4fab0f230de92fdcff08739247b39013a4dcf91" translate="yes" xml:space="preserve">
          <source>Turn off move detection. This can be used to override configuration settings. It is the same as &lt;code&gt;--color-moved=no&lt;/code&gt;.</source>
          <target state="translated">关闭移动检测。这可用于覆盖配置设置。与 &lt;code&gt;--color-moved=no&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b0eb0b106db412297afc722cb22850ad8fd89466" translate="yes" xml:space="preserve">
          <source>Turn off rename detection, even when the configuration file gives the default to do so.</source>
          <target state="translated">关闭重命名检测,即使配置文件给出的默认是这样做。</target>
        </trans-unit>
        <trans-unit id="4e867193eda90e02a99d5e3b2d3aff016424ee32" translate="yes" xml:space="preserve">
          <source>Turn off rename detection. This overrides the &lt;code&gt;merge.renames&lt;/code&gt; configuration variable. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--no-renames&lt;/code&gt;.</source>
          <target state="translated">关闭重命名检测。这将覆盖 &lt;code&gt;merge.renames&lt;/code&gt; 配置变量。另请参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--no-renames&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29eb4a9a74bb1156273caaa264fc85825c0572ef" translate="yes" xml:space="preserve">
          <source>Turn on rename detection, optionally setting the similarity threshold. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--find-renames&lt;/code&gt;.</source>
          <target state="translated">打开重命名检测，可以选择设置相似性阈值。另见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--find-renames&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a279dbfc86c680add56c7a5993ef6023dec20637" translate="yes" xml:space="preserve">
          <source>Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the &lt;code&gt;merge.renames&lt;/code&gt; configuration variable. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--find-renames&lt;/code&gt;.</source>
          <target state="translated">打开重命名检测，可以选择设置相似性阈值。这是默认值。这将覆盖 &lt;code&gt;merge.renames&lt;/code&gt; 配置变量。另见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--find-renames&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9d077a66918e3017c929a4d5ef75e05f491a825" translate="yes" xml:space="preserve">
          <source>Turn on/off rename detection regardless of user configuration. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--no-renames&lt;/code&gt;.</source>
          <target state="translated">无论用户配置如何，都可以打开/关闭重命名检测。另请参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--no-renames&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff597cb2e8f500da1bb43f369ea55f0017801fbc" translate="yes" xml:space="preserve">
          <source>Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal.</source>
          <target state="translated">明确开启/关闭进度。如果两者都不指定,如果标准误差连接到终端,则显示进度。</target>
        </trans-unit>
        <trans-unit id="b63e204e5b5bb236923126ba202fed353f8079ec" translate="yes" xml:space="preserve">
          <source>Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal. Note that not all merge strategies may support progress reporting.</source>
          <target state="translated">明确开启/关闭进度。如果两者都不指定,如果标准误差连接到终端,则显示进度。注意,并非所有的合并策略都支持进度报告。</target>
        </trans-unit>
        <trans-unit id="ae22b8d4ecb731b706e41a653df929373ee8e8e0" translate="yes" xml:space="preserve">
          <source>Turns off any previous &lt;code&gt;--filter=&lt;/code&gt; argument.</source>
          <target state="translated">关闭任何以前的 &lt;code&gt;--filter=&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="954e9a2594b4d5687b25c9c1a8357bca3253b18f" translate="yes" xml:space="preserve">
          <source>Tweaking diff output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef2d842e6b781b12f96bc62f4ab607c12e12218" translate="yes" xml:space="preserve">
          <source>Two Tree Merge</source>
          <target state="translated">双树合并</target>
        </trans-unit>
        <trans-unit id="6bda5442e87e811366b94ce6966009ecac6ac5dc" translate="yes" xml:space="preserve">
          <source>Two consecutive asterisks (&quot;&lt;code&gt;**&lt;/code&gt;&quot;) in patterns matched against full pathname may have special meaning:</source>
          <target state="translated">模式中与完整路径名匹配的两个连续星号（&amp;ldquo; &lt;code&gt;**&lt;/code&gt; &amp;rdquo;）可能具有特殊含义：</target>
        </trans-unit>
        <trans-unit id="e187ca5222f2f1c9a298321896225faf75c5697a" translate="yes" xml:space="preserve">
          <source>Two consecutive asterisks (&amp;ldquo;**&amp;rdquo;) in patterns matched against full pathname may have special meaning:</source>
          <target state="translated">与完整路径名匹配的模式中的两个连续星号（&amp;ldquo; **&amp;rdquo;）可能具有特殊含义：</target>
        </trans-unit>
        <trans-unit id="fce699584c34eaef39ec9c341ad51961e194a419" translate="yes" xml:space="preserve">
          <source>Two special values are supported: &lt;code&gt;off&lt;/code&gt; will simply close the corresponding standard handle, and if &lt;code&gt;GIT_REDIRECT_STDERR&lt;/code&gt; is &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;, standard error will be redirected to the same handle as standard output.</source>
          <target state="translated">支持两个特殊值： &lt;code&gt;off&lt;/code&gt; 将仅关闭相应的标准句柄，并且如果 &lt;code&gt;GIT_REDIRECT_STDERR&lt;/code&gt; 为 &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; ，则将标准错误重定向到与标准输出相同的句柄。</target>
        </trans-unit>
        <trans-unit id="34a739d621f3038babff4f0f681d077135e77a75" translate="yes" xml:space="preserve">
          <source>Two things are interesting here:</source>
          <target state="translated">这里有两件事很有意思。</target>
        </trans-unit>
        <trans-unit id="ced48512ad4d3cb13ca20b7cb1f2f8e4abd0bc9d" translate="yes" xml:space="preserve">
          <source>Tying it all together</source>
          <target state="translated">把所有的事情联系在一起</target>
        </trans-unit>
        <trans-unit id="3a87a5a93967e0c0facb5bdbedab0a6936494920" translate="yes" xml:space="preserve">
          <source>Type 5 is reserved for future expansion. Type 0 is invalid.</source>
          <target state="translated">类型5是为将来的扩展保留的。类型0是无效的。</target>
        </trans-unit>
        <trans-unit id="e8e8d3184972cec12ef3bd94d7eec7947cbe4b53" translate="yes" xml:space="preserve">
          <source>Typical gitweb config files will only change starting (default) time zone, and leave other elements at their default values:</source>
          <target state="translated">典型的gitweb配置文件只会改变起始(默认)时区,而让其他元素保持默认值。</target>
        </trans-unit>
        <trans-unit id="3aa25a3911a2da2f000729dbc451ee040fee4a66" translate="yes" xml:space="preserve">
          <source>Typical usage is something like:</source>
          <target state="translated">典型的用法是这样的。</target>
        </trans-unit>
        <trans-unit id="db1f5b1028dc570d4bb8caccd45a45601a38210c" translate="yes" xml:space="preserve">
          <source>Typical use of git credential</source>
          <target state="translated">git证书的典型用法</target>
        </trans-unit>
        <trans-unit id="d63a8a509d39725ec5fc85189ba54ffbab2dd0bb" translate="yes" xml:space="preserve">
          <source>Typically it will be placed in a MUA&amp;rsquo;s drafts folder, edited to add timely commentary that should not go in the changelog after the three dashes, and then sent as a message whose body, in our example, starts with &quot;arch/arm config files were&amp;hellip;​&quot;. On the receiving end, readers can save interesting patches in a UNIX mailbox and apply them with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;.</source>
          <target state="translated">通常，它将放置在MUA的drafts文件夹中，进行编辑以添加及时的注释，该注释不应在三个破折号之后出现在变更日志中，然后作为消息发送，其主体在我们的示例中以&amp;ldquo; arch / arm配置文件开头&amp;hellip;&amp;rdquo;。在接收端，读者可以将有趣的补丁程序保存在UNIX邮箱中，并通过&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;应用它们。</target>
        </trans-unit>
        <trans-unit id="3b51965ce078cc4b0d9ecb0a1b113a383a8700dc" translate="yes" xml:space="preserve">
          <source>Typically such a variable may look like this:</source>
          <target state="translated">一般来说,这样的变量可能是这样的。</target>
        </trans-unit>
        <trans-unit id="9f47be9cc1e7fcec80fcc7e52dcbd486a27d2ee2" translate="yes" xml:space="preserve">
          <source>Typically this is run with a script calling Git&amp;rsquo;s imitation of the &lt;code&gt;merge&lt;/code&gt; command from the RCS package.</source>
          <target state="translated">通常，这是通过脚本调用Git模仿RCS包中的 &lt;code&gt;merge&lt;/code&gt; 命令来运行的。</target>
        </trans-unit>
        <trans-unit id="e4333d902cedfd0d4739277fdec621b3f9f09422" translate="yes" xml:space="preserve">
          <source>Typically this matches the real type of &amp;lt;object&amp;gt; but asking for a type that can trivially be dereferenced from the given &amp;lt;object&amp;gt; is also permitted. An example is to ask for a &quot;tree&quot; with &amp;lt;object&amp;gt; being a commit object that contains it, or to ask for a &quot;blob&quot; with &amp;lt;object&amp;gt; being a tag object that points at it.</source>
          <target state="translated">通常，它与&amp;lt;object&amp;gt;的实际类型匹配，但是也允许要求可以从给定的&amp;lt;object&amp;gt;取消引用的类型。一个示例是要求一个带有&amp;lt;object&amp;gt;作为包含它的提交对象的&amp;ldquo;树&amp;rdquo;，或者要求一个带有&amp;lt;object&amp;gt;是指向它的标记对象的&amp;ldquo; blob&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6b016c5601edd059fd8dc12bb8d8426b6525fff2" translate="yes" xml:space="preserve">
          <source>Typically you would first remove all tracked files from the working tree using this command:</source>
          <target state="translated">通常情况下,你会先用这个命令从工作树中删除所有跟踪的文件。</target>
        </trans-unit>
        <trans-unit id="3a2ee6ee14f11a86e1818d26c21e9493d38718f1" translate="yes" xml:space="preserve">
          <source>Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel.</source>
          <target state="translated">通常情况下,并行递归和多远程的获取会更快。默认情况下,检索是按顺序执行的,而不是并行的。</target>
        </trans-unit>
        <trans-unit id="94e92e77c127b9c8a314ec2c48c4916e008c6404" translate="yes" xml:space="preserve">
          <source>Typically, this is invoked as &lt;code&gt;git read-tree -m $H $M&lt;/code&gt;, where $H is the head commit of the current repository, and $M is the head of a foreign tree, which is simply ahead of $H (i.e. we are in a fast-forward situation).</source>
          <target state="translated">通常，这是作为 &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; 调用的，其中$ H是当前存储库的头提交，而$ M是外来树的头，仅在$ H之前（即，处于快速发展的状态）。</target>
        </trans-unit>
        <trans-unit id="0ada5827188094ef6e82c28e45e078ca96f54ca4" translate="yes" xml:space="preserve">
          <source>U: file is unmerged (you must complete the merge before it can be committed)</source>
          <target state="translated">U:文件未合并(必须在提交前完成合并)</target>
        </trans-unit>
        <trans-unit id="1a7a0d0dd35212ae4c8c4c873315c6e7e9351f3b" translate="yes" xml:space="preserve">
          <source>URI and label (title) for the Git logo link (or your site logo, if you chose to use different logo image). By default, these both refer to Git homepage, &lt;a href=&quot;https://git-scm.com&quot;&gt;https://git-scm.com&lt;/a&gt;; in the past, they pointed to Git documentation at &lt;a href=&quot;https://www.kernel.org&quot;&gt;https://www.kernel.org&lt;/a&gt;.</source>
          <target state="translated">Git徽标链接（或站点徽标，如果您选择使用其他徽标图像）的URI和标签（标题）。默认情况下，它们都指向Git主页&lt;a href=&quot;https://git-scm.com&quot;&gt;https://git-scm.com&lt;/a&gt; ; 过去，他们指向&lt;a href=&quot;https://www.kernel.org&quot;&gt;https://www.kernel.org&lt;/a&gt;上的Git文档。</target>
        </trans-unit>
        <trans-unit id="8561702ffd22bbb5ccd1a81c9c8d8cc77f16fa7e" translate="yes" xml:space="preserve">
          <source>Un-sets the previously set type specifier (if one was previously set). This option requests that &lt;code&gt;git config&lt;/code&gt; not canonicalize the retrieved variable. &lt;code&gt;--no-type&lt;/code&gt; has no effect without &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; or &lt;code&gt;--&amp;lt;type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">取消设置先前设置的类型说明符（如果先前已设置）。此选项要求 &lt;code&gt;git config&lt;/code&gt; 不规范检索到的变量。没有 &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; 或 &lt;code&gt;--&amp;lt;type&amp;gt;&lt;/code&gt; no &lt;code&gt;--no-type&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="911839695653d988872929c95814b8902e300040" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--pretty=oneline&lt;/code&gt;, the commit message is prefixed with this information on the same line. This option cannot be combined with &lt;code&gt;--reverse&lt;/code&gt;. See also &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;--pretty=oneline&lt;/code&gt; 下，提交消息在同一行上带有此信息的前缀。此选项不能与 &lt;code&gt;--reverse&lt;/code&gt; 结合使用。另见&lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64ba59969ba5a36d002d9a189101c624fcf7d3cc" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--pretty=reference&lt;/code&gt;, this information will not be shown at all.</source>
          <target state="translated">在 &lt;code&gt;--pretty=reference&lt;/code&gt; 下，此信息将完全不显示。</target>
        </trans-unit>
        <trans-unit id="c73a6e04cc57ad10ee4ae7284f559a5ae2a53d36" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, some versions of &lt;code&gt;diff&lt;/code&gt; do not correctly detect a missing new-line at the end of the file. As a result, patches created by such &lt;code&gt;diff&lt;/code&gt; programs do not record incomplete lines correctly. This option adds support for applying such patches by working around this bug.</source>
          <target state="translated">在某些情况下，某些版本的 &lt;code&gt;diff&lt;/code&gt; 无法正确检测到文件末尾缺少的换行符。结果，由此类 &lt;code&gt;diff&lt;/code&gt; 程序创建的补丁无法正确记录不完整的行。通过解决此错误，此选项增加了对应用此类修补程序的支持。</target>
        </trans-unit>
        <trans-unit id="67a27dbf5548d05ac63e85bd8b4c875d8f48c102" translate="yes" xml:space="preserve">
          <source>Understanding History: Commits</source>
          <target state="translated">了解历史。承诺</target>
        </trans-unit>
        <trans-unit id="9334dba95d5dfb2042093dd9adbddea5f77c5eb4" translate="yes" xml:space="preserve">
          <source>Understanding history: History diagrams</source>
          <target state="translated">了解历史。历史图表</target>
        </trans-unit>
        <trans-unit id="85bd1a7ea75afef7e0417cd2bf9d9f3cf13e5e08" translate="yes" xml:space="preserve">
          <source>Understanding history: What is a branch?</source>
          <target state="translated">了解历史。什么是分支?</target>
        </trans-unit>
        <trans-unit id="6d61d96a492f996316f1e84e66cbfde933315e2c" translate="yes" xml:space="preserve">
          <source>Understanding history: commits, parents, and reachability</source>
          <target state="translated">了解历史:承诺、父母和可达到性。</target>
        </trans-unit>
        <trans-unit id="afa47a28efb9d6631a7be02ac359bed5256995ce" translate="yes" xml:space="preserve">
          <source>Undo a commit and redo</source>
          <target state="translated">撤销提交并重做</target>
        </trans-unit>
        <trans-unit id="61cb90c052dfcd0fda883c6029d1d0fc0a0f4685" translate="yes" xml:space="preserve">
          <source>Undo a commit, making it a topic branch</source>
          <target state="translated">撤销提交,使其成为一个主题分支。</target>
        </trans-unit>
        <trans-unit id="93d74feb000c815128d68a09c83733db43b69c15" translate="yes" xml:space="preserve">
          <source>Undo a merge or pull</source>
          <target state="translated">撤销合并或拉动</target>
        </trans-unit>
        <trans-unit id="4728c70cd06347b5f285fb3e7887387303b3968e" translate="yes" xml:space="preserve">
          <source>Undo a merge or pull inside a dirty working tree</source>
          <target state="translated">撤销合并或拉入脏工作树内的操作。</target>
        </trans-unit>
        <trans-unit id="27b7abb5b90b7a2e8f00eaf74b6df8323ba7d926" translate="yes" xml:space="preserve">
          <source>Undo add</source>
          <target state="translated">撤销添加</target>
        </trans-unit>
        <trans-unit id="ca677a11d37ffdca5231911a194cc2fcdffc5a26" translate="yes" xml:space="preserve">
          <source>Undo commits permanently</source>
          <target state="translated">永久撤销承诺</target>
        </trans-unit>
        <trans-unit id="4180759bca2f04cde0ec69611cb0e0ec1cfe7139" translate="yes" xml:space="preserve">
          <source>Undoes the effects of &lt;code&gt;fetch&lt;/code&gt; back to the specified revision. This allows you to re-&lt;code&gt;fetch&lt;/code&gt; an SVN revision. Normally the contents of an SVN revision should never change and &lt;code&gt;reset&lt;/code&gt; should not be necessary. However, if SVN permissions change, or if you alter your --ignore-paths option, a &lt;code&gt;fetch&lt;/code&gt; may fail with &quot;not found in commit&quot; (file not previously visible) or &quot;checksum mismatch&quot; (missed a modification). If the problem file cannot be ignored forever (with --ignore-paths) the only way to repair the repo is to use &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">撤消 &lt;code&gt;fetch&lt;/code&gt; 指定修订的影响。这使您可以 &lt;code&gt;fetch&lt;/code&gt; SVN修订版。通常，SVN修订版的内容永远不应该更改，也不必 &lt;code&gt;reset&lt;/code&gt; 。但是，如果SVN权限发生更改，或者更改了--ignore-paths选项，则 &lt;code&gt;fetch&lt;/code&gt; 可能会失败，并显示&amp;ldquo;未在提交中找到&amp;rdquo;（以前不可见的文件）或&amp;ldquo;校验和不匹配&amp;rdquo;（缺少修改）。如果无法永久忽略问题文件（使用--ignore-paths），则修复存储库的唯一方法是使用 &lt;code&gt;reset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac1f58f831611819b4114b80dd55e3ce540d5b23" translate="yes" xml:space="preserve">
          <source>Undoing a merge</source>
          <target state="translated">撤销合并</target>
        </trans-unit>
        <trans-unit id="f552d5a5802e3df6273c784214def9840b82f594" translate="yes" xml:space="preserve">
          <source>Unfortunately this system becomes inefficient once a project has a lot of objects. Try this on an old project:</source>
          <target state="translated">不幸的是,一旦一个项目有很多对象,这个系统就会变得效率低下。在一个旧项目上试试这个。</target>
        </trans-unit>
        <trans-unit id="c7deb06b3e42a38e2b00598939aa39f8d24897bd" translate="yes" xml:space="preserve">
          <source>Unfortunately, the desired effect of cleaning up text files with mixed line endings and the undesired effect of corrupting binary files cannot be distinguished. In both cases CRLFs are removed in an irreversible way. For text files this is the right thing to do because CRLFs are line endings, while for binary files converting CRLFs corrupts data.</source>
          <target state="translated">遗憾的是,清理行尾混杂的文本文件的理想效果和破坏二进制文件的不理想效果无法区分。在这两种情况下,CRLFs都是以一种不可逆的方式被删除的。对于文本文件来说,这是正确的做法,因为CRLFs是行尾,而对于二进制文件来说,转换CRLFs会破坏数据。</target>
        </trans-unit>
        <trans-unit id="6da1ce58d3a6c34c76807dc44593d7cd8c6563b6" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;--text&lt;/code&gt; is supplied patches of binary files without a textconv filter will be ignored.</source>
          <target state="translated">除非提供了 &lt;code&gt;--text&lt;/code&gt; ,否则将忽略不具有textconv过滤器的二进制文件补丁。</target>
        </trans-unit>
        <trans-unit id="54cbf98b314812a07f65f95ae77e8608ddf0b26f" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-f&lt;/code&gt; is given, the &lt;code&gt;replace&lt;/code&gt; reference must not yet exist.</source>
          <target state="translated">除非给出 &lt;code&gt;-f&lt;/code&gt; ，否则 &lt;code&gt;replace&lt;/code&gt; 引用必须不存在。</target>
        </trans-unit>
        <trans-unit id="ec0a9816e3fe8947b4bfff6f5914c3288bed6fc9" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-f&lt;/code&gt; is given, the named tag must not yet exist.</source>
          <target state="translated">除非给出 &lt;code&gt;-f&lt;/code&gt; ，否则命名标记必须还不存在。</target>
        </trans-unit>
        <trans-unit id="7824ccb45f3d7be1fd07def25712792fbdf3f009" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git blame&lt;/code&gt; and &lt;code&gt;git annotate&lt;/code&gt; in older versions of git, the extent of the annotation can be limited to both line ranges and revision ranges. The &lt;code&gt;-L&lt;/code&gt; option, which limits annotation to a range of lines, may be specified multiple times.</source>
          <target state="translated">与 &lt;code&gt;git blame&lt;/code&gt; 和 &lt;code&gt;git annotate&lt;/code&gt; 在较早版本的git中不同，注释的范围可以限于行范围和修订范围。的 &lt;code&gt;-L&lt;/code&gt; 选项，这限制了注释的行范围的，可被指定多次。</target>
        </trans-unit>
        <trans-unit id="1fa5e3a4c28161d2ef67ee80d5624341cfa56be1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git diff-files&lt;/code&gt;, which showed the difference between the index file and the working tree, &lt;code&gt;git diff-index&lt;/code&gt; shows the differences between a committed &lt;strong&gt;tree&lt;/strong&gt; and either the index file or the working tree. In other words, &lt;code&gt;git diff-index&lt;/code&gt; wants a tree to be diffed against, and before we did the commit, we couldn&amp;rsquo;t do that, because we didn&amp;rsquo;t have anything to diff against.</source>
          <target state="translated">与 &lt;code&gt;git diff-files&lt;/code&gt; 不同，后者显示了索引文件和工作树之间的 &lt;code&gt;git diff-index&lt;/code&gt; ，而git diff-index显示了已提交的&lt;strong&gt;树&lt;/strong&gt;与索引文件或工作树之间的差异。换句话说， &lt;code&gt;git diff-index&lt;/code&gt; 希望与一棵树进行比较，而在我们提交之前，我们无法做到这一点，因为我们没有任何要针对的。</target>
        </trans-unit>
        <trans-unit id="a75073ebd9356a7219cb30b4bb866c17ce8b906c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;gitk&lt;/code&gt;, &lt;code&gt;git gui&lt;/code&gt; focuses on commit generation and single file annotation and does not show project history. It does however supply menu actions to start a &lt;code&gt;gitk&lt;/code&gt; session from within &lt;code&gt;git gui&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;gitk&lt;/code&gt; 不同， &lt;code&gt;git gui&lt;/code&gt; 专注于提交生成和单个文件注释，并且不显示项目历史记录。但是，它确实提供了菜单操作以从 &lt;code&gt;git gui&lt;/code&gt; 内部启动 &lt;code&gt;gitk&lt;/code&gt; 会话。</target>
        </trans-unit>
        <trans-unit id="cd17281830ac5a9aa50c0d768481eabf04240182" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;raw&lt;/code&gt; format above, the time zone/UTC offset information contained in an RFC 2822 date string is used to adjust the date value to UTC prior to storage. Therefore it is important that this information be as accurate as possible.</source>
          <target state="translated">与上面的 &lt;code&gt;raw&lt;/code&gt; 格式不同，RFC 2822日期字符串中包含的时区/ UTC偏移信息用于在存储之前将日期值调整为UTC。因此，重要的是此信息应尽可能准确。</target>
        </trans-unit>
        <trans-unit id="b9ebe23208a4d3f51d6690b78b04b40646f8e2f1" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;rfc2822&lt;/code&gt; format, this format is very strict. Any variation in formatting will cause fast-import to reject the value, and some sanity checks on the numeric values may also be performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422977ffd462a03a6cbce65db58b07001eb2214f" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;rfc2822&lt;/code&gt; format, this format is very strict. Any variation in formatting will cause fast-import to reject the value.</source>
          <target state="translated">与 &lt;code&gt;rfc2822&lt;/code&gt; 格式不同，此格式非常严格。格式上的任何变化都将导致快速导入拒绝该值。</target>
        </trans-unit>
        <trans-unit id="a5e8af576412d2facd9f39a0996da0da165c42ee" translate="yes" xml:space="preserve">
          <source>Unlike the Porcelain format, the filename information is always given and terminates the entry:</source>
          <target state="translated">与瓷器格式不同的是,总是给出文件名信息并终止条目。</target>
        </trans-unit>
        <trans-unit id="b603b31236d9df1a4442c23c62ea6317f2525837" translate="yes" xml:space="preserve">
          <source>Unlike the longhand form, when Alice fetches from Bob using a remote repository shorthand set up with &lt;code&gt;git remote&lt;/code&gt;, what was fetched is stored in a remote-tracking branch, in this case &lt;code&gt;bob/master&lt;/code&gt;. So after this:</source>
          <target state="translated">与长格式不同，当爱丽丝使用通过 &lt;code&gt;git remote&lt;/code&gt; 设置的远程存储库速记从Bob获取时，所获取的内容存储在远程跟踪分支中，在本例中为 &lt;code&gt;bob/master&lt;/code&gt; 。因此，在此之后：</target>
        </trans-unit>
        <trans-unit id="cc8e9909209a90f3a790bc3005980e8527de79e5" translate="yes" xml:space="preserve">
          <source>Unlike the traditional &lt;code&gt;unified&lt;/code&gt; diff format, which shows two files A and B with a single column that has &lt;code&gt;-&lt;/code&gt; (minus &amp;mdash; appears in A but removed in B), &lt;code&gt;+&lt;/code&gt; (plus &amp;mdash; missing in A but added to B), or &lt;code&gt;&quot; &quot;&lt;/code&gt; (space &amp;mdash; unchanged) prefix, this format compares two or more files file1, file2,&amp;hellip;​ with one file X, and shows how X differs from each of fileN. One column for each of fileN is prepended to the output line to note how X&amp;rsquo;s line is different from it.</source>
          <target state="translated">与传统的 &lt;code&gt;unified&lt;/code&gt; 差异格式不同，传统的差异格式显示两个文件A和B，其中一个列具有 &lt;code&gt;-&lt;/code&gt; （减号-在A中出现，但在B中删除）， &lt;code&gt;+&lt;/code&gt; （加号-在A中丢失但添加到B中）或 &lt;code&gt;&quot; &quot;&lt;/code&gt; （空格（未更改）前缀，此格式将两个或多个文件file1，file2 ...与一个文件X进行比较，并显示X与每个fileN有何不同。每个fileN的一列都位于输出行的前面，以指出X的行与之不同。</target>
        </trans-unit>
        <trans-unit id="71233552f2a4fc77054593fac1f6899dd0308229" translate="yes" xml:space="preserve">
          <source>Unlike variables like &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;core.editor&lt;/code&gt; the &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; and &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; variables will not fall back on the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; configuration if they aren&amp;rsquo;t set. To uniformly configure the same fsck settings in different circumstances all three of them they must all set to the same values.</source>
          <target state="translated">与 &lt;code&gt;color.ui&lt;/code&gt; 和 &lt;code&gt;core.editor&lt;/code&gt; 之 &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 变量不同，receive.fsck。&amp;lt;msg-id&amp;gt;和 &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 变量如果不包含在 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 配置中组。为了在不同的情况下统一配置相同的fsck设置，必须将这三个设置都设置为相同的值。</target>
        </trans-unit>
        <trans-unit id="00ee5ed7b48c819f6f323dbe1b9a72aef5a0c864" translate="yes" xml:space="preserve">
          <source>Unlike variables like &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;core.editor&lt;/code&gt; the &lt;code&gt;receive.fsck.skipList&lt;/code&gt; and &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; variables will not fall back on the &lt;code&gt;fsck.skipList&lt;/code&gt; configuration if they aren&amp;rsquo;t set. To uniformly configure the same fsck settings in different circumstances all three of them they must all set to the same values.</source>
          <target state="translated">与变量一样 &lt;code&gt;color.ui&lt;/code&gt; 和 &lt;code&gt;core.editor&lt;/code&gt; 的 &lt;code&gt;receive.fsck.skipList&lt;/code&gt; 和 &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; 变量将不会依傍 &lt;code&gt;fsck.skipList&lt;/code&gt; 如果未设置它们的配置。为了在不同的情况下统一配置相同的fsck设置，必须将这三个设置都设置为相同的值。</target>
        </trans-unit>
        <trans-unit id="8a3dffb4c65d7a1f27e907ef2a919885d1125ac9" translate="yes" xml:space="preserve">
          <source>Unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, any updates outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; will be accepted without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;), whether that&amp;rsquo;s swapping e.g. a tree object for a blob, or a commit for another commit that&amp;rsquo;s doesn&amp;rsquo;t have the previous commit as an ancestor etc.</source>
          <target state="translated">与使用&lt;a href=&quot;git-push&quot;&gt;git-push [1]推送&lt;/a&gt;时不同，在refspec（或 &lt;code&gt;--force&lt;/code&gt; ）中，在 &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 之外的任何更新都将在不带 &lt;code&gt;+&lt;/code&gt; 的情况下被接受，无论是将树对象交换为blob，或针对另一个不具有先前祖先提交的提交的提交等。</target>
        </trans-unit>
        <trans-unit id="2f2516ccb262ba2dda1eeb5218e911868837ce78" translate="yes" xml:space="preserve">
          <source>Unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, there is no configuration which&amp;rsquo;ll amend these rules, and nothing like a &lt;code&gt;pre-fetch&lt;/code&gt; hook analogous to the &lt;code&gt;pre-receive&lt;/code&gt; hook.</source>
          <target state="translated">与推动时不同&lt;a href=&quot;git-push&quot;&gt;的git推[1] &lt;/a&gt;，没有配置which'll修改这些规则，并没有像 &lt;code&gt;pre-fetch&lt;/code&gt; 钩类似于 &lt;code&gt;pre-receive&lt;/code&gt; 钩。</target>
        </trans-unit>
        <trans-unit id="fb79f423670171900d7e94880e8d45907e9f995c" translate="yes" xml:space="preserve">
          <source>Unlock a working tree, allowing it to be pruned, moved or deleted.</source>
          <target state="translated">解锁一棵工作树,允许它被修剪、移动或删除。</target>
        </trans-unit>
        <trans-unit id="b00eee8b49227caba98e5d68033660ff6076ebcc" translate="yes" xml:space="preserve">
          <source>Unmerged entries have the following format; the first character is a &quot;u&quot; to distinguish from ordinary changed entries.</source>
          <target state="translated">未合并的条目具有以下格式;第一个字符是 &quot;u&quot;,以区别于普通的更改条目。</target>
        </trans-unit>
        <trans-unit id="2c99cc569343579b221cd64026ecc62bb1c21d7b" translate="yes" xml:space="preserve">
          <source>Unpack objects from a packed archive</source>
          <target state="translated">从打包的档案中解压对象</target>
        </trans-unit>
        <trans-unit id="42e2a268d032a6abb00d4cbd80feaa1ecd7a75d6" translate="yes" xml:space="preserve">
          <source>Unreachable tags, commits, and trees will also be accessed to find the tips of dangling segments of history. Use &lt;code&gt;--no-dangling&lt;/code&gt; if you don&amp;rsquo;t care about this output and want to speed it up further.</source>
          <target state="translated">无法访问的标签，提交和树也将被访问，以找到悬空的历史片段的提示。如果您不关心此输出并希望进一步提高输出速度，请使用 &lt;code&gt;--no-dangling&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8a4efd1d470fc3c5ede97084c82a35b9804122a" translate="yes" xml:space="preserve">
          <source>Unregister the given submodules, i.e. remove the whole &lt;code&gt;submodule.$name&lt;/code&gt; section from .git/config together with their work tree. Further calls to &lt;code&gt;git submodule update&lt;/code&gt;, &lt;code&gt;git submodule foreach&lt;/code&gt; and &lt;code&gt;git submodule sync&lt;/code&gt; will skip any unregistered submodules until they are initialized again, so use this command if you don&amp;rsquo;t want to have a local checkout of the submodule in your working tree anymore.</source>
          <target state="translated">取消注册给定的子模块，即从.git / config中删除整个 &lt;code&gt;submodule.$name&lt;/code&gt; 部分及其工作树。进一步调用 &lt;code&gt;git submodule update&lt;/code&gt; ， &lt;code&gt;git submodule foreach&lt;/code&gt; 和 &lt;code&gt;git submodule sync&lt;/code&gt; 将跳过所有未注册的子模块，直到再次对其进行初始化为止，因此，如果您不想在工作树中再次使用该子模块，请使用此命令。</target>
        </trans-unit>
        <trans-unit id="1431f68f359f8699975be39dca08302c67d68d9e" translate="yes" xml:space="preserve">
          <source>Unset</source>
          <target state="translated">Unset</target>
        </trans-unit>
        <trans-unit id="8ff954e80b42b18d3d0fcda602d94db1e46da2d4" translate="yes" xml:space="preserve">
          <source>Unsetting the &lt;code&gt;text&lt;/code&gt; attribute on a path tells Git not to attempt any end-of-line conversion upon checkin or checkout.</source>
          <target state="translated">在路径上取消设置 &lt;code&gt;text&lt;/code&gt; 属性会告诉Git在签入或签出时不要尝试任何行尾转换。</target>
        </trans-unit>
        <trans-unit id="7f84947907454dd0cb412d2a8e5d5e3b9c2382f0" translate="yes" xml:space="preserve">
          <source>Unsetting the variable, or setting it to empty, &quot;0&quot; or &quot;false&quot; (case insensitive) disables trace messages.</source>
          <target state="translated">取消设置变量,或将其设置为空、&quot;0 &quot;或 &quot;false&quot;(不区分大小写),禁用跟踪信息。</target>
        </trans-unit>
        <trans-unit id="c176eff9c64fa28a4b6af1aa296cc1394bbf7a80" translate="yes" xml:space="preserve">
          <source>Unshelve</source>
          <target state="translated">Unshelve</target>
        </trans-unit>
        <trans-unit id="9fde2b36ff30053ad23e6a695929873244cc0367" translate="yes" xml:space="preserve">
          <source>Unshelve options</source>
          <target state="translated">解压选项</target>
        </trans-unit>
        <trans-unit id="004e593b6690fb3d48f4f5a86eac1cd13b5b2234" translate="yes" xml:space="preserve">
          <source>Unshelving will take a shelved P4 changelist, and produce the equivalent git commit in the branch refs/remotes/p4-unshelved/&amp;lt;changelist&amp;gt;.</source>
          <target state="translated">取消搁置将使用搁置的P4更改列表，并在分支refs / remotes / p4-unshelved / &amp;lt;changelist&amp;gt;中产生等效的git commit。</target>
        </trans-unit>
        <trans-unit id="a6e7eb706e115cdaf88206be37eb67b232d007bc" translate="yes" xml:space="preserve">
          <source>Unspecified</source>
          <target state="translated">Unspecified</target>
        </trans-unit>
        <trans-unit id="78f88266b367e8b6e086054e91f1ebc89e168d16" translate="yes" xml:space="preserve">
          <source>Until Git version 2.20, and unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, any updates to &lt;code&gt;refs/tags/*&lt;/code&gt; would be accepted without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches. Since Git version 2.20, fetching to update &lt;code&gt;refs/tags/*&lt;/code&gt; works the same way as when pushing. I.e. any updates will be rejected without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;).</source>
          <target state="translated">在Git 2.20之前，与使用&lt;a href=&quot;git-push&quot;&gt;git-push [1]推送&lt;/a&gt;时不同，在refspec（或 &lt;code&gt;--force&lt;/code&gt; ）中不带 &lt;code&gt;+&lt;/code&gt; 的任何对 &lt;code&gt;refs/tags/*&lt;/code&gt; 的更新将被接受。提取时，我们混杂地认为从远程进行的所有标签更新都是强制提取。从Git版本2.20开始，获取更新 &lt;code&gt;refs/tags/*&lt;/code&gt; 的方式与推送时相同。也就是说，任何更新将在refspec（或 &lt;code&gt;--force&lt;/code&gt; ）中不带 &lt;code&gt;+&lt;/code&gt; 的情况下被拒绝。</target>
        </trans-unit>
        <trans-unit id="9514c500d61430538679eec9081979b274172cf9" translate="yes" xml:space="preserve">
          <source>Untracked cache</source>
          <target state="translated">未跟踪的缓存</target>
        </trans-unit>
        <trans-unit id="614ce4ff1bf92552970ab54ff766006d0da693f9" translate="yes" xml:space="preserve">
          <source>Untracked items have the following format:</source>
          <target state="translated">未追踪项目的格式如下:</target>
        </trans-unit>
        <trans-unit id="1eade895e693b4111455eda06a87af1097cf4d6c" translate="yes" xml:space="preserve">
          <source>Untyped &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;, e.g. the contents of a file.</source>
          <target state="translated">无类型的&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;，例如文件的内容。</target>
        </trans-unit>
        <trans-unit id="7b839a219907b09268c047c522a03961e96bd78b" translate="yes" xml:space="preserve">
          <source>Unused configuration variable. Used in Git versions 2.20 and 2.21 as an escape hatch to enable the legacy shellscript implementation of rebase. Now the built-in rewrite of it in C is always used. Setting this will emit a warning, to alert any remaining users that setting this now does nothing.</source>
          <target state="translated">未使用的配置变量。在 Git 2.20 和 2.21 版本中,它被用来作为一个转义窗口,以启用传统的 shell 脚本实现 rebase。现在总是使用 C 语言的内置重写。设置这个变量会发出一个警告,以提醒其余用户,设置这个变量不会有任何作用。</target>
        </trans-unit>
        <trans-unit id="315fc3f07f41b1c3600ceb87f6a9f32b85f1da70" translate="yes" xml:space="preserve">
          <source>Unused configuration variable. Used in Git versions 2.22 to 2.26 as an escape hatch to enable the legacy shellscript implementation of stash. Now the built-in rewrite of it in C is always used. Setting this will emit a warning, to alert any remaining users that setting this now does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca31b4c795dcb03444e6d0c037dbcd47081c70a9" translate="yes" xml:space="preserve">
          <source>Update affected files from CVS repository before attempting export.</source>
          <target state="translated">在尝试导出之前,更新CVS仓库中受影响的文件。</target>
        </trans-unit>
        <trans-unit id="82e59b151c004802a1fa23ba3e75a68d14df0e2a" translate="yes" xml:space="preserve">
          <source>Update an existing shelved changelist with this commit. Implies --shelve. Repeat for multiple shelved changelists.</source>
          <target state="translated">用此提交更新已搁置的变更列表。意味着 --shelve。对多个搁置的变更列表重复此操作。</target>
        </trans-unit>
        <trans-unit id="5433caf2e572561b5bb38ff5e69b0263d08b90aa" translate="yes" xml:space="preserve">
          <source>Update and examine branches from the repository you cloned from:</source>
          <target state="translated">更新和检查你克隆的仓库中的分支。</target>
        </trans-unit>
        <trans-unit id="381f15e94e347f076ef71f417ee29b782a6dcc4d" translate="yes" xml:space="preserve">
          <source>Update auxiliary info file to help dumb servers</source>
          <target state="translated">更新辅助信息文件以帮助哑巴服务器。</target>
        </trans-unit>
        <trans-unit id="d94aecddb1a2d3c03afb4a7cf4e1bb3a0123c2c6" translate="yes" xml:space="preserve">
          <source>Update hook</source>
          <target state="translated">更新钩子</target>
        </trans-unit>
        <trans-unit id="e5f960e3f28d7d7ea59f8750682a356ae18535be" translate="yes" xml:space="preserve">
          <source>Update remote refs along with associated objects</source>
          <target state="translated">更新远程参考文献和相关对象</target>
        </trans-unit>
        <trans-unit id="ee3315ea0cbb49ab6105a89db0964480184c3ce9" translate="yes" xml:space="preserve">
          <source>Update the Git repository with recent changes from p4, rebasing your work on top:</source>
          <target state="translated">用p4的最新变化更新Git仓库,将你的工作重新建立在上面。</target>
        </trans-unit>
        <trans-unit id="5937294218e2d7b95b7b77414b52c326239ca8d5" translate="yes" xml:space="preserve">
          <source>Update the index by adding new files that are unknown to the index and files modified in the working tree, but ignore files that have been removed from the working tree. This option is a no-op when no &amp;lt;pathspec&amp;gt; is used.</source>
          <target state="translated">通过添加索引未知的新文件和在工作树中修改的文件来更新索引，但忽略已从工作树中删除的文件。当不使用&amp;lt;pathspec&amp;gt;时，此选项为no-op。</target>
        </trans-unit>
        <trans-unit id="94df66721f1bfd4990972c3f5f4a0d6b61f59f9e" translate="yes" xml:space="preserve">
          <source>Update the index just where it already has an entry matching &amp;lt;pathspec&amp;gt;. This removes as well as modifies index entries to match the working tree, but adds no new files.</source>
          <target state="translated">在索引已经具有与&amp;lt;pathspec&amp;gt;匹配的条目的地方更新索引。这会删除和修改索引条目以匹配工作树，但不会添加任何新文件。</target>
        </trans-unit>
        <trans-unit id="03d173e098621e3730258998672da85e88b347b1" translate="yes" xml:space="preserve">
          <source>Update the index not only where the working tree has a file matching &amp;lt;pathspec&amp;gt; but also where the index already has an entry. This adds, modifies, and removes index entries to match the working tree.</source>
          <target state="translated">不仅在工作树具有与&amp;lt;pathspec&amp;gt;匹配的文件的地方，而且在索引已经具有条目的地方，更新索引。这将添加，修改和删除索引条目以匹配工作树。</target>
        </trans-unit>
        <trans-unit id="1a6e291eaaa3e731de98429f7fb37fdac90f0a22" translate="yes" xml:space="preserve">
          <source>Update the object name stored in a ref safely</source>
          <target state="translated">安全地更新存储在ref中的对象名称</target>
        </trans-unit>
        <trans-unit id="00f0c8a1eac4ed2966a7d563ef87a6387d365dcf" translate="yes" xml:space="preserve">
          <source>Update the origin repository&amp;rsquo;s master branch with the dev branch, allowing non-fast-forward updates. &lt;strong&gt;This can leave unreferenced commits dangling in the origin repository.&lt;/strong&gt; Consider the following situation, where a fast-forward is not possible:</source>
          <target state="translated">使用dev分支更新原始存储库的master分支，从而允许非快速更新。&lt;strong&gt;这可能会使未引用的提交悬在原始存储库中。&lt;/strong&gt;请考虑以下情况，其中不可能实现快进：</target>
        </trans-unit>
        <trans-unit id="b73d3968359117cfd051c2e81a709d1d9e1579b7" translate="yes" xml:space="preserve">
          <source>Update the reference to the value of the top reflog entry (i.e. &amp;lt;ref&amp;gt;@{0}) if the previous top entry was pruned. (This option is ignored for symbolic references.)</source>
          <target state="translated">如果先前的顶部条目被修剪，则将引用更新为顶部条目列表的值（即&amp;lt;ref&amp;gt; @ {0}）。（对于符号引用，将忽略此选项。）</target>
        </trans-unit>
        <trans-unit id="d7c08d3ae4fbcbbf6a3dc89cdba309659a4395bc" translate="yes" xml:space="preserve">
          <source>Update the reflog for &amp;lt;name&amp;gt; with &amp;lt;reason&amp;gt;. This is valid only when creating or updating a symbolic ref.</source>
          <target state="translated">用&amp;lt;原因&amp;gt;更新&amp;lt;名称&amp;gt;的引用日志。仅在创建或更新符号引用时有效。</target>
        </trans-unit>
        <trans-unit id="d053e75e709458eca9f01e5c8910658ea18a25cf" translate="yes" xml:space="preserve">
          <source>Update the registered submodules to match what the superproject expects by cloning missing submodules, fetching missing commits in submodules and updating the working tree of the submodules. The &quot;updating&quot; can be done in several ways depending on command line options and the value of &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration variable. The command line option takes precedence over the configuration variable. If neither is given, a &lt;code&gt;checkout&lt;/code&gt; is performed. The &lt;code&gt;update&lt;/code&gt; procedures supported both from the command line as well as through the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration are:</source>
          <target state="translated">通过克隆丢失的子模块，在子模块中获取丢失的提交并更新子模块的工作树，更新已注册的子模块，以符合超级项目的期望。根据命令行选项和 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 配置变量的值，可以通过几种方式完成&amp;ldquo;更新&amp;rdquo; 。命令行选项优先于配置变量。如果两者均未给出，则执行 &lt;code&gt;checkout&lt;/code&gt; 。该 &lt;code&gt;update&lt;/code&gt; 程序的命令行以及通过所支持的两个 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 配置为：</target>
        </trans-unit>
        <trans-unit id="9a189cb9ecf6f808972788504f5218556d75488e" translate="yes" xml:space="preserve">
          <source>Update the remote-tracking branches for the repository you cloned from, then merge one of them into your current branch:</source>
          <target state="translated">更新你克隆的仓库的远程跟踪分支,然后将其中一个分支合并到你当前的分支中。</target>
        </trans-unit>
        <trans-unit id="b4a6a66956cae4a12a849cae6094fa1d9187d293" translate="yes" xml:space="preserve">
          <source>Update the remote-tracking branches:</source>
          <target state="translated">更新远程跟踪分支。</target>
        </trans-unit>
        <trans-unit id="6d5daf3e771e4022d14d6727e49c69b93e7e63af" translate="yes" xml:space="preserve">
          <source>Update the sparse-checkout file to include additional patterns. By default, these patterns are read from the command-line arguments, but they can be read from stdin using the &lt;code&gt;--stdin&lt;/code&gt; option. When &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled, the given patterns are interpreted as directory names as in the &lt;code&gt;set&lt;/code&gt; subcommand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68dff1cbdca38d9a97763a1d9fd849e951b6a1b" translate="yes" xml:space="preserve">
          <source>Updates files in the working tree to match the version in the index or the specified tree. If no pathspec was given, &lt;code&gt;git checkout&lt;/code&gt; will also update &lt;code&gt;HEAD&lt;/code&gt; to set the specified branch as the current branch.</source>
          <target state="translated">更新工作树中的文件以匹配索引或指定树中的版本。如果没有给出pathspec， &lt;code&gt;git checkout&lt;/code&gt; 也会更新 &lt;code&gt;HEAD&lt;/code&gt; 以将指定的分支设置为当前分支。</target>
        </trans-unit>
        <trans-unit id="091bf3e8c6fb28b8688a9117ac018615896df561" translate="yes" xml:space="preserve">
          <source>Updates remote refs using local refs, while sending objects necessary to complete the given refs.</source>
          <target state="translated">使用本地参考文献更新远程参考文献,同时发送完成给定参考文献所需的对象。</target>
        </trans-unit>
        <trans-unit id="91ca9b60db53a2ebedea4c579e08371ec4025869" translate="yes" xml:space="preserve">
          <source>Updating A with the resulting merge commit will fast-forward and your push will be accepted.</source>
          <target state="translated">更新A并进行合并提交,会快速推进,你的推送会被接受。</target>
        </trans-unit>
        <trans-unit id="b1b31935884de26d68d690781ac1ec814b3bc924" translate="yes" xml:space="preserve">
          <source>Updating a repository with git fetch</source>
          <target state="translated">用git fetch更新版本库。</target>
        </trans-unit>
        <trans-unit id="c2ed1ab77aee7c3aaed70bc448641d662955a12f" translate="yes" xml:space="preserve">
          <source>Updating existing tests that assume GIT_TRACE format messages.</source>
          <target state="translated">更新现有的测试,假设GIT_TRACE格式的消息。</target>
        </trans-unit>
        <trans-unit id="c5ded60beb1b0eb17cab63a8e09a8acd2261286e" translate="yes" xml:space="preserve">
          <source>Updating the index did something else too: it created a &lt;code&gt;.git/index&lt;/code&gt; file. This is the index that describes your current working tree, and something you should be very aware of. Again, you normally never worry about the index file itself, but you should be aware of the fact that you have not actually really &quot;checked in&quot; your files into Git so far, you&amp;rsquo;ve only &lt;strong&gt;told&lt;/strong&gt; Git about them.</source>
          <target state="translated">更新索引也做了其他事情：它创建了一个 &lt;code&gt;.git/index&lt;/code&gt; 文件。这是描述您当前工作树的索引，您应该非常了解它。同样，您通常不必担心索引文件本身，但是您应该意识到，到目前为止，您还没有真正将文件&amp;ldquo;检入&amp;rdquo;到Git中，您只是&lt;strong&gt;告诉了&lt;/strong&gt; Git。</target>
        </trans-unit>
        <trans-unit id="583381e5edf6e3ab467919c38286667f0916979d" translate="yes" xml:space="preserve">
          <source>Upon completion, &amp;lt;branch&amp;gt; will be the current branch.</source>
          <target state="translated">完成后，&amp;lt;branch&amp;gt;将是当前分支。</target>
        </trans-unit>
        <trans-unit id="c956664b8da61af6d0e1bf33a6e1ff75cbe45ad1" translate="yes" xml:space="preserve">
          <source>Upon seeing an invalid object name in the input, pretend as if the bad input was not given.</source>
          <target state="translated">当看到输入中出现无效的对象名称时,就装作没有输入不良的样子。</target>
        </trans-unit>
        <trans-unit id="d725441fc805b8226e9417fb2c8cf53ac8d791d5" translate="yes" xml:space="preserve">
          <source>Upstream branch to compare against. May be any valid commit, not just an existing branch name. Defaults to the configured upstream for the current branch.</source>
          <target state="translated">与之比较的上游分支,可以是任何有效的提交,而不仅仅是现有的分支名。可以是任何有效的提交,而不仅仅是现有的分支名。默认为当前分支的上游配置。</target>
        </trans-unit>
        <trans-unit id="f5808323e4ba717fc383cb75e63b6cf3a4e857e7" translate="yes" xml:space="preserve">
          <source>Upstream branch to search for equivalent commits. Defaults to the upstream branch of HEAD.</source>
          <target state="translated">搜索等价提交的上游分支。默认为 HEAD 的上游分支。</target>
        </trans-unit>
        <trans-unit id="309bc26d3c4c2649258f95c7069216bb2a7ac5f4" translate="yes" xml:space="preserve">
          <source>Upstream location from which commits are identified to submit to p4. By default, this is the most recent p4 commit reachable from &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">确定提交要提交给p4的上游位置。默认情况下，这是 &lt;code&gt;HEAD&lt;/code&gt; 可访问的最新p4提交。</target>
        </trans-unit>
        <trans-unit id="df28f1403e8348eae4829434034d1a95e5fe659d" translate="yes" xml:space="preserve">
          <source>Url translation</source>
          <target state="translated">网址翻译</target>
        </trans-unit>
        <trans-unit id="7ae770d8c2db91584c78e413662ced65719f53ca" translate="yes" xml:space="preserve">
          <source>Usage of this flag will probably be rare, since you can get rid of commits that start empty by just firing up an interactive rebase and removing the lines corresponding to the commits you don&amp;rsquo;t want. This flag exists as a convenient shortcut, such as for cases where external tools generate many empty commits and you want them all removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51159e5f3b0adbeed98e188d040286280a5320b" translate="yes" xml:space="preserve">
          <source>Usage text</source>
          <target state="translated">使用文本</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="6039144c2dc6586b6f3f0cb7423bcc0b3de0d0c1" translate="yes" xml:space="preserve">
          <source>Use &quot;patience diff&quot; algorithm when generating patches.</source>
          <target state="translated">生成补丁时使用 &quot;耐心差异 &quot;算法。</target>
        </trans-unit>
        <trans-unit id="1712fa1f1e6f89a27b7d3117ed39073a3258971d" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;dir&amp;gt; to store the resulting files, instead of the current working directory.</source>
          <target state="translated">使用&amp;lt;dir&amp;gt;存储结果文件，而不是当前工作目录。</target>
        </trans-unit>
        <trans-unit id="89ed1ad2d65d4e1af42e685a9ee22c739e5d2c9b" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;message&amp;gt; instead of the branch names for the first line of the log message. For use with &lt;code&gt;--log&lt;/code&gt;.</source>
          <target state="translated">使用&amp;lt;message&amp;gt;代替日志消息第一行的分支名称。与 &lt;code&gt;--log&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="a8e6c324c4e7440184ef28eb2f6fc1fca5a4a325" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;regex&amp;gt; to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies &lt;code&gt;--word-diff&lt;/code&gt; unless it was already enabled.</source>
          <target state="translated">使用&amp;lt;regex&amp;gt;来确定单词是什么，而不是将非空白行视为一个单词。也意味着 &lt;code&gt;--word-diff&lt;/code&gt; ,除非已启用。</target>
        </trans-unit>
        <trans-unit id="f70b8a97f949594b729b07efce2ca59a63023925" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;!&lt;/code&gt; to not make the corresponding negated long option available.</source>
          <target state="translated">使用 &lt;code&gt;!&lt;/code&gt; 使相应的取反加长选项不可用。</target>
        </trans-unit>
        <trans-unit id="f7924a219e6794d45a36b15b2c44738227b795ff" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; to set the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; explicitly. e.g., &quot;git remote set-head origin master&quot; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 显式设置symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 。例如，&amp;ldquo; git remote set-head source origin master&amp;rdquo;会将symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; 设置为 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 。仅当 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 已经存在时，这才起作用；如果不是，则必须先获取它。</target>
        </trans-unit>
        <trans-unit id="e726751622c7eadb004a31b60b5fa1e9cc1fbf90" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; to set the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; explicitly. e.g., &lt;code&gt;git
remote set-head origin master&lt;/code&gt; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d950943422ee3b93275d1e4b1e510463e5b432e0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; to contact a running cache daemon (or start a new cache daemon if one is not started). Defaults to &lt;code&gt;$XDG_CACHE_HOME/git/credential/socket&lt;/code&gt; unless &lt;code&gt;~/.git-credential-cache/&lt;/code&gt; exists in which case &lt;code&gt;~/.git-credential-cache/socket&lt;/code&gt; is used instead. If your home directory is on a network-mounted filesystem, you may need to change this to a local filesystem. You must specify an absolute path.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 与正在运行的缓存守护程序联系（如果尚未启动，请启动一个新的缓存守护程序）。默认为 &lt;code&gt;$XDG_CACHE_HOME/git/credential/socket&lt;/code&gt; ，除非 &lt;code&gt;~/.git-credential-cache/&lt;/code&gt; 存在在这种情况下 &lt;code&gt;~/.git-credential-cache/socket&lt;/code&gt; 来代替。如果主目录位于网络安装的文件系统上，则可能需要将其更改为本地文件系统。您必须指定绝对路径。</target>
        </trans-unit>
        <trans-unit id="faabe60607ec900b5e4ad4f074b4870d8f9c10c6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; to lookup and store credentials. The file will have its filesystem permissions set to prevent other users on the system from reading it, but will not be encrypted or otherwise protected. If not specified, credentials will be searched for from &lt;code&gt;~/.git-credentials&lt;/code&gt; and &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt;, and credentials will be written to &lt;code&gt;~/.git-credentials&lt;/code&gt; if it exists, or &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; if it exists and the former does not. See also &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 查找和存储凭据。该文件将设置其文件系统权限，以防止系统上的其他用户读取该文件，但不会被加密或受到其他保护。如果没有指定，凭据将搜索从 &lt;code&gt;~/.git-credentials&lt;/code&gt; 和 &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; 和证书将被写入到 &lt;code&gt;~/.git-credentials&lt;/code&gt; ，如果它存在，或 &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; （如果存在）而前者则没有。另请参阅&lt;a href=&quot;#FILES&quot;&gt;文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aadb92eae500ef695bbe6a445720ce25246dd04e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;*&lt;/code&gt; to mean that this option should not be listed in the usage generated for the &lt;code&gt;-h&lt;/code&gt; argument. It&amp;rsquo;s shown for &lt;code&gt;--help-all&lt;/code&gt; as documented in &lt;a href=&quot;gitcli&quot;&gt;gitcli[7]&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;*&lt;/code&gt; 表示此选项不应在为 &lt;code&gt;-h&lt;/code&gt; 参数生成的用法中列出。如&lt;a href=&quot;gitcli&quot;&gt;gitcli [7]&lt;/a&gt;所示，它显示为 &lt;code&gt;--help-all&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bbcee2a044e9c08185b38acb1e1c57ceea88054" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--no-guess&lt;/code&gt; to disable this.</source>
          <target state="translated">使用 &lt;code&gt;--no-guess&lt;/code&gt; 禁用此功能。</target>
        </trans-unit>
        <trans-unit id="6deefc2a8fa6667ca14a90dee15faf81b1f0546a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-o master&lt;/code&gt; for continuing an import that was initially done by the old cvs2git tool.</source>
          <target state="translated">使用 &lt;code&gt;-o master&lt;/code&gt; 继续执行最初由旧cvs2git工具完成的导入。</target>
        </trans-unit>
        <trans-unit id="a4527eec708654a210ce88433047c8e573fb91f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-r&lt;/code&gt; together with &lt;code&gt;-d&lt;/code&gt; to delete remote-tracking branches. Note, that it only makes sense to delete remote-tracking branches if they no longer exist in the remote repository or if &lt;code&gt;git fetch&lt;/code&gt; was configured not to fetch them again. See also the &lt;code&gt;prune&lt;/code&gt; subcommand of &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; for a way to clean up all obsolete remote-tracking branches.</source>
          <target state="translated">与 &lt;code&gt;-d&lt;/code&gt; 一起使用 &lt;code&gt;-r&lt;/code&gt; 可以删除远程跟踪分支。请注意，仅当远程跟踪分支不再存在于远程存储库中或 &lt;code&gt;git fetch&lt;/code&gt; 配置为不再再次获取它们时，才有意义。另请参见&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;的 &lt;code&gt;prune&lt;/code&gt; 子命令，以清除所有过时的远程跟踪分支。</target>
        </trans-unit>
        <trans-unit id="eb7d25cab29167524de808a8da669505756898ee" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;=&lt;/code&gt; if the option takes an argument.</source>
          <target state="translated">如果该选项接受参数，则使用 &lt;code&gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d247642d4c8609f74c2030daa3d24c7c82d2e46d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;?&lt;/code&gt; to mean that the option takes an optional argument. You probably want to use the &lt;code&gt;--stuck-long&lt;/code&gt; mode to be able to unambiguously parse the optional argument.</source>
          <target state="translated">使用 &lt;code&gt;?&lt;/code&gt; 表示该选项采用可选参数。您可能希望使用 &lt;code&gt;--stuck-long&lt;/code&gt; 模式才能明确解析可选参数。</target>
        </trans-unit>
        <trans-unit id="7929eb6fd77d1ea35c9c481fc89518eafcc1cd45" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git bisect&lt;/code&gt; to get a short usage description, and &lt;code&gt;git bisect
help&lt;/code&gt; or &lt;code&gt;git bisect -h&lt;/code&gt; to get a long usage description.</source>
          <target state="translated">使用 &lt;code&gt;git bisect&lt;/code&gt; 可获得简短的用法说明，使用 &lt;code&gt;git bisect help&lt;/code&gt; 或 &lt;code&gt;git bisect -h&lt;/code&gt; 可获得较长的用法说明。</target>
        </trans-unit>
        <trans-unit id="599c65a25784af23c9351ba6f4874c534a65a263" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git cherry origin&lt;/code&gt; to see which ones of your patches were accepted, and/or use &lt;code&gt;git rebase origin&lt;/code&gt; to port your unmerged changes forward to the updated upstream.</source>
          <target state="translated">使用 &lt;code&gt;git cherry origin&lt;/code&gt; 查看被接受的补丁程序，和/或使用 &lt;code&gt;git rebase origin&lt;/code&gt; 将未合并的更改转发到更新的上游。</target>
        </trans-unit>
        <trans-unit id="f1986201248cbf297f2fb86d6f520b30d057ce7d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; or &lt;code&gt;git remote update&lt;/code&gt; to stay up to date.</source>
          <target state="translated">使用 &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; 或 &lt;code&gt;git remote update&lt;/code&gt; 保持最新。</target>
        </trans-unit>
        <trans-unit id="252ef42d37b56d31d5e5dc2525ae974052dfca91" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git format-patch origin&lt;/code&gt; to prepare patches for e-mail submission to your upstream and send it out. Go back to step 2. and continue.</source>
          <target state="translated">使用 &lt;code&gt;git format-patch origin&lt;/code&gt; 来准备补丁，以将电子邮件提交到上游并发送出去。返回第2步，然后继续。</target>
        </trans-unit>
        <trans-unit id="cd30f3ed950161de3f8267d9a18953af3c02784f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git mergetool&lt;/code&gt; to run one of several merge utilities to resolve merge conflicts. It is typically run after &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;git mergetool&lt;/code&gt; 运行多个合并实用程序之一来解决合并冲突。它通常在 &lt;code&gt;git merge&lt;/code&gt; 之后运行。</target>
        </trans-unit>
        <trans-unit id="6b298c06fc405635f29d06efdf0f42592d8075f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rev-parse&lt;/code&gt; in option parsing mode (see PARSEOPT section below).</source>
          <target state="translated">在选项解析模式下使用 &lt;code&gt;git rev-parse&lt;/code&gt; （请参阅下面的PARSEOPT部分）。</target>
        </trans-unit>
        <trans-unit id="7c9820d48befbd19730095f238fb8a15824823ad" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rev-parse&lt;/code&gt; in shell quoting mode (see SQ-QUOTE section below). In contrast to the &lt;code&gt;--sq&lt;/code&gt; option below, this mode does only quoting. Nothing else is done to command input.</source>
          <target state="translated">在shell引用模式下使用 &lt;code&gt;git rev-parse&lt;/code&gt; （请参阅下面的SQ-QUOTE部分）。与下面的 &lt;code&gt;--sq&lt;/code&gt; 选项相反，此模式仅引用。命令输入无其他操作。</target>
        </trans-unit>
        <trans-unit id="4c4d44083fa5e2a6971987cf935297be30994f4c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stash&lt;/code&gt; when you want to record the current state of the working directory and the index, but want to go back to a clean working directory. The command saves your local modifications away and reverts the working directory to match the &lt;code&gt;HEAD&lt;/code&gt; commit.</source>
          <target state="translated">当您想记录工作目录和索引的当前状态，但又想回到干净的工作目录时，请使用 &lt;code&gt;git stash&lt;/code&gt; 。该命令将您的本地修改保存下来，并还原工作目录以匹配 &lt;code&gt;HEAD&lt;/code&gt; 提交。</target>
        </trans-unit>
        <trans-unit id="41c11f9d8154a7d9c49ff48bc15e09cdeb4a9a5c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stripspace --strip-comments&lt;/code&gt; to obtain:</source>
          <target state="translated">使用 &lt;code&gt;git stripspace --strip-comments&lt;/code&gt; 获得：</target>
        </trans-unit>
        <trans-unit id="141b00818c5025cc15ff515d81283fc5705a8a4e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stripspace&lt;/code&gt; with no arguments to obtain:</source>
          <target state="translated">使用 &lt;code&gt;git stripspace&lt;/code&gt; 带参数的git stripspace获取：</target>
        </trans-unit>
        <trans-unit id="ae0479a18945009a7ebac30bdfceaa72c61a99c4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ident&lt;/code&gt; in the &lt;code&gt;From:&lt;/code&gt; header of each commit email. If the author ident of the commit is not textually identical to the provided &lt;code&gt;ident&lt;/code&gt;, place a &lt;code&gt;From:&lt;/code&gt; header in the body of the message with the original author. If no &lt;code&gt;ident&lt;/code&gt; is given, use the committer ident.</source>
          <target state="translated">在每个提交电子邮件的&amp;ldquo; &lt;code&gt;From:&lt;/code&gt; 标题中使用 &lt;code&gt;ident&lt;/code&gt; 。如果提交的作者身份与提供的 &lt;code&gt;ident&lt;/code&gt; 在文本上不相同，请在原始邮件的正文中放置一个 &lt;code&gt;From:&lt;/code&gt; 标头。如果没有给出 &lt;code&gt;ident&lt;/code&gt; ，则使用提交者标识。</target>
        </trans-unit>
        <trans-unit id="8fb68f530aa46816206d7ea34908da4d297edef3" translate="yes" xml:space="preserve">
          <source>Use IPv4 addresses only, ignoring IPv6 addresses.</source>
          <target state="translated">只使用IPv4地址,忽略IPv6地址。</target>
        </trans-unit>
        <trans-unit id="d89ac89f76f16a68a863b0d9f578ffd1a558d6b0" translate="yes" xml:space="preserve">
          <source>Use IPv6 addresses only, ignoring IPv4 addresses.</source>
          <target state="translated">只使用IPv6地址,忽略IPv4地址。</target>
        </trans-unit>
        <trans-unit id="23206ddfb8d01b68973d7bd9cccf799f208e3657" translate="yes" xml:space="preserve">
          <source>Use Message &amp;rarr; Insert file&amp;hellip;​ and insert the patch.</source>
          <target state="translated">使用消息&amp;rarr;插入文件...并插入补丁。</target>
        </trans-unit>
        <trans-unit id="1b7e380bb9ef947a64359e01f17ce54cd3bdece1" translate="yes" xml:space="preserve">
          <source>Use One Mark Per Commit</source>
          <target state="translated">每次承诺使用一个标记</target>
        </trans-unit>
        <trans-unit id="c24268aab2b43d4e294643c8fbcbd60d377e139b" translate="yes" xml:space="preserve">
          <source>Use POSIX extended/basic regexp for patterns. Default is to use basic regexp.</source>
          <target state="translated">对模式使用 POSIX 扩展/基本 regexp。默认是使用基本的regexp。</target>
        </trans-unit>
        <trans-unit id="36e96e4a2fd002679f3b794b4968539810c5c2eb" translate="yes" xml:space="preserve">
          <source>Use Perl-compatible regular expressions for patterns.</source>
          <target state="translated">对模式使用Perl兼容的正则表达式。</target>
        </trans-unit>
        <trans-unit id="fd46ce4ee0de88bb1a4ebb0e0c6375d24c2fb065" translate="yes" xml:space="preserve">
          <source>Use SO_REUSEADDR when binding the listening socket. This allows the server to restart without waiting for old connections to time out.</source>
          <target state="translated">在绑定监听套接字时,使用SO_REUSEADDR。这允许服务器重新启动,而不需要等待旧的连接超时。</target>
        </trans-unit>
        <trans-unit id="f351ffbdfc957393f82f6653e37778e19987b350" translate="yes" xml:space="preserve">
          <source>Use Tag Fixup Branches</source>
          <target state="translated">使用标签修复分支</target>
        </trans-unit>
        <trans-unit id="41019858ddf6bd113a2b54361af9c75b6d741367" translate="yes" xml:space="preserve">
          <source>Use \0 as the delimiter for pathnames in the output, and print them verbatim. Without this option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable core.quotePath (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67640e675158aa473b8a69cc0cdb46fb8ed7283f" translate="yes" xml:space="preserve">
          <source>Use a &quot;stable&quot; sum of hashes as the patch ID. With this option:</source>
          <target state="translated">使用一个 &quot;稳定的 &quot;哈希值之和作为补丁ID。有了这个选项。</target>
        </trans-unit>
        <trans-unit id="0ec5feaf620cc0230519584645c952a1ae99d83c" translate="yes" xml:space="preserve">
          <source>Use a client spec to find the list of interesting files in p4. See the &quot;CLIENT SPEC&quot; section below.</source>
          <target state="translated">使用客户端规范来查找p4中有趣的文件列表。参见下面的 &quot;CLIENT SPEC &quot;部分。</target>
        </trans-unit>
        <trans-unit id="cf410607b4d646fae6b37dffcb3f37fcc481f52b" translate="yes" xml:space="preserve">
          <source>Use a mergetool. &lt;code&gt;git mergetool&lt;/code&gt; to launch a graphical mergetool which will work you through the merge.</source>
          <target state="translated">使用mergetool。 &lt;code&gt;git mergetool&lt;/code&gt; 启动图形化合并工具，它将通过合并工作。</target>
        </trans-unit>
        <trans-unit id="e7589df3d820308df2c8a838829de10cfbcf2077" translate="yes" xml:space="preserve">
          <source>Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde &lt;code&gt;~&lt;/code&gt; on a line of its own.</source>
          <target state="translated">使用专用于脚本的基于行的特殊格式。添加/删除/未更改的运行以通常的统一diff格式打印，从行首的 &lt;code&gt;+&lt;/code&gt; / &lt;code&gt;-&lt;/code&gt; /``字符开始，一直扩展到行尾。输入中的换行符由自己的一行上的波浪号 &lt;code&gt;~&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="77b024aefcbc37a1627539595d18a928f0842816" translate="yes" xml:space="preserve">
          <source>Use a tarball as a starting point for a new repository.</source>
          <target state="translated">使用一个 tar 包作为新版本库的起点。</target>
        </trans-unit>
        <trans-unit id="afac3b09febbe243aa11caf12f594c7284e7bf23" translate="yes" xml:space="preserve">
          <source>Use an &quot;unstable&quot; hash as the patch ID. With this option, the result produced is compatible with the patch-id value produced by git 1.9 and older. Users with pre-existing databases storing patch-ids produced by git 1.9 and older (who do not deal with reordered patches) may want to use this option.</source>
          <target state="translated">使用 &quot;不稳定 &quot;的哈希值作为补丁 ID。使用这个选项,产生的结果会与 git 1.9 及更早版本的补丁 ID 值兼容。如果用户的数据库中已经存储了 git 1.9 或更早版本的补丁 ID(不处理重新排序的补丁),可能会希望使用这个选项。</target>
        </trans-unit>
        <trans-unit id="ef4088fc09156b38070cb26da8281dc7bfd8c504" translate="yes" xml:space="preserve">
          <source>Use an atomic transaction for updating the refs. If any of the refs fails to update then the entire push will fail without changing any refs.</source>
          <target state="translated">使用原子事务来更新refs。如果任何一个refs未能更新,那么整个推送将失败,而不会改变任何refs。</target>
        </trans-unit>
        <trans-unit id="049c3e05f1b188c69413c7549059c67376f76ed1" translate="yes" xml:space="preserve">
          <source>Use an atomic transaction on the remote side if available. Either all refs are updated, or on error, no refs are updated. If the server does not support atomic pushes the push will fail.</source>
          <target state="translated">如果有的话,在远程端使用原子事务。要么更新所有refs,要么出错时不更新refs。如果服务器不支持原子推送,推送将失败。</target>
        </trans-unit>
        <trans-unit id="402b0ecf5212c8d413a7923b4b251cf4b803a260" translate="yes" xml:space="preserve">
          <source>Use applying strategies to rebase (calling &lt;code&gt;git-am&lt;/code&gt; internally). This option may become a no-op in the future once the merge backend handles everything the apply one does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55fb404106de44576d9bc731a7fb4baf9a6337c" translate="yes" xml:space="preserve">
          <source>Use binary search to find the commit that introduced a bug</source>
          <target state="translated">使用二进制搜索来查找引入bug的提交。</target>
        </trans-unit>
        <trans-unit id="78ee9b127501691d305b39cc3fc13fc74a1d22a1" translate="yes" xml:space="preserve">
          <source>Use customized color for &lt;code&gt;git add --interactive&lt;/code&gt; and &lt;code&gt;git clean --interactive&lt;/code&gt; output. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; may be &lt;code&gt;prompt&lt;/code&gt;, &lt;code&gt;header&lt;/code&gt;, &lt;code&gt;help&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;, for four distinct types of normal output from interactive commands.</source>
          <target state="translated">对 &lt;code&gt;git add --interactive&lt;/code&gt; 和 &lt;code&gt;git clean --interactive&lt;/code&gt; 输出使用自定义颜色。对于来自交互命令的四种不同类型的常规输出， &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 可以是 &lt;code&gt;prompt&lt;/code&gt; ， &lt;code&gt;header&lt;/code&gt; ， &lt;code&gt;help&lt;/code&gt; 或 &lt;code&gt;error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf3aeb7f00c3d69ade01b5cc321078d4f50948ae" translate="yes" xml:space="preserve">
          <source>Use customized color for &lt;code&gt;git log --decorate&lt;/code&gt; output. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;branch&lt;/code&gt;, &lt;code&gt;remoteBranch&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;, &lt;code&gt;stash&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt; for local branches, remote-tracking branches, tags, stash and HEAD, respectively and &lt;code&gt;grafted&lt;/code&gt; for grafted commits.</source>
          <target state="translated">对 &lt;code&gt;git log --decorate&lt;/code&gt; 使用自定义颜色- 装饰输出。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 是本地分支，远程跟踪分支，tag，stash和HEAD 的 &lt;code&gt;branch&lt;/code&gt; ， &lt;code&gt;remoteBranch&lt;/code&gt; ， &lt;code&gt;tag&lt;/code&gt; ， &lt;code&gt;stash&lt;/code&gt; 或 &lt;code&gt;HEAD&lt;/code&gt; 之一，分别为嫁接的提交而被 &lt;code&gt;grafted&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29ecef38edab0e1998d46583be9558cf2a562eff" translate="yes" xml:space="preserve">
          <source>Use customized color for branch coloration. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;current&lt;/code&gt; (the current branch), &lt;code&gt;local&lt;/code&gt; (a local branch), &lt;code&gt;remote&lt;/code&gt; (a remote-tracking branch in refs/remotes/), &lt;code&gt;upstream&lt;/code&gt; (upstream tracking branch), &lt;code&gt;plain&lt;/code&gt; (other refs).</source>
          <target state="translated">使用自定义颜色进行分支着色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 是 &lt;code&gt;current&lt;/code&gt; （当前分支）， &lt;code&gt;local&lt;/code&gt; （本地分支）， &lt;code&gt;remote&lt;/code&gt; （refs / remotes /中的远程跟踪分支）， &lt;code&gt;upstream&lt;/code&gt; （上游跟踪分支）， &lt;code&gt;plain&lt;/code&gt; （其他ref）之一。</target>
        </trans-unit>
        <trans-unit id="fcdeebdb47ef8466da45d806c0dccf091f4447a0" translate="yes" xml:space="preserve">
          <source>Use customized color for diff colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; specifies which part of the patch to use the specified color, and is one of &lt;code&gt;context&lt;/code&gt; (context text - &lt;code&gt;plain&lt;/code&gt; is a historical synonym), &lt;code&gt;meta&lt;/code&gt; (metainformation), &lt;code&gt;frag&lt;/code&gt; (hunk header), &lt;code&gt;func&lt;/code&gt; (function in hunk header), &lt;code&gt;old&lt;/code&gt; (removed lines), &lt;code&gt;new&lt;/code&gt; (added lines), &lt;code&gt;commit&lt;/code&gt; (commit headers), &lt;code&gt;whitespace&lt;/code&gt; (highlighting whitespace errors), &lt;code&gt;oldMoved&lt;/code&gt; (deleted lines), &lt;code&gt;newMoved&lt;/code&gt; (added lines), &lt;code&gt;oldMovedDimmed&lt;/code&gt;, &lt;code&gt;oldMovedAlternative&lt;/code&gt;, &lt;code&gt;oldMovedAlternativeDimmed&lt;/code&gt;, &lt;code&gt;newMovedDimmed&lt;/code&gt;, &lt;code&gt;newMovedAlternative&lt;/code&gt;&lt;code&gt;newMovedAlternativeDimmed&lt;/code&gt; (See the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; setting of &lt;code&gt;--color-moved&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; for details), &lt;code&gt;contextDimmed&lt;/code&gt;, &lt;code&gt;oldDimmed&lt;/code&gt;, &lt;code&gt;newDimmed&lt;/code&gt;, &lt;code&gt;contextBold&lt;/code&gt;, &lt;code&gt;oldBold&lt;/code&gt;, and &lt;code&gt;newBold&lt;/code&gt; (see &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt; for details).</source>
          <target state="translated">使用自定义颜色进行diff着色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 指定补丁的哪一部分使用指定的颜色，并且是 &lt;code&gt;context&lt;/code&gt; （上下文文本- &lt;code&gt;plain&lt;/code&gt; 是历史同义词）， &lt;code&gt;meta&lt;/code&gt; （生成形式）， &lt;code&gt;frag&lt;/code&gt; （大块头）， &lt;code&gt;func&lt;/code&gt; （大块头中的函数）， &lt;code&gt;old&lt;/code&gt; （删除的行）， &lt;code&gt;new&lt;/code&gt; （添加的行）， &lt;code&gt;commit&lt;/code&gt; （提交标头）， &lt;code&gt;whitespace&lt;/code&gt; （突出显示空白错误）， &lt;code&gt;oldMoved&lt;/code&gt; （删除的行）， &lt;code&gt;newMoved&lt;/code&gt; （添加的行）， &lt;code&gt;oldMovedDimmed&lt;/code&gt; ， &lt;code&gt;oldMovedAlternative&lt;/code&gt; ， &lt;code&gt;oldMovedAlternativeDimmed&lt;/code&gt; ， &lt;code&gt;newMovedDimmed&lt;/code&gt; ， &lt;code&gt;newMovedAlternative&lt;/code&gt; &lt;code&gt;newMovedAlternativeDimmed&lt;/code&gt; （见 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 的设定 &lt;code&gt;--color-moved&lt;/code&gt; 在&lt;a href=&quot;git-diff&quot;&gt;GIT-DIFF [1]&lt;/a&gt;的详细信息）， &lt;code&gt;contextDimmed&lt;/code&gt; ， &lt;code&gt;oldDimmed&lt;/code&gt; ， &lt;code&gt;newDimmed&lt;/code&gt; ， &lt;code&gt;contextBold&lt;/code&gt; ， &lt;code&gt;oldBold&lt;/code&gt; ，和 &lt;code&gt;newBold&lt;/code&gt; （见&lt;a href=&quot;git-range-diff&quot;&gt;GIT-范围-DIFF [ 1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="799532fe06b09693cab5782f0c7b74d1305d2cb1" translate="yes" xml:space="preserve">
          <source>Use customized color for each remote keyword. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; may be &lt;code&gt;hint&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;success&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; which match the corresponding keyword.</source>
          <target state="translated">为每个远程关键字使用自定义颜色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 可以是 &lt;code&gt;hint&lt;/code&gt; ， &lt;code&gt;warning&lt;/code&gt; ， &lt;code&gt;success&lt;/code&gt; 或 &lt;code&gt;error&lt;/code&gt; ，它们与相应的关键字匹配。</target>
        </trans-unit>
        <trans-unit id="e8363e3bb3b19269f1bec63465f050d08c7400a8" translate="yes" xml:space="preserve">
          <source>Use customized color for grep colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; specifies which part of the line to use the specified color, and is one of</source>
          <target state="translated">使用自定义颜色进行grep着色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 指定使用指定颜色的行的哪一部分，并且是以下之一</target>
        </trans-unit>
        <trans-unit id="3d940f7a54cc13b6b8a420b163ce2b7e4ccedf38" translate="yes" xml:space="preserve">
          <source>Use customized color for hints.</source>
          <target state="translated">使用自定义颜色进行提示。</target>
        </trans-unit>
        <trans-unit id="a7bc0186c1d40a59aee910eedb6524484cbce3a0" translate="yes" xml:space="preserve">
          <source>Use customized color for push errors.</source>
          <target state="translated">使用自定义颜色进行推送错误。</target>
        </trans-unit>
        <trans-unit id="efd1e4b094e6a540e69b42772ae161651f4648a2" translate="yes" xml:space="preserve">
          <source>Use customized color for status colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;header&lt;/code&gt; (the header text of the status message), &lt;code&gt;added&lt;/code&gt; or &lt;code&gt;updated&lt;/code&gt; (files which are added but not committed), &lt;code&gt;changed&lt;/code&gt; (files which are changed but not added in the index), &lt;code&gt;untracked&lt;/code&gt; (files which are not tracked by Git), &lt;code&gt;branch&lt;/code&gt; (the current branch), &lt;code&gt;nobranch&lt;/code&gt; (the color the &lt;code&gt;no branch&lt;/code&gt; warning is shown in, defaulting to red), &lt;code&gt;localBranch&lt;/code&gt; or &lt;code&gt;remoteBranch&lt;/code&gt; (the local and remote branch names, respectively, when branch and tracking information is displayed in the status short-format), or &lt;code&gt;unmerged&lt;/code&gt; (files which have unmerged changes).</source>
          <target state="translated">使用自定义颜色进行状态着色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 是 &lt;code&gt;header&lt;/code&gt; （状态消息的标题文本），已 &lt;code&gt;added&lt;/code&gt; 或 &lt;code&gt;updated&lt;/code&gt; （已添加但未提交的文件），已 &lt;code&gt;changed&lt;/code&gt; （已更改但未添加到索引中的文件）， &lt;code&gt;untracked&lt;/code&gt; （未添加的文件）之一在以下位置显示分支和跟踪信息时，由Git跟踪）， &lt;code&gt;branch&lt;/code&gt; （当前分支）， &lt;code&gt;nobranch&lt;/code&gt; （显示 &lt;code&gt;no branch&lt;/code&gt; 警告的颜色，默认为红色）， &lt;code&gt;localBranch&lt;/code&gt; 或 &lt;code&gt;remoteBranch&lt;/code&gt; （分别为本地和远程分支名称）。状态短格式），或 &lt;code&gt;unmerged&lt;/code&gt; （具有未合并更改的文件）。</target>
        </trans-unit>
        <trans-unit id="42006ecfd08deb9b3ff0a3f1d7240d8f715710f3" translate="yes" xml:space="preserve">
          <source>Use customized color when a push was rejected.</source>
          <target state="translated">推送被拒绝时,使用自定义颜色。</target>
        </trans-unit>
        <trans-unit id="7714f2243f3ecb7a0c915a75f0d9677bee5cfddf" translate="yes" xml:space="preserve">
          <source>Use fixed strings for patterns (don&amp;rsquo;t interpret pattern as a regex).</source>
          <target state="translated">使用固定的字符串作为模式（不要将模式解释为正则表达式）。</target>
        </trans-unit>
        <trans-unit id="be83392780575c9c0f338875e4ab41fca7ad0580" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of Git objects. We check &lt;code&gt;&amp;lt;dir&amp;gt;/packs/multi-pack-index&lt;/code&gt; for the current MIDX file, and &lt;code&gt;&amp;lt;dir&amp;gt;/packs&lt;/code&gt; for the pack-files to index.</source>
          <target state="translated">将给定目录用于Git对象的位置。我们检查当前MIDX文件的 &lt;code&gt;&amp;lt;dir&amp;gt;/packs/multi-pack-index&lt;/code&gt; ，并检查要索引的pack-file的 &lt;code&gt;&amp;lt;dir&amp;gt;/packs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58e0e6d68f2b1086e2f61cc3ccf9bb473fce2cb1" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of packfiles and commit-graph file. This parameter exists to specify the location of an alternate that only has the objects directory, not a full &lt;code&gt;.git&lt;/code&gt; directory. The commit-graph file is expected to be in the &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; directory and the packfiles are expected to be in &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt;.</source>
          <target state="translated">将给定目录用于packfiles和commit-graph文件的位置。存在此参数以指定仅具有对象目录而不是完整的 &lt;code&gt;.git&lt;/code&gt; 目录的替代项的位置。提交图文件应位于 &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; 目录中，而packfile文件应位于 &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="034b8d3eb2bf376cba5a544572cc51a019ffd1af" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of packfiles and commit-graph file. This parameter exists to specify the location of an alternate that only has the objects directory, not a full &lt;code&gt;.git&lt;/code&gt; directory. The commit-graph file is expected to be in the &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; directory and the packfiles are expected to be in &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt;. If the directory could not be made into an absolute path, or does not match any known object directory, &lt;code&gt;git commit-graph ...&lt;/code&gt; will exit with non-zero status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e22ac3ec044552fceb6f971a8409c3fc735d918" translate="yes" xml:space="preserve">
          <source>Use gmail as the smtp server</source>
          <target state="translated">使用gmail作为smtp服务器</target>
        </trans-unit>
        <trans-unit id="243e0ec42451f8d223cf0a086b6e0d020fe017bc" translate="yes" xml:space="preserve">
          <source>Use hash &lt;code&gt;#&lt;/code&gt; for comments that are either on their own line, or after the email address.</source>
          <target state="translated">使用井号 &lt;code&gt;#&lt;/code&gt; 可以单独显示一行，也可以在电子邮件地址之后添加注释。</target>
        </trans-unit>
        <trans-unit id="fe4290ca9cf2dcf165b3911c20fcc8115cf36b09" translate="yes" xml:space="preserve">
          <source>Use libcurl to communicate with the IMAP server, unless tunneling into it. Ignored if Git was built without the USE_CURL_FOR_IMAP_SEND option set.</source>
          <target state="translated">使用 libcurl 与 IMAP 服务器通信,除非是通过隧道进入。如果 Git 在构建时没有设置 USE_CURL_FOR_IMAP_SEND 选项,则忽略。</target>
        </trans-unit>
        <trans-unit id="b43e2a7c9e04ff83908291bc454ceb95c66f26d2" translate="yes" xml:space="preserve">
          <source>Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt;.</source>
          <target state="translated">使用mailmap文件将作者和提交者的姓名和电子邮件地址映射到规范的真实姓名和电子邮件地址。参见&lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="869311b9e64386ec94c4224dbda98ca212bcb863" translate="yes" xml:space="preserve">
          <source>Use merging strategies to rebase. When the recursive (default) merge strategy is used, this allows rebase to be aware of renames on the upstream side.</source>
          <target state="translated">使用合并策略来rebase。当使用递归(默认)合并策略时,可以让rebase意识到上游侧的重名。</target>
        </trans-unit>
        <trans-unit id="07cf71eed9a3b36f45bcc6fde8a3af9707bd0146" translate="yes" xml:space="preserve">
          <source>Use merging strategies to rebase. When the recursive (default) merge strategy is used, this allows rebase to be aware of renames on the upstream side. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504dd078aaf1ec972f6af826bbe142e1450759fa" translate="yes" xml:space="preserve">
          <source>Use of &quot;topic branches&quot; solves these problems. The name is pretty self explanatory, with a caveat that comes from the &quot;merge upwards&quot; rule above:</source>
          <target state="translated">使用 &quot;主题分支 &quot;可以解决这些问题。这个名字很自圆其说,有一个注意事项,来自于上面的 &quot;向上合并 &quot;规则。</target>
        </trans-unit>
        <trans-unit id="2997460999cadfc1fcc5d52315d53b3d5efcd07d" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;dcommit&lt;/code&gt; is preferred to &lt;code&gt;set-tree&lt;/code&gt; (below).</source>
          <target state="translated">首选使用 &lt;code&gt;dcommit&lt;/code&gt; 来 &lt;code&gt;set-tree&lt;/code&gt; （如下）。</target>
        </trans-unit>
        <trans-unit id="6b08c4843a60fcea417d6fa6b7562621b3124054" translate="yes" xml:space="preserve">
          <source>Use of this utility is encouraged in favor of directly accessing files under the &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">鼓励使用此实用程序，以便直接访问 &lt;code&gt;.git&lt;/code&gt; 目录下的文件。</target>
        </trans-unit>
        <trans-unit id="3a96544176d9c64bcdfe76616987380a83e4f896" translate="yes" xml:space="preserve">
          <source>Use permissions reported by umask(2). The default, when &lt;code&gt;--shared&lt;/code&gt; is not specified.</source>
          <target state="translated">使用umask（2）报告的权限。默认值 &lt;code&gt;--shared&lt;/code&gt; 未指定。</target>
        </trans-unit>
        <trans-unit id="7b2e5a64a2bb1a5fbe6304abee401e1d3f35a8f4" translate="yes" xml:space="preserve">
          <source>Use reflog to find a better common ancestor between &amp;lt;upstream&amp;gt; and &amp;lt;branch&amp;gt; when calculating which commits have been introduced by &amp;lt;branch&amp;gt;.</source>
          <target state="translated">在计算&amp;lt;branch&amp;gt;引入了哪些提交时，使用reflog在&amp;lt;upstream&amp;gt;和&amp;lt;branch&amp;gt;之间找到更好的共同祖先。</target>
        </trans-unit>
        <trans-unit id="b40e39ff3f77007104d997879dd735023a9dca06" translate="yes" xml:space="preserve">
          <source>Use revisions from revs-file instead of calling &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;.</source>
          <target state="translated">使用revs-file中的修订，而不是调用&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efb298546ca010c6e357a2c3cc79d1b86fb2f356" translate="yes" xml:space="preserve">
          <source>Use the &quot;sparse&quot; algorithm to determine which objects to include in the pack, when combined with the &quot;--revs&quot; option. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames.</source>
          <target state="translated">当与&quot;--revs &quot;选项结合使用时,使用 &quot;sparse &quot;算法来决定哪些对象要包含在包中。这个算法只走出现在引入新对象的路径中的树。这在计算发送一个小变化的包时可以有显著的性能优势。然而,如果包含的提交包含某些类型的直接重命名,那么额外的对象有可能被添加到包文件中。</target>
        </trans-unit>
        <trans-unit id="0755f10a2fd51824d1737b45b49a4642d66873f8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--in-place&lt;/code&gt; option to edit a message file in place:</source>
          <target state="translated">使用 &lt;code&gt;--in-place&lt;/code&gt; 选项可就地编辑消息文件：</target>
        </trans-unit>
        <trans-unit id="55e7e1126d3aa0a5c8bf2360dfcd495bb1107882" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute only if you cannot store a file in UTF-8 encoding and if you want Git to be able to process the content as text.</source>
          <target state="translated">仅当您不能以UTF-8编码存储文件并且希望Git能够将内容作为文本处理时，才使用 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="b5ec705c3f1e9d70bd95302efbf5732684172042" translate="yes" xml:space="preserve">
          <source>Use the branch detection algorithm to find new paths in p4. It is documented below in &quot;BRANCH DETECTION&quot;.</source>
          <target state="translated">在p4中使用分支检测算法来寻找新的路径。下面在 &quot;BRANCH DETECTION &quot;中进行了说明。</target>
        </trans-unit>
        <trans-unit id="33ac56041ae34da6b3682a94d8a665913a47636a" translate="yes" xml:space="preserve">
          <source>Use the credential (e.g., access the URL with the username and password from step (2)), and see if it&amp;rsquo;s accepted.</source>
          <target state="translated">使用凭据（例如，使用步骤（2）中的用户名和密码访问URL），然后查看它是否被接受。</target>
        </trans-unit>
        <trans-unit id="4cfefdd524d37cf0c1fedc168c903048fc636bbd" translate="yes" xml:space="preserve">
          <source>Use the customized color for the part of git-blame output that is repeated meta information per line (such as commit id, author name, date and timezone). Defaults to cyan.</source>
          <target state="translated">为 git-blame 输出中每行重复元信息(如提交 ID、作者名、日期和时区)的部分使用自定义颜色。默认为青色。</target>
        </trans-unit>
        <trans-unit id="a024bae6c0f6ae8fa68e77c95e0c4f95100aa970" translate="yes" xml:space="preserve">
          <source>Use the diff tool specified by &amp;lt;tool&amp;gt;. Valid values include emerge, kompare, meld, and vimdiff. Run &lt;code&gt;git difftool --tool-help&lt;/code&gt; for the list of valid &amp;lt;tool&amp;gt; settings.</source>
          <target state="translated">使用&amp;lt;tool&amp;gt;指定的差异工具。有效值包括emerge，kompare，meld和vimdiff。运行 &lt;code&gt;git difftool --tool-help&lt;/code&gt; 以获得有效的&amp;lt;tool&amp;gt;设置列表。</target>
        </trans-unit>
        <trans-unit id="161588bc8b76efbad18d428ccf6e2f5e459908d1" translate="yes" xml:space="preserve">
          <source>Use the fast patchset import strategy. This can be significantly faster for large trees, but cannot handle directory renames or permissions changes. The default strategy is slow and safe.</source>
          <target state="translated">使用快速补丁集导入策略。这对于大型树来说,速度会显著加快,但不能处理目录重命名或权限更改。默认策略是缓慢而安全的。</target>
        </trans-unit>
        <trans-unit id="89541b63bc820ad5c76ea37101a62452ee62e61c" translate="yes" xml:space="preserve">
          <source>Use the following attributes if your &lt;code&gt;*.ps1&lt;/code&gt; files are UTF-16 little endian encoded without BOM and you want Git to use Windows line endings in the working directory (use &lt;code&gt;UTF-16LE-BOM&lt;/code&gt; instead of &lt;code&gt;UTF-16LE&lt;/code&gt; if you want UTF-16 little endian with BOM). Please note, it is highly recommended to explicitly define the line endings with &lt;code&gt;eol&lt;/code&gt; if the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute is used to avoid ambiguity.</source>
          <target state="translated">如果您的 &lt;code&gt;*.ps1&lt;/code&gt; 文件使用UTF-16小尾数编码而不带BOM，并且您希望Git在工作目录中使用Windows行尾（请使用 &lt;code&gt;UTF-16LE-BOM&lt;/code&gt; 而不是 &lt;code&gt;UTF-16LE&lt;/code&gt; )，请使用以下属性BOM的小尾数）。请注意，如果使用 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性以避免歧义，强烈建议使用 &lt;code&gt;eol&lt;/code&gt; 明确定义行尾。</target>
        </trans-unit>
        <trans-unit id="e5c2f58b6a6ebc713504e60181f4f0dd37da2d6d" translate="yes" xml:space="preserve">
          <source>Use the given &amp;lt;msg&amp;gt; as the commit message. If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs.</source>
          <target state="translated">使用给定的&amp;lt;msg&amp;gt;作为提交消息。如果给出了多个 &lt;code&gt;-m&lt;/code&gt; 选项，则它们的值将串联为单独的段落。</target>
        </trans-unit>
        <trans-unit id="be3b9715415e0357d3d87d01aa8f812c871fb1e1" translate="yes" xml:space="preserve">
          <source>Use the given &lt;code&gt;msg&lt;/code&gt; as the commit message. This option disables the &lt;code&gt;--edit&lt;/code&gt; option.</source>
          <target state="translated">使用给定的 &lt;code&gt;msg&lt;/code&gt; 作为提交消息。此选项禁用 &lt;code&gt;--edit&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="43103d879018fa15a44cefa9b3baec705e25165c" translate="yes" xml:space="preserve">
          <source>Use the given config file instead of the one specified by GIT_CONFIG.</source>
          <target state="translated">使用给定的配置文件代替GIT_CONFIG指定的文件。</target>
        </trans-unit>
        <trans-unit id="6d07104b51b424f44cb0346a9ac8f4116b0f06d7" translate="yes" xml:space="preserve">
          <source>Use the given exclude pattern in addition to the standard ignore rules (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;).</source>
          <target state="translated">除了标准的忽略规则（请参阅&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;）之外，还使用给定的排除模式。</target>
        </trans-unit>
        <trans-unit id="9a12bbd112f0b48f03fdbbbb0b9c68268bedd960" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy. If there is no &lt;code&gt;-s&lt;/code&gt; option &lt;code&gt;git merge-recursive&lt;/code&gt; is used instead. This implies --merge.</source>
          <target state="translated">使用给定的合并策略。如果没有 &lt;code&gt;-s&lt;/code&gt; 选项，则使用 &lt;code&gt;git merge-recursive&lt;/code&gt; 。这意味着--merge。</target>
        </trans-unit>
        <trans-unit id="aad779cdebc63bc4b25eb19e46a7b214101b70ea" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy. Should only be used once. See the MERGE STRATEGIES section in &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details.</source>
          <target state="translated">使用给定的合并策略。只能使用一次。有关详细信息，请参见&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]中的&amp;ldquo;合并&lt;/a&gt;策略&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="0d697cccd6049781089822f14d706ae91b43a781" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no &lt;code&gt;-s&lt;/code&gt; option, a built-in list of strategies is used instead (&lt;code&gt;git merge-recursive&lt;/code&gt; when merging a single head, &lt;code&gt;git merge-octopus&lt;/code&gt; otherwise).</source>
          <target state="translated">使用给定的合并策略；可以多次提供，以按应尝试的顺序指定它们。如果没有 &lt;code&gt;-s&lt;/code&gt; 选项，则使用内置策略列表代替（ &lt;code&gt;git merge-recursive&lt;/code&gt; 单个头部时使用git merge-recursive，否则使用 &lt;code&gt;git merge-octopus&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e15a6801b533c61848133f0481a1499ec359e784" translate="yes" xml:space="preserve">
          <source>Use the given note message (instead of prompting). If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs. Lines starting with &lt;code&gt;#&lt;/code&gt; and empty lines other than a single line between paragraphs will be stripped out.</source>
          <target state="translated">使用给定的注释消息（而不是提示）。如果给出了多个 &lt;code&gt;-m&lt;/code&gt; 选项，则它们的值将串联为单独的段落。以 &lt;code&gt;#&lt;/code&gt; 开头的行和段落之间的空行（段落之间的单行除外）将被删除。</target>
        </trans-unit>
        <trans-unit id="2301e57be484e5bf3374c6061960726be52acd3f" translate="yes" xml:space="preserve">
          <source>Use the given tag message (instead of prompting). If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs. Implies &lt;code&gt;-a&lt;/code&gt; if none of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is given.</source>
          <target state="translated">使用给定的标记消息（而不是提示）。如果给出了多个 &lt;code&gt;-m&lt;/code&gt; 选项，则它们的值将串联为单独的段落。意味着 &lt;code&gt;-a&lt;/code&gt; 如果没有的 &lt;code&gt;-a&lt;/code&gt; ， &lt;code&gt;-s&lt;/code&gt; ，或 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 给出。</target>
        </trans-unit>
        <trans-unit id="52a6c166f490dbb0be0d25b65f46015f7e67e623" translate="yes" xml:space="preserve">
          <source>Use the interactive patch selection interface to chose which changes to commit. See &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; for details.</source>
          <target state="translated">使用交互式补丁选择界面选择要提交的更改。有关详细信息，请参见&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7db128e87ada4e1ec3f3340d8431acfc429f3677" translate="yes" xml:space="preserve">
          <source>Use the merge resolution program specified by &amp;lt;tool&amp;gt;. Valid values include emerge, gvimdiff, kdiff3, meld, vimdiff, and tortoisemerge. Run &lt;code&gt;git mergetool --tool-help&lt;/code&gt; for the list of valid &amp;lt;tool&amp;gt; settings.</source>
          <target state="translated">使用&amp;lt;tool&amp;gt;指定的合并解决程序。有效值包括emerge，gvimdiff，kdiff3，meld，vimdiff和tortoisemerge。运行 &lt;code&gt;git mergetool --tool-help&lt;/code&gt; 以获得有效的&amp;lt;tool&amp;gt;设置列表。</target>
        </trans-unit>
        <trans-unit id="047156e36b9d6e8b2155d32a029545b1b026f10e" translate="yes" xml:space="preserve">
          <source>Use the multi-pack-index file to track multiple packfiles using a single index. See &lt;a href=&quot;multi-pack-index&quot;&gt;the multi-pack-index design document&lt;/a&gt;.</source>
          <target state="translated">使用multi-pack-index文件可使用单个索引跟踪多个packfile。请参阅&lt;a href=&quot;multi-pack-index&quot;&gt;multi-pack-index设计文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f14443aa07cf034aa00129ee21b4f7df2be49255" translate="yes" xml:space="preserve">
          <source>Use the partial clone feature and request that the server sends a subset of reachable objects according to a given object filter. When using &lt;code&gt;--filter&lt;/code&gt;, the supplied &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; is used for the partial clone filter. For example, &lt;code&gt;--filter=blob:none&lt;/code&gt; will filter out all blobs (file contents) until needed by Git. Also, &lt;code&gt;--filter=blob:limit=&amp;lt;size&amp;gt;&lt;/code&gt; will filter out all blobs of size at least &lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;. For more details on filter specifications, see the &lt;code&gt;--filter&lt;/code&gt; option in &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bac5b4ccbcc396e691c8ba8f2af89d4f60c9270" translate="yes" xml:space="preserve">
          <source>Use the same output mode as &lt;a href=&quot;git-annotate&quot;&gt;git-annotate[1]&lt;/a&gt; (Default: off).</source>
          <target state="translated">使用与&lt;a href=&quot;git-annotate&quot;&gt;git-annotate [1]&lt;/a&gt;相同的输出模式（默认值：关闭）。</target>
        </trans-unit>
        <trans-unit id="0ed67a2ecd3a9ee96ae4cd7dcb45f48a2cf84bf4" translate="yes" xml:space="preserve">
          <source>Use the selected commit message without launching an editor. For example, &lt;code&gt;git commit --amend --no-edit&lt;/code&gt; amends a commit without changing its commit message.</source>
          <target state="translated">使用选定的提交消息而不启动编辑器。例如， &lt;code&gt;git commit --amend --no-edit&lt;/code&gt; 修改提交而不更改其提交消息。</target>
        </trans-unit>
        <trans-unit id="8e65c034e7da87d64be153e02b39a8529bd16f67" translate="yes" xml:space="preserve">
          <source>Use the source ref that matches &lt;code&gt;master&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) to update the ref that matches &lt;code&gt;satellite/master&lt;/code&gt; (most probably &lt;code&gt;refs/remotes/satellite/master&lt;/code&gt;) in the &lt;code&gt;mothership&lt;/code&gt; repository; do the same for &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;satellite/dev&lt;/code&gt;.</source>
          <target state="translated">使用与 &lt;code&gt;master&lt;/code&gt; 匹配的源ref （例如 &lt;code&gt;refs/heads/master&lt;/code&gt; ）来更新与 &lt;code&gt;mothership&lt;/code&gt; 库中的 &lt;code&gt;satellite/master&lt;/code&gt; 匹配的ref （最有可能是 &lt;code&gt;refs/remotes/satellite/master&lt;/code&gt; ）；对 &lt;code&gt;dev&lt;/code&gt; 和 &lt;code&gt;satellite/dev&lt;/code&gt; 做同样的事情。</target>
        </trans-unit>
        <trans-unit id="82b93c6560af27195da14e70510e2b3d8651c3b7" translate="yes" xml:space="preserve">
          <source>Use the specified HTTP protocol version when communicating with a server. If you want to force the default. The available and default version depend on libcurl. Actually the possible values of this option are:</source>
          <target state="translated">与服务器通信时使用指定的HTTP协议版本。如果你想强制使用默认版本。可用和默认版本取决于libcurl。其实这个选项的可能值是</target>
        </trans-unit>
        <trans-unit id="85fede53ff0add46d3665dfda925d3c1db752a7f" translate="yes" xml:space="preserve">
          <source>Use the specified HTTP protocol version when communicating with a server. If you want to force the default. The available and default version depend on libcurl. Currently the possible values of this option are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="becfdaabcf538340d904ac918eb155dd5d16c802" translate="yes" xml:space="preserve">
          <source>Use the specified URL to connect to the destination Subversion repository. This is useful in cases where the source SVN repository is read-only. This option overrides configuration property &lt;code&gt;commiturl&lt;/code&gt;.</source>
          <target state="translated">使用指定的URL连接到目标Subversion存储库。在源SVN存储库为只读的情况下，这很有用。此选项将覆盖配置属性 &lt;code&gt;commiturl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eded6790141cbbb141d77bfcf5fc351397828538" translate="yes" xml:space="preserve">
          <source>Use the specified name for the initial branch in the newly created repository. If not specified, fall back to the default name: &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e057e9e47493412f91dea4102ac0984cb71bdeb" translate="yes" xml:space="preserve">
          <source>Use the value of the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable to decide what to notice as error.</source>
          <target state="translated">使用 &lt;code&gt;core.whitespace&lt;/code&gt; 配置变量的值来确定要注意的错误。</target>
        </trans-unit>
        <trans-unit id="810f8c03feb9550dd6740190f543dbb37624e241" translate="yes" xml:space="preserve">
          <source>Use this custom program instead of &quot;&lt;code&gt;gpg&lt;/code&gt;&quot; found on &lt;code&gt;$PATH&lt;/code&gt; when making or verifying a PGP signature. The program must support the same command-line interface as GPG, namely, to verify a detached signature, &quot;&lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt;&quot; is run, and the program is expected to signal a good signature by exiting with code 0, and to generate an ASCII-armored detached signature, the standard input of &quot;&lt;code&gt;gpg -bsau $key&lt;/code&gt;&quot; is fed with the contents to be signed, and the program is expected to send the result to its standard output.</source>
          <target state="translated">制作或验证PGP签名时，请使用此自定义程序，而不要在 &lt;code&gt;$PATH&lt;/code&gt; 上找到&amp;ldquo; &lt;code&gt;gpg&lt;/code&gt; &amp;rdquo; 。该程序必须支持与GPG相同的命令行界面，即，验证分离的签名，运行&amp;ldquo; &lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt; &amp;rdquo;，并且该程序应通过退出代码来发出良好的签名信号0，并生成一个ASCII装甲的分离签名，&amp;ldquo; &lt;code&gt;gpg -bsau $key&lt;/code&gt; &amp;rdquo; 的标准输入被馈送了要签名的内容，程序期望将结果发送到其标准输出。</target>
        </trans-unit>
        <trans-unit id="a644dabd3c4c5e288aecaab3da05ddb8c7da086c" translate="yes" xml:space="preserve">
          <source>Use this for compatibility with old-style branch names used by earlier versions of &lt;code&gt;git archimport&lt;/code&gt;. Old-style branch names were category--branch, whereas new-style branch names are archive,category--branch--version. In both cases, names given on the command-line will override the automatically-generated ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad85fb495e355ea9ee99bf9caef60d6a5acc4df9" translate="yes" xml:space="preserve">
          <source>Use this for compatibility with old-style branch names used by earlier versions of &lt;code&gt;git archimport&lt;/code&gt;. Old-style branch names were category{litdd}branch, whereas new-style branch names are archive,category{litdd}branch{litdd}version. In both cases, names given on the command-line will override the automatically-generated ones.</source>
          <target state="translated">使用它与 &lt;code&gt;git archimport&lt;/code&gt; 的早期版本使用的旧式分支名称兼容。旧样式的分支名称是类别{litdd}分支，而新样式的分支名称是存档，类别{litdd}分支{litdd}版本。在这两种情况下，命令行上给定的名称都将覆盖自动生成的名称。</target>
        </trans-unit>
        <trans-unit id="f09efb8456c99114df5272977533145bfda3715e" translate="yes" xml:space="preserve">
          <source>Use this option to integrate changes from the upstream subproject with your submodule&amp;rsquo;s current HEAD. Alternatively, you can run &lt;code&gt;git pull&lt;/code&gt; from the submodule, which is equivalent except for the remote branch name: &lt;code&gt;update --remote&lt;/code&gt; uses the default upstream repository and &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt;, while &lt;code&gt;git pull&lt;/code&gt; uses the submodule&amp;rsquo;s &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;. Prefer &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; if you want to distribute the default upstream branch with the superproject and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; if you want a more native feel while working in the submodule itself.</source>
          <target state="translated">使用此选项可以将上游子项目中的更改与子模块的当前HEAD集成在一起。或者，您可以从子模块运行 &lt;code&gt;git pull&lt;/code&gt; ，除了远程分支名称外，它是等效的： &lt;code&gt;update --remote&lt;/code&gt; 使用默认的上游存储库和 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; ，而 &lt;code&gt;git pull&lt;/code&gt; 使用子模块的 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 。合并。身高 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; ，如果你想与上层项目和分发默认的上游分支 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 如果你想要一个更原始的感觉辅助模块本身工作时。</target>
        </trans-unit>
        <trans-unit id="205f9bc458a5cacd665ee1af1eac8a989bc13811" translate="yes" xml:space="preserve">
          <source>Use this option to set the namespace where the original commits will be stored. The default value is &lt;code&gt;refs/original&lt;/code&gt;.</source>
          <target state="translated">使用此选项设置将存储原始提交的名称空间。默认值为 &lt;code&gt;refs/original&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="978a87da673ee3d6baf57006a070d2ceaf2e0a29" translate="yes" xml:space="preserve">
          <source>Use this option to set the path to the temporary directory used for rewriting. When applying a tree filter, the command needs to temporarily check out the tree to some directory, which may consume considerable space in case of large projects. By default it does this in the &lt;code&gt;.git-rewrite/&lt;/code&gt; directory but you can override that choice by this parameter.</source>
          <target state="translated">使用此选项可以将路径设置为用于重写的临时目录。应用树过滤器时，该命令需要临时将树检出到某个目录，如果大型项目，这可能会占用大量空间。默认情况下，它在 &lt;code&gt;.git-rewrite/&lt;/code&gt; 目录中执行此操作，但是您可以通过此参数覆盖该选择。</target>
        </trans-unit>
        <trans-unit id="7dad6966beac366ffc5d985e757265d090b93f5a" translate="yes" xml:space="preserve">
          <source>Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.</source>
          <target state="translated">使用此选项可以解除阶段,只从索引中删除路径。工作树文件,无论是否被修改,都将被保留。</target>
        </trans-unit>
        <trans-unit id="22e3468b42fc7b02294ecbf3cdd521f378eedf7b" translate="yes" xml:space="preserve">
          <source>Use this to customize the program used for the signing format you chose. (see &lt;code&gt;gpg.program&lt;/code&gt; and &lt;code&gt;gpg.format&lt;/code&gt;) &lt;code&gt;gpg.program&lt;/code&gt; can still be used as a legacy synonym for &lt;code&gt;gpg.openpgp.program&lt;/code&gt;. The default value for &lt;code&gt;gpg.x509.program&lt;/code&gt; is &quot;gpgsm&quot;.</source>
          <target state="translated">使用此功能可自定义用于所选签名格式的程序。 （请参阅 &lt;code&gt;gpg.program&lt;/code&gt; 和 &lt;code&gt;gpg.format&lt;/code&gt; ） &lt;code&gt;gpg.program&lt;/code&gt; 仍可以用作 &lt;code&gt;gpg.openpgp.program&lt;/code&gt; 的旧同义词。 &lt;code&gt;gpg.x509.program&lt;/code&gt; 的默认值为&amp;ldquo; gpgsm&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2c0ec0febb1ffdfb71fd1faf1bdd4ef5cebdb7eb" translate="yes" xml:space="preserve">
          <source>Use this to specify the path to &lt;code&gt;git-upload-pack&lt;/code&gt; on the remote side, if is not found on your $PATH. Installations of sshd ignores the user&amp;rsquo;s environment setup scripts for login shells (e.g. .bash_profile) and your privately installed git may not be found on the system default $PATH. Another workaround suggested is to set up your $PATH in &quot;.bashrc&quot;, but this flag is for people who do not want to pay the overhead for non-interactive shells by having a lean .bashrc file (they set most of the things up in .bash_profile).</source>
          <target state="translated">如果在您的$ PATH中找不到 &lt;code&gt;git-upload-pack&lt;/code&gt; 的路径，可使用它来指定该路径。 sshd的安装将忽略用户用于登录Shell的环境设置脚本（例如.bash_profile），并且在系统默认$ PATH上可能找不到您私人安装的git。建议的另一种解决方法是在&amp;ldquo; .bashrc&amp;rdquo;中设置$ PATH，但是此标志适用于那些不想通过使用lean .bashrc文件来支付非交互式shell开销的人（它们将大部分内容设置为在.bash_profile中）。</target>
        </trans-unit>
        <trans-unit id="1f3cdffd9311e81ebd0ee41b41de344f546bb6a2" translate="yes" xml:space="preserve">
          <source>Used DBI driver. You can specify any available driver for this here, but it might not work. cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Please regard this as an experimental feature. May not contain colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;</source>
          <target state="translated">使用过的DBI驱动程序。您可以在此处指定任何可用的驱动程序，但可能无法使用。 cvsserver已通过 &lt;code&gt;DBD::SQLite&lt;/code&gt; 测试，据报告可与 &lt;code&gt;DBD::Pg&lt;/code&gt; ，并报告&lt;strong&gt;不适&lt;/strong&gt;用于 &lt;code&gt;DBD::mysql&lt;/code&gt; 。请将此作为实验功能。不得包含冒号（ &lt;code&gt;:&lt;/code&gt; ）。默认值： &lt;code&gt;SQLite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e96c8aa1d6db1322edc422d5cc1ffbd12e71daed" translate="yes" xml:space="preserve">
          <source>Used Perl DBI driver. You can specify any available driver for this here, but it might not work. git-cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Experimental feature. May not contain double colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">使用过的Perl DBI驱动程序。您可以在此处指定任何可用的驱动程序，但可能无法使用。 git-cvsserver已使用 &lt;code&gt;DBD::SQLite&lt;/code&gt; 进行了测试，据报告可与 &lt;code&gt;DBD::Pg&lt;/code&gt; ，并报告&lt;strong&gt;不适&lt;/strong&gt;用于 &lt;code&gt;DBD::mysql&lt;/code&gt; 。实验功能。但不能包含双冒号（ &lt;code&gt;:&lt;/code&gt; ）。默认值： &lt;code&gt;SQLite&lt;/code&gt; 。参见&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3dcc5e110a8886980641614ba00244bbf70eb3c6" translate="yes" xml:space="preserve">
          <source>Used as %(if)&amp;hellip;​%(then)&amp;hellip;​%(end) or %(if)&amp;hellip;​%(then)&amp;hellip;​%(else)&amp;hellip;​%(end). If there is an atom with value or string literal after the %(if) then everything after the %(then) is printed, else if the %(else) atom is used, then everything after %(else) is printed. We ignore space when evaluating the string before %(then), this is useful when we use the %(HEAD) atom which prints either &quot;*&quot; or &quot; &quot; and we want to apply the &lt;code&gt;if&lt;/code&gt; condition only on the &lt;code&gt;HEAD&lt;/code&gt; ref. Append &quot;:equals=&amp;lt;string&amp;gt;&quot; or &quot;:notequals=&amp;lt;string&amp;gt;&quot; to compare the value between the %(if:&amp;hellip;​) and %(then) atoms with the given string.</source>
          <target state="translated">用作％（if）...％（then）...％（end）或％（if）...％（then）...％（else）...％（end）。如果在％（if）后面有一个带有值或字符串文字的原子，那么将打印％（then）之后的所有内容，否则，如果使用％（else）原子，则将打印％（else）之后的所有内容。我们在评估％（then）之前的字符串时会忽略空格，当我们使用％（HEAD）原子打印&amp;ldquo; *&amp;rdquo;或&amp;ldquo;&amp;rdquo;并且我们只想在 &lt;code&gt;HEAD&lt;/code&gt; ref 上应用 &lt;code&gt;if&lt;/code&gt; 条件时，这很有用。附加&amp;ldquo;：equals = &amp;lt;string&amp;gt;&amp;rdquo;或&amp;ldquo;：notequals = &amp;lt;string&amp;gt;&amp;rdquo;可以比较％（if：&amp;hellip;）和％（then）原子与给定字符串之间的值。</target>
        </trans-unit>
        <trans-unit id="88972a7007de9e429d28d6bad7487052b23f9b65" translate="yes" xml:space="preserve">
          <source>Used to check that a bundle file is valid and will apply cleanly to the current repository. This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository. &lt;code&gt;git bundle&lt;/code&gt; prints a list of missing commits, if any, and exits with a non-zero status.</source>
          <target state="translated">用于检查捆绑文件是否有效，并将其干净地应用于当前存储库。这包括检查包格式本身，以及检查必备提交是否存在以及是否在当前存储库中完全链接。 &lt;code&gt;git bundle&lt;/code&gt; 打印丢失的提交列表（如果有），并以非零状态退出。</target>
        </trans-unit>
        <trans-unit id="a81dfbb4b6756f63bb43c72d54c78dd02ef851d4" translate="yes" xml:space="preserve">
          <source>Used to create a bundle named &lt;code&gt;file&lt;/code&gt;. This requires the &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; arguments to define the bundle contents. &lt;code&gt;options&lt;/code&gt; contains the options specific to the &lt;code&gt;git bundle create&lt;/code&gt; subcommand.</source>
          <target state="translated">用于创建名为 &lt;code&gt;file&lt;/code&gt; 的捆绑包。这需要 &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; 参数来定义分发包内容。 &lt;code&gt;options&lt;/code&gt; 包含特定于 &lt;code&gt;git bundle create&lt;/code&gt; 子命令的选项。</target>
        </trans-unit>
        <trans-unit id="fe127bac2ab0b61ffb60c0284f3741224c9951e1" translate="yes" xml:space="preserve">
          <source>Used to enforce or disable certificate revocation checks in cURL when http.sslBackend is set to &quot;schannel&quot;. Defaults to &lt;code&gt;true&lt;/code&gt; if unset. Only necessary to disable this if Git consistently errors and the message is about checking the revocation status of a certificate. This option is ignored if cURL lacks support for setting the relevant SSL option at runtime.</source>
          <target state="translated">当http.sslBackend设置为&amp;ldquo; schannel&amp;rdquo;时，用于强制或禁用cURL中的证书吊销检查。如果未设置，则默认为 &lt;code&gt;true&lt;/code&gt; 。只有在Git持续出错并且消息是关于检查证书的吊销状态时，才需要禁用此功能。如果cURL不支持在运行时设置相关SSL选项，则忽略此选项。</target>
        </trans-unit>
        <trans-unit id="526891fe0801e3a16c20e50ecde492e75d4f6490" translate="yes" xml:space="preserve">
          <source>Used to set the maximum load that we will still respond to gitweb queries. If the server load exceeds this value then gitweb will return &quot;503 Service Unavailable&quot; error. The server load is taken to be 0 if gitweb cannot determine its value. Currently it works only on Linux, where it uses &lt;code&gt;/proc/loadavg&lt;/code&gt;; the load there is the number of active tasks on the system &amp;mdash; processes that are actually running &amp;mdash; averaged over the last minute.</source>
          <target state="translated">用于设置我们仍将响应gitweb查询的最大负载。如果服务器负载超过此值，则gitweb将返回&amp;ldquo; 503 Service Unavailable&amp;rdquo;错误。如果gitweb无法确定其值，则将服务器负载视为0。目前，它仅在使用 &lt;code&gt;/proc/loadavg&lt;/code&gt; 的 Linux上有效；负载是系统上当前活动任务的数量（实际上是正在运行的进程）在最后一分钟内的平均值。</target>
        </trans-unit>
        <trans-unit id="184dba4369820f49a823e624aa006f74d3fc96ef" translate="yes" xml:space="preserve">
          <source>Used with --remote to specify the path to the &lt;code&gt;git-upload-archive&lt;/code&gt; on the remote side.</source>
          <target state="translated">与--remote一起使用，以指定远程端 &lt;code&gt;git-upload-archive&lt;/code&gt; 的路径。</target>
        </trans-unit>
        <trans-unit id="a985abb59dca2d23760f5b7ff00e7d00f2d0f353" translate="yes" xml:space="preserve">
          <source>Used with &lt;code&gt;--range-diff&lt;/code&gt;, tweak the heuristic which matches up commits between the previous and current series of patches by adjusting the creation/deletion cost fudge factor. See &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt;) for details.</source>
          <target state="translated">与 &lt;code&gt;--range-diff&lt;/code&gt; 一起使用，可通过调整创建/删除成本软键系数来调整启发式算法，以匹配先前和当前系列补丁之间的提交。有关详细信息，请参见&lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9777df5e2d0f3ca27a559e53074b9f39896040e8" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;fetch&lt;/code&gt; command.</source>
          <target state="translated">与 &lt;code&gt;fetch&lt;/code&gt; 命令一起使用。</target>
        </trans-unit>
        <trans-unit id="ea99fa3d480e34606197cb808cc4a18c1d6b1306" translate="yes" xml:space="preserve">
          <source>User Manual</source>
          <target state="translated">用户手册</target>
        </trans-unit>
        <trans-unit id="3d338fa6790366b9708dc60a5019a8d98f73c4b3" translate="yes" xml:space="preserve">
          <source>User configuration and preferences are stored at:</source>
          <target state="translated">用户配置和偏好存储在:</target>
        </trans-unit>
        <trans-unit id="ba3e3bfcde6395de2671f768450f02d32f692aba" translate="yes" xml:space="preserve">
          <source>User name (e.g., &lt;code&gt;user&lt;/code&gt; in &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt;). If the config key has a user name it must match the user name in the URL exactly. If the config key does not have a user name, that config key will match a URL with any user name (including none), but at a lower precedence than a config key with a user name.</source>
          <target state="translated">用户名（例如， &lt;code&gt;user&lt;/code&gt; 在 &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt; ）。如果config键具有用户名，则它必须与URL中的用户名完全匹配。如果配置密钥没有用户名，则该配置密钥将匹配具有任何用户名（包括无用户名）的URL，但其优先级低于具有用户名的配置密钥。</target>
        </trans-unit>
        <trans-unit id="9eabd3862d3bc88b6d20553afdc4c28a880bd15a" translate="yes" xml:space="preserve">
          <source>User specified as an option to all p4 commands, with &lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4USER&lt;/code&gt; can be used instead.</source>
          <target state="translated">使用 &lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt; 将用户指定为所有p4命令的选项。可以改为使用环境变量 &lt;code&gt;P4USER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3129c28f60cb352aa378d9055c2dee4b71cd917d" translate="yes" xml:space="preserve">
          <source>User-specific configuration file. Also called &quot;global&quot; configuration file.</source>
          <target state="translated">用户专用的配置文件,也叫 &quot;全局 &quot;配置文件。也叫 &quot;全局 &quot;配置文件。</target>
        </trans-unit>
        <trans-unit id="53b3f2b51348a1a5a4076e004425d0d150df3f8e" translate="yes" xml:space="preserve">
          <source>User-specific credentials file.</source>
          <target state="translated">用户专用凭证文件。</target>
        </trans-unit>
        <trans-unit id="fbb3c5af6a1b800cb6bfa442ae5c6ae5ee1a4454" translate="yes" xml:space="preserve">
          <source>Username for SMTP-AUTH. Default is the value of &lt;code&gt;sendemail.smtpUser&lt;/code&gt;; if a username is not specified (with &lt;code&gt;--smtp-user&lt;/code&gt; or &lt;code&gt;sendemail.smtpUser&lt;/code&gt;), then authentication is not attempted.</source>
          <target state="translated">SMTP-AUTH的用户名。默认值为 &lt;code&gt;sendemail.smtpUser&lt;/code&gt; 的值；如果未指定用户名（使用 &lt;code&gt;--smtp-user&lt;/code&gt; 或 &lt;code&gt;sendemail.smtpUser&lt;/code&gt; ），则不尝试身份验证。</target>
        </trans-unit>
        <trans-unit id="dd5ba62269befa999225c8d360ebd4fd64f50001" translate="yes" xml:space="preserve">
          <source>Users may select an automated merge strategy from among the following using either -s/--strategy option or configuring notes.mergeStrategy accordingly:</source>
          <target state="translated">用户可以通过使用-s/--strategy选项或相应配置notes.mergeStrategy,从以下几项中选择自动合并策略。</target>
        </trans-unit>
        <trans-unit id="312954bd3f459a8154fbfda7b5edb71c57c929c2" translate="yes" xml:space="preserve">
          <source>Users migrating from CVS may also want to read &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">从CVS迁移的用户可能还想阅读&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bdfc1b01541d0790675419ccbb86b2582c7e882c" translate="yes" xml:space="preserve">
          <source>Users often try to use the assume-unchanged and skip-worktree bits to tell Git to ignore changes to files that are tracked. This does not work as expected, since Git may still check working tree files against the index when performing certain operations. In general, Git does not provide a way to ignore changes to tracked files, so alternate solutions are recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fd200f233551c846ddc52433b7473972ba45cd" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;assume unchanged&amp;rdquo; bit</source>
          <target state="translated">使用&amp;ldquo;假定不变&amp;rdquo;位</target>
        </trans-unit>
        <trans-unit id="db59534f65c86c428a7a540c110ff1130d39acfc" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git add -A&amp;rdquo;</source>
          <target state="translated">使用&amp;ldquo; git add -A&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="3f756864c1cac8254338a14f16b7888b4cd11774" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git commit -a&amp;rdquo;</source>
          <target state="translated">使用&amp;ldquo; git commit -a&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="1ad6e2bdca2ef33d6f60d1165c40af77488df73e" translate="yes" xml:space="preserve">
          <source>Using --cacheinfo or --info-only</source>
          <target state="translated">使用 --cacheinfo 或 --info-only</target>
        </trans-unit>
        <trans-unit id="63a49bc3316ec7fe7ab1c50a106ab3c187422a12" translate="yes" xml:space="preserve">
          <source>Using --index-info</source>
          <target state="translated">使用--index-info</target>
        </trans-unit>
        <trans-unit id="9465002aca9e596e405478c595d6ec82ecf19f4d" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules can only fetch new commits in already checked out submodules right now. When e.g. upstream added a new submodule in the just fetched commits of the superproject the submodule itself cannot be fetched, making it impossible to check out that submodule later without having to do a fetch again. This is expected to be fixed in a future Git version.</source>
          <target state="translated">使用--recurse-submodules只能获取现在已经检查出来的子模块中的新提交。当上游在刚刚取回的超级项目提交中添加了一个新的子模块时,子模块本身就不能被取回,这就使得以后在不重新取回子模块的情况下,无法再检查出该子模块。这个问题预计会在未来的Git版本中得到修复。</target>
        </trans-unit>
        <trans-unit id="9ba2b3bf5dd0ae3395bffc9a6bf30c85dfb19a1b" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules' HEAD to be detached at that commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6c4766d3d128d670a5d5adf42fc526da676a66" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules will update the content of all initialized submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules HEAD to be detached at that commit.</source>
          <target state="translated">使用--recurse-submodules会根据超级项目中记录的提交,通过递归调用read-tree来更新所有初始化的子模块的内容,也会设置子模块HEAD在该提交时被分离。</target>
        </trans-unit>
        <trans-unit id="8315f077dd8f5ad49468aff013d2df68acafcb5e" translate="yes" xml:space="preserve">
          <source>Using --refresh</source>
          <target state="translated">使用--刷新</target>
        </trans-unit>
        <trans-unit id="0565ce691b52b5953c2fb97dfb806a2f764f48e2" translate="yes" xml:space="preserve">
          <source>Using --temp or --stage=all</source>
          <target state="translated">使用--temp或--stage=全部。</target>
        </trans-unit>
        <trans-unit id="509888a40362653e71adbbdc6d4e59bc0d3d4ce4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--index-filter&lt;/code&gt; with &lt;code&gt;git rm&lt;/code&gt; yields a significantly faster version. Like with using &lt;code&gt;rm filename&lt;/code&gt;, &lt;code&gt;git rm --cached filename&lt;/code&gt; will fail if the file is absent from the tree of a commit. If you want to &quot;completely forget&quot; a file, it does not matter when it entered history, so we also add &lt;code&gt;--ignore-unmatch&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;git rm&lt;/code&gt; 上使用 &lt;code&gt;--index-filter&lt;/code&gt; 会产生明显更快的版本。就像使用 &lt;code&gt;rm filename&lt;/code&gt; 一样，如果提交树中没有该文件，则 &lt;code&gt;git rm --cached filename&lt;/code&gt; 将失败。如果您想&amp;ldquo;完全忘记&amp;rdquo;文件，则在输入历史记录时不要紧，因此我们还要添加 &lt;code&gt;--ignore-unmatch&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="802dbfe4495f98c59f087035f936edebe365e8d7" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all active submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless &lt;code&gt;-f&lt;/code&gt; is used. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, submodules working trees will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf5da0d2a32c5b7048069200ef431cff7653b1d4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all active submodules according to the commit recorded in the superproject. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, submodules working trees will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e7ecf39552b28db7a0c771cb5239db7d4a81af" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless &lt;code&gt;-f&lt;/code&gt; is used. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="translated">使用 &lt;code&gt;--recurse-submodules&lt;/code&gt; 将根据超级项目中记录的提交更新所有初始化子模块的内容。如果子模块中的本地修改将被覆盖，则除非使用 &lt;code&gt;-f&lt;/code&gt; ,否则检出将失败。如果不使用任何内容（或 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ），则不会更新子模块的工作树。就像&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]一样&lt;/a&gt;，这将分离子模块的 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87e05fa35b92ebd2beac592a4000f99e52c8fa99" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodules.</source>
          <target state="translated">使用 &lt;code&gt;--recurse-submodules&lt;/code&gt; 将根据超级项目中记录的提交更新所有初始化子模块的内容。如果不使用任何内容（或 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ），则不会更新子模块的工作树。就像&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]一样&lt;/a&gt;，这将分离子模块的 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="131907fc18369579f75831dbffd3a45262caaa68" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-a&lt;/code&gt; would conflate &amp;lt;remote&amp;gt; with any local branches you happen to have been prefixed with the same &amp;lt;remote&amp;gt; pattern.</source>
          <target state="translated">使用 &lt;code&gt;-a&lt;/code&gt; 会将&amp;lt;remote&amp;gt;与您恰好以相同的&amp;lt;remote&amp;gt;模式作为前缀的任何本地分支合并。</target>
        </trans-unit>
        <trans-unit id="bc196497d8f80228e3ec0969c92ba077224b9158" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;git checkout-index&lt;/em&gt; to &quot;export an entire tree&quot;</source>
          <target state="translated">使用&lt;em&gt;git checkout-index&lt;/em&gt;来&amp;ldquo;导出整个树&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="bb5a1594f36aa9f526f3a0391e9aecb18bcb1ed6" translate="yes" xml:space="preserve">
          <source>Using Gmail&amp;rsquo;s IMAP interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f145740948f023493614f8cb28fc352a33b08d80" translate="yes" xml:space="preserve">
          <source>Using a limit</source>
          <target state="translated">使用极限</target>
        </trans-unit>
        <trans-unit id="0d18e7415acaf5bf1693b96116e4340271619597" translate="yes" xml:space="preserve">
          <source>Using another project while maintaining independent history. Submodules allow you to contain the working tree of another project within your own working tree while keeping the history of both projects separate. Also, since submodules are fixed to an arbitrary version, the other project can be independently developed without affecting the superproject, allowing the superproject project to fix itself to new versions only when desired.</source>
          <target state="translated">使用另一个项目,同时保持独立的历史。子模块允许你在自己的工作树中包含另一个项目的工作树,同时保持两个项目的历史独立。另外,由于子模块固定为任意版本,所以另一个项目可以在不影响超级项目的情况下独立开发,允许超级项目项目只在需要的时候将自己固定为新版本。</target>
        </trans-unit>
        <trans-unit id="03266ad998c58f3651e774794904a59499884e04" translate="yes" xml:space="preserve">
          <source>Using complex scripts</source>
          <target state="translated">使用复杂的脚本</target>
        </trans-unit>
        <trans-unit id="9a4e17fa716627d801ba04248e7c13675c63f6bf" translate="yes" xml:space="preserve">
          <source>Using direct mode with SSL:</source>
          <target state="translated">使用直接模式与SSL。</target>
        </trans-unit>
        <trans-unit id="80be60b71aa62e009a5472e7b71ecca69fb605f2" translate="yes" xml:space="preserve">
          <source>Using direct mode:</source>
          <target state="translated">使用直接模式。</target>
        </trans-unit>
        <trans-unit id="1c1bc19943239ea53498134ee5024657c6f7482f" translate="yes" xml:space="preserve">
          <source>Using git for collaboration</source>
          <target state="translated">使用git进行协作</target>
        </trans-unit>
        <trans-unit id="e742dd237e897f0c09d1168ed38eeca1316d409b" translate="yes" xml:space="preserve">
          <source>Using interactive rebases</source>
          <target state="translated">使用互动式资料库</target>
        </trans-unit>
        <trans-unit id="16c9cb76d4ea0981714eee54828fc3305174e2d5" translate="yes" xml:space="preserve">
          <source>Using macro attributes</source>
          <target state="translated">使用宏属性</target>
        </trans-unit>
        <trans-unit id="0bcad514939a1a512d30defc1dd83a6988408bd1" translate="yes" xml:space="preserve">
          <source>Using more options generally further limits the output (e.g. &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; limits to commits newer than &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt;, and using it with &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; further limits to commits whose log message has a line that matches &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;), unless otherwise noted.</source>
          <target state="translated">使用更多选项通常会进一步限制输出（例如，-- &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; 限制用于提交比 &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt; 更新的提交，并将其与 &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; 一起使用进一步限制用于提交其日志消息具有与 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; ），除非另有说明。</target>
        </trans-unit>
        <trans-unit id="aab9e25047cbd960c71a3d6743c695a0fbcee99d" translate="yes" xml:space="preserve">
          <source>Using refspecs explicitly:</source>
          <target state="translated">明确使用refspecs。</target>
        </trans-unit>
        <trans-unit id="e240eb205361a2a50754a2cbbad5230917e3c8f6" translate="yes" xml:space="preserve">
          <source>Using test suites and git bisect together</source>
          <target state="translated">使用测试套件和git bisect一起使用。</target>
        </trans-unit>
        <trans-unit id="8fdfb0e1e33426ffa586ab6e967bc34118a45d25" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;--submodule=log&lt;/code&gt; option with &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; will provide that information too.</source>
          <target state="translated">在&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]中&lt;/a&gt;使用 &lt;code&gt;--submodule=log&lt;/code&gt; 选项也将提供该信息。</target>
        </trans-unit>
        <trans-unit id="d42f8d8f39d5c1ce54e65e242137998175012054" translate="yes" xml:space="preserve">
          <source>Using these options, &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; will act similar to the more specialized family of commit log tools: &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;</source>
          <target state="translated">使用这些选项，&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]的&lt;/a&gt;作用类似于更专业的提交日志工具系列：&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;，&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;和&lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a34d360db274a11502bc402ef7758f2bc5adf11b" translate="yes" xml:space="preserve">
          <source>Using this helper will store your passwords unencrypted on disk, protected only by filesystem permissions. If this is not an acceptable security tradeoff, try &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache[1]&lt;/a&gt;, or find a helper that integrates with secure storage provided by your operating system.</source>
          <target state="translated">使用此帮助程序会将密码未加密地存储在磁盘上，仅受文件系统权限保护。如果这不是可接受的安全性折衷方案，请尝试使用&lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache [1]&lt;/a&gt;或查找与操作系统提供的安全存储集成在一起的帮助程序。</target>
        </trans-unit>
        <trans-unit id="86d0ca06bdb5a3aacec696a9b10115a302a90ea4" translate="yes" xml:space="preserve">
          <source>Using this hook, it is easy to generate mails describing the updates to the repository. This example script sends one mail message per ref listing the commits pushed to the repository, and logs the push certificates of signed pushes with good signatures to a logger service:</source>
          <target state="translated">使用这个钩子,可以很容易地生成描述版本库更新的邮件。这个示例脚本为每个 ref 发送一封邮件,列出推送到版本库的提交信息,并将签名良好的推送证书记录到记录器服务。</target>
        </trans-unit>
        <trans-unit id="7ae98ad0643543d139a0ccded2d96be6c57e816c" translate="yes" xml:space="preserve">
          <source>Using this option for any other purpose (don&amp;rsquo;t ask) is very strongly discouraged.</source>
          <target state="translated">强烈建议不要将此选项用于其他目的（不要问）。</target>
        </trans-unit>
        <trans-unit id="ebe89d9e15d8a582f6b4a48c6c03d60cf9c673f1" translate="yes" xml:space="preserve">
          <source>Using tunnel mode:</source>
          <target state="translated">使用隧道模式。</target>
        </trans-unit>
        <trans-unit id="f17a1449e9ed80dcff59f550977b6693d42b10bf" translate="yes" xml:space="preserve">
          <source>Usual 3-way file level merge for text files. Conflicted regions are marked with conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. The version from your branch appears before the &lt;code&gt;=======&lt;/code&gt; marker, and the version from the merged branch appears after the &lt;code&gt;=======&lt;/code&gt; marker.</source>
          <target state="translated">文本文件的常规3向文件级合并。冲突区域用冲突标记 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;=======&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 标记。来自分支的版本显示在 &lt;code&gt;=======&lt;/code&gt; 标记之前，而来自合并分支的版本显示在 &lt;code&gt;=======&lt;/code&gt; 标记之后。</target>
        </trans-unit>
        <trans-unit id="6cb51fab051882aaba81e0715d7acfa80e2ce09c" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;git gc&lt;/code&gt; runs very quickly while providing good disk space utilization and performance. This option will cause &lt;code&gt;git gc&lt;/code&gt; to more aggressively optimize the repository at the expense of taking much more time. The effects of this optimization are mostly persistent. See the &quot;AGGRESSIVE&quot; section below for details.</source>
          <target state="translated">通常 &lt;code&gt;git gc&lt;/code&gt; 可以非常快速地运行，同时提供良好的磁盘空间利用率和性能。这个选项将使 &lt;code&gt;git gc&lt;/code&gt; 更加积极地优化存储库，但要花费更多时间。这种优化的效果大部分是持久的。有关详细信息，请参见下面的&amp;ldquo; AGGRESSIVE&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="da9e2cbf852524ee1edb371514af799c05f82c93" translate="yes" xml:space="preserve">
          <source>Usually a merge requires the index file as well as the files in the working tree to be up to date with the current head commit, in order not to lose local changes. This flag disables the check with the working tree and is meant to be used when creating a merge of trees that are not directly related to the current working tree status into a temporary index file.</source>
          <target state="translated">通常情况下,合并要求索引文件和工作树中的文件与当前的头提交保持一致,以避免丢失本地的变化。这个标志会禁用工作树的检查,用于将与当前工作树状态没有直接关系的树合并到临时索引文件中。</target>
        </trans-unit>
        <trans-unit id="27214bb5573e76f1f8a1f21396536681c10927d6" translate="yes" xml:space="preserve">
          <source>Usually a three-way merge by &lt;code&gt;git read-tree&lt;/code&gt; resolves the merge for really trivial cases and leaves other cases unresolved in the index, so that porcelains can implement different merge policies. This flag makes the command resolve a few more cases internally:</source>
          <target state="translated">通常，由 &lt;code&gt;git read-tree&lt;/code&gt; 进行的三路合并可解决真正琐碎的情况下的合并，而索引中未解决其他情况，以便瓷器可以实施不同的合并策略。此标志使命令可以在内部解决更多情况：</target>
        </trans-unit>
        <trans-unit id="1a018c180f83561166ef04fc1c1b049dd7bef5e3" translate="yes" xml:space="preserve">
          <source>Usually given &quot;&amp;lt;feature&amp;gt;&quot; is configurable via the &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; config variable in the per-repository Git configuration file.</source>
          <target state="translated">通常可以通过每个存储库Git配置文件中的 &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; config变量配置给定的&amp;ldquo; &amp;lt;feature&amp;gt;&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="06bd62b74600c2b58fc5390378d7102461c2b477" translate="yes" xml:space="preserve">
          <source>Usually it is easier to configure any desired options through your personal &lt;code&gt;.ssh/config&lt;/code&gt; file. Please consult your ssh documentation for further details.</source>
          <target state="translated">通常，通过您的个人 &lt;code&gt;.ssh/config&lt;/code&gt; 文件配置任何所需的选项会更容易。请查阅ssh文档以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="e92c22e35ceb9b2c8da5295a992718e30d5c9f60" translate="yes" xml:space="preserve">
          <source>Usually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command prevents you from making such a commit. This option bypasses the safety, and is primarily for use by foreign SCM interface scripts.</source>
          <target state="translated">通常记录一个与唯一父提交树完全相同的提交是一个错误,该命令可以防止你进行这样的提交。这个选项绕过了安全问题,主要用于国外SCM接口脚本。</target>
        </trans-unit>
        <trans-unit id="8ce3f0d516dc2a9d67b8e4ba143055eaf7bab452" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates a sequence of commits. This flag applies the changes necessary to cherry-pick each named commit to your working tree and the index, without making any commit. In addition, when this option is used, your index does not have to match the HEAD commit. The cherry-pick is done against the beginning state of your index.</source>
          <target state="translated">通常情况下,该命令会自动创建一个提交序列。这个标志将对工作树和索引进行必要的修改,以挑出每个命名的提交,而不进行任何提交。此外,当使用这个选项时,你的索引不必与 HEAD 提交匹配。挑拣是根据索引的起始状态进行的。</target>
        </trans-unit>
        <trans-unit id="55875ee1e78ad1cfc5a25d1e098bc17781327203" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates some commits with commit log messages stating which commits were reverted. This flag applies the changes necessary to revert the named commits to your working tree and the index, but does not make the commits. In addition, when this option is used, your index does not have to match the HEAD commit. The revert is done against the beginning state of your index.</source>
          <target state="translated">通常情况下,命令会自动创建一些提交,并在提交日志中说明哪些提交被还原。这个选项将对工作树和索引进行必要的修改,但不进行提交。此外,当使用这个选项时,您的索引不必与 HEAD 提交匹配。还原是根据索引的起始状态进行的。</target>
        </trans-unit>
        <trans-unit id="51d5f6e8faedb5ef4d1204f14e2f7ab2d7b77eaf" translate="yes" xml:space="preserve">
          <source>Usually the command stops output upon showing the commit that is the common ancestor of all the branches. This flag tells the command to go &amp;lt;n&amp;gt; more common commits beyond that. When &amp;lt;n&amp;gt; is negative, display only the &amp;lt;reference&amp;gt;s given, without showing the commit ancestry tree.</source>
          <target state="translated">通常，该命令会在显示所有分支的共同祖先的提交后停止输出。该标志告诉命令执行&amp;lt;n&amp;gt;个更常见的提交。当&amp;lt;n&amp;gt;为负数时，仅显示给定的&amp;lt;reference&amp;gt;，而不显示提交祖先树。</target>
        </trans-unit>
        <trans-unit id="29097abe7ecd686605680556737a55dc5b7468af" translate="yes" xml:space="preserve">
          <source>Usually the object names are output in SHA-1 form (with possible &lt;code&gt;^&lt;/code&gt; prefix); this option makes them output in a form as close to the original input as possible.</source>
          <target state="translated">通常，对象名称以SHA-1格式输出（可能带有 &lt;code&gt;^&lt;/code&gt; 前缀）；此选项使它们以尽可能接近原始输入的形式输出。</target>
        </trans-unit>
        <trans-unit id="576f849692364345fa924f476c3413707294c315" translate="yes" xml:space="preserve">
          <source>Usually the output is made one line per flag and parameter. This option makes output a single line, properly quoted for consumption by shell. Useful when you expect your parameter to contain whitespaces and newlines (e.g. when using pickaxe &lt;code&gt;-S&lt;/code&gt; with &lt;code&gt;git diff-*&lt;/code&gt;). In contrast to the &lt;code&gt;--sq-quote&lt;/code&gt; option, the command input is still interpreted as usual.</source>
          <target state="translated">通常，每个标志和参数的输出为一行。此选项使输出单行，正确引用以供shell使用。当您希望参数包含空格和换行符时 &lt;code&gt;git diff-*&lt;/code&gt; 用（例如，当将pickaxe &lt;code&gt;-S&lt;/code&gt; 与git diff- *一起使用时）。与 &lt;code&gt;--sq-quote&lt;/code&gt; 选项相比，该命令输入仍然像往常一样被解释。</target>
        </trans-unit>
        <trans-unit id="52303fe63fddea8a07d49fe1df917ff950ba6541" translate="yes" xml:space="preserve">
          <source>Usually the program removes email cruft from the Subject: header line to extract the title line for the commit log message. This option prevents this munging, and is most useful when used to read back &lt;code&gt;git format-patch -k&lt;/code&gt; output.</source>
          <target state="translated">通常，程序从Subject：标题行中删除电子邮件碎片，以提取提交日志消息的标题行。这个选项防止这种麻烦，并且在用于回读 &lt;code&gt;git format-patch -k&lt;/code&gt; 输出时最有用。</target>
        </trans-unit>
        <trans-unit id="12904fba6e8c31d350b5463557502fba670802b3" translate="yes" xml:space="preserve">
          <source>Usually you cannot cherry-pick a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows cherry-pick to replay the change relative to the specified parent.</source>
          <target state="translated">通常情况下,你不能挑拣一个合并,因为你不知道合并的哪一边应该被视为主线。这个选项指定了主线的父号(从1开始),允许cherry-pick重放相对于指定父号的变化。</target>
        </trans-unit>
        <trans-unit id="8ec09d5ac366ce3cd2a5e3c6c67d0b4fe311e4bf" translate="yes" xml:space="preserve">
          <source>Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.</source>
          <target state="translated">通常情况下,你不能恢复合并,因为你不知道合并的哪一边应该被视为主线。这个选项指定了主线的父号(从1开始),并允许还原相对于指定父号的变化。</target>
        </trans-unit>
        <trans-unit id="6969d1a350dfc3fafb277e2e6995e5ac7a289ac5" translate="yes" xml:space="preserve">
          <source>Usually you should not need to change (adjust) any of configuration variables described below; they should be automatically set by gitweb to correct value.</source>
          <target state="translated">通常情况下,你不需要改变(调整)下面描述的任何配置变量,它们应该由gitweb自动设置为正确的值。</target>
        </trans-unit>
        <trans-unit id="b172c85defacdb686b541793ef9e8aeee0cdf60e" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git fetch&lt;/code&gt;, which is a higher level wrapper of this command, instead.</source>
          <target state="translated">通常，您会想使用 &lt;code&gt;git fetch&lt;/code&gt; ，它是此命令的高级包装。</target>
        </trans-unit>
        <trans-unit id="bec645de31c299cb10f93b6253e1e1669a5f0a31" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git push&lt;/code&gt;, which is a higher-level wrapper of this command, instead. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">通常，您会想使用 &lt;code&gt;git push&lt;/code&gt; ，它是此命令的高级包装。参见&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5982263578e4f00875c00a40da810fe92911cebc" translate="yes" xml:space="preserve">
          <source>Usually, &quot;git push&quot; refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it.</source>
          <target state="translated">通常,&quot;git push &quot;会拒绝更新不是本地 ref 祖先的远程 ref。</target>
        </trans-unit>
        <trans-unit id="f8497b6ab754b20f8d36f9efb8dfea581706bc5d" translate="yes" xml:space="preserve">
          <source>Usually, dangling blobs and trees aren&amp;rsquo;t very interesting. They&amp;rsquo;re almost always the result of either being a half-way mergebase (the blob will often even have the conflict markers from a merge in it, if you have had conflicting merges that you fixed up by hand), or simply because you interrupted a &lt;code&gt;git fetch&lt;/code&gt; with ^C or something like that, leaving &lt;code&gt;some&lt;/code&gt; of the new objects in the object database, but just dangling and useless.</source>
          <target state="translated">通常，悬挂的斑点和树木不是很有趣。它们几乎总是由于成为中途合并基础而产生的（如果您手动修复了冲突的合并，则blob甚至经常会在其中包含来自合并的冲突标记），或者仅仅是因为您打断了一个 &lt;code&gt;git fetch&lt;/code&gt; 与^ C或类似的东西，留下 &lt;code&gt;some&lt;/code&gt; 新对象的对象数据库中，但只是晃来晃去的和无用的。</target>
        </trans-unit>
        <trans-unit id="ebecb811fcb50ea2c9e80ad196b73df5b02ee5fc" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when &lt;code&gt;--force-with-lease&lt;/code&gt; option is used, the command refuses to update a remote ref whose current value does not match what is expected.</source>
          <target state="translated">通常，该命令拒绝更新不是用于覆盖它的本地引用的祖先的远程引用。另外，当使用 &lt;code&gt;--force-with-lease&lt;/code&gt; 选项时，该命令将拒绝更新其当前值与预期值不匹配的远程引用。</target>
        </trans-unit>
        <trans-unit id="1039e5d0aca0474d85bb0cc56a14c21769cd56ed" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the check. What this means is that the remote repository can lose commits; use it with care.</source>
          <target state="translated">通常情况下,命令会拒绝更新一个不是用来覆盖它的本地 ref 的祖先的远程 ref。这个标志可以禁用检查。这意味着远程仓库可能会丢失提交,请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="b573cab97a4c7ff4e65c78f089627a289eeb14b6" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;'s include:</source>
          <target state="translated">有效的 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 包括：</target>
        </trans-unit>
        <trans-unit id="2f441e23dc9e42a84676feea9743dbd62f2c9b12" translate="yes" xml:space="preserve">
          <source>Valid object types are:</source>
          <target state="translated">有效的对象类型是:</target>
        </trans-unit>
        <trans-unit id="9b5bd1c32c0119d43f13ecb3f634510bb032afd7" translate="yes" xml:space="preserve">
          <source>Validate packed Git archive files</source>
          <target state="translated">验证打包的Git存档文件</target>
        </trans-unit>
        <trans-unit id="c95efe4a20b3c90ba09bca423cb347dacda4f997" translate="yes" xml:space="preserve">
          <source>Validates the GPG signature created by &lt;code&gt;git commit -S&lt;/code&gt;.</source>
          <target state="translated">验证 &lt;code&gt;git commit -S&lt;/code&gt; 创建的GPG签名。</target>
        </trans-unit>
        <trans-unit id="ee833db09826b15f6656c228fc09101a4d262c96" translate="yes" xml:space="preserve">
          <source>Validates the gpg signature created by &lt;code&gt;git tag&lt;/code&gt;.</source>
          <target state="translated">验证 &lt;code&gt;git tag&lt;/code&gt; 创建的gpg签名。</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="38ecbfb58a1b4075db82e349628396bb680485d8" translate="yes" xml:space="preserve">
          <source>Values for other tools can be used if there is a corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration entry (see below).</source>
          <target state="translated">如果有相应的 &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 配置条目（请参见下文），则可以使用其他工具的值。</target>
        </trans-unit>
        <trans-unit id="4590af9796b7774b94529a47844bbbd8cd70381f" translate="yes" xml:space="preserve">
          <source>Values obtained in later configuration files override values obtained earlier in the above sequence.</source>
          <target state="translated">在后来的配置文件中获得的值覆盖了上述序列中早期获得的值。</target>
        </trans-unit>
        <trans-unit id="42a2c91c112ab20fb86d229e79049c16aac8f47b" translate="yes" xml:space="preserve">
          <source>Values of many variables are treated as a simple string, but there are variables that take values of specific types and there are rules as to how to spell them.</source>
          <target state="translated">很多变量的值都是作为一个简单的字符串来处理的,但是有的变量取的是特定类型的值,如何拼写是有规则的。</target>
        </trans-unit>
        <trans-unit id="af6a117cf9cae5d8127a5c83e908e26e4094605c" translate="yes" xml:space="preserve">
          <source>Variable substitution</source>
          <target state="translated">可变式替代</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="36ae09eeb0daa8ef3fa73e86b507f064c6f1150e" translate="yes" xml:space="preserve">
          <source>Various Git commands use the following environment variables:</source>
          <target state="translated">各种Git命令都会使用以下环境变量。</target>
        </trans-unit>
        <trans-unit id="c808db304a88e67e4d99602bde96a3fd73a86c36" translate="yes" xml:space="preserve">
          <source>Various aspects of gitweb&amp;rsquo;s behavior can be controlled through the configuration file &lt;code&gt;gitweb_config.perl&lt;/code&gt; or &lt;code&gt;/etc/gitweb.conf&lt;/code&gt;. See the &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; for details.</source>
          <target state="translated">可以通过配置文件 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 或 &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; 来控制gitweb行为的各个方面。有关详细信息，请参见&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="514c3adc237433a43f04caf698ef6f51638f8f03" translate="yes" xml:space="preserve">
          <source>Various commands read from the configuration file and adjust their operation accordingly. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a list and more details about the configuration mechanism.</source>
          <target state="translated">从配置文件中读取各种命令，并相应地调整其操作。有关配置机制的列表和更多详细信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9d741cda072f8e825584f9d44fb913d01a1b3645" translate="yes" xml:space="preserve">
          <source>Various values from structured fields in referenced objects can be used to interpolate into the resulting output, or as sort keys.</source>
          <target state="translated">引用对象中结构化字段的各种值可以用来插值到结果输出中,或者作为排序键。</target>
        </trans-unit>
        <trans-unit id="0e52597805b02b27bbf6fa8afb053d38cd1cf9a2" translate="yes" xml:space="preserve">
          <source>Various ways to check your working tree</source>
          <target state="translated">检查工作树的各种方法</target>
        </trans-unit>
        <trans-unit id="8a8830ff167eaa3505bc00fdd4111ea514743436" translate="yes" xml:space="preserve">
          <source>Verbose output.</source>
          <target state="translated">啰嗦的输出。</target>
        </trans-unit>
        <trans-unit id="5e80e8afa8277ee05efe0825f2f72b290ab38b7f" translate="yes" xml:space="preserve">
          <source>Verbose.</source>
          <target state="translated">Verbose.</target>
        </trans-unit>
        <trans-unit id="1eee329978eae57e0140879a7cb5a19a8e448f4c" translate="yes" xml:space="preserve">
          <source>Verbosely display information about the searching strategy being employed to standard error. The tag name will still be printed to standard out.</source>
          <target state="translated">以标准误差口头显示有关正在使用的搜索策略的信息。标签名称仍会被打印出来,达到标准误差。</target>
        </trans-unit>
        <trans-unit id="17eca013b0d71c76732d4067f559197bffc5dc5a" translate="yes" xml:space="preserve">
          <source>Verbosity: let &lt;code&gt;cvsimport&lt;/code&gt; report what it is doing.</source>
          <target state="translated">&lt;code&gt;cvsimport&lt;/code&gt; 程度：让cvsimport报告它在做什么。</target>
        </trans-unit>
        <trans-unit id="43241483b8c2e2b351480246076bc9d9d3aeeb38" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database</source>
          <target state="translated">验证数据库中对象的连接性和有效性。</target>
        </trans-unit>
        <trans-unit id="083f6e6fa7581860cb22a12637eec790f2c234d9" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database.</source>
          <target state="translated">验证数据库中对象的连接性和有效性。</target>
        </trans-unit>
        <trans-unit id="6f20b572e11a287b2200fc3c18b3124b41ee5e40" translate="yes" xml:space="preserve">
          <source>Verify &amp;lt;ref&amp;gt; against &amp;lt;oldvalue&amp;gt; but do not change it. If &amp;lt;oldvalue&amp;gt; is zero or missing, the ref must not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121ce6e2fb35359b4c456b6cab91a3389a1154d2" translate="yes" xml:space="preserve">
          <source>Verify &amp;lt;ref&amp;gt; against &amp;lt;oldvalue&amp;gt; but do not change it. If &amp;lt;oldvalue&amp;gt; zero or missing, the ref must not exist.</source>
          <target state="translated">针对&amp;lt;oldvalue&amp;gt;验证&amp;lt;ref&amp;gt;，但不要更改它。如果&amp;lt;oldvalue&amp;gt;为零或丢失，则引用必须不存在。</target>
        </trans-unit>
        <trans-unit id="f2a6ea4dcf4e13700439c2c62eb9c887c3645654" translate="yes" xml:space="preserve">
          <source>Verify that everything reachable from target is fetched. Used after an earlier fetch is interrupted.</source>
          <target state="translated">确认所有从target可以到达的东西都被取走了。在早先的获取被中断后使用。</target>
        </trans-unit>
        <trans-unit id="dc19dfe6277cd8889c0ce32fc30714a767c456fd" translate="yes" xml:space="preserve">
          <source>Verify that exactly one parameter is provided, and that it can be turned into a raw 20-byte SHA-1 that can be used to access the object database. If so, emit it to the standard output; otherwise, error out.</source>
          <target state="translated">验证是否正好提供了一个参数,并且它可以变成一个20字节的原始SHA-1,可以用来访问对象数据库。如果可以,则将其输出到标准输出;否则,出错。</target>
        </trans-unit>
        <trans-unit id="e921c65f691e2b371e3e29dc398bb292612d2860" translate="yes" xml:space="preserve">
          <source>Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key. If the tip commit of the side branch is not signed with a valid key, the merge is aborted.</source>
          <target state="translated">验证被合并的侧分支的提示提交是否用有效的密钥签署,即具有有效uid的密钥:在默认的信任模型中,这意味着签署密钥已经由受信任的密钥签署。如果侧分支的提示提交不是用有效的密钥签署的,合并就会中止。</target>
        </trans-unit>
        <trans-unit id="baf3600caf9cbc675ef33fe6c51f69bd006b47ea" translate="yes" xml:space="preserve">
          <source>Verify the GPG signature of the given tag names.</source>
          <target state="translated">验证给定标签名的 GPG 签名。</target>
        </trans-unit>
        <trans-unit id="2977304de3538ddff5d274481548280fa86926b6" translate="yes" xml:space="preserve">
          <source>Verify the MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">验证当前.git文件夹中packfiles的MIDX文件。</target>
        </trans-unit>
        <trans-unit id="593811a1bcc6cbc445bcfa7fdf52e4a760c41784" translate="yes" xml:space="preserve">
          <source>Verify the contents of the MIDX file.</source>
          <target state="translated">验证MIDX文件的内容。</target>
        </trans-unit>
        <trans-unit id="63de76d12bfde7fe2c14402fe2f03160cc3a7318" translate="yes" xml:space="preserve">
          <source>Version 1 porcelain format is similar to the short format, but is guaranteed not to change in a backwards-incompatible way between Git versions or based on user configuration. This makes it ideal for parsing by scripts. The description of the short format above also describes the porcelain format, with a few exceptions:</source>
          <target state="translated">第1版瓷器格式与短格式类似,但保证不会在Git版本之间或根据用户配置进行向后不兼容的改变。这使得它非常适合脚本的解析。上面对短格式的描述也是对瓷器格式的描述,但有一些例外。</target>
        </trans-unit>
        <trans-unit id="1bb30898712789d3819631e4bb7ad8cf32d20671" translate="yes" xml:space="preserve">
          <source>Version 1 takes two arguments, a version (1) and the time in elapsed nanoseconds since midnight, January 1, 1970.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e409adcd5a97d5085c0477fcb4b42dc9a034a9" translate="yes" xml:space="preserve">
          <source>Version 2 format adds more detailed information about the state of the worktree and changed items. Version 2 also defines an extensible set of easy to parse optional headers.</source>
          <target state="translated">第2版格式增加了更多关于工作树状态和变更项的详细信息。第2版还定义了一套可扩展的、易于解析的可选头文件。</target>
        </trans-unit>
        <trans-unit id="2b8063c91f48f5daba279d42a4965f292b8198dd" translate="yes" xml:space="preserve">
          <source>Version 2 pack-*.idx files support packs larger than 4 gib, and</source>
          <target state="translated">第2版pack-*.idx文件支持大于4个gib的包,以及</target>
        </trans-unit>
        <trans-unit id="76b6cb1496a78fff149bd68b719a91ca0d69c9df" translate="yes" xml:space="preserve">
          <source>Version 2 takes two arguments, a version (2) and a token that is used for identifying changes since the token. For watchman this would be a clock id. This version must output to stdout the new token followed by a NUL before the list of files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a28a75eceea6b3fb1730e69daff64901cead811" translate="yes" xml:space="preserve">
          <source>Version 4 performs a simple pathname compression that reduces index size by 30%-50% on large repositories, which results in faster load time. Version 4 is relatively young (first released in 1.8.0 in October 2012). Other Git implementations such as JGit and libgit2 may not support it yet.</source>
          <target state="translated">第4版执行简单的路径名压缩,在大型资源库上减少30%-50%的索引大小,从而加快加载时间。第4版还比较年轻(2012年10月首次发布的1.8.0版本),其他Git实现如JGit和libgit2可能还不支持。其他Git实现,如JGit和libgit2可能还不支持。</target>
        </trans-unit>
        <trans-unit id="5b61ffa7c699cf77c98fcf76236048d42ca5d233" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">版本 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fc1164df4f366b4e06ce848f94e3799671648de" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">版本 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26980b77b1e7ef480646032aebce78732551db11" translate="yes" xml:space="preserve">
          <source>Versions of Git older than 1.7.7 don&amp;rsquo;t know about the &lt;code&gt;tar.gz&lt;/code&gt; format, you&amp;rsquo;ll need to use gzip explicitly:</source>
          <target state="translated">低于1.7.7的Git版本不了解 &lt;code&gt;tar.gz&lt;/code&gt; 格式，您需要明确使用gzip：</target>
        </trans-unit>
        <trans-unit id="48cda44638e8ce2f3c6e764951e4cd137e88bacc" translate="yes" xml:space="preserve">
          <source>Via the alternates mechanism, a &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; can inherit part of its &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; from another object database, which is called an &quot;alternate&quot;.</source>
          <target state="translated">通过备用机制，&lt;a href=&quot;#def_repository&quot;&gt;存储库&lt;/a&gt;可以从另一个对象数据库（称为&amp;ldquo;备用&amp;rdquo;）继承其&lt;a href=&quot;#def_object_database&quot;&gt;对象数据库的&lt;/a&gt;一部分。</target>
        </trans-unit>
        <trans-unit id="d75bfce3768015c62af9c4bd29fd7cad894764e0" translate="yes" xml:space="preserve">
          <source>Viewing everything that was changed in a revision, and step through revisions one at a time, viewing the history of the repository.</source>
          <target state="translated">查看修订中的所有变化,并逐一查看修订,查看版本库的历史。</target>
        </trans-unit>
        <trans-unit id="8e797001d4524362e7db8f18210266901eb28403" translate="yes" xml:space="preserve">
          <source>Viewing files in GUI tools</source>
          <target state="translated">在GUI工具中查看文件</target>
        </trans-unit>
        <trans-unit id="05c33ea7de1cccd62a72042e46bec3b3d340cf9f" translate="yes" xml:space="preserve">
          <source>Viewing multiple Git repositories with common root.</source>
          <target state="translated">用共同的根查看多个Git仓库。</target>
        </trans-unit>
        <trans-unit id="1439a80405107c5dd4ca129513bf97eb92ca8c3f" translate="yes" xml:space="preserve">
          <source>Viewing old file versions</source>
          <target state="translated">查看旧文件版本</target>
        </trans-unit>
        <trans-unit id="cba1ab24737b9af4081eae74baa579853869959f" translate="yes" xml:space="preserve">
          <source>Viewing project history</source>
          <target state="translated">查看项目历史</target>
        </trans-unit>
        <trans-unit id="48e788f7b4905bc5801452134707bb74e1fddd3c" translate="yes" xml:space="preserve">
          <source>Viewing the blame/annotation details of any file (if enabled).</source>
          <target state="translated">查看任何文件的责任/注释详情(如果启用)。</target>
        </trans-unit>
        <trans-unit id="afd57038f9956faea3beadae2f663a8f18e1dd6a" translate="yes" xml:space="preserve">
          <source>Viewing the contents of files in the repository at any revision.</source>
          <target state="translated">查看版本库中任何版本的文件内容。</target>
        </trans-unit>
        <trans-unit id="79e8c237bcc343324671ba4de89f13c4632b7437" translate="yes" xml:space="preserve">
          <source>Viewing the revision log of branches, history of files and directories, see what was changed when, by who.</source>
          <target state="translated">查看分支的修订日志、文件和目录的历史记录,查看什么时候、由谁修改了什么。</target>
        </trans-unit>
        <trans-unit id="5d3b4279714ad2970a30b9dfdfce1d9cde0d271d" translate="yes" xml:space="preserve">
          <source>Voila.</source>
          <target state="translated">Voila.</target>
        </trans-unit>
        <trans-unit id="f7dda342bfe7129409283096bf9eae6889a3617d" translate="yes" xml:space="preserve">
          <source>Waiting $&amp;lt;int&amp;gt; seconds before reconnecting to SMTP server. Used together with --batch-size option. Defaults to the &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; configuration variable.</source>
          <target state="translated">等待$ &amp;lt;int&amp;gt;秒，然后重新连接到SMTP服务器。与--batch-size选项一起使用。默认为 &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; 配置变量。</target>
        </trans-unit>
        <trans-unit id="6abfc589b188840a4520edd8282e2221d54aed84" translate="yes" xml:space="preserve">
          <source>Walk history forward instead of backward. Instead of showing the revision in which a line appeared, this shows the last revision in which a line has existed. This requires a range of revision like START..END where the path to blame exists in START. &lt;code&gt;git blame --reverse START&lt;/code&gt; is taken as &lt;code&gt;git blame
--reverse START..HEAD&lt;/code&gt; for convenience.</source>
          <target state="translated">向前走历史而不是向后走。与其显示行所在的修订，不显示行所在的最新修订。这就需要进行一系列修订，例如START..END，其中的归咎路径在START中。为方便起见，将 &lt;code&gt;git blame --reverse START&lt;/code&gt; 视为 &lt;code&gt;git blame --reverse START..HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="246770a4db6a59723366cd008c0806351012631a" translate="yes" xml:space="preserve">
          <source>Walk through the patches in the series and warn if we cannot find all of the necessary information to commit a patch. At the time of this writing only missing author information is warned about.</source>
          <target state="translated">走过系列的补丁,如果我们无法找到提交补丁的所有必要信息,就会发出警告。在写这篇文章的时候,只对缺少的作者信息进行警告。</target>
        </trans-unit>
        <trans-unit id="8741434725596a0a6dcba1ea6ce0540165fbeb38" translate="yes" xml:space="preserve">
          <source>Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.</source>
          <target state="translated">如果更改引入冲突标记或空白错误，则发出警告。哪些空白错误由 &lt;code&gt;core.whitespace&lt;/code&gt; 配置控制。默认情况下，尾随空格（包括仅由空格组成的行）以及在行的初始缩进内紧随其后是制表符的空格字符都被视为空格错误。如果发现问题，则以非零状态退出。与--exit-code不兼容。</target>
        </trans-unit>
        <trans-unit id="d0219dea42624b30174e17cfd1bb37d7d1a042a1" translate="yes" xml:space="preserve">
          <source>Warn of patches that contain lines longer than 998 characters unless a suitable transfer encoding (&lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, or &lt;code&gt;quoted-printable&lt;/code&gt;) is used; this is due to SMTP limits as described by &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txt&lt;/a&gt;.</source>
          <target state="translated">除非行中使用了适当的传输编码（ &lt;code&gt;auto&lt;/code&gt; ， &lt;code&gt;base64&lt;/code&gt; 或 &lt;code&gt;quoted-printable&lt;/code&gt; ），否则警告包含超过998个字符的行的修补程序；这是由于&lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txt中&lt;/a&gt;所述的SMTP限制所致。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="d9a62a2598117c2be58c53a722de6576cd225a89" translate="yes" xml:space="preserve">
          <source>Warnings are printed on the standard error output for any explicitly unsupported constructs, and any other lines that are not recognized by the parser.</source>
          <target state="translated">对于任何明确不支持的构造,以及任何其他不被解析器识别的行,都会在标准错误输出中打印警告。</target>
        </trans-unit>
        <trans-unit id="54490e8680807566a4db5e14166b54af9ee18d68" translate="yes" xml:space="preserve">
          <source>We already saw in &lt;a href=&quot;#understanding-commits&quot;&gt;Understanding History: Commits&lt;/a&gt; that all commits are stored under a 40-digit &quot;object name&quot;. In fact, all the information needed to represent the history of a project is stored in objects with such names. In each case the name is calculated by taking the SHA-1 hash of the contents of the object. The SHA-1 hash is a cryptographic hash function. What that means to us is that it is impossible to find two different objects with the same name. This has a number of advantages; among others:</source>
          <target state="translated">我们已经在&lt;a href=&quot;#understanding-commits&quot;&gt;了解历史记录：提交中&lt;/a&gt;看到所有提交都存储在40位&amp;ldquo;对象名&amp;rdquo;下。实际上，表示项目历史所需的所有信息都存储在具有此类名称的对象中。在每种情况下，名称都是通过获取对象内容的SHA-1哈希值来计算的。SHA-1哈希是一种加密哈希函数。对我们而言，这意味着不可能找到两个具有相同名称的不同对象。这具有许多优点。其中：</target>
        </trans-unit>
        <trans-unit id="d6fd523936a98d1231393ad2931c9779a4d79b0e" translate="yes" xml:space="preserve">
          <source>We are looking for a &quot;best&quot; explanation of the new series in terms of the old one. We can represent an &quot;explanation&quot; as an edge in the graph:</source>
          <target state="translated">我们正在寻找一个新系列对旧系列的 &quot;最佳 &quot;解释。我们可以用图中的一条边来表示 &quot;解释&quot;。</target>
        </trans-unit>
        <trans-unit id="9b940c15e60e8d5e30f8f0dd6fb317eefa03a3c7" translate="yes" xml:space="preserve">
          <source>We assume that GITWEB_CONFIG has its default Makefile value, namely &lt;code&gt;gitweb_config.perl&lt;/code&gt;. Put the following in &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; file:</source>
          <target state="translated">我们假设GITWEB_CONFIG具有默认的Makefile值，即 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 。将以下内容放入 &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="860f449f084465687d5f3065e9dcdf4471fe0c53" translate="yes" xml:space="preserve">
          <source>We assume the following in /etc/services</source>
          <target state="translated">我们在/etc/services中假设以下内容</target>
        </trans-unit>
        <trans-unit id="e666201c4a3affd420bf339541f1e66f556269f5" translate="yes" xml:space="preserve">
          <source>We assume you have already created a Git repository for your project, possibly created from scratch or from a tarball (see &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt;), or imported from an already existing CVS repository (see the next section).</source>
          <target state="translated">我们假设您已经为您的项目创建了一个Git存储库，可能是从头开始或从tarball创建的（请参阅&lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt;），或者是从已经存在的CVS存储库中导入的（请参阅下一节）。</target>
        </trans-unit>
        <trans-unit id="a35a2d4ac8af99272cba8ca44431c44847ef0735" translate="yes" xml:space="preserve">
          <source>We can also create a tag to refer to a particular commit; after running</source>
          <target state="translated">我们也可以创建一个标签来引用一个特定的提交;在运行了</target>
        </trans-unit>
        <trans-unit id="ec584a188dcd2e25a99263b54f2feb909dc57e99" translate="yes" xml:space="preserve">
          <source>We can ask Git about this particular object with the &lt;code&gt;cat-file&lt;/code&gt; command. Don&amp;rsquo;t copy the 40 hex digits from this example but use those from your own version. Note that you can shorten it to only a few characters to save yourself typing all 40 hex digits:</source>
          <target state="translated">我们可以使用 &lt;code&gt;cat-file&lt;/code&gt; 命令向Git询问有关此特定对象的信息。不要复制此示例中的40个十六进制数字，而应使用您自己的版本中的40个十六进制数字。请注意，您可以将其缩短为仅几个字符，以免自己键入所有40个十六进制数字：</target>
        </trans-unit>
        <trans-unit id="3d0c7ad92eed63e4b86ed7fcdbe0a2af116dc20a" translate="yes" xml:space="preserve">
          <source>We can further investigate the time spent scanning for untracked files.</source>
          <target state="translated">我们可以进一步调查扫描未被跟踪的文件所花费的时间。</target>
        </trans-unit>
        <trans-unit id="14c5f91f2f30d67e424b3d8fa6177783e08a84fd" translate="yes" xml:space="preserve">
          <source>We can get just the branch-head names, and remove &lt;code&gt;master&lt;/code&gt;, with the help of the standard utilities cut and grep:</source>
          <target state="translated">我们可以在标准实用程序cut和grep的帮助下，获取分支头名称，然后删除 &lt;code&gt;master&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a00f6027326a1e03d87c7714c37d6396c5fc0f07" translate="yes" xml:space="preserve">
          <source>We can get this using the following command:</source>
          <target state="translated">我们可以使用下面的命令来获得。</target>
        </trans-unit>
        <trans-unit id="308213d749ac73498be48acb36aa505b62d477c8" translate="yes" xml:space="preserve">
          <source>We can give this name to &lt;code&gt;git show&lt;/code&gt; to see the details about this commit.</source>
          <target state="translated">我们可以将此名称赋予 &lt;code&gt;git show&lt;/code&gt; 以查看有关此提交的详细信息。</target>
        </trans-unit>
        <trans-unit id="164a7b582707458e7c29a45bdd3cb932a29b3ca1" translate="yes" xml:space="preserve">
          <source>We can list all the heads in this repository with &lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref[1]&lt;/a&gt;:</source>
          <target state="translated">我们可以使用&lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref [1]&lt;/a&gt;列出该存储库中的所有头像：</target>
        </trans-unit>
        <trans-unit id="3342879e047ae36a38db13969064b38d54ccc902" translate="yes" xml:space="preserve">
          <source>We divide Git into high level (&quot;porcelain&quot;) commands and low level (&quot;plumbing&quot;) commands.</source>
          <target state="translated">我们将Git分为高层(&quot;瓷器&quot;)命令和低层(&quot;管道&quot;)命令。</target>
        </trans-unit>
        <trans-unit id="011f9d254149abd4e25f111f5f8f2bc847e7e4cc" translate="yes" xml:space="preserve">
          <source>We explain how to do this in the following sections.</source>
          <target state="translated">我们在下面的章节中解释如何做到这一点。</target>
        </trans-unit>
        <trans-unit id="4822ab43c46db1b5802e2f53899245649e4398bd" translate="yes" xml:space="preserve">
          <source>We formulate a set of &lt;code&gt;rules&lt;/code&gt; for quick reference, while the prose tries to motivate each of them. Do not always take them literally; you should value good reasons for your actions higher than manpages such as this one.</source>
          <target state="translated">我们制定了一套 &lt;code&gt;rules&lt;/code&gt; 供快速参考，而散文则试图激发它们中的每一个。不要总是从字面上看待它们。您应该认为自己的行为比此类手册更为重要。</target>
        </trans-unit>
        <trans-unit id="27af85d69b0e1da45afccff7b9c2331995331c55" translate="yes" xml:space="preserve">
          <source>We found that most commits on the graph may give quite a lot of information when they are tested. And the commits that will not on average give a lot of information are the one near the good and bad commits.</source>
          <target state="translated">我们发现,图上的大多数提交在测试时可能会提供相当多的信息。而那些平均不会提供大量信息的提交,则是靠近好的和坏的提交。</target>
        </trans-unit>
        <trans-unit id="319c4fde5f53d3ebfff60d2ca81633ff5c5e7332" translate="yes" xml:space="preserve">
          <source>We have already seen &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;how to keep remote-tracking branches up to date&lt;/a&gt; with &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;, and how to merge two branches. So you can merge in changes from the original repository&amp;rsquo;s master branch with:</source>
          <target state="translated">我们已经看到了&lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;如何&lt;/a&gt;使用&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1] &lt;/a&gt;来使远程跟踪分支保持最新状态，以及如何合并两个分支。因此，您可以将原始存储库的master分支中的更改合并到：</target>
        </trans-unit>
        <trans-unit id="9313b2be3fe8f9ef5431fd57e740ed2c389d7c2c" translate="yes" xml:space="preserve">
          <source>We have already seen how branches work previously, with &quot;fun and work&quot; example using two branches. The idea is the same if there are more than two branches. Let&amp;rsquo;s say you started out from &quot;master&quot; head, and have some new code in the &quot;master&quot; branch, and two independent fixes in the &quot;commit-fix&quot; and &quot;diff-fix&quot; branches:</source>
          <target state="translated">我们已经看到了分支以前是如何工作的，其中使用两个分支的&amp;ldquo;有趣并工作&amp;rdquo;示例。如果有两个以上的分支，则想法是相同的。假设您从&amp;ldquo; master&amp;rdquo;头开始，在&amp;ldquo; master&amp;rdquo;分支中有一些新代码，在&amp;ldquo; commit-fix&amp;rdquo;和&amp;ldquo; diff-fix&amp;rdquo;分支中有两个独立的修复程序：</target>
        </trans-unit>
        <trans-unit id="1170354586d8db2806a89632eb01397ff1d5b39a" translate="yes" xml:space="preserve">
          <source>We have seen several ways of naming commits already:</source>
          <target state="translated">我们已经看到了几种命名提交的方式。</target>
        </trans-unit>
        <trans-unit id="ea2d131015439270646c4d9deb94b3238eec4d65" translate="yes" xml:space="preserve">
          <source>We have seen that regressions are an important problem, and that &quot;git bisect&quot; has nice features that complement very well practices and other tools, especially test suites, that are generally used to fight regressions. But it might be needed to change some work-flows and (bad) habits to get the most out of it.</source>
          <target state="translated">我们已经看到,回归是一个重要的问题,&quot;git bisect &quot;有很好的功能,可以很好地补充实践和其他工具,尤其是测试套件,这些工具通常用于打击回归。但可能需要改变一些工作流程和(坏的)习惯,才能发挥它的最大作用。</target>
        </trans-unit>
        <trans-unit id="58d71328c844eab6bb246a8885f29a926cbaf29b" translate="yes" xml:space="preserve">
          <source>We have seen that test suites and git bisect are very powerful when used together. It can be even more powerful if you can combine them with other systems.</source>
          <target state="translated">我们已经看到,测试套件和git bisect一起使用时非常强大。如果你能把它们和其他系统结合起来,就会更加强大。</target>
        </trans-unit>
        <trans-unit id="0dc1429b571e4014b12f464201faf90142f01343" translate="yes" xml:space="preserve">
          <source>We ignore all SVN properties except svn:executable. Any unhandled properties are logged to $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log</source>
          <target state="translated">我们忽略除svn：executable之外的所有SVN属性。任何未处理的属性都记录到$ GIT_DIR / svn / &amp;lt;refname&amp;gt; /unhandled.log中</target>
        </trans-unit>
        <trans-unit id="5e0e70c2a550cebe0f64341bc25aba4f82846837" translate="yes" xml:space="preserve">
          <source>We said this tutorial shows what plumbing does to help you cope with the porcelain that isn&amp;rsquo;t flushing, but we so far did not talk about how the merge really works. If you are following this tutorial the first time, I&amp;rsquo;d suggest to skip to &quot;Publishing your work&quot; section and come back here later.</source>
          <target state="translated">我们说本教程显示了管道功能可以帮助您应对未冲洗的瓷器，但是到目前为止，我们还没有讨论合并的真正原理。如果您是第一次学习本教程，建议您跳到&amp;ldquo;发布您的作品&amp;rdquo;部分，稍后再回到这里。</target>
        </trans-unit>
        <trans-unit id="038e0426e816e440e5c183b0ccfae9faca0c65b5" translate="yes" xml:space="preserve">
          <source>We saw above that &lt;code&gt;origin&lt;/code&gt; is just a shortcut to refer to the repository that you originally cloned from. This information is stored in Git configuration variables, which you can see using &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">我们在上面看到了 &lt;code&gt;origin&lt;/code&gt; 只是引用您最初从其克隆的存储库的快捷方式。此信息存储在Git配置变量中，您可以使用&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;查看：</target>
        </trans-unit>
        <trans-unit id="789eeb5f51968bf21d9746b92623ca08838d8bcb" translate="yes" xml:space="preserve">
          <source>We saw earlier that &quot;git bisect skip&quot; is now using a PRNG to try to avoid areas in the commit graph where commits are untestable. The problem is that sometimes the first bad commit will be in an untestable area.</source>
          <target state="translated">我们之前看到,&quot;git bisect skip &quot;现在使用 PRNG 来避免提交图中不可测试的提交区域。问题是,有时第一个坏的提交会出现在不可测试的区域。</target>
        </trans-unit>
        <trans-unit id="e6f53989efc34bb4d6e54dcd09f15943b6a8a36c" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#conflict-resolution&quot;&gt;Getting conflict-resolution help during a merge&lt;/a&gt; that during a merge the index can store multiple versions of a single file (called &quot;stages&quot;). The third column in the &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; output above is the stage number, and will take on values other than 0 for files with merge conflicts.</source>
          <target state="translated">我们在&lt;a href=&quot;#conflict-resolution&quot;&gt;合并&lt;/a&gt;过程中获得解决冲突的帮助中看到，在合并过程中，索引可以存储单个文件的多个版本（称为&amp;ldquo;阶段&amp;rdquo;）。上面输出的&lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]中&lt;/a&gt;的第三列是阶段号，对于具有合并冲突的文件，它将采用非0的值。</target>
        </trans-unit>
        <trans-unit id="d5d682276e6a6d081a241de022b4ded4aef9c418" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;Fixing a mistake by rewriting history&lt;/a&gt; that you can replace the most recent commit using</source>
          <target state="translated">我们在&lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;通过改写历史记录&lt;/a&gt;来纠正错误中看到，您可以使用替换最近的提交</target>
        </trans-unit>
        <trans-unit id="aafdc07c8e0d9b297fcdd505608f380ef754ed45" translate="yes" xml:space="preserve">
          <source>We saw in part one of the tutorial that commits have names like this. It turns out that every object in the Git history is stored under a 40-digit hex name. That name is the SHA-1 hash of the object&amp;rsquo;s contents; among other things, this ensures that Git will never store the same data twice (since identical data is given an identical SHA-1 name), and that the contents of a Git object will never change (since that would change the object&amp;rsquo;s name as well). The 7 char hex strings here are simply the abbreviation of such 40 character long strings. Abbreviations can be used everywhere where the 40 character strings can be used, so long as they are unambiguous.</source>
          <target state="translated">我们在本教程的第一部分中看到，提交具有这样的名称。事实证明，Git历史记录中的每个对象都以40位十六进制名称存储。该名称是对象内容的SHA-1哈希值；除其他事项外，这确保Git永远不会将相同的数据存储两次（因为相同的数据被赋予相同的SHA-1名称），并且Git对象的内容将永远不会更改（因为这也会更改对象的名称） ）。这里的7个char十六进制字符串只是这种40个字符长的字符串的缩写。缩写可以在可以使用40个字符串的任何地方使用，只要它们没有歧义即可。</target>
        </trans-unit>
        <trans-unit id="09c046487d09b436218fe11aa8c1087251442281" translate="yes" xml:space="preserve">
          <source>We separate the porcelain commands into the main commands and some ancillary user utilities.</source>
          <target state="translated">我们将瓷器命令分为主命令和一些辅助用户实用程序。</target>
        </trans-unit>
        <trans-unit id="f2e875357a5ce85901234308b841a3138ebd851b" translate="yes" xml:space="preserve">
          <source>We should point out that &quot;habitually&quot; (regularly for no real reason) merging an integration branch into your topics &amp;mdash; and by extension, merging anything upstream into anything downstream on a regular basis &amp;mdash; is frowned upon:</source>
          <target state="translated">我们应该指出，&amp;ldquo;习惯性地&amp;rdquo;（通常没有任何正当理由）将集成分支合并到您的主题中，并且通过扩展，将上游的任何内容定期合并到下游的任何内容中，您不赞成这样做：</target>
        </trans-unit>
        <trans-unit id="3b0c2056ade966758c96efbd333ad03c787ca3ac" translate="yes" xml:space="preserve">
          <source>We start with one specialized tool that is useful for finding the commit that introduced a bug into a project.</source>
          <target state="translated">我们先从一个专门的工具开始,这个工具可以帮助我们找到将错误引入项目的提交。</target>
        </trans-unit>
        <trans-unit id="3bb7fbe62fd9b3fa1a7f67f6a431251fe7b02079" translate="yes" xml:space="preserve">
          <source>We start with the most important, the &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; and the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">我们从最重要的&lt;a href=&quot;#def_object_database&quot;&gt;对象数据库&lt;/a&gt;和&lt;a href=&quot;#def_index&quot;&gt;索引开始&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa1acdd625946113b786a5983b045431892f2e96" translate="yes" xml:space="preserve">
          <source>We supposed in the previous examples that the &quot;good&quot; commits were ancestors of the &quot;bad&quot; commit. But this is not a requirement of &quot;git bisect&quot;.</source>
          <target state="translated">在前面的例子中,我们认为 &quot;好的 &quot;提交是 &quot;坏的 &quot;提交的祖先,但这不是 &quot;git bisect &quot;的要求。但这不是 &quot;git bisect &quot;的要求。</target>
        </trans-unit>
        <trans-unit id="09e675bfb62532c536d372645ebddf19b07c5684" translate="yes" xml:space="preserve">
          <source>We want to make &lt;code&gt;topic&lt;/code&gt; forked from branch &lt;code&gt;master&lt;/code&gt;; for example, because the functionality on which &lt;code&gt;topic&lt;/code&gt; depends was merged into the more stable &lt;code&gt;master&lt;/code&gt; branch. We want our tree to look like this:</source>
          <target state="translated">我们要使分支 &lt;code&gt;master&lt;/code&gt; 分叉的 &lt;code&gt;topic&lt;/code&gt; ; 例如，因为 &lt;code&gt;topic&lt;/code&gt; 依赖的功能已合并到更稳定的 &lt;code&gt;master&lt;/code&gt; 分支中。我们希望我们的树看起来像这样：</target>
        </trans-unit>
        <trans-unit id="0fa006b18282abd83f954d3423dfd83f70f68c0d" translate="yes" xml:space="preserve">
          <source>We will introduce some tools that can help you do this, explain how to use them, and then explain some of the problems that can arise because you are rewriting history.</source>
          <target state="translated">我们将介绍一些可以帮助你做到这一点的工具,解释如何使用它们,然后解释一些因为你正在改写历史而可能出现的问题。</target>
        </trans-unit>
        <trans-unit id="e34d86d215639adac5ecaa74d7f70d803a2ef9de" translate="yes" xml:space="preserve">
          <source>We will sometimes represent Git history using diagrams like the one below. Commits are shown as &quot;o&quot;, and the links between them with lines drawn with - / and \. Time goes left to right:</source>
          <target state="translated">我们有时会用下面这样的图来表示 Git 的历史。承诺用 &quot;o &quot;表示,它们之间的联系用-/和\画出的线表示。时间从左到右。</target>
        </trans-unit>
        <trans-unit id="ab9fd84ced67b4e6059fb12091ba4144199c5397" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll assume that the problem is a single missing or corrupted blob, which is sometimes a solvable problem. (Recovering missing trees and especially commits is &lt;strong&gt;much&lt;/strong&gt; harder).</source>
          <target state="translated">我们假设问题是单个丢失或损坏的斑点，有时这是一个可以解决的问题。（恢复丢失的树，尤其是提交&lt;strong&gt;要&lt;/strong&gt;困难得多）。</target>
        </trans-unit>
        <trans-unit id="2aa7b1ec194976812ce4b6b3f7e0ba34eba549a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll keep this simple and stupid, so we&amp;rsquo;ll start off with populating a few trivial files just to get a feel for it.</source>
          <target state="translated">我们将使这个简单而愚蠢的事情变得如此，因此我们将从填充一些琐碎的文件开始，只是为了对此有所了解。</target>
        </trans-unit>
        <trans-unit id="2d4db37414a68811cd95f44af4830929ada62273" translate="yes" xml:space="preserve">
          <source>Webserver configuration</source>
          <target state="translated">网络服务器配置</target>
        </trans-unit>
        <trans-unit id="c0f36d74c982d11ffbdfaa17b6ab39308ec52a2f" translate="yes" xml:space="preserve">
          <source>Webserver configuration with multiple projects' root</source>
          <target state="translated">用多个项目的根配置Webserver</target>
        </trans-unit>
        <trans-unit id="ef6d4f2b2672206d0b50ce512c5b9cc1369fe95f" translate="yes" xml:space="preserve">
          <source>What an alias file in each format looks like can be found in the documentation of the email program of the same name. The differences and limitations from the standard formats are described below:</source>
          <target state="translated">每种格式的别名文件是什么样的,可以在同名电子邮件程序的文档中找到。与标准格式的区别和限制在下面描述。</target>
        </trans-unit>
        <trans-unit id="fa6325f935566c907b8b84855ddf6b390a1827e3" translate="yes" xml:space="preserve">
          <source>What are the 7 digits of hex that Git responded to the commit with?</source>
          <target state="translated">Git响应提交的7位十六进制数字是什么?</target>
        </trans-unit>
        <trans-unit id="5fb651419665147da76edfca56099f33ccd0e645" translate="yes" xml:space="preserve">
          <source>What does this mean?</source>
          <target state="translated">这意味着什么?</target>
        </trans-unit>
        <trans-unit id="b77fdbd3385bc488b50aa891b5b4c124304a8f69" translate="yes" xml:space="preserve">
          <source>What is interesting too is that end users that are reporting bugs (or QA people that reproduced a bug) have access to the environment where the bug happens. So they can often more easily reproduce a regression. And if they can bisect, then more information will be extracted from the environment where the bug happens, which means that it will be easier to understand and then fix the bug.</source>
          <target state="translated">同样有趣的是,报告bug的最终用户(或重现bug的QA人员)可以访问bug发生的环境。所以他们往往可以更容易地重现一个回归。而如果他们能够一分为二,那么就会从bug发生的环境中提取更多的信息,这意味着会更容易理解然后修复bug。</target>
        </trans-unit>
        <trans-unit id="549056214cd4b23720c4559829b5b36cc5cf6d0c" translate="yes" xml:space="preserve">
          <source>What next?</source>
          <target state="translated">接下来呢?</target>
        </trans-unit>
        <trans-unit id="fe77441e9cc191fb4a5181d6f98e51e7bf6ce4ab" translate="yes" xml:space="preserve">
          <source>What people don&amp;rsquo;t get is that this is a situation where the &quot;end node principle&quot; applies. When you have limited resources (here: developers) you don&amp;rsquo;t push the bulk of the burden upon them. Instead you push things out to the resource you have a lot of, the end nodes (here: users), so that the situation actually scales.</source>
          <target state="translated">人们不明白的是，这种情况适用了&amp;ldquo;端节点原理&amp;rdquo;。当您的资源有限时（此处为开发人员），您不会将大量的负担加在他们身上。取而代之的是将内容推送到您拥有很多资源的终端节点（此处为用户），以便实际扩展情况。</target>
        </trans-unit>
        <trans-unit id="e4950cd435094a3f200db11a5c1b540d80d04769" translate="yes" xml:space="preserve">
          <source>What should you do when you tag a wrong commit and you would want to re-tag?</source>
          <target state="translated">当你标记了一个错误的提交,而你又想重新标记时,你应该怎么做?</target>
        </trans-unit>
        <trans-unit id="049920ec0574fb80b08ccee259e5814b007cd44c" translate="yes" xml:space="preserve">
          <source>What the -p option produces is slightly different from the traditional diff format:</source>
          <target state="translated">-p选项产生的东西与传统的diff格式略有不同。</target>
        </trans-unit>
        <trans-unit id="e27b60d4391d6c41de480e30a2d0df50a6723ae8" translate="yes" xml:space="preserve">
          <source>What to do when a push fails</source>
          <target state="translated">推送失败怎么办</target>
        </trans-unit>
        <trans-unit id="42a1dbf4390cedcf2f183fba444335bae8d5ae11" translate="yes" xml:space="preserve">
          <source>What you chose are then highlighted with &lt;code&gt;*&lt;/code&gt;, like this:</source>
          <target state="translated">然后，您选择的内容将以 &lt;code&gt;*&lt;/code&gt; 突出显示，如下所示：</target>
        </trans-unit>
        <trans-unit id="e11a716b5dc9d27d9966b39b2c63b32b4c67e627" translate="yes" xml:space="preserve">
          <source>When &amp;lt;rev&amp;gt; is not specified, the command annotates the changes starting backwards from the working tree copy. This flag makes the command pretend as if the working tree copy has the contents of the named file (specify &lt;code&gt;-&lt;/code&gt; to make the command read from the standard input).</source>
          <target state="translated">如果未指定&amp;lt;rev&amp;gt;，则该命令注释从工作树副本向后开始的更改。该标志使命令假装为好像工作树副本具有命名文件的内容（指定 &lt;code&gt;-&lt;/code&gt; 使命令从标准输入中读取）。</target>
        </trans-unit>
        <trans-unit id="df8212af8d2323e7260f5fa3c4bc0bbc714643ff" translate="yes" xml:space="preserve">
          <source>When --fork-point is active, &lt;code&gt;fork_point&lt;/code&gt; will be used instead of &amp;lt;upstream&amp;gt; to calculate the set of commits to rebase, where &lt;code&gt;fork_point&lt;/code&gt; is the result of &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt;
&amp;lt;branch&amp;gt;&lt;/code&gt; command (see &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt;). If &lt;code&gt;fork_point&lt;/code&gt; ends up being empty, the &amp;lt;upstream&amp;gt; will be used as a fallback.</source>
          <target state="translated">当--fork-point处于活动状态时，将使用 &lt;code&gt;fork_point&lt;/code&gt; 而不是&amp;lt;upstream&amp;gt;来计算要变基的提交集，其中 &lt;code&gt;fork_point&lt;/code&gt; 是 &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt; 命令的结果（参见&lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]&lt;/a&gt;）。如果 &lt;code&gt;fork_point&lt;/code&gt; 最终为空，则&amp;lt;upstream&amp;gt;将用作后备。</target>
        </trans-unit>
        <trans-unit id="0b903c4e9a3738f389f65549fe23dcd21fd8909d" translate="yes" xml:space="preserve">
          <source>When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; is specified, it is the string that will be shown instead of the default one.</source>
          <target state="translated">当不使用--graph时，所有历史分支均被展平，这使得很难看到两个连续的提交不属于线性分支。在这种情况下，此选项在它们之间设置了障碍。如果指定了 &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; ，它将显示的是字符串，而不是默认的字符串。</target>
        </trans-unit>
        <trans-unit id="24ff3c267435a7dcecd3166ed52f8210a7c7f0de" translate="yes" xml:space="preserve">
          <source>When --stdout is specified then progress report is displayed during the object count and compression phases but inhibited during the write-out phase. The reason is that in some cases the output stream is directly linked to another command which may wish to display progress status of its own as it processes incoming pack data. This flag is like --progress except that it forces progress report for the write-out phase as well even if --stdout is used.</source>
          <target state="translated">当指定-stdout时,在对象计数和压缩阶段会显示进度报告,但在写入输出阶段会被禁止。原因是在某些情况下,输出流直接连接到另一个命令,而另一个命令可能希望在处理输入的数据包时显示自己的进度状态。这个标志和--progress一样,只是即使使用--stdout,它也会强制写入输出阶段的进度报告。</target>
        </trans-unit>
        <trans-unit id="d3e80ca53bd7d57db503ac84208eff0dbe6d901f" translate="yes" xml:space="preserve">
          <source>When -k is not in effect, all leading strings bracketed with &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; pairs are stripped. This option limits the stripping to only the pairs whose bracketed string contains the word &quot;PATCH&quot;.</source>
          <target state="translated">当-k无效时，将删除所有用 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 对括起来的前导字符串。此选项将剥离仅限于括号中的字符串包含单词&amp;ldquo; PATCH&amp;rdquo;的对。</target>
        </trans-unit>
        <trans-unit id="882475218cb0a9fc17e76a3d4266386adec5dd71" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;$@&quot;&lt;/code&gt; is &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; in the above example, the following usage text would be shown:</source>
          <target state="translated">在上面的示例中，当 &lt;code&gt;&quot;$@&quot;&lt;/code&gt; 为 &lt;code&gt;-h&lt;/code&gt; 或 &lt;code&gt;--help&lt;/code&gt; 时，将显示以下用法文本：</target>
        </trans-unit>
        <trans-unit id="d78a0cbb0812363470a0c64a4a94d40dd1da90bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--batch-all-objects&lt;/code&gt; is in use, visit objects in an order which may be more efficient for accessing the object contents than hash order. The exact details of the order are unspecified, but if you do not require a specific order, this should generally result in faster output, especially with &lt;code&gt;--batch&lt;/code&gt;. Note that &lt;code&gt;cat-file&lt;/code&gt; will still show each object only once, even if it is stored multiple times in the repository.</source>
          <target state="translated">当使用 &lt;code&gt;--batch-all-objects&lt;/code&gt; 时，以比散列顺序更有效的方式访问对象，以访问对象内容的顺序。该命令的确切详细信息尚未指定，但是如果您不需要特定的命令，则通常应能提高输出速度，尤其是使用 &lt;code&gt;--batch&lt;/code&gt; 时。请注意，即使 &lt;code&gt;cat-file&lt;/code&gt; 多次存储在存储库中，cat-file仍只会显示每个对象一次。</target>
        </trans-unit>
        <trans-unit id="95919047a579b82415a0ddd6c6f601bfbb7dc80f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--check&lt;/code&gt; is in effect, or when applying the patch (which is the default when none of the options that disables it is in effect), make sure the patch is applicable to what the current index file records. If the file to be patched in the working tree is not up to date, it is flagged as an error. This flag also causes the index file to be updated.</source>
          <target state="translated">当 &lt;code&gt;--check&lt;/code&gt; 生效时，或在应用补丁程序时（这是所有禁用它的选项都没有生效的默认设置），请确保该补丁程序适用于当前索引文件记录的内容。如果要在工作树中修补的文件不是最新的，则将其标记为错误。此标志还导致索引文件被更新。</target>
        </trans-unit>
        <trans-unit id="526cf7ed548b3415806841ff6b0e065a944a8f5e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--compose&lt;/code&gt; is used, git send-email will use the From, Subject, and In-Reply-To headers specified in the message. If the body of the message (what you type after the headers and a blank line) only contains blank (or Git: prefixed) lines, the summary won&amp;rsquo;t be sent, but From, Subject, and In-Reply-To headers will be used unless they are removed.</source>
          <target state="translated">当使用 &lt;code&gt;--compose&lt;/code&gt; 时，git send-email将使用消息中指定的From，Subject和In-Reply-To标头。如果邮件的正文（在标题和空白行之后键入的内容）仅包含空白行（或Git：带前缀的行），则不会发送摘要，但发件人，主题和In-Reply-To标头除非将其删除，否则将被使用。</target>
        </trans-unit>
        <trans-unit id="46dc43993fdd7156fca21e87a205fc0f333f2d9a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--cone&lt;/code&gt; is provided, the &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; setting is also set, allowing for better performance with a limited set of patterns (see &lt;code&gt;CONE PATTERN SET&lt;/code&gt; below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6d168ca5e25a70ab78d5a850025a2ad07d998b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--exclude&lt;/code&gt; and &lt;code&gt;--include&lt;/code&gt; patterns are used, they are examined in the order they appear on the command line, and the first match determines if a patch to each path is used. A patch to a path that does not match any include/exclude pattern is used by default if there is no include pattern on the command line, and ignored if there is any include pattern.</source>
          <target state="translated">使用 &lt;code&gt;--exclude&lt;/code&gt; 和 &lt;code&gt;--include&lt;/code&gt; 模式时，将按照它们在命令行中出现的顺序进行检查，并且第一个匹配项确定是否使用了每个路径的补丁。如果命令行上没有包含模式，则默认使用与任何包含/排除模式都不匹配的路径的补丁程序；如果存在任何包含模式，则将忽略该补丁。</target>
        </trans-unit>
        <trans-unit id="febfb7b902fc970c3396f3068a5c66e59c7ec8ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--notes&lt;/code&gt; is in effect, the message from the notes is matched as if it were part of the log message.</source>
          <target state="translated">当 &lt;code&gt;--notes&lt;/code&gt; 生效时，便笺中的消息将被匹配，就好像它是日志消息的一部分一样。</target>
        </trans-unit>
        <trans-unit id="b84c74a91c715b3bf1b4e927529a07a15aed9721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--numstat&lt;/code&gt; has been given, do not munge pathnames, but use a NUL-terminated machine-readable format.</source>
          <target state="translated">当 &lt;code&gt;--numstat&lt;/code&gt; 已给出，不Munge时间路径名，而是用一个NULL结尾的机器可读的格式。</target>
        </trans-unit>
        <trans-unit id="d371e700585c518084c33d84fef0af43b13c3439" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt; or &lt;code&gt;--name-status&lt;/code&gt; has been given, do not munge pathnames and use NULs as output field terminators.</source>
          <target state="translated">当 &lt;code&gt;--raw&lt;/code&gt; ， &lt;code&gt;--numstat&lt;/code&gt; ， &lt;code&gt;--name-only&lt;/code&gt; 或 &lt;code&gt;--name-status&lt;/code&gt; 已经给出，不Munge时间路径名，并使用完全无效的输出字段终止符。</target>
        </trans-unit>
        <trans-unit id="e163d548a1a886a531d60736c2ba3e851388a10a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--root&lt;/code&gt; is specified the initial commit will be shown as a big creation event. This is equivalent to a diff against the NULL tree.</source>
          <target state="translated">当 &lt;code&gt;--root&lt;/code&gt; 指定初始提交将显示为一个大的创建事件。这等效于对NULL树的差异。</target>
        </trans-unit>
        <trans-unit id="8183759ad974b12070a46362dbaa27565534e645" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--show-pulls&lt;/code&gt; is paired with &lt;code&gt;--simplify-merges&lt;/code&gt;, the graph includes all of the necessary information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b88ba2b22685842fbd9b8b75fb2959da8ea9e8b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--stdin&lt;/code&gt; is specified, the command does not take &amp;lt;tree-ish&amp;gt; arguments from the command line. Instead, it reads lines containing either two &amp;lt;tree&amp;gt;, one &amp;lt;commit&amp;gt;, or a list of &amp;lt;commit&amp;gt; from its standard input. (Use a single space as separator.)</source>
          <target state="translated">当 &lt;code&gt;--stdin&lt;/code&gt; 被指定时，该命令不采取从命令行&amp;lt;树肥胖型&amp;gt;参数。而是从其标准输入中读取包含两个&amp;lt;tree&amp;gt;，一个&amp;lt;commit&amp;gt;或&amp;lt;commit&amp;gt;列表的行。（使用单个空格作为分隔符。）</target>
        </trans-unit>
        <trans-unit id="c23ac888d8fe422c1532e2aed10782043e7c6859" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--temp&lt;/code&gt; is used (or implied by &lt;code&gt;--stage=all&lt;/code&gt;) &lt;code&gt;git checkout-index&lt;/code&gt; will create a temporary file for each index entry being checked out. The index will not be updated with stat information. These options can be useful if the caller needs all stages of all unmerged entries so that the unmerged files can be processed by an external merge tool.</source>
          <target state="translated">当使用 &lt;code&gt;--temp&lt;/code&gt; （或由 &lt;code&gt;--stage=all&lt;/code&gt; 隐含）时， &lt;code&gt;git checkout-index&lt;/code&gt; 将为每个被检出的索引条目创建一个临时文件。该索引将不会使用统计信息进行更新。如果调用者需要所有未合并条目的所有阶段，以便外部合并工具可以处理未合并文件，则这些选项很有用。</target>
        </trans-unit>
        <trans-unit id="5c97ac9560dda79ead627bde39274f79b6e5dd8a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; are used without &lt;code&gt;--pickaxe-all&lt;/code&gt;, only filepairs that match their respective criterion are kept in the output. When &lt;code&gt;--pickaxe-all&lt;/code&gt; is used, if even one filepair matches their respective criterion in a changeset, the entire changeset is kept. This behavior is designed to make reviewing changes in the context of the whole changeset easier.</source>
          <target state="translated">在不带 &lt;code&gt;--pickaxe-all&lt;/code&gt; 的情况下使用 &lt;code&gt;-S&lt;/code&gt; 或 &lt;code&gt;-G&lt;/code&gt; 时，仅匹配其各自标准的文件对将保留在输出中。当使用 &lt;code&gt;--pickaxe-all&lt;/code&gt; 时，即使在变更集中一个文件对也符合其各自的标准，整个变更集也会保留。此行为旨在使在整个变更集的上下文中更轻松地检查变更。</target>
        </trans-unit>
        <trans-unit id="b7230470efbcbdb8b4c76cdcdcf3272fde68030f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; finds a change, show all the changes in that changeset, not just the files that contain the change in &amp;lt;string&amp;gt;.</source>
          <target state="translated">当 &lt;code&gt;-S&lt;/code&gt; 或 &lt;code&gt;-G&lt;/code&gt; 找到更改时，请显示该更改集中的所有更改，而不仅仅是显示&amp;lt;string&amp;gt;中包含更改的文件。</target>
        </trans-unit>
        <trans-unit id="b52ce403c26e2631158c50ee6bd3c17065ed82dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-u&lt;/code&gt; option is not used, untracked files and directories are shown (i.e. the same as specifying &lt;code&gt;normal&lt;/code&gt;), to help you avoid forgetting to add newly created files. Because it takes extra work to find untracked files in the filesystem, this mode may take some time in a large working tree. Consider enabling untracked cache and split index if supported (see &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; and &lt;code&gt;git update-index
--split-index&lt;/code&gt;), Otherwise you can use &lt;code&gt;no&lt;/code&gt; to have &lt;code&gt;git status&lt;/code&gt; return more quickly without showing untracked files.</source>
          <target state="translated">如果不使用 &lt;code&gt;-u&lt;/code&gt; 选项，则会显示未跟踪的文件和目录（即与指定 &lt;code&gt;normal&lt;/code&gt; 相同），以帮助您避免忘记添加新创建的文件。因为在文件系统中查找未跟踪的文件需要额外的工作，所以此模式在大型工作树中可能需要一些时间。如果支持，请考虑启用未跟踪的缓存和拆分索引（请参阅 &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; 和 &lt;code&gt;git update-index --split-index&lt;/code&gt; ），否则，可以使用 &lt;code&gt;no&lt;/code&gt; 来使 &lt;code&gt;git status&lt;/code&gt; 更快地返回，而不会显示未跟踪的文件。</target>
        </trans-unit>
        <trans-unit id="97c7c816e31485397947c4cd78f79e742f80ec39" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-z&lt;/code&gt; output option is in effect, the output is formatted this way:</source>
          <target state="translated">当 &lt;code&gt;-z&lt;/code&gt; output选项生效时，以这种方式格式化输出：</target>
        </trans-unit>
        <trans-unit id="2bf71954fc8fac90c9030e3b9b1232971580d22a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;FETCH_HEAD&lt;/code&gt; (and no other commit) is specified, the branches recorded in the &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; file by the previous invocation of &lt;code&gt;git fetch&lt;/code&gt; for merging are merged to the current branch.</source>
          <target state="translated">当 &lt;code&gt;FETCH_HEAD&lt;/code&gt; （并且没有其他提交）时，通过先前调用 &lt;code&gt;git fetch&lt;/code&gt; 进行合并而记录在 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 文件中的分支将合并到当前分支。</target>
        </trans-unit>
        <trans-unit id="30aaf2e9dd06a0335c5f1cb4c0791345a6730170" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled, the input list is considered a list of directories instead of sparse-checkout patterns. The command writes patterns to the sparse-checkout file to include all files contained in those directories (recursively) as well as files that are siblings of ancestor directories. The input format matches the output of &lt;code&gt;git ls-tree --name-only&lt;/code&gt;. This includes interpreting pathnames that begin with a double quote (&quot;) as C-style quoted strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a79eb2995cdbf5e2d0a3c4b4e62d970b5798ea30" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; is enabled, the config file &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; is read after &lt;code&gt;.git/config&lt;/code&gt; is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="093107f57324ea8ddf834562dc5da735634ce1c2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.fsckObjects&lt;/code&gt; or &lt;code&gt;receive.fsckObjects&lt;/code&gt; are not set, the value of this variable is used instead. Defaults to false.</source>
          <target state="translated">当未设置 &lt;code&gt;fetch.fsckObjects&lt;/code&gt; 或 &lt;code&gt;receive.fsckObjects&lt;/code&gt; 时，将使用此变量的值。默认为false。</target>
        </trans-unit>
        <trans-unit id="f0f4e4ab298d72d3ce878991ffe1cd2532ffab74" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.unpackLimit&lt;/code&gt; or &lt;code&gt;receive.unpackLimit&lt;/code&gt; are not set, the value of this variable is used instead. The default value is 100.</source>
          <target state="translated">当未设置 &lt;code&gt;fetch.unpackLimit&lt;/code&gt; 或 &lt;code&gt;receive.unpackLimit&lt;/code&gt; 时，将使用此变量的值。默认值为100。</target>
        </trans-unit>
        <trans-unit id="0f43e1a31ad9e45784cdafec68b8141e1a628402" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; is set, errors can be switched to warnings and vice versa by configuring the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; setting where the &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; is the fsck message ID and the value is one of &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;. For convenience, fsck prefixes the error/warning with the message ID, e.g. &quot;missingEmail: invalid author/committer line - missing email&quot; means that setting &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; will hide that issue.</source>
          <target state="translated">设置 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ，可以通过配置 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 设置将错误切换为警告，反之亦然，其中 &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; 是fsck消息ID，值是 &lt;code&gt;error&lt;/code&gt; 之一。， &lt;code&gt;warn&lt;/code&gt; 或 &lt;code&gt;ignore&lt;/code&gt; 。为了方便起见，fsck在错误/警告之前添加了消息ID，例如&amp;ldquo; missingEmail：无效的作者/提交者行-缺少电子邮件&amp;rdquo;表示设置 &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; 将隐藏该问题。</target>
        </trans-unit>
        <trans-unit id="ce3f108ee8253a42ecb067bc1a011bcbcd3ad290" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git apply&lt;/code&gt; is used as a &quot;better GNU patch&quot;, the user can pass the &lt;code&gt;--unsafe-paths&lt;/code&gt; option to override this safety check. This option has no effect when &lt;code&gt;--index&lt;/code&gt; or &lt;code&gt;--cached&lt;/code&gt; is in use.</source>
          <target state="translated">当 &lt;code&gt;git apply&lt;/code&gt; 用作&amp;ldquo;更好的GNU补丁&amp;rdquo;时，用户可以通过 &lt;code&gt;--unsafe-paths&lt;/code&gt; 选项来覆盖此安全检查。使用 &lt;code&gt;--index&lt;/code&gt; 或 &lt;code&gt;--cached&lt;/code&gt; 时，此选项无效。</target>
        </trans-unit>
        <trans-unit id="dea5ce8f581717a21d1ee89e4952655599f11488" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git difftool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;diff.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with the following variables available: &lt;code&gt;$LOCAL&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff pre-image and &lt;code&gt;$REMOTE&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff post-image. &lt;code&gt;$MERGED&lt;/code&gt; is the name of the file which is being compared. &lt;code&gt;$BASE&lt;/code&gt; is provided for compatibility with custom merge tool commands and has the same value as &lt;code&gt;$MERGED&lt;/code&gt;.</source>
          <target state="translated">当使用此工具（通过 &lt;code&gt;-t&lt;/code&gt; 或 &lt;code&gt;--tool&lt;/code&gt; 选项或 &lt;code&gt;diff.tool&lt;/code&gt; 配置变量）调用 &lt;code&gt;git difftool&lt;/code&gt; 时,将使用以下可用变量调用已配置的命令行： &lt;code&gt;$LOCAL&lt;/code&gt; 设置为临时名称包含差异前映像内容和 &lt;code&gt;$REMOTE&lt;/code&gt; 被设置为包含差异后映像内容的临时文件的名称。 &lt;code&gt;$MERGED&lt;/code&gt; 是要比较的文件的名称。提供 &lt;code&gt;$BASE&lt;/code&gt; 是为了与自定义合并工具命令兼容，并且具有与 &lt;code&gt;$MERGED&lt;/code&gt; 相同的值。</target>
        </trans-unit>
        <trans-unit id="02bc7953c8eb819402a97fdb05db86103d3e94f0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run with explicit branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin master&lt;/code&gt;, the &amp;lt;refspec&amp;gt;s given on the command line determine what are to be fetched (e.g. &lt;code&gt;master&lt;/code&gt; in the example, which is a short-hand for &lt;code&gt;master:&lt;/code&gt;, which in turn means &quot;fetch the &lt;code&gt;master&lt;/code&gt; branch but I do not explicitly say what remote-tracking branch to update with it from the command line&quot;), and the example command will fetch &lt;code&gt;only&lt;/code&gt; the &lt;code&gt;master&lt;/code&gt; branch. The &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values determine which remote-tracking branch, if any, is updated. When used in this way, the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values do not have any effect in deciding &lt;code&gt;what&lt;/code&gt; gets fetched (i.e. the values are not used as refspecs when the command-line lists refspecs); they are only used to decide &lt;code&gt;where&lt;/code&gt; the refs that are fetched are stored by acting as a mapping.</source>
          <target state="translated">当 &lt;code&gt;git fetch&lt;/code&gt; 与显式分支和/或标记一起运行以在命令行上进行获取时，例如 &lt;code&gt;git fetch origin master&lt;/code&gt; ，命令行上给出的&amp;lt;refspec&amp;gt;确定要获取的内容（例如，示例中的 &lt;code&gt;master&lt;/code&gt; ，即短手的 &lt;code&gt;master:&lt;/code&gt; ，这反过来又意味着&amp;ldquo;取 &lt;code&gt;master&lt;/code&gt; 分支，但我并没有明确说什么远程跟踪分支的命令行与它更新&amp;rdquo;），示例命令将获取 &lt;code&gt;only&lt;/code&gt; 的 &lt;code&gt;master&lt;/code&gt; 分支。所述 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 值确定哪个远程跟踪分支，如果有的话，将被更新。以这种方式使用时，将使用 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 值对确定 &lt;code&gt;what&lt;/code&gt; 获取的内容没有任何影响（即，当命令行列出refspecs时，这些值不用作refspecs）；它们仅用于决定 &lt;code&gt;where&lt;/code&gt; 是取出裁判被用作映射存储。</target>
        </trans-unit>
        <trans-unit id="d3bb27ea8d5739147518646e08d478432b5ac353" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run without specifying what branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values are used as the refspecs&amp;mdash;​they specify which refs to fetch and which local refs to update. The example above will fetch all branches that exist in the &lt;code&gt;origin&lt;/code&gt; (i.e. any ref that matches the left-hand side of the value, &lt;code&gt;refs/heads/*&lt;/code&gt;) and update the corresponding remote-tracking branches in the &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; hierarchy.</source>
          <target state="translated">在运行 &lt;code&gt;git fetch&lt;/code&gt; 时未指定要在命令行上提取的分支和/或标签的情况下，例如 &lt;code&gt;git fetch origin&lt;/code&gt; 或 &lt;code&gt;git fetch&lt;/code&gt; ， &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 值用作refspecs-它们指定要提取和提取的ref哪个本地参考要更新。上面的示例将获取 &lt;code&gt;origin&lt;/code&gt; 中存在的所有分支（即，与值的左侧匹配的所有ref &lt;code&gt;refs/heads/*&lt;/code&gt; ），并更新 &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; 中的相应远程跟踪分支。层次结构。</target>
        </trans-unit>
        <trans-unit id="6bfc306f6ccec6cbac00c82d44f7befe47671739" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part below. This option overrides that check.</source>
          <target state="translated">当 &lt;code&gt;git fetch&lt;/code&gt; 与 &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec一起使用时，它可能会拒绝更新本地分支，如下面的 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 部分所述。此选项将覆盖该检查。</target>
        </trans-unit>
        <trans-unit id="b8a0a18f13c1248a211519fc4b6c3ee775403075" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part of the &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; documentation. This option overrides that check.</source>
          <target state="translated">当 &lt;code&gt;git fetch&lt;/code&gt; 与 &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec一起使用时，它可能会拒绝更新本地分支，如&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;文档的 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 部分所述。此选项将覆盖该检查。</target>
        </trans-unit>
        <trans-unit id="946d45913d1a6d20975808ddb9f4de7a3a592055" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it calls &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt;. This config variable can be used to set a different grace period. The value &quot;now&quot; may be used to disable the grace period and prune &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; immediately, or &quot;never&quot; may be used to suppress pruning.</source>
          <target state="translated">当 &lt;code&gt;git gc&lt;/code&gt; 运行时，它会调用 &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt; 。此配置变量可用于设置不同的宽限期。值&amp;ldquo; now&amp;rdquo;可用于禁用宽限期并立即修剪 &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; ，或&amp;ldquo; never&amp;rdquo;可用于禁止修剪。</target>
        </trans-unit>
        <trans-unit id="bdaf9b565f5bc5effacd5e94ca1e6e23df9c9f7a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it will call &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt;. Override the grace period with this config variable. The value &quot;now&quot; may be used to disable this grace period and always prune unreachable objects immediately, or &quot;never&quot; may be used to suppress pruning. This feature helps prevent corruption when &lt;code&gt;git gc&lt;/code&gt; runs concurrently with another process writing to the repository; see the &quot;NOTES&quot; section of &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">当 &lt;code&gt;git gc&lt;/code&gt; 运行时，它会调用 &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt; 。使用此配置变量覆盖宽限期。值&amp;ldquo; now&amp;rdquo;可用于禁用此宽限期，并始终立即修剪不可达的对象，或者&amp;ldquo; never&amp;rdquo;可用于禁止修剪。当 &lt;code&gt;git gc&lt;/code&gt; 与另一个写入存储库的进程同时运行时，此功能有助于防止损坏。参见&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;的&amp;ldquo; NOTES&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="9771ab35f0db8c62ffb81b026ac116ab479df958" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git mergetool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;merge.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with &lt;code&gt;$BASE&lt;/code&gt; set to the name of a temporary file containing the common base for the merge, if available; &lt;code&gt;$LOCAL&lt;/code&gt; set to the name of a temporary file containing the contents of the file on the current branch; &lt;code&gt;$REMOTE&lt;/code&gt; set to the name of a temporary file containing the contents of the file to be merged, and &lt;code&gt;$MERGED&lt;/code&gt; set to the name of the file to which the merge tool should write the result of the merge resolution.</source>
          <target state="translated">当 &lt;code&gt;git mergetool&lt;/code&gt; 被调用与此工具（或者通过 &lt;code&gt;-t&lt;/code&gt; 或 &lt;code&gt;--tool&lt;/code&gt; 选项或 &lt;code&gt;merge.tool&lt;/code&gt; 配置变量）所配置的命令行将与被调用 &lt;code&gt;$BASE&lt;/code&gt; 设定为包含在共用基座的临时文件的名称合并（如果有）； &lt;code&gt;$LOCAL&lt;/code&gt; 设置为包含当前分支上文件内容的临时文件的名称； &lt;code&gt;$REMOTE&lt;/code&gt; 设置为包含要合并文件内容的临时文件的名称，而 &lt;code&gt;$MERGED&lt;/code&gt; 设置为合并工具应向其中写入合并解析结果的文件的名称。</target>
        </trans-unit>
        <trans-unit id="8d649c2a1b515f828b380ed0228639a9abf6f2e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-difftool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default diff tool will be read from the configured &lt;code&gt;diff.guitool&lt;/code&gt; variable instead of &lt;code&gt;diff.tool&lt;/code&gt;. The &lt;code&gt;--no-gui&lt;/code&gt; option can be used to override this setting. If &lt;code&gt;diff.guitool&lt;/code&gt; is not set, we will fallback in the order of &lt;code&gt;merge.guitool&lt;/code&gt;, &lt;code&gt;diff.tool&lt;/code&gt;, &lt;code&gt;merge.tool&lt;/code&gt; until a tool is found.</source>
          <target state="translated">当使用 &lt;code&gt;-g&lt;/code&gt; 或 &lt;code&gt;--gui&lt;/code&gt; 选项调用 &lt;code&gt;git-difftool&lt;/code&gt; 时,将从配置的 &lt;code&gt;diff.guitool&lt;/code&gt; 变量而不是 &lt;code&gt;diff.tool&lt;/code&gt; 中读取默认的diff工具。该 &lt;code&gt;--no-gui&lt;/code&gt; 选项可用于覆盖此设置。如果 &lt;code&gt;diff.guitool&lt;/code&gt; 没有设置，我们将在顺序后备 &lt;code&gt;merge.guitool&lt;/code&gt; ， &lt;code&gt;diff.tool&lt;/code&gt; ， &lt;code&gt;merge.tool&lt;/code&gt; 直到工具中找到。</target>
        </trans-unit>
        <trans-unit id="dab1778e78eece39a70fe4959b77fef05af95366" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-mergetool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default merge tool will be read from the configured &lt;code&gt;merge.guitool&lt;/code&gt; variable instead of &lt;code&gt;merge.tool&lt;/code&gt;. If &lt;code&gt;merge.guitool&lt;/code&gt; is not set, we will fallback to the tool configured under &lt;code&gt;merge.tool&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;git-mergetool&lt;/code&gt; 与调用 &lt;code&gt;-g&lt;/code&gt; 或 &lt;code&gt;--gui&lt;/code&gt; 选项默认合并工具会从配置的读取 &lt;code&gt;merge.guitool&lt;/code&gt; 变量，而不是 &lt;code&gt;merge.tool&lt;/code&gt; 。如果 &lt;code&gt;merge.guitool&lt;/code&gt; 没有设置，我们将回退到下配置的工具 &lt;code&gt;merge.tool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55d1f905322639499a3e0c7d64b920e915841fa1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;group&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), the repository is made shareable between several users in a group (making sure all the files and objects are group-writable). When &lt;code&gt;all&lt;/code&gt; (or &lt;code&gt;world&lt;/code&gt; or &lt;code&gt;everybody&lt;/code&gt;), the repository will be readable by all users, additionally to being group-shareable. When &lt;code&gt;umask&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;), Git will use permissions reported by umask(2). When &lt;code&gt;0xxx&lt;/code&gt;, where &lt;code&gt;0xxx&lt;/code&gt; is an octal number, files in the repository will have this mode value. &lt;code&gt;0xxx&lt;/code&gt; will override user&amp;rsquo;s umask value (whereas the other options will only override requested parts of the user&amp;rsquo;s umask value). Examples: &lt;code&gt;0660&lt;/code&gt; will make the repo read/write-able for the owner and group, but inaccessible to others (equivalent to &lt;code&gt;group&lt;/code&gt; unless umask is e.g. &lt;code&gt;0022&lt;/code&gt;). &lt;code&gt;0640&lt;/code&gt; is a repository that is group-readable but not group-writable. See &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;. False by default.</source>
          <target state="translated">如果为 &lt;code&gt;group&lt;/code&gt; （或 &lt;code&gt;true&lt;/code&gt; ），则使存储库在一个组中的多个用户之间可共享（确保所有文件和对象都是可写的）。当 &lt;code&gt;all&lt;/code&gt; （或 &lt;code&gt;world&lt;/code&gt; 或 &lt;code&gt;everybody&lt;/code&gt; ）时，除了可以组共享之外，所有用户都可以读取该存储库。当 &lt;code&gt;umask&lt;/code&gt; （或 &lt;code&gt;false&lt;/code&gt; ）时，Git将使用umask（2）报告的权限。当 &lt;code&gt;0xxx&lt;/code&gt; ，其中 &lt;code&gt;0xxx&lt;/code&gt; 是一个八进制数时，存储库中的文件将具有此模式值。 &lt;code&gt;0xxx&lt;/code&gt; 将覆盖用户的umask值（而其他选项将仅覆盖用户的umask值的请求部分）。例子： &lt;code&gt;0660&lt;/code&gt; 将使所有者和组可以读取/写入该存储库，但其他用户则无法访问该存储库（除非umask例如 &lt;code&gt;0022&lt;/code&gt; ,否则等效于 &lt;code&gt;group&lt;/code&gt; ）。 &lt;code&gt;0640&lt;/code&gt; 是可组读取但不可组写入的存储库。参见&lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt;。默认为False。</target>
        </trans-unit>
        <trans-unit id="0c640b1443fdc376fb0e05e5b19871e0f70bfa75" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;interactive&lt;/code&gt;, enable the interactive mode of rebase.</source>
          <target state="translated">当 &lt;code&gt;interactive&lt;/code&gt; ，使底垫的交互模式。</target>
        </trans-unit>
        <trans-unit id="0e5d1d0d5309f291d73a19a6f71347b59d761978" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;konqueror&lt;/code&gt; is specified in the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable, we launch &lt;code&gt;kfmclient&lt;/code&gt; to try to open the man page on an already opened konqueror in a new tab if possible.</source>
          <target state="translated">当 &lt;code&gt;konqueror&lt;/code&gt; 在指定 &lt;code&gt;man.viewer&lt;/code&gt; 配置变量，我们推出 &lt;code&gt;kfmclient&lt;/code&gt; 尝试，如果能够在新标签中打开一个已经打开的Konqueror手册页。</target>
        </trans-unit>
        <trans-unit id="162b4f89725e01e084b1d2a9bb66f41a211da6f6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;matching&lt;/code&gt; mode is specified, paths that explicitly match an ignored pattern are shown. If a directory matches an ignore pattern, then it is shown, but not paths contained in the ignored directory. If a directory does not match an ignore pattern, but all contents are ignored, then the directory is not shown, but all contents are shown.</source>
          <target state="translated">当 &lt;code&gt;matching&lt;/code&gt; 指定模式，则明确匹配忽略图案路径被示出。如果目录匹配忽略模式，则显示该目录，但不显示忽略目录中包含的路径。如果目录与忽略模式不匹配，但是所有内容都将被忽略，则不会显示目录，但是会显示所有内容。</target>
        </trans-unit>
        <trans-unit id="7ee4878df1abaf60b54059eba9faa52c16598786" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;merges&lt;/code&gt; (or just &lt;code&gt;m&lt;/code&gt;), pass the &lt;code&gt;--rebase-merges&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239b51beb1f8c13233881b0568518d58e269df96" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;merges&lt;/code&gt;, pass the &lt;code&gt;--rebase-merges&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">当 &lt;code&gt;merges&lt;/code&gt; ，通过 &lt;code&gt;--rebase-merges&lt;/code&gt; 选项 &lt;code&gt;git rebase&lt;/code&gt; ，以便本地合并提交被包括在变基（见&lt;a href=&quot;git-rebase&quot;&gt;GIT-变基[1]&lt;/a&gt;的详细信息）。</target>
        </trans-unit>
        <trans-unit id="26887709475bb99a484f3550dfcf66463a02ff1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), also pass &lt;code&gt;--preserve-merges&lt;/code&gt; along to &lt;code&gt;git rebase&lt;/code&gt; so that locally committed merge commits will not be flattened by running &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;preserve&lt;/code&gt; （弃用，取而代之的 &lt;code&gt;merges&lt;/code&gt; ），也通过 &lt;code&gt;--preserve-merges&lt;/code&gt; 一起 &lt;code&gt;git rebase&lt;/code&gt; ，使本地提交合并的提交将无法通过运行扁平 &lt;code&gt;git pull&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1aa5ac29106f7e567cb177a446057fe6893dfb3c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserve&lt;/code&gt; (or just &lt;code&gt;p&lt;/code&gt;, deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), also pass &lt;code&gt;--preserve-merges&lt;/code&gt; along to &lt;code&gt;git rebase&lt;/code&gt; so that locally committed merge commits will not be flattened by running &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c040d756e251986ff4d930aa40402b774da81b76" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserveUser&lt;/code&gt; is true, &lt;code&gt;git p4&lt;/code&gt; normally dies if it cannot find an author in the p4 user map. This setting submits the change regardless.</source>
          <target state="translated">当 &lt;code&gt;preserveUser&lt;/code&gt; 为true时，如果 &lt;code&gt;git p4&lt;/code&gt; 在p4用户映射中找不到作者，通常会死亡。无论如何，此设置都会提交更改。</target>
        </trans-unit>
        <trans-unit id="f1cb457481e4cab2531cdb48fb2ed70a72c47f80" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;receive-pack&lt;/code&gt; takes in objects, they are placed into a temporary &quot;quarantine&quot; directory within the &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory and migrated into the main object store only after the &lt;code&gt;pre-receive&lt;/code&gt; hook has completed. If the push fails before then, the temporary directory is removed entirely.</source>
          <target state="translated">当 &lt;code&gt;receive-pack&lt;/code&gt; 接收对象时，仅在 &lt;code&gt;pre-receive&lt;/code&gt; 挂钩完成后，它们才会放入 &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; 目录中的临时&amp;ldquo;隔离&amp;rdquo;目录中，并迁移到主对象存储中。如果在此之前推送失败，则将临时目录完全删除。</target>
        </trans-unit>
        <trans-unit id="13eed45e8cb127a4420b06f0b52f497c696b7d45" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; is set to &quot;auto&quot;, the path is marked for automatic end-of-line conversion. If Git decides that the content is text, its line endings are converted to LF on checkin. When the file has been committed with CRLF, no conversion is done.</source>
          <target state="translated">当 &lt;code&gt;text&lt;/code&gt; 设置为&amp;ldquo;自动&amp;rdquo;时，该路径被标记为自动行尾转换。如果Git决定内容为文本，则其行尾在签入时将转换为LF。使用CRLF提交文件后，不会进行任何转换。</target>
        </trans-unit>
        <trans-unit id="2bb8610f0d3f51c94aca7dd51e3603814301750d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text=auto&lt;/code&gt; conversion is enabled in a cross-platform project using push and pull to a central repository the text files containing CRLFs should be normalized.</source>
          <target state="translated">当 &lt;code&gt;text=auto&lt;/code&gt; 转换是一个跨平台的项目中使用推拉到一个中央存储库包含CRLFs文本文件启用进行归一化。</target>
        </trans-unit>
        <trans-unit id="f1b569ad0a0d3f731d90377a830d25de99487fad" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;upload-pack&lt;/code&gt; has started &lt;code&gt;pack-objects&lt;/code&gt;, there may be a quiet period while &lt;code&gt;pack-objects&lt;/code&gt; prepares the pack. Normally it would output progress information, but if &lt;code&gt;--quiet&lt;/code&gt; was used for the fetch, &lt;code&gt;pack-objects&lt;/code&gt; will output nothing at all until the pack data begins. Some clients and networks may consider the server to be hung and give up. Setting this option instructs &lt;code&gt;upload-pack&lt;/code&gt; to send an empty keepalive packet every &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; seconds. Setting this option to 0 disables keepalive packets entirely. The default is 5 seconds.</source>
          <target state="translated">当 &lt;code&gt;upload-pack&lt;/code&gt; 开始 &lt;code&gt;pack-objects&lt;/code&gt; ， &lt;code&gt;pack-objects&lt;/code&gt; 准备打包时可能会有一段安静的时间。通常，它将输出进度信息，但是如果将 &lt;code&gt;--quiet&lt;/code&gt; 用于获取，则在压缩数据开始之前，压缩 &lt;code&gt;pack-objects&lt;/code&gt; 将什么也不输出。一些客户端和网络可能会认为服务器已挂起并放弃。设置此选项将指示 &lt;code&gt;upload-pack&lt;/code&gt; 每隔 &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; 秒发送一个空的keepalive数据包。将此选项设置为0将完全禁用keepalive数据包。默认值为5秒。</target>
        </trans-unit>
        <trans-unit id="09ea8c9e4617731ed2a0cdf40185d39ec477e171" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; is in effect, allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for an object at the tip of a hidden ref (by default, such a request is rejected). See also &lt;code&gt;uploadpack.hideRefs&lt;/code&gt;. Even if this is false, a client may be able to steal objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">当 &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; 生效时，允许 &lt;code&gt;upload-pack&lt;/code&gt; 接受在隐藏ref的尖端请求对象的获取请求（默认情况下，该请求被拒绝）。另请参见 &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; 。即使这是错误的，客户端也可以通过&lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt;手册页的&amp;ldquo;安全&amp;rdquo;部分中描述的技术来窃取对象。最好将私有数据保存在单独的存储库中。</target>
        </trans-unit>
        <trans-unit id="5f953a201b0ae4d35f35034718b3114ef928787f" translate="yes" xml:space="preserve">
          <source>When Git doesn&amp;rsquo;t know how to handle a certain transport protocol, it attempts to use the &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used:</source>
          <target state="translated">当Git不知道如何处理某种传输协议时，它会尝试使用 &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; 远程帮助程序（如果存在）。要显式请求远程帮助者，可以使用以下语法：</target>
        </trans-unit>
        <trans-unit id="cf58a154a8f8fa8889640812d376b7964ce7bef2" translate="yes" xml:space="preserve">
          <source>When Git encounters a URL of the form &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; is a protocol that it cannot handle natively, it automatically invokes &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with the full URL as the second argument. If such a URL is encountered directly on the command line, the first argument is the same as the second, and if it is encountered in a configured remote, the first argument is the name of that remote.</source>
          <target state="translated">当Git遇到 &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt; 形式的URL时，其中 &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; 是它本身无法处理的协议，它会自动调用 &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; ，并将完整URL作为第二个参数。如果直接在命令行上遇到这样的URL，则第一个参数与第二个参数相同，如果在已配置的远程中遇到该URL，则第一个参数是该远程的名称。</target>
        </trans-unit>
        <trans-unit id="27018e5bb4c8622ebcfed2f81b80284203c3bc2f" translate="yes" xml:space="preserve">
          <source>When Git encounters the first file that needs to be cleaned or smudged, it starts the filter and performs the handshake. In the handshake, the welcome message sent by Git is &quot;git-filter-client&quot;, only version 2 is supported, and the supported capabilities are &quot;clean&quot;, &quot;smudge&quot;, and &quot;delay&quot;.</source>
          <target state="translated">当Git遇到第一个需要清理或污损的文件时,就会启动过滤器并进行握手。在握手过程中,Git发送的欢迎信息是 &quot;git-filter-client&quot;,只支持第2版,支持的功能是 &quot;clean&quot;、&quot;smudge &quot;和 &quot;delay&quot;。</target>
        </trans-unit>
        <trans-unit id="f51f886a7edb2e397d8670010685e9d17fb9bc09" translate="yes" xml:space="preserve">
          <source>When Git needs authentication for a particular URL context, credential-store will consider that context a pattern to match against each entry in the credentials file. If the protocol, hostname, and username (if we already have one) match, then the password is returned to Git. See the discussion of configuration in &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">当Git需要针对特定​​URL上下文进行身份验证时，凭据存储将认为该上下文是一种与凭据文件中每个条目匹配的模式。如果协议，主机名和用户名（如果已经有）匹配，那么密码将返回给Git。有关更多信息，请参见&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]中&lt;/a&gt;有关配置的讨论。</target>
        </trans-unit>
        <trans-unit id="fbdc4494c8c569621bd35073fd02055c267f7e54" translate="yes" xml:space="preserve">
          <source>When Git needs to show you a diff for the path with &lt;code&gt;diff&lt;/code&gt; attribute set to &lt;code&gt;jcdiff&lt;/code&gt;, it calls the command you specified with the above configuration, i.e. &lt;code&gt;j-c-diff&lt;/code&gt;, with 7 parameters, just like &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; program is called. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">当Git需要将 &lt;code&gt;diff&lt;/code&gt; 属性设置为 &lt;code&gt;jcdiff&lt;/code&gt; 的路径显示给您diff时，它将调用您使用上述配置指定的命令，即 &lt;code&gt;j-c-diff&lt;/code&gt; ，具有7个参数，就像 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 程序一样。有关详细信息，请参见&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb3065603615c6a64dfcb623c10f42c6b9e417fa" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;git push --signed&lt;/code&gt; sent a push certificate with a &quot;nonce&quot; that was issued by a receive-pack serving the same repository within this many seconds, export the &quot;nonce&quot; found in the certificate to &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; to the hooks (instead of what the receive-pack asked the sending side to include). This may allow writing checks in &lt;code&gt;pre-receive&lt;/code&gt; and &lt;code&gt;post-receive&lt;/code&gt; a bit easier. Instead of checking &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; environment variable that records by how many seconds the nonce is stale to decide if they want to accept the certificate, they only can check &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; is &lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;git push --signed&lt;/code&gt; 在这么多秒内发送带有服务于同一存储库的接收包发出的带有&amp;ldquo; nonce&amp;rdquo;的推送证书时，请将证书中找到的&amp;ldquo; nonce&amp;rdquo;导出到 &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; 到钩子（而不是接收包要求发送方包括什么）。这可能允许写入检查 &lt;code&gt;pre-receive&lt;/code&gt; 和 &lt;code&gt;post-receive&lt;/code&gt; 一个更容易一些。他们无需检查 &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; 环境变量来记录他们是否愿意接受证书， &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; 仅检查GIT_PUSH_CERT_NONCE_STATUS是 &lt;code&gt;OK&lt;/code&gt; 即可，该环境变量记录了随机数过时的秒数。</target>
        </trans-unit>
        <trans-unit id="f34a76491c47ddfcf2959dd6944574eeda479afa" translate="yes" xml:space="preserve">
          <source>When a command has finished, and the client has received the entire response from the server, a client can either request that another command be executed or can terminate the connection. A client may optionally send an empty request consisting of just a flush-pkt to indicate that no more requests will be made.</source>
          <target state="translated">当一条命令结束,客户端收到服务器的全部响应后,客户端可以请求执行另一条命令,也可以终止连接。客户端可以选择发送一个仅由flush-pkt组成的空请求,以表示不再发出请求。</target>
        </trans-unit>
        <trans-unit id="98e606d10b24cc0c03b08a4efd9e014e2a7d092f" translate="yes" xml:space="preserve">
          <source>When a commit is created in this state, the branch is updated to refer to the new commit. Specifically, &lt;code&gt;git commit&lt;/code&gt; creates a new commit &lt;code&gt;d&lt;/code&gt;, whose parent is commit &lt;code&gt;c&lt;/code&gt;, and then updates branch &lt;code&gt;master&lt;/code&gt; to refer to new commit &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;HEAD&lt;/code&gt; still refers to branch &lt;code&gt;master&lt;/code&gt; and so indirectly now refers to commit &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">在这种状态下创建提交后，分支将更新以引用新的提交。具体来说， &lt;code&gt;git commit&lt;/code&gt; 创建一个新的提交 &lt;code&gt;d&lt;/code&gt; ，其父为commit &lt;code&gt;c&lt;/code&gt; ，然后更新分支 &lt;code&gt;master&lt;/code&gt; 以引用新的提交 &lt;code&gt;d&lt;/code&gt; 。 &lt;code&gt;HEAD&lt;/code&gt; 仍然指分支 &lt;code&gt;master&lt;/code&gt; ，因此现在间接指commit &lt;code&gt;d&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b5e6d106b45c449ef3f9978fa7e9a2c319abd6d7" translate="yes" xml:space="preserve">
          <source>When a conflict occurs while rebasing, rebase stops and asks the user to resolve. Since the user may need to make notable changes while resolving conflicts, after conflicts are resolved and the user has run &lt;code&gt;git rebase --continue&lt;/code&gt;, the rebase should open an editor and ask the user to update the commit message. The merge backend does this, while the apply backend blindly applies the original commit message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d656a10ad8d92cd23d5675fa9c3ba2b92a8d6f" translate="yes" xml:space="preserve">
          <source>When a curl trace is enabled (see &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; above), do not dump data (that is, only dump info lines and headers).</source>
          <target state="translated">启用卷曲跟踪时（请参见上面的 &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; ），请勿转储数据（即，仅转储信息行和标头）。</target>
        </trans-unit>
        <trans-unit id="855748d09cda03242c615ed9f83d928cff4dd252" translate="yes" xml:space="preserve">
          <source>When a fetch mirror is created with &lt;code&gt;--mirror=fetch&lt;/code&gt;, the refs will not be stored in the &lt;code&gt;refs/remotes/&lt;/code&gt; namespace, but rather everything in &lt;code&gt;refs/&lt;/code&gt; on the remote will be directly mirrored into &lt;code&gt;refs/&lt;/code&gt; in the local repository. This option only makes sense in bare repositories, because a fetch would overwrite any local commits.</source>
          <target state="translated">当使用 &lt;code&gt;--mirror=fetch&lt;/code&gt; 创建获取镜像时，参考不会存储在 &lt;code&gt;refs/remotes/&lt;/code&gt; 名称空间中，而是将远程 &lt;code&gt;refs/&lt;/code&gt; 中的所有内容直接镜像到本地存储库中的 &lt;code&gt;refs/&lt;/code&gt; 中。该选项仅在裸仓库中才有意义，因为获取将覆盖所有本地提交。</target>
        </trans-unit>
        <trans-unit id="747511f053f093bdd8637c2efa65029ba86d5e79" translate="yes" xml:space="preserve">
          <source>When a git process is a (direct or indirect) child of another git process, it inherits Trace2 context information. This allows the child to print the command hierarchy. This example shows gc as child[3] of fetch. When the gc process reports its name as &quot;gc&quot;, it also reports the hierarchy as &quot;fetch/gc&quot;. (In this example, trace2 messages from the child process is indented for clarity.)</source>
          <target state="translated">当一个 git 进程是另一个 git 进程的(直接或间接)子进程时,它会继承 Trace2 上下文信息。这允许子进程打印命令层次结构。这个例子显示 gc 是 fetch 的子进程[3]。当 gc 进程将自己的名字报告为 &quot;gc &quot;时,它也将层次结构报告为 &quot;fetch/gc&quot;。(在这个例子中,为了清楚起见,子进程的 trace2 消息被缩进了。)</target>
        </trans-unit>
        <trans-unit id="dcc866e382263d0b053b9eb6226d8321d2b6f3a3" translate="yes" xml:space="preserve">
          <source>When a helper is executed, it will have one &quot;operation&quot; argument appended to its command line, which is one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79294381fcaa0a0dccaa2b41ac29dc7daa74e3f5" translate="yes" xml:space="preserve">
          <source>When a local branch is started off a remote-tracking branch, Git sets up the branch (specifically the &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries) so that &lt;code&gt;git pull&lt;/code&gt; will appropriately merge from the remote-tracking branch. This behavior may be changed via the global &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; configuration flag. That setting can be overridden by using the &lt;code&gt;--track&lt;/code&gt; and &lt;code&gt;--no-track&lt;/code&gt; options, and changed later using &lt;code&gt;git branch --set-upstream-to&lt;/code&gt;.</source>
          <target state="translated">当本地分支从远程跟踪分支启动时，Git会设置分支（特别是 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 和 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 配置条目），以便 &lt;code&gt;git pull&lt;/code&gt; 将适当地从远程分支合并。跟踪分支。可以通过全局 &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; 配置标志来更改此行为。可以使用 &lt;code&gt;--track&lt;/code&gt; 和 &lt;code&gt;--no-track&lt;/code&gt; 选项覆盖该设置，稍后使用 &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; 进行更改。</target>
        </trans-unit>
        <trans-unit id="dbb99a5451930fe8366dedb022737c46385ca3a6" translate="yes" xml:space="preserve">
          <source>When a merge commit is included by &lt;code&gt;--show-pulls&lt;/code&gt;, the merge is treated as if it &quot;pulled&quot; the change from another branch. When using &lt;code&gt;--show-pulls&lt;/code&gt; on this example (and no other options) the resulting graph is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e12783acd89ac9262429bc89fcf85d9b95e88c1" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens during switching branches with the &lt;code&gt;-m&lt;/code&gt; option, you would see something like this:</source>
          <target state="translated">当使用 &lt;code&gt;-m&lt;/code&gt; 选项切换分支期间发生合并冲突时，您将看到类似以下内容：</target>
        </trans-unit>
        <trans-unit id="8b8f6236a48634fd451e67557b1ed432c992a4a6" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with &lt;code&gt;git add&lt;/code&gt; (or &lt;code&gt;git rm&lt;/code&gt; if the merge should result in deletion of the path).</source>
          <target state="translated">发生合并冲突时，冲突路径的索引条目将保持未合并状态，您需要解决冲突并使用 &lt;code&gt;git add&lt;/code&gt; （或 &lt;code&gt;git rm&lt;/code&gt; 标记已解决的路径，如果合并会导致路径的删除）。</target>
        </trans-unit>
        <trans-unit id="054b9e9957838ff74728498487ffff5f26346d88" translate="yes" xml:space="preserve">
          <source>When a merge isn&amp;rsquo;t resolved automatically, Git leaves the index and the working tree in a special state that gives you all the information you need to help resolve the merge.</source>
          <target state="translated">当合并不能自动解决时，Git会将索引和工作树置于特殊状态，为您提供帮助解决合并所需的所有信息。</target>
        </trans-unit>
        <trans-unit id="1d6b6e4ed4a39cb92155b19d26f3a8478b8d6d5c" translate="yes" xml:space="preserve">
          <source>When a new branch is created with &lt;code&gt;git branch&lt;/code&gt;, &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt; that tracks another branch, this variable tells Git to set up pull to rebase instead of merge (see &quot;branch.&amp;lt;name&amp;gt;.rebase&quot;). When &lt;code&gt;never&lt;/code&gt;, rebase is never automatically set to true. When &lt;code&gt;local&lt;/code&gt;, rebase is set to true for tracked branches of other local branches. When &lt;code&gt;remote&lt;/code&gt;, rebase is set to true for tracked branches of remote-tracking branches. When &lt;code&gt;always&lt;/code&gt;, rebase will be set to true for all tracking branches. See &quot;branch.autoSetupMerge&quot; for details on how to set up a branch to track another branch. This option defaults to never.</source>
          <target state="translated">当使用跟踪另一个分支的 &lt;code&gt;git branch&lt;/code&gt; ， &lt;code&gt;git switch&lt;/code&gt; 或 &lt;code&gt;git checkout&lt;/code&gt; 创建一个新分支时，此变量告诉Git设置对基础进行重载而不是合并的拉取（请参阅&amp;ldquo; branch。&amp;lt;name&amp;gt; .rebase&amp;rdquo;）。如果 &lt;code&gt;never&lt;/code&gt; ，则rebase永远不会自动设置为true。当 &lt;code&gt;local&lt;/code&gt; 时，对于其他本地分支的跟踪分支，rebase设置为true。当 &lt;code&gt;remote&lt;/code&gt; 时，远程跟踪分支的跟踪分支的rebase设置为true。当 &lt;code&gt;always&lt;/code&gt; ，底垫将被设置为true，所有跟踪的分支。有关如何设置分支以跟踪另一个分支的详细信息，请参见&amp;ldquo; branch.autoSetupMerge&amp;rdquo;。该选项默认为从不。</target>
        </trans-unit>
        <trans-unit id="ed0adff8e63a6741e1694d5ebc304264bd392424" translate="yes" xml:space="preserve">
          <source>When a patch failure occurs, &amp;lt;msg&amp;gt; will be printed to the screen before exiting. This overrides the standard message informing you to use &lt;code&gt;--continue&lt;/code&gt; or &lt;code&gt;--skip&lt;/code&gt; to handle the failure. This is solely for internal use between &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">当补丁失败时，&amp;lt;msg&amp;gt;将被打印到屏幕上，然后退出。这将覆盖标准消息，通知您使用 &lt;code&gt;--continue&lt;/code&gt; 或 &lt;code&gt;--skip&lt;/code&gt; 处理失败。这仅用于 &lt;code&gt;git rebase&lt;/code&gt; 和 &lt;code&gt;git am&lt;/code&gt; 之间的内部使用。</target>
        </trans-unit>
        <trans-unit id="d5b066fa036c4bb98c79472fbdf38de3d119f100" translate="yes" xml:space="preserve">
          <source>When a patch is part of an ongoing discussion, the patch generated by &lt;code&gt;git format-patch&lt;/code&gt; can be tweaked to take advantage of the &lt;code&gt;git am --scissors&lt;/code&gt; feature. After your response to the discussion comes a line that consists solely of &quot;&lt;code&gt;-- &amp;gt;8 --&lt;/code&gt;&quot; (scissors and perforation), followed by the patch with unnecessary header fields removed:</source>
          <target state="translated">当补丁是正在进行的讨论的一部分时，可以对 &lt;code&gt;git format-patch&lt;/code&gt; 生成的补丁进行调整，以利用 &lt;code&gt;git am --scissors&lt;/code&gt; 功能。在您对讨论的回答之后，出现了仅由&amp;ldquo; &lt;code&gt;-- &amp;gt;8 --&lt;/code&gt; &amp;rdquo;（剪刀和穿孔）组成的一行，其后是补丁，其中删除了不必要的标题字段：</target>
        </trans-unit>
        <trans-unit id="f3cb24e54c9837370739d06bd25b8c911a05ee6b" translate="yes" xml:space="preserve">
          <source>When a path is in the &quot;unmerged&quot; state, running &lt;code&gt;git update-index&lt;/code&gt; for that path tells Git to mark the path resolved.</source>
          <target state="translated">当路径处于&amp;ldquo;未合并&amp;rdquo;状态时，对该路径运行 &lt;code&gt;git update-index&lt;/code&gt; 会告诉Git标记已解析的路径。</target>
        </trans-unit>
        <trans-unit id="f8965008f9824bf8da0b033710c2d7ac1f3f6568" translate="yes" xml:space="preserve">
          <source>When a pure mode change is encountered (which has no index information), the information is read from the current index instead.</source>
          <target state="translated">当遇到纯模式变化时(没有索引信息),则从当前索引中读取信息代替。</target>
        </trans-unit>
        <trans-unit id="ef4651b07e5b8cb97cb93de85df1d7e556426d24" translate="yes" xml:space="preserve">
          <source>When a push mirror is created with &lt;code&gt;--mirror=push&lt;/code&gt;, then &lt;code&gt;git push&lt;/code&gt; will always behave as if &lt;code&gt;--mirror&lt;/code&gt; was passed.</source>
          <target state="translated">当使用 &lt;code&gt;--mirror=push&lt;/code&gt; 创建推送镜像时，则 &lt;code&gt;git push&lt;/code&gt; 将始终表现为 &lt;code&gt;--mirror&lt;/code&gt; 被传递。</target>
        </trans-unit>
        <trans-unit id="deb13d30f8ba66c920f6495f36b99921916b0fbc" translate="yes" xml:space="preserve">
          <source>When a rebase required merge conflicts to be resolved, compare the changes introduced by the rebase directly afterwards using:</source>
          <target state="translated">当一个rebase需要解决合并冲突时,使用以下方法直接比较rebase引入的变化。</target>
        </trans-unit>
        <trans-unit id="350766930233515327656bc7b70b13214a7aa33c" translate="yes" xml:space="preserve">
          <source>When a ref is updated, reflog entries are created to keep track of the reason why the ref was updated (which is typically the name of the high-level command that updated the ref), in addition to the old and new values of the ref. A scripted Porcelain command can use set_reflog_action helper function in &lt;code&gt;git-sh-setup&lt;/code&gt; to set its name to this variable when it is invoked as the top level command by the end user, to be recorded in the body of the reflog.</source>
          <target state="translated">更新参考时，除了参考的旧值和新值外，还将创建参考记录条目以跟踪更新参考的原因（通常是更新参考的高级命令的名称）。 。当最终用户将其作为顶层命令调用并记录在reflog的正文中时，脚本化的Porcelain命令可以在 &lt;code&gt;git-sh-setup&lt;/code&gt; 中使用set_reflog_action帮助函数将其名称设置为此变量。</target>
        </trans-unit>
        <trans-unit id="0a564cf0d83332d2cd6fd3ac884cec9942b078c7" translate="yes" xml:space="preserve">
          <source>When a repository is synchronized via &lt;code&gt;git push&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; objects packed in the source repository are usually stored unpacked in the destination. While this allows you to use different packing strategies on both ends, it also means you may need to repack both repositories every once in a while.</source>
          <target state="translated">当通过 &lt;code&gt;git push&lt;/code&gt; 和 &lt;code&gt;git pull&lt;/code&gt; 同步存储库时，打包在源存储库中的对象通常会解压缩存储在目标中。尽管这使您可以在两端使用不同的打包策略，但这也意味着您可能需要不时地重新打包两个存储库。</target>
        </trans-unit>
        <trans-unit id="89c3a76b400f69bc409951d41f44580e1ce5b550" translate="yes" xml:space="preserve">
          <source>When a scripting language specific quoting is in effect, everything between a top-level opening atom and its matching %(end) is evaluated according to the semantics of the opening atom and only its result from the top-level is quoted.</source>
          <target state="translated">当脚本语言特有的引号生效时,顶层开口原子与其匹配的%(end)之间的所有内容都会根据开口原子的语义进行评估,只有其来自顶层的结果才会被引用。</target>
        </trans-unit>
        <trans-unit id="1d0d6b410e7d083b396401fa9485dd3214d89132" translate="yes" xml:space="preserve">
          <source>When a variable is said to take a boolean value, many synonyms are accepted for &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;; these are all case-insensitive.</source>
          <target state="translated">当一个变量被认为是布尔值时，很多同义词都接受 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; ; 这些都不区分大小写。</target>
        </trans-unit>
        <trans-unit id="085e4eddfd9be8c4f3b576466769939a6475604e" translate="yes" xml:space="preserve">
          <source>When accepting a new code drop for a vendor branch, you probably want to record both the removal of paths and additions of new paths as well as modifications of existing paths.</source>
          <target state="translated">在接受厂商分支的新代码投放时,你可能既要记录路径的删除,也要记录新路径的添加以及现有路径的修改。</target>
        </trans-unit>
        <trans-unit id="98d4ec1ab85d43886cf359223c5c65ec41aa50b0" translate="yes" xml:space="preserve">
          <source>When accepting a signed push (see &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;), the signed push certificate is stored in a blob and an environment variable &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; can be consulted for its object name. See the description of &lt;code&gt;post-receive&lt;/code&gt; hook for an example. In addition, the certificate is verified using GPG and the result is exported with the following environment variables:</source>
          <target state="translated">接受签名的推送（请参阅&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;）时，签名的推送证书存储在Blob中，可以使用环境变量 &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; 来获取其对象名称。有关示例，请参见 &lt;code&gt;post-receive&lt;/code&gt; 挂钩的描述。此外，使用GPG验证证书，并使用以下环境变量导出结果：</target>
        </trans-unit>
        <trans-unit id="5d78f94855bee5654824b328b5c74fbbbf68d2ce" translate="yes" xml:space="preserve">
          <source>When acquiring credentials, consider the &quot;path&quot; component of an http or https URL to be important. Defaults to false. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">获取凭据时，请考虑http或https URL的&amp;ldquo;路径&amp;rdquo;部分很重要。默认为false。有关更多信息，请参见&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36125e3b1dadcf8415f427875bfbe6e3edb592ec" translate="yes" xml:space="preserve">
          <source>When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting).</source>
          <target state="translated">当向已经有注释的对象添加注释时,覆盖现有的注释(而不是中止)。</target>
        </trans-unit>
        <trans-unit id="31a6893d1f507cb4bce24b6631d6f67bbe0ca8c3" translate="yes" xml:space="preserve">
          <source>When advertising tips of available history from an alternate, use the shell to execute the specified command instead of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. The first argument is the absolute path of the alternate. Output must contain one hex object id per line (i.e., the same as produced by &lt;code&gt;git for-each-ref
--format='%(objectname)'&lt;/code&gt;).</source>
          <target state="translated">当通过备用广告发布可用历史的提示时，请使用Shell执行指定的命令，而不是&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt;。第一个参数是替代项的绝对路径。输出必须每行包含一个十六进制对象ID（即，与 &lt;code&gt;git for-each-ref --format='%(objectname)'&lt;/code&gt; 产生的ID相同）。</target>
        </trans-unit>
        <trans-unit id="aee562f05eaa47b0988f9365fa4403a675334ce1" translate="yes" xml:space="preserve">
          <source>When an argument can be misunderstood as either a revision or a path, they can be disambiguated by placing &lt;code&gt;--&lt;/code&gt; between them. E.g. &lt;code&gt;git diff -- HEAD&lt;/code&gt; is, &quot;I have a file called HEAD in my work tree. Please show changes between the version I staged in the index and what I have in the work tree for that file&quot;, not &quot;show difference between the HEAD commit and the work tree as a whole&quot;. You can say &lt;code&gt;git diff HEAD --&lt;/code&gt; to ask for the latter.</source>
          <target state="translated">当一个参数可以被误解为一个修订版或路径，它们可以通过将被消除歧义 &lt;code&gt;--&lt;/code&gt; 在它们之间。例如 &lt;code&gt;git diff -- HEAD&lt;/code&gt; 是，&amp;ldquo;我的工作树中有一个名为HEAD的文件。请显示在索引中暂存的版本与该文件的工作树中的版本之间的更改&amp;rdquo;，而不是&amp;ldquo;显示HEAD commit和整个工作树&amp;rdquo;。您可以说 &lt;code&gt;git diff HEAD --&lt;/code&gt; 要求后者。</target>
        </trans-unit>
        <trans-unit id="8ed1e316e9f06aa8f0fbb451acc5e5dd1d53d618" translate="yes" xml:space="preserve">
          <source>When an argument may be understood either as a reference or as a file name, choose to understand it as a format-patch argument (&lt;code&gt;--format-patch&lt;/code&gt;) or as a file name (&lt;code&gt;--no-format-patch&lt;/code&gt;). By default, when such a conflict occurs, git send-email will fail.</source>
          <target state="translated">当参数可以被理解为引用或文件名时，请选择将其理解为格式补丁参数（ &lt;code&gt;--format-patch&lt;/code&gt; ）或文件名（ &lt;code&gt;--no-format-patch&lt;/code&gt; ）。默认情况下，发生此类冲突时，git send-email将失败。</target>
        </trans-unit>
        <trans-unit id="daa45faaafc93f57dcfa6219226fd8a2224c7353" translate="yes" xml:space="preserve">
          <source>When an interactive command (such as &lt;code&gt;git add --patch&lt;/code&gt;) shows a colorized diff, git will pipe the diff through the shell command defined by this configuration variable. The command may mark up the diff further for human consumption, provided that it retains a one-to-one correspondence with the lines in the original diff. Defaults to disabled (no filtering).</source>
          <target state="translated">当交互式命令（例如 &lt;code&gt;git add --patch&lt;/code&gt; ）显示彩色的差异时，git将通过此配置变量定义的shell命令通过管道传递差异。该命令可以进一步标记差异以供人类使用，前提是该命令与原始差异中的行保持一一对应的关系。默认为禁用（不过滤）。</target>
        </trans-unit>
        <trans-unit id="66bd09d84d7f728fe64b22afe9c1d5b02faccf2f" translate="yes" xml:space="preserve">
          <source>When an optional Git branch name (or a Git commit object name) is specified as an argument, the subcommand works on the specified branch, not on the current branch.</source>
          <target state="translated">当指定一个可选的 Git 分支名(或 Git 提交对象名)作为参数时,子命令会在指定的分支上工作,而不是在当前分支上工作。</target>
        </trans-unit>
        <trans-unit id="54600ca959ccb5286a6125f852754e8a441f6246" translate="yes" xml:space="preserve">
          <source>When an update changes a branch (or more in general, a ref) that used to point at commit A to point at another commit B, it is called a fast-forward update if and only if B is a descendant of A.</source>
          <target state="translated">当一个更新将过去指向提交A的分支(或者更笼统地说,是一个ref)改变为指向另一个提交B的分支时,如果且仅当B是A的后裔时,它被称为快进更新。</target>
        </trans-unit>
        <trans-unit id="b999dfcfa57d71ee62dbc42f4d8a0527e63491d1" translate="yes" xml:space="preserve">
          <source>When applying a patch, detect a new or modified line that has whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that solely consist of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors.</source>
          <target state="translated">应用补丁程序时，请检测出现空白错误的新行或修改行。哪些空白错误由 &lt;code&gt;core.whitespace&lt;/code&gt; 配置控制。默认情况下，尾随空格（包括仅由空格组成的行）和在行的初始缩进内紧随其后是制表符的空格字符都被视为空格错误。</target>
        </trans-unit>
        <trans-unit id="b3581e25b4edfc3eae85f688560f931e31414d31" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore additions made by the patch. This can be used to extract the common part between two files by first running &lt;code&gt;diff&lt;/code&gt; on them and applying the result with this option, which would apply the deletion part but not the addition part.</source>
          <target state="translated">应用补丁程序时，请忽略补丁程序添加的内容。可以通过首先在两个文件上运行 &lt;code&gt;diff&lt;/code&gt; 并使用此选项应用结果来提取两个文件之间的公共部分，这将应用删除部分，而不应用加法部分。</target>
        </trans-unit>
        <trans-unit id="6bf2c606b0bf760a50dfcc2e9e2a1dfc6d6ce1b9" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore changes in whitespace in context lines if necessary. Context lines will preserve their whitespace, and they will not undergo whitespace fixing regardless of the value of the &lt;code&gt;--whitespace&lt;/code&gt; option. New lines will still be fixed, though.</source>
          <target state="translated">应用补丁程序时，如有必要，请忽略上下文行中空格的更改。上下文行将保留其空格，并且无论 &lt;code&gt;--whitespace&lt;/code&gt; 选项的值如何，它们都不会进行空格固定。不过，新行仍将固定。</target>
        </trans-unit>
        <trans-unit id="588f408b6e1e0374e87fb8fe5ff6e5cd0dca42b8" translate="yes" xml:space="preserve">
          <source>When applying the patch only to the working tree, mark new files to be added to the index later (see &lt;code&gt;--intent-to-add&lt;/code&gt; option in &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;). This option is ignored unless running in a Git repository and &lt;code&gt;--index&lt;/code&gt; is not specified. Note that &lt;code&gt;--index&lt;/code&gt; could be implied by other options such as &lt;code&gt;--cached&lt;/code&gt; or &lt;code&gt;--3way&lt;/code&gt;.</source>
          <target state="translated">当仅将补丁应用到工作树时，请标记以后要添加到索引的新文件（请参阅&lt;a href=&quot;git-add&quot;&gt;git-add [1]中的&lt;/a&gt; &lt;code&gt;--intent-to-add&lt;/code&gt; 选项）。除非在Git存储库中运行并且未指定 &lt;code&gt;--index&lt;/code&gt; ,否则将忽略此选项。请注意，-- &lt;code&gt;--index&lt;/code&gt; 可能由 &lt;code&gt;--cached&lt;/code&gt; 或 &lt;code&gt;--3way&lt;/code&gt; 等其他选项隐含。</target>
        </trans-unit>
        <trans-unit id="59fa333bf5332a3a74a0fa1b62097787ae41682d" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering a signed tag. With &lt;code&gt;strip&lt;/code&gt;, the tags will silently be made unsigned, with &lt;code&gt;warn-strip&lt;/code&gt; they will be made unsigned but a warning will be displayed, with &lt;code&gt;verbatim&lt;/code&gt;, they will be silently exported and with &lt;code&gt;warn&lt;/code&gt;, they will be exported, but you will see a warning.</source>
          <target state="translated">当要求 &lt;code&gt;abort&lt;/code&gt; （默认设置）时，该程序将在遇到签名标签时死亡。使用 &lt;code&gt;strip&lt;/code&gt; ，标签将被静默地设置为无符号，使用 &lt;code&gt;warn-strip&lt;/code&gt; ,它们将被设置为无符号，但是将显示警告，使用 &lt;code&gt;verbatim&lt;/code&gt; 显示，它们将被静默导出，使用 &lt;code&gt;warn&lt;/code&gt; ，将被导出，但是您将看到一个警告。 。</target>
        </trans-unit>
        <trans-unit id="a094fa226ab8da9ad05df22ffe9e8c64cbd9aea9" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering such a tag. With &lt;code&gt;drop&lt;/code&gt; it will omit such tags from the output. With &lt;code&gt;rewrite&lt;/code&gt;, if the tagged object is a commit, it will rewrite the tag to tag an ancestor commit (via parent rewriting; see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;)</source>
          <target state="translated">当要求 &lt;code&gt;abort&lt;/code&gt; （这是默认设置）时，该程序将在遇到此类标签​​时死亡。使用 &lt;code&gt;drop&lt;/code&gt; 时，将从输出中省略此类标签。使用 &lt;code&gt;rewrite&lt;/code&gt; ，如果标记的对象是提交，它将重写标签以标记祖先提交（通过父级重写；请参见&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="034f3e54dc418fd0aaba391926e4cdc6f9338cc5" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;--incremental&lt;/code&gt; option, the command outputs the result as it is built. The output generally will talk about lines touched by more recent commits first (i.e. the lines will be annotated out of order) and is meant to be used by interactive viewers.</source>
          <target state="translated">当使用 &lt;code&gt;--incremental&lt;/code&gt; 选项调用时，命令将在生成结果时输出结果。通常，输出将首先讨论较新的提交所触及的行（即，行将被无序注释），并打算由交互式查看器使用。</target>
        </trans-unit>
        <trans-unit id="37ed40c0b9c191bc52be1eea56e95c21c8c30c92" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, check out stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">从索引中检出路径时，请检出第2阶段（ &lt;code&gt;ours&lt;/code&gt; ）或第3阶段（ &lt;code&gt;theirs&lt;/code&gt; ）的未合并路径。</target>
        </trans-unit>
        <trans-unit id="b2d7eb083886da1526ca38a6780f9e98825df5e6" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.</source>
          <target state="translated">当从索引中检查路径时,不要在未合并的条目时失败,而是忽略未合并的条目。</target>
        </trans-unit>
        <trans-unit id="87b021689017efd0b4fbe642f48fde6408f7cde4" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths.</source>
          <target state="translated">当从索引中检查出路径时,这个选项可以让你在指定的路径中重新创建冲突的合并。</target>
        </trans-unit>
        <trans-unit id="44968c91f62b2f1c7eb77848556b128eac9d4512" translate="yes" xml:space="preserve">
          <source>When cloning an SVN repository, if none of the options for describing the repository layout is used (--trunk, --tags, --branches, --stdlayout), &lt;code&gt;git svn clone&lt;/code&gt; will create a Git repository with completely linear history, where branches and tags appear as separate directories in the working copy. While this is the easiest way to get a copy of a complete repository, for projects with many branches it will lead to a working copy many times larger than just the trunk. Thus for projects using the standard directory structure (trunk/branches/tags), it is recommended to clone with option &lt;code&gt;--stdlayout&lt;/code&gt;. If the project uses a non-standard structure, and/or if branches and tags are not required, it is easiest to only clone one directory (typically trunk), without giving any repository layout options. If the full history with branches and tags is required, the options &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; must be used.</source>
          <target state="translated">克隆SVN储存库时，如果不使用任何描述储存库布局的选项（--trunk，-tags，-branches，-stdlayout），则 &lt;code&gt;git svn clone&lt;/code&gt; 将创建具有完全线性历史记录的Git储存库，其中分支和标签在工作副本中显示为单独的目录。尽管这是获得完整存储库副本的最简单方法，但是对于具有许多分支的项目，这将导致其工作副本比主干大许多倍。因此，对于使用标准目录结构（trunk / branches / tags）的项目，建议使用 &lt;code&gt;--stdlayout&lt;/code&gt; 选项进行克隆。如果项目使用非标准结构，并且/或者如果不需要分支和标记，则最简单的方法是仅克隆一个目录（通常是主干），而不提供任何存储库布局选项。如果需要用树枝和标签的全部历史，选项 &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; 必须使用。</target>
        </trans-unit>
        <trans-unit id="cf5bdc8ee9de0e891bd2e2ffd6ad5374a27fb398" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; You can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules.</source>
          <target state="translated">克隆或提取包含子模块的存储库时，默认情况下不会检出子模块；您可以指示 &lt;code&gt;clone&lt;/code&gt; 递归到子模块中。 &lt;code&gt;git submodule&lt;/code&gt; 的 &lt;code&gt;init&lt;/code&gt; 和 &lt;code&gt;update&lt;/code&gt; 子命令将维护已检出的子模块，并在您的工作树中对其进行适当的修订。另外，您可以设置 &lt;code&gt;submodule.recurse&lt;/code&gt; 以使 &lt;code&gt;checkout&lt;/code&gt; 递归到子模块中。</target>
        </trans-unit>
        <trans-unit id="2bdda0ba49ff183f8b76fb42fb3146b89e404d42" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; you can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules (note that &lt;code&gt;submodule.recurse&lt;/code&gt; also affects other Git commands, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a complete list).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96f700dec6ecf67635f001fe97af20a3a1af7ba" translate="yes" xml:space="preserve">
          <source>When combining multiple &lt;code&gt;--contains&lt;/code&gt; and &lt;code&gt;--no-contains&lt;/code&gt; filters, only references that contain at least one of the &lt;code&gt;--contains&lt;/code&gt; commits and contain none of the &lt;code&gt;--no-contains&lt;/code&gt; commits are shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3693ecef45adf0e594fc21eeb7dc1180a98b303e" translate="yes" xml:space="preserve">
          <source>When combining multiple &lt;code&gt;--merged&lt;/code&gt; and &lt;code&gt;--no-merged&lt;/code&gt; filters, only references that are reachable from at least one of the &lt;code&gt;--merged&lt;/code&gt; commits and from none of the &lt;code&gt;--no-merged&lt;/code&gt; commits are shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f5e261fa8e1325a05e77f0fa02cd4e804a016b" translate="yes" xml:space="preserve">
          <source>When committing fixups, consider using &lt;code&gt;merge&lt;/code&gt; to connect the commit(s) which are supplying file revisions to the fixup branch. Doing so will allow tools such as &lt;code&gt;git blame&lt;/code&gt; to track through the real commit history and properly annotate the source files.</source>
          <target state="translated">提交修订时，请考虑使用 &lt;code&gt;merge&lt;/code&gt; 将提供文件修订的提交连接到fixup分支。这样做将允许诸如 &lt;code&gt;git blame&lt;/code&gt; 之类的工具跟踪真实的提交历史记录并正确注释源文件。</target>
        </trans-unit>
        <trans-unit id="187746ad8497cb1dac2dfe493269450955422d85" translate="yes" xml:space="preserve">
          <source>When committing to svn from Git (as part of &lt;code&gt;set-tree&lt;/code&gt; or &lt;code&gt;dcommit&lt;/code&gt; operations), if the existing log message doesn&amp;rsquo;t already have a &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line, append a &lt;code&gt;From:&lt;/code&gt; line based on the Git commit&amp;rsquo;s author string. If you use this, then &lt;code&gt;--use-log-author&lt;/code&gt; will retrieve a valid author string for all commits.</source>
          <target state="translated">从Git提交svn时（作为 &lt;code&gt;set-tree&lt;/code&gt; 或 &lt;code&gt;dcommit&lt;/code&gt; 操作的一部分），如果现有日志消息中尚没有 &lt;code&gt;From:&lt;/code&gt; 或 &lt;code&gt;Signed-off-by:&lt;/code&gt; 行，请根据Git提交的内容附加 &lt;code&gt;From:&lt;/code&gt; 行作者字符串。如果使用此选项，则 &lt;code&gt;--use-log-author&lt;/code&gt; 将为所有提交检索有效的作者字符串。</target>
        </trans-unit>
        <trans-unit id="df4d9e8de337675930b7c7d126c3cbfdb0d919e8" translate="yes" xml:space="preserve">
          <source>When common porcelain operations that create objects are run, they will check whether the repository has grown substantially since the last maintenance, and if so run &lt;code&gt;git gc&lt;/code&gt; automatically. See &lt;code&gt;gc.auto&lt;/code&gt; below for how to disable this behavior.</source>
          <target state="translated">当运行创建对象的常用瓷器操作时，它们将检查自上次维护以来存储库是否已显着增长，如果是，则自动运行 &lt;code&gt;git gc&lt;/code&gt; 。有关如何禁用此行为的信息，请参见下面的 &lt;code&gt;gc.auto&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cef5cc19d56f034a0850f6ce0dc6add0c966a70" translate="yes" xml:space="preserve">
          <source>When comparing two trees, the ID of both trees (separated by a space and terminated by a newline) is printed before the difference. When comparing commits, the ID of the first (or only) commit, followed by a newline, is printed.</source>
          <target state="translated">当比较两棵树时,在差异之前打印两棵树的ID(用空格隔开,用换行结束)。当比较提交时,打印第一个(或唯一的)提交的ID,后面加一个换行。</target>
        </trans-unit>
        <trans-unit id="fe249445673b1134855083e0c3b366c4aeeb2c8e" translate="yes" xml:space="preserve">
          <source>When converting a value to its canonical form using the &lt;code&gt;--type=bool&lt;/code&gt; type specifier, &lt;code&gt;git config&lt;/code&gt; will ensure that the output is &quot;true&quot; or &quot;false&quot; (spelled in lowercase).</source>
          <target state="translated">使用 &lt;code&gt;--type=bool&lt;/code&gt; 类型说明符将值转换为规范形式时， &lt;code&gt;git config&lt;/code&gt; 将确保输出为&amp;ldquo; true&amp;rdquo;或&amp;ldquo; false&amp;rdquo;（拼写为小写）。</target>
        </trans-unit>
        <trans-unit id="5800d8777d6f116b967a3c4b503079e04a8dd27b" translate="yes" xml:space="preserve">
          <source>When copying a remote repository, you&amp;rsquo;ll want to at a minimum update the index cache when you do this, and especially with other peoples' repositories you often want to make sure that the index cache is in some known state (you don&amp;rsquo;t know &lt;strong&gt;what&lt;/strong&gt; they&amp;rsquo;ve done and not yet checked in), so usually you&amp;rsquo;ll precede the &lt;code&gt;git update-index&lt;/code&gt; with a</source>
          <target state="translated">复制远程存储库时，您至少需要在执行此操作时更新索引缓存，尤其是在其他人的存储库中，通常需要确保索引缓存处于某种已知状态（您不希望这样做）。知道&lt;strong&gt;什么&lt;/strong&gt;他们做了，并没有检查），所以通常你会在之前 &lt;code&gt;git update-index&lt;/code&gt; 用</target>
        </trans-unit>
        <trans-unit id="a0c9c076efebd050282e8220820bf37e469a5914" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite (see the &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; option), determines what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">在重写过程中复制笔记时（请参阅&amp;ldquo; notes.rewrite。&amp;lt;command&amp;gt;&amp;rdquo;选项），确定目标提交已包含笔记时该怎么做。必须是 &lt;code&gt;overwrite&lt;/code&gt; ， &lt;code&gt;concatenate&lt;/code&gt; ， &lt;code&gt;cat_sort_uniq&lt;/code&gt; 或 &lt;code&gt;ignore&lt;/code&gt; 之一。默认为 &lt;code&gt;concatenate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2daf889c63a8ae3ef0bd84b9e0a7bae3186ea5d" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. May be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">在重写过程中复制注释时,指定应该复制其注释的(完全限定的)ref。可能是一个 glob,在这种情况下,所有匹配的 refs 中的注释都会被复制。您也可以多次指定这个配置。</target>
        </trans-unit>
        <trans-unit id="c445d369a5c50740a59f3ad28697ace644e2811e" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. The ref may be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">在重写过程中复制笔记时,指定应该复制其笔记的(完全限定的)ref。ref可能是一个glob,在这种情况下,所有匹配的ref中的注释都会被复制。您也可以多次指定这个配置。</target>
        </trans-unit>
        <trans-unit id="1243aaab79ff33e7a2d49c8eb8b4f16703a1c016" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">在重写过程中复制笔记时，如果目标提交已包含笔记该怎么办。必须是 &lt;code&gt;overwrite&lt;/code&gt; ， &lt;code&gt;concatenate&lt;/code&gt; ， &lt;code&gt;cat_sort_uniq&lt;/code&gt; 或 &lt;code&gt;ignore&lt;/code&gt; 之一。默认为 &lt;code&gt;concatenate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb6ea94e62e06bb5ee870300111df0d9f630f320" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. This overrides the &lt;code&gt;core.rewriteMode&lt;/code&gt; setting.</source>
          <target state="translated">在重写过程中复制笔记时，如果目标提交已包含笔记该怎么办。必须是 &lt;code&gt;overwrite&lt;/code&gt; ， &lt;code&gt;concatenate&lt;/code&gt; ， &lt;code&gt;cat_sort_uniq&lt;/code&gt; 或 &lt;code&gt;ignore&lt;/code&gt; 之一。这将覆盖 &lt;code&gt;core.rewriteMode&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="fa7e030aba2e9a9a4e5882753f19d2b4a66b4e16" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">创建新分支时，如果 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 是分支，则将其标记为新分支的&amp;ldquo;上游&amp;rdquo;。如果 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 是远程跟踪分支，则为默认设置。有关详细信息，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]中的&lt;/a&gt; &amp;ldquo; --track&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="4e04dc75cba18b40521f918d2128a9cc7f50298f" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d8049451fa958ada38921d90347d3ee7c4d771" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. &lt;code&gt;-c&lt;/code&gt; is implied. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">创建新分支时，请设置&amp;ldquo;上游&amp;rdquo;配置。 &lt;code&gt;-c&lt;/code&gt; 是隐含的。有关详细 &lt;code&gt;--track&lt;/code&gt; ，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]中的&lt;/a&gt;--track。</target>
        </trans-unit>
        <trans-unit id="fc590aa31fec73c4296b9f428640a84b6d3e91a7" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">创建新分支时，请设置&amp;ldquo;上游&amp;rdquo;配置。有关详细信息，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]中的&lt;/a&gt; &amp;ldquo; --track&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="67211ea9327a11f7c102d4d6622e44707e57316e" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries to mark the start-point branch as &quot;upstream&quot; from the new branch. This configuration will tell git to show the relationship between the two branches in &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git branch -v&lt;/code&gt;. Furthermore, it directs &lt;code&gt;git pull&lt;/code&gt; without arguments to pull from the upstream when the new branch is checked out.</source>
          <target state="translated">创建新分支时，请设置 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 和 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 配置条目，以将起点分支标记为新分支的&amp;ldquo;上游&amp;rdquo;。此配置将告诉git显示处于 &lt;code&gt;git status&lt;/code&gt; 和 &lt;code&gt;git branch -v&lt;/code&gt; 的两个分支之间的关系。此外，它指示不带参数的 &lt;code&gt;git pull&lt;/code&gt; 在签出新分支时从上游拉出。</target>
        </trans-unit>
        <trans-unit id="30421c6d8900807173aa121649f943a72b9b4dbe" translate="yes" xml:space="preserve">
          <source>When creating a packed archive in a repository that has existing packs, the command reuses existing deltas. This sometimes results in a slightly suboptimal pack. This flag tells the command not to reuse existing deltas but compute them from scratch.</source>
          <target state="translated">当在有现有包的仓库中创建打包后的存档时,该命令会重复使用现有的 deltas。这有时会导致一个略微次优的包。这个标志告诉命令不要重复使用现有的三角区,而是从头开始计算。</target>
        </trans-unit>
        <trans-unit id="40641904740525d3a46d2f53ea1f042429403d62" translate="yes" xml:space="preserve">
          <source>When creating files, prepend &amp;lt;string&amp;gt; (usually a directory including a trailing /)</source>
          <target state="translated">创建文件时，请在&amp;lt;string&amp;gt;之前添加前缀（通常是包含尾随/的目录）</target>
        </trans-unit>
        <trans-unit id="55d2573d14b31c180f96244b6210a62251fe4b79" translate="yes" xml:space="preserve">
          <source>When dealing with &lt;code&gt;git diff-tree&lt;/code&gt; output, it takes advantage of the fact that the patch is prefixed with the object name of the commit, and outputs two 40-byte hexadecimal strings. The first string is the patch ID, and the second string is the commit ID. This can be used to make a mapping from patch ID to commit ID.</source>
          <target state="translated">处理 &lt;code&gt;git diff-tree&lt;/code&gt; 输出时，它利用了补丁以提交对象名称为前缀的事实，并输出两个40字节的十六进制字符串。第一个字符串是补丁ID，第二个字符串是提交ID。这可用于从补丁程序ID到提交ID的映射。</target>
        </trans-unit>
        <trans-unit id="d776ef3252048cd13183a8501d7c0015731386cd" translate="yes" xml:space="preserve">
          <source>When deciding what attributes are assigned to a path, Git consults &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file (which has the highest precedence), &lt;code&gt;.gitattributes&lt;/code&gt; file in the same directory as the path in question, and its parent directories up to the toplevel of the work tree (the further the directory that contains &lt;code&gt;.gitattributes&lt;/code&gt; is from the path in question, the lower its precedence). Finally global and system-wide files are considered (they have the lowest precedence).</source>
          <target state="translated">在确定将哪些属性分配给路径时，Git会参考 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 文件（优先级最高） &lt;code&gt;.gitattributes&lt;/code&gt; 文件与所讨论路径位于同一目录中，以及其父目录直至该目录的顶层。工作树（包含 &lt;code&gt;.gitattributes&lt;/code&gt; 的目录距离所讨论的路径越远，其优先级越低）。最后，考虑全局文件和系统范围的文件（它们的优先级最低）。</target>
        </trans-unit>
        <trans-unit id="be47e73cae5925c270f0353e0b448f44fba38688" translate="yes" xml:space="preserve">
          <source>When deinitialized or deleted (see below), the submodule&amp;rsquo;s Git directory is automatically moved to &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; of the superproject.</source>
          <target state="translated">当 &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; 或删除时（参见下文），子模块的Git目录将自动移至超级项目的$ GIT_DIR / modules / &amp;lt;name&amp;gt; /中。</target>
        </trans-unit>
        <trans-unit id="d6198e5c096df70165a4ba7282b14c9062838d85" translate="yes" xml:space="preserve">
          <source>When displaying names of reachable objects, in addition to the SHA-1 also display a name that describes &lt;strong&gt;how&lt;/strong&gt; they are reachable, compatible with &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;, e.g. &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt;.</source>
          <target state="translated">当显示可到达对象的名称时，除了SHA-1之外，还会显示描述它们&lt;strong&gt;如何&lt;/strong&gt;可到达的名称，与&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt;兼容，例如 &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39ccc422d97039f55d5b75b982904e65809f0ab0" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in a porcelain-ready format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">在进行空运行时，以瓷器就绪格式提供输出。有关详细信息，请参见&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;。意味着 &lt;code&gt;--dry-run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91fdf83cd4cf2351c13b94fc0d59dcd9a51c5b73" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the long-format. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">空试时，以长格式提供输出。意味着 &lt;code&gt;--dry-run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7320eee3c7f6d76666dfe697952518d827846a03" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the short-format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">空试时，以短格式给出输出。有关详细信息，请参见&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;。意味着 &lt;code&gt;--dry-run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9aa102d4a4b04252e6d4b5a0080dce309ef777d4" translate="yes" xml:space="preserve">
          <source>When doing a repository conversion, use a unique mark per commit (&lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt;) and supply the --export-marks option on the command line. fast-import will dump a file which lists every mark and the Git object SHA-1 that corresponds to it. If the frontend can tie the marks back to the source repository, it is easy to verify the accuracy and completeness of the import by comparing each Git commit to the corresponding source revision.</source>
          <target state="translated">在进行存储库转换时，每次提交使用唯一标记（ &lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt; ），并在命令行上提供--export-marks选项。快速导入将转储一个文件，其中列出了每个标记以及与之对应的Git对象SHA-1。如果前端可以将标记重新绑定到源存储库，则可以通过将每个Git提交与相应的源修订版本进行比较，轻松地验证导入的准确性和完整性。</target>
        </trans-unit>
        <trans-unit id="6f397bf185a0b1be7403f8c718221517e54d79b2" translate="yes" xml:space="preserve">
          <source>When editing the commit message, start the editor with the contents in the given file. The &lt;code&gt;commit.template&lt;/code&gt; configuration variable is often used to give this option implicitly to the command. This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order. If the user exits the editor without editing the message, the commit is aborted. This has no effect when a message is given by other means, e.g. with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; options.</source>
          <target state="translated">编辑提交消息时，请使用给定文件中的内容启动编辑器。所述 &lt;code&gt;commit.template&lt;/code&gt; 配置变量经常被用于隐含地给这个选项添加到命令。此机制可用于希望引导参与者以什么顺序在消息中写些什么的项目。如果用户退出编辑器而不编辑消息，则提交将中止。当通过其他方式（例如，使用 &lt;code&gt;-m&lt;/code&gt; 或 &lt;code&gt;-F&lt;/code&gt; 选项）给出消息时，这无效。</target>
        </trans-unit>
        <trans-unit id="7835173f74e58e15c8891f5a3e0b3af743fd1c66" translate="yes" xml:space="preserve">
          <source>When editing, provide the raw object contents rather than pretty-printed ones. Currently this only affects trees, which will be shown in their binary form. This is harder to work with, but can help when repairing a tree that is so corrupted it cannot be pretty-printed. Note that you may need to configure your editor to cleanly read and write binary data.</source>
          <target state="translated">当编辑时,提供原始对象内容,而不是漂亮的打印内容。目前这只影响树,树将以二进制形式显示。这是比较难处理的,但在修复一棵被破坏得无法以漂亮打印的树时,会有帮助。请注意,你可能需要配置你的编辑器来清洁地读写二进制数据。</target>
        </trans-unit>
        <trans-unit id="ce47e94310de9fcb0d82c1f052bbcc38f3a11f76" translate="yes" xml:space="preserve">
          <source>When enabled, the default &lt;code&gt;post-update&lt;/code&gt; hook runs &lt;code&gt;git update-server-info&lt;/code&gt; to keep the information used by dumb transports (e.g., HTTP) up to date. If you are publishing a Git repository that is accessible via HTTP, you should probably enable this hook.</source>
          <target state="translated">启用后，默认 &lt;code&gt;post-update&lt;/code&gt; 挂钩将运行 &lt;code&gt;git update-server-info&lt;/code&gt; ,以使哑传输（例如HTTP）使用的信息保持最新。如果要发布可通过HTTP访问的Git存储库，则可能应启用此挂钩。</target>
        </trans-unit>
        <trans-unit id="a529b1482d7666548417edb1d901df1240194350" translate="yes" xml:space="preserve">
          <source>When encountering a non-ASCII message or subject that does not declare its encoding, add headers/quoting to indicate it is encoded in &amp;lt;encoding&amp;gt;. Default is the value of the &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt;; if that is unspecified, this will be prompted for if any non-ASCII files are encountered.</source>
          <target state="translated">遇到未声明其编码的非ASCII消息或主题时，请添加标头/引号以指示其已在&amp;lt;encoding&amp;gt;中进行编码。默认值为 &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt; 的值；如果未指定，则将提示您是否遇到任何非ASCII文件。</target>
        </trans-unit>
        <trans-unit id="c331bd8bb74634e4f18684aaa53f36ba8f8cf37d" translate="yes" xml:space="preserve">
          <source>When erasing credentials, matching credentials will be erased from all files.</source>
          <target state="translated">擦除凭证时,匹配的凭证将从所有文件中擦除。</target>
        </trans-unit>
        <trans-unit id="74e58a3904b06fc63c005d33dc33b553098868b7" translate="yes" xml:space="preserve">
          <source>When extensions.worktreeConfig is enabled, the config file &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; is read after &lt;code&gt;.git/config&lt;/code&gt; is.</source>
          <target state="translated">启用extensions.worktreeConfig后，将在 &lt;code&gt;.git/config&lt;/code&gt; 之后读取配置文件 &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a73371934954e7de3c00c5b21339d1552e97b06" translate="yes" xml:space="preserve">
          <source>When false, merge the current branch into the upstream branch.</source>
          <target state="translated">当为假时,将当前分支合并到上游分支。</target>
        </trans-unit>
        <trans-unit id="d5dfb7a500ca38e6f311c3fe54f4fbaf71bc47ce" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. Providing an empty &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; to the &lt;code&gt;--refmap&lt;/code&gt; option causes Git to ignore the configured refspecs and rely entirely on the refspecs supplied as command-line arguments. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8afe72df4116adf55dd615031acfafbceae0ec5" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="translated">当获取命令行上列出的引用时，请使用指定的refspec（可以多次提供）将引用映射到远程跟踪分支，而不是远程存储库的 &lt;code&gt;remote.*.fetch&lt;/code&gt; 配置变量的值。有关详细信息，请参见&amp;ldquo;配置的远程跟踪分支&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="f131c02a4584603f0de6ca46a404ddf3258dbf13" translate="yes" xml:space="preserve">
          <source>When files are modified outside of Git, the user will need to stage the modified files explicitly (e.g. see &lt;code&gt;Examples&lt;/code&gt; section in &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;). Git will not normally detect changes to those files.</source>
          <target state="translated">在Git之外修改文件时，用户将需要显式地登台修改过的文件（例如，参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]中的&amp;ldquo; &lt;/a&gt; &lt;code&gt;Examples&lt;/code&gt; 部分）。Git通常不会检测到这些文件的更改。</target>
        </trans-unit>
        <trans-unit id="e95f7718835508fa2f714691dae7615b5ccee03a" translate="yes" xml:space="preserve">
          <source>When filtering history with &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt;, does not prune some history. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">当过滤历史 &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt; ，不修剪一些历史。（有关详细说明，请参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;中的&amp;ldquo;历史记录简化&amp;rdquo; 。）</target>
        </trans-unit>
        <trans-unit id="18f94df4064f0faddb37415d13a088dd57356563" translate="yes" xml:space="preserve">
          <source>When first created, objects are stored in individual files, but for efficiency may later be compressed together into &quot;pack files&quot;.</source>
          <target state="translated">当第一次创建时,对象被存储在单独的文件中,但为了提高效率,以后可能会被压缩在一起成为 &quot;打包文件&quot;。</target>
        </trans-unit>
        <trans-unit id="3ce1186a221491da0c957498f84e962314b0f4f4" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;.</source>
          <target state="translated">给定要显示的提交范围（例如 &lt;code&gt;commit1..commit2&lt;/code&gt; 或 &lt;code&gt;commit2 ^commit1&lt;/code&gt; ）时，仅显示直接存在于 &lt;code&gt;commit1&lt;/code&gt; 和 &lt;code&gt;commit2&lt;/code&gt; 之间的祖先链上的提交，即既是 &lt;code&gt;commit1&lt;/code&gt; 的后代又是commit2的后代的 &lt;code&gt;commit2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e006844e32fc3d063be827d3911798e9ae2b69bd" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">给定要显示的提交范围（例如 &lt;code&gt;commit1..commit2&lt;/code&gt; 或 &lt;code&gt;commit2 ^commit1&lt;/code&gt; ）时，仅显示直接存在于 &lt;code&gt;commit1&lt;/code&gt; 和 &lt;code&gt;commit2&lt;/code&gt; 之间的祖先链上的提交，即既是 &lt;code&gt;commit1&lt;/code&gt; 的后代又是commit2的祖先的 &lt;code&gt;commit2&lt;/code&gt; 。 （有关详细说明，请参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;中的&amp;ldquo;历史记录简化&amp;rdquo; 。）</target>
        </trans-unit>
        <trans-unit id="8281565ed0f01821dd04f5b4f8a282147fc8eb15" translate="yes" xml:space="preserve">
          <source>When given a two-part name section.key, the value for section.&amp;lt;url&amp;gt;.key whose &amp;lt;url&amp;gt; part matches the best to the given URL is returned (if no such key exists, the value for section.key is used as a fallback). When given just the section as name, do so for all the keys in the section and list them. Returns error code 1 if no value is found.</source>
          <target state="translated">当给定一个由两部分组成的名称section.key时，将返回其&amp;lt;url&amp;gt;部分与给定URL最匹配的section。&amp;lt;url&amp;gt; .key的值（如果不存在这样的密钥，则使用section.key的值作为备用）。如果仅以该部分的名称作为名称，请对该部分中的所有键进行命名并列出它们。如果找不到值，则返回错误代码1。</target>
        </trans-unit>
        <trans-unit id="f88bacf945cb9e0553c03a8ac1d906d306ca24eb" translate="yes" xml:space="preserve">
          <source>When given an SVN revision number of the form &lt;code&gt;rN&lt;/code&gt;, returns the corresponding Git commit hash (this can optionally be followed by a tree-ish to specify which branch should be searched). When given a tree-ish, returns the corresponding SVN revision number.</source>
          <target state="translated">当给定SVN版本号为 &lt;code&gt;rN&lt;/code&gt; 时，返回相应的Git commit哈希值（可以选择后面跟一个树状语句来指定应该搜索哪个分支）。给定树状结构时，返回相应的SVN版本号。</target>
        </trans-unit>
        <trans-unit id="a96423d691859ec79cd98b29f7765677feb267ba" translate="yes" xml:space="preserve">
          <source>When given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end.</source>
          <target state="translated">当给定,并且要克隆的仓库是通过ssh访问时,这将为另一端运行的命令指定一个非默认路径。</target>
        </trans-unit>
        <trans-unit id="d1fb59a7ba9cbb456b044d488d1684f86345d108" translate="yes" xml:space="preserve">
          <source>When given, and the repository to fetch from is handled by &lt;code&gt;git fetch-pack&lt;/code&gt;, &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; is passed to the command to specify non-default path for the command run on the other end.</source>
          <target state="translated">如果给定了信息，并且要从中获取信息的存储库由 &lt;code&gt;git fetch-pack&lt;/code&gt; 处理，则 &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; 会传递给命令，以为另一端运行的命令指定非默认路径。</target>
        </trans-unit>
        <trans-unit id="347806ba4d643d64e35fb6159f6ca9df9bd36627" translate="yes" xml:space="preserve">
          <source>When giving multiple pattern expressions combined with &lt;code&gt;--or&lt;/code&gt;, this flag is specified to limit the match to files that have lines to match all of them.</source>
          <target state="translated">当给出多个与 &lt;code&gt;--or&lt;/code&gt; 组合的模式表达式时，将指定此标志以将匹配项限制为具有所有行都匹配的文件。</target>
        </trans-unit>
        <trans-unit id="a0b6fe15df65f2d5daa97101d52d41abe4f1ad3a" translate="yes" xml:space="preserve">
          <source>When grepping the object store (with &lt;code&gt;--cached&lt;/code&gt; or giving tree objects), running with multiple threads might perform slower than single threaded if &lt;code&gt;--textconv&lt;/code&gt; is given and there&amp;rsquo;re too many text conversions. So if you experience low performance in this case, it might be desirable to use &lt;code&gt;--threads=1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aea2178dff194f0c4c01be5fd5d2a4667a09068" translate="yes" xml:space="preserve">
          <source>When he&amp;rsquo;s ready, he tells Alice to pull changes from the repository at /home/bob/myrepo. She does this with:</source>
          <target state="translated">准备就绪后，他告诉Alice从/ home / bob / myrepo的存储库中提取更改。她这样做是：</target>
        </trans-unit>
        <trans-unit id="66bba6f8c73ac5f72ec362ac6e58a5210f96d2e5" translate="yes" xml:space="preserve">
          <source>When importing a renamed file or directory, simply delete the old name(s) and modify the new name(s) during the corresponding commit. Git performs rename detection after-the-fact, rather than explicitly during a commit.</source>
          <target state="translated">当导入一个重命名的文件或目录时,只需删除旧名,并在相应的提交中修改新名即可。Git 会在事后进行重命名检测,而不是在提交时明确地进行检测。</target>
        </trans-unit>
        <trans-unit id="547b791fe6e4a112ecfb6e63c2e9ee0d26e77b05" translate="yes" xml:space="preserve">
          <source>When in cone mode, the &lt;code&gt;git sparse-checkout set&lt;/code&gt; subcommand takes a list of directories instead of a list of sparse-checkout patterns. In this mode, the command &lt;code&gt;git sparse-checkout set A/B/C&lt;/code&gt; sets the directory &lt;code&gt;A/B/C&lt;/code&gt; as a recursive pattern, the directories &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A/B&lt;/code&gt; are added as parent patterns. The resulting sparse-checkout file is now</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdd5299d04b153fd0e295904b9e12eec6b499c8" translate="yes" xml:space="preserve">
          <source>When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt;). Note that the current worktree&amp;rsquo;s HEAD will not have its path printed (it will always be your current directory).</source>
          <target state="translated">在列表模式下，显示sha1并提交每个标题的主题行，以及与上游分支的关系（如果有）。如果给出两次，则打印链接的工作树的路径（如果有）以及上游分支的名称（另请参见 &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt; ）。请注意，当前工作树的HEAD不会打印其路径（它将始终是您的当前目录）。</target>
        </trans-unit>
        <trans-unit id="df3e42ff48559b3d46a4606cc43ea02a4d5742e5" translate="yes" xml:space="preserve">
          <source>When informative errors are turned on, git-daemon will report more verbose errors to the client, differentiating conditions like &quot;no such repository&quot; from &quot;repository not exported&quot;. This is more convenient for clients, but may leak information about the existence of unexported repositories. When informative errors are not enabled, all errors report &quot;access denied&quot; to the client. The default is --no-informative-errors.</source>
          <target state="translated">当开启信息错误时,git-daemon会向客户端报告更详细的错误,将 &quot;没有这样的仓库 &quot;和 &quot;没有导出仓库 &quot;这样的情况区分开来。这对客户端来说比较方便,但可能会泄露未导出版本库的信息。当不启用信息错误时,所有错误都会向客户端报告 &quot;拒绝访问&quot;。默认值是--no-informative-errors。</target>
        </trans-unit>
        <trans-unit id="882f7c25abfabdf5a0527656f301ec49c21b72e8" translate="yes" xml:space="preserve">
          <source>When initializing submodules, a &lt;code&gt;.gitmodules&lt;/code&gt; file in the top-level directory of the containing repository is used to find the url of each submodule. This file should be formatted in the same way as &lt;code&gt;$GIT_DIR/config&lt;/code&gt;. The key to each submodule url is &quot;submodule.$name.url&quot;. See &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">初始化子模块时，包含存储库的顶级目录中的 &lt;code&gt;.gitmodules&lt;/code&gt; 文件用于查找每个子模块的url。该文件的格式应与 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 。每个子模块URL的键是&amp;ldquo; submodule。$ name.url&amp;rdquo;。有关详细信息，请参见&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="854c3f2001a62b8064a99a360e1e32072b64ad8e" translate="yes" xml:space="preserve">
          <source>When initially invoking &lt;code&gt;git am&lt;/code&gt;, you give it the names of the mailboxes to process. Upon seeing the first patch that does not apply, it aborts in the middle. You can recover from this in one of two ways:</source>
          <target state="translated">最初调用 &lt;code&gt;git am&lt;/code&gt; 时，您给它提供了要处理的邮箱的名称。看到不适用的第一个补丁后，它会在中间中止。您可以通过以下两种方式之一从中恢复：</target>
        </trans-unit>
        <trans-unit id="ae919810620b188b4a098cb2c7010981f59eb2a8" translate="yes" xml:space="preserve">
          <source>When invoking a custom merge tool, Git uses a set of temporary files to pass to the tool. If the tool returns an error and this variable is set to &lt;code&gt;true&lt;/code&gt;, then these temporary files will be preserved, otherwise they will be removed after the tool has exited. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">调用自定义合并工具时，Git使用一组临时文件传递给该工具。如果工具返回错误且此变量设置为 &lt;code&gt;true&lt;/code&gt; ，则将保留这些临时文件，否则将在工具退出后将其删除。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b149cf0c1c59f45e7d020f119cab62bcf88ef5e" translate="yes" xml:space="preserve">
          <source>When it comes to editing that commit, execute &lt;code&gt;git reset HEAD^&lt;/code&gt;. The effect is that the HEAD is rewound by one, and the index follows suit. However, the working tree stays the same.</source>
          <target state="translated">在编辑提交时，执行 &lt;code&gt;git reset HEAD^&lt;/code&gt; 。效果是将HEAD倒退一个，索引也随之变化。但是，工作树保持不变。</target>
        </trans-unit>
        <trans-unit id="54d95c16d8a8ecd15ca228486caba0d9b645aa97" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to apply a change, the following happens:</source>
          <target state="translated">当不清楚如何应用变化时,会发生以下情况。</target>
        </trans-unit>
        <trans-unit id="42b78027e34d66bfdfc08d7cf571f024832571b4" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to reconcile the changes, the following happens:</source>
          <target state="translated">当如何协调这些变化不明显时,就会发生以下情况。</target>
        </trans-unit>
        <trans-unit id="ac3a9525cba718f2ba4c34b577914369145b2d3f" translate="yes" xml:space="preserve">
          <source>When listing references from an alternate, list only references that begin with the given prefix. Prefixes match as if they were given as arguments to &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. To list multiple prefixes, separate them with whitespace. If &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; is set, setting &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; has no effect.</source>
          <target state="translated">从备用列表列出引用时，仅列出以给定前缀开头的引用。前缀匹配，就好像它们是&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]的参数一样&lt;/a&gt;。要列出多个前缀，请用空格分隔它们。如果 &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; 设置，设置 &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; 没有任何效果。</target>
        </trans-unit>
        <trans-unit id="9485b24ac5fd9e24de580d1b4ae98203a381daa8" translate="yes" xml:space="preserve">
          <source>When listing, use the specified &amp;lt;format&amp;gt;, which can be one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;. When omitted, the format defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">列出时，请使用指定的&amp;lt;format&amp;gt;，它可以是 &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;medium&lt;/code&gt; 和 &lt;code&gt;long&lt;/code&gt; 之一。如果省略，则格式默认为 &lt;code&gt;short&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0de171dd2f5efd6969d6cc172c7d84e26d4bf231" translate="yes" xml:space="preserve">
          <source>When loosening unreachable objects, do not bother loosening any objects older than &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt;. This can be used to optimize out the write of any objects that would be immediately pruned by a follow-up &lt;code&gt;git prune&lt;/code&gt;.</source>
          <target state="translated">松开无法到达的对象时，请勿费心松开任何 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 之前的对象。这可以用来优化对任何由后续 &lt;code&gt;git prune&lt;/code&gt; 修剪的对象的写入。</target>
        </trans-unit>
        <trans-unit id="2ecd3bb7ffbd4f19e0c8d754d499b7e6453c84ef" translate="yes" xml:space="preserve">
          <source>When merging an annotated (and possibly signed) tag, Git always creates a merge commit even if a fast-forward merge is possible, and the commit message template is prepared with the tag message. Additionally, if the tag is signed, the signature check is reported as a comment in the message template. See also &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;.</source>
          <target state="translated">合并带注释（且可能已签名）的标签时，即使可能进行快速合并，Git也会始终创建合并提交，并且使用标签消息准备提交消息模板。此外，如果标记已签名，则签名检查将作为注释报告在消息模板中。另见&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe18117100b1e7049979d08b3604c39a0ff0f463" translate="yes" xml:space="preserve">
          <source>When merging notes, be more verbose. When pruning notes, report all object names whose notes are removed.</source>
          <target state="translated">合并注解时,要更加详细。修剪注解时,报告所有注解被删除的对象名称。</target>
        </trans-unit>
        <trans-unit id="2a6ffb56c555f1836377a0b4eb9f01a6db423b92" translate="yes" xml:space="preserve">
          <source>When merging notes, operate quietly.</source>
          <target state="translated">合并笔记时,要悄悄操作。</target>
        </trans-unit>
        <trans-unit id="452e3643271eefd0a90ad1d2e336613f571129ec" translate="yes" xml:space="preserve">
          <source>When merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: &quot;manual&quot; (default), &quot;ours&quot;, &quot;theirs&quot;, &quot;union&quot; and &quot;cat_sort_uniq&quot;. This option overrides the &quot;notes.mergeStrategy&quot; configuration setting. See the &quot;NOTES MERGE STRATEGIES&quot; section below for more information on each notes merge strategy.</source>
          <target state="translated">合并笔记时,使用给定的策略解决笔记冲突。识别的策略有以下几种。&quot;manual&quot;(默认),&quot;ours&quot;,&quot;theirs&quot;,&quot;union &quot;和 &quot;cat_sort_uniq&quot;。这个选项会覆盖 &quot;Notes.mergeStrategy &quot;配置设置。请参阅下面的 &quot;notes合并策略 &quot;一节,了解每个笔记合并策略的更多信息。</target>
        </trans-unit>
        <trans-unit id="a1f0170f40742ebfd5d162ab78a6fe6f60fbd4e1" translate="yes" xml:space="preserve">
          <source>When missing or is set to &lt;code&gt;default&lt;/code&gt;, many fields in the stat structure are checked to detect if a file has been modified since Git looked at it. When this configuration variable is set to &lt;code&gt;minimal&lt;/code&gt;, sub-second part of mtime and ctime, the uid and gid of the owner of the file, the inode number (and the device number, if Git was compiled to use it), are excluded from the check among these fields, leaving only the whole-second part of mtime (and ctime, if &lt;code&gt;core.trustCtime&lt;/code&gt; is set) and the filesize to be checked.</source>
          <target state="translated">当丢失或设置为 &lt;code&gt;default&lt;/code&gt; ，将检查stat结构中的许多字段，以检测自Git查看文件以来是否已修改文件。当该配置变量被设置为 &lt;code&gt;minimal&lt;/code&gt; 修改时间和的ctime，UID的，子第二部分和GID的文件的inode编号的所有者（和器件号码，如果GIT中被编译使用它），被排除在在这些字段中进行检查，仅保留mtime的整个第二部分（如果设置了 &lt;code&gt;core.trustCtime&lt;/code&gt; ，则保留 ctime ）和要检查的文件大小。</target>
        </trans-unit>
        <trans-unit id="0689b4b76e007bf9e9f69e1368a4eed9e3d9055a" translate="yes" xml:space="preserve">
          <source>When more than one pattern matches the path, a later line overrides an earlier line. This overriding is done per attribute.</source>
          <target state="translated">当有多个模式与路径匹配时,后面的一行会覆盖前面的一行。这种覆盖是按属性进行的。</target>
        </trans-unit>
        <trans-unit id="7de11bcf0fc6f31a9913abfce53b7b83c6075119" translate="yes" xml:space="preserve">
          <source>When moved lines are colored using e.g. the &lt;code&gt;diff.colorMoved&lt;/code&gt; setting, this option controls the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; how spaces are treated for details of valid modes see &lt;code&gt;--color-moved-ws&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">当移动的线被使用例如有色 &lt;code&gt;diff.colorMoved&lt;/code&gt; 设置，这个选项控制 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 空间如何为有效模式中的处理的细节见 &lt;code&gt;--color-moved-ws&lt;/code&gt; 在&lt;a href=&quot;git-diff&quot;&gt;GIT-DIFF [1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52b8058d0bfbbff70a9ce60ad478453479b9a747" translate="yes" xml:space="preserve">
          <source>When multiple patches are output, the subject prefix will instead be &quot;[PATCH n/m] &quot;. To force 1/1 to be added for a single patch, use &lt;code&gt;-n&lt;/code&gt;. To omit patch numbers from the subject, use &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">当输出多个音色时，主题前缀将改为&amp;ldquo; [PATCH n / m]&amp;rdquo;。要强制为单个补丁添加1/1，请使用 &lt;code&gt;-n&lt;/code&gt; 。要从主题中省略补丁号，请使用 &lt;code&gt;-N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1cdd3c7b73eb4476790691d3f8180aaaecc09ec" translate="yes" xml:space="preserve">
          <source>When multiple working trees are used, most of files in $GIT_DIR are per-worktree with a few known exceptions. All files under &lt;code&gt;common&lt;/code&gt; however will be shared between all working trees.</source>
          <target state="translated">当使用多个工作树时，$ GIT_DIR中的大多数文件都是每个工作树，但有一些已知的例外。但是，所有 &lt;code&gt;common&lt;/code&gt; 目录下的所有文件都将在所有工作树之间共享。</target>
        </trans-unit>
        <trans-unit id="dea6d60865820d20f017799a5c24231f89c30494" translate="yes" xml:space="preserve">
          <source>When neither the command-line nor the configuration specify what to push, the default behavior is used, which corresponds to the &lt;code&gt;simple&lt;/code&gt; value for &lt;code&gt;push.default&lt;/code&gt;: the current branch is pushed to the corresponding upstream branch, but as a safety measure, the push is aborted if the upstream branch does not have the same name as the local one.</source>
          <target state="translated">当命令行和配置均未指定要推送的内容时，将使用默认行为，该行为对应于 &lt;code&gt;push.default&lt;/code&gt; 的 &lt;code&gt;simple&lt;/code&gt; 值。default：将当前分支推送到相应的上游分支，但作为安全措施，使用push如果上游分支与本地分支的名称不同，则将中止。</target>
        </trans-unit>
        <trans-unit id="60de604c8e6be170ca14a17caf3d8c66cf8e4c1f" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, &lt;code&gt;stash@{0}&lt;/code&gt; is assumed, otherwise &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; must be a reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">如果未给出 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; ，则假定为 &lt;code&gt;stash@{0}&lt;/code&gt; ，否则， &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 必须是 &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 形式的引用。</target>
        </trans-unit>
        <trans-unit id="1cb728a038f1c7e17113ec68844d5bac04accdd7" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; argument is given from the command line, &lt;code&gt;git push&lt;/code&gt; behaves as if each &amp;lt;value&amp;gt; of this variable is given as &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">当从命令行中没有给出 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 参数时， &lt;code&gt;git push&lt;/code&gt; 的行为就像该变量的每个&amp;lt;value&amp;gt;都以 &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt; 的形式给出一样。</target>
        </trans-unit>
        <trans-unit id="a166fc08fc71ee0e3d700a37b70f8845fb53d565" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--whitespace&lt;/code&gt; flag is given from the command line, this configuration item is used as the default.</source>
          <target state="translated">如果 &lt;code&gt;--whitespace&lt;/code&gt; 未给出--whitespace标志，则此配置项用作默认值。</target>
        </trans-unit>
        <trans-unit id="b29755631cf67968424c24b41012b3c14a5bc20f" translate="yes" xml:space="preserve">
          <source>When no refspec was given on the command line, then &lt;code&gt;git pull&lt;/code&gt; uses the refspec from the configuration or &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt;. In such cases, the following rules apply:</source>
          <target state="translated">如果在命令行上未提供 &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; ，则 &lt;code&gt;git pull&lt;/code&gt; 使用配置或$ GIT_DIR / remotes / &amp;lt;origin&amp;gt;中的refspec。在这种情况下，以下规则适用：</target>
        </trans-unit>
        <trans-unit id="feee7e6efffd7b04e5558aa779c91bc6a7b795bd" translate="yes" xml:space="preserve">
          <source>When no remote is specified (via -r) the &lt;code&gt;HEAD&lt;/code&gt; branch from CVS is imported to the &lt;code&gt;origin&lt;/code&gt; branch within the Git repository, as &lt;code&gt;HEAD&lt;/code&gt; already has a special meaning for Git. When a remote is specified the &lt;code&gt;HEAD&lt;/code&gt; branch is named remotes/&amp;lt;remote&amp;gt;/master mirroring &lt;code&gt;git clone&lt;/code&gt; behaviour. Use this option if you want to import into a different branch.</source>
          <target state="translated">如果未指定任何远程（通过-r），则CVS 的 &lt;code&gt;HEAD&lt;/code&gt; 分支将导入到Git存储库中的 &lt;code&gt;origin&lt;/code&gt; 分支，因为 &lt;code&gt;HEAD&lt;/code&gt; 对Git已经具有特殊含义。指定一个远程对象后， &lt;code&gt;HEAD&lt;/code&gt; 分支将命名为remotes / &amp;lt;remote&amp;gt; / master镜像 &lt;code&gt;git clone&lt;/code&gt; 行为。如果要导入到其他分支，请使用此选项。</target>
        </trans-unit>
        <trans-unit id="ac03f302c1aadb048fb52d65d000d2a5006af96e" translate="yes" xml:space="preserve">
          <source>When no remote is specified, by default the &lt;code&gt;origin&lt;/code&gt; remote will be used, unless there&amp;rsquo;s an upstream branch configured for the current branch.</source>
          <target state="translated">如果未指定任何远程，默认情况下将使用 &lt;code&gt;origin&lt;/code&gt; 远程，除非为当前分支配置了上游分支。</target>
        </trans-unit>
        <trans-unit id="d52e3dbbfef371828cf1a5d65a8a3d7860fbbc07" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for pushing. It also overrides &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing from branch &amp;lt;name&amp;gt;. When you pull from one place (e.g. your upstream) and push to another place (e.g. your own publishing repository), you would want to set &lt;code&gt;remote.pushDefault&lt;/code&gt; to specify the remote to push to for all branches, and use this option to override it for a specific branch.</source>
          <target state="translated">在分支&amp;lt;名称&amp;gt;上时，它将覆盖 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 以进行推送。它还会覆盖 &lt;code&gt;remote.pushDefault&lt;/code&gt; 以从分支&amp;lt;名称&amp;gt;进行推送。当您从一个地方（例如上游）拉出并推送到另一个地方（例如您自己的发布存储库）时，您需要设置 &lt;code&gt;remote.pushDefault&lt;/code&gt; 以指定要推送到所有分支的远程，并使用此选项覆盖对于特定的分支。</target>
        </trans-unit>
        <trans-unit id="2c5d62eaf7dc4c0abb09284bfc14bacce3f382aa" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it tells &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; which remote to fetch from/push to. The remote to push to may be overridden with &lt;code&gt;remote.pushDefault&lt;/code&gt; (for all branches). The remote to push to, for the current branch, may be further overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt;. If no remote is configured, or if you are not on any branch, it defaults to &lt;code&gt;origin&lt;/code&gt; for fetching and &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing. Additionally, &lt;code&gt;.&lt;/code&gt; (a period) is the current local repository (a dot-repository), see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;'s final note below.</source>
          <target state="translated">在分支&amp;lt;name&amp;gt;上时，它告诉 &lt;code&gt;git fetch&lt;/code&gt; 和 &lt;code&gt;git push&lt;/code&gt; 从哪个远程获取/推送到。推送到的遥控器可能会被 &lt;code&gt;remote.pushDefault&lt;/code&gt; （对于所有分支）覆盖。对于当前分支，要推送到的远程对象可能会被 &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; 进一步覆盖。如果没有远程配置，或者如果你没有任何分支，则默认为 &lt;code&gt;origin&lt;/code&gt; 的获取和 &lt;code&gt;remote.pushDefault&lt;/code&gt; 推。此外， &lt;code&gt;.&lt;/code&gt; （句点）是当前的本地存储库（点存储库），请参见 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 的最后注释。</target>
        </trans-unit>
        <trans-unit id="99875f2b6ac5843dc20c0934eb9cdf10f7711c8e" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;fsmonitor valid&quot; bit for the paths. See section &quot;File System Monitor&quot; below for more information.</source>
          <target state="translated">当指定了其中一个标志时,不会更新路径中记录的对象名称,而是设置和解除路径的 &quot;fsmonitor valid &quot;位。相反,这些选项会设置和取消设置路径的 &quot;fsmonitor valid &quot;位。更多信息请参见下面的 &quot;文件系统监视器 &quot;一节。</target>
        </trans-unit>
        <trans-unit id="095b3a1631077463d64190b5c04e9903f37eec26" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;skip-worktree&quot; bit for the paths. See section &quot;Skip-worktree bit&quot; below for more information.</source>
          <target state="translated">当指定这些标志之一时,不会更新路径中记录的对象名称。相反,这些选项会设置和取消设置路径的 &quot;skip-worktree &quot;位。更多信息请参见下面的 &quot;跳过工作树位 &quot;一节。</target>
        </trans-unit>
        <trans-unit id="6e8f4e10b13b6ff83d83df5063d58c36d64a87b8" translate="yes" xml:space="preserve">
          <source>When one or more &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; are specified explicitly (whether on the command line or via &lt;code&gt;--stdin&lt;/code&gt;), it can be either a single pattern, or a pair of such pattern separated by a colon &quot;:&quot; (this means that a ref name cannot have a colon in it). A single pattern &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is just a shorthand for &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">当显式指定一个或多个 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 时（无论是在命令行上还是通过 &lt;code&gt;--stdin&lt;/code&gt; ），它可以是单个模式，也可以是一对这样的模式，并用冒号&amp;ldquo;：&amp;rdquo;分隔（这意味着ref名称中不能包含冒号）。单个模式 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 只是 &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="9a9b16c534806b7638cc46892a28dd173752ed8c" translate="yes" xml:space="preserve">
          <source>When packing a blob fast-import always attempts to deltify against the last blob written. Unless specifically arranged for by the frontend, this will probably not be a prior version of the same file, so the generated delta will not be the smallest possible. The resulting packfile will be compressed, but will not be optimal.</source>
          <target state="translated">当打包一个blob时,fast-import总是试图对照最后写入的blob进行deltify。除非前台特别安排,否则这可能不是同一文件的先前版本,所以生成的delta不会是最小的。生成的packfile会被压缩,但不会是最佳的。</target>
        </trans-unit>
        <trans-unit id="76e4bf1d99930055a44aa05818b2c065730f60bb" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-paths&lt;/code&gt;.</source>
          <target state="translated">当传递给 &lt;code&gt;init&lt;/code&gt; 或 &lt;code&gt;clone&lt;/code&gt; 时,此正则表达式将保留为配置键。有关 &lt;code&gt;--ignore-paths&lt;/code&gt; 的描述，请参见 &lt;code&gt;fetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6a3308486ea0114e28423fc585e726bdfefa0d3" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-refs&lt;/code&gt;.</source>
          <target state="translated">当传递给 &lt;code&gt;init&lt;/code&gt; 或 &lt;code&gt;clone&lt;/code&gt; 时,此正则表达式将保留为配置键。有关 &lt;code&gt;--ignore-refs&lt;/code&gt; 的描述，请参见 &lt;code&gt;fetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="247954c989ece2f916f72b869f8bb1eb7f01f09e" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">当传递给 &lt;code&gt;init&lt;/code&gt; 或 &lt;code&gt;clone&lt;/code&gt; 时,此正则表达式将保留为配置键。有关 &lt;code&gt;--include-paths&lt;/code&gt; 的描述，请参见 &lt;code&gt;fetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="701b3c119f368819101d8af88b842359e5cb7ac8" translate="yes" xml:space="preserve">
          <source>When paths are given, show them (note that this isn&amp;rsquo;t really raw pathnames, but rather a list of patterns to match). Otherwise implicitly uses the root level of the tree as the sole path argument.</source>
          <target state="translated">给定路径后，显示它们（请注意，这实际上不是原始路径名，而是要匹配的模式列表）。否则，隐式使用树的根级别作为唯一路径参数。</target>
        </trans-unit>
        <trans-unit id="a12bc3537fe67daac72917848a655d5078c91711" translate="yes" xml:space="preserve">
          <source>When pathspec is given on the command line, commit the contents of the files that match the pathspec without recording the changes already added to the index. The contents of these files are also staged for the next commit on top of what have been staged before.</source>
          <target state="translated">当命令行给出pathspec时,提交符合pathspec的文件内容,而不记录已经添加到索引中的更改。这些文件的内容也会在下一次提交时,在之前的缓存上进行缓存。</target>
        </trans-unit>
        <trans-unit id="1a6dc462ca36ebe8779cf750259e000c162a076a" translate="yes" xml:space="preserve">
          <source>When pathspec is given to &lt;code&gt;git stash push&lt;/code&gt;, the new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</source>
          <target state="translated">当给 &lt;code&gt;git stash push&lt;/code&gt; 提供pathspec时，新的stash条目仅记录与pathspec匹配的文件的修改状态。然后，索引条目和工作树文件也仅针对这些文件回滚到HEAD中的状态，而与pathspec不匹配的文件将完整保留。</target>
        </trans-unit>
        <trans-unit id="20284d20320c7f9cdd342728ed75cf98e12a1b6c" translate="yes" xml:space="preserve">
          <source>When possible, &lt;code&gt;pack-objects&lt;/code&gt; tries to reuse existing on-disk deltas to avoid having to search for new ones on the fly. This is an important optimization for serving fetches, because it means the server can avoid inflating most objects at all and just send the bytes directly from disk. This optimization can&amp;rsquo;t work when an object is stored as a delta against a base which the receiver does not have (and which we are not already sending). In that case the server &quot;breaks&quot; the delta and has to find a new one, which has a high CPU cost. Therefore it&amp;rsquo;s important for performance that the set of objects in on-disk delta relationships match what a client would fetch.</source>
          <target state="translated">在可能的情况下， &lt;code&gt;pack-objects&lt;/code&gt; 尝试重用现有的磁盘增量，以避免在运行中寻找新的增量。对于服务提取来说，这是一项重要的优化，因为这意味着服务器可以完全避免膨胀大多数对象，而直接从磁盘发送字节。当将对象存储为相对于接收者没有（并且我们尚未发送）的基准的增量时，此优化将无法进行。在这种情况下，服务器&amp;ldquo;破坏&amp;rdquo;增量并必须找到一个新的CPU，这将导致CPU成本高昂。因此，对磁盘而言，增量差异关系中的对象集必须与客户端获取的内容相匹配对于性能而言非常重要。</target>
        </trans-unit>
        <trans-unit id="a5d1e2c9c76493f4d0a607592b15388eabc93e4e" translate="yes" xml:space="preserve">
          <source>When present, it will also copy the value of &lt;code&gt;submodule.$name.update&lt;/code&gt;. This command does not alter existing information in .git/config. You can then customize the submodule clone URLs in .git/config for your local setup and proceed to &lt;code&gt;git submodule update&lt;/code&gt;; you can also just use &lt;code&gt;git submodule update --init&lt;/code&gt; without the explicit &lt;code&gt;init&lt;/code&gt; step if you do not intend to customize any submodule locations.</source>
          <target state="translated">如果存在，它还将复制 &lt;code&gt;submodule.$name.update&lt;/code&gt; 的值。此命令不会更改.git / config中的现有信息。然后，您可以在.git / config中为本地设置自定义子模块克隆URL，然后继续进行 &lt;code&gt;git submodule update&lt;/code&gt; ；如果您不打算自定义任何子模块位置，则也可以只使用 &lt;code&gt;git submodule update --init&lt;/code&gt; 而不使用显式的 &lt;code&gt;init&lt;/code&gt; 步骤。</target>
        </trans-unit>
        <trans-unit id="fb5aacfd35a68a879acea2ba6edf150f79c935f9" translate="yes" xml:space="preserve">
          <source>When pushing to a remote that is different from the remote you normally pull from, work as &lt;code&gt;current&lt;/code&gt;. This is the safest option and is suited for beginners.</source>
          <target state="translated">当推入与您通常从其拔出的遥控器不同的遥控器时，请以 &lt;code&gt;current&lt;/code&gt; 工作。这是最安全的选择，适合初学者。</target>
        </trans-unit>
        <trans-unit id="f99e4f9643f5e033d51557f2aab4b69c000e9e23" translate="yes" xml:space="preserve">
          <source>When pushing, request the remote server to update refs in a single atomic transaction. If successful, all refs will be updated, or none will. If the remote side does not support this capability, the push will fail.</source>
          <target state="translated">推送时,请求远程服务器在一个原子事务中更新 refs。如果成功,所有的 refs 都会被更新,或者没有。如果远端不支持这个功能,推送将失败。</target>
        </trans-unit>
        <trans-unit id="24e8d08f5bcd393fd98db303b5bfff38ae149335" translate="yes" xml:space="preserve">
          <source>When reading the &lt;code&gt;core.repositoryformatversion&lt;/code&gt; variable, a git implementation which supports version 1 MUST also read any configuration keys found in the &lt;code&gt;extensions&lt;/code&gt; section of the configuration file.</source>
          <target state="translated">在读取 &lt;code&gt;core.repositoryformatversion&lt;/code&gt; 变量时，支持版本1的git实现也必须读取配置文件的 &lt;code&gt;extensions&lt;/code&gt; 部分中找到的所有配置键。</target>
        </trans-unit>
        <trans-unit id="d49438aa2f88cdc57a3b7001a0406b8491bbad55" translate="yes" xml:space="preserve">
          <source>When reading trailers, there can be whitespaces after the token, the separator and the value. There can also be whitespaces inside the token and the value. The value may be split over multiple lines with each subsequent line starting with whitespace, like the &quot;folding&quot; in RFC 822.</source>
          <target state="translated">读取预告片时,标记、分隔符和值后面可能会有空格。在标记和值内也可以有空格。值可以分成多行,每一行都以空格开始,就像RFC 822中的 &quot;折叠&quot;。</target>
        </trans-unit>
        <trans-unit id="c808cfa1e01223bf6f90ceb1edbec20a1b9b3321" translate="yes" xml:space="preserve">
          <source>When reading, the values are read from the system, global and repository local configuration files by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--local&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt; and &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to read from only that location (see &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;).</source>
          <target state="translated">读取时，默认情况下会从系统，全局和存储库本地配置文件中读取值，并且选项 &lt;code&gt;--system&lt;/code&gt; ，-- &lt;code&gt;--global&lt;/code&gt; ，-- &lt;code&gt;--local&lt;/code&gt; ，-- &lt;code&gt;--worktree&lt;/code&gt; 和 &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; 可用于告知命令仅从该位置读取（请参阅&lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="35058e27fd0502a5cbd6b1225fdbfa49a5b7004d" translate="yes" xml:space="preserve">
          <source>When recording the commit, append a line that says &quot;(cherry picked from commit &amp;hellip;​)&quot; to the original commit message in order to indicate which commit this change was cherry-picked from. This is done only for cherry picks without conflicts. Do not use this option if you are cherry-picking from your private branch because the information is useless to the recipient. If on the other hand you are cherry-picking between two publicly visible branches (e.g. backporting a fix to a maintenance branch for an older release from a development branch), adding this information can be useful.</source>
          <target state="translated">在记录提交时，请在原始提交消息后添加一行``（从提交中提取樱桃...）''，以表明此更改是从哪个提交中挑选出来的。这仅适用于没有冲突的樱桃采摘。如果您是从私人分支中挑选樱桃，请不要使用此选项，因为该信息对收件人毫无用处。另一方面，如果您在两个公开可见的分支之间进行挑剔（例如，将修补程序向后移植到维护分支，以便从开发分支中发布较旧的版本），则添加此信息可能会很有用。</target>
        </trans-unit>
        <trans-unit id="ccaf8e1c6e304870dc79f0b6ba9e209459375c19" translate="yes" xml:space="preserve">
          <source>When recording your own work, the contents of modified files in your working tree are temporarily stored to a staging area called the &quot;index&quot; with &lt;code&gt;git add&lt;/code&gt;. A file can be reverted back, only in the index but not in the working tree, to that of the last commit with &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt;, which effectively reverts &lt;code&gt;git add&lt;/code&gt; and prevents the changes to this file from participating in the next commit. After building the state to be committed incrementally with these commands, &lt;code&gt;git commit&lt;/code&gt; (without any pathname parameter) is used to record what has been staged so far. This is the most basic form of the command. An example:</source>
          <target state="translated">记录自己的作品时，使用 &lt;code&gt;git add&lt;/code&gt; 将工作树中已修改文件的内容临时存储到称为&amp;ldquo;索引&amp;rdquo;的登台区域中。可以使用 &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt; 将文件仅在索引中但不能在工作树中还原为最后一次提交的文件，可以有效地还原 &lt;code&gt;git add&lt;/code&gt; 并防止对该文件的更改参与到git下一次提交。在使用这些命令建立要递增 &lt;code&gt;git commit&lt;/code&gt; 的状态之后，使用git commit（不带任何pathname参数）来记录到目前为止已执行的操作。这是命令的最基本形式。一个例子：</target>
        </trans-unit>
        <trans-unit id="35cd60207a202ee3a283a2d8b2047b148806b6b3" translate="yes" xml:space="preserve">
          <source>When remote and local branch are both named &quot;test&quot;:</source>
          <target state="translated">当远程和本地分支都命名为 &quot;test &quot;时。</target>
        </trans-unit>
        <trans-unit id="2eefb86cce90a60f5ab07db6487aa99da3ba4333" translate="yes" xml:space="preserve">
          <source>When rename/copy is involved, &lt;code&gt;file1&lt;/code&gt; and &lt;code&gt;file2&lt;/code&gt; show the name of the source file of the rename/copy and the name of the file that rename/copy produces, respectively.</source>
          <target state="translated">当涉及重命名/复制时， &lt;code&gt;file1&lt;/code&gt; 和 &lt;code&gt;file2&lt;/code&gt; 分别显示重命名/复制的源文件的名称和重命名/复制生成的文件的名称。</target>
        </trans-unit>
        <trans-unit id="3475b12f6b8e32c3a9c4f496f5f906d95460d63d" translate="yes" xml:space="preserve">
          <source>When repacking with delta islands the delta window tends to get clogged with candidates that are forbidden by the config. Repacking with a big --window helps (and doesn&amp;rsquo;t take as long as it otherwise might because we can reject some object pairs based on islands before doing any computation on the content).</source>
          <target state="translated">当重新打包delta岛时，delta窗口会被配置所禁止的候选者阻塞。用大--window进行重新包装会有所帮助（并且不需要花那么长的时间，因为在对内容进行任何计算之前，我们可以基于岛拒绝某些对象对）。</target>
        </trans-unit>
        <trans-unit id="9f9b14ed67913870e54606a7e4140c245c13e689" translate="yes" xml:space="preserve">
          <source>When restoring files in the working tree from the index, use stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">从索引还原工作树中的文件时，对于未合并的路径，请使用阶段＃2（ &lt;code&gt;ours&lt;/code&gt; ）或＃3（ &lt;code&gt;theirs&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f350add778942f50c4b0b2f8798762ec9d6fc205" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, &lt;code&gt;--merge&lt;/code&gt; or &lt;code&gt;--conflict&lt;/code&gt; is specified. Unmerged paths on the working tree are left alone.</source>
          <target state="translated">从索引还原工作树上的文件时，如果存在未合并的条目并且 &lt;code&gt;--conflict&lt;/code&gt; 指定 &lt;code&gt;--ours&lt;/code&gt; ，-- &lt;code&gt;--theirs&lt;/code&gt; ，-- &lt;code&gt;--merge&lt;/code&gt; 或--conflict，请不要中止该操作。工作树上未合并的路径将保留。</target>
        </trans-unit>
        <trans-unit id="84ac309392e16a1f3dcc1a792805de1c5dea7161" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths.</source>
          <target state="translated">当从索引中恢复工作树上的文件时,在未合并的路径中重新创建冲突的合并。</target>
        </trans-unit>
        <trans-unit id="273a9228c51e5936f4d142f339102a2bbdd8c3b8" translate="yes" xml:space="preserve">
          <source>When retrieving svn commits into Git (as part of &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, or &lt;code&gt;dcommit&lt;/code&gt; operations), look for the first &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line in the log message and use that as the author string.</source>
          <target state="translated">当将svn commits检索到Git中（作为 &lt;code&gt;fetch&lt;/code&gt; ， &lt;code&gt;rebase&lt;/code&gt; 或 &lt;code&gt;dcommit&lt;/code&gt; 操作的一部分）时，请在日志消息中查找第一个 &lt;code&gt;From:&lt;/code&gt; 或 &lt;code&gt;Signed-off-by:&lt;/code&gt; by- ：行并将其用作作者字符串。</target>
        </trans-unit>
        <trans-unit id="78d119701beb340fc1dce20129de3c1bebaf8055" translate="yes" xml:space="preserve">
          <source>When revision range specifiers are used to limit the annotation, lines that have not changed since the range boundary (either the commit v2.6.18 or the most recent commit that is more than 3 weeks old in the above example) are blamed for that range boundary commit.</source>
          <target state="translated">当使用修订范围指定符来限制注解时,自范围边界以来没有变化的行(无论是上例中的提交v2.6.18还是超过3周的最近一次提交)将被归咎于该范围边界提交。</target>
        </trans-unit>
        <trans-unit id="802f2e7848870b44ce9f04fb441477cd05447e6c" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;) and this variable is set to &lt;code&gt;true&lt;/code&gt;, Git automatically copies your notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;, but see &quot;notes.rewriteRef&quot; below.</source>
          <target state="translated">当使用&amp;lt;command&amp;gt;进行重写提交（当前为 &lt;code&gt;amend&lt;/code&gt; 或 &lt;code&gt;rebase&lt;/code&gt; ）并且此变量设置为 &lt;code&gt;true&lt;/code&gt; 时，Git会自动将您的笔记从原始副本复制到重写的提交中。默认为 &lt;code&gt;true&lt;/code&gt; ，但请参见下面的&amp;ldquo; notes.rewriteRef&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b9c5c034bfc575d885230ecf217359276486be76" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;), if this variable is &lt;code&gt;false&lt;/code&gt;, git will not copy notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;. See also &quot;&lt;code&gt;notes.rewriteRef&lt;/code&gt;&quot; below.</source>
          <target state="translated">当使用&amp;lt;command&amp;gt;重写提交时（当前是 &lt;code&gt;amend&lt;/code&gt; 或 &lt;code&gt;rebase&lt;/code&gt; ），如果此变量为 &lt;code&gt;false&lt;/code&gt; ，则git不会将笔记从原始副本复制到重写的提交中。默认为 &lt;code&gt;true&lt;/code&gt; 。另请参见下面的&amp;ldquo; &lt;code&gt;notes.rewriteRef&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0528b909a801bc351dbefd46a3e339150f63bb9d" translate="yes" xml:space="preserve">
          <source>When rewriting commits, which notes to copy from the original to the rewritten commit. Must be a colon-delimited list of refs or globs.</source>
          <target state="translated">当重写提交时,要从原提交中复制哪些注释到重写后的提交中。必须是以冒号分隔的参考文献或globs列表。</target>
        </trans-unit>
        <trans-unit id="777967b1b1cbeac1b786b4e659ef472d75c08474" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument.</source>
          <target state="translated">从项目的子目录运行时，可以告诉它排除目录之外的更改，并使用此选项显示相对于它的路径名。当您不在子目录中（例如，在裸仓库中）时，可以通过指定&amp;lt;path&amp;gt;作为参数来命名要相对于哪个子目录进行输出。</target>
        </trans-unit>
        <trans-unit id="1526deda1d1c171ba9bb8aedb499ef46fa3558ac" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument. &lt;code&gt;--no-relative&lt;/code&gt; can be used to countermand both &lt;code&gt;diff.relative&lt;/code&gt; config option and previous &lt;code&gt;--relative&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27ca634a7183f46a280e82c3af06c829ca10b89" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory.</source>
          <target state="translated">当从子目录运行时,命令通常输出相对于当前目录的路径。这个选项会强制输出相对于项目顶层目录的路径。</target>
        </trans-unit>
        <trans-unit id="ed0ff11c4a5dd052209fd6d888b93db83b1003f1" translate="yes" xml:space="preserve">
          <source>When run in a directory that does not have &quot;.git&quot; repository directory, Git tries to find such a directory in the parent directories to find the top of the working tree, but by default it does not cross filesystem boundaries. This environment variable can be set to true to tell Git not to stop at filesystem boundaries. Like &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt;, this will not affect an explicit repository directory set via &lt;code&gt;GIT_DIR&lt;/code&gt; or on the command line.</source>
          <target state="translated">当在没有&amp;ldquo; .git&amp;rdquo;存储库目录的目录中运行时，Git会尝试在父目录中找到这样的目录以查找工作树的顶部，但是默认情况下它不会跨越文件系统边界。可以将此环境变量设置为true，以告诉Git不要在文件系统边界停止。像 &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt; 一样，这不会影响通过 &lt;code&gt;GIT_DIR&lt;/code&gt; 或在命令行上设置的显式存储库目录。</target>
        </trans-unit>
        <trans-unit id="9ce1b9e20fc14e8e8925879039b8daf3d52acd6a" translate="yes" xml:space="preserve">
          <source>When running the command with &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-m&lt;/code&gt; options, the merge result may need to overwrite paths that are not tracked in the current branch. The command usually refuses to proceed with the merge to avoid losing such a path. However this safety valve sometimes gets in the way. For example, it often happens that the other branch added a file that used to be a generated file in your branch, and the safety valve triggers when you try to switch to that branch after you ran &lt;code&gt;make&lt;/code&gt; but before running &lt;code&gt;make clean&lt;/code&gt; to remove the generated file. This option tells the command to read per-directory exclude file (usually &lt;code&gt;.gitignore&lt;/code&gt;) and allows such an untracked but explicitly ignored file to be overwritten.</source>
          <target state="translated">当使用 &lt;code&gt;-u&lt;/code&gt; 和 &lt;code&gt;-m&lt;/code&gt; 选项运行命令时，合并结果可能需要覆盖当前分支中未跟踪的路径。该命令通常拒绝继续合并，以免丢失此类路径。但是，此安全阀有时会妨碍您的操作。例如，它常常发生其他分支还说，曾经在你的分支生成的文件的文件，和安全阀触发器，当您尝试切换到该分支你跑后 &lt;code&gt;make&lt;/code&gt; ，但在运行之前 &lt;code&gt;make clean&lt;/code&gt; 去除产生文件。此选项告诉命令读取每个目录的排除文件（通常是 &lt;code&gt;.gitignore&lt;/code&gt; ），并允许覆盖这种未跟踪但被显式忽略的文件。</target>
        </trans-unit>
        <trans-unit id="df426fd8f20937aff52c156a03a07b3202618140" translate="yes" xml:space="preserve">
          <source>When sending a patch this way, most often you are sending your own patch, so in addition to the &quot;&lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt;&quot; marker you should omit &lt;code&gt;From:&lt;/code&gt; and &lt;code&gt;Date:&lt;/code&gt; lines from the patch file. The patch title is likely to be different from the subject of the discussion the patch is in response to, so it is likely that you would want to keep the Subject: line, like the example above.</source>
          <target state="translated">以这种方式发送补丁程序时，通常是发送自己的补丁程序，因此，除了&amp;ldquo; &lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt; &amp;rdquo;标记外，还应 &lt;code&gt;From:&lt;/code&gt; 补丁程序文件中省略From：和 &lt;code&gt;Date:&lt;/code&gt; 行。补丁标题可能与补丁所针对的讨论主题不同，因此，您可能希望保留Subject：行，如上例所示。</target>
        </trans-unit>
        <trans-unit id="85b26b0293721642a3d3ba409cae09a21a570f47" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always highlight matches. When &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use color only when the output is written to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">设置为 &lt;code&gt;always&lt;/code&gt; 时，始终突出显示匹配项。如果为 &lt;code&gt;false&lt;/code&gt; （或 &lt;code&gt;never&lt;/code&gt; ），则永不。设置为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;auto&lt;/code&gt; 时，仅在将输出写入终端时使用颜色。如果未设置，则使用 &lt;code&gt;color.ui&lt;/code&gt; 的值（默认情况下为 &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dfd0a45591bf4cdb6d73f4e9b16cc039b04690be" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always use colors for interactive prompts and displays (such as those used by &quot;git-add --interactive&quot; and &quot;git-clean --interactive&quot;). When false (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use colors only when the output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">设置为 &lt;code&gt;always&lt;/code&gt; 时，始终为交互提示和显示使用颜色（例如&amp;ldquo; git-add --interactive&amp;rdquo;和&amp;ldquo; git-clean --interactive&amp;rdquo;使用的颜色）。如果为假（或 &lt;code&gt;never&lt;/code&gt; ），则永不。设置为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;auto&lt;/code&gt; 时，仅在输出到终端时才使用颜色。如果未设置，则使用 &lt;code&gt;color.ui&lt;/code&gt; 的值（默认情况下为 &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9ba7d00c9f4d532d2b9486b8c87259ed84e278f3" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;change&lt;/code&gt;, tells &lt;code&gt;git apply&lt;/code&gt; to ignore changes in whitespace, in the same way as the &lt;code&gt;--ignore-space-change&lt;/code&gt; option. When set to one of: no, none, never, false tells &lt;code&gt;git apply&lt;/code&gt; to respect all whitespace differences. See &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;.</source>
          <target state="translated">设置为 &lt;code&gt;change&lt;/code&gt; 时，告诉 &lt;code&gt;git apply&lt;/code&gt; 忽略空白中的更改，与 &lt;code&gt;--ignore-space-change&lt;/code&gt; 选项相同。当设置为以下之一时：不，不，从不，false告诉 &lt;code&gt;git apply&lt;/code&gt; 于尊重所有空白差异。参见&lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d6e4c3c7b2c6d56efae11b1e0ed0dcb5ce2357b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;merges&lt;/code&gt;, rebase using &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">当设置为 &lt;code&gt;merges&lt;/code&gt; ，使用变基 &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; ，以便本地合并提交被包括在变基（见&lt;a href=&quot;git-rebase&quot;&gt;GIT-变基[1]&lt;/a&gt;的详细信息）。</target>
        </trans-unit>
        <trans-unit id="3726def44fed6d7863a8f10abeef80361e6f2701" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), rebase with the &lt;code&gt;--preserve-merges&lt;/code&gt; option passed to &lt;code&gt;git rebase&lt;/code&gt; so that locally created merge commits will not be flattened.</source>
          <target state="translated">当设置为 &lt;code&gt;preserve&lt;/code&gt; （不推荐使用 &lt;code&gt;merges&lt;/code&gt; 时），请使用 &lt;code&gt;--preserve-merges&lt;/code&gt; 选项传递给 &lt;code&gt;git rebase&lt;/code&gt; 进行重新设置基准,以便本地创建的合并提交不会被展平。</target>
        </trans-unit>
        <trans-unit id="14ded32327ec4343589fd7082ddc1f7fdc8962f6" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git reset&lt;/code&gt; will default to the &lt;code&gt;--quiet&lt;/code&gt; option.</source>
          <target state="translated">设置为true时， &lt;code&gt;git reset&lt;/code&gt; 将默认为 &lt;code&gt;--quiet&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="01f095efe30e9d32fee48e094d88f96d4eba1bad" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git-rerere&lt;/code&gt; updates the index with the resulting contents after it cleanly resolves conflicts using previously recorded resolution. Defaults to false.</source>
          <target state="translated">设置为true时， &lt;code&gt;git-rerere&lt;/code&gt; 使用先前记录的分辨率完全解决冲突后，将使用结果内容更新索引。默认为false。</target>
        </trans-unit>
        <trans-unit id="e2cc234f1ab166d2852bd6878a576806a19d5021" translate="yes" xml:space="preserve">
          <source>When set to true, a clone of this submodule will be performed as a shallow clone (with a history depth of 1) unless the user explicitly asks for a non-shallow clone.</source>
          <target state="translated">当设置为 &quot;true &quot;时,除非用户明确要求非浅层克隆,否则该子模块的克隆将以浅层克隆的方式进行(历史深度为1)。</target>
        </trans-unit>
        <trans-unit id="6b72e60e4df8bc4b62a55c38ddf1b7b574998e6d" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run merge on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92df8026c7e3a5d595e452302b48399c0fa7807" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="translated">设置为true时，在操作开始之前自动创建一个临时存储项，并在操作结束之后应用它。这意味着您可以在肮脏的工作树上运行rebase。但是，请谨慎使用：成功重新设置基准之后的最终存储应用程序可能会导致非平凡的冲突。可以通过&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;的 &lt;code&gt;--no-autostash&lt;/code&gt; 和 &lt;code&gt;--autostash&lt;/code&gt; 选项覆盖此选项。默认为false。</target>
        </trans-unit>
        <trans-unit id="454e58d95a3a4a743aeef0859eac2b9c78e6f07a" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any local tags that no longer exist on the remote if pruning is activated in general via &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt;, &lt;code&gt;fetch.prune&lt;/code&gt; or &lt;code&gt;--prune&lt;/code&gt;. Overrides &lt;code&gt;fetch.pruneTags&lt;/code&gt; settings, if any.</source>
          <target state="translated">设置为true时，默认情况下，如果通常通过 &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; ， &lt;code&gt;fetch.prune&lt;/code&gt; 或 &lt;code&gt;--prune&lt;/code&gt; 激活了修剪，则默认情况下从此远程获取还将删除远程上不再存在的所有本地标记。覆盖 &lt;code&gt;fetch.pruneTags&lt;/code&gt; 设置（如果有）。</target>
        </trans-unit>
        <trans-unit id="2f08cdfbf2bbbb5ba49961d7515ae4f7f92a166e" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any remote-tracking references that no longer exist on the remote (as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line). Overrides &lt;code&gt;fetch.prune&lt;/code&gt; settings, if any.</source>
          <target state="translated">设置为true时，默认情况下从此远程获取还将删除远程上不再存在的所有远程跟踪引用（就像在命令行上给出了 &lt;code&gt;--prune&lt;/code&gt; 选项一样）。覆盖 &lt;code&gt;fetch.prune&lt;/code&gt; 设置（如果有）。</target>
        </trans-unit>
        <trans-unit id="5739477a3b9489a88899be9378f898520709209f" translate="yes" xml:space="preserve">
          <source>When set to true, git-receive-pack will advertise the push options capability to its clients. False by default.</source>
          <target state="translated">当设置为 &quot;true &quot;时,git-receive-pack 会向客户宣传推送选项的功能。默认为False。</target>
        </trans-unit>
        <trans-unit id="af12eb66ec26d00e256f0fbfcc7125aeb108aa2e" translate="yes" xml:space="preserve">
          <source>When set to true, this remote will be used to fetch promisor objects.</source>
          <target state="translated">当设置为 &quot;true &quot;时,这个远程将被用来获取承诺者对象。</target>
        </trans-unit>
        <trans-unit id="384788e82f8977bea09d8463e5bbfca26ec8a699" translate="yes" xml:space="preserve">
          <source>When set, the fetch or receive will abort in the case of a malformed object or a link to a nonexistent object. In addition, various other issues are checked for, including legacy issues (see &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;), and potential security issues like the existence of a &lt;code&gt;.GIT&lt;/code&gt; directory or a malicious &lt;code&gt;.gitmodules&lt;/code&gt; file (see the release notes for v2.2.1 and v2.17.1 for details). Other sanity and security checks may be added in future releases.</source>
          <target state="translated">设置此选项后，如果对象格式错误或指向不存在的对象的链接，则提取或接收将中止。此外，还会检查其他各种问题，包括遗留问题（请参阅 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ）以及潜在的安全问题，例如是否存在 &lt;code&gt;.GIT&lt;/code&gt; 目录或恶意的 &lt;code&gt;.gitmodules&lt;/code&gt; 文件（请参阅v2的发行说明）。 2.1和v2.17.1了解详情）。其他健全性和安全性检查可能会在将来的版本中添加。</target>
        </trans-unit>
        <trans-unit id="51a9809b150b3fa600feb6c1ea57e78e8de9e787" translate="yes" xml:space="preserve">
          <source>When showing &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;porcelain&lt;/code&gt; status output, print the filename verbatim and terminate the entries with NUL, instead of LF. If no format is given, implies the &lt;code&gt;--porcelain&lt;/code&gt; output format. Without the &lt;code&gt;-z&lt;/code&gt; option, filenames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">当显示 &lt;code&gt;short&lt;/code&gt; 或 &lt;code&gt;porcelain&lt;/code&gt; 状态输出时，逐字打印文件名，并以NUL（而不是LF）终止输入。如果未给出格式，则表示 &lt;code&gt;--porcelain&lt;/code&gt; 输出格式。如果不使用 &lt;code&gt;-z&lt;/code&gt; 选项，则引用带有&amp;ldquo;不寻常&amp;rdquo;字符的文件名，如配置变量 &lt;code&gt;core.quotePath&lt;/code&gt; 所述（参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="43f2e6f1690661b84f31283fe1b400a9df885029" translate="yes" xml:space="preserve">
          <source>When showing a change that involves a rename or a copy, &lt;code&gt;--stat&lt;/code&gt; output formats the pathnames compactly by combining common prefix and suffix of the pathnames. For example, a change that moves &lt;code&gt;arch/i386/Makefile&lt;/code&gt; to &lt;code&gt;arch/x86/Makefile&lt;/code&gt; while modifying 4 lines will be shown like this:</source>
          <target state="translated">显示涉及重命名或副本的更改时，-- &lt;code&gt;--stat&lt;/code&gt; 输出通过组合路径名的公共前缀和后缀来紧凑地格式化路径名。例如，在修改4行的同时将 &lt;code&gt;arch/i386/Makefile&lt;/code&gt; 移至 &lt;code&gt;arch/x86/Makefile&lt;/code&gt; 的更改将如下所示：</target>
        </trans-unit>
        <trans-unit id="5d4332d6cfe825bd00a3bfef76e9ffde728a5dde" translate="yes" xml:space="preserve">
          <source>When showing commit messages, also show notes which are stored in the given ref. The ref must be fully qualified. If the given ref does not exist, it is not an error but means that no notes should be printed.</source>
          <target state="translated">当显示提交消息时,也会显示存储在给定 ref 中的注释。ref必须是完全限定的。如果给定的 ref 不存在,这不是错误,而是意味着不应该打印注释。</target>
        </trans-unit>
        <trans-unit id="43020b05da28d5245a5572e708a459c7bb4d40bf" translate="yes" xml:space="preserve">
          <source>When showing object names, prefix them with &lt;code&gt;^&lt;/code&gt; and strip &lt;code&gt;^&lt;/code&gt; prefix from the object names that already have one.</source>
          <target state="translated">显示对象名称时，请在它们前面加上 &lt;code&gt;^&lt;/code&gt; ,并从已经有一个的对象名称中删除 &lt;code&gt;^&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="bf158ec030a04af48fd84ff99f4cdef61dbc802c" translate="yes" xml:space="preserve">
          <source>When showing the value of &amp;lt;name&amp;gt; as a symbolic ref, try to shorten the value, e.g. from &lt;code&gt;refs/heads/master&lt;/code&gt; to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">将&amp;lt;name&amp;gt;的值显示为符号ref时，请尝试将其值缩短，例如从 &lt;code&gt;refs/heads/master&lt;/code&gt; 改为 &lt;code&gt;master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d07871fea9de7a0886062f3dfa8bbc506d97b667" translate="yes" xml:space="preserve">
          <source>When shown by &lt;code&gt;git diff-tree -c&lt;/code&gt;, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents). When shown by &lt;code&gt;git diff-files -c&lt;/code&gt;, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka &quot;our version&quot;, file2 is stage 3 aka &quot;their version&quot;).</source>
          <target state="translated">当由 &lt;code&gt;git diff-tree -c&lt;/code&gt; 显示时，它将合并提交的父项与合并结果进行比较（即file1..fileN是父项）。当由 &lt;code&gt;git diff-files -c&lt;/code&gt; 显示时，它将两个未解析的合并父对象与工作树文件进行比较（即file1是阶段2 aka&amp;ldquo;我们的版本&amp;rdquo;，file2是阶段3 aka&amp;ldquo;其版本&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="aea42e2933202e5e3d5f69076d6bebeb378dfcd9" translate="yes" xml:space="preserve">
          <source>When some commits have been skipped (using &quot;git bisect skip&quot;), then the bisection algorithm is the same for step 1) to 3). But then we use roughly the following steps:</source>
          <target state="translated">当跳过了一些提交(使用 &quot;git bisect skip&quot;),那么第1)到第3)步的二分算法是一样的。但我们大致使用以下步骤。</target>
        </trans-unit>
        <trans-unit id="4192528671a22eca45fcad6bb5614a7ec165a5d4" translate="yes" xml:space="preserve">
          <source>When specified one or more times, &lt;code&gt;-L&lt;/code&gt; restricts annotation to the requested lines.</source>
          <target state="translated">如果指定一次或多次，则 &lt;code&gt;-L&lt;/code&gt; 将注释限制为所请求的行。</target>
        </trans-unit>
        <trans-unit id="75acd7ee44b0e77c6b233d3615dca447d4cfdc8c" translate="yes" xml:space="preserve">
          <source>When specifying the -v option the format used is:</source>
          <target state="translated">当指定-v选项时,使用的格式是:。</target>
        </trans-unit>
        <trans-unit id="0550af8039db48de114d18431bb7375cee83b91b" translate="yes" xml:space="preserve">
          <source>When switching branches with &lt;code&gt;--merge&lt;/code&gt;, staged changes may be lost.</source>
          <target state="translated">当使用 &lt;code&gt;--merge&lt;/code&gt; 切换分支时，分阶段的更改可能会丢失。</target>
        </trans-unit>
        <trans-unit id="1f4fa4b7e00510c39cb24519dad3b49f07cff89d" translate="yes" xml:space="preserve">
          <source>When switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">当切换分支时,如果您对一个或多个文件进行了本地修改,而这些修改在当前分支和您要切换的分支之间是不同的,那么为了在上下文中保留您的修改,命令将拒绝切换分支。但是,如果使用这个选项,当前分支、工作树内容和新分支之间会进行三方合并,您将在新分支上。</target>
        </trans-unit>
        <trans-unit id="7b0d58bb9103d272bfd260e85d337e6780ed225d" translate="yes" xml:space="preserve">
          <source>When switching branches, proceed even if the index or the working tree differs from &lt;code&gt;HEAD&lt;/code&gt;. This is used to throw away local changes.</source>
          <target state="translated">切换分支时，即使索引或工作树不同于 &lt;code&gt;HEAD&lt;/code&gt; ，也要继续进行。这用于丢弃本地更改。</target>
        </trans-unit>
        <trans-unit id="c0e1144ec53aca779c8724f81a0ba0a804f51a81" translate="yes" xml:space="preserve">
          <source>When the &quot;-C&quot; option is used, the original contents of modified files, and deleted files (and also unmodified files, if the &quot;--find-copies-harder&quot; option is used) are considered as candidates of the source files in rename/copy operation. If the input were like these filepairs, that talk about a modified file fileY and a newly created file file0:</source>
          <target state="translated">当使用&quot;-C &quot;选项时,在进行重命名/复制操作时,修改过的文件和删除过的文件(如果使用&quot;--find-copies-harder &quot;选项,也包括未修改过的文件)的原始内容被视为源文件的候选文件。如果输入的文件是这样的文件对,那就说明一个被修改的文件Y和一个新创建的文件0。</target>
        </trans-unit>
        <trans-unit id="f6565c60ff0e235a6b049473d40ff8e72074a702" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; argument is a branch name, the &lt;code&gt;--detach&lt;/code&gt; option can be used to detach &lt;code&gt;HEAD&lt;/code&gt; at the tip of the branch (&lt;code&gt;git checkout
&amp;lt;branch&amp;gt;&lt;/code&gt; would check out that branch without detaching &lt;code&gt;HEAD&lt;/code&gt;).</source>
          <target state="translated">当 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 参数是一个分支名， &lt;code&gt;--detach&lt;/code&gt; 选项可用于分离 &lt;code&gt;HEAD&lt;/code&gt; 在分支的前端部（ &lt;code&gt;git checkout &amp;lt;branch&amp;gt;&lt;/code&gt; 将检查出不拆卸该分支 &lt;code&gt;HEAD&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="588cf4af82a088b4d8241fca9de08188511b35c3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--aggressive&lt;/code&gt; option is supplied, &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; will be invoked with the &lt;code&gt;-f&lt;/code&gt; flag, which in turn will pass &lt;code&gt;--no-reuse-delta&lt;/code&gt; to &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This will throw away any existing deltas and re-compute them, at the expense of spending much more time on the repacking.</source>
          <target state="translated">当 &lt;code&gt;--aggressive&lt;/code&gt; 选项被提供时，&lt;a href=&quot;git-repack&quot;&gt;GIT-重新包装[1]&lt;/a&gt;将与被调用 &lt;code&gt;-f&lt;/code&gt; 标志，这反过来将通过 &lt;code&gt;--no-reuse-delta&lt;/code&gt; 到&lt;a href=&quot;git-pack-objects&quot;&gt;GIT中包对象[1] &lt;/a&gt;。这将丢弃所有现有的增量并重新计算它们，但要花费更多的时间进行重新包装。</target>
        </trans-unit>
        <trans-unit id="36c732582138b85601314513444f94ba223454f7" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--auto-merge&lt;/code&gt; is given, meld will merge all non-conflicting parts automatically, highlight the conflicting parts and wait for user decision. Setting &lt;code&gt;mergetool.meld.useAutoMerge&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; tells Git to unconditionally use the &lt;code&gt;--auto-merge&lt;/code&gt; option with &lt;code&gt;meld&lt;/code&gt;. Setting this value to &lt;code&gt;auto&lt;/code&gt; makes git detect whether &lt;code&gt;--auto-merge&lt;/code&gt; is supported and will only use &lt;code&gt;--auto-merge&lt;/code&gt; when available. A value of &lt;code&gt;false&lt;/code&gt; avoids using &lt;code&gt;--auto-merge&lt;/code&gt; altogether, and is the default value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82879b1b4c41ea78abef977470f6f223214f239a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--stdin&lt;/code&gt; option is provided, the patterns are read from standard in as a newline-delimited list instead of from the arguments.</source>
          <target state="translated">当 &lt;code&gt;--stdin&lt;/code&gt; 提供选项，模式从标准作为新行分隔的列表，而不是从参数读取。</target>
        </trans-unit>
        <trans-unit id="0e72b560677fc7dbf879d4b64bab949efbe4ffc6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-l&lt;/code&gt; option is used, format changes to</source>
          <target state="translated">使用 &lt;code&gt;-l&lt;/code&gt; 选项时，格式更改为</target>
        </trans-unit>
        <trans-unit id="2d7535050bbd171bed81a20302444843893d883d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-z&lt;/code&gt; option is given, pathnames are printed as is and without any quoting and lines are terminated with a NUL (ASCII 0x00) byte.</source>
          <target state="translated">当 &lt;code&gt;-z&lt;/code&gt; 选项，则路径名被打印为是，没有任何引用和线端接一个NUL（ASCII 0&amp;times;00）字节。</target>
        </trans-unit>
        <trans-unit id="e231e06fa3f3b3606e814466b6e12bf27e65315d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;.gitattributes&lt;/code&gt; file is missing from the work tree, the path in the index is used as a fall-back. During checkout process, &lt;code&gt;.gitattributes&lt;/code&gt; in the index is used and then the file in the working tree is used as a fall-back.</source>
          <target state="translated">当工作树中缺少 &lt;code&gt;.gitattributes&lt;/code&gt; 文件时，索引中的路径将用作后备路径。在签出过程中，将使用索引中的 &lt;code&gt;.gitattributes&lt;/code&gt; ，然后将工作树中的文件用作后备。</target>
        </trans-unit>
        <trans-unit id="ca6fe469ff13b0a4412dea9bd34db705e00a71db" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;LESS&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;FRX&lt;/code&gt; (if &lt;code&gt;LESS&lt;/code&gt; environment variable is set, Git does not change it at all). If you want to selectively override Git&amp;rsquo;s default setting for &lt;code&gt;LESS&lt;/code&gt;, you can set &lt;code&gt;core.pager&lt;/code&gt; to e.g. &lt;code&gt;less -S&lt;/code&gt;. This will be passed to the shell by Git, which will translate the final command to &lt;code&gt;LESS=FRX less -S&lt;/code&gt;. The environment does not set the &lt;code&gt;S&lt;/code&gt; option but the command line does, instructing less to truncate long lines. Similarly, setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;less -+F&lt;/code&gt; will deactivate the &lt;code&gt;F&lt;/code&gt; option specified by the environment from the command-line, deactivating the &quot;quit if one screen&quot; behavior of &lt;code&gt;less&lt;/code&gt;. One can specifically activate some flags for particular commands: for example, setting &lt;code&gt;pager.blame&lt;/code&gt; to &lt;code&gt;less -S&lt;/code&gt; enables line truncation only for &lt;code&gt;git blame&lt;/code&gt;.</source>
          <target state="translated">当未设置 &lt;code&gt;LESS&lt;/code&gt; 环境变量时，Git会将其设置为 &lt;code&gt;FRX&lt;/code&gt; （如果设置了 &lt;code&gt;LESS&lt;/code&gt; 环境变量，则Git根本不会更改它）。如果你想选择覆写Git的默认设置 &lt;code&gt;LESS&lt;/code&gt; ，你可以设置 &lt;code&gt;core.pager&lt;/code&gt; 到如 &lt;code&gt;less -S&lt;/code&gt; 。这将由Git传递给Shell，它将最终命令转换为 &lt;code&gt;LESS=FRX less -S&lt;/code&gt; 。环境未设置 &lt;code&gt;S&lt;/code&gt; 选项，但命令行设置了该选项，减少了截断长行的指示。同样，如果设置 &lt;code&gt;core.pager&lt;/code&gt; 到 &lt;code&gt;less -+F&lt;/code&gt; 将停用 &lt;code&gt;F&lt;/code&gt; 由环境从命令行指定的选项，停用了 &lt;code&gt;less&lt;/code&gt; 的&amp;ldquo;如果一个屏幕退出&amp;rdquo;的行为。可以专门为某些命令激活一些标志：例如，将 &lt;code&gt;pager.blame&lt;/code&gt; 设置为 &lt;code&gt;less -S&lt;/code&gt; 仅对 &lt;code&gt;git blame&lt;/code&gt; 启用行截断。</target>
        </trans-unit>
        <trans-unit id="74ad9f83ee4c2323b6a50919a4a444bb844e349c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable is changed, the file system monitor is added to or removed from the index the next time a command reads the index. When &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; are used, the file system monitor is immediately added to or removed from the index.</source>
          <target state="translated">更改 &lt;code&gt;core.fsmonitor&lt;/code&gt; 配置变量后，下次命令读取索引时，会将文件系统监视器添加到索引中或从索引中删除。使用 &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; ，文件系统监视器将立即添加到索引中或从索引中删除。</target>
        </trans-unit>
        <trans-unit id="a4c9cc7c80e5659747cb4b3bf0914ba1addde698" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable is changed, the untracked cache is added to or removed from the index the next time a command reads the index; while when &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; are used, the untracked cache is immediately added to or removed from the index.</source>
          <target state="translated">更改 &lt;code&gt;core.untrackedCache&lt;/code&gt; 配置变量后，下次命令读取索引时，会将未跟踪的高速缓存添加到索引中或从索引中删除；当使用 &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; ，立即将未跟踪的高速缓存添加到索引或从索引中删除。</target>
        </trans-unit>
        <trans-unit id="a212ca612f0b7b9b082dffe71078dd396d414402" translate="yes" xml:space="preserve">
          <source>When the attribute &lt;code&gt;ident&lt;/code&gt; is set for a path, Git replaces &lt;code&gt;$Id$&lt;/code&gt; in the blob object with &lt;code&gt;$Id:&lt;/code&gt;, followed by the 40-character hexadecimal blob object name, followed by a dollar sign &lt;code&gt;$&lt;/code&gt; upon checkout. Any byte sequence that begins with &lt;code&gt;$Id:&lt;/code&gt; and ends with &lt;code&gt;$&lt;/code&gt; in the worktree file is replaced with &lt;code&gt;$Id$&lt;/code&gt; upon check-in.</source>
          <target state="translated">为路径设置属性 &lt;code&gt;ident&lt;/code&gt; 时，Git用 &lt;code&gt;$Id$&lt;/code&gt; 替换blob对象中的 &lt;code&gt;$Id:&lt;/code&gt; ，后跟40个字符的十六进制blob对象名，然后在结帐时加上美元符号 &lt;code&gt;$&lt;/code&gt; 。与开头的字节序列 &lt;code&gt;$Id:&lt;/code&gt; 和结束与 &lt;code&gt;$&lt;/code&gt; 在worktree文件被替换 &lt;code&gt;$Id$&lt;/code&gt; 在办理登机手续。</target>
        </trans-unit>
        <trans-unit id="fa514f01de77ed627378917f2aa0b40cefa8c9a0" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the files and directories to be cleaned, and goes into its interactive command loop.</source>
          <target state="translated">当命令进入交互模式后,会显示出要清理的文件和目录,并进入其交互命令循环。</target>
        </trans-unit>
        <trans-unit id="8e767c7023b00ca52d4fb770ab49ce4dc284f987" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the output of the &lt;code&gt;status&lt;/code&gt; subcommand, and then goes into its interactive command loop.</source>
          <target state="translated">当命令进入交互模式时，它将显示 &lt;code&gt;status&lt;/code&gt; 子命令的输出，然后进入其交互命令循环。</target>
        </trans-unit>
        <trans-unit id="e95952399796aad65deb415e39c303153d01cdf9" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the current directory relative to the top-level directory.</source>
          <target state="translated">当从子目录调用命令时,显示当前目录相对于顶层目录的路径。</target>
        </trans-unit>
        <trans-unit id="45506eccf72696bf6e0287a6eeda327142bb0f41" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the top-level directory relative to the current directory (typically a sequence of &quot;../&quot;, or an empty string).</source>
          <target state="translated">当从子目录中调用命令时,显示顶层目录相对于当前目录的路径(通常是&quot;./&quot;的序列,或一个空字符串)。</target>
        </trans-unit>
        <trans-unit id="609d76b7287e730d5e5fcae1b57a1cde4d02d1ae" translate="yes" xml:space="preserve">
          <source>When the command is run without pathspec, it errors out, instead of deinit-ing everything, to prevent mistakes.</source>
          <target state="translated">当命令在没有pathspec的情况下运行时,会出错,而不是deinit-ing一切,以防止错误。</target>
        </trans-unit>
        <trans-unit id="2ebded60d45ed8776b0324d8d2138df90f552a15" translate="yes" xml:space="preserve">
          <source>When the command line does not specify what to push with &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; arguments or &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--mirror&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt; options, the command finds the default &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; by consulting &lt;code&gt;remote.*.push&lt;/code&gt; configuration, and if it is not found, honors &lt;code&gt;push.default&lt;/code&gt; configuration to decide what to push (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for the meaning of &lt;code&gt;push.default&lt;/code&gt;).</source>
          <target state="translated">当命令行未使用 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; &lt;code&gt;--mirror&lt;/code&gt; &amp;gt; ...自变量或 &lt;code&gt;--all&lt;/code&gt; ，-- mirror，-- &lt;code&gt;--tags&lt;/code&gt; 选项指定要推送的内容时，该命令将通过参考 &lt;code&gt;remote.*.push&lt;/code&gt; 配置查找默认的 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; ，然后如果未找到，则使用 &lt;code&gt;push.default&lt;/code&gt; 配置来决定要推送的内容（有关 &lt;code&gt;push.default&lt;/code&gt; 的含义，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4f61ade639e58b8586884fe92cb9eea816606ac2" translate="yes" xml:space="preserve">
          <source>When the command line does not specify where to push with the &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument, &lt;code&gt;branch.*.remote&lt;/code&gt; configuration for the current branch is consulted to determine where to push. If the configuration is missing, it defaults to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">当命令行未使用 &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; 参数指定推送位置时，将查询当前分支的 &lt;code&gt;branch.*.remote&lt;/code&gt; 配置以确定推送位置。如果缺少配置，则默认为 &lt;code&gt;origin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dd963bd8e58b7ff2b11f8f622df35ecbcf28d58" translate="yes" xml:space="preserve">
          <source>When the commit diffs differ, &lt;code&gt;git range-diff&lt;/code&gt; recreates the original diffs' coloring, and adds outer -/+ diff markers with the &lt;strong&gt;background&lt;/strong&gt; being red/green to make it easier to see e.g. when there was a change in what exact lines were added.</source>
          <target state="translated">当提交差异不同时， &lt;code&gt;git range-diff&lt;/code&gt; 会重新创建原始差异的颜色，并添加外部-/ +差异标记，&lt;strong&gt;背景&lt;/strong&gt;为红色/绿色，以便于查看，例如，当添加的确切行发生更改时。</target>
        </trans-unit>
        <trans-unit id="3625aba84b870871330cdfd48d8779c4e4badb58" translate="yes" xml:space="preserve">
          <source>When the commit log message begins with &quot;squash! &amp;hellip;​&quot; (or &quot;fixup! &amp;hellip;​&quot;), and there is already a commit in the todo list that matches the same &lt;code&gt;...&lt;/code&gt;, automatically modify the todo list of rebase -i so that the commit marked for squashing comes right after the commit to be modified, and change the action of the moved commit from &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;squash&lt;/code&gt; (or &lt;code&gt;fixup&lt;/code&gt;). A commit matches the &lt;code&gt;...&lt;/code&gt; if the commit subject matches, or if the &lt;code&gt;...&lt;/code&gt; refers to the commit&amp;rsquo;s hash. As a fall-back, partial matches of the commit subject work, too. The recommended way to create fixup/squash commits is by using the &lt;code&gt;--fixup&lt;/code&gt;/&lt;code&gt;--squash&lt;/code&gt; options of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">当提交日志消息以&amp;ldquo; squash！&amp;hellip;&amp;rdquo;（或&amp;ldquo; fixup！&amp;hellip;``&amp;rdquo;）开头，并且在待办事项列表中已经存在与相同 &lt;code&gt;...&lt;/code&gt; 匹配的提交时，自动修改rebase -i的待办事项列表。这样，标记为压扁的提交就在要修改的提交之后出现，并将移动的提交的动作从 &lt;code&gt;pick&lt;/code&gt; 更改为 &lt;code&gt;squash&lt;/code&gt; （或 &lt;code&gt;fixup&lt;/code&gt; ）。如果提交主题匹配，或者 &lt;code&gt;...&lt;/code&gt; 引用提交的哈希，则提交与 &lt;code&gt;...&lt;/code&gt; 匹配。作为后备，提交主题的部分匹配也起作用。创建fixup / squash提交的推荐方法是使用&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;的 &lt;code&gt;--fixup&lt;/code&gt; / &lt;code&gt;--squash&lt;/code&gt; 选项。。</target>
        </trans-unit>
        <trans-unit id="777196d17b1a10c66d0cd105e5fb66da2363f7b1" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.partialclone&lt;/code&gt; is set, it indicates that the repo was created with a partial clone (or later performed a partial fetch) and that the remote may have omitted sending certain unwanted objects. Such a remote is called a &quot;promisor remote&quot; and it promises that all such omitted objects can be fetched from it in the future.</source>
          <target state="translated">设置配置密钥 &lt;code&gt;extensions.partialclone&lt;/code&gt; 时，它表示该回购是使用部分克隆创建的（或稍后执行部分提取的操作），并且遥控器可能已省略了发送某些不需要的对象的操作。这种远程称为&amp;ldquo;承诺远程&amp;rdquo;，它承诺将来可以从中获取所有这些省略的对象。</target>
        </trans-unit>
        <trans-unit id="ef73607bec133cc1d32aaf64deafc8c72104731d" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.preciousObjects&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, objects in the repository MUST NOT be deleted (e.g., by &lt;code&gt;git-prune&lt;/code&gt; or &lt;code&gt;git repack -d&lt;/code&gt;).</source>
          <target state="translated">当配置键 &lt;code&gt;extensions.preciousObjects&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 时，不得删除存储库中的对象（例如，通过 &lt;code&gt;git-prune&lt;/code&gt; 或 &lt;code&gt;git repack -d&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e23e26ad367e6b915821bbb7b38753fa6fd4c240" translate="yes" xml:space="preserve">
          <source>When the current working directory is below the repository directory print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">当当前工作目录在仓库目录下时打印 &quot;true&quot;,否则打印 &quot;false&quot;。</target>
        </trans-unit>
        <trans-unit id="8a7aa53d7bbe6bfa657a2a1bb84359882384d7fa" translate="yes" xml:space="preserve">
          <source>When the current working directory is inside the work tree of the repository print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">当当前工作目录在仓库的工作树内时打印 &quot;true&quot;,否则打印 &quot;false&quot;。</target>
        </trans-unit>
        <trans-unit id="e614fb1c074d0b3ebd865c7756d786dc01074ea4" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called to generate diffs, and Git does not use its builtin diff machinery. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7dc6a4dcd86a8d725c2332772df83ad820f427" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called, instead of the diff invocation described above. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="translated">设置环境变量 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 时，将调用由其命名的程序，而不是上述的diff调用。对于添加，删除或修改的路径，使用7个参数调用 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ec4de571b6827b1e0107c62834d6f8cf9f50bba2" translate="yes" xml:space="preserve">
          <source>When the git-rebase command is run, it will first execute a &quot;pre-rebase&quot; hook if one exists. You can use this hook to do sanity checks and reject the rebase if it isn&amp;rsquo;t appropriate. Please see the template pre-rebase hook script for an example.</source>
          <target state="translated">运行git-rebase命令时，如果存在，它将首先执行&amp;ldquo; pre-rebase&amp;rdquo;钩子。您可以使用此挂钩进行健全性检查，如果不合适的话，可以拒绝重新设置基准。有关示例，请参阅模板变基前挂钩脚本。</target>
        </trans-unit>
        <trans-unit id="4663df00f4cd516023be3e887d8ecce789e72f00" translate="yes" xml:space="preserve">
          <source>When the history involves criss-cross merges, there can be more than one &lt;code&gt;best&lt;/code&gt; common ancestor for two commits. For example, with this topology:</source>
          <target state="translated">当历史涉及纵横交错的合并时，两次提交可能有多个 &lt;code&gt;best&lt;/code&gt; 共同祖先。例如，使用此拓扑：</target>
        </trans-unit>
        <trans-unit id="58beafa5cea14c3b99014fb314d938b1ee9fac65" translate="yes" xml:space="preserve">
          <source>When the man viewer, specified by the &lt;code&gt;man.viewer&lt;/code&gt; configuration variables, is not among the supported ones, then the corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration variable will be looked up. If this variable exists then the specified tool will be treated as a custom command and a shell eval will be used to run the command with the man page passed as arguments.</source>
          <target state="translated">如果由 &lt;code&gt;man.viewer&lt;/code&gt; 配置变量指定的man查看器不在受支持的对象中，则将查找对应的 &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 配置变量。如果存在此变量，则将指定的工具视为自定义命令，并且将使用shell eval将手册页作为参数传递来运行该命令。</target>
        </trans-unit>
        <trans-unit id="d01c091e9d01b5baf9f294a1d7b9c823d7d014bc" translate="yes" xml:space="preserve">
          <source>When the output goes to a terminal, it is color-coded by default, just like regular &lt;code&gt;git diff&lt;/code&gt;'s output. In addition, the first line (adding a commit) is green, the last line (deleting a commit) is red, the second line (with a perfect match) is yellow like the commit header of &lt;code&gt;git
show&lt;/code&gt;'s output, and the third line colors the old commit red, the new one green and the rest like &lt;code&gt;git show&lt;/code&gt;'s commit header.</source>
          <target state="translated">当输出到达终端时，默认情况下会使用彩色编码，就像常规 &lt;code&gt;git diff&lt;/code&gt; 的输出一样。此外，第一行（添加提交）为绿色，最后一行（删除提交）为红色，第二行（具有完美匹配）为黄色，就像 &lt;code&gt;git show&lt;/code&gt; 的输出的提交标头一样，第三行一行为旧提交红色，新提交绿色，其余为 &lt;code&gt;git show&lt;/code&gt; 的提交标头。</target>
        </trans-unit>
        <trans-unit id="ecf68ce55bda2542529810833e005e7f157f71c2" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. &lt;code&gt;--no-3way&lt;/code&gt; can be used to override am.threeWay configuration variable. For more information, see am.threeWay in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">如果补丁不能完全适用，则如果该补丁记录了它应该应用于的Blob的身份，并且我们可以在本地使用这些Blob，则退回到三路合并。 &lt;code&gt;--no-3way&lt;/code&gt; 可用于覆盖am.threeWay配置变量。有关更多信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]中的&lt;/a&gt; am.threeWay 。</target>
        </trans-unit>
        <trans-unit id="28728fcf386b485f532ec99285643062f0405ba5" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to, and we have those blobs available locally, possibly leaving the conflict markers in the files in the working tree for the user to resolve. This option implies the &lt;code&gt;--index&lt;/code&gt; option, and is incompatible with the &lt;code&gt;--reject&lt;/code&gt; and the &lt;code&gt;--cached&lt;/code&gt; options.</source>
          <target state="translated">如果补丁不能完全适用，则如果该补丁记录了它应该应用于的Blob的标识，则退回到三路合并，并且这些Blob在本地可用，可能会将冲突标记保留在工作树的文件中供用户解决。此选项暗含 &lt;code&gt;--index&lt;/code&gt; 选项，并且与 &lt;code&gt;--reject&lt;/code&gt; 和 &lt;code&gt;--cached&lt;/code&gt; 选项不兼容。</target>
        </trans-unit>
        <trans-unit id="bdd1b4760c591dff915e966378bff929405d28b1" translate="yes" xml:space="preserve">
          <source>When the push is complete, outputs one or more &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; or &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; lines to indicate success or failure of each pushed ref. The status report output is terminated by a blank line. The option field &amp;lt;why&amp;gt; may be quoted in a C style string if it contains an LF.</source>
          <target state="translated">推送完成后，输出一个或多个 &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; 或 &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; 线表示每个推送参考的成功或失败。状态报告输出以空白行终止。如果选项字段&amp;lt;why&amp;gt;包含LF，则可以在C样式字符串中加引号。</target>
        </trans-unit>
        <trans-unit id="c36826b0bb47b2400e28127fc2b6b138c228a63f" translate="yes" xml:space="preserve">
          <source>When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the &lt;code&gt;+&lt;/code&gt; sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.</source>
          <target state="translated">当已知要提取的远程分支定期重绕并重新设置基准时，可以预期其新提示将不会是其先前提示的后代（上次获取时存储在您的远程跟踪分支中）。您可能希望使用 &lt;code&gt;+&lt;/code&gt; 号表示此类分支需要非快进更新。无法通过这种行为来确定或声明分支将在存储库中可用；拉取用户只需知道这是分支的预期使用模式即可。</target>
        </trans-unit>
        <trans-unit id="c2d02d0fdbdd6b68f91184ab0fd8a5fcfd84e982" translate="yes" xml:space="preserve">
          <source>When the repository is bare print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">当存储库为裸露时打印 &quot;true&quot;,否则打印 &quot;false&quot;。</target>
        </trans-unit>
        <trans-unit id="4881892c9231f2a8cbf0d32abf5995af521026ca" translate="yes" xml:space="preserve">
          <source>When the repository is shallow print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">当库位较浅时打印 &quot;true&quot;,否则打印 &quot;false&quot;。</target>
        </trans-unit>
        <trans-unit id="37826a890a4b64bdd1230276a23bd80630675ca5" translate="yes" xml:space="preserve">
          <source>When the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; has the commit at a tip of a ref that is different from the ref you have locally, you can use the &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; syntax, to have its local name, a colon &lt;code&gt;:&lt;/code&gt;, and its remote name.</source>
          <target state="translated">当以 &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 命名的存储库在与本地引用不同的ref的提示处提交时，可以使用 &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; 语法，以其本地名称冒号 &lt;code&gt;:&lt;/code&gt; ，和它的远程名称。</target>
        </trans-unit>
        <trans-unit id="a7fe7f8247bda757ca8d697055bcfe0913ae2caf" translate="yes" xml:space="preserve">
          <source>When the repository to clone from is on a local machine, this flag bypasses the normal &quot;Git aware&quot; transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories. The files under &lt;code&gt;.git/objects/&lt;/code&gt; directory are hardlinked to save space when possible.</source>
          <target state="translated">当要从中进行克隆的存储库位于本地计算机上时，此标志将绕过常规的&amp;ldquo; Git感知&amp;rdquo;传输机制，并通过在对象和引用目录下创建HEAD以及所有内容的副本来克隆存储库。 &lt;code&gt;.git/objects/&lt;/code&gt; 目录下的文件经过硬链接以尽可能节省空间。</target>
        </trans-unit>
        <trans-unit id="87edb2bef2f28c0f63de7720d331d50db0279e94" translate="yes" xml:space="preserve">
          <source>When the repository to clone is on the local machine, instead of using hard links, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to share the objects with the source repository. The resulting repository starts out without any object of its own.</source>
          <target state="translated">当要克隆的存储库位于本地计算机上时，而不是使用硬链接，而是自动设置 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; 与源存储库共享对象。生成的存储库开始时没有其自己的任何对象。</target>
        </trans-unit>
        <trans-unit id="e18b845f941d21aaf5232c387f67cb23d0a4e759" translate="yes" xml:space="preserve">
          <source>When the result of a &lt;code&gt;git bisect&lt;/code&gt; is a non-merge commit, you should normally be able to discover the problem by examining just that commit. Developers can make this easy by breaking their changes into small self-contained commits. That won&amp;rsquo;t help in the case above, however, because the problem isn&amp;rsquo;t obvious from examination of any single commit; instead, a global view of the development is required. To make matters worse, the change in semantics in the problematic function may be just one small part of the changes in the upper line of development.</source>
          <target state="translated">当 &lt;code&gt;git bisect&lt;/code&gt; 的结果是非合并提交时，通常应该可以通过仅检查该提交来发现问题。开发人员可以通过将更改分成小的独立提交来简化此过程。但是，这在上面的情况下无济于事，因为从检查任何一次提交来看问题都不明显；取而代之的是，需要对发展情况有一个全局的认识。更糟糕的是，问题功能中语义的更改可能只是开发上限更改的一小部分。</target>
        </trans-unit>
        <trans-unit id="57dfd8622d0e5d97d5c5344dbdac2c35010a468d" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, shared index files that were not modified since the time this variable specifies will be removed when a new shared index file is created. The value &quot;now&quot; expires all entries immediately, and &quot;never&quot; suppresses expiration altogether. The default value is &quot;2.weeks.ago&quot;. Note that a shared index file is considered modified (for the purpose of expiration) each time a new split-index file is either created based on it or read from it. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">使用拆分索引功能时，在创建新的共享索引文件时，将删除自此变量指定的时间以来未修改的共享索引文件。值&amp;ldquo;现在&amp;rdquo;立即使所有条目到期，而值&amp;ldquo;从不&amp;rdquo;则完全禁止到期。默认值为&amp;ldquo; 2.weeks.ago&amp;rdquo;。请注意，每次基于共享索引文件创建新的拆分索引文件或从中读取拆分索引文件时，都将其视为已修改（出于过期目的）。参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="887ef75c2523fd6b4da84b3a0a714f4995305746" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, this specifies the percent of entries the split index can contain compared to the total number of entries in both the split index and the shared index before a new shared index is written. The value should be between 0 and 100. If the value is 0 then a new shared index is always written, if it is 100 a new shared index is never written. By default the value is 20, so a new shared index is written if the number of entries in the split index would be greater than 20 percent of the total number of entries. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">使用拆分索引功能时，它指定在写入新的共享索引之前，拆分索引可以包含的条目数与拆分索引和共享索引中的条目总数的百分比。该值应介于0到100之间。如果该值为0，则始终写入新的共享索引；如果为100，则永远不会写入新的共享索引。默认情况下，该值为20，因此，如果拆分索引中的条目数大于条目总数的20％，则会写入新的共享索引。参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1631afdb92ffecd0a40ddcd8f40433691ff79d82" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt; (or just &lt;code&gt;i&lt;/code&gt;), the rebase is run in interactive mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249674ff1351f5c865508a34f368a209ce692426" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt;, the rebase is run in interactive mode.</source>
          <target state="translated">当值是 &lt;code&gt;interactive&lt;/code&gt; ，rebase以交互模式运行。</target>
        </trans-unit>
        <trans-unit id="2a8620af5de619d02cbdb1290090cf457f4270c6" translate="yes" xml:space="preserve">
          <source>When the working tree is updated, using --recurse-submodules will also recursively reset the working tree of all active submodules according to the commit recorded in the superproject, also setting the submodules' HEAD to be detached at that commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc30d1504ae5818b5ebed3f68f464e3d8d41b06" translate="yes" xml:space="preserve">
          <source>When there are approximately more than this many loose objects in the repository, &lt;code&gt;git gc --auto&lt;/code&gt; will pack them. Some Porcelain commands use this command to perform a light-weight garbage collection from time to time. The default value is 6700.</source>
          <target state="translated">当存储库中的松散对象大约超过这个数目时， &lt;code&gt;git gc --auto&lt;/code&gt; 会将它们打包。某些瓷器命令会不时使用此命令执行轻量级垃圾收集。默认值为6700。</target>
        </trans-unit>
        <trans-unit id="c316674f184677333eb7d2b00fe1f02bf0eda4b8" translate="yes" xml:space="preserve">
          <source>When there are content conflicts, the merge machinery tries to annotate each side&amp;rsquo;s conflict markers with the commits where the content came from. Since the apply backend drops the original information about the rebased commits and their parents (and instead generates new fake commits based off limited information in the generated patches), those commits cannot be identified; instead it has to fall back to a commit summary. Also, when merge.conflictStyle is set to diff3, the apply backend will use &quot;constructed merge base&quot; to label the content from the merge base, and thus provide no information about the merge base commit whatsoever.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62fefa7cb364ff9a836bef0837ac15925fecc8f2" translate="yes" xml:space="preserve">
          <source>When there are more than this many packs that are not marked with &lt;code&gt;*.keep&lt;/code&gt; file in the repository, &lt;code&gt;git gc
--auto&lt;/code&gt; consolidates them into one larger pack. The default value is 50. Setting this to 0 disables it. Setting &lt;code&gt;gc.auto&lt;/code&gt; to 0 will also disable this.</source>
          <target state="translated">如果在存储库中有很多未用 &lt;code&gt;*.keep&lt;/code&gt; 文件标记的包， &lt;code&gt;git gc --auto&lt;/code&gt; 会将它们合并为一个更大的包。默认值为50。将其设置为0将禁用它。将 &lt;code&gt;gc.auto&lt;/code&gt; 设置为0也将禁用此功能。</target>
        </trans-unit>
        <trans-unit id="a99bf9777c550eb2f6602e82876314f8cadcb15d" translate="yes" xml:space="preserve">
          <source>When there is only one argument given and it is not &lt;code&gt;--&lt;/code&gt; (e.g. &lt;code&gt;git
checkout abc&lt;/code&gt;), and when the argument is both a valid &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (e.g. a branch &lt;code&gt;abc&lt;/code&gt; exists) and a valid &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (e.g. a file or a directory whose name is &quot;abc&quot; exists), Git would usually ask you to disambiguate. Because checking out a branch is so common an operation, however, &lt;code&gt;git checkout abc&lt;/code&gt; takes &quot;abc&quot; as a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; in such a situation. Use &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; if you want to checkout these paths out of the index.</source>
          <target state="translated">当存在仅给出一个参数，它不是 &lt;code&gt;--&lt;/code&gt; （例如 &lt;code&gt;git checkout abc&lt;/code&gt; ），并且当参数是既有效 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; （例如，分支 &lt;code&gt;abc&lt;/code&gt; 存在）和一个有效的 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (例如，文件或名称为&amp;ldquo; abc&amp;rdquo;的目录），Git通常会要求您消除歧义。因为签出分支是一项常见的操作，但是，在这种情况下， &lt;code&gt;git checkout abc&lt;/code&gt; 将&amp;ldquo; abc&amp;rdquo;作为 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 。如果 &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; 索引中检出这些路径，请使用git checkout-&amp;lt;pathspec&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="3ff1d02c565a22d417998ec283b077273b716d4a" translate="yes" xml:space="preserve">
          <source>When these environment variables are set, the corresponding command-line arguments may not be used.</source>
          <target state="translated">当设置这些环境变量时,可能不会使用相应的命令行参数。</target>
        </trans-unit>
        <trans-unit id="86c4d2dcd046b538b0d9c792061f20bffd3f8c8e" translate="yes" xml:space="preserve">
          <source>When this flag is provided, the pack is read from stdin instead and a copy is then written to &amp;lt;pack-file&amp;gt;. If &amp;lt;pack-file&amp;gt; is not specified, the pack is written to objects/pack/ directory of the current Git repository with a default name determined from the pack content. If &amp;lt;pack-file&amp;gt; is not specified consider using --keep to prevent a race condition between this process and &lt;code&gt;git repack&lt;/code&gt;.</source>
          <target state="translated">提供此标志时，将改为从stdin中读取包，然后将副本写入&amp;lt;pack-file&amp;gt;。如果未指定&amp;lt;pack-file&amp;gt;，则使用默认的名称（根据包内容确定）将其写入当前Git存储库的objects / pack /目录。如果未指定&amp;lt;pack-file&amp;gt;，请考虑使用--keep来防止此进程与 &lt;code&gt;git repack&lt;/code&gt; 之间发生竞争。</target>
        </trans-unit>
        <trans-unit id="c91915e7d5f6096e68c1652d49f4ac505147354d" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the object names recorded for the paths are not updated. Instead, this option sets/unsets the &quot;assume unchanged&quot; bit for the paths. When the &quot;assume unchanged&quot; bit is on, the user promises not to change the file and allows Git to assume that the working tree file matches what is recorded in the index. If you want to change the working tree file, you need to unset the bit to tell Git. This is sometimes helpful when working with a big project on a filesystem that has very slow lstat(2) system call (e.g. cifs).</source>
          <target state="translated">当指定这个标志时,不会更新路径中记录的对象名称。相反,这个选项会设置/取消路径的 &quot;假定不变 &quot;位。当 &quot;假定不变 &quot;位开启时,用户承诺不更改文件,并允许 Git 假定工作树文件与索引中记录的内容一致。如果你想改变工作树文件,你需要取消设置该位来告诉 Git。这在处理一个大项目时,有时会很有帮助,因为这个项目的文件系统的lstat(2)系统调用速度很慢(比如cifs)。</target>
        </trans-unit>
        <trans-unit id="b1f75c6b9b1b22670befceda22525699cad697f2" translate="yes" xml:space="preserve">
          <source>When this form of &lt;code&gt;git read-tree&lt;/code&gt; returns successfully, you can see which of the &quot;local changes&quot; that you made were carried forward by running &lt;code&gt;git diff-index --cached $M&lt;/code&gt;. Note that this does not necessarily match what &lt;code&gt;git diff-index --cached $H&lt;/code&gt; would have produced before such a two tree merge. This is because of cases 18 and 19 --- if you already had the changes in $M (e.g. maybe you picked it up via e-mail in a patch form), &lt;code&gt;git diff-index
--cached $H&lt;/code&gt; would have told you about the change before this merge, but it would not show in &lt;code&gt;git diff-index --cached $M&lt;/code&gt; output after the two-tree merge.</source>
          <target state="translated">当这种形式的 &lt;code&gt;git read-tree&lt;/code&gt; 成功返回时，您可以通过运行 &lt;code&gt;git diff-index --cached $M&lt;/code&gt; 来查看进行了哪些&amp;ldquo;本地更改&amp;rdquo; 。请注意，这不一定与 &lt;code&gt;git diff-index --cached $H&lt;/code&gt; 在这样的两棵树合并之前产生的结果匹配。这是由于情况18和19 ---如果您已经在$ M中进行了更改（例如，您可能以补丁程序形式通过电子邮件将其获取了），则 &lt;code&gt;git diff-index --cached $H&lt;/code&gt; 会告诉您关于此合并之前的更改的信息，但是在两棵树合并之后，不会在 &lt;code&gt;git diff-index --cached $M&lt;/code&gt; 输出中显示。</target>
        </trans-unit>
        <trans-unit id="a7b5d3881356f9c9c7fd25660fd80f9c16873a97" translate="yes" xml:space="preserve">
          <source>When this option is specified, the behavior is as if a special &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; argument were added at the beginning of the command line, where &amp;lt;value&amp;gt; is taken to be the standard output of the specified command with any leading and trailing whitespace trimmed off.</source>
          <target state="translated">指定此选项后，行为就像在命令行的开头添加了特殊的 &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 参数一样，其中&amp;lt;value&amp;gt;被视为指定命令的标准输出，并带有任何前导和尾随空白修剪掉。</target>
        </trans-unit>
        <trans-unit id="fe0e96d95c4eefa9bfe72917d015cf48a18efcc2" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de58814133990da5a575ac12a35ef9b3b981ae4a" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves. Note that any components which are missing from the URL (e.g., there is no username in the example above) will be set to empty; if you want to provide a URL and override some attributes, provide the URL attribute first, followed by any overrides.</source>
          <target state="translated">当 &lt;code&gt;git credential&lt;/code&gt; 读取此特殊属性时，该值将解析为URL，并视为已读取其组成部分（例如， &lt;code&gt;url=https://example.com&lt;/code&gt; 的行为就好像 &lt;code&gt;protocol=https&lt;/code&gt; 和 &lt;code&gt;host=example.com&lt;/code&gt; 已提供）。这可以帮助呼叫者避免自己解析URL。请注意，URL中缺少的任何组件（例如，在上面的示例中没有用户名）将被设置为空；如果要提供URL并覆盖某些属性，请首先提供URL属性，然后再提供任何覆盖。</target>
        </trans-unit>
        <trans-unit id="882eafec7b82da90c1fd3ae7dc7040457d013cf9" translate="yes" xml:space="preserve">
          <source>When trace files are written to a target directory, they will be named according to the last component of the SID (optionally followed by a counter to avoid filename collisions).</source>
          <target state="translated">当跟踪文件被写入目标目录时,它们将根据SID的最后一个组件命名(可选择在后面加一个计数器以避免文件名冲突)。</target>
        </trans-unit>
        <trans-unit id="1771ffd8c74f9f0b2e623ff3c52581b28a17469b" translate="yes" xml:space="preserve">
          <source>When tracking multiple directories (using --stdlayout, --branches, or --tags options), git svn will attempt to connect to the root (or highest allowed level) of the Subversion repository. This default allows better tracking of history if entire projects are moved within a repository, but may cause issues on repositories where read access restrictions are in place. Passing &lt;code&gt;--no-minimize-url&lt;/code&gt; will allow git svn to accept URLs as-is without attempting to connect to a higher level directory. This option is off by default when only one URL/branch is tracked (it would do little good).</source>
          <target state="translated">当跟踪多个目录（使用--stdlayout，--branches或--tags选项）时，git svn将尝试连接到Subversion存储库的根目录（或允许的最高级别）。如果整个项目都在存储库中移动，则使用默认值可以更好地跟踪历史记录，但是可能会在存在读取访问限制的存储库上引起问题。传递 &lt;code&gt;--no-minimize-url&lt;/code&gt; 将允许git svn照原样接受URL，而无需尝试连接到更高级别的目录。当仅跟踪一个URL /分支时，默认情况下此选项为关闭（效果不佳）。</target>
        </trans-unit>
        <trans-unit id="442a6a05d34f849ad275ea5e7d6f50f5aafe59d9" translate="yes" xml:space="preserve">
          <source>When true, and when reachability bitmaps are enabled, pack-objects will try to send parts of the bitmapped packfile verbatim. This can reduce memory and CPU usage to serve fetches, but might result in sending a slightly larger pack. Defaults to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce35b3add797f616ba5b3be537b437a03e625f0" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;false&lt;/code&gt; unless &lt;code&gt;feature.experimental&lt;/code&gt; is enabled.</source>
          <target state="translated">如果为true，git会默认使用 &lt;code&gt;--sparse&lt;/code&gt; 在选项 &lt;code&gt;git pack-objects&lt;/code&gt; 时 &lt;code&gt;--revs&lt;/code&gt; 选项存在。该算法仅遍历出现在引入新对象的路径中的树。在计算包裹以发送小额零钱时，这可能具有显着的性能优势。但是，如果包含的提交包含某些类型的直接重命名，则可能会将额外的对象添加到打包文件。除非启用 &lt;code&gt;feature.experimental&lt;/code&gt; ,否则默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a46d4189a8b9229b7d91d54cdebfebe81ffd9ae6" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d73311a3b4a00977d7e2237078b01efb9320bfa" translate="yes" xml:space="preserve">
          <source>When true, git will include a &quot;hash cache&quot; section in the bitmap index (if one is written). This cache can be used to feed git&amp;rsquo;s delta heuristics, potentially leading to better deltas between bitmapped and non-bitmapped objects (e.g., when serving a fetch between an older, bitmapped pack and objects that have been pushed since the last gc). The downside is that it consumes 4 bytes per object of disk space. Defaults to true.</source>
          <target state="translated">如果为true，则git将在位图索引中包含&amp;ldquo;哈希缓存&amp;rdquo;部分（如果已写入）。该缓存可用于馈送git的增量启发式，有可能导致位图对象与非位图对象之间的增量更好（例如，在较旧的位图包与自上次gc之后推送的对象之间进行获取时）。缺点是每个对象磁盘空间消耗4个字节。默认为true。</target>
        </trans-unit>
        <trans-unit id="98f36898b39f3ac14609adb644f7b367554be4b3" translate="yes" xml:space="preserve">
          <source>When true, git will use pack bitmaps (if available) when packing to stdout (e.g., during the server side of a fetch). Defaults to true. You should not generally need to turn this off unless you are debugging pack bitmaps.</source>
          <target state="translated">当为 &quot;true &quot;时,git 会在打包到 stdout 时使用打包位图(如果有的话)(例如,在取件的服务器端)。默认值为true。一般来说,除非你在调试打包位图,否则不需要关闭这个选项。</target>
        </trans-unit>
        <trans-unit id="3060361b8b64f7f4f15aa5d402b402d65fd1ef21" translate="yes" xml:space="preserve">
          <source>When true, git will write a bitmap index when packing all objects to disk (e.g., when &lt;code&gt;git repack -a&lt;/code&gt; is run). This index can speed up the &quot;counting objects&quot; phase of subsequent packs created for clones and fetches, at the cost of some disk space and extra time spent on the initial repack. This has no effect if multiple packfiles are created. Defaults to true on bare repos, false otherwise.</source>
          <target state="translated">如果为true，则git在将所有对象打包到磁盘时（例如，运行 &lt;code&gt;git repack -a&lt;/code&gt; 时）将写入位图索引。该索引可以加快为克隆和提取创建的后续包的&amp;ldquo;计数对象&amp;rdquo;阶段，但要花一些磁盘空间和花在初始重新打包上的额外时间。如果创建了多个packfile，这将无效。对于裸仓库，默认为true，否则为false。</target>
        </trans-unit>
        <trans-unit id="b7b0c56b83a62c5cf7d9e0b77ba1430747588d7a" translate="yes" xml:space="preserve">
          <source>When true, rebase branches on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;branch.&amp;lt;name&amp;gt;.rebase&quot; for setting this on a per-branch basis.</source>
          <target state="translated">为true时，将在已获取分支的顶部重新分支，而不是在运行&amp;ldquo; git pull&amp;rdquo;时从默认远程合并默认分支。请参阅&amp;ldquo; branch。&amp;lt;名称&amp;gt; .rebase&amp;rdquo;以基于每个分支进行设置。</target>
        </trans-unit>
        <trans-unit id="c15c8ba9ac152f7e581087f6ca67eb8a95961a05" translate="yes" xml:space="preserve">
          <source>When true, rebase the branch &amp;lt;name&amp;gt; on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;pull.rebase&quot; for doing this in a non branch-specific manner.</source>
          <target state="translated">设置为true时，将分支&amp;lt;名称&amp;gt;重新设置在获取的分支之上，而不是在运行&amp;ldquo; git pull&amp;rdquo;时从默认远程合并默认分支。请参阅&amp;ldquo; pull.rebase&amp;rdquo;以非特定于分支的方式执行此操作。</target>
        </trans-unit>
        <trans-unit id="32f2ccfcaf97ac2d1b8fdcbcf4ee46e8d18499a7" translate="yes" xml:space="preserve">
          <source>When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.</source>
          <target state="translated">当为真时,在获取后将当前分支重基到上游分支之上。如果有一个远程跟踪分支与上游分支相对应,且上游分支自上次获取后被重基,则重基使用该信息以避免重基非本地变化。</target>
        </trans-unit>
        <trans-unit id="e3872f2dbeef66b0c7927df02dbbfa3a35c8d12b" translate="yes" xml:space="preserve">
          <source>When two trees are given, it compares the first tree with the second. When a single commit is given, it compares the commit with its parents. The remaining commits, when given, are used as if they are parents of the first commit.</source>
          <target state="translated">当给定两棵树时,它将第一棵树和第二棵树进行比较。当给定一个提交时,它将该提交与它的父提交进行比较。其余的提交,如果给定,则作为第一个提交的父提交来使用。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
