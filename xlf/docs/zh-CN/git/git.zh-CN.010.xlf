<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="d8f5a662d30248028e58618a9cb324b38272bbd8" translate="yes" xml:space="preserve">
          <source>These commands all compare two sets of things; what is compared differs:</source>
          <target state="translated">这些命令都是比较两组事物,比较的内容不同。</target>
        </trans-unit>
        <trans-unit id="6e07bfec6529e0e8049d6a168dde51eb0ed55268" translate="yes" xml:space="preserve">
          <source>These commands are to interact with foreign SCM and with other people via patch over e-mail.</source>
          <target state="translated">这些命令是通过电子邮件与国外SCM以及通过补丁与其他人员进行交互。</target>
        </trans-unit>
        <trans-unit id="008c5282b165f202ade67dc870d3522a81a841bd" translate="yes" xml:space="preserve">
          <source>These configuration variables control &lt;code&gt;internal&lt;/code&gt; gitweb behavior.</source>
          <target state="translated">这些配置变量控制 &lt;code&gt;internal&lt;/code&gt; gitweb行为。</target>
        </trans-unit>
        <trans-unit id="94d243826a65ff43f06f691e3b2f877746c8e3a7" translate="yes" xml:space="preserve">
          <source>These configurations enable two things. First, each unix user (&lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt;) of the server will be able to browse through gitweb Git repositories found in &lt;code&gt;~/public_git/&lt;/code&gt; with the following url:</source>
          <target state="translated">这些配置启用两件事。首先，服务器的每个unix用户（ &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; ）都可以使用以下URL 浏览 &lt;code&gt;~/public_git/&lt;/code&gt; gitweb Git存储库：</target>
        </trans-unit>
        <trans-unit id="3c188c162ef90ed4e72b2204b53fd7bbdf63ed82" translate="yes" xml:space="preserve">
          <source>These environment variables apply to &lt;code&gt;all&lt;/code&gt; core Git commands. Nb: it is worth noting that they may be used/overridden by SCMS sitting above Git so take care if using a foreign front-end.</source>
          <target state="translated">这些环境变量适用于 &lt;code&gt;all&lt;/code&gt; 核心Git命令。Nb：值得注意的是，位于Git上方的SCMS可能会使用/覆盖它们，因此，如果使用国外前端，请当心。</target>
        </trans-unit>
        <trans-unit id="e4a9928c908043039dae5cc89a184941db222aba" translate="yes" xml:space="preserve">
          <source>These exclude patterns come from these places, in order:</source>
          <target state="translated">这些排除模式来自于这些地方,依次。</target>
        </trans-unit>
        <trans-unit id="75ad982aca6a7add80092ae27820348741497d7e" translate="yes" xml:space="preserve">
          <source>These flag are passed to the &lt;code&gt;git apply&lt;/code&gt; program (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) that applies the patch.</source>
          <target state="translated">这些标志传递给 &lt;code&gt;git apply&lt;/code&gt; 补丁的git apply程序（请参阅&lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a66ecfa5cef3d43b11b6332452dde3bc34998a82" translate="yes" xml:space="preserve">
          <source>These flags are passed to &lt;code&gt;git am&lt;/code&gt; to easily change the dates of the rebased commits (see &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;).</source>
          <target state="translated">这些标志传递给 &lt;code&gt;git am&lt;/code&gt; ,以轻松更改重新基于基础的提交的日期（请参见&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6f1d3498209d5426cb1c8295c9947466ac12cab4" translate="yes" xml:space="preserve">
          <source>These flags are passed to the &lt;code&gt;git apply&lt;/code&gt; (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) program that applies the patch.</source>
          <target state="translated">这些标志传递给 &lt;code&gt;git apply&lt;/code&gt; 补丁的git apply（请参阅&lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt;）程序。</target>
        </trans-unit>
        <trans-unit id="17c5d825c714d7f669df648adc8ffa3b9865aa3a" translate="yes" xml:space="preserve">
          <source>These forms reset the index entries for all paths that match the &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; to their state at &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;. (It does not affect the working tree or the current branch.)</source>
          <target state="translated">这些格式将与 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 匹配的所有路径的索引条目重置为其在 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 的状态。（它不会影响工作树或当前分支。）</target>
        </trans-unit>
        <trans-unit id="84dfe82e69639d7dd0490e18b4061edc5e5f61bb" translate="yes" xml:space="preserve">
          <source>These general best practices are very helpful if you bisect often.</source>
          <target state="translated">这些一般的最佳实践是非常有用的,如果你经常两败俱伤。</target>
        </trans-unit>
        <trans-unit id="db63350c8a27af092cfd256119dcf34d87e7125f" translate="yes" xml:space="preserve">
          <source>These instructions use the &lt;code&gt;git-cvsimport&lt;/code&gt; script which ships with git, but other importers may provide better results. See the note in &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport[1]&lt;/a&gt; for other options.</source>
          <target state="translated">这些说明使用 &lt;code&gt;git-cvsimport&lt;/code&gt; 附带的git-cvsimport脚本，但其他导入程序可能会提供更好的结果。有关其他选项，请参见&lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport [1]中&lt;/a&gt;的注释。</target>
        </trans-unit>
        <trans-unit id="4de4cd9ec9920076e498bf4f8c01b7cc0e7335b0" translate="yes" xml:space="preserve">
          <source>These messages are concerned with Git thread usage.</source>
          <target state="translated">这些信息与Git线程的使用有关。</target>
        </trans-unit>
        <trans-unit id="b8e5bd243ffdab655773f15dbcfc0554b819902f" translate="yes" xml:space="preserve">
          <source>These options are deprecated. Use the above --notes/--no-notes options instead.</source>
          <target state="translated">这些选项已经过时。</target>
        </trans-unit>
        <trans-unit id="894173daf027c82b1254f620d2cbbddacd04b7fd" translate="yes" xml:space="preserve">
          <source>These options are ignored for historical reasons.</source>
          <target state="translated">由于历史原因,这些选项被忽略了。</target>
        </trans-unit>
        <trans-unit id="0608f735748e7710136ac2ca4b1a8fc7f8d0f8a8" translate="yes" xml:space="preserve">
          <source>These options are mostly targeted for packing of Git repositories.</source>
          <target state="translated">这些选项主要针对 Git 仓库的打包。</target>
        </trans-unit>
        <trans-unit id="44fc7c2eb5b5d3f683db2d8973767b7defab9c76" translate="yes" xml:space="preserve">
          <source>These options are passed to &lt;a href=&quot;git-send-pack&quot;&gt;git-send-pack[1]&lt;/a&gt;. A thin transfer significantly reduces the amount of sent data when the sender and receiver share many of the same objects in common. The default is &lt;code&gt;--thin&lt;/code&gt;.</source>
          <target state="translated">这些选项被传递给&lt;a href=&quot;git-send-pack&quot;&gt;git-send-pack [1]&lt;/a&gt;。当发送方和接收方共享许多相同的对象时，精简传输会大大减少发送的数据量。默认值为 &lt;code&gt;--thin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c86ff6978b6c3146e6796c4f36abf160da0176d" translate="yes" xml:space="preserve">
          <source>These options can be used in an initial &lt;code&gt;clone&lt;/code&gt;, along with the &lt;code&gt;sync&lt;/code&gt; options described above.</source>
          <target state="translated">这些选项可以与上述 &lt;code&gt;sync&lt;/code&gt; 选项一起用于初始 &lt;code&gt;clone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ade32a888d52a4ba127b2e5cb51121d4b067e67" translate="yes" xml:space="preserve">
          <source>These options can be used in the initial &lt;code&gt;clone&lt;/code&gt; as well as in subsequent &lt;code&gt;sync&lt;/code&gt; operations.</source>
          <target state="translated">这些选项可用于初始 &lt;code&gt;clone&lt;/code&gt; 以及后续的 &lt;code&gt;sync&lt;/code&gt; 操作中。</target>
        </trans-unit>
        <trans-unit id="3f45787718e6c314237aec0cf2c5e63156df92c4" translate="yes" xml:space="preserve">
          <source>These options can be used to modify &lt;code&gt;git p4 rebase&lt;/code&gt; behavior.</source>
          <target state="translated">这些选项可用于修改 &lt;code&gt;git p4 rebase&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="046bf3cadb648529c8cbf517d3ba66246fc697fc" translate="yes" xml:space="preserve">
          <source>These options can be used to modify &lt;code&gt;git p4 submit&lt;/code&gt; behavior.</source>
          <target state="translated">这些选项可用于修改 &lt;code&gt;git p4 submit&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="5bf9264c3d2f29d27aed45b38db366aee6362601" translate="yes" xml:space="preserve">
          <source>These options control layout (defaults to &lt;code&gt;column&lt;/code&gt;). Setting any of these implies &lt;code&gt;always&lt;/code&gt; if none of &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;, or &lt;code&gt;auto&lt;/code&gt; are specified.</source>
          <target state="translated">这些选项控制布局（默认为 &lt;code&gt;column&lt;/code&gt; ）。如果 &lt;code&gt;never&lt;/code&gt; 指定 &lt;code&gt;always&lt;/code&gt; ，never或 &lt;code&gt;auto&lt;/code&gt; 的任何一项，则设置其中的任何一项表示 &lt;code&gt;always&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="510a1cbefb424a60db8479a49dd55a0966d6d945" translate="yes" xml:space="preserve">
          <source>These options control when the feature should be enabled (defaults to &lt;code&gt;never&lt;/code&gt;):</source>
          <target state="translated">这些选项控制何时应启用该功能（默认为 &lt;code&gt;never&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="931e215644554fa9404627a014bfd3cf51399ea5" translate="yes" xml:space="preserve">
          <source>These options take effect whatever the value of the &lt;code&gt;core.splitIndex&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">无论 &lt;code&gt;core.splitIndex&lt;/code&gt; 配置变量的值如何，这些选项都会生效（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。但是，当更改与配置值不符时，会发出警告，因为配置值将在下次读取索引时生效，这将删除该选项的预期效果。</target>
        </trans-unit>
        <trans-unit id="932e8c22c29966222600cac9510425979eeabd1c" translate="yes" xml:space="preserve">
          <source>These options take effect whatever the value of the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">无论 &lt;code&gt;core.untrackedCache&lt;/code&gt; 配置变量的值如何，这些选项都会生效（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。但是，当更改与配置值不符时，会发出警告，因为配置值将在下次读取索引时生效，这将删除该选项的预期效果。</target>
        </trans-unit>
        <trans-unit id="ff7024be4fc3bd9a63ff1aab42e5c2f33080a5ad" translate="yes" xml:space="preserve">
          <source>These parameters can also be set individually with &lt;code&gt;--stat-width=&amp;lt;width&amp;gt;&lt;/code&gt;, &lt;code&gt;--stat-name-width=&amp;lt;name-width&amp;gt;&lt;/code&gt; and &lt;code&gt;--stat-count=&amp;lt;count&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这些参数也可以分别使用 &lt;code&gt;--stat-width=&amp;lt;width&amp;gt;&lt;/code&gt; ，-- &lt;code&gt;--stat-name-width=&amp;lt;name-width&amp;gt;&lt;/code&gt; 和 &lt;code&gt;--stat-count=&amp;lt;count&amp;gt;&lt;/code&gt; 进行设置。</target>
        </trans-unit>
        <trans-unit id="25d97f197e2ad468ea791c831ca2e71054c4e207" translate="yes" xml:space="preserve">
          <source>These remote-tracking references can be deleted as a one-off with either of:</source>
          <target state="translated">这些远程跟踪参考资料可以通过以下两种方式一次性删除:</target>
        </trans-unit>
        <trans-unit id="4994737bcfd88cfa54486bc85e99d5152416b798" translate="yes" xml:space="preserve">
          <source>These rules make it easy for shell script based tools to parse reference names, pathname expansion by the shell when a reference name is used unquoted (by mistake), and also avoid ambiguities in certain reference name expressions (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;):</source>
          <target state="translated">这些规则使基于Shell脚本的工具可以轻松解析引用名称，在引用名称不加引号的情况下（错误地）由外壳扩展路径名，还可以避免某些引用名称表达式中的歧义（请参阅&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="d2d3b8bc5c27c38dddb2f7c9e54b52668c820483" translate="yes" xml:space="preserve">
          <source>These services can be enabled/disabled using the per-repository configuration file:</source>
          <target state="translated">这些服务可以使用每个存储库的配置文件来启用/禁用。</target>
        </trans-unit>
        <trans-unit id="11be9ffec744e4c727f505822229118ed50ca097" translate="yes" xml:space="preserve">
          <source>These services can be globally enabled/disabled using the command-line options of this command. If finer-grained control is desired (e.g. to allow &lt;code&gt;git archive&lt;/code&gt; to be run against only in a few selected repositories the daemon serves), the per-repository configuration file can be used to enable or disable them.</source>
          <target state="translated">可以使用此命令的命令行选项全局启用/禁用这些服务。如果需要更细粒度的控制（例如，仅允许在守护程序所服务的几个选定存储库中运行 &lt;code&gt;git archive&lt;/code&gt; ），则可以使用每个存储库配置文件来启用或禁用它们。</target>
        </trans-unit>
        <trans-unit id="6e7a1043f71fa1813c0b5e398e97710f483944d9" translate="yes" xml:space="preserve">
          <source>These things may exist in a Git repository.</source>
          <target state="translated">这些东西可能存在于Git仓库中。</target>
        </trans-unit>
        <trans-unit id="b5c7f688db050c92cfc9bb2aa9d676e52849ec7b" translate="yes" xml:space="preserve">
          <source>These three branches all forked from a common commit, [master], whose commit message is &quot;Add 'git show-branch'&quot;. The &quot;fixes&quot; branch adds one commit &quot;Introduce &quot;reset type&quot; flag to &quot;git reset&quot;&quot;. The &quot;mhf&quot; branch adds many other commits. The current branch is &quot;master&quot;.</source>
          <target state="translated">这三个分支都是从一个共同的提交[master]分叉出来的,其提交信息是 &quot;添加'git show-branch'&quot;。fixes &quot;分支增加了一个提交 &quot;在 &quot;git reset &quot;中引入 &quot;reset type &quot;标志&quot;。mhf &quot;分支增加了许多其他提交。目前的分支是 &quot;master&quot;。</target>
        </trans-unit>
        <trans-unit id="c6204a9318b7a0526e46b8696b2eb378d52ecf11" translate="yes" xml:space="preserve">
          <source>These two filters behave differently, and by default, a filter is taken as the former, massaging the contents into more convenient shape. A missing filter driver definition in the config, or a filter driver that exits with a non-zero status, is not an error but makes the filter a no-op passthru.</source>
          <target state="translated">这两种过滤器的行为是不同的,默认情况下,过滤器被当作前者,将内容按摩成更方便的形状。如果配置中缺少过滤器驱动定义,或者过滤器驱动退出时状态为非零,都不是错误,而是使过滤器成为无操作的通病。</target>
        </trans-unit>
        <trans-unit id="e20e46dc24b79b5218925e423850545226b0898e" translate="yes" xml:space="preserve">
          <source>These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within --window to see if using delta compression saves space. --depth limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.</source>
          <target state="translated">这两个选项会影响如何使用 delta 压缩来存储包中的对象。这些对象首先在内部按类型、大小和可选的名称进行排序,并与 --window 中的其他对象进行比较,以确定使用 delta 压缩是否能节省空间。--depth 限制了最大的 delta 深度;太深会影响解包器的性能,因为 delta 数据需要被应用那么多次才能到达所需的对象。</target>
        </trans-unit>
        <trans-unit id="de212a952b72f4cd05af023bbd056fa8307c4a9f" translate="yes" xml:space="preserve">
          <source>These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within &lt;code&gt;--window&lt;/code&gt; to see if using delta compression saves space. &lt;code&gt;--depth&lt;/code&gt; limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.</source>
          <target state="translated">这两个选项影响使用增量压缩存储包中包含的对象的方式。这些对象首先在内部按类型，大小和可选的名称进行排序，然后与 &lt;code&gt;--window&lt;/code&gt; 中的其他对象进行比较，以查看是否使用增量压缩节省了空间。 &lt;code&gt;--depth&lt;/code&gt; 限制最大增量深度；将其设置得过深会影响解包器方面的性能，因为需要多次应用增量数据才能到达必需的对象。</target>
        </trans-unit>
        <trans-unit id="6a0bfaec1ca5ad5a0f6710f22f7b4b78eecfef67" translate="yes" xml:space="preserve">
          <source>These two syntaxes are mostly equivalent, except the former implies --local option.</source>
          <target state="translated">这两种语法大部分是等价的,只是前者意味着--local选项。</target>
        </trans-unit>
        <trans-unit id="9270307e15adf00d482cdebd8e068750f310bc87" translate="yes" xml:space="preserve">
          <source>These two syntaxes are mostly equivalent, except when cloning, when the former implies --local option. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; for details.</source>
          <target state="translated">除了克隆时（前者暗示--local选项）外，这两种语法几乎都是等效的。有关详细信息，请参见&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="469e074d32a553c54f69af6603803ffbfd2e6dda" translate="yes" xml:space="preserve">
          <source>These types of entries are generally created as a result of using &lt;code&gt;git
commit --amend&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt; and are the commits prior to the amend or rebase occurring. Since these changes are not part of the current project most users will want to expire them sooner, which is why the default is more aggressive than &lt;code&gt;gc.reflogExpire&lt;/code&gt;.</source>
          <target state="translated">这些类型的条目通常是由于使用 &lt;code&gt;git commit --amend&lt;/code&gt; 或 &lt;code&gt;git rebase&lt;/code&gt; 而创建的，它们是在进行amend或rebase之前的提交。由于这些更改不是当前项目的一部分，因此大多数用户希望它们尽快过期，这就是为什么默认值比 &lt;code&gt;gc.reflogExpire&lt;/code&gt; 更具侵略性的原因。</target>
        </trans-unit>
        <trans-unit id="99a10a0726ee032ba80815c05eceb6d5a6ab2aa8" translate="yes" xml:space="preserve">
          <source>These variables control various optional help messages designed to aid new users. All &lt;code&gt;advice.*&lt;/code&gt; variables default to &lt;code&gt;true&lt;/code&gt;, and you can tell Git that you do not need help by setting these to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">这些变量控制旨在帮助新用户的各种可选帮助消息。所有 &lt;code&gt;advice.*&lt;/code&gt; 变量默认为 &lt;code&gt;true&lt;/code&gt; ，可以通过将它们设置为 &lt;code&gt;false&lt;/code&gt; 来告诉Git不需要帮助：</target>
        </trans-unit>
        <trans-unit id="289bbff1e27f0cf157d5208bbfcb9f369ecc1504" translate="yes" xml:space="preserve">
          <source>These variables obviate the need for command-line options in some circumstances, allowing easier restricted usage through git-shell.</source>
          <target state="translated">在某些情况下,这些变量不需要命令行选项,可以通过 git-shell 更容易地限制使用。</target>
        </trans-unit>
        <trans-unit id="48d5c4b33cae3d35014b5a5e266ea897c2a18c9f" translate="yes" xml:space="preserve">
          <source>These will display all commits which exist only on HEAD or on MERGE_HEAD, and which touch an unmerged file.</source>
          <target state="translated">这些将显示所有只存在于 HEAD 或 MERGE_HEAD 上的提交,以及触及未合并文件的提交。</target>
        </trans-unit>
        <trans-unit id="e9ab0d9bdf3f35b7d6ece2d3bc65f4fbb38bad38" translate="yes" xml:space="preserve">
          <source>They are both passed directly to &lt;code&gt;git diff-tree&lt;/code&gt;; see &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt; for more information.</source>
          <target state="translated">它们都直接传递给 &lt;code&gt;git diff-tree&lt;/code&gt; ；有关更多信息，请参见&lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afa16f632fa562fed5a34ad41431101aacb568d7" translate="yes" xml:space="preserve">
          <source>They can include slash &lt;code&gt;/&lt;/code&gt; for hierarchical (directory) grouping, but no slash-separated component can begin with a dot &lt;code&gt;.&lt;/code&gt; or end with the sequence &lt;code&gt;.lock&lt;/code&gt;.</source>
          <target state="translated">它们可以包括斜杠 &lt;code&gt;/&lt;/code&gt; 用于层次结构（目录）分组，但是斜杠分隔的组件不能以点开头 &lt;code&gt;.&lt;/code&gt; 或以序列 &lt;code&gt;.lock&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="48a933f433abac80f2e0e41b240081f7a399893c" translate="yes" xml:space="preserve">
          <source>They cannot be the single character &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">它们不能是单个字符 &lt;code&gt;@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c798a840110b095cd0c31cb10cad16c17f5292dd" translate="yes" xml:space="preserve">
          <source>They cannot begin or end with a slash &lt;code&gt;/&lt;/code&gt; or contain multiple consecutive slashes (see the &lt;code&gt;--normalize&lt;/code&gt; option below for an exception to this rule)</source>
          <target state="translated">它们不能以斜杠开头或结尾 &lt;code&gt;/&lt;/code&gt; 或包含多个连续的斜杠（有关此规则的例外，请参阅下面的 &lt;code&gt;--normalize&lt;/code&gt; 选项）</target>
        </trans-unit>
        <trans-unit id="794c847c2b033448497ba9e6f46f59b7325ccd69" translate="yes" xml:space="preserve">
          <source>They cannot contain a &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">它们不能包含 &lt;code&gt;\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4cf89d0a711867dbdfa498e7e6b80fb04c020f3" translate="yes" xml:space="preserve">
          <source>They cannot contain a sequence &lt;code&gt;@{&lt;/code&gt;.</source>
          <target state="translated">它们不能包含序列 &lt;code&gt;@{&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c781dcfcbfa7c545717cc72f3f25ac7fba039fd7" translate="yes" xml:space="preserve">
          <source>They cannot end with a dot &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">它们不能以点结尾 &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdf3c698f8591838633d63d5550c41009f5d53bb" translate="yes" xml:space="preserve">
          <source>They cannot have ASCII control characters (i.e. bytes whose values are lower than \040, or \177 &lt;code&gt;DEL&lt;/code&gt;), space, tilde &lt;code&gt;~&lt;/code&gt;, caret &lt;code&gt;^&lt;/code&gt;, or colon &lt;code&gt;:&lt;/code&gt; anywhere.</source>
          <target state="translated">它们不能具有ASCII控制字符（即，值小于\ 040或\ 177 &lt;code&gt;DEL&lt;/code&gt; 的字节），空格，代字号 &lt;code&gt;~&lt;/code&gt; ，插入号 &lt;code&gt;^&lt;/code&gt; 或冒号 &lt;code&gt;:&lt;/code&gt; 任何地方。</target>
        </trans-unit>
        <trans-unit id="9fa9a35ba99f055f59e5fb0fc3903845af8141d1" translate="yes" xml:space="preserve">
          <source>They cannot have question-mark &lt;code&gt;?&lt;/code&gt;, asterisk &lt;code&gt;*&lt;/code&gt;, or open bracket &lt;code&gt;[&lt;/code&gt; anywhere. See the &lt;code&gt;--refspec-pattern&lt;/code&gt; option below for an exception to this rule.</source>
          <target state="translated">他们不能有问号 &lt;code&gt;?&lt;/code&gt; ，星号 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;[&lt;/code&gt; 在任何位置打开括号[ 有关此规则的例外，请参见下面的 &lt;code&gt;--refspec-pattern&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="07233de88d34b821d099ea14e09099281360fa3d" translate="yes" xml:space="preserve">
          <source>They cannot have two consecutive dots &lt;code&gt;..&lt;/code&gt; anywhere.</source>
          <target state="translated">他们不能有两个连续的点 &lt;code&gt;..&lt;/code&gt; 任何地方。</target>
        </trans-unit>
        <trans-unit id="08cc7b3818b658e36c5e9a0a0fcefabb2c9bd5ce" translate="yes" xml:space="preserve">
          <source>They must contain at least one &lt;code&gt;/&lt;/code&gt;. This enforces the presence of a category like &lt;code&gt;heads/&lt;/code&gt;, &lt;code&gt;tags/&lt;/code&gt; etc. but the actual names are not restricted. If the &lt;code&gt;--allow-onelevel&lt;/code&gt; option is used, this rule is waived.</source>
          <target state="translated">它们必须包含至少一个 &lt;code&gt;/&lt;/code&gt; 。这会强制出现诸如 &lt;code&gt;heads/&lt;/code&gt; ， &lt;code&gt;tags/&lt;/code&gt; 等之类的类别，但实际名称不受限制。如果使用 &lt;code&gt;--allow-onelevel&lt;/code&gt; 选项，则将放弃此规则。</target>
        </trans-unit>
        <trans-unit id="9c66e1086c1b783565f285e9f8d345796e4a920b" translate="yes" xml:space="preserve">
          <source>Things get more complicated if the &lt;code&gt;subsystem&lt;/code&gt; changes do not exactly correspond to the ones before the rebase.</source>
          <target state="translated">如果 &lt;code&gt;subsystem&lt;/code&gt; 更改与重新设置之前的更改不完全对应，则事情会变得更加复杂。</target>
        </trans-unit>
        <trans-unit id="877bd5e347693a4c90610529b809f198ae203a8a" translate="yes" xml:space="preserve">
          <source>Think about how to create a clear chapter dependency graph that will allow people to get to important topics without necessarily reading everything in between.</source>
          <target state="translated">思考如何创建一个清晰的章节依赖图,让人们能够进入重要的主题,而不一定要阅读中间的所有内容。</target>
        </trans-unit>
        <trans-unit id="5f03012af2a22f62503c31e1e064eb23ddd2be46" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;key&lt;/code&gt; will be used instead of &amp;lt;token&amp;gt; in the trailer. At the end of this key, a separator can appear and then some space characters. By default the only valid separator is &lt;code&gt;:&lt;/code&gt;, but this can be changed using the &lt;code&gt;trailer.separators&lt;/code&gt; config variable.</source>
          <target state="translated">该 &lt;code&gt;key&lt;/code&gt; 将代替预告片中的&amp;lt;token&amp;gt;使用。在此键的末尾，可能会出现分隔符，然后出现一些空格字符。默认情况下，唯一有效的分隔符是 &lt;code&gt;:&lt;/code&gt; ，但是可以使用 &lt;code&gt;trailer.separators&lt;/code&gt; 配置变量进行更改。</target>
        </trans-unit>
        <trans-unit id="9ed9ef222233001104259cd6ab7e0ea2e028dedb" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;merge&lt;/code&gt; can also be done by &lt;code&gt;pulling from her own remote-tracking branch&lt;/code&gt;, like this:</source>
          <target state="translated">这个 &lt;code&gt;merge&lt;/code&gt; 也可以通过进行 &lt;code&gt;pulling from her own remote-tracking branch&lt;/code&gt; ，就像这样：</target>
        </trans-unit>
        <trans-unit id="0007248c88629a35b9fa8e1cf4c8fdf299191526" translate="yes" xml:space="preserve">
          <source>This accepts all options that &lt;code&gt;git svn fetch&lt;/code&gt; and &lt;code&gt;git rebase&lt;/code&gt; accept. However, &lt;code&gt;--fetch-all&lt;/code&gt; only fetches from the current [svn-remote], and not all [svn-remote] definitions.</source>
          <target state="translated">这将接受 &lt;code&gt;git svn fetch&lt;/code&gt; 和 &lt;code&gt;git rebase&lt;/code&gt; 接受的所有选项。但是，-- &lt;code&gt;--fetch-all&lt;/code&gt; 仅从当前的[svn-remote]定义中获取，而不是从所有的[svn-remote]定义获取。</target>
        </trans-unit>
        <trans-unit id="c118365ba0290d763b2d4e635fbfbb09d23e73e6" translate="yes" xml:space="preserve">
          <source>This action is disabled by default for performance reasons.</source>
          <target state="translated">由于性能原因,该操作默认为禁用。</target>
        </trans-unit>
        <trans-unit id="692de83ae64c152ace96a6b22c40c6c7b5256f5f" translate="yes" xml:space="preserve">
          <source>This adds a link titled &quot;graphiclog&quot; after the &quot;summary&quot; link, leading to &lt;code&gt;git-browser&lt;/code&gt; script, passing &lt;code&gt;r=&amp;lt;project&amp;gt;&lt;/code&gt; as a query parameter.</source>
          <target state="translated">这将在&amp;ldquo;摘要&amp;rdquo;链接之后添加一个名为&amp;ldquo; graphiclog&amp;rdquo;的链接，从而导致 &lt;code&gt;git-browser&lt;/code&gt; 脚本，并传递 &lt;code&gt;r=&amp;lt;project&amp;gt;&lt;/code&gt; 作为查询参数。</target>
        </trans-unit>
        <trans-unit id="9647e1f610a9d28b74cedc3ffa625f5d98628ec8" translate="yes" xml:space="preserve">
          <source>This algorithm extends the patience algorithm to &quot;support low-occurrence common elements&quot;.</source>
          <target state="translated">该算法将耐心算法扩展为 &quot;支持低发生率的共同元素&quot;。</target>
        </trans-unit>
        <trans-unit id="5f9e4d22cfa1bc9f924abb0f51a443db2655b318" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;git svn&lt;/code&gt; to re-map repository URLs and UUIDs from mirrors created using SVN::Mirror (or svk) for metadata.</source>
          <target state="translated">这允许 &lt;code&gt;git svn&lt;/code&gt; 从使用SVN :: Mirror（或svk）为元数据创建的镜像中重新映射存储库URL和UUID。</target>
        </trans-unit>
        <trans-unit id="cb552885bcd7df779f362e35a229c9d935657c60" translate="yes" xml:space="preserve">
          <source>This allows one to specify a Perl regular expression that will cause skipping of all matching paths from checkout from SVN. The &lt;code&gt;--ignore-paths&lt;/code&gt; option should match for every &lt;code&gt;fetch&lt;/code&gt; (including automatic fetches due to &lt;code&gt;clone&lt;/code&gt;, &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, etc) on a given repository.</source>
          <target state="translated">这允许您指定一个Perl正则表达式，该表达式将导致从SVN检出中跳过所有匹配的路径。所述 &lt;code&gt;--ignore-paths&lt;/code&gt; 选项应匹配每 &lt;code&gt;fetch&lt;/code&gt; （包括自动取由于 &lt;code&gt;clone&lt;/code&gt; ， &lt;code&gt;dcommit&lt;/code&gt; ， &lt;code&gt;rebase&lt;/code&gt; 在给定储存库等）。</target>
        </trans-unit>
        <trans-unit id="bf5d12ceb1111e8b06bd58f3985472091a1cae12" translate="yes" xml:space="preserve">
          <source>This allows one to specify a Perl regular expression that will cause the inclusion of only matching paths from checkout from SVN. The &lt;code&gt;--include-paths&lt;/code&gt; option should match for every &lt;code&gt;fetch&lt;/code&gt; (including automatic fetches due to &lt;code&gt;clone&lt;/code&gt;, &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, etc) on a given repository. &lt;code&gt;--ignore-paths&lt;/code&gt; takes precedence over &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">这允许指定一个Perl正则表达式，该正则表达式将导致仅包含来自SVN的检出的匹配路径。所述 &lt;code&gt;--include-paths&lt;/code&gt; 选项应匹配每 &lt;code&gt;fetch&lt;/code&gt; （包括自动取由于 &lt;code&gt;clone&lt;/code&gt; ， &lt;code&gt;dcommit&lt;/code&gt; ， &lt;code&gt;rebase&lt;/code&gt; 在给定储存库等）。 &lt;code&gt;--ignore-paths&lt;/code&gt; 优先于 &lt;code&gt;--include-paths&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c68f089f9144bc4bdc1d710532bfa75a569d11ed" translate="yes" xml:space="preserve">
          <source>This allows one to specify a prefix which is prepended to the names of remotes if trunk/branches/tags are specified. The prefix does not automatically include a trailing slash, so be sure you include one in the argument if that is what you want. If --branches/-b is specified, the prefix must include a trailing slash. Setting a prefix (with a trailing slash) is strongly encouraged in any case, as your SVN-tracking refs will then be located at &quot;refs/remotes/$prefix/&lt;strong&gt;&quot;, which is compatible with Git&amp;rsquo;s own remote-tracking ref layout (refs/remotes/$remote/&lt;/strong&gt;). Setting a prefix is also useful if you wish to track multiple projects that share a common repository. By default, the prefix is set to &lt;code&gt;origin/&lt;/code&gt;.</source>
          <target state="translated">如果指定了中继线/分支/标签，则允许指定一个前缀，该前缀在遥控器的名称之前。前缀不会自动包含尾部斜杠，因此，如果需要，请确保在参数中包括一个斜杠。如果指定了--branches / -b，则前缀必须包含尾部斜杠。在任何情况下都强烈建议设置前缀（带有斜杠），因为这样您的SVN跟踪引用将位于&amp;ldquo; refs / remotes / $ prefix / &lt;strong&gt;&amp;rdquo;，这与Git自己的远程跟踪引用布局兼容（refs / remotes / $ remote /&lt;/strong&gt;）。如果您希望跟踪共享一个公共存储库的多个项目，则设置前缀也很有用。默认情况下，前缀设置为 &lt;code&gt;origin/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99b10fdeae941de841a9ac73e39b7c06fcc2d978" translate="yes" xml:space="preserve">
          <source>This allows revision ranges for partial/cauterized history to be supported. $NUMBER, $NUMBER1:$NUMBER2 (numeric ranges), $NUMBER:HEAD, and BASE:$NUMBER are all supported.</source>
          <target state="translated">这允许支持部分/固化历史的修订范围。$NUMBER、$NUMBER1:$NUMBER2(数字范围)、$NUMBER:HEAD和BASE:$NUMBER都支持。</target>
        </trans-unit>
        <trans-unit id="f18b167effc162d347deb782b83eab22ac73f014" translate="yes" xml:space="preserve">
          <source>This allows users to create repositories from alternate URLs. For example, an administrator could run &lt;code&gt;git svn&lt;/code&gt; on the server locally (accessing via file://) but wish to distribute the repository with a public http:// or svn:// URL in the metadata so users of it will see the public URL.</source>
          <target state="translated">这允许用户从备用URL创建存储库。例如，管理员可以在本地服务器上运行 &lt;code&gt;git svn&lt;/code&gt; （通过file：//访问），但希望在元数据中使用公共http：//或svn：// URL分发存储库，以便其用户可以看到公开网址。</target>
        </trans-unit>
        <trans-unit id="86c4c002dbb35b192dee2247feadc27722ad842a" translate="yes" xml:space="preserve">
          <source>This application is a CVS emulation layer for Git.</source>
          <target state="translated">这个应用是Git的CVS仿真层。</target>
        </trans-unit>
        <trans-unit id="8feea1468fa1fae814e84f89aca492fad30e5da4" translate="yes" xml:space="preserve">
          <source>This applies modifications from a hot-fix branch before each test run, e.g. in case your build or test environment changed so that older revisions may need a fix which newer ones have already. (Make sure the hot-fix branch is based off a commit which is contained in all revisions which you are bisecting, so that the merge does not pull in too much, or use &lt;code&gt;git cherry-pick&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt;.)</source>
          <target state="translated">这会在每次测试运行之前应用来自修补程序分支的修改，例如，如果您的构建或测试环境发生了更改，以便较旧的修订可能需要较新的修订已经具有的修复。（请确保热修复程序分支基于您要二等分的所有修订中包含的提交，以便合并不会引入过多内容，或者使用 &lt;code&gt;git cherry-pick&lt;/code&gt; 而不是 &lt;code&gt;git merge&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="889d1277201779cf18582f69129975a9bf60d357" translate="yes" xml:space="preserve">
          <source>This applies to files added to the source branch &lt;strong&gt;after&lt;/strong&gt; a daughter branch was created: if previously no commit was made on the daughter branch they will erroneously be added to the daughter branch in git.</source>
          <target state="translated">这适用于在创建子分支&lt;strong&gt;之后&lt;/strong&gt;添加到源分支的文件：如果以前未在子分支上进行任何提交，则它们将被错误地添加到git中的子分支中。</target>
        </trans-unit>
        <trans-unit id="cd519f993fc33ca56b2cb882b0ae5ba8b983012d" translate="yes" xml:space="preserve">
          <source>This argument will not be passed to &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;. Instead it sets the vhost field in the git:// service request (to rest of the argument). Default is not to send vhost in such request (if sent).</source>
          <target state="translated">此参数不会传递给 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 。而是在git：//服务请求中设置vhost字段（其余参数）。默认设置是不发送此类请求中的虚拟主机（如果已发送）。</target>
        </trans-unit>
        <trans-unit id="9535ee34f2074fa8e689413e0518f1d3faf71e7d" translate="yes" xml:space="preserve">
          <source>This argument will not be passed to &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;. Instead, it will cause the helper to start by sending git:// service requests to the remote side with the service field set to an appropriate value and the repository field set to rest of the argument. Default is not to send such a request.</source>
          <target state="translated">此参数不会传递给 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 。取而代之的是，它将通过将git：//服务请求发送到远程端来启动帮助程序，其中service字段设置为适当的值，repository字段设置为参数的其余部分。默认为不发送此类请求。</target>
        </trans-unit>
        <trans-unit id="b50cd8ffcdc46b4b68ae7776a2b00f1d1183b6dd" translate="yes" xml:space="preserve">
          <source>This asks for all the history reachable from the given commit but not from any branch, tag, or other reference. If you decide it&amp;rsquo;s something you want, you can always create a new reference to it, e.g.,</source>
          <target state="translated">这要求从给定的提交（而不是从任何分支，标记或其他引用）获得的所有历史记录。如果您决定要这样做，则可以随时为其创建新的引用，例如，</target>
        </trans-unit>
        <trans-unit id="7efa4dea1c9da210003e0c08e382eb543f66cbf7" translate="yes" xml:space="preserve">
          <source>This attribute controls the length of conflict markers left in the work tree file during a conflicted merge. Only setting to the value to a positive integer has any meaningful effect.</source>
          <target state="translated">此属性控制冲突合并时工作树文件中留下的冲突标记的长度。只有将该值设置为正整数才有意义。</target>
        </trans-unit>
        <trans-unit id="4caef1788f338fb02906a32b34bfb366a7539a3a" translate="yes" xml:space="preserve">
          <source>This attribute enables and controls end-of-line normalization. When a text file is normalized, its line endings are converted to LF in the repository. To control what line ending style is used in the working directory, use the &lt;code&gt;eol&lt;/code&gt; attribute for a single file and the &lt;code&gt;core.eol&lt;/code&gt; configuration variable for all text files. Note that setting &lt;code&gt;core.autocrlf&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;input&lt;/code&gt; overrides &lt;code&gt;core.eol&lt;/code&gt; (see the definitions of those options in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">此属性启用并控制行尾规范化。对文本文件进行规范化后，其行尾将在存储库中转换为LF。要控制工作目录中使用哪种行尾样式，请对单个文件使用 &lt;code&gt;eol&lt;/code&gt; 属性，对所有文本文件使用 &lt;code&gt;core.eol&lt;/code&gt; 配置变量。请注意，将 &lt;code&gt;core.autocrlf&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;input&lt;/code&gt; 会覆盖 &lt;code&gt;core.eol&lt;/code&gt; （请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;中这些选项的定义）。</target>
        </trans-unit>
        <trans-unit id="9abb1dada669f4b282e87943eaa4c10d9676f824" translate="yes" xml:space="preserve">
          <source>This attribute sets a specific line-ending style to be used in the working directory. It enables end-of-line conversion without any content checks, effectively setting the &lt;code&gt;text&lt;/code&gt; attribute. Note that setting this attribute on paths which are in the index with CRLF line endings may make the paths to be considered dirty. Adding the path to the index again will normalize the line endings in the index.</source>
          <target state="translated">此属性设置在工作目录中使用的特定行尾样式。它无需任何内容检查即可进行行尾转换，从而有效地设置了 &lt;code&gt;text&lt;/code&gt; 属性。请注意，在带有CRLF行尾的索引中的路径上设置此属性可能会使该路径被视为脏路径。再次将路径添加到索引将规范索引中的行尾。</target>
        </trans-unit>
        <trans-unit id="a95f413f93d421b5f0b609911f7201baca2aa2de" translate="yes" xml:space="preserve">
          <source>This automatically updates the rev_map if needed (see &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; in the FILES section below for details).</source>
          <target state="translated">如果需要，这会自动更新rev_map（有关详细信息，请参见下面&amp;ldquo; FILES&amp;rdquo;部分中的 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="756e07e0622c048ffb322b306c002b3fe742a463" translate="yes" xml:space="preserve">
          <source>This behavior can be suppressed with the &lt;code&gt;--no-ff&lt;/code&gt; option.</source>
          <target state="translated">可以使用 &lt;code&gt;--no-ff&lt;/code&gt; 选项抑制此行为。</target>
        </trans-unit>
        <trans-unit id="8ad430bc747d1916521d538bf94c1847176c4231" translate="yes" xml:space="preserve">
          <source>This behavior is the default when the start point is a remote-tracking branch. Set the branch.autoSetupMerge configuration variable to &lt;code&gt;false&lt;/code&gt; if you want &lt;code&gt;git switch&lt;/code&gt;, &lt;code&gt;git checkout&lt;/code&gt; and &lt;code&gt;git branch&lt;/code&gt; to always behave as if &lt;code&gt;--no-track&lt;/code&gt; were given. Set it to &lt;code&gt;always&lt;/code&gt; if you want this behavior when the start-point is either a local or remote-tracking branch.</source>
          <target state="translated">当起点是远程跟踪分支时，此行为是默认行为。如果希望 &lt;code&gt;git switch&lt;/code&gt; ， &lt;code&gt;git checkout&lt;/code&gt; 和 &lt;code&gt;git branch&lt;/code&gt; 始终表现为 &lt;code&gt;--no-track&lt;/code&gt; ，则将branch.autoSetupMerge配置变量设置为 &lt;code&gt;false&lt;/code&gt; 。如果您希望在起始点是本地或远程跟踪分支时使用此行为，请将其设置为 &lt;code&gt;always&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e589ab09a449c7cf7000e50f249deca2b148281c" translate="yes" xml:space="preserve">
          <source>This boolean will enable &lt;code&gt;fsync()&lt;/code&gt; when writing object files.</source>
          <target state="translated">写入目标文件时，此布尔值将启用 &lt;code&gt;fsync()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a9d8bb8cd3e4996e1654fca8257ad2030d24d70" translate="yes" xml:space="preserve">
          <source>This breakage is of course most of the time unrelated to the breakage we are trying to locate in the commit graph. But it prevents us to know if the interesting &quot;bad behavior&quot; is present or not.</source>
          <target state="translated">当然,这种破绽大多数时候与我们试图在提交图中定位的破绽无关。但它让我们无法知道是否存在有趣的 &quot;坏行为&quot;。</target>
        </trans-unit>
        <trans-unit id="1a7656b1b8b17aa91ea330f8fbedd0a75097faed" translate="yes" xml:space="preserve">
          <source>This bug has also been shown to affect non-symlink cases of replacing a directory with a file when it comes to the internal structures of the untracked cache, but no case has been reported where this resulted in wrong &quot;git status&quot; output.</source>
          <target state="translated">当涉及到未跟踪缓存的内部结构时,这个bug也被证明会影响到用文件替换目录的非全链接情况,但还没有报告说这会导致错误的 &quot;git状态 &quot;输出。</target>
        </trans-unit>
        <trans-unit id="bbb14e9c1a32bd1658d34b41d317e78fe3e2cf7e" translate="yes" xml:space="preserve">
          <source>This cache is meant to speed up commands that involve determining untracked files such as &lt;code&gt;git status&lt;/code&gt;.</source>
          <target state="translated">此缓存旨在加快涉及确定未跟踪文件（例如 &lt;code&gt;git status&lt;/code&gt; )的命令的速度。</target>
        </trans-unit>
        <trans-unit id="5e9291bab46bd7ea7a2a21b7e8d51146482ff7a6" translate="yes" xml:space="preserve">
          <source>This calculates the same as &lt;code&gt;--bisect&lt;/code&gt;, except that refs in &lt;code&gt;refs/bisect/&lt;/code&gt; are not used, and except that this outputs text ready to be eval&amp;rsquo;ed by the shell. These lines will assign the name of the midpoint revision to the variable &lt;code&gt;bisect_rev&lt;/code&gt;, and the expected number of commits to be tested after &lt;code&gt;bisect_rev&lt;/code&gt; is tested to &lt;code&gt;bisect_nr&lt;/code&gt;, the expected number of commits to be tested if &lt;code&gt;bisect_rev&lt;/code&gt; turns out to be good to &lt;code&gt;bisect_good&lt;/code&gt;, the expected number of commits to be tested if &lt;code&gt;bisect_rev&lt;/code&gt; turns out to be bad to &lt;code&gt;bisect_bad&lt;/code&gt;, and the number of commits we are bisecting right now to &lt;code&gt;bisect_all&lt;/code&gt;.</source>
          <target state="translated">此计算与 &lt;code&gt;--bisect&lt;/code&gt; 相同，除了不使用 &lt;code&gt;refs/bisect/&lt;/code&gt; 中的ref，并且输出的文本准备好由shell评估之外。这些生产线将分配中点修订的变量名 &lt;code&gt;bisect_rev&lt;/code&gt; ，并承诺的预期数量进行测试后 &lt;code&gt;bisect_rev&lt;/code&gt; 进行测试，以 &lt;code&gt;bisect_nr&lt;/code&gt; ，进行测试提交的预期数量，如果 &lt;code&gt;bisect_rev&lt;/code&gt; 原来是很好的 &lt;code&gt;bisect_good&lt;/code&gt; 时，如果 &lt;code&gt;bisect_rev&lt;/code&gt; 对 &lt;code&gt;bisect_bad&lt;/code&gt; 不好的话，测试的期望提交数，我们现在正划分为 &lt;code&gt;bisect_all&lt;/code&gt; 的提交数。</target>
        </trans-unit>
        <trans-unit id="7d3cf717b036e3b0e81df34e24d7ea082a035f6a" translate="yes" xml:space="preserve">
          <source>This can allow you to make partial mirrors when running fetch; but is generally not recommended because history will be skipped and lost.</source>
          <target state="translated">这可以让你在运行fetch时制作部分镜像,但一般不建议使用,因为历史记录会被跳过并丢失。</target>
        </trans-unit>
        <trans-unit id="636e119b451b3bd7ccaf26b7d43733789f26ed19" translate="yes" xml:space="preserve">
          <source>This can also be set up as the default behaviour by using the &lt;code&gt;worktree.guessRemote&lt;/code&gt; config option.</source>
          <target state="translated">也可以使用 &lt;code&gt;worktree.guessRemote&lt;/code&gt; 配置选项将其设置为默认行为。</target>
        </trans-unit>
        <trans-unit id="fa409f68e80081ea9a669e9f13a5d077543254ef" translate="yes" xml:space="preserve">
          <source>This can be &lt;code&gt;end&lt;/code&gt;, which is the default, &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt; or &lt;code&gt;before&lt;/code&gt;.</source>
          <target state="translated">可以是 &lt;code&gt;end&lt;/code&gt; ，这是默认值， &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;after&lt;/code&gt; 或 &lt;code&gt;before&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0de02388f102cf8ff32d10ea0ea1542e4435ae39" translate="yes" xml:space="preserve">
          <source>This can be any options that the archiver backend understands. See next section.</source>
          <target state="translated">这可以是归档器后台理解的任何选项。见下一节。</target>
        </trans-unit>
        <trans-unit id="8ebe928ea2c46867d2d30a22aa44b6d209b60b27" translate="yes" xml:space="preserve">
          <source>This can be combined with the gitweb configuration:</source>
          <target state="translated">可以结合gitweb配置。</target>
        </trans-unit>
        <trans-unit id="3e2aafd0fe68d162abd0214f2c4dbcf97a317242" translate="yes" xml:space="preserve">
          <source>This can be enabled by default with the configuration option mailinfo.scissors.</source>
          <target state="translated">这可以通过配置选项mailinfo.scissors默认启用。</target>
        </trans-unit>
        <trans-unit id="90b17ef61d05f77323fefc823815f1b4d0ca5c24" translate="yes" xml:space="preserve">
          <source>This can be set to a comma-separated list of strings. When a curl trace is enabled (see &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; above), whenever a &quot;Cookies:&quot; header sent by the client is dumped, values of cookies whose key is in that list (case-sensitive) are redacted.</source>
          <target state="translated">可以将其设置为逗号分隔的字符串列表。启用卷曲跟踪时（请参见上面的 &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; ），每当转储客户端发送的&amp;ldquo; Cookies：&amp;rdquo;标头时，都会删除其键在该列表中（区分大小写）的cookie的值。</target>
        </trans-unit>
        <trans-unit id="3d49143ca76086473ec42d2280fe45285788984b" translate="yes" xml:space="preserve">
          <source>This can be used to color the metadata of a blame line depending on age of the line.</source>
          <target state="translated">这可以用来根据线的年龄对责备线的元数据进行着色。</target>
        </trans-unit>
        <trans-unit id="0f9fdab39f98d82a2bdc74c13a484288c9af48d4" translate="yes" xml:space="preserve">
          <source>This can be used to convert arguments to a command run in a subdirectory so that they can still be used after moving to the top-level of the repository. For example:</source>
          <target state="translated">这可以用来转换在子目录中运行的命令的参数,以便在移动到版本库的顶层后仍然可以使用。例如</target>
        </trans-unit>
        <trans-unit id="7c4f04c6d6345aed6141f4d5502d056991a7840c" translate="yes" xml:space="preserve">
          <source>This can be used when you want to include further changes to the merge, or want to write your own merge commit message.</source>
          <target state="translated">当你想对合并进行进一步的修改,或者想写自己的合并提交信息时,可以使用这个功能。</target>
        </trans-unit>
        <trans-unit id="14d1ead4268c0c0f3315fceadadaf2f291770d82" translate="yes" xml:space="preserve">
          <source>This can be used with the &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt; commands.</source>
          <target state="translated">可以与 &lt;code&gt;dcommit&lt;/code&gt; ， &lt;code&gt;rebase&lt;/code&gt; ， &lt;code&gt;branch&lt;/code&gt; 和 &lt;code&gt;tag&lt;/code&gt; 命令一起使用。</target>
        </trans-unit>
        <trans-unit id="9067f207a93cdcf6d90b3183367a4ae6097c31d6" translate="yes" xml:space="preserve">
          <source>This can be useful when you want to publish the tree from a commit without exposing its full history. You might want to do this to publish an open source branch of a project whose current tree is &quot;clean&quot;, but whose full history contains proprietary or otherwise encumbered bits of code.</source>
          <target state="translated">当你想在不暴露完整历史的情况下发布提交的代码树时,这个方法可能很有用。你可能想用这个方法来发布一个项目的开源分支,该分支当前的代码树是 &quot;干净的&quot;,但其完整的历史记录中包含了专有的或有其他限制的代码。</target>
        </trans-unit>
        <trans-unit id="4ddcbb1d5b5e22f922e078b6b0d84fe1dcc0409b" translate="yes" xml:space="preserve">
          <source>This can happen, for example, if you:</source>
          <target state="translated">这可能发生,例如,如果你。</target>
        </trans-unit>
        <trans-unit id="9140f80526c6eb06ff98ed4abf5c0d2e07067266" translate="yes" xml:space="preserve">
          <source>This can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities and is considered generally safe and fast.</source>
          <target state="translated">这只能使用3路合并算法解决两个头(即当前分支和你拉来的另一个分支)。它试图仔细检测交叉合并的歧义,被认为是一般安全和快速的。</target>
        </trans-unit>
        <trans-unit id="10679b433b60fbaff0452d6d903b314fee5164d2" translate="yes" xml:space="preserve">
          <source>This can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this can detect and handle merges involving renames, but currently cannot make use of detected copies. This is the default merge strategy when pulling or merging one branch.</source>
          <target state="translated">这只能用3路合并算法解决两个头。当有一个以上的共同祖先可以用于3-way合并时,它会创建一个共同祖先的合并树,并将其作为3-way合并的参考树。通过对 Linux 2.6 内核开发历史中的实际合并提交进行测试,发现这样做可以减少合并冲突,而不会造成错误合并。此外,它还可以检测和处理涉及重命名的合并,但目前还不能使用检测到的副本。这是拉取或合并一个分支时的默认合并策略。</target>
        </trans-unit>
        <trans-unit id="2cac39aeb86961e1363f7613dfed0033661ab943" translate="yes" xml:space="preserve">
          <source>This can speed up operations like &lt;code&gt;git diff&lt;/code&gt; and &lt;code&gt;git status&lt;/code&gt; especially on filesystems like NFS that have weak caching semantics and thus relatively high IO latencies. When enabled, Git will do the index comparison to the filesystem data in parallel, allowing overlapping IO&amp;rsquo;s. Defaults to true.</source>
          <target state="translated">这可以加快诸如 &lt;code&gt;git diff&lt;/code&gt; 和 &lt;code&gt;git status&lt;/code&gt; 之类的操作,尤其是在诸如NFS之类的文件系统上，这些系统具有较弱的缓存语义，因此具有相对较高的IO延迟。启用后，Git将并行对文件系统数据进行索引比较，从而允许重叠的IO。默认为true。</target>
        </trans-unit>
        <trans-unit id="9202266152fd1a0a2194149286bebd74fe30a95c" translate="yes" xml:space="preserve">
          <source>This capability can be advertised multiple times. The first applicable refspec takes precedence. The left-hand of refspecs advertised with this capability must cover all refs reported by the list command. If no &lt;code&gt;refspec&lt;/code&gt; capability is advertised, there is an implied &lt;code&gt;refspec *:*&lt;/code&gt;.</source>
          <target state="translated">此功能可以多次发布。第一个适用的refspec优先。用此功能发布的参考规范的左侧必须覆盖list命令报告的所有参考。如果没有发布 &lt;code&gt;refspec&lt;/code&gt; 功能，则暗示一个 &lt;code&gt;refspec *:*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="561397ab0857a5bada65e17ac4aabd661a6939b5" translate="yes" xml:space="preserve">
          <source>This chapter covers internal details of the Git implementation which probably only Git developers need to understand.</source>
          <target state="translated">本章涉及Git实现的内部细节,可能只有Git开发者才需要了解。</target>
        </trans-unit>
        <trans-unit id="9301665301f3e50c4417122a8411be226ea5b235" translate="yes" xml:space="preserve">
          <source>This command always gets all objects. Historically, there were three options &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-t&lt;/code&gt; for choosing which objects to download. They are now silently ignored.</source>
          <target state="translated">此命令始终获取所有对象。从历史上看，有三个选项 &lt;code&gt;-a&lt;/code&gt; ， &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;-t&lt;/code&gt; 用于选择要下载的对象。现在，它们被静默忽略。</target>
        </trans-unit>
        <trans-unit id="5b8a59dc9ca3a3d6f247d36df5fb54708fa69494" translate="yes" xml:space="preserve">
          <source>This command applies the patch but does not create a commit. Use &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; to create commits from patches generated by &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; and/or received by email.</source>
          <target state="translated">该命令应用补丁，但不创建提交。使用&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;从&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]生成&lt;/a&gt;和/或通过电子邮件收到的补丁中创建提交。</target>
        </trans-unit>
        <trans-unit id="1f849e1e7df08a5bb28860e4715d22e12f5d5d20" translate="yes" xml:space="preserve">
          <source>This command assists the developer in this process by recording conflicted automerge results and corresponding hand resolve results on the initial manual merge, and applying previously recorded hand resolutions to their corresponding automerge results.</source>
          <target state="translated">该命令协助开发人员在此过程中,在初始人工合并时记录冲突的自动合并结果和相应的手工解决结果,并将之前记录的手工解决结果应用到相应的自动合并结果中。</target>
        </trans-unit>
        <trans-unit id="b823d02fd766a4ae4b81090ce369454e7da568d6" translate="yes" xml:space="preserve">
          <source>This command caches credentials in memory for use by future Git programs. The stored credentials never touch the disk, and are forgotten after a configurable timeout. The cache is accessible over a Unix domain socket, restricted to the current user by filesystem permissions.</source>
          <target state="translated">这条命令会将凭证缓存在内存中,供未来的 Git 程序使用。存储的凭证永远不会接触磁盘,并在可配置的超时后被遗忘。缓存可以通过 Unix 域套接字访问,根据文件系统的权限限制当前用户使用。</target>
        </trans-unit>
        <trans-unit id="4784337d21599fe7fcfddcd79392d8470207170e" translate="yes" xml:space="preserve">
          <source>This command can be performed multiple times before a commit. It only adds the content of the specified file(s) at the time the add command is run; if you want subsequent changes included in the next commit, then you must run &lt;code&gt;git add&lt;/code&gt; again to add the new content to the index.</source>
          <target state="translated">提交前可以多次执行此命令。它仅在运行add命令时添加指定文件的内容；如果要在下一次提交中包含后续更改，则必须再次运行 &lt;code&gt;git add&lt;/code&gt; ，以将新内容添加到索引中。</target>
        </trans-unit>
        <trans-unit id="c286ab165ab2a31532b621372beb627366820ec4" translate="yes" xml:space="preserve">
          <source>This command can be used where a &lt;code&gt;filemodify&lt;/code&gt; directive can appear, allowing it to be used in the middle of a commit. For a &lt;code&gt;filemodify&lt;/code&gt; using an inline directive, it can also appear right before the &lt;code&gt;data&lt;/code&gt; directive.</source>
          <target state="translated">该命令可以在出现 &lt;code&gt;filemodify&lt;/code&gt; 指令的地方使用，从而可以在提交过程中使用它。对于使用内联指令的 &lt;code&gt;filemodify&lt;/code&gt; ，它也可以出现在 &lt;code&gt;data&lt;/code&gt; 指令之前。</target>
        </trans-unit>
        <trans-unit id="74e4352fd2289d447be4133ac0e6d68d162428a6" translate="yes" xml:space="preserve">
          <source>This command can run &lt;code&gt;applypatch-msg&lt;/code&gt;, &lt;code&gt;pre-applypatch&lt;/code&gt;, and &lt;code&gt;post-applypatch&lt;/code&gt; hooks. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">此命令可以运行 &lt;code&gt;applypatch-msg&lt;/code&gt; ， &lt;code&gt;pre-applypatch&lt;/code&gt; 和 &lt;code&gt;post-applypatch&lt;/code&gt; 挂钩。有关更多信息，请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e5610ce87e5d01d8f8246892b4f05f886b6ad5a" translate="yes" xml:space="preserve">
          <source>This command can run &lt;code&gt;commit-msg&lt;/code&gt;, &lt;code&gt;prepare-commit-msg&lt;/code&gt;, &lt;code&gt;pre-commit&lt;/code&gt;, &lt;code&gt;post-commit&lt;/code&gt; and &lt;code&gt;post-rewrite&lt;/code&gt; hooks. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">该命令可以运行 &lt;code&gt;commit-msg&lt;/code&gt; ， &lt;code&gt;prepare-commit-msg&lt;/code&gt; ， &lt;code&gt;pre-commit&lt;/code&gt; ， &lt;code&gt;post-commit&lt;/code&gt; 和 &lt;code&gt;post-rewrite&lt;/code&gt; 挂钩。有关更多信息，请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ba8d48bf258fdf0b61e4a3a7667022fd45b3e45" translate="yes" xml:space="preserve">
          <source>This command creates an empty Git repository - basically a &lt;code&gt;.git&lt;/code&gt; directory with subdirectories for &lt;code&gt;objects&lt;/code&gt;, &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, and template files. An initial &lt;code&gt;HEAD&lt;/code&gt; file that references the HEAD of the master branch is also created.</source>
          <target state="translated">此命令创建一个空的Git存储库-基本上是一个 &lt;code&gt;.git&lt;/code&gt; 目录，其中包含 &lt;code&gt;objects&lt;/code&gt; ， &lt;code&gt;refs/heads&lt;/code&gt; ， &lt;code&gt;refs/tags&lt;/code&gt; 和模板文件的子目录。还创建了引用master分支的HEAD 的初始 &lt;code&gt;HEAD&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="f52be87adec196973421cd7319ee0f98c1860983" translate="yes" xml:space="preserve">
          <source>This command degenerates to download everything to complete the asked refs from the remote side when the local side does not have a common ancestor commit.</source>
          <target state="translated">当本地端没有共同的祖先提交时,这个命令会退化到从远程端下载一切完成要求的refs。</target>
        </trans-unit>
        <trans-unit id="194b70091800ec19021441e8c1778ca9e02b53d5" translate="yes" xml:space="preserve">
          <source>This command ensures that the changes in the experimental branch are already in the current branch.</source>
          <target state="translated">该命令确保实验分支中的变化已经在当前分支中。</target>
        </trans-unit>
        <trans-unit id="1b788d383418fe8b134f7630991a2d6359c7dd7c" translate="yes" xml:space="preserve">
          <source>This command finds new changes in p4 and imports them as Git commits.</source>
          <target state="translated">这条命令可以找到 p4 中的新变化,并将其作为 Git 提交导入。</target>
        </trans-unit>
        <trans-unit id="4b11fc8efec3bd343a83e9f1aa4620a514b9ab8e" translate="yes" xml:space="preserve">
          <source>This command formats the lines of its standard input into a table with multiple columns. Each input line occupies one cell of the table. It is used internally by other git commands to format output into columns.</source>
          <target state="translated">该命令将其标准输入行格式化为一个多列的表格。每一行输入都占据了表格的一个单元格。它在内部被其他 git 命令用来将输出格式化为列。</target>
        </trans-unit>
        <trans-unit id="ade7fdc971ed1f0936fb8fbff7bb1574367ca37b" translate="yes" xml:space="preserve">
          <source>This command is extremely useful if the frontend does not know (or does not care to know) what files are currently on the branch, and therefore cannot generate the proper &lt;code&gt;filedelete&lt;/code&gt; commands to update the content.</source>
          <target state="translated">如果前端不知道（或不希望知道）分支上当前有哪些文件，因此无法生成正确的 &lt;code&gt;filedelete&lt;/code&gt; 命令来更新内容，则此命令非常有用。</target>
        </trans-unit>
        <trans-unit id="5f45dc9e63088b4d8e620891decbfdd6655de376" translate="yes" xml:space="preserve">
          <source>This command is intended mostly for internal use by scripts automatically invoking &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">该命令主要用于自动调用 &lt;code&gt;git merge&lt;/code&gt; 的脚本内部使用。</target>
        </trans-unit>
        <trans-unit id="3710225b15829bc8cbeb92895b81ff709286e645" translate="yes" xml:space="preserve">
          <source>This command is recursive by default.</source>
          <target state="translated">该命令默认是递归的。</target>
        </trans-unit>
        <trans-unit id="6e8668d616c8790cb8d71e8720597de54ced7850" translate="yes" xml:space="preserve">
          <source>This command is used to combine all objects that do not currently reside in a &quot;pack&quot;, into a pack. It can also be used to re-organize existing packs into a single, more efficient pack.</source>
          <target state="translated">这条命令用于将当前不在一个 &quot;包 &quot;中的所有对象合并成一个包。它也可以用来将现有的包重新组织成一个更有效的包。</target>
        </trans-unit>
        <trans-unit id="e7cbc44be580e3c1734536d3564c4b9dc7e501fa" translate="yes" xml:space="preserve">
          <source>This command is used to solve the storage and performance problem by storing the refs in a single file, &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt;. When a ref is missing from the traditional &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory hierarchy, it is looked up in this file and used if found.</source>
          <target state="translated">此命令用于通过将引用存储在单个文件 &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; 来解决存储和性能问题。当传统的 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 目录层次结构中缺少引用时，将在此文件中查找该引用并在找到后使用。</target>
        </trans-unit>
        <trans-unit id="43f707239bbecf8d6bf96bbdb4b367abb8fd5357" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git archive&lt;/code&gt; side, and the program pair is meant to be used to get an archive from a remote repository.</source>
          <target state="translated">最终用户通常不会直接调用此命令。协议的UI位于 &lt;code&gt;git archive&lt;/code&gt; 端，该程序对用于从远程存储库获取归档。</target>
        </trans-unit>
        <trans-unit id="17d67b43408b7b4804e33e1e3b79dc1fbf03af1b" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git fetch-pack&lt;/code&gt; side, and the program pair is meant to be used to pull updates from a remote repository. For push operations, see &lt;code&gt;git send-pack&lt;/code&gt;.</source>
          <target state="translated">最终用户通常不会直接调用此命令。协议的UI位于 &lt;code&gt;git fetch-pack&lt;/code&gt; 一侧，该程序对用于从远程存储库中提取更新。有关推送操作，请参见 &lt;code&gt;git send-pack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36ac8b84f92c3cf141e5ae101adcc45178aae4c7" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git send-pack&lt;/code&gt; side, and the program pair is meant to be used to push updates to remote repository. For pull operations, see &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt;.</source>
          <target state="translated">最终用户通常不会直接调用此命令。协议的UI位于 &lt;code&gt;git send-pack&lt;/code&gt; 一侧，该程序对用于将更新推送到远程存储库。有关拉操作，请参见&lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8cac5b996748b602d2e8f0cf9273cee3d1c4d80" translate="yes" xml:space="preserve">
          <source>This command lets you check that intermediate commits are compilable. The todo list becomes like that:</source>
          <target state="translated">这个命令让你检查中间提交是否可以编译。待办事项列表就会变成这样。</target>
        </trans-unit>
        <trans-unit id="56bca57be11add071b8aeae38f6a28f443105856" translate="yes" xml:space="preserve">
          <source>This command manages the information recorded in the reflogs.</source>
          <target state="translated">该命令管理重新记录的信息。</target>
        </trans-unit>
        <trans-unit id="7c7ebb85111dd101dc1c2782f6e5cbc235a39c44" translate="yes" xml:space="preserve">
          <source>This command provides a way to interact with p4 repositories using Git.</source>
          <target state="translated">该命令提供了一种使用 Git 与 p4 仓库进行交互的方法。</target>
        </trans-unit>
        <trans-unit id="637c92f99feb8b30861eeaee2e3273c64a9b5351" translate="yes" xml:space="preserve">
          <source>This command reads some patches or commit messages from either the &amp;lt;file&amp;gt; arguments or the standard input if no &amp;lt;file&amp;gt; is specified. If &lt;code&gt;--parse&lt;/code&gt; is specified, the output consists of the parsed trailers.</source>
          <target state="translated">如果未指定&amp;lt;file&amp;gt;，则此命令从&amp;lt;file&amp;gt;参数或标准输入读取某些补丁或提交消息。如果指定了 &lt;code&gt;--parse&lt;/code&gt; ，则输出由已解析的预告片组成。</target>
        </trans-unit>
        <trans-unit id="a38646d64359b52991af1358c674765acf2c0c11" translate="yes" xml:space="preserve">
          <source>This command should not list any commits. Otherwise, check out &lt;code&gt;master&lt;/code&gt; and merge &lt;code&gt;maint&lt;/code&gt; into it.</source>
          <target state="translated">该命令不应列出任何提交。否则，请检出 &lt;code&gt;master&lt;/code&gt; 并将 &lt;code&gt;maint&lt;/code&gt; 合并到其中。</target>
        </trans-unit>
        <trans-unit id="6a853b09f1818b9d32f936bd42aa8a84af13b068" translate="yes" xml:space="preserve">
          <source>This command shows the differences between two versions of a patch series, or more generally, two commit ranges (ignoring merge commits).</source>
          <target state="translated">这条命令显示了一个补丁系列的两个版本之间的差异,或者更一般地说,两个提交范围之间的差异(忽略合并提交)。</target>
        </trans-unit>
        <trans-unit id="852903a68075d19a47d4520af94edde77996207f" translate="yes" xml:space="preserve">
          <source>This command stores credentials indefinitely on disk for use by future Git programs.</source>
          <target state="translated">这条命令会将凭证无限期地存储在磁盘上,供以后的 Git 程序使用。</target>
        </trans-unit>
        <trans-unit id="d143bf10d727fe2f5d0639ed85e199dd448d8bd2" translate="yes" xml:space="preserve">
          <source>This command updates the index using the current content found in the working tree, to prepare the content staged for the next commit. It typically adds the current content of existing paths as a whole, but with some options it can also be used to add content with only part of the changes made to the working tree files applied, or remove paths that do not exist in the working tree anymore.</source>
          <target state="translated">这条命令使用工作树中的当前内容更新索引,为下一次提交准备分期的内容。它通常会将现有路径的内容作为一个整体来添加,但通过一些选项,它也可以用来添加只应用了工作树文件的部分更改的内容,或者删除工作树中已经不存在的路径。</target>
        </trans-unit>
        <trans-unit id="61eacd31ecbd262bdcbed11d9c6103318919d1be" translate="yes" xml:space="preserve">
          <source>This command uploads a mailbox generated with &lt;code&gt;git format-patch&lt;/code&gt; into an IMAP drafts folder. This allows patches to be sent as other email is when using mail clients that cannot read mailbox files directly. The command also works with any general mailbox in which emails have the fields &quot;From&quot;, &quot;Date&quot;, and &quot;Subject&quot; in that order.</source>
          <target state="translated">此命令将使用 &lt;code&gt;git format-patch&lt;/code&gt; 生成的邮箱上载到 IMAP草稿文件夹。使用无法直接读取邮箱文件的邮件客户端时，这可以像发送其他电子邮件一样发送补丁程序。该命令还可以与任何常规邮箱一起使用，在该邮箱中，电子邮件的顺序为&amp;ldquo;发件人&amp;rdquo;，&amp;ldquo;日期&amp;rdquo;和&amp;ldquo;主题&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a3bcbdfcf8f3a072ac23f24cf310648f9691fb70" translate="yes" xml:space="preserve">
          <source>This command uses a binary search algorithm to find which commit in your project&amp;rsquo;s history introduced a bug. You use it by first telling it a &quot;bad&quot; commit that is known to contain the bug, and a &quot;good&quot; commit that is known to be before the bug was introduced. Then &lt;code&gt;git
bisect&lt;/code&gt; picks a commit between those two endpoints and asks you whether the selected commit is &quot;good&quot; or &quot;bad&quot;. It continues narrowing down the range until it finds the exact commit that introduced the change.</source>
          <target state="translated">此命令使用二进制搜索算法来查找项目历史记录中的哪个提交引入了错误。通过首先告诉它包含臭虫的&amp;ldquo;坏&amp;rdquo;提交和引入臭虫之前的&amp;ldquo;好&amp;rdquo;提交来使用它。然后 &lt;code&gt;git bisect&lt;/code&gt; 在这两个端点之间选择一个提交，并询问您所选择的提交是&amp;ldquo;好&amp;rdquo;还是&amp;ldquo;坏&amp;rdquo;。它继续缩小范围，直到找到引入更改的确切提交为止。</target>
        </trans-unit>
        <trans-unit id="097f8af4b6f26b418927a5ca4b24d71746b1f843" translate="yes" xml:space="preserve">
          <source>This command uses the &lt;code&gt;diff.color.*&lt;/code&gt; and &lt;code&gt;pager.range-diff&lt;/code&gt; settings (the latter is on by default). See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">此命令使用 &lt;code&gt;diff.color.*&lt;/code&gt; 和 &lt;code&gt;pager.range-diff&lt;/code&gt; 设置（默认情况下启用）。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03bab6a03561ee7ff2e9bf92505bcdd5322bfb51" translate="yes" xml:space="preserve">
          <source>This command will fail with non-zero status upon error. Some exit codes are:</source>
          <target state="translated">该命令在出错时将以非零状态失败。一些退出代码是:</target>
        </trans-unit>
        <trans-unit id="7ed6af6e5518c122d94f4b8fea824fc7938bd5aa" translate="yes" xml:space="preserve">
          <source>This command will fetch changes from the remote branches to your remote-tracking branches &lt;code&gt;origin/*&lt;/code&gt;, and merge the default branch into the current branch.</source>
          <target state="translated">此命令将从远程分支获取更改到远程跟踪分支 &lt;code&gt;origin/*&lt;/code&gt; ，并将默认分支合并到当前分支。</target>
        </trans-unit>
        <trans-unit id="99c24081605f25434a1fa0a51df82045bf4b7763" translate="yes" xml:space="preserve">
          <source>This command will save your changes away to the &lt;code&gt;stash&lt;/code&gt;, and reset your working tree and the index to match the tip of your current branch. Then you can make your fix as usual.</source>
          <target state="translated">此命令会将您的更改保存到 &lt;code&gt;stash&lt;/code&gt; ，并重置工作树和索引以匹配当前分支的尖端。然后，您可以照常进行修复。</target>
        </trans-unit>
        <trans-unit id="cb41b9bb98cbe715b8d6c0b50eb0b52309cdc91a" translate="yes" xml:space="preserve">
          <source>This commit will get blown away so a throw-away log message is OK.</source>
          <target state="translated">这个提交会被炸掉,所以扔掉的日志信息是可以的。</target>
        </trans-unit>
        <trans-unit id="068d7057b3017084327709c3e61c2e224fb2a5f6" translate="yes" xml:space="preserve">
          <source>This commits all other changes in the index.</source>
          <target state="translated">这将提交索引中的所有其他更改。</target>
        </trans-unit>
        <trans-unit id="1d649ab8ff53024e7549864469811ccee0abf2e7" translate="yes" xml:space="preserve">
          <source>This commits your first edits in &lt;code&gt;branch1&lt;/code&gt;.</source>
          <target state="translated">这将在 &lt;code&gt;branch1&lt;/code&gt; 中提交您的第一次编辑。</target>
        </trans-unit>
        <trans-unit id="8bc13c84a009ea0d6abb173ac6100dc00ae7606a" translate="yes" xml:space="preserve">
          <source>This compares stage 2 (our branch), stage 3 (their branch) and the working tree file and outputs a combined diff, similar to the way &lt;code&gt;diff-tree&lt;/code&gt; shows a merge commit with these flags.</source>
          <target state="translated">这将比较阶段2（我们的分支），阶段3（他们的分支）和工作树文件，并输出组合的diff，类似于 &lt;code&gt;diff-tree&lt;/code&gt; 显示带有这些标志的合并提交的方式。</target>
        </trans-unit>
        <trans-unit id="d3fe164a17e549b712f12743eb90dc676fb8455c" translate="yes" xml:space="preserve">
          <source>This computation involves traversing all the reachable objects, i.e. it has the same cost as &lt;code&gt;git prune&lt;/code&gt;. It is primarily intended to fix corruption caused by garbage collecting using older versions of Git, which didn&amp;rsquo;t protect objects referred to by reflogs.</source>
          <target state="translated">该计算涉及遍历所有可到达的对象，即，其成本与 &lt;code&gt;git prune&lt;/code&gt; 相同。它的主要目的是修复使用较旧版本的Git进行垃圾收集所导致的损坏，该版本未保护reflog引用的对象。</target>
        </trans-unit>
        <trans-unit id="9e7c3905269f2318ce8a27a07b91b053d9dd7129" translate="yes" xml:space="preserve">
          <source>This configuration can be specified multiple times in order to allow multiple notes refs to be included. In that case, it will behave similarly to multiple &lt;code&gt;--[no-]notes[=]&lt;/code&gt; options passed in. That is, a value of &lt;code&gt;true&lt;/code&gt; will show the default notes, a value of &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; will also show notes from that notes ref and a value of &lt;code&gt;false&lt;/code&gt; will negate previous configurations and not show notes.</source>
          <target state="translated">可以多次指定此配置，以允许包含多个注释引用。在这种情况下，它的行为类似于传入的多个 &lt;code&gt;--[no-]notes[=]&lt;/code&gt; 选项。即，值为 &lt;code&gt;true&lt;/code&gt; 将显示默认注释，值为 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 还将显示该注释中的注释ref和 &lt;code&gt;false&lt;/code&gt; 值将否定以前的配置，并且不显示注释。</target>
        </trans-unit>
        <trans-unit id="e6aa4372bde5e931f9e4e006e5a3cd0aea5ccf17" translate="yes" xml:space="preserve">
          <source>This configuration is used in two ways:</source>
          <target state="translated">这种配置有两种使用方式。</target>
        </trans-unit>
        <trans-unit id="06f31556dacb48424e7a1be662dd26364f785ce9" translate="yes" xml:space="preserve">
          <source>This configuration variable is useful in cases where you&amp;rsquo;d like to centrally configure your Git hooks instead of configuring them on a per-repository basis, or as a more flexible and centralized alternative to having an &lt;code&gt;init.templateDir&lt;/code&gt; where you&amp;rsquo;ve changed default hooks.</source>
          <target state="translated">此配置变量在您希望集中配置Git挂钩而不是基于每个存储库进行配置的情况下非常有用，或者作为在更改了默认挂钩之后使用 &lt;code&gt;init.templateDir&lt;/code&gt; 的更灵活，更集中的替代方法。</target>
        </trans-unit>
        <trans-unit id="eed4a11499740f4bb5f61d3ce7354c5409f33bf3" translate="yes" xml:space="preserve">
          <source>This configures how whitespace is ignored when performing the move detection for &lt;code&gt;--color-moved&lt;/code&gt;. It can be set by the &lt;code&gt;diff.colorMovedWS&lt;/code&gt; configuration setting. These modes can be given as a comma separated list:</source>
          <target state="translated">这配置了对 &lt;code&gt;--color-moved&lt;/code&gt; 执行移动检测时如何忽略空格。可以通过 &lt;code&gt;diff.colorMovedWS&lt;/code&gt; 配置设置进行设置。这些模式可以以逗号分隔的列表形式给出：</target>
        </trans-unit>
        <trans-unit id="9b4ea1fd788cef298d939e77017eddec04b80461" translate="yes" xml:space="preserve">
          <source>This configures how whitespace is ignored when performing the move detection for &lt;code&gt;--color-moved&lt;/code&gt;. These modes can be given as a comma separated list:</source>
          <target state="translated">这配置了对 &lt;code&gt;--color-moved&lt;/code&gt; 执行移动检测时如何忽略空格。这些模式可以以逗号分隔的列表形式给出：</target>
        </trans-unit>
        <trans-unit id="77030a3f3e0bddf7aada34bc0939552bc0993e3c" translate="yes" xml:space="preserve">
          <source>This counts the number of unpacked object files and disk space consumed by them, to help you decide when it is a good time to repack.</source>
          <target state="translated">这将统计未打包的对象文件的数量和它们所消耗的磁盘空间,以帮助你决定何时是重新打包的好时机。</target>
        </trans-unit>
        <trans-unit id="3e67b0f2a3d6f811dcdec6a80edd2cc8d01b0b6b" translate="yes" xml:space="preserve">
          <source>This creates a &quot;lightweight&quot; tag. If you would also like to include a comment with the tag, and possibly sign it cryptographically, then you should create a tag object instead; see the &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; man page for details.</source>
          <target state="translated">这将创建一个&amp;ldquo;轻量级&amp;rdquo;标签。如果您还希望在标签中包含注释，并可能对其进行加密签名，则应该创建一个标签对象；有关详细信息，请参见&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;手册页。</target>
        </trans-unit>
        <trans-unit id="687e61032de29ec5a828bf99d3854a432acd2a82" translate="yes" xml:space="preserve">
          <source>This creates a new directory &quot;myrepo&quot; containing a clone of Alice&amp;rsquo;s repository. The clone is on an equal footing with the original project, possessing its own copy of the original project&amp;rsquo;s history.</source>
          <target state="translated">这将创建一个新目录&amp;ldquo; myrepo&amp;rdquo;，其中包含Alice存储库的克隆。该克隆副本与原始项目处于平等地位，拥有自己的原始项目历史副本。</target>
        </trans-unit>
        <trans-unit id="c2fd84fc2fa04021fed2cadb8707ca64b05a22fb" translate="yes" xml:space="preserve">
          <source>This creates a single &quot;pack file&quot; in .git/objects/pack/ containing all currently unpacked objects. You can then run</source>
          <target state="translated">这将在 .git/objects/pack/中创建一个单一的 &quot;pack文件&quot;,其中包含所有当前未打包的对象。然后您可以运行</target>
        </trans-unit>
        <trans-unit id="bf43931e74b20a3da5197ed923f890fe71d72016" translate="yes" xml:space="preserve">
          <source>This default configuration is achieved by creating references to the remote branch heads under &lt;code&gt;refs/remotes/origin&lt;/code&gt; and by initializing &lt;code&gt;remote.origin.url&lt;/code&gt; and &lt;code&gt;remote.origin.fetch&lt;/code&gt; configuration variables.</source>
          <target state="translated">通过在 &lt;code&gt;refs/remotes/origin&lt;/code&gt; 下创建对远程分支头的引用并初始化 &lt;code&gt;remote.origin.url&lt;/code&gt; 和 &lt;code&gt;remote.origin.fetch&lt;/code&gt; 配置变量来实现此默认配置。</target>
        </trans-unit>
        <trans-unit id="984768ad68337dfe2b0015e657c9f4f069afabc8" translate="yes" xml:space="preserve">
          <source>This defines two submodules, &lt;code&gt;libfoo&lt;/code&gt; and &lt;code&gt;libbar&lt;/code&gt;. These are expected to be checked out in the paths &lt;code&gt;include/foo&lt;/code&gt; and &lt;code&gt;include/bar&lt;/code&gt;, and for both submodules a URL is specified which can be used for cloning the submodules.</source>
          <target state="translated">这定义了两个子模块 &lt;code&gt;libfoo&lt;/code&gt; 和 &lt;code&gt;libbar&lt;/code&gt; 。可以在 &lt;code&gt;include/foo&lt;/code&gt; 和 &lt;code&gt;include/bar&lt;/code&gt; 路径中检出它们，并且为两个子模块都指定一个URL，该URL可用于克隆子模块。</target>
        </trans-unit>
        <trans-unit id="57db5304522b1070a0df1071ce5df5d38ea7d002" translate="yes" xml:space="preserve">
          <source>This describes how Tony Luck uses Git in his role as maintainer of the IA64 architecture for the Linux kernel.</source>
          <target state="translated">本文介绍了Tony Luck作为Linux内核IA64架构的维护者如何使用Git。</target>
        </trans-unit>
        <trans-unit id="c9e275f2996b22cd4415c594fae8f08a0dfe70e8" translate="yes" xml:space="preserve">
          <source>This determines the coloring scheme to be applied to blame output. It can be &lt;code&gt;repeatedLines&lt;/code&gt;, &lt;code&gt;highlightRecent&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt; which is the default.</source>
          <target state="translated">这确定了要应用于责备输出的着色方案。它可以是 &lt;code&gt;repeatedLines&lt;/code&gt; ， &lt;code&gt;highlightRecent&lt;/code&gt; 或默认的 &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56ee29b22f07db9306c3380b74b5b0180828e415" translate="yes" xml:space="preserve">
          <source>This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/objects&quot; will be used instead.</source>
          <target state="translated">如果设置了 $GIT_COMMON_DIR,这个目录就会被忽略,取而代之的是 &quot;$GIT_COMMON_DIR/objects&quot;。</target>
        </trans-unit>
        <trans-unit id="2072b137cd96280de0e098678b51f23a76dcd0dc" translate="yes" xml:space="preserve">
          <source>This disables potentially expensive checks to workaround broken symlinks checked into SVN by broken clients. Set this option to &quot;false&quot; if you track a SVN repository with many empty blobs that are not symlinks. This option may be changed while &lt;code&gt;git svn&lt;/code&gt; is running and take effect on the next revision fetched. If unset, &lt;code&gt;git svn&lt;/code&gt; assumes this option to be &quot;true&quot;.</source>
          <target state="translated">这会禁用潜在的昂贵检查，以解决由损坏的客户端签入SVN的损坏的符号链接。如果您跟踪带有许多不是符号链接的空blob的SVN存储库，请将此选项设置为&amp;ldquo; false&amp;rdquo;。 &lt;code&gt;git svn&lt;/code&gt; 运行时可以更改此选项，并在获取的下一个修订版本上生效。如果未设置，则 &lt;code&gt;git svn&lt;/code&gt; 假定此选项为&amp;ldquo; true&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="006e62625e60aabc7f31fa591f6f9b4a3bd2a878" translate="yes" xml:space="preserve">
          <source>This document attempts to write down and motivate some of the workflow elements used for &lt;code&gt;git.git&lt;/code&gt; itself. Many ideas apply in general, though the full workflow is rarely required for smaller projects with fewer people involved.</source>
          <target state="translated">本文档试图写下并激励一些用于 &lt;code&gt;git.git&lt;/code&gt; 本身的工作流元素。通常有许多想法适用，尽管对于涉及较少人员的小型项目，很少需要完整的工作流程。</target>
        </trans-unit>
        <trans-unit id="8cd9193645885514540ac19f3167f508bebca422" translate="yes" xml:space="preserve">
          <source>This document presents a specification for a version 2 of Git&amp;rsquo;s wire protocol. Protocol v2 will improve upon v1 in the following ways:</source>
          <target state="translated">本文档介绍了Git有线协议版本2的规范。协议v2将在以下方面对v1进行改进：</target>
        </trans-unit>
        <trans-unit id="46bd1a26c48d1772be26d3d869cc4b6544004ea1" translate="yes" xml:space="preserve">
          <source>This document shows the &quot;raw&quot; syntax as seen by git. The shell and other UIs might require additional quoting to protect special characters and to avoid word splitting.</source>
          <target state="translated">本文档展示了 git 所看到的 &quot;原始 &quot;语法,shell 和其他用户界面可能需要额外的引号来保护特殊字符,并避免拆字。在shell和其他用户接口中,可能需要额外的引号来保护特殊字符,并避免词的分割。</target>
        </trans-unit>
        <trans-unit id="a76f8971dde9f8810b677765aca0d70490d9f8fa" translate="yes" xml:space="preserve">
          <source>This document will serve as the master list for extensions. Any implementation wishing to define a new extension should make a note of it here, in order to claim the name.</source>
          <target state="translated">本文件将作为扩展名的主列表。任何希望定义新扩展的实现都应在此注明,以便使用该名称。</target>
        </trans-unit>
        <trans-unit id="d24a591988945bec7d040b25bd5a37c73014bcf3" translate="yes" xml:space="preserve">
          <source>This does not affect &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; or the &lt;code&gt;git-diff-*&lt;/code&gt; plumbing commands. Can be overridden on the command line with the &lt;code&gt;--color[=&amp;lt;when&amp;gt;]&lt;/code&gt; option.</source>
          <target state="translated">这不会影响&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;或 &lt;code&gt;git-diff-*&lt;/code&gt; 管道命令。可以使用 &lt;code&gt;--color[=&amp;lt;when&amp;gt;]&lt;/code&gt; 选项在命令行上覆盖。</target>
        </trans-unit>
        <trans-unit id="99af460532d2c9f72e65ed17f7464c8aa563e1f4" translate="yes" xml:space="preserve">
          <source>This does not force normalization of text files, but does ensure that text files that you introduce to the repository have their line endings normalized to LF when they are added, and that files that are already normalized in the repository stay normalized.</source>
          <target state="translated">这并不强制对文本文件进行归一化,但可以确保你引入到版本库的文本文件在添加时,其行结尾会被归一化为LF,而且版本库中已经归一化的文件会保持归一化。</target>
        </trans-unit>
        <trans-unit id="257328db317fb853114a41f8430f87cd826d08a0" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t interfere with interoperating with the Subversion repository you cloned from, but if you wish for your local Git repository to be able to interoperate with someone else&amp;rsquo;s local Git repository, either don&amp;rsquo;t use this option or you should both use it in the same local time zone.</source>
          <target state="translated">这不会干扰与您克隆的Subversion存储库的互操作，但是如果您希望本地Git存储库能够与其他人的本地Git存储库进行互操作，请不要使用此选项，或者您都应在相同的当地时区。</target>
        </trans-unit>
        <trans-unit id="45497ef8f3614492732f059c04bc30af3c6593e9" translate="yes" xml:space="preserve">
          <source>This effectively runs &lt;code&gt;add --interactive&lt;/code&gt;, but bypasses the initial command menu and directly jumps to the &lt;code&gt;patch&lt;/code&gt; subcommand. See &amp;ldquo;Interactive mode&amp;rdquo; for details.</source>
          <target state="translated">这将有效地运行 &lt;code&gt;add --interactive&lt;/code&gt; ，但会绕过初始命令菜单，而直接跳转到 &lt;code&gt;patch&lt;/code&gt; 子命令。有关详细信息，请参见&amp;ldquo;交互模式&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="53c54ba0465bbf9916ac436659dbf61aedb86156" translate="yes" xml:space="preserve">
          <source>This enables parent rewriting, see &lt;code&gt;History Simplification&lt;/code&gt; above.</source>
          <target state="translated">这将启用父级重写，请参见上面的&amp;ldquo; &lt;code&gt;History Simplification&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccdf590466d01d04dcf6da8ad6a6bec9f02c4d8e" translate="yes" xml:space="preserve">
          <source>This environment allows the specification of an alternate index file. If not specified, the default of &lt;code&gt;$GIT_DIR/index&lt;/code&gt; is used.</source>
          <target state="translated">此环境允许指定备用索引文件。如果未指定，则使用默认值 &lt;code&gt;$GIT_DIR/index&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2abd55a6650395bf249165e2f6568e98ab14958c" translate="yes" xml:space="preserve">
          <source>This environment variable allows the specification of an index version for new repositories. It won&amp;rsquo;t affect existing index files. By default index file version 2 or 3 is used. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; for more information.</source>
          <target state="translated">此环境变量允许为新存储库指定索引版本。它不会影响现有的索引文件。默认情况下，使用索引文件版本2或3。有关更多信息，请参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2763e4fc7ba1973ac90184c067d20f9d0fda70a8" translate="yes" xml:space="preserve">
          <source>This environment variable overrides &lt;code&gt;$EDITOR&lt;/code&gt; and &lt;code&gt;$VISUAL&lt;/code&gt;. It is used by several Git commands when, on interactive mode, an editor is to be launched. See also &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; and the &lt;code&gt;core.editor&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">此环境变量将覆盖 &lt;code&gt;$EDITOR&lt;/code&gt; 和 &lt;code&gt;$VISUAL&lt;/code&gt; 。在交互模式下，要启动编辑器时，它由多个Git命令使用。另请参见&lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt;和&lt;a href=&quot;git-config&quot;&gt;git-config [1]中&lt;/a&gt;的 &lt;code&gt;core.editor&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="ddbc158f0dcc3c8ea52494b42fbb66d15e06e460" translate="yes" xml:space="preserve">
          <source>This environment variable overrides &lt;code&gt;$PAGER&lt;/code&gt;. If it is set to an empty string or to the value &quot;cat&quot;, Git will not launch a pager. See also the &lt;code&gt;core.pager&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">此环境变量将覆盖 &lt;code&gt;$PAGER&lt;/code&gt; 。如果将其设置为空字符串或值&amp;ldquo; cat&amp;rdquo;，则Git将不会启动寻呼机。另请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]中&lt;/a&gt;的 &lt;code&gt;core.pager&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="25ea93764f52eb3dcc477c86398962bd9bbded98" translate="yes" xml:space="preserve">
          <source>This event contains the command name for this git process and the hierarchy of commands from parent git processes.</source>
          <target state="translated">这个事件包含了这个git进程的命令名称和父git进程的命令层次。</target>
        </trans-unit>
        <trans-unit id="f5d9f72db5c7ffa9776d5c71964338d54a2515a4" translate="yes" xml:space="preserve">
          <source>This event contains the complete argv received by main().</source>
          <target state="translated">这个事件包含了main()收到的完整的argv。</target>
        </trans-unit>
        <trans-unit id="2a4c1f111536d47e2687ea692bfe5bd399b4307d" translate="yes" xml:space="preserve">
          <source>This event contains the discovered full path of the git executable (on platforms that are configured to resolve it).</source>
          <target state="translated">该事件包含发现的git可执行文件的完整路径(在配置为解析的平台上)。</target>
        </trans-unit>
        <trans-unit id="c8af8dbf59abf700f44d6449c7c951b54692bd2e" translate="yes" xml:space="preserve">
          <source>This event defines a repo-id and associates it with the root of the worktree.</source>
          <target state="translated">该事件定义了一个repo-id,并将其与工作树的根相关联。</target>
        </trans-unit>
        <trans-unit id="efbcacd1a490c688869fdd46397140e75919d7ab" translate="yes" xml:space="preserve">
          <source>This event describes a child process that is about to be spawned.</source>
          <target state="translated">该事件描述了一个即将被生成的子流程。</target>
        </trans-unit>
        <trans-unit id="8c8f935852467fd7c3b46787d77518dc3611a986" translate="yes" xml:space="preserve">
          <source>This event gives the version of the executable and the EVENT format. It should always be the first event in a trace session. The EVENT format version will be incremented if new event types are added, if existing fields are removed, or if there are significant changes in interpretation of existing events or fields. Smaller changes, such as adding a new field to an existing event, will not require an increment to the EVENT format version.</source>
          <target state="translated">该事件给出了可执行文件的版本和EVENT格式。它应该始终是跟踪会话中的第一个事件。如果增加了新的事件类型,删除了现有的字段,或者对现有事件或字段的解释有重大变化,EVENT格式版本将被递增。较小的变化,如在现有事件中添加一个新字段,将不需要递增EVENT格式版本。</target>
        </trans-unit>
        <trans-unit id="7ea085d0e611d87af89c62af2b70656c0016dc7e" translate="yes" xml:space="preserve">
          <source>This event is emitted by the Trace2 &lt;code&gt;atexit&lt;/code&gt; routine during final shutdown. It should be the last event emitted by the process.</source>
          <target state="translated">在最终关闭期间，Trace2 &lt;code&gt;atexit&lt;/code&gt; 例程会发出此事件。它应该是流程发出的最后一个事件。</target>
        </trans-unit>
        <trans-unit id="0b20979b7d0436896a9e4dd619b31c2f047cbd64" translate="yes" xml:space="preserve">
          <source>This event is emitted when git calls &lt;code&gt;exit()&lt;/code&gt;.</source>
          <target state="translated">当git调用 &lt;code&gt;exit()&lt;/code&gt; 时发出此事件。</target>
        </trans-unit>
        <trans-unit id="9c63cb7135e802e553dc499a675da732d4f96c3a" translate="yes" xml:space="preserve">
          <source>This event is emitted when one of the &lt;code&gt;error()&lt;/code&gt;, &lt;code&gt;die()&lt;/code&gt;, or &lt;code&gt;usage()&lt;/code&gt; functions are called.</source>
          <target state="translated">调用 &lt;code&gt;error()&lt;/code&gt; ， &lt;code&gt;die()&lt;/code&gt; 或 &lt;code&gt;usage()&lt;/code&gt; 函数之一时，将发出此事件。</target>
        </trans-unit>
        <trans-unit id="ebb8b872e605289564f67171a3133d84781ab210" translate="yes" xml:space="preserve">
          <source>This event is emitted when the program is terminated by a user signal. Depending on the platform, the signal event may prevent the &quot;atexit&quot; event from being generated.</source>
          <target state="translated">当程序被用户信号终止时,会发出该事件。根据平台的不同,该信号事件可能会阻止 &quot;atexit &quot;事件的产生。</target>
        </trans-unit>
        <trans-unit id="2ca8802f12c75856c4e7ea399ac7a1939e2a37eb" translate="yes" xml:space="preserve">
          <source>This event is generated after the current process has returned from the waitpid() and collected the exit information from the child.</source>
          <target state="translated">该事件在当前进程从waitpid()返回并收集了子进程的退出信息后产生。</target>
        </trans-unit>
        <trans-unit id="9fe6d803410a7d3a5cd4bc2114534352d230200b" translate="yes" xml:space="preserve">
          <source>This event is generated before git attempts to &lt;code&gt;exec()&lt;/code&gt; another command rather than starting a child process.</source>
          <target state="translated">这个事件是在git尝试 &lt;code&gt;exec()&lt;/code&gt; 另一个命令而不是启动子进程之前生成的。</target>
        </trans-unit>
        <trans-unit id="93caa8939f471f1240286ec30c6905ef3996f20e" translate="yes" xml:space="preserve">
          <source>This event is generated if the &lt;code&gt;exec()&lt;/code&gt; fails and control returns to the current git command.</source>
          <target state="translated">如果 &lt;code&gt;exec()&lt;/code&gt; 失败并且控制返回到当前的git命令，则会生成此事件。</target>
        </trans-unit>
        <trans-unit id="814427d239ec02f31ac7bf0fb913766e18bfb53e" translate="yes" xml:space="preserve">
          <source>This event is generated to log a global parameter.</source>
          <target state="translated">该事件的产生是为了记录一个全局参数。</target>
        </trans-unit>
        <trans-unit id="54b6cc61590e1e0eba249cc8ddd71ddff154355b" translate="yes" xml:space="preserve">
          <source>This event is generated to log a pre-formatted JSON string containing structured data.</source>
          <target state="translated">该事件的产生是为了记录一个包含结构化数据的预格式化JSON字符串。</target>
        </trans-unit>
        <trans-unit id="0ee97bbcf1fde0cf306363257efe6b7de578045e" translate="yes" xml:space="preserve">
          <source>This event is generated to log a thread- and region-local key/value pair.</source>
          <target state="translated">该事件的产生是为了记录线程和区域的本地键/值对。</target>
        </trans-unit>
        <trans-unit id="4caa8d05330c9e1126d8391705e312b0d8975d63" translate="yes" xml:space="preserve">
          <source>This event is generated when a thread exits. It is generated from &lt;strong&gt;within&lt;/strong&gt; the thread&amp;rsquo;s thread-proc (for TLS reasons).</source>
          <target state="translated">线程退出时会生成此事件。它是从线程的thread-proc &lt;strong&gt;内部&lt;/strong&gt;生成的（出于TLS的原因）。</target>
        </trans-unit>
        <trans-unit id="eba565beaf1b2269c764c147f5196869afe38bce" translate="yes" xml:space="preserve">
          <source>This event is generated when a thread is started. It is generated from &lt;strong&gt;within&lt;/strong&gt; the new thread&amp;rsquo;s thread-proc (for TLS reasons).</source>
          <target state="translated">启动线程时生成此事件。它是&lt;strong&gt;在&lt;/strong&gt;新线程的thread-proc &lt;strong&gt;内部&lt;/strong&gt;生成的（出于TLS的原因）。</target>
        </trans-unit>
        <trans-unit id="1684fe3e3862662b36c1dfb0c9bb20558e1f338a" translate="yes" xml:space="preserve">
          <source>This event is generated when entering a region.</source>
          <target state="translated">该事件在进入一个区域时产生。</target>
        </trans-unit>
        <trans-unit id="809d72e4f54bac6c7054af4e990fa8c97e8c764d" translate="yes" xml:space="preserve">
          <source>This event is generated when leaving a region.</source>
          <target state="translated">该事件在离开一个区域时产生。</target>
        </trans-unit>
        <trans-unit id="1e6a7368deeb7ec580313fc82400f1c12d17672a" translate="yes" xml:space="preserve">
          <source>This event is present when an alias is expanded.</source>
          <target state="translated">当一个别名被展开时,该事件就会出现。</target>
        </trans-unit>
        <trans-unit id="bca802363ffa9599d9e13df71e2f62ec1454e32f" translate="yes" xml:space="preserve">
          <source>This event is written to the git-trace2-discard sentinel file if there are too many files in the target trace directory (see the trace2.maxFiles config option).</source>
          <target state="translated">如果目标跟踪目录中的文件太多,该事件会被写入 git-trace2-discard sentinel 文件(参见 trace2.maxFiles 配置选项)。</target>
        </trans-unit>
        <trans-unit id="8c2ad60a0d9356a6e908b18056fbac1c2b1d4129" translate="yes" xml:space="preserve">
          <source>This event, when present, describes the command variant This event may be emitted more than once.</source>
          <target state="translated">该事件在出现时,描述了命令的变体。</target>
        </trans-unit>
        <trans-unit id="3e7d09cee878b03064fb9d9484c73f3f00225826" translate="yes" xml:space="preserve">
          <source>This example also shows that thread names are assigned in a racy manner as each thread starts and allocates TLS storage.</source>
          <target state="translated">这个例子还表明,在每个线程启动和分配TLS存储时,线程名称都是以一种狂热的方式分配的。</target>
        </trans-unit>
        <trans-unit id="e296b28f1fcad64b66f85f9abe931f54fc5fbde0" translate="yes" xml:space="preserve">
          <source>This example imports a new remote &quot;p4/proj2&quot; into an existing Git repository:</source>
          <target state="translated">本例将新的远程 &quot;p4/proj2 &quot;导入到现有的 Git 仓库中。</target>
        </trans-unit>
        <trans-unit id="7cbbc9fac80d3f9e05217d26ad6f34ea5097abe6" translate="yes" xml:space="preserve">
          <source>This example shows that the index contained 3552 entries.</source>
          <target state="translated">这个例子显示,该索引包含3552个条目。</target>
        </trans-unit>
        <trans-unit id="af5672891a1be21669d22b688901415e2cf060c3" translate="yes" xml:space="preserve">
          <source>This expands to the object name of the delta base for the given object, if it is stored as a delta. Otherwise it expands to the null object name (all zeroes).</source>
          <target state="translated">如果给定的对象被存储为delta,则扩展为delta基的对象名。否则,它将展开为空的对象名(全部为零)。</target>
        </trans-unit>
        <trans-unit id="1a642986ccbacca12888668bff4ca6d3b1007b62" translate="yes" xml:space="preserve">
          <source>This explanation comes for &quot;free&quot; because there was no change. Similarly &lt;code&gt;C&lt;/code&gt; could be explained using &lt;code&gt;1&lt;/code&gt;, but that comes at some cost c&amp;gt;0 because of the modification:</source>
          <target state="translated">这种解释是&amp;ldquo;免费的&amp;rdquo;，因为没有变化。类似地，可以使用 &lt;code&gt;1&lt;/code&gt; 来解释 &lt;code&gt;C&lt;/code&gt; ，但是由于修改，这会付出一定的代价c&amp;gt; 0：</target>
        </trans-unit>
        <trans-unit id="86a0b58a904e042293eb0ea80455653f123e7d4e" translate="yes" xml:space="preserve">
          <source>This extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents.</source>
          <target state="translated">如果重命名或复制检测被激活,这种扩展格式可以很有用,让你看到不同父文件的原始名称。</target>
        </trans-unit>
        <trans-unit id="fc95481325c82bdecdaa23291b735168b05af418" translate="yes" xml:space="preserve">
          <source>This extension does not change git&amp;rsquo;s behavior at all. It is useful only for testing format-1 compatibility.</source>
          <target state="translated">这个扩展根本不会改变git的行为。仅对测试格式1兼容性有用。</target>
        </trans-unit>
        <trans-unit id="24a20ccff9f7f9f91cdf61fb876086b44fc5be61" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis by setting repository&amp;rsquo;s &lt;code&gt;gitweb.pickaxe&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过设置存储库的 &lt;code&gt;gitweb.pickaxe&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="3fcd9d965aa29d51e3ab01e56c522e086b7f545b" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.avatar&lt;/code&gt; configuration variable.</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.avatar&lt;/code&gt; 配置变量在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="da6908103a49ae5e820a33c13aadd5dfdd3e67a7" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.blame&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.blame&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="1d6d167abae14ab18966eab440f954ed6085f29c" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.grep&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.grep&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="dd4f802848cf6cbdc7682aeefb00472f2c444c9e" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.highlight&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.highlight&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="a8e82652b1c51e397e7f1e31621e9084d5611fda" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.patches&lt;/code&gt; configuration variable (integer).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.patches&lt;/code&gt; 配置变量（整数）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="a0528d6fc23cb2716835712f44b5daf955251062" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.remote_heads&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.remote_heads&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="58b983175f59d7aad97dac71b32251a2f4a8c4a0" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.showSizes&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.showSizes&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="ee33afe943a28f48529ed67cc410ad185ea09f23" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.snapshot&lt;/code&gt; configuration variable, which contains a comma separated list of formats or &quot;none&quot; to disable snapshots. Unknown values are ignored.</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.snapshot&lt;/code&gt; 配置变量在每个存储库的基础上配置此功能，该变量包含逗号分隔的格式列表或&amp;ldquo; none&amp;rdquo;以禁用快照。未知值将被忽略。</target>
        </trans-unit>
        <trans-unit id="c2467a6f49bad0810d0f5e1c4a51888ceb4f5b0f" translate="yes" xml:space="preserve">
          <source>This feature can be configured on per-repository basis after setting $feature{&lt;code&gt;extra-branch-refs&lt;/code&gt;}{&lt;code&gt;override&lt;/code&gt;} to true, via repository&amp;rsquo;s &lt;code&gt;gitweb.extraBranchRefs&lt;/code&gt; configuration variable, which contains a space separated list of refs. An example:</source>
          <target state="translated">通过将$ feature { &lt;code&gt;extra-branch-refs&lt;/code&gt; } { &lt;code&gt;override&lt;/code&gt; }设置为true后，可以通过存储库的 &lt;code&gt;gitweb.extraBranchRefs&lt;/code&gt; 配置变量在每个存储库的基础上配置此功能，该配置变量包含一个以空格分隔的refs列表。一个例子：</target>
        </trans-unit>
        <trans-unit id="83b4612ad81d70c9ed8920a4b451b69b8c3ee080" translate="yes" xml:space="preserve">
          <source>This feature is intended to speed up git operations for repos that have large working directories.</source>
          <target state="translated">这个功能的目的是为了加快有大型工作目录的仓库的git操作。</target>
        </trans-unit>
        <trans-unit id="6b24b487d6d9654020073f6754733ecc051175ad" translate="yes" xml:space="preserve">
          <source>This feature is semi-deprecated. For scripting purpose, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;&lt;code&gt;--porcelain&lt;/code&gt; and &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt;&lt;code&gt;--name-status&lt;/code&gt; are almost always superior alternatives, and users should look at &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;&lt;code&gt;--short&lt;/code&gt; or &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--name-status&lt;/code&gt; for more user-friendly alternatives.</source>
          <target state="translated">半不推荐使用此功能。出于脚本目的，&lt;a href=&quot;git-status&quot;&gt;git-status [1] &lt;/a&gt; &lt;code&gt;--porcelain&lt;/code&gt; 和&lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1] &lt;/a&gt; &lt;code&gt;--name-status&lt;/code&gt; 几乎总是更好的选择，用户应查看&lt;a href=&quot;git-status&quot;&gt;git-status [1] &lt;/a&gt; &lt;code&gt;--short&lt;/code&gt; 或&lt;a href=&quot;git-diff&quot;&gt;git- diff [1] &lt;/a&gt; &lt;code&gt;--name-status&lt;/code&gt; 提供更多用户友好的替代方案。</target>
        </trans-unit>
        <trans-unit id="0861edc399d3214fad2ecef2c8c7d8f9e28b4564" translate="yes" xml:space="preserve">
          <source>This feature is useful when an established project should be accepted despite early commits containing errors that can be safely ignored such as invalid committer email addresses. Note: corrupt objects cannot be skipped with this setting.</source>
          <target state="translated">这个功能对于已经建立的项目来说是很有用的,尽管早期的提交中包含了一些错误,比如提交人的电子邮件地址无效,但还是应该被接受。注意:这个设置不能跳过损坏的对象。</target>
        </trans-unit>
        <trans-unit id="5474f37d061902594342fbe38be401770ea2769f" translate="yes" xml:space="preserve">
          <source>This feature works by recording the mtime of the working tree directories and then omitting reading directories and stat calls against files in those directories whose mtime hasn&amp;rsquo;t changed. For this to work the underlying operating system and file system must change the &lt;code&gt;st_mtime&lt;/code&gt; field of directories if files in the directory are added, modified or deleted.</source>
          <target state="translated">此功能的工作方式是记录工作树目录的mtime，然后忽略mtime不变的那些目录中的文件的读取目录和stat调用。为此，如果在目录中添加，修改或删除了文件，则底层操作系统和文件系统必须更改目录的 &lt;code&gt;st_mtime&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="ef2541ade640bd800921de0e87cda6dd56d4d5f6" translate="yes" xml:space="preserve">
          <source>This fetches revisions from the SVN parent of the current HEAD and rebases the current (uncommitted to SVN) work against it.</source>
          <target state="translated">这将从当前 HEAD 的 SVN 父版本中获取修订版,并对当前(未提交到 SVN)的工作进行重定向。</target>
        </trans-unit>
        <trans-unit id="e6f84c5c8c6a08793025b9538660cbd1c1faa637" translate="yes" xml:space="preserve">
          <source>This file contains the commit message of a commit in progress. If &lt;code&gt;git commit&lt;/code&gt; exits due to an error before creating a commit, any commit message that has been provided by the user (e.g., in an editor session) will be available in this file, but will be overwritten by the next invocation of &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">该文件包含正在进行的提交的提交消息。如果 &lt;code&gt;git commit&lt;/code&gt; 由于在创建提交之前出错而退出，则用户提供的任何提交消息（例如，在编辑器会话中）都将在此文件中可用，但是下次 &lt;code&gt;git commit&lt;/code&gt; 调用将覆盖该消息。</target>
        </trans-unit>
        <trans-unit id="2063696fd909d95d720efff6859f2846f7a33789" translate="yes" xml:space="preserve">
          <source>This file helps dumb transports discover what refs are available in this repository. If the repository is published for dumb transports, this file should be regenerated by &lt;code&gt;git update-server-info&lt;/code&gt; every time a tag or branch is created or modified. This is normally done from the &lt;code&gt;hooks/update&lt;/code&gt; hook, which is run by the &lt;code&gt;git-receive-pack&lt;/code&gt; command when you &lt;code&gt;git push&lt;/code&gt; into the repository.</source>
          <target state="translated">此文件可帮助愚蠢的传输发现该存储库中可用的参考。如果发布该存储库是为了进行愚蠢的传输，则每次创建或修改标签或分支时， &lt;code&gt;git update-server-info&lt;/code&gt; 都应重新生成此文件。这通常是通过 &lt;code&gt;hooks/update&lt;/code&gt; 钩子完成的，当您将 &lt;code&gt;git push&lt;/code&gt; 到存储库时，钩子/更新钩子由 &lt;code&gt;git-receive-pack&lt;/code&gt; 命令运行。</target>
        </trans-unit>
        <trans-unit id="3487083c7b98c66e39acc8f940f40c0e9ceac88f" translate="yes" xml:space="preserve">
          <source>This file is to help dumb transports discover what packs are available in this object store. Whenever a pack is added or removed, &lt;code&gt;git update-server-info&lt;/code&gt; should be run to keep this file up to date if the repository is published for dumb transports. &lt;code&gt;git repack&lt;/code&gt; does this by default.</source>
          <target state="translated">此文件是为了帮助愚蠢的传输发现此对象存储中有哪些可用的包。每当添加或删除 &lt;code&gt;git update-server-info&lt;/code&gt; 时，如果已发布存储库以进行愚蠢的传输，则应运行git update-server-info以使该文件保持最新。 &lt;code&gt;git repack&lt;/code&gt; 默认情况下会这样做。</target>
        </trans-unit>
        <trans-unit id="cbe65e34529f44f10bf3c4bc531b3ef1a1689dfb" translate="yes" xml:space="preserve">
          <source>This file mainly serves as the mapping between the name and path of submodules in the superproject, such that the submodule&amp;rsquo;s Git directory can be located.</source>
          <target state="translated">该文件主要用作超级项目中子模块的名称和路径之间的映射，以便可以找到子模块的Git目录。</target>
        </trans-unit>
        <trans-unit id="071050e2544b6fc3703fb63508bbfdc9243b46ab" translate="yes" xml:space="preserve">
          <source>This file records URLs to alternate object stores that this object store borrows objects from, to be used when the repository is fetched over HTTP.</source>
          <target state="translated">这个文件记录了这个对象商店借用对象的备用对象商店的 URL,以便在通过 HTTP 获取存储库时使用。</target>
        </trans-unit>
        <trans-unit id="cc3397ff622f0d4d27f532099612807583041388" translate="yes" xml:space="preserve">
          <source>This file records fake commit ancestry information, to pretend the set of parents a commit has is different from how the commit was actually created. One record per line describes a commit and its fake parents by listing their 40-byte hexadecimal object names separated by a space and terminated by a newline.</source>
          <target state="translated">这个文件记录了假的提交祖先信息,以假装一个提交的父母集与该提交的实际创建方式不同。每行一条记录通过列出40字节的十六进制对象名来描述一个提交和它的假父母,并以空格分隔,以换行结束。</target>
        </trans-unit>
        <trans-unit id="1873ba1c652fc3e8dae8a41ecd45dff2c995baaf" translate="yes" xml:space="preserve">
          <source>This file records paths to alternate object stores that this object store borrows objects from, one pathname per line. Note that not only native Git tools use it locally, but the HTTP fetcher also tries to use it remotely; this will usually work if you have relative paths (relative to the object database, not to the repository!) in your alternates file, but it will not work if you use absolute paths unless the absolute path in filesystem and web URL is the same. See also &lt;code&gt;objects/info/http-alternates&lt;/code&gt;.</source>
          <target state="translated">该文件记录到该对象存储库借用对象的备用对象存储库的路径，每行一个路径名。请注意，不仅本地Git工具在本地使用它，而且HTTP fetcher也会尝试远程使用它。如果您的替代文件中有相对路径（相对于对象数据库，而不是存储库！），通常这将起作用，但如果您使用绝对路径，则除非文件系统和Web URL中的绝对路径相同，否则它将不起作用。另请参阅 &lt;code&gt;objects/info/http-alternates&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="517ab2689bb34239adf0b92ebb2a70e736956866" translate="yes" xml:space="preserve">
          <source>This file stores sparse checkout patterns. See also: &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt;.</source>
          <target state="translated">此文件存储稀疏签出模式。另请参阅：&lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39e8ca5394d81b30bccd145a749de9346fba2480" translate="yes" xml:space="preserve">
          <source>This file uses the following format:</source>
          <target state="translated">该文件使用以下格式:</target>
        </trans-unit>
        <trans-unit id="53c1d1d0fe83b95fe57b9ac9f6f59413589df721" translate="yes" xml:space="preserve">
          <source>This file, by convention among Porcelains, stores the exclude pattern list. &lt;code&gt;.gitignore&lt;/code&gt; is the per-directory ignore file. &lt;code&gt;git status&lt;/code&gt;, &lt;code&gt;git add&lt;/code&gt;, &lt;code&gt;git rm&lt;/code&gt; and &lt;code&gt;git clean&lt;/code&gt; look at it but the core Git commands do not look at it. See also: &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="translated">按照陶瓷惯例，此文件存储排除模式列表。 &lt;code&gt;.gitignore&lt;/code&gt; 是每个目录的忽略文件。 &lt;code&gt;git status&lt;/code&gt; ， &lt;code&gt;git add&lt;/code&gt; ， &lt;code&gt;git rm&lt;/code&gt; 和 &lt;code&gt;git clean&lt;/code&gt; 会看它，但是核心的Git命令不会看它。另请参阅：&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8956b9fdca3244ff8cd9467aefdc82ab275d878" translate="yes" xml:space="preserve">
          <source>This filter may be used if you only need to modify the environment in which the commit will be performed. Specifically, you might want to rewrite the author/committer name/email/time environment variables (see &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; for details).</source>
          <target state="translated">如果仅需要修改将在其中执行提交的环境，则可以使用此过滤器。具体来说，您可能想要重写作者/提交者名称/电子邮件/时间环境变量（有关详细信息，请参见&lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1f7d9b6979d573a6d61c7fc37aef6ce7f09ba079" translate="yes" xml:space="preserve">
          <source>This flag causes &lt;code&gt;git diff-tree --stdin&lt;/code&gt; to also show the commit message before the differences.</source>
          <target state="translated">这个标志使 &lt;code&gt;git diff-tree --stdin&lt;/code&gt; 也显示差异之前的提交消息。</target>
        </trans-unit>
        <trans-unit id="f18c1480999d4a64a19b051751a1dfdb3d01c394" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in a local pack that has a .keep file to be ignored, even if it would have otherwise been packed.</source>
          <target state="translated">这个标志会导致一个已经在本地包中有.keep文件的对象被忽略,即使它本来会被打包。</target>
        </trans-unit>
        <trans-unit id="3b2c5aa43d85ae95c70f7126e1a8d471a0247285" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in a pack to be ignored even if it would have otherwise been packed.</source>
          <target state="translated">这个标志会导致一个已经在包装中的对象被忽略,即使它本来会被包装。</target>
        </trans-unit>
        <trans-unit id="936ccdd465b71c76f59e3d7929f0e31e3a24c431" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in the given pack to be ignored, even if it would have otherwise been packed. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; is the pack file name without leading directory (e.g. &lt;code&gt;pack-123.pack&lt;/code&gt;). The option could be specified multiple times to keep multiple packs.</source>
          <target state="translated">即使已打包，此标志也会导致已忽略给定包中的对象。 &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; 是没有前导目录的包文件名（例如 &lt;code&gt;pack-123.pack&lt;/code&gt; ）。可以多次指定该选项以保留多个包装。</target>
        </trans-unit>
        <trans-unit id="9fad47cb9db9729fbeb177e82626a6322dbefd6c" translate="yes" xml:space="preserve">
          <source>This flag causes an object that is borrowed from an alternate object store to be ignored even if it would have otherwise been packed.</source>
          <target state="translated">这个标志会导致从备用对象存储中借用的对象被忽略,即使它本来会被打包。</target>
        </trans-unit>
        <trans-unit id="97fddffea713eaa9774ecf695b0619f959916c25" translate="yes" xml:space="preserve">
          <source>This flag causes combined diffs (used for merge commits) to list the name of the file from all parents. It thus only has effect when -c or --cc are specified, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested).</source>
          <target state="translated">这个标志会使合并后的差异文件(用于合并提交)列出所有父文件的名称。因此,它只有在指定了 -c 或 --cc 时才会生效,而且只有在检测到文件名变化时才会有用(例如,当要求检测重命名或复制时)。</target>
        </trans-unit>
        <trans-unit id="7d04699c745135d6f14712a3d65005478838c3a7" translate="yes" xml:space="preserve">
          <source>This flag changes the way a merge commit is displayed (which means it is useful only when the command is given one &amp;lt;tree-ish&amp;gt;, or &lt;code&gt;--stdin&lt;/code&gt;). It shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time (which is what the &lt;code&gt;-m&lt;/code&gt; option does). Furthermore, it lists only files which were modified from all parents.</source>
          <target state="translated">该标志改变了合并提交的显示方式（这意味着仅在命令被赋予一个&amp;lt;tree-ish&amp;gt;或 &lt;code&gt;--stdin&lt;/code&gt; 时才有用）。它同时显示了每个父项与合并结果之间的差异，而不是一次显示父项与结果之间的成对差异（这是 &lt;code&gt;-m&lt;/code&gt; 选项的作用）。此外，它仅列出从所有父级修改而来的文件。</target>
        </trans-unit>
        <trans-unit id="0d503f20848f4e1ff6c5e78038f4bce28f3422a3" translate="yes" xml:space="preserve">
          <source>This flag changes the way a merge commit patch is displayed, in a similar way to the &lt;code&gt;-c&lt;/code&gt; option. It implies the &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-p&lt;/code&gt; options and further compresses the patch output by omitting uninteresting hunks whose the contents in the parents have only two variants and the merge result picks one of them without modification. When all hunks are uninteresting, the commit itself and the commit log message is not shown, just like in any other &quot;empty diff&quot; case.</source>
          <target state="translated">该标志以与 &lt;code&gt;-c&lt;/code&gt; 选项类似的方式更改合并提交补丁的显示方式。它暗示了 &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;-p&lt;/code&gt; 选项，并通过省略不感兴趣的块（它们在父级中的内容只有两个变体，合并结果选择了其中一个而没有修改）来进一步压缩补丁输出。当所有的块都不感兴趣时​​，就不会显示提交本身和提交日志消息，就像其他&amp;ldquo;空差异&amp;rdquo;情况一样。</target>
        </trans-unit>
        <trans-unit id="4835250d6cbee97633146544cd1896afcc631099" translate="yes" xml:space="preserve">
          <source>This flag disables these checks, and can cause the remote repository to lose commits; use it with care.</source>
          <target state="translated">这个标志会禁用这些检查,并可能导致远程仓库丢失提交,请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="cc5f19786a1b0eda7705eaaa80c372612ab5d782" translate="yes" xml:space="preserve">
          <source>This flag implies the &lt;code&gt;-c&lt;/code&gt; option and further compresses the patch output by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification.</source>
          <target state="translated">该标志表示 &lt;code&gt;-c&lt;/code&gt; 选项，并通过省略不感兴趣的块（它们在父对象中的内容只有两个变体）并且合并结果选择其中一个而没有修改的粗体来进一步压缩补丁输出。</target>
        </trans-unit>
        <trans-unit id="6c9f2e241df42ed566896490c4c1723461343597" translate="yes" xml:space="preserve">
          <source>This flag is passed to the &lt;code&gt;git log&lt;/code&gt; program (see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;) that generates the patches.</source>
          <target state="translated">该标志被传递到生成补丁的 &lt;code&gt;git log&lt;/code&gt; 程序（请参阅&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7d74132f018d1e29c74648fc0cf6690a80cd700b" translate="yes" xml:space="preserve">
          <source>This flag makes the command not to report its progress on the standard error stream.</source>
          <target state="translated">该标志使命令不在标准错误流上报告其进度。</target>
        </trans-unit>
        <trans-unit id="c7300f914a6246e85c4558f9e03e3ac6bd2957c2" translate="yes" xml:space="preserve">
          <source>This flag makes the merge commits show the full diff like regular commits; for each merge parent, a separate log entry and diff is generated. An exception is that only diff against the first parent is shown when &lt;code&gt;--first-parent&lt;/code&gt; option is given; in that case, the output represents the changes the merge brought &lt;code&gt;into&lt;/code&gt; the then-current branch.</source>
          <target state="translated">该标志使合并提交像常规提交一样显示完整的差异；对于每个合并父级，将生成一个单独的日志条目和差异。一个例外是，给定 &lt;code&gt;--first-parent&lt;/code&gt; 选项时，仅显示与第一个父对象的差异；在这种情况下，输出表示变化带来合并 &lt;code&gt;into&lt;/code&gt; 当时的分支。</target>
        </trans-unit>
        <trans-unit id="824f1a5cbd322eac2edc9b61691e0afb5fb06c7c" translate="yes" xml:space="preserve">
          <source>This flag tells the command not to reuse existing object data at all, including non deltified object, forcing recompression of everything. This implies --no-reuse-delta. Useful only in the obscure case where wholesale enforcement of a different compression level on the packed data is desired.</source>
          <target state="translated">这个标志告诉命令完全不重用现有的对象数据,包括非强化对象,强制重新压缩所有的数据。这意味着--no-reuse-delta。只有在需要对打包的数据全盘执行不同压缩级别的情况下才有用。</target>
        </trans-unit>
        <trans-unit id="e554d11fed47fbadc588fbbd426a692640350799" translate="yes" xml:space="preserve">
          <source>This form can only be used in the middle of a &lt;code&gt;commit&lt;/code&gt;. The path names a directory entry within fast-import&amp;rsquo;s active commit. The path must be quoted in this case.</source>
          <target state="translated">这种形式只能在 &lt;code&gt;commit&lt;/code&gt; 。该路径为快速导入的活动提交中的目录条目命名。在这种情况下，必须引用路径。</target>
        </trans-unit>
        <trans-unit id="55cd46dfe4dc47146eb359f16ba2ab6440f5d33b" translate="yes" xml:space="preserve">
          <source>This form is to compare the given two paths on the filesystem. You can omit the &lt;code&gt;--no-index&lt;/code&gt; option when running the command in a working tree controlled by Git and at least one of the paths points outside the working tree, or when running the command outside a working tree controlled by Git. This form implies &lt;code&gt;--exit-code&lt;/code&gt;.</source>
          <target state="translated">这种形式是比较文件系统上给定的两个路径。在由Git控制的工作树中运行命令时，可以忽略 &lt;code&gt;--no-index&lt;/code&gt; 选项，并且至少有一个路径指向该工作树之外，或者在由Git控制的工作树外部运行命令时，也可以省略该选项。这种形式意味着 &lt;code&gt;--exit-code&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a36c2e6e9bf305ffd5ef7a7e4c453ac93dfb865" translate="yes" xml:space="preserve">
          <source>This form is to view the changes on the branch containing and up to the second &amp;lt;commit&amp;gt;, starting at a common ancestor of both &amp;lt;commit&amp;gt;. &quot;git diff A...B&quot; is equivalent to &quot;git diff $(git merge-base A B) B&quot;. You can omit any one of &amp;lt;commit&amp;gt;, which has the same effect as using HEAD instead.</source>
          <target state="translated">此表单用于查看包含且直到第二个&amp;lt;commit&amp;gt;的分支上的更改，该更改始于两个&amp;lt;commit&amp;gt;的共同祖先。&amp;ldquo; git diff A ... B&amp;rdquo;等效于&amp;ldquo; git diff $（git merge-base AB）B&amp;rdquo;。您可以省略&amp;lt;commit&amp;gt;中的任何一个，其效果与使用HEAD相同。</target>
        </trans-unit>
        <trans-unit id="18011d68a19f669179582c8652eaff17f583329f" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you have in your working tree relative to the named &amp;lt;commit&amp;gt;. You can use HEAD to compare it with the latest commit, or a branch name to compare with the tip of a different branch.</source>
          <target state="translated">此表单用于查看您在工作树中相对于名为&amp;lt;commit&amp;gt;的更改。您可以使用HEAD将其与最新提交进行比较，或使用分支名称与其他分支的尖端进行比较。</target>
        </trans-unit>
        <trans-unit id="0c3233dc5774a7d1fc399a8b304cc732bba72d9f" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you made relative to the index (staging area for the next commit). In other words, the differences are what you &lt;code&gt;could&lt;/code&gt; tell Git to further add to the index but you still haven&amp;rsquo;t. You can stage these changes by using &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;.</source>
          <target state="translated">该表单用于查看您相对于索引（下一次提交的暂存区域）所做的更改。换句话说，您 &lt;code&gt;could&lt;/code&gt; 告诉Git进一步将差异添加到索引中，但您仍然没有。您可以使用&lt;a href=&quot;git-add&quot;&gt;git-add [1]进行&lt;/a&gt;这些更改。</target>
        </trans-unit>
        <trans-unit id="ee8e76f95895702db36db495b0e53027904973c9" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you staged for the next commit relative to the named &amp;lt;commit&amp;gt;. Typically you would want comparison with the latest commit, so if you do not give &amp;lt;commit&amp;gt;, it defaults to HEAD. If HEAD does not exist (e.g. unborn branches) and &amp;lt;commit&amp;gt; is not given, it shows all staged changes. --staged is a synonym of --cached.</source>
          <target state="translated">此表单用于查看相对于命名的&amp;lt;commit&amp;gt;为下一次提交所做的更改。通常，您希望与最新提交进行比较，因此，如果您不提供&amp;lt;commit&amp;gt;，则默认为HEAD。如果HEAD不存在（例如，未出生的分支）并且未给出&amp;lt;commit&amp;gt;，则它将显示所有已分阶段的更改。--staged是--cached的同义词。</target>
        </trans-unit>
        <trans-unit id="51dda6a69f38e64f972e32a62549822542d75887" translate="yes" xml:space="preserve">
          <source>This form is to view the differences between the raw contents of two blob objects.</source>
          <target state="translated">这种形式是为了查看两个blob对象的原始内容之间的差异。</target>
        </trans-unit>
        <trans-unit id="395d78419362cad7438eb6eae46785d35953f019" translate="yes" xml:space="preserve">
          <source>This form resets the current branch head to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; and possibly updates the index (resetting it to the tree of &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;) and the working tree depending on &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is omitted, defaults to &lt;code&gt;--mixed&lt;/code&gt;. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; must be one of the following:</source>
          <target state="translated">该表格将当前分支头重置为 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; ,并可能更新索引（将其重置为 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 的树）和取决于 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 的工作树。如果省略 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; ，则默认为 &lt;code&gt;--mixed&lt;/code&gt; 。所述 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 必须是下列之一：</target>
        </trans-unit>
        <trans-unit id="90bcd35d4969f3a90ba2bd18f27a5c6eb93f333b" translate="yes" xml:space="preserve">
          <source>This form will use the first line matching the given POSIX regex. If &amp;lt;start&amp;gt; is a regex, it will search from the end of the previous &lt;code&gt;-L&lt;/code&gt; range, if any, otherwise from the start of file. If &amp;lt;start&amp;gt; is &amp;ldquo;^/regex/&amp;rdquo;, it will search from the start of file. If &amp;lt;end&amp;gt; is a regex, it will search starting at the line given by &amp;lt;start&amp;gt;.</source>
          <target state="translated">此表单将使用与给定POSIX正则表达式匹配的第一行。如果&amp;lt;start&amp;gt;是正则表达式，它将从前一个 &lt;code&gt;-L&lt;/code&gt; 范围的末尾（如果有）搜索，否则从文件的开头搜索。如果&amp;lt;start&amp;gt;是&amp;ldquo; ^ / regex /&amp;rdquo;，它将从文件的开头搜索。如果&amp;lt;end&amp;gt;是正则表达式，它将从&amp;lt;start&amp;gt;给出的行开始搜索。</target>
        </trans-unit>
        <trans-unit id="b42c261dd1828c15332725a480fa7095bcc76b2a" translate="yes" xml:space="preserve">
          <source>This format expects the first line of the file to contain the &quot;Cc:&quot; value and the &quot;Subject:&quot; of the message as the second line.</source>
          <target state="translated">这种格式希望文件的第一行包含 &quot;Cc:&quot;值,第二行包含邮件的 &quot;Subject:&quot;。</target>
        </trans-unit>
        <trans-unit id="105520fc7842a24e43537a27759a074335828eb6" translate="yes" xml:space="preserve">
          <source>This format is identical to version &lt;code&gt;0&lt;/code&gt;, with the following exceptions:</source>
          <target state="translated">此格式与版本 &lt;code&gt;0&lt;/code&gt; 相同，但以下情况除外：</target>
        </trans-unit>
        <trans-unit id="fd22347e6ce1cebbfe9140a8d5df54f1132eb3e9" translate="yes" xml:space="preserve">
          <source>This format is no longer produced by any Git command, but is and will continue to be supported by &lt;code&gt;update-index --index-info&lt;/code&gt;.</source>
          <target state="translated">此格式不再由任何Git命令生成，但是 &lt;code&gt;update-index --index-info&lt;/code&gt; 将继续支持。</target>
        </trans-unit>
        <trans-unit id="e1e42b99834dd201113f33eae88b5856f686096e" translate="yes" xml:space="preserve">
          <source>This format is to put higher order stages into the index file and matches &lt;code&gt;git ls-files --stage&lt;/code&gt; output.</source>
          <target state="translated">此格式用于将高阶阶段放入索引文件中，并匹配 &lt;code&gt;git ls-files --stage&lt;/code&gt; 输出。</target>
        </trans-unit>
        <trans-unit id="483caba3e82677e09e2d521ebba75089a90ce09e" translate="yes" xml:space="preserve">
          <source>This format is to stuff &lt;code&gt;git ls-tree&lt;/code&gt; output into the index.</source>
          <target state="translated">这种格式是将 &lt;code&gt;git ls-tree&lt;/code&gt; 输出填充到索引中。</target>
        </trans-unit>
        <trans-unit id="078ec0cba6df63b2f2fc0bbcd069e250ea13b628" translate="yes" xml:space="preserve">
          <source>This format is used to refer to another commit in a commit message and is the same as &lt;code&gt;--pretty='format:%C(auto)%h (%s, %ad)'&lt;/code&gt;. By default, the date is formatted with &lt;code&gt;--date=short&lt;/code&gt; unless another &lt;code&gt;--date&lt;/code&gt; option is explicitly specified. As with any &lt;code&gt;format:&lt;/code&gt; with format placeholders, its output is not affected by other options like &lt;code&gt;--decorate&lt;/code&gt; and &lt;code&gt;--walk-reflogs&lt;/code&gt;.</source>
          <target state="translated">此格式用于引用提交消息中的另一个提交，并且与 &lt;code&gt;--pretty='format:%C(auto)%h (%s, %ad)'&lt;/code&gt; 。默认情况下，日期格式为 &lt;code&gt;--date=short&lt;/code&gt; ,除非明确指定了另一个 &lt;code&gt;--date&lt;/code&gt; 选项。与任何 &lt;code&gt;format:&lt;/code&gt; 使用格式占位符，其输出不受 &lt;code&gt;--decorate&lt;/code&gt; 和 &lt;code&gt;--walk-reflogs&lt;/code&gt; 之类的其他选项的影响。</target>
        </trans-unit>
        <trans-unit id="742c78626a467f269e89b016f43c5e1a7be4cd88" translate="yes" xml:space="preserve">
          <source>This gets rid of the &lt;code&gt;git-svn-id:&lt;/code&gt; lines at the end of every commit.</source>
          <target state="translated">这就消除了 &lt;code&gt;git-svn-id:&lt;/code&gt; 每次提交结束时的行。</target>
        </trans-unit>
        <trans-unit id="2acaf36aea784a80df7509fcb8e38355c645c5a7" translate="yes" xml:space="preserve">
          <source>This gives a very controlled flow of fixes. If you notice that you have applied a fix to e.g. &lt;code&gt;master&lt;/code&gt; that is also required in &lt;code&gt;maint&lt;/code&gt;, you will need to cherry-pick it (using &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;) downwards. This will happen a few times and is nothing to worry about unless you do it very frequently.</source>
          <target state="translated">这样可以很好地控制修补程序的流程。如果发现已应用修复到例如 &lt;code&gt;master&lt;/code&gt; ，其也需要在 &lt;code&gt;maint&lt;/code&gt; ，则需要樱桃挑它（使用&lt;a href=&quot;git-cherry-pick&quot;&gt;GIT-樱桃挑[1] &lt;/a&gt;）向下。这将发生几次，除非您经常进行，否则无需担心。</target>
        </trans-unit>
        <trans-unit id="1f3884c08aac0f5d8941c7814b274c9743619a33" translate="yes" xml:space="preserve">
          <source>This happens if the &lt;code&gt;subsystem&lt;/code&gt; rebase had conflicts, or used &lt;code&gt;--interactive&lt;/code&gt; to omit, edit, squash, or fixup commits; or if the upstream used one of &lt;code&gt;commit --amend&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, or a full history rewriting command like &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;&lt;code&gt;filter-repo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;subsystem&lt;/code&gt; 发生了冲突，或者使用 &lt;code&gt;--interactive&lt;/code&gt; 来省略，编辑，压榨或修复提交，则会发生这种情况。或者上游是否使用 &lt;code&gt;commit --amend&lt;/code&gt; ， &lt;code&gt;reset&lt;/code&gt; 或完整的历史记录重写命令（如&lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt; &lt;code&gt;filter-repo&lt;/code&gt; )之一&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53ac63807fcdbfc7e050fb3151d6b086f2e9a274" translate="yes" xml:space="preserve">
          <source>This happens if the &lt;code&gt;subsystem&lt;/code&gt; rebase was a simple rebase and had no conflicts.</source>
          <target state="translated">如果 &lt;code&gt;subsystem&lt;/code&gt; 是简单的基础并且没有冲突，则会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="d414984e9f8d7bfd782c8f2da36b80bcd80ea28e" translate="yes" xml:space="preserve">
          <source>This has a few user-visible effects and caveats:</source>
          <target state="translated">这有一些用户可见的效果和注意事项。</target>
        </trans-unit>
        <trans-unit id="1c876a37c9c7633e47e1a6a38b1f16f75e32a3ed" translate="yes" xml:space="preserve">
          <source>This has a very similar UI to &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;revert&lt;/code&gt;, and lets you add untracked paths to the index.</source>
          <target state="translated">它具有非常相似的UI来 &lt;code&gt;update&lt;/code&gt; 和 &lt;code&gt;revert&lt;/code&gt; ，并允许您将未跟踪的路径添加到索引。</target>
        </trans-unit>
        <trans-unit id="33280cb105ee3b71902ce7b15c9592fd52f73e30" translate="yes" xml:space="preserve">
          <source>This has a very similar UI to &lt;code&gt;update&lt;/code&gt;, and the staged information for selected paths are reverted to that of the HEAD version. Reverting new paths makes them untracked.</source>
          <target state="translated">这具有非常相似的UI来 &lt;code&gt;update&lt;/code&gt; ，并且选定路径的暂存信息将还原为HEAD版本的信息。还原新路径使它们无法跟踪。</target>
        </trans-unit>
        <trans-unit id="4d4512b846dcedcc9cf4704e69eaeda15e1830db" translate="yes" xml:space="preserve">
          <source>This has been requested by some kernel developers because some bugs called sporadic bugs do not appear in all the kernel builds because they are very dependent on the compiler output.</source>
          <target state="translated">这是一些内核开发者要求的,因为一些被称为零星bug的bug并没有出现在所有的内核构建中,因为它们非常依赖于编译器的输出。</target>
        </trans-unit>
        <trans-unit id="b93781d2b5ee24d7b760545bc5177eb80e4c3e22" translate="yes" xml:space="preserve">
          <source>This has the advantage that it will be saved in your &lt;code&gt;CVS/Root&lt;/code&gt; files and you don&amp;rsquo;t need to worry about always setting the correct environment variable. SSH users restricted to &lt;code&gt;git-shell&lt;/code&gt; don&amp;rsquo;t need to override the default with CVS_SERVER (and shouldn&amp;rsquo;t) as &lt;code&gt;git-shell&lt;/code&gt; understands &lt;code&gt;cvs&lt;/code&gt; to mean &lt;code&gt;git-cvsserver&lt;/code&gt; and pretends that the other end runs the real &lt;code&gt;cvs&lt;/code&gt; better.</source>
          <target state="translated">这样的好处是它将被保存在您的 &lt;code&gt;CVS/Root&lt;/code&gt; 文件中，您不必担心总是设置正确的环境变量。受限于 &lt;code&gt;git-shell&lt;/code&gt; 的 SSH用户无需使用CVS_SERVER覆盖默认值（也不应该），因为 &lt;code&gt;git-shell&lt;/code&gt; 理解 &lt;code&gt;cvs&lt;/code&gt; 意味着 &lt;code&gt;git-cvsserver&lt;/code&gt; 并假装另一端可以更好地运行真实的 &lt;code&gt;cvs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f27a3b2d1e595dbb21c1b28424b4a89305bcf439" translate="yes" xml:space="preserve">
          <source>This has two implications:</source>
          <target state="translated">这有两个含义。</target>
        </trans-unit>
        <trans-unit id="a2d38b5ae6dea81df64d435d13a5c9c9c6e43a8c" translate="yes" xml:space="preserve">
          <source>This header line is followed by the following information at least once for each commit:</source>
          <target state="translated">这个头行后面是以下信息,每次提交至少一次。</target>
        </trans-unit>
        <trans-unit id="aac19de1c954c0a5c2aba42bf1f288afbf74cabf" translate="yes" xml:space="preserve">
          <source>This helper uses specified file descriptors to connect to a remote Git server. This is not meant for end users but for programs and scripts calling git fetch, push or archive.</source>
          <target state="translated">这个帮助程序使用指定的文件描述符来连接到远程 Git 服务器。这不是为终端用户准备的,而是为调用 git fetch、push 或 archive 的程序和脚本准备的。</target>
        </trans-unit>
        <trans-unit id="eafdc2cefff4153e88df550a24ce4b00606582ea" translate="yes" xml:space="preserve">
          <source>This hook can be used in conjunction with a corresponding pre-commit hook to save and restore any form of metadata associated with the working tree (e.g.: permissions/ownership, ACLS, etc). See contrib/hooks/setgitperms.perl for an example of how to do this.</source>
          <target state="translated">这个钩子可以和相应的预提交钩子一起使用,以保存和恢复与工作树相关的任何形式的元数据(例如:权限/所有权,ACLS等)。参见 contrib/hooks/setgitperms.perl 来了解如何做到这一点。</target>
        </trans-unit>
        <trans-unit id="9fae8c19d5ced3830760d386f8db3473a746ea76" translate="yes" xml:space="preserve">
          <source>This hook can be used to perform repository validity checks, auto-display differences from the previous HEAD if different, or set working dir metadata properties.</source>
          <target state="translated">这个钩子可以用来执行版本库有效性检查,如果与之前的HEAD不同,则自动显示差异,或者设置工作dir元数据属性。</target>
        </trans-unit>
        <trans-unit id="89a247d66f7dd9fd927ac160899ee7ad4eefe257" translate="yes" xml:space="preserve">
          <source>This hook can be used to prevent &lt;code&gt;forced&lt;/code&gt; update on certain refs by making sure that the object name is a commit object that is a descendant of the commit object named by the old object name. That is, to enforce a &quot;fast-forward only&quot; policy.</source>
          <target state="translated">通过确保对象名称是作为旧对象名称命名的提交对象的后代的提交对象，可以使用该挂钩来防止对某些引用进行 &lt;code&gt;forced&lt;/code&gt; 更新。也就是说，强制执行&amp;ldquo;仅快进&amp;rdquo;策略。</target>
        </trans-unit>
        <trans-unit id="e2b4b08b5c7d529703ac2e4609fae5478174d015" translate="yes" xml:space="preserve">
          <source>This hook can be used, for example, to run &lt;code&gt;git update-server-info&lt;/code&gt; if the repository is packed and is served via a dumb transport.</source>
          <target state="translated">如果存储库已打包并通过愚蠢的传输服务，则可以使用此钩子来运行 &lt;code&gt;git update-server-info&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec8359ca4fe68868d4a094d214fa5c736b07b686" translate="yes" xml:space="preserve">
          <source>This hook does not affect the outcome of &lt;code&gt;git receive-pack&lt;/code&gt;, as it is called after the real work is done.</source>
          <target state="translated">这个钩子不会影响 &lt;code&gt;git receive-pack&lt;/code&gt; 的结果，因为它在实际工作完成后会被调用。</target>
        </trans-unit>
        <trans-unit id="4f1494681f56d1e644fae421a13f75381d1bf104" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but for each ref to be updated it receives on standard input a line of the format:</source>
          <target state="translated">这个钩子对receive操作执行一次。它不接受任何参数,但每更新一个 ref,它就会在标准输入中接收一行格式的内容。</target>
        </trans-unit>
        <trans-unit id="1c705c0b531046d9558421e4543f9aca35624390" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but gets the same information as the &lt;a href=&quot;#pre-receive&quot;&gt;&lt;em&gt;pre-receive&lt;/em&gt;&lt;/a&gt; hook does on its standard input.</source>
          <target state="translated">该挂钩执行一次以进行接收操作。它不带参数，但获得的信息与&lt;a href=&quot;#pre-receive&quot;&gt;&lt;em&gt;pre-receive&lt;/em&gt;&lt;/a&gt;钩子在其标准输入上得到的信息相同。</target>
        </trans-unit>
        <trans-unit id="8f404b0d7afced029532dd1c0ce00c69033fa119" translate="yes" xml:space="preserve">
          <source>This hook is called before any refname is updated and before any fast-forward checks are performed.</source>
          <target state="translated">这个钩子在任何refname被更新和任何快进检查被执行之前被调用。</target>
        </trans-unit>
        <trans-unit id="6f4d4e6bc9f3d3e90e8224d9cc9d15607a5f159d" translate="yes" xml:space="preserve">
          <source>This hook is called by &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and can be used to prevent a push from taking place. The hook is called with two parameters which provide the name and location of the destination remote, if a named remote is not being used both values will be the same.</source>
          <target state="translated">这个钩子被&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;调用，可以用来防止进行推送。该挂钩由两个参数调用，这些参数提供目标远程服务器的名称和位置，如果未使用命名远程服务器，则两个值将相同。</target>
        </trans-unit>
        <trans-unit id="b761c5f63f99b7c22c6e4ca4e1bd741b6a19c509" translate="yes" xml:space="preserve">
          <source>This hook is called by &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; and can be used to prevent a branch from getting rebased. The hook may be called with one or two parameters. The first parameter is the upstream from which the series was forked. The second parameter is the branch being rebased, and is not set when rebasing the current branch.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;调用，可用于防止分支重新建立基础。可以使用一个或两个参数来调用该挂钩。第一个参数是从其派生系列的上游。第二个参数是要重新建立基础的分支，在重新建立当前分支的基础时未设置。</target>
        </trans-unit>
        <trans-unit id="fc84f5afc2cc3712fb061152c42b83b5432e2d28" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes a single parameter, the name of the file that holds the proposed commit log message. Exiting with a non-zero status causes &lt;code&gt;git am&lt;/code&gt; to abort before applying the patch.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;调用。它只有一个参数，即保存建议的提交日志消息的文件的名称。以非零状态退出会导致 &lt;code&gt;git am&lt;/code&gt; 在应用补丁之前中止。</target>
        </trans-unit>
        <trans-unit id="109f1251e93ab76b92d28a05e1f40ca3ae3e2435" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes no parameter, and is invoked after the patch is applied and a commit is made.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;调用。它不带参数，在应用补丁并进行提交之后被调用。</target>
        </trans-unit>
        <trans-unit id="31dd1042d3a6d88015bf6a789db56141bf61f664" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes no parameter, and is invoked after the patch is applied, but before a commit is made.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;调用。它不带参数，在应用补丁程序之后但在提交之前被调用。</target>
        </trans-unit>
        <trans-unit id="4126a7ec7eb0a54d9b99d1f389fd70ce96c40950" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes a single parameter, the name of the file that holds the proposed commit log message. Exiting with a non-zero status causes the command to abort.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;和&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;调用，可以使用 &lt;code&gt;--no-verify&lt;/code&gt; 选项绕过。它只有一个参数，即保存建议的提交日志消息的文件的名称。以非零状态退出会导致命令中止。</target>
        </trans-unit>
        <trans-unit id="977ece26ae3c0446a7497462b09e90162737d6ca" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; right after preparing the default log message, and before the editor is started.</source>
          <target state="translated">&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;在准备默认日志消息之后并且在启动编辑器之前立即调用此钩子。</target>
        </trans-unit>
        <trans-unit id="2ae25bad855fc10ca5e955357c713cdbb31a472c" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes no parameters, and is invoked before obtaining the proposed commit log message and making a commit. Exiting with a non-zero status from this script causes the &lt;code&gt;git commit&lt;/code&gt; command to abort before creating a commit.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;调用，可以使用 &lt;code&gt;--no-verify&lt;/code&gt; 选项绕过。它不带任何参数，并且在获取建议的提交日志消息并进行提交之前被调用。从此脚本以非零状态退出会导致 &lt;code&gt;git commit&lt;/code&gt; 命令在创建提交之前中止。</target>
        </trans-unit>
        <trans-unit id="21226463d529e8f7d5082c27401d959f905ec4d1" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;. It takes no parameters, and is invoked after a commit is made.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;调用。它不带任何参数，并在提交后被调用。</target>
        </trans-unit>
        <trans-unit id="0a4097349c79cead9de93e647cb9ba47cbed7c91" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes no parameters, and is invoked after the merge has been carried out successfully and before obtaining the proposed commit log message to make a commit. Exiting with a non-zero status from this script causes the &lt;code&gt;git merge&lt;/code&gt; command to abort before creating a commit.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;调用，可以使用 &lt;code&gt;--no-verify&lt;/code&gt; 选项绕过。它不带任何参数，并且在成功执行合并之后并在获取建议的提交日志消息以进行提交之前被调用。从此脚本以非零状态退出会导致 &lt;code&gt;git merge&lt;/code&gt; 命令在创建提交之前中止。</target>
        </trans-unit>
        <trans-unit id="de911dadfd0a4abc2b13baa4ccbc2ae0aca9f055" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, which happens when a &lt;code&gt;git pull&lt;/code&gt; is done on a local repository. The hook takes a single parameter, a status flag specifying whether or not the merge being done was a squash merge. This hook cannot affect the outcome of &lt;code&gt;git merge&lt;/code&gt; and is not executed, if the merge failed due to conflicts.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;调用，这是在本地存储库上执行 &lt;code&gt;git pull&lt;/code&gt; 时发生的。挂钩使用一个参数，一个状态标志，指定要进行的合并是否为壁球合并。如果合并由于冲突而失败，则此钩子不会影响 &lt;code&gt;git merge&lt;/code&gt; 的结果，因此不会执行。</target>
        </trans-unit>
        <trans-unit id="76961cafe28e294daa6f1b287a02eb4fe4bf07aa" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository, and when the push tries to update the branch that is currently checked out and the &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; configuration variable is set to &lt;code&gt;updateInstead&lt;/code&gt;. Such a push by default is refused if the working tree and the index of the remote repository has any difference from the currently checked out commit; when both the working tree and the index match the current commit, they are updated to match the newly pushed tip of the branch. This hook is to be used to override the default behaviour.</source>
          <target state="translated">当&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;对 &lt;code&gt;git push&lt;/code&gt; 作出反应并更新其存储库中的引用时，以及当push尝试更新当前已检出的分支和 &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; 配置变量时，将由git-receive-pack [1]调用此钩子。设置为 &lt;code&gt;updateInstead&lt;/code&gt; 。如果工作树和远程存储库的索引与当前检出的提交有任何区别，则默认情况下将拒绝此类推送；当工作树和索引都与当前提交匹配时，它们将被更新以与分支的新推送尖端匹配。该钩子将用于覆盖默认行为。</target>
        </trans-unit>
        <trans-unit id="5a56dac625f1205849f2b5f6e3619a708d3ea48e" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. It executes on the remote repository once after all the refs have been updated.</source>
          <target state="translated">当它对 &lt;code&gt;git push&lt;/code&gt; 做出反应并更新其存储库中的引用时，该钩子由&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;调用。所有引用均已更新后，它将在远程存储库上执行。</target>
        </trans-unit>
        <trans-unit id="390ce0821ef413eec43c389641cce2dfc9687135" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. Just before starting to update refs on the remote repository, the pre-receive hook is invoked. Its exit status determines the success or failure of the update.</source>
          <target state="translated">当它对 &lt;code&gt;git push&lt;/code&gt; 做出反应并更新其存储库中的引用时，该钩子由&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;调用。在开始更新远程存储库上的引用之前，将调用pre-receive挂钩。其退出状态确定更新的成功或失败。</target>
        </trans-unit>
        <trans-unit id="f508c67d780c6e440d114ab5a4809e8db15887c6" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. Just before updating the ref on the remote repository, the update hook is invoked. Its exit status determines the success or failure of the ref update.</source>
          <target state="translated">当它对 &lt;code&gt;git push&lt;/code&gt; 做出反应并更新其存储库中的引用时，该钩子由&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;调用。在更新远程存储库上的ref之前，将调用更新挂钩。其退出状态确定引用更新的成功或失败。</target>
        </trans-unit>
        <trans-unit id="c94fc31562e49c2e1f57905c2984b3787d6eb579" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;. It takes a single parameter, the name of the file that holds the e-mail to be sent. Exiting with a non-zero status causes &lt;code&gt;git send-email&lt;/code&gt; to abort before sending any e-mails.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt;调用。它只有一个参数，即保存要发送电子邮件的文件的名称。以非零状态退出会导致 &lt;code&gt;git send-email&lt;/code&gt; 在发送任何电子邮件之前中止。</target>
        </trans-unit>
        <trans-unit id="898dc345a1faef7e78cc6f07a48d416762cf9e72" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git gc --auto&lt;/code&gt; (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;). It takes no parameter, and exiting with non-zero status from this script causes the &lt;code&gt;git gc --auto&lt;/code&gt; to abort.</source>
          <target state="translated">该钩子由 &lt;code&gt;git gc --auto&lt;/code&gt; 调用（请参阅&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;）。它不带任何参数，并且以非零状态退出此脚本会导致 &lt;code&gt;git gc --auto&lt;/code&gt; 中止。</target>
        </trans-unit>
        <trans-unit id="fa504b80ab7d4ab7fd02bb1c09f7267f7ffd0b87" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt;. It takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevent &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. Run &lt;code&gt;git-p4 submit --help&lt;/code&gt; for details.</source>
          <target state="translated">这个钩子由 &lt;code&gt;git-p4 submit&lt;/code&gt; 调用。它不带参数，标准输入也不带任何内容。从此脚本以非零状态退出会阻止 &lt;code&gt;git-p4 submit&lt;/code&gt; 启动。运行 &lt;code&gt;git-p4 submit --help&lt;/code&gt; 以获得详细信息。</target>
        </trans-unit>
        <trans-unit id="e8569f58a670ba9d05dfd0c2191295df64e04e73" translate="yes" xml:space="preserve">
          <source>This hook is invoked by commands that rewrite commits (&lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; when called with &lt;code&gt;--amend&lt;/code&gt; and &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;; however, full-history (re)writing tools like &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import[1]&lt;/a&gt; or &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; typically do not call it!). Its first argument denotes the command it was invoked by: currently one of &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;. Further command-dependent arguments may be passed in the future.</source>
          <target state="translated">该钩子由重写提交的命令调用（&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;用 &lt;code&gt;--amend&lt;/code&gt; 和&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;调用时；但是，完整的历史（重新）编写工具，例如&lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import [1]&lt;/a&gt;或&lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt;通常不调用它！）。它的第一个参数表示由其调用的命令：当前为 &lt;code&gt;amend&lt;/code&gt; 或 &lt;code&gt;rebase&lt;/code&gt; 之一。将来可能会传递更多与命令有关的参数。</target>
        </trans-unit>
        <trans-unit id="7b20b75526e2af7ef8179932e884a838f68429b3" translate="yes" xml:space="preserve">
          <source>This hook is invoked when a &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; or &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; is run after having updated the worktree. The hook is given three parameters: the ref of the previous HEAD, the ref of the new HEAD (which may or may not have changed), and a flag indicating whether the checkout was a branch checkout (changing branches, flag=1) or a file checkout (retrieving a file from the index, flag=0). This hook cannot affect the outcome of &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt;.</source>
          <target state="translated">更新工作树后运行&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;或&lt;a href=&quot;git-switch&quot;&gt;git-switch [1]&lt;/a&gt;时，将调用此挂钩。挂钩具有三个参数：前一个HEAD的ref，新HEAD的ref（可能已更改，也可能未更改）和一个标志，指示签出是否为分支签出（更改分支，flag = 1）或文件检出（从索引中检索文件，标志= 0）。这个钩子不会影响 &lt;code&gt;git switch&lt;/code&gt; 或 &lt;code&gt;git checkout&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="7b0692c459d4a723afc690b678a8556c7e5d3814" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the configuration option &lt;code&gt;core.fsmonitor&lt;/code&gt; is set to &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt;. It takes two arguments, a version (currently 1) and the time in elapsed nanoseconds since midnight, January 1, 1970.</source>
          <target state="translated">当配置选项 &lt;code&gt;core.fsmonitor&lt;/code&gt; 设置为 &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt; watchman时，将调用此挂钩。它需要两个参数，一个版本（当前为1），以及自1970年1月1日午夜以来经过的时间（以纳秒为单位）。</target>
        </trans-unit>
        <trans-unit id="1ea8190ee0fad5a3aca31c578a724c322c0d57cb" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the index is written in read-cache.c do_write_locked_index.</source>
          <target state="translated">这个钩子在read-cache.c do_write_locked_index中写入索引时被调用。</target>
        </trans-unit>
        <trans-unit id="bbcd7cc3d137fc9e83cb037a7ffe28a3a104cf5b" translate="yes" xml:space="preserve">
          <source>This hook is invoked with the environment variable &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; if the command will not bring up an editor to modify the commit message.</source>
          <target state="translated">如果该命令不会调出编辑器来修改提交消息，则使用环境变量 &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; 调用此挂钩。</target>
        </trans-unit>
        <trans-unit id="ddc7ece9286909c0de44abe41d5a762b67552ed5" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">这个钩子主要用于通知，不会影响 &lt;code&gt;git am&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="448e187d53f17c70cda00f92a3ee55c4bde07472" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">这个钩子主要用于通知，不会影响 &lt;code&gt;git commit&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="08260832c28c95684a1993d7203db5c6a733006a" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git receive-pack&lt;/code&gt;.</source>
          <target state="translated">这个钩子主要用于通知，并且不会影响 &lt;code&gt;git receive-pack&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="f1b9eafafbdf014b8c082347223fc7e3e439cd3c" translate="yes" xml:space="preserve">
          <source>This implies &lt;code&gt;--revs&lt;/code&gt;. In addition to the list of revision arguments read from the standard input, pretend as if all refs under &lt;code&gt;refs/&lt;/code&gt; are specified to be included.</source>
          <target state="translated">这意味着 &lt;code&gt;--revs&lt;/code&gt; 。除了从标准输入中读取的修订参数列表之外，还假装好像已指定 &lt;code&gt;refs/&lt;/code&gt; 下的所有ref 。</target>
        </trans-unit>
        <trans-unit id="00f6fe101136dac1c604175fe5bf787266d15317" translate="yes" xml:space="preserve">
          <source>This implies &lt;code&gt;--revs&lt;/code&gt;. When processing the list of revision arguments read from the standard input, limit the objects packed to those that are not already packed.</source>
          <target state="translated">这意味着 &lt;code&gt;--revs&lt;/code&gt; 。处理从标准输入中读取的修订参数列表时，请将打包的对象限制为尚未打包的对象。</target>
        </trans-unit>
        <trans-unit id="23abf25dbec44cc1a257bc71a457bb760d4a79eb" translate="yes" xml:space="preserve">
          <source>This implies the &lt;code&gt;--topo-order&lt;/code&gt; option by default, but the &lt;code&gt;--date-order&lt;/code&gt; option may also be specified.</source>
          <target state="translated">这意味着默认情况下 &lt;code&gt;--topo-order&lt;/code&gt; 选项，但也可以指定 &lt;code&gt;--date-order&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="9bafb6d097d43ca4ccca730edb887425acfba8b5" translate="yes" xml:space="preserve">
          <source>This imports the specified depot into &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; in an existing Git repository. The &lt;code&gt;--branch&lt;/code&gt; option can be used to specify a different branch to be used for the p4 content.</source>
          <target state="translated">这会将指定的软件仓库导入到现有Git存储库中的 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; 中。该 &lt;code&gt;--branch&lt;/code&gt; 选项可用于指定不同的分支，以用于P4内容。</target>
        </trans-unit>
        <trans-unit id="505428074ae07b004fad59f4eaeb272274ac2c6b" translate="yes" xml:space="preserve">
          <source>This information can be used to determine what commit was the tip of a branch &quot;2 days ago&quot;.</source>
          <target state="translated">这些信息可以用来确定 &quot;2天前 &quot;的分支是什么提交。</target>
        </trans-unit>
        <trans-unit id="86187244d1368864bf6af8ccb054656e32b6a58b" translate="yes" xml:space="preserve">
          <source>This instructs git svn to recode pathnames to a given encoding. It can be used by windows users and by those who work in non-utf8 locales to avoid corrupted file names with non-ASCII characters. Valid encodings are the ones supported by Perl&amp;rsquo;s Encode module.</source>
          <target state="translated">这指示git svn将路径名重新编码为给定的编码。Windows用户和在非utf8语言环境中工作的人员都可以使用它，以避免使用非ASCII字符损坏文件名。有效的编码是Perl的Encode模块支持的编码。</target>
        </trans-unit>
        <trans-unit id="0909b4167b1b6cfc93db8cafdc74248d3901c792" translate="yes" xml:space="preserve">
          <source>This is a deprecated synonym for &lt;code&gt;repack.writeBitmaps&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; 的不赞成使用的同义词。</target>
        </trans-unit>
        <trans-unit id="0663f3ff3f5e643bb58ee19e6a44fd14680c40d5" translate="yes" xml:space="preserve">
          <source>This is a login shell for SSH accounts to provide restricted Git access. It permits execution only of server-side Git commands implementing the pull/push functionality, plus custom commands present in a subdirectory named &lt;code&gt;git-shell-commands&lt;/code&gt; in the user&amp;rsquo;s home directory.</source>
          <target state="translated">这是SSH帐户的登录外壳，用于提供受限制的Git访问。它仅允许执行实现拉/推功能的服务器端Git命令，以及用户主目录中名为 &lt;code&gt;git-shell-commands&lt;/code&gt; 的子目录中存在的自定义命令。</target>
        </trans-unit>
        <trans-unit id="bb9b1700493e02e1c42808252a2a81a90b07f06f" translate="yes" xml:space="preserve">
          <source>This is a modified recursive strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree.</source>
          <target state="translated">这是一种修改后的递归策略。在合并树A和B时,如果B对应A的子树,则首先调整B,使之与A的树结构相匹配,而不是读取同一层次的树。这种调整也是对共同祖先树进行的。</target>
        </trans-unit>
        <trans-unit id="94478372a5a22fcace1286299ca604a903c0373f" translate="yes" xml:space="preserve">
          <source>This is a multi-valued variable, and an empty value can be used in a higher priority configuration file (e.g. &lt;code&gt;.git/config&lt;/code&gt; in a repository) to clear the values inherited from a lower priority configuration files (e.g. &lt;code&gt;$HOME/.gitconfig&lt;/code&gt;).</source>
          <target state="translated">这是一个多值变量，可以在较高优先级的配置文件（例如，存储库中的 &lt;code&gt;.git/config&lt;/code&gt; )中使用空值，以清除从较低优先级的配置文件（例如 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; ）继承的值。。</target>
        </trans-unit>
        <trans-unit id="9800795b0feafe785919ba7eb03d901a5af98b6d" translate="yes" xml:space="preserve">
          <source>This is a potentially &lt;em&gt;dangerous&lt;/em&gt; mode of operation. It rewrites history, which does not bode well when you published that history already. Do &lt;strong&gt;not&lt;/strong&gt; use this option unless you have read &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; carefully.</source>
          <target state="translated">这是潜在的&lt;em&gt;危险&lt;/em&gt;操作模式。它会重写历史记录，当您已经发布该历史记录时，这并不是一个好兆头。难道&lt;strong&gt;不&lt;/strong&gt;除非您已经阅读使用此选项&lt;a href=&quot;git-rebase&quot;&gt;的git-底垫[1]&lt;/a&gt;小心。</target>
        </trans-unit>
        <trans-unit id="7393bcbfeab09d874001a82423e807bb091915e9" translate="yes" xml:space="preserve">
          <source>This is a quick summary of the major commands; the previous chapters explain how these work in more detail.</source>
          <target state="translated">这是对主要命令的快速总结;前面的章节将更详细地解释这些命令如何工作。</target>
        </trans-unit>
        <trans-unit id="e6b70a1472f7c00669a56c92197ed227d5be5866" translate="yes" xml:space="preserve">
          <source>This is a shorthand for &quot;--pretty=oneline --abbrev-commit&quot; used together.</source>
          <target state="translated">这是&quot;-pretty=oneline--abbrev-commit &quot;一起使用的速记。</target>
        </trans-unit>
        <trans-unit id="18c84bcba1b16c1ac1cf14d08c1c68d27e4599a1" translate="yes" xml:space="preserve">
          <source>This is a total waste of time and effort on a filesystem that orders data writes properly, but can be useful for filesystems that do not use journalling (traditional UNIX filesystems) or that only journal metadata and not file contents (OS X&amp;rsquo;s HFS+, or Linux ext3 with &quot;data=writeback&quot;).</source>
          <target state="translated">订购正确写入数据的文件系统会浪费时间和精力，但对于不使用日志记录的文件系统（传统的UNIX文件系统）或仅记录日志元数据而不是文件内容的文件系统（OS X的HFS +或Linux）很有用ext3和&amp;ldquo; data = writeback&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="554ab63db8a74b017dac093a21d0557d821484db" translate="yes" xml:space="preserve">
          <source>This is a toy format. The current time and time zone of this system is always copied into the identity string at the time it is being created by fast-import. There is no way to specify a different time or time zone.</source>
          <target state="translated">这是一个玩具格式。在fast-import创建系统时,这个系统的当前时间和时区总是被复制到身份字符串中。没有办法指定不同的时间或时区。</target>
        </trans-unit>
        <trans-unit id="bc30d84517d5f02b55a3811eba6ffba9e6c0e4f0" translate="yes" xml:space="preserve">
          <source>This is a work in progress.</source>
          <target state="translated">这是一项正在进行中的工作。</target>
        </trans-unit>
        <trans-unit id="3e77feb91313add3d7aff3491329020f7cd2b88e" translate="yes" xml:space="preserve">
          <source>This is an easy way to check out a particular version without having to make up a name for the new branch. You can still create a new branch (or tag) for this version later if you decide to.</source>
          <target state="translated">这是个简单的方法,可以在不为新分支取名的情况下检查出一个特定的版本。如果您决定为这个版本创建一个新的分支(或标签),您仍然可以在以后为其创建一个新的分支。</target>
        </trans-unit>
        <trans-unit id="86d03a90949a936d437c536daea902a3352ca567" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;rebase&lt;/code&gt; is used in a workflow that treats the history at the remote as the shared canonical one, and treats the work done on the branch you are rebasing as the third-party work to be integrated, and you are temporarily assuming the role of the keeper of the canonical history during the rebase. As the keeper of the canonical history, you need to view the history from the remote as &lt;code&gt;ours&lt;/code&gt; (i.e. &quot;our shared canonical history&quot;), while what you did on your side branch as &lt;code&gt;theirs&lt;/code&gt; (i.e. &quot;one contributor&amp;rsquo;s work on top of it&quot;).</source>
          <target state="translated">这是因为在工作流中使用了 &lt;code&gt;rebase&lt;/code&gt; ，该工作流将远程站点上的历史记录视为共享规范，并将您要重新部署的分支上完成的工作视为要集成的第三方工作，并且您暂时担当了该角色改组期间的规范历史保持者。作为规范历史的保存者，您需要从远程查看与 &lt;code&gt;ours&lt;/code&gt; 一样的历史（即&amp;ldquo;我们共享的规范历史&amp;rdquo;），而您在分支机构所做的工作就是作为 &lt;code&gt;theirs&lt;/code&gt; （即&amp;ldquo;一个贡献者的工作&amp;rdquo;）。 ）。</target>
        </trans-unit>
        <trans-unit id="95a20fc02bc3cd4094f682df1ea1f755e327d688" translate="yes" xml:space="preserve">
          <source>This is called a &lt;code&gt;hunk header&lt;/code&gt;. The &quot;TEXT&quot; portion is by default a line that begins with an alphabet, an underscore or a dollar sign; this matches what GNU &lt;code&gt;diff -p&lt;/code&gt; output uses. This default selection however is not suited for some contents, and you can use a customized pattern to make a selection.</source>
          <target state="translated">这称为 &lt;code&gt;hunk header&lt;/code&gt; 。默认情况下，&amp;ldquo; TEXT&amp;rdquo;部分是以字母，下划线或美元符号开头的行；这与GNU &lt;code&gt;diff -p&lt;/code&gt; 输出使用的匹配。但是，此默认选择不适用于某些内容，您可以使用自定义模式进行选择。</target>
        </trans-unit>
        <trans-unit id="85de32d717921314245903361d4033db93188253" translate="yes" xml:space="preserve">
          <source>This is default name of common system-wide configuration file.</source>
          <target state="translated">这是全系统通用配置文件的默认名称。</target>
        </trans-unit>
        <trans-unit id="8fabc38be889239efec56b25dba57afb3b308b5b" translate="yes" xml:space="preserve">
          <source>This is default name of fallback system-wide configuration file. This file is used only if per-instance configuration variable is not found.</source>
          <target state="translated">这是回退系统范围内配置文件的默认名称。只有在没有找到每个实例的配置变量时,才会使用该文件。</target>
        </trans-unit>
        <trans-unit id="e13cac7eff842df90d7031a70a4150ab3a8cdbc2" translate="yes" xml:space="preserve">
          <source>This is default name of per-instance configuration file. The format of this file is described above.</source>
          <target state="translated">这是每个实例配置文件的默认名称。该文件的格式如上所述。</target>
        </trans-unit>
        <trans-unit id="2ac99b50de3702f5d543e44c6b1ddc55b08d7471" translate="yes" xml:space="preserve">
          <source>This is designed to be as compact as possible.</source>
          <target state="translated">这样设计是为了尽可能的紧凑。</target>
        </trans-unit>
        <trans-unit id="d4d30dfd1772dd73a7b51cd065bd14037d1044bf" translate="yes" xml:space="preserve">
          <source>This is done to prevent you from losing your work-in-progress changes, and mixing your random changes in an unrelated merge commit. To illustrate, suppose you start from what has been committed last to your repository:</source>
          <target state="translated">这样做的目的是为了防止丢失正在进行中的修改,以及将随机的修改混入不相关的合并提交中。为了说明这一点,假设你从最后提交到版本库的内容开始。</target>
        </trans-unit>
        <trans-unit id="c5483036881ec5a0c568843866e403149495194d" translate="yes" xml:space="preserve">
          <source>This is how you read a blob (actually, not only a blob, but any type of object). To know how the function &lt;code&gt;read_object_with_reference()&lt;/code&gt; actually works, find the source code for it (something like &lt;code&gt;git grep
read_object_with | grep &quot;:[a-z]&quot;&lt;/code&gt; in the Git repository), and read the source.</source>
          <target state="translated">这就是读取blob（实际上，不仅是blob，而且是任何类型的对象）的方式。要了解 &lt;code&gt;read_object_with_reference()&lt;/code&gt; 函数的实际工作方式，请找到该函数的源代码（类似于 &lt;code&gt;git grep read_object_with | grep &quot;:[a-z]&quot;&lt;/code&gt; 在Git存储库中），然后阅读源代码。</target>
        </trans-unit>
        <trans-unit id="d94f65e687e225292db2cabccebd8f5b3adaa1d5" translate="yes" xml:space="preserve">
          <source>This is ideally suited for read-only updates, i.e., pulling from Git repositories.</source>
          <target state="translated">这非常适合于只读更新,即从Git仓库中拉取。</target>
        </trans-unit>
        <trans-unit id="4f74abb17322f51c4e08c52446429282a69cbb4c" translate="yes" xml:space="preserve">
          <source>This is intended to be used by the test suite only. It allows to force the version for the generated pack index, and to force 64-bit index entries on objects located above the given offset.</source>
          <target state="translated">这仅用于测试套件。它允许强制生成包索引的版本,并强制位于给定偏移量以上的对象的64位索引条目。</target>
        </trans-unit>
        <trans-unit id="8180429180a5d33dfa16e7d2805d2ac9f53f061d" translate="yes" xml:space="preserve">
          <source>This is just to get you into the groove for the most libified part of Git: the revision walker.</source>
          <target state="translated">这只是为了让你进入Git最解放的部分:修订行者。</target>
        </trans-unit>
        <trans-unit id="dce30f3fbb0be29025f159d55505215087cce86b" translate="yes" xml:space="preserve">
          <source>This is known to &lt;code&gt;range-diff&lt;/code&gt; as &quot;dual coloring&quot;. Use &lt;code&gt;--no-dual-color&lt;/code&gt; to revert to color all lines according to the outer diff markers (and completely ignore the inner diff when it comes to color).</source>
          <target state="translated">这是已知的 &lt;code&gt;range-diff&lt;/code&gt; &amp;ldquo;双重着色&amp;rdquo;。使用 &lt;code&gt;--no-dual-color&lt;/code&gt; 可以根据外部差异标记对所有行进行着色（在涉及颜色时完全忽略内部差异）。</target>
        </trans-unit>
        <trans-unit id="51ecbd5eaeeeee461a4969f3b0cb27dc975ebc23" translate="yes" xml:space="preserve">
          <source>This is made much worse if many files have to be fixed to resolve conflicts. That&amp;rsquo;s why such merges are called &quot;evil merges&quot;. They can make regressions very difficult to track down. It can even be misleading to know the first bad commit if it happens to be such a merge, because people might think that the bug comes from bad conflict resolution when it comes from a semantic change in one branch.</source>
          <target state="translated">如果必须修复许多文件以解决冲突，则情况将更加糟糕。这就是为什么这种合并称为&amp;ldquo;邪恶合并&amp;rdquo;的原因。它们可能使回归非常难以追踪。如果碰巧是这样的合并，那么知道第一个错误的提交甚至可能会产生误导，因为人们可能会认为该错误来自错误的冲突解决，而该错​​误来自一个分支中的语义更改。</target>
        </trans-unit>
        <trans-unit id="2742189647afc1dbda2e1e2ecc6c9303cbb2d70b" translate="yes" xml:space="preserve">
          <source>This is meant to be used by higher level scripts to compute merge results outside of the index, and stuff the results back into the index. For this reason, the output from the command omits entries that match the &amp;lt;branch1&amp;gt; tree.</source>
          <target state="translated">这意味着更高级别的脚本将使用它来计算索引之外的合并结果，并将结果填充回索引中。因此，命令的输出将省略与&amp;lt;branch1&amp;gt;树匹配的条目。</target>
        </trans-unit>
        <trans-unit id="9ccf843e585a34e60ae505f61685a10813c9c88a" translate="yes" xml:space="preserve">
          <source>This is most often done when you remembered what you just committed is incomplete, or you misspelled your commit message, or both. Leaves working tree as it was before &quot;reset&quot;.</source>
          <target state="translated">最常见的情况是,当你想起刚刚提交的内容不完整,或者你拼错了提交信息,或者两者都有。让工作树保持 &quot;重置 &quot;前的状态。</target>
        </trans-unit>
        <trans-unit id="efff48b2c5bed4c5ab6435b6d058280a53664967" translate="yes" xml:space="preserve">
          <source>This is not a command the end user would want to run. Ever. This documentation is meant for people who are studying the Porcelain-ish scripts and/or are writing new ones.</source>
          <target state="translated">这不是一个终端用户想要运行的命令。永远不会。这篇文档是为那些正在研究瓷器类脚本和/或正在编写新脚本的人准备的。</target>
        </trans-unit>
        <trans-unit id="4c9e09ba77ce1340a426d6ae669add42a4fe4542" translate="yes" xml:space="preserve">
          <source>This is not a real filter executed for each commit but a one time setup just before the loop. Therefore no commit-specific variables are defined yet. Functions or variables defined here can be used or modified in the following filter steps except the commit filter, for technical reasons.</source>
          <target state="translated">这不是为每次提交执行的真正的过滤器,而是在循环之前的一次性设置。因此,目前还没有定义针对提交的变量。由于技术原因,这里定义的函数或变量可以在下面的过滤步骤中使用或修改,但提交过滤除外。</target>
        </trans-unit>
        <trans-unit id="ad1d1c10cd51125ef48d021d8c7283be0413a66d" translate="yes" xml:space="preserve">
          <source>This is not hard to understand, as soon as you realize that Git simply never knows (or cares) about files that it is not told about explicitly. Git will never go &lt;strong&gt;looking&lt;/strong&gt; for files to compare, it expects you to tell it what the files are, and that&amp;rsquo;s what the index is there for.</source>
          <target state="translated">这一点并不难理解，只要您意识到Git根本就不知道（或关心）没有明确告知它的文件。Git永远不会&lt;strong&gt;寻找&lt;/strong&gt;要比较的文件，它希望您告诉它文件是什么，这就是索引的用途。</target>
        </trans-unit>
        <trans-unit id="0273358cae89a5a683cca4bca340f2d1ab3cc600" translate="yes" xml:space="preserve">
          <source>This is only used by git-completion.bash to add or remove commands from the list of completed commands. Normally only porcelain commands and a few select others are completed. You can add more commands, separated by space, in this variable. Prefixing the command with &lt;code&gt;-&lt;/code&gt; will remove it from the existing list.</source>
          <target state="translated">git-completion.bash仅使用它从已完成的命令列表中添加或删除命令。通常，仅完成瓷器命令和一些其他命令。您可以在此变量中添加更多命令，以空格分隔。在命令前面加上 &lt;code&gt;-&lt;/code&gt; 会将其从现有列表中删除。</target>
        </trans-unit>
        <trans-unit id="fcaf558e1ca35a6c93dcb363081455cef6ced8a0" translate="yes" xml:space="preserve">
          <source>This is only valid for &amp;lt;end&amp;gt; and will specify a number of lines before or after the line given by &amp;lt;start&amp;gt;.</source>
          <target state="translated">这仅对&amp;lt;end&amp;gt;有效，并将在&amp;lt;start&amp;gt;给定的行之前或之后指定多行。</target>
        </trans-unit>
        <trans-unit id="1b0501180252ff128dca83458515deca695a7ecc" translate="yes" xml:space="preserve">
          <source>This is optional and is only searched when &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; is present in $GIT_DIR/config.</source>
          <target state="translated">这是可选的，仅当$ GIT_DIR / config中存在 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 时才搜索。</target>
        </trans-unit>
        <trans-unit id="4306207006bf4fdd2134f4efea5f0d698d2c1f81" translate="yes" xml:space="preserve">
          <source>This is particularly true when passing in diff options. Currently some options like &lt;code&gt;--stat&lt;/code&gt; can, as an emergent effect, produce output that&amp;rsquo;s quite useless in the context of &lt;code&gt;range-diff&lt;/code&gt;. Future versions of &lt;code&gt;range-diff&lt;/code&gt; may learn to interpret such options in a manner specific to &lt;code&gt;range-diff&lt;/code&gt; (e.g. for &lt;code&gt;--stat&lt;/code&gt; producing human-readable output which summarizes how the diffstat changed).</source>
          <target state="translated">当传递diff选项时尤其如此。目前，诸如 &lt;code&gt;--stat&lt;/code&gt; 之类的一些选项作为一种紧急效果可以产生在 &lt;code&gt;range-diff&lt;/code&gt; 上下文中非常无用的输出。未来版本的 &lt;code&gt;range-diff&lt;/code&gt; 可能会学习以特定于 &lt;code&gt;range-diff&lt;/code&gt; 的方式来解释此类选项（例如，用于 &lt;code&gt;--stat&lt;/code&gt; 产生人类可读的输出，其中总结了diffstat的变化）。</target>
        </trans-unit>
        <trans-unit id="c2dfec9fbb580524d9c87ce7e3303a7b47cc295d" translate="yes" xml:space="preserve">
          <source>This is passed to both underlying git-fetch to squelch reporting of during transfer, and underlying git-merge to squelch output during merging.</source>
          <target state="translated">这将被传递给底层的 git-fetch 来压制传输过程中的报告,以及底层的 git-merge 来压制合并过程中的输出。</target>
        </trans-unit>
        <trans-unit id="3d17e8f742373c8bbf1871e58142a3d3c4b1c09b" translate="yes" xml:space="preserve">
          <source>This is per-repository enhancement / version of global prefix-based &lt;code&gt;@git_base_url_list&lt;/code&gt; gitweb configuration variable (see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;).</source>
          <target state="translated">这是基于存储库的增强功能/基于全局前缀的 &lt;code&gt;@git_base_url_list&lt;/code&gt; gitweb配置变量的版本（请参见&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a7bcc6783fe2c533eb40b84879a83d32f4d95dc9" translate="yes" xml:space="preserve">
          <source>This is similar to --symbolic, but it omits input that are not refs (i.e. branch or tag names; or more explicitly disambiguating &quot;heads/master&quot; form, when you want to name the &quot;master&quot; branch when there is an unfortunately named tag &quot;master&quot;), and show them as full refnames (e.g. &quot;refs/heads/master&quot;).</source>
          <target state="translated">这与 --symbolic 类似,但它省略了不是 refs 的输入(即分支或标记名称;或者更明确地以 &quot;head/master &quot;的形式,当你想命名 &quot;master &quot;分支时,不幸的是有一个命名为 &quot;master &quot;的标记),并将它们显示为完整的 refs 名称(例如 &quot;refs/heads/master&quot;)。</target>
        </trans-unit>
        <trans-unit id="4cae7dda407705febf1be1d8f0d77956238a429a" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;info/grafts&lt;/code&gt; but is internally used and maintained by shallow clone mechanism. See &lt;code&gt;--depth&lt;/code&gt; option to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; and &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;. This file is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/shallow&quot; will be used instead.</source>
          <target state="translated">这类似于 &lt;code&gt;info/grafts&lt;/code&gt; 但在内部由浅克隆机制使用和维护。参见&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;和&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]的&lt;/a&gt; &lt;code&gt;--depth&lt;/code&gt; 选项。如果设置了$ GIT_COMMON_DIR，该文件将被忽略，而将使用&amp;ldquo; $ GIT_COMMON_DIR / shallow&amp;rdquo;代替。</target>
        </trans-unit>
        <trans-unit id="44c5e44a5b0e8e88feba4a9ab4b3411e28cf0521" translate="yes" xml:space="preserve">
          <source>This is similar to the previous mode, but lets you use the interactive interface to show the &quot;diff&quot; output and choose which hunks to use in the result. See below for the description of &lt;code&gt;--patch&lt;/code&gt; option.</source>
          <target state="translated">这与以前的模式相似，但是允许您使用交互式界面显示&amp;ldquo; diff&amp;rdquo;输出并选择要在结果中使用的块。有关 &lt;code&gt;--patch&lt;/code&gt; 选项的说明，请参见下文。</target>
        </trans-unit>
        <trans-unit id="4054020991b3f63ee43241d99b871a192e5f7888" translate="yes" xml:space="preserve">
          <source>This is synonymous to the previous form. If &amp;lt;commit&amp;gt; on one side is omitted, it will have the same effect as using HEAD instead.</source>
          <target state="translated">这与以前的形式同义。如果省略了一侧的&amp;lt;commit&amp;gt;，它将具有与使用HEAD相同的效果。</target>
        </trans-unit>
        <trans-unit id="75478eb48b06b2098532610f52369c54c5a35766" translate="yes" xml:space="preserve">
          <source>This is the Git native format and is &lt;code&gt;&amp;lt;time&amp;gt; SP &amp;lt;offutc&amp;gt;&lt;/code&gt;. It is also fast-import&amp;rsquo;s default format, if --date-format was not specified.</source>
          <target state="translated">这是Git本机格式，并且是 &lt;code&gt;&amp;lt;time&amp;gt; SP &amp;lt;offutc&amp;gt;&lt;/code&gt; 。如果未指定--date-format，它也是快速导入的默认格式。</target>
        </trans-unit>
        <trans-unit id="6bd79ba5c8340a61cc49527317aae865e2230698" translate="yes" xml:space="preserve">
          <source>This is the filter for performing the commit. If this filter is specified, it will be called instead of the &lt;code&gt;git commit-tree&lt;/code&gt; command, with arguments of the form &quot;&amp;lt;TREE_ID&amp;gt; [(-p &amp;lt;PARENT_COMMIT_ID&amp;gt;)&amp;hellip;​]&quot; and the log message on stdin. The commit id is expected on stdout.</source>
          <target state="translated">这是用于执行提交的过滤器。如果指定了该过滤器，它将被调用，而不是 &lt;code&gt;git commit-tree&lt;/code&gt; 命令，与以下形式的参数&amp;ldquo;&amp;lt;TREE_ID&amp;gt; [（-p &amp;lt;PARENT_COMMIT_ID&amp;gt;）...]&amp;rdquo;和在stdin日志消息。提交ID应该在标准输出上。</target>
        </trans-unit>
        <trans-unit id="ab02ed108f018595c9832dcfce47c6a593278667" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting tag names. When passed, it will be called for every tag ref that points to a rewritten object (or to a tag object which points to a rewritten object). The original tag name is passed via standard input, and the new tag name is expected on standard output.</source>
          <target state="translated">这是重写标签名的过滤器。通过后,它将对指向重写对象(或指向重写对象的标签对象)的每个标签 ref 进行调用。原始的标签名通过标准输入传递,而新的标签名则在标准输出中被期待。</target>
        </trans-unit>
        <trans-unit id="ec46b5cef98509f43f653471ea24de2e709b0b36" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the commit messages. The argument is evaluated in the shell with the original commit message on standard input; its standard output is used as the new commit message.</source>
          <target state="translated">这是用于重写提交信息的过滤器,参数在shell中用标准输入的原始提交信息进行评估,其标准输出作为新的提交信息。参数在shell中以标准输入的原始提交信息进行评估,其标准输出作为新的提交信息。</target>
        </trans-unit>
        <trans-unit id="baaf77805fbcb910ae11f451b39d9e38daaa6669" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the commit&amp;rsquo;s parent list. It will receive the parent string on stdin and shall output the new parent string on stdout. The parent string is in the format described in &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt;: empty for the initial commit, &quot;-p parent&quot; for a normal commit and &quot;-p parent1 -p parent2 -p parent3 &amp;hellip;​&quot; for a merge commit.</source>
          <target state="translated">这是用于重写提交的父列表的过滤器。它将在stdin上接收父字符串，并在stdout上输出新的父字符串。父字符串采用&lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]中&lt;/a&gt;描述的格式：初始提交为空，普通提交为&amp;ldquo; -p父&amp;rdquo;，合并为&amp;ldquo; -p父1 -p父2 -p父3&amp;hellip;&amp;rdquo;。承诺。</target>
        </trans-unit>
        <trans-unit id="ed6796eee1e84719fc79503aec05a2585b0a98ee" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the index. It is similar to the tree filter but does not check out the tree, which makes it much faster. Frequently used with &lt;code&gt;git rm --cached
--ignore-unmatch ...&lt;/code&gt;, see EXAMPLES below. For hairy cases, see &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">这是用于重写索引的过滤器。它类似于树过滤器，但不检出树，这使它更快。经常与 &lt;code&gt;git rm --cached --ignore-unmatch ...&lt;/code&gt; ，请参见下面的示例。对于多毛的情况，请参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84464b13412e29584cb64fc663c003212ddd470c" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the tree and its contents. The argument is evaluated in shell with the working directory set to the root of the checked out tree. The new tree is then used as-is (new files are auto-added, disappeared files are auto-removed - neither .gitignore files nor any other ignore rules &lt;strong&gt;HAVE ANY EFFECT&lt;/strong&gt;!).</source>
          <target state="translated">这是用于重写树及其内容的过滤器。该参数在shell中评估，且工作目录设置为检出树的根。然后新树被原样使用（新文件是自动添加的，消失的文件是自动删除-既不的.gitignore文件，也没有任何其他无视规则&lt;strong&gt;有任何影响&lt;/strong&gt;！）。</target>
        </trans-unit>
        <trans-unit id="ac6e8f6a01875184858c8585102e8f6aa273aee7" translate="yes" xml:space="preserve">
          <source>This is the format defined by the initial version of git, including but not limited to the format of the repository directory, the repository configuration file, and the object and ref storage. Specifying the complete behavior of git is beyond the scope of this document.</source>
          <target state="translated">这是git初始版本所定义的格式,包括但不限于版本库目录、版本库配置文件、对象和ref存储的格式。指定git的完整行为超出了本文档的范围。</target>
        </trans-unit>
        <trans-unit id="53064adeec7c86c12f0de7129be2018180dbdde8" translate="yes" xml:space="preserve">
          <source>This is the instruction format to copy a byte range from the source object. It encodes the offset to copy from and the number of bytes to copy. Offset and size are in little-endian order.</source>
          <target state="translated">这是从源对象中复制一个字节范围的指令格式。它对要复制的偏移量和要复制的字节数进行编码。偏移量和大小按小字节顺序排列。</target>
        </trans-unit>
        <trans-unit id="7c56810b4cb2a212f096564a869dc50ed111eb3c" translate="yes" xml:space="preserve">
          <source>This is the instruction reserved for future expansion.</source>
          <target state="translated">这是为将来的扩展而保留的指令。</target>
        </trans-unit>
        <trans-unit id="2ac15a186ae4c1add6605d649b034295db99bef1" translate="yes" xml:space="preserve">
          <source>This is the instruction to construct target object without the base object. The following data is appended to the target object. The first seven bits of the first octet determines the size of data in bytes. The size must be non-zero.</source>
          <target state="translated">这是在没有基础对象的情况下构造目标对象的指令。在目标对象中附加以下数据。第一个八位组的前七位决定数据的大小,单位是字节。大小必须为非零。</target>
        </trans-unit>
        <trans-unit id="109ca8035c1b87bb820c08a28a9de7b34fde1bb6" translate="yes" xml:space="preserve">
          <source>This is the opposite of &lt;code&gt;ours&lt;/code&gt;; note that, unlike &lt;code&gt;ours&lt;/code&gt;, there is no &lt;code&gt;theirs&lt;/code&gt; merge strategy to confuse this merge option with.</source>
          <target state="translated">这与 &lt;code&gt;ours&lt;/code&gt; 相反; 请注意，与 &lt;code&gt;ours&lt;/code&gt; 不同，没有 &lt;code&gt;theirs&lt;/code&gt; 合并策略可以混淆此合并选项。</target>
        </trans-unit>
        <trans-unit id="a470bc42a7932d13fef06a087064186d12eef547" translate="yes" xml:space="preserve">
          <source>This is the preferred method.</source>
          <target state="translated">这是首选的方法。</target>
        </trans-unit>
        <trans-unit id="d5ae5cf60359e7831f40d915d7567f63dc115a19" translate="yes" xml:space="preserve">
          <source>This is the same &lt;code&gt;git read-tree&lt;/code&gt; command we have already seen, but it takes three trees, unlike previous examples. This reads the contents of each tree into different &lt;code&gt;stage&lt;/code&gt; in the index file (the first tree goes to stage 1, the second to stage 2, etc.). After reading three trees into three stages, the paths that are the same in all three stages are &lt;code&gt;collapsed&lt;/code&gt; into stage 0. Also paths that are the same in two of three stages are collapsed into stage 0, taking the SHA-1 from either stage 2 or stage 3, whichever is different from stage 1 (i.e. only one side changed from the common ancestor).</source>
          <target state="translated">这是我们已经看到的相同的 &lt;code&gt;git read-tree&lt;/code&gt; 命令，但是它需要三棵树，这与前面的示例不同。这会将每个树的内容读入索引文件中的不同 &lt;code&gt;stage&lt;/code&gt; （第一棵树进入阶段1，第二棵树进入阶段2，依此类推）。将三棵树分为三个阶段后，在所有三个阶段中都相同的路径将 &lt;code&gt;collapsed&lt;/code&gt; 到阶段0中。还将在三个阶段中的两个阶段中相同的路径折叠到阶段0中，并从任一阶段2中获取SHA-1或第3阶段，与第1阶段中的任何一个都不相同（即，从共同祖先开始只改变了一侧）。</target>
        </trans-unit>
        <trans-unit id="d9a78198f4c718b4aad0f141375d5823cd8e39e3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;gitdir&lt;/code&gt; except that matching is done case-insensitively (e.g. on case-insensitive file systems)</source>
          <target state="translated">这与 &lt;code&gt;gitdir&lt;/code&gt; 相同，除了匹配不区分大小写（例如，不区分大小写的文件系统）</target>
        </trans-unit>
        <trans-unit id="3d8eaa3e252f616f4794342341d2f4ec065a52c7" translate="yes" xml:space="preserve">
          <source>This is the standard email format as described by RFC 2822.</source>
          <target state="translated">这是RFC 2822所描述的标准电子邮件格式。</target>
        </trans-unit>
        <trans-unit id="b1825adadaae31865a7ba56f02eeaa58bb1a595e" translate="yes" xml:space="preserve">
          <source>This is the standard helper program to use with &lt;code&gt;git merge-index&lt;/code&gt; to resolve a merge after the trivial merge done with &lt;code&gt;git read-tree -m&lt;/code&gt;.</source>
          <target state="translated">这是与 &lt;code&gt;git merge-index&lt;/code&gt; 一起使用的标准帮助程序，用于在使用 &lt;code&gt;git read-tree -m&lt;/code&gt; 进行微不足道的合并后解决合并。</target>
        </trans-unit>
        <trans-unit id="f4605ef17a6ae238fb7ad1359ce2fc3809a170d2" translate="yes" xml:space="preserve">
          <source>This is the state of the index file and the working file after &lt;code&gt;git merge&lt;/code&gt; returns control back to you, leaving the conflicting merge for you to resolve. Notice that the path &lt;code&gt;hello&lt;/code&gt; is still unmerged, and what you see with &lt;code&gt;git diff&lt;/code&gt; at this point is differences since stage 2 (i.e. your version).</source>
          <target state="translated">这是 &lt;code&gt;git merge&lt;/code&gt; 将控制权交还给您后，索引文件和工作文件的状态，将冲突的合并留给您解决。请注意，路径 &lt;code&gt;hello&lt;/code&gt; 仍未合并，此时您在 &lt;code&gt;git diff&lt;/code&gt; 上看到的是第二阶段以来的差异（即您的版本）。</target>
        </trans-unit>
        <trans-unit id="885013fc19184ff3f87757857452f6badc7e664c" translate="yes" xml:space="preserve">
          <source>This is to emulate &lt;code&gt;git fetch&lt;/code&gt; run on the &lt;code&gt;mothership&lt;/code&gt; using &lt;code&gt;git
push&lt;/code&gt; that is run in the opposite direction in order to integrate the work done on &lt;code&gt;satellite&lt;/code&gt;, and is often necessary when you can only make connection in one way (i.e. satellite can ssh into mothership but mothership cannot initiate connection to satellite because the latter is behind a firewall or does not run sshd).</source>
          <target state="translated">这是为了使用相反方向运行的 &lt;code&gt;git push&lt;/code&gt; 模拟在 &lt;code&gt;mothership&lt;/code&gt; 上运行的 &lt;code&gt;git fetch&lt;/code&gt; ，以便集成在 &lt;code&gt;satellite&lt;/code&gt; 完成的工作，并且在您只能以一种方式建立连接时（例如，人造卫星可以ssh进入母舰）通常是必需的但母权关系无法启动与卫星的连接，因为后者位于防火墙后面或未运行sshd）。</target>
        </trans-unit>
        <trans-unit id="a0fbffa526980249cc459b3697ae082d2fb16d12" translate="yes" xml:space="preserve">
          <source>This is to view the changes between two arbitrary &amp;lt;commit&amp;gt;.</source>
          <target state="translated">这是为了查看两个任意&amp;lt;commit&amp;gt;之间的更改。</target>
        </trans-unit>
        <trans-unit id="2ccd3734f230a6bccf87e0841ef19acfd1763ec7" translate="yes" xml:space="preserve">
          <source>This is used if &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; does not resolve the correct &lt;code&gt;-kb&lt;/code&gt; mode to use. If true, all unresolved files are sent to the client in mode &lt;code&gt;-kb&lt;/code&gt;. This causes the client to treat them as binary files, which suppresses any newline munging it otherwise might do. Alternatively, if it is set to &quot;guess&quot;, then the contents of the file are examined to decide if it is binary, similar to &lt;code&gt;core.autocrlf&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 无法解析要使用的正确 &lt;code&gt;-kb&lt;/code&gt; 模式，则使用此方法。如果为true，则所有未解析的文件都以 &lt;code&gt;-kb&lt;/code&gt; 模式发送到客户端。这导致客户端将它们视为二进制文件，从而抑制了换行符，否则可能会造成麻烦。或者，如果将其设置为&amp;ldquo; guess&amp;rdquo;，则类似于 &lt;code&gt;core.autocrlf&lt;/code&gt; ，将检查文件的内容以确定它是否为二进制。</target>
        </trans-unit>
        <trans-unit id="414b7e001678a67515e35206eca5b23ff617a9b6" translate="yes" xml:space="preserve">
          <source>This is used to avoid unnecessary false hits when &lt;code&gt;git diff-files&lt;/code&gt; is run after &lt;code&gt;git read-tree&lt;/code&gt;.</source>
          <target state="translated">这用于避免在 &lt;code&gt;git read-tree&lt;/code&gt; 之后运行 &lt;code&gt;git diff-files&lt;/code&gt; 时产生不必要的错误命中。</target>
        </trans-unit>
        <trans-unit id="1756049aad8be96bbdbe029ae5b31f810c9534b0" translate="yes" xml:space="preserve">
          <source>This is used to imply --all-progress whenever progress display is activated. Unlike --all-progress this flag doesn&amp;rsquo;t actually force any progress display by itself.</source>
          <target state="translated">每当激活进度显示时，它用于表示--all-progress。与--all-progress不同，此标志实际上并不强制自己显示任何进度。</target>
        </trans-unit>
        <trans-unit id="fa389947911fb92b7cae5947eac62679e5095362" translate="yes" xml:space="preserve">
          <source>This is used to reorder the filepairs according to the user&amp;rsquo;s (or project&amp;rsquo;s) taste, and is controlled by the -O option to the &lt;code&gt;git diff-*&lt;/code&gt; commands.</source>
          <target state="translated">这用于根据用户（或项目）的喜好对文件对重新排序，并由 &lt;code&gt;git diff-*&lt;/code&gt; 命令的-O选项控制。</target>
        </trans-unit>
        <trans-unit id="e4698ff07eb1e8e63a5c87a4e409437aeb77e0b4" translate="yes" xml:space="preserve">
          <source>This is useful because it makes it easy to choose a good commit to test when you want to avoid to test some of them for some reason (they may not compile for example).</source>
          <target state="translated">这很有用,因为当你因为某些原因(例如,它们可能无法编译)而想避免测试某些提交时,可以很容易地选择一个好的提交进行测试。</target>
        </trans-unit>
        <trans-unit id="8b37ac2c46d9c49011957ba8051eb182f97c074f" translate="yes" xml:space="preserve">
          <source>This is useful if F and G were flawed in some way, or should not be part of topicA. Note that the argument to --onto and the &amp;lt;upstream&amp;gt; parameter can be any valid commit-ish.</source>
          <target state="translated">如果F和G以某种方式存在缺陷，或者不应该成为topicA的一部分，则这很有用。请注意，--onto的参数和&amp;lt;upstream&amp;gt;参数可以是任何有效的commit-ish。</target>
        </trans-unit>
        <trans-unit id="5add7a300e88f092e0ef1b21363222f3ece44ad7" translate="yes" xml:space="preserve">
          <source>This is useful if remote side is git:// server accessed over some tunnel.</source>
          <target state="translated">如果远端是通过某个隧道访问的git://服务器,这很有用。</target>
        </trans-unit>
        <trans-unit id="d562e00428aacff2db14167eb0ecbc7ee7ea6370" translate="yes" xml:space="preserve">
          <source>This is useful if the branch on which you ran &lt;code&gt;git stash push&lt;/code&gt; has changed enough that &lt;code&gt;git stash apply&lt;/code&gt; fails due to conflicts. Since the stash entry is applied on top of the commit that was HEAD at the time &lt;code&gt;git stash&lt;/code&gt; was run, it restores the originally stashed state with no conflicts.</source>
          <target state="translated">如果您在其上运行 &lt;code&gt;git stash push&lt;/code&gt; 的分支已更改得足够多，以至于 &lt;code&gt;git stash apply&lt;/code&gt; 由于冲突而失败，这将很有用。由于存储条目是在运行 &lt;code&gt;git stash&lt;/code&gt; 时是HEAD的提交之上应用的，因此它可以恢复原始存储状态，而不会发生冲突。</target>
        </trans-unit>
        <trans-unit id="30fcffaf45041b08cc97af9d1fa76a9ba0b33fa3" translate="yes" xml:space="preserve">
          <source>This is useful if you want to begin your message in a discussion thread with comments and suggestions on the message you are responding to, and to conclude it with a patch submission, separating the discussion and the beginning of the proposed commit log message with a scissors line.</source>
          <target state="translated">如果您想在讨论线程中以评论和建议开始您的消息,并以提交补丁结束,用剪刀线隔开讨论和提交日志消息的开头,这很有用。</target>
        </trans-unit>
        <trans-unit id="f93051fa336df47ab5f519702120e3efac9cd277" translate="yes" xml:space="preserve">
          <source>This is useful on systems where lstat() calls are very slow, such as CIFS/Microsoft Windows.</source>
          <target state="translated">这对那些调用lstat()很慢的系统很有用,比如CIFS/Microsoft Windows。</target>
        </trans-unit>
        <trans-unit id="6b9439a13a0f6c5a19da94d77f92d4a1ee7e5be6" translate="yes" xml:space="preserve">
          <source>This is useful when cherry-picking more than one commits' effect to your index in a row.</source>
          <target state="translated">当在一行中挑选多个提交的效果时,这很有用。</target>
        </trans-unit>
        <trans-unit id="ccb566ca825959d19feaead9d9434de1315351a7" translate="yes" xml:space="preserve">
          <source>This is useful when reverting more than one commits' effect to your index in a row.</source>
          <target state="translated">这在恢复一行中多个提交的效果时很有用。</target>
        </trans-unit>
        <trans-unit id="a6b3b2938023c6383383af34a5efd6428edcf530" translate="yes" xml:space="preserve">
          <source>This is useful when topicB does not depend on topicA.</source>
          <target state="translated">当话题B不依赖于话题A时,这很有用。</target>
        </trans-unit>
        <trans-unit id="804a7dc8302db74d34102cb378738f0047ef1777" translate="yes" xml:space="preserve">
          <source>This is usually not what an end user wants to run directly. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; instead.</source>
          <target state="translated">最终用户通常不想直接运行它。参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81deedcd021f1608f9f91f70a15e2349e22a39d7" translate="yes" xml:space="preserve">
          <source>This is what &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; generates. Most headers and MIME formatting are ignored.</source>
          <target state="translated">这就是&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;生成的。大多数标题和MIME格式都将被忽略。</target>
        </trans-unit>
        <trans-unit id="ca6a5c0a1684e36bc50c3e68cfccb9e6ebf59a4b" translate="yes" xml:space="preserve">
          <source>This is what causes Git to track the remote&amp;rsquo;s branches; you may modify or delete these configuration options by editing &lt;code&gt;.git/config&lt;/code&gt; with a text editor. (See the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.)</source>
          <target state="translated">这就是导致Git跟踪远程分支的原因。您可以通过使用文本编辑器编辑 &lt;code&gt;.git/config&lt;/code&gt; 来修改或删除这些配置选项。（有关详细信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;的&amp;ldquo; CONFIGURATION FILE&amp;rdquo;部分。）</target>
        </trans-unit>
        <trans-unit id="e49010e0ec73f433e7f19c2db7cbfd7081066732" translate="yes" xml:space="preserve">
          <source>This is why it is a bad idea to just chose the next best unskipped bisection commit when the first one has been skipped.</source>
          <target state="translated">这就是为什么当第一个跳过的时候,只选择下一个最好的未跳过的二段提交是个坏主意。</target>
        </trans-unit>
        <trans-unit id="51722bee7db4c41cee14b92ba092db0dce132718" translate="yes" xml:space="preserve">
          <source>This leaves a copy of &lt;code&gt;next&lt;/code&gt; temporarily in FETCH_HEAD, but does not update any remote-tracking branches. Using remote-tracking branches, the same can be done by invoking fetch and merge:</source>
          <target state="translated">这会在FETCH_HEAD中暂时保留 &lt;code&gt;next&lt;/code&gt; 的副本，但不会更新任何远程跟踪分支。使用远程跟踪分支，可以通过调用访存和合并来完成相同的工作：</target>
        </trans-unit>
        <trans-unit id="8d3c273456c213d2f0eef245650834ea18d26a16" translate="yes" xml:space="preserve">
          <source>This lets you choose one path out of a &lt;code&gt;status&lt;/code&gt; like selection. After choosing the path, it presents the diff between the index and the working tree file and asks you if you want to stage the change of each hunk. You can select one of the following options and type return:</source>
          <target state="translated">这使您可以从选择之类的 &lt;code&gt;status&lt;/code&gt; 选择一条路径。选择路径后，它将显示索引和工作树文件之间的差异，并询问您是否要暂存每个块的更改。您可以选择以下选项之一，然后键入return：</target>
        </trans-unit>
        <trans-unit id="060b46ed6fd409fbf360157d2f3c13ff3dcd2220" translate="yes" xml:space="preserve">
          <source>This lets you quit without do cleaning.</source>
          <target state="translated">这让你不需要做清洁就可以退出。</target>
        </trans-unit>
        <trans-unit id="aa41c7db3702739cc1b230bda0b83b675d7b2671" translate="yes" xml:space="preserve">
          <source>This lets you review what will be committed (i.e. between HEAD and index).</source>
          <target state="translated">这可以让你审查将被提交的内容(即HEAD和索引之间)。</target>
        </trans-unit>
        <trans-unit id="ca3fd0a1256c2900c49910f1d037599eb216d4ff" translate="yes" xml:space="preserve">
          <source>This list should contain the URI of gitweb&amp;rsquo;s standard stylesheet. The default URI of gitweb stylesheet can be set at build time using the &lt;code&gt;GITWEB_CSS&lt;/code&gt; makefile variable. Its default value is &lt;code&gt;static/gitweb.css&lt;/code&gt; (or &lt;code&gt;static/gitweb.min.css&lt;/code&gt; if the &lt;code&gt;CSSMIN&lt;/code&gt; variable is defined, i.e. if CSS minifier is used during build).</source>
          <target state="translated">该列表应包含gitweb标准样式表的URI。可以在构建时使用 &lt;code&gt;GITWEB_CSS&lt;/code&gt; makefile变量设置gitweb样式表的默认URI 。其默认值为 &lt;code&gt;static/gitweb.css&lt;/code&gt; （如果定义了 &lt;code&gt;CSSMIN&lt;/code&gt; 变量，则为 &lt;code&gt;static/gitweb.min.css&lt;/code&gt; ，即，如果在构建过程中使用了CSS minifier）。</target>
        </trans-unit>
        <trans-unit id="87db555786bcad0bd342abfeced795a76cdcb852" translate="yes" xml:space="preserve">
          <source>This lists the commits reachable from the previous version of the &lt;code&gt;master&lt;/code&gt; branch head. This syntax can be used with any Git command that accepts a commit, not just with &lt;code&gt;git log&lt;/code&gt;. Some other examples:</source>
          <target state="translated">这列出了从 &lt;code&gt;master&lt;/code&gt; 分支头的先前版本可到达的提交。此语法可以与任何接受提交的Git命令一起使用，而不仅限于 &lt;code&gt;git log&lt;/code&gt; 。其他一些例子：</target>
        </trans-unit>
        <trans-unit id="9d19ff56a7106ea2437dd5210773dc60fd2828eb" translate="yes" xml:space="preserve">
          <source>This looks up the &amp;lt;file&amp;gt;(s) in the index and, if there are any merge entries, passes the SHA-1 hash for those files as arguments 1, 2, 3 (empty argument if no file), and &amp;lt;file&amp;gt; as argument 4. File modes for the three files are passed as arguments 5, 6 and 7.</source>
          <target state="translated">这将在索引中查找&amp;lt;file&amp;gt;，如果有任何合并条目，则将这些文件的SHA-1散列作为参数1、2、3（如果没有文件，则为空参数）和&amp;lt;file&amp;gt;作为参数4。三个文件的文件模式作为参数5、6和7传递。</target>
        </trans-unit>
        <trans-unit id="6790f45ac4b6ed7e77775e3a5dfba68fc876105d" translate="yes" xml:space="preserve">
          <source>This makes a commit that records the modification to &lt;code&gt;Makefile&lt;/code&gt;. The changes staged for &lt;code&gt;hello.c&lt;/code&gt; and &lt;code&gt;hello.h&lt;/code&gt; are not included in the resulting commit. However, their changes are not lost &amp;mdash; they are still staged and merely held back. After the above sequence, if you do:</source>
          <target state="translated">这将记录对 &lt;code&gt;Makefile&lt;/code&gt; 的修改的提交。针对 &lt;code&gt;hello.c&lt;/code&gt; 和 &lt;code&gt;hello.h&lt;/code&gt; 进行的更改未包含在结果提交中。但是，它们的更改不会丢失-它们仍会上演，只是受阻。在上述顺序之后，如果您这样做：</target>
        </trans-unit>
        <trans-unit id="c23316330a20f8d3e00d74e273bc6ee3d02efbd7" translate="yes" xml:space="preserve">
          <source>This makes a new branch called &lt;code&gt;other&lt;/code&gt; from &lt;code&gt;master~5..master&lt;/code&gt; (i.e. if &lt;code&gt;master&lt;/code&gt; has linear history, it will take the last 5 commits).</source>
          <target state="translated">这使得所谓的新分支 &lt;code&gt;other&lt;/code&gt; 从 &lt;code&gt;master~5..master&lt;/code&gt; （即，如果 &lt;code&gt;master&lt;/code&gt; 有线性的历史，它将采取的最后5次提交）。</target>
        </trans-unit>
        <trans-unit id="b0ade35fb815795f98a8b6354752858acd9e1cfa" translate="yes" xml:space="preserve">
          <source>This makes sure that only the key/value pair for kernel.org is replaced.</source>
          <target state="translated">这将确保只有kernel.org的key/value对被替换。</target>
        </trans-unit>
        <trans-unit id="2d726c732ca5f310160366fecc16a8d1ede4f94c" translate="yes" xml:space="preserve">
          <source>This manual describes the convention used throughout Git CLI.</source>
          <target state="translated">本手册介绍了Git CLI中使用的惯例。</target>
        </trans-unit>
        <trans-unit id="40982f6c18ca56554ec412b18ace4f012d6c51fa" translate="yes" xml:space="preserve">
          <source>This manual is designed to be readable by someone with basic UNIX command-line skills, but no previous knowledge of Git.</source>
          <target state="translated">本手册的设计目的是为了让具有基本 UNIX 命令行技能,但没有 Git 知识的人也能阅读。</target>
        </trans-unit>
        <trans-unit id="1b4c4400f56ace6af78ca50c928fe7f5cfe13be6" translate="yes" xml:space="preserve">
          <source>This manual page describes only the most frequently used options.</source>
          <target state="translated">本手册页面只介绍最常用的选项。</target>
        </trans-unit>
        <trans-unit id="c74c8f67468f674a4bbb6cadbdb326520214aafb" translate="yes" xml:space="preserve">
          <source>This manual page describes only the most frequently used options. See &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; for a complete list.</source>
          <target state="translated">本手册页仅介绍最常用的选项。有关完整列表，请参见&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78fbc8bf0be13ddc4f9bce27ee4dc19783022a2b" translate="yes" xml:space="preserve">
          <source>This means &quot;show everything that is reachable from either one, but exclude anything that is reachable from both of them&quot;.</source>
          <target state="translated">这意味着 &quot;显示所有从任何一个地方可以到达的东西,但排除所有从两个地方都可以到达的东西&quot;。</target>
        </trans-unit>
        <trans-unit id="9f4c07f14694007bf95dcdb96bbfc3991db01ef3" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; is the opposite of &lt;code&gt;git add
&amp;lt;pathspec&amp;gt;&lt;/code&gt;. This command is equivalent to &lt;code&gt;git restore [--source=&amp;lt;tree-ish&amp;gt;] --staged &amp;lt;pathspec&amp;gt;...&lt;/code&gt;.</source>
          <target state="translated">这意味着 &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; 与 &lt;code&gt;git add &amp;lt;pathspec&amp;gt;&lt;/code&gt; 相反。此命令等同于 &lt;code&gt;git restore [--source=&amp;lt;tree-ish&amp;gt;] --staged &amp;lt;pathspec&amp;gt;...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="138908f8222de2b4daf75b57b97dc896b1845167" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;git reset -p&lt;/code&gt; is the opposite of &lt;code&gt;git add -p&lt;/code&gt;, i.e. you can use it to selectively reset hunks. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">这意味着 &lt;code&gt;git reset -p&lt;/code&gt; 与 &lt;code&gt;git add -p&lt;/code&gt; 相反，即，您可以使用它选择性地重置块。请参阅&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;的&amp;ldquo;交互模式&amp;rdquo;部分，以了解如何操作 &lt;code&gt;--patch&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="9c231d7cedbd657513f91f60869397c2bef2f37d" translate="yes" xml:space="preserve">
          <source>This means that it is often &quot;cheaper&quot; if QA people or end users can do it.</source>
          <target state="translated">这意味着,如果QA人员或终端用户能够做到这一点,往往会 &quot;更便宜&quot;。</target>
        </trans-unit>
        <trans-unit id="0ff1dc064f7e1f4d0872498ac05a21ade168adc9" translate="yes" xml:space="preserve">
          <source>This means that test suites are good to prevent some bugs from being committed and they are also quite good to tell you that you have some bugs. But they are not so good to tell you where some bugs have been introduced. To tell you that efficiently, git bisect is needed.</source>
          <target state="translated">这意味着,测试套件很好地防止了一些bug的发生,它们也很好地告诉你你有一些bug。但它们并不能很好地告诉你哪里引入了一些bug。为了有效地告诉你这些,需要使用git bisect。</target>
        </trans-unit>
        <trans-unit id="388b9571e5f1264e3be3a08ce2827efedebdef31" translate="yes" xml:space="preserve">
          <source>This means that the best bisection commits are the commits where the following function is maximum:</source>
          <target state="translated">这意味着,最好的二分提交是以下函数最大的提交。</target>
        </trans-unit>
        <trans-unit id="597961da0012b9cd684792dccd1c7471e5687e9f" translate="yes" xml:space="preserve">
          <source>This means that the trimmed &amp;lt;token&amp;gt; and &amp;lt;value&amp;gt; will be separated by &lt;code&gt;': '&lt;/code&gt; (one colon followed by one space).</source>
          <target state="translated">这意味着修剪的&amp;lt;token&amp;gt;和&amp;lt;value&amp;gt;将由 &lt;code&gt;': '&lt;/code&gt; 分隔（一个冒号后跟一个空格）。</target>
        </trans-unit>
        <trans-unit id="38ea5711a664516b71bd0eeea932fd8ac8d7c412" translate="yes" xml:space="preserve">
          <source>This means that we get rid of the uninteresting commits in the DAG.</source>
          <target state="translated">这意味着,我们要把DAG中不感兴趣的提交内容去掉。</target>
        </trans-unit>
        <trans-unit id="2454a8b57cbe01726a67b284a671cd468ecfe3a7" translate="yes" xml:space="preserve">
          <source>This means that you can do</source>
          <target state="translated">这意味着,你可以做</target>
        </trans-unit>
        <trans-unit id="4bfb7f09c9f4811c3630d40fb2caf5f3310e564e" translate="yes" xml:space="preserve">
          <source>This means that you can use &lt;code&gt;git checkout -p&lt;/code&gt; to selectively discard edits from your current working tree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">这意味着您可以使用 &lt;code&gt;git checkout -p&lt;/code&gt; 从当前工作树中有选择地放弃编辑。请参阅&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;的&amp;ldquo;交互模式&amp;rdquo;部分，以了解如何操作 &lt;code&gt;--patch&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="2db1fd51873ef2a0afca87fc61387f5a8891e2a5" translate="yes" xml:space="preserve">
          <source>This merges the changes from Bob&amp;rsquo;s &quot;master&quot; branch into Alice&amp;rsquo;s current branch. If Alice has made her own changes in the meantime, then she may need to manually fix any conflicts.</source>
          <target state="translated">这会将Bob的&amp;ldquo; master&amp;rdquo;分支中的更改合并到Alice的当前分支中。如果爱丽丝在此期间进行了自己的更改，则她可能需要手动解决所有冲突。</target>
        </trans-unit>
        <trans-unit id="cff3569519105ed116111cf73b4d626e89a75fc2" translate="yes" xml:space="preserve">
          <source>This merges the file listing in the directory cache index with the actual working directory list, and shows different combinations of the two.</source>
          <target state="translated">这将目录缓存索引中的文件列表与实际工作目录列表合并,并显示两者的不同组合。</target>
        </trans-unit>
        <trans-unit id="e550f0e6cba8953c27a9638529775caa0627f8ed" translate="yes" xml:space="preserve">
          <source>This might not be what you expect, i.e. you want to prune remote &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, but also explicitly fetch tags from it, so when you fetch from it you delete all your local tags, most of which may not have come from the &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; remote in the first place.</source>
          <target state="translated">这可能不是您所期望的，即您想修剪远程 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; ，但也要从中明确获取标签，因此，从中获取时，您将删除所有本地标签，其中大多数可能不是来自 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 首先是远程。</target>
        </trans-unit>
        <trans-unit id="c165a1bf0e23a30271149315bd9959512cec8cbc" translate="yes" xml:space="preserve">
          <source>This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get</source>
          <target state="translated">这种模式与默认模式有一点不同:始终遵循合并的所有父节点,即使对其中一方是TREESAME。即使合并中不止一方有提交的内容,也不意味着合并本身就是这样的! 在这个例子中,我们得到</target>
        </trans-unit>
        <trans-unit id="06118fd3f101fa40f7bcb707d4305013c9a74e7d" translate="yes" xml:space="preserve">
          <source>This mode has become the default in Git 2.0.</source>
          <target state="translated">这个模式在 Git 2.0 中已经成为默认模式。</target>
        </trans-unit>
        <trans-unit id="9c35450959e8c97cb733c60205966cdb68e529c7" translate="yes" xml:space="preserve">
          <source>This mode is designed for repositories with very large indexes, and aims at reducing the time it takes to repeatedly write these indexes.</source>
          <target state="translated">这种模式是为具有非常大的索引的存储库设计的,目的是减少重复编写这些索引的时间。</target>
        </trans-unit>
        <trans-unit id="660380648a3de0733323135a33a60c0126cae6f8" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to dump the internal marks table to &amp;lt;file&amp;gt; when complete. For details, read up on &lt;code&gt;--export-marks=&amp;lt;file&amp;gt;&lt;/code&gt; in &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;.</source>
          <target state="translated">这将修改 &lt;code&gt;export&lt;/code&gt; 功能，指示Git完成后将内部标记表转储到&amp;lt;file&amp;gt;。有关详细信息，关于读向上 &lt;code&gt;--export-marks=&amp;lt;file&amp;gt;&lt;/code&gt; 在&lt;a href=&quot;git-fast-export&quot;&gt;GIT中快速出口[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="59a5d5693433000c28979c8002984ee295ddd735" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to load the marks specified in &amp;lt;file&amp;gt; before processing any input. For details, read up on &lt;code&gt;--import-marks=&amp;lt;file&amp;gt;&lt;/code&gt; in &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;.</source>
          <target state="translated">这修改了 &lt;code&gt;export&lt;/code&gt; 功能，指示Git在处理任何输入之前加载&amp;lt;file&amp;gt;中指定的标记。有关详细信息，关于读向上 &lt;code&gt;--import-marks=&amp;lt;file&amp;gt;&lt;/code&gt; 在&lt;a href=&quot;git-fast-export&quot;&gt;GIT中快速出口[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29cca50076d9ab0c1672949be9f5cf285333ce65" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to pass &lt;code&gt;--signed-tags=verbatim&lt;/code&gt; to &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;. In the absence of this capability, Git will use &lt;code&gt;--signed-tags=warn-strip&lt;/code&gt;.</source>
          <target state="translated">这修改了 &lt;code&gt;export&lt;/code&gt; 功能，指示Git将 &lt;code&gt;--signed-tags=verbatim&lt;/code&gt; 传递给&lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export [1]&lt;/a&gt;。如果没有此功能，Git将使用 &lt;code&gt;--signed-tags=warn-strip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cd76e4b36f80f26235450d81c7340212de49a9e" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;import&lt;/code&gt; capability. The fast-import commands &lt;code&gt;cat-blob&lt;/code&gt; and &lt;code&gt;ls&lt;/code&gt; can be used by remote-helpers to retrieve information about blobs and trees that already exist in fast-import&amp;rsquo;s memory. This requires a channel from fast-import to the remote-helper. If it is advertised in addition to &quot;import&quot;, Git establishes a pipe from fast-import to the remote-helper&amp;rsquo;s stdin. It follows that Git and fast-import are both connected to the remote-helper&amp;rsquo;s stdin. Because Git can send multiple commands to the remote-helper it is required that helpers that use &lt;code&gt;bidi-import&lt;/code&gt; buffer all &lt;code&gt;import&lt;/code&gt; commands of a batch before sending data to fast-import. This is to prevent mixing commands and fast-import responses on the helper&amp;rsquo;s stdin.</source>
          <target state="translated">这将修改 &lt;code&gt;import&lt;/code&gt; 功能。远程帮助人员可以使用快速导入命令 &lt;code&gt;cat-blob&lt;/code&gt; 和 &lt;code&gt;ls&lt;/code&gt; 来检索有关快速导入内存中已经存在的blob和树的信息。这需要从快速导入到远程帮助者的通道。如果除了&amp;ldquo; import&amp;rdquo;以外还进行广告宣传，Git会建立一条从快速导入到远程帮助程序的stdin的管道。因此，Git和快速导入都连接到了远程帮助程序的stdin。因为Git可以向远程帮助程序发送多个命令，所以要求使用 &lt;code&gt;bidi-import&lt;/code&gt; 的帮助程序缓冲所有 &lt;code&gt;import&lt;/code&gt; 将数据发送到快速导入之前的批处理命令。这是为了防止在助手的stdin上混合命令和快速导入响应。</target>
        </trans-unit>
        <trans-unit id="18b230f7b58b67f5f52143b1696b5514cecb3bd1" translate="yes" xml:space="preserve">
          <source>This operation is safe even if Alice has uncommitted local changes. The range notation &quot;HEAD..FETCH_HEAD&quot; means &quot;show everything that is reachable from the FETCH_HEAD but exclude anything that is reachable from HEAD&quot;. Alice already knows everything that leads to her current state (HEAD), and reviews what Bob has in his state (FETCH_HEAD) that she has not seen with this command.</source>
          <target state="translated">即使Alice有未提交的本地变更,这个操作也是安全的。范围符号 &quot;HEAD...FETCH_HEAD &quot;的意思是 &quot;显示所有从FETCH_HEAD可以到达的东西,但排除任何从HEAD可以到达的东西&quot;。爱丽丝已经知道了所有通向她当前状态(HEAD)的东西,并回顾了Bob在他的状态(FETCH_HEAD)中有哪些她没有看到的东西,用这个命令。</target>
        </trans-unit>
        <trans-unit id="4d6058894e90e81912f089323abaddf6ff7286d2" translate="yes" xml:space="preserve">
          <source>This option affects options that expect path name like &lt;code&gt;--git-dir&lt;/code&gt; and &lt;code&gt;--work-tree&lt;/code&gt; in that their interpretations of the path names would be made relative to the working directory caused by the &lt;code&gt;-C&lt;/code&gt; option. For example the following invocations are equivalent:</source>
          <target state="translated">此选项会影响期望路径名称的选项，例如 &lt;code&gt;--git-dir&lt;/code&gt; 和 &lt;code&gt;--work-tree&lt;/code&gt; ，因为它们对路径名称的解释将相对于 &lt;code&gt;-C&lt;/code&gt; 选项引起的工作目录进行。例如，以下调用是等效的：</target>
        </trans-unit>
        <trans-unit id="2b42f3dc9742d00737d912066dfd2008f4af0874" translate="yes" xml:space="preserve">
          <source>This option allows you to say that you expect the history you are updating is what you rebased and want to replace. If the remote ref still points at the commit you specified, you can be sure that no other people did anything to the ref. It is like taking a &quot;lease&quot; on the ref without explicitly locking it, and the remote ref is updated only if the &quot;lease&quot; is still valid.</source>
          <target state="translated">这个选项允许你说你希望更新的历史记录是你重写的,并且要替换。如果远程 ref 仍然指向你指定的提交,你可以确定没有其他人对 ref 做过任何事情。这就像在没有明确锁定的情况下对 ref 进行了 &quot;租赁&quot;,只有在 &quot;租赁 &quot;仍然有效的情况下,远程 ref 才会被更新。</target>
        </trans-unit>
        <trans-unit id="a3080455c3c310acd65dd25e9f3c439906791e33" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-commit and commit-msg hooks. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">该选项绕过了pre-commit和commit-msg挂钩。另请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae0cb95b3299088da58c88ea10fd24e68d20bac1" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-merge and commit-msg hooks. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">此选项绕过pre-merge和commit-msg挂钩。另请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22c10b3b137f37c4d219034c9b73126392cd066c" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-rebase hook. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">此选项绕过了预变基挂钩。另请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e7eb09891c6b3b929ffed676724fa916ce9b73e" translate="yes" xml:space="preserve">
          <source>This option can be either set to a boolean value or to &lt;code&gt;on-demand&lt;/code&gt;. Setting it to a boolean changes the behavior of fetch and pull to unconditionally recurse into submodules when set to true or to not recurse at all when set to false. When set to &lt;code&gt;on-demand&lt;/code&gt; (the default value), fetch and pull will only recurse into a populated submodule when its superproject retrieves a commit that updates the submodule&amp;rsquo;s reference.</source>
          <target state="translated">该选项可以设置为布尔值，也可以设置为 &lt;code&gt;on-demand&lt;/code&gt; 。将其设置为布尔值会更改fetch和pull的行为，设置为true时将无条件地递归到子模块中，或者设置为false时则完全不递归。当设置为 &lt;code&gt;on-demand&lt;/code&gt; （默认值）时，仅当其超级项目检索提交以更新子模块的引用的提交时，提取和拉取才会递归到已填充的子模块中。</target>
        </trans-unit>
        <trans-unit id="5d7a21f2665910c78fd7ff132552ce53899e84c0" translate="yes" xml:space="preserve">
          <source>This option can be used along with &lt;code&gt;--bisect-vars&lt;/code&gt;, in this case, after all the sorted commit objects, there will be the same text as if &lt;code&gt;--bisect-vars&lt;/code&gt; had been used alone.</source>
          <target state="translated">此选项可以与 &lt;code&gt;--bisect-vars&lt;/code&gt; 一起使用，在这种情况下，在所有排序的提交对象之后，将具有与 &lt;code&gt;--bisect-vars&lt;/code&gt; 单独使用相同的文本。</target>
        </trans-unit>
        <trans-unit id="93ff5c11faab29c493dcd0eb330b2a514a09e43b" translate="yes" xml:space="preserve">
          <source>This option can be used several times to provide several detection regexes.</source>
          <target state="translated">这个选项可以多次使用,以提供多个检测重词。</target>
        </trans-unit>
        <trans-unit id="a9be17765d99ef763e2665079651c5e7b4e1ceec" translate="yes" xml:space="preserve">
          <source>This option can be used to control recursive fetching of this submodule. If this option is also present in the submodules entry in .git/config of the superproject, the setting there will override the one found in .gitmodules. Both settings can be overridden on the command line by using the &quot;--[no-]recurse-submodules&quot; option to &quot;git fetch&quot; and &quot;git pull&quot;.</source>
          <target state="translated">这个选项可以用来控制这个子模块的递归获取。如果这个选项也存在于超级项目的.git/config中的子模块条目中,那里的设置将覆盖.gitmodules中的设置。这两个设置都可以在命令行上通过使用&quot;--[no-]recurse-submodules &quot;选项来覆盖 &quot;git fetch &quot;和 &quot;git pull&quot;。</target>
        </trans-unit>
        <trans-unit id="4813ba4c4b012e94932c2c7e77e5d37eb750ee7d" translate="yes" xml:space="preserve">
          <source>This option can be used to control recursive fetching of this submodule. It can be overridden by using the --[no-]recurse-submodules command-line option to &quot;git fetch&quot; and &quot;git pull&quot;. This setting will override that from in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file.</source>
          <target state="translated">此选项可用于控制此子模块的递归提取。可以通过使用-[no-] recurse-submodules命令行选项来&amp;ldquo; git fetch&amp;rdquo;和&amp;ldquo; git pull&amp;rdquo;来覆盖它。此设置将覆盖&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;文件中的设置。</target>
        </trans-unit>
        <trans-unit id="dc1c2b92ebab0226490f8de8ccd94e6df6f7955b" translate="yes" xml:space="preserve">
          <source>This option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options).</source>
          <target state="translated">这个选项可以用来将命令行选项从文件列表中分离出来,(当文件名可能被误认为是命令行选项时很有用)。</target>
        </trans-unit>
        <trans-unit id="792e2c6acea003d2f54070521de0f6b1fb530a29" translate="yes" xml:space="preserve">
          <source>This option can be used to specify a shell command that will be called to automatically add or modify a trailer with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">此选项可用于指定shell命令，该命令将被调用以使用指定的&amp;lt;token&amp;gt;自动添加或修改预告片。</target>
        </trans-unit>
        <trans-unit id="3870831de784b5f9a3b27254aee6ab6f7a036b72" translate="yes" xml:space="preserve">
          <source>This option can only be used for one-shot imports as &lt;code&gt;git svn&lt;/code&gt; will not be able to fetch again without metadata. Additionally, if you lose your &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; files, &lt;code&gt;git svn&lt;/code&gt; will not be able to rebuild them.</source>
          <target state="translated">此选项只能用于一次导入，因为 &lt;code&gt;git svn&lt;/code&gt; 如果没有元数据将无法再次获取。此外，如果丢失了 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; 文件，则 &lt;code&gt;git svn&lt;/code&gt; 将无法重建它们。</target>
        </trans-unit>
        <trans-unit id="7745929fdc4d071dfa2f069450065a35fb03a357" translate="yes" xml:space="preserve">
          <source>This option can only be used together with --dry-run. By using this option the user can check if any of the given files would be ignored, no matter if they are already present in the work tree or not.</source>
          <target state="translated">这个选项只能和--dry-run一起使用。通过使用这个选项,用户可以检查是否会忽略任何给定的文件,无论它们是否已经存在于工作树中。</target>
        </trans-unit>
        <trans-unit id="2cd2090b6cd931e9fb6990b800f11805da77a460" translate="yes" xml:space="preserve">
          <source>This option cannot (currently) be used unless &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; is used.</source>
          <target state="translated">除非使用 &lt;code&gt;--batch&lt;/code&gt; 或 &lt;code&gt;--batch-check&lt;/code&gt; ,否则（当前）不能使用此选项。</target>
        </trans-unit>
        <trans-unit id="882762ef26e2279478bc78603a1e7faf56dec8c3" translate="yes" xml:space="preserve">
          <source>This option controls if and under what conditions new commits of populated submodules should be fetched too. It can be used as a boolean option to completely disable recursion when set to &lt;code&gt;no&lt;/code&gt; or to unconditionally recurse into all populated submodules when set to &lt;code&gt;yes&lt;/code&gt;, which is the default when this option is used without any value. Use &lt;code&gt;on-demand&lt;/code&gt; to only recurse into a populated submodule when the superproject retrieves a commit that updates the submodule&amp;rsquo;s reference to a commit that isn&amp;rsquo;t already in the local submodule clone.</source>
          <target state="translated">此选项控制是否以及在什么条件下也应提取已填充子模块的新提交。设置为 &lt;code&gt;no&lt;/code&gt; 时，它可以用作布尔选项来完全禁用递归；设置为 &lt;code&gt;yes&lt;/code&gt; 时，它可以无条件地递归到所有填充的子模块中；这是使用此选项而没有任何值时的默认值。仅当超级项目检索到的提交会将子模块的引用更新为本地子模块克隆中尚未存在的提交时，才 &lt;code&gt;on-demand&lt;/code&gt; 使用以递归到已填充的子模块中。</target>
        </trans-unit>
        <trans-unit id="69bffdffaf64305a520ea61fd7a4110a4c5bf981" translate="yes" xml:space="preserve">
          <source>This option controls if new commits of all populated submodules should be fetched and updated, too (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;).</source>
          <target state="translated">此选项控制是否也应提取并更新所有已填充子模块的新提交（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;和&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="30828ff428cc76245c5c17e5cbd61f4d3413d1c5" translate="yes" xml:space="preserve">
          <source>This option determines how the commit message will be cleaned up before being passed on to the commit machinery. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more details. In particular, if the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is given a value of &lt;code&gt;scissors&lt;/code&gt;, scissors will be appended to &lt;code&gt;MERGE_MSG&lt;/code&gt; before being passed on in the case of a conflict.</source>
          <target state="translated">此选项确定在将提交消息传递到提交机器之前如何对其进行清理。有关更多详细信息，请参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;。特别是，如果为 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 赋予 &lt;code&gt;scissors&lt;/code&gt; 值，则在发生冲突时将在传递剪刀之前将其附加到 &lt;code&gt;MERGE_MSG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="286a93d0042817a6190102b1bfcb5df866579bac" translate="yes" xml:space="preserve">
          <source>This option determines how the merge message will be cleaned up before committing. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more details. In addition, if the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is given a value of &lt;code&gt;scissors&lt;/code&gt;, scissors will be appended to &lt;code&gt;MERGE_MSG&lt;/code&gt; before being passed on to the commit machinery in the case of a merge conflict.</source>
          <target state="translated">该选项确定提交前如何清除合并消息。有关更多详细信息，请参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;。另外，如果为 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 赋予 &lt;code&gt;scissors&lt;/code&gt; 值，则在发生合并冲突的情况下，剪刀将被附加到 &lt;code&gt;MERGE_MSG&lt;/code&gt; 上,然后传递给提交机制。</target>
        </trans-unit>
        <trans-unit id="4d1960d5d8472d2a194e5ec10acd8959326f748a" translate="yes" xml:space="preserve">
          <source>This option determines how the supplied commit message should be cleaned up before committing. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; can be &lt;code&gt;strip&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt;, &lt;code&gt;verbatim&lt;/code&gt;, &lt;code&gt;scissors&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">此选项确定在提交之前应如何清除提供的提交消息。所述 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 可以是 &lt;code&gt;strip&lt;/code&gt; ， &lt;code&gt;whitespace&lt;/code&gt; ， &lt;code&gt;verbatim&lt;/code&gt; ， &lt;code&gt;scissors&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5dab8a93409f72b36d8b46ab64625d688725721" translate="yes" xml:space="preserve">
          <source>This option does not (currently) work correctly when an object in the index is specified (e.g. &lt;code&gt;:link&lt;/code&gt; instead of &lt;code&gt;HEAD:link&lt;/code&gt;) rather than one in the tree.</source>
          <target state="translated">当在索引中指定一个对象（例如 &lt;code&gt;:link&lt;/code&gt; 而不是 &lt;code&gt;HEAD:link&lt;/code&gt; ）而不是树中的一个对象时，此选项（当前）无法正常工作。</target>
        </trans-unit>
        <trans-unit id="d9ea124fbd7a15594b4c6836d821b0c2d1f565c3" translate="yes" xml:space="preserve">
          <source>This option forces conflicting hunks to be auto-resolved cleanly by favoring &lt;code&gt;our&lt;/code&gt; version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side.</source>
          <target state="translated">此选项通过支持 &lt;code&gt;our&lt;/code&gt; 版本来强制自动解决冲突的大块。合并结果中反映了与另一棵树不冲突的变化。对于二进制文件，全部内容都是从我们这边获取的。</target>
        </trans-unit>
        <trans-unit id="03e43ead906b5a3ebd0febb15138c0f0fef70180" translate="yes" xml:space="preserve">
          <source>This option identifies the file status with the following tags (followed by a space) at the start of each line:</source>
          <target state="translated">这个选项在每行开头用以下标签(后面加一个空格)来标识文件状态。</target>
        </trans-unit>
        <trans-unit id="11f1817b2bcb9580d82cb7eff477a970ee3352b6" translate="yes" xml:space="preserve">
          <source>This option is NOT recommended as it makes it difficult to track down old references to SVN revision numbers in existing documentation, bug reports, and archives. If you plan to eventually migrate from SVN to Git and are certain about dropping SVN history, consider &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; instead. filter-repo also allows reformatting of metadata for ease-of-reading and rewriting authorship info for non-&quot;svn.authorsFile&quot; users.</source>
          <target state="translated">不建议使用此选项，因为它会使您难以在现有文档，错误报告和档案中跟踪对SVN修订版号的旧引用。如果您打算最终从SVN迁移到Git，并且确定要删除SVN历史记录，请考虑使用&lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt;。filter-repo还允许重新格式化元数据，以方便非&amp;ldquo; svn.authorsFile&amp;rdquo;用户的阅读和重写作者信息。</target>
        </trans-unit>
        <trans-unit id="78790ec840bc0471b6e620b0edc9dccd8cb32215" translate="yes" xml:space="preserve">
          <source>This option is a more advanced form of &lt;code&gt;subtree&lt;/code&gt; strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.</source>
          <target state="translated">此选项是 &lt;code&gt;subtree&lt;/code&gt; 策略的一种更高级形式，其中该策略猜测合并时必须如何移动两棵树以相互匹配。而是将指定的路径添加前缀（或从开头剥离）以使两棵树的形状匹配。</target>
        </trans-unit>
        <trans-unit id="4caf0764823caa06aa3cb192d447e797c84f9905" translate="yes" xml:space="preserve">
          <source>This option is deprecated in favour of &lt;code&gt;git stash push&lt;/code&gt;. It differs from &quot;stash push&quot; in that it cannot take pathspecs. Instead, all non-option arguments are concatenated to form the stash message.</source>
          <target state="translated">不推荐使用此选项，而推荐使用 &lt;code&gt;git stash push&lt;/code&gt; 。它与&amp;ldquo;隐藏推送&amp;rdquo;的不同之处在于它不能采用pathspec。而是将所有非选项参数串联起来构成隐藏消息。</target>
        </trans-unit>
        <trans-unit id="c02fef4ae69460732c7c3bd405bb6c17f43ad119" translate="yes" xml:space="preserve">
          <source>This option is equivalent to the &amp;lt;repository&amp;gt; argument. If both are specified, the command-line argument takes precedence.</source>
          <target state="translated">此选项等效于&amp;lt;repository&amp;gt;参数。如果两者都指定，则命令行参数优先。</target>
        </trans-unit>
        <trans-unit id="b7fdcf9707bc99b530bc435f0d474fdd1738b42d" translate="yes" xml:space="preserve">
          <source>This option is implicitly supplied if any other list-like option such as &lt;code&gt;--contains&lt;/code&gt; is provided. See the documentation for each of those options for details.</source>
          <target state="translated">如果提供了其他类似列表的选项（例如 &lt;code&gt;--contains&lt;/code&gt; ），则隐式提供此选项。有关每个选项的详细信息，请参见文档。</target>
        </trans-unit>
        <trans-unit id="710c94d6943c052c3ce9d72b355d1824bacce0cd" translate="yes" xml:space="preserve">
          <source>This option is only applicable in non-verbose mode.</source>
          <target state="translated">此选项仅适用于非言语模式。</target>
        </trans-unit>
        <trans-unit id="4cc49fd28601407189cb758fe5a41d5aaf8777ac" translate="yes" xml:space="preserve">
          <source>This option is only applicable when listing tags without annotation lines.</source>
          <target state="translated">此选项仅适用于列出没有注释行的标签时。</target>
        </trans-unit>
        <trans-unit id="ac28aa5e8f93911465d1aaa74ae4db50de2f286b" translate="yes" xml:space="preserve">
          <source>This option is only relevant if we are tracking branches (using one of the repository layout options --trunk, --tags, --branches, --stdlayout). For each tracked branch, try to find out where its revision was copied from, and set a suitable parent in the first Git commit for the branch. This is especially helpful when we&amp;rsquo;re tracking a directory that has been moved around within the repository. If this feature is disabled, the branches created by &lt;code&gt;git svn&lt;/code&gt; will all be linear and not share any history, meaning that there will be no information on where branches were branched off or merged. However, following long/convoluted histories can take a long time, so disabling this feature may speed up the cloning process. This feature is enabled by default, use --no-follow-parent to disable it.</source>
          <target state="translated">仅当我们跟踪分支时才使用此选项（使用存储库布局选项--trunk，-tags，-branches，-stdlayout中的一个）。对于每个跟踪的分支，尝试找出其修订版本从何处复制，并在该分支的第一个Git提交中设置合适的父级。当我们跟踪已在存储库中移动的目录时，这特别有用。如果禁用此功能，则由 &lt;code&gt;git svn&lt;/code&gt; 创建的分支将全部是线性的，并且不会共享任何历史记录，这意味着将没有关于分支在何处分支或合并的信息。但是，遵循较长/复杂的历史记录可能会花费很长时间，因此禁用此功能可能会加快克隆过程。默认情况下启用此功能，请使用--no-follow-parent禁用它。</target>
        </trans-unit>
        <trans-unit id="e12fdc170000781ad1c58dbca132db57e3472f94" translate="yes" xml:space="preserve">
          <source>This option is only used by Mac OS implementation of Git. When core.precomposeUnicode=true, Git reverts the unicode decomposition of filenames done by Mac OS. This is useful when sharing a repository between Mac OS and Linux or Windows. (Git for Windows 1.7.10 or higher is needed, or Git under cygwin 1.7). When false, file names are handled fully transparent by Git, which is backward compatible with older versions of Git.</source>
          <target state="translated">这个选项只在Mac OS实现的Git中使用。当core.precomposeUnicode=true时,Git会恢复Mac OS对文件名的unicode分解。这在 Mac OS 和 Linux 或 Windows 之间共享仓库时非常有用。(需要 Git for Windows 1.7.10 或更高版本,或 Git under cygwin 1.7)。当为 &quot;false &quot;时,Git对文件名的处理是完全透明的,这与旧版本的Git向后兼容。</target>
        </trans-unit>
        <trans-unit id="488a5b3855b8742f267f0b39339ad03e677bc10e" translate="yes" xml:space="preserve">
          <source>This option is only valid for add and update commands. Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.</source>
          <target state="translated">这个选项只对添加和更新命令有效。除非指定了 -q,否则当标准错误流连接到终端时,默认情况下会报告进度状态。即使标准错误流没有指向终端,该标志也会强制报告进度状态。</target>
        </trans-unit>
        <trans-unit id="564be2665790d0ee7a744865d472382d1cf20497" translate="yes" xml:space="preserve">
          <source>This option is only valid for add and update commands. These commands sometimes need to clone a remote repository. In this case, this option will be passed to the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; command.</source>
          <target state="translated">此选项仅对添加和更新命令有效。这些命令有时需要克隆远程存储库。在这种情况下，此选项将传递给&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="1175e1719609394666bffaa81ec16b8052e4a6b8" translate="yes" xml:space="preserve">
          <source>This option is only valid for add, deinit and update commands. When running add, allow adding an otherwise ignored submodule path. When running deinit the submodule working trees will be removed even if they contain local changes. When running update (only effective with the checkout procedure), throw away local changes in submodules when switching to a different commit; and always run a checkout operation in the submodule, even if the commit listed in the index of the containing repository matches the commit checked out in the submodule.</source>
          <target state="translated">这个选项只对add、deinit和update命令有效。当运行add时,允许添加一个否则被忽略的子模块路径。当运行deinit时,子模块工作树将被删除,即使它们包含本地变化。当运行 update 时(仅对 checkout 程序有效),当切换到不同的提交时,扔掉子模块中的本地变化;并且总是在子模块中运行 checkout 操作,即使包含仓库的索引中列出的提交与子模块中签出的提交相匹配。</target>
        </trans-unit>
        <trans-unit id="2de8d442aa39a274aaa4b758d62aa7d0adb622e3" translate="yes" xml:space="preserve">
          <source>This option is only valid for foreach, update, status and sync commands. Traverse submodules recursively. The operation is performed not only in the submodules of the current repo, but also in any nested submodules inside those submodules (and so on).</source>
          <target state="translated">这个选项只对foreach、update、status和sync命令有效。递归遍历子模块。该操作不仅在当前 repo 的子模块中执行,而且在这些子模块中的任何嵌套的子模块中执行(以此类推)。</target>
        </trans-unit>
        <trans-unit id="d01c54f91ad08eb6d9511d7549b500d6b89b1500" translate="yes" xml:space="preserve">
          <source>This option is only valid for status and summary commands. These commands typically use the commit found in the submodule HEAD, but with this option, the commit stored in the index is used instead.</source>
          <target state="translated">这个选项只对状态和摘要命令有效。这些命令通常使用子模块HEAD中的提交,但使用这个选项,会使用索引中存储的提交。</target>
        </trans-unit>
        <trans-unit id="7ba21174d5319ba108a98df185e2c79d000e199b" translate="yes" xml:space="preserve">
          <source>This option is only valid for the add command. It sets the submodule&amp;rsquo;s name to the given string instead of defaulting to its path. The name must be valid as a directory name and may not end with a &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">此选项仅对add命令有效。它将子模块的名称设置为给定的字符串，而不是默认使用其路径。该名称必须作为目录名称有效，并且不能以 &lt;code&gt;/&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="87ff71824f0ae07bd73763f995cf49d0ad4b94cd" translate="yes" xml:space="preserve">
          <source>This option is only valid for the deinit command. Unregister all submodules in the working tree.</source>
          <target state="translated">这个选项只对deinit命令有效。取消注册工作树中的所有子模块。</target>
        </trans-unit>
        <trans-unit id="f24783ef5194da88d7aca04af04dd4876a0ce3ed" translate="yes" xml:space="preserve">
          <source>This option is only valid for the summary command. Limit the summary size (number of commits shown in total). Giving 0 will disable the summary; a negative number means unlimited (the default). This limit only applies to modified submodules. The size is always limited to 1 for added/deleted/typechanged submodules.</source>
          <target state="translated">这个选项只对摘要命令有效。限制摘要的大小(总共显示的提交次数)。给予0将禁用摘要;负数表示无限制(默认)。这个限制只适用于修改过的子模块。对于添加/删除/类型改变的子模块,大小总是限制为1。</target>
        </trans-unit>
        <trans-unit id="ba7d2b303205764476dea6127f5143ab027381fd" translate="yes" xml:space="preserve">
          <source>This option is only valid for the summary command. This command compares the commit in the index with that in the submodule HEAD when this option is used.</source>
          <target state="translated">这个选项只对摘要命令有效。当使用该选项时,该命令将索引中的提交与子模块HEAD中的提交进行比较。</target>
        </trans-unit>
        <trans-unit id="0329e613a2d579c43cf813e4dcb872eed327d20c" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Checkout the commit recorded in the superproject on a detached HEAD in the submodule. This is the default behavior, the main use of this option is to override &lt;code&gt;submodule.$name.update&lt;/code&gt; when set to a value other than &lt;code&gt;checkout&lt;/code&gt;. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is either not explicitly set or set to &lt;code&gt;checkout&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">此选项仅对update命令有效。在子模块中的分离HEAD上签出超级项目中记录的提交。这是默认行为，当设置为 &lt;code&gt;checkout&lt;/code&gt; 以外的其他值时，此选项的主要用途是覆盖 &lt;code&gt;submodule.$name.update&lt;/code&gt; 。如果未显式设置键 &lt;code&gt;submodule.$name.update&lt;/code&gt; 或将其设置为 &lt;code&gt;checkout&lt;/code&gt; ，则此选项为隐式。</target>
        </trans-unit>
        <trans-unit id="7988d8bd0ba82c9f133c5f7cc525c2236228f253" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Clone new submodules in parallel with as many jobs. Defaults to the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; option.</source>
          <target state="translated">此选项仅对update命令有效。克隆新的子模块，同时包含尽可能多的作业。默认为 &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="de5e49243a4037b1b14e7038956130dc87de6d4f" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Don&amp;rsquo;t fetch new objects from the remote site.</source>
          <target state="translated">此选项仅对update命令有效。不要从远程站点获取新对象。</target>
        </trans-unit>
        <trans-unit id="f13e740e91a73f0a2574eefa11fc263894a39d8c" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Initialize all submodules for which &quot;git submodule init&quot; has not been called so far before updating.</source>
          <target state="translated">这个选项只对更新命令有效。在更新前,初始化所有尚未调用 &quot;git submodule init &quot;的子模块。</target>
        </trans-unit>
        <trans-unit id="78bb9a5b0867074719f5c17324b183ac216eed4e" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Instead of using the superproject&amp;rsquo;s recorded SHA-1 to update the submodule, use the status of the submodule&amp;rsquo;s remote-tracking branch. The remote used is branch&amp;rsquo;s remote (&lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt;), defaulting to &lt;code&gt;origin&lt;/code&gt;. The remote branch used defaults to &lt;code&gt;master&lt;/code&gt;, but the branch name may be overridden by setting the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; option in either &lt;code&gt;.gitmodules&lt;/code&gt; or &lt;code&gt;.git/config&lt;/code&gt; (with &lt;code&gt;.git/config&lt;/code&gt; taking precedence).</source>
          <target state="translated">此选项仅对update命令有效。不要使用超级项目记录的SHA-1更新子模块，而要使用子模块的远程跟踪分支的状态。所使用的远程是分支的远程（ &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; ），默认为 &lt;code&gt;origin&lt;/code&gt; 。使用的远程分支默认为 &lt;code&gt;master&lt;/code&gt; ，但是可以通过设置 &lt;code&gt;.gitmodules&lt;/code&gt; 或 &lt;code&gt;.git/config&lt;/code&gt; 中的 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 选项来覆盖分支名称（以 &lt;code&gt;.git/config&lt;/code&gt; 优先）。</target>
        </trans-unit>
        <trans-unit id="c3d36d21960733622c3c4d0c9b1d02dde186ab4d" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Merge the commit recorded in the superproject into the current branch of the submodule. If this option is given, the submodule&amp;rsquo;s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve the resulting conflicts within the submodule with the usual conflict resolution tools. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is set to &lt;code&gt;merge&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">此选项仅对update命令有效。将超级项目中记录的提交合并到子模块的当前分支中。如果给出此选项，则不会分离子模块的HEAD。如果合并失败阻止了此过程，则必须使用常规的冲突解决工具来解决子模块内导致的冲突。如果键 &lt;code&gt;submodule.$name.update&lt;/code&gt; 设置为 &lt;code&gt;merge&lt;/code&gt; ，则此选项为隐式。</target>
        </trans-unit>
        <trans-unit id="24320b0a3d3cc55ac6e67c5111e4d5b2024f7768" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Rebase the current branch onto the commit recorded in the superproject. If this option is given, the submodule&amp;rsquo;s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve these failures with &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is set to &lt;code&gt;rebase&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">此选项仅对update命令有效。将当前分支重新基于超级项目中记录的提交。如果给出此选项，则不会分离子模块的HEAD。如果合并失败阻止了此过程，则必须使用&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;解决这些失败。如果密钥 &lt;code&gt;submodule.$name.update&lt;/code&gt; 设置为 &lt;code&gt;rebase&lt;/code&gt; ，则此选项为隐式。</target>
        </trans-unit>
        <trans-unit id="7010a654e778ac0c1da27a5e658bfb8f3af2d2b7" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. The initial clone of a submodule will use the recommended &lt;code&gt;submodule.&amp;lt;name&amp;gt;.shallow&lt;/code&gt; as provided by the &lt;code&gt;.gitmodules&lt;/code&gt; file by default. To ignore the suggestions use &lt;code&gt;--no-recommend-shallow&lt;/code&gt;.</source>
          <target state="translated">此选项仅对update命令有效。子模块的初始克隆将使用 &lt;code&gt;.gitmodules&lt;/code&gt; 文件默认提供的推荐 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.shallow&lt;/code&gt; 。要忽略建议，请使用 &lt;code&gt;--no-recommend-shallow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6d7b3753dd95003bf8a5d9061fa7c1fb4ce2aaa" translate="yes" xml:space="preserve">
          <source>This option is only valid when &quot;--rebase&quot; is used.</source>
          <target state="translated">这个选项只有在使用&quot;--rebase &quot;时才有效。</target>
        </trans-unit>
        <trans-unit id="f287cb1cbdf50b2a99b97c922a7a8e625bb0e374" translate="yes" xml:space="preserve">
          <source>This option is passed through to &lt;code&gt;git pack-objects&lt;/code&gt;.</source>
          <target state="translated">此选项通过 &lt;code&gt;git pack-objects&lt;/code&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="4fbc055bad10c535a2fe42cbab527b95ac43fb4e" translate="yes" xml:space="preserve">
          <source>This option is primarily to help users who are used to older versions of Git, whose &quot;git add &amp;lt;pathspec&amp;gt;&amp;hellip;​&quot; was a synonym for &quot;git add --no-all &amp;lt;pathspec&amp;gt;&amp;hellip;​&quot;, i.e. ignored removed files.</source>
          <target state="translated">此选项主要是为习惯于旧版本Git的用户提供帮助，这些用户的&amp;ldquo; git add &amp;lt;pathspec&amp;gt;&amp;hellip;&amp;rdquo;是&amp;ldquo; git add --no-all &amp;lt;pathspec&amp;gt; ...&amp;rdquo;的同义词，即忽略已删除的文件。</target>
        </trans-unit>
        <trans-unit id="b78fb9017b343dcaa9f7e76e34c0b6aead88f71f" translate="yes" xml:space="preserve">
          <source>This option is similar to &lt;code&gt;--topo-order&lt;/code&gt; in the sense that no parent comes before all of its children, but otherwise commits are ordered according to their commit date.</source>
          <target state="translated">此选项与 &lt;code&gt;--topo-order&lt;/code&gt; 相似，在某种意义上，没有父级先于其所有子级出现，但其他提交是根据其提交日期排序的。</target>
        </trans-unit>
        <trans-unit id="45355afb761a7570eab836899016e010dbbaff37" translate="yes" xml:space="preserve">
          <source>This option is used internally to temporarily provide a non-negative default value for the --recurse-submodules option. All other methods of configuring fetch&amp;rsquo;s submodule recursion (such as settings in &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; and &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) override this option, as does specifying --[no-]recurse-submodules directly.</source>
          <target state="translated">此选项在内部用于临时为--recurse-submodules选项提供非负默认值。所有其他配置fetch的子模块递归的方法（例如&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;和&lt;a href=&quot;git-config&quot;&gt;git-config [1]中的设置&lt;/a&gt;）都会覆盖此选项，就像直接指定-[no-] recurse-submodules一样。</target>
        </trans-unit>
        <trans-unit id="37e6c888c3b366c4018908c683d3076036665dbd" translate="yes" xml:space="preserve">
          <source>This option is useful in the case where one is developing a feature on top of an upstream branch. While the feature is being worked on, the upstream branch may advance and it may not be the best idea to keep rebasing on top of the upstream but to keep the base commit as-is.</source>
          <target state="translated">当我们在上游分支的基础上开发一个特性时,这个选项是很有用的。当功能正在开发的时候,上游分支可能会前进,因此在上游分支的基础上继续重新归类可能不是最好的主意,而应该保持基础提交的原样。</target>
        </trans-unit>
        <trans-unit id="df85f593fd6f7620dd8216482ba39599038d6eaa" translate="yes" xml:space="preserve">
          <source>This option is valid for add and update commands. Create a &lt;code&gt;shallow&lt;/code&gt; clone with a history truncated to the specified number of revisions. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;</source>
          <target state="translated">此选项对添加和更新命令有效。创建一个 &lt;code&gt;shallow&lt;/code&gt; 副本，其历史记录被截断为指定的修订版本。参见&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ebd5b9556122446be4baef760f1327190ef9a1e0" translate="yes" xml:space="preserve">
          <source>This option makes it possible to choose what action will be performed when there is already at least one trailer with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">使用此选项可以选择在消息中已经存在至少一个具有相同&amp;lt;token&amp;gt;的预告片时执行的操作。</target>
        </trans-unit>
        <trans-unit id="ccc070d377579e85f01a8bc02ef61c868f5331ee" translate="yes" xml:space="preserve">
          <source>This option makes it possible to choose what action will be performed when there is not yet any trailer with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">此选项使您可以选择在消息中还没有任何具有相同&amp;lt;token&amp;gt;的预告片时将执行的操作。</target>
        </trans-unit>
        <trans-unit id="f87ac9b403a45c29acabaf374d53994925318884" translate="yes" xml:space="preserve">
          <source>This option may be given up to three times, and specifies labels to be used in place of the corresponding file names in conflict reports. That is, &lt;code&gt;git merge-file -L x -L y -L z a b c&lt;/code&gt; generates output that looks like it came from files x, y and z instead of from files a, b and c.</source>
          <target state="translated">该选项最多可给出3次，并指定用于代替冲突报告中相应文件名的标签。也就是说， &lt;code&gt;git merge-file -L x -L y -L z a b c&lt;/code&gt; 生成的输出看起来像是来自文件x，y和z而不是来自文件a，b和c。</target>
        </trans-unit>
        <trans-unit id="e631233708c2bfee4790b72e1f69b49f86a6c1ad" translate="yes" xml:space="preserve">
          <source>This option may be specified more than once.</source>
          <target state="translated">此选项可指定一次以上。</target>
        </trans-unit>
        <trans-unit id="ad4bbf67e7b293924d5786bf652c9c00512dbaee" translate="yes" xml:space="preserve">
          <source>This option may be specified more than once; if so, Git will report commits reachable from any of the given commits.</source>
          <target state="translated">这个选项可以指定多个,如果是这样的话,Git会报告从任何一个给定的提交到达的提交。</target>
        </trans-unit>
        <trans-unit id="02516672facfbf5a7b264eba6cd92c5455d92d79" translate="yes" xml:space="preserve">
          <source>This option may be specified multiple times.</source>
          <target state="translated">此选项可指定多次。</target>
        </trans-unit>
        <trans-unit id="b397b665066a62a5850aaf1e8487dea9e6d48e99" translate="yes" xml:space="preserve">
          <source>This option may be useful if you have CVS revision numbers stored in commit messages, bug-tracking systems, email archives, and the like.</source>
          <target state="translated">如果你的 CVS 版本号存储在提交信息、错误跟踪系统、电子邮件档案中,这个选项可能会很有用。</target>
        </trans-unit>
        <trans-unit id="5f0fddd7193d3e6d239ce8fc4bc7fc077dbf4105" translate="yes" xml:space="preserve">
          <source>This option may be useful when the test you would perform in each step does not require a checked out tree.</source>
          <target state="translated">当你在每个步骤中执行的测试不需要检查出的树时,这个选项可能很有用。</target>
        </trans-unit>
        <trans-unit id="17ca02a4d5f28c7e8971b8d1a382a0b6bcfa0d17" translate="yes" xml:space="preserve">
          <source>This option overrides this restriction if the current value of the remote ref is the expected value. &quot;git push&quot; fails otherwise.</source>
          <target state="translated">如果远程ref的当前值是预期值,这个选项会覆盖这个限制。否则 &quot;git push &quot;会失败。</target>
        </trans-unit>
        <trans-unit id="8d166b9e59f19f7598d41e509f594cbcbd0ac7f1" translate="yes" xml:space="preserve">
          <source>This option provides an additional limit on top of &lt;code&gt;--window&lt;/code&gt;; the window size will dynamically scale down so as to not take up more than &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; bytes in memory. This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. &lt;code&gt;--window-memory=0&lt;/code&gt; makes memory usage unlimited. The default is taken from the &lt;code&gt;pack.windowMemory&lt;/code&gt; configuration variable.</source>
          <target state="translated">此选项在 &lt;code&gt;--window&lt;/code&gt; 之上提供了一个额外的限制；窗口大小将动态缩小，以使内存中的字节数不超过 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 个字节。这在包含大型对象和小型对象的存储库中非常有用，这样不会因为一个大窗口而用完内存，但是仍然可以利用大窗口来存储较小的对象。大小可以后缀&amp;ldquo; k&amp;rdquo;，&amp;ldquo; m&amp;rdquo;或&amp;ldquo; g&amp;rdquo;。 &lt;code&gt;--window-memory=0&lt;/code&gt; 使内存使用不受限制。默认值来自 &lt;code&gt;pack.windowMemory&lt;/code&gt; 配置变量。</target>
        </trans-unit>
        <trans-unit id="b37ac455915a6998f49ecb85f682ef29dfba0c63" translate="yes" xml:space="preserve">
          <source>This option provides an additional limit on top of &lt;code&gt;--window&lt;/code&gt;; the window size will dynamically scale down so as to not take up more than &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; bytes in memory. This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. &lt;code&gt;--window-memory=0&lt;/code&gt; makes memory usage unlimited. The default is taken from the &lt;code&gt;pack.windowMemory&lt;/code&gt; configuration variable. Note that the actual memory usage will be the limit multiplied by the number of threads used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;.</source>
          <target state="translated">此选项在 &lt;code&gt;--window&lt;/code&gt; 之上提供了一个额外的限制；窗口大小将动态缩小，以使内存中的字节数不超过 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 个字节。这在包含大型对象和小型对象的存储库中非常有用，这样不会因为一个大窗口而用完内存，但是仍然可以利用大窗口来存储较小的对象。大小可以后缀&amp;ldquo; k&amp;rdquo;，&amp;ldquo; m&amp;rdquo;或&amp;ldquo; g&amp;rdquo;。 &lt;code&gt;--window-memory=0&lt;/code&gt; 使内存使用不受限制。默认值来自 &lt;code&gt;pack.windowMemory&lt;/code&gt; 配置变量。请注意，实际内存使用量将是限制乘以&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;使用的线程数。</target>
        </trans-unit>
        <trans-unit id="16a6b7273f3cccefcfa42e33a667c568aaee0875" translate="yes" xml:space="preserve">
          <source>This option sets how the tag message is cleaned up. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; can be one of &lt;code&gt;verbatim&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt; and &lt;code&gt;strip&lt;/code&gt;. The &lt;code&gt;strip&lt;/code&gt; mode is default. The &lt;code&gt;verbatim&lt;/code&gt; mode does not change message at all, &lt;code&gt;whitespace&lt;/code&gt; removes just leading/trailing whitespace lines and &lt;code&gt;strip&lt;/code&gt; removes both whitespace and commentary.</source>
          <target state="translated">此选项设置清除标签消息的方式。所述 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 可以是一个 &lt;code&gt;verbatim&lt;/code&gt; ， &lt;code&gt;whitespace&lt;/code&gt; 和 &lt;code&gt;strip&lt;/code&gt; 。所述 &lt;code&gt;strip&lt;/code&gt; 模式是默认值。的 &lt;code&gt;verbatim&lt;/code&gt; 模式完全不改变消息时， &lt;code&gt;whitespace&lt;/code&gt; 将删除刚刚前/后空白线和 &lt;code&gt;strip&lt;/code&gt; 同时去除空白和评注。</target>
        </trans-unit>
        <trans-unit id="1c04622cab5eac3fe5e20d1c189be97d2000ad23" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.ifexists&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">此选项采用与 &lt;code&gt;trailer.ifexists&lt;/code&gt; 配置变量相同的值，并且它将覆盖该选项为具有指定&amp;lt;token&amp;gt;的拖车指定的值。</target>
        </trans-unit>
        <trans-unit id="de59f6641e33166f78c75c60b985eacdf1d2a0ea" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.ifmissing&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">该选项采用与 &lt;code&gt;trailer.ifmissing&lt;/code&gt; 配置变量相同的值，并且它将覆盖该选项为具有指定&amp;lt;token&amp;gt;的拖车指定的值。</target>
        </trans-unit>
        <trans-unit id="6b156d8c8a67e1eaa9c71b8c4e454e308c17c450" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.where&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">该选项采用与 &lt;code&gt;trailer.where&lt;/code&gt; 配置变量相同的值，并且它将覆盖该选项为具有指定&amp;lt;token&amp;gt;的拖车指定的值。</target>
        </trans-unit>
        <trans-unit id="7df9ff293572a5c1527bce59783d9544419daa5b" translate="yes" xml:space="preserve">
          <source>This option tells where a new trailer will be added.</source>
          <target state="translated">这个选项告诉我们新的预告片将被添加到哪里。</target>
        </trans-unit>
        <trans-unit id="b36c69b0196d300061790058cdc0665affb9915e" translate="yes" xml:space="preserve">
          <source>This option tells which characters are recognized as trailer separators. By default only &lt;code&gt;:&lt;/code&gt; is recognized as a trailer separator, except that &lt;code&gt;=&lt;/code&gt; is always accepted on the command line for compatibility with other git commands.</source>
          <target state="translated">此选项告诉哪些字符被识别为尾部分隔符。默认情况下，仅 &lt;code&gt;:&lt;/code&gt; 被识别为尾部分隔符，但为了与其他git命令兼容，始终在命令行上接受 &lt;code&gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d89b4c86a97ff8d1caa3cc84d59173003c0040dc" translate="yes" xml:space="preserve">
          <source>This option will cause fast-export to issue a &quot;deleteall&quot; directive for each commit followed by a full list of all files in the commit (as opposed to just listing the files which are different from the commit&amp;rsquo;s first parent).</source>
          <target state="translated">此选项将导致快速导出为每个提交发出&amp;ldquo; deleteall&amp;rdquo;指令，后跟该提交中所有文件的完整列表（而不是仅列出与提交的第一个父文件不同的文件）。</target>
        </trans-unit>
        <trans-unit id="f143abcfc92e5721db51d7183ec9951b417133b6" translate="yes" xml:space="preserve">
          <source>This option will cause git-svn to attempt to automatically populate the svn:mergeinfo property in the SVN repository when possible. Currently, this can only be done when dcommitting non-fast-forward merges where all parents but the first have already been pushed into SVN.</source>
          <target state="translated">这个选项会让 git-svn 在可能的情况下尝试自动填充 SVN 仓库中的 svn:mergeinfo 属性。目前,只有在提交非快进式合并时,除了第一条以外的所有父版本都已经被推送到SVN中时,才能做到这一点。</target>
        </trans-unit>
        <trans-unit id="06697c041d5aacbd598da12e9917cf43b1b799c5" translate="yes" xml:space="preserve">
          <source>This option will cause the mapping from old to new objects to be loaded from named branch upon startup and saved as a new commit to that branch upon exit, enabling incremental of large trees. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does not exist it will be created.</source>
          <target state="translated">此选项将导致从旧对象到新对象的映射在启动时从命名分支加载，并在退出时另存为对该分支的新提交，从而启用大树的增量。如果 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 不存在，将创建它。</target>
        </trans-unit>
        <trans-unit id="dac1adaa75a920f5808dd15e4e9468c4b8319529" translate="yes" xml:space="preserve">
          <source>This output format is compatible with what &lt;code&gt;--index-info --stdin&lt;/code&gt; of &lt;code&gt;git update-index&lt;/code&gt; expects.</source>
          <target state="translated">这种输出格式是什么兼容 &lt;code&gt;--index-info --stdin&lt;/code&gt; 的 &lt;code&gt;git update-index&lt;/code&gt; 的期望。</target>
        </trans-unit>
        <trans-unit id="9b61a138f7f673e2e13a43bac58e20e6d27091cc" translate="yes" xml:space="preserve">
          <source>This outputs all the commit objects between the included and excluded commits, ordered by their distance to the included and excluded commits. Refs in &lt;code&gt;refs/bisect/&lt;/code&gt; are not used. The farthest from them is displayed first. (This is the only one displayed by &lt;code&gt;--bisect&lt;/code&gt;.)</source>
          <target state="translated">这将输出包含和排除提交之间的所有提交对象，并按它们到包含和排除提交的距离进行排序。未使用 &lt;code&gt;refs/bisect/&lt;/code&gt; 中的refs。离它们最远的位置将首先显示。（这是 &lt;code&gt;--bisect&lt;/code&gt; 显示的唯一一个。）</target>
        </trans-unit>
        <trans-unit id="c6b16b352aa83127a9d9220754dcd31555c3879e" translate="yes" xml:space="preserve">
          <source>This outputs something like this (the actual commit object names would be different)</source>
          <target state="translated">它的输出是这样的(实际的提交对象名称会有所不同</target>
        </trans-unit>
        <trans-unit id="05fcf2a461c52cf42967559d01dbd73ffe108135" translate="yes" xml:space="preserve">
          <source>This overrides a previous &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; setting and reads the default merge tool will be read from the configured &lt;code&gt;merge.tool&lt;/code&gt; variable.</source>
          <target state="translated">这将覆盖先前的 &lt;code&gt;-g&lt;/code&gt; 或 &lt;code&gt;--gui&lt;/code&gt; 设置，并从配置的 &lt;code&gt;merge.tool&lt;/code&gt; 变量中读取默认的合并工具。</target>
        </trans-unit>
        <trans-unit id="cf7619d964802ced013b07a7c34a4262a7e0e3f4" translate="yes" xml:space="preserve">
          <source>This page can be displayed with &lt;code&gt;git help help&lt;/code&gt; or &lt;code&gt;git help --help&lt;/code&gt;</source>
          <target state="translated">该页面可以显示 &lt;code&gt;git help help&lt;/code&gt; 或 &lt;code&gt;git help --help&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d990ef47ac594dcb10bc55890ec7a6963b3ffaed" translate="yes" xml:space="preserve">
          <source>This particular format is supplied as it&amp;rsquo;s short to implement and may be useful to a process that wants to create a new commit right now, without needing to use a working directory or &lt;code&gt;git update-index&lt;/code&gt;.</source>
          <target state="translated">提供这种特定格式是因为它的实现时间很短，它对于想要立即创建新提交的进程很有用，而无需使用工作目录或 &lt;code&gt;git update-index&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ace4cf0777df858ca1c6440d5cccb2ed6637934" translate="yes" xml:space="preserve">
          <source>This prints the name of a commit they are both based on. You should now look up the tree objects of those commits, which you can easily do with</source>
          <target state="translated">这将打印出它们都基于的提交的名称。现在您应该查找这些提交的树状对象,您可以使用</target>
        </trans-unit>
        <trans-unit id="65ce33f2a6f411ae54de75d77a4a5c5e2663fba3" translate="yes" xml:space="preserve">
          <source>This program computes which packs in your repository are redundant. The output is suitable for piping to &lt;code&gt;xargs rm&lt;/code&gt; if you are in the root of the repository.</source>
          <target state="translated">该程序计算存储库中的哪些包是多余的。如果您在存储库的根目录中，则该输出适合用于管道传输到 &lt;code&gt;xargs rm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dec60739fdc5804a4abedc6cf66847493211890" translate="yes" xml:space="preserve">
          <source>This program dumps the given revisions in a form suitable to be piped into &lt;code&gt;git fast-import&lt;/code&gt;.</source>
          <target state="translated">该程序将给定的修订版以适合管道传输到 &lt;code&gt;git fast-import&lt;/code&gt; 的形式转储。</target>
        </trans-unit>
        <trans-unit id="21943cdf9cd81593906492b86163eaa305da0be9" translate="yes" xml:space="preserve">
          <source>This program is usually not what the end user wants to run directly. Most end users want to use one of the existing frontend programs, which parses a specific type of foreign source and feeds the contents stored there to &lt;code&gt;git fast-import&lt;/code&gt;.</source>
          <target state="translated">该程序通常不是最终用户想要直接运行的程序。大多数最终用户都想使用现有的前端程序之一，该程序解析特定类型的外部源并将存储在那里的内容提供给 &lt;code&gt;git fast-import&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17acfb3fc2cc80c07ee41f3eeadca000eefd6ee0" translate="yes" xml:space="preserve">
          <source>This program searches the &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; for all objects that currently exist in a pack file as well as the independent object directories.</source>
          <target state="translated">该程序在 &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; 搜索包文件中当前存在的所有对象以及独立的对象目录。</target>
        </trans-unit>
        <trans-unit id="a85a25d731117b0f9fdffb50b50cd41a205c14dd" translate="yes" xml:space="preserve">
          <source>This public repository could further be mirrored, and that is how Git repositories at &lt;code&gt;kernel.org&lt;/code&gt; are managed.</source>
          <target state="translated">可以进一步镜像此公共存储库，这就是管理 &lt;code&gt;kernel.org&lt;/code&gt; 上的Git存储库的方式。</target>
        </trans-unit>
        <trans-unit id="3f74cf126c451b6a68e67763c97a8253f485453b" translate="yes" xml:space="preserve">
          <source>This puts a Git archive of the named CVS module in the directory &amp;lt;destination&amp;gt;, which will be created if necessary.</source>
          <target state="translated">这会将命名的CVS模块的Git存档放在目录&amp;lt;目标&amp;gt;中，该目录将在必要时创建。</target>
        </trans-unit>
        <trans-unit id="8831ce4f64ae931ef68e9c4eb0b8a48320fea478" translate="yes" xml:space="preserve">
          <source>This rebase can be performed using the &lt;code&gt;--rebase-merges&lt;/code&gt; option. It will generate a todo list looking like this:</source>
          <target state="translated">可以使用 &lt;code&gt;--rebase-merges&lt;/code&gt; 选项执行此重新设置。它将生成一个待办事项清单，如下所示：</target>
        </trans-unit>
        <trans-unit id="5e2dd779ca9f11c05d6bae58c7d8a031f404dc72" translate="yes" xml:space="preserve">
          <source>This ref is unchanged since the last import or fetch, although the helper cannot necessarily determine what value that produced.</source>
          <target state="translated">这个 ref 自上次导入或获取后没有变化,尽管帮助者不一定能确定产生了什么值。</target>
        </trans-unit>
        <trans-unit id="0e48a6f59fc5d06bf39a026582c3a2674a30ee86" translate="yes" xml:space="preserve">
          <source>This remote helper is transparently used by Git when you use commands such as &quot;git fetch &amp;lt;URL&amp;gt;&quot;, &quot;git clone &amp;lt;URL&amp;gt;&quot;, , &quot;git push &amp;lt;URL&amp;gt;&quot; or &quot;git remote add &amp;lt;nick&amp;gt; &amp;lt;URL&amp;gt;&quot;, where &amp;lt;URL&amp;gt; begins with &lt;code&gt;ext::&lt;/code&gt;. Examples:</source>
          <target state="translated">当您使用&amp;ldquo; git fetch &amp;lt;URL&amp;gt;&amp;rdquo;，&amp;ldquo; git clone &amp;lt;URL&amp;gt;&amp;rdquo;，&amp;ldquo; git push &amp;lt;URL&amp;gt;&amp;rdquo;或&amp;ldquo; git remote add &amp;lt;nick&amp;gt; &amp;lt;URL&amp;gt;&amp;rdquo;之类的命令时，Git会透明地使用此远程帮助器。 ，其中&amp;lt;URL&amp;gt;以 &lt;code&gt;ext::&lt;/code&gt; 开头。例子：</target>
        </trans-unit>
        <trans-unit id="76e69f76fb018209940d2bd178b055119cc99cef" translate="yes" xml:space="preserve">
          <source>This remote helper uses the specified &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; to connect to a remote Git server.</source>
          <target state="translated">该远程帮助程序使用指定的 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 连接到远程Git服务器。</target>
        </trans-unit>
        <trans-unit id="08f3058ad626936f077bcdb5101be9917b27eae0" translate="yes" xml:space="preserve">
          <source>This removes the &lt;code&gt;WIP&lt;/code&gt; commit from the commit history, and sets your working tree to the state just before you made that snapshot.</source>
          <target state="translated">这将从提交历史记录中删除 &lt;code&gt;WIP&lt;/code&gt; 提交，并将工作树设置为刚创建快照之前的状态。</target>
        </trans-unit>
        <trans-unit id="6cde691b95501235edce70baf30f3d475a6f05af" translate="yes" xml:space="preserve">
          <source>This removes the file from the index while keeping it in the working directory.</source>
          <target state="translated">这将从索引中删除文件,同时将其保留在工作目录中。</target>
        </trans-unit>
        <trans-unit id="f2e99bc05d5874bb5e940e93689126e6c4aa347e" translate="yes" xml:space="preserve">
          <source>This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the &lt;code&gt;recursive&lt;/code&gt; merge strategy.</source>
          <target state="translated">这样可以解析任意数量的head，但是合并的结果树始终是当前分支head的树，有效地忽略了所有其他分支的所有更改。它旨在取代侧支的旧开发历史。请注意，这与 &lt;code&gt;recursive&lt;/code&gt; 合并策略的-Xours选项不同。</target>
        </trans-unit>
        <trans-unit id="053dd73bd0ed92de95c5b132a1b4a0308f96cd04" translate="yes" xml:space="preserve">
          <source>This resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch.</source>
          <target state="translated">这可以解决两个以上头的情况,但拒绝做需要手动解决的复杂合并。它主要用于将主题分支头捆绑在一起。当拉取或合并多个分支时,这是默认的合并策略。</target>
        </trans-unit>
        <trans-unit id="e1337ea8d65ee53d09143c99f1f587dd31c2d238" translate="yes" xml:space="preserve">
          <source>This results in:</source>
          <target state="translated">这导致:</target>
        </trans-unit>
        <trans-unit id="a3acfff86d0ac3c7e1c1af7dc1decad57125efa5" translate="yes" xml:space="preserve">
          <source>This runs &lt;code&gt;git fsck --unreachable&lt;/code&gt; using all the refs available in &lt;code&gt;refs/&lt;/code&gt;, optionally with additional set of objects specified on the command line, and prunes all unpacked objects unreachable from any of these head objects from the object database. In addition, it prunes the unpacked objects that are also found in packs by running &lt;code&gt;git prune-packed&lt;/code&gt;. It also removes entries from .git/shallow that are not reachable by any ref.</source>
          <target state="translated">这将使用 &lt;code&gt;refs/&lt;/code&gt; 可用的所有ref 运行 &lt;code&gt;git fsck --unreachable&lt;/code&gt; ，还可以选择在命令行中指定其他对象集，并修剪所有从对象数据库中这些头对象中无法访问的所有未打包的对象。另外，它通过运行 &lt;code&gt;git prune-packed&lt;/code&gt; 来修剪在包中也可以找到的未打包对象。它还从.git / shallow中删除任何引用都无法访问的条目。</target>
        </trans-unit>
        <trans-unit id="66bb2cd044765c7338efb3b55d3b51e463e22970" translate="yes" xml:space="preserve">
          <source>This runs a virtual check-out and check-in of all three stages of a file when resolving a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See &quot;Merging branches with differing checkin/checkout attributes&quot; in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">解决三向合并时，这将对文件的所有三个阶段进行虚拟签出和签入。当合并具有不同原始过滤器或行尾规范化规则的分支时，应使用此选项。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]中的&lt;/a&gt; &amp;ldquo;合并具有不同签入/签出属性的分支&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="b3bd580b61f2b6d754a6c049f07ff919549d1439" translate="yes" xml:space="preserve">
          <source>This says &quot;include everything in root, but nothing two levels below root.&quot; If we then add the folder &lt;code&gt;A/B/C&lt;/code&gt; as a recursive pattern, the folders &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A/B&lt;/code&gt; are added as parent patterns. The resulting sparse-checkout file is now</source>
          <target state="translated">这表示&amp;ldquo;将所有内容都包含在根目录中，但不包括根目录下的两个级别&amp;rdquo;。如果随后将文件夹 &lt;code&gt;A/B/C&lt;/code&gt; 添加为递归模式，则文件夹 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;A/B&lt;/code&gt; 将作为父模式添加。现在生成的稀疏签出文件</target>
        </trans-unit>
        <trans-unit id="9f2fcd6a73ae4ce542d08fc5e7f799314e8e80fc" translate="yes" xml:space="preserve">
          <source>This script can be passed to &quot;git bisect run&quot; to find the commit that introduced a performance regression:</source>
          <target state="translated">这个脚本可以通过 &quot;git bisect run &quot;来找到引入性能回归的提交。</target>
        </trans-unit>
        <trans-unit id="72c86095923977328df35910b245e776428b840b" translate="yes" xml:space="preserve">
          <source>This script is included in various scripts to supply routines to parse files under $GIT_DIR/remotes/ and $GIT_DIR/branches/ and configuration variables that are related to fetching, pulling and pushing.</source>
          <target state="translated">这个脚本包含在各种脚本中,为解析$GIT_DIR/remotes/和$GIT_DIR/branches/下的文件提供例程,以及与取、拉、推相关的配置变量。</target>
        </trans-unit>
        <trans-unit id="a405ee4e7ff4cc67a738558081388543481850c0" translate="yes" xml:space="preserve">
          <source>This section can also be used by those who respond to &lt;code&gt;git
request-pull&lt;/code&gt; or pull-request on GitHub (www.github.com) to integrate the work of others into their history. A sub-area lieutenant for a repository will act both as a participant and as an integrator.</source>
          <target state="translated">响应GitHub（www.github.com）上的 &lt;code&gt;git request-pull&lt;/code&gt; 或pull-request 的人员也可以使用此部分，以将其他人的工作集成到他们的历史中。存储库的子区域副手将既充当参与者又充当集成者。</target>
        </trans-unit>
        <trans-unit id="53af582e47690e9820cb012bdcbccf97b8def7d3" translate="yes" xml:space="preserve">
          <source>This section explains how to configure some common webservers to run gitweb. In all cases, &lt;code&gt;/path/to/gitweb&lt;/code&gt; in the examples is the directory you ran installed gitweb in, and contains &lt;code&gt;gitweb_config.perl&lt;/code&gt;.</source>
          <target state="translated">本节说明如何配置一些常见的Web服务器以运行gitweb。在所有情况下，示例中的 &lt;code&gt;/path/to/gitweb&lt;/code&gt; 是您在其中安装gitweb的运行目录，其中包含 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79c0f1f15a38eae1b5cc2a5e381bfbc844ef9486" translate="yes" xml:space="preserve">
          <source>This section is only included if a packfile section is also included in the response.</source>
          <target state="translated">只有当响应中也包含Packfile部分时,才会包含这部分。</target>
        </trans-unit>
        <trans-unit id="f3cd5eb5a3885e012dabb05171cc566728c1791b" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git archive --remote&lt;/code&gt;. It is disabled by default, but a repository can enable it by setting &lt;code&gt;daemon.uploadarch&lt;/code&gt; configuration item to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这服务 &lt;code&gt;git archive --remote&lt;/code&gt; 。默认情况下禁用它，但是存储库可以通过将 &lt;code&gt;daemon.uploadarch&lt;/code&gt; 配置项设置为 &lt;code&gt;true&lt;/code&gt; 来启用它。</target>
        </trans-unit>
        <trans-unit id="a1fc9be9532fca80163bd11748e3553d0b5b85a4" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients. It is enabled by default, but a repository can disable it by setting &lt;code&gt;daemon.uploadpack&lt;/code&gt; configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">这为 &lt;code&gt;git fetch-pack&lt;/code&gt; 和 &lt;code&gt;git ls-remote&lt;/code&gt; 客户端提供服务。默认情况下启用它，但是存储库可以通过将 &lt;code&gt;daemon.uploadpack&lt;/code&gt; 配置项设置为 &lt;code&gt;false&lt;/code&gt; 来禁用它。</target>
        </trans-unit>
        <trans-unit id="ce507c3877f92fc6c1de609ca683d1e2a4e1b26f" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients. It is enabled by default, but a repository can disable it by setting this configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">这为 &lt;code&gt;git fetch-pack&lt;/code&gt; 和 &lt;code&gt;git ls-remote&lt;/code&gt; 客户端提供服务。默认情况下启用它，但是存储库可以通过将此配置项设置为 &lt;code&gt;false&lt;/code&gt; 来禁用它。</target>
        </trans-unit>
        <trans-unit id="f25bae0e6df9b1b4a76a588d485b17d422e56c18" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git send-pack&lt;/code&gt; clients, allowing anonymous push. It is disabled by default, as there is &lt;code&gt;no&lt;/code&gt; authentication in the protocol (in other words, anybody can push anything into the repository, including removal of refs). This is solely meant for a closed LAN setting where everybody is friendly. This service can be enabled by setting &lt;code&gt;daemon.receivepack&lt;/code&gt; configuration item to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这为 &lt;code&gt;git send-pack&lt;/code&gt; 客户端提供服务，允许匿名推送。默认情况下，它是禁用的，因为协议中 &lt;code&gt;no&lt;/code&gt; 身份验证（换句话说，任何人都可以将任何内容推送到存储库中，包括删除引用）。这仅适用于每个人都友好的封闭LAN设置。可以通过将 &lt;code&gt;daemon.receivepack&lt;/code&gt; 配置项设置为 &lt;code&gt;true&lt;/code&gt; 来启用此服务。</target>
        </trans-unit>
        <trans-unit id="6b2859849402fde4d51ffe73c129c97d00cb6083" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git send-pack&lt;/code&gt; clients, allowing push. It is disabled by default for anonymous users, and enabled by default for users authenticated by the web server. It can be disabled by setting this item to &lt;code&gt;false&lt;/code&gt;, or enabled for all users, including anonymous users, by setting it to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这为 &lt;code&gt;git send-pack&lt;/code&gt; 客户提供服务，允许推送。默认情况下，匿名用户禁用此功能，默认情况下，对于通过Web服务器认证的用户启用此功能。可以通过将此项目设置为 &lt;code&gt;false&lt;/code&gt; 来禁用它，或者通过将其设置为 &lt;code&gt;true&lt;/code&gt; 来为所有用户（包括匿名用户）启用。</target>
        </trans-unit>
        <trans-unit id="1d789007e515492a9cc42830b12a07ff1db6d084" translate="yes" xml:space="preserve">
          <source>This serves Git clients older than version 1.6.6 that are unable to use the upload pack service. When enabled, clients are able to read any file within the repository, including objects that are no longer reachable from a branch but are still present. It is enabled by default, but a repository can disable it by setting this configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">这为版本低于1.6.6的Git客户端提供服务，这些客户端无法使用上载包服务。启用后，客户端可以读取存储库中的任何文件，包括从分支不再可访问但仍然存在的对象。默认情况下启用它，但是存储库可以通过将此配置项设置为 &lt;code&gt;false&lt;/code&gt; 来禁用它。</target>
        </trans-unit>
        <trans-unit id="5456200c93d8963943eca093573a9d8938a4ea5f" translate="yes" xml:space="preserve">
          <source>This sets GIT_SVN_ID (instead of using the environment). This allows the user to override the default refname to fetch from when tracking a single URL. The &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;dcommit&lt;/code&gt; commands no longer require this switch as an argument.</source>
          <target state="translated">这将设置GIT_SVN_ID（而不是使用环境）。这允许用户在跟踪单个URL时覆盖要从中获取的默认refname。该 &lt;code&gt;log&lt;/code&gt; 和 &lt;code&gt;dcommit&lt;/code&gt; 命令不再需要这个开关作为参数。</target>
        </trans-unit>
        <trans-unit id="acb244d7aa46a820614aa10decb4464bc8ecabb6" translate="yes" xml:space="preserve">
          <source>This setting can be disabled by the &lt;code&gt;--no-notes&lt;/code&gt; option, overridden by the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable, and overridden by the &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt; option.</source>
          <target state="translated">可以通过 &lt;code&gt;--no-notes&lt;/code&gt; 选项禁用此设置，可以由 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 环境变量覆盖，而由 &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt; 选项覆盖。</target>
        </trans-unit>
        <trans-unit id="a8f435ef26eec94bd5c23846a74c0f4d57a87c8f" translate="yes" xml:space="preserve">
          <source>This setting can be overridden by passing the &lt;code&gt;--strategy&lt;/code&gt; option.</source>
          <target state="translated">可以通过传递 &lt;code&gt;--strategy&lt;/code&gt; 选项来覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="5d273f23cd160340c4f9b3fbc5a088c0fc2c32be" translate="yes" xml:space="preserve">
          <source>This setting can be overridden by the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable.</source>
          <target state="translated">可以通过 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 环境变量来覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="b28435a905552ea063d5203034696b428fdc0b87" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable, which must be a colon separated list of refs or globs.</source>
          <target state="translated">可以使用 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 环境变量来覆盖此设置，该环境变量必须是用冒号分隔的ref或glob列表。</target>
        </trans-unit>
        <trans-unit id="45473aa6b3903d5487aab6b473bcf528e266cdec" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_MODE&lt;/code&gt; environment variable.</source>
          <target state="translated">可以使用 &lt;code&gt;GIT_NOTES_REWRITE_MODE&lt;/code&gt; 环境变量来覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="39555b916eeeec115f6735665b5426bf964f4e52" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable, which must be a colon separated list of refs or globs.</source>
          <target state="translated">可以使用 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 环境变量来覆盖此设置，该环境变量必须是用冒号分隔的ref或glob列表。</target>
        </trans-unit>
        <trans-unit id="d17d74e5aa80b06bd416eb43f1c510767efc6dc8" translate="yes" xml:space="preserve">
          <source>This setting defaults to &quot;refs/notes/commits&quot;, and it can be overridden by the &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; environment variable. See &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;.</source>
          <target state="translated">此设置默认为&amp;ldquo; refs / notes / commits&amp;rdquo;，并且可以被 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 环境变量覆盖。参见&lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="843f7e48b1e3c030c426060d83a399e29388c249" translate="yes" xml:space="preserve">
          <source>This setting forces Git to normalize line endings for this file on checkin and convert them to CRLF when the file is checked out.</source>
          <target state="translated">这个设置会强制 Git 在签入时对该文件的行尾进行标准化处理,并在签出时将其转换为 CRLF。</target>
        </trans-unit>
        <trans-unit id="8c7bb001c250cfdf4247d252deb09b8b2c2a2839" translate="yes" xml:space="preserve">
          <source>This setting forces Git to normalize line endings to LF on checkin and prevents conversion to CRLF when the file is checked out.</source>
          <target state="translated">这个设置会强制 Git 在签入时将行尾规范化为 LF,并防止在签出时转换为 CRLF。</target>
        </trans-unit>
        <trans-unit id="886fc853da603148f91948f5793a0d1be70dc28a" translate="yes" xml:space="preserve">
          <source>This setting is automatically guessed by &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; when the repository was created. By default a repository that ends in &quot;/.git&quot; is assumed to be not bare (bare = false), while all other repositories are assumed to be bare (bare = true).</source>
          <target state="translated">创建存储库时，&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;或&lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt;会自动猜测此设置。默认情况下，以&amp;ldquo; /.git&amp;rdquo;结尾的存储库被假定为裸机（裸=假），而所有其他存储库被假定为裸机（裸= true）。</target>
        </trans-unit>
        <trans-unit id="a32da40367d476cb817ba2cfa99cb18bc04a7b3a" translate="yes" xml:space="preserve">
          <source>This setting overrides the default of the &lt;code&gt;--cleanup&lt;/code&gt; option in &lt;code&gt;git commit&lt;/code&gt;. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for details. Changing the default can be useful when you always want to keep lines that begin with comment character &lt;code&gt;#&lt;/code&gt; in your log message, in which case you would do &lt;code&gt;git config commit.cleanup whitespace&lt;/code&gt; (note that you will have to remove the help lines that begin with &lt;code&gt;#&lt;/code&gt; in the commit log template yourself, if you do this).</source>
          <target state="translated">此设置将覆盖 &lt;code&gt;git commit&lt;/code&gt; 中的 &lt;code&gt;--cleanup&lt;/code&gt; 选项的默认设置。有关详细信息，请参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;。当您始终希望在日志消息中保留以注释字符 &lt;code&gt;#&lt;/code&gt; 开头的行时，更改默认值会很有用，在这种情况下，您需要执行 &lt;code&gt;git config commit.cleanup whitespace&lt;/code&gt; （请注意，您必须删除以开头的帮助行 &lt;code&gt;#&lt;/code&gt; ，您自己可以在提交日志模板中）。</target>
        </trans-unit>
        <trans-unit id="e85001143ab4f6109a8db79b80d46592a3792b5e" translate="yes" xml:space="preserve">
          <source>This setting should be set to a comma-separated list of color and date settings, starting and ending with a color, the dates should be set from oldest to newest. The metadata will be colored given the colors if the line was introduced before the given timestamp, overwriting older timestamped colors.</source>
          <target state="translated">该设置应设置为以逗号分隔的颜色和日期设置列表,以颜色开始和结束,日期应从最旧到最新设置。如果该行是在给定时间戳之前引入的,元数据将被赋予颜色,覆盖较旧的时间戳颜色。</target>
        </trans-unit>
        <trans-unit id="1b39995bc064271da90ffd3401f4ace36766db6f" translate="yes" xml:space="preserve">
          <source>This setting writes a JSON-based format that is suited for machine interpretation. See &lt;code&gt;GIT_TRACE2&lt;/code&gt; for available trace output options and &lt;a href=&quot;api-trace2&quot;&gt;Trace2 documentation&lt;/a&gt; for full details.</source>
          <target state="translated">此设置将编写适合机器解释的基于JSON的格式。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE2&lt;/code&gt; ；有关完整的详细信息，请参见Trace2 &lt;a href=&quot;api-trace2&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d727921c238e28668ffb0dd7e4775077e3d6b368" translate="yes" xml:space="preserve">
          <source>This should be a colon-separated list of absolute paths. If set, it is a list of directories that Git should not chdir up into while looking for a repository directory (useful for excluding slow-loading network directories). It will not exclude the current working directory or a GIT_DIR set on the command line or in the environment. Normally, Git has to read the entries in this list and resolve any symlink that might be present in order to compare them with the current directory. However, if even this access is slow, you can add an empty entry to the list to tell Git that the subsequent entries are not symlinks and needn&amp;rsquo;t be resolved; e.g., &lt;code&gt;GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink&lt;/code&gt;.</source>
          <target state="translated">这应该是用冒号分隔的绝对路径列表。如果设置，则它是Git在查找存储库目录时不应该进入的目录列表（用于排除缓慢加载的网络目录）。它不会排除当前的工作目录或在命令行或环境中设置的GIT_DIR。通常，Git必须读取此列表中的条目并解析可能出现的任何符号链接，以便将它们与当前目录进行比较。但是，即使访问速度很慢，您也可以在列表中添加一个空条目，以告知Git后续条目不是符号链接，不需要解析；例如， &lt;code&gt;GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02391ad98329bedcf2ddfbe7ebdef774e4e7cc67" translate="yes" xml:space="preserve">
          <source>This should help you to submit patches inline using KMail.</source>
          <target state="translated">这应该可以帮助你使用KMail在线提交补丁。</target>
        </trans-unit>
        <trans-unit id="dc65a8c75ec971d079e04ac05264e8ee2fb908c8" translate="yes" xml:space="preserve">
          <source>This should make &quot;--pretty=oneline&quot; a whole lot more readable for people using 80-column terminals.</source>
          <target state="translated">这将使&quot;-pretty=oneline &quot;对于使用80列终端的人来说更加易读。</target>
        </trans-unit>
        <trans-unit id="cda899a68420b48633046b1cef20e4960b467a9e" translate="yes" xml:space="preserve">
          <source>This should make it easy to look up svn log messages when svn users refer to -r/--revision numbers.</source>
          <target state="translated">当svn用户参考-r/--revision号码时,这应该可以很容易地查找svn日志信息。</target>
        </trans-unit>
        <trans-unit id="3fce0b9f9a8369808848ec3f066c1735323bb111" translate="yes" xml:space="preserve">
          <source>This should not be confused with the &lt;code&gt;ours&lt;/code&gt; merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring &lt;code&gt;our&lt;/code&gt; history contains all that happened in it.</source>
          <target state="translated">这不应与 &lt;code&gt;ours&lt;/code&gt; 合并策略混淆，该策略甚至根本不看另一棵树包含的内容。它丢弃了另一棵树所做的一切，声明 &lt;code&gt;our&lt;/code&gt; 历史包含其中发生的所有事件。</target>
        </trans-unit>
        <trans-unit id="70d0ce2d7e7f48cdf303b28228ad271bde0b97ac" translate="yes" xml:space="preserve">
          <source>This shows that our resolved version deleted &quot;Hello world&quot; from the first parent, deleted &quot;Goodbye&quot; from the second parent, and added &quot;Goodbye world&quot;, which was previously absent from both.</source>
          <target state="translated">由此可见,我们的解决版删除了第一个父体中的 &quot;Hello world&quot;,删除了第二个父体中的 &quot;Goodbye&quot;,增加了之前两个父体都没有的 &quot;Goodbye world&quot;。</target>
        </trans-unit>
        <trans-unit id="e0fbc89a9eb1f686d88b41839c951cd18b86bf5e" translate="yes" xml:space="preserve">
          <source>This shows that you can do without a run script if you write the test on a single line.</source>
          <target state="translated">这说明,如果你把测试写在单行上,可以不用运行脚本。</target>
        </trans-unit>
        <trans-unit id="f580a082428b40358ee35f346bb87b38bbd6e3f8" translate="yes" xml:space="preserve">
          <source>This shows the change between HEAD and index (i.e. what will be committed if you say &lt;code&gt;git commit&lt;/code&gt;), and between index and working tree files (i.e. what you could stage further before &lt;code&gt;git commit&lt;/code&gt; using &lt;code&gt;git add&lt;/code&gt;) for each path. A sample output looks like this:</source>
          <target state="translated">这显示了每个路径的HEAD和index之间的变化（即，如果您说 &lt;code&gt;git commit&lt;/code&gt; ，将提交什么），以及索引和工作树文件之间的变化（即，您可以在使用 &lt;code&gt;git add&lt;/code&gt; 的 &lt;code&gt;git commit&lt;/code&gt; 之前进行进一步的转换）。示例输出如下所示：</target>
        </trans-unit>
        <trans-unit id="cdedf9c4235065dcc3b6a065543c259879fefa6b" translate="yes" xml:space="preserve">
          <source>This shows the files and directories to be deleted and issues an &quot;Input ignore patterns&amp;gt;&amp;gt;&quot; prompt. You can input space-separated patterns to exclude files and directories from deletion. E.g. &quot;*.c *.h&quot; will excludes files end with &quot;.c&quot; and &quot;.h&quot; from deletion. When you are satisfied with the filtered result, press ENTER (empty) back to the main menu.</source>
          <target state="translated">这显示了要删除的文件和目录，并发出&amp;ldquo;输入忽略模式&amp;gt;&amp;gt;&amp;rdquo;提示。您可以输入以空格分隔的模式，以从删除中排除文件和目录。例如，&amp;ldquo; *。c * .h&amp;rdquo;将删除以&amp;ldquo; .c&amp;rdquo;和&amp;ldquo; .h&amp;rdquo;结尾的文件。当您对过滤后的结果感到满意时，请按ENTER（空）回到主菜单。</target>
        </trans-unit>
        <trans-unit id="d76da1518821bfa115def32fd19d8e8b1e73d979" translate="yes" xml:space="preserve">
          <source>This shows the files and directories to be deleted and issues an &quot;Select items to delete&amp;gt;&amp;gt;&quot; prompt. When the prompt ends with double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; like this, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. &quot;2-5 7,9&quot; to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining items are selected. E.g. &quot;7-&quot; to choose 7,8,9 from the list. You can say &lt;code&gt;*&lt;/code&gt; to choose everything. Also when you are satisfied with the filtered result, press ENTER (empty) back to the main menu.</source>
          <target state="translated">这将显示要删除的文件和目录，并发出&amp;ldquo;选择要删除的项目&amp;gt;&amp;gt;&amp;rdquo;提示。当提示符以double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 这样结束时，您可以进行多个选择，并与空格或逗号连接。您也可以说范围。例如，&amp;ldquo; 2-5 7,9&amp;rdquo;从列表中选择2,3,4,5,7,9。如果省略范围中的第二个数字，则将选择所有剩余的项目。例如，&amp;ldquo; 7-&amp;rdquo;从列表中选择7,8,9。您可以说 &lt;code&gt;*&lt;/code&gt; 选择所有内容。同样，当您对过滤后的结果感到满意时，请按ENTER（空白）回到主菜单。</target>
        </trans-unit>
        <trans-unit id="53f59db63b45945049b0fe262d831991c1cb4a8d" translate="yes" xml:space="preserve">
          <source>This shows the status information and issues an &quot;Update&amp;gt;&amp;gt;&quot; prompt. When the prompt ends with double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. &quot;2-5 7,9&quot; to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining patches are taken. E.g. &quot;7-&quot; to choose 7,8,9 from the list. You can say &lt;code&gt;*&lt;/code&gt; to choose everything.</source>
          <target state="translated">这将显示状态信息并发出&amp;ldquo; Update &amp;gt;&amp;gt;&amp;rdquo;提示。当提示以双 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 结束时，您可以选择多个选项，并用空格或逗号连接。您也可以说范围。例如，&amp;ldquo; 2-5 7,9&amp;rdquo;从列表中选择2,3,4,5,7,9。如果忽略范围中的第二个数字，则会获取所有剩余的色块。例如，&amp;ldquo; 7-&amp;rdquo;从列表中选择7,8,9。您可以说 &lt;code&gt;*&lt;/code&gt; 选择所有内容。</target>
        </trans-unit>
        <trans-unit id="728eb7da1f0f1bff86889f4ac114a7967bd3817f" translate="yes" xml:space="preserve">
          <source>This snapshot is now stored in a temporary staging area which Git calls the &quot;index&quot;. You can permanently store the contents of the index in the repository with &lt;code&gt;git commit&lt;/code&gt;:</source>
          <target state="translated">现在，此快照存储在Git称为&amp;ldquo;索引&amp;rdquo;的临时登台区域中。您可以使用 &lt;code&gt;git commit&lt;/code&gt; 将索引的内容永久存储在存储库中：</target>
        </trans-unit>
        <trans-unit id="dfa3a419f48a4609a0668c69a143f543612e713a" translate="yes" xml:space="preserve">
          <source>This solution is not 100% bulletproof, in the sense that if some project has a named ref (branch, tag) starting with &lt;code&gt;git/&lt;/code&gt;, then paths such as</source>
          <target state="translated">从某种意义上说，如果某个项目具有以 &lt;code&gt;git/&lt;/code&gt; 开头的命名ref（分支，标签），则此解决方案不是100％防弹的</target>
        </trans-unit>
        <trans-unit id="02da975953020f9ebbe3388889e8a8406f05d0c7" translate="yes" xml:space="preserve">
          <source>This step and the next one could be combined into a single step with &quot;checkout -b my2.6.14 v2.6.14&quot;.</source>
          <target state="translated">这一步和下一步可以用 &quot;checkout -b my2.6.14 v2.6.14 &quot;合并成一个步骤。</target>
        </trans-unit>
        <trans-unit id="9b0b980e437fd3274de63464aa9184e42833d899" translate="yes" xml:space="preserve">
          <source>This suffix is also accepted when spelled in uppercase, and means the same thing no matter the case.</source>
          <target state="translated">这个后缀在拼成大写时也被接受,无论大小写都是一样的意思。</target>
        </trans-unit>
        <trans-unit id="01f381d8f83cae139b7e7ff06573574ebdbc8086" translate="yes" xml:space="preserve">
          <source>This supersedes the &lt;a href=&quot;#post-update&quot;&gt;&lt;em&gt;post-update&lt;/em&gt;&lt;/a&gt; hook in that it gets both old and new values of all the refs in addition to their names.</source>
          <target state="translated">这取代了&lt;a href=&quot;#post-update&quot;&gt;&lt;em&gt;更新后&lt;/em&gt;&lt;/a&gt;钩子，因为它除了获得所有引用的名称之外，还获取所有引用的旧值和新值。</target>
        </trans-unit>
        <trans-unit id="6339f7da558022ed0ae10f566dd01f30bb047e19" translate="yes" xml:space="preserve">
          <source>This synchronizes your public repository to match the named branch head (i.e. &lt;code&gt;master&lt;/code&gt; in this case) and objects reachable from them in your current repository.</source>
          <target state="translated">这将使您的公共存储库同步，以匹配命名的分支头（在这种情况下为 &lt;code&gt;master&lt;/code&gt; ）和在当前存储库中可从中访问的对象。</target>
        </trans-unit>
        <trans-unit id="0012e2584fc653cc03e6dda35ea11cbdc9f6c1a2" translate="yes" xml:space="preserve">
          <source>This syntax is only recognized if there are no slashes before the first colon. This helps differentiate a local path that contains a colon. For example the local path &lt;code&gt;foo:bar&lt;/code&gt; could be specified as an absolute path or &lt;code&gt;./foo:bar&lt;/code&gt; to avoid being misinterpreted as an ssh url.</source>
          <target state="translated">仅当第一个冒号之前没有斜杠时才能识别此语法。这有助于区分包含冒号的本地路径。例如，可以将本地路径 &lt;code&gt;foo:bar&lt;/code&gt; 指定为绝对路径，或者将 &lt;code&gt;./foo:bar&lt;/code&gt; 指定为避免被误解为ssh url。</target>
        </trans-unit>
        <trans-unit id="9f5d9872e03f1e6dd55415fa2249d9c84ea6f738" translate="yes" xml:space="preserve">
          <source>This takes a text file each of whose lines is a shell glob pattern. Filepairs that match a glob pattern on an earlier line in the file are output before ones that match a later line, and filepairs that do not match any glob pattern are output last.</source>
          <target state="translated">它接收一个文本文件,其每一行都是一个 shell glob 模式。匹配文件中较早一行的 glob 模式的文件对会在匹配较晚一行的文件对之前输出,不匹配任何 glob 模式的文件对会最后输出。</target>
        </trans-unit>
        <trans-unit id="b169549655fddd825e67d14c1591493d6ac0be03" translate="yes" xml:space="preserve">
          <source>This target is intended to be more of a summary (like GIT_TRACE) and less detailed than the other targets. It ignores thread, region, and data messages, for example.</source>
          <target state="translated">这个目标的目的是更多的是一个摘要(像GIT_TRACE),而不是像其他目标那样详细。例如,它忽略了线程、区域和数据消息。</target>
        </trans-unit>
        <trans-unit id="49bec15344e0cef74269dabec868d060f4c1b07d" translate="yes" xml:space="preserve">
          <source>This tells the bisect process that no commit after &lt;code&gt;v2.5&lt;/code&gt;, up to and including &lt;code&gt;v2.6&lt;/code&gt;, should be tested.</source>
          <target state="translated">这告诉bisect流程，在 &lt;code&gt;v2.5&lt;/code&gt; 之后（直到 &lt;code&gt;v2.6&lt;/code&gt; )（包括v2.6），不应该测试任何提交。</target>
        </trans-unit>
        <trans-unit id="1842bab1269e00a8bf77d06ee23570861225cc48" translate="yes" xml:space="preserve">
          <source>This tells the bisect process that the commits between &lt;code&gt;v2.5&lt;/code&gt; and &lt;code&gt;v2.6&lt;/code&gt; (inclusive) should be skipped.</source>
          <target state="translated">这告诉bisect进程应跳过 &lt;code&gt;v2.5&lt;/code&gt; 和 &lt;code&gt;v2.6&lt;/code&gt; （含）之间的提交。</target>
        </trans-unit>
        <trans-unit id="fb42c5eea9f7afe3662a07fd6af3c3105ab04e8f" translate="yes" xml:space="preserve">
          <source>This tells you that the immediately following version of the file was &quot;newsha&quot;, and that the immediately preceding version was &quot;oldsha&quot;. You also know the commit messages that went with the change from oldsha to 4b9458b and with the change from 4b9458b to newsha.</source>
          <target state="translated">这告诉你,紧接着文件的版本是 &quot;newsha&quot;,而之前的版本是 &quot;oldsha&quot;。你也知道从oldsha到4b9458b和从4b9458b到newsha的提交信息。</target>
        </trans-unit>
        <trans-unit id="8f1179423f3ea23a6c9e525ef159db41c1155b6a" translate="yes" xml:space="preserve">
          <source>This transformation is used to detect renames and copies, and is controlled by the -M option (to detect renames) and the -C option (to detect copies as well) to the &lt;code&gt;git diff-*&lt;/code&gt; commands. If the input contained these filepairs:</source>
          <target state="translated">此转换用于检测重命名和副本，并由 &lt;code&gt;git diff-*&lt;/code&gt; 命令的-M选项（用于检测重命名）和-C选项（也用于检测副本）控制。如果输入包含以下文件对：</target>
        </trans-unit>
        <trans-unit id="573190bccf8f2a4ea6fc33eedd23b4b8fc3f90f8" translate="yes" xml:space="preserve">
          <source>This transformation is used to merge filepairs broken by diffcore-break, and not transformed into rename/copy by diffcore-rename, back into a single modification. This always runs when diffcore-break is used.</source>
          <target state="translated">这个转换用于将被 diffcore-break 打断的文件对,以及没有被 diffcore-rename 转化为 rename/copy 的文件对,合并为一个修改。当使用diffcore-break时,这个转换总是会运行。</target>
        </trans-unit>
        <trans-unit id="448726c2164ad1aa28f4d84dcd657bc466764287" translate="yes" xml:space="preserve">
          <source>This transformation limits the set of filepairs to those that change specified strings between the preimage and the postimage in a certain way. -S&amp;lt;block of text&amp;gt; and -G&amp;lt;regular expression&amp;gt; options are used to specify different ways these strings are sought.</source>
          <target state="translated">这种转换将文件对的集合限制为以某种方式更改前映像和后映像之间的指定字符串的文件对。-S &amp;lt;文本块&amp;gt;和-G &amp;lt;正则表达式&amp;gt;选项用于指定搜索这些字符串的不同方式。</target>
        </trans-unit>
        <trans-unit id="eb01f7c28a2e42a179d9ca76727e0a7db6bb8dce" translate="yes" xml:space="preserve">
          <source>This transport can be used for both uploading and downloading, and requires you to have a log-in privilege over &lt;code&gt;ssh&lt;/code&gt; to the remote machine. It finds out the set of objects the other side lacks by exchanging the head commits both ends have and transfers (close to) minimum set of objects. It is by far the most efficient way to exchange Git objects between repositories.</source>
          <target state="translated">此传输可用于上载和下载，并且要求您具有通过 &lt;code&gt;ssh&lt;/code&gt; 登录到远程计算机的登录特权。它通过交换两端的头提交并转移（接近）最小对象集来找出另一侧缺少的对象集。到目前为止，这是在存储库之间交换Git对象的最有效方法。</target>
        </trans-unit>
        <trans-unit id="1e93313475dc2966a9b364d25d3e63ddb92cd35d" translate="yes" xml:space="preserve">
          <source>This transport is the same as SSH transport but uses &lt;code&gt;sh&lt;/code&gt; to run both ends on the local machine instead of running other end on the remote machine via &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">此传输与SSH传输相同，但是使用 &lt;code&gt;sh&lt;/code&gt; 在本地计算机上运行两端，而不是通过 &lt;code&gt;ssh&lt;/code&gt; 在远程计算机上运行另一端。</target>
        </trans-unit>
        <trans-unit id="187c060b77919e40b0db07be6c4444d6bedf0f1f" translate="yes" xml:space="preserve">
          <source>This transport was designed for anonymous downloading. Like SSH transport, it finds out the set of objects the downstream side lacks and transfers (close to) minimum set of objects.</source>
          <target state="translated">这种传输是为匿名下载设计的。像SSH传输一样,它找出下游方缺少的对象集,并传输(接近)最小对象集。</target>
        </trans-unit>
        <trans-unit id="a843c4941e9eb68216876c91a59842ae7d058faa" translate="yes" xml:space="preserve">
          <source>This tutorial explains how to import a new project into Git, make changes to it, and share changes with other developers.</source>
          <target state="translated">本教程介绍了如何将一个新项目导入Git,对其进行修改,并与其他开发者分享修改。</target>
        </trans-unit>
        <trans-unit id="586b98337ae35b657ccc9687b72106b49b3b174b" translate="yes" xml:space="preserve">
          <source>This tutorial explains how to use the &quot;core&quot; Git commands to set up and work with a Git repository.</source>
          <target state="translated">本教程将介绍如何使用 &quot;核心 &quot;Git命令来设置和使用Git仓库。</target>
        </trans-unit>
        <trans-unit id="4f3b7287fc4739a451de38537fb0637003a134c1" translate="yes" xml:space="preserve">
          <source>This tutorial should be enough to perform basic distributed revision control for your projects. However, to fully understand the depth and power of Git you need to understand two simple ideas on which it is based:</source>
          <target state="translated">这篇教程应该足以让你对项目进行基本的分布式修订控制。然而,要想充分理解 Git 的深度和威力,你需要了解它所基于的两个简单的理念。</target>
        </trans-unit>
        <trans-unit id="50b7797bad77b49520127714ff8a716873aad978" translate="yes" xml:space="preserve">
          <source>This updates (or creates, as necessary) branches &lt;code&gt;pu&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt; in the local repository by fetching from the branches (respectively) &lt;code&gt;pu&lt;/code&gt; and &lt;code&gt;maint&lt;/code&gt; from the remote repository.</source>
          <target state="translated">通过从远程存储库中的 &lt;code&gt;pu&lt;/code&gt; 和 &lt;code&gt;maint&lt;/code&gt; 分别获取分支，从而更新（或根据需要创建）本地存储库中的 &lt;code&gt;pu&lt;/code&gt; 和 &lt;code&gt;tmp&lt;/code&gt; 分支。</target>
        </trans-unit>
        <trans-unit id="70ac0b727096d7231e8fdcdd112d1a04551c8ca8" translate="yes" xml:space="preserve">
          <source>This used to be the default, but not since Git 2.0 (&lt;code&gt;simple&lt;/code&gt; is the new default).</source>
          <target state="translated">这曾经是默认设置，但自Git 2.0起就没有了（ &lt;code&gt;simple&lt;/code&gt; 是新的默认设置）。</target>
        </trans-unit>
        <trans-unit id="fd75f35034e73b98112aaaf4198ee488b9e51804" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;--interactive&lt;/code&gt; machinery internally, but combining it with the &lt;code&gt;--interactive&lt;/code&gt; option explicitly is generally not a good idea unless you know what you are doing (see BUGS below).</source>
          <target state="translated">这在内部使用 &lt;code&gt;--interactive&lt;/code&gt; 机制，但是除非明确知道您在做什么，否则将它与 &lt;code&gt;--interactive&lt;/code&gt; 选项显式结合通常不是一个好主意（请参阅下面的BUGS）。</target>
        </trans-unit>
        <trans-unit id="665eaff82148d49a545a97a7903a8bf0d3754608" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;--interactive&lt;/code&gt; machinery internally, but it can be run without an explicit &lt;code&gt;--interactive&lt;/code&gt;.</source>
          <target state="translated">这在内部使用 &lt;code&gt;--interactive&lt;/code&gt; 机制，但无需显式 &lt;code&gt;--interactive&lt;/code&gt; 即可运行。</target>
        </trans-unit>
        <trans-unit id="5a59444b879ae5151f30b1cffe08974240ac7bdc" translate="yes" xml:space="preserve">
          <source>This uses the same two-dot range notation we saw earlier with &lt;code&gt;git log&lt;/code&gt;.</source>
          <target state="translated">这使用了我们之前在 &lt;code&gt;git log&lt;/code&gt; 中看到的相同的两点范围符号。</target>
        </trans-unit>
        <trans-unit id="94dc29f5a82c88ac8ea06389eebe7535e89a6fb1" translate="yes" xml:space="preserve">
          <source>This value is true by default in a repository that has a working directory associated with it, and false by default in a bare repository.</source>
          <target state="translated">这个值在有工作目录的版本库中默认为true,在裸版本库中默认为false。</target>
        </trans-unit>
        <trans-unit id="73a34f84ecc165ae3643b28ecca4c6c41f197412" translate="yes" xml:space="preserve">
          <source>This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value &quot;user&quot; indicates that the archiving user&amp;rsquo;s umask will be used instead. See umask(2) and &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt;.</source>
          <target state="translated">此变量可用于限制tar归档条目的权限位。默认值为0002，它将关闭世界写入位。特殊值&amp;ldquo; user&amp;rdquo;指示将改为使用归档用户的umask。参见umask（2）和&lt;a href=&quot;git-archive&quot;&gt;git-archive [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63a384d932515032afb2060852ce18cd5598c9ca" translate="yes" xml:space="preserve">
          <source>This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value &quot;user&quot; indicates that the archiving user&amp;rsquo;s umask will be used instead. See umask(2) for details. If &lt;code&gt;--remote&lt;/code&gt; is used then only the configuration of the remote repository takes effect.</source>
          <target state="translated">此变量可用于限制tar归档条目的权限位。默认值为0002，它将关闭世界写入位。特殊值&amp;ldquo; user&amp;rdquo;指示将改为使用归档用户的umask。有关详细信息，请参见umask（2）。如果使用 &lt;code&gt;--remote&lt;/code&gt; ，则仅远程存储库的配置生效。</target>
        </trans-unit>
        <trans-unit id="0afce327e7d4311118de1c5dc2faa8fa7a291053" translate="yes" xml:space="preserve">
          <source>This variable controls the event target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">此变量控制事件目标的目的地。它可以被 &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; 环境变量覆盖。下表显示了可能的值。</target>
        </trans-unit>
        <trans-unit id="b3073c2a2c3930628fae47eb515e2fe5729910f0" translate="yes" xml:space="preserve">
          <source>This variable controls the normal target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">此变量控制正常的目标位置。它可以被 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 环境变量覆盖。下表显示了可能的值。</target>
        </trans-unit>
        <trans-unit id="ab644894061fa15fc115b6d355d07c2965277303" translate="yes" xml:space="preserve">
          <source>This variable controls the performance target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">此变量控制性能目标。它可以被 &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; 环境变量覆盖。下表显示了可能的值。</target>
        </trans-unit>
        <trans-unit id="53008d90e6aae985c2e7839a77d7b54894ce429e" translate="yes" xml:space="preserve">
          <source>This variable controls the sort ordering of branches when displayed by &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;. Without the &quot;--sort=&amp;lt;value&amp;gt;&quot; option provided, the value of this variable will be used as the default. See &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt; field names for valid values.</source>
          <target state="translated">当由&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;显示时，此变量控制分支的排序顺序。如果不提供&amp;ldquo; --sort = &amp;lt;值&amp;gt;&amp;rdquo;选项，则此变量的值将用作默认值。有关有效值，请参见&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt;字段名称。</target>
        </trans-unit>
        <trans-unit id="ea1c7eb75a360c1f9f69915dbc32e427ddfb7ced" translate="yes" xml:space="preserve">
          <source>This variable controls the sort ordering of tags when displayed by &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;. Without the &quot;--sort=&amp;lt;value&amp;gt;&quot; option provided, the value of this variable will be used as the default.</source>
          <target state="translated">当由&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;显示时，此变量控制标签的排序顺序。如果不提供&amp;ldquo; --sort = &amp;lt;值&amp;gt;&amp;rdquo;选项，则此变量的值将用作默认值。</target>
        </trans-unit>
        <trans-unit id="c2680b6925a4a160ca8f3fee892cc23ec9be5f4f" translate="yes" xml:space="preserve">
          <source>This variable determines the default value for variables such as &lt;code&gt;color.diff&lt;/code&gt; and &lt;code&gt;color.grep&lt;/code&gt; that control the use of color per command family. Its scope will expand as more commands learn configuration to set a default for the &lt;code&gt;--color&lt;/code&gt; option. Set it to &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;never&lt;/code&gt; if you prefer Git commands not to use color unless enabled explicitly with some other configuration or the &lt;code&gt;--color&lt;/code&gt; option. Set it to &lt;code&gt;always&lt;/code&gt; if you want all output not intended for machine consumption to use color, to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt; (this is the default since Git 1.8.4) if you want such output to use color when written to the terminal.</source>
          <target state="translated">此变量确定诸如 &lt;code&gt;color.diff&lt;/code&gt; 和 &lt;code&gt;color.grep&lt;/code&gt; 之类的变量的默认值，这些变量控制每个命令系列对颜色的使用。随着更多命令学习配置以设置 &lt;code&gt;--color&lt;/code&gt; 选项的默认值，其范围将扩大。如果您不希望Git命令不使用颜色，除非将其与其他配置或 &lt;code&gt;--color&lt;/code&gt; 选项一起显式启用，否则将其设置为 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;never&lt;/code&gt; 设置颜色。将其设置为 &lt;code&gt;always&lt;/code&gt; ，如果你想不用于机器消耗的用色，所有输出 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;auto&lt;/code&gt; ，如果你想这样的输出使用的颜色，当写入到终端（这是因为Git的1.8.4默认值）。</target>
        </trans-unit>
        <trans-unit id="2eb6f1e33d90fc7fb4373fa1793932292fbc650d" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;transfer.hideRefs&lt;/code&gt;, but applies only to &lt;code&gt;receive-pack&lt;/code&gt; (and so affects pushes, but not fetches). An attempt to update or delete a hidden ref by &lt;code&gt;git push&lt;/code&gt; is rejected.</source>
          <target state="translated">此变量与 &lt;code&gt;transfer.hideRefs&lt;/code&gt; 相同，但仅适用于 &lt;code&gt;receive-pack&lt;/code&gt; （因此影响推送，但不影响提取）。拒绝通过 &lt;code&gt;git push&lt;/code&gt; 更新或删除隐藏引用的尝试。</target>
        </trans-unit>
        <trans-unit id="763a368531eb9d8bc40e93c6334e049f21620c45" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;transfer.hideRefs&lt;/code&gt;, but applies only to &lt;code&gt;upload-pack&lt;/code&gt; (and so affects only fetches, not pushes). An attempt to fetch a hidden ref by &lt;code&gt;git fetch&lt;/code&gt; will fail. See also &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt;.</source>
          <target state="translated">此变量与 &lt;code&gt;transfer.hideRefs&lt;/code&gt; 相同，但仅适用于 &lt;code&gt;upload-pack&lt;/code&gt; （因此仅影响提取，不影响推送）。尝试通过 &lt;code&gt;git fetch&lt;/code&gt; 提取隐藏的引用将失败。另请参见 &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75aa35a44ffd767e8a239dc01347d150ce1e39ed" translate="yes" xml:space="preserve">
          <source>This variable matters only when using persistent web environments that serve multiple requests using single gitweb instance, like mod_perl, FastCGI or Plackup.</source>
          <target state="translated">这个变量只有在使用持久化的网络环境,如mod_perl、FastCGI或Plackup,使用单个gitweb实例来服务多个请求时才有意义。</target>
        </trans-unit>
        <trans-unit id="c0526214b5c55d639fefd6a92d93b97ec2455930" translate="yes" xml:space="preserve">
          <source>This variable specifies a shell command through which the tar output generated by &lt;code&gt;git archive&lt;/code&gt; should be piped. The command is executed using the shell with the generated tar file on its standard input, and should produce the final output on its standard output. Any compression-level options will be passed to the command (e.g., &quot;-9&quot;). An output file with the same extension as &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; will be use this format if no other format is given.</source>
          <target state="translated">该变量指定一个shell命令，通过该命令可以将 &lt;code&gt;git archive&lt;/code&gt; 生成的tar输出通过管道传输。该命令是使用Shell执行的，其标准输入上带有生成的tar文件，并且应在其标准输出上生成最终输出。任何压缩级别的选项都将传递给命令（例如&amp;ldquo; -9&amp;rdquo;）。如果未指定其他格式，则扩展名与 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 相同的输出文件将使用此格式。</target>
        </trans-unit>
        <trans-unit id="99ffcf0d1fc58b3934082bac9786637cf3a8cdad" translate="yes" xml:space="preserve">
          <source>This view is similar to &lt;code&gt;shortlog&lt;/code&gt; view.</source>
          <target state="translated">该视图类似于 &lt;code&gt;shortlog&lt;/code&gt; 视图。</target>
        </trans-unit>
        <trans-unit id="16ae6576174eeb48325f0bfa3042bcb20d29d417" translate="yes" xml:space="preserve">
          <source>This was not the case in the initial release of this feature in v2.13.0, which only matched the realpath version. Configuration that wants to be compatible with the initial release of this feature needs to either specify only the realpath version, or both versions.</source>
          <target state="translated">这个功能在v2.13.0的初始版本中并不是这样的,它只匹配realpath版本。想要与该功能初始版本兼容的配置,需要只指定realpath版本,或者两个版本都指定。</target>
        </trans-unit>
        <trans-unit id="7c8d457b197b5558b7abfe068bcd1974205f94ad" translate="yes" xml:space="preserve">
          <source>This was optional in prior versions of git, but now it is the default. You can use &lt;code&gt;--no-utf8&lt;/code&gt; to override this.</source>
          <target state="translated">这在以前的git版本中是可选的，但现在是默认设置。您可以使用 &lt;code&gt;--no-utf8&lt;/code&gt; 覆盖它。</target>
        </trans-unit>
        <trans-unit id="314df942d006c94c85d3e8c8bfe0a0b8ef8308d1" translate="yes" xml:space="preserve">
          <source>This will again prompt you for a message describing the change, and then record a new version of the project.</source>
          <target state="translated">这将再次提示你输入描述更改的信息,然后记录项目的新版本。</target>
        </trans-unit>
        <trans-unit id="53cca56aaa41c3093032e1d720cb620b22717e06" translate="yes" xml:space="preserve">
          <source>This will cache the result of running &quot;exif&quot; on each blob indefinitely. If you change the textconv config variable for a diff driver, Git will automatically invalidate the cache entries and re-run the textconv filter. If you want to invalidate the cache manually (e.g., because your version of &quot;exif&quot; was updated and now produces better output), you can remove the cache manually with &lt;code&gt;git update-ref -d refs/notes/textconv/jpg&lt;/code&gt; (where &quot;jpg&quot; is the name of the diff driver, as in the example above).</source>
          <target state="translated">这将无限期地缓存在每个Blob上运行&amp;ldquo; exif&amp;rdquo;的结果。如果您更改了diff驱动程序的textconv配置变量，Git将自动使缓存条目无效并重新运行textconv过滤器。如果您想手动使缓存无效（例如，因为您的&amp;ldquo; exif&amp;rdquo;版本已更新，现在可以产生更好的输出），则可以使用 &lt;code&gt;git update-ref -d refs/notes/textconv/jpg&lt;/code&gt; （其中&amp;ldquo; jpg&amp;rdquo;是差异驱动程序的名称，如上例所示。</target>
        </trans-unit>
        <trans-unit id="3d17cc7dd2b4aac7e00ecd2628dbb99eefd074c7" translate="yes" xml:space="preserve">
          <source>This will cause Git to generate &lt;code&gt;Binary files differ&lt;/code&gt; (or a binary patch, if binary patches are enabled) instead of a regular diff.</source>
          <target state="translated">这将导致Git生成 &lt;code&gt;Binary files differ&lt;/code&gt; 常规差异的Binary文件（或二进制补丁，如果启用了二进制补丁）。</target>
        </trans-unit>
        <trans-unit id="dac66330b2bd98fcf90352c4cbeba694c8f4feb3" translate="yes" xml:space="preserve">
          <source>This will check out the currently cached copy of &lt;code&gt;Makefile&lt;/code&gt; into the file &lt;code&gt;.merged-Makefile&lt;/code&gt;.</source>
          <target state="translated">这会将当前缓存的 &lt;code&gt;Makefile&lt;/code&gt; 副本 &lt;code&gt;.merged-Makefile&lt;/code&gt; 到文件.merged-Makefile中。</target>
        </trans-unit>
        <trans-unit id="9acb73cd9d17d8ef0d5dfd6af35ea9d0a50c12ab" translate="yes" xml:space="preserve">
          <source>This will create a new commit which undoes the change in HEAD. You will be given a chance to edit the commit message for the new commit.</source>
          <target state="translated">这将创建一个新的提交,撤销对 HEAD 的修改。您将有机会编辑新提交的提交信息。</target>
        </trans-unit>
        <trans-unit id="85437cd96f5cff3dd194d542498fd954d1bf1e01" translate="yes" xml:space="preserve">
          <source>This will define a remote called &quot;origin&quot; in the resulting repository that lets you fetch and pull from the bundle. The $GIT_DIR/config file in R2 will have an entry like this:</source>
          <target state="translated">这将在生成的版本库中定义一个名为 &quot;origin &quot;的远程,让你从捆绑包中获取和拉取。在R2的$GIT_DIR/config文件中会有这样的条目。</target>
        </trans-unit>
        <trans-unit id="2986121c6e711f05b2ed0ba772dedbd8c66503ff" translate="yes" xml:space="preserve">
          <source>This will error out if $REV is empty or not a valid revision.</source>
          <target state="translated">如果$REV为空或不是一个有效的版本,这将会出错。</target>
        </trans-unit>
        <trans-unit id="c8b7e8566771f37a03bc25eaec95675ffe82ba31" translate="yes" xml:space="preserve">
          <source>This will export the whole repository and import it into the existing empty repository. Except for reencoding commits that are not in UTF-8, it would be a one-to-one mirror.</source>
          <target state="translated">这将导出整个版本库,并将其导入到现有的空版本库中。除了重新编码非 UTF-8 的提交,这将是一个一对一的镜像。</target>
        </trans-unit>
        <trans-unit id="5f851e29f67384fe2f487309701055635453a02c" translate="yes" xml:space="preserve">
          <source>This will list what commits you must have in order to extract from the bundle and will error out if you do not have them.</source>
          <target state="translated">这将列出你必须有哪些提交才能从 bundle 中提取,如果你没有这些提交,就会出错。</target>
        </trans-unit>
        <trans-unit id="7ed8616207d4b6e51bdcbe1e7b524863a0139782" translate="yes" xml:space="preserve">
          <source>This will open your editor with a list of steps to be taken to perform your rebase.</source>
          <target state="translated">这将打开你的编辑器,并列出执行你的重垒的步骤。</target>
        </trans-unit>
        <trans-unit id="e9e68cbb3d1c11da9ad7575ebecc630d58996f10" translate="yes" xml:space="preserve">
          <source>This will prompt you for a commit message. You&amp;rsquo;ve now stored the first version of your project in Git.</source>
          <target state="translated">这将提示您输入提交消息。现在，您已将项目的第一个版本存储在Git中。</target>
        </trans-unit>
        <trans-unit id="9229da0c83ee0b71f5a22085b5f3b7e07e9ec55a" translate="yes" xml:space="preserve">
          <source>This will remove each of your commits from mywork, temporarily saving them as patches (in a directory named &lt;code&gt;.git/rebase-apply&lt;/code&gt;), update mywork to point at the latest version of origin, then apply each of the saved patches to the new mywork. The result will look like:</source>
          <target state="translated">这将从mywork中删除您的每个提交，将它们临时保存为补丁（在名为 &lt;code&gt;.git/rebase-apply&lt;/code&gt; 的目录中），更新mywork以指向最新的原始版本，然后将每个保存的补丁应用于新的mywork 。结果将如下所示：</target>
        </trans-unit>
        <trans-unit id="1c98be5284d00528a6b74a33ba778d044a767668" translate="yes" xml:space="preserve">
          <source>This will result in only b (a and c are cleared).</source>
          <target state="translated">这将导致只有b(a和c被清除)。</target>
        </trans-unit>
        <trans-unit id="0385ed25689cd3e1167020ff6e8ba549d1603871" translate="yes" xml:space="preserve">
          <source>This will set the property &lt;code&gt;svn:keywords&lt;/code&gt; to &lt;code&gt;FreeBSD=%H&lt;/code&gt; for the file &lt;code&gt;devel/py-tipper/Makefile&lt;/code&gt;.</source>
          <target state="translated">这会将文件 &lt;code&gt;devel/py-tipper/Makefile&lt;/code&gt; 的 &lt;code&gt;svn:keywords&lt;/code&gt; 属性设置为 &lt;code&gt;FreeBSD=%H&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61383e31770f578e5ee86310440dccd09a4e5008" translate="yes" xml:space="preserve">
          <source>This will show &quot;refs/heads/master&quot; but also &quot;refs/remote/other-repo/master&quot;, if such references exists.</source>
          <target state="translated">这将显示 &quot;refs/heads/master&quot;,但也会显示 &quot;refs/remote/other-repo/master&quot;,如果存在这样的引用的话。</target>
        </trans-unit>
        <trans-unit id="23dd2de32c54566f1df1adf9f6794600102b9c2b" translate="yes" xml:space="preserve">
          <source>This will start to clean, and you must confirm one by one in order to delete items. Please note that this action is not as efficient as the above two actions.</source>
          <target state="translated">这样就会开始清理,必须逐一确认才能删除项目。请注意,这个动作的效率不如以上两个动作。</target>
        </trans-unit>
        <trans-unit id="9b7bbd24afc1c6a470a80ef47d5171b33809ea28" translate="yes" xml:space="preserve">
          <source>This works for any of the supported update procedures (&lt;code&gt;--checkout&lt;/code&gt;, &lt;code&gt;--rebase&lt;/code&gt;, etc.). The only change is the source of the target SHA-1. For example, &lt;code&gt;submodule update --remote --merge&lt;/code&gt; will merge upstream submodule changes into the submodules, while &lt;code&gt;submodule update
--merge&lt;/code&gt; will merge superproject gitlink changes into the submodules.</source>
          <target state="translated">这适用于任何受支持的更新过程（ &lt;code&gt;--checkout&lt;/code&gt; ，-- &lt;code&gt;--rebase&lt;/code&gt; 等）。唯一的变化是目标SHA-1的来源。例如， &lt;code&gt;submodule update --remote --merge&lt;/code&gt; 将上游子模块更改合并到子模块中，而 &lt;code&gt;submodule update --merge&lt;/code&gt; 将超级项目gitlink更改合并到子模块中。</target>
        </trans-unit>
        <trans-unit id="5a2ee7840b76b59e3aede30738fb578b292bc5f3" translate="yes" xml:space="preserve">
          <source>This works similarly to &lt;code&gt;svn update&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt; except that it preserves linear history with &lt;code&gt;git rebase&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt; for ease of dcommitting with &lt;code&gt;git svn&lt;/code&gt;.</source>
          <target state="translated">这与 &lt;code&gt;svn update&lt;/code&gt; 或 &lt;code&gt;git pull&lt;/code&gt; 相似，除了它使用 &lt;code&gt;git rebase&lt;/code&gt; 而不是 &lt;code&gt;git merge&lt;/code&gt; 保留线性历史记录，以便于 &lt;code&gt;git svn&lt;/code&gt; 提交。</target>
        </trans-unit>
        <trans-unit id="5bc6c0e59c3e651570d66e12101e9a57040fd659" translate="yes" xml:space="preserve">
          <source>This would leave only one merge commit when your topic branch is finally ready and merged into the master branch. This merge would require you to resolve the conflict, introduced by the commits marked with &lt;code&gt;*&lt;/code&gt;. However, this conflict is often the same conflict you resolved when you created the test merge you blew away. &lt;code&gt;git rerere&lt;/code&gt; helps you resolve this final conflicted merge using the information from your earlier hand resolve.</source>
          <target state="translated">当您的主题分支最终准备好并合并到master分支中时，这将只留下一个合并提交。这种合并将需要您解决由 &lt;code&gt;*&lt;/code&gt; 标记的提交引起的冲突。但是，此冲突通常与您创建的测试合并所消除的冲突相同。 &lt;code&gt;git rerere&lt;/code&gt; 帮助您使用较早的手动解决方法中的信息来解决此最终冲突的合并。</target>
        </trans-unit>
        <trans-unit id="dcd6f908de988995d9fff4cafd75d14bc0785c1a" translate="yes" xml:space="preserve">
          <source>This would leave the merge result in &lt;code&gt;hello.c~2&lt;/code&gt; file, along with conflict markers if there are conflicts. After verifying the merge result makes sense, you can tell Git what the final merge result for this file is by:</source>
          <target state="translated">如果存在冲突，这会将合并结果以及冲突标记保留在 &lt;code&gt;hello.c~2&lt;/code&gt; 文件中。验证合并结果有意义之后，可以通过以下方式告诉Git该文件的最终合并结果是什么：</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="ee3cacca7314105556d3050112f523980e59f973" translate="yes" xml:space="preserve">
          <source>Those snapshots aren&amp;rsquo;t necessarily all arranged in a single line from oldest to newest; instead, work may simultaneously proceed along parallel lines of development, called &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;, which may merge and diverge.</source>
          <target state="translated">这些快照不必从最旧到最新全部排列在一行中。取而代之的是，工作可以同时沿着并行的发展路线（称为&lt;a href=&quot;#def_branch&quot;&gt;分支）进行&lt;/a&gt;，分支可以合并和发散。</target>
        </trans-unit>
        <trans-unit id="7a5a53a50d0fbac4f3a27d9d2d5853146557d940" translate="yes" xml:space="preserve">
          <source>Though not required, it&amp;rsquo;s a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.</source>
          <target state="translated">尽管不是必需的，但最好以一条简短的（少于50个字符的）短行来概述所有更改，然后是空行，再进行更详尽的描述，以开始提交消息。直到提交消息中的第一行空白为止的文本都被视为提交标题，并且该标题在整个Git中都使用。例如，&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;将提交转换为电子邮件，并在主题行上使用标题，在正文中使用其余提交。</target>
        </trans-unit>
        <trans-unit id="fdd6ea0498f5dbe48e6926bc8c91e77146fa2184" translate="yes" xml:space="preserve">
          <source>Though, according to Wikipedia &lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt;:</source>
          <target state="translated">不过，根据维基百科&lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="18c9e3ce5bbbf77af11ba41f4d7a7d9b7a1aaa55" translate="yes" xml:space="preserve">
          <source>Thread Events</source>
          <target state="translated">主题活动</target>
        </trans-unit>
        <trans-unit id="8850eee2783cf53d0af71d524467316d7d06a850" translate="yes" xml:space="preserve">
          <source>Thread messages added to a thread-proc.</source>
          <target state="translated">线程消息添加到线程程序中。</target>
        </trans-unit>
        <trans-unit id="1501e9d814d273ed34cc6b50f1b5e25add4ac049" translate="yes" xml:space="preserve">
          <source>Three other shorthands exist, particularly useful for merge commits, for naming a set that is formed by a commit and its parent commits.</source>
          <target state="translated">另外还有三个速记,对于合并提交特别有用,用于命名一个由提交和其父提交组成的集合。</target>
        </trans-unit>
        <trans-unit id="8e23a87c8354d34eb4b513798d76048267e22ae4" translate="yes" xml:space="preserve">
          <source>Three steps:</source>
          <target state="translated">三个步骤。</target>
        </trans-unit>
        <trans-unit id="cf3d01be00b3333c6ca36b4d1bb0a1a1c357a43f" translate="yes" xml:space="preserve">
          <source>Throw-away integration</source>
          <target state="translated">抛弃式整合</target>
        </trans-unit>
        <trans-unit id="c4780f4837eebde8ca1de31df251ef05e2361eb2" translate="yes" xml:space="preserve">
          <source>Thunderbird</source>
          <target state="translated">Thunderbird</target>
        </trans-unit>
        <trans-unit id="d5e84648e0355ba1080675ff57a3c64a03a76a7c" translate="yes" xml:space="preserve">
          <source>Thunderbird in particular is known to be problematic. Thunderbird users may wish to visit this web page for more information: &lt;a href=&quot;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&quot;&gt;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&lt;/a&gt;</source>
          <target state="translated">尤其是雷鸟是有问题的。Thunderbird用户可能希望访问此网页以获取更多信息：&lt;a href=&quot;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&quot;&gt;http&lt;/a&gt; : //kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email</target>
        </trans-unit>
        <trans-unit id="da473e9b687406079cfbc2672fddb50595865b5d" translate="yes" xml:space="preserve">
          <source>Thus we see that this tree has one file in it. The SHA-1 hash is a reference to that file&amp;rsquo;s data:</source>
          <target state="translated">因此，我们看到该树中有一个文件。SHA-1哈希是对该文件数据的引用：</target>
        </trans-unit>
        <trans-unit id="309fb29079c2e5019b9d34cb235aee0452735a40" translate="yes" xml:space="preserve">
          <source>Thus you can, e.g., turn a library subdirectory into a repository of its own. Note the &lt;code&gt;--&lt;/code&gt; that separates &lt;code&gt;filter-branch&lt;/code&gt; options from revision options, and the &lt;code&gt;--all&lt;/code&gt; to rewrite all branches and tags.</source>
          <target state="translated">因此，您可以，例如，将库子目录变成其自己的存储库。请注意 &lt;code&gt;--&lt;/code&gt; 将 &lt;code&gt;filter-branch&lt;/code&gt; 选项与修订选项分开，以及 &lt;code&gt;--all&lt;/code&gt; 重写所有分支和标记。</target>
        </trans-unit>
        <trans-unit id="d35ca4f0ad7715e9f69a7f979c2424eb99273503" translate="yes" xml:space="preserve">
          <source>Thus, the following command:</source>
          <target state="translated">因此,下面的命令。</target>
        </trans-unit>
        <trans-unit id="77cc1ec67e1af48d92e062ee397960be200bdf58" translate="yes" xml:space="preserve">
          <source>Thus, we can provide O(log N) lookup time for any number of packfiles.</source>
          <target state="translated">因此,我们可以为任何数量的packfiles提供O(log N)的查找时间。</target>
        </trans-unit>
        <trans-unit id="ae19d34e63a0724afdaaeabe3d0fe80af7f9e778" translate="yes" xml:space="preserve">
          <source>Time and date specified by the ISO 8601 standard, for example &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;. The parser accepts a space instead of the &lt;code&gt;T&lt;/code&gt; character as well.</source>
          <target state="translated">ISO 8601标准指定的时间和日期，例如 &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; 。解析器也接受空格而不是 &lt;code&gt;T&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="0bac72478f018c225224e8417f521a2dad6209d3" translate="yes" xml:space="preserve">
          <source>Time zone values can be &quot;local&quot; (for local time zone that browser uses), &quot;utc&quot; (what gitweb uses when JavaScript or this feature is disabled), or numerical time zones in the form of &quot;+/-HHMM&quot;, such as &quot;+0200&quot;.</source>
          <target state="translated">时区值可以是 &quot;local&quot;(浏览器使用的本地时区)、&quot;utc&quot; (当JavaScript或此功能被禁用时,gitweb使用的),或 &quot;+/-hhmm &quot;形式的数字时区,如 &quot;+0200&quot;。</target>
        </trans-unit>
        <trans-unit id="396a560fd1658574279d941c34737eda5359f4fc" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) between the moment the connection is established and the client request is received (typically a rather low value, since that should be basically immediate).</source>
          <target state="translated">从建立连接到收到客户端请求之间的超时时间(以秒为单位)(通常是一个相当低的值,因为这基本上应该是即时的)。</target>
        </trans-unit>
        <trans-unit id="0ae2f4dfeb0fa0aaf2833b3c271308d2190a4162" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) for specific client sub-requests. This includes the time it takes for the server to process the sub-request and the time spent waiting for the next client&amp;rsquo;s request.</source>
          <target state="translated">特定客户端子请求的超时（以秒为单位）。这包括服务器处理子请求所花费的时间以及等待下一个客户端请求所花费的时间。</target>
        </trans-unit>
        <trans-unit id="ad6b83abe0aada0e5e6aec8e7e7470429fd4ee37" translate="yes" xml:space="preserve">
          <source>Tips and tricks</source>
          <target state="translated">提示和技巧</target>
        </trans-unit>
        <trans-unit id="d7242682d2f91b131962f45ed3706e536d3cdcc6" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; more than two &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;.</source>
          <target state="translated">要&lt;a href=&quot;#def_merge&quot;&gt;合并&lt;/a&gt;两个以上的&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c181af3380fe2a4df836df7796a5de6ef8d47c5" translate="yes" xml:space="preserve">
          <source>To access refs, it&amp;rsquo;s best not to look inside GIT_DIR directly. Instead use commands such as &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; or &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref[1]&lt;/a&gt; which will handle refs correctly.</source>
          <target state="translated">要访问引用，最好不要直接查看GIT_DIR。而是使用诸如&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt;或&lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref [1]之类的命令&lt;/a&gt;来正确处理引用。</target>
        </trans-unit>
        <trans-unit id="bdc5ec95e827bdeffd1f9aab0bef5dd1e05d0443" translate="yes" xml:space="preserve">
          <source>To achieve this, try to split your work into small steps from the very beginning. It is always easier to squash a few commits together than to split one big commit into several. Don&amp;rsquo;t be afraid of making too small or imperfect steps along the way. You can always go back later and edit the commits with &lt;code&gt;git rebase --interactive&lt;/code&gt; before you publish them. You can use &lt;code&gt;git stash push --keep-index&lt;/code&gt; to run the test suite independent of other uncommitted changes; see the EXAMPLES section of &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">为此，请从一开始就尝试将您的工作分成几个小步骤。将几个提交挤压在一起总是比将一个大提交分成几份要容易得多。不要害怕沿途走得太小或不完美。您始终可以稍后再返回，并在发布之前使用 &lt;code&gt;git rebase --interactive&lt;/code&gt; 编辑提交。您可以使用 &lt;code&gt;git stash push --keep-index&lt;/code&gt; 独立于其他未提交的更改来运行测试套件。参见&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;的示例部分。</target>
        </trans-unit>
        <trans-unit id="0fad63887775e60c970096082173b077cbcda459" translate="yes" xml:space="preserve">
          <source>To actually match only values with an exclamation mark, you have to</source>
          <target state="translated">要想实际只匹配带感叹号的值,你需要</target>
        </trans-unit>
        <trans-unit id="0fea0d3a69770ac7053eba17165f8f811c0d830f" translate="yes" xml:space="preserve">
          <source>To add a new proxy, without altering any of the existing ones, use</source>
          <target state="translated">要添加一个新的代理,而不改变任何现有的代理,使用</target>
        </trans-unit>
        <trans-unit id="6a37f3f129452efb4608e170beca8c23ff8dc189" translate="yes" xml:space="preserve">
          <source>To aid in debugging frontends fast-import ignores any line that begins with &lt;code&gt;#&lt;/code&gt; (ASCII pound/hash) up to and including the line ending &lt;code&gt;LF&lt;/code&gt;. A comment line may contain any sequence of bytes that does not contain an LF and therefore may be used to include any detailed debugging information that might be specific to the frontend and useful when inspecting a fast-import data stream.</source>
          <target state="translated">为了帮助调试前端，快速导入会忽略任何以 &lt;code&gt;#&lt;/code&gt; （ASCII磅/哈希）开头的行，直到 &lt;code&gt;LF&lt;/code&gt; 为止。注释行可以包含不包含LF的任何字节序列，因此可以用来包含任何详细的调试信息，这些信息可能特定于前端，并且在检查快速导入数据流时很有用。</target>
        </trans-unit>
        <trans-unit id="285359187a2aff04e4ea763b2f3e4bbaf641190b" translate="yes" xml:space="preserve">
          <source>To assist in this, Git also provides the tag object&amp;hellip;​</source>
          <target state="translated">为此，Git还提供了标签对象...</target>
        </trans-unit>
        <trans-unit id="b0021f1eb05e23f63eb7ccc2f58c52546ee61585" translate="yes" xml:space="preserve">
          <source>To avoid deadlock, such frontends must completely consume any pending output from &lt;code&gt;progress&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;get-mark&lt;/code&gt;, and &lt;code&gt;cat-blob&lt;/code&gt; before performing writes to fast-import that might block.</source>
          <target state="translated">为避免死锁，此类前端必须完全消耗 &lt;code&gt;progress&lt;/code&gt; ， &lt;code&gt;ls&lt;/code&gt; ， &lt;code&gt;get-mark&lt;/code&gt; 和 &lt;code&gt;cat-blob&lt;/code&gt; 的所有待处理输出，然后再执行可能会阻止的快速导入的写操作。</target>
        </trans-unit>
        <trans-unit id="75e1daad195d404dc835c71216234df4a4676d4e" translate="yes" xml:space="preserve">
          <source>To avoid deleting a shared index file that is still used, its modification time is updated to the current time every time a new split index based on the shared index file is either created or read from.</source>
          <target state="translated">为了避免删除仍在使用的共享索引文件,每次创建或读取基于共享索引文件的新拆分索引时,其修改时间都会更新为当前时间。</target>
        </trans-unit>
        <trans-unit id="0b95bb4f949904cf33707d2a81be23c345f8e5aa" translate="yes" xml:space="preserve">
          <source>To avoid false positives (e.g. when a patch has been removed, and an unrelated patch has been added between two iterations of the same patch series), the cost matrix is extended to allow for that, by adding fixed-cost entries for wholesale deletes/adds.</source>
          <target state="translated">为了避免误报(例如,当一个补丁被删除,而在同一补丁系列的两次迭代之间又增加了一个不相关的补丁),成本矩阵进行了扩展,增加了大量删除/增加补丁的固定成本条目,以考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="0fd573776931ed5e5643654b60eb3896366ed973" translate="yes" xml:space="preserve">
          <source>To avoid interfering with other worktrees, it first enables the &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; setting and makes sure to set the &lt;code&gt;core.sparseCheckout&lt;/code&gt; setting in the worktree-specific config file.</source>
          <target state="translated">为了避免干扰其他工作树，它首先启用 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 设置，并确保在特定于工作树的配置文件中设置 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="3c2082115575958e10a9c1afdaf9ab0c9127b12a" translate="yes" xml:space="preserve">
          <source>To avoid recording unrelated changes in the merge commit, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; will also abort if there are any changes registered in the index relative to the &lt;code&gt;HEAD&lt;/code&gt; commit. (Special narrow exceptions to this rule may exist depending on which merge strategy is in use, but generally, the index must match HEAD.)</source>
          <target state="translated">为了避免在合并提交中记录无关的更改，如果在索引中相对于 &lt;code&gt;HEAD&lt;/code&gt; 提交注册了任何更改，则 &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git merge&lt;/code&gt; 也将中止。（根据所使用的合并策略，可能存在此规则的特殊狭义例外，但通常，索引必须与HEAD匹配。）</target>
        </trans-unit>
        <trans-unit id="3066556f3c40d15744968614a5fc8c1e23bf8a7b" translate="yes" xml:space="preserve">
          <source>To avoid typing long email addresses, point this to one or more email aliases files. You must also supply &lt;code&gt;sendemail.aliasFileType&lt;/code&gt;.</source>
          <target state="translated">为避免输入长电子邮件地址，请将其指向一个或多个电子邮件别名文件。您还必须提供 &lt;code&gt;sendemail.aliasFileType&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4b87fbf313d264308ea989e0e3b9a4c3d776c25" translate="yes" xml:space="preserve">
          <source>To bootstrap the process, you can first create a bundle that does not have any basis. You can use a tag to remember up to what commit you last processed, in order to make it easy to later update the other repository with an incremental bundle:</source>
          <target state="translated">为了引导这个过程,你可以先创建一个没有任何基础的 bundle。你可以使用一个标签来记住你最后处理的提交,以便于以后用一个增量的捆绑更新其他仓库。</target>
        </trans-unit>
        <trans-unit id="9d8840568125195e79747db7654d577582e9ce27" translate="yes" xml:space="preserve">
          <source>To change which notes are shown by &lt;code&gt;git log&lt;/code&gt;, see the &quot;notes.displayRef&quot; configuration in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">要更改 &lt;code&gt;git log&lt;/code&gt; 显示的注释，请参阅&lt;a href=&quot;git-log&quot;&gt;git-log [1]中&lt;/a&gt;的&amp;ldquo; notes.displayRef&amp;rdquo;配置。</target>
        </trans-unit>
        <trans-unit id="97883ec3271fcc02269394ee0880b3655a6f452f" translate="yes" xml:space="preserve">
          <source>To check out commit &lt;code&gt;HEAD~3&lt;/code&gt; for temporary inspection or experiment without creating a new branch:</source>
          <target state="translated">要在不创建新分支的情况下签出 &lt;code&gt;HEAD~3&lt;/code&gt; 进行临时检查或实验：</target>
        </trans-unit>
        <trans-unit id="d144f3be27bf6711b21fc83fdbf3f1e8ff9fc321" translate="yes" xml:space="preserve">
          <source>To commit a tree you have instantiated with &lt;code&gt;git write-tree&lt;/code&gt;, you&amp;rsquo;d create a &quot;commit&quot; object that refers to that tree and the history behind it&amp;mdash;​most notably the &quot;parent&quot; commits that preceded it in history.</source>
          <target state="translated">要提交使用 &lt;code&gt;git write-tree&lt;/code&gt; 实例化的树，您需要创建一个``提交''对象，该对象引用该树及其背后的历史记录-最值得注意的是在历史记录之前的``父''提交。</target>
        </trans-unit>
        <trans-unit id="05e44c536d85ee3801aa2c0d698cefa8d09c4c33" translate="yes" xml:space="preserve">
          <source>To completely remove a submodule, manually delete &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt;.</source>
          <target state="translated">要完全删除子模块，请手动删除 &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27c15a86c7e79c3805e163825e563ceb0da18b5a" translate="yes" xml:space="preserve">
          <source>To control which revisions to show, gitk supports most options applicable to the &lt;code&gt;git rev-list&lt;/code&gt; command. It also supports a few options applicable to the &lt;code&gt;git diff-*&lt;/code&gt; commands to control how the changes each commit introduces are shown. Finally, it supports some gitk-specific options.</source>
          <target state="translated">为了控制显示哪些修订，gitk支持适用于 &lt;code&gt;git rev-list&lt;/code&gt; 命令的大多数选项。它还支持适用于 &lt;code&gt;git diff-*&lt;/code&gt; 命令的一些选项，以控制如何显示每次提交引入的更改。最后，它支持一些特定于gitk的选项。</target>
        </trans-unit>
        <trans-unit id="777e371b82028c9765bc912013f44d79febb95a6" translate="yes" xml:space="preserve">
          <source>To cope with such a situation, after the inner &lt;code&gt;git bisect&lt;/code&gt; finds the next revision to test, the script can apply the patch before compiling, run the real test, and afterwards decide if the revision (possibly with the needed patch) passed the test and then rewind the tree to the pristine state. Finally the script should exit with the status of the real test to let the &lt;code&gt;git bisect run&lt;/code&gt; command loop determine the eventual outcome of the bisect session.</source>
          <target state="translated">为了解决这种情况，在内部 &lt;code&gt;git bisect&lt;/code&gt; 找到下一个要测试的修订版本之后，脚本可以在编译之前应用补丁，运行真实测试，然后确定该修订版本（可能带有所需的补丁）是否通过了测试，并且然后将树倒回原始状态。最后，脚本应以真实测试的状态退出，以使 &lt;code&gt;git bisect run&lt;/code&gt; 命令循环确定bisect会话的最终结果。</target>
        </trans-unit>
        <trans-unit id="8674c1ca562e6ecc34e19d2429ea897e7602bd28" translate="yes" xml:space="preserve">
          <source>To create your own local live copy of such a &quot;raw&quot; Git repository, you&amp;rsquo;d first create your own subdirectory for the project, and then copy the raw repository contents into the &lt;code&gt;.git&lt;/code&gt; directory. For example, to create your own copy of the Git repository, you&amp;rsquo;d do the following</source>
          <target state="translated">要创建此类&amp;ldquo;原始&amp;rdquo; Git存储库的本地实时副本，您首先需要为项目创建自己的子目录，然后将原始存储库内容复制到 &lt;code&gt;.git&lt;/code&gt; 目录中。例如，要创建自己的Git存储库副本，请执行以下操作</target>
        </trans-unit>
        <trans-unit id="495be7922d2a293092e6f366efd8045104e01478" translate="yes" xml:space="preserve">
          <source>To define a custom merge driver &lt;code&gt;filfre&lt;/code&gt;, add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">要定义自定义合并驱动程序 &lt;code&gt;filfre&lt;/code&gt; ，请在 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件（或 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 文件）中添加一个部分，如下所示：</target>
        </trans-unit>
        <trans-unit id="369d97c17e3edbb633e139fcbb4d6a1ea94c1201" translate="yes" xml:space="preserve">
          <source>To define an external diff driver &lt;code&gt;jcdiff&lt;/code&gt;, add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">要定义外部diff驱动程序 &lt;code&gt;jcdiff&lt;/code&gt; ，请在 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件（或 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 文件）中添加一个部分，如下所示：</target>
        </trans-unit>
        <trans-unit id="302897a013466c7a33ee45af87c508a98422abd4" translate="yes" xml:space="preserve">
          <source>To delete the entry for renames, do</source>
          <target state="translated">要删除重名的条目,请执行</target>
        </trans-unit>
        <trans-unit id="f31f6b0ae1c80bea942e287ae0ab318c31ede1f4" translate="yes" xml:space="preserve">
          <source>To determine the location of the repository on disk, &lt;code&gt;git http-backend&lt;/code&gt; concatenates the environment variables PATH_INFO, which is set automatically by the web server, and GIT_PROJECT_ROOT, which must be set manually in the web server configuration. If GIT_PROJECT_ROOT is not set, &lt;code&gt;git http-backend&lt;/code&gt; reads PATH_TRANSLATED, which is also set automatically by the web server.</source>
          <target state="translated">为了确定存储库在磁盘上的位置， &lt;code&gt;git http-backend&lt;/code&gt; 将环境变量PATH_INFO（由Web服务器自动设置）和GIT_PROJECT_ROOT串联在一起，后者必须在Web服务器配置中手动设置。如果未设置GIT_PROJECT_ROOT，则 &lt;code&gt;git http-backend&lt;/code&gt; 会读取PATH_TRANSLATED，它也会由Web服务器自动设置。</target>
        </trans-unit>
        <trans-unit id="b99f7180a07f9dbb13dde063c76c98dd5e2d7887" translate="yes" xml:space="preserve">
          <source>To disable features that accept parameters (are configurable), you need to set this element to empty list i.e. &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">要禁用接受参数的功能（可配置），您需要将此元素设置为空列表，即 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43f3c91605c9cb6d680c0ea9cf4c1bb2e77b4d9d" translate="yes" xml:space="preserve">
          <source>To disable interactive logins, displaying a greeting instead:</source>
          <target state="translated">要禁用交互式登录,显示问候语代替。</target>
        </trans-unit>
        <trans-unit id="2e78622c40c98dec97477af783b12ba20d12cc1a" translate="yes" xml:space="preserve">
          <source>To display the &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; man page, use &lt;code&gt;git help git&lt;/code&gt;.</source>
          <target state="translated">要显示&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;手册页，请使用 &lt;code&gt;git help git&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa4dddf358b16e56494c90923230fd025e6f958d" translate="yes" xml:space="preserve">
          <source>To do automatic tag object dereferencing, use the &quot;-d&quot; or &quot;--dereference&quot; flag, so you can do</source>
          <target state="translated">要进行自动的标签对象取消引用,使用&quot;-d &quot;或&quot;--dereference &quot;标志,因此您可以进行以下操作</target>
        </trans-unit>
        <trans-unit id="dc05ce874d6baee1eae11d94d6fd56f1e0a6d0ed" translate="yes" xml:space="preserve">
          <source>To do the merge, do</source>
          <target state="translated">要进行合并,请执行</target>
        </trans-unit>
        <trans-unit id="45ed93b09b65e276ec2ef33a1d9d7c3e10d14bfe" translate="yes" xml:space="preserve">
          <source>To do this, the current maintenance branch is copied to another branch named with the previous release version number (e.g. maint-X.Y.(Z-1) where X.Y.Z is the current release).</source>
          <target state="translated">要做到这一点,当前的维护分支会被复制到另一个以之前的版本号命名的分支上(例如maint-X.Y.(Z-1),其中X.Y.Z是当前的版本)。</target>
        </trans-unit>
        <trans-unit id="380aa6a091a04ad8bbf89399d1982760e370374e" translate="yes" xml:space="preserve">
          <source>To drop a commit, replace the command &quot;pick&quot; with &quot;drop&quot;, or just delete the matching line.</source>
          <target state="translated">要放弃一个提交,将命令 &quot;pick &quot;替换为 &quot;drop&quot;,或者直接删除匹配的行。</target>
        </trans-unit>
        <trans-unit id="e05b8854f808624747710c5e1d641ee4dabaf30c" translate="yes" xml:space="preserve">
          <source>To elaborate, &quot;reading&quot; means checking for file existence, reading file attributes or file content. The working directory version may be present or absent. If present, its content may match against the index version or not. Writing is not affected by this bit, content safety is still first priority. Note that Git &lt;code&gt;can&lt;/code&gt; update working directory file, that is marked skip-worktree, if it is safe to do so (i.e. working directory version matches index version)</source>
          <target state="translated">详细地说，&amp;ldquo;读取&amp;rdquo;是指检查文件是否存在，读取文件属性或文件内容。工作目录版本可能存在或不存在。如果存在，其内容可能与索引版本不匹配。写入不受此位影响，内容安全仍然是第一要务。注意，如果安全的话，Git &lt;code&gt;can&lt;/code&gt; 更新标记为skip-worktree的工作目录文件（例如，工作目录版本与索引版本匹配）。</target>
        </trans-unit>
        <trans-unit id="64ecd7272d648bbcdba5e527a1a80e43cb0705c5" translate="yes" xml:space="preserve">
          <source>To enable &lt;code&gt;git archive --remote&lt;/code&gt; and disable &lt;code&gt;git fetch&lt;/code&gt; against a repository, have the following in the configuration file in the repository (that is the file &lt;code&gt;config&lt;/code&gt; next to &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;refs&lt;/code&gt; and &lt;code&gt;objects&lt;/code&gt;).</source>
          <target state="translated">要对存储库启用 &lt;code&gt;git archive --remote&lt;/code&gt; 并禁用 &lt;code&gt;git fetch&lt;/code&gt; ，请在存储库的配置文件中添加以下内容（即 &lt;code&gt;HEAD&lt;/code&gt; ， &lt;code&gt;refs&lt;/code&gt; 和 &lt;code&gt;objects&lt;/code&gt; 旁边的文件 &lt;code&gt;config&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="af7d8457fff28a2087e0f74bc51d0468026a9bff" translate="yes" xml:space="preserve">
          <source>To enable a target, set the corresponding environment variable or system or global config value to one of the following:</source>
          <target state="translated">要启用目标,请将相应的环境变量或系统或全局配置值设置为以下之一。</target>
        </trans-unit>
        <trans-unit id="01e6eac26c3bbc386ab13c8cd6a9167801f24836" translate="yes" xml:space="preserve">
          <source>To enable anonymous read access but authenticated write access, require authorization for both the initial ref advertisement (which we detect as a push via the service parameter in the query string), and the receive-pack invocation itself:</source>
          <target state="translated">为了实现匿名的读访问,但认证的写访问,需要对初始ref广告(我们通过查询字符串中的service参数检测为推送)和receive-pack调用本身进行授权。</target>
        </trans-unit>
        <trans-unit id="9bda367b82f8881561a1128afb27f36988891c35" translate="yes" xml:space="preserve">
          <source>To enable anonymous read access but authenticated write access:</source>
          <target state="translated">启用匿名读取访问,但允许认证的写入访问。</target>
        </trans-unit>
        <trans-unit id="050d5472dcd3f05f019f9a8129d0bb6d5e205df8" translate="yes" xml:space="preserve">
          <source>To enable blame, pickaxe search, and snapshot support (allowing &quot;tar.gz&quot; and &quot;zip&quot; snapshots), while allowing individual projects to turn them off, put the following in your GITWEB_CONFIG file:</source>
          <target state="translated">要启用责备、pickaxe搜索和快照支持(允许 &quot;tar.gz &quot;和 &quot;zip &quot;快照),同时允许单个项目关闭它们,请在GITWEB_CONFIG文件中加入以下内容。</target>
        </trans-unit>
        <trans-unit id="fa7174e314ce7012972664ac5bcf82d4b390a6d5" translate="yes" xml:space="preserve">
          <source>To enable git-cvsserver access (which should generally have the &lt;code&gt;no-interactive-login&lt;/code&gt; example above as a prerequisite, as creating the git-shell-commands directory allows interactive logins):</source>
          <target state="translated">要启用git-cvsserver访问（通常应该具有上面的 &lt;code&gt;no-interactive-login&lt;/code&gt; 示例作为先决条件，因为创建git-shell-commands目录允许交互式登录）：</target>
        </trans-unit>
        <trans-unit id="69aa803d2928631745bb26ea6d720a34de175dd7" translate="yes" xml:space="preserve">
          <source>To enable that additional nice feature, when a bisection is started and when some good commits are not ancestors of the bad commit, we first compute the merge bases between the bad and the good commits and we chose these merge bases as the first commits that will be checked out and tested.</source>
          <target state="translated">为了实现这个额外的好功能,当开始一分为二的时候,当一些好的提交不是坏的提交的祖先时,我们首先计算坏的提交和好的提交之间的合并基数,我们选择这些合并基数作为首先要检查和测试的提交。</target>
        </trans-unit>
        <trans-unit id="ba44f6ad0a0230b79b3149aabc029b57fd7f22d9" translate="yes" xml:space="preserve">
          <source>To enable the sparse-checkout feature, run &lt;code&gt;git sparse-checkout init&lt;/code&gt; to initialize a simple sparse-checkout file and enable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; config setting. Then, run &lt;code&gt;git sparse-checkout set&lt;/code&gt; to modify the patterns in the sparse-checkout file.</source>
          <target state="translated">要启用稀疏签出功能，请运行 &lt;code&gt;git sparse-checkout init&lt;/code&gt; 初始化一个简单的稀疏签出文件并启用 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 配置设置。然后，运行 &lt;code&gt;git sparse-checkout set&lt;/code&gt; 来修改sparse-checkout文件中的模式。</target>
        </trans-unit>
        <trans-unit id="1318b73efc503f41a06d5d140c646ee25cf7e427" translate="yes" xml:space="preserve">
          <source>To exclude commits reachable from a commit, a prefix &lt;code&gt;^&lt;/code&gt; notation is used. E.g. &lt;code&gt;^r1 r2&lt;/code&gt; means commits reachable from &lt;code&gt;r2&lt;/code&gt; but exclude the ones reachable from &lt;code&gt;r1&lt;/code&gt; (i.e. &lt;code&gt;r1&lt;/code&gt; and its ancestors).</source>
          <target state="translated">为了从提交中排除可到达的提交，使用前缀 &lt;code&gt;^&lt;/code&gt; 表示法。例如 &lt;code&gt;^r1 r2&lt;/code&gt; 表示可从 &lt;code&gt;r2&lt;/code&gt; 到达的提交，但不包括可从 &lt;code&gt;r1&lt;/code&gt; 到达的提交（即 &lt;code&gt;r1&lt;/code&gt; 及其祖先）。</target>
        </trans-unit>
        <trans-unit id="a12d809ea9b20c2b561957b059e3fe943cb6e440" translate="yes" xml:space="preserve">
          <source>To find out how the result can be used, just read on in &lt;code&gt;cmd_cat_file()&lt;/code&gt;:</source>
          <target state="translated">要了解如何使用结果，只需在 &lt;code&gt;cmd_cat_file()&lt;/code&gt; 中继续阅读：</target>
        </trans-unit>
        <trans-unit id="338cdf0c3d82152dc96e1eae9cd9922bf736e76c" translate="yes" xml:space="preserve">
          <source>To get a checkout with the Eclipse CVS client:</source>
          <target state="translated">要用Eclipse CVS客户端进行结账。</target>
        </trans-unit>
        <trans-unit id="976f859125db1311d8f82bb8df703ef2ad537fd0" translate="yes" xml:space="preserve">
          <source>To get a reminder of the currently used terms, use</source>
          <target state="translated">要获得当前使用的术语的提醒,使用</target>
        </trans-unit>
        <trans-unit id="68b714c59ff5898ff58433a2938d52aeb27df43e" translate="yes" xml:space="preserve">
          <source>To get started with gitweb, run &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; from a Git repository. This would configure and start your web server, and run web browser pointing to gitweb.</source>
          <target state="translated">要开始使用gitweb，请从Git存储库运行&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;。这将配置并启动您的Web服务器，并运行指向gitweb的Web浏览器。</target>
        </trans-unit>
        <trans-unit id="bf62a03860b36b4b6a615592146052d88035a5f4" translate="yes" xml:space="preserve">
          <source>To get the &quot;base&quot; for the merge, look up the common parent of two commits:</source>
          <target state="translated">要想得到合并的 &quot;基数&quot;,就要查找两个提交的共同父体。</target>
        </trans-unit>
        <trans-unit id="ec1f343ca45777aa33e95b7222bfb7658aa36062" translate="yes" xml:space="preserve">
          <source>To get the feature/bugfix into an integration branch, simply merge it. If the topic has evolved further in the meantime, merge again. (Note that you do not necessarily have to merge it to the oldest integration branch first. For example, you can first merge a bugfix to &lt;code&gt;next&lt;/code&gt;, give it some testing time, and merge to &lt;code&gt;maint&lt;/code&gt; when you know it is stable.)</source>
          <target state="translated">要将功能/错误修正纳入集成分支，只需将其合并即可。如果与此同时话题进一步发展，请再次合并。（请注意，您不必一定要先将其合并到最早的集成分支。例如，您可以先将bugfix合并到 &lt;code&gt;next&lt;/code&gt; ，给它一些测试时间，然后在知道稳定后合并到 &lt;code&gt;maint&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="60ae758b58fc83602f1720fb9cc2f0f4fb30b090" translate="yes" xml:space="preserve">
          <source>To give some hard figures, we used to have an average report-to-fix cycle of 142.6 hours (according to our somewhat weird bug-tracker which just measures wall-clock time). Since we moved to Git, we&amp;rsquo;ve lowered that to 16.2 hours. Primarily because we can stay on top of the bug fixing now, and because everyone&amp;rsquo;s jockeying to get to fix bugs (we&amp;rsquo;re quite proud of how lazy we are to let Git find the bugs for us). Each new release results in ~40% fewer bugs (almost certainly due to how we now feel about writing tests).</source>
          <target state="translated">为了给出一些确切的数字，我们以前的平均报告到修复周期为142.6小时（根据我们有些奇怪的bug跟踪器（它仅测量挂钟时间））。自从我们迁移到Git以来，我们将其降低到16.2小时。主要是因为我们现在可以保持在bug修复的最前沿，并且因为每个人都在努力修复bug（我们为让Git为我们找到bug感到很懒惰而感到自豪）。每个新版本都会减少大约40％的错误（几乎可以肯定，这是由于我们现在对编写测试的感觉所致）。</target>
        </trans-unit>
        <trans-unit id="cc855cb566c405d222e3a3236275bbad376833c3" translate="yes" xml:space="preserve">
          <source>To help with that, &lt;code&gt;range&lt;/code&gt; uses the &lt;code&gt;--dual-color&lt;/code&gt; mode by default. In this mode, the diff of diffs will retain the original diff colors, and prefix the lines with -/+ markers that have their &lt;strong&gt;background&lt;/strong&gt; red or green, to make it more obvious that they describe how the diff itself changed.</source>
          <target state="translated">为了解决这个问题， &lt;code&gt;range&lt;/code&gt; 默认使用 &lt;code&gt;--dual-color&lt;/code&gt; 模式。在此模式下，差异的差异将保留原始差异颜色，并在带有-/ +标记的行前加上&lt;strong&gt;背景为&lt;/strong&gt;红色或绿色的标记，以使其更明显地描述差异本身的变化。</target>
        </trans-unit>
        <trans-unit id="096c5d9029f3f58b2af501ec17fb5d42ac0f73fe" translate="yes" xml:space="preserve">
          <source>To illustrate the difference between &lt;code&gt;-S&amp;lt;regex&amp;gt; --pickaxe-regex&lt;/code&gt; and &lt;code&gt;-G&amp;lt;regex&amp;gt;&lt;/code&gt;, consider a commit with the following diff in the same file:</source>
          <target state="translated">为了说明 &lt;code&gt;-S&amp;lt;regex&amp;gt; --pickaxe-regex&lt;/code&gt; 和 &lt;code&gt;-G&amp;lt;regex&amp;gt;&lt;/code&gt; 之间的区别，请考虑在同一文件中包含以下差异的提交：</target>
        </trans-unit>
        <trans-unit id="e67d6de21feaa90def83753eb253a23faea561fa" translate="yes" xml:space="preserve">
          <source>To illustrate, suppose you are in a situation where someone develops a &lt;code&gt;subsystem&lt;/code&gt; branch, and you are working on a &lt;code&gt;topic&lt;/code&gt; that is dependent on this &lt;code&gt;subsystem&lt;/code&gt;. You might end up with a history like the following:</source>
          <target state="translated">为了进行说明，假设您处于有人开发 &lt;code&gt;subsystem&lt;/code&gt; 分支的情况，并且您正在研究一个依赖于该 &lt;code&gt;subsystem&lt;/code&gt; 的 &lt;code&gt;topic&lt;/code&gt; 。您可能会得到如下所示的历史记录：</target>
        </trans-unit>
        <trans-unit id="a98d25733140cb4450fff563f123b0d4cafeb9f9" translate="yes" xml:space="preserve">
          <source>To interrupt the rebase (just like an &quot;edit&quot; command would do, but without cherry-picking any commit first), use the &quot;break&quot; command.</source>
          <target state="translated">要中断rebase(就像 &quot;edit &quot;命令一样,但不需要先挑出任何提交),使用 &quot;break &quot;命令。</target>
        </trans-unit>
        <trans-unit id="f6408dba3913ebdb903fdfce1d68f1906d3e56f0" translate="yes" xml:space="preserve">
          <source>To look at only non-zero stages, use &lt;code&gt;--unmerged&lt;/code&gt; flag:</source>
          <target state="translated">要仅查看非零阶段，请使用 &lt;code&gt;--unmerged&lt;/code&gt; 标志：</target>
        </trans-unit>
        <trans-unit id="5b273f729e50c3bb1996889c896c925cce764cd8" translate="yes" xml:space="preserve">
          <source>To make it readable, we can tell &lt;code&gt;git diff-files&lt;/code&gt; to output the differences as a patch, using the &lt;code&gt;-p&lt;/code&gt; flag:</source>
          <target state="translated">为了使其可读，我们可以使用 &lt;code&gt;-p&lt;/code&gt; 标志告诉 &lt;code&gt;git diff-files&lt;/code&gt; 将差异作为补丁输出：</target>
        </trans-unit>
        <trans-unit id="5411ef1231b1da2dbabaf49f4348af685832f2f7" translate="yes" xml:space="preserve">
          <source>To move the whole tree into a subdirectory, or remove it from there:</source>
          <target state="translated">要将整棵树移到子目录中,或从子目录中删除它。</target>
        </trans-unit>
        <trans-unit id="9fef1883cb2bb53007927c93e3d8f7431145efad" translate="yes" xml:space="preserve">
          <source>To perform a three-way merge, you start with the two commits you want to merge, find their closest common parent (a third commit), and compare the trees corresponding to these three commits.</source>
          <target state="translated">要执行三向合并,先从要合并的两个提交开始,找到它们最接近的共同父代(第三个提交),然后比较这三个提交对应的树。</target>
        </trans-unit>
        <trans-unit id="a35f3e8a10774da4c0b0f3f87118660d7ef9889e" translate="yes" xml:space="preserve">
          <source>To place a higher stage entry to the index, the path should first be removed by feeding a mode=0 entry for the path, and then feeding necessary input lines in the third format.</source>
          <target state="translated">如果要将更高阶段的条目放到索引中,应先为路径输入一个mode=0的条目,然后再以第三种格式输入必要的输入行,将路径删除。</target>
        </trans-unit>
        <trans-unit id="26b0cbf1bc1090821ae6f59cac15f02ec7f562f8" translate="yes" xml:space="preserve">
          <source>To prepare for working on &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, switch to it by updating the index and the files in the working tree, and by pointing &lt;code&gt;HEAD&lt;/code&gt; at the branch. Local modifications to the files in the working tree are kept, so that they can be committed to the &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">要准备在 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 上工作，请通过更新工作树中的索引和文件，并将 &lt;code&gt;HEAD&lt;/code&gt; 指向分支来切换到该分支。保留对工作树中文件的本地修改，以便可以将其提交给 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13739c43ac679e23fc4c2d09478ac31e5293cb15" translate="yes" xml:space="preserve">
          <source>To pretend you have a file at path with mode and sha1, say:</source>
          <target state="translated">假设你在路径上有一个文件,用mode和sha1,比如。</target>
        </trans-unit>
        <trans-unit id="6785e6ba620455f331d4a09eb8363e2600eabf25" translate="yes" xml:space="preserve">
          <source>To prevent a $GIT_DIR/worktrees entry from being pruned (which can be useful in some situations, such as when the entry&amp;rsquo;s working tree is stored on a portable device), use the &lt;code&gt;git worktree lock&lt;/code&gt; command, which adds a file named &lt;code&gt;locked&lt;/code&gt; to the entry&amp;rsquo;s directory. The file contains the reason in plain text. For example, if a linked working tree&amp;rsquo;s &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; then a file named &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; will prevent the &lt;code&gt;test-next&lt;/code&gt; entry from being pruned. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for details.</source>
          <target state="translated">为了防止修剪$ GIT_DIR / worktrees条目（在某些情况下（例如，该条目的工作树存储在便携式设备上时，这 &lt;code&gt;git worktree lock&lt;/code&gt; 用）），请使用git worktree lock命令，该命令将一个名为 &lt;code&gt;locked&lt;/code&gt; 的文件添加到条目的目录。该文件以纯文本形式包含原因。例如，如果链接的工作树的 &lt;code&gt;.git&lt;/code&gt; 文件指向 &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; ,则名为 &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; 的文件将阻止 &lt;code&gt;test-next&lt;/code&gt; 删除下一个条目。有关详细信息，请参见&lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46ac404b2baca4d3a659bb0594db0c41828389ed" translate="yes" xml:space="preserve">
          <source>To prevent these unnecessary merge conflicts, Git can be told to run a virtual check-out and check-in of all three stages of a file when resolving a three-way merge by setting the &lt;code&gt;merge.renormalize&lt;/code&gt; configuration variable. This prevents changes caused by check-in conversion from causing spurious merge conflicts when a converted file is merged with an unconverted file.</source>
          <target state="translated">为了防止这些不必要的合并冲突，在通过设置 &lt;code&gt;merge.renormalize&lt;/code&gt; 配置变量来解决三向合并时，可以告诉Git对文件的所有三个阶段运行虚拟检出和检入。当转换后的文件与未转换的文件合并时，这可以防止由签入转换引起的更改引起虚假合并冲突。</target>
        </trans-unit>
        <trans-unit id="91d260766aee213709a415223ac206b93100d7d5" translate="yes" xml:space="preserve">
          <source>To prune objects not used by your repository or another that borrows from your repository via its &lt;code&gt;.git/objects/info/alternates&lt;/code&gt;:</source>
          <target state="translated">要修剪存储库或通过其 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; 从存储库借用的另一个对象未​​使用的对象，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="2f63f42b98c259e7fd0384dd68939f7fc302c5eb" translate="yes" xml:space="preserve">
          <source>To prune references as part of your normal workflow without needing to remember to run that, set &lt;code&gt;fetch.prune&lt;/code&gt; globally, or &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; per-remote in the config. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">要在正常工作流程中修剪引用而不需要记住运行该引用，请在 &lt;code&gt;fetch.prune&lt;/code&gt; 全局设置fetch.prune或 &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; per-remote。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68bfae2792009c9d944a67bd77b4854e1c8c4d3e" translate="yes" xml:space="preserve">
          <source>To put the loose objects into a pack, just run git repack:</source>
          <target state="translated">要把松散的对象放入包中,只需运行git repack即可。</target>
        </trans-unit>
        <trans-unit id="8344caf5b982f9b0d4dc99f7ff5aa708ff0b3592" translate="yes" xml:space="preserve">
          <source>To query the value for a given key, do</source>
          <target state="translated">要查询一个给定的键的值,请执行</target>
        </trans-unit>
        <trans-unit id="6d7c1598e59e901d58d9b961c14fa449c82ef069" translate="yes" xml:space="preserve">
          <source>To reapply a series of changes from a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; to a different base, and reset the &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; of that branch to the result.</source>
          <target state="translated">要重新应用从&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;到其他基准的一系列更改，并将该分支的&lt;a href=&quot;#def_head&quot;&gt;开头&lt;/a&gt;重置为结果。</target>
        </trans-unit>
        <trans-unit id="25388a0bc929e9a0e4d2bb9d4d113e8444bb02a5" translate="yes" xml:space="preserve">
          <source>To remove a file from the index and from the working tree, use</source>
          <target state="translated">要从索引和工作树中删除一个文件,请使用</target>
        </trans-unit>
        <trans-unit id="c7850646e909d85f101794190a2e6f7a699e3e90" translate="yes" xml:space="preserve">
          <source>To remove commits authored by &quot;Darl McBribe&quot; from the history:</source>
          <target state="translated">从历史记录中删除 &quot;Darl McBribe &quot;撰写的提交。</target>
        </trans-unit>
        <trans-unit id="65692943c43d72ea453917ea884fccf3994fb56e" translate="yes" xml:space="preserve">
          <source>To remove selection, prefix the input with &lt;code&gt;-&lt;/code&gt; like this:</source>
          <target state="translated">要删除选择，请在输入之前添加 &lt;code&gt;-&lt;/code&gt; ,如下所示：</target>
        </trans-unit>
        <trans-unit id="9e91a512899aa79b93af123e6b1768a526248346" translate="yes" xml:space="preserve">
          <source>To repopulate the working directory with all files, use the &lt;code&gt;git sparse-checkout disable&lt;/code&gt; command.</source>
          <target state="translated">要用所有文件重新填充工作目录，请使用 &lt;code&gt;git sparse-checkout disable&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="5c497720a7ab3ae3ef408305ef475289bc14a521" translate="yes" xml:space="preserve">
          <source>To reproduce the entire p4 history in Git, use the &lt;code&gt;@all&lt;/code&gt; modifier on the depot path:</source>
          <target state="translated">要在Git中重现整个p4历史记录，请在仓库路径上使用 &lt;code&gt;@all&lt;/code&gt; 修饰符：</target>
        </trans-unit>
        <trans-unit id="d4609928d728916d052df2a3b481b65890e4b16e" translate="yes" xml:space="preserve">
          <source>To require authentication for both reads and writes, use a Location directive around the repository, or one of its parent directories:</source>
          <target state="translated">要要求对读和写进行认证,可以在版本库周围使用一个Location指令,或者它的一个父目录。</target>
        </trans-unit>
        <trans-unit id="10ebfb5ceb771c952eff2c39be3b852f1f654421" translate="yes" xml:space="preserve">
          <source>To require authentication for both reads and writes:</source>
          <target state="translated">要求对读和写进行认证。</target>
        </trans-unit>
        <trans-unit id="847928f545abee25f9f8e4e2cc396a049af86735" translate="yes" xml:space="preserve">
          <source>To restore a file in the index to match the version in &lt;code&gt;HEAD&lt;/code&gt; (this is the same as using &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;)</source>
          <target state="translated">恢复索引中的文件以匹配 &lt;code&gt;HEAD&lt;/code&gt; 中的版本（这与使用&lt;a href=&quot;git-reset&quot;&gt;git-reset [1]相同&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="21366b05c441f538e6886570018737e901640e49" translate="yes" xml:space="preserve">
          <source>To restore all files in the current directory</source>
          <target state="translated">要恢复当前目录下的所有文件</target>
        </trans-unit>
        <trans-unit id="0ab7e14988a23edeb341648ca7b63377b3dd49d2" translate="yes" xml:space="preserve">
          <source>To restrict rewriting to only part of the history, specify a revision range in addition to the new branch name. The new branch name will point to the top-most revision that a &lt;code&gt;git rev-list&lt;/code&gt; of this range will print.</source>
          <target state="translated">要将重写限制为仅历史记录的一部分，除了新的分支名称外，还要指定修订范围。新的分支名称将指向此范围的 &lt;code&gt;git rev-list&lt;/code&gt; 将打印的最高修订。</target>
        </trans-unit>
        <trans-unit id="4d880d7fd779c619b85e62692eb083b5f59e932e" translate="yes" xml:space="preserve">
          <source>To rewrite commits E,F,G,H, use one of these:</source>
          <target state="translated">要重写提交E,F,G,H,请使用其中之一。</target>
        </trans-unit>
        <trans-unit id="47b66273feb1f496168989ebee433bebb314fc85" translate="yes" xml:space="preserve">
          <source>To rewrite only commits D,E,F,G,H, but leave A, B and C alone, use:</source>
          <target state="translated">要只重写D,E,F,G,H,而不重写A,B,C,请使用。</target>
        </trans-unit>
        <trans-unit id="8c31d9c011b7c86062de888fb92cc01426b53584" translate="yes" xml:space="preserve">
          <source>To rewrite the repository to look as if &lt;code&gt;foodir/&lt;/code&gt; had been its project root, and discard all other history:</source>
          <target state="translated">要重写存储库，使其看起来好像 &lt;code&gt;foodir/&lt;/code&gt; 已经是其项目根，并丢弃所有其他历史记录：</target>
        </trans-unit>
        <trans-unit id="7c02b2b350476c8c24e25173b62f35a8ad0c0ae3" translate="yes" xml:space="preserve">
          <source>To see how submodule support works, create four example repositories that can be used later as a submodule:</source>
          <target state="translated">为了了解子模块支持是如何工作的,创建四个示例仓库,以后可以作为子模块使用。</target>
        </trans-unit>
        <trans-unit id="700bc56e5656b835e5cd7fa2e5386957dfc66eac" translate="yes" xml:space="preserve">
          <source>To see the currently remaining suspects in &lt;code&gt;gitk&lt;/code&gt;, issue the following command during the bisection process (the subcommand &lt;code&gt;view&lt;/code&gt; can be used as an alternative to &lt;code&gt;visualize&lt;/code&gt;):</source>
          <target state="translated">要查看 &lt;code&gt;gitk&lt;/code&gt; 中当前剩余的可疑对象，请在对分过程中发出以下命令（子命令 &lt;code&gt;view&lt;/code&gt; 可以用作 &lt;code&gt;visualize&lt;/code&gt; 的替代方法）：</target>
        </trans-unit>
        <trans-unit id="faa509deef7fcd4d518cc2cd2e577046b7eb747b" translate="yes" xml:space="preserve">
          <source>To see whether it has already been merged into the test or release branches, use:</source>
          <target state="translated">要查看它是否已经被合并到测试或发布分支中,使用。</target>
        </trans-unit>
        <trans-unit id="1e15ca1368deb202f467e491af7bfdb38f930af4" translate="yes" xml:space="preserve">
          <source>To serve gitweb at the same url, use a ScriptAliasMatch to only those URLs that &lt;code&gt;git http-backend&lt;/code&gt; can handle, and forward the rest to gitweb:</source>
          <target state="translated">要以相同的网址提供gitweb，请使用ScriptAliasMatch仅将 &lt;code&gt;git http-backend&lt;/code&gt; 可以处理的URL 转发给gitweb：</target>
        </trans-unit>
        <trans-unit id="3b5c2b799f6b39d60aa882699fc88e3eb3a77175" translate="yes" xml:space="preserve">
          <source>To serve multiple repositories from different &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; in a single repository:</source>
          <target state="translated">要在单个存储库中提供来自不同&lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt;的多个存储库：</target>
        </trans-unit>
        <trans-unit id="59fa97f902b7761eca14600ff37aff1758dec6bd" translate="yes" xml:space="preserve">
          <source>To set a commit (which typically is at the tip of another history) to be the parent of the current initial commit, in order to paste the other history behind the current history:</source>
          <target state="translated">将一个提交(通常是在另一个历史记录的顶端)设置为当前初始提交的父级,以便将其他历史记录粘贴在当前历史记录的后面。</target>
        </trans-unit>
        <trans-unit id="d091c25539483b5c5b3db274eae656a5f768704a" translate="yes" xml:space="preserve">
          <source>To set the date used in future tag objects, set the environment variable GIT_COMMITTER_DATE (see the later discussion of possible values; the most common form is &quot;YYYY-MM-DD HH:MM&quot;).</source>
          <target state="translated">要设置未来标签对象中使用的日期,请设置环境变量GIT_COMMITTER_DATE(参见后面对可能值的讨论;最常见的形式是 &quot;YYYY-MM-DD HH:MM&quot;)。</target>
        </trans-unit>
        <trans-unit id="0de4847876d8ab04ebb463613f39507d60c3b1a3" translate="yes" xml:space="preserve">
          <source>To set this up, first create your work tree by cloning Linus&amp;rsquo;s public tree:</source>
          <target state="translated">要进行设置，首先通过克隆Linus的公共树来创建工作树：</target>
        </trans-unit>
        <trans-unit id="6fdb47a7575f286ad7a6b8b651d8470ef2c51c01" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as a regular, non-inetd service that handles repositories for multiple virtual hosts based on their IP addresses, start the daemon like this:</source>
          <target state="translated">要将 &lt;code&gt;git daemon&lt;/code&gt; 设置为常规的非inetd服务，该服务根据虚拟主机的IP地址处理多个虚拟主机的存储库，请启动该守护进程，如下所示：</target>
        </trans-unit>
        <trans-unit id="cd4e85b93c0b5a71d973a240463742c429d6ce10" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as an inetd service that handles any repository under the whitelisted set of directories, /pub/foo and /pub/bar, place an entry like the following into /etc/inetd all on one line:</source>
          <target state="translated">要将 &lt;code&gt;git daemon&lt;/code&gt; 设置为可处理列入白名单的目录集/ pub / foo和/ pub / bar下的任何存储库的ine​​td服务，请在/ etc / inetd中将以下内容全部放入一行：</target>
        </trans-unit>
        <trans-unit id="d85d4c6ac447e3ea7881a95ee3354b641502c913" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as an inetd service that handles repositories for different virtual hosts, &lt;code&gt;www.example.com&lt;/code&gt; and &lt;code&gt;www.example.org&lt;/code&gt;, place an entry like the following into &lt;code&gt;/etc/inetd&lt;/code&gt; all on one line:</source>
          <target state="translated">要将 &lt;code&gt;git daemon&lt;/code&gt; 设置为可处理不同虚拟主机的存储库的ine​​td服务，请将 &lt;code&gt;www.example.com&lt;/code&gt; 和 &lt;code&gt;www.example.org&lt;/code&gt; 如下所示的条目放在 &lt;code&gt;/etc/inetd&lt;/code&gt; 中的所有行中：</target>
        </trans-unit>
        <trans-unit id="6d1dfa06a0b2e0253dac9a23d3e763ff2be4729c" translate="yes" xml:space="preserve">
          <source>To shelve changes instead of submitting, use &lt;code&gt;--shelve&lt;/code&gt; and &lt;code&gt;--update-shelve&lt;/code&gt;:</source>
          <target state="translated">要搁置更改而不是提交更改，请使用 &lt;code&gt;--shelve&lt;/code&gt; 和 &lt;code&gt;--update-shelve&lt;/code&gt; shelve：</target>
        </trans-unit>
        <trans-unit id="b19251adc869dd31b98316a2df3ca3e146f58f68" translate="yes" xml:space="preserve">
          <source>To show all references called &quot;master&quot;, whether tags or heads or anything else, and regardless of how deep in the reference naming hierarchy they are, use:</source>
          <target state="translated">要显示所有被称为 &quot;master &quot;的引用,无论是tag、head还是其他任何东西,也不管它们在引用命名层次结构中的位置有多深,请使用。</target>
        </trans-unit>
        <trans-unit id="51ec81ccf2337a76aefa897308cd08d96e515614" translate="yes" xml:space="preserve">
          <source>To show only tags, or only proper branch heads, use &quot;--tags&quot; and/or &quot;--heads&quot; respectively (using both means that it shows tags and heads, but not other random references under the refs/ subdirectory).</source>
          <target state="translated">要只显示标签,或者只显示正确的分支头,分别使用&quot;--tags &quot;和/或&quot;--heads&quot;(使用这两个词意味着它显示标签和头,但不显示refs/子目录下的其他随机引用)。</target>
        </trans-unit>
        <trans-unit id="864f9f1ee17e37f4b3823291b8524eebd5879fc4" translate="yes" xml:space="preserve">
          <source>To show that as an example, let&amp;rsquo;s go back to the git-tutorial repository we used earlier, and create a branch in it. You do that by simply just saying that you want to check out a new branch:</source>
          <target state="translated">为了说明这一点，让我们回到前面使用的git-tutorial存储库，并在其中创建一个分支。您只需说出要签出新的分支即可：</target>
        </trans-unit>
        <trans-unit id="acab411fa1b0a4e2f72e42b537e21a4bc08bf613" translate="yes" xml:space="preserve">
          <source>To simplify the discussion we will suppose that the untestable area is a simple string of commits and that it was created by a breakage introduced by one commit (let&amp;rsquo;s call it BBC for bisect breaking commit) and later fixed by another one (let&amp;rsquo;s call it BFC for bisect fixing commit).</source>
          <target state="translated">为了简化讨论，我们将假设不可测区域是一个简单的提交字符串，它是由一个提交引入的破损创建的（对于二等分断开提交，我们称之为BBC），后来又由另一个提交修复了（称为BFC）。对于等分修复提交）。</target>
        </trans-unit>
        <trans-unit id="975e3a9279c8287bca9f664bbcc61fee7baa93ca" translate="yes" xml:space="preserve">
          <source>To specify a branch other than the current one, use:</source>
          <target state="translated">要指定当前分支以外的分支,请使用。</target>
        </trans-unit>
        <trans-unit id="b6b6e95c2c1acd4004bc280690d73f7c9df3e3b0" translate="yes" xml:space="preserve">
          <source>To specify a namespace, set the &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; environment variable to the namespace. For each ref namespace, Git stores the corresponding refs in a directory under &lt;code&gt;refs/namespaces/&lt;/code&gt;. For example, &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; will store refs under &lt;code&gt;refs/namespaces/foo/&lt;/code&gt;. You can also specify namespaces via the &lt;code&gt;--namespace&lt;/code&gt; option to &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;.</source>
          <target state="translated">要指定名称空间，请将 &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; 环境变量设置为名称空间。对于每个ref名称空间，Git会将相应的refs存储在 &lt;code&gt;refs/namespaces/&lt;/code&gt; 下的目录中。例如， &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; 将引用存储在 &lt;code&gt;refs/namespaces/foo/&lt;/code&gt; 。您还可以通过&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;的 &lt;code&gt;--namespace&lt;/code&gt; 选项指定名称空间。</target>
        </trans-unit>
        <trans-unit id="8d8e0463dddb070b083bcb1d31f0cd304bcae1a2" translate="yes" xml:space="preserve">
          <source>To specify a single commit or a range of commits, use:</source>
          <target state="translated">要指定一个或一系列的提交,请使用。</target>
        </trans-unit>
        <trans-unit id="b6bdd73c5af990a9c308cb3582e6683a673000a9" translate="yes" xml:space="preserve">
          <source>To stop tracking a file that is currently tracked, use &lt;code&gt;git rm --cached&lt;/code&gt;.</source>
          <target state="translated">要停止跟踪当前跟踪的文件，请使用 &lt;code&gt;git rm --cached&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5aabd990937e7026d6c235ccca8da7a1bd54429f" translate="yes" xml:space="preserve">
          <source>To submit all changes that are in the current Git branch but not in the &lt;code&gt;p4/master&lt;/code&gt; branch, use:</source>
          <target state="translated">要提交当前Git分支中而不是 &lt;code&gt;p4/master&lt;/code&gt; 分支中的所有更改，请使用：</target>
        </trans-unit>
        <trans-unit id="4d37523ff8334f7ae27e64b17d4088a430f024d8" translate="yes" xml:space="preserve">
          <source>To submit patches using GMail&amp;rsquo;s IMAP interface, first, edit your ~/.gitconfig to specify your account settings:</source>
          <target state="translated">要使用GMail的IMAP界面提交补丁，请首先编辑〜/ .gitconfig以指定您的帐户设置：</target>
        </trans-unit>
        <trans-unit id="3829362b0206f78fb7e35755e5364f47036b822a" translate="yes" xml:space="preserve">
          <source>To support virtual hosting, an interpolated path template can be used to dynamically construct alternate paths. The template supports %H for the target hostname as supplied by the client but converted to all lowercase, %CH for the canonical hostname, %IP for the server&amp;rsquo;s IP address, %P for the port number, and %D for the absolute path of the named repository. After interpolation, the path is validated against the directory whitelist.</source>
          <target state="translated">为了支持虚拟主机，可以使用内插的路径模板动态构建备用路径。模板支持％H作为客户端提供的目标主机名，但转换为所有小写字母，％CH表示规范的主机名，％IP表示服务器的IP地址，％P表示端口号，％D表示绝对路径命名存储库。插值后，将根据目录白名单验证路径。</target>
        </trans-unit>
        <trans-unit id="5c5bebcfb262219afa24ad57e1be9ff8017de145" translate="yes" xml:space="preserve">
          <source>To switch back to the previous branch before we switched to mytopic (i.e. &quot;master&quot; branch):</source>
          <target state="translated">要切换回我们切换到mytopic之前的分支(即 &quot;主 &quot;分支)。</target>
        </trans-unit>
        <trans-unit id="f604bfa9fc2a5e3a8b43aed4c26f0a58bfbd1e14" translate="yes" xml:space="preserve">
          <source>To tell Git that yes, you really do realize that certain files no longer exist, or that new files should be added, you should use the &lt;code&gt;--remove&lt;/code&gt; and &lt;code&gt;--add&lt;/code&gt; flags respectively.</source>
          <target state="translated">告诉Git是的，您确实意识到某些文件不再存在，或者应该添加新文件，应该分别使用 &lt;code&gt;--remove&lt;/code&gt; 和 &lt;code&gt;--add&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="f3c508cb95e621506ae6e931b2fdadcaba14a047" translate="yes" xml:space="preserve">
          <source>To test the interaction of several topics, merge them into a throw-away branch. You must never base any work on such a branch!</source>
          <target state="translated">要测试几个主题的交互,请将它们合并到一个抛弃式分支中。你绝对不能在这样的分支上做任何工作!</target>
        </trans-unit>
        <trans-unit id="ded44bb687bc8a448accbaa8cf09bc1b10b3ff71" translate="yes" xml:space="preserve">
          <source>To that end, it first finds pairs of commits from both commit ranges that correspond with each other. Two commits are said to correspond when the diff between their patches (i.e. the author information, the commit message and the commit diff) is reasonably small compared to the patches' size. See ``Algorithm`` below for details.</source>
          <target state="translated">为此,它首先从两个提交范围中找到相互对应的提交对。当两个提交的补丁之间的差异(即作者信息、提交信息和提交差异)与补丁的大小相比相当小时,就被认为是对应的。详见下文 &quot;算法&quot;。</target>
        </trans-unit>
        <trans-unit id="28b9a65cbb97d3af18835efd06d4d171278e0508" translate="yes" xml:space="preserve">
          <source>To throw away part of the development, i.e. to assign the &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; to an earlier &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;.</source>
          <target state="translated">放弃部分开发内容，即将&lt;a href=&quot;#def_head&quot;&gt;磁头&lt;/a&gt;分配给较早的&lt;a href=&quot;#def_revision&quot;&gt;修订版&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2857b34f71a88c7afeb725363e4097e2e44ff45" translate="yes" xml:space="preserve">
          <source>To top it all off, even when users finally find working commands, they naturally want to share them. But they may be unaware that their repo didn&amp;rsquo;t have some special cases that someone else&amp;rsquo;s does. So, when someone else with a different repository runs the same commands, they get hit by the problems above. Or, the user just runs commands that really were vetted for special cases, but they run it on a different OS where it doesn&amp;rsquo;t work, as noted above.</source>
          <target state="translated">最重要的是，即使用户最终找到了有效的命令，他们自然也希望共享它们。但是他们可能不知道自己的仓库没有其他人做的特殊情况。因此，当其他人使用不同的存储库运行相同的命令时，他们会受到上述问题的打击。或者，用户仅运行确实经过特殊情况审查的命令，但如上所述，他们在不起作用的其他操作系统上运行该命令。</target>
        </trans-unit>
        <trans-unit id="c4d2ca21938c992db0b3b75cacfc935366e6629e" translate="yes" xml:space="preserve">
          <source>To update and refresh only the files already checked out</source>
          <target state="translated">只更新和刷新已经签出的文件。</target>
        </trans-unit>
        <trans-unit id="a8c26a487a2f6627cb1ef2fcc7d8934daa7b62d0" translate="yes" xml:space="preserve">
          <source>To update and refresh only the files already checked out:</source>
          <target state="translated">只更新和刷新已经签出的文件。</target>
        </trans-unit>
        <trans-unit id="ec65c1043e980aa5b1f1a444793e6e405a4b07fd" translate="yes" xml:space="preserve">
          <source>To update the index with the contents of a new or modified file, use</source>
          <target state="translated">要用新的或修改后的文件内容更新索引,使用</target>
        </trans-unit>
        <trans-unit id="693fe77a3dea0f3b3cf2c4a884d12237d7043db5" translate="yes" xml:space="preserve">
          <source>To update the resulting mine.git repository, you can fetch or pull after replacing the bundle stored at /home/me/tmp/file.bundle with incremental updates.</source>
          <target state="translated">要更新产生的mine.git仓库,你可以在将存储在/home/me/tmp/file.bundle的bundle替换为增量更新后,再取或拉。</target>
        </trans-unit>
        <trans-unit id="7804c7379482ba8df4ffa8604001ea71fae1937a" translate="yes" xml:space="preserve">
          <source>To use &quot;old&quot; and &quot;new&quot; instead of &quot;good&quot; and bad, you must run &lt;code&gt;git
bisect start&lt;/code&gt; without commits as argument and then run the following commands to add the commits:</source>
          <target state="translated">要使用&amp;ldquo;旧&amp;rdquo;和&amp;ldquo;新&amp;rdquo;而不是&amp;ldquo;好&amp;rdquo;和&amp;ldquo;坏&amp;rdquo;，必须运行不带提交的 &lt;code&gt;git bisect start&lt;/code&gt; ，然后运行以下命令来添加提交：</target>
        </trans-unit>
        <trans-unit id="288cf0a04f95ab8d9b3cedc9a80bcb75e1eb91a6" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;git send-email&lt;/code&gt; to send your patches through the GMail SMTP server, edit ~/.gitconfig to specify your account settings:</source>
          <target state="translated">要使用 &lt;code&gt;git send-email&lt;/code&gt; 通过GMail SMTP服务器发送补丁，请编辑〜/ .gitconfig以指定您的帐户设置：</target>
        </trans-unit>
        <trans-unit id="b24b5140a04c50c5ab1f6a8bf4b67a65e4b08446" translate="yes" xml:space="preserve">
          <source>To use a helper, you must first select one to use. Git currently includes the following helpers:</source>
          <target state="translated">要使用助记器,必须先选择一个助记器来使用。目前,Git 包含了以下几个辅助工具。</target>
        </trans-unit>
        <trans-unit id="00e4f18d69f51ffe1eea42af728cb3d7bb0059ec" translate="yes" xml:space="preserve">
          <source>To use the tool, imap.folder and either imap.tunnel or imap.host must be set to appropriate values.</source>
          <target state="translated">要使用该工具,imap.folder和imap.tunnel或imap.host必须设置为适当的值。</target>
        </trans-unit>
        <trans-unit id="8b51a494019812910be0a147154b59e9ef1b84fa" translate="yes" xml:space="preserve">
          <source>To use this mode effectively, you have to make sure &lt;code&gt;all&lt;/code&gt; the branches you would push out are ready to be pushed out before running &lt;code&gt;git push&lt;/code&gt;, as the whole point of this mode is to allow you to push all of the branches in one go. If you usually finish work on only one branch and push out the result, while other branches are unfinished, this mode is not for you. Also this mode is not suitable for pushing into a shared central repository, as other people may add new branches there, or update the tip of existing branches outside your control.</source>
          <target state="translated">为了有效地使用此模式，您必须确保在运行 &lt;code&gt;git push&lt;/code&gt; 之前已准备好将要推出的 &lt;code&gt;all&lt;/code&gt; 分支都推出，因为此模式的要点是允许您一次推送所有分支。如果通常只在一个分支上完成工作并推出结果，而其他分支还没有完成，则此模式不适合您。同样，此模式也不适合推送到共享中央存储库中，因为其他人可能会在其中添加新分支，或在控件外部更新现有分支的尖端。</target>
        </trans-unit>
        <trans-unit id="0db2ead5af506998515a70d6693b9cc78c43968a" translate="yes" xml:space="preserve">
          <source>To verify that &lt;code&gt;master&lt;/code&gt; is indeed a superset of &lt;code&gt;maint&lt;/code&gt;, use git log:</source>
          <target state="translated">要验证 &lt;code&gt;master&lt;/code&gt; 确实是 &lt;code&gt;maint&lt;/code&gt; 的超集，请使用git log：</target>
        </trans-unit>
        <trans-unit id="25e07c07376edb7f994c3289d03610c1335d5288" translate="yes" xml:space="preserve">
          <source>Todo list</source>
          <target state="translated">所有名单</target>
        </trans-unit>
        <trans-unit id="44e89f12173f1b11f3c33dfcf393dbeb53d74231" translate="yes" xml:space="preserve">
          <source>Toggle the pre-push hook (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;). The default is --verify, giving the hook a chance to prevent the push. With --no-verify, the hook is bypassed completely.</source>
          <target state="translated">切换预推钩（请参阅&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;）。默认值为--verify，为挂钩提供了阻止推送的机会。使用--no-verify，挂钩将被完全绕过。</target>
        </trans-unit>
        <trans-unit id="e69b3ac557eee7192f98b057069c2f145301ef39" translate="yes" xml:space="preserve">
          <source>Topic branches</source>
          <target state="translated">主题分支</target>
        </trans-unit>
        <trans-unit id="99011a3381da15bff0042576b0bb55bb6ae9ffd0" translate="yes" xml:space="preserve">
          <source>TortoiseCVS</source>
          <target state="translated">TortoiseCVS</target>
        </trans-unit>
        <trans-unit id="9732ce69da01051c0a62cf40cfeb5063ebcf5c22" translate="yes" xml:space="preserve">
          <source>Trace the evolution of the line range given by &quot;&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;&quot; (or the function name regex &amp;lt;funcname&amp;gt;) within the &amp;lt;file&amp;gt;. You may not give any pathspec limiters. This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and &amp;lt;start&amp;gt; and &amp;lt;end&amp;gt; (or &amp;lt;funcname&amp;gt;) must exist in the starting revision. You can specify this option more than once. Implies &lt;code&gt;--patch&lt;/code&gt;. Patch output can be suppressed using &lt;code&gt;--no-patch&lt;/code&gt;, but other diff formats (namely &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--shortstat&lt;/code&gt;, &lt;code&gt;--dirstat&lt;/code&gt;, &lt;code&gt;--summary&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt;, &lt;code&gt;--name-status&lt;/code&gt;, &lt;code&gt;--check&lt;/code&gt;) are not currently implemented.</source>
          <target state="translated">跟踪&amp;lt;file&amp;gt;中&amp;ldquo; &amp;lt;start&amp;gt;，&amp;lt;end&amp;gt;&amp;rdquo;（或函数名regex &amp;lt;funcname&amp;gt;）给定的行范围的演变。您不得提供任何pathspec限制器。当前，这仅限于从单个修订版开始的遍历，即，您只能提供零个或一个正修订版参数，并且起始版本中必须存在&amp;lt;start&amp;gt;和&amp;lt;end&amp;gt;（或&amp;lt;funcname&amp;gt;）。您可以多次指定此选项。意味着 &lt;code&gt;--patch&lt;/code&gt; 。可以使用 &lt;code&gt;--no-patch&lt;/code&gt; 抑制补丁输出，但可以使用其他差异格式（即 &lt;code&gt;--raw&lt;/code&gt; ，-- &lt;code&gt;--numstat&lt;/code&gt; ，-- &lt;code&gt;--shortstat&lt;/code&gt; ，-- &lt;code&gt;--dirstat&lt;/code&gt; ，-- &lt;code&gt;--summary&lt;/code&gt; ， &lt;code&gt;--name-only&lt;/code&gt; name -only， &lt;code&gt;--name-status&lt;/code&gt; name -status， &lt;code&gt;--check&lt;/code&gt; ）目前尚未实现。</target>
        </trans-unit>
        <trans-unit id="324f1031e6064bf946ba7ad7de400c92a706ee71" translate="yes" xml:space="preserve">
          <source>Trace2 api</source>
          <target state="translated">Trace2 api</target>
        </trans-unit>
        <trans-unit id="f39bab439a6977ac76a84295e79b079d44b7d908" translate="yes" xml:space="preserve">
          <source>Trace2 config settings are only read from the system and global config files; repository local and worktree config files and &lt;code&gt;-c&lt;/code&gt; command line arguments are not respected.</source>
          <target state="translated">Trace2配置设置只能从系统和全局配置文件中读取；不遵守存储库本地和工作树配置文件以及 &lt;code&gt;-c&lt;/code&gt; 命令行参数。</target>
        </trans-unit>
        <trans-unit id="34f4d5fb2d35b898a8c6180c70ae5079360dafe0" translate="yes" xml:space="preserve">
          <source>Trace2 defines the following set of Trace2 Targets. Format details are given in a later section.</source>
          <target state="translated">Trace2 定义了以下一组 Trace2 Targets。格式细节将在后面的章节中给出。</target>
        </trans-unit>
        <trans-unit id="9cffe01770c87380a0c500c2ba4c5fe9919c83ec" translate="yes" xml:space="preserve">
          <source>Trace2 instrumentation throughout the Git code base sends Trace2 messages to the enabled Trace2 Targets. Targets transform these messages content into purpose-specific formats and write events to their data streams. In this manner, the Trace2 API can drive many different types of analysis.</source>
          <target state="translated">Git 代码库中的 Trace2 仪器会向启用的 Trace2 Targets 发送 Trace2 消息。Targets 将这些消息内容转化为特定目的的格式,并将事件写入其数据流。通过这种方式,Trace2 API 可以驱动许多不同类型的分析。</target>
        </trans-unit>
        <trans-unit id="952dc6d60a810a50f48d84409a5ca3162f18abfc" translate="yes" xml:space="preserve">
          <source>Trace2 is controlled using &lt;code&gt;trace2.&lt;/code&gt; config values in the system and global config files and &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variables. Trace2 does not read from repo local or worktree config files or respect &lt;code&gt;-c&lt;/code&gt; command line config settings.</source>
          <target state="translated">使用 &lt;code&gt;trace2.&lt;/code&gt; 控制Trace2。系统和全局配置文件中的配置值以及 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 环境变量。Trace2不会从存储库本地或工作树配置文件中读取数据，也不会遵循 &lt;code&gt;-c&lt;/code&gt; 命令行配置设置。</target>
        </trans-unit>
        <trans-unit id="20f68aac372bbc56e3b5b3e96aea0079529bedb9" translate="yes" xml:space="preserve">
          <source>Trace2 regions are similar to the existing trace_performance_enter() and trace_performance_leave() routines, but are thread safe and maintain per-thread stacks of timers.</source>
          <target state="translated">Trace2区域类似于现有的trace_performance_enter()和trace_performance_leave()例程,但是是线程安全的,并且维护每个线程的定时器堆栈。</target>
        </trans-unit>
        <trans-unit id="8bded73626b8544423d59c1c5a0c1bfb684cb12e" translate="yes" xml:space="preserve">
          <source>Trace2 target formats</source>
          <target state="translated">Trace2目标格式</target>
        </trans-unit>
        <trans-unit id="e4cb4d4e7e519744d1375eb303304baebc567ae9" translate="yes" xml:space="preserve">
          <source>Trace2 targets</source>
          <target state="translated">Trace2目标</target>
        </trans-unit>
        <trans-unit id="a0cfb1f78b98054b282b0aab138d8ea25f2c82bd" translate="yes" xml:space="preserve">
          <source>Tracking and contributing to an entire Subversion-managed project (complete with a trunk, tags and branches):</source>
          <target state="translated">跟踪和贡献于整个Subversion管理的项目(完整的主干、标签和分支)。</target>
        </trans-unit>
        <trans-unit id="847895b0cdb93b975e4c930f95d66dabeb1e64d2" translate="yes" xml:space="preserve">
          <source>Tracking and contributing to the trunk of a Subversion-managed project (ignoring tags and branches):</source>
          <target state="translated">追踪并贡献给Subversion管理的项目主干(忽略标签和分支)。</target>
        </trans-unit>
        <trans-unit id="667c19a45142471c0c20cc605b683a6a3152afb1" translate="yes" xml:space="preserve">
          <source>Traditionally, tips of branches and tags (collectively known as &lt;code&gt;refs&lt;/code&gt;) were stored one file per ref in a (sub)directory under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory. While many branch tips tend to be updated often, most tags and some branch tips are never updated. When a repository has hundreds or thousands of tags, this one-file-per-ref format both wastes storage and hurts performance.</source>
          <target state="translated">传统上，分支和标签的提示（统称为 &lt;code&gt;refs&lt;/code&gt; ）是每个ref文件在 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 目录下的（子）目录中存储一个文件。尽管许多分支提示往往会经常更新，但是大多数标记和某些分支提示从未更新。当存储库具有成百上千个标签时，这种&amp;ldquo;每个引用一个文件&amp;rdquo;的格式既浪费存储空间，又损害性能。</target>
        </trans-unit>
        <trans-unit id="a5cf7db57e9cf074478d171148671cc677faf56a" translate="yes" xml:space="preserve">
          <source>Trailing spaces are ignored unless they are quoted with backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;).</source>
          <target state="translated">除非用反斜杠（&amp;ldquo; &lt;code&gt;\&lt;/code&gt; &amp;rdquo;）引号，否则将忽略尾随空格。</target>
        </trans-unit>
        <trans-unit id="18baa50eee1aac68104e16bd4ad94c661cde3869" translate="yes" xml:space="preserve">
          <source>Transfer size: In its current form Git requires the whole working tree present. It does not allow partial trees to be transferred in fetch or clone. If the project you work on consists of multiple repositories tied together as submodules in a superproject, you can avoid fetching the working trees of the repositories you are not interested in.</source>
          <target state="translated">传输大小。在目前的形式下,Git需要整个工作树的存在。它不允许在fetch或clone中传输部分工作树。如果你的项目由多个仓库组成,并作为超级项目的子模块,你可以避免获取你不感兴趣的仓库的工作树。</target>
        </trans-unit>
        <trans-unit id="bdf6a912dffd18ed6042052fce8610d96ce56a71" translate="yes" xml:space="preserve">
          <source>Transform stdin by substituting all the 40-character SHA-1 hexes (say $hex) with &quot;$hex ($rev_name)&quot;. When used with --name-only, substitute with &quot;$rev_name&quot;, omitting $hex altogether. Intended for the scripter&amp;rsquo;s use.</source>
          <target state="translated">通过用&amp;ldquo; $ hex（$ rev_name）&amp;rdquo;替换所有40个字符的SHA-1十六进​​制（例如$ hex）来转换stdin。当与--name-only一起使用时，用&amp;ldquo; $ rev_name&amp;rdquo;代替，完全省略$ hex。供脚本编写者使用。</target>
        </trans-unit>
        <trans-unit id="fc873c381aea0c960eb3ebd47773defb66d7e124" translate="yes" xml:space="preserve">
          <source>Transmit &amp;lt;string&amp;gt; as a push option. As the push option must not contain LF or NUL characters, the string is not encoded.</source>
          <target state="translated">传输&amp;lt;string&amp;gt;作为推送选项。由于push选项中不得包含LF或NUL字符，因此不会对字符串进行编码。</target>
        </trans-unit>
        <trans-unit id="32bd61986aca00f68612950bbcdb4915d3d0e846" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. The server&amp;rsquo;s handling of server options, including unknown ones, is server-specific. When multiple &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line.</source>
          <target state="translated">使用协议版本2进行通信时，将给定的字符串传输到服务器。给定的字符串不得包含NUL或LF字符。服务器对服务器选项（包括未知选项）的处理是特定于服务器的。当给出多个 &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; 时，它们都将按照命令行中列出的顺序发送到另一端。</target>
        </trans-unit>
        <trans-unit id="39635a03df29b9789e505a1038590e24ea96c9e9" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. When multiple &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line.</source>
          <target state="translated">使用协议版本2进行通信时，将给定的字符串传输到服务器。给定的字符串不得包含NUL或LF字符。当给出多个 &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; 时，它们都将按照命令行中列出的顺序发送到另一端。</target>
        </trans-unit>
        <trans-unit id="2995fbcc2c84443582483713456b482a39b63e37" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character. When multiple &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line. When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; is given from the command line, the values of configuration variable &lt;code&gt;push.pushOption&lt;/code&gt; are used instead.</source>
          <target state="translated">将给定的字符串发送到服务器，服务器将它们传递到接收前和接收后钩子。给定的字符串不得包含NUL或LF字符。当给出多个 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 时，它们都将按照命令行中列出的顺序发送到另一端。如果在命令行中未提供 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; ， &lt;code&gt;push.pushOption&lt;/code&gt; 使用配置变量push.pushOption的值。</target>
        </trans-unit>
        <trans-unit id="9960fbc3363c91bebbbc4dae3127f4935a1a22d6" translate="yes" xml:space="preserve">
          <source>Treat all files as text.</source>
          <target state="translated">将所有文件视为文本。</target>
        </trans-unit>
        <trans-unit id="a08e9c61e543dccc4a24afe7a10c95737cbb1ca7" translate="yes" xml:space="preserve">
          <source>Treat pathspecs literally (i.e. no globbing, no pathspec magic). This is equivalent to setting the &lt;code&gt;GIT_LITERAL_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">从字面上对待pathspec（即，不要乱扔，没有pathspec魔术）。这等效于将 &lt;code&gt;GIT_LITERAL_PATHSPECS&lt;/code&gt; 环境变量设置为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8024445062b4bb90b2e84a4da6e0bb207f37b5f4" translate="yes" xml:space="preserve">
          <source>Treat the &amp;lt;string&amp;gt; given to &lt;code&gt;-S&lt;/code&gt; as an extended POSIX regular expression to match.</source>
          <target state="translated">将给予 &lt;code&gt;-S&lt;/code&gt; 的&amp;lt;string&amp;gt; 视为匹配的扩展POSIX正则表达式。</target>
        </trans-unit>
        <trans-unit id="72315ec1092243bb561e5b4697869abb3601099e" translate="yes" xml:space="preserve">
          <source>Treat the repository as a bare repository. If GIT_DIR environment is not set, it is set to the current working directory.</source>
          <target state="translated">将版本库作为裸库处理,如果没有设置GIT_DIR环境,则设置为当前工作目录。如果没有设置GIT_DIR环境,则设置为当前工作目录。</target>
        </trans-unit>
        <trans-unit id="1dad3a3b77cbf00bf58d87ee853af6d3cddb344a" translate="yes" xml:space="preserve">
          <source>Treat the revision argument as a &amp;lt;revision range&amp;gt;, even if it is just a single commit (that would normally be treated as a &amp;lt;since&amp;gt;). Note that root commits included in the specified range are always formatted as creation patches, independently of this flag.</source>
          <target state="translated">将修订版参数视为&amp;lt;修订版范围&amp;gt;，即使它只是一次提交（通常将被视为&amp;lt;since&amp;gt;）。请注意，包含在指定范围内的root提交始终被格式化为创建补丁，而与该标志无关。</target>
        </trans-unit>
        <trans-unit id="aa88eae97d6ad1936bc41000081122649aee8d74" translate="yes" xml:space="preserve">
          <source>Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;-b&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, &lt;code&gt;--ignore-space-at-eol&lt;/code&gt;, and &lt;code&gt;--ignore-cr-at-eol&lt;/code&gt;.</source>
          <target state="translated">为了进行三向合并，将具有指定空白类型更改的行视为未更改。空格更改与行的其他更改混合在一起将不被忽略。另请参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;-b&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; ，-- &lt;code&gt;--ignore-space-at-eol&lt;/code&gt; 和 &lt;code&gt;--ignore-cr-at-eol&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ddd0e484558c1f8e50a8fe3c2dc7499225a9297" translate="yes" xml:space="preserve">
          <source>Tree Object</source>
          <target state="translated">树形对象</target>
        </trans-unit>
        <trans-unit id="bce93b7f9d4c3064a3f582b574710500d7e5efb5" translate="yes" xml:space="preserve">
          <source>Tree and blob objects outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; will be treated the same way as if they were inside &lt;code&gt;refs/tags/*&lt;/code&gt;, any update of them will be rejected.</source>
          <target state="translated">&lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 之外的tree和blob对象将被视为与 &lt;code&gt;refs/tags/*&lt;/code&gt; 内的对象相同的方式对待，否则将拒绝更新它们。</target>
        </trans-unit>
        <trans-unit id="faed43d5018a65bdda1021ea817b81efdd882a1f" translate="yes" xml:space="preserve">
          <source>Tree objects as well as tag objects not pointing at commits, cannot be described. When describing blobs, the lightweight tags pointing at blobs are ignored, but the blob is still described as &amp;lt;committ-ish&amp;gt;:&amp;lt;path&amp;gt; despite the lightweight tag being favorable.</source>
          <target state="translated">无法描述树对象以及未指向提交的标记对象。在描述blob时，指向blob的轻量级标签将被忽略，但是尽管该轻量级标签是有利的，但该blob仍被描述为&amp;lt;committ-ish&amp;gt;：&amp;lt;path&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="d94a666a1561928de12071aa36f46464acd70f54" translate="yes" xml:space="preserve">
          <source>Tree to checkout from (when paths are given). If not specified, the index will be used.</source>
          <target state="translated">签出的树(给定路径时)。如果没有指定,将使用索引。</target>
        </trans-unit>
        <trans-unit id="fef8232d1c67b8b3403ba454c8ae3c965dc5fb72" translate="yes" xml:space="preserve">
          <source>Trees (aka directories) use just 12 bytes of memory on top of the memory required for their entries (see &amp;ldquo;per active file&amp;rdquo; below). The cost of a tree is virtually 0, as its overhead amortizes out over the individual file entries.</source>
          <target state="translated">树（又名目录）仅在其条目所需的内存之上使用12个字节的内存（请参见下面的&amp;ldquo;每个活动文件&amp;rdquo;）。一棵树的成本实际上为0，因为其开销在各个文件条目上摊销。</target>
        </trans-unit>
        <trans-unit id="8797468d6463e4f71332170d9f50ca7fd321cc3a" translate="yes" xml:space="preserve">
          <source>Trivial merges are done by &lt;code&gt;git read-tree&lt;/code&gt; itself. Only conflicting paths will be in unmerged state when &lt;code&gt;git read-tree&lt;/code&gt; returns.</source>
          <target state="translated">琐碎的合并由 &lt;code&gt;git read-tree&lt;/code&gt; 本身完成。 &lt;code&gt;git read-tree&lt;/code&gt; 返回时，只有冲突的路径才会处于未合并状态。</target>
        </trans-unit>
        <trans-unit id="c14d8e783a9f521d30b73eb971eac8f82acc62a0" translate="yes" xml:space="preserve">
          <source>True merge</source>
          <target state="translated">真正的合并</target>
        </trans-unit>
        <trans-unit id="33a579ffc0dccbff15be01734ea4138ea4e7635c" translate="yes" xml:space="preserve">
          <source>Trust</source>
          <target state="translated">Trust</target>
        </trans-unit>
        <trans-unit id="df8a0e781552ee165e12d7086194c5f37262dc36" translate="yes" xml:space="preserve">
          <source>Try to speed up the traversal using the pack bitmap index (if one is available). Note that when traversing with &lt;code&gt;--objects&lt;/code&gt;, trees and blobs will not have their associated path printed.</source>
          <target state="translated">尝试使用包位图索引（如果有）来加快遍历速度。请注意，使用 &lt;code&gt;--objects&lt;/code&gt; 遍历时，树和blob将不会打印其关联路径。</target>
        </trans-unit>
        <trans-unit id="db494399fc91d335ea933090c261cf51f7615da6" translate="yes" xml:space="preserve">
          <source>Try to update from the upstream resulted in a lot of conflicts; you were not ready to spend a lot of time merging right now, so you decide to do that later.</source>
          <target state="translated">尝试从上游更新导致了很多冲突,你现在还没准备好花大量时间合并,所以你决定以后再做。</target>
        </trans-unit>
        <trans-unit id="3a12d2b4901990f4e580a360ff850809fe3f67b9" translate="yes" xml:space="preserve">
          <source>Turn off any previous &lt;code&gt;--filter=&lt;/code&gt; argument.</source>
          <target state="translated">关闭任何以前的 &lt;code&gt;--filter=&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="34771065d121fc03fac8d38d540e254893826329" translate="yes" xml:space="preserve">
          <source>Turn off branch colors, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">即使配置文件将颜色输出设置为默认值，也要关闭分支颜色。与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="6d9cbb32ce6c68e264cdb30b91e954cf183958d3" translate="yes" xml:space="preserve">
          <source>Turn off colored diff. It is the same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">关闭彩色差异。它与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="3d9b2354f095eeb41acddbf4f3d69d4ac5775813" translate="yes" xml:space="preserve">
          <source>Turn off colored diff. This can be used to override configuration settings. It is the same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">关闭彩色差异。这可用于覆盖配置设置。它与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="8ad464ef4a6c59cdcb2319e829113b9b9a0202fe" translate="yes" xml:space="preserve">
          <source>Turn off colored output, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">即使配置文件将默认设置为彩色输出，也要关闭彩色输出。与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="a3a997309d5fb6a6ca30f0f6201f278a284d8e1e" translate="yes" xml:space="preserve">
          <source>Turn off match highlighting, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">即使配置文件将颜色输出设置为默认值，也要关闭匹配突出显示。与 &lt;code&gt;--color=never&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d4fab0f230de92fdcff08739247b39013a4dcf91" translate="yes" xml:space="preserve">
          <source>Turn off move detection. This can be used to override configuration settings. It is the same as &lt;code&gt;--color-moved=no&lt;/code&gt;.</source>
          <target state="translated">关闭移动检测。这可用于覆盖配置设置。与 &lt;code&gt;--color-moved=no&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b0eb0b106db412297afc722cb22850ad8fd89466" translate="yes" xml:space="preserve">
          <source>Turn off rename detection, even when the configuration file gives the default to do so.</source>
          <target state="translated">关闭重命名检测,即使配置文件给出的默认是这样做。</target>
        </trans-unit>
        <trans-unit id="4e867193eda90e02a99d5e3b2d3aff016424ee32" translate="yes" xml:space="preserve">
          <source>Turn off rename detection. This overrides the &lt;code&gt;merge.renames&lt;/code&gt; configuration variable. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--no-renames&lt;/code&gt;.</source>
          <target state="translated">关闭重命名检测。这将覆盖 &lt;code&gt;merge.renames&lt;/code&gt; 配置变量。另请参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--no-renames&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29eb4a9a74bb1156273caaa264fc85825c0572ef" translate="yes" xml:space="preserve">
          <source>Turn on rename detection, optionally setting the similarity threshold. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--find-renames&lt;/code&gt;.</source>
          <target state="translated">打开重命名检测，可以选择设置相似性阈值。另见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--find-renames&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a279dbfc86c680add56c7a5993ef6023dec20637" translate="yes" xml:space="preserve">
          <source>Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the &lt;code&gt;merge.renames&lt;/code&gt; configuration variable. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--find-renames&lt;/code&gt;.</source>
          <target state="translated">打开重命名检测，可以选择设置相似性阈值。这是默认值。这将覆盖 &lt;code&gt;merge.renames&lt;/code&gt; 配置变量。另见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--find-renames&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9d077a66918e3017c929a4d5ef75e05f491a825" translate="yes" xml:space="preserve">
          <source>Turn on/off rename detection regardless of user configuration. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--no-renames&lt;/code&gt;.</source>
          <target state="translated">无论用户配置如何，都可以打开/关闭重命名检测。另请参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--no-renames&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff597cb2e8f500da1bb43f369ea55f0017801fbc" translate="yes" xml:space="preserve">
          <source>Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal.</source>
          <target state="translated">明确开启/关闭进度。如果两者都不指定,如果标准误差连接到终端,则显示进度。</target>
        </trans-unit>
        <trans-unit id="b63e204e5b5bb236923126ba202fed353f8079ec" translate="yes" xml:space="preserve">
          <source>Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal. Note that not all merge strategies may support progress reporting.</source>
          <target state="translated">明确开启/关闭进度。如果两者都不指定,如果标准误差连接到终端,则显示进度。注意,并非所有的合并策略都支持进度报告。</target>
        </trans-unit>
        <trans-unit id="ae22b8d4ecb731b706e41a653df929373ee8e8e0" translate="yes" xml:space="preserve">
          <source>Turns off any previous &lt;code&gt;--filter=&lt;/code&gt; argument.</source>
          <target state="translated">关闭任何以前的 &lt;code&gt;--filter=&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="aef2d842e6b781b12f96bc62f4ab607c12e12218" translate="yes" xml:space="preserve">
          <source>Two Tree Merge</source>
          <target state="translated">双树合并</target>
        </trans-unit>
        <trans-unit id="6bda5442e87e811366b94ce6966009ecac6ac5dc" translate="yes" xml:space="preserve">
          <source>Two consecutive asterisks (&quot;&lt;code&gt;**&lt;/code&gt;&quot;) in patterns matched against full pathname may have special meaning:</source>
          <target state="translated">模式中与完整路径名匹配的两个连续星号（&amp;ldquo; &lt;code&gt;**&lt;/code&gt; &amp;rdquo;）可能具有特殊含义：</target>
        </trans-unit>
        <trans-unit id="e187ca5222f2f1c9a298321896225faf75c5697a" translate="yes" xml:space="preserve">
          <source>Two consecutive asterisks (&amp;ldquo;**&amp;rdquo;) in patterns matched against full pathname may have special meaning:</source>
          <target state="translated">与完整路径名匹配的模式中的两个连续星号（&amp;ldquo; **&amp;rdquo;）可能具有特殊含义：</target>
        </trans-unit>
        <trans-unit id="fce699584c34eaef39ec9c341ad51961e194a419" translate="yes" xml:space="preserve">
          <source>Two special values are supported: &lt;code&gt;off&lt;/code&gt; will simply close the corresponding standard handle, and if &lt;code&gt;GIT_REDIRECT_STDERR&lt;/code&gt; is &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;, standard error will be redirected to the same handle as standard output.</source>
          <target state="translated">支持两个特殊值： &lt;code&gt;off&lt;/code&gt; 将仅关闭相应的标准句柄，并且如果 &lt;code&gt;GIT_REDIRECT_STDERR&lt;/code&gt; 为 &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; ，则将标准错误重定向到与标准输出相同的句柄。</target>
        </trans-unit>
        <trans-unit id="34a739d621f3038babff4f0f681d077135e77a75" translate="yes" xml:space="preserve">
          <source>Two things are interesting here:</source>
          <target state="translated">这里有两件事很有意思。</target>
        </trans-unit>
        <trans-unit id="ced48512ad4d3cb13ca20b7cb1f2f8e4abd0bc9d" translate="yes" xml:space="preserve">
          <source>Tying it all together</source>
          <target state="translated">把所有的事情联系在一起</target>
        </trans-unit>
        <trans-unit id="3a87a5a93967e0c0facb5bdbedab0a6936494920" translate="yes" xml:space="preserve">
          <source>Type 5 is reserved for future expansion. Type 0 is invalid.</source>
          <target state="translated">类型5是为将来的扩展保留的。类型0是无效的。</target>
        </trans-unit>
        <trans-unit id="e8e8d3184972cec12ef3bd94d7eec7947cbe4b53" translate="yes" xml:space="preserve">
          <source>Typical gitweb config files will only change starting (default) time zone, and leave other elements at their default values:</source>
          <target state="translated">典型的gitweb配置文件只会改变起始(默认)时区,而让其他元素保持默认值。</target>
        </trans-unit>
        <trans-unit id="3aa25a3911a2da2f000729dbc451ee040fee4a66" translate="yes" xml:space="preserve">
          <source>Typical usage is something like:</source>
          <target state="translated">典型的用法是这样的。</target>
        </trans-unit>
        <trans-unit id="db1f5b1028dc570d4bb8caccd45a45601a38210c" translate="yes" xml:space="preserve">
          <source>Typical use of git credential</source>
          <target state="translated">git证书的典型用法</target>
        </trans-unit>
        <trans-unit id="d63a8a509d39725ec5fc85189ba54ffbab2dd0bb" translate="yes" xml:space="preserve">
          <source>Typically it will be placed in a MUA&amp;rsquo;s drafts folder, edited to add timely commentary that should not go in the changelog after the three dashes, and then sent as a message whose body, in our example, starts with &quot;arch/arm config files were&amp;hellip;​&quot;. On the receiving end, readers can save interesting patches in a UNIX mailbox and apply them with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;.</source>
          <target state="translated">通常，它将放置在MUA的drafts文件夹中，进行编辑以添加及时的注释，该注释不应在三个破折号之后出现在变更日志中，然后作为消息发送，其主体在我们的示例中以&amp;ldquo; arch / arm配置文件开头&amp;hellip;&amp;rdquo;。在接收端，读者可以将有趣的补丁程序保存在UNIX邮箱中，并通过&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;应用它们。</target>
        </trans-unit>
        <trans-unit id="3b51965ce078cc4b0d9ecb0a1b113a383a8700dc" translate="yes" xml:space="preserve">
          <source>Typically such a variable may look like this:</source>
          <target state="translated">一般来说,这样的变量可能是这样的。</target>
        </trans-unit>
        <trans-unit id="9f47be9cc1e7fcec80fcc7e52dcbd486a27d2ee2" translate="yes" xml:space="preserve">
          <source>Typically this is run with a script calling Git&amp;rsquo;s imitation of the &lt;code&gt;merge&lt;/code&gt; command from the RCS package.</source>
          <target state="translated">通常，这是通过脚本调用Git模仿RCS包中的 &lt;code&gt;merge&lt;/code&gt; 命令来运行的。</target>
        </trans-unit>
        <trans-unit id="e4333d902cedfd0d4739277fdec621b3f9f09422" translate="yes" xml:space="preserve">
          <source>Typically this matches the real type of &amp;lt;object&amp;gt; but asking for a type that can trivially be dereferenced from the given &amp;lt;object&amp;gt; is also permitted. An example is to ask for a &quot;tree&quot; with &amp;lt;object&amp;gt; being a commit object that contains it, or to ask for a &quot;blob&quot; with &amp;lt;object&amp;gt; being a tag object that points at it.</source>
          <target state="translated">通常，它与&amp;lt;object&amp;gt;的实际类型匹配，但是也允许要求可以从给定的&amp;lt;object&amp;gt;取消引用的类型。一个示例是要求一个带有&amp;lt;object&amp;gt;作为包含它的提交对象的&amp;ldquo;树&amp;rdquo;，或者要求一个带有&amp;lt;object&amp;gt;是指向它的标记对象的&amp;ldquo; blob&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6b016c5601edd059fd8dc12bb8d8426b6525fff2" translate="yes" xml:space="preserve">
          <source>Typically you would first remove all tracked files from the working tree using this command:</source>
          <target state="translated">通常情况下,你会先用这个命令从工作树中删除所有跟踪的文件。</target>
        </trans-unit>
        <trans-unit id="3a2ee6ee14f11a86e1818d26c21e9493d38718f1" translate="yes" xml:space="preserve">
          <source>Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel.</source>
          <target state="translated">通常情况下,并行递归和多远程的获取会更快。默认情况下,检索是按顺序执行的,而不是并行的。</target>
        </trans-unit>
        <trans-unit id="94e92e77c127b9c8a314ec2c48c4916e008c6404" translate="yes" xml:space="preserve">
          <source>Typically, this is invoked as &lt;code&gt;git read-tree -m $H $M&lt;/code&gt;, where $H is the head commit of the current repository, and $M is the head of a foreign tree, which is simply ahead of $H (i.e. we are in a fast-forward situation).</source>
          <target state="translated">通常，这是作为 &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; 调用的，其中$ H是当前存储库的头提交，而$ M是外来树的头，仅在$ H之前（即，处于快速发展的状态）。</target>
        </trans-unit>
        <trans-unit id="0ada5827188094ef6e82c28e45e078ca96f54ca4" translate="yes" xml:space="preserve">
          <source>U: file is unmerged (you must complete the merge before it can be committed)</source>
          <target state="translated">U:文件未合并(必须在提交前完成合并)</target>
        </trans-unit>
        <trans-unit id="1a7a0d0dd35212ae4c8c4c873315c6e7e9351f3b" translate="yes" xml:space="preserve">
          <source>URI and label (title) for the Git logo link (or your site logo, if you chose to use different logo image). By default, these both refer to Git homepage, &lt;a href=&quot;https://git-scm.com&quot;&gt;https://git-scm.com&lt;/a&gt;; in the past, they pointed to Git documentation at &lt;a href=&quot;https://www.kernel.org&quot;&gt;https://www.kernel.org&lt;/a&gt;.</source>
          <target state="translated">Git徽标链接（或站点徽标，如果您选择使用其他徽标图像）的URI和标签（标题）。默认情况下，它们都指向Git主页&lt;a href=&quot;https://git-scm.com&quot;&gt;https://git-scm.com&lt;/a&gt; ; 过去，他们指向&lt;a href=&quot;https://www.kernel.org&quot;&gt;https://www.kernel.org&lt;/a&gt;上的Git文档。</target>
        </trans-unit>
        <trans-unit id="8561702ffd22bbb5ccd1a81c9c8d8cc77f16fa7e" translate="yes" xml:space="preserve">
          <source>Un-sets the previously set type specifier (if one was previously set). This option requests that &lt;code&gt;git config&lt;/code&gt; not canonicalize the retrieved variable. &lt;code&gt;--no-type&lt;/code&gt; has no effect without &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; or &lt;code&gt;--&amp;lt;type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">取消设置先前设置的类型说明符（如果先前已设置）。此选项要求 &lt;code&gt;git config&lt;/code&gt; 不规范检索到的变量。没有 &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; 或 &lt;code&gt;--&amp;lt;type&amp;gt;&lt;/code&gt; no &lt;code&gt;--no-type&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="911839695653d988872929c95814b8902e300040" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--pretty=oneline&lt;/code&gt;, the commit message is prefixed with this information on the same line. This option cannot be combined with &lt;code&gt;--reverse&lt;/code&gt;. See also &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;--pretty=oneline&lt;/code&gt; 下，提交消息在同一行上带有此信息的前缀。此选项不能与 &lt;code&gt;--reverse&lt;/code&gt; 结合使用。另见&lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64ba59969ba5a36d002d9a189101c624fcf7d3cc" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--pretty=reference&lt;/code&gt;, this information will not be shown at all.</source>
          <target state="translated">在 &lt;code&gt;--pretty=reference&lt;/code&gt; 下，此信息将完全不显示。</target>
        </trans-unit>
        <trans-unit id="c73a6e04cc57ad10ee4ae7284f559a5ae2a53d36" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, some versions of &lt;code&gt;diff&lt;/code&gt; do not correctly detect a missing new-line at the end of the file. As a result, patches created by such &lt;code&gt;diff&lt;/code&gt; programs do not record incomplete lines correctly. This option adds support for applying such patches by working around this bug.</source>
          <target state="translated">在某些情况下，某些版本的 &lt;code&gt;diff&lt;/code&gt; 无法正确检测到文件末尾缺少的换行符。结果，由此类 &lt;code&gt;diff&lt;/code&gt; 程序创建的补丁无法正确记录不完整的行。通过解决此错误，此选项增加了对应用此类修补程序的支持。</target>
        </trans-unit>
        <trans-unit id="67a27dbf5548d05ac63e85bd8b4c875d8f48c102" translate="yes" xml:space="preserve">
          <source>Understanding History: Commits</source>
          <target state="translated">了解历史。承诺</target>
        </trans-unit>
        <trans-unit id="9334dba95d5dfb2042093dd9adbddea5f77c5eb4" translate="yes" xml:space="preserve">
          <source>Understanding history: History diagrams</source>
          <target state="translated">了解历史。历史图表</target>
        </trans-unit>
        <trans-unit id="85bd1a7ea75afef7e0417cd2bf9d9f3cf13e5e08" translate="yes" xml:space="preserve">
          <source>Understanding history: What is a branch?</source>
          <target state="translated">了解历史。什么是分支?</target>
        </trans-unit>
        <trans-unit id="6d61d96a492f996316f1e84e66cbfde933315e2c" translate="yes" xml:space="preserve">
          <source>Understanding history: commits, parents, and reachability</source>
          <target state="translated">了解历史:承诺、父母和可达到性。</target>
        </trans-unit>
        <trans-unit id="afa47a28efb9d6631a7be02ac359bed5256995ce" translate="yes" xml:space="preserve">
          <source>Undo a commit and redo</source>
          <target state="translated">撤销提交并重做</target>
        </trans-unit>
        <trans-unit id="61cb90c052dfcd0fda883c6029d1d0fc0a0f4685" translate="yes" xml:space="preserve">
          <source>Undo a commit, making it a topic branch</source>
          <target state="translated">撤销提交,使其成为一个主题分支。</target>
        </trans-unit>
        <trans-unit id="93d74feb000c815128d68a09c83733db43b69c15" translate="yes" xml:space="preserve">
          <source>Undo a merge or pull</source>
          <target state="translated">撤销合并或拉动</target>
        </trans-unit>
        <trans-unit id="4728c70cd06347b5f285fb3e7887387303b3968e" translate="yes" xml:space="preserve">
          <source>Undo a merge or pull inside a dirty working tree</source>
          <target state="translated">撤销合并或拉入脏工作树内的操作。</target>
        </trans-unit>
        <trans-unit id="27b7abb5b90b7a2e8f00eaf74b6df8323ba7d926" translate="yes" xml:space="preserve">
          <source>Undo add</source>
          <target state="translated">撤销添加</target>
        </trans-unit>
        <trans-unit id="ca677a11d37ffdca5231911a194cc2fcdffc5a26" translate="yes" xml:space="preserve">
          <source>Undo commits permanently</source>
          <target state="translated">永久撤销承诺</target>
        </trans-unit>
        <trans-unit id="4180759bca2f04cde0ec69611cb0e0ec1cfe7139" translate="yes" xml:space="preserve">
          <source>Undoes the effects of &lt;code&gt;fetch&lt;/code&gt; back to the specified revision. This allows you to re-&lt;code&gt;fetch&lt;/code&gt; an SVN revision. Normally the contents of an SVN revision should never change and &lt;code&gt;reset&lt;/code&gt; should not be necessary. However, if SVN permissions change, or if you alter your --ignore-paths option, a &lt;code&gt;fetch&lt;/code&gt; may fail with &quot;not found in commit&quot; (file not previously visible) or &quot;checksum mismatch&quot; (missed a modification). If the problem file cannot be ignored forever (with --ignore-paths) the only way to repair the repo is to use &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">撤消 &lt;code&gt;fetch&lt;/code&gt; 指定修订的影响。这使您可以 &lt;code&gt;fetch&lt;/code&gt; SVN修订版。通常，SVN修订版的内容永远不应该更改，也不必 &lt;code&gt;reset&lt;/code&gt; 。但是，如果SVN权限发生更改，或者更改了--ignore-paths选项，则 &lt;code&gt;fetch&lt;/code&gt; 可能会失败，并显示&amp;ldquo;未在提交中找到&amp;rdquo;（以前不可见的文件）或&amp;ldquo;校验和不匹配&amp;rdquo;（缺少修改）。如果无法永久忽略问题文件（使用--ignore-paths），则修复存储库的唯一方法是使用 &lt;code&gt;reset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac1f58f831611819b4114b80dd55e3ce540d5b23" translate="yes" xml:space="preserve">
          <source>Undoing a merge</source>
          <target state="translated">撤销合并</target>
        </trans-unit>
        <trans-unit id="f552d5a5802e3df6273c784214def9840b82f594" translate="yes" xml:space="preserve">
          <source>Unfortunately this system becomes inefficient once a project has a lot of objects. Try this on an old project:</source>
          <target state="translated">不幸的是,一旦一个项目有很多对象,这个系统就会变得效率低下。在一个旧项目上试试这个。</target>
        </trans-unit>
        <trans-unit id="c7deb06b3e42a38e2b00598939aa39f8d24897bd" translate="yes" xml:space="preserve">
          <source>Unfortunately, the desired effect of cleaning up text files with mixed line endings and the undesired effect of corrupting binary files cannot be distinguished. In both cases CRLFs are removed in an irreversible way. For text files this is the right thing to do because CRLFs are line endings, while for binary files converting CRLFs corrupts data.</source>
          <target state="translated">遗憾的是,清理行尾混杂的文本文件的理想效果和破坏二进制文件的不理想效果无法区分。在这两种情况下,CRLFs都是以一种不可逆的方式被删除的。对于文本文件来说,这是正确的做法,因为CRLFs是行尾,而对于二进制文件来说,转换CRLFs会破坏数据。</target>
        </trans-unit>
        <trans-unit id="6da1ce58d3a6c34c76807dc44593d7cd8c6563b6" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;--text&lt;/code&gt; is supplied patches of binary files without a textconv filter will be ignored.</source>
          <target state="translated">除非提供了 &lt;code&gt;--text&lt;/code&gt; ,否则将忽略不具有textconv过滤器的二进制文件补丁。</target>
        </trans-unit>
        <trans-unit id="54cbf98b314812a07f65f95ae77e8608ddf0b26f" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-f&lt;/code&gt; is given, the &lt;code&gt;replace&lt;/code&gt; reference must not yet exist.</source>
          <target state="translated">除非给出 &lt;code&gt;-f&lt;/code&gt; ，否则 &lt;code&gt;replace&lt;/code&gt; 引用必须不存在。</target>
        </trans-unit>
        <trans-unit id="ec0a9816e3fe8947b4bfff6f5914c3288bed6fc9" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-f&lt;/code&gt; is given, the named tag must not yet exist.</source>
          <target state="translated">除非给出 &lt;code&gt;-f&lt;/code&gt; ，否则命名标记必须还不存在。</target>
        </trans-unit>
        <trans-unit id="7824ccb45f3d7be1fd07def25712792fbdf3f009" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git blame&lt;/code&gt; and &lt;code&gt;git annotate&lt;/code&gt; in older versions of git, the extent of the annotation can be limited to both line ranges and revision ranges. The &lt;code&gt;-L&lt;/code&gt; option, which limits annotation to a range of lines, may be specified multiple times.</source>
          <target state="translated">与 &lt;code&gt;git blame&lt;/code&gt; 和 &lt;code&gt;git annotate&lt;/code&gt; 在较早版本的git中不同，注释的范围可以限于行范围和修订范围。的 &lt;code&gt;-L&lt;/code&gt; 选项，这限制了注释的行范围的，可被指定多次。</target>
        </trans-unit>
        <trans-unit id="1fa5e3a4c28161d2ef67ee80d5624341cfa56be1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git diff-files&lt;/code&gt;, which showed the difference between the index file and the working tree, &lt;code&gt;git diff-index&lt;/code&gt; shows the differences between a committed &lt;strong&gt;tree&lt;/strong&gt; and either the index file or the working tree. In other words, &lt;code&gt;git diff-index&lt;/code&gt; wants a tree to be diffed against, and before we did the commit, we couldn&amp;rsquo;t do that, because we didn&amp;rsquo;t have anything to diff against.</source>
          <target state="translated">与 &lt;code&gt;git diff-files&lt;/code&gt; 不同，后者显示了索引文件和工作树之间的 &lt;code&gt;git diff-index&lt;/code&gt; ，而git diff-index显示了已提交的&lt;strong&gt;树&lt;/strong&gt;与索引文件或工作树之间的差异。换句话说， &lt;code&gt;git diff-index&lt;/code&gt; 希望与一棵树进行比较，而在我们提交之前，我们无法做到这一点，因为我们没有任何要针对的。</target>
        </trans-unit>
        <trans-unit id="a75073ebd9356a7219cb30b4bb866c17ce8b906c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;gitk&lt;/code&gt;, &lt;code&gt;git gui&lt;/code&gt; focuses on commit generation and single file annotation and does not show project history. It does however supply menu actions to start a &lt;code&gt;gitk&lt;/code&gt; session from within &lt;code&gt;git gui&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;gitk&lt;/code&gt; 不同， &lt;code&gt;git gui&lt;/code&gt; 专注于提交生成和单个文件注释，并且不显示项目历史记录。但是，它确实提供了菜单操作以从 &lt;code&gt;git gui&lt;/code&gt; 内部启动 &lt;code&gt;gitk&lt;/code&gt; 会话。</target>
        </trans-unit>
        <trans-unit id="cd17281830ac5a9aa50c0d768481eabf04240182" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;raw&lt;/code&gt; format above, the time zone/UTC offset information contained in an RFC 2822 date string is used to adjust the date value to UTC prior to storage. Therefore it is important that this information be as accurate as possible.</source>
          <target state="translated">与上面的 &lt;code&gt;raw&lt;/code&gt; 格式不同，RFC 2822日期字符串中包含的时区/ UTC偏移信息用于在存储之前将日期值调整为UTC。因此，重要的是此信息应尽可能准确。</target>
        </trans-unit>
        <trans-unit id="422977ffd462a03a6cbce65db58b07001eb2214f" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;rfc2822&lt;/code&gt; format, this format is very strict. Any variation in formatting will cause fast-import to reject the value.</source>
          <target state="translated">与 &lt;code&gt;rfc2822&lt;/code&gt; 格式不同，此格式非常严格。格式上的任何变化都将导致快速导入拒绝该值。</target>
        </trans-unit>
        <trans-unit id="a5e8af576412d2facd9f39a0996da0da165c42ee" translate="yes" xml:space="preserve">
          <source>Unlike the Porcelain format, the filename information is always given and terminates the entry:</source>
          <target state="translated">与瓷器格式不同的是,总是给出文件名信息并终止条目。</target>
        </trans-unit>
        <trans-unit id="b603b31236d9df1a4442c23c62ea6317f2525837" translate="yes" xml:space="preserve">
          <source>Unlike the longhand form, when Alice fetches from Bob using a remote repository shorthand set up with &lt;code&gt;git remote&lt;/code&gt;, what was fetched is stored in a remote-tracking branch, in this case &lt;code&gt;bob/master&lt;/code&gt;. So after this:</source>
          <target state="translated">与长格式不同，当爱丽丝使用通过 &lt;code&gt;git remote&lt;/code&gt; 设置的远程存储库速记从Bob获取时，所获取的内容存储在远程跟踪分支中，在本例中为 &lt;code&gt;bob/master&lt;/code&gt; 。因此，在此之后：</target>
        </trans-unit>
        <trans-unit id="cc8e9909209a90f3a790bc3005980e8527de79e5" translate="yes" xml:space="preserve">
          <source>Unlike the traditional &lt;code&gt;unified&lt;/code&gt; diff format, which shows two files A and B with a single column that has &lt;code&gt;-&lt;/code&gt; (minus &amp;mdash; appears in A but removed in B), &lt;code&gt;+&lt;/code&gt; (plus &amp;mdash; missing in A but added to B), or &lt;code&gt;&quot; &quot;&lt;/code&gt; (space &amp;mdash; unchanged) prefix, this format compares two or more files file1, file2,&amp;hellip;​ with one file X, and shows how X differs from each of fileN. One column for each of fileN is prepended to the output line to note how X&amp;rsquo;s line is different from it.</source>
          <target state="translated">与传统的 &lt;code&gt;unified&lt;/code&gt; 差异格式不同，传统的差异格式显示两个文件A和B，其中一个列具有 &lt;code&gt;-&lt;/code&gt; （减号-在A中出现，但在B中删除）， &lt;code&gt;+&lt;/code&gt; （加号-在A中丢失但添加到B中）或 &lt;code&gt;&quot; &quot;&lt;/code&gt; （空格（未更改）前缀，此格式将两个或多个文件file1，file2 ...与一个文件X进行比较，并显示X与每个fileN有何不同。每个fileN的一列都位于输出行的前面，以指出X的行与之不同。</target>
        </trans-unit>
        <trans-unit id="71233552f2a4fc77054593fac1f6899dd0308229" translate="yes" xml:space="preserve">
          <source>Unlike variables like &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;core.editor&lt;/code&gt; the &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; and &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; variables will not fall back on the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; configuration if they aren&amp;rsquo;t set. To uniformly configure the same fsck settings in different circumstances all three of them they must all set to the same values.</source>
          <target state="translated">与 &lt;code&gt;color.ui&lt;/code&gt; 和 &lt;code&gt;core.editor&lt;/code&gt; 之 &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 变量不同，receive.fsck。&amp;lt;msg-id&amp;gt;和 &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 变量如果不包含在 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 配置中组。为了在不同的情况下统一配置相同的fsck设置，必须将这三个设置都设置为相同的值。</target>
        </trans-unit>
        <trans-unit id="00ee5ed7b48c819f6f323dbe1b9a72aef5a0c864" translate="yes" xml:space="preserve">
          <source>Unlike variables like &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;core.editor&lt;/code&gt; the &lt;code&gt;receive.fsck.skipList&lt;/code&gt; and &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; variables will not fall back on the &lt;code&gt;fsck.skipList&lt;/code&gt; configuration if they aren&amp;rsquo;t set. To uniformly configure the same fsck settings in different circumstances all three of them they must all set to the same values.</source>
          <target state="translated">与变量一样 &lt;code&gt;color.ui&lt;/code&gt; 和 &lt;code&gt;core.editor&lt;/code&gt; 的 &lt;code&gt;receive.fsck.skipList&lt;/code&gt; 和 &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; 变量将不会依傍 &lt;code&gt;fsck.skipList&lt;/code&gt; 如果未设置它们的配置。为了在不同的情况下统一配置相同的fsck设置，必须将这三个设置都设置为相同的值。</target>
        </trans-unit>
        <trans-unit id="8a3dffb4c65d7a1f27e907ef2a919885d1125ac9" translate="yes" xml:space="preserve">
          <source>Unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, any updates outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; will be accepted without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;), whether that&amp;rsquo;s swapping e.g. a tree object for a blob, or a commit for another commit that&amp;rsquo;s doesn&amp;rsquo;t have the previous commit as an ancestor etc.</source>
          <target state="translated">与使用&lt;a href=&quot;git-push&quot;&gt;git-push [1]推送&lt;/a&gt;时不同，在refspec（或 &lt;code&gt;--force&lt;/code&gt; ）中，在 &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 之外的任何更新都将在不带 &lt;code&gt;+&lt;/code&gt; 的情况下被接受，无论是将树对象交换为blob，或针对另一个不具有先前祖先提交的提交的提交等。</target>
        </trans-unit>
        <trans-unit id="2f2516ccb262ba2dda1eeb5218e911868837ce78" translate="yes" xml:space="preserve">
          <source>Unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, there is no configuration which&amp;rsquo;ll amend these rules, and nothing like a &lt;code&gt;pre-fetch&lt;/code&gt; hook analogous to the &lt;code&gt;pre-receive&lt;/code&gt; hook.</source>
          <target state="translated">与推动时不同&lt;a href=&quot;git-push&quot;&gt;的git推[1] &lt;/a&gt;，没有配置which'll修改这些规则，并没有像 &lt;code&gt;pre-fetch&lt;/code&gt; 钩类似于 &lt;code&gt;pre-receive&lt;/code&gt; 钩。</target>
        </trans-unit>
        <trans-unit id="fb79f423670171900d7e94880e8d45907e9f995c" translate="yes" xml:space="preserve">
          <source>Unlock a working tree, allowing it to be pruned, moved or deleted.</source>
          <target state="translated">解锁一棵工作树,允许它被修剪、移动或删除。</target>
        </trans-unit>
        <trans-unit id="b00eee8b49227caba98e5d68033660ff6076ebcc" translate="yes" xml:space="preserve">
          <source>Unmerged entries have the following format; the first character is a &quot;u&quot; to distinguish from ordinary changed entries.</source>
          <target state="translated">未合并的条目具有以下格式;第一个字符是 &quot;u&quot;,以区别于普通的更改条目。</target>
        </trans-unit>
        <trans-unit id="2c99cc569343579b221cd64026ecc62bb1c21d7b" translate="yes" xml:space="preserve">
          <source>Unpack objects from a packed archive</source>
          <target state="translated">从打包的档案中解压对象</target>
        </trans-unit>
        <trans-unit id="42e2a268d032a6abb00d4cbd80feaa1ecd7a75d6" translate="yes" xml:space="preserve">
          <source>Unreachable tags, commits, and trees will also be accessed to find the tips of dangling segments of history. Use &lt;code&gt;--no-dangling&lt;/code&gt; if you don&amp;rsquo;t care about this output and want to speed it up further.</source>
          <target state="translated">无法访问的标签，提交和树也将被访问，以找到悬空的历史片段的提示。如果您不关心此输出并希望进一步提高输出速度，请使用 &lt;code&gt;--no-dangling&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8a4efd1d470fc3c5ede97084c82a35b9804122a" translate="yes" xml:space="preserve">
          <source>Unregister the given submodules, i.e. remove the whole &lt;code&gt;submodule.$name&lt;/code&gt; section from .git/config together with their work tree. Further calls to &lt;code&gt;git submodule update&lt;/code&gt;, &lt;code&gt;git submodule foreach&lt;/code&gt; and &lt;code&gt;git submodule sync&lt;/code&gt; will skip any unregistered submodules until they are initialized again, so use this command if you don&amp;rsquo;t want to have a local checkout of the submodule in your working tree anymore.</source>
          <target state="translated">取消注册给定的子模块，即从.git / config中删除整个 &lt;code&gt;submodule.$name&lt;/code&gt; 部分及其工作树。进一步调用 &lt;code&gt;git submodule update&lt;/code&gt; ， &lt;code&gt;git submodule foreach&lt;/code&gt; 和 &lt;code&gt;git submodule sync&lt;/code&gt; 将跳过所有未注册的子模块，直到再次对其进行初始化为止，因此，如果您不想在工作树中再次使用该子模块，请使用此命令。</target>
        </trans-unit>
        <trans-unit id="1431f68f359f8699975be39dca08302c67d68d9e" translate="yes" xml:space="preserve">
          <source>Unset</source>
          <target state="translated">Unset</target>
        </trans-unit>
        <trans-unit id="8ff954e80b42b18d3d0fcda602d94db1e46da2d4" translate="yes" xml:space="preserve">
          <source>Unsetting the &lt;code&gt;text&lt;/code&gt; attribute on a path tells Git not to attempt any end-of-line conversion upon checkin or checkout.</source>
          <target state="translated">在路径上取消设置 &lt;code&gt;text&lt;/code&gt; 属性会告诉Git在签入或签出时不要尝试任何行尾转换。</target>
        </trans-unit>
        <trans-unit id="7f84947907454dd0cb412d2a8e5d5e3b9c2382f0" translate="yes" xml:space="preserve">
          <source>Unsetting the variable, or setting it to empty, &quot;0&quot; or &quot;false&quot; (case insensitive) disables trace messages.</source>
          <target state="translated">取消设置变量,或将其设置为空、&quot;0 &quot;或 &quot;false&quot;(不区分大小写),禁用跟踪信息。</target>
        </trans-unit>
        <trans-unit id="c176eff9c64fa28a4b6af1aa296cc1394bbf7a80" translate="yes" xml:space="preserve">
          <source>Unshelve</source>
          <target state="translated">Unshelve</target>
        </trans-unit>
        <trans-unit id="9fde2b36ff30053ad23e6a695929873244cc0367" translate="yes" xml:space="preserve">
          <source>Unshelve options</source>
          <target state="translated">解压选项</target>
        </trans-unit>
        <trans-unit id="004e593b6690fb3d48f4f5a86eac1cd13b5b2234" translate="yes" xml:space="preserve">
          <source>Unshelving will take a shelved P4 changelist, and produce the equivalent git commit in the branch refs/remotes/p4-unshelved/&amp;lt;changelist&amp;gt;.</source>
          <target state="translated">取消搁置将使用搁置的P4更改列表，并在分支refs / remotes / p4-unshelved / &amp;lt;changelist&amp;gt;中产生等效的git commit。</target>
        </trans-unit>
        <trans-unit id="a6e7eb706e115cdaf88206be37eb67b232d007bc" translate="yes" xml:space="preserve">
          <source>Unspecified</source>
          <target state="translated">Unspecified</target>
        </trans-unit>
        <trans-unit id="78f88266b367e8b6e086054e91f1ebc89e168d16" translate="yes" xml:space="preserve">
          <source>Until Git version 2.20, and unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, any updates to &lt;code&gt;refs/tags/*&lt;/code&gt; would be accepted without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches. Since Git version 2.20, fetching to update &lt;code&gt;refs/tags/*&lt;/code&gt; works the same way as when pushing. I.e. any updates will be rejected without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;).</source>
          <target state="translated">在Git 2.20之前，与使用&lt;a href=&quot;git-push&quot;&gt;git-push [1]推送&lt;/a&gt;时不同，在refspec（或 &lt;code&gt;--force&lt;/code&gt; ）中不带 &lt;code&gt;+&lt;/code&gt; 的任何对 &lt;code&gt;refs/tags/*&lt;/code&gt; 的更新将被接受。提取时，我们混杂地认为从远程进行的所有标签更新都是强制提取。从Git版本2.20开始，获取更新 &lt;code&gt;refs/tags/*&lt;/code&gt; 的方式与推送时相同。也就是说，任何更新将在refspec（或 &lt;code&gt;--force&lt;/code&gt; ）中不带 &lt;code&gt;+&lt;/code&gt; 的情况下被拒绝。</target>
        </trans-unit>
        <trans-unit id="9514c500d61430538679eec9081979b274172cf9" translate="yes" xml:space="preserve">
          <source>Untracked cache</source>
          <target state="translated">未跟踪的缓存</target>
        </trans-unit>
        <trans-unit id="614ce4ff1bf92552970ab54ff766006d0da693f9" translate="yes" xml:space="preserve">
          <source>Untracked items have the following format:</source>
          <target state="translated">未追踪项目的格式如下:</target>
        </trans-unit>
        <trans-unit id="1eade895e693b4111455eda06a87af1097cf4d6c" translate="yes" xml:space="preserve">
          <source>Untyped &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;, e.g. the contents of a file.</source>
          <target state="translated">无类型的&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;，例如文件的内容。</target>
        </trans-unit>
        <trans-unit id="7b839a219907b09268c047c522a03961e96bd78b" translate="yes" xml:space="preserve">
          <source>Unused configuration variable. Used in Git versions 2.20 and 2.21 as an escape hatch to enable the legacy shellscript implementation of rebase. Now the built-in rewrite of it in C is always used. Setting this will emit a warning, to alert any remaining users that setting this now does nothing.</source>
          <target state="translated">未使用的配置变量。在 Git 2.20 和 2.21 版本中,它被用来作为一个转义窗口,以启用传统的 shell 脚本实现 rebase。现在总是使用 C 语言的内置重写。设置这个变量会发出一个警告,以提醒其余用户,设置这个变量不会有任何作用。</target>
        </trans-unit>
        <trans-unit id="ca31b4c795dcb03444e6d0c037dbcd47081c70a9" translate="yes" xml:space="preserve">
          <source>Update affected files from CVS repository before attempting export.</source>
          <target state="translated">在尝试导出之前,更新CVS仓库中受影响的文件。</target>
        </trans-unit>
        <trans-unit id="82e59b151c004802a1fa23ba3e75a68d14df0e2a" translate="yes" xml:space="preserve">
          <source>Update an existing shelved changelist with this commit. Implies --shelve. Repeat for multiple shelved changelists.</source>
          <target state="translated">用此提交更新已搁置的变更列表。意味着 --shelve。对多个搁置的变更列表重复此操作。</target>
        </trans-unit>
        <trans-unit id="5433caf2e572561b5bb38ff5e69b0263d08b90aa" translate="yes" xml:space="preserve">
          <source>Update and examine branches from the repository you cloned from:</source>
          <target state="translated">更新和检查你克隆的仓库中的分支。</target>
        </trans-unit>
        <trans-unit id="381f15e94e347f076ef71f417ee29b782a6dcc4d" translate="yes" xml:space="preserve">
          <source>Update auxiliary info file to help dumb servers</source>
          <target state="translated">更新辅助信息文件以帮助哑巴服务器。</target>
        </trans-unit>
        <trans-unit id="d94aecddb1a2d3c03afb4a7cf4e1bb3a0123c2c6" translate="yes" xml:space="preserve">
          <source>Update hook</source>
          <target state="translated">更新钩子</target>
        </trans-unit>
        <trans-unit id="e5f960e3f28d7d7ea59f8750682a356ae18535be" translate="yes" xml:space="preserve">
          <source>Update remote refs along with associated objects</source>
          <target state="translated">更新远程参考文献和相关对象</target>
        </trans-unit>
        <trans-unit id="ee3315ea0cbb49ab6105a89db0964480184c3ce9" translate="yes" xml:space="preserve">
          <source>Update the Git repository with recent changes from p4, rebasing your work on top:</source>
          <target state="translated">用p4的最新变化更新Git仓库,将你的工作重新建立在上面。</target>
        </trans-unit>
        <trans-unit id="5937294218e2d7b95b7b77414b52c326239ca8d5" translate="yes" xml:space="preserve">
          <source>Update the index by adding new files that are unknown to the index and files modified in the working tree, but ignore files that have been removed from the working tree. This option is a no-op when no &amp;lt;pathspec&amp;gt; is used.</source>
          <target state="translated">通过添加索引未知的新文件和在工作树中修改的文件来更新索引，但忽略已从工作树中删除的文件。当不使用&amp;lt;pathspec&amp;gt;时，此选项为no-op。</target>
        </trans-unit>
        <trans-unit id="94df66721f1bfd4990972c3f5f4a0d6b61f59f9e" translate="yes" xml:space="preserve">
          <source>Update the index just where it already has an entry matching &amp;lt;pathspec&amp;gt;. This removes as well as modifies index entries to match the working tree, but adds no new files.</source>
          <target state="translated">在索引已经具有与&amp;lt;pathspec&amp;gt;匹配的条目的地方更新索引。这会删除和修改索引条目以匹配工作树，但不会添加任何新文件。</target>
        </trans-unit>
        <trans-unit id="03d173e098621e3730258998672da85e88b347b1" translate="yes" xml:space="preserve">
          <source>Update the index not only where the working tree has a file matching &amp;lt;pathspec&amp;gt; but also where the index already has an entry. This adds, modifies, and removes index entries to match the working tree.</source>
          <target state="translated">不仅在工作树具有与&amp;lt;pathspec&amp;gt;匹配的文件的地方，而且在索引已经具有条目的地方，更新索引。这将添加，修改和删除索引条目以匹配工作树。</target>
        </trans-unit>
        <trans-unit id="1a6e291eaaa3e731de98429f7fb37fdac90f0a22" translate="yes" xml:space="preserve">
          <source>Update the object name stored in a ref safely</source>
          <target state="translated">安全地更新存储在ref中的对象名称</target>
        </trans-unit>
        <trans-unit id="00f0c8a1eac4ed2966a7d563ef87a6387d365dcf" translate="yes" xml:space="preserve">
          <source>Update the origin repository&amp;rsquo;s master branch with the dev branch, allowing non-fast-forward updates. &lt;strong&gt;This can leave unreferenced commits dangling in the origin repository.&lt;/strong&gt; Consider the following situation, where a fast-forward is not possible:</source>
          <target state="translated">使用dev分支更新原始存储库的master分支，从而允许非快速更新。&lt;strong&gt;这可能会使未引用的提交悬在原始存储库中。&lt;/strong&gt;请考虑以下情况，其中不可能实现快进：</target>
        </trans-unit>
        <trans-unit id="b73d3968359117cfd051c2e81a709d1d9e1579b7" translate="yes" xml:space="preserve">
          <source>Update the reference to the value of the top reflog entry (i.e. &amp;lt;ref&amp;gt;@{0}) if the previous top entry was pruned. (This option is ignored for symbolic references.)</source>
          <target state="translated">如果先前的顶部条目被修剪，则将引用更新为顶部条目列表的值（即&amp;lt;ref&amp;gt; @ {0}）。（对于符号引用，将忽略此选项。）</target>
        </trans-unit>
        <trans-unit id="d7c08d3ae4fbcbbf6a3dc89cdba309659a4395bc" translate="yes" xml:space="preserve">
          <source>Update the reflog for &amp;lt;name&amp;gt; with &amp;lt;reason&amp;gt;. This is valid only when creating or updating a symbolic ref.</source>
          <target state="translated">用&amp;lt;原因&amp;gt;更新&amp;lt;名称&amp;gt;的引用日志。仅在创建或更新符号引用时有效。</target>
        </trans-unit>
        <trans-unit id="d053e75e709458eca9f01e5c8910658ea18a25cf" translate="yes" xml:space="preserve">
          <source>Update the registered submodules to match what the superproject expects by cloning missing submodules, fetching missing commits in submodules and updating the working tree of the submodules. The &quot;updating&quot; can be done in several ways depending on command line options and the value of &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration variable. The command line option takes precedence over the configuration variable. If neither is given, a &lt;code&gt;checkout&lt;/code&gt; is performed. The &lt;code&gt;update&lt;/code&gt; procedures supported both from the command line as well as through the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration are:</source>
          <target state="translated">通过克隆丢失的子模块，在子模块中获取丢失的提交并更新子模块的工作树，更新已注册的子模块，以符合超级项目的期望。根据命令行选项和 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 配置变量的值，可以通过几种方式完成&amp;ldquo;更新&amp;rdquo; 。命令行选项优先于配置变量。如果两者均未给出，则执行 &lt;code&gt;checkout&lt;/code&gt; 。该 &lt;code&gt;update&lt;/code&gt; 程序的命令行以及通过所支持的两个 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 配置为：</target>
        </trans-unit>
        <trans-unit id="9a189cb9ecf6f808972788504f5218556d75488e" translate="yes" xml:space="preserve">
          <source>Update the remote-tracking branches for the repository you cloned from, then merge one of them into your current branch:</source>
          <target state="translated">更新你克隆的仓库的远程跟踪分支,然后将其中一个分支合并到你当前的分支中。</target>
        </trans-unit>
        <trans-unit id="b4a6a66956cae4a12a849cae6094fa1d9187d293" translate="yes" xml:space="preserve">
          <source>Update the remote-tracking branches:</source>
          <target state="translated">更新远程跟踪分支。</target>
        </trans-unit>
        <trans-unit id="f68dff1cbdca38d9a97763a1d9fd849e951b6a1b" translate="yes" xml:space="preserve">
          <source>Updates files in the working tree to match the version in the index or the specified tree. If no pathspec was given, &lt;code&gt;git checkout&lt;/code&gt; will also update &lt;code&gt;HEAD&lt;/code&gt; to set the specified branch as the current branch.</source>
          <target state="translated">更新工作树中的文件以匹配索引或指定树中的版本。如果没有给出pathspec， &lt;code&gt;git checkout&lt;/code&gt; 也会更新 &lt;code&gt;HEAD&lt;/code&gt; 以将指定的分支设置为当前分支。</target>
        </trans-unit>
        <trans-unit id="091bf3e8c6fb28b8688a9117ac018615896df561" translate="yes" xml:space="preserve">
          <source>Updates remote refs using local refs, while sending objects necessary to complete the given refs.</source>
          <target state="translated">使用本地参考文献更新远程参考文献,同时发送完成给定参考文献所需的对象。</target>
        </trans-unit>
        <trans-unit id="91ca9b60db53a2ebedea4c579e08371ec4025869" translate="yes" xml:space="preserve">
          <source>Updating A with the resulting merge commit will fast-forward and your push will be accepted.</source>
          <target state="translated">更新A并进行合并提交,会快速推进,你的推送会被接受。</target>
        </trans-unit>
        <trans-unit id="b1b31935884de26d68d690781ac1ec814b3bc924" translate="yes" xml:space="preserve">
          <source>Updating a repository with git fetch</source>
          <target state="translated">用git fetch更新版本库。</target>
        </trans-unit>
        <trans-unit id="c2ed1ab77aee7c3aaed70bc448641d662955a12f" translate="yes" xml:space="preserve">
          <source>Updating existing tests that assume GIT_TRACE format messages.</source>
          <target state="translated">更新现有的测试,假设GIT_TRACE格式的消息。</target>
        </trans-unit>
        <trans-unit id="c5ded60beb1b0eb17cab63a8e09a8acd2261286e" translate="yes" xml:space="preserve">
          <source>Updating the index did something else too: it created a &lt;code&gt;.git/index&lt;/code&gt; file. This is the index that describes your current working tree, and something you should be very aware of. Again, you normally never worry about the index file itself, but you should be aware of the fact that you have not actually really &quot;checked in&quot; your files into Git so far, you&amp;rsquo;ve only &lt;strong&gt;told&lt;/strong&gt; Git about them.</source>
          <target state="translated">更新索引也做了其他事情：它创建了一个 &lt;code&gt;.git/index&lt;/code&gt; 文件。这是描述您当前工作树的索引，您应该非常了解它。同样，您通常不必担心索引文件本身，但是您应该意识到，到目前为止，您还没有真正将文件&amp;ldquo;检入&amp;rdquo;到Git中，您只是&lt;strong&gt;告诉了&lt;/strong&gt; Git。</target>
        </trans-unit>
        <trans-unit id="583381e5edf6e3ab467919c38286667f0916979d" translate="yes" xml:space="preserve">
          <source>Upon completion, &amp;lt;branch&amp;gt; will be the current branch.</source>
          <target state="translated">完成后，&amp;lt;branch&amp;gt;将是当前分支。</target>
        </trans-unit>
        <trans-unit id="c956664b8da61af6d0e1bf33a6e1ff75cbe45ad1" translate="yes" xml:space="preserve">
          <source>Upon seeing an invalid object name in the input, pretend as if the bad input was not given.</source>
          <target state="translated">当看到输入中出现无效的对象名称时,就装作没有输入不良的样子。</target>
        </trans-unit>
        <trans-unit id="d725441fc805b8226e9417fb2c8cf53ac8d791d5" translate="yes" xml:space="preserve">
          <source>Upstream branch to compare against. May be any valid commit, not just an existing branch name. Defaults to the configured upstream for the current branch.</source>
          <target state="translated">与之比较的上游分支,可以是任何有效的提交,而不仅仅是现有的分支名。可以是任何有效的提交,而不仅仅是现有的分支名。默认为当前分支的上游配置。</target>
        </trans-unit>
        <trans-unit id="f5808323e4ba717fc383cb75e63b6cf3a4e857e7" translate="yes" xml:space="preserve">
          <source>Upstream branch to search for equivalent commits. Defaults to the upstream branch of HEAD.</source>
          <target state="translated">搜索等价提交的上游分支。默认为 HEAD 的上游分支。</target>
        </trans-unit>
        <trans-unit id="309bc26d3c4c2649258f95c7069216bb2a7ac5f4" translate="yes" xml:space="preserve">
          <source>Upstream location from which commits are identified to submit to p4. By default, this is the most recent p4 commit reachable from &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">确定提交要提交给p4的上游位置。默认情况下，这是 &lt;code&gt;HEAD&lt;/code&gt; 可访问的最新p4提交。</target>
        </trans-unit>
        <trans-unit id="df28f1403e8348eae4829434034d1a95e5fe659d" translate="yes" xml:space="preserve">
          <source>Url translation</source>
          <target state="translated">网址翻译</target>
        </trans-unit>
        <trans-unit id="f51159e5f3b0adbeed98e188d040286280a5320b" translate="yes" xml:space="preserve">
          <source>Usage text</source>
          <target state="translated">使用文本</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="6039144c2dc6586b6f3f0cb7423bcc0b3de0d0c1" translate="yes" xml:space="preserve">
          <source>Use &quot;patience diff&quot; algorithm when generating patches.</source>
          <target state="translated">生成补丁时使用 &quot;耐心差异 &quot;算法。</target>
        </trans-unit>
        <trans-unit id="1712fa1f1e6f89a27b7d3117ed39073a3258971d" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;dir&amp;gt; to store the resulting files, instead of the current working directory.</source>
          <target state="translated">使用&amp;lt;dir&amp;gt;存储结果文件，而不是当前工作目录。</target>
        </trans-unit>
        <trans-unit id="89ed1ad2d65d4e1af42e685a9ee22c739e5d2c9b" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;message&amp;gt; instead of the branch names for the first line of the log message. For use with &lt;code&gt;--log&lt;/code&gt;.</source>
          <target state="translated">使用&amp;lt;message&amp;gt;代替日志消息第一行的分支名称。与 &lt;code&gt;--log&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="a8e6c324c4e7440184ef28eb2f6fc1fca5a4a325" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;regex&amp;gt; to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies &lt;code&gt;--word-diff&lt;/code&gt; unless it was already enabled.</source>
          <target state="translated">使用&amp;lt;regex&amp;gt;来确定单词是什么，而不是将非空白行视为一个单词。也意味着 &lt;code&gt;--word-diff&lt;/code&gt; ,除非已启用。</target>
        </trans-unit>
        <trans-unit id="f70b8a97f949594b729b07efce2ca59a63023925" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;!&lt;/code&gt; to not make the corresponding negated long option available.</source>
          <target state="translated">使用 &lt;code&gt;!&lt;/code&gt; 使相应的取反加长选项不可用。</target>
        </trans-unit>
        <trans-unit id="f7924a219e6794d45a36b15b2c44738227b795ff" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; to set the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; explicitly. e.g., &quot;git remote set-head origin master&quot; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 显式设置symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 。例如，&amp;ldquo; git remote set-head source origin master&amp;rdquo;会将symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; 设置为 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 。仅当 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 已经存在时，这才起作用；如果不是，则必须先获取它。</target>
        </trans-unit>
        <trans-unit id="d950943422ee3b93275d1e4b1e510463e5b432e0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; to contact a running cache daemon (or start a new cache daemon if one is not started). Defaults to &lt;code&gt;$XDG_CACHE_HOME/git/credential/socket&lt;/code&gt; unless &lt;code&gt;~/.git-credential-cache/&lt;/code&gt; exists in which case &lt;code&gt;~/.git-credential-cache/socket&lt;/code&gt; is used instead. If your home directory is on a network-mounted filesystem, you may need to change this to a local filesystem. You must specify an absolute path.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 与正在运行的缓存守护程序联系（如果尚未启动，请启动一个新的缓存守护程序）。默认为 &lt;code&gt;$XDG_CACHE_HOME/git/credential/socket&lt;/code&gt; ，除非 &lt;code&gt;~/.git-credential-cache/&lt;/code&gt; 存在在这种情况下 &lt;code&gt;~/.git-credential-cache/socket&lt;/code&gt; 来代替。如果主目录位于网络安装的文件系统上，则可能需要将其更改为本地文件系统。您必须指定绝对路径。</target>
        </trans-unit>
        <trans-unit id="faabe60607ec900b5e4ad4f074b4870d8f9c10c6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; to lookup and store credentials. The file will have its filesystem permissions set to prevent other users on the system from reading it, but will not be encrypted or otherwise protected. If not specified, credentials will be searched for from &lt;code&gt;~/.git-credentials&lt;/code&gt; and &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt;, and credentials will be written to &lt;code&gt;~/.git-credentials&lt;/code&gt; if it exists, or &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; if it exists and the former does not. See also &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 查找和存储凭据。该文件将设置其文件系统权限，以防止系统上的其他用户读取该文件，但不会被加密或受到其他保护。如果没有指定，凭据将搜索从 &lt;code&gt;~/.git-credentials&lt;/code&gt; 和 &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; 和证书将被写入到 &lt;code&gt;~/.git-credentials&lt;/code&gt; ，如果它存在，或 &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; （如果存在）而前者则没有。另请参阅&lt;a href=&quot;#FILES&quot;&gt;文件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aadb92eae500ef695bbe6a445720ce25246dd04e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;*&lt;/code&gt; to mean that this option should not be listed in the usage generated for the &lt;code&gt;-h&lt;/code&gt; argument. It&amp;rsquo;s shown for &lt;code&gt;--help-all&lt;/code&gt; as documented in &lt;a href=&quot;gitcli&quot;&gt;gitcli[7]&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;*&lt;/code&gt; 表示此选项不应在为 &lt;code&gt;-h&lt;/code&gt; 参数生成的用法中列出。如&lt;a href=&quot;gitcli&quot;&gt;gitcli [7]&lt;/a&gt;所示，它显示为 &lt;code&gt;--help-all&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bbcee2a044e9c08185b38acb1e1c57ceea88054" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--no-guess&lt;/code&gt; to disable this.</source>
          <target state="translated">使用 &lt;code&gt;--no-guess&lt;/code&gt; 禁用此功能。</target>
        </trans-unit>
        <trans-unit id="6deefc2a8fa6667ca14a90dee15faf81b1f0546a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-o master&lt;/code&gt; for continuing an import that was initially done by the old cvs2git tool.</source>
          <target state="translated">使用 &lt;code&gt;-o master&lt;/code&gt; 继续执行最初由旧cvs2git工具完成的导入。</target>
        </trans-unit>
        <trans-unit id="a4527eec708654a210ce88433047c8e573fb91f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-r&lt;/code&gt; together with &lt;code&gt;-d&lt;/code&gt; to delete remote-tracking branches. Note, that it only makes sense to delete remote-tracking branches if they no longer exist in the remote repository or if &lt;code&gt;git fetch&lt;/code&gt; was configured not to fetch them again. See also the &lt;code&gt;prune&lt;/code&gt; subcommand of &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; for a way to clean up all obsolete remote-tracking branches.</source>
          <target state="translated">与 &lt;code&gt;-d&lt;/code&gt; 一起使用 &lt;code&gt;-r&lt;/code&gt; 可以删除远程跟踪分支。请注意，仅当远程跟踪分支不再存在于远程存储库中或 &lt;code&gt;git fetch&lt;/code&gt; 配置为不再再次获取它们时，才有意义。另请参见&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;的 &lt;code&gt;prune&lt;/code&gt; 子命令，以清除所有过时的远程跟踪分支。</target>
        </trans-unit>
        <trans-unit id="eb7d25cab29167524de808a8da669505756898ee" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;=&lt;/code&gt; if the option takes an argument.</source>
          <target state="translated">如果该选项接受参数，则使用 &lt;code&gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d247642d4c8609f74c2030daa3d24c7c82d2e46d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;?&lt;/code&gt; to mean that the option takes an optional argument. You probably want to use the &lt;code&gt;--stuck-long&lt;/code&gt; mode to be able to unambiguously parse the optional argument.</source>
          <target state="translated">使用 &lt;code&gt;?&lt;/code&gt; 表示该选项采用可选参数。您可能希望使用 &lt;code&gt;--stuck-long&lt;/code&gt; 模式才能明确解析可选参数。</target>
        </trans-unit>
        <trans-unit id="7929eb6fd77d1ea35c9c481fc89518eafcc1cd45" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git bisect&lt;/code&gt; to get a short usage description, and &lt;code&gt;git bisect
help&lt;/code&gt; or &lt;code&gt;git bisect -h&lt;/code&gt; to get a long usage description.</source>
          <target state="translated">使用 &lt;code&gt;git bisect&lt;/code&gt; 可获得简短的用法说明，使用 &lt;code&gt;git bisect help&lt;/code&gt; 或 &lt;code&gt;git bisect -h&lt;/code&gt; 可获得较长的用法说明。</target>
        </trans-unit>
        <trans-unit id="599c65a25784af23c9351ba6f4874c534a65a263" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git cherry origin&lt;/code&gt; to see which ones of your patches were accepted, and/or use &lt;code&gt;git rebase origin&lt;/code&gt; to port your unmerged changes forward to the updated upstream.</source>
          <target state="translated">使用 &lt;code&gt;git cherry origin&lt;/code&gt; 查看被接受的补丁程序，和/或使用 &lt;code&gt;git rebase origin&lt;/code&gt; 将未合并的更改转发到更新的上游。</target>
        </trans-unit>
        <trans-unit id="f1986201248cbf297f2fb86d6f520b30d057ce7d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; or &lt;code&gt;git remote update&lt;/code&gt; to stay up to date.</source>
          <target state="translated">使用 &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; 或 &lt;code&gt;git remote update&lt;/code&gt; 保持最新。</target>
        </trans-unit>
        <trans-unit id="252ef42d37b56d31d5e5dc2525ae974052dfca91" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git format-patch origin&lt;/code&gt; to prepare patches for e-mail submission to your upstream and send it out. Go back to step 2. and continue.</source>
          <target state="translated">使用 &lt;code&gt;git format-patch origin&lt;/code&gt; 来准备补丁，以将电子邮件提交到上游并发送出去。返回第2步，然后继续。</target>
        </trans-unit>
        <trans-unit id="cd30f3ed950161de3f8267d9a18953af3c02784f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git mergetool&lt;/code&gt; to run one of several merge utilities to resolve merge conflicts. It is typically run after &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;git mergetool&lt;/code&gt; 运行多个合并实用程序之一来解决合并冲突。它通常在 &lt;code&gt;git merge&lt;/code&gt; 之后运行。</target>
        </trans-unit>
        <trans-unit id="6b298c06fc405635f29d06efdf0f42592d8075f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rev-parse&lt;/code&gt; in option parsing mode (see PARSEOPT section below).</source>
          <target state="translated">在选项解析模式下使用 &lt;code&gt;git rev-parse&lt;/code&gt; （请参阅下面的PARSEOPT部分）。</target>
        </trans-unit>
        <trans-unit id="7c9820d48befbd19730095f238fb8a15824823ad" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rev-parse&lt;/code&gt; in shell quoting mode (see SQ-QUOTE section below). In contrast to the &lt;code&gt;--sq&lt;/code&gt; option below, this mode does only quoting. Nothing else is done to command input.</source>
          <target state="translated">在shell引用模式下使用 &lt;code&gt;git rev-parse&lt;/code&gt; （请参阅下面的SQ-QUOTE部分）。与下面的 &lt;code&gt;--sq&lt;/code&gt; 选项相反，此模式仅引用。命令输入无其他操作。</target>
        </trans-unit>
        <trans-unit id="4c4d44083fa5e2a6971987cf935297be30994f4c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stash&lt;/code&gt; when you want to record the current state of the working directory and the index, but want to go back to a clean working directory. The command saves your local modifications away and reverts the working directory to match the &lt;code&gt;HEAD&lt;/code&gt; commit.</source>
          <target state="translated">当您想记录工作目录和索引的当前状态，但又想回到干净的工作目录时，请使用 &lt;code&gt;git stash&lt;/code&gt; 。该命令将您的本地修改保存下来，并还原工作目录以匹配 &lt;code&gt;HEAD&lt;/code&gt; 提交。</target>
        </trans-unit>
        <trans-unit id="41c11f9d8154a7d9c49ff48bc15e09cdeb4a9a5c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stripspace --strip-comments&lt;/code&gt; to obtain:</source>
          <target state="translated">使用 &lt;code&gt;git stripspace --strip-comments&lt;/code&gt; 获得：</target>
        </trans-unit>
        <trans-unit id="141b00818c5025cc15ff515d81283fc5705a8a4e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stripspace&lt;/code&gt; with no arguments to obtain:</source>
          <target state="translated">使用 &lt;code&gt;git stripspace&lt;/code&gt; 带参数的git stripspace获取：</target>
        </trans-unit>
        <trans-unit id="ae0479a18945009a7ebac30bdfceaa72c61a99c4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ident&lt;/code&gt; in the &lt;code&gt;From:&lt;/code&gt; header of each commit email. If the author ident of the commit is not textually identical to the provided &lt;code&gt;ident&lt;/code&gt;, place a &lt;code&gt;From:&lt;/code&gt; header in the body of the message with the original author. If no &lt;code&gt;ident&lt;/code&gt; is given, use the committer ident.</source>
          <target state="translated">在每个提交电子邮件的&amp;ldquo; &lt;code&gt;From:&lt;/code&gt; 标题中使用 &lt;code&gt;ident&lt;/code&gt; 。如果提交的作者身份与提供的 &lt;code&gt;ident&lt;/code&gt; 在文本上不相同，请在原始邮件的正文中放置一个 &lt;code&gt;From:&lt;/code&gt; 标头。如果没有给出 &lt;code&gt;ident&lt;/code&gt; ，则使用提交者标识。</target>
        </trans-unit>
        <trans-unit id="8fb68f530aa46816206d7ea34908da4d297edef3" translate="yes" xml:space="preserve">
          <source>Use IPv4 addresses only, ignoring IPv6 addresses.</source>
          <target state="translated">只使用IPv4地址,忽略IPv6地址。</target>
        </trans-unit>
        <trans-unit id="d89ac89f76f16a68a863b0d9f578ffd1a558d6b0" translate="yes" xml:space="preserve">
          <source>Use IPv6 addresses only, ignoring IPv4 addresses.</source>
          <target state="translated">只使用IPv6地址,忽略IPv4地址。</target>
        </trans-unit>
        <trans-unit id="23206ddfb8d01b68973d7bd9cccf799f208e3657" translate="yes" xml:space="preserve">
          <source>Use Message &amp;rarr; Insert file&amp;hellip;​ and insert the patch.</source>
          <target state="translated">使用消息&amp;rarr;插入文件...并插入补丁。</target>
        </trans-unit>
        <trans-unit id="1b7e380bb9ef947a64359e01f17ce54cd3bdece1" translate="yes" xml:space="preserve">
          <source>Use One Mark Per Commit</source>
          <target state="translated">每次承诺使用一个标记</target>
        </trans-unit>
        <trans-unit id="c24268aab2b43d4e294643c8fbcbd60d377e139b" translate="yes" xml:space="preserve">
          <source>Use POSIX extended/basic regexp for patterns. Default is to use basic regexp.</source>
          <target state="translated">对模式使用 POSIX 扩展/基本 regexp。默认是使用基本的regexp。</target>
        </trans-unit>
        <trans-unit id="36e96e4a2fd002679f3b794b4968539810c5c2eb" translate="yes" xml:space="preserve">
          <source>Use Perl-compatible regular expressions for patterns.</source>
          <target state="translated">对模式使用Perl兼容的正则表达式。</target>
        </trans-unit>
        <trans-unit id="fd46ce4ee0de88bb1a4ebb0e0c6375d24c2fb065" translate="yes" xml:space="preserve">
          <source>Use SO_REUSEADDR when binding the listening socket. This allows the server to restart without waiting for old connections to time out.</source>
          <target state="translated">在绑定监听套接字时,使用SO_REUSEADDR。这允许服务器重新启动,而不需要等待旧的连接超时。</target>
        </trans-unit>
        <trans-unit id="f351ffbdfc957393f82f6653e37778e19987b350" translate="yes" xml:space="preserve">
          <source>Use Tag Fixup Branches</source>
          <target state="translated">使用标签修复分支</target>
        </trans-unit>
        <trans-unit id="67640e675158aa473b8a69cc0cdb46fb8ed7283f" translate="yes" xml:space="preserve">
          <source>Use a &quot;stable&quot; sum of hashes as the patch ID. With this option:</source>
          <target state="translated">使用一个 &quot;稳定的 &quot;哈希值之和作为补丁ID。有了这个选项。</target>
        </trans-unit>
        <trans-unit id="0ec5feaf620cc0230519584645c952a1ae99d83c" translate="yes" xml:space="preserve">
          <source>Use a client spec to find the list of interesting files in p4. See the &quot;CLIENT SPEC&quot; section below.</source>
          <target state="translated">使用客户端规范来查找p4中有趣的文件列表。参见下面的 &quot;CLIENT SPEC &quot;部分。</target>
        </trans-unit>
        <trans-unit id="cf410607b4d646fae6b37dffcb3f37fcc481f52b" translate="yes" xml:space="preserve">
          <source>Use a mergetool. &lt;code&gt;git mergetool&lt;/code&gt; to launch a graphical mergetool which will work you through the merge.</source>
          <target state="translated">使用mergetool。 &lt;code&gt;git mergetool&lt;/code&gt; 启动图形化合并工具，它将通过合并工作。</target>
        </trans-unit>
        <trans-unit id="e7589df3d820308df2c8a838829de10cfbcf2077" translate="yes" xml:space="preserve">
          <source>Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde &lt;code&gt;~&lt;/code&gt; on a line of its own.</source>
          <target state="translated">使用专用于脚本的基于行的特殊格式。添加/删除/未更改的运行以通常的统一diff格式打印，从行首的 &lt;code&gt;+&lt;/code&gt; / &lt;code&gt;-&lt;/code&gt; /``字符开始，一直扩展到行尾。输入中的换行符由自己的一行上的波浪号 &lt;code&gt;~&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="77b024aefcbc37a1627539595d18a928f0842816" translate="yes" xml:space="preserve">
          <source>Use a tarball as a starting point for a new repository.</source>
          <target state="translated">使用一个 tar 包作为新版本库的起点。</target>
        </trans-unit>
        <trans-unit id="afac3b09febbe243aa11caf12f594c7284e7bf23" translate="yes" xml:space="preserve">
          <source>Use an &quot;unstable&quot; hash as the patch ID. With this option, the result produced is compatible with the patch-id value produced by git 1.9 and older. Users with pre-existing databases storing patch-ids produced by git 1.9 and older (who do not deal with reordered patches) may want to use this option.</source>
          <target state="translated">使用 &quot;不稳定 &quot;的哈希值作为补丁 ID。使用这个选项,产生的结果会与 git 1.9 及更早版本的补丁 ID 值兼容。如果用户的数据库中已经存储了 git 1.9 或更早版本的补丁 ID(不处理重新排序的补丁),可能会希望使用这个选项。</target>
        </trans-unit>
        <trans-unit id="ef4088fc09156b38070cb26da8281dc7bfd8c504" translate="yes" xml:space="preserve">
          <source>Use an atomic transaction for updating the refs. If any of the refs fails to update then the entire push will fail without changing any refs.</source>
          <target state="translated">使用原子事务来更新refs。如果任何一个refs未能更新,那么整个推送将失败,而不会改变任何refs。</target>
        </trans-unit>
        <trans-unit id="049c3e05f1b188c69413c7549059c67376f76ed1" translate="yes" xml:space="preserve">
          <source>Use an atomic transaction on the remote side if available. Either all refs are updated, or on error, no refs are updated. If the server does not support atomic pushes the push will fail.</source>
          <target state="translated">如果有的话,在远程端使用原子事务。要么更新所有refs,要么出错时不更新refs。如果服务器不支持原子推送,推送将失败。</target>
        </trans-unit>
        <trans-unit id="e55fb404106de44576d9bc731a7fb4baf9a6337c" translate="yes" xml:space="preserve">
          <source>Use binary search to find the commit that introduced a bug</source>
          <target state="translated">使用二进制搜索来查找引入bug的提交。</target>
        </trans-unit>
        <trans-unit id="78ee9b127501691d305b39cc3fc13fc74a1d22a1" translate="yes" xml:space="preserve">
          <source>Use customized color for &lt;code&gt;git add --interactive&lt;/code&gt; and &lt;code&gt;git clean --interactive&lt;/code&gt; output. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; may be &lt;code&gt;prompt&lt;/code&gt;, &lt;code&gt;header&lt;/code&gt;, &lt;code&gt;help&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;, for four distinct types of normal output from interactive commands.</source>
          <target state="translated">对 &lt;code&gt;git add --interactive&lt;/code&gt; 和 &lt;code&gt;git clean --interactive&lt;/code&gt; 输出使用自定义颜色。对于来自交互命令的四种不同类型的常规输出， &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 可以是 &lt;code&gt;prompt&lt;/code&gt; ， &lt;code&gt;header&lt;/code&gt; ， &lt;code&gt;help&lt;/code&gt; 或 &lt;code&gt;error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf3aeb7f00c3d69ade01b5cc321078d4f50948ae" translate="yes" xml:space="preserve">
          <source>Use customized color for &lt;code&gt;git log --decorate&lt;/code&gt; output. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;branch&lt;/code&gt;, &lt;code&gt;remoteBranch&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;, &lt;code&gt;stash&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt; for local branches, remote-tracking branches, tags, stash and HEAD, respectively and &lt;code&gt;grafted&lt;/code&gt; for grafted commits.</source>
          <target state="translated">对 &lt;code&gt;git log --decorate&lt;/code&gt; 使用自定义颜色- 装饰输出。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 是本地分支，远程跟踪分支，tag，stash和HEAD 的 &lt;code&gt;branch&lt;/code&gt; ， &lt;code&gt;remoteBranch&lt;/code&gt; ， &lt;code&gt;tag&lt;/code&gt; ， &lt;code&gt;stash&lt;/code&gt; 或 &lt;code&gt;HEAD&lt;/code&gt; 之一，分别为嫁接的提交而被 &lt;code&gt;grafted&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29ecef38edab0e1998d46583be9558cf2a562eff" translate="yes" xml:space="preserve">
          <source>Use customized color for branch coloration. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;current&lt;/code&gt; (the current branch), &lt;code&gt;local&lt;/code&gt; (a local branch), &lt;code&gt;remote&lt;/code&gt; (a remote-tracking branch in refs/remotes/), &lt;code&gt;upstream&lt;/code&gt; (upstream tracking branch), &lt;code&gt;plain&lt;/code&gt; (other refs).</source>
          <target state="translated">使用自定义颜色进行分支着色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 是 &lt;code&gt;current&lt;/code&gt; （当前分支）， &lt;code&gt;local&lt;/code&gt; （本地分支）， &lt;code&gt;remote&lt;/code&gt; （refs / remotes /中的远程跟踪分支）， &lt;code&gt;upstream&lt;/code&gt; （上游跟踪分支）， &lt;code&gt;plain&lt;/code&gt; （其他ref）之一。</target>
        </trans-unit>
        <trans-unit id="fcdeebdb47ef8466da45d806c0dccf091f4447a0" translate="yes" xml:space="preserve">
          <source>Use customized color for diff colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; specifies which part of the patch to use the specified color, and is one of &lt;code&gt;context&lt;/code&gt; (context text - &lt;code&gt;plain&lt;/code&gt; is a historical synonym), &lt;code&gt;meta&lt;/code&gt; (metainformation), &lt;code&gt;frag&lt;/code&gt; (hunk header), &lt;code&gt;func&lt;/code&gt; (function in hunk header), &lt;code&gt;old&lt;/code&gt; (removed lines), &lt;code&gt;new&lt;/code&gt; (added lines), &lt;code&gt;commit&lt;/code&gt; (commit headers), &lt;code&gt;whitespace&lt;/code&gt; (highlighting whitespace errors), &lt;code&gt;oldMoved&lt;/code&gt; (deleted lines), &lt;code&gt;newMoved&lt;/code&gt; (added lines), &lt;code&gt;oldMovedDimmed&lt;/code&gt;, &lt;code&gt;oldMovedAlternative&lt;/code&gt;, &lt;code&gt;oldMovedAlternativeDimmed&lt;/code&gt;, &lt;code&gt;newMovedDimmed&lt;/code&gt;, &lt;code&gt;newMovedAlternative&lt;/code&gt;&lt;code&gt;newMovedAlternativeDimmed&lt;/code&gt; (See the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; setting of &lt;code&gt;--color-moved&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; for details), &lt;code&gt;contextDimmed&lt;/code&gt;, &lt;code&gt;oldDimmed&lt;/code&gt;, &lt;code&gt;newDimmed&lt;/code&gt;, &lt;code&gt;contextBold&lt;/code&gt;, &lt;code&gt;oldBold&lt;/code&gt;, and &lt;code&gt;newBold&lt;/code&gt; (see &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt; for details).</source>
          <target state="translated">使用自定义颜色进行diff着色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 指定补丁的哪一部分使用指定的颜色，并且是 &lt;code&gt;context&lt;/code&gt; （上下文文本- &lt;code&gt;plain&lt;/code&gt; 是历史同义词）， &lt;code&gt;meta&lt;/code&gt; （生成形式）， &lt;code&gt;frag&lt;/code&gt; （大块头）， &lt;code&gt;func&lt;/code&gt; （大块头中的函数）， &lt;code&gt;old&lt;/code&gt; （删除的行）， &lt;code&gt;new&lt;/code&gt; （添加的行）， &lt;code&gt;commit&lt;/code&gt; （提交标头）， &lt;code&gt;whitespace&lt;/code&gt; （突出显示空白错误）， &lt;code&gt;oldMoved&lt;/code&gt; （删除的行）， &lt;code&gt;newMoved&lt;/code&gt; （添加的行）， &lt;code&gt;oldMovedDimmed&lt;/code&gt; ， &lt;code&gt;oldMovedAlternative&lt;/code&gt; ， &lt;code&gt;oldMovedAlternativeDimmed&lt;/code&gt; ， &lt;code&gt;newMovedDimmed&lt;/code&gt; ， &lt;code&gt;newMovedAlternative&lt;/code&gt; &lt;code&gt;newMovedAlternativeDimmed&lt;/code&gt; （见 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 的设定 &lt;code&gt;--color-moved&lt;/code&gt; 在&lt;a href=&quot;git-diff&quot;&gt;GIT-DIFF [1]&lt;/a&gt;的详细信息）， &lt;code&gt;contextDimmed&lt;/code&gt; ， &lt;code&gt;oldDimmed&lt;/code&gt; ， &lt;code&gt;newDimmed&lt;/code&gt; ， &lt;code&gt;contextBold&lt;/code&gt; ， &lt;code&gt;oldBold&lt;/code&gt; ，和 &lt;code&gt;newBold&lt;/code&gt; （见&lt;a href=&quot;git-range-diff&quot;&gt;GIT-范围-DIFF [ 1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="799532fe06b09693cab5782f0c7b74d1305d2cb1" translate="yes" xml:space="preserve">
          <source>Use customized color for each remote keyword. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; may be &lt;code&gt;hint&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;success&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; which match the corresponding keyword.</source>
          <target state="translated">为每个远程关键字使用自定义颜色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 可以是 &lt;code&gt;hint&lt;/code&gt; ， &lt;code&gt;warning&lt;/code&gt; ， &lt;code&gt;success&lt;/code&gt; 或 &lt;code&gt;error&lt;/code&gt; ，它们与相应的关键字匹配。</target>
        </trans-unit>
        <trans-unit id="e8363e3bb3b19269f1bec63465f050d08c7400a8" translate="yes" xml:space="preserve">
          <source>Use customized color for grep colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; specifies which part of the line to use the specified color, and is one of</source>
          <target state="translated">使用自定义颜色进行grep着色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 指定使用指定颜色的行的哪一部分，并且是以下之一</target>
        </trans-unit>
        <trans-unit id="3d940f7a54cc13b6b8a420b163ce2b7e4ccedf38" translate="yes" xml:space="preserve">
          <source>Use customized color for hints.</source>
          <target state="translated">使用自定义颜色进行提示。</target>
        </trans-unit>
        <trans-unit id="a7bc0186c1d40a59aee910eedb6524484cbce3a0" translate="yes" xml:space="preserve">
          <source>Use customized color for push errors.</source>
          <target state="translated">使用自定义颜色进行推送错误。</target>
        </trans-unit>
        <trans-unit id="efd1e4b094e6a540e69b42772ae161651f4648a2" translate="yes" xml:space="preserve">
          <source>Use customized color for status colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;header&lt;/code&gt; (the header text of the status message), &lt;code&gt;added&lt;/code&gt; or &lt;code&gt;updated&lt;/code&gt; (files which are added but not committed), &lt;code&gt;changed&lt;/code&gt; (files which are changed but not added in the index), &lt;code&gt;untracked&lt;/code&gt; (files which are not tracked by Git), &lt;code&gt;branch&lt;/code&gt; (the current branch), &lt;code&gt;nobranch&lt;/code&gt; (the color the &lt;code&gt;no branch&lt;/code&gt; warning is shown in, defaulting to red), &lt;code&gt;localBranch&lt;/code&gt; or &lt;code&gt;remoteBranch&lt;/code&gt; (the local and remote branch names, respectively, when branch and tracking information is displayed in the status short-format), or &lt;code&gt;unmerged&lt;/code&gt; (files which have unmerged changes).</source>
          <target state="translated">使用自定义颜色进行状态着色。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 是 &lt;code&gt;header&lt;/code&gt; （状态消息的标题文本），已 &lt;code&gt;added&lt;/code&gt; 或 &lt;code&gt;updated&lt;/code&gt; （已添加但未提交的文件），已 &lt;code&gt;changed&lt;/code&gt; （已更改但未添加到索引中的文件）， &lt;code&gt;untracked&lt;/code&gt; （未添加的文件）之一在以下位置显示分支和跟踪信息时，由Git跟踪）， &lt;code&gt;branch&lt;/code&gt; （当前分支）， &lt;code&gt;nobranch&lt;/code&gt; （显示 &lt;code&gt;no branch&lt;/code&gt; 警告的颜色，默认为红色）， &lt;code&gt;localBranch&lt;/code&gt; 或 &lt;code&gt;remoteBranch&lt;/code&gt; （分别为本地和远程分支名称）。状态短格式），或 &lt;code&gt;unmerged&lt;/code&gt; （具有未合并更改的文件）。</target>
        </trans-unit>
        <trans-unit id="42006ecfd08deb9b3ff0a3f1d7240d8f715710f3" translate="yes" xml:space="preserve">
          <source>Use customized color when a push was rejected.</source>
          <target state="translated">推送被拒绝时,使用自定义颜色。</target>
        </trans-unit>
        <trans-unit id="7714f2243f3ecb7a0c915a75f0d9677bee5cfddf" translate="yes" xml:space="preserve">
          <source>Use fixed strings for patterns (don&amp;rsquo;t interpret pattern as a regex).</source>
          <target state="translated">使用固定的字符串作为模式（不要将模式解释为正则表达式）。</target>
        </trans-unit>
        <trans-unit id="be83392780575c9c0f338875e4ab41fca7ad0580" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of Git objects. We check &lt;code&gt;&amp;lt;dir&amp;gt;/packs/multi-pack-index&lt;/code&gt; for the current MIDX file, and &lt;code&gt;&amp;lt;dir&amp;gt;/packs&lt;/code&gt; for the pack-files to index.</source>
          <target state="translated">将给定目录用于Git对象的位置。我们检查当前MIDX文件的 &lt;code&gt;&amp;lt;dir&amp;gt;/packs/multi-pack-index&lt;/code&gt; ，并检查要索引的pack-file的 &lt;code&gt;&amp;lt;dir&amp;gt;/packs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58e0e6d68f2b1086e2f61cc3ccf9bb473fce2cb1" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of packfiles and commit-graph file. This parameter exists to specify the location of an alternate that only has the objects directory, not a full &lt;code&gt;.git&lt;/code&gt; directory. The commit-graph file is expected to be in the &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; directory and the packfiles are expected to be in &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt;.</source>
          <target state="translated">将给定目录用于packfiles和commit-graph文件的位置。存在此参数以指定仅具有对象目录而不是完整的 &lt;code&gt;.git&lt;/code&gt; 目录的替代项的位置。提交图文件应位于 &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; 目录中，而packfile文件应位于 &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="9e22ac3ec044552fceb6f971a8409c3fc735d918" translate="yes" xml:space="preserve">
          <source>Use gmail as the smtp server</source>
          <target state="translated">使用gmail作为smtp服务器</target>
        </trans-unit>
        <trans-unit id="243e0ec42451f8d223cf0a086b6e0d020fe017bc" translate="yes" xml:space="preserve">
          <source>Use hash &lt;code&gt;#&lt;/code&gt; for comments that are either on their own line, or after the email address.</source>
          <target state="translated">使用井号 &lt;code&gt;#&lt;/code&gt; 可以单独显示一行，也可以在电子邮件地址之后添加注释。</target>
        </trans-unit>
        <trans-unit id="fe4290ca9cf2dcf165b3911c20fcc8115cf36b09" translate="yes" xml:space="preserve">
          <source>Use libcurl to communicate with the IMAP server, unless tunneling into it. Ignored if Git was built without the USE_CURL_FOR_IMAP_SEND option set.</source>
          <target state="translated">使用 libcurl 与 IMAP 服务器通信,除非是通过隧道进入。如果 Git 在构建时没有设置 USE_CURL_FOR_IMAP_SEND 选项,则忽略。</target>
        </trans-unit>
        <trans-unit id="b43e2a7c9e04ff83908291bc454ceb95c66f26d2" translate="yes" xml:space="preserve">
          <source>Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt;.</source>
          <target state="translated">使用mailmap文件将作者和提交者的姓名和电子邮件地址映射到规范的真实姓名和电子邮件地址。参见&lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="869311b9e64386ec94c4224dbda98ca212bcb863" translate="yes" xml:space="preserve">
          <source>Use merging strategies to rebase. When the recursive (default) merge strategy is used, this allows rebase to be aware of renames on the upstream side.</source>
          <target state="translated">使用合并策略来rebase。当使用递归(默认)合并策略时,可以让rebase意识到上游侧的重名。</target>
        </trans-unit>
        <trans-unit id="504dd078aaf1ec972f6af826bbe142e1450759fa" translate="yes" xml:space="preserve">
          <source>Use of &quot;topic branches&quot; solves these problems. The name is pretty self explanatory, with a caveat that comes from the &quot;merge upwards&quot; rule above:</source>
          <target state="translated">使用 &quot;主题分支 &quot;可以解决这些问题。这个名字很自圆其说,有一个注意事项,来自于上面的 &quot;向上合并 &quot;规则。</target>
        </trans-unit>
        <trans-unit id="2997460999cadfc1fcc5d52315d53b3d5efcd07d" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;dcommit&lt;/code&gt; is preferred to &lt;code&gt;set-tree&lt;/code&gt; (below).</source>
          <target state="translated">首选使用 &lt;code&gt;dcommit&lt;/code&gt; 来 &lt;code&gt;set-tree&lt;/code&gt; （如下）。</target>
        </trans-unit>
        <trans-unit id="6b08c4843a60fcea417d6fa6b7562621b3124054" translate="yes" xml:space="preserve">
          <source>Use of this utility is encouraged in favor of directly accessing files under the &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">鼓励使用此实用程序，以便直接访问 &lt;code&gt;.git&lt;/code&gt; 目录下的文件。</target>
        </trans-unit>
        <trans-unit id="3a96544176d9c64bcdfe76616987380a83e4f896" translate="yes" xml:space="preserve">
          <source>Use permissions reported by umask(2). The default, when &lt;code&gt;--shared&lt;/code&gt; is not specified.</source>
          <target state="translated">使用umask（2）报告的权限。默认值 &lt;code&gt;--shared&lt;/code&gt; 未指定。</target>
        </trans-unit>
        <trans-unit id="7b2e5a64a2bb1a5fbe6304abee401e1d3f35a8f4" translate="yes" xml:space="preserve">
          <source>Use reflog to find a better common ancestor between &amp;lt;upstream&amp;gt; and &amp;lt;branch&amp;gt; when calculating which commits have been introduced by &amp;lt;branch&amp;gt;.</source>
          <target state="translated">在计算&amp;lt;branch&amp;gt;引入了哪些提交时，使用reflog在&amp;lt;upstream&amp;gt;和&amp;lt;branch&amp;gt;之间找到更好的共同祖先。</target>
        </trans-unit>
        <trans-unit id="b40e39ff3f77007104d997879dd735023a9dca06" translate="yes" xml:space="preserve">
          <source>Use revisions from revs-file instead of calling &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;.</source>
          <target state="translated">使用revs-file中的修订，而不是调用&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efb298546ca010c6e357a2c3cc79d1b86fb2f356" translate="yes" xml:space="preserve">
          <source>Use the &quot;sparse&quot; algorithm to determine which objects to include in the pack, when combined with the &quot;--revs&quot; option. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames.</source>
          <target state="translated">当与&quot;--revs &quot;选项结合使用时,使用 &quot;sparse &quot;算法来决定哪些对象要包含在包中。这个算法只走出现在引入新对象的路径中的树。这在计算发送一个小变化的包时可以有显著的性能优势。然而,如果包含的提交包含某些类型的直接重命名,那么额外的对象有可能被添加到包文件中。</target>
        </trans-unit>
        <trans-unit id="0755f10a2fd51824d1737b45b49a4642d66873f8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--in-place&lt;/code&gt; option to edit a message file in place:</source>
          <target state="translated">使用 &lt;code&gt;--in-place&lt;/code&gt; 选项可就地编辑消息文件：</target>
        </trans-unit>
        <trans-unit id="55e7e1126d3aa0a5c8bf2360dfcd495bb1107882" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute only if you cannot store a file in UTF-8 encoding and if you want Git to be able to process the content as text.</source>
          <target state="translated">仅当您不能以UTF-8编码存储文件并且希望Git能够将内容作为文本处理时，才使用 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="b5ec705c3f1e9d70bd95302efbf5732684172042" translate="yes" xml:space="preserve">
          <source>Use the branch detection algorithm to find new paths in p4. It is documented below in &quot;BRANCH DETECTION&quot;.</source>
          <target state="translated">在p4中使用分支检测算法来寻找新的路径。下面在 &quot;BRANCH DETECTION &quot;中进行了说明。</target>
        </trans-unit>
        <trans-unit id="33ac56041ae34da6b3682a94d8a665913a47636a" translate="yes" xml:space="preserve">
          <source>Use the credential (e.g., access the URL with the username and password from step (2)), and see if it&amp;rsquo;s accepted.</source>
          <target state="translated">使用凭据（例如，使用步骤（2）中的用户名和密码访问URL），然后查看它是否被接受。</target>
        </trans-unit>
        <trans-unit id="4cfefdd524d37cf0c1fedc168c903048fc636bbd" translate="yes" xml:space="preserve">
          <source>Use the customized color for the part of git-blame output that is repeated meta information per line (such as commit id, author name, date and timezone). Defaults to cyan.</source>
          <target state="translated">为 git-blame 输出中每行重复元信息(如提交 ID、作者名、日期和时区)的部分使用自定义颜色。默认为青色。</target>
        </trans-unit>
        <trans-unit id="a024bae6c0f6ae8fa68e77c95e0c4f95100aa970" translate="yes" xml:space="preserve">
          <source>Use the diff tool specified by &amp;lt;tool&amp;gt;. Valid values include emerge, kompare, meld, and vimdiff. Run &lt;code&gt;git difftool --tool-help&lt;/code&gt; for the list of valid &amp;lt;tool&amp;gt; settings.</source>
          <target state="translated">使用&amp;lt;tool&amp;gt;指定的差异工具。有效值包括emerge，kompare，meld和vimdiff。运行 &lt;code&gt;git difftool --tool-help&lt;/code&gt; 以获得有效的&amp;lt;tool&amp;gt;设置列表。</target>
        </trans-unit>
        <trans-unit id="161588bc8b76efbad18d428ccf6e2f5e459908d1" translate="yes" xml:space="preserve">
          <source>Use the fast patchset import strategy. This can be significantly faster for large trees, but cannot handle directory renames or permissions changes. The default strategy is slow and safe.</source>
          <target state="translated">使用快速补丁集导入策略。这对于大型树来说,速度会显著加快,但不能处理目录重命名或权限更改。默认策略是缓慢而安全的。</target>
        </trans-unit>
        <trans-unit id="89541b63bc820ad5c76ea37101a62452ee62e61c" translate="yes" xml:space="preserve">
          <source>Use the following attributes if your &lt;code&gt;*.ps1&lt;/code&gt; files are UTF-16 little endian encoded without BOM and you want Git to use Windows line endings in the working directory (use &lt;code&gt;UTF-16LE-BOM&lt;/code&gt; instead of &lt;code&gt;UTF-16LE&lt;/code&gt; if you want UTF-16 little endian with BOM). Please note, it is highly recommended to explicitly define the line endings with &lt;code&gt;eol&lt;/code&gt; if the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute is used to avoid ambiguity.</source>
          <target state="translated">如果您的 &lt;code&gt;*.ps1&lt;/code&gt; 文件使用UTF-16小尾数编码而不带BOM，并且您希望Git在工作目录中使用Windows行尾（请使用 &lt;code&gt;UTF-16LE-BOM&lt;/code&gt; 而不是 &lt;code&gt;UTF-16LE&lt;/code&gt; )，请使用以下属性BOM的小尾数）。请注意，如果使用 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性以避免歧义，强烈建议使用 &lt;code&gt;eol&lt;/code&gt; 明确定义行尾。</target>
        </trans-unit>
        <trans-unit id="e5c2f58b6a6ebc713504e60181f4f0dd37da2d6d" translate="yes" xml:space="preserve">
          <source>Use the given &amp;lt;msg&amp;gt; as the commit message. If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs.</source>
          <target state="translated">使用给定的&amp;lt;msg&amp;gt;作为提交消息。如果给出了多个 &lt;code&gt;-m&lt;/code&gt; 选项，则它们的值将串联为单独的段落。</target>
        </trans-unit>
        <trans-unit id="be3b9715415e0357d3d87d01aa8f812c871fb1e1" translate="yes" xml:space="preserve">
          <source>Use the given &lt;code&gt;msg&lt;/code&gt; as the commit message. This option disables the &lt;code&gt;--edit&lt;/code&gt; option.</source>
          <target state="translated">使用给定的 &lt;code&gt;msg&lt;/code&gt; 作为提交消息。此选项禁用 &lt;code&gt;--edit&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="43103d879018fa15a44cefa9b3baec705e25165c" translate="yes" xml:space="preserve">
          <source>Use the given config file instead of the one specified by GIT_CONFIG.</source>
          <target state="translated">使用给定的配置文件代替GIT_CONFIG指定的文件。</target>
        </trans-unit>
        <trans-unit id="6d07104b51b424f44cb0346a9ac8f4116b0f06d7" translate="yes" xml:space="preserve">
          <source>Use the given exclude pattern in addition to the standard ignore rules (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;).</source>
          <target state="translated">除了标准的忽略规则（请参阅&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;）之外，还使用给定的排除模式。</target>
        </trans-unit>
        <trans-unit id="9a12bbd112f0b48f03fdbbbb0b9c68268bedd960" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy. If there is no &lt;code&gt;-s&lt;/code&gt; option &lt;code&gt;git merge-recursive&lt;/code&gt; is used instead. This implies --merge.</source>
          <target state="translated">使用给定的合并策略。如果没有 &lt;code&gt;-s&lt;/code&gt; 选项，则使用 &lt;code&gt;git merge-recursive&lt;/code&gt; 。这意味着--merge。</target>
        </trans-unit>
        <trans-unit id="aad779cdebc63bc4b25eb19e46a7b214101b70ea" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy. Should only be used once. See the MERGE STRATEGIES section in &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details.</source>
          <target state="translated">使用给定的合并策略。只能使用一次。有关详细信息，请参见&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]中的&amp;ldquo;合并&lt;/a&gt;策略&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="0d697cccd6049781089822f14d706ae91b43a781" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no &lt;code&gt;-s&lt;/code&gt; option, a built-in list of strategies is used instead (&lt;code&gt;git merge-recursive&lt;/code&gt; when merging a single head, &lt;code&gt;git merge-octopus&lt;/code&gt; otherwise).</source>
          <target state="translated">使用给定的合并策略；可以多次提供，以按应尝试的顺序指定它们。如果没有 &lt;code&gt;-s&lt;/code&gt; 选项，则使用内置策略列表代替（ &lt;code&gt;git merge-recursive&lt;/code&gt; 单个头部时使用git merge-recursive，否则使用 &lt;code&gt;git merge-octopus&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e15a6801b533c61848133f0481a1499ec359e784" translate="yes" xml:space="preserve">
          <source>Use the given note message (instead of prompting). If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs. Lines starting with &lt;code&gt;#&lt;/code&gt; and empty lines other than a single line between paragraphs will be stripped out.</source>
          <target state="translated">使用给定的注释消息（而不是提示）。如果给出了多个 &lt;code&gt;-m&lt;/code&gt; 选项，则它们的值将串联为单独的段落。以 &lt;code&gt;#&lt;/code&gt; 开头的行和段落之间的空行（段落之间的单行除外）将被删除。</target>
        </trans-unit>
        <trans-unit id="2301e57be484e5bf3374c6061960726be52acd3f" translate="yes" xml:space="preserve">
          <source>Use the given tag message (instead of prompting). If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs. Implies &lt;code&gt;-a&lt;/code&gt; if none of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is given.</source>
          <target state="translated">使用给定的标记消息（而不是提示）。如果给出了多个 &lt;code&gt;-m&lt;/code&gt; 选项，则它们的值将串联为单独的段落。意味着 &lt;code&gt;-a&lt;/code&gt; 如果没有的 &lt;code&gt;-a&lt;/code&gt; ， &lt;code&gt;-s&lt;/code&gt; ，或 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 给出。</target>
        </trans-unit>
        <trans-unit id="52a6c166f490dbb0be0d25b65f46015f7e67e623" translate="yes" xml:space="preserve">
          <source>Use the interactive patch selection interface to chose which changes to commit. See &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; for details.</source>
          <target state="translated">使用交互式补丁选择界面选择要提交的更改。有关详细信息，请参见&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7db128e87ada4e1ec3f3340d8431acfc429f3677" translate="yes" xml:space="preserve">
          <source>Use the merge resolution program specified by &amp;lt;tool&amp;gt;. Valid values include emerge, gvimdiff, kdiff3, meld, vimdiff, and tortoisemerge. Run &lt;code&gt;git mergetool --tool-help&lt;/code&gt; for the list of valid &amp;lt;tool&amp;gt; settings.</source>
          <target state="translated">使用&amp;lt;tool&amp;gt;指定的合并解决程序。有效值包括emerge，gvimdiff，kdiff3，meld，vimdiff和tortoisemerge。运行 &lt;code&gt;git mergetool --tool-help&lt;/code&gt; 以获得有效的&amp;lt;tool&amp;gt;设置列表。</target>
        </trans-unit>
        <trans-unit id="047156e36b9d6e8b2155d32a029545b1b026f10e" translate="yes" xml:space="preserve">
          <source>Use the multi-pack-index file to track multiple packfiles using a single index. See &lt;a href=&quot;multi-pack-index&quot;&gt;the multi-pack-index design document&lt;/a&gt;.</source>
          <target state="translated">使用multi-pack-index文件可使用单个索引跟踪多个packfile。请参阅&lt;a href=&quot;multi-pack-index&quot;&gt;multi-pack-index设计文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6bac5b4ccbcc396e691c8ba8f2af89d4f60c9270" translate="yes" xml:space="preserve">
          <source>Use the same output mode as &lt;a href=&quot;git-annotate&quot;&gt;git-annotate[1]&lt;/a&gt; (Default: off).</source>
          <target state="translated">使用与&lt;a href=&quot;git-annotate&quot;&gt;git-annotate [1]&lt;/a&gt;相同的输出模式（默认值：关闭）。</target>
        </trans-unit>
        <trans-unit id="0ed67a2ecd3a9ee96ae4cd7dcb45f48a2cf84bf4" translate="yes" xml:space="preserve">
          <source>Use the selected commit message without launching an editor. For example, &lt;code&gt;git commit --amend --no-edit&lt;/code&gt; amends a commit without changing its commit message.</source>
          <target state="translated">使用选定的提交消息而不启动编辑器。例如， &lt;code&gt;git commit --amend --no-edit&lt;/code&gt; 修改提交而不更改其提交消息。</target>
        </trans-unit>
        <trans-unit id="8e65c034e7da87d64be153e02b39a8529bd16f67" translate="yes" xml:space="preserve">
          <source>Use the source ref that matches &lt;code&gt;master&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) to update the ref that matches &lt;code&gt;satellite/master&lt;/code&gt; (most probably &lt;code&gt;refs/remotes/satellite/master&lt;/code&gt;) in the &lt;code&gt;mothership&lt;/code&gt; repository; do the same for &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;satellite/dev&lt;/code&gt;.</source>
          <target state="translated">使用与 &lt;code&gt;master&lt;/code&gt; 匹配的源ref （例如 &lt;code&gt;refs/heads/master&lt;/code&gt; ）来更新与 &lt;code&gt;mothership&lt;/code&gt; 库中的 &lt;code&gt;satellite/master&lt;/code&gt; 匹配的ref （最有可能是 &lt;code&gt;refs/remotes/satellite/master&lt;/code&gt; ）；对 &lt;code&gt;dev&lt;/code&gt; 和 &lt;code&gt;satellite/dev&lt;/code&gt; 做同样的事情。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
