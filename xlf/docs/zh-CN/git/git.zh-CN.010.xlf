<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="35e3581a01e860cba15921ad7e00a74542d34f54" translate="yes" xml:space="preserve">
          <source>The merge backend works with a full copy of each relevant file, insulating it from these types of problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c94b31b25e0c09828d4438bdd636247e16e902" translate="yes" xml:space="preserve">
          <source>The merge backend works with the full commits on both sides of history and thus has no such limitations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657f593653b8985b76ea363799992d9ccd8552d1" translate="yes" xml:space="preserve">
          <source>The merge driver can learn the pathname in which the merged result will be stored via placeholder &lt;code&gt;%P&lt;/code&gt;.</source>
          <target state="translated">合并驱动程序可以通过占位符 &lt;code&gt;%P&lt;/code&gt; 来学习将合并结果存储在其中的路径名。</target>
        </trans-unit>
        <trans-unit id="3a4ee88dc1fd419e5903b5a6b97383e8c2a1fab9" translate="yes" xml:space="preserve">
          <source>The merge driver is expected to leave the result of the merge in the file named with &lt;code&gt;%A&lt;/code&gt; by overwriting it, and exit with zero status if it managed to merge them cleanly, or non-zero if there were conflicts.</source>
          <target state="translated">期望合并驱动程序通过覆盖将合并结果保留在以 &lt;code&gt;%A&lt;/code&gt; 命名的文件中，如果它设法干净地合并它们，则退出状态为零；如果存在冲突，则合并状态为非零。</target>
        </trans-unit>
        <trans-unit id="d39522f0982abae4a359335f63ed088d0f4a4c4e" translate="yes" xml:space="preserve">
          <source>The merge mechanism (&lt;code&gt;git merge&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; commands) allows the backend &lt;code&gt;merge strategies&lt;/code&gt; to be chosen with &lt;code&gt;-s&lt;/code&gt; option. Some strategies can also take their own options, which can be passed by giving &lt;code&gt;-X&amp;lt;option&amp;gt;&lt;/code&gt; arguments to &lt;code&gt;git merge&lt;/code&gt; and/or &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">合并机制（ &lt;code&gt;git merge&lt;/code&gt; 和 &lt;code&gt;git pull&lt;/code&gt; 命令）允许使用 &lt;code&gt;-s&lt;/code&gt; 选项选择后端 &lt;code&gt;merge strategies&lt;/code&gt; 。某些策略也可以采用自己的选项，可以通过为 &lt;code&gt;git merge&lt;/code&gt; 和/或 &lt;code&gt;git pull&lt;/code&gt; 提供 &lt;code&gt;-X&amp;lt;option&amp;gt;&lt;/code&gt; 参数来传递它们。</target>
        </trans-unit>
        <trans-unit id="fa594438c3581495b74bb79c047cb66382bd8b0d" translate="yes" xml:space="preserve">
          <source>The merge workflow works by copying branches between upstream and downstream. Upstream can merge contributions into the official history; downstream base their work on the official history.</source>
          <target state="translated">合并工作流的工作原理是在上游和下游之间复制分支。上游可以将贡献合并到官方历史中;下游则以官方历史为基础开展工作。</target>
        </trans-unit>
        <trans-unit id="1df107645dfce75dc8613a8a0f6007cf8381d780" translate="yes" xml:space="preserve">
          <source>The merge-base command finds a common ancestor of the given commits, and always returns one or the other in the case where one is a descendant of the other; so the above output shows that e05db0fd actually is an ancestor of v1.5.0-rc1.</source>
          <target state="translated">merge-base命令可以找到给定提交的共同祖先,如果一个是另一个的后裔,总是返回一个或另一个;所以上面的输出显示e05db0fd实际上是v1.5.0-rc1的祖先。</target>
        </trans-unit>
        <trans-unit id="91d3bf0b3d356085e2e60914fc9a13ad2e2b8ebf" translate="yes" xml:space="preserve">
          <source>The message in a commit or a tag object is &lt;code&gt;contents&lt;/code&gt;, from which &lt;code&gt;contents:&amp;lt;part&amp;gt;&lt;/code&gt; can be used to extract various parts out of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f5c4372c6fc154ead993a9f4b5a82da922524d" translate="yes" xml:space="preserve">
          <source>The message taken from file with &lt;code&gt;-F&lt;/code&gt; and command line with &lt;code&gt;-m&lt;/code&gt; are usually used as the tag message unmodified. This option lets you further edit the message taken from these sources.</source>
          <target state="translated">从 &lt;code&gt;-F&lt;/code&gt; 的文件中获取的消息和 &lt;code&gt;-m&lt;/code&gt; 的命令行中获取的消息通常用作未修改的标记消息。此选项使您可以进一步编辑从这些来源获取的消息。</target>
        </trans-unit>
        <trans-unit id="1e2b72f6afed427d21f4e345d320e470730d82f9" translate="yes" xml:space="preserve">
          <source>The message taken from file with &lt;code&gt;-F&lt;/code&gt;, command line with &lt;code&gt;-m&lt;/code&gt;, and from commit object with &lt;code&gt;-C&lt;/code&gt; are usually used as the commit log message unmodified. This option lets you further edit the message taken from these sources.</source>
          <target state="translated">从 &lt;code&gt;-F&lt;/code&gt; 的文件，从 &lt;code&gt;-m&lt;/code&gt; 的命令行和从 &lt;code&gt;-C&lt;/code&gt; 的提交对象获取的消息通常用作未修改的提交日志消息。此选项使您可以进一步编辑从这些来源获取的消息。</target>
        </trans-unit>
        <trans-unit id="ae16f65784862fd6e529b736650355763df13327" translate="yes" xml:space="preserve">
          <source>The method by which a submodule is updated by &lt;code&gt;git submodule update&lt;/code&gt;, which is the only affected command, others such as &lt;code&gt;git checkout --recurse-submodules&lt;/code&gt; are unaffected. It exists for historical reasons, when &lt;code&gt;git submodule&lt;/code&gt; was the only command to interact with submodules; settings like &lt;code&gt;submodule.active&lt;/code&gt; and &lt;code&gt;pull.rebase&lt;/code&gt; are more specific. It is populated by &lt;code&gt;git submodule init&lt;/code&gt; from the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file. See description of &lt;code&gt;update&lt;/code&gt; command in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git submodule update&lt;/code&gt; 用来更新子模块的方法是唯一受影响的命令，而 &lt;code&gt;git checkout --recurse-submodules&lt;/code&gt; 等其他命令则不受影响。由于历史原因，它存在，当时 &lt;code&gt;git submodule&lt;/code&gt; 是与子模块进行交互的唯一命令。诸如 &lt;code&gt;submodule.active&lt;/code&gt; 和 &lt;code&gt;pull.rebase&lt;/code&gt; 之类的设置更为具体。它是由填充 &lt;code&gt;git submodule init&lt;/code&gt; 从&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;的文件。参见&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt;中 &lt;code&gt;update&lt;/code&gt; 命令的描述。</target>
        </trans-unit>
        <trans-unit id="04ef06b50b9899f38b1e5f5c81eb00396b6d2328" translate="yes" xml:space="preserve">
          <source>The mode parameter is optional (defaults to &lt;code&gt;all&lt;/code&gt;), and is used to specify the handling of untracked files; when -u is not used, the default is &lt;code&gt;normal&lt;/code&gt;, i.e. show untracked files and directories.</source>
          <target state="translated">mode参数是可选的（默认为 &lt;code&gt;all&lt;/code&gt; ），用于指定未跟踪文件的处理；当不使用-u时，默认值为 &lt;code&gt;normal&lt;/code&gt; ，即显示未跟踪的文件和目录。</target>
        </trans-unit>
        <trans-unit id="daee71f2e966cf5f390a0401b9f0381f1242178c" translate="yes" xml:space="preserve">
          <source>The mode parameter is used to specify the handling of ignored files. It is optional: it defaults to &lt;code&gt;traditional&lt;/code&gt;.</source>
          <target state="translated">mode参数用于指定忽略文件的处理。它是可选的：默认为 &lt;code&gt;traditional&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="789771a80f50eaf70002a855307c4e88ea3d25bd" translate="yes" xml:space="preserve">
          <source>The mode parameter is used to specify the handling of untracked files. It is optional: it defaults to &lt;code&gt;all&lt;/code&gt;, and if specified, it must be stuck to the option (e.g. &lt;code&gt;-uno&lt;/code&gt;, but not &lt;code&gt;-u no&lt;/code&gt;).</source>
          <target state="translated">mode参数用于指定未跟踪文件的处理。它是可选的：默认为 &lt;code&gt;all&lt;/code&gt; ，并且如果指定，则必须坚持使用该选项（例如， &lt;code&gt;-uno&lt;/code&gt; ，而不是 &lt;code&gt;-u no&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d56062b3fd6eee94e49e5896b7d127ee25df01a1" translate="yes" xml:space="preserve">
          <source>The modifications stashed away by this command can be listed with &lt;code&gt;git stash list&lt;/code&gt;, inspected with &lt;code&gt;git stash show&lt;/code&gt;, and restored (potentially on top of a different commit) with &lt;code&gt;git stash apply&lt;/code&gt;. Calling &lt;code&gt;git stash&lt;/code&gt; without any arguments is equivalent to &lt;code&gt;git stash push&lt;/code&gt;. A stash is by default listed as &quot;WIP on &lt;code&gt;branchname&lt;/code&gt; &amp;hellip;​&quot;, but you can give a more descriptive message on the command line when you create one.</source>
          <target state="translated">可以使用 &lt;code&gt;git stash list&lt;/code&gt; 列出该修改保存的修改，可以使用 &lt;code&gt;git stash show&lt;/code&gt; 进行检查，还可以使用 &lt;code&gt;git stash apply&lt;/code&gt; 恢复（可能在其他提交之上）。不带任何参数调用 &lt;code&gt;git stash&lt;/code&gt; 等效于 &lt;code&gt;git stash push&lt;/code&gt; 。默认情况下，存储项显示为&amp;ldquo; WIP on &lt;code&gt;branchname&lt;/code&gt; &amp;hellip;&amp;rdquo;，但是在创建存储项时，可以在命令行上提供更具描述性的消息。</target>
        </trans-unit>
        <trans-unit id="e06fa83026ee56ec3b62a659fa5a44c6e4e4728d" translate="yes" xml:space="preserve">
          <source>The module path (only needed if httpd is Apache). (Default: /usr/lib/apache2/modules)</source>
          <target state="translated">模块路径(只有当httpd是Apache时才需要)。(默认:/usr/lib/apache2/modules)</target>
        </trans-unit>
        <trans-unit id="08ed4170506fa174e84f549a0e3f26086c486529" translate="yes" xml:space="preserve">
          <source>The more complex forms are:</source>
          <target state="translated">比较复杂的形式是:</target>
        </trans-unit>
        <trans-unit id="7d735293dee944ca58932a7261110828d307c793" translate="yes" xml:space="preserve">
          <source>The most common cause of dangling objects is that you&amp;rsquo;ve rebased a branch, or you have pulled from somebody else who rebased a branch&amp;mdash;​see &lt;a href=&quot;#cleaning-up-history&quot;&gt;Rewriting history and maintaining patch series&lt;/a&gt;. In that case, the old head of the original branch still exists, as does everything it pointed to. The branch pointer itself just doesn&amp;rsquo;t, since you replaced it with another one.</source>
          <target state="translated">导致对象悬空的最常见原因是您已经重新建立了分支的基础，或者已经从重新建立分支的其他人那里撤走了-请参阅&lt;a href=&quot;#cleaning-up-history&quot;&gt;重写历史记录和维护修补程序系列&lt;/a&gt;。在这种情况下，原始分支的旧头仍然存在，它指向的所有内容也一样。分支指针本身只是不行，因为您已将其替换为另一个。</target>
        </trans-unit>
        <trans-unit id="8bc143dd44c89f63596943262174b04211332773" translate="yes" xml:space="preserve">
          <source>The multi-pack-index (MIDX for short) stores a list of objects and their offsets into multiple packfiles. It contains:</source>
          <target state="translated">多包索引(简称MIDX)将对象列表及其偏移量存储到多个包文件中。它包含:</target>
        </trans-unit>
        <trans-unit id="4ca15f678a55a1443f2d701a54958e45ad8a0235" translate="yes" xml:space="preserve">
          <source>The multi-pack-index allows many packfiles, especially in a context where repacking is expensive (such as a very large repo), or unexpected maintenance time is unacceptable (such as a high-demand build machine). However, the multi-pack-index needs to be rewritten in full every time. We can extend the format to be incremental, so writes are fast. By storing a small &quot;tip&quot; multi-pack-index that points to large &quot;base&quot; MIDX files, we can keep writes fast while still reducing the number of binary searches required for object lookups.</source>
          <target state="translated">multi-pack-index允许许多packfiles,特别是在重新打包成本很高的情况下(比如一个非常大的repo),或者意外的维护时间是不可接受的(比如一个高需求的构建机)。然而,多包索引每次都需要全部重写。我们可以将格式扩展为增量,所以写入速度很快。通过存储一个小的 &quot;小费 &quot;多包索引,指向大的 &quot;基础 &quot;MIDX文件,我们可以保持快速写入,同时还可以减少对象查找所需的二进制搜索次数。</target>
        </trans-unit>
        <trans-unit id="d98c840529f1ab7c2fa3df48a823219f4ff9a17e" translate="yes" xml:space="preserve">
          <source>The multi-pack-index files refer to multiple pack-files and loose objects.</source>
          <target state="translated">多包索引文件指的是多包文件和松散对象。</target>
        </trans-unit>
        <trans-unit id="1e0c8af9211e361d1a35789c37df84247f7ae9ac" translate="yes" xml:space="preserve">
          <source>The name and the e-mail address of the owner of the key that signed the push certificate.</source>
          <target state="translated">签署推送证书的密钥所有者的姓名和电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="2551d22d5e60fb51293e5ef827d3f2d640624d55" translate="yes" xml:space="preserve">
          <source>The name of a commit at which to start the new branch; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details. Defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">开始新分支的提交的名称；有关详细信息，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;。默认为 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0efd5464958e1be85e38672256be6f6e17bc462a" translate="yes" xml:space="preserve">
          <source>The name of a local ref which can be considered &amp;ldquo;upstream&amp;rdquo; from the displayed ref. Respects &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt; and &lt;code&gt;:rstrip&lt;/code&gt; in the same way as &lt;code&gt;refname&lt;/code&gt; above. Additionally respects &lt;code&gt;:track&lt;/code&gt; to show &quot;[ahead N, behind M]&quot; and &lt;code&gt;:trackshort&lt;/code&gt; to show the terse version: &quot;&amp;gt;&quot; (ahead), &quot;&amp;lt;&quot; (behind), &quot;&amp;lt;&amp;gt;&quot; (ahead and behind), or &quot;=&quot; (in sync). &lt;code&gt;:track&lt;/code&gt; also prints &quot;[gone]&quot; whenever unknown upstream ref is encountered. Append &lt;code&gt;:track,nobracket&lt;/code&gt; to show tracking information without brackets (i.e &quot;ahead N, behind M&quot;).</source>
          <target state="translated">本地裁判的名称，可以将其视为所显示裁判的&amp;ldquo;上游&amp;rdquo;。与上面的 &lt;code&gt;refname&lt;/code&gt; 一样，尊重 &lt;code&gt;:short&lt;/code&gt; ， &lt;code&gt;:lstrip&lt;/code&gt; 和 &lt;code&gt;:rstrip&lt;/code&gt; 。另外， &lt;code&gt;:track&lt;/code&gt; 表示&amp;ldquo; [[N之前，M后面]&amp;rdquo;，而 &lt;code&gt;:trackshort&lt;/code&gt; 表示简洁的版本：&amp;ldquo;&amp;gt;&amp;rdquo;（前面），&amp;ldquo; &amp;lt;&amp;rdquo;（后面），&amp;ldquo; &amp;lt;&amp;gt;&amp;rdquo;（前面和后面）或&amp;ldquo; =&amp;ldquo;（同步）。 &lt;code&gt;:track&lt;/code&gt; 每当遇到未知的上游引用时也会打印&amp;ldquo; [gone]&amp;rdquo;。附加 &lt;code&gt;:track,nobracket&lt;/code&gt; 以不带括号的方式显示跟踪信息（即&amp;ldquo; N前面，M后面&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="285243cf13ade280f7038dfb92bbdaa7d26dec36" translate="yes" xml:space="preserve">
          <source>The name of a local ref which represents the &lt;code&gt;@{push}&lt;/code&gt; location for the displayed ref. Respects &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt;, &lt;code&gt;:rstrip&lt;/code&gt;, &lt;code&gt;:track&lt;/code&gt;, &lt;code&gt;:trackshort&lt;/code&gt;, &lt;code&gt;:remotename&lt;/code&gt;, and &lt;code&gt;:remoteref&lt;/code&gt; options as &lt;code&gt;upstream&lt;/code&gt; does. Produces an empty string if no &lt;code&gt;@{push}&lt;/code&gt; ref is configured.</source>
          <target state="translated">本地引用的名称，代表所显示引用的 &lt;code&gt;@{push}&lt;/code&gt; 位置。与 &lt;code&gt;upstream&lt;/code&gt; 一样，尊重 &lt;code&gt;:short&lt;/code&gt; ， &lt;code&gt;:lstrip&lt;/code&gt; ， &lt;code&gt;:rstrip&lt;/code&gt; ， &lt;code&gt;:track&lt;/code&gt; ， &lt;code&gt;:trackshort&lt;/code&gt; ， &lt;code&gt;:remotename&lt;/code&gt; 和 &lt;code&gt;:remoteref&lt;/code&gt; remoteref选项。如果未配置 &lt;code&gt;@{push}&lt;/code&gt; 引用，则产生一个空字符串。</target>
        </trans-unit>
        <trans-unit id="25973fbcb02049e23787d52ffa23363b0665166c" translate="yes" xml:space="preserve">
          <source>The name of a new directory to clone into. The &quot;humanish&quot; part of the source repository is used if no directory is explicitly given (&lt;code&gt;repo&lt;/code&gt; for &lt;code&gt;/path/to/repo.git&lt;/code&gt; and &lt;code&gt;foo&lt;/code&gt; for &lt;code&gt;host.xz:foo/.git&lt;/code&gt;). Cloning into an existing directory is only allowed if the directory is empty.</source>
          <target state="translated">要克隆到的新目录的名称。使用源资源库的&amp;ldquo;humanish&amp;rdquo;部分，如果没有目录明确给出（ &lt;code&gt;repo&lt;/code&gt; 为 &lt;code&gt;/path/to/repo.git&lt;/code&gt; 和 &lt;code&gt;foo&lt;/code&gt; 为 &lt;code&gt;host.xz:foo/.git&lt;/code&gt; ）。仅当目录为空时才允许克隆到现有目录。</target>
        </trans-unit>
        <trans-unit id="3c836d4cc86fbcc3a897aa8fab973465c40a1899" translate="yes" xml:space="preserve">
          <source>The name of an existing branch already in fast-import&amp;rsquo;s internal branch table. If fast-import doesn&amp;rsquo;t know the name, it&amp;rsquo;s treated as a SHA-1 expression.</source>
          <target state="translated">快速导入的内部分支表中已存在的分支的名称。如果快速导入不知道名称，则将其视为SHA-1表达式。</target>
        </trans-unit>
        <trans-unit id="c21a579b2f8550495cd7f286a4f77b45b3df2f6e" translate="yes" xml:space="preserve">
          <source>The name of an existing branch to rename.</source>
          <target state="translated">要重命名的现有分支的名称。</target>
        </trans-unit>
        <trans-unit id="b35cfa9e6735c6918643ac8769ab4e5dd81020f0" translate="yes" xml:space="preserve">
          <source>The name of an external credential helper, and any associated options. If the helper name is not an absolute path, then the string &lt;code&gt;git
credential-&lt;/code&gt; is prepended. The resulting string is executed by the shell (so, for example, setting this to &lt;code&gt;foo --option=bar&lt;/code&gt; will execute &lt;code&gt;git credential-foo --option=bar&lt;/code&gt; via the shell. See the manual of specific helpers for examples of their use.</source>
          <target state="translated">外部凭据助手的名称以及任何关联的选项。如果助手名称不是绝对路径，那么将使用字符串 &lt;code&gt;git credential-&lt;/code&gt; 。结果字符串由外壳程序执行（例如，将其设置为 &lt;code&gt;foo --option=bar&lt;/code&gt; 将通过外壳程序执行 &lt;code&gt;git credential-foo --option=bar&lt;/code&gt; 。有关其用法的示例，请参阅特定帮助程序的手册。</target>
        </trans-unit>
        <trans-unit id="7efaaad02f8c0d5eaaddaa5b6f8a8113410c8ef1" translate="yes" xml:space="preserve">
          <source>The name of one of the following can be used instead of a URL as &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument:</source>
          <target state="translated">可以使用以下任一名称代替URL作为 &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="f54520854ea19fafb55997c9840c558f7f80fed9" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;replace&lt;/code&gt; reference is the SHA-1 of the object that is replaced. The content of the &lt;code&gt;replace&lt;/code&gt; reference is the SHA-1 of the replacement object.</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; 引用的名称是被替换对象的SHA-1。 &lt;code&gt;replace&lt;/code&gt; 引用的内容是替换对象的SHA-1。</target>
        </trans-unit>
        <trans-unit id="117daad0c937bbfd67b26eaa98382dde664a6203" translate="yes" xml:space="preserve">
          <source>The name of the branch to create or delete. The new branch name must pass all checks defined by &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format[1]&lt;/a&gt;. Some of these checks may restrict the characters allowed in a branch name.</source>
          <target state="translated">要创建或删除的分支的名称。新的分支名称必须通过&lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format [1]&lt;/a&gt;定义的所有检查。其中一些检查可能会限制分支名称中允许的字符。</target>
        </trans-unit>
        <trans-unit id="f40b450a4e1f94bf798289a960712dae0a6f632b" translate="yes" xml:space="preserve">
          <source>The name of the client can be given to &lt;code&gt;git p4&lt;/code&gt; in multiple ways. The variable &lt;code&gt;git-p4.client&lt;/code&gt; takes precedence if it exists. Otherwise, normal p4 mechanisms of determining the client are used: environment variable &lt;code&gt;P4CLIENT&lt;/code&gt;, a file referenced by &lt;code&gt;P4CONFIG&lt;/code&gt;, or the local host name.</source>
          <target state="translated">客户端的名称可以通过多种方式赋予 &lt;code&gt;git p4&lt;/code&gt; 。变量 &lt;code&gt;git-p4.client&lt;/code&gt; 优先（如果存在）。否则，将使用确定客户端的常规p4机制：环境变量 &lt;code&gt;P4CLIENT&lt;/code&gt; ， &lt;code&gt;P4CONFIG&lt;/code&gt; 引用的文件或本地主机名。</target>
        </trans-unit>
        <trans-unit id="d25f4900ca4ac26428c337fc8a49a0fffaa87baa" translate="yes" xml:space="preserve">
          <source>The name of the current branch is stored in .git/HEAD.</source>
          <target state="translated">当前分支的名称存储在.git/HEAD中。</target>
        </trans-unit>
        <trans-unit id="9192c74ec25457f29baaadaeb1d2b767ba20ddac" translate="yes" xml:space="preserve">
          <source>The name of the local ref being pushed, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix. In the case of deletion, the name of the local ref is omitted.</source>
          <target state="translated">推送的本地ref的名称减去其 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 前缀。在删除的情况下，将省略本地引用的名称。</target>
        </trans-unit>
        <trans-unit id="61c75d700127b0c70d569d247bca51622e343006" translate="yes" xml:space="preserve">
          <source>The name of the local ref being updated, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix.</source>
          <target state="translated">要更新的本地ref的名称减去其 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="40299b8374a45bc90296f421fddf5763cb8c6908" translate="yes" xml:space="preserve">
          <source>The name of the object to show. For a more complete list of ways to spell object names, see the &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">要显示的对象的名称。有关拼写对象名称的方法的完整列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]中&lt;/a&gt;的&amp;ldquo;指定版本&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="15cfdda92a704493f44c3f6bda85fdb4fe25cc87" translate="yes" xml:space="preserve">
          <source>The name of the ref (the part after $GIT_DIR/). For a non-ambiguous short name of the ref append &lt;code&gt;:short&lt;/code&gt;. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode. If &lt;code&gt;lstrip=&amp;lt;N&amp;gt;&lt;/code&gt; (&lt;code&gt;rstrip=&amp;lt;N&amp;gt;&lt;/code&gt;) is appended, strips &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; slash-separated path components from the front (back) of the refname (e.g. &lt;code&gt;%(refname:lstrip=2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;%(refname:rstrip=2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;refs&lt;/code&gt;). If &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; is a negative number, strip as many path components as necessary from the specified end to leave &lt;code&gt;-&amp;lt;N&amp;gt;&lt;/code&gt; path components (e.g. &lt;code&gt;%(refname:lstrip=-2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;tags/foo&lt;/code&gt; and &lt;code&gt;%(refname:rstrip=-1)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;refs&lt;/code&gt;). When the ref does not have enough components, the result becomes an empty string if stripping with positive &amp;lt;N&amp;gt;, or it becomes the full refname if stripping with negative &amp;lt;N&amp;gt;. Neither is an error.</source>
          <target state="translated">引用的名称（$ GIT_DIR /之后的部分）。对于ref的明确名称，请附加 &lt;code&gt;:short&lt;/code&gt; 。选项core.warnAmbiguousRefs用于选择严格缩写模式。如果 &lt;code&gt;lstrip=&amp;lt;N&amp;gt;&lt;/code&gt; （ &lt;code&gt;rstrip=&amp;lt;N&amp;gt;&lt;/code&gt; ），则从refname的前面（后面） &lt;code&gt;%(refname:lstrip=2)&lt;/code&gt; &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; 斜杠分隔的路径分量（例如，％（refname：lstrip = 2）变成 &lt;code&gt;refs/tags/foo&lt;/code&gt; 变成 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;%(refname:rstrip=2)&lt;/code&gt; 将 &lt;code&gt;refs/tags/foo&lt;/code&gt; 变成 &lt;code&gt;refs&lt;/code&gt; 。如果 &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; 为负数，则从指定的末端剥去尽可能多的路径分量，以保留 &lt;code&gt;-&amp;lt;N&amp;gt;&lt;/code&gt; 路径组件（例如， &lt;code&gt;%(refname:lstrip=-2)&lt;/code&gt; 将 &lt;code&gt;refs/tags/foo&lt;/code&gt; 转换为 &lt;code&gt;tags/foo&lt;/code&gt; ,而 &lt;code&gt;%(refname:rstrip=-1)&lt;/code&gt; 将 &lt;code&gt;refs/tags/foo&lt;/code&gt; 转换为 &lt;code&gt;refs&lt;/code&gt; ）。当ref的分量不足时，如果使用正号&amp;lt;N&amp;gt;进行剥离，结果将为空字符串；如果使用负号&amp;lt;N&amp;gt;进行剥离，则结果将为完整的refname。都不是错误。</target>
        </trans-unit>
        <trans-unit id="d3667dc69f3d60260150d30873ae903291e9c610" translate="yes" xml:space="preserve">
          <source>The name of the remote ref being fetched from, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix. In the case of deletion, the name of the remote ref is &quot;(none)&quot;.</source>
          <target state="translated">从中获取远程引用的名称，减去其 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 前缀。在删除的情况下，远程引用的名称为&amp;ldquo;（无）&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f1e1380262032f81dbdd04e4a724dd0dac2f66a0" translate="yes" xml:space="preserve">
          <source>The name of the remote ref being updated, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix.</source>
          <target state="translated">要更新的远程引用的名称，减去其 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="cf1208454bdf4c7c5a0ab602103e6dd838ca212a" translate="yes" xml:space="preserve">
          <source>The name of the repository in gitweb is the path to its &lt;code&gt;$GIT_DIR&lt;/code&gt; (its object database) relative to &lt;code&gt;$projectroot&lt;/code&gt;. Therefore the repository $repo can be found at &quot;$projectroot/$repo&quot;.</source>
          <target state="translated">gitweb中存储库的名称是其相对于 &lt;code&gt;$projectroot&lt;/code&gt; &lt;code&gt;$GIT_DIR&lt;/code&gt; （其对象数据库）的路径。因此，可以在&amp;ldquo; $ projectroot / $ repo&amp;rdquo;中找到存储库$ repo。</target>
        </trans-unit>
        <trans-unit id="1b6cc45302b6351d18e813818cde0845c0a5a22a" translate="yes" xml:space="preserve">
          <source>The name of the tag to create, delete, or describe. The new tag name must pass all checks defined by &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format[1]&lt;/a&gt;. Some of these checks may restrict the characters allowed in a tag name.</source>
          <target state="translated">要创建，删除或描述的标签的名称。新标签名称必须通过&lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format [1]&lt;/a&gt;定义的所有检查。其中一些检查可能会限制标签名称中允许的字符。</target>
        </trans-unit>
        <trans-unit id="964fd80a7ebc3b646125e059ac3c7f8c3a22061f" translate="yes" xml:space="preserve">
          <source>The named branches will be interpreted as if specified with the &lt;code&gt;-t&lt;/code&gt; option on the &lt;code&gt;git remote add&lt;/code&gt; command line.</source>
          <target state="translated">命名分支将被解释为与 &lt;code&gt;git remote add&lt;/code&gt; 命令行上的 &lt;code&gt;-t&lt;/code&gt; 选项指定的一样。</target>
        </trans-unit>
        <trans-unit id="a7226417649eb7c8f42ca4934a290033c08aad1c" translate="yes" xml:space="preserve">
          <source>The names of objects to show (defaults to &lt;code&gt;HEAD&lt;/code&gt;). For a more complete list of ways to spell object names, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">要显示的对象名称（默认为 &lt;code&gt;HEAD&lt;/code&gt; ）。有关拼写对象名称的方法的完整列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]中的&lt;/a&gt; &amp;ldquo;指定修订版&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="df439b2df93c9264d2652e8aa379f62f3b6ab5ac" translate="yes" xml:space="preserve">
          <source>The names of refs that are fetched, together with the object names they point at, are written to &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt;. This information may be used by scripts or other git commands, such as &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">获取的ref的名称以及它们指向的对象名称将写入 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 。脚本或其他git命令（例如&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]）&lt;/a&gt;可以使用此信息。</target>
        </trans-unit>
        <trans-unit id="1b9c4b549f992b26edb42d00411780a65661d81d" translate="yes" xml:space="preserve">
          <source>The native transport (i.e. git:// URL) does no authentication and should be used with caution on unsecured networks.</source>
          <target state="translated">本机传输(i.e.git://URL)不进行身份验证,在不安全的网络上应谨慎使用。</target>
        </trans-unit>
        <trans-unit id="86d32cda4c46d201605240981feec896fb3daceb" translate="yes" xml:space="preserve">
          <source>The new branch head will point to this commit. It may be given as a branch name, a commit-id, or a tag. If this option is omitted, the current HEAD will be used instead.</source>
          <target state="translated">新的分支头将指向这个提交。它可以是一个分支名,一个提交id,或者一个标签。如果省略了这个选项,则会使用当前的头。</target>
        </trans-unit>
        <trans-unit id="597e47a48a8bd8b3528838dd5cebedeb7b241f60" translate="yes" xml:space="preserve">
          <source>The new name for an existing branch. The same restrictions as for &amp;lt;branchname&amp;gt; apply.</source>
          <target state="translated">现有分支的新名称。适用与&amp;lt;分支名称&amp;gt;相同的限制。</target>
        </trans-unit>
        <trans-unit id="05a068e20a6ba11ea4fd1dbaef65a93e78041978" translate="yes" xml:space="preserve">
          <source>The new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade318097a09c67b5bdaa6c1344cf2a281d7cac8" translate="yes" xml:space="preserve">
          <source>The next parameter is the pattern. This option has to be used for patterns starting with &lt;code&gt;-&lt;/code&gt; and should be used in scripts passing user input to grep. Multiple patterns are combined by &lt;code&gt;or&lt;/code&gt;.</source>
          <target state="translated">下一个参数是模式。此选项必须用于以 &lt;code&gt;-&lt;/code&gt; 开头的模式，并且应在将用户输入传递给grep的脚本中使用。 &lt;code&gt;or&lt;/code&gt; 组合多个模式。</target>
        </trans-unit>
        <trans-unit id="00f28e3b882b5553d45ceeb08082d3dcda522dd0" translate="yes" xml:space="preserve">
          <source>The next step of merging is to merge these three versions of the file, using 3-way merge. This is done by giving &lt;code&gt;git merge-one-file&lt;/code&gt; command as one of the arguments to &lt;code&gt;git merge-index&lt;/code&gt; command:</source>
          <target state="translated">合并的下一步是使用3向合并来合并文件的这三个版本。这是通过给 &lt;code&gt;git merge-one-file&lt;/code&gt; 命令作为 &lt;code&gt;git merge-index&lt;/code&gt; 命令的参数之一来完成的：</target>
        </trans-unit>
        <trans-unit id="c203649e7405cacf1f66f3229b4d864ccf1b5f34" translate="yes" xml:space="preserve">
          <source>The nonce string the process asked the signer to include in the push certificate. If this does not match the value recorded on the &quot;nonce&quot; header in the push certificate, it may indicate that the certificate is a valid one that is being replayed from a separate &quot;git push&quot; session.</source>
          <target state="translated">进程要求签名者在推送证书中包含的 nonce 字符串。如果这个字符串与推送证书中的 &quot;nonce &quot;头记录的值不一致,则可能表明证书是一个有效的证书,正在从一个单独的 &quot;git push &quot;会话中重放。</target>
        </trans-unit>
        <trans-unit id="a81eae6f204563324e9f0299e6e5a18af11339c2" translate="yes" xml:space="preserve">
          <source>The normal format target is a tradition printf format and similar to GIT_TRACE format. This format is enabled with the &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variable or the &lt;code&gt;trace2.normalTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">普通格式的目标是传统的printf格式，与GIT_TRACE格式相似。此格式通过 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 环境变量或 &lt;code&gt;trace2.normalTarget&lt;/code&gt; 系统或全局配置设置启用。</target>
        </trans-unit>
        <trans-unit id="08867837836724d3f4c3cfbd7d03fa5d964eec62" translate="yes" xml:space="preserve">
          <source>The number of additional commits is the number of commits which would be displayed by &quot;git log v1.0.4..parent&quot;. The hash suffix is &quot;-g&quot; + unambiguous abbreviation for the tip commit of parent (which was &lt;code&gt;2414721b194453f058079d897d13c4e377f92dc6&lt;/code&gt;). The &quot;g&quot; prefix stands for &quot;git&quot; and is used to allow describing the version of a software depending on the SCM the software is managed with. This is useful in an environment where people may use different SCMs.</source>
          <target state="translated">附加提交数是&amp;ldquo; git log v1.0.4..parent&amp;rdquo;将显示的提交数。哈希后缀是&amp;ldquo; -g&amp;rdquo; +父代技巧提交的明确缩写（即 &lt;code&gt;2414721b194453f058079d897d13c4e377f92dc6&lt;/code&gt; ）。&amp;ldquo; g&amp;rdquo;前缀代表&amp;ldquo; git&amp;rdquo;，用于根据管理软件的SCM来描述软件的版本。这在人们可能使用不同SCM的环境中很有用。</target>
        </trans-unit>
        <trans-unit id="83386653d6009935020ea78a4c28a793cc5fa198" translate="yes" xml:space="preserve">
          <source>The number of curl sessions (counted across slots) to be kept across requests. They will not be ended with curl_easy_cleanup() until http_cleanup() is invoked. If USE_CURL_MULTI is not defined, this value will be capped at 1. Defaults to 1.</source>
          <target state="translated">在不同的请求中要保留的curl会话的数量(按槽数计算),在http_cleanup()被调用之前,这些会话不会被curl_easy_cleanup()结束。在调用 http_cleanup()之前,它们不会被 curl_easy_cleanup()结束。如果没有定义 USE_CURL_MULTI,这个值的上限是 1,默认为 1。</target>
        </trans-unit>
        <trans-unit id="eb593ed0188a165abaa2fc9b58825ac993fcfa11" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing rename detection during a merge; if not specified, defaults to the value of diff.renameLimit. This setting has no effect if rename detection is turned off.</source>
          <target state="translated">合并过程中执行重命名检测时要考虑的文件数量;如果没有指定,默认为 diff.renameLimit 的值。如果关闭了重命名检测,则此设置没有任何影响;如果没有指定,默认为diff.renameLimit的值。</target>
        </trans-unit>
        <trans-unit id="b49ca7e6ecad75b8cf0b0ec3dcf469e017a13140" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing rename detection in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;. Defaults to the value of diff.renameLimit.</source>
          <target state="translated">在&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;和&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]中&lt;/a&gt;执行重命名检测时要考虑的文件数。默认为diff.renameLimit的值。</target>
        </trans-unit>
        <trans-unit id="62caddb975571c60931b3e5e41910f9ec3dfea6e" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing the copy/rename detection; equivalent to the &lt;code&gt;git diff&lt;/code&gt; option &lt;code&gt;-l&lt;/code&gt;. This setting has no effect if rename detection is turned off.</source>
          <target state="translated">执行复制/重命名检测时要考虑的文件数；等效于 &lt;code&gt;git diff&lt;/code&gt; 选项 &lt;code&gt;-l&lt;/code&gt; 。如果关闭重命名检测，此设置无效。</target>
        </trans-unit>
        <trans-unit id="f40a726880d5eda55c8da498a0add02c8ea2a7b1" translate="yes" xml:space="preserve">
          <source>The number of push options given on the command line of &lt;code&gt;git push --push-option=...&lt;/code&gt; can be read from the environment variable &lt;code&gt;GIT_PUSH_OPTION_COUNT&lt;/code&gt;, and the options themselves are found in &lt;code&gt;GIT_PUSH_OPTION_0&lt;/code&gt;, &lt;code&gt;GIT_PUSH_OPTION_1&lt;/code&gt;,&amp;hellip;​ If it is negotiated to not use the push options phase, the environment variables will not be set. If the client selects to use push options, but doesn&amp;rsquo;t transmit any, the count variable will be set to zero, &lt;code&gt;GIT_PUSH_OPTION_COUNT=0&lt;/code&gt;.</source>
          <target state="translated">可以从环境变量 &lt;code&gt;GIT_PUSH_OPTION_COUNT&lt;/code&gt; 读取 &lt;code&gt;git push --push-option=...&lt;/code&gt; 命令行上给定的push选项数量，这些选项本身可以在 &lt;code&gt;GIT_PUSH_OPTION_0&lt;/code&gt; ， &lt;code&gt;GIT_PUSH_OPTION_1&lt;/code&gt; 中找到，...使用push选项阶段时，将不会设置环境变量。如果客户端选择使用推送选项，但不发送任何推送选项，则count变量将设置为零，即 &lt;code&gt;GIT_PUSH_OPTION_COUNT=0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5ad10bd3ab58adc794f2122271c46d58529bef4" translate="yes" xml:space="preserve">
          <source>The number of spaces between columns. One space by default.</source>
          <target state="translated">列间的空格数。默认为一个空格。</target>
        </trans-unit>
        <trans-unit id="911462b0802b22317c5a57a0a0510dbf0c397a66" translate="yes" xml:space="preserve">
          <source>The number of submodules fetched at the same time. Defaults to the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; option.</source>
          <target state="translated">同时获取的子模块数。默认为 &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="34de3b8749bfae0c14ff8d34783f05c9920748b5" translate="yes" xml:space="preserve">
          <source>The object can be a blob or a submodule commit. It implies the &lt;code&gt;-t&lt;/code&gt; option in &lt;code&gt;git-log&lt;/code&gt; to also find trees.</source>
          <target state="translated">该对象可以是Blob或子模块提交。这意味着 &lt;code&gt;git-log&lt;/code&gt; 中的 &lt;code&gt;-t&lt;/code&gt; 选项也可以找到树。</target>
        </trans-unit>
        <trans-unit id="2794f5933199b4937a09c41b8d049f6b88620c25" translate="yes" xml:space="preserve">
          <source>The object database contains objects of three main types: blobs, which hold file data; trees, which point to blobs and other trees to build up directory hierarchies; and commits, which each reference a single tree and some number of parent commits.</source>
          <target state="translated">对象数据库包含三种主要类型的对象:blobs,存放文件数据;tree,指向blobs和其他树,以建立目录层次结构;commits,每个commits引用一棵树和一些父commits。</target>
        </trans-unit>
        <trans-unit id="b5ea163b65a2243d9fc238d7c50700c517adc350" translate="yes" xml:space="preserve">
          <source>The object database is the rather elegant system used to store the history of your project&amp;mdash;​files, directories, and commits.</source>
          <target state="translated">对象数据库是一个非常优雅的系统，用于存储项目的历史记录-文件，目录和提交。</target>
        </trans-unit>
        <trans-unit id="db080c7937810b605e4381605a2e18077b89e3c0" translate="yes" xml:space="preserve">
          <source>The object name (aka SHA-1). For a non-ambiguous abbreviation of the object name append &lt;code&gt;:short&lt;/code&gt;. For an abbreviation of the object name with desired length append &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt;, where the minimum length is MINIMUM_ABBREV. The length may be exceeded to ensure unique object names.</source>
          <target state="translated">对象名称（又名SHA-1）。对于对象名称的明确缩写，请附加 &lt;code&gt;:short&lt;/code&gt; 。对于具有所需长度的对象名称的缩写，请附加 &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt; ，其中最小长度为MINIMUM_ABBREV。可以超过该长度以确保唯一的对象名称。</target>
        </trans-unit>
        <trans-unit id="b335d1a75376848bee9affb50a6203b316fcc02d" translate="yes" xml:space="preserve">
          <source>The object referenced by &amp;lt;src&amp;gt; is used to update the &amp;lt;dst&amp;gt; reference on the remote side. Whether this is allowed depends on where in &lt;code&gt;refs/*&lt;/code&gt; the &amp;lt;dst&amp;gt; reference lives as described in detail below, in those sections &quot;update&quot; means any modifications except deletes, which as noted after the next few sections are treated differently.</source>
          <target state="translated">&amp;lt;src&amp;gt;引用的对象用于更新远程端的&amp;lt;dst&amp;gt;引用。是否允许这样做取决于 &lt;code&gt;refs/*&lt;/code&gt; 中&amp;lt;dst&amp;gt;引用的位置，如以下详细所述，在那些部分中，&amp;ldquo;更新&amp;rdquo;表示除删除外的任何修改，这在接下来的几节中将作不同处理。</target>
        </trans-unit>
        <trans-unit id="afdbad7acf93ca3457880eb431fd58ab07141e11" translate="yes" xml:space="preserve">
          <source>The object table is actually a hashtable keyed on the object name (the unique SHA-1). This storage configuration allows fast-import to reuse an existing or already written object and avoid writing duplicates to the output packfile. Duplicate blobs are surprisingly common in an import, typically due to branch merges in the source.</source>
          <target state="translated">对象表实际上是一个以对象名称(唯一的SHA-1)为键的哈希特表。这种存储配置允许快速导入重用现有的或已经写好的对象,并避免将重复的对象写入输出包文件。重复的 blobs 在导入中是非常常见的,通常是由于源文件中的分支合并。</target>
        </trans-unit>
        <trans-unit id="0b16e9c4d73790474d293fcd4d96547c235d7d1f" translate="yes" xml:space="preserve">
          <source>The object that the new tag will refer to, usually a commit. Defaults to HEAD.</source>
          <target state="translated">新标签将引用的对象,通常是一个提交。默认为 HEAD。</target>
        </trans-unit>
        <trans-unit id="5468420c6f62137502c6bb00574138b237765047" translate="yes" xml:space="preserve">
          <source>The object type may be a blob, representing the contents of a file, or another tree, representing the contents of a subdirectory. Since trees and blobs, like all other objects, are named by the SHA-1 hash of their contents, two trees have the same SHA-1 name if and only if their contents (including, recursively, the contents of all subdirectories) are identical. This allows Git to quickly determine the differences between two related tree objects, since it can ignore any entries with identical object names.</source>
          <target state="translated">对象类型可以是代表文件内容的blob,也可以是代表子目录内容的树。因为树和blob和其他对象一样,都是用内容的SHA-1哈希值来命名的,所以只有当两个树的内容(包括递归的所有子目录的内容)相同时,它们的SHA-1名称才会相同。这使得Git可以快速确定两个相关树对象之间的差异,因为它可以忽略任何具有相同对象名的条目。</target>
        </trans-unit>
        <trans-unit id="abf9c48e6cb6157bcc4ecdd7fbfd1167ee2a4bc5" translate="yes" xml:space="preserve">
          <source>The object types in some more detail:</source>
          <target state="translated">对象类型更详细一些。</target>
        </trans-unit>
        <trans-unit id="1aa11fdf087f0d8d0d32eb67b923b0efa29ecf46" translate="yes" xml:space="preserve">
          <source>The objects are output in the order in which they are found in the index file, which should be (in a correctly constructed file) sorted by object id.</source>
          <target state="translated">对象是按照它们在索引文件中找到的顺序输出的,索引文件应该(在一个正确构造的文件中)按对象id排序。</target>
        </trans-unit>
        <trans-unit id="113c9617d3615ff46d1de3788621403d384bc970" translate="yes" xml:space="preserve">
          <source>The official repository of the &lt;code&gt;git gui&lt;/code&gt; project can be found at:</source>
          <target state="translated">&lt;code&gt;git gui&lt;/code&gt; 项目的官方存储库位于：</target>
        </trans-unit>
        <trans-unit id="d2925f4342d92a06228b4eeddfbffd0ada540f91" translate="yes" xml:space="preserve">
          <source>The one commit in this list that is not related to CMake may very well have been motivated by working on fixing all those bugs introduced by switching to CMake, but it addresses a different concern. To split this branch into two topic branches, the todo list could be edited like this:</source>
          <target state="translated">这个列表中与 CMake 无关的一个提交,很可能是为了修复切换到 CMake 后引入的所有错误,但它解决的是不同的问题。要把这个分支分成两个主题分支,可以这样编辑todo列表。</target>
        </trans-unit>
        <trans-unit id="680930999bd0e3bf9880124c135a89bca3a329f3" translate="yes" xml:space="preserve">
          <source>The oneline descriptions are purely for your pleasure; &lt;code&gt;git rebase&lt;/code&gt; will not look at them but at the commit names (&quot;deadbee&quot; and &quot;fa1afe1&quot; in this example), so do not delete or edit the names.</source>
          <target state="translated">单行描述纯粹是为了您的愉悦； &lt;code&gt;git rebase&lt;/code&gt; 不会查看它们，而是查看提交名称（在此示例中为&amp;ldquo; deadbee&amp;rdquo;和&amp;ldquo; fa1afe1&amp;rdquo;），因此请勿删除或编辑名称。</target>
        </trans-unit>
        <trans-unit id="b174b5f513a45da66bee660cec63368b38af2a1f" translate="yes" xml:space="preserve">
          <source>The only difference between this command and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; is that they use slightly different output formats, and this command exists only for backward compatibility to support existing scripts, and provide a more familiar command name for people coming from other SCM systems.</source>
          <target state="translated">此命令和&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;之间的唯一区别是，它们使用略有不同的输出格式，并且此命令仅存在用于向后兼容以支持现有脚本，并且为来自其他SCM系统的人提供了更熟悉的命令名称。</target>
        </trans-unit>
        <trans-unit id="90482aceb580582ec33d188b8fb1bca29f8136a1" translate="yes" xml:space="preserve">
          <source>The option can have the following values, defaulting to &lt;code&gt;group&lt;/code&gt; if no value is given:</source>
          <target state="translated">该选项可以具有以下值，如果没有给出值，则默认为 &lt;code&gt;group&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="72a352b7174eb63582b749d1295b267e0dae9887" translate="yes" xml:space="preserve">
          <source>The optional &amp;lt;limit&amp;gt; is useful in cases where your topic is based on other work that is not in upstream. Expanding on the previous example, this might look like:</source>
          <target state="translated">可选的&amp;lt;limit&amp;gt;在主题基于上游以外的其他工作的情况下很有用。在前面的示例上进行扩展，可能类似于：</target>
        </trans-unit>
        <trans-unit id="4136e1c0c625091f77db10ec0b76e55e39fdb1b6" translate="yes" xml:space="preserve">
          <source>The optional &amp;lt;style&amp;gt; argument can be either &lt;code&gt;shallow&lt;/code&gt; or &lt;code&gt;deep&lt;/code&gt;. &lt;code&gt;shallow&lt;/code&gt; threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the &lt;code&gt;--in-reply-to&lt;/code&gt;, and the first patch mail, in this order. &lt;code&gt;deep&lt;/code&gt; threading makes every mail a reply to the previous one.</source>
          <target state="translated">可选的&amp;lt;style&amp;gt;参数可以是 &lt;code&gt;shallow&lt;/code&gt; 或 &lt;code&gt;deep&lt;/code&gt; 。 &lt;code&gt;shallow&lt;/code&gt; 线程使每个邮件都回复到该系列的 &lt;code&gt;--in-reply-to&lt;/code&gt; ，该标题是从求职信，-in-reply-to和第一个补丁邮件中按此顺序选择的。 &lt;code&gt;deep&lt;/code&gt; 线程使每封邮件都回复上一封邮件。</target>
        </trans-unit>
        <trans-unit id="3dd98bdacd886ba292b303baaba2ecefebed8bab" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;encoding&lt;/code&gt; command indicates the encoding of the commit message. Most commits are UTF-8 and the encoding is omitted, but this allows importing commit messages into git without first reencoding them.</source>
          <target state="translated">可选的 &lt;code&gt;encoding&lt;/code&gt; 命令指示提交消息的编码。大多数提交都是UTF-8，并且省略了编码，但这允许将提交消息导入git，而无需先对其进行重新编码。</target>
        </trans-unit>
        <trans-unit id="f1f596d4ea27770161ef3ea6df226eac8321e34f" translate="yes" xml:space="preserve">
          <source>The optional GPG signature of the tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ae75c1b10bf71d7e20ef9926e29585fa74a2e0" translate="yes" xml:space="preserve">
          <source>The optional argument &amp;lt;path&amp;gt; is the relative location for the cloned submodule to exist in the superproject. If &amp;lt;path&amp;gt; is not given, the canonical part of the source repository is used (&quot;repo&quot; for &quot;/path/to/repo.git&quot; and &quot;foo&quot; for &quot;host.xz:foo/.git&quot;). If &amp;lt;path&amp;gt; exists and is already a valid Git repository, then it is staged for commit without cloning. The &amp;lt;path&amp;gt; is also used as the submodule&amp;rsquo;s logical name in its configuration entries unless &lt;code&gt;--name&lt;/code&gt; is used to specify a logical name.</source>
          <target state="translated">可选参数&amp;lt;path&amp;gt;是在超级项目中存在的克隆子模块的相对位置。如果未给出&amp;lt;path&amp;gt;，则使用源存储库的规范部分（&amp;ldquo; repo&amp;rdquo;表示&amp;ldquo; /path/to/repo.git&amp;rdquo;，&amp;ldquo;foo&amp;rdquo;表示&amp;ldquo; host.xz：foo / .git&amp;rdquo;）。如果&amp;lt;path&amp;gt;存在并且已经是有效的Git存储库，则将其暂存以进行提交而无需克隆。 &amp;lt;path&amp;gt;在其配置条目中也用作子模块的逻辑名，除非 &lt;code&gt;--name&lt;/code&gt; 用于指定逻辑名。</target>
        </trans-unit>
        <trans-unit id="476c5c2c4870d6be72c4d31b42e1450136c51807" translate="yes" xml:space="preserve">
          <source>The optional configuration variable &lt;code&gt;core.excludesFile&lt;/code&gt; indicates a path to a file containing patterns of file names to exclude, similar to &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;. Patterns in the exclude file are used in addition to those in &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;.</source>
          <target state="translated">可选配置变量 &lt;code&gt;core.excludesFile&lt;/code&gt; 指示文件的路径，该路径包含要排除的文件名模式，类似于 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 。除了 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 模式以外，还使用排除文件中的模式。</target>
        </trans-unit>
        <trans-unit id="ad80c43bd988ae6e6061dfab8a056d2afaee7691" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;--contains&lt;/code&gt;, &lt;code&gt;--no-contains&lt;/code&gt;, &lt;code&gt;--merged&lt;/code&gt; and &lt;code&gt;--no-merged&lt;/code&gt; serve four related but different purposes:</source>
          <target state="translated">选项 &lt;code&gt;--contains&lt;/code&gt; ， &lt;code&gt;--no-contains&lt;/code&gt; ， &lt;code&gt;--merged&lt;/code&gt; 和 &lt;code&gt;--no-merged&lt;/code&gt; 成为四大关，但不同的目的：</target>
        </trans-unit>
        <trans-unit id="081a3bdc8213b4774c97cebf32978af69c3476cb" translate="yes" xml:space="preserve">
          <source>The order of stages 1, 2 and 3 (hence the order of three &amp;lt;tree-ish&amp;gt; command-line arguments) are significant when you start a 3-way merge with an index file that is already populated. Here is an outline of how the algorithm works:</source>
          <target state="translated">当您开始使用已填充的索引文件进行三向合并时，阶段1、2和3的顺序（因此三个&amp;lt;tree-ish&amp;gt;命令行参数的顺序）很重要。这是算法工作原理的概述：</target>
        </trans-unit>
        <trans-unit id="3fb57cf5101f783ba73fc6eba17ed42ef2940627" translate="yes" xml:space="preserve">
          <source>The order of the flags used to matter, but not anymore.</source>
          <target state="translated">过去旗帜的顺序很重要,但现在不一样了。</target>
        </trans-unit>
        <trans-unit id="32a54a6aa8ff67e3d76c47c6fabd2affc1e5cbb5" translate="yes" xml:space="preserve">
          <source>The origin of lines is automatically followed across whole-file renames (currently there is no option to turn the rename-following off). To follow lines moved from one file to another, or to follow lines that were copied and pasted from another file, etc., see the &lt;code&gt;-C&lt;/code&gt; and &lt;code&gt;-M&lt;/code&gt; options.</source>
          <target state="translated">整个文件重命名会自动跟随行的起点（当前没有选项可以关闭重命名跟随）。要跟随从一个文件移动到另一个文件的行，或者跟随从另一个文件复制和粘贴的行，等等，请参见 &lt;code&gt;-C&lt;/code&gt; 和 &lt;code&gt;-M&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="b66619a4ae8f145d6aac4431781b08d6ac86597a" translate="yes" xml:space="preserve">
          <source>The origin revision can be changed with the &quot;--origin&quot; option.</source>
          <target state="translated">可以用&quot;--origin &quot;选项来改变原始版本。</target>
        </trans-unit>
        <trans-unit id="617fe8d1d55cfe9ccc09f76fcfa190410b239da3" translate="yes" xml:space="preserve">
          <source>The original format used by Greg Kroah-Hartman&amp;rsquo;s &lt;code&gt;send_lots_of_email.pl&lt;/code&gt; script</source>
          <target state="translated">Greg Kroah-Hartman的 &lt;code&gt;send_lots_of_email.pl&lt;/code&gt; 脚本使用的原始格式</target>
        </trans-unit>
        <trans-unit id="a7a5cdcdcd4d6fcaaf02e53acebd8443c9b015da" translate="yes" xml:space="preserve">
          <source>The original job of &lt;code&gt;git rev-parse&lt;/code&gt; is now taken by the function &lt;code&gt;setup_revisions()&lt;/code&gt;, which parses the revisions and the common command-line options for the revision walker. This information is stored in the struct &lt;code&gt;rev_info&lt;/code&gt; for later consumption. You can do your own command-line option parsing after calling &lt;code&gt;setup_revisions()&lt;/code&gt;. After that, you have to call &lt;code&gt;prepare_revision_walk()&lt;/code&gt; for initialization, and then you can get the commits one by one with the function &lt;code&gt;get_revision()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git rev-parse&lt;/code&gt; 的原始工作现在由 &lt;code&gt;setup_revisions()&lt;/code&gt; 函数承担，该函数解析修订和修订行者的常用命令行选项。此信息存储在struct &lt;code&gt;rev_info&lt;/code&gt; 中,以供以后使用。您可以在调用 &lt;code&gt;setup_revisions()&lt;/code&gt; 之后执行自己的命令行选项解析。之后，您必须调用 &lt;code&gt;prepare_revision_walk()&lt;/code&gt; 进行初始化，然后可以使用 &lt;code&gt;get_revision()&lt;/code&gt; 函数一个接一个地提交提交。</target>
        </trans-unit>
        <trans-unit id="4c9da327e28b59015cec84abd98a33aec635328d" translate="yes" xml:space="preserve">
          <source>The original tags are not deleted, but can be overwritten; use &quot;--tag-name-filter cat&quot; to simply update the tags. In this case, be very careful and make sure you have the old tags backed up in case the conversion has run afoul.</source>
          <target state="translated">原来的标签不会被删除,但可以被覆盖;使用&quot;--tag-name-filter cat &quot;来简单地更新标签。在这种情况下,要非常小心,并确保你有旧的标签备份,以防转换过程中出现问题。</target>
        </trans-unit>
        <trans-unit id="6c2cf73d4477ea65ac2368f08dedbcc07c9eafb4" translate="yes" xml:space="preserve">
          <source>The other nice thing with test suites, is that when you have one, you already know how to test for bad behavior. So you can use this knowledge to create a new test case for &quot;git bisect&quot; when it appears that there is a regression. So it will be easier to bisect the bug and fix it. And then you can add the test case you just created to your test suite.</source>
          <target state="translated">测试套件的另一个好处是,当你有一个测试套件时,你已经知道如何测试不良行为。因此,当出现回归时,你可以使用这些知识为 &quot;git bisect &quot;创建一个新的测试用例。这样就可以更容易地将bug一分为二,并修复它。然后你就可以把刚才创建的测试用例添加到你的测试套件中。</target>
        </trans-unit>
        <trans-unit id="94bda500b4b5c47f0218909469e6ab7f1eee52b6" translate="yes" xml:space="preserve">
          <source>The other way to drive the bisection process is to tell &quot;git bisect&quot; to launch a script or command at each bisection step to know if the current commit is &quot;good&quot; or &quot;bad&quot;. To do that, we use the &quot;git bisect run&quot; command. For example:</source>
          <target state="translated">另一种方法是让 &quot;git bisect &quot;在每一个分离步骤中启动一个脚本或命令,以了解当前的提交是 &quot;好 &quot;还是 &quot;坏&quot;。为此,我们使用 &quot;git bisect run &quot;命令。例如:&quot;git bisect run &quot;命令</target>
        </trans-unit>
        <trans-unit id="013b9f528101f55f667633859403afae697697c4" translate="yes" xml:space="preserve">
          <source>The output format is modified to be machine-parsable (see below). If &lt;code&gt;--stdin&lt;/code&gt; is also given, input paths are separated with a NUL character instead of a linefeed character.</source>
          <target state="translated">将输出格式修改为机器可解析的（请参见下文）。如果还给出了 &lt;code&gt;--stdin&lt;/code&gt; ，则输入路径用NUL字符而不是换行符分隔。</target>
        </trans-unit>
        <trans-unit id="4ebdc78d172a0b82e38a898aa2ae716344def4d5" translate="yes" xml:space="preserve">
          <source>The output format is modified to be machine-parsable. If &lt;code&gt;--stdin&lt;/code&gt; is also given, input paths are separated with a NUL character instead of a linefeed character.</source>
          <target state="translated">将输出格式修改为机器可解析的。如果还给出了 &lt;code&gt;--stdin&lt;/code&gt; ，则输入路径用NUL字符而不是换行符分隔。</target>
        </trans-unit>
        <trans-unit id="885a3d9b027501a3f7ddd2554d827f984cacfcf5" translate="yes" xml:space="preserve">
          <source>The output format is similar to the Porcelain format, but it does not contain the actual lines from the file that is being annotated.</source>
          <target state="translated">输出格式与Porcelain格式类似,但它不包含被注释的文件的实际行数。</target>
        </trans-unit>
        <trans-unit id="16ca2e6d144e9c4d47f91cfe57ded6c4b6f874af" translate="yes" xml:space="preserve">
          <source>The output from this command is designed to be used as a commit template comment. The default, long format, is designed to be human readable, verbose and descriptive. Its contents and format are subject to change at any time.</source>
          <target state="translated">该命令的输出是用来作为提交模板的注释。默认的长格式是为了让人能够读懂,并具有详细的描述性。其内容和格式可能会随时改变。</target>
        </trans-unit>
        <trans-unit id="467b04ab4f0f42e5eb4db50995625d7a06a04bbc" translate="yes" xml:space="preserve">
          <source>The output is in the format: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;reference name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">输出的格式为： &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;reference name&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="297e105083265b9b5df9c784faa30006468bc5fd" translate="yes" xml:space="preserve">
          <source>The output is of the form: &amp;lt;path&amp;gt; COLON SP &amp;lt;attribute&amp;gt; COLON SP &amp;lt;info&amp;gt; LF</source>
          <target state="translated">输出的形式为：&amp;lt;path&amp;gt; COLON SP &amp;lt;attribute&amp;gt; COLON SP &amp;lt;info&amp;gt; LF</target>
        </trans-unit>
        <trans-unit id="00d47eecfb8e7c432b9a2a4461da0aa0b0a14445" translate="yes" xml:space="preserve">
          <source>The output is the new tag&amp;rsquo;s &amp;lt;object&amp;gt; identifier.</source>
          <target state="translated">输出是新标签的&amp;lt;object&amp;gt;标识符。</target>
        </trans-unit>
        <trans-unit id="c209f5f99a30592095be06f60778bfc6143218e8" translate="yes" xml:space="preserve">
          <source>The output of &quot;git fetch&quot; depends on the transport method used; this section describes the output when fetching over the Git protocol (either locally or via ssh) and Smart HTTP protocol.</source>
          <target state="translated">&quot;git fetch &quot;的输出取决于所使用的传输方式,本节将介绍通过Git协议(本地或通过ssh)和智能HTTP协议进行获取时的输出。</target>
        </trans-unit>
        <trans-unit id="249df455a76d6d8a4ee813f24ba8c68836888f67" translate="yes" xml:space="preserve">
          <source>The output of &quot;git push&quot; depends on the transport method used; this section describes the output when pushing over the Git protocol (either locally or via ssh).</source>
          <target state="translated">git push &quot;的输出取决于所使用的传输方式,本节将介绍通过 Git 协议(本地或通过 ssh)推送时的输出。</target>
        </trans-unit>
        <trans-unit id="2012a50a7ce95c41c81b087cc42352c50e07741b" translate="yes" xml:space="preserve">
          <source>The output of ls-refs is as follows:</source>
          <target state="translated">ls-refs的输出如下。</target>
        </trans-unit>
        <trans-unit id="c9897264787fe814346af61567793268dae2ec95" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;range-diff&lt;/code&gt; command is subject to change. It is intended to be human-readable porcelain output, not something that can be used across versions of Git to get a textually stable &lt;code&gt;range-diff&lt;/code&gt; (as opposed to something like the &lt;code&gt;--stable&lt;/code&gt; option to &lt;a href=&quot;git-patch-id&quot;&gt;git-patch-id[1]&lt;/a&gt;). There&amp;rsquo;s also no equivalent of &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt; for &lt;code&gt;range-diff&lt;/code&gt;, the output is not intended to be machine-readable.</source>
          <target state="translated">&lt;code&gt;range-diff&lt;/code&gt; 命令的输出可能会发生变化。它打算用作人类可读的瓷器输出，而不是可以在Git的各个版本中使用的东西，以获得文本上稳定的 &lt;code&gt;range-diff&lt;/code&gt; （与&lt;a href=&quot;git-patch-id&quot;&gt;git-patch-id [1]&lt;/a&gt;的 &lt;code&gt;--stable&lt;/code&gt; 选项类似的东西相反） 。还有没有等价的&lt;a href=&quot;git-apply&quot;&gt;GIT-应用[1]&lt;/a&gt;用于 &lt;code&gt;range-diff&lt;/code&gt; ，输出不旨在是机器可读的。</target>
        </trans-unit>
        <trans-unit id="acccdb81223db3ebfe60a727e12d9a4ed87719fe" translate="yes" xml:space="preserve">
          <source>The output order is determined by the order of glob patterns in &amp;lt;orderfile&amp;gt;. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.</source>
          <target state="translated">输出顺序由&amp;lt;orderfile&amp;gt;中的glob模式的顺序确定。路径名与第一个模式匹配的所有文件都将首先输出，路径名与第二个模式（但不是第一个模式）相匹配的所有文件都将被输出，依此类推。路径名与任何模式都不匹配的所有文件最后输出，就好像文件末尾有一个隐式的全部匹配模式。如果多个路径名具有相同的等级（它们匹配相同的模式，但没有更早的模式），则它们相对于彼此的输出顺序是正常顺序。</target>
        </trans-unit>
        <trans-unit id="70ec2e58d64c53608a589a3f892a41e430e23c0e" translate="yes" xml:space="preserve">
          <source>The overall time needed to compute this algorithm is the time needed to compute n+m commit diffs and then n*m diffs of patches, plus the time needed to compute the least-cost assignment between n and m diffs. Git uses an implementation of the Jonker-Volgenant algorithm to solve the assignment problem, which has cubic runtime complexity. The matching found in this case will look like this:</source>
          <target state="translated">计算这个算法所需的总体时间是计算n+m个commit diffs,然后计算n*m个patch diffs所需的时间,再加上计算n和m个 diffs之间的最小成本分配所需的时间。Git使用Jonker-Volgenant算法的实现来解决分配问题,该算法的运行复杂度为立方。在这种情况下找到的匹配会是这样的。</target>
        </trans-unit>
        <trans-unit id="f8c05a901b25f6434301621f82a267dcb0caae54" translate="yes" xml:space="preserve">
          <source>The p4 changes will be created as the user invoking &lt;code&gt;git p4 submit&lt;/code&gt;. The &lt;code&gt;--preserve-user&lt;/code&gt; option will cause ownership to be modified according to the author of the Git commit. This option requires admin privileges in p4, which can be granted using &lt;code&gt;p4 protect&lt;/code&gt;.</source>
          <target state="translated">用户调用 &lt;code&gt;git p4 submit&lt;/code&gt; 将创建p4更改。该 &lt;code&gt;--preserve-user&lt;/code&gt; 选项会使根据混帐的作者提交的所有权进行修改。此选项需要p4中的管理员特权，可以使用 &lt;code&gt;p4 protect&lt;/code&gt; 授予该特权。</target>
        </trans-unit>
        <trans-unit id="bc53387773cbb38b899a330a03a788e5288eab48" translate="yes" xml:space="preserve">
          <source>The p4 client specification is maintained with the &lt;code&gt;p4 client&lt;/code&gt; command and contains among other fields, a View that specifies how the depot is mapped into the client repository. The &lt;code&gt;clone&lt;/code&gt; and &lt;code&gt;sync&lt;/code&gt; commands can consult the client spec when given the &lt;code&gt;--use-client-spec&lt;/code&gt; option or when the useClientSpec variable is true. After &lt;code&gt;git p4 clone&lt;/code&gt;, the useClientSpec variable is automatically set in the repository configuration file. This allows future &lt;code&gt;git p4 submit&lt;/code&gt; commands to work properly; the submit command looks only at the variable and does not have a command-line option.</source>
          <target state="translated">p4客户端规范由 &lt;code&gt;p4 client&lt;/code&gt; 命令维护，除其他字段外，还包含一个视图，该视图指定软件仓库如何映射到客户端存储库中。该 &lt;code&gt;clone&lt;/code&gt; 并 &lt;code&gt;sync&lt;/code&gt; 给出的命令时，可以咨询客户规范 &lt;code&gt;--use-client-spec&lt;/code&gt; 选项，或当useClientSpec变量为真。之后 &lt;code&gt;git p4 clone&lt;/code&gt; ，将useClientSpec变量自动存储库配置文件中设置。这使得将来的 &lt;code&gt;git p4 submit&lt;/code&gt; 命令可以正常工作； Submit命令仅查看变量，并且没有命令行选项。</target>
        </trans-unit>
        <trans-unit id="9fec68b06723905b09b9270262e6a13c1b490876" translate="yes" xml:space="preserve">
          <source>The p4 depot path argument to &lt;code&gt;git p4 sync&lt;/code&gt; and &lt;code&gt;git p4 clone&lt;/code&gt; can be one or more space-separated p4 depot paths, with an optional p4 revision specifier on the end:</source>
          <target state="translated">&lt;code&gt;git p4 sync&lt;/code&gt; 和 &lt;code&gt;git p4 clone&lt;/code&gt; 的p4 depot path参数可以是一个或多个以空格分隔的p4 depot路径，最后带有一个可选的p4版本说明符：</target>
        </trans-unit>
        <trans-unit id="d877dea1de89fdb5a15efd47a5debfe5403b96f4" translate="yes" xml:space="preserve">
          <source>The pack-indexes (.idx files) remain in the pack directory so we can delete the MIDX file, set core.midx to false, or downgrade without any loss of information.</source>
          <target state="translated">pack-indexes(.idx文件)仍然保留在pack目录下,所以我们可以删除MIDX文件,将core.midx设置为false,或者降级而不丢失任何信息。</target>
        </trans-unit>
        <trans-unit id="933f30be1e83e4fe09dc8528b693f5b5a75f065d" translate="yes" xml:space="preserve">
          <source>The packed archive format (.pack) is designed to be self-contained so that it can be unpacked without any further information. Therefore, each object that a delta depends upon must be present within the pack.</source>
          <target state="translated">包装档案格式(.pack)的设计是自成一体的,因此它可以在没有任何进一步信息的情况下被解压。因此,delta所依赖的每个对象都必须存在于pack中。</target>
        </trans-unit>
        <trans-unit id="75cd7427877d4a48fded775aaaba114771e37304" translate="yes" xml:space="preserve">
          <source>The packfile(s) created by fast-import do not encourage good disk access patterns. This is caused by fast-import writing the data in the order it is received on standard input, while Git typically organizes data within packfiles to make the most recent (current tip) data appear before historical data. Git also clusters commits together, speeding up revision traversal through better cache locality.</source>
          <target state="translated">由 fast-import 创建的 packfile 并不支持良好的磁盘访问模式,这是因为 fast-import 按照标准输入的顺序写入数据,而 Git 通常会在 packfile 中组织数据,使最新的(当前的提示)数据出现在历史数据之前。这是由于fast-import按照标准输入的顺序写入数据,而Git通常会在packfiles中组织数据,使最新的(当前的提示)数据出现在历史数据之前。Git还将提交的数据聚拢在一起,通过更好的缓存位置性来加快修订版的遍历速度。</target>
        </trans-unit>
        <trans-unit id="73715b9a828b5f7ca9623cd366d376d487c8e126" translate="yes" xml:space="preserve">
          <source>The partial clone feature records special &quot;promisor&quot; packs that may point to objects that are not stored locally, but available on request to a server. The multi-pack-index does not currently track these promisor packs.</source>
          <target state="translated">部分克隆功能记录了特殊的 &quot;promposor &quot;包,这些包可能指向没有存储在本地的对象,但可以根据请求向服务器提供。多包索引目前不跟踪这些承诺者包。</target>
        </trans-unit>
        <trans-unit id="608e992a19f0287b5b2e4cbdc92416d882bd253c" translate="yes" xml:space="preserve">
          <source>The password to use when logging in to the server.</source>
          <target state="translated">登录服务器时使用的密码。</target>
        </trans-unit>
        <trans-unit id="f899bc9ba76fee3c960f01f1f955c5a4bf020e98" translate="yes" xml:space="preserve">
          <source>The patch extracted from e-mail.</source>
          <target state="translated">从电子邮件中提取的补丁。</target>
        </trans-unit>
        <trans-unit id="621265bbad5d0651c63283720f8a5ccddfdeeb61" translate="yes" xml:space="preserve">
          <source>The patch is expected to be inline, directly following the message. Any line that is of the form:</source>
          <target state="translated">补丁应该是内联的,直接跟在消息后面。任何形式的行:</target>
        </trans-unit>
        <trans-unit id="eedf9ed2547b7a76bcd6fb69785bf954af8d224f" translate="yes" xml:space="preserve">
          <source>The patch itself does not apply cleanly. That is &lt;code&gt;bad&lt;/code&gt; but does not have much to do with your MUA. You might want to rebase the patch with &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; before regenerating it in this case.</source>
          <target state="translated">补丁本身不能完全应用。这是 &lt;code&gt;bad&lt;/code&gt; ，但没有太多与你的MUA做。在这种情况下，您可能想在重新生成修补程序之前使用&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]将其&lt;/a&gt;重新着色。</target>
        </trans-unit>
        <trans-unit id="c9ecbf09d9172bac5285d567a6e1031058a01024" translate="yes" xml:space="preserve">
          <source>The patch produced by &lt;code&gt;git format-patch&lt;/code&gt; is in UNIX mailbox format, with a fixed &quot;magic&quot; time stamp to indicate that the file is output from format-patch rather than a real mailbox, like so:</source>
          <target state="translated">&lt;code&gt;git format-patch&lt;/code&gt; patch产生的补丁是UNIX邮箱格式，带有固定的&amp;ldquo;魔术&amp;rdquo;时间戳，指示该文件是从format-patch而不是真实邮箱输出的，如下所示：</target>
        </trans-unit>
        <trans-unit id="7072603eb0a607d061c366f3e4a9cba6cffbd377" translate="yes" xml:space="preserve">
          <source>The path can be either absolute or relative. A relative path is taken as relative to the directory where the hooks are run (see the &quot;DESCRIPTION&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">路径可以是绝对路径，也可以是相对路径。相对路径是相对于运行钩子的目录而言的（请参阅&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;的&amp;ldquo; DESCRIPTION&amp;rdquo;部分）。</target>
        </trans-unit>
        <trans-unit id="6ccace0f35f0f4e5cab0e8cffbdf924135579b2e" translate="yes" xml:space="preserve">
          <source>The path has the attribute with special value &quot;false&quot;; this is specified by listing the name of the attribute prefixed with a dash &lt;code&gt;-&lt;/code&gt; in the attribute list.</source>
          <target state="translated">路径具有带有特殊值&amp;ldquo; false&amp;rdquo;的属性；这是通过列出与一个破折号前缀属性的名称指定 &lt;code&gt;-&lt;/code&gt; 属性列表英寸</target>
        </trans-unit>
        <trans-unit id="96cc920a42ed7b296307f756480841c1366430ee" translate="yes" xml:space="preserve">
          <source>The path has the attribute with special value &quot;true&quot;; this is specified by listing only the name of the attribute in the attribute list.</source>
          <target state="translated">路径中有特殊值为 &quot;true &quot;的属性;这是由属性列表中只列出属性名称来指定的。</target>
        </trans-unit>
        <trans-unit id="f3d259c7dde8e69cba5e131da2dcac58054c5102" translate="yes" xml:space="preserve">
          <source>The path has the attribute with specified string value; this is specified by listing the name of the attribute followed by an equal sign &lt;code&gt;=&lt;/code&gt; and its value in the attribute list.</source>
          <target state="translated">路径具有具有指定字符串值的属性；通过列出属性名称，后跟等号 &lt;code&gt;=&lt;/code&gt; 及其在属性列表中的值来指定。</target>
        </trans-unit>
        <trans-unit id="9a89a340b481b20bfabef5b1bcb5482c1e173e57" translate="yes" xml:space="preserve">
          <source>The path to a list of object names (i.e. one unabbreviated SHA-1 per line) that are known to be broken in a non-fatal way and should be ignored. On versions of Git 2.20 and later comments (&lt;code&gt;#&lt;/code&gt;), empty lines, and any leading and trailing whitespace is ignored. Everything but a SHA-1 per line will error out on older versions.</source>
          <target state="translated">已知以非致命方式中断的对象名称列表（即，每行一个未缩写的SHA-1）的路径，应将其忽略。在Git 2.20和更高版本的注释（ &lt;code&gt;#&lt;/code&gt; ）版本中，空行以及任何前导和尾随空格都将被忽略。每行除SHA-1以外的所有内容在旧版本中都会出错。</target>
        </trans-unit>
        <trans-unit id="66bacdcfb6546645ce51a1173beecea036fe198b" translate="yes" xml:space="preserve">
          <source>The path to higher software quality is significantly improved software testing.</source>
          <target state="translated">提高软件质量的途径是大大改善软件测试。</target>
        </trans-unit>
        <trans-unit id="a62f8e77f19dbb91947274f4224d3b2000deceef" translate="yes" xml:space="preserve">
          <source>The path with which the credential will be used. E.g., for accessing a remote https repository, this will be the repository&amp;rsquo;s path on the server.</source>
          <target state="translated">凭据将使用的路径。例如，对于访问远程https资源库，这将是服务器上资源库的路径。</target>
        </trans-unit>
        <trans-unit id="75a6542b84624c1ec2a2753cb02bac2dc12deb38" translate="yes" xml:space="preserve">
          <source>The path within the &amp;lt;repository&amp;gt; that the action is performed on, for those actions that require it.</source>
          <target state="translated">&amp;lt;repository&amp;gt;中要对其执行操作的路径，用于需要执行该操作的路径。</target>
        </trans-unit>
        <trans-unit id="42c5355b2496aa717e00373f3c96e2614e271309" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing previously stored cookie lines, which should be used in the Git http session, if they match the server. The file format of the file to read cookies from should be plain HTTP headers or the Netscape/Mozilla cookie file format (see &lt;code&gt;curl(1)&lt;/code&gt;). NOTE that the file specified with http.cookieFile is used only as input unless http.saveCookies is set.</source>
          <target state="translated">包含先前存储的cookie行的文件的路径名，如果它们与服务器匹配，则应在Git http会话中使用。从中读取cookie的文件格式应为纯HTTP标头或Netscape / Mozilla cookie文件格式（请参见 &lt;code&gt;curl(1)&lt;/code&gt; ）。注意，除非设置了http.saveCookies，否则用http.cookieFile指定的文件仅用作输入。</target>
        </trans-unit>
        <trans-unit id="7529cc524422963391df3cb62b329f757e09e898" translate="yes" xml:space="preserve">
          <source>The pathname of a file that stores a client certificate to use to authenticate with an HTTPS proxy. Can be overridden by the &lt;code&gt;GIT_PROXY_SSL_CERT&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd72157b1a828f8662a88c728954dfe8fd532c2" translate="yes" xml:space="preserve">
          <source>The pathname of a file that stores a private key to use to authenticate with an HTTPS proxy. Can be overridden by the &lt;code&gt;GIT_PROXY_SSL_KEY&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb891f79fbec881d22446bf8cf74ef0a3e451e0" translate="yes" xml:space="preserve">
          <source>The paths mentioned in the output, unlike many other Git commands, are made relative to the current directory if you are working in a subdirectory (this is on purpose, to help cutting and pasting). See the status.relativePaths config option below.</source>
          <target state="translated">与其他许多Git命令不同的是,如果你是在子目录下工作,输出中提到的路径是相对于当前目录的(这是故意的,有助于剪切和粘贴)。参见下面的 status.relativePaths 配置选项。</target>
        </trans-unit>
        <trans-unit id="ae851010ea42ad696931dec57e7a58d6d0655b81" translate="yes" xml:space="preserve">
          <source>The pathspecs are used to limit the world diff operates in. They remove the filepairs outside the specified sets of pathnames. E.g. If the input set of filepairs included:</source>
          <target state="translated">pathspecs用于限制diff操作的范围。它们会删除指定路径名集之外的文件对。例如,如果输入的文件对集包括。</target>
        </trans-unit>
        <trans-unit id="a35fe6e03b5cf8e686f61a60362e87d3cf937722" translate="yes" xml:space="preserve">
          <source>The pattern &quot;foo/*&quot;, matches &quot;foo/test.json&quot; (a regular file), &quot;foo/bar&quot; (a directory), but it does not match &quot;foo/bar/hello.c&quot; (a regular file), as the asterisk in the pattern does not match &quot;bar/hello.c&quot; which has a slash in it.</source>
          <target state="translated">模式 &quot;foo/*&quot;,匹配 &quot;foo/test.json&quot;(常规文件)、&quot;foo/bar&quot;(目录),但不匹配 &quot;foo/bar/hello.c&quot;(常规文件),因为模式中的星号与 &quot;bar/hello.c &quot;不匹配,后者有斜线。</target>
        </trans-unit>
        <trans-unit id="472a6ff8d8e6e0153adf76e5ad83f89df7215b9f" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;doc/frotz&lt;/code&gt; and &lt;code&gt;/doc/frotz&lt;/code&gt; have the same effect in any &lt;code&gt;.gitignore&lt;/code&gt; file. In other words, a leading slash is not relevant if there is already a middle slash in the pattern.</source>
          <target state="translated">模式 &lt;code&gt;doc/frotz&lt;/code&gt; 和 &lt;code&gt;/doc/frotz&lt;/code&gt; 在任何 &lt;code&gt;.gitignore&lt;/code&gt; 文件中具有相同的效果。换句话说，如果模式中已经存在中间斜线，则前导斜线不相关。</target>
        </trans-unit>
        <trans-unit id="7f3e3da749b8fed6cc11585c7aa5dbe77eee53ad" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;foo/&lt;/code&gt; will match a directory &lt;code&gt;foo&lt;/code&gt; and paths underneath it, but will not match a regular file or a symbolic link &lt;code&gt;foo&lt;/code&gt; (this is consistent with the way how pathspec works in general in Git)</source>
          <target state="translated">模式 &lt;code&gt;foo/&lt;/code&gt; 将匹配目录 &lt;code&gt;foo&lt;/code&gt; 及其下的路径，但不匹配常规文件或符号链接 &lt;code&gt;foo&lt;/code&gt; （这与pathspec在Git中的一般工作方式一致）</target>
        </trans-unit>
        <trans-unit id="32166ee916b00891724c1bd52223b5e1e2d10da0" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;hello.*&lt;/code&gt; matches any file or folder whose name begins with &lt;code&gt;hello&lt;/code&gt;. If one wants to restrict this only to the directory and not in its subdirectories, one can prepend the pattern with a slash, i.e. &lt;code&gt;/hello.*&lt;/code&gt;; the pattern now matches &lt;code&gt;hello.txt&lt;/code&gt;, &lt;code&gt;hello.c&lt;/code&gt; but not &lt;code&gt;a/hello.java&lt;/code&gt;.</source>
          <target state="translated">模式 &lt;code&gt;hello.*&lt;/code&gt; 匹配名称以 &lt;code&gt;hello&lt;/code&gt; 开头的任何文件或文件夹。如果只想将此限制于目录而不是其子目录，则可以在模式前面加上斜杠，即 &lt;code&gt;/hello.*&lt;/code&gt; ；该模式现在匹配 &lt;code&gt;hello.txt&lt;/code&gt; ， &lt;code&gt;hello.c&lt;/code&gt; ,但不匹配 &lt;code&gt;a/hello.java&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b35cb663783a3682a66157f3dc9fd508efdfceba" translate="yes" xml:space="preserve">
          <source>The pattern can contain standard globbing wildcards and two additional ones, &lt;code&gt;**/&lt;/code&gt; and &lt;code&gt;/**&lt;/code&gt;, that can match multiple path components. Please refer to &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for details. For convenience:</source>
          <target state="translated">该模式可以包含标准的通配符和两个附加的通配符 &lt;code&gt;**/&lt;/code&gt; 和 &lt;code&gt;/**&lt;/code&gt; ，它们可以匹配多个路径分量。有关详细信息，请参考&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;。为了方便：</target>
        </trans-unit>
        <trans-unit id="ae88d32c3f9079756948f2fdc8ae4c4c2e834b93" translate="yes" xml:space="preserve">
          <source>The patterns given should not begin with &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, or &lt;code&gt;refs/remotes&lt;/code&gt; when applied to &lt;code&gt;--branches&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt;, or &lt;code&gt;--remotes&lt;/code&gt;, respectively, and they must begin with &lt;code&gt;refs/&lt;/code&gt; when applied to &lt;code&gt;--glob&lt;/code&gt; or &lt;code&gt;--all&lt;/code&gt;. If a trailing &lt;code&gt;/*&lt;/code&gt; is intended, it must be given explicitly.</source>
          <target state="translated">给予不应该开始图案 &lt;code&gt;refs/heads&lt;/code&gt; ， &lt;code&gt;refs/tags&lt;/code&gt; ，或 &lt;code&gt;refs/remotes&lt;/code&gt; 当应用于 &lt;code&gt;--branches&lt;/code&gt; ， &lt;code&gt;--tags&lt;/code&gt; ，或 &lt;code&gt;--remotes&lt;/code&gt; ，分别与他们必须以 &lt;code&gt;refs/&lt;/code&gt; 当应用于 &lt;code&gt;--glob&lt;/code&gt; 或 &lt;code&gt;--all&lt;/code&gt; 。如果要使用结尾的 &lt;code&gt;/*&lt;/code&gt; ，则必须明确给出。</target>
        </trans-unit>
        <trans-unit id="86b0de7f6b1176e8c07c5aaa523447c3abd4915b" translate="yes" xml:space="preserve">
          <source>The performance format target (PERF) is a column-based format to replace GIT_TRACE_PERFORMANCE and is suitable for development and testing, possibly to complement tools like gprof. This format is enabled with the &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; environment variable or the &lt;code&gt;trace2.perfTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">性能格式目标（PERF）是一种基于列的格式，用于替代GIT_TRACE_PERFORMANCE，适用于开发和测试，可能会补充gprof等工具。使用 &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; 环境变量或 &lt;code&gt;trace2.perfTarget&lt;/code&gt; 系统或全局配置设置启用此格式。</target>
        </trans-unit>
        <trans-unit id="506071bbd9d0908b14e8f015ca1b0ff23e4ec21e" translate="yes" xml:space="preserve">
          <source>The performance of git-filter-branch is glacially slow; its design makes it impossible for a backward-compatible implementation to ever be fast:</source>
          <target state="translated">git-filter-branch的性能非常慢,它的设计使得一个向后兼容的实现不可能快。</target>
        </trans-unit>
        <trans-unit id="d698b970e30734158c98cc5647b57a259a47bb36" translate="yes" xml:space="preserve">
          <source>The person who put a piece of code into Git.</source>
          <target state="translated">将一段代码放入Git的人。</target>
        </trans-unit>
        <trans-unit id="81b84527afb0ae2e697e75bbd7638af25fa12741" translate="yes" xml:space="preserve">
          <source>The pickaxe search is described in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; (the description of &lt;code&gt;-S&amp;lt;string&amp;gt;&lt;/code&gt; option, which refers to pickaxe entry in &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt; for more details).</source>
          <target state="translated">镐搜索在&lt;a href=&quot;git-log&quot;&gt;git-log [1]中进行&lt;/a&gt;了描述（ &lt;code&gt;-S&amp;lt;string&amp;gt;&lt;/code&gt; 选项的描述，有关更多细节，请&lt;a href=&quot;gitdiffcore&quot;&gt;参见gitdiffcore [7]中的&lt;/a&gt;镐输入）。</target>
        </trans-unit>
        <trans-unit id="525e6a0e6ee3d9fa31ab39c46532aa0c693111e1" translate="yes" xml:space="preserve">
          <source>The placeholders are:</source>
          <target state="translated">占位机是。</target>
        </trans-unit>
        <trans-unit id="1651136b42ed906ec527c0b5bb6ead2e015774c3" translate="yes" xml:space="preserve">
          <source>The point of this helper is to reduce the number of times you must type your username or password. For example:</source>
          <target state="translated">这个助手的目的是减少你必须输入用户名或密码的次数。例如</target>
        </trans-unit>
        <trans-unit id="c89cea9d29e269d3d21a2bb103d39e43b1e539d2" translate="yes" xml:space="preserve">
          <source>The porcelain format</source>
          <target state="translated">瓷器格式</target>
        </trans-unit>
        <trans-unit id="26e08a1995b67cc0010521ba6bed170106483645" translate="yes" xml:space="preserve">
          <source>The porcelain format generally suppresses commit information that has already been seen. For example, two lines that are blamed to the same commit will both be shown, but the details for that commit will be shown only once. This is more efficient, but may require more state be kept by the reader. The &lt;code&gt;--line-porcelain&lt;/code&gt; option can be used to output full commit information for each line, allowing simpler (but less efficient) usage like:</source>
          <target state="translated">瓷器格式通常会抑制已经看到的提交信息。例如，将显示归咎于同一提交的两行，但是该提交的详细信息将仅显示一次。这是更有效的方法，但可能要求阅读器保留更多状态。所述 &lt;code&gt;--line-porcelain&lt;/code&gt; 选项可用于以输出完整的提交信息的每一行，从而允许更简单的像（但效率较低）的用法：</target>
        </trans-unit>
        <trans-unit id="20c54b7279b5d1b2be6928d44083be1fd00dfbb8" translate="yes" xml:space="preserve">
          <source>The porcelain format has a line per attribute. Attributes are listed with a label and value separated by a single space. Boolean attributes (like &lt;code&gt;bare&lt;/code&gt; and &lt;code&gt;detached&lt;/code&gt;) are listed as a label only, and are only present if and only if the value is true. The first attribute of a worktree is always &lt;code&gt;worktree&lt;/code&gt;, an empty line indicates the end of the record. For example:</source>
          <target state="translated">瓷器格式每个属性都有一行。属性用标签和值列出，并用单个空格分隔。布尔属性（如 &lt;code&gt;bare&lt;/code&gt; 和 &lt;code&gt;detached&lt;/code&gt; ）仅作为标签列出，并且仅当且仅当该值为true时才存在。工作树的第一个属性始终是 &lt;code&gt;worktree&lt;/code&gt; ，空行表示记录的结尾。例如：</target>
        </trans-unit>
        <trans-unit id="d78141a7bccc3a1873780a422f8d41a19ce92e1b" translate="yes" xml:space="preserve">
          <source>The porcelain format has a line per attribute. Attributes are listed with a label and value separated by a single space. Boolean attributes (like &lt;code&gt;bare&lt;/code&gt; and &lt;code&gt;detached&lt;/code&gt;) are listed as a label only, and are present only if the value is true. The first attribute of a working tree is always &lt;code&gt;worktree&lt;/code&gt;, an empty line indicates the end of the record. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a362940b066b853917862099c8e9ab263cba72b1" translate="yes" xml:space="preserve">
          <source>The port number to bind the gitweb httpd to. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">绑定gitweb httpd的端口号。参见&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cecf31c324042fa16f4839249194885b3982bae" translate="yes" xml:space="preserve">
          <source>The port number to bind the httpd to. (Default: 1234)</source>
          <target state="translated">绑定 httpd 的端口号。(默认值:1234)</target>
        </trans-unit>
        <trans-unit id="735bfd35b5b101e4c116696c3cd1ebf6bc58faa9" translate="yes" xml:space="preserve">
          <source>The possible options are:</source>
          <target state="translated">可能的选择是:</target>
        </trans-unit>
        <trans-unit id="8bc0e360ec6eefb74bc5a1aed65f13e846b6d915" translate="yes" xml:space="preserve">
          <source>The preferred strategy for rolling out a version bump (whether whole repository or for a single file) is to teach git to read the new format, and allow writing the new format with a config switch or command line option (for experimentation or for those who do not care about backwards compatibility with older gits). Then after a long period to allow the reading capability to become common, we may switch to writing the new format by default.</source>
          <target state="translated">推广版本升级(无论是整个版本库还是单个文件)的首选策略是教会git读取新的格式,并允许通过配置开关或命令行选项来写入新的格式(用于实验或那些不在乎与旧gits向后兼容的人)。然后经过很长一段时间,让读取能力变得普遍,我们可以默认切换到写入新格式。</target>
        </trans-unit>
        <trans-unit id="adf8f6f66c16d1ab5dcd5c39342b75931e439ba4" translate="yes" xml:space="preserve">
          <source>The prefix ability basically makes it trivial to use &lt;code&gt;git checkout-index&lt;/code&gt; as an &quot;export as tree&quot; function. Just read the desired tree into the index, and do:</source>
          <target state="translated">前缀功能基本上使将 &lt;code&gt;git checkout-index&lt;/code&gt; 用作&amp;ldquo;导出为树&amp;rdquo;功能变得微不足道。只需将所需的树读入索引，然后执行：</target>
        </trans-unit>
        <trans-unit id="0f1fc4f35ab6b79f4468bd7525c0542dc9193da5" translate="yes" xml:space="preserve">
          <source>The previously introduced &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; is just a wrapper for &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">先前介绍的&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;只是&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;的包装。</target>
        </trans-unit>
        <trans-unit id="675ae216ecd575fef2e1ffa9eadeda52bdab6e90" translate="yes" xml:space="preserve">
          <source>The primary problem with rewriting the history of a branch has to do with merging. Suppose somebody fetches your branch and merges it into their branch, with a result something like this:</source>
          <target state="translated">重写分支历史的主要问题是与合并有关。假设有人获取了你的分支并将其合并到他们的分支中,结果是这样的。</target>
        </trans-unit>
        <trans-unit id="ff3dc4a94f1f540e3dd725f6eef6c2d405d85a87" translate="yes" xml:space="preserve">
          <source>The primary tool we&amp;rsquo;ve been using to create commits is &lt;code&gt;git-commit
-a&lt;/code&gt;, which creates a commit including every change you&amp;rsquo;ve made to your working tree. But what if you want to commit changes only to certain files? Or only certain changes to certain files?</source>
          <target state="translated">我们用来创建提交的主要工具是 &lt;code&gt;git-commit -a&lt;/code&gt; ，它创建一个提交，其中包括您对工作树所做的所有更改。但是，如果您只想对某些文件提交更改怎么办？还是仅对某些文件进行某些更改？</target>
        </trans-unit>
        <trans-unit id="bc32172ebad82b3a8531284b76fc91d0e2655fc8" translate="yes" xml:space="preserve">
          <source>The protection it offers over &lt;code&gt;--force&lt;/code&gt; is ensuring that subsequent changes your work wasn&amp;rsquo;t based on aren&amp;rsquo;t clobbered, but this is trivially defeated if some background process is updating refs in the background. We don&amp;rsquo;t have anything except the remote tracking info to go by as a heuristic for refs you&amp;rsquo;re expected to have seen &amp;amp; are willing to clobber.</source>
          <target state="translated">它提供的 &lt;code&gt;--force&lt;/code&gt; 保护可以确保您的工作所基于的后续更改不会被破坏，但是如果某些后台进程在后台更新引用，这将是微不足道的。除了远程跟踪信息以外，我们没有其他任何东西，可以启发您希望看到的参考文献，并愿意为之烦恼。</target>
        </trans-unit>
        <trans-unit id="c8ef7004934ae749808b9e22322b2c11275f98e4" translate="yes" xml:space="preserve">
          <source>The protocol names currently used by git are:</source>
          <target state="translated">目前git使用的协议名称为:。</target>
        </trans-unit>
        <trans-unit id="19913c2c5a680884fd5ab271ea84dfe92e10bf53" translate="yes" xml:space="preserve">
          <source>The protocol over which the credential will be used (e.g., &lt;code&gt;https&lt;/code&gt;).</source>
          <target state="translated">将使用凭证的协议（例如 &lt;code&gt;https&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="27c53e4d1c63b3496c93b1976851fe0522937712" translate="yes" xml:space="preserve">
          <source>The provided options must not contain a NUL or LF character.</source>
          <target state="translated">提供的选项不能包含NUL或LF字符。</target>
        </trans-unit>
        <trans-unit id="5fb1f43ddd5fc4b8ac18d086f82e6f88c9ed5855" translate="yes" xml:space="preserve">
          <source>The purpose of gitignore files is to ensure that certain files not tracked by Git remain untracked.</source>
          <target state="translated">gitignore文件的目的是确保某些没有被Git跟踪的文件不被跟踪。</target>
        </trans-unit>
        <trans-unit id="a2b9675d20ab3c1e80e15b296d660914f6ea2131" translate="yes" xml:space="preserve">
          <source>The purpose of the hook is to edit the message file in place, and it is not suppressed by the &lt;code&gt;--no-verify&lt;/code&gt; option. A non-zero exit means a failure of the hook and aborts the commit. It should not be used as replacement for pre-commit hook.</source>
          <target state="translated">挂钩的目的是就地编辑消息文件，并且 &lt;code&gt;--no-verify&lt;/code&gt; 选项不会抑制该挂钩。非零退出意味着挂钩失败并中止提交。不应将其用作预提交挂钩的替代品。</target>
        </trans-unit>
        <trans-unit id="96e3995f595001b3f723f5fc30a3546a03e6b50b" translate="yes" xml:space="preserve">
          <source>The purpose of the hook is to edit the message file in place, and it is not supressed by the &lt;code&gt;--no-verify&lt;/code&gt; option. This hook is called even if &lt;code&gt;--prepare-p4-only&lt;/code&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383a661ab7ffdec395082f1f22f245f53263885b" translate="yes" xml:space="preserve">
          <source>The push URL of a remote repository. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">远程存储库的推送URL。参见&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8cd29a2b80ae7f4721c7a9c69324052af609357" translate="yes" xml:space="preserve">
          <source>The push done by the other person updated the branch that used to point at commit X to point at commit A. It is a fast-forward.</source>
          <target state="translated">对方所做的推送,将原来指向提交X的分支更新为指向提交A的分支,这是一个快进。</target>
        </trans-unit>
        <trans-unit id="79a20eedac198c71849aef6d1fe1606ea1ee319f" translate="yes" xml:space="preserve">
          <source>The quilt series file.</source>
          <target state="translated">被子系列文件。</target>
        </trans-unit>
        <trans-unit id="eb2f9ed5ec284eab8396a9b582f3da5582d364ca" translate="yes" xml:space="preserve">
          <source>The raw output format from &quot;git-diff-index&quot;, &quot;git-diff-tree&quot;, &quot;git-diff-files&quot; and &quot;git diff --raw&quot; are very similar.</source>
          <target state="translated">git-diff-index&quot;、&quot;git-diff-tree&quot;、&quot;git-diff-files &quot;和 &quot;git diff --raw &quot;的原始输出格式非常相似。</target>
        </trans-unit>
        <trans-unit id="a6ab1028c44c2d54846a9217b4a7ad959d178f38" translate="yes" xml:space="preserve">
          <source>The reachability bitmap is currently paired directly with a single packfile, using the pack-order as the object order to hopefully compress the bitmaps well using run-length encoding. This could be extended to pair a reachability bitmap with a multi-pack-index. If the multi-pack-index is extended to store a &quot;stable object order&quot; (a function Order(hash) = integer that is constant for a given hash, even as the multi-pack-index is updated) then a reachability bitmap could point to a multi-pack-index and be updated independently.</source>
          <target state="translated">目前,可到达性位图直接与单个packfile配对,使用pack-order作为对象顺序,希望能使用运行长度编码很好地压缩位图。这可以扩展到将可到达性位图与多包索引配对。如果 multi-pack-index 被扩展为存储一个 &quot;稳定的对象顺序&quot;(一个函数 Order(hash)=整数,对于一个给定的哈希来说,即使在 multi-pack-index 被更新时也是不变的),那么一个可到达性位图可以指向一个 multi-pack-index 并被独立更新。</target>
        </trans-unit>
        <trans-unit id="0aca04dff2f76e52dde4dcdd1542bfe4e1470100" translate="yes" xml:space="preserve">
          <source>The reason fast-import uses &lt;code&gt;:&lt;/code&gt; to denote a mark reference is this character is not legal in a Git branch name. The leading &lt;code&gt;:&lt;/code&gt; makes it easy to distinguish between the mark 42 (&lt;code&gt;:42&lt;/code&gt;) and the branch 42 (&lt;code&gt;42&lt;/code&gt; or &lt;code&gt;refs/heads/42&lt;/code&gt;), or an abbreviated SHA-1 which happened to consist only of base-10 digits.</source>
          <target state="translated">快速导入使用 &lt;code&gt;:&lt;/code&gt; 表示标记参考的原因是该字符在Git分支名称中不合法。前导 &lt;code&gt;:&lt;/code&gt; 可以轻松地区分标记42（ &lt;code&gt;:42&lt;/code&gt; ）和分支42（ &lt;code&gt;42&lt;/code&gt; 或 &lt;code&gt;refs/heads/42&lt;/code&gt; ），或正好仅由10位数字组成的SHA-1缩写。</target>
        </trans-unit>
        <trans-unit id="1aba410e8fcfe74102eea2fcf73898889acee3ed" translate="yes" xml:space="preserve">
          <source>The reason it doesn&amp;rsquo;t error out when provided without &lt;code&gt;--prune&lt;/code&gt; or its config versions is for flexibility of the configured versions, and to maintain a 1=1 mapping between what the command line flags do, and what the configuration versions do.</source>
          <target state="translated">当不提供 &lt;code&gt;--prune&lt;/code&gt; 或其配置版本时，它不会出错的原因是为了确保配置版本的灵活性，并在命令行标志和配置版本之间保持1 = 1的映射。</target>
        </trans-unit>
        <trans-unit id="b2defd752d90b2a93e28eb3efe0e516f3fc264fc" translate="yes" xml:space="preserve">
          <source>The rebase will stop where &lt;code&gt;pick&lt;/code&gt; has been replaced with &lt;code&gt;edit&lt;/code&gt; or when a step in the list fails to mechanically resolve conflicts and needs your help. When you are done editing and/or resolving conflicts you can continue with &lt;code&gt;git rebase --continue&lt;/code&gt;. If you decide that things are getting too hairy, you can always bail out with &lt;code&gt;git rebase
--abort&lt;/code&gt;. Even after the rebase is complete, you can still recover the original branch by using the &lt;a href=&quot;#reflogs&quot;&gt;reflog&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;pick&lt;/code&gt; 被替换为 &lt;code&gt;edit&lt;/code&gt; 或者列表中的某个步骤无法机械解决冲突并需要您的帮助，则rebase将停止。完成编辑和/或解决冲突后，可以继续使用 &lt;code&gt;git rebase --continue&lt;/code&gt; 。如果您认为事情变得太 &lt;code&gt;git rebase --abort&lt;/code&gt; ，可以随时使用git rebase --abort来纾困。即使完成了基准调整，您仍然可以使用&lt;a href=&quot;#reflogs&quot;&gt;reflog&lt;/a&gt;恢复原始分支。</target>
        </trans-unit>
        <trans-unit id="939cf091c711a461fc7775d9278b48a4457f30c1" translate="yes" xml:space="preserve">
          <source>The ref namespace is hierarchical. Different subhierarchies are used for different purposes (e.g. the &lt;code&gt;refs/heads/&lt;/code&gt; hierarchy is used to represent local branches).</source>
          <target state="translated">ref名称空间是分层的。不同的子层次结构用于不同的目的（例如， &lt;code&gt;refs/heads/&lt;/code&gt; 层次结构用于表示本地分支）。</target>
        </trans-unit>
        <trans-unit id="d11d2f57237e560f1ae2f7da112ae694568b2d78" translate="yes" xml:space="preserve">
          <source>The ref which the given symbolic ref refers to. If not a symbolic ref, nothing is printed. Respects the &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt; and &lt;code&gt;:rstrip&lt;/code&gt; options in the same way as &lt;code&gt;refname&lt;/code&gt; above.</source>
          <target state="translated">给定符号ref所引用的ref。如果不是符号引用，则不会打印任何内容。与上面的 &lt;code&gt;refname&lt;/code&gt; 一样，尊重 &lt;code&gt;:short&lt;/code&gt; ， &lt;code&gt;:lstrip&lt;/code&gt; 和 &lt;code&gt;:rstrip&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="09256802b46aa557905f47df9fc0a1148d341199" translate="yes" xml:space="preserve">
          <source>The reflogs are kept by default for 30 days, after which they may be pruned. See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; and &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; to learn how to control this pruning, and see the &quot;SPECIFYING REVISIONS&quot; section of &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details.</source>
          <target state="translated">默认情况下，reflog会保留30天，之后可能会被删除。请参阅&lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt;和&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;以了解如何控制此修剪，并请参阅&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]的&lt;/a&gt; &amp;ldquo; SPECIFYING REVISIONS&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="29e87ce112fa8f38582e71025c0e3c162626939f" translate="yes" xml:space="preserve">
          <source>The refname parameter is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 arguments are the object names for the refname before and after the update. Note that the hook is called before the refname is updated, so either sha1-old is 0{40} (meaning there is no such ref yet), or it should match what is recorded in refname.</source>
          <target state="translated">refname参数是相对于$GIT_DIR的,例如,对于主头来说,是 &quot;refs/heads/master&quot;。两个 sha1 参数是 refname 更新前和更新后的对象名。请注意,钩子是在 refname 更新之前调用的,所以 sha1-old 是 0{40}。(意思是还没有这样的ref),或者它应该与refname中记录的内容一致。</target>
        </trans-unit>
        <trans-unit id="21810fe3549bedbdcfb85519d93701f4c1ec8042" translate="yes" xml:space="preserve">
          <source>The refname value is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 values before each refname are the object names for the refname before and after the update. Refs that were created will have sha1-old equal to 0{40}, while refs that were deleted will have sha1-new equal to 0{40}, otherwise sha1-old and sha1-new should be valid objects in the repository.</source>
          <target state="translated">refname 的值是相对于 $GIT_DIR 的,例如,对于主头来说,就是 &quot;refs/heads/master&quot;。每个 refname 前面的两个 sha1 值是更新前和更新后 refname 的对象名。被创建的 refs 的 sha1-old 值等于 0{40},而被删除的 refs 的 sha1-new 值等于 0{40},否则 sha1-old 和 sha1-new 应该是版本库中的有效对象。</target>
        </trans-unit>
        <trans-unit id="f7cd6bb7198b77eda24e90f3bdabb1a4fb56aeb0" translate="yes" xml:space="preserve">
          <source>The refname value is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 values before each refname are the object names for the refname before and after the update. Refs to be created will have sha1-old equal to 0{40}, while refs to be deleted will have sha1-new equal to 0{40}, otherwise sha1-old and sha1-new should be valid objects in the repository.</source>
          <target state="translated">refname 的值是相对于 $GIT_DIR 的,例如,对于主头来说,就是 &quot;refs/heads/master&quot;。每个 refname 前面的两个 sha1 值是更新前和更新后 refname 的对象名。要创建的 refs 的 sha1-old 值等于 0{40},而要删除的 refs 的 sha1-new 值等于 0{40},否则 sha1-old 和 sha1-new 应该是版本库中的有效对象。</target>
        </trans-unit>
        <trans-unit id="efb922792d6081ee214f4a8e1d665108721507f6" translate="yes" xml:space="preserve">
          <source>The refs are using the given hash algorithm. This keyword is only used if the server and client both support the object-format extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce26e3499eea5a4c24942a8e072b3a9539557d0b" translate="yes" xml:space="preserve">
          <source>The regex can also be set via a diff driver or configuration option, see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; or &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.</source>
          <target state="translated">还可以通过diff驱动程序或配置选项来设置正则表达式，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;或&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。明确给出该参数将覆盖所有差异驱动程序或配置设置。差异驱动程序将覆盖配置设置。</target>
        </trans-unit>
        <trans-unit id="db9cbae31eee7dd0453a2f75d2431a49c7ce5a43" translate="yes" xml:space="preserve">
          <source>The regex must capture the source branch name in $1.</source>
          <target state="translated">regex必须捕获1美元中的源分支名称。</target>
        </trans-unit>
        <trans-unit id="2f22e3781909efae9d373f9fa46942441b8a264c" translate="yes" xml:space="preserve">
          <source>The regular expression that the diff driver should use to recognize the hunk header. A built-in pattern may also be used. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff驱动程序应用于识别块头的正则表达式。也可以使用内置模式。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4211f7342bdc098f581fc9d7939f84dc24cd9689" translate="yes" xml:space="preserve">
          <source>The regular expression that the diff driver should use to split words in a line. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff驱动程序应使用正则表达式在一行中拆分单词。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa527c60a8440b01958ab1ade21254172db5c938" translate="yes" xml:space="preserve">
          <source>The remainder of the commit or the tag message that follows the &quot;subject&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0619f2eb83a7faf485cba23bd4bbef8fb0cb4dd" translate="yes" xml:space="preserve">
          <source>The remainder of the line, after stripping the spaces, is used as the help associated to the option.</source>
          <target state="translated">去掉空格后,这一行的剩余部分被用作与选项相关的帮助。</target>
        </trans-unit>
        <trans-unit id="19c5350e9da63f63a8abbccc7168a03dfd13ebac" translate="yes" xml:space="preserve">
          <source>The remaining features cannot be overridden on a per project basis.</source>
          <target state="translated">其余的功能不能按项目进行覆盖。</target>
        </trans-unit>
        <trans-unit id="303228bfc99fc67a561e0782dc3e0ceb08c259bb" translate="yes" xml:space="preserve">
          <source>The remote branch name for a submodule, used by &lt;code&gt;git submodule
update --remote&lt;/code&gt;. Set this option to override the value found in the &lt;code&gt;.gitmodules&lt;/code&gt; file. See &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">子模块的远程分支名称，由 &lt;code&gt;git submodule update --remote&lt;/code&gt; 。设置此选项可覆盖 &lt;code&gt;.gitmodules&lt;/code&gt; 文件中的值。有关详细信息，请参见&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt;和&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fdf928f1cd746e7574e5e26895f63052b9e3300" translate="yes" xml:space="preserve">
          <source>The remote configuration is achieved using the &lt;code&gt;remote.origin.url&lt;/code&gt; and &lt;code&gt;remote.origin.fetch&lt;/code&gt; configuration variables. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">使用 &lt;code&gt;remote.origin.url&lt;/code&gt; 和 &lt;code&gt;remote.origin.fetch&lt;/code&gt; 配置变量可以实现远程配置。（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e7b65b070cfabceee72964f903404025034f8258" translate="yes" xml:space="preserve">
          <source>The remote end did not report the successful update of the ref, perhaps because of a temporary error on the remote side, a break in the network connection, or other transient error.</source>
          <target state="translated">远程端没有报出ref的成功更新,可能是远程端临时出错,网络连接中断,或者其他短暂的错误。</target>
        </trans-unit>
        <trans-unit id="53c927a78ca0c11dc61a2c100f0e02c446d49374" translate="yes" xml:space="preserve">
          <source>The remote end refused the update. Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; (for pushes to the checked out branch), &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; (for forced non-fast-forward updates), &lt;code&gt;receive.denyDeletes&lt;/code&gt; or &lt;code&gt;receive.denyDeleteCurrent&lt;/code&gt;. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">远端拒绝更新。通常是由远程侧的钩子引起的，或者是由于远程存储库具有以下有效的安全选项之一： &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; （用于推送到签出的分支）， &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; （用于强制的非快进更新） ）， &lt;code&gt;receive.denyDeletes&lt;/code&gt; 或 &lt;code&gt;receive.denyDeleteCurrent&lt;/code&gt; 。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9422d899b3eadda77c8387091e37d96facb6c2f" translate="yes" xml:space="preserve">
          <source>The remote heads to update from. This is relative to $GIT_DIR (e.g. &quot;HEAD&quot;, &quot;refs/heads/master&quot;). When unspecified, update from all heads the remote side has.</source>
          <target state="translated">要更新的远程头。这是相对于 $GIT_DIR 的 (例如 &quot;HEAD&quot;,&quot;refs/heads/master&quot;)。当未指定时,从远程的所有头更新。</target>
        </trans-unit>
        <trans-unit id="0419c5b470511fe246bdc207ab1f44978b5929c7" translate="yes" xml:space="preserve">
          <source>The remote hostname for a network credential.</source>
          <target state="translated">网络凭证的远程主机名。</target>
        </trans-unit>
        <trans-unit id="2acecc1c91d3ba6caf56ecf7245b62c949c434da" translate="yes" xml:space="preserve">
          <source>The remote hostname for a network credential. This includes the port number if one was specified (e.g., &quot;example.com:8088&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7632b9807699f7e6cd146f3dd66e0428b068933" translate="yes" xml:space="preserve">
          <source>The remote ref that matches &amp;lt;src&amp;gt; is fetched, and if &amp;lt;dst&amp;gt; is not an empty string, an attempt is made to update the local ref that matches it.</source>
          <target state="translated">获取与&amp;lt;src&amp;gt;匹配的远程引用，并且如果&amp;lt;dst&amp;gt;不是空字符串，则尝试更新与之匹配的本地ref。</target>
        </trans-unit>
        <trans-unit id="282ef7eedc5a5bdee9740e04ed8375ea205f3da3" translate="yes" xml:space="preserve">
          <source>The remote refs to update.</source>
          <target state="translated">要更新的远程参照物。</target>
        </trans-unit>
        <trans-unit id="1126548b6dd0a73d0e4b3cf8a47f765ced5296ec" translate="yes" xml:space="preserve">
          <source>The remote to push to by default. Overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for all branches, and is overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; for specific branches.</source>
          <target state="translated">默认情况下要推送到的遥控器。重写 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 对所有分支，并且通过重写 &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; 特定分支。</target>
        </trans-unit>
        <trans-unit id="69cc315a656a6408b19c28c1250214347094ab33" translate="yes" xml:space="preserve">
          <source>The replaced object and the replacement object must be of the same type. This restriction can be bypassed using &lt;code&gt;-f&lt;/code&gt;.</source>
          <target state="translated">替换的对象和替换的对象必须具有相同的类型。可以使用 &lt;code&gt;-f&lt;/code&gt; 绕过此限制。</target>
        </trans-unit>
        <trans-unit id="1ad56792b1c232c0733d7ad92a2a6edfcbfd7d1e" translate="yes" xml:space="preserve">
          <source>The report does not tell you anything about lines which have been deleted or replaced; you need to use a tool such as &lt;code&gt;git diff&lt;/code&gt; or the &quot;pickaxe&quot; interface briefly mentioned in the following paragraph.</source>
          <target state="translated">该报告不会告诉您有关已删除或替换的行的任何信息；您需要使用下一节中简要提到的 &lt;code&gt;git diff&lt;/code&gt; 之类的工具或&amp;ldquo; pickaxe&amp;rdquo;界面。</target>
        </trans-unit>
        <trans-unit id="b4fd8af335028abdc88c8957e63b788cd43e89cc" translate="yes" xml:space="preserve">
          <source>The report of the commands of this hook should have the same order as the input. The exit status of the &lt;code&gt;proc-receive&lt;/code&gt; hook only determines the success or failure of the group of commands sent to it, unless atomic push is in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c986c29f6ffa22f2a8c706bbb75b7aeb4461294" translate="yes" xml:space="preserve">
          <source>The repository URL to be pulled from.</source>
          <target state="translated">要拉取的版本库URL。</target>
        </trans-unit>
        <trans-unit id="944d2d5ccd37faa608b4a3dce165543a5adf2fbf" translate="yes" xml:space="preserve">
          <source>The repository the action will be performed on.</source>
          <target state="translated">要执行操作的存储库。</target>
        </trans-unit>
        <trans-unit id="0e7c4601cfd7634812fd5318d08d4f529fb59bef" translate="yes" xml:space="preserve">
          <source>The repository to get a tar archive from.</source>
          <target state="translated">从仓库中获取焦油文件的仓库。</target>
        </trans-unit>
        <trans-unit id="bc81f7623489d466e462d3597d8dc6ebd3c462a1" translate="yes" xml:space="preserve">
          <source>The repository to sync from.</source>
          <target state="translated">要同步的存储库。</target>
        </trans-unit>
        <trans-unit id="3d7b45c15d44961366710f29c0592cfbaf8293a2" translate="yes" xml:space="preserve">
          <source>The repository to sync into.</source>
          <target state="translated">要同步到的存储库。</target>
        </trans-unit>
        <trans-unit id="85a32286326310d42bba4488de0fbceb84f9845b" translate="yes" xml:space="preserve">
          <source>The repository to update.</source>
          <target state="translated">要更新的存储库。</target>
        </trans-unit>
        <trans-unit id="15ea4cb9c0b7ca59bf54604e4e274c258d2ab5d8" translate="yes" xml:space="preserve">
          <source>The response of &lt;code&gt;fetch&lt;/code&gt; is broken into a number of sections separated by delimiter packets (0001), with each section beginning with its section header.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 的响应分为多个由定界符数据包（0001）分隔的部分，每个部分均以其部分头开始。</target>
        </trans-unit>
        <trans-unit id="f5a3baabdc3717b14a2e7f02d6a5a2eab21baf8b" translate="yes" xml:space="preserve">
          <source>The response of &lt;code&gt;fetch&lt;/code&gt; is broken into a number of sections separated by delimiter packets (0001), with each section beginning with its section header. Most sections are sent only when the packfile is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1a001f6b3f7c16917c0e0241e976b8717f870a" translate="yes" xml:space="preserve">
          <source>The rest of the documentation discusses &lt;code&gt;fsck.*&lt;/code&gt; for brevity, but the same applies for the corresponding &lt;code&gt;receive.fsck.*&lt;/code&gt; and &lt;code&gt;fetch.&amp;lt;msg-id&amp;gt;.*&lt;/code&gt;. variables.</source>
          <target state="translated">为了简洁起见，文档的其余部分讨论了 &lt;code&gt;fsck.*&lt;/code&gt; ，但是对于相应的 &lt;code&gt;receive.fsck.*&lt;/code&gt; 和 &lt;code&gt;fetch.&amp;lt;msg-id&amp;gt;.*&lt;/code&gt; 。变量。</target>
        </trans-unit>
        <trans-unit id="ac10b74ced74e00c661f52e9250a42f47fd6add4" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;git merge-base --octopus A B C&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, because &lt;code&gt;2&lt;/code&gt; is the best common ancestor of all commits.</source>
          <target state="translated">结果 &lt;code&gt;git merge-base --octopus A B C&lt;/code&gt; 是 &lt;code&gt;2&lt;/code&gt; ，因为 &lt;code&gt;2&lt;/code&gt; 是所有提交的最好的共同祖先。</target>
        </trans-unit>
        <trans-unit id="1e8fa948e18ddfaa21178042cd566eaada7aae80" translate="yes" xml:space="preserve">
          <source>The result of comparison is passed from these commands to what is internally called &quot;diffcore&quot;, in a format similar to what is output when the -p option is not used. E.g.</source>
          <target state="translated">比较的结果由这些命令传递到内部的 &quot;diffcore&quot;,格式类似于不使用-p选项时的输出。例如</target>
        </trans-unit>
        <trans-unit id="d6478eddd3e6be6e1f0703d8450a597d1ea3dfe6" translate="yes" xml:space="preserve">
          <source>The result of such a bisection would be that we would find that H is the first bad commit, when in fact it&amp;rsquo;s B. So that would be wrong!</source>
          <target state="translated">这样一分为二的结果是，我们会发现H是第一个错误提交，而实际上是B。所以这是错误的！</target>
        </trans-unit>
        <trans-unit id="9ed4c9f58d5e6595458ce4cb4952fdfe7c07ce9b" translate="yes" xml:space="preserve">
          <source>The resulting command then has an &quot;operation&quot; argument appended to it (see below for details), and the result is executed by the shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baad8b31b0f95aa1296c5c88ad34816424f2926e" translate="yes" xml:space="preserve">
          <source>The resulting directory proj.git contains a &quot;bare&quot; git repository&amp;mdash;​it is just the contents of the &lt;code&gt;.git&lt;/code&gt; directory, without any files checked out around it.</source>
          <target state="translated">产生的目录proj.git包含一个``裸露''的git存储库-它只是 &lt;code&gt;.git&lt;/code&gt; 目录的内容，周围没有任何文件被检出。</target>
        </trans-unit>
        <trans-unit id="31dc4b206e7be8ca9a78c4871cc58f03a5340e5b" translate="yes" xml:space="preserve">
          <source>The revision data is appended to the file if it already exists, for use when doing incremental imports.</source>
          <target state="translated">如果文件中已经存在修订数据,则将其附加到文件中,以便在进行增量导入时使用。</target>
        </trans-unit>
        <trans-unit id="0ca811b30547ebe29846859e95a6c9147e8141b4" translate="yes" xml:space="preserve">
          <source>The rewrite rule guarantees that existing static files will be properly served, whereas any other URL will be passed to gitweb as PATH_INFO parameter.</source>
          <target state="translated">重写规则保证了现有的静态文件将被正确地服务,而其他任何URL将作为PATH_INFO参数传递给gitweb。</target>
        </trans-unit>
        <trans-unit id="7511d9248c0671ec876d283606ae9df0bea2f6b2" translate="yes" xml:space="preserve">
          <source>The ripple effect of a &quot;hard case&quot; recovery is especially bad: &lt;code&gt;everyone&lt;/code&gt; downstream from &lt;code&gt;topic&lt;/code&gt; will now have to perform a &quot;hard case&quot; recovery too!</source>
          <target state="translated">&amp;ldquo;硬案例&amp;rdquo;恢复的连锁反应尤其糟糕： &lt;code&gt;topic&lt;/code&gt; 下游的 &lt;code&gt;everyone&lt;/code&gt; 现在也都必须执行&amp;ldquo;硬案例&amp;rdquo;恢复！</target>
        </trans-unit>
        <trans-unit id="93d5c7537e241865d860131eb6d72edc95c9d772" translate="yes" xml:space="preserve">
          <source>The root of the CVS archive. May be local (a simple path) or remote; currently, only the :local:, :ext: and :pserver: access methods are supported. If not given, &lt;code&gt;git cvsimport&lt;/code&gt; will try to read it from &lt;code&gt;CVS/Root&lt;/code&gt;. If no such file exists, it checks for the &lt;code&gt;CVSROOT&lt;/code&gt; environment variable.</source>
          <target state="translated">CVS存档的根。可以是本地（简单路径）或远程；当前，仅支持：local：，：ext：和：pserver：访问方法。如果未给出， &lt;code&gt;git cvsimport&lt;/code&gt; 将尝试从 &lt;code&gt;CVS/Root&lt;/code&gt; 读取它。如果不存在这样的文件，它将检查 &lt;code&gt;CVSROOT&lt;/code&gt; 环境变量。</target>
        </trans-unit>
        <trans-unit id="df41fdf293aec02e3dee1ead27003284471a1181" translate="yes" xml:space="preserve">
          <source>The root of the tree can be represented by an empty string as &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">树的根可以用空字符串表示为 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="557dc21e01559e09224bc25bcbd6a672b4e3d883" translate="yes" xml:space="preserve">
          <source>The rule to determine which remote branch to merge after fetching is a bit involved, in order not to break backward compatibility.</source>
          <target state="translated">为了不破坏后向兼容性,取完后确定合并哪个远程分支的规则有点牵扯。</target>
        </trans-unit>
        <trans-unit id="bbff5506f0bff9eed6d1a29f80ce8f838449bb56" translate="yes" xml:space="preserve">
          <source>The rules by which the pattern matches paths are the same as in &lt;code&gt;.gitignore&lt;/code&gt; files (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), with a few exceptions:</source>
          <target state="translated">模式匹配路径的规则与 &lt;code&gt;.gitignore&lt;/code&gt; 文件中的规则相同（请参见&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;），但有一些例外：</target>
        </trans-unit>
        <trans-unit id="579e7c08387accae89723ba13e3ec53145837232" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;--merge&lt;/code&gt; option above, but changes the way the conflicting hunks are presented, overriding the &lt;code&gt;merge.conflictStyle&lt;/code&gt; configuration variable. Possible values are &quot;merge&quot; (default) and &quot;diff3&quot; (in addition to what is shown by &quot;merge&quot; style, shows the original contents).</source>
          <target state="translated">与上面的 &lt;code&gt;--merge&lt;/code&gt; 选项相同，但是更改了显示冲突的块的方式，覆盖了 &lt;code&gt;merge.conflictStyle&lt;/code&gt; 配置变量。可能的值为&amp;ldquo;合并&amp;rdquo;（默认）和&amp;ldquo; diff3&amp;rdquo;（除了&amp;ldquo;合并&amp;rdquo;样式显示的内容以外，还显示原始内容）。</target>
        </trans-unit>
        <trans-unit id="1a11cc7f94381fe2de07d484775d2914bf62d241" translate="yes" xml:space="preserve">
          <source>The same as the previous one:</source>
          <target state="translated">与之前的一样。</target>
        </trans-unit>
        <trans-unit id="ebdfbbadd1b4e3e4d3c390aed297730072348592" translate="yes" xml:space="preserve">
          <source>The same rewind and rebuild process may be followed for &lt;code&gt;pu&lt;/code&gt;. A public announcement is not necessary since &lt;code&gt;pu&lt;/code&gt; is a throw-away branch, as described above.</source>
          <target state="translated">&lt;code&gt;pu&lt;/code&gt; 可以遵循相同的倒带和重建过程。如上所述，由于 &lt;code&gt;pu&lt;/code&gt; 是一个一次性分支，因此无需进行公开公告。</target>
        </trans-unit>
        <trans-unit id="982acf1816c2fb0e10e67de1c939cdcea16cc699" translate="yes" xml:space="preserve">
          <source>The same rewind and rebuild process may be followed for &lt;code&gt;seen&lt;/code&gt;. A public announcement is not necessary since &lt;code&gt;seen&lt;/code&gt; is a throw-away branch, as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d931302d20c8d2d3f4d29cdb99720d08f56244" translate="yes" xml:space="preserve">
          <source>The same trailer as a v1 pack file:</source>
          <target state="translated">和v1包文件一样的预告片。</target>
        </trans-unit>
        <trans-unit id="ef6e4cd5de79a2002e4df69090fc16d7024fe532" translate="yes" xml:space="preserve">
          <source>The sample &lt;code&gt;prepare-commit-msg&lt;/code&gt; hook that comes with Git removes the help message found in the commented portion of the commit template.</source>
          <target state="translated">Git附带的样本 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 挂钩删除了在提交模板的注释部分中找到的帮助消息。</target>
        </trans-unit>
        <trans-unit id="0814a224cf6ffffca90b05b46ffd264f8d62f600" translate="yes" xml:space="preserve">
          <source>The sample hooks are all disabled by default. To enable one of the sample hooks rename it by removing its &lt;code&gt;.sample&lt;/code&gt; suffix.</source>
          <target state="translated">默认情况下，样本挂钩均处于禁用状态。要启用其中一个示例挂钩，请通过删除其 &lt;code&gt;.sample&lt;/code&gt; 后缀对其重命名。</target>
        </trans-unit>
        <trans-unit id="ee2f5fb52849fdcd69a62a399938c4c71ec4e36c" translate="yes" xml:space="preserve">
          <source>The sane thing. Just admit you screwed up, and use a different name. Others have already seen one tag-name, and if you keep the same name, you may be in the situation that two people both have &quot;version X&quot;, but they actually have &lt;code&gt;different&lt;/code&gt; &quot;X&quot;'s. So just call it &quot;X.1&quot; and be done with it.</source>
          <target state="translated">理智的事情。只要承认您搞砸了，并使用其他名称即可。其他人已经看到了一个标记名，如果您使用相同的名称，则可能是两个人都有&amp;ldquo; X版本&amp;rdquo;，但实际上却有 &lt;code&gt;different&lt;/code&gt; &amp;ldquo; X&amp;rdquo;。因此，只需将其称为&amp;ldquo; X.1&amp;rdquo;即可完成。</target>
        </trans-unit>
        <trans-unit id="16a78cd21b6c709f016f4a17d2a1069e970db97c" translate="yes" xml:space="preserve">
          <source>The script expects you to provide the key roots where it can start the import from an &lt;code&gt;initial import&lt;/code&gt; or &lt;code&gt;tag&lt;/code&gt; type of Arch commit. It will follow and import new branches within the provided roots.</source>
          <target state="translated">该脚本希望您提供密钥根，以便从 &lt;code&gt;initial import&lt;/code&gt; 或Arch提交的 &lt;code&gt;tag&lt;/code&gt; 类型开始导入。它将遵循并在提供的根目录中导入新分支。</target>
        </trans-unit>
        <trans-unit id="793ca81ee99913a2e3edc7ca33209f79549422e8" translate="yes" xml:space="preserve">
          <source>The scriptlet sets &lt;code&gt;GIT_DIR&lt;/code&gt; and &lt;code&gt;GIT_OBJECT_DIRECTORY&lt;/code&gt; shell variables, but does &lt;strong&gt;not&lt;/strong&gt; export them to the environment.</source>
          <target state="translated">脚本集设置了 &lt;code&gt;GIT_DIR&lt;/code&gt; 和 &lt;code&gt;GIT_OBJECT_DIRECTORY&lt;/code&gt; Shell变量，但是&lt;strong&gt;没有&lt;/strong&gt;将它们导出到环境中。</target>
        </trans-unit>
        <trans-unit id="8b53f7beee61a37b0174ea389f5f36080ff3c1b7" translate="yes" xml:space="preserve">
          <source>The second .gitignore prevents Git from ignoring &lt;code&gt;arch/foo/kernel/vmlinux.lds.S&lt;/code&gt;.</source>
          <target state="translated">第二个.gitignore防止Git忽略 &lt;code&gt;arch/foo/kernel/vmlinux.lds.S&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc737587a80c0c07a4fffd3646c479ff0f86cddd" translate="yes" xml:space="preserve">
          <source>The second example demonstrates that you can abbreviate the object name to only the first several hexadecimal digits in most places.</source>
          <target state="translated">第二个例子表明,你可以在大多数地方将对象名称缩写为只有前几位十六进制数字。</target>
        </trans-unit>
        <trans-unit id="2890a9def3fff903603dee47b68cd9b5af108707" translate="yes" xml:space="preserve">
          <source>The second format is what gets used when &lt;code&gt;--stage=all&lt;/code&gt;. The three stage temporary fields (stage1temp, stage2temp, stage3temp) list the name of the temporary file if there is a stage entry in the index or &lt;code&gt;.&lt;/code&gt; if there is no stage entry. Paths which only have a stage 0 entry will always be omitted from the output.</source>
          <target state="translated">第二种格式是 &lt;code&gt;--stage=all&lt;/code&gt; 时使用的格式。如果索引或中有一个阶段条目，则三个阶段的临时字段（stage1temp，stage2temp，stage3temp）将列出临时文件的名称 &lt;code&gt;.&lt;/code&gt; 如果没有阶段入口。仅具有阶段0条目的路径将始终从输出中省略。</target>
        </trans-unit>
        <trans-unit id="8a6f107e4f2dc8b17455f1349e940becb9fc3a6b" translate="yes" xml:space="preserve">
          <source>The second issue is one of auditing. When many contributors are working on the same repository, it is important which merge commits introduced a change into an important branch. The problematic merge &lt;code&gt;R&lt;/code&gt; above is not likely to be the merge commit that was used to merge into an important branch. Instead, the merge &lt;code&gt;N&lt;/code&gt; was used to merge &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; into the important branch. This commit may have information about why the change &lt;code&gt;X&lt;/code&gt; came to override the changes from &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in its commit message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b87f951d8d8be1a02da6e062a3489256945d73" translate="yes" xml:space="preserve">
          <source>The second parameter passed to the hook is the indicator for whether or not the index was updated and the skip-worktree bit could have changed. &quot;1&quot; meaning skip-worktree bits could have been updated and &quot;0&quot; meaning they were not.</source>
          <target state="translated">传递给钩子的第二个参数是索引是否被更新和skip-worktree位是否可能发生变化的指示器,&quot;1 &quot;表示skip-worktree位可能被更新,&quot;0 &quot;表示没有被更新。&quot;1 &quot;表示skip-worktree位可能已经更新,&quot;0 &quot;表示没有更新。</target>
        </trans-unit>
        <trans-unit id="b730007914036d9f0fb3ba6052d64853bae216ae" translate="yes" xml:space="preserve">
          <source>The second syntax (&quot;&lt;code&gt;git merge --abort&lt;/code&gt;&quot;) can only be run after the merge has resulted in conflicts. &lt;code&gt;git merge --abort&lt;/code&gt; will abort the merge process and try to reconstruct the pre-merge state. However, if there were uncommitted changes when the merge started (and especially if those changes were further modified after the merge was started), &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to reconstruct the original (pre-merge) changes. Therefore:</source>
          <target state="translated">第二种语法（&amp;ldquo; &lt;code&gt;git merge --abort&lt;/code&gt; &amp;rdquo;）只能在合并导致冲突后运行。 &lt;code&gt;git merge --abort&lt;/code&gt; 将中止合并过程，并尝试重建合并前的状态。但是，如果在合并开始时有未提交的更改（尤其是在合并开始后进一步修改了这些更改），则 &lt;code&gt;git merge --abort&lt;/code&gt; 在某些情况下将无法重建原始（合并前）更改。因此：</target>
        </trans-unit>
        <trans-unit id="1f7dcee78b5872602756cd0d868ad6253db301fe" translate="yes" xml:space="preserve">
          <source>The second transformation in the chain is diffcore-break, and is controlled by the -B option to the &lt;code&gt;git diff-*&lt;/code&gt; commands. This is used to detect a filepair that represents &quot;complete rewrite&quot; and break such filepair into two filepairs that represent delete and create. E.g. If the input contained this filepair:</source>
          <target state="translated">链中的第二个转换是diffcore-break，由 &lt;code&gt;git diff-*&lt;/code&gt; 命令的-B选项控制。这用于检测代表&amp;ldquo;完全重写&amp;rdquo;的文件对，并将该文件对分为代表删除和创建的两个文件对。例如，如果输入包含此文件对：</target>
        </trans-unit>
        <trans-unit id="5aa738048a0181b9705365955bd04c18156f9d33" translate="yes" xml:space="preserve">
          <source>The section &lt;code&gt;submodule.foo.*&lt;/code&gt; in the &lt;code&gt;.gitmodules&lt;/code&gt; file gives additional hints to Git&amp;rsquo;s porcelain layer. For example, the &lt;code&gt;submodule.foo.url&lt;/code&gt; setting specifies where to obtain the submodule.</source>
          <target state="translated">&lt;code&gt;.gitmodules&lt;/code&gt; 文件中的 &lt;code&gt;submodule.foo.*&lt;/code&gt; 部分为Git的瓷器层提供了其他提示。例如， &lt;code&gt;submodule.foo.url&lt;/code&gt; 设置指定从何处获取子模块。</target>
        </trans-unit>
        <trans-unit id="addff8a92e5ddb901ae8a38330bc2dcce4be9fbb" translate="yes" xml:space="preserve">
          <source>The section or key is invalid (ret=1),</source>
          <target state="translated">节或键无效(ret=1)。</target>
        </trans-unit>
        <trans-unit id="463ba2454fad2719570e32271a038c3acce699a7" translate="yes" xml:space="preserve">
          <source>The server MUST NOT send any &quot;unshallow&quot; lines for anything which the client has not indicated was shallow as a part of its request.</source>
          <target state="translated">服务器绝不能发送任何 &quot;不浅 &quot;的行,如果客户在请求中没有说明是浅的,则必须发送。</target>
        </trans-unit>
        <trans-unit id="d868af4cbdec034778f61defdf53e9a4307fd341" translate="yes" xml:space="preserve">
          <source>The server MUST NOT send any refs which were not requested using &lt;code&gt;want-ref&lt;/code&gt; lines.</source>
          <target state="translated">服务器不得发送任何没有使用 &lt;code&gt;want-ref&lt;/code&gt; 线请求的参考。</target>
        </trans-unit>
        <trans-unit id="446930d87bed0e82e29e329dd081708ba37057c2" translate="yes" xml:space="preserve">
          <source>The server can advertise the &lt;code&gt;agent&lt;/code&gt; capability with a value &lt;code&gt;X&lt;/code&gt; (in the form &lt;code&gt;agent=X&lt;/code&gt;) to notify the client that the server is running version &lt;code&gt;X&lt;/code&gt;. The client may optionally send its own agent string by including the &lt;code&gt;agent&lt;/code&gt; capability with a value &lt;code&gt;Y&lt;/code&gt; (in the form &lt;code&gt;agent=Y&lt;/code&gt;) in its request to the server (but it MUST NOT do so if the server did not advertise the agent capability). The &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; strings may contain any printable ASCII characters except space (i.e., the byte range 32 &amp;lt; x &amp;lt; 127), and are typically of the form &quot;package/version&quot; (e.g., &quot;git/1.8.3.1&quot;). The agent strings are purely informative for statistics and debugging purposes, and MUST NOT be used to programmatically assume the presence or absence of particular features.</source>
          <target state="translated">服务器可以使用值 &lt;code&gt;X&lt;/code&gt; （以 &lt;code&gt;agent=X&lt;/code&gt; 的形式）通告 &lt;code&gt;agent&lt;/code&gt; 功能，以通知客户端服务器正在运行 &lt;code&gt;X&lt;/code&gt; 版本。客户端可以选择将自己的代理字符串发送给服务器，方法是在请求中包括一个具有 &lt;code&gt;Y&lt;/code&gt; 值（形式为 &lt;code&gt;agent=Y&lt;/code&gt; ）的 &lt;code&gt;agent&lt;/code&gt; 功能（但如果服务器未公布代理功能，则它一定不要这样做）。在 &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;Y&lt;/code&gt; ^字符串可以包含除空格（即字节范围32 &amp;lt;x &amp;lt;127）之外的任何可打印ASCII字符，并且通常采用&amp;ldquo;包/版本&amp;rdquo;形式（例如，&amp;ldquo; git / 1.8.3.1&amp;rdquo;）。代理字符串仅出于统计和调试目的提供信息，不得用于以编程方式假定是否存在特定功能。</target>
        </trans-unit>
        <trans-unit id="5d8f08f3df19bb2371d7bbd09e4f22512a514d87" translate="yes" xml:space="preserve">
          <source>The server can advertise the &lt;code&gt;object-format&lt;/code&gt; capability with a value &lt;code&gt;X&lt;/code&gt; (in the form &lt;code&gt;object-format=X&lt;/code&gt;) to notify the client that the server is able to deal with objects using hash algorithm X. If not specified, the server is assumed to only handle SHA-1. If the client would like to use a hash algorithm other than SHA-1, it should specify its object-format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dbb8fc2dd2ef1317864e26b0a2f75da26a1d7f0" translate="yes" xml:space="preserve">
          <source>The server sends a &quot;shallow obj-id&quot; line for each commit whose parents will not be sent in the following packfile.</source>
          <target state="translated">服务器为每个提交发送一个 &quot;浅层obj-id &quot;行,其父母不会在下面的packfile中发送。</target>
        </trans-unit>
        <trans-unit id="15cbc52acb55c8a437e7a9fc2cb2ebb8c994afc3" translate="yes" xml:space="preserve">
          <source>The server sends an &quot;unshallow obj-id&quot; line for each commit which the client has indicated is shallow, but is no longer shallow as a result of the fetch (due to its parents being sent in the following packfile).</source>
          <target state="translated">服务器为每一个提交发送 &quot;unshallow obj-id &quot;行,客户端已经表示该提交是浅层的,但由于取回的结果已经不再是浅层的了(由于它的父体被发送到下面的packfile中)。</target>
        </trans-unit>
        <trans-unit id="3f482eecb5e3fca563243c0419eece540e0582ac" translate="yes" xml:space="preserve">
          <source>The server will respond with &quot;ACK obj-id&quot; for all of the object ids sent as have lines which are common.</source>
          <target state="translated">服务器将以 &quot;ACK obj-id &quot;回应所有发送的对象id,因为有行是共同的。</target>
        </trans-unit>
        <trans-unit id="543a974b0aa8c62d541ca2830198235b945cc003" translate="yes" xml:space="preserve">
          <source>The server will respond with &quot;NAK&quot; if none of the object ids sent as have lines were common.</source>
          <target state="translated">如果作为have行发送的对象id没有一个是共同的,服务器将以 &quot;NAK &quot;回应。</target>
        </trans-unit>
        <trans-unit id="568256da628f1737b5310a22de9a07629ce73e0d" translate="yes" xml:space="preserve">
          <source>The server will respond with a &quot;ready&quot; line indicating that the server has found an acceptable common base and is ready to make and send a packfile (which will be found in the packfile section of the same response)</source>
          <target state="translated">服务器将以 &quot;准备好了 &quot;行来回应,表示服务器已经找到了一个可接受的公共基础,并准备好制作和发送一个packfile(它将在同一响应的packfile部分找到)。</target>
        </trans-unit>
        <trans-unit id="69ff3eec8c55e5a8095ea13f51e31e429dc845d6" translate="yes" xml:space="preserve">
          <source>The server will send a ref listing (&quot;&amp;lt;oid&amp;gt; &amp;lt;refname&amp;gt;&quot;) for each reference requested using &lt;code&gt;want-ref&lt;/code&gt; lines.</source>
          <target state="translated">服务器将使用旺旺 &lt;code&gt;want-ref&lt;/code&gt; 线为每个请求的参考发送参考列表（&amp;ldquo; &amp;lt;oid&amp;gt; &amp;lt;参考名称&amp;gt;&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="afb7e2ac1ca268d29d3dabe65a1485bc3c99ebf1" translate="yes" xml:space="preserve">
          <source>The server will then check to ensure that the client&amp;rsquo;s request is comprised of a valid command as well as valid capabilities which were advertised. If the request is valid the server will then execute the command. A server MUST wait till it has received the client&amp;rsquo;s entire request before issuing a response. The format of the response is determined by the command being executed, but in all cases a flush-pkt indicates the end of the response.</source>
          <target state="translated">然后，服务器将检查以确保客户端的请求包含有效的命令以及已通告的有效功能。如果请求有效，则服务器将执行命令。服务器必须等到收到客户端的整个请求后再发出响应。响应的格式由正在执行的命令确定，但在所有情况下，flush-pkt均指示响应结束。</target>
        </trans-unit>
        <trans-unit id="537b1e0777fad4eaaafbf4ccf5940ab37b1e2ed6" translate="yes" xml:space="preserve">
          <source>The shared index part, to be referenced by $GIT_DIR/index and other temporary index files. Only valid in split index mode.</source>
          <target state="translated">共享索引部分,由$GIT_DIR/index和其他临时索引文件引用。仅在分割索引模式下有效。</target>
        </trans-unit>
        <trans-unit id="d11a14c0103fd18e1ebb96bcb7251e0f8abbce80" translate="yes" xml:space="preserve">
          <source>The shift magic first throws away the tree id and then the -p parameters. Note that this handles merges properly! In case Darl committed a merge between P1 and P2, it will be propagated properly and all children of the merge will become merge commits with P1,P2 as their parents instead of the merge commit.</source>
          <target state="translated">Shift魔术首先抛开树的id,然后抛开-p参数。请注意,这样可以正确处理合并 如果Darl在P1和P2之间提交了一个合并,它将被正确地传播,所有合并的子代将成为以P1,P2为父代的合并提交,而不是合并提交。</target>
        </trans-unit>
        <trans-unit id="e33b2d8b27401f604cb70ad4d214df90a2abf20c" translate="yes" xml:space="preserve">
          <source>The similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one.</source>
          <target state="translated">相似性指数是指没有变化的线条的百分比,而不相似性指数是指变化线条的百分比。它是一个四舍五入的整数,后面有一个百分号。因此,相似度指数值为100%是为两个相等的文件保留的,而100%的不相似度意味着旧文件中没有行进入新文件。</target>
        </trans-unit>
        <trans-unit id="09f0c715250f8ac9e78727d6768d66502facff83" translate="yes" xml:space="preserve">
          <source>The simplest commit to find is the HEAD commit, which we can find from .git/HEAD:</source>
          <target state="translated">最简单的提交是head提交,我们可以从.git/HEAD中找到。</target>
        </trans-unit>
        <trans-unit id="938f800e1b465bd0f07eb377492ba2456bfbed2c" translate="yes" xml:space="preserve">
          <source>The simplest way to do this is using &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and ssh; to update the remote branch named &lt;code&gt;master&lt;/code&gt; with the latest state of your branch named &lt;code&gt;master&lt;/code&gt;, run</source>
          <target state="translated">最简单的方法是使用&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;和ssh; 更新名为远程分支 &lt;code&gt;master&lt;/code&gt; 与你的分支命名的最新状态 &lt;code&gt;master&lt;/code&gt; ，跑</target>
        </trans-unit>
        <trans-unit id="a5eba655ac4b55a1106bdc6c6dbf2b0d1ad04c8a" translate="yes" xml:space="preserve">
          <source>The simplest way to mark a file as binary is to unset the diff attribute in the &lt;code&gt;.gitattributes&lt;/code&gt; file:</source>
          <target state="translated">将文件标记为二进制的最简单方法是取消设置 &lt;code&gt;.gitattributes&lt;/code&gt; 文件中的diff属性：</target>
        </trans-unit>
        <trans-unit id="0f95b7ebe5f42d4f0766af1eda2b35efa6854fa9" translate="yes" xml:space="preserve">
          <source>The size in bytes of the commit or tag message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99bb329f9f9a76ae9c81982693e8d5911709e87c" translate="yes" xml:space="preserve">
          <source>The size of the object (the same as &lt;code&gt;git cat-file -s&lt;/code&gt; reports). Append &lt;code&gt;:disk&lt;/code&gt; to get the size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the &lt;code&gt;CAVEATS&lt;/code&gt; section below.</source>
          <target state="translated">对象的大小（与 &lt;code&gt;git cat-file -s&lt;/code&gt; 报告相同）。附加 &lt;code&gt;:disk&lt;/code&gt; 以获取对象占用磁盘的大小（以字节为单位）。请参阅下面的&amp;ldquo; &lt;code&gt;CAVEATS&lt;/code&gt; 部分中有关磁盘大小的注释。</target>
        </trans-unit>
        <trans-unit id="3527fa64b6fd749102c379b2fd96b0df5cd454cb" translate="yes" xml:space="preserve">
          <source>The size of the window used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; when no window size is given on the command line. Defaults to 10.</source>
          <target state="translated">窗口的大小使用&lt;a href=&quot;git-pack-objects&quot;&gt;GIT中包对象[1]&lt;/a&gt;当在命令行上没有给出窗口大小。默认为10</target>
        </trans-unit>
        <trans-unit id="2372575566ae8c805d7580bdcbad6da1c4463611" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the object (the same as &lt;code&gt;cat-file -s&lt;/code&gt; reports).</source>
          <target state="translated">对象的大小（以字节为单位）（与 &lt;code&gt;cat-file -s&lt;/code&gt; 报告相同）。</target>
        </trans-unit>
        <trans-unit id="43c333a5a6bd3bca8b34d5163a7aa7b6d79d2d40" translate="yes" xml:space="preserve">
          <source>The size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the &lt;code&gt;CAVEATS&lt;/code&gt; section below.</source>
          <target state="translated">对象在磁盘上占用的大小（以字节为单位）。请参阅下面的&amp;ldquo; &lt;code&gt;CAVEATS&lt;/code&gt; 部分中有关磁盘大小的注释。</target>
        </trans-unit>
        <trans-unit id="7d544171c06a9cb39c4059f830c0a8558d3922c9" translate="yes" xml:space="preserve">
          <source>The slash &lt;code&gt;/&lt;/code&gt; is used as the directory separator. Separators may occur at the beginning, middle or end of the &lt;code&gt;.gitignore&lt;/code&gt; search pattern.</source>
          <target state="translated">斜杠 &lt;code&gt;/&lt;/code&gt; 用作目录分隔符。分隔符可以出现在 &lt;code&gt;.gitignore&lt;/code&gt; 搜索模式的开始，中间或结尾。</target>
        </trans-unit>
        <trans-unit id="e18b2266f1b1b9062e466bd05dd697dc8d44c68f" translate="yes" xml:space="preserve">
          <source>The smaller the changes in your commit, the most effective &quot;git bisect&quot; will be. And you will probably need &quot;git bisect&quot; less in the first place, as small changes are easier to review even if they are only reviewed by the committer.</source>
          <target state="translated">提交的改动越小,&quot;git bisect &quot;就越有效。而且你可能会减少对 &quot;git bisect &quot;的需求,因为小的改动即使只有提交者审查,也更容易审查。</target>
        </trans-unit>
        <trans-unit id="0dab2fe7462a5d0c0b797d08e789dbaaf7bfa1df" translate="yes" xml:space="preserve">
          <source>The smart HTTP server, &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend[1]&lt;/a&gt;, will pass GIT_NAMESPACE through to the backend programs; see &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend[1]&lt;/a&gt; for sample configuration to expose repository namespaces as repositories.</source>
          <target state="translated">智能HTTP服务器&lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend [1]&lt;/a&gt;会将GIT_NAMESPACE传递给后端程序；请参阅&lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend [1]&lt;/a&gt;以获得用于将存储库名称空间公开为存储库的示例配置。</target>
        </trans-unit>
        <trans-unit id="9ee3be6f644f850e9ae409b580b74ced862493f8" translate="yes" xml:space="preserve">
          <source>The solution, of course, is to make a merge that we can undo: merge into a throw-away branch.</source>
          <target state="translated">当然,解决的办法是做一个我们可以撤销的合并:合并成一个扔掉的分支。</target>
        </trans-unit>
        <trans-unit id="8a1117f540255f9a5dcffa1baa25558f77657b0e" translate="yes" xml:space="preserve">
          <source>The special case of restarting an incremental import from the current branch value should be written as:</source>
          <target state="translated">从当前分支值重新启动增量导入的特殊情况应写成:。</target>
        </trans-unit>
        <trans-unit id="3599d1b8b89ee48d0b633dcff9041c57284c3251" translate="yes" xml:space="preserve">
          <source>The special exit code 125 should be used when the current source code cannot be tested. If the script exits with this code, the current revision will be skipped (see &lt;code&gt;git bisect skip&lt;/code&gt; above). 125 was chosen as the highest sensible value to use for this purpose, because 126 and 127 are used by POSIX shells to signal specific error status (127 is for command not found, 126 is for command found but not executable&amp;mdash;​these details do not matter, as they are normal errors in the script, as far as &lt;code&gt;bisect run&lt;/code&gt; is concerned).</source>
          <target state="translated">当无法测试当前源代码时，应使用特殊的退出代码125。如果脚本以该代码退出，则当前版本将被跳过（请参见上面的 &lt;code&gt;git bisect skip&lt;/code&gt; ）。 125被选为用于此目的的最高明智值，因为POSIX shell使用126和127来表示特定的错误状态（127用于未找到命令，126用于发现命令但不可执行-这些详细信息不无关紧要，因为就 &lt;code&gt;bisect run&lt;/code&gt; 而言，它们是脚本中的正常错误）。</target>
        </trans-unit>
        <trans-unit id="60ac8fe2a99f998c150bb7d9adc8dfbeed95a10d" translate="yes" xml:space="preserve">
          <source>The special null SHA-1 (40 zeros) specifies that the branch is to be removed.</source>
          <target state="translated">特殊的空SHA-1(40个零)指定要删除的分支。</target>
        </trans-unit>
        <trans-unit id="a4c2fa6682338e4d7c45557107add1984be0213c" translate="yes" xml:space="preserve">
          <source>The special refspec &lt;code&gt;:&lt;/code&gt; (or &lt;code&gt;+:&lt;/code&gt; to allow non-fast-forward updates) directs Git to push &quot;matching&quot; branches: for every branch that exists on the local side, the remote side is updated if a branch of the same name already exists on the remote side.</source>
          <target state="translated">特殊的refspec &lt;code&gt;:&lt;/code&gt; (或 &lt;code&gt;+:&lt;/code&gt; 允许非快速转发更新）指示Git推送&amp;ldquo;匹配&amp;rdquo;分支：对于本地存在的每个分支，如果已经存在同名的分支，则更新远程端在远端。</target>
        </trans-unit>
        <trans-unit id="f2f702d2704e1b64279419d712ca4460c3b7f78e" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;none&lt;/code&gt; can be used as the proxy command to specify that no proxy be used for a given domain pattern. This is useful for excluding servers inside a firewall from proxy use, while defaulting to a common proxy for external domains.</source>
          <target state="translated">特殊字符串 &lt;code&gt;none&lt;/code&gt; 可用作代理命令，以指定对于给定的域模式，不使用任何代理。这对于将防火墙内部的服务器从代理使用中排除，而默认使用外部域的通用代理很有用。</target>
        </trans-unit>
        <trans-unit id="65b859a3a4528b4a1eebafeebe9d2d28ac0eb085" translate="yes" xml:space="preserve">
          <source>The special symbol &quot;HEAD&quot; can always be used to refer to the current branch. In fact, Git uses a file named &lt;code&gt;HEAD&lt;/code&gt; in the &lt;code&gt;.git&lt;/code&gt; directory to remember which branch is current:</source>
          <target state="translated">特殊符号&amp;ldquo; HEAD&amp;rdquo;始终可以用于引用当前分支。实际上，Git 在 &lt;code&gt;.git&lt;/code&gt; 目录中使用一个名为 &lt;code&gt;HEAD&lt;/code&gt; 的文件来记住哪个分支是当前的：</target>
        </trans-unit>
        <trans-unit id="54b91d851f1b23aa70b29c0e74d2c28879b6de30" translate="yes" xml:space="preserve">
          <source>The ssh and git protocols additionally support ~username expansion:</source>
          <target state="translated">ssh和git协议另外支持~username扩展。</target>
        </trans-unit>
        <trans-unit id="ac6c6d73b5f6b7c3cef28dfe32da61495601bd7c" translate="yes" xml:space="preserve">
          <source>The standard actions are:</source>
          <target state="translated">标准行动是:</target>
        </trans-unit>
        <trans-unit id="a72f515f06e2719cd062e161d9ed80a61b68c92f" translate="yes" xml:space="preserve">
          <source>The standard email format as described by RFC 2822, for example &lt;code&gt;Thu, 07 Apr 2005 22:13:13 +0200&lt;/code&gt;.</source>
          <target state="translated">RFC 2822描述的标准电子邮件格式，例如 &lt;code&gt;Thu, 07 Apr 2005 22:13:13 +0200&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8128f4cfe82d86e129a0094608260664c3bb1ba3" translate="yes" xml:space="preserve">
          <source>The standard helper program to use with git-merge-index</source>
          <target state="translated">使用git-merge-index的标准帮助程序。</target>
        </trans-unit>
        <trans-unit id="4d34b021b617aa2bf3f93982ac428b041f085fbe" translate="yes" xml:space="preserve">
          <source>The starting point for the new branch. Specifying a &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; allows you to create a branch based on some other point in history than where HEAD currently points. (Or, in the case of &lt;code&gt;--detach&lt;/code&gt;, allows you to inspect and detach from some other point.)</source>
          <target state="translated">新分支的起点。指定 &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; 允许您基于历史记录中除HEAD当前指向的其他点来创建分支。（或者，在 &lt;code&gt;--detach&lt;/code&gt; 的情况下，允许您检查其他点并与之分离。）</target>
        </trans-unit>
        <trans-unit id="ca9ba47b83a1def4d8a6c769f2e642f061d5236a" translate="yes" xml:space="preserve">
          <source>The status of GPG verification of the push certificate, using the same mnemonic as used in &lt;code&gt;%G?&lt;/code&gt; format of &lt;code&gt;git log&lt;/code&gt; family of commands (see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;).</source>
          <target state="translated">使用与 &lt;code&gt;%G?&lt;/code&gt; 使用的相同的助记符对推送证书进行GPG验证的状态？ &lt;code&gt;git log&lt;/code&gt; 系列命令的格式（请参阅&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c902748a09ab505851b0b39809c60f3db2027be9" translate="yes" xml:space="preserve">
          <source>The status of the fetch is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</source>
          <target state="translated">取数的状态以表格形式输出,每一行代表一个ref的状态。每一行都是这样的形式。</target>
        </trans-unit>
        <trans-unit id="7729563c964ef73ba71f39abfa320766ac0cea33" translate="yes" xml:space="preserve">
          <source>The status of the push is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</source>
          <target state="translated">推送的状态以表格的形式输出,每一行代表一个参考的状态。每行的形式为:</target>
        </trans-unit>
        <trans-unit id="e939f21e3282d453b1398071feb25115360b90b4" translate="yes" xml:space="preserve">
          <source>The status of up-to-date refs is shown only if --porcelain or --verbose option is used.</source>
          <target state="translated">只有在使用--porcelain或--verbose选项时,才会显示最新参考资料的状态。</target>
        </trans-unit>
        <trans-unit id="0ebfa7ce02ec5605e425e0cd98062f5bbd8f2510" translate="yes" xml:space="preserve">
          <source>The status of up-to-date refs is shown only if the --verbose option is used.</source>
          <target state="translated">只有在使用--verbose选项时,才会显示最新的参考资料的状态。</target>
        </trans-unit>
        <trans-unit id="a97643bd561fabe3d136679e4752cb73667ec062" translate="yes" xml:space="preserve">
          <source>The structured objects can further have their structure and connectivity to other objects verified. This is generally done with the &lt;code&gt;git fsck&lt;/code&gt; program, which generates a full dependency graph of all objects, and verifies their internal consistency (in addition to just verifying their superficial consistency through the hash).</source>
          <target state="translated">结构化对象还可以验证其结构和与其他对象的连接性。通常使用 &lt;code&gt;git fsck&lt;/code&gt; 程序完成此操作，该程序会生成所有对象的完整依赖关系图，并验证其内部一致性（除了仅通过哈希验证其表面一致性之外）。</target>
        </trans-unit>
        <trans-unit id="af4ab93b8907c3bc82033e90c4bc6eedaac09e1c" translate="yes" xml:space="preserve">
          <source>The submit process invokes the editor before each p4 change is submitted. If this setting is true, though, the editing step is skipped.</source>
          <target state="translated">在每次提交p4修改之前,提交过程都会调用编辑器。但如果此设置为真,则会跳过编辑步骤。</target>
        </trans-unit>
        <trans-unit id="72386229ffdfc0f6ba847ccdd7620fcafabeae30" translate="yes" xml:space="preserve">
          <source>The submodule directories are there, but they&amp;rsquo;re empty:</source>
          <target state="translated">子模块目录在那里，但它们为空：</target>
        </trans-unit>
        <trans-unit id="802b1c9a36cac97c548242e11fe5baa3275576f0" translate="yes" xml:space="preserve">
          <source>The submodule will never be considered modified (but will nonetheless show up in the output of status and commit when it has been staged).</source>
          <target state="translated">这个子模块永远不会被认为是修改过的(但当它被分期时,还是会显示在状态和提交的输出中)。</target>
        </trans-unit>
        <trans-unit id="7180d60887d97b6ca57dd91c2b86681f019ca631" translate="yes" xml:space="preserve">
          <source>The submodule&amp;rsquo;s &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file would come into play when running &lt;code&gt;git push --recurse-submodules=check&lt;/code&gt; in the superproject, as this would check if the submodule has any changes not published to any remote. The remotes are configured in the submodule as usual in the &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file.</source>
          <target state="translated">在超级项目中运行 &lt;code&gt;git push --recurse-submodules=check&lt;/code&gt; 时，子模块的 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件将起作用，因为这将检查子模块是否有未发布到任何远程的更改。遥控器通常在 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件的子模块中进行配置。</target>
        </trans-unit>
        <trans-unit id="2a87578b15befa74b2d27eca3216884ceb35493c" translate="yes" xml:space="preserve">
          <source>The suffix &lt;code&gt;@{push}&lt;/code&gt; reports the branch &quot;where we would push to&quot; if &lt;code&gt;git push&lt;/code&gt; were run while &lt;code&gt;branchname&lt;/code&gt; was checked out (or the current &lt;code&gt;HEAD&lt;/code&gt; if no branchname is specified). Since our push destination is in a remote repository, of course, we report the local tracking branch that corresponds to that branch (i.e., something in &lt;code&gt;refs/remotes/&lt;/code&gt;).</source>
          <target state="translated">如果在 &lt;code&gt;branchname&lt;/code&gt; 时运行了 &lt;code&gt;git push&lt;/code&gt; ,则后缀 &lt;code&gt;@{push}&lt;/code&gt; 报告分支&amp;ldquo;我们将推送至的位置&amp;rdquo; （如果未指定branchname，则返回当前 &lt;code&gt;HEAD&lt;/code&gt; ）。由于推送目标位于远程存储库中，因此，我们当然会报告与该分支相对应的本地跟踪分支（即 &lt;code&gt;refs/remotes/&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c10fd9c6c93e1de11dbe32978aa15d853b4103fb" translate="yes" xml:space="preserve">
          <source>The suffix &lt;code&gt;@{upstream}&lt;/code&gt; to a branchname (short form &lt;code&gt;&amp;lt;branchname&amp;gt;@{u}&lt;/code&gt;) refers to the branch that the branch specified by branchname is set to build on top of (configured with &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;). A missing branchname defaults to the current one. These suffixes are also accepted when spelled in uppercase, and they mean the same thing no matter the case.</source>
          <target state="translated">分支名称的后缀 &lt;code&gt;@{upstream}&lt;/code&gt; （缩写为 &lt;code&gt;&amp;lt;branchname&amp;gt;@{u}&lt;/code&gt; ）是指分支名称所指定的分支被设置为建立在该分支之上（由 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 和 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; ）。缺少的分支名称默认为当前分支名称。这些后缀大写时也会被接受，无论大小写，它们都具有相同的含义。</target>
        </trans-unit>
        <trans-unit id="35fca7d90e0c51050df5863335fd96cb674d847a" translate="yes" xml:space="preserve">
          <source>The symlink will either be absolute (beginning with a /), or relative to the tree root. For instance, if dir/link points to ../../foo, then &amp;lt;symlink&amp;gt; will be ../foo. &amp;lt;size&amp;gt; is the size of the symlink in bytes.</source>
          <target state="translated">符号链接可以是绝对的（以/开头），也可以是相对于树根的符号。例如，如果dir / link指向../../foo，则&amp;lt;symlink&amp;gt;将是../foo。&amp;lt;size&amp;gt;是符号链接的大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="1e32c77f2578ce3c979cd217827d9aa3c6897be9" translate="yes" xml:space="preserve">
          <source>The syntax is fairly flexible and permissive; whitespaces are mostly ignored. The &lt;code&gt;#&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; characters begin comments to the end of line, blank lines are ignored.</source>
          <target state="translated">语法相当灵活且允许。空格通常被忽略。该 &lt;code&gt;#&lt;/code&gt; 和 &lt;code&gt;;&lt;/code&gt; 字符从注释开始到行尾，空白行将被忽略。</target>
        </trans-unit>
        <trans-unit id="e9a240786337cb206c43c416821000b9a6721022" translate="yes" xml:space="preserve">
          <source>The syntax of the configuration files is that of Perl, since these files are handled by sourcing them as fragments of Perl code (the language that gitweb itself is written in). Variables are typically set using the &lt;code&gt;our&lt;/code&gt; qualifier (as in &quot;&lt;code&gt;our $variable = &amp;lt;value&amp;gt;;&lt;/code&gt;&quot;) to avoid syntax errors if a new version of gitweb no longer uses a variable and therefore stops declaring it.</source>
          <target state="translated">配置文件的语法是Perl的语法，因为这些文件是通过将它们作为Perl代码的片段（gitweb本身所使用的语言）来提供来处理的。变量是使用通常设置 &lt;code&gt;our&lt;/code&gt; 限定符（如在&amp;ldquo; &lt;code&gt;our $variable = &amp;lt;value&amp;gt;;&lt;/code&gt; 以避免语法错误如果叫做gitweb的新版本不再使用一个变量，并因此停止它声明&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="85d5722bf15562fb833fe3c8f580a92fe2e2d3db" translate="yes" xml:space="preserve">
          <source>The tables below show what happens when running:</source>
          <target state="translated">下表显示了运行时的情况。</target>
        </trans-unit>
        <trans-unit id="0ab961c529e0da6916842ede03d74fc7b0e0f90e" translate="yes" xml:space="preserve">
          <source>The tag &lt;code&gt;v2.6.18&lt;/code&gt; is short for &lt;code&gt;refs/tags/v2.6.18&lt;/code&gt;.</source>
          <target state="translated">标签 &lt;code&gt;v2.6.18&lt;/code&gt; 是 &lt;code&gt;refs/tags/v2.6.18&lt;/code&gt; 的缩写。</target>
        </trans-unit>
        <trans-unit id="e5173af0305c1d6df2de24b7ea317c256f65109e" translate="yes" xml:space="preserve">
          <source>The template directory will be one of the following (in order):</source>
          <target state="translated">模板目录将是以下之一(按顺序)。</target>
        </trans-unit>
        <trans-unit id="45d4fdaf8fe9ac583ec50051c8f5eb8c944a1ec1" translate="yes" xml:space="preserve">
          <source>The term &lt;a href=&quot;#def_pickaxe&quot;&gt;pickaxe&lt;/a&gt; refers to an option to the diffcore routines that help select changes that add or delete a given text string. With the &lt;code&gt;--pickaxe-all&lt;/code&gt; option, it can be used to view the full &lt;a href=&quot;#def_changeset&quot;&gt;changeset&lt;/a&gt; that introduced or removed, say, a particular line of text. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">术语&lt;a href=&quot;#def_pickaxe&quot;&gt;镐&lt;/a&gt;是指diffcore例程的一个选项，该选项有助于选择添加或删除给定文本字符串的更改。使用 &lt;code&gt;--pickaxe-all&lt;/code&gt; 选项，它可以用于查看引入或删除的完整&lt;a href=&quot;#def_changeset&quot;&gt;变更集&lt;/a&gt;，例如，特定的文本行。参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2ba0595fa8d197d8c3640c03007e070ceba5b47" translate="yes" xml:space="preserve">
          <source>The text conversion is generally a one-way conversion; in this example, we lose the actual image contents and focus just on the text data. This means that diffs generated by textconv are &lt;em&gt;not&lt;/em&gt; suitable for applying. For this reason, only &lt;code&gt;git diff&lt;/code&gt; and the &lt;code&gt;git log&lt;/code&gt; family of commands (i.e., log, whatchanged, show) will perform text conversion. &lt;code&gt;git
format-patch&lt;/code&gt; will never generate this output. If you want to send somebody a text-converted diff of a binary file (e.g., because it quickly conveys the changes you have made), you should generate it separately and send it as a comment &lt;em&gt;in addition to&lt;/em&gt; the usual binary diff that you might send.</source>
          <target state="translated">文本转换通常是单向转换；在此示例中，我们丢失了实际的图像内容，而只关注文本数据。这意味着textconv生成的差异&lt;em&gt;不&lt;/em&gt;适合应用。因此，只有 &lt;code&gt;git diff&lt;/code&gt; 和 &lt;code&gt;git log&lt;/code&gt; 系列命令（即log，whatchanged，show）将执行文本转换。 &lt;code&gt;git format-patch&lt;/code&gt; 将永远不会生成此输出。如果您想将二进制文件的文本转换后的差异发送给某人（例如，因为它可以快速传达您所做的更改），则您应该单独生成该文件，并将其作为注释发送给您，&lt;em&gt;而&lt;/em&gt;不是通常的二进制差异。发送。</target>
        </trans-unit>
        <trans-unit id="eb234a21c48fd769b7576108683d04bf29f253cb" translate="yes" xml:space="preserve">
          <source>The third syntax (&quot;&lt;code&gt;git merge --continue&lt;/code&gt;&quot;) can only be run after the merge has resulted in conflicts.</source>
          <target state="translated">第三种语法（&amp;ldquo; &lt;code&gt;git merge --continue&lt;/code&gt; &amp;rdquo;）只能在合并导致冲突后运行。</target>
        </trans-unit>
        <trans-unit id="a25be90a41e318ce76ddb9737f9c1a04e1e950e3" translate="yes" xml:space="preserve">
          <source>The time between the first rc release and the final release is supposed to be used to test rc versions and fight bugs and especially regressions. And this time is more than 80% of the release cycle time. But this is not the end of the fight yet, as of course it continues after the release.</source>
          <target state="translated">从第一个rc版本到最终版本之间的时间,应该是用来测试rc版本和打击bug,尤其是回归。而这个时间占发布周期时间的80%以上。但这还不是战斗的结束,因为当然在发布后还要继续战斗。</target>
        </trans-unit>
        <trans-unit id="75271c1b7d85cdfdc3bad04249d4464b9c292a44" translate="yes" xml:space="preserve">
          <source>The time of the change is specified by &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; using the date format that was selected by the --date-format=&amp;lt;fmt&amp;gt; command-line option. See &amp;ldquo;Date Formats&amp;rdquo; above for the set of supported formats, and their syntax.</source>
          <target state="translated">更改时间由 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 使用--date-format = &amp;lt;fmt&amp;gt;命令行选项选择的日期格式指定。有关支持的格式集及其语法，请参见上面的&amp;ldquo;日期格式&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="05b9a4ac37ff05623171d65150ac27013efa2fa0" translate="yes" xml:space="preserve">
          <source>The time of the event is specified by &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; as the number of seconds since the UNIX epoch (midnight, Jan 1, 1970, UTC) and is written as an ASCII decimal integer.</source>
          <target state="translated">事件的时间由 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 指定为自UNIX纪元（1970年1月1日午夜，UTC）以来的秒数，并以ASCII十进制整数表示。</target>
        </trans-unit>
        <trans-unit id="e85bdfa8e02113c7aa36696add629ec632f05440" translate="yes" xml:space="preserve">
          <source>The todo list presented by the deprecated &lt;code&gt;--preserve-merges --interactive&lt;/code&gt; does not represent the topology of the revision graph (use &lt;code&gt;--rebase-merges&lt;/code&gt; instead). Editing commits and rewording their commit messages should work fine, but attempts to reorder commits tend to produce counterintuitive results. Use &lt;code&gt;--rebase-merges&lt;/code&gt; in such scenarios instead.</source>
          <target state="translated">不推荐使用的 &lt;code&gt;--preserve-merges --interactive&lt;/code&gt; 提供的待办事项列表不表示修订图的拓扑（请改用 &lt;code&gt;--rebase-merges&lt;/code&gt; ）。编辑提交并对提交消息进行重新措辞应该可以正常工作，但是尝试对提交进行重新排序会产生与直觉相反的结果。在这种情况下，请使用 &lt;code&gt;--rebase-merges&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f8166907df228eb9266d7566c3cde991d9d39bd" translate="yes" xml:space="preserve">
          <source>The total number of paths.</source>
          <target state="translated">总的路径数。</target>
        </trans-unit>
        <trans-unit id="46c0269533706ef03961ed4548e480cdcfd7a84a" translate="yes" xml:space="preserve">
          <source>The trailer records 20-byte SHA-1 checksum of all of the above.</source>
          <target state="translated">拖车记录了上述所有内容的20字节SHA-1校验和。</target>
        </trans-unit>
        <trans-unit id="b9ae27ef547547fea9cd9f5b91bb86a4c8f93238" translate="yes" xml:space="preserve">
          <source>The trailer records a pack checksum of all of the above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9380254df0eb0e126f55d72177d625190ab23928" translate="yes" xml:space="preserve">
          <source>The transmission of the packfile begins immediately after the section header</source>
          <target state="translated">包装文件的传输在节头之后立即开始。</target>
        </trans-unit>
        <trans-unit id="de285c430d2e1f897693d7ccc23434e1a3a5c103" translate="yes" xml:space="preserve">
          <source>The tree object is the tree we examined first, and this commit is unusual in that it lacks any parent.</source>
          <target state="translated">树对象就是我们先检查的树,这次提交的情况很特别,它缺少任何父树。</target>
        </trans-unit>
        <trans-unit id="9178b43dc9b2907a6afd7a3693f2c6894ec0ecd9" translate="yes" xml:space="preserve">
          <source>The tree of actual checked out files. The working tree normally contains the contents of the &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; commit&amp;rsquo;s tree, plus any local changes that you have made but not yet committed.</source>
          <target state="translated">实际签出文件的树。工作树通常包含&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;提交树的内容，以及您已进行但尚未提交的所有本地更改。</target>
        </trans-unit>
        <trans-unit id="26b5c7d70f82997ceabb111adeeb911e4d89a340" translate="yes" xml:space="preserve">
          <source>The tree or commit to produce an archive for.</source>
          <target state="translated">要制作存档的树或提交。</target>
        </trans-unit>
        <trans-unit id="90f78952a054862b4ed6d79982e2eab2fc081a24" translate="yes" xml:space="preserve">
          <source>The twist is that if some file doesn&amp;rsquo;t match the index, we don&amp;rsquo;t have a backing store thing for it, and we use the magic &quot;all-zero&quot; sha1 to show that. So let&amp;rsquo;s say that you have edited &lt;code&gt;kernel/sched.c&lt;/code&gt;, but have not actually done a &lt;code&gt;git update-index&lt;/code&gt; on it yet - there is no &quot;object&quot; associated with the new state, and you get:</source>
          <target state="translated">扭曲之处在于，如果某个文件与索引不匹配，那么我们就没有后备存储，而我们使用神奇的&amp;ldquo;全零&amp;rdquo; sha1来表明这一点。因此，假设您已经编辑了 &lt;code&gt;kernel/sched.c&lt;/code&gt; ，但实际上尚未对其执行 &lt;code&gt;git update-index&lt;/code&gt; index-没有与新状态关联的&amp;ldquo;对象&amp;rdquo;，您将得到：</target>
        </trans-unit>
        <trans-unit id="43d0ee9ad50c1c3c133c4c2ff3f216463ab119aa" translate="yes" xml:space="preserve">
          <source>The two options can be specified together to ask a command to work on both the index and the working tree.</source>
          <target state="translated">这两个选项可以一起指定,要求命令同时在索引和工作树上工作。</target>
        </trans-unit>
        <trans-unit id="293c342524c5d665ec090c34f37c73d153be74d5" translate="yes" xml:space="preserve">
          <source>The type of the object (&lt;code&gt;blob&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;).</source>
          <target state="translated">对象的类型（ &lt;code&gt;blob&lt;/code&gt; ， &lt;code&gt;tree&lt;/code&gt; ， &lt;code&gt;commit&lt;/code&gt; ， &lt;code&gt;tag&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="35ca6d49608b210b7cf8be4b86261fa4bd55e249" translate="yes" xml:space="preserve">
          <source>The type of the object (the same as &lt;code&gt;cat-file -t&lt;/code&gt; reports).</source>
          <target state="translated">对象的类型（与 &lt;code&gt;cat-file -t&lt;/code&gt; 报告相同）。</target>
        </trans-unit>
        <trans-unit id="a4f9324e934e3998d2ea50e9e2c5152c5cb8ca76" translate="yes" xml:space="preserve">
          <source>The typical usage is to set just the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables; the other options are provided for more complex use cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4785efb96aaa5561500dccbb8420f79e52290b85" translate="yes" xml:space="preserve">
          <source>The underlying Git plumbing tools, such as &lt;code&gt;git ls-files&lt;/code&gt; and &lt;code&gt;git read-tree&lt;/code&gt;, read &lt;code&gt;gitignore&lt;/code&gt; patterns specified by command-line options, or from files specified by command-line options. Higher-level Git tools, such as &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git add&lt;/code&gt;, use patterns from the sources specified above.</source>
          <target state="translated">基本的Git管道工具，例如 &lt;code&gt;git ls-files&lt;/code&gt; 和 &lt;code&gt;git read-tree&lt;/code&gt; ，从命令行选项指定的 &lt;code&gt;gitignore&lt;/code&gt; 读取模式，或者从命令行选项指定的文件读取gitignore模式。更高级别的Git工具（例如 &lt;code&gt;git status&lt;/code&gt; 和 &lt;code&gt;git add&lt;/code&gt; ）使用上述指定来源中的模式。</target>
        </trans-unit>
        <trans-unit id="c7717dd458d0c51efaa12d77d8ac91e6b1b7952a" translate="yes" xml:space="preserve">
          <source>The unique identifier of an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;. The object name is usually represented by a 40 character hexadecimal string. Also colloquially called &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;的唯一标识符。对象名称通常由40个字符的十六进制字符串表示。俗称&lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="190c2fffcaa0444f677f39ee7f8533684a0964b1" translate="yes" xml:space="preserve">
          <source>The unit of storage in Git. It is uniquely identified by the &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; of its contents. Consequently, an object cannot be changed.</source>
          <target state="translated">Git中的存储单位。它由其内容的&lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt;唯一标识。因此，无法更改对象。</target>
        </trans-unit>
        <trans-unit id="39871fae2a5575ced5627a5aed0eb792e4c6cc2e" translate="yes" xml:space="preserve">
          <source>The untracked cache extension can be enabled by the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">可以通过 &lt;code&gt;core.untrackedCache&lt;/code&gt; 配置变量启用未跟踪的缓存扩展（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cc7260429a75073116cdc4eb67dbd95326cbd29d" translate="yes" xml:space="preserve">
          <source>The upstream project is expected to have the commit named by &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; and the output asks it to integrate the changes you made since that commit, up to the commit named by &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt;, by visiting the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">预期上游项目将具有由 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 命名的提交，并且输出将要求它通过访问由 &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 命名的存储库集成您自该提交以来所做的更改，直至集成到由 &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; 命名的提交。</target>
        </trans-unit>
        <trans-unit id="90c1df21766dd92e926e4168cc9d516f756c7832" translate="yes" xml:space="preserve">
          <source>The upstream reference is generally &lt;code&gt;refs/remotes/p4/master&lt;/code&gt;, but can be overridden using the &lt;code&gt;--origin=&lt;/code&gt; command-line option.</source>
          <target state="translated">上游引用通常是 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; ，但是可以使用 &lt;code&gt;--origin=&lt;/code&gt; 命令行选项覆盖。</target>
        </trans-unit>
        <trans-unit id="26e6d639f86a47deca57ab3911edaae9c5141f38" translate="yes" xml:space="preserve">
          <source>The user wants to fast-forward to $M.</source>
          <target state="translated">用户想快进到$M。</target>
        </trans-unit>
        <trans-unit id="6df61c6f9e257fdbf1ce4a60fb1d73b618d329ca" translate="yes" xml:space="preserve">
          <source>The user&amp;rsquo;s color.status configuration is not respected; color will always be off.</source>
          <target state="translated">不尊重用户的color.status配置；颜色将始终关闭。</target>
        </trans-unit>
        <trans-unit id="ab6a20b222f27dba657bc91ae7970effd7a690ca" translate="yes" xml:space="preserve">
          <source>The user&amp;rsquo;s status.relativePaths configuration is not respected; paths shown will always be relative to the repository root.</source>
          <target state="translated">不遵守用户的status.relativePaths配置；显示的路径将始终相对于存储库根目录。</target>
        </trans-unit>
        <trans-unit id="20126eaca194f3ace1deaba2aaa4133e6326b674" translate="yes" xml:space="preserve">
          <source>The user-provided shell commands will likely involve a pipeline of commands, resulting in the creation of many processes per commit. Creating and running another process takes a widely varying amount of time between operating systems, but on any platform it is very slow relative to invoking a function.</source>
          <target state="translated">用户提供的shell命令很可能会涉及到一个命令流水线,导致每次提交都会创建许多进程。创建和运行另一个进程所需的时间在不同的操作系统之间有很大的差异,但在任何平台上,相对于调用一个函数来说都是非常缓慢的。</target>
        </trans-unit>
        <trans-unit id="b70cc2efdcbaf68bada34e0550746a0012d52bae" translate="yes" xml:space="preserve">
          <source>The username to use when logging in to the server.</source>
          <target state="translated">登录服务器时要使用的用户名。</target>
        </trans-unit>
        <trans-unit id="46c33e134557b27ccb1a85349808f80ba518bd84" translate="yes" xml:space="preserve">
          <source>The valid values for this option are: &lt;code&gt;add&lt;/code&gt; (this is the default) and &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">此选项的有效值为： &lt;code&gt;add&lt;/code&gt; （这是默认值）和 &lt;code&gt;doNothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17a990c606d2e2e22a8f755a1f843b57ef2f5ef2" translate="yes" xml:space="preserve">
          <source>The valid values for this option are: &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; (this is the default), &lt;code&gt;addIfDifferent&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">此选项的有效值为： &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; （这是默认值）， &lt;code&gt;addIfDifferent&lt;/code&gt; ， &lt;code&gt;add&lt;/code&gt; ， &lt;code&gt;replace&lt;/code&gt; 或 &lt;code&gt;doNothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="505e929c5c3b27eed17b03a2625718de5c7f7031" translate="yes" xml:space="preserve">
          <source>The value for a variable that takes a color is a list of colors (at most two, one for foreground and one for background) and attributes (as many as you want), separated by spaces.</source>
          <target state="translated">取色变量的值是一个颜色列表(最多两个,一个是前景色,一个是背景色)和属性(任意多个),用空格分隔。</target>
        </trans-unit>
        <trans-unit id="e1d242fc18797a443a86ba553d48e3f3cae01e9a" translate="yes" xml:space="preserve">
          <source>The value for many variables that specify various sizes can be suffixed with &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;,&amp;hellip;​ to mean &quot;scale the number by 1024&quot;, &quot;by 1024x1024&quot;, etc.</source>
          <target state="translated">可以将指定各种大小的许多变量的值加 &lt;code&gt;k&lt;/code&gt; ， &lt;code&gt;M&lt;/code&gt; ，... 后缀，以表示&amp;ldquo;将数字缩放1024&amp;rdquo;，&amp;ldquo;按1024x1024&amp;rdquo;等。</target>
        </trans-unit>
        <trans-unit id="f1dedc58ec3c676ad597a786553123421e517365" translate="yes" xml:space="preserve">
          <source>The value is a list of three values: a default time zone (for if the client hasn&amp;rsquo;t selected some other time zone and saved it in a cookie), a name of cookie where to store selected time zone, and a CSS class used to mark up dates for manipulation. If you want to turn this feature off, set &quot;default&quot; to empty list: &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">该值是三个值的列表：默认时区（如果客户端未选择其他时区并将其保存在Cookie中），用于存储所选时区的cookie名称以及所使用的CSS类标记日期以便进行操作。如果要关闭此功能，请将&amp;ldquo;默认&amp;rdquo;设置为空列表： &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0462ada8e80b752f4ecad69fb2563ec0b8b930aa" translate="yes" xml:space="preserve">
          <source>The value of 'default' is a list of names of snapshot formats, defined in &lt;code&gt;%known_snapshot_formats&lt;/code&gt; hash, that you wish to offer. Supported formats include &quot;tgz&quot;, &quot;tbz2&quot;, &quot;txz&quot; (gzip/bzip2/xz compressed tar archive) and &quot;zip&quot;; please consult gitweb sources for a definitive list. By default only &quot;tgz&quot; is offered.</source>
          <target state="translated">&amp;ldquo; default&amp;rdquo;的值是您希望提供的快照格式名称的列表，这些名称在 &lt;code&gt;%known_snapshot_formats&lt;/code&gt; 哈希中定义。支持的格式包括&amp;ldquo; tgz&amp;rdquo;，&amp;ldquo; tbz2&amp;rdquo;，&amp;ldquo; txz&amp;rdquo;（gzip / bzip2 / xz压缩tar存档）和&amp;ldquo; zip&amp;rdquo;；请查阅gitweb来源以获得确切的列表。默认情况下，仅提供&amp;ldquo; tgz&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c34b53e9a12553098df9adad4c30762484ffde18" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; must be a valid refname in Git and therefore may contain forward slashes. As &lt;code&gt;LF&lt;/code&gt; is not valid in a Git refname, no quoting or escaping syntax is supported here.</source>
          <target state="translated">&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 的值必须是Git中的有效refname，因此可能包含正斜杠。由于 &lt;code&gt;LF&lt;/code&gt; 在Git引用名称中无效，因此此处不支持引用或转义语法。</target>
        </trans-unit>
        <trans-unit id="8b5a30f586808b1827fdb8f433a15c6c9d49f6ba" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; must be in canonical form. That is it must not:</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 的值必须为规范形式。那绝对不能：</target>
        </trans-unit>
        <trans-unit id="dfb2ec984e9987b1b930824861a3abbf3e4aa29f" translate="yes" xml:space="preserve">
          <source>The value of this attribute specifies the character encoding that should be used by GUI tools (e.g. &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; and &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;) to display the contents of the relevant file. Note that due to performance considerations &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; does not use this attribute unless you manually enable per-file encodings in its options.</source>
          <target state="translated">此属性的值指定GUI工具（例如&lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt;和&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt;）用于显示相关文件内容的字符编码。请注意，出于性能方面的考虑，除非您在其选项中手动启用按文件编码，否则&lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt;不会使用此属性。</target>
        </trans-unit>
        <trans-unit id="4bdcd2a8dee01aee6c5f0f23e7e10ac25985aae6" translate="yes" xml:space="preserve">
          <source>The value of this key is the name of the promisor remote.</source>
          <target state="translated">这个键的值是承诺者远程的名称。</target>
        </trans-unit>
        <trans-unit id="49e3be97b83e2e2d47823db7b33592c5066364cc" translate="yes" xml:space="preserve">
          <source>The version parameter is used to specify the format version. This is optional and defaults to the original version &lt;code&gt;v1&lt;/code&gt; format.</source>
          <target state="translated">version参数用于指定格式版本。这是可选的，默认为原始版本 &lt;code&gt;v1&lt;/code&gt; 格式。</target>
        </trans-unit>
        <trans-unit id="a720bc9826a296e909d26ea1e1addd2076945090" translate="yes" xml:space="preserve">
          <source>The victim sends &quot;have&quot; lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn&amp;rsquo;t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to &quot;merge&quot; X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)</source>
          <target state="translated">受害者发送&amp;ldquo; have&amp;rdquo;行，广告它拥有的对象的ID，这些对象的ID并不是明确要共享的，但是如果对等方也有它们，则可以用来优化传输。攻击者选择要窃取的对象ID X并将引用发送给X，但由于受害者已经拥有X，因此不需要发送X的内容。现在，受害者认为攻击者拥有X，并将X的内容稍后发送回攻击者。 （通过在客户端有权访问的名称空间中创建对X的引用，然后将其提取，这种攻击对于客户端在服务器上执行来说是最直接的。服务器在客户端上执行此操作的最可能方式是&amp;ldquo;将&amp;ldquo; X&amp;rdquo;合并到公共分支，并希望用户在该分支上做其他工作并将其推送回服务器，而不会注意到合并。）</target>
        </trans-unit>
        <trans-unit id="bad569f9e07003c7e9ba90b91ff6d5e2d3ebab92" translate="yes" xml:space="preserve">
          <source>The virtual host configuration (in Apache configuration file) should look like this:</source>
          <target state="translated">虚拟主机的配置(在Apache配置文件中)应该是这样的。</target>
        </trans-unit>
        <trans-unit id="6258db9fdd3beac891e6dcfd7dedb19764ce413e" translate="yes" xml:space="preserve">
          <source>The way &lt;code&gt;git update-index&lt;/code&gt; handles files it is told about can be modified using the various options:</source>
          <target state="translated">该方式 &lt;code&gt;git update-index&lt;/code&gt; 手柄文件，它讲述可以使用各种选项进行修改：</target>
        </trans-unit>
        <trans-unit id="ae6c5b18c0fd18e4f577ab3723eb5808f05d9f12" translate="yes" xml:space="preserve">
          <source>The web browser can be specified using the configuration variable &lt;code&gt;help.browser&lt;/code&gt;, or &lt;code&gt;web.browser&lt;/code&gt; if the former is not set. If none of these config variables is set, the &lt;code&gt;git web--browse&lt;/code&gt; helper script (called by &lt;code&gt;git help&lt;/code&gt;) will pick a suitable default. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2adc08265063993fb836b81a622f1e26249d55" translate="yes" xml:space="preserve">
          <source>The web browser can be specified using the configuration variable &lt;code&gt;help.browser&lt;/code&gt;, or &lt;code&gt;web.browser&lt;/code&gt; if the former is not set. If none of these config variables is set, the &lt;code&gt;git web{litdd}browse&lt;/code&gt; helper script (called by &lt;code&gt;git help&lt;/code&gt;) will pick a suitable default. See git-web{litdd}browse[1] for more information about this.</source>
          <target state="translated">可以使用配置变量 &lt;code&gt;help.browser&lt;/code&gt; 或 &lt;code&gt;web.browser&lt;/code&gt; (如果未设置前者）来指定Web浏览器。如果未设置这些配置变量，则 &lt;code&gt;git web{litdd}browse&lt;/code&gt; 助手脚本（由 &lt;code&gt;git help&lt;/code&gt; 调用）将选择合适的默认值。有关更多信息，请参见git-web {litdd} browse [1]。</target>
        </trans-unit>
        <trans-unit id="d52f23a775c5f3aadffb0193202482a8a4b8d0b1" translate="yes" xml:space="preserve">
          <source>The web browser that should be used to view the gitweb page. This will be passed to the &lt;code&gt;git web--browse&lt;/code&gt; helper script along with the URL of the gitweb instance. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this. If the script fails, the URL will be printed to stdout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38f40c77930468f76ac59e3f127231f37c11803" translate="yes" xml:space="preserve">
          <source>The web browser that should be used to view the gitweb page. This will be passed to the &lt;code&gt;git web{litdd}browse&lt;/code&gt; helper script along with the URL of the gitweb instance. See git-web{litdd}browse[1] for more information about this. If the script fails, the URL will be printed to stdout.</source>
          <target state="translated">应该用于查看gitweb页面的Web浏览器。它将与gitweb实例的URL一起传递到 &lt;code&gt;git web{litdd}browse&lt;/code&gt; 帮助脚本。有关更多信息，请参见git-web {litdd} browse [1]。如果脚本失败，则URL将被打印到stdout。</target>
        </trans-unit>
        <trans-unit id="c7492cc5fa9e9927a227312bd1f1ea85a3766cb5" translate="yes" xml:space="preserve">
          <source>The width (in characters) of the &quot;Description&quot; column of the projects list. Longer descriptions will be truncated (trying to cut at word boundary); the full description is available in the &lt;code&gt;title&lt;/code&gt; attribute (usually shown on mouseover). The default is 25, which might be too small if you use long project descriptions.</source>
          <target state="translated">项目列表的&amp;ldquo;描述&amp;rdquo;列的宽度（以字符为单位）。较长的描述将被截断（试图在单词边界处切开）；完整的描述位于 &lt;code&gt;title&lt;/code&gt; 属性中（通常在鼠标悬停时显示）。默认值为25，如果使用较长的项目描述，则可能太小。</target>
        </trans-unit>
        <trans-unit id="2a9553b8b798d28f6c8fd9f09980f5b7959498e9" translate="yes" xml:space="preserve">
          <source>The window size parameter used in the delta compression algorithm used by &lt;code&gt;git gc --aggressive&lt;/code&gt;. This defaults to 250, which is a much more aggressive window size than the default &lt;code&gt;--window&lt;/code&gt; of 10.</source>
          <target state="translated">&lt;code&gt;git gc --aggressive&lt;/code&gt; 使用的增量压缩算法中使用的窗口大小参数。默认值为250，这比默认 &lt;code&gt;--window&lt;/code&gt; 10 窗口大小大得多。</target>
        </trans-unit>
        <trans-unit id="046739930d5e8946cdceaf820a70c4ac9ebc8d51" translate="yes" xml:space="preserve">
          <source>The working directory then reflects the contents that the project had when it was tagged v2.6.13, and &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; shows two branches, with an asterisk marking the currently checked-out branch:</source>
          <target state="translated">然后，工作目录反映了项目被标记为v2.6.13时的内容，而&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;显示了两个分支，其中带有星号的标记表示当前已签出的分支：</target>
        </trans-unit>
        <trans-unit id="c76d23bfcb6d4a63fd96acda23f8bee068090518" translate="yes" xml:space="preserve">
          <source>The worktree list command has two output formats. The default format shows the details on a single line with columns. For example:</source>
          <target state="translated">工作树列表命令有两种输出格式。默认格式是在单行上显示详细信息,并有列。例如,工作树列表命令有两种输出格式,默认的格式是将详细信息显示在带列的单行上。</target>
        </trans-unit>
        <trans-unit id="ecaf7c5f30215b083ffbd406549425a7d1040c7d" translate="yes" xml:space="preserve">
          <source>Then &quot;&lt;code&gt;git merge topic&lt;/code&gt;&quot; will replay the changes made on the &lt;code&gt;topic&lt;/code&gt; branch since it diverged from &lt;code&gt;master&lt;/code&gt; (i.e., &lt;code&gt;E&lt;/code&gt;) until its current commit (&lt;code&gt;C&lt;/code&gt;) on top of &lt;code&gt;master&lt;/code&gt;, and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.</source>
          <target state="translated">那么，&amp;ldquo; &lt;code&gt;git merge topic&lt;/code&gt; &amp;rdquo;将重播上所做的更改 &lt;code&gt;topic&lt;/code&gt; 分支，因为它从分歧 &lt;code&gt;master&lt;/code&gt; （即 &lt;code&gt;E&lt;/code&gt; ），直到其当前提交（ &lt;code&gt;C&lt;/code&gt; 之上） &lt;code&gt;master&lt;/code&gt; ，并在新的记录结果用的名字提交沿两个父提交，以及来自用户的描述更改的日志消息。</target>
        </trans-unit>
        <trans-unit id="f3bf49c80f1bf671798b336ee7a6337eb982b2bc" translate="yes" xml:space="preserve">
          <source>Then &quot;&lt;code&gt;git pull&lt;/code&gt;&quot; will fetch and replay the changes from the remote &lt;code&gt;master&lt;/code&gt; branch since it diverged from the local &lt;code&gt;master&lt;/code&gt; (i.e., &lt;code&gt;E&lt;/code&gt;) until its current commit (&lt;code&gt;C&lt;/code&gt;) on top of &lt;code&gt;master&lt;/code&gt; and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.</source>
          <target state="translated">那么，&amp;ldquo; &lt;code&gt;git pull&lt;/code&gt; &amp;rdquo;将获取和重放从远程更改 &lt;code&gt;master&lt;/code&gt; 分支，因为它从本地分歧 &lt;code&gt;master&lt;/code&gt; （即 &lt;code&gt;E&lt;/code&gt; ），直到其当前提交（ &lt;code&gt;C&lt;/code&gt; ^）之上 &lt;code&gt;master&lt;/code&gt; ，并在新的记录结果与提交沿两个父提交的名称以及来自用户的描述更改的日志消息。</target>
        </trans-unit>
        <trans-unit id="44f92500b7ae9560ae64e2f2fc4f1af900d3ff26" translate="yes" xml:space="preserve">
          <source>Then &quot;git bisect&quot; will checkout a commit of its choosing and ask the user to test it, like this:</source>
          <target state="translated">然后,&quot;git bisect &quot;会勾选一个它选择的提交,并要求用户测试它,就像这样。</target>
        </trans-unit>
        <trans-unit id="e1ef052a3cd59f805d0ae45d1b9033a6a2faaa95" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;git bisect&lt;/code&gt; will respond with something like</source>
          <target state="translated">然后 &lt;code&gt;git bisect&lt;/code&gt; 会回应类似</target>
        </trans-unit>
        <trans-unit id="307236a389d15c9e88cc574f3c2b3a0314992840" translate="yes" xml:space="preserve">
          <source>Then compile and test the chosen revision, and afterwards mark the revision as good or bad in the usual manner.</source>
          <target state="translated">然后对所选的修订版进行编译和测试,之后按照常规的方式对修订版进行好坏标记。</target>
        </trans-unit>
        <trans-unit id="876e252bd62eb2a97f748800c6625b2b00ccfdec" translate="yes" xml:space="preserve">
          <source>Then confirm that the bug persists in a repository created from that stream (many bugs will not, as they really do depend on the exact repository contents):</source>
          <target state="translated">然后确认该bug在从该流创建的仓库中持续存在(许多bug不会,因为它们确实取决于仓库的确切内容)。</target>
        </trans-unit>
        <trans-unit id="87463a5d117dae6022935ddfd68f09bfbb9b0943" translate="yes" xml:space="preserve">
          <source>Then create the following script to get list of project in the format suitable for GITWEB_LIST build configuration variable (or &lt;code&gt;$projects_list&lt;/code&gt; variable in gitweb config):</source>
          <target state="translated">然后创建以下脚本，以适合GITWEB_LIST构建配置变量（或gitweb config中的 &lt;code&gt;$projects_list&lt;/code&gt; 变量）的格式获取项目列表：</target>
        </trans-unit>
        <trans-unit id="b5a742d8577423cd13ed5705b5290de27ff73949" translate="yes" xml:space="preserve">
          <source>Then fixup &quot;master&quot; with &lt;code&gt;git rebase&lt;/code&gt;. Do NOT use &lt;code&gt;git merge&lt;/code&gt; or your history will not be compatible with a future &lt;code&gt;dcommit&lt;/code&gt;!</source>
          <target state="translated">然后用 &lt;code&gt;git rebase&lt;/code&gt; 修复&amp;ldquo; master&amp;rdquo; 。不要使用 &lt;code&gt;git merge&lt;/code&gt; ,否则您的历史记录将与以后的 &lt;code&gt;dcommit&lt;/code&gt; 不兼容！</target>
        </trans-unit>
        <trans-unit id="78318329e21f0014f75ba54a708b1f46ad0d023c" translate="yes" xml:space="preserve">
          <source>Then it compares the new skip-worktree value with the previous one. If skip-worktree turns from set to unset, it will add the corresponding file back. If it turns from unset to set, that file will be removed.</source>
          <target state="translated">然后将新的 skip-worktree 值与之前的值进行比较。如果 skip-worktree 从 set 转为 unset,它将把相应的文件添加回来。如果从unset转为set,则该文件将被删除。</target>
        </trans-unit>
        <trans-unit id="5e9c59419a3e5d8568740259a39319d49129c624" translate="yes" xml:space="preserve">
          <source>Then it examines &lt;code&gt;.gitattributes&lt;/code&gt; (which is in the parent directory), and finds that the first line matches, but &lt;code&gt;t/.gitattributes&lt;/code&gt; file already decided how &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; attributes should be given to this path, so it leaves &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; unset. Attribute &lt;code&gt;baz&lt;/code&gt; is set.</source>
          <target state="translated">然后，它检查 &lt;code&gt;.gitattributes&lt;/code&gt; （位于父目录中），发现第一行匹配，但是 &lt;code&gt;t/.gitattributes&lt;/code&gt; 文件已经决定了如何 &lt;code&gt;merge&lt;/code&gt; ， &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 属性赋予该路径，因此保留 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 未设定。设置属性 &lt;code&gt;baz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1100f313a3d209e54bf3bc725a364711886dbfc4" translate="yes" xml:space="preserve">
          <source>Then modify, reorder, or eliminate patches as needed before applying them again with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;:</source>
          <target state="translated">然后根据需要修改，重新排序或消除补丁，然后使用&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;再次应用它们：</target>
        </trans-unit>
        <trans-unit id="cd43ef848f2d3c4afb2a44ae28c2a413397c1d96" translate="yes" xml:space="preserve">
          <source>Then provide your password via the pserver method, for example:</source>
          <target state="translated">然后通过pserver方法提供密码,例如。</target>
        </trans-unit>
        <trans-unit id="a774f276f116b48d127c0c1418ef7aa2fe46b49b" translate="yes" xml:space="preserve">
          <source>Then simplify each commit &lt;code&gt;C&lt;/code&gt; to its replacement &lt;code&gt;C'&lt;/code&gt; in the final history according to the following rules:</source>
          <target state="translated">然后根据以下规则在最终历史记录中将每个提交 &lt;code&gt;C&lt;/code&gt; 简化为其替换 &lt;code&gt;C'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2f5d7fdcf8fcb013dcf3c597507de91a5cb0f77d" translate="yes" xml:space="preserve">
          <source>Then simply fork your topic branches from the stable remotes as explained earlier.</source>
          <target state="translated">然后按照前面的解释,简单地从稳定的远程中分叉出你的主题分支。</target>
        </trans-unit>
        <trans-unit id="b19a7b2e2b2e2252f0564256c9b87915d5db46d3" translate="yes" xml:space="preserve">
          <source>Then suppose you modify the last three commits:</source>
          <target state="translated">那么假设你修改了最后三次提交。</target>
        </trans-unit>
        <trans-unit id="e69e2e34d497710c4127a780d2a5ed5c7d7fac83" translate="yes" xml:space="preserve">
          <source>Then there are two ways to get a smaller repository. A safer way is to clone, that keeps your original intact.</source>
          <target state="translated">那么有两种方法可以让仓库变小。比较安全的方法是克隆,这样可以保持你的原件不变。</target>
        </trans-unit>
        <trans-unit id="5c871054b486e3acaf28dc409c1ab3e693b4fc90" translate="yes" xml:space="preserve">
          <source>Then this &lt;code&gt;git p4 clone&lt;/code&gt; command:</source>
          <target state="translated">然后这个 &lt;code&gt;git p4 clone&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="db9b57b987ef397bc0b191d278e31ed2d827cb0a" translate="yes" xml:space="preserve">
          <source>Then you can disable sparse checkout. Sparse checkout support in &lt;code&gt;git read-tree&lt;/code&gt; and similar commands is disabled by default. You need to turn &lt;code&gt;core.sparseCheckout&lt;/code&gt; on in order to have sparse checkout support.</source>
          <target state="translated">然后，您可以禁用稀疏签出。 &lt;code&gt;git read-tree&lt;/code&gt; 和类似命令中的稀疏签出支持默认情况下处于禁用状态。您需要打开 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 才能获得稀疏签出支持。</target>
        </trans-unit>
        <trans-unit id="87a33f516a8ffec885e906dbb29e388a5f30ada0" translate="yes" xml:space="preserve">
          <source>Then you can pull and merge, leaving &lt;code&gt;frotz.c&lt;/code&gt; and &lt;code&gt;filfre.c&lt;/code&gt; changes still in the working tree.</source>
          <target state="translated">然后，您可以拉并合并，将 &lt;code&gt;frotz.c&lt;/code&gt; 和 &lt;code&gt;filfre.c&lt;/code&gt; 的更改仍保留在工作树中。</target>
        </trans-unit>
        <trans-unit id="fa280cd97c17d646b4ce0e60bbbcb27953b34fb3" translate="yes" xml:space="preserve">
          <source>Then you can push both the test and release trees using &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;:</source>
          <target state="translated">然后，您可以使用&lt;a href=&quot;git-push&quot;&gt;git-push [1]推送&lt;/a&gt;测试和发布树：</target>
        </trans-unit>
        <trans-unit id="9015e54306232b9477b76c544780cb6cb29e184c" translate="yes" xml:space="preserve">
          <source>Then you might want a &lt;code&gt;.mailmap&lt;/code&gt; file that looks like:</source>
          <target state="translated">然后，您可能需要一个 &lt;code&gt;.mailmap&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="bdefcc2b7f4d341c71ca424367a0164c209ac375" translate="yes" xml:space="preserve">
          <source>Then you transfer file.bundle to the target machine B. Because this bundle does not require any existing object to be extracted, you can create a new repository on machine B by cloning from it:</source>
          <target state="translated">然后将file.bundle转移到目标机器B上,因为这个bundle不需要提取任何现有的对象,所以你可以在机器B上通过克隆它来创建一个新的仓库。</target>
        </trans-unit>
        <trans-unit id="e826c3727c0c79aa7b30f2352881ef1c5a35f171" translate="yes" xml:space="preserve">
          <source>Then you would define a &quot;filter.indent.clean&quot; and &quot;filter.indent.smudge&quot; configuration in your .git/config to specify a pair of commands to modify the contents of C programs when the source files are checked in (&quot;clean&quot; is run) and checked out (no change is made because the command is &quot;cat&quot;).</source>
          <target state="translated">那么你就在你的.git/config中定义一个 &quot;filter.indent.clean &quot;和 &quot;filter.indent.smudge &quot;的配置,来指定一对命令,以便在源文件检查进来(运行 &quot;clean&quot;)和检查出去(因为命令是 &quot;cat&quot;,所以没有修改)时修改C程序的内容。</target>
        </trans-unit>
        <trans-unit id="c6308f4c83137c8ddf705f0b33927bc3a2a2d3bf" translate="yes" xml:space="preserve">
          <source>Then, make that directory into a Git repository by running &lt;code&gt;git init&lt;/code&gt;, but this time, since its name is not the usual &lt;code&gt;.git&lt;/code&gt;, we do things slightly differently:</source>
          <target state="translated">然后，通过运行 &lt;code&gt;git init&lt;/code&gt; 将该目录放入Git存储库，但这一次，由于其名称不是通常的 &lt;code&gt;.git&lt;/code&gt; ，因此我们做的事情略有不同：</target>
        </trans-unit>
        <trans-unit id="4d45e0228f3dfbda52666260c02f45c435d7f13c" translate="yes" xml:space="preserve">
          <source>Then, use &lt;code&gt;git bisect &amp;lt;term-old&amp;gt;&lt;/code&gt; and &lt;code&gt;git bisect &amp;lt;term-new&amp;gt;&lt;/code&gt; instead of &lt;code&gt;git bisect good&lt;/code&gt; and &lt;code&gt;git bisect bad&lt;/code&gt; to mark commits.</source>
          <target state="translated">然后，使用 &lt;code&gt;git bisect &amp;lt;term-old&amp;gt;&lt;/code&gt; 和 &lt;code&gt;git bisect &amp;lt;term-new&amp;gt;&lt;/code&gt; 代替 &lt;code&gt;git bisect good&lt;/code&gt; 和 &lt;code&gt;git bisect bad&lt;/code&gt; 标记提交。</target>
        </trans-unit>
        <trans-unit id="b100177b4f5d14520d5631ccbd2bc2ff52393e78" translate="yes" xml:space="preserve">
          <source>Then, you run this command:</source>
          <target state="translated">然后,你运行这个命令。</target>
        </trans-unit>
        <trans-unit id="ebbdc2314a6104dc9178c4c9ed7835ad78f84727" translate="yes" xml:space="preserve">
          <source>Then, you would define a &quot;diff.tex.xfuncname&quot; configuration to specify a regular expression that matches a line that you would want to appear as the hunk header &quot;TEXT&quot;. Add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">然后，您将定义&amp;ldquo; diff.tex.xfuncname&amp;rdquo;配置，以指定一个正则表达式，该正则表达式与您希望以粗体标题&amp;ldquo; TEXT&amp;rdquo;出现的行匹配。像这样在您的 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件（或 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 文件）中添加一个部分：</target>
        </trans-unit>
        <trans-unit id="8d94c9456285c171a8f18dcac7b76fd1fccc9ff4" translate="yes" xml:space="preserve">
          <source>There are (number of parents + 1) &lt;code&gt;@&lt;/code&gt; characters in the chunk header for combined diff format.</source>
          <target state="translated">组合式diff格式的块标题中有（父级数+ 1）个 &lt;code&gt;@&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="f7e9cf96a6ce9ed5c513750352c4736c076b5145" translate="yes" xml:space="preserve">
          <source>There are CPP wrapper macros and ifdefs to hide most of these details. See &lt;code&gt;trace2.h&lt;/code&gt; for more details. The following discussion will only describe the simplified forms.</source>
          <target state="translated">有CPP包装器宏和ifdefs隐藏了大多数这些细节。有关更多详细信息，请参见 &lt;code&gt;trace2.h&lt;/code&gt; 。以下讨论将仅描述简化形式。</target>
        </trans-unit>
        <trans-unit id="e4287f1e47cb2bfc1b9e5f25165aef43ceec9d6c" translate="yes" xml:space="preserve">
          <source>There are a few built-in low-level merge drivers defined that can be asked for via the &lt;code&gt;merge&lt;/code&gt; attribute.</source>
          <target state="translated">定义了一些内置的低级合并驱动程序，可以通过 &lt;code&gt;merge&lt;/code&gt; 属性要求它们。</target>
        </trans-unit>
        <trans-unit id="12f3989319ea3c0cba3d029a62ee2c306fd0616b" translate="yes" xml:space="preserve">
          <source>There are a few built-in patterns to make this easier, and &lt;code&gt;tex&lt;/code&gt; is one of them, so you do not have to write the above in your configuration file (you still need to enable this with the attribute mechanism, via &lt;code&gt;.gitattributes&lt;/code&gt;). The following built in patterns are available:</source>
          <target state="translated">有一些内置模式可以简化此过程，而 &lt;code&gt;tex&lt;/code&gt; 是其中之一，因此您不必在配置文件中编写以上内容（您仍然需要通过 &lt;code&gt;.gitattributes&lt;/code&gt; 通过属性机制启用此功能）。可以使用以下内置模式：</target>
        </trans-unit>
        <trans-unit id="336d04ab3583042f88f12edf2d051324b94f62a0" translate="yes" xml:space="preserve">
          <source>There are a few issues to resolve before we can completely switch to Trace2.</source>
          <target state="translated">在我们完全切换到Trace2之前,有几个问题需要解决。</target>
        </trans-unit>
        <trans-unit id="c8e0813ee0029806de1de3d5b367acd9c0a0d07d" translate="yes" xml:space="preserve">
          <source>There are a few more behavioral differences that most folks would probably consider inconsequential but which are mentioned for completeness:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f553cccafe9fdfa62552e6e1af4be573be245c47" translate="yes" xml:space="preserve">
          <source>There are a few special-purpose refs that do not begin with &lt;code&gt;refs/&lt;/code&gt;. The most notable example is &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">有一些特殊用途的ref并非以 &lt;code&gt;refs/&lt;/code&gt; 开头。最著名的例子是 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc9f53378dabd08666f7e5c5af2a717dbbd37e28" translate="yes" xml:space="preserve">
          <source>There are a number of factors which affect how much memory fast-import requires to perform an import. Like critical sections of core Git, fast-import uses its own memory allocators to amortize any overheads associated with malloc. In practice fast-import tends to amortize any malloc overheads to 0, due to its use of large block allocations.</source>
          <target state="translated">有很多因素会影响 fast-import 在执行导入时需要多少内存。和 Git 的核心部分一样,fast-import 使用自己的内存分配器来摊销与 malloc 相关的开销。在实践中,由于使用了大块分配,fast-import 倾向于将所有 malloc 开销摊销为 0。</target>
        </trans-unit>
        <trans-unit id="e0b2b532209e8b05d8ee20f67e782301986fd65a" translate="yes" xml:space="preserve">
          <source>There are also cases where existing indexes written by git versions before 2.17 will reference directories that don&amp;rsquo;t exist anymore, potentially causing many &quot;could not open directory&quot; warnings to be printed on &quot;git status&quot;. These are new warnings for existing issues that were previously silently discarded.</source>
          <target state="translated">在某些情况下，由2.17之前的git版本编写的现有索引将引用不再存在的目录，从而可能导致在&amp;ldquo; git status&amp;rdquo;上显示许多&amp;ldquo;无法打开目录&amp;rdquo;警告。这些是针对以前已被静默丢弃的现有问题的新警告。</target>
        </trans-unit>
        <trans-unit id="aec0acb7fb7522f7c5da2df9b13975842cb9d1be" translate="yes" xml:space="preserve">
          <source>There are also more complex operations that can be performed. But beware that because the patch is applied only to the index and not the working tree, the working tree will appear to &quot;undo&quot; the change in the index. For example, introducing a new line into the index that is in neither the HEAD nor the working tree will stage the new line for commit, but the line will appear to be reverted in the working tree.</source>
          <target state="translated">还可以进行更复杂的操作。但要注意的是,由于补丁只应用于索引而非工作树,工作树会出现 &quot;撤销 &quot;索引中的更改。例如,在索引中引入一个既不在 HEAD 也不在工作树中的新行,会对新行进行阶段性提交,但在工作树中该行会被还原。</target>
        </trans-unit>
        <trans-unit id="a266660a35cd18470141c43d8a3ffa2b3074c06a" translate="yes" xml:space="preserve">
          <source>There are also other situations that cause dangling objects. For example, a &quot;dangling blob&quot; may arise because you did a &lt;code&gt;git add&lt;/code&gt; of a file, but then, before you actually committed it and made it part of the bigger picture, you changed something else in that file and committed that &lt;strong&gt;updated&lt;/strong&gt; thing&amp;mdash;​the old state that you added originally ends up not being pointed to by any commit or tree, so it&amp;rsquo;s now a dangling blob object.</source>
          <target state="translated">还有其他情况会导致物体悬空。例如，由于您对文件进行 &lt;code&gt;git add&lt;/code&gt; ，可能会出现&amp;ldquo;悬空的斑点&amp;rdquo; ，但是，在实际提交该文件并将其作为大图的一部分之前，您更改了该文件中的其他内容并提交了&lt;strong&gt;更新的内容&lt;/strong&gt; -最初添加的旧状态最终没有被任何提交或树指向，因此现在是一个悬空的Blob对象。</target>
        </trans-unit>
        <trans-unit id="232088d916b340ecad3098c72c2ebccbe30b76e5" translate="yes" xml:space="preserve">
          <source>There are also several operations which should be avoided entirely, as they will make the patch impossible to apply:</source>
          <target state="translated">此外,还有几种操作也应完全避免,因为它们会使补丁无法应用。</target>
        </trans-unit>
        <trans-unit id="eeb0752be9462c9bd2e54575f2023419e06b3d3b" translate="yes" xml:space="preserve">
          <source>There are also ways to automate the bisecting process if you have a test script that can tell a good from a bad commit. See &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; for more information about this and other &lt;code&gt;git
bisect&lt;/code&gt; features.</source>
          <target state="translated">如果您的测试脚本可以从错误的提交中分辨出好消息，那么还有其他方法可以自动执行平分过程。有关此功能和其他 &lt;code&gt;git bisect&lt;/code&gt; 功能的更多信息，请参见&lt;a href=&quot;git-bisect&quot;&gt;git-bisect [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="753d0dde7d0dbacd496fb113e3e96e5ea6d9494d" translate="yes" xml:space="preserve">
          <source>There are four different types of objects: &quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;, and &quot;tag&quot;.</source>
          <target state="translated">有四种不同类型的对象。&quot;blob&quot;,&quot;树&quot;,&quot;提交 &quot;和 &quot;标签&quot;。</target>
        </trans-unit>
        <trans-unit id="a3d0232ce28c94288cf502f722ca216e09b8c5b1" translate="yes" xml:space="preserve">
          <source>There are implementations of Git that do not leave usable values in some fields (e.g. JGit); by excluding these fields from the comparison, the &lt;code&gt;minimal&lt;/code&gt; mode may help interoperability when the same repository is used by these other systems at the same time.</source>
          <target state="translated">有一些Git的实现并没有在某些领域（例如JGit）中留下可用的值。通过从比较中排除这些字段， &lt;code&gt;minimal&lt;/code&gt; 模式可以帮助当其他系统同时使用同一存储库时的互操作性。</target>
        </trans-unit>
        <trans-unit id="ac26d523869587e187089ca0cfe8dfa88bde0428" translate="yes" xml:space="preserve">
          <source>There are many more; see the &quot;SPECIFYING REVISIONS&quot; section of the &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; man page for the complete list of ways to name revisions. Some examples:</source>
          <target state="translated">还有更多；有关命名修订的完整方法列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;手册页的&amp;ldquo; SPECIFYING REVISIONS&amp;rdquo;部分。一些例子：</target>
        </trans-unit>
        <trans-unit id="caa64d4f477bb9cc6ae8b8763c8d93ec4bfb0cef" translate="yes" xml:space="preserve">
          <source>There are no facilities for helping users find what unwanted crud they should delete, which means they are much more likely to have incomplete or partial cleanups that sometimes result in confusion and people wasting time trying to understand. (For example, folks tend to just look for big files to delete instead of big directories or extensions, and once they do so, then sometime later folks using the new repository who are going through history will notice a build artifact directory that has some files but not others, or a cache of dependencies (node_modules or similar) which couldn&amp;rsquo;t have ever been functional since it&amp;rsquo;s missing some files.)</source>
          <target state="translated">没有任何工具可以帮助用户找到应该删除的多余杂物，这意味着他们很可能会进行不完全或部分清理，有时会造成混乱，导致人们浪费时间去理解。（例如，人们倾向于只查找要删除的大文件，而不是大目录或扩展名，一旦这样做，那么以后使用新存储库的人们会在历史记录中看到一个构建工件目录，其中包含一些文件但不是其他，或者是依赖项的缓存（node_modules或类似的东西），因为丢失了一些文件，这些缓存本来无法发挥作用。）</target>
        </trans-unit>
        <trans-unit id="ce4a9f9a1026ea763732ff998a2bcfb7b60f26ca" translate="yes" xml:space="preserve">
          <source>There are no public Trace2 data structures.</source>
          <target state="translated">没有公共的Trace2数据结构。</target>
        </trans-unit>
        <trans-unit id="5a1dbdef2a9d4fcde2fec24ad984bfc7ec6f3aa2" translate="yes" xml:space="preserve">
          <source>There are numerous other tools, such as StGit, which exist for the purpose of maintaining a patch series. These are outside of the scope of this manual.</source>
          <target state="translated">还有许多其他的工具,比如StGit,它们是为了维护补丁系列而存在的。这些都不在本手册的范围之内。</target>
        </trans-unit>
        <trans-unit id="306721e74c73edf4b4a1c2554be600724c25d3f0" translate="yes" xml:space="preserve">
          <source>There are other estimates saying that 80% of the cost related to software is about maintenance &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">还有其他估计表明与软件相关的成本中有80％与维护有关&lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7eccee0caa41472aded0ea349d3d3fa4831b32ab" translate="yes" xml:space="preserve">
          <source>There are other real-world examples of using update and post-update hooks found in the Documentation/howto directory.</source>
          <target state="translated">在Documentation/howto目录下还有其他使用更新和更新后钩子的实际例子。</target>
        </trans-unit>
        <trans-unit id="ddc4304f0c733f93eaa36c71971b210be6c86baa" translate="yes" xml:space="preserve">
          <source>There are several built-in formats, and you can define additional formats by setting a pretty.&amp;lt;name&amp;gt; config option to either another format name, or a &lt;code&gt;format:&lt;/code&gt; string, as described below (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Here are the details of the built-in formats:</source>
          <target state="translated">内置的格式有几种，您可以通过将pretty。&amp;lt;name&amp;gt; config选项设置为另一个格式名称或 &lt;code&gt;format:&lt;/code&gt; string 来定义其他格式，如下所述（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。以下是内置格式的详细信息：</target>
        </trans-unit>
        <trans-unit id="172e083c83bf7e6cbde177805c61722f6bdc0777" translate="yes" xml:space="preserve">
          <source>There are some numbers about bugs in general, like a NIST study in 2002 &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt; that said:</source>
          <target state="translated">一般而言，关于错误的数字很多，例如2002年的NIST研究&lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt;说：</target>
        </trans-unit>
        <trans-unit id="1a73feb2f257a54073e6e874ef78ceeefd47d29e" translate="yes" xml:space="preserve">
          <source>There are some subtle differences how the backends behave.</source>
          <target state="translated">后台的表现有一些微妙的差异。</target>
        </trans-unit>
        <trans-unit id="a41ebe77f2eb54fbd4f30714a2e14c8c1d436ea0" translate="yes" xml:space="preserve">
          <source>There are three commands with similar names: &lt;code&gt;git reset&lt;/code&gt;, &lt;code&gt;git restore&lt;/code&gt; and &lt;code&gt;git revert&lt;/code&gt;.</source>
          <target state="translated">有三个名称相似的命令： &lt;code&gt;git reset&lt;/code&gt; ， &lt;code&gt;git restore&lt;/code&gt; 和 &lt;code&gt;git revert&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27e17ed315eeb27fa67bd10d3870c4d2deb8a92d" translate="yes" xml:space="preserve">
          <source>There are three different approaches: use an add-on to turn off line wraps, configure Thunderbird to not mangle patches, or use an external editor to keep Thunderbird from mangling the patches.</source>
          <target state="translated">有三种不同的方法:使用插件关闭行包装,配置Thunderbird不乱打补丁,或者使用外部编辑器来防止Thunderbird乱打补丁。</target>
        </trans-unit>
        <trans-unit id="8c553f5839a8296a42918c5ea6f6a2fcca19fa49" translate="yes" xml:space="preserve">
          <source>There are three main tools that can be used for this:</source>
          <target state="translated">主要有三个工具可以使用。</target>
        </trans-unit>
        <trans-unit id="86e24f426735724adb9ab7ea59c461905251e8e9" translate="yes" xml:space="preserve">
          <source>There are three ways to specify which refs to update on the remote end.</source>
          <target state="translated">有三种方法可以指定在远程端更新哪些refs。</target>
        </trans-unit>
        <trans-unit id="5544b2d42620b4375dbc730230171fe04b9f972b" translate="yes" xml:space="preserve">
          <source>There are two different types of capabilities: normal capabilities, which can be used to convey information or alter the behavior of a request, and commands, which are the core actions that a client wants to perform (fetch, push, etc).</source>
          <target state="translated">能力有两种不同的类型:普通能力和命令,前者可以用来传递信息或改变请求的行为,后者是客户端要执行的核心操作(获取、推送等)。</target>
        </trans-unit>
        <trans-unit id="c2015c03c4c8786233c499c7815e06c17100a16b" translate="yes" xml:space="preserve">
          <source>There are two formats accepted for patch files:</source>
          <target state="translated">补丁文件有两种格式可接受。</target>
        </trans-unit>
        <trans-unit id="9b5e9b84c7e0cf0cc62bfad7ffc7f5a42847bbc1" translate="yes" xml:space="preserve">
          <source>There are two kinds of fixes, discussed in the following subsections:</source>
          <target state="translated">有两种修复方式,在下面的小节中讨论。</target>
        </trans-unit>
        <trans-unit id="afe3df249e404830655fd820b0b8e96397ac9183" translate="yes" xml:space="preserve">
          <source>There are two main tools that can be used to include changes from one branch on another: &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; and &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;.</source>
          <target state="translated">有两个主要工具可用于包括从一个分支到另一个分支的更改：&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;和&lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1432c9def859812f2dcccb492cbe2b422538cffb" translate="yes" xml:space="preserve">
          <source>There are two ways to specify which commits to operate on.</source>
          <target state="translated">有两种方法可以指定对哪些提交进行操作。</target>
        </trans-unit>
        <trans-unit id="04a6eae6f43fc050171fa2270096884eaba0fee3" translate="yes" xml:space="preserve">
          <source>There is a difference between listing multiple &amp;lt;refspec&amp;gt; directly on &lt;em&gt;git pull&lt;/em&gt; command line and having multiple &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; entries in your configuration for a &amp;lt;repository&amp;gt; and running a &lt;em&gt;git pull&lt;/em&gt; command without any explicit &amp;lt;refspec&amp;gt; parameters. &amp;lt;refspec&amp;gt;s listed explicitly on the command line are always merged into the current branch after fetching. In other words, if you list more than one remote ref, &lt;em&gt;git pull&lt;/em&gt; will create an Octopus merge. On the other hand, if you do not list any explicit &amp;lt;refspec&amp;gt; parameter on the command line, &lt;em&gt;git pull&lt;/em&gt; will fetch all the &amp;lt;refspec&amp;gt;s it finds in the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; configuration and merge only the first &amp;lt;refspec&amp;gt; found into the current branch. This is because making an Octopus from remote refs is rarely done, while keeping track of multiple remote heads in one-go by fetching more than one is often useful.</source>
          <target state="translated">直接在&lt;em&gt;git pull&lt;/em&gt;命令行上列出多个&amp;lt; &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; &amp;gt;和在配置中为&amp;lt;repository&amp;gt;获取多个remote。&amp;lt;repository&amp;gt; .fetch条目，以及运行不带任何显式&amp;lt;refspec&amp;gt;参数的&lt;em&gt;git pull&lt;/em&gt;命令之间有区别。在命令行中明确列出的&amp;lt;refspec&amp;gt;总是在获取后合并到当前分支中。换句话说，如果您列出多个远程引用，则&lt;em&gt;git pull&lt;/em&gt;将创建一个八达通合并。另一方面，如果未在命令行上列出任何显式的&amp;lt;refspec&amp;gt;参数，则&lt;em&gt;git pull&lt;/em&gt;将获取在 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 找到的所有&amp;lt; refspec&amp;gt;。&amp;lt;repository&amp;gt; .fetch配置并仅将找到的第一个&amp;lt;refspec&amp;gt;合并到当前分支中。这是因为很少用远程引用来制作章鱼，而通过获取多个来一次跟踪多个远程头通常是有用的。</target>
        </trans-unit>
        <trans-unit id="08d27e369ae02f07111163548604defe0fd7ba02" translate="yes" xml:space="preserve">
          <source>There is a fourth official branch that is used slightly differently:</source>
          <target state="translated">还有第四个官科,使用方法略有不同。</target>
        </trans-unit>
        <trans-unit id="3ab0818052937d36eff9b5a2767bc99b339b1151" translate="yes" xml:space="preserve">
          <source>There is a script in contrib/thunderbird-patch-inline which can help you include patches with Thunderbird in an easy way. To use it, do the steps above and then use the script as the external editor.</source>
          <target state="translated">在 contrib/thunderbird-patch-inline 中有一个脚本,它可以帮助你以一种简单的方式加入 Thunderbird 的补丁。要使用它,请执行上面的步骤,然后使用该脚本作为外部编辑器。</target>
        </trans-unit>
        <trans-unit id="1232149fc68bcd969b013f8dcdb8f804dc24a0d6" translate="yes" xml:space="preserve">
          <source>There is a tradeoff of course: merges require a more careful branch management. The following subsections discuss the important points.</source>
          <target state="translated">当然有一个权衡:合并需要更细致的分支机构管理。以下各小节将讨论重要的几点。</target>
        </trans-unit>
        <trans-unit id="dad64266cc32a47cdf74ec10317455f91f86159c" translate="yes" xml:space="preserve">
          <source>There is already a project called BBChop created by Ealdwulf Wuffinga on Github that does something like that using Bayesian Search Theory &lt;a href=&quot;#9&quot;&gt;[9]&lt;/a&gt;:</source>
          <target state="translated">Ealdwulf Wuffinga在Github上已经有一个名为BBChop的项目，该项目使用贝叶斯搜索理论&lt;a href=&quot;#9&quot;&gt;[9]进行&lt;/a&gt;类似的操作：</target>
        </trans-unit>
        <trans-unit id="72c8cb7314c2d9e687a4188f4607320887a3abaf" translate="yes" xml:space="preserve">
          <source>There is also a deprecated &lt;code&gt;[section.subsection]&lt;/code&gt; syntax. With this syntax, the subsection name is converted to lower-case and is also compared case sensitively. These subsection names follow the same restrictions as section names.</source>
          <target state="translated">还有不推荐使用的 &lt;code&gt;[section.subsection]&lt;/code&gt; 语法。使用此语法，小节名称将转换为小写，并且还会区分大小写进行比较。这些小节名称遵循与节名称相同的限制。</target>
        </trans-unit>
        <trans-unit id="562a7aac41f0a6a2b8bd94c80ba1df49ae8c2861" translate="yes" xml:space="preserve">
          <source>There is also an alternate -z format recommended for machine parsing. In that format, the status field is the same, but some other things change. First, the &lt;code&gt;-&amp;gt;&lt;/code&gt; is omitted from rename entries and the field order is reversed (e.g &lt;code&gt;from -&amp;gt; to&lt;/code&gt; becomes &lt;code&gt;to from&lt;/code&gt;). Second, a NUL (ASCII 0) follows each filename, replacing space as a field separator and the terminating newline (but a space still separates the status field from the first filename). Third, filenames containing special characters are not specially formatted; no quoting or backslash-escaping is performed.</source>
          <target state="translated">建议使用另一种-z格式进行机器解析。在这种格式下，状态字段是相同的，但其他一些内容会发生变化。首先，在重命名条目中省略了 &lt;code&gt;-&amp;gt;&lt;/code&gt; ，并且字段顺序相反（例如， &lt;code&gt;from -&amp;gt; to&lt;/code&gt; 变为 &lt;code&gt;to from&lt;/code&gt; ）。其次，每个文件名后面都有一个NUL（ASCII 0），用空格代替字段分隔符和结尾的换行符（但空格仍将状态字段与第一个文件名分隔开）。第三，包含特殊字符的文件名不是特殊格式的。不执行引号或反斜杠转义。</target>
        </trans-unit>
        <trans-unit id="23b53316aea0dd64f8f21ea0eae539235bf45a74" translate="yes" xml:space="preserve">
          <source>There is also an option to sort by versions, this can be done by using the fieldname &lt;code&gt;version:refname&lt;/code&gt; or its alias &lt;code&gt;v:refname&lt;/code&gt;.</source>
          <target state="translated">还有一个按版本排序的选项，可以通过使用字段名 &lt;code&gt;version:refname&lt;/code&gt; 或其别名 &lt;code&gt;v:refname&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="490f0c7223e032436f3ed74187899d6766a21bb5" translate="yes" xml:space="preserve">
          <source>There is another common situation where you may encounter non-fast-forward rejection when you try to push, and it is possible even when you are pushing into a repository nobody else pushes into. After you push commit A yourself (in the first picture in this section), replace it with &quot;git commit --amend&quot; to produce commit B, and you try to push it out, because forgot that you have pushed A out already. In such a case, and only if you are certain that nobody in the meantime fetched your earlier commit A (and started building on top of it), you can run &quot;git push --force&quot; to overwrite it. In other words, &quot;git push --force&quot; is a method reserved for a case where you do mean to lose history.</source>
          <target state="translated">还有一种常见的情况是,当你尝试推送时,可能会遇到非快进式的拒绝,即使是你推送到一个没有人推送的仓库里,也有可能出现这种情况。你自己推送了提交A后(本节第一张图),用 &quot;git commit --amend &quot;替换成提交B,然后你想推送出去,因为忘了你已经推送了A。在这种情况下,只有当你确定在此期间没有人取走你之前的提交A(并在它的基础上开始构建),你可以运行 &quot;git push --force &quot;来覆盖它。换句话说,&quot;git push --force &quot;是一种保留给您确实要丢失历史记录的情况的方法。</target>
        </trans-unit>
        <trans-unit id="8a8fda27a5ab0014e2c03663c10e41e5858f14f1" translate="yes" xml:space="preserve">
          <source>There is another simplification mode available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76938def2c927fda8d1c815e17291d57380d4a8a" translate="yes" xml:space="preserve">
          <source>There is another tweak in the bisection algorithm that has not been described in the &quot;bisection algorithm&quot; above.</source>
          <target state="translated">在二分法算法中还有一个调整,上面的 &quot;二分法算法 &quot;中没有介绍。</target>
        </trans-unit>
        <trans-unit id="6cd697be600e420b39bb68cc6d967c4ceca70af4" translate="yes" xml:space="preserve">
          <source>There is no option for &lt;code&gt;git rm&lt;/code&gt; to remove from the index only the paths that have disappeared from the filesystem. However, depending on the use case, there are several ways that can be done.</source>
          <target state="translated">没有为没有选项 &lt;code&gt;git rm&lt;/code&gt; 从索引中只有那些从文件系统中消失的路径删除。但是，根据使用情况，有几种方法可以完成。</target>
        </trans-unit>
        <trans-unit id="60bcaa98facce6fa9b4916fcb4556840549eaf70" translate="yes" xml:space="preserve">
          <source>There is no other restriction on the replaced and replacement objects. Merge commits can be replaced by non-merge commits and vice versa.</source>
          <target state="translated">对被替换和替换对象没有其他限制。合并提交可以被非合并提交所取代,反之亦然。</target>
        </trans-unit>
        <trans-unit id="5b920fe2651a1acef3f4de11b5f87d418bf37e32" translate="yes" xml:space="preserve">
          <source>There is now a new commit &lt;code&gt;e&lt;/code&gt;, but it is referenced only by &lt;code&gt;HEAD&lt;/code&gt;. We can of course add yet another commit in this state:</source>
          <target state="translated">现在有一个新的提交 &lt;code&gt;e&lt;/code&gt; ，但仅由 &lt;code&gt;HEAD&lt;/code&gt; 引用。我们当然可以在这种状态下添加另一个提交：</target>
        </trans-unit>
        <trans-unit id="e84a3494173a3e4e1765afc114a7bb8588db5e4e" translate="yes" xml:space="preserve">
          <source>There is one special case not mentioned above, which is treated differently. Normally, a merge results in a merge commit, with two parents, one pointing at each of the two lines of development that were merged.</source>
          <target state="translated">有一种特殊的情况上面没有提到,它的处理方式是不同的。通常情况下,合并的结果是一个合并提交,有两个父节点,一个指向被合并的两条开发线。</target>
        </trans-unit>
        <trans-unit id="9c233ac02212216497063926a3cd425b73c1b106" translate="yes" xml:space="preserve">
          <source>There may be other problems when using &lt;code&gt;git rev-list&lt;/code&gt; related to pending objects.</source>
          <target state="translated">使用与待处理对象相关的 &lt;code&gt;git rev-list&lt;/code&gt; 时，可能还会有其他问题。</target>
        </trans-unit>
        <trans-unit id="3cc97d3b58e95d007d294ed252208117b7ea36ad" translate="yes" xml:space="preserve">
          <source>There was a discussion at one point on the linux kernel mailing list of whether it was ok to always ask end user to bisect, and very good points were made to support the point of view that it is ok.</source>
          <target state="translated">在linux内核邮件列表上曾经讨论过是否可以总是要求终端用户进行二分法,并且提出了非常好的观点,支持这样做的观点。</target>
        </trans-unit>
        <trans-unit id="e31f2056d77b9761665b1e39804c963e7c7e3f73" translate="yes" xml:space="preserve">
          <source>Therefore if the refspec for the remote includes e.g. &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt;, or you manually run e.g. &lt;code&gt;git fetch
--prune &amp;lt;name&amp;gt; &quot;refs/tags/*:refs/tags/*&quot;&lt;/code&gt; it won&amp;rsquo;t be stale remote tracking branches that are deleted, but any local tag that doesn&amp;rsquo;t exist on the remote.</source>
          <target state="translated">因此，如果远程的refspec包括例如 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; ，或者您手动运行例如 &lt;code&gt;git fetch --prune &amp;lt;name&amp;gt; &quot;refs/tags/*:refs/tags/*&quot;&lt;/code&gt; 它将不会过期的远程跟踪分支将被删除，但是远程上不存在的任何本地标记。</target>
        </trans-unit>
        <trans-unit id="22e33781a4f63d74c967572b3d2d5742f6f5b3cf" translate="yes" xml:space="preserve">
          <source>These are applied in sequence. The set of filepairs &lt;code&gt;git diff-*&lt;/code&gt; commands find are used as the input to diffcore-break, and the output from diffcore-break is used as the input to the next transformation. The final result is then passed to the output routine and generates either diff-raw format (see Output format sections of the manual for &lt;code&gt;git diff-*&lt;/code&gt; commands) or diff-patch format.</source>
          <target state="translated">这些按顺序应用。找到的文件对 &lt;code&gt;git diff-*&lt;/code&gt; 命令集用作diffcore-break的输入，而diffcore-break的输出用作下一个转换的输入。然后将最终结果传递到输出例程，并生成diff-raw格式（有关 &lt;code&gt;git diff-*&lt;/code&gt; 命令，请参见手册的&amp;ldquo;输出格式&amp;rdquo;部分）或diff-patch格式。</target>
        </trans-unit>
        <trans-unit id="5e4c5d2d8cb413a7bc102a12d4b32266eb5dffbd" translate="yes" xml:space="preserve">
          <source>These are concerned with describing the specific Git command after the command line, config, and environment are inspected. e.g: &lt;code&gt;void trace2_cmd_name(const char *name)&lt;/code&gt;, &lt;code&gt;void trace2_cmd_mode(const char *mode)&lt;/code&gt;.</source>
          <target state="translated">这些与检查命令行，配置和环境之后描述特定的Git命令有关。例如： &lt;code&gt;void trace2_cmd_name(const char *name)&lt;/code&gt; ， &lt;code&gt;void trace2_cmd_mode(const char *mode)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd918e1aed68e545e545890a5d457bd39124acbb" translate="yes" xml:space="preserve">
          <source>These are concerned with recording performance data over regions or spans of code. e.g: &lt;code&gt;void trace2_region_enter(const char *category, const char *label, const struct repository *repo)&lt;/code&gt;.</source>
          <target state="translated">这些与在代码的区域或跨度上记录性能数据有关。例如： &lt;code&gt;void trace2_region_enter(const char *category, const char *label, const struct repository *repo)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10ea7c6e4b3ea51596f6b19ba236a57b5e812041" translate="yes" xml:space="preserve">
          <source>These are concerned with the lifetime of the overall git process. e.g: &lt;code&gt;void trace2_initialize_clock()&lt;/code&gt;, &lt;code&gt;void trace2_initialize()&lt;/code&gt;, &lt;code&gt;int trace2_is_enabled()&lt;/code&gt;, &lt;code&gt;void trace2_cmd_start(int argc, const char **argv)&lt;/code&gt;.</source>
          <target state="translated">这些与整个git过程的生命周期有关。例如： &lt;code&gt;void trace2_initialize_clock()&lt;/code&gt; ， &lt;code&gt;void trace2_initialize()&lt;/code&gt; ， &lt;code&gt;int trace2_is_enabled()&lt;/code&gt; ， &lt;code&gt;void trace2_cmd_start(int argc, const char **argv)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3dce3473c941e3b3b27a31ac8449a2f1991a75d0" translate="yes" xml:space="preserve">
          <source>These are concerned with the various spawned child processes, including shell scripts, git commands, editors, pagers, and hooks.</source>
          <target state="translated">这些涉及到各种产卵的子进程,包括shell脚本、git命令、编辑器、分页器和钩子。</target>
        </trans-unit>
        <trans-unit id="64d6caf87f558c78a882445d71ea9cd47be32d78" translate="yes" xml:space="preserve">
          <source>These are internal helper commands used by other commands; end users typically do not use them directly.</source>
          <target state="translated">这些都是其他命令使用的内部辅助命令,最终用户一般不会直接使用它们。</target>
        </trans-unit>
        <trans-unit id="14e40973cf60a547a4fee511ff95c4f84a31a06f" translate="yes" xml:space="preserve">
          <source>These are only used with the &lt;code&gt;dcommit&lt;/code&gt; and &lt;code&gt;rebase&lt;/code&gt; commands.</source>
          <target state="translated">这些仅与 &lt;code&gt;dcommit&lt;/code&gt; 和 &lt;code&gt;rebase&lt;/code&gt; 命令一起使用。</target>
        </trans-unit>
        <trans-unit id="1f4226446a769c76931ca392e2a09f31777b3654" translate="yes" xml:space="preserve">
          <source>These are optional command-line options for init. Each of these flags can point to a relative repository path (--tags=project/tags) or a full url (--tags=https://foo.org/project/tags). You can specify more than one --tags and/or --branches options, in case your Subversion repository places tags or branches under multiple paths. The option --stdlayout is a shorthand way of setting trunk,tags,branches as the relative paths, which is the Subversion default. If any of the other options are given as well, they take precedence.</source>
          <target state="translated">这些都是init的可选命令行选项,它们可以指向相对仓库路径(-tags=project/tags)或完整的url(-tags=)。每一个标志都可以指向一个相对的版本库路径 (--tags=project/tags)或一个完整的 URL (--tagshttps://foo.org/project/tags)。你可以指定多个 --tags 和/或 --branches 选项,以防你的 Subversion 仓库将标签或分支放在多个路径下。选项 --stdlayout 是将 trunk,tags,branches 设置为相对路径的速记方式,这是 Subversion 的默认值。如果同时给出了其他选项,则它们优先。</target>
        </trans-unit>
        <trans-unit id="ef89fe03d8c6b725e4e01a5ddca75169500d3912" translate="yes" xml:space="preserve">
          <source>These attributes affect how the contents stored in the repository are copied to the working tree files when commands such as &lt;code&gt;git switch&lt;/code&gt;, &lt;code&gt;git checkout&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; run. They also affect how Git stores the contents you prepare in the working tree in the repository upon &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">当运行诸如 &lt;code&gt;git switch&lt;/code&gt; ， &lt;code&gt;git checkout&lt;/code&gt; 和 &lt;code&gt;git merge&lt;/code&gt; 之类的命令时，这些属性影响存储在存储库中的内容如何复制到工作树文件中。它们还会影响 &lt;code&gt;git add&lt;/code&gt; 和 &lt;code&gt;git commit&lt;/code&gt; 时Git如何将您准备的内容存储在存储库中的工作树中。</target>
        </trans-unit>
        <trans-unit id="1e36f59cc4fba5296689c97860f8ef3c808cbf54" translate="yes" xml:space="preserve">
          <source>These can be easily kept up to date using &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;可以很容易地使它们保持最新状态。</target>
        </trans-unit>
        <trans-unit id="d8f5a662d30248028e58618a9cb324b38272bbd8" translate="yes" xml:space="preserve">
          <source>These commands all compare two sets of things; what is compared differs:</source>
          <target state="translated">这些命令都是比较两组事物,比较的内容不同。</target>
        </trans-unit>
        <trans-unit id="6e07bfec6529e0e8049d6a168dde51eb0ed55268" translate="yes" xml:space="preserve">
          <source>These commands are to interact with foreign SCM and with other people via patch over e-mail.</source>
          <target state="translated">这些命令是通过电子邮件与国外SCM以及通过补丁与其他人员进行交互。</target>
        </trans-unit>
        <trans-unit id="008c5282b165f202ade67dc870d3522a81a841bd" translate="yes" xml:space="preserve">
          <source>These configuration variables control &lt;code&gt;internal&lt;/code&gt; gitweb behavior.</source>
          <target state="translated">这些配置变量控制 &lt;code&gt;internal&lt;/code&gt; gitweb行为。</target>
        </trans-unit>
        <trans-unit id="94d243826a65ff43f06f691e3b2f877746c8e3a7" translate="yes" xml:space="preserve">
          <source>These configurations enable two things. First, each unix user (&lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt;) of the server will be able to browse through gitweb Git repositories found in &lt;code&gt;~/public_git/&lt;/code&gt; with the following url:</source>
          <target state="translated">这些配置启用两件事。首先，服务器的每个unix用户（ &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; ）都可以使用以下URL 浏览 &lt;code&gt;~/public_git/&lt;/code&gt; gitweb Git存储库：</target>
        </trans-unit>
        <trans-unit id="3c188c162ef90ed4e72b2204b53fd7bbdf63ed82" translate="yes" xml:space="preserve">
          <source>These environment variables apply to &lt;code&gt;all&lt;/code&gt; core Git commands. Nb: it is worth noting that they may be used/overridden by SCMS sitting above Git so take care if using a foreign front-end.</source>
          <target state="translated">这些环境变量适用于 &lt;code&gt;all&lt;/code&gt; 核心Git命令。Nb：值得注意的是，位于Git上方的SCMS可能会使用/覆盖它们，因此，如果使用国外前端，请当心。</target>
        </trans-unit>
        <trans-unit id="e4a9928c908043039dae5cc89a184941db222aba" translate="yes" xml:space="preserve">
          <source>These exclude patterns come from these places, in order:</source>
          <target state="translated">这些排除模式来自于这些地方,依次。</target>
        </trans-unit>
        <trans-unit id="75ad982aca6a7add80092ae27820348741497d7e" translate="yes" xml:space="preserve">
          <source>These flag are passed to the &lt;code&gt;git apply&lt;/code&gt; program (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) that applies the patch.</source>
          <target state="translated">这些标志传递给 &lt;code&gt;git apply&lt;/code&gt; 补丁的git apply程序（请参阅&lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a66ecfa5cef3d43b11b6332452dde3bc34998a82" translate="yes" xml:space="preserve">
          <source>These flags are passed to &lt;code&gt;git am&lt;/code&gt; to easily change the dates of the rebased commits (see &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;).</source>
          <target state="translated">这些标志传递给 &lt;code&gt;git am&lt;/code&gt; ,以轻松更改重新基于基础的提交的日期（请参见&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6f1d3498209d5426cb1c8295c9947466ac12cab4" translate="yes" xml:space="preserve">
          <source>These flags are passed to the &lt;code&gt;git apply&lt;/code&gt; (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) program that applies the patch.</source>
          <target state="translated">这些标志传递给 &lt;code&gt;git apply&lt;/code&gt; 补丁的git apply（请参阅&lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt;）程序。</target>
        </trans-unit>
        <trans-unit id="17c5d825c714d7f669df648adc8ffa3b9865aa3a" translate="yes" xml:space="preserve">
          <source>These forms reset the index entries for all paths that match the &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; to their state at &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;. (It does not affect the working tree or the current branch.)</source>
          <target state="translated">这些格式将与 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 匹配的所有路径的索引条目重置为其在 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 的状态。（它不会影响工作树或当前分支。）</target>
        </trans-unit>
        <trans-unit id="84dfe82e69639d7dd0490e18b4061edc5e5f61bb" translate="yes" xml:space="preserve">
          <source>These general best practices are very helpful if you bisect often.</source>
          <target state="translated">这些一般的最佳实践是非常有用的,如果你经常两败俱伤。</target>
        </trans-unit>
        <trans-unit id="db63350c8a27af092cfd256119dcf34d87e7125f" translate="yes" xml:space="preserve">
          <source>These instructions use the &lt;code&gt;git-cvsimport&lt;/code&gt; script which ships with git, but other importers may provide better results. See the note in &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport[1]&lt;/a&gt; for other options.</source>
          <target state="translated">这些说明使用 &lt;code&gt;git-cvsimport&lt;/code&gt; 附带的git-cvsimport脚本，但其他导入程序可能会提供更好的结果。有关其他选项，请参见&lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport [1]中&lt;/a&gt;的注释。</target>
        </trans-unit>
        <trans-unit id="4de4cd9ec9920076e498bf4f8c01b7cc0e7335b0" translate="yes" xml:space="preserve">
          <source>These messages are concerned with Git thread usage.</source>
          <target state="translated">这些信息与Git线程的使用有关。</target>
        </trans-unit>
        <trans-unit id="b8e5bd243ffdab655773f15dbcfc0554b819902f" translate="yes" xml:space="preserve">
          <source>These options are deprecated. Use the above --notes/--no-notes options instead.</source>
          <target state="translated">这些选项已经过时。</target>
        </trans-unit>
        <trans-unit id="894173daf027c82b1254f620d2cbbddacd04b7fd" translate="yes" xml:space="preserve">
          <source>These options are ignored for historical reasons.</source>
          <target state="translated">由于历史原因,这些选项被忽略了。</target>
        </trans-unit>
        <trans-unit id="0608f735748e7710136ac2ca4b1a8fc7f8d0f8a8" translate="yes" xml:space="preserve">
          <source>These options are mostly targeted for packing of Git repositories.</source>
          <target state="translated">这些选项主要针对 Git 仓库的打包。</target>
        </trans-unit>
        <trans-unit id="44fc7c2eb5b5d3f683db2d8973767b7defab9c76" translate="yes" xml:space="preserve">
          <source>These options are passed to &lt;a href=&quot;git-send-pack&quot;&gt;git-send-pack[1]&lt;/a&gt;. A thin transfer significantly reduces the amount of sent data when the sender and receiver share many of the same objects in common. The default is &lt;code&gt;--thin&lt;/code&gt;.</source>
          <target state="translated">这些选项被传递给&lt;a href=&quot;git-send-pack&quot;&gt;git-send-pack [1]&lt;/a&gt;。当发送方和接收方共享许多相同的对象时，精简传输会大大减少发送的数据量。默认值为 &lt;code&gt;--thin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38ddfaeebf99ab2e211259f05e2350cca6be519d" translate="yes" xml:space="preserve">
          <source>These options are primarily useful when converting a repository from one hash algorithm to another; without them, fast-import will fail if it encounters a submodule because it has no way of writing the object ID into the new hash algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c86ff6978b6c3146e6796c4f36abf160da0176d" translate="yes" xml:space="preserve">
          <source>These options can be used in an initial &lt;code&gt;clone&lt;/code&gt;, along with the &lt;code&gt;sync&lt;/code&gt; options described above.</source>
          <target state="translated">这些选项可以与上述 &lt;code&gt;sync&lt;/code&gt; 选项一起用于初始 &lt;code&gt;clone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ade32a888d52a4ba127b2e5cb51121d4b067e67" translate="yes" xml:space="preserve">
          <source>These options can be used in the initial &lt;code&gt;clone&lt;/code&gt; as well as in subsequent &lt;code&gt;sync&lt;/code&gt; operations.</source>
          <target state="translated">这些选项可用于初始 &lt;code&gt;clone&lt;/code&gt; 以及后续的 &lt;code&gt;sync&lt;/code&gt; 操作中。</target>
        </trans-unit>
        <trans-unit id="3f45787718e6c314237aec0cf2c5e63156df92c4" translate="yes" xml:space="preserve">
          <source>These options can be used to modify &lt;code&gt;git p4 rebase&lt;/code&gt; behavior.</source>
          <target state="translated">这些选项可用于修改 &lt;code&gt;git p4 rebase&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="046bf3cadb648529c8cbf517d3ba66246fc697fc" translate="yes" xml:space="preserve">
          <source>These options can be used to modify &lt;code&gt;git p4 submit&lt;/code&gt; behavior.</source>
          <target state="translated">这些选项可用于修改 &lt;code&gt;git p4 submit&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="5bf9264c3d2f29d27aed45b38db366aee6362601" translate="yes" xml:space="preserve">
          <source>These options control layout (defaults to &lt;code&gt;column&lt;/code&gt;). Setting any of these implies &lt;code&gt;always&lt;/code&gt; if none of &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;, or &lt;code&gt;auto&lt;/code&gt; are specified.</source>
          <target state="translated">这些选项控制布局（默认为 &lt;code&gt;column&lt;/code&gt; ）。如果 &lt;code&gt;never&lt;/code&gt; 指定 &lt;code&gt;always&lt;/code&gt; ，never或 &lt;code&gt;auto&lt;/code&gt; 的任何一项，则设置其中的任何一项表示 &lt;code&gt;always&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="510a1cbefb424a60db8479a49dd55a0966d6d945" translate="yes" xml:space="preserve">
          <source>These options control when the feature should be enabled (defaults to &lt;code&gt;never&lt;/code&gt;):</source>
          <target state="translated">这些选项控制何时应启用该功能（默认为 &lt;code&gt;never&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="931e215644554fa9404627a014bfd3cf51399ea5" translate="yes" xml:space="preserve">
          <source>These options take effect whatever the value of the &lt;code&gt;core.splitIndex&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">无论 &lt;code&gt;core.splitIndex&lt;/code&gt; 配置变量的值如何，这些选项都会生效（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。但是，当更改与配置值不符时，会发出警告，因为配置值将在下次读取索引时生效，这将删除该选项的预期效果。</target>
        </trans-unit>
        <trans-unit id="932e8c22c29966222600cac9510425979eeabd1c" translate="yes" xml:space="preserve">
          <source>These options take effect whatever the value of the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">无论 &lt;code&gt;core.untrackedCache&lt;/code&gt; 配置变量的值如何，这些选项都会生效（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。但是，当更改与配置值不符时，会发出警告，因为配置值将在下次读取索引时生效，这将删除该选项的预期效果。</target>
        </trans-unit>
        <trans-unit id="ff7024be4fc3bd9a63ff1aab42e5c2f33080a5ad" translate="yes" xml:space="preserve">
          <source>These parameters can also be set individually with &lt;code&gt;--stat-width=&amp;lt;width&amp;gt;&lt;/code&gt;, &lt;code&gt;--stat-name-width=&amp;lt;name-width&amp;gt;&lt;/code&gt; and &lt;code&gt;--stat-count=&amp;lt;count&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这些参数也可以分别使用 &lt;code&gt;--stat-width=&amp;lt;width&amp;gt;&lt;/code&gt; ，-- &lt;code&gt;--stat-name-width=&amp;lt;name-width&amp;gt;&lt;/code&gt; 和 &lt;code&gt;--stat-count=&amp;lt;count&amp;gt;&lt;/code&gt; 进行设置。</target>
        </trans-unit>
        <trans-unit id="25d97f197e2ad468ea791c831ca2e71054c4e207" translate="yes" xml:space="preserve">
          <source>These remote-tracking references can be deleted as a one-off with either of:</source>
          <target state="translated">这些远程跟踪参考资料可以通过以下两种方式一次性删除:</target>
        </trans-unit>
        <trans-unit id="4994737bcfd88cfa54486bc85e99d5152416b798" translate="yes" xml:space="preserve">
          <source>These rules make it easy for shell script based tools to parse reference names, pathname expansion by the shell when a reference name is used unquoted (by mistake), and also avoid ambiguities in certain reference name expressions (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;):</source>
          <target state="translated">这些规则使基于Shell脚本的工具可以轻松解析引用名称，在引用名称不加引号的情况下（错误地）由外壳扩展路径名，还可以避免某些引用名称表达式中的歧义（请参阅&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="d2d3b8bc5c27c38dddb2f7c9e54b52668c820483" translate="yes" xml:space="preserve">
          <source>These services can be enabled/disabled using the per-repository configuration file:</source>
          <target state="translated">这些服务可以使用每个存储库的配置文件来启用/禁用。</target>
        </trans-unit>
        <trans-unit id="11be9ffec744e4c727f505822229118ed50ca097" translate="yes" xml:space="preserve">
          <source>These services can be globally enabled/disabled using the command-line options of this command. If finer-grained control is desired (e.g. to allow &lt;code&gt;git archive&lt;/code&gt; to be run against only in a few selected repositories the daemon serves), the per-repository configuration file can be used to enable or disable them.</source>
          <target state="translated">可以使用此命令的命令行选项全局启用/禁用这些服务。如果需要更细粒度的控制（例如，仅允许在守护程序所服务的几个选定存储库中运行 &lt;code&gt;git archive&lt;/code&gt; ），则可以使用每个存储库配置文件来启用或禁用它们。</target>
        </trans-unit>
        <trans-unit id="6e7a1043f71fa1813c0b5e398e97710f483944d9" translate="yes" xml:space="preserve">
          <source>These things may exist in a Git repository.</source>
          <target state="translated">这些东西可能存在于Git仓库中。</target>
        </trans-unit>
        <trans-unit id="b5c7f688db050c92cfc9bb2aa9d676e52849ec7b" translate="yes" xml:space="preserve">
          <source>These three branches all forked from a common commit, [master], whose commit message is &quot;Add 'git show-branch'&quot;. The &quot;fixes&quot; branch adds one commit &quot;Introduce &quot;reset type&quot; flag to &quot;git reset&quot;&quot;. The &quot;mhf&quot; branch adds many other commits. The current branch is &quot;master&quot;.</source>
          <target state="translated">这三个分支都是从一个共同的提交[master]分叉出来的,其提交信息是 &quot;添加'git show-branch'&quot;。fixes &quot;分支增加了一个提交 &quot;在 &quot;git reset &quot;中引入 &quot;reset type &quot;标志&quot;。mhf &quot;分支增加了许多其他提交。目前的分支是 &quot;master&quot;。</target>
        </trans-unit>
        <trans-unit id="c6204a9318b7a0526e46b8696b2eb378d52ecf11" translate="yes" xml:space="preserve">
          <source>These two filters behave differently, and by default, a filter is taken as the former, massaging the contents into more convenient shape. A missing filter driver definition in the config, or a filter driver that exits with a non-zero status, is not an error but makes the filter a no-op passthru.</source>
          <target state="translated">这两种过滤器的行为是不同的,默认情况下,过滤器被当作前者,将内容按摩成更方便的形状。如果配置中缺少过滤器驱动定义,或者过滤器驱动退出时状态为非零,都不是错误,而是使过滤器成为无操作的通病。</target>
        </trans-unit>
        <trans-unit id="e20e46dc24b79b5218925e423850545226b0898e" translate="yes" xml:space="preserve">
          <source>These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within --window to see if using delta compression saves space. --depth limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.</source>
          <target state="translated">这两个选项会影响如何使用 delta 压缩来存储包中的对象。这些对象首先在内部按类型、大小和可选的名称进行排序,并与 --window 中的其他对象进行比较,以确定使用 delta 压缩是否能节省空间。--depth 限制了最大的 delta 深度;太深会影响解包器的性能,因为 delta 数据需要被应用那么多次才能到达所需的对象。</target>
        </trans-unit>
        <trans-unit id="de212a952b72f4cd05af023bbd056fa8307c4a9f" translate="yes" xml:space="preserve">
          <source>These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within &lt;code&gt;--window&lt;/code&gt; to see if using delta compression saves space. &lt;code&gt;--depth&lt;/code&gt; limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.</source>
          <target state="translated">这两个选项影响使用增量压缩存储包中包含的对象的方式。这些对象首先在内部按类型，大小和可选的名称进行排序，然后与 &lt;code&gt;--window&lt;/code&gt; 中的其他对象进行比较，以查看是否使用增量压缩节省了空间。 &lt;code&gt;--depth&lt;/code&gt; 限制最大增量深度；将其设置得过深会影响解包器方面的性能，因为需要多次应用增量数据才能到达必需的对象。</target>
        </trans-unit>
        <trans-unit id="6a0bfaec1ca5ad5a0f6710f22f7b4b78eecfef67" translate="yes" xml:space="preserve">
          <source>These two syntaxes are mostly equivalent, except the former implies --local option.</source>
          <target state="translated">这两种语法大部分是等价的,只是前者意味着--local选项。</target>
        </trans-unit>
        <trans-unit id="9270307e15adf00d482cdebd8e068750f310bc87" translate="yes" xml:space="preserve">
          <source>These two syntaxes are mostly equivalent, except when cloning, when the former implies --local option. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; for details.</source>
          <target state="translated">除了克隆时（前者暗示--local选项）外，这两种语法几乎都是等效的。有关详细信息，请参见&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="469e074d32a553c54f69af6603803ffbfd2e6dda" translate="yes" xml:space="preserve">
          <source>These types of entries are generally created as a result of using &lt;code&gt;git
commit --amend&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt; and are the commits prior to the amend or rebase occurring. Since these changes are not part of the current project most users will want to expire them sooner, which is why the default is more aggressive than &lt;code&gt;gc.reflogExpire&lt;/code&gt;.</source>
          <target state="translated">这些类型的条目通常是由于使用 &lt;code&gt;git commit --amend&lt;/code&gt; 或 &lt;code&gt;git rebase&lt;/code&gt; 而创建的，它们是在进行amend或rebase之前的提交。由于这些更改不是当前项目的一部分，因此大多数用户希望它们尽快过期，这就是为什么默认值比 &lt;code&gt;gc.reflogExpire&lt;/code&gt; 更具侵略性的原因。</target>
        </trans-unit>
        <trans-unit id="99a10a0726ee032ba80815c05eceb6d5a6ab2aa8" translate="yes" xml:space="preserve">
          <source>These variables control various optional help messages designed to aid new users. All &lt;code&gt;advice.*&lt;/code&gt; variables default to &lt;code&gt;true&lt;/code&gt;, and you can tell Git that you do not need help by setting these to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">这些变量控制旨在帮助新用户的各种可选帮助消息。所有 &lt;code&gt;advice.*&lt;/code&gt; 变量默认为 &lt;code&gt;true&lt;/code&gt; ，可以通过将它们设置为 &lt;code&gt;false&lt;/code&gt; 来告诉Git不需要帮助：</target>
        </trans-unit>
        <trans-unit id="289bbff1e27f0cf157d5208bbfcb9f369ecc1504" translate="yes" xml:space="preserve">
          <source>These variables obviate the need for command-line options in some circumstances, allowing easier restricted usage through git-shell.</source>
          <target state="translated">在某些情况下,这些变量不需要命令行选项,可以通过 git-shell 更容易地限制使用。</target>
        </trans-unit>
        <trans-unit id="48d5c4b33cae3d35014b5a5e266ea897c2a18c9f" translate="yes" xml:space="preserve">
          <source>These will display all commits which exist only on HEAD or on MERGE_HEAD, and which touch an unmerged file.</source>
          <target state="translated">这些将显示所有只存在于 HEAD 或 MERGE_HEAD 上的提交,以及触及未合并文件的提交。</target>
        </trans-unit>
        <trans-unit id="e9ab0d9bdf3f35b7d6ece2d3bc65f4fbb38bad38" translate="yes" xml:space="preserve">
          <source>They are both passed directly to &lt;code&gt;git diff-tree&lt;/code&gt;; see &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt; for more information.</source>
          <target state="translated">它们都直接传递给 &lt;code&gt;git diff-tree&lt;/code&gt; ；有关更多信息，请参见&lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afa16f632fa562fed5a34ad41431101aacb568d7" translate="yes" xml:space="preserve">
          <source>They can include slash &lt;code&gt;/&lt;/code&gt; for hierarchical (directory) grouping, but no slash-separated component can begin with a dot &lt;code&gt;.&lt;/code&gt; or end with the sequence &lt;code&gt;.lock&lt;/code&gt;.</source>
          <target state="translated">它们可以包括斜杠 &lt;code&gt;/&lt;/code&gt; 用于层次结构（目录）分组，但是斜杠分隔的组件不能以点开头 &lt;code&gt;.&lt;/code&gt; 或以序列 &lt;code&gt;.lock&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="48a933f433abac80f2e0e41b240081f7a399893c" translate="yes" xml:space="preserve">
          <source>They cannot be the single character &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">它们不能是单个字符 &lt;code&gt;@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c798a840110b095cd0c31cb10cad16c17f5292dd" translate="yes" xml:space="preserve">
          <source>They cannot begin or end with a slash &lt;code&gt;/&lt;/code&gt; or contain multiple consecutive slashes (see the &lt;code&gt;--normalize&lt;/code&gt; option below for an exception to this rule)</source>
          <target state="translated">它们不能以斜杠开头或结尾 &lt;code&gt;/&lt;/code&gt; 或包含多个连续的斜杠（有关此规则的例外，请参阅下面的 &lt;code&gt;--normalize&lt;/code&gt; 选项）</target>
        </trans-unit>
        <trans-unit id="794c847c2b033448497ba9e6f46f59b7325ccd69" translate="yes" xml:space="preserve">
          <source>They cannot contain a &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">它们不能包含 &lt;code&gt;\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4cf89d0a711867dbdfa498e7e6b80fb04c020f3" translate="yes" xml:space="preserve">
          <source>They cannot contain a sequence &lt;code&gt;@{&lt;/code&gt;.</source>
          <target state="translated">它们不能包含序列 &lt;code&gt;@{&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c781dcfcbfa7c545717cc72f3f25ac7fba039fd7" translate="yes" xml:space="preserve">
          <source>They cannot end with a dot &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">它们不能以点结尾 &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdf3c698f8591838633d63d5550c41009f5d53bb" translate="yes" xml:space="preserve">
          <source>They cannot have ASCII control characters (i.e. bytes whose values are lower than \040, or \177 &lt;code&gt;DEL&lt;/code&gt;), space, tilde &lt;code&gt;~&lt;/code&gt;, caret &lt;code&gt;^&lt;/code&gt;, or colon &lt;code&gt;:&lt;/code&gt; anywhere.</source>
          <target state="translated">它们不能具有ASCII控制字符（即，值小于\ 040或\ 177 &lt;code&gt;DEL&lt;/code&gt; 的字节），空格，代字号 &lt;code&gt;~&lt;/code&gt; ，插入号 &lt;code&gt;^&lt;/code&gt; 或冒号 &lt;code&gt;:&lt;/code&gt; 任何地方。</target>
        </trans-unit>
        <trans-unit id="9fa9a35ba99f055f59e5fb0fc3903845af8141d1" translate="yes" xml:space="preserve">
          <source>They cannot have question-mark &lt;code&gt;?&lt;/code&gt;, asterisk &lt;code&gt;*&lt;/code&gt;, or open bracket &lt;code&gt;[&lt;/code&gt; anywhere. See the &lt;code&gt;--refspec-pattern&lt;/code&gt; option below for an exception to this rule.</source>
          <target state="translated">他们不能有问号 &lt;code&gt;?&lt;/code&gt; ，星号 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;[&lt;/code&gt; 在任何位置打开括号[ 有关此规则的例外，请参见下面的 &lt;code&gt;--refspec-pattern&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="07233de88d34b821d099ea14e09099281360fa3d" translate="yes" xml:space="preserve">
          <source>They cannot have two consecutive dots &lt;code&gt;..&lt;/code&gt; anywhere.</source>
          <target state="translated">他们不能有两个连续的点 &lt;code&gt;..&lt;/code&gt; 任何地方。</target>
        </trans-unit>
        <trans-unit id="08cc7b3818b658e36c5e9a0a0fcefabb2c9bd5ce" translate="yes" xml:space="preserve">
          <source>They must contain at least one &lt;code&gt;/&lt;/code&gt;. This enforces the presence of a category like &lt;code&gt;heads/&lt;/code&gt;, &lt;code&gt;tags/&lt;/code&gt; etc. but the actual names are not restricted. If the &lt;code&gt;--allow-onelevel&lt;/code&gt; option is used, this rule is waived.</source>
          <target state="translated">它们必须包含至少一个 &lt;code&gt;/&lt;/code&gt; 。这会强制出现诸如 &lt;code&gt;heads/&lt;/code&gt; ， &lt;code&gt;tags/&lt;/code&gt; 等之类的类别，但实际名称不受限制。如果使用 &lt;code&gt;--allow-onelevel&lt;/code&gt; 选项，则将放弃此规则。</target>
        </trans-unit>
        <trans-unit id="9c66e1086c1b783565f285e9f8d345796e4a920b" translate="yes" xml:space="preserve">
          <source>Things get more complicated if the &lt;code&gt;subsystem&lt;/code&gt; changes do not exactly correspond to the ones before the rebase.</source>
          <target state="translated">如果 &lt;code&gt;subsystem&lt;/code&gt; 更改与重新设置之前的更改不完全对应，则事情会变得更加复杂。</target>
        </trans-unit>
        <trans-unit id="877bd5e347693a4c90610529b809f198ae203a8a" translate="yes" xml:space="preserve">
          <source>Think about how to create a clear chapter dependency graph that will allow people to get to important topics without necessarily reading everything in between.</source>
          <target state="translated">思考如何创建一个清晰的章节依赖图,让人们能够进入重要的主题,而不一定要阅读中间的所有内容。</target>
        </trans-unit>
        <trans-unit id="5f03012af2a22f62503c31e1e064eb23ddd2be46" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;key&lt;/code&gt; will be used instead of &amp;lt;token&amp;gt; in the trailer. At the end of this key, a separator can appear and then some space characters. By default the only valid separator is &lt;code&gt;:&lt;/code&gt;, but this can be changed using the &lt;code&gt;trailer.separators&lt;/code&gt; config variable.</source>
          <target state="translated">该 &lt;code&gt;key&lt;/code&gt; 将代替预告片中的&amp;lt;token&amp;gt;使用。在此键的末尾，可能会出现分隔符，然后出现一些空格字符。默认情况下，唯一有效的分隔符是 &lt;code&gt;:&lt;/code&gt; ，但是可以使用 &lt;code&gt;trailer.separators&lt;/code&gt; 配置变量进行更改。</target>
        </trans-unit>
        <trans-unit id="9ed9ef222233001104259cd6ab7e0ea2e028dedb" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;merge&lt;/code&gt; can also be done by &lt;code&gt;pulling from her own remote-tracking branch&lt;/code&gt;, like this:</source>
          <target state="translated">这个 &lt;code&gt;merge&lt;/code&gt; 也可以通过进行 &lt;code&gt;pulling from her own remote-tracking branch&lt;/code&gt; ，就像这样：</target>
        </trans-unit>
        <trans-unit id="0007248c88629a35b9fa8e1cf4c8fdf299191526" translate="yes" xml:space="preserve">
          <source>This accepts all options that &lt;code&gt;git svn fetch&lt;/code&gt; and &lt;code&gt;git rebase&lt;/code&gt; accept. However, &lt;code&gt;--fetch-all&lt;/code&gt; only fetches from the current [svn-remote], and not all [svn-remote] definitions.</source>
          <target state="translated">这将接受 &lt;code&gt;git svn fetch&lt;/code&gt; 和 &lt;code&gt;git rebase&lt;/code&gt; 接受的所有选项。但是，-- &lt;code&gt;--fetch-all&lt;/code&gt; 仅从当前的[svn-remote]定义中获取，而不是从所有的[svn-remote]定义获取。</target>
        </trans-unit>
        <trans-unit id="c118365ba0290d763b2d4e635fbfbb09d23e73e6" translate="yes" xml:space="preserve">
          <source>This action is disabled by default for performance reasons.</source>
          <target state="translated">由于性能原因,该操作默认为禁用。</target>
        </trans-unit>
        <trans-unit id="692de83ae64c152ace96a6b22c40c6c7b5256f5f" translate="yes" xml:space="preserve">
          <source>This adds a link titled &quot;graphiclog&quot; after the &quot;summary&quot; link, leading to &lt;code&gt;git-browser&lt;/code&gt; script, passing &lt;code&gt;r=&amp;lt;project&amp;gt;&lt;/code&gt; as a query parameter.</source>
          <target state="translated">这将在&amp;ldquo;摘要&amp;rdquo;链接之后添加一个名为&amp;ldquo; graphiclog&amp;rdquo;的链接，从而导致 &lt;code&gt;git-browser&lt;/code&gt; 脚本，并传递 &lt;code&gt;r=&amp;lt;project&amp;gt;&lt;/code&gt; 作为查询参数。</target>
        </trans-unit>
        <trans-unit id="9647e1f610a9d28b74cedc3ffa625f5d98628ec8" translate="yes" xml:space="preserve">
          <source>This algorithm extends the patience algorithm to &quot;support low-occurrence common elements&quot;.</source>
          <target state="translated">该算法将耐心算法扩展为 &quot;支持低发生率的共同元素&quot;。</target>
        </trans-unit>
        <trans-unit id="5f9e4d22cfa1bc9f924abb0f51a443db2655b318" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;git svn&lt;/code&gt; to re-map repository URLs and UUIDs from mirrors created using SVN::Mirror (or svk) for metadata.</source>
          <target state="translated">这允许 &lt;code&gt;git svn&lt;/code&gt; 从使用SVN :: Mirror（或svk）为元数据创建的镜像中重新映射存储库URL和UUID。</target>
        </trans-unit>
        <trans-unit id="cb552885bcd7df779f362e35a229c9d935657c60" translate="yes" xml:space="preserve">
          <source>This allows one to specify a Perl regular expression that will cause skipping of all matching paths from checkout from SVN. The &lt;code&gt;--ignore-paths&lt;/code&gt; option should match for every &lt;code&gt;fetch&lt;/code&gt; (including automatic fetches due to &lt;code&gt;clone&lt;/code&gt;, &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, etc) on a given repository.</source>
          <target state="translated">这允许您指定一个Perl正则表达式，该表达式将导致从SVN检出中跳过所有匹配的路径。所述 &lt;code&gt;--ignore-paths&lt;/code&gt; 选项应匹配每 &lt;code&gt;fetch&lt;/code&gt; （包括自动取由于 &lt;code&gt;clone&lt;/code&gt; ， &lt;code&gt;dcommit&lt;/code&gt; ， &lt;code&gt;rebase&lt;/code&gt; 在给定储存库等）。</target>
        </trans-unit>
        <trans-unit id="bf5d12ceb1111e8b06bd58f3985472091a1cae12" translate="yes" xml:space="preserve">
          <source>This allows one to specify a Perl regular expression that will cause the inclusion of only matching paths from checkout from SVN. The &lt;code&gt;--include-paths&lt;/code&gt; option should match for every &lt;code&gt;fetch&lt;/code&gt; (including automatic fetches due to &lt;code&gt;clone&lt;/code&gt;, &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, etc) on a given repository. &lt;code&gt;--ignore-paths&lt;/code&gt; takes precedence over &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">这允许指定一个Perl正则表达式，该正则表达式将导致仅包含来自SVN的检出的匹配路径。所述 &lt;code&gt;--include-paths&lt;/code&gt; 选项应匹配每 &lt;code&gt;fetch&lt;/code&gt; （包括自动取由于 &lt;code&gt;clone&lt;/code&gt; ， &lt;code&gt;dcommit&lt;/code&gt; ， &lt;code&gt;rebase&lt;/code&gt; 在给定储存库等）。 &lt;code&gt;--ignore-paths&lt;/code&gt; 优先于 &lt;code&gt;--include-paths&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c68f089f9144bc4bdc1d710532bfa75a569d11ed" translate="yes" xml:space="preserve">
          <source>This allows one to specify a prefix which is prepended to the names of remotes if trunk/branches/tags are specified. The prefix does not automatically include a trailing slash, so be sure you include one in the argument if that is what you want. If --branches/-b is specified, the prefix must include a trailing slash. Setting a prefix (with a trailing slash) is strongly encouraged in any case, as your SVN-tracking refs will then be located at &quot;refs/remotes/$prefix/&lt;strong&gt;&quot;, which is compatible with Git&amp;rsquo;s own remote-tracking ref layout (refs/remotes/$remote/&lt;/strong&gt;). Setting a prefix is also useful if you wish to track multiple projects that share a common repository. By default, the prefix is set to &lt;code&gt;origin/&lt;/code&gt;.</source>
          <target state="translated">如果指定了中继线/分支/标签，则允许指定一个前缀，该前缀在遥控器的名称之前。前缀不会自动包含尾部斜杠，因此，如果需要，请确保在参数中包括一个斜杠。如果指定了--branches / -b，则前缀必须包含尾部斜杠。在任何情况下都强烈建议设置前缀（带有斜杠），因为这样您的SVN跟踪引用将位于&amp;ldquo; refs / remotes / $ prefix / &lt;strong&gt;&amp;rdquo;，这与Git自己的远程跟踪引用布局兼容（refs / remotes / $ remote /&lt;/strong&gt;）。如果您希望跟踪共享一个公共存储库的多个项目，则设置前缀也很有用。默认情况下，前缀设置为 &lt;code&gt;origin/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99b10fdeae941de841a9ac73e39b7c06fcc2d978" translate="yes" xml:space="preserve">
          <source>This allows revision ranges for partial/cauterized history to be supported. $NUMBER, $NUMBER1:$NUMBER2 (numeric ranges), $NUMBER:HEAD, and BASE:$NUMBER are all supported.</source>
          <target state="translated">这允许支持部分/固化历史的修订范围。$NUMBER、$NUMBER1:$NUMBER2(数字范围)、$NUMBER:HEAD和BASE:$NUMBER都支持。</target>
        </trans-unit>
        <trans-unit id="f18b167effc162d347deb782b83eab22ac73f014" translate="yes" xml:space="preserve">
          <source>This allows users to create repositories from alternate URLs. For example, an administrator could run &lt;code&gt;git svn&lt;/code&gt; on the server locally (accessing via file://) but wish to distribute the repository with a public http:// or svn:// URL in the metadata so users of it will see the public URL.</source>
          <target state="translated">这允许用户从备用URL创建存储库。例如，管理员可以在本地服务器上运行 &lt;code&gt;git svn&lt;/code&gt; （通过file：//访问），但希望在元数据中使用公共http：//或svn：// URL分发存储库，以便其用户可以看到公开网址。</target>
        </trans-unit>
        <trans-unit id="86c4c002dbb35b192dee2247feadc27722ad842a" translate="yes" xml:space="preserve">
          <source>This application is a CVS emulation layer for Git.</source>
          <target state="translated">这个应用是Git的CVS仿真层。</target>
        </trans-unit>
        <trans-unit id="8feea1468fa1fae814e84f89aca492fad30e5da4" translate="yes" xml:space="preserve">
          <source>This applies modifications from a hot-fix branch before each test run, e.g. in case your build or test environment changed so that older revisions may need a fix which newer ones have already. (Make sure the hot-fix branch is based off a commit which is contained in all revisions which you are bisecting, so that the merge does not pull in too much, or use &lt;code&gt;git cherry-pick&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt;.)</source>
          <target state="translated">这会在每次测试运行之前应用来自修补程序分支的修改，例如，如果您的构建或测试环境发生了更改，以便较旧的修订可能需要较新的修订已经具有的修复。（请确保热修复程序分支基于您要二等分的所有修订中包含的提交，以便合并不会引入过多内容，或者使用 &lt;code&gt;git cherry-pick&lt;/code&gt; 而不是 &lt;code&gt;git merge&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="889d1277201779cf18582f69129975a9bf60d357" translate="yes" xml:space="preserve">
          <source>This applies to files added to the source branch &lt;strong&gt;after&lt;/strong&gt; a daughter branch was created: if previously no commit was made on the daughter branch they will erroneously be added to the daughter branch in git.</source>
          <target state="translated">这适用于在创建子分支&lt;strong&gt;之后&lt;/strong&gt;添加到源分支的文件：如果以前未在子分支上进行任何提交，则它们将被错误地添加到git中的子分支中。</target>
        </trans-unit>
        <trans-unit id="cd519f993fc33ca56b2cb882b0ae5ba8b983012d" translate="yes" xml:space="preserve">
          <source>This argument will not be passed to &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;. Instead it sets the vhost field in the git:// service request (to rest of the argument). Default is not to send vhost in such request (if sent).</source>
          <target state="translated">此参数不会传递给 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 。而是在git：//服务请求中设置vhost字段（其余参数）。默认设置是不发送此类请求中的虚拟主机（如果已发送）。</target>
        </trans-unit>
        <trans-unit id="9535ee34f2074fa8e689413e0518f1d3faf71e7d" translate="yes" xml:space="preserve">
          <source>This argument will not be passed to &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;. Instead, it will cause the helper to start by sending git:// service requests to the remote side with the service field set to an appropriate value and the repository field set to rest of the argument. Default is not to send such a request.</source>
          <target state="translated">此参数不会传递给 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 。取而代之的是，它将通过将git：//服务请求发送到远程端来启动帮助程序，其中service字段设置为适当的值，repository字段设置为参数的其余部分。默认为不发送此类请求。</target>
        </trans-unit>
        <trans-unit id="b50cd8ffcdc46b4b68ae7776a2b00f1d1183b6dd" translate="yes" xml:space="preserve">
          <source>This asks for all the history reachable from the given commit but not from any branch, tag, or other reference. If you decide it&amp;rsquo;s something you want, you can always create a new reference to it, e.g.,</source>
          <target state="translated">这要求从给定的提交（而不是从任何分支，标记或其他引用）获得的所有历史记录。如果您决定要这样做，则可以随时为其创建新的引用，例如，</target>
        </trans-unit>
        <trans-unit id="7efa4dea1c9da210003e0c08e382eb543f66cbf7" translate="yes" xml:space="preserve">
          <source>This attribute controls the length of conflict markers left in the work tree file during a conflicted merge. Only setting to the value to a positive integer has any meaningful effect.</source>
          <target state="translated">此属性控制冲突合并时工作树文件中留下的冲突标记的长度。只有将该值设置为正整数才有意义。</target>
        </trans-unit>
        <trans-unit id="4caef1788f338fb02906a32b34bfb366a7539a3a" translate="yes" xml:space="preserve">
          <source>This attribute enables and controls end-of-line normalization. When a text file is normalized, its line endings are converted to LF in the repository. To control what line ending style is used in the working directory, use the &lt;code&gt;eol&lt;/code&gt; attribute for a single file and the &lt;code&gt;core.eol&lt;/code&gt; configuration variable for all text files. Note that setting &lt;code&gt;core.autocrlf&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;input&lt;/code&gt; overrides &lt;code&gt;core.eol&lt;/code&gt; (see the definitions of those options in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">此属性启用并控制行尾规范化。对文本文件进行规范化后，其行尾将在存储库中转换为LF。要控制工作目录中使用哪种行尾样式，请对单个文件使用 &lt;code&gt;eol&lt;/code&gt; 属性，对所有文本文件使用 &lt;code&gt;core.eol&lt;/code&gt; 配置变量。请注意，将 &lt;code&gt;core.autocrlf&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;input&lt;/code&gt; 会覆盖 &lt;code&gt;core.eol&lt;/code&gt; （请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;中这些选项的定义）。</target>
        </trans-unit>
        <trans-unit id="9abb1dada669f4b282e87943eaa4c10d9676f824" translate="yes" xml:space="preserve">
          <source>This attribute sets a specific line-ending style to be used in the working directory. It enables end-of-line conversion without any content checks, effectively setting the &lt;code&gt;text&lt;/code&gt; attribute. Note that setting this attribute on paths which are in the index with CRLF line endings may make the paths to be considered dirty. Adding the path to the index again will normalize the line endings in the index.</source>
          <target state="translated">此属性设置在工作目录中使用的特定行尾样式。它无需任何内容检查即可进行行尾转换，从而有效地设置了 &lt;code&gt;text&lt;/code&gt; 属性。请注意，在带有CRLF行尾的索引中的路径上设置此属性可能会使该路径被视为脏路径。再次将路径添加到索引将规范索引中的行尾。</target>
        </trans-unit>
        <trans-unit id="a95f413f93d421b5f0b609911f7201baca2aa2de" translate="yes" xml:space="preserve">
          <source>This automatically updates the rev_map if needed (see &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; in the FILES section below for details).</source>
          <target state="translated">如果需要，这会自动更新rev_map（有关详细信息，请参见下面&amp;ldquo; FILES&amp;rdquo;部分中的 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="756e07e0622c048ffb322b306c002b3fe742a463" translate="yes" xml:space="preserve">
          <source>This behavior can be suppressed with the &lt;code&gt;--no-ff&lt;/code&gt; option.</source>
          <target state="translated">可以使用 &lt;code&gt;--no-ff&lt;/code&gt; 选项抑制此行为。</target>
        </trans-unit>
        <trans-unit id="8ad430bc747d1916521d538bf94c1847176c4231" translate="yes" xml:space="preserve">
          <source>This behavior is the default when the start point is a remote-tracking branch. Set the branch.autoSetupMerge configuration variable to &lt;code&gt;false&lt;/code&gt; if you want &lt;code&gt;git switch&lt;/code&gt;, &lt;code&gt;git checkout&lt;/code&gt; and &lt;code&gt;git branch&lt;/code&gt; to always behave as if &lt;code&gt;--no-track&lt;/code&gt; were given. Set it to &lt;code&gt;always&lt;/code&gt; if you want this behavior when the start-point is either a local or remote-tracking branch.</source>
          <target state="translated">当起点是远程跟踪分支时，此行为是默认行为。如果希望 &lt;code&gt;git switch&lt;/code&gt; ， &lt;code&gt;git checkout&lt;/code&gt; 和 &lt;code&gt;git branch&lt;/code&gt; 始终表现为 &lt;code&gt;--no-track&lt;/code&gt; ，则将branch.autoSetupMerge配置变量设置为 &lt;code&gt;false&lt;/code&gt; 。如果您希望在起始点是本地或远程跟踪分支时使用此行为，请将其设置为 &lt;code&gt;always&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02d843a8479501e1f56c84b63bc83f8438d9dc3a" translate="yes" xml:space="preserve">
          <source>This boolean config option controls whether the maintenance task with name &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt; is run when no &lt;code&gt;--task&lt;/code&gt; option is specified to &lt;code&gt;git maintenance run&lt;/code&gt;. These config values are ignored if a &lt;code&gt;--task&lt;/code&gt; option exists. By default, only &lt;code&gt;maintenance.gc.enabled&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e589ab09a449c7cf7000e50f249deca2b148281c" translate="yes" xml:space="preserve">
          <source>This boolean will enable &lt;code&gt;fsync()&lt;/code&gt; when writing object files.</source>
          <target state="translated">写入目标文件时，此布尔值将启用 &lt;code&gt;fsync()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a9d8bb8cd3e4996e1654fca8257ad2030d24d70" translate="yes" xml:space="preserve">
          <source>This breakage is of course most of the time unrelated to the breakage we are trying to locate in the commit graph. But it prevents us to know if the interesting &quot;bad behavior&quot; is present or not.</source>
          <target state="translated">当然,这种破绽大多数时候与我们试图在提交图中定位的破绽无关。但它让我们无法知道是否存在有趣的 &quot;坏行为&quot;。</target>
        </trans-unit>
        <trans-unit id="1a7656b1b8b17aa91ea330f8fbedd0a75097faed" translate="yes" xml:space="preserve">
          <source>This bug has also been shown to affect non-symlink cases of replacing a directory with a file when it comes to the internal structures of the untracked cache, but no case has been reported where this resulted in wrong &quot;git status&quot; output.</source>
          <target state="translated">当涉及到未跟踪缓存的内部结构时,这个bug也被证明会影响到用文件替换目录的非全链接情况,但还没有报告说这会导致错误的 &quot;git状态 &quot;输出。</target>
        </trans-unit>
        <trans-unit id="bbb14e9c1a32bd1658d34b41d317e78fe3e2cf7e" translate="yes" xml:space="preserve">
          <source>This cache is meant to speed up commands that involve determining untracked files such as &lt;code&gt;git status&lt;/code&gt;.</source>
          <target state="translated">此缓存旨在加快涉及确定未跟踪文件（例如 &lt;code&gt;git status&lt;/code&gt; )的命令的速度。</target>
        </trans-unit>
        <trans-unit id="5e9291bab46bd7ea7a2a21b7e8d51146482ff7a6" translate="yes" xml:space="preserve">
          <source>This calculates the same as &lt;code&gt;--bisect&lt;/code&gt;, except that refs in &lt;code&gt;refs/bisect/&lt;/code&gt; are not used, and except that this outputs text ready to be eval&amp;rsquo;ed by the shell. These lines will assign the name of the midpoint revision to the variable &lt;code&gt;bisect_rev&lt;/code&gt;, and the expected number of commits to be tested after &lt;code&gt;bisect_rev&lt;/code&gt; is tested to &lt;code&gt;bisect_nr&lt;/code&gt;, the expected number of commits to be tested if &lt;code&gt;bisect_rev&lt;/code&gt; turns out to be good to &lt;code&gt;bisect_good&lt;/code&gt;, the expected number of commits to be tested if &lt;code&gt;bisect_rev&lt;/code&gt; turns out to be bad to &lt;code&gt;bisect_bad&lt;/code&gt;, and the number of commits we are bisecting right now to &lt;code&gt;bisect_all&lt;/code&gt;.</source>
          <target state="translated">此计算与 &lt;code&gt;--bisect&lt;/code&gt; 相同，除了不使用 &lt;code&gt;refs/bisect/&lt;/code&gt; 中的ref，并且输出的文本准备好由shell评估之外。这些生产线将分配中点修订的变量名 &lt;code&gt;bisect_rev&lt;/code&gt; ，并承诺的预期数量进行测试后 &lt;code&gt;bisect_rev&lt;/code&gt; 进行测试，以 &lt;code&gt;bisect_nr&lt;/code&gt; ，进行测试提交的预期数量，如果 &lt;code&gt;bisect_rev&lt;/code&gt; 原来是很好的 &lt;code&gt;bisect_good&lt;/code&gt; 时，如果 &lt;code&gt;bisect_rev&lt;/code&gt; 对 &lt;code&gt;bisect_bad&lt;/code&gt; 不好的话，测试的期望提交数，我们现在正划分为 &lt;code&gt;bisect_all&lt;/code&gt; 的提交数。</target>
        </trans-unit>
        <trans-unit id="7d3cf717b036e3b0e81df34e24d7ea082a035f6a" translate="yes" xml:space="preserve">
          <source>This can allow you to make partial mirrors when running fetch; but is generally not recommended because history will be skipped and lost.</source>
          <target state="translated">这可以让你在运行fetch时制作部分镜像,但一般不建议使用,因为历史记录会被跳过并丢失。</target>
        </trans-unit>
        <trans-unit id="636e119b451b3bd7ccaf26b7d43733789f26ed19" translate="yes" xml:space="preserve">
          <source>This can also be set up as the default behaviour by using the &lt;code&gt;worktree.guessRemote&lt;/code&gt; config option.</source>
          <target state="translated">也可以使用 &lt;code&gt;worktree.guessRemote&lt;/code&gt; 配置选项将其设置为默认行为。</target>
        </trans-unit>
        <trans-unit id="fa409f68e80081ea9a669e9f13a5d077543254ef" translate="yes" xml:space="preserve">
          <source>This can be &lt;code&gt;end&lt;/code&gt;, which is the default, &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt; or &lt;code&gt;before&lt;/code&gt;.</source>
          <target state="translated">可以是 &lt;code&gt;end&lt;/code&gt; ，这是默认值， &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;after&lt;/code&gt; 或 &lt;code&gt;before&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0de02388f102cf8ff32d10ea0ea1542e4435ae39" translate="yes" xml:space="preserve">
          <source>This can be any options that the archiver backend understands. See next section.</source>
          <target state="translated">这可以是归档器后台理解的任何选项。见下一节。</target>
        </trans-unit>
        <trans-unit id="8ebe928ea2c46867d2d30a22aa44b6d209b60b27" translate="yes" xml:space="preserve">
          <source>This can be combined with the gitweb configuration:</source>
          <target state="translated">可以结合gitweb配置。</target>
        </trans-unit>
        <trans-unit id="3e2aafd0fe68d162abd0214f2c4dbcf97a317242" translate="yes" xml:space="preserve">
          <source>This can be enabled by default with the configuration option mailinfo.scissors.</source>
          <target state="translated">这可以通过配置选项mailinfo.scissors默认启用。</target>
        </trans-unit>
        <trans-unit id="90b17ef61d05f77323fefc823815f1b4d0ca5c24" translate="yes" xml:space="preserve">
          <source>This can be set to a comma-separated list of strings. When a curl trace is enabled (see &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; above), whenever a &quot;Cookies:&quot; header sent by the client is dumped, values of cookies whose key is in that list (case-sensitive) are redacted.</source>
          <target state="translated">可以将其设置为逗号分隔的字符串列表。启用卷曲跟踪时（请参见上面的 &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; ），每当转储客户端发送的&amp;ldquo; Cookies：&amp;rdquo;标头时，都会删除其键在该列表中（区分大小写）的cookie的值。</target>
        </trans-unit>
        <trans-unit id="3d49143ca76086473ec42d2280fe45285788984b" translate="yes" xml:space="preserve">
          <source>This can be used to color the metadata of a blame line depending on age of the line.</source>
          <target state="translated">这可以用来根据线的年龄对责备线的元数据进行着色。</target>
        </trans-unit>
        <trans-unit id="0f9fdab39f98d82a2bdc74c13a484288c9af48d4" translate="yes" xml:space="preserve">
          <source>This can be used to convert arguments to a command run in a subdirectory so that they can still be used after moving to the top-level of the repository. For example:</source>
          <target state="translated">这可以用来转换在子目录中运行的命令的参数,以便在移动到版本库的顶层后仍然可以使用。例如</target>
        </trans-unit>
        <trans-unit id="7c4f04c6d6345aed6141f4d5502d056991a7840c" translate="yes" xml:space="preserve">
          <source>This can be used when you want to include further changes to the merge, or want to write your own merge commit message.</source>
          <target state="translated">当你想对合并进行进一步的修改,或者想写自己的合并提交信息时,可以使用这个功能。</target>
        </trans-unit>
        <trans-unit id="14d1ead4268c0c0f3315fceadadaf2f291770d82" translate="yes" xml:space="preserve">
          <source>This can be used with the &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt; commands.</source>
          <target state="translated">可以与 &lt;code&gt;dcommit&lt;/code&gt; ， &lt;code&gt;rebase&lt;/code&gt; ， &lt;code&gt;branch&lt;/code&gt; 和 &lt;code&gt;tag&lt;/code&gt; 命令一起使用。</target>
        </trans-unit>
        <trans-unit id="9067f207a93cdcf6d90b3183367a4ae6097c31d6" translate="yes" xml:space="preserve">
          <source>This can be useful when you want to publish the tree from a commit without exposing its full history. You might want to do this to publish an open source branch of a project whose current tree is &quot;clean&quot;, but whose full history contains proprietary or otherwise encumbered bits of code.</source>
          <target state="translated">当你想在不暴露完整历史的情况下发布提交的代码树时,这个方法可能很有用。你可能想用这个方法来发布一个项目的开源分支,该分支当前的代码树是 &quot;干净的&quot;,但其完整的历史记录中包含了专有的或有其他限制的代码。</target>
        </trans-unit>
        <trans-unit id="4ddcbb1d5b5e22f922e078b6b0d84fe1dcc0409b" translate="yes" xml:space="preserve">
          <source>This can happen, for example, if you:</source>
          <target state="translated">这可能发生,例如,如果你。</target>
        </trans-unit>
        <trans-unit id="9140f80526c6eb06ff98ed4abf5c0d2e07067266" translate="yes" xml:space="preserve">
          <source>This can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities and is considered generally safe and fast.</source>
          <target state="translated">这只能使用3路合并算法解决两个头(即当前分支和你拉来的另一个分支)。它试图仔细检测交叉合并的歧义,被认为是一般安全和快速的。</target>
        </trans-unit>
        <trans-unit id="10679b433b60fbaff0452d6d903b314fee5164d2" translate="yes" xml:space="preserve">
          <source>This can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this can detect and handle merges involving renames, but currently cannot make use of detected copies. This is the default merge strategy when pulling or merging one branch.</source>
          <target state="translated">这只能用3路合并算法解决两个头。当有一个以上的共同祖先可以用于3-way合并时,它会创建一个共同祖先的合并树,并将其作为3-way合并的参考树。通过对 Linux 2.6 内核开发历史中的实际合并提交进行测试,发现这样做可以减少合并冲突,而不会造成错误合并。此外,它还可以检测和处理涉及重命名的合并,但目前还不能使用检测到的副本。这是拉取或合并一个分支时的默认合并策略。</target>
        </trans-unit>
        <trans-unit id="2cac39aeb86961e1363f7613dfed0033661ab943" translate="yes" xml:space="preserve">
          <source>This can speed up operations like &lt;code&gt;git diff&lt;/code&gt; and &lt;code&gt;git status&lt;/code&gt; especially on filesystems like NFS that have weak caching semantics and thus relatively high IO latencies. When enabled, Git will do the index comparison to the filesystem data in parallel, allowing overlapping IO&amp;rsquo;s. Defaults to true.</source>
          <target state="translated">这可以加快诸如 &lt;code&gt;git diff&lt;/code&gt; 和 &lt;code&gt;git status&lt;/code&gt; 之类的操作,尤其是在诸如NFS之类的文件系统上，这些系统具有较弱的缓存语义，因此具有相对较高的IO延迟。启用后，Git将并行对文件系统数据进行索引比较，从而允许重叠的IO。默认为true。</target>
        </trans-unit>
        <trans-unit id="9202266152fd1a0a2194149286bebd74fe30a95c" translate="yes" xml:space="preserve">
          <source>This capability can be advertised multiple times. The first applicable refspec takes precedence. The left-hand of refspecs advertised with this capability must cover all refs reported by the list command. If no &lt;code&gt;refspec&lt;/code&gt; capability is advertised, there is an implied &lt;code&gt;refspec *:*&lt;/code&gt;.</source>
          <target state="translated">此功能可以多次发布。第一个适用的refspec优先。用此功能发布的参考规范的左侧必须覆盖list命令报告的所有参考。如果没有发布 &lt;code&gt;refspec&lt;/code&gt; 功能，则暗示一个 &lt;code&gt;refspec *:*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="561397ab0857a5bada65e17ac4aabd661a6939b5" translate="yes" xml:space="preserve">
          <source>This chapter covers internal details of the Git implementation which probably only Git developers need to understand.</source>
          <target state="translated">本章涉及Git实现的内部细节,可能只有Git开发者才需要了解。</target>
        </trans-unit>
        <trans-unit id="9301665301f3e50c4417122a8411be226ea5b235" translate="yes" xml:space="preserve">
          <source>This command always gets all objects. Historically, there were three options &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-t&lt;/code&gt; for choosing which objects to download. They are now silently ignored.</source>
          <target state="translated">此命令始终获取所有对象。从历史上看，有三个选项 &lt;code&gt;-a&lt;/code&gt; ， &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;-t&lt;/code&gt; 用于选择要下载的对象。现在，它们被静默忽略。</target>
        </trans-unit>
        <trans-unit id="5b8a59dc9ca3a3d6f247d36df5fb54708fa69494" translate="yes" xml:space="preserve">
          <source>This command applies the patch but does not create a commit. Use &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; to create commits from patches generated by &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; and/or received by email.</source>
          <target state="translated">该命令应用补丁，但不创建提交。使用&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;从&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]生成&lt;/a&gt;和/或通过电子邮件收到的补丁中创建提交。</target>
        </trans-unit>
        <trans-unit id="1f849e1e7df08a5bb28860e4715d22e12f5d5d20" translate="yes" xml:space="preserve">
          <source>This command assists the developer in this process by recording conflicted automerge results and corresponding hand resolve results on the initial manual merge, and applying previously recorded hand resolutions to their corresponding automerge results.</source>
          <target state="translated">该命令协助开发人员在此过程中,在初始人工合并时记录冲突的自动合并结果和相应的手工解决结果,并将之前记录的手工解决结果应用到相应的自动合并结果中。</target>
        </trans-unit>
        <trans-unit id="b823d02fd766a4ae4b81090ce369454e7da568d6" translate="yes" xml:space="preserve">
          <source>This command caches credentials in memory for use by future Git programs. The stored credentials never touch the disk, and are forgotten after a configurable timeout. The cache is accessible over a Unix domain socket, restricted to the current user by filesystem permissions.</source>
          <target state="translated">这条命令会将凭证缓存在内存中,供未来的 Git 程序使用。存储的凭证永远不会接触磁盘,并在可配置的超时后被遗忘。缓存可以通过 Unix 域套接字访问,根据文件系统的权限限制当前用户使用。</target>
        </trans-unit>
        <trans-unit id="4784337d21599fe7fcfddcd79392d8470207170e" translate="yes" xml:space="preserve">
          <source>This command can be performed multiple times before a commit. It only adds the content of the specified file(s) at the time the add command is run; if you want subsequent changes included in the next commit, then you must run &lt;code&gt;git add&lt;/code&gt; again to add the new content to the index.</source>
          <target state="translated">提交前可以多次执行此命令。它仅在运行add命令时添加指定文件的内容；如果要在下一次提交中包含后续更改，则必须再次运行 &lt;code&gt;git add&lt;/code&gt; ，以将新内容添加到索引中。</target>
        </trans-unit>
        <trans-unit id="c286ab165ab2a31532b621372beb627366820ec4" translate="yes" xml:space="preserve">
          <source>This command can be used where a &lt;code&gt;filemodify&lt;/code&gt; directive can appear, allowing it to be used in the middle of a commit. For a &lt;code&gt;filemodify&lt;/code&gt; using an inline directive, it can also appear right before the &lt;code&gt;data&lt;/code&gt; directive.</source>
          <target state="translated">该命令可以在出现 &lt;code&gt;filemodify&lt;/code&gt; 指令的地方使用，从而可以在提交过程中使用它。对于使用内联指令的 &lt;code&gt;filemodify&lt;/code&gt; ，它也可以出现在 &lt;code&gt;data&lt;/code&gt; 指令之前。</target>
        </trans-unit>
        <trans-unit id="74e4352fd2289d447be4133ac0e6d68d162428a6" translate="yes" xml:space="preserve">
          <source>This command can run &lt;code&gt;applypatch-msg&lt;/code&gt;, &lt;code&gt;pre-applypatch&lt;/code&gt;, and &lt;code&gt;post-applypatch&lt;/code&gt; hooks. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">此命令可以运行 &lt;code&gt;applypatch-msg&lt;/code&gt; ， &lt;code&gt;pre-applypatch&lt;/code&gt; 和 &lt;code&gt;post-applypatch&lt;/code&gt; 挂钩。有关更多信息，请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e5610ce87e5d01d8f8246892b4f05f886b6ad5a" translate="yes" xml:space="preserve">
          <source>This command can run &lt;code&gt;commit-msg&lt;/code&gt;, &lt;code&gt;prepare-commit-msg&lt;/code&gt;, &lt;code&gt;pre-commit&lt;/code&gt;, &lt;code&gt;post-commit&lt;/code&gt; and &lt;code&gt;post-rewrite&lt;/code&gt; hooks. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">该命令可以运行 &lt;code&gt;commit-msg&lt;/code&gt; ， &lt;code&gt;prepare-commit-msg&lt;/code&gt; ， &lt;code&gt;pre-commit&lt;/code&gt; ， &lt;code&gt;post-commit&lt;/code&gt; 和 &lt;code&gt;post-rewrite&lt;/code&gt; 挂钩。有关更多信息，请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ba8d48bf258fdf0b61e4a3a7667022fd45b3e45" translate="yes" xml:space="preserve">
          <source>This command creates an empty Git repository - basically a &lt;code&gt;.git&lt;/code&gt; directory with subdirectories for &lt;code&gt;objects&lt;/code&gt;, &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, and template files. An initial &lt;code&gt;HEAD&lt;/code&gt; file that references the HEAD of the master branch is also created.</source>
          <target state="translated">此命令创建一个空的Git存储库-基本上是一个 &lt;code&gt;.git&lt;/code&gt; 目录，其中包含 &lt;code&gt;objects&lt;/code&gt; ， &lt;code&gt;refs/heads&lt;/code&gt; ， &lt;code&gt;refs/tags&lt;/code&gt; 和模板文件的子目录。还创建了引用master分支的HEAD 的初始 &lt;code&gt;HEAD&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="f52be87adec196973421cd7319ee0f98c1860983" translate="yes" xml:space="preserve">
          <source>This command degenerates to download everything to complete the asked refs from the remote side when the local side does not have a common ancestor commit.</source>
          <target state="translated">当本地端没有共同的祖先提交时,这个命令会退化到从远程端下载一切完成要求的refs。</target>
        </trans-unit>
        <trans-unit id="194b70091800ec19021441e8c1778ca9e02b53d5" translate="yes" xml:space="preserve">
          <source>This command ensures that the changes in the experimental branch are already in the current branch.</source>
          <target state="translated">该命令确保实验分支中的变化已经在当前分支中。</target>
        </trans-unit>
        <trans-unit id="1b788d383418fe8b134f7630991a2d6359c7dd7c" translate="yes" xml:space="preserve">
          <source>This command finds new changes in p4 and imports them as Git commits.</source>
          <target state="translated">这条命令可以找到 p4 中的新变化,并将其作为 Git 提交导入。</target>
        </trans-unit>
        <trans-unit id="4b11fc8efec3bd343a83e9f1aa4620a514b9ab8e" translate="yes" xml:space="preserve">
          <source>This command formats the lines of its standard input into a table with multiple columns. Each input line occupies one cell of the table. It is used internally by other git commands to format output into columns.</source>
          <target state="translated">该命令将其标准输入行格式化为一个多列的表格。每一行输入都占据了表格的一个单元格。它在内部被其他 git 命令用来将输出格式化为列。</target>
        </trans-unit>
        <trans-unit id="ade7fdc971ed1f0936fb8fbff7bb1574367ca37b" translate="yes" xml:space="preserve">
          <source>This command is extremely useful if the frontend does not know (or does not care to know) what files are currently on the branch, and therefore cannot generate the proper &lt;code&gt;filedelete&lt;/code&gt; commands to update the content.</source>
          <target state="translated">如果前端不知道（或不希望知道）分支上当前有哪些文件，因此无法生成正确的 &lt;code&gt;filedelete&lt;/code&gt; 命令来更新内容，则此命令非常有用。</target>
        </trans-unit>
        <trans-unit id="5f45dc9e63088b4d8e620891decbfdd6655de376" translate="yes" xml:space="preserve">
          <source>This command is intended mostly for internal use by scripts automatically invoking &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">该命令主要用于自动调用 &lt;code&gt;git merge&lt;/code&gt; 的脚本内部使用。</target>
        </trans-unit>
        <trans-unit id="3710225b15829bc8cbeb92895b81ff709286e645" translate="yes" xml:space="preserve">
          <source>This command is recursive by default.</source>
          <target state="translated">该命令默认是递归的。</target>
        </trans-unit>
        <trans-unit id="6e8668d616c8790cb8d71e8720597de54ced7850" translate="yes" xml:space="preserve">
          <source>This command is used to combine all objects that do not currently reside in a &quot;pack&quot;, into a pack. It can also be used to re-organize existing packs into a single, more efficient pack.</source>
          <target state="translated">这条命令用于将当前不在一个 &quot;包 &quot;中的所有对象合并成一个包。它也可以用来将现有的包重新组织成一个更有效的包。</target>
        </trans-unit>
        <trans-unit id="e7cbc44be580e3c1734536d3564c4b9dc7e501fa" translate="yes" xml:space="preserve">
          <source>This command is used to solve the storage and performance problem by storing the refs in a single file, &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt;. When a ref is missing from the traditional &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory hierarchy, it is looked up in this file and used if found.</source>
          <target state="translated">此命令用于通过将引用存储在单个文件 &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; 来解决存储和性能问题。当传统的 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 目录层次结构中缺少引用时，将在此文件中查找该引用并在找到后使用。</target>
        </trans-unit>
        <trans-unit id="43f707239bbecf8d6bf96bbdb4b367abb8fd5357" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git archive&lt;/code&gt; side, and the program pair is meant to be used to get an archive from a remote repository.</source>
          <target state="translated">最终用户通常不会直接调用此命令。协议的UI位于 &lt;code&gt;git archive&lt;/code&gt; 端，该程序对用于从远程存储库获取归档。</target>
        </trans-unit>
        <trans-unit id="17d67b43408b7b4804e33e1e3b79dc1fbf03af1b" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git fetch-pack&lt;/code&gt; side, and the program pair is meant to be used to pull updates from a remote repository. For push operations, see &lt;code&gt;git send-pack&lt;/code&gt;.</source>
          <target state="translated">最终用户通常不会直接调用此命令。协议的UI位于 &lt;code&gt;git fetch-pack&lt;/code&gt; 一侧，该程序对用于从远程存储库中提取更新。有关推送操作，请参见 &lt;code&gt;git send-pack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36ac8b84f92c3cf141e5ae101adcc45178aae4c7" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git send-pack&lt;/code&gt; side, and the program pair is meant to be used to push updates to remote repository. For pull operations, see &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt;.</source>
          <target state="translated">最终用户通常不会直接调用此命令。协议的UI位于 &lt;code&gt;git send-pack&lt;/code&gt; 一侧，该程序对用于将更新推送到远程存储库。有关拉操作，请参见&lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8cac5b996748b602d2e8f0cf9273cee3d1c4d80" translate="yes" xml:space="preserve">
          <source>This command lets you check that intermediate commits are compilable. The todo list becomes like that:</source>
          <target state="translated">这个命令让你检查中间提交是否可以编译。待办事项列表就会变成这样。</target>
        </trans-unit>
        <trans-unit id="56bca57be11add071b8aeae38f6a28f443105856" translate="yes" xml:space="preserve">
          <source>This command manages the information recorded in the reflogs.</source>
          <target state="translated">该命令管理重新记录的信息。</target>
        </trans-unit>
        <trans-unit id="7c7ebb85111dd101dc1c2782f6e5cbc235a39c44" translate="yes" xml:space="preserve">
          <source>This command provides a way to interact with p4 repositories using Git.</source>
          <target state="translated">该命令提供了一种使用 Git 与 p4 仓库进行交互的方法。</target>
        </trans-unit>
        <trans-unit id="637c92f99feb8b30861eeaee2e3273c64a9b5351" translate="yes" xml:space="preserve">
          <source>This command reads some patches or commit messages from either the &amp;lt;file&amp;gt; arguments or the standard input if no &amp;lt;file&amp;gt; is specified. If &lt;code&gt;--parse&lt;/code&gt; is specified, the output consists of the parsed trailers.</source>
          <target state="translated">如果未指定&amp;lt;file&amp;gt;，则此命令从&amp;lt;file&amp;gt;参数或标准输入读取某些补丁或提交消息。如果指定了 &lt;code&gt;--parse&lt;/code&gt; ，则输出由已解析的预告片组成。</target>
        </trans-unit>
        <trans-unit id="a38646d64359b52991af1358c674765acf2c0c11" translate="yes" xml:space="preserve">
          <source>This command should not list any commits. Otherwise, check out &lt;code&gt;master&lt;/code&gt; and merge &lt;code&gt;maint&lt;/code&gt; into it.</source>
          <target state="translated">该命令不应列出任何提交。否则，请检出 &lt;code&gt;master&lt;/code&gt; 并将 &lt;code&gt;maint&lt;/code&gt; 合并到其中。</target>
        </trans-unit>
        <trans-unit id="6a853b09f1818b9d32f936bd42aa8a84af13b068" translate="yes" xml:space="preserve">
          <source>This command shows the differences between two versions of a patch series, or more generally, two commit ranges (ignoring merge commits).</source>
          <target state="translated">这条命令显示了一个补丁系列的两个版本之间的差异,或者更一般地说,两个提交范围之间的差异(忽略合并提交)。</target>
        </trans-unit>
        <trans-unit id="852903a68075d19a47d4520af94edde77996207f" translate="yes" xml:space="preserve">
          <source>This command stores credentials indefinitely on disk for use by future Git programs.</source>
          <target state="translated">这条命令会将凭证无限期地存储在磁盘上,供以后的 Git 程序使用。</target>
        </trans-unit>
        <trans-unit id="d143bf10d727fe2f5d0639ed85e199dd448d8bd2" translate="yes" xml:space="preserve">
          <source>This command updates the index using the current content found in the working tree, to prepare the content staged for the next commit. It typically adds the current content of existing paths as a whole, but with some options it can also be used to add content with only part of the changes made to the working tree files applied, or remove paths that do not exist in the working tree anymore.</source>
          <target state="translated">这条命令使用工作树中的当前内容更新索引,为下一次提交准备分期的内容。它通常会将现有路径的内容作为一个整体来添加,但通过一些选项,它也可以用来添加只应用了工作树文件的部分更改的内容,或者删除工作树中已经不存在的路径。</target>
        </trans-unit>
        <trans-unit id="61eacd31ecbd262bdcbed11d9c6103318919d1be" translate="yes" xml:space="preserve">
          <source>This command uploads a mailbox generated with &lt;code&gt;git format-patch&lt;/code&gt; into an IMAP drafts folder. This allows patches to be sent as other email is when using mail clients that cannot read mailbox files directly. The command also works with any general mailbox in which emails have the fields &quot;From&quot;, &quot;Date&quot;, and &quot;Subject&quot; in that order.</source>
          <target state="translated">此命令将使用 &lt;code&gt;git format-patch&lt;/code&gt; 生成的邮箱上载到 IMAP草稿文件夹。使用无法直接读取邮箱文件的邮件客户端时，这可以像发送其他电子邮件一样发送补丁程序。该命令还可以与任何常规邮箱一起使用，在该邮箱中，电子邮件的顺序为&amp;ldquo;发件人&amp;rdquo;，&amp;ldquo;日期&amp;rdquo;和&amp;ldquo;主题&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a3bcbdfcf8f3a072ac23f24cf310648f9691fb70" translate="yes" xml:space="preserve">
          <source>This command uses a binary search algorithm to find which commit in your project&amp;rsquo;s history introduced a bug. You use it by first telling it a &quot;bad&quot; commit that is known to contain the bug, and a &quot;good&quot; commit that is known to be before the bug was introduced. Then &lt;code&gt;git
bisect&lt;/code&gt; picks a commit between those two endpoints and asks you whether the selected commit is &quot;good&quot; or &quot;bad&quot;. It continues narrowing down the range until it finds the exact commit that introduced the change.</source>
          <target state="translated">此命令使用二进制搜索算法来查找项目历史记录中的哪个提交引入了错误。通过首先告诉它包含臭虫的&amp;ldquo;坏&amp;rdquo;提交和引入臭虫之前的&amp;ldquo;好&amp;rdquo;提交来使用它。然后 &lt;code&gt;git bisect&lt;/code&gt; 在这两个端点之间选择一个提交，并询问您所选择的提交是&amp;ldquo;好&amp;rdquo;还是&amp;ldquo;坏&amp;rdquo;。它继续缩小范围，直到找到引入更改的确切提交为止。</target>
        </trans-unit>
        <trans-unit id="097f8af4b6f26b418927a5ca4b24d71746b1f843" translate="yes" xml:space="preserve">
          <source>This command uses the &lt;code&gt;diff.color.*&lt;/code&gt; and &lt;code&gt;pager.range-diff&lt;/code&gt; settings (the latter is on by default). See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">此命令使用 &lt;code&gt;diff.color.*&lt;/code&gt; 和 &lt;code&gt;pager.range-diff&lt;/code&gt; 设置（默认情况下启用）。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03bab6a03561ee7ff2e9bf92505bcdd5322bfb51" translate="yes" xml:space="preserve">
          <source>This command will fail with non-zero status upon error. Some exit codes are:</source>
          <target state="translated">该命令在出错时将以非零状态失败。一些退出代码是:</target>
        </trans-unit>
        <trans-unit id="7ed6af6e5518c122d94f4b8fea824fc7938bd5aa" translate="yes" xml:space="preserve">
          <source>This command will fetch changes from the remote branches to your remote-tracking branches &lt;code&gt;origin/*&lt;/code&gt;, and merge the default branch into the current branch.</source>
          <target state="translated">此命令将从远程分支获取更改到远程跟踪分支 &lt;code&gt;origin/*&lt;/code&gt; ，并将默认分支合并到当前分支。</target>
        </trans-unit>
        <trans-unit id="99c24081605f25434a1fa0a51df82045bf4b7763" translate="yes" xml:space="preserve">
          <source>This command will save your changes away to the &lt;code&gt;stash&lt;/code&gt;, and reset your working tree and the index to match the tip of your current branch. Then you can make your fix as usual.</source>
          <target state="translated">此命令会将您的更改保存到 &lt;code&gt;stash&lt;/code&gt; ，并重置工作树和索引以匹配当前分支的尖端。然后，您可以照常进行修复。</target>
        </trans-unit>
        <trans-unit id="cb41b9bb98cbe715b8d6c0b50eb0b52309cdc91a" translate="yes" xml:space="preserve">
          <source>This commit will get blown away so a throw-away log message is OK.</source>
          <target state="translated">这个提交会被炸掉,所以扔掉的日志信息是可以的。</target>
        </trans-unit>
        <trans-unit id="068d7057b3017084327709c3e61c2e224fb2a5f6" translate="yes" xml:space="preserve">
          <source>This commits all other changes in the index.</source>
          <target state="translated">这将提交索引中的所有其他更改。</target>
        </trans-unit>
        <trans-unit id="1d649ab8ff53024e7549864469811ccee0abf2e7" translate="yes" xml:space="preserve">
          <source>This commits your first edits in &lt;code&gt;branch1&lt;/code&gt;.</source>
          <target state="translated">这将在 &lt;code&gt;branch1&lt;/code&gt; 中提交您的第一次编辑。</target>
        </trans-unit>
        <trans-unit id="8bc13c84a009ea0d6abb173ac6100dc00ae7606a" translate="yes" xml:space="preserve">
          <source>This compares stage 2 (our branch), stage 3 (their branch) and the working tree file and outputs a combined diff, similar to the way &lt;code&gt;diff-tree&lt;/code&gt; shows a merge commit with these flags.</source>
          <target state="translated">这将比较阶段2（我们的分支），阶段3（他们的分支）和工作树文件，并输出组合的diff，类似于 &lt;code&gt;diff-tree&lt;/code&gt; 显示带有这些标志的合并提交的方式。</target>
        </trans-unit>
        <trans-unit id="d3fe164a17e549b712f12743eb90dc676fb8455c" translate="yes" xml:space="preserve">
          <source>This computation involves traversing all the reachable objects, i.e. it has the same cost as &lt;code&gt;git prune&lt;/code&gt;. It is primarily intended to fix corruption caused by garbage collecting using older versions of Git, which didn&amp;rsquo;t protect objects referred to by reflogs.</source>
          <target state="translated">该计算涉及遍历所有可到达的对象，即，其成本与 &lt;code&gt;git prune&lt;/code&gt; 相同。它的主要目的是修复使用较旧版本的Git进行垃圾收集所导致的损坏，该版本未保护reflog引用的对象。</target>
        </trans-unit>
        <trans-unit id="9e7c3905269f2318ce8a27a07b91b053d9dd7129" translate="yes" xml:space="preserve">
          <source>This configuration can be specified multiple times in order to allow multiple notes refs to be included. In that case, it will behave similarly to multiple &lt;code&gt;--[no-]notes[=]&lt;/code&gt; options passed in. That is, a value of &lt;code&gt;true&lt;/code&gt; will show the default notes, a value of &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; will also show notes from that notes ref and a value of &lt;code&gt;false&lt;/code&gt; will negate previous configurations and not show notes.</source>
          <target state="translated">可以多次指定此配置，以允许包含多个注释引用。在这种情况下，它的行为类似于传入的多个 &lt;code&gt;--[no-]notes[=]&lt;/code&gt; 选项。即，值为 &lt;code&gt;true&lt;/code&gt; 将显示默认注释，值为 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 还将显示该注释中的注释ref和 &lt;code&gt;false&lt;/code&gt; 值将否定以前的配置，并且不显示注释。</target>
        </trans-unit>
        <trans-unit id="e6aa4372bde5e931f9e4e006e5a3cd0aea5ccf17" translate="yes" xml:space="preserve">
          <source>This configuration is used in two ways:</source>
          <target state="translated">这种配置有两种使用方式。</target>
        </trans-unit>
        <trans-unit id="06f31556dacb48424e7a1be662dd26364f785ce9" translate="yes" xml:space="preserve">
          <source>This configuration variable is useful in cases where you&amp;rsquo;d like to centrally configure your Git hooks instead of configuring them on a per-repository basis, or as a more flexible and centralized alternative to having an &lt;code&gt;init.templateDir&lt;/code&gt; where you&amp;rsquo;ve changed default hooks.</source>
          <target state="translated">此配置变量在您希望集中配置Git挂钩而不是基于每个存储库进行配置的情况下非常有用，或者作为在更改了默认挂钩之后使用 &lt;code&gt;init.templateDir&lt;/code&gt; 的更灵活，更集中的替代方法。</target>
        </trans-unit>
        <trans-unit id="eed4a11499740f4bb5f61d3ce7354c5409f33bf3" translate="yes" xml:space="preserve">
          <source>This configures how whitespace is ignored when performing the move detection for &lt;code&gt;--color-moved&lt;/code&gt;. It can be set by the &lt;code&gt;diff.colorMovedWS&lt;/code&gt; configuration setting. These modes can be given as a comma separated list:</source>
          <target state="translated">这配置了对 &lt;code&gt;--color-moved&lt;/code&gt; 执行移动检测时如何忽略空格。可以通过 &lt;code&gt;diff.colorMovedWS&lt;/code&gt; 配置设置进行设置。这些模式可以以逗号分隔的列表形式给出：</target>
        </trans-unit>
        <trans-unit id="9b4ea1fd788cef298d939e77017eddec04b80461" translate="yes" xml:space="preserve">
          <source>This configures how whitespace is ignored when performing the move detection for &lt;code&gt;--color-moved&lt;/code&gt;. These modes can be given as a comma separated list:</source>
          <target state="translated">这配置了对 &lt;code&gt;--color-moved&lt;/code&gt; 执行移动检测时如何忽略空格。这些模式可以以逗号分隔的列表形式给出：</target>
        </trans-unit>
        <trans-unit id="77030a3f3e0bddf7aada34bc0939552bc0993e3c" translate="yes" xml:space="preserve">
          <source>This counts the number of unpacked object files and disk space consumed by them, to help you decide when it is a good time to repack.</source>
          <target state="translated">这将统计未打包的对象文件的数量和它们所消耗的磁盘空间,以帮助你决定何时是重新打包的好时机。</target>
        </trans-unit>
        <trans-unit id="3e67b0f2a3d6f811dcdec6a80edd2cc8d01b0b6b" translate="yes" xml:space="preserve">
          <source>This creates a &quot;lightweight&quot; tag. If you would also like to include a comment with the tag, and possibly sign it cryptographically, then you should create a tag object instead; see the &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; man page for details.</source>
          <target state="translated">这将创建一个&amp;ldquo;轻量级&amp;rdquo;标签。如果您还希望在标签中包含注释，并可能对其进行加密签名，则应该创建一个标签对象；有关详细信息，请参见&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;手册页。</target>
        </trans-unit>
        <trans-unit id="687e61032de29ec5a828bf99d3854a432acd2a82" translate="yes" xml:space="preserve">
          <source>This creates a new directory &quot;myrepo&quot; containing a clone of Alice&amp;rsquo;s repository. The clone is on an equal footing with the original project, possessing its own copy of the original project&amp;rsquo;s history.</source>
          <target state="translated">这将创建一个新目录&amp;ldquo; myrepo&amp;rdquo;，其中包含Alice存储库的克隆。该克隆副本与原始项目处于平等地位，拥有自己的原始项目历史副本。</target>
        </trans-unit>
        <trans-unit id="c2fd84fc2fa04021fed2cadb8707ca64b05a22fb" translate="yes" xml:space="preserve">
          <source>This creates a single &quot;pack file&quot; in .git/objects/pack/ containing all currently unpacked objects. You can then run</source>
          <target state="translated">这将在 .git/objects/pack/中创建一个单一的 &quot;pack文件&quot;,其中包含所有当前未打包的对象。然后您可以运行</target>
        </trans-unit>
        <trans-unit id="bf43931e74b20a3da5197ed923f890fe71d72016" translate="yes" xml:space="preserve">
          <source>This default configuration is achieved by creating references to the remote branch heads under &lt;code&gt;refs/remotes/origin&lt;/code&gt; and by initializing &lt;code&gt;remote.origin.url&lt;/code&gt; and &lt;code&gt;remote.origin.fetch&lt;/code&gt; configuration variables.</source>
          <target state="translated">通过在 &lt;code&gt;refs/remotes/origin&lt;/code&gt; 下创建对远程分支头的引用并初始化 &lt;code&gt;remote.origin.url&lt;/code&gt; 和 &lt;code&gt;remote.origin.fetch&lt;/code&gt; 配置变量来实现此默认配置。</target>
        </trans-unit>
        <trans-unit id="984768ad68337dfe2b0015e657c9f4f069afabc8" translate="yes" xml:space="preserve">
          <source>This defines two submodules, &lt;code&gt;libfoo&lt;/code&gt; and &lt;code&gt;libbar&lt;/code&gt;. These are expected to be checked out in the paths &lt;code&gt;include/foo&lt;/code&gt; and &lt;code&gt;include/bar&lt;/code&gt;, and for both submodules a URL is specified which can be used for cloning the submodules.</source>
          <target state="translated">这定义了两个子模块 &lt;code&gt;libfoo&lt;/code&gt; 和 &lt;code&gt;libbar&lt;/code&gt; 。可以在 &lt;code&gt;include/foo&lt;/code&gt; 和 &lt;code&gt;include/bar&lt;/code&gt; 路径中检出它们，并且为两个子模块都指定一个URL，该URL可用于克隆子模块。</target>
        </trans-unit>
        <trans-unit id="57db5304522b1070a0df1071ce5df5d38ea7d002" translate="yes" xml:space="preserve">
          <source>This describes how Tony Luck uses Git in his role as maintainer of the IA64 architecture for the Linux kernel.</source>
          <target state="translated">本文介绍了Tony Luck作为Linux内核IA64架构的维护者如何使用Git。</target>
        </trans-unit>
        <trans-unit id="c9e275f2996b22cd4415c594fae8f08a0dfe70e8" translate="yes" xml:space="preserve">
          <source>This determines the coloring scheme to be applied to blame output. It can be &lt;code&gt;repeatedLines&lt;/code&gt;, &lt;code&gt;highlightRecent&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt; which is the default.</source>
          <target state="translated">这确定了要应用于责备输出的着色方案。它可以是 &lt;code&gt;repeatedLines&lt;/code&gt; ， &lt;code&gt;highlightRecent&lt;/code&gt; 或默认的 &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56ee29b22f07db9306c3380b74b5b0180828e415" translate="yes" xml:space="preserve">
          <source>This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/objects&quot; will be used instead.</source>
          <target state="translated">如果设置了 $GIT_COMMON_DIR,这个目录就会被忽略,取而代之的是 &quot;$GIT_COMMON_DIR/objects&quot;。</target>
        </trans-unit>
        <trans-unit id="2072b137cd96280de0e098678b51f23a76dcd0dc" translate="yes" xml:space="preserve">
          <source>This disables potentially expensive checks to workaround broken symlinks checked into SVN by broken clients. Set this option to &quot;false&quot; if you track a SVN repository with many empty blobs that are not symlinks. This option may be changed while &lt;code&gt;git svn&lt;/code&gt; is running and take effect on the next revision fetched. If unset, &lt;code&gt;git svn&lt;/code&gt; assumes this option to be &quot;true&quot;.</source>
          <target state="translated">这会禁用潜在的昂贵检查，以解决由损坏的客户端签入SVN的损坏的符号链接。如果您跟踪带有许多不是符号链接的空blob的SVN存储库，请将此选项设置为&amp;ldquo; false&amp;rdquo;。 &lt;code&gt;git svn&lt;/code&gt; 运行时可以更改此选项，并在获取的下一个修订版本上生效。如果未设置，则 &lt;code&gt;git svn&lt;/code&gt; 假定此选项为&amp;ldquo; true&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="006e62625e60aabc7f31fa591f6f9b4a3bd2a878" translate="yes" xml:space="preserve">
          <source>This document attempts to write down and motivate some of the workflow elements used for &lt;code&gt;git.git&lt;/code&gt; itself. Many ideas apply in general, though the full workflow is rarely required for smaller projects with fewer people involved.</source>
          <target state="translated">本文档试图写下并激励一些用于 &lt;code&gt;git.git&lt;/code&gt; 本身的工作流元素。通常有许多想法适用，尽管对于涉及较少人员的小型项目，很少需要完整的工作流程。</target>
        </trans-unit>
        <trans-unit id="8cd9193645885514540ac19f3167f508bebca422" translate="yes" xml:space="preserve">
          <source>This document presents a specification for a version 2 of Git&amp;rsquo;s wire protocol. Protocol v2 will improve upon v1 in the following ways:</source>
          <target state="translated">本文档介绍了Git有线协议版本2的规范。协议v2将在以下方面对v1进行改进：</target>
        </trans-unit>
        <trans-unit id="46bd1a26c48d1772be26d3d869cc4b6544004ea1" translate="yes" xml:space="preserve">
          <source>This document shows the &quot;raw&quot; syntax as seen by git. The shell and other UIs might require additional quoting to protect special characters and to avoid word splitting.</source>
          <target state="translated">本文档展示了 git 所看到的 &quot;原始 &quot;语法,shell 和其他用户界面可能需要额外的引号来保护特殊字符,并避免拆字。在shell和其他用户接口中,可能需要额外的引号来保护特殊字符,并避免词的分割。</target>
        </trans-unit>
        <trans-unit id="a76f8971dde9f8810b677765aca0d70490d9f8fa" translate="yes" xml:space="preserve">
          <source>This document will serve as the master list for extensions. Any implementation wishing to define a new extension should make a note of it here, in order to claim the name.</source>
          <target state="translated">本文件将作为扩展名的主列表。任何希望定义新扩展的实现都应在此注明,以便使用该名称。</target>
        </trans-unit>
        <trans-unit id="d24a591988945bec7d040b25bd5a37c73014bcf3" translate="yes" xml:space="preserve">
          <source>This does not affect &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; or the &lt;code&gt;git-diff-*&lt;/code&gt; plumbing commands. Can be overridden on the command line with the &lt;code&gt;--color[=&amp;lt;when&amp;gt;]&lt;/code&gt; option.</source>
          <target state="translated">这不会影响&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;或 &lt;code&gt;git-diff-*&lt;/code&gt; 管道命令。可以使用 &lt;code&gt;--color[=&amp;lt;when&amp;gt;]&lt;/code&gt; 选项在命令行上覆盖。</target>
        </trans-unit>
        <trans-unit id="99af460532d2c9f72e65ed17f7464c8aa563e1f4" translate="yes" xml:space="preserve">
          <source>This does not force normalization of text files, but does ensure that text files that you introduce to the repository have their line endings normalized to LF when they are added, and that files that are already normalized in the repository stay normalized.</source>
          <target state="translated">这并不强制对文本文件进行归一化,但可以确保你引入到版本库的文本文件在添加时,其行结尾会被归一化为LF,而且版本库中已经归一化的文件会保持归一化。</target>
        </trans-unit>
        <trans-unit id="257328db317fb853114a41f8430f87cd826d08a0" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t interfere with interoperating with the Subversion repository you cloned from, but if you wish for your local Git repository to be able to interoperate with someone else&amp;rsquo;s local Git repository, either don&amp;rsquo;t use this option or you should both use it in the same local time zone.</source>
          <target state="translated">这不会干扰与您克隆的Subversion存储库的互操作，但是如果您希望本地Git存储库能够与其他人的本地Git存储库进行互操作，请不要使用此选项，或者您都应在相同的当地时区。</target>
        </trans-unit>
        <trans-unit id="45497ef8f3614492732f059c04bc30af3c6593e9" translate="yes" xml:space="preserve">
          <source>This effectively runs &lt;code&gt;add --interactive&lt;/code&gt;, but bypasses the initial command menu and directly jumps to the &lt;code&gt;patch&lt;/code&gt; subcommand. See &amp;ldquo;Interactive mode&amp;rdquo; for details.</source>
          <target state="translated">这将有效地运行 &lt;code&gt;add --interactive&lt;/code&gt; ，但会绕过初始命令菜单，而直接跳转到 &lt;code&gt;patch&lt;/code&gt; 子命令。有关详细信息，请参见&amp;ldquo;交互模式&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="53c54ba0465bbf9916ac436659dbf61aedb86156" translate="yes" xml:space="preserve">
          <source>This enables parent rewriting, see &lt;code&gt;History Simplification&lt;/code&gt; above.</source>
          <target state="translated">这将启用父级重写，请参见上面的&amp;ldquo; &lt;code&gt;History Simplification&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccdf590466d01d04dcf6da8ad6a6bec9f02c4d8e" translate="yes" xml:space="preserve">
          <source>This environment allows the specification of an alternate index file. If not specified, the default of &lt;code&gt;$GIT_DIR/index&lt;/code&gt; is used.</source>
          <target state="translated">此环境允许指定备用索引文件。如果未指定，则使用默认值 &lt;code&gt;$GIT_DIR/index&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2abd55a6650395bf249165e2f6568e98ab14958c" translate="yes" xml:space="preserve">
          <source>This environment variable allows the specification of an index version for new repositories. It won&amp;rsquo;t affect existing index files. By default index file version 2 or 3 is used. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; for more information.</source>
          <target state="translated">此环境变量允许为新存储库指定索引版本。它不会影响现有的索引文件。默认情况下，使用索引文件版本2或3。有关更多信息，请参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2763e4fc7ba1973ac90184c067d20f9d0fda70a8" translate="yes" xml:space="preserve">
          <source>This environment variable overrides &lt;code&gt;$EDITOR&lt;/code&gt; and &lt;code&gt;$VISUAL&lt;/code&gt;. It is used by several Git commands when, on interactive mode, an editor is to be launched. See also &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; and the &lt;code&gt;core.editor&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">此环境变量将覆盖 &lt;code&gt;$EDITOR&lt;/code&gt; 和 &lt;code&gt;$VISUAL&lt;/code&gt; 。在交互模式下，要启动编辑器时，它由多个Git命令使用。另请参见&lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt;和&lt;a href=&quot;git-config&quot;&gt;git-config [1]中&lt;/a&gt;的 &lt;code&gt;core.editor&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="ddbc158f0dcc3c8ea52494b42fbb66d15e06e460" translate="yes" xml:space="preserve">
          <source>This environment variable overrides &lt;code&gt;$PAGER&lt;/code&gt;. If it is set to an empty string or to the value &quot;cat&quot;, Git will not launch a pager. See also the &lt;code&gt;core.pager&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">此环境变量将覆盖 &lt;code&gt;$PAGER&lt;/code&gt; 。如果将其设置为空字符串或值&amp;ldquo; cat&amp;rdquo;，则Git将不会启动寻呼机。另请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]中&lt;/a&gt;的 &lt;code&gt;core.pager&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="85b43d9b9e3f28d79e0c1169949e722bd8f10c35" translate="yes" xml:space="preserve">
          <source>This environment variable overrides the configured Git editor when editing the todo list of an interactive rebase. See also linkit::git-rebase[1] and the &lt;code&gt;sequence.editor&lt;/code&gt; option in linkit::git-config[1].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ea93764f52eb3dcc477c86398962bd9bbded98" translate="yes" xml:space="preserve">
          <source>This event contains the command name for this git process and the hierarchy of commands from parent git processes.</source>
          <target state="translated">这个事件包含了这个git进程的命令名称和父git进程的命令层次。</target>
        </trans-unit>
        <trans-unit id="f5d9f72db5c7ffa9776d5c71964338d54a2515a4" translate="yes" xml:space="preserve">
          <source>This event contains the complete argv received by main().</source>
          <target state="translated">这个事件包含了main()收到的完整的argv。</target>
        </trans-unit>
        <trans-unit id="2a4c1f111536d47e2687ea692bfe5bd399b4307d" translate="yes" xml:space="preserve">
          <source>This event contains the discovered full path of the git executable (on platforms that are configured to resolve it).</source>
          <target state="translated">该事件包含发现的git可执行文件的完整路径(在配置为解析的平台上)。</target>
        </trans-unit>
        <trans-unit id="c8af8dbf59abf700f44d6449c7c951b54692bd2e" translate="yes" xml:space="preserve">
          <source>This event defines a repo-id and associates it with the root of the worktree.</source>
          <target state="translated">该事件定义了一个repo-id,并将其与工作树的根相关联。</target>
        </trans-unit>
        <trans-unit id="efbcacd1a490c688869fdd46397140e75919d7ab" translate="yes" xml:space="preserve">
          <source>This event describes a child process that is about to be spawned.</source>
          <target state="translated">该事件描述了一个即将被生成的子流程。</target>
        </trans-unit>
        <trans-unit id="8c8f935852467fd7c3b46787d77518dc3611a986" translate="yes" xml:space="preserve">
          <source>This event gives the version of the executable and the EVENT format. It should always be the first event in a trace session. The EVENT format version will be incremented if new event types are added, if existing fields are removed, or if there are significant changes in interpretation of existing events or fields. Smaller changes, such as adding a new field to an existing event, will not require an increment to the EVENT format version.</source>
          <target state="translated">该事件给出了可执行文件的版本和EVENT格式。它应该始终是跟踪会话中的第一个事件。如果增加了新的事件类型,删除了现有的字段,或者对现有事件或字段的解释有重大变化,EVENT格式版本将被递增。较小的变化,如在现有事件中添加一个新字段,将不需要递增EVENT格式版本。</target>
        </trans-unit>
        <trans-unit id="7ea085d0e611d87af89c62af2b70656c0016dc7e" translate="yes" xml:space="preserve">
          <source>This event is emitted by the Trace2 &lt;code&gt;atexit&lt;/code&gt; routine during final shutdown. It should be the last event emitted by the process.</source>
          <target state="translated">在最终关闭期间，Trace2 &lt;code&gt;atexit&lt;/code&gt; 例程会发出此事件。它应该是流程发出的最后一个事件。</target>
        </trans-unit>
        <trans-unit id="0b20979b7d0436896a9e4dd619b31c2f047cbd64" translate="yes" xml:space="preserve">
          <source>This event is emitted when git calls &lt;code&gt;exit()&lt;/code&gt;.</source>
          <target state="translated">当git调用 &lt;code&gt;exit()&lt;/code&gt; 时发出此事件。</target>
        </trans-unit>
        <trans-unit id="9c63cb7135e802e553dc499a675da732d4f96c3a" translate="yes" xml:space="preserve">
          <source>This event is emitted when one of the &lt;code&gt;error()&lt;/code&gt;, &lt;code&gt;die()&lt;/code&gt;, or &lt;code&gt;usage()&lt;/code&gt; functions are called.</source>
          <target state="translated">调用 &lt;code&gt;error()&lt;/code&gt; ， &lt;code&gt;die()&lt;/code&gt; 或 &lt;code&gt;usage()&lt;/code&gt; 函数之一时，将发出此事件。</target>
        </trans-unit>
        <trans-unit id="ebb8b872e605289564f67171a3133d84781ab210" translate="yes" xml:space="preserve">
          <source>This event is emitted when the program is terminated by a user signal. Depending on the platform, the signal event may prevent the &quot;atexit&quot; event from being generated.</source>
          <target state="translated">当程序被用户信号终止时,会发出该事件。根据平台的不同,该信号事件可能会阻止 &quot;atexit &quot;事件的产生。</target>
        </trans-unit>
        <trans-unit id="2ca8802f12c75856c4e7ea399ac7a1939e2a37eb" translate="yes" xml:space="preserve">
          <source>This event is generated after the current process has returned from the waitpid() and collected the exit information from the child.</source>
          <target state="translated">该事件在当前进程从waitpid()返回并收集了子进程的退出信息后产生。</target>
        </trans-unit>
        <trans-unit id="9fe6d803410a7d3a5cd4bc2114534352d230200b" translate="yes" xml:space="preserve">
          <source>This event is generated before git attempts to &lt;code&gt;exec()&lt;/code&gt; another command rather than starting a child process.</source>
          <target state="translated">这个事件是在git尝试 &lt;code&gt;exec()&lt;/code&gt; 另一个命令而不是启动子进程之前生成的。</target>
        </trans-unit>
        <trans-unit id="93caa8939f471f1240286ec30c6905ef3996f20e" translate="yes" xml:space="preserve">
          <source>This event is generated if the &lt;code&gt;exec()&lt;/code&gt; fails and control returns to the current git command.</source>
          <target state="translated">如果 &lt;code&gt;exec()&lt;/code&gt; 失败并且控制返回到当前的git命令，则会生成此事件。</target>
        </trans-unit>
        <trans-unit id="15a0b5629f08a42566247fd3e8af69adc717eef8" translate="yes" xml:space="preserve">
          <source>This event is generated to log a global parameter, such as a config setting, command-line flag, or environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814427d239ec02f31ac7bf0fb913766e18bfb53e" translate="yes" xml:space="preserve">
          <source>This event is generated to log a global parameter.</source>
          <target state="translated">该事件的产生是为了记录一个全局参数。</target>
        </trans-unit>
        <trans-unit id="54b6cc61590e1e0eba249cc8ddd71ddff154355b" translate="yes" xml:space="preserve">
          <source>This event is generated to log a pre-formatted JSON string containing structured data.</source>
          <target state="translated">该事件的产生是为了记录一个包含结构化数据的预格式化JSON字符串。</target>
        </trans-unit>
        <trans-unit id="0ee97bbcf1fde0cf306363257efe6b7de578045e" translate="yes" xml:space="preserve">
          <source>This event is generated to log a thread- and region-local key/value pair.</source>
          <target state="translated">该事件的产生是为了记录线程和区域的本地键/值对。</target>
        </trans-unit>
        <trans-unit id="4caa8d05330c9e1126d8391705e312b0d8975d63" translate="yes" xml:space="preserve">
          <source>This event is generated when a thread exits. It is generated from &lt;strong&gt;within&lt;/strong&gt; the thread&amp;rsquo;s thread-proc (for TLS reasons).</source>
          <target state="translated">线程退出时会生成此事件。它是从线程的thread-proc &lt;strong&gt;内部&lt;/strong&gt;生成的（出于TLS的原因）。</target>
        </trans-unit>
        <trans-unit id="eba565beaf1b2269c764c147f5196869afe38bce" translate="yes" xml:space="preserve">
          <source>This event is generated when a thread is started. It is generated from &lt;strong&gt;within&lt;/strong&gt; the new thread&amp;rsquo;s thread-proc (for TLS reasons).</source>
          <target state="translated">启动线程时生成此事件。它是&lt;strong&gt;在&lt;/strong&gt;新线程的thread-proc &lt;strong&gt;内部&lt;/strong&gt;生成的（出于TLS的原因）。</target>
        </trans-unit>
        <trans-unit id="1684fe3e3862662b36c1dfb0c9bb20558e1f338a" translate="yes" xml:space="preserve">
          <source>This event is generated when entering a region.</source>
          <target state="translated">该事件在进入一个区域时产生。</target>
        </trans-unit>
        <trans-unit id="809d72e4f54bac6c7054af4e990fa8c97e8c764d" translate="yes" xml:space="preserve">
          <source>This event is generated when leaving a region.</source>
          <target state="translated">该事件在离开一个区域时产生。</target>
        </trans-unit>
        <trans-unit id="1e6a7368deeb7ec580313fc82400f1c12d17672a" translate="yes" xml:space="preserve">
          <source>This event is present when an alias is expanded.</source>
          <target state="translated">当一个别名被展开时,该事件就会出现。</target>
        </trans-unit>
        <trans-unit id="bca802363ffa9599d9e13df71e2f62ec1454e32f" translate="yes" xml:space="preserve">
          <source>This event is written to the git-trace2-discard sentinel file if there are too many files in the target trace directory (see the trace2.maxFiles config option).</source>
          <target state="translated">如果目标跟踪目录中的文件太多,该事件会被写入 git-trace2-discard sentinel 文件(参见 trace2.maxFiles 配置选项)。</target>
        </trans-unit>
        <trans-unit id="8c2ad60a0d9356a6e908b18056fbac1c2b1d4129" translate="yes" xml:space="preserve">
          <source>This event, when present, describes the command variant This event may be emitted more than once.</source>
          <target state="translated">该事件在出现时,描述了命令的变体。</target>
        </trans-unit>
        <trans-unit id="3e7d09cee878b03064fb9d9484c73f3f00225826" translate="yes" xml:space="preserve">
          <source>This example also shows that thread names are assigned in a racy manner as each thread starts and allocates TLS storage.</source>
          <target state="translated">这个例子还表明,在每个线程启动和分配TLS存储时,线程名称都是以一种狂热的方式分配的。</target>
        </trans-unit>
        <trans-unit id="e296b28f1fcad64b66f85f9abe931f54fc5fbde0" translate="yes" xml:space="preserve">
          <source>This example imports a new remote &quot;p4/proj2&quot; into an existing Git repository:</source>
          <target state="translated">本例将新的远程 &quot;p4/proj2 &quot;导入到现有的 Git 仓库中。</target>
        </trans-unit>
        <trans-unit id="7cbbc9fac80d3f9e05217d26ad6f34ea5097abe6" translate="yes" xml:space="preserve">
          <source>This example shows that the index contained 3552 entries.</source>
          <target state="translated">这个例子显示,该索引包含3552个条目。</target>
        </trans-unit>
        <trans-unit id="af5672891a1be21669d22b688901415e2cf060c3" translate="yes" xml:space="preserve">
          <source>This expands to the object name of the delta base for the given object, if it is stored as a delta. Otherwise it expands to the null object name (all zeroes).</source>
          <target state="translated">如果给定的对象被存储为delta,则扩展为delta基的对象名。否则,它将展开为空的对象名(全部为零)。</target>
        </trans-unit>
        <trans-unit id="1a642986ccbacca12888668bff4ca6d3b1007b62" translate="yes" xml:space="preserve">
          <source>This explanation comes for &quot;free&quot; because there was no change. Similarly &lt;code&gt;C&lt;/code&gt; could be explained using &lt;code&gt;1&lt;/code&gt;, but that comes at some cost c&amp;gt;0 because of the modification:</source>
          <target state="translated">这种解释是&amp;ldquo;免费的&amp;rdquo;，因为没有变化。类似地，可以使用 &lt;code&gt;1&lt;/code&gt; 来解释 &lt;code&gt;C&lt;/code&gt; ，但是由于修改，这会付出一定的代价c&amp;gt; 0：</target>
        </trans-unit>
        <trans-unit id="86a0b58a904e042293eb0ea80455653f123e7d4e" translate="yes" xml:space="preserve">
          <source>This extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents.</source>
          <target state="translated">如果重命名或复制检测被激活,这种扩展格式可以很有用,让你看到不同父文件的原始名称。</target>
        </trans-unit>
        <trans-unit id="fc95481325c82bdecdaa23291b735168b05af418" translate="yes" xml:space="preserve">
          <source>This extension does not change git&amp;rsquo;s behavior at all. It is useful only for testing format-1 compatibility.</source>
          <target state="translated">这个扩展根本不会改变git的行为。仅对测试格式1兼容性有用。</target>
        </trans-unit>
        <trans-unit id="24a20ccff9f7f9f91cdf61fb876086b44fc5be61" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis by setting repository&amp;rsquo;s &lt;code&gt;gitweb.pickaxe&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过设置存储库的 &lt;code&gt;gitweb.pickaxe&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="3fcd9d965aa29d51e3ab01e56c522e086b7f545b" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.avatar&lt;/code&gt; configuration variable.</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.avatar&lt;/code&gt; 配置变量在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="da6908103a49ae5e820a33c13aadd5dfdd3e67a7" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.blame&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.blame&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="1d6d167abae14ab18966eab440f954ed6085f29c" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.grep&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.grep&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="dd4f802848cf6cbdc7682aeefb00472f2c444c9e" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.highlight&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.highlight&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="a8e82652b1c51e397e7f1e31621e9084d5611fda" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.patches&lt;/code&gt; configuration variable (integer).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.patches&lt;/code&gt; 配置变量（整数）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="a0528d6fc23cb2716835712f44b5daf955251062" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.remote_heads&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.remote_heads&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="58b983175f59d7aad97dac71b32251a2f4a8c4a0" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.showSizes&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.showSizes&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="ee33afe943a28f48529ed67cc410ad185ea09f23" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.snapshot&lt;/code&gt; configuration variable, which contains a comma separated list of formats or &quot;none&quot; to disable snapshots. Unknown values are ignored.</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.snapshot&lt;/code&gt; 配置变量在每个存储库的基础上配置此功能，该变量包含逗号分隔的格式列表或&amp;ldquo; none&amp;rdquo;以禁用快照。未知值将被忽略。</target>
        </trans-unit>
        <trans-unit id="c2467a6f49bad0810d0f5e1c4a51888ceb4f5b0f" translate="yes" xml:space="preserve">
          <source>This feature can be configured on per-repository basis after setting $feature{&lt;code&gt;extra-branch-refs&lt;/code&gt;}{&lt;code&gt;override&lt;/code&gt;} to true, via repository&amp;rsquo;s &lt;code&gt;gitweb.extraBranchRefs&lt;/code&gt; configuration variable, which contains a space separated list of refs. An example:</source>
          <target state="translated">通过将$ feature { &lt;code&gt;extra-branch-refs&lt;/code&gt; } { &lt;code&gt;override&lt;/code&gt; }设置为true后，可以通过存储库的 &lt;code&gt;gitweb.extraBranchRefs&lt;/code&gt; 配置变量在每个存储库的基础上配置此功能，该配置变量包含一个以空格分隔的refs列表。一个例子：</target>
        </trans-unit>
        <trans-unit id="83b4612ad81d70c9ed8920a4b451b69b8c3ee080" translate="yes" xml:space="preserve">
          <source>This feature is intended to speed up git operations for repos that have large working directories.</source>
          <target state="translated">这个功能的目的是为了加快有大型工作目录的仓库的git操作。</target>
        </trans-unit>
        <trans-unit id="6b24b487d6d9654020073f6754733ecc051175ad" translate="yes" xml:space="preserve">
          <source>This feature is semi-deprecated. For scripting purpose, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;&lt;code&gt;--porcelain&lt;/code&gt; and &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt;&lt;code&gt;--name-status&lt;/code&gt; are almost always superior alternatives, and users should look at &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;&lt;code&gt;--short&lt;/code&gt; or &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--name-status&lt;/code&gt; for more user-friendly alternatives.</source>
          <target state="translated">半不推荐使用此功能。出于脚本目的，&lt;a href=&quot;git-status&quot;&gt;git-status [1] &lt;/a&gt; &lt;code&gt;--porcelain&lt;/code&gt; 和&lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1] &lt;/a&gt; &lt;code&gt;--name-status&lt;/code&gt; 几乎总是更好的选择，用户应查看&lt;a href=&quot;git-status&quot;&gt;git-status [1] &lt;/a&gt; &lt;code&gt;--short&lt;/code&gt; 或&lt;a href=&quot;git-diff&quot;&gt;git- diff [1] &lt;/a&gt; &lt;code&gt;--name-status&lt;/code&gt; 提供更多用户友好的替代方案。</target>
        </trans-unit>
        <trans-unit id="0861edc399d3214fad2ecef2c8c7d8f9e28b4564" translate="yes" xml:space="preserve">
          <source>This feature is useful when an established project should be accepted despite early commits containing errors that can be safely ignored such as invalid committer email addresses. Note: corrupt objects cannot be skipped with this setting.</source>
          <target state="translated">这个功能对于已经建立的项目来说是很有用的,尽管早期的提交中包含了一些错误,比如提交人的电子邮件地址无效,但还是应该被接受。注意:这个设置不能跳过损坏的对象。</target>
        </trans-unit>
        <trans-unit id="5474f37d061902594342fbe38be401770ea2769f" translate="yes" xml:space="preserve">
          <source>This feature works by recording the mtime of the working tree directories and then omitting reading directories and stat calls against files in those directories whose mtime hasn&amp;rsquo;t changed. For this to work the underlying operating system and file system must change the &lt;code&gt;st_mtime&lt;/code&gt; field of directories if files in the directory are added, modified or deleted.</source>
          <target state="translated">此功能的工作方式是记录工作树目录的mtime，然后忽略mtime不变的那些目录中的文件的读取目录和stat调用。为此，如果在目录中添加，修改或删除了文件，则底层操作系统和文件系统必须更改目录的 &lt;code&gt;st_mtime&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="ef2541ade640bd800921de0e87cda6dd56d4d5f6" translate="yes" xml:space="preserve">
          <source>This fetches revisions from the SVN parent of the current HEAD and rebases the current (uncommitted to SVN) work against it.</source>
          <target state="translated">这将从当前 HEAD 的 SVN 父版本中获取修订版,并对当前(未提交到 SVN)的工作进行重定向。</target>
        </trans-unit>
        <trans-unit id="e6f84c5c8c6a08793025b9538660cbd1c1faa637" translate="yes" xml:space="preserve">
          <source>This file contains the commit message of a commit in progress. If &lt;code&gt;git commit&lt;/code&gt; exits due to an error before creating a commit, any commit message that has been provided by the user (e.g., in an editor session) will be available in this file, but will be overwritten by the next invocation of &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">该文件包含正在进行的提交的提交消息。如果 &lt;code&gt;git commit&lt;/code&gt; 由于在创建提交之前出错而退出，则用户提供的任何提交消息（例如，在编辑器会话中）都将在此文件中可用，但是下次 &lt;code&gt;git commit&lt;/code&gt; 调用将覆盖该消息。</target>
        </trans-unit>
        <trans-unit id="2063696fd909d95d720efff6859f2846f7a33789" translate="yes" xml:space="preserve">
          <source>This file helps dumb transports discover what refs are available in this repository. If the repository is published for dumb transports, this file should be regenerated by &lt;code&gt;git update-server-info&lt;/code&gt; every time a tag or branch is created or modified. This is normally done from the &lt;code&gt;hooks/update&lt;/code&gt; hook, which is run by the &lt;code&gt;git-receive-pack&lt;/code&gt; command when you &lt;code&gt;git push&lt;/code&gt; into the repository.</source>
          <target state="translated">此文件可帮助愚蠢的传输发现该存储库中可用的参考。如果发布该存储库是为了进行愚蠢的传输，则每次创建或修改标签或分支时， &lt;code&gt;git update-server-info&lt;/code&gt; 都应重新生成此文件。这通常是通过 &lt;code&gt;hooks/update&lt;/code&gt; 钩子完成的，当您将 &lt;code&gt;git push&lt;/code&gt; 到存储库时，钩子/更新钩子由 &lt;code&gt;git-receive-pack&lt;/code&gt; 命令运行。</target>
        </trans-unit>
        <trans-unit id="3487083c7b98c66e39acc8f940f40c0e9ceac88f" translate="yes" xml:space="preserve">
          <source>This file is to help dumb transports discover what packs are available in this object store. Whenever a pack is added or removed, &lt;code&gt;git update-server-info&lt;/code&gt; should be run to keep this file up to date if the repository is published for dumb transports. &lt;code&gt;git repack&lt;/code&gt; does this by default.</source>
          <target state="translated">此文件是为了帮助愚蠢的传输发现此对象存储中有哪些可用的包。每当添加或删除 &lt;code&gt;git update-server-info&lt;/code&gt; 时，如果已发布存储库以进行愚蠢的传输，则应运行git update-server-info以使该文件保持最新。 &lt;code&gt;git repack&lt;/code&gt; 默认情况下会这样做。</target>
        </trans-unit>
        <trans-unit id="cbe65e34529f44f10bf3c4bc531b3ef1a1689dfb" translate="yes" xml:space="preserve">
          <source>This file mainly serves as the mapping between the name and path of submodules in the superproject, such that the submodule&amp;rsquo;s Git directory can be located.</source>
          <target state="translated">该文件主要用作超级项目中子模块的名称和路径之间的映射，以便可以找到子模块的Git目录。</target>
        </trans-unit>
        <trans-unit id="071050e2544b6fc3703fb63508bbfdc9243b46ab" translate="yes" xml:space="preserve">
          <source>This file records URLs to alternate object stores that this object store borrows objects from, to be used when the repository is fetched over HTTP.</source>
          <target state="translated">这个文件记录了这个对象商店借用对象的备用对象商店的 URL,以便在通过 HTTP 获取存储库时使用。</target>
        </trans-unit>
        <trans-unit id="cc3397ff622f0d4d27f532099612807583041388" translate="yes" xml:space="preserve">
          <source>This file records fake commit ancestry information, to pretend the set of parents a commit has is different from how the commit was actually created. One record per line describes a commit and its fake parents by listing their 40-byte hexadecimal object names separated by a space and terminated by a newline.</source>
          <target state="translated">这个文件记录了假的提交祖先信息,以假装一个提交的父母集与该提交的实际创建方式不同。每行一条记录通过列出40字节的十六进制对象名来描述一个提交和它的假父母,并以空格分隔,以换行结束。</target>
        </trans-unit>
        <trans-unit id="1873ba1c652fc3e8dae8a41ecd45dff2c995baaf" translate="yes" xml:space="preserve">
          <source>This file records paths to alternate object stores that this object store borrows objects from, one pathname per line. Note that not only native Git tools use it locally, but the HTTP fetcher also tries to use it remotely; this will usually work if you have relative paths (relative to the object database, not to the repository!) in your alternates file, but it will not work if you use absolute paths unless the absolute path in filesystem and web URL is the same. See also &lt;code&gt;objects/info/http-alternates&lt;/code&gt;.</source>
          <target state="translated">该文件记录到该对象存储库借用对象的备用对象存储库的路径，每行一个路径名。请注意，不仅本地Git工具在本地使用它，而且HTTP fetcher也会尝试远程使用它。如果您的替代文件中有相对路径（相对于对象数据库，而不是存储库！），通常这将起作用，但如果您使用绝对路径，则除非文件系统和Web URL中的绝对路径相同，否则它将不起作用。另请参阅 &lt;code&gt;objects/info/http-alternates&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="517ab2689bb34239adf0b92ebb2a70e736956866" translate="yes" xml:space="preserve">
          <source>This file stores sparse checkout patterns. See also: &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt;.</source>
          <target state="translated">此文件存储稀疏签出模式。另请参阅：&lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39e8ca5394d81b30bccd145a749de9346fba2480" translate="yes" xml:space="preserve">
          <source>This file uses the following format:</source>
          <target state="translated">该文件使用以下格式:</target>
        </trans-unit>
        <trans-unit id="53c1d1d0fe83b95fe57b9ac9f6f59413589df721" translate="yes" xml:space="preserve">
          <source>This file, by convention among Porcelains, stores the exclude pattern list. &lt;code&gt;.gitignore&lt;/code&gt; is the per-directory ignore file. &lt;code&gt;git status&lt;/code&gt;, &lt;code&gt;git add&lt;/code&gt;, &lt;code&gt;git rm&lt;/code&gt; and &lt;code&gt;git clean&lt;/code&gt; look at it but the core Git commands do not look at it. See also: &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="translated">按照陶瓷惯例，此文件存储排除模式列表。 &lt;code&gt;.gitignore&lt;/code&gt; 是每个目录的忽略文件。 &lt;code&gt;git status&lt;/code&gt; ， &lt;code&gt;git add&lt;/code&gt; ， &lt;code&gt;git rm&lt;/code&gt; 和 &lt;code&gt;git clean&lt;/code&gt; 会看它，但是核心的Git命令不会看它。另请参阅：&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8956b9fdca3244ff8cd9467aefdc82ab275d878" translate="yes" xml:space="preserve">
          <source>This filter may be used if you only need to modify the environment in which the commit will be performed. Specifically, you might want to rewrite the author/committer name/email/time environment variables (see &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; for details).</source>
          <target state="translated">如果仅需要修改将在其中执行提交的环境，则可以使用此过滤器。具体来说，您可能想要重写作者/提交者名称/电子邮件/时间环境变量（有关详细信息，请参见&lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1f7d9b6979d573a6d61c7fc37aef6ce7f09ba079" translate="yes" xml:space="preserve">
          <source>This flag causes &lt;code&gt;git diff-tree --stdin&lt;/code&gt; to also show the commit message before the differences.</source>
          <target state="translated">这个标志使 &lt;code&gt;git diff-tree --stdin&lt;/code&gt; 也显示差异之前的提交消息。</target>
        </trans-unit>
        <trans-unit id="f18c1480999d4a64a19b051751a1dfdb3d01c394" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in a local pack that has a .keep file to be ignored, even if it would have otherwise been packed.</source>
          <target state="translated">这个标志会导致一个已经在本地包中有.keep文件的对象被忽略,即使它本来会被打包。</target>
        </trans-unit>
        <trans-unit id="3b2c5aa43d85ae95c70f7126e1a8d471a0247285" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in a pack to be ignored even if it would have otherwise been packed.</source>
          <target state="translated">这个标志会导致一个已经在包装中的对象被忽略,即使它本来会被包装。</target>
        </trans-unit>
        <trans-unit id="936ccdd465b71c76f59e3d7929f0e31e3a24c431" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in the given pack to be ignored, even if it would have otherwise been packed. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; is the pack file name without leading directory (e.g. &lt;code&gt;pack-123.pack&lt;/code&gt;). The option could be specified multiple times to keep multiple packs.</source>
          <target state="translated">即使已打包，此标志也会导致已忽略给定包中的对象。 &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; 是没有前导目录的包文件名（例如 &lt;code&gt;pack-123.pack&lt;/code&gt; ）。可以多次指定该选项以保留多个包装。</target>
        </trans-unit>
        <trans-unit id="9fad47cb9db9729fbeb177e82626a6322dbefd6c" translate="yes" xml:space="preserve">
          <source>This flag causes an object that is borrowed from an alternate object store to be ignored even if it would have otherwise been packed.</source>
          <target state="translated">这个标志会导致从备用对象存储中借用的对象被忽略,即使它本来会被打包。</target>
        </trans-unit>
        <trans-unit id="97fddffea713eaa9774ecf695b0619f959916c25" translate="yes" xml:space="preserve">
          <source>This flag causes combined diffs (used for merge commits) to list the name of the file from all parents. It thus only has effect when -c or --cc are specified, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested).</source>
          <target state="translated">这个标志会使合并后的差异文件(用于合并提交)列出所有父文件的名称。因此,它只有在指定了 -c 或 --cc 时才会生效,而且只有在检测到文件名变化时才会有用(例如,当要求检测重命名或复制时)。</target>
        </trans-unit>
        <trans-unit id="7d04699c745135d6f14712a3d65005478838c3a7" translate="yes" xml:space="preserve">
          <source>This flag changes the way a merge commit is displayed (which means it is useful only when the command is given one &amp;lt;tree-ish&amp;gt;, or &lt;code&gt;--stdin&lt;/code&gt;). It shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time (which is what the &lt;code&gt;-m&lt;/code&gt; option does). Furthermore, it lists only files which were modified from all parents.</source>
          <target state="translated">该标志改变了合并提交的显示方式（这意味着仅在命令被赋予一个&amp;lt;tree-ish&amp;gt;或 &lt;code&gt;--stdin&lt;/code&gt; 时才有用）。它同时显示了每个父项与合并结果之间的差异，而不是一次显示父项与结果之间的成对差异（这是 &lt;code&gt;-m&lt;/code&gt; 选项的作用）。此外，它仅列出从所有父级修改而来的文件。</target>
        </trans-unit>
        <trans-unit id="0d503f20848f4e1ff6c5e78038f4bce28f3422a3" translate="yes" xml:space="preserve">
          <source>This flag changes the way a merge commit patch is displayed, in a similar way to the &lt;code&gt;-c&lt;/code&gt; option. It implies the &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-p&lt;/code&gt; options and further compresses the patch output by omitting uninteresting hunks whose the contents in the parents have only two variants and the merge result picks one of them without modification. When all hunks are uninteresting, the commit itself and the commit log message is not shown, just like in any other &quot;empty diff&quot; case.</source>
          <target state="translated">该标志以与 &lt;code&gt;-c&lt;/code&gt; 选项类似的方式更改合并提交补丁的显示方式。它暗示了 &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;-p&lt;/code&gt; 选项，并通过省略不感兴趣的块（它们在父级中的内容只有两个变体，合并结果选择了其中一个而没有修改）来进一步压缩补丁输出。当所有的块都不感兴趣时​​，就不会显示提交本身和提交日志消息，就像其他&amp;ldquo;空差异&amp;rdquo;情况一样。</target>
        </trans-unit>
        <trans-unit id="4835250d6cbee97633146544cd1896afcc631099" translate="yes" xml:space="preserve">
          <source>This flag disables these checks, and can cause the remote repository to lose commits; use it with care.</source>
          <target state="translated">这个标志会禁用这些检查,并可能导致远程仓库丢失提交,请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="cc5f19786a1b0eda7705eaaa80c372612ab5d782" translate="yes" xml:space="preserve">
          <source>This flag implies the &lt;code&gt;-c&lt;/code&gt; option and further compresses the patch output by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification.</source>
          <target state="translated">该标志表示 &lt;code&gt;-c&lt;/code&gt; 选项，并通过省略不感兴趣的块（它们在父对象中的内容只有两个变体）并且合并结果选择其中一个而没有修改的粗体来进一步压缩补丁输出。</target>
        </trans-unit>
        <trans-unit id="03d7872e2a4e991418dc3ea26303b414cb645f27" translate="yes" xml:space="preserve">
          <source>This flag is passed to the &lt;code&gt;git apply&lt;/code&gt; program (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) that applies the patch. Implies --apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9f2e241df42ed566896490c4c1723461343597" translate="yes" xml:space="preserve">
          <source>This flag is passed to the &lt;code&gt;git log&lt;/code&gt; program (see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;) that generates the patches.</source>
          <target state="translated">该标志被传递到生成补丁的 &lt;code&gt;git log&lt;/code&gt; 程序（请参阅&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7d74132f018d1e29c74648fc0cf6690a80cd700b" translate="yes" xml:space="preserve">
          <source>This flag makes the command not to report its progress on the standard error stream.</source>
          <target state="translated">该标志使命令不在标准错误流上报告其进度。</target>
        </trans-unit>
        <trans-unit id="c7300f914a6246e85c4558f9e03e3ac6bd2957c2" translate="yes" xml:space="preserve">
          <source>This flag makes the merge commits show the full diff like regular commits; for each merge parent, a separate log entry and diff is generated. An exception is that only diff against the first parent is shown when &lt;code&gt;--first-parent&lt;/code&gt; option is given; in that case, the output represents the changes the merge brought &lt;code&gt;into&lt;/code&gt; the then-current branch.</source>
          <target state="translated">该标志使合并提交像常规提交一样显示完整的差异；对于每个合并父级，将生成一个单独的日志条目和差异。一个例外是，给定 &lt;code&gt;--first-parent&lt;/code&gt; 选项时，仅显示与第一个父对象的差异；在这种情况下，输出表示变化带来合并 &lt;code&gt;into&lt;/code&gt; 当时的分支。</target>
        </trans-unit>
        <trans-unit id="824f1a5cbd322eac2edc9b61691e0afb5fb06c7c" translate="yes" xml:space="preserve">
          <source>This flag tells the command not to reuse existing object data at all, including non deltified object, forcing recompression of everything. This implies --no-reuse-delta. Useful only in the obscure case where wholesale enforcement of a different compression level on the packed data is desired.</source>
          <target state="translated">这个标志告诉命令完全不重用现有的对象数据,包括非强化对象,强制重新压缩所有的数据。这意味着--no-reuse-delta。只有在需要对打包的数据全盘执行不同压缩级别的情况下才有用。</target>
        </trans-unit>
        <trans-unit id="e554d11fed47fbadc588fbbd426a692640350799" translate="yes" xml:space="preserve">
          <source>This form can only be used in the middle of a &lt;code&gt;commit&lt;/code&gt;. The path names a directory entry within fast-import&amp;rsquo;s active commit. The path must be quoted in this case.</source>
          <target state="translated">这种形式只能在 &lt;code&gt;commit&lt;/code&gt; 。该路径为快速导入的活动提交中的目录条目命名。在这种情况下，必须引用路径。</target>
        </trans-unit>
        <trans-unit id="55cd46dfe4dc47146eb359f16ba2ab6440f5d33b" translate="yes" xml:space="preserve">
          <source>This form is to compare the given two paths on the filesystem. You can omit the &lt;code&gt;--no-index&lt;/code&gt; option when running the command in a working tree controlled by Git and at least one of the paths points outside the working tree, or when running the command outside a working tree controlled by Git. This form implies &lt;code&gt;--exit-code&lt;/code&gt;.</source>
          <target state="translated">这种形式是比较文件系统上给定的两个路径。在由Git控制的工作树中运行命令时，可以忽略 &lt;code&gt;--no-index&lt;/code&gt; 选项，并且至少有一个路径指向该工作树之外，或者在由Git控制的工作树外部运行命令时，也可以省略该选项。这种形式意味着 &lt;code&gt;--exit-code&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a36c2e6e9bf305ffd5ef7a7e4c453ac93dfb865" translate="yes" xml:space="preserve">
          <source>This form is to view the changes on the branch containing and up to the second &amp;lt;commit&amp;gt;, starting at a common ancestor of both &amp;lt;commit&amp;gt;. &quot;git diff A...B&quot; is equivalent to &quot;git diff $(git merge-base A B) B&quot;. You can omit any one of &amp;lt;commit&amp;gt;, which has the same effect as using HEAD instead.</source>
          <target state="translated">此表单用于查看包含且直到第二个&amp;lt;commit&amp;gt;的分支上的更改，该更改始于两个&amp;lt;commit&amp;gt;的共同祖先。&amp;ldquo; git diff A ... B&amp;rdquo;等效于&amp;ldquo; git diff $（git merge-base AB）B&amp;rdquo;。您可以省略&amp;lt;commit&amp;gt;中的任何一个，其效果与使用HEAD相同。</target>
        </trans-unit>
        <trans-unit id="18011d68a19f669179582c8652eaff17f583329f" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you have in your working tree relative to the named &amp;lt;commit&amp;gt;. You can use HEAD to compare it with the latest commit, or a branch name to compare with the tip of a different branch.</source>
          <target state="translated">此表单用于查看您在工作树中相对于名为&amp;lt;commit&amp;gt;的更改。您可以使用HEAD将其与最新提交进行比较，或使用分支名称与其他分支的尖端进行比较。</target>
        </trans-unit>
        <trans-unit id="0c3233dc5774a7d1fc399a8b304cc732bba72d9f" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you made relative to the index (staging area for the next commit). In other words, the differences are what you &lt;code&gt;could&lt;/code&gt; tell Git to further add to the index but you still haven&amp;rsquo;t. You can stage these changes by using &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;.</source>
          <target state="translated">该表单用于查看您相对于索引（下一次提交的暂存区域）所做的更改。换句话说，您 &lt;code&gt;could&lt;/code&gt; 告诉Git进一步将差异添加到索引中，但您仍然没有。您可以使用&lt;a href=&quot;git-add&quot;&gt;git-add [1]进行&lt;/a&gt;这些更改。</target>
        </trans-unit>
        <trans-unit id="ee8e76f95895702db36db495b0e53027904973c9" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you staged for the next commit relative to the named &amp;lt;commit&amp;gt;. Typically you would want comparison with the latest commit, so if you do not give &amp;lt;commit&amp;gt;, it defaults to HEAD. If HEAD does not exist (e.g. unborn branches) and &amp;lt;commit&amp;gt; is not given, it shows all staged changes. --staged is a synonym of --cached.</source>
          <target state="translated">此表单用于查看相对于命名的&amp;lt;commit&amp;gt;为下一次提交所做的更改。通常，您希望与最新提交进行比较，因此，如果您不提供&amp;lt;commit&amp;gt;，则默认为HEAD。如果HEAD不存在（例如，未出生的分支）并且未给出&amp;lt;commit&amp;gt;，则它将显示所有已分阶段的更改。--staged是--cached的同义词。</target>
        </trans-unit>
        <trans-unit id="51dda6a69f38e64f972e32a62549822542d75887" translate="yes" xml:space="preserve">
          <source>This form is to view the differences between the raw contents of two blob objects.</source>
          <target state="translated">这种形式是为了查看两个blob对象的原始内容之间的差异。</target>
        </trans-unit>
        <trans-unit id="3140d31a73de32a89eb697f18f04aa202d7a5d8e" translate="yes" xml:space="preserve">
          <source>This form is to view the results of a merge commit. The first listed &amp;lt;commit&amp;gt; must be the merge itself; the remaining two or more commits should be its parents. A convenient way to produce the desired set of revisions is to use the ^@ suffix. For instance, if &lt;code&gt;master&lt;/code&gt; names a merge commit, &lt;code&gt;git diff master
master^@&lt;/code&gt; gives the same combined diff as &lt;code&gt;git show master&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395d78419362cad7438eb6eae46785d35953f019" translate="yes" xml:space="preserve">
          <source>This form resets the current branch head to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; and possibly updates the index (resetting it to the tree of &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;) and the working tree depending on &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is omitted, defaults to &lt;code&gt;--mixed&lt;/code&gt;. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; must be one of the following:</source>
          <target state="translated">该表格将当前分支头重置为 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; ,并可能更新索引（将其重置为 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 的树）和取决于 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 的工作树。如果省略 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; ，则默认为 &lt;code&gt;--mixed&lt;/code&gt; 。所述 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 必须是下列之一：</target>
        </trans-unit>
        <trans-unit id="90bcd35d4969f3a90ba2bd18f27a5c6eb93f333b" translate="yes" xml:space="preserve">
          <source>This form will use the first line matching the given POSIX regex. If &amp;lt;start&amp;gt; is a regex, it will search from the end of the previous &lt;code&gt;-L&lt;/code&gt; range, if any, otherwise from the start of file. If &amp;lt;start&amp;gt; is &amp;ldquo;^/regex/&amp;rdquo;, it will search from the start of file. If &amp;lt;end&amp;gt; is a regex, it will search starting at the line given by &amp;lt;start&amp;gt;.</source>
          <target state="translated">此表单将使用与给定POSIX正则表达式匹配的第一行。如果&amp;lt;start&amp;gt;是正则表达式，它将从前一个 &lt;code&gt;-L&lt;/code&gt; 范围的末尾（如果有）搜索，否则从文件的开头搜索。如果&amp;lt;start&amp;gt;是&amp;ldquo; ^ / regex /&amp;rdquo;，它将从文件的开头搜索。如果&amp;lt;end&amp;gt;是正则表达式，它将从&amp;lt;start&amp;gt;给出的行开始搜索。</target>
        </trans-unit>
        <trans-unit id="b42c261dd1828c15332725a480fa7095bcc76b2a" translate="yes" xml:space="preserve">
          <source>This format expects the first line of the file to contain the &quot;Cc:&quot; value and the &quot;Subject:&quot; of the message as the second line.</source>
          <target state="translated">这种格式希望文件的第一行包含 &quot;Cc:&quot;值,第二行包含邮件的 &quot;Subject:&quot;。</target>
        </trans-unit>
        <trans-unit id="105520fc7842a24e43537a27759a074335828eb6" translate="yes" xml:space="preserve">
          <source>This format is identical to version &lt;code&gt;0&lt;/code&gt;, with the following exceptions:</source>
          <target state="translated">此格式与版本 &lt;code&gt;0&lt;/code&gt; 相同，但以下情况除外：</target>
        </trans-unit>
        <trans-unit id="fd22347e6ce1cebbfe9140a8d5df54f1132eb3e9" translate="yes" xml:space="preserve">
          <source>This format is no longer produced by any Git command, but is and will continue to be supported by &lt;code&gt;update-index --index-info&lt;/code&gt;.</source>
          <target state="translated">此格式不再由任何Git命令生成，但是 &lt;code&gt;update-index --index-info&lt;/code&gt; 将继续支持。</target>
        </trans-unit>
        <trans-unit id="e1e42b99834dd201113f33eae88b5856f686096e" translate="yes" xml:space="preserve">
          <source>This format is to put higher order stages into the index file and matches &lt;code&gt;git ls-files --stage&lt;/code&gt; output.</source>
          <target state="translated">此格式用于将高阶阶段放入索引文件中，并匹配 &lt;code&gt;git ls-files --stage&lt;/code&gt; 输出。</target>
        </trans-unit>
        <trans-unit id="483caba3e82677e09e2d521ebba75089a90ce09e" translate="yes" xml:space="preserve">
          <source>This format is to stuff &lt;code&gt;git ls-tree&lt;/code&gt; output into the index.</source>
          <target state="translated">这种格式是将 &lt;code&gt;git ls-tree&lt;/code&gt; 输出填充到索引中。</target>
        </trans-unit>
        <trans-unit id="078ec0cba6df63b2f2fc0bbcd069e250ea13b628" translate="yes" xml:space="preserve">
          <source>This format is used to refer to another commit in a commit message and is the same as &lt;code&gt;--pretty='format:%C(auto)%h (%s, %ad)'&lt;/code&gt;. By default, the date is formatted with &lt;code&gt;--date=short&lt;/code&gt; unless another &lt;code&gt;--date&lt;/code&gt; option is explicitly specified. As with any &lt;code&gt;format:&lt;/code&gt; with format placeholders, its output is not affected by other options like &lt;code&gt;--decorate&lt;/code&gt; and &lt;code&gt;--walk-reflogs&lt;/code&gt;.</source>
          <target state="translated">此格式用于引用提交消息中的另一个提交，并且与 &lt;code&gt;--pretty='format:%C(auto)%h (%s, %ad)'&lt;/code&gt; 。默认情况下，日期格式为 &lt;code&gt;--date=short&lt;/code&gt; ,除非明确指定了另一个 &lt;code&gt;--date&lt;/code&gt; 选项。与任何 &lt;code&gt;format:&lt;/code&gt; 使用格式占位符，其输出不受 &lt;code&gt;--decorate&lt;/code&gt; 和 &lt;code&gt;--walk-reflogs&lt;/code&gt; 之类的其他选项的影响。</target>
        </trans-unit>
        <trans-unit id="742c78626a467f269e89b016f43c5e1a7be4cd88" translate="yes" xml:space="preserve">
          <source>This gets rid of the &lt;code&gt;git-svn-id:&lt;/code&gt; lines at the end of every commit.</source>
          <target state="translated">这就消除了 &lt;code&gt;git-svn-id:&lt;/code&gt; 每次提交结束时的行。</target>
        </trans-unit>
        <trans-unit id="2acaf36aea784a80df7509fcb8e38355c645c5a7" translate="yes" xml:space="preserve">
          <source>This gives a very controlled flow of fixes. If you notice that you have applied a fix to e.g. &lt;code&gt;master&lt;/code&gt; that is also required in &lt;code&gt;maint&lt;/code&gt;, you will need to cherry-pick it (using &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;) downwards. This will happen a few times and is nothing to worry about unless you do it very frequently.</source>
          <target state="translated">这样可以很好地控制修补程序的流程。如果发现已应用修复到例如 &lt;code&gt;master&lt;/code&gt; ，其也需要在 &lt;code&gt;maint&lt;/code&gt; ，则需要樱桃挑它（使用&lt;a href=&quot;git-cherry-pick&quot;&gt;GIT-樱桃挑[1] &lt;/a&gt;）向下。这将发生几次，除非您经常进行，否则无需担心。</target>
        </trans-unit>
        <trans-unit id="1f3884c08aac0f5d8941c7814b274c9743619a33" translate="yes" xml:space="preserve">
          <source>This happens if the &lt;code&gt;subsystem&lt;/code&gt; rebase had conflicts, or used &lt;code&gt;--interactive&lt;/code&gt; to omit, edit, squash, or fixup commits; or if the upstream used one of &lt;code&gt;commit --amend&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, or a full history rewriting command like &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;&lt;code&gt;filter-repo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;subsystem&lt;/code&gt; 发生了冲突，或者使用 &lt;code&gt;--interactive&lt;/code&gt; 来省略，编辑，压榨或修复提交，则会发生这种情况。或者上游是否使用 &lt;code&gt;commit --amend&lt;/code&gt; ， &lt;code&gt;reset&lt;/code&gt; 或完整的历史记录重写命令（如&lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt; &lt;code&gt;filter-repo&lt;/code&gt; )之一&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53ac63807fcdbfc7e050fb3151d6b086f2e9a274" translate="yes" xml:space="preserve">
          <source>This happens if the &lt;code&gt;subsystem&lt;/code&gt; rebase was a simple rebase and had no conflicts.</source>
          <target state="translated">如果 &lt;code&gt;subsystem&lt;/code&gt; 是简单的基础并且没有冲突，则会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="d414984e9f8d7bfd782c8f2da36b80bcd80ea28e" translate="yes" xml:space="preserve">
          <source>This has a few user-visible effects and caveats:</source>
          <target state="translated">这有一些用户可见的效果和注意事项。</target>
        </trans-unit>
        <trans-unit id="1c876a37c9c7633e47e1a6a38b1f16f75e32a3ed" translate="yes" xml:space="preserve">
          <source>This has a very similar UI to &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;revert&lt;/code&gt;, and lets you add untracked paths to the index.</source>
          <target state="translated">它具有非常相似的UI来 &lt;code&gt;update&lt;/code&gt; 和 &lt;code&gt;revert&lt;/code&gt; ，并允许您将未跟踪的路径添加到索引。</target>
        </trans-unit>
        <trans-unit id="33280cb105ee3b71902ce7b15c9592fd52f73e30" translate="yes" xml:space="preserve">
          <source>This has a very similar UI to &lt;code&gt;update&lt;/code&gt;, and the staged information for selected paths are reverted to that of the HEAD version. Reverting new paths makes them untracked.</source>
          <target state="translated">这具有非常相似的UI来 &lt;code&gt;update&lt;/code&gt; ，并且选定路径的暂存信息将还原为HEAD版本的信息。还原新路径使它们无法跟踪。</target>
        </trans-unit>
        <trans-unit id="4d4512b846dcedcc9cf4704e69eaeda15e1830db" translate="yes" xml:space="preserve">
          <source>This has been requested by some kernel developers because some bugs called sporadic bugs do not appear in all the kernel builds because they are very dependent on the compiler output.</source>
          <target state="translated">这是一些内核开发者要求的,因为一些被称为零星bug的bug并没有出现在所有的内核构建中,因为它们非常依赖于编译器的输出。</target>
        </trans-unit>
        <trans-unit id="b93781d2b5ee24d7b760545bc5177eb80e4c3e22" translate="yes" xml:space="preserve">
          <source>This has the advantage that it will be saved in your &lt;code&gt;CVS/Root&lt;/code&gt; files and you don&amp;rsquo;t need to worry about always setting the correct environment variable. SSH users restricted to &lt;code&gt;git-shell&lt;/code&gt; don&amp;rsquo;t need to override the default with CVS_SERVER (and shouldn&amp;rsquo;t) as &lt;code&gt;git-shell&lt;/code&gt; understands &lt;code&gt;cvs&lt;/code&gt; to mean &lt;code&gt;git-cvsserver&lt;/code&gt; and pretends that the other end runs the real &lt;code&gt;cvs&lt;/code&gt; better.</source>
          <target state="translated">这样的好处是它将被保存在您的 &lt;code&gt;CVS/Root&lt;/code&gt; 文件中，您不必担心总是设置正确的环境变量。受限于 &lt;code&gt;git-shell&lt;/code&gt; 的 SSH用户无需使用CVS_SERVER覆盖默认值（也不应该），因为 &lt;code&gt;git-shell&lt;/code&gt; 理解 &lt;code&gt;cvs&lt;/code&gt; 意味着 &lt;code&gt;git-cvsserver&lt;/code&gt; 并假装另一端可以更好地运行真实的 &lt;code&gt;cvs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f27a3b2d1e595dbb21c1b28424b4a89305bcf439" translate="yes" xml:space="preserve">
          <source>This has two implications:</source>
          <target state="translated">这有两个含义。</target>
        </trans-unit>
        <trans-unit id="a2d38b5ae6dea81df64d435d13a5c9c9c6e43a8c" translate="yes" xml:space="preserve">
          <source>This header line is followed by the following information at least once for each commit:</source>
          <target state="translated">这个头行后面是以下信息,每次提交至少一次。</target>
        </trans-unit>
        <trans-unit id="aac19de1c954c0a5c2aba42bf1f288afbf74cabf" translate="yes" xml:space="preserve">
          <source>This helper uses specified file descriptors to connect to a remote Git server. This is not meant for end users but for programs and scripts calling git fetch, push or archive.</source>
          <target state="translated">这个帮助程序使用指定的文件描述符来连接到远程 Git 服务器。这不是为终端用户准备的,而是为调用 git fetch、push 或 archive 的程序和脚本准备的。</target>
        </trans-unit>
        <trans-unit id="eafdc2cefff4153e88df550a24ce4b00606582ea" translate="yes" xml:space="preserve">
          <source>This hook can be used in conjunction with a corresponding pre-commit hook to save and restore any form of metadata associated with the working tree (e.g.: permissions/ownership, ACLS, etc). See contrib/hooks/setgitperms.perl for an example of how to do this.</source>
          <target state="translated">这个钩子可以和相应的预提交钩子一起使用,以保存和恢复与工作树相关的任何形式的元数据(例如:权限/所有权,ACLS等)。参见 contrib/hooks/setgitperms.perl 来了解如何做到这一点。</target>
        </trans-unit>
        <trans-unit id="9fae8c19d5ced3830760d386f8db3473a746ea76" translate="yes" xml:space="preserve">
          <source>This hook can be used to perform repository validity checks, auto-display differences from the previous HEAD if different, or set working dir metadata properties.</source>
          <target state="translated">这个钩子可以用来执行版本库有效性检查,如果与之前的HEAD不同,则自动显示差异,或者设置工作dir元数据属性。</target>
        </trans-unit>
        <trans-unit id="89a247d66f7dd9fd927ac160899ee7ad4eefe257" translate="yes" xml:space="preserve">
          <source>This hook can be used to prevent &lt;code&gt;forced&lt;/code&gt; update on certain refs by making sure that the object name is a commit object that is a descendant of the commit object named by the old object name. That is, to enforce a &quot;fast-forward only&quot; policy.</source>
          <target state="translated">通过确保对象名称是作为旧对象名称命名的提交对象的后代的提交对象，可以使用该挂钩来防止对某些引用进行 &lt;code&gt;forced&lt;/code&gt; 更新。也就是说，强制执行&amp;ldquo;仅快进&amp;rdquo;策略。</target>
        </trans-unit>
        <trans-unit id="e2b4b08b5c7d529703ac2e4609fae5478174d015" translate="yes" xml:space="preserve">
          <source>This hook can be used, for example, to run &lt;code&gt;git update-server-info&lt;/code&gt; if the repository is packed and is served via a dumb transport.</source>
          <target state="translated">如果存储库已打包并通过愚蠢的传输服务，则可以使用此钩子来运行 &lt;code&gt;git update-server-info&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec8359ca4fe68868d4a094d214fa5c736b07b686" translate="yes" xml:space="preserve">
          <source>This hook does not affect the outcome of &lt;code&gt;git receive-pack&lt;/code&gt;, as it is called after the real work is done.</source>
          <target state="translated">这个钩子不会影响 &lt;code&gt;git receive-pack&lt;/code&gt; 的结果，因为它在实际工作完成后会被调用。</target>
        </trans-unit>
        <trans-unit id="4f1494681f56d1e644fae421a13f75381d1bf104" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but for each ref to be updated it receives on standard input a line of the format:</source>
          <target state="translated">这个钩子对receive操作执行一次。它不接受任何参数,但每更新一个 ref,它就会在标准输入中接收一行格式的内容。</target>
        </trans-unit>
        <trans-unit id="1c705c0b531046d9558421e4543f9aca35624390" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but gets the same information as the &lt;a href=&quot;#pre-receive&quot;&gt;&lt;em&gt;pre-receive&lt;/em&gt;&lt;/a&gt; hook does on its standard input.</source>
          <target state="translated">该挂钩执行一次以进行接收操作。它不带参数，但获得的信息与&lt;a href=&quot;#pre-receive&quot;&gt;&lt;em&gt;pre-receive&lt;/em&gt;&lt;/a&gt;钩子在其标准输入上得到的信息相同。</target>
        </trans-unit>
        <trans-unit id="98f6b796f54de07e8019b94d0f551840c498ad05" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but uses a pkt-line format protocol to communicate with &lt;code&gt;receive-pack&lt;/code&gt; to read commands, push-options and send results. In the following example for the protocol, the letter &lt;code&gt;S&lt;/code&gt; stands for &lt;code&gt;receive-pack&lt;/code&gt; and the letter &lt;code&gt;H&lt;/code&gt; stands for this hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f404b0d7afced029532dd1c0ce00c69033fa119" translate="yes" xml:space="preserve">
          <source>This hook is called before any refname is updated and before any fast-forward checks are performed.</source>
          <target state="translated">这个钩子在任何refname被更新和任何快进检查被执行之前被调用。</target>
        </trans-unit>
        <trans-unit id="6f4d4e6bc9f3d3e90e8224d9cc9d15607a5f159d" translate="yes" xml:space="preserve">
          <source>This hook is called by &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and can be used to prevent a push from taking place. The hook is called with two parameters which provide the name and location of the destination remote, if a named remote is not being used both values will be the same.</source>
          <target state="translated">这个钩子被&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;调用，可以用来防止进行推送。该挂钩由两个参数调用，这些参数提供目标远程服务器的名称和位置，如果未使用命名远程服务器，则两个值将相同。</target>
        </trans-unit>
        <trans-unit id="b761c5f63f99b7c22c6e4ca4e1bd741b6a19c509" translate="yes" xml:space="preserve">
          <source>This hook is called by &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; and can be used to prevent a branch from getting rebased. The hook may be called with one or two parameters. The first parameter is the upstream from which the series was forked. The second parameter is the branch being rebased, and is not set when rebasing the current branch.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;调用，可用于防止分支重新建立基础。可以使用一个或两个参数来调用该挂钩。第一个参数是从其派生系列的上游。第二个参数是要重新建立基础的分支，在重新建立当前分支的基础时未设置。</target>
        </trans-unit>
        <trans-unit id="fc84f5afc2cc3712fb061152c42b83b5432e2d28" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes a single parameter, the name of the file that holds the proposed commit log message. Exiting with a non-zero status causes &lt;code&gt;git am&lt;/code&gt; to abort before applying the patch.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;调用。它只有一个参数，即保存建议的提交日志消息的文件的名称。以非零状态退出会导致 &lt;code&gt;git am&lt;/code&gt; 在应用补丁之前中止。</target>
        </trans-unit>
        <trans-unit id="109f1251e93ab76b92d28a05e1f40ca3ae3e2435" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes no parameter, and is invoked after the patch is applied and a commit is made.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;调用。它不带参数，在应用补丁并进行提交之后被调用。</target>
        </trans-unit>
        <trans-unit id="31dd1042d3a6d88015bf6a789db56141bf61f664" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes no parameter, and is invoked after the patch is applied, but before a commit is made.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;调用。它不带参数，在应用补丁程序之后但在提交之前被调用。</target>
        </trans-unit>
        <trans-unit id="4126a7ec7eb0a54d9b99d1f389fd70ce96c40950" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes a single parameter, the name of the file that holds the proposed commit log message. Exiting with a non-zero status causes the command to abort.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;和&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;调用，可以使用 &lt;code&gt;--no-verify&lt;/code&gt; 选项绕过。它只有一个参数，即保存建议的提交日志消息的文件的名称。以非零状态退出会导致命令中止。</target>
        </trans-unit>
        <trans-unit id="977ece26ae3c0446a7497462b09e90162737d6ca" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; right after preparing the default log message, and before the editor is started.</source>
          <target state="translated">&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;在准备默认日志消息之后并且在启动编辑器之前立即调用此钩子。</target>
        </trans-unit>
        <trans-unit id="2ae25bad855fc10ca5e955357c713cdbb31a472c" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes no parameters, and is invoked before obtaining the proposed commit log message and making a commit. Exiting with a non-zero status from this script causes the &lt;code&gt;git commit&lt;/code&gt; command to abort before creating a commit.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;调用，可以使用 &lt;code&gt;--no-verify&lt;/code&gt; 选项绕过。它不带任何参数，并且在获取建议的提交日志消息并进行提交之前被调用。从此脚本以非零状态退出会导致 &lt;code&gt;git commit&lt;/code&gt; 命令在创建提交之前中止。</target>
        </trans-unit>
        <trans-unit id="21226463d529e8f7d5082c27401d959f905ec4d1" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;. It takes no parameters, and is invoked after a commit is made.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;调用。它不带任何参数，并在提交后被调用。</target>
        </trans-unit>
        <trans-unit id="0a4097349c79cead9de93e647cb9ba47cbed7c91" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes no parameters, and is invoked after the merge has been carried out successfully and before obtaining the proposed commit log message to make a commit. Exiting with a non-zero status from this script causes the &lt;code&gt;git merge&lt;/code&gt; command to abort before creating a commit.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;调用，可以使用 &lt;code&gt;--no-verify&lt;/code&gt; 选项绕过。它不带任何参数，并且在成功执行合并之后并在获取建议的提交日志消息以进行提交之前被调用。从此脚本以非零状态退出会导致 &lt;code&gt;git merge&lt;/code&gt; 命令在创建提交之前中止。</target>
        </trans-unit>
        <trans-unit id="de911dadfd0a4abc2b13baa4ccbc2ae0aca9f055" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, which happens when a &lt;code&gt;git pull&lt;/code&gt; is done on a local repository. The hook takes a single parameter, a status flag specifying whether or not the merge being done was a squash merge. This hook cannot affect the outcome of &lt;code&gt;git merge&lt;/code&gt; and is not executed, if the merge failed due to conflicts.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;调用，这是在本地存储库上执行 &lt;code&gt;git pull&lt;/code&gt; 时发生的。挂钩使用一个参数，一个状态标志，指定要进行的合并是否为壁球合并。如果合并由于冲突而失败，则此钩子不会影响 &lt;code&gt;git merge&lt;/code&gt; 的结果，因此不会执行。</target>
        </trans-unit>
        <trans-unit id="76961cafe28e294daa6f1b287a02eb4fe4bf07aa" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository, and when the push tries to update the branch that is currently checked out and the &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; configuration variable is set to &lt;code&gt;updateInstead&lt;/code&gt;. Such a push by default is refused if the working tree and the index of the remote repository has any difference from the currently checked out commit; when both the working tree and the index match the current commit, they are updated to match the newly pushed tip of the branch. This hook is to be used to override the default behaviour.</source>
          <target state="translated">当&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;对 &lt;code&gt;git push&lt;/code&gt; 作出反应并更新其存储库中的引用时，以及当push尝试更新当前已检出的分支和 &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; 配置变量时，将由git-receive-pack [1]调用此钩子。设置为 &lt;code&gt;updateInstead&lt;/code&gt; 。如果工作树和远程存储库的索引与当前检出的提交有任何区别，则默认情况下将拒绝此类推送；当工作树和索引都与当前提交匹配时，它们将被更新以与分支的新推送尖端匹配。该钩子将用于覆盖默认行为。</target>
        </trans-unit>
        <trans-unit id="5a56dac625f1205849f2b5f6e3619a708d3ea48e" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. It executes on the remote repository once after all the refs have been updated.</source>
          <target state="translated">当它对 &lt;code&gt;git push&lt;/code&gt; 做出反应并更新其存储库中的引用时，该钩子由&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;调用。所有引用均已更新后，它将在远程存储库上执行。</target>
        </trans-unit>
        <trans-unit id="390ce0821ef413eec43c389641cce2dfc9687135" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. Just before starting to update refs on the remote repository, the pre-receive hook is invoked. Its exit status determines the success or failure of the update.</source>
          <target state="translated">当它对 &lt;code&gt;git push&lt;/code&gt; 做出反应并更新其存储库中的引用时，该钩子由&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;调用。在开始更新远程存储库上的引用之前，将调用pre-receive挂钩。其退出状态确定更新的成功或失败。</target>
        </trans-unit>
        <trans-unit id="f508c67d780c6e440d114ab5a4809e8db15887c6" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. Just before updating the ref on the remote repository, the update hook is invoked. Its exit status determines the success or failure of the ref update.</source>
          <target state="translated">当它对 &lt;code&gt;git push&lt;/code&gt; 做出反应并更新其存储库中的引用时，该钩子由&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;调用。在更新远程存储库上的ref之前，将调用更新挂钩。其退出状态确定引用更新的成功或失败。</target>
        </trans-unit>
        <trans-unit id="c165f7e2051fecf641e46f5c29ee35090d7d5f24" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;. If the server has set the multi-valued config variable &lt;code&gt;receive.procReceiveRefs&lt;/code&gt;, and the commands sent to &lt;code&gt;receive-pack&lt;/code&gt; have matching reference names, these commands will be executed by this hook, instead of by the internal &lt;code&gt;execute_commands()&lt;/code&gt; function. This hook is responsible for updating the relevant references and reporting the results back to &lt;code&gt;receive-pack&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c94fc31562e49c2e1f57905c2984b3787d6eb579" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;. It takes a single parameter, the name of the file that holds the e-mail to be sent. Exiting with a non-zero status causes &lt;code&gt;git send-email&lt;/code&gt; to abort before sending any e-mails.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt;调用。它只有一个参数，即保存要发送电子邮件的文件的名称。以非零状态退出会导致 &lt;code&gt;git send-email&lt;/code&gt; 在发送任何电子邮件之前中止。</target>
        </trans-unit>
        <trans-unit id="898dc345a1faef7e78cc6f07a48d416762cf9e72" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git gc --auto&lt;/code&gt; (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;). It takes no parameter, and exiting with non-zero status from this script causes the &lt;code&gt;git gc --auto&lt;/code&gt; to abort.</source>
          <target state="translated">该钩子由 &lt;code&gt;git gc --auto&lt;/code&gt; 调用（请参阅&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;）。它不带任何参数，并且以非零状态退出此脚本会导致 &lt;code&gt;git gc --auto&lt;/code&gt; 中止。</target>
        </trans-unit>
        <trans-unit id="536d2f256146b81297af8f05d9ee07d3c788ff56" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db96373c38bd1df6e078c9fa2b6d9e050d469bb3" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt;. It takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevent &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. It can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; command line option. Run &lt;code&gt;git-p4 submit --help&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa504b80ab7d4ab7fd02bb1c09f7267f7ffd0b87" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt;. It takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevent &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. Run &lt;code&gt;git-p4 submit --help&lt;/code&gt; for details.</source>
          <target state="translated">这个钩子由 &lt;code&gt;git-p4 submit&lt;/code&gt; 调用。它不带参数，标准输入也不带任何内容。从此脚本以非零状态退出会阻止 &lt;code&gt;git-p4 submit&lt;/code&gt; 启动。运行 &lt;code&gt;git-p4 submit --help&lt;/code&gt; 以获得详细信息。</target>
        </trans-unit>
        <trans-unit id="e343164b203dd1de0ba3f9a30c792df16e0f19da" translate="yes" xml:space="preserve">
          <source>This hook is invoked by any Git command that performs reference updates. It executes whenever a reference transaction is prepared, committed or aborted and may thus get called multiple times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8569f58a670ba9d05dfd0c2191295df64e04e73" translate="yes" xml:space="preserve">
          <source>This hook is invoked by commands that rewrite commits (&lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; when called with &lt;code&gt;--amend&lt;/code&gt; and &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;; however, full-history (re)writing tools like &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import[1]&lt;/a&gt; or &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; typically do not call it!). Its first argument denotes the command it was invoked by: currently one of &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;. Further command-dependent arguments may be passed in the future.</source>
          <target state="translated">该钩子由重写提交的命令调用（&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;用 &lt;code&gt;--amend&lt;/code&gt; 和&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;调用时；但是，完整的历史（重新）编写工具，例如&lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import [1]&lt;/a&gt;或&lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt;通常不调用它！）。它的第一个参数表示由其调用的命令：当前为 &lt;code&gt;amend&lt;/code&gt; 或 &lt;code&gt;rebase&lt;/code&gt; 之一。将来可能会传递更多与命令有关的参数。</target>
        </trans-unit>
        <trans-unit id="8c8dde02f7fe4fac23930e917fd59c1d03fbfa8b" translate="yes" xml:space="preserve">
          <source>This hook is invoked when a &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; or &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; is run after having updated the worktree. The hook is given three parameters: the ref of the previous HEAD, the ref of the new HEAD (which may or may not have changed), and a flag indicating whether the checkout was a branch checkout (changing branches, flag=1) or a file checkout (retrieving a file from the index, flag=0). This hook cannot affect the outcome of &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt;, other than that the hook&amp;rsquo;s exit status becomes the exit status of these two commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b20b75526e2af7ef8179932e884a838f68429b3" translate="yes" xml:space="preserve">
          <source>This hook is invoked when a &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; or &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; is run after having updated the worktree. The hook is given three parameters: the ref of the previous HEAD, the ref of the new HEAD (which may or may not have changed), and a flag indicating whether the checkout was a branch checkout (changing branches, flag=1) or a file checkout (retrieving a file from the index, flag=0). This hook cannot affect the outcome of &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt;.</source>
          <target state="translated">更新工作树后运行&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;或&lt;a href=&quot;git-switch&quot;&gt;git-switch [1]&lt;/a&gt;时，将调用此挂钩。挂钩具有三个参数：前一个HEAD的ref，新HEAD的ref（可能已更改，也可能未更改）和一个标志，指示签出是否为分支签出（更改分支，flag = 1）或文件检出（从索引中检索文件，标志= 0）。这个钩子不会影响 &lt;code&gt;git switch&lt;/code&gt; 或 &lt;code&gt;git checkout&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="fd3ae42761b9b86d30d029aa1493872ff1533f42" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the configuration option &lt;code&gt;core.fsmonitor&lt;/code&gt; is set to &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt; or &lt;code&gt;.git/hooks/fsmonitor-watchmanv2&lt;/code&gt; depending on the version of the hook to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0692c459d4a723afc690b678a8556c7e5d3814" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the configuration option &lt;code&gt;core.fsmonitor&lt;/code&gt; is set to &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt;. It takes two arguments, a version (currently 1) and the time in elapsed nanoseconds since midnight, January 1, 1970.</source>
          <target state="translated">当配置选项 &lt;code&gt;core.fsmonitor&lt;/code&gt; 设置为 &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt; watchman时，将调用此挂钩。它需要两个参数，一个版本（当前为1），以及自1970年1月1日午夜以来经过的时间（以纳秒为单位）。</target>
        </trans-unit>
        <trans-unit id="1ea8190ee0fad5a3aca31c578a724c322c0d57cb" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the index is written in read-cache.c do_write_locked_index.</source>
          <target state="translated">这个钩子在read-cache.c do_write_locked_index中写入索引时被调用。</target>
        </trans-unit>
        <trans-unit id="bbcd7cc3d137fc9e83cb037a7ffe28a3a104cf5b" translate="yes" xml:space="preserve">
          <source>This hook is invoked with the environment variable &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; if the command will not bring up an editor to modify the commit message.</source>
          <target state="translated">如果该命令不会调出编辑器来修改提交消息，则使用环境变量 &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; 调用此挂钩。</target>
        </trans-unit>
        <trans-unit id="ddc7ece9286909c0de44abe41d5a762b67552ed5" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">这个钩子主要用于通知，不会影响 &lt;code&gt;git am&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="448e187d53f17c70cda00f92a3ee55c4bde07472" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">这个钩子主要用于通知，不会影响 &lt;code&gt;git commit&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="08260832c28c95684a1993d7203db5c6a733006a" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git receive-pack&lt;/code&gt;.</source>
          <target state="translated">这个钩子主要用于通知，并且不会影响 &lt;code&gt;git receive-pack&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="f1b9eafafbdf014b8c082347223fc7e3e439cd3c" translate="yes" xml:space="preserve">
          <source>This implies &lt;code&gt;--revs&lt;/code&gt;. In addition to the list of revision arguments read from the standard input, pretend as if all refs under &lt;code&gt;refs/&lt;/code&gt; are specified to be included.</source>
          <target state="translated">这意味着 &lt;code&gt;--revs&lt;/code&gt; 。除了从标准输入中读取的修订参数列表之外，还假装好像已指定 &lt;code&gt;refs/&lt;/code&gt; 下的所有ref 。</target>
        </trans-unit>
        <trans-unit id="00f6fe101136dac1c604175fe5bf787266d15317" translate="yes" xml:space="preserve">
          <source>This implies &lt;code&gt;--revs&lt;/code&gt;. When processing the list of revision arguments read from the standard input, limit the objects packed to those that are not already packed.</source>
          <target state="translated">这意味着 &lt;code&gt;--revs&lt;/code&gt; 。处理从标准输入中读取的修订参数列表时，请将打包的对象限制为尚未打包的对象。</target>
        </trans-unit>
        <trans-unit id="23abf25dbec44cc1a257bc71a457bb760d4a79eb" translate="yes" xml:space="preserve">
          <source>This implies the &lt;code&gt;--topo-order&lt;/code&gt; option by default, but the &lt;code&gt;--date-order&lt;/code&gt; option may also be specified.</source>
          <target state="translated">这意味着默认情况下 &lt;code&gt;--topo-order&lt;/code&gt; 选项，但也可以指定 &lt;code&gt;--date-order&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="9bafb6d097d43ca4ccca730edb887425acfba8b5" translate="yes" xml:space="preserve">
          <source>This imports the specified depot into &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; in an existing Git repository. The &lt;code&gt;--branch&lt;/code&gt; option can be used to specify a different branch to be used for the p4 content.</source>
          <target state="translated">这会将指定的软件仓库导入到现有Git存储库中的 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; 中。该 &lt;code&gt;--branch&lt;/code&gt; 选项可用于指定不同的分支，以用于P4内容。</target>
        </trans-unit>
        <trans-unit id="5a7c7788d041aa1a2f51fc279f1f6f7da23ae666" translate="yes" xml:space="preserve">
          <source>This indicates that the helper is able to interact with the remote side using an explicit hash algorithm extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505428074ae07b004fad59f4eaeb272274ac2c6b" translate="yes" xml:space="preserve">
          <source>This information can be used to determine what commit was the tip of a branch &quot;2 days ago&quot;.</source>
          <target state="translated">这些信息可以用来确定 &quot;2天前 &quot;的分支是什么提交。</target>
        </trans-unit>
        <trans-unit id="86187244d1368864bf6af8ccb054656e32b6a58b" translate="yes" xml:space="preserve">
          <source>This instructs git svn to recode pathnames to a given encoding. It can be used by windows users and by those who work in non-utf8 locales to avoid corrupted file names with non-ASCII characters. Valid encodings are the ones supported by Perl&amp;rsquo;s Encode module.</source>
          <target state="translated">这指示git svn将路径名重新编码为给定的编码。Windows用户和在非utf8语言环境中工作的人员都可以使用它，以避免使用非ASCII字符损坏文件名。有效的编码是Perl的Encode模块支持的编码。</target>
        </trans-unit>
        <trans-unit id="956c7627c61d83f78ef967d8ba93fedd722fb328" translate="yes" xml:space="preserve">
          <source>This integer config option controls how often the &lt;code&gt;commit-graph&lt;/code&gt; task should be run as part of &lt;code&gt;git maintenance run --auto&lt;/code&gt;. If zero, then the &lt;code&gt;commit-graph&lt;/code&gt; task will not run with the &lt;code&gt;--auto&lt;/code&gt; option. A negative value will force the task to run every time. Otherwise, a positive value implies the command should run when the number of reachable commits that are not in the commit-graph file is at least the value of &lt;code&gt;maintenance.commit-graph.auto&lt;/code&gt;. The default value is 100.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0909b4167b1b6cfc93db8cafdc74248d3901c792" translate="yes" xml:space="preserve">
          <source>This is a deprecated synonym for &lt;code&gt;repack.writeBitmaps&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; 的不赞成使用的同义词。</target>
        </trans-unit>
        <trans-unit id="0663f3ff3f5e643bb58ee19e6a44fd14680c40d5" translate="yes" xml:space="preserve">
          <source>This is a login shell for SSH accounts to provide restricted Git access. It permits execution only of server-side Git commands implementing the pull/push functionality, plus custom commands present in a subdirectory named &lt;code&gt;git-shell-commands&lt;/code&gt; in the user&amp;rsquo;s home directory.</source>
          <target state="translated">这是SSH帐户的登录外壳，用于提供受限制的Git访问。它仅允许执行实现拉/推功能的服务器端Git命令，以及用户主目录中名为 &lt;code&gt;git-shell-commands&lt;/code&gt; 的子目录中存在的自定义命令。</target>
        </trans-unit>
        <trans-unit id="bb9b1700493e02e1c42808252a2a81a90b07f06f" translate="yes" xml:space="preserve">
          <source>This is a modified recursive strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree.</source>
          <target state="translated">这是一种修改后的递归策略。在合并树A和B时,如果B对应A的子树,则首先调整B,使之与A的树结构相匹配,而不是读取同一层次的树。这种调整也是对共同祖先树进行的。</target>
        </trans-unit>
        <trans-unit id="9ebc5555eb7976dd79439890cefef50e4fca7252" translate="yes" xml:space="preserve">
          <source>This is a multi-valued variable that defines reference prefixes to match the commands in &lt;code&gt;receive-pack&lt;/code&gt;. Commands matching the prefixes will be executed by an external hook &quot;proc-receive&quot;, instead of the internal &lt;code&gt;execute_commands&lt;/code&gt; function. If this variable is not defined, the &quot;proc-receive&quot; hook will never be used, and all commands will be executed by the internal &lt;code&gt;execute_commands&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94478372a5a22fcace1286299ca604a903c0373f" translate="yes" xml:space="preserve">
          <source>This is a multi-valued variable, and an empty value can be used in a higher priority configuration file (e.g. &lt;code&gt;.git/config&lt;/code&gt; in a repository) to clear the values inherited from a lower priority configuration files (e.g. &lt;code&gt;$HOME/.gitconfig&lt;/code&gt;).</source>
          <target state="translated">这是一个多值变量，可以在较高优先级的配置文件（例如，存储库中的 &lt;code&gt;.git/config&lt;/code&gt; )中使用空值，以清除从较低优先级的配置文件（例如 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; ）继承的值。。</target>
        </trans-unit>
        <trans-unit id="9800795b0feafe785919ba7eb03d901a5af98b6d" translate="yes" xml:space="preserve">
          <source>This is a potentially &lt;em&gt;dangerous&lt;/em&gt; mode of operation. It rewrites history, which does not bode well when you published that history already. Do &lt;strong&gt;not&lt;/strong&gt; use this option unless you have read &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; carefully.</source>
          <target state="translated">这是潜在的&lt;em&gt;危险&lt;/em&gt;操作模式。它会重写历史记录，当您已经发布该历史记录时，这并不是一个好兆头。难道&lt;strong&gt;不&lt;/strong&gt;除非您已经阅读使用此选项&lt;a href=&quot;git-rebase&quot;&gt;的git-底垫[1]&lt;/a&gt;小心。</target>
        </trans-unit>
        <trans-unit id="7393bcbfeab09d874001a82423e807bb091915e9" translate="yes" xml:space="preserve">
          <source>This is a quick summary of the major commands; the previous chapters explain how these work in more detail.</source>
          <target state="translated">这是对主要命令的快速总结;前面的章节将更详细地解释这些命令如何工作。</target>
        </trans-unit>
        <trans-unit id="e6b70a1472f7c00669a56c92197ed227d5be5866" translate="yes" xml:space="preserve">
          <source>This is a shorthand for &quot;--pretty=oneline --abbrev-commit&quot; used together.</source>
          <target state="translated">这是&quot;-pretty=oneline--abbrev-commit &quot;一起使用的速记。</target>
        </trans-unit>
        <trans-unit id="18c84bcba1b16c1ac1cf14d08c1c68d27e4599a1" translate="yes" xml:space="preserve">
          <source>This is a total waste of time and effort on a filesystem that orders data writes properly, but can be useful for filesystems that do not use journalling (traditional UNIX filesystems) or that only journal metadata and not file contents (OS X&amp;rsquo;s HFS+, or Linux ext3 with &quot;data=writeback&quot;).</source>
          <target state="translated">订购正确写入数据的文件系统会浪费时间和精力，但对于不使用日志记录的文件系统（传统的UNIX文件系统）或仅记录日志元数据而不是文件内容的文件系统（OS X的HFS +或Linux）很有用ext3和&amp;ldquo; data = writeback&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="554ab63db8a74b017dac093a21d0557d821484db" translate="yes" xml:space="preserve">
          <source>This is a toy format. The current time and time zone of this system is always copied into the identity string at the time it is being created by fast-import. There is no way to specify a different time or time zone.</source>
          <target state="translated">这是一个玩具格式。在fast-import创建系统时,这个系统的当前时间和时区总是被复制到身份字符串中。没有办法指定不同的时间或时区。</target>
        </trans-unit>
        <trans-unit id="bc30d84517d5f02b55a3811eba6ffba9e6c0e4f0" translate="yes" xml:space="preserve">
          <source>This is a work in progress.</source>
          <target state="translated">这是一项正在进行中的工作。</target>
        </trans-unit>
        <trans-unit id="cdf94d586f4e34dd4d9c37fe3a3dd3a90ee94301" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;--group=committer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e77feb91313add3d7aff3491329020f7cd2b88e" translate="yes" xml:space="preserve">
          <source>This is an easy way to check out a particular version without having to make up a name for the new branch. You can still create a new branch (or tag) for this version later if you decide to.</source>
          <target state="translated">这是个简单的方法,可以在不为新分支取名的情况下检查出一个特定的版本。如果您决定为这个版本创建一个新的分支(或标签),您仍然可以在以后为其创建一个新的分支。</target>
        </trans-unit>
        <trans-unit id="86d03a90949a936d437c536daea902a3352ca567" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;rebase&lt;/code&gt; is used in a workflow that treats the history at the remote as the shared canonical one, and treats the work done on the branch you are rebasing as the third-party work to be integrated, and you are temporarily assuming the role of the keeper of the canonical history during the rebase. As the keeper of the canonical history, you need to view the history from the remote as &lt;code&gt;ours&lt;/code&gt; (i.e. &quot;our shared canonical history&quot;), while what you did on your side branch as &lt;code&gt;theirs&lt;/code&gt; (i.e. &quot;one contributor&amp;rsquo;s work on top of it&quot;).</source>
          <target state="translated">这是因为在工作流中使用了 &lt;code&gt;rebase&lt;/code&gt; ，该工作流将远程站点上的历史记录视为共享规范，并将您要重新部署的分支上完成的工作视为要集成的第三方工作，并且您暂时担当了该角色改组期间的规范历史保持者。作为规范历史的保存者，您需要从远程查看与 &lt;code&gt;ours&lt;/code&gt; 一样的历史（即&amp;ldquo;我们共享的规范历史&amp;rdquo;），而您在分支机构所做的工作就是作为 &lt;code&gt;theirs&lt;/code&gt; （即&amp;ldquo;一个贡献者的工作&amp;rdquo;）。 ）。</target>
        </trans-unit>
        <trans-unit id="95a20fc02bc3cd4094f682df1ea1f755e327d688" translate="yes" xml:space="preserve">
          <source>This is called a &lt;code&gt;hunk header&lt;/code&gt;. The &quot;TEXT&quot; portion is by default a line that begins with an alphabet, an underscore or a dollar sign; this matches what GNU &lt;code&gt;diff -p&lt;/code&gt; output uses. This default selection however is not suited for some contents, and you can use a customized pattern to make a selection.</source>
          <target state="translated">这称为 &lt;code&gt;hunk header&lt;/code&gt; 。默认情况下，&amp;ldquo; TEXT&amp;rdquo;部分是以字母，下划线或美元符号开头的行；这与GNU &lt;code&gt;diff -p&lt;/code&gt; 输出使用的匹配。但是，此默认选择不适用于某些内容，您可以使用自定义模式进行选择。</target>
        </trans-unit>
        <trans-unit id="85de32d717921314245903361d4033db93188253" translate="yes" xml:space="preserve">
          <source>This is default name of common system-wide configuration file.</source>
          <target state="translated">这是全系统通用配置文件的默认名称。</target>
        </trans-unit>
        <trans-unit id="8fabc38be889239efec56b25dba57afb3b308b5b" translate="yes" xml:space="preserve">
          <source>This is default name of fallback system-wide configuration file. This file is used only if per-instance configuration variable is not found.</source>
          <target state="translated">这是回退系统范围内配置文件的默认名称。只有在没有找到每个实例的配置变量时,才会使用该文件。</target>
        </trans-unit>
        <trans-unit id="e13cac7eff842df90d7031a70a4150ab3a8cdbc2" translate="yes" xml:space="preserve">
          <source>This is default name of per-instance configuration file. The format of this file is described above.</source>
          <target state="translated">这是每个实例配置文件的默认名称。该文件的格式如上所述。</target>
        </trans-unit>
        <trans-unit id="2ac99b50de3702f5d543e44c6b1ddc55b08d7471" translate="yes" xml:space="preserve">
          <source>This is designed to be as compact as possible.</source>
          <target state="translated">这样设计是为了尽可能的紧凑。</target>
        </trans-unit>
        <trans-unit id="d4d30dfd1772dd73a7b51cd065bd14037d1044bf" translate="yes" xml:space="preserve">
          <source>This is done to prevent you from losing your work-in-progress changes, and mixing your random changes in an unrelated merge commit. To illustrate, suppose you start from what has been committed last to your repository:</source>
          <target state="translated">这样做的目的是为了防止丢失正在进行中的修改,以及将随机的修改混入不相关的合并提交中。为了说明这一点,假设你从最后提交到版本库的内容开始。</target>
        </trans-unit>
        <trans-unit id="c5483036881ec5a0c568843866e403149495194d" translate="yes" xml:space="preserve">
          <source>This is how you read a blob (actually, not only a blob, but any type of object). To know how the function &lt;code&gt;read_object_with_reference()&lt;/code&gt; actually works, find the source code for it (something like &lt;code&gt;git grep
read_object_with | grep &quot;:[a-z]&quot;&lt;/code&gt; in the Git repository), and read the source.</source>
          <target state="translated">这就是读取blob（实际上，不仅是blob，而且是任何类型的对象）的方式。要了解 &lt;code&gt;read_object_with_reference()&lt;/code&gt; 函数的实际工作方式，请找到该函数的源代码（类似于 &lt;code&gt;git grep read_object_with | grep &quot;:[a-z]&quot;&lt;/code&gt; 在Git存储库中），然后阅读源代码。</target>
        </trans-unit>
        <trans-unit id="d94f65e687e225292db2cabccebd8f5b3adaa1d5" translate="yes" xml:space="preserve">
          <source>This is ideally suited for read-only updates, i.e., pulling from Git repositories.</source>
          <target state="translated">这非常适合于只读更新,即从Git仓库中拉取。</target>
        </trans-unit>
        <trans-unit id="4f74abb17322f51c4e08c52446429282a69cbb4c" translate="yes" xml:space="preserve">
          <source>This is intended to be used by the test suite only. It allows to force the version for the generated pack index, and to force 64-bit index entries on objects located above the given offset.</source>
          <target state="translated">这仅用于测试套件。它允许强制生成包索引的版本,并强制位于给定偏移量以上的对象的64位索引条目。</target>
        </trans-unit>
        <trans-unit id="8180429180a5d33dfa16e7d2805d2ac9f53f061d" translate="yes" xml:space="preserve">
          <source>This is just to get you into the groove for the most libified part of Git: the revision walker.</source>
          <target state="translated">这只是为了让你进入Git最解放的部分:修订行者。</target>
        </trans-unit>
        <trans-unit id="dce30f3fbb0be29025f159d55505215087cce86b" translate="yes" xml:space="preserve">
          <source>This is known to &lt;code&gt;range-diff&lt;/code&gt; as &quot;dual coloring&quot;. Use &lt;code&gt;--no-dual-color&lt;/code&gt; to revert to color all lines according to the outer diff markers (and completely ignore the inner diff when it comes to color).</source>
          <target state="translated">这是已知的 &lt;code&gt;range-diff&lt;/code&gt; &amp;ldquo;双重着色&amp;rdquo;。使用 &lt;code&gt;--no-dual-color&lt;/code&gt; 可以根据外部差异标记对所有行进行着色（在涉及颜色时完全忽略内部差异）。</target>
        </trans-unit>
        <trans-unit id="51ecbd5eaeeeee461a4969f3b0cb27dc975ebc23" translate="yes" xml:space="preserve">
          <source>This is made much worse if many files have to be fixed to resolve conflicts. That&amp;rsquo;s why such merges are called &quot;evil merges&quot;. They can make regressions very difficult to track down. It can even be misleading to know the first bad commit if it happens to be such a merge, because people might think that the bug comes from bad conflict resolution when it comes from a semantic change in one branch.</source>
          <target state="translated">如果必须修复许多文件以解决冲突，则情况将更加糟糕。这就是为什么这种合并称为&amp;ldquo;邪恶合并&amp;rdquo;的原因。它们可能使回归非常难以追踪。如果碰巧是这样的合并，那么知道第一个错误的提交甚至可能会产生误导，因为人们可能会认为该错误来自错误的冲突解决，而该错​​误来自一个分支中的语义更改。</target>
        </trans-unit>
        <trans-unit id="2742189647afc1dbda2e1e2ecc6c9303cbb2d70b" translate="yes" xml:space="preserve">
          <source>This is meant to be used by higher level scripts to compute merge results outside of the index, and stuff the results back into the index. For this reason, the output from the command omits entries that match the &amp;lt;branch1&amp;gt; tree.</source>
          <target state="translated">这意味着更高级别的脚本将使用它来计算索引之外的合并结果，并将结果填充回索引中。因此，命令的输出将省略与&amp;lt;branch1&amp;gt;树匹配的条目。</target>
        </trans-unit>
        <trans-unit id="9ccf843e585a34e60ae505f61685a10813c9c88a" translate="yes" xml:space="preserve">
          <source>This is most often done when you remembered what you just committed is incomplete, or you misspelled your commit message, or both. Leaves working tree as it was before &quot;reset&quot;.</source>
          <target state="translated">最常见的情况是,当你想起刚刚提交的内容不完整,或者你拼错了提交信息,或者两者都有。让工作树保持 &quot;重置 &quot;前的状态。</target>
        </trans-unit>
        <trans-unit id="efff48b2c5bed4c5ab6435b6d058280a53664967" translate="yes" xml:space="preserve">
          <source>This is not a command the end user would want to run. Ever. This documentation is meant for people who are studying the Porcelain-ish scripts and/or are writing new ones.</source>
          <target state="translated">这不是一个终端用户想要运行的命令。永远不会。这篇文档是为那些正在研究瓷器类脚本和/或正在编写新脚本的人准备的。</target>
        </trans-unit>
        <trans-unit id="4c9e09ba77ce1340a426d6ae669add42a4fe4542" translate="yes" xml:space="preserve">
          <source>This is not a real filter executed for each commit but a one time setup just before the loop. Therefore no commit-specific variables are defined yet. Functions or variables defined here can be used or modified in the following filter steps except the commit filter, for technical reasons.</source>
          <target state="translated">这不是为每次提交执行的真正的过滤器,而是在循环之前的一次性设置。因此,目前还没有定义针对提交的变量。由于技术原因,这里定义的函数或变量可以在下面的过滤步骤中使用或修改,但提交过滤除外。</target>
        </trans-unit>
        <trans-unit id="ad1d1c10cd51125ef48d021d8c7283be0413a66d" translate="yes" xml:space="preserve">
          <source>This is not hard to understand, as soon as you realize that Git simply never knows (or cares) about files that it is not told about explicitly. Git will never go &lt;strong&gt;looking&lt;/strong&gt; for files to compare, it expects you to tell it what the files are, and that&amp;rsquo;s what the index is there for.</source>
          <target state="translated">这一点并不难理解，只要您意识到Git根本就不知道（或关心）没有明确告知它的文件。Git永远不会&lt;strong&gt;寻找&lt;/strong&gt;要比较的文件，它希望您告诉它文件是什么，这就是索引的用途。</target>
        </trans-unit>
        <trans-unit id="0273358cae89a5a683cca4bca340f2d1ab3cc600" translate="yes" xml:space="preserve">
          <source>This is only used by git-completion.bash to add or remove commands from the list of completed commands. Normally only porcelain commands and a few select others are completed. You can add more commands, separated by space, in this variable. Prefixing the command with &lt;code&gt;-&lt;/code&gt; will remove it from the existing list.</source>
          <target state="translated">git-completion.bash仅使用它从已完成的命令列表中添加或删除命令。通常，仅完成瓷器命令和一些其他命令。您可以在此变量中添加更多命令，以空格分隔。在命令前面加上 &lt;code&gt;-&lt;/code&gt; 会将其从现有列表中删除。</target>
        </trans-unit>
        <trans-unit id="fcaf558e1ca35a6c93dcb363081455cef6ced8a0" translate="yes" xml:space="preserve">
          <source>This is only valid for &amp;lt;end&amp;gt; and will specify a number of lines before or after the line given by &amp;lt;start&amp;gt;.</source>
          <target state="translated">这仅对&amp;lt;end&amp;gt;有效，并将在&amp;lt;start&amp;gt;给定的行之前或之后指定多行。</target>
        </trans-unit>
        <trans-unit id="1b0501180252ff128dca83458515deca695a7ecc" translate="yes" xml:space="preserve">
          <source>This is optional and is only searched when &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; is present in $GIT_DIR/config.</source>
          <target state="translated">这是可选的，仅当$ GIT_DIR / config中存在 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 时才搜索。</target>
        </trans-unit>
        <trans-unit id="4306207006bf4fdd2134f4efea5f0d698d2c1f81" translate="yes" xml:space="preserve">
          <source>This is particularly true when passing in diff options. Currently some options like &lt;code&gt;--stat&lt;/code&gt; can, as an emergent effect, produce output that&amp;rsquo;s quite useless in the context of &lt;code&gt;range-diff&lt;/code&gt;. Future versions of &lt;code&gt;range-diff&lt;/code&gt; may learn to interpret such options in a manner specific to &lt;code&gt;range-diff&lt;/code&gt; (e.g. for &lt;code&gt;--stat&lt;/code&gt; producing human-readable output which summarizes how the diffstat changed).</source>
          <target state="translated">当传递diff选项时尤其如此。目前，诸如 &lt;code&gt;--stat&lt;/code&gt; 之类的一些选项作为一种紧急效果可以产生在 &lt;code&gt;range-diff&lt;/code&gt; 上下文中非常无用的输出。未来版本的 &lt;code&gt;range-diff&lt;/code&gt; 可能会学习以特定于 &lt;code&gt;range-diff&lt;/code&gt; 的方式来解释此类选项（例如，用于 &lt;code&gt;--stat&lt;/code&gt; 产生人类可读的输出，其中总结了diffstat的变化）。</target>
        </trans-unit>
        <trans-unit id="c2dfec9fbb580524d9c87ce7e3303a7b47cc295d" translate="yes" xml:space="preserve">
          <source>This is passed to both underlying git-fetch to squelch reporting of during transfer, and underlying git-merge to squelch output during merging.</source>
          <target state="translated">这将被传递给底层的 git-fetch 来压制传输过程中的报告,以及底层的 git-merge 来压制合并过程中的输出。</target>
        </trans-unit>
        <trans-unit id="3d17e8f742373c8bbf1871e58142a3d3c4b1c09b" translate="yes" xml:space="preserve">
          <source>This is per-repository enhancement / version of global prefix-based &lt;code&gt;@git_base_url_list&lt;/code&gt; gitweb configuration variable (see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;).</source>
          <target state="translated">这是基于存储库的增强功能/基于全局前缀的 &lt;code&gt;@git_base_url_list&lt;/code&gt; gitweb配置变量的版本（请参见&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a7bcc6783fe2c533eb40b84879a83d32f4d95dc9" translate="yes" xml:space="preserve">
          <source>This is similar to --symbolic, but it omits input that are not refs (i.e. branch or tag names; or more explicitly disambiguating &quot;heads/master&quot; form, when you want to name the &quot;master&quot; branch when there is an unfortunately named tag &quot;master&quot;), and show them as full refnames (e.g. &quot;refs/heads/master&quot;).</source>
          <target state="translated">这与 --symbolic 类似,但它省略了不是 refs 的输入(即分支或标记名称;或者更明确地以 &quot;head/master &quot;的形式,当你想命名 &quot;master &quot;分支时,不幸的是有一个命名为 &quot;master &quot;的标记),并将它们显示为完整的 refs 名称(例如 &quot;refs/heads/master&quot;)。</target>
        </trans-unit>
        <trans-unit id="4cae7dda407705febf1be1d8f0d77956238a429a" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;info/grafts&lt;/code&gt; but is internally used and maintained by shallow clone mechanism. See &lt;code&gt;--depth&lt;/code&gt; option to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; and &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;. This file is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/shallow&quot; will be used instead.</source>
          <target state="translated">这类似于 &lt;code&gt;info/grafts&lt;/code&gt; 但在内部由浅克隆机制使用和维护。参见&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;和&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]的&lt;/a&gt; &lt;code&gt;--depth&lt;/code&gt; 选项。如果设置了$ GIT_COMMON_DIR，该文件将被忽略，而将使用&amp;ldquo; $ GIT_COMMON_DIR / shallow&amp;rdquo;代替。</target>
        </trans-unit>
        <trans-unit id="44c5e44a5b0e8e88feba4a9ab4b3411e28cf0521" translate="yes" xml:space="preserve">
          <source>This is similar to the previous mode, but lets you use the interactive interface to show the &quot;diff&quot; output and choose which hunks to use in the result. See below for the description of &lt;code&gt;--patch&lt;/code&gt; option.</source>
          <target state="translated">这与以前的模式相似，但是允许您使用交互式界面显示&amp;ldquo; diff&amp;rdquo;输出并选择要在结果中使用的块。有关 &lt;code&gt;--patch&lt;/code&gt; 选项的说明，请参见下文。</target>
        </trans-unit>
        <trans-unit id="6d4677f97f18bb53a7088b838331f1fec5e57df8" translate="yes" xml:space="preserve">
          <source>This is synonymous to the earlier form (without the &quot;..&quot;) for viewing the changes between two arbitrary &amp;lt;commit&amp;gt;. If &amp;lt;commit&amp;gt; on one side is omitted, it will have the same effect as using HEAD instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4054020991b3f63ee43241d99b871a192e5f7888" translate="yes" xml:space="preserve">
          <source>This is synonymous to the previous form. If &amp;lt;commit&amp;gt; on one side is omitted, it will have the same effect as using HEAD instead.</source>
          <target state="translated">这与以前的形式同义。如果省略了一侧的&amp;lt;commit&amp;gt;，它将具有与使用HEAD相同的效果。</target>
        </trans-unit>
        <trans-unit id="75478eb48b06b2098532610f52369c54c5a35766" translate="yes" xml:space="preserve">
          <source>This is the Git native format and is &lt;code&gt;&amp;lt;time&amp;gt; SP &amp;lt;offutc&amp;gt;&lt;/code&gt;. It is also fast-import&amp;rsquo;s default format, if --date-format was not specified.</source>
          <target state="translated">这是Git本机格式，并且是 &lt;code&gt;&amp;lt;time&amp;gt; SP &amp;lt;offutc&amp;gt;&lt;/code&gt; 。如果未指定--date-format，它也是快速导入的默认格式。</target>
        </trans-unit>
        <trans-unit id="6bd79ba5c8340a61cc49527317aae865e2230698" translate="yes" xml:space="preserve">
          <source>This is the filter for performing the commit. If this filter is specified, it will be called instead of the &lt;code&gt;git commit-tree&lt;/code&gt; command, with arguments of the form &quot;&amp;lt;TREE_ID&amp;gt; [(-p &amp;lt;PARENT_COMMIT_ID&amp;gt;)&amp;hellip;​]&quot; and the log message on stdin. The commit id is expected on stdout.</source>
          <target state="translated">这是用于执行提交的过滤器。如果指定了该过滤器，它将被调用，而不是 &lt;code&gt;git commit-tree&lt;/code&gt; 命令，与以下形式的参数&amp;ldquo;&amp;lt;TREE_ID&amp;gt; [（-p &amp;lt;PARENT_COMMIT_ID&amp;gt;）...]&amp;rdquo;和在stdin日志消息。提交ID应该在标准输出上。</target>
        </trans-unit>
        <trans-unit id="ab02ed108f018595c9832dcfce47c6a593278667" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting tag names. When passed, it will be called for every tag ref that points to a rewritten object (or to a tag object which points to a rewritten object). The original tag name is passed via standard input, and the new tag name is expected on standard output.</source>
          <target state="translated">这是重写标签名的过滤器。通过后,它将对指向重写对象(或指向重写对象的标签对象)的每个标签 ref 进行调用。原始的标签名通过标准输入传递,而新的标签名则在标准输出中被期待。</target>
        </trans-unit>
        <trans-unit id="ec46b5cef98509f43f653471ea24de2e709b0b36" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the commit messages. The argument is evaluated in the shell with the original commit message on standard input; its standard output is used as the new commit message.</source>
          <target state="translated">这是用于重写提交信息的过滤器,参数在shell中用标准输入的原始提交信息进行评估,其标准输出作为新的提交信息。参数在shell中以标准输入的原始提交信息进行评估,其标准输出作为新的提交信息。</target>
        </trans-unit>
        <trans-unit id="baaf77805fbcb910ae11f451b39d9e38daaa6669" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the commit&amp;rsquo;s parent list. It will receive the parent string on stdin and shall output the new parent string on stdout. The parent string is in the format described in &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt;: empty for the initial commit, &quot;-p parent&quot; for a normal commit and &quot;-p parent1 -p parent2 -p parent3 &amp;hellip;​&quot; for a merge commit.</source>
          <target state="translated">这是用于重写提交的父列表的过滤器。它将在stdin上接收父字符串，并在stdout上输出新的父字符串。父字符串采用&lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]中&lt;/a&gt;描述的格式：初始提交为空，普通提交为&amp;ldquo; -p父&amp;rdquo;，合并为&amp;ldquo; -p父1 -p父2 -p父3&amp;hellip;&amp;rdquo;。承诺。</target>
        </trans-unit>
        <trans-unit id="ed6796eee1e84719fc79503aec05a2585b0a98ee" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the index. It is similar to the tree filter but does not check out the tree, which makes it much faster. Frequently used with &lt;code&gt;git rm --cached
--ignore-unmatch ...&lt;/code&gt;, see EXAMPLES below. For hairy cases, see &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">这是用于重写索引的过滤器。它类似于树过滤器，但不检出树，这使它更快。经常与 &lt;code&gt;git rm --cached --ignore-unmatch ...&lt;/code&gt; ，请参见下面的示例。对于多毛的情况，请参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84464b13412e29584cb64fc663c003212ddd470c" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the tree and its contents. The argument is evaluated in shell with the working directory set to the root of the checked out tree. The new tree is then used as-is (new files are auto-added, disappeared files are auto-removed - neither .gitignore files nor any other ignore rules &lt;strong&gt;HAVE ANY EFFECT&lt;/strong&gt;!).</source>
          <target state="translated">这是用于重写树及其内容的过滤器。该参数在shell中评估，且工作目录设置为检出树的根。然后新树被原样使用（新文件是自动添加的，消失的文件是自动删除-既不的.gitignore文件，也没有任何其他无视规则&lt;strong&gt;有任何影响&lt;/strong&gt;！）。</target>
        </trans-unit>
        <trans-unit id="ac6e8f6a01875184858c8585102e8f6aa273aee7" translate="yes" xml:space="preserve">
          <source>This is the format defined by the initial version of git, including but not limited to the format of the repository directory, the repository configuration file, and the object and ref storage. Specifying the complete behavior of git is beyond the scope of this document.</source>
          <target state="translated">这是git初始版本所定义的格式,包括但不限于版本库目录、版本库配置文件、对象和ref存储的格式。指定git的完整行为超出了本文档的范围。</target>
        </trans-unit>
        <trans-unit id="53064adeec7c86c12f0de7129be2018180dbdde8" translate="yes" xml:space="preserve">
          <source>This is the instruction format to copy a byte range from the source object. It encodes the offset to copy from and the number of bytes to copy. Offset and size are in little-endian order.</source>
          <target state="translated">这是从源对象中复制一个字节范围的指令格式。它对要复制的偏移量和要复制的字节数进行编码。偏移量和大小按小字节顺序排列。</target>
        </trans-unit>
        <trans-unit id="7c56810b4cb2a212f096564a869dc50ed111eb3c" translate="yes" xml:space="preserve">
          <source>This is the instruction reserved for future expansion.</source>
          <target state="translated">这是为将来的扩展而保留的指令。</target>
        </trans-unit>
        <trans-unit id="2ac15a186ae4c1add6605d649b034295db99bef1" translate="yes" xml:space="preserve">
          <source>This is the instruction to construct target object without the base object. The following data is appended to the target object. The first seven bits of the first octet determines the size of data in bytes. The size must be non-zero.</source>
          <target state="translated">这是在没有基础对象的情况下构造目标对象的指令。在目标对象中附加以下数据。第一个八位组的前七位决定数据的大小,单位是字节。大小必须为非零。</target>
        </trans-unit>
        <trans-unit id="109ca8035c1b87bb820c08a28a9de7b34fde1bb6" translate="yes" xml:space="preserve">
          <source>This is the opposite of &lt;code&gt;ours&lt;/code&gt;; note that, unlike &lt;code&gt;ours&lt;/code&gt;, there is no &lt;code&gt;theirs&lt;/code&gt; merge strategy to confuse this merge option with.</source>
          <target state="translated">这与 &lt;code&gt;ours&lt;/code&gt; 相反; 请注意，与 &lt;code&gt;ours&lt;/code&gt; 不同，没有 &lt;code&gt;theirs&lt;/code&gt; 合并策略可以混淆此合并选项。</target>
        </trans-unit>
        <trans-unit id="a470bc42a7932d13fef06a087064186d12eef547" translate="yes" xml:space="preserve">
          <source>This is the preferred method.</source>
          <target state="translated">这是首选的方法。</target>
        </trans-unit>
        <trans-unit id="d5ae5cf60359e7831f40d915d7567f63dc115a19" translate="yes" xml:space="preserve">
          <source>This is the same &lt;code&gt;git read-tree&lt;/code&gt; command we have already seen, but it takes three trees, unlike previous examples. This reads the contents of each tree into different &lt;code&gt;stage&lt;/code&gt; in the index file (the first tree goes to stage 1, the second to stage 2, etc.). After reading three trees into three stages, the paths that are the same in all three stages are &lt;code&gt;collapsed&lt;/code&gt; into stage 0. Also paths that are the same in two of three stages are collapsed into stage 0, taking the SHA-1 from either stage 2 or stage 3, whichever is different from stage 1 (i.e. only one side changed from the common ancestor).</source>
          <target state="translated">这是我们已经看到的相同的 &lt;code&gt;git read-tree&lt;/code&gt; 命令，但是它需要三棵树，这与前面的示例不同。这会将每个树的内容读入索引文件中的不同 &lt;code&gt;stage&lt;/code&gt; （第一棵树进入阶段1，第二棵树进入阶段2，依此类推）。将三棵树分为三个阶段后，在所有三个阶段中都相同的路径将 &lt;code&gt;collapsed&lt;/code&gt; 到阶段0中。还将在三个阶段中的两个阶段中相同的路径折叠到阶段0中，并从任一阶段2中获取SHA-1或第3阶段，与第1阶段中的任何一个都不相同（即，从共同祖先开始只改变了一侧）。</target>
        </trans-unit>
        <trans-unit id="d9a78198f4c718b4aad0f141375d5823cd8e39e3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;gitdir&lt;/code&gt; except that matching is done case-insensitively (e.g. on case-insensitive file systems)</source>
          <target state="translated">这与 &lt;code&gt;gitdir&lt;/code&gt; 相同，除了匹配不区分大小写（例如，不区分大小写的文件系统）</target>
        </trans-unit>
        <trans-unit id="6d8ef8c3ff85a1d3362ff60dea809d4867db08e2" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;raw&lt;/code&gt; except that no sanity checks on the numeric epoch and local offset are performed. This can be useful when trying to filter or import an existing history with e.g. bogus timezone values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8eaa3e252f616f4794342341d2f4ec065a52c7" translate="yes" xml:space="preserve">
          <source>This is the standard email format as described by RFC 2822.</source>
          <target state="translated">这是RFC 2822所描述的标准电子邮件格式。</target>
        </trans-unit>
        <trans-unit id="b1825adadaae31865a7ba56f02eeaa58bb1a595e" translate="yes" xml:space="preserve">
          <source>This is the standard helper program to use with &lt;code&gt;git merge-index&lt;/code&gt; to resolve a merge after the trivial merge done with &lt;code&gt;git read-tree -m&lt;/code&gt;.</source>
          <target state="translated">这是与 &lt;code&gt;git merge-index&lt;/code&gt; 一起使用的标准帮助程序，用于在使用 &lt;code&gt;git read-tree -m&lt;/code&gt; 进行微不足道的合并后解决合并。</target>
        </trans-unit>
        <trans-unit id="f4605ef17a6ae238fb7ad1359ce2fc3809a170d2" translate="yes" xml:space="preserve">
          <source>This is the state of the index file and the working file after &lt;code&gt;git merge&lt;/code&gt; returns control back to you, leaving the conflicting merge for you to resolve. Notice that the path &lt;code&gt;hello&lt;/code&gt; is still unmerged, and what you see with &lt;code&gt;git diff&lt;/code&gt; at this point is differences since stage 2 (i.e. your version).</source>
          <target state="translated">这是 &lt;code&gt;git merge&lt;/code&gt; 将控制权交还给您后，索引文件和工作文件的状态，将冲突的合并留给您解决。请注意，路径 &lt;code&gt;hello&lt;/code&gt; 仍未合并，此时您在 &lt;code&gt;git diff&lt;/code&gt; 上看到的是第二阶段以来的差异（即您的版本）。</target>
        </trans-unit>
        <trans-unit id="885013fc19184ff3f87757857452f6badc7e664c" translate="yes" xml:space="preserve">
          <source>This is to emulate &lt;code&gt;git fetch&lt;/code&gt; run on the &lt;code&gt;mothership&lt;/code&gt; using &lt;code&gt;git
push&lt;/code&gt; that is run in the opposite direction in order to integrate the work done on &lt;code&gt;satellite&lt;/code&gt;, and is often necessary when you can only make connection in one way (i.e. satellite can ssh into mothership but mothership cannot initiate connection to satellite because the latter is behind a firewall or does not run sshd).</source>
          <target state="translated">这是为了使用相反方向运行的 &lt;code&gt;git push&lt;/code&gt; 模拟在 &lt;code&gt;mothership&lt;/code&gt; 上运行的 &lt;code&gt;git fetch&lt;/code&gt; ，以便集成在 &lt;code&gt;satellite&lt;/code&gt; 完成的工作，并且在您只能以一种方式建立连接时（例如，人造卫星可以ssh进入母舰）通常是必需的但母权关系无法启动与卫星的连接，因为后者位于防火墙后面或未运行sshd）。</target>
        </trans-unit>
        <trans-unit id="a0fbffa526980249cc459b3697ae082d2fb16d12" translate="yes" xml:space="preserve">
          <source>This is to view the changes between two arbitrary &amp;lt;commit&amp;gt;.</source>
          <target state="translated">这是为了查看两个任意&amp;lt;commit&amp;gt;之间的更改。</target>
        </trans-unit>
        <trans-unit id="2ccd3734f230a6bccf87e0841ef19acfd1763ec7" translate="yes" xml:space="preserve">
          <source>This is used if &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; does not resolve the correct &lt;code&gt;-kb&lt;/code&gt; mode to use. If true, all unresolved files are sent to the client in mode &lt;code&gt;-kb&lt;/code&gt;. This causes the client to treat them as binary files, which suppresses any newline munging it otherwise might do. Alternatively, if it is set to &quot;guess&quot;, then the contents of the file are examined to decide if it is binary, similar to &lt;code&gt;core.autocrlf&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 无法解析要使用的正确 &lt;code&gt;-kb&lt;/code&gt; 模式，则使用此方法。如果为true，则所有未解析的文件都以 &lt;code&gt;-kb&lt;/code&gt; 模式发送到客户端。这导致客户端将它们视为二进制文件，从而抑制了换行符，否则可能会造成麻烦。或者，如果将其设置为&amp;ldquo; guess&amp;rdquo;，则类似于 &lt;code&gt;core.autocrlf&lt;/code&gt; ，将检查文件的内容以确定它是否为二进制。</target>
        </trans-unit>
        <trans-unit id="414b7e001678a67515e35206eca5b23ff617a9b6" translate="yes" xml:space="preserve">
          <source>This is used to avoid unnecessary false hits when &lt;code&gt;git diff-files&lt;/code&gt; is run after &lt;code&gt;git read-tree&lt;/code&gt;.</source>
          <target state="translated">这用于避免在 &lt;code&gt;git read-tree&lt;/code&gt; 之后运行 &lt;code&gt;git diff-files&lt;/code&gt; 时产生不必要的错误命中。</target>
        </trans-unit>
        <trans-unit id="1756049aad8be96bbdbe029ae5b31f810c9534b0" translate="yes" xml:space="preserve">
          <source>This is used to imply --all-progress whenever progress display is activated. Unlike --all-progress this flag doesn&amp;rsquo;t actually force any progress display by itself.</source>
          <target state="translated">每当激活进度显示时，它用于表示--all-progress。与--all-progress不同，此标志实际上并不强制自己显示任何进度。</target>
        </trans-unit>
        <trans-unit id="fa389947911fb92b7cae5947eac62679e5095362" translate="yes" xml:space="preserve">
          <source>This is used to reorder the filepairs according to the user&amp;rsquo;s (or project&amp;rsquo;s) taste, and is controlled by the -O option to the &lt;code&gt;git diff-*&lt;/code&gt; commands.</source>
          <target state="translated">这用于根据用户（或项目）的喜好对文件对重新排序，并由 &lt;code&gt;git diff-*&lt;/code&gt; 命令的-O选项控制。</target>
        </trans-unit>
        <trans-unit id="e4698ff07eb1e8e63a5c87a4e409437aeb77e0b4" translate="yes" xml:space="preserve">
          <source>This is useful because it makes it easy to choose a good commit to test when you want to avoid to test some of them for some reason (they may not compile for example).</source>
          <target state="translated">这很有用,因为当你因为某些原因(例如,它们可能无法编译)而想避免测试某些提交时,可以很容易地选择一个好的提交进行测试。</target>
        </trans-unit>
        <trans-unit id="8b37ac2c46d9c49011957ba8051eb182f97c074f" translate="yes" xml:space="preserve">
          <source>This is useful if F and G were flawed in some way, or should not be part of topicA. Note that the argument to --onto and the &amp;lt;upstream&amp;gt; parameter can be any valid commit-ish.</source>
          <target state="translated">如果F和G以某种方式存在缺陷，或者不应该成为topicA的一部分，则这很有用。请注意，--onto的参数和&amp;lt;upstream&amp;gt;参数可以是任何有效的commit-ish。</target>
        </trans-unit>
        <trans-unit id="5add7a300e88f092e0ef1b21363222f3ece44ad7" translate="yes" xml:space="preserve">
          <source>This is useful if remote side is git:// server accessed over some tunnel.</source>
          <target state="translated">如果远端是通过某个隧道访问的git://服务器,这很有用。</target>
        </trans-unit>
        <trans-unit id="d562e00428aacff2db14167eb0ecbc7ee7ea6370" translate="yes" xml:space="preserve">
          <source>This is useful if the branch on which you ran &lt;code&gt;git stash push&lt;/code&gt; has changed enough that &lt;code&gt;git stash apply&lt;/code&gt; fails due to conflicts. Since the stash entry is applied on top of the commit that was HEAD at the time &lt;code&gt;git stash&lt;/code&gt; was run, it restores the originally stashed state with no conflicts.</source>
          <target state="translated">如果您在其上运行 &lt;code&gt;git stash push&lt;/code&gt; 的分支已更改得足够多，以至于 &lt;code&gt;git stash apply&lt;/code&gt; 由于冲突而失败，这将很有用。由于存储条目是在运行 &lt;code&gt;git stash&lt;/code&gt; 时是HEAD的提交之上应用的，因此它可以恢复原始存储状态，而不会发生冲突。</target>
        </trans-unit>
        <trans-unit id="30fcffaf45041b08cc97af9d1fa76a9ba0b33fa3" translate="yes" xml:space="preserve">
          <source>This is useful if you want to begin your message in a discussion thread with comments and suggestions on the message you are responding to, and to conclude it with a patch submission, separating the discussion and the beginning of the proposed commit log message with a scissors line.</source>
          <target state="translated">如果您想在讨论线程中以评论和建议开始您的消息,并以提交补丁结束,用剪刀线隔开讨论和提交日志消息的开头,这很有用。</target>
        </trans-unit>
        <trans-unit id="f93051fa336df47ab5f519702120e3efac9cd277" translate="yes" xml:space="preserve">
          <source>This is useful on systems where lstat() calls are very slow, such as CIFS/Microsoft Windows.</source>
          <target state="translated">这对那些调用lstat()很慢的系统很有用,比如CIFS/Microsoft Windows。</target>
        </trans-unit>
        <trans-unit id="6b9439a13a0f6c5a19da94d77f92d4a1ee7e5be6" translate="yes" xml:space="preserve">
          <source>This is useful when cherry-picking more than one commits' effect to your index in a row.</source>
          <target state="translated">当在一行中挑选多个提交的效果时,这很有用。</target>
        </trans-unit>
        <trans-unit id="ccb566ca825959d19feaead9d9434de1315351a7" translate="yes" xml:space="preserve">
          <source>This is useful when reverting more than one commits' effect to your index in a row.</source>
          <target state="translated">这在恢复一行中多个提交的效果时很有用。</target>
        </trans-unit>
        <trans-unit id="a6b3b2938023c6383383af34a5efd6428edcf530" translate="yes" xml:space="preserve">
          <source>This is useful when topicB does not depend on topicA.</source>
          <target state="translated">当话题B不依赖于话题A时,这很有用。</target>
        </trans-unit>
        <trans-unit id="804a7dc8302db74d34102cb378738f0047ef1777" translate="yes" xml:space="preserve">
          <source>This is usually not what an end user wants to run directly. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; instead.</source>
          <target state="translated">最终用户通常不想直接运行它。参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81deedcd021f1608f9f91f70a15e2349e22a39d7" translate="yes" xml:space="preserve">
          <source>This is what &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; generates. Most headers and MIME formatting are ignored.</source>
          <target state="translated">这就是&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;生成的。大多数标题和MIME格式都将被忽略。</target>
        </trans-unit>
        <trans-unit id="ca6a5c0a1684e36bc50c3e68cfccb9e6ebf59a4b" translate="yes" xml:space="preserve">
          <source>This is what causes Git to track the remote&amp;rsquo;s branches; you may modify or delete these configuration options by editing &lt;code&gt;.git/config&lt;/code&gt; with a text editor. (See the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.)</source>
          <target state="translated">这就是导致Git跟踪远程分支的原因。您可以通过使用文本编辑器编辑 &lt;code&gt;.git/config&lt;/code&gt; 来修改或删除这些配置选项。（有关详细信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;的&amp;ldquo; CONFIGURATION FILE&amp;rdquo;部分。）</target>
        </trans-unit>
        <trans-unit id="e49010e0ec73f433e7f19c2db7cbfd7081066732" translate="yes" xml:space="preserve">
          <source>This is why it is a bad idea to just chose the next best unskipped bisection commit when the first one has been skipped.</source>
          <target state="translated">这就是为什么当第一个跳过的时候,只选择下一个最好的未跳过的二段提交是个坏主意。</target>
        </trans-unit>
        <trans-unit id="b49b41d6b66c63a0b41c3cd8eb53b02ecb1e28e6" translate="yes" xml:space="preserve">
          <source>This leaves a copy of &lt;code&gt;next&lt;/code&gt; temporarily in FETCH_HEAD, and updates the remote-tracking branch &lt;code&gt;origin/next&lt;/code&gt;. The same can be done by invoking fetch and merge:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51722bee7db4c41cee14b92ba092db0dce132718" translate="yes" xml:space="preserve">
          <source>This leaves a copy of &lt;code&gt;next&lt;/code&gt; temporarily in FETCH_HEAD, but does not update any remote-tracking branches. Using remote-tracking branches, the same can be done by invoking fetch and merge:</source>
          <target state="translated">这会在FETCH_HEAD中暂时保留 &lt;code&gt;next&lt;/code&gt; 的副本，但不会更新任何远程跟踪分支。使用远程跟踪分支，可以通过调用访存和合并来完成相同的工作：</target>
        </trans-unit>
        <trans-unit id="8d3c273456c213d2f0eef245650834ea18d26a16" translate="yes" xml:space="preserve">
          <source>This lets you choose one path out of a &lt;code&gt;status&lt;/code&gt; like selection. After choosing the path, it presents the diff between the index and the working tree file and asks you if you want to stage the change of each hunk. You can select one of the following options and type return:</source>
          <target state="translated">这使您可以从选择之类的 &lt;code&gt;status&lt;/code&gt; 选择一条路径。选择路径后，它将显示索引和工作树文件之间的差异，并询问您是否要暂存每个块的更改。您可以选择以下选项之一，然后键入return：</target>
        </trans-unit>
        <trans-unit id="060b46ed6fd409fbf360157d2f3c13ff3dcd2220" translate="yes" xml:space="preserve">
          <source>This lets you quit without do cleaning.</source>
          <target state="translated">这让你不需要做清洁就可以退出。</target>
        </trans-unit>
        <trans-unit id="aa41c7db3702739cc1b230bda0b83b675d7b2671" translate="yes" xml:space="preserve">
          <source>This lets you review what will be committed (i.e. between HEAD and index).</source>
          <target state="translated">这可以让你审查将被提交的内容(即HEAD和索引之间)。</target>
        </trans-unit>
        <trans-unit id="ca3fd0a1256c2900c49910f1d037599eb216d4ff" translate="yes" xml:space="preserve">
          <source>This list should contain the URI of gitweb&amp;rsquo;s standard stylesheet. The default URI of gitweb stylesheet can be set at build time using the &lt;code&gt;GITWEB_CSS&lt;/code&gt; makefile variable. Its default value is &lt;code&gt;static/gitweb.css&lt;/code&gt; (or &lt;code&gt;static/gitweb.min.css&lt;/code&gt; if the &lt;code&gt;CSSMIN&lt;/code&gt; variable is defined, i.e. if CSS minifier is used during build).</source>
          <target state="translated">该列表应包含gitweb标准样式表的URI。可以在构建时使用 &lt;code&gt;GITWEB_CSS&lt;/code&gt; makefile变量设置gitweb样式表的默认URI 。其默认值为 &lt;code&gt;static/gitweb.css&lt;/code&gt; （如果定义了 &lt;code&gt;CSSMIN&lt;/code&gt; 变量，则为 &lt;code&gt;static/gitweb.min.css&lt;/code&gt; ，即，如果在构建过程中使用了CSS minifier）。</target>
        </trans-unit>
        <trans-unit id="87db555786bcad0bd342abfeced795a76cdcb852" translate="yes" xml:space="preserve">
          <source>This lists the commits reachable from the previous version of the &lt;code&gt;master&lt;/code&gt; branch head. This syntax can be used with any Git command that accepts a commit, not just with &lt;code&gt;git log&lt;/code&gt;. Some other examples:</source>
          <target state="translated">这列出了从 &lt;code&gt;master&lt;/code&gt; 分支头的先前版本可到达的提交。此语法可以与任何接受提交的Git命令一起使用，而不仅限于 &lt;code&gt;git log&lt;/code&gt; 。其他一些例子：</target>
        </trans-unit>
        <trans-unit id="9d19ff56a7106ea2437dd5210773dc60fd2828eb" translate="yes" xml:space="preserve">
          <source>This looks up the &amp;lt;file&amp;gt;(s) in the index and, if there are any merge entries, passes the SHA-1 hash for those files as arguments 1, 2, 3 (empty argument if no file), and &amp;lt;file&amp;gt; as argument 4. File modes for the three files are passed as arguments 5, 6 and 7.</source>
          <target state="translated">这将在索引中查找&amp;lt;file&amp;gt;，如果有任何合并条目，则将这些文件的SHA-1散列作为参数1、2、3（如果没有文件，则为空参数）和&amp;lt;file&amp;gt;作为参数4。三个文件的文件模式作为参数5、6和7传递。</target>
        </trans-unit>
        <trans-unit id="6790f45ac4b6ed7e77775e3a5dfba68fc876105d" translate="yes" xml:space="preserve">
          <source>This makes a commit that records the modification to &lt;code&gt;Makefile&lt;/code&gt;. The changes staged for &lt;code&gt;hello.c&lt;/code&gt; and &lt;code&gt;hello.h&lt;/code&gt; are not included in the resulting commit. However, their changes are not lost &amp;mdash; they are still staged and merely held back. After the above sequence, if you do:</source>
          <target state="translated">这将记录对 &lt;code&gt;Makefile&lt;/code&gt; 的修改的提交。针对 &lt;code&gt;hello.c&lt;/code&gt; 和 &lt;code&gt;hello.h&lt;/code&gt; 进行的更改未包含在结果提交中。但是，它们的更改不会丢失-它们仍会上演，只是受阻。在上述顺序之后，如果您这样做：</target>
        </trans-unit>
        <trans-unit id="c23316330a20f8d3e00d74e273bc6ee3d02efbd7" translate="yes" xml:space="preserve">
          <source>This makes a new branch called &lt;code&gt;other&lt;/code&gt; from &lt;code&gt;master~5..master&lt;/code&gt; (i.e. if &lt;code&gt;master&lt;/code&gt; has linear history, it will take the last 5 commits).</source>
          <target state="translated">这使得所谓的新分支 &lt;code&gt;other&lt;/code&gt; 从 &lt;code&gt;master~5..master&lt;/code&gt; （即，如果 &lt;code&gt;master&lt;/code&gt; 有线性的历史，它将采取的最后5次提交）。</target>
        </trans-unit>
        <trans-unit id="b0ade35fb815795f98a8b6354752858acd9e1cfa" translate="yes" xml:space="preserve">
          <source>This makes sure that only the key/value pair for kernel.org is replaced.</source>
          <target state="translated">这将确保只有kernel.org的key/value对被替换。</target>
        </trans-unit>
        <trans-unit id="2d726c732ca5f310160366fecc16a8d1ede4f94c" translate="yes" xml:space="preserve">
          <source>This manual describes the convention used throughout Git CLI.</source>
          <target state="translated">本手册介绍了Git CLI中使用的惯例。</target>
        </trans-unit>
        <trans-unit id="40982f6c18ca56554ec412b18ace4f012d6c51fa" translate="yes" xml:space="preserve">
          <source>This manual is designed to be readable by someone with basic UNIX command-line skills, but no previous knowledge of Git.</source>
          <target state="translated">本手册的设计目的是为了让具有基本 UNIX 命令行技能,但没有 Git 知识的人也能阅读。</target>
        </trans-unit>
        <trans-unit id="1b4c4400f56ace6af78ca50c928fe7f5cfe13be6" translate="yes" xml:space="preserve">
          <source>This manual page describes only the most frequently used options.</source>
          <target state="translated">本手册页面只介绍最常用的选项。</target>
        </trans-unit>
        <trans-unit id="c74c8f67468f674a4bbb6cadbdb326520214aafb" translate="yes" xml:space="preserve">
          <source>This manual page describes only the most frequently used options. See &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; for a complete list.</source>
          <target state="translated">本手册页仅介绍最常用的选项。有关完整列表，请参见&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78fbc8bf0be13ddc4f9bce27ee4dc19783022a2b" translate="yes" xml:space="preserve">
          <source>This means &quot;show everything that is reachable from either one, but exclude anything that is reachable from both of them&quot;.</source>
          <target state="translated">这意味着 &quot;显示所有从任何一个地方可以到达的东西,但排除所有从两个地方都可以到达的东西&quot;。</target>
        </trans-unit>
        <trans-unit id="9f4c07f14694007bf95dcdb96bbfc3991db01ef3" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; is the opposite of &lt;code&gt;git add
&amp;lt;pathspec&amp;gt;&lt;/code&gt;. This command is equivalent to &lt;code&gt;git restore [--source=&amp;lt;tree-ish&amp;gt;] --staged &amp;lt;pathspec&amp;gt;...&lt;/code&gt;.</source>
          <target state="translated">这意味着 &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; 与 &lt;code&gt;git add &amp;lt;pathspec&amp;gt;&lt;/code&gt; 相反。此命令等同于 &lt;code&gt;git restore [--source=&amp;lt;tree-ish&amp;gt;] --staged &amp;lt;pathspec&amp;gt;...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="138908f8222de2b4daf75b57b97dc896b1845167" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;git reset -p&lt;/code&gt; is the opposite of &lt;code&gt;git add -p&lt;/code&gt;, i.e. you can use it to selectively reset hunks. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">这意味着 &lt;code&gt;git reset -p&lt;/code&gt; 与 &lt;code&gt;git add -p&lt;/code&gt; 相反，即，您可以使用它选择性地重置块。请参阅&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;的&amp;ldquo;交互模式&amp;rdquo;部分，以了解如何操作 &lt;code&gt;--patch&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="9c231d7cedbd657513f91f60869397c2bef2f37d" translate="yes" xml:space="preserve">
          <source>This means that it is often &quot;cheaper&quot; if QA people or end users can do it.</source>
          <target state="translated">这意味着,如果QA人员或终端用户能够做到这一点,往往会 &quot;更便宜&quot;。</target>
        </trans-unit>
        <trans-unit id="0ff1dc064f7e1f4d0872498ac05a21ade168adc9" translate="yes" xml:space="preserve">
          <source>This means that test suites are good to prevent some bugs from being committed and they are also quite good to tell you that you have some bugs. But they are not so good to tell you where some bugs have been introduced. To tell you that efficiently, git bisect is needed.</source>
          <target state="translated">这意味着,测试套件很好地防止了一些bug的发生,它们也很好地告诉你你有一些bug。但它们并不能很好地告诉你哪里引入了一些bug。为了有效地告诉你这些,需要使用git bisect。</target>
        </trans-unit>
        <trans-unit id="388b9571e5f1264e3be3a08ce2827efedebdef31" translate="yes" xml:space="preserve">
          <source>This means that the best bisection commits are the commits where the following function is maximum:</source>
          <target state="translated">这意味着,最好的二分提交是以下函数最大的提交。</target>
        </trans-unit>
        <trans-unit id="597961da0012b9cd684792dccd1c7471e5687e9f" translate="yes" xml:space="preserve">
          <source>This means that the trimmed &amp;lt;token&amp;gt; and &amp;lt;value&amp;gt; will be separated by &lt;code&gt;': '&lt;/code&gt; (one colon followed by one space).</source>
          <target state="translated">这意味着修剪的&amp;lt;token&amp;gt;和&amp;lt;value&amp;gt;将由 &lt;code&gt;': '&lt;/code&gt; 分隔（一个冒号后跟一个空格）。</target>
        </trans-unit>
        <trans-unit id="38ea5711a664516b71bd0eeea932fd8ac8d7c412" translate="yes" xml:space="preserve">
          <source>This means that we get rid of the uninteresting commits in the DAG.</source>
          <target state="translated">这意味着,我们要把DAG中不感兴趣的提交内容去掉。</target>
        </trans-unit>
        <trans-unit id="2454a8b57cbe01726a67b284a671cd468ecfe3a7" translate="yes" xml:space="preserve">
          <source>This means that you can do</source>
          <target state="translated">这意味着,你可以做</target>
        </trans-unit>
        <trans-unit id="4bfb7f09c9f4811c3630d40fb2caf5f3310e564e" translate="yes" xml:space="preserve">
          <source>This means that you can use &lt;code&gt;git checkout -p&lt;/code&gt; to selectively discard edits from your current working tree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">这意味着您可以使用 &lt;code&gt;git checkout -p&lt;/code&gt; 从当前工作树中有选择地放弃编辑。请参阅&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;的&amp;ldquo;交互模式&amp;rdquo;部分，以了解如何操作 &lt;code&gt;--patch&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="2db1fd51873ef2a0afca87fc61387f5a8891e2a5" translate="yes" xml:space="preserve">
          <source>This merges the changes from Bob&amp;rsquo;s &quot;master&quot; branch into Alice&amp;rsquo;s current branch. If Alice has made her own changes in the meantime, then she may need to manually fix any conflicts.</source>
          <target state="translated">这会将Bob的&amp;ldquo; master&amp;rdquo;分支中的更改合并到Alice的当前分支中。如果爱丽丝在此期间进行了自己的更改，则她可能需要手动解决所有冲突。</target>
        </trans-unit>
        <trans-unit id="cff3569519105ed116111cf73b4d626e89a75fc2" translate="yes" xml:space="preserve">
          <source>This merges the file listing in the directory cache index with the actual working directory list, and shows different combinations of the two.</source>
          <target state="translated">这将目录缓存索引中的文件列表与实际工作目录列表合并,并显示两者的不同组合。</target>
        </trans-unit>
        <trans-unit id="e550f0e6cba8953c27a9638529775caa0627f8ed" translate="yes" xml:space="preserve">
          <source>This might not be what you expect, i.e. you want to prune remote &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, but also explicitly fetch tags from it, so when you fetch from it you delete all your local tags, most of which may not have come from the &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; remote in the first place.</source>
          <target state="translated">这可能不是您所期望的，即您想修剪远程 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; ，但也要从中明确获取标签，因此，从中获取时，您将删除所有本地标签，其中大多数可能不是来自 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 首先是远程。</target>
        </trans-unit>
        <trans-unit id="c165a1bf0e23a30271149315bd9959512cec8cbc" translate="yes" xml:space="preserve">
          <source>This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get</source>
          <target state="translated">这种模式与默认模式有一点不同:始终遵循合并的所有父节点,即使对其中一方是TREESAME。即使合并中不止一方有提交的内容,也不意味着合并本身就是这样的! 在这个例子中,我们得到</target>
        </trans-unit>
        <trans-unit id="06118fd3f101fa40f7bcb707d4305013c9a74e7d" translate="yes" xml:space="preserve">
          <source>This mode has become the default in Git 2.0.</source>
          <target state="translated">这个模式在 Git 2.0 中已经成为默认模式。</target>
        </trans-unit>
        <trans-unit id="9c35450959e8c97cb733c60205966cdb68e529c7" translate="yes" xml:space="preserve">
          <source>This mode is designed for repositories with very large indexes, and aims at reducing the time it takes to repeatedly write these indexes.</source>
          <target state="translated">这种模式是为具有非常大的索引的存储库设计的,目的是减少重复编写这些索引的时间。</target>
        </trans-unit>
        <trans-unit id="660380648a3de0733323135a33a60c0126cae6f8" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to dump the internal marks table to &amp;lt;file&amp;gt; when complete. For details, read up on &lt;code&gt;--export-marks=&amp;lt;file&amp;gt;&lt;/code&gt; in &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;.</source>
          <target state="translated">这将修改 &lt;code&gt;export&lt;/code&gt; 功能，指示Git完成后将内部标记表转储到&amp;lt;file&amp;gt;。有关详细信息，关于读向上 &lt;code&gt;--export-marks=&amp;lt;file&amp;gt;&lt;/code&gt; 在&lt;a href=&quot;git-fast-export&quot;&gt;GIT中快速出口[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="59a5d5693433000c28979c8002984ee295ddd735" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to load the marks specified in &amp;lt;file&amp;gt; before processing any input. For details, read up on &lt;code&gt;--import-marks=&amp;lt;file&amp;gt;&lt;/code&gt; in &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;.</source>
          <target state="translated">这修改了 &lt;code&gt;export&lt;/code&gt; 功能，指示Git在处理任何输入之前加载&amp;lt;file&amp;gt;中指定的标记。有关详细信息，关于读向上 &lt;code&gt;--import-marks=&amp;lt;file&amp;gt;&lt;/code&gt; 在&lt;a href=&quot;git-fast-export&quot;&gt;GIT中快速出口[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29cca50076d9ab0c1672949be9f5cf285333ce65" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to pass &lt;code&gt;--signed-tags=verbatim&lt;/code&gt; to &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;. In the absence of this capability, Git will use &lt;code&gt;--signed-tags=warn-strip&lt;/code&gt;.</source>
          <target state="translated">这修改了 &lt;code&gt;export&lt;/code&gt; 功能，指示Git将 &lt;code&gt;--signed-tags=verbatim&lt;/code&gt; 传递给&lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export [1]&lt;/a&gt;。如果没有此功能，Git将使用 &lt;code&gt;--signed-tags=warn-strip&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cd76e4b36f80f26235450d81c7340212de49a9e" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;import&lt;/code&gt; capability. The fast-import commands &lt;code&gt;cat-blob&lt;/code&gt; and &lt;code&gt;ls&lt;/code&gt; can be used by remote-helpers to retrieve information about blobs and trees that already exist in fast-import&amp;rsquo;s memory. This requires a channel from fast-import to the remote-helper. If it is advertised in addition to &quot;import&quot;, Git establishes a pipe from fast-import to the remote-helper&amp;rsquo;s stdin. It follows that Git and fast-import are both connected to the remote-helper&amp;rsquo;s stdin. Because Git can send multiple commands to the remote-helper it is required that helpers that use &lt;code&gt;bidi-import&lt;/code&gt; buffer all &lt;code&gt;import&lt;/code&gt; commands of a batch before sending data to fast-import. This is to prevent mixing commands and fast-import responses on the helper&amp;rsquo;s stdin.</source>
          <target state="translated">这将修改 &lt;code&gt;import&lt;/code&gt; 功能。远程帮助人员可以使用快速导入命令 &lt;code&gt;cat-blob&lt;/code&gt; 和 &lt;code&gt;ls&lt;/code&gt; 来检索有关快速导入内存中已经存在的blob和树的信息。这需要从快速导入到远程帮助者的通道。如果除了&amp;ldquo; import&amp;rdquo;以外还进行广告宣传，Git会建立一条从快速导入到远程帮助程序的stdin的管道。因此，Git和快速导入都连接到了远程帮助程序的stdin。因为Git可以向远程帮助程序发送多个命令，所以要求使用 &lt;code&gt;bidi-import&lt;/code&gt; 的帮助程序缓冲所有 &lt;code&gt;import&lt;/code&gt; 将数据发送到快速导入之前的批处理命令。这是为了防止在助手的stdin上混合命令和快速导入响应。</target>
        </trans-unit>
        <trans-unit id="18b230f7b58b67f5f52143b1696b5514cecb3bd1" translate="yes" xml:space="preserve">
          <source>This operation is safe even if Alice has uncommitted local changes. The range notation &quot;HEAD..FETCH_HEAD&quot; means &quot;show everything that is reachable from the FETCH_HEAD but exclude anything that is reachable from HEAD&quot;. Alice already knows everything that leads to her current state (HEAD), and reviews what Bob has in his state (FETCH_HEAD) that she has not seen with this command.</source>
          <target state="translated">即使Alice有未提交的本地变更,这个操作也是安全的。范围符号 &quot;HEAD...FETCH_HEAD &quot;的意思是 &quot;显示所有从FETCH_HEAD可以到达的东西,但排除任何从HEAD可以到达的东西&quot;。爱丽丝已经知道了所有通向她当前状态(HEAD)的东西,并回顾了Bob在他的状态(FETCH_HEAD)中有哪些她没有看到的东西,用这个命令。</target>
        </trans-unit>
        <trans-unit id="4d6058894e90e81912f089323abaddf6ff7286d2" translate="yes" xml:space="preserve">
          <source>This option affects options that expect path name like &lt;code&gt;--git-dir&lt;/code&gt; and &lt;code&gt;--work-tree&lt;/code&gt; in that their interpretations of the path names would be made relative to the working directory caused by the &lt;code&gt;-C&lt;/code&gt; option. For example the following invocations are equivalent:</source>
          <target state="translated">此选项会影响期望路径名称的选项，例如 &lt;code&gt;--git-dir&lt;/code&gt; 和 &lt;code&gt;--work-tree&lt;/code&gt; ，因为它们对路径名称的解释将相对于 &lt;code&gt;-C&lt;/code&gt; 选项引起的工作目录进行。例如，以下调用是等效的：</target>
        </trans-unit>
        <trans-unit id="2b42f3dc9742d00737d912066dfd2008f4af0874" translate="yes" xml:space="preserve">
          <source>This option allows you to say that you expect the history you are updating is what you rebased and want to replace. If the remote ref still points at the commit you specified, you can be sure that no other people did anything to the ref. It is like taking a &quot;lease&quot; on the ref without explicitly locking it, and the remote ref is updated only if the &quot;lease&quot; is still valid.</source>
          <target state="translated">这个选项允许你说你希望更新的历史记录是你重写的,并且要替换。如果远程 ref 仍然指向你指定的提交,你可以确定没有其他人对 ref 做过任何事情。这就像在没有明确锁定的情况下对 ref 进行了 &quot;租赁&quot;,只有在 &quot;租赁 &quot;仍然有效的情况下,远程 ref 才会被更新。</target>
        </trans-unit>
        <trans-unit id="a3080455c3c310acd65dd25e9f3c439906791e33" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-commit and commit-msg hooks. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">该选项绕过了pre-commit和commit-msg挂钩。另请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae0cb95b3299088da58c88ea10fd24e68d20bac1" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-merge and commit-msg hooks. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">此选项绕过pre-merge和commit-msg挂钩。另请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22c10b3b137f37c4d219034c9b73126392cd066c" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-rebase hook. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">此选项绕过了预变基挂钩。另请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e7eb09891c6b3b929ffed676724fa916ce9b73e" translate="yes" xml:space="preserve">
          <source>This option can be either set to a boolean value or to &lt;code&gt;on-demand&lt;/code&gt;. Setting it to a boolean changes the behavior of fetch and pull to unconditionally recurse into submodules when set to true or to not recurse at all when set to false. When set to &lt;code&gt;on-demand&lt;/code&gt; (the default value), fetch and pull will only recurse into a populated submodule when its superproject retrieves a commit that updates the submodule&amp;rsquo;s reference.</source>
          <target state="translated">该选项可以设置为布尔值，也可以设置为 &lt;code&gt;on-demand&lt;/code&gt; 。将其设置为布尔值会更改fetch和pull的行为，设置为true时将无条件地递归到子模块中，或者设置为false时则完全不递归。当设置为 &lt;code&gt;on-demand&lt;/code&gt; （默认值）时，仅当其超级项目检索提交以更新子模块的引用的提交时，提取和拉取才会递归到已填充的子模块中。</target>
        </trans-unit>
        <trans-unit id="5d7a21f2665910c78fd7ff132552ce53899e84c0" translate="yes" xml:space="preserve">
          <source>This option can be used along with &lt;code&gt;--bisect-vars&lt;/code&gt;, in this case, after all the sorted commit objects, there will be the same text as if &lt;code&gt;--bisect-vars&lt;/code&gt; had been used alone.</source>
          <target state="translated">此选项可以与 &lt;code&gt;--bisect-vars&lt;/code&gt; 一起使用，在这种情况下，在所有排序的提交对象之后，将具有与 &lt;code&gt;--bisect-vars&lt;/code&gt; 单独使用相同的文本。</target>
        </trans-unit>
        <trans-unit id="93ff5c11faab29c493dcd0eb330b2a514a09e43b" translate="yes" xml:space="preserve">
          <source>This option can be used several times to provide several detection regexes.</source>
          <target state="translated">这个选项可以多次使用,以提供多个检测重词。</target>
        </trans-unit>
        <trans-unit id="a9be17765d99ef763e2665079651c5e7b4e1ceec" translate="yes" xml:space="preserve">
          <source>This option can be used to control recursive fetching of this submodule. If this option is also present in the submodules entry in .git/config of the superproject, the setting there will override the one found in .gitmodules. Both settings can be overridden on the command line by using the &quot;--[no-]recurse-submodules&quot; option to &quot;git fetch&quot; and &quot;git pull&quot;.</source>
          <target state="translated">这个选项可以用来控制这个子模块的递归获取。如果这个选项也存在于超级项目的.git/config中的子模块条目中,那里的设置将覆盖.gitmodules中的设置。这两个设置都可以在命令行上通过使用&quot;--[no-]recurse-submodules &quot;选项来覆盖 &quot;git fetch &quot;和 &quot;git pull&quot;。</target>
        </trans-unit>
        <trans-unit id="4813ba4c4b012e94932c2c7e77e5d37eb750ee7d" translate="yes" xml:space="preserve">
          <source>This option can be used to control recursive fetching of this submodule. It can be overridden by using the --[no-]recurse-submodules command-line option to &quot;git fetch&quot; and &quot;git pull&quot;. This setting will override that from in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file.</source>
          <target state="translated">此选项可用于控制此子模块的递归提取。可以通过使用-[no-] recurse-submodules命令行选项来&amp;ldquo; git fetch&amp;rdquo;和&amp;ldquo; git pull&amp;rdquo;来覆盖它。此设置将覆盖&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;文件中的设置。</target>
        </trans-unit>
        <trans-unit id="dc1c2b92ebab0226490f8de8ccd94e6df6f7955b" translate="yes" xml:space="preserve">
          <source>This option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options).</source>
          <target state="translated">这个选项可以用来将命令行选项从文件列表中分离出来,(当文件名可能被误认为是命令行选项时很有用)。</target>
        </trans-unit>
        <trans-unit id="792e2c6acea003d2f54070521de0f6b1fb530a29" translate="yes" xml:space="preserve">
          <source>This option can be used to specify a shell command that will be called to automatically add or modify a trailer with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">此选项可用于指定shell命令，该命令将被调用以使用指定的&amp;lt;token&amp;gt;自动添加或修改预告片。</target>
        </trans-unit>
        <trans-unit id="3870831de784b5f9a3b27254aee6ab6f7a036b72" translate="yes" xml:space="preserve">
          <source>This option can only be used for one-shot imports as &lt;code&gt;git svn&lt;/code&gt; will not be able to fetch again without metadata. Additionally, if you lose your &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; files, &lt;code&gt;git svn&lt;/code&gt; will not be able to rebuild them.</source>
          <target state="translated">此选项只能用于一次导入，因为 &lt;code&gt;git svn&lt;/code&gt; 如果没有元数据将无法再次获取。此外，如果丢失了 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; 文件，则 &lt;code&gt;git svn&lt;/code&gt; 将无法重建它们。</target>
        </trans-unit>
        <trans-unit id="7745929fdc4d071dfa2f069450065a35fb03a357" translate="yes" xml:space="preserve">
          <source>This option can only be used together with --dry-run. By using this option the user can check if any of the given files would be ignored, no matter if they are already present in the work tree or not.</source>
          <target state="translated">这个选项只能和--dry-run一起使用。通过使用这个选项,用户可以检查是否会忽略任何给定的文件,无论它们是否已经存在于工作树中。</target>
        </trans-unit>
        <trans-unit id="2cd2090b6cd931e9fb6990b800f11805da77a460" translate="yes" xml:space="preserve">
          <source>This option cannot (currently) be used unless &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; is used.</source>
          <target state="translated">除非使用 &lt;code&gt;--batch&lt;/code&gt; 或 &lt;code&gt;--batch-check&lt;/code&gt; ,否则（当前）不能使用此选项。</target>
        </trans-unit>
        <trans-unit id="0bf834f696ae0c2ea43d0e8666eab0cbfdcf28f1" translate="yes" xml:space="preserve">
          <source>This option cannot be used with --stdin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="882762ef26e2279478bc78603a1e7faf56dec8c3" translate="yes" xml:space="preserve">
          <source>This option controls if and under what conditions new commits of populated submodules should be fetched too. It can be used as a boolean option to completely disable recursion when set to &lt;code&gt;no&lt;/code&gt; or to unconditionally recurse into all populated submodules when set to &lt;code&gt;yes&lt;/code&gt;, which is the default when this option is used without any value. Use &lt;code&gt;on-demand&lt;/code&gt; to only recurse into a populated submodule when the superproject retrieves a commit that updates the submodule&amp;rsquo;s reference to a commit that isn&amp;rsquo;t already in the local submodule clone.</source>
          <target state="translated">此选项控制是否以及在什么条件下也应提取已填充子模块的新提交。设置为 &lt;code&gt;no&lt;/code&gt; 时，它可以用作布尔选项来完全禁用递归；设置为 &lt;code&gt;yes&lt;/code&gt; 时，它可以无条件地递归到所有填充的子模块中；这是使用此选项而没有任何值时的默认值。仅当超级项目检索到的提交会将子模块的引用更新为本地子模块克隆中尚未存在的提交时，才 &lt;code&gt;on-demand&lt;/code&gt; 使用以递归到已填充的子模块中。</target>
        </trans-unit>
        <trans-unit id="402f84a0bd330441925cd57436b80c9379eb3ea0" translate="yes" xml:space="preserve">
          <source>This option controls if and under what conditions new commits of populated submodules should be fetched too. It can be used as a boolean option to completely disable recursion when set to &lt;code&gt;no&lt;/code&gt; or to unconditionally recurse into all populated submodules when set to &lt;code&gt;yes&lt;/code&gt;, which is the default when this option is used without any value. Use &lt;code&gt;on-demand&lt;/code&gt; to only recurse into a populated submodule when the superproject retrieves a commit that updates the submodule&amp;rsquo;s reference to a commit that isn&amp;rsquo;t already in the local submodule clone. By default, &lt;code&gt;on-demand&lt;/code&gt; is used, unless &lt;code&gt;fetch.recurseSubmodules&lt;/code&gt; is set (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bffdffaf64305a520ea61fd7a4110a4c5bf981" translate="yes" xml:space="preserve">
          <source>This option controls if new commits of all populated submodules should be fetched and updated, too (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;).</source>
          <target state="translated">此选项控制是否也应提取并更新所有已填充子模块的新提交（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;和&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8666b4e7aa19effada757acd8dc6a366796aecc5" translate="yes" xml:space="preserve">
          <source>This option controls if new commits of populated submodules should be fetched, and if the working trees of active submodules should be updated, too (see &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;, &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e48667fde8ec2632838629a22c3bc7308b3012" translate="yes" xml:space="preserve">
          <source>This option controls whether &lt;code&gt;git fetch&lt;/code&gt; (and the underlying fetch in &lt;code&gt;git pull&lt;/code&gt;) will recursively fetch into populated submodules. This option can be set either to a boolean value or to &lt;code&gt;on-demand&lt;/code&gt;. Setting it to a boolean changes the behavior of fetch and pull to recurse unconditionally into submodules when set to true or to not recurse at all when set to false. When set to &lt;code&gt;on-demand&lt;/code&gt;, fetch and pull will only recurse into a populated submodule when its superproject retrieves a commit that updates the submodule&amp;rsquo;s reference. Defaults to &lt;code&gt;on-demand&lt;/code&gt;, or to the value of &lt;code&gt;submodule.recurse&lt;/code&gt; if set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30828ff428cc76245c5c17e5cbd61f4d3413d1c5" translate="yes" xml:space="preserve">
          <source>This option determines how the commit message will be cleaned up before being passed on to the commit machinery. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more details. In particular, if the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is given a value of &lt;code&gt;scissors&lt;/code&gt;, scissors will be appended to &lt;code&gt;MERGE_MSG&lt;/code&gt; before being passed on in the case of a conflict.</source>
          <target state="translated">此选项确定在将提交消息传递到提交机器之前如何对其进行清理。有关更多详细信息，请参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;。特别是，如果为 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 赋予 &lt;code&gt;scissors&lt;/code&gt; 值，则在发生冲突时将在传递剪刀之前将其附加到 &lt;code&gt;MERGE_MSG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="286a93d0042817a6190102b1bfcb5df866579bac" translate="yes" xml:space="preserve">
          <source>This option determines how the merge message will be cleaned up before committing. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more details. In addition, if the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is given a value of &lt;code&gt;scissors&lt;/code&gt;, scissors will be appended to &lt;code&gt;MERGE_MSG&lt;/code&gt; before being passed on to the commit machinery in the case of a merge conflict.</source>
          <target state="translated">该选项确定提交前如何清除合并消息。有关更多详细信息，请参见&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;。另外，如果为 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 赋予 &lt;code&gt;scissors&lt;/code&gt; 值，则在发生合并冲突的情况下，剪刀将被附加到 &lt;code&gt;MERGE_MSG&lt;/code&gt; 上,然后传递给提交机制。</target>
        </trans-unit>
        <trans-unit id="4d1960d5d8472d2a194e5ec10acd8959326f748a" translate="yes" xml:space="preserve">
          <source>This option determines how the supplied commit message should be cleaned up before committing. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; can be &lt;code&gt;strip&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt;, &lt;code&gt;verbatim&lt;/code&gt;, &lt;code&gt;scissors&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">此选项确定在提交之前应如何清除提供的提交消息。所述 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 可以是 &lt;code&gt;strip&lt;/code&gt; ， &lt;code&gt;whitespace&lt;/code&gt; ， &lt;code&gt;verbatim&lt;/code&gt; ， &lt;code&gt;scissors&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5dab8a93409f72b36d8b46ab64625d688725721" translate="yes" xml:space="preserve">
          <source>This option does not (currently) work correctly when an object in the index is specified (e.g. &lt;code&gt;:link&lt;/code&gt; instead of &lt;code&gt;HEAD:link&lt;/code&gt;) rather than one in the tree.</source>
          <target state="translated">当在索引中指定一个对象（例如 &lt;code&gt;:link&lt;/code&gt; 而不是 &lt;code&gt;HEAD:link&lt;/code&gt; ）而不是树中的一个对象时，此选项（当前）无法正常工作。</target>
        </trans-unit>
        <trans-unit id="d9ea124fbd7a15594b4c6836d821b0c2d1f565c3" translate="yes" xml:space="preserve">
          <source>This option forces conflicting hunks to be auto-resolved cleanly by favoring &lt;code&gt;our&lt;/code&gt; version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side.</source>
          <target state="translated">此选项通过支持 &lt;code&gt;our&lt;/code&gt; 版本来强制自动解决冲突的大块。合并结果中反映了与另一棵树不冲突的变化。对于二进制文件，全部内容都是从我们这边获取的。</target>
        </trans-unit>
        <trans-unit id="03e43ead906b5a3ebd0febb15138c0f0fef70180" translate="yes" xml:space="preserve">
          <source>This option identifies the file status with the following tags (followed by a space) at the start of each line:</source>
          <target state="translated">这个选项在每行开头用以下标签(后面加一个空格)来标识文件状态。</target>
        </trans-unit>
        <trans-unit id="11f1817b2bcb9580d82cb7eff477a970ee3352b6" translate="yes" xml:space="preserve">
          <source>This option is NOT recommended as it makes it difficult to track down old references to SVN revision numbers in existing documentation, bug reports, and archives. If you plan to eventually migrate from SVN to Git and are certain about dropping SVN history, consider &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; instead. filter-repo also allows reformatting of metadata for ease-of-reading and rewriting authorship info for non-&quot;svn.authorsFile&quot; users.</source>
          <target state="translated">不建议使用此选项，因为它会使您难以在现有文档，错误报告和档案中跟踪对SVN修订版号的旧引用。如果您打算最终从SVN迁移到Git，并且确定要删除SVN历史记录，请考虑使用&lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt;。filter-repo还允许重新格式化元数据，以方便非&amp;ldquo; svn.authorsFile&amp;rdquo;用户的阅读和重写作者信息。</target>
        </trans-unit>
        <trans-unit id="78790ec840bc0471b6e620b0edc9dccd8cb32215" translate="yes" xml:space="preserve">
          <source>This option is a more advanced form of &lt;code&gt;subtree&lt;/code&gt; strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.</source>
          <target state="translated">此选项是 &lt;code&gt;subtree&lt;/code&gt; 策略的一种更高级形式，其中该策略猜测合并时必须如何移动两棵树以相互匹配。而是将指定的路径添加前缀（或从开头剥离）以使两棵树的形状匹配。</target>
        </trans-unit>
        <trans-unit id="7e1a0662099548eacf19f027d973ae52cc900bb4" translate="yes" xml:space="preserve">
          <source>This option is deprecated in favour of &lt;code&gt;git stash push&lt;/code&gt;. It differs from &quot;stash push&quot; in that it cannot take pathspec. Instead, all non-option arguments are concatenated to form the stash message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4caf0764823caa06aa3cb192d447e797c84f9905" translate="yes" xml:space="preserve">
          <source>This option is deprecated in favour of &lt;code&gt;git stash push&lt;/code&gt;. It differs from &quot;stash push&quot; in that it cannot take pathspecs. Instead, all non-option arguments are concatenated to form the stash message.</source>
          <target state="translated">不推荐使用此选项，而推荐使用 &lt;code&gt;git stash push&lt;/code&gt; 。它与&amp;ldquo;隐藏推送&amp;rdquo;的不同之处在于它不能采用pathspec。而是将所有非选项参数串联起来构成隐藏消息。</target>
        </trans-unit>
        <trans-unit id="c02fef4ae69460732c7c3bd405bb6c17f43ad119" translate="yes" xml:space="preserve">
          <source>This option is equivalent to the &amp;lt;repository&amp;gt; argument. If both are specified, the command-line argument takes precedence.</source>
          <target state="translated">此选项等效于&amp;lt;repository&amp;gt;参数。如果两者都指定，则命令行参数优先。</target>
        </trans-unit>
        <trans-unit id="b7fdcf9707bc99b530bc435f0d474fdd1738b42d" translate="yes" xml:space="preserve">
          <source>This option is implicitly supplied if any other list-like option such as &lt;code&gt;--contains&lt;/code&gt; is provided. See the documentation for each of those options for details.</source>
          <target state="translated">如果提供了其他类似列表的选项（例如 &lt;code&gt;--contains&lt;/code&gt; ），则隐式提供此选项。有关每个选项的详细信息，请参见文档。</target>
        </trans-unit>
        <trans-unit id="710c94d6943c052c3ce9d72b355d1824bacce0cd" translate="yes" xml:space="preserve">
          <source>This option is only applicable in non-verbose mode.</source>
          <target state="translated">此选项仅适用于非言语模式。</target>
        </trans-unit>
        <trans-unit id="4cc49fd28601407189cb758fe5a41d5aaf8777ac" translate="yes" xml:space="preserve">
          <source>This option is only applicable when listing tags without annotation lines.</source>
          <target state="translated">此选项仅适用于列出没有注释行的标签时。</target>
        </trans-unit>
        <trans-unit id="ac28aa5e8f93911465d1aaa74ae4db50de2f286b" translate="yes" xml:space="preserve">
          <source>This option is only relevant if we are tracking branches (using one of the repository layout options --trunk, --tags, --branches, --stdlayout). For each tracked branch, try to find out where its revision was copied from, and set a suitable parent in the first Git commit for the branch. This is especially helpful when we&amp;rsquo;re tracking a directory that has been moved around within the repository. If this feature is disabled, the branches created by &lt;code&gt;git svn&lt;/code&gt; will all be linear and not share any history, meaning that there will be no information on where branches were branched off or merged. However, following long/convoluted histories can take a long time, so disabling this feature may speed up the cloning process. This feature is enabled by default, use --no-follow-parent to disable it.</source>
          <target state="translated">仅当我们跟踪分支时才使用此选项（使用存储库布局选项--trunk，-tags，-branches，-stdlayout中的一个）。对于每个跟踪的分支，尝试找出其修订版本从何处复制，并在该分支的第一个Git提交中设置合适的父级。当我们跟踪已在存储库中移动的目录时，这特别有用。如果禁用此功能，则由 &lt;code&gt;git svn&lt;/code&gt; 创建的分支将全部是线性的，并且不会共享任何历史记录，这意味着将没有关于分支在何处分支或合并的信息。但是，遵循较长/复杂的历史记录可能会花费很长时间，因此禁用此功能可能会加快克隆过程。默认情况下启用此功能，请使用--no-follow-parent禁用它。</target>
        </trans-unit>
        <trans-unit id="e12fdc170000781ad1c58dbca132db57e3472f94" translate="yes" xml:space="preserve">
          <source>This option is only used by Mac OS implementation of Git. When core.precomposeUnicode=true, Git reverts the unicode decomposition of filenames done by Mac OS. This is useful when sharing a repository between Mac OS and Linux or Windows. (Git for Windows 1.7.10 or higher is needed, or Git under cygwin 1.7). When false, file names are handled fully transparent by Git, which is backward compatible with older versions of Git.</source>
          <target state="translated">这个选项只在Mac OS实现的Git中使用。当core.precomposeUnicode=true时,Git会恢复Mac OS对文件名的unicode分解。这在 Mac OS 和 Linux 或 Windows 之间共享仓库时非常有用。(需要 Git for Windows 1.7.10 或更高版本,或 Git under cygwin 1.7)。当为 &quot;false &quot;时,Git对文件名的处理是完全透明的,这与旧版本的Git向后兼容。</target>
        </trans-unit>
        <trans-unit id="f6656985205e20f496a0b3074744f80ac096af4d" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;branch&lt;/code&gt;, &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;show&lt;/code&gt; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6b30f54355307a9689dd1f0d561ef40fa56b3b" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;save&lt;/code&gt;, &lt;code&gt;store&lt;/code&gt; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1fe023113c04188594b141d1e29c7346f8a146" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a31933c42436b9e91daec147e769ddb8e06d57" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1938ed399d7f045d62945a278113dd2db5e4506d" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;push&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488a5b3855b8742f267f0b39339ad03e677bc10e" translate="yes" xml:space="preserve">
          <source>This option is only valid for add and update commands. Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.</source>
          <target state="translated">这个选项只对添加和更新命令有效。除非指定了 -q,否则当标准错误流连接到终端时,默认情况下会报告进度状态。即使标准错误流没有指向终端,该标志也会强制报告进度状态。</target>
        </trans-unit>
        <trans-unit id="564be2665790d0ee7a744865d472382d1cf20497" translate="yes" xml:space="preserve">
          <source>This option is only valid for add and update commands. These commands sometimes need to clone a remote repository. In this case, this option will be passed to the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; command.</source>
          <target state="translated">此选项仅对添加和更新命令有效。这些命令有时需要克隆远程存储库。在这种情况下，此选项将传递给&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="1175e1719609394666bffaa81ec16b8052e4a6b8" translate="yes" xml:space="preserve">
          <source>This option is only valid for add, deinit and update commands. When running add, allow adding an otherwise ignored submodule path. When running deinit the submodule working trees will be removed even if they contain local changes. When running update (only effective with the checkout procedure), throw away local changes in submodules when switching to a different commit; and always run a checkout operation in the submodule, even if the commit listed in the index of the containing repository matches the commit checked out in the submodule.</source>
          <target state="translated">这个选项只对add、deinit和update命令有效。当运行add时,允许添加一个否则被忽略的子模块路径。当运行deinit时,子模块工作树将被删除,即使它们包含本地变化。当运行 update 时(仅对 checkout 程序有效),当切换到不同的提交时,扔掉子模块中的本地变化;并且总是在子模块中运行 checkout 操作,即使包含仓库的索引中列出的提交与子模块中签出的提交相匹配。</target>
        </trans-unit>
        <trans-unit id="2de8d442aa39a274aaa4b758d62aa7d0adb622e3" translate="yes" xml:space="preserve">
          <source>This option is only valid for foreach, update, status and sync commands. Traverse submodules recursively. The operation is performed not only in the submodules of the current repo, but also in any nested submodules inside those submodules (and so on).</source>
          <target state="translated">这个选项只对foreach、update、status和sync命令有效。递归遍历子模块。该操作不仅在当前 repo 的子模块中执行,而且在这些子模块中的任何嵌套的子模块中执行(以此类推)。</target>
        </trans-unit>
        <trans-unit id="d01c54f91ad08eb6d9511d7549b500d6b89b1500" translate="yes" xml:space="preserve">
          <source>This option is only valid for status and summary commands. These commands typically use the commit found in the submodule HEAD, but with this option, the commit stored in the index is used instead.</source>
          <target state="translated">这个选项只对状态和摘要命令有效。这些命令通常使用子模块HEAD中的提交,但使用这个选项,会使用索引中存储的提交。</target>
        </trans-unit>
        <trans-unit id="7ba21174d5319ba108a98df185e2c79d000e199b" translate="yes" xml:space="preserve">
          <source>This option is only valid for the add command. It sets the submodule&amp;rsquo;s name to the given string instead of defaulting to its path. The name must be valid as a directory name and may not end with a &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">此选项仅对add命令有效。它将子模块的名称设置为给定的字符串，而不是默认使用其路径。该名称必须作为目录名称有效，并且不能以 &lt;code&gt;/&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="87ff71824f0ae07bd73763f995cf49d0ad4b94cd" translate="yes" xml:space="preserve">
          <source>This option is only valid for the deinit command. Unregister all submodules in the working tree.</source>
          <target state="translated">这个选项只对deinit命令有效。取消注册工作树中的所有子模块。</target>
        </trans-unit>
        <trans-unit id="f24783ef5194da88d7aca04af04dd4876a0ce3ed" translate="yes" xml:space="preserve">
          <source>This option is only valid for the summary command. Limit the summary size (number of commits shown in total). Giving 0 will disable the summary; a negative number means unlimited (the default). This limit only applies to modified submodules. The size is always limited to 1 for added/deleted/typechanged submodules.</source>
          <target state="translated">这个选项只对摘要命令有效。限制摘要的大小(总共显示的提交次数)。给予0将禁用摘要;负数表示无限制(默认)。这个限制只适用于修改过的子模块。对于添加/删除/类型改变的子模块,大小总是限制为1。</target>
        </trans-unit>
        <trans-unit id="ba7d2b303205764476dea6127f5143ab027381fd" translate="yes" xml:space="preserve">
          <source>This option is only valid for the summary command. This command compares the commit in the index with that in the submodule HEAD when this option is used.</source>
          <target state="translated">这个选项只对摘要命令有效。当使用该选项时,该命令将索引中的提交与子模块HEAD中的提交进行比较。</target>
        </trans-unit>
        <trans-unit id="0329e613a2d579c43cf813e4dcb872eed327d20c" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Checkout the commit recorded in the superproject on a detached HEAD in the submodule. This is the default behavior, the main use of this option is to override &lt;code&gt;submodule.$name.update&lt;/code&gt; when set to a value other than &lt;code&gt;checkout&lt;/code&gt;. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is either not explicitly set or set to &lt;code&gt;checkout&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">此选项仅对update命令有效。在子模块中的分离HEAD上签出超级项目中记录的提交。这是默认行为，当设置为 &lt;code&gt;checkout&lt;/code&gt; 以外的其他值时，此选项的主要用途是覆盖 &lt;code&gt;submodule.$name.update&lt;/code&gt; 。如果未显式设置键 &lt;code&gt;submodule.$name.update&lt;/code&gt; 或将其设置为 &lt;code&gt;checkout&lt;/code&gt; ，则此选项为隐式。</target>
        </trans-unit>
        <trans-unit id="7988d8bd0ba82c9f133c5f7cc525c2236228f253" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Clone new submodules in parallel with as many jobs. Defaults to the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; option.</source>
          <target state="translated">此选项仅对update命令有效。克隆新的子模块，同时包含尽可能多的作业。默认为 &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="d378f847e736854044b7df06d860154da6a30cd4" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Clone only one branch during update: HEAD or one specified by --branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5e49243a4037b1b14e7038956130dc87de6d4f" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Don&amp;rsquo;t fetch new objects from the remote site.</source>
          <target state="translated">此选项仅对update命令有效。不要从远程站点获取新对象。</target>
        </trans-unit>
        <trans-unit id="f13e740e91a73f0a2574eefa11fc263894a39d8c" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Initialize all submodules for which &quot;git submodule init&quot; has not been called so far before updating.</source>
          <target state="translated">这个选项只对更新命令有效。在更新前,初始化所有尚未调用 &quot;git submodule init &quot;的子模块。</target>
        </trans-unit>
        <trans-unit id="78bb9a5b0867074719f5c17324b183ac216eed4e" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Instead of using the superproject&amp;rsquo;s recorded SHA-1 to update the submodule, use the status of the submodule&amp;rsquo;s remote-tracking branch. The remote used is branch&amp;rsquo;s remote (&lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt;), defaulting to &lt;code&gt;origin&lt;/code&gt;. The remote branch used defaults to &lt;code&gt;master&lt;/code&gt;, but the branch name may be overridden by setting the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; option in either &lt;code&gt;.gitmodules&lt;/code&gt; or &lt;code&gt;.git/config&lt;/code&gt; (with &lt;code&gt;.git/config&lt;/code&gt; taking precedence).</source>
          <target state="translated">此选项仅对update命令有效。不要使用超级项目记录的SHA-1更新子模块，而要使用子模块的远程跟踪分支的状态。所使用的远程是分支的远程（ &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; ），默认为 &lt;code&gt;origin&lt;/code&gt; 。使用的远程分支默认为 &lt;code&gt;master&lt;/code&gt; ，但是可以通过设置 &lt;code&gt;.gitmodules&lt;/code&gt; 或 &lt;code&gt;.git/config&lt;/code&gt; 中的 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 选项来覆盖分支名称（以 &lt;code&gt;.git/config&lt;/code&gt; 优先）。</target>
        </trans-unit>
        <trans-unit id="71febe80653ad4c9e80be61d4ea3dbe9011e0741" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Instead of using the superproject&amp;rsquo;s recorded SHA-1 to update the submodule, use the status of the submodule&amp;rsquo;s remote-tracking branch. The remote used is branch&amp;rsquo;s remote (&lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt;), defaulting to &lt;code&gt;origin&lt;/code&gt;. The remote branch used defaults to the remote &lt;code&gt;HEAD&lt;/code&gt;, but the branch name may be overridden by setting the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; option in either &lt;code&gt;.gitmodules&lt;/code&gt; or &lt;code&gt;.git/config&lt;/code&gt; (with &lt;code&gt;.git/config&lt;/code&gt; taking precedence).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d36d21960733622c3c4d0c9b1d02dde186ab4d" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Merge the commit recorded in the superproject into the current branch of the submodule. If this option is given, the submodule&amp;rsquo;s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve the resulting conflicts within the submodule with the usual conflict resolution tools. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is set to &lt;code&gt;merge&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">此选项仅对update命令有效。将超级项目中记录的提交合并到子模块的当前分支中。如果给出此选项，则不会分离子模块的HEAD。如果合并失败阻止了此过程，则必须使用常规的冲突解决工具来解决子模块内导致的冲突。如果键 &lt;code&gt;submodule.$name.update&lt;/code&gt; 设置为 &lt;code&gt;merge&lt;/code&gt; ，则此选项为隐式。</target>
        </trans-unit>
        <trans-unit id="24320b0a3d3cc55ac6e67c5111e4d5b2024f7768" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Rebase the current branch onto the commit recorded in the superproject. If this option is given, the submodule&amp;rsquo;s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve these failures with &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is set to &lt;code&gt;rebase&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">此选项仅对update命令有效。将当前分支重新基于超级项目中记录的提交。如果给出此选项，则不会分离子模块的HEAD。如果合并失败阻止了此过程，则必须使用&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;解决这些失败。如果密钥 &lt;code&gt;submodule.$name.update&lt;/code&gt; 设置为 &lt;code&gt;rebase&lt;/code&gt; ，则此选项为隐式。</target>
        </trans-unit>
        <trans-unit id="7010a654e778ac0c1da27a5e658bfb8f3af2d2b7" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. The initial clone of a submodule will use the recommended &lt;code&gt;submodule.&amp;lt;name&amp;gt;.shallow&lt;/code&gt; as provided by the &lt;code&gt;.gitmodules&lt;/code&gt; file by default. To ignore the suggestions use &lt;code&gt;--no-recommend-shallow&lt;/code&gt;.</source>
          <target state="translated">此选项仅对update命令有效。子模块的初始克隆将使用 &lt;code&gt;.gitmodules&lt;/code&gt; 文件默认提供的推荐 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.shallow&lt;/code&gt; 。要忽略建议，请使用 &lt;code&gt;--no-recommend-shallow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6d7b3753dd95003bf8a5d9061fa7c1fb4ce2aaa" translate="yes" xml:space="preserve">
          <source>This option is only valid when &quot;--rebase&quot; is used.</source>
          <target state="translated">这个选项只有在使用&quot;--rebase &quot;时才有效。</target>
        </trans-unit>
        <trans-unit id="98847da95477508a8a5d1e566e92d9a686be8a10" translate="yes" xml:space="preserve">
          <source>This option is particularly useful in avoiding false positives when a merged branch contained broken or non-buildable commits, but the merge itself was OK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f287cb1cbdf50b2a99b97c922a7a8e625bb0e374" translate="yes" xml:space="preserve">
          <source>This option is passed through to &lt;code&gt;git pack-objects&lt;/code&gt;.</source>
          <target state="translated">此选项通过 &lt;code&gt;git pack-objects&lt;/code&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="4fbc055bad10c535a2fe42cbab527b95ac43fb4e" translate="yes" xml:space="preserve">
          <source>This option is primarily to help users who are used to older versions of Git, whose &quot;git add &amp;lt;pathspec&amp;gt;&amp;hellip;​&quot; was a synonym for &quot;git add --no-all &amp;lt;pathspec&amp;gt;&amp;hellip;​&quot;, i.e. ignored removed files.</source>
          <target state="translated">此选项主要是为习惯于旧版本Git的用户提供帮助，这些用户的&amp;ldquo; git add &amp;lt;pathspec&amp;gt;&amp;hellip;&amp;rdquo;是&amp;ldquo; git add --no-all &amp;lt;pathspec&amp;gt; ...&amp;rdquo;的同义词，即忽略已删除的文件。</target>
        </trans-unit>
        <trans-unit id="b78fb9017b343dcaa9f7e76e34c0b6aead88f71f" translate="yes" xml:space="preserve">
          <source>This option is similar to &lt;code&gt;--topo-order&lt;/code&gt; in the sense that no parent comes before all of its children, but otherwise commits are ordered according to their commit date.</source>
          <target state="translated">此选项与 &lt;code&gt;--topo-order&lt;/code&gt; 相似，在某种意义上，没有父级先于其所有子级出现，但其他提交是根据其提交日期排序的。</target>
        </trans-unit>
        <trans-unit id="45355afb761a7570eab836899016e010dbbaff37" translate="yes" xml:space="preserve">
          <source>This option is used internally to temporarily provide a non-negative default value for the --recurse-submodules option. All other methods of configuring fetch&amp;rsquo;s submodule recursion (such as settings in &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; and &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) override this option, as does specifying --[no-]recurse-submodules directly.</source>
          <target state="translated">此选项在内部用于临时为--recurse-submodules选项提供非负默认值。所有其他配置fetch的子模块递归的方法（例如&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;和&lt;a href=&quot;git-config&quot;&gt;git-config [1]中的设置&lt;/a&gt;）都会覆盖此选项，就像直接指定-[no-] recurse-submodules一样。</target>
        </trans-unit>
        <trans-unit id="37e6c888c3b366c4018908c683d3076036665dbd" translate="yes" xml:space="preserve">
          <source>This option is useful in the case where one is developing a feature on top of an upstream branch. While the feature is being worked on, the upstream branch may advance and it may not be the best idea to keep rebasing on top of the upstream but to keep the base commit as-is.</source>
          <target state="translated">当我们在上游分支的基础上开发一个特性时,这个选项是很有用的。当功能正在开发的时候,上游分支可能会前进,因此在上游分支的基础上继续重新归类可能不是最好的主意,而应该保持基础提交的原样。</target>
        </trans-unit>
        <trans-unit id="df85f593fd6f7620dd8216482ba39599038d6eaa" translate="yes" xml:space="preserve">
          <source>This option is valid for add and update commands. Create a &lt;code&gt;shallow&lt;/code&gt; clone with a history truncated to the specified number of revisions. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;</source>
          <target state="translated">此选项对添加和更新命令有效。创建一个 &lt;code&gt;shallow&lt;/code&gt; 副本，其历史记录被截断为指定的修订版本。参见&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ebd5b9556122446be4baef760f1327190ef9a1e0" translate="yes" xml:space="preserve">
          <source>This option makes it possible to choose what action will be performed when there is already at least one trailer with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">使用此选项可以选择在消息中已经存在至少一个具有相同&amp;lt;token&amp;gt;的预告片时执行的操作。</target>
        </trans-unit>
        <trans-unit id="ccc070d377579e85f01a8bc02ef61c868f5331ee" translate="yes" xml:space="preserve">
          <source>This option makes it possible to choose what action will be performed when there is not yet any trailer with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">此选项使您可以选择在消息中还没有任何具有相同&amp;lt;token&amp;gt;的预告片时将执行的操作。</target>
        </trans-unit>
        <trans-unit id="f87ac9b403a45c29acabaf374d53994925318884" translate="yes" xml:space="preserve">
          <source>This option may be given up to three times, and specifies labels to be used in place of the corresponding file names in conflict reports. That is, &lt;code&gt;git merge-file -L x -L y -L z a b c&lt;/code&gt; generates output that looks like it came from files x, y and z instead of from files a, b and c.</source>
          <target state="translated">该选项最多可给出3次，并指定用于代替冲突报告中相应文件名的标签。也就是说， &lt;code&gt;git merge-file -L x -L y -L z a b c&lt;/code&gt; 生成的输出看起来像是来自文件x，y和z而不是来自文件a，b和c。</target>
        </trans-unit>
        <trans-unit id="e631233708c2bfee4790b72e1f69b49f86a6c1ad" translate="yes" xml:space="preserve">
          <source>This option may be specified more than once.</source>
          <target state="translated">此选项可指定一次以上。</target>
        </trans-unit>
        <trans-unit id="ad4bbf67e7b293924d5786bf652c9c00512dbaee" translate="yes" xml:space="preserve">
          <source>This option may be specified more than once; if so, Git will report commits reachable from any of the given commits.</source>
          <target state="translated">这个选项可以指定多个,如果是这样的话,Git会报告从任何一个给定的提交到达的提交。</target>
        </trans-unit>
        <trans-unit id="02516672facfbf5a7b264eba6cd92c5455d92d79" translate="yes" xml:space="preserve">
          <source>This option may be specified multiple times.</source>
          <target state="translated">此选项可指定多次。</target>
        </trans-unit>
        <trans-unit id="b397b665066a62a5850aaf1e8487dea9e6d48e99" translate="yes" xml:space="preserve">
          <source>This option may be useful if you have CVS revision numbers stored in commit messages, bug-tracking systems, email archives, and the like.</source>
          <target state="translated">如果你的 CVS 版本号存储在提交信息、错误跟踪系统、电子邮件档案中,这个选项可能会很有用。</target>
        </trans-unit>
        <trans-unit id="5f0fddd7193d3e6d239ce8fc4bc7fc077dbf4105" translate="yes" xml:space="preserve">
          <source>This option may be useful when the test you would perform in each step does not require a checked out tree.</source>
          <target state="translated">当你在每个步骤中执行的测试不需要检查出的树时,这个选项可能很有用。</target>
        </trans-unit>
        <trans-unit id="17ca02a4d5f28c7e8971b8d1a382a0b6bcfa0d17" translate="yes" xml:space="preserve">
          <source>This option overrides this restriction if the current value of the remote ref is the expected value. &quot;git push&quot; fails otherwise.</source>
          <target state="translated">如果远程ref的当前值是预期值,这个选项会覆盖这个限制。否则 &quot;git push &quot;会失败。</target>
        </trans-unit>
        <trans-unit id="8d166b9e59f19f7598d41e509f594cbcbd0ac7f1" translate="yes" xml:space="preserve">
          <source>This option provides an additional limit on top of &lt;code&gt;--window&lt;/code&gt;; the window size will dynamically scale down so as to not take up more than &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; bytes in memory. This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. &lt;code&gt;--window-memory=0&lt;/code&gt; makes memory usage unlimited. The default is taken from the &lt;code&gt;pack.windowMemory&lt;/code&gt; configuration variable.</source>
          <target state="translated">此选项在 &lt;code&gt;--window&lt;/code&gt; 之上提供了一个额外的限制；窗口大小将动态缩小，以使内存中的字节数不超过 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 个字节。这在包含大型对象和小型对象的存储库中非常有用，这样不会因为一个大窗口而用完内存，但是仍然可以利用大窗口来存储较小的对象。大小可以后缀&amp;ldquo; k&amp;rdquo;，&amp;ldquo; m&amp;rdquo;或&amp;ldquo; g&amp;rdquo;。 &lt;code&gt;--window-memory=0&lt;/code&gt; 使内存使用不受限制。默认值来自 &lt;code&gt;pack.windowMemory&lt;/code&gt; 配置变量。</target>
        </trans-unit>
        <trans-unit id="b37ac455915a6998f49ecb85f682ef29dfba0c63" translate="yes" xml:space="preserve">
          <source>This option provides an additional limit on top of &lt;code&gt;--window&lt;/code&gt;; the window size will dynamically scale down so as to not take up more than &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; bytes in memory. This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. &lt;code&gt;--window-memory=0&lt;/code&gt; makes memory usage unlimited. The default is taken from the &lt;code&gt;pack.windowMemory&lt;/code&gt; configuration variable. Note that the actual memory usage will be the limit multiplied by the number of threads used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;.</source>
          <target state="translated">此选项在 &lt;code&gt;--window&lt;/code&gt; 之上提供了一个额外的限制；窗口大小将动态缩小，以使内存中的字节数不超过 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 个字节。这在包含大型对象和小型对象的存储库中非常有用，这样不会因为一个大窗口而用完内存，但是仍然可以利用大窗口来存储较小的对象。大小可以后缀&amp;ldquo; k&amp;rdquo;，&amp;ldquo; m&amp;rdquo;或&amp;ldquo; g&amp;rdquo;。 &lt;code&gt;--window-memory=0&lt;/code&gt; 使内存使用不受限制。默认值来自 &lt;code&gt;pack.windowMemory&lt;/code&gt; 配置变量。请注意，实际内存使用量将是限制乘以&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;使用的线程数。</target>
        </trans-unit>
        <trans-unit id="16a6b7273f3cccefcfa42e33a667c568aaee0875" translate="yes" xml:space="preserve">
          <source>This option sets how the tag message is cleaned up. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; can be one of &lt;code&gt;verbatim&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt; and &lt;code&gt;strip&lt;/code&gt;. The &lt;code&gt;strip&lt;/code&gt; mode is default. The &lt;code&gt;verbatim&lt;/code&gt; mode does not change message at all, &lt;code&gt;whitespace&lt;/code&gt; removes just leading/trailing whitespace lines and &lt;code&gt;strip&lt;/code&gt; removes both whitespace and commentary.</source>
          <target state="translated">此选项设置清除标签消息的方式。所述 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 可以是一个 &lt;code&gt;verbatim&lt;/code&gt; ， &lt;code&gt;whitespace&lt;/code&gt; 和 &lt;code&gt;strip&lt;/code&gt; 。所述 &lt;code&gt;strip&lt;/code&gt; 模式是默认值。的 &lt;code&gt;verbatim&lt;/code&gt; 模式完全不改变消息时， &lt;code&gt;whitespace&lt;/code&gt; 将删除刚刚前/后空白线和 &lt;code&gt;strip&lt;/code&gt; 同时去除空白和评注。</target>
        </trans-unit>
        <trans-unit id="1c04622cab5eac3fe5e20d1c189be97d2000ad23" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.ifexists&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">此选项采用与 &lt;code&gt;trailer.ifexists&lt;/code&gt; 配置变量相同的值，并且它将覆盖该选项为具有指定&amp;lt;token&amp;gt;的拖车指定的值。</target>
        </trans-unit>
        <trans-unit id="de59f6641e33166f78c75c60b985eacdf1d2a0ea" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.ifmissing&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">该选项采用与 &lt;code&gt;trailer.ifmissing&lt;/code&gt; 配置变量相同的值，并且它将覆盖该选项为具有指定&amp;lt;token&amp;gt;的拖车指定的值。</target>
        </trans-unit>
        <trans-unit id="6b156d8c8a67e1eaa9c71b8c4e454e308c17c450" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.where&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">该选项采用与 &lt;code&gt;trailer.where&lt;/code&gt; 配置变量相同的值，并且它将覆盖该选项为具有指定&amp;lt;token&amp;gt;的拖车指定的值。</target>
        </trans-unit>
        <trans-unit id="7df9ff293572a5c1527bce59783d9544419daa5b" translate="yes" xml:space="preserve">
          <source>This option tells where a new trailer will be added.</source>
          <target state="translated">这个选项告诉我们新的预告片将被添加到哪里。</target>
        </trans-unit>
        <trans-unit id="b36c69b0196d300061790058cdc0665affb9915e" translate="yes" xml:space="preserve">
          <source>This option tells which characters are recognized as trailer separators. By default only &lt;code&gt;:&lt;/code&gt; is recognized as a trailer separator, except that &lt;code&gt;=&lt;/code&gt; is always accepted on the command line for compatibility with other git commands.</source>
          <target state="translated">此选项告诉哪些字符被识别为尾部分隔符。默认情况下，仅 &lt;code&gt;:&lt;/code&gt; 被识别为尾部分隔符，但为了与其他git命令兼容，始终在命令行上接受 &lt;code&gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d89b4c86a97ff8d1caa3cc84d59173003c0040dc" translate="yes" xml:space="preserve">
          <source>This option will cause fast-export to issue a &quot;deleteall&quot; directive for each commit followed by a full list of all files in the commit (as opposed to just listing the files which are different from the commit&amp;rsquo;s first parent).</source>
          <target state="translated">此选项将导致快速导出为每个提交发出&amp;ldquo; deleteall&amp;rdquo;指令，后跟该提交中所有文件的完整列表（而不是仅列出与提交的第一个父文件不同的文件）。</target>
        </trans-unit>
        <trans-unit id="f143abcfc92e5721db51d7183ec9951b417133b6" translate="yes" xml:space="preserve">
          <source>This option will cause git-svn to attempt to automatically populate the svn:mergeinfo property in the SVN repository when possible. Currently, this can only be done when dcommitting non-fast-forward merges where all parents but the first have already been pushed into SVN.</source>
          <target state="translated">这个选项会让 git-svn 在可能的情况下尝试自动填充 SVN 仓库中的 svn:mergeinfo 属性。目前,只有在提交非快进式合并时,除了第一条以外的所有父版本都已经被推送到SVN中时,才能做到这一点。</target>
        </trans-unit>
        <trans-unit id="06697c041d5aacbd598da12e9917cf43b1b799c5" translate="yes" xml:space="preserve">
          <source>This option will cause the mapping from old to new objects to be loaded from named branch upon startup and saved as a new commit to that branch upon exit, enabling incremental of large trees. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does not exist it will be created.</source>
          <target state="translated">此选项将导致从旧对象到新对象的映射在启动时从命名分支加载，并在退出时另存为对该分支的新提交，从而启用大树的增量。如果 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 不存在，将创建它。</target>
        </trans-unit>
        <trans-unit id="dac1adaa75a920f5808dd15e4e9468c4b8319529" translate="yes" xml:space="preserve">
          <source>This output format is compatible with what &lt;code&gt;--index-info --stdin&lt;/code&gt; of &lt;code&gt;git update-index&lt;/code&gt; expects.</source>
          <target state="translated">这种输出格式是什么兼容 &lt;code&gt;--index-info --stdin&lt;/code&gt; 的 &lt;code&gt;git update-index&lt;/code&gt; 的期望。</target>
        </trans-unit>
        <trans-unit id="9b61a138f7f673e2e13a43bac58e20e6d27091cc" translate="yes" xml:space="preserve">
          <source>This outputs all the commit objects between the included and excluded commits, ordered by their distance to the included and excluded commits. Refs in &lt;code&gt;refs/bisect/&lt;/code&gt; are not used. The farthest from them is displayed first. (This is the only one displayed by &lt;code&gt;--bisect&lt;/code&gt;.)</source>
          <target state="translated">这将输出包含和排除提交之间的所有提交对象，并按它们到包含和排除提交的距离进行排序。未使用 &lt;code&gt;refs/bisect/&lt;/code&gt; 中的refs。离它们最远的位置将首先显示。（这是 &lt;code&gt;--bisect&lt;/code&gt; 显示的唯一一个。）</target>
        </trans-unit>
        <trans-unit id="c6b16b352aa83127a9d9220754dcd31555c3879e" translate="yes" xml:space="preserve">
          <source>This outputs something like this (the actual commit object names would be different)</source>
          <target state="translated">它的输出是这样的(实际的提交对象名称会有所不同</target>
        </trans-unit>
        <trans-unit id="05fcf2a461c52cf42967559d01dbd73ffe108135" translate="yes" xml:space="preserve">
          <source>This overrides a previous &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; setting and reads the default merge tool will be read from the configured &lt;code&gt;merge.tool&lt;/code&gt; variable.</source>
          <target state="translated">这将覆盖先前的 &lt;code&gt;-g&lt;/code&gt; 或 &lt;code&gt;--gui&lt;/code&gt; 设置，并从配置的 &lt;code&gt;merge.tool&lt;/code&gt; 变量中读取默认的合并工具。</target>
        </trans-unit>
        <trans-unit id="cf7619d964802ced013b07a7c34a4262a7e0e3f4" translate="yes" xml:space="preserve">
          <source>This page can be displayed with &lt;code&gt;git help help&lt;/code&gt; or &lt;code&gt;git help --help&lt;/code&gt;</source>
          <target state="translated">该页面可以显示 &lt;code&gt;git help help&lt;/code&gt; 或 &lt;code&gt;git help --help&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d990ef47ac594dcb10bc55890ec7a6963b3ffaed" translate="yes" xml:space="preserve">
          <source>This particular format is supplied as it&amp;rsquo;s short to implement and may be useful to a process that wants to create a new commit right now, without needing to use a working directory or &lt;code&gt;git update-index&lt;/code&gt;.</source>
          <target state="translated">提供这种特定格式是因为它的实现时间很短，它对于想要立即创建新提交的进程很有用，而无需使用工作目录或 &lt;code&gt;git update-index&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ace4cf0777df858ca1c6440d5cccb2ed6637934" translate="yes" xml:space="preserve">
          <source>This prints the name of a commit they are both based on. You should now look up the tree objects of those commits, which you can easily do with</source>
          <target state="translated">这将打印出它们都基于的提交的名称。现在您应该查找这些提交的树状对象,您可以使用</target>
        </trans-unit>
        <trans-unit id="65ce33f2a6f411ae54de75d77a4a5c5e2663fba3" translate="yes" xml:space="preserve">
          <source>This program computes which packs in your repository are redundant. The output is suitable for piping to &lt;code&gt;xargs rm&lt;/code&gt; if you are in the root of the repository.</source>
          <target state="translated">该程序计算存储库中的哪些包是多余的。如果您在存储库的根目录中，则该输出适合用于管道传输到 &lt;code&gt;xargs rm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dec60739fdc5804a4abedc6cf66847493211890" translate="yes" xml:space="preserve">
          <source>This program dumps the given revisions in a form suitable to be piped into &lt;code&gt;git fast-import&lt;/code&gt;.</source>
          <target state="translated">该程序将给定的修订版以适合管道传输到 &lt;code&gt;git fast-import&lt;/code&gt; 的形式转储。</target>
        </trans-unit>
        <trans-unit id="21943cdf9cd81593906492b86163eaa305da0be9" translate="yes" xml:space="preserve">
          <source>This program is usually not what the end user wants to run directly. Most end users want to use one of the existing frontend programs, which parses a specific type of foreign source and feeds the contents stored there to &lt;code&gt;git fast-import&lt;/code&gt;.</source>
          <target state="translated">该程序通常不是最终用户想要直接运行的程序。大多数最终用户都想使用现有的前端程序之一，该程序解析特定类型的外部源并将存储在那里的内容提供给 &lt;code&gt;git fast-import&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17acfb3fc2cc80c07ee41f3eeadca000eefd6ee0" translate="yes" xml:space="preserve">
          <source>This program searches the &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; for all objects that currently exist in a pack file as well as the independent object directories.</source>
          <target state="translated">该程序在 &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; 搜索包文件中当前存在的所有对象以及独立的对象目录。</target>
        </trans-unit>
        <trans-unit id="a85a25d731117b0f9fdffb50b50cd41a205c14dd" translate="yes" xml:space="preserve">
          <source>This public repository could further be mirrored, and that is how Git repositories at &lt;code&gt;kernel.org&lt;/code&gt; are managed.</source>
          <target state="translated">可以进一步镜像此公共存储库，这就是管理 &lt;code&gt;kernel.org&lt;/code&gt; 上的Git存储库的方式。</target>
        </trans-unit>
        <trans-unit id="3f74cf126c451b6a68e67763c97a8253f485453b" translate="yes" xml:space="preserve">
          <source>This puts a Git archive of the named CVS module in the directory &amp;lt;destination&amp;gt;, which will be created if necessary.</source>
          <target state="translated">这会将命名的CVS模块的Git存档放在目录&amp;lt;目标&amp;gt;中，该目录将在必要时创建。</target>
        </trans-unit>
        <trans-unit id="8831ce4f64ae931ef68e9c4eb0b8a48320fea478" translate="yes" xml:space="preserve">
          <source>This rebase can be performed using the &lt;code&gt;--rebase-merges&lt;/code&gt; option. It will generate a todo list looking like this:</source>
          <target state="translated">可以使用 &lt;code&gt;--rebase-merges&lt;/code&gt; 选项执行此重新设置。它将生成一个待办事项清单，如下所示：</target>
        </trans-unit>
        <trans-unit id="5e2dd779ca9f11c05d6bae58c7d8a031f404dc72" translate="yes" xml:space="preserve">
          <source>This ref is unchanged since the last import or fetch, although the helper cannot necessarily determine what value that produced.</source>
          <target state="translated">这个 ref 自上次导入或获取后没有变化,尽管帮助者不一定能确定产生了什么值。</target>
        </trans-unit>
        <trans-unit id="0e48a6f59fc5d06bf39a026582c3a2674a30ee86" translate="yes" xml:space="preserve">
          <source>This remote helper is transparently used by Git when you use commands such as &quot;git fetch &amp;lt;URL&amp;gt;&quot;, &quot;git clone &amp;lt;URL&amp;gt;&quot;, , &quot;git push &amp;lt;URL&amp;gt;&quot; or &quot;git remote add &amp;lt;nick&amp;gt; &amp;lt;URL&amp;gt;&quot;, where &amp;lt;URL&amp;gt; begins with &lt;code&gt;ext::&lt;/code&gt;. Examples:</source>
          <target state="translated">当您使用&amp;ldquo; git fetch &amp;lt;URL&amp;gt;&amp;rdquo;，&amp;ldquo; git clone &amp;lt;URL&amp;gt;&amp;rdquo;，&amp;ldquo; git push &amp;lt;URL&amp;gt;&amp;rdquo;或&amp;ldquo; git remote add &amp;lt;nick&amp;gt; &amp;lt;URL&amp;gt;&amp;rdquo;之类的命令时，Git会透明地使用此远程帮助器。 ，其中&amp;lt;URL&amp;gt;以 &lt;code&gt;ext::&lt;/code&gt; 开头。例子：</target>
        </trans-unit>
        <trans-unit id="76e69f76fb018209940d2bd178b055119cc99cef" translate="yes" xml:space="preserve">
          <source>This remote helper uses the specified &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; to connect to a remote Git server.</source>
          <target state="translated">该远程帮助程序使用指定的 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 连接到远程Git服务器。</target>
        </trans-unit>
        <trans-unit id="08f3058ad626936f077bcdb5101be9917b27eae0" translate="yes" xml:space="preserve">
          <source>This removes the &lt;code&gt;WIP&lt;/code&gt; commit from the commit history, and sets your working tree to the state just before you made that snapshot.</source>
          <target state="translated">这将从提交历史记录中删除 &lt;code&gt;WIP&lt;/code&gt; 提交，并将工作树设置为刚创建快照之前的状态。</target>
        </trans-unit>
        <trans-unit id="6cde691b95501235edce70baf30f3d475a6f05af" translate="yes" xml:space="preserve">
          <source>This removes the file from the index while keeping it in the working directory.</source>
          <target state="translated">这将从索引中删除文件,同时将其保留在工作目录中。</target>
        </trans-unit>
        <trans-unit id="f2e99bc05d5874bb5e940e93689126e6c4aa347e" translate="yes" xml:space="preserve">
          <source>This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the &lt;code&gt;recursive&lt;/code&gt; merge strategy.</source>
          <target state="translated">这样可以解析任意数量的head，但是合并的结果树始终是当前分支head的树，有效地忽略了所有其他分支的所有更改。它旨在取代侧支的旧开发历史。请注意，这与 &lt;code&gt;recursive&lt;/code&gt; 合并策略的-Xours选项不同。</target>
        </trans-unit>
        <trans-unit id="053dd73bd0ed92de95c5b132a1b4a0308f96cd04" translate="yes" xml:space="preserve">
          <source>This resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch.</source>
          <target state="translated">这可以解决两个以上头的情况,但拒绝做需要手动解决的复杂合并。它主要用于将主题分支头捆绑在一起。当拉取或合并多个分支时,这是默认的合并策略。</target>
        </trans-unit>
        <trans-unit id="e1337ea8d65ee53d09143c99f1f587dd31c2d238" translate="yes" xml:space="preserve">
          <source>This results in:</source>
          <target state="translated">这导致:</target>
        </trans-unit>
        <trans-unit id="a3acfff86d0ac3c7e1c1af7dc1decad57125efa5" translate="yes" xml:space="preserve">
          <source>This runs &lt;code&gt;git fsck --unreachable&lt;/code&gt; using all the refs available in &lt;code&gt;refs/&lt;/code&gt;, optionally with additional set of objects specified on the command line, and prunes all unpacked objects unreachable from any of these head objects from the object database. In addition, it prunes the unpacked objects that are also found in packs by running &lt;code&gt;git prune-packed&lt;/code&gt;. It also removes entries from .git/shallow that are not reachable by any ref.</source>
          <target state="translated">这将使用 &lt;code&gt;refs/&lt;/code&gt; 可用的所有ref 运行 &lt;code&gt;git fsck --unreachable&lt;/code&gt; ，还可以选择在命令行中指定其他对象集，并修剪所有从对象数据库中这些头对象中无法访问的所有未打包的对象。另外，它通过运行 &lt;code&gt;git prune-packed&lt;/code&gt; 来修剪在包中也可以找到的未打包对象。它还从.git / shallow中删除任何引用都无法访问的条目。</target>
        </trans-unit>
        <trans-unit id="66bb2cd044765c7338efb3b55d3b51e463e22970" translate="yes" xml:space="preserve">
          <source>This runs a virtual check-out and check-in of all three stages of a file when resolving a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See &quot;Merging branches with differing checkin/checkout attributes&quot; in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">解决三向合并时，这将对文件的所有三个阶段进行虚拟签出和签入。当合并具有不同原始过滤器或行尾规范化规则的分支时，应使用此选项。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]中的&lt;/a&gt; &amp;ldquo;合并具有不同签入/签出属性的分支&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="d37cfee1983b15d675f4e1a4163b8c978a492421" translate="yes" xml:space="preserve">
          <source>This says &quot;include everything in root, but nothing two levels below root.&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bd580b61f2b6d754a6c049f07ff919549d1439" translate="yes" xml:space="preserve">
          <source>This says &quot;include everything in root, but nothing two levels below root.&quot; If we then add the folder &lt;code&gt;A/B/C&lt;/code&gt; as a recursive pattern, the folders &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A/B&lt;/code&gt; are added as parent patterns. The resulting sparse-checkout file is now</source>
          <target state="translated">这表示&amp;ldquo;将所有内容都包含在根目录中，但不包括根目录下的两个级别&amp;rdquo;。如果随后将文件夹 &lt;code&gt;A/B/C&lt;/code&gt; 添加为递归模式，则文件夹 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;A/B&lt;/code&gt; 将作为父模式添加。现在生成的稀疏签出文件</target>
        </trans-unit>
        <trans-unit id="9f2fcd6a73ae4ce542d08fc5e7f799314e8e80fc" translate="yes" xml:space="preserve">
          <source>This script can be passed to &quot;git bisect run&quot; to find the commit that introduced a performance regression:</source>
          <target state="translated">这个脚本可以通过 &quot;git bisect run &quot;来找到引入性能回归的提交。</target>
        </trans-unit>
        <trans-unit id="72c86095923977328df35910b245e776428b840b" translate="yes" xml:space="preserve">
          <source>This script is included in various scripts to supply routines to parse files under $GIT_DIR/remotes/ and $GIT_DIR/branches/ and configuration variables that are related to fetching, pulling and pushing.</source>
          <target state="translated">这个脚本包含在各种脚本中,为解析$GIT_DIR/remotes/和$GIT_DIR/branches/下的文件提供例程,以及与取、拉、推相关的配置变量。</target>
        </trans-unit>
        <trans-unit id="a405ee4e7ff4cc67a738558081388543481850c0" translate="yes" xml:space="preserve">
          <source>This section can also be used by those who respond to &lt;code&gt;git
request-pull&lt;/code&gt; or pull-request on GitHub (www.github.com) to integrate the work of others into their history. A sub-area lieutenant for a repository will act both as a participant and as an integrator.</source>
          <target state="translated">响应GitHub（www.github.com）上的 &lt;code&gt;git request-pull&lt;/code&gt; 或pull-request 的人员也可以使用此部分，以将其他人的工作集成到他们的历史中。存储库的子区域副手将既充当参与者又充当集成者。</target>
        </trans-unit>
        <trans-unit id="53af582e47690e9820cb012bdcbccf97b8def7d3" translate="yes" xml:space="preserve">
          <source>This section explains how to configure some common webservers to run gitweb. In all cases, &lt;code&gt;/path/to/gitweb&lt;/code&gt; in the examples is the directory you ran installed gitweb in, and contains &lt;code&gt;gitweb_config.perl&lt;/code&gt;.</source>
          <target state="translated">本节说明如何配置一些常见的Web服务器以运行gitweb。在所有情况下，示例中的 &lt;code&gt;/path/to/gitweb&lt;/code&gt; 是您在其中安装gitweb的运行目录，其中包含 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79c0f1f15a38eae1b5cc2a5e381bfbc844ef9486" translate="yes" xml:space="preserve">
          <source>This section is only included if a packfile section is also included in the response.</source>
          <target state="translated">只有当响应中也包含Packfile部分时,才会包含这部分。</target>
        </trans-unit>
        <trans-unit id="f3cd5eb5a3885e012dabb05171cc566728c1791b" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git archive --remote&lt;/code&gt;. It is disabled by default, but a repository can enable it by setting &lt;code&gt;daemon.uploadarch&lt;/code&gt; configuration item to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这服务 &lt;code&gt;git archive --remote&lt;/code&gt; 。默认情况下禁用它，但是存储库可以通过将 &lt;code&gt;daemon.uploadarch&lt;/code&gt; 配置项设置为 &lt;code&gt;true&lt;/code&gt; 来启用它。</target>
        </trans-unit>
        <trans-unit id="a1fc9be9532fca80163bd11748e3553d0b5b85a4" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients. It is enabled by default, but a repository can disable it by setting &lt;code&gt;daemon.uploadpack&lt;/code&gt; configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">这为 &lt;code&gt;git fetch-pack&lt;/code&gt; 和 &lt;code&gt;git ls-remote&lt;/code&gt; 客户端提供服务。默认情况下启用它，但是存储库可以通过将 &lt;code&gt;daemon.uploadpack&lt;/code&gt; 配置项设置为 &lt;code&gt;false&lt;/code&gt; 来禁用它。</target>
        </trans-unit>
        <trans-unit id="ce507c3877f92fc6c1de609ca683d1e2a4e1b26f" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients. It is enabled by default, but a repository can disable it by setting this configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">这为 &lt;code&gt;git fetch-pack&lt;/code&gt; 和 &lt;code&gt;git ls-remote&lt;/code&gt; 客户端提供服务。默认情况下启用它，但是存储库可以通过将此配置项设置为 &lt;code&gt;false&lt;/code&gt; 来禁用它。</target>
        </trans-unit>
        <trans-unit id="f25bae0e6df9b1b4a76a588d485b17d422e56c18" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git send-pack&lt;/code&gt; clients, allowing anonymous push. It is disabled by default, as there is &lt;code&gt;no&lt;/code&gt; authentication in the protocol (in other words, anybody can push anything into the repository, including removal of refs). This is solely meant for a closed LAN setting where everybody is friendly. This service can be enabled by setting &lt;code&gt;daemon.receivepack&lt;/code&gt; configuration item to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这为 &lt;code&gt;git send-pack&lt;/code&gt; 客户端提供服务，允许匿名推送。默认情况下，它是禁用的，因为协议中 &lt;code&gt;no&lt;/code&gt; 身份验证（换句话说，任何人都可以将任何内容推送到存储库中，包括删除引用）。这仅适用于每个人都友好的封闭LAN设置。可以通过将 &lt;code&gt;daemon.receivepack&lt;/code&gt; 配置项设置为 &lt;code&gt;true&lt;/code&gt; 来启用此服务。</target>
        </trans-unit>
        <trans-unit id="6b2859849402fde4d51ffe73c129c97d00cb6083" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git send-pack&lt;/code&gt; clients, allowing push. It is disabled by default for anonymous users, and enabled by default for users authenticated by the web server. It can be disabled by setting this item to &lt;code&gt;false&lt;/code&gt;, or enabled for all users, including anonymous users, by setting it to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这为 &lt;code&gt;git send-pack&lt;/code&gt; 客户提供服务，允许推送。默认情况下，匿名用户禁用此功能，默认情况下，对于通过Web服务器认证的用户启用此功能。可以通过将此项目设置为 &lt;code&gt;false&lt;/code&gt; 来禁用它，或者通过将其设置为 &lt;code&gt;true&lt;/code&gt; 来为所有用户（包括匿名用户）启用。</target>
        </trans-unit>
        <trans-unit id="1d789007e515492a9cc42830b12a07ff1db6d084" translate="yes" xml:space="preserve">
          <source>This serves Git clients older than version 1.6.6 that are unable to use the upload pack service. When enabled, clients are able to read any file within the repository, including objects that are no longer reachable from a branch but are still present. It is enabled by default, but a repository can disable it by setting this configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">这为版本低于1.6.6的Git客户端提供服务，这些客户端无法使用上载包服务。启用后，客户端可以读取存储库中的任何文件，包括从分支不再可访问但仍然存在的对象。默认情况下启用它，但是存储库可以通过将此配置项设置为 &lt;code&gt;false&lt;/code&gt; 来禁用它。</target>
        </trans-unit>
        <trans-unit id="5456200c93d8963943eca093573a9d8938a4ea5f" translate="yes" xml:space="preserve">
          <source>This sets GIT_SVN_ID (instead of using the environment). This allows the user to override the default refname to fetch from when tracking a single URL. The &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;dcommit&lt;/code&gt; commands no longer require this switch as an argument.</source>
          <target state="translated">这将设置GIT_SVN_ID（而不是使用环境）。这允许用户在跟踪单个URL时覆盖要从中获取的默认refname。该 &lt;code&gt;log&lt;/code&gt; 和 &lt;code&gt;dcommit&lt;/code&gt; 命令不再需要这个开关作为参数。</target>
        </trans-unit>
        <trans-unit id="acb244d7aa46a820614aa10decb4464bc8ecabb6" translate="yes" xml:space="preserve">
          <source>This setting can be disabled by the &lt;code&gt;--no-notes&lt;/code&gt; option, overridden by the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable, and overridden by the &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt; option.</source>
          <target state="translated">可以通过 &lt;code&gt;--no-notes&lt;/code&gt; 选项禁用此设置，可以由 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 环境变量覆盖，而由 &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt; 选项覆盖。</target>
        </trans-unit>
        <trans-unit id="a8f435ef26eec94bd5c23846a74c0f4d57a87c8f" translate="yes" xml:space="preserve">
          <source>This setting can be overridden by passing the &lt;code&gt;--strategy&lt;/code&gt; option.</source>
          <target state="translated">可以通过传递 &lt;code&gt;--strategy&lt;/code&gt; 选项来覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="5d273f23cd160340c4f9b3fbc5a088c0fc2c32be" translate="yes" xml:space="preserve">
          <source>This setting can be overridden by the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable.</source>
          <target state="translated">可以通过 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 环境变量来覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="b28435a905552ea063d5203034696b428fdc0b87" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable, which must be a colon separated list of refs or globs.</source>
          <target state="translated">可以使用 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 环境变量来覆盖此设置，该环境变量必须是用冒号分隔的ref或glob列表。</target>
        </trans-unit>
        <trans-unit id="45473aa6b3903d5487aab6b473bcf528e266cdec" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_MODE&lt;/code&gt; environment variable.</source>
          <target state="translated">可以使用 &lt;code&gt;GIT_NOTES_REWRITE_MODE&lt;/code&gt; 环境变量来覆盖此设置。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
