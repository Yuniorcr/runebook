<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="3dfacf796b68e98a60c628fed43445479dc82ce1" translate="yes" xml:space="preserve">
          <source>The fast-import mechanism used by &lt;code&gt;git p4&lt;/code&gt; creates one pack file for each invocation of &lt;code&gt;git p4 sync&lt;/code&gt;. Normally, Git garbage compression (&lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;) automatically compresses these to fewer pack files, but explicit invocation of &lt;code&gt;git repack -adf&lt;/code&gt; may improve performance.</source>
          <target state="translated">&lt;code&gt;git p4&lt;/code&gt; 使用的快速导入机制为 &lt;code&gt;git p4 sync&lt;/code&gt; 的每次调用创建一个打包文件。通常，Git垃圾压缩（&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;）自动将它们压缩为更少的打包文件，但是显式调用 &lt;code&gt;git repack -adf&lt;/code&gt; 可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="53e903dc94674f5b365dd31d16a6c2e334c714e3" translate="yes" xml:space="preserve">
          <source>The fetch and push protocols are not designed to prevent one side from stealing data from the other repository that was not intended to be shared. If you have private data that you need to protect from a malicious peer, your best option is to store it in another repository. This applies to both clients and servers. In particular, namespaces on a server are not effective for read access control; you should only grant read access to a namespace to clients that you would trust with read access to the entire repository.</source>
          <target state="translated">获取和推送协议并不是为了防止一方从另一个存储库中窃取不打算共享的数据而设计的。如果你有需要保护的私有数据不被恶意的对等方窃取,你最好的选择是将其存储在另一个存储库中。这适用于客户端和服务器。特别是,服务器上的命名空间对于读取访问控制是无效的;你应该只将对命名空间的读取访问权授予那些你会信任的对整个存储库有读取访问权的客户端。</target>
        </trans-unit>
        <trans-unit id="648bf821f46e9909499e1fbac0dd96a1ab871eb7" translate="yes" xml:space="preserve">
          <source>The fields (including the &lt;code&gt;-&amp;gt;&lt;/code&gt;) are separated from each other by a single space. If a filename contains whitespace or other nonprintable characters, that field will be quoted in the manner of a C string literal: surrounded by ASCII double quote (34) characters, and with interior special characters backslash-escaped.</source>
          <target state="translated">各个字段（包括 &lt;code&gt;-&amp;gt;&lt;/code&gt; ）之间用一个空格隔开。如果文件名包含空格或其他不可打印的字符，则该字段将以C字符串文字的形式引用：用ASCII双引号（34）字符包围，并用反斜杠转义的内部特殊字符。</target>
        </trans-unit>
        <trans-unit id="3994e582754827987cb1dab035b29a73b90c4b3e" translate="yes" xml:space="preserve">
          <source>The file consists of sections and variables. A section begins with the name of the section in square brackets and continues until the next section begins. Section names are case-insensitive. Only alphanumeric characters, &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;.&lt;/code&gt; are allowed in section names. Each variable must belong to some section, which means that there must be a section header before the first setting of a variable.</source>
          <target state="translated">该文件包含节和变量。一个部分以方括号中的部分名称开头，一直持续到下一个部分开始为止。节名称不区分大小写。仅字母数字字符 &lt;code&gt;-&lt;/code&gt; 和 &lt;code&gt;.&lt;/code&gt; 节名称中允许使用。每个变量必须属于某个节，这意味着在第一次设置变量之前必须有一个节头。</target>
        </trans-unit>
        <trans-unit id="b77694751b662ffffe51a33dc2cd7f9b8be897f4" translate="yes" xml:space="preserve">
          <source>The file contains one subsection per submodule, and the subsection value is the name of the submodule. The name is set to the path where the submodule has been added unless it was customized with the &lt;code&gt;--name&lt;/code&gt; option of &lt;code&gt;git submodule add&lt;/code&gt;. Each submodule section also contains the following required keys:</source>
          <target state="translated">该文件每个子模块包含一个子节，该子节的值是子模块的名称。该名称设置为添加子模块的路径，除非使用 &lt;code&gt;git submodule add&lt;/code&gt; 的 &lt;code&gt;--name&lt;/code&gt; 选项对其进行了自定义。每个子模块部分还包含以下必需键：</target>
        </trans-unit>
        <trans-unit id="d7d8ebbce919f993c68a8bac80b9fbb16d92024e" translate="yes" xml:space="preserve">
          <source>The file format includes parameters for the object ID hash function, so a future change of hash algorithm does not require a change in format.</source>
          <target state="translated">文件格式中包含了对象ID哈希函数的参数,所以将来改变哈希算法不需要改变格式。</target>
        </trans-unit>
        <trans-unit id="1bb6e340dc566db02505e0c4003761a9d85c40c1" translate="yes" xml:space="preserve">
          <source>The file is concluded with a trailer:</source>
          <target state="translated">文件的最后是一个预告片。</target>
        </trans-unit>
        <trans-unit id="996f5fbcdb16f7d7ee85c3a6ae77d46a1781884a" translate="yes" xml:space="preserve">
          <source>The file parameters can point at the user&amp;rsquo;s working file (e.g. &lt;code&gt;new-file&lt;/code&gt; in &quot;git-diff-files&quot;), &lt;code&gt;/dev/null&lt;/code&gt; (e.g. &lt;code&gt;old-file&lt;/code&gt; when a new file is added), or a temporary file (e.g. &lt;code&gt;old-file&lt;/code&gt; in the index). &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; should not worry about unlinking the temporary file --- it is removed when &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; exits.</source>
          <target state="translated">该文件中的参数可以在用户的工作文件指向（如 &lt;code&gt;new-file&lt;/code&gt; 在&amp;ldquo;混帐的Diff-文件&amp;rdquo;）， &lt;code&gt;/dev/null&lt;/code&gt; （如 &lt;code&gt;old-file&lt;/code&gt; 时添加一个新的文件），或临时文件（如 &lt;code&gt;old-file&lt;/code&gt; 索引中的文件）。 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 不必担心取消链接临时文件---在退出 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 时将其删除。</target>
        </trans-unit>
        <trans-unit id="b979e5d416845ad4db7c29ab613bf67d05d7d448" translate="yes" xml:space="preserve">
          <source>The files are read in the order given above, with last value found taking precedence over values read earlier. When multiple values are taken then all values of a key from all files will be used.</source>
          <target state="translated">文件按上述顺序读取,最后找到的值优先于前面读取的值。当取多个值时,则将使用所有文件中一个键的所有值。</target>
        </trans-unit>
        <trans-unit id="22cd650e22be9431ebec70f16e27f0954b25a243" translate="yes" xml:space="preserve">
          <source>The files to read the patch from. &lt;code&gt;-&lt;/code&gt; can be used to read from the standard input.</source>
          <target state="translated">从中读取补丁的文件。 &lt;code&gt;-&lt;/code&gt; 可用于从标准输入中读取。</target>
        </trans-unit>
        <trans-unit id="fc839d554b73db3187cb52551b31c221d5647965" translate="yes" xml:space="preserve">
          <source>The filter is expected to respond with a list of &quot;key=value&quot; pairs terminated with a flush packet. If the filter does not experience problems then the list must contain a &quot;success&quot; status. Right after these packets the filter is expected to send the content in zero or more pkt-line packets and a flush packet at the end. Finally, a second list of &quot;key=value&quot; pairs terminated with a flush packet is expected. The filter can change the status in the second list or keep the status as is with an empty list. Please note that the empty list must be terminated with a flush packet regardless.</source>
          <target state="translated">过滤器应该用一个 &quot;key=value &quot;对的列表来响应,并以一个冲洗包结束。如果过滤器没有遇到问题,那么这个列表必须包含一个 &quot;成功 &quot;状态。就在这些数据包之后,过滤器要以0个或更多的pkt-line数据包发送内容,并在最后发送一个flush数据包。最后,预计第二个 &quot;key=value &quot;对的列表将以一个flush包结束。过滤器可以改变第二个列表中的状态,也可以用一个空列表保持状态不变。请注意,无论如何,空列表都必须以一个flush包结束。</target>
        </trans-unit>
        <trans-unit id="48c7b9e769ad1a8ac7a03d8a91befba4e1dc75d4" translate="yes" xml:space="preserve">
          <source>The filter that will be applied when fetching from this promisor remote.</source>
          <target state="translated">从这个远程承诺者获取信息时应用的过滤器。</target>
        </trans-unit>
        <trans-unit id="67e1cbcd0bc26ca591869ec55e18981d4a05f31d" translate="yes" xml:space="preserve">
          <source>The filters are applied in the order as listed below. The &amp;lt;command&amp;gt; argument is always evaluated in the shell context using the &lt;code&gt;eval&lt;/code&gt; command (with the notable exception of the commit filter, for technical reasons). Prior to that, the &lt;code&gt;$GIT_COMMIT&lt;/code&gt; environment variable will be set to contain the id of the commit being rewritten. Also, GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE, GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL, and GIT_COMMITTER_DATE are taken from the current commit and exported to the environment, in order to affect the author and committer identities of the replacement commit created by &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; after the filters have run.</source>
          <target state="translated">过滤器的应用顺序如下。始终在shell上下文中使用 &lt;code&gt;eval&lt;/code&gt; 命令评估&amp;lt;command&amp;gt;参数（出于技术原因，commit过滤器明显例外）。在此之前， &lt;code&gt;$GIT_COMMIT&lt;/code&gt; 环境变量将设置为包含要重写的提交的ID。另外，GIT_AUTHOR_NAME，GIT_AUTHOR_EMAIL，GIT_AUTHOR_DATE，GIT_COMMITTER_NAME，GIT_COMMITTER_EMAIL和GIT_COMMITTER_DATE均从当前提交中提取并导出到环境中，以影响由&lt;a href=&quot;git-commit-tree&quot;&gt;[1]&lt;/a&gt;在git-commit-tree之后创建的替换提交的作者和提交者身份筛选器已运行。</target>
        </trans-unit>
        <trans-unit id="96e6a8e11c595c66ed126e7ed94498b41b8ef74c" translate="yes" xml:space="preserve">
          <source>The final &quot;/&quot; is important. The exported name is literally just prefixed with the specified string. Contrast this with the following example.</source>
          <target state="translated">最后的&quot;/&quot;很重要。导出的名称实际上只是用指定的字符串作为前缀。与下面的例子进行对比。</target>
        </trans-unit>
        <trans-unit id="5e71083855686454b686d549c1aa754044d9c24f" translate="yes" xml:space="preserve">
          <source>The final result will be a series of commits, one for each patch in the original mailbox, with authorship and commit log message each taken from the message containing each patch.</source>
          <target state="translated">最后的结果将是一系列的提交,每个补丁在原始邮箱中都有一个,作者和提交日志信息分别取自包含每个补丁的消息。</target>
        </trans-unit>
        <trans-unit id="d06dc79919ba8d7d4e32bae22586b9e61ea6ab90" translate="yes" xml:space="preserve">
          <source>The first &quot;git bisect&quot; subcommand to use is &quot;git bisect start&quot; to start the search. Then bounds must be set to limit the commit space. This is done usually by giving one &quot;bad&quot; and at least one &quot;good&quot; commit. They can be passed in the initial call to &quot;git bisect start&quot; like this:</source>
          <target state="translated">第一个要使用的 &quot;git bisect &quot;子命令是 &quot;git bisect start&quot;,开始搜索。然后,必须设置限制提交空间的界限,这通常是通过给出一个 &quot;坏 &quot;和至少一个 &quot;好 &quot;的提交来完成的。这通常是通过给出一个 &quot;坏的 &quot;和至少一个 &quot;好的 &quot;提交来完成的,它们可以在 &quot;git bisect start &quot;的初始调用中传递。在调用 &quot;git bisect start &quot;时,可以像这样传递它们。</target>
        </trans-unit>
        <trans-unit id="7d24667b8a3af4ae680279e90e5939ecc7d57754" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;N&lt;/code&gt; lines of the message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd96cc8c67fe6f3794e1faadfc16d4e75778490" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;origin&lt;/code&gt;, just tells Git to fetch from the repository you originally cloned from. The second argument tells Git to fetch the branch named &lt;code&gt;todo&lt;/code&gt; from the remote repository, and to store it locally under the name &lt;code&gt;refs/heads/my-todo-work&lt;/code&gt;.</source>
          <target state="translated">第一个参数 &lt;code&gt;origin&lt;/code&gt; 只是告诉Git从最初克隆的存储库中获取。第二个参数告诉Git 从远程存储库获取名为 &lt;code&gt;todo&lt;/code&gt; 的分支，并将其以 &lt;code&gt;refs/heads/my-todo-work&lt;/code&gt; 的名称本地存储。</target>
        </trans-unit>
        <trans-unit id="81bbac8df429c9294b949507806676c0327c9227" translate="yes" xml:space="preserve">
          <source>The first character given by this option will be the default character used when another separator is not specified in the config for this trailer.</source>
          <target state="translated">该选项给出的第一个字符将是该预告片配置中未指定其他分隔符时的默认字符。</target>
        </trans-unit>
        <trans-unit id="39b9ae2f52daae0742c9cd959c54a342268035c6" translate="yes" xml:space="preserve">
          <source>The first command fetches the &lt;code&gt;maint&lt;/code&gt; branch from the repository at &lt;code&gt;git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt; and the second command uses &lt;code&gt;FETCH_HEAD&lt;/code&gt; to examine the branch with &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;. The fetched objects will eventually be removed by git&amp;rsquo;s built-in housekeeping (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;).</source>
          <target state="translated">第一个命令从 &lt;code&gt;git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt; 的存储库中获取 &lt;code&gt;maint&lt;/code&gt; 分支，第二个命令使用 &lt;code&gt;FETCH_HEAD&lt;/code&gt; 通过&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;检查该分支。所获取的对象最终将由git的内置管家删除（请参见&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fc54aa6f7f46c36afb224191ab9ce02506aa2fd9" translate="yes" xml:space="preserve">
          <source>The first defense against such problems is backups. You can back up a Git directory using clone, or just using cp, tar, or any other backup mechanism.</source>
          <target state="translated">对此类问题的第一道防线就是备份。你可以使用clone备份Git目录,或者直接使用cp、tar或其他备份机制。</target>
        </trans-unit>
        <trans-unit id="eb17679ed2c14d3eecb0f1bd83c98beea1f4bea4" translate="yes" xml:space="preserve">
          <source>The first format is what gets used when &lt;code&gt;--stage&lt;/code&gt; is omitted or is not &lt;code&gt;--stage=all&lt;/code&gt;. The field tempname is the temporary file name holding the file content and path is the tracked path name in the index. Only the requested entries are output.</source>
          <target state="translated">第一种格式是 &lt;code&gt;--stage&lt;/code&gt; 省略或不是 &lt;code&gt;--stage=all&lt;/code&gt; 时使用的格式。字段tempname是保存文件内容的临时文件名，path是索引中跟踪的路径名。仅输出所请求的条目。</target>
        </trans-unit>
        <trans-unit id="e7e26fcb00a95d796be86027e9776fd349443123" translate="yes" xml:space="preserve">
          <source>The first is simple and appropriate if you do not have secure storage available for a password. It is generally configured by adding this to your config:</source>
          <target state="translated">第一种方法很简单,如果你没有安全的密码存储空间,那么这种方法是合适的。一般是通过在你的config中添加这个来配置的。</target>
        </trans-unit>
        <trans-unit id="51f664b1e28dce07dd2c1ef3f2cc4ddb005556f4" translate="yes" xml:space="preserve">
          <source>The first issue is performance. Unlike any previous option, the &lt;code&gt;--simplify-merges&lt;/code&gt; option requires walking the entire commit history before returning a single result. This can make the option difficult to use for very large repositories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="561e4f0c34cc864db97b2078e570c6b7cf2ee83d" translate="yes" xml:space="preserve">
          <source>The first line of the input feeds 0 as the mode to remove the path; the SHA-1 does not matter as long as it is well formatted. Then the second and third line feeds stage 1 and stage 2 entries for that path. After the above, we would end up with this:</source>
          <target state="translated">输入的第一行输入0作为删除路径的模式,SHA-1并不重要,只要格式良好即可。然后第二行和第三行输入该路径的阶段1和阶段2条目。经过上面的操作,我们最终会得到这样的结果。</target>
        </trans-unit>
        <trans-unit id="d7a467221d570ce5d2e2454d168c252049fa7e64" translate="yes" xml:space="preserve">
          <source>The first number is the number of objects which are kept in individual files. The second is the amount of space taken up by those &quot;loose&quot; objects.</source>
          <target state="translated">第一个数字是保存在单个文件中的对象数量。第二个数字是这些 &quot;松散 &quot;物体所占的空间。</target>
        </trans-unit>
        <trans-unit id="a3a16231598a15324fe96a0d30a2003f1c762045" translate="yes" xml:space="preserve">
          <source>The first paragraph of the message, which typically is a single line, is taken as the &quot;subject&quot; of the commit or the tag message. Instead of &lt;code&gt;contents:subject&lt;/code&gt;, field &lt;code&gt;subject&lt;/code&gt; can also be used to obtain same results. &lt;code&gt;:sanitize&lt;/code&gt; can be appended to &lt;code&gt;subject&lt;/code&gt; for subject line suitable for filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1517f019c895db91a3158888218e464c0e667ed4" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the hook is the indicator for the working directory being updated. &quot;1&quot; meaning working directory was updated or &quot;0&quot; when the working directory was not updated.</source>
          <target state="translated">传递给钩子的第一个参数是被更新的工作目录的指示器,&quot;1 &quot;表示工作目录被更新,&quot;0 &quot;表示工作目录没有被更新。&quot;1 &quot;表示工作目录被更新,&quot;0 &quot;表示工作目录没有被更新。</target>
        </trans-unit>
        <trans-unit id="69f4b05a4b19ebccc10062a19a78b72d37ff6b60" translate="yes" xml:space="preserve">
          <source>The first rule takes precedence in the case of a single &amp;lt;commit&amp;gt;. To apply the second rule, i.e., format everything since the beginning of history up until &amp;lt;commit&amp;gt;, use the &lt;code&gt;--root&lt;/code&gt; option: &lt;code&gt;git format-patch
--root &amp;lt;commit&amp;gt;&lt;/code&gt;. If you want to format only &amp;lt;commit&amp;gt; itself, you can do this with &lt;code&gt;git format-patch -1 &amp;lt;commit&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">对于单个&amp;lt;commit&amp;gt;，第一个规则优先。要应用第二条规则，即格式化从历史记录开始到&amp;lt;commit&amp;gt;的所有内容，请使用 &lt;code&gt;--root&lt;/code&gt; 选项： &lt;code&gt;git format-patch --root &amp;lt;commit&amp;gt;&lt;/code&gt; 。如果只想格式化&amp;lt;commit&amp;gt;本身，则可以使用 &lt;code&gt;git format-patch -1 &amp;lt;commit&amp;gt;&lt;/code&gt; 进行格式化。</target>
        </trans-unit>
        <trans-unit id="088dfc95ab36375e45956a12e0a84d20b54cd1e3" translate="yes" xml:space="preserve">
          <source>The first step is trivial: when you want to tell Git about any changes to your working tree, you use the &lt;code&gt;git update-index&lt;/code&gt; program. That program normally just takes a list of filenames you want to update, but to avoid trivial mistakes, it refuses to add new entries to the index (or remove existing ones) unless you explicitly tell it that you&amp;rsquo;re adding a new entry with the &lt;code&gt;--add&lt;/code&gt; flag (or removing an entry with the &lt;code&gt;--remove&lt;/code&gt;) flag.</source>
          <target state="translated">第一步很简单：当您想告诉Git您对工作树的任何更改时，请使用 &lt;code&gt;git update-index&lt;/code&gt; 程序。该程序通常只获取您要更新的文件名列表，但为避免琐碎的错误，除非您明确告诉它要添加新条目，否则它将拒绝向索引添加新条目（或删除现有条目）。 &lt;code&gt;--add&lt;/code&gt; 标志（或使用 &lt;code&gt;--remove&lt;/code&gt; 删除条目）标志。</target>
        </trans-unit>
        <trans-unit id="a1763915dd6826ebefd6dfcb3fd9fb79e61ff2f7" translate="yes" xml:space="preserve">
          <source>The first time that a commit shows up in the stream, it has various other information about it printed out with a one-word tag at the beginning of each line describing the extra commit information (author, email, committer, dates, summary, etc.).</source>
          <target state="translated">当一个提交第一次出现在流中时,它的各种其他信息都会被打印出来,每行开头都有一个单字标签,描述额外的提交信息(作者、电子邮件、提交者、日期、摘要等)。</target>
        </trans-unit>
        <trans-unit id="33e2d00ff1c333999b37d340bc5ae3e8a3bfd826" translate="yes" xml:space="preserve">
          <source>The first time you run it, you will be prompted for your credentials. Enter the app-specific or your regular password as appropriate. If you have credential helper configured (see &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt;), the password will be saved in the credential store so you won&amp;rsquo;t have to type it the next time.</source>
          <target state="translated">首次运行时，将提示您输入凭据。输入特定于应用程序的密码或您的常规密码。如果您配置了凭据帮助程序（请参阅&lt;a href=&quot;git-credential&quot;&gt;git-credential [1]&lt;/a&gt;），则密码将保存在凭据存储区中，因此下次无需键入密码。</target>
        </trans-unit>
        <trans-unit id="1c77b9db9c00c5ba7e83e0fb24758e48237c23ee" translate="yes" xml:space="preserve">
          <source>The first two lines indicate that it is showing the two branches with the titles of their top-of-the-tree commits, you are currently on &lt;code&gt;master&lt;/code&gt; branch (notice the asterisk &lt;code&gt;*&lt;/code&gt; character), and the first column for the later output lines is used to show commits contained in the &lt;code&gt;master&lt;/code&gt; branch, and the second column for the &lt;code&gt;mybranch&lt;/code&gt; branch. Three commits are shown along with their titles. All of them have non blank characters in the first column (&lt;code&gt;*&lt;/code&gt; shows an ordinary commit on the current branch, &lt;code&gt;-&lt;/code&gt; is a merge commit), which means they are now part of the &lt;code&gt;master&lt;/code&gt; branch. Only the &quot;Some work&quot; commit has the plus &lt;code&gt;+&lt;/code&gt; character in the second column, because &lt;code&gt;mybranch&lt;/code&gt; has not been merged to incorporate these commits from the master branch. The string inside brackets before the commit log message is a short name you can use to name the commit. In the above example, &lt;code&gt;master&lt;/code&gt; and &lt;code&gt;mybranch&lt;/code&gt; are branch heads. &lt;code&gt;master^&lt;/code&gt; is the first parent of &lt;code&gt;master&lt;/code&gt; branch head. Please see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; if you want to see more complex cases.</source>
          <target state="translated">前两行表明它正在显示两个分支，并具有其树顶提交的标题，您当前位于 &lt;code&gt;master&lt;/code&gt; 分支上（请注意星号 &lt;code&gt;*&lt;/code&gt; 字符），后面输出行的第一列是用于显示 &lt;code&gt;master&lt;/code&gt; 分支中包含的提交，以及 &lt;code&gt;mybranch&lt;/code&gt; 分支的第二列。显示了三个提交及其标题。它们全部在第一列中具有非空白字符（ &lt;code&gt;*&lt;/code&gt; 显示当前分支上的普通提交， &lt;code&gt;-&lt;/code&gt; 是合并提交），这意味着它们现在是 &lt;code&gt;master&lt;/code&gt; 分支的一部分。只有&amp;ldquo;某些工作&amp;rdquo;提交才有加号 &lt;code&gt;+&lt;/code&gt; 第二列中的字符，因为 &lt;code&gt;mybranch&lt;/code&gt; 尚未合并以合并master分支中的这些提交。提交日志消息前方括号内的字符串是可用于命名提交的缩写。在上面的示例中， &lt;code&gt;master&lt;/code&gt; 和 &lt;code&gt;mybranch&lt;/code&gt; 是分支头。 &lt;code&gt;master^&lt;/code&gt; 是 &lt;code&gt;master&lt;/code&gt; 分支头的第一个父代。如果您想查看更复杂的情况，请参阅&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b2c923c8cb34a6329089d3ed63e2b76d6f7ceed" translate="yes" xml:space="preserve">
          <source>The folder to drop the mails into, which is typically the Drafts folder. For example: &quot;INBOX.Drafts&quot;, &quot;INBOX/Drafts&quot; or &quot;[Gmail]/Drafts&quot;. Required.</source>
          <target state="translated">要将邮件投递到的文件夹,通常是Drafts文件夹。例如:&quot;INBOX.Drafts&quot;、&quot;INBOX/Drafts &quot;或&quot;[Gmail]/Drafts&quot;。&quot;INBOX.Drafts&quot;,&quot;INBOX/Drafts &quot;或&quot;[Gmail]/Drafts&quot;。需要。</target>
        </trans-unit>
        <trans-unit id="396ef1fe12b6dc07f4e5a4f66f87333df9fb56e3" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;update&lt;/code&gt; procedures are only available via the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration variable:</source>
          <target state="translated">以下 &lt;code&gt;update&lt;/code&gt; 过程仅可通过 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 配置变量使用：</target>
        </trans-unit>
        <trans-unit id="109e44e80a38f6553ddae4455bbabc5ec0d98180" translate="yes" xml:space="preserve">
          <source>The following Thunderbird extensions are needed: AboutConfig from &lt;a href=&quot;http://aboutconfig.mozdev.org/&quot;&gt;http://aboutconfig.mozdev.org/&lt;/a&gt; and External Editor from &lt;a href=&quot;http://globs.org/articles.php?lng=en&amp;amp;pg=8&quot;&gt;http://globs.org/articles.php?lng=en&amp;amp;pg=8&lt;/a&gt;</source>
          <target state="translated">需要以下Thunderbird扩展：&lt;a href=&quot;http://aboutconfig.mozdev.org/&quot;&gt;http&lt;/a&gt; ://aboutconfig.mozdev.org/中的AboutConfig 和&lt;a href=&quot;http://globs.org/articles.php?lng=en&amp;amp;pg=8&quot;&gt;http://globs.org/articles.php?lng=en&amp;amp;pg=8中的&lt;/a&gt;外部编辑器</target>
        </trans-unit>
        <trans-unit id="f6722fafbaf6d78a6b809eec36e0605e28b20857" translate="yes" xml:space="preserve">
          <source>The following are helper commands used by the above; end users typically do not use them directly.</source>
          <target state="translated">以下是上述使用的辅助命令,最终用户一般不直接使用。</target>
        </trans-unit>
        <trans-unit id="e785808b3cacaeabb63607758cc61e3471a646e6" translate="yes" xml:space="preserve">
          <source>The following browsers (or commands) are currently supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e10909a1942dd56a826033bd880f2f38314517d" translate="yes" xml:space="preserve">
          <source>The following command switches to the &quot;master&quot; branch:</source>
          <target state="translated">下面的命令可以切换到 &quot;主 &quot;分支。</target>
        </trans-unit>
        <trans-unit id="7a4f4c25f3029fcde1d4a38239fa9b13c5887156" translate="yes" xml:space="preserve">
          <source>The following command-line options change import semantics and may therefore not be passed as option:</source>
          <target state="translated">以下命令行选项改变了导入语义,因此不能作为选项传递。</target>
        </trans-unit>
        <trans-unit id="932cde1c301ce345d40b274a1f81ff3e5be711e6" translate="yes" xml:space="preserve">
          <source>The following command-specific comments apply:</source>
          <target state="translated">以下是对特定命令的评论。</target>
        </trans-unit>
        <trans-unit id="d6f2de10386ef19748ad0fa0931b3359b3969227" translate="yes" xml:space="preserve">
          <source>The following config settings can be used to modify &lt;code&gt;git p4&lt;/code&gt; behavior. They all are in the &lt;code&gt;git-p4&lt;/code&gt; section.</source>
          <target state="translated">以下配置设置可用于修改 &lt;code&gt;git p4&lt;/code&gt; 行为。它们都在 &lt;code&gt;git-p4&lt;/code&gt; 部分中。</target>
        </trans-unit>
        <trans-unit id="f68ee79cc1f0c0e26a0c766d89a6823644298bab" translate="yes" xml:space="preserve">
          <source>The following configuration variables tell gitweb where to find files. The values of these variables are paths on the filesystem.</source>
          <target state="translated">以下配置变量告诉gitweb在哪里查找文件。这些变量的值是文件系统中的路径。</target>
        </trans-unit>
        <trans-unit id="446ebc694e2441273405a78869483ed3506272c8" translate="yes" xml:space="preserve">
          <source>The following date formats are supported. A frontend should select the format it will use for this import by passing the format name in the --date-format=&amp;lt;fmt&amp;gt; command-line option.</source>
          <target state="translated">支持以下日期格式。前端应通过在--date-format = &amp;lt;fmt&amp;gt;命令行选项中传递格式名称来选择用于此导入的格式。</target>
        </trans-unit>
        <trans-unit id="e77a52167245e31f57d9305063355588365e98e5" translate="yes" xml:space="preserve">
          <source>The following description divides the low-level commands into commands that manipulate objects (in the repository, index, and working tree), commands that interrogate and compare objects, and commands that move objects and references between repositories.</source>
          <target state="translated">下面的描述将低级命令分为操作对象(在资源库、索引和工作树中)的命令、查询和比较对象的命令以及在资源库之间移动对象和引用的命令。</target>
        </trans-unit>
        <trans-unit id="0ccfcc7705084a20c6fb8eba32c2c2f3d02467cc" translate="yes" xml:space="preserve">
          <source>The following documentation pages are guides about Git concepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce90b7b29314319d9c33a8b52e106d84ec9670f" translate="yes" xml:space="preserve">
          <source>The following escape sequences (beside &lt;code&gt;\&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt;) are recognized: &lt;code&gt;\n&lt;/code&gt; for newline character (NL), &lt;code&gt;\t&lt;/code&gt; for horizontal tabulation (HT, TAB) and &lt;code&gt;\b&lt;/code&gt; for backspace (BS). Other char escape sequences (including octal escape sequences) are invalid.</source>
          <target state="translated">可以识别以下转义序列（在 &lt;code&gt;\&quot;&lt;/code&gt; 和 &lt;code&gt;\\&lt;/code&gt; 旁边）： &lt;code&gt;\n&lt;/code&gt; 代表换行符（NL）， &lt;code&gt;\t&lt;/code&gt; 代表水平制表符（HT，TAB）， &lt;code&gt;\b&lt;/code&gt; 代表退格键（BS）。其他char逃逸序列（包括八进制）转义序列）无效。</target>
        </trans-unit>
        <trans-unit id="11e92a0ce8b123a34278f747bf61153deb05c5a4" translate="yes" xml:space="preserve">
          <source>The following example shows three branches, &quot;master&quot;, &quot;fixes&quot; and &quot;mhf&quot;:</source>
          <target state="translated">下面的例子显示了三个分支,&quot;master&quot;、&quot;fixes &quot;和 &quot;mhf&quot;。</target>
        </trans-unit>
        <trans-unit id="4297ab330b843af6f1af2259ff9a055a87b6bf37" translate="yes" xml:space="preserve">
          <source>The following features from &amp;lsquo;svn log&amp;rsquo; are supported:</source>
          <target state="translated">支持&amp;ldquo; svn日志&amp;rdquo;中的以下功能：</target>
        </trans-unit>
        <trans-unit id="9b96392c24cd31061920293e2fd2511a8543969f" translate="yes" xml:space="preserve">
          <source>The following flags further affect the behavior when comparing commits (but not trees).</source>
          <target state="translated">以下标志会进一步影响比较提交(但不是树)时的行为。</target>
        </trans-unit>
        <trans-unit id="c98119f1eba9806e1383e47ef0aa9d751dbdff13" translate="yes" xml:space="preserve">
          <source>The following format are available:</source>
          <target state="translated">有以下格式可供选择:</target>
        </trans-unit>
        <trans-unit id="7e633b53438db1ba002f1e1e7fca5cd2fc86227f" translate="yes" xml:space="preserve">
          <source>The following information is captured automatically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25c21591a2ca83e23e48f87144d8a587685473b" translate="yes" xml:space="preserve">
          <source>The following information is requested from the user:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f08fc55d496958a337ddcb6a67febfb89f85554" translate="yes" xml:space="preserve">
          <source>The following key/value pairs are common to all events:</source>
          <target state="translated">以下键/值对是所有事件的共同点:</target>
        </trans-unit>
        <trans-unit id="0a5e5ff367236dbd6bf5580d5af5e71ae090b770" translate="yes" xml:space="preserve">
          <source>The following options affect the way the simplification is performed:</source>
          <target state="translated">以下选项会影响简化的方式。</target>
        </trans-unit>
        <trans-unit id="d99d5d2882d3fb95fadc56a0416699f5b886386d" translate="yes" xml:space="preserve">
          <source>The following options are available in either location:</source>
          <target state="translated">以下选项可在任一地点使用:</target>
        </trans-unit>
        <trans-unit id="6e9dd1ef0925dcf9e09b1e6e501e8d0360e77eba" translate="yes" xml:space="preserve">
          <source>The following options are defined and (under suitable circumstances) set by Git if the remote helper has the &lt;code&gt;option&lt;/code&gt; capability.</source>
          <target state="translated">如果远程帮助程序具有 &lt;code&gt;option&lt;/code&gt; 功能，则由Git定义并（在适当的情况下）设置以下选项。</target>
        </trans-unit>
        <trans-unit id="ad97d4ffb6c58a93bf3193a5402926d11d214aa1" translate="yes" xml:space="preserve">
          <source>The following options select the commits to be shown:</source>
          <target state="translated">以下选项选择要显示的提交。</target>
        </trans-unit>
        <trans-unit id="04bd1c24e8e494894e5123ce96e6c123a135b194" translate="yes" xml:space="preserve">
          <source>The following options:</source>
          <target state="translated">以下选项:</target>
        </trans-unit>
        <trans-unit id="7b3b3b2ba3a3d71942fecd2cbccdbee3fd847246" translate="yes" xml:space="preserve">
          <source>The following sequence attempts to backport a patch, bails out because the code the patch applies to has changed too much, and then tries again, this time exercising more care about matching up context lines.</source>
          <target state="translated">下面的序列试图回溯一个补丁,因为补丁所应用的代码变化太大而退出,然后再次尝试,这次在匹配上下文行时更加小心。</target>
        </trans-unit>
        <trans-unit id="0fb6c7c3c1a2e6361aa6d0f3ddafd309ebc6378c" translate="yes" xml:space="preserve">
          <source>The following sequence checks out the &lt;code&gt;master&lt;/code&gt; branch, reverts the &lt;code&gt;Makefile&lt;/code&gt; to two revisions back, deletes &lt;code&gt;hello.c&lt;/code&gt; by mistake, and gets it back from the index.</source>
          <target state="translated">以下序列检出 &lt;code&gt;master&lt;/code&gt; 分支，将 &lt;code&gt;Makefile&lt;/code&gt; 恢复为两个修订版本，错误地删除 &lt;code&gt;hello.c&lt;/code&gt; ，然后将其从索引中取回。</target>
        </trans-unit>
        <trans-unit id="b8a40037f7e020ad1f156eb7f08942ca8112c080" translate="yes" xml:space="preserve">
          <source>The following sequence switches to the &lt;code&gt;master&lt;/code&gt; branch, reverts the &lt;code&gt;Makefile&lt;/code&gt; to two revisions back, deletes hello.c by mistake, and gets it back from the index.</source>
          <target state="translated">以下序列切换到 &lt;code&gt;master&lt;/code&gt; 分支，将 &lt;code&gt;Makefile&lt;/code&gt; 恢复为两个修订版本，错误地删除hello.c，然后将其从索引中恢复。</target>
        </trans-unit>
        <trans-unit id="75477915a08ed3777518303fe3302c5a880167a8" translate="yes" xml:space="preserve">
          <source>The following sequences have a special meaning:</source>
          <target state="translated">以下序列具有特殊意义。</target>
        </trans-unit>
        <trans-unit id="b07d72a39fdd44876a293ab8f917fa6a1014bd8c" translate="yes" xml:space="preserve">
          <source>The following subcommands are available:</source>
          <target state="translated">可使用以下子命令。</target>
        </trans-unit>
        <trans-unit id="55332124e1bbf00265c49abce68b19cb8696bb39" translate="yes" xml:space="preserve">
          <source>The following syntaxes may be used with them:</source>
          <target state="translated">可与它们一起使用下列语法:</target>
        </trans-unit>
        <trans-unit id="f9c489d8b69bf82a63ff4a237dd2bd772b8fb351" translate="yes" xml:space="preserve">
          <source>The following tables show what happens when there are unmerged entries:</source>
          <target state="translated">下表显示了有未合并条目时的情况。</target>
        </trans-unit>
        <trans-unit id="3cc98c85c7406728df501340aea8c7fdc3f04d78" translate="yes" xml:space="preserve">
          <source>The following tips and tricks have been collected from various users of fast-import, and are offered here as suggestions.</source>
          <target state="translated">以下技巧和窍门是由fast-import的不同用户收集的,在此提供给大家作为建议。</target>
        </trans-unit>
        <trans-unit id="177a564b8e3982405afb3b516ab4bbb5063d1ee7" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=blob:limit=&amp;lt;n&amp;gt;[kmg]&lt;/code&gt; omits blobs larger than n bytes or units. n may be zero. The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB. For example, &lt;code&gt;blob:limit=1k&lt;/code&gt; is the same as &lt;code&gt;blob:limit=1024&lt;/code&gt;.</source>
          <target state="translated">形式 &lt;code&gt;--filter=blob:limit=&amp;lt;n&amp;gt;[kmg]&lt;/code&gt; 省略了斑点大于n个字节或单元大。n可以为零。后缀k，m和g可用于命名KiB，MiB或GiB中的单位。例如， &lt;code&gt;blob:limit=1k&lt;/code&gt; 与 &lt;code&gt;blob:limit=1024&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="94349f8d4383b34d05a696da3b05af67f12eec03" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=blob:none&lt;/code&gt; omits all blobs.</source>
          <target state="translated">&lt;code&gt;--filter=blob:none&lt;/code&gt; 形式省略所有斑点。</target>
        </trans-unit>
        <trans-unit id="39c705af761382dd23f074438f9b0e646bf492af" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=combine:&amp;lt;filter1&amp;gt;+&amp;lt;filter2&amp;gt;+&amp;hellip;​&amp;lt;filterN&amp;gt;&lt;/code&gt; can also be used to combined several filters, but this is harder than just repeating the &lt;code&gt;--filter&lt;/code&gt; flag and is usually not necessary. Filters are joined by &lt;code&gt;+&lt;/code&gt; and individual filters are %-encoded (i.e. URL-encoded). Besides the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; characters, the following characters are reserved and also must be encoded: &lt;code&gt;~!@#$^&amp;amp;*()[]{}\;&quot;,&amp;lt;&amp;gt;?&lt;/code&gt;&lt;code&gt;'`&lt;/code&gt; as well as all characters with ASCII code &amp;lt;= &lt;code&gt;0x20&lt;/code&gt;, which includes space and newline.</source>
          <target state="translated">形式 &lt;code&gt;--filter=combine:&amp;lt;filter1&amp;gt;+&amp;lt;filter2&amp;gt;+&amp;hellip;​&amp;lt;filterN&amp;gt;&lt;/code&gt; 也可以被用于组合几个过滤器，但是这不是仅仅重复较硬 &lt;code&gt;--filter&lt;/code&gt; 标志，通常是没有必要的。过滤器以 &lt;code&gt;+&lt;/code&gt; 开头，各个过滤器均经过％编码（即URL编码）。除 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 字符外，还保留以下字符，并且还必须对其进行编码： &lt;code&gt;~!@#$^&amp;amp;*()[]{}\;&quot;,&amp;lt;&amp;gt;?&lt;/code&gt; &lt;code&gt;'`&lt;/code&gt; 以及所有ASCII码&amp;lt; = &lt;code&gt;0x20&lt;/code&gt; ，其中包括空格和换行符。</target>
        </trans-unit>
        <trans-unit id="d52505ec75878146eb9054dceb4728d58b485513" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=sparse:oid=&amp;lt;blob-ish&amp;gt;&lt;/code&gt; uses a sparse-checkout specification contained in the blob (or blob-expression) &lt;code&gt;&amp;lt;blob-ish&amp;gt;&lt;/code&gt; to omit blobs that would not be not required for a sparse checkout on the requested refs.</source>
          <target state="translated">形式 &lt;code&gt;--filter=sparse:oid=&amp;lt;blob-ish&amp;gt;&lt;/code&gt; 使用稀疏结账规范包含在团块（团块或表达） &lt;code&gt;&amp;lt;blob-ish&amp;gt;&lt;/code&gt; 到不会被不需要用于稀疏结帐上省略斑点所要求的裁判。</target>
        </trans-unit>
        <trans-unit id="ef46a11218e9457b2745a05e86c211527bd23b7c" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=tree:&amp;lt;depth&amp;gt;&lt;/code&gt; omits all blobs and trees whose depth from the root tree is &amp;gt;= &amp;lt;depth&amp;gt; (minimum depth if an object is located at multiple depths in the commits traversed). &amp;lt;depth&amp;gt;=0 will not include any trees or blobs unless included explicitly in the command-line (or standard input when --stdin is used). &amp;lt;depth&amp;gt;=1 will include only the tree and blobs which are referenced directly by a commit reachable from &amp;lt;commit&amp;gt; or an explicitly-given object. &amp;lt;depth&amp;gt;=2 is like &amp;lt;depth&amp;gt;=1 while also including trees and blobs one more level removed from an explicitly-given commit or tree.</source>
          <target state="translated">形式 &lt;code&gt;--filter=tree:&amp;lt;depth&amp;gt;&lt;/code&gt; 会忽略所有从根树开始的深度大于等于= &amp;lt;depth&amp;gt;（如果对象在遍历的提交中位于多个深度处的最小深度）的所有Blob和树。除非在命令行中明确包含（或使用--stdin时的标准输入），否则&amp;lt;depth&amp;gt; = 0将不包含任何树或blob。 &amp;lt;depth&amp;gt; = 1将仅包含由&amp;lt;commit&amp;gt;或显式给出的对象可到达的提交直接引用的树和blob。 &amp;lt;depth&amp;gt; = 2类似于&amp;lt;depth&amp;gt; = 1，同时还包括树和blob，它们从显式给定的提交或树中删除了一个级别。</target>
        </trans-unit>
        <trans-unit id="143c72f9a0abe1adb065cd1c00c0271a08c274c4" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-any&lt;/code&gt; will allow object traversal to continue if a missing object is encountered. Missing objects will silently be omitted from the results.</source>
          <target state="translated">如果遇到丢失的对象，格式 &lt;code&gt;--missing=allow-any&lt;/code&gt; 将允许对象遍历继续。缺少的对象将在结果中被忽略。</target>
        </trans-unit>
        <trans-unit id="bdde6c336c8ea83ffd865ad36b93358c59c8c01f" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-any&lt;/code&gt; will allow object traversal to continue if a missing object is encountered. No fetch of a missing object will occur. Missing objects will silently be omitted from the results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac33b80327bef1bf98d899063defe39f6edf744" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. No fetch of a missing object will occur. An unexpected missing object will raise an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="280716e3ccf86616960848b089fdadef81ba797d" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing object will raise an error.</source>
          <target state="translated">&lt;code&gt;--missing=allow-promisor&lt;/code&gt; 的形式类似于 &lt;code&gt;allow-any&lt;/code&gt; ，但仅允许针对期望的Promisor丢失对象继续进行对象遍历。意外丢失的对象将引发错误。</target>
        </trans-unit>
        <trans-unit id="563d9e750d01dbe920d57035d16bed3d91b9aea6" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing objects will raise an error.</source>
          <target state="translated">&lt;code&gt;--missing=allow-promisor&lt;/code&gt; 的形式类似于 &lt;code&gt;allow-any&lt;/code&gt; ，但仅允许针对期望的Promisor丢失对象继续进行对象遍历。意外丢失的对象将引发错误。</target>
        </trans-unit>
        <trans-unit id="85974afd39adff2510445a34b40c988ae3340623" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that pack-objects stop with an error if a missing object is encountered. If the repository is a partial clone, an attempt to fetch missing objects will be made before declaring them missing. This is the default action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c618ed732782b866de4c7dcf716daa2ac64119" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that pack-objects stop with an error if a missing object is encountered. This is the default action.</source>
          <target state="translated">如果遇到丢失的对象，则 &lt;code&gt;--missing=error&lt;/code&gt; 格式请求打包对象以错误停止。这是默认操作。</target>
        </trans-unit>
        <trans-unit id="2ed32158adb2f2f236ac5307d5ba7c30f0630796" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that rev-list stop with an error if a missing object is encountered. This is the default action.</source>
          <target state="translated">如果遇到缺少的对象，则 &lt;code&gt;--missing=error&lt;/code&gt; 格式请求rev-list停止并显示错误。这是默认操作。</target>
        </trans-unit>
        <trans-unit id="67e4b67693941fe412533d5210bde2a413de8fb1" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=print&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will also print a list of the missing objects. Object IDs are prefixed with a &amp;ldquo;?&amp;rdquo; character.</source>
          <target state="translated">&lt;code&gt;--missing=print&lt;/code&gt; 的形式类似于 &lt;code&gt;allow-any&lt;/code&gt; ，但也会打印缺失对象的列表。对象ID的前缀为&amp;ldquo;？&amp;rdquo; 字符。</target>
        </trans-unit>
        <trans-unit id="09994cb2384da5eddbe0ae0a9a1ceca76d8c8bcc" translate="yes" xml:space="preserve">
          <source>The format of a &amp;lt;refspec&amp;gt; parameter is an optional plus &lt;code&gt;+&lt;/code&gt;, followed by the source &amp;lt;src&amp;gt;, followed by a colon &lt;code&gt;:&lt;/code&gt;, followed by the destination ref &amp;lt;dst&amp;gt;. The colon can be omitted when &amp;lt;dst&amp;gt; is empty. &amp;lt;src&amp;gt; is typically a ref, but it can also be a fully spelled hex object name.</source>
          <target state="translated">&amp;lt;refspec&amp;gt;参数的格式是可选的plus &lt;code&gt;+&lt;/code&gt; ，后跟源&amp;lt;src&amp;gt;，后跟冒号 &lt;code&gt;:&lt;/code&gt; ，然后是目标ref &amp;lt;dst&amp;gt;。&amp;lt;dst&amp;gt;为空时，可以省略冒号。&amp;lt;src&amp;gt;通常是引用，但也可以是完全拼写的十六进制对象名称。</target>
        </trans-unit>
        <trans-unit id="05c09db4c870e826391cf6ebde5a8cc33d2791f6" translate="yes" xml:space="preserve">
          <source>The format of these files is username followed by the encrypted password, for example:</source>
          <target state="translated">这些文件的格式是用户名,后面是加密的密码,例如。</target>
        </trans-unit>
        <trans-unit id="65670970ee487305077ce344ca1fb6c36a889cee" translate="yes" xml:space="preserve">
          <source>The former lets your shell expand the fileglob, and you are asking the dot-C files in your working tree to be overwritten with the version in the index. The latter passes the &lt;code&gt;*.c&lt;/code&gt; to Git, and you are asking the paths in the index that match the pattern to be checked out to your working tree. After running &lt;code&gt;git add hello.c; rm hello.c&lt;/code&gt;, you will &lt;code&gt;not&lt;/code&gt; see &lt;code&gt;hello.c&lt;/code&gt; in your working tree with the former, but with the latter you will.</source>
          <target state="translated">前者让您的shell扩展fileglob，然后您要求工作树中的dot-C文件被索引中的版本覆盖。后者将 &lt;code&gt;*.c&lt;/code&gt; 传递给Git，您正在询问索引中与要检出的模式匹配到您的工作树的路径。运行 &lt;code&gt;git add hello.c; rm hello.c&lt;/code&gt; ，您 &lt;code&gt;not&lt;/code&gt; 在工作树中与前者一起看到 &lt;code&gt;hello.c&lt;/code&gt; ，但与后者会看到。</target>
        </trans-unit>
        <trans-unit id="b363974f459c2a2b237a919650aa9dc9f75161d2" translate="yes" xml:space="preserve">
          <source>The frontend must specify the number of bytes of data.</source>
          <target state="translated">前端必须指定数据的字节数。</target>
        </trans-unit>
        <trans-unit id="23957db0f038e6b4263285c2923ad6ce72a805ca" translate="yes" xml:space="preserve">
          <source>The full SHA-1 object name (40-byte hexadecimal string), or a leading substring that is unique within the repository. E.g. dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the same commit object if there is no other object in your repository whose object name starts with dae86e.</source>
          <target state="translated">完整的 SHA-1 对象名称(40 字节的十六进制字符串),或者在版本库中唯一的前导子串,例如 dae86e1950b1277e545cee180551750029cfe735 和 dae86e 都命名为同一个提交对象,如果版本库中没有其他对象的话。例如 dae86e1950b1277e545cee180551750029cfe735 和 dae86e 都命名为同一个提交对象,如果你的版本库中没有其他对象的名字以 dae86e 开头。</target>
        </trans-unit>
        <trans-unit id="ce332106cb9361add9aaf31aea030a425aeed7be" translate="yes" xml:space="preserve">
          <source>The full name is occasionally useful if, for example, there ever exists a tag and a branch with the same name.</source>
          <target state="translated">例如,如果存在一个标签和一个同名的分支,全名偶尔会有用。</target>
        </trans-unit>
        <trans-unit id="d24187cae372eb76b2a26570ccfd9def8c8abdf6" translate="yes" xml:space="preserve">
          <source>The full pattern set allows for arbitrary pattern matches and complicated inclusion/exclusion rules. These can result in O(N*M) pattern matches when updating the index, where N is the number of patterns and M is the number of paths in the index. To combat this performance issue, a more restricted pattern set is allowed when &lt;code&gt;core.spareCheckoutCone&lt;/code&gt; is enabled.</source>
          <target state="translated">完整模式集允许任意模式匹配和复杂的包含/排除规则。这些可能导致更新索引时出现O（N * M）个模式匹配，其中N是模式数量，M是索引中路径的数量。为了解决此性能问题，启用 &lt;code&gt;core.spareCheckoutCone&lt;/code&gt; 时允许使用更多受限制的模式集。</target>
        </trans-unit>
        <trans-unit id="271f7ad4b6b86f815e34a99cf6372d6f7edf455d" translate="yes" xml:space="preserve">
          <source>The full pattern set allows for arbitrary pattern matches and complicated inclusion/exclusion rules. These can result in O(N*M) pattern matches when updating the index, where N is the number of patterns and M is the number of paths in the index. To combat this performance issue, a more restricted pattern set is allowed when &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3e98918a57498bee35c9ef416c5932bb448c1f" translate="yes" xml:space="preserve">
          <source>The full syntax for a p4 view is documented in &lt;code&gt;p4 help views&lt;/code&gt;. &lt;code&gt;git p4&lt;/code&gt; knows only a subset of the view syntax. It understands multi-line mappings, overlays with &lt;code&gt;+&lt;/code&gt;, exclusions with &lt;code&gt;-&lt;/code&gt; and double-quotes around whitespace. Of the possible wildcards, &lt;code&gt;git p4&lt;/code&gt; only handles &lt;code&gt;&amp;hellip;​&lt;/code&gt;, and only when it is at the end of the path. &lt;code&gt;git p4&lt;/code&gt; will complain if it encounters an unhandled wildcard.</source>
          <target state="translated">&lt;code&gt;p4 help views&lt;/code&gt; 视图中记录了p4视图的完整语法。 &lt;code&gt;git p4&lt;/code&gt; 只知道视图语法的一个子集。它了解多行映射，带 &lt;code&gt;+&lt;/code&gt; 的叠加层，带 &lt;code&gt;-&lt;/code&gt; 的排除对象以及空格周围的双引号。可能的通配符， &lt;code&gt;git p4&lt;/code&gt; 只处理 &lt;code&gt;&amp;hellip;​&lt;/code&gt; ，只有当它在路的尽头。如果 &lt;code&gt;git p4&lt;/code&gt; 遇到未处理的通配符，它​​将抱怨。</target>
        </trans-unit>
        <trans-unit id="18d1519c9cf5420b92be3f082cd6f0aa89c3d260" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;skip_commit&lt;/code&gt; is defined as follows:</source>
          <target state="translated">函数 &lt;code&gt;skip_commit&lt;/code&gt; 定义如下：</target>
        </trans-unit>
        <trans-unit id="af7dd50b5e9b3d3ec2ae519f399794527002dc23" translate="yes" xml:space="preserve">
          <source>The functions defined by the Trace2 API are declared and documented in &lt;code&gt;trace2.h&lt;/code&gt;. It defines the API functions and wrapper macros for Trace2.</source>
          <target state="translated">由TRACE2 API定义的函数声明和中记录 &lt;code&gt;trace2.h&lt;/code&gt; 。它定义了Trace2的API函数和包装器宏。</target>
        </trans-unit>
        <trans-unit id="e5521fd46bed9d589b56b651d5f3ef04e9a3b2a8" translate="yes" xml:space="preserve">
          <source>The future of bisecting</source>
          <target state="translated">二分法的未来</target>
        </trans-unit>
        <trans-unit id="2aa4427c10c7d5c13ef7bbb9898f5fea28090dd1" translate="yes" xml:space="preserve">
          <source>The general idea is this: we generate a cost matrix between the commits in both commit ranges, then solve the least-cost assignment.</source>
          <target state="translated">一般的想法是:我们在两个提交范围内的提交之间生成一个成本矩阵,然后解决最小成本分配。</target>
        </trans-unit>
        <trans-unit id="0339eef2339eb8367ea8564b9ff6721cd9dea407" translate="yes" xml:space="preserve">
          <source>The git commit is created relative to the current origin revision (HEAD by default). A parent commit is created based on the origin, and then the unshelve commit is created based on that.</source>
          <target state="translated">git 提交是相对于当前的原点修订版(默认为 HEAD)而创建的。父提交是基于原点创建的,然后在此基础上创建unshelve提交。</target>
        </trans-unit>
        <trans-unit id="a5bbcd1beb35762403be84a14e62e0a4eb5d5226" translate="yes" xml:space="preserve">
          <source>The git object database</source>
          <target state="translated">git对象数据库</target>
        </trans-unit>
        <trans-unit id="80d403b9b878573aec88e9c705123dc6feedf769" translate="yes" xml:space="preserve">
          <source>The gitweb CGI script for viewing Git repositories over the web uses a perl script fragment as its configuration file. You can set variables using &quot;&lt;code&gt;our $variable = value&lt;/code&gt;&quot;; text from a &quot;#&quot; character until the end of a line is ignored. See &lt;strong&gt;perlsyn&lt;/strong&gt;(1) for details.</source>
          <target state="translated">用于在Web上查看Git存储库的gitweb CGI脚本使用perl脚本片段作为其配置文件。您可以使用&amp;ldquo; &lt;code&gt;our $variable = value&lt;/code&gt; &amp;rdquo; 来设置变量；从&amp;ldquo;＃&amp;rdquo;字符到行尾的文本将被忽略。有关详细信息，请参见&lt;strong&gt;perlsyn&lt;/strong&gt;（1）。</target>
        </trans-unit>
        <trans-unit id="a1a6c42c76028a67bf39dd75b77a2307812be731" translate="yes" xml:space="preserve">
          <source>The gitweb cgi script provides users an easy way to browse your project&amp;rsquo;s revisions, file contents and logs without having to install Git. Features like RSS/Atom feeds and blame/annotation details may optionally be enabled.</source>
          <target state="translated">gitweb cgi脚本为用户提供了一种无需安装Git即可轻松浏览项目修订版，文件内容和日志的简便方法。可以选择启用RSS / Atom提要和责备/注释详细信息之类的功能。</target>
        </trans-unit>
        <trans-unit id="eefcb42be74db518327d9c82beb9a165d884846e" translate="yes" xml:space="preserve">
          <source>The gitweb features that are configurable via &lt;code&gt;%feature&lt;/code&gt; hash are listed below. This should be a complete list, but ultimately the authoritative and complete list is in gitweb.cgi source code, with features described in the comments.</source>
          <target state="translated">下面列出了可通过 &lt;code&gt;%feature&lt;/code&gt; 哈希配置的gitweb功能。这应该是一个完整列表，但最终的权威和完整列表在gitweb.cgi源代码中，并在注释中描述了功能。</target>
        </trans-unit>
        <trans-unit id="bee84a897df9efb668b9aee969a1e660ed8af0a4" translate="yes" xml:space="preserve">
          <source>The gitweb.extraBranchRefs is actually a multi-valued configuration variable, so following example is also correct and the result is the same as of the snippet above:</source>
          <target state="translated">gitweb.extraBranchRefs实际上是一个多值的配置变量,所以下面的例子也是正确的,结果和上面的片段一样。</target>
        </trans-unit>
        <trans-unit id="ab9a5e4603e46ba18e0a4c5efe881c7ac8def35b" translate="yes" xml:space="preserve">
          <source>The given URL is recorded into &lt;code&gt;.gitmodules&lt;/code&gt; for use by subsequent users cloning the superproject. If the URL is given relative to the superproject&amp;rsquo;s repository, the presumption is the superproject and submodule repositories will be kept together in the same relative location, and only the superproject&amp;rsquo;s URL needs to be provided. git-submodule will correctly locate the submodule using the relative URL in &lt;code&gt;.gitmodules&lt;/code&gt;.</source>
          <target state="translated">给定的URL被记录到 &lt;code&gt;.gitmodules&lt;/code&gt; 中，供后续用户克隆超级项目使用。如果URL是相对于超级项目的存储库给出的，则假定超级项目和子模块存储库将被放置在相同的相对位置，并且仅需提供超级项目的URL。git-submodule将使用 &lt;code&gt;.gitmodules&lt;/code&gt; 中的相对URL正确定位子模块。</target>
        </trans-unit>
        <trans-unit id="1190edfebfe2406cf333713a0e461379865b033f" translate="yes" xml:space="preserve">
          <source>The goal of this tutorial is to introduce two fundamental pieces of Git&amp;rsquo;s architecture&amp;mdash;​the object database and the index file&amp;mdash;​and to provide the reader with everything necessary to understand the rest of the Git documentation.</source>
          <target state="translated">本教程的目的是介绍Git体系结构的两个基本部分-对象数据库和索引文件-并为读者提供理解其余Git文档所需的一切。</target>
        </trans-unit>
        <trans-unit id="880a291c14c1099392ebdd9b73ec08c93b7220d1" translate="yes" xml:space="preserve">
          <source>The hard case</source>
          <target state="translated">硬壳</target>
        </trans-unit>
        <trans-unit id="71b4cfb50bd8944708a6926991c13ef0bfbac07d" translate="yes" xml:space="preserve">
          <source>The hashes are 40 hex characters long. When Git upgrades to a new hash algorithm, this might need to be updated. (It should match whatever index-pack outputs after &quot;pack\t&quot; or &quot;keep\t&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2a187748caf680c0e66173f60176ec60ea02ab" translate="yes" xml:space="preserve">
          <source>The header consists of 256 4-byte network byte order integers. N-th entry of this table records the number of objects in the corresponding pack, the first byte of whose object name is less than or equal to N. This is called the &lt;code&gt;first-level fan-out&lt;/code&gt; table.</source>
          <target state="translated">标头由256个4字节网络字节顺序整数组成。该表的第N个条目记录相应数据包中的对象数，其对象名称的第一个字节小于或等于N。这称为 &lt;code&gt;first-level fan-out&lt;/code&gt; 表。</target>
        </trans-unit>
        <trans-unit id="0e2dd021a6a8dc94bfb40a62a04904f17b8f1dab" translate="yes" xml:space="preserve">
          <source>The header is followed by number of object entries, each of which looks like this:</source>
          <target state="translated">头部后面是对象项的数量,每个对象项的样子是这样的。</target>
        </trans-unit>
        <trans-unit id="10743ced5c1563e940127b440ba806235a399ac8" translate="yes" xml:space="preserve">
          <source>The header is followed by sorted 24-byte entries, one entry per object in the pack. Each entry is:</source>
          <target state="translated">头部后面是经过排序的24字节条目,包中每个对象一个条目。每个条目是:</target>
        </trans-unit>
        <trans-unit id="03910dca7f1c0af7f3d0e6986f455aceaec86f05" translate="yes" xml:space="preserve">
          <source>The header of the email is configurable via command-line options. If not specified on the command line, the user will be prompted with a ReadLine enabled interface to provide the necessary information.</source>
          <target state="translated">电子邮件的标题可以通过命令行选项进行配置。如果没有在命令行中指定,用户将被提示使用ReadLine接口来提供必要的信息。</target>
        </trans-unit>
        <trans-unit id="53d28fdf80ee055eff1005765033449c285d4f79" translate="yes" xml:space="preserve">
          <source>The hook always runs after the automatic note copying (see &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) has happened, and thus has access to these notes.</source>
          <target state="translated">挂钩总是在自动注释复制后运行（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]中的&lt;/a&gt; &amp;ldquo; notes.rewrite。&amp;lt;command&amp;gt;&amp;rdquo; ），因此可以访问这些注释。</target>
        </trans-unit>
        <trans-unit id="55997df4465d2b793292e1300e70ff2f9e1a3588" translate="yes" xml:space="preserve">
          <source>The hook executes once for each ref to be updated, and takes three parameters:</source>
          <target state="translated">钩子对每一个要更新的 ref 执行一次,需要三个参数。</target>
        </trans-unit>
        <trans-unit id="7918f32150a1e75fa34aeef2474d601c36b3a718" translate="yes" xml:space="preserve">
          <source>The hook is allowed to edit the changelist file and can be used to normalize the text into some project standard format. It can also be used to refuse the Submit after inspect the message file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6422fdbff7a8b80abf6e11b9c756369981239875" translate="yes" xml:space="preserve">
          <source>The hook is allowed to edit the message file in place, and can be used to normalize the message into some project standard format. It can also be used to refuse the commit after inspecting the message file.</source>
          <target state="translated">该钩子允许在原地编辑消息文件,并可用于将消息规范为某种项目标准格式。也可以用来在检查完消息文件后拒绝提交。</target>
        </trans-unit>
        <trans-unit id="7dd8785c8f6fdd3a8a45999afa9f773631b556f1" translate="yes" xml:space="preserve">
          <source>The hook receives a list of the rewritten commits on stdin, in the format</source>
          <target state="translated">钩子在 stdin 上接收重写的提交列表,格式为</target>
        </trans-unit>
        <trans-unit id="ffb0d43685532aa46e893849969758ab23367451" translate="yes" xml:space="preserve">
          <source>The hook receives the commit with which the tip of the current branch is going to be updated. It can exit with a non-zero status to refuse the push (when it does so, it must not modify the index or the working tree). Or it can make any necessary changes to the working tree and to the index to bring them to the desired state when the tip of the current branch is updated to the new commit, and exit with a zero status.</source>
          <target state="translated">钩子接收提交,当前分支的顶端将被更新。它可以以非零状态退出,拒绝推送(当它这样做时,它不能修改索引或工作树)。或者它可以对工作树和索引进行必要的修改,以便在当前分支的顶端更新到新的提交时,使它们达到所需的状态,然后以零状态退出。</target>
        </trans-unit>
        <trans-unit id="6e0236cadc345b5114c4c6984e7438ed153e1f2f" translate="yes" xml:space="preserve">
          <source>The hook should exit with non-zero status if it wants to disallow updating the named ref. Otherwise it should exit with zero.</source>
          <target state="translated">如果钩子要禁止更新命名的 ref,它应该以非零状态退出。否则应该以零退出。</target>
        </trans-unit>
        <trans-unit id="9739d79c49b82b53238e48aeefee9c342d93a499" translate="yes" xml:space="preserve">
          <source>The hook should output to stdout the list of all files in the working directory that may have changed since the requested time. The logic should be inclusive so that it does not miss any potential changes. The paths should be relative to the root of the working directory and be separated by a single NUL.</source>
          <target state="translated">钩子应该将工作目录中自请求时间以来可能发生变化的所有文件列表输出到stdp。这个逻辑应该是包容的,这样就不会错过任何潜在的变化。路径应该是相对于工作目录的根目录的,并且用一个NUL分隔。</target>
        </trans-unit>
        <trans-unit id="726cd696e8b088103d80193483306d60860caef4" translate="yes" xml:space="preserve">
          <source>The hook takes exactly one argument, which is the current state the given reference transaction is in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022998a9843b7be307eb2d587f13704cf2ce86bd" translate="yes" xml:space="preserve">
          <source>The horizontal line of history A---Q is taken to be the first parent of each merge. The commits are:</source>
          <target state="translated">历史上的横线A---Q取为每次合并的第一个父级。提交的内容是:</target>
        </trans-unit>
        <trans-unit id="41f47ff55448de90533c1d6461f6a54aa470a338" translate="yes" xml:space="preserve">
          <source>The human-readable name used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;author.name&lt;/code&gt; configuration settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a50b3e42cc3505776fea766e525fbf7e68884e" translate="yes" xml:space="preserve">
          <source>The human-readable name used in the committer identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;committer.name&lt;/code&gt; configuration settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf0ebdfb4273a6fce7952dfa28834b6e411cd7f" translate="yes" xml:space="preserve">
          <source>The hypothetical proxy command entries actually have a postfix to discern what URL they apply to. Here is how to change the entry for kernel.org to &quot;ssh&quot;.</source>
          <target state="translated">假设的代理命令条目实际上有一个后缀来辨别它们适用于什么URL。下面是如何将kernel.org的条目改为 &quot;ssh&quot;。</target>
        </trans-unit>
        <trans-unit id="4399284bfb632a08cce3f3533db563320f49af23" translate="yes" xml:space="preserve">
          <source>The id of a tree object to diff against.</source>
          <target state="translated">要对比的树对象的id。</target>
        </trans-unit>
        <trans-unit id="0505b9e9f78e78efa1c8b76bc422638cba05b1b7" translate="yes" xml:space="preserve">
          <source>The id of a tree object.</source>
          <target state="translated">树对象的id。</target>
        </trans-unit>
        <trans-unit id="2e60e84271eec03fd28b067b32c84bb5fbe76999" translate="yes" xml:space="preserve">
          <source>The id of the tree object(s) to be read/merged.</source>
          <target state="translated">要读取/合并的树对象的id。</target>
        </trans-unit>
        <trans-unit id="fb9074ec22bab96e3e97d4855db9bfaed224187c" translate="yes" xml:space="preserve">
          <source>The idea is that every 3 test for example, &quot;git bisect&quot; could ask the user to test a commit that has already been found to be &quot;good&quot; or &quot;bad&quot; (because one of its descendants or one of its ancestors has been found to be &quot;good&quot; or &quot;bad&quot; respectively). If it happens that a commit has been previously incorrectly classified then the bisection can be aborted early, hopefully before too many mistakes have been made. Then the user will have to look at what happened and then restart the bisection using a fixed bisect log.</source>
          <target state="translated">我们的想法是,每隔 3 次测试,例如,&quot;git bisect &quot;可以要求用户测试一个已经被发现是 &quot;好 &quot;或 &quot;坏 &quot;的提交(因为它的一个后代或它的一个祖先分别被发现是 &quot;好 &quot;或 &quot;坏&quot;)。如果碰巧一个提交之前已经被错误地分类,那么可以提前中止二分法,希望是在犯了太多错误之前。然后,用户必须查看发生了什么,然后使用固定的二分法日志重新开始二分法。</target>
        </trans-unit>
        <trans-unit id="b3a07b8c786a1b03697e9ded467b22cd2ece1ab4" translate="yes" xml:space="preserve">
          <source>The idea is to manually tell &lt;code&gt;git rebase&lt;/code&gt; &quot;where the old &lt;code&gt;subsystem&lt;/code&gt; ended and your &lt;code&gt;topic&lt;/code&gt; began&quot;, that is, what the old merge base between them was. You will have to find a way to name the last commit of the old &lt;code&gt;subsystem&lt;/code&gt;, for example:</source>
          <target state="translated">这个想法是手动告诉 &lt;code&gt;git rebase&lt;/code&gt; &amp;ldquo;旧 &lt;code&gt;subsystem&lt;/code&gt; 在哪里结束并且您的 &lt;code&gt;topic&lt;/code&gt; 开始了&amp;rdquo;，即它们之间的旧合并基础是什么。您将必须找到一种方法来命名旧 &lt;code&gt;subsystem&lt;/code&gt; 的最后一次提交，例如：</target>
        </trans-unit>
        <trans-unit id="1ff2a3a30d68d12ef6b058f357f43e3bd9cd4f0f" translate="yes" xml:space="preserve">
          <source>The idx files to verify.</source>
          <target state="translated">要核实的idx文件。</target>
        </trans-unit>
        <trans-unit id="fd29bd486dc43b124e6d98a808e18b86c2905ae4" translate="yes" xml:space="preserve">
          <source>The import checks out from CVS every revision of every file. Reportedly cvsimport can average some twenty revisions per second, so for a medium-sized project this should not take more than a couple of minutes. Larger projects or remote repositories may take longer.</source>
          <target state="translated">导入会从 CVS 中检查出每个文件的每一次修订。据报道,cvsimport 平均每秒可以修改 20 个版本,所以对于一个中等规模的项目来说,这应该不会超过几分钟。更大的项目或远程仓库可能需要更长的时间。</target>
        </trans-unit>
        <trans-unit id="69f04e00f7076b8b130e67c7134e53f7f1076bf2" translate="yes" xml:space="preserve">
          <source>The import is incremental, so if you call it again next month it will fetch any CVS updates that have been made in the meantime. For this to work, you must not modify the imported branches; instead, create new branches for your own changes, and merge in the imported branches as necessary.</source>
          <target state="translated">导入是增量式的,所以如果您下个月再调用它,它将获取在此期间所做的任何 CVS 更新。为了使这个方法有效,你不能修改导入的分支;相反,你必须为你自己的修改创建新的分支,并在必要时合并导入的分支。</target>
        </trans-unit>
        <trans-unit id="807035ab1f5be4f0cb3563dc9b49740571ca0fa4" translate="yes" xml:space="preserve">
          <source>The index</source>
          <target state="translated">该指数</target>
        </trans-unit>
        <trans-unit id="4284ed429265f3c1afc30e4fc09197d88352698c" translate="yes" xml:space="preserve">
          <source>The index and the working tree are adjusted as if you had previously run &lt;code&gt;git checkout &amp;lt;start_point&amp;gt;&lt;/code&gt;. This allows you to start a new history that records a set of paths similar to &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; by easily running &lt;code&gt;git commit -a&lt;/code&gt; to make the root commit.</source>
          <target state="translated">就像您以前运行 &lt;code&gt;git checkout &amp;lt;start_point&amp;gt;&lt;/code&gt; 一样，将调整索引和工作树。这样，您可以轻松运行 &lt;code&gt;git commit -a&lt;/code&gt; 进行根提交，从而开始一个新的历史记录，该记录记录了一组类似于 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 的路径。</target>
        </trans-unit>
        <trans-unit id="0818281aa21612fb5fa362015c64c5645d861084" translate="yes" xml:space="preserve">
          <source>The index contains all the information necessary to generate a single (uniquely determined) tree object.</source>
          <target state="translated">该索引包含了生成单个(唯一确定的)树对象的所有必要信息。</target>
        </trans-unit>
        <trans-unit id="3d9fb9e020c0d003a42d72f87f16ba2ba38226e6" translate="yes" xml:space="preserve">
          <source>The index enables fast comparisons between the tree object it defines and the working tree.</source>
          <target state="translated">该索引可以实现它定义的树对象和工作树之间的快速比较。</target>
        </trans-unit>
        <trans-unit id="eb65460c6179ccddcd4479166e9da44d8f5c40d8" translate="yes" xml:space="preserve">
          <source>The index file</source>
          <target state="translated">索引文件</target>
        </trans-unit>
        <trans-unit id="181ab401ce7a15640077d5cb413c24fc6eb6a97e" translate="yes" xml:space="preserve">
          <source>The index file is a cache of the state of a directory tree, used to create commits, check out working directories, and hold the various trees involved in a merge.</source>
          <target state="translated">索引文件是一个目录树状态的缓存,用于创建提交,检查工作目录,并保存合并中涉及的各种树。</target>
        </trans-unit>
        <trans-unit id="a98935eae61bfe66b9928e790965f624bf2f8b5b" translate="yes" xml:space="preserve">
          <source>The index file is initialized with a list of all paths and, for each path, a blob object and a set of attributes. The blob object represents the contents of the file as of the head of the current branch. The attributes (last modified time, size, etc.) are taken from the corresponding file in the working tree. Subsequent changes to the working tree can be found by comparing these attributes. The index may be updated with new content, and new commits may be created from the content stored in the index.</source>
          <target state="translated">索引文件用所有路径的列表和每个路径的blob对象和一组属性来初始化。blob对象表示当前分支头部的文件内容。属性(最后修改的时间、大小等)取自工作树中的相应文件。通过比较这些属性可以发现工作树的后续变化。索引可以用新的内容更新,也可以从索引中存储的内容创建新的提交。</target>
        </trans-unit>
        <trans-unit id="803387e9a63472a3287bdc2446032cf6e023e1d9" translate="yes" xml:space="preserve">
          <source>The index is a binary file (generally kept in &lt;code&gt;.git/index&lt;/code&gt;) containing a sorted list of path names, each with permissions and the SHA-1 of a blob object; &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; can show you the contents of the index:</source>
          <target state="translated">索引是一个二进制文件（通常保存在 &lt;code&gt;.git/index&lt;/code&gt; 中），其中包含路径名的排序列表，每个路径名均具有权限和blob对象的SHA-1；&lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]&lt;/a&gt;可以向您显示索引的内容：</target>
        </trans-unit>
        <trans-unit id="a9316182499a37d7c3626ac01aa8aab4c013b473" translate="yes" xml:space="preserve">
          <source>The index is also capable of storing multiple entries (called &quot;stages&quot;) for a given pathname. These stages are used to hold the various unmerged version of a file when a merge is in progress.</source>
          <target state="translated">索引还能够为一个给定的路径名存储多个条目(称为 &quot;阶段&quot;)。这些阶段用于在合并过程中保存文件的各种未合并版本。</target>
        </trans-unit>
        <trans-unit id="188f5a2d7cb942916f4771a1884b995e88b4142c" translate="yes" xml:space="preserve">
          <source>The index is thus a sort of temporary staging area, which is filled with a tree which you are in the process of working on.</source>
          <target state="translated">因此,索引是一种临时的中转站,里面装的是你正在做的一棵树。</target>
        </trans-unit>
        <trans-unit id="272f4c7f98ef3d0d8ac3fea3ee0b1455507c7b6c" translate="yes" xml:space="preserve">
          <source>The index is updated after successful completion, but the change must still be committed.</source>
          <target state="translated">成功完成后,索引会被更新,但更改仍然必须被提交。</target>
        </trans-unit>
        <trans-unit id="aaf3f3d73cad6f7ed8d83d0912688100fa696756" translate="yes" xml:space="preserve">
          <source>The index line includes the blob object names before and after the change. The &amp;lt;mode&amp;gt; is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.</source>
          <target state="translated">索引行包含更改前后的Blob对象名称。如果文件模式未更改，则包含&amp;lt;mode&amp;gt;；否则，将显示&amp;lt;mode&amp;gt;。否则，单独的行指示旧模式和新模式。</target>
        </trans-unit>
        <trans-unit id="0c2192b5aebec33a414387c35e4e32f7ffc2561e" translate="yes" xml:space="preserve">
          <source>The index may contain unmerged entries because of a previous failed merge. By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out. Using &lt;code&gt;-f&lt;/code&gt; will ignore these unmerged entries. The contents from a specific side of the merge can be checked out of the index by using &lt;code&gt;--ours&lt;/code&gt; or &lt;code&gt;--theirs&lt;/code&gt;. With &lt;code&gt;-m&lt;/code&gt;, changes made to the working tree file can be discarded to re-create the original conflicted merge result.</source>
          <target state="translated">由于先前合并失败，索引可能包含未合并的条目。默认情况下，如果您尝试从索引中检出此类条目，则检出操作将失败并且将不检出任何内容。使用 &lt;code&gt;-f&lt;/code&gt; 将忽略这些未合并的条目。可以使用 &lt;code&gt;--ours&lt;/code&gt; 或 &lt;code&gt;--theirs&lt;/code&gt; 从合并的特定方面将内容从索引中检出。使用 &lt;code&gt;-m&lt;/code&gt; ，可以放弃对工作树文件的更改以重新创建原始的冲突合并结果。</target>
        </trans-unit>
        <trans-unit id="4d0d51f29d49355316c3cef38c96a8eb5dfc2a8a" translate="yes" xml:space="preserve">
          <source>The index must be in a fully merged state.</source>
          <target state="translated">索引必须处于完全合并的状态。</target>
        </trans-unit>
        <trans-unit id="76af7fc7918327fcfae98949c1f8a57aa6273691" translate="yes" xml:space="preserve">
          <source>The information &lt;code&gt;git rerere&lt;/code&gt; records is also used when running &lt;code&gt;git rebase&lt;/code&gt;. After blowing away the test merge and continuing development on the topic branch:</source>
          <target state="translated">运行 &lt;code&gt;git rebase&lt;/code&gt; 时也会使用信息 &lt;code&gt;git rerere&lt;/code&gt; 记录。在完成测试合并并继续在主题分支上进行开发之后：</target>
        </trans-unit>
        <trans-unit id="15901a24c7f8cf8a87522005a6e5af387df87a55" translate="yes" xml:space="preserve">
          <source>The information regarding a particular file, stored in the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;. An index entry can be unmerged, if a &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; was started, but not yet finished (i.e. if the index contains multiple versions of that file).</source>
          <target state="translated">有关特定文件的信息，存储在&lt;a href=&quot;#def_index&quot;&gt;索引中&lt;/a&gt;。如果&lt;a href=&quot;#def_merge&quot;&gt;合并&lt;/a&gt;开始但尚未完成（例如，如果索引包含该文件的多个版本），则可以取消合并索引条目。</target>
        </trans-unit>
        <trans-unit id="e1b41d54924f3d005ef481db0b83a44bcb5b9a26" translate="yes" xml:space="preserve">
          <source>The initial &lt;code&gt;git svn clone&lt;/code&gt; can be quite time-consuming (especially for large Subversion repositories). If multiple people (or one person with multiple machines) want to use &lt;code&gt;git svn&lt;/code&gt; to interact with the same Subversion repository, you can do the initial &lt;code&gt;git svn clone&lt;/code&gt; to a repository on a server and have each person clone that repository with &lt;code&gt;git clone&lt;/code&gt;:</source>
          <target state="translated">最初的 &lt;code&gt;git svn clone&lt;/code&gt; 可能非常耗时（特别是对于大型Subversion存储库）。如果多个人（或一个拥有多台计算机的人）想要使用 &lt;code&gt;git svn&lt;/code&gt; 与同一个Subversion存储库进行交互，则可以将 &lt;code&gt;git svn clone&lt;/code&gt; 初始克隆到服务器上的存储库，并让每个人使用 &lt;code&gt;git clone&lt;/code&gt; 克隆该存储库：</target>
        </trans-unit>
        <trans-unit id="086eba2d4da1f4350d7506d860bddbb6a3656718" translate="yes" xml:space="preserve">
          <source>The initial clone may be time-consuming for a large project, but you will only need to clone once.</source>
          <target state="translated">对于一个大型项目来说,初始克隆可能会很耗时,但你只需要克隆一次。</target>
        </trans-unit>
        <trans-unit id="de40e4660568a286f9924fcf84aa107b9295fcd9" translate="yes" xml:space="preserve">
          <source>The initial revision lays the foundation for almost everything Git has today, but is small enough to read in one sitting.</source>
          <target state="translated">初次修订奠定了今天Git几乎所有的基础,但体积小,可以一次读完。</target>
        </trans-unit>
        <trans-unit id="c62040180edff3420ed3a70f2f1e520bccaa26ac" translate="yes" xml:space="preserve">
          <source>The insane thing. You really want to call the new version &quot;X&quot; too, &lt;code&gt;even though&lt;/code&gt; others have already seen the old one. So just use &lt;code&gt;git tag -f&lt;/code&gt; again, as if you hadn&amp;rsquo;t already published the old one.</source>
          <target state="translated">疯了 您真的也想将新版本称为&amp;ldquo; X&amp;rdquo;， &lt;code&gt;even though&lt;/code&gt; 其他人已经看到了旧版本。因此，只需再次使用 &lt;code&gt;git tag -f&lt;/code&gt; ，就好像您尚未发布旧版本一样。</target>
        </trans-unit>
        <trans-unit id="861707a12241605e66eb9230fb32f3c54a08448e" translate="yes" xml:space="preserve">
          <source>The intent of this option is to pick and choose lines of the patch to apply, or even to modify the contents of lines to be staged. This can be quicker and more flexible than using the interactive hunk selector. However, it is easy to confuse oneself and create a patch that does not apply to the index. See EDITING PATCHES below.</source>
          <target state="translated">这个选项的意图是挑选要应用补丁的行,甚至修改要分期的行的内容。这可以比使用交互式的块状选择器更快、更灵活。但是,很容易混淆自己的视线,创建一个不适用索引的补丁。参见下面的编辑补丁。</target>
        </trans-unit>
        <trans-unit id="44c76b656c6ccb35aba2b96c920b5e782121a3bc" translate="yes" xml:space="preserve">
          <source>The interactive backend drops commits by default that started empty and halts if it hits a commit that ended up empty. The &lt;code&gt;--keep-empty&lt;/code&gt; option exists for the interactive backend to allow it to keep commits that started empty.</source>
          <target state="translated">交互式后端默认丢弃开始为空的提交，如果命中最终为空的提交则停止。该 &lt;code&gt;--keep-empty&lt;/code&gt; 选项存在互动后端以使其保持这一开始空提交。</target>
        </trans-unit>
        <trans-unit id="c4d1b3aab1a5f39909af0bdb9766437575ff6138" translate="yes" xml:space="preserve">
          <source>The interactive mode is meant for this type of workflow:</source>
          <target state="translated">交互式模式就是针对这类工作流程的。</target>
        </trans-unit>
        <trans-unit id="bed5d62a356c4ef72d5d10899b110555c8810a69" translate="yes" xml:space="preserve">
          <source>The interactive rebase command was originally designed to handle individual patch series. As such, it makes sense to exclude merge commits from the todo list, as the developer may have merged the then-current &lt;code&gt;master&lt;/code&gt; while working on the branch, only to rebase all the commits onto &lt;code&gt;master&lt;/code&gt; eventually (skipping the merge commits).</source>
          <target state="translated">交互式rebase命令最初旨在处理各个修补程序系列。因此，将合并提交从待办事项列表中排除是有意义的，因为开发人员在分支上工作时可能已经合并了当时的 &lt;code&gt;master&lt;/code&gt; ，最终只是将所有提交重新基于 &lt;code&gt;master&lt;/code&gt; （跳过合并提交）。</target>
        </trans-unit>
        <trans-unit id="54aff08446e09f30da133e329eb3f3646033c66c" translate="yes" xml:space="preserve">
          <source>The interactive rebase will stop when a command fails (i.e. exits with non-0 status) to give you an opportunity to fix the problem. You can continue with &lt;code&gt;git rebase --continue&lt;/code&gt;.</source>
          <target state="translated">当命令失败（即以非0状态退出）时，交互式知识库将停止，从而为您提供解决问题的机会。您可以继续 &lt;code&gt;git rebase --continue&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a7f537099e4a0d8d8faba9c5e743d565b88b9dd" translate="yes" xml:space="preserve">
          <source>The interface (input, output, set of options and the semantics) to these low-level commands are meant to be a lot more stable than Porcelain level commands, because these commands are primarily for scripted use. The interface to Porcelain commands on the other hand are subject to change in order to improve the end user experience.</source>
          <target state="translated">这些低级命令的接口(输入、输出、选项集和语义)要比Porcelain级别的命令稳定得多,因为这些命令主要是供脚本使用的。另一方面,为了改善最终用户的体验,Porcelain命令的接口是可以改变的。</target>
        </trans-unit>
        <trans-unit id="bf907bc1bbd0905aa866d8781057341315704641" translate="yes" xml:space="preserve">
          <source>The internal block size to use when converting a revision specifier such as &lt;code&gt;@all&lt;/code&gt; into a list of specific change numbers. Instead of using a single call to &lt;code&gt;p4 changes&lt;/code&gt; to find the full list of changes for the conversion, there are a sequence of calls to &lt;code&gt;p4 changes -m&lt;/code&gt;, each of which requests one block of changes of the given size. The default block size is 500, which should usually be suitable.</source>
          <target state="translated">将修订说明符（例如 &lt;code&gt;@all&lt;/code&gt; )转换为特定更改编号列表时要使用的内部块大小。除了使用单个对 &lt;code&gt;p4 changes&lt;/code&gt; 调用来查找转换的完整列表之外，还有一系列对 &lt;code&gt;p4 changes -m&lt;/code&gt; 的调用，每个调用都请求一个给定大小的更改块。默认的块大小是500，通常应该合适。</target>
        </trans-unit>
        <trans-unit id="b58ee91a98701b75ecd0edc6713c67b3efbc3330" translate="yes" xml:space="preserve">
          <source>The internals are documented in the &lt;a href=&quot;api-index&quot;&gt;Git API documentation&lt;/a&gt;.</source>
          <target state="translated">内部信息记录在&lt;a href=&quot;api-index&quot;&gt;Git API文档中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52e0ef5f6de2b43e809ff876c18bbee69e575471" translate="yes" xml:space="preserve">
          <source>The key may contain any bytes except &lt;code&gt;=&lt;/code&gt;, newline, or NUL. The value may contain any bytes except newline or NUL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051387312310d89e1f2cd1a7644ba37793a94a7c" translate="yes" xml:space="preserve">
          <source>The known attack vectors are as follows:</source>
          <target state="translated">已知的攻击载体如下:</target>
        </trans-unit>
        <trans-unit id="d0880a7ce92ec68d75b7997f1b8b330766294029" translate="yes" xml:space="preserve">
          <source>The lack of a central group of &quot;committers&quot; means there is less need for formal decisions about who is &quot;in&quot; and who is &quot;out&quot;.</source>
          <target state="translated">缺乏一个 &quot;承诺者 &quot;的中心小组,意味着不需要正式决定谁 &quot;加入 &quot;和谁 &quot;退出&quot;。</target>
        </trans-unit>
        <trans-unit id="d217f82f775261a888c8090d4fd57de90a2943db" translate="yes" xml:space="preserve">
          <source>The last diff is empty, but no new commits have been made, and the head still doesn&amp;rsquo;t contain the new line:</source>
          <target state="translated">最后一个差异为空，但未进行任何新的提交，并且头仍不包含新行：</target>
        </trans-unit>
        <trans-unit id="fc6ae42476a6037281df209d5a37adfb042c084d" translate="yes" xml:space="preserve">
          <source>The last three commits (&lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;HEAD^&lt;/code&gt;, and &lt;code&gt;HEAD~2&lt;/code&gt;) were bad and you do not want to ever see them again. Do &lt;strong&gt;not&lt;/strong&gt; do this if you have already given these commits to somebody else. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for the implications of doing so.)</source>
          <target state="translated">最后三个提交（ &lt;code&gt;HEAD&lt;/code&gt; ， &lt;code&gt;HEAD^&lt;/code&gt; 和 &lt;code&gt;HEAD~2&lt;/code&gt; ）很糟糕，您不想再看到它们。难道&lt;strong&gt;不是&lt;/strong&gt;如果你已经给了这些提交给别人做。 （有关这样做的含义，请参见&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]中&lt;/a&gt;的&amp;ldquo;从UPSTREAM REBASE恢复&amp;rdquo;一节。）</target>
        </trans-unit>
        <trans-unit id="9b2685798225cd4befed46a027cdbd30eb245ee2" translate="yes" xml:space="preserve">
          <source>The latest stash you created is stored in &lt;code&gt;refs/stash&lt;/code&gt;; older stashes are found in the reflog of this reference and can be named using the usual reflog syntax (e.g. &lt;code&gt;stash@{0}&lt;/code&gt; is the most recently created stash, &lt;code&gt;stash@{1}&lt;/code&gt; is the one before it, &lt;code&gt;stash@{2.hours.ago}&lt;/code&gt; is also possible). Stashes may also be referenced by specifying just the stash index (e.g. the integer &lt;code&gt;n&lt;/code&gt; is equivalent to &lt;code&gt;stash@{n}&lt;/code&gt;).</source>
          <target state="translated">您创建的最新存储存储在 &lt;code&gt;refs/stash&lt;/code&gt; 中；在此引用的引用日志中可以找到较旧的隐藏项，并且可以使用常规引用日志语法进行命名（例如， &lt;code&gt;stash@{0}&lt;/code&gt; 是最新创建的隐藏项， &lt;code&gt;stash@{1}&lt;/code&gt; 是之前 &lt;code&gt;stash@{2.hours.ago}&lt;/code&gt; ）。还可以通过仅指定存储索引来引用存储（例如，整数 &lt;code&gt;n&lt;/code&gt; 等于 &lt;code&gt;stash@{n}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8bb7601b8118e6905d96f76a29452df6bc2ae98e" translate="yes" xml:space="preserve">
          <source>The latter is not available by default, unless configured.</source>
          <target state="translated">后者在默认情况下不可用,除非配置。</target>
        </trans-unit>
        <trans-unit id="9096be046e467fbce79d2a6fe63b310a7a8be174" translate="yes" xml:space="preserve">
          <source>The latter use of the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values can be overridden by giving the &lt;code&gt;--refmap=&amp;lt;refspec&amp;gt;&lt;/code&gt; parameter(s) on the command line.</source>
          <target state="translated">可以通过在命令行上提供 &lt;code&gt;--refmap=&amp;lt;refspec&amp;gt;&lt;/code&gt; 参数来覆盖对 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 值的后者使用。</target>
        </trans-unit>
        <trans-unit id="63c1787cad9f454d5a2a74665dcae083a7a8328f" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, for git-credential-store to retry when trying to lock the credentials file. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 1000 (i.e., retry for 1s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ffd562f6b8b4abf7958d261df418cb81ead100" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, to retry when trying to lock an individual reference. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 100 (i.e., retry for 100ms).</source>
          <target state="translated">当试图锁定一个单独的引用时,重试的时间长度,以毫秒为单位。值0表示完全不重试;-1表示无限期重试。默认值为100(即重试100毫秒)。</target>
        </trans-unit>
        <trans-unit id="68a6d4f84896f5fe182696f59cffd1c668106a0a" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, to retry when trying to lock the &lt;code&gt;packed-refs&lt;/code&gt; file. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 1000 (i.e., retry for 1 second).</source>
          <target state="translated">尝试锁定 &lt;code&gt;packed-refs&lt;/code&gt; 文件时重试的时间长度（以毫秒为单位）。值0表示完全不重试；-1表示无限期尝试。默认值为1000（即重试1秒）。</target>
        </trans-unit>
        <trans-unit id="fff6cc41c6311b04938a1f36a103054a2f1d2e11" translate="yes" xml:space="preserve">
          <source>The list above is ordered by decreasing precedence; a URL that matches a config key&amp;rsquo;s path is preferred to one that matches its user name. For example, if the URL is &lt;code&gt;https://user@example.com/foo/bar&lt;/code&gt; a config key match of &lt;code&gt;https://example.com/foo&lt;/code&gt; will be preferred over a config key match of &lt;code&gt;https://user@example.com&lt;/code&gt;.</source>
          <target state="translated">上面的列表通过降低优先级进行排序；与配置键的路径匹配的URL优先于与用户名匹配的URL。例如，如果URL是 &lt;code&gt;https://user@example.com/foo/bar&lt;/code&gt; 的一个配置密钥匹配 &lt;code&gt;https://example.com/foo&lt;/code&gt; 将优于的一个配置关键匹配 &lt;code&gt;https://user@example.com&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34cf6a4a25da733f5b8366288a8f31ad385fa0ee" translate="yes" xml:space="preserve">
          <source>The list of identifiers, and other information, of the objects in a &lt;a href=&quot;#def_pack&quot;&gt;pack&lt;/a&gt;, to assist in efficiently accessing the contents of a pack.</source>
          <target state="translated">&lt;a href=&quot;#def_pack&quot;&gt;包中&lt;/a&gt;对象的标识符列表和其他信息，以帮助有效地访问包中的内容。</target>
        </trans-unit>
        <trans-unit id="58413b6422259538de8b3cfc5351841a4fb3ade2" translate="yes" xml:space="preserve">
          <source>The list of mailbox files to read patches from. If you do not supply this argument, the command reads from the standard input. If you supply directories, they will be treated as Maildirs.</source>
          <target state="translated">要读取补丁的邮箱文件列表。如果你不提供这个参数,命令将从标准输入中读取。如果你提供了目录,它们将被视为Maildirs。</target>
        </trans-unit>
        <trans-unit id="811a0eecf6c6689902c9fc1e00fe667f20b10132" translate="yes" xml:space="preserve">
          <source>The list of remotes which are fetched by &quot;git remote update &amp;lt;group&amp;gt;&quot;. See &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">由&amp;ldquo; git remote update &amp;lt;组&amp;gt;&amp;rdquo;获取的远程列表。参见&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3aadf5969931435dfd81a576572d271c1b7df1e4" translate="yes" xml:space="preserve">
          <source>The list you get with &quot;ls&quot; :-)</source>
          <target state="translated">你用 &quot;ls &quot;得到的列表:-)</target>
        </trans-unit>
        <trans-unit id="2d5bfecbee3eeb5c71f69bd43de88bc34222a07d" translate="yes" xml:space="preserve">
          <source>The local offset is specified by &lt;code&gt;&amp;lt;offutc&amp;gt;&lt;/code&gt; as a positive or negative offset from UTC. For example EST (which is 5 hours behind UTC) would be expressed in &lt;code&gt;&amp;lt;tz&amp;gt;&lt;/code&gt; by &amp;ldquo;-0500&amp;rdquo; while UTC is &amp;ldquo;+0000&amp;rdquo;. The local offset does not affect &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;; it is used only as an advisement to help formatting routines display the timestamp.</source>
          <target state="translated">&lt;code&gt;&amp;lt;offutc&amp;gt;&lt;/code&gt; 将本地偏移量指定为相对于UTC的正偏移量或负偏移量。例如，EST（比UTC晚5小时）将以 &lt;code&gt;&amp;lt;tz&amp;gt;&lt;/code&gt; 表示为&amp;ldquo; -0500&amp;rdquo;，而UTC是&amp;ldquo; +0000&amp;rdquo;。本地偏移量不影响 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; ；它仅用作建议，以帮助格式化例程显示时间戳。</target>
        </trans-unit>
        <trans-unit id="ab508d82c7d8a4545e2bb32ec9ec4fb2386a14cb" translate="yes" xml:space="preserve">
          <source>The location of an augmenting mailmap file. The default mailmap, located in the root of the repository, is loaded first, then the mailmap file pointed to by this variable. The location of the mailmap file may be in a repository subdirectory, or somewhere outside of the repository itself. See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">扩充邮件映射文件的位置。首先加载位于存储库根目录中的默认邮件映射，然后加载此变量指向的邮件映射文件。邮件映射文件的位置可以在存储库子目录中，也可以在存储库本身之外的某个位置。参见&lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt;和&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3bb0979c637e06c575b3f731f106ded5d4b916f" translate="yes" xml:space="preserve">
          <source>The location of per-instance and system-wide configuration files can be overridden using the following environment variables:</source>
          <target state="translated">可以使用以下环境变量覆盖每个实例和全系统配置文件的位置。</target>
        </trans-unit>
        <trans-unit id="9446c1e5cce4b2ece4fc10ff79540962e21c6551" translate="yes" xml:space="preserve">
          <source>The magic word &lt;code&gt;top&lt;/code&gt; (magic signature: &lt;code&gt;/&lt;/code&gt;) makes the pattern match from the root of the working tree, even when you are running the command from inside a subdirectory.</source>
          <target state="translated">魔术字 &lt;code&gt;top&lt;/code&gt; （魔术签名： &lt;code&gt;/&lt;/code&gt; ）使模式从工作树的根开始匹配，即使您是在子目录中运行命令也是如此。</target>
        </trans-unit>
        <trans-unit id="64ba77ac0581cbecc6b691422d0c5681817b2387" translate="yes" xml:space="preserve">
          <source>The main command loop has 6 subcommands (plus help and quit).</source>
          <target state="translated">主命令循环有6个子命令(加上帮助和退出)。</target>
        </trans-unit>
        <trans-unit id="0b0bee129956915b1cb776d4190a01b55932ed3c" translate="yes" xml:space="preserve">
          <source>The main command loop has 6 subcommands.</source>
          <target state="translated">主命令循环有6个子命令。</target>
        </trans-unit>
        <trans-unit id="821ddd85eba2b4bc6e95a82521b10b32287622db" translate="yes" xml:space="preserve">
          <source>The main trunk is stored in the Git branch named &lt;code&gt;origin&lt;/code&gt;, and additional CVS branches are stored in Git branches with the same names. The most recent version of the main trunk is also left checked out on the &lt;code&gt;master&lt;/code&gt; branch, so you can start adding your own changes right away.</source>
          <target state="translated">主干存储在名为 &lt;code&gt;origin&lt;/code&gt; 的Git分支中，其他CVS分支以相同的名称存储在Git分支中。主干线的最新版本还剩下签出的 &lt;code&gt;master&lt;/code&gt; 分支，这样你就可以开始添加你自己改变的时候了。</target>
        </trans-unit>
        <trans-unit id="f31023370321849385c22bc8ae521136bfffac45" translate="yes" xml:space="preserve">
          <source>The mapping of file names from the p4 depot path to Git, by default, involves removing the entire depot path. With this option, the full p4 depot path is retained in Git. For example, path &lt;code&gt;//depot/main/foo/bar.c&lt;/code&gt;, when imported from &lt;code&gt;//depot/main/&lt;/code&gt;, becomes &lt;code&gt;foo/bar.c&lt;/code&gt;. With &lt;code&gt;--keep-path&lt;/code&gt;, the Git path is instead &lt;code&gt;depot/main/foo/bar.c&lt;/code&gt;.</source>
          <target state="translated">默认情况下，从p4仓库路径到Git的文件名映射涉及删除整个仓库路径。使用此选项，完整的p4仓库路径将保留在Git中。例如，路径 &lt;code&gt;//depot/main/foo/bar.c&lt;/code&gt; ，从导入时 &lt;code&gt;//depot/main/&lt;/code&gt; 变得 &lt;code&gt;foo/bar.c&lt;/code&gt; 。与 &lt;code&gt;--keep-path&lt;/code&gt; ，所述路径GIT中是代替 &lt;code&gt;depot/main/foo/bar.c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="696795b724c116f40755fe0ffd2f815f95c8f529" translate="yes" xml:space="preserve">
          <source>The mark command is optional here as some frontends have chosen to generate the Git SHA-1 for the blob on their own, and feed that directly to &lt;code&gt;commit&lt;/code&gt;. This is typically more work than it&amp;rsquo;s worth however, as marks are inexpensive to store and easy to use.</source>
          <target state="translated">mark命令在这里是可选的，因为一些前端已经选择自行生成Blob的Git SHA-1，并直接将其 &lt;code&gt;commit&lt;/code&gt; 以进行提交。但是，由于标记的存储成本低且易于使用，因此这通常比值得的工作还要多。</target>
        </trans-unit>
        <trans-unit id="154d6f76415eae422478f55f25c1ddb853a4e1ab" translate="yes" xml:space="preserve">
          <source>The maximum delta depth used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; when no maximum depth is given on the command line. Defaults to 50. Maximum value is 4095.</source>
          <target state="translated">&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;在命令行上未指定最大深度时使用的最大增量深度。默认值为50。最大值为4095。</target>
        </trans-unit>
        <trans-unit id="95e6e1cf49a26e9f67b2825bc0bd39addf27373a" translate="yes" xml:space="preserve">
          <source>The maximum length of the output filenames generated by the &lt;code&gt;format-patch&lt;/code&gt; command; defaults to 64. Can be overridden by the &lt;code&gt;--filename-max-length=&amp;lt;n&amp;gt;&lt;/code&gt; command line option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9325da9117f9b4afd884e4f7e837bf9ca641172e" translate="yes" xml:space="preserve">
          <source>The maximum memory in bytes used for caching deltas in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; before writing them out to a pack. This cache is used to speed up the writing object phase by not having to recompute the final delta result once the best match for all objects is found. Repacking large repositories on machines which are tight with memory might be badly impacted by this though, especially if this cache pushes the system into swapping. A value of 0 means no limit. The smallest size of 1 byte may be used to virtually disable this cache. Defaults to 256 MiB.</source>
          <target state="translated">在将&lt;a href=&quot;git-pack-objects&quot;&gt;Delta-pack-objects [1]中的&lt;/a&gt;增量写入数据包之前，用于缓存增量的最大内存（以字节为单位）。一旦找到了所有对象的最佳匹配项，就不必重新计算最终的增量结果，此缓存可用于加快写入对象的阶段。但是，在内存紧张的计算机上重新打包大型存储库可能会受到严重影响，特别是如果此缓存将系统推向交换状态。值为0表示没有限制。 1字节的最小大小可用于虚拟禁用此缓存。默认为256 MiB。</target>
        </trans-unit>
        <trans-unit id="a0015a1c1a155cb39bc99dd58a785f6e45fb6909" translate="yes" xml:space="preserve">
          <source>The maximum size of a delta, that is cached in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This cache is used to speed up the writing object phase by not having to recompute the final delta result once the best match for all objects is found. Defaults to 1000. Maximum value is 65535.</source>
          <target state="translated">增量的最大大小，该大小缓存在&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]中&lt;/a&gt;。一旦找到所有对象的最佳匹配，就不必重新计算最终的增量结果，就可以使用该缓存来加快写入对象的阶段。默认值为1000。最大值为65535。</target>
        </trans-unit>
        <trans-unit id="d2696797b76aad16406d56dd354feaf085869327" translate="yes" xml:space="preserve">
          <source>The maximum size of a pack. This setting only affects packing to a file when repacking, i.e. the git:// protocol is unaffected. It can be overridden by the &lt;code&gt;--max-pack-size&lt;/code&gt; option of &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. Reaching this limit results in the creation of multiple packfiles; which in turn prevents bitmaps from being created. The minimum size allowed is limited to 1 MiB. The default is unlimited. Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">一包的最大尺寸。此设置仅在重新打包时影响打包到文件，即git：//协议不受影响。可以通过&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;的 &lt;code&gt;--max-pack-size&lt;/code&gt; 选项覆盖它。达到此限制将导致创建多个packfile；反过来又阻止了位图的创建。允许的最小大小限制为1 MiB。默认值为无限制。支持 &lt;code&gt;k&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; 或 &lt;code&gt;g&lt;/code&gt; 的通用单位后缀。</target>
        </trans-unit>
        <trans-unit id="bb8ed32c533714ca4a8bb85ec574c3c5791f3a2f" translate="yes" xml:space="preserve">
          <source>The maximum size of memory that is consumed by each thread in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for pack window memory when no limit is given on the command line. The value can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. When left unconfigured (or set explicitly to 0), there will be no limit.</source>
          <target state="translated">当在命令行上未给出限制时，&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]中&lt;/a&gt;的每个线程在pack窗口内存中占用的最大内存大小。该值可以带有&amp;ldquo; k&amp;rdquo;，&amp;ldquo; m&amp;rdquo;或&amp;ldquo; g&amp;rdquo;后缀。取消配置（或显式设置为0）时，将没有限制。</target>
        </trans-unit>
        <trans-unit id="565cc584b68c5b675a716ec7daae7fd9f3343784" translate="yes" xml:space="preserve">
          <source>The meaning of each part of feature configuration is described below:</source>
          <target state="translated">下面将介绍功能配置中各部分的含义。</target>
        </trans-unit>
        <trans-unit id="9c067af8c6826c60723d70b61f19783aa20b528e" translate="yes" xml:space="preserve">
          <source>The merge backend keeps intentionally empty commits by default (though with -i they are marked as empty in the todo list editor, or they can be dropped automatically with --no-keep-empty).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e3581a01e860cba15921ad7e00a74542d34f54" translate="yes" xml:space="preserve">
          <source>The merge backend works with a full copy of each relevant file, insulating it from these types of problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c94b31b25e0c09828d4438bdd636247e16e902" translate="yes" xml:space="preserve">
          <source>The merge backend works with the full commits on both sides of history and thus has no such limitations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657f593653b8985b76ea363799992d9ccd8552d1" translate="yes" xml:space="preserve">
          <source>The merge driver can learn the pathname in which the merged result will be stored via placeholder &lt;code&gt;%P&lt;/code&gt;.</source>
          <target state="translated">合并驱动程序可以通过占位符 &lt;code&gt;%P&lt;/code&gt; 来学习将合并结果存储在其中的路径名。</target>
        </trans-unit>
        <trans-unit id="3a4ee88dc1fd419e5903b5a6b97383e8c2a1fab9" translate="yes" xml:space="preserve">
          <source>The merge driver is expected to leave the result of the merge in the file named with &lt;code&gt;%A&lt;/code&gt; by overwriting it, and exit with zero status if it managed to merge them cleanly, or non-zero if there were conflicts.</source>
          <target state="translated">期望合并驱动程序通过覆盖将合并结果保留在以 &lt;code&gt;%A&lt;/code&gt; 命名的文件中，如果它设法干净地合并它们，则退出状态为零；如果存在冲突，则合并状态为非零。</target>
        </trans-unit>
        <trans-unit id="d39522f0982abae4a359335f63ed088d0f4a4c4e" translate="yes" xml:space="preserve">
          <source>The merge mechanism (&lt;code&gt;git merge&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; commands) allows the backend &lt;code&gt;merge strategies&lt;/code&gt; to be chosen with &lt;code&gt;-s&lt;/code&gt; option. Some strategies can also take their own options, which can be passed by giving &lt;code&gt;-X&amp;lt;option&amp;gt;&lt;/code&gt; arguments to &lt;code&gt;git merge&lt;/code&gt; and/or &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">合并机制（ &lt;code&gt;git merge&lt;/code&gt; 和 &lt;code&gt;git pull&lt;/code&gt; 命令）允许使用 &lt;code&gt;-s&lt;/code&gt; 选项选择后端 &lt;code&gt;merge strategies&lt;/code&gt; 。某些策略也可以采用自己的选项，可以通过为 &lt;code&gt;git merge&lt;/code&gt; 和/或 &lt;code&gt;git pull&lt;/code&gt; 提供 &lt;code&gt;-X&amp;lt;option&amp;gt;&lt;/code&gt; 参数来传递它们。</target>
        </trans-unit>
        <trans-unit id="fa594438c3581495b74bb79c047cb66382bd8b0d" translate="yes" xml:space="preserve">
          <source>The merge workflow works by copying branches between upstream and downstream. Upstream can merge contributions into the official history; downstream base their work on the official history.</source>
          <target state="translated">合并工作流的工作原理是在上游和下游之间复制分支。上游可以将贡献合并到官方历史中;下游则以官方历史为基础开展工作。</target>
        </trans-unit>
        <trans-unit id="1df107645dfce75dc8613a8a0f6007cf8381d780" translate="yes" xml:space="preserve">
          <source>The merge-base command finds a common ancestor of the given commits, and always returns one or the other in the case where one is a descendant of the other; so the above output shows that e05db0fd actually is an ancestor of v1.5.0-rc1.</source>
          <target state="translated">merge-base命令可以找到给定提交的共同祖先,如果一个是另一个的后裔,总是返回一个或另一个;所以上面的输出显示e05db0fd实际上是v1.5.0-rc1的祖先。</target>
        </trans-unit>
        <trans-unit id="91d3bf0b3d356085e2e60914fc9a13ad2e2b8ebf" translate="yes" xml:space="preserve">
          <source>The message in a commit or a tag object is &lt;code&gt;contents&lt;/code&gt;, from which &lt;code&gt;contents:&amp;lt;part&amp;gt;&lt;/code&gt; can be used to extract various parts out of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f5c4372c6fc154ead993a9f4b5a82da922524d" translate="yes" xml:space="preserve">
          <source>The message taken from file with &lt;code&gt;-F&lt;/code&gt; and command line with &lt;code&gt;-m&lt;/code&gt; are usually used as the tag message unmodified. This option lets you further edit the message taken from these sources.</source>
          <target state="translated">从 &lt;code&gt;-F&lt;/code&gt; 的文件中获取的消息和 &lt;code&gt;-m&lt;/code&gt; 的命令行中获取的消息通常用作未修改的标记消息。此选项使您可以进一步编辑从这些来源获取的消息。</target>
        </trans-unit>
        <trans-unit id="1e2b72f6afed427d21f4e345d320e470730d82f9" translate="yes" xml:space="preserve">
          <source>The message taken from file with &lt;code&gt;-F&lt;/code&gt;, command line with &lt;code&gt;-m&lt;/code&gt;, and from commit object with &lt;code&gt;-C&lt;/code&gt; are usually used as the commit log message unmodified. This option lets you further edit the message taken from these sources.</source>
          <target state="translated">从 &lt;code&gt;-F&lt;/code&gt; 的文件，从 &lt;code&gt;-m&lt;/code&gt; 的命令行和从 &lt;code&gt;-C&lt;/code&gt; 的提交对象获取的消息通常用作未修改的提交日志消息。此选项使您可以进一步编辑从这些来源获取的消息。</target>
        </trans-unit>
        <trans-unit id="ae16f65784862fd6e529b736650355763df13327" translate="yes" xml:space="preserve">
          <source>The method by which a submodule is updated by &lt;code&gt;git submodule update&lt;/code&gt;, which is the only affected command, others such as &lt;code&gt;git checkout --recurse-submodules&lt;/code&gt; are unaffected. It exists for historical reasons, when &lt;code&gt;git submodule&lt;/code&gt; was the only command to interact with submodules; settings like &lt;code&gt;submodule.active&lt;/code&gt; and &lt;code&gt;pull.rebase&lt;/code&gt; are more specific. It is populated by &lt;code&gt;git submodule init&lt;/code&gt; from the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file. See description of &lt;code&gt;update&lt;/code&gt; command in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git submodule update&lt;/code&gt; 用来更新子模块的方法是唯一受影响的命令，而 &lt;code&gt;git checkout --recurse-submodules&lt;/code&gt; 等其他命令则不受影响。由于历史原因，它存在，当时 &lt;code&gt;git submodule&lt;/code&gt; 是与子模块进行交互的唯一命令。诸如 &lt;code&gt;submodule.active&lt;/code&gt; 和 &lt;code&gt;pull.rebase&lt;/code&gt; 之类的设置更为具体。它是由填充 &lt;code&gt;git submodule init&lt;/code&gt; 从&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;的文件。参见&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt;中 &lt;code&gt;update&lt;/code&gt; 命令的描述。</target>
        </trans-unit>
        <trans-unit id="04ef06b50b9899f38b1e5f5c81eb00396b6d2328" translate="yes" xml:space="preserve">
          <source>The mode parameter is optional (defaults to &lt;code&gt;all&lt;/code&gt;), and is used to specify the handling of untracked files; when -u is not used, the default is &lt;code&gt;normal&lt;/code&gt;, i.e. show untracked files and directories.</source>
          <target state="translated">mode参数是可选的（默认为 &lt;code&gt;all&lt;/code&gt; ），用于指定未跟踪文件的处理；当不使用-u时，默认值为 &lt;code&gt;normal&lt;/code&gt; ，即显示未跟踪的文件和目录。</target>
        </trans-unit>
        <trans-unit id="daee71f2e966cf5f390a0401b9f0381f1242178c" translate="yes" xml:space="preserve">
          <source>The mode parameter is used to specify the handling of ignored files. It is optional: it defaults to &lt;code&gt;traditional&lt;/code&gt;.</source>
          <target state="translated">mode参数用于指定忽略文件的处理。它是可选的：默认为 &lt;code&gt;traditional&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="789771a80f50eaf70002a855307c4e88ea3d25bd" translate="yes" xml:space="preserve">
          <source>The mode parameter is used to specify the handling of untracked files. It is optional: it defaults to &lt;code&gt;all&lt;/code&gt;, and if specified, it must be stuck to the option (e.g. &lt;code&gt;-uno&lt;/code&gt;, but not &lt;code&gt;-u no&lt;/code&gt;).</source>
          <target state="translated">mode参数用于指定未跟踪文件的处理。它是可选的：默认为 &lt;code&gt;all&lt;/code&gt; ，并且如果指定，则必须坚持使用该选项（例如， &lt;code&gt;-uno&lt;/code&gt; ，而不是 &lt;code&gt;-u no&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d56062b3fd6eee94e49e5896b7d127ee25df01a1" translate="yes" xml:space="preserve">
          <source>The modifications stashed away by this command can be listed with &lt;code&gt;git stash list&lt;/code&gt;, inspected with &lt;code&gt;git stash show&lt;/code&gt;, and restored (potentially on top of a different commit) with &lt;code&gt;git stash apply&lt;/code&gt;. Calling &lt;code&gt;git stash&lt;/code&gt; without any arguments is equivalent to &lt;code&gt;git stash push&lt;/code&gt;. A stash is by default listed as &quot;WIP on &lt;code&gt;branchname&lt;/code&gt; &amp;hellip;​&quot;, but you can give a more descriptive message on the command line when you create one.</source>
          <target state="translated">可以使用 &lt;code&gt;git stash list&lt;/code&gt; 列出该修改保存的修改，可以使用 &lt;code&gt;git stash show&lt;/code&gt; 进行检查，还可以使用 &lt;code&gt;git stash apply&lt;/code&gt; 恢复（可能在其他提交之上）。不带任何参数调用 &lt;code&gt;git stash&lt;/code&gt; 等效于 &lt;code&gt;git stash push&lt;/code&gt; 。默认情况下，存储项显示为&amp;ldquo; WIP on &lt;code&gt;branchname&lt;/code&gt; &amp;hellip;&amp;rdquo;，但是在创建存储项时，可以在命令行上提供更具描述性的消息。</target>
        </trans-unit>
        <trans-unit id="e06fa83026ee56ec3b62a659fa5a44c6e4e4728d" translate="yes" xml:space="preserve">
          <source>The module path (only needed if httpd is Apache). (Default: /usr/lib/apache2/modules)</source>
          <target state="translated">模块路径(只有当httpd是Apache时才需要)。(默认:/usr/lib/apache2/modules)</target>
        </trans-unit>
        <trans-unit id="08ed4170506fa174e84f549a0e3f26086c486529" translate="yes" xml:space="preserve">
          <source>The more complex forms are:</source>
          <target state="translated">比较复杂的形式是:</target>
        </trans-unit>
        <trans-unit id="7d735293dee944ca58932a7261110828d307c793" translate="yes" xml:space="preserve">
          <source>The most common cause of dangling objects is that you&amp;rsquo;ve rebased a branch, or you have pulled from somebody else who rebased a branch&amp;mdash;​see &lt;a href=&quot;#cleaning-up-history&quot;&gt;Rewriting history and maintaining patch series&lt;/a&gt;. In that case, the old head of the original branch still exists, as does everything it pointed to. The branch pointer itself just doesn&amp;rsquo;t, since you replaced it with another one.</source>
          <target state="translated">导致对象悬空的最常见原因是您已经重新建立了分支的基础，或者已经从重新建立分支的其他人那里撤走了-请参阅&lt;a href=&quot;#cleaning-up-history&quot;&gt;重写历史记录和维护修补程序系列&lt;/a&gt;。在这种情况下，原始分支的旧头仍然存在，它指向的所有内容也一样。分支指针本身只是不行，因为您已将其替换为另一个。</target>
        </trans-unit>
        <trans-unit id="8bc143dd44c89f63596943262174b04211332773" translate="yes" xml:space="preserve">
          <source>The multi-pack-index (MIDX for short) stores a list of objects and their offsets into multiple packfiles. It contains:</source>
          <target state="translated">多包索引(简称MIDX)将对象列表及其偏移量存储到多个包文件中。它包含:</target>
        </trans-unit>
        <trans-unit id="4ca15f678a55a1443f2d701a54958e45ad8a0235" translate="yes" xml:space="preserve">
          <source>The multi-pack-index allows many packfiles, especially in a context where repacking is expensive (such as a very large repo), or unexpected maintenance time is unacceptable (such as a high-demand build machine). However, the multi-pack-index needs to be rewritten in full every time. We can extend the format to be incremental, so writes are fast. By storing a small &quot;tip&quot; multi-pack-index that points to large &quot;base&quot; MIDX files, we can keep writes fast while still reducing the number of binary searches required for object lookups.</source>
          <target state="translated">multi-pack-index允许许多packfiles,特别是在重新打包成本很高的情况下(比如一个非常大的repo),或者意外的维护时间是不可接受的(比如一个高需求的构建机)。然而,多包索引每次都需要全部重写。我们可以将格式扩展为增量,所以写入速度很快。通过存储一个小的 &quot;小费 &quot;多包索引,指向大的 &quot;基础 &quot;MIDX文件,我们可以保持快速写入,同时还可以减少对象查找所需的二进制搜索次数。</target>
        </trans-unit>
        <trans-unit id="d98c840529f1ab7c2fa3df48a823219f4ff9a17e" translate="yes" xml:space="preserve">
          <source>The multi-pack-index files refer to multiple pack-files and loose objects.</source>
          <target state="translated">多包索引文件指的是多包文件和松散对象。</target>
        </trans-unit>
        <trans-unit id="1e0c8af9211e361d1a35789c37df84247f7ae9ac" translate="yes" xml:space="preserve">
          <source>The name and the e-mail address of the owner of the key that signed the push certificate.</source>
          <target state="translated">签署推送证书的密钥所有者的姓名和电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="2551d22d5e60fb51293e5ef827d3f2d640624d55" translate="yes" xml:space="preserve">
          <source>The name of a commit at which to start the new branch; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details. Defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">开始新分支的提交的名称；有关详细信息，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;。默认为 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0efd5464958e1be85e38672256be6f6e17bc462a" translate="yes" xml:space="preserve">
          <source>The name of a local ref which can be considered &amp;ldquo;upstream&amp;rdquo; from the displayed ref. Respects &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt; and &lt;code&gt;:rstrip&lt;/code&gt; in the same way as &lt;code&gt;refname&lt;/code&gt; above. Additionally respects &lt;code&gt;:track&lt;/code&gt; to show &quot;[ahead N, behind M]&quot; and &lt;code&gt;:trackshort&lt;/code&gt; to show the terse version: &quot;&amp;gt;&quot; (ahead), &quot;&amp;lt;&quot; (behind), &quot;&amp;lt;&amp;gt;&quot; (ahead and behind), or &quot;=&quot; (in sync). &lt;code&gt;:track&lt;/code&gt; also prints &quot;[gone]&quot; whenever unknown upstream ref is encountered. Append &lt;code&gt;:track,nobracket&lt;/code&gt; to show tracking information without brackets (i.e &quot;ahead N, behind M&quot;).</source>
          <target state="translated">本地裁判的名称，可以将其视为所显示裁判的&amp;ldquo;上游&amp;rdquo;。与上面的 &lt;code&gt;refname&lt;/code&gt; 一样，尊重 &lt;code&gt;:short&lt;/code&gt; ， &lt;code&gt;:lstrip&lt;/code&gt; 和 &lt;code&gt;:rstrip&lt;/code&gt; 。另外， &lt;code&gt;:track&lt;/code&gt; 表示&amp;ldquo; [[N之前，M后面]&amp;rdquo;，而 &lt;code&gt;:trackshort&lt;/code&gt; 表示简洁的版本：&amp;ldquo;&amp;gt;&amp;rdquo;（前面），&amp;ldquo; &amp;lt;&amp;rdquo;（后面），&amp;ldquo; &amp;lt;&amp;gt;&amp;rdquo;（前面和后面）或&amp;ldquo; =&amp;ldquo;（同步）。 &lt;code&gt;:track&lt;/code&gt; 每当遇到未知的上游引用时也会打印&amp;ldquo; [gone]&amp;rdquo;。附加 &lt;code&gt;:track,nobracket&lt;/code&gt; 以不带括号的方式显示跟踪信息（即&amp;ldquo; N前面，M后面&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="285243cf13ade280f7038dfb92bbdaa7d26dec36" translate="yes" xml:space="preserve">
          <source>The name of a local ref which represents the &lt;code&gt;@{push}&lt;/code&gt; location for the displayed ref. Respects &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt;, &lt;code&gt;:rstrip&lt;/code&gt;, &lt;code&gt;:track&lt;/code&gt;, &lt;code&gt;:trackshort&lt;/code&gt;, &lt;code&gt;:remotename&lt;/code&gt;, and &lt;code&gt;:remoteref&lt;/code&gt; options as &lt;code&gt;upstream&lt;/code&gt; does. Produces an empty string if no &lt;code&gt;@{push}&lt;/code&gt; ref is configured.</source>
          <target state="translated">本地引用的名称，代表所显示引用的 &lt;code&gt;@{push}&lt;/code&gt; 位置。与 &lt;code&gt;upstream&lt;/code&gt; 一样，尊重 &lt;code&gt;:short&lt;/code&gt; ， &lt;code&gt;:lstrip&lt;/code&gt; ， &lt;code&gt;:rstrip&lt;/code&gt; ， &lt;code&gt;:track&lt;/code&gt; ， &lt;code&gt;:trackshort&lt;/code&gt; ， &lt;code&gt;:remotename&lt;/code&gt; 和 &lt;code&gt;:remoteref&lt;/code&gt; remoteref选项。如果未配置 &lt;code&gt;@{push}&lt;/code&gt; 引用，则产生一个空字符串。</target>
        </trans-unit>
        <trans-unit id="25973fbcb02049e23787d52ffa23363b0665166c" translate="yes" xml:space="preserve">
          <source>The name of a new directory to clone into. The &quot;humanish&quot; part of the source repository is used if no directory is explicitly given (&lt;code&gt;repo&lt;/code&gt; for &lt;code&gt;/path/to/repo.git&lt;/code&gt; and &lt;code&gt;foo&lt;/code&gt; for &lt;code&gt;host.xz:foo/.git&lt;/code&gt;). Cloning into an existing directory is only allowed if the directory is empty.</source>
          <target state="translated">要克隆到的新目录的名称。使用源资源库的&amp;ldquo;humanish&amp;rdquo;部分，如果没有目录明确给出（ &lt;code&gt;repo&lt;/code&gt; 为 &lt;code&gt;/path/to/repo.git&lt;/code&gt; 和 &lt;code&gt;foo&lt;/code&gt; 为 &lt;code&gt;host.xz:foo/.git&lt;/code&gt; ）。仅当目录为空时才允许克隆到现有目录。</target>
        </trans-unit>
        <trans-unit id="3c836d4cc86fbcc3a897aa8fab973465c40a1899" translate="yes" xml:space="preserve">
          <source>The name of an existing branch already in fast-import&amp;rsquo;s internal branch table. If fast-import doesn&amp;rsquo;t know the name, it&amp;rsquo;s treated as a SHA-1 expression.</source>
          <target state="translated">快速导入的内部分支表中已存在的分支的名称。如果快速导入不知道名称，则将其视为SHA-1表达式。</target>
        </trans-unit>
        <trans-unit id="c21a579b2f8550495cd7f286a4f77b45b3df2f6e" translate="yes" xml:space="preserve">
          <source>The name of an existing branch to rename.</source>
          <target state="translated">要重命名的现有分支的名称。</target>
        </trans-unit>
        <trans-unit id="b35cfa9e6735c6918643ac8769ab4e5dd81020f0" translate="yes" xml:space="preserve">
          <source>The name of an external credential helper, and any associated options. If the helper name is not an absolute path, then the string &lt;code&gt;git
credential-&lt;/code&gt; is prepended. The resulting string is executed by the shell (so, for example, setting this to &lt;code&gt;foo --option=bar&lt;/code&gt; will execute &lt;code&gt;git credential-foo --option=bar&lt;/code&gt; via the shell. See the manual of specific helpers for examples of their use.</source>
          <target state="translated">外部凭据助手的名称以及任何关联的选项。如果助手名称不是绝对路径，那么将使用字符串 &lt;code&gt;git credential-&lt;/code&gt; 。结果字符串由外壳程序执行（例如，将其设置为 &lt;code&gt;foo --option=bar&lt;/code&gt; 将通过外壳程序执行 &lt;code&gt;git credential-foo --option=bar&lt;/code&gt; 。有关其用法的示例，请参阅特定帮助程序的手册。</target>
        </trans-unit>
        <trans-unit id="7efaaad02f8c0d5eaaddaa5b6f8a8113410c8ef1" translate="yes" xml:space="preserve">
          <source>The name of one of the following can be used instead of a URL as &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument:</source>
          <target state="translated">可以使用以下任一名称代替URL作为 &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="f54520854ea19fafb55997c9840c558f7f80fed9" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;replace&lt;/code&gt; reference is the SHA-1 of the object that is replaced. The content of the &lt;code&gt;replace&lt;/code&gt; reference is the SHA-1 of the replacement object.</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; 引用的名称是被替换对象的SHA-1。 &lt;code&gt;replace&lt;/code&gt; 引用的内容是替换对象的SHA-1。</target>
        </trans-unit>
        <trans-unit id="117daad0c937bbfd67b26eaa98382dde664a6203" translate="yes" xml:space="preserve">
          <source>The name of the branch to create or delete. The new branch name must pass all checks defined by &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format[1]&lt;/a&gt;. Some of these checks may restrict the characters allowed in a branch name.</source>
          <target state="translated">要创建或删除的分支的名称。新的分支名称必须通过&lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format [1]&lt;/a&gt;定义的所有检查。其中一些检查可能会限制分支名称中允许的字符。</target>
        </trans-unit>
        <trans-unit id="f40b450a4e1f94bf798289a960712dae0a6f632b" translate="yes" xml:space="preserve">
          <source>The name of the client can be given to &lt;code&gt;git p4&lt;/code&gt; in multiple ways. The variable &lt;code&gt;git-p4.client&lt;/code&gt; takes precedence if it exists. Otherwise, normal p4 mechanisms of determining the client are used: environment variable &lt;code&gt;P4CLIENT&lt;/code&gt;, a file referenced by &lt;code&gt;P4CONFIG&lt;/code&gt;, or the local host name.</source>
          <target state="translated">客户端的名称可以通过多种方式赋予 &lt;code&gt;git p4&lt;/code&gt; 。变量 &lt;code&gt;git-p4.client&lt;/code&gt; 优先（如果存在）。否则，将使用确定客户端的常规p4机制：环境变量 &lt;code&gt;P4CLIENT&lt;/code&gt; ， &lt;code&gt;P4CONFIG&lt;/code&gt; 引用的文件或本地主机名。</target>
        </trans-unit>
        <trans-unit id="d25f4900ca4ac26428c337fc8a49a0fffaa87baa" translate="yes" xml:space="preserve">
          <source>The name of the current branch is stored in .git/HEAD.</source>
          <target state="translated">当前分支的名称存储在.git/HEAD中。</target>
        </trans-unit>
        <trans-unit id="9192c74ec25457f29baaadaeb1d2b767ba20ddac" translate="yes" xml:space="preserve">
          <source>The name of the local ref being pushed, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix. In the case of deletion, the name of the local ref is omitted.</source>
          <target state="translated">推送的本地ref的名称减去其 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 前缀。在删除的情况下，将省略本地引用的名称。</target>
        </trans-unit>
        <trans-unit id="61c75d700127b0c70d569d247bca51622e343006" translate="yes" xml:space="preserve">
          <source>The name of the local ref being updated, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix.</source>
          <target state="translated">要更新的本地ref的名称减去其 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="40299b8374a45bc90296f421fddf5763cb8c6908" translate="yes" xml:space="preserve">
          <source>The name of the object to show. For a more complete list of ways to spell object names, see the &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">要显示的对象的名称。有关拼写对象名称的方法的完整列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]中&lt;/a&gt;的&amp;ldquo;指定版本&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="15cfdda92a704493f44c3f6bda85fdb4fe25cc87" translate="yes" xml:space="preserve">
          <source>The name of the ref (the part after $GIT_DIR/). For a non-ambiguous short name of the ref append &lt;code&gt;:short&lt;/code&gt;. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode. If &lt;code&gt;lstrip=&amp;lt;N&amp;gt;&lt;/code&gt; (&lt;code&gt;rstrip=&amp;lt;N&amp;gt;&lt;/code&gt;) is appended, strips &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; slash-separated path components from the front (back) of the refname (e.g. &lt;code&gt;%(refname:lstrip=2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;%(refname:rstrip=2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;refs&lt;/code&gt;). If &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; is a negative number, strip as many path components as necessary from the specified end to leave &lt;code&gt;-&amp;lt;N&amp;gt;&lt;/code&gt; path components (e.g. &lt;code&gt;%(refname:lstrip=-2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;tags/foo&lt;/code&gt; and &lt;code&gt;%(refname:rstrip=-1)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;refs&lt;/code&gt;). When the ref does not have enough components, the result becomes an empty string if stripping with positive &amp;lt;N&amp;gt;, or it becomes the full refname if stripping with negative &amp;lt;N&amp;gt;. Neither is an error.</source>
          <target state="translated">引用的名称（$ GIT_DIR /之后的部分）。对于ref的明确名称，请附加 &lt;code&gt;:short&lt;/code&gt; 。选项core.warnAmbiguousRefs用于选择严格缩写模式。如果 &lt;code&gt;lstrip=&amp;lt;N&amp;gt;&lt;/code&gt; （ &lt;code&gt;rstrip=&amp;lt;N&amp;gt;&lt;/code&gt; ），则从refname的前面（后面） &lt;code&gt;%(refname:lstrip=2)&lt;/code&gt; &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; 斜杠分隔的路径分量（例如，％（refname：lstrip = 2）变成 &lt;code&gt;refs/tags/foo&lt;/code&gt; 变成 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;%(refname:rstrip=2)&lt;/code&gt; 将 &lt;code&gt;refs/tags/foo&lt;/code&gt; 变成 &lt;code&gt;refs&lt;/code&gt; 。如果 &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; 为负数，则从指定的末端剥去尽可能多的路径分量，以保留 &lt;code&gt;-&amp;lt;N&amp;gt;&lt;/code&gt; 路径组件（例如， &lt;code&gt;%(refname:lstrip=-2)&lt;/code&gt; 将 &lt;code&gt;refs/tags/foo&lt;/code&gt; 转换为 &lt;code&gt;tags/foo&lt;/code&gt; ,而 &lt;code&gt;%(refname:rstrip=-1)&lt;/code&gt; 将 &lt;code&gt;refs/tags/foo&lt;/code&gt; 转换为 &lt;code&gt;refs&lt;/code&gt; ）。当ref的分量不足时，如果使用正号&amp;lt;N&amp;gt;进行剥离，结果将为空字符串；如果使用负号&amp;lt;N&amp;gt;进行剥离，则结果将为完整的refname。都不是错误。</target>
        </trans-unit>
        <trans-unit id="d3667dc69f3d60260150d30873ae903291e9c610" translate="yes" xml:space="preserve">
          <source>The name of the remote ref being fetched from, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix. In the case of deletion, the name of the remote ref is &quot;(none)&quot;.</source>
          <target state="translated">从中获取远程引用的名称，减去其 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 前缀。在删除的情况下，远程引用的名称为&amp;ldquo;（无）&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f1e1380262032f81dbdd04e4a724dd0dac2f66a0" translate="yes" xml:space="preserve">
          <source>The name of the remote ref being updated, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix.</source>
          <target state="translated">要更新的远程引用的名称，减去其 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="4541cb8cb079b50ad15e3d46e62cd66b37316e42" translate="yes" xml:space="preserve">
          <source>The name of the remote to create when cloning a repository. Defaults to &lt;code&gt;origin&lt;/code&gt;, and can be overridden by passing the &lt;code&gt;--origin&lt;/code&gt; command-line option to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1208454bdf4c7c5a0ab602103e6dd838ca212a" translate="yes" xml:space="preserve">
          <source>The name of the repository in gitweb is the path to its &lt;code&gt;$GIT_DIR&lt;/code&gt; (its object database) relative to &lt;code&gt;$projectroot&lt;/code&gt;. Therefore the repository $repo can be found at &quot;$projectroot/$repo&quot;.</source>
          <target state="translated">gitweb中存储库的名称是其相对于 &lt;code&gt;$projectroot&lt;/code&gt; &lt;code&gt;$GIT_DIR&lt;/code&gt; （其对象数据库）的路径。因此，可以在&amp;ldquo; $ projectroot / $ repo&amp;rdquo;中找到存储库$ repo。</target>
        </trans-unit>
        <trans-unit id="1b6cc45302b6351d18e813818cde0845c0a5a22a" translate="yes" xml:space="preserve">
          <source>The name of the tag to create, delete, or describe. The new tag name must pass all checks defined by &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format[1]&lt;/a&gt;. Some of these checks may restrict the characters allowed in a tag name.</source>
          <target state="translated">要创建，删除或描述的标签的名称。新标签名称必须通过&lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format [1]&lt;/a&gt;定义的所有检查。其中一些检查可能会限制标签名称中允许的字符。</target>
        </trans-unit>
        <trans-unit id="964fd80a7ebc3b646125e059ac3c7f8c3a22061f" translate="yes" xml:space="preserve">
          <source>The named branches will be interpreted as if specified with the &lt;code&gt;-t&lt;/code&gt; option on the &lt;code&gt;git remote add&lt;/code&gt; command line.</source>
          <target state="translated">命名分支将被解释为与 &lt;code&gt;git remote add&lt;/code&gt; 命令行上的 &lt;code&gt;-t&lt;/code&gt; 选项指定的一样。</target>
        </trans-unit>
        <trans-unit id="a7226417649eb7c8f42ca4934a290033c08aad1c" translate="yes" xml:space="preserve">
          <source>The names of objects to show (defaults to &lt;code&gt;HEAD&lt;/code&gt;). For a more complete list of ways to spell object names, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">要显示的对象名称（默认为 &lt;code&gt;HEAD&lt;/code&gt; ）。有关拼写对象名称的方法的完整列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]中的&lt;/a&gt; &amp;ldquo;指定修订版&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="df439b2df93c9264d2652e8aa379f62f3b6ab5ac" translate="yes" xml:space="preserve">
          <source>The names of refs that are fetched, together with the object names they point at, are written to &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt;. This information may be used by scripts or other git commands, such as &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">获取的ref的名称以及它们指向的对象名称将写入 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 。脚本或其他git命令（例如&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]）&lt;/a&gt;可以使用此信息。</target>
        </trans-unit>
        <trans-unit id="1b9c4b549f992b26edb42d00411780a65661d81d" translate="yes" xml:space="preserve">
          <source>The native transport (i.e. git:// URL) does no authentication and should be used with caution on unsecured networks.</source>
          <target state="translated">本机传输(i.e.git://URL)不进行身份验证,在不安全的网络上应谨慎使用。</target>
        </trans-unit>
        <trans-unit id="86d32cda4c46d201605240981feec896fb3daceb" translate="yes" xml:space="preserve">
          <source>The new branch head will point to this commit. It may be given as a branch name, a commit-id, or a tag. If this option is omitted, the current HEAD will be used instead.</source>
          <target state="translated">新的分支头将指向这个提交。它可以是一个分支名,一个提交id,或者一个标签。如果省略了这个选项,则会使用当前的头。</target>
        </trans-unit>
        <trans-unit id="597e47a48a8bd8b3528838dd5cebedeb7b241f60" translate="yes" xml:space="preserve">
          <source>The new name for an existing branch. The same restrictions as for &amp;lt;branchname&amp;gt; apply.</source>
          <target state="translated">现有分支的新名称。适用与&amp;lt;分支名称&amp;gt;相同的限制。</target>
        </trans-unit>
        <trans-unit id="05a068e20a6ba11ea4fd1dbaef65a93e78041978" translate="yes" xml:space="preserve">
          <source>The new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade318097a09c67b5bdaa6c1344cf2a281d7cac8" translate="yes" xml:space="preserve">
          <source>The next parameter is the pattern. This option has to be used for patterns starting with &lt;code&gt;-&lt;/code&gt; and should be used in scripts passing user input to grep. Multiple patterns are combined by &lt;code&gt;or&lt;/code&gt;.</source>
          <target state="translated">下一个参数是模式。此选项必须用于以 &lt;code&gt;-&lt;/code&gt; 开头的模式，并且应在将用户输入传递给grep的脚本中使用。 &lt;code&gt;or&lt;/code&gt; 组合多个模式。</target>
        </trans-unit>
        <trans-unit id="00f28e3b882b5553d45ceeb08082d3dcda522dd0" translate="yes" xml:space="preserve">
          <source>The next step of merging is to merge these three versions of the file, using 3-way merge. This is done by giving &lt;code&gt;git merge-one-file&lt;/code&gt; command as one of the arguments to &lt;code&gt;git merge-index&lt;/code&gt; command:</source>
          <target state="translated">合并的下一步是使用3向合并来合并文件的这三个版本。这是通过给 &lt;code&gt;git merge-one-file&lt;/code&gt; 命令作为 &lt;code&gt;git merge-index&lt;/code&gt; 命令的参数之一来完成的：</target>
        </trans-unit>
        <trans-unit id="c203649e7405cacf1f66f3229b4d864ccf1b5f34" translate="yes" xml:space="preserve">
          <source>The nonce string the process asked the signer to include in the push certificate. If this does not match the value recorded on the &quot;nonce&quot; header in the push certificate, it may indicate that the certificate is a valid one that is being replayed from a separate &quot;git push&quot; session.</source>
          <target state="translated">进程要求签名者在推送证书中包含的 nonce 字符串。如果这个字符串与推送证书中的 &quot;nonce &quot;头记录的值不一致,则可能表明证书是一个有效的证书,正在从一个单独的 &quot;git push &quot;会话中重放。</target>
        </trans-unit>
        <trans-unit id="a81eae6f204563324e9f0299e6e5a18af11339c2" translate="yes" xml:space="preserve">
          <source>The normal format target is a tradition printf format and similar to GIT_TRACE format. This format is enabled with the &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variable or the &lt;code&gt;trace2.normalTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">普通格式的目标是传统的printf格式，与GIT_TRACE格式相似。此格式通过 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 环境变量或 &lt;code&gt;trace2.normalTarget&lt;/code&gt; 系统或全局配置设置启用。</target>
        </trans-unit>
        <trans-unit id="08867837836724d3f4c3cfbd7d03fa5d964eec62" translate="yes" xml:space="preserve">
          <source>The number of additional commits is the number of commits which would be displayed by &quot;git log v1.0.4..parent&quot;. The hash suffix is &quot;-g&quot; + unambiguous abbreviation for the tip commit of parent (which was &lt;code&gt;2414721b194453f058079d897d13c4e377f92dc6&lt;/code&gt;). The &quot;g&quot; prefix stands for &quot;git&quot; and is used to allow describing the version of a software depending on the SCM the software is managed with. This is useful in an environment where people may use different SCMs.</source>
          <target state="translated">附加提交数是&amp;ldquo; git log v1.0.4..parent&amp;rdquo;将显示的提交数。哈希后缀是&amp;ldquo; -g&amp;rdquo; +父代技巧提交的明确缩写（即 &lt;code&gt;2414721b194453f058079d897d13c4e377f92dc6&lt;/code&gt; ）。&amp;ldquo; g&amp;rdquo;前缀代表&amp;ldquo; git&amp;rdquo;，用于根据管理软件的SCM来描述软件的版本。这在人们可能使用不同SCM的环境中很有用。</target>
        </trans-unit>
        <trans-unit id="83386653d6009935020ea78a4c28a793cc5fa198" translate="yes" xml:space="preserve">
          <source>The number of curl sessions (counted across slots) to be kept across requests. They will not be ended with curl_easy_cleanup() until http_cleanup() is invoked. If USE_CURL_MULTI is not defined, this value will be capped at 1. Defaults to 1.</source>
          <target state="translated">在不同的请求中要保留的curl会话的数量(按槽数计算),在http_cleanup()被调用之前,这些会话不会被curl_easy_cleanup()结束。在调用 http_cleanup()之前,它们不会被 curl_easy_cleanup()结束。如果没有定义 USE_CURL_MULTI,这个值的上限是 1,默认为 1。</target>
        </trans-unit>
        <trans-unit id="eb593ed0188a165abaa2fc9b58825ac993fcfa11" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing rename detection during a merge; if not specified, defaults to the value of diff.renameLimit. This setting has no effect if rename detection is turned off.</source>
          <target state="translated">合并过程中执行重命名检测时要考虑的文件数量;如果没有指定,默认为 diff.renameLimit 的值。如果关闭了重命名检测,则此设置没有任何影响;如果没有指定,默认为diff.renameLimit的值。</target>
        </trans-unit>
        <trans-unit id="b49ca7e6ecad75b8cf0b0ec3dcf469e017a13140" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing rename detection in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;. Defaults to the value of diff.renameLimit.</source>
          <target state="translated">在&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;和&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]中&lt;/a&gt;执行重命名检测时要考虑的文件数。默认为diff.renameLimit的值。</target>
        </trans-unit>
        <trans-unit id="62caddb975571c60931b3e5e41910f9ec3dfea6e" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing the copy/rename detection; equivalent to the &lt;code&gt;git diff&lt;/code&gt; option &lt;code&gt;-l&lt;/code&gt;. This setting has no effect if rename detection is turned off.</source>
          <target state="translated">执行复制/重命名检测时要考虑的文件数；等效于 &lt;code&gt;git diff&lt;/code&gt; 选项 &lt;code&gt;-l&lt;/code&gt; 。如果关闭重命名检测，此设置无效。</target>
        </trans-unit>
        <trans-unit id="f40a726880d5eda55c8da498a0add02c8ea2a7b1" translate="yes" xml:space="preserve">
          <source>The number of push options given on the command line of &lt;code&gt;git push --push-option=...&lt;/code&gt; can be read from the environment variable &lt;code&gt;GIT_PUSH_OPTION_COUNT&lt;/code&gt;, and the options themselves are found in &lt;code&gt;GIT_PUSH_OPTION_0&lt;/code&gt;, &lt;code&gt;GIT_PUSH_OPTION_1&lt;/code&gt;,&amp;hellip;​ If it is negotiated to not use the push options phase, the environment variables will not be set. If the client selects to use push options, but doesn&amp;rsquo;t transmit any, the count variable will be set to zero, &lt;code&gt;GIT_PUSH_OPTION_COUNT=0&lt;/code&gt;.</source>
          <target state="translated">可以从环境变量 &lt;code&gt;GIT_PUSH_OPTION_COUNT&lt;/code&gt; 读取 &lt;code&gt;git push --push-option=...&lt;/code&gt; 命令行上给定的push选项数量，这些选项本身可以在 &lt;code&gt;GIT_PUSH_OPTION_0&lt;/code&gt; ， &lt;code&gt;GIT_PUSH_OPTION_1&lt;/code&gt; 中找到，...使用push选项阶段时，将不会设置环境变量。如果客户端选择使用推送选项，但不发送任何推送选项，则count变量将设置为零，即 &lt;code&gt;GIT_PUSH_OPTION_COUNT=0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5ad10bd3ab58adc794f2122271c46d58529bef4" translate="yes" xml:space="preserve">
          <source>The number of spaces between columns. One space by default.</source>
          <target state="translated">列间的空格数。默认为一个空格。</target>
        </trans-unit>
        <trans-unit id="911462b0802b22317c5a57a0a0510dbf0c397a66" translate="yes" xml:space="preserve">
          <source>The number of submodules fetched at the same time. Defaults to the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; option.</source>
          <target state="translated">同时获取的子模块数。默认为 &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="34de3b8749bfae0c14ff8d34783f05c9920748b5" translate="yes" xml:space="preserve">
          <source>The object can be a blob or a submodule commit. It implies the &lt;code&gt;-t&lt;/code&gt; option in &lt;code&gt;git-log&lt;/code&gt; to also find trees.</source>
          <target state="translated">该对象可以是Blob或子模块提交。这意味着 &lt;code&gt;git-log&lt;/code&gt; 中的 &lt;code&gt;-t&lt;/code&gt; 选项也可以找到树。</target>
        </trans-unit>
        <trans-unit id="2794f5933199b4937a09c41b8d049f6b88620c25" translate="yes" xml:space="preserve">
          <source>The object database contains objects of three main types: blobs, which hold file data; trees, which point to blobs and other trees to build up directory hierarchies; and commits, which each reference a single tree and some number of parent commits.</source>
          <target state="translated">对象数据库包含三种主要类型的对象:blobs,存放文件数据;tree,指向blobs和其他树,以建立目录层次结构;commits,每个commits引用一棵树和一些父commits。</target>
        </trans-unit>
        <trans-unit id="b5ea163b65a2243d9fc238d7c50700c517adc350" translate="yes" xml:space="preserve">
          <source>The object database is the rather elegant system used to store the history of your project&amp;mdash;​files, directories, and commits.</source>
          <target state="translated">对象数据库是一个非常优雅的系统，用于存储项目的历史记录-文件，目录和提交。</target>
        </trans-unit>
        <trans-unit id="db080c7937810b605e4381605a2e18077b89e3c0" translate="yes" xml:space="preserve">
          <source>The object name (aka SHA-1). For a non-ambiguous abbreviation of the object name append &lt;code&gt;:short&lt;/code&gt;. For an abbreviation of the object name with desired length append &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt;, where the minimum length is MINIMUM_ABBREV. The length may be exceeded to ensure unique object names.</source>
          <target state="translated">对象名称（又名SHA-1）。对于对象名称的明确缩写，请附加 &lt;code&gt;:short&lt;/code&gt; 。对于具有所需长度的对象名称的缩写，请附加 &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt; ，其中最小长度为MINIMUM_ABBREV。可以超过该长度以确保唯一的对象名称。</target>
        </trans-unit>
        <trans-unit id="b335d1a75376848bee9affb50a6203b316fcc02d" translate="yes" xml:space="preserve">
          <source>The object referenced by &amp;lt;src&amp;gt; is used to update the &amp;lt;dst&amp;gt; reference on the remote side. Whether this is allowed depends on where in &lt;code&gt;refs/*&lt;/code&gt; the &amp;lt;dst&amp;gt; reference lives as described in detail below, in those sections &quot;update&quot; means any modifications except deletes, which as noted after the next few sections are treated differently.</source>
          <target state="translated">&amp;lt;src&amp;gt;引用的对象用于更新远程端的&amp;lt;dst&amp;gt;引用。是否允许这样做取决于 &lt;code&gt;refs/*&lt;/code&gt; 中&amp;lt;dst&amp;gt;引用的位置，如以下详细所述，在那些部分中，&amp;ldquo;更新&amp;rdquo;表示除删除外的任何修改，这在接下来的几节中将作不同处理。</target>
        </trans-unit>
        <trans-unit id="afdbad7acf93ca3457880eb431fd58ab07141e11" translate="yes" xml:space="preserve">
          <source>The object table is actually a hashtable keyed on the object name (the unique SHA-1). This storage configuration allows fast-import to reuse an existing or already written object and avoid writing duplicates to the output packfile. Duplicate blobs are surprisingly common in an import, typically due to branch merges in the source.</source>
          <target state="translated">对象表实际上是一个以对象名称(唯一的SHA-1)为键的哈希特表。这种存储配置允许快速导入重用现有的或已经写好的对象,并避免将重复的对象写入输出包文件。重复的 blobs 在导入中是非常常见的,通常是由于源文件中的分支合并。</target>
        </trans-unit>
        <trans-unit id="0b16e9c4d73790474d293fcd4d96547c235d7d1f" translate="yes" xml:space="preserve">
          <source>The object that the new tag will refer to, usually a commit. Defaults to HEAD.</source>
          <target state="translated">新标签将引用的对象,通常是一个提交。默认为 HEAD。</target>
        </trans-unit>
        <trans-unit id="5468420c6f62137502c6bb00574138b237765047" translate="yes" xml:space="preserve">
          <source>The object type may be a blob, representing the contents of a file, or another tree, representing the contents of a subdirectory. Since trees and blobs, like all other objects, are named by the SHA-1 hash of their contents, two trees have the same SHA-1 name if and only if their contents (including, recursively, the contents of all subdirectories) are identical. This allows Git to quickly determine the differences between two related tree objects, since it can ignore any entries with identical object names.</source>
          <target state="translated">对象类型可以是代表文件内容的blob,也可以是代表子目录内容的树。因为树和blob和其他对象一样,都是用内容的SHA-1哈希值来命名的,所以只有当两个树的内容(包括递归的所有子目录的内容)相同时,它们的SHA-1名称才会相同。这使得Git可以快速确定两个相关树对象之间的差异,因为它可以忽略任何具有相同对象名的条目。</target>
        </trans-unit>
        <trans-unit id="abf9c48e6cb6157bcc4ecdd7fbfd1167ee2a4bc5" translate="yes" xml:space="preserve">
          <source>The object types in some more detail:</source>
          <target state="translated">对象类型更详细一些。</target>
        </trans-unit>
        <trans-unit id="1aa11fdf087f0d8d0d32eb67b923b0efa29ecf46" translate="yes" xml:space="preserve">
          <source>The objects are output in the order in which they are found in the index file, which should be (in a correctly constructed file) sorted by object id.</source>
          <target state="translated">对象是按照它们在索引文件中找到的顺序输出的,索引文件应该(在一个正确构造的文件中)按对象id排序。</target>
        </trans-unit>
        <trans-unit id="113c9617d3615ff46d1de3788621403d384bc970" translate="yes" xml:space="preserve">
          <source>The official repository of the &lt;code&gt;git gui&lt;/code&gt; project can be found at:</source>
          <target state="translated">&lt;code&gt;git gui&lt;/code&gt; 项目的官方存储库位于：</target>
        </trans-unit>
        <trans-unit id="d2925f4342d92a06228b4eeddfbffd0ada540f91" translate="yes" xml:space="preserve">
          <source>The one commit in this list that is not related to CMake may very well have been motivated by working on fixing all those bugs introduced by switching to CMake, but it addresses a different concern. To split this branch into two topic branches, the todo list could be edited like this:</source>
          <target state="translated">这个列表中与 CMake 无关的一个提交,很可能是为了修复切换到 CMake 后引入的所有错误,但它解决的是不同的问题。要把这个分支分成两个主题分支,可以这样编辑todo列表。</target>
        </trans-unit>
        <trans-unit id="680930999bd0e3bf9880124c135a89bca3a329f3" translate="yes" xml:space="preserve">
          <source>The oneline descriptions are purely for your pleasure; &lt;code&gt;git rebase&lt;/code&gt; will not look at them but at the commit names (&quot;deadbee&quot; and &quot;fa1afe1&quot; in this example), so do not delete or edit the names.</source>
          <target state="translated">单行描述纯粹是为了您的愉悦； &lt;code&gt;git rebase&lt;/code&gt; 不会查看它们，而是查看提交名称（在此示例中为&amp;ldquo; deadbee&amp;rdquo;和&amp;ldquo; fa1afe1&amp;rdquo;），因此请勿删除或编辑名称。</target>
        </trans-unit>
        <trans-unit id="b174b5f513a45da66bee660cec63368b38af2a1f" translate="yes" xml:space="preserve">
          <source>The only difference between this command and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; is that they use slightly different output formats, and this command exists only for backward compatibility to support existing scripts, and provide a more familiar command name for people coming from other SCM systems.</source>
          <target state="translated">此命令和&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;之间的唯一区别是，它们使用略有不同的输出格式，并且此命令仅存在用于向后兼容以支持现有脚本，并且为来自其他SCM系统的人提供了更熟悉的命令名称。</target>
        </trans-unit>
        <trans-unit id="82fa629da6adc18439c1d9295d8f644e8391fd9b" translate="yes" xml:space="preserve">
          <source>The only safe place to make these changes is on the remote repository (i.e., the Git server), usually in the &lt;code&gt;pre-receive&lt;/code&gt; hook or in a continuous integration (CI) system. These are the locations in which policy can be enforced effectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90482aceb580582ec33d188b8fb1bca29f8136a1" translate="yes" xml:space="preserve">
          <source>The option can have the following values, defaulting to &lt;code&gt;group&lt;/code&gt; if no value is given:</source>
          <target state="translated">该选项可以具有以下值，如果没有给出值，则默认为 &lt;code&gt;group&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="72a352b7174eb63582b749d1295b267e0dae9887" translate="yes" xml:space="preserve">
          <source>The optional &amp;lt;limit&amp;gt; is useful in cases where your topic is based on other work that is not in upstream. Expanding on the previous example, this might look like:</source>
          <target state="translated">可选的&amp;lt;limit&amp;gt;在主题基于上游以外的其他工作的情况下很有用。在前面的示例上进行扩展，可能类似于：</target>
        </trans-unit>
        <trans-unit id="4136e1c0c625091f77db10ec0b76e55e39fdb1b6" translate="yes" xml:space="preserve">
          <source>The optional &amp;lt;style&amp;gt; argument can be either &lt;code&gt;shallow&lt;/code&gt; or &lt;code&gt;deep&lt;/code&gt;. &lt;code&gt;shallow&lt;/code&gt; threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the &lt;code&gt;--in-reply-to&lt;/code&gt;, and the first patch mail, in this order. &lt;code&gt;deep&lt;/code&gt; threading makes every mail a reply to the previous one.</source>
          <target state="translated">可选的&amp;lt;style&amp;gt;参数可以是 &lt;code&gt;shallow&lt;/code&gt; 或 &lt;code&gt;deep&lt;/code&gt; 。 &lt;code&gt;shallow&lt;/code&gt; 线程使每个邮件都回复到该系列的 &lt;code&gt;--in-reply-to&lt;/code&gt; ，该标题是从求职信，-in-reply-to和第一个补丁邮件中按此顺序选择的。 &lt;code&gt;deep&lt;/code&gt; 线程使每封邮件都回复上一封邮件。</target>
        </trans-unit>
        <trans-unit id="3dd98bdacd886ba292b303baaba2ecefebed8bab" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;encoding&lt;/code&gt; command indicates the encoding of the commit message. Most commits are UTF-8 and the encoding is omitted, but this allows importing commit messages into git without first reencoding them.</source>
          <target state="translated">可选的 &lt;code&gt;encoding&lt;/code&gt; 命令指示提交消息的编码。大多数提交都是UTF-8，并且省略了编码，但这允许将提交消息导入git，而无需先对其进行重新编码。</target>
        </trans-unit>
        <trans-unit id="f1f596d4ea27770161ef3ea6df226eac8321e34f" translate="yes" xml:space="preserve">
          <source>The optional GPG signature of the tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ae75c1b10bf71d7e20ef9926e29585fa74a2e0" translate="yes" xml:space="preserve">
          <source>The optional argument &amp;lt;path&amp;gt; is the relative location for the cloned submodule to exist in the superproject. If &amp;lt;path&amp;gt; is not given, the canonical part of the source repository is used (&quot;repo&quot; for &quot;/path/to/repo.git&quot; and &quot;foo&quot; for &quot;host.xz:foo/.git&quot;). If &amp;lt;path&amp;gt; exists and is already a valid Git repository, then it is staged for commit without cloning. The &amp;lt;path&amp;gt; is also used as the submodule&amp;rsquo;s logical name in its configuration entries unless &lt;code&gt;--name&lt;/code&gt; is used to specify a logical name.</source>
          <target state="translated">可选参数&amp;lt;path&amp;gt;是在超级项目中存在的克隆子模块的相对位置。如果未给出&amp;lt;path&amp;gt;，则使用源存储库的规范部分（&amp;ldquo; repo&amp;rdquo;表示&amp;ldquo; /path/to/repo.git&amp;rdquo;，&amp;ldquo;foo&amp;rdquo;表示&amp;ldquo; host.xz：foo / .git&amp;rdquo;）。如果&amp;lt;path&amp;gt;存在并且已经是有效的Git存储库，则将其暂存以进行提交而无需克隆。 &amp;lt;path&amp;gt;在其配置条目中也用作子模块的逻辑名，除非 &lt;code&gt;--name&lt;/code&gt; 用于指定逻辑名。</target>
        </trans-unit>
        <trans-unit id="476c5c2c4870d6be72c4d31b42e1450136c51807" translate="yes" xml:space="preserve">
          <source>The optional configuration variable &lt;code&gt;core.excludesFile&lt;/code&gt; indicates a path to a file containing patterns of file names to exclude, similar to &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;. Patterns in the exclude file are used in addition to those in &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;.</source>
          <target state="translated">可选配置变量 &lt;code&gt;core.excludesFile&lt;/code&gt; 指示文件的路径，该路径包含要排除的文件名模式，类似于 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 。除了 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 模式以外，还使用排除文件中的模式。</target>
        </trans-unit>
        <trans-unit id="ad80c43bd988ae6e6061dfab8a056d2afaee7691" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;--contains&lt;/code&gt;, &lt;code&gt;--no-contains&lt;/code&gt;, &lt;code&gt;--merged&lt;/code&gt; and &lt;code&gt;--no-merged&lt;/code&gt; serve four related but different purposes:</source>
          <target state="translated">选项 &lt;code&gt;--contains&lt;/code&gt; ， &lt;code&gt;--no-contains&lt;/code&gt; ， &lt;code&gt;--merged&lt;/code&gt; 和 &lt;code&gt;--no-merged&lt;/code&gt; 成为四大关，但不同的目的：</target>
        </trans-unit>
        <trans-unit id="081a3bdc8213b4774c97cebf32978af69c3476cb" translate="yes" xml:space="preserve">
          <source>The order of stages 1, 2 and 3 (hence the order of three &amp;lt;tree-ish&amp;gt; command-line arguments) are significant when you start a 3-way merge with an index file that is already populated. Here is an outline of how the algorithm works:</source>
          <target state="translated">当您开始使用已填充的索引文件进行三向合并时，阶段1、2和3的顺序（因此三个&amp;lt;tree-ish&amp;gt;命令行参数的顺序）很重要。这是算法工作原理的概述：</target>
        </trans-unit>
        <trans-unit id="3fb57cf5101f783ba73fc6eba17ed42ef2940627" translate="yes" xml:space="preserve">
          <source>The order of the flags used to matter, but not anymore.</source>
          <target state="translated">过去旗帜的顺序很重要,但现在不一样了。</target>
        </trans-unit>
        <trans-unit id="32a54a6aa8ff67e3d76c47c6fabd2affc1e5cbb5" translate="yes" xml:space="preserve">
          <source>The origin of lines is automatically followed across whole-file renames (currently there is no option to turn the rename-following off). To follow lines moved from one file to another, or to follow lines that were copied and pasted from another file, etc., see the &lt;code&gt;-C&lt;/code&gt; and &lt;code&gt;-M&lt;/code&gt; options.</source>
          <target state="translated">整个文件重命名会自动跟随行的起点（当前没有选项可以关闭重命名跟随）。要跟随从一个文件移动到另一个文件的行，或者跟随从另一个文件复制和粘贴的行，等等，请参见 &lt;code&gt;-C&lt;/code&gt; 和 &lt;code&gt;-M&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="b66619a4ae8f145d6aac4431781b08d6ac86597a" translate="yes" xml:space="preserve">
          <source>The origin revision can be changed with the &quot;--origin&quot; option.</source>
          <target state="translated">可以用&quot;--origin &quot;选项来改变原始版本。</target>
        </trans-unit>
        <trans-unit id="617fe8d1d55cfe9ccc09f76fcfa190410b239da3" translate="yes" xml:space="preserve">
          <source>The original format used by Greg Kroah-Hartman&amp;rsquo;s &lt;code&gt;send_lots_of_email.pl&lt;/code&gt; script</source>
          <target state="translated">Greg Kroah-Hartman的 &lt;code&gt;send_lots_of_email.pl&lt;/code&gt; 脚本使用的原始格式</target>
        </trans-unit>
        <trans-unit id="a7a5cdcdcd4d6fcaaf02e53acebd8443c9b015da" translate="yes" xml:space="preserve">
          <source>The original job of &lt;code&gt;git rev-parse&lt;/code&gt; is now taken by the function &lt;code&gt;setup_revisions()&lt;/code&gt;, which parses the revisions and the common command-line options for the revision walker. This information is stored in the struct &lt;code&gt;rev_info&lt;/code&gt; for later consumption. You can do your own command-line option parsing after calling &lt;code&gt;setup_revisions()&lt;/code&gt;. After that, you have to call &lt;code&gt;prepare_revision_walk()&lt;/code&gt; for initialization, and then you can get the commits one by one with the function &lt;code&gt;get_revision()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git rev-parse&lt;/code&gt; 的原始工作现在由 &lt;code&gt;setup_revisions()&lt;/code&gt; 函数承担，该函数解析修订和修订行者的常用命令行选项。此信息存储在struct &lt;code&gt;rev_info&lt;/code&gt; 中,以供以后使用。您可以在调用 &lt;code&gt;setup_revisions()&lt;/code&gt; 之后执行自己的命令行选项解析。之后，您必须调用 &lt;code&gt;prepare_revision_walk()&lt;/code&gt; 进行初始化，然后可以使用 &lt;code&gt;get_revision()&lt;/code&gt; 函数一个接一个地提交提交。</target>
        </trans-unit>
        <trans-unit id="4c9da327e28b59015cec84abd98a33aec635328d" translate="yes" xml:space="preserve">
          <source>The original tags are not deleted, but can be overwritten; use &quot;--tag-name-filter cat&quot; to simply update the tags. In this case, be very careful and make sure you have the old tags backed up in case the conversion has run afoul.</source>
          <target state="translated">原来的标签不会被删除,但可以被覆盖;使用&quot;--tag-name-filter cat &quot;来简单地更新标签。在这种情况下,要非常小心,并确保你有旧的标签备份,以防转换过程中出现问题。</target>
        </trans-unit>
        <trans-unit id="6c2cf73d4477ea65ac2368f08dedbcc07c9eafb4" translate="yes" xml:space="preserve">
          <source>The other nice thing with test suites, is that when you have one, you already know how to test for bad behavior. So you can use this knowledge to create a new test case for &quot;git bisect&quot; when it appears that there is a regression. So it will be easier to bisect the bug and fix it. And then you can add the test case you just created to your test suite.</source>
          <target state="translated">测试套件的另一个好处是,当你有一个测试套件时,你已经知道如何测试不良行为。因此,当出现回归时,你可以使用这些知识为 &quot;git bisect &quot;创建一个新的测试用例。这样就可以更容易地将bug一分为二,并修复它。然后你就可以把刚才创建的测试用例添加到你的测试套件中。</target>
        </trans-unit>
        <trans-unit id="94bda500b4b5c47f0218909469e6ab7f1eee52b6" translate="yes" xml:space="preserve">
          <source>The other way to drive the bisection process is to tell &quot;git bisect&quot; to launch a script or command at each bisection step to know if the current commit is &quot;good&quot; or &quot;bad&quot;. To do that, we use the &quot;git bisect run&quot; command. For example:</source>
          <target state="translated">另一种方法是让 &quot;git bisect &quot;在每一个分离步骤中启动一个脚本或命令,以了解当前的提交是 &quot;好 &quot;还是 &quot;坏&quot;。为此,我们使用 &quot;git bisect run &quot;命令。例如:&quot;git bisect run &quot;命令</target>
        </trans-unit>
        <trans-unit id="013b9f528101f55f667633859403afae697697c4" translate="yes" xml:space="preserve">
          <source>The output format is modified to be machine-parsable (see below). If &lt;code&gt;--stdin&lt;/code&gt; is also given, input paths are separated with a NUL character instead of a linefeed character.</source>
          <target state="translated">将输出格式修改为机器可解析的（请参见下文）。如果还给出了 &lt;code&gt;--stdin&lt;/code&gt; ，则输入路径用NUL字符而不是换行符分隔。</target>
        </trans-unit>
        <trans-unit id="4ebdc78d172a0b82e38a898aa2ae716344def4d5" translate="yes" xml:space="preserve">
          <source>The output format is modified to be machine-parsable. If &lt;code&gt;--stdin&lt;/code&gt; is also given, input paths are separated with a NUL character instead of a linefeed character.</source>
          <target state="translated">将输出格式修改为机器可解析的。如果还给出了 &lt;code&gt;--stdin&lt;/code&gt; ，则输入路径用NUL字符而不是换行符分隔。</target>
        </trans-unit>
        <trans-unit id="885a3d9b027501a3f7ddd2554d827f984cacfcf5" translate="yes" xml:space="preserve">
          <source>The output format is similar to the Porcelain format, but it does not contain the actual lines from the file that is being annotated.</source>
          <target state="translated">输出格式与Porcelain格式类似,但它不包含被注释的文件的实际行数。</target>
        </trans-unit>
        <trans-unit id="16ca2e6d144e9c4d47f91cfe57ded6c4b6f874af" translate="yes" xml:space="preserve">
          <source>The output from this command is designed to be used as a commit template comment. The default, long format, is designed to be human readable, verbose and descriptive. Its contents and format are subject to change at any time.</source>
          <target state="translated">该命令的输出是用来作为提交模板的注释。默认的长格式是为了让人能够读懂,并具有详细的描述性。其内容和格式可能会随时改变。</target>
        </trans-unit>
        <trans-unit id="467b04ab4f0f42e5eb4db50995625d7a06a04bbc" translate="yes" xml:space="preserve">
          <source>The output is in the format: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;reference name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">输出的格式为： &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;reference name&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="297e105083265b9b5df9c784faa30006468bc5fd" translate="yes" xml:space="preserve">
          <source>The output is of the form: &amp;lt;path&amp;gt; COLON SP &amp;lt;attribute&amp;gt; COLON SP &amp;lt;info&amp;gt; LF</source>
          <target state="translated">输出的形式为：&amp;lt;path&amp;gt; COLON SP &amp;lt;attribute&amp;gt; COLON SP &amp;lt;info&amp;gt; LF</target>
        </trans-unit>
        <trans-unit id="00d47eecfb8e7c432b9a2a4461da0aa0b0a14445" translate="yes" xml:space="preserve">
          <source>The output is the new tag&amp;rsquo;s &amp;lt;object&amp;gt; identifier.</source>
          <target state="translated">输出是新标签的&amp;lt;object&amp;gt;标识符。</target>
        </trans-unit>
        <trans-unit id="c209f5f99a30592095be06f60778bfc6143218e8" translate="yes" xml:space="preserve">
          <source>The output of &quot;git fetch&quot; depends on the transport method used; this section describes the output when fetching over the Git protocol (either locally or via ssh) and Smart HTTP protocol.</source>
          <target state="translated">&quot;git fetch &quot;的输出取决于所使用的传输方式,本节将介绍通过Git协议(本地或通过ssh)和智能HTTP协议进行获取时的输出。</target>
        </trans-unit>
        <trans-unit id="249df455a76d6d8a4ee813f24ba8c68836888f67" translate="yes" xml:space="preserve">
          <source>The output of &quot;git push&quot; depends on the transport method used; this section describes the output when pushing over the Git protocol (either locally or via ssh).</source>
          <target state="translated">git push &quot;的输出取决于所使用的传输方式,本节将介绍通过 Git 协议(本地或通过 ssh)推送时的输出。</target>
        </trans-unit>
        <trans-unit id="2012a50a7ce95c41c81b087cc42352c50e07741b" translate="yes" xml:space="preserve">
          <source>The output of ls-refs is as follows:</source>
          <target state="translated">ls-refs的输出如下。</target>
        </trans-unit>
        <trans-unit id="c9897264787fe814346af61567793268dae2ec95" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;range-diff&lt;/code&gt; command is subject to change. It is intended to be human-readable porcelain output, not something that can be used across versions of Git to get a textually stable &lt;code&gt;range-diff&lt;/code&gt; (as opposed to something like the &lt;code&gt;--stable&lt;/code&gt; option to &lt;a href=&quot;git-patch-id&quot;&gt;git-patch-id[1]&lt;/a&gt;). There&amp;rsquo;s also no equivalent of &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt; for &lt;code&gt;range-diff&lt;/code&gt;, the output is not intended to be machine-readable.</source>
          <target state="translated">&lt;code&gt;range-diff&lt;/code&gt; 命令的输出可能会发生变化。它打算用作人类可读的瓷器输出，而不是可以在Git的各个版本中使用的东西，以获得文本上稳定的 &lt;code&gt;range-diff&lt;/code&gt; （与&lt;a href=&quot;git-patch-id&quot;&gt;git-patch-id [1]&lt;/a&gt;的 &lt;code&gt;--stable&lt;/code&gt; 选项类似的东西相反） 。还有没有等价的&lt;a href=&quot;git-apply&quot;&gt;GIT-应用[1]&lt;/a&gt;用于 &lt;code&gt;range-diff&lt;/code&gt; ，输出不旨在是机器可读的。</target>
        </trans-unit>
        <trans-unit id="acccdb81223db3ebfe60a727e12d9a4ed87719fe" translate="yes" xml:space="preserve">
          <source>The output order is determined by the order of glob patterns in &amp;lt;orderfile&amp;gt;. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.</source>
          <target state="translated">输出顺序由&amp;lt;orderfile&amp;gt;中的glob模式的顺序确定。路径名与第一个模式匹配的所有文件都将首先输出，路径名与第二个模式（但不是第一个模式）相匹配的所有文件都将被输出，依此类推。路径名与任何模式都不匹配的所有文件最后输出，就好像文件末尾有一个隐式的全部匹配模式。如果多个路径名具有相同的等级（它们匹配相同的模式，但没有更早的模式），则它们相对于彼此的输出顺序是正常顺序。</target>
        </trans-unit>
        <trans-unit id="70ec2e58d64c53608a589a3f892a41e430e23c0e" translate="yes" xml:space="preserve">
          <source>The overall time needed to compute this algorithm is the time needed to compute n+m commit diffs and then n*m diffs of patches, plus the time needed to compute the least-cost assignment between n and m diffs. Git uses an implementation of the Jonker-Volgenant algorithm to solve the assignment problem, which has cubic runtime complexity. The matching found in this case will look like this:</source>
          <target state="translated">计算这个算法所需的总体时间是计算n+m个commit diffs,然后计算n*m个patch diffs所需的时间,再加上计算n和m个 diffs之间的最小成本分配所需的时间。Git使用Jonker-Volgenant算法的实现来解决分配问题,该算法的运行复杂度为立方。在这种情况下找到的匹配会是这样的。</target>
        </trans-unit>
        <trans-unit id="f8c05a901b25f6434301621f82a267dcb0caae54" translate="yes" xml:space="preserve">
          <source>The p4 changes will be created as the user invoking &lt;code&gt;git p4 submit&lt;/code&gt;. The &lt;code&gt;--preserve-user&lt;/code&gt; option will cause ownership to be modified according to the author of the Git commit. This option requires admin privileges in p4, which can be granted using &lt;code&gt;p4 protect&lt;/code&gt;.</source>
          <target state="translated">用户调用 &lt;code&gt;git p4 submit&lt;/code&gt; 将创建p4更改。该 &lt;code&gt;--preserve-user&lt;/code&gt; 选项会使根据混帐的作者提交的所有权进行修改。此选项需要p4中的管理员特权，可以使用 &lt;code&gt;p4 protect&lt;/code&gt; 授予该特权。</target>
        </trans-unit>
        <trans-unit id="bc53387773cbb38b899a330a03a788e5288eab48" translate="yes" xml:space="preserve">
          <source>The p4 client specification is maintained with the &lt;code&gt;p4 client&lt;/code&gt; command and contains among other fields, a View that specifies how the depot is mapped into the client repository. The &lt;code&gt;clone&lt;/code&gt; and &lt;code&gt;sync&lt;/code&gt; commands can consult the client spec when given the &lt;code&gt;--use-client-spec&lt;/code&gt; option or when the useClientSpec variable is true. After &lt;code&gt;git p4 clone&lt;/code&gt;, the useClientSpec variable is automatically set in the repository configuration file. This allows future &lt;code&gt;git p4 submit&lt;/code&gt; commands to work properly; the submit command looks only at the variable and does not have a command-line option.</source>
          <target state="translated">p4客户端规范由 &lt;code&gt;p4 client&lt;/code&gt; 命令维护，除其他字段外，还包含一个视图，该视图指定软件仓库如何映射到客户端存储库中。该 &lt;code&gt;clone&lt;/code&gt; 并 &lt;code&gt;sync&lt;/code&gt; 给出的命令时，可以咨询客户规范 &lt;code&gt;--use-client-spec&lt;/code&gt; 选项，或当useClientSpec变量为真。之后 &lt;code&gt;git p4 clone&lt;/code&gt; ，将useClientSpec变量自动存储库配置文件中设置。这使得将来的 &lt;code&gt;git p4 submit&lt;/code&gt; 命令可以正常工作； Submit命令仅查看变量，并且没有命令行选项。</target>
        </trans-unit>
        <trans-unit id="9fec68b06723905b09b9270262e6a13c1b490876" translate="yes" xml:space="preserve">
          <source>The p4 depot path argument to &lt;code&gt;git p4 sync&lt;/code&gt; and &lt;code&gt;git p4 clone&lt;/code&gt; can be one or more space-separated p4 depot paths, with an optional p4 revision specifier on the end:</source>
          <target state="translated">&lt;code&gt;git p4 sync&lt;/code&gt; 和 &lt;code&gt;git p4 clone&lt;/code&gt; 的p4 depot path参数可以是一个或多个以空格分隔的p4 depot路径，最后带有一个可选的p4版本说明符：</target>
        </trans-unit>
        <trans-unit id="d877dea1de89fdb5a15efd47a5debfe5403b96f4" translate="yes" xml:space="preserve">
          <source>The pack-indexes (.idx files) remain in the pack directory so we can delete the MIDX file, set core.midx to false, or downgrade without any loss of information.</source>
          <target state="translated">pack-indexes(.idx文件)仍然保留在pack目录下,所以我们可以删除MIDX文件,将core.midx设置为false,或者降级而不丢失任何信息。</target>
        </trans-unit>
        <trans-unit id="933f30be1e83e4fe09dc8528b693f5b5a75f065d" translate="yes" xml:space="preserve">
          <source>The packed archive format (.pack) is designed to be self-contained so that it can be unpacked without any further information. Therefore, each object that a delta depends upon must be present within the pack.</source>
          <target state="translated">包装档案格式(.pack)的设计是自成一体的,因此它可以在没有任何进一步信息的情况下被解压。因此,delta所依赖的每个对象都必须存在于pack中。</target>
        </trans-unit>
        <trans-unit id="75cd7427877d4a48fded775aaaba114771e37304" translate="yes" xml:space="preserve">
          <source>The packfile(s) created by fast-import do not encourage good disk access patterns. This is caused by fast-import writing the data in the order it is received on standard input, while Git typically organizes data within packfiles to make the most recent (current tip) data appear before historical data. Git also clusters commits together, speeding up revision traversal through better cache locality.</source>
          <target state="translated">由 fast-import 创建的 packfile 并不支持良好的磁盘访问模式,这是因为 fast-import 按照标准输入的顺序写入数据,而 Git 通常会在 packfile 中组织数据,使最新的(当前的提示)数据出现在历史数据之前。这是由于fast-import按照标准输入的顺序写入数据,而Git通常会在packfiles中组织数据,使最新的(当前的提示)数据出现在历史数据之前。Git还将提交的数据聚拢在一起,通过更好的缓存位置性来加快修订版的遍历速度。</target>
        </trans-unit>
        <trans-unit id="73715b9a828b5f7ca9623cd366d376d487c8e126" translate="yes" xml:space="preserve">
          <source>The partial clone feature records special &quot;promisor&quot; packs that may point to objects that are not stored locally, but available on request to a server. The multi-pack-index does not currently track these promisor packs.</source>
          <target state="translated">部分克隆功能记录了特殊的 &quot;promposor &quot;包,这些包可能指向没有存储在本地的对象,但可以根据请求向服务器提供。多包索引目前不跟踪这些承诺者包。</target>
        </trans-unit>
        <trans-unit id="608e992a19f0287b5b2e4cbdc92416d882bd253c" translate="yes" xml:space="preserve">
          <source>The password to use when logging in to the server.</source>
          <target state="translated">登录服务器时使用的密码。</target>
        </trans-unit>
        <trans-unit id="f899bc9ba76fee3c960f01f1f955c5a4bf020e98" translate="yes" xml:space="preserve">
          <source>The patch extracted from e-mail.</source>
          <target state="translated">从电子邮件中提取的补丁。</target>
        </trans-unit>
        <trans-unit id="621265bbad5d0651c63283720f8a5ccddfdeeb61" translate="yes" xml:space="preserve">
          <source>The patch is expected to be inline, directly following the message. Any line that is of the form:</source>
          <target state="translated">补丁应该是内联的,直接跟在消息后面。任何形式的行:</target>
        </trans-unit>
        <trans-unit id="eedf9ed2547b7a76bcd6fb69785bf954af8d224f" translate="yes" xml:space="preserve">
          <source>The patch itself does not apply cleanly. That is &lt;code&gt;bad&lt;/code&gt; but does not have much to do with your MUA. You might want to rebase the patch with &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; before regenerating it in this case.</source>
          <target state="translated">补丁本身不能完全应用。这是 &lt;code&gt;bad&lt;/code&gt; ，但没有太多与你的MUA做。在这种情况下，您可能想在重新生成修补程序之前使用&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]将其&lt;/a&gt;重新着色。</target>
        </trans-unit>
        <trans-unit id="c9ecbf09d9172bac5285d567a6e1031058a01024" translate="yes" xml:space="preserve">
          <source>The patch produced by &lt;code&gt;git format-patch&lt;/code&gt; is in UNIX mailbox format, with a fixed &quot;magic&quot; time stamp to indicate that the file is output from format-patch rather than a real mailbox, like so:</source>
          <target state="translated">&lt;code&gt;git format-patch&lt;/code&gt; patch产生的补丁是UNIX邮箱格式，带有固定的&amp;ldquo;魔术&amp;rdquo;时间戳，指示该文件是从format-patch而不是真实邮箱输出的，如下所示：</target>
        </trans-unit>
        <trans-unit id="7072603eb0a607d061c366f3e4a9cba6cffbd377" translate="yes" xml:space="preserve">
          <source>The path can be either absolute or relative. A relative path is taken as relative to the directory where the hooks are run (see the &quot;DESCRIPTION&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">路径可以是绝对路径，也可以是相对路径。相对路径是相对于运行钩子的目录而言的（请参阅&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;的&amp;ldquo; DESCRIPTION&amp;rdquo;部分）。</target>
        </trans-unit>
        <trans-unit id="6ccace0f35f0f4e5cab0e8cffbdf924135579b2e" translate="yes" xml:space="preserve">
          <source>The path has the attribute with special value &quot;false&quot;; this is specified by listing the name of the attribute prefixed with a dash &lt;code&gt;-&lt;/code&gt; in the attribute list.</source>
          <target state="translated">路径具有带有特殊值&amp;ldquo; false&amp;rdquo;的属性；这是通过列出与一个破折号前缀属性的名称指定 &lt;code&gt;-&lt;/code&gt; 属性列表英寸</target>
        </trans-unit>
        <trans-unit id="96cc920a42ed7b296307f756480841c1366430ee" translate="yes" xml:space="preserve">
          <source>The path has the attribute with special value &quot;true&quot;; this is specified by listing only the name of the attribute in the attribute list.</source>
          <target state="translated">路径中有特殊值为 &quot;true &quot;的属性;这是由属性列表中只列出属性名称来指定的。</target>
        </trans-unit>
        <trans-unit id="f3d259c7dde8e69cba5e131da2dcac58054c5102" translate="yes" xml:space="preserve">
          <source>The path has the attribute with specified string value; this is specified by listing the name of the attribute followed by an equal sign &lt;code&gt;=&lt;/code&gt; and its value in the attribute list.</source>
          <target state="translated">路径具有具有指定字符串值的属性；通过列出属性名称，后跟等号 &lt;code&gt;=&lt;/code&gt; 及其在属性列表中的值来指定。</target>
        </trans-unit>
        <trans-unit id="9a89a340b481b20bfabef5b1bcb5482c1e173e57" translate="yes" xml:space="preserve">
          <source>The path to a list of object names (i.e. one unabbreviated SHA-1 per line) that are known to be broken in a non-fatal way and should be ignored. On versions of Git 2.20 and later comments (&lt;code&gt;#&lt;/code&gt;), empty lines, and any leading and trailing whitespace is ignored. Everything but a SHA-1 per line will error out on older versions.</source>
          <target state="translated">已知以非致命方式中断的对象名称列表（即，每行一个未缩写的SHA-1）的路径，应将其忽略。在Git 2.20和更高版本的注释（ &lt;code&gt;#&lt;/code&gt; ）版本中，空行以及任何前导和尾随空格都将被忽略。每行除SHA-1以外的所有内容在旧版本中都会出错。</target>
        </trans-unit>
        <trans-unit id="66bacdcfb6546645ce51a1173beecea036fe198b" translate="yes" xml:space="preserve">
          <source>The path to higher software quality is significantly improved software testing.</source>
          <target state="translated">提高软件质量的途径是大大改善软件测试。</target>
        </trans-unit>
        <trans-unit id="a62f8e77f19dbb91947274f4224d3b2000deceef" translate="yes" xml:space="preserve">
          <source>The path with which the credential will be used. E.g., for accessing a remote https repository, this will be the repository&amp;rsquo;s path on the server.</source>
          <target state="translated">凭据将使用的路径。例如，对于访问远程https资源库，这将是服务器上资源库的路径。</target>
        </trans-unit>
        <trans-unit id="75a6542b84624c1ec2a2753cb02bac2dc12deb38" translate="yes" xml:space="preserve">
          <source>The path within the &amp;lt;repository&amp;gt; that the action is performed on, for those actions that require it.</source>
          <target state="translated">&amp;lt;repository&amp;gt;中要对其执行操作的路径，用于需要执行该操作的路径。</target>
        </trans-unit>
        <trans-unit id="42c5355b2496aa717e00373f3c96e2614e271309" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing previously stored cookie lines, which should be used in the Git http session, if they match the server. The file format of the file to read cookies from should be plain HTTP headers or the Netscape/Mozilla cookie file format (see &lt;code&gt;curl(1)&lt;/code&gt;). NOTE that the file specified with http.cookieFile is used only as input unless http.saveCookies is set.</source>
          <target state="translated">包含先前存储的cookie行的文件的路径名，如果它们与服务器匹配，则应在Git http会话中使用。从中读取cookie的文件格式应为纯HTTP标头或Netscape / Mozilla cookie文件格式（请参见 &lt;code&gt;curl(1)&lt;/code&gt; ）。注意，除非设置了http.saveCookies，否则用http.cookieFile指定的文件仅用作输入。</target>
        </trans-unit>
        <trans-unit id="7529cc524422963391df3cb62b329f757e09e898" translate="yes" xml:space="preserve">
          <source>The pathname of a file that stores a client certificate to use to authenticate with an HTTPS proxy. Can be overridden by the &lt;code&gt;GIT_PROXY_SSL_CERT&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd72157b1a828f8662a88c728954dfe8fd532c2" translate="yes" xml:space="preserve">
          <source>The pathname of a file that stores a private key to use to authenticate with an HTTPS proxy. Can be overridden by the &lt;code&gt;GIT_PROXY_SSL_KEY&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb891f79fbec881d22446bf8cf74ef0a3e451e0" translate="yes" xml:space="preserve">
          <source>The paths mentioned in the output, unlike many other Git commands, are made relative to the current directory if you are working in a subdirectory (this is on purpose, to help cutting and pasting). See the status.relativePaths config option below.</source>
          <target state="translated">与其他许多Git命令不同的是,如果你是在子目录下工作,输出中提到的路径是相对于当前目录的(这是故意的,有助于剪切和粘贴)。参见下面的 status.relativePaths 配置选项。</target>
        </trans-unit>
        <trans-unit id="ae851010ea42ad696931dec57e7a58d6d0655b81" translate="yes" xml:space="preserve">
          <source>The pathspecs are used to limit the world diff operates in. They remove the filepairs outside the specified sets of pathnames. E.g. If the input set of filepairs included:</source>
          <target state="translated">pathspecs用于限制diff操作的范围。它们会删除指定路径名集之外的文件对。例如,如果输入的文件对集包括。</target>
        </trans-unit>
        <trans-unit id="a35fe6e03b5cf8e686f61a60362e87d3cf937722" translate="yes" xml:space="preserve">
          <source>The pattern &quot;foo/*&quot;, matches &quot;foo/test.json&quot; (a regular file), &quot;foo/bar&quot; (a directory), but it does not match &quot;foo/bar/hello.c&quot; (a regular file), as the asterisk in the pattern does not match &quot;bar/hello.c&quot; which has a slash in it.</source>
          <target state="translated">模式 &quot;foo/*&quot;,匹配 &quot;foo/test.json&quot;(常规文件)、&quot;foo/bar&quot;(目录),但不匹配 &quot;foo/bar/hello.c&quot;(常规文件),因为模式中的星号与 &quot;bar/hello.c &quot;不匹配,后者有斜线。</target>
        </trans-unit>
        <trans-unit id="472a6ff8d8e6e0153adf76e5ad83f89df7215b9f" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;doc/frotz&lt;/code&gt; and &lt;code&gt;/doc/frotz&lt;/code&gt; have the same effect in any &lt;code&gt;.gitignore&lt;/code&gt; file. In other words, a leading slash is not relevant if there is already a middle slash in the pattern.</source>
          <target state="translated">模式 &lt;code&gt;doc/frotz&lt;/code&gt; 和 &lt;code&gt;/doc/frotz&lt;/code&gt; 在任何 &lt;code&gt;.gitignore&lt;/code&gt; 文件中具有相同的效果。换句话说，如果模式中已经存在中间斜线，则前导斜线不相关。</target>
        </trans-unit>
        <trans-unit id="7f3e3da749b8fed6cc11585c7aa5dbe77eee53ad" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;foo/&lt;/code&gt; will match a directory &lt;code&gt;foo&lt;/code&gt; and paths underneath it, but will not match a regular file or a symbolic link &lt;code&gt;foo&lt;/code&gt; (this is consistent with the way how pathspec works in general in Git)</source>
          <target state="translated">模式 &lt;code&gt;foo/&lt;/code&gt; 将匹配目录 &lt;code&gt;foo&lt;/code&gt; 及其下的路径，但不匹配常规文件或符号链接 &lt;code&gt;foo&lt;/code&gt; （这与pathspec在Git中的一般工作方式一致）</target>
        </trans-unit>
        <trans-unit id="32166ee916b00891724c1bd52223b5e1e2d10da0" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;hello.*&lt;/code&gt; matches any file or folder whose name begins with &lt;code&gt;hello&lt;/code&gt;. If one wants to restrict this only to the directory and not in its subdirectories, one can prepend the pattern with a slash, i.e. &lt;code&gt;/hello.*&lt;/code&gt;; the pattern now matches &lt;code&gt;hello.txt&lt;/code&gt;, &lt;code&gt;hello.c&lt;/code&gt; but not &lt;code&gt;a/hello.java&lt;/code&gt;.</source>
          <target state="translated">模式 &lt;code&gt;hello.*&lt;/code&gt; 匹配名称以 &lt;code&gt;hello&lt;/code&gt; 开头的任何文件或文件夹。如果只想将此限制于目录而不是其子目录，则可以在模式前面加上斜杠，即 &lt;code&gt;/hello.*&lt;/code&gt; ；该模式现在匹配 &lt;code&gt;hello.txt&lt;/code&gt; ， &lt;code&gt;hello.c&lt;/code&gt; ,但不匹配 &lt;code&gt;a/hello.java&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b35cb663783a3682a66157f3dc9fd508efdfceba" translate="yes" xml:space="preserve">
          <source>The pattern can contain standard globbing wildcards and two additional ones, &lt;code&gt;**/&lt;/code&gt; and &lt;code&gt;/**&lt;/code&gt;, that can match multiple path components. Please refer to &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for details. For convenience:</source>
          <target state="translated">该模式可以包含标准的通配符和两个附加的通配符 &lt;code&gt;**/&lt;/code&gt; 和 &lt;code&gt;/**&lt;/code&gt; ，它们可以匹配多个路径分量。有关详细信息，请参考&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;。为了方便：</target>
        </trans-unit>
        <trans-unit id="ae88d32c3f9079756948f2fdc8ae4c4c2e834b93" translate="yes" xml:space="preserve">
          <source>The patterns given should not begin with &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, or &lt;code&gt;refs/remotes&lt;/code&gt; when applied to &lt;code&gt;--branches&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt;, or &lt;code&gt;--remotes&lt;/code&gt;, respectively, and they must begin with &lt;code&gt;refs/&lt;/code&gt; when applied to &lt;code&gt;--glob&lt;/code&gt; or &lt;code&gt;--all&lt;/code&gt;. If a trailing &lt;code&gt;/*&lt;/code&gt; is intended, it must be given explicitly.</source>
          <target state="translated">给予不应该开始图案 &lt;code&gt;refs/heads&lt;/code&gt; ， &lt;code&gt;refs/tags&lt;/code&gt; ，或 &lt;code&gt;refs/remotes&lt;/code&gt; 当应用于 &lt;code&gt;--branches&lt;/code&gt; ， &lt;code&gt;--tags&lt;/code&gt; ，或 &lt;code&gt;--remotes&lt;/code&gt; ，分别与他们必须以 &lt;code&gt;refs/&lt;/code&gt; 当应用于 &lt;code&gt;--glob&lt;/code&gt; 或 &lt;code&gt;--all&lt;/code&gt; 。如果要使用结尾的 &lt;code&gt;/*&lt;/code&gt; ，则必须明确给出。</target>
        </trans-unit>
        <trans-unit id="86b0de7f6b1176e8c07c5aaa523447c3abd4915b" translate="yes" xml:space="preserve">
          <source>The performance format target (PERF) is a column-based format to replace GIT_TRACE_PERFORMANCE and is suitable for development and testing, possibly to complement tools like gprof. This format is enabled with the &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; environment variable or the &lt;code&gt;trace2.perfTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">性能格式目标（PERF）是一种基于列的格式，用于替代GIT_TRACE_PERFORMANCE，适用于开发和测试，可能会补充gprof等工具。使用 &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; 环境变量或 &lt;code&gt;trace2.perfTarget&lt;/code&gt; 系统或全局配置设置启用此格式。</target>
        </trans-unit>
        <trans-unit id="506071bbd9d0908b14e8f015ca1b0ff23e4ec21e" translate="yes" xml:space="preserve">
          <source>The performance of git-filter-branch is glacially slow; its design makes it impossible for a backward-compatible implementation to ever be fast:</source>
          <target state="translated">git-filter-branch的性能非常慢,它的设计使得一个向后兼容的实现不可能快。</target>
        </trans-unit>
        <trans-unit id="d698b970e30734158c98cc5647b57a259a47bb36" translate="yes" xml:space="preserve">
          <source>The person who put a piece of code into Git.</source>
          <target state="translated">将一段代码放入Git的人。</target>
        </trans-unit>
        <trans-unit id="81b84527afb0ae2e697e75bbd7638af25fa12741" translate="yes" xml:space="preserve">
          <source>The pickaxe search is described in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; (the description of &lt;code&gt;-S&amp;lt;string&amp;gt;&lt;/code&gt; option, which refers to pickaxe entry in &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt; for more details).</source>
          <target state="translated">镐搜索在&lt;a href=&quot;git-log&quot;&gt;git-log [1]中进行&lt;/a&gt;了描述（ &lt;code&gt;-S&amp;lt;string&amp;gt;&lt;/code&gt; 选项的描述，有关更多细节，请&lt;a href=&quot;gitdiffcore&quot;&gt;参见gitdiffcore [7]中的&lt;/a&gt;镐输入）。</target>
        </trans-unit>
        <trans-unit id="525e6a0e6ee3d9fa31ab39c46532aa0c693111e1" translate="yes" xml:space="preserve">
          <source>The placeholders are:</source>
          <target state="translated">占位机是。</target>
        </trans-unit>
        <trans-unit id="1651136b42ed906ec527c0b5bb6ead2e015774c3" translate="yes" xml:space="preserve">
          <source>The point of this helper is to reduce the number of times you must type your username or password. For example:</source>
          <target state="translated">这个助手的目的是减少你必须输入用户名或密码的次数。例如</target>
        </trans-unit>
        <trans-unit id="c89cea9d29e269d3d21a2bb103d39e43b1e539d2" translate="yes" xml:space="preserve">
          <source>The porcelain format</source>
          <target state="translated">瓷器格式</target>
        </trans-unit>
        <trans-unit id="26e08a1995b67cc0010521ba6bed170106483645" translate="yes" xml:space="preserve">
          <source>The porcelain format generally suppresses commit information that has already been seen. For example, two lines that are blamed to the same commit will both be shown, but the details for that commit will be shown only once. This is more efficient, but may require more state be kept by the reader. The &lt;code&gt;--line-porcelain&lt;/code&gt; option can be used to output full commit information for each line, allowing simpler (but less efficient) usage like:</source>
          <target state="translated">瓷器格式通常会抑制已经看到的提交信息。例如，将显示归咎于同一提交的两行，但是该提交的详细信息将仅显示一次。这是更有效的方法，但可能要求阅读器保留更多状态。所述 &lt;code&gt;--line-porcelain&lt;/code&gt; 选项可用于以输出完整的提交信息的每一行，从而允许更简单的像（但效率较低）的用法：</target>
        </trans-unit>
        <trans-unit id="20c54b7279b5d1b2be6928d44083be1fd00dfbb8" translate="yes" xml:space="preserve">
          <source>The porcelain format has a line per attribute. Attributes are listed with a label and value separated by a single space. Boolean attributes (like &lt;code&gt;bare&lt;/code&gt; and &lt;code&gt;detached&lt;/code&gt;) are listed as a label only, and are only present if and only if the value is true. The first attribute of a worktree is always &lt;code&gt;worktree&lt;/code&gt;, an empty line indicates the end of the record. For example:</source>
          <target state="translated">瓷器格式每个属性都有一行。属性用标签和值列出，并用单个空格分隔。布尔属性（如 &lt;code&gt;bare&lt;/code&gt; 和 &lt;code&gt;detached&lt;/code&gt; ）仅作为标签列出，并且仅当且仅当该值为true时才存在。工作树的第一个属性始终是 &lt;code&gt;worktree&lt;/code&gt; ，空行表示记录的结尾。例如：</target>
        </trans-unit>
        <trans-unit id="d78141a7bccc3a1873780a422f8d41a19ce92e1b" translate="yes" xml:space="preserve">
          <source>The porcelain format has a line per attribute. Attributes are listed with a label and value separated by a single space. Boolean attributes (like &lt;code&gt;bare&lt;/code&gt; and &lt;code&gt;detached&lt;/code&gt;) are listed as a label only, and are present only if the value is true. The first attribute of a working tree is always &lt;code&gt;worktree&lt;/code&gt;, an empty line indicates the end of the record. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a362940b066b853917862099c8e9ab263cba72b1" translate="yes" xml:space="preserve">
          <source>The port number to bind the gitweb httpd to. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">绑定gitweb httpd的端口号。参见&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cecf31c324042fa16f4839249194885b3982bae" translate="yes" xml:space="preserve">
          <source>The port number to bind the httpd to. (Default: 1234)</source>
          <target state="translated">绑定 httpd 的端口号。(默认值:1234)</target>
        </trans-unit>
        <trans-unit id="735bfd35b5b101e4c116696c3cd1ebf6bc58faa9" translate="yes" xml:space="preserve">
          <source>The possible options are:</source>
          <target state="translated">可能的选择是:</target>
        </trans-unit>
        <trans-unit id="8bc0e360ec6eefb74bc5a1aed65f13e846b6d915" translate="yes" xml:space="preserve">
          <source>The preferred strategy for rolling out a version bump (whether whole repository or for a single file) is to teach git to read the new format, and allow writing the new format with a config switch or command line option (for experimentation or for those who do not care about backwards compatibility with older gits). Then after a long period to allow the reading capability to become common, we may switch to writing the new format by default.</source>
          <target state="translated">推广版本升级(无论是整个版本库还是单个文件)的首选策略是教会git读取新的格式,并允许通过配置开关或命令行选项来写入新的格式(用于实验或那些不在乎与旧gits向后兼容的人)。然后经过很长一段时间,让读取能力变得普遍,我们可以默认切换到写入新格式。</target>
        </trans-unit>
        <trans-unit id="adf8f6f66c16d1ab5dcd5c39342b75931e439ba4" translate="yes" xml:space="preserve">
          <source>The prefix ability basically makes it trivial to use &lt;code&gt;git checkout-index&lt;/code&gt; as an &quot;export as tree&quot; function. Just read the desired tree into the index, and do:</source>
          <target state="translated">前缀功能基本上使将 &lt;code&gt;git checkout-index&lt;/code&gt; 用作&amp;ldquo;导出为树&amp;rdquo;功能变得微不足道。只需将所需的树读入索引，然后执行：</target>
        </trans-unit>
        <trans-unit id="0f1fc4f35ab6b79f4468bd7525c0542dc9193da5" translate="yes" xml:space="preserve">
          <source>The previously introduced &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; is just a wrapper for &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">先前介绍的&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;只是&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;的包装。</target>
        </trans-unit>
        <trans-unit id="675ae216ecd575fef2e1ffa9eadeda52bdab6e90" translate="yes" xml:space="preserve">
          <source>The primary problem with rewriting the history of a branch has to do with merging. Suppose somebody fetches your branch and merges it into their branch, with a result something like this:</source>
          <target state="translated">重写分支历史的主要问题是与合并有关。假设有人获取了你的分支并将其合并到他们的分支中,结果是这样的。</target>
        </trans-unit>
        <trans-unit id="ff3dc4a94f1f540e3dd725f6eef6c2d405d85a87" translate="yes" xml:space="preserve">
          <source>The primary tool we&amp;rsquo;ve been using to create commits is &lt;code&gt;git-commit
-a&lt;/code&gt;, which creates a commit including every change you&amp;rsquo;ve made to your working tree. But what if you want to commit changes only to certain files? Or only certain changes to certain files?</source>
          <target state="translated">我们用来创建提交的主要工具是 &lt;code&gt;git-commit -a&lt;/code&gt; ，它创建一个提交，其中包括您对工作树所做的所有更改。但是，如果您只想对某些文件提交更改怎么办？还是仅对某些文件进行某些更改？</target>
        </trans-unit>
        <trans-unit id="bc32172ebad82b3a8531284b76fc91d0e2655fc8" translate="yes" xml:space="preserve">
          <source>The protection it offers over &lt;code&gt;--force&lt;/code&gt; is ensuring that subsequent changes your work wasn&amp;rsquo;t based on aren&amp;rsquo;t clobbered, but this is trivially defeated if some background process is updating refs in the background. We don&amp;rsquo;t have anything except the remote tracking info to go by as a heuristic for refs you&amp;rsquo;re expected to have seen &amp;amp; are willing to clobber.</source>
          <target state="translated">它提供的 &lt;code&gt;--force&lt;/code&gt; 保护可以确保您的工作所基于的后续更改不会被破坏，但是如果某些后台进程在后台更新引用，这将是微不足道的。除了远程跟踪信息以外，我们没有其他任何东西，可以启发您希望看到的参考文献，并愿意为之烦恼。</target>
        </trans-unit>
        <trans-unit id="c8ef7004934ae749808b9e22322b2c11275f98e4" translate="yes" xml:space="preserve">
          <source>The protocol names currently used by git are:</source>
          <target state="translated">目前git使用的协议名称为:。</target>
        </trans-unit>
        <trans-unit id="19913c2c5a680884fd5ab271ea84dfe92e10bf53" translate="yes" xml:space="preserve">
          <source>The protocol over which the credential will be used (e.g., &lt;code&gt;https&lt;/code&gt;).</source>
          <target state="translated">将使用凭证的协议（例如 &lt;code&gt;https&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="27c53e4d1c63b3496c93b1976851fe0522937712" translate="yes" xml:space="preserve">
          <source>The provided options must not contain a NUL or LF character.</source>
          <target state="translated">提供的选项不能包含NUL或LF字符。</target>
        </trans-unit>
        <trans-unit id="5fb1f43ddd5fc4b8ac18d086f82e6f88c9ed5855" translate="yes" xml:space="preserve">
          <source>The purpose of gitignore files is to ensure that certain files not tracked by Git remain untracked.</source>
          <target state="translated">gitignore文件的目的是确保某些没有被Git跟踪的文件不被跟踪。</target>
        </trans-unit>
        <trans-unit id="a2b9675d20ab3c1e80e15b296d660914f6ea2131" translate="yes" xml:space="preserve">
          <source>The purpose of the hook is to edit the message file in place, and it is not suppressed by the &lt;code&gt;--no-verify&lt;/code&gt; option. A non-zero exit means a failure of the hook and aborts the commit. It should not be used as replacement for pre-commit hook.</source>
          <target state="translated">挂钩的目的是就地编辑消息文件，并且 &lt;code&gt;--no-verify&lt;/code&gt; 选项不会抑制该挂钩。非零退出意味着挂钩失败并中止提交。不应将其用作预提交挂钩的替代品。</target>
        </trans-unit>
        <trans-unit id="96e3995f595001b3f723f5fc30a3546a03e6b50b" translate="yes" xml:space="preserve">
          <source>The purpose of the hook is to edit the message file in place, and it is not supressed by the &lt;code&gt;--no-verify&lt;/code&gt; option. This hook is called even if &lt;code&gt;--prepare-p4-only&lt;/code&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383a661ab7ffdec395082f1f22f245f53263885b" translate="yes" xml:space="preserve">
          <source>The push URL of a remote repository. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">远程存储库的推送URL。参见&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8cd29a2b80ae7f4721c7a9c69324052af609357" translate="yes" xml:space="preserve">
          <source>The push done by the other person updated the branch that used to point at commit X to point at commit A. It is a fast-forward.</source>
          <target state="translated">对方所做的推送,将原来指向提交X的分支更新为指向提交A的分支,这是一个快进。</target>
        </trans-unit>
        <trans-unit id="79a20eedac198c71849aef6d1fe1606ea1ee319f" translate="yes" xml:space="preserve">
          <source>The quilt series file.</source>
          <target state="translated">被子系列文件。</target>
        </trans-unit>
        <trans-unit id="eb2f9ed5ec284eab8396a9b582f3da5582d364ca" translate="yes" xml:space="preserve">
          <source>The raw output format from &quot;git-diff-index&quot;, &quot;git-diff-tree&quot;, &quot;git-diff-files&quot; and &quot;git diff --raw&quot; are very similar.</source>
          <target state="translated">git-diff-index&quot;、&quot;git-diff-tree&quot;、&quot;git-diff-files &quot;和 &quot;git diff --raw &quot;的原始输出格式非常相似。</target>
        </trans-unit>
        <trans-unit id="a6ab1028c44c2d54846a9217b4a7ad959d178f38" translate="yes" xml:space="preserve">
          <source>The reachability bitmap is currently paired directly with a single packfile, using the pack-order as the object order to hopefully compress the bitmaps well using run-length encoding. This could be extended to pair a reachability bitmap with a multi-pack-index. If the multi-pack-index is extended to store a &quot;stable object order&quot; (a function Order(hash) = integer that is constant for a given hash, even as the multi-pack-index is updated) then a reachability bitmap could point to a multi-pack-index and be updated independently.</source>
          <target state="translated">目前,可到达性位图直接与单个packfile配对,使用pack-order作为对象顺序,希望能使用运行长度编码很好地压缩位图。这可以扩展到将可到达性位图与多包索引配对。如果 multi-pack-index 被扩展为存储一个 &quot;稳定的对象顺序&quot;(一个函数 Order(hash)=整数,对于一个给定的哈希来说,即使在 multi-pack-index 被更新时也是不变的),那么一个可到达性位图可以指向一个 multi-pack-index 并被独立更新。</target>
        </trans-unit>
        <trans-unit id="0aca04dff2f76e52dde4dcdd1542bfe4e1470100" translate="yes" xml:space="preserve">
          <source>The reason fast-import uses &lt;code&gt;:&lt;/code&gt; to denote a mark reference is this character is not legal in a Git branch name. The leading &lt;code&gt;:&lt;/code&gt; makes it easy to distinguish between the mark 42 (&lt;code&gt;:42&lt;/code&gt;) and the branch 42 (&lt;code&gt;42&lt;/code&gt; or &lt;code&gt;refs/heads/42&lt;/code&gt;), or an abbreviated SHA-1 which happened to consist only of base-10 digits.</source>
          <target state="translated">快速导入使用 &lt;code&gt;:&lt;/code&gt; 表示标记参考的原因是该字符在Git分支名称中不合法。前导 &lt;code&gt;:&lt;/code&gt; 可以轻松地区分标记42（ &lt;code&gt;:42&lt;/code&gt; ）和分支42（ &lt;code&gt;42&lt;/code&gt; 或 &lt;code&gt;refs/heads/42&lt;/code&gt; ），或正好仅由10位数字组成的SHA-1缩写。</target>
        </trans-unit>
        <trans-unit id="1aba410e8fcfe74102eea2fcf73898889acee3ed" translate="yes" xml:space="preserve">
          <source>The reason it doesn&amp;rsquo;t error out when provided without &lt;code&gt;--prune&lt;/code&gt; or its config versions is for flexibility of the configured versions, and to maintain a 1=1 mapping between what the command line flags do, and what the configuration versions do.</source>
          <target state="translated">当不提供 &lt;code&gt;--prune&lt;/code&gt; 或其配置版本时，它不会出错的原因是为了确保配置版本的灵活性，并在命令行标志和配置版本之间保持1 = 1的映射。</target>
        </trans-unit>
        <trans-unit id="b2defd752d90b2a93e28eb3efe0e516f3fc264fc" translate="yes" xml:space="preserve">
          <source>The rebase will stop where &lt;code&gt;pick&lt;/code&gt; has been replaced with &lt;code&gt;edit&lt;/code&gt; or when a step in the list fails to mechanically resolve conflicts and needs your help. When you are done editing and/or resolving conflicts you can continue with &lt;code&gt;git rebase --continue&lt;/code&gt;. If you decide that things are getting too hairy, you can always bail out with &lt;code&gt;git rebase
--abort&lt;/code&gt;. Even after the rebase is complete, you can still recover the original branch by using the &lt;a href=&quot;#reflogs&quot;&gt;reflog&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;pick&lt;/code&gt; 被替换为 &lt;code&gt;edit&lt;/code&gt; 或者列表中的某个步骤无法机械解决冲突并需要您的帮助，则rebase将停止。完成编辑和/或解决冲突后，可以继续使用 &lt;code&gt;git rebase --continue&lt;/code&gt; 。如果您认为事情变得太 &lt;code&gt;git rebase --abort&lt;/code&gt; ，可以随时使用git rebase --abort来纾困。即使完成了基准调整，您仍然可以使用&lt;a href=&quot;#reflogs&quot;&gt;reflog&lt;/a&gt;恢复原始分支。</target>
        </trans-unit>
        <trans-unit id="939cf091c711a461fc7775d9278b48a4457f30c1" translate="yes" xml:space="preserve">
          <source>The ref namespace is hierarchical. Different subhierarchies are used for different purposes (e.g. the &lt;code&gt;refs/heads/&lt;/code&gt; hierarchy is used to represent local branches).</source>
          <target state="translated">ref名称空间是分层的。不同的子层次结构用于不同的目的（例如， &lt;code&gt;refs/heads/&lt;/code&gt; 层次结构用于表示本地分支）。</target>
        </trans-unit>
        <trans-unit id="d11d2f57237e560f1ae2f7da112ae694568b2d78" translate="yes" xml:space="preserve">
          <source>The ref which the given symbolic ref refers to. If not a symbolic ref, nothing is printed. Respects the &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt; and &lt;code&gt;:rstrip&lt;/code&gt; options in the same way as &lt;code&gt;refname&lt;/code&gt; above.</source>
          <target state="translated">给定符号ref所引用的ref。如果不是符号引用，则不会打印任何内容。与上面的 &lt;code&gt;refname&lt;/code&gt; 一样，尊重 &lt;code&gt;:short&lt;/code&gt; ， &lt;code&gt;:lstrip&lt;/code&gt; 和 &lt;code&gt;:rstrip&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="09256802b46aa557905f47df9fc0a1148d341199" translate="yes" xml:space="preserve">
          <source>The reflogs are kept by default for 30 days, after which they may be pruned. See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; and &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; to learn how to control this pruning, and see the &quot;SPECIFYING REVISIONS&quot; section of &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details.</source>
          <target state="translated">默认情况下，reflog会保留30天，之后可能会被删除。请参阅&lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt;和&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;以了解如何控制此修剪，并请参阅&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]的&lt;/a&gt; &amp;ldquo; SPECIFYING REVISIONS&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="29e87ce112fa8f38582e71025c0e3c162626939f" translate="yes" xml:space="preserve">
          <source>The refname parameter is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 arguments are the object names for the refname before and after the update. Note that the hook is called before the refname is updated, so either sha1-old is 0{40} (meaning there is no such ref yet), or it should match what is recorded in refname.</source>
          <target state="translated">refname参数是相对于$GIT_DIR的,例如,对于主头来说,是 &quot;refs/heads/master&quot;。两个 sha1 参数是 refname 更新前和更新后的对象名。请注意,钩子是在 refname 更新之前调用的,所以 sha1-old 是 0{40}。(意思是还没有这样的ref),或者它应该与refname中记录的内容一致。</target>
        </trans-unit>
        <trans-unit id="21810fe3549bedbdcfb85519d93701f4c1ec8042" translate="yes" xml:space="preserve">
          <source>The refname value is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 values before each refname are the object names for the refname before and after the update. Refs that were created will have sha1-old equal to 0{40}, while refs that were deleted will have sha1-new equal to 0{40}, otherwise sha1-old and sha1-new should be valid objects in the repository.</source>
          <target state="translated">refname 的值是相对于 $GIT_DIR 的,例如,对于主头来说,就是 &quot;refs/heads/master&quot;。每个 refname 前面的两个 sha1 值是更新前和更新后 refname 的对象名。被创建的 refs 的 sha1-old 值等于 0{40},而被删除的 refs 的 sha1-new 值等于 0{40},否则 sha1-old 和 sha1-new 应该是版本库中的有效对象。</target>
        </trans-unit>
        <trans-unit id="f7cd6bb7198b77eda24e90f3bdabb1a4fb56aeb0" translate="yes" xml:space="preserve">
          <source>The refname value is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 values before each refname are the object names for the refname before and after the update. Refs to be created will have sha1-old equal to 0{40}, while refs to be deleted will have sha1-new equal to 0{40}, otherwise sha1-old and sha1-new should be valid objects in the repository.</source>
          <target state="translated">refname 的值是相对于 $GIT_DIR 的,例如,对于主头来说,就是 &quot;refs/heads/master&quot;。每个 refname 前面的两个 sha1 值是更新前和更新后 refname 的对象名。要创建的 refs 的 sha1-old 值等于 0{40},而要删除的 refs 的 sha1-new 值等于 0{40},否则 sha1-old 和 sha1-new 应该是版本库中的有效对象。</target>
        </trans-unit>
        <trans-unit id="efb922792d6081ee214f4a8e1d665108721507f6" translate="yes" xml:space="preserve">
          <source>The refs are using the given hash algorithm. This keyword is only used if the server and client both support the object-format extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce26e3499eea5a4c24942a8e072b3a9539557d0b" translate="yes" xml:space="preserve">
          <source>The regex can also be set via a diff driver or configuration option, see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; or &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.</source>
          <target state="translated">还可以通过diff驱动程序或配置选项来设置正则表达式，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;或&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。明确给出该参数将覆盖所有差异驱动程序或配置设置。差异驱动程序将覆盖配置设置。</target>
        </trans-unit>
        <trans-unit id="db9cbae31eee7dd0453a2f75d2431a49c7ce5a43" translate="yes" xml:space="preserve">
          <source>The regex must capture the source branch name in $1.</source>
          <target state="translated">regex必须捕获1美元中的源分支名称。</target>
        </trans-unit>
        <trans-unit id="2f22e3781909efae9d373f9fa46942441b8a264c" translate="yes" xml:space="preserve">
          <source>The regular expression that the diff driver should use to recognize the hunk header. A built-in pattern may also be used. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff驱动程序应用于识别块头的正则表达式。也可以使用内置模式。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4211f7342bdc098f581fc9d7939f84dc24cd9689" translate="yes" xml:space="preserve">
          <source>The regular expression that the diff driver should use to split words in a line. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff驱动程序应使用正则表达式在一行中拆分单词。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa527c60a8440b01958ab1ade21254172db5c938" translate="yes" xml:space="preserve">
          <source>The remainder of the commit or the tag message that follows the &quot;subject&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0619f2eb83a7faf485cba23bd4bbef8fb0cb4dd" translate="yes" xml:space="preserve">
          <source>The remainder of the line, after stripping the spaces, is used as the help associated to the option.</source>
          <target state="translated">去掉空格后,这一行的剩余部分被用作与选项相关的帮助。</target>
        </trans-unit>
        <trans-unit id="19c5350e9da63f63a8abbccc7168a03dfd13ebac" translate="yes" xml:space="preserve">
          <source>The remaining features cannot be overridden on a per project basis.</source>
          <target state="translated">其余的功能不能按项目进行覆盖。</target>
        </trans-unit>
        <trans-unit id="303228bfc99fc67a561e0782dc3e0ceb08c259bb" translate="yes" xml:space="preserve">
          <source>The remote branch name for a submodule, used by &lt;code&gt;git submodule
update --remote&lt;/code&gt;. Set this option to override the value found in the &lt;code&gt;.gitmodules&lt;/code&gt; file. See &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">子模块的远程分支名称，由 &lt;code&gt;git submodule update --remote&lt;/code&gt; 。设置此选项可覆盖 &lt;code&gt;.gitmodules&lt;/code&gt; 文件中的值。有关详细信息，请参见&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt;和&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fdf928f1cd746e7574e5e26895f63052b9e3300" translate="yes" xml:space="preserve">
          <source>The remote configuration is achieved using the &lt;code&gt;remote.origin.url&lt;/code&gt; and &lt;code&gt;remote.origin.fetch&lt;/code&gt; configuration variables. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">使用 &lt;code&gt;remote.origin.url&lt;/code&gt; 和 &lt;code&gt;remote.origin.fetch&lt;/code&gt; 配置变量可以实现远程配置。（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e7b65b070cfabceee72964f903404025034f8258" translate="yes" xml:space="preserve">
          <source>The remote end did not report the successful update of the ref, perhaps because of a temporary error on the remote side, a break in the network connection, or other transient error.</source>
          <target state="translated">远程端没有报出ref的成功更新,可能是远程端临时出错,网络连接中断,或者其他短暂的错误。</target>
        </trans-unit>
        <trans-unit id="53c927a78ca0c11dc61a2c100f0e02c446d49374" translate="yes" xml:space="preserve">
          <source>The remote end refused the update. Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; (for pushes to the checked out branch), &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; (for forced non-fast-forward updates), &lt;code&gt;receive.denyDeletes&lt;/code&gt; or &lt;code&gt;receive.denyDeleteCurrent&lt;/code&gt;. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">远端拒绝更新。通常是由远程侧的钩子引起的，或者是由于远程存储库具有以下有效的安全选项之一： &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; （用于推送到签出的分支）， &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; （用于强制的非快进更新） ）， &lt;code&gt;receive.denyDeletes&lt;/code&gt; 或 &lt;code&gt;receive.denyDeleteCurrent&lt;/code&gt; 。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9422d899b3eadda77c8387091e37d96facb6c2f" translate="yes" xml:space="preserve">
          <source>The remote heads to update from. This is relative to $GIT_DIR (e.g. &quot;HEAD&quot;, &quot;refs/heads/master&quot;). When unspecified, update from all heads the remote side has.</source>
          <target state="translated">要更新的远程头。这是相对于 $GIT_DIR 的 (例如 &quot;HEAD&quot;,&quot;refs/heads/master&quot;)。当未指定时,从远程的所有头更新。</target>
        </trans-unit>
        <trans-unit id="0419c5b470511fe246bdc207ab1f44978b5929c7" translate="yes" xml:space="preserve">
          <source>The remote hostname for a network credential.</source>
          <target state="translated">网络凭证的远程主机名。</target>
        </trans-unit>
        <trans-unit id="2acecc1c91d3ba6caf56ecf7245b62c949c434da" translate="yes" xml:space="preserve">
          <source>The remote hostname for a network credential. This includes the port number if one was specified (e.g., &quot;example.com:8088&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7632b9807699f7e6cd146f3dd66e0428b068933" translate="yes" xml:space="preserve">
          <source>The remote ref that matches &amp;lt;src&amp;gt; is fetched, and if &amp;lt;dst&amp;gt; is not an empty string, an attempt is made to update the local ref that matches it.</source>
          <target state="translated">获取与&amp;lt;src&amp;gt;匹配的远程引用，并且如果&amp;lt;dst&amp;gt;不是空字符串，则尝试更新与之匹配的本地ref。</target>
        </trans-unit>
        <trans-unit id="282ef7eedc5a5bdee9740e04ed8375ea205f3da3" translate="yes" xml:space="preserve">
          <source>The remote refs to update.</source>
          <target state="translated">要更新的远程参照物。</target>
        </trans-unit>
        <trans-unit id="1126548b6dd0a73d0e4b3cf8a47f765ced5296ec" translate="yes" xml:space="preserve">
          <source>The remote to push to by default. Overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for all branches, and is overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; for specific branches.</source>
          <target state="translated">默认情况下要推送到的遥控器。重写 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 对所有分支，并且通过重写 &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; 特定分支。</target>
        </trans-unit>
        <trans-unit id="69cc315a656a6408b19c28c1250214347094ab33" translate="yes" xml:space="preserve">
          <source>The replaced object and the replacement object must be of the same type. This restriction can be bypassed using &lt;code&gt;-f&lt;/code&gt;.</source>
          <target state="translated">替换的对象和替换的对象必须具有相同的类型。可以使用 &lt;code&gt;-f&lt;/code&gt; 绕过此限制。</target>
        </trans-unit>
        <trans-unit id="1ad56792b1c232c0733d7ad92a2a6edfcbfd7d1e" translate="yes" xml:space="preserve">
          <source>The report does not tell you anything about lines which have been deleted or replaced; you need to use a tool such as &lt;code&gt;git diff&lt;/code&gt; or the &quot;pickaxe&quot; interface briefly mentioned in the following paragraph.</source>
          <target state="translated">该报告不会告诉您有关已删除或替换的行的任何信息；您需要使用下一节中简要提到的 &lt;code&gt;git diff&lt;/code&gt; 之类的工具或&amp;ldquo; pickaxe&amp;rdquo;界面。</target>
        </trans-unit>
        <trans-unit id="b4fd8af335028abdc88c8957e63b788cd43e89cc" translate="yes" xml:space="preserve">
          <source>The report of the commands of this hook should have the same order as the input. The exit status of the &lt;code&gt;proc-receive&lt;/code&gt; hook only determines the success or failure of the group of commands sent to it, unless atomic push is in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c986c29f6ffa22f2a8c706bbb75b7aeb4461294" translate="yes" xml:space="preserve">
          <source>The repository URL to be pulled from.</source>
          <target state="translated">要拉取的版本库URL。</target>
        </trans-unit>
        <trans-unit id="944d2d5ccd37faa608b4a3dce165543a5adf2fbf" translate="yes" xml:space="preserve">
          <source>The repository the action will be performed on.</source>
          <target state="translated">要执行操作的存储库。</target>
        </trans-unit>
        <trans-unit id="0e7c4601cfd7634812fd5318d08d4f529fb59bef" translate="yes" xml:space="preserve">
          <source>The repository to get a tar archive from.</source>
          <target state="translated">从仓库中获取焦油文件的仓库。</target>
        </trans-unit>
        <trans-unit id="bc81f7623489d466e462d3597d8dc6ebd3c462a1" translate="yes" xml:space="preserve">
          <source>The repository to sync from.</source>
          <target state="translated">要同步的存储库。</target>
        </trans-unit>
        <trans-unit id="3d7b45c15d44961366710f29c0592cfbaf8293a2" translate="yes" xml:space="preserve">
          <source>The repository to sync into.</source>
          <target state="translated">要同步到的存储库。</target>
        </trans-unit>
        <trans-unit id="85a32286326310d42bba4488de0fbceb84f9845b" translate="yes" xml:space="preserve">
          <source>The repository to update.</source>
          <target state="translated">要更新的存储库。</target>
        </trans-unit>
        <trans-unit id="15ea4cb9c0b7ca59bf54604e4e274c258d2ab5d8" translate="yes" xml:space="preserve">
          <source>The response of &lt;code&gt;fetch&lt;/code&gt; is broken into a number of sections separated by delimiter packets (0001), with each section beginning with its section header.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 的响应分为多个由定界符数据包（0001）分隔的部分，每个部分均以其部分头开始。</target>
        </trans-unit>
        <trans-unit id="f5a3baabdc3717b14a2e7f02d6a5a2eab21baf8b" translate="yes" xml:space="preserve">
          <source>The response of &lt;code&gt;fetch&lt;/code&gt; is broken into a number of sections separated by delimiter packets (0001), with each section beginning with its section header. Most sections are sent only when the packfile is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1a001f6b3f7c16917c0e0241e976b8717f870a" translate="yes" xml:space="preserve">
          <source>The rest of the documentation discusses &lt;code&gt;fsck.*&lt;/code&gt; for brevity, but the same applies for the corresponding &lt;code&gt;receive.fsck.*&lt;/code&gt; and &lt;code&gt;fetch.&amp;lt;msg-id&amp;gt;.*&lt;/code&gt;. variables.</source>
          <target state="translated">为了简洁起见，文档的其余部分讨论了 &lt;code&gt;fsck.*&lt;/code&gt; ，但是对于相应的 &lt;code&gt;receive.fsck.*&lt;/code&gt; 和 &lt;code&gt;fetch.&amp;lt;msg-id&amp;gt;.*&lt;/code&gt; 。变量。</target>
        </trans-unit>
        <trans-unit id="ac10b74ced74e00c661f52e9250a42f47fd6add4" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;git merge-base --octopus A B C&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, because &lt;code&gt;2&lt;/code&gt; is the best common ancestor of all commits.</source>
          <target state="translated">结果 &lt;code&gt;git merge-base --octopus A B C&lt;/code&gt; 是 &lt;code&gt;2&lt;/code&gt; ，因为 &lt;code&gt;2&lt;/code&gt; 是所有提交的最好的共同祖先。</target>
        </trans-unit>
        <trans-unit id="1e8fa948e18ddfaa21178042cd566eaada7aae80" translate="yes" xml:space="preserve">
          <source>The result of comparison is passed from these commands to what is internally called &quot;diffcore&quot;, in a format similar to what is output when the -p option is not used. E.g.</source>
          <target state="translated">比较的结果由这些命令传递到内部的 &quot;diffcore&quot;,格式类似于不使用-p选项时的输出。例如</target>
        </trans-unit>
        <trans-unit id="d6478eddd3e6be6e1f0703d8450a597d1ea3dfe6" translate="yes" xml:space="preserve">
          <source>The result of such a bisection would be that we would find that H is the first bad commit, when in fact it&amp;rsquo;s B. So that would be wrong!</source>
          <target state="translated">这样一分为二的结果是，我们会发现H是第一个错误提交，而实际上是B。所以这是错误的！</target>
        </trans-unit>
        <trans-unit id="9ed4c9f58d5e6595458ce4cb4952fdfe7c07ce9b" translate="yes" xml:space="preserve">
          <source>The resulting command then has an &quot;operation&quot; argument appended to it (see below for details), and the result is executed by the shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baad8b31b0f95aa1296c5c88ad34816424f2926e" translate="yes" xml:space="preserve">
          <source>The resulting directory proj.git contains a &quot;bare&quot; git repository&amp;mdash;​it is just the contents of the &lt;code&gt;.git&lt;/code&gt; directory, without any files checked out around it.</source>
          <target state="translated">产生的目录proj.git包含一个``裸露''的git存储库-它只是 &lt;code&gt;.git&lt;/code&gt; 目录的内容，周围没有任何文件被检出。</target>
        </trans-unit>
        <trans-unit id="31dc4b206e7be8ca9a78c4871cc58f03a5340e5b" translate="yes" xml:space="preserve">
          <source>The revision data is appended to the file if it already exists, for use when doing incremental imports.</source>
          <target state="translated">如果文件中已经存在修订数据,则将其附加到文件中,以便在进行增量导入时使用。</target>
        </trans-unit>
        <trans-unit id="0ca811b30547ebe29846859e95a6c9147e8141b4" translate="yes" xml:space="preserve">
          <source>The rewrite rule guarantees that existing static files will be properly served, whereas any other URL will be passed to gitweb as PATH_INFO parameter.</source>
          <target state="translated">重写规则保证了现有的静态文件将被正确地服务,而其他任何URL将作为PATH_INFO参数传递给gitweb。</target>
        </trans-unit>
        <trans-unit id="7511d9248c0671ec876d283606ae9df0bea2f6b2" translate="yes" xml:space="preserve">
          <source>The ripple effect of a &quot;hard case&quot; recovery is especially bad: &lt;code&gt;everyone&lt;/code&gt; downstream from &lt;code&gt;topic&lt;/code&gt; will now have to perform a &quot;hard case&quot; recovery too!</source>
          <target state="translated">&amp;ldquo;硬案例&amp;rdquo;恢复的连锁反应尤其糟糕： &lt;code&gt;topic&lt;/code&gt; 下游的 &lt;code&gt;everyone&lt;/code&gt; 现在也都必须执行&amp;ldquo;硬案例&amp;rdquo;恢复！</target>
        </trans-unit>
        <trans-unit id="93d5c7537e241865d860131eb6d72edc95c9d772" translate="yes" xml:space="preserve">
          <source>The root of the CVS archive. May be local (a simple path) or remote; currently, only the :local:, :ext: and :pserver: access methods are supported. If not given, &lt;code&gt;git cvsimport&lt;/code&gt; will try to read it from &lt;code&gt;CVS/Root&lt;/code&gt;. If no such file exists, it checks for the &lt;code&gt;CVSROOT&lt;/code&gt; environment variable.</source>
          <target state="translated">CVS存档的根。可以是本地（简单路径）或远程；当前，仅支持：local：，：ext：和：pserver：访问方法。如果未给出， &lt;code&gt;git cvsimport&lt;/code&gt; 将尝试从 &lt;code&gt;CVS/Root&lt;/code&gt; 读取它。如果不存在这样的文件，它将检查 &lt;code&gt;CVSROOT&lt;/code&gt; 环境变量。</target>
        </trans-unit>
        <trans-unit id="df41fdf293aec02e3dee1ead27003284471a1181" translate="yes" xml:space="preserve">
          <source>The root of the tree can be represented by an empty string as &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">树的根可以用空字符串表示为 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="557dc21e01559e09224bc25bcbd6a672b4e3d883" translate="yes" xml:space="preserve">
          <source>The rule to determine which remote branch to merge after fetching is a bit involved, in order not to break backward compatibility.</source>
          <target state="translated">为了不破坏后向兼容性,取完后确定合并哪个远程分支的规则有点牵扯。</target>
        </trans-unit>
        <trans-unit id="bbff5506f0bff9eed6d1a29f80ce8f838449bb56" translate="yes" xml:space="preserve">
          <source>The rules by which the pattern matches paths are the same as in &lt;code&gt;.gitignore&lt;/code&gt; files (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), with a few exceptions:</source>
          <target state="translated">模式匹配路径的规则与 &lt;code&gt;.gitignore&lt;/code&gt; 文件中的规则相同（请参见&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;），但有一些例外：</target>
        </trans-unit>
        <trans-unit id="579e7c08387accae89723ba13e3ec53145837232" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;--merge&lt;/code&gt; option above, but changes the way the conflicting hunks are presented, overriding the &lt;code&gt;merge.conflictStyle&lt;/code&gt; configuration variable. Possible values are &quot;merge&quot; (default) and &quot;diff3&quot; (in addition to what is shown by &quot;merge&quot; style, shows the original contents).</source>
          <target state="translated">与上面的 &lt;code&gt;--merge&lt;/code&gt; 选项相同，但是更改了显示冲突的块的方式，覆盖了 &lt;code&gt;merge.conflictStyle&lt;/code&gt; 配置变量。可能的值为&amp;ldquo;合并&amp;rdquo;（默认）和&amp;ldquo; diff3&amp;rdquo;（除了&amp;ldquo;合并&amp;rdquo;样式显示的内容以外，还显示原始内容）。</target>
        </trans-unit>
        <trans-unit id="1a11cc7f94381fe2de07d484775d2914bf62d241" translate="yes" xml:space="preserve">
          <source>The same as the previous one:</source>
          <target state="translated">与之前的一样。</target>
        </trans-unit>
        <trans-unit id="ebdfbbadd1b4e3e4d3c390aed297730072348592" translate="yes" xml:space="preserve">
          <source>The same rewind and rebuild process may be followed for &lt;code&gt;pu&lt;/code&gt;. A public announcement is not necessary since &lt;code&gt;pu&lt;/code&gt; is a throw-away branch, as described above.</source>
          <target state="translated">&lt;code&gt;pu&lt;/code&gt; 可以遵循相同的倒带和重建过程。如上所述，由于 &lt;code&gt;pu&lt;/code&gt; 是一个一次性分支，因此无需进行公开公告。</target>
        </trans-unit>
        <trans-unit id="982acf1816c2fb0e10e67de1c939cdcea16cc699" translate="yes" xml:space="preserve">
          <source>The same rewind and rebuild process may be followed for &lt;code&gt;seen&lt;/code&gt;. A public announcement is not necessary since &lt;code&gt;seen&lt;/code&gt; is a throw-away branch, as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d931302d20c8d2d3f4d29cdb99720d08f56244" translate="yes" xml:space="preserve">
          <source>The same trailer as a v1 pack file:</source>
          <target state="translated">和v1包文件一样的预告片。</target>
        </trans-unit>
        <trans-unit id="ef6e4cd5de79a2002e4df69090fc16d7024fe532" translate="yes" xml:space="preserve">
          <source>The sample &lt;code&gt;prepare-commit-msg&lt;/code&gt; hook that comes with Git removes the help message found in the commented portion of the commit template.</source>
          <target state="translated">Git附带的样本 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 挂钩删除了在提交模板的注释部分中找到的帮助消息。</target>
        </trans-unit>
        <trans-unit id="0814a224cf6ffffca90b05b46ffd264f8d62f600" translate="yes" xml:space="preserve">
          <source>The sample hooks are all disabled by default. To enable one of the sample hooks rename it by removing its &lt;code&gt;.sample&lt;/code&gt; suffix.</source>
          <target state="translated">默认情况下，样本挂钩均处于禁用状态。要启用其中一个示例挂钩，请通过删除其 &lt;code&gt;.sample&lt;/code&gt; 后缀对其重命名。</target>
        </trans-unit>
        <trans-unit id="ee2f5fb52849fdcd69a62a399938c4c71ec4e36c" translate="yes" xml:space="preserve">
          <source>The sane thing. Just admit you screwed up, and use a different name. Others have already seen one tag-name, and if you keep the same name, you may be in the situation that two people both have &quot;version X&quot;, but they actually have &lt;code&gt;different&lt;/code&gt; &quot;X&quot;'s. So just call it &quot;X.1&quot; and be done with it.</source>
          <target state="translated">理智的事情。只要承认您搞砸了，并使用其他名称即可。其他人已经看到了一个标记名，如果您使用相同的名称，则可能是两个人都有&amp;ldquo; X版本&amp;rdquo;，但实际上却有 &lt;code&gt;different&lt;/code&gt; &amp;ldquo; X&amp;rdquo;。因此，只需将其称为&amp;ldquo; X.1&amp;rdquo;即可完成。</target>
        </trans-unit>
        <trans-unit id="16a78cd21b6c709f016f4a17d2a1069e970db97c" translate="yes" xml:space="preserve">
          <source>The script expects you to provide the key roots where it can start the import from an &lt;code&gt;initial import&lt;/code&gt; or &lt;code&gt;tag&lt;/code&gt; type of Arch commit. It will follow and import new branches within the provided roots.</source>
          <target state="translated">该脚本希望您提供密钥根，以便从 &lt;code&gt;initial import&lt;/code&gt; 或Arch提交的 &lt;code&gt;tag&lt;/code&gt; 类型开始导入。它将遵循并在提供的根目录中导入新分支。</target>
        </trans-unit>
        <trans-unit id="793ca81ee99913a2e3edc7ca33209f79549422e8" translate="yes" xml:space="preserve">
          <source>The scriptlet sets &lt;code&gt;GIT_DIR&lt;/code&gt; and &lt;code&gt;GIT_OBJECT_DIRECTORY&lt;/code&gt; shell variables, but does &lt;strong&gt;not&lt;/strong&gt; export them to the environment.</source>
          <target state="translated">脚本集设置了 &lt;code&gt;GIT_DIR&lt;/code&gt; 和 &lt;code&gt;GIT_OBJECT_DIRECTORY&lt;/code&gt; Shell变量，但是&lt;strong&gt;没有&lt;/strong&gt;将它们导出到环境中。</target>
        </trans-unit>
        <trans-unit id="8b53f7beee61a37b0174ea389f5f36080ff3c1b7" translate="yes" xml:space="preserve">
          <source>The second .gitignore prevents Git from ignoring &lt;code&gt;arch/foo/kernel/vmlinux.lds.S&lt;/code&gt;.</source>
          <target state="translated">第二个.gitignore防止Git忽略 &lt;code&gt;arch/foo/kernel/vmlinux.lds.S&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc737587a80c0c07a4fffd3646c479ff0f86cddd" translate="yes" xml:space="preserve">
          <source>The second example demonstrates that you can abbreviate the object name to only the first several hexadecimal digits in most places.</source>
          <target state="translated">第二个例子表明,你可以在大多数地方将对象名称缩写为只有前几位十六进制数字。</target>
        </trans-unit>
        <trans-unit id="2890a9def3fff903603dee47b68cd9b5af108707" translate="yes" xml:space="preserve">
          <source>The second format is what gets used when &lt;code&gt;--stage=all&lt;/code&gt;. The three stage temporary fields (stage1temp, stage2temp, stage3temp) list the name of the temporary file if there is a stage entry in the index or &lt;code&gt;.&lt;/code&gt; if there is no stage entry. Paths which only have a stage 0 entry will always be omitted from the output.</source>
          <target state="translated">第二种格式是 &lt;code&gt;--stage=all&lt;/code&gt; 时使用的格式。如果索引或中有一个阶段条目，则三个阶段的临时字段（stage1temp，stage2temp，stage3temp）将列出临时文件的名称 &lt;code&gt;.&lt;/code&gt; 如果没有阶段入口。仅具有阶段0条目的路径将始终从输出中省略。</target>
        </trans-unit>
        <trans-unit id="8a6f107e4f2dc8b17455f1349e940becb9fc3a6b" translate="yes" xml:space="preserve">
          <source>The second issue is one of auditing. When many contributors are working on the same repository, it is important which merge commits introduced a change into an important branch. The problematic merge &lt;code&gt;R&lt;/code&gt; above is not likely to be the merge commit that was used to merge into an important branch. Instead, the merge &lt;code&gt;N&lt;/code&gt; was used to merge &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; into the important branch. This commit may have information about why the change &lt;code&gt;X&lt;/code&gt; came to override the changes from &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in its commit message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b87f951d8d8be1a02da6e062a3489256945d73" translate="yes" xml:space="preserve">
          <source>The second parameter passed to the hook is the indicator for whether or not the index was updated and the skip-worktree bit could have changed. &quot;1&quot; meaning skip-worktree bits could have been updated and &quot;0&quot; meaning they were not.</source>
          <target state="translated">传递给钩子的第二个参数是索引是否被更新和skip-worktree位是否可能发生变化的指示器,&quot;1 &quot;表示skip-worktree位可能被更新,&quot;0 &quot;表示没有被更新。&quot;1 &quot;表示skip-worktree位可能已经更新,&quot;0 &quot;表示没有更新。</target>
        </trans-unit>
        <trans-unit id="b730007914036d9f0fb3ba6052d64853bae216ae" translate="yes" xml:space="preserve">
          <source>The second syntax (&quot;&lt;code&gt;git merge --abort&lt;/code&gt;&quot;) can only be run after the merge has resulted in conflicts. &lt;code&gt;git merge --abort&lt;/code&gt; will abort the merge process and try to reconstruct the pre-merge state. However, if there were uncommitted changes when the merge started (and especially if those changes were further modified after the merge was started), &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to reconstruct the original (pre-merge) changes. Therefore:</source>
          <target state="translated">第二种语法（&amp;ldquo; &lt;code&gt;git merge --abort&lt;/code&gt; &amp;rdquo;）只能在合并导致冲突后运行。 &lt;code&gt;git merge --abort&lt;/code&gt; 将中止合并过程，并尝试重建合并前的状态。但是，如果在合并开始时有未提交的更改（尤其是在合并开始后进一步修改了这些更改），则 &lt;code&gt;git merge --abort&lt;/code&gt; 在某些情况下将无法重建原始（合并前）更改。因此：</target>
        </trans-unit>
        <trans-unit id="1f7dcee78b5872602756cd0d868ad6253db301fe" translate="yes" xml:space="preserve">
          <source>The second transformation in the chain is diffcore-break, and is controlled by the -B option to the &lt;code&gt;git diff-*&lt;/code&gt; commands. This is used to detect a filepair that represents &quot;complete rewrite&quot; and break such filepair into two filepairs that represent delete and create. E.g. If the input contained this filepair:</source>
          <target state="translated">链中的第二个转换是diffcore-break，由 &lt;code&gt;git diff-*&lt;/code&gt; 命令的-B选项控制。这用于检测代表&amp;ldquo;完全重写&amp;rdquo;的文件对，并将该文件对分为代表删除和创建的两个文件对。例如，如果输入包含此文件对：</target>
        </trans-unit>
        <trans-unit id="5aa738048a0181b9705365955bd04c18156f9d33" translate="yes" xml:space="preserve">
          <source>The section &lt;code&gt;submodule.foo.*&lt;/code&gt; in the &lt;code&gt;.gitmodules&lt;/code&gt; file gives additional hints to Git&amp;rsquo;s porcelain layer. For example, the &lt;code&gt;submodule.foo.url&lt;/code&gt; setting specifies where to obtain the submodule.</source>
          <target state="translated">&lt;code&gt;.gitmodules&lt;/code&gt; 文件中的 &lt;code&gt;submodule.foo.*&lt;/code&gt; 部分为Git的瓷器层提供了其他提示。例如， &lt;code&gt;submodule.foo.url&lt;/code&gt; 设置指定从何处获取子模块。</target>
        </trans-unit>
        <trans-unit id="addff8a92e5ddb901ae8a38330bc2dcce4be9fbb" translate="yes" xml:space="preserve">
          <source>The section or key is invalid (ret=1),</source>
          <target state="translated">节或键无效(ret=1)。</target>
        </trans-unit>
        <trans-unit id="463ba2454fad2719570e32271a038c3acce699a7" translate="yes" xml:space="preserve">
          <source>The server MUST NOT send any &quot;unshallow&quot; lines for anything which the client has not indicated was shallow as a part of its request.</source>
          <target state="translated">服务器绝不能发送任何 &quot;不浅 &quot;的行,如果客户在请求中没有说明是浅的,则必须发送。</target>
        </trans-unit>
        <trans-unit id="d868af4cbdec034778f61defdf53e9a4307fd341" translate="yes" xml:space="preserve">
          <source>The server MUST NOT send any refs which were not requested using &lt;code&gt;want-ref&lt;/code&gt; lines.</source>
          <target state="translated">服务器不得发送任何没有使用 &lt;code&gt;want-ref&lt;/code&gt; 线请求的参考。</target>
        </trans-unit>
        <trans-unit id="446930d87bed0e82e29e329dd081708ba37057c2" translate="yes" xml:space="preserve">
          <source>The server can advertise the &lt;code&gt;agent&lt;/code&gt; capability with a value &lt;code&gt;X&lt;/code&gt; (in the form &lt;code&gt;agent=X&lt;/code&gt;) to notify the client that the server is running version &lt;code&gt;X&lt;/code&gt;. The client may optionally send its own agent string by including the &lt;code&gt;agent&lt;/code&gt; capability with a value &lt;code&gt;Y&lt;/code&gt; (in the form &lt;code&gt;agent=Y&lt;/code&gt;) in its request to the server (but it MUST NOT do so if the server did not advertise the agent capability). The &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; strings may contain any printable ASCII characters except space (i.e., the byte range 32 &amp;lt; x &amp;lt; 127), and are typically of the form &quot;package/version&quot; (e.g., &quot;git/1.8.3.1&quot;). The agent strings are purely informative for statistics and debugging purposes, and MUST NOT be used to programmatically assume the presence or absence of particular features.</source>
          <target state="translated">服务器可以使用值 &lt;code&gt;X&lt;/code&gt; （以 &lt;code&gt;agent=X&lt;/code&gt; 的形式）通告 &lt;code&gt;agent&lt;/code&gt; 功能，以通知客户端服务器正在运行 &lt;code&gt;X&lt;/code&gt; 版本。客户端可以选择将自己的代理字符串发送给服务器，方法是在请求中包括一个具有 &lt;code&gt;Y&lt;/code&gt; 值（形式为 &lt;code&gt;agent=Y&lt;/code&gt; ）的 &lt;code&gt;agent&lt;/code&gt; 功能（但如果服务器未公布代理功能，则它一定不要这样做）。在 &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;Y&lt;/code&gt; ^字符串可以包含除空格（即字节范围32 &amp;lt;x &amp;lt;127）之外的任何可打印ASCII字符，并且通常采用&amp;ldquo;包/版本&amp;rdquo;形式（例如，&amp;ldquo; git / 1.8.3.1&amp;rdquo;）。代理字符串仅出于统计和调试目的提供信息，不得用于以编程方式假定是否存在特定功能。</target>
        </trans-unit>
        <trans-unit id="5d8f08f3df19bb2371d7bbd09e4f22512a514d87" translate="yes" xml:space="preserve">
          <source>The server can advertise the &lt;code&gt;object-format&lt;/code&gt; capability with a value &lt;code&gt;X&lt;/code&gt; (in the form &lt;code&gt;object-format=X&lt;/code&gt;) to notify the client that the server is able to deal with objects using hash algorithm X. If not specified, the server is assumed to only handle SHA-1. If the client would like to use a hash algorithm other than SHA-1, it should specify its object-format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c71d3c4f66b93dbf4d80cac3ad0ba90c74cbf8" translate="yes" xml:space="preserve">
          <source>The server may advertise a session ID that can be used to identify this process across multiple requests. The client may advertise its own session ID back to the server as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dbb8fc2dd2ef1317864e26b0a2f75da26a1d7f0" translate="yes" xml:space="preserve">
          <source>The server sends a &quot;shallow obj-id&quot; line for each commit whose parents will not be sent in the following packfile.</source>
          <target state="translated">服务器为每个提交发送一个 &quot;浅层obj-id &quot;行,其父母不会在下面的packfile中发送。</target>
        </trans-unit>
        <trans-unit id="15cbc52acb55c8a437e7a9fc2cb2ebb8c994afc3" translate="yes" xml:space="preserve">
          <source>The server sends an &quot;unshallow obj-id&quot; line for each commit which the client has indicated is shallow, but is no longer shallow as a result of the fetch (due to its parents being sent in the following packfile).</source>
          <target state="translated">服务器为每一个提交发送 &quot;unshallow obj-id &quot;行,客户端已经表示该提交是浅层的,但由于取回的结果已经不再是浅层的了(由于它的父体被发送到下面的packfile中)。</target>
        </trans-unit>
        <trans-unit id="3f482eecb5e3fca563243c0419eece540e0582ac" translate="yes" xml:space="preserve">
          <source>The server will respond with &quot;ACK obj-id&quot; for all of the object ids sent as have lines which are common.</source>
          <target state="translated">服务器将以 &quot;ACK obj-id &quot;回应所有发送的对象id,因为有行是共同的。</target>
        </trans-unit>
        <trans-unit id="543a974b0aa8c62d541ca2830198235b945cc003" translate="yes" xml:space="preserve">
          <source>The server will respond with &quot;NAK&quot; if none of the object ids sent as have lines were common.</source>
          <target state="translated">如果作为have行发送的对象id没有一个是共同的,服务器将以 &quot;NAK &quot;回应。</target>
        </trans-unit>
        <trans-unit id="568256da628f1737b5310a22de9a07629ce73e0d" translate="yes" xml:space="preserve">
          <source>The server will respond with a &quot;ready&quot; line indicating that the server has found an acceptable common base and is ready to make and send a packfile (which will be found in the packfile section of the same response)</source>
          <target state="translated">服务器将以 &quot;准备好了 &quot;行来回应,表示服务器已经找到了一个可接受的公共基础,并准备好制作和发送一个packfile(它将在同一响应的packfile部分找到)。</target>
        </trans-unit>
        <trans-unit id="69ff3eec8c55e5a8095ea13f51e31e429dc845d6" translate="yes" xml:space="preserve">
          <source>The server will send a ref listing (&quot;&amp;lt;oid&amp;gt; &amp;lt;refname&amp;gt;&quot;) for each reference requested using &lt;code&gt;want-ref&lt;/code&gt; lines.</source>
          <target state="translated">服务器将使用旺旺 &lt;code&gt;want-ref&lt;/code&gt; 线为每个请求的参考发送参考列表（&amp;ldquo; &amp;lt;oid&amp;gt; &amp;lt;参考名称&amp;gt;&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="afb7e2ac1ca268d29d3dabe65a1485bc3c99ebf1" translate="yes" xml:space="preserve">
          <source>The server will then check to ensure that the client&amp;rsquo;s request is comprised of a valid command as well as valid capabilities which were advertised. If the request is valid the server will then execute the command. A server MUST wait till it has received the client&amp;rsquo;s entire request before issuing a response. The format of the response is determined by the command being executed, but in all cases a flush-pkt indicates the end of the response.</source>
          <target state="translated">然后，服务器将检查以确保客户端的请求包含有效的命令以及已通告的有效功能。如果请求有效，则服务器将执行命令。服务器必须等到收到客户端的整个请求后再发出响应。响应的格式由正在执行的命令确定，但在所有情况下，flush-pkt均指示响应结束。</target>
        </trans-unit>
        <trans-unit id="537b1e0777fad4eaaafbf4ccf5940ab37b1e2ed6" translate="yes" xml:space="preserve">
          <source>The shared index part, to be referenced by $GIT_DIR/index and other temporary index files. Only valid in split index mode.</source>
          <target state="translated">共享索引部分,由$GIT_DIR/index和其他临时索引文件引用。仅在分割索引模式下有效。</target>
        </trans-unit>
        <trans-unit id="d11a14c0103fd18e1ebb96bcb7251e0f8abbce80" translate="yes" xml:space="preserve">
          <source>The shift magic first throws away the tree id and then the -p parameters. Note that this handles merges properly! In case Darl committed a merge between P1 and P2, it will be propagated properly and all children of the merge will become merge commits with P1,P2 as their parents instead of the merge commit.</source>
          <target state="translated">Shift魔术首先抛开树的id,然后抛开-p参数。请注意,这样可以正确处理合并 如果Darl在P1和P2之间提交了一个合并,它将被正确地传播,所有合并的子代将成为以P1,P2为父代的合并提交,而不是合并提交。</target>
        </trans-unit>
        <trans-unit id="e33b2d8b27401f604cb70ad4d214df90a2abf20c" translate="yes" xml:space="preserve">
          <source>The similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one.</source>
          <target state="translated">相似性指数是指没有变化的线条的百分比,而不相似性指数是指变化线条的百分比。它是一个四舍五入的整数,后面有一个百分号。因此,相似度指数值为100%是为两个相等的文件保留的,而100%的不相似度意味着旧文件中没有行进入新文件。</target>
        </trans-unit>
        <trans-unit id="09f0c715250f8ac9e78727d6768d66502facff83" translate="yes" xml:space="preserve">
          <source>The simplest commit to find is the HEAD commit, which we can find from .git/HEAD:</source>
          <target state="translated">最简单的提交是head提交,我们可以从.git/HEAD中找到。</target>
        </trans-unit>
        <trans-unit id="938f800e1b465bd0f07eb377492ba2456bfbed2c" translate="yes" xml:space="preserve">
          <source>The simplest way to do this is using &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and ssh; to update the remote branch named &lt;code&gt;master&lt;/code&gt; with the latest state of your branch named &lt;code&gt;master&lt;/code&gt;, run</source>
          <target state="translated">最简单的方法是使用&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;和ssh; 更新名为远程分支 &lt;code&gt;master&lt;/code&gt; 与你的分支命名的最新状态 &lt;code&gt;master&lt;/code&gt; ，跑</target>
        </trans-unit>
        <trans-unit id="a5eba655ac4b55a1106bdc6c6dbf2b0d1ad04c8a" translate="yes" xml:space="preserve">
          <source>The simplest way to mark a file as binary is to unset the diff attribute in the &lt;code&gt;.gitattributes&lt;/code&gt; file:</source>
          <target state="translated">将文件标记为二进制的最简单方法是取消设置 &lt;code&gt;.gitattributes&lt;/code&gt; 文件中的diff属性：</target>
        </trans-unit>
        <trans-unit id="0f95b7ebe5f42d4f0766af1eda2b35efa6854fa9" translate="yes" xml:space="preserve">
          <source>The size in bytes of the commit or tag message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99bb329f9f9a76ae9c81982693e8d5911709e87c" translate="yes" xml:space="preserve">
          <source>The size of the object (the same as &lt;code&gt;git cat-file -s&lt;/code&gt; reports). Append &lt;code&gt;:disk&lt;/code&gt; to get the size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the &lt;code&gt;CAVEATS&lt;/code&gt; section below.</source>
          <target state="translated">对象的大小（与 &lt;code&gt;git cat-file -s&lt;/code&gt; 报告相同）。附加 &lt;code&gt;:disk&lt;/code&gt; 以获取对象占用磁盘的大小（以字节为单位）。请参阅下面的&amp;ldquo; &lt;code&gt;CAVEATS&lt;/code&gt; 部分中有关磁盘大小的注释。</target>
        </trans-unit>
        <trans-unit id="3527fa64b6fd749102c379b2fd96b0df5cd454cb" translate="yes" xml:space="preserve">
          <source>The size of the window used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; when no window size is given on the command line. Defaults to 10.</source>
          <target state="translated">窗口的大小使用&lt;a href=&quot;git-pack-objects&quot;&gt;GIT中包对象[1]&lt;/a&gt;当在命令行上没有给出窗口大小。默认为10</target>
        </trans-unit>
        <trans-unit id="2372575566ae8c805d7580bdcbad6da1c4463611" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the object (the same as &lt;code&gt;cat-file -s&lt;/code&gt; reports).</source>
          <target state="translated">对象的大小（以字节为单位）（与 &lt;code&gt;cat-file -s&lt;/code&gt; 报告相同）。</target>
        </trans-unit>
        <trans-unit id="43c333a5a6bd3bca8b34d5163a7aa7b6d79d2d40" translate="yes" xml:space="preserve">
          <source>The size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the &lt;code&gt;CAVEATS&lt;/code&gt; section below.</source>
          <target state="translated">对象在磁盘上占用的大小（以字节为单位）。请参阅下面的&amp;ldquo; &lt;code&gt;CAVEATS&lt;/code&gt; 部分中有关磁盘大小的注释。</target>
        </trans-unit>
        <trans-unit id="7d544171c06a9cb39c4059f830c0a8558d3922c9" translate="yes" xml:space="preserve">
          <source>The slash &lt;code&gt;/&lt;/code&gt; is used as the directory separator. Separators may occur at the beginning, middle or end of the &lt;code&gt;.gitignore&lt;/code&gt; search pattern.</source>
          <target state="translated">斜杠 &lt;code&gt;/&lt;/code&gt; 用作目录分隔符。分隔符可以出现在 &lt;code&gt;.gitignore&lt;/code&gt; 搜索模式的开始，中间或结尾。</target>
        </trans-unit>
        <trans-unit id="e18b2266f1b1b9062e466bd05dd697dc8d44c68f" translate="yes" xml:space="preserve">
          <source>The smaller the changes in your commit, the most effective &quot;git bisect&quot; will be. And you will probably need &quot;git bisect&quot; less in the first place, as small changes are easier to review even if they are only reviewed by the committer.</source>
          <target state="translated">提交的改动越小,&quot;git bisect &quot;就越有效。而且你可能会减少对 &quot;git bisect &quot;的需求,因为小的改动即使只有提交者审查,也更容易审查。</target>
        </trans-unit>
        <trans-unit id="0dab2fe7462a5d0c0b797d08e789dbaaf7bfa1df" translate="yes" xml:space="preserve">
          <source>The smart HTTP server, &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend[1]&lt;/a&gt;, will pass GIT_NAMESPACE through to the backend programs; see &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend[1]&lt;/a&gt; for sample configuration to expose repository namespaces as repositories.</source>
          <target state="translated">智能HTTP服务器&lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend [1]&lt;/a&gt;会将GIT_NAMESPACE传递给后端程序；请参阅&lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend [1]&lt;/a&gt;以获得用于将存储库名称空间公开为存储库的示例配置。</target>
        </trans-unit>
        <trans-unit id="9ee3be6f644f850e9ae409b580b74ced862493f8" translate="yes" xml:space="preserve">
          <source>The solution, of course, is to make a merge that we can undo: merge into a throw-away branch.</source>
          <target state="translated">当然,解决的办法是做一个我们可以撤销的合并:合并成一个扔掉的分支。</target>
        </trans-unit>
        <trans-unit id="8a1117f540255f9a5dcffa1baa25558f77657b0e" translate="yes" xml:space="preserve">
          <source>The special case of restarting an incremental import from the current branch value should be written as:</source>
          <target state="translated">从当前分支值重新启动增量导入的特殊情况应写成:。</target>
        </trans-unit>
        <trans-unit id="3599d1b8b89ee48d0b633dcff9041c57284c3251" translate="yes" xml:space="preserve">
          <source>The special exit code 125 should be used when the current source code cannot be tested. If the script exits with this code, the current revision will be skipped (see &lt;code&gt;git bisect skip&lt;/code&gt; above). 125 was chosen as the highest sensible value to use for this purpose, because 126 and 127 are used by POSIX shells to signal specific error status (127 is for command not found, 126 is for command found but not executable&amp;mdash;​these details do not matter, as they are normal errors in the script, as far as &lt;code&gt;bisect run&lt;/code&gt; is concerned).</source>
          <target state="translated">当无法测试当前源代码时，应使用特殊的退出代码125。如果脚本以该代码退出，则当前版本将被跳过（请参见上面的 &lt;code&gt;git bisect skip&lt;/code&gt; ）。 125被选为用于此目的的最高明智值，因为POSIX shell使用126和127来表示特定的错误状态（127用于未找到命令，126用于发现命令但不可执行-这些详细信息不无关紧要，因为就 &lt;code&gt;bisect run&lt;/code&gt; 而言，它们是脚本中的正常错误）。</target>
        </trans-unit>
        <trans-unit id="60ac8fe2a99f998c150bb7d9adc8dfbeed95a10d" translate="yes" xml:space="preserve">
          <source>The special null SHA-1 (40 zeros) specifies that the branch is to be removed.</source>
          <target state="translated">特殊的空SHA-1(40个零)指定要删除的分支。</target>
        </trans-unit>
        <trans-unit id="a4c2fa6682338e4d7c45557107add1984be0213c" translate="yes" xml:space="preserve">
          <source>The special refspec &lt;code&gt;:&lt;/code&gt; (or &lt;code&gt;+:&lt;/code&gt; to allow non-fast-forward updates) directs Git to push &quot;matching&quot; branches: for every branch that exists on the local side, the remote side is updated if a branch of the same name already exists on the remote side.</source>
          <target state="translated">特殊的refspec &lt;code&gt;:&lt;/code&gt; (或 &lt;code&gt;+:&lt;/code&gt; 允许非快速转发更新）指示Git推送&amp;ldquo;匹配&amp;rdquo;分支：对于本地存在的每个分支，如果已经存在同名的分支，则更新远程端在远端。</target>
        </trans-unit>
        <trans-unit id="f2f702d2704e1b64279419d712ca4460c3b7f78e" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;none&lt;/code&gt; can be used as the proxy command to specify that no proxy be used for a given domain pattern. This is useful for excluding servers inside a firewall from proxy use, while defaulting to a common proxy for external domains.</source>
          <target state="translated">特殊字符串 &lt;code&gt;none&lt;/code&gt; 可用作代理命令，以指定对于给定的域模式，不使用任何代理。这对于将防火墙内部的服务器从代理使用中排除，而默认使用外部域的通用代理很有用。</target>
        </trans-unit>
        <trans-unit id="65b859a3a4528b4a1eebafeebe9d2d28ac0eb085" translate="yes" xml:space="preserve">
          <source>The special symbol &quot;HEAD&quot; can always be used to refer to the current branch. In fact, Git uses a file named &lt;code&gt;HEAD&lt;/code&gt; in the &lt;code&gt;.git&lt;/code&gt; directory to remember which branch is current:</source>
          <target state="translated">特殊符号&amp;ldquo; HEAD&amp;rdquo;始终可以用于引用当前分支。实际上，Git 在 &lt;code&gt;.git&lt;/code&gt; 目录中使用一个名为 &lt;code&gt;HEAD&lt;/code&gt; 的文件来记住哪个分支是当前的：</target>
        </trans-unit>
        <trans-unit id="54b91d851f1b23aa70b29c0e74d2c28879b6de30" translate="yes" xml:space="preserve">
          <source>The ssh and git protocols additionally support ~username expansion:</source>
          <target state="translated">ssh和git协议另外支持~username扩展。</target>
        </trans-unit>
        <trans-unit id="ac6c6d73b5f6b7c3cef28dfe32da61495601bd7c" translate="yes" xml:space="preserve">
          <source>The standard actions are:</source>
          <target state="translated">标准行动是:</target>
        </trans-unit>
        <trans-unit id="a72f515f06e2719cd062e161d9ed80a61b68c92f" translate="yes" xml:space="preserve">
          <source>The standard email format as described by RFC 2822, for example &lt;code&gt;Thu, 07 Apr 2005 22:13:13 +0200&lt;/code&gt;.</source>
          <target state="translated">RFC 2822描述的标准电子邮件格式，例如 &lt;code&gt;Thu, 07 Apr 2005 22:13:13 +0200&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8128f4cfe82d86e129a0094608260664c3bb1ba3" translate="yes" xml:space="preserve">
          <source>The standard helper program to use with git-merge-index</source>
          <target state="translated">使用git-merge-index的标准帮助程序。</target>
        </trans-unit>
        <trans-unit id="4d34b021b617aa2bf3f93982ac428b041f085fbe" translate="yes" xml:space="preserve">
          <source>The starting point for the new branch. Specifying a &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; allows you to create a branch based on some other point in history than where HEAD currently points. (Or, in the case of &lt;code&gt;--detach&lt;/code&gt;, allows you to inspect and detach from some other point.)</source>
          <target state="translated">新分支的起点。指定 &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; 允许您基于历史记录中除HEAD当前指向的其他点来创建分支。（或者，在 &lt;code&gt;--detach&lt;/code&gt; 的情况下，允许您检查其他点并与之分离。）</target>
        </trans-unit>
        <trans-unit id="ca9ba47b83a1def4d8a6c769f2e642f061d5236a" translate="yes" xml:space="preserve">
          <source>The status of GPG verification of the push certificate, using the same mnemonic as used in &lt;code&gt;%G?&lt;/code&gt; format of &lt;code&gt;git log&lt;/code&gt; family of commands (see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;).</source>
          <target state="translated">使用与 &lt;code&gt;%G?&lt;/code&gt; 使用的相同的助记符对推送证书进行GPG验证的状态？ &lt;code&gt;git log&lt;/code&gt; 系列命令的格式（请参阅&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c902748a09ab505851b0b39809c60f3db2027be9" translate="yes" xml:space="preserve">
          <source>The status of the fetch is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</source>
          <target state="translated">取数的状态以表格形式输出,每一行代表一个ref的状态。每一行都是这样的形式。</target>
        </trans-unit>
        <trans-unit id="7729563c964ef73ba71f39abfa320766ac0cea33" translate="yes" xml:space="preserve">
          <source>The status of the push is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</source>
          <target state="translated">推送的状态以表格的形式输出,每一行代表一个参考的状态。每行的形式为:</target>
        </trans-unit>
        <trans-unit id="e939f21e3282d453b1398071feb25115360b90b4" translate="yes" xml:space="preserve">
          <source>The status of up-to-date refs is shown only if --porcelain or --verbose option is used.</source>
          <target state="translated">只有在使用--porcelain或--verbose选项时,才会显示最新参考资料的状态。</target>
        </trans-unit>
        <trans-unit id="0ebfa7ce02ec5605e425e0cd98062f5bbd8f2510" translate="yes" xml:space="preserve">
          <source>The status of up-to-date refs is shown only if the --verbose option is used.</source>
          <target state="translated">只有在使用--verbose选项时,才会显示最新的参考资料的状态。</target>
        </trans-unit>
        <trans-unit id="a97643bd561fabe3d136679e4752cb73667ec062" translate="yes" xml:space="preserve">
          <source>The structured objects can further have their structure and connectivity to other objects verified. This is generally done with the &lt;code&gt;git fsck&lt;/code&gt; program, which generates a full dependency graph of all objects, and verifies their internal consistency (in addition to just verifying their superficial consistency through the hash).</source>
          <target state="translated">结构化对象还可以验证其结构和与其他对象的连接性。通常使用 &lt;code&gt;git fsck&lt;/code&gt; 程序完成此操作，该程序会生成所有对象的完整依赖关系图，并验证其内部一致性（除了仅通过哈希验证其表面一致性之外）。</target>
        </trans-unit>
        <trans-unit id="af4ab93b8907c3bc82033e90c4bc6eedaac09e1c" translate="yes" xml:space="preserve">
          <source>The submit process invokes the editor before each p4 change is submitted. If this setting is true, though, the editing step is skipped.</source>
          <target state="translated">在每次提交p4修改之前,提交过程都会调用编辑器。但如果此设置为真,则会跳过编辑步骤。</target>
        </trans-unit>
        <trans-unit id="72386229ffdfc0f6ba847ccdd7620fcafabeae30" translate="yes" xml:space="preserve">
          <source>The submodule directories are there, but they&amp;rsquo;re empty:</source>
          <target state="translated">子模块目录在那里，但它们为空：</target>
        </trans-unit>
        <trans-unit id="802b1c9a36cac97c548242e11fe5baa3275576f0" translate="yes" xml:space="preserve">
          <source>The submodule will never be considered modified (but will nonetheless show up in the output of status and commit when it has been staged).</source>
          <target state="translated">这个子模块永远不会被认为是修改过的(但当它被分期时,还是会显示在状态和提交的输出中)。</target>
        </trans-unit>
        <trans-unit id="7180d60887d97b6ca57dd91c2b86681f019ca631" translate="yes" xml:space="preserve">
          <source>The submodule&amp;rsquo;s &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file would come into play when running &lt;code&gt;git push --recurse-submodules=check&lt;/code&gt; in the superproject, as this would check if the submodule has any changes not published to any remote. The remotes are configured in the submodule as usual in the &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file.</source>
          <target state="translated">在超级项目中运行 &lt;code&gt;git push --recurse-submodules=check&lt;/code&gt; 时，子模块的 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件将起作用，因为这将检查子模块是否有未发布到任何远程的更改。遥控器通常在 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件的子模块中进行配置。</target>
        </trans-unit>
        <trans-unit id="2a87578b15befa74b2d27eca3216884ceb35493c" translate="yes" xml:space="preserve">
          <source>The suffix &lt;code&gt;@{push}&lt;/code&gt; reports the branch &quot;where we would push to&quot; if &lt;code&gt;git push&lt;/code&gt; were run while &lt;code&gt;branchname&lt;/code&gt; was checked out (or the current &lt;code&gt;HEAD&lt;/code&gt; if no branchname is specified). Since our push destination is in a remote repository, of course, we report the local tracking branch that corresponds to that branch (i.e., something in &lt;code&gt;refs/remotes/&lt;/code&gt;).</source>
          <target state="translated">如果在 &lt;code&gt;branchname&lt;/code&gt; 时运行了 &lt;code&gt;git push&lt;/code&gt; ,则后缀 &lt;code&gt;@{push}&lt;/code&gt; 报告分支&amp;ldquo;我们将推送至的位置&amp;rdquo; （如果未指定branchname，则返回当前 &lt;code&gt;HEAD&lt;/code&gt; ）。由于推送目标位于远程存储库中，因此，我们当然会报告与该分支相对应的本地跟踪分支（即 &lt;code&gt;refs/remotes/&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c10fd9c6c93e1de11dbe32978aa15d853b4103fb" translate="yes" xml:space="preserve">
          <source>The suffix &lt;code&gt;@{upstream}&lt;/code&gt; to a branchname (short form &lt;code&gt;&amp;lt;branchname&amp;gt;@{u}&lt;/code&gt;) refers to the branch that the branch specified by branchname is set to build on top of (configured with &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;). A missing branchname defaults to the current one. These suffixes are also accepted when spelled in uppercase, and they mean the same thing no matter the case.</source>
          <target state="translated">分支名称的后缀 &lt;code&gt;@{upstream}&lt;/code&gt; （缩写为 &lt;code&gt;&amp;lt;branchname&amp;gt;@{u}&lt;/code&gt; ）是指分支名称所指定的分支被设置为建立在该分支之上（由 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 和 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; ）。缺少的分支名称默认为当前分支名称。这些后缀大写时也会被接受，无论大小写，它们都具有相同的含义。</target>
        </trans-unit>
        <trans-unit id="35fca7d90e0c51050df5863335fd96cb674d847a" translate="yes" xml:space="preserve">
          <source>The symlink will either be absolute (beginning with a /), or relative to the tree root. For instance, if dir/link points to ../../foo, then &amp;lt;symlink&amp;gt; will be ../foo. &amp;lt;size&amp;gt; is the size of the symlink in bytes.</source>
          <target state="translated">符号链接可以是绝对的（以/开头），也可以是相对于树根的符号。例如，如果dir / link指向../../foo，则&amp;lt;symlink&amp;gt;将是../foo。&amp;lt;size&amp;gt;是符号链接的大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="1e32c77f2578ce3c979cd217827d9aa3c6897be9" translate="yes" xml:space="preserve">
          <source>The syntax is fairly flexible and permissive; whitespaces are mostly ignored. The &lt;code&gt;#&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; characters begin comments to the end of line, blank lines are ignored.</source>
          <target state="translated">语法相当灵活且允许。空格通常被忽略。该 &lt;code&gt;#&lt;/code&gt; 和 &lt;code&gt;;&lt;/code&gt; 字符从注释开始到行尾，空白行将被忽略。</target>
        </trans-unit>
        <trans-unit id="e9a240786337cb206c43c416821000b9a6721022" translate="yes" xml:space="preserve">
          <source>The syntax of the configuration files is that of Perl, since these files are handled by sourcing them as fragments of Perl code (the language that gitweb itself is written in). Variables are typically set using the &lt;code&gt;our&lt;/code&gt; qualifier (as in &quot;&lt;code&gt;our $variable = &amp;lt;value&amp;gt;;&lt;/code&gt;&quot;) to avoid syntax errors if a new version of gitweb no longer uses a variable and therefore stops declaring it.</source>
          <target state="translated">配置文件的语法是Perl的语法，因为这些文件是通过将它们作为Perl代码的片段（gitweb本身所使用的语言）来提供来处理的。变量是使用通常设置 &lt;code&gt;our&lt;/code&gt; 限定符（如在&amp;ldquo; &lt;code&gt;our $variable = &amp;lt;value&amp;gt;;&lt;/code&gt; 以避免语法错误如果叫做gitweb的新版本不再使用一个变量，并因此停止它声明&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="85d5722bf15562fb833fe3c8f580a92fe2e2d3db" translate="yes" xml:space="preserve">
          <source>The tables below show what happens when running:</source>
          <target state="translated">下表显示了运行时的情况。</target>
        </trans-unit>
        <trans-unit id="0ab961c529e0da6916842ede03d74fc7b0e0f90e" translate="yes" xml:space="preserve">
          <source>The tag &lt;code&gt;v2.6.18&lt;/code&gt; is short for &lt;code&gt;refs/tags/v2.6.18&lt;/code&gt;.</source>
          <target state="translated">标签 &lt;code&gt;v2.6.18&lt;/code&gt; 是 &lt;code&gt;refs/tags/v2.6.18&lt;/code&gt; 的缩写。</target>
        </trans-unit>
        <trans-unit id="e5173af0305c1d6df2de24b7ea317c256f65109e" translate="yes" xml:space="preserve">
          <source>The template directory will be one of the following (in order):</source>
          <target state="translated">模板目录将是以下之一(按顺序)。</target>
        </trans-unit>
        <trans-unit id="45d4fdaf8fe9ac583ec50051c8f5eb8c944a1ec1" translate="yes" xml:space="preserve">
          <source>The term &lt;a href=&quot;#def_pickaxe&quot;&gt;pickaxe&lt;/a&gt; refers to an option to the diffcore routines that help select changes that add or delete a given text string. With the &lt;code&gt;--pickaxe-all&lt;/code&gt; option, it can be used to view the full &lt;a href=&quot;#def_changeset&quot;&gt;changeset&lt;/a&gt; that introduced or removed, say, a particular line of text. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">术语&lt;a href=&quot;#def_pickaxe&quot;&gt;镐&lt;/a&gt;是指diffcore例程的一个选项，该选项有助于选择添加或删除给定文本字符串的更改。使用 &lt;code&gt;--pickaxe-all&lt;/code&gt; 选项，它可以用于查看引入或删除的完整&lt;a href=&quot;#def_changeset&quot;&gt;变更集&lt;/a&gt;，例如，特定的文本行。参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2ba0595fa8d197d8c3640c03007e070ceba5b47" translate="yes" xml:space="preserve">
          <source>The text conversion is generally a one-way conversion; in this example, we lose the actual image contents and focus just on the text data. This means that diffs generated by textconv are &lt;em&gt;not&lt;/em&gt; suitable for applying. For this reason, only &lt;code&gt;git diff&lt;/code&gt; and the &lt;code&gt;git log&lt;/code&gt; family of commands (i.e., log, whatchanged, show) will perform text conversion. &lt;code&gt;git
format-patch&lt;/code&gt; will never generate this output. If you want to send somebody a text-converted diff of a binary file (e.g., because it quickly conveys the changes you have made), you should generate it separately and send it as a comment &lt;em&gt;in addition to&lt;/em&gt; the usual binary diff that you might send.</source>
          <target state="translated">文本转换通常是单向转换；在此示例中，我们丢失了实际的图像内容，而只关注文本数据。这意味着textconv生成的差异&lt;em&gt;不&lt;/em&gt;适合应用。因此，只有 &lt;code&gt;git diff&lt;/code&gt; 和 &lt;code&gt;git log&lt;/code&gt; 系列命令（即log，whatchanged，show）将执行文本转换。 &lt;code&gt;git format-patch&lt;/code&gt; 将永远不会生成此输出。如果您想将二进制文件的文本转换后的差异发送给某人（例如，因为它可以快速传达您所做的更改），则您应该单独生成该文件，并将其作为注释发送给您，&lt;em&gt;而&lt;/em&gt;不是通常的二进制差异。发送。</target>
        </trans-unit>
        <trans-unit id="eb234a21c48fd769b7576108683d04bf29f253cb" translate="yes" xml:space="preserve">
          <source>The third syntax (&quot;&lt;code&gt;git merge --continue&lt;/code&gt;&quot;) can only be run after the merge has resulted in conflicts.</source>
          <target state="translated">第三种语法（&amp;ldquo; &lt;code&gt;git merge --continue&lt;/code&gt; &amp;rdquo;）只能在合并导致冲突后运行。</target>
        </trans-unit>
        <trans-unit id="a25be90a41e318ce76ddb9737f9c1a04e1e950e3" translate="yes" xml:space="preserve">
          <source>The time between the first rc release and the final release is supposed to be used to test rc versions and fight bugs and especially regressions. And this time is more than 80% of the release cycle time. But this is not the end of the fight yet, as of course it continues after the release.</source>
          <target state="translated">从第一个rc版本到最终版本之间的时间,应该是用来测试rc版本和打击bug,尤其是回归。而这个时间占发布周期时间的80%以上。但这还不是战斗的结束,因为当然在发布后还要继续战斗。</target>
        </trans-unit>
        <trans-unit id="75271c1b7d85cdfdc3bad04249d4464b9c292a44" translate="yes" xml:space="preserve">
          <source>The time of the change is specified by &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; using the date format that was selected by the --date-format=&amp;lt;fmt&amp;gt; command-line option. See &amp;ldquo;Date Formats&amp;rdquo; above for the set of supported formats, and their syntax.</source>
          <target state="translated">更改时间由 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 使用--date-format = &amp;lt;fmt&amp;gt;命令行选项选择的日期格式指定。有关支持的格式集及其语法，请参见上面的&amp;ldquo;日期格式&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="05b9a4ac37ff05623171d65150ac27013efa2fa0" translate="yes" xml:space="preserve">
          <source>The time of the event is specified by &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; as the number of seconds since the UNIX epoch (midnight, Jan 1, 1970, UTC) and is written as an ASCII decimal integer.</source>
          <target state="translated">事件的时间由 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 指定为自UNIX纪元（1970年1月1日午夜，UTC）以来的秒数，并以ASCII十进制整数表示。</target>
        </trans-unit>
        <trans-unit id="e85bdfa8e02113c7aa36696add629ec632f05440" translate="yes" xml:space="preserve">
          <source>The todo list presented by the deprecated &lt;code&gt;--preserve-merges --interactive&lt;/code&gt; does not represent the topology of the revision graph (use &lt;code&gt;--rebase-merges&lt;/code&gt; instead). Editing commits and rewording their commit messages should work fine, but attempts to reorder commits tend to produce counterintuitive results. Use &lt;code&gt;--rebase-merges&lt;/code&gt; in such scenarios instead.</source>
          <target state="translated">不推荐使用的 &lt;code&gt;--preserve-merges --interactive&lt;/code&gt; 提供的待办事项列表不表示修订图的拓扑（请改用 &lt;code&gt;--rebase-merges&lt;/code&gt; ）。编辑提交并对提交消息进行重新措辞应该可以正常工作，但是尝试对提交进行重新排序会产生与直觉相反的结果。在这种情况下，请使用 &lt;code&gt;--rebase-merges&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f8166907df228eb9266d7566c3cde991d9d39bd" translate="yes" xml:space="preserve">
          <source>The total number of paths.</source>
          <target state="translated">总的路径数。</target>
        </trans-unit>
        <trans-unit id="46c0269533706ef03961ed4548e480cdcfd7a84a" translate="yes" xml:space="preserve">
          <source>The trailer records 20-byte SHA-1 checksum of all of the above.</source>
          <target state="translated">拖车记录了上述所有内容的20字节SHA-1校验和。</target>
        </trans-unit>
        <trans-unit id="b9ae27ef547547fea9cd9f5b91bb86a4c8f93238" translate="yes" xml:space="preserve">
          <source>The trailer records a pack checksum of all of the above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9380254df0eb0e126f55d72177d625190ab23928" translate="yes" xml:space="preserve">
          <source>The transmission of the packfile begins immediately after the section header</source>
          <target state="translated">包装文件的传输在节头之后立即开始。</target>
        </trans-unit>
        <trans-unit id="de285c430d2e1f897693d7ccc23434e1a3a5c103" translate="yes" xml:space="preserve">
          <source>The tree object is the tree we examined first, and this commit is unusual in that it lacks any parent.</source>
          <target state="translated">树对象就是我们先检查的树,这次提交的情况很特别,它缺少任何父树。</target>
        </trans-unit>
        <trans-unit id="9178b43dc9b2907a6afd7a3693f2c6894ec0ecd9" translate="yes" xml:space="preserve">
          <source>The tree of actual checked out files. The working tree normally contains the contents of the &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; commit&amp;rsquo;s tree, plus any local changes that you have made but not yet committed.</source>
          <target state="translated">实际签出文件的树。工作树通常包含&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;提交树的内容，以及您已进行但尚未提交的所有本地更改。</target>
        </trans-unit>
        <trans-unit id="26b5c7d70f82997ceabb111adeeb911e4d89a340" translate="yes" xml:space="preserve">
          <source>The tree or commit to produce an archive for.</source>
          <target state="translated">要制作存档的树或提交。</target>
        </trans-unit>
        <trans-unit id="90f78952a054862b4ed6d79982e2eab2fc081a24" translate="yes" xml:space="preserve">
          <source>The twist is that if some file doesn&amp;rsquo;t match the index, we don&amp;rsquo;t have a backing store thing for it, and we use the magic &quot;all-zero&quot; sha1 to show that. So let&amp;rsquo;s say that you have edited &lt;code&gt;kernel/sched.c&lt;/code&gt;, but have not actually done a &lt;code&gt;git update-index&lt;/code&gt; on it yet - there is no &quot;object&quot; associated with the new state, and you get:</source>
          <target state="translated">扭曲之处在于，如果某个文件与索引不匹配，那么我们就没有后备存储，而我们使用神奇的&amp;ldquo;全零&amp;rdquo; sha1来表明这一点。因此，假设您已经编辑了 &lt;code&gt;kernel/sched.c&lt;/code&gt; ，但实际上尚未对其执行 &lt;code&gt;git update-index&lt;/code&gt; index-没有与新状态关联的&amp;ldquo;对象&amp;rdquo;，您将得到：</target>
        </trans-unit>
        <trans-unit id="43d0ee9ad50c1c3c133c4c2ff3f216463ab119aa" translate="yes" xml:space="preserve">
          <source>The two options can be specified together to ask a command to work on both the index and the working tree.</source>
          <target state="translated">这两个选项可以一起指定,要求命令同时在索引和工作树上工作。</target>
        </trans-unit>
        <trans-unit id="293c342524c5d665ec090c34f37c73d153be74d5" translate="yes" xml:space="preserve">
          <source>The type of the object (&lt;code&gt;blob&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;).</source>
          <target state="translated">对象的类型（ &lt;code&gt;blob&lt;/code&gt; ， &lt;code&gt;tree&lt;/code&gt; ， &lt;code&gt;commit&lt;/code&gt; ， &lt;code&gt;tag&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="35ca6d49608b210b7cf8be4b86261fa4bd55e249" translate="yes" xml:space="preserve">
          <source>The type of the object (the same as &lt;code&gt;cat-file -t&lt;/code&gt; reports).</source>
          <target state="translated">对象的类型（与 &lt;code&gt;cat-file -t&lt;/code&gt; 报告相同）。</target>
        </trans-unit>
        <trans-unit id="a4f9324e934e3998d2ea50e9e2c5152c5cb8ca76" translate="yes" xml:space="preserve">
          <source>The typical usage is to set just the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables; the other options are provided for more complex use cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4785efb96aaa5561500dccbb8420f79e52290b85" translate="yes" xml:space="preserve">
          <source>The underlying Git plumbing tools, such as &lt;code&gt;git ls-files&lt;/code&gt; and &lt;code&gt;git read-tree&lt;/code&gt;, read &lt;code&gt;gitignore&lt;/code&gt; patterns specified by command-line options, or from files specified by command-line options. Higher-level Git tools, such as &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git add&lt;/code&gt;, use patterns from the sources specified above.</source>
          <target state="translated">基本的Git管道工具，例如 &lt;code&gt;git ls-files&lt;/code&gt; 和 &lt;code&gt;git read-tree&lt;/code&gt; ，从命令行选项指定的 &lt;code&gt;gitignore&lt;/code&gt; 读取模式，或者从命令行选项指定的文件读取gitignore模式。更高级别的Git工具（例如 &lt;code&gt;git status&lt;/code&gt; 和 &lt;code&gt;git add&lt;/code&gt; ）使用上述指定来源中的模式。</target>
        </trans-unit>
        <trans-unit id="c7717dd458d0c51efaa12d77d8ac91e6b1b7952a" translate="yes" xml:space="preserve">
          <source>The unique identifier of an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;. The object name is usually represented by a 40 character hexadecimal string. Also colloquially called &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;的唯一标识符。对象名称通常由40个字符的十六进制字符串表示。俗称&lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="190c2fffcaa0444f677f39ee7f8533684a0964b1" translate="yes" xml:space="preserve">
          <source>The unit of storage in Git. It is uniquely identified by the &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; of its contents. Consequently, an object cannot be changed.</source>
          <target state="translated">Git中的存储单位。它由其内容的&lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt;唯一标识。因此，无法更改对象。</target>
        </trans-unit>
        <trans-unit id="39871fae2a5575ced5627a5aed0eb792e4c6cc2e" translate="yes" xml:space="preserve">
          <source>The untracked cache extension can be enabled by the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">可以通过 &lt;code&gt;core.untrackedCache&lt;/code&gt; 配置变量启用未跟踪的缓存扩展（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cc7260429a75073116cdc4eb67dbd95326cbd29d" translate="yes" xml:space="preserve">
          <source>The upstream project is expected to have the commit named by &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; and the output asks it to integrate the changes you made since that commit, up to the commit named by &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt;, by visiting the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">预期上游项目将具有由 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 命名的提交，并且输出将要求它通过访问由 &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 命名的存储库集成您自该提交以来所做的更改，直至集成到由 &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; 命名的提交。</target>
        </trans-unit>
        <trans-unit id="90c1df21766dd92e926e4168cc9d516f756c7832" translate="yes" xml:space="preserve">
          <source>The upstream reference is generally &lt;code&gt;refs/remotes/p4/master&lt;/code&gt;, but can be overridden using the &lt;code&gt;--origin=&lt;/code&gt; command-line option.</source>
          <target state="translated">上游引用通常是 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; ，但是可以使用 &lt;code&gt;--origin=&lt;/code&gt; 命令行选项覆盖。</target>
        </trans-unit>
        <trans-unit id="26e6d639f86a47deca57ab3911edaae9c5141f38" translate="yes" xml:space="preserve">
          <source>The user wants to fast-forward to $M.</source>
          <target state="translated">用户想快进到$M。</target>
        </trans-unit>
        <trans-unit id="6df61c6f9e257fdbf1ce4a60fb1d73b618d329ca" translate="yes" xml:space="preserve">
          <source>The user&amp;rsquo;s color.status configuration is not respected; color will always be off.</source>
          <target state="translated">不尊重用户的color.status配置；颜色将始终关闭。</target>
        </trans-unit>
        <trans-unit id="ab6a20b222f27dba657bc91ae7970effd7a690ca" translate="yes" xml:space="preserve">
          <source>The user&amp;rsquo;s status.relativePaths configuration is not respected; paths shown will always be relative to the repository root.</source>
          <target state="translated">不遵守用户的status.relativePaths配置；显示的路径将始终相对于存储库根目录。</target>
        </trans-unit>
        <trans-unit id="20126eaca194f3ace1deaba2aaa4133e6326b674" translate="yes" xml:space="preserve">
          <source>The user-provided shell commands will likely involve a pipeline of commands, resulting in the creation of many processes per commit. Creating and running another process takes a widely varying amount of time between operating systems, but on any platform it is very slow relative to invoking a function.</source>
          <target state="translated">用户提供的shell命令很可能会涉及到一个命令流水线,导致每次提交都会创建许多进程。创建和运行另一个进程所需的时间在不同的操作系统之间有很大的差异,但在任何平台上,相对于调用一个函数来说都是非常缓慢的。</target>
        </trans-unit>
        <trans-unit id="b70cc2efdcbaf68bada34e0550746a0012d52bae" translate="yes" xml:space="preserve">
          <source>The username to use when logging in to the server.</source>
          <target state="translated">登录服务器时要使用的用户名。</target>
        </trans-unit>
        <trans-unit id="ed02ee3239772cb9dc0f4dbf65c91bd756125cc7" translate="yes" xml:space="preserve">
          <source>The usual way to deal with this is to use &lt;code&gt;git revert&lt;/code&gt;. This preserves the history that the original change was made and was a valuable contribution, but also introduces a new commit that undoes those changes because the original had a problem. The commit message of the revert indicates the commit which was reverted and is usually edited to include an explanation as to why the revert was made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c33e134557b27ccb1a85349808f80ba518bd84" translate="yes" xml:space="preserve">
          <source>The valid values for this option are: &lt;code&gt;add&lt;/code&gt; (this is the default) and &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">此选项的有效值为： &lt;code&gt;add&lt;/code&gt; （这是默认值）和 &lt;code&gt;doNothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17a990c606d2e2e22a8f755a1f843b57ef2f5ef2" translate="yes" xml:space="preserve">
          <source>The valid values for this option are: &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; (this is the default), &lt;code&gt;addIfDifferent&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">此选项的有效值为： &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; （这是默认值）， &lt;code&gt;addIfDifferent&lt;/code&gt; ， &lt;code&gt;add&lt;/code&gt; ， &lt;code&gt;replace&lt;/code&gt; 或 &lt;code&gt;doNothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="505e929c5c3b27eed17b03a2625718de5c7f7031" translate="yes" xml:space="preserve">
          <source>The value for a variable that takes a color is a list of colors (at most two, one for foreground and one for background) and attributes (as many as you want), separated by spaces.</source>
          <target state="translated">取色变量的值是一个颜色列表(最多两个,一个是前景色,一个是背景色)和属性(任意多个),用空格分隔。</target>
        </trans-unit>
        <trans-unit id="e1d242fc18797a443a86ba553d48e3f3cae01e9a" translate="yes" xml:space="preserve">
          <source>The value for many variables that specify various sizes can be suffixed with &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;,&amp;hellip;​ to mean &quot;scale the number by 1024&quot;, &quot;by 1024x1024&quot;, etc.</source>
          <target state="translated">可以将指定各种大小的许多变量的值加 &lt;code&gt;k&lt;/code&gt; ， &lt;code&gt;M&lt;/code&gt; ，... 后缀，以表示&amp;ldquo;将数字缩放1024&amp;rdquo;，&amp;ldquo;按1024x1024&amp;rdquo;等。</target>
        </trans-unit>
        <trans-unit id="f1dedc58ec3c676ad597a786553123421e517365" translate="yes" xml:space="preserve">
          <source>The value is a list of three values: a default time zone (for if the client hasn&amp;rsquo;t selected some other time zone and saved it in a cookie), a name of cookie where to store selected time zone, and a CSS class used to mark up dates for manipulation. If you want to turn this feature off, set &quot;default&quot; to empty list: &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">该值是三个值的列表：默认时区（如果客户端未选择其他时区并将其保存在Cookie中），用于存储所选时区的cookie名称以及所使用的CSS类标记日期以便进行操作。如果要关闭此功能，请将&amp;ldquo;默认&amp;rdquo;设置为空列表： &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0462ada8e80b752f4ecad69fb2563ec0b8b930aa" translate="yes" xml:space="preserve">
          <source>The value of 'default' is a list of names of snapshot formats, defined in &lt;code&gt;%known_snapshot_formats&lt;/code&gt; hash, that you wish to offer. Supported formats include &quot;tgz&quot;, &quot;tbz2&quot;, &quot;txz&quot; (gzip/bzip2/xz compressed tar archive) and &quot;zip&quot;; please consult gitweb sources for a definitive list. By default only &quot;tgz&quot; is offered.</source>
          <target state="translated">&amp;ldquo; default&amp;rdquo;的值是您希望提供的快照格式名称的列表，这些名称在 &lt;code&gt;%known_snapshot_formats&lt;/code&gt; 哈希中定义。支持的格式包括&amp;ldquo; tgz&amp;rdquo;，&amp;ldquo; tbz2&amp;rdquo;，&amp;ldquo; txz&amp;rdquo;（gzip / bzip2 / xz压缩tar存档）和&amp;ldquo; zip&amp;rdquo;；请查阅gitweb来源以获得确切的列表。默认情况下，仅提供&amp;ldquo; tgz&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c34b53e9a12553098df9adad4c30762484ffde18" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; must be a valid refname in Git and therefore may contain forward slashes. As &lt;code&gt;LF&lt;/code&gt; is not valid in a Git refname, no quoting or escaping syntax is supported here.</source>
          <target state="translated">&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 的值必须是Git中的有效refname，因此可能包含正斜杠。由于 &lt;code&gt;LF&lt;/code&gt; 在Git引用名称中无效，因此此处不支持引用或转义语法。</target>
        </trans-unit>
        <trans-unit id="8b5a30f586808b1827fdb8f433a15c6c9d49f6ba" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; must be in canonical form. That is it must not:</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 的值必须为规范形式。那绝对不能：</target>
        </trans-unit>
        <trans-unit id="dfb2ec984e9987b1b930824861a3abbf3e4aa29f" translate="yes" xml:space="preserve">
          <source>The value of this attribute specifies the character encoding that should be used by GUI tools (e.g. &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; and &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;) to display the contents of the relevant file. Note that due to performance considerations &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; does not use this attribute unless you manually enable per-file encodings in its options.</source>
          <target state="translated">此属性的值指定GUI工具（例如&lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt;和&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt;）用于显示相关文件内容的字符编码。请注意，出于性能方面的考虑，除非您在其选项中手动启用按文件编码，否则&lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt;不会使用此属性。</target>
        </trans-unit>
        <trans-unit id="4bdcd2a8dee01aee6c5f0f23e7e10ac25985aae6" translate="yes" xml:space="preserve">
          <source>The value of this key is the name of the promisor remote.</source>
          <target state="translated">这个键的值是承诺者远程的名称。</target>
        </trans-unit>
        <trans-unit id="49e3be97b83e2e2d47823db7b33592c5066364cc" translate="yes" xml:space="preserve">
          <source>The version parameter is used to specify the format version. This is optional and defaults to the original version &lt;code&gt;v1&lt;/code&gt; format.</source>
          <target state="translated">version参数用于指定格式版本。这是可选的，默认为原始版本 &lt;code&gt;v1&lt;/code&gt; 格式。</target>
        </trans-unit>
        <trans-unit id="a720bc9826a296e909d26ea1e1addd2076945090" translate="yes" xml:space="preserve">
          <source>The victim sends &quot;have&quot; lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn&amp;rsquo;t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to &quot;merge&quot; X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)</source>
          <target state="translated">受害者发送&amp;ldquo; have&amp;rdquo;行，广告它拥有的对象的ID，这些对象的ID并不是明确要共享的，但是如果对等方也有它们，则可以用来优化传输。攻击者选择要窃取的对象ID X并将引用发送给X，但由于受害者已经拥有X，因此不需要发送X的内容。现在，受害者认为攻击者拥有X，并将X的内容稍后发送回攻击者。 （通过在客户端有权访问的名称空间中创建对X的引用，然后将其提取，这种攻击对于客户端在服务器上执行来说是最直接的。服务器在客户端上执行此操作的最可能方式是&amp;ldquo;将&amp;ldquo; X&amp;rdquo;合并到公共分支，并希望用户在该分支上做其他工作并将其推送回服务器，而不会注意到合并。）</target>
        </trans-unit>
        <trans-unit id="bad569f9e07003c7e9ba90b91ff6d5e2d3ebab92" translate="yes" xml:space="preserve">
          <source>The virtual host configuration (in Apache configuration file) should look like this:</source>
          <target state="translated">虚拟主机的配置(在Apache配置文件中)应该是这样的。</target>
        </trans-unit>
        <trans-unit id="6258db9fdd3beac891e6dcfd7dedb19764ce413e" translate="yes" xml:space="preserve">
          <source>The way &lt;code&gt;git update-index&lt;/code&gt; handles files it is told about can be modified using the various options:</source>
          <target state="translated">该方式 &lt;code&gt;git update-index&lt;/code&gt; 手柄文件，它讲述可以使用各种选项进行修改：</target>
        </trans-unit>
        <trans-unit id="5fe1a87d113fe93088f754b0185b7bc1cb985816" translate="yes" xml:space="preserve">
          <source>The web browser can be specified using a configuration variable passed with the -c (or --config) command-line option, or the &lt;code&gt;web.browser&lt;/code&gt; configuration variable if the former is not used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae6c5b18c0fd18e4f577ab3723eb5808f05d9f12" translate="yes" xml:space="preserve">
          <source>The web browser can be specified using the configuration variable &lt;code&gt;help.browser&lt;/code&gt;, or &lt;code&gt;web.browser&lt;/code&gt; if the former is not set. If none of these config variables is set, the &lt;code&gt;git web--browse&lt;/code&gt; helper script (called by &lt;code&gt;git help&lt;/code&gt;) will pick a suitable default. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2adc08265063993fb836b81a622f1e26249d55" translate="yes" xml:space="preserve">
          <source>The web browser can be specified using the configuration variable &lt;code&gt;help.browser&lt;/code&gt;, or &lt;code&gt;web.browser&lt;/code&gt; if the former is not set. If none of these config variables is set, the &lt;code&gt;git web{litdd}browse&lt;/code&gt; helper script (called by &lt;code&gt;git help&lt;/code&gt;) will pick a suitable default. See git-web{litdd}browse[1] for more information about this.</source>
          <target state="translated">可以使用配置变量 &lt;code&gt;help.browser&lt;/code&gt; 或 &lt;code&gt;web.browser&lt;/code&gt; (如果未设置前者）来指定Web浏览器。如果未设置这些配置变量，则 &lt;code&gt;git web{litdd}browse&lt;/code&gt; 助手脚本（由 &lt;code&gt;git help&lt;/code&gt; 调用）将选择合适的默认值。有关更多信息，请参见git-web {litdd} browse [1]。</target>
        </trans-unit>
        <trans-unit id="d52f23a775c5f3aadffb0193202482a8a4b8d0b1" translate="yes" xml:space="preserve">
          <source>The web browser that should be used to view the gitweb page. This will be passed to the &lt;code&gt;git web--browse&lt;/code&gt; helper script along with the URL of the gitweb instance. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this. If the script fails, the URL will be printed to stdout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38f40c77930468f76ac59e3f127231f37c11803" translate="yes" xml:space="preserve">
          <source>The web browser that should be used to view the gitweb page. This will be passed to the &lt;code&gt;git web{litdd}browse&lt;/code&gt; helper script along with the URL of the gitweb instance. See git-web{litdd}browse[1] for more information about this. If the script fails, the URL will be printed to stdout.</source>
          <target state="translated">应该用于查看gitweb页面的Web浏览器。它将与gitweb实例的URL一起传递到 &lt;code&gt;git web{litdd}browse&lt;/code&gt; 帮助脚本。有关更多信息，请参见git-web {litdd} browse [1]。如果脚本失败，则URL将被打印到stdout。</target>
        </trans-unit>
        <trans-unit id="c7492cc5fa9e9927a227312bd1f1ea85a3766cb5" translate="yes" xml:space="preserve">
          <source>The width (in characters) of the &quot;Description&quot; column of the projects list. Longer descriptions will be truncated (trying to cut at word boundary); the full description is available in the &lt;code&gt;title&lt;/code&gt; attribute (usually shown on mouseover). The default is 25, which might be too small if you use long project descriptions.</source>
          <target state="translated">项目列表的&amp;ldquo;描述&amp;rdquo;列的宽度（以字符为单位）。较长的描述将被截断（试图在单词边界处切开）；完整的描述位于 &lt;code&gt;title&lt;/code&gt; 属性中（通常在鼠标悬停时显示）。默认值为25，如果使用较长的项目描述，则可能太小。</target>
        </trans-unit>
        <trans-unit id="2a9553b8b798d28f6c8fd9f09980f5b7959498e9" translate="yes" xml:space="preserve">
          <source>The window size parameter used in the delta compression algorithm used by &lt;code&gt;git gc --aggressive&lt;/code&gt;. This defaults to 250, which is a much more aggressive window size than the default &lt;code&gt;--window&lt;/code&gt; of 10.</source>
          <target state="translated">&lt;code&gt;git gc --aggressive&lt;/code&gt; 使用的增量压缩算法中使用的窗口大小参数。默认值为250，这比默认 &lt;code&gt;--window&lt;/code&gt; 10 窗口大小大得多。</target>
        </trans-unit>
        <trans-unit id="046739930d5e8946cdceaf820a70c4ac9ebc8d51" translate="yes" xml:space="preserve">
          <source>The working directory then reflects the contents that the project had when it was tagged v2.6.13, and &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; shows two branches, with an asterisk marking the currently checked-out branch:</source>
          <target state="translated">然后，工作目录反映了项目被标记为v2.6.13时的内容，而&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;显示了两个分支，其中带有星号的标记表示当前已签出的分支：</target>
        </trans-unit>
        <trans-unit id="c76d23bfcb6d4a63fd96acda23f8bee068090518" translate="yes" xml:space="preserve">
          <source>The worktree list command has two output formats. The default format shows the details on a single line with columns. For example:</source>
          <target state="translated">工作树列表命令有两种输出格式。默认格式是在单行上显示详细信息,并有列。例如,工作树列表命令有两种输出格式,默认的格式是将详细信息显示在带列的单行上。</target>
        </trans-unit>
        <trans-unit id="ecaf7c5f30215b083ffbd406549425a7d1040c7d" translate="yes" xml:space="preserve">
          <source>Then &quot;&lt;code&gt;git merge topic&lt;/code&gt;&quot; will replay the changes made on the &lt;code&gt;topic&lt;/code&gt; branch since it diverged from &lt;code&gt;master&lt;/code&gt; (i.e., &lt;code&gt;E&lt;/code&gt;) until its current commit (&lt;code&gt;C&lt;/code&gt;) on top of &lt;code&gt;master&lt;/code&gt;, and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.</source>
          <target state="translated">那么，&amp;ldquo; &lt;code&gt;git merge topic&lt;/code&gt; &amp;rdquo;将重播上所做的更改 &lt;code&gt;topic&lt;/code&gt; 分支，因为它从分歧 &lt;code&gt;master&lt;/code&gt; （即 &lt;code&gt;E&lt;/code&gt; ），直到其当前提交（ &lt;code&gt;C&lt;/code&gt; 之上） &lt;code&gt;master&lt;/code&gt; ，并在新的记录结果用的名字提交沿两个父提交，以及来自用户的描述更改的日志消息。</target>
        </trans-unit>
        <trans-unit id="f3bf49c80f1bf671798b336ee7a6337eb982b2bc" translate="yes" xml:space="preserve">
          <source>Then &quot;&lt;code&gt;git pull&lt;/code&gt;&quot; will fetch and replay the changes from the remote &lt;code&gt;master&lt;/code&gt; branch since it diverged from the local &lt;code&gt;master&lt;/code&gt; (i.e., &lt;code&gt;E&lt;/code&gt;) until its current commit (&lt;code&gt;C&lt;/code&gt;) on top of &lt;code&gt;master&lt;/code&gt; and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.</source>
          <target state="translated">那么，&amp;ldquo; &lt;code&gt;git pull&lt;/code&gt; &amp;rdquo;将获取和重放从远程更改 &lt;code&gt;master&lt;/code&gt; 分支，因为它从本地分歧 &lt;code&gt;master&lt;/code&gt; （即 &lt;code&gt;E&lt;/code&gt; ），直到其当前提交（ &lt;code&gt;C&lt;/code&gt; ^）之上 &lt;code&gt;master&lt;/code&gt; ，并在新的记录结果与提交沿两个父提交的名称以及来自用户的描述更改的日志消息。</target>
        </trans-unit>
        <trans-unit id="44f92500b7ae9560ae64e2f2fc4f1af900d3ff26" translate="yes" xml:space="preserve">
          <source>Then &quot;git bisect&quot; will checkout a commit of its choosing and ask the user to test it, like this:</source>
          <target state="translated">然后,&quot;git bisect &quot;会勾选一个它选择的提交,并要求用户测试它,就像这样。</target>
        </trans-unit>
        <trans-unit id="e1ef052a3cd59f805d0ae45d1b9033a6a2faaa95" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;git bisect&lt;/code&gt; will respond with something like</source>
          <target state="translated">然后 &lt;code&gt;git bisect&lt;/code&gt; 会回应类似</target>
        </trans-unit>
        <trans-unit id="307236a389d15c9e88cc574f3c2b3a0314992840" translate="yes" xml:space="preserve">
          <source>Then compile and test the chosen revision, and afterwards mark the revision as good or bad in the usual manner.</source>
          <target state="translated">然后对所选的修订版进行编译和测试,之后按照常规的方式对修订版进行好坏标记。</target>
        </trans-unit>
        <trans-unit id="876e252bd62eb2a97f748800c6625b2b00ccfdec" translate="yes" xml:space="preserve">
          <source>Then confirm that the bug persists in a repository created from that stream (many bugs will not, as they really do depend on the exact repository contents):</source>
          <target state="translated">然后确认该bug在从该流创建的仓库中持续存在(许多bug不会,因为它们确实取决于仓库的确切内容)。</target>
        </trans-unit>
        <trans-unit id="87463a5d117dae6022935ddfd68f09bfbb9b0943" translate="yes" xml:space="preserve">
          <source>Then create the following script to get list of project in the format suitable for GITWEB_LIST build configuration variable (or &lt;code&gt;$projects_list&lt;/code&gt; variable in gitweb config):</source>
          <target state="translated">然后创建以下脚本，以适合GITWEB_LIST构建配置变量（或gitweb config中的 &lt;code&gt;$projects_list&lt;/code&gt; 变量）的格式获取项目列表：</target>
        </trans-unit>
        <trans-unit id="b5a742d8577423cd13ed5705b5290de27ff73949" translate="yes" xml:space="preserve">
          <source>Then fixup &quot;master&quot; with &lt;code&gt;git rebase&lt;/code&gt;. Do NOT use &lt;code&gt;git merge&lt;/code&gt; or your history will not be compatible with a future &lt;code&gt;dcommit&lt;/code&gt;!</source>
          <target state="translated">然后用 &lt;code&gt;git rebase&lt;/code&gt; 修复&amp;ldquo; master&amp;rdquo; 。不要使用 &lt;code&gt;git merge&lt;/code&gt; ,否则您的历史记录将与以后的 &lt;code&gt;dcommit&lt;/code&gt; 不兼容！</target>
        </trans-unit>
        <trans-unit id="78318329e21f0014f75ba54a708b1f46ad0d023c" translate="yes" xml:space="preserve">
          <source>Then it compares the new skip-worktree value with the previous one. If skip-worktree turns from set to unset, it will add the corresponding file back. If it turns from unset to set, that file will be removed.</source>
          <target state="translated">然后将新的 skip-worktree 值与之前的值进行比较。如果 skip-worktree 从 set 转为 unset,它将把相应的文件添加回来。如果从unset转为set,则该文件将被删除。</target>
        </trans-unit>
        <trans-unit id="5e9c59419a3e5d8568740259a39319d49129c624" translate="yes" xml:space="preserve">
          <source>Then it examines &lt;code&gt;.gitattributes&lt;/code&gt; (which is in the parent directory), and finds that the first line matches, but &lt;code&gt;t/.gitattributes&lt;/code&gt; file already decided how &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; attributes should be given to this path, so it leaves &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; unset. Attribute &lt;code&gt;baz&lt;/code&gt; is set.</source>
          <target state="translated">然后，它检查 &lt;code&gt;.gitattributes&lt;/code&gt; （位于父目录中），发现第一行匹配，但是 &lt;code&gt;t/.gitattributes&lt;/code&gt; 文件已经决定了如何 &lt;code&gt;merge&lt;/code&gt; ， &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 属性赋予该路径，因此保留 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 未设定。设置属性 &lt;code&gt;baz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1100f313a3d209e54bf3bc725a364711886dbfc4" translate="yes" xml:space="preserve">
          <source>Then modify, reorder, or eliminate patches as needed before applying them again with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;:</source>
          <target state="translated">然后根据需要修改，重新排序或消除补丁，然后使用&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;再次应用它们：</target>
        </trans-unit>
        <trans-unit id="cd43ef848f2d3c4afb2a44ae28c2a413397c1d96" translate="yes" xml:space="preserve">
          <source>Then provide your password via the pserver method, for example:</source>
          <target state="translated">然后通过pserver方法提供密码,例如。</target>
        </trans-unit>
        <trans-unit id="a774f276f116b48d127c0c1418ef7aa2fe46b49b" translate="yes" xml:space="preserve">
          <source>Then simplify each commit &lt;code&gt;C&lt;/code&gt; to its replacement &lt;code&gt;C'&lt;/code&gt; in the final history according to the following rules:</source>
          <target state="translated">然后根据以下规则在最终历史记录中将每个提交 &lt;code&gt;C&lt;/code&gt; 简化为其替换 &lt;code&gt;C'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2f5d7fdcf8fcb013dcf3c597507de91a5cb0f77d" translate="yes" xml:space="preserve">
          <source>Then simply fork your topic branches from the stable remotes as explained earlier.</source>
          <target state="translated">然后按照前面的解释,简单地从稳定的远程中分叉出你的主题分支。</target>
        </trans-unit>
        <trans-unit id="b19a7b2e2b2e2252f0564256c9b87915d5db46d3" translate="yes" xml:space="preserve">
          <source>Then suppose you modify the last three commits:</source>
          <target state="translated">那么假设你修改了最后三次提交。</target>
        </trans-unit>
        <trans-unit id="e69e2e34d497710c4127a780d2a5ed5c7d7fac83" translate="yes" xml:space="preserve">
          <source>Then there are two ways to get a smaller repository. A safer way is to clone, that keeps your original intact.</source>
          <target state="translated">那么有两种方法可以让仓库变小。比较安全的方法是克隆,这样可以保持你的原件不变。</target>
        </trans-unit>
        <trans-unit id="5c871054b486e3acaf28dc409c1ab3e693b4fc90" translate="yes" xml:space="preserve">
          <source>Then this &lt;code&gt;git p4 clone&lt;/code&gt; command:</source>
          <target state="translated">然后这个 &lt;code&gt;git p4 clone&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="db9b57b987ef397bc0b191d278e31ed2d827cb0a" translate="yes" xml:space="preserve">
          <source>Then you can disable sparse checkout. Sparse checkout support in &lt;code&gt;git read-tree&lt;/code&gt; and similar commands is disabled by default. You need to turn &lt;code&gt;core.sparseCheckout&lt;/code&gt; on in order to have sparse checkout support.</source>
          <target state="translated">然后，您可以禁用稀疏签出。 &lt;code&gt;git read-tree&lt;/code&gt; 和类似命令中的稀疏签出支持默认情况下处于禁用状态。您需要打开 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 才能获得稀疏签出支持。</target>
        </trans-unit>
        <trans-unit id="87a33f516a8ffec885e906dbb29e388a5f30ada0" translate="yes" xml:space="preserve">
          <source>Then you can pull and merge, leaving &lt;code&gt;frotz.c&lt;/code&gt; and &lt;code&gt;filfre.c&lt;/code&gt; changes still in the working tree.</source>
          <target state="translated">然后，您可以拉并合并，将 &lt;code&gt;frotz.c&lt;/code&gt; 和 &lt;code&gt;filfre.c&lt;/code&gt; 的更改仍保留在工作树中。</target>
        </trans-unit>
        <trans-unit id="fa280cd97c17d646b4ce0e60bbbcb27953b34fb3" translate="yes" xml:space="preserve">
          <source>Then you can push both the test and release trees using &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;:</source>
          <target state="translated">然后，您可以使用&lt;a href=&quot;git-push&quot;&gt;git-push [1]推送&lt;/a&gt;测试和发布树：</target>
        </trans-unit>
        <trans-unit id="9015e54306232b9477b76c544780cb6cb29e184c" translate="yes" xml:space="preserve">
          <source>Then you might want a &lt;code&gt;.mailmap&lt;/code&gt; file that looks like:</source>
          <target state="translated">然后，您可能需要一个 &lt;code&gt;.mailmap&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="bdefcc2b7f4d341c71ca424367a0164c209ac375" translate="yes" xml:space="preserve">
          <source>Then you transfer file.bundle to the target machine B. Because this bundle does not require any existing object to be extracted, you can create a new repository on machine B by cloning from it:</source>
          <target state="translated">然后将file.bundle转移到目标机器B上,因为这个bundle不需要提取任何现有的对象,所以你可以在机器B上通过克隆它来创建一个新的仓库。</target>
        </trans-unit>
        <trans-unit id="e826c3727c0c79aa7b30f2352881ef1c5a35f171" translate="yes" xml:space="preserve">
          <source>Then you would define a &quot;filter.indent.clean&quot; and &quot;filter.indent.smudge&quot; configuration in your .git/config to specify a pair of commands to modify the contents of C programs when the source files are checked in (&quot;clean&quot; is run) and checked out (no change is made because the command is &quot;cat&quot;).</source>
          <target state="translated">那么你就在你的.git/config中定义一个 &quot;filter.indent.clean &quot;和 &quot;filter.indent.smudge &quot;的配置,来指定一对命令,以便在源文件检查进来(运行 &quot;clean&quot;)和检查出去(因为命令是 &quot;cat&quot;,所以没有修改)时修改C程序的内容。</target>
        </trans-unit>
        <trans-unit id="c6308f4c83137c8ddf705f0b33927bc3a2a2d3bf" translate="yes" xml:space="preserve">
          <source>Then, make that directory into a Git repository by running &lt;code&gt;git init&lt;/code&gt;, but this time, since its name is not the usual &lt;code&gt;.git&lt;/code&gt;, we do things slightly differently:</source>
          <target state="translated">然后，通过运行 &lt;code&gt;git init&lt;/code&gt; 将该目录放入Git存储库，但这一次，由于其名称不是通常的 &lt;code&gt;.git&lt;/code&gt; ，因此我们做的事情略有不同：</target>
        </trans-unit>
        <trans-unit id="4d45e0228f3dfbda52666260c02f45c435d7f13c" translate="yes" xml:space="preserve">
          <source>Then, use &lt;code&gt;git bisect &amp;lt;term-old&amp;gt;&lt;/code&gt; and &lt;code&gt;git bisect &amp;lt;term-new&amp;gt;&lt;/code&gt; instead of &lt;code&gt;git bisect good&lt;/code&gt; and &lt;code&gt;git bisect bad&lt;/code&gt; to mark commits.</source>
          <target state="translated">然后，使用 &lt;code&gt;git bisect &amp;lt;term-old&amp;gt;&lt;/code&gt; 和 &lt;code&gt;git bisect &amp;lt;term-new&amp;gt;&lt;/code&gt; 代替 &lt;code&gt;git bisect good&lt;/code&gt; 和 &lt;code&gt;git bisect bad&lt;/code&gt; 标记提交。</target>
        </trans-unit>
        <trans-unit id="4891bcd6061a60561c6585b63258de3d0b8b270b" translate="yes" xml:space="preserve">
          <source>Then, you can adjust your push URL to use &lt;code&gt;git@example_author&lt;/code&gt; or &lt;code&gt;git@example_committer&lt;/code&gt; instead of &lt;code&gt;git@example.org&lt;/code&gt; (e.g., &lt;code&gt;git remote set-url
git@example_author:org1/project1.git&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b100177b4f5d14520d5631ccbd2bc2ff52393e78" translate="yes" xml:space="preserve">
          <source>Then, you run this command:</source>
          <target state="translated">然后,你运行这个命令。</target>
        </trans-unit>
        <trans-unit id="ebbdc2314a6104dc9178c4c9ed7835ad78f84727" translate="yes" xml:space="preserve">
          <source>Then, you would define a &quot;diff.tex.xfuncname&quot; configuration to specify a regular expression that matches a line that you would want to appear as the hunk header &quot;TEXT&quot;. Add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">然后，您将定义&amp;ldquo; diff.tex.xfuncname&amp;rdquo;配置，以指定一个正则表达式，该正则表达式与您希望以粗体标题&amp;ldquo; TEXT&amp;rdquo;出现的行匹配。像这样在您的 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件（或 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 文件）中添加一个部分：</target>
        </trans-unit>
        <trans-unit id="8d94c9456285c171a8f18dcac7b76fd1fccc9ff4" translate="yes" xml:space="preserve">
          <source>There are (number of parents + 1) &lt;code&gt;@&lt;/code&gt; characters in the chunk header for combined diff format.</source>
          <target state="translated">组合式diff格式的块标题中有（父级数+ 1）个 &lt;code&gt;@&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="f7e9cf96a6ce9ed5c513750352c4736c076b5145" translate="yes" xml:space="preserve">
          <source>There are CPP wrapper macros and ifdefs to hide most of these details. See &lt;code&gt;trace2.h&lt;/code&gt; for more details. The following discussion will only describe the simplified forms.</source>
          <target state="translated">有CPP包装器宏和ifdefs隐藏了大多数这些细节。有关更多详细信息，请参见 &lt;code&gt;trace2.h&lt;/code&gt; 。以下讨论将仅描述简化形式。</target>
        </trans-unit>
        <trans-unit id="e4287f1e47cb2bfc1b9e5f25165aef43ceec9d6c" translate="yes" xml:space="preserve">
          <source>There are a few built-in low-level merge drivers defined that can be asked for via the &lt;code&gt;merge&lt;/code&gt; attribute.</source>
          <target state="translated">定义了一些内置的低级合并驱动程序，可以通过 &lt;code&gt;merge&lt;/code&gt; 属性要求它们。</target>
        </trans-unit>
        <trans-unit id="12f3989319ea3c0cba3d029a62ee2c306fd0616b" translate="yes" xml:space="preserve">
          <source>There are a few built-in patterns to make this easier, and &lt;code&gt;tex&lt;/code&gt; is one of them, so you do not have to write the above in your configuration file (you still need to enable this with the attribute mechanism, via &lt;code&gt;.gitattributes&lt;/code&gt;). The following built in patterns are available:</source>
          <target state="translated">有一些内置模式可以简化此过程，而 &lt;code&gt;tex&lt;/code&gt; 是其中之一，因此您不必在配置文件中编写以上内容（您仍然需要通过 &lt;code&gt;.gitattributes&lt;/code&gt; 通过属性机制启用此功能）。可以使用以下内置模式：</target>
        </trans-unit>
        <trans-unit id="336d04ab3583042f88f12edf2d051324b94f62a0" translate="yes" xml:space="preserve">
          <source>There are a few issues to resolve before we can completely switch to Trace2.</source>
          <target state="translated">在我们完全切换到Trace2之前,有几个问题需要解决。</target>
        </trans-unit>
        <trans-unit id="c8e0813ee0029806de1de3d5b367acd9c0a0d07d" translate="yes" xml:space="preserve">
          <source>There are a few more behavioral differences that most folks would probably consider inconsequential but which are mentioned for completeness:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f553cccafe9fdfa62552e6e1af4be573be245c47" translate="yes" xml:space="preserve">
          <source>There are a few special-purpose refs that do not begin with &lt;code&gt;refs/&lt;/code&gt;. The most notable example is &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">有一些特殊用途的ref并非以 &lt;code&gt;refs/&lt;/code&gt; 开头。最著名的例子是 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc9f53378dabd08666f7e5c5af2a717dbbd37e28" translate="yes" xml:space="preserve">
          <source>There are a number of factors which affect how much memory fast-import requires to perform an import. Like critical sections of core Git, fast-import uses its own memory allocators to amortize any overheads associated with malloc. In practice fast-import tends to amortize any malloc overheads to 0, due to its use of large block allocations.</source>
          <target state="translated">有很多因素会影响 fast-import 在执行导入时需要多少内存。和 Git 的核心部分一样,fast-import 使用自己的内存分配器来摊销与 malloc 相关的开销。在实践中,由于使用了大块分配,fast-import 倾向于将所有 malloc 开销摊销为 0。</target>
        </trans-unit>
        <trans-unit id="e0b2b532209e8b05d8ee20f67e782301986fd65a" translate="yes" xml:space="preserve">
          <source>There are also cases where existing indexes written by git versions before 2.17 will reference directories that don&amp;rsquo;t exist anymore, potentially causing many &quot;could not open directory&quot; warnings to be printed on &quot;git status&quot;. These are new warnings for existing issues that were previously silently discarded.</source>
          <target state="translated">在某些情况下，由2.17之前的git版本编写的现有索引将引用不再存在的目录，从而可能导致在&amp;ldquo; git status&amp;rdquo;上显示许多&amp;ldquo;无法打开目录&amp;rdquo;警告。这些是针对以前已被静默丢弃的现有问题的新警告。</target>
        </trans-unit>
        <trans-unit id="aec0acb7fb7522f7c5da2df9b13975842cb9d1be" translate="yes" xml:space="preserve">
          <source>There are also more complex operations that can be performed. But beware that because the patch is applied only to the index and not the working tree, the working tree will appear to &quot;undo&quot; the change in the index. For example, introducing a new line into the index that is in neither the HEAD nor the working tree will stage the new line for commit, but the line will appear to be reverted in the working tree.</source>
          <target state="translated">还可以进行更复杂的操作。但要注意的是,由于补丁只应用于索引而非工作树,工作树会出现 &quot;撤销 &quot;索引中的更改。例如,在索引中引入一个既不在 HEAD 也不在工作树中的新行,会对新行进行阶段性提交,但在工作树中该行会被还原。</target>
        </trans-unit>
        <trans-unit id="a266660a35cd18470141c43d8a3ffa2b3074c06a" translate="yes" xml:space="preserve">
          <source>There are also other situations that cause dangling objects. For example, a &quot;dangling blob&quot; may arise because you did a &lt;code&gt;git add&lt;/code&gt; of a file, but then, before you actually committed it and made it part of the bigger picture, you changed something else in that file and committed that &lt;strong&gt;updated&lt;/strong&gt; thing&amp;mdash;​the old state that you added originally ends up not being pointed to by any commit or tree, so it&amp;rsquo;s now a dangling blob object.</source>
          <target state="translated">还有其他情况会导致物体悬空。例如，由于您对文件进行 &lt;code&gt;git add&lt;/code&gt; ，可能会出现&amp;ldquo;悬空的斑点&amp;rdquo; ，但是，在实际提交该文件并将其作为大图的一部分之前，您更改了该文件中的其他内容并提交了&lt;strong&gt;更新的内容&lt;/strong&gt; -最初添加的旧状态最终没有被任何提交或树指向，因此现在是一个悬空的Blob对象。</target>
        </trans-unit>
        <trans-unit id="232088d916b340ecad3098c72c2ebccbe30b76e5" translate="yes" xml:space="preserve">
          <source>There are also several operations which should be avoided entirely, as they will make the patch impossible to apply:</source>
          <target state="translated">此外,还有几种操作也应完全避免,因为它们会使补丁无法应用。</target>
        </trans-unit>
        <trans-unit id="eeb0752be9462c9bd2e54575f2023419e06b3d3b" translate="yes" xml:space="preserve">
          <source>There are also ways to automate the bisecting process if you have a test script that can tell a good from a bad commit. See &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; for more information about this and other &lt;code&gt;git
bisect&lt;/code&gt; features.</source>
          <target state="translated">如果您的测试脚本可以从错误的提交中分辨出好消息，那么还有其他方法可以自动执行平分过程。有关此功能和其他 &lt;code&gt;git bisect&lt;/code&gt; 功能的更多信息，请参见&lt;a href=&quot;git-bisect&quot;&gt;git-bisect [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="753d0dde7d0dbacd496fb113e3e96e5ea6d9494d" translate="yes" xml:space="preserve">
          <source>There are four different types of objects: &quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;, and &quot;tag&quot;.</source>
          <target state="translated">有四种不同类型的对象。&quot;blob&quot;,&quot;树&quot;,&quot;提交 &quot;和 &quot;标签&quot;。</target>
        </trans-unit>
        <trans-unit id="a3d0232ce28c94288cf502f722ca216e09b8c5b1" translate="yes" xml:space="preserve">
          <source>There are implementations of Git that do not leave usable values in some fields (e.g. JGit); by excluding these fields from the comparison, the &lt;code&gt;minimal&lt;/code&gt; mode may help interoperability when the same repository is used by these other systems at the same time.</source>
          <target state="translated">有一些Git的实现并没有在某些领域（例如JGit）中留下可用的值。通过从比较中排除这些字段， &lt;code&gt;minimal&lt;/code&gt; 模式可以帮助当其他系统同时使用同一存储库时的互操作性。</target>
        </trans-unit>
        <trans-unit id="ac26d523869587e187089ca0cfe8dfa88bde0428" translate="yes" xml:space="preserve">
          <source>There are many more; see the &quot;SPECIFYING REVISIONS&quot; section of the &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; man page for the complete list of ways to name revisions. Some examples:</source>
          <target state="translated">还有更多；有关命名修订的完整方法列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;手册页的&amp;ldquo; SPECIFYING REVISIONS&amp;rdquo;部分。一些例子：</target>
        </trans-unit>
        <trans-unit id="caa64d4f477bb9cc6ae8b8763c8d93ec4bfb0cef" translate="yes" xml:space="preserve">
          <source>There are no facilities for helping users find what unwanted crud they should delete, which means they are much more likely to have incomplete or partial cleanups that sometimes result in confusion and people wasting time trying to understand. (For example, folks tend to just look for big files to delete instead of big directories or extensions, and once they do so, then sometime later folks using the new repository who are going through history will notice a build artifact directory that has some files but not others, or a cache of dependencies (node_modules or similar) which couldn&amp;rsquo;t have ever been functional since it&amp;rsquo;s missing some files.)</source>
          <target state="translated">没有任何工具可以帮助用户找到应该删除的多余杂物，这意味着他们很可能会进行不完全或部分清理，有时会造成混乱，导致人们浪费时间去理解。（例如，人们倾向于只查找要删除的大文件，而不是大目录或扩展名，一旦这样做，那么以后使用新存储库的人们会在历史记录中看到一个构建工件目录，其中包含一些文件但不是其他，或者是依赖项的缓存（node_modules或类似的东西），因为丢失了一些文件，这些缓存本来无法发挥作用。）</target>
        </trans-unit>
        <trans-unit id="ce4a9f9a1026ea763732ff998a2bcfb7b60f26ca" translate="yes" xml:space="preserve">
          <source>There are no public Trace2 data structures.</source>
          <target state="translated">没有公共的Trace2数据结构。</target>
        </trans-unit>
        <trans-unit id="5a1dbdef2a9d4fcde2fec24ad984bfc7ec6f3aa2" translate="yes" xml:space="preserve">
          <source>There are numerous other tools, such as StGit, which exist for the purpose of maintaining a patch series. These are outside of the scope of this manual.</source>
          <target state="translated">还有许多其他的工具,比如StGit,它们是为了维护补丁系列而存在的。这些都不在本手册的范围之内。</target>
        </trans-unit>
        <trans-unit id="306721e74c73edf4b4a1c2554be600724c25d3f0" translate="yes" xml:space="preserve">
          <source>There are other estimates saying that 80% of the cost related to software is about maintenance &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">还有其他估计表明与软件相关的成本中有80％与维护有关&lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7eccee0caa41472aded0ea349d3d3fa4831b32ab" translate="yes" xml:space="preserve">
          <source>There are other real-world examples of using update and post-update hooks found in the Documentation/howto directory.</source>
          <target state="translated">在Documentation/howto目录下还有其他使用更新和更新后钩子的实际例子。</target>
        </trans-unit>
        <trans-unit id="ddc4304f0c733f93eaa36c71971b210be6c86baa" translate="yes" xml:space="preserve">
          <source>There are several built-in formats, and you can define additional formats by setting a pretty.&amp;lt;name&amp;gt; config option to either another format name, or a &lt;code&gt;format:&lt;/code&gt; string, as described below (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Here are the details of the built-in formats:</source>
          <target state="translated">内置的格式有几种，您可以通过将pretty。&amp;lt;name&amp;gt; config选项设置为另一个格式名称或 &lt;code&gt;format:&lt;/code&gt; string 来定义其他格式，如下所述（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。以下是内置格式的详细信息：</target>
        </trans-unit>
        <trans-unit id="172e083c83bf7e6cbde177805c61722f6bdc0777" translate="yes" xml:space="preserve">
          <source>There are some numbers about bugs in general, like a NIST study in 2002 &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt; that said:</source>
          <target state="translated">一般而言，关于错误的数字很多，例如2002年的NIST研究&lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt;说：</target>
        </trans-unit>
        <trans-unit id="1a73feb2f257a54073e6e874ef78ceeefd47d29e" translate="yes" xml:space="preserve">
          <source>There are some subtle differences how the backends behave.</source>
          <target state="translated">后台的表现有一些微妙的差异。</target>
        </trans-unit>
        <trans-unit id="a41ebe77f2eb54fbd4f30714a2e14c8c1d436ea0" translate="yes" xml:space="preserve">
          <source>There are three commands with similar names: &lt;code&gt;git reset&lt;/code&gt;, &lt;code&gt;git restore&lt;/code&gt; and &lt;code&gt;git revert&lt;/code&gt;.</source>
          <target state="translated">有三个名称相似的命令： &lt;code&gt;git reset&lt;/code&gt; ， &lt;code&gt;git restore&lt;/code&gt; 和 &lt;code&gt;git revert&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27e17ed315eeb27fa67bd10d3870c4d2deb8a92d" translate="yes" xml:space="preserve">
          <source>There are three different approaches: use an add-on to turn off line wraps, configure Thunderbird to not mangle patches, or use an external editor to keep Thunderbird from mangling the patches.</source>
          <target state="translated">有三种不同的方法:使用插件关闭行包装,配置Thunderbird不乱打补丁,或者使用外部编辑器来防止Thunderbird乱打补丁。</target>
        </trans-unit>
        <trans-unit id="8c553f5839a8296a42918c5ea6f6a2fcca19fa49" translate="yes" xml:space="preserve">
          <source>There are three main tools that can be used for this:</source>
          <target state="translated">主要有三个工具可以使用。</target>
        </trans-unit>
        <trans-unit id="86e24f426735724adb9ab7ea59c461905251e8e9" translate="yes" xml:space="preserve">
          <source>There are three ways to specify which refs to update on the remote end.</source>
          <target state="translated">有三种方法可以指定在远程端更新哪些refs。</target>
        </trans-unit>
        <trans-unit id="5544b2d42620b4375dbc730230171fe04b9f972b" translate="yes" xml:space="preserve">
          <source>There are two different types of capabilities: normal capabilities, which can be used to convey information or alter the behavior of a request, and commands, which are the core actions that a client wants to perform (fetch, push, etc).</source>
          <target state="translated">能力有两种不同的类型:普通能力和命令,前者可以用来传递信息或改变请求的行为,后者是客户端要执行的核心操作(获取、推送等)。</target>
        </trans-unit>
        <trans-unit id="c2015c03c4c8786233c499c7815e06c17100a16b" translate="yes" xml:space="preserve">
          <source>There are two formats accepted for patch files:</source>
          <target state="translated">补丁文件有两种格式可接受。</target>
        </trans-unit>
        <trans-unit id="9b5e9b84c7e0cf0cc62bfad7ffc7f5a42847bbc1" translate="yes" xml:space="preserve">
          <source>There are two kinds of fixes, discussed in the following subsections:</source>
          <target state="translated">有两种修复方式,在下面的小节中讨论。</target>
        </trans-unit>
        <trans-unit id="afe3df249e404830655fd820b0b8e96397ac9183" translate="yes" xml:space="preserve">
          <source>There are two main tools that can be used to include changes from one branch on another: &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; and &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;.</source>
          <target state="translated">有两个主要工具可用于包括从一个分支到另一个分支的更改：&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;和&lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1432c9def859812f2dcccb492cbe2b422538cffb" translate="yes" xml:space="preserve">
          <source>There are two ways to specify which commits to operate on.</source>
          <target state="translated">有两种方法可以指定对哪些提交进行操作。</target>
        </trans-unit>
        <trans-unit id="04a6eae6f43fc050171fa2270096884eaba0fee3" translate="yes" xml:space="preserve">
          <source>There is a difference between listing multiple &amp;lt;refspec&amp;gt; directly on &lt;em&gt;git pull&lt;/em&gt; command line and having multiple &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; entries in your configuration for a &amp;lt;repository&amp;gt; and running a &lt;em&gt;git pull&lt;/em&gt; command without any explicit &amp;lt;refspec&amp;gt; parameters. &amp;lt;refspec&amp;gt;s listed explicitly on the command line are always merged into the current branch after fetching. In other words, if you list more than one remote ref, &lt;em&gt;git pull&lt;/em&gt; will create an Octopus merge. On the other hand, if you do not list any explicit &amp;lt;refspec&amp;gt; parameter on the command line, &lt;em&gt;git pull&lt;/em&gt; will fetch all the &amp;lt;refspec&amp;gt;s it finds in the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; configuration and merge only the first &amp;lt;refspec&amp;gt; found into the current branch. This is because making an Octopus from remote refs is rarely done, while keeping track of multiple remote heads in one-go by fetching more than one is often useful.</source>
          <target state="translated">直接在&lt;em&gt;git pull&lt;/em&gt;命令行上列出多个&amp;lt; &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; &amp;gt;和在配置中为&amp;lt;repository&amp;gt;获取多个remote。&amp;lt;repository&amp;gt; .fetch条目，以及运行不带任何显式&amp;lt;refspec&amp;gt;参数的&lt;em&gt;git pull&lt;/em&gt;命令之间有区别。在命令行中明确列出的&amp;lt;refspec&amp;gt;总是在获取后合并到当前分支中。换句话说，如果您列出多个远程引用，则&lt;em&gt;git pull&lt;/em&gt;将创建一个八达通合并。另一方面，如果未在命令行上列出任何显式的&amp;lt;refspec&amp;gt;参数，则&lt;em&gt;git pull&lt;/em&gt;将获取在 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 找到的所有&amp;lt; refspec&amp;gt;。&amp;lt;repository&amp;gt; .fetch配置并仅将找到的第一个&amp;lt;refspec&amp;gt;合并到当前分支中。这是因为很少用远程引用来制作章鱼，而通过获取多个来一次跟踪多个远程头通常是有用的。</target>
        </trans-unit>
        <trans-unit id="08d27e369ae02f07111163548604defe0fd7ba02" translate="yes" xml:space="preserve">
          <source>There is a fourth official branch that is used slightly differently:</source>
          <target state="translated">还有第四个官科,使用方法略有不同。</target>
        </trans-unit>
        <trans-unit id="3ab0818052937d36eff9b5a2767bc99b339b1151" translate="yes" xml:space="preserve">
          <source>There is a script in contrib/thunderbird-patch-inline which can help you include patches with Thunderbird in an easy way. To use it, do the steps above and then use the script as the external editor.</source>
          <target state="translated">在 contrib/thunderbird-patch-inline 中有一个脚本,它可以帮助你以一种简单的方式加入 Thunderbird 的补丁。要使用它,请执行上面的步骤,然后使用该脚本作为外部编辑器。</target>
        </trans-unit>
        <trans-unit id="1232149fc68bcd969b013f8dcdb8f804dc24a0d6" translate="yes" xml:space="preserve">
          <source>There is a tradeoff of course: merges require a more careful branch management. The following subsections discuss the important points.</source>
          <target state="translated">当然有一个权衡:合并需要更细致的分支机构管理。以下各小节将讨论重要的几点。</target>
        </trans-unit>
        <trans-unit id="dad64266cc32a47cdf74ec10317455f91f86159c" translate="yes" xml:space="preserve">
          <source>There is already a project called BBChop created by Ealdwulf Wuffinga on Github that does something like that using Bayesian Search Theory &lt;a href=&quot;#9&quot;&gt;[9]&lt;/a&gt;:</source>
          <target state="translated">Ealdwulf Wuffinga在Github上已经有一个名为BBChop的项目，该项目使用贝叶斯搜索理论&lt;a href=&quot;#9&quot;&gt;[9]进行&lt;/a&gt;类似的操作：</target>
        </trans-unit>
        <trans-unit id="72c8cb7314c2d9e687a4188f4607320887a3abaf" translate="yes" xml:space="preserve">
          <source>There is also a deprecated &lt;code&gt;[section.subsection]&lt;/code&gt; syntax. With this syntax, the subsection name is converted to lower-case and is also compared case sensitively. These subsection names follow the same restrictions as section names.</source>
          <target state="translated">还有不推荐使用的 &lt;code&gt;[section.subsection]&lt;/code&gt; 语法。使用此语法，小节名称将转换为小写，并且还会区分大小写进行比较。这些小节名称遵循与节名称相同的限制。</target>
        </trans-unit>
        <trans-unit id="562a7aac41f0a6a2b8bd94c80ba1df49ae8c2861" translate="yes" xml:space="preserve">
          <source>There is also an alternate -z format recommended for machine parsing. In that format, the status field is the same, but some other things change. First, the &lt;code&gt;-&amp;gt;&lt;/code&gt; is omitted from rename entries and the field order is reversed (e.g &lt;code&gt;from -&amp;gt; to&lt;/code&gt; becomes &lt;code&gt;to from&lt;/code&gt;). Second, a NUL (ASCII 0) follows each filename, replacing space as a field separator and the terminating newline (but a space still separates the status field from the first filename). Third, filenames containing special characters are not specially formatted; no quoting or backslash-escaping is performed.</source>
          <target state="translated">建议使用另一种-z格式进行机器解析。在这种格式下，状态字段是相同的，但其他一些内容会发生变化。首先，在重命名条目中省略了 &lt;code&gt;-&amp;gt;&lt;/code&gt; ，并且字段顺序相反（例如， &lt;code&gt;from -&amp;gt; to&lt;/code&gt; 变为 &lt;code&gt;to from&lt;/code&gt; ）。其次，每个文件名后面都有一个NUL（ASCII 0），用空格代替字段分隔符和结尾的换行符（但空格仍将状态字段与第一个文件名分隔开）。第三，包含特殊字符的文件名不是特殊格式的。不执行引号或反斜杠转义。</target>
        </trans-unit>
        <trans-unit id="23b53316aea0dd64f8f21ea0eae539235bf45a74" translate="yes" xml:space="preserve">
          <source>There is also an option to sort by versions, this can be done by using the fieldname &lt;code&gt;version:refname&lt;/code&gt; or its alias &lt;code&gt;v:refname&lt;/code&gt;.</source>
          <target state="translated">还有一个按版本排序的选项，可以通过使用字段名 &lt;code&gt;version:refname&lt;/code&gt; 或其别名 &lt;code&gt;v:refname&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="490f0c7223e032436f3ed74187899d6766a21bb5" translate="yes" xml:space="preserve">
          <source>There is another common situation where you may encounter non-fast-forward rejection when you try to push, and it is possible even when you are pushing into a repository nobody else pushes into. After you push commit A yourself (in the first picture in this section), replace it with &quot;git commit --amend&quot; to produce commit B, and you try to push it out, because forgot that you have pushed A out already. In such a case, and only if you are certain that nobody in the meantime fetched your earlier commit A (and started building on top of it), you can run &quot;git push --force&quot; to overwrite it. In other words, &quot;git push --force&quot; is a method reserved for a case where you do mean to lose history.</source>
          <target state="translated">还有一种常见的情况是,当你尝试推送时,可能会遇到非快进式的拒绝,即使是你推送到一个没有人推送的仓库里,也有可能出现这种情况。你自己推送了提交A后(本节第一张图),用 &quot;git commit --amend &quot;替换成提交B,然后你想推送出去,因为忘了你已经推送了A。在这种情况下,只有当你确定在此期间没有人取走你之前的提交A(并在它的基础上开始构建),你可以运行 &quot;git push --force &quot;来覆盖它。换句话说,&quot;git push --force &quot;是一种保留给您确实要丢失历史记录的情况的方法。</target>
        </trans-unit>
        <trans-unit id="8a8fda27a5ab0014e2c03663c10e41e5858f14f1" translate="yes" xml:space="preserve">
          <source>There is another simplification mode available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76938def2c927fda8d1c815e17291d57380d4a8a" translate="yes" xml:space="preserve">
          <source>There is another tweak in the bisection algorithm that has not been described in the &quot;bisection algorithm&quot; above.</source>
          <target state="translated">在二分法算法中还有一个调整,上面的 &quot;二分法算法 &quot;中没有介绍。</target>
        </trans-unit>
        <trans-unit id="6cd697be600e420b39bb68cc6d967c4ceca70af4" translate="yes" xml:space="preserve">
          <source>There is no option for &lt;code&gt;git rm&lt;/code&gt; to remove from the index only the paths that have disappeared from the filesystem. However, depending on the use case, there are several ways that can be done.</source>
          <target state="translated">没有为没有选项 &lt;code&gt;git rm&lt;/code&gt; 从索引中只有那些从文件系统中消失的路径删除。但是，根据使用情况，有几种方法可以完成。</target>
        </trans-unit>
        <trans-unit id="60bcaa98facce6fa9b4916fcb4556840549eaf70" translate="yes" xml:space="preserve">
          <source>There is no other restriction on the replaced and replacement objects. Merge commits can be replaced by non-merge commits and vice versa.</source>
          <target state="translated">对被替换和替换对象没有其他限制。合并提交可以被非合并提交所取代,反之亦然。</target>
        </trans-unit>
        <trans-unit id="5b920fe2651a1acef3f4de11b5f87d418bf37e32" translate="yes" xml:space="preserve">
          <source>There is now a new commit &lt;code&gt;e&lt;/code&gt;, but it is referenced only by &lt;code&gt;HEAD&lt;/code&gt;. We can of course add yet another commit in this state:</source>
          <target state="translated">现在有一个新的提交 &lt;code&gt;e&lt;/code&gt; ，但仅由 &lt;code&gt;HEAD&lt;/code&gt; 引用。我们当然可以在这种状态下添加另一个提交：</target>
        </trans-unit>
        <trans-unit id="e84a3494173a3e4e1765afc114a7bb8588db5e4e" translate="yes" xml:space="preserve">
          <source>There is one special case not mentioned above, which is treated differently. Normally, a merge results in a merge commit, with two parents, one pointing at each of the two lines of development that were merged.</source>
          <target state="translated">有一种特殊的情况上面没有提到,它的处理方式是不同的。通常情况下,合并的结果是一个合并提交,有两个父节点,一个指向被合并的两条开发线。</target>
        </trans-unit>
        <trans-unit id="9c233ac02212216497063926a3cd425b73c1b106" translate="yes" xml:space="preserve">
          <source>There may be other problems when using &lt;code&gt;git rev-list&lt;/code&gt; related to pending objects.</source>
          <target state="translated">使用与待处理对象相关的 &lt;code&gt;git rev-list&lt;/code&gt; 时，可能还会有其他问题。</target>
        </trans-unit>
        <trans-unit id="3cc97d3b58e95d007d294ed252208117b7ea36ad" translate="yes" xml:space="preserve">
          <source>There was a discussion at one point on the linux kernel mailing list of whether it was ok to always ask end user to bisect, and very good points were made to support the point of view that it is ok.</source>
          <target state="translated">在linux内核邮件列表上曾经讨论过是否可以总是要求终端用户进行二分法,并且提出了非常好的观点,支持这样做的观点。</target>
        </trans-unit>
        <trans-unit id="e31f2056d77b9761665b1e39804c963e7c7e3f73" translate="yes" xml:space="preserve">
          <source>Therefore if the refspec for the remote includes e.g. &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt;, or you manually run e.g. &lt;code&gt;git fetch
--prune &amp;lt;name&amp;gt; &quot;refs/tags/*:refs/tags/*&quot;&lt;/code&gt; it won&amp;rsquo;t be stale remote tracking branches that are deleted, but any local tag that doesn&amp;rsquo;t exist on the remote.</source>
          <target state="translated">因此，如果远程的refspec包括例如 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; ，或者您手动运行例如 &lt;code&gt;git fetch --prune &amp;lt;name&amp;gt; &quot;refs/tags/*:refs/tags/*&quot;&lt;/code&gt; 它将不会过期的远程跟踪分支将被删除，但是远程上不存在的任何本地标记。</target>
        </trans-unit>
        <trans-unit id="22e33781a4f63d74c967572b3d2d5742f6f5b3cf" translate="yes" xml:space="preserve">
          <source>These are applied in sequence. The set of filepairs &lt;code&gt;git diff-*&lt;/code&gt; commands find are used as the input to diffcore-break, and the output from diffcore-break is used as the input to the next transformation. The final result is then passed to the output routine and generates either diff-raw format (see Output format sections of the manual for &lt;code&gt;git diff-*&lt;/code&gt; commands) or diff-patch format.</source>
          <target state="translated">这些按顺序应用。找到的文件对 &lt;code&gt;git diff-*&lt;/code&gt; 命令集用作diffcore-break的输入，而diffcore-break的输出用作下一个转换的输入。然后将最终结果传递到输出例程，并生成diff-raw格式（有关 &lt;code&gt;git diff-*&lt;/code&gt; 命令，请参见手册的&amp;ldquo;输出格式&amp;rdquo;部分）或diff-patch格式。</target>
        </trans-unit>
        <trans-unit id="5e4c5d2d8cb413a7bc102a12d4b32266eb5dffbd" translate="yes" xml:space="preserve">
          <source>These are concerned with describing the specific Git command after the command line, config, and environment are inspected. e.g: &lt;code&gt;void trace2_cmd_name(const char *name)&lt;/code&gt;, &lt;code&gt;void trace2_cmd_mode(const char *mode)&lt;/code&gt;.</source>
          <target state="translated">这些与检查命令行，配置和环境之后描述特定的Git命令有关。例如： &lt;code&gt;void trace2_cmd_name(const char *name)&lt;/code&gt; ， &lt;code&gt;void trace2_cmd_mode(const char *mode)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd918e1aed68e545e545890a5d457bd39124acbb" translate="yes" xml:space="preserve">
          <source>These are concerned with recording performance data over regions or spans of code. e.g: &lt;code&gt;void trace2_region_enter(const char *category, const char *label, const struct repository *repo)&lt;/code&gt;.</source>
          <target state="translated">这些与在代码的区域或跨度上记录性能数据有关。例如： &lt;code&gt;void trace2_region_enter(const char *category, const char *label, const struct repository *repo)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10ea7c6e4b3ea51596f6b19ba236a57b5e812041" translate="yes" xml:space="preserve">
          <source>These are concerned with the lifetime of the overall git process. e.g: &lt;code&gt;void trace2_initialize_clock()&lt;/code&gt;, &lt;code&gt;void trace2_initialize()&lt;/code&gt;, &lt;code&gt;int trace2_is_enabled()&lt;/code&gt;, &lt;code&gt;void trace2_cmd_start(int argc, const char **argv)&lt;/code&gt;.</source>
          <target state="translated">这些与整个git过程的生命周期有关。例如： &lt;code&gt;void trace2_initialize_clock()&lt;/code&gt; ， &lt;code&gt;void trace2_initialize()&lt;/code&gt; ， &lt;code&gt;int trace2_is_enabled()&lt;/code&gt; ， &lt;code&gt;void trace2_cmd_start(int argc, const char **argv)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3dce3473c941e3b3b27a31ac8449a2f1991a75d0" translate="yes" xml:space="preserve">
          <source>These are concerned with the various spawned child processes, including shell scripts, git commands, editors, pagers, and hooks.</source>
          <target state="translated">这些涉及到各种产卵的子进程,包括shell脚本、git命令、编辑器、分页器和钩子。</target>
        </trans-unit>
        <trans-unit id="64d6caf87f558c78a882445d71ea9cd47be32d78" translate="yes" xml:space="preserve">
          <source>These are internal helper commands used by other commands; end users typically do not use them directly.</source>
          <target state="translated">这些都是其他命令使用的内部辅助命令,最终用户一般不会直接使用它们。</target>
        </trans-unit>
        <trans-unit id="14e40973cf60a547a4fee511ff95c4f84a31a06f" translate="yes" xml:space="preserve">
          <source>These are only used with the &lt;code&gt;dcommit&lt;/code&gt; and &lt;code&gt;rebase&lt;/code&gt; commands.</source>
          <target state="translated">这些仅与 &lt;code&gt;dcommit&lt;/code&gt; 和 &lt;code&gt;rebase&lt;/code&gt; 命令一起使用。</target>
        </trans-unit>
        <trans-unit id="1f4226446a769c76931ca392e2a09f31777b3654" translate="yes" xml:space="preserve">
          <source>These are optional command-line options for init. Each of these flags can point to a relative repository path (--tags=project/tags) or a full url (--tags=https://foo.org/project/tags). You can specify more than one --tags and/or --branches options, in case your Subversion repository places tags or branches under multiple paths. The option --stdlayout is a shorthand way of setting trunk,tags,branches as the relative paths, which is the Subversion default. If any of the other options are given as well, they take precedence.</source>
          <target state="translated">这些都是init的可选命令行选项,它们可以指向相对仓库路径(-tags=project/tags)或完整的url(-tags=)。每一个标志都可以指向一个相对的版本库路径 (--tags=project/tags)或一个完整的 URL (--tagshttps://foo.org/project/tags)。你可以指定多个 --tags 和/或 --branches 选项,以防你的 Subversion 仓库将标签或分支放在多个路径下。选项 --stdlayout 是将 trunk,tags,branches 设置为相对路径的速记方式,这是 Subversion 的默认值。如果同时给出了其他选项,则它们优先。</target>
        </trans-unit>
        <trans-unit id="ef89fe03d8c6b725e4e01a5ddca75169500d3912" translate="yes" xml:space="preserve">
          <source>These attributes affect how the contents stored in the repository are copied to the working tree files when commands such as &lt;code&gt;git switch&lt;/code&gt;, &lt;code&gt;git checkout&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; run. They also affect how Git stores the contents you prepare in the working tree in the repository upon &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">当运行诸如 &lt;code&gt;git switch&lt;/code&gt; ， &lt;code&gt;git checkout&lt;/code&gt; 和 &lt;code&gt;git merge&lt;/code&gt; 之类的命令时，这些属性影响存储在存储库中的内容如何复制到工作树文件中。它们还会影响 &lt;code&gt;git add&lt;/code&gt; 和 &lt;code&gt;git commit&lt;/code&gt; 时Git如何将您准备的内容存储在存储库中的工作树中。</target>
        </trans-unit>
        <trans-unit id="1e36f59cc4fba5296689c97860f8ef3c808cbf54" translate="yes" xml:space="preserve">
          <source>These can be easily kept up to date using &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;可以很容易地使它们保持最新状态。</target>
        </trans-unit>
        <trans-unit id="d8f5a662d30248028e58618a9cb324b38272bbd8" translate="yes" xml:space="preserve">
          <source>These commands all compare two sets of things; what is compared differs:</source>
          <target state="translated">这些命令都是比较两组事物,比较的内容不同。</target>
        </trans-unit>
        <trans-unit id="6e07bfec6529e0e8049d6a168dde51eb0ed55268" translate="yes" xml:space="preserve">
          <source>These commands are to interact with foreign SCM and with other people via patch over e-mail.</source>
          <target state="translated">这些命令是通过电子邮件与国外SCM以及通过补丁与其他人员进行交互。</target>
        </trans-unit>
        <trans-unit id="8e87e31fbdfcc66d2844293591fb44e9bb68be03" translate="yes" xml:space="preserve">
          <source>These config values are loaded from system, global, and local Git config, as available. If &lt;code&gt;git for-each-repo&lt;/code&gt; is run in a directory that is not a Git repository, then only the system and global config is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008c5282b165f202ade67dc870d3522a81a841bd" translate="yes" xml:space="preserve">
          <source>These configuration variables control &lt;code&gt;internal&lt;/code&gt; gitweb behavior.</source>
          <target state="translated">这些配置变量控制 &lt;code&gt;internal&lt;/code&gt; gitweb行为。</target>
        </trans-unit>
        <trans-unit id="94d243826a65ff43f06f691e3b2f877746c8e3a7" translate="yes" xml:space="preserve">
          <source>These configurations enable two things. First, each unix user (&lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt;) of the server will be able to browse through gitweb Git repositories found in &lt;code&gt;~/public_git/&lt;/code&gt; with the following url:</source>
          <target state="translated">这些配置启用两件事。首先，服务器的每个unix用户（ &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; ）都可以使用以下URL 浏览 &lt;code&gt;~/public_git/&lt;/code&gt; gitweb Git存储库：</target>
        </trans-unit>
        <trans-unit id="3c188c162ef90ed4e72b2204b53fd7bbdf63ed82" translate="yes" xml:space="preserve">
          <source>These environment variables apply to &lt;code&gt;all&lt;/code&gt; core Git commands. Nb: it is worth noting that they may be used/overridden by SCMS sitting above Git so take care if using a foreign front-end.</source>
          <target state="translated">这些环境变量适用于 &lt;code&gt;all&lt;/code&gt; 核心Git命令。Nb：值得注意的是，位于Git上方的SCMS可能会使用/覆盖它们，因此，如果使用国外前端，请当心。</target>
        </trans-unit>
        <trans-unit id="e4a9928c908043039dae5cc89a184941db222aba" translate="yes" xml:space="preserve">
          <source>These exclude patterns come from these places, in order:</source>
          <target state="translated">这些排除模式来自于这些地方,依次。</target>
        </trans-unit>
        <trans-unit id="75ad982aca6a7add80092ae27820348741497d7e" translate="yes" xml:space="preserve">
          <source>These flag are passed to the &lt;code&gt;git apply&lt;/code&gt; program (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) that applies the patch.</source>
          <target state="translated">这些标志传递给 &lt;code&gt;git apply&lt;/code&gt; 补丁的git apply程序（请参阅&lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a66ecfa5cef3d43b11b6332452dde3bc34998a82" translate="yes" xml:space="preserve">
          <source>These flags are passed to &lt;code&gt;git am&lt;/code&gt; to easily change the dates of the rebased commits (see &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;).</source>
          <target state="translated">这些标志传递给 &lt;code&gt;git am&lt;/code&gt; ,以轻松更改重新基于基础的提交的日期（请参见&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6f1d3498209d5426cb1c8295c9947466ac12cab4" translate="yes" xml:space="preserve">
          <source>These flags are passed to the &lt;code&gt;git apply&lt;/code&gt; (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) program that applies the patch.</source>
          <target state="translated">这些标志传递给 &lt;code&gt;git apply&lt;/code&gt; 补丁的git apply（请参阅&lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt;）程序。</target>
        </trans-unit>
        <trans-unit id="17c5d825c714d7f669df648adc8ffa3b9865aa3a" translate="yes" xml:space="preserve">
          <source>These forms reset the index entries for all paths that match the &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; to their state at &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;. (It does not affect the working tree or the current branch.)</source>
          <target state="translated">这些格式将与 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 匹配的所有路径的索引条目重置为其在 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 的状态。（它不会影响工作树或当前分支。）</target>
        </trans-unit>
        <trans-unit id="84dfe82e69639d7dd0490e18b4061edc5e5f61bb" translate="yes" xml:space="preserve">
          <source>These general best practices are very helpful if you bisect often.</source>
          <target state="translated">这些一般的最佳实践是非常有用的,如果你经常两败俱伤。</target>
        </trans-unit>
        <trans-unit id="db63350c8a27af092cfd256119dcf34d87e7125f" translate="yes" xml:space="preserve">
          <source>These instructions use the &lt;code&gt;git-cvsimport&lt;/code&gt; script which ships with git, but other importers may provide better results. See the note in &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport[1]&lt;/a&gt; for other options.</source>
          <target state="translated">这些说明使用 &lt;code&gt;git-cvsimport&lt;/code&gt; 附带的git-cvsimport脚本，但其他导入程序可能会提供更好的结果。有关其他选项，请参见&lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport [1]中&lt;/a&gt;的注释。</target>
        </trans-unit>
        <trans-unit id="4de4cd9ec9920076e498bf4f8c01b7cc0e7335b0" translate="yes" xml:space="preserve">
          <source>These messages are concerned with Git thread usage.</source>
          <target state="translated">这些信息与Git线程的使用有关。</target>
        </trans-unit>
        <trans-unit id="b8e5bd243ffdab655773f15dbcfc0554b819902f" translate="yes" xml:space="preserve">
          <source>These options are deprecated. Use the above --notes/--no-notes options instead.</source>
          <target state="translated">这些选项已经过时。</target>
        </trans-unit>
        <trans-unit id="894173daf027c82b1254f620d2cbbddacd04b7fd" translate="yes" xml:space="preserve">
          <source>These options are ignored for historical reasons.</source>
          <target state="translated">由于历史原因,这些选项被忽略了。</target>
        </trans-unit>
        <trans-unit id="0608f735748e7710136ac2ca4b1a8fc7f8d0f8a8" translate="yes" xml:space="preserve">
          <source>These options are mostly targeted for packing of Git repositories.</source>
          <target state="translated">这些选项主要针对 Git 仓库的打包。</target>
        </trans-unit>
        <trans-unit id="44fc7c2eb5b5d3f683db2d8973767b7defab9c76" translate="yes" xml:space="preserve">
          <source>These options are passed to &lt;a href=&quot;git-send-pack&quot;&gt;git-send-pack[1]&lt;/a&gt;. A thin transfer significantly reduces the amount of sent data when the sender and receiver share many of the same objects in common. The default is &lt;code&gt;--thin&lt;/code&gt;.</source>
          <target state="translated">这些选项被传递给&lt;a href=&quot;git-send-pack&quot;&gt;git-send-pack [1]&lt;/a&gt;。当发送方和接收方共享许多相同的对象时，精简传输会大大减少发送的数据量。默认值为 &lt;code&gt;--thin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38ddfaeebf99ab2e211259f05e2350cca6be519d" translate="yes" xml:space="preserve">
          <source>These options are primarily useful when converting a repository from one hash algorithm to another; without them, fast-import will fail if it encounters a submodule because it has no way of writing the object ID into the new hash algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c86ff6978b6c3146e6796c4f36abf160da0176d" translate="yes" xml:space="preserve">
          <source>These options can be used in an initial &lt;code&gt;clone&lt;/code&gt;, along with the &lt;code&gt;sync&lt;/code&gt; options described above.</source>
          <target state="translated">这些选项可以与上述 &lt;code&gt;sync&lt;/code&gt; 选项一起用于初始 &lt;code&gt;clone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ade32a888d52a4ba127b2e5cb51121d4b067e67" translate="yes" xml:space="preserve">
          <source>These options can be used in the initial &lt;code&gt;clone&lt;/code&gt; as well as in subsequent &lt;code&gt;sync&lt;/code&gt; operations.</source>
          <target state="translated">这些选项可用于初始 &lt;code&gt;clone&lt;/code&gt; 以及后续的 &lt;code&gt;sync&lt;/code&gt; 操作中。</target>
        </trans-unit>
        <trans-unit id="3f45787718e6c314237aec0cf2c5e63156df92c4" translate="yes" xml:space="preserve">
          <source>These options can be used to modify &lt;code&gt;git p4 rebase&lt;/code&gt; behavior.</source>
          <target state="translated">这些选项可用于修改 &lt;code&gt;git p4 rebase&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="046bf3cadb648529c8cbf517d3ba66246fc697fc" translate="yes" xml:space="preserve">
          <source>These options can be used to modify &lt;code&gt;git p4 submit&lt;/code&gt; behavior.</source>
          <target state="translated">这些选项可用于修改 &lt;code&gt;git p4 submit&lt;/code&gt; 行为。</target>
        </trans-unit>
        <trans-unit id="5bf9264c3d2f29d27aed45b38db366aee6362601" translate="yes" xml:space="preserve">
          <source>These options control layout (defaults to &lt;code&gt;column&lt;/code&gt;). Setting any of these implies &lt;code&gt;always&lt;/code&gt; if none of &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;, or &lt;code&gt;auto&lt;/code&gt; are specified.</source>
          <target state="translated">这些选项控制布局（默认为 &lt;code&gt;column&lt;/code&gt; ）。如果 &lt;code&gt;never&lt;/code&gt; 指定 &lt;code&gt;always&lt;/code&gt; ，never或 &lt;code&gt;auto&lt;/code&gt; 的任何一项，则设置其中的任何一项表示 &lt;code&gt;always&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="510a1cbefb424a60db8479a49dd55a0966d6d945" translate="yes" xml:space="preserve">
          <source>These options control when the feature should be enabled (defaults to &lt;code&gt;never&lt;/code&gt;):</source>
          <target state="translated">这些选项控制何时应启用该功能（默认为 &lt;code&gt;never&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="931e215644554fa9404627a014bfd3cf51399ea5" translate="yes" xml:space="preserve">
          <source>These options take effect whatever the value of the &lt;code&gt;core.splitIndex&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">无论 &lt;code&gt;core.splitIndex&lt;/code&gt; 配置变量的值如何，这些选项都会生效（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。但是，当更改与配置值不符时，会发出警告，因为配置值将在下次读取索引时生效，这将删除该选项的预期效果。</target>
        </trans-unit>
        <trans-unit id="932e8c22c29966222600cac9510425979eeabd1c" translate="yes" xml:space="preserve">
          <source>These options take effect whatever the value of the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">无论 &lt;code&gt;core.untrackedCache&lt;/code&gt; 配置变量的值如何，这些选项都会生效（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。但是，当更改与配置值不符时，会发出警告，因为配置值将在下次读取索引时生效，这将删除该选项的预期效果。</target>
        </trans-unit>
        <trans-unit id="ff7024be4fc3bd9a63ff1aab42e5c2f33080a5ad" translate="yes" xml:space="preserve">
          <source>These parameters can also be set individually with &lt;code&gt;--stat-width=&amp;lt;width&amp;gt;&lt;/code&gt;, &lt;code&gt;--stat-name-width=&amp;lt;name-width&amp;gt;&lt;/code&gt; and &lt;code&gt;--stat-count=&amp;lt;count&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这些参数也可以分别使用 &lt;code&gt;--stat-width=&amp;lt;width&amp;gt;&lt;/code&gt; ，-- &lt;code&gt;--stat-name-width=&amp;lt;name-width&amp;gt;&lt;/code&gt; 和 &lt;code&gt;--stat-count=&amp;lt;count&amp;gt;&lt;/code&gt; 进行设置。</target>
        </trans-unit>
        <trans-unit id="25d97f197e2ad468ea791c831ca2e71054c4e207" translate="yes" xml:space="preserve">
          <source>These remote-tracking references can be deleted as a one-off with either of:</source>
          <target state="translated">这些远程跟踪参考资料可以通过以下两种方式一次性删除:</target>
        </trans-unit>
        <trans-unit id="4994737bcfd88cfa54486bc85e99d5152416b798" translate="yes" xml:space="preserve">
          <source>These rules make it easy for shell script based tools to parse reference names, pathname expansion by the shell when a reference name is used unquoted (by mistake), and also avoid ambiguities in certain reference name expressions (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;):</source>
          <target state="translated">这些规则使基于Shell脚本的工具可以轻松解析引用名称，在引用名称不加引号的情况下（错误地）由外壳扩展路径名，还可以避免某些引用名称表达式中的歧义（请参阅&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="d2d3b8bc5c27c38dddb2f7c9e54b52668c820483" translate="yes" xml:space="preserve">
          <source>These services can be enabled/disabled using the per-repository configuration file:</source>
          <target state="translated">这些服务可以使用每个存储库的配置文件来启用/禁用。</target>
        </trans-unit>
        <trans-unit id="11be9ffec744e4c727f505822229118ed50ca097" translate="yes" xml:space="preserve">
          <source>These services can be globally enabled/disabled using the command-line options of this command. If finer-grained control is desired (e.g. to allow &lt;code&gt;git archive&lt;/code&gt; to be run against only in a few selected repositories the daemon serves), the per-repository configuration file can be used to enable or disable them.</source>
          <target state="translated">可以使用此命令的命令行选项全局启用/禁用这些服务。如果需要更细粒度的控制（例如，仅允许在守护程序所服务的几个选定存储库中运行 &lt;code&gt;git archive&lt;/code&gt; ），则可以使用每个存储库配置文件来启用或禁用它们。</target>
        </trans-unit>
        <trans-unit id="70e4323eda62161a4a47cb9a1d65be89828fd66d" translate="yes" xml:space="preserve">
          <source>These settings help tools pick the right format for output such as patches and result in files being checked out in the appropriate line ending for the platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7a1043f71fa1813c0b5e398e97710f483944d9" translate="yes" xml:space="preserve">
          <source>These things may exist in a Git repository.</source>
          <target state="translated">这些东西可能存在于Git仓库中。</target>
        </trans-unit>
        <trans-unit id="b5c7f688db050c92cfc9bb2aa9d676e52849ec7b" translate="yes" xml:space="preserve">
          <source>These three branches all forked from a common commit, [master], whose commit message is &quot;Add 'git show-branch'&quot;. The &quot;fixes&quot; branch adds one commit &quot;Introduce &quot;reset type&quot; flag to &quot;git reset&quot;&quot;. The &quot;mhf&quot; branch adds many other commits. The current branch is &quot;master&quot;.</source>
          <target state="translated">这三个分支都是从一个共同的提交[master]分叉出来的,其提交信息是 &quot;添加'git show-branch'&quot;。fixes &quot;分支增加了一个提交 &quot;在 &quot;git reset &quot;中引入 &quot;reset type &quot;标志&quot;。mhf &quot;分支增加了许多其他提交。目前的分支是 &quot;master&quot;。</target>
        </trans-unit>
        <trans-unit id="c6204a9318b7a0526e46b8696b2eb378d52ecf11" translate="yes" xml:space="preserve">
          <source>These two filters behave differently, and by default, a filter is taken as the former, massaging the contents into more convenient shape. A missing filter driver definition in the config, or a filter driver that exits with a non-zero status, is not an error but makes the filter a no-op passthru.</source>
          <target state="translated">这两种过滤器的行为是不同的,默认情况下,过滤器被当作前者,将内容按摩成更方便的形状。如果配置中缺少过滤器驱动定义,或者过滤器驱动退出时状态为非零,都不是错误,而是使过滤器成为无操作的通病。</target>
        </trans-unit>
        <trans-unit id="e20e46dc24b79b5218925e423850545226b0898e" translate="yes" xml:space="preserve">
          <source>These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within --window to see if using delta compression saves space. --depth limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.</source>
          <target state="translated">这两个选项会影响如何使用 delta 压缩来存储包中的对象。这些对象首先在内部按类型、大小和可选的名称进行排序,并与 --window 中的其他对象进行比较,以确定使用 delta 压缩是否能节省空间。--depth 限制了最大的 delta 深度;太深会影响解包器的性能,因为 delta 数据需要被应用那么多次才能到达所需的对象。</target>
        </trans-unit>
        <trans-unit id="de212a952b72f4cd05af023bbd056fa8307c4a9f" translate="yes" xml:space="preserve">
          <source>These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within &lt;code&gt;--window&lt;/code&gt; to see if using delta compression saves space. &lt;code&gt;--depth&lt;/code&gt; limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.</source>
          <target state="translated">这两个选项影响使用增量压缩存储包中包含的对象的方式。这些对象首先在内部按类型，大小和可选的名称进行排序，然后与 &lt;code&gt;--window&lt;/code&gt; 中的其他对象进行比较，以查看是否使用增量压缩节省了空间。 &lt;code&gt;--depth&lt;/code&gt; 限制最大增量深度；将其设置得过深会影响解包器方面的性能，因为需要多次应用增量数据才能到达必需的对象。</target>
        </trans-unit>
        <trans-unit id="6a0bfaec1ca5ad5a0f6710f22f7b4b78eecfef67" translate="yes" xml:space="preserve">
          <source>These two syntaxes are mostly equivalent, except the former implies --local option.</source>
          <target state="translated">这两种语法大部分是等价的,只是前者意味着--local选项。</target>
        </trans-unit>
        <trans-unit id="9270307e15adf00d482cdebd8e068750f310bc87" translate="yes" xml:space="preserve">
          <source>These two syntaxes are mostly equivalent, except when cloning, when the former implies --local option. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; for details.</source>
          <target state="translated">除了克隆时（前者暗示--local选项）外，这两种语法几乎都是等效的。有关详细信息，请参见&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="469e074d32a553c54f69af6603803ffbfd2e6dda" translate="yes" xml:space="preserve">
          <source>These types of entries are generally created as a result of using &lt;code&gt;git
commit --amend&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt; and are the commits prior to the amend or rebase occurring. Since these changes are not part of the current project most users will want to expire them sooner, which is why the default is more aggressive than &lt;code&gt;gc.reflogExpire&lt;/code&gt;.</source>
          <target state="translated">这些类型的条目通常是由于使用 &lt;code&gt;git commit --amend&lt;/code&gt; 或 &lt;code&gt;git rebase&lt;/code&gt; 而创建的，它们是在进行amend或rebase之前的提交。由于这些更改不是当前项目的一部分，因此大多数用户希望它们尽快过期，这就是为什么默认值比 &lt;code&gt;gc.reflogExpire&lt;/code&gt; 更具侵略性的原因。</target>
        </trans-unit>
        <trans-unit id="99a10a0726ee032ba80815c05eceb6d5a6ab2aa8" translate="yes" xml:space="preserve">
          <source>These variables control various optional help messages designed to aid new users. All &lt;code&gt;advice.*&lt;/code&gt; variables default to &lt;code&gt;true&lt;/code&gt;, and you can tell Git that you do not need help by setting these to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">这些变量控制旨在帮助新用户的各种可选帮助消息。所有 &lt;code&gt;advice.*&lt;/code&gt; 变量默认为 &lt;code&gt;true&lt;/code&gt; ，可以通过将它们设置为 &lt;code&gt;false&lt;/code&gt; 来告诉Git不需要帮助：</target>
        </trans-unit>
        <trans-unit id="289bbff1e27f0cf157d5208bbfcb9f369ecc1504" translate="yes" xml:space="preserve">
          <source>These variables obviate the need for command-line options in some circumstances, allowing easier restricted usage through git-shell.</source>
          <target state="translated">在某些情况下,这些变量不需要命令行选项,可以通过 git-shell 更容易地限制使用。</target>
        </trans-unit>
        <trans-unit id="48d5c4b33cae3d35014b5a5e266ea897c2a18c9f" translate="yes" xml:space="preserve">
          <source>These will display all commits which exist only on HEAD or on MERGE_HEAD, and which touch an unmerged file.</source>
          <target state="translated">这些将显示所有只存在于 HEAD 或 MERGE_HEAD 上的提交,以及触及未合并文件的提交。</target>
        </trans-unit>
        <trans-unit id="e9ab0d9bdf3f35b7d6ece2d3bc65f4fbb38bad38" translate="yes" xml:space="preserve">
          <source>They are both passed directly to &lt;code&gt;git diff-tree&lt;/code&gt;; see &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt; for more information.</source>
          <target state="translated">它们都直接传递给 &lt;code&gt;git diff-tree&lt;/code&gt; ；有关更多信息，请参见&lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afa16f632fa562fed5a34ad41431101aacb568d7" translate="yes" xml:space="preserve">
          <source>They can include slash &lt;code&gt;/&lt;/code&gt; for hierarchical (directory) grouping, but no slash-separated component can begin with a dot &lt;code&gt;.&lt;/code&gt; or end with the sequence &lt;code&gt;.lock&lt;/code&gt;.</source>
          <target state="translated">它们可以包括斜杠 &lt;code&gt;/&lt;/code&gt; 用于层次结构（目录）分组，但是斜杠分隔的组件不能以点开头 &lt;code&gt;.&lt;/code&gt; 或以序列 &lt;code&gt;.lock&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="48a933f433abac80f2e0e41b240081f7a399893c" translate="yes" xml:space="preserve">
          <source>They cannot be the single character &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">它们不能是单个字符 &lt;code&gt;@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c798a840110b095cd0c31cb10cad16c17f5292dd" translate="yes" xml:space="preserve">
          <source>They cannot begin or end with a slash &lt;code&gt;/&lt;/code&gt; or contain multiple consecutive slashes (see the &lt;code&gt;--normalize&lt;/code&gt; option below for an exception to this rule)</source>
          <target state="translated">它们不能以斜杠开头或结尾 &lt;code&gt;/&lt;/code&gt; 或包含多个连续的斜杠（有关此规则的例外，请参阅下面的 &lt;code&gt;--normalize&lt;/code&gt; 选项）</target>
        </trans-unit>
        <trans-unit id="794c847c2b033448497ba9e6f46f59b7325ccd69" translate="yes" xml:space="preserve">
          <source>They cannot contain a &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">它们不能包含 &lt;code&gt;\&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4cf89d0a711867dbdfa498e7e6b80fb04c020f3" translate="yes" xml:space="preserve">
          <source>They cannot contain a sequence &lt;code&gt;@{&lt;/code&gt;.</source>
          <target state="translated">它们不能包含序列 &lt;code&gt;@{&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c781dcfcbfa7c545717cc72f3f25ac7fba039fd7" translate="yes" xml:space="preserve">
          <source>They cannot end with a dot &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">它们不能以点结尾 &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdf3c698f8591838633d63d5550c41009f5d53bb" translate="yes" xml:space="preserve">
          <source>They cannot have ASCII control characters (i.e. bytes whose values are lower than \040, or \177 &lt;code&gt;DEL&lt;/code&gt;), space, tilde &lt;code&gt;~&lt;/code&gt;, caret &lt;code&gt;^&lt;/code&gt;, or colon &lt;code&gt;:&lt;/code&gt; anywhere.</source>
          <target state="translated">它们不能具有ASCII控制字符（即，值小于\ 040或\ 177 &lt;code&gt;DEL&lt;/code&gt; 的字节），空格，代字号 &lt;code&gt;~&lt;/code&gt; ，插入号 &lt;code&gt;^&lt;/code&gt; 或冒号 &lt;code&gt;:&lt;/code&gt; 任何地方。</target>
        </trans-unit>
        <trans-unit id="9fa9a35ba99f055f59e5fb0fc3903845af8141d1" translate="yes" xml:space="preserve">
          <source>They cannot have question-mark &lt;code&gt;?&lt;/code&gt;, asterisk &lt;code&gt;*&lt;/code&gt;, or open bracket &lt;code&gt;[&lt;/code&gt; anywhere. See the &lt;code&gt;--refspec-pattern&lt;/code&gt; option below for an exception to this rule.</source>
          <target state="translated">他们不能有问号 &lt;code&gt;?&lt;/code&gt; ，星号 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;[&lt;/code&gt; 在任何位置打开括号[ 有关此规则的例外，请参见下面的 &lt;code&gt;--refspec-pattern&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="07233de88d34b821d099ea14e09099281360fa3d" translate="yes" xml:space="preserve">
          <source>They cannot have two consecutive dots &lt;code&gt;..&lt;/code&gt; anywhere.</source>
          <target state="translated">他们不能有两个连续的点 &lt;code&gt;..&lt;/code&gt; 任何地方。</target>
        </trans-unit>
        <trans-unit id="08cc7b3818b658e36c5e9a0a0fcefabb2c9bd5ce" translate="yes" xml:space="preserve">
          <source>They must contain at least one &lt;code&gt;/&lt;/code&gt;. This enforces the presence of a category like &lt;code&gt;heads/&lt;/code&gt;, &lt;code&gt;tags/&lt;/code&gt; etc. but the actual names are not restricted. If the &lt;code&gt;--allow-onelevel&lt;/code&gt; option is used, this rule is waived.</source>
          <target state="translated">它们必须包含至少一个 &lt;code&gt;/&lt;/code&gt; 。这会强制出现诸如 &lt;code&gt;heads/&lt;/code&gt; ， &lt;code&gt;tags/&lt;/code&gt; 等之类的类别，但实际名称不受限制。如果使用 &lt;code&gt;--allow-onelevel&lt;/code&gt; 选项，则将放弃此规则。</target>
        </trans-unit>
        <trans-unit id="9c66e1086c1b783565f285e9f8d345796e4a920b" translate="yes" xml:space="preserve">
          <source>Things get more complicated if the &lt;code&gt;subsystem&lt;/code&gt; changes do not exactly correspond to the ones before the rebase.</source>
          <target state="translated">如果 &lt;code&gt;subsystem&lt;/code&gt; 更改与重新设置之前的更改不完全对应，则事情会变得更加复杂。</target>
        </trans-unit>
        <trans-unit id="877bd5e347693a4c90610529b809f198ae203a8a" translate="yes" xml:space="preserve">
          <source>Think about how to create a clear chapter dependency graph that will allow people to get to important topics without necessarily reading everything in between.</source>
          <target state="translated">思考如何创建一个清晰的章节依赖图,让人们能够进入重要的主题,而不一定要阅读中间的所有内容。</target>
        </trans-unit>
        <trans-unit id="5f03012af2a22f62503c31e1e064eb23ddd2be46" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;key&lt;/code&gt; will be used instead of &amp;lt;token&amp;gt; in the trailer. At the end of this key, a separator can appear and then some space characters. By default the only valid separator is &lt;code&gt;:&lt;/code&gt;, but this can be changed using the &lt;code&gt;trailer.separators&lt;/code&gt; config variable.</source>
          <target state="translated">该 &lt;code&gt;key&lt;/code&gt; 将代替预告片中的&amp;lt;token&amp;gt;使用。在此键的末尾，可能会出现分隔符，然后出现一些空格字符。默认情况下，唯一有效的分隔符是 &lt;code&gt;:&lt;/code&gt; ，但是可以使用 &lt;code&gt;trailer.separators&lt;/code&gt; 配置变量进行更改。</target>
        </trans-unit>
        <trans-unit id="9ed9ef222233001104259cd6ab7e0ea2e028dedb" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;merge&lt;/code&gt; can also be done by &lt;code&gt;pulling from her own remote-tracking branch&lt;/code&gt;, like this:</source>
          <target state="translated">这个 &lt;code&gt;merge&lt;/code&gt; 也可以通过进行 &lt;code&gt;pulling from her own remote-tracking branch&lt;/code&gt; ，就像这样：</target>
        </trans-unit>
        <trans-unit id="0007248c88629a35b9fa8e1cf4c8fdf299191526" translate="yes" xml:space="preserve">
          <source>This accepts all options that &lt;code&gt;git svn fetch&lt;/code&gt; and &lt;code&gt;git rebase&lt;/code&gt; accept. However, &lt;code&gt;--fetch-all&lt;/code&gt; only fetches from the current [svn-remote], and not all [svn-remote] definitions.</source>
          <target state="translated">这将接受 &lt;code&gt;git svn fetch&lt;/code&gt; 和 &lt;code&gt;git rebase&lt;/code&gt; 接受的所有选项。但是，-- &lt;code&gt;--fetch-all&lt;/code&gt; 仅从当前的[svn-remote]定义中获取，而不是从所有的[svn-remote]定义获取。</target>
        </trans-unit>
        <trans-unit id="c118365ba0290d763b2d4e635fbfbb09d23e73e6" translate="yes" xml:space="preserve">
          <source>This action is disabled by default for performance reasons.</source>
          <target state="translated">由于性能原因,该操作默认为禁用。</target>
        </trans-unit>
        <trans-unit id="692de83ae64c152ace96a6b22c40c6c7b5256f5f" translate="yes" xml:space="preserve">
          <source>This adds a link titled &quot;graphiclog&quot; after the &quot;summary&quot; link, leading to &lt;code&gt;git-browser&lt;/code&gt; script, passing &lt;code&gt;r=&amp;lt;project&amp;gt;&lt;/code&gt; as a query parameter.</source>
          <target state="translated">这将在&amp;ldquo;摘要&amp;rdquo;链接之后添加一个名为&amp;ldquo; graphiclog&amp;rdquo;的链接，从而导致 &lt;code&gt;git-browser&lt;/code&gt; 脚本，并传递 &lt;code&gt;r=&amp;lt;project&amp;gt;&lt;/code&gt; 作为查询参数。</target>
        </trans-unit>
        <trans-unit id="9647e1f610a9d28b74cedc3ffa625f5d98628ec8" translate="yes" xml:space="preserve">
          <source>This algorithm extends the patience algorithm to &quot;support low-occurrence common elements&quot;.</source>
          <target state="translated">该算法将耐心算法扩展为 &quot;支持低发生率的共同元素&quot;。</target>
        </trans-unit>
        <trans-unit id="5f9e4d22cfa1bc9f924abb0f51a443db2655b318" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;git svn&lt;/code&gt; to re-map repository URLs and UUIDs from mirrors created using SVN::Mirror (or svk) for metadata.</source>
          <target state="translated">这允许 &lt;code&gt;git svn&lt;/code&gt; 从使用SVN :: Mirror（或svk）为元数据创建的镜像中重新映射存储库URL和UUID。</target>
        </trans-unit>
        <trans-unit id="cb552885bcd7df779f362e35a229c9d935657c60" translate="yes" xml:space="preserve">
          <source>This allows one to specify a Perl regular expression that will cause skipping of all matching paths from checkout from SVN. The &lt;code&gt;--ignore-paths&lt;/code&gt; option should match for every &lt;code&gt;fetch&lt;/code&gt; (including automatic fetches due to &lt;code&gt;clone&lt;/code&gt;, &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, etc) on a given repository.</source>
          <target state="translated">这允许您指定一个Perl正则表达式，该表达式将导致从SVN检出中跳过所有匹配的路径。所述 &lt;code&gt;--ignore-paths&lt;/code&gt; 选项应匹配每 &lt;code&gt;fetch&lt;/code&gt; （包括自动取由于 &lt;code&gt;clone&lt;/code&gt; ， &lt;code&gt;dcommit&lt;/code&gt; ， &lt;code&gt;rebase&lt;/code&gt; 在给定储存库等）。</target>
        </trans-unit>
        <trans-unit id="bf5d12ceb1111e8b06bd58f3985472091a1cae12" translate="yes" xml:space="preserve">
          <source>This allows one to specify a Perl regular expression that will cause the inclusion of only matching paths from checkout from SVN. The &lt;code&gt;--include-paths&lt;/code&gt; option should match for every &lt;code&gt;fetch&lt;/code&gt; (including automatic fetches due to &lt;code&gt;clone&lt;/code&gt;, &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, etc) on a given repository. &lt;code&gt;--ignore-paths&lt;/code&gt; takes precedence over &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">这允许指定一个Perl正则表达式，该正则表达式将导致仅包含来自SVN的检出的匹配路径。所述 &lt;code&gt;--include-paths&lt;/code&gt; 选项应匹配每 &lt;code&gt;fetch&lt;/code&gt; （包括自动取由于 &lt;code&gt;clone&lt;/code&gt; ， &lt;code&gt;dcommit&lt;/code&gt; ， &lt;code&gt;rebase&lt;/code&gt; 在给定储存库等）。 &lt;code&gt;--ignore-paths&lt;/code&gt; 优先于 &lt;code&gt;--include-paths&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c68f089f9144bc4bdc1d710532bfa75a569d11ed" translate="yes" xml:space="preserve">
          <source>This allows one to specify a prefix which is prepended to the names of remotes if trunk/branches/tags are specified. The prefix does not automatically include a trailing slash, so be sure you include one in the argument if that is what you want. If --branches/-b is specified, the prefix must include a trailing slash. Setting a prefix (with a trailing slash) is strongly encouraged in any case, as your SVN-tracking refs will then be located at &quot;refs/remotes/$prefix/&lt;strong&gt;&quot;, which is compatible with Git&amp;rsquo;s own remote-tracking ref layout (refs/remotes/$remote/&lt;/strong&gt;). Setting a prefix is also useful if you wish to track multiple projects that share a common repository. By default, the prefix is set to &lt;code&gt;origin/&lt;/code&gt;.</source>
          <target state="translated">如果指定了中继线/分支/标签，则允许指定一个前缀，该前缀在遥控器的名称之前。前缀不会自动包含尾部斜杠，因此，如果需要，请确保在参数中包括一个斜杠。如果指定了--branches / -b，则前缀必须包含尾部斜杠。在任何情况下都强烈建议设置前缀（带有斜杠），因为这样您的SVN跟踪引用将位于&amp;ldquo; refs / remotes / $ prefix / &lt;strong&gt;&amp;rdquo;，这与Git自己的远程跟踪引用布局兼容（refs / remotes / $ remote /&lt;/strong&gt;）。如果您希望跟踪共享一个公共存储库的多个项目，则设置前缀也很有用。默认情况下，前缀设置为 &lt;code&gt;origin/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99b10fdeae941de841a9ac73e39b7c06fcc2d978" translate="yes" xml:space="preserve">
          <source>This allows revision ranges for partial/cauterized history to be supported. $NUMBER, $NUMBER1:$NUMBER2 (numeric ranges), $NUMBER:HEAD, and BASE:$NUMBER are all supported.</source>
          <target state="translated">这允许支持部分/固化历史的修订范围。$NUMBER、$NUMBER1:$NUMBER2(数字范围)、$NUMBER:HEAD和BASE:$NUMBER都支持。</target>
        </trans-unit>
        <trans-unit id="f18b167effc162d347deb782b83eab22ac73f014" translate="yes" xml:space="preserve">
          <source>This allows users to create repositories from alternate URLs. For example, an administrator could run &lt;code&gt;git svn&lt;/code&gt; on the server locally (accessing via file://) but wish to distribute the repository with a public http:// or svn:// URL in the metadata so users of it will see the public URL.</source>
          <target state="translated">这允许用户从备用URL创建存储库。例如，管理员可以在本地服务器上运行 &lt;code&gt;git svn&lt;/code&gt; （通过file：//访问），但希望在元数据中使用公共http：//或svn：// URL分发存储库，以便其用户可以看到公开网址。</target>
        </trans-unit>
        <trans-unit id="86c4c002dbb35b192dee2247feadc27722ad842a" translate="yes" xml:space="preserve">
          <source>This application is a CVS emulation layer for Git.</source>
          <target state="translated">这个应用是Git的CVS仿真层。</target>
        </trans-unit>
        <trans-unit id="8feea1468fa1fae814e84f89aca492fad30e5da4" translate="yes" xml:space="preserve">
          <source>This applies modifications from a hot-fix branch before each test run, e.g. in case your build or test environment changed so that older revisions may need a fix which newer ones have already. (Make sure the hot-fix branch is based off a commit which is contained in all revisions which you are bisecting, so that the merge does not pull in too much, or use &lt;code&gt;git cherry-pick&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt;.)</source>
          <target state="translated">这会在每次测试运行之前应用来自修补程序分支的修改，例如，如果您的构建或测试环境发生了更改，以便较旧的修订可能需要较新的修订已经具有的修复。（请确保热修复程序分支基于您要二等分的所有修订中包含的提交，以便合并不会引入过多内容，或者使用 &lt;code&gt;git cherry-pick&lt;/code&gt; 而不是 &lt;code&gt;git merge&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="889d1277201779cf18582f69129975a9bf60d357" translate="yes" xml:space="preserve">
          <source>This applies to files added to the source branch &lt;strong&gt;after&lt;/strong&gt; a daughter branch was created: if previously no commit was made on the daughter branch they will erroneously be added to the daughter branch in git.</source>
          <target state="translated">这适用于在创建子分支&lt;strong&gt;之后&lt;/strong&gt;添加到源分支的文件：如果以前未在子分支上进行任何提交，则它们将被错误地添加到git中的子分支中。</target>
        </trans-unit>
        <trans-unit id="cd519f993fc33ca56b2cb882b0ae5ba8b983012d" translate="yes" xml:space="preserve">
          <source>This argument will not be passed to &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;. Instead it sets the vhost field in the git:// service request (to rest of the argument). Default is not to send vhost in such request (if sent).</source>
          <target state="translated">此参数不会传递给 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 。而是在git：//服务请求中设置vhost字段（其余参数）。默认设置是不发送此类请求中的虚拟主机（如果已发送）。</target>
        </trans-unit>
        <trans-unit id="9535ee34f2074fa8e689413e0518f1d3faf71e7d" translate="yes" xml:space="preserve">
          <source>This argument will not be passed to &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;. Instead, it will cause the helper to start by sending git:// service requests to the remote side with the service field set to an appropriate value and the repository field set to rest of the argument. Default is not to send such a request.</source>
          <target state="translated">此参数不会传递给 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 。取而代之的是，它将通过将git：//服务请求发送到远程端来启动帮助程序，其中service字段设置为适当的值，repository字段设置为参数的其余部分。默认为不发送此类请求。</target>
        </trans-unit>
        <trans-unit id="b50cd8ffcdc46b4b68ae7776a2b00f1d1183b6dd" translate="yes" xml:space="preserve">
          <source>This asks for all the history reachable from the given commit but not from any branch, tag, or other reference. If you decide it&amp;rsquo;s something you want, you can always create a new reference to it, e.g.,</source>
          <target state="translated">这要求从给定的提交（而不是从任何分支，标记或其他引用）获得的所有历史记录。如果您决定要这样做，则可以随时为其创建新的引用，例如，</target>
        </trans-unit>
        <trans-unit id="7efa4dea1c9da210003e0c08e382eb543f66cbf7" translate="yes" xml:space="preserve">
          <source>This attribute controls the length of conflict markers left in the work tree file during a conflicted merge. Only setting to the value to a positive integer has any meaningful effect.</source>
          <target state="translated">此属性控制冲突合并时工作树文件中留下的冲突标记的长度。只有将该值设置为正整数才有意义。</target>
        </trans-unit>
        <trans-unit id="4caef1788f338fb02906a32b34bfb366a7539a3a" translate="yes" xml:space="preserve">
          <source>This attribute enables and controls end-of-line normalization. When a text file is normalized, its line endings are converted to LF in the repository. To control what line ending style is used in the working directory, use the &lt;code&gt;eol&lt;/code&gt; attribute for a single file and the &lt;code&gt;core.eol&lt;/code&gt; configuration variable for all text files. Note that setting &lt;code&gt;core.autocrlf&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;input&lt;/code&gt; overrides &lt;code&gt;core.eol&lt;/code&gt; (see the definitions of those options in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">此属性启用并控制行尾规范化。对文本文件进行规范化后，其行尾将在存储库中转换为LF。要控制工作目录中使用哪种行尾样式，请对单个文件使用 &lt;code&gt;eol&lt;/code&gt; 属性，对所有文本文件使用 &lt;code&gt;core.eol&lt;/code&gt; 配置变量。请注意，将 &lt;code&gt;core.autocrlf&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;input&lt;/code&gt; 会覆盖 &lt;code&gt;core.eol&lt;/code&gt; （请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;中这些选项的定义）。</target>
        </trans-unit>
        <trans-unit id="9abb1dada669f4b282e87943eaa4c10d9676f824" translate="yes" xml:space="preserve">
          <source>This attribute sets a specific line-ending style to be used in the working directory. It enables end-of-line conversion without any content checks, effectively setting the &lt;code&gt;text&lt;/code&gt; attribute. Note that setting this attribute on paths which are in the index with CRLF line endings may make the paths to be considered dirty. Adding the path to the index again will normalize the line endings in the index.</source>
          <target state="translated">此属性设置在工作目录中使用的特定行尾样式。它无需任何内容检查即可进行行尾转换，从而有效地设置了 &lt;code&gt;text&lt;/code&gt; 属性。请注意，在带有CRLF行尾的索引中的路径上设置此属性可能会使该路径被视为脏路径。再次将路径添加到索引将规范索引中的行尾。</target>
        </trans-unit>
        <trans-unit id="a95f413f93d421b5f0b609911f7201baca2aa2de" translate="yes" xml:space="preserve">
          <source>This automatically updates the rev_map if needed (see &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; in the FILES section below for details).</source>
          <target state="translated">如果需要，这会自动更新rev_map（有关详细信息，请参见下面&amp;ldquo; FILES&amp;rdquo;部分中的 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5ef9fc28040a2d8ac737cc9e8915d682487174d5" translate="yes" xml:space="preserve">
          <source>This avoids touching the disk, but removes the additional file. Your project may prefer to adopt a naming convention, such as all-lowercase names, to avoid this problem from occurring again; such a convention can be checked using a &lt;code&gt;pre-receive&lt;/code&gt; hook or as part of a continuous integration (CI) system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756e07e0622c048ffb322b306c002b3fe742a463" translate="yes" xml:space="preserve">
          <source>This behavior can be suppressed with the &lt;code&gt;--no-ff&lt;/code&gt; option.</source>
          <target state="translated">可以使用 &lt;code&gt;--no-ff&lt;/code&gt; 选项抑制此行为。</target>
        </trans-unit>
        <trans-unit id="8ad430bc747d1916521d538bf94c1847176c4231" translate="yes" xml:space="preserve">
          <source>This behavior is the default when the start point is a remote-tracking branch. Set the branch.autoSetupMerge configuration variable to &lt;code&gt;false&lt;/code&gt; if you want &lt;code&gt;git switch&lt;/code&gt;, &lt;code&gt;git checkout&lt;/code&gt; and &lt;code&gt;git branch&lt;/code&gt; to always behave as if &lt;code&gt;--no-track&lt;/code&gt; were given. Set it to &lt;code&gt;always&lt;/code&gt; if you want this behavior when the start-point is either a local or remote-tracking branch.</source>
          <target state="translated">当起点是远程跟踪分支时，此行为是默认行为。如果希望 &lt;code&gt;git switch&lt;/code&gt; ， &lt;code&gt;git checkout&lt;/code&gt; 和 &lt;code&gt;git branch&lt;/code&gt; 始终表现为 &lt;code&gt;--no-track&lt;/code&gt; ，则将branch.autoSetupMerge配置变量设置为 &lt;code&gt;false&lt;/code&gt; 。如果您希望在起始点是本地或远程跟踪分支时使用此行为，请将其设置为 &lt;code&gt;always&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a57c8928c46f18c8586890f640bdaceff3225ce7" translate="yes" xml:space="preserve">
          <source>This boolean config option controls whether some commands run &lt;code&gt;git maintenance run --auto&lt;/code&gt; after doing their normal work. Defaults to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d843a8479501e1f56c84b63bc83f8438d9dc3a" translate="yes" xml:space="preserve">
          <source>This boolean config option controls whether the maintenance task with name &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt; is run when no &lt;code&gt;--task&lt;/code&gt; option is specified to &lt;code&gt;git maintenance run&lt;/code&gt;. These config values are ignored if a &lt;code&gt;--task&lt;/code&gt; option exists. By default, only &lt;code&gt;maintenance.gc.enabled&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e589ab09a449c7cf7000e50f249deca2b148281c" translate="yes" xml:space="preserve">
          <source>This boolean will enable &lt;code&gt;fsync()&lt;/code&gt; when writing object files.</source>
          <target state="translated">写入目标文件时，此布尔值将启用 &lt;code&gt;fsync()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a9d8bb8cd3e4996e1654fca8257ad2030d24d70" translate="yes" xml:space="preserve">
          <source>This breakage is of course most of the time unrelated to the breakage we are trying to locate in the commit graph. But it prevents us to know if the interesting &quot;bad behavior&quot; is present or not.</source>
          <target state="translated">当然,这种破绽大多数时候与我们试图在提交图中定位的破绽无关。但它让我们无法知道是否存在有趣的 &quot;坏行为&quot;。</target>
        </trans-unit>
        <trans-unit id="1a7656b1b8b17aa91ea330f8fbedd0a75097faed" translate="yes" xml:space="preserve">
          <source>This bug has also been shown to affect non-symlink cases of replacing a directory with a file when it comes to the internal structures of the untracked cache, but no case has been reported where this resulted in wrong &quot;git status&quot; output.</source>
          <target state="translated">当涉及到未跟踪缓存的内部结构时,这个bug也被证明会影响到用文件替换目录的非全链接情况,但还没有报告说这会导致错误的 &quot;git状态 &quot;输出。</target>
        </trans-unit>
        <trans-unit id="bbb14e9c1a32bd1658d34b41d317e78fe3e2cf7e" translate="yes" xml:space="preserve">
          <source>This cache is meant to speed up commands that involve determining untracked files such as &lt;code&gt;git status&lt;/code&gt;.</source>
          <target state="translated">此缓存旨在加快涉及确定未跟踪文件（例如 &lt;code&gt;git status&lt;/code&gt; )的命令的速度。</target>
        </trans-unit>
        <trans-unit id="5e9291bab46bd7ea7a2a21b7e8d51146482ff7a6" translate="yes" xml:space="preserve">
          <source>This calculates the same as &lt;code&gt;--bisect&lt;/code&gt;, except that refs in &lt;code&gt;refs/bisect/&lt;/code&gt; are not used, and except that this outputs text ready to be eval&amp;rsquo;ed by the shell. These lines will assign the name of the midpoint revision to the variable &lt;code&gt;bisect_rev&lt;/code&gt;, and the expected number of commits to be tested after &lt;code&gt;bisect_rev&lt;/code&gt; is tested to &lt;code&gt;bisect_nr&lt;/code&gt;, the expected number of commits to be tested if &lt;code&gt;bisect_rev&lt;/code&gt; turns out to be good to &lt;code&gt;bisect_good&lt;/code&gt;, the expected number of commits to be tested if &lt;code&gt;bisect_rev&lt;/code&gt; turns out to be bad to &lt;code&gt;bisect_bad&lt;/code&gt;, and the number of commits we are bisecting right now to &lt;code&gt;bisect_all&lt;/code&gt;.</source>
          <target state="translated">此计算与 &lt;code&gt;--bisect&lt;/code&gt; 相同，除了不使用 &lt;code&gt;refs/bisect/&lt;/code&gt; 中的ref，并且输出的文本准备好由shell评估之外。这些生产线将分配中点修订的变量名 &lt;code&gt;bisect_rev&lt;/code&gt; ，并承诺的预期数量进行测试后 &lt;code&gt;bisect_rev&lt;/code&gt; 进行测试，以 &lt;code&gt;bisect_nr&lt;/code&gt; ，进行测试提交的预期数量，如果 &lt;code&gt;bisect_rev&lt;/code&gt; 原来是很好的 &lt;code&gt;bisect_good&lt;/code&gt; 时，如果 &lt;code&gt;bisect_rev&lt;/code&gt; 对 &lt;code&gt;bisect_bad&lt;/code&gt; 不好的话，测试的期望提交数，我们现在正划分为 &lt;code&gt;bisect_all&lt;/code&gt; 的提交数。</target>
        </trans-unit>
        <trans-unit id="7d3cf717b036e3b0e81df34e24d7ea082a035f6a" translate="yes" xml:space="preserve">
          <source>This can allow you to make partial mirrors when running fetch; but is generally not recommended because history will be skipped and lost.</source>
          <target state="translated">这可以让你在运行fetch时制作部分镜像,但一般不建议使用,因为历史记录会被跳过并丢失。</target>
        </trans-unit>
        <trans-unit id="636e119b451b3bd7ccaf26b7d43733789f26ed19" translate="yes" xml:space="preserve">
          <source>This can also be set up as the default behaviour by using the &lt;code&gt;worktree.guessRemote&lt;/code&gt; config option.</source>
          <target state="translated">也可以使用 &lt;code&gt;worktree.guessRemote&lt;/code&gt; 配置选项将其设置为默认行为。</target>
        </trans-unit>
        <trans-unit id="fa409f68e80081ea9a669e9f13a5d077543254ef" translate="yes" xml:space="preserve">
          <source>This can be &lt;code&gt;end&lt;/code&gt;, which is the default, &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt; or &lt;code&gt;before&lt;/code&gt;.</source>
          <target state="translated">可以是 &lt;code&gt;end&lt;/code&gt; ，这是默认值， &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;after&lt;/code&gt; 或 &lt;code&gt;before&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0de02388f102cf8ff32d10ea0ea1542e4435ae39" translate="yes" xml:space="preserve">
          <source>This can be any options that the archiver backend understands. See next section.</source>
          <target state="translated">这可以是归档器后台理解的任何选项。见下一节。</target>
        </trans-unit>
        <trans-unit id="8ebe928ea2c46867d2d30a22aa44b6d209b60b27" translate="yes" xml:space="preserve">
          <source>This can be combined with the gitweb configuration:</source>
          <target state="translated">可以结合gitweb配置。</target>
        </trans-unit>
        <trans-unit id="3e2aafd0fe68d162abd0214f2c4dbcf97a317242" translate="yes" xml:space="preserve">
          <source>This can be enabled by default with the configuration option mailinfo.scissors.</source>
          <target state="translated">这可以通过配置选项mailinfo.scissors默认启用。</target>
        </trans-unit>
        <trans-unit id="90b17ef61d05f77323fefc823815f1b4d0ca5c24" translate="yes" xml:space="preserve">
          <source>This can be set to a comma-separated list of strings. When a curl trace is enabled (see &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; above), whenever a &quot;Cookies:&quot; header sent by the client is dumped, values of cookies whose key is in that list (case-sensitive) are redacted.</source>
          <target state="translated">可以将其设置为逗号分隔的字符串列表。启用卷曲跟踪时（请参见上面的 &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; ），每当转储客户端发送的&amp;ldquo; Cookies：&amp;rdquo;标头时，都会删除其键在该列表中（区分大小写）的cookie的值。</target>
        </trans-unit>
        <trans-unit id="3d49143ca76086473ec42d2280fe45285788984b" translate="yes" xml:space="preserve">
          <source>This can be used to color the metadata of a blame line depending on age of the line.</source>
          <target state="translated">这可以用来根据线的年龄对责备线的元数据进行着色。</target>
        </trans-unit>
        <trans-unit id="0f9fdab39f98d82a2bdc74c13a484288c9af48d4" translate="yes" xml:space="preserve">
          <source>This can be used to convert arguments to a command run in a subdirectory so that they can still be used after moving to the top-level of the repository. For example:</source>
          <target state="translated">这可以用来转换在子目录中运行的命令的参数,以便在移动到版本库的顶层后仍然可以使用。例如</target>
        </trans-unit>
        <trans-unit id="7c4f04c6d6345aed6141f4d5502d056991a7840c" translate="yes" xml:space="preserve">
          <source>This can be used when you want to include further changes to the merge, or want to write your own merge commit message.</source>
          <target state="translated">当你想对合并进行进一步的修改,或者想写自己的合并提交信息时,可以使用这个功能。</target>
        </trans-unit>
        <trans-unit id="14d1ead4268c0c0f3315fceadadaf2f291770d82" translate="yes" xml:space="preserve">
          <source>This can be used with the &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt; commands.</source>
          <target state="translated">可以与 &lt;code&gt;dcommit&lt;/code&gt; ， &lt;code&gt;rebase&lt;/code&gt; ， &lt;code&gt;branch&lt;/code&gt; 和 &lt;code&gt;tag&lt;/code&gt; 命令一起使用。</target>
        </trans-unit>
        <trans-unit id="9067f207a93cdcf6d90b3183367a4ae6097c31d6" translate="yes" xml:space="preserve">
          <source>This can be useful when you want to publish the tree from a commit without exposing its full history. You might want to do this to publish an open source branch of a project whose current tree is &quot;clean&quot;, but whose full history contains proprietary or otherwise encumbered bits of code.</source>
          <target state="translated">当你想在不暴露完整历史的情况下发布提交的代码树时,这个方法可能很有用。你可能想用这个方法来发布一个项目的开源分支,该分支当前的代码树是 &quot;干净的&quot;,但其完整的历史记录中包含了专有的或有其他限制的代码。</target>
        </trans-unit>
        <trans-unit id="4ddcbb1d5b5e22f922e078b6b0d84fe1dcc0409b" translate="yes" xml:space="preserve">
          <source>This can happen, for example, if you:</source>
          <target state="translated">这可能发生,例如,如果你。</target>
        </trans-unit>
        <trans-unit id="9140f80526c6eb06ff98ed4abf5c0d2e07067266" translate="yes" xml:space="preserve">
          <source>This can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities and is considered generally safe and fast.</source>
          <target state="translated">这只能使用3路合并算法解决两个头(即当前分支和你拉来的另一个分支)。它试图仔细检测交叉合并的歧义,被认为是一般安全和快速的。</target>
        </trans-unit>
        <trans-unit id="10679b433b60fbaff0452d6d903b314fee5164d2" translate="yes" xml:space="preserve">
          <source>This can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this can detect and handle merges involving renames, but currently cannot make use of detected copies. This is the default merge strategy when pulling or merging one branch.</source>
          <target state="translated">这只能用3路合并算法解决两个头。当有一个以上的共同祖先可以用于3-way合并时,它会创建一个共同祖先的合并树,并将其作为3-way合并的参考树。通过对 Linux 2.6 内核开发历史中的实际合并提交进行测试,发现这样做可以减少合并冲突,而不会造成错误合并。此外,它还可以检测和处理涉及重命名的合并,但目前还不能使用检测到的副本。这是拉取或合并一个分支时的默认合并策略。</target>
        </trans-unit>
        <trans-unit id="2cac39aeb86961e1363f7613dfed0033661ab943" translate="yes" xml:space="preserve">
          <source>This can speed up operations like &lt;code&gt;git diff&lt;/code&gt; and &lt;code&gt;git status&lt;/code&gt; especially on filesystems like NFS that have weak caching semantics and thus relatively high IO latencies. When enabled, Git will do the index comparison to the filesystem data in parallel, allowing overlapping IO&amp;rsquo;s. Defaults to true.</source>
          <target state="translated">这可以加快诸如 &lt;code&gt;git diff&lt;/code&gt; 和 &lt;code&gt;git status&lt;/code&gt; 之类的操作,尤其是在诸如NFS之类的文件系统上，这些系统具有较弱的缓存语义，因此具有相对较高的IO延迟。启用后，Git将并行对文件系统数据进行索引比较，从而允许重叠的IO。默认为true。</target>
        </trans-unit>
        <trans-unit id="9202266152fd1a0a2194149286bebd74fe30a95c" translate="yes" xml:space="preserve">
          <source>This capability can be advertised multiple times. The first applicable refspec takes precedence. The left-hand of refspecs advertised with this capability must cover all refs reported by the list command. If no &lt;code&gt;refspec&lt;/code&gt; capability is advertised, there is an implied &lt;code&gt;refspec *:*&lt;/code&gt;.</source>
          <target state="translated">此功能可以多次发布。第一个适用的refspec优先。用此功能发布的参考规范的左侧必须覆盖list命令报告的所有参考。如果没有发布 &lt;code&gt;refspec&lt;/code&gt; 功能，则暗示一个 &lt;code&gt;refspec *:*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="561397ab0857a5bada65e17ac4aabd661a6939b5" translate="yes" xml:space="preserve">
          <source>This chapter covers internal details of the Git implementation which probably only Git developers need to understand.</source>
          <target state="translated">本章涉及Git实现的内部细节,可能只有Git开发者才需要了解。</target>
        </trans-unit>
        <trans-unit id="9301665301f3e50c4417122a8411be226ea5b235" translate="yes" xml:space="preserve">
          <source>This command always gets all objects. Historically, there were three options &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-t&lt;/code&gt; for choosing which objects to download. They are now silently ignored.</source>
          <target state="translated">此命令始终获取所有对象。从历史上看，有三个选项 &lt;code&gt;-a&lt;/code&gt; ， &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;-t&lt;/code&gt; 用于选择要下载的对象。现在，它们被静默忽略。</target>
        </trans-unit>
        <trans-unit id="5b8a59dc9ca3a3d6f247d36df5fb54708fa69494" translate="yes" xml:space="preserve">
          <source>This command applies the patch but does not create a commit. Use &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; to create commits from patches generated by &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; and/or received by email.</source>
          <target state="translated">该命令应用补丁，但不创建提交。使用&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;从&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]生成&lt;/a&gt;和/或通过电子邮件收到的补丁中创建提交。</target>
        </trans-unit>
        <trans-unit id="1f849e1e7df08a5bb28860e4715d22e12f5d5d20" translate="yes" xml:space="preserve">
          <source>This command assists the developer in this process by recording conflicted automerge results and corresponding hand resolve results on the initial manual merge, and applying previously recorded hand resolutions to their corresponding automerge results.</source>
          <target state="translated">该命令协助开发人员在此过程中,在初始人工合并时记录冲突的自动合并结果和相应的手工解决结果,并将之前记录的手工解决结果应用到相应的自动合并结果中。</target>
        </trans-unit>
        <trans-unit id="b823d02fd766a4ae4b81090ce369454e7da568d6" translate="yes" xml:space="preserve">
          <source>This command caches credentials in memory for use by future Git programs. The stored credentials never touch the disk, and are forgotten after a configurable timeout. The cache is accessible over a Unix domain socket, restricted to the current user by filesystem permissions.</source>
          <target state="translated">这条命令会将凭证缓存在内存中,供未来的 Git 程序使用。存储的凭证永远不会接触磁盘,并在可配置的超时后被遗忘。缓存可以通过 Unix 域套接字访问,根据文件系统的权限限制当前用户使用。</target>
        </trans-unit>
        <trans-unit id="4784337d21599fe7fcfddcd79392d8470207170e" translate="yes" xml:space="preserve">
          <source>This command can be performed multiple times before a commit. It only adds the content of the specified file(s) at the time the add command is run; if you want subsequent changes included in the next commit, then you must run &lt;code&gt;git add&lt;/code&gt; again to add the new content to the index.</source>
          <target state="translated">提交前可以多次执行此命令。它仅在运行add命令时添加指定文件的内容；如果要在下一次提交中包含后续更改，则必须再次运行 &lt;code&gt;git add&lt;/code&gt; ，以将新内容添加到索引中。</target>
        </trans-unit>
        <trans-unit id="c286ab165ab2a31532b621372beb627366820ec4" translate="yes" xml:space="preserve">
          <source>This command can be used where a &lt;code&gt;filemodify&lt;/code&gt; directive can appear, allowing it to be used in the middle of a commit. For a &lt;code&gt;filemodify&lt;/code&gt; using an inline directive, it can also appear right before the &lt;code&gt;data&lt;/code&gt; directive.</source>
          <target state="translated">该命令可以在出现 &lt;code&gt;filemodify&lt;/code&gt; 指令的地方使用，从而可以在提交过程中使用它。对于使用内联指令的 &lt;code&gt;filemodify&lt;/code&gt; ，它也可以出现在 &lt;code&gt;data&lt;/code&gt; 指令之前。</target>
        </trans-unit>
        <trans-unit id="74e4352fd2289d447be4133ac0e6d68d162428a6" translate="yes" xml:space="preserve">
          <source>This command can run &lt;code&gt;applypatch-msg&lt;/code&gt;, &lt;code&gt;pre-applypatch&lt;/code&gt;, and &lt;code&gt;post-applypatch&lt;/code&gt; hooks. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">此命令可以运行 &lt;code&gt;applypatch-msg&lt;/code&gt; ， &lt;code&gt;pre-applypatch&lt;/code&gt; 和 &lt;code&gt;post-applypatch&lt;/code&gt; 挂钩。有关更多信息，请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e5610ce87e5d01d8f8246892b4f05f886b6ad5a" translate="yes" xml:space="preserve">
          <source>This command can run &lt;code&gt;commit-msg&lt;/code&gt;, &lt;code&gt;prepare-commit-msg&lt;/code&gt;, &lt;code&gt;pre-commit&lt;/code&gt;, &lt;code&gt;post-commit&lt;/code&gt; and &lt;code&gt;post-rewrite&lt;/code&gt; hooks. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">该命令可以运行 &lt;code&gt;commit-msg&lt;/code&gt; ， &lt;code&gt;prepare-commit-msg&lt;/code&gt; ， &lt;code&gt;pre-commit&lt;/code&gt; ， &lt;code&gt;post-commit&lt;/code&gt; 和 &lt;code&gt;post-rewrite&lt;/code&gt; 挂钩。有关更多信息，请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ba8d48bf258fdf0b61e4a3a7667022fd45b3e45" translate="yes" xml:space="preserve">
          <source>This command creates an empty Git repository - basically a &lt;code&gt;.git&lt;/code&gt; directory with subdirectories for &lt;code&gt;objects&lt;/code&gt;, &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, and template files. An initial &lt;code&gt;HEAD&lt;/code&gt; file that references the HEAD of the master branch is also created.</source>
          <target state="translated">此命令创建一个空的Git存储库-基本上是一个 &lt;code&gt;.git&lt;/code&gt; 目录，其中包含 &lt;code&gt;objects&lt;/code&gt; ， &lt;code&gt;refs/heads&lt;/code&gt; ， &lt;code&gt;refs/tags&lt;/code&gt; 和模板文件的子目录。还创建了引用master分支的HEAD 的初始 &lt;code&gt;HEAD&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="283a3a39e231f6367045f912a15047dc4264c5e0" translate="yes" xml:space="preserve">
          <source>This command creates an empty Git repository - basically a &lt;code&gt;.git&lt;/code&gt; directory with subdirectories for &lt;code&gt;objects&lt;/code&gt;, &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, and template files. An initial branch without any commits will be created (see the &lt;code&gt;--initial-branch&lt;/code&gt; option below for its name).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52be87adec196973421cd7319ee0f98c1860983" translate="yes" xml:space="preserve">
          <source>This command degenerates to download everything to complete the asked refs from the remote side when the local side does not have a common ancestor commit.</source>
          <target state="translated">当本地端没有共同的祖先提交时,这个命令会退化到从远程端下载一切完成要求的refs。</target>
        </trans-unit>
        <trans-unit id="194b70091800ec19021441e8c1778ca9e02b53d5" translate="yes" xml:space="preserve">
          <source>This command ensures that the changes in the experimental branch are already in the current branch.</source>
          <target state="translated">该命令确保实验分支中的变化已经在当前分支中。</target>
        </trans-unit>
        <trans-unit id="1b788d383418fe8b134f7630991a2d6359c7dd7c" translate="yes" xml:space="preserve">
          <source>This command finds new changes in p4 and imports them as Git commits.</source>
          <target state="translated">这条命令可以找到 p4 中的新变化,并将其作为 Git 提交导入。</target>
        </trans-unit>
        <trans-unit id="4b11fc8efec3bd343a83e9f1aa4620a514b9ab8e" translate="yes" xml:space="preserve">
          <source>This command formats the lines of its standard input into a table with multiple columns. Each input line occupies one cell of the table. It is used internally by other git commands to format output into columns.</source>
          <target state="translated">该命令将其标准输入行格式化为一个多列的表格。每一行输入都占据了表格的一个单元格。它在内部被其他 git 命令用来将输出格式化为列。</target>
        </trans-unit>
        <trans-unit id="ade7fdc971ed1f0936fb8fbff7bb1574367ca37b" translate="yes" xml:space="preserve">
          <source>This command is extremely useful if the frontend does not know (or does not care to know) what files are currently on the branch, and therefore cannot generate the proper &lt;code&gt;filedelete&lt;/code&gt; commands to update the content.</source>
          <target state="translated">如果前端不知道（或不希望知道）分支上当前有哪些文件，因此无法生成正确的 &lt;code&gt;filedelete&lt;/code&gt; 命令来更新内容，则此命令非常有用。</target>
        </trans-unit>
        <trans-unit id="5f45dc9e63088b4d8e620891decbfdd6655de376" translate="yes" xml:space="preserve">
          <source>This command is intended mostly for internal use by scripts automatically invoking &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">该命令主要用于自动调用 &lt;code&gt;git merge&lt;/code&gt; 的脚本内部使用。</target>
        </trans-unit>
        <trans-unit id="3710225b15829bc8cbeb92895b81ff709286e645" translate="yes" xml:space="preserve">
          <source>This command is recursive by default.</source>
          <target state="translated">该命令默认是递归的。</target>
        </trans-unit>
        <trans-unit id="6e8668d616c8790cb8d71e8720597de54ced7850" translate="yes" xml:space="preserve">
          <source>This command is used to combine all objects that do not currently reside in a &quot;pack&quot;, into a pack. It can also be used to re-organize existing packs into a single, more efficient pack.</source>
          <target state="translated">这条命令用于将当前不在一个 &quot;包 &quot;中的所有对象合并成一个包。它也可以用来将现有的包重新组织成一个更有效的包。</target>
        </trans-unit>
        <trans-unit id="e7cbc44be580e3c1734536d3564c4b9dc7e501fa" translate="yes" xml:space="preserve">
          <source>This command is used to solve the storage and performance problem by storing the refs in a single file, &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt;. When a ref is missing from the traditional &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory hierarchy, it is looked up in this file and used if found.</source>
          <target state="translated">此命令用于通过将引用存储在单个文件 &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; 来解决存储和性能问题。当传统的 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 目录层次结构中缺少引用时，将在此文件中查找该引用并在找到后使用。</target>
        </trans-unit>
        <trans-unit id="43f707239bbecf8d6bf96bbdb4b367abb8fd5357" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git archive&lt;/code&gt; side, and the program pair is meant to be used to get an archive from a remote repository.</source>
          <target state="translated">最终用户通常不会直接调用此命令。协议的UI位于 &lt;code&gt;git archive&lt;/code&gt; 端，该程序对用于从远程存储库获取归档。</target>
        </trans-unit>
        <trans-unit id="17d67b43408b7b4804e33e1e3b79dc1fbf03af1b" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git fetch-pack&lt;/code&gt; side, and the program pair is meant to be used to pull updates from a remote repository. For push operations, see &lt;code&gt;git send-pack&lt;/code&gt;.</source>
          <target state="translated">最终用户通常不会直接调用此命令。协议的UI位于 &lt;code&gt;git fetch-pack&lt;/code&gt; 一侧，该程序对用于从远程存储库中提取更新。有关推送操作，请参见 &lt;code&gt;git send-pack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36ac8b84f92c3cf141e5ae101adcc45178aae4c7" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git send-pack&lt;/code&gt; side, and the program pair is meant to be used to push updates to remote repository. For pull operations, see &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt;.</source>
          <target state="translated">最终用户通常不会直接调用此命令。协议的UI位于 &lt;code&gt;git send-pack&lt;/code&gt; 一侧，该程序对用于将更新推送到远程存储库。有关拉操作，请参见&lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8cac5b996748b602d2e8f0cf9273cee3d1c4d80" translate="yes" xml:space="preserve">
          <source>This command lets you check that intermediate commits are compilable. The todo list becomes like that:</source>
          <target state="translated">这个命令让你检查中间提交是否可以编译。待办事项列表就会变成这样。</target>
        </trans-unit>
        <trans-unit id="56bca57be11add071b8aeae38f6a28f443105856" translate="yes" xml:space="preserve">
          <source>This command manages the information recorded in the reflogs.</source>
          <target state="translated">该命令管理重新记录的信息。</target>
        </trans-unit>
        <trans-unit id="7c7ebb85111dd101dc1c2782f6e5cbc235a39c44" translate="yes" xml:space="preserve">
          <source>This command provides a way to interact with p4 repositories using Git.</source>
          <target state="translated">该命令提供了一种使用 Git 与 p4 仓库进行交互的方法。</target>
        </trans-unit>
        <trans-unit id="637c92f99feb8b30861eeaee2e3273c64a9b5351" translate="yes" xml:space="preserve">
          <source>This command reads some patches or commit messages from either the &amp;lt;file&amp;gt; arguments or the standard input if no &amp;lt;file&amp;gt; is specified. If &lt;code&gt;--parse&lt;/code&gt; is specified, the output consists of the parsed trailers.</source>
          <target state="translated">如果未指定&amp;lt;file&amp;gt;，则此命令从&amp;lt;file&amp;gt;参数或标准输入读取某些补丁或提交消息。如果指定了 &lt;code&gt;--parse&lt;/code&gt; ，则输出由已解析的预告片组成。</target>
        </trans-unit>
        <trans-unit id="a38646d64359b52991af1358c674765acf2c0c11" translate="yes" xml:space="preserve">
          <source>This command should not list any commits. Otherwise, check out &lt;code&gt;master&lt;/code&gt; and merge &lt;code&gt;maint&lt;/code&gt; into it.</source>
          <target state="translated">该命令不应列出任何提交。否则，请检出 &lt;code&gt;master&lt;/code&gt; 并将 &lt;code&gt;maint&lt;/code&gt; 合并到其中。</target>
        </trans-unit>
        <trans-unit id="6a853b09f1818b9d32f936bd42aa8a84af13b068" translate="yes" xml:space="preserve">
          <source>This command shows the differences between two versions of a patch series, or more generally, two commit ranges (ignoring merge commits).</source>
          <target state="translated">这条命令显示了一个补丁系列的两个版本之间的差异,或者更一般地说,两个提交范围之间的差异(忽略合并提交)。</target>
        </trans-unit>
        <trans-unit id="852903a68075d19a47d4520af94edde77996207f" translate="yes" xml:space="preserve">
          <source>This command stores credentials indefinitely on disk for use by future Git programs.</source>
          <target state="translated">这条命令会将凭证无限期地存储在磁盘上,供以后的 Git 程序使用。</target>
        </trans-unit>
        <trans-unit id="d143bf10d727fe2f5d0639ed85e199dd448d8bd2" translate="yes" xml:space="preserve">
          <source>This command updates the index using the current content found in the working tree, to prepare the content staged for the next commit. It typically adds the current content of existing paths as a whole, but with some options it can also be used to add content with only part of the changes made to the working tree files applied, or remove paths that do not exist in the working tree anymore.</source>
          <target state="translated">这条命令使用工作树中的当前内容更新索引,为下一次提交准备分期的内容。它通常会将现有路径的内容作为一个整体来添加,但通过一些选项,它也可以用来添加只应用了工作树文件的部分更改的内容,或者删除工作树中已经不存在的路径。</target>
        </trans-unit>
        <trans-unit id="61eacd31ecbd262bdcbed11d9c6103318919d1be" translate="yes" xml:space="preserve">
          <source>This command uploads a mailbox generated with &lt;code&gt;git format-patch&lt;/code&gt; into an IMAP drafts folder. This allows patches to be sent as other email is when using mail clients that cannot read mailbox files directly. The command also works with any general mailbox in which emails have the fields &quot;From&quot;, &quot;Date&quot;, and &quot;Subject&quot; in that order.</source>
          <target state="translated">此命令将使用 &lt;code&gt;git format-patch&lt;/code&gt; 生成的邮箱上载到 IMAP草稿文件夹。使用无法直接读取邮箱文件的邮件客户端时，这可以像发送其他电子邮件一样发送补丁程序。该命令还可以与任何常规邮箱一起使用，在该邮箱中，电子邮件的顺序为&amp;ldquo;发件人&amp;rdquo;，&amp;ldquo;日期&amp;rdquo;和&amp;ldquo;主题&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a3bcbdfcf8f3a072ac23f24cf310648f9691fb70" translate="yes" xml:space="preserve">
          <source>This command uses a binary search algorithm to find which commit in your project&amp;rsquo;s history introduced a bug. You use it by first telling it a &quot;bad&quot; commit that is known to contain the bug, and a &quot;good&quot; commit that is known to be before the bug was introduced. Then &lt;code&gt;git
bisect&lt;/code&gt; picks a commit between those two endpoints and asks you whether the selected commit is &quot;good&quot; or &quot;bad&quot;. It continues narrowing down the range until it finds the exact commit that introduced the change.</source>
          <target state="translated">此命令使用二进制搜索算法来查找项目历史记录中的哪个提交引入了错误。通过首先告诉它包含臭虫的&amp;ldquo;坏&amp;rdquo;提交和引入臭虫之前的&amp;ldquo;好&amp;rdquo;提交来使用它。然后 &lt;code&gt;git bisect&lt;/code&gt; 在这两个端点之间选择一个提交，并询问您所选择的提交是&amp;ldquo;好&amp;rdquo;还是&amp;ldquo;坏&amp;rdquo;。它继续缩小范围，直到找到引入更改的确切提交为止。</target>
        </trans-unit>
        <trans-unit id="097f8af4b6f26b418927a5ca4b24d71746b1f843" translate="yes" xml:space="preserve">
          <source>This command uses the &lt;code&gt;diff.color.*&lt;/code&gt; and &lt;code&gt;pager.range-diff&lt;/code&gt; settings (the latter is on by default). See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">此命令使用 &lt;code&gt;diff.color.*&lt;/code&gt; 和 &lt;code&gt;pager.range-diff&lt;/code&gt; 设置（默认情况下启用）。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03bab6a03561ee7ff2e9bf92505bcdd5322bfb51" translate="yes" xml:space="preserve">
          <source>This command will fail with non-zero status upon error. Some exit codes are:</source>
          <target state="translated">该命令在出错时将以非零状态失败。一些退出代码是:</target>
        </trans-unit>
        <trans-unit id="7ed6af6e5518c122d94f4b8fea824fc7938bd5aa" translate="yes" xml:space="preserve">
          <source>This command will fetch changes from the remote branches to your remote-tracking branches &lt;code&gt;origin/*&lt;/code&gt;, and merge the default branch into the current branch.</source>
          <target state="translated">此命令将从远程分支获取更改到远程跟踪分支 &lt;code&gt;origin/*&lt;/code&gt; ，并将默认分支合并到当前分支。</target>
        </trans-unit>
        <trans-unit id="99c24081605f25434a1fa0a51df82045bf4b7763" translate="yes" xml:space="preserve">
          <source>This command will save your changes away to the &lt;code&gt;stash&lt;/code&gt;, and reset your working tree and the index to match the tip of your current branch. Then you can make your fix as usual.</source>
          <target state="translated">此命令会将您的更改保存到 &lt;code&gt;stash&lt;/code&gt; ，并重置工作树和索引以匹配当前分支的尖端。然后，您可以照常进行修复。</target>
        </trans-unit>
        <trans-unit id="cb41b9bb98cbe715b8d6c0b50eb0b52309cdc91a" translate="yes" xml:space="preserve">
          <source>This commit will get blown away so a throw-away log message is OK.</source>
          <target state="translated">这个提交会被炸掉,所以扔掉的日志信息是可以的。</target>
        </trans-unit>
        <trans-unit id="068d7057b3017084327709c3e61c2e224fb2a5f6" translate="yes" xml:space="preserve">
          <source>This commits all other changes in the index.</source>
          <target state="translated">这将提交索引中的所有其他更改。</target>
        </trans-unit>
        <trans-unit id="1d649ab8ff53024e7549864469811ccee0abf2e7" translate="yes" xml:space="preserve">
          <source>This commits your first edits in &lt;code&gt;branch1&lt;/code&gt;.</source>
          <target state="translated">这将在 &lt;code&gt;branch1&lt;/code&gt; 中提交您的第一次编辑。</target>
        </trans-unit>
        <trans-unit id="8bc13c84a009ea0d6abb173ac6100dc00ae7606a" translate="yes" xml:space="preserve">
          <source>This compares stage 2 (our branch), stage 3 (their branch) and the working tree file and outputs a combined diff, similar to the way &lt;code&gt;diff-tree&lt;/code&gt; shows a merge commit with these flags.</source>
          <target state="translated">这将比较阶段2（我们的分支），阶段3（他们的分支）和工作树文件，并输出组合的diff，类似于 &lt;code&gt;diff-tree&lt;/code&gt; 显示带有这些标志的合并提交的方式。</target>
        </trans-unit>
        <trans-unit id="d3fe164a17e549b712f12743eb90dc676fb8455c" translate="yes" xml:space="preserve">
          <source>This computation involves traversing all the reachable objects, i.e. it has the same cost as &lt;code&gt;git prune&lt;/code&gt;. It is primarily intended to fix corruption caused by garbage collecting using older versions of Git, which didn&amp;rsquo;t protect objects referred to by reflogs.</source>
          <target state="translated">该计算涉及遍历所有可到达的对象，即，其成本与 &lt;code&gt;git prune&lt;/code&gt; 相同。它的主要目的是修复使用较旧版本的Git进行垃圾收集所导致的损坏，该版本未保护reflog引用的对象。</target>
        </trans-unit>
        <trans-unit id="241f3360b1ffda93090a6212a837542c91b1e09e" translate="yes" xml:space="preserve">
          <source>This config option controls whether or not the given &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt; runs during a &lt;code&gt;git maintenance run --schedule=&amp;lt;frequency&amp;gt;&lt;/code&gt; command. The value must be one of &quot;hourly&quot;, &quot;daily&quot;, or &quot;weekly&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e7c3905269f2318ce8a27a07b91b053d9dd7129" translate="yes" xml:space="preserve">
          <source>This configuration can be specified multiple times in order to allow multiple notes refs to be included. In that case, it will behave similarly to multiple &lt;code&gt;--[no-]notes[=]&lt;/code&gt; options passed in. That is, a value of &lt;code&gt;true&lt;/code&gt; will show the default notes, a value of &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; will also show notes from that notes ref and a value of &lt;code&gt;false&lt;/code&gt; will negate previous configurations and not show notes.</source>
          <target state="translated">可以多次指定此配置，以允许包含多个注释引用。在这种情况下，它的行为类似于传入的多个 &lt;code&gt;--[no-]notes[=]&lt;/code&gt; 选项。即，值为 &lt;code&gt;true&lt;/code&gt; 将显示默认注释，值为 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 还将显示该注释中的注释ref和 &lt;code&gt;false&lt;/code&gt; 值将否定以前的配置，并且不显示注释。</target>
        </trans-unit>
        <trans-unit id="0675827ca8d724102e17a053585b958058551f3d" translate="yes" xml:space="preserve">
          <source>This configuration doesn&amp;rsquo;t have any effect on authenticating to remote services; for that, see &lt;code&gt;credential.username&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6aa4372bde5e931f9e4e006e5a3cd0aea5ccf17" translate="yes" xml:space="preserve">
          <source>This configuration is used in two ways:</source>
          <target state="translated">这种配置有两种使用方式。</target>
        </trans-unit>
        <trans-unit id="06f31556dacb48424e7a1be662dd26364f785ce9" translate="yes" xml:space="preserve">
          <source>This configuration variable is useful in cases where you&amp;rsquo;d like to centrally configure your Git hooks instead of configuring them on a per-repository basis, or as a more flexible and centralized alternative to having an &lt;code&gt;init.templateDir&lt;/code&gt; where you&amp;rsquo;ve changed default hooks.</source>
          <target state="translated">此配置变量在您希望集中配置Git挂钩而不是基于每个存储库进行配置的情况下非常有用，或者作为在更改了默认挂钩之后使用 &lt;code&gt;init.templateDir&lt;/code&gt; 的更灵活，更集中的替代方法。</target>
        </trans-unit>
        <trans-unit id="eed4a11499740f4bb5f61d3ce7354c5409f33bf3" translate="yes" xml:space="preserve">
          <source>This configures how whitespace is ignored when performing the move detection for &lt;code&gt;--color-moved&lt;/code&gt;. It can be set by the &lt;code&gt;diff.colorMovedWS&lt;/code&gt; configuration setting. These modes can be given as a comma separated list:</source>
          <target state="translated">这配置了对 &lt;code&gt;--color-moved&lt;/code&gt; 执行移动检测时如何忽略空格。可以通过 &lt;code&gt;diff.colorMovedWS&lt;/code&gt; 配置设置进行设置。这些模式可以以逗号分隔的列表形式给出：</target>
        </trans-unit>
        <trans-unit id="9b4ea1fd788cef298d939e77017eddec04b80461" translate="yes" xml:space="preserve">
          <source>This configures how whitespace is ignored when performing the move detection for &lt;code&gt;--color-moved&lt;/code&gt;. These modes can be given as a comma separated list:</source>
          <target state="translated">这配置了对 &lt;code&gt;--color-moved&lt;/code&gt; 执行移动检测时如何忽略空格。这些模式可以以逗号分隔的列表形式给出：</target>
        </trans-unit>
        <trans-unit id="77030a3f3e0bddf7aada34bc0939552bc0993e3c" translate="yes" xml:space="preserve">
          <source>This counts the number of unpacked object files and disk space consumed by them, to help you decide when it is a good time to repack.</source>
          <target state="translated">这将统计未打包的对象文件的数量和它们所消耗的磁盘空间,以帮助你决定何时是重新打包的好时机。</target>
        </trans-unit>
        <trans-unit id="3e67b0f2a3d6f811dcdec6a80edd2cc8d01b0b6b" translate="yes" xml:space="preserve">
          <source>This creates a &quot;lightweight&quot; tag. If you would also like to include a comment with the tag, and possibly sign it cryptographically, then you should create a tag object instead; see the &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; man page for details.</source>
          <target state="translated">这将创建一个&amp;ldquo;轻量级&amp;rdquo;标签。如果您还希望在标签中包含注释，并可能对其进行加密签名，则应该创建一个标签对象；有关详细信息，请参见&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;手册页。</target>
        </trans-unit>
        <trans-unit id="687e61032de29ec5a828bf99d3854a432acd2a82" translate="yes" xml:space="preserve">
          <source>This creates a new directory &quot;myrepo&quot; containing a clone of Alice&amp;rsquo;s repository. The clone is on an equal footing with the original project, possessing its own copy of the original project&amp;rsquo;s history.</source>
          <target state="translated">这将创建一个新目录&amp;ldquo; myrepo&amp;rdquo;，其中包含Alice存储库的克隆。该克隆副本与原始项目处于平等地位，拥有自己的原始项目历史副本。</target>
        </trans-unit>
        <trans-unit id="c2fd84fc2fa04021fed2cadb8707ca64b05a22fb" translate="yes" xml:space="preserve">
          <source>This creates a single &quot;pack file&quot; in .git/objects/pack/ containing all currently unpacked objects. You can then run</source>
          <target state="translated">这将在 .git/objects/pack/中创建一个单一的 &quot;pack文件&quot;,其中包含所有当前未打包的对象。然后您可以运行</target>
        </trans-unit>
        <trans-unit id="bf43931e74b20a3da5197ed923f890fe71d72016" translate="yes" xml:space="preserve">
          <source>This default configuration is achieved by creating references to the remote branch heads under &lt;code&gt;refs/remotes/origin&lt;/code&gt; and by initializing &lt;code&gt;remote.origin.url&lt;/code&gt; and &lt;code&gt;remote.origin.fetch&lt;/code&gt; configuration variables.</source>
          <target state="translated">通过在 &lt;code&gt;refs/remotes/origin&lt;/code&gt; 下创建对远程分支头的引用并初始化 &lt;code&gt;remote.origin.url&lt;/code&gt; 和 &lt;code&gt;remote.origin.fetch&lt;/code&gt; 配置变量来实现此默认配置。</target>
        </trans-unit>
        <trans-unit id="984768ad68337dfe2b0015e657c9f4f069afabc8" translate="yes" xml:space="preserve">
          <source>This defines two submodules, &lt;code&gt;libfoo&lt;/code&gt; and &lt;code&gt;libbar&lt;/code&gt;. These are expected to be checked out in the paths &lt;code&gt;include/foo&lt;/code&gt; and &lt;code&gt;include/bar&lt;/code&gt;, and for both submodules a URL is specified which can be used for cloning the submodules.</source>
          <target state="translated">这定义了两个子模块 &lt;code&gt;libfoo&lt;/code&gt; 和 &lt;code&gt;libbar&lt;/code&gt; 。可以在 &lt;code&gt;include/foo&lt;/code&gt; 和 &lt;code&gt;include/bar&lt;/code&gt; 路径中检出它们，并且为两个子模块都指定一个URL，该URL可用于克隆子模块。</target>
        </trans-unit>
        <trans-unit id="57db5304522b1070a0df1071ce5df5d38ea7d002" translate="yes" xml:space="preserve">
          <source>This describes how Tony Luck uses Git in his role as maintainer of the IA64 architecture for the Linux kernel.</source>
          <target state="translated">本文介绍了Tony Luck作为Linux内核IA64架构的维护者如何使用Git。</target>
        </trans-unit>
        <trans-unit id="c9e275f2996b22cd4415c594fae8f08a0dfe70e8" translate="yes" xml:space="preserve">
          <source>This determines the coloring scheme to be applied to blame output. It can be &lt;code&gt;repeatedLines&lt;/code&gt;, &lt;code&gt;highlightRecent&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt; which is the default.</source>
          <target state="translated">这确定了要应用于责备输出的着色方案。它可以是 &lt;code&gt;repeatedLines&lt;/code&gt; ， &lt;code&gt;highlightRecent&lt;/code&gt; 或默认的 &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56ee29b22f07db9306c3380b74b5b0180828e415" translate="yes" xml:space="preserve">
          <source>This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/objects&quot; will be used instead.</source>
          <target state="translated">如果设置了 $GIT_COMMON_DIR,这个目录就会被忽略,取而代之的是 &quot;$GIT_COMMON_DIR/objects&quot;。</target>
        </trans-unit>
        <trans-unit id="2072b137cd96280de0e098678b51f23a76dcd0dc" translate="yes" xml:space="preserve">
          <source>This disables potentially expensive checks to workaround broken symlinks checked into SVN by broken clients. Set this option to &quot;false&quot; if you track a SVN repository with many empty blobs that are not symlinks. This option may be changed while &lt;code&gt;git svn&lt;/code&gt; is running and take effect on the next revision fetched. If unset, &lt;code&gt;git svn&lt;/code&gt; assumes this option to be &quot;true&quot;.</source>
          <target state="translated">这会禁用潜在的昂贵检查，以解决由损坏的客户端签入SVN的损坏的符号链接。如果您跟踪带有许多不是符号链接的空blob的SVN存储库，请将此选项设置为&amp;ldquo; false&amp;rdquo;。 &lt;code&gt;git svn&lt;/code&gt; 运行时可以更改此选项，并在获取的下一个修订版本上生效。如果未设置，则 &lt;code&gt;git svn&lt;/code&gt; 假定此选项为&amp;ldquo; true&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="006e62625e60aabc7f31fa591f6f9b4a3bd2a878" translate="yes" xml:space="preserve">
          <source>This document attempts to write down and motivate some of the workflow elements used for &lt;code&gt;git.git&lt;/code&gt; itself. Many ideas apply in general, though the full workflow is rarely required for smaller projects with fewer people involved.</source>
          <target state="translated">本文档试图写下并激励一些用于 &lt;code&gt;git.git&lt;/code&gt; 本身的工作流元素。通常有许多想法适用，尽管对于涉及较少人员的小型项目，很少需要完整的工作流程。</target>
        </trans-unit>
        <trans-unit id="8cd9193645885514540ac19f3167f508bebca422" translate="yes" xml:space="preserve">
          <source>This document presents a specification for a version 2 of Git&amp;rsquo;s wire protocol. Protocol v2 will improve upon v1 in the following ways:</source>
          <target state="translated">本文档介绍了Git有线协议版本2的规范。协议v2将在以下方面对v1进行改进：</target>
        </trans-unit>
        <trans-unit id="46bd1a26c48d1772be26d3d869cc4b6544004ea1" translate="yes" xml:space="preserve">
          <source>This document shows the &quot;raw&quot; syntax as seen by git. The shell and other UIs might require additional quoting to protect special characters and to avoid word splitting.</source>
          <target state="translated">本文档展示了 git 所看到的 &quot;原始 &quot;语法,shell 和其他用户界面可能需要额外的引号来保护特殊字符,并避免拆字。在shell和其他用户接口中,可能需要额外的引号来保护特殊字符,并避免词的分割。</target>
        </trans-unit>
        <trans-unit id="a76f8971dde9f8810b677765aca0d70490d9f8fa" translate="yes" xml:space="preserve">
          <source>This document will serve as the master list for extensions. Any implementation wishing to define a new extension should make a note of it here, in order to claim the name.</source>
          <target state="translated">本文件将作为扩展名的主列表。任何希望定义新扩展的实现都应在此注明,以便使用该名称。</target>
        </trans-unit>
        <trans-unit id="d24a591988945bec7d040b25bd5a37c73014bcf3" translate="yes" xml:space="preserve">
          <source>This does not affect &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; or the &lt;code&gt;git-diff-*&lt;/code&gt; plumbing commands. Can be overridden on the command line with the &lt;code&gt;--color[=&amp;lt;when&amp;gt;]&lt;/code&gt; option.</source>
          <target state="translated">这不会影响&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;或 &lt;code&gt;git-diff-*&lt;/code&gt; 管道命令。可以使用 &lt;code&gt;--color[=&amp;lt;when&amp;gt;]&lt;/code&gt; 选项在命令行上覆盖。</target>
        </trans-unit>
        <trans-unit id="99af460532d2c9f72e65ed17f7464c8aa563e1f4" translate="yes" xml:space="preserve">
          <source>This does not force normalization of text files, but does ensure that text files that you introduce to the repository have their line endings normalized to LF when they are added, and that files that are already normalized in the repository stay normalized.</source>
          <target state="translated">这并不强制对文本文件进行归一化,但可以确保你引入到版本库的文本文件在添加时,其行结尾会被归一化为LF,而且版本库中已经归一化的文件会保持归一化。</target>
        </trans-unit>
        <trans-unit id="257328db317fb853114a41f8430f87cd826d08a0" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t interfere with interoperating with the Subversion repository you cloned from, but if you wish for your local Git repository to be able to interoperate with someone else&amp;rsquo;s local Git repository, either don&amp;rsquo;t use this option or you should both use it in the same local time zone.</source>
          <target state="translated">这不会干扰与您克隆的Subversion存储库的互操作，但是如果您希望本地Git存储库能够与其他人的本地Git存储库进行互操作，请不要使用此选项，或者您都应在相同的当地时区。</target>
        </trans-unit>
        <trans-unit id="45497ef8f3614492732f059c04bc30af3c6593e9" translate="yes" xml:space="preserve">
          <source>This effectively runs &lt;code&gt;add --interactive&lt;/code&gt;, but bypasses the initial command menu and directly jumps to the &lt;code&gt;patch&lt;/code&gt; subcommand. See &amp;ldquo;Interactive mode&amp;rdquo; for details.</source>
          <target state="translated">这将有效地运行 &lt;code&gt;add --interactive&lt;/code&gt; ，但会绕过初始命令菜单，而直接跳转到 &lt;code&gt;patch&lt;/code&gt; 子命令。有关详细信息，请参见&amp;ldquo;交互模式&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="53c54ba0465bbf9916ac436659dbf61aedb86156" translate="yes" xml:space="preserve">
          <source>This enables parent rewriting, see &lt;code&gt;History Simplification&lt;/code&gt; above.</source>
          <target state="translated">这将启用父级重写，请参见上面的&amp;ldquo; &lt;code&gt;History Simplification&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccdf590466d01d04dcf6da8ad6a6bec9f02c4d8e" translate="yes" xml:space="preserve">
          <source>This environment allows the specification of an alternate index file. If not specified, the default of &lt;code&gt;$GIT_DIR/index&lt;/code&gt; is used.</source>
          <target state="translated">此环境允许指定备用索引文件。如果未指定，则使用默认值 &lt;code&gt;$GIT_DIR/index&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2abd55a6650395bf249165e2f6568e98ab14958c" translate="yes" xml:space="preserve">
          <source>This environment variable allows the specification of an index version for new repositories. It won&amp;rsquo;t affect existing index files. By default index file version 2 or 3 is used. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; for more information.</source>
          <target state="translated">此环境变量允许为新存储库指定索引版本。它不会影响现有的索引文件。默认情况下，使用索引文件版本2或3。有关更多信息，请参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2763e4fc7ba1973ac90184c067d20f9d0fda70a8" translate="yes" xml:space="preserve">
          <source>This environment variable overrides &lt;code&gt;$EDITOR&lt;/code&gt; and &lt;code&gt;$VISUAL&lt;/code&gt;. It is used by several Git commands when, on interactive mode, an editor is to be launched. See also &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; and the &lt;code&gt;core.editor&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">此环境变量将覆盖 &lt;code&gt;$EDITOR&lt;/code&gt; 和 &lt;code&gt;$VISUAL&lt;/code&gt; 。在交互模式下，要启动编辑器时，它由多个Git命令使用。另请参见&lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt;和&lt;a href=&quot;git-config&quot;&gt;git-config [1]中&lt;/a&gt;的 &lt;code&gt;core.editor&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="ddbc158f0dcc3c8ea52494b42fbb66d15e06e460" translate="yes" xml:space="preserve">
          <source>This environment variable overrides &lt;code&gt;$PAGER&lt;/code&gt;. If it is set to an empty string or to the value &quot;cat&quot;, Git will not launch a pager. See also the &lt;code&gt;core.pager&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">此环境变量将覆盖 &lt;code&gt;$PAGER&lt;/code&gt; 。如果将其设置为空字符串或值&amp;ldquo; cat&amp;rdquo;，则Git将不会启动寻呼机。另请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]中&lt;/a&gt;的 &lt;code&gt;core.pager&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="f82f561bc1110497edce7ce36b1651b7ef0d8603" translate="yes" xml:space="preserve">
          <source>This environment variable overrides the configured Git editor when editing the todo list of an interactive rebase. See also &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; and the &lt;code&gt;sequence.editor&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b43d9b9e3f28d79e0c1169949e722bd8f10c35" translate="yes" xml:space="preserve">
          <source>This environment variable overrides the configured Git editor when editing the todo list of an interactive rebase. See also linkit::git-rebase[1] and the &lt;code&gt;sequence.editor&lt;/code&gt; option in linkit::git-config[1].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ea93764f52eb3dcc477c86398962bd9bbded98" translate="yes" xml:space="preserve">
          <source>This event contains the command name for this git process and the hierarchy of commands from parent git processes.</source>
          <target state="translated">这个事件包含了这个git进程的命令名称和父git进程的命令层次。</target>
        </trans-unit>
        <trans-unit id="f5d9f72db5c7ffa9776d5c71964338d54a2515a4" translate="yes" xml:space="preserve">
          <source>This event contains the complete argv received by main().</source>
          <target state="translated">这个事件包含了main()收到的完整的argv。</target>
        </trans-unit>
        <trans-unit id="2a4c1f111536d47e2687ea692bfe5bd399b4307d" translate="yes" xml:space="preserve">
          <source>This event contains the discovered full path of the git executable (on platforms that are configured to resolve it).</source>
          <target state="translated">该事件包含发现的git可执行文件的完整路径(在配置为解析的平台上)。</target>
        </trans-unit>
        <trans-unit id="c8af8dbf59abf700f44d6449c7c951b54692bd2e" translate="yes" xml:space="preserve">
          <source>This event defines a repo-id and associates it with the root of the worktree.</source>
          <target state="translated">该事件定义了一个repo-id,并将其与工作树的根相关联。</target>
        </trans-unit>
        <trans-unit id="efbcacd1a490c688869fdd46397140e75919d7ab" translate="yes" xml:space="preserve">
          <source>This event describes a child process that is about to be spawned.</source>
          <target state="translated">该事件描述了一个即将被生成的子流程。</target>
        </trans-unit>
        <trans-unit id="8c8f935852467fd7c3b46787d77518dc3611a986" translate="yes" xml:space="preserve">
          <source>This event gives the version of the executable and the EVENT format. It should always be the first event in a trace session. The EVENT format version will be incremented if new event types are added, if existing fields are removed, or if there are significant changes in interpretation of existing events or fields. Smaller changes, such as adding a new field to an existing event, will not require an increment to the EVENT format version.</source>
          <target state="translated">该事件给出了可执行文件的版本和EVENT格式。它应该始终是跟踪会话中的第一个事件。如果增加了新的事件类型,删除了现有的字段,或者对现有事件或字段的解释有重大变化,EVENT格式版本将被递增。较小的变化,如在现有事件中添加一个新字段,将不需要递增EVENT格式版本。</target>
        </trans-unit>
        <trans-unit id="7ea085d0e611d87af89c62af2b70656c0016dc7e" translate="yes" xml:space="preserve">
          <source>This event is emitted by the Trace2 &lt;code&gt;atexit&lt;/code&gt; routine during final shutdown. It should be the last event emitted by the process.</source>
          <target state="translated">在最终关闭期间，Trace2 &lt;code&gt;atexit&lt;/code&gt; 例程会发出此事件。它应该是流程发出的最后一个事件。</target>
        </trans-unit>
        <trans-unit id="0b20979b7d0436896a9e4dd619b31c2f047cbd64" translate="yes" xml:space="preserve">
          <source>This event is emitted when git calls &lt;code&gt;exit()&lt;/code&gt;.</source>
          <target state="translated">当git调用 &lt;code&gt;exit()&lt;/code&gt; 时发出此事件。</target>
        </trans-unit>
        <trans-unit id="b7857843019d5043272d37ee889b33f311c45158" translate="yes" xml:space="preserve">
          <source>This event is emitted when one of the &lt;code&gt;error()&lt;/code&gt;, &lt;code&gt;die()&lt;/code&gt;, &lt;code&gt;warning()&lt;/code&gt;, or &lt;code&gt;usage()&lt;/code&gt; functions are called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c63cb7135e802e553dc499a675da732d4f96c3a" translate="yes" xml:space="preserve">
          <source>This event is emitted when one of the &lt;code&gt;error()&lt;/code&gt;, &lt;code&gt;die()&lt;/code&gt;, or &lt;code&gt;usage()&lt;/code&gt; functions are called.</source>
          <target state="translated">调用 &lt;code&gt;error()&lt;/code&gt; ， &lt;code&gt;die()&lt;/code&gt; 或 &lt;code&gt;usage()&lt;/code&gt; 函数之一时，将发出此事件。</target>
        </trans-unit>
        <trans-unit id="ebb8b872e605289564f67171a3133d84781ab210" translate="yes" xml:space="preserve">
          <source>This event is emitted when the program is terminated by a user signal. Depending on the platform, the signal event may prevent the &quot;atexit&quot; event from being generated.</source>
          <target state="translated">当程序被用户信号终止时,会发出该事件。根据平台的不同,该信号事件可能会阻止 &quot;atexit &quot;事件的产生。</target>
        </trans-unit>
        <trans-unit id="2ca8802f12c75856c4e7ea399ac7a1939e2a37eb" translate="yes" xml:space="preserve">
          <source>This event is generated after the current process has returned from the waitpid() and collected the exit information from the child.</source>
          <target state="translated">该事件在当前进程从waitpid()返回并收集了子进程的退出信息后产生。</target>
        </trans-unit>
        <trans-unit id="9fe6d803410a7d3a5cd4bc2114534352d230200b" translate="yes" xml:space="preserve">
          <source>This event is generated before git attempts to &lt;code&gt;exec()&lt;/code&gt; another command rather than starting a child process.</source>
          <target state="translated">这个事件是在git尝试 &lt;code&gt;exec()&lt;/code&gt; 另一个命令而不是启动子进程之前生成的。</target>
        </trans-unit>
        <trans-unit id="93caa8939f471f1240286ec30c6905ef3996f20e" translate="yes" xml:space="preserve">
          <source>This event is generated if the &lt;code&gt;exec()&lt;/code&gt; fails and control returns to the current git command.</source>
          <target state="translated">如果 &lt;code&gt;exec()&lt;/code&gt; 失败并且控制返回到当前的git命令，则会生成此事件。</target>
        </trans-unit>
        <trans-unit id="15a0b5629f08a42566247fd3e8af69adc717eef8" translate="yes" xml:space="preserve">
          <source>This event is generated to log a global parameter, such as a config setting, command-line flag, or environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814427d239ec02f31ac7bf0fb913766e18bfb53e" translate="yes" xml:space="preserve">
          <source>This event is generated to log a global parameter.</source>
          <target state="translated">该事件的产生是为了记录一个全局参数。</target>
        </trans-unit>
        <trans-unit id="54b6cc61590e1e0eba249cc8ddd71ddff154355b" translate="yes" xml:space="preserve">
          <source>This event is generated to log a pre-formatted JSON string containing structured data.</source>
          <target state="translated">该事件的产生是为了记录一个包含结构化数据的预格式化JSON字符串。</target>
        </trans-unit>
        <trans-unit id="0ee97bbcf1fde0cf306363257efe6b7de578045e" translate="yes" xml:space="preserve">
          <source>This event is generated to log a thread- and region-local key/value pair.</source>
          <target state="translated">该事件的产生是为了记录线程和区域的本地键/值对。</target>
        </trans-unit>
        <trans-unit id="4caa8d05330c9e1126d8391705e312b0d8975d63" translate="yes" xml:space="preserve">
          <source>This event is generated when a thread exits. It is generated from &lt;strong&gt;within&lt;/strong&gt; the thread&amp;rsquo;s thread-proc (for TLS reasons).</source>
          <target state="translated">线程退出时会生成此事件。它是从线程的thread-proc &lt;strong&gt;内部&lt;/strong&gt;生成的（出于TLS的原因）。</target>
        </trans-unit>
        <trans-unit id="eba565beaf1b2269c764c147f5196869afe38bce" translate="yes" xml:space="preserve">
          <source>This event is generated when a thread is started. It is generated from &lt;strong&gt;within&lt;/strong&gt; the new thread&amp;rsquo;s thread-proc (for TLS reasons).</source>
          <target state="translated">启动线程时生成此事件。它是&lt;strong&gt;在&lt;/strong&gt;新线程的thread-proc &lt;strong&gt;内部&lt;/strong&gt;生成的（出于TLS的原因）。</target>
        </trans-unit>
        <trans-unit id="1684fe3e3862662b36c1dfb0c9bb20558e1f338a" translate="yes" xml:space="preserve">
          <source>This event is generated when entering a region.</source>
          <target state="translated">该事件在进入一个区域时产生。</target>
        </trans-unit>
        <trans-unit id="809d72e4f54bac6c7054af4e990fa8c97e8c764d" translate="yes" xml:space="preserve">
          <source>This event is generated when leaving a region.</source>
          <target state="translated">该事件在离开一个区域时产生。</target>
        </trans-unit>
        <trans-unit id="1e6a7368deeb7ec580313fc82400f1c12d17672a" translate="yes" xml:space="preserve">
          <source>This event is present when an alias is expanded.</source>
          <target state="translated">当一个别名被展开时,该事件就会出现。</target>
        </trans-unit>
        <trans-unit id="bca802363ffa9599d9e13df71e2f62ec1454e32f" translate="yes" xml:space="preserve">
          <source>This event is written to the git-trace2-discard sentinel file if there are too many files in the target trace directory (see the trace2.maxFiles config option).</source>
          <target state="translated">如果目标跟踪目录中的文件太多,该事件会被写入 git-trace2-discard sentinel 文件(参见 trace2.maxFiles 配置选项)。</target>
        </trans-unit>
        <trans-unit id="8c2ad60a0d9356a6e908b18056fbac1c2b1d4129" translate="yes" xml:space="preserve">
          <source>This event, when present, describes the command variant This event may be emitted more than once.</source>
          <target state="translated">该事件在出现时,描述了命令的变体。</target>
        </trans-unit>
        <trans-unit id="3e7d09cee878b03064fb9d9484c73f3f00225826" translate="yes" xml:space="preserve">
          <source>This example also shows that thread names are assigned in a racy manner as each thread starts and allocates TLS storage.</source>
          <target state="translated">这个例子还表明,在每个线程启动和分配TLS存储时,线程名称都是以一种狂热的方式分配的。</target>
        </trans-unit>
        <trans-unit id="e296b28f1fcad64b66f85f9abe931f54fc5fbde0" translate="yes" xml:space="preserve">
          <source>This example imports a new remote &quot;p4/proj2&quot; into an existing Git repository:</source>
          <target state="translated">本例将新的远程 &quot;p4/proj2 &quot;导入到现有的 Git 仓库中。</target>
        </trans-unit>
        <trans-unit id="7cbbc9fac80d3f9e05217d26ad6f34ea5097abe6" translate="yes" xml:space="preserve">
          <source>This example shows that the index contained 3552 entries.</source>
          <target state="translated">这个例子显示,该索引包含3552个条目。</target>
        </trans-unit>
        <trans-unit id="af5672891a1be21669d22b688901415e2cf060c3" translate="yes" xml:space="preserve">
          <source>This expands to the object name of the delta base for the given object, if it is stored as a delta. Otherwise it expands to the null object name (all zeroes).</source>
          <target state="translated">如果给定的对象被存储为delta,则扩展为delta基的对象名。否则,它将展开为空的对象名(全部为零)。</target>
        </trans-unit>
        <trans-unit id="1a642986ccbacca12888668bff4ca6d3b1007b62" translate="yes" xml:space="preserve">
          <source>This explanation comes for &quot;free&quot; because there was no change. Similarly &lt;code&gt;C&lt;/code&gt; could be explained using &lt;code&gt;1&lt;/code&gt;, but that comes at some cost c&amp;gt;0 because of the modification:</source>
          <target state="translated">这种解释是&amp;ldquo;免费的&amp;rdquo;，因为没有变化。类似地，可以使用 &lt;code&gt;1&lt;/code&gt; 来解释 &lt;code&gt;C&lt;/code&gt; ，但是由于修改，这会付出一定的代价c&amp;gt; 0：</target>
        </trans-unit>
        <trans-unit id="86a0b58a904e042293eb0ea80455653f123e7d4e" translate="yes" xml:space="preserve">
          <source>This extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents.</source>
          <target state="translated">如果重命名或复制检测被激活,这种扩展格式可以很有用,让你看到不同父文件的原始名称。</target>
        </trans-unit>
        <trans-unit id="fc95481325c82bdecdaa23291b735168b05af418" translate="yes" xml:space="preserve">
          <source>This extension does not change git&amp;rsquo;s behavior at all. It is useful only for testing format-1 compatibility.</source>
          <target state="translated">这个扩展根本不会改变git的行为。仅对测试格式1兼容性有用。</target>
        </trans-unit>
        <trans-unit id="24a20ccff9f7f9f91cdf61fb876086b44fc5be61" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis by setting repository&amp;rsquo;s &lt;code&gt;gitweb.pickaxe&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过设置存储库的 &lt;code&gt;gitweb.pickaxe&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="3fcd9d965aa29d51e3ab01e56c522e086b7f545b" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.avatar&lt;/code&gt; configuration variable.</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.avatar&lt;/code&gt; 配置变量在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="da6908103a49ae5e820a33c13aadd5dfdd3e67a7" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.blame&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.blame&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="1d6d167abae14ab18966eab440f954ed6085f29c" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.grep&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.grep&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="dd4f802848cf6cbdc7682aeefb00472f2c444c9e" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.highlight&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.highlight&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="a8e82652b1c51e397e7f1e31621e9084d5611fda" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.patches&lt;/code&gt; configuration variable (integer).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.patches&lt;/code&gt; 配置变量（整数）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="a0528d6fc23cb2716835712f44b5daf955251062" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.remote_heads&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.remote_heads&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="58b983175f59d7aad97dac71b32251a2f4a8c4a0" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.showSizes&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.showSizes&lt;/code&gt; 配置变量（布尔值）在每个存储库的基础上配置此功能。</target>
        </trans-unit>
        <trans-unit id="ee33afe943a28f48529ed67cc410ad185ea09f23" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.snapshot&lt;/code&gt; configuration variable, which contains a comma separated list of formats or &quot;none&quot; to disable snapshots. Unknown values are ignored.</source>
          <target state="translated">可以通过存储库的 &lt;code&gt;gitweb.snapshot&lt;/code&gt; 配置变量在每个存储库的基础上配置此功能，该变量包含逗号分隔的格式列表或&amp;ldquo; none&amp;rdquo;以禁用快照。未知值将被忽略。</target>
        </trans-unit>
        <trans-unit id="c2467a6f49bad0810d0f5e1c4a51888ceb4f5b0f" translate="yes" xml:space="preserve">
          <source>This feature can be configured on per-repository basis after setting $feature{&lt;code&gt;extra-branch-refs&lt;/code&gt;}{&lt;code&gt;override&lt;/code&gt;} to true, via repository&amp;rsquo;s &lt;code&gt;gitweb.extraBranchRefs&lt;/code&gt; configuration variable, which contains a space separated list of refs. An example:</source>
          <target state="translated">通过将$ feature { &lt;code&gt;extra-branch-refs&lt;/code&gt; } { &lt;code&gt;override&lt;/code&gt; }设置为true后，可以通过存储库的 &lt;code&gt;gitweb.extraBranchRefs&lt;/code&gt; 配置变量在每个存储库的基础上配置此功能，该配置变量包含一个以空格分隔的refs列表。一个例子：</target>
        </trans-unit>
        <trans-unit id="83b4612ad81d70c9ed8920a4b451b69b8c3ee080" translate="yes" xml:space="preserve">
          <source>This feature is intended to speed up git operations for repos that have large working directories.</source>
          <target state="translated">这个功能的目的是为了加快有大型工作目录的仓库的git操作。</target>
        </trans-unit>
        <trans-unit id="6b24b487d6d9654020073f6754733ecc051175ad" translate="yes" xml:space="preserve">
          <source>This feature is semi-deprecated. For scripting purpose, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;&lt;code&gt;--porcelain&lt;/code&gt; and &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt;&lt;code&gt;--name-status&lt;/code&gt; are almost always superior alternatives, and users should look at &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;&lt;code&gt;--short&lt;/code&gt; or &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--name-status&lt;/code&gt; for more user-friendly alternatives.</source>
          <target state="translated">半不推荐使用此功能。出于脚本目的，&lt;a href=&quot;git-status&quot;&gt;git-status [1] &lt;/a&gt; &lt;code&gt;--porcelain&lt;/code&gt; 和&lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1] &lt;/a&gt; &lt;code&gt;--name-status&lt;/code&gt; 几乎总是更好的选择，用户应查看&lt;a href=&quot;git-status&quot;&gt;git-status [1] &lt;/a&gt; &lt;code&gt;--short&lt;/code&gt; 或&lt;a href=&quot;git-diff&quot;&gt;git- diff [1] &lt;/a&gt; &lt;code&gt;--name-status&lt;/code&gt; 提供更多用户友好的替代方案。</target>
        </trans-unit>
        <trans-unit id="0861edc399d3214fad2ecef2c8c7d8f9e28b4564" translate="yes" xml:space="preserve">
          <source>This feature is useful when an established project should be accepted despite early commits containing errors that can be safely ignored such as invalid committer email addresses. Note: corrupt objects cannot be skipped with this setting.</source>
          <target state="translated">这个功能对于已经建立的项目来说是很有用的,尽管早期的提交中包含了一些错误,比如提交人的电子邮件地址无效,但还是应该被接受。注意:这个设置不能跳过损坏的对象。</target>
        </trans-unit>
        <trans-unit id="5474f37d061902594342fbe38be401770ea2769f" translate="yes" xml:space="preserve">
          <source>This feature works by recording the mtime of the working tree directories and then omitting reading directories and stat calls against files in those directories whose mtime hasn&amp;rsquo;t changed. For this to work the underlying operating system and file system must change the &lt;code&gt;st_mtime&lt;/code&gt; field of directories if files in the directory are added, modified or deleted.</source>
          <target state="translated">此功能的工作方式是记录工作树目录的mtime，然后忽略mtime不变的那些目录中的文件的读取目录和stat调用。为此，如果在目录中添加，修改或删除了文件，则底层操作系统和文件系统必须更改目录的 &lt;code&gt;st_mtime&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="ef2541ade640bd800921de0e87cda6dd56d4d5f6" translate="yes" xml:space="preserve">
          <source>This fetches revisions from the SVN parent of the current HEAD and rebases the current (uncommitted to SVN) work against it.</source>
          <target state="translated">这将从当前 HEAD 的 SVN 父版本中获取修订版,并对当前(未提交到 SVN)的工作进行重定向。</target>
        </trans-unit>
        <trans-unit id="e6f84c5c8c6a08793025b9538660cbd1c1faa637" translate="yes" xml:space="preserve">
          <source>This file contains the commit message of a commit in progress. If &lt;code&gt;git commit&lt;/code&gt; exits due to an error before creating a commit, any commit message that has been provided by the user (e.g., in an editor session) will be available in this file, but will be overwritten by the next invocation of &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">该文件包含正在进行的提交的提交消息。如果 &lt;code&gt;git commit&lt;/code&gt; 由于在创建提交之前出错而退出，则用户提供的任何提交消息（例如，在编辑器会话中）都将在此文件中可用，但是下次 &lt;code&gt;git commit&lt;/code&gt; 调用将覆盖该消息。</target>
        </trans-unit>
        <trans-unit id="2063696fd909d95d720efff6859f2846f7a33789" translate="yes" xml:space="preserve">
          <source>This file helps dumb transports discover what refs are available in this repository. If the repository is published for dumb transports, this file should be regenerated by &lt;code&gt;git update-server-info&lt;/code&gt; every time a tag or branch is created or modified. This is normally done from the &lt;code&gt;hooks/update&lt;/code&gt; hook, which is run by the &lt;code&gt;git-receive-pack&lt;/code&gt; command when you &lt;code&gt;git push&lt;/code&gt; into the repository.</source>
          <target state="translated">此文件可帮助愚蠢的传输发现该存储库中可用的参考。如果发布该存储库是为了进行愚蠢的传输，则每次创建或修改标签或分支时， &lt;code&gt;git update-server-info&lt;/code&gt; 都应重新生成此文件。这通常是通过 &lt;code&gt;hooks/update&lt;/code&gt; 钩子完成的，当您将 &lt;code&gt;git push&lt;/code&gt; 到存储库时，钩子/更新钩子由 &lt;code&gt;git-receive-pack&lt;/code&gt; 命令运行。</target>
        </trans-unit>
        <trans-unit id="3487083c7b98c66e39acc8f940f40c0e9ceac88f" translate="yes" xml:space="preserve">
          <source>This file is to help dumb transports discover what packs are available in this object store. Whenever a pack is added or removed, &lt;code&gt;git update-server-info&lt;/code&gt; should be run to keep this file up to date if the repository is published for dumb transports. &lt;code&gt;git repack&lt;/code&gt; does this by default.</source>
          <target state="translated">此文件是为了帮助愚蠢的传输发现此对象存储中有哪些可用的包。每当添加或删除 &lt;code&gt;git update-server-info&lt;/code&gt; 时，如果已发布存储库以进行愚蠢的传输，则应运行git update-server-info以使该文件保持最新。 &lt;code&gt;git repack&lt;/code&gt; 默认情况下会这样做。</target>
        </trans-unit>
        <trans-unit id="cbe65e34529f44f10bf3c4bc531b3ef1a1689dfb" translate="yes" xml:space="preserve">
          <source>This file mainly serves as the mapping between the name and path of submodules in the superproject, such that the submodule&amp;rsquo;s Git directory can be located.</source>
          <target state="translated">该文件主要用作超级项目中子模块的名称和路径之间的映射，以便可以找到子模块的Git目录。</target>
        </trans-unit>
        <trans-unit id="071050e2544b6fc3703fb63508bbfdc9243b46ab" translate="yes" xml:space="preserve">
          <source>This file records URLs to alternate object stores that this object store borrows objects from, to be used when the repository is fetched over HTTP.</source>
          <target state="translated">这个文件记录了这个对象商店借用对象的备用对象商店的 URL,以便在通过 HTTP 获取存储库时使用。</target>
        </trans-unit>
        <trans-unit id="cc3397ff622f0d4d27f532099612807583041388" translate="yes" xml:space="preserve">
          <source>This file records fake commit ancestry information, to pretend the set of parents a commit has is different from how the commit was actually created. One record per line describes a commit and its fake parents by listing their 40-byte hexadecimal object names separated by a space and terminated by a newline.</source>
          <target state="translated">这个文件记录了假的提交祖先信息,以假装一个提交的父母集与该提交的实际创建方式不同。每行一条记录通过列出40字节的十六进制对象名来描述一个提交和它的假父母,并以空格分隔,以换行结束。</target>
        </trans-unit>
        <trans-unit id="1873ba1c652fc3e8dae8a41ecd45dff2c995baaf" translate="yes" xml:space="preserve">
          <source>This file records paths to alternate object stores that this object store borrows objects from, one pathname per line. Note that not only native Git tools use it locally, but the HTTP fetcher also tries to use it remotely; this will usually work if you have relative paths (relative to the object database, not to the repository!) in your alternates file, but it will not work if you use absolute paths unless the absolute path in filesystem and web URL is the same. See also &lt;code&gt;objects/info/http-alternates&lt;/code&gt;.</source>
          <target state="translated">该文件记录到该对象存储库借用对象的备用对象存储库的路径，每行一个路径名。请注意，不仅本地Git工具在本地使用它，而且HTTP fetcher也会尝试远程使用它。如果您的替代文件中有相对路径（相对于对象数据库，而不是存储库！），通常这将起作用，但如果您使用绝对路径，则除非文件系统和Web URL中的绝对路径相同，否则它将不起作用。另请参阅 &lt;code&gt;objects/info/http-alternates&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="517ab2689bb34239adf0b92ebb2a70e736956866" translate="yes" xml:space="preserve">
          <source>This file stores sparse checkout patterns. See also: &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt;.</source>
          <target state="translated">此文件存储稀疏签出模式。另请参阅：&lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39e8ca5394d81b30bccd145a749de9346fba2480" translate="yes" xml:space="preserve">
          <source>This file uses the following format:</source>
          <target state="translated">该文件使用以下格式:</target>
        </trans-unit>
        <trans-unit id="53c1d1d0fe83b95fe57b9ac9f6f59413589df721" translate="yes" xml:space="preserve">
          <source>This file, by convention among Porcelains, stores the exclude pattern list. &lt;code&gt;.gitignore&lt;/code&gt; is the per-directory ignore file. &lt;code&gt;git status&lt;/code&gt;, &lt;code&gt;git add&lt;/code&gt;, &lt;code&gt;git rm&lt;/code&gt; and &lt;code&gt;git clean&lt;/code&gt; look at it but the core Git commands do not look at it. See also: &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="translated">按照陶瓷惯例，此文件存储排除模式列表。 &lt;code&gt;.gitignore&lt;/code&gt; 是每个目录的忽略文件。 &lt;code&gt;git status&lt;/code&gt; ， &lt;code&gt;git add&lt;/code&gt; ， &lt;code&gt;git rm&lt;/code&gt; 和 &lt;code&gt;git clean&lt;/code&gt; 会看它，但是核心的Git命令不会看它。另请参阅：&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8956b9fdca3244ff8cd9467aefdc82ab275d878" translate="yes" xml:space="preserve">
          <source>This filter may be used if you only need to modify the environment in which the commit will be performed. Specifically, you might want to rewrite the author/committer name/email/time environment variables (see &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; for details).</source>
          <target state="translated">如果仅需要修改将在其中执行提交的环境，则可以使用此过滤器。具体来说，您可能想要重写作者/提交者名称/电子邮件/时间环境变量（有关详细信息，请参见&lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1f7d9b6979d573a6d61c7fc37aef6ce7f09ba079" translate="yes" xml:space="preserve">
          <source>This flag causes &lt;code&gt;git diff-tree --stdin&lt;/code&gt; to also show the commit message before the differences.</source>
          <target state="translated">这个标志使 &lt;code&gt;git diff-tree --stdin&lt;/code&gt; 也显示差异之前的提交消息。</target>
        </trans-unit>
        <trans-unit id="f18c1480999d4a64a19b051751a1dfdb3d01c394" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in a local pack that has a .keep file to be ignored, even if it would have otherwise been packed.</source>
          <target state="translated">这个标志会导致一个已经在本地包中有.keep文件的对象被忽略,即使它本来会被打包。</target>
        </trans-unit>
        <trans-unit id="3b2c5aa43d85ae95c70f7126e1a8d471a0247285" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in a pack to be ignored even if it would have otherwise been packed.</source>
          <target state="translated">这个标志会导致一个已经在包装中的对象被忽略,即使它本来会被包装。</target>
        </trans-unit>
        <trans-unit id="936ccdd465b71c76f59e3d7929f0e31e3a24c431" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in the given pack to be ignored, even if it would have otherwise been packed. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; is the pack file name without leading directory (e.g. &lt;code&gt;pack-123.pack&lt;/code&gt;). The option could be specified multiple times to keep multiple packs.</source>
          <target state="translated">即使已打包，此标志也会导致已忽略给定包中的对象。 &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; 是没有前导目录的包文件名（例如 &lt;code&gt;pack-123.pack&lt;/code&gt; ）。可以多次指定该选项以保留多个包装。</target>
        </trans-unit>
        <trans-unit id="9fad47cb9db9729fbeb177e82626a6322dbefd6c" translate="yes" xml:space="preserve">
          <source>This flag causes an object that is borrowed from an alternate object store to be ignored even if it would have otherwise been packed.</source>
          <target state="translated">这个标志会导致从备用对象存储中借用的对象被忽略,即使它本来会被打包。</target>
        </trans-unit>
        <trans-unit id="97fddffea713eaa9774ecf695b0619f959916c25" translate="yes" xml:space="preserve">
          <source>This flag causes combined diffs (used for merge commits) to list the name of the file from all parents. It thus only has effect when -c or --cc are specified, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested).</source>
          <target state="translated">这个标志会使合并后的差异文件(用于合并提交)列出所有父文件的名称。因此,它只有在指定了 -c 或 --cc 时才会生效,而且只有在检测到文件名变化时才会有用(例如,当要求检测重命名或复制时)。</target>
        </trans-unit>
        <trans-unit id="7d04699c745135d6f14712a3d65005478838c3a7" translate="yes" xml:space="preserve">
          <source>This flag changes the way a merge commit is displayed (which means it is useful only when the command is given one &amp;lt;tree-ish&amp;gt;, or &lt;code&gt;--stdin&lt;/code&gt;). It shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time (which is what the &lt;code&gt;-m&lt;/code&gt; option does). Furthermore, it lists only files which were modified from all parents.</source>
          <target state="translated">该标志改变了合并提交的显示方式（这意味着仅在命令被赋予一个&amp;lt;tree-ish&amp;gt;或 &lt;code&gt;--stdin&lt;/code&gt; 时才有用）。它同时显示了每个父项与合并结果之间的差异，而不是一次显示父项与结果之间的成对差异（这是 &lt;code&gt;-m&lt;/code&gt; 选项的作用）。此外，它仅列出从所有父级修改而来的文件。</target>
        </trans-unit>
        <trans-unit id="0d503f20848f4e1ff6c5e78038f4bce28f3422a3" translate="yes" xml:space="preserve">
          <source>This flag changes the way a merge commit patch is displayed, in a similar way to the &lt;code&gt;-c&lt;/code&gt; option. It implies the &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-p&lt;/code&gt; options and further compresses the patch output by omitting uninteresting hunks whose the contents in the parents have only two variants and the merge result picks one of them without modification. When all hunks are uninteresting, the commit itself and the commit log message is not shown, just like in any other &quot;empty diff&quot; case.</source>
          <target state="translated">该标志以与 &lt;code&gt;-c&lt;/code&gt; 选项类似的方式更改合并提交补丁的显示方式。它暗示了 &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;-p&lt;/code&gt; 选项，并通过省略不感兴趣的块（它们在父级中的内容只有两个变体，合并结果选择了其中一个而没有修改）来进一步压缩补丁输出。当所有的块都不感兴趣时​​，就不会显示提交本身和提交日志消息，就像其他&amp;ldquo;空差异&amp;rdquo;情况一样。</target>
        </trans-unit>
        <trans-unit id="4835250d6cbee97633146544cd1896afcc631099" translate="yes" xml:space="preserve">
          <source>This flag disables these checks, and can cause the remote repository to lose commits; use it with care.</source>
          <target state="translated">这个标志会禁用这些检查,并可能导致远程仓库丢失提交,请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="cc5f19786a1b0eda7705eaaa80c372612ab5d782" translate="yes" xml:space="preserve">
          <source>This flag implies the &lt;code&gt;-c&lt;/code&gt; option and further compresses the patch output by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification.</source>
          <target state="translated">该标志表示 &lt;code&gt;-c&lt;/code&gt; 选项，并通过省略不感兴趣的块（它们在父对象中的内容只有两个变体）并且合并结果选择其中一个而没有修改的粗体来进一步压缩补丁输出。</target>
        </trans-unit>
        <trans-unit id="03d7872e2a4e991418dc3ea26303b414cb645f27" translate="yes" xml:space="preserve">
          <source>This flag is passed to the &lt;code&gt;git apply&lt;/code&gt; program (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) that applies the patch. Implies --apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9f2e241df42ed566896490c4c1723461343597" translate="yes" xml:space="preserve">
          <source>This flag is passed to the &lt;code&gt;git log&lt;/code&gt; program (see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;) that generates the patches.</source>
          <target state="translated">该标志被传递到生成补丁的 &lt;code&gt;git log&lt;/code&gt; 程序（请参阅&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7d74132f018d1e29c74648fc0cf6690a80cd700b" translate="yes" xml:space="preserve">
          <source>This flag makes the command not to report its progress on the standard error stream.</source>
          <target state="translated">该标志使命令不在标准错误流上报告其进度。</target>
        </trans-unit>
        <trans-unit id="c7300f914a6246e85c4558f9e03e3ac6bd2957c2" translate="yes" xml:space="preserve">
          <source>This flag makes the merge commits show the full diff like regular commits; for each merge parent, a separate log entry and diff is generated. An exception is that only diff against the first parent is shown when &lt;code&gt;--first-parent&lt;/code&gt; option is given; in that case, the output represents the changes the merge brought &lt;code&gt;into&lt;/code&gt; the then-current branch.</source>
          <target state="translated">该标志使合并提交像常规提交一样显示完整的差异；对于每个合并父级，将生成一个单独的日志条目和差异。一个例外是，给定 &lt;code&gt;--first-parent&lt;/code&gt; 选项时，仅显示与第一个父对象的差异；在这种情况下，输出表示变化带来合并 &lt;code&gt;into&lt;/code&gt; 当时的分支。</target>
        </trans-unit>
        <trans-unit id="824f1a5cbd322eac2edc9b61691e0afb5fb06c7c" translate="yes" xml:space="preserve">
          <source>This flag tells the command not to reuse existing object data at all, including non deltified object, forcing recompression of everything. This implies --no-reuse-delta. Useful only in the obscure case where wholesale enforcement of a different compression level on the packed data is desired.</source>
          <target state="translated">这个标志告诉命令完全不重用现有的对象数据,包括非强化对象,强制重新压缩所有的数据。这意味着--no-reuse-delta。只有在需要对打包的数据全盘执行不同压缩级别的情况下才有用。</target>
        </trans-unit>
        <trans-unit id="e554d11fed47fbadc588fbbd426a692640350799" translate="yes" xml:space="preserve">
          <source>This form can only be used in the middle of a &lt;code&gt;commit&lt;/code&gt;. The path names a directory entry within fast-import&amp;rsquo;s active commit. The path must be quoted in this case.</source>
          <target state="translated">这种形式只能在 &lt;code&gt;commit&lt;/code&gt; 。该路径为快速导入的活动提交中的目录条目命名。在这种情况下，必须引用路径。</target>
        </trans-unit>
        <trans-unit id="55cd46dfe4dc47146eb359f16ba2ab6440f5d33b" translate="yes" xml:space="preserve">
          <source>This form is to compare the given two paths on the filesystem. You can omit the &lt;code&gt;--no-index&lt;/code&gt; option when running the command in a working tree controlled by Git and at least one of the paths points outside the working tree, or when running the command outside a working tree controlled by Git. This form implies &lt;code&gt;--exit-code&lt;/code&gt;.</source>
          <target state="translated">这种形式是比较文件系统上给定的两个路径。在由Git控制的工作树中运行命令时，可以忽略 &lt;code&gt;--no-index&lt;/code&gt; 选项，并且至少有一个路径指向该工作树之外，或者在由Git控制的工作树外部运行命令时，也可以省略该选项。这种形式意味着 &lt;code&gt;--exit-code&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a36c2e6e9bf305ffd5ef7a7e4c453ac93dfb865" translate="yes" xml:space="preserve">
          <source>This form is to view the changes on the branch containing and up to the second &amp;lt;commit&amp;gt;, starting at a common ancestor of both &amp;lt;commit&amp;gt;. &quot;git diff A...B&quot; is equivalent to &quot;git diff $(git merge-base A B) B&quot;. You can omit any one of &amp;lt;commit&amp;gt;, which has the same effect as using HEAD instead.</source>
          <target state="translated">此表单用于查看包含且直到第二个&amp;lt;commit&amp;gt;的分支上的更改，该更改始于两个&amp;lt;commit&amp;gt;的共同祖先。&amp;ldquo; git diff A ... B&amp;rdquo;等效于&amp;ldquo; git diff $（git merge-base AB）B&amp;rdquo;。您可以省略&amp;lt;commit&amp;gt;中的任何一个，其效果与使用HEAD相同。</target>
        </trans-unit>
        <trans-unit id="1c4bbf16a9eb9be23dc9fab9fed4d09670912ec0" translate="yes" xml:space="preserve">
          <source>This form is to view the changes on the branch containing and up to the second &amp;lt;commit&amp;gt;, starting at a common ancestor of both &amp;lt;commit&amp;gt;. &lt;code&gt;git diff A...B&lt;/code&gt; is equivalent to &lt;code&gt;git diff $(git merge-base A B) B&lt;/code&gt;. You can omit any one of &amp;lt;commit&amp;gt;, which has the same effect as using HEAD instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18011d68a19f669179582c8652eaff17f583329f" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you have in your working tree relative to the named &amp;lt;commit&amp;gt;. You can use HEAD to compare it with the latest commit, or a branch name to compare with the tip of a different branch.</source>
          <target state="translated">此表单用于查看您在工作树中相对于名为&amp;lt;commit&amp;gt;的更改。您可以使用HEAD将其与最新提交进行比较，或使用分支名称与其他分支的尖端进行比较。</target>
        </trans-unit>
        <trans-unit id="0c3233dc5774a7d1fc399a8b304cc732bba72d9f" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you made relative to the index (staging area for the next commit). In other words, the differences are what you &lt;code&gt;could&lt;/code&gt; tell Git to further add to the index but you still haven&amp;rsquo;t. You can stage these changes by using &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;.</source>
          <target state="translated">该表单用于查看您相对于索引（下一次提交的暂存区域）所做的更改。换句话说，您 &lt;code&gt;could&lt;/code&gt; 告诉Git进一步将差异添加到索引中，但您仍然没有。您可以使用&lt;a href=&quot;git-add&quot;&gt;git-add [1]进行&lt;/a&gt;这些更改。</target>
        </trans-unit>
        <trans-unit id="ee8e76f95895702db36db495b0e53027904973c9" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you staged for the next commit relative to the named &amp;lt;commit&amp;gt;. Typically you would want comparison with the latest commit, so if you do not give &amp;lt;commit&amp;gt;, it defaults to HEAD. If HEAD does not exist (e.g. unborn branches) and &amp;lt;commit&amp;gt; is not given, it shows all staged changes. --staged is a synonym of --cached.</source>
          <target state="translated">此表单用于查看相对于命名的&amp;lt;commit&amp;gt;为下一次提交所做的更改。通常，您希望与最新提交进行比较，因此，如果您不提供&amp;lt;commit&amp;gt;，则默认为HEAD。如果HEAD不存在（例如，未出生的分支）并且未给出&amp;lt;commit&amp;gt;，则它将显示所有已分阶段的更改。--staged是--cached的同义词。</target>
        </trans-unit>
        <trans-unit id="51dda6a69f38e64f972e32a62549822542d75887" translate="yes" xml:space="preserve">
          <source>This form is to view the differences between the raw contents of two blob objects.</source>
          <target state="translated">这种形式是为了查看两个blob对象的原始内容之间的差异。</target>
        </trans-unit>
        <trans-unit id="df8ee2cb26426eddf11d55337361b04a2e3c04bb" translate="yes" xml:space="preserve">
          <source>This form is to view the results of a merge commit. The first listed &amp;lt;commit&amp;gt; must be the merge itself; the remaining two or more commits should be its parents. A convenient way to produce the desired set of revisions is to use the &lt;code&gt;^@&lt;/code&gt; suffix. For instance, if &lt;code&gt;master&lt;/code&gt; names a merge commit, &lt;code&gt;git diff master
master^@&lt;/code&gt; gives the same combined diff as &lt;code&gt;git show master&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3140d31a73de32a89eb697f18f04aa202d7a5d8e" translate="yes" xml:space="preserve">
          <source>This form is to view the results of a merge commit. The first listed &amp;lt;commit&amp;gt; must be the merge itself; the remaining two or more commits should be its parents. A convenient way to produce the desired set of revisions is to use the ^@ suffix. For instance, if &lt;code&gt;master&lt;/code&gt; names a merge commit, &lt;code&gt;git diff master
master^@&lt;/code&gt; gives the same combined diff as &lt;code&gt;git show master&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395d78419362cad7438eb6eae46785d35953f019" translate="yes" xml:space="preserve">
          <source>This form resets the current branch head to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; and possibly updates the index (resetting it to the tree of &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;) and the working tree depending on &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is omitted, defaults to &lt;code&gt;--mixed&lt;/code&gt;. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; must be one of the following:</source>
          <target state="translated">该表格将当前分支头重置为 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; ,并可能更新索引（将其重置为 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 的树）和取决于 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 的工作树。如果省略 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; ，则默认为 &lt;code&gt;--mixed&lt;/code&gt; 。所述 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 必须是下列之一：</target>
        </trans-unit>
        <trans-unit id="90bcd35d4969f3a90ba2bd18f27a5c6eb93f333b" translate="yes" xml:space="preserve">
          <source>This form will use the first line matching the given POSIX regex. If &amp;lt;start&amp;gt; is a regex, it will search from the end of the previous &lt;code&gt;-L&lt;/code&gt; range, if any, otherwise from the start of file. If &amp;lt;start&amp;gt; is &amp;ldquo;^/regex/&amp;rdquo;, it will search from the start of file. If &amp;lt;end&amp;gt; is a regex, it will search starting at the line given by &amp;lt;start&amp;gt;.</source>
          <target state="translated">此表单将使用与给定POSIX正则表达式匹配的第一行。如果&amp;lt;start&amp;gt;是正则表达式，它将从前一个 &lt;code&gt;-L&lt;/code&gt; 范围的末尾（如果有）搜索，否则从文件的开头搜索。如果&amp;lt;start&amp;gt;是&amp;ldquo; ^ / regex /&amp;rdquo;，它将从文件的开头搜索。如果&amp;lt;end&amp;gt;是正则表达式，它将从&amp;lt;start&amp;gt;给出的行开始搜索。</target>
        </trans-unit>
        <trans-unit id="215f3a05528763c5f39e5365947941ffab5eacc1" translate="yes" xml:space="preserve">
          <source>This form will use the first line matching the given POSIX regex. If &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; is a regex, it will search from the end of the previous &lt;code&gt;-L&lt;/code&gt; range, if any, otherwise from the start of file. If &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; is &lt;code&gt;^/regex/&lt;/code&gt;, it will search from the start of file. If &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; is a regex, it will search starting at the line given by &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42c261dd1828c15332725a480fa7095bcc76b2a" translate="yes" xml:space="preserve">
          <source>This format expects the first line of the file to contain the &quot;Cc:&quot; value and the &quot;Subject:&quot; of the message as the second line.</source>
          <target state="translated">这种格式希望文件的第一行包含 &quot;Cc:&quot;值,第二行包含邮件的 &quot;Subject:&quot;。</target>
        </trans-unit>
        <trans-unit id="105520fc7842a24e43537a27759a074335828eb6" translate="yes" xml:space="preserve">
          <source>This format is identical to version &lt;code&gt;0&lt;/code&gt;, with the following exceptions:</source>
          <target state="translated">此格式与版本 &lt;code&gt;0&lt;/code&gt; 相同，但以下情况除外：</target>
        </trans-unit>
        <trans-unit id="fd22347e6ce1cebbfe9140a8d5df54f1132eb3e9" translate="yes" xml:space="preserve">
          <source>This format is no longer produced by any Git command, but is and will continue to be supported by &lt;code&gt;update-index --index-info&lt;/code&gt;.</source>
          <target state="translated">此格式不再由任何Git命令生成，但是 &lt;code&gt;update-index --index-info&lt;/code&gt; 将继续支持。</target>
        </trans-unit>
        <trans-unit id="e1e42b99834dd201113f33eae88b5856f686096e" translate="yes" xml:space="preserve">
          <source>This format is to put higher order stages into the index file and matches &lt;code&gt;git ls-files --stage&lt;/code&gt; output.</source>
          <target state="translated">此格式用于将高阶阶段放入索引文件中，并匹配 &lt;code&gt;git ls-files --stage&lt;/code&gt; 输出。</target>
        </trans-unit>
        <trans-unit id="483caba3e82677e09e2d521ebba75089a90ce09e" translate="yes" xml:space="preserve">
          <source>This format is to stuff &lt;code&gt;git ls-tree&lt;/code&gt; output into the index.</source>
          <target state="translated">这种格式是将 &lt;code&gt;git ls-tree&lt;/code&gt; 输出填充到索引中。</target>
        </trans-unit>
        <trans-unit id="078ec0cba6df63b2f2fc0bbcd069e250ea13b628" translate="yes" xml:space="preserve">
          <source>This format is used to refer to another commit in a commit message and is the same as &lt;code&gt;--pretty='format:%C(auto)%h (%s, %ad)'&lt;/code&gt;. By default, the date is formatted with &lt;code&gt;--date=short&lt;/code&gt; unless another &lt;code&gt;--date&lt;/code&gt; option is explicitly specified. As with any &lt;code&gt;format:&lt;/code&gt; with format placeholders, its output is not affected by other options like &lt;code&gt;--decorate&lt;/code&gt; and &lt;code&gt;--walk-reflogs&lt;/code&gt;.</source>
          <target state="translated">此格式用于引用提交消息中的另一个提交，并且与 &lt;code&gt;--pretty='format:%C(auto)%h (%s, %ad)'&lt;/code&gt; 。默认情况下，日期格式为 &lt;code&gt;--date=short&lt;/code&gt; ,除非明确指定了另一个 &lt;code&gt;--date&lt;/code&gt; 选项。与任何 &lt;code&gt;format:&lt;/code&gt; 使用格式占位符，其输出不受 &lt;code&gt;--decorate&lt;/code&gt; 和 &lt;code&gt;--walk-reflogs&lt;/code&gt; 之类的其他选项的影响。</target>
        </trans-unit>
        <trans-unit id="742c78626a467f269e89b016f43c5e1a7be4cd88" translate="yes" xml:space="preserve">
          <source>This gets rid of the &lt;code&gt;git-svn-id:&lt;/code&gt; lines at the end of every commit.</source>
          <target state="translated">这就消除了 &lt;code&gt;git-svn-id:&lt;/code&gt; 每次提交结束时的行。</target>
        </trans-unit>
        <trans-unit id="2acaf36aea784a80df7509fcb8e38355c645c5a7" translate="yes" xml:space="preserve">
          <source>This gives a very controlled flow of fixes. If you notice that you have applied a fix to e.g. &lt;code&gt;master&lt;/code&gt; that is also required in &lt;code&gt;maint&lt;/code&gt;, you will need to cherry-pick it (using &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;) downwards. This will happen a few times and is nothing to worry about unless you do it very frequently.</source>
          <target state="translated">这样可以很好地控制修补程序的流程。如果发现已应用修复到例如 &lt;code&gt;master&lt;/code&gt; ，其也需要在 &lt;code&gt;maint&lt;/code&gt; ，则需要樱桃挑它（使用&lt;a href=&quot;git-cherry-pick&quot;&gt;GIT-樱桃挑[1] &lt;/a&gt;）向下。这将发生几次，除非您经常进行，否则无需担心。</target>
        </trans-unit>
        <trans-unit id="1f3884c08aac0f5d8941c7814b274c9743619a33" translate="yes" xml:space="preserve">
          <source>This happens if the &lt;code&gt;subsystem&lt;/code&gt; rebase had conflicts, or used &lt;code&gt;--interactive&lt;/code&gt; to omit, edit, squash, or fixup commits; or if the upstream used one of &lt;code&gt;commit --amend&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, or a full history rewriting command like &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;&lt;code&gt;filter-repo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;subsystem&lt;/code&gt; 发生了冲突，或者使用 &lt;code&gt;--interactive&lt;/code&gt; 来省略，编辑，压榨或修复提交，则会发生这种情况。或者上游是否使用 &lt;code&gt;commit --amend&lt;/code&gt; ， &lt;code&gt;reset&lt;/code&gt; 或完整的历史记录重写命令（如&lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt; &lt;code&gt;filter-repo&lt;/code&gt; )之一&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53ac63807fcdbfc7e050fb3151d6b086f2e9a274" translate="yes" xml:space="preserve">
          <source>This happens if the &lt;code&gt;subsystem&lt;/code&gt; rebase was a simple rebase and had no conflicts.</source>
          <target state="translated">如果 &lt;code&gt;subsystem&lt;/code&gt; 是简单的基础并且没有冲突，则会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="d414984e9f8d7bfd782c8f2da36b80bcd80ea28e" translate="yes" xml:space="preserve">
          <source>This has a few user-visible effects and caveats:</source>
          <target state="translated">这有一些用户可见的效果和注意事项。</target>
        </trans-unit>
        <trans-unit id="1c876a37c9c7633e47e1a6a38b1f16f75e32a3ed" translate="yes" xml:space="preserve">
          <source>This has a very similar UI to &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;revert&lt;/code&gt;, and lets you add untracked paths to the index.</source>
          <target state="translated">它具有非常相似的UI来 &lt;code&gt;update&lt;/code&gt; 和 &lt;code&gt;revert&lt;/code&gt; ，并允许您将未跟踪的路径添加到索引。</target>
        </trans-unit>
        <trans-unit id="33280cb105ee3b71902ce7b15c9592fd52f73e30" translate="yes" xml:space="preserve">
          <source>This has a very similar UI to &lt;code&gt;update&lt;/code&gt;, and the staged information for selected paths are reverted to that of the HEAD version. Reverting new paths makes them untracked.</source>
          <target state="translated">这具有非常相似的UI来 &lt;code&gt;update&lt;/code&gt; ，并且选定路径的暂存信息将还原为HEAD版本的信息。还原新路径使它们无法跟踪。</target>
        </trans-unit>
        <trans-unit id="4d4512b846dcedcc9cf4704e69eaeda15e1830db" translate="yes" xml:space="preserve">
          <source>This has been requested by some kernel developers because some bugs called sporadic bugs do not appear in all the kernel builds because they are very dependent on the compiler output.</source>
          <target state="translated">这是一些内核开发者要求的,因为一些被称为零星bug的bug并没有出现在所有的内核构建中,因为它们非常依赖于编译器的输出。</target>
        </trans-unit>
        <trans-unit id="b93781d2b5ee24d7b760545bc5177eb80e4c3e22" translate="yes" xml:space="preserve">
          <source>This has the advantage that it will be saved in your &lt;code&gt;CVS/Root&lt;/code&gt; files and you don&amp;rsquo;t need to worry about always setting the correct environment variable. SSH users restricted to &lt;code&gt;git-shell&lt;/code&gt; don&amp;rsquo;t need to override the default with CVS_SERVER (and shouldn&amp;rsquo;t) as &lt;code&gt;git-shell&lt;/code&gt; understands &lt;code&gt;cvs&lt;/code&gt; to mean &lt;code&gt;git-cvsserver&lt;/code&gt; and pretends that the other end runs the real &lt;code&gt;cvs&lt;/code&gt; better.</source>
          <target state="translated">这样的好处是它将被保存在您的 &lt;code&gt;CVS/Root&lt;/code&gt; 文件中，您不必担心总是设置正确的环境变量。受限于 &lt;code&gt;git-shell&lt;/code&gt; 的 SSH用户无需使用CVS_SERVER覆盖默认值（也不应该），因为 &lt;code&gt;git-shell&lt;/code&gt; 理解 &lt;code&gt;cvs&lt;/code&gt; 意味着 &lt;code&gt;git-cvsserver&lt;/code&gt; 并假装另一端可以更好地运行真实的 &lt;code&gt;cvs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f27a3b2d1e595dbb21c1b28424b4a89305bcf439" translate="yes" xml:space="preserve">
          <source>This has two implications:</source>
          <target state="translated">这有两个含义。</target>
        </trans-unit>
        <trans-unit id="a2d38b5ae6dea81df64d435d13a5c9c9c6e43a8c" translate="yes" xml:space="preserve">
          <source>This header line is followed by the following information at least once for each commit:</source>
          <target state="translated">这个头行后面是以下信息,每次提交至少一次。</target>
        </trans-unit>
        <trans-unit id="aac19de1c954c0a5c2aba42bf1f288afbf74cabf" translate="yes" xml:space="preserve">
          <source>This helper uses specified file descriptors to connect to a remote Git server. This is not meant for end users but for programs and scripts calling git fetch, push or archive.</source>
          <target state="translated">这个帮助程序使用指定的文件描述符来连接到远程 Git 服务器。这不是为终端用户准备的,而是为调用 git fetch、push 或 archive 的程序和脚本准备的。</target>
        </trans-unit>
        <trans-unit id="eafdc2cefff4153e88df550a24ce4b00606582ea" translate="yes" xml:space="preserve">
          <source>This hook can be used in conjunction with a corresponding pre-commit hook to save and restore any form of metadata associated with the working tree (e.g.: permissions/ownership, ACLS, etc). See contrib/hooks/setgitperms.perl for an example of how to do this.</source>
          <target state="translated">这个钩子可以和相应的预提交钩子一起使用,以保存和恢复与工作树相关的任何形式的元数据(例如:权限/所有权,ACLS等)。参见 contrib/hooks/setgitperms.perl 来了解如何做到这一点。</target>
        </trans-unit>
        <trans-unit id="9fae8c19d5ced3830760d386f8db3473a746ea76" translate="yes" xml:space="preserve">
          <source>This hook can be used to perform repository validity checks, auto-display differences from the previous HEAD if different, or set working dir metadata properties.</source>
          <target state="translated">这个钩子可以用来执行版本库有效性检查,如果与之前的HEAD不同,则自动显示差异,或者设置工作dir元数据属性。</target>
        </trans-unit>
        <trans-unit id="89a247d66f7dd9fd927ac160899ee7ad4eefe257" translate="yes" xml:space="preserve">
          <source>This hook can be used to prevent &lt;code&gt;forced&lt;/code&gt; update on certain refs by making sure that the object name is a commit object that is a descendant of the commit object named by the old object name. That is, to enforce a &quot;fast-forward only&quot; policy.</source>
          <target state="translated">通过确保对象名称是作为旧对象名称命名的提交对象的后代的提交对象，可以使用该挂钩来防止对某些引用进行 &lt;code&gt;forced&lt;/code&gt; 更新。也就是说，强制执行&amp;ldquo;仅快进&amp;rdquo;策略。</target>
        </trans-unit>
        <trans-unit id="e2b4b08b5c7d529703ac2e4609fae5478174d015" translate="yes" xml:space="preserve">
          <source>This hook can be used, for example, to run &lt;code&gt;git update-server-info&lt;/code&gt; if the repository is packed and is served via a dumb transport.</source>
          <target state="translated">如果存储库已打包并通过愚蠢的传输服务，则可以使用此钩子来运行 &lt;code&gt;git update-server-info&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec8359ca4fe68868d4a094d214fa5c736b07b686" translate="yes" xml:space="preserve">
          <source>This hook does not affect the outcome of &lt;code&gt;git receive-pack&lt;/code&gt;, as it is called after the real work is done.</source>
          <target state="translated">这个钩子不会影响 &lt;code&gt;git receive-pack&lt;/code&gt; 的结果，因为它在实际工作完成后会被调用。</target>
        </trans-unit>
        <trans-unit id="4f1494681f56d1e644fae421a13f75381d1bf104" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but for each ref to be updated it receives on standard input a line of the format:</source>
          <target state="translated">这个钩子对receive操作执行一次。它不接受任何参数,但每更新一个 ref,它就会在标准输入中接收一行格式的内容。</target>
        </trans-unit>
        <trans-unit id="1c705c0b531046d9558421e4543f9aca35624390" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but gets the same information as the &lt;a href=&quot;#pre-receive&quot;&gt;&lt;em&gt;pre-receive&lt;/em&gt;&lt;/a&gt; hook does on its standard input.</source>
          <target state="translated">该挂钩执行一次以进行接收操作。它不带参数，但获得的信息与&lt;a href=&quot;#pre-receive&quot;&gt;&lt;em&gt;pre-receive&lt;/em&gt;&lt;/a&gt;钩子在其标准输入上得到的信息相同。</target>
        </trans-unit>
        <trans-unit id="98f6b796f54de07e8019b94d0f551840c498ad05" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but uses a pkt-line format protocol to communicate with &lt;code&gt;receive-pack&lt;/code&gt; to read commands, push-options and send results. In the following example for the protocol, the letter &lt;code&gt;S&lt;/code&gt; stands for &lt;code&gt;receive-pack&lt;/code&gt; and the letter &lt;code&gt;H&lt;/code&gt; stands for this hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f404b0d7afced029532dd1c0ce00c69033fa119" translate="yes" xml:space="preserve">
          <source>This hook is called before any refname is updated and before any fast-forward checks are performed.</source>
          <target state="translated">这个钩子在任何refname被更新和任何快进检查被执行之前被调用。</target>
        </trans-unit>
        <trans-unit id="6f4d4e6bc9f3d3e90e8224d9cc9d15607a5f159d" translate="yes" xml:space="preserve">
          <source>This hook is called by &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and can be used to prevent a push from taking place. The hook is called with two parameters which provide the name and location of the destination remote, if a named remote is not being used both values will be the same.</source>
          <target state="translated">这个钩子被&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;调用，可以用来防止进行推送。该挂钩由两个参数调用，这些参数提供目标远程服务器的名称和位置，如果未使用命名远程服务器，则两个值将相同。</target>
        </trans-unit>
        <trans-unit id="b761c5f63f99b7c22c6e4ca4e1bd741b6a19c509" translate="yes" xml:space="preserve">
          <source>This hook is called by &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; and can be used to prevent a branch from getting rebased. The hook may be called with one or two parameters. The first parameter is the upstream from which the series was forked. The second parameter is the branch being rebased, and is not set when rebasing the current branch.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;调用，可用于防止分支重新建立基础。可以使用一个或两个参数来调用该挂钩。第一个参数是从其派生系列的上游。第二个参数是要重新建立基础的分支，在重新建立当前分支的基础时未设置。</target>
        </trans-unit>
        <trans-unit id="fc84f5afc2cc3712fb061152c42b83b5432e2d28" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes a single parameter, the name of the file that holds the proposed commit log message. Exiting with a non-zero status causes &lt;code&gt;git am&lt;/code&gt; to abort before applying the patch.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;调用。它只有一个参数，即保存建议的提交日志消息的文件的名称。以非零状态退出会导致 &lt;code&gt;git am&lt;/code&gt; 在应用补丁之前中止。</target>
        </trans-unit>
        <trans-unit id="109f1251e93ab76b92d28a05e1f40ca3ae3e2435" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes no parameter, and is invoked after the patch is applied and a commit is made.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;调用。它不带参数，在应用补丁并进行提交之后被调用。</target>
        </trans-unit>
        <trans-unit id="31dd1042d3a6d88015bf6a789db56141bf61f664" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes no parameter, and is invoked after the patch is applied, but before a commit is made.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;调用。它不带参数，在应用补丁程序之后但在提交之前被调用。</target>
        </trans-unit>
        <trans-unit id="4126a7ec7eb0a54d9b99d1f389fd70ce96c40950" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes a single parameter, the name of the file that holds the proposed commit log message. Exiting with a non-zero status causes the command to abort.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;和&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;调用，可以使用 &lt;code&gt;--no-verify&lt;/code&gt; 选项绕过。它只有一个参数，即保存建议的提交日志消息的文件的名称。以非零状态退出会导致命令中止。</target>
        </trans-unit>
        <trans-unit id="977ece26ae3c0446a7497462b09e90162737d6ca" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; right after preparing the default log message, and before the editor is started.</source>
          <target state="translated">&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;在准备默认日志消息之后并且在启动编辑器之前立即调用此钩子。</target>
        </trans-unit>
        <trans-unit id="2ae25bad855fc10ca5e955357c713cdbb31a472c" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes no parameters, and is invoked before obtaining the proposed commit log message and making a commit. Exiting with a non-zero status from this script causes the &lt;code&gt;git commit&lt;/code&gt; command to abort before creating a commit.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;调用，可以使用 &lt;code&gt;--no-verify&lt;/code&gt; 选项绕过。它不带任何参数，并且在获取建议的提交日志消息并进行提交之前被调用。从此脚本以非零状态退出会导致 &lt;code&gt;git commit&lt;/code&gt; 命令在创建提交之前中止。</target>
        </trans-unit>
        <trans-unit id="21226463d529e8f7d5082c27401d959f905ec4d1" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;. It takes no parameters, and is invoked after a commit is made.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;调用。它不带任何参数，并在提交后被调用。</target>
        </trans-unit>
        <trans-unit id="0a4097349c79cead9de93e647cb9ba47cbed7c91" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes no parameters, and is invoked after the merge has been carried out successfully and before obtaining the proposed commit log message to make a commit. Exiting with a non-zero status from this script causes the &lt;code&gt;git merge&lt;/code&gt; command to abort before creating a commit.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;调用，可以使用 &lt;code&gt;--no-verify&lt;/code&gt; 选项绕过。它不带任何参数，并且在成功执行合并之后并在获取建议的提交日志消息以进行提交之前被调用。从此脚本以非零状态退出会导致 &lt;code&gt;git merge&lt;/code&gt; 命令在创建提交之前中止。</target>
        </trans-unit>
        <trans-unit id="de911dadfd0a4abc2b13baa4ccbc2ae0aca9f055" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, which happens when a &lt;code&gt;git pull&lt;/code&gt; is done on a local repository. The hook takes a single parameter, a status flag specifying whether or not the merge being done was a squash merge. This hook cannot affect the outcome of &lt;code&gt;git merge&lt;/code&gt; and is not executed, if the merge failed due to conflicts.</source>
          <target state="translated">该钩子由&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;调用，这是在本地存储库上执行 &lt;code&gt;git pull&lt;/code&gt; 时发生的。挂钩使用一个参数，一个状态标志，指定要进行的合并是否为壁球合并。如果合并由于冲突而失败，则此钩子不会影响 &lt;code&gt;git merge&lt;/code&gt; 的结果，因此不会执行。</target>
        </trans-unit>
        <trans-unit id="76961cafe28e294daa6f1b287a02eb4fe4bf07aa" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository, and when the push tries to update the branch that is currently checked out and the &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; configuration variable is set to &lt;code&gt;updateInstead&lt;/code&gt;. Such a push by default is refused if the working tree and the index of the remote repository has any difference from the currently checked out commit; when both the working tree and the index match the current commit, they are updated to match the newly pushed tip of the branch. This hook is to be used to override the default behaviour.</source>
          <target state="translated">当&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;对 &lt;code&gt;git push&lt;/code&gt; 作出反应并更新其存储库中的引用时，以及当push尝试更新当前已检出的分支和 &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; 配置变量时，将由git-receive-pack [1]调用此钩子。设置为 &lt;code&gt;updateInstead&lt;/code&gt; 。如果工作树和远程存储库的索引与当前检出的提交有任何区别，则默认情况下将拒绝此类推送；当工作树和索引都与当前提交匹配时，它们将被更新以与分支的新推送尖端匹配。该钩子将用于覆盖默认行为。</target>
        </trans-unit>
        <trans-unit id="5a56dac625f1205849f2b5f6e3619a708d3ea48e" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. It executes on the remote repository once after all the refs have been updated.</source>
          <target state="translated">当它对 &lt;code&gt;git push&lt;/code&gt; 做出反应并更新其存储库中的引用时，该钩子由&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;调用。所有引用均已更新后，它将在远程存储库上执行。</target>
        </trans-unit>
        <trans-unit id="390ce0821ef413eec43c389641cce2dfc9687135" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. Just before starting to update refs on the remote repository, the pre-receive hook is invoked. Its exit status determines the success or failure of the update.</source>
          <target state="translated">当它对 &lt;code&gt;git push&lt;/code&gt; 做出反应并更新其存储库中的引用时，该钩子由&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;调用。在开始更新远程存储库上的引用之前，将调用pre-receive挂钩。其退出状态确定更新的成功或失败。</target>
        </trans-unit>
        <trans-unit id="f508c67d780c6e440d114ab5a4809e8db15887c6" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. Just before updating the ref on the remote repository, the update hook is invoked. Its exit status determines the success or failure of the ref update.</source>
          <target state="translated">当它对 &lt;code&gt;git push&lt;/code&gt; 做出反应并更新其存储库中的引用时，该钩子由&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt;调用。在更新远程存储库上的ref之前，将调用更新挂钩。其退出状态确定引用更新的成功或失败。</target>
        </trans-unit>
        <trans-unit id="c165f7e2051fecf641e46f5c29ee35090d7d5f24" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;. If the server has set the multi-valued config variable &lt;code&gt;receive.procReceiveRefs&lt;/code&gt;, and the commands sent to &lt;code&gt;receive-pack&lt;/code&gt; have matching reference names, these commands will be executed by this hook, instead of by the internal &lt;code&gt;execute_commands()&lt;/code&gt; function. This hook is responsible for updating the relevant references and reporting the results back to &lt;code&gt;receive-pack&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c94fc31562e49c2e1f57905c2984b3787d6eb579" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;. It takes a single parameter, the name of the file that holds the e-mail to be sent. Exiting with a non-zero status causes &lt;code&gt;git send-email&lt;/code&gt; to abort before sending any e-mails.</source>
          <target state="translated">这个钩子由&lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt;调用。它只有一个参数，即保存要发送电子邮件的文件的名称。以非零状态退出会导致 &lt;code&gt;git send-email&lt;/code&gt; 在发送任何电子邮件之前中止。</target>
        </trans-unit>
        <trans-unit id="898dc345a1faef7e78cc6f07a48d416762cf9e72" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git gc --auto&lt;/code&gt; (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;). It takes no parameter, and exiting with non-zero status from this script causes the &lt;code&gt;git gc --auto&lt;/code&gt; to abort.</source>
          <target state="translated">该钩子由 &lt;code&gt;git gc --auto&lt;/code&gt; 调用（请参阅&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;）。它不带任何参数，并且以非零状态退出此脚本会导致 &lt;code&gt;git gc --auto&lt;/code&gt; 中止。</target>
        </trans-unit>
        <trans-unit id="536d2f256146b81297af8f05d9ee07d3c788ff56" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db96373c38bd1df6e078c9fa2b6d9e050d469bb3" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt;. It takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevent &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. It can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; command line option. Run &lt;code&gt;git-p4 submit --help&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa504b80ab7d4ab7fd02bb1c09f7267f7ffd0b87" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt;. It takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevent &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. Run &lt;code&gt;git-p4 submit --help&lt;/code&gt; for details.</source>
          <target state="translated">这个钩子由 &lt;code&gt;git-p4 submit&lt;/code&gt; 调用。它不带参数，标准输入也不带任何内容。从此脚本以非零状态退出会阻止 &lt;code&gt;git-p4 submit&lt;/code&gt; 启动。运行 &lt;code&gt;git-p4 submit --help&lt;/code&gt; 以获得详细信息。</target>
        </trans-unit>
        <trans-unit id="e343164b203dd1de0ba3f9a30c792df16e0f19da" translate="yes" xml:space="preserve">
          <source>This hook is invoked by any Git command that performs reference updates. It executes whenever a reference transaction is prepared, committed or aborted and may thus get called multiple times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8569f58a670ba9d05dfd0c2191295df64e04e73" translate="yes" xml:space="preserve">
          <source>This hook is invoked by commands that rewrite commits (&lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; when called with &lt;code&gt;--amend&lt;/code&gt; and &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;; however, full-history (re)writing tools like &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import[1]&lt;/a&gt; or &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; typically do not call it!). Its first argument denotes the command it was invoked by: currently one of &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;. Further command-dependent arguments may be passed in the future.</source>
          <target state="translated">该钩子由重写提交的命令调用（&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;用 &lt;code&gt;--amend&lt;/code&gt; 和&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;调用时；但是，完整的历史（重新）编写工具，例如&lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import [1]&lt;/a&gt;或&lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt;通常不调用它！）。它的第一个参数表示由其调用的命令：当前为 &lt;code&gt;amend&lt;/code&gt; 或 &lt;code&gt;rebase&lt;/code&gt; 之一。将来可能会传递更多与命令有关的参数。</target>
        </trans-unit>
        <trans-unit id="8c8dde02f7fe4fac23930e917fd59c1d03fbfa8b" translate="yes" xml:space="preserve">
          <source>This hook is invoked when a &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; or &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; is run after having updated the worktree. The hook is given three parameters: the ref of the previous HEAD, the ref of the new HEAD (which may or may not have changed), and a flag indicating whether the checkout was a branch checkout (changing branches, flag=1) or a file checkout (retrieving a file from the index, flag=0). This hook cannot affect the outcome of &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt;, other than that the hook&amp;rsquo;s exit status becomes the exit status of these two commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b20b75526e2af7ef8179932e884a838f68429b3" translate="yes" xml:space="preserve">
          <source>This hook is invoked when a &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; or &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; is run after having updated the worktree. The hook is given three parameters: the ref of the previous HEAD, the ref of the new HEAD (which may or may not have changed), and a flag indicating whether the checkout was a branch checkout (changing branches, flag=1) or a file checkout (retrieving a file from the index, flag=0). This hook cannot affect the outcome of &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt;.</source>
          <target state="translated">更新工作树后运行&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;或&lt;a href=&quot;git-switch&quot;&gt;git-switch [1]&lt;/a&gt;时，将调用此挂钩。挂钩具有三个参数：前一个HEAD的ref，新HEAD的ref（可能已更改，也可能未更改）和一个标志，指示签出是否为分支签出（更改分支，flag = 1）或文件检出（从索引中检索文件，标志= 0）。这个钩子不会影响 &lt;code&gt;git switch&lt;/code&gt; 或 &lt;code&gt;git checkout&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="fd3ae42761b9b86d30d029aa1493872ff1533f42" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the configuration option &lt;code&gt;core.fsmonitor&lt;/code&gt; is set to &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt; or &lt;code&gt;.git/hooks/fsmonitor-watchmanv2&lt;/code&gt; depending on the version of the hook to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0692c459d4a723afc690b678a8556c7e5d3814" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the configuration option &lt;code&gt;core.fsmonitor&lt;/code&gt; is set to &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt;. It takes two arguments, a version (currently 1) and the time in elapsed nanoseconds since midnight, January 1, 1970.</source>
          <target state="translated">当配置选项 &lt;code&gt;core.fsmonitor&lt;/code&gt; 设置为 &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt; watchman时，将调用此挂钩。它需要两个参数，一个版本（当前为1），以及自1970年1月1日午夜以来经过的时间（以纳秒为单位）。</target>
        </trans-unit>
        <trans-unit id="1ea8190ee0fad5a3aca31c578a724c322c0d57cb" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the index is written in read-cache.c do_write_locked_index.</source>
          <target state="translated">这个钩子在read-cache.c do_write_locked_index中写入索引时被调用。</target>
        </trans-unit>
        <trans-unit id="bbcd7cc3d137fc9e83cb037a7ffe28a3a104cf5b" translate="yes" xml:space="preserve">
          <source>This hook is invoked with the environment variable &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; if the command will not bring up an editor to modify the commit message.</source>
          <target state="translated">如果该命令不会调出编辑器来修改提交消息，则使用环境变量 &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; 调用此挂钩。</target>
        </trans-unit>
        <trans-unit id="ddc7ece9286909c0de44abe41d5a762b67552ed5" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">这个钩子主要用于通知，不会影响 &lt;code&gt;git am&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="448e187d53f17c70cda00f92a3ee55c4bde07472" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">这个钩子主要用于通知，不会影响 &lt;code&gt;git commit&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="08260832c28c95684a1993d7203db5c6a733006a" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git receive-pack&lt;/code&gt;.</source>
          <target state="translated">这个钩子主要用于通知，并且不会影响 &lt;code&gt;git receive-pack&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="f1b9eafafbdf014b8c082347223fc7e3e439cd3c" translate="yes" xml:space="preserve">
          <source>This implies &lt;code&gt;--revs&lt;/code&gt;. In addition to the list of revision arguments read from the standard input, pretend as if all refs under &lt;code&gt;refs/&lt;/code&gt; are specified to be included.</source>
          <target state="translated">这意味着 &lt;code&gt;--revs&lt;/code&gt; 。除了从标准输入中读取的修订参数列表之外，还假装好像已指定 &lt;code&gt;refs/&lt;/code&gt; 下的所有ref 。</target>
        </trans-unit>
        <trans-unit id="00f6fe101136dac1c604175fe5bf787266d15317" translate="yes" xml:space="preserve">
          <source>This implies &lt;code&gt;--revs&lt;/code&gt;. When processing the list of revision arguments read from the standard input, limit the objects packed to those that are not already packed.</source>
          <target state="translated">这意味着 &lt;code&gt;--revs&lt;/code&gt; 。处理从标准输入中读取的修订参数列表时，请将打包的对象限制为尚未打包的对象。</target>
        </trans-unit>
        <trans-unit id="23abf25dbec44cc1a257bc71a457bb760d4a79eb" translate="yes" xml:space="preserve">
          <source>This implies the &lt;code&gt;--topo-order&lt;/code&gt; option by default, but the &lt;code&gt;--date-order&lt;/code&gt; option may also be specified.</source>
          <target state="translated">这意味着默认情况下 &lt;code&gt;--topo-order&lt;/code&gt; 选项，但也可以指定 &lt;code&gt;--date-order&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="9bafb6d097d43ca4ccca730edb887425acfba8b5" translate="yes" xml:space="preserve">
          <source>This imports the specified depot into &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; in an existing Git repository. The &lt;code&gt;--branch&lt;/code&gt; option can be used to specify a different branch to be used for the p4 content.</source>
          <target state="translated">这会将指定的软件仓库导入到现有Git存储库中的 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; 中。该 &lt;code&gt;--branch&lt;/code&gt; 选项可用于指定不同的分支，以用于P4内容。</target>
        </trans-unit>
        <trans-unit id="5a7c7788d041aa1a2f51fc279f1f6f7da23ae666" translate="yes" xml:space="preserve">
          <source>This indicates that the helper is able to interact with the remote side using an explicit hash algorithm extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505428074ae07b004fad59f4eaeb272274ac2c6b" translate="yes" xml:space="preserve">
          <source>This information can be used to determine what commit was the tip of a branch &quot;2 days ago&quot;.</source>
          <target state="translated">这些信息可以用来确定 &quot;2天前 &quot;的分支是什么提交。</target>
        </trans-unit>
        <trans-unit id="86187244d1368864bf6af8ccb054656e32b6a58b" translate="yes" xml:space="preserve">
          <source>This instructs git svn to recode pathnames to a given encoding. It can be used by windows users and by those who work in non-utf8 locales to avoid corrupted file names with non-ASCII characters. Valid encodings are the ones supported by Perl&amp;rsquo;s Encode module.</source>
          <target state="translated">这指示git svn将路径名重新编码为给定的编码。Windows用户和在非utf8语言环境中工作的人员都可以使用它，以避免使用非ASCII字符损坏文件名。有效的编码是Perl的Encode模块支持的编码。</target>
        </trans-unit>
        <trans-unit id="956c7627c61d83f78ef967d8ba93fedd722fb328" translate="yes" xml:space="preserve">
          <source>This integer config option controls how often the &lt;code&gt;commit-graph&lt;/code&gt; task should be run as part of &lt;code&gt;git maintenance run --auto&lt;/code&gt;. If zero, then the &lt;code&gt;commit-graph&lt;/code&gt; task will not run with the &lt;code&gt;--auto&lt;/code&gt; option. A negative value will force the task to run every time. Otherwise, a positive value implies the command should run when the number of reachable commits that are not in the commit-graph file is at least the value of &lt;code&gt;maintenance.commit-graph.auto&lt;/code&gt;. The default value is 100.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64a7c2d6ae98d20c277e94177b42af973cafce0" translate="yes" xml:space="preserve">
          <source>This integer config option controls how often the &lt;code&gt;incremental-repack&lt;/code&gt; task should be run as part of &lt;code&gt;git maintenance run --auto&lt;/code&gt;. If zero, then the &lt;code&gt;incremental-repack&lt;/code&gt; task will not run with the &lt;code&gt;--auto&lt;/code&gt; option. A negative value will force the task to run every time. Otherwise, a positive value implies the command should run when the number of pack-files not in the multi-pack-index is at least the value of &lt;code&gt;maintenance.incremental-repack.auto&lt;/code&gt;. The default value is 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61993927f5b7a85ff06e34daa416caf3ce7cbe39" translate="yes" xml:space="preserve">
          <source>This integer config option controls how often the &lt;code&gt;loose-objects&lt;/code&gt; task should be run as part of &lt;code&gt;git maintenance run --auto&lt;/code&gt;. If zero, then the &lt;code&gt;loose-objects&lt;/code&gt; task will not run with the &lt;code&gt;--auto&lt;/code&gt; option. A negative value will force the task to run every time. Otherwise, a positive value implies the command should run when the number of loose objects is at least the value of &lt;code&gt;maintenance.loose-objects.auto&lt;/code&gt;. The default value is 100.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0909b4167b1b6cfc93db8cafdc74248d3901c792" translate="yes" xml:space="preserve">
          <source>This is a deprecated synonym for &lt;code&gt;repack.writeBitmaps&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; 的不赞成使用的同义词。</target>
        </trans-unit>
        <trans-unit id="0663f3ff3f5e643bb58ee19e6a44fd14680c40d5" translate="yes" xml:space="preserve">
          <source>This is a login shell for SSH accounts to provide restricted Git access. It permits execution only of server-side Git commands implementing the pull/push functionality, plus custom commands present in a subdirectory named &lt;code&gt;git-shell-commands&lt;/code&gt; in the user&amp;rsquo;s home directory.</source>
          <target state="translated">这是SSH帐户的登录外壳，用于提供受限制的Git访问。它仅允许执行实现拉/推功能的服务器端Git命令，以及用户主目录中名为 &lt;code&gt;git-shell-commands&lt;/code&gt; 的子目录中存在的自定义命令。</target>
        </trans-unit>
        <trans-unit id="bb9b1700493e02e1c42808252a2a81a90b07f06f" translate="yes" xml:space="preserve">
          <source>This is a modified recursive strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree.</source>
          <target state="translated">这是一种修改后的递归策略。在合并树A和B时,如果B对应A的子树,则首先调整B,使之与A的树结构相匹配,而不是读取同一层次的树。这种调整也是对共同祖先树进行的。</target>
        </trans-unit>
        <trans-unit id="9ebc5555eb7976dd79439890cefef50e4fca7252" translate="yes" xml:space="preserve">
          <source>This is a multi-valued variable that defines reference prefixes to match the commands in &lt;code&gt;receive-pack&lt;/code&gt;. Commands matching the prefixes will be executed by an external hook &quot;proc-receive&quot;, instead of the internal &lt;code&gt;execute_commands&lt;/code&gt; function. If this variable is not defined, the &quot;proc-receive&quot; hook will never be used, and all commands will be executed by the internal &lt;code&gt;execute_commands&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94478372a5a22fcace1286299ca604a903c0373f" translate="yes" xml:space="preserve">
          <source>This is a multi-valued variable, and an empty value can be used in a higher priority configuration file (e.g. &lt;code&gt;.git/config&lt;/code&gt; in a repository) to clear the values inherited from a lower priority configuration files (e.g. &lt;code&gt;$HOME/.gitconfig&lt;/code&gt;).</source>
          <target state="translated">这是一个多值变量，可以在较高优先级的配置文件（例如，存储库中的 &lt;code&gt;.git/config&lt;/code&gt; )中使用空值，以清除从较低优先级的配置文件（例如 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; ）继承的值。。</target>
        </trans-unit>
        <trans-unit id="9800795b0feafe785919ba7eb03d901a5af98b6d" translate="yes" xml:space="preserve">
          <source>This is a potentially &lt;em&gt;dangerous&lt;/em&gt; mode of operation. It rewrites history, which does not bode well when you published that history already. Do &lt;strong&gt;not&lt;/strong&gt; use this option unless you have read &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; carefully.</source>
          <target state="translated">这是潜在的&lt;em&gt;危险&lt;/em&gt;操作模式。它会重写历史记录，当您已经发布该历史记录时，这并不是一个好兆头。难道&lt;strong&gt;不&lt;/strong&gt;除非您已经阅读使用此选项&lt;a href=&quot;git-rebase&quot;&gt;的git-底垫[1]&lt;/a&gt;小心。</target>
        </trans-unit>
        <trans-unit id="7393bcbfeab09d874001a82423e807bb091915e9" translate="yes" xml:space="preserve">
          <source>This is a quick summary of the major commands; the previous chapters explain how these work in more detail.</source>
          <target state="translated">这是对主要命令的快速总结;前面的章节将更详细地解释这些命令如何工作。</target>
        </trans-unit>
        <trans-unit id="e6b70a1472f7c00669a56c92197ed227d5be5866" translate="yes" xml:space="preserve">
          <source>This is a shorthand for &quot;--pretty=oneline --abbrev-commit&quot; used together.</source>
          <target state="translated">这是&quot;-pretty=oneline--abbrev-commit &quot;一起使用的速记。</target>
        </trans-unit>
        <trans-unit id="18c84bcba1b16c1ac1cf14d08c1c68d27e4599a1" translate="yes" xml:space="preserve">
          <source>This is a total waste of time and effort on a filesystem that orders data writes properly, but can be useful for filesystems that do not use journalling (traditional UNIX filesystems) or that only journal metadata and not file contents (OS X&amp;rsquo;s HFS+, or Linux ext3 with &quot;data=writeback&quot;).</source>
          <target state="translated">订购正确写入数据的文件系统会浪费时间和精力，但对于不使用日志记录的文件系统（传统的UNIX文件系统）或仅记录日志元数据而不是文件内容的文件系统（OS X的HFS +或Linux）很有用ext3和&amp;ldquo; data = writeback&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="554ab63db8a74b017dac093a21d0557d821484db" translate="yes" xml:space="preserve">
          <source>This is a toy format. The current time and time zone of this system is always copied into the identity string at the time it is being created by fast-import. There is no way to specify a different time or time zone.</source>
          <target state="translated">这是一个玩具格式。在fast-import创建系统时,这个系统的当前时间和时区总是被复制到身份字符串中。没有办法指定不同的时间或时区。</target>
        </trans-unit>
        <trans-unit id="bc30d84517d5f02b55a3811eba6ffba9e6c0e4f0" translate="yes" xml:space="preserve">
          <source>This is a work in progress.</source>
          <target state="translated">这是一项正在进行中的工作。</target>
        </trans-unit>
        <trans-unit id="cdf94d586f4e34dd4d9c37fe3a3dd3a90ee94301" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;--group=committer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e77feb91313add3d7aff3491329020f7cd2b88e" translate="yes" xml:space="preserve">
          <source>This is an easy way to check out a particular version without having to make up a name for the new branch. You can still create a new branch (or tag) for this version later if you decide to.</source>
          <target state="translated">这是个简单的方法,可以在不为新分支取名的情况下检查出一个特定的版本。如果您决定为这个版本创建一个新的分支(或标签),您仍然可以在以后为其创建一个新的分支。</target>
        </trans-unit>
        <trans-unit id="86d03a90949a936d437c536daea902a3352ca567" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;rebase&lt;/code&gt; is used in a workflow that treats the history at the remote as the shared canonical one, and treats the work done on the branch you are rebasing as the third-party work to be integrated, and you are temporarily assuming the role of the keeper of the canonical history during the rebase. As the keeper of the canonical history, you need to view the history from the remote as &lt;code&gt;ours&lt;/code&gt; (i.e. &quot;our shared canonical history&quot;), while what you did on your side branch as &lt;code&gt;theirs&lt;/code&gt; (i.e. &quot;one contributor&amp;rsquo;s work on top of it&quot;).</source>
          <target state="translated">这是因为在工作流中使用了 &lt;code&gt;rebase&lt;/code&gt; ，该工作流将远程站点上的历史记录视为共享规范，并将您要重新部署的分支上完成的工作视为要集成的第三方工作，并且您暂时担当了该角色改组期间的规范历史保持者。作为规范历史的保存者，您需要从远程查看与 &lt;code&gt;ours&lt;/code&gt; 一样的历史（即&amp;ldquo;我们共享的规范历史&amp;rdquo;），而您在分支机构所做的工作就是作为 &lt;code&gt;theirs&lt;/code&gt; （即&amp;ldquo;一个贡献者的工作&amp;rdquo;）。 ）。</target>
        </trans-unit>
        <trans-unit id="95a20fc02bc3cd4094f682df1ea1f755e327d688" translate="yes" xml:space="preserve">
          <source>This is called a &lt;code&gt;hunk header&lt;/code&gt;. The &quot;TEXT&quot; portion is by default a line that begins with an alphabet, an underscore or a dollar sign; this matches what GNU &lt;code&gt;diff -p&lt;/code&gt; output uses. This default selection however is not suited for some contents, and you can use a customized pattern to make a selection.</source>
          <target state="translated">这称为 &lt;code&gt;hunk header&lt;/code&gt; 。默认情况下，&amp;ldquo; TEXT&amp;rdquo;部分是以字母，下划线或美元符号开头的行；这与GNU &lt;code&gt;diff -p&lt;/code&gt; 输出使用的匹配。但是，此默认选择不适用于某些内容，您可以使用自定义模式进行选择。</target>
        </trans-unit>
        <trans-unit id="85de32d717921314245903361d4033db93188253" translate="yes" xml:space="preserve">
          <source>This is default name of common system-wide configuration file.</source>
          <target state="translated">这是全系统通用配置文件的默认名称。</target>
        </trans-unit>
        <trans-unit id="8fabc38be889239efec56b25dba57afb3b308b5b" translate="yes" xml:space="preserve">
          <source>This is default name of fallback system-wide configuration file. This file is used only if per-instance configuration variable is not found.</source>
          <target state="translated">这是回退系统范围内配置文件的默认名称。只有在没有找到每个实例的配置变量时,才会使用该文件。</target>
        </trans-unit>
        <trans-unit id="e13cac7eff842df90d7031a70a4150ab3a8cdbc2" translate="yes" xml:space="preserve">
          <source>This is default name of per-instance configuration file. The format of this file is described above.</source>
          <target state="translated">这是每个实例配置文件的默认名称。该文件的格式如上所述。</target>
        </trans-unit>
        <trans-unit id="2ac99b50de3702f5d543e44c6b1ddc55b08d7471" translate="yes" xml:space="preserve">
          <source>This is designed to be as compact as possible.</source>
          <target state="translated">这样设计是为了尽可能的紧凑。</target>
        </trans-unit>
        <trans-unit id="2fb3b65e8bdaca2feb11f7bb139eec49acdf4051" translate="yes" xml:space="preserve">
          <source>This is done to avoid disrupting the remote-tracking branches. The end users expect these refs to stay unmoved unless they initiate a fetch. With prefetch task, however, the objects necessary to complete a later real fetch would already be obtained, so the real fetch would go faster. In the ideal case, it will just become an update to a bunch of remote-tracking branches without any object transfer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d30dfd1772dd73a7b51cd065bd14037d1044bf" translate="yes" xml:space="preserve">
          <source>This is done to prevent you from losing your work-in-progress changes, and mixing your random changes in an unrelated merge commit. To illustrate, suppose you start from what has been committed last to your repository:</source>
          <target state="translated">这样做的目的是为了防止丢失正在进行中的修改,以及将随机的修改混入不相关的合并提交中。为了说明这一点,假设你从最后提交到版本库的内容开始。</target>
        </trans-unit>
        <trans-unit id="c5483036881ec5a0c568843866e403149495194d" translate="yes" xml:space="preserve">
          <source>This is how you read a blob (actually, not only a blob, but any type of object). To know how the function &lt;code&gt;read_object_with_reference()&lt;/code&gt; actually works, find the source code for it (something like &lt;code&gt;git grep
read_object_with | grep &quot;:[a-z]&quot;&lt;/code&gt; in the Git repository), and read the source.</source>
          <target state="translated">这就是读取blob（实际上，不仅是blob，而且是任何类型的对象）的方式。要了解 &lt;code&gt;read_object_with_reference()&lt;/code&gt; 函数的实际工作方式，请找到该函数的源代码（类似于 &lt;code&gt;git grep read_object_with | grep &quot;:[a-z]&quot;&lt;/code&gt; 在Git存储库中），然后阅读源代码。</target>
        </trans-unit>
        <trans-unit id="d94f65e687e225292db2cabccebd8f5b3adaa1d5" translate="yes" xml:space="preserve">
          <source>This is ideally suited for read-only updates, i.e., pulling from Git repositories.</source>
          <target state="translated">这非常适合于只读更新,即从Git仓库中拉取。</target>
        </trans-unit>
        <trans-unit id="4f74abb17322f51c4e08c52446429282a69cbb4c" translate="yes" xml:space="preserve">
          <source>This is intended to be used by the test suite only. It allows to force the version for the generated pack index, and to force 64-bit index entries on objects located above the given offset.</source>
          <target state="translated">这仅用于测试套件。它允许强制生成包索引的版本,并强制位于给定偏移量以上的对象的64位索引条目。</target>
        </trans-unit>
        <trans-unit id="8180429180a5d33dfa16e7d2805d2ac9f53f061d" translate="yes" xml:space="preserve">
          <source>This is just to get you into the groove for the most libified part of Git: the revision walker.</source>
          <target state="translated">这只是为了让你进入Git最解放的部分:修订行者。</target>
        </trans-unit>
        <trans-unit id="dce30f3fbb0be29025f159d55505215087cce86b" translate="yes" xml:space="preserve">
          <source>This is known to &lt;code&gt;range-diff&lt;/code&gt; as &quot;dual coloring&quot;. Use &lt;code&gt;--no-dual-color&lt;/code&gt; to revert to color all lines according to the outer diff markers (and completely ignore the inner diff when it comes to color).</source>
          <target state="translated">这是已知的 &lt;code&gt;range-diff&lt;/code&gt; &amp;ldquo;双重着色&amp;rdquo;。使用 &lt;code&gt;--no-dual-color&lt;/code&gt; 可以根据外部差异标记对所有行进行着色（在涉及颜色时完全忽略内部差异）。</target>
        </trans-unit>
        <trans-unit id="51ecbd5eaeeeee461a4969f3b0cb27dc975ebc23" translate="yes" xml:space="preserve">
          <source>This is made much worse if many files have to be fixed to resolve conflicts. That&amp;rsquo;s why such merges are called &quot;evil merges&quot;. They can make regressions very difficult to track down. It can even be misleading to know the first bad commit if it happens to be such a merge, because people might think that the bug comes from bad conflict resolution when it comes from a semantic change in one branch.</source>
          <target state="translated">如果必须修复许多文件以解决冲突，则情况将更加糟糕。这就是为什么这种合并称为&amp;ldquo;邪恶合并&amp;rdquo;的原因。它们可能使回归非常难以追踪。如果碰巧是这样的合并，那么知道第一个错误的提交甚至可能会产生误导，因为人们可能会认为该错误来自错误的冲突解决，而该错​​误来自一个分支中的语义更改。</target>
        </trans-unit>
        <trans-unit id="2742189647afc1dbda2e1e2ecc6c9303cbb2d70b" translate="yes" xml:space="preserve">
          <source>This is meant to be used by higher level scripts to compute merge results outside of the index, and stuff the results back into the index. For this reason, the output from the command omits entries that match the &amp;lt;branch1&amp;gt; tree.</source>
          <target state="translated">这意味着更高级别的脚本将使用它来计算索引之外的合并结果，并将结果填充回索引中。因此，命令的输出将省略与&amp;lt;branch1&amp;gt;树匹配的条目。</target>
        </trans-unit>
        <trans-unit id="9ccf843e585a34e60ae505f61685a10813c9c88a" translate="yes" xml:space="preserve">
          <source>This is most often done when you remembered what you just committed is incomplete, or you misspelled your commit message, or both. Leaves working tree as it was before &quot;reset&quot;.</source>
          <target state="translated">最常见的情况是,当你想起刚刚提交的内容不完整,或者你拼错了提交信息,或者两者都有。让工作树保持 &quot;重置 &quot;前的状态。</target>
        </trans-unit>
        <trans-unit id="efff48b2c5bed4c5ab6435b6d058280a53664967" translate="yes" xml:space="preserve">
          <source>This is not a command the end user would want to run. Ever. This documentation is meant for people who are studying the Porcelain-ish scripts and/or are writing new ones.</source>
          <target state="translated">这不是一个终端用户想要运行的命令。永远不会。这篇文档是为那些正在研究瓷器类脚本和/或正在编写新脚本的人准备的。</target>
        </trans-unit>
        <trans-unit id="1a7ca68cf192059586c364ba5f318ecdbeb3a963" translate="yes" xml:space="preserve">
          <source>This is not a command the end user would want to run. Ever. This documentation is meant for people who are studying the plumbing scripts and/or are writing new ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9e09ba77ce1340a426d6ae669add42a4fe4542" translate="yes" xml:space="preserve">
          <source>This is not a real filter executed for each commit but a one time setup just before the loop. Therefore no commit-specific variables are defined yet. Functions or variables defined here can be used or modified in the following filter steps except the commit filter, for technical reasons.</source>
          <target state="translated">这不是为每次提交执行的真正的过滤器,而是在循环之前的一次性设置。因此,目前还没有定义针对提交的变量。由于技术原因,这里定义的函数或变量可以在下面的过滤步骤中使用或修改,但提交过滤除外。</target>
        </trans-unit>
        <trans-unit id="ad1d1c10cd51125ef48d021d8c7283be0413a66d" translate="yes" xml:space="preserve">
          <source>This is not hard to understand, as soon as you realize that Git simply never knows (or cares) about files that it is not told about explicitly. Git will never go &lt;strong&gt;looking&lt;/strong&gt; for files to compare, it expects you to tell it what the files are, and that&amp;rsquo;s what the index is there for.</source>
          <target state="translated">这一点并不难理解，只要您意识到Git根本就不知道（或关心）没有明确告知它的文件。Git永远不会&lt;strong&gt;寻找&lt;/strong&gt;要比较的文件，它希望您告诉它文件是什么，这就是索引的用途。</target>
        </trans-unit>
        <trans-unit id="0273358cae89a5a683cca4bca340f2d1ab3cc600" translate="yes" xml:space="preserve">
          <source>This is only used by git-completion.bash to add or remove commands from the list of completed commands. Normally only porcelain commands and a few select others are completed. You can add more commands, separated by space, in this variable. Prefixing the command with &lt;code&gt;-&lt;/code&gt; will remove it from the existing list.</source>
          <target state="translated">git-completion.bash仅使用它从已完成的命令列表中添加或删除命令。通常，仅完成瓷器命令和一些其他命令。您可以在此变量中添加更多命令，以空格分隔。在命令前面加上 &lt;code&gt;-&lt;/code&gt; 会将其从现有列表中删除。</target>
        </trans-unit>
        <trans-unit id="fcaf558e1ca35a6c93dcb363081455cef6ced8a0" translate="yes" xml:space="preserve">
          <source>This is only valid for &amp;lt;end&amp;gt; and will specify a number of lines before or after the line given by &amp;lt;start&amp;gt;.</source>
          <target state="translated">这仅对&amp;lt;end&amp;gt;有效，并将在&amp;lt;start&amp;gt;给定的行之前或之后指定多行。</target>
        </trans-unit>
        <trans-unit id="3d1897f588ce3866d7bd11a61c4f52eb7dec72ee" translate="yes" xml:space="preserve">
          <source>This is only valid for &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; and will specify a number of lines before or after the line given by &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0501180252ff128dca83458515deca695a7ecc" translate="yes" xml:space="preserve">
          <source>This is optional and is only searched when &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; is present in $GIT_DIR/config.</source>
          <target state="translated">这是可选的，仅当$ GIT_DIR / config中存在 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 时才搜索。</target>
        </trans-unit>
        <trans-unit id="4306207006bf4fdd2134f4efea5f0d698d2c1f81" translate="yes" xml:space="preserve">
          <source>This is particularly true when passing in diff options. Currently some options like &lt;code&gt;--stat&lt;/code&gt; can, as an emergent effect, produce output that&amp;rsquo;s quite useless in the context of &lt;code&gt;range-diff&lt;/code&gt;. Future versions of &lt;code&gt;range-diff&lt;/code&gt; may learn to interpret such options in a manner specific to &lt;code&gt;range-diff&lt;/code&gt; (e.g. for &lt;code&gt;--stat&lt;/code&gt; producing human-readable output which summarizes how the diffstat changed).</source>
          <target state="translated">当传递diff选项时尤其如此。目前，诸如 &lt;code&gt;--stat&lt;/code&gt; 之类的一些选项作为一种紧急效果可以产生在 &lt;code&gt;range-diff&lt;/code&gt; 上下文中非常无用的输出。未来版本的 &lt;code&gt;range-diff&lt;/code&gt; 可能会学习以特定于 &lt;code&gt;range-diff&lt;/code&gt; 的方式来解释此类选项（例如，用于 &lt;code&gt;--stat&lt;/code&gt; 产生人类可读的输出，其中总结了diffstat的变化）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
