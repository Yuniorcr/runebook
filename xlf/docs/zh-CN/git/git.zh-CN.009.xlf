<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="a8fe9598336f37cb9328ca8052e59b151a7933de" translate="yes" xml:space="preserve">
          <source>Text viewer for use by Git commands (e.g., &lt;code&gt;less&lt;/code&gt;). The value is meant to be interpreted by the shell. The order of preference is the &lt;code&gt;$GIT_PAGER&lt;/code&gt; environment variable, then &lt;code&gt;core.pager&lt;/code&gt; configuration, then &lt;code&gt;$PAGER&lt;/code&gt;, and then the default chosen at compile time (usually &lt;code&gt;less&lt;/code&gt;).</source>
          <target state="translated">Git命令使用的文本查看器（例如， &lt;code&gt;less&lt;/code&gt; ）。该值应由外壳解释。优先顺序是 &lt;code&gt;$GIT_PAGER&lt;/code&gt; 环境变量，然后是 &lt;code&gt;core.pager&lt;/code&gt; 配置，然后是 &lt;code&gt;$PAGER&lt;/code&gt; ，然后是在编译时选择的默认值（通常 &lt;code&gt;less&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0bd1b0b7ad0ea4fe7d508b463e4e610ef00887b1" translate="yes" xml:space="preserve">
          <source>That is, a pattern followed by an attributes list, separated by whitespaces. Leading and trailing whitespaces are ignored. Lines that begin with &lt;code&gt;#&lt;/code&gt; are ignored. Patterns that begin with a double quote are quoted in C style. When the pattern matches the path in question, the attributes listed on the line are given to the path.</source>
          <target state="translated">也就是说，模式后面是属性列表，由空格隔开。前导和尾随空格将被忽略。以 &lt;code&gt;#&lt;/code&gt; 开头的行将被忽略。以双引号开头的模式以C样式引用。当模式与所讨论的路径匹配时，将在行上列出的属性赋予该路径。</target>
        </trans-unit>
        <trans-unit id="a2ed6bb3b9b6e451ccc6f660ef58cfb1d5aab73c" translate="yes" xml:space="preserve">
          <source>That is, from left to right:</source>
          <target state="translated">就是说,从左到右。</target>
        </trans-unit>
        <trans-unit id="8f093c96f9e4fd62eb55be18fd622f6079c4aad2" translate="yes" xml:space="preserve">
          <source>That is, from the left to the right:</source>
          <target state="translated">就是说,从左边到右边。</target>
        </trans-unit>
        <trans-unit id="11e8a09abfceb997eddb8423e1781ebd95db28e7" translate="yes" xml:space="preserve">
          <source>That is:</source>
          <target state="translated">那就是:</target>
        </trans-unit>
        <trans-unit id="aa54aa26ef67ef77a7b5a4203a2f21478483f336" translate="yes" xml:space="preserve">
          <source>That means that even if you offer only read access (e.g. by using the pserver method), &lt;code&gt;git-cvsserver&lt;/code&gt; should have write access to the database to work reliably (otherwise you need to make sure that the database is up to date any time &lt;code&gt;git-cvsserver&lt;/code&gt; is executed).</source>
          <target state="translated">这意味着，即使你（通过使用pserver的方法如）提供只读访问， &lt;code&gt;git-cvsserver&lt;/code&gt; 应该具有对数据库的工作可靠的写权限（否则你需要确保数据库是最新的任何时间 &lt;code&gt;git-cvsserver&lt;/code&gt; 已执行）。</target>
        </trans-unit>
        <trans-unit id="452813997abf32b7a81b495ef3287ae8cfa66246" translate="yes" xml:space="preserve">
          <source>That means that if you do a &lt;code&gt;git read-tree -m &amp;lt;newtree&amp;gt;&lt;/code&gt; followed by a &lt;code&gt;git checkout-index -f -u -a&lt;/code&gt;, the &lt;code&gt;git checkout-index&lt;/code&gt; only checks out the stuff that really changed.</source>
          <target state="translated">这意味着，如果您执行 &lt;code&gt;git read-tree -m &amp;lt;newtree&amp;gt;&lt;/code&gt; 后接 &lt;code&gt;git checkout-index -f -u -a&lt;/code&gt; ，则 &lt;code&gt;git checkout-index&lt;/code&gt; 仅签出真正更改的内容。</target>
        </trans-unit>
        <trans-unit id="a1aaaec20914cfb53973b0431f384394f0c406ca" translate="yes" xml:space="preserve">
          <source>That puts the heads and tags for each fork in their own island (named &quot;1234&quot; or similar), and the pull refs for each go into their own &quot;1234-pull&quot;.</source>
          <target state="translated">这样就把每个分叉的头和标签放在自己的岛中(命名为 &quot;1234 &quot;或类似的),而每个分叉的拉动参考则进入自己的 &quot;1234-pull&quot;。</target>
        </trans-unit>
        <trans-unit id="767670eb6ab18d660b358046eb00166f0a64fef3" translate="yes" xml:space="preserve">
          <source>That will produce the diff between the tips of the two branches. If you&amp;rsquo;d prefer to find the diff from their common ancestor to test, you can use three dots instead of two:</source>
          <target state="translated">这将在两个分支的尖端之间产生差异。如果您希望从他们的共同祖先找到差异进行测试，则可以使用三个点而不是两个点：</target>
        </trans-unit>
        <trans-unit id="2ab4548e0b841bbace5e0a92c23778ab654224e3" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why the &quot;git replace&quot; command was created. Technically it stores replacements &quot;refs&quot; in the &quot;refs/replace/&quot; hierarchy. These &quot;refs&quot; are like branches (that are stored in &quot;refs/heads/&quot;) or tags (that are stored in &quot;refs/tags&quot;), and that means that they can automatically be shared like branches or tags among developers.</source>
          <target state="translated">这就是创建&amp;ldquo; git replace&amp;rdquo;命令的原因。从技术上讲，它将替换&amp;ldquo; refs&amp;rdquo;存储在&amp;ldquo; refs / replace /&amp;rdquo;层次结构中。这些&amp;ldquo;引用&amp;rdquo;就像分支（存储在&amp;ldquo; refs / heads /&amp;rdquo;中）或标签（存储在&amp;ldquo; refs / tags&amp;rdquo;中）一样，这意味着它们可以像分支或标签一样在开发人员之间自动共享。</target>
        </trans-unit>
        <trans-unit id="e7f78784e12fead6a14f302d919d7dfe2a02b05b" translate="yes" xml:space="preserve">
          <source>The &quot;child_class&quot; field is a rough classification, such as &quot;editor&quot;, &quot;pager&quot;, &quot;transport/*&quot;, and &quot;hook&quot;. Unclassified children are classified with &quot;?&quot;.</source>
          <target state="translated">&quot;child_class &quot;字段是一个粗略的分类,如 &quot;editor&quot;、&quot;pager&quot;、&quot;transport/*&quot;、&quot;hook &quot;等。未分类的孩子用&quot;?&quot;来分类。</target>
        </trans-unit>
        <trans-unit id="fe5496d60fae83b54bfa30bb265cd284e395a597" translate="yes" xml:space="preserve">
          <source>The &quot;child_id&quot; field can be used to match this child_start with the corresponding child_exit event.</source>
          <target state="translated">&quot;child_id &quot;字段可以用来匹配这个child_start和相应的child_exit事件。</target>
        </trans-unit>
        <trans-unit id="2ee1a593683be8a9c62bf7139373ea713a6461c3" translate="yes" xml:space="preserve">
          <source>The &quot;commit&quot; object links a physical state of a tree with a description of how we got there and why. Use the &lt;code&gt;--pretty=raw&lt;/code&gt; option to &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; or &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; to examine your favorite commit:</source>
          <target state="translated">&amp;ldquo;提交&amp;rdquo;对象将一棵树的物理状态与我们如何到达那里以及为什么的描述联系起来。使用 &lt;code&gt;--pretty=raw&lt;/code&gt; 选项在&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;或&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;中检查您喜欢的提交：</target>
        </trans-unit>
        <trans-unit id="6db6601ce62b96f9f8fba54efac9ee5967a731f4" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; value consists of a list of triplets in the form &lt;code&gt;(&quot;&amp;lt;label&amp;gt;&quot;, &quot;&amp;lt;link&amp;gt;&quot;, &quot;&amp;lt;position&amp;gt;&quot;)&lt;/code&gt; where &quot;position&quot; is the label after which to insert the link, &quot;link&quot; is a format string where &lt;code&gt;%n&lt;/code&gt; expands to the project name, &lt;code&gt;%f&lt;/code&gt; to the project path within the filesystem (i.e. &quot;$projectroot/$project&quot;), &lt;code&gt;%h&lt;/code&gt; to the current hash ('h' gitweb parameter) and &lt;code&gt;%b&lt;/code&gt; to the current hash base ('hb' gitweb parameter); &lt;code&gt;%%&lt;/code&gt; expands to '%'.</source>
          <target state="translated">&amp;ldquo;默认&amp;rdquo;值由格式 &lt;code&gt;(&quot;&amp;lt;label&amp;gt;&quot;, &quot;&amp;lt;link&amp;gt;&quot;, &quot;&amp;lt;position&amp;gt;&quot;)&lt;/code&gt; 的三元组列表组成，其中&amp;ldquo;位置&amp;rdquo;是插入链接的标签，&amp;ldquo;链接&amp;rdquo;是一个格式字符串，其中 &lt;code&gt;%n&lt;/code&gt; 扩展为项目名称， &lt;code&gt;%f&lt;/code&gt; 为文件系统内的项目路径（即&amp;ldquo; $ projectroot / $ project&amp;rdquo;）， &lt;code&gt;%h&lt;/code&gt; 为当前哈希（'h'gitweb参数）， &lt;code&gt;%b&lt;/code&gt; 为当前的哈希库（'hb'gitweb参数）； &lt;code&gt;%%&lt;/code&gt; 扩展为'％'。</target>
        </trans-unit>
        <trans-unit id="a92a8477d5d97d17f1c481b90522235992b0aec5" translate="yes" xml:space="preserve">
          <source>The &quot;delete&quot; subcommand deletes single entries from the reflog. Its argument must be an &lt;code&gt;exact&lt;/code&gt; entry (e.g. &quot;&lt;code&gt;git reflog delete
master@{2}&lt;/code&gt;&quot;). This subcommand is also typically not used directly by end users.</source>
          <target state="translated">&amp;ldquo;删除&amp;rdquo;子命令从引用日志中删除单个条目。它的参数必须是一个 &lt;code&gt;exact&lt;/code&gt; 条目（例如&amp;ldquo; &lt;code&gt;git reflog delete master@{2}&lt;/code&gt; &amp;rdquo;）。最终用户通常也不会直接使用此子命令。</target>
        </trans-unit>
        <trans-unit id="15cc724d6cfbdaca681c81ec6b39527ea7ba3e75" translate="yes" xml:space="preserve">
          <source>The &quot;downwards graduation&quot; discussed above cannot be done by actually merging downwards, however, since that would merge &lt;code&gt;all&lt;/code&gt; changes on the unstable branch into the stable one. Hence the following:</source>
          <target state="translated">上面讨论的&amp;ldquo;向下分级&amp;rdquo;不能通过实际向下合并来完成，但是，因为那样会将不稳定分支上的 &lt;code&gt;all&lt;/code&gt; 更改合并到稳定分支中。因此，以下内容：</target>
        </trans-unit>
        <trans-unit id="4b681909e4d1085f8faa13044f43a355b4e9ca0a" translate="yes" xml:space="preserve">
          <source>The &quot;exec&quot; command launches the command in a shell (the one specified in &lt;code&gt;$SHELL&lt;/code&gt;, or the default shell if &lt;code&gt;$SHELL&lt;/code&gt; is not set), so you can use shell features (like &quot;cd&quot;, &quot;&amp;gt;&quot;, &quot;;&quot; &amp;hellip;​). The command is run from the root of the working tree.</source>
          <target state="translated">&amp;ldquo; exec&amp;rdquo;命令在外壳程序（ &lt;code&gt;$SHELL&lt;/code&gt; 指定的命令，如果未设置 &lt;code&gt;$SHELL&lt;/code&gt; 则为默认外壳程序）中启动命令，因此您可以使用外壳程序功能（如&amp;ldquo; cd&amp;rdquo;，&amp;ldquo;&amp;ldquo;&amp;gt;&amp;rdquo;，&amp;ldquo;;&amp;rdquo;） ......）该命令从工作树的根目录运行。</target>
        </trans-unit>
        <trans-unit id="3e27bb28ac33a3ed0da91ec19b0543d1741f2754" translate="yes" xml:space="preserve">
          <source>The &quot;exec_id&quot; field is a command-unique id and is only useful if the &lt;code&gt;exec()&lt;/code&gt; fails and a corresponding exec_result event is generated.</source>
          <target state="translated">&amp;ldquo; exec_id&amp;rdquo;字段是命令唯一的ID，仅在 &lt;code&gt;exec()&lt;/code&gt; 失败并且生成了相应的exec_result事件时才有用。</target>
        </trans-unit>
        <trans-unit id="111dec81403753e6a7d49025386f92b4f5a7ce80" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; subcommand checks whether a ref has a reflog. It exits with zero status if the reflog exists, and non-zero status if it does not.</source>
          <target state="translated">存在 &quot;子命令用于检查一个 ref 是否有 reflog,如果 reflog 存在,则以零状态退出,如果不存在,则以非零状态退出。如果reflog存在,则以零状态退出,如果不存在,则以非零状态退出。</target>
        </trans-unit>
        <trans-unit id="b084a3a2964fff409a1c4bd5eaf3ff2af985bb46" translate="yes" xml:space="preserve">
          <source>The &quot;experimental&quot; branch is the one you just created, and the &quot;master&quot; branch is a default branch that was created for you automatically. The asterisk marks the branch you are currently on; type</source>
          <target state="translated">实验 &quot;分支是您刚刚创建的分支,&quot;主 &quot;分支是自动为您创建的默认分支。星号表示你目前所在的分支,输入</target>
        </trans-unit>
        <trans-unit id="8a5c55e5646a8a6620c2e2207d5f34af5eadc4f2" translate="yes" xml:space="preserve">
          <source>The &quot;expire&quot; subcommand prunes older reflog entries. Entries older than &lt;code&gt;expire&lt;/code&gt; time, or entries older than &lt;code&gt;expire-unreachable&lt;/code&gt; time and not reachable from the current tip, are removed from the reflog. This is typically not used directly by end users &amp;mdash; instead, see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; expire&amp;rdquo;子命令修剪较旧的引用日志条目。早于 &lt;code&gt;expire&lt;/code&gt; 时间的条目，或早于 &lt;code&gt;expire-unreachable&lt;/code&gt; 时间且无法从当前提示访问的条目，都将从reflog中删除。最终用户通常不直接使用它，而是参见&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51ddfbdb206861a134ce9d36a0cd6f8dcb912a92" translate="yes" xml:space="preserve">
          <source>The &quot;extent of changes&quot; parameter can be tweaked from the default 80% (that is, unless more than 80% of the original material is deleted, the broken pairs are merged back into a single modification) by giving a second number to -B option, like these:</source>
          <target state="translated">&quot;修改范围 &quot;参数可以从默认的80%(也就是除非删除超过80%的原始材料,否则破损的对子会被合并回一个修改),通过给-B选项赋予第二个数字来调整,比如这些。</target>
        </trans-unit>
        <trans-unit id="4be913eb74285fc0f11c845775de3706d8e8ac4f" translate="yes" xml:space="preserve">
          <source>The &quot;git-diff-tree&quot; command begins its output by printing the hash of what is being compared. After that, all the commands print one output line per changed file.</source>
          <target state="translated">&quot;git-diff-tree &quot;命令的输出首先是打印正在比较的内容的哈希值。之后,所有的命令都是每修改一个文件打印一行输出。</target>
        </trans-unit>
        <trans-unit id="14e841537fdff67ebd6d58e11774065ab0f0ebfa" translate="yes" xml:space="preserve">
          <source>The &quot;indent&quot; filter is well-behaved in this regard: it will not modify input that is already correctly indented. In this case, the lack of a smudge filter means that the clean filter &lt;code&gt;must&lt;/code&gt; accept its own output without modifying it.</source>
          <target state="translated">&amp;ldquo;缩进&amp;rdquo;过滤器在这方面表现良好：它不会修改已经正确缩进的输入。在这种情况下，缺少污迹过滤器意味着干净的过滤器 &lt;code&gt;must&lt;/code&gt; 接受其自身的输出而不进行修改。</target>
        </trans-unit>
        <trans-unit id="2a9f18fc49cc181471bfbc97a47a88e9bcc1179f" translate="yes" xml:space="preserve">
          <source>The &quot;index&quot; holds a snapshot of the content of the working tree, and it is this snapshot that is taken as the contents of the next commit. Thus after making any changes to the working tree, and before running the commit command, you must use the &lt;code&gt;add&lt;/code&gt; command to add any new or modified files to the index.</source>
          <target state="translated">&amp;ldquo;索引&amp;rdquo;保存着工作树内容的快照，正是该快照被用作下一次提交的内容。因此，在对工作树进行任何更改之后，并且在运行commit命令之前，必须使用 &lt;code&gt;add&lt;/code&gt; 命令将所有新文件或修改过的文件添加到索引中。</target>
        </trans-unit>
        <trans-unit id="6b5b86b50febe55839cf4e73fade50a78b6b0a0e" translate="yes" xml:space="preserve">
          <source>The &quot;master&quot; branch that was created at the time you cloned is a copy of the HEAD in the repository that you cloned from. That repository may also have had other branches, though, and your local repository keeps branches which track each of those remote branches, called remote-tracking branches, which you can view using the &lt;code&gt;-r&lt;/code&gt; option to &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;:</source>
          <target state="translated">克隆时创建的&amp;ldquo; master&amp;rdquo;分支是克隆源中HEAD的副本。但是，该存储库可能还具有其他分支，并且本地存储库保留跟踪每个远程分支的分支，称为远程跟踪分支，您可以使用&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;的 &lt;code&gt;-r&lt;/code&gt; 选项进行查看：</target>
        </trans-unit>
        <trans-unit id="b0e05ae2162ea2794c2d7383fd67bd0eb622aa45" translate="yes" xml:space="preserve">
          <source>The &quot;name&quot; field is an arbitrary string to describe the command mode. For example, checkout can checkout a branch or an individual file. And these variations typically have different performance characteristics that are not comparable.</source>
          <target state="translated">&quot;name &quot;字段是一个任意的字符串,用来描述命令模式。例如,checkout可以检查一个分支或单个文件。而这些变化通常具有不同的性能特点,没有可比性。</target>
        </trans-unit>
        <trans-unit id="dd5002fa5ace7f79f3506e0a4b77fdeff5bda038" translate="yes" xml:space="preserve">
          <source>The &quot;non-cached&quot; mode takes a different approach, and is potentially the more useful of the two in that what it does can&amp;rsquo;t be emulated with a &lt;code&gt;git write-tree&lt;/code&gt; + &lt;code&gt;git diff-tree&lt;/code&gt;. Thus that&amp;rsquo;s the default mode. The non-cached version asks the question:</source>
          <target state="translated">&amp;ldquo;非缓存&amp;rdquo;模式采用了不同的方法，并且可能在两者中更有用，因为它不能用 &lt;code&gt;git write-tree&lt;/code&gt; + &lt;code&gt;git diff-tree&lt;/code&gt; 来模拟。因此，这是默认模式。非缓存版本会提出以下问题：</target>
        </trans-unit>
        <trans-unit id="fb600e178320a3e93fbf20a6c6f69b12e2843e17" translate="yes" xml:space="preserve">
          <source>The &quot;pull&quot; command thus performs two operations: it fetches changes from a remote branch, then merges them into the current branch.</source>
          <target state="translated">因此,&quot;pull &quot;命令执行两个操作:它从远程分支获取变更,然后将它们合并到当前分支。</target>
        </trans-unit>
        <trans-unit id="70b3edc9504f2665b7793306c4b0a620ef20dadb" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository that is destination of a push operation. This parameter can be either a URL (see the section &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; below) or the name of a remote (see the section &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; below).</source>
          <target state="translated">作为推送操作目标的&amp;ldquo;远程&amp;rdquo;存储库。此参数可以是URL（请参阅下面的&lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt;部分）或遥控器的名称（请参见下面的&lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt;部分）。</target>
        </trans-unit>
        <trans-unit id="0610be2d46404a8f9561c2512c45bc2650bc2b77" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository that is the source of a fetch or pull operation. This parameter can be either a URL (see the section &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; below) or the name of a remote (see the section &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; below).</source>
          <target state="translated">作为提取或拉取操作来源的&amp;ldquo;远程&amp;rdquo;存储库。此参数可以是URL（请参阅下面的&lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt;部分）或遥控器的名称（请参见下面的&lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt;部分）。</target>
        </trans-unit>
        <trans-unit id="672e385879e10047919cb534a388204453fa9b9b" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository to query. This parameter can be either a URL or the name of a remote (see the GIT URLS and REMOTES sections of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">要查询的&amp;ldquo;远程&amp;rdquo;存储库。此参数可以是URL或远程名称（请参阅&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;的GIT URLS和REMOTES部分）。</target>
        </trans-unit>
        <trans-unit id="c6967bbb137406cb4cb1860aeca604a66e63b551" translate="yes" xml:space="preserve">
          <source>The &quot;show&quot; subcommand (which is also the default, in the absence of any subcommands) shows the log of the reference provided in the command-line (or &lt;code&gt;HEAD&lt;/code&gt;, by default). The reflog covers all recent actions, and in addition the &lt;code&gt;HEAD&lt;/code&gt; reflog records branch switching. &lt;code&gt;git reflog show&lt;/code&gt; is an alias for &lt;code&gt;git log -g --abbrev-commit
--pretty=oneline&lt;/code&gt;; see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for more information.</source>
          <target state="translated">&amp;ldquo; show&amp;rdquo;子命令（在没有任何子命令的情况下也是默认值）显示命令行（默认为 &lt;code&gt;HEAD&lt;/code&gt; ）中提供的引用的日志。刷新日志涵盖了所有最近的操作，此外， &lt;code&gt;HEAD&lt;/code&gt; 刷新日志还记录了分支切换。 &lt;code&gt;git reflog show&lt;/code&gt; 是 &lt;code&gt;git log -g --abbrev-commit --pretty=oneline&lt;/code&gt; 的别名；有关更多信息，请参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f44e4ac17ec1a545f86623659c266196a2646a2" translate="yes" xml:space="preserve">
          <source>The &quot;status&quot; command is a useful way to get a quick summary of the situation:</source>
          <target state="translated">&quot;状态 &quot;命令是快速了解情况的有用方法。</target>
        </trans-unit>
        <trans-unit id="97877392fd9cfcae446bf7fdee6a5be7af0d7e1e" translate="yes" xml:space="preserve">
          <source>The &quot;tar.gz&quot; and &quot;tgz&quot; formats are defined automatically and default to &lt;code&gt;gzip -cn&lt;/code&gt;. You may override them with custom commands.</source>
          <target state="translated">&amp;ldquo; tar.gz&amp;rdquo;和&amp;ldquo; tgz&amp;rdquo;格式是自动定义的，默认为 &lt;code&gt;gzip -cn&lt;/code&gt; 。您可以使用自定义命令覆盖它们。</target>
        </trans-unit>
        <trans-unit id="de5a671425f0a835fc1aa7cc9c82d529d93b1856" translate="yes" xml:space="preserve">
          <source>The &quot;tree&quot; object here refers to the new state of the tree:</source>
          <target state="translated">这里的 &quot;树 &quot;对象指的是树的新状态。</target>
        </trans-unit>
        <trans-unit id="e01253337b76bf7642cbcef035c48eb0188a2f7d" translate="yes" xml:space="preserve">
          <source>The &quot;value&quot; field may be an integer or a string.</source>
          <target state="translated">值 &quot;字段可以是一个整数或字符串。</target>
        </trans-unit>
        <trans-unit id="38b8f4a1de6f86897b3e2a50acc4b0dda41fe280" translate="yes" xml:space="preserve">
          <source>The &amp;lt;dataref&amp;gt; represents the blob, tree, or commit object at &amp;lt;path&amp;gt; and can be used in later &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;cat-blob&lt;/code&gt;, &lt;code&gt;filemodify&lt;/code&gt;, or &lt;code&gt;ls&lt;/code&gt; commands.</source>
          <target state="translated">&amp;lt;dataref&amp;gt;表示&amp;lt;path&amp;gt;处的blob，tree或commit对象，可以在以后的 &lt;code&gt;get-mark&lt;/code&gt; ， &lt;code&gt;cat-blob&lt;/code&gt; ， &lt;code&gt;filemodify&lt;/code&gt; 或 &lt;code&gt;ls&lt;/code&gt; 命令中使用。</target>
        </trans-unit>
        <trans-unit id="118ecd88d0a05a5c1cb4a877b8fac543b0b9ad8d" translate="yes" xml:space="preserve">
          <source>The &amp;lt;dst&amp;gt; tells which ref on the remote side is updated with this push. Arbitrary expressions cannot be used here, an actual ref must be named. If &lt;code&gt;git push [&amp;lt;repository&amp;gt;]&lt;/code&gt; without any &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; argument is set to update some ref at the destination with &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; with &lt;code&gt;remote.&amp;lt;repository&amp;gt;.push&lt;/code&gt; configuration variable, &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; part can be omitted&amp;mdash;​such a push will update a ref that &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; normally updates without any &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; on the command line. Otherwise, missing &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; means to update the same ref as the &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;dst&amp;gt;告知通过此推送更新远程端的哪个引用。此处不能使用任意表达式，必须命名实际引用。如果 &lt;code&gt;git push [&amp;lt;repository&amp;gt;]&lt;/code&gt; 不带任何 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 参数的git push [&amp;lt;repository&amp;gt;]设置为使用带有 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.push&lt;/code&gt; 配置变量的 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 更新目标处的某些ref，则可以省略 &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; 部分-这样push将更新 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 通常不会在命令行上添加任何 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 的引用。否则，缺少 &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; 意味着要更新与 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 相同的引用。</target>
        </trans-unit>
        <trans-unit id="a11f746174b65907575be3c7e94b2869a6db53ed" translate="yes" xml:space="preserve">
          <source>The &amp;lt;feature&amp;gt; part of the command may be any one of the following:</source>
          <target state="translated">命令的&amp;lt;feature&amp;gt;部分可以是以下任意一项：</target>
        </trans-unit>
        <trans-unit id="12c10723a00c71e41369dc4ab439f9bc656fc9a7" translate="yes" xml:space="preserve">
          <source>The &amp;lt;file&amp;gt; list given to the command can be exact pathnames, file glob patterns, or leading directory names. The command removes only the paths that are known to Git. Giving the name of a file that you have not told Git about does not remove that file.</source>
          <target state="translated">赋予命令的&amp;lt;file&amp;gt;列表可以是确切的路径名，文件全局模​​式或前导目录名。该命令仅删除Git已知的路径。提供您未告知Git的文件名不会删除该文件。</target>
        </trans-unit>
        <trans-unit id="d9a9d78d51370431396c79c2da7d525a4215ec53" translate="yes" xml:space="preserve">
          <source>The &amp;lt;paths&amp;gt; parameters, when given, are used to limit the diff to the named paths (you can give directory names and get diff for all files under them).</source>
          <target state="translated">如果指定了&amp;lt;paths&amp;gt;参数，则用于将diff限制为命名路径（您可以指定目录名称，并获取其下所有文件的diff）。</target>
        </trans-unit>
        <trans-unit id="be0e9224a3c31468000ef31d0ee2d41289501c7f" translate="yes" xml:space="preserve">
          <source>The &amp;lt;src&amp;gt; is often the name of the branch you would want to push, but it can be any arbitrary &quot;SHA-1 expression&quot;, such as &lt;code&gt;master~4&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt; (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;).</source>
          <target state="translated">在&amp;lt;SRC&amp;gt;通常是你想推，但它可以是任何任意的&amp;ldquo;SHA-1的表达&amp;rdquo;，如分支的名字 &lt;code&gt;master~4&lt;/code&gt; 或 &lt;code&gt;HEAD&lt;/code&gt; （参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7] &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="94b79c58bc3ec3bceec3b732165a2a52f94063c6" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, is present in the database but never &lt;code&gt;directly&lt;/code&gt; used. A dangling commit could be a root node.</source>
          <target state="translated">&amp;lt;type&amp;gt;对象&amp;lt;object&amp;gt;，存在于数据库中，但从未 &lt;code&gt;directly&lt;/code&gt; 使用过。悬空的提交可能是根节点。</target>
        </trans-unit>
        <trans-unit id="c165697ba8df58634f80c6f82752d5afcdee5578" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, is referred to but isn&amp;rsquo;t present in the database.</source>
          <target state="translated">&amp;lt;type&amp;gt;对象&amp;lt;object&amp;gt;被引用，但在数据库中不存在。</target>
        </trans-unit>
        <trans-unit id="5e6573bf54036812f2655d363c6262b69c0dca40" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, isn&amp;rsquo;t actually referred to directly or indirectly in any of the trees or commits seen. This can mean that there&amp;rsquo;s another root node that you&amp;rsquo;re not specifying or that the tree is corrupt. If you haven&amp;rsquo;t missed a root node then you might as well delete unreachable nodes since they can&amp;rsquo;t be used.</source>
          <target state="translated">实际上，在看到的任何树或提交中实际上都没有直接或间接引用&amp;lt;type&amp;gt;对象&amp;lt;object&amp;gt;。这可能意味着您没有指定另一个根节点，或者树已损坏。如果您没有错过根节点，那么您最好删除无法访问的节点，因为它们无法使用。</target>
        </trans-unit>
        <trans-unit id="afa0888330a84b7e0fff615f1c9b8a57ecf94505" translate="yes" xml:space="preserve">
          <source>The 'git sh-i18n scriptlet is designed to be sourced (using &lt;code&gt;.&lt;/code&gt;) by Git&amp;rsquo;s porcelain programs implemented in shell script. It provides wrappers for the GNU &lt;code&gt;gettext&lt;/code&gt; and &lt;code&gt;eval_gettext&lt;/code&gt; functions accessible through the &lt;code&gt;gettext.sh&lt;/code&gt; script, and provides pass-through fallbacks on systems without GNU gettext.</source>
          <target state="translated">'git sh-i18n脚本集旨在通过使用Git的shell脚本中的瓷器程序来获取（使用 &lt;code&gt;.&lt;/code&gt; ）。它提供了包装的GNU &lt;code&gt;gettext&lt;/code&gt; 和 &lt;code&gt;eval_gettext&lt;/code&gt; 通过访问功能 &lt;code&gt;gettext.sh&lt;/code&gt; 脚本，并提供了直通的系统上没有回退的gettext GNU。</target>
        </trans-unit>
        <trans-unit id="75c51ca5866a2731f86888419b9fb61d16567aec" translate="yes" xml:space="preserve">
          <source>The (fully qualified) refname from which to show notes when showing commit messages. The value of this variable can be set to a glob, in which case notes from all matching refs will be shown. You may also specify this configuration variable several times. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">当显示提交消息时,要显示注释的(完全限定的)refname。这个变量的值可以设置为 glob,在这种情况下,会显示所有匹配的 refs 的注释。您也可以多次指定这个配置变量。对于不存在的 refs 会发出警告,但不匹配的 glob 会被忽略。</target>
        </trans-unit>
        <trans-unit id="1e4ce979f13cefaaddaddc6c3ce47e1170286daa" translate="yes" xml:space="preserve">
          <source>The (possibly remote) repository to clone from. See the &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; section below for more information on specifying repositories.</source>
          <target state="translated">要克隆的（可能是远程的）存储库。有关指定存储库的更多信息，请参见下面的&lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="0958323d0ba18cc1a0d938e257756d1659d52ec9" translate="yes" xml:space="preserve">
          <source>The --exclude-existing form is a filter that does the inverse. It reads refs from stdin, one ref per line, and shows those that don&amp;rsquo;t exist in the local repository.</source>
          <target state="translated">--exclude-existing形式是进行逆运算的过滤器。它从stdin读取引用，每行一个引用，并显示本地存储库中不存在的引用。</target>
        </trans-unit>
        <trans-unit id="a043107d8410def266c54e81fdffaefcdaf6dd4c" translate="yes" xml:space="preserve">
          <source>The --smtp-server-option option must be repeated for each option you want to pass to the server. Likewise, different lines in the configuration files must be used for each option.</source>
          <target state="translated">对于要传递给服务器的每个选项,必须重复使用--smtp-server-option选项。同样,配置文件中的每个选项也必须使用不同的行。</target>
        </trans-unit>
        <trans-unit id="b478196a2fb02489b622996c5ea9b31713647e4d" translate="yes" xml:space="preserve">
          <source>The .git location may be auto-discovered, or come from &lt;code&gt;$GIT_DIR&lt;/code&gt; environment variable. If the repository is auto discovered via a .git file (e.g. from submodules, or a linked worktree), the .git location would be the final location where the .git directory is, not where the .git file is.</source>
          <target state="translated">.git位置可以自动发现，也可以来自 &lt;code&gt;$GIT_DIR&lt;/code&gt; 环境变量。如果通过.git文件（例如从子模块或链接的工作树）自动发现存储库，则.git位置将是.git目录的最终位置，而不是.git文件的位置。</target>
        </trans-unit>
        <trans-unit id="489d70f8c8831a28cdf6bb81a4079dab3fec8b7e" translate="yes" xml:space="preserve">
          <source>The 40-hex object name of the object.</source>
          <target state="translated">对象的40个十六进制的对象名称。</target>
        </trans-unit>
        <trans-unit id="edba0bac58d4604af8b0ccc3234ca39328b25c20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; command can create a tar or zip archive from any version of a project; for example:</source>
          <target state="translated">在&lt;a href=&quot;git-archive&quot;&gt;GIT中-归档[1]&lt;/a&gt;命令可以创建一个tar或zip从项目的任何版本的存档; 例如：</target>
        </trans-unit>
        <trans-unit id="8ff01ddb94fa5e45588517f77b5eb76be2068bf4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; command correctly handles history that includes merge commits. However, when the commit that it finds is a merge commit, the user may need to work harder than usual to figure out why that commit introduced a problem.</source>
          <target state="translated">在&lt;a href=&quot;git-bisect&quot;&gt;GIT-平分[1]&lt;/a&gt;命令正确处理历史，其包括合并的提交。但是，当它找到的提交是合并提交时，用户可能需要比平时更努力地工作，以弄清为什么该提交引起了问题。</target>
        </trans-unit>
        <trans-unit id="a1047413b5c194a852bce97f1a7a5b5c064c8f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt; command can show the contents of any object, though the higher-level &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; is usually more useful.</source>
          <target state="translated">在&lt;a href=&quot;git-cat-file&quot;&gt;GIT中-CAT-文件[1]&lt;/a&gt;命令可以显示任何对象的内容，虽然上级&lt;a href=&quot;git-show&quot;&gt;GIT中出现[1]&lt;/a&gt;通常更有用。</target>
        </trans-unit>
        <trans-unit id="0ea75322cb21a3c3c8fac48d1e6228de3fae3cce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; command allows constructing commits with arbitrary parents and trees.</source>
          <target state="translated">该&lt;a href=&quot;git-commit-tree&quot;&gt;混帐提交树[1]&lt;/a&gt;命令允许构建任意父母和树木的提交。</target>
        </trans-unit>
        <trans-unit id="efc26cd7227657520a6926ebb23db38544c357a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-describe&quot;&gt;git-describe[1]&lt;/a&gt; command does the opposite, naming the revision using a tag on which the given commit is based:</source>
          <target state="translated">在&lt;a href=&quot;git-describe&quot;&gt;GIT-描述[1]&lt;/a&gt;命令则相反，使用其上所基于的指定的提交标记命名修订：</target>
        </trans-unit>
        <trans-unit id="9903942bbbf43f525c7cf036d25898c86f9d9d7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt; command runs a number of self-consistency checks on the repository, and reports on any problems. This may take some time.</source>
          <target state="translated">在&lt;a href=&quot;git-fsck&quot;&gt;GIT-fsck的[1]&lt;/a&gt;命令运行一个数字上存储库自一致性检查的，并且在出现任何问题的报告。这可能要花点时间。</target>
        </trans-unit>
        <trans-unit id="ff835519b77a7ea3e8c99474cee535ec38ab3bd6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt; command will sometimes complain about dangling objects. They are not a problem.</source>
          <target state="translated">在&lt;a href=&quot;git-fsck&quot;&gt;GIT-fsck的[1]&lt;/a&gt;命令有时会抱怨悬空对象。他们不是问题。</target>
        </trans-unit>
        <trans-unit id="d818a9097a56e35195bf0f4a41317be4c1298cc7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; command performs packing, pruning, and more for you, so is normally the only high-level command you need.</source>
          <target state="translated">在&lt;a href=&quot;git-gc&quot;&gt;GIT-GC [1]&lt;/a&gt;命令进行包装，修剪，多用于你，所以通常是唯一的需要高级命令。</target>
        </trans-unit>
        <trans-unit id="7674cbc9fda493edc257e040882a4d3b2fee5da7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; command provides a simple way to start browsing the repository using gitweb. The default server when using instaweb is lighttpd.</source>
          <target state="translated">在&lt;a href=&quot;git-instaweb&quot;&gt;GIT-instaweb [1]&lt;/a&gt;命令提供了一种简单的方法来开始浏览使用的GitWeb信息库。使用instaweb时的默认服务器是lighttpd。</target>
        </trans-unit>
        <trans-unit id="3d865565a2d1aab8d65d5524c33990e3ecd5eee4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; and &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; commands also provide special help for merges:</source>
          <target state="translated">在&lt;a href=&quot;git-log&quot;&gt;git的日志[1]&lt;/a&gt;和&lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt;命令，还提供了合并特别的帮助：</target>
        </trans-unit>
        <trans-unit id="869571e8bf360d23843fed69fde509a99aec51ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; command can show lists of commits. On its own, it shows all commits reachable from the parent commit; but you can also make more specific requests:</source>
          <target state="translated">在&lt;a href=&quot;git-log&quot;&gt;GIT中日志[1]&lt;/a&gt;命令可以显示提交的列表。它单独显示所有从父提交可到达的提交；但您也可以提出更具体的要求：</target>
        </trans-unit>
        <trans-unit id="49730fd39b9c73a554b2cce254c7d8e26a1047e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; command is a low-level command that is occasionally useful for translating some name for a commit to the object name for that commit:</source>
          <target state="translated">在&lt;a href=&quot;git-rev-parse&quot;&gt;GIT-REV-解析[1]&lt;/a&gt;命令是一个低级别的命令，该命令是用于平移一些名称承诺为提交对象名偶尔有用：</target>
        </trans-unit>
        <trans-unit id="d0ac1c8438cdf91fddee2ad5a2dd381f720a6756" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; command is available since Git 1.5.3. Users with Git 1.5.2 can look up the submodule commits in the repository and manually check them out; earlier versions won&amp;rsquo;t recognize the submodules at all.</source>
          <target state="translated">在&lt;a href=&quot;git-submodule&quot;&gt;GIT-子模块[1]&lt;/a&gt;命令是可用的，因为GIT中1.5.3。使用Git 1.5.2的用户可以在存储库中查找子模块的提交并手动将其检出。早期版本根本无法识别子模块。</target>
        </trans-unit>
        <trans-unit id="8ffc16af4f4197ccdbaaceb3fe6721dcc4562d83" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; command updates the index with information from the working directory. You generally update the index information by just specifying the filename you want to update, like so:</source>
          <target state="translated">在&lt;a href=&quot;git-update-index&quot;&gt;GIT中更新索引[1]&lt;/a&gt;命令更新与从工作目录信息的索引。通常，您只需指定要更新的文件名即可更新索引信息，如下所示：</target>
        </trans-unit>
        <trans-unit id="20874526426e66810d4174f5227a378a8de7e91c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;git filter-repo&lt;/a&gt; tool is an alternative to git-filter-branch which does not suffer from these performance problems or the safety problems (mentioned below). For those with existing tooling which relies upon git-filter-branch, &lt;code&gt;git repo-filter&lt;/code&gt; also provides &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;filter-lamely&lt;/a&gt;, a drop-in git-filter-branch replacement (with a few caveats). While filter-lamely suffers from all the same safety issues as git-filter-branch, it at least ameliorates the performance issues a little.</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;GIT中过滤回购&lt;/a&gt;工具是与git滤波器分支的替代在不脱离这些性能问题或安全性问题（后述）受到影响。对于那些拥有依赖git-filter-branch的现有工具的人， &lt;code&gt;git repo-filter&lt;/code&gt; 还提供&lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;filter-lamely&lt;/a&gt;，即插即用的 git-filter-branch替换（有一些警告）。尽管filter-lamely遭受了与git-filter-branch相同的所有安全问题，但它至少可以稍微改善性能问题。</target>
        </trans-unit>
        <trans-unit id="ad21d56fce6cdd39ef4f92ed0708902d059eaafc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;user-manual&quot;&gt;Git User&amp;rsquo;s Manual&lt;/a&gt; provides a more comprehensive introduction to Git.</source>
          <target state="translated">在&lt;a href=&quot;user-manual&quot;&gt;Git的用户手册&lt;/a&gt;提供了更全面的介绍Git的。</target>
        </trans-unit>
        <trans-unit id="89c784f1b1d17488cfe361d4581fd69d6d34303d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;user-manual#git-concepts&quot;&gt;Git concepts chapter of the user-manual&lt;/a&gt; and &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; both provide introductions to the underlying Git architecture.</source>
          <target state="translated">&lt;a href=&quot;user-manual#git-concepts&quot;&gt;用户手册&lt;/a&gt;和&lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt;的Git概念一章都提供了底层Git体系结构的介绍。</target>
        </trans-unit>
        <trans-unit id="5f7a0a0ce9975de955e97678d53d0386ebf8b091" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; file is used to define the skip-worktree reference bitmap. When Git updates the working directory, it updates the skip-worktree bits in the index based on this file. The files matching the patterns in the file will appear in the working directory, and the rest will not.</source>
          <target state="translated">在 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 文件被用来定义的跳跃worktree参考位图。当Git更新工作目录时，它将根据该文件更新索引中的skip-worktree位。与文件中的模式匹配的文件将显示在工作目录中，其余文件则不会显示。</target>
        </trans-unit>
        <trans-unit id="18927ccc4077efc9fa00280f487bf7ea52068011" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;any&amp;gt;&lt;/code&gt; part of the command may contain any sequence of bytes that does not contain &lt;code&gt;LF&lt;/code&gt;. The &lt;code&gt;LF&lt;/code&gt; after the command is optional. Callers may wish to process the output through a tool such as sed to remove the leading part of the line, for example:</source>
          <target state="translated">命令的 &lt;code&gt;&amp;lt;any&amp;gt;&lt;/code&gt; 部分可以包含不包含 &lt;code&gt;LF&lt;/code&gt; 的任何字节序列。该 &lt;code&gt;LF&lt;/code&gt; 命令后是可选的。调用者可能希望通过诸如sed之类的工具来处理输出，以删除行的开头部分，例如：</target>
        </trans-unit>
        <trans-unit id="38ecaff497a30523addb0d68ac2f3ff7d62121ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) or the full 40-byte SHA-1 of a Git tag, commit, or tree object, preexisting or waiting to be written. The path is relative to the top level of the tree named by &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 可以是一个参考标记（ &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ）或GIT中标签的全部40个字节的SHA-1，提交，或者树对象，预先存在的或等待写入。路径相对于 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 命名的树的顶层。</target>
        </trans-unit>
        <trans-unit id="df9429d81584e26f1a55e7eff78d6952383c6adf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set previously or a full 40-byte SHA-1 of a Git blob, preexisting or ready to be written.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 可以是参考标记（ &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ）预先设定或一个的blob的完整的40字节SHA-1，先前存在的或准备好被写入。</target>
        </trans-unit>
        <trans-unit id="d38490ce2af2d9b14b21e7e25c13d2a1c79c408e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; part of the command may contain any of the options listed in the OPTIONS section that do not change import semantics, without the leading &lt;code&gt;--&lt;/code&gt; and is treated in the same way.</source>
          <target state="translated">该命令的 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 部分可能包含OPTIONS部分中列出的任何选项，这些选项不会更改导入语义，并且不带前导 &lt;code&gt;--&lt;/code&gt; 并以相同的方式处理。</target>
        </trans-unit>
        <trans-unit id="73cfe0e2f7b7cccff976b7e355044194793ceedb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;pushurl&amp;gt;&lt;/code&gt; is used for pushes only. It is optional and defaults to &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;pushurl&amp;gt;&lt;/code&gt; 仅用于推动。它是可选的，默认为 &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="226bf97de37dae89426f4bcaf2c8464c2aaac4ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;rev&amp;gt;^-[&amp;lt;n&amp;gt;]&lt;/code&gt; notation includes &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; but excludes the &amp;lt;n&amp;gt;th parent (i.e. a shorthand for &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt;), with &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1 if not given. This is typically useful for merge commits where you can just pass &lt;code&gt;&amp;lt;commit&amp;gt;^-&lt;/code&gt; to get all the commits in the branch that was merged in merge commit &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; (including &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; itself).</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;rev&amp;gt;^-[&amp;lt;n&amp;gt;]&lt;/code&gt; 表示法包括 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 但不包括&amp;lt;N&amp;gt;个亲本（即，简写 &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt; ）中，用 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1，如果没有给。这通常对合并提交很有用，在合并提交中，您只需传递 &lt;code&gt;&amp;lt;commit&amp;gt;^-&lt;/code&gt; 即可获取合并提交 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 中已合并的分支中的所有提交（包括 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 本身）。</target>
        </trans-unit>
        <trans-unit id="382c52b269a126869d3f5e611e50db349c01a555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; is just a good idea when you know the rest will be filenames; it will prevent problems with a filename of, for example, &lt;code&gt;-a&lt;/code&gt;. Using &lt;code&gt;--&lt;/code&gt; is probably a good policy in scripts.</source>
          <target state="translated">当您知道其余的将是文件名时， &lt;code&gt;--&lt;/code&gt; 只是一个好主意；它将防止文件名例如 &lt;code&gt;-a&lt;/code&gt; 出现问题。在脚本中使用 &lt;code&gt;--&lt;/code&gt; 可能是一个很好的策略。</target>
        </trans-unit>
        <trans-unit id="1a7c2f7d5b7ec8386e86076d812d974232af3082" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--cached&lt;/code&gt; option is used to ask a command that usually works on files in the working tree to &lt;strong&gt;only&lt;/strong&gt; work with the index. For example, &lt;code&gt;git grep&lt;/code&gt;, when used without a commit to specify from which commit to look for strings in, usually works on files in the working tree, but with the &lt;code&gt;--cached&lt;/code&gt; option, it looks for strings in the index.</source>
          <target state="translated">该 &lt;code&gt;--cached&lt;/code&gt; 选项是问，通常在工作中的文件工作树的命令&lt;strong&gt;只&lt;/strong&gt;工作与索引。例如， &lt;code&gt;git grep&lt;/code&gt; 不用提交来指定从哪个提交中查找字符串时，通常可用于工作树中的文件，但是使用 &lt;code&gt;--cached&lt;/code&gt; 选项时，它将在索引中查找字符串。</target>
        </trans-unit>
        <trans-unit id="93eb90d6c0bfdb16dcadbf4c72d38d80f8bf4451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--dry-run&lt;/code&gt; option can be used to obtain a summary of what is included by any of the above for the next commit by giving the same set of parameters (options and paths).</source>
          <target state="translated">所述 &lt;code&gt;--dry-run&lt;/code&gt; 选项可以用于获得什么是由任何上述的包括的总结下被赋予了相同的一组参数（选项和路径）提交。</target>
        </trans-unit>
        <trans-unit id="45e26263ba79c46b47e35a4fe67d4d8f33b37e0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--env-filter&lt;/code&gt; option can be used to modify committer and/or author identity. For example, if you found out that your commits have the wrong identity due to a misconfigured user.email, you can make a correction, before publishing the project, like this:</source>
          <target state="translated">所述 &lt;code&gt;--env-filter&lt;/code&gt; 选项可以用于修改提交者和/或作者的身份。例如，如果您发现由于user.email配置错误导致提交的身份错误，则可以在发布项目之前进行更正，如下所示：</target>
        </trans-unit>
        <trans-unit id="b4b7635118d0a90fb277012f2d96d5181b61e4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--index&lt;/code&gt; option is used to ask a command that usually works on files in the working tree to &lt;strong&gt;also&lt;/strong&gt; affect the index. For example, &lt;code&gt;git stash apply&lt;/code&gt; usually merges changes recorded in a stash entry to the working tree, but with the &lt;code&gt;--index&lt;/code&gt; option, it also merges changes to the index as well.</source>
          <target state="translated">该 &lt;code&gt;--index&lt;/code&gt; 选项是问，通常在工作中的文件工作树的命令&lt;strong&gt;还&lt;/strong&gt;影响指数。例如， &lt;code&gt;git stash apply&lt;/code&gt; 通常将存储在存储条目中的更改合并到工作树中，但是使用 &lt;code&gt;--index&lt;/code&gt; 选项，它也将更改合并到索引中。</target>
        </trans-unit>
        <trans-unit id="f5e672ca7275921f27bc57abfee8498efa38d837" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--numstat&lt;/code&gt; option gives the diffstat(1) information but is designed for easier machine consumption. An entry in &lt;code&gt;--numstat&lt;/code&gt; output looks like this:</source>
          <target state="translated">该 &lt;code&gt;--numstat&lt;/code&gt; 选项给出的diffstat（1）信息，但设计更容易机消费。 &lt;code&gt;--numstat&lt;/code&gt; 输出中的条目如下所示：</target>
        </trans-unit>
        <trans-unit id="824224d8413c92cfa07b10a7d5f109653a254225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--patch&lt;/code&gt; option implies &lt;code&gt;--keep-index&lt;/code&gt;. You can use &lt;code&gt;--no-keep-index&lt;/code&gt; to override this.</source>
          <target state="translated">该 &lt;code&gt;--patch&lt;/code&gt; 选项意味着 &lt;code&gt;--keep-index&lt;/code&gt; 。您可以使用 &lt;code&gt;--no-keep-index&lt;/code&gt; 覆盖它。</target>
        </trans-unit>
        <trans-unit id="cd53bf0606653a9e38fc2f67928f722d519b8437" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--prune-tags&lt;/code&gt; option is equivalent to having &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; declared in the refspecs of the remote. This can lead to some seemingly strange interactions:</source>
          <target state="translated">&lt;code&gt;--prune-tags&lt;/code&gt; 选项等效于在遥控器的refspec中声明 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; 。这可能导致一些看似奇怪的交互：</target>
        </trans-unit>
        <trans-unit id="eedbb7a82985c4671f5041c09553972a9225fc17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rebase-merges&lt;/code&gt; mode is similar in spirit to the deprecated &lt;code&gt;--preserve-merges&lt;/code&gt; but works with interactive rebases, where commits can be reordered, inserted and dropped at will.</source>
          <target state="translated">该 &lt;code&gt;--rebase-merges&lt;/code&gt; 模式在本质上弃用类似 &lt;code&gt;--preserve-merges&lt;/code&gt; ，但与互动底垫，在这里提交可以重新排序，插入和随意丢弃的作品。</target>
        </trans-unit>
        <trans-unit id="8061f1189be4b513311a10997c4e6fc449baeaf4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--simplify-by-decoration&lt;/code&gt; option allows you to view only the big picture of the topology of the history, by omitting commits that are not referenced by tags. Commits are marked as !TREESAME (in other words, kept after history simplification rules described above) if (1) they are referenced by tags, or (2) they change the contents of the paths given on the command line. All other commits are marked as TREESAME (subject to be simplified away).</source>
          <target state="translated">该 &lt;code&gt;--simplify-by-decoration&lt;/code&gt; 选项允许你只查看历史的拓扑结构的大局，通过省略未通过标签引用的提交。如果（1）标记引用了提交，或（2）更改了命令行上给定路径的内容，则将提交标记为！TREESAME（换句话说，在上述的历史简化规则之后保留）。所有其他提交都标记为TREESAME（将被简化）。</target>
        </trans-unit>
        <trans-unit id="16b8753fdc735c82bb8e4b4e3197e33fe132b018" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--summary&lt;/code&gt; option describes newly added, deleted, renamed and copied files. The &lt;code&gt;--stat&lt;/code&gt; option adds diffstat(1) graph to the output. These options can be combined with other options, such as &lt;code&gt;-p&lt;/code&gt;, and are meant for human consumption.</source>
          <target state="translated">该 &lt;code&gt;--summary&lt;/code&gt; 选项描述新添加，删除，重命名和复制的文件。所述 &lt;code&gt;--stat&lt;/code&gt; 选项添加diffstat（1）图来输出。这些选项可以与其他选项结合使用，例如 &lt;code&gt;-p&lt;/code&gt; ，供人类使用。</target>
        </trans-unit>
        <trans-unit id="2fb3a538afbb18a8ca912f0cecf9a31cb6701775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; option instructs &lt;code&gt;git config&lt;/code&gt; to ensure that incoming and outgoing values are canonicalize-able under the given &amp;lt;type&amp;gt;. If no &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; is given, no canonicalization will be performed. Callers may unset an existing &lt;code&gt;--type&lt;/code&gt; specifier with &lt;code&gt;--no-type&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; 选项指示 &lt;code&gt;git config&lt;/code&gt; ，以确保输入和输出值。规范化-能够在给定的&amp;lt;类型&amp;gt;。如果未 &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; ，则将不执行规范化。 &lt;code&gt;--type&lt;/code&gt; 者可以使用 &lt;code&gt;--no-type&lt;/code&gt; 取消设置现有的--type指定符。</target>
        </trans-unit>
        <trans-unit id="0c9422891d35819a54a8ef0ba6d7016d122547ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-M&lt;/code&gt; and &lt;code&gt;-C&lt;/code&gt; options require O(n^2) processing time where n is the number of potential rename/copy targets. This option prevents rename/copy detection from running if the number of rename/copy targets exceeds the specified number.</source>
          <target state="translated">在 &lt;code&gt;-M&lt;/code&gt; 和 &lt;code&gt;-C&lt;/code&gt; 选项需要为O（n ^ 2）的处理时间，其中n是潜在的重命名的数目/复制目标。如果重命名/复制目标的数量超过指定数目，此选项将阻止运行重命名/复制检测。</target>
        </trans-unit>
        <trans-unit id="73fff0c26b859dbfe915afb814a50fa7bc541c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-C&lt;/code&gt; options have the exact same semantics as &lt;code&gt;-m&lt;/code&gt; and &lt;code&gt;-M&lt;/code&gt;, except instead of the branch being renamed it along with its config and reflog will be copied to a new name.</source>
          <target state="translated">在 &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;-C&lt;/code&gt; 选项有相同的语义 &lt;code&gt;-m&lt;/code&gt; 和 &lt;code&gt;-M&lt;/code&gt; ，除了支路，而不是给它改名与它的配置和引用日志一起将被复制到一个新的名字。</target>
        </trans-unit>
        <trans-unit id="89a7df63322c3f15984d17c0e2db0a5d71e95aa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; and &lt;code&gt;-F&lt;/code&gt; options can be given any number of times, in any order. The commit log message will be composed in the order in which the options are given.</source>
          <target state="translated">该 &lt;code&gt;-m&lt;/code&gt; 和 &lt;code&gt;-F&lt;/code&gt; 选项可以给任意次数，以任何顺序。提交日志消息将按照给出选项的顺序组成。</target>
        </trans-unit>
        <trans-unit id="f4502e6a26132411ed2e9fd1c43849a487e5e5a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; option is mutually exclusive with &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, and &lt;code&gt;-F&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;-m&lt;/code&gt; 选项是互相排斥的 &lt;code&gt;-c&lt;/code&gt; ， &lt;code&gt;-C&lt;/code&gt; ，和 &lt;code&gt;-F&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38779d2c15d6e090718b82e6af2f8c359ec976d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.git-credentials&lt;/code&gt; file is stored in plaintext. Each credential is stored on its own line as a URL like:</source>
          <target state="translated">在 &lt;code&gt;.git-credentials&lt;/code&gt; 文件存储在纯文本。每个凭证都以URL的形式存储在自己的行中，例如：</target>
        </trans-unit>
        <trans-unit id="905c63d14654cde00625cb5e82c7038bc34ea94e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.gitmodules&lt;/code&gt; file inside the superproject. A project usually uses this file to suggest defaults for the upstream collection of repositories for the mapping that is required between a submodule&amp;rsquo;s name and its path.</source>
          <target state="translated">超级项目中的 &lt;code&gt;.gitmodules&lt;/code&gt; 文件。项目通常使用此文件为子模块名称和其路径之间所需的映射建议上游存储库集合的默认值。</target>
        </trans-unit>
        <trans-unit id="0bb4fdb786947245a90430b5697a0e9422df1d21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.gitmodules&lt;/code&gt; file, located in the top-level directory of a Git working tree, is a text file with a syntax matching the requirements of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;.gitmodules&lt;/code&gt; 文件，位于一个Git工作树的顶层目录，是相匹配的要求，语法的文本文件&lt;a href=&quot;git-config&quot;&gt;的git-配置[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5324d8792f18dd9ac59490b336e09b1bd43353e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.mailmap&lt;/code&gt; feature is used to coalesce together commits by the same person in the shortlog, where their name and/or email address was spelled differently.</source>
          <target state="translated">该 &lt;code&gt;.mailmap&lt;/code&gt; 功能由同一个人在shortlog，他们的名称和/或电子邮件地址被拼写不同用于聚结在一起提交。</target>
        </trans-unit>
        <trans-unit id="73c3a5a96a8a6a48d412facd438733454a4a63a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; ref is set to point at the commit that introduced the change that is difficult to apply.</source>
          <target state="translated">该 &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; 裁判在设置点提交介绍了这是难以适用的变化。</target>
        </trans-unit>
        <trans-unit id="df208c183263acdaf73c0a978db9f5c35380bc6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; environment variables and the &lt;code&gt;--date&lt;/code&gt; option support the following date formats:</source>
          <target state="translated">该 &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt; ， &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; 环境变量和 &lt;code&gt;--date&lt;/code&gt; 选项支持以下日期格式：</target>
        </trans-unit>
        <trans-unit id="ad08232602558aa9979e8ccc7bf4df9612b12ec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; environment variables support the following date formats:</source>
          <target state="translated">该 &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt; ， &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; 环境变量支持以下日期格式：</target>
        </trans-unit>
        <trans-unit id="9c24e5e1da9f8726ec7abe4516a017b9495c2fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable may be passed to &lt;code&gt;git-http-backend&lt;/code&gt; to bypass the check for the &quot;git-daemon-export-ok&quot; file in each repository before allowing export of that repository.</source>
          <target state="translated">可以在允许导出该存储库之前，将 &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; 环境变量传递给 &lt;code&gt;git-http-backend&lt;/code&gt; 以绕过每个存储库中对&amp;ldquo; git-daemon-export-ok&amp;rdquo;文件的检查。</target>
        </trans-unit>
        <trans-unit id="387cfeb550226cfd9e601b1b72a83920c3f36040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_HTTP_MAX_REQUEST_BUFFER&lt;/code&gt; environment variable (or the &lt;code&gt;http.maxRequestBuffer&lt;/code&gt; config variable) may be set to change the largest ref negotiation request that git will handle during a fetch; any fetch requiring a larger buffer will not succeed. This value should not normally need to be changed, but may be helpful if you are fetching from a repository with an extremely large number of refs. The value can be specified with a unit (e.g., &lt;code&gt;100M&lt;/code&gt; for 100 megabytes). The default is 10 megabytes.</source>
          <target state="translated">所述 &lt;code&gt;GIT_HTTP_MAX_REQUEST_BUFFER&lt;/code&gt; 环境变量（或 &lt;code&gt;http.maxRequestBuffer&lt;/code&gt; 配置变量）可以被设置为改变最大REF协商请求git会期间获取处理; 任何需要较大缓冲区的提取都不会成功。通常不需要更改该值，但是如果您从具有大量引用的存储库中获取数据，则可能会有所帮助。可以用单位指定该值（例如 &lt;code&gt;100M&lt;/code&gt; 表示100兆字节）。默认值为10 MB。</target>
        </trans-unit>
        <trans-unit id="166eca4501cd90cd3b21f8df969c5ee397d12242" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_NO_REPLACE_OBJECTS&lt;/code&gt; environment variable can be set to achieve the same effect as the &lt;code&gt;--no-replace-objects&lt;/code&gt; option.</source>
          <target state="translated">该 &lt;code&gt;GIT_NO_REPLACE_OBJECTS&lt;/code&gt; 环境变量可以设置来实现的同样的效果 &lt;code&gt;--no-replace-objects&lt;/code&gt; 的选择。</target>
        </trans-unit>
        <trans-unit id="8bee9745a8d6377da5f35089625008b4042f0f35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_PUSH_CERT*&lt;/code&gt; environment variables can be inspected, just as in &lt;code&gt;pre-receive&lt;/code&gt; hook, after accepting a signed push.</source>
          <target state="translated">所述 &lt;code&gt;GIT_PUSH_CERT*&lt;/code&gt; 环境变量可以被检查，就如同在 &lt;code&gt;pre-receive&lt;/code&gt; 钩，接受签字推后。</target>
        </trans-unit>
        <trans-unit id="8bc6550bd201f7a8ce8611abf35f278e4b89d03c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; pointer stays the same.</source>
          <target state="translated">该 &lt;code&gt;HEAD&lt;/code&gt; 指针保持不变。</target>
        </trans-unit>
        <trans-unit id="652c0cf20ffd72216eb399a1f559569365b85933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after &lt;code&gt;&amp;lt;delim&amp;gt; LF&lt;/code&gt; is optional (it used to be required).</source>
          <target state="translated">所述 &lt;code&gt;LF&lt;/code&gt; 后 &lt;code&gt;&amp;lt;delim&amp;gt; LF&lt;/code&gt; 是可选的（它用于需要）。</target>
        </trans-unit>
        <trans-unit id="c1bff9f88ec1fe482fd273291dfad27de492749b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; is optional (it used to be required) but recommended. Always including it makes debugging a fast-import stream easier as the next command always starts in column 0 of the next line, even if &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; did not end with an &lt;code&gt;LF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; 之后的 &lt;code&gt;LF&lt;/code&gt; 是可选的（以前是必需的），但建议使用。始终包含它可以使调试快速导入流变得更加容易，因为下一条命令始终在下一行的第0列中开始，即使 &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; 并非以 &lt;code&gt;LF&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="ec7a854b1a4c70ca562f0584186eed412906ec8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after the command is optional (it used to be required).</source>
          <target state="translated">的 &lt;code&gt;LF&lt;/code&gt; 的命令之后是可选的（它用于需要）。</target>
        </trans-unit>
        <trans-unit id="9a136595a2c2895a25e4571b5fe242dd49c2174e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after the command is optional (it used to be required). Note that for reasons of backward compatibility, if the commit ends with a &lt;code&gt;data&lt;/code&gt; command (i.e. it has no &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filedelete&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt;, &lt;code&gt;filedeleteall&lt;/code&gt; or &lt;code&gt;notemodify&lt;/code&gt; commands) then two &lt;code&gt;LF&lt;/code&gt; commands may appear at the end of the command instead of just one.</source>
          <target state="translated">的 &lt;code&gt;LF&lt;/code&gt; 的命令之后是可选的（它用于需要）。请注意，出于向后兼容的原因，如果提交以 &lt;code&gt;data&lt;/code&gt; 命令结尾（即，它没有 &lt;code&gt;from&lt;/code&gt; ， &lt;code&gt;merge&lt;/code&gt; ， &lt;code&gt;filemodify&lt;/code&gt; ， &lt;code&gt;filedelete&lt;/code&gt; ， &lt;code&gt;filecopy&lt;/code&gt; ， &lt;code&gt;filerename&lt;/code&gt; ， &lt;code&gt;filedeleteall&lt;/code&gt; 或 &lt;code&gt;notemodify&lt;/code&gt; 命令），则两个 &lt;code&gt;LF&lt;/code&gt; 命令可能会出现在命令末尾而不是一个。</target>
        </trans-unit>
        <trans-unit id="6afb1837ee3e8f65249dcb4905156711b603dd19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MERGE_HEAD&lt;/code&gt; ref is set to point to the other branch head.</source>
          <target state="translated">该 &lt;code&gt;MERGE_HEAD&lt;/code&gt; Ref设定点到另一个分支头。</target>
        </trans-unit>
        <trans-unit id="4dcd07a8427d3cae73e7340717a2be5da78b122e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^0&lt;/code&gt; suffix is necessary as fast-import does not permit a branch to start from itself, and the branch is created in memory before the &lt;code&gt;from&lt;/code&gt; command is even read from the input. Adding &lt;code&gt;^0&lt;/code&gt; will force fast-import to resolve the commit through Git&amp;rsquo;s revision parsing library, rather than its internal branch table, thereby loading in the existing value of the branch.</source>
          <target state="translated">该 &lt;code&gt;^0&lt;/code&gt; 后缀是必要的，因为快速导入不允许一个分支，从自身做起，并在内存中创建分支之前， &lt;code&gt;from&lt;/code&gt; 命令甚至从输入读取。添加 &lt;code&gt;^0&lt;/code&gt; 将强制快速导入通过Git的修订版解析库而不是其内部分支表来解析提交，从而加载分支的现有值。</target>
        </trans-unit>
        <trans-unit id="675155c0bc0c9682b02ea7dc72c6fe717f8d57df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^r1 r2&lt;/code&gt; set operation appears so often that there is a shorthand for it. When you have two commits &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; (named according to the syntax explained in SPECIFYING REVISIONS above), you can ask for commits that are reachable from r2 excluding those that are reachable from r1 by &lt;code&gt;^r1 r2&lt;/code&gt; and it can be written as &lt;code&gt;r1..r2&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;^r1 r2&lt;/code&gt; 设置操作似乎经常有它的简写。当您有两个提交 &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;r2&lt;/code&gt; （根据上面&amp;ldquo;指定版本&amp;rdquo;中所述的语法命名）时，可以要求从r2可以到达的提交（不包括从r1到 &lt;code&gt;^r1 r2&lt;/code&gt; 可以到达的提交），可以将其写为 &lt;code&gt;r1..r2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c300333c575f956c2060e4236a825e5a15abf118" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a/&lt;/code&gt; and &lt;code&gt;b/&lt;/code&gt; filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, &lt;code&gt;/dev/null&lt;/code&gt; is &lt;code&gt;not&lt;/code&gt; used in place of the &lt;code&gt;a/&lt;/code&gt; or &lt;code&gt;b/&lt;/code&gt; filenames.</source>
          <target state="translated">所述 &lt;code&gt;a/&lt;/code&gt; 和 &lt;code&gt;b/&lt;/code&gt; 文件名是，除非重命名/拷贝所涉及的相同。特别是，即使是创建或删除，也 &lt;code&gt;not&lt;/code&gt; 使用 &lt;code&gt;/dev/null&lt;/code&gt; 代替 &lt;code&gt;a/&lt;/code&gt; 或 &lt;code&gt;b/&lt;/code&gt; 文件名。</target>
        </trans-unit>
        <trans-unit id="eab33dae66d0744b7d6024e6ba0526d3cbdb099d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base commit&lt;/code&gt; is shown as &quot;base-commit: &quot; followed by the 40-hex of the commit object name. A &lt;code&gt;prerequisite patch&lt;/code&gt; is shown as &quot;prerequisite-patch-id: &quot; followed by the 40-hex &lt;code&gt;patch id&lt;/code&gt;, which can be obtained by passing the patch through the &lt;code&gt;git patch-id --stable&lt;/code&gt; command.</source>
          <target state="translated">所述 &lt;code&gt;base commit&lt;/code&gt; 被示出为&amp;ldquo;基提交：&amp;rdquo;，后跟提交对象名称的40进制。甲 &lt;code&gt;prerequisite patch&lt;/code&gt; 被示出为&amp;ldquo;前提贴片-ID：&amp;rdquo;，接着在40进制 &lt;code&gt;patch id&lt;/code&gt; ，其可以通过使补丁通过获得 &lt;code&gt;git patch-id --stable&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="4310c66d08d5e3db5f29a0976c449ecfedbc1c27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;category&lt;/code&gt; field may be used in a future enhancement to do category-based filtering.</source>
          <target state="translated">该 &lt;code&gt;category&lt;/code&gt; 字段可能在未来的增强可以用来做基于类别的过滤。</target>
        </trans-unit>
        <trans-unit id="957c03f80393df2f84f209da8b3d5d5b6c66e351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commit walkers&lt;/code&gt; are sometimes also called &lt;code&gt;dumb transports&lt;/code&gt;, because they do not require any Git aware smart server like Git Native transport does. Any stock HTTP server that does not even support directory index would suffice. But you must prepare your repository with &lt;code&gt;git update-server-info&lt;/code&gt; to help dumb transport downloaders.</source>
          <target state="translated">在 &lt;code&gt;commit walkers&lt;/code&gt; 有时也被称为 &lt;code&gt;dumb transports&lt;/code&gt; ，因为它们不需要任何的Git知道智能服务器如Git机传输一样。任何甚至不支持目录索引的现有HTTP服务器都足够。但是您必须使用 &lt;code&gt;git update-server-info&lt;/code&gt; 准备您的存储库，以帮助简化传输下载程序。</target>
        </trans-unit>
        <trans-unit id="16292719b3497b67052d324a828a5bf607c10cb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;committer&lt;/code&gt; command indicates who made this commit, and when they made it.</source>
          <target state="translated">该 &lt;code&gt;committer&lt;/code&gt; 命令指示谁做此承诺，当他们做到了。</target>
        </trans-unit>
        <trans-unit id="7e0ffba56fb259ff8ccb9999d0c02587815b0675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable allows you to define what &lt;code&gt;diff&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; should consider whitespace errors for all paths in the project (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). This attribute gives you finer control per path.</source>
          <target state="translated">该 &lt;code&gt;core.whitespace&lt;/code&gt; 配置变量允许您定义什么 &lt;code&gt;diff&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 应该考虑空白为项目中的所有路径错误（见&lt;a href=&quot;git-config&quot;&gt;的git-配置[1] &lt;/a&gt;）。此属性使您可以更好地控制每个路径。</target>
        </trans-unit>
        <trans-unit id="c4cf312c5837f50305786c4fff7bd921da0df1e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; command following &lt;code&gt;committer&lt;/code&gt; must supply the commit message (see below for &lt;code&gt;data&lt;/code&gt; command syntax). To import an empty commit message use a 0 length data. Commit messages are free-form and are not interpreted by Git. Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified.</source>
          <target state="translated">的 &lt;code&gt;data&lt;/code&gt; 的命令以下 &lt;code&gt;committer&lt;/code&gt; 必须提供提交消息（参见下面的 &lt;code&gt;data&lt;/code&gt; 命令语法）。要导入空的提交消息，请使用长度为0的数据。提交消息是自由格式的，不会被Git解释。当前，它们必须以UTF-8编码，因为快速导入不允许指定其他编码。</target>
        </trans-unit>
        <trans-unit id="fe1dcaff1f205cb554cce0caa7f556f5b3750431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; command following &lt;code&gt;tagger&lt;/code&gt; must supply the annotated tag message (see below for &lt;code&gt;data&lt;/code&gt; command syntax). To import an empty tag message use a 0 length data. Tag messages are free-form and are not interpreted by Git. Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified.</source>
          <target state="translated">&lt;code&gt;tagger&lt;/code&gt; 后面的 &lt;code&gt;data&lt;/code&gt; 命令必须提供带注释的标记消息（有关 &lt;code&gt;data&lt;/code&gt; 命令语法，请参见下文）。要导入空标签消息，请使用长度为0的数据。标记消息是自由格式的，不会被Git解释。当前，它们必须以UTF-8编码，因为快速导入不允许指定其他编码。</target>
        </trans-unit>
        <trans-unit id="463a929e2c19b7bbf028008ad9aa5a5763e6cf66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export-marks&lt;/code&gt; and &lt;code&gt;import-marks&lt;/code&gt; capabilities, if specified, affect this command in so far as they are passed on to &lt;code&gt;git fast-export&lt;/code&gt;, which then will load/store a table of marks for local objects. This can be used to implement for incremental operations.</source>
          <target state="translated">该 &lt;code&gt;export-marks&lt;/code&gt; 和 &lt;code&gt;import-marks&lt;/code&gt; 功能，如果指定，在只要它们传递影响这个命令到 &lt;code&gt;git fast-export&lt;/code&gt; ，然后将加载/存储本地对象标记的表。这可用于实现增量操作。</target>
        </trans-unit>
        <trans-unit id="b29369cc7c91f799f3a98b04ce067ccee4eaff48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra-info&lt;/code&gt; is again command-dependent. If it is empty, the preceding SP is also omitted. Currently, no commands pass any &lt;code&gt;extra-info&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;extra-info&lt;/code&gt; 再次命令依赖性。如果为空，则也忽略前面的SP。当前，没有命令传递任何 &lt;code&gt;extra-info&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42c3cfeeb6fb7d3b809e4b2424ab05b633a62a10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with &lt;code&gt;%n&lt;/code&gt; instead of &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; 格式允许你指定要显示哪些信息。它的工作方式类似于printf格式，但值得注意的例外是，您使用 &lt;code&gt;%n&lt;/code&gt; 而不是 &lt;code&gt;\n&lt;/code&gt; 换行了。</target>
        </trans-unit>
        <trans-unit id="6d12446e6ba50613ffa6591e4d86ab902d5b116f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; command is the same as in the &lt;code&gt;commit&lt;/code&gt; command; see above for details.</source>
          <target state="translated">在 &lt;code&gt;from&lt;/code&gt; 命令是一样的，在 &lt;code&gt;commit&lt;/code&gt; 命令; 有关详情，请参见上文。</target>
        </trans-unit>
        <trans-unit id="d9bc1ff5b134d7635edcea3cd4e631a291483167" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; command is used to specify the commit to initialize this branch from. This revision will be the first ancestor of the new commit. The state of the tree built at this commit will begin with the state at the &lt;code&gt;from&lt;/code&gt; commit, and be altered by the content modifications in this commit.</source>
          <target state="translated">在 &lt;code&gt;from&lt;/code&gt; 命令用于指定承诺初始化这个分支。此修订版将是新提交的第一个祖先。在此提交时构建的树的状态将以 &lt;code&gt;from&lt;/code&gt; 提交时的状态开始，并被该提交中的内容修改所改变。</target>
        </trans-unit>
        <trans-unit id="75dab416c6ca16533650ccb3bdbb6f1c8c80e31e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git add&lt;/code&gt; command will not add ignored files by default. If any ignored files were explicitly specified on the command line, &lt;code&gt;git add&lt;/code&gt; will fail with a list of ignored files. Ignored files reached by directory recursion or filename globbing performed by Git (quote your globs before the shell) will be silently ignored. The &lt;code&gt;git add&lt;/code&gt; command can be used to add ignored files with the &lt;code&gt;-f&lt;/code&gt; (force) option.</source>
          <target state="translated">该 &lt;code&gt;git add&lt;/code&gt; 命令默认情况下不会加忽略的文件。如果在命令行上明确指定了任何被忽略的文件，则 &lt;code&gt;git add&lt;/code&gt; 将失败，并显示被忽略文件的列表。由目录递归或Git执行的文件名通配符（在shell之前引用您的通配符）所到达的忽略文件将被静默忽略。在 &lt;code&gt;git add&lt;/code&gt; 命令可以用来添加与被忽略的文件 &lt;code&gt;-f&lt;/code&gt; （强制）选项。</target>
        </trans-unit>
        <trans-unit id="9bd7293224a598d82d7fb9b059bf233156e9f91a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git bundle&lt;/code&gt; command packages objects and references in an archive at the originating machine, which can then be imported into another repository using &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt;, or &lt;code&gt;git clone&lt;/code&gt;, after moving the archive by some means (e.g., by sneakernet).</source>
          <target state="translated">在 &lt;code&gt;git bundle&lt;/code&gt; 命令包的对象和引用在归档在源机器，其然后可以被导入到使用另一种存储库 &lt;code&gt;git fetch&lt;/code&gt; ， &lt;code&gt;git pull&lt;/code&gt; ，或 &lt;code&gt;git clone&lt;/code&gt; ，通过某种手段移动存档（例如，通过sneakernet）之后。</target>
        </trans-unit>
        <trans-unit id="3d9620664b0c9d56c3287a812c3ff6b6d1c8717f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git diff-*&lt;/code&gt; family works by first comparing two sets of files:</source>
          <target state="translated">该 &lt;code&gt;git diff-*&lt;/code&gt; 系列作品第一比较两组文件：</target>
        </trans-unit>
        <trans-unit id="597ca1f538bf6e2f60b9e6f9e15d7129efb080fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fetch&lt;/code&gt; operation always stores the head of the last fetched branch in FETCH_HEAD. For example, if you run &lt;code&gt;git fetch&lt;/code&gt; without specifying a local branch as the target of the operation</source>
          <target state="translated">该 &lt;code&gt;git fetch&lt;/code&gt; 操作总是存储在FETCH_HEAD最后取分支的头。例如，如果您运行 &lt;code&gt;git fetch&lt;/code&gt; 而不将本地分支指定为操作的目标</target>
        </trans-unit>
        <trans-unit id="f809c0db2fabe1b716a044f1ae315c3eafe27e59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fmt-merge-msg&lt;/code&gt; command can be used to give a good default for automated &lt;code&gt;git merge&lt;/code&gt; invocations. The automated message can include the branch description.</source>
          <target state="translated">该 &lt;code&gt;git fmt-merge-msg&lt;/code&gt; 命令可以用来提供一个良好的默认自动 &lt;code&gt;git merge&lt;/code&gt; 调用。自动消息可以包括分支描述。</target>
        </trans-unit>
        <trans-unit id="dae50540309298598631c32bc4ba09615f81ee1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git gc --auto&lt;/code&gt; command will run the &lt;code&gt;pre-auto-gc&lt;/code&gt; hook. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">该 &lt;code&gt;git gc --auto&lt;/code&gt; 命令将运行 &lt;code&gt;pre-auto-gc&lt;/code&gt; 挂钩。有关更多信息，请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cfc7fc175318cd6dff60f69f9572984dc7656815" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git grep&lt;/code&gt; command can search for strings in any version of your project, so</source>
          <target state="translated">该 &lt;code&gt;git grep&lt;/code&gt; 命令可以在项目的任何版本的搜索字符串，所以</target>
        </trans-unit>
        <trans-unit id="10370106ed757f0fcfa619078db112558b3f4b4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git log&lt;/code&gt; command has a weakness: it must present commits in a list. When the history has lines of development that diverged and then merged back together, the order in which &lt;code&gt;git log&lt;/code&gt; presents those commits is meaningless.</source>
          <target state="translated">在 &lt;code&gt;git log&lt;/code&gt; 命令有一个弱点：它必须在列表中出现的提交。当历史上的发展路线发生分歧然后又融合在一起时， &lt;code&gt;git log&lt;/code&gt; 呈现这些提交的顺序就没有意义了。</target>
        </trans-unit>
        <trans-unit id="2918fcbf92a1ba7da67f920488e3f1571c6c776d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git pull&lt;/code&gt; command can also be given &lt;code&gt;.&lt;/code&gt; as the &quot;remote&quot; repository, in which case it just merges in a branch from the current repository; so the commands</source>
          <target state="translated">该 &lt;code&gt;git pull&lt;/code&gt; 命令也可以给予 &lt;code&gt;.&lt;/code&gt; 作为&amp;ldquo;远程&amp;rdquo;存储库，在这种情况下，它只是合并到当前存储库的一个分支中；所以命令</target>
        </trans-unit>
        <trans-unit id="ae6be494d942d11be1fef84bf75e14340e42ba70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git sh-setup&lt;/code&gt; scriptlet is designed to be sourced (using &lt;code&gt;.&lt;/code&gt;) by other shell scripts to set up some variables pointing at the normal Git directories and a few helper shell functions.</source>
          <target state="translated">在 &lt;code&gt;git sh-setup&lt;/code&gt; 小脚本设计（使用进行采购 &lt;code&gt;.&lt;/code&gt; 其他shell脚本）设置一些变量，在普通的Git目录和几个帮手外壳功能指向。</target>
        </trans-unit>
        <trans-unit id="b8d00251834fb59fdb3aac3b6b6d2fd6617d8c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git status&lt;/code&gt; command can be used to obtain a summary of which files have changes that are staged for the next commit.</source>
          <target state="translated">在 &lt;code&gt;git status&lt;/code&gt; 命令可以用来获取其摘要文件有上演下一个提交更改。</target>
        </trans-unit>
        <trans-unit id="1114dd8f20b27292636eee44dbca10b695a7e192" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git submodule add &amp;lt;repo&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt; command does a couple of things:</source>
          <target state="translated">在 &lt;code&gt;git submodule add &amp;lt;repo&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt; 命令执行一两件事情：</target>
        </trans-unit>
        <trans-unit id="851ad3692f8ce86e89fabf82d757953cfb293665" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git svn log&lt;/code&gt; command will not work on repositories using this, either. Using this conflicts with the &lt;code&gt;useSvmProps&lt;/code&gt; option for (hopefully) obvious reasons.</source>
          <target state="translated">该 &lt;code&gt;git svn log&lt;/code&gt; 命令将不会使用该资料库的工作，无论是。出于明显的原因，使用此方法与 &lt;code&gt;useSvmProps&lt;/code&gt; 选项冲突。</target>
        </trans-unit>
        <trans-unit id="54f2e5960f99dce6a894019f61b5f183cfaf541a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git switch&lt;/code&gt; command normally expects a branch head, but will also accept an arbitrary commit when invoked with --detach; for example, you can check out the commit referenced by a tag:</source>
          <target state="translated">在 &lt;code&gt;git switch&lt;/code&gt; 命令通常期望的分支头，同时也将接受当与--detach调用任意提交; 例如，您可以签出标签引用的提交：</target>
        </trans-unit>
        <trans-unit id="5df4353714e03396f22186d308b555d9fc45aa0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git unpack-objects&lt;/code&gt; command can read the packed archive and expand the objects contained in the pack into &quot;one-file one-object&quot; format; this is typically done by the smart-pull commands when a pack is created on-the-fly for efficient network transport by their peers.</source>
          <target state="translated">该 &lt;code&gt;git unpack-objects&lt;/code&gt; 命令可以读取打包存档，并展开包含在包中的对象为&amp;ldquo;一个文件一个对象&amp;rdquo;的格式; 当动态创建数据包以使其对等方高效进行网络传输时，通常通过smart-pull命令完成此操作。</target>
        </trans-unit>
        <trans-unit id="472b18d3af19081ec08acbffb4a8b9828ded3de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git write-tree&lt;/code&gt; command refuses to write a nonsensical tree, and it will complain about unmerged entries if it sees a single entry that is not stage 0.</source>
          <target state="translated">该 &lt;code&gt;git write-tree&lt;/code&gt; 命令不听使唤了一个荒谬的树，它会抱怨未合并的项目，如果它看到一个条目不是0期。</target>
        </trans-unit>
        <trans-unit id="57ed6fd41631cf164adf8f1a5f87022b80e95155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git-fetch&lt;/code&gt; command, with no arguments, will update all of the remote-tracking branches to the latest version found in the original repository. It will not touch any of your own branches&amp;mdash;​not even the &quot;master&quot; branch that was created for you on clone.</source>
          <target state="translated">该 &lt;code&gt;git-fetch&lt;/code&gt; 命令，不带任何参数，将所有的远程跟踪分支更新到了原版本库中的最新版本。它不会碰到您自己的任何分支-甚至不会为克隆上为您创建的&amp;ldquo; master&amp;rdquo;分支。</target>
        </trans-unit>
        <trans-unit id="b7a1f970e8485b643b6fd9d3ee5bf5ec87b44b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gitlink&lt;/code&gt; entry contains the object name of the commit that the superproject expects the submodule&amp;rsquo;s working directory to be at.</source>
          <target state="translated">该 &lt;code&gt;gitlink&lt;/code&gt; 条目包含对象名称的提交是上层项目预计子模块的工作目录是在。</target>
        </trans-unit>
        <trans-unit id="20a22a2e8dd656430183eebd26fcd541802b3980" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;help.browser&lt;/code&gt;, &lt;code&gt;web.browser&lt;/code&gt; and &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; will also be checked if the &lt;code&gt;web&lt;/code&gt; format is chosen (either by command-line option or configuration variable). See &lt;code&gt;-w|--web&lt;/code&gt; in the OPTIONS section above and git-web{litdd}browse[1].</source>
          <target state="translated">的 &lt;code&gt;help.browser&lt;/code&gt; ， &lt;code&gt;web.browser&lt;/code&gt; 和 &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 也将被如果检查的 &lt;code&gt;web&lt;/code&gt; 被选择的格式（通过命令行选项或配置变量）。请参阅上面&amp;ldquo;选项&amp;rdquo;部分中的 &lt;code&gt;-w|--web&lt;/code&gt; 和git-web {litdd} browse [1]。</target>
        </trans-unit>
        <trans-unit id="d643b3df461bdc6854f7d047b7c0264699b4e1d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;includeIf&lt;/code&gt; sections allow you to include config directives from another source. These sections behave identically to each other with the exception that &lt;code&gt;includeIf&lt;/code&gt; sections may be ignored if their condition does not evaluate to true; see &quot;Conditional includes&quot; below.</source>
          <target state="translated">在 &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;includeIf&lt;/code&gt; 部分允许您包括来自其他来源的配置指令。这些部分的行为相同，不同之处在于，如果条件条件未为true ，则 &lt;code&gt;includeIf&lt;/code&gt; 部分可能会被忽略；请参阅下面的&amp;ldquo;有条件的包含&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="25df8c5531688eabec317d8bad065a9bd5755f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; command associates a label with the current HEAD when that command is executed. These labels are created as worktree-local refs (&lt;code&gt;refs/rewritten/&amp;lt;label&amp;gt;&lt;/code&gt;) that will be deleted when the rebase finishes. That way, rebase operations in multiple worktrees linked to the same repository do not interfere with one another. If the &lt;code&gt;label&lt;/code&gt; command fails, it is rescheduled immediately, with a helpful message how to proceed.</source>
          <target state="translated">所述 &lt;code&gt;label&lt;/code&gt; 的命令被执行的命令时，标签与当前HEAD相关联。这些标签被创建为工作树本地引用（ &lt;code&gt;refs/rewritten/&amp;lt;label&amp;gt;&lt;/code&gt; rewrite / &amp;lt;label&amp;gt;），在完成基准调整后将被删除。这样，链接到同一存储库的多个工作树中的变基操作不会相互干扰。如果 &lt;code&gt;label&lt;/code&gt; 命令失败，则会立即重新安排其时间，并提供一条有用的消息，说明如何继续。</target>
        </trans-unit>
        <trans-unit id="a21f07c748b4f824d325c5d844a166616c79a19e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list&lt;/code&gt; command produces a list of refs in which each ref may be followed by a list of attributes. The following ref list attributes are defined.</source>
          <target state="translated">该 &lt;code&gt;list&lt;/code&gt; 命令产生参其中每个裁判可以跟随的属性列表的列表。定义了以下引用列表属性。</target>
        </trans-unit>
        <trans-unit id="a1948673e2dc6e9b36baf9466260194608388c73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ls&lt;/code&gt; command can also be used where a &lt;code&gt;filemodify&lt;/code&gt; directive can appear, allowing it to be used in the middle of a commit.</source>
          <target state="translated">的 &lt;code&gt;ls&lt;/code&gt; 命令还可以用于其中 &lt;code&gt;filemodify&lt;/code&gt; 指令可以出现，允许它在一个提交中间使用。</target>
        </trans-unit>
        <trans-unit id="9f751fdc4139000f76be8c4b7f0362d024d6ccd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maint&lt;/code&gt; branch should now be fast-forwarded to the newly released code so that maintenance fixes can be tracked for the current release:</source>
          <target state="translated">现在应该将 &lt;code&gt;maint&lt;/code&gt; 分支快速转发到新发布的代码，以便可以跟踪当前版本的维护修补程序：</target>
        </trans-unit>
        <trans-unit id="3d08be0d91fe4ba76005ea415ec8dd980a19baaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;man.viewer&lt;/code&gt; configuration variable will be checked if the &lt;code&gt;man&lt;/code&gt; format is chosen. The following values are currently supported:</source>
          <target state="translated">所述 &lt;code&gt;man.viewer&lt;/code&gt; 如果配置变量将被检查 &lt;code&gt;man&lt;/code&gt; 被选择的格式。当前支持以下值：</target>
        </trans-unit>
        <trans-unit id="4d99fda454f21ad231a7b020da5a33fbc1590dfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;master&lt;/code&gt; branch is supposed to be a superset of &lt;code&gt;maint&lt;/code&gt;. If this condition does not hold, then &lt;code&gt;maint&lt;/code&gt; contains some commits that are not included on &lt;code&gt;master&lt;/code&gt;. The fixes represented by those commits will therefore not be included in your feature release.</source>
          <target state="translated">该 &lt;code&gt;master&lt;/code&gt; 分支应该是一个超集 &lt;code&gt;maint&lt;/code&gt; 。如果此条件不成立，则 &lt;code&gt;maint&lt;/code&gt; 包含 &lt;code&gt;master&lt;/code&gt; 上未包括的某些提交。因此，这些提交表示的修复将不会包含在您的功能版本中。</target>
        </trans-unit>
        <trans-unit id="60a9438818e32daade34327aac8510a028d0a280" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.driver&lt;/code&gt; variable&amp;rsquo;s value is used to construct a command to run to merge ancestor&amp;rsquo;s version (&lt;code&gt;%O&lt;/code&gt;), current version (&lt;code&gt;%A&lt;/code&gt;) and the other branches' version (&lt;code&gt;%B&lt;/code&gt;). These three tokens are replaced with the names of temporary files that hold the contents of these versions when the command line is built. Additionally, %L will be replaced with the conflict marker size (see below).</source>
          <target state="translated">的 &lt;code&gt;merge.*.driver&lt;/code&gt; 变量的值被用来构建一个命令来运行，以合并的祖先的版本（ &lt;code&gt;%O&lt;/code&gt; ），当前版本（ &lt;code&gt;%A&lt;/code&gt; ），另一个分支的版本（ &lt;code&gt;%B&lt;/code&gt; ）。在构建命令行时，这三个标记将替换为保存这些版本内容的临时文件的名称。此外，％L将替换为冲突标记大小（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="8135860bcb3c213dc65a79f9d59c1c4cf76a9b52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.name&lt;/code&gt; variable gives the driver a human-readable name.</source>
          <target state="translated">该 &lt;code&gt;merge.*.name&lt;/code&gt; 变量给司机一个人类可读的名称。</target>
        </trans-unit>
        <trans-unit id="531f58358e8d95bd1e04306b8f06edec09e06aba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.recursive&lt;/code&gt; variable specifies what other merge driver to use when the merge driver is called for an internal merge between common ancestors, when there are more than one. When left unspecified, the driver itself is used for both internal merge and the final merge.</source>
          <target state="translated">该 &lt;code&gt;merge.*.recursive&lt;/code&gt; 变量指定什么其他的合并驱动程序时，有一个以上的使用时，合并驱动程序称为共同祖先之间的内部合并。如果未指定，则驱动程序本身将用于内部合并和最终合并。</target>
        </trans-unit>
        <trans-unit id="0e9e9f9df980dcf05008ee310843fafb365f76e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge&lt;/code&gt; command will merge the specified revision(s) into whatever is HEAD at that time. With &lt;code&gt;-C &amp;lt;original-commit&amp;gt;&lt;/code&gt;, the commit message of the specified merge commit will be used. When the &lt;code&gt;-C&lt;/code&gt; is changed to a lower-case &lt;code&gt;-c&lt;/code&gt;, the message will be opened in an editor after a successful merge so that the user can edit the message.</source>
          <target state="translated">该 &lt;code&gt;merge&lt;/code&gt; 命令将合并指定的修订版本到什么是HEAD在那个时候。通过 &lt;code&gt;-C &amp;lt;original-commit&amp;gt;&lt;/code&gt; ，将使用指定的合并提交的提交消息。当 &lt;code&gt;-C&lt;/code&gt; 更改为小写字母 &lt;code&gt;-c&lt;/code&gt; 时，成功合并后，该消息将在编辑器中打开，以便用户可以编辑该消息。</target>
        </trans-unit>
        <trans-unit id="103d9db55b62f87264ea4e2293c619e5e886c09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode &amp;lt;mode&amp;gt;,&amp;lt;mode&amp;gt;..&amp;lt;mode&amp;gt;&lt;/code&gt; line appears only if at least one of the &amp;lt;mode&amp;gt; is different from the rest. Extended headers with information about detected contents movement (renames and copying detection) are designed to work with diff of two &amp;lt;tree-ish&amp;gt; and are not used by combined diff format.</source>
          <target state="translated">的 &lt;code&gt;mode &amp;lt;mode&amp;gt;,&amp;lt;mode&amp;gt;..&amp;lt;mode&amp;gt;&lt;/code&gt; 线只有在&amp;lt;模式&amp;gt;中的至少一个是从所述静止不同出现。具有有关检测到的内容移动（重命名和复制检测）信息的扩展头设计用于处理两个&amp;lt;tree-ish&amp;gt;的diff，并且不被组合的diff格式使用。</target>
        </trans-unit>
        <trans-unit id="245bf1c27c1e24c16ea60d971116c678983044e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-pre-submit&lt;/code&gt; hook is executed if it exists and is executable. The hook takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevents &lt;code&gt;git-p4 submit&lt;/code&gt; from launching.</source>
          <target state="translated">如果 &lt;code&gt;p4-pre-submit&lt;/code&gt; 钩存在且可执行，则执行该钩。挂钩不带参数，标准输入也不带任何内容。从此脚本以非零状态退出会阻止 &lt;code&gt;git-p4 submit&lt;/code&gt; 启动。</target>
        </trans-unit>
        <trans-unit id="55ac82e7ce6eab5b9d775518541be1b358e64d26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;post-update&lt;/code&gt; hook can tell what are the heads that were pushed, but it does not know what their original and updated values are, so it is a poor place to do log old..new. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook does get both original and updated values of the refs. You might consider it instead if you need them.</source>
          <target state="translated">在 &lt;code&gt;post-update&lt;/code&gt; 挂钩可以告诉什么是推送的头，但它不知道他们原来的和更新的值，所以它是做记录old..new一个穷地方。在&lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;后收到&lt;/em&gt;&lt;/a&gt;钩并得到裁判的原件和更新的值。如果需要，可以考虑考虑。</target>
        </trans-unit>
        <trans-unit id="7b1878af31d43f94d962552d8195f8f92835c4ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pre-receive&lt;/code&gt; hook MUST NOT update any refs to point to quarantined objects. Other programs accessing the repository will not be able to see the objects (and if the pre-receive hook fails, those refs would become corrupted). For safety, any ref updates from within &lt;code&gt;pre-receive&lt;/code&gt; are automatically rejected.</source>
          <target state="translated">在 &lt;code&gt;pre-receive&lt;/code&gt; 钩不得更新任何裁判给点隔离的对象。其他访问存储库的程序将无法查看对象（如果预接收挂钩失败，则这些引用将被损坏）。为了安全起见，来自 &lt;code&gt;pre-receive&lt;/code&gt; 内部的所有参考更新都会被自动拒绝。</target>
        </trans-unit>
        <trans-unit id="eb98cabc50bf16dce560817c25a1c4d64601cce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pu&lt;/code&gt; branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; &lt;code&gt;tmp&lt;/code&gt; will not be.</source>
          <target state="translated">该 &lt;code&gt;pu&lt;/code&gt; 即使它没有快进的，因为它是一个加号前缀分公司将被更新; &lt;code&gt;tmp&lt;/code&gt; 不会。</target>
        </trans-unit>
        <trans-unit id="d5f7235d0f9a5c833ca324eff7dc4ec19b6e7285" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pull&lt;/code&gt; command knows where to get updates from because of certain configuration variables that were set by the first &lt;code&gt;git clone&lt;/code&gt; command; see &lt;code&gt;git config -l&lt;/code&gt; and the &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; man page for details.</source>
          <target state="translated">由于第一个 &lt;code&gt;git clone&lt;/code&gt; 命令设置了某些配置变量，因此 &lt;code&gt;pull&lt;/code&gt; 命令知道从何处获取更新。有关详细信息，请参见 &lt;code&gt;git config -l&lt;/code&gt; 和&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;手册页。</target>
        </trans-unit>
        <trans-unit id="9716ab4c9bb8eabfdb4d2f2052c2761838dfc4ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r1^!&lt;/code&gt; notation includes commit &lt;code&gt;r1&lt;/code&gt; but excludes all of its parents. By itself, this notation denotes the single commit &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;r1^!&lt;/code&gt; 表示法包括提交 &lt;code&gt;r1&lt;/code&gt; ,但不包括其所有父项。该符号本身表示单个提交 &lt;code&gt;r1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec7b0d87246117fbc7ede1e9fb5e445953432dc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r1^@&lt;/code&gt; notation means all parents of &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;r1^@&lt;/code&gt; 符号表示的所有家长 &lt;code&gt;r1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="906a6c33616cfaeeffbd4277ee44152fa9cd28f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;raw&lt;/code&gt; format shows the entire commit exactly as stored in the commit object. Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and &lt;code&gt;parents&lt;/code&gt; information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with &lt;code&gt;git log --raw&lt;/code&gt;. To get full object names in a raw diff format, use &lt;code&gt;--no-abbrev&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;raw&lt;/code&gt; 格式示出了整个提交完全一样存储在commit对象。值得注意的是，无论是否使用--abbrev或--no-abbrev，哈希值都会完整显示，并且 &lt;code&gt;parents&lt;/code&gt; 信息显示了真正的父级提交，而没有考虑嫁接或简化历史记录。注意，这种格式会影响提交的显示方式，但不会影响diff的显示方式，例如 &lt;code&gt;git log --raw&lt;/code&gt; 。要获取原始diff格式的完整对象名称，请使用 &lt;code&gt;--no-abbrev&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e2ae08cd51826a72547a4936e1fee7033d540d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursive&lt;/code&gt; strategy can take the following options:</source>
          <target state="translated">该 &lt;code&gt;recursive&lt;/code&gt; 策略可以采取下列选项：</target>
        </trans-unit>
        <trans-unit id="2274cd304e0d47984767afeee4d877ca51fbdd54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refs/heads/*&lt;/code&gt; namespace will only accept commit objects, and updates only if they can be fast-forwarded.</source>
          <target state="translated">该 &lt;code&gt;refs/heads/*&lt;/code&gt; 命名空间将只接受提交对象，且仅当他们可以更新快进。</target>
        </trans-unit>
        <trans-unit id="73d202d810478ee27aec0a92a74e6cf7efe8db45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refs/tags/*&lt;/code&gt; namespace will accept any kind of object (as commits, trees and blobs can be tagged), and any updates to them will be rejected.</source>
          <target state="translated">该 &lt;code&gt;refs/tags/*&lt;/code&gt; 命名空间将接受任何类型的对象（如提交，树木和斑点可以被标记），并给他们任何更新将被拒绝。</target>
        </trans-unit>
        <trans-unit id="8f1fa8b6ca43d585bbef39f492a9db57e9ecc9a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reset&lt;/code&gt; command can also be used to create lightweight (non-annotated) tags. For example:</source>
          <target state="translated">该 &lt;code&gt;reset&lt;/code&gt; 命令也可以用于创建轻量（未标注）标签。例如：</target>
        </trans-unit>
        <trans-unit id="bd2e909f258c6aa58fa07c5acaee67caeb1da10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reset&lt;/code&gt; command resets the HEAD, index and worktree to the specified revision. It is similar to an &lt;code&gt;exec git reset --hard &amp;lt;label&amp;gt;&lt;/code&gt;, but refuses to overwrite untracked files. If the &lt;code&gt;reset&lt;/code&gt; command fails, it is rescheduled immediately, with a helpful message how to edit the todo list (this typically happens when a &lt;code&gt;reset&lt;/code&gt; command was inserted into the todo list manually and contains a typo).</source>
          <target state="translated">的 &lt;code&gt;reset&lt;/code&gt; 命令重置HEAD，索引和worktree到指定的修订版本。它类似于 &lt;code&gt;exec git reset --hard &amp;lt;label&amp;gt;&lt;/code&gt; ，但是拒绝覆盖未跟踪的文件。如果 &lt;code&gt;reset&lt;/code&gt; 命令失败，则会立即重新安排时间表，并提供一条有用的消息，说明如何编辑待办事项列表（通常在将 &lt;code&gt;reset&lt;/code&gt; 命令手动插入待办事项列表并包含错字时会发生这种情况）。</target>
        </trans-unit>
        <trans-unit id="06cca2918a8a255dfff1d384369e4d4195e47f51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shortlog&lt;/code&gt; view is more compact; it shows one commit per line.</source>
          <target state="translated">所述 &lt;code&gt;shortlog&lt;/code&gt; 视图更紧凑; 它显示每行一次提交。</target>
        </trans-unit>
        <trans-unit id="49d7635e517e74681985e2d5acfe0d3faa2b57eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tagger&lt;/code&gt; command uses the same format as &lt;code&gt;committer&lt;/code&gt; within &lt;code&gt;commit&lt;/code&gt;; again see above for details.</source>
          <target state="translated">所述 &lt;code&gt;tagger&lt;/code&gt; 命令使用相同的格式 &lt;code&gt;committer&lt;/code&gt; 内 &lt;code&gt;commit&lt;/code&gt; ; 再次参见上面的详细信息。</target>
        </trans-unit>
        <trans-unit id="c5d1574573f9cb9deb3517e06eb81c31c726f5b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;textconv&lt;/code&gt; config option is used to define a program for performing such a conversion. The program should take a single argument, the name of a file to convert, and produce the resulting text on stdout.</source>
          <target state="translated">所述 &lt;code&gt;textconv&lt;/code&gt; 配置选项被用来定义用于执行这种转换的程序。该程序应使用单个参数，即要转换的文件的名称，并在stdout上生成结果文本。</target>
        </trans-unit>
        <trans-unit id="5a024de933cb7ecb7f2684cd23c20dd59cced4c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tformat:&lt;/code&gt; format works exactly like &lt;code&gt;format:&lt;/code&gt;, except that it provides &quot;terminator&quot; semantics instead of &quot;separator&quot; semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries. This means that the final entry of a single-line format will be properly terminated with a new line, just as the &quot;oneline&quot; format does. For example:</source>
          <target state="translated">该 &lt;code&gt;tformat:&lt;/code&gt; 格式的操作完全相同 &lt;code&gt;format:&lt;/code&gt; ，不同之处在于它提供了&amp;ldquo;终结者&amp;rdquo;的语义，而不是&amp;ldquo;分隔符&amp;rdquo;的语义。换句话说，每个提交都附加了消息终止符（通常是换行符），而不是在条目之间放置分隔符。这意味着单行格式的最后输入将以换行正确终止，就像&amp;ldquo; oneline&amp;rdquo;格式一样。例如：</target>
        </trans-unit>
        <trans-unit id="52696bbc1bd35a1c1c6d78b6535a11990db3bb34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables determine what ends up in the &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; field of commit objects. If you need the &lt;code&gt;author&lt;/code&gt; or &lt;code&gt;committer&lt;/code&gt; to be different, the &lt;code&gt;author.name&lt;/code&gt;, &lt;code&gt;author.email&lt;/code&gt;, &lt;code&gt;committer.name&lt;/code&gt; or &lt;code&gt;committer.email&lt;/code&gt; variables can be set. Also, all of these can be overridden by the &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt;, &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; and &lt;code&gt;EMAIL&lt;/code&gt; environment variables. See &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; for more information.</source>
          <target state="translated">该 &lt;code&gt;user.name&lt;/code&gt; 和 &lt;code&gt;user.email&lt;/code&gt; 变量决定什么在结束了 &lt;code&gt;author&lt;/code&gt; 与 &lt;code&gt;committer&lt;/code&gt; 提交的对象领域。如果您需要 &lt;code&gt;author&lt;/code&gt; 或 &lt;code&gt;committer&lt;/code&gt; 者不同，则可以设置 &lt;code&gt;author.name&lt;/code&gt; ， &lt;code&gt;author.email&lt;/code&gt; ， &lt;code&gt;committer.name&lt;/code&gt; 或 &lt;code&gt;committer.email&lt;/code&gt; 变量。此外，所有这些都可以被 &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt; ， &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt; ， &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt; ， &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; 和 &lt;code&gt;EMAIL&lt;/code&gt; 环境变量覆盖。参见&lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]&lt;/a&gt; 想要查询更多的信息。</target>
        </trans-unit>
        <trans-unit id="16ffcc56d5f44fe2ccdfd792b9ad74a964b837f9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&amp;hellip;​&lt;/em&gt; (three-dot) Symmetric Difference Notation</source>
          <target state="translated">该&lt;em&gt;...&lt;/em&gt;（三个点）对称差符号</target>
        </trans-unit>
        <trans-unit id="3ca01d997f3f16d56fc54554bfe9b469c32c5dff" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;..&lt;/em&gt; (two-dot) Range Notation</source>
          <target state="translated">该&lt;em&gt;..&lt;/em&gt;（双点）范围标识</target>
        </trans-unit>
        <trans-unit id="28292c9406d9116658f021a9e7e686e22523649d" translate="yes" xml:space="preserve">
          <source>The C rewrite is first included with Git version 2.22 (and Git for Windows version 2.19). This option serves as an escape hatch to re-enable the legacy version in case any bugs are found in the rewrite. This option and the shell script version of &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; will be removed in some future release.</source>
          <target state="translated">C重写首先包含在Git 2.22版（和Git for Windows 2.19版）中。如果在重写中发现任何错误，此选项可作为逃生窗口以重新启用旧版本。此选项和&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;的shell脚本版本将在将来的发行版中删除。</target>
        </trans-unit>
        <trans-unit id="dbe462d7e2f126482bf0dec3d004def2c9c89bb6" translate="yes" xml:space="preserve">
          <source>The CVS module you want to import. Relative to &amp;lt;CVSROOT&amp;gt;. If not given, &lt;code&gt;git cvsimport&lt;/code&gt; tries to read it from &lt;code&gt;CVS/Repository&lt;/code&gt;.</source>
          <target state="translated">您要导入的CVS模块。相对于&amp;lt;CVSROOT&amp;gt;。如果未给出， &lt;code&gt;git cvsimport&lt;/code&gt; 尝试从 &lt;code&gt;CVS/Repository&lt;/code&gt; 读取它。</target>
        </trans-unit>
        <trans-unit id="d9fdb00c7bf3f2937ed399ea5a7eb5783533387f" translate="yes" xml:space="preserve">
          <source>The Event Format Target</source>
          <target state="translated">事件格式目标</target>
        </trans-unit>
        <trans-unit id="91f31eeacecff37ec38db2aff37269235d7422bb" translate="yes" xml:space="preserve">
          <source>The GIT_TRACE_&amp;lt;key&amp;gt; mechanism allows each &amp;lt;key&amp;gt; to write to a different file (in addition to just stderr).</source>
          <target state="translated">GIT_TRACE_ &amp;lt;key&amp;gt;机制允许每个&amp;lt;key&amp;gt;写入不同的文件（除了stderr之外）。</target>
        </trans-unit>
        <trans-unit id="eb9c24f633d0777727caf33c8ede260c0246d232" translate="yes" xml:space="preserve">
          <source>The GPG key ID of the key that signed the push certificate.</source>
          <target state="translated">签署推送证书的密钥的 GPG 密钥 ID。</target>
        </trans-unit>
        <trans-unit id="7fd047e9e0dcddc0ec24d2bfa4a8d0b4477b60c4" translate="yes" xml:space="preserve">
          <source>The Git Repository</source>
          <target state="translated">Git 仓库</target>
        </trans-unit>
        <trans-unit id="ec69c4a3fd32f0743df23ab218ec13475fdae8cc" translate="yes" xml:space="preserve">
          <source>The Git configuration file contains a number of variables that affect the Git commands' behavior. The files &lt;code&gt;.git/config&lt;/code&gt; and optionally &lt;code&gt;config.worktree&lt;/code&gt; (see &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; below) in each repository are used to store the configuration for that repository, and &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; is used to store a per-user configuration as fallback values for the &lt;code&gt;.git/config&lt;/code&gt; file. The file &lt;code&gt;/etc/gitconfig&lt;/code&gt; can be used to store a system-wide default configuration.</source>
          <target state="translated">Git配置文件包含许多影响Git命令行为的变量。每个存储库中的文件 &lt;code&gt;.git/config&lt;/code&gt; 和可选的 &lt;code&gt;config.worktree&lt;/code&gt; （请参见下面的 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; ）用于存储该存储库的配置，而 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 用于存储每个用户的配置作为后备值在 &lt;code&gt;.git/config&lt;/code&gt; 文件。 &lt;code&gt;/etc/gitconfig&lt;/code&gt; 文件可用于存储系统范围的默认配置。</target>
        </trans-unit>
        <trans-unit id="c4676de1f2b8af7673ad60d0d802fc7e29d8da30" translate="yes" xml:space="preserve">
          <source>The Git object directory contains a &lt;code&gt;pack&lt;/code&gt; directory containing packfiles (with suffix &quot;.pack&quot;) and pack-indexes (with suffix &quot;.idx&quot;). The pack-indexes provide a way to lookup objects and navigate to their offset within the pack, but these must come in pairs with the packfiles. This pairing depends on the file names, as the pack-index differs only in suffix with its pack- file. While the pack-indexes provide fast lookup per packfile, this performance degrades as the number of packfiles increases, because abbreviations need to inspect every packfile and we are more likely to have a miss on our most-recently-used packfile. For some large repositories, repacking into a single packfile is not feasible due to storage space or excessive repack times.</source>
          <target state="translated">Git对象目录包含一个 &lt;code&gt;pack&lt;/code&gt; 目录，该目录包含packfiles（后缀&amp;ldquo; .pack&amp;rdquo;）和pack-indexes（后缀&amp;ldquo; .idx&amp;rdquo;）。包索引提供了一种查找对象并导航到包内偏移量的方法，但这些对象必须与包文件成对出现。配对取决于文件名，因为pack-index仅在带有后缀的pack-file中有所不同。尽管pack-indexs提供了每个packfile的快速查找功能，但是随着packfile数量的增加，这种性能会下降，因为缩写需要检查每个packfile，而我们最有可能会错过最近使用的packfile。对于某些大型存储库，由于存储空间或重新包装时间过多，将其重新包装到单个packfile中是不可行的。</target>
        </trans-unit>
        <trans-unit id="a2329c4ac9f08d776040ac221ffa562b7323c3f6" translate="yes" xml:space="preserve">
          <source>The Git protocol gives better performance and reliability, but on a host with a web server set up, HTTP exports may be simpler to set up.</source>
          <target state="translated">Git协议能提供更好的性能和可靠性,但在设置了Web服务器的主机上,HTTP导出的设置可能更简单。</target>
        </trans-unit>
        <trans-unit id="1179b23d825b14c0a26acd1779bd21e4b7a2880e" translate="yes" xml:space="preserve">
          <source>The Git remote to import this CVS repository into. Moves all CVS branches into remotes/&amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt; akin to the way &lt;code&gt;git clone&lt;/code&gt; uses &lt;code&gt;origin&lt;/code&gt; by default.</source>
          <target state="translated">将这个CVS信息库导入到的Git远程。将所有CVS分支移动到类似于 &lt;code&gt;git clone&lt;/code&gt; 默认使用 &lt;code&gt;origin&lt;/code&gt; 的方式的remotes / &amp;lt;remote&amp;gt; / &amp;lt;branch&amp;gt;中。</target>
        </trans-unit>
        <trans-unit id="bd47eb27f30e04cbdc75cd21789edadd8836d3bb" translate="yes" xml:space="preserve">
          <source>The Git repository browser</source>
          <target state="translated">Git 仓库浏览器</target>
        </trans-unit>
        <trans-unit id="076055123196294023f50dc3852a8243be06956f" translate="yes" xml:space="preserve">
          <source>The Git repository browser. Shows branches, commit history and file differences. gitk is the utility started by &lt;code&gt;git gui&lt;/code&gt;'s Repository Visualize actions.</source>
          <target state="translated">Git存储库浏览器。显示分支，提交历史记录和文件差异。gitk是由 &lt;code&gt;git gui&lt;/code&gt; 的 &amp;ldquo;存储库可视化&amp;rdquo;操作启动的实用程序。</target>
        </trans-unit>
        <trans-unit id="703dfd23887a83d4329e915dd0bcbd7608c6b6a7" translate="yes" xml:space="preserve">
          <source>The Git repository to import to. If the directory doesn&amp;rsquo;t exist, it will be created. Default is the current directory.</source>
          <target state="translated">要导入到的Git存储库。如果该目录不存在，将创建该目录。默认为当前目录。</target>
        </trans-unit>
        <trans-unit id="6970e04ce98d2b4a3b2c6e8de2880e4a745e2c4f" translate="yes" xml:space="preserve">
          <source>The HEAD then refers to the SHA-1 of the commit instead of to a branch, and git branch shows that you are no longer on a branch:</source>
          <target state="translated">然后,HEAD指的是提交的SHA-1,而不是分支,git branch显示你已经不在一个分支上了。</target>
        </trans-unit>
        <trans-unit id="895d60d2bce01273de11df4a950c78fe3184bcf0" translate="yes" xml:space="preserve">
          <source>The HTTP USER_AGENT string presented to an HTTP server. The default value represents the version of the client Git such as git/1.7.1. This option allows you to override this value to a more common value such as Mozilla/4.0. This may be necessary, for instance, if connecting through a firewall that restricts HTTP connections to a set of common USER_AGENT strings (but not including those like git/1.7.1). Can be overridden by the &lt;code&gt;GIT_HTTP_USER_AGENT&lt;/code&gt; environment variable.</source>
          <target state="translated">提供给HTTP服务器的HTTP USER_AGENT字符串。默认值表示客户端Git的版本，例如git / 1.7.1。此选项使您可以将此值替代为更常见的值，例如Mozilla / 4.0。例如，如果通过限制HTTP连接到一组常见USER_AGENT字符串（但不包括git / 1.7.1的字符串）的防火墙进行连接，则可能有必要。可以被 &lt;code&gt;GIT_HTTP_USER_AGENT&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="00aa9820c66c0255936f6c8707aec2ad36a5c140" translate="yes" xml:space="preserve">
          <source>The HTTP daemon command-line that will be executed. Command-line options may be specified here, and the configuration file will be added at the end of the command-line. Currently apache2, lighttpd, mongoose, plackup, python and webrick are supported. (Default: lighttpd)</source>
          <target state="translated">将要执行的HTTP守护进程命令行。命令行选项可以在这里指定,配置文件将添加在命令行的最后。目前支持apache2、lighttpd、mongoose、plackup、python和webrick。(默认:lighttpd)</target>
        </trans-unit>
        <trans-unit id="adee6c32cf5372a9cc214e1cabc3f604f4a421cf" translate="yes" xml:space="preserve">
          <source>The HTTP daemon command-line to start gitweb on your working repository. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">HTTP守护程序命令行，用于在您的工作存储库上启动gitweb。参见&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a20118bebd861685578a19065b0fb24ab670ec89" translate="yes" xml:space="preserve">
          <source>The MIDX file format uses a chunk-based approach (similar to the commit-graph file) that allows optional data to be added.</source>
          <target state="translated">MIDX文件格式使用基于分块的方法(类似于提交-图形文件),允许添加可选的数据。</target>
        </trans-unit>
        <trans-unit id="64e372cd9f501c41226d338629f4adfe7884c507" translate="yes" xml:space="preserve">
          <source>The MIDX is stored in a file named &lt;code&gt;multi-pack-index&lt;/code&gt; in the .git/objects/pack directory. This could be stored in the pack directory of an alternate. It refers only to packfiles in that same directory.</source>
          <target state="translated">MIDX存储在.git / objects / pack目录中名为 &lt;code&gt;multi-pack-index&lt;/code&gt; 的文件中。这可以存储在备用目录的pack目录中。它仅引用相同目录中的packfiles。</target>
        </trans-unit>
        <trans-unit id="be240040a2b303919e9f8b3f8c55bd2d4b871823" translate="yes" xml:space="preserve">
          <source>The MIDX keeps only one record per object ID. If an object appears in multiple packfiles, then the MIDX selects the copy in the most- recently modified packfile.</source>
          <target state="translated">MIDX 每个对象 ID 只保留一条记录。如果一个对象出现在多个包文件中,那么 MIDX 会选择最近修改的包文件中的副本。</target>
        </trans-unit>
        <trans-unit id="d248ab48f510e2fbd4b16391dc71868ce2bb9eb7" translate="yes" xml:space="preserve">
          <source>The MUA corrupted your patch; &quot;am&quot; would complain that the patch does not apply. Look in the .git/rebase-apply/ subdirectory and see what &lt;code&gt;patch&lt;/code&gt; file contains and check for the common corruption patterns mentioned above.</source>
          <target state="translated">MUA损坏了您的补丁；&amp;ldquo; am&amp;rdquo;会抱怨该补丁不适用。在.git / rebase-apply /子目录中查找并查看 &lt;code&gt;patch&lt;/code&gt; 文件包含的内容，并检查上述常见损坏模式。</target>
        </trans-unit>
        <trans-unit id="dcfedffa2e791a211c838c6711816e41fded8f05" translate="yes" xml:space="preserve">
          <source>The Normal Format Target</source>
          <target state="translated">标准格式目标</target>
        </trans-unit>
        <trans-unit id="500d32200a061b0c3eb8acb59a37b1ba3087273e" translate="yes" xml:space="preserve">
          <source>The Object Database</source>
          <target state="translated">对象数据库</target>
        </trans-unit>
        <trans-unit id="b3b387e6e23160b9001074a3b231e88c333277a0" translate="yes" xml:space="preserve">
          <source>The PERF target is intended for interactive performance analysis during development and is quite noisy.</source>
          <target state="translated">PERF目标是为了在开发过程中进行交互式的性能分析,是相当嘈杂的。</target>
        </trans-unit>
        <trans-unit id="716ba6c2a540215443944eab8349af10087e97bb" translate="yes" xml:space="preserve">
          <source>The Performance Format Target</source>
          <target state="translated">性能格式目标</target>
        </trans-unit>
        <trans-unit id="ca04878afc5a61720c26b830b963e827e884a4f1" translate="yes" xml:space="preserve">
          <source>The SSL version to use when negotiating an SSL connection, if you want to force the default. The available and default version depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; option; see the libcurl documentation for more details on the format of this option and for the ssl version supported. Actually the possible values of this option are:</source>
          <target state="translated">如果要强制使用默认值，则在协商SSL连接时要使用的SSL版本。可用的默认版本取决于libcurl是针对NSS还是OpenSSL构建的，以及所使用的加密库的特定配置。在内部，这会设置 &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; 选项；有关此选项的格式和受支持的ssl版本的更多详细信息，请参见libcurl文档。实际上，此选项的可能值为：</target>
        </trans-unit>
        <trans-unit id="6c8d77384dcf5927fceefc0c82e6aa35599c0a0b" translate="yes" xml:space="preserve">
          <source>The Trace2 API can be used to print debug, performance, and telemetry information to stderr or a file. The Trace2 feature is inactive unless explicitly enabled by enabling one or more Trace2 Targets.</source>
          <target state="translated">Trace2 API 可用于将调试、性能和遥测信息打印到 stderr 或文件中。除非通过启用一个或多个 Trace2 Targets 来明确启用,否则 Trace2 功能是不活跃的。</target>
        </trans-unit>
        <trans-unit id="6bdbd91221731e97e635f28174406bd894d81047" translate="yes" xml:space="preserve">
          <source>The Trace2 API defines a set of high-level messages with known fields, such as (&lt;code&gt;start&lt;/code&gt;: &lt;code&gt;argv&lt;/code&gt;) and (&lt;code&gt;exit&lt;/code&gt;: {&lt;code&gt;exit-code&lt;/code&gt;, &lt;code&gt;elapsed-time&lt;/code&gt;}).</source>
          <target state="translated">Trace2 API定义了一组具有已知字段的高级消息，例如（ &lt;code&gt;start&lt;/code&gt; ： &lt;code&gt;argv&lt;/code&gt; ）和（ &lt;code&gt;exit&lt;/code&gt; ：{ &lt;code&gt;exit-code&lt;/code&gt; ， &lt;code&gt;elapsed-time&lt;/code&gt; }）。</target>
        </trans-unit>
        <trans-unit id="c8d932fd39b46f7d652bfdd2be6511ab09fc4671" translate="yes" xml:space="preserve">
          <source>The Trace2 API is intended to replace the existing (Trace1) printf-style tracing provided by the existing &lt;code&gt;GIT_TRACE&lt;/code&gt; and &lt;code&gt;GIT_TRACE_PERFORMANCE&lt;/code&gt; facilities. During initial implementation, Trace2 and Trace1 may operate in parallel.</source>
          <target state="translated">Trace2 API旨在替代现有 &lt;code&gt;GIT_TRACE&lt;/code&gt; 和 &lt;code&gt;GIT_TRACE_PERFORMANCE&lt;/code&gt; 工具提供的现有（Trace1）printf样式跟踪。在初始实施期间，Trace2和Trace1可以并行运行。</target>
        </trans-unit>
        <trans-unit id="a5397d7e9698d7ad87ff097450bf8a8e1a772416" translate="yes" xml:space="preserve">
          <source>The Trace2 code also defines a set of private functions and data types in the &lt;code&gt;trace2/&lt;/code&gt; directory. These symbols are prefixed with &lt;code&gt;tr2_&lt;/code&gt; and should only be used by functions in &lt;code&gt;trace2.c&lt;/code&gt;.</source>
          <target state="translated">Trace2代码还在 &lt;code&gt;trace2/&lt;/code&gt; 目录中定义了一组私有函数和数据类型。这些符号以 &lt;code&gt;tr2_&lt;/code&gt; 为前缀，并且只能由 &lt;code&gt;trace2.c&lt;/code&gt; 中的函数使用。</target>
        </trans-unit>
        <trans-unit id="8e231fe7d9a0eb53151c1a418399ded2fd9db9e8" translate="yes" xml:space="preserve">
          <source>The URL for a submodule. This variable is copied from the .gitmodules file to the git config via &lt;code&gt;git submodule init&lt;/code&gt;. The user can change the configured URL before obtaining the submodule via &lt;code&gt;git submodule update&lt;/code&gt;. If neither submodule.&amp;lt;name&amp;gt;.active or submodule.active are set, the presence of this variable is used as a fallback to indicate whether the submodule is of interest to git commands. See &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">子模块的URL。此变量通过 &lt;code&gt;git submodule init&lt;/code&gt; 从.gitmodules文件复制到git config 。用户可以在通过 &lt;code&gt;git submodule update&lt;/code&gt; 获得子模块之前更改配置的URL 。如果未设置submodule。&amp;lt;name&amp;gt; .active或submodule.active，则此变量的存在将用作回退，以指示git命令是否对子模块感兴趣。有关详细信息，请参见&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt;和&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="307f8458b88cd1196dc3047eb250fdb8e3348b46" translate="yes" xml:space="preserve">
          <source>The URL of a remote repository. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; or &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">远程存储库的URL。参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;或&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="92c06c873fe7803ddcdb456ba837dbd24d10b389" translate="yes" xml:space="preserve">
          <source>The URL to the remote repository.</source>
          <target state="translated">远程存储库的URL。</target>
        </trans-unit>
        <trans-unit id="846d99295948de526a5621f0a520c5a9a78af747" translate="yes" xml:space="preserve">
          <source>The Workflow</source>
          <target state="translated">工作流程</target>
        </trans-unit>
        <trans-unit id="91d8165377483e9123ecf4a3d5455b3b1999d185" translate="yes" xml:space="preserve">
          <source>The above can also be written as simply</source>
          <target state="translated">上述内容也可以简单写成</target>
        </trans-unit>
        <trans-unit id="13c712cb6756cc53fb3407886d0503d18cb537c0" translate="yes" xml:space="preserve">
          <source>The above command copies all branches from the remote refs/heads/ namespace and stores them to the local refs/remotes/origin/ namespace, unless the branch.&amp;lt;name&amp;gt;.fetch option is used to specify a non-default refspec.</source>
          <target state="translated">上面的命令从远程refs / heads /命名空间复制所有分支，并将它们存储到本地refs / remotes / origin /命名空间，除非使用branch。&amp;lt;name&amp;gt; .fetch选项指定非默认的refspec。</target>
        </trans-unit>
        <trans-unit id="61e1efd32cbb415eea7b734b98558317a6d1aac3" translate="yes" xml:space="preserve">
          <source>The above command would change the origin repository to</source>
          <target state="translated">上面的命令会将源码库改为</target>
        </trans-unit>
        <trans-unit id="cc504649b9359e7717badcdf0f10e04d6127c3a0" translate="yes" xml:space="preserve">
          <source>The above configuration expects your public repositories to live under &lt;code&gt;/pub/git&lt;/code&gt; and will serve them as &lt;code&gt;http://git.domain.org/dir-under-pub-git&lt;/code&gt;, both as clonable Git URL and as browseable gitweb interface. If you then start your &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; with &lt;code&gt;--base-path=/pub/git --export-all&lt;/code&gt; then you can even use the &lt;code&gt;git://&lt;/code&gt; URL with exactly the same path.</source>
          <target state="translated">上面的配置期望您的公共存储库位于 &lt;code&gt;/pub/git&lt;/code&gt; 下，并将它们作为 &lt;code&gt;http://git.domain.org/dir-under-pub-git&lt;/code&gt; ，可克隆的Git URL和可浏览的gitweb界面使用。如果然后使用 &lt;code&gt;--base-path=/pub/git --export-all&lt;/code&gt; 启动&lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt;，那么您甚至可以使用路径完全相同的 &lt;code&gt;git://&lt;/code&gt; URL。</target>
        </trans-unit>
        <trans-unit id="baa5f35656f9b3f3ba646932132fa97233a197b9" translate="yes" xml:space="preserve">
          <source>The above is all you need to know to resolve a simple merge. But Git also provides more information to help resolve conflicts:</source>
          <target state="translated">以上就是解决一个简单的合并问题所需要知道的全部内容。但Git也提供了更多信息来帮助解决冲突。</target>
        </trans-unit>
        <trans-unit id="70fce3bc08ea4ed40bcc99c52f88c26bd24f0b87" translate="yes" xml:space="preserve">
          <source>The above is the description of a Git merge at the lowest level, to help you understand what conceptually happens under the hood. In practice, nobody, not even Git itself, runs &lt;code&gt;git cat-file&lt;/code&gt; three times for this. There is a &lt;code&gt;git merge-index&lt;/code&gt; program that extracts the stages to temporary files and calls a &quot;merge&quot; script on it:</source>
          <target state="translated">上面是最低级别的Git合并的描述，以帮助您了解引擎盖下的概念。实际上，没有人，甚至是Git本身，都没有为此运行过 &lt;code&gt;git cat-file&lt;/code&gt; 3次。有一个 &lt;code&gt;git merge-index&lt;/code&gt; 程序，可将阶段提取到临时文件并在其上调用&amp;ldquo;合并&amp;rdquo;脚本：</target>
        </trans-unit>
        <trans-unit id="eb77c0d462477bf4637c28037a03befbbf605c33" translate="yes" xml:space="preserve">
          <source>The absolute path to the worktree in which the ref is checked out, if it is checked out in any linked worktree. Empty string otherwise.</source>
          <target state="translated">如果ref在任何链接的工作树中被签出,则表示该工作树的绝对路径。否则为空字符串。</target>
        </trans-unit>
        <trans-unit id="76cd9fb4bfcc53cf44ccfea4ed1923acc958405e" translate="yes" xml:space="preserve">
          <source>The accepted attributes are &lt;code&gt;bold&lt;/code&gt;, &lt;code&gt;dim&lt;/code&gt;, &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;blink&lt;/code&gt;, &lt;code&gt;reverse&lt;/code&gt;, &lt;code&gt;italic&lt;/code&gt;, and &lt;code&gt;strike&lt;/code&gt; (for crossed-out or &quot;strikethrough&quot; letters). The position of any attributes with respect to the colors (before, after, or in between), doesn&amp;rsquo;t matter. Specific attributes may be turned off by prefixing them with &lt;code&gt;no&lt;/code&gt; or &lt;code&gt;no-&lt;/code&gt; (e.g., &lt;code&gt;noreverse&lt;/code&gt;, &lt;code&gt;no-ul&lt;/code&gt;, etc).</source>
          <target state="translated">可接受的属性为 &lt;code&gt;bold&lt;/code&gt; ， &lt;code&gt;dim&lt;/code&gt; ， &lt;code&gt;ul&lt;/code&gt; ， &lt;code&gt;blink&lt;/code&gt; ， &lt;code&gt;reverse&lt;/code&gt; ， &lt;code&gt;italic&lt;/code&gt; 和 &lt;code&gt;strike&lt;/code&gt; （对于划线或&amp;ldquo;删除线&amp;rdquo;字母）。任何属性相对于颜色的位置（之前，之后或之间）都无关紧要。可以通过给特定属性加上 &lt;code&gt;no&lt;/code&gt; 或 &lt;code&gt;no-&lt;/code&gt; （例如 &lt;code&gt;noreverse&lt;/code&gt; ， &lt;code&gt;no-ul&lt;/code&gt; 等）来关闭特定属性。</target>
        </trans-unit>
        <trans-unit id="0bb8a69a5cde6b982a60a95e4956ebdf1a59fa5f" translate="yes" xml:space="preserve">
          <source>The accepted patterns in the cone pattern set are:</source>
          <target state="translated">锥型图案集中可接受的图案有:</target>
        </trans-unit>
        <trans-unit id="ec26e1bb6d1ddd903fea6ea4b1aec39f9a4bdff7" translate="yes" xml:space="preserve">
          <source>The action of fixing up manually what a failed automatic &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; left behind.</source>
          <target state="translated">手动修复失败的自动&lt;a href=&quot;#def_merge&quot;&gt;合并&lt;/a&gt;留下的操作。</target>
        </trans-unit>
        <trans-unit id="91929f919cdca3ddad9711d4446a1108e24ab05c" translate="yes" xml:space="preserve">
          <source>The action of updating all or part of the &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; with a &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; or &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; from the &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt;, and updating the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; and &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; if the whole working tree has been pointed at a new &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;.</source>
          <target state="translated">更新的全部或部分行动&lt;a href=&quot;#def_working_tree&quot;&gt;工作树&lt;/a&gt;与&lt;a href=&quot;#def_tree_object&quot;&gt;树对象&lt;/a&gt;或&lt;a href=&quot;#def_blob_object&quot;&gt;BLOB&lt;/a&gt;从&lt;a href=&quot;#def_object_database&quot;&gt;对象数据库&lt;/a&gt;，并更新&lt;a href=&quot;#def_index&quot;&gt;索引&lt;/a&gt;和&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;，如果整个工作树已经指出，在一个新的&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf91c6dac7e4978798d8310657f124dd799f4bf4" translate="yes" xml:space="preserve">
          <source>The action that will be run. Defaults to &lt;code&gt;projects_list&lt;/code&gt; if repo is not set, and to &lt;code&gt;summary&lt;/code&gt; otherwise.</source>
          <target state="translated">将要运行的动作。如果未设置repo，则默认为 &lt;code&gt;projects_list&lt;/code&gt; ，否则为 &lt;code&gt;summary&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e262b52287502541a33fa85d5cf2fdae897da448" translate="yes" xml:space="preserve">
          <source>The active branch LRU, when coupled with the filename string pool and lazy loading of subtrees, allows fast-import to efficiently import projects with 2,000+ branches and 45,114+ files in a very limited memory footprint (less than 2.7 MiB per active branch).</source>
          <target state="translated">活动分支LRU,结合文件名字符串池和子树的懒惰加载,允许快速导入,以非常有限的内存占用(每个活动分支小于2.7 MiB)有效地导入2000多个分支和45114个文件的项目。</target>
        </trans-unit>
        <trans-unit id="5b37048d4139b83b97c29aa7a22d2da66c283ae2" translate="yes" xml:space="preserve">
          <source>The actual configuration line should be on one line.</source>
          <target state="translated">实际的配置行应在一行。</target>
        </trans-unit>
        <trans-unit id="b70c0ba474f3173fff896ac2745af10a69e6cc3b" translate="yes" xml:space="preserve">
          <source>The additional AliasMatch makes it so that</source>
          <target state="translated">额外的AliasMatch使它可以使</target>
        </trans-unit>
        <trans-unit id="d6139a3bd26979c3a7767519a48aa9c385b73634" translate="yes" xml:space="preserve">
          <source>The advantage of doing this is that the history of &lt;code&gt;next&lt;/code&gt; will be clean. For example, some topics merged into &lt;code&gt;next&lt;/code&gt; may have initially looked promising, but were later found to be undesirable or premature. In such a case, the topic is reverted out of &lt;code&gt;next&lt;/code&gt; but the fact remains in the history that it was once merged and reverted. By recreating &lt;code&gt;next&lt;/code&gt;, you give another incarnation of such topics a clean slate to retry, and a feature release is a good point in history to do so.</source>
          <target state="translated">这样做的好处是 &lt;code&gt;next&lt;/code&gt; 的历史将很干净。例如，合并到 &lt;code&gt;next&lt;/code&gt; 主题中的某些主题起初看起来很有希望，但后来被发现是不受欢迎或不成熟的。在这种情况下，该主题会从下 &lt;code&gt;next&lt;/code&gt; 还原出来，但事实是它曾经被合并和还原过。通过重新创建 &lt;code&gt;next&lt;/code&gt; ，您可以使这些主题的另一种形式完全可以重试，并且功能发布是历史上这样做的好时机。</target>
        </trans-unit>
        <trans-unit id="2f1746fed6139a8489ee3d916322bdcbeb17e684" translate="yes" xml:space="preserve">
          <source>The advantage of using an external diff command is flexibility. You are not bound to find line-oriented changes, nor is it necessary for the output to resemble unified diff. You are free to locate and report changes in the most appropriate way for your data format.</source>
          <target state="translated">使用外部diff命令的好处是灵活。你不一定要找到面向行的变化,也不一定要输出类似统一的diff命令。你可以自由地以最适合你的数据格式的方式来定位和报告变化。</target>
        </trans-unit>
        <trans-unit id="37f935f00ace4f7aca8e441adbbf1abe0704a83a" translate="yes" xml:space="preserve">
          <source>The am backend drops any &quot;empty&quot; commits, regardless of whether the commit started empty (had no changes relative to its parent to start with) or ended empty (all changes were already applied upstream in other commits).</source>
          <target state="translated">Am后端会丢弃任何 &quot;空 &quot;的提交,不管该提交是空开始(相对于它的父提交没有任何变化)还是空结束(所有的变化都已经应用到上游的其他提交中)。</target>
        </trans-unit>
        <trans-unit id="013053835d145f0cc494db8211a188c9999bae09" translate="yes" xml:space="preserve">
          <source>The area where a pair of conflicting changes happened is marked with markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. The part before the &lt;code&gt;=======&lt;/code&gt; is typically your side, and the part afterwards is typically their side.</source>
          <target state="translated">发生一对冲突的更改的区域用标记 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;=======&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 标记。 &lt;code&gt;=======&lt;/code&gt; 之前的部分通常是您的一面，之后的部分通常是他们的一面。</target>
        </trans-unit>
        <trans-unit id="bbce7a566319a0fa5122538fad84df16b94a33f3" translate="yes" xml:space="preserve">
          <source>The argument to this option may be a glob on ref names, a ref, or the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is equivalent to specifying this option multiple times, one for each matching ref name.</source>
          <target state="translated">这个选项的参数可以是 ref 名称的 glob,也可以是 ref,或者是提交的 SHA-1(可能是缩写)。指定 glob 相当于多次指定这个选项,每个匹配的 ref 名称都有一个。</target>
        </trans-unit>
        <trans-unit id="6083c463b2a8fa637d23cd99c59e9746cb6a7539" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;diff&lt;/code&gt; affects how Git generates diffs for particular files. It can tell Git whether to generate a textual patch for the path or to treat the path as a binary file. It can also affect what line is shown on the hunk header &lt;code&gt;@@ -k,l +n,m @@&lt;/code&gt; line, tell Git to use an external command to generate the diff, or ask Git to convert binary files to a text format before generating the diff.</source>
          <target state="translated">&lt;code&gt;diff&lt;/code&gt; 属性影响Git如何为特定文件生成差异。它可以告诉Git是为路径生成文本补丁还是将路径视为二进制文件。它还可能会影响大块标题 &lt;code&gt;@@ -k,l +n,m @@&lt;/code&gt; 行，告诉Git使用外部命令生成diff，或要求Git在将二进制文件转换为文本格式之前产生差异。</target>
        </trans-unit>
        <trans-unit id="e3fef41e3a691b83ea57e915fd492f173e96b0ec" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;merge&lt;/code&gt; affects how three versions of a file are merged when a file-level merge is necessary during &lt;code&gt;git merge&lt;/code&gt;, and other commands such as &lt;code&gt;git revert&lt;/code&gt; and &lt;code&gt;git cherry-pick&lt;/code&gt;.</source>
          <target state="translated">当在 &lt;code&gt;git merge&lt;/code&gt; 和其他命令（如 &lt;code&gt;git revert&lt;/code&gt; 和 &lt;code&gt;git cherry-pick&lt;/code&gt; )期间需要进行文件级合并时，属性 &lt;code&gt;merge&lt;/code&gt; 影响文件三个版本的合并方式。</target>
        </trans-unit>
        <trans-unit id="2fe7b4a122d21c0258f6159b6aeead7d915c58b4" translate="yes" xml:space="preserve">
          <source>The attributes allow a fine-grained control, how the line endings are converted. Here is an example that will make Git normalize .txt, .vcproj and .sh files, ensure that .vcproj files have CRLF and .sh files have LF in the working directory, and prevent .jpg files from being normalized regardless of their content.</source>
          <target state="translated">属性允许精细地控制行尾的转换方式。下面是一个例子,它将使 Git 规范化 .txt、.vcproj 和 .sh 文件,确保 .vcproj 文件在工作目录下有 CRLF,.sh 文件在工作目录下有 LF,并防止 .jpg 文件无论内容如何都被规范化。</target>
        </trans-unit>
        <trans-unit id="0849ab3d36b0ce6d3f6183dc21f6e83ad1520176" translate="yes" xml:space="preserve">
          <source>The author name and email address to use when no author information can be found in the patch description.</source>
          <target state="translated">当在补丁描述中找不到作者信息时,要使用的作者姓名和电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="b012a2641006f12bad01716515743698d7deabe2" translate="yes" xml:space="preserve">
          <source>The author of a piece of code.</source>
          <target state="translated">一段代码的作者。</target>
        </trans-unit>
        <trans-unit id="147440e8e5aa984c82659720dc655a2dca5add95" translate="yes" xml:space="preserve">
          <source>The backend process sets GIT_COMMITTER_NAME to &lt;code&gt;$REMOTE_USER&lt;/code&gt; and GIT_COMMITTER_EMAIL to &lt;code&gt;${REMOTE_USER}@http.${REMOTE_ADDR}&lt;/code&gt;, ensuring that any reflogs created by &lt;code&gt;git-receive-pack&lt;/code&gt; contain some identifying information of the remote user who performed the push.</source>
          <target state="translated">后端进程将GIT_COMMITTER_NAME设置为 &lt;code&gt;$REMOTE_USER&lt;/code&gt; ，将GIT_COMMITTER_EMAIL设置为 &lt;code&gt;${REMOTE_USER}@http.${REMOTE_ADDR}&lt;/code&gt; ，以确保 &lt;code&gt;git-receive-pack&lt;/code&gt; 创建的所有reflog 都包含执行推送的远程用户的一些标识信息。</target>
        </trans-unit>
        <trans-unit id="21e5e59ef58a1f64125adda00de18248644f6705" translate="yes" xml:space="preserve">
          <source>The base object could also be deltified if it&amp;rsquo;s in the same pack. Ref-delta can also refer to an object outside the pack (i.e. the so-called &quot;thin pack&quot;). When stored on disk however, the pack should be self contained to avoid cyclic dependency.</source>
          <target state="translated">如果基础对象位于同一包中，则也可以将其删除。引用增量还可以引用包外部的对象（即所谓的&amp;ldquo;瘦包&amp;rdquo;）。但是，当存储在磁盘上时，该软件包应该是自包含的，以避免循环依赖性。</target>
        </trans-unit>
        <trans-unit id="1877d075d52f12eee201f2607da0c072a35f24bc" translate="yes" xml:space="preserve">
          <source>The base tree information block is used for maintainers or third party testers to know the exact state the patch series applies to. It consists of the &lt;code&gt;base commit&lt;/code&gt;, which is a well-known commit that is part of the stable part of the project history everybody else works off of, and zero or more &lt;code&gt;prerequisite patches&lt;/code&gt;, which are well-known patches in flight that is not yet part of the &lt;code&gt;base commit&lt;/code&gt; that need to be applied on top of &lt;code&gt;base commit&lt;/code&gt; in topological order before the patches can be applied.</source>
          <target state="translated">基础树信息块用于维护人员或第三方测试人员，以了解补丁程序系列适用的确切状态。它由 &lt;code&gt;base commit&lt;/code&gt; （这是众所周知的提交，它是其他所有人都在其中进行的项目历史的稳定部分的一部分）和零个或多个 &lt;code&gt;prerequisite patches&lt;/code&gt; ，这些补丁是尚未运行的众所周知的补丁所述的部分 &lt;code&gt;base commit&lt;/code&gt; 的顶部施加这种需要 &lt;code&gt;base commit&lt;/code&gt; 在拓扑顺序可以应用补丁之前。</target>
        </trans-unit>
        <trans-unit id="dc39b1b9637026dfb15dfa743421fbe1dc2277e7" translate="yes" xml:space="preserve">
          <source>The basic colors accepted are &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;black&lt;/code&gt;, &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt;, &lt;code&gt;yellow&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt;, &lt;code&gt;magenta&lt;/code&gt;, &lt;code&gt;cyan&lt;/code&gt; and &lt;code&gt;white&lt;/code&gt;. The first color given is the foreground; the second is the background.</source>
          <target state="translated">接受的基本颜色为 &lt;code&gt;normal&lt;/code&gt; 色， &lt;code&gt;black&lt;/code&gt; ， &lt;code&gt;red&lt;/code&gt; ， &lt;code&gt;green&lt;/code&gt; ， &lt;code&gt;yellow&lt;/code&gt; ， &lt;code&gt;blue&lt;/code&gt; ， &lt;code&gt;magenta&lt;/code&gt; ， &lt;code&gt;cyan&lt;/code&gt; 和 &lt;code&gt;white&lt;/code&gt; 。给定的第一个颜色是前景色；第二个是背景。</target>
        </trans-unit>
        <trans-unit id="d4e1b119ab89bbecfc6f0f5d854268dcecbb088f" translate="yes" xml:space="preserve">
          <source>The basic form described in DESCRIPTION with a Git directory, a working directory, a &lt;code&gt;gitlink&lt;/code&gt;, and a &lt;code&gt;.gitmodules&lt;/code&gt; entry.</source>
          <target state="translated">描述中描述的基本形式，带有一个Git目录，一个工作目录，一个 &lt;code&gt;gitlink&lt;/code&gt; 和一个 &lt;code&gt;.gitmodules&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="b21f7863c055f0aa6938a038ffa25acf7017fe84" translate="yes" xml:space="preserve">
          <source>The basic greedy diff algorithm. Currently, this is the default.</source>
          <target state="translated">基本的greedy diff算法。目前,这是默认的。</target>
        </trans-unit>
        <trans-unit id="ebbd31d9dd00322abaa4bb83a8b03f787c70d43c" translate="yes" xml:space="preserve">
          <source>The basic requirements:</source>
          <target state="translated">基本要求:</target>
        </trans-unit>
        <trans-unit id="675f96a5f033def81701bda4e874ec2fbad8a388" translate="yes" xml:space="preserve">
          <source>The below documentation is the same as what&amp;rsquo;s found in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">以下文档与&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;中的文档相同：</target>
        </trans-unit>
        <trans-unit id="f55762f9996c39bda184001319965b733714f313" translate="yes" xml:space="preserve">
          <source>The best way to get one is by using the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; command to download a copy of an existing repository. If you don&amp;rsquo;t already have a project in mind, here are some interesting examples:</source>
          <target state="translated">最好的方法是使用&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;命令下载现有存储库的副本。如果您还没有一个项目，这里有一些有趣的例子：</target>
        </trans-unit>
        <trans-unit id="e2b6c88cac94cf24687d4ba9657759c1ab28582a" translate="yes" xml:space="preserve">
          <source>The best way to see how this works is using the &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; command; running gitk now on a Git repository and looking for merge commits will help understand how Git organizes history.</source>
          <target state="translated">观察它如何工作的最好方法是使用&lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt;命令。现在在Git存储库上运行gitk并查找合并提交将有助于了解Git如何组织历史记录。</target>
        </trans-unit>
        <trans-unit id="8130ad227eb2e1ffe8f116dc4280c5919bb4cd97" translate="yes" xml:space="preserve">
          <source>The branch &lt;code&gt;test&lt;/code&gt; is short for &lt;code&gt;refs/heads/test&lt;/code&gt;.</source>
          <target state="translated">分支 &lt;code&gt;test&lt;/code&gt; 是 &lt;code&gt;refs/heads/test&lt;/code&gt; 的缩写。</target>
        </trans-unit>
        <trans-unit id="420b2dd61e4562065a5bd273fcdbaecde70d1742" translate="yes" xml:space="preserve">
          <source>The branch LRU builtin to fast-import tends to behave very well, and the cost of activating an inactive branch is so low that bouncing around between branches has virtually no impact on import performance.</source>
          <target state="translated">Fast-import内置的分支LRU往往表现得非常好,激活一个非活动分支的成本非常低,在分支之间跳来跳去对导入性能几乎没有影响。</target>
        </trans-unit>
        <trans-unit id="58be5b6cbe7d7c0a923608fe1415c68702e2aa84" translate="yes" xml:space="preserve">
          <source>The chain of operation</source>
          <target state="translated">业务链</target>
        </trans-unit>
        <trans-unit id="cb0b83bdafd60672fc0fb681d6c09ff33adfb7dc" translate="yes" xml:space="preserve">
          <source>The changes are still visible in the submodule&amp;rsquo;s reflog.</source>
          <target state="translated">更改仍在子模块的引用日志中可见。</target>
        </trans-unit>
        <trans-unit id="e18a17400a7fdeb34351715eb209f43bb56b69d6" translate="yes" xml:space="preserve">
          <source>The clone command creates a new directory named after the project (&lt;code&gt;git&lt;/code&gt; or &lt;code&gt;linux&lt;/code&gt; in the examples above). After you cd into this directory, you will see that it contains a copy of the project files, called the &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;, together with a special top-level directory named &lt;code&gt;.git&lt;/code&gt;, which contains all the information about the history of the project.</source>
          <target state="translated">clone命令创建一个以项目命名的新目录（在上面的示例中为 &lt;code&gt;git&lt;/code&gt; 或 &lt;code&gt;linux&lt;/code&gt; ）。cd到该目录后，您将看到它包含项目文件的副本，称为&lt;a href=&quot;#def_working_tree&quot;&gt;工作树&lt;/a&gt;，以及一个名为 &lt;code&gt;.git&lt;/code&gt; 的特殊顶级目录，其中包含有关项目历史记录的所有信息。</target>
        </trans-unit>
        <trans-unit id="9b1ff6b6614bf65ff7cf18fa7ac8ca0c73c31da4" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;git commit -a&lt;/code&gt; first looks at your working tree, notices that you have modified hello.c and removed goodbye.c, and performs necessary &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git rm&lt;/code&gt; for you.</source>
          <target state="translated">&lt;code&gt;git commit -a&lt;/code&gt; 命令首先查看您的工作树，注意到您已经修改了hello.c并删除了goodbye.c，并为您执行了必要的 &lt;code&gt;git add&lt;/code&gt; 和 &lt;code&gt;git rm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95cb34ce247ae47a8a7d5a122ee875bb99decb40" translate="yes" xml:space="preserve">
          <source>The command allows for creation and fast-forwarding of sha1 refs (heads/tags) on the remote end (strictly speaking, it is the local end &lt;code&gt;git-receive-pack&lt;/code&gt; runs, but to the user who is sitting at the send-pack end, it is updating the remote. Confused?)</source>
          <target state="translated">该命令允许在远程端（严格地说，它是本地端 &lt;code&gt;git-receive-pack&lt;/code&gt; 运行，但是对于坐在send-pack端的用户）创建和快速转发sha1 refs（头/标签），它正在更新遥控器。感到困惑吗？）</target>
        </trans-unit>
        <trans-unit id="2b42e9d45bef456324952e5870d272017a1a991c" translate="yes" xml:space="preserve">
          <source>The command also looks at &lt;code&gt;core.trustctime&lt;/code&gt; configuration variable. It can be useful when the inode change time is regularly modified by something outside Git (file system crawlers and backup systems use ctime for marking files processed) (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">该命令还将查看 &lt;code&gt;core.trustctime&lt;/code&gt; 配置变量。当init更改时间由Git外部的某些东西定期修改（文件系统搜寻器和备份系统使用ctime标记已处理的文件）时，它很有用（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b2d2a0a5d3ee3b745ff8e27d667799782d3fee27" translate="yes" xml:space="preserve">
          <source>The command by default does not allow an update that is not a fast-forward to prevent such loss of history.</source>
          <target state="translated">该命令默认不允许更新不是快进,以防止这种历史损失。</target>
        </trans-unit>
        <trans-unit id="57bd298a9fbda93bedda739fa9a93ffd1fbe53dd" translate="yes" xml:space="preserve">
          <source>The command by default packs all tags and refs that are already packed, and leaves other refs alone. This is because branches are expected to be actively developed and packing their tips does not help performance. This option causes branch tips to be packed as well. Useful for a repository with many branches of historical interests.</source>
          <target state="translated">默认情况下,该命令会打包所有已经打包好的标签和引用,而不考虑其他引用。这是因为分支应该是积极开发的,打包它们的提示对性能没有帮助。这个选项会使分支的提示也被打包。对于有许多历史性分支的版本库来说,这个选项很有用。</target>
        </trans-unit>
        <trans-unit id="affc62639786f9435bc3e40b781bdaefab9bf88f" translate="yes" xml:space="preserve">
          <source>The command can also be used to restore the content in the index with &lt;code&gt;--staged&lt;/code&gt;, or restore both the working tree and the index with &lt;code&gt;--staged --worktree&lt;/code&gt;.</source>
          <target state="translated">该命令还可以用来与恢复索引内容 &lt;code&gt;--staged&lt;/code&gt; ，或同时还原工作树，并与指数 &lt;code&gt;--staged --worktree&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="033264e01f6eaf7651e64aee25dc83cea3397f0e" translate="yes" xml:space="preserve">
          <source>The command finds the most recent tag that is reachable from a commit. If the tag points to the commit, then only the tag is shown. Otherwise, it suffixes the tag name with the number of additional commits on top of the tagged object and the abbreviated object name of the most recent commit. The result is a &quot;human-readable&quot; object name which can also be used to identify the commit to other git commands.</source>
          <target state="translated">功能:该命令用于查找可从提交中获取的最新标签。如果标签指向提交,则只显示该标签。否则,它会在标签名称后加上标签对象上的其他提交次数和最近提交的缩写对象名称。结果是一个 &quot;人可读 &quot;的对象名,它也可以用来识别其他 git 命令的提交。</target>
        </trans-unit>
        <trans-unit id="3ab56fbe7068ffbc29e1e09d644dcd93a3d4ced5" translate="yes" xml:space="preserve">
          <source>The command honors &lt;code&gt;color.status&lt;/code&gt; (or &lt;code&gt;status.color&lt;/code&gt; &amp;mdash; they mean the same thing and the latter is kept for backward compatibility) and &lt;code&gt;color.status.&amp;lt;slot&amp;gt;&lt;/code&gt; configuration variables to colorize its output.</source>
          <target state="translated">该命令使用 &lt;code&gt;color.status&lt;/code&gt; （或 &lt;code&gt;status.color&lt;/code&gt; ，它们表示相同的东西，并且保留后者是为了向后兼容）和 &lt;code&gt;color.status.&amp;lt;slot&amp;gt;&lt;/code&gt; 配置变量以使其输出着色。</target>
        </trans-unit>
        <trans-unit id="426f574eb4223ad0c1806f2471b371a9ce2ce62b" translate="yes" xml:space="preserve">
          <source>The command honors &lt;code&gt;core.filemode&lt;/code&gt; configuration variable. If your repository is on a filesystem whose executable bits are unreliable, this should be set to &lt;code&gt;false&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). This causes the command to ignore differences in file modes recorded in the index and the file mode on the filesystem if they differ only on executable bit. On such an unfortunate filesystem, you may need to use &lt;code&gt;git update-index --chmod=&lt;/code&gt;.</source>
          <target state="translated">该命令使用 &lt;code&gt;core.filemode&lt;/code&gt; 配置变量。如果您的存储库位于其可执行位不可靠的文件系统上，则应将其设置为 &lt;code&gt;false&lt;/code&gt; （请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。如果仅在可执行位上存在差异，该命令将导致该命令忽略索引中记录的文件模式和文件系统上的文件模式的差异。在这种不幸的文件系统上，您可能需要使用 &lt;code&gt;git update-index --chmod=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c1fbeab69cdf1a35e381ef7eff39e0ef873ae8e" translate="yes" xml:space="preserve">
          <source>The command is kept primarily for historical reasons; fingers of many people who learned Git long before &lt;code&gt;git log&lt;/code&gt; was invented by reading Linux kernel mailing list are trained to type it.</source>
          <target state="translated">该命令的保留主要是出于历史原因；在通过阅读Linux内核邮件列表发明 &lt;code&gt;git log&lt;/code&gt; 之前很久就学会了Git的许多人的手指都受过训练来键入它。</target>
        </trans-unit>
        <trans-unit id="078766939aed50311c1dcee68ff982a08734592e" translate="yes" xml:space="preserve">
          <source>The command line for those commands that support taking submodules as part of their pathspecs. Most commands have a boolean flag &lt;code&gt;--recurse-submodules&lt;/code&gt; which specify whether to recurse into submodules. Examples are &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;checkout&lt;/code&gt;. Some commands take enums, such as &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;, where you can specify how submodules are affected.</source>
          <target state="translated">这些命令的命令行支持将子模块作为其路径规范的一部分。大多数命令都有一个布尔标志 &lt;code&gt;--recurse-submodules&lt;/code&gt; ，用于指定是否递归到子模块中。例如 &lt;code&gt;grep&lt;/code&gt; 和 &lt;code&gt;checkout&lt;/code&gt; 。一些命令带有枚举，例如 &lt;code&gt;fetch&lt;/code&gt; 和 &lt;code&gt;push&lt;/code&gt; ，您可以在其中指定如何影响子模块。</target>
        </trans-unit>
        <trans-unit id="0c67f633874ba0fbe1af2a193c1c589167c2ab4d" translate="yes" xml:space="preserve">
          <source>The command looks at &lt;code&gt;core.ignorestat&lt;/code&gt; configuration variable. See &lt;code&gt;Using &quot;assume unchanged&quot; bit&lt;/code&gt; section above.</source>
          <target state="translated">该命令查看 &lt;code&gt;core.ignorestat&lt;/code&gt; 配置变量。请参阅上面的 &lt;code&gt;Using &quot;assume unchanged&quot; bit&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="5f7f0d79e587cabe73eebce8a6424fb5cae3c144" translate="yes" xml:space="preserve">
          <source>The command looks at &lt;code&gt;core.ignorestat&lt;/code&gt; configuration variable. When this is true, paths updated with &lt;code&gt;git update-index paths...&lt;/code&gt; and paths updated with other Git commands that update both index and working tree (e.g. &lt;code&gt;git apply --index&lt;/code&gt;, &lt;code&gt;git checkout-index -u&lt;/code&gt;, and &lt;code&gt;git read-tree -u&lt;/code&gt;) are automatically marked as &quot;assume unchanged&quot;. Note that &quot;assume unchanged&quot; bit is &lt;strong&gt;not&lt;/strong&gt; set if &lt;code&gt;git update-index --refresh&lt;/code&gt; finds the working tree file matches the index (use &lt;code&gt;git update-index --really-refresh&lt;/code&gt; if you want to mark them as &quot;assume unchanged&quot;).</source>
          <target state="translated">该命令查看 &lt;code&gt;core.ignorestat&lt;/code&gt; 配置变量。如果为真，则使用 &lt;code&gt;git update-index paths...&lt;/code&gt; 以及使用其他同时更新索引和工作树的Git命令更新的路径（例如 &lt;code&gt;git apply --index&lt;/code&gt; ， &lt;code&gt;git checkout-index -u&lt;/code&gt; 和 &lt;code&gt;git read-tree -u&lt;/code&gt; ）会自动标记为&amp;ldquo;假定未更改&amp;rdquo;。请注意，如果 &lt;code&gt;git update-index --refresh&lt;/code&gt; 找到与索引匹配的工作树文件，则&lt;strong&gt;不会&lt;/strong&gt;设置&amp;ldquo;假定不变&amp;rdquo;位（如果要将它们标记为&amp;ldquo;假定不变&amp;rdquo;，请使用 &lt;code&gt;git update-index --really-refresh&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="719021beca97cba355f40567331ed4531fab91cd" translate="yes" xml:space="preserve">
          <source>The command loop shows the list of subcommands available, and gives a prompt &quot;What now&amp;gt; &quot;. In general, when the prompt ends with a single &lt;code&gt;&amp;gt;&lt;/code&gt;, you can pick only one of the choices given and type return, like this:</source>
          <target state="translated">命令循环显示可用的子命令列表，并提示&amp;ldquo; What now&amp;gt;&amp;rdquo;。通常，当提示以单个 &lt;code&gt;&amp;gt;&lt;/code&gt; 结束时，您只能选择给定的选项之一并键入return，如下所示：</target>
        </trans-unit>
        <trans-unit id="653e31d7d7203bdc451cd54eed957012f41434d3" translate="yes" xml:space="preserve">
          <source>The command refuses to process new mailboxes until the current operation is finished, so if you decide to start over from scratch, run &lt;code&gt;git am --abort&lt;/code&gt; before running the command with mailbox names.</source>
          <target state="translated">该命令将拒绝处理新的邮箱，直到当前操作完成为止，因此，如果您决定从头开始， &lt;code&gt;git am --abort&lt;/code&gt; 在运行带有邮箱名称的命令之前运行git am --abort。</target>
        </trans-unit>
        <trans-unit id="ddc41d8aed51eb71b1c7af7000815eb2a4b359d3" translate="yes" xml:space="preserve">
          <source>The command stream is terminated by a blank line. In some cases (indicated in the documentation of the relevant commands), this blank line is followed by a payload in some other protocol (e.g., the pack protocol), while in others it indicates the end of input.</source>
          <target state="translated">命令流以空行结束。在某些情况下(在相关命令的文档中说明),这个空行后面是其他协议(如打包协议)中的有效载荷,而在其他情况下,它表示输入的结束。</target>
        </trans-unit>
        <trans-unit id="d1cdce0d3b2e7df2146074a7208b9f02c1bab1a7" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git diff-tree&lt;/code&gt; command to control how the changes the commit introduces are shown.</source>
          <target state="translated">该命令采用适用于 &lt;code&gt;git diff-tree&lt;/code&gt; 命令的选项，以控制如何显示提交引入的更改。</target>
        </trans-unit>
        <trans-unit id="35fc48f2de1638c3a16917e24656f5cccec37735" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git log&lt;/code&gt; command to control what is shown and how. See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">该命令采用适用于 &lt;code&gt;git log&lt;/code&gt; 命令的选项来控制显示的内容和方式。参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="704cfc598be528aca39957bda30b48a4e32947ac" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git rev-list&lt;/code&gt; command to control what is shown and how, and options applicable to the &lt;code&gt;git diff-*&lt;/code&gt; commands to control how the changes each commit introduces are shown.</source>
          <target state="translated">该命令具有适用于 &lt;code&gt;git rev-list&lt;/code&gt; 命令的选项以控制显示内容和方式，以及适用于 &lt;code&gt;git diff-*&lt;/code&gt; 命令的选项以控制如何显示每次提交引入的更改。</target>
        </trans-unit>
        <trans-unit id="05dd6533643357a7eb4c0a33aa8aafdf86be046c" translate="yes" xml:space="preserve">
          <source>The command takes various subcommands, and different options depending on the subcommand:</source>
          <target state="translated">该命令采取不同的子命令,根据子命令的不同,选项也不同。</target>
        </trans-unit>
        <trans-unit id="5dfb0879d1b00c6726b4c473489aecee6c7360c1" translate="yes" xml:space="preserve">
          <source>The command that the diff driver should call to generate the text-converted version of a file. The result of the conversion is used to generate a human-readable diff. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff驱动程序应调用该命令以生成文件的文本转换版本。转换结果用于生成人类可读的差异。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76561fd073c2b7875043b506e4a6c918bbf27fef" translate="yes" xml:space="preserve">
          <source>The command usually removes loose refs under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; hierarchy after packing them. This option tells it not to.</source>
          <target state="translated">打包后，该命令通常会删除 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 层次结构下的松散引用。此选项告诉它不这样做。</target>
        </trans-unit>
        <trans-unit id="77170493947dd63f2044149c05ae4eb27dc0d118" translate="yes" xml:space="preserve">
          <source>The command usually shows percentage progress. This flag suppresses it.</source>
          <target state="translated">该命令通常显示进度百分比。此标志将抑制它的显示。</target>
        </trans-unit>
        <trans-unit id="3df5350b5d92a4c7df677ed19aeefaf4fd05338a" translate="yes" xml:space="preserve">
          <source>The command which is used to convert the content of a blob object to a worktree file upon checkout. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">签出后用于将blob对象的内容转换为工作树文件的命令。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e78c7e2042e4de22f48dc29ab38867e1c8242106" translate="yes" xml:space="preserve">
          <source>The command which is used to convert the content of a worktree file to a blob upon checkin. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">该命令用于在签入时将工作树文件的内容转换为Blob。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a6711f072ffccd6a7948d8fcfc289d0284bd97d1" translate="yes" xml:space="preserve">
          <source>The command will only rewrite the &lt;code&gt;positive&lt;/code&gt; refs mentioned in the command line (e.g. if you pass &lt;code&gt;a..b&lt;/code&gt;, only &lt;code&gt;b&lt;/code&gt; will be rewritten). If you specify no filters, the commits will be recommitted without any changes, which would normally have no effect. Nevertheless, this may be useful in the future for compensating for some Git bugs or such, therefore such a usage is permitted.</source>
          <target state="translated">该命令将仅重写命令行中提到的 &lt;code&gt;positive&lt;/code&gt; 引用（例如，如果传递 &lt;code&gt;a..b&lt;/code&gt; ，则仅 &lt;code&gt;b&lt;/code&gt; 将被重写）。如果您未指定任何过滤器，则将重新提交提交而无需进行任何更改，这通常是无效的。不过，这在将来可能会用于补偿某些Git漏洞等，因此是允许的。</target>
        </trans-unit>
        <trans-unit id="6c1d44a42d537aa236fa8b0c18f8ebc1e0d665b8" translate="yes" xml:space="preserve">
          <source>The command writes the commit object name of the common ancestor to the standard output, so we captured its output to a variable, because we will be using it in the next step. By the way, the common ancestor commit is the &quot;Initial commit&quot; commit in this case. You can tell it by:</source>
          <target state="translated">该命令将共同祖先的提交对象名称写入标准输出,所以我们将其输出捕获到一个变量中,因为我们将在下一步使用它。顺便说一下,在本例中,共同祖先提交是 &quot;初始提交 &quot;提交。你可以通过以下方式来判断。</target>
        </trans-unit>
        <trans-unit id="277f50b8984fb8f1e24e58a015e232c719b0136b" translate="yes" xml:space="preserve">
          <source>The command&amp;rsquo;s second form creates a new branch head named &amp;lt;branchname&amp;gt; which points to the current &lt;code&gt;HEAD&lt;/code&gt;, or &amp;lt;start-point&amp;gt; if given. As a special case, for &amp;lt;start-point&amp;gt;, you may use &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; as a shortcut for the merge base of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; if there is exactly one merge base. You can leave out at most one of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, in which case it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">该命令的第二种形式创建一个名为&amp;lt;branchname&amp;gt;的新分支头，该分支头指向当前 &lt;code&gt;HEAD&lt;/code&gt; 或&amp;lt;start-point&amp;gt;（如果给定）。作为一种特殊情况，对于&amp;lt;start-point&amp;gt;，如果存在一个合并基数，则可以使用 &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; 作为 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 合并基数的快捷方式。您最多可以忽略 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 之一，在这种情况下，默认为 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0384db43c537c0cba33bbce02fa39c058435bd6c" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude-from=&amp;lt;file&amp;gt; specifies a file containing a list of patterns. Patterns are ordered in the same order they appear in the file.</source>
          <target state="translated">命令行标志--exclude-from = &amp;lt;file&amp;gt;指定包含模式列表的文件。模式按它们在文件中出现的顺序排列。</target>
        </trans-unit>
        <trans-unit id="84de3c7a7b3ba54b91bb57a464ea60b526231897" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude-per-directory=&amp;lt;name&amp;gt; specifies a name of the file in each directory &lt;code&gt;git ls-files&lt;/code&gt; examines, normally &lt;code&gt;.gitignore&lt;/code&gt;. Files in deeper directories take precedence. Patterns are ordered in the same order they appear in the files.</source>
          <target state="translated">命令行标志--exclude-per-directory = &amp;lt;名称&amp;gt;指定 &lt;code&gt;git ls-files&lt;/code&gt; 检查的每个目录中文件的名称，通常为 &lt;code&gt;.gitignore&lt;/code&gt; 。较深目录中的文件优先。模式按它们在文件中出现的顺序排列。</target>
        </trans-unit>
        <trans-unit id="de25d36c95ea6a374c3001c57d5c8bbae6052f57" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude=&amp;lt;pattern&amp;gt; specifies a single pattern. Patterns are ordered in the same order they appear in the command line.</source>
          <target state="translated">命令行标志--exclude = &amp;lt;pattern&amp;gt;指定单个模式。模式的排列顺序与它们在命令行中出现的顺序相同。</target>
        </trans-unit>
        <trans-unit id="57163e2560363b464673a4a43dc95a7ad9f9ef3b" translate="yes" xml:space="preserve">
          <source>The commit &quot;D&quot; is called a &quot;merge base&quot; for branch &quot;main&quot; and &quot;dev&quot; because it&amp;rsquo;s the best common ancestor for these branches for a merge.</source>
          <target state="translated">提交&amp;ldquo; D&amp;rdquo;被称为分支&amp;ldquo; main&amp;rdquo;和&amp;ldquo; dev&amp;rdquo;的&amp;ldquo;合并基础&amp;rdquo;，因为它是这些分支进行合并的最佳共同祖先。</target>
        </trans-unit>
        <trans-unit id="f185c14cbc82f3e4dae044b7f66a7608424887fa" translate="yes" xml:space="preserve">
          <source>The commit author name is taken from the &quot;From: &quot; line of the message, and commit author date is taken from the &quot;Date: &quot; line of the message. The &quot;Subject: &quot; line is used as the title of the commit, after stripping common prefix &quot;[PATCH &amp;lt;anything&amp;gt;]&quot;. The &quot;Subject: &quot; line is supposed to concisely describe what the commit is about in one line of text.</source>
          <target state="translated">提交作者的姓名来自消息的&amp;ldquo;发件人：&amp;rdquo;行，提交作者的日期来自消息的&amp;ldquo;日期：&amp;rdquo;行。除去公共前缀&amp;ldquo; [PATCH &amp;lt;任何内容&amp;gt;]&amp;rdquo;后，&amp;ldquo;主题：&amp;rdquo;行用作提交的标题。&amp;ldquo; Subject：&amp;rdquo;行应该简洁地描述一行文本中的提交内容。</target>
        </trans-unit>
        <trans-unit id="2f12acdb07fb960bc2fd1e07b27cc4a2b35ad054" translate="yes" xml:space="preserve">
          <source>The commit list format can be changed by setting the configuration option rebase.instructionFormat. A customized instruction format will automatically have the long commit hash prepended to the format.</source>
          <target state="translated">提交列表格式可以通过设置配置选项 rebase.instructionFormat 来改变。自定义的指令格式会自动在格式前加上长的提交哈希。</target>
        </trans-unit>
        <trans-unit id="56b4186deed0365516ca63a760921d1d85d5abd6" translate="yes" xml:space="preserve">
          <source>The commit log message extracted from e-mail, usually except the title line which comes from e-mail Subject.</source>
          <target state="translated">从电子邮件中提取的提交日志信息,通常除了标题行来自电子邮件主题外。</target>
        </trans-unit>
        <trans-unit id="448543278984728d32d400e55fc12701ecc9668d" translate="yes" xml:space="preserve">
          <source>The commit log message, author name and author email are taken from the e-mail, and after minimally decoding MIME transfer encoding, re-coded in the charset specified by i18n.commitencoding (defaulting to UTF-8) by transliterating them. This used to be optional but now it is the default.</source>
          <target state="translated">提交日志信息、作者姓名和作者邮件是从邮件中提取的,经过最小化的 MIME 传输编码解码后,用 i18n.commitencoding 指定的字符集(默认为 UTF-8)进行转写。这在过去是可选的,但现在是默认的。</target>
        </trans-unit>
        <trans-unit id="682ec5a16062666d3ac4c15995f4c320f0569ce3" translate="yes" xml:space="preserve">
          <source>The commit message is formed by the title taken from the &quot;Subject: &quot;, a blank line and the body of the message up to where the patch begins. Excess whitespace at the end of each line is automatically stripped.</source>
          <target state="translated">提交消息是由 &quot;Subject.&quot;中的标题、空行和消息的正文组成,直到补丁开始的地方。&quot;主题 &quot;中的标题、空行和消息的正文,直到补丁开始的地方。每行末尾多余的空白会被自动删除。</target>
        </trans-unit>
        <trans-unit id="9d14a63335261988fcede52b815289c8a87983a5" translate="yes" xml:space="preserve">
          <source>The commit message is supplied either directly with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option, or indirectly from the tag or commit when the second tree-ish denotes such an object, or it is requested by invoking an editor (see &lt;code&gt;--edit&lt;/code&gt; option below).</source>
          <target state="translated">提交消息可以通过 &lt;code&gt;-m&lt;/code&gt; 或 &lt;code&gt;-F&lt;/code&gt; 选项直接提供，或者在第二个树状结构表示此类对象或通过调用编辑器进行请求时间接从标记或提交中提供（请参见下面的 &lt;code&gt;--edit&lt;/code&gt; 选项） 。</target>
        </trans-unit>
        <trans-unit id="50413d61f19e8e0d39eb4098c01c599c7c407f25" translate="yes" xml:space="preserve">
          <source>The commit object names shown above would be different for you, but they should match the HEAD commit object names of your repositories. You can check it by running &lt;code&gt;git ls-remote ../a&lt;/code&gt;.</source>
          <target state="translated">上面显示的提交对象名称对您而言将有所不同，但它们应与存储库的HEAD提交对象名称匹配。您可以通过运行 &lt;code&gt;git ls-remote ../a&lt;/code&gt; 进行检查。</target>
        </trans-unit>
        <trans-unit id="8b7bb35b4ae403135d95400938252724b91ca0d2" translate="yes" xml:space="preserve">
          <source>The commit objects record the encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user. For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in &lt;code&gt;X&lt;/code&gt; and we are outputting in &lt;code&gt;X&lt;/code&gt;, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output.</source>
          <target state="translated">提交对象在其编码标头中记录用于日志消息的编码。此选项可用于告诉命令以用户首选的编码方式重新编码提交日志消息。对于非管道命令，此默认为UTF-8。注意，如果一个对象声称要用 &lt;code&gt;X&lt;/code&gt; 编码并且我们要用 &lt;code&gt;X&lt;/code&gt; 输出，我们将逐字输出该对象；这意味着可以将原始提交中的无效序列复制到输出中。</target>
        </trans-unit>
        <trans-unit id="8a40378090f508382eab3e21e0b4382b3bab0ad4" translate="yes" xml:space="preserve">
          <source>The commit, equivalent to what other systems call a &quot;changeset&quot; or &quot;version&quot;, represents a step in the project&amp;rsquo;s history, and each parent represents an immediately preceding step. Commits with more than one parent represent merges of independent lines of development.</source>
          <target state="translated">提交与其他系统称为&amp;ldquo;变更集&amp;rdquo;或&amp;ldquo;版本&amp;rdquo;的提交等效，表示项目历史记录中的一个步骤，每个父级表示紧接的前一个步骤。与多个父代的提交代表了独立开发线的合并。</target>
        </trans-unit>
        <trans-unit id="7d3d64efc4f4511458592fa6c8a58dcfb8579da7" translate="yes" xml:space="preserve">
          <source>The commits are guaranteed to be listed in the order that they were processed by rebase.</source>
          <target state="translated">保证按照Rebase处理的顺序列出提交的内容。</target>
        </trans-unit>
        <trans-unit id="00a94582df69c83885533dbdc944c957c3a549e0" translate="yes" xml:space="preserve">
          <source>The commits marked with &lt;code&gt;*&lt;/code&gt; touch the same area in the same file; you need to resolve the conflicts when creating the commit marked with &lt;code&gt;+&lt;/code&gt;. Then you can test the result to make sure your work-in-progress still works with what is in the latest master.</source>
          <target state="translated">标有 &lt;code&gt;*&lt;/code&gt; 的提交触及同一文件中的同一区域；您需要在创建带有 &lt;code&gt;+&lt;/code&gt; 标记的提交时解决冲突。然后，您可以测试结果，以确保您的在制品仍可与最新的母版中的作品一起使用。</target>
        </trans-unit>
        <trans-unit id="a3fd88845d0ae86224cb7a800b3122f1cf56cb03" translate="yes" xml:space="preserve">
          <source>The commits that were previously saved into the temporary area are then reapplied to the current branch, one by one, in order. Note that any commits in HEAD which introduce the same textual changes as a commit in HEAD..&amp;lt;upstream&amp;gt; are omitted (i.e., a patch already accepted upstream with a different commit message or timestamp will be skipped).</source>
          <target state="translated">然后，将先前保存到临时区域中的提交依次重新应用于当前分支。请注意，在HEAD中引入与HEAD .. &amp;lt;upstream&amp;gt;中的提交相同的文本更改的所有提交都将被忽略（即，将跳过上游已接受的具有不同提交消息或时间戳的补丁程序）。</target>
        </trans-unit>
        <trans-unit id="18d247bf08e46b2d89a403ce14a86d7b99503646" translate="yes" xml:space="preserve">
          <source>The complete message in a commit and tag object is &lt;code&gt;contents&lt;/code&gt;. Its first line is &lt;code&gt;contents:subject&lt;/code&gt;, where subject is the concatenation of all lines of the commit message up to the first blank line. The next line is &lt;code&gt;contents:body&lt;/code&gt;, where body is all of the lines after the first blank line. The optional GPG signature is &lt;code&gt;contents:signature&lt;/code&gt;. The first &lt;code&gt;N&lt;/code&gt; lines of the message is obtained using &lt;code&gt;contents:lines=N&lt;/code&gt;. Additionally, the trailers as interpreted by &lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers[1]&lt;/a&gt; are obtained as &lt;code&gt;trailers&lt;/code&gt; (or by using the historical alias &lt;code&gt;contents:trailers&lt;/code&gt;). Non-trailer lines from the trailer block can be omitted with &lt;code&gt;trailers:only&lt;/code&gt;. Whitespace-continuations can be removed from trailers so that each trailer appears on a line by itself with its full content with &lt;code&gt;trailers:unfold&lt;/code&gt;. Both can be used together as &lt;code&gt;trailers:unfold,only&lt;/code&gt;.</source>
          <target state="translated">提交和标记对象中的完整消息为 &lt;code&gt;contents&lt;/code&gt; 。它的第一行是 &lt;code&gt;contents:subject&lt;/code&gt; ，其中subject是提交消息中所有行的连接，直到第一行空白为止。下一行是 &lt;code&gt;contents:body&lt;/code&gt; ，其中body是第一个空白行之后的所有行。可选的GPG签名为 &lt;code&gt;contents:signature&lt;/code&gt; 。使用 &lt;code&gt;contents:lines=N&lt;/code&gt; 获得消息的前 &lt;code&gt;N&lt;/code&gt; 行。另外，由&lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers [1]解释的预告片&lt;/a&gt;可以作为 &lt;code&gt;trailers&lt;/code&gt; 获得（或使用历史别名 &lt;code&gt;contents:trailers&lt;/code&gt; ）。可以使用 &lt;code&gt;trailers:only&lt;/code&gt; 省略来自预告片块的非预告线。可以从预告片中删除空白连续符，以便每个预告片都单独显示在一行中，并且其全部内容与 &lt;code&gt;trailers:unfold&lt;/code&gt; 相同。两者都可以一起用作 &lt;code&gt;trailers:unfold,only&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cfefd9783776d68186cc88921bf5543257f8ee9" translate="yes" xml:space="preserve">
          <source>The complete series produces the same end result as your own (probably much messier!) development process did.</source>
          <target state="translated">完整的系列产生的最终结果和你自己的开发过程一样(可能更乱!)。</target>
        </trans-unit>
        <trans-unit id="94ed81b46eb91e159691e77d6f1f3c669ea0f93b" translate="yes" xml:space="preserve">
          <source>The condition starts with a keyword followed by a colon and some data whose format and meaning depends on the keyword. Supported keywords are:</source>
          <target state="translated">该条件以关键字开始,后面是冒号和一些数据,其格式和含义取决于关键字。支持的关键字有:</target>
        </trans-unit>
        <trans-unit id="b796e8b15faa41177d638a7b320c951a662a1b91" translate="yes" xml:space="preserve">
          <source>The config settings that start with &lt;code&gt;feature.&lt;/code&gt; modify the defaults of a group of other config settings. These groups are created by the Git developer community as recommended defaults and are subject to change. In particular, new config options may be added with different defaults.</source>
          <target state="translated">以 &lt;code&gt;feature.&lt;/code&gt; 开头的配置设置。修改一组其他配置设置的默认值。这些组由Git开发人员社区创建，作为建议的默认值，并且会随时更改。特别是，可以使用不同的默认值添加新的配置选项。</target>
        </trans-unit>
        <trans-unit id="0fd18e355006d4a8cb0ab9547d6ae9db29a772ac" translate="yes" xml:space="preserve">
          <source>The config variable &lt;code&gt;ssh.variant&lt;/code&gt; can be set to override this detection. Valid values are &lt;code&gt;ssh&lt;/code&gt; (to use OpenSSH options), &lt;code&gt;plink&lt;/code&gt;, &lt;code&gt;putty&lt;/code&gt;, &lt;code&gt;tortoiseplink&lt;/code&gt;, &lt;code&gt;simple&lt;/code&gt; (no options except the host and remote command). The default auto-detection can be explicitly requested using the value &lt;code&gt;auto&lt;/code&gt;. Any other value is treated as &lt;code&gt;ssh&lt;/code&gt;. This setting can also be overridden via the environment variable &lt;code&gt;GIT_SSH_VARIANT&lt;/code&gt;.</source>
          <target state="translated">可以将配置变量 &lt;code&gt;ssh.variant&lt;/code&gt; 设置为覆盖此检测。有效值为 &lt;code&gt;ssh&lt;/code&gt; （使用OpenSSH选项）， &lt;code&gt;plink&lt;/code&gt; ， &lt;code&gt;putty&lt;/code&gt; ， &lt;code&gt;tortoiseplink&lt;/code&gt; ， &lt;code&gt;simple&lt;/code&gt; （除host和remote命令外没有其他选项）。可以使用值 &lt;code&gt;auto&lt;/code&gt; 显式请求默认的自动检测。其他任何值均视为 &lt;code&gt;ssh&lt;/code&gt; 。也可以通过环境变量 &lt;code&gt;GIT_SSH_VARIANT&lt;/code&gt; 覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="82dcb1f42fdd78b7a73229a297c6923dd8af63df" translate="yes" xml:space="preserve">
          <source>The configuration file &lt;code&gt;$GIT_DIR/config&lt;/code&gt; in the superproject. Git only recurses into active submodules (see &quot;ACTIVE SUBMODULES&quot; section below).</source>
          <target state="translated">超级项目中的配置文件 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 。Git仅递归到活动子模块中（请参阅下面的&amp;ldquo;活动子模块&amp;rdquo;部分）。</target>
        </trans-unit>
        <trans-unit id="774734ca6d9570e50bffe1b21770dfa34405f67a" translate="yes" xml:space="preserve">
          <source>The configuration file is used to override the default settings that were built into gitweb at the time the &lt;code&gt;gitweb.cgi&lt;/code&gt; script was generated.</source>
          <target state="translated">该配置文件用于覆盖生成 &lt;code&gt;gitweb.cgi&lt;/code&gt; 脚本时内置在gitweb中的默认设置。</target>
        </trans-unit>
        <trans-unit id="b47107ae705aecdb184ade3561dff30a01436bf4" translate="yes" xml:space="preserve">
          <source>The configuration inside the submodule. This includes &lt;code&gt;$GIT_DIR/config&lt;/code&gt; in the submodule, but also settings in the tree such as a &lt;code&gt;.gitattributes&lt;/code&gt; or &lt;code&gt;.gitignore&lt;/code&gt; files that specify behavior of commands inside the submodule.</source>
          <target state="translated">子模块内部的配置。这包括子模块中的 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; ，还包括树中的设置，例如 &lt;code&gt;.gitattributes&lt;/code&gt; 或 &lt;code&gt;.gitignore&lt;/code&gt; 文件，用于指定子模块内部命令的行为。</target>
        </trans-unit>
        <trans-unit id="9f6d6d393008f1bcb3935ac97c688c0c97bcd837" translate="yes" xml:space="preserve">
          <source>The configuration of submodules</source>
          <target state="translated">子模块的配置</target>
        </trans-unit>
        <trans-unit id="386a88f6456b2a92a88834767dd0b8e7846f5609" translate="yes" xml:space="preserve">
          <source>The configuration variables &lt;code&gt;$projects_list_group_categories&lt;/code&gt; and &lt;code&gt;$project_list_default_category&lt;/code&gt; are described in &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;</source>
          <target state="translated">配置变量 &lt;code&gt;$projects_list_group_categories&lt;/code&gt; 和 &lt;code&gt;$project_list_default_category&lt;/code&gt; 在&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt;中描述</target>
        </trans-unit>
        <trans-unit id="7bf08d06e6b6627f964eab6068d66314f0702240" translate="yes" xml:space="preserve">
          <source>The configuration variables are used by both the Git plumbing and the porcelains. The variables are divided into sections, wherein the fully qualified variable name of the variable itself is the last dot-separated segment and the section name is everything before the last dot. The variable names are case-insensitive, allow only alphanumeric characters and &lt;code&gt;-&lt;/code&gt;, and must start with an alphabetic character. Some variables may appear multiple times; we say then that the variable is multivalued.</source>
          <target state="translated">Git管道和瓷器都使用配置变量。变量分为多个部分，其中变量本身的完全限定变量名称是最后一个点分隔的段，而部分名称是最后一个点之前的所有内容。变量名称不区分大小写，仅允许字母数字字符和 &lt;code&gt;-&lt;/code&gt; ，并且必须以字母字符开头。有些变量可能会出现多次；那么我们说变量是多值的。</target>
        </trans-unit>
        <trans-unit id="9ba005fddfd40c1aca4a3afcc24f0bfe0be0d141" translate="yes" xml:space="preserve">
          <source>The configuration variables described below configure some of gitweb links: their target and their look (text or image), and where to find page prerequisites (stylesheet, favicon, images, scripts). Usually they are left at their default values, with the possible exception of &lt;code&gt;@stylesheets&lt;/code&gt; variable.</source>
          <target state="translated">下文描述的配置变量配置了一些gitweb链接：它们的目标和外观（文本或图像），以及在哪里可以找到页面先决条件（样式表，图标，图像，脚本）。通常，它们保留其默认值， &lt;code&gt;@stylesheets&lt;/code&gt; 变量可能除外。</target>
        </trans-unit>
        <trans-unit id="352cabf788111a2af3c96521f974380812252a38" translate="yes" xml:space="preserve">
          <source>The configuration variables described below control how gitweb finds Git repositories, and how repositories are displayed and accessed.</source>
          <target state="translated">下面描述的配置变量控制着gitweb如何找到Git仓库,以及如何显示和访问仓库。</target>
        </trans-unit>
        <trans-unit id="3f43fd6b4f50ff73ead39001e9e7b24eaf91129d" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;@{-&amp;lt;n&amp;gt;}&lt;/code&gt; means the &amp;lt;n&amp;gt;th branch/commit checked out before the current one.</source>
          <target state="translated">构造 &lt;code&gt;@{-&amp;lt;n&amp;gt;}&lt;/code&gt; 表示在当前分支之前签出的第&amp;lt;n&amp;gt;个分支/提交。</target>
        </trans-unit>
        <trans-unit id="532c17d263ea0447251201d507a716aaf6f28f2e" translate="yes" xml:space="preserve">
          <source>The content to be committed can be specified in several ways:</source>
          <target state="translated">可以通过多种方式指定要提交的内容。</target>
        </trans-unit>
        <trans-unit id="a3c1db69a05b050bddfd156a5df9e51b55df4af8" translate="yes" xml:space="preserve">
          <source>The contents of the actual line is output after the above header, prefixed by a TAB. This is to allow adding more header elements later.</source>
          <target state="translated">实际行的内容是在上述头之后输出的,前面加一个TAB。这是为了以后可以添加更多的头元素。</target>
        </trans-unit>
        <trans-unit id="07ff8c430a66890255703acd59c46fb9590b9dc8" translate="yes" xml:space="preserve">
          <source>The contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level.</source>
          <target state="translated">blob对象的内容是未被解释的字节序列。在核心层没有编码转换。</target>
        </trans-unit>
        <trans-unit id="1b5efb2fc6b2c2f5d21112887ebec33fa1322cd1" translate="yes" xml:space="preserve">
          <source>The contents of the included file are inserted immediately, as if they had been found at the location of the include directive. If the value of the variable is a relative path, the path is considered to be relative to the configuration file in which the include directive was found. See below for examples.</source>
          <target state="translated">包含的文件内容会被立即插入,就像它们是在include指令的位置被找到的一样。如果变量的值是一个相对路径,那么这个路径被认为是相对于包含指令所在的配置文件的。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="8e2acace54c1bc95e05b068c1615156bf7369b0d" translate="yes" xml:space="preserve">
          <source>The core Git is often called &quot;plumbing&quot;, with the prettier user interfaces on top of it called &quot;porcelain&quot;. You may not want to use the plumbing directly very often, but it can be good to know what the plumbing does when the porcelain isn&amp;rsquo;t flushing.</source>
          <target state="translated">核心Git通常称为&amp;ldquo;管道&amp;rdquo;，其上的更漂亮的用户界面称为&amp;ldquo;瓷器&amp;rdquo;。您可能不希望经常直接使用管道，但是最好知道不冲洗瓷器时管道的作用。</target>
        </trans-unit>
        <trans-unit id="bdff9728a51893f686262a6a471251953f8ca49c" translate="yes" xml:space="preserve">
          <source>The core.multiPackIndex config setting must be on to consume MIDX files.</source>
          <target state="translated">core.multiPackIndex配置设置必须开启才能消耗MIDX文件。</target>
        </trans-unit>
        <trans-unit id="4fd34d18ba310e6b91e875c3fcf517fe13b68829" translate="yes" xml:space="preserve">
          <source>The cost matrix is populated thusly: for each pair of commits, both diffs are generated and the &quot;diff of diffs&quot; is generated, with 3 context lines, then the number of lines in that diff is used as cost.</source>
          <target state="translated">成本矩阵是这样填充的:对于每一对提交,都会生成两个diff,并生成 &quot;diff的diff&quot;,其中有3个上下文行,那么该diff的行数就作为成本。</target>
        </trans-unit>
        <trans-unit id="588bd7a488f6b8b596aae7dca46a3809b4412eb0" translate="yes" xml:space="preserve">
          <source>The cost of an edge &lt;code&gt;o--C&lt;/code&gt; is the size of &lt;code&gt;C&lt;/code&gt;'s diff, modified by a fudge factor that should be smaller than 100%. The cost of an edge &lt;code&gt;o--o&lt;/code&gt; is free. The fudge factor is necessary because even if &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have nothing in common, they may still share a few empty lines and such, possibly making the assignment &lt;code&gt;1--C&lt;/code&gt;, &lt;code&gt;o--o&lt;/code&gt; slightly cheaper than &lt;code&gt;1--o&lt;/code&gt;, &lt;code&gt;o--C&lt;/code&gt; even if &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have nothing in common. With the fudge factor we require a much larger common part to consider patches as corresponding.</source>
          <target state="translated">边缘 &lt;code&gt;o--C&lt;/code&gt; 的成本是 &lt;code&gt;C&lt;/code&gt; 的diff 的大小，并通过应小于100％的软化系数进行修改。边缘 &lt;code&gt;o--o&lt;/code&gt; 的成本是免费的。忽悠系数是必要的，因为即使 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 没有共同点，它们仍可能共享一些空行，因此，可能使分配 &lt;code&gt;1--C&lt;/code&gt; ， &lt;code&gt;o--o&lt;/code&gt; 比 &lt;code&gt;1--o&lt;/code&gt; ， &lt;code&gt;o--C&lt;/code&gt; 便宜-C即使 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 没有共同点。有了软糖因素，我们需要一个更大的公用部分，才能将补丁视为相应的补丁。</target>
        </trans-unit>
        <trans-unit id="1995b336f91a29b5d0cf1cb6bf6d7c2407fa802c" translate="yes" xml:space="preserve">
          <source>The credential is split into a set of named attributes, with one attribute per line. Each attribute is specified by a key-value pair, separated by an &lt;code&gt;=&lt;/code&gt; (equals) sign, followed by a newline. The key may contain any bytes except &lt;code&gt;=&lt;/code&gt;, newline, or NUL. The value may contain any bytes except newline or NUL. In both cases, all bytes are treated as-is (i.e., there is no quoting, and one cannot transmit a value with newline or NUL in it). The list of attributes is terminated by a blank line or end-of-file. Git understands the following attributes:</source>
          <target state="translated">凭证分为一组命名属性，每行一个属性。每个属性由键值对指定，并由 &lt;code&gt;=&lt;/code&gt; （等号）分隔，后跟换行符。密钥可以包含除 &lt;code&gt;=&lt;/code&gt; ，换行符或NUL 以外的任何字节。该值可以包含除换行符或NUL之外的任何字节。在这两种情况下，所有字节均按原样处理（即，不加引号，并且不能传输其中包含换行符或NUL的值）。属性列表以空白行或文件结尾终止。Git理解以下属性：</target>
        </trans-unit>
        <trans-unit id="332163de0b53725f6a8fdbb5dfbee2d72f5e952f" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s password, if we are asking it to be stored.</source>
          <target state="translated">凭据的密码（如果我们要求将其存储）。</target>
        </trans-unit>
        <trans-unit id="b2af82f2f4002bb109eae365a3025f169b56089c" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s username, if we already have one (e.g., from a URL, from the user, or from a previously run helper).</source>
          <target state="translated">凭据的用户名（如果已经有）（例如，来自URL，用户或先前运行的帮助程序）。</target>
        </trans-unit>
        <trans-unit id="327d8af868005c380ff04a569542ec1ad381deca" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. In more detail: Your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is normally derived from the state of the tree referred to by HEAD. HEAD is a reference to one of the &lt;a href=&quot;#def_head&quot;&gt;heads&lt;/a&gt; in your repository, except when using a &lt;a href=&quot;#def_detached_HEAD&quot;&gt;detached HEAD&lt;/a&gt;, in which case it directly references an arbitrary commit.</source>
          <target state="translated">当前&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;。更详细地：您的&lt;a href=&quot;#def_working_tree&quot;&gt;工作树&lt;/a&gt;通常是从HEAD所指的树的状态派生的。HEAD是对的一个参考&lt;a href=&quot;#def_head&quot;&gt;的头&lt;/a&gt;在你的仓库，使用时除外&lt;a href=&quot;#def_detached_HEAD&quot;&gt;分离的头&lt;/a&gt;，在这种情况下，直接引用任意提交。</target>
        </trans-unit>
        <trans-unit id="6a22129f9e2c1c598b41ac7718060a19c57ba2df" translate="yes" xml:space="preserve">
          <source>The current branch and &lt;code&gt;HEAD&lt;/code&gt; pointer stay at the last commit successfully made.</source>
          <target state="translated">当前分支和 &lt;code&gt;HEAD&lt;/code&gt; 指针停留在成功完成的最后一次提交上。</target>
        </trans-unit>
        <trans-unit id="0f49d1c21e2564ca60f22933641a619ec1965bd6" translate="yes" xml:space="preserve">
          <source>The current branch is reset to &amp;lt;upstream&amp;gt;, or &amp;lt;newbase&amp;gt; if the --onto option was supplied. This has the exact same effect as &lt;code&gt;git reset --hard &amp;lt;upstream&amp;gt;&lt;/code&gt; (or &amp;lt;newbase&amp;gt;). ORIG_HEAD is set to point at the tip of the branch before the reset.</source>
          <target state="translated">如果提供了--onto选项，则将当前分支重置为&amp;lt;上游&amp;gt;或&amp;lt;newbase&amp;gt;。这与 &lt;code&gt;git reset --hard &amp;lt;upstream&amp;gt;&lt;/code&gt; （或&amp;lt;newbase&amp;gt;）完全相同。将ORIG_HEAD设置为指向重置之前分支的尖端。</target>
        </trans-unit>
        <trans-unit id="485fe33a04a6d00e71aec5bce139a108011107ac" translate="yes" xml:space="preserve">
          <source>The current command-line parameters used for each variant are as follows:</source>
          <target state="translated">目前各变量使用的命令行参数如下。</target>
        </trans-unit>
        <trans-unit id="f1d20a076d93bfe14eb345a4d54fe76b72904bc4" translate="yes" xml:space="preserve">
          <source>The current index and work tree is derived from $H, but the user may have local changes in them since $H.</source>
          <target state="translated">当前的索引和工作树来自$H,但用户可能会在$H之后对它们进行局部修改。</target>
        </trans-unit>
        <trans-unit id="7bc299cda3bedfdcbabc4a6883d29c81bf74d5df" translate="yes" xml:space="preserve">
          <source>The current index file for the repository. It is usually not found in a bare repository.</source>
          <target state="translated">版本库的当前索引文件。它通常在裸仓库中找不到。</target>
        </trans-unit>
        <trans-unit id="6561295b83003ebae9a9c6ca19e06cdfe7bf9b70" translate="yes" xml:space="preserve">
          <source>The currently defined format versions are:</source>
          <target state="translated">目前定义的格式版本有:</target>
        </trans-unit>
        <trans-unit id="66a8472981ef80b1cce56bd59cf5f4d97c11f9f9" translate="yes" xml:space="preserve">
          <source>The currently supported hooks are described below.</source>
          <target state="translated">目前支持的钩子描述如下。</target>
        </trans-unit>
        <trans-unit id="8715361e5840de7b556e67eacf990927a206b328" translate="yes" xml:space="preserve">
          <source>The custom diff driver command. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">定制diff驱动程序命令。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e530b24daf8e53e45f57000d6a6174670a1f6d2" translate="yes" xml:space="preserve">
          <source>The data content for the file has not been supplied yet. The frontend wants to supply it as part of this modify command.</source>
          <target state="translated">文件的数据内容还没有提供。前台希望将其作为修改命令的一部分来提供。</target>
        </trans-unit>
        <trans-unit id="f92713104ec45ad60b839fa902e6ffedd1e05a41" translate="yes" xml:space="preserve">
          <source>The data content for the file was already supplied by a prior &lt;code&gt;blob&lt;/code&gt; command. The frontend just needs to connect it.</source>
          <target state="translated">该文件的数据内容已由先前的 &lt;code&gt;blob&lt;/code&gt; 命令提供。前端只需要连接它。</target>
        </trans-unit>
        <trans-unit id="abeb69d3d4bae2cc1a5a16e58850f1c93c17369b" translate="yes" xml:space="preserve">
          <source>The data content for the note has not been supplied yet. The frontend wants to supply it as part of this modify command.</source>
          <target state="translated">注释的数据内容还没有提供。前台希望将其作为本次修改命令的一部分来提供。</target>
        </trans-unit>
        <trans-unit id="81c47d0a0bfa5328ac109608aa42a36ac0ca6a45" translate="yes" xml:space="preserve">
          <source>The data content for the note was already supplied by a prior &lt;code&gt;blob&lt;/code&gt; command. The frontend just needs to connect it to the commit that is to be annotated.</source>
          <target state="translated">注释的数据内容已由先前的 &lt;code&gt;blob&lt;/code&gt; 命令提供。前端只需要将其连接到要注释的提交即可。</target>
        </trans-unit>
        <trans-unit id="d1c68865b9a230a071410342b903f7a0e48271ba" translate="yes" xml:space="preserve">
          <source>The data that follows the keyword &lt;code&gt;gitdir:&lt;/code&gt; is used as a glob pattern. If the location of the .git directory matches the pattern, the include condition is met.</source>
          <target state="translated">关键字 &lt;code&gt;gitdir:&lt;/code&gt; 之后的数据用作全局模式。如果.git目录的位置与该模式匹配，则满足包含条件。</target>
        </trans-unit>
        <trans-unit id="c1597312d460a92e79d09c37c305ec85acdf7d09" translate="yes" xml:space="preserve">
          <source>The data that follows the keyword &lt;code&gt;onbranch:&lt;/code&gt; is taken to be a pattern with standard globbing wildcards and two additional ones, &lt;code&gt;**/&lt;/code&gt; and &lt;code&gt;/**&lt;/code&gt;, that can match multiple path components. If we are in a worktree where the name of the branch that is currently checked out matches the pattern, the include condition is met.</source>
          <target state="translated">关键字 &lt;code&gt;onbranch:&lt;/code&gt; 之后的数据被视为具有标准通配符和另外两个 &lt;code&gt;**/&lt;/code&gt; 和 &lt;code&gt;/**&lt;/code&gt; 的模式，它们可以匹配多个路径分量。如果我们位于当前检出的分支名称与模式匹配的工作树中，则满足包含条件。</target>
        </trans-unit>
        <trans-unit id="7c053d7b296d35ca64db938819dea858103dc6da" translate="yes" xml:space="preserve">
          <source>The data transfer of the packfile is always multiplexed, using the same semantics of the &lt;code&gt;side-band-64k&lt;/code&gt; capability from protocol version 1. This means that each packet, during the packfile data stream, is made up of a leading 4-byte pkt-line length (typical of the pkt-line format), followed by a 1-byte stream code, followed by the actual data.</source>
          <target state="translated">使用协议版本1 的 &lt;code&gt;side-band-64k&lt;/code&gt; 功能的相同语义，总是对packfile的数据传输进行多路复用。这意味着在packfile数据流期间，每个数据包均由前导4字节pkt-行长度（通常是pkt-line格式），然后是1字节流代码，然后是实际数据。</target>
        </trans-unit>
        <trans-unit id="c2900c14cd751c2ba06b33eb8d53cbdb905b94a4" translate="yes" xml:space="preserve">
          <source>The database cannot be reliably regenerated in a consistent form after the branch it is tracking has changed. Example: For merged branches, &lt;code&gt;git-cvsserver&lt;/code&gt; only tracks one branch of development, and after a &lt;code&gt;git merge&lt;/code&gt; an incrementally updated database may track a different branch than a database regenerated from scratch, causing inconsistent CVS revision numbers. &lt;code&gt;git-cvsserver&lt;/code&gt; has no way of knowing which branch it would have picked if it had been run incrementally pre-merge. So if you have to fully or partially (from old backup) regenerate the database, you should be suspicious of pre-existing CVS sandboxes.</source>
          <target state="translated">跟踪的分支已更改后，无法以一致的形式可靠地重新生成数据库。示例：对于合并的分支， &lt;code&gt;git-cvsserver&lt;/code&gt; 仅跟踪开发的一个分支，并且在 &lt;code&gt;git merge&lt;/code&gt; ，增量更新的数据库可能会跟踪与从头开始重新生成的数据库不同的分支，从而导致不一致的CVS版本号。 &lt;code&gt;git-cvsserver&lt;/code&gt; 无法知道如果在合并前以增量方式运行它将选择哪个分支。因此，如果您必须全部或部分（从旧备份中）重新生成数据库，则应该对预先存在的CVS沙箱感到怀疑。</target>
        </trans-unit>
        <trans-unit id="44d2a77b29a1133933d2693560e181324cc0bf34" translate="yes" xml:space="preserve">
          <source>The database has an object whose hash doesn&amp;rsquo;t match the object database value. This indicates a serious data integrity problem.</source>
          <target state="translated">数据库中有一个对象，其哈希值与对象数据库的值不匹配。这表明存在严重的数据完整性问题。</target>
        </trans-unit>
        <trans-unit id="28234e35fb4524e90d740d3154dc66c02cb1f7a2" translate="yes" xml:space="preserve">
          <source>The default &amp;lt;ref&amp;gt; is &quot;master&quot;.</source>
          <target state="translated">默认的&amp;lt;ref&amp;gt;是&amp;ldquo; master&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c033f0ddddff0b7a496ef058316bfe1c29b59dcb" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge. If the upstream branch of 'A' is 'origin/B' sometimes we say &quot;'A' is tracking 'origin/B'&quot;.</source>
          <target state="translated">合并到所讨论的分支中的默认&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;（或所讨论的分支被重新建立为基础）。它是通过branch。&amp;lt;name&amp;gt; .remote和branch。&amp;lt;name&amp;gt; .merge配置的。如果'A'的上游分支是'origin / B'，有时我们说&amp;ldquo;'A'正在跟踪'origin / B'&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0e2c938aad423666052c9b862a31c7bd282b15cb" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge. If the upstream branch of &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;origin/B&lt;/code&gt; sometimes we say &quot;&lt;code&gt;A&lt;/code&gt; is tracking &lt;code&gt;origin/B&lt;/code&gt;&quot;.</source>
          <target state="translated">合并到所讨论的分支中的默认&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;（或所讨论的分支被重新建立为基础）。它是通过branch。&amp;lt;name&amp;gt; .remote和branch。&amp;lt;name&amp;gt; .merge配置的。如果 &lt;code&gt;A&lt;/code&gt; 的上游分支是 &lt;code&gt;origin/B&lt;/code&gt; 有时我们会说&amp;ldquo; &lt;code&gt;A&lt;/code&gt; 正在跟踪 &lt;code&gt;origin/B&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2a57474834373f0012a2eee4dc03542456f6b683" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;applypatch-msg&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;commit-msg&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">启用后，默认的 &lt;code&gt;applypatch-msg&lt;/code&gt; 挂钩将运行 &lt;code&gt;commit-msg&lt;/code&gt; 挂钩（如果已启用）。</target>
        </trans-unit>
        <trans-unit id="1004092b458b148233da1997202a081689268a8e" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;commit-msg&lt;/code&gt; hook, when enabled, detects duplicate &quot;Signed-off-by&quot; lines, and aborts the commit if one is found.</source>
          <target state="translated">默认的 &lt;code&gt;commit-msg&lt;/code&gt; 挂钩启用后，会检测到重复的&amp;ldquo; Signed-by-by&amp;rdquo;行，如果找到则中止提交。</target>
        </trans-unit>
        <trans-unit id="54e7a2ab7a7ead4c100931e31ff4408636c3868d" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;post-receive&lt;/code&gt; hook is empty, but there is a sample script &lt;code&gt;post-receive-email&lt;/code&gt; provided in the &lt;code&gt;contrib/hooks&lt;/code&gt; directory in Git distribution, which implements sending commit emails.</source>
          <target state="translated">默认的 &lt;code&gt;post-receive&lt;/code&gt; 钩子为空，但是Git发行版的 &lt;code&gt;contrib/hooks&lt;/code&gt; 目录中提供了一个示例脚本 &lt;code&gt;post-receive-email&lt;/code&gt; ，该脚本实现了发送提交电子邮件。</target>
        </trans-unit>
        <trans-unit id="a71e842d9eb90ca6731ba585809c1f8c19eb80f6" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-applypatch&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;pre-commit&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">如果启用了默认的 &lt;code&gt;pre-applypatch&lt;/code&gt; 挂钩，则它将运行 &lt;code&gt;pre-commit&lt;/code&gt; 挂钩（如果已启用）。</target>
        </trans-unit>
        <trans-unit id="b4266565542333c335464dc9285134a4a9b31011" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-commit&lt;/code&gt; hook, when enabled&amp;mdash;​and with the &lt;code&gt;hooks.allownonascii&lt;/code&gt; config option unset or set to false&amp;mdash;​prevents the use of non-ASCII filenames.</source>
          <target state="translated">默认的 &lt;code&gt;pre-commit&lt;/code&gt; 挂钩在 &lt;code&gt;hooks.allownonascii&lt;/code&gt; 时-并且未设置hooks.allownonascii config选项或将其设置为false-防止使用非ASCII文件名。</target>
        </trans-unit>
        <trans-unit id="c591fe93d0021a0c7991225b1a062c31f35ddd16" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-commit&lt;/code&gt; hook, when enabled, catches introduction of lines with trailing whitespaces and aborts the commit when such a line is found.</source>
          <target state="translated">默认的 &lt;code&gt;pre-commit&lt;/code&gt; 钩启用时会捕获带有尾随空格的行的引入，并在找到这样的行时中止提交。</target>
        </trans-unit>
        <trans-unit id="5c24125124251d23fec260bbe8f20bf4ce1ae496" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-merge-commit&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;pre-commit&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">如果启用了默认的 &lt;code&gt;pre-merge-commit&lt;/code&gt; 钩子，那么它将运行 &lt;code&gt;pre-commit&lt;/code&gt; （如果已启用）钩子。</target>
        </trans-unit>
        <trans-unit id="c0f0841a2790ebd8e4684a32dafde265e2735139" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;update&lt;/code&gt; hook, when enabled&amp;mdash;​and with &lt;code&gt;hooks.allowunannotated&lt;/code&gt; config option unset or set to false&amp;mdash;​prevents unannotated tags to be pushed.</source>
          <target state="translated">默认 &lt;code&gt;update&lt;/code&gt; 挂钩在 &lt;code&gt;hooks.allowunannotated&lt;/code&gt; 时以及未设置hooks.allowunannotated config选项或将其设置为false的情况下，将阻止推送未注释的标签。</target>
        </trans-unit>
        <trans-unit id="e99caaee535fa5770d85355802dd91eb002c650f" translate="yes" xml:space="preserve">
          <source>The default behavior of this command when no &amp;lt;refspec&amp;gt; is given can be configured by setting the &lt;code&gt;push&lt;/code&gt; option of the remote, or the &lt;code&gt;push.default&lt;/code&gt; configuration variable.</source>
          <target state="translated">可以通过设置遥控器的 &lt;code&gt;push&lt;/code&gt; 选项或 &lt;code&gt;push.default&lt;/code&gt; 配置变量来配置未给出&amp;lt;refspec&amp;gt;时此命令的默认行为。</target>
        </trans-unit>
        <trans-unit id="04fb2222b71daf513a74198926f20b6eb1c65e53" translate="yes" xml:space="preserve">
          <source>The default can be changed by the &lt;code&gt;commit.cleanup&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">可以通过 &lt;code&gt;commit.cleanup&lt;/code&gt; 配置变量更改默认值（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6d2b951210087bf6a12979c879cea7654da192ce" translate="yes" xml:space="preserve">
          <source>The default can be changed using the status.showUntrackedFiles configuration variable documented in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;git-config&quot;&gt;git-config [1]中&lt;/a&gt;记录的status.showUntrackedFiles配置变量来更改默认值。</target>
        </trans-unit>
        <trans-unit id="f4804356dda86c0d39019920e2a204580a3348e0" translate="yes" xml:space="preserve">
          <source>The default configuration with no configuration file at all may work perfectly well for some installations. Still, a configuration file is useful for customizing or tweaking the behavior of gitweb in many ways, and some optional features will not be present unless explicitly enabled using the configurable &lt;code&gt;%features&lt;/code&gt; variable (see also &quot;Configuring gitweb features&quot; section below).</source>
          <target state="translated">完全没有配置文件的默认配置在某些安装中可能效果很好。尽管如此，配置文件仍然可以通过多种方式用于自定义或调整gitweb的行为，除非使用可配置的 &lt;code&gt;%features&lt;/code&gt; 变量显式启用，否则某些可选功能将不存在（另请参见下面的&amp;ldquo;配置gitweb功能&amp;rdquo;部分）。</target>
        </trans-unit>
        <trans-unit id="ba35598baf99b4759b4ac8e8e152046ad84f4f70" translate="yes" xml:space="preserve">
          <source>The default destination is &lt;code&gt;syslog&lt;/code&gt; if &lt;code&gt;--inetd&lt;/code&gt; or &lt;code&gt;--detach&lt;/code&gt; is specified, otherwise &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">如果指定了 &lt;code&gt;--inetd&lt;/code&gt; 或 &lt;code&gt;--detach&lt;/code&gt; ,则默认目标为 &lt;code&gt;syslog&lt;/code&gt; ，否则为 &lt;code&gt;stderr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08a91820da4ab8ff0557091a83e78baf95e62cbc" translate="yes" xml:space="preserve">
          <source>The default development &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. Whenever you create a Git &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;, a branch named &quot;master&quot; is created, and becomes the active branch. In most cases, this contains the local development, though that is purely by convention and is not required.</source>
          <target state="translated">默认的开发&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;。每当创建Git &lt;a href=&quot;#def_repository&quot;&gt;存储库时&lt;/a&gt;，都会创建一个名为&amp;ldquo; master&amp;rdquo;的分支，并成为活动分支。在大多数情况下，这包含本地开发，尽管这完全是约定的，不是必需的。</target>
        </trans-unit>
        <trans-unit id="9cfb0587d78b80316db2bf990e0689e616d2c4e9" translate="yes" xml:space="preserve">
          <source>The default diff tool to use when &lt;code&gt;--gui&lt;/code&gt; is specified.</source>
          <target state="translated">指定 &lt;code&gt;--gui&lt;/code&gt; 时使用的默认差异工具。</target>
        </trans-unit>
        <trans-unit id="2106f60990b064f5f08c291bb6d584e30eb4aef6" translate="yes" xml:space="preserve">
          <source>The default diff tool to use.</source>
          <target state="translated">默认使用的diff工具。</target>
        </trans-unit>
        <trans-unit id="ef7818a768aaedb1852c90af2f69c6d87d81a9be" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output a signature containing the Git version number. Use this variable to change that default. Set this variable to the empty string (&quot;&quot;) to suppress signature generation.</source>
          <target state="translated">format-patch 的默认值是输出包含 Git 版本号的签名。使用这个变量可以改变这个默认值。将此变量设为空字符串(&quot;&quot;),以抑制生成签名。</target>
        </trans-unit>
        <trans-unit id="04f69f6bfbe685cc6892bfe73707b968c4b7e627" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output files with the &lt;code&gt;[PATCH]&lt;/code&gt; subject prefix. Use this variable to change that prefix.</source>
          <target state="translated">format-patch的默认设置是输出带有 &lt;code&gt;[PATCH]&lt;/code&gt; 主题前缀的文件。使用此变量可以更改该前缀。</target>
        </trans-unit>
        <trans-unit id="9305a301a407a477c0982cd809ad589540305e9b" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output files with the suffix &lt;code&gt;.patch&lt;/code&gt;. Use this variable to change that suffix (make sure to include the dot if you want it).</source>
          <target state="translated">format-patch的默认设置是输出带有后缀 &lt;code&gt;.patch&lt;/code&gt; 的文件。使用此变量可以更改该后缀（如果需要，请确保包含点）。</target>
        </trans-unit>
        <trans-unit id="82f6ff06915abbfaa5bafadf3e71c6515eea8a49" translate="yes" xml:space="preserve">
          <source>The default for the patch directory is patches or the value of the &lt;code&gt;$QUILT_PATCHES&lt;/code&gt; environment variable.</source>
          <target state="translated">修补程序目录的默认值为修补程序或 &lt;code&gt;$QUILT_PATCHES&lt;/code&gt; 环境变量的值。</target>
        </trans-unit>
        <trans-unit id="63e417c4ba57abb65259188be896bb91267bad84" translate="yes" xml:space="preserve">
          <source>The default for the series file is &amp;lt;patches&amp;gt;/series or the value of the &lt;code&gt;$QUILT_SERIES&lt;/code&gt; environment variable.</source>
          <target state="translated">系列文件的默认值为&amp;lt;patches&amp;gt; / series或 &lt;code&gt;$QUILT_SERIES&lt;/code&gt; 环境变量的值。</target>
        </trans-unit>
        <trans-unit id="43b413a4d69c795f1a4cc6e5069d43aa254cba9e" translate="yes" xml:space="preserve">
          <source>The default format does not show what the original said in the conflicting area. You cannot tell how many lines are deleted and replaced with Barbie&amp;rsquo;s remark on your side. The only thing you can tell is that your side wants to say it is hard and you&amp;rsquo;d prefer to go shopping, while the other side wants to claim it is easy.</source>
          <target state="translated">默认格式不显示原件在冲突区域中所说的内容。您无法判断删除了多少行并替换为您旁边的芭比娃娃的言论。您唯一可以说的是，您的一方要说很难，并且您更喜欢去购物，而另一方则想声称这很容易。</target>
        </trans-unit>
        <trans-unit id="2c9ac4b5e02925d5a2242fa228d32b0af91d581b" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;--no-notes&lt;/code&gt;, unless the &lt;code&gt;format.notes&lt;/code&gt; configuration is set.</source>
          <target state="translated">除非设置了 &lt;code&gt;format.notes&lt;/code&gt; 配置，否则默认值为 &lt;code&gt;--no-notes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e210eb7dbec89858b8e72d64e2d379a9aada6a48" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;--no-thread&lt;/code&gt;, unless the &lt;code&gt;format.thread&lt;/code&gt; configuration is set. If &lt;code&gt;--thread&lt;/code&gt; is specified without a style, it defaults to the style specified by &lt;code&gt;format.thread&lt;/code&gt; if any, or else &lt;code&gt;shallow&lt;/code&gt;.</source>
          <target state="translated">除非设置了 &lt;code&gt;format.thread&lt;/code&gt; 配置，否则默认值为 &lt;code&gt;--no-thread&lt;/code&gt; 。如果 &lt;code&gt;--thread&lt;/code&gt; 是一个没有风格的指定，则默认为按指定的样式 &lt;code&gt;format.thread&lt;/code&gt; 如果有的话，否则 &lt;code&gt;shallow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9abe1131612b105426f13be17707662aa8662d23" translate="yes" xml:space="preserve">
          <source>The default is false, except &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; will probe and set core.ignoreCase true if appropriate when the repository is created.</source>
          <target state="translated">缺省值为false，除了&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;或&lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt;将在创建存储库时在适当的情况下探测并设置core.ignoreCase为true。</target>
        </trans-unit>
        <trans-unit id="fcf73b7882b6e3d265136d0071b137412decce56" translate="yes" xml:space="preserve">
          <source>The default is not to print any annotation lines. If no number is given to &lt;code&gt;-n&lt;/code&gt;, only the first line is printed. If the tag is not annotated, the commit message is displayed instead.</source>
          <target state="translated">默认设置是不打印任何注释行。如果 &lt;code&gt;-n&lt;/code&gt; 没有给出数字，则仅打印第一行。如果未注释标签，则显示提交消息。</target>
        </trans-unit>
        <trans-unit id="19baf950afb8f746e54b7299adf6fbd6966f659a" translate="yes" xml:space="preserve">
          <source>The default is to diff against our branch (-2) and the cleanly resolved paths. The option -0 can be given to omit diff output for unmerged entries and just show &quot;Unmerged&quot;.</source>
          <target state="translated">默认情况下,我们会对我们的分支(-2)和干净的解析路径进行比较。选项-0可以用来省略未合并条目的diff输出,只显示 &quot;Unmerged&quot;。</target>
        </trans-unit>
        <trans-unit id="70f152ab57d660d365ae81763277f72b2d86f307" translate="yes" xml:space="preserve">
          <source>The default is true (when core.filemode is not specified in the config file).</source>
          <target state="translated">默认为true(当配置文件中没有指定core.filemode时)。</target>
        </trans-unit>
        <trans-unit id="03228e9bc81b32ffbccac2430f1d794dd7591d2a" translate="yes" xml:space="preserve">
          <source>The default is true, except &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; will probe and set core.symlinks false if appropriate when the repository is created.</source>
          <target state="translated">缺省值为true，除了&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;或&lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt;将探测并设置core.symlinks为false时（如果创建存储库）。</target>
        </trans-unit>
        <trans-unit id="72445c1104c1c11ef748913a9c6e570e5a73c947" translate="yes" xml:space="preserve">
          <source>The default location of the CVS checkout to use for the export.</source>
          <target state="translated">用于导出的CVS结账的默认位置。</target>
        </trans-unit>
        <trans-unit id="116262510e324641581bf8e5fe54c44cc1ec58f5" translate="yes" xml:space="preserve">
          <source>The default merge strategy to use when pulling a single branch.</source>
          <target state="translated">拉取单个分支时默认使用的合并策略。</target>
        </trans-unit>
        <trans-unit id="a808540aa8de08b00cb350dbc14ab54e33fa8faf" translate="yes" xml:space="preserve">
          <source>The default merge strategy to use when pulling multiple branches at once.</source>
          <target state="translated">当同时拉取多个分支时,默认使用的合并策略。</target>
        </trans-unit>
        <trans-unit id="e2e648395119cc70a2e9e998b6f3d4c60294fc12" translate="yes" xml:space="preserve">
          <source>The default mode for format-patch to determine which parts of the cover letter will be populated using the branch&amp;rsquo;s description. See the &lt;code&gt;--cover-from-description&lt;/code&gt; option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">format-patch的默认模式，用于确定使用分支的说明填充求职信的哪些部分。请参阅&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]中&lt;/a&gt;的 &lt;code&gt;--cover-from-description&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="063faead523251f77be0529092965c3429cc8003" translate="yes" xml:space="preserve">
          <source>The default module path for &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; to use instead of /usr/lib/apache2/modules. Only used if httpd is Apache.</source>
          <target state="translated">&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;代替/ usr / lib / apache2 / modules使用的默认模块路径。仅当httpd是Apache时使用。</target>
        </trans-unit>
        <trans-unit id="91f8aff2bf27bb7f60525104a4a75d78c7ffe52b" translate="yes" xml:space="preserve">
          <source>The default notes merge strategy is &quot;manual&quot;, which checks out conflicting notes in a special work tree for resolving notes conflicts (&lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt;), and instructs the user to resolve the conflicts in that work tree. When done, the user can either finalize the merge with &lt;code&gt;git notes merge --commit&lt;/code&gt;, or abort the merge with &lt;code&gt;git notes merge --abort&lt;/code&gt;.</source>
          <target state="translated">默认的便笺合并策略是&amp;ldquo;手动&amp;rdquo;，它在特殊的工作树中检出冲突的便笺以解决便笺冲突（ &lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt; ），并指示用户解决该工作树中的冲突。完成后，用户可以使用 &lt;code&gt;git notes merge --commit&lt;/code&gt; 最终确定合并，也可以使用git notes merge --abort中止 &lt;code&gt;git notes merge --abort&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d49acb565d9b642605b0a997d7ebc3213ecdde25" translate="yes" xml:space="preserve">
          <source>The default pretty format for log/show/whatchanged command, See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;.</source>
          <target state="translated">log / show / whatchanged命令的默认漂亮格式，请参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;，&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;，&lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c642123af45071133c151f29614b42c5bfc1ffac" translate="yes" xml:space="preserve">
          <source>The default program to execute on the remote side when fetching. See option --upload-pack of &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt;.</source>
          <target state="translated">提取时在远程端执行的默认程序。参见&lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]的&lt;/a&gt; --upload-pack选项。</target>
        </trans-unit>
        <trans-unit id="02bc1378d0d05db5e7ff2ca7062e80f4098e5579" translate="yes" xml:space="preserve">
          <source>The default program to execute on the remote side when pushing. See option --receive-pack of &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">推送时要在远程执行的默认程序。参见选项--receive-pack的&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1520b8813a02e6817b17665a2200c8c1eb73489c" translate="yes" xml:space="preserve">
          <source>The default remote is the remote of the remote-tracking branch of the current branch. If no such remote-tracking branch exists or the HEAD is detached, &quot;origin&quot; is assumed to be the default remote. If the superproject doesn&amp;rsquo;t have a default remote configured the superproject is its own authoritative upstream and the current working directory is used instead.</source>
          <target state="translated">默认远程是当前分支的远程跟踪分支的远程。如果不存在这样的远程跟踪分支或HEAD被分离，则将&amp;ldquo;源&amp;rdquo;假定为默认远程。如果超级项目没有配置默认远程，则超级项目是其自己的权威上游，而使用当前的工作目录。</target>
        </trans-unit>
        <trans-unit id="0d78370864f4fde80869e4efb080139612c8d161" translate="yes" xml:space="preserve">
          <source>The default set of &quot;refspec&quot; for &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;的默认&amp;ldquo; refspec&amp;rdquo;集。参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e7461b63dbe3a9bd4be74e77260f6121d70becf" translate="yes" xml:space="preserve">
          <source>The default set of &quot;refspec&quot; for &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;的默认&amp;ldquo; refspec&amp;rdquo;集。参见&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b1d55965a766c32086046542d13a0c5cafb5d20" translate="yes" xml:space="preserve">
          <source>The default set of branches for &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;. See &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt;的默认分支集。参见&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f8a6ecfdcb232e0e35afa31c75a9bb76e3ba014" translate="yes" xml:space="preserve">
          <source>The default template directory includes some directory structure, suggested &quot;exclude patterns&quot; (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), and sample hook files.</source>
          <target state="translated">默认的模板目录包括一些目录结构，建议的&amp;ldquo;排除模式&amp;rdquo;（请参阅&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;）和示例挂钩文件。</target>
        </trans-unit>
        <trans-unit id="5c5dda91be7317473d73b4f4f28156d762d8905f" translate="yes" xml:space="preserve">
          <source>The default threading style for &lt;code&gt;git format-patch&lt;/code&gt;. Can be a boolean value, or &lt;code&gt;shallow&lt;/code&gt; or &lt;code&gt;deep&lt;/code&gt;. &lt;code&gt;shallow&lt;/code&gt; threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the &lt;code&gt;--in-reply-to&lt;/code&gt;, and the first patch mail, in this order. &lt;code&gt;deep&lt;/code&gt; threading makes every mail a reply to the previous one. A true boolean value is the same as &lt;code&gt;shallow&lt;/code&gt;, and a false value disables threading.</source>
          <target state="translated">&lt;code&gt;git format-patch&lt;/code&gt; 的默认线程样式。可以是布尔值，也可以是 &lt;code&gt;shallow&lt;/code&gt; 或 &lt;code&gt;deep&lt;/code&gt; 。 &lt;code&gt;shallow&lt;/code&gt; 线程使每个邮件都回复到该系列的 &lt;code&gt;--in-reply-to&lt;/code&gt; ，该标题是从求职信，-in-reply-to和第一个补丁邮件中按此顺序选择的。 &lt;code&gt;deep&lt;/code&gt; 线程使每封邮件都回复上一封邮件。布尔值的真值与 &lt;code&gt;shallow&lt;/code&gt; 值相同，假值的值则禁用线程化。</target>
        </trans-unit>
        <trans-unit id="0eb7f832f6b33a6020eb8629fee287c4b15b4801" translate="yes" xml:space="preserve">
          <source>The default upstream &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. Most projects have at least one upstream project which they track. By default 'origin' is used for that purpose. New upstream updates will be fetched into &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branches&lt;/a&gt; named origin/name-of-upstream-branch, which you can see using &lt;code&gt;git branch -r&lt;/code&gt;.</source>
          <target state="translated">默认的上游&lt;a href=&quot;#def_repository&quot;&gt;存储库&lt;/a&gt;。大多数项目都有至少一个要跟踪的上游项目。默认情况下，&amp;ldquo; origin&amp;rdquo;用于此目的。新的上游更新将被提取到名为origin / of-streamstream-branch的&lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;远程跟踪&lt;/a&gt;分支中，您可以使用 &lt;code&gt;git branch -r&lt;/code&gt; 看到它们。</target>
        </trans-unit>
        <trans-unit id="4f838be44da45fd1828d0b46b391485ccd56187e" translate="yes" xml:space="preserve">
          <source>The default upstream &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. Most projects have at least one upstream project which they track. By default &lt;code&gt;origin&lt;/code&gt; is used for that purpose. New upstream updates will be fetched into &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branches&lt;/a&gt; named origin/name-of-upstream-branch, which you can see using &lt;code&gt;git branch -r&lt;/code&gt;.</source>
          <target state="translated">默认的上游&lt;a href=&quot;#def_repository&quot;&gt;存储库&lt;/a&gt;。大多数项目都有至少一个要跟踪的上游项目。默认情况下， &lt;code&gt;origin&lt;/code&gt; 用于此目的。新的上游更新将被提取到名为origin / of-streamstream-branch的&lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;远程跟踪&lt;/a&gt;分支中，您可以使用 &lt;code&gt;git branch -r&lt;/code&gt; 看到它们。</target>
        </trans-unit>
        <trans-unit id="66087a54aa582dff2f539d6f92ec2461ac3012fd" translate="yes" xml:space="preserve">
          <source>The default value for --window is 10 and --depth is 50. The maximum depth is 4095.</source>
          <target state="translated">--window的默认值是10,-depth的默认值是50。最大深度为4095。</target>
        </trans-unit>
        <trans-unit id="90d3816cdd271ff4f563d74700f0c34c9ae7702c" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;$projectroot&lt;/code&gt; is &lt;code&gt;/pub/git&lt;/code&gt;. You can change it during building gitweb via &lt;code&gt;GITWEB_PROJECTROOT&lt;/code&gt; build configuration variable.</source>
          <target state="translated">默认值为 &lt;code&gt;$projectroot&lt;/code&gt; 是 &lt;code&gt;/pub/git&lt;/code&gt; 。您可以在构建gitweb期间通过 &lt;code&gt;GITWEB_PROJECTROOT&lt;/code&gt; 构建配置变量进行更改。</target>
        </trans-unit>
        <trans-unit id="78bcbc1a976cbafa1db494161487aec966c7436d" translate="yes" xml:space="preserve">
          <source>The default value is either &lt;code&gt;static/gitweb.js&lt;/code&gt;, or &lt;code&gt;static/gitweb.min.js&lt;/code&gt; if the &lt;code&gt;JSMIN&lt;/code&gt; build variable was defined, i.e. if JavaScript minifier was used at build time. &lt;strong&gt;Note&lt;/strong&gt; that this single file is generated from multiple individual JavaScript &quot;modules&quot;.</source>
          <target state="translated">如果定义了 &lt;code&gt;JSMIN&lt;/code&gt; 构建变量，则默认值为 &lt;code&gt;static/gitweb.js&lt;/code&gt; 或 &lt;code&gt;static/gitweb.min.js&lt;/code&gt; ，即，如果在构建时使用了JavaScript minifier。&lt;strong&gt;请注意&lt;/strong&gt;，这个文件是由多个单独的JavaScript&amp;ldquo;模块&amp;rdquo;生成的。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="88fcf9aad2af8490af6dabfabbb5732019a6c8e1" translate="yes" xml:space="preserve">
          <source>The default value of this variable is determined by the &lt;code&gt;GITWEB_LIST&lt;/code&gt; makefile variable at installation time. If this variable is empty, gitweb will fall back to scanning the &lt;code&gt;$projectroot&lt;/code&gt; directory for repositories.</source>
          <target state="translated">该变量的默认值由安装时的 &lt;code&gt;GITWEB_LIST&lt;/code&gt; makefile变量确定。如果此变量为空，则gitweb将退回到扫描 &lt;code&gt;$projectroot&lt;/code&gt; 目录以查找存储库。</target>
        </trans-unit>
        <trans-unit id="da622b41696b803144c5254aad9443c84211d515" translate="yes" xml:space="preserve">
          <source>The default value of this variable is determined by the build-time configuration variable &lt;code&gt;GITWEB_PROJECT_MAXDEPTH&lt;/code&gt;, which defaults to 2007.</source>
          <target state="translated">此变量的默认值由构建时配置变量 &lt;code&gt;GITWEB_PROJECT_MAXDEPTH&lt;/code&gt; 确定，其默认值为2007。</target>
        </trans-unit>
        <trans-unit id="777a0a86855d35a436d0a0e990f3b787a636cb43" translate="yes" xml:space="preserve">
          <source>The defined extensions are:</source>
          <target state="translated">已定义的扩展是:</target>
        </trans-unit>
        <trans-unit id="2309a4e043845fb6e7e786e69af3d5ed57221f3f" translate="yes" xml:space="preserve">
          <source>The definition of a diff driver is done in &lt;code&gt;gitconfig&lt;/code&gt;, not &lt;code&gt;gitattributes&lt;/code&gt; file, so strictly speaking this manual page is a wrong place to talk about it. However&amp;hellip;​</source>
          <target state="translated">diff驱动程序的定义是在 &lt;code&gt;gitconfig&lt;/code&gt; 中完成的，而不是在 &lt;code&gt;gitattributes&lt;/code&gt; 文件中完成的，因此严格来说，本手册页是谈论它的错误位置。但是...</target>
        </trans-unit>
        <trans-unit id="05fbc211f0bbdc85a5cbba915fe02006f8119e9e" translate="yes" xml:space="preserve">
          <source>The definition of a merge driver is done in the &lt;code&gt;.git/config&lt;/code&gt; file, not in the &lt;code&gt;gitattributes&lt;/code&gt; file, so strictly speaking this manual page is a wrong place to talk about it. However&amp;hellip;​</source>
          <target state="translated">合并驱动程序的定义是在 &lt;code&gt;.git/config&lt;/code&gt; 文件中完成的，而不是在 &lt;code&gt;gitattributes&lt;/code&gt; 文件中完成的，因此严格来说，本手册页是谈论它的错误位置。但是...</target>
        </trans-unit>
        <trans-unit id="096c7fcd9c9053c9edd8c72ca9c95b04e65c3409" translate="yes" xml:space="preserve">
          <source>The deletion removes the superproject&amp;rsquo;s tracking data, which are both the &lt;code&gt;gitlink&lt;/code&gt; entry and the section in the &lt;code&gt;.gitmodules&lt;/code&gt; file. The submodule&amp;rsquo;s working directory is removed from the file system, but the Git directory is kept around as it to make it possible to checkout past commits without requiring fetching from another repository.</source>
          <target state="translated">删除操作将删除超级项目的跟踪数据，该数据既是 &lt;code&gt;gitlink&lt;/code&gt; 条目，也是 &lt;code&gt;.gitmodules&lt;/code&gt; 文件中的部分。子模块的工作目录已从文件系统中删除，但是保留了Git目录，因为它可以签出过去的提交而无需从另一个存储库获取。</target>
        </trans-unit>
        <trans-unit id="c4fe2a741691af413a8b078592b8e6a937844e84" translate="yes" xml:space="preserve">
          <source>The delta data is a sequence of instructions to reconstruct an object from the base object. If the base object is deltified, it must be converted to canonical form first. Each instruction appends more and more data to the target object until it&amp;rsquo;s complete. There are two supported instructions so far: one for copy a byte range from the source object and one for inserting new data embedded in the instruction itself.</source>
          <target state="translated">增量数据是从基本对象重建对象的指令序列。如果基础对象被删除，则必须首先将其转换为规范形式。每条指令都会将越来越多的数据附加到目标对象，直到完成为止。到目前为止，有两种支持的指令：一种用于从源对象复制字节范围，另一种用于插入指令本身中嵌入的新数据。</target>
        </trans-unit>
        <trans-unit id="892bc72de2972bd5305c51b8962327a3cfb2518f" translate="yes" xml:space="preserve">
          <source>The depth parameter used in the delta compression algorithm used by &lt;code&gt;git gc --aggressive&lt;/code&gt;. This defaults to 50, which is the default for the &lt;code&gt;--depth&lt;/code&gt; option when &lt;code&gt;--aggressive&lt;/code&gt; isn&amp;rsquo;t in use.</source>
          <target state="translated">&lt;code&gt;git gc --aggressive&lt;/code&gt; 使用的增量压缩算法中使用的深度参数。默认值为50，这是未使用 &lt;code&gt;--depth&lt;/code&gt; 时 &lt;code&gt;--aggressive&lt;/code&gt; 选项的默认值。</target>
        </trans-unit>
        <trans-unit id="71588492154c20723b86643e523c1d2b33771cc9" translate="yes" xml:space="preserve">
          <source>The design of fast-import allows it to import large projects in a minimum amount of memory usage and processing time. Assuming the frontend is able to keep up with fast-import and feed it a constant stream of data, import times for projects holding 10+ years of history and containing 100,000+ individual commits are generally completed in just 1-2 hours on quite modest (~$2,000 USD) hardware.</source>
          <target state="translated">fast-import的设计使得它可以在最小的内存使用量和处理时间内导入大型项目。假设前端能够跟上fast-import的速度,并为其提供源源不断的数据流,那么对于拥有10年以上历史、包含100,000+个人提交的项目,在相当小的硬件(约2000美元)上,导入时间一般只需1-2小时即可完成。</target>
        </trans-unit>
        <trans-unit id="c420d947d2d5939e423cde725977f1dbb1cf946b" translate="yes" xml:space="preserve">
          <source>The developer might want to rebase those commits to a newer &lt;code&gt;master&lt;/code&gt; while keeping the branch topology, for example when the first topic branch is expected to be integrated into &lt;code&gt;master&lt;/code&gt; much earlier than the second one, say, to resolve merge conflicts with changes to the DownloadButton class that made it into &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">开发人员可能希望在保留分支拓扑的同时将这些提交重新分配到较新的 &lt;code&gt;master&lt;/code&gt; ，例如，当第一个主题分支要比第二个主题更早地集成到 &lt;code&gt;master&lt;/code&gt; 中时，例如，解决合并冲突和对DownloadButton的更改成为 &lt;code&gt;master&lt;/code&gt; 班级。</target>
        </trans-unit>
        <trans-unit id="38adb1a4eb1052b4c27e8f4f4a52ae35ba0619ad" translate="yes" xml:space="preserve">
          <source>The diff above shows the differences between the working-tree version of file.txt and the stage 2 and stage 3 versions. So instead of preceding each line by a single &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, it now uses two columns: the first column is used for differences between the first parent and the working directory copy, and the second for differences between the second parent and the working directory copy. (See the &quot;COMBINED DIFF FORMAT&quot; section of &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt; for a details of the format.)</source>
          <target state="translated">上面的差异显示了file.txt的工作树版本与阶段2和阶段3版本之间的差异。因此，它现在不再使用每行前面的单个 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; ，而是使用两列：第一列用于第一个父级和工作目录副本之间的差异，第二列用于第二个父级和工作目录副本之间的差异。 （有关格式的详细信息，请参见&lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt;的&amp;ldquo; COMBINED DIFF FORMAT&amp;rdquo;部分。）</target>
        </trans-unit>
        <trans-unit id="330f16adb7b4cb162abae538c3471400c6f3dfa4" translate="yes" xml:space="preserve">
          <source>The diff commands &lt;code&gt;git diff-index&lt;/code&gt;, &lt;code&gt;git diff-files&lt;/code&gt;, and &lt;code&gt;git diff-tree&lt;/code&gt; can be told to manipulate differences they find in unconventional ways before showing &lt;code&gt;diff&lt;/code&gt; output. The manipulation is collectively called &quot;diffcore transformation&quot;. This short note describes what they are and how to use them to produce &lt;code&gt;diff&lt;/code&gt; output that is easier to understand than the conventional kind.</source>
          <target state="translated">可以告诉diff命令 &lt;code&gt;git diff-index&lt;/code&gt; ， &lt;code&gt;git diff-files&lt;/code&gt; 和 &lt;code&gt;git diff-tree&lt;/code&gt; 在显示 &lt;code&gt;diff&lt;/code&gt; 输出之前以非常规的方式操纵他们发现的差异。该操作统称为&amp;ldquo; diffcore变换&amp;rdquo;。此简短说明描述了它们是什么以及如何使用它们来生成 &lt;code&gt;diff&lt;/code&gt; 输出，该输出比常规类型更易于理解。</target>
        </trans-unit>
        <trans-unit id="4e50a3e21215031cd44c450ab91735643c2d6198" translate="yes" xml:space="preserve">
          <source>The diffcore mechanism is fed a list of such comparison results (each of which is called &quot;filepair&quot;, although at this point each of them talks about a single file), and transforms such a list into another list. There are currently 5 such transformations:</source>
          <target state="translated">diffcore机制被送入一个这样的比较结果的列表(每一个比较结果都被称为 &quot;filepair&quot;,尽管此时每一个比较结果都在谈论一个文件),并将这样的列表转换为另一个列表。目前有5种这样的转换方式。</target>
        </trans-unit>
        <trans-unit id="5ccc68add0025f283e287a514f59373a91910067" translate="yes" xml:space="preserve">
          <source>The directory holding the sha1 objects is missing.</source>
          <target state="translated">保存sha1对象的目录不见了。</target>
        </trans-unit>
        <trans-unit id="3e56ce3070b6d1fe8bc11b5262f83540c8411c39" translate="yes" xml:space="preserve">
          <source>The directory to find the quilt patches.</source>
          <target state="translated">找到被子补丁的目录。</target>
        </trans-unit>
        <trans-unit id="0bb0f16c4fefb50922eb2b1990a8580cecff19f2" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is with:</source>
          <target state="translated">最简单的方法就是用。</target>
        </trans-unit>
        <trans-unit id="114ebd710b84299f5cb327f93e8be01e979eae23" translate="yes" xml:space="preserve">
          <source>The easy case</source>
          <target state="translated">简单的案例</target>
        </trans-unit>
        <trans-unit id="ae6685a0ed898fdf61a802d261028cc9079a0958" translate="yes" xml:space="preserve">
          <source>The editor used to edit the commit log message will be chosen from the &lt;code&gt;GIT_EDITOR&lt;/code&gt; environment variable, the core.editor configuration variable, the &lt;code&gt;VISUAL&lt;/code&gt; environment variable, or the &lt;code&gt;EDITOR&lt;/code&gt; environment variable (in that order). See &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; for details.</source>
          <target state="translated">将从 &lt;code&gt;GIT_EDITOR&lt;/code&gt; 环境变量，core.editor配置变量， &lt;code&gt;VISUAL&lt;/code&gt; 环境变量或 &lt;code&gt;EDITOR&lt;/code&gt; 环境变量（按此顺序）中选择用于编辑提交日志消息的编辑器。有关详细信息，请参见&lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e4dbd523803a96213d55b1fc234d8888f00a89f" translate="yes" xml:space="preserve">
          <source>The effect of the &lt;code&gt;git add&lt;/code&gt; was to add one entry to the index file:</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; 的作用是在索引文件中添加一个条目：</target>
        </trans-unit>
        <trans-unit id="8c668b981ec948c02063906a293d8a4332dec951" translate="yes" xml:space="preserve">
          <source>The effect of this is best shown by way of comparing to &lt;code&gt;--full-history&lt;/code&gt; with parent rewriting. The example turns into:</source>
          <target state="translated">通过与 &lt;code&gt;--full-history&lt;/code&gt; 与父代重写进行比较，可以最好地表明其效果。该示例变为：</target>
        </trans-unit>
        <trans-unit id="f01b79da1b24a8459870505ceabc7acd5dc253cb" translate="yes" xml:space="preserve">
          <source>The effective value of &quot;core.notesRef&quot; (possibly overridden by GIT_NOTES_REF) is also implicitly added to the list of refs to be displayed.</source>
          <target state="translated">core.notesRef &quot;的有效值(可能会被GIT_NOTES_REF覆盖)也会被隐性地添加到要显示的refs列表中。</target>
        </trans-unit>
        <trans-unit id="47170c140110158e7cecc3842f11a773c4cf2ae7" translate="yes" xml:space="preserve">
          <source>The effects of this are mostly persistent, e.g. when packs and loose objects are coalesced into one another pack the existing deltas in that pack might get re-used, but there are also various cases where we might pick a sub-optimal delta from a newer pack instead.</source>
          <target state="translated">这种影响主要是持久的,例如,当包和松散的对象被凝聚到另一个包中时,该包中现有的三角洲可能会被重新使用,但也有各种情况下,我们可能会从一个较新的包中挑选一个次优的三角洲来代替。</target>
        </trans-unit>
        <trans-unit id="e05ce4cdee1f111bdf6e1a5c14e6220d9920c4e2" translate="yes" xml:space="preserve">
          <source>The equivalence test is based on the diff, after removing whitespace and line numbers. git-cherry therefore detects when commits have been &quot;copied&quot; by means of &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;, &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; or &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">去除空白和行号后，等效测试基于差异。因此，&lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry&lt;/a&gt;通过git-cherry-pick [1]，&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;或&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;检测提交的时间。</target>
        </trans-unit>
        <trans-unit id="1c5c570f3616a5224dd6e91327ceb211453e9ddc" translate="yes" xml:space="preserve">
          <source>The error event may be emitted more than once. The format string allows post-processors to group errors by type without worrying about specific error arguments.</source>
          <target state="translated">错误事件可以发出一次以上。该格式字符串允许后处理器按类型对错误进行分组,而不必担心具体的错误参数。</target>
        </trans-unit>
        <trans-unit id="2c5c3dbbaebe5825bdfa9c22deed2d10f337e86e" translate="yes" xml:space="preserve">
          <source>The event format target is a JSON-based format of event data suitable for telemetry analysis. This format is enabled with the &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; environment variable or the &lt;code&gt;trace2.eventTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">事件格式目标是适用于遥测分析的事件数据的基于JSON的格式。此格式通过 &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; 环境变量或 &lt;code&gt;trace2.eventTarget&lt;/code&gt; 系统或全局配置设置启用。</target>
        </trans-unit>
        <trans-unit id="bb53cc945a6f48ddfeb31dcd9983e9640d488cf9" translate="yes" xml:space="preserve">
          <source>The ever-versatile &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; command can also be used to examine tree objects, but &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt; will give you more details:</source>
          <target state="translated">多功能&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;命令也可以用于检查树对象，但是&lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt;将为您提供更多详细信息：</target>
        </trans-unit>
        <trans-unit id="2cae5c144ae6a6f552f7dcee7bbaf0209258a3bd" translate="yes" xml:space="preserve">
          <source>The example configuration presented here is guaranteed to be backwards and forward compatible.</source>
          <target state="translated">这里介绍的例子配置保证向后和向前兼容。</target>
        </trans-unit>
        <trans-unit id="77578078110fe9093d1036dd58aeebc2db7df1b8" translate="yes" xml:space="preserve">
          <source>The exit code from this hook invocation is ignored, however a non-zero exit code will generate an error message.</source>
          <target state="translated">这个钩子调用的退出代码会被忽略,但是一个非零的退出代码会产生一个错误信息。</target>
        </trans-unit>
        <trans-unit id="1e405cb397afa437170eea29059b03dcf97426f6" translate="yes" xml:space="preserve">
          <source>The exit code from this hook invocation is ignored; the only thing left for &lt;code&gt;git-receive-pack&lt;/code&gt; to do at that point is to exit itself anyway.</source>
          <target state="translated">挂钩调用的退出代码将被忽略；那时 &lt;code&gt;git-receive-pack&lt;/code&gt; 要做的唯一一件事就是退出自己。</target>
        </trans-unit>
        <trans-unit id="5a81c04e486b5c66b0be7554a6e91773cfd1a9a9" translate="yes" xml:space="preserve">
          <source>The exit status determines whether git will use the data from the hook to limit its search. On error, it will fall back to verifying all files and folders.</source>
          <target state="translated">退出状态决定了git是否会使用钩子的数据来限制它的搜索。如果出错,它将回到验证所有文件和文件夹的状态。</target>
        </trans-unit>
        <trans-unit id="863cf74b97781c15eaa4bf39c81be105821817bd" translate="yes" xml:space="preserve">
          <source>The exit value of this program is negative on error, and the number of conflicts otherwise (truncated to 127 if there are more than that many conflicts). If the merge was clean, the exit value is 0.</source>
          <target state="translated">该程序的退出值在错误时为负值,否则为冲突数(如果冲突数超过那么多,则截断为127)。如果合并是干净的,则退出值为0。</target>
        </trans-unit>
        <trans-unit id="600e0ed5040d09634bf101b6adc431e3349d2258" translate="yes" xml:space="preserve">
          <source>The expected use case of this is to write supporting explanation for the commit that does not belong to the commit log message proper, and include it with the patch submission. While one can simply write these explanations after &lt;code&gt;format-patch&lt;/code&gt; has run but before sending, keeping them as Git notes allows them to be maintained between versions of the patch series (but see the discussion of the &lt;code&gt;notes.rewrite&lt;/code&gt; configuration options in &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; to use this workflow).</source>
          <target state="translated">预期的用例是为不属于提交日志消息的提交编写支持说明，并将其包含在补丁提交中。尽管可以在 &lt;code&gt;format-patch&lt;/code&gt; 运行之后但在发送之前简单地编写这些解释，但将它们保留为Git注释可以在补丁系列的各个版本之间进行维护（但请参见 &lt;code&gt;notes.rewrite&lt;/code&gt; 配置选项的讨论&lt;a href=&quot;git-notes&quot;&gt;git-notes [ 1]&lt;/a&gt;使用此工作流程）。</target>
        </trans-unit>
        <trans-unit id="7c7921a0c6ea4cec42a427f589011997d35e15f9" translate="yes" xml:space="preserve">
          <source>The external command can optionally write a single line to its standard output to be sent to the requestor as an error message when it declines the service.</source>
          <target state="translated">外部命令可以选择在其标准输出中写一行,作为拒绝服务时的错误信息发送给请求者。</target>
        </trans-unit>
        <trans-unit id="34c4f9db557882c9df4177a31e00a543de8934c9" translate="yes" xml:space="preserve">
          <source>The extra &lt;code&gt;NUL&lt;/code&gt; before the preimage path in renamed case is to allow scripts that read the output to tell if the current record being read is a single-path record or a rename/copy record without reading ahead. After reading added and deleted lines, reading up to &lt;code&gt;NUL&lt;/code&gt; would yield the pathname, but if that is &lt;code&gt;NUL&lt;/code&gt;, the record will show two paths.</source>
          <target state="translated">在重命名情况下，前映像路径之前的额外 &lt;code&gt;NUL&lt;/code&gt; 是允许读取输出的脚本告诉正在读取的当前记录是单路径记录还是重命名/复制记录，而无需提前读取。在读取添加和删除的行之后，最多读取 &lt;code&gt;NUL&lt;/code&gt; 会产生路径名，但是如果为 &lt;code&gt;NUL&lt;/code&gt; ，则记录将显示两个路径。</target>
        </trans-unit>
        <trans-unit id="1b54438722ed3844a0702f9ed09c56d6aef28ee2" translate="yes" xml:space="preserve">
          <source>The fast-import backend itself can import into an empty repository (one that has already been initialized by &lt;code&gt;git init&lt;/code&gt;) or incrementally update an existing populated repository. Whether or not incremental imports are supported from a particular foreign source depends on the frontend program in use.</source>
          <target state="translated">快速导入后端本身可以导入到一个空的存储库（已经由 &lt;code&gt;git init&lt;/code&gt; 初始化的存储库）中，也可以增量更新现有的填充存储库。是否从特定外部来源支持增量导入取决于所使用的前端程序。</target>
        </trans-unit>
        <trans-unit id="3dfacf796b68e98a60c628fed43445479dc82ce1" translate="yes" xml:space="preserve">
          <source>The fast-import mechanism used by &lt;code&gt;git p4&lt;/code&gt; creates one pack file for each invocation of &lt;code&gt;git p4 sync&lt;/code&gt;. Normally, Git garbage compression (&lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;) automatically compresses these to fewer pack files, but explicit invocation of &lt;code&gt;git repack -adf&lt;/code&gt; may improve performance.</source>
          <target state="translated">&lt;code&gt;git p4&lt;/code&gt; 使用的快速导入机制为 &lt;code&gt;git p4 sync&lt;/code&gt; 的每次调用创建一个打包文件。通常，Git垃圾压缩（&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;）自动将它们压缩为更少的打包文件，但是显式调用 &lt;code&gt;git repack -adf&lt;/code&gt; 可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="53e903dc94674f5b365dd31d16a6c2e334c714e3" translate="yes" xml:space="preserve">
          <source>The fetch and push protocols are not designed to prevent one side from stealing data from the other repository that was not intended to be shared. If you have private data that you need to protect from a malicious peer, your best option is to store it in another repository. This applies to both clients and servers. In particular, namespaces on a server are not effective for read access control; you should only grant read access to a namespace to clients that you would trust with read access to the entire repository.</source>
          <target state="translated">获取和推送协议并不是为了防止一方从另一个存储库中窃取不打算共享的数据而设计的。如果你有需要保护的私有数据不被恶意的对等方窃取,你最好的选择是将其存储在另一个存储库中。这适用于客户端和服务器。特别是,服务器上的命名空间对于读取访问控制是无效的;你应该只将对命名空间的读取访问权授予那些你会信任的对整个存储库有读取访问权的客户端。</target>
        </trans-unit>
        <trans-unit id="648bf821f46e9909499e1fbac0dd96a1ab871eb7" translate="yes" xml:space="preserve">
          <source>The fields (including the &lt;code&gt;-&amp;gt;&lt;/code&gt;) are separated from each other by a single space. If a filename contains whitespace or other nonprintable characters, that field will be quoted in the manner of a C string literal: surrounded by ASCII double quote (34) characters, and with interior special characters backslash-escaped.</source>
          <target state="translated">各个字段（包括 &lt;code&gt;-&amp;gt;&lt;/code&gt; ）之间用一个空格隔开。如果文件名包含空格或其他不可打印的字符，则该字段将以C字符串文字的形式引用：用ASCII双引号（34）字符包围，并用反斜杠转义的内部特殊字符。</target>
        </trans-unit>
        <trans-unit id="3994e582754827987cb1dab035b29a73b90c4b3e" translate="yes" xml:space="preserve">
          <source>The file consists of sections and variables. A section begins with the name of the section in square brackets and continues until the next section begins. Section names are case-insensitive. Only alphanumeric characters, &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;.&lt;/code&gt; are allowed in section names. Each variable must belong to some section, which means that there must be a section header before the first setting of a variable.</source>
          <target state="translated">该文件包含节和变量。一个部分以方括号中的部分名称开头，一直持续到下一个部分开始为止。节名称不区分大小写。仅字母数字字符 &lt;code&gt;-&lt;/code&gt; 和 &lt;code&gt;.&lt;/code&gt; 节名称中允许使用。每个变量必须属于某个节，这意味着在第一次设置变量之前必须有一个节头。</target>
        </trans-unit>
        <trans-unit id="b77694751b662ffffe51a33dc2cd7f9b8be897f4" translate="yes" xml:space="preserve">
          <source>The file contains one subsection per submodule, and the subsection value is the name of the submodule. The name is set to the path where the submodule has been added unless it was customized with the &lt;code&gt;--name&lt;/code&gt; option of &lt;code&gt;git submodule add&lt;/code&gt;. Each submodule section also contains the following required keys:</source>
          <target state="translated">该文件每个子模块包含一个子节，该子节的值是子模块的名称。该名称设置为添加子模块的路径，除非使用 &lt;code&gt;git submodule add&lt;/code&gt; 的 &lt;code&gt;--name&lt;/code&gt; 选项对其进行了自定义。每个子模块部分还包含以下必需键：</target>
        </trans-unit>
        <trans-unit id="d7d8ebbce919f993c68a8bac80b9fbb16d92024e" translate="yes" xml:space="preserve">
          <source>The file format includes parameters for the object ID hash function, so a future change of hash algorithm does not require a change in format.</source>
          <target state="translated">文件格式中包含了对象ID哈希函数的参数,所以将来改变哈希算法不需要改变格式。</target>
        </trans-unit>
        <trans-unit id="1bb6e340dc566db02505e0c4003761a9d85c40c1" translate="yes" xml:space="preserve">
          <source>The file is concluded with a trailer:</source>
          <target state="translated">文件的最后是一个预告片。</target>
        </trans-unit>
        <trans-unit id="996f5fbcdb16f7d7ee85c3a6ae77d46a1781884a" translate="yes" xml:space="preserve">
          <source>The file parameters can point at the user&amp;rsquo;s working file (e.g. &lt;code&gt;new-file&lt;/code&gt; in &quot;git-diff-files&quot;), &lt;code&gt;/dev/null&lt;/code&gt; (e.g. &lt;code&gt;old-file&lt;/code&gt; when a new file is added), or a temporary file (e.g. &lt;code&gt;old-file&lt;/code&gt; in the index). &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; should not worry about unlinking the temporary file --- it is removed when &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; exits.</source>
          <target state="translated">该文件中的参数可以在用户的工作文件指向（如 &lt;code&gt;new-file&lt;/code&gt; 在&amp;ldquo;混帐的Diff-文件&amp;rdquo;）， &lt;code&gt;/dev/null&lt;/code&gt; （如 &lt;code&gt;old-file&lt;/code&gt; 时添加一个新的文件），或临时文件（如 &lt;code&gt;old-file&lt;/code&gt; 索引中的文件）。 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 不必担心取消链接临时文件---在退出 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 时将其删除。</target>
        </trans-unit>
        <trans-unit id="b979e5d416845ad4db7c29ab613bf67d05d7d448" translate="yes" xml:space="preserve">
          <source>The files are read in the order given above, with last value found taking precedence over values read earlier. When multiple values are taken then all values of a key from all files will be used.</source>
          <target state="translated">文件按上述顺序读取,最后找到的值优先于前面读取的值。当取多个值时,则将使用所有文件中一个键的所有值。</target>
        </trans-unit>
        <trans-unit id="22cd650e22be9431ebec70f16e27f0954b25a243" translate="yes" xml:space="preserve">
          <source>The files to read the patch from. &lt;code&gt;-&lt;/code&gt; can be used to read from the standard input.</source>
          <target state="translated">从中读取补丁的文件。 &lt;code&gt;-&lt;/code&gt; 可用于从标准输入中读取。</target>
        </trans-unit>
        <trans-unit id="fc839d554b73db3187cb52551b31c221d5647965" translate="yes" xml:space="preserve">
          <source>The filter is expected to respond with a list of &quot;key=value&quot; pairs terminated with a flush packet. If the filter does not experience problems then the list must contain a &quot;success&quot; status. Right after these packets the filter is expected to send the content in zero or more pkt-line packets and a flush packet at the end. Finally, a second list of &quot;key=value&quot; pairs terminated with a flush packet is expected. The filter can change the status in the second list or keep the status as is with an empty list. Please note that the empty list must be terminated with a flush packet regardless.</source>
          <target state="translated">过滤器应该用一个 &quot;key=value &quot;对的列表来响应,并以一个冲洗包结束。如果过滤器没有遇到问题,那么这个列表必须包含一个 &quot;成功 &quot;状态。就在这些数据包之后,过滤器要以0个或更多的pkt-line数据包发送内容,并在最后发送一个flush数据包。最后,预计第二个 &quot;key=value &quot;对的列表将以一个flush包结束。过滤器可以改变第二个列表中的状态,也可以用一个空列表保持状态不变。请注意,无论如何,空列表都必须以一个flush包结束。</target>
        </trans-unit>
        <trans-unit id="48c7b9e769ad1a8ac7a03d8a91befba4e1dc75d4" translate="yes" xml:space="preserve">
          <source>The filter that will be applied when fetching from this promisor remote.</source>
          <target state="translated">从这个远程承诺者获取信息时应用的过滤器。</target>
        </trans-unit>
        <trans-unit id="67e1cbcd0bc26ca591869ec55e18981d4a05f31d" translate="yes" xml:space="preserve">
          <source>The filters are applied in the order as listed below. The &amp;lt;command&amp;gt; argument is always evaluated in the shell context using the &lt;code&gt;eval&lt;/code&gt; command (with the notable exception of the commit filter, for technical reasons). Prior to that, the &lt;code&gt;$GIT_COMMIT&lt;/code&gt; environment variable will be set to contain the id of the commit being rewritten. Also, GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE, GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL, and GIT_COMMITTER_DATE are taken from the current commit and exported to the environment, in order to affect the author and committer identities of the replacement commit created by &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; after the filters have run.</source>
          <target state="translated">过滤器的应用顺序如下。始终在shell上下文中使用 &lt;code&gt;eval&lt;/code&gt; 命令评估&amp;lt;command&amp;gt;参数（出于技术原因，commit过滤器明显例外）。在此之前， &lt;code&gt;$GIT_COMMIT&lt;/code&gt; 环境变量将设置为包含要重写的提交的ID。另外，GIT_AUTHOR_NAME，GIT_AUTHOR_EMAIL，GIT_AUTHOR_DATE，GIT_COMMITTER_NAME，GIT_COMMITTER_EMAIL和GIT_COMMITTER_DATE均从当前提交中提取并导出到环境中，以影响由&lt;a href=&quot;git-commit-tree&quot;&gt;[1]&lt;/a&gt;在git-commit-tree之后创建的替换提交的作者和提交者身份筛选器已运行。</target>
        </trans-unit>
        <trans-unit id="96e6a8e11c595c66ed126e7ed94498b41b8ef74c" translate="yes" xml:space="preserve">
          <source>The final &quot;/&quot; is important. The exported name is literally just prefixed with the specified string. Contrast this with the following example.</source>
          <target state="translated">最后的&quot;/&quot;很重要。导出的名称实际上只是用指定的字符串作为前缀。与下面的例子进行对比。</target>
        </trans-unit>
        <trans-unit id="5e71083855686454b686d549c1aa754044d9c24f" translate="yes" xml:space="preserve">
          <source>The final result will be a series of commits, one for each patch in the original mailbox, with authorship and commit log message each taken from the message containing each patch.</source>
          <target state="translated">最后的结果将是一系列的提交,每个补丁在原始邮箱中都有一个,作者和提交日志信息分别取自包含每个补丁的消息。</target>
        </trans-unit>
        <trans-unit id="d06dc79919ba8d7d4e32bae22586b9e61ea6ab90" translate="yes" xml:space="preserve">
          <source>The first &quot;git bisect&quot; subcommand to use is &quot;git bisect start&quot; to start the search. Then bounds must be set to limit the commit space. This is done usually by giving one &quot;bad&quot; and at least one &quot;good&quot; commit. They can be passed in the initial call to &quot;git bisect start&quot; like this:</source>
          <target state="translated">第一个要使用的 &quot;git bisect &quot;子命令是 &quot;git bisect start&quot;,开始搜索。然后,必须设置限制提交空间的界限,这通常是通过给出一个 &quot;坏 &quot;和至少一个 &quot;好 &quot;的提交来完成的。这通常是通过给出一个 &quot;坏的 &quot;和至少一个 &quot;好的 &quot;提交来完成的,它们可以在 &quot;git bisect start &quot;的初始调用中传递。在调用 &quot;git bisect start &quot;时,可以像这样传递它们。</target>
        </trans-unit>
        <trans-unit id="3dd96cc8c67fe6f3794e1faadfc16d4e75778490" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;origin&lt;/code&gt;, just tells Git to fetch from the repository you originally cloned from. The second argument tells Git to fetch the branch named &lt;code&gt;todo&lt;/code&gt; from the remote repository, and to store it locally under the name &lt;code&gt;refs/heads/my-todo-work&lt;/code&gt;.</source>
          <target state="translated">第一个参数 &lt;code&gt;origin&lt;/code&gt; 只是告诉Git从最初克隆的存储库中获取。第二个参数告诉Git 从远程存储库获取名为 &lt;code&gt;todo&lt;/code&gt; 的分支，并将其以 &lt;code&gt;refs/heads/my-todo-work&lt;/code&gt; 的名称本地存储。</target>
        </trans-unit>
        <trans-unit id="81bbac8df429c9294b949507806676c0327c9227" translate="yes" xml:space="preserve">
          <source>The first character given by this option will be the default character used when another separator is not specified in the config for this trailer.</source>
          <target state="translated">该选项给出的第一个字符将是该预告片配置中未指定其他分隔符时的默认字符。</target>
        </trans-unit>
        <trans-unit id="39b9ae2f52daae0742c9cd959c54a342268035c6" translate="yes" xml:space="preserve">
          <source>The first command fetches the &lt;code&gt;maint&lt;/code&gt; branch from the repository at &lt;code&gt;git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt; and the second command uses &lt;code&gt;FETCH_HEAD&lt;/code&gt; to examine the branch with &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;. The fetched objects will eventually be removed by git&amp;rsquo;s built-in housekeeping (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;).</source>
          <target state="translated">第一个命令从 &lt;code&gt;git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt; 的存储库中获取 &lt;code&gt;maint&lt;/code&gt; 分支，第二个命令使用 &lt;code&gt;FETCH_HEAD&lt;/code&gt; 通过&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;检查该分支。所获取的对象最终将由git的内置管家删除（请参见&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fc54aa6f7f46c36afb224191ab9ce02506aa2fd9" translate="yes" xml:space="preserve">
          <source>The first defense against such problems is backups. You can back up a Git directory using clone, or just using cp, tar, or any other backup mechanism.</source>
          <target state="translated">对此类问题的第一道防线就是备份。你可以使用clone备份Git目录,或者直接使用cp、tar或其他备份机制。</target>
        </trans-unit>
        <trans-unit id="eb17679ed2c14d3eecb0f1bd83c98beea1f4bea4" translate="yes" xml:space="preserve">
          <source>The first format is what gets used when &lt;code&gt;--stage&lt;/code&gt; is omitted or is not &lt;code&gt;--stage=all&lt;/code&gt;. The field tempname is the temporary file name holding the file content and path is the tracked path name in the index. Only the requested entries are output.</source>
          <target state="translated">第一种格式是 &lt;code&gt;--stage&lt;/code&gt; 省略或不是 &lt;code&gt;--stage=all&lt;/code&gt; 时使用的格式。字段tempname是保存文件内容的临时文件名，path是索引中跟踪的路径名。仅输出所请求的条目。</target>
        </trans-unit>
        <trans-unit id="e7e26fcb00a95d796be86027e9776fd349443123" translate="yes" xml:space="preserve">
          <source>The first is simple and appropriate if you do not have secure storage available for a password. It is generally configured by adding this to your config:</source>
          <target state="translated">第一种方法很简单,如果你没有安全的密码存储空间,那么这种方法是合适的。一般是通过在你的config中添加这个来配置的。</target>
        </trans-unit>
        <trans-unit id="561e4f0c34cc864db97b2078e570c6b7cf2ee83d" translate="yes" xml:space="preserve">
          <source>The first line of the input feeds 0 as the mode to remove the path; the SHA-1 does not matter as long as it is well formatted. Then the second and third line feeds stage 1 and stage 2 entries for that path. After the above, we would end up with this:</source>
          <target state="translated">输入的第一行输入0作为删除路径的模式,SHA-1并不重要,只要格式良好即可。然后第二行和第三行输入该路径的阶段1和阶段2条目。经过上面的操作,我们最终会得到这样的结果。</target>
        </trans-unit>
        <trans-unit id="d7a467221d570ce5d2e2454d168c252049fa7e64" translate="yes" xml:space="preserve">
          <source>The first number is the number of objects which are kept in individual files. The second is the amount of space taken up by those &quot;loose&quot; objects.</source>
          <target state="translated">第一个数字是保存在单个文件中的对象数量。第二个数字是这些 &quot;松散 &quot;物体所占的空间。</target>
        </trans-unit>
        <trans-unit id="1517f019c895db91a3158888218e464c0e667ed4" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the hook is the indicator for the working directory being updated. &quot;1&quot; meaning working directory was updated or &quot;0&quot; when the working directory was not updated.</source>
          <target state="translated">传递给钩子的第一个参数是被更新的工作目录的指示器,&quot;1 &quot;表示工作目录被更新,&quot;0 &quot;表示工作目录没有被更新。&quot;1 &quot;表示工作目录被更新,&quot;0 &quot;表示工作目录没有被更新。</target>
        </trans-unit>
        <trans-unit id="69f4b05a4b19ebccc10062a19a78b72d37ff6b60" translate="yes" xml:space="preserve">
          <source>The first rule takes precedence in the case of a single &amp;lt;commit&amp;gt;. To apply the second rule, i.e., format everything since the beginning of history up until &amp;lt;commit&amp;gt;, use the &lt;code&gt;--root&lt;/code&gt; option: &lt;code&gt;git format-patch
--root &amp;lt;commit&amp;gt;&lt;/code&gt;. If you want to format only &amp;lt;commit&amp;gt; itself, you can do this with &lt;code&gt;git format-patch -1 &amp;lt;commit&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">对于单个&amp;lt;commit&amp;gt;，第一个规则优先。要应用第二条规则，即格式化从历史记录开始到&amp;lt;commit&amp;gt;的所有内容，请使用 &lt;code&gt;--root&lt;/code&gt; 选项： &lt;code&gt;git format-patch --root &amp;lt;commit&amp;gt;&lt;/code&gt; 。如果只想格式化&amp;lt;commit&amp;gt;本身，则可以使用 &lt;code&gt;git format-patch -1 &amp;lt;commit&amp;gt;&lt;/code&gt; 进行格式化。</target>
        </trans-unit>
        <trans-unit id="088dfc95ab36375e45956a12e0a84d20b54cd1e3" translate="yes" xml:space="preserve">
          <source>The first step is trivial: when you want to tell Git about any changes to your working tree, you use the &lt;code&gt;git update-index&lt;/code&gt; program. That program normally just takes a list of filenames you want to update, but to avoid trivial mistakes, it refuses to add new entries to the index (or remove existing ones) unless you explicitly tell it that you&amp;rsquo;re adding a new entry with the &lt;code&gt;--add&lt;/code&gt; flag (or removing an entry with the &lt;code&gt;--remove&lt;/code&gt;) flag.</source>
          <target state="translated">第一步很简单：当您想告诉Git您对工作树的任何更改时，请使用 &lt;code&gt;git update-index&lt;/code&gt; 程序。该程序通常只获取您要更新的文件名列表，但为避免琐碎的错误，除非您明确告诉它要添加新条目，否则它将拒绝向索引添加新条目（或删除现有条目）。 &lt;code&gt;--add&lt;/code&gt; 标志（或使用 &lt;code&gt;--remove&lt;/code&gt; 删除条目）标志。</target>
        </trans-unit>
        <trans-unit id="a1763915dd6826ebefd6dfcb3fd9fb79e61ff2f7" translate="yes" xml:space="preserve">
          <source>The first time that a commit shows up in the stream, it has various other information about it printed out with a one-word tag at the beginning of each line describing the extra commit information (author, email, committer, dates, summary, etc.).</source>
          <target state="translated">当一个提交第一次出现在流中时,它的各种其他信息都会被打印出来,每行开头都有一个单字标签,描述额外的提交信息(作者、电子邮件、提交者、日期、摘要等)。</target>
        </trans-unit>
        <trans-unit id="33e2d00ff1c333999b37d340bc5ae3e8a3bfd826" translate="yes" xml:space="preserve">
          <source>The first time you run it, you will be prompted for your credentials. Enter the app-specific or your regular password as appropriate. If you have credential helper configured (see &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt;), the password will be saved in the credential store so you won&amp;rsquo;t have to type it the next time.</source>
          <target state="translated">首次运行时，将提示您输入凭据。输入特定于应用程序的密码或您的常规密码。如果您配置了凭据帮助程序（请参阅&lt;a href=&quot;git-credential&quot;&gt;git-credential [1]&lt;/a&gt;），则密码将保存在凭据存储区中，因此下次无需键入密码。</target>
        </trans-unit>
        <trans-unit id="1c77b9db9c00c5ba7e83e0fb24758e48237c23ee" translate="yes" xml:space="preserve">
          <source>The first two lines indicate that it is showing the two branches with the titles of their top-of-the-tree commits, you are currently on &lt;code&gt;master&lt;/code&gt; branch (notice the asterisk &lt;code&gt;*&lt;/code&gt; character), and the first column for the later output lines is used to show commits contained in the &lt;code&gt;master&lt;/code&gt; branch, and the second column for the &lt;code&gt;mybranch&lt;/code&gt; branch. Three commits are shown along with their titles. All of them have non blank characters in the first column (&lt;code&gt;*&lt;/code&gt; shows an ordinary commit on the current branch, &lt;code&gt;-&lt;/code&gt; is a merge commit), which means they are now part of the &lt;code&gt;master&lt;/code&gt; branch. Only the &quot;Some work&quot; commit has the plus &lt;code&gt;+&lt;/code&gt; character in the second column, because &lt;code&gt;mybranch&lt;/code&gt; has not been merged to incorporate these commits from the master branch. The string inside brackets before the commit log message is a short name you can use to name the commit. In the above example, &lt;code&gt;master&lt;/code&gt; and &lt;code&gt;mybranch&lt;/code&gt; are branch heads. &lt;code&gt;master^&lt;/code&gt; is the first parent of &lt;code&gt;master&lt;/code&gt; branch head. Please see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; if you want to see more complex cases.</source>
          <target state="translated">前两行表明它正在显示两个分支，并具有其树顶提交的标题，您当前位于 &lt;code&gt;master&lt;/code&gt; 分支上（请注意星号 &lt;code&gt;*&lt;/code&gt; 字符），后面输出行的第一列是用于显示 &lt;code&gt;master&lt;/code&gt; 分支中包含的提交，以及 &lt;code&gt;mybranch&lt;/code&gt; 分支的第二列。显示了三个提交及其标题。它们全部在第一列中具有非空白字符（ &lt;code&gt;*&lt;/code&gt; 显示当前分支上的普通提交， &lt;code&gt;-&lt;/code&gt; 是合并提交），这意味着它们现在是 &lt;code&gt;master&lt;/code&gt; 分支的一部分。只有&amp;ldquo;某些工作&amp;rdquo;提交才有加号 &lt;code&gt;+&lt;/code&gt; 第二列中的字符，因为 &lt;code&gt;mybranch&lt;/code&gt; 尚未合并以合并master分支中的这些提交。提交日志消息前方括号内的字符串是可用于命名提交的缩写。在上面的示例中， &lt;code&gt;master&lt;/code&gt; 和 &lt;code&gt;mybranch&lt;/code&gt; 是分支头。 &lt;code&gt;master^&lt;/code&gt; 是 &lt;code&gt;master&lt;/code&gt; 分支头的第一个父代。如果您想查看更复杂的情况，请参阅&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b2c923c8cb34a6329089d3ed63e2b76d6f7ceed" translate="yes" xml:space="preserve">
          <source>The folder to drop the mails into, which is typically the Drafts folder. For example: &quot;INBOX.Drafts&quot;, &quot;INBOX/Drafts&quot; or &quot;[Gmail]/Drafts&quot;. Required.</source>
          <target state="translated">要将邮件投递到的文件夹,通常是Drafts文件夹。例如:&quot;INBOX.Drafts&quot;、&quot;INBOX/Drafts &quot;或&quot;[Gmail]/Drafts&quot;。&quot;INBOX.Drafts&quot;,&quot;INBOX/Drafts &quot;或&quot;[Gmail]/Drafts&quot;。需要。</target>
        </trans-unit>
        <trans-unit id="396ef1fe12b6dc07f4e5a4f66f87333df9fb56e3" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;update&lt;/code&gt; procedures are only available via the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration variable:</source>
          <target state="translated">以下 &lt;code&gt;update&lt;/code&gt; 过程仅可通过 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 配置变量使用：</target>
        </trans-unit>
        <trans-unit id="109e44e80a38f6553ddae4455bbabc5ec0d98180" translate="yes" xml:space="preserve">
          <source>The following Thunderbird extensions are needed: AboutConfig from &lt;a href=&quot;http://aboutconfig.mozdev.org/&quot;&gt;http://aboutconfig.mozdev.org/&lt;/a&gt; and External Editor from &lt;a href=&quot;http://globs.org/articles.php?lng=en&amp;amp;pg=8&quot;&gt;http://globs.org/articles.php?lng=en&amp;amp;pg=8&lt;/a&gt;</source>
          <target state="translated">需要以下Thunderbird扩展：&lt;a href=&quot;http://aboutconfig.mozdev.org/&quot;&gt;http&lt;/a&gt; ://aboutconfig.mozdev.org/中的AboutConfig 和&lt;a href=&quot;http://globs.org/articles.php?lng=en&amp;amp;pg=8&quot;&gt;http://globs.org/articles.php?lng=en&amp;amp;pg=8中的&lt;/a&gt;外部编辑器</target>
        </trans-unit>
        <trans-unit id="f6722fafbaf6d78a6b809eec36e0605e28b20857" translate="yes" xml:space="preserve">
          <source>The following are helper commands used by the above; end users typically do not use them directly.</source>
          <target state="translated">以下是上述使用的辅助命令,最终用户一般不直接使用。</target>
        </trans-unit>
        <trans-unit id="7e10909a1942dd56a826033bd880f2f38314517d" translate="yes" xml:space="preserve">
          <source>The following command switches to the &quot;master&quot; branch:</source>
          <target state="translated">下面的命令可以切换到 &quot;主 &quot;分支。</target>
        </trans-unit>
        <trans-unit id="7a4f4c25f3029fcde1d4a38239fa9b13c5887156" translate="yes" xml:space="preserve">
          <source>The following command-line options change import semantics and may therefore not be passed as option:</source>
          <target state="translated">以下命令行选项改变了导入语义,因此不能作为选项传递。</target>
        </trans-unit>
        <trans-unit id="932cde1c301ce345d40b274a1f81ff3e5be711e6" translate="yes" xml:space="preserve">
          <source>The following command-specific comments apply:</source>
          <target state="translated">以下是对特定命令的评论。</target>
        </trans-unit>
        <trans-unit id="d6f2de10386ef19748ad0fa0931b3359b3969227" translate="yes" xml:space="preserve">
          <source>The following config settings can be used to modify &lt;code&gt;git p4&lt;/code&gt; behavior. They all are in the &lt;code&gt;git-p4&lt;/code&gt; section.</source>
          <target state="translated">以下配置设置可用于修改 &lt;code&gt;git p4&lt;/code&gt; 行为。它们都在 &lt;code&gt;git-p4&lt;/code&gt; 部分中。</target>
        </trans-unit>
        <trans-unit id="f68ee79cc1f0c0e26a0c766d89a6823644298bab" translate="yes" xml:space="preserve">
          <source>The following configuration variables tell gitweb where to find files. The values of these variables are paths on the filesystem.</source>
          <target state="translated">以下配置变量告诉gitweb在哪里查找文件。这些变量的值是文件系统中的路径。</target>
        </trans-unit>
        <trans-unit id="446ebc694e2441273405a78869483ed3506272c8" translate="yes" xml:space="preserve">
          <source>The following date formats are supported. A frontend should select the format it will use for this import by passing the format name in the --date-format=&amp;lt;fmt&amp;gt; command-line option.</source>
          <target state="translated">支持以下日期格式。前端应通过在--date-format = &amp;lt;fmt&amp;gt;命令行选项中传递格式名称来选择用于此导入的格式。</target>
        </trans-unit>
        <trans-unit id="e77a52167245e31f57d9305063355588365e98e5" translate="yes" xml:space="preserve">
          <source>The following description divides the low-level commands into commands that manipulate objects (in the repository, index, and working tree), commands that interrogate and compare objects, and commands that move objects and references between repositories.</source>
          <target state="translated">下面的描述将低级命令分为操作对象(在资源库、索引和工作树中)的命令、查询和比较对象的命令以及在资源库之间移动对象和引用的命令。</target>
        </trans-unit>
        <trans-unit id="8ce90b7b29314319d9c33a8b52e106d84ec9670f" translate="yes" xml:space="preserve">
          <source>The following escape sequences (beside &lt;code&gt;\&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt;) are recognized: &lt;code&gt;\n&lt;/code&gt; for newline character (NL), &lt;code&gt;\t&lt;/code&gt; for horizontal tabulation (HT, TAB) and &lt;code&gt;\b&lt;/code&gt; for backspace (BS). Other char escape sequences (including octal escape sequences) are invalid.</source>
          <target state="translated">可以识别以下转义序列（在 &lt;code&gt;\&quot;&lt;/code&gt; 和 &lt;code&gt;\\&lt;/code&gt; 旁边）： &lt;code&gt;\n&lt;/code&gt; 代表换行符（NL）， &lt;code&gt;\t&lt;/code&gt; 代表水平制表符（HT，TAB）， &lt;code&gt;\b&lt;/code&gt; 代表退格键（BS）。其他char逃逸序列（包括八进制）转义序列）无效。</target>
        </trans-unit>
        <trans-unit id="11e92a0ce8b123a34278f747bf61153deb05c5a4" translate="yes" xml:space="preserve">
          <source>The following example shows three branches, &quot;master&quot;, &quot;fixes&quot; and &quot;mhf&quot;:</source>
          <target state="translated">下面的例子显示了三个分支,&quot;master&quot;、&quot;fixes &quot;和 &quot;mhf&quot;。</target>
        </trans-unit>
        <trans-unit id="4297ab330b843af6f1af2259ff9a055a87b6bf37" translate="yes" xml:space="preserve">
          <source>The following features from &amp;lsquo;svn log&amp;rsquo; are supported:</source>
          <target state="translated">支持&amp;ldquo; svn日志&amp;rdquo;中的以下功能：</target>
        </trans-unit>
        <trans-unit id="9b96392c24cd31061920293e2fd2511a8543969f" translate="yes" xml:space="preserve">
          <source>The following flags further affect the behavior when comparing commits (but not trees).</source>
          <target state="translated">以下标志会进一步影响比较提交(但不是树)时的行为。</target>
        </trans-unit>
        <trans-unit id="c98119f1eba9806e1383e47ef0aa9d751dbdff13" translate="yes" xml:space="preserve">
          <source>The following format are available:</source>
          <target state="translated">有以下格式可供选择:</target>
        </trans-unit>
        <trans-unit id="5f08fc55d496958a337ddcb6a67febfb89f85554" translate="yes" xml:space="preserve">
          <source>The following key/value pairs are common to all events:</source>
          <target state="translated">以下键/值对是所有事件的共同点:</target>
        </trans-unit>
        <trans-unit id="0a5e5ff367236dbd6bf5580d5af5e71ae090b770" translate="yes" xml:space="preserve">
          <source>The following options affect the way the simplification is performed:</source>
          <target state="translated">以下选项会影响简化的方式。</target>
        </trans-unit>
        <trans-unit id="d99d5d2882d3fb95fadc56a0416699f5b886386d" translate="yes" xml:space="preserve">
          <source>The following options are available in either location:</source>
          <target state="translated">以下选项可在任一地点使用:</target>
        </trans-unit>
        <trans-unit id="6e9dd1ef0925dcf9e09b1e6e501e8d0360e77eba" translate="yes" xml:space="preserve">
          <source>The following options are defined and (under suitable circumstances) set by Git if the remote helper has the &lt;code&gt;option&lt;/code&gt; capability.</source>
          <target state="translated">如果远程帮助程序具有 &lt;code&gt;option&lt;/code&gt; 功能，则由Git定义并（在适当的情况下）设置以下选项。</target>
        </trans-unit>
        <trans-unit id="ad97d4ffb6c58a93bf3193a5402926d11d214aa1" translate="yes" xml:space="preserve">
          <source>The following options select the commits to be shown:</source>
          <target state="translated">以下选项选择要显示的提交。</target>
        </trans-unit>
        <trans-unit id="04bd1c24e8e494894e5123ce96e6c123a135b194" translate="yes" xml:space="preserve">
          <source>The following options:</source>
          <target state="translated">以下选项:</target>
        </trans-unit>
        <trans-unit id="7b3b3b2ba3a3d71942fecd2cbccdbee3fd847246" translate="yes" xml:space="preserve">
          <source>The following sequence attempts to backport a patch, bails out because the code the patch applies to has changed too much, and then tries again, this time exercising more care about matching up context lines.</source>
          <target state="translated">下面的序列试图回溯一个补丁,因为补丁所应用的代码变化太大而退出,然后再次尝试,这次在匹配上下文行时更加小心。</target>
        </trans-unit>
        <trans-unit id="0fb6c7c3c1a2e6361aa6d0f3ddafd309ebc6378c" translate="yes" xml:space="preserve">
          <source>The following sequence checks out the &lt;code&gt;master&lt;/code&gt; branch, reverts the &lt;code&gt;Makefile&lt;/code&gt; to two revisions back, deletes &lt;code&gt;hello.c&lt;/code&gt; by mistake, and gets it back from the index.</source>
          <target state="translated">以下序列检出 &lt;code&gt;master&lt;/code&gt; 分支，将 &lt;code&gt;Makefile&lt;/code&gt; 恢复为两个修订版本，错误地删除 &lt;code&gt;hello.c&lt;/code&gt; ，然后将其从索引中取回。</target>
        </trans-unit>
        <trans-unit id="b8a40037f7e020ad1f156eb7f08942ca8112c080" translate="yes" xml:space="preserve">
          <source>The following sequence switches to the &lt;code&gt;master&lt;/code&gt; branch, reverts the &lt;code&gt;Makefile&lt;/code&gt; to two revisions back, deletes hello.c by mistake, and gets it back from the index.</source>
          <target state="translated">以下序列切换到 &lt;code&gt;master&lt;/code&gt; 分支，将 &lt;code&gt;Makefile&lt;/code&gt; 恢复为两个修订版本，错误地删除hello.c，然后将其从索引中恢复。</target>
        </trans-unit>
        <trans-unit id="75477915a08ed3777518303fe3302c5a880167a8" translate="yes" xml:space="preserve">
          <source>The following sequences have a special meaning:</source>
          <target state="translated">以下序列具有特殊意义。</target>
        </trans-unit>
        <trans-unit id="b07d72a39fdd44876a293ab8f917fa6a1014bd8c" translate="yes" xml:space="preserve">
          <source>The following subcommands are available:</source>
          <target state="translated">可使用以下子命令。</target>
        </trans-unit>
        <trans-unit id="55332124e1bbf00265c49abce68b19cb8696bb39" translate="yes" xml:space="preserve">
          <source>The following syntaxes may be used with them:</source>
          <target state="translated">可与它们一起使用下列语法:</target>
        </trans-unit>
        <trans-unit id="f9c489d8b69bf82a63ff4a237dd2bd772b8fb351" translate="yes" xml:space="preserve">
          <source>The following tables show what happens when there are unmerged entries:</source>
          <target state="translated">下表显示了有未合并条目时的情况。</target>
        </trans-unit>
        <trans-unit id="3cc98c85c7406728df501340aea8c7fdc3f04d78" translate="yes" xml:space="preserve">
          <source>The following tips and tricks have been collected from various users of fast-import, and are offered here as suggestions.</source>
          <target state="translated">以下技巧和窍门是由fast-import的不同用户收集的,在此提供给大家作为建议。</target>
        </trans-unit>
        <trans-unit id="177a564b8e3982405afb3b516ab4bbb5063d1ee7" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=blob:limit=&amp;lt;n&amp;gt;[kmg]&lt;/code&gt; omits blobs larger than n bytes or units. n may be zero. The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB. For example, &lt;code&gt;blob:limit=1k&lt;/code&gt; is the same as &lt;code&gt;blob:limit=1024&lt;/code&gt;.</source>
          <target state="translated">形式 &lt;code&gt;--filter=blob:limit=&amp;lt;n&amp;gt;[kmg]&lt;/code&gt; 省略了斑点大于n个字节或单元大。n可以为零。后缀k，m和g可用于命名KiB，MiB或GiB中的单位。例如， &lt;code&gt;blob:limit=1k&lt;/code&gt; 与 &lt;code&gt;blob:limit=1024&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="94349f8d4383b34d05a696da3b05af67f12eec03" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=blob:none&lt;/code&gt; omits all blobs.</source>
          <target state="translated">&lt;code&gt;--filter=blob:none&lt;/code&gt; 形式省略所有斑点。</target>
        </trans-unit>
        <trans-unit id="39c705af761382dd23f074438f9b0e646bf492af" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=combine:&amp;lt;filter1&amp;gt;+&amp;lt;filter2&amp;gt;+&amp;hellip;​&amp;lt;filterN&amp;gt;&lt;/code&gt; can also be used to combined several filters, but this is harder than just repeating the &lt;code&gt;--filter&lt;/code&gt; flag and is usually not necessary. Filters are joined by &lt;code&gt;+&lt;/code&gt; and individual filters are %-encoded (i.e. URL-encoded). Besides the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; characters, the following characters are reserved and also must be encoded: &lt;code&gt;~!@#$^&amp;amp;*()[]{}\;&quot;,&amp;lt;&amp;gt;?&lt;/code&gt;&lt;code&gt;'`&lt;/code&gt; as well as all characters with ASCII code &amp;lt;= &lt;code&gt;0x20&lt;/code&gt;, which includes space and newline.</source>
          <target state="translated">形式 &lt;code&gt;--filter=combine:&amp;lt;filter1&amp;gt;+&amp;lt;filter2&amp;gt;+&amp;hellip;​&amp;lt;filterN&amp;gt;&lt;/code&gt; 也可以被用于组合几个过滤器，但是这不是仅仅重复较硬 &lt;code&gt;--filter&lt;/code&gt; 标志，通常是没有必要的。过滤器以 &lt;code&gt;+&lt;/code&gt; 开头，各个过滤器均经过％编码（即URL编码）。除 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 字符外，还保留以下字符，并且还必须对其进行编码： &lt;code&gt;~!@#$^&amp;amp;*()[]{}\;&quot;,&amp;lt;&amp;gt;?&lt;/code&gt; &lt;code&gt;'`&lt;/code&gt; 以及所有ASCII码&amp;lt; = &lt;code&gt;0x20&lt;/code&gt; ，其中包括空格和换行符。</target>
        </trans-unit>
        <trans-unit id="d52505ec75878146eb9054dceb4728d58b485513" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=sparse:oid=&amp;lt;blob-ish&amp;gt;&lt;/code&gt; uses a sparse-checkout specification contained in the blob (or blob-expression) &lt;code&gt;&amp;lt;blob-ish&amp;gt;&lt;/code&gt; to omit blobs that would not be not required for a sparse checkout on the requested refs.</source>
          <target state="translated">形式 &lt;code&gt;--filter=sparse:oid=&amp;lt;blob-ish&amp;gt;&lt;/code&gt; 使用稀疏结账规范包含在团块（团块或表达） &lt;code&gt;&amp;lt;blob-ish&amp;gt;&lt;/code&gt; 到不会被不需要用于稀疏结帐上省略斑点所要求的裁判。</target>
        </trans-unit>
        <trans-unit id="ef46a11218e9457b2745a05e86c211527bd23b7c" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=tree:&amp;lt;depth&amp;gt;&lt;/code&gt; omits all blobs and trees whose depth from the root tree is &amp;gt;= &amp;lt;depth&amp;gt; (minimum depth if an object is located at multiple depths in the commits traversed). &amp;lt;depth&amp;gt;=0 will not include any trees or blobs unless included explicitly in the command-line (or standard input when --stdin is used). &amp;lt;depth&amp;gt;=1 will include only the tree and blobs which are referenced directly by a commit reachable from &amp;lt;commit&amp;gt; or an explicitly-given object. &amp;lt;depth&amp;gt;=2 is like &amp;lt;depth&amp;gt;=1 while also including trees and blobs one more level removed from an explicitly-given commit or tree.</source>
          <target state="translated">形式 &lt;code&gt;--filter=tree:&amp;lt;depth&amp;gt;&lt;/code&gt; 会忽略所有从根树开始的深度大于等于= &amp;lt;depth&amp;gt;（如果对象在遍历的提交中位于多个深度处的最小深度）的所有Blob和树。除非在命令行中明确包含（或使用--stdin时的标准输入），否则&amp;lt;depth&amp;gt; = 0将不包含任何树或blob。 &amp;lt;depth&amp;gt; = 1将仅包含由&amp;lt;commit&amp;gt;或显式给出的对象可到达的提交直接引用的树和blob。 &amp;lt;depth&amp;gt; = 2类似于&amp;lt;depth&amp;gt; = 1，同时还包括树和blob，它们从显式给定的提交或树中删除了一个级别。</target>
        </trans-unit>
        <trans-unit id="143c72f9a0abe1adb065cd1c00c0271a08c274c4" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-any&lt;/code&gt; will allow object traversal to continue if a missing object is encountered. Missing objects will silently be omitted from the results.</source>
          <target state="translated">如果遇到丢失的对象，格式 &lt;code&gt;--missing=allow-any&lt;/code&gt; 将允许对象遍历继续。缺少的对象将在结果中被忽略。</target>
        </trans-unit>
        <trans-unit id="280716e3ccf86616960848b089fdadef81ba797d" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing object will raise an error.</source>
          <target state="translated">&lt;code&gt;--missing=allow-promisor&lt;/code&gt; 的形式类似于 &lt;code&gt;allow-any&lt;/code&gt; ，但仅允许针对期望的Promisor丢失对象继续进行对象遍历。意外丢失的对象将引发错误。</target>
        </trans-unit>
        <trans-unit id="563d9e750d01dbe920d57035d16bed3d91b9aea6" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing objects will raise an error.</source>
          <target state="translated">&lt;code&gt;--missing=allow-promisor&lt;/code&gt; 的形式类似于 &lt;code&gt;allow-any&lt;/code&gt; ，但仅允许针对期望的Promisor丢失对象继续进行对象遍历。意外丢失的对象将引发错误。</target>
        </trans-unit>
        <trans-unit id="28c618ed732782b866de4c7dcf716daa2ac64119" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that pack-objects stop with an error if a missing object is encountered. This is the default action.</source>
          <target state="translated">如果遇到丢失的对象，则 &lt;code&gt;--missing=error&lt;/code&gt; 格式请求打包对象以错误停止。这是默认操作。</target>
        </trans-unit>
        <trans-unit id="2ed32158adb2f2f236ac5307d5ba7c30f0630796" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that rev-list stop with an error if a missing object is encountered. This is the default action.</source>
          <target state="translated">如果遇到缺少的对象，则 &lt;code&gt;--missing=error&lt;/code&gt; 格式请求rev-list停止并显示错误。这是默认操作。</target>
        </trans-unit>
        <trans-unit id="67e4b67693941fe412533d5210bde2a413de8fb1" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=print&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will also print a list of the missing objects. Object IDs are prefixed with a &amp;ldquo;?&amp;rdquo; character.</source>
          <target state="translated">&lt;code&gt;--missing=print&lt;/code&gt; 的形式类似于 &lt;code&gt;allow-any&lt;/code&gt; ，但也会打印缺失对象的列表。对象ID的前缀为&amp;ldquo;？&amp;rdquo; 字符。</target>
        </trans-unit>
        <trans-unit id="09994cb2384da5eddbe0ae0a9a1ceca76d8c8bcc" translate="yes" xml:space="preserve">
          <source>The format of a &amp;lt;refspec&amp;gt; parameter is an optional plus &lt;code&gt;+&lt;/code&gt;, followed by the source &amp;lt;src&amp;gt;, followed by a colon &lt;code&gt;:&lt;/code&gt;, followed by the destination ref &amp;lt;dst&amp;gt;. The colon can be omitted when &amp;lt;dst&amp;gt; is empty. &amp;lt;src&amp;gt; is typically a ref, but it can also be a fully spelled hex object name.</source>
          <target state="translated">&amp;lt;refspec&amp;gt;参数的格式是可选的plus &lt;code&gt;+&lt;/code&gt; ，后跟源&amp;lt;src&amp;gt;，后跟冒号 &lt;code&gt;:&lt;/code&gt; ，然后是目标ref &amp;lt;dst&amp;gt;。&amp;lt;dst&amp;gt;为空时，可以省略冒号。&amp;lt;src&amp;gt;通常是引用，但也可以是完全拼写的十六进制对象名称。</target>
        </trans-unit>
        <trans-unit id="05c09db4c870e826391cf6ebde5a8cc33d2791f6" translate="yes" xml:space="preserve">
          <source>The format of these files is username followed by the encrypted password, for example:</source>
          <target state="translated">这些文件的格式是用户名,后面是加密的密码,例如。</target>
        </trans-unit>
        <trans-unit id="65670970ee487305077ce344ca1fb6c36a889cee" translate="yes" xml:space="preserve">
          <source>The former lets your shell expand the fileglob, and you are asking the dot-C files in your working tree to be overwritten with the version in the index. The latter passes the &lt;code&gt;*.c&lt;/code&gt; to Git, and you are asking the paths in the index that match the pattern to be checked out to your working tree. After running &lt;code&gt;git add hello.c; rm hello.c&lt;/code&gt;, you will &lt;code&gt;not&lt;/code&gt; see &lt;code&gt;hello.c&lt;/code&gt; in your working tree with the former, but with the latter you will.</source>
          <target state="translated">前者让您的shell扩展fileglob，然后您要求工作树中的dot-C文件被索引中的版本覆盖。后者将 &lt;code&gt;*.c&lt;/code&gt; 传递给Git，您正在询问索引中与要检出的模式匹配到您的工作树的路径。运行 &lt;code&gt;git add hello.c; rm hello.c&lt;/code&gt; ，您 &lt;code&gt;not&lt;/code&gt; 在工作树中与前者一起看到 &lt;code&gt;hello.c&lt;/code&gt; ，但与后者会看到。</target>
        </trans-unit>
        <trans-unit id="b363974f459c2a2b237a919650aa9dc9f75161d2" translate="yes" xml:space="preserve">
          <source>The frontend must specify the number of bytes of data.</source>
          <target state="translated">前端必须指定数据的字节数。</target>
        </trans-unit>
        <trans-unit id="23957db0f038e6b4263285c2923ad6ce72a805ca" translate="yes" xml:space="preserve">
          <source>The full SHA-1 object name (40-byte hexadecimal string), or a leading substring that is unique within the repository. E.g. dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the same commit object if there is no other object in your repository whose object name starts with dae86e.</source>
          <target state="translated">完整的 SHA-1 对象名称(40 字节的十六进制字符串),或者在版本库中唯一的前导子串,例如 dae86e1950b1277e545cee180551750029cfe735 和 dae86e 都命名为同一个提交对象,如果版本库中没有其他对象的话。例如 dae86e1950b1277e545cee180551750029cfe735 和 dae86e 都命名为同一个提交对象,如果你的版本库中没有其他对象的名字以 dae86e 开头。</target>
        </trans-unit>
        <trans-unit id="ce332106cb9361add9aaf31aea030a425aeed7be" translate="yes" xml:space="preserve">
          <source>The full name is occasionally useful if, for example, there ever exists a tag and a branch with the same name.</source>
          <target state="translated">例如,如果存在一个标签和一个同名的分支,全名偶尔会有用。</target>
        </trans-unit>
        <trans-unit id="d24187cae372eb76b2a26570ccfd9def8c8abdf6" translate="yes" xml:space="preserve">
          <source>The full pattern set allows for arbitrary pattern matches and complicated inclusion/exclusion rules. These can result in O(N*M) pattern matches when updating the index, where N is the number of patterns and M is the number of paths in the index. To combat this performance issue, a more restricted pattern set is allowed when &lt;code&gt;core.spareCheckoutCone&lt;/code&gt; is enabled.</source>
          <target state="translated">完整模式集允许任意模式匹配和复杂的包含/排除规则。这些可能导致更新索引时出现O（N * M）个模式匹配，其中N是模式数量，M是索引中路径的数量。为了解决此性能问题，启用 &lt;code&gt;core.spareCheckoutCone&lt;/code&gt; 时允许使用更多受限制的模式集。</target>
        </trans-unit>
        <trans-unit id="6d3e98918a57498bee35c9ef416c5932bb448c1f" translate="yes" xml:space="preserve">
          <source>The full syntax for a p4 view is documented in &lt;code&gt;p4 help views&lt;/code&gt;. &lt;code&gt;git p4&lt;/code&gt; knows only a subset of the view syntax. It understands multi-line mappings, overlays with &lt;code&gt;+&lt;/code&gt;, exclusions with &lt;code&gt;-&lt;/code&gt; and double-quotes around whitespace. Of the possible wildcards, &lt;code&gt;git p4&lt;/code&gt; only handles &lt;code&gt;&amp;hellip;​&lt;/code&gt;, and only when it is at the end of the path. &lt;code&gt;git p4&lt;/code&gt; will complain if it encounters an unhandled wildcard.</source>
          <target state="translated">&lt;code&gt;p4 help views&lt;/code&gt; 视图中记录了p4视图的完整语法。 &lt;code&gt;git p4&lt;/code&gt; 只知道视图语法的一个子集。它了解多行映射，带 &lt;code&gt;+&lt;/code&gt; 的叠加层，带 &lt;code&gt;-&lt;/code&gt; 的排除对象以及空格周围的双引号。可能的通配符， &lt;code&gt;git p4&lt;/code&gt; 只处理 &lt;code&gt;&amp;hellip;​&lt;/code&gt; ，只有当它在路的尽头。如果 &lt;code&gt;git p4&lt;/code&gt; 遇到未处理的通配符，它​​将抱怨。</target>
        </trans-unit>
        <trans-unit id="18d1519c9cf5420b92be3f082cd6f0aa89c3d260" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;skip_commit&lt;/code&gt; is defined as follows:</source>
          <target state="translated">函数 &lt;code&gt;skip_commit&lt;/code&gt; 定义如下：</target>
        </trans-unit>
        <trans-unit id="af7dd50b5e9b3d3ec2ae519f399794527002dc23" translate="yes" xml:space="preserve">
          <source>The functions defined by the Trace2 API are declared and documented in &lt;code&gt;trace2.h&lt;/code&gt;. It defines the API functions and wrapper macros for Trace2.</source>
          <target state="translated">由TRACE2 API定义的函数声明和中记录 &lt;code&gt;trace2.h&lt;/code&gt; 。它定义了Trace2的API函数和包装器宏。</target>
        </trans-unit>
        <trans-unit id="e5521fd46bed9d589b56b651d5f3ef04e9a3b2a8" translate="yes" xml:space="preserve">
          <source>The future of bisecting</source>
          <target state="translated">二分法的未来</target>
        </trans-unit>
        <trans-unit id="2aa4427c10c7d5c13ef7bbb9898f5fea28090dd1" translate="yes" xml:space="preserve">
          <source>The general idea is this: we generate a cost matrix between the commits in both commit ranges, then solve the least-cost assignment.</source>
          <target state="translated">一般的想法是:我们在两个提交范围内的提交之间生成一个成本矩阵,然后解决最小成本分配。</target>
        </trans-unit>
        <trans-unit id="0339eef2339eb8367ea8564b9ff6721cd9dea407" translate="yes" xml:space="preserve">
          <source>The git commit is created relative to the current origin revision (HEAD by default). A parent commit is created based on the origin, and then the unshelve commit is created based on that.</source>
          <target state="translated">git 提交是相对于当前的原点修订版(默认为 HEAD)而创建的。父提交是基于原点创建的,然后在此基础上创建unshelve提交。</target>
        </trans-unit>
        <trans-unit id="a5bbcd1beb35762403be84a14e62e0a4eb5d5226" translate="yes" xml:space="preserve">
          <source>The git object database</source>
          <target state="translated">git对象数据库</target>
        </trans-unit>
        <trans-unit id="80d403b9b878573aec88e9c705123dc6feedf769" translate="yes" xml:space="preserve">
          <source>The gitweb CGI script for viewing Git repositories over the web uses a perl script fragment as its configuration file. You can set variables using &quot;&lt;code&gt;our $variable = value&lt;/code&gt;&quot;; text from a &quot;#&quot; character until the end of a line is ignored. See &lt;strong&gt;perlsyn&lt;/strong&gt;(1) for details.</source>
          <target state="translated">用于在Web上查看Git存储库的gitweb CGI脚本使用perl脚本片段作为其配置文件。您可以使用&amp;ldquo; &lt;code&gt;our $variable = value&lt;/code&gt; &amp;rdquo; 来设置变量；从&amp;ldquo;＃&amp;rdquo;字符到行尾的文本将被忽略。有关详细信息，请参见&lt;strong&gt;perlsyn&lt;/strong&gt;（1）。</target>
        </trans-unit>
        <trans-unit id="a1a6c42c76028a67bf39dd75b77a2307812be731" translate="yes" xml:space="preserve">
          <source>The gitweb cgi script provides users an easy way to browse your project&amp;rsquo;s revisions, file contents and logs without having to install Git. Features like RSS/Atom feeds and blame/annotation details may optionally be enabled.</source>
          <target state="translated">gitweb cgi脚本为用户提供了一种无需安装Git即可轻松浏览项目修订版，文件内容和日志的简便方法。可以选择启用RSS / Atom提要和责备/注释详细信息之类的功能。</target>
        </trans-unit>
        <trans-unit id="eefcb42be74db518327d9c82beb9a165d884846e" translate="yes" xml:space="preserve">
          <source>The gitweb features that are configurable via &lt;code&gt;%feature&lt;/code&gt; hash are listed below. This should be a complete list, but ultimately the authoritative and complete list is in gitweb.cgi source code, with features described in the comments.</source>
          <target state="translated">下面列出了可通过 &lt;code&gt;%feature&lt;/code&gt; 哈希配置的gitweb功能。这应该是一个完整列表，但最终的权威和完整列表在gitweb.cgi源代码中，并在注释中描述了功能。</target>
        </trans-unit>
        <trans-unit id="bee84a897df9efb668b9aee969a1e660ed8af0a4" translate="yes" xml:space="preserve">
          <source>The gitweb.extraBranchRefs is actually a multi-valued configuration variable, so following example is also correct and the result is the same as of the snippet above:</source>
          <target state="translated">gitweb.extraBranchRefs实际上是一个多值的配置变量,所以下面的例子也是正确的,结果和上面的片段一样。</target>
        </trans-unit>
        <trans-unit id="ab9a5e4603e46ba18e0a4c5efe881c7ac8def35b" translate="yes" xml:space="preserve">
          <source>The given URL is recorded into &lt;code&gt;.gitmodules&lt;/code&gt; for use by subsequent users cloning the superproject. If the URL is given relative to the superproject&amp;rsquo;s repository, the presumption is the superproject and submodule repositories will be kept together in the same relative location, and only the superproject&amp;rsquo;s URL needs to be provided. git-submodule will correctly locate the submodule using the relative URL in &lt;code&gt;.gitmodules&lt;/code&gt;.</source>
          <target state="translated">给定的URL被记录到 &lt;code&gt;.gitmodules&lt;/code&gt; 中，供后续用户克隆超级项目使用。如果URL是相对于超级项目的存储库给出的，则假定超级项目和子模块存储库将被放置在相同的相对位置，并且仅需提供超级项目的URL。git-submodule将使用 &lt;code&gt;.gitmodules&lt;/code&gt; 中的相对URL正确定位子模块。</target>
        </trans-unit>
        <trans-unit id="1190edfebfe2406cf333713a0e461379865b033f" translate="yes" xml:space="preserve">
          <source>The goal of this tutorial is to introduce two fundamental pieces of Git&amp;rsquo;s architecture&amp;mdash;​the object database and the index file&amp;mdash;​and to provide the reader with everything necessary to understand the rest of the Git documentation.</source>
          <target state="translated">本教程的目的是介绍Git体系结构的两个基本部分-对象数据库和索引文件-并为读者提供理解其余Git文档所需的一切。</target>
        </trans-unit>
        <trans-unit id="880a291c14c1099392ebdd9b73ec08c93b7220d1" translate="yes" xml:space="preserve">
          <source>The hard case</source>
          <target state="translated">硬壳</target>
        </trans-unit>
        <trans-unit id="7d2a187748caf680c0e66173f60176ec60ea02ab" translate="yes" xml:space="preserve">
          <source>The header consists of 256 4-byte network byte order integers. N-th entry of this table records the number of objects in the corresponding pack, the first byte of whose object name is less than or equal to N. This is called the &lt;code&gt;first-level fan-out&lt;/code&gt; table.</source>
          <target state="translated">标头由256个4字节网络字节顺序整数组成。该表的第N个条目记录相应数据包中的对象数，其对象名称的第一个字节小于或等于N。这称为 &lt;code&gt;first-level fan-out&lt;/code&gt; 表。</target>
        </trans-unit>
        <trans-unit id="0e2dd021a6a8dc94bfb40a62a04904f17b8f1dab" translate="yes" xml:space="preserve">
          <source>The header is followed by number of object entries, each of which looks like this:</source>
          <target state="translated">头部后面是对象项的数量,每个对象项的样子是这样的。</target>
        </trans-unit>
        <trans-unit id="10743ced5c1563e940127b440ba806235a399ac8" translate="yes" xml:space="preserve">
          <source>The header is followed by sorted 24-byte entries, one entry per object in the pack. Each entry is:</source>
          <target state="translated">头部后面是经过排序的24字节条目,包中每个对象一个条目。每个条目是:</target>
        </trans-unit>
        <trans-unit id="03910dca7f1c0af7f3d0e6986f455aceaec86f05" translate="yes" xml:space="preserve">
          <source>The header of the email is configurable via command-line options. If not specified on the command line, the user will be prompted with a ReadLine enabled interface to provide the necessary information.</source>
          <target state="translated">电子邮件的标题可以通过命令行选项进行配置。如果没有在命令行中指定,用户将被提示使用ReadLine接口来提供必要的信息。</target>
        </trans-unit>
        <trans-unit id="53d28fdf80ee055eff1005765033449c285d4f79" translate="yes" xml:space="preserve">
          <source>The hook always runs after the automatic note copying (see &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) has happened, and thus has access to these notes.</source>
          <target state="translated">挂钩总是在自动注释复制后运行（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]中的&lt;/a&gt; &amp;ldquo; notes.rewrite。&amp;lt;command&amp;gt;&amp;rdquo; ），因此可以访问这些注释。</target>
        </trans-unit>
        <trans-unit id="55997df4465d2b793292e1300e70ff2f9e1a3588" translate="yes" xml:space="preserve">
          <source>The hook executes once for each ref to be updated, and takes three parameters:</source>
          <target state="translated">钩子对每一个要更新的 ref 执行一次,需要三个参数。</target>
        </trans-unit>
        <trans-unit id="6422fdbff7a8b80abf6e11b9c756369981239875" translate="yes" xml:space="preserve">
          <source>The hook is allowed to edit the message file in place, and can be used to normalize the message into some project standard format. It can also be used to refuse the commit after inspecting the message file.</source>
          <target state="translated">该钩子允许在原地编辑消息文件,并可用于将消息规范为某种项目标准格式。也可以用来在检查完消息文件后拒绝提交。</target>
        </trans-unit>
        <trans-unit id="7dd8785c8f6fdd3a8a45999afa9f773631b556f1" translate="yes" xml:space="preserve">
          <source>The hook receives a list of the rewritten commits on stdin, in the format</source>
          <target state="translated">钩子在 stdin 上接收重写的提交列表,格式为</target>
        </trans-unit>
        <trans-unit id="ffb0d43685532aa46e893849969758ab23367451" translate="yes" xml:space="preserve">
          <source>The hook receives the commit with which the tip of the current branch is going to be updated. It can exit with a non-zero status to refuse the push (when it does so, it must not modify the index or the working tree). Or it can make any necessary changes to the working tree and to the index to bring them to the desired state when the tip of the current branch is updated to the new commit, and exit with a zero status.</source>
          <target state="translated">钩子接收提交,当前分支的顶端将被更新。它可以以非零状态退出,拒绝推送(当它这样做时,它不能修改索引或工作树)。或者它可以对工作树和索引进行必要的修改,以便在当前分支的顶端更新到新的提交时,使它们达到所需的状态,然后以零状态退出。</target>
        </trans-unit>
        <trans-unit id="6e0236cadc345b5114c4c6984e7438ed153e1f2f" translate="yes" xml:space="preserve">
          <source>The hook should exit with non-zero status if it wants to disallow updating the named ref. Otherwise it should exit with zero.</source>
          <target state="translated">如果钩子要禁止更新命名的 ref,它应该以非零状态退出。否则应该以零退出。</target>
        </trans-unit>
        <trans-unit id="9739d79c49b82b53238e48aeefee9c342d93a499" translate="yes" xml:space="preserve">
          <source>The hook should output to stdout the list of all files in the working directory that may have changed since the requested time. The logic should be inclusive so that it does not miss any potential changes. The paths should be relative to the root of the working directory and be separated by a single NUL.</source>
          <target state="translated">钩子应该将工作目录中自请求时间以来可能发生变化的所有文件列表输出到stdp。这个逻辑应该是包容的,这样就不会错过任何潜在的变化。路径应该是相对于工作目录的根目录的,并且用一个NUL分隔。</target>
        </trans-unit>
        <trans-unit id="022998a9843b7be307eb2d587f13704cf2ce86bd" translate="yes" xml:space="preserve">
          <source>The horizontal line of history A---Q is taken to be the first parent of each merge. The commits are:</source>
          <target state="translated">历史上的横线A---Q取为每次合并的第一个父级。提交的内容是:</target>
        </trans-unit>
        <trans-unit id="bdf0ebdfb4273a6fce7952dfa28834b6e411cd7f" translate="yes" xml:space="preserve">
          <source>The hypothetical proxy command entries actually have a postfix to discern what URL they apply to. Here is how to change the entry for kernel.org to &quot;ssh&quot;.</source>
          <target state="translated">假设的代理命令条目实际上有一个后缀来辨别它们适用于什么URL。下面是如何将kernel.org的条目改为 &quot;ssh&quot;。</target>
        </trans-unit>
        <trans-unit id="4399284bfb632a08cce3f3533db563320f49af23" translate="yes" xml:space="preserve">
          <source>The id of a tree object to diff against.</source>
          <target state="translated">要对比的树对象的id。</target>
        </trans-unit>
        <trans-unit id="0505b9e9f78e78efa1c8b76bc422638cba05b1b7" translate="yes" xml:space="preserve">
          <source>The id of a tree object.</source>
          <target state="translated">树对象的id。</target>
        </trans-unit>
        <trans-unit id="2e60e84271eec03fd28b067b32c84bb5fbe76999" translate="yes" xml:space="preserve">
          <source>The id of the tree object(s) to be read/merged.</source>
          <target state="translated">要读取/合并的树对象的id。</target>
        </trans-unit>
        <trans-unit id="fb9074ec22bab96e3e97d4855db9bfaed224187c" translate="yes" xml:space="preserve">
          <source>The idea is that every 3 test for example, &quot;git bisect&quot; could ask the user to test a commit that has already been found to be &quot;good&quot; or &quot;bad&quot; (because one of its descendants or one of its ancestors has been found to be &quot;good&quot; or &quot;bad&quot; respectively). If it happens that a commit has been previously incorrectly classified then the bisection can be aborted early, hopefully before too many mistakes have been made. Then the user will have to look at what happened and then restart the bisection using a fixed bisect log.</source>
          <target state="translated">我们的想法是,每隔 3 次测试,例如,&quot;git bisect &quot;可以要求用户测试一个已经被发现是 &quot;好 &quot;或 &quot;坏 &quot;的提交(因为它的一个后代或它的一个祖先分别被发现是 &quot;好 &quot;或 &quot;坏&quot;)。如果碰巧一个提交之前已经被错误地分类,那么可以提前中止二分法,希望是在犯了太多错误之前。然后,用户必须查看发生了什么,然后使用固定的二分法日志重新开始二分法。</target>
        </trans-unit>
        <trans-unit id="b3a07b8c786a1b03697e9ded467b22cd2ece1ab4" translate="yes" xml:space="preserve">
          <source>The idea is to manually tell &lt;code&gt;git rebase&lt;/code&gt; &quot;where the old &lt;code&gt;subsystem&lt;/code&gt; ended and your &lt;code&gt;topic&lt;/code&gt; began&quot;, that is, what the old merge base between them was. You will have to find a way to name the last commit of the old &lt;code&gt;subsystem&lt;/code&gt;, for example:</source>
          <target state="translated">这个想法是手动告诉 &lt;code&gt;git rebase&lt;/code&gt; &amp;ldquo;旧 &lt;code&gt;subsystem&lt;/code&gt; 在哪里结束并且您的 &lt;code&gt;topic&lt;/code&gt; 开始了&amp;rdquo;，即它们之间的旧合并基础是什么。您将必须找到一种方法来命名旧 &lt;code&gt;subsystem&lt;/code&gt; 的最后一次提交，例如：</target>
        </trans-unit>
        <trans-unit id="1ff2a3a30d68d12ef6b058f357f43e3bd9cd4f0f" translate="yes" xml:space="preserve">
          <source>The idx files to verify.</source>
          <target state="translated">要核实的idx文件。</target>
        </trans-unit>
        <trans-unit id="fd29bd486dc43b124e6d98a808e18b86c2905ae4" translate="yes" xml:space="preserve">
          <source>The import checks out from CVS every revision of every file. Reportedly cvsimport can average some twenty revisions per second, so for a medium-sized project this should not take more than a couple of minutes. Larger projects or remote repositories may take longer.</source>
          <target state="translated">导入会从 CVS 中检查出每个文件的每一次修订。据报道,cvsimport 平均每秒可以修改 20 个版本,所以对于一个中等规模的项目来说,这应该不会超过几分钟。更大的项目或远程仓库可能需要更长的时间。</target>
        </trans-unit>
        <trans-unit id="69f04e00f7076b8b130e67c7134e53f7f1076bf2" translate="yes" xml:space="preserve">
          <source>The import is incremental, so if you call it again next month it will fetch any CVS updates that have been made in the meantime. For this to work, you must not modify the imported branches; instead, create new branches for your own changes, and merge in the imported branches as necessary.</source>
          <target state="translated">导入是增量式的,所以如果您下个月再调用它,它将获取在此期间所做的任何 CVS 更新。为了使这个方法有效,你不能修改导入的分支;相反,你必须为你自己的修改创建新的分支,并在必要时合并导入的分支。</target>
        </trans-unit>
        <trans-unit id="807035ab1f5be4f0cb3563dc9b49740571ca0fa4" translate="yes" xml:space="preserve">
          <source>The index</source>
          <target state="translated">该指数</target>
        </trans-unit>
        <trans-unit id="4284ed429265f3c1afc30e4fc09197d88352698c" translate="yes" xml:space="preserve">
          <source>The index and the working tree are adjusted as if you had previously run &lt;code&gt;git checkout &amp;lt;start_point&amp;gt;&lt;/code&gt;. This allows you to start a new history that records a set of paths similar to &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; by easily running &lt;code&gt;git commit -a&lt;/code&gt; to make the root commit.</source>
          <target state="translated">就像您以前运行 &lt;code&gt;git checkout &amp;lt;start_point&amp;gt;&lt;/code&gt; 一样，将调整索引和工作树。这样，您可以轻松运行 &lt;code&gt;git commit -a&lt;/code&gt; 进行根提交，从而开始一个新的历史记录，该记录记录了一组类似于 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 的路径。</target>
        </trans-unit>
        <trans-unit id="0818281aa21612fb5fa362015c64c5645d861084" translate="yes" xml:space="preserve">
          <source>The index contains all the information necessary to generate a single (uniquely determined) tree object.</source>
          <target state="translated">该索引包含了生成单个(唯一确定的)树对象的所有必要信息。</target>
        </trans-unit>
        <trans-unit id="3d9fb9e020c0d003a42d72f87f16ba2ba38226e6" translate="yes" xml:space="preserve">
          <source>The index enables fast comparisons between the tree object it defines and the working tree.</source>
          <target state="translated">该索引可以实现它定义的树对象和工作树之间的快速比较。</target>
        </trans-unit>
        <trans-unit id="eb65460c6179ccddcd4479166e9da44d8f5c40d8" translate="yes" xml:space="preserve">
          <source>The index file</source>
          <target state="translated">索引文件</target>
        </trans-unit>
        <trans-unit id="181ab401ce7a15640077d5cb413c24fc6eb6a97e" translate="yes" xml:space="preserve">
          <source>The index file is a cache of the state of a directory tree, used to create commits, check out working directories, and hold the various trees involved in a merge.</source>
          <target state="translated">索引文件是一个目录树状态的缓存,用于创建提交,检查工作目录,并保存合并中涉及的各种树。</target>
        </trans-unit>
        <trans-unit id="a98935eae61bfe66b9928e790965f624bf2f8b5b" translate="yes" xml:space="preserve">
          <source>The index file is initialized with a list of all paths and, for each path, a blob object and a set of attributes. The blob object represents the contents of the file as of the head of the current branch. The attributes (last modified time, size, etc.) are taken from the corresponding file in the working tree. Subsequent changes to the working tree can be found by comparing these attributes. The index may be updated with new content, and new commits may be created from the content stored in the index.</source>
          <target state="translated">索引文件用所有路径的列表和每个路径的blob对象和一组属性来初始化。blob对象表示当前分支头部的文件内容。属性(最后修改的时间、大小等)取自工作树中的相应文件。通过比较这些属性可以发现工作树的后续变化。索引可以用新的内容更新,也可以从索引中存储的内容创建新的提交。</target>
        </trans-unit>
        <trans-unit id="803387e9a63472a3287bdc2446032cf6e023e1d9" translate="yes" xml:space="preserve">
          <source>The index is a binary file (generally kept in &lt;code&gt;.git/index&lt;/code&gt;) containing a sorted list of path names, each with permissions and the SHA-1 of a blob object; &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; can show you the contents of the index:</source>
          <target state="translated">索引是一个二进制文件（通常保存在 &lt;code&gt;.git/index&lt;/code&gt; 中），其中包含路径名的排序列表，每个路径名均具有权限和blob对象的SHA-1；&lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]&lt;/a&gt;可以向您显示索引的内容：</target>
        </trans-unit>
        <trans-unit id="a9316182499a37d7c3626ac01aa8aab4c013b473" translate="yes" xml:space="preserve">
          <source>The index is also capable of storing multiple entries (called &quot;stages&quot;) for a given pathname. These stages are used to hold the various unmerged version of a file when a merge is in progress.</source>
          <target state="translated">索引还能够为一个给定的路径名存储多个条目(称为 &quot;阶段&quot;)。这些阶段用于在合并过程中保存文件的各种未合并版本。</target>
        </trans-unit>
        <trans-unit id="188f5a2d7cb942916f4771a1884b995e88b4142c" translate="yes" xml:space="preserve">
          <source>The index is thus a sort of temporary staging area, which is filled with a tree which you are in the process of working on.</source>
          <target state="translated">因此,索引是一种临时的中转站,里面装的是你正在做的一棵树。</target>
        </trans-unit>
        <trans-unit id="272f4c7f98ef3d0d8ac3fea3ee0b1455507c7b6c" translate="yes" xml:space="preserve">
          <source>The index is updated after successful completion, but the change must still be committed.</source>
          <target state="translated">成功完成后,索引会被更新,但更改仍然必须被提交。</target>
        </trans-unit>
        <trans-unit id="aaf3f3d73cad6f7ed8d83d0912688100fa696756" translate="yes" xml:space="preserve">
          <source>The index line includes the blob object names before and after the change. The &amp;lt;mode&amp;gt; is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.</source>
          <target state="translated">索引行包含更改前后的Blob对象名称。如果文件模式未更改，则包含&amp;lt;mode&amp;gt;；否则，将显示&amp;lt;mode&amp;gt;。否则，单独的行指示旧模式和新模式。</target>
        </trans-unit>
        <trans-unit id="0c2192b5aebec33a414387c35e4e32f7ffc2561e" translate="yes" xml:space="preserve">
          <source>The index may contain unmerged entries because of a previous failed merge. By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out. Using &lt;code&gt;-f&lt;/code&gt; will ignore these unmerged entries. The contents from a specific side of the merge can be checked out of the index by using &lt;code&gt;--ours&lt;/code&gt; or &lt;code&gt;--theirs&lt;/code&gt;. With &lt;code&gt;-m&lt;/code&gt;, changes made to the working tree file can be discarded to re-create the original conflicted merge result.</source>
          <target state="translated">由于先前合并失败，索引可能包含未合并的条目。默认情况下，如果您尝试从索引中检出此类条目，则检出操作将失败并且将不检出任何内容。使用 &lt;code&gt;-f&lt;/code&gt; 将忽略这些未合并的条目。可以使用 &lt;code&gt;--ours&lt;/code&gt; 或 &lt;code&gt;--theirs&lt;/code&gt; 从合并的特定方面将内容从索引中检出。使用 &lt;code&gt;-m&lt;/code&gt; ，可以放弃对工作树文件的更改以重新创建原始的冲突合并结果。</target>
        </trans-unit>
        <trans-unit id="4d0d51f29d49355316c3cef38c96a8eb5dfc2a8a" translate="yes" xml:space="preserve">
          <source>The index must be in a fully merged state.</source>
          <target state="translated">索引必须处于完全合并的状态。</target>
        </trans-unit>
        <trans-unit id="76af7fc7918327fcfae98949c1f8a57aa6273691" translate="yes" xml:space="preserve">
          <source>The information &lt;code&gt;git rerere&lt;/code&gt; records is also used when running &lt;code&gt;git rebase&lt;/code&gt;. After blowing away the test merge and continuing development on the topic branch:</source>
          <target state="translated">运行 &lt;code&gt;git rebase&lt;/code&gt; 时也会使用信息 &lt;code&gt;git rerere&lt;/code&gt; 记录。在完成测试合并并继续在主题分支上进行开发之后：</target>
        </trans-unit>
        <trans-unit id="15901a24c7f8cf8a87522005a6e5af387df87a55" translate="yes" xml:space="preserve">
          <source>The information regarding a particular file, stored in the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;. An index entry can be unmerged, if a &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; was started, but not yet finished (i.e. if the index contains multiple versions of that file).</source>
          <target state="translated">有关特定文件的信息，存储在&lt;a href=&quot;#def_index&quot;&gt;索引中&lt;/a&gt;。如果&lt;a href=&quot;#def_merge&quot;&gt;合并&lt;/a&gt;开始但尚未完成（例如，如果索引包含该文件的多个版本），则可以取消合并索引条目。</target>
        </trans-unit>
        <trans-unit id="e1b41d54924f3d005ef481db0b83a44bcb5b9a26" translate="yes" xml:space="preserve">
          <source>The initial &lt;code&gt;git svn clone&lt;/code&gt; can be quite time-consuming (especially for large Subversion repositories). If multiple people (or one person with multiple machines) want to use &lt;code&gt;git svn&lt;/code&gt; to interact with the same Subversion repository, you can do the initial &lt;code&gt;git svn clone&lt;/code&gt; to a repository on a server and have each person clone that repository with &lt;code&gt;git clone&lt;/code&gt;:</source>
          <target state="translated">最初的 &lt;code&gt;git svn clone&lt;/code&gt; 可能非常耗时（特别是对于大型Subversion存储库）。如果多个人（或一个拥有多台计算机的人）想要使用 &lt;code&gt;git svn&lt;/code&gt; 与同一个Subversion存储库进行交互，则可以将 &lt;code&gt;git svn clone&lt;/code&gt; 初始克隆到服务器上的存储库，并让每个人使用 &lt;code&gt;git clone&lt;/code&gt; 克隆该存储库：</target>
        </trans-unit>
        <trans-unit id="086eba2d4da1f4350d7506d860bddbb6a3656718" translate="yes" xml:space="preserve">
          <source>The initial clone may be time-consuming for a large project, but you will only need to clone once.</source>
          <target state="translated">对于一个大型项目来说,初始克隆可能会很耗时,但你只需要克隆一次。</target>
        </trans-unit>
        <trans-unit id="de40e4660568a286f9924fcf84aa107b9295fcd9" translate="yes" xml:space="preserve">
          <source>The initial revision lays the foundation for almost everything Git has today, but is small enough to read in one sitting.</source>
          <target state="translated">初次修订奠定了今天Git几乎所有的基础,但体积小,可以一次读完。</target>
        </trans-unit>
        <trans-unit id="c62040180edff3420ed3a70f2f1e520bccaa26ac" translate="yes" xml:space="preserve">
          <source>The insane thing. You really want to call the new version &quot;X&quot; too, &lt;code&gt;even though&lt;/code&gt; others have already seen the old one. So just use &lt;code&gt;git tag -f&lt;/code&gt; again, as if you hadn&amp;rsquo;t already published the old one.</source>
          <target state="translated">疯了 您真的也想将新版本称为&amp;ldquo; X&amp;rdquo;， &lt;code&gt;even though&lt;/code&gt; 其他人已经看到了旧版本。因此，只需再次使用 &lt;code&gt;git tag -f&lt;/code&gt; ，就好像您尚未发布旧版本一样。</target>
        </trans-unit>
        <trans-unit id="861707a12241605e66eb9230fb32f3c54a08448e" translate="yes" xml:space="preserve">
          <source>The intent of this option is to pick and choose lines of the patch to apply, or even to modify the contents of lines to be staged. This can be quicker and more flexible than using the interactive hunk selector. However, it is easy to confuse oneself and create a patch that does not apply to the index. See EDITING PATCHES below.</source>
          <target state="translated">这个选项的意图是挑选要应用补丁的行,甚至修改要分期的行的内容。这可以比使用交互式的块状选择器更快、更灵活。但是,很容易混淆自己的视线,创建一个不适用索引的补丁。参见下面的编辑补丁。</target>
        </trans-unit>
        <trans-unit id="44c76b656c6ccb35aba2b96c920b5e782121a3bc" translate="yes" xml:space="preserve">
          <source>The interactive backend drops commits by default that started empty and halts if it hits a commit that ended up empty. The &lt;code&gt;--keep-empty&lt;/code&gt; option exists for the interactive backend to allow it to keep commits that started empty.</source>
          <target state="translated">交互式后端默认丢弃开始为空的提交，如果命中最终为空的提交则停止。该 &lt;code&gt;--keep-empty&lt;/code&gt; 选项存在互动后端以使其保持这一开始空提交。</target>
        </trans-unit>
        <trans-unit id="c4d1b3aab1a5f39909af0bdb9766437575ff6138" translate="yes" xml:space="preserve">
          <source>The interactive mode is meant for this type of workflow:</source>
          <target state="translated">交互式模式就是针对这类工作流程的。</target>
        </trans-unit>
        <trans-unit id="bed5d62a356c4ef72d5d10899b110555c8810a69" translate="yes" xml:space="preserve">
          <source>The interactive rebase command was originally designed to handle individual patch series. As such, it makes sense to exclude merge commits from the todo list, as the developer may have merged the then-current &lt;code&gt;master&lt;/code&gt; while working on the branch, only to rebase all the commits onto &lt;code&gt;master&lt;/code&gt; eventually (skipping the merge commits).</source>
          <target state="translated">交互式rebase命令最初旨在处理各个修补程序系列。因此，将合并提交从待办事项列表中排除是有意义的，因为开发人员在分支上工作时可能已经合并了当时的 &lt;code&gt;master&lt;/code&gt; ，最终只是将所有提交重新基于 &lt;code&gt;master&lt;/code&gt; （跳过合并提交）。</target>
        </trans-unit>
        <trans-unit id="54aff08446e09f30da133e329eb3f3646033c66c" translate="yes" xml:space="preserve">
          <source>The interactive rebase will stop when a command fails (i.e. exits with non-0 status) to give you an opportunity to fix the problem. You can continue with &lt;code&gt;git rebase --continue&lt;/code&gt;.</source>
          <target state="translated">当命令失败（即以非0状态退出）时，交互式知识库将停止，从而为您提供解决问题的机会。您可以继续 &lt;code&gt;git rebase --continue&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a7f537099e4a0d8d8faba9c5e743d565b88b9dd" translate="yes" xml:space="preserve">
          <source>The interface (input, output, set of options and the semantics) to these low-level commands are meant to be a lot more stable than Porcelain level commands, because these commands are primarily for scripted use. The interface to Porcelain commands on the other hand are subject to change in order to improve the end user experience.</source>
          <target state="translated">这些低级命令的接口(输入、输出、选项集和语义)要比Porcelain级别的命令稳定得多,因为这些命令主要是供脚本使用的。另一方面,为了改善最终用户的体验,Porcelain命令的接口是可以改变的。</target>
        </trans-unit>
        <trans-unit id="bf907bc1bbd0905aa866d8781057341315704641" translate="yes" xml:space="preserve">
          <source>The internal block size to use when converting a revision specifier such as &lt;code&gt;@all&lt;/code&gt; into a list of specific change numbers. Instead of using a single call to &lt;code&gt;p4 changes&lt;/code&gt; to find the full list of changes for the conversion, there are a sequence of calls to &lt;code&gt;p4 changes -m&lt;/code&gt;, each of which requests one block of changes of the given size. The default block size is 500, which should usually be suitable.</source>
          <target state="translated">将修订说明符（例如 &lt;code&gt;@all&lt;/code&gt; )转换为特定更改编号列表时要使用的内部块大小。除了使用单个对 &lt;code&gt;p4 changes&lt;/code&gt; 调用来查找转换的完整列表之外，还有一系列对 &lt;code&gt;p4 changes -m&lt;/code&gt; 的调用，每个调用都请求一个给定大小的更改块。默认的块大小是500，通常应该合适。</target>
        </trans-unit>
        <trans-unit id="b58ee91a98701b75ecd0edc6713c67b3efbc3330" translate="yes" xml:space="preserve">
          <source>The internals are documented in the &lt;a href=&quot;api-index&quot;&gt;Git API documentation&lt;/a&gt;.</source>
          <target state="translated">内部信息记录在&lt;a href=&quot;api-index&quot;&gt;Git API文档中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="051387312310d89e1f2cd1a7644ba37793a94a7c" translate="yes" xml:space="preserve">
          <source>The known attack vectors are as follows:</source>
          <target state="translated">已知的攻击载体如下:</target>
        </trans-unit>
        <trans-unit id="d0880a7ce92ec68d75b7997f1b8b330766294029" translate="yes" xml:space="preserve">
          <source>The lack of a central group of &quot;committers&quot; means there is less need for formal decisions about who is &quot;in&quot; and who is &quot;out&quot;.</source>
          <target state="translated">缺乏一个 &quot;承诺者 &quot;的中心小组,意味着不需要正式决定谁 &quot;加入 &quot;和谁 &quot;退出&quot;。</target>
        </trans-unit>
        <trans-unit id="d217f82f775261a888c8090d4fd57de90a2943db" translate="yes" xml:space="preserve">
          <source>The last diff is empty, but no new commits have been made, and the head still doesn&amp;rsquo;t contain the new line:</source>
          <target state="translated">最后一个差异为空，但未进行任何新的提交，并且头仍不包含新行：</target>
        </trans-unit>
        <trans-unit id="fc6ae42476a6037281df209d5a37adfb042c084d" translate="yes" xml:space="preserve">
          <source>The last three commits (&lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;HEAD^&lt;/code&gt;, and &lt;code&gt;HEAD~2&lt;/code&gt;) were bad and you do not want to ever see them again. Do &lt;strong&gt;not&lt;/strong&gt; do this if you have already given these commits to somebody else. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for the implications of doing so.)</source>
          <target state="translated">最后三个提交（ &lt;code&gt;HEAD&lt;/code&gt; ， &lt;code&gt;HEAD^&lt;/code&gt; 和 &lt;code&gt;HEAD~2&lt;/code&gt; ）很糟糕，您不想再看到它们。难道&lt;strong&gt;不是&lt;/strong&gt;如果你已经给了这些提交给别人做。 （有关这样做的含义，请参见&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]中&lt;/a&gt;的&amp;ldquo;从UPSTREAM REBASE恢复&amp;rdquo;一节。）</target>
        </trans-unit>
        <trans-unit id="9b2685798225cd4befed46a027cdbd30eb245ee2" translate="yes" xml:space="preserve">
          <source>The latest stash you created is stored in &lt;code&gt;refs/stash&lt;/code&gt;; older stashes are found in the reflog of this reference and can be named using the usual reflog syntax (e.g. &lt;code&gt;stash@{0}&lt;/code&gt; is the most recently created stash, &lt;code&gt;stash@{1}&lt;/code&gt; is the one before it, &lt;code&gt;stash@{2.hours.ago}&lt;/code&gt; is also possible). Stashes may also be referenced by specifying just the stash index (e.g. the integer &lt;code&gt;n&lt;/code&gt; is equivalent to &lt;code&gt;stash@{n}&lt;/code&gt;).</source>
          <target state="translated">您创建的最新存储存储在 &lt;code&gt;refs/stash&lt;/code&gt; 中；在此引用的引用日志中可以找到较旧的隐藏项，并且可以使用常规引用日志语法进行命名（例如， &lt;code&gt;stash@{0}&lt;/code&gt; 是最新创建的隐藏项， &lt;code&gt;stash@{1}&lt;/code&gt; 是之前 &lt;code&gt;stash@{2.hours.ago}&lt;/code&gt; ）。还可以通过仅指定存储索引来引用存储（例如，整数 &lt;code&gt;n&lt;/code&gt; 等于 &lt;code&gt;stash@{n}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8bb7601b8118e6905d96f76a29452df6bc2ae98e" translate="yes" xml:space="preserve">
          <source>The latter is not available by default, unless configured.</source>
          <target state="translated">后者在默认情况下不可用,除非配置。</target>
        </trans-unit>
        <trans-unit id="9096be046e467fbce79d2a6fe63b310a7a8be174" translate="yes" xml:space="preserve">
          <source>The latter use of the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values can be overridden by giving the &lt;code&gt;--refmap=&amp;lt;refspec&amp;gt;&lt;/code&gt; parameter(s) on the command line.</source>
          <target state="translated">可以通过在命令行上提供 &lt;code&gt;--refmap=&amp;lt;refspec&amp;gt;&lt;/code&gt; 参数来覆盖对 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 值的后者使用。</target>
        </trans-unit>
        <trans-unit id="55ffd562f6b8b4abf7958d261df418cb81ead100" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, to retry when trying to lock an individual reference. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 100 (i.e., retry for 100ms).</source>
          <target state="translated">当试图锁定一个单独的引用时,重试的时间长度,以毫秒为单位。值0表示完全不重试;-1表示无限期重试。默认值为100(即重试100毫秒)。</target>
        </trans-unit>
        <trans-unit id="68a6d4f84896f5fe182696f59cffd1c668106a0a" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, to retry when trying to lock the &lt;code&gt;packed-refs&lt;/code&gt; file. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 1000 (i.e., retry for 1 second).</source>
          <target state="translated">尝试锁定 &lt;code&gt;packed-refs&lt;/code&gt; 文件时重试的时间长度（以毫秒为单位）。值0表示完全不重试；-1表示无限期尝试。默认值为1000（即重试1秒）。</target>
        </trans-unit>
        <trans-unit id="fff6cc41c6311b04938a1f36a103054a2f1d2e11" translate="yes" xml:space="preserve">
          <source>The list above is ordered by decreasing precedence; a URL that matches a config key&amp;rsquo;s path is preferred to one that matches its user name. For example, if the URL is &lt;code&gt;https://user@example.com/foo/bar&lt;/code&gt; a config key match of &lt;code&gt;https://example.com/foo&lt;/code&gt; will be preferred over a config key match of &lt;code&gt;https://user@example.com&lt;/code&gt;.</source>
          <target state="translated">上面的列表通过降低优先级进行排序；与配置键的路径匹配的URL优先于与用户名匹配的URL。例如，如果URL是 &lt;code&gt;https://user@example.com/foo/bar&lt;/code&gt; 的一个配置密钥匹配 &lt;code&gt;https://example.com/foo&lt;/code&gt; 将优于的一个配置关键匹配 &lt;code&gt;https://user@example.com&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34cf6a4a25da733f5b8366288a8f31ad385fa0ee" translate="yes" xml:space="preserve">
          <source>The list of identifiers, and other information, of the objects in a &lt;a href=&quot;#def_pack&quot;&gt;pack&lt;/a&gt;, to assist in efficiently accessing the contents of a pack.</source>
          <target state="translated">&lt;a href=&quot;#def_pack&quot;&gt;包中&lt;/a&gt;对象的标识符列表和其他信息，以帮助有效地访问包中的内容。</target>
        </trans-unit>
        <trans-unit id="58413b6422259538de8b3cfc5351841a4fb3ade2" translate="yes" xml:space="preserve">
          <source>The list of mailbox files to read patches from. If you do not supply this argument, the command reads from the standard input. If you supply directories, they will be treated as Maildirs.</source>
          <target state="translated">要读取补丁的邮箱文件列表。如果你不提供这个参数,命令将从标准输入中读取。如果你提供了目录,它们将被视为Maildirs。</target>
        </trans-unit>
        <trans-unit id="811a0eecf6c6689902c9fc1e00fe667f20b10132" translate="yes" xml:space="preserve">
          <source>The list of remotes which are fetched by &quot;git remote update &amp;lt;group&amp;gt;&quot;. See &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">由&amp;ldquo; git remote update &amp;lt;组&amp;gt;&amp;rdquo;获取的远程列表。参见&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3aadf5969931435dfd81a576572d271c1b7df1e4" translate="yes" xml:space="preserve">
          <source>The list you get with &quot;ls&quot; :-)</source>
          <target state="translated">你用 &quot;ls &quot;得到的列表:-)</target>
        </trans-unit>
        <trans-unit id="2d5bfecbee3eeb5c71f69bd43de88bc34222a07d" translate="yes" xml:space="preserve">
          <source>The local offset is specified by &lt;code&gt;&amp;lt;offutc&amp;gt;&lt;/code&gt; as a positive or negative offset from UTC. For example EST (which is 5 hours behind UTC) would be expressed in &lt;code&gt;&amp;lt;tz&amp;gt;&lt;/code&gt; by &amp;ldquo;-0500&amp;rdquo; while UTC is &amp;ldquo;+0000&amp;rdquo;. The local offset does not affect &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;; it is used only as an advisement to help formatting routines display the timestamp.</source>
          <target state="translated">&lt;code&gt;&amp;lt;offutc&amp;gt;&lt;/code&gt; 将本地偏移量指定为相对于UTC的正偏移量或负偏移量。例如，EST（比UTC晚5小时）将以 &lt;code&gt;&amp;lt;tz&amp;gt;&lt;/code&gt; 表示为&amp;ldquo; -0500&amp;rdquo;，而UTC是&amp;ldquo; +0000&amp;rdquo;。本地偏移量不影响 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; ；它仅用作建议，以帮助格式化例程显示时间戳。</target>
        </trans-unit>
        <trans-unit id="ab508d82c7d8a4545e2bb32ec9ec4fb2386a14cb" translate="yes" xml:space="preserve">
          <source>The location of an augmenting mailmap file. The default mailmap, located in the root of the repository, is loaded first, then the mailmap file pointed to by this variable. The location of the mailmap file may be in a repository subdirectory, or somewhere outside of the repository itself. See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">扩充邮件映射文件的位置。首先加载位于存储库根目录中的默认邮件映射，然后加载此变量指向的邮件映射文件。邮件映射文件的位置可以在存储库子目录中，也可以在存储库本身之外的某个位置。参见&lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt;和&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3bb0979c637e06c575b3f731f106ded5d4b916f" translate="yes" xml:space="preserve">
          <source>The location of per-instance and system-wide configuration files can be overridden using the following environment variables:</source>
          <target state="translated">可以使用以下环境变量覆盖每个实例和全系统配置文件的位置。</target>
        </trans-unit>
        <trans-unit id="9446c1e5cce4b2ece4fc10ff79540962e21c6551" translate="yes" xml:space="preserve">
          <source>The magic word &lt;code&gt;top&lt;/code&gt; (magic signature: &lt;code&gt;/&lt;/code&gt;) makes the pattern match from the root of the working tree, even when you are running the command from inside a subdirectory.</source>
          <target state="translated">魔术字 &lt;code&gt;top&lt;/code&gt; （魔术签名： &lt;code&gt;/&lt;/code&gt; ）使模式从工作树的根开始匹配，即使您是在子目录中运行命令也是如此。</target>
        </trans-unit>
        <trans-unit id="64ba77ac0581cbecc6b691422d0c5681817b2387" translate="yes" xml:space="preserve">
          <source>The main command loop has 6 subcommands (plus help and quit).</source>
          <target state="translated">主命令循环有6个子命令(加上帮助和退出)。</target>
        </trans-unit>
        <trans-unit id="0b0bee129956915b1cb776d4190a01b55932ed3c" translate="yes" xml:space="preserve">
          <source>The main command loop has 6 subcommands.</source>
          <target state="translated">主命令循环有6个子命令。</target>
        </trans-unit>
        <trans-unit id="821ddd85eba2b4bc6e95a82521b10b32287622db" translate="yes" xml:space="preserve">
          <source>The main trunk is stored in the Git branch named &lt;code&gt;origin&lt;/code&gt;, and additional CVS branches are stored in Git branches with the same names. The most recent version of the main trunk is also left checked out on the &lt;code&gt;master&lt;/code&gt; branch, so you can start adding your own changes right away.</source>
          <target state="translated">主干存储在名为 &lt;code&gt;origin&lt;/code&gt; 的Git分支中，其他CVS分支以相同的名称存储在Git分支中。主干线的最新版本还剩下签出的 &lt;code&gt;master&lt;/code&gt; 分支，这样你就可以开始添加你自己改变的时候了。</target>
        </trans-unit>
        <trans-unit id="f31023370321849385c22bc8ae521136bfffac45" translate="yes" xml:space="preserve">
          <source>The mapping of file names from the p4 depot path to Git, by default, involves removing the entire depot path. With this option, the full p4 depot path is retained in Git. For example, path &lt;code&gt;//depot/main/foo/bar.c&lt;/code&gt;, when imported from &lt;code&gt;//depot/main/&lt;/code&gt;, becomes &lt;code&gt;foo/bar.c&lt;/code&gt;. With &lt;code&gt;--keep-path&lt;/code&gt;, the Git path is instead &lt;code&gt;depot/main/foo/bar.c&lt;/code&gt;.</source>
          <target state="translated">默认情况下，从p4仓库路径到Git的文件名映射涉及删除整个仓库路径。使用此选项，完整的p4仓库路径将保留在Git中。例如，路径 &lt;code&gt;//depot/main/foo/bar.c&lt;/code&gt; ，从导入时 &lt;code&gt;//depot/main/&lt;/code&gt; 变得 &lt;code&gt;foo/bar.c&lt;/code&gt; 。与 &lt;code&gt;--keep-path&lt;/code&gt; ，所述路径GIT中是代替 &lt;code&gt;depot/main/foo/bar.c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="696795b724c116f40755fe0ffd2f815f95c8f529" translate="yes" xml:space="preserve">
          <source>The mark command is optional here as some frontends have chosen to generate the Git SHA-1 for the blob on their own, and feed that directly to &lt;code&gt;commit&lt;/code&gt;. This is typically more work than it&amp;rsquo;s worth however, as marks are inexpensive to store and easy to use.</source>
          <target state="translated">mark命令在这里是可选的，因为一些前端已经选择自行生成Blob的Git SHA-1，并直接将其 &lt;code&gt;commit&lt;/code&gt; 以进行提交。但是，由于标记的存储成本低且易于使用，因此这通常比值得的工作还要多。</target>
        </trans-unit>
        <trans-unit id="154d6f76415eae422478f55f25c1ddb853a4e1ab" translate="yes" xml:space="preserve">
          <source>The maximum delta depth used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; when no maximum depth is given on the command line. Defaults to 50. Maximum value is 4095.</source>
          <target state="translated">&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;在命令行上未指定最大深度时使用的最大增量深度。默认值为50。最大值为4095。</target>
        </trans-unit>
        <trans-unit id="9325da9117f9b4afd884e4f7e837bf9ca641172e" translate="yes" xml:space="preserve">
          <source>The maximum memory in bytes used for caching deltas in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; before writing them out to a pack. This cache is used to speed up the writing object phase by not having to recompute the final delta result once the best match for all objects is found. Repacking large repositories on machines which are tight with memory might be badly impacted by this though, especially if this cache pushes the system into swapping. A value of 0 means no limit. The smallest size of 1 byte may be used to virtually disable this cache. Defaults to 256 MiB.</source>
          <target state="translated">在将&lt;a href=&quot;git-pack-objects&quot;&gt;Delta-pack-objects [1]中的&lt;/a&gt;增量写入数据包之前，用于缓存增量的最大内存（以字节为单位）。一旦找到了所有对象的最佳匹配项，就不必重新计算最终的增量结果，此缓存可用于加快写入对象的阶段。但是，在内存紧张的计算机上重新打包大型存储库可能会受到严重影响，特别是如果此缓存将系统推向交换状态。值为0表示没有限制。 1字节的最小大小可用于虚拟禁用此缓存。默认为256 MiB。</target>
        </trans-unit>
        <trans-unit id="a0015a1c1a155cb39bc99dd58a785f6e45fb6909" translate="yes" xml:space="preserve">
          <source>The maximum size of a delta, that is cached in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This cache is used to speed up the writing object phase by not having to recompute the final delta result once the best match for all objects is found. Defaults to 1000. Maximum value is 65535.</source>
          <target state="translated">增量的最大大小，该大小缓存在&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]中&lt;/a&gt;。一旦找到所有对象的最佳匹配，就不必重新计算最终的增量结果，就可以使用该缓存来加快写入对象的阶段。默认值为1000。最大值为65535。</target>
        </trans-unit>
        <trans-unit id="d2696797b76aad16406d56dd354feaf085869327" translate="yes" xml:space="preserve">
          <source>The maximum size of a pack. This setting only affects packing to a file when repacking, i.e. the git:// protocol is unaffected. It can be overridden by the &lt;code&gt;--max-pack-size&lt;/code&gt; option of &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. Reaching this limit results in the creation of multiple packfiles; which in turn prevents bitmaps from being created. The minimum size allowed is limited to 1 MiB. The default is unlimited. Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">一包的最大尺寸。此设置仅在重新打包时影响打包到文件，即git：//协议不受影响。可以通过&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;的 &lt;code&gt;--max-pack-size&lt;/code&gt; 选项覆盖它。达到此限制将导致创建多个packfile；反过来又阻止了位图的创建。允许的最小大小限制为1 MiB。默认值为无限制。支持 &lt;code&gt;k&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; 或 &lt;code&gt;g&lt;/code&gt; 的通用单位后缀。</target>
        </trans-unit>
        <trans-unit id="bb8ed32c533714ca4a8bb85ec574c3c5791f3a2f" translate="yes" xml:space="preserve">
          <source>The maximum size of memory that is consumed by each thread in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for pack window memory when no limit is given on the command line. The value can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. When left unconfigured (or set explicitly to 0), there will be no limit.</source>
          <target state="translated">当在命令行上未给出限制时，&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]中&lt;/a&gt;的每个线程在pack窗口内存中占用的最大内存大小。该值可以带有&amp;ldquo; k&amp;rdquo;，&amp;ldquo; m&amp;rdquo;或&amp;ldquo; g&amp;rdquo;后缀。取消配置（或显式设置为0）时，将没有限制。</target>
        </trans-unit>
        <trans-unit id="565cc584b68c5b675a716ec7daae7fd9f3343784" translate="yes" xml:space="preserve">
          <source>The meaning of each part of feature configuration is described below:</source>
          <target state="translated">下面将介绍功能配置中各部分的含义。</target>
        </trans-unit>
        <trans-unit id="657f593653b8985b76ea363799992d9ccd8552d1" translate="yes" xml:space="preserve">
          <source>The merge driver can learn the pathname in which the merged result will be stored via placeholder &lt;code&gt;%P&lt;/code&gt;.</source>
          <target state="translated">合并驱动程序可以通过占位符 &lt;code&gt;%P&lt;/code&gt; 来学习将合并结果存储在其中的路径名。</target>
        </trans-unit>
        <trans-unit id="3a4ee88dc1fd419e5903b5a6b97383e8c2a1fab9" translate="yes" xml:space="preserve">
          <source>The merge driver is expected to leave the result of the merge in the file named with &lt;code&gt;%A&lt;/code&gt; by overwriting it, and exit with zero status if it managed to merge them cleanly, or non-zero if there were conflicts.</source>
          <target state="translated">期望合并驱动程序通过覆盖将合并结果保留在以 &lt;code&gt;%A&lt;/code&gt; 命名的文件中，如果它设法干净地合并它们，则退出状态为零；如果存在冲突，则合并状态为非零。</target>
        </trans-unit>
        <trans-unit id="d39522f0982abae4a359335f63ed088d0f4a4c4e" translate="yes" xml:space="preserve">
          <source>The merge mechanism (&lt;code&gt;git merge&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; commands) allows the backend &lt;code&gt;merge strategies&lt;/code&gt; to be chosen with &lt;code&gt;-s&lt;/code&gt; option. Some strategies can also take their own options, which can be passed by giving &lt;code&gt;-X&amp;lt;option&amp;gt;&lt;/code&gt; arguments to &lt;code&gt;git merge&lt;/code&gt; and/or &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">合并机制（ &lt;code&gt;git merge&lt;/code&gt; 和 &lt;code&gt;git pull&lt;/code&gt; 命令）允许使用 &lt;code&gt;-s&lt;/code&gt; 选项选择后端 &lt;code&gt;merge strategies&lt;/code&gt; 。某些策略也可以采用自己的选项，可以通过为 &lt;code&gt;git merge&lt;/code&gt; 和/或 &lt;code&gt;git pull&lt;/code&gt; 提供 &lt;code&gt;-X&amp;lt;option&amp;gt;&lt;/code&gt; 参数来传递它们。</target>
        </trans-unit>
        <trans-unit id="fa594438c3581495b74bb79c047cb66382bd8b0d" translate="yes" xml:space="preserve">
          <source>The merge workflow works by copying branches between upstream and downstream. Upstream can merge contributions into the official history; downstream base their work on the official history.</source>
          <target state="translated">合并工作流的工作原理是在上游和下游之间复制分支。上游可以将贡献合并到官方历史中;下游则以官方历史为基础开展工作。</target>
        </trans-unit>
        <trans-unit id="1df107645dfce75dc8613a8a0f6007cf8381d780" translate="yes" xml:space="preserve">
          <source>The merge-base command finds a common ancestor of the given commits, and always returns one or the other in the case where one is a descendant of the other; so the above output shows that e05db0fd actually is an ancestor of v1.5.0-rc1.</source>
          <target state="translated">merge-base命令可以找到给定提交的共同祖先,如果一个是另一个的后裔,总是返回一个或另一个;所以上面的输出显示e05db0fd实际上是v1.5.0-rc1的祖先。</target>
        </trans-unit>
        <trans-unit id="19f5c4372c6fc154ead993a9f4b5a82da922524d" translate="yes" xml:space="preserve">
          <source>The message taken from file with &lt;code&gt;-F&lt;/code&gt; and command line with &lt;code&gt;-m&lt;/code&gt; are usually used as the tag message unmodified. This option lets you further edit the message taken from these sources.</source>
          <target state="translated">从 &lt;code&gt;-F&lt;/code&gt; 的文件中获取的消息和 &lt;code&gt;-m&lt;/code&gt; 的命令行中获取的消息通常用作未修改的标记消息。此选项使您可以进一步编辑从这些来源获取的消息。</target>
        </trans-unit>
        <trans-unit id="1e2b72f6afed427d21f4e345d320e470730d82f9" translate="yes" xml:space="preserve">
          <source>The message taken from file with &lt;code&gt;-F&lt;/code&gt;, command line with &lt;code&gt;-m&lt;/code&gt;, and from commit object with &lt;code&gt;-C&lt;/code&gt; are usually used as the commit log message unmodified. This option lets you further edit the message taken from these sources.</source>
          <target state="translated">从 &lt;code&gt;-F&lt;/code&gt; 的文件，从 &lt;code&gt;-m&lt;/code&gt; 的命令行和从 &lt;code&gt;-C&lt;/code&gt; 的提交对象获取的消息通常用作未修改的提交日志消息。此选项使您可以进一步编辑从这些来源获取的消息。</target>
        </trans-unit>
        <trans-unit id="ae16f65784862fd6e529b736650355763df13327" translate="yes" xml:space="preserve">
          <source>The method by which a submodule is updated by &lt;code&gt;git submodule update&lt;/code&gt;, which is the only affected command, others such as &lt;code&gt;git checkout --recurse-submodules&lt;/code&gt; are unaffected. It exists for historical reasons, when &lt;code&gt;git submodule&lt;/code&gt; was the only command to interact with submodules; settings like &lt;code&gt;submodule.active&lt;/code&gt; and &lt;code&gt;pull.rebase&lt;/code&gt; are more specific. It is populated by &lt;code&gt;git submodule init&lt;/code&gt; from the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file. See description of &lt;code&gt;update&lt;/code&gt; command in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git submodule update&lt;/code&gt; 用来更新子模块的方法是唯一受影响的命令，而 &lt;code&gt;git checkout --recurse-submodules&lt;/code&gt; 等其他命令则不受影响。由于历史原因，它存在，当时 &lt;code&gt;git submodule&lt;/code&gt; 是与子模块进行交互的唯一命令。诸如 &lt;code&gt;submodule.active&lt;/code&gt; 和 &lt;code&gt;pull.rebase&lt;/code&gt; 之类的设置更为具体。它是由填充 &lt;code&gt;git submodule init&lt;/code&gt; 从&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;的文件。参见&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt;中 &lt;code&gt;update&lt;/code&gt; 命令的描述。</target>
        </trans-unit>
        <trans-unit id="04ef06b50b9899f38b1e5f5c81eb00396b6d2328" translate="yes" xml:space="preserve">
          <source>The mode parameter is optional (defaults to &lt;code&gt;all&lt;/code&gt;), and is used to specify the handling of untracked files; when -u is not used, the default is &lt;code&gt;normal&lt;/code&gt;, i.e. show untracked files and directories.</source>
          <target state="translated">mode参数是可选的（默认为 &lt;code&gt;all&lt;/code&gt; ），用于指定未跟踪文件的处理；当不使用-u时，默认值为 &lt;code&gt;normal&lt;/code&gt; ，即显示未跟踪的文件和目录。</target>
        </trans-unit>
        <trans-unit id="daee71f2e966cf5f390a0401b9f0381f1242178c" translate="yes" xml:space="preserve">
          <source>The mode parameter is used to specify the handling of ignored files. It is optional: it defaults to &lt;code&gt;traditional&lt;/code&gt;.</source>
          <target state="translated">mode参数用于指定忽略文件的处理。它是可选的：默认为 &lt;code&gt;traditional&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="789771a80f50eaf70002a855307c4e88ea3d25bd" translate="yes" xml:space="preserve">
          <source>The mode parameter is used to specify the handling of untracked files. It is optional: it defaults to &lt;code&gt;all&lt;/code&gt;, and if specified, it must be stuck to the option (e.g. &lt;code&gt;-uno&lt;/code&gt;, but not &lt;code&gt;-u no&lt;/code&gt;).</source>
          <target state="translated">mode参数用于指定未跟踪文件的处理。它是可选的：默认为 &lt;code&gt;all&lt;/code&gt; ，并且如果指定，则必须坚持使用该选项（例如， &lt;code&gt;-uno&lt;/code&gt; ，而不是 &lt;code&gt;-u no&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d56062b3fd6eee94e49e5896b7d127ee25df01a1" translate="yes" xml:space="preserve">
          <source>The modifications stashed away by this command can be listed with &lt;code&gt;git stash list&lt;/code&gt;, inspected with &lt;code&gt;git stash show&lt;/code&gt;, and restored (potentially on top of a different commit) with &lt;code&gt;git stash apply&lt;/code&gt;. Calling &lt;code&gt;git stash&lt;/code&gt; without any arguments is equivalent to &lt;code&gt;git stash push&lt;/code&gt;. A stash is by default listed as &quot;WIP on &lt;code&gt;branchname&lt;/code&gt; &amp;hellip;​&quot;, but you can give a more descriptive message on the command line when you create one.</source>
          <target state="translated">可以使用 &lt;code&gt;git stash list&lt;/code&gt; 列出该修改保存的修改，可以使用 &lt;code&gt;git stash show&lt;/code&gt; 进行检查，还可以使用 &lt;code&gt;git stash apply&lt;/code&gt; 恢复（可能在其他提交之上）。不带任何参数调用 &lt;code&gt;git stash&lt;/code&gt; 等效于 &lt;code&gt;git stash push&lt;/code&gt; 。默认情况下，存储项显示为&amp;ldquo; WIP on &lt;code&gt;branchname&lt;/code&gt; &amp;hellip;&amp;rdquo;，但是在创建存储项时，可以在命令行上提供更具描述性的消息。</target>
        </trans-unit>
        <trans-unit id="e06fa83026ee56ec3b62a659fa5a44c6e4e4728d" translate="yes" xml:space="preserve">
          <source>The module path (only needed if httpd is Apache). (Default: /usr/lib/apache2/modules)</source>
          <target state="translated">模块路径(只有当httpd是Apache时才需要)。(默认:/usr/lib/apache2/modules)</target>
        </trans-unit>
        <trans-unit id="08ed4170506fa174e84f549a0e3f26086c486529" translate="yes" xml:space="preserve">
          <source>The more complex forms are:</source>
          <target state="translated">比较复杂的形式是:</target>
        </trans-unit>
        <trans-unit id="7d735293dee944ca58932a7261110828d307c793" translate="yes" xml:space="preserve">
          <source>The most common cause of dangling objects is that you&amp;rsquo;ve rebased a branch, or you have pulled from somebody else who rebased a branch&amp;mdash;​see &lt;a href=&quot;#cleaning-up-history&quot;&gt;Rewriting history and maintaining patch series&lt;/a&gt;. In that case, the old head of the original branch still exists, as does everything it pointed to. The branch pointer itself just doesn&amp;rsquo;t, since you replaced it with another one.</source>
          <target state="translated">导致对象悬空的最常见原因是您已经重新建立了分支的基础，或者已经从重新建立分支的其他人那里撤走了-请参阅&lt;a href=&quot;#cleaning-up-history&quot;&gt;重写历史记录和维护修补程序系列&lt;/a&gt;。在这种情况下，原始分支的旧头仍然存在，它指向的所有内容也一样。分支指针本身只是不行，因为您已将其替换为另一个。</target>
        </trans-unit>
        <trans-unit id="8bc143dd44c89f63596943262174b04211332773" translate="yes" xml:space="preserve">
          <source>The multi-pack-index (MIDX for short) stores a list of objects and their offsets into multiple packfiles. It contains:</source>
          <target state="translated">多包索引(简称MIDX)将对象列表及其偏移量存储到多个包文件中。它包含:</target>
        </trans-unit>
        <trans-unit id="4ca15f678a55a1443f2d701a54958e45ad8a0235" translate="yes" xml:space="preserve">
          <source>The multi-pack-index allows many packfiles, especially in a context where repacking is expensive (such as a very large repo), or unexpected maintenance time is unacceptable (such as a high-demand build machine). However, the multi-pack-index needs to be rewritten in full every time. We can extend the format to be incremental, so writes are fast. By storing a small &quot;tip&quot; multi-pack-index that points to large &quot;base&quot; MIDX files, we can keep writes fast while still reducing the number of binary searches required for object lookups.</source>
          <target state="translated">multi-pack-index允许许多packfiles,特别是在重新打包成本很高的情况下(比如一个非常大的repo),或者意外的维护时间是不可接受的(比如一个高需求的构建机)。然而,多包索引每次都需要全部重写。我们可以将格式扩展为增量,所以写入速度很快。通过存储一个小的 &quot;小费 &quot;多包索引,指向大的 &quot;基础 &quot;MIDX文件,我们可以保持快速写入,同时还可以减少对象查找所需的二进制搜索次数。</target>
        </trans-unit>
        <trans-unit id="d98c840529f1ab7c2fa3df48a823219f4ff9a17e" translate="yes" xml:space="preserve">
          <source>The multi-pack-index files refer to multiple pack-files and loose objects.</source>
          <target state="translated">多包索引文件指的是多包文件和松散对象。</target>
        </trans-unit>
        <trans-unit id="1e0c8af9211e361d1a35789c37df84247f7ae9ac" translate="yes" xml:space="preserve">
          <source>The name and the e-mail address of the owner of the key that signed the push certificate.</source>
          <target state="translated">签署推送证书的密钥所有者的姓名和电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="2551d22d5e60fb51293e5ef827d3f2d640624d55" translate="yes" xml:space="preserve">
          <source>The name of a commit at which to start the new branch; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details. Defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">开始新分支的提交的名称；有关详细信息，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;。默认为 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0efd5464958e1be85e38672256be6f6e17bc462a" translate="yes" xml:space="preserve">
          <source>The name of a local ref which can be considered &amp;ldquo;upstream&amp;rdquo; from the displayed ref. Respects &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt; and &lt;code&gt;:rstrip&lt;/code&gt; in the same way as &lt;code&gt;refname&lt;/code&gt; above. Additionally respects &lt;code&gt;:track&lt;/code&gt; to show &quot;[ahead N, behind M]&quot; and &lt;code&gt;:trackshort&lt;/code&gt; to show the terse version: &quot;&amp;gt;&quot; (ahead), &quot;&amp;lt;&quot; (behind), &quot;&amp;lt;&amp;gt;&quot; (ahead and behind), or &quot;=&quot; (in sync). &lt;code&gt;:track&lt;/code&gt; also prints &quot;[gone]&quot; whenever unknown upstream ref is encountered. Append &lt;code&gt;:track,nobracket&lt;/code&gt; to show tracking information without brackets (i.e &quot;ahead N, behind M&quot;).</source>
          <target state="translated">本地裁判的名称，可以将其视为所显示裁判的&amp;ldquo;上游&amp;rdquo;。与上面的 &lt;code&gt;refname&lt;/code&gt; 一样，尊重 &lt;code&gt;:short&lt;/code&gt; ， &lt;code&gt;:lstrip&lt;/code&gt; 和 &lt;code&gt;:rstrip&lt;/code&gt; 。另外， &lt;code&gt;:track&lt;/code&gt; 表示&amp;ldquo; [[N之前，M后面]&amp;rdquo;，而 &lt;code&gt;:trackshort&lt;/code&gt; 表示简洁的版本：&amp;ldquo;&amp;gt;&amp;rdquo;（前面），&amp;ldquo; &amp;lt;&amp;rdquo;（后面），&amp;ldquo; &amp;lt;&amp;gt;&amp;rdquo;（前面和后面）或&amp;ldquo; =&amp;ldquo;（同步）。 &lt;code&gt;:track&lt;/code&gt; 每当遇到未知的上游引用时也会打印&amp;ldquo; [gone]&amp;rdquo;。附加 &lt;code&gt;:track,nobracket&lt;/code&gt; 以不带括号的方式显示跟踪信息（即&amp;ldquo; N前面，M后面&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="285243cf13ade280f7038dfb92bbdaa7d26dec36" translate="yes" xml:space="preserve">
          <source>The name of a local ref which represents the &lt;code&gt;@{push}&lt;/code&gt; location for the displayed ref. Respects &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt;, &lt;code&gt;:rstrip&lt;/code&gt;, &lt;code&gt;:track&lt;/code&gt;, &lt;code&gt;:trackshort&lt;/code&gt;, &lt;code&gt;:remotename&lt;/code&gt;, and &lt;code&gt;:remoteref&lt;/code&gt; options as &lt;code&gt;upstream&lt;/code&gt; does. Produces an empty string if no &lt;code&gt;@{push}&lt;/code&gt; ref is configured.</source>
          <target state="translated">本地引用的名称，代表所显示引用的 &lt;code&gt;@{push}&lt;/code&gt; 位置。与 &lt;code&gt;upstream&lt;/code&gt; 一样，尊重 &lt;code&gt;:short&lt;/code&gt; ， &lt;code&gt;:lstrip&lt;/code&gt; ， &lt;code&gt;:rstrip&lt;/code&gt; ， &lt;code&gt;:track&lt;/code&gt; ， &lt;code&gt;:trackshort&lt;/code&gt; ， &lt;code&gt;:remotename&lt;/code&gt; 和 &lt;code&gt;:remoteref&lt;/code&gt; remoteref选项。如果未配置 &lt;code&gt;@{push}&lt;/code&gt; 引用，则产生一个空字符串。</target>
        </trans-unit>
        <trans-unit id="25973fbcb02049e23787d52ffa23363b0665166c" translate="yes" xml:space="preserve">
          <source>The name of a new directory to clone into. The &quot;humanish&quot; part of the source repository is used if no directory is explicitly given (&lt;code&gt;repo&lt;/code&gt; for &lt;code&gt;/path/to/repo.git&lt;/code&gt; and &lt;code&gt;foo&lt;/code&gt; for &lt;code&gt;host.xz:foo/.git&lt;/code&gt;). Cloning into an existing directory is only allowed if the directory is empty.</source>
          <target state="translated">要克隆到的新目录的名称。使用源资源库的&amp;ldquo;humanish&amp;rdquo;部分，如果没有目录明确给出（ &lt;code&gt;repo&lt;/code&gt; 为 &lt;code&gt;/path/to/repo.git&lt;/code&gt; 和 &lt;code&gt;foo&lt;/code&gt; 为 &lt;code&gt;host.xz:foo/.git&lt;/code&gt; ）。仅当目录为空时才允许克隆到现有目录。</target>
        </trans-unit>
        <trans-unit id="3c836d4cc86fbcc3a897aa8fab973465c40a1899" translate="yes" xml:space="preserve">
          <source>The name of an existing branch already in fast-import&amp;rsquo;s internal branch table. If fast-import doesn&amp;rsquo;t know the name, it&amp;rsquo;s treated as a SHA-1 expression.</source>
          <target state="translated">快速导入的内部分支表中已存在的分支的名称。如果快速导入不知道名称，则将其视为SHA-1表达式。</target>
        </trans-unit>
        <trans-unit id="c21a579b2f8550495cd7f286a4f77b45b3df2f6e" translate="yes" xml:space="preserve">
          <source>The name of an existing branch to rename.</source>
          <target state="translated">要重命名的现有分支的名称。</target>
        </trans-unit>
        <trans-unit id="b35cfa9e6735c6918643ac8769ab4e5dd81020f0" translate="yes" xml:space="preserve">
          <source>The name of an external credential helper, and any associated options. If the helper name is not an absolute path, then the string &lt;code&gt;git
credential-&lt;/code&gt; is prepended. The resulting string is executed by the shell (so, for example, setting this to &lt;code&gt;foo --option=bar&lt;/code&gt; will execute &lt;code&gt;git credential-foo --option=bar&lt;/code&gt; via the shell. See the manual of specific helpers for examples of their use.</source>
          <target state="translated">外部凭据助手的名称以及任何关联的选项。如果助手名称不是绝对路径，那么将使用字符串 &lt;code&gt;git credential-&lt;/code&gt; 。结果字符串由外壳程序执行（例如，将其设置为 &lt;code&gt;foo --option=bar&lt;/code&gt; 将通过外壳程序执行 &lt;code&gt;git credential-foo --option=bar&lt;/code&gt; 。有关其用法的示例，请参阅特定帮助程序的手册。</target>
        </trans-unit>
        <trans-unit id="7efaaad02f8c0d5eaaddaa5b6f8a8113410c8ef1" translate="yes" xml:space="preserve">
          <source>The name of one of the following can be used instead of a URL as &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument:</source>
          <target state="translated">可以使用以下任一名称代替URL作为 &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="f54520854ea19fafb55997c9840c558f7f80fed9" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;replace&lt;/code&gt; reference is the SHA-1 of the object that is replaced. The content of the &lt;code&gt;replace&lt;/code&gt; reference is the SHA-1 of the replacement object.</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; 引用的名称是被替换对象的SHA-1。 &lt;code&gt;replace&lt;/code&gt; 引用的内容是替换对象的SHA-1。</target>
        </trans-unit>
        <trans-unit id="117daad0c937bbfd67b26eaa98382dde664a6203" translate="yes" xml:space="preserve">
          <source>The name of the branch to create or delete. The new branch name must pass all checks defined by &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format[1]&lt;/a&gt;. Some of these checks may restrict the characters allowed in a branch name.</source>
          <target state="translated">要创建或删除的分支的名称。新的分支名称必须通过&lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format [1]&lt;/a&gt;定义的所有检查。其中一些检查可能会限制分支名称中允许的字符。</target>
        </trans-unit>
        <trans-unit id="f40b450a4e1f94bf798289a960712dae0a6f632b" translate="yes" xml:space="preserve">
          <source>The name of the client can be given to &lt;code&gt;git p4&lt;/code&gt; in multiple ways. The variable &lt;code&gt;git-p4.client&lt;/code&gt; takes precedence if it exists. Otherwise, normal p4 mechanisms of determining the client are used: environment variable &lt;code&gt;P4CLIENT&lt;/code&gt;, a file referenced by &lt;code&gt;P4CONFIG&lt;/code&gt;, or the local host name.</source>
          <target state="translated">客户端的名称可以通过多种方式赋予 &lt;code&gt;git p4&lt;/code&gt; 。变量 &lt;code&gt;git-p4.client&lt;/code&gt; 优先（如果存在）。否则，将使用确定客户端的常规p4机制：环境变量 &lt;code&gt;P4CLIENT&lt;/code&gt; ， &lt;code&gt;P4CONFIG&lt;/code&gt; 引用的文件或本地主机名。</target>
        </trans-unit>
        <trans-unit id="d25f4900ca4ac26428c337fc8a49a0fffaa87baa" translate="yes" xml:space="preserve">
          <source>The name of the current branch is stored in .git/HEAD.</source>
          <target state="translated">当前分支的名称存储在.git/HEAD中。</target>
        </trans-unit>
        <trans-unit id="9192c74ec25457f29baaadaeb1d2b767ba20ddac" translate="yes" xml:space="preserve">
          <source>The name of the local ref being pushed, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix. In the case of deletion, the name of the local ref is omitted.</source>
          <target state="translated">推送的本地ref的名称减去其 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 前缀。在删除的情况下，将省略本地引用的名称。</target>
        </trans-unit>
        <trans-unit id="61c75d700127b0c70d569d247bca51622e343006" translate="yes" xml:space="preserve">
          <source>The name of the local ref being updated, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix.</source>
          <target state="translated">要更新的本地ref的名称减去其 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="40299b8374a45bc90296f421fddf5763cb8c6908" translate="yes" xml:space="preserve">
          <source>The name of the object to show. For a more complete list of ways to spell object names, see the &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">要显示的对象的名称。有关拼写对象名称的方法的完整列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]中&lt;/a&gt;的&amp;ldquo;指定版本&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="15cfdda92a704493f44c3f6bda85fdb4fe25cc87" translate="yes" xml:space="preserve">
          <source>The name of the ref (the part after $GIT_DIR/). For a non-ambiguous short name of the ref append &lt;code&gt;:short&lt;/code&gt;. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode. If &lt;code&gt;lstrip=&amp;lt;N&amp;gt;&lt;/code&gt; (&lt;code&gt;rstrip=&amp;lt;N&amp;gt;&lt;/code&gt;) is appended, strips &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; slash-separated path components from the front (back) of the refname (e.g. &lt;code&gt;%(refname:lstrip=2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;%(refname:rstrip=2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;refs&lt;/code&gt;). If &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; is a negative number, strip as many path components as necessary from the specified end to leave &lt;code&gt;-&amp;lt;N&amp;gt;&lt;/code&gt; path components (e.g. &lt;code&gt;%(refname:lstrip=-2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;tags/foo&lt;/code&gt; and &lt;code&gt;%(refname:rstrip=-1)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;refs&lt;/code&gt;). When the ref does not have enough components, the result becomes an empty string if stripping with positive &amp;lt;N&amp;gt;, or it becomes the full refname if stripping with negative &amp;lt;N&amp;gt;. Neither is an error.</source>
          <target state="translated">引用的名称（$ GIT_DIR /之后的部分）。对于ref的明确名称，请附加 &lt;code&gt;:short&lt;/code&gt; 。选项core.warnAmbiguousRefs用于选择严格缩写模式。如果 &lt;code&gt;lstrip=&amp;lt;N&amp;gt;&lt;/code&gt; （ &lt;code&gt;rstrip=&amp;lt;N&amp;gt;&lt;/code&gt; ），则从refname的前面（后面） &lt;code&gt;%(refname:lstrip=2)&lt;/code&gt; &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; 斜杠分隔的路径分量（例如，％（refname：lstrip = 2）变成 &lt;code&gt;refs/tags/foo&lt;/code&gt; 变成 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;%(refname:rstrip=2)&lt;/code&gt; 将 &lt;code&gt;refs/tags/foo&lt;/code&gt; 变成 &lt;code&gt;refs&lt;/code&gt; 。如果 &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; 为负数，则从指定的末端剥去尽可能多的路径分量，以保留 &lt;code&gt;-&amp;lt;N&amp;gt;&lt;/code&gt; 路径组件（例如， &lt;code&gt;%(refname:lstrip=-2)&lt;/code&gt; 将 &lt;code&gt;refs/tags/foo&lt;/code&gt; 转换为 &lt;code&gt;tags/foo&lt;/code&gt; ,而 &lt;code&gt;%(refname:rstrip=-1)&lt;/code&gt; 将 &lt;code&gt;refs/tags/foo&lt;/code&gt; 转换为 &lt;code&gt;refs&lt;/code&gt; ）。当ref的分量不足时，如果使用正号&amp;lt;N&amp;gt;进行剥离，结果将为空字符串；如果使用负号&amp;lt;N&amp;gt;进行剥离，则结果将为完整的refname。都不是错误。</target>
        </trans-unit>
        <trans-unit id="d3667dc69f3d60260150d30873ae903291e9c610" translate="yes" xml:space="preserve">
          <source>The name of the remote ref being fetched from, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix. In the case of deletion, the name of the remote ref is &quot;(none)&quot;.</source>
          <target state="translated">从中获取远程引用的名称，减去其 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 前缀。在删除的情况下，远程引用的名称为&amp;ldquo;（无）&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f1e1380262032f81dbdd04e4a724dd0dac2f66a0" translate="yes" xml:space="preserve">
          <source>The name of the remote ref being updated, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix.</source>
          <target state="translated">要更新的远程引用的名称，减去其 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="cf1208454bdf4c7c5a0ab602103e6dd838ca212a" translate="yes" xml:space="preserve">
          <source>The name of the repository in gitweb is the path to its &lt;code&gt;$GIT_DIR&lt;/code&gt; (its object database) relative to &lt;code&gt;$projectroot&lt;/code&gt;. Therefore the repository $repo can be found at &quot;$projectroot/$repo&quot;.</source>
          <target state="translated">gitweb中存储库的名称是其相对于 &lt;code&gt;$projectroot&lt;/code&gt; &lt;code&gt;$GIT_DIR&lt;/code&gt; （其对象数据库）的路径。因此，可以在&amp;ldquo; $ projectroot / $ repo&amp;rdquo;中找到存储库$ repo。</target>
        </trans-unit>
        <trans-unit id="1b6cc45302b6351d18e813818cde0845c0a5a22a" translate="yes" xml:space="preserve">
          <source>The name of the tag to create, delete, or describe. The new tag name must pass all checks defined by &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format[1]&lt;/a&gt;. Some of these checks may restrict the characters allowed in a tag name.</source>
          <target state="translated">要创建，删除或描述的标签的名称。新标签名称必须通过&lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format [1]&lt;/a&gt;定义的所有检查。其中一些检查可能会限制标签名称中允许的字符。</target>
        </trans-unit>
        <trans-unit id="964fd80a7ebc3b646125e059ac3c7f8c3a22061f" translate="yes" xml:space="preserve">
          <source>The named branches will be interpreted as if specified with the &lt;code&gt;-t&lt;/code&gt; option on the &lt;code&gt;git remote add&lt;/code&gt; command line.</source>
          <target state="translated">命名分支将被解释为与 &lt;code&gt;git remote add&lt;/code&gt; 命令行上的 &lt;code&gt;-t&lt;/code&gt; 选项指定的一样。</target>
        </trans-unit>
        <trans-unit id="a7226417649eb7c8f42ca4934a290033c08aad1c" translate="yes" xml:space="preserve">
          <source>The names of objects to show (defaults to &lt;code&gt;HEAD&lt;/code&gt;). For a more complete list of ways to spell object names, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">要显示的对象名称（默认为 &lt;code&gt;HEAD&lt;/code&gt; ）。有关拼写对象名称的方法的完整列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]中的&lt;/a&gt; &amp;ldquo;指定修订版&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="df439b2df93c9264d2652e8aa379f62f3b6ab5ac" translate="yes" xml:space="preserve">
          <source>The names of refs that are fetched, together with the object names they point at, are written to &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt;. This information may be used by scripts or other git commands, such as &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">获取的ref的名称以及它们指向的对象名称将写入 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 。脚本或其他git命令（例如&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]）&lt;/a&gt;可以使用此信息。</target>
        </trans-unit>
        <trans-unit id="1b9c4b549f992b26edb42d00411780a65661d81d" translate="yes" xml:space="preserve">
          <source>The native transport (i.e. git:// URL) does no authentication and should be used with caution on unsecured networks.</source>
          <target state="translated">本机传输(i.e.git://URL)不进行身份验证,在不安全的网络上应谨慎使用。</target>
        </trans-unit>
        <trans-unit id="86d32cda4c46d201605240981feec896fb3daceb" translate="yes" xml:space="preserve">
          <source>The new branch head will point to this commit. It may be given as a branch name, a commit-id, or a tag. If this option is omitted, the current HEAD will be used instead.</source>
          <target state="translated">新的分支头将指向这个提交。它可以是一个分支名,一个提交id,或者一个标签。如果省略了这个选项,则会使用当前的头。</target>
        </trans-unit>
        <trans-unit id="597e47a48a8bd8b3528838dd5cebedeb7b241f60" translate="yes" xml:space="preserve">
          <source>The new name for an existing branch. The same restrictions as for &amp;lt;branchname&amp;gt; apply.</source>
          <target state="translated">现有分支的新名称。适用与&amp;lt;分支名称&amp;gt;相同的限制。</target>
        </trans-unit>
        <trans-unit id="ade318097a09c67b5bdaa6c1344cf2a281d7cac8" translate="yes" xml:space="preserve">
          <source>The next parameter is the pattern. This option has to be used for patterns starting with &lt;code&gt;-&lt;/code&gt; and should be used in scripts passing user input to grep. Multiple patterns are combined by &lt;code&gt;or&lt;/code&gt;.</source>
          <target state="translated">下一个参数是模式。此选项必须用于以 &lt;code&gt;-&lt;/code&gt; 开头的模式，并且应在将用户输入传递给grep的脚本中使用。 &lt;code&gt;or&lt;/code&gt; 组合多个模式。</target>
        </trans-unit>
        <trans-unit id="00f28e3b882b5553d45ceeb08082d3dcda522dd0" translate="yes" xml:space="preserve">
          <source>The next step of merging is to merge these three versions of the file, using 3-way merge. This is done by giving &lt;code&gt;git merge-one-file&lt;/code&gt; command as one of the arguments to &lt;code&gt;git merge-index&lt;/code&gt; command:</source>
          <target state="translated">合并的下一步是使用3向合并来合并文件的这三个版本。这是通过给 &lt;code&gt;git merge-one-file&lt;/code&gt; 命令作为 &lt;code&gt;git merge-index&lt;/code&gt; 命令的参数之一来完成的：</target>
        </trans-unit>
        <trans-unit id="c203649e7405cacf1f66f3229b4d864ccf1b5f34" translate="yes" xml:space="preserve">
          <source>The nonce string the process asked the signer to include in the push certificate. If this does not match the value recorded on the &quot;nonce&quot; header in the push certificate, it may indicate that the certificate is a valid one that is being replayed from a separate &quot;git push&quot; session.</source>
          <target state="translated">进程要求签名者在推送证书中包含的 nonce 字符串。如果这个字符串与推送证书中的 &quot;nonce &quot;头记录的值不一致,则可能表明证书是一个有效的证书,正在从一个单独的 &quot;git push &quot;会话中重放。</target>
        </trans-unit>
        <trans-unit id="a81eae6f204563324e9f0299e6e5a18af11339c2" translate="yes" xml:space="preserve">
          <source>The normal format target is a tradition printf format and similar to GIT_TRACE format. This format is enabled with the &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variable or the &lt;code&gt;trace2.normalTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">普通格式的目标是传统的printf格式，与GIT_TRACE格式相似。此格式通过 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 环境变量或 &lt;code&gt;trace2.normalTarget&lt;/code&gt; 系统或全局配置设置启用。</target>
        </trans-unit>
        <trans-unit id="08867837836724d3f4c3cfbd7d03fa5d964eec62" translate="yes" xml:space="preserve">
          <source>The number of additional commits is the number of commits which would be displayed by &quot;git log v1.0.4..parent&quot;. The hash suffix is &quot;-g&quot; + unambiguous abbreviation for the tip commit of parent (which was &lt;code&gt;2414721b194453f058079d897d13c4e377f92dc6&lt;/code&gt;). The &quot;g&quot; prefix stands for &quot;git&quot; and is used to allow describing the version of a software depending on the SCM the software is managed with. This is useful in an environment where people may use different SCMs.</source>
          <target state="translated">附加提交数是&amp;ldquo; git log v1.0.4..parent&amp;rdquo;将显示的提交数。哈希后缀是&amp;ldquo; -g&amp;rdquo; +父代技巧提交的明确缩写（即 &lt;code&gt;2414721b194453f058079d897d13c4e377f92dc6&lt;/code&gt; ）。&amp;ldquo; g&amp;rdquo;前缀代表&amp;ldquo; git&amp;rdquo;，用于根据管理软件的SCM来描述软件的版本。这在人们可能使用不同SCM的环境中很有用。</target>
        </trans-unit>
        <trans-unit id="83386653d6009935020ea78a4c28a793cc5fa198" translate="yes" xml:space="preserve">
          <source>The number of curl sessions (counted across slots) to be kept across requests. They will not be ended with curl_easy_cleanup() until http_cleanup() is invoked. If USE_CURL_MULTI is not defined, this value will be capped at 1. Defaults to 1.</source>
          <target state="translated">在不同的请求中要保留的curl会话的数量(按槽数计算),在http_cleanup()被调用之前,这些会话不会被curl_easy_cleanup()结束。在调用 http_cleanup()之前,它们不会被 curl_easy_cleanup()结束。如果没有定义 USE_CURL_MULTI,这个值的上限是 1,默认为 1。</target>
        </trans-unit>
        <trans-unit id="eb593ed0188a165abaa2fc9b58825ac993fcfa11" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing rename detection during a merge; if not specified, defaults to the value of diff.renameLimit. This setting has no effect if rename detection is turned off.</source>
          <target state="translated">合并过程中执行重命名检测时要考虑的文件数量;如果没有指定,默认为 diff.renameLimit 的值。如果关闭了重命名检测,则此设置没有任何影响;如果没有指定,默认为diff.renameLimit的值。</target>
        </trans-unit>
        <trans-unit id="b49ca7e6ecad75b8cf0b0ec3dcf469e017a13140" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing rename detection in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;. Defaults to the value of diff.renameLimit.</source>
          <target state="translated">在&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;和&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]中&lt;/a&gt;执行重命名检测时要考虑的文件数。默认为diff.renameLimit的值。</target>
        </trans-unit>
        <trans-unit id="62caddb975571c60931b3e5e41910f9ec3dfea6e" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing the copy/rename detection; equivalent to the &lt;code&gt;git diff&lt;/code&gt; option &lt;code&gt;-l&lt;/code&gt;. This setting has no effect if rename detection is turned off.</source>
          <target state="translated">执行复制/重命名检测时要考虑的文件数；等效于 &lt;code&gt;git diff&lt;/code&gt; 选项 &lt;code&gt;-l&lt;/code&gt; 。如果关闭重命名检测，此设置无效。</target>
        </trans-unit>
        <trans-unit id="f40a726880d5eda55c8da498a0add02c8ea2a7b1" translate="yes" xml:space="preserve">
          <source>The number of push options given on the command line of &lt;code&gt;git push --push-option=...&lt;/code&gt; can be read from the environment variable &lt;code&gt;GIT_PUSH_OPTION_COUNT&lt;/code&gt;, and the options themselves are found in &lt;code&gt;GIT_PUSH_OPTION_0&lt;/code&gt;, &lt;code&gt;GIT_PUSH_OPTION_1&lt;/code&gt;,&amp;hellip;​ If it is negotiated to not use the push options phase, the environment variables will not be set. If the client selects to use push options, but doesn&amp;rsquo;t transmit any, the count variable will be set to zero, &lt;code&gt;GIT_PUSH_OPTION_COUNT=0&lt;/code&gt;.</source>
          <target state="translated">可以从环境变量 &lt;code&gt;GIT_PUSH_OPTION_COUNT&lt;/code&gt; 读取 &lt;code&gt;git push --push-option=...&lt;/code&gt; 命令行上给定的push选项数量，这些选项本身可以在 &lt;code&gt;GIT_PUSH_OPTION_0&lt;/code&gt; ， &lt;code&gt;GIT_PUSH_OPTION_1&lt;/code&gt; 中找到，...使用push选项阶段时，将不会设置环境变量。如果客户端选择使用推送选项，但不发送任何推送选项，则count变量将设置为零，即 &lt;code&gt;GIT_PUSH_OPTION_COUNT=0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5ad10bd3ab58adc794f2122271c46d58529bef4" translate="yes" xml:space="preserve">
          <source>The number of spaces between columns. One space by default.</source>
          <target state="translated">列间的空格数。默认为一个空格。</target>
        </trans-unit>
        <trans-unit id="911462b0802b22317c5a57a0a0510dbf0c397a66" translate="yes" xml:space="preserve">
          <source>The number of submodules fetched at the same time. Defaults to the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; option.</source>
          <target state="translated">同时获取的子模块数。默认为 &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="34de3b8749bfae0c14ff8d34783f05c9920748b5" translate="yes" xml:space="preserve">
          <source>The object can be a blob or a submodule commit. It implies the &lt;code&gt;-t&lt;/code&gt; option in &lt;code&gt;git-log&lt;/code&gt; to also find trees.</source>
          <target state="translated">该对象可以是Blob或子模块提交。这意味着 &lt;code&gt;git-log&lt;/code&gt; 中的 &lt;code&gt;-t&lt;/code&gt; 选项也可以找到树。</target>
        </trans-unit>
        <trans-unit id="2794f5933199b4937a09c41b8d049f6b88620c25" translate="yes" xml:space="preserve">
          <source>The object database contains objects of three main types: blobs, which hold file data; trees, which point to blobs and other trees to build up directory hierarchies; and commits, which each reference a single tree and some number of parent commits.</source>
          <target state="translated">对象数据库包含三种主要类型的对象:blobs,存放文件数据;tree,指向blobs和其他树,以建立目录层次结构;commits,每个commits引用一棵树和一些父commits。</target>
        </trans-unit>
        <trans-unit id="b5ea163b65a2243d9fc238d7c50700c517adc350" translate="yes" xml:space="preserve">
          <source>The object database is the rather elegant system used to store the history of your project&amp;mdash;​files, directories, and commits.</source>
          <target state="translated">对象数据库是一个非常优雅的系统，用于存储项目的历史记录-文件，目录和提交。</target>
        </trans-unit>
        <trans-unit id="db080c7937810b605e4381605a2e18077b89e3c0" translate="yes" xml:space="preserve">
          <source>The object name (aka SHA-1). For a non-ambiguous abbreviation of the object name append &lt;code&gt;:short&lt;/code&gt;. For an abbreviation of the object name with desired length append &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt;, where the minimum length is MINIMUM_ABBREV. The length may be exceeded to ensure unique object names.</source>
          <target state="translated">对象名称（又名SHA-1）。对于对象名称的明确缩写，请附加 &lt;code&gt;:short&lt;/code&gt; 。对于具有所需长度的对象名称的缩写，请附加 &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt; ，其中最小长度为MINIMUM_ABBREV。可以超过该长度以确保唯一的对象名称。</target>
        </trans-unit>
        <trans-unit id="b335d1a75376848bee9affb50a6203b316fcc02d" translate="yes" xml:space="preserve">
          <source>The object referenced by &amp;lt;src&amp;gt; is used to update the &amp;lt;dst&amp;gt; reference on the remote side. Whether this is allowed depends on where in &lt;code&gt;refs/*&lt;/code&gt; the &amp;lt;dst&amp;gt; reference lives as described in detail below, in those sections &quot;update&quot; means any modifications except deletes, which as noted after the next few sections are treated differently.</source>
          <target state="translated">&amp;lt;src&amp;gt;引用的对象用于更新远程端的&amp;lt;dst&amp;gt;引用。是否允许这样做取决于 &lt;code&gt;refs/*&lt;/code&gt; 中&amp;lt;dst&amp;gt;引用的位置，如以下详细所述，在那些部分中，&amp;ldquo;更新&amp;rdquo;表示除删除外的任何修改，这在接下来的几节中将作不同处理。</target>
        </trans-unit>
        <trans-unit id="afdbad7acf93ca3457880eb431fd58ab07141e11" translate="yes" xml:space="preserve">
          <source>The object table is actually a hashtable keyed on the object name (the unique SHA-1). This storage configuration allows fast-import to reuse an existing or already written object and avoid writing duplicates to the output packfile. Duplicate blobs are surprisingly common in an import, typically due to branch merges in the source.</source>
          <target state="translated">对象表实际上是一个以对象名称(唯一的SHA-1)为键的哈希特表。这种存储配置允许快速导入重用现有的或已经写好的对象,并避免将重复的对象写入输出包文件。重复的 blobs 在导入中是非常常见的,通常是由于源文件中的分支合并。</target>
        </trans-unit>
        <trans-unit id="0b16e9c4d73790474d293fcd4d96547c235d7d1f" translate="yes" xml:space="preserve">
          <source>The object that the new tag will refer to, usually a commit. Defaults to HEAD.</source>
          <target state="translated">新标签将引用的对象,通常是一个提交。默认为 HEAD。</target>
        </trans-unit>
        <trans-unit id="5468420c6f62137502c6bb00574138b237765047" translate="yes" xml:space="preserve">
          <source>The object type may be a blob, representing the contents of a file, or another tree, representing the contents of a subdirectory. Since trees and blobs, like all other objects, are named by the SHA-1 hash of their contents, two trees have the same SHA-1 name if and only if their contents (including, recursively, the contents of all subdirectories) are identical. This allows Git to quickly determine the differences between two related tree objects, since it can ignore any entries with identical object names.</source>
          <target state="translated">对象类型可以是代表文件内容的blob,也可以是代表子目录内容的树。因为树和blob和其他对象一样,都是用内容的SHA-1哈希值来命名的,所以只有当两个树的内容(包括递归的所有子目录的内容)相同时,它们的SHA-1名称才会相同。这使得Git可以快速确定两个相关树对象之间的差异,因为它可以忽略任何具有相同对象名的条目。</target>
        </trans-unit>
        <trans-unit id="abf9c48e6cb6157bcc4ecdd7fbfd1167ee2a4bc5" translate="yes" xml:space="preserve">
          <source>The object types in some more detail:</source>
          <target state="translated">对象类型更详细一些。</target>
        </trans-unit>
        <trans-unit id="1aa11fdf087f0d8d0d32eb67b923b0efa29ecf46" translate="yes" xml:space="preserve">
          <source>The objects are output in the order in which they are found in the index file, which should be (in a correctly constructed file) sorted by object id.</source>
          <target state="translated">对象是按照它们在索引文件中找到的顺序输出的,索引文件应该(在一个正确构造的文件中)按对象id排序。</target>
        </trans-unit>
        <trans-unit id="113c9617d3615ff46d1de3788621403d384bc970" translate="yes" xml:space="preserve">
          <source>The official repository of the &lt;code&gt;git gui&lt;/code&gt; project can be found at:</source>
          <target state="translated">&lt;code&gt;git gui&lt;/code&gt; 项目的官方存储库位于：</target>
        </trans-unit>
        <trans-unit id="d2925f4342d92a06228b4eeddfbffd0ada540f91" translate="yes" xml:space="preserve">
          <source>The one commit in this list that is not related to CMake may very well have been motivated by working on fixing all those bugs introduced by switching to CMake, but it addresses a different concern. To split this branch into two topic branches, the todo list could be edited like this:</source>
          <target state="translated">这个列表中与 CMake 无关的一个提交,很可能是为了修复切换到 CMake 后引入的所有错误,但它解决的是不同的问题。要把这个分支分成两个主题分支,可以这样编辑todo列表。</target>
        </trans-unit>
        <trans-unit id="680930999bd0e3bf9880124c135a89bca3a329f3" translate="yes" xml:space="preserve">
          <source>The oneline descriptions are purely for your pleasure; &lt;code&gt;git rebase&lt;/code&gt; will not look at them but at the commit names (&quot;deadbee&quot; and &quot;fa1afe1&quot; in this example), so do not delete or edit the names.</source>
          <target state="translated">单行描述纯粹是为了您的愉悦； &lt;code&gt;git rebase&lt;/code&gt; 不会查看它们，而是查看提交名称（在此示例中为&amp;ldquo; deadbee&amp;rdquo;和&amp;ldquo; fa1afe1&amp;rdquo;），因此请勿删除或编辑名称。</target>
        </trans-unit>
        <trans-unit id="b174b5f513a45da66bee660cec63368b38af2a1f" translate="yes" xml:space="preserve">
          <source>The only difference between this command and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; is that they use slightly different output formats, and this command exists only for backward compatibility to support existing scripts, and provide a more familiar command name for people coming from other SCM systems.</source>
          <target state="translated">此命令和&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;之间的唯一区别是，它们使用略有不同的输出格式，并且此命令仅存在用于向后兼容以支持现有脚本，并且为来自其他SCM系统的人提供了更熟悉的命令名称。</target>
        </trans-unit>
        <trans-unit id="90482aceb580582ec33d188b8fb1bca29f8136a1" translate="yes" xml:space="preserve">
          <source>The option can have the following values, defaulting to &lt;code&gt;group&lt;/code&gt; if no value is given:</source>
          <target state="translated">该选项可以具有以下值，如果没有给出值，则默认为 &lt;code&gt;group&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="72a352b7174eb63582b749d1295b267e0dae9887" translate="yes" xml:space="preserve">
          <source>The optional &amp;lt;limit&amp;gt; is useful in cases where your topic is based on other work that is not in upstream. Expanding on the previous example, this might look like:</source>
          <target state="translated">可选的&amp;lt;limit&amp;gt;在主题基于上游以外的其他工作的情况下很有用。在前面的示例上进行扩展，可能类似于：</target>
        </trans-unit>
        <trans-unit id="4136e1c0c625091f77db10ec0b76e55e39fdb1b6" translate="yes" xml:space="preserve">
          <source>The optional &amp;lt;style&amp;gt; argument can be either &lt;code&gt;shallow&lt;/code&gt; or &lt;code&gt;deep&lt;/code&gt;. &lt;code&gt;shallow&lt;/code&gt; threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the &lt;code&gt;--in-reply-to&lt;/code&gt;, and the first patch mail, in this order. &lt;code&gt;deep&lt;/code&gt; threading makes every mail a reply to the previous one.</source>
          <target state="translated">可选的&amp;lt;style&amp;gt;参数可以是 &lt;code&gt;shallow&lt;/code&gt; 或 &lt;code&gt;deep&lt;/code&gt; 。 &lt;code&gt;shallow&lt;/code&gt; 线程使每个邮件都回复到该系列的 &lt;code&gt;--in-reply-to&lt;/code&gt; ，该标题是从求职信，-in-reply-to和第一个补丁邮件中按此顺序选择的。 &lt;code&gt;deep&lt;/code&gt; 线程使每封邮件都回复上一封邮件。</target>
        </trans-unit>
        <trans-unit id="3dd98bdacd886ba292b303baaba2ecefebed8bab" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;encoding&lt;/code&gt; command indicates the encoding of the commit message. Most commits are UTF-8 and the encoding is omitted, but this allows importing commit messages into git without first reencoding them.</source>
          <target state="translated">可选的 &lt;code&gt;encoding&lt;/code&gt; 命令指示提交消息的编码。大多数提交都是UTF-8，并且省略了编码，但这允许将提交消息导入git，而无需先对其进行重新编码。</target>
        </trans-unit>
        <trans-unit id="b0ae75c1b10bf71d7e20ef9926e29585fa74a2e0" translate="yes" xml:space="preserve">
          <source>The optional argument &amp;lt;path&amp;gt; is the relative location for the cloned submodule to exist in the superproject. If &amp;lt;path&amp;gt; is not given, the canonical part of the source repository is used (&quot;repo&quot; for &quot;/path/to/repo.git&quot; and &quot;foo&quot; for &quot;host.xz:foo/.git&quot;). If &amp;lt;path&amp;gt; exists and is already a valid Git repository, then it is staged for commit without cloning. The &amp;lt;path&amp;gt; is also used as the submodule&amp;rsquo;s logical name in its configuration entries unless &lt;code&gt;--name&lt;/code&gt; is used to specify a logical name.</source>
          <target state="translated">可选参数&amp;lt;path&amp;gt;是在超级项目中存在的克隆子模块的相对位置。如果未给出&amp;lt;path&amp;gt;，则使用源存储库的规范部分（&amp;ldquo; repo&amp;rdquo;表示&amp;ldquo; /path/to/repo.git&amp;rdquo;，&amp;ldquo;foo&amp;rdquo;表示&amp;ldquo; host.xz：foo / .git&amp;rdquo;）。如果&amp;lt;path&amp;gt;存在并且已经是有效的Git存储库，则将其暂存以进行提交而无需克隆。 &amp;lt;path&amp;gt;在其配置条目中也用作子模块的逻辑名，除非 &lt;code&gt;--name&lt;/code&gt; 用于指定逻辑名。</target>
        </trans-unit>
        <trans-unit id="476c5c2c4870d6be72c4d31b42e1450136c51807" translate="yes" xml:space="preserve">
          <source>The optional configuration variable &lt;code&gt;core.excludesFile&lt;/code&gt; indicates a path to a file containing patterns of file names to exclude, similar to &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;. Patterns in the exclude file are used in addition to those in &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;.</source>
          <target state="translated">可选配置变量 &lt;code&gt;core.excludesFile&lt;/code&gt; 指示文件的路径，该路径包含要排除的文件名模式，类似于 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 。除了 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 模式以外，还使用排除文件中的模式。</target>
        </trans-unit>
        <trans-unit id="ad80c43bd988ae6e6061dfab8a056d2afaee7691" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;--contains&lt;/code&gt;, &lt;code&gt;--no-contains&lt;/code&gt;, &lt;code&gt;--merged&lt;/code&gt; and &lt;code&gt;--no-merged&lt;/code&gt; serve four related but different purposes:</source>
          <target state="translated">选项 &lt;code&gt;--contains&lt;/code&gt; ， &lt;code&gt;--no-contains&lt;/code&gt; ， &lt;code&gt;--merged&lt;/code&gt; 和 &lt;code&gt;--no-merged&lt;/code&gt; 成为四大关，但不同的目的：</target>
        </trans-unit>
        <trans-unit id="081a3bdc8213b4774c97cebf32978af69c3476cb" translate="yes" xml:space="preserve">
          <source>The order of stages 1, 2 and 3 (hence the order of three &amp;lt;tree-ish&amp;gt; command-line arguments) are significant when you start a 3-way merge with an index file that is already populated. Here is an outline of how the algorithm works:</source>
          <target state="translated">当您开始使用已填充的索引文件进行三向合并时，阶段1、2和3的顺序（因此三个&amp;lt;tree-ish&amp;gt;命令行参数的顺序）很重要。这是算法工作原理的概述：</target>
        </trans-unit>
        <trans-unit id="3fb57cf5101f783ba73fc6eba17ed42ef2940627" translate="yes" xml:space="preserve">
          <source>The order of the flags used to matter, but not anymore.</source>
          <target state="translated">过去旗帜的顺序很重要,但现在不一样了。</target>
        </trans-unit>
        <trans-unit id="32a54a6aa8ff67e3d76c47c6fabd2affc1e5cbb5" translate="yes" xml:space="preserve">
          <source>The origin of lines is automatically followed across whole-file renames (currently there is no option to turn the rename-following off). To follow lines moved from one file to another, or to follow lines that were copied and pasted from another file, etc., see the &lt;code&gt;-C&lt;/code&gt; and &lt;code&gt;-M&lt;/code&gt; options.</source>
          <target state="translated">整个文件重命名会自动跟随行的起点（当前没有选项可以关闭重命名跟随）。要跟随从一个文件移动到另一个文件的行，或者跟随从另一个文件复制和粘贴的行，等等，请参见 &lt;code&gt;-C&lt;/code&gt; 和 &lt;code&gt;-M&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="b66619a4ae8f145d6aac4431781b08d6ac86597a" translate="yes" xml:space="preserve">
          <source>The origin revision can be changed with the &quot;--origin&quot; option.</source>
          <target state="translated">可以用&quot;--origin &quot;选项来改变原始版本。</target>
        </trans-unit>
        <trans-unit id="617fe8d1d55cfe9ccc09f76fcfa190410b239da3" translate="yes" xml:space="preserve">
          <source>The original format used by Greg Kroah-Hartman&amp;rsquo;s &lt;code&gt;send_lots_of_email.pl&lt;/code&gt; script</source>
          <target state="translated">Greg Kroah-Hartman的 &lt;code&gt;send_lots_of_email.pl&lt;/code&gt; 脚本使用的原始格式</target>
        </trans-unit>
        <trans-unit id="a7a5cdcdcd4d6fcaaf02e53acebd8443c9b015da" translate="yes" xml:space="preserve">
          <source>The original job of &lt;code&gt;git rev-parse&lt;/code&gt; is now taken by the function &lt;code&gt;setup_revisions()&lt;/code&gt;, which parses the revisions and the common command-line options for the revision walker. This information is stored in the struct &lt;code&gt;rev_info&lt;/code&gt; for later consumption. You can do your own command-line option parsing after calling &lt;code&gt;setup_revisions()&lt;/code&gt;. After that, you have to call &lt;code&gt;prepare_revision_walk()&lt;/code&gt; for initialization, and then you can get the commits one by one with the function &lt;code&gt;get_revision()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git rev-parse&lt;/code&gt; 的原始工作现在由 &lt;code&gt;setup_revisions()&lt;/code&gt; 函数承担，该函数解析修订和修订行者的常用命令行选项。此信息存储在struct &lt;code&gt;rev_info&lt;/code&gt; 中,以供以后使用。您可以在调用 &lt;code&gt;setup_revisions()&lt;/code&gt; 之后执行自己的命令行选项解析。之后，您必须调用 &lt;code&gt;prepare_revision_walk()&lt;/code&gt; 进行初始化，然后可以使用 &lt;code&gt;get_revision()&lt;/code&gt; 函数一个接一个地提交提交。</target>
        </trans-unit>
        <trans-unit id="4c9da327e28b59015cec84abd98a33aec635328d" translate="yes" xml:space="preserve">
          <source>The original tags are not deleted, but can be overwritten; use &quot;--tag-name-filter cat&quot; to simply update the tags. In this case, be very careful and make sure you have the old tags backed up in case the conversion has run afoul.</source>
          <target state="translated">原来的标签不会被删除,但可以被覆盖;使用&quot;--tag-name-filter cat &quot;来简单地更新标签。在这种情况下,要非常小心,并确保你有旧的标签备份,以防转换过程中出现问题。</target>
        </trans-unit>
        <trans-unit id="6c2cf73d4477ea65ac2368f08dedbcc07c9eafb4" translate="yes" xml:space="preserve">
          <source>The other nice thing with test suites, is that when you have one, you already know how to test for bad behavior. So you can use this knowledge to create a new test case for &quot;git bisect&quot; when it appears that there is a regression. So it will be easier to bisect the bug and fix it. And then you can add the test case you just created to your test suite.</source>
          <target state="translated">测试套件的另一个好处是,当你有一个测试套件时,你已经知道如何测试不良行为。因此,当出现回归时,你可以使用这些知识为 &quot;git bisect &quot;创建一个新的测试用例。这样就可以更容易地将bug一分为二,并修复它。然后你就可以把刚才创建的测试用例添加到你的测试套件中。</target>
        </trans-unit>
        <trans-unit id="94bda500b4b5c47f0218909469e6ab7f1eee52b6" translate="yes" xml:space="preserve">
          <source>The other way to drive the bisection process is to tell &quot;git bisect&quot; to launch a script or command at each bisection step to know if the current commit is &quot;good&quot; or &quot;bad&quot;. To do that, we use the &quot;git bisect run&quot; command. For example:</source>
          <target state="translated">另一种方法是让 &quot;git bisect &quot;在每一个分离步骤中启动一个脚本或命令,以了解当前的提交是 &quot;好 &quot;还是 &quot;坏&quot;。为此,我们使用 &quot;git bisect run &quot;命令。例如:&quot;git bisect run &quot;命令</target>
        </trans-unit>
        <trans-unit id="013b9f528101f55f667633859403afae697697c4" translate="yes" xml:space="preserve">
          <source>The output format is modified to be machine-parsable (see below). If &lt;code&gt;--stdin&lt;/code&gt; is also given, input paths are separated with a NUL character instead of a linefeed character.</source>
          <target state="translated">将输出格式修改为机器可解析的（请参见下文）。如果还给出了 &lt;code&gt;--stdin&lt;/code&gt; ，则输入路径用NUL字符而不是换行符分隔。</target>
        </trans-unit>
        <trans-unit id="4ebdc78d172a0b82e38a898aa2ae716344def4d5" translate="yes" xml:space="preserve">
          <source>The output format is modified to be machine-parsable. If &lt;code&gt;--stdin&lt;/code&gt; is also given, input paths are separated with a NUL character instead of a linefeed character.</source>
          <target state="translated">将输出格式修改为机器可解析的。如果还给出了 &lt;code&gt;--stdin&lt;/code&gt; ，则输入路径用NUL字符而不是换行符分隔。</target>
        </trans-unit>
        <trans-unit id="885a3d9b027501a3f7ddd2554d827f984cacfcf5" translate="yes" xml:space="preserve">
          <source>The output format is similar to the Porcelain format, but it does not contain the actual lines from the file that is being annotated.</source>
          <target state="translated">输出格式与Porcelain格式类似,但它不包含被注释的文件的实际行数。</target>
        </trans-unit>
        <trans-unit id="16ca2e6d144e9c4d47f91cfe57ded6c4b6f874af" translate="yes" xml:space="preserve">
          <source>The output from this command is designed to be used as a commit template comment. The default, long format, is designed to be human readable, verbose and descriptive. Its contents and format are subject to change at any time.</source>
          <target state="translated">该命令的输出是用来作为提交模板的注释。默认的长格式是为了让人能够读懂,并具有详细的描述性。其内容和格式可能会随时改变。</target>
        </trans-unit>
        <trans-unit id="467b04ab4f0f42e5eb4db50995625d7a06a04bbc" translate="yes" xml:space="preserve">
          <source>The output is in the format: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;reference name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">输出的格式为： &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;reference name&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="297e105083265b9b5df9c784faa30006468bc5fd" translate="yes" xml:space="preserve">
          <source>The output is of the form: &amp;lt;path&amp;gt; COLON SP &amp;lt;attribute&amp;gt; COLON SP &amp;lt;info&amp;gt; LF</source>
          <target state="translated">输出的形式为：&amp;lt;path&amp;gt; COLON SP &amp;lt;attribute&amp;gt; COLON SP &amp;lt;info&amp;gt; LF</target>
        </trans-unit>
        <trans-unit id="00d47eecfb8e7c432b9a2a4461da0aa0b0a14445" translate="yes" xml:space="preserve">
          <source>The output is the new tag&amp;rsquo;s &amp;lt;object&amp;gt; identifier.</source>
          <target state="translated">输出是新标签的&amp;lt;object&amp;gt;标识符。</target>
        </trans-unit>
        <trans-unit id="c209f5f99a30592095be06f60778bfc6143218e8" translate="yes" xml:space="preserve">
          <source>The output of &quot;git fetch&quot; depends on the transport method used; this section describes the output when fetching over the Git protocol (either locally or via ssh) and Smart HTTP protocol.</source>
          <target state="translated">&quot;git fetch &quot;的输出取决于所使用的传输方式,本节将介绍通过Git协议(本地或通过ssh)和智能HTTP协议进行获取时的输出。</target>
        </trans-unit>
        <trans-unit id="249df455a76d6d8a4ee813f24ba8c68836888f67" translate="yes" xml:space="preserve">
          <source>The output of &quot;git push&quot; depends on the transport method used; this section describes the output when pushing over the Git protocol (either locally or via ssh).</source>
          <target state="translated">git push &quot;的输出取决于所使用的传输方式,本节将介绍通过 Git 协议(本地或通过 ssh)推送时的输出。</target>
        </trans-unit>
        <trans-unit id="2012a50a7ce95c41c81b087cc42352c50e07741b" translate="yes" xml:space="preserve">
          <source>The output of ls-refs is as follows:</source>
          <target state="translated">ls-refs的输出如下。</target>
        </trans-unit>
        <trans-unit id="c9897264787fe814346af61567793268dae2ec95" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;range-diff&lt;/code&gt; command is subject to change. It is intended to be human-readable porcelain output, not something that can be used across versions of Git to get a textually stable &lt;code&gt;range-diff&lt;/code&gt; (as opposed to something like the &lt;code&gt;--stable&lt;/code&gt; option to &lt;a href=&quot;git-patch-id&quot;&gt;git-patch-id[1]&lt;/a&gt;). There&amp;rsquo;s also no equivalent of &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt; for &lt;code&gt;range-diff&lt;/code&gt;, the output is not intended to be machine-readable.</source>
          <target state="translated">&lt;code&gt;range-diff&lt;/code&gt; 命令的输出可能会发生变化。它打算用作人类可读的瓷器输出，而不是可以在Git的各个版本中使用的东西，以获得文本上稳定的 &lt;code&gt;range-diff&lt;/code&gt; （与&lt;a href=&quot;git-patch-id&quot;&gt;git-patch-id [1]&lt;/a&gt;的 &lt;code&gt;--stable&lt;/code&gt; 选项类似的东西相反） 。还有没有等价的&lt;a href=&quot;git-apply&quot;&gt;GIT-应用[1]&lt;/a&gt;用于 &lt;code&gt;range-diff&lt;/code&gt; ，输出不旨在是机器可读的。</target>
        </trans-unit>
        <trans-unit id="acccdb81223db3ebfe60a727e12d9a4ed87719fe" translate="yes" xml:space="preserve">
          <source>The output order is determined by the order of glob patterns in &amp;lt;orderfile&amp;gt;. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.</source>
          <target state="translated">输出顺序由&amp;lt;orderfile&amp;gt;中的glob模式的顺序确定。路径名与第一个模式匹配的所有文件都将首先输出，路径名与第二个模式（但不是第一个模式）相匹配的所有文件都将被输出，依此类推。路径名与任何模式都不匹配的所有文件最后输出，就好像文件末尾有一个隐式的全部匹配模式。如果多个路径名具有相同的等级（它们匹配相同的模式，但没有更早的模式），则它们相对于彼此的输出顺序是正常顺序。</target>
        </trans-unit>
        <trans-unit id="70ec2e58d64c53608a589a3f892a41e430e23c0e" translate="yes" xml:space="preserve">
          <source>The overall time needed to compute this algorithm is the time needed to compute n+m commit diffs and then n*m diffs of patches, plus the time needed to compute the least-cost assignment between n and m diffs. Git uses an implementation of the Jonker-Volgenant algorithm to solve the assignment problem, which has cubic runtime complexity. The matching found in this case will look like this:</source>
          <target state="translated">计算这个算法所需的总体时间是计算n+m个commit diffs,然后计算n*m个patch diffs所需的时间,再加上计算n和m个 diffs之间的最小成本分配所需的时间。Git使用Jonker-Volgenant算法的实现来解决分配问题,该算法的运行复杂度为立方。在这种情况下找到的匹配会是这样的。</target>
        </trans-unit>
        <trans-unit id="f8c05a901b25f6434301621f82a267dcb0caae54" translate="yes" xml:space="preserve">
          <source>The p4 changes will be created as the user invoking &lt;code&gt;git p4 submit&lt;/code&gt;. The &lt;code&gt;--preserve-user&lt;/code&gt; option will cause ownership to be modified according to the author of the Git commit. This option requires admin privileges in p4, which can be granted using &lt;code&gt;p4 protect&lt;/code&gt;.</source>
          <target state="translated">用户调用 &lt;code&gt;git p4 submit&lt;/code&gt; 将创建p4更改。该 &lt;code&gt;--preserve-user&lt;/code&gt; 选项会使根据混帐的作者提交的所有权进行修改。此选项需要p4中的管理员特权，可以使用 &lt;code&gt;p4 protect&lt;/code&gt; 授予该特权。</target>
        </trans-unit>
        <trans-unit id="bc53387773cbb38b899a330a03a788e5288eab48" translate="yes" xml:space="preserve">
          <source>The p4 client specification is maintained with the &lt;code&gt;p4 client&lt;/code&gt; command and contains among other fields, a View that specifies how the depot is mapped into the client repository. The &lt;code&gt;clone&lt;/code&gt; and &lt;code&gt;sync&lt;/code&gt; commands can consult the client spec when given the &lt;code&gt;--use-client-spec&lt;/code&gt; option or when the useClientSpec variable is true. After &lt;code&gt;git p4 clone&lt;/code&gt;, the useClientSpec variable is automatically set in the repository configuration file. This allows future &lt;code&gt;git p4 submit&lt;/code&gt; commands to work properly; the submit command looks only at the variable and does not have a command-line option.</source>
          <target state="translated">p4客户端规范由 &lt;code&gt;p4 client&lt;/code&gt; 命令维护，除其他字段外，还包含一个视图，该视图指定软件仓库如何映射到客户端存储库中。该 &lt;code&gt;clone&lt;/code&gt; 并 &lt;code&gt;sync&lt;/code&gt; 给出的命令时，可以咨询客户规范 &lt;code&gt;--use-client-spec&lt;/code&gt; 选项，或当useClientSpec变量为真。之后 &lt;code&gt;git p4 clone&lt;/code&gt; ，将useClientSpec变量自动存储库配置文件中设置。这使得将来的 &lt;code&gt;git p4 submit&lt;/code&gt; 命令可以正常工作； Submit命令仅查看变量，并且没有命令行选项。</target>
        </trans-unit>
        <trans-unit id="9fec68b06723905b09b9270262e6a13c1b490876" translate="yes" xml:space="preserve">
          <source>The p4 depot path argument to &lt;code&gt;git p4 sync&lt;/code&gt; and &lt;code&gt;git p4 clone&lt;/code&gt; can be one or more space-separated p4 depot paths, with an optional p4 revision specifier on the end:</source>
          <target state="translated">&lt;code&gt;git p4 sync&lt;/code&gt; 和 &lt;code&gt;git p4 clone&lt;/code&gt; 的p4 depot path参数可以是一个或多个以空格分隔的p4 depot路径，最后带有一个可选的p4版本说明符：</target>
        </trans-unit>
        <trans-unit id="d877dea1de89fdb5a15efd47a5debfe5403b96f4" translate="yes" xml:space="preserve">
          <source>The pack-indexes (.idx files) remain in the pack directory so we can delete the MIDX file, set core.midx to false, or downgrade without any loss of information.</source>
          <target state="translated">pack-indexes(.idx文件)仍然保留在pack目录下,所以我们可以删除MIDX文件,将core.midx设置为false,或者降级而不丢失任何信息。</target>
        </trans-unit>
        <trans-unit id="933f30be1e83e4fe09dc8528b693f5b5a75f065d" translate="yes" xml:space="preserve">
          <source>The packed archive format (.pack) is designed to be self-contained so that it can be unpacked without any further information. Therefore, each object that a delta depends upon must be present within the pack.</source>
          <target state="translated">包装档案格式(.pack)的设计是自成一体的,因此它可以在没有任何进一步信息的情况下被解压。因此,delta所依赖的每个对象都必须存在于pack中。</target>
        </trans-unit>
        <trans-unit id="75cd7427877d4a48fded775aaaba114771e37304" translate="yes" xml:space="preserve">
          <source>The packfile(s) created by fast-import do not encourage good disk access patterns. This is caused by fast-import writing the data in the order it is received on standard input, while Git typically organizes data within packfiles to make the most recent (current tip) data appear before historical data. Git also clusters commits together, speeding up revision traversal through better cache locality.</source>
          <target state="translated">由 fast-import 创建的 packfile 并不支持良好的磁盘访问模式,这是因为 fast-import 按照标准输入的顺序写入数据,而 Git 通常会在 packfile 中组织数据,使最新的(当前的提示)数据出现在历史数据之前。这是由于fast-import按照标准输入的顺序写入数据,而Git通常会在packfiles中组织数据,使最新的(当前的提示)数据出现在历史数据之前。Git还将提交的数据聚拢在一起,通过更好的缓存位置性来加快修订版的遍历速度。</target>
        </trans-unit>
        <trans-unit id="73715b9a828b5f7ca9623cd366d376d487c8e126" translate="yes" xml:space="preserve">
          <source>The partial clone feature records special &quot;promisor&quot; packs that may point to objects that are not stored locally, but available on request to a server. The multi-pack-index does not currently track these promisor packs.</source>
          <target state="translated">部分克隆功能记录了特殊的 &quot;promposor &quot;包,这些包可能指向没有存储在本地的对象,但可以根据请求向服务器提供。多包索引目前不跟踪这些承诺者包。</target>
        </trans-unit>
        <trans-unit id="608e992a19f0287b5b2e4cbdc92416d882bd253c" translate="yes" xml:space="preserve">
          <source>The password to use when logging in to the server.</source>
          <target state="translated">登录服务器时使用的密码。</target>
        </trans-unit>
        <trans-unit id="f899bc9ba76fee3c960f01f1f955c5a4bf020e98" translate="yes" xml:space="preserve">
          <source>The patch extracted from e-mail.</source>
          <target state="translated">从电子邮件中提取的补丁。</target>
        </trans-unit>
        <trans-unit id="621265bbad5d0651c63283720f8a5ccddfdeeb61" translate="yes" xml:space="preserve">
          <source>The patch is expected to be inline, directly following the message. Any line that is of the form:</source>
          <target state="translated">补丁应该是内联的,直接跟在消息后面。任何形式的行:</target>
        </trans-unit>
        <trans-unit id="eedf9ed2547b7a76bcd6fb69785bf954af8d224f" translate="yes" xml:space="preserve">
          <source>The patch itself does not apply cleanly. That is &lt;code&gt;bad&lt;/code&gt; but does not have much to do with your MUA. You might want to rebase the patch with &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; before regenerating it in this case.</source>
          <target state="translated">补丁本身不能完全应用。这是 &lt;code&gt;bad&lt;/code&gt; ，但没有太多与你的MUA做。在这种情况下，您可能想在重新生成修补程序之前使用&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]将其&lt;/a&gt;重新着色。</target>
        </trans-unit>
        <trans-unit id="c9ecbf09d9172bac5285d567a6e1031058a01024" translate="yes" xml:space="preserve">
          <source>The patch produced by &lt;code&gt;git format-patch&lt;/code&gt; is in UNIX mailbox format, with a fixed &quot;magic&quot; time stamp to indicate that the file is output from format-patch rather than a real mailbox, like so:</source>
          <target state="translated">&lt;code&gt;git format-patch&lt;/code&gt; patch产生的补丁是UNIX邮箱格式，带有固定的&amp;ldquo;魔术&amp;rdquo;时间戳，指示该文件是从format-patch而不是真实邮箱输出的，如下所示：</target>
        </trans-unit>
        <trans-unit id="7072603eb0a607d061c366f3e4a9cba6cffbd377" translate="yes" xml:space="preserve">
          <source>The path can be either absolute or relative. A relative path is taken as relative to the directory where the hooks are run (see the &quot;DESCRIPTION&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">路径可以是绝对路径，也可以是相对路径。相对路径是相对于运行钩子的目录而言的（请参阅&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;的&amp;ldquo; DESCRIPTION&amp;rdquo;部分）。</target>
        </trans-unit>
        <trans-unit id="6ccace0f35f0f4e5cab0e8cffbdf924135579b2e" translate="yes" xml:space="preserve">
          <source>The path has the attribute with special value &quot;false&quot;; this is specified by listing the name of the attribute prefixed with a dash &lt;code&gt;-&lt;/code&gt; in the attribute list.</source>
          <target state="translated">路径具有带有特殊值&amp;ldquo; false&amp;rdquo;的属性；这是通过列出与一个破折号前缀属性的名称指定 &lt;code&gt;-&lt;/code&gt; 属性列表英寸</target>
        </trans-unit>
        <trans-unit id="96cc920a42ed7b296307f756480841c1366430ee" translate="yes" xml:space="preserve">
          <source>The path has the attribute with special value &quot;true&quot;; this is specified by listing only the name of the attribute in the attribute list.</source>
          <target state="translated">路径中有特殊值为 &quot;true &quot;的属性;这是由属性列表中只列出属性名称来指定的。</target>
        </trans-unit>
        <trans-unit id="f3d259c7dde8e69cba5e131da2dcac58054c5102" translate="yes" xml:space="preserve">
          <source>The path has the attribute with specified string value; this is specified by listing the name of the attribute followed by an equal sign &lt;code&gt;=&lt;/code&gt; and its value in the attribute list.</source>
          <target state="translated">路径具有具有指定字符串值的属性；通过列出属性名称，后跟等号 &lt;code&gt;=&lt;/code&gt; 及其在属性列表中的值来指定。</target>
        </trans-unit>
        <trans-unit id="9a89a340b481b20bfabef5b1bcb5482c1e173e57" translate="yes" xml:space="preserve">
          <source>The path to a list of object names (i.e. one unabbreviated SHA-1 per line) that are known to be broken in a non-fatal way and should be ignored. On versions of Git 2.20 and later comments (&lt;code&gt;#&lt;/code&gt;), empty lines, and any leading and trailing whitespace is ignored. Everything but a SHA-1 per line will error out on older versions.</source>
          <target state="translated">已知以非致命方式中断的对象名称列表（即，每行一个未缩写的SHA-1）的路径，应将其忽略。在Git 2.20和更高版本的注释（ &lt;code&gt;#&lt;/code&gt; ）版本中，空行以及任何前导和尾随空格都将被忽略。每行除SHA-1以外的所有内容在旧版本中都会出错。</target>
        </trans-unit>
        <trans-unit id="66bacdcfb6546645ce51a1173beecea036fe198b" translate="yes" xml:space="preserve">
          <source>The path to higher software quality is significantly improved software testing.</source>
          <target state="translated">提高软件质量的途径是大大改善软件测试。</target>
        </trans-unit>
        <trans-unit id="a62f8e77f19dbb91947274f4224d3b2000deceef" translate="yes" xml:space="preserve">
          <source>The path with which the credential will be used. E.g., for accessing a remote https repository, this will be the repository&amp;rsquo;s path on the server.</source>
          <target state="translated">凭据将使用的路径。例如，对于访问远程https资源库，这将是服务器上资源库的路径。</target>
        </trans-unit>
        <trans-unit id="75a6542b84624c1ec2a2753cb02bac2dc12deb38" translate="yes" xml:space="preserve">
          <source>The path within the &amp;lt;repository&amp;gt; that the action is performed on, for those actions that require it.</source>
          <target state="translated">&amp;lt;repository&amp;gt;中要对其执行操作的路径，用于需要执行该操作的路径。</target>
        </trans-unit>
        <trans-unit id="42c5355b2496aa717e00373f3c96e2614e271309" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing previously stored cookie lines, which should be used in the Git http session, if they match the server. The file format of the file to read cookies from should be plain HTTP headers or the Netscape/Mozilla cookie file format (see &lt;code&gt;curl(1)&lt;/code&gt;). NOTE that the file specified with http.cookieFile is used only as input unless http.saveCookies is set.</source>
          <target state="translated">包含先前存储的cookie行的文件的路径名，如果它们与服务器匹配，则应在Git http会话中使用。从中读取cookie的文件格式应为纯HTTP标头或Netscape / Mozilla cookie文件格式（请参见 &lt;code&gt;curl(1)&lt;/code&gt; ）。注意，除非设置了http.saveCookies，否则用http.cookieFile指定的文件仅用作输入。</target>
        </trans-unit>
        <trans-unit id="cdb891f79fbec881d22446bf8cf74ef0a3e451e0" translate="yes" xml:space="preserve">
          <source>The paths mentioned in the output, unlike many other Git commands, are made relative to the current directory if you are working in a subdirectory (this is on purpose, to help cutting and pasting). See the status.relativePaths config option below.</source>
          <target state="translated">与其他许多Git命令不同的是,如果你是在子目录下工作,输出中提到的路径是相对于当前目录的(这是故意的,有助于剪切和粘贴)。参见下面的 status.relativePaths 配置选项。</target>
        </trans-unit>
        <trans-unit id="ae851010ea42ad696931dec57e7a58d6d0655b81" translate="yes" xml:space="preserve">
          <source>The pathspecs are used to limit the world diff operates in. They remove the filepairs outside the specified sets of pathnames. E.g. If the input set of filepairs included:</source>
          <target state="translated">pathspecs用于限制diff操作的范围。它们会删除指定路径名集之外的文件对。例如,如果输入的文件对集包括。</target>
        </trans-unit>
        <trans-unit id="a35fe6e03b5cf8e686f61a60362e87d3cf937722" translate="yes" xml:space="preserve">
          <source>The pattern &quot;foo/*&quot;, matches &quot;foo/test.json&quot; (a regular file), &quot;foo/bar&quot; (a directory), but it does not match &quot;foo/bar/hello.c&quot; (a regular file), as the asterisk in the pattern does not match &quot;bar/hello.c&quot; which has a slash in it.</source>
          <target state="translated">模式 &quot;foo/*&quot;,匹配 &quot;foo/test.json&quot;(常规文件)、&quot;foo/bar&quot;(目录),但不匹配 &quot;foo/bar/hello.c&quot;(常规文件),因为模式中的星号与 &quot;bar/hello.c &quot;不匹配,后者有斜线。</target>
        </trans-unit>
        <trans-unit id="472a6ff8d8e6e0153adf76e5ad83f89df7215b9f" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;doc/frotz&lt;/code&gt; and &lt;code&gt;/doc/frotz&lt;/code&gt; have the same effect in any &lt;code&gt;.gitignore&lt;/code&gt; file. In other words, a leading slash is not relevant if there is already a middle slash in the pattern.</source>
          <target state="translated">模式 &lt;code&gt;doc/frotz&lt;/code&gt; 和 &lt;code&gt;/doc/frotz&lt;/code&gt; 在任何 &lt;code&gt;.gitignore&lt;/code&gt; 文件中具有相同的效果。换句话说，如果模式中已经存在中间斜线，则前导斜线不相关。</target>
        </trans-unit>
        <trans-unit id="7f3e3da749b8fed6cc11585c7aa5dbe77eee53ad" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;foo/&lt;/code&gt; will match a directory &lt;code&gt;foo&lt;/code&gt; and paths underneath it, but will not match a regular file or a symbolic link &lt;code&gt;foo&lt;/code&gt; (this is consistent with the way how pathspec works in general in Git)</source>
          <target state="translated">模式 &lt;code&gt;foo/&lt;/code&gt; 将匹配目录 &lt;code&gt;foo&lt;/code&gt; 及其下的路径，但不匹配常规文件或符号链接 &lt;code&gt;foo&lt;/code&gt; （这与pathspec在Git中的一般工作方式一致）</target>
        </trans-unit>
        <trans-unit id="32166ee916b00891724c1bd52223b5e1e2d10da0" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;hello.*&lt;/code&gt; matches any file or folder whose name begins with &lt;code&gt;hello&lt;/code&gt;. If one wants to restrict this only to the directory and not in its subdirectories, one can prepend the pattern with a slash, i.e. &lt;code&gt;/hello.*&lt;/code&gt;; the pattern now matches &lt;code&gt;hello.txt&lt;/code&gt;, &lt;code&gt;hello.c&lt;/code&gt; but not &lt;code&gt;a/hello.java&lt;/code&gt;.</source>
          <target state="translated">模式 &lt;code&gt;hello.*&lt;/code&gt; 匹配名称以 &lt;code&gt;hello&lt;/code&gt; 开头的任何文件或文件夹。如果只想将此限制于目录而不是其子目录，则可以在模式前面加上斜杠，即 &lt;code&gt;/hello.*&lt;/code&gt; ；该模式现在匹配 &lt;code&gt;hello.txt&lt;/code&gt; ， &lt;code&gt;hello.c&lt;/code&gt; ,但不匹配 &lt;code&gt;a/hello.java&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b35cb663783a3682a66157f3dc9fd508efdfceba" translate="yes" xml:space="preserve">
          <source>The pattern can contain standard globbing wildcards and two additional ones, &lt;code&gt;**/&lt;/code&gt; and &lt;code&gt;/**&lt;/code&gt;, that can match multiple path components. Please refer to &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for details. For convenience:</source>
          <target state="translated">该模式可以包含标准的通配符和两个附加的通配符 &lt;code&gt;**/&lt;/code&gt; 和 &lt;code&gt;/**&lt;/code&gt; ，它们可以匹配多个路径分量。有关详细信息，请参考&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;。为了方便：</target>
        </trans-unit>
        <trans-unit id="ae88d32c3f9079756948f2fdc8ae4c4c2e834b93" translate="yes" xml:space="preserve">
          <source>The patterns given should not begin with &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, or &lt;code&gt;refs/remotes&lt;/code&gt; when applied to &lt;code&gt;--branches&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt;, or &lt;code&gt;--remotes&lt;/code&gt;, respectively, and they must begin with &lt;code&gt;refs/&lt;/code&gt; when applied to &lt;code&gt;--glob&lt;/code&gt; or &lt;code&gt;--all&lt;/code&gt;. If a trailing &lt;code&gt;/*&lt;/code&gt; is intended, it must be given explicitly.</source>
          <target state="translated">给予不应该开始图案 &lt;code&gt;refs/heads&lt;/code&gt; ， &lt;code&gt;refs/tags&lt;/code&gt; ，或 &lt;code&gt;refs/remotes&lt;/code&gt; 当应用于 &lt;code&gt;--branches&lt;/code&gt; ， &lt;code&gt;--tags&lt;/code&gt; ，或 &lt;code&gt;--remotes&lt;/code&gt; ，分别与他们必须以 &lt;code&gt;refs/&lt;/code&gt; 当应用于 &lt;code&gt;--glob&lt;/code&gt; 或 &lt;code&gt;--all&lt;/code&gt; 。如果要使用结尾的 &lt;code&gt;/*&lt;/code&gt; ，则必须明确给出。</target>
        </trans-unit>
        <trans-unit id="86b0de7f6b1176e8c07c5aaa523447c3abd4915b" translate="yes" xml:space="preserve">
          <source>The performance format target (PERF) is a column-based format to replace GIT_TRACE_PERFORMANCE and is suitable for development and testing, possibly to complement tools like gprof. This format is enabled with the &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; environment variable or the &lt;code&gt;trace2.perfTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">性能格式目标（PERF）是一种基于列的格式，用于替代GIT_TRACE_PERFORMANCE，适用于开发和测试，可能会补充gprof等工具。使用 &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; 环境变量或 &lt;code&gt;trace2.perfTarget&lt;/code&gt; 系统或全局配置设置启用此格式。</target>
        </trans-unit>
        <trans-unit id="506071bbd9d0908b14e8f015ca1b0ff23e4ec21e" translate="yes" xml:space="preserve">
          <source>The performance of git-filter-branch is glacially slow; its design makes it impossible for a backward-compatible implementation to ever be fast:</source>
          <target state="translated">git-filter-branch的性能非常慢,它的设计使得一个向后兼容的实现不可能快。</target>
        </trans-unit>
        <trans-unit id="d698b970e30734158c98cc5647b57a259a47bb36" translate="yes" xml:space="preserve">
          <source>The person who put a piece of code into Git.</source>
          <target state="translated">将一段代码放入Git的人。</target>
        </trans-unit>
        <trans-unit id="81b84527afb0ae2e697e75bbd7638af25fa12741" translate="yes" xml:space="preserve">
          <source>The pickaxe search is described in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; (the description of &lt;code&gt;-S&amp;lt;string&amp;gt;&lt;/code&gt; option, which refers to pickaxe entry in &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt; for more details).</source>
          <target state="translated">镐搜索在&lt;a href=&quot;git-log&quot;&gt;git-log [1]中进行&lt;/a&gt;了描述（ &lt;code&gt;-S&amp;lt;string&amp;gt;&lt;/code&gt; 选项的描述，有关更多细节，请&lt;a href=&quot;gitdiffcore&quot;&gt;参见gitdiffcore [7]中的&lt;/a&gt;镐输入）。</target>
        </trans-unit>
        <trans-unit id="525e6a0e6ee3d9fa31ab39c46532aa0c693111e1" translate="yes" xml:space="preserve">
          <source>The placeholders are:</source>
          <target state="translated">占位机是。</target>
        </trans-unit>
        <trans-unit id="1651136b42ed906ec527c0b5bb6ead2e015774c3" translate="yes" xml:space="preserve">
          <source>The point of this helper is to reduce the number of times you must type your username or password. For example:</source>
          <target state="translated">这个助手的目的是减少你必须输入用户名或密码的次数。例如</target>
        </trans-unit>
        <trans-unit id="c89cea9d29e269d3d21a2bb103d39e43b1e539d2" translate="yes" xml:space="preserve">
          <source>The porcelain format</source>
          <target state="translated">瓷器格式</target>
        </trans-unit>
        <trans-unit id="26e08a1995b67cc0010521ba6bed170106483645" translate="yes" xml:space="preserve">
          <source>The porcelain format generally suppresses commit information that has already been seen. For example, two lines that are blamed to the same commit will both be shown, but the details for that commit will be shown only once. This is more efficient, but may require more state be kept by the reader. The &lt;code&gt;--line-porcelain&lt;/code&gt; option can be used to output full commit information for each line, allowing simpler (but less efficient) usage like:</source>
          <target state="translated">瓷器格式通常会抑制已经看到的提交信息。例如，将显示归咎于同一提交的两行，但是该提交的详细信息将仅显示一次。这是更有效的方法，但可能要求阅读器保留更多状态。所述 &lt;code&gt;--line-porcelain&lt;/code&gt; 选项可用于以输出完整的提交信息的每一行，从而允许更简单的像（但效率较低）的用法：</target>
        </trans-unit>
        <trans-unit id="20c54b7279b5d1b2be6928d44083be1fd00dfbb8" translate="yes" xml:space="preserve">
          <source>The porcelain format has a line per attribute. Attributes are listed with a label and value separated by a single space. Boolean attributes (like &lt;code&gt;bare&lt;/code&gt; and &lt;code&gt;detached&lt;/code&gt;) are listed as a label only, and are only present if and only if the value is true. The first attribute of a worktree is always &lt;code&gt;worktree&lt;/code&gt;, an empty line indicates the end of the record. For example:</source>
          <target state="translated">瓷器格式每个属性都有一行。属性用标签和值列出，并用单个空格分隔。布尔属性（如 &lt;code&gt;bare&lt;/code&gt; 和 &lt;code&gt;detached&lt;/code&gt; ）仅作为标签列出，并且仅当且仅当该值为true时才存在。工作树的第一个属性始终是 &lt;code&gt;worktree&lt;/code&gt; ，空行表示记录的结尾。例如：</target>
        </trans-unit>
        <trans-unit id="a362940b066b853917862099c8e9ab263cba72b1" translate="yes" xml:space="preserve">
          <source>The port number to bind the gitweb httpd to. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">绑定gitweb httpd的端口号。参见&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cecf31c324042fa16f4839249194885b3982bae" translate="yes" xml:space="preserve">
          <source>The port number to bind the httpd to. (Default: 1234)</source>
          <target state="translated">绑定 httpd 的端口号。(默认值:1234)</target>
        </trans-unit>
        <trans-unit id="735bfd35b5b101e4c116696c3cd1ebf6bc58faa9" translate="yes" xml:space="preserve">
          <source>The possible options are:</source>
          <target state="translated">可能的选择是:</target>
        </trans-unit>
        <trans-unit id="8bc0e360ec6eefb74bc5a1aed65f13e846b6d915" translate="yes" xml:space="preserve">
          <source>The preferred strategy for rolling out a version bump (whether whole repository or for a single file) is to teach git to read the new format, and allow writing the new format with a config switch or command line option (for experimentation or for those who do not care about backwards compatibility with older gits). Then after a long period to allow the reading capability to become common, we may switch to writing the new format by default.</source>
          <target state="translated">推广版本升级(无论是整个版本库还是单个文件)的首选策略是教会git读取新的格式,并允许通过配置开关或命令行选项来写入新的格式(用于实验或那些不在乎与旧gits向后兼容的人)。然后经过很长一段时间,让读取能力变得普遍,我们可以默认切换到写入新格式。</target>
        </trans-unit>
        <trans-unit id="adf8f6f66c16d1ab5dcd5c39342b75931e439ba4" translate="yes" xml:space="preserve">
          <source>The prefix ability basically makes it trivial to use &lt;code&gt;git checkout-index&lt;/code&gt; as an &quot;export as tree&quot; function. Just read the desired tree into the index, and do:</source>
          <target state="translated">前缀功能基本上使将 &lt;code&gt;git checkout-index&lt;/code&gt; 用作&amp;ldquo;导出为树&amp;rdquo;功能变得微不足道。只需将所需的树读入索引，然后执行：</target>
        </trans-unit>
        <trans-unit id="0f1fc4f35ab6b79f4468bd7525c0542dc9193da5" translate="yes" xml:space="preserve">
          <source>The previously introduced &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; is just a wrapper for &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">先前介绍的&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;只是&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;的包装。</target>
        </trans-unit>
        <trans-unit id="675ae216ecd575fef2e1ffa9eadeda52bdab6e90" translate="yes" xml:space="preserve">
          <source>The primary problem with rewriting the history of a branch has to do with merging. Suppose somebody fetches your branch and merges it into their branch, with a result something like this:</source>
          <target state="translated">重写分支历史的主要问题是与合并有关。假设有人获取了你的分支并将其合并到他们的分支中,结果是这样的。</target>
        </trans-unit>
        <trans-unit id="ff3dc4a94f1f540e3dd725f6eef6c2d405d85a87" translate="yes" xml:space="preserve">
          <source>The primary tool we&amp;rsquo;ve been using to create commits is &lt;code&gt;git-commit
-a&lt;/code&gt;, which creates a commit including every change you&amp;rsquo;ve made to your working tree. But what if you want to commit changes only to certain files? Or only certain changes to certain files?</source>
          <target state="translated">我们用来创建提交的主要工具是 &lt;code&gt;git-commit -a&lt;/code&gt; ，它创建一个提交，其中包括您对工作树所做的所有更改。但是，如果您只想对某些文件提交更改怎么办？还是仅对某些文件进行某些更改？</target>
        </trans-unit>
        <trans-unit id="bc32172ebad82b3a8531284b76fc91d0e2655fc8" translate="yes" xml:space="preserve">
          <source>The protection it offers over &lt;code&gt;--force&lt;/code&gt; is ensuring that subsequent changes your work wasn&amp;rsquo;t based on aren&amp;rsquo;t clobbered, but this is trivially defeated if some background process is updating refs in the background. We don&amp;rsquo;t have anything except the remote tracking info to go by as a heuristic for refs you&amp;rsquo;re expected to have seen &amp;amp; are willing to clobber.</source>
          <target state="translated">它提供的 &lt;code&gt;--force&lt;/code&gt; 保护可以确保您的工作所基于的后续更改不会被破坏，但是如果某些后台进程在后台更新引用，这将是微不足道的。除了远程跟踪信息以外，我们没有其他任何东西，可以启发您希望看到的参考文献，并愿意为之烦恼。</target>
        </trans-unit>
        <trans-unit id="c8ef7004934ae749808b9e22322b2c11275f98e4" translate="yes" xml:space="preserve">
          <source>The protocol names currently used by git are:</source>
          <target state="translated">目前git使用的协议名称为:。</target>
        </trans-unit>
        <trans-unit id="19913c2c5a680884fd5ab271ea84dfe92e10bf53" translate="yes" xml:space="preserve">
          <source>The protocol over which the credential will be used (e.g., &lt;code&gt;https&lt;/code&gt;).</source>
          <target state="translated">将使用凭证的协议（例如 &lt;code&gt;https&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="27c53e4d1c63b3496c93b1976851fe0522937712" translate="yes" xml:space="preserve">
          <source>The provided options must not contain a NUL or LF character.</source>
          <target state="translated">提供的选项不能包含NUL或LF字符。</target>
        </trans-unit>
        <trans-unit id="5fb1f43ddd5fc4b8ac18d086f82e6f88c9ed5855" translate="yes" xml:space="preserve">
          <source>The purpose of gitignore files is to ensure that certain files not tracked by Git remain untracked.</source>
          <target state="translated">gitignore文件的目的是确保某些没有被Git跟踪的文件不被跟踪。</target>
        </trans-unit>
        <trans-unit id="a2b9675d20ab3c1e80e15b296d660914f6ea2131" translate="yes" xml:space="preserve">
          <source>The purpose of the hook is to edit the message file in place, and it is not suppressed by the &lt;code&gt;--no-verify&lt;/code&gt; option. A non-zero exit means a failure of the hook and aborts the commit. It should not be used as replacement for pre-commit hook.</source>
          <target state="translated">挂钩的目的是就地编辑消息文件，并且 &lt;code&gt;--no-verify&lt;/code&gt; 选项不会抑制该挂钩。非零退出意味着挂钩失败并中止提交。不应将其用作预提交挂钩的替代品。</target>
        </trans-unit>
        <trans-unit id="383a661ab7ffdec395082f1f22f245f53263885b" translate="yes" xml:space="preserve">
          <source>The push URL of a remote repository. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">远程存储库的推送URL。参见&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8cd29a2b80ae7f4721c7a9c69324052af609357" translate="yes" xml:space="preserve">
          <source>The push done by the other person updated the branch that used to point at commit X to point at commit A. It is a fast-forward.</source>
          <target state="translated">对方所做的推送,将原来指向提交X的分支更新为指向提交A的分支,这是一个快进。</target>
        </trans-unit>
        <trans-unit id="79a20eedac198c71849aef6d1fe1606ea1ee319f" translate="yes" xml:space="preserve">
          <source>The quilt series file.</source>
          <target state="translated">被子系列文件。</target>
        </trans-unit>
        <trans-unit id="eb2f9ed5ec284eab8396a9b582f3da5582d364ca" translate="yes" xml:space="preserve">
          <source>The raw output format from &quot;git-diff-index&quot;, &quot;git-diff-tree&quot;, &quot;git-diff-files&quot; and &quot;git diff --raw&quot; are very similar.</source>
          <target state="translated">git-diff-index&quot;、&quot;git-diff-tree&quot;、&quot;git-diff-files &quot;和 &quot;git diff --raw &quot;的原始输出格式非常相似。</target>
        </trans-unit>
        <trans-unit id="a6ab1028c44c2d54846a9217b4a7ad959d178f38" translate="yes" xml:space="preserve">
          <source>The reachability bitmap is currently paired directly with a single packfile, using the pack-order as the object order to hopefully compress the bitmaps well using run-length encoding. This could be extended to pair a reachability bitmap with a multi-pack-index. If the multi-pack-index is extended to store a &quot;stable object order&quot; (a function Order(hash) = integer that is constant for a given hash, even as the multi-pack-index is updated) then a reachability bitmap could point to a multi-pack-index and be updated independently.</source>
          <target state="translated">目前,可到达性位图直接与单个packfile配对,使用pack-order作为对象顺序,希望能使用运行长度编码很好地压缩位图。这可以扩展到将可到达性位图与多包索引配对。如果 multi-pack-index 被扩展为存储一个 &quot;稳定的对象顺序&quot;(一个函数 Order(hash)=整数,对于一个给定的哈希来说,即使在 multi-pack-index 被更新时也是不变的),那么一个可到达性位图可以指向一个 multi-pack-index 并被独立更新。</target>
        </trans-unit>
        <trans-unit id="0aca04dff2f76e52dde4dcdd1542bfe4e1470100" translate="yes" xml:space="preserve">
          <source>The reason fast-import uses &lt;code&gt;:&lt;/code&gt; to denote a mark reference is this character is not legal in a Git branch name. The leading &lt;code&gt;:&lt;/code&gt; makes it easy to distinguish between the mark 42 (&lt;code&gt;:42&lt;/code&gt;) and the branch 42 (&lt;code&gt;42&lt;/code&gt; or &lt;code&gt;refs/heads/42&lt;/code&gt;), or an abbreviated SHA-1 which happened to consist only of base-10 digits.</source>
          <target state="translated">快速导入使用 &lt;code&gt;:&lt;/code&gt; 表示标记参考的原因是该字符在Git分支名称中不合法。前导 &lt;code&gt;:&lt;/code&gt; 可以轻松地区分标记42（ &lt;code&gt;:42&lt;/code&gt; ）和分支42（ &lt;code&gt;42&lt;/code&gt; 或 &lt;code&gt;refs/heads/42&lt;/code&gt; ），或正好仅由10位数字组成的SHA-1缩写。</target>
        </trans-unit>
        <trans-unit id="1aba410e8fcfe74102eea2fcf73898889acee3ed" translate="yes" xml:space="preserve">
          <source>The reason it doesn&amp;rsquo;t error out when provided without &lt;code&gt;--prune&lt;/code&gt; or its config versions is for flexibility of the configured versions, and to maintain a 1=1 mapping between what the command line flags do, and what the configuration versions do.</source>
          <target state="translated">当不提供 &lt;code&gt;--prune&lt;/code&gt; 或其配置版本时，它不会出错的原因是为了确保配置版本的灵活性，并在命令行标志和配置版本之间保持1 = 1的映射。</target>
        </trans-unit>
        <trans-unit id="b2defd752d90b2a93e28eb3efe0e516f3fc264fc" translate="yes" xml:space="preserve">
          <source>The rebase will stop where &lt;code&gt;pick&lt;/code&gt; has been replaced with &lt;code&gt;edit&lt;/code&gt; or when a step in the list fails to mechanically resolve conflicts and needs your help. When you are done editing and/or resolving conflicts you can continue with &lt;code&gt;git rebase --continue&lt;/code&gt;. If you decide that things are getting too hairy, you can always bail out with &lt;code&gt;git rebase
--abort&lt;/code&gt;. Even after the rebase is complete, you can still recover the original branch by using the &lt;a href=&quot;#reflogs&quot;&gt;reflog&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;pick&lt;/code&gt; 被替换为 &lt;code&gt;edit&lt;/code&gt; 或者列表中的某个步骤无法机械解决冲突并需要您的帮助，则rebase将停止。完成编辑和/或解决冲突后，可以继续使用 &lt;code&gt;git rebase --continue&lt;/code&gt; 。如果您认为事情变得太 &lt;code&gt;git rebase --abort&lt;/code&gt; ，可以随时使用git rebase --abort来纾困。即使完成了基准调整，您仍然可以使用&lt;a href=&quot;#reflogs&quot;&gt;reflog&lt;/a&gt;恢复原始分支。</target>
        </trans-unit>
        <trans-unit id="939cf091c711a461fc7775d9278b48a4457f30c1" translate="yes" xml:space="preserve">
          <source>The ref namespace is hierarchical. Different subhierarchies are used for different purposes (e.g. the &lt;code&gt;refs/heads/&lt;/code&gt; hierarchy is used to represent local branches).</source>
          <target state="translated">ref名称空间是分层的。不同的子层次结构用于不同的目的（例如， &lt;code&gt;refs/heads/&lt;/code&gt; 层次结构用于表示本地分支）。</target>
        </trans-unit>
        <trans-unit id="d11d2f57237e560f1ae2f7da112ae694568b2d78" translate="yes" xml:space="preserve">
          <source>The ref which the given symbolic ref refers to. If not a symbolic ref, nothing is printed. Respects the &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt; and &lt;code&gt;:rstrip&lt;/code&gt; options in the same way as &lt;code&gt;refname&lt;/code&gt; above.</source>
          <target state="translated">给定符号ref所引用的ref。如果不是符号引用，则不会打印任何内容。与上面的 &lt;code&gt;refname&lt;/code&gt; 一样，尊重 &lt;code&gt;:short&lt;/code&gt; ， &lt;code&gt;:lstrip&lt;/code&gt; 和 &lt;code&gt;:rstrip&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="09256802b46aa557905f47df9fc0a1148d341199" translate="yes" xml:space="preserve">
          <source>The reflogs are kept by default for 30 days, after which they may be pruned. See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; and &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; to learn how to control this pruning, and see the &quot;SPECIFYING REVISIONS&quot; section of &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details.</source>
          <target state="translated">默认情况下，reflog会保留30天，之后可能会被删除。请参阅&lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt;和&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;以了解如何控制此修剪，并请参阅&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]的&lt;/a&gt; &amp;ldquo; SPECIFYING REVISIONS&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="29e87ce112fa8f38582e71025c0e3c162626939f" translate="yes" xml:space="preserve">
          <source>The refname parameter is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 arguments are the object names for the refname before and after the update. Note that the hook is called before the refname is updated, so either sha1-old is 0{40} (meaning there is no such ref yet), or it should match what is recorded in refname.</source>
          <target state="translated">refname参数是相对于$GIT_DIR的,例如,对于主头来说,是 &quot;refs/heads/master&quot;。两个 sha1 参数是 refname 更新前和更新后的对象名。请注意,钩子是在 refname 更新之前调用的,所以 sha1-old 是 0{40}。(意思是还没有这样的ref),或者它应该与refname中记录的内容一致。</target>
        </trans-unit>
        <trans-unit id="21810fe3549bedbdcfb85519d93701f4c1ec8042" translate="yes" xml:space="preserve">
          <source>The refname value is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 values before each refname are the object names for the refname before and after the update. Refs that were created will have sha1-old equal to 0{40}, while refs that were deleted will have sha1-new equal to 0{40}, otherwise sha1-old and sha1-new should be valid objects in the repository.</source>
          <target state="translated">refname 的值是相对于 $GIT_DIR 的,例如,对于主头来说,就是 &quot;refs/heads/master&quot;。每个 refname 前面的两个 sha1 值是更新前和更新后 refname 的对象名。被创建的 refs 的 sha1-old 值等于 0{40},而被删除的 refs 的 sha1-new 值等于 0{40},否则 sha1-old 和 sha1-new 应该是版本库中的有效对象。</target>
        </trans-unit>
        <trans-unit id="f7cd6bb7198b77eda24e90f3bdabb1a4fb56aeb0" translate="yes" xml:space="preserve">
          <source>The refname value is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 values before each refname are the object names for the refname before and after the update. Refs to be created will have sha1-old equal to 0{40}, while refs to be deleted will have sha1-new equal to 0{40}, otherwise sha1-old and sha1-new should be valid objects in the repository.</source>
          <target state="translated">refname 的值是相对于 $GIT_DIR 的,例如,对于主头来说,就是 &quot;refs/heads/master&quot;。每个 refname 前面的两个 sha1 值是更新前和更新后 refname 的对象名。要创建的 refs 的 sha1-old 值等于 0{40},而要删除的 refs 的 sha1-new 值等于 0{40},否则 sha1-old 和 sha1-new 应该是版本库中的有效对象。</target>
        </trans-unit>
        <trans-unit id="ce26e3499eea5a4c24942a8e072b3a9539557d0b" translate="yes" xml:space="preserve">
          <source>The regex can also be set via a diff driver or configuration option, see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; or &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.</source>
          <target state="translated">还可以通过diff驱动程序或配置选项来设置正则表达式，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;或&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。明确给出该参数将覆盖所有差异驱动程序或配置设置。差异驱动程序将覆盖配置设置。</target>
        </trans-unit>
        <trans-unit id="db9cbae31eee7dd0453a2f75d2431a49c7ce5a43" translate="yes" xml:space="preserve">
          <source>The regex must capture the source branch name in $1.</source>
          <target state="translated">regex必须捕获1美元中的源分支名称。</target>
        </trans-unit>
        <trans-unit id="2f22e3781909efae9d373f9fa46942441b8a264c" translate="yes" xml:space="preserve">
          <source>The regular expression that the diff driver should use to recognize the hunk header. A built-in pattern may also be used. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff驱动程序应用于识别块头的正则表达式。也可以使用内置模式。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4211f7342bdc098f581fc9d7939f84dc24cd9689" translate="yes" xml:space="preserve">
          <source>The regular expression that the diff driver should use to split words in a line. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff驱动程序应使用正则表达式在一行中拆分单词。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f0619f2eb83a7faf485cba23bd4bbef8fb0cb4dd" translate="yes" xml:space="preserve">
          <source>The remainder of the line, after stripping the spaces, is used as the help associated to the option.</source>
          <target state="translated">去掉空格后,这一行的剩余部分被用作与选项相关的帮助。</target>
        </trans-unit>
        <trans-unit id="19c5350e9da63f63a8abbccc7168a03dfd13ebac" translate="yes" xml:space="preserve">
          <source>The remaining features cannot be overridden on a per project basis.</source>
          <target state="translated">其余的功能不能按项目进行覆盖。</target>
        </trans-unit>
        <trans-unit id="303228bfc99fc67a561e0782dc3e0ceb08c259bb" translate="yes" xml:space="preserve">
          <source>The remote branch name for a submodule, used by &lt;code&gt;git submodule
update --remote&lt;/code&gt;. Set this option to override the value found in the &lt;code&gt;.gitmodules&lt;/code&gt; file. See &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">子模块的远程分支名称，由 &lt;code&gt;git submodule update --remote&lt;/code&gt; 。设置此选项可覆盖 &lt;code&gt;.gitmodules&lt;/code&gt; 文件中的值。有关详细信息，请参见&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt;和&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fdf928f1cd746e7574e5e26895f63052b9e3300" translate="yes" xml:space="preserve">
          <source>The remote configuration is achieved using the &lt;code&gt;remote.origin.url&lt;/code&gt; and &lt;code&gt;remote.origin.fetch&lt;/code&gt; configuration variables. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">使用 &lt;code&gt;remote.origin.url&lt;/code&gt; 和 &lt;code&gt;remote.origin.fetch&lt;/code&gt; 配置变量可以实现远程配置。（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e7b65b070cfabceee72964f903404025034f8258" translate="yes" xml:space="preserve">
          <source>The remote end did not report the successful update of the ref, perhaps because of a temporary error on the remote side, a break in the network connection, or other transient error.</source>
          <target state="translated">远程端没有报出ref的成功更新,可能是远程端临时出错,网络连接中断,或者其他短暂的错误。</target>
        </trans-unit>
        <trans-unit id="53c927a78ca0c11dc61a2c100f0e02c446d49374" translate="yes" xml:space="preserve">
          <source>The remote end refused the update. Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; (for pushes to the checked out branch), &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; (for forced non-fast-forward updates), &lt;code&gt;receive.denyDeletes&lt;/code&gt; or &lt;code&gt;receive.denyDeleteCurrent&lt;/code&gt;. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">远端拒绝更新。通常是由远程侧的钩子引起的，或者是由于远程存储库具有以下有效的安全选项之一： &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; （用于推送到签出的分支）， &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; （用于强制的非快进更新） ）， &lt;code&gt;receive.denyDeletes&lt;/code&gt; 或 &lt;code&gt;receive.denyDeleteCurrent&lt;/code&gt; 。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9422d899b3eadda77c8387091e37d96facb6c2f" translate="yes" xml:space="preserve">
          <source>The remote heads to update from. This is relative to $GIT_DIR (e.g. &quot;HEAD&quot;, &quot;refs/heads/master&quot;). When unspecified, update from all heads the remote side has.</source>
          <target state="translated">要更新的远程头。这是相对于 $GIT_DIR 的 (例如 &quot;HEAD&quot;,&quot;refs/heads/master&quot;)。当未指定时,从远程的所有头更新。</target>
        </trans-unit>
        <trans-unit id="0419c5b470511fe246bdc207ab1f44978b5929c7" translate="yes" xml:space="preserve">
          <source>The remote hostname for a network credential.</source>
          <target state="translated">网络凭证的远程主机名。</target>
        </trans-unit>
        <trans-unit id="a7632b9807699f7e6cd146f3dd66e0428b068933" translate="yes" xml:space="preserve">
          <source>The remote ref that matches &amp;lt;src&amp;gt; is fetched, and if &amp;lt;dst&amp;gt; is not an empty string, an attempt is made to update the local ref that matches it.</source>
          <target state="translated">获取与&amp;lt;src&amp;gt;匹配的远程引用，并且如果&amp;lt;dst&amp;gt;不是空字符串，则尝试更新与之匹配的本地ref。</target>
        </trans-unit>
        <trans-unit id="282ef7eedc5a5bdee9740e04ed8375ea205f3da3" translate="yes" xml:space="preserve">
          <source>The remote refs to update.</source>
          <target state="translated">要更新的远程参照物。</target>
        </trans-unit>
        <trans-unit id="1126548b6dd0a73d0e4b3cf8a47f765ced5296ec" translate="yes" xml:space="preserve">
          <source>The remote to push to by default. Overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for all branches, and is overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; for specific branches.</source>
          <target state="translated">默认情况下要推送到的遥控器。重写 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 对所有分支，并且通过重写 &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; 特定分支。</target>
        </trans-unit>
        <trans-unit id="69cc315a656a6408b19c28c1250214347094ab33" translate="yes" xml:space="preserve">
          <source>The replaced object and the replacement object must be of the same type. This restriction can be bypassed using &lt;code&gt;-f&lt;/code&gt;.</source>
          <target state="translated">替换的对象和替换的对象必须具有相同的类型。可以使用 &lt;code&gt;-f&lt;/code&gt; 绕过此限制。</target>
        </trans-unit>
        <trans-unit id="1ad56792b1c232c0733d7ad92a2a6edfcbfd7d1e" translate="yes" xml:space="preserve">
          <source>The report does not tell you anything about lines which have been deleted or replaced; you need to use a tool such as &lt;code&gt;git diff&lt;/code&gt; or the &quot;pickaxe&quot; interface briefly mentioned in the following paragraph.</source>
          <target state="translated">该报告不会告诉您有关已删除或替换的行的任何信息；您需要使用下一节中简要提到的 &lt;code&gt;git diff&lt;/code&gt; 之类的工具或&amp;ldquo; pickaxe&amp;rdquo;界面。</target>
        </trans-unit>
        <trans-unit id="2c986c29f6ffa22f2a8c706bbb75b7aeb4461294" translate="yes" xml:space="preserve">
          <source>The repository URL to be pulled from.</source>
          <target state="translated">要拉取的版本库URL。</target>
        </trans-unit>
        <trans-unit id="944d2d5ccd37faa608b4a3dce165543a5adf2fbf" translate="yes" xml:space="preserve">
          <source>The repository the action will be performed on.</source>
          <target state="translated">要执行操作的存储库。</target>
        </trans-unit>
        <trans-unit id="0e7c4601cfd7634812fd5318d08d4f529fb59bef" translate="yes" xml:space="preserve">
          <source>The repository to get a tar archive from.</source>
          <target state="translated">从仓库中获取焦油文件的仓库。</target>
        </trans-unit>
        <trans-unit id="bc81f7623489d466e462d3597d8dc6ebd3c462a1" translate="yes" xml:space="preserve">
          <source>The repository to sync from.</source>
          <target state="translated">要同步的存储库。</target>
        </trans-unit>
        <trans-unit id="3d7b45c15d44961366710f29c0592cfbaf8293a2" translate="yes" xml:space="preserve">
          <source>The repository to sync into.</source>
          <target state="translated">要同步到的存储库。</target>
        </trans-unit>
        <trans-unit id="85a32286326310d42bba4488de0fbceb84f9845b" translate="yes" xml:space="preserve">
          <source>The repository to update.</source>
          <target state="translated">要更新的存储库。</target>
        </trans-unit>
        <trans-unit id="15ea4cb9c0b7ca59bf54604e4e274c258d2ab5d8" translate="yes" xml:space="preserve">
          <source>The response of &lt;code&gt;fetch&lt;/code&gt; is broken into a number of sections separated by delimiter packets (0001), with each section beginning with its section header.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 的响应分为多个由定界符数据包（0001）分隔的部分，每个部分均以其部分头开始。</target>
        </trans-unit>
        <trans-unit id="4f1a001f6b3f7c16917c0e0241e976b8717f870a" translate="yes" xml:space="preserve">
          <source>The rest of the documentation discusses &lt;code&gt;fsck.*&lt;/code&gt; for brevity, but the same applies for the corresponding &lt;code&gt;receive.fsck.*&lt;/code&gt; and &lt;code&gt;fetch.&amp;lt;msg-id&amp;gt;.*&lt;/code&gt;. variables.</source>
          <target state="translated">为了简洁起见，文档的其余部分讨论了 &lt;code&gt;fsck.*&lt;/code&gt; ，但是对于相应的 &lt;code&gt;receive.fsck.*&lt;/code&gt; 和 &lt;code&gt;fetch.&amp;lt;msg-id&amp;gt;.*&lt;/code&gt; 。变量。</target>
        </trans-unit>
        <trans-unit id="ac10b74ced74e00c661f52e9250a42f47fd6add4" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;git merge-base --octopus A B C&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, because &lt;code&gt;2&lt;/code&gt; is the best common ancestor of all commits.</source>
          <target state="translated">结果 &lt;code&gt;git merge-base --octopus A B C&lt;/code&gt; 是 &lt;code&gt;2&lt;/code&gt; ，因为 &lt;code&gt;2&lt;/code&gt; 是所有提交的最好的共同祖先。</target>
        </trans-unit>
        <trans-unit id="1e8fa948e18ddfaa21178042cd566eaada7aae80" translate="yes" xml:space="preserve">
          <source>The result of comparison is passed from these commands to what is internally called &quot;diffcore&quot;, in a format similar to what is output when the -p option is not used. E.g.</source>
          <target state="translated">比较的结果由这些命令传递到内部的 &quot;diffcore&quot;,格式类似于不使用-p选项时的输出。例如</target>
        </trans-unit>
        <trans-unit id="d6478eddd3e6be6e1f0703d8450a597d1ea3dfe6" translate="yes" xml:space="preserve">
          <source>The result of such a bisection would be that we would find that H is the first bad commit, when in fact it&amp;rsquo;s B. So that would be wrong!</source>
          <target state="translated">这样一分为二的结果是，我们会发现H是第一个错误提交，而实际上是B。所以这是错误的！</target>
        </trans-unit>
        <trans-unit id="baad8b31b0f95aa1296c5c88ad34816424f2926e" translate="yes" xml:space="preserve">
          <source>The resulting directory proj.git contains a &quot;bare&quot; git repository&amp;mdash;​it is just the contents of the &lt;code&gt;.git&lt;/code&gt; directory, without any files checked out around it.</source>
          <target state="translated">产生的目录proj.git包含一个``裸露''的git存储库-它只是 &lt;code&gt;.git&lt;/code&gt; 目录的内容，周围没有任何文件被检出。</target>
        </trans-unit>
        <trans-unit id="31dc4b206e7be8ca9a78c4871cc58f03a5340e5b" translate="yes" xml:space="preserve">
          <source>The revision data is appended to the file if it already exists, for use when doing incremental imports.</source>
          <target state="translated">如果文件中已经存在修订数据,则将其附加到文件中,以便在进行增量导入时使用。</target>
        </trans-unit>
        <trans-unit id="0ca811b30547ebe29846859e95a6c9147e8141b4" translate="yes" xml:space="preserve">
          <source>The rewrite rule guarantees that existing static files will be properly served, whereas any other URL will be passed to gitweb as PATH_INFO parameter.</source>
          <target state="translated">重写规则保证了现有的静态文件将被正确地服务,而其他任何URL将作为PATH_INFO参数传递给gitweb。</target>
        </trans-unit>
        <trans-unit id="7511d9248c0671ec876d283606ae9df0bea2f6b2" translate="yes" xml:space="preserve">
          <source>The ripple effect of a &quot;hard case&quot; recovery is especially bad: &lt;code&gt;everyone&lt;/code&gt; downstream from &lt;code&gt;topic&lt;/code&gt; will now have to perform a &quot;hard case&quot; recovery too!</source>
          <target state="translated">&amp;ldquo;硬案例&amp;rdquo;恢复的连锁反应尤其糟糕： &lt;code&gt;topic&lt;/code&gt; 下游的 &lt;code&gt;everyone&lt;/code&gt; 现在也都必须执行&amp;ldquo;硬案例&amp;rdquo;恢复！</target>
        </trans-unit>
        <trans-unit id="93d5c7537e241865d860131eb6d72edc95c9d772" translate="yes" xml:space="preserve">
          <source>The root of the CVS archive. May be local (a simple path) or remote; currently, only the :local:, :ext: and :pserver: access methods are supported. If not given, &lt;code&gt;git cvsimport&lt;/code&gt; will try to read it from &lt;code&gt;CVS/Root&lt;/code&gt;. If no such file exists, it checks for the &lt;code&gt;CVSROOT&lt;/code&gt; environment variable.</source>
          <target state="translated">CVS存档的根。可以是本地（简单路径）或远程；当前，仅支持：local：，：ext：和：pserver：访问方法。如果未给出， &lt;code&gt;git cvsimport&lt;/code&gt; 将尝试从 &lt;code&gt;CVS/Root&lt;/code&gt; 读取它。如果不存在这样的文件，它将检查 &lt;code&gt;CVSROOT&lt;/code&gt; 环境变量。</target>
        </trans-unit>
        <trans-unit id="df41fdf293aec02e3dee1ead27003284471a1181" translate="yes" xml:space="preserve">
          <source>The root of the tree can be represented by an empty string as &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">树的根可以用空字符串表示为 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="557dc21e01559e09224bc25bcbd6a672b4e3d883" translate="yes" xml:space="preserve">
          <source>The rule to determine which remote branch to merge after fetching is a bit involved, in order not to break backward compatibility.</source>
          <target state="translated">为了不破坏后向兼容性,取完后确定合并哪个远程分支的规则有点牵扯。</target>
        </trans-unit>
        <trans-unit id="bbff5506f0bff9eed6d1a29f80ce8f838449bb56" translate="yes" xml:space="preserve">
          <source>The rules by which the pattern matches paths are the same as in &lt;code&gt;.gitignore&lt;/code&gt; files (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), with a few exceptions:</source>
          <target state="translated">模式匹配路径的规则与 &lt;code&gt;.gitignore&lt;/code&gt; 文件中的规则相同（请参见&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;），但有一些例外：</target>
        </trans-unit>
        <trans-unit id="579e7c08387accae89723ba13e3ec53145837232" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;--merge&lt;/code&gt; option above, but changes the way the conflicting hunks are presented, overriding the &lt;code&gt;merge.conflictStyle&lt;/code&gt; configuration variable. Possible values are &quot;merge&quot; (default) and &quot;diff3&quot; (in addition to what is shown by &quot;merge&quot; style, shows the original contents).</source>
          <target state="translated">与上面的 &lt;code&gt;--merge&lt;/code&gt; 选项相同，但是更改了显示冲突的块的方式，覆盖了 &lt;code&gt;merge.conflictStyle&lt;/code&gt; 配置变量。可能的值为&amp;ldquo;合并&amp;rdquo;（默认）和&amp;ldquo; diff3&amp;rdquo;（除了&amp;ldquo;合并&amp;rdquo;样式显示的内容以外，还显示原始内容）。</target>
        </trans-unit>
        <trans-unit id="1a11cc7f94381fe2de07d484775d2914bf62d241" translate="yes" xml:space="preserve">
          <source>The same as the previous one:</source>
          <target state="translated">与之前的一样。</target>
        </trans-unit>
        <trans-unit id="ebdfbbadd1b4e3e4d3c390aed297730072348592" translate="yes" xml:space="preserve">
          <source>The same rewind and rebuild process may be followed for &lt;code&gt;pu&lt;/code&gt;. A public announcement is not necessary since &lt;code&gt;pu&lt;/code&gt; is a throw-away branch, as described above.</source>
          <target state="translated">&lt;code&gt;pu&lt;/code&gt; 可以遵循相同的倒带和重建过程。如上所述，由于 &lt;code&gt;pu&lt;/code&gt; 是一个一次性分支，因此无需进行公开公告。</target>
        </trans-unit>
        <trans-unit id="30d931302d20c8d2d3f4d29cdb99720d08f56244" translate="yes" xml:space="preserve">
          <source>The same trailer as a v1 pack file:</source>
          <target state="translated">和v1包文件一样的预告片。</target>
        </trans-unit>
        <trans-unit id="ef6e4cd5de79a2002e4df69090fc16d7024fe532" translate="yes" xml:space="preserve">
          <source>The sample &lt;code&gt;prepare-commit-msg&lt;/code&gt; hook that comes with Git removes the help message found in the commented portion of the commit template.</source>
          <target state="translated">Git附带的样本 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 挂钩删除了在提交模板的注释部分中找到的帮助消息。</target>
        </trans-unit>
        <trans-unit id="0814a224cf6ffffca90b05b46ffd264f8d62f600" translate="yes" xml:space="preserve">
          <source>The sample hooks are all disabled by default. To enable one of the sample hooks rename it by removing its &lt;code&gt;.sample&lt;/code&gt; suffix.</source>
          <target state="translated">默认情况下，样本挂钩均处于禁用状态。要启用其中一个示例挂钩，请通过删除其 &lt;code&gt;.sample&lt;/code&gt; 后缀对其重命名。</target>
        </trans-unit>
        <trans-unit id="ee2f5fb52849fdcd69a62a399938c4c71ec4e36c" translate="yes" xml:space="preserve">
          <source>The sane thing. Just admit you screwed up, and use a different name. Others have already seen one tag-name, and if you keep the same name, you may be in the situation that two people both have &quot;version X&quot;, but they actually have &lt;code&gt;different&lt;/code&gt; &quot;X&quot;'s. So just call it &quot;X.1&quot; and be done with it.</source>
          <target state="translated">理智的事情。只要承认您搞砸了，并使用其他名称即可。其他人已经看到了一个标记名，如果您使用相同的名称，则可能是两个人都有&amp;ldquo; X版本&amp;rdquo;，但实际上却有 &lt;code&gt;different&lt;/code&gt; &amp;ldquo; X&amp;rdquo;。因此，只需将其称为&amp;ldquo; X.1&amp;rdquo;即可完成。</target>
        </trans-unit>
        <trans-unit id="16a78cd21b6c709f016f4a17d2a1069e970db97c" translate="yes" xml:space="preserve">
          <source>The script expects you to provide the key roots where it can start the import from an &lt;code&gt;initial import&lt;/code&gt; or &lt;code&gt;tag&lt;/code&gt; type of Arch commit. It will follow and import new branches within the provided roots.</source>
          <target state="translated">该脚本希望您提供密钥根，以便从 &lt;code&gt;initial import&lt;/code&gt; 或Arch提交的 &lt;code&gt;tag&lt;/code&gt; 类型开始导入。它将遵循并在提供的根目录中导入新分支。</target>
        </trans-unit>
        <trans-unit id="793ca81ee99913a2e3edc7ca33209f79549422e8" translate="yes" xml:space="preserve">
          <source>The scriptlet sets &lt;code&gt;GIT_DIR&lt;/code&gt; and &lt;code&gt;GIT_OBJECT_DIRECTORY&lt;/code&gt; shell variables, but does &lt;strong&gt;not&lt;/strong&gt; export them to the environment.</source>
          <target state="translated">脚本集设置了 &lt;code&gt;GIT_DIR&lt;/code&gt; 和 &lt;code&gt;GIT_OBJECT_DIRECTORY&lt;/code&gt; Shell变量，但是&lt;strong&gt;没有&lt;/strong&gt;将它们导出到环境中。</target>
        </trans-unit>
        <trans-unit id="8b53f7beee61a37b0174ea389f5f36080ff3c1b7" translate="yes" xml:space="preserve">
          <source>The second .gitignore prevents Git from ignoring &lt;code&gt;arch/foo/kernel/vmlinux.lds.S&lt;/code&gt;.</source>
          <target state="translated">第二个.gitignore防止Git忽略 &lt;code&gt;arch/foo/kernel/vmlinux.lds.S&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc737587a80c0c07a4fffd3646c479ff0f86cddd" translate="yes" xml:space="preserve">
          <source>The second example demonstrates that you can abbreviate the object name to only the first several hexadecimal digits in most places.</source>
          <target state="translated">第二个例子表明,你可以在大多数地方将对象名称缩写为只有前几位十六进制数字。</target>
        </trans-unit>
        <trans-unit id="2890a9def3fff903603dee47b68cd9b5af108707" translate="yes" xml:space="preserve">
          <source>The second format is what gets used when &lt;code&gt;--stage=all&lt;/code&gt;. The three stage temporary fields (stage1temp, stage2temp, stage3temp) list the name of the temporary file if there is a stage entry in the index or &lt;code&gt;.&lt;/code&gt; if there is no stage entry. Paths which only have a stage 0 entry will always be omitted from the output.</source>
          <target state="translated">第二种格式是 &lt;code&gt;--stage=all&lt;/code&gt; 时使用的格式。如果索引或中有一个阶段条目，则三个阶段的临时字段（stage1temp，stage2temp，stage3temp）将列出临时文件的名称 &lt;code&gt;.&lt;/code&gt; 如果没有阶段入口。仅具有阶段0条目的路径将始终从输出中省略。</target>
        </trans-unit>
        <trans-unit id="86b87f951d8d8be1a02da6e062a3489256945d73" translate="yes" xml:space="preserve">
          <source>The second parameter passed to the hook is the indicator for whether or not the index was updated and the skip-worktree bit could have changed. &quot;1&quot; meaning skip-worktree bits could have been updated and &quot;0&quot; meaning they were not.</source>
          <target state="translated">传递给钩子的第二个参数是索引是否被更新和skip-worktree位是否可能发生变化的指示器,&quot;1 &quot;表示skip-worktree位可能被更新,&quot;0 &quot;表示没有被更新。&quot;1 &quot;表示skip-worktree位可能已经更新,&quot;0 &quot;表示没有更新。</target>
        </trans-unit>
        <trans-unit id="b730007914036d9f0fb3ba6052d64853bae216ae" translate="yes" xml:space="preserve">
          <source>The second syntax (&quot;&lt;code&gt;git merge --abort&lt;/code&gt;&quot;) can only be run after the merge has resulted in conflicts. &lt;code&gt;git merge --abort&lt;/code&gt; will abort the merge process and try to reconstruct the pre-merge state. However, if there were uncommitted changes when the merge started (and especially if those changes were further modified after the merge was started), &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to reconstruct the original (pre-merge) changes. Therefore:</source>
          <target state="translated">第二种语法（&amp;ldquo; &lt;code&gt;git merge --abort&lt;/code&gt; &amp;rdquo;）只能在合并导致冲突后运行。 &lt;code&gt;git merge --abort&lt;/code&gt; 将中止合并过程，并尝试重建合并前的状态。但是，如果在合并开始时有未提交的更改（尤其是在合并开始后进一步修改了这些更改），则 &lt;code&gt;git merge --abort&lt;/code&gt; 在某些情况下将无法重建原始（合并前）更改。因此：</target>
        </trans-unit>
        <trans-unit id="1f7dcee78b5872602756cd0d868ad6253db301fe" translate="yes" xml:space="preserve">
          <source>The second transformation in the chain is diffcore-break, and is controlled by the -B option to the &lt;code&gt;git diff-*&lt;/code&gt; commands. This is used to detect a filepair that represents &quot;complete rewrite&quot; and break such filepair into two filepairs that represent delete and create. E.g. If the input contained this filepair:</source>
          <target state="translated">链中的第二个转换是diffcore-break，由 &lt;code&gt;git diff-*&lt;/code&gt; 命令的-B选项控制。这用于检测代表&amp;ldquo;完全重写&amp;rdquo;的文件对，并将该文件对分为代表删除和创建的两个文件对。例如，如果输入包含此文件对：</target>
        </trans-unit>
        <trans-unit id="5aa738048a0181b9705365955bd04c18156f9d33" translate="yes" xml:space="preserve">
          <source>The section &lt;code&gt;submodule.foo.*&lt;/code&gt; in the &lt;code&gt;.gitmodules&lt;/code&gt; file gives additional hints to Git&amp;rsquo;s porcelain layer. For example, the &lt;code&gt;submodule.foo.url&lt;/code&gt; setting specifies where to obtain the submodule.</source>
          <target state="translated">&lt;code&gt;.gitmodules&lt;/code&gt; 文件中的 &lt;code&gt;submodule.foo.*&lt;/code&gt; 部分为Git的瓷器层提供了其他提示。例如， &lt;code&gt;submodule.foo.url&lt;/code&gt; 设置指定从何处获取子模块。</target>
        </trans-unit>
        <trans-unit id="addff8a92e5ddb901ae8a38330bc2dcce4be9fbb" translate="yes" xml:space="preserve">
          <source>The section or key is invalid (ret=1),</source>
          <target state="translated">节或键无效(ret=1)。</target>
        </trans-unit>
        <trans-unit id="463ba2454fad2719570e32271a038c3acce699a7" translate="yes" xml:space="preserve">
          <source>The server MUST NOT send any &quot;unshallow&quot; lines for anything which the client has not indicated was shallow as a part of its request.</source>
          <target state="translated">服务器绝不能发送任何 &quot;不浅 &quot;的行,如果客户在请求中没有说明是浅的,则必须发送。</target>
        </trans-unit>
        <trans-unit id="d868af4cbdec034778f61defdf53e9a4307fd341" translate="yes" xml:space="preserve">
          <source>The server MUST NOT send any refs which were not requested using &lt;code&gt;want-ref&lt;/code&gt; lines.</source>
          <target state="translated">服务器不得发送任何没有使用 &lt;code&gt;want-ref&lt;/code&gt; 线请求的参考。</target>
        </trans-unit>
        <trans-unit id="446930d87bed0e82e29e329dd081708ba37057c2" translate="yes" xml:space="preserve">
          <source>The server can advertise the &lt;code&gt;agent&lt;/code&gt; capability with a value &lt;code&gt;X&lt;/code&gt; (in the form &lt;code&gt;agent=X&lt;/code&gt;) to notify the client that the server is running version &lt;code&gt;X&lt;/code&gt;. The client may optionally send its own agent string by including the &lt;code&gt;agent&lt;/code&gt; capability with a value &lt;code&gt;Y&lt;/code&gt; (in the form &lt;code&gt;agent=Y&lt;/code&gt;) in its request to the server (but it MUST NOT do so if the server did not advertise the agent capability). The &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; strings may contain any printable ASCII characters except space (i.e., the byte range 32 &amp;lt; x &amp;lt; 127), and are typically of the form &quot;package/version&quot; (e.g., &quot;git/1.8.3.1&quot;). The agent strings are purely informative for statistics and debugging purposes, and MUST NOT be used to programmatically assume the presence or absence of particular features.</source>
          <target state="translated">服务器可以使用值 &lt;code&gt;X&lt;/code&gt; （以 &lt;code&gt;agent=X&lt;/code&gt; 的形式）通告 &lt;code&gt;agent&lt;/code&gt; 功能，以通知客户端服务器正在运行 &lt;code&gt;X&lt;/code&gt; 版本。客户端可以选择将自己的代理字符串发送给服务器，方法是在请求中包括一个具有 &lt;code&gt;Y&lt;/code&gt; 值（形式为 &lt;code&gt;agent=Y&lt;/code&gt; ）的 &lt;code&gt;agent&lt;/code&gt; 功能（但如果服务器未公布代理功能，则它一定不要这样做）。在 &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;Y&lt;/code&gt; ^字符串可以包含除空格（即字节范围32 &amp;lt;x &amp;lt;127）之外的任何可打印ASCII字符，并且通常采用&amp;ldquo;包/版本&amp;rdquo;形式（例如，&amp;ldquo; git / 1.8.3.1&amp;rdquo;）。代理字符串仅出于统计和调试目的提供信息，不得用于以编程方式假定是否存在特定功能。</target>
        </trans-unit>
        <trans-unit id="5dbb8fc2dd2ef1317864e26b0a2f75da26a1d7f0" translate="yes" xml:space="preserve">
          <source>The server sends a &quot;shallow obj-id&quot; line for each commit whose parents will not be sent in the following packfile.</source>
          <target state="translated">服务器为每个提交发送一个 &quot;浅层obj-id &quot;行,其父母不会在下面的packfile中发送。</target>
        </trans-unit>
        <trans-unit id="15cbc52acb55c8a437e7a9fc2cb2ebb8c994afc3" translate="yes" xml:space="preserve">
          <source>The server sends an &quot;unshallow obj-id&quot; line for each commit which the client has indicated is shallow, but is no longer shallow as a result of the fetch (due to its parents being sent in the following packfile).</source>
          <target state="translated">服务器为每一个提交发送 &quot;unshallow obj-id &quot;行,客户端已经表示该提交是浅层的,但由于取回的结果已经不再是浅层的了(由于它的父体被发送到下面的packfile中)。</target>
        </trans-unit>
        <trans-unit id="3f482eecb5e3fca563243c0419eece540e0582ac" translate="yes" xml:space="preserve">
          <source>The server will respond with &quot;ACK obj-id&quot; for all of the object ids sent as have lines which are common.</source>
          <target state="translated">服务器将以 &quot;ACK obj-id &quot;回应所有发送的对象id,因为有行是共同的。</target>
        </trans-unit>
        <trans-unit id="543a974b0aa8c62d541ca2830198235b945cc003" translate="yes" xml:space="preserve">
          <source>The server will respond with &quot;NAK&quot; if none of the object ids sent as have lines were common.</source>
          <target state="translated">如果作为have行发送的对象id没有一个是共同的,服务器将以 &quot;NAK &quot;回应。</target>
        </trans-unit>
        <trans-unit id="568256da628f1737b5310a22de9a07629ce73e0d" translate="yes" xml:space="preserve">
          <source>The server will respond with a &quot;ready&quot; line indicating that the server has found an acceptable common base and is ready to make and send a packfile (which will be found in the packfile section of the same response)</source>
          <target state="translated">服务器将以 &quot;准备好了 &quot;行来回应,表示服务器已经找到了一个可接受的公共基础,并准备好制作和发送一个packfile(它将在同一响应的packfile部分找到)。</target>
        </trans-unit>
        <trans-unit id="69ff3eec8c55e5a8095ea13f51e31e429dc845d6" translate="yes" xml:space="preserve">
          <source>The server will send a ref listing (&quot;&amp;lt;oid&amp;gt; &amp;lt;refname&amp;gt;&quot;) for each reference requested using &lt;code&gt;want-ref&lt;/code&gt; lines.</source>
          <target state="translated">服务器将使用旺旺 &lt;code&gt;want-ref&lt;/code&gt; 线为每个请求的参考发送参考列表（&amp;ldquo; &amp;lt;oid&amp;gt; &amp;lt;参考名称&amp;gt;&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="afb7e2ac1ca268d29d3dabe65a1485bc3c99ebf1" translate="yes" xml:space="preserve">
          <source>The server will then check to ensure that the client&amp;rsquo;s request is comprised of a valid command as well as valid capabilities which were advertised. If the request is valid the server will then execute the command. A server MUST wait till it has received the client&amp;rsquo;s entire request before issuing a response. The format of the response is determined by the command being executed, but in all cases a flush-pkt indicates the end of the response.</source>
          <target state="translated">然后，服务器将检查以确保客户端的请求包含有效的命令以及已通告的有效功能。如果请求有效，则服务器将执行命令。服务器必须等到收到客户端的整个请求后再发出响应。响应的格式由正在执行的命令确定，但在所有情况下，flush-pkt均指示响应结束。</target>
        </trans-unit>
        <trans-unit id="537b1e0777fad4eaaafbf4ccf5940ab37b1e2ed6" translate="yes" xml:space="preserve">
          <source>The shared index part, to be referenced by $GIT_DIR/index and other temporary index files. Only valid in split index mode.</source>
          <target state="translated">共享索引部分,由$GIT_DIR/index和其他临时索引文件引用。仅在分割索引模式下有效。</target>
        </trans-unit>
        <trans-unit id="d11a14c0103fd18e1ebb96bcb7251e0f8abbce80" translate="yes" xml:space="preserve">
          <source>The shift magic first throws away the tree id and then the -p parameters. Note that this handles merges properly! In case Darl committed a merge between P1 and P2, it will be propagated properly and all children of the merge will become merge commits with P1,P2 as their parents instead of the merge commit.</source>
          <target state="translated">Shift魔术首先抛开树的id,然后抛开-p参数。请注意,这样可以正确处理合并 如果Darl在P1和P2之间提交了一个合并,它将被正确地传播,所有合并的子代将成为以P1,P2为父代的合并提交,而不是合并提交。</target>
        </trans-unit>
        <trans-unit id="e33b2d8b27401f604cb70ad4d214df90a2abf20c" translate="yes" xml:space="preserve">
          <source>The similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one.</source>
          <target state="translated">相似性指数是指没有变化的线条的百分比,而不相似性指数是指变化线条的百分比。它是一个四舍五入的整数,后面有一个百分号。因此,相似度指数值为100%是为两个相等的文件保留的,而100%的不相似度意味着旧文件中没有行进入新文件。</target>
        </trans-unit>
        <trans-unit id="09f0c715250f8ac9e78727d6768d66502facff83" translate="yes" xml:space="preserve">
          <source>The simplest commit to find is the HEAD commit, which we can find from .git/HEAD:</source>
          <target state="translated">最简单的提交是head提交,我们可以从.git/HEAD中找到。</target>
        </trans-unit>
        <trans-unit id="938f800e1b465bd0f07eb377492ba2456bfbed2c" translate="yes" xml:space="preserve">
          <source>The simplest way to do this is using &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and ssh; to update the remote branch named &lt;code&gt;master&lt;/code&gt; with the latest state of your branch named &lt;code&gt;master&lt;/code&gt;, run</source>
          <target state="translated">最简单的方法是使用&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;和ssh; 更新名为远程分支 &lt;code&gt;master&lt;/code&gt; 与你的分支命名的最新状态 &lt;code&gt;master&lt;/code&gt; ，跑</target>
        </trans-unit>
        <trans-unit id="a5eba655ac4b55a1106bdc6c6dbf2b0d1ad04c8a" translate="yes" xml:space="preserve">
          <source>The simplest way to mark a file as binary is to unset the diff attribute in the &lt;code&gt;.gitattributes&lt;/code&gt; file:</source>
          <target state="translated">将文件标记为二进制的最简单方法是取消设置 &lt;code&gt;.gitattributes&lt;/code&gt; 文件中的diff属性：</target>
        </trans-unit>
        <trans-unit id="99bb329f9f9a76ae9c81982693e8d5911709e87c" translate="yes" xml:space="preserve">
          <source>The size of the object (the same as &lt;code&gt;git cat-file -s&lt;/code&gt; reports). Append &lt;code&gt;:disk&lt;/code&gt; to get the size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the &lt;code&gt;CAVEATS&lt;/code&gt; section below.</source>
          <target state="translated">对象的大小（与 &lt;code&gt;git cat-file -s&lt;/code&gt; 报告相同）。附加 &lt;code&gt;:disk&lt;/code&gt; 以获取对象占用磁盘的大小（以字节为单位）。请参阅下面的&amp;ldquo; &lt;code&gt;CAVEATS&lt;/code&gt; 部分中有关磁盘大小的注释。</target>
        </trans-unit>
        <trans-unit id="3527fa64b6fd749102c379b2fd96b0df5cd454cb" translate="yes" xml:space="preserve">
          <source>The size of the window used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; when no window size is given on the command line. Defaults to 10.</source>
          <target state="translated">窗口的大小使用&lt;a href=&quot;git-pack-objects&quot;&gt;GIT中包对象[1]&lt;/a&gt;当在命令行上没有给出窗口大小。默认为10</target>
        </trans-unit>
        <trans-unit id="2372575566ae8c805d7580bdcbad6da1c4463611" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the object (the same as &lt;code&gt;cat-file -s&lt;/code&gt; reports).</source>
          <target state="translated">对象的大小（以字节为单位）（与 &lt;code&gt;cat-file -s&lt;/code&gt; 报告相同）。</target>
        </trans-unit>
        <trans-unit id="43c333a5a6bd3bca8b34d5163a7aa7b6d79d2d40" translate="yes" xml:space="preserve">
          <source>The size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the &lt;code&gt;CAVEATS&lt;/code&gt; section below.</source>
          <target state="translated">对象在磁盘上占用的大小（以字节为单位）。请参阅下面的&amp;ldquo; &lt;code&gt;CAVEATS&lt;/code&gt; 部分中有关磁盘大小的注释。</target>
        </trans-unit>
        <trans-unit id="7d544171c06a9cb39c4059f830c0a8558d3922c9" translate="yes" xml:space="preserve">
          <source>The slash &lt;code&gt;/&lt;/code&gt; is used as the directory separator. Separators may occur at the beginning, middle or end of the &lt;code&gt;.gitignore&lt;/code&gt; search pattern.</source>
          <target state="translated">斜杠 &lt;code&gt;/&lt;/code&gt; 用作目录分隔符。分隔符可以出现在 &lt;code&gt;.gitignore&lt;/code&gt; 搜索模式的开始，中间或结尾。</target>
        </trans-unit>
        <trans-unit id="e18b2266f1b1b9062e466bd05dd697dc8d44c68f" translate="yes" xml:space="preserve">
          <source>The smaller the changes in your commit, the most effective &quot;git bisect&quot; will be. And you will probably need &quot;git bisect&quot; less in the first place, as small changes are easier to review even if they are only reviewed by the committer.</source>
          <target state="translated">提交的改动越小,&quot;git bisect &quot;就越有效。而且你可能会减少对 &quot;git bisect &quot;的需求,因为小的改动即使只有提交者审查,也更容易审查。</target>
        </trans-unit>
        <trans-unit id="0dab2fe7462a5d0c0b797d08e789dbaaf7bfa1df" translate="yes" xml:space="preserve">
          <source>The smart HTTP server, &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend[1]&lt;/a&gt;, will pass GIT_NAMESPACE through to the backend programs; see &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend[1]&lt;/a&gt; for sample configuration to expose repository namespaces as repositories.</source>
          <target state="translated">智能HTTP服务器&lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend [1]&lt;/a&gt;会将GIT_NAMESPACE传递给后端程序；请参阅&lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend [1]&lt;/a&gt;以获得用于将存储库名称空间公开为存储库的示例配置。</target>
        </trans-unit>
        <trans-unit id="9ee3be6f644f850e9ae409b580b74ced862493f8" translate="yes" xml:space="preserve">
          <source>The solution, of course, is to make a merge that we can undo: merge into a throw-away branch.</source>
          <target state="translated">当然,解决的办法是做一个我们可以撤销的合并:合并成一个扔掉的分支。</target>
        </trans-unit>
        <trans-unit id="8a1117f540255f9a5dcffa1baa25558f77657b0e" translate="yes" xml:space="preserve">
          <source>The special case of restarting an incremental import from the current branch value should be written as:</source>
          <target state="translated">从当前分支值重新启动增量导入的特殊情况应写成:。</target>
        </trans-unit>
        <trans-unit id="3599d1b8b89ee48d0b633dcff9041c57284c3251" translate="yes" xml:space="preserve">
          <source>The special exit code 125 should be used when the current source code cannot be tested. If the script exits with this code, the current revision will be skipped (see &lt;code&gt;git bisect skip&lt;/code&gt; above). 125 was chosen as the highest sensible value to use for this purpose, because 126 and 127 are used by POSIX shells to signal specific error status (127 is for command not found, 126 is for command found but not executable&amp;mdash;​these details do not matter, as they are normal errors in the script, as far as &lt;code&gt;bisect run&lt;/code&gt; is concerned).</source>
          <target state="translated">当无法测试当前源代码时，应使用特殊的退出代码125。如果脚本以该代码退出，则当前版本将被跳过（请参见上面的 &lt;code&gt;git bisect skip&lt;/code&gt; ）。 125被选为用于此目的的最高明智值，因为POSIX shell使用126和127来表示特定的错误状态（127用于未找到命令，126用于发现命令但不可执行-这些详细信息不无关紧要，因为就 &lt;code&gt;bisect run&lt;/code&gt; 而言，它们是脚本中的正常错误）。</target>
        </trans-unit>
        <trans-unit id="60ac8fe2a99f998c150bb7d9adc8dfbeed95a10d" translate="yes" xml:space="preserve">
          <source>The special null SHA-1 (40 zeros) specifies that the branch is to be removed.</source>
          <target state="translated">特殊的空SHA-1(40个零)指定要删除的分支。</target>
        </trans-unit>
        <trans-unit id="a4c2fa6682338e4d7c45557107add1984be0213c" translate="yes" xml:space="preserve">
          <source>The special refspec &lt;code&gt;:&lt;/code&gt; (or &lt;code&gt;+:&lt;/code&gt; to allow non-fast-forward updates) directs Git to push &quot;matching&quot; branches: for every branch that exists on the local side, the remote side is updated if a branch of the same name already exists on the remote side.</source>
          <target state="translated">特殊的refspec &lt;code&gt;:&lt;/code&gt; (或 &lt;code&gt;+:&lt;/code&gt; 允许非快速转发更新）指示Git推送&amp;ldquo;匹配&amp;rdquo;分支：对于本地存在的每个分支，如果已经存在同名的分支，则更新远程端在远端。</target>
        </trans-unit>
        <trans-unit id="f2f702d2704e1b64279419d712ca4460c3b7f78e" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;none&lt;/code&gt; can be used as the proxy command to specify that no proxy be used for a given domain pattern. This is useful for excluding servers inside a firewall from proxy use, while defaulting to a common proxy for external domains.</source>
          <target state="translated">特殊字符串 &lt;code&gt;none&lt;/code&gt; 可用作代理命令，以指定对于给定的域模式，不使用任何代理。这对于将防火墙内部的服务器从代理使用中排除，而默认使用外部域的通用代理很有用。</target>
        </trans-unit>
        <trans-unit id="65b859a3a4528b4a1eebafeebe9d2d28ac0eb085" translate="yes" xml:space="preserve">
          <source>The special symbol &quot;HEAD&quot; can always be used to refer to the current branch. In fact, Git uses a file named &lt;code&gt;HEAD&lt;/code&gt; in the &lt;code&gt;.git&lt;/code&gt; directory to remember which branch is current:</source>
          <target state="translated">特殊符号&amp;ldquo; HEAD&amp;rdquo;始终可以用于引用当前分支。实际上，Git 在 &lt;code&gt;.git&lt;/code&gt; 目录中使用一个名为 &lt;code&gt;HEAD&lt;/code&gt; 的文件来记住哪个分支是当前的：</target>
        </trans-unit>
        <trans-unit id="54b91d851f1b23aa70b29c0e74d2c28879b6de30" translate="yes" xml:space="preserve">
          <source>The ssh and git protocols additionally support ~username expansion:</source>
          <target state="translated">ssh和git协议另外支持~username扩展。</target>
        </trans-unit>
        <trans-unit id="ac6c6d73b5f6b7c3cef28dfe32da61495601bd7c" translate="yes" xml:space="preserve">
          <source>The standard actions are:</source>
          <target state="translated">标准行动是:</target>
        </trans-unit>
        <trans-unit id="a72f515f06e2719cd062e161d9ed80a61b68c92f" translate="yes" xml:space="preserve">
          <source>The standard email format as described by RFC 2822, for example &lt;code&gt;Thu, 07 Apr 2005 22:13:13 +0200&lt;/code&gt;.</source>
          <target state="translated">RFC 2822描述的标准电子邮件格式，例如 &lt;code&gt;Thu, 07 Apr 2005 22:13:13 +0200&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8128f4cfe82d86e129a0094608260664c3bb1ba3" translate="yes" xml:space="preserve">
          <source>The standard helper program to use with git-merge-index</source>
          <target state="translated">使用git-merge-index的标准帮助程序。</target>
        </trans-unit>
        <trans-unit id="4d34b021b617aa2bf3f93982ac428b041f085fbe" translate="yes" xml:space="preserve">
          <source>The starting point for the new branch. Specifying a &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; allows you to create a branch based on some other point in history than where HEAD currently points. (Or, in the case of &lt;code&gt;--detach&lt;/code&gt;, allows you to inspect and detach from some other point.)</source>
          <target state="translated">新分支的起点。指定 &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; 允许您基于历史记录中除HEAD当前指向的其他点来创建分支。（或者，在 &lt;code&gt;--detach&lt;/code&gt; 的情况下，允许您检查其他点并与之分离。）</target>
        </trans-unit>
        <trans-unit id="ca9ba47b83a1def4d8a6c769f2e642f061d5236a" translate="yes" xml:space="preserve">
          <source>The status of GPG verification of the push certificate, using the same mnemonic as used in &lt;code&gt;%G?&lt;/code&gt; format of &lt;code&gt;git log&lt;/code&gt; family of commands (see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;).</source>
          <target state="translated">使用与 &lt;code&gt;%G?&lt;/code&gt; 使用的相同的助记符对推送证书进行GPG验证的状态？ &lt;code&gt;git log&lt;/code&gt; 系列命令的格式（请参阅&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c902748a09ab505851b0b39809c60f3db2027be9" translate="yes" xml:space="preserve">
          <source>The status of the fetch is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</source>
          <target state="translated">取数的状态以表格形式输出,每一行代表一个ref的状态。每一行都是这样的形式。</target>
        </trans-unit>
        <trans-unit id="7729563c964ef73ba71f39abfa320766ac0cea33" translate="yes" xml:space="preserve">
          <source>The status of the push is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</source>
          <target state="translated">推送的状态以表格的形式输出,每一行代表一个参考的状态。每行的形式为:</target>
        </trans-unit>
        <trans-unit id="e939f21e3282d453b1398071feb25115360b90b4" translate="yes" xml:space="preserve">
          <source>The status of up-to-date refs is shown only if --porcelain or --verbose option is used.</source>
          <target state="translated">只有在使用--porcelain或--verbose选项时,才会显示最新参考资料的状态。</target>
        </trans-unit>
        <trans-unit id="0ebfa7ce02ec5605e425e0cd98062f5bbd8f2510" translate="yes" xml:space="preserve">
          <source>The status of up-to-date refs is shown only if the --verbose option is used.</source>
          <target state="translated">只有在使用--verbose选项时,才会显示最新的参考资料的状态。</target>
        </trans-unit>
        <trans-unit id="a97643bd561fabe3d136679e4752cb73667ec062" translate="yes" xml:space="preserve">
          <source>The structured objects can further have their structure and connectivity to other objects verified. This is generally done with the &lt;code&gt;git fsck&lt;/code&gt; program, which generates a full dependency graph of all objects, and verifies their internal consistency (in addition to just verifying their superficial consistency through the hash).</source>
          <target state="translated">结构化对象还可以验证其结构和与其他对象的连接性。通常使用 &lt;code&gt;git fsck&lt;/code&gt; 程序完成此操作，该程序会生成所有对象的完整依赖关系图，并验证其内部一致性（除了仅通过哈希验证其表面一致性之外）。</target>
        </trans-unit>
        <trans-unit id="af4ab93b8907c3bc82033e90c4bc6eedaac09e1c" translate="yes" xml:space="preserve">
          <source>The submit process invokes the editor before each p4 change is submitted. If this setting is true, though, the editing step is skipped.</source>
          <target state="translated">在每次提交p4修改之前,提交过程都会调用编辑器。但如果此设置为真,则会跳过编辑步骤。</target>
        </trans-unit>
        <trans-unit id="72386229ffdfc0f6ba847ccdd7620fcafabeae30" translate="yes" xml:space="preserve">
          <source>The submodule directories are there, but they&amp;rsquo;re empty:</source>
          <target state="translated">子模块目录在那里，但它们为空：</target>
        </trans-unit>
        <trans-unit id="802b1c9a36cac97c548242e11fe5baa3275576f0" translate="yes" xml:space="preserve">
          <source>The submodule will never be considered modified (but will nonetheless show up in the output of status and commit when it has been staged).</source>
          <target state="translated">这个子模块永远不会被认为是修改过的(但当它被分期时,还是会显示在状态和提交的输出中)。</target>
        </trans-unit>
        <trans-unit id="7180d60887d97b6ca57dd91c2b86681f019ca631" translate="yes" xml:space="preserve">
          <source>The submodule&amp;rsquo;s &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file would come into play when running &lt;code&gt;git push --recurse-submodules=check&lt;/code&gt; in the superproject, as this would check if the submodule has any changes not published to any remote. The remotes are configured in the submodule as usual in the &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file.</source>
          <target state="translated">在超级项目中运行 &lt;code&gt;git push --recurse-submodules=check&lt;/code&gt; 时，子模块的 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件将起作用，因为这将检查子模块是否有未发布到任何远程的更改。遥控器通常在 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件的子模块中进行配置。</target>
        </trans-unit>
        <trans-unit id="2a87578b15befa74b2d27eca3216884ceb35493c" translate="yes" xml:space="preserve">
          <source>The suffix &lt;code&gt;@{push}&lt;/code&gt; reports the branch &quot;where we would push to&quot; if &lt;code&gt;git push&lt;/code&gt; were run while &lt;code&gt;branchname&lt;/code&gt; was checked out (or the current &lt;code&gt;HEAD&lt;/code&gt; if no branchname is specified). Since our push destination is in a remote repository, of course, we report the local tracking branch that corresponds to that branch (i.e., something in &lt;code&gt;refs/remotes/&lt;/code&gt;).</source>
          <target state="translated">如果在 &lt;code&gt;branchname&lt;/code&gt; 时运行了 &lt;code&gt;git push&lt;/code&gt; ,则后缀 &lt;code&gt;@{push}&lt;/code&gt; 报告分支&amp;ldquo;我们将推送至的位置&amp;rdquo; （如果未指定branchname，则返回当前 &lt;code&gt;HEAD&lt;/code&gt; ）。由于推送目标位于远程存储库中，因此，我们当然会报告与该分支相对应的本地跟踪分支（即 &lt;code&gt;refs/remotes/&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c10fd9c6c93e1de11dbe32978aa15d853b4103fb" translate="yes" xml:space="preserve">
          <source>The suffix &lt;code&gt;@{upstream}&lt;/code&gt; to a branchname (short form &lt;code&gt;&amp;lt;branchname&amp;gt;@{u}&lt;/code&gt;) refers to the branch that the branch specified by branchname is set to build on top of (configured with &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;). A missing branchname defaults to the current one. These suffixes are also accepted when spelled in uppercase, and they mean the same thing no matter the case.</source>
          <target state="translated">分支名称的后缀 &lt;code&gt;@{upstream}&lt;/code&gt; （缩写为 &lt;code&gt;&amp;lt;branchname&amp;gt;@{u}&lt;/code&gt; ）是指分支名称所指定的分支被设置为建立在该分支之上（由 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 和 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; ）。缺少的分支名称默认为当前分支名称。这些后缀大写时也会被接受，无论大小写，它们都具有相同的含义。</target>
        </trans-unit>
        <trans-unit id="35fca7d90e0c51050df5863335fd96cb674d847a" translate="yes" xml:space="preserve">
          <source>The symlink will either be absolute (beginning with a /), or relative to the tree root. For instance, if dir/link points to ../../foo, then &amp;lt;symlink&amp;gt; will be ../foo. &amp;lt;size&amp;gt; is the size of the symlink in bytes.</source>
          <target state="translated">符号链接可以是绝对的（以/开头），也可以是相对于树根的符号。例如，如果dir / link指向../../foo，则&amp;lt;symlink&amp;gt;将是../foo。&amp;lt;size&amp;gt;是符号链接的大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="1e32c77f2578ce3c979cd217827d9aa3c6897be9" translate="yes" xml:space="preserve">
          <source>The syntax is fairly flexible and permissive; whitespaces are mostly ignored. The &lt;code&gt;#&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; characters begin comments to the end of line, blank lines are ignored.</source>
          <target state="translated">语法相当灵活且允许。空格通常被忽略。该 &lt;code&gt;#&lt;/code&gt; 和 &lt;code&gt;;&lt;/code&gt; 字符从注释开始到行尾，空白行将被忽略。</target>
        </trans-unit>
        <trans-unit id="e9a240786337cb206c43c416821000b9a6721022" translate="yes" xml:space="preserve">
          <source>The syntax of the configuration files is that of Perl, since these files are handled by sourcing them as fragments of Perl code (the language that gitweb itself is written in). Variables are typically set using the &lt;code&gt;our&lt;/code&gt; qualifier (as in &quot;&lt;code&gt;our $variable = &amp;lt;value&amp;gt;;&lt;/code&gt;&quot;) to avoid syntax errors if a new version of gitweb no longer uses a variable and therefore stops declaring it.</source>
          <target state="translated">配置文件的语法是Perl的语法，因为这些文件是通过将它们作为Perl代码的片段（gitweb本身所使用的语言）来提供来处理的。变量是使用通常设置 &lt;code&gt;our&lt;/code&gt; 限定符（如在&amp;ldquo; &lt;code&gt;our $variable = &amp;lt;value&amp;gt;;&lt;/code&gt; 以避免语法错误如果叫做gitweb的新版本不再使用一个变量，并因此停止它声明&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="85d5722bf15562fb833fe3c8f580a92fe2e2d3db" translate="yes" xml:space="preserve">
          <source>The tables below show what happens when running:</source>
          <target state="translated">下表显示了运行时的情况。</target>
        </trans-unit>
        <trans-unit id="0ab961c529e0da6916842ede03d74fc7b0e0f90e" translate="yes" xml:space="preserve">
          <source>The tag &lt;code&gt;v2.6.18&lt;/code&gt; is short for &lt;code&gt;refs/tags/v2.6.18&lt;/code&gt;.</source>
          <target state="translated">标签 &lt;code&gt;v2.6.18&lt;/code&gt; 是 &lt;code&gt;refs/tags/v2.6.18&lt;/code&gt; 的缩写。</target>
        </trans-unit>
        <trans-unit id="e5173af0305c1d6df2de24b7ea317c256f65109e" translate="yes" xml:space="preserve">
          <source>The template directory will be one of the following (in order):</source>
          <target state="translated">模板目录将是以下之一(按顺序)。</target>
        </trans-unit>
        <trans-unit id="45d4fdaf8fe9ac583ec50051c8f5eb8c944a1ec1" translate="yes" xml:space="preserve">
          <source>The term &lt;a href=&quot;#def_pickaxe&quot;&gt;pickaxe&lt;/a&gt; refers to an option to the diffcore routines that help select changes that add or delete a given text string. With the &lt;code&gt;--pickaxe-all&lt;/code&gt; option, it can be used to view the full &lt;a href=&quot;#def_changeset&quot;&gt;changeset&lt;/a&gt; that introduced or removed, say, a particular line of text. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">术语&lt;a href=&quot;#def_pickaxe&quot;&gt;镐&lt;/a&gt;是指diffcore例程的一个选项，该选项有助于选择添加或删除给定文本字符串的更改。使用 &lt;code&gt;--pickaxe-all&lt;/code&gt; 选项，它可以用于查看引入或删除的完整&lt;a href=&quot;#def_changeset&quot;&gt;变更集&lt;/a&gt;，例如，特定的文本行。参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2ba0595fa8d197d8c3640c03007e070ceba5b47" translate="yes" xml:space="preserve">
          <source>The text conversion is generally a one-way conversion; in this example, we lose the actual image contents and focus just on the text data. This means that diffs generated by textconv are &lt;em&gt;not&lt;/em&gt; suitable for applying. For this reason, only &lt;code&gt;git diff&lt;/code&gt; and the &lt;code&gt;git log&lt;/code&gt; family of commands (i.e., log, whatchanged, show) will perform text conversion. &lt;code&gt;git
format-patch&lt;/code&gt; will never generate this output. If you want to send somebody a text-converted diff of a binary file (e.g., because it quickly conveys the changes you have made), you should generate it separately and send it as a comment &lt;em&gt;in addition to&lt;/em&gt; the usual binary diff that you might send.</source>
          <target state="translated">文本转换通常是单向转换；在此示例中，我们丢失了实际的图像内容，而只关注文本数据。这意味着textconv生成的差异&lt;em&gt;不&lt;/em&gt;适合应用。因此，只有 &lt;code&gt;git diff&lt;/code&gt; 和 &lt;code&gt;git log&lt;/code&gt; 系列命令（即log，whatchanged，show）将执行文本转换。 &lt;code&gt;git format-patch&lt;/code&gt; 将永远不会生成此输出。如果您想将二进制文件的文本转换后的差异发送给某人（例如，因为它可以快速传达您所做的更改），则您应该单独生成该文件，并将其作为注释发送给您，&lt;em&gt;而&lt;/em&gt;不是通常的二进制差异。发送。</target>
        </trans-unit>
        <trans-unit id="eb234a21c48fd769b7576108683d04bf29f253cb" translate="yes" xml:space="preserve">
          <source>The third syntax (&quot;&lt;code&gt;git merge --continue&lt;/code&gt;&quot;) can only be run after the merge has resulted in conflicts.</source>
          <target state="translated">第三种语法（&amp;ldquo; &lt;code&gt;git merge --continue&lt;/code&gt; &amp;rdquo;）只能在合并导致冲突后运行。</target>
        </trans-unit>
        <trans-unit id="a25be90a41e318ce76ddb9737f9c1a04e1e950e3" translate="yes" xml:space="preserve">
          <source>The time between the first rc release and the final release is supposed to be used to test rc versions and fight bugs and especially regressions. And this time is more than 80% of the release cycle time. But this is not the end of the fight yet, as of course it continues after the release.</source>
          <target state="translated">从第一个rc版本到最终版本之间的时间,应该是用来测试rc版本和打击bug,尤其是回归。而这个时间占发布周期时间的80%以上。但这还不是战斗的结束,因为当然在发布后还要继续战斗。</target>
        </trans-unit>
        <trans-unit id="75271c1b7d85cdfdc3bad04249d4464b9c292a44" translate="yes" xml:space="preserve">
          <source>The time of the change is specified by &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; using the date format that was selected by the --date-format=&amp;lt;fmt&amp;gt; command-line option. See &amp;ldquo;Date Formats&amp;rdquo; above for the set of supported formats, and their syntax.</source>
          <target state="translated">更改时间由 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 使用--date-format = &amp;lt;fmt&amp;gt;命令行选项选择的日期格式指定。有关支持的格式集及其语法，请参见上面的&amp;ldquo;日期格式&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="05b9a4ac37ff05623171d65150ac27013efa2fa0" translate="yes" xml:space="preserve">
          <source>The time of the event is specified by &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; as the number of seconds since the UNIX epoch (midnight, Jan 1, 1970, UTC) and is written as an ASCII decimal integer.</source>
          <target state="translated">事件的时间由 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 指定为自UNIX纪元（1970年1月1日午夜，UTC）以来的秒数，并以ASCII十进制整数表示。</target>
        </trans-unit>
        <trans-unit id="e85bdfa8e02113c7aa36696add629ec632f05440" translate="yes" xml:space="preserve">
          <source>The todo list presented by the deprecated &lt;code&gt;--preserve-merges --interactive&lt;/code&gt; does not represent the topology of the revision graph (use &lt;code&gt;--rebase-merges&lt;/code&gt; instead). Editing commits and rewording their commit messages should work fine, but attempts to reorder commits tend to produce counterintuitive results. Use &lt;code&gt;--rebase-merges&lt;/code&gt; in such scenarios instead.</source>
          <target state="translated">不推荐使用的 &lt;code&gt;--preserve-merges --interactive&lt;/code&gt; 提供的待办事项列表不表示修订图的拓扑（请改用 &lt;code&gt;--rebase-merges&lt;/code&gt; ）。编辑提交并对提交消息进行重新措辞应该可以正常工作，但是尝试对提交进行重新排序会产生与直觉相反的结果。在这种情况下，请使用 &lt;code&gt;--rebase-merges&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f8166907df228eb9266d7566c3cde991d9d39bd" translate="yes" xml:space="preserve">
          <source>The total number of paths.</source>
          <target state="translated">总的路径数。</target>
        </trans-unit>
        <trans-unit id="46c0269533706ef03961ed4548e480cdcfd7a84a" translate="yes" xml:space="preserve">
          <source>The trailer records 20-byte SHA-1 checksum of all of the above.</source>
          <target state="translated">拖车记录了上述所有内容的20字节SHA-1校验和。</target>
        </trans-unit>
        <trans-unit id="9380254df0eb0e126f55d72177d625190ab23928" translate="yes" xml:space="preserve">
          <source>The transmission of the packfile begins immediately after the section header</source>
          <target state="translated">包装文件的传输在节头之后立即开始。</target>
        </trans-unit>
        <trans-unit id="de285c430d2e1f897693d7ccc23434e1a3a5c103" translate="yes" xml:space="preserve">
          <source>The tree object is the tree we examined first, and this commit is unusual in that it lacks any parent.</source>
          <target state="translated">树对象就是我们先检查的树,这次提交的情况很特别,它缺少任何父树。</target>
        </trans-unit>
        <trans-unit id="9178b43dc9b2907a6afd7a3693f2c6894ec0ecd9" translate="yes" xml:space="preserve">
          <source>The tree of actual checked out files. The working tree normally contains the contents of the &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; commit&amp;rsquo;s tree, plus any local changes that you have made but not yet committed.</source>
          <target state="translated">实际签出文件的树。工作树通常包含&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;提交树的内容，以及您已进行但尚未提交的所有本地更改。</target>
        </trans-unit>
        <trans-unit id="26b5c7d70f82997ceabb111adeeb911e4d89a340" translate="yes" xml:space="preserve">
          <source>The tree or commit to produce an archive for.</source>
          <target state="translated">要制作存档的树或提交。</target>
        </trans-unit>
        <trans-unit id="90f78952a054862b4ed6d79982e2eab2fc081a24" translate="yes" xml:space="preserve">
          <source>The twist is that if some file doesn&amp;rsquo;t match the index, we don&amp;rsquo;t have a backing store thing for it, and we use the magic &quot;all-zero&quot; sha1 to show that. So let&amp;rsquo;s say that you have edited &lt;code&gt;kernel/sched.c&lt;/code&gt;, but have not actually done a &lt;code&gt;git update-index&lt;/code&gt; on it yet - there is no &quot;object&quot; associated with the new state, and you get:</source>
          <target state="translated">扭曲之处在于，如果某个文件与索引不匹配，那么我们就没有后备存储，而我们使用神奇的&amp;ldquo;全零&amp;rdquo; sha1来表明这一点。因此，假设您已经编辑了 &lt;code&gt;kernel/sched.c&lt;/code&gt; ，但实际上尚未对其执行 &lt;code&gt;git update-index&lt;/code&gt; index-没有与新状态关联的&amp;ldquo;对象&amp;rdquo;，您将得到：</target>
        </trans-unit>
        <trans-unit id="43d0ee9ad50c1c3c133c4c2ff3f216463ab119aa" translate="yes" xml:space="preserve">
          <source>The two options can be specified together to ask a command to work on both the index and the working tree.</source>
          <target state="translated">这两个选项可以一起指定,要求命令同时在索引和工作树上工作。</target>
        </trans-unit>
        <trans-unit id="293c342524c5d665ec090c34f37c73d153be74d5" translate="yes" xml:space="preserve">
          <source>The type of the object (&lt;code&gt;blob&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;).</source>
          <target state="translated">对象的类型（ &lt;code&gt;blob&lt;/code&gt; ， &lt;code&gt;tree&lt;/code&gt; ， &lt;code&gt;commit&lt;/code&gt; ， &lt;code&gt;tag&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="35ca6d49608b210b7cf8be4b86261fa4bd55e249" translate="yes" xml:space="preserve">
          <source>The type of the object (the same as &lt;code&gt;cat-file -t&lt;/code&gt; reports).</source>
          <target state="translated">对象的类型（与 &lt;code&gt;cat-file -t&lt;/code&gt; 报告相同）。</target>
        </trans-unit>
        <trans-unit id="4785efb96aaa5561500dccbb8420f79e52290b85" translate="yes" xml:space="preserve">
          <source>The underlying Git plumbing tools, such as &lt;code&gt;git ls-files&lt;/code&gt; and &lt;code&gt;git read-tree&lt;/code&gt;, read &lt;code&gt;gitignore&lt;/code&gt; patterns specified by command-line options, or from files specified by command-line options. Higher-level Git tools, such as &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git add&lt;/code&gt;, use patterns from the sources specified above.</source>
          <target state="translated">基本的Git管道工具，例如 &lt;code&gt;git ls-files&lt;/code&gt; 和 &lt;code&gt;git read-tree&lt;/code&gt; ，从命令行选项指定的 &lt;code&gt;gitignore&lt;/code&gt; 读取模式，或者从命令行选项指定的文件读取gitignore模式。更高级别的Git工具（例如 &lt;code&gt;git status&lt;/code&gt; 和 &lt;code&gt;git add&lt;/code&gt; ）使用上述指定来源中的模式。</target>
        </trans-unit>
        <trans-unit id="c7717dd458d0c51efaa12d77d8ac91e6b1b7952a" translate="yes" xml:space="preserve">
          <source>The unique identifier of an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;. The object name is usually represented by a 40 character hexadecimal string. Also colloquially called &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;的唯一标识符。对象名称通常由40个字符的十六进制字符串表示。俗称&lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="190c2fffcaa0444f677f39ee7f8533684a0964b1" translate="yes" xml:space="preserve">
          <source>The unit of storage in Git. It is uniquely identified by the &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; of its contents. Consequently, an object cannot be changed.</source>
          <target state="translated">Git中的存储单位。它由其内容的&lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt;唯一标识。因此，无法更改对象。</target>
        </trans-unit>
        <trans-unit id="39871fae2a5575ced5627a5aed0eb792e4c6cc2e" translate="yes" xml:space="preserve">
          <source>The untracked cache extension can be enabled by the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">可以通过 &lt;code&gt;core.untrackedCache&lt;/code&gt; 配置变量启用未跟踪的缓存扩展（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cc7260429a75073116cdc4eb67dbd95326cbd29d" translate="yes" xml:space="preserve">
          <source>The upstream project is expected to have the commit named by &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; and the output asks it to integrate the changes you made since that commit, up to the commit named by &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt;, by visiting the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">预期上游项目将具有由 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 命名的提交，并且输出将要求它通过访问由 &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 命名的存储库集成您自该提交以来所做的更改，直至集成到由 &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; 命名的提交。</target>
        </trans-unit>
        <trans-unit id="90c1df21766dd92e926e4168cc9d516f756c7832" translate="yes" xml:space="preserve">
          <source>The upstream reference is generally &lt;code&gt;refs/remotes/p4/master&lt;/code&gt;, but can be overridden using the &lt;code&gt;--origin=&lt;/code&gt; command-line option.</source>
          <target state="translated">上游引用通常是 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; ，但是可以使用 &lt;code&gt;--origin=&lt;/code&gt; 命令行选项覆盖。</target>
        </trans-unit>
        <trans-unit id="26e6d639f86a47deca57ab3911edaae9c5141f38" translate="yes" xml:space="preserve">
          <source>The user wants to fast-forward to $M.</source>
          <target state="translated">用户想快进到$M。</target>
        </trans-unit>
        <trans-unit id="6df61c6f9e257fdbf1ce4a60fb1d73b618d329ca" translate="yes" xml:space="preserve">
          <source>The user&amp;rsquo;s color.status configuration is not respected; color will always be off.</source>
          <target state="translated">不尊重用户的color.status配置；颜色将始终关闭。</target>
        </trans-unit>
        <trans-unit id="ab6a20b222f27dba657bc91ae7970effd7a690ca" translate="yes" xml:space="preserve">
          <source>The user&amp;rsquo;s status.relativePaths configuration is not respected; paths shown will always be relative to the repository root.</source>
          <target state="translated">不遵守用户的status.relativePaths配置；显示的路径将始终相对于存储库根目录。</target>
        </trans-unit>
        <trans-unit id="20126eaca194f3ace1deaba2aaa4133e6326b674" translate="yes" xml:space="preserve">
          <source>The user-provided shell commands will likely involve a pipeline of commands, resulting in the creation of many processes per commit. Creating and running another process takes a widely varying amount of time between operating systems, but on any platform it is very slow relative to invoking a function.</source>
          <target state="translated">用户提供的shell命令很可能会涉及到一个命令流水线,导致每次提交都会创建许多进程。创建和运行另一个进程所需的时间在不同的操作系统之间有很大的差异,但在任何平台上,相对于调用一个函数来说都是非常缓慢的。</target>
        </trans-unit>
        <trans-unit id="b70cc2efdcbaf68bada34e0550746a0012d52bae" translate="yes" xml:space="preserve">
          <source>The username to use when logging in to the server.</source>
          <target state="translated">登录服务器时要使用的用户名。</target>
        </trans-unit>
        <trans-unit id="46c33e134557b27ccb1a85349808f80ba518bd84" translate="yes" xml:space="preserve">
          <source>The valid values for this option are: &lt;code&gt;add&lt;/code&gt; (this is the default) and &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">此选项的有效值为： &lt;code&gt;add&lt;/code&gt; （这是默认值）和 &lt;code&gt;doNothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17a990c606d2e2e22a8f755a1f843b57ef2f5ef2" translate="yes" xml:space="preserve">
          <source>The valid values for this option are: &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; (this is the default), &lt;code&gt;addIfDifferent&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">此选项的有效值为： &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; （这是默认值）， &lt;code&gt;addIfDifferent&lt;/code&gt; ， &lt;code&gt;add&lt;/code&gt; ， &lt;code&gt;replace&lt;/code&gt; 或 &lt;code&gt;doNothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="505e929c5c3b27eed17b03a2625718de5c7f7031" translate="yes" xml:space="preserve">
          <source>The value for a variable that takes a color is a list of colors (at most two, one for foreground and one for background) and attributes (as many as you want), separated by spaces.</source>
          <target state="translated">取色变量的值是一个颜色列表(最多两个,一个是前景色,一个是背景色)和属性(任意多个),用空格分隔。</target>
        </trans-unit>
        <trans-unit id="e1d242fc18797a443a86ba553d48e3f3cae01e9a" translate="yes" xml:space="preserve">
          <source>The value for many variables that specify various sizes can be suffixed with &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;,&amp;hellip;​ to mean &quot;scale the number by 1024&quot;, &quot;by 1024x1024&quot;, etc.</source>
          <target state="translated">可以将指定各种大小的许多变量的值加 &lt;code&gt;k&lt;/code&gt; ， &lt;code&gt;M&lt;/code&gt; ，... 后缀，以表示&amp;ldquo;将数字缩放1024&amp;rdquo;，&amp;ldquo;按1024x1024&amp;rdquo;等。</target>
        </trans-unit>
        <trans-unit id="f1dedc58ec3c676ad597a786553123421e517365" translate="yes" xml:space="preserve">
          <source>The value is a list of three values: a default time zone (for if the client hasn&amp;rsquo;t selected some other time zone and saved it in a cookie), a name of cookie where to store selected time zone, and a CSS class used to mark up dates for manipulation. If you want to turn this feature off, set &quot;default&quot; to empty list: &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">该值是三个值的列表：默认时区（如果客户端未选择其他时区并将其保存在Cookie中），用于存储所选时区的cookie名称以及所使用的CSS类标记日期以便进行操作。如果要关闭此功能，请将&amp;ldquo;默认&amp;rdquo;设置为空列表： &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0462ada8e80b752f4ecad69fb2563ec0b8b930aa" translate="yes" xml:space="preserve">
          <source>The value of 'default' is a list of names of snapshot formats, defined in &lt;code&gt;%known_snapshot_formats&lt;/code&gt; hash, that you wish to offer. Supported formats include &quot;tgz&quot;, &quot;tbz2&quot;, &quot;txz&quot; (gzip/bzip2/xz compressed tar archive) and &quot;zip&quot;; please consult gitweb sources for a definitive list. By default only &quot;tgz&quot; is offered.</source>
          <target state="translated">&amp;ldquo; default&amp;rdquo;的值是您希望提供的快照格式名称的列表，这些名称在 &lt;code&gt;%known_snapshot_formats&lt;/code&gt; 哈希中定义。支持的格式包括&amp;ldquo; tgz&amp;rdquo;，&amp;ldquo; tbz2&amp;rdquo;，&amp;ldquo; txz&amp;rdquo;（gzip / bzip2 / xz压缩tar存档）和&amp;ldquo; zip&amp;rdquo;；请查阅gitweb来源以获得确切的列表。默认情况下，仅提供&amp;ldquo; tgz&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c34b53e9a12553098df9adad4c30762484ffde18" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; must be a valid refname in Git and therefore may contain forward slashes. As &lt;code&gt;LF&lt;/code&gt; is not valid in a Git refname, no quoting or escaping syntax is supported here.</source>
          <target state="translated">&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 的值必须是Git中的有效refname，因此可能包含正斜杠。由于 &lt;code&gt;LF&lt;/code&gt; 在Git引用名称中无效，因此此处不支持引用或转义语法。</target>
        </trans-unit>
        <trans-unit id="8b5a30f586808b1827fdb8f433a15c6c9d49f6ba" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; must be in canonical form. That is it must not:</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 的值必须为规范形式。那绝对不能：</target>
        </trans-unit>
        <trans-unit id="dfb2ec984e9987b1b930824861a3abbf3e4aa29f" translate="yes" xml:space="preserve">
          <source>The value of this attribute specifies the character encoding that should be used by GUI tools (e.g. &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; and &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;) to display the contents of the relevant file. Note that due to performance considerations &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; does not use this attribute unless you manually enable per-file encodings in its options.</source>
          <target state="translated">此属性的值指定GUI工具（例如&lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt;和&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt;）用于显示相关文件内容的字符编码。请注意，出于性能方面的考虑，除非您在其选项中手动启用按文件编码，否则&lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt;不会使用此属性。</target>
        </trans-unit>
        <trans-unit id="4bdcd2a8dee01aee6c5f0f23e7e10ac25985aae6" translate="yes" xml:space="preserve">
          <source>The value of this key is the name of the promisor remote.</source>
          <target state="translated">这个键的值是承诺者远程的名称。</target>
        </trans-unit>
        <trans-unit id="49e3be97b83e2e2d47823db7b33592c5066364cc" translate="yes" xml:space="preserve">
          <source>The version parameter is used to specify the format version. This is optional and defaults to the original version &lt;code&gt;v1&lt;/code&gt; format.</source>
          <target state="translated">version参数用于指定格式版本。这是可选的，默认为原始版本 &lt;code&gt;v1&lt;/code&gt; 格式。</target>
        </trans-unit>
        <trans-unit id="a720bc9826a296e909d26ea1e1addd2076945090" translate="yes" xml:space="preserve">
          <source>The victim sends &quot;have&quot; lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn&amp;rsquo;t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to &quot;merge&quot; X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)</source>
          <target state="translated">受害者发送&amp;ldquo; have&amp;rdquo;行，广告它拥有的对象的ID，这些对象的ID并不是明确要共享的，但是如果对等方也有它们，则可以用来优化传输。攻击者选择要窃取的对象ID X并将引用发送给X，但由于受害者已经拥有X，因此不需要发送X的内容。现在，受害者认为攻击者拥有X，并将X的内容稍后发送回攻击者。 （通过在客户端有权访问的名称空间中创建对X的引用，然后将其提取，这种攻击对于客户端在服务器上执行来说是最直接的。服务器在客户端上执行此操作的最可能方式是&amp;ldquo;将&amp;ldquo; X&amp;rdquo;合并到公共分支，并希望用户在该分支上做其他工作并将其推送回服务器，而不会注意到合并。）</target>
        </trans-unit>
        <trans-unit id="bad569f9e07003c7e9ba90b91ff6d5e2d3ebab92" translate="yes" xml:space="preserve">
          <source>The virtual host configuration (in Apache configuration file) should look like this:</source>
          <target state="translated">虚拟主机的配置(在Apache配置文件中)应该是这样的。</target>
        </trans-unit>
        <trans-unit id="6258db9fdd3beac891e6dcfd7dedb19764ce413e" translate="yes" xml:space="preserve">
          <source>The way &lt;code&gt;git update-index&lt;/code&gt; handles files it is told about can be modified using the various options:</source>
          <target state="translated">该方式 &lt;code&gt;git update-index&lt;/code&gt; 手柄文件，它讲述可以使用各种选项进行修改：</target>
        </trans-unit>
        <trans-unit id="dc2adc08265063993fb836b81a622f1e26249d55" translate="yes" xml:space="preserve">
          <source>The web browser can be specified using the configuration variable &lt;code&gt;help.browser&lt;/code&gt;, or &lt;code&gt;web.browser&lt;/code&gt; if the former is not set. If none of these config variables is set, the &lt;code&gt;git web{litdd}browse&lt;/code&gt; helper script (called by &lt;code&gt;git help&lt;/code&gt;) will pick a suitable default. See git-web{litdd}browse[1] for more information about this.</source>
          <target state="translated">可以使用配置变量 &lt;code&gt;help.browser&lt;/code&gt; 或 &lt;code&gt;web.browser&lt;/code&gt; (如果未设置前者）来指定Web浏览器。如果未设置这些配置变量，则 &lt;code&gt;git web{litdd}browse&lt;/code&gt; 助手脚本（由 &lt;code&gt;git help&lt;/code&gt; 调用）将选择合适的默认值。有关更多信息，请参见git-web {litdd} browse [1]。</target>
        </trans-unit>
        <trans-unit id="c38f40c77930468f76ac59e3f127231f37c11803" translate="yes" xml:space="preserve">
          <source>The web browser that should be used to view the gitweb page. This will be passed to the &lt;code&gt;git web{litdd}browse&lt;/code&gt; helper script along with the URL of the gitweb instance. See git-web{litdd}browse[1] for more information about this. If the script fails, the URL will be printed to stdout.</source>
          <target state="translated">应该用于查看gitweb页面的Web浏览器。它将与gitweb实例的URL一起传递到 &lt;code&gt;git web{litdd}browse&lt;/code&gt; 帮助脚本。有关更多信息，请参见git-web {litdd} browse [1]。如果脚本失败，则URL将被打印到stdout。</target>
        </trans-unit>
        <trans-unit id="c7492cc5fa9e9927a227312bd1f1ea85a3766cb5" translate="yes" xml:space="preserve">
          <source>The width (in characters) of the &quot;Description&quot; column of the projects list. Longer descriptions will be truncated (trying to cut at word boundary); the full description is available in the &lt;code&gt;title&lt;/code&gt; attribute (usually shown on mouseover). The default is 25, which might be too small if you use long project descriptions.</source>
          <target state="translated">项目列表的&amp;ldquo;描述&amp;rdquo;列的宽度（以字符为单位）。较长的描述将被截断（试图在单词边界处切开）；完整的描述位于 &lt;code&gt;title&lt;/code&gt; 属性中（通常在鼠标悬停时显示）。默认值为25，如果使用较长的项目描述，则可能太小。</target>
        </trans-unit>
        <trans-unit id="2a9553b8b798d28f6c8fd9f09980f5b7959498e9" translate="yes" xml:space="preserve">
          <source>The window size parameter used in the delta compression algorithm used by &lt;code&gt;git gc --aggressive&lt;/code&gt;. This defaults to 250, which is a much more aggressive window size than the default &lt;code&gt;--window&lt;/code&gt; of 10.</source>
          <target state="translated">&lt;code&gt;git gc --aggressive&lt;/code&gt; 使用的增量压缩算法中使用的窗口大小参数。默认值为250，这比默认 &lt;code&gt;--window&lt;/code&gt; 10 窗口大小大得多。</target>
        </trans-unit>
        <trans-unit id="046739930d5e8946cdceaf820a70c4ac9ebc8d51" translate="yes" xml:space="preserve">
          <source>The working directory then reflects the contents that the project had when it was tagged v2.6.13, and &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; shows two branches, with an asterisk marking the currently checked-out branch:</source>
          <target state="translated">然后，工作目录反映了项目被标记为v2.6.13时的内容，而&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;显示了两个分支，其中带有星号的标记表示当前已签出的分支：</target>
        </trans-unit>
        <trans-unit id="c76d23bfcb6d4a63fd96acda23f8bee068090518" translate="yes" xml:space="preserve">
          <source>The worktree list command has two output formats. The default format shows the details on a single line with columns. For example:</source>
          <target state="translated">工作树列表命令有两种输出格式。默认格式是在单行上显示详细信息,并有列。例如,工作树列表命令有两种输出格式,默认的格式是将详细信息显示在带列的单行上。</target>
        </trans-unit>
        <trans-unit id="ecaf7c5f30215b083ffbd406549425a7d1040c7d" translate="yes" xml:space="preserve">
          <source>Then &quot;&lt;code&gt;git merge topic&lt;/code&gt;&quot; will replay the changes made on the &lt;code&gt;topic&lt;/code&gt; branch since it diverged from &lt;code&gt;master&lt;/code&gt; (i.e., &lt;code&gt;E&lt;/code&gt;) until its current commit (&lt;code&gt;C&lt;/code&gt;) on top of &lt;code&gt;master&lt;/code&gt;, and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.</source>
          <target state="translated">那么，&amp;ldquo; &lt;code&gt;git merge topic&lt;/code&gt; &amp;rdquo;将重播上所做的更改 &lt;code&gt;topic&lt;/code&gt; 分支，因为它从分歧 &lt;code&gt;master&lt;/code&gt; （即 &lt;code&gt;E&lt;/code&gt; ），直到其当前提交（ &lt;code&gt;C&lt;/code&gt; 之上） &lt;code&gt;master&lt;/code&gt; ，并在新的记录结果用的名字提交沿两个父提交，以及来自用户的描述更改的日志消息。</target>
        </trans-unit>
        <trans-unit id="f3bf49c80f1bf671798b336ee7a6337eb982b2bc" translate="yes" xml:space="preserve">
          <source>Then &quot;&lt;code&gt;git pull&lt;/code&gt;&quot; will fetch and replay the changes from the remote &lt;code&gt;master&lt;/code&gt; branch since it diverged from the local &lt;code&gt;master&lt;/code&gt; (i.e., &lt;code&gt;E&lt;/code&gt;) until its current commit (&lt;code&gt;C&lt;/code&gt;) on top of &lt;code&gt;master&lt;/code&gt; and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.</source>
          <target state="translated">那么，&amp;ldquo; &lt;code&gt;git pull&lt;/code&gt; &amp;rdquo;将获取和重放从远程更改 &lt;code&gt;master&lt;/code&gt; 分支，因为它从本地分歧 &lt;code&gt;master&lt;/code&gt; （即 &lt;code&gt;E&lt;/code&gt; ），直到其当前提交（ &lt;code&gt;C&lt;/code&gt; ^）之上 &lt;code&gt;master&lt;/code&gt; ，并在新的记录结果与提交沿两个父提交的名称以及来自用户的描述更改的日志消息。</target>
        </trans-unit>
        <trans-unit id="44f92500b7ae9560ae64e2f2fc4f1af900d3ff26" translate="yes" xml:space="preserve">
          <source>Then &quot;git bisect&quot; will checkout a commit of its choosing and ask the user to test it, like this:</source>
          <target state="translated">然后,&quot;git bisect &quot;会勾选一个它选择的提交,并要求用户测试它,就像这样。</target>
        </trans-unit>
        <trans-unit id="e1ef052a3cd59f805d0ae45d1b9033a6a2faaa95" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;git bisect&lt;/code&gt; will respond with something like</source>
          <target state="translated">然后 &lt;code&gt;git bisect&lt;/code&gt; 会回应类似</target>
        </trans-unit>
        <trans-unit id="307236a389d15c9e88cc574f3c2b3a0314992840" translate="yes" xml:space="preserve">
          <source>Then compile and test the chosen revision, and afterwards mark the revision as good or bad in the usual manner.</source>
          <target state="translated">然后对所选的修订版进行编译和测试,之后按照常规的方式对修订版进行好坏标记。</target>
        </trans-unit>
        <trans-unit id="876e252bd62eb2a97f748800c6625b2b00ccfdec" translate="yes" xml:space="preserve">
          <source>Then confirm that the bug persists in a repository created from that stream (many bugs will not, as they really do depend on the exact repository contents):</source>
          <target state="translated">然后确认该bug在从该流创建的仓库中持续存在(许多bug不会,因为它们确实取决于仓库的确切内容)。</target>
        </trans-unit>
        <trans-unit id="87463a5d117dae6022935ddfd68f09bfbb9b0943" translate="yes" xml:space="preserve">
          <source>Then create the following script to get list of project in the format suitable for GITWEB_LIST build configuration variable (or &lt;code&gt;$projects_list&lt;/code&gt; variable in gitweb config):</source>
          <target state="translated">然后创建以下脚本，以适合GITWEB_LIST构建配置变量（或gitweb config中的 &lt;code&gt;$projects_list&lt;/code&gt; 变量）的格式获取项目列表：</target>
        </trans-unit>
        <trans-unit id="b5a742d8577423cd13ed5705b5290de27ff73949" translate="yes" xml:space="preserve">
          <source>Then fixup &quot;master&quot; with &lt;code&gt;git rebase&lt;/code&gt;. Do NOT use &lt;code&gt;git merge&lt;/code&gt; or your history will not be compatible with a future &lt;code&gt;dcommit&lt;/code&gt;!</source>
          <target state="translated">然后用 &lt;code&gt;git rebase&lt;/code&gt; 修复&amp;ldquo; master&amp;rdquo; 。不要使用 &lt;code&gt;git merge&lt;/code&gt; ,否则您的历史记录将与以后的 &lt;code&gt;dcommit&lt;/code&gt; 不兼容！</target>
        </trans-unit>
        <trans-unit id="78318329e21f0014f75ba54a708b1f46ad0d023c" translate="yes" xml:space="preserve">
          <source>Then it compares the new skip-worktree value with the previous one. If skip-worktree turns from set to unset, it will add the corresponding file back. If it turns from unset to set, that file will be removed.</source>
          <target state="translated">然后将新的 skip-worktree 值与之前的值进行比较。如果 skip-worktree 从 set 转为 unset,它将把相应的文件添加回来。如果从unset转为set,则该文件将被删除。</target>
        </trans-unit>
        <trans-unit id="5e9c59419a3e5d8568740259a39319d49129c624" translate="yes" xml:space="preserve">
          <source>Then it examines &lt;code&gt;.gitattributes&lt;/code&gt; (which is in the parent directory), and finds that the first line matches, but &lt;code&gt;t/.gitattributes&lt;/code&gt; file already decided how &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; attributes should be given to this path, so it leaves &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; unset. Attribute &lt;code&gt;baz&lt;/code&gt; is set.</source>
          <target state="translated">然后，它检查 &lt;code&gt;.gitattributes&lt;/code&gt; （位于父目录中），发现第一行匹配，但是 &lt;code&gt;t/.gitattributes&lt;/code&gt; 文件已经决定了如何 &lt;code&gt;merge&lt;/code&gt; ， &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 属性赋予该路径，因此保留 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 未设定。设置属性 &lt;code&gt;baz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1100f313a3d209e54bf3bc725a364711886dbfc4" translate="yes" xml:space="preserve">
          <source>Then modify, reorder, or eliminate patches as needed before applying them again with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;:</source>
          <target state="translated">然后根据需要修改，重新排序或消除补丁，然后使用&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;再次应用它们：</target>
        </trans-unit>
        <trans-unit id="cd43ef848f2d3c4afb2a44ae28c2a413397c1d96" translate="yes" xml:space="preserve">
          <source>Then provide your password via the pserver method, for example:</source>
          <target state="translated">然后通过pserver方法提供密码,例如。</target>
        </trans-unit>
        <trans-unit id="a774f276f116b48d127c0c1418ef7aa2fe46b49b" translate="yes" xml:space="preserve">
          <source>Then simplify each commit &lt;code&gt;C&lt;/code&gt; to its replacement &lt;code&gt;C'&lt;/code&gt; in the final history according to the following rules:</source>
          <target state="translated">然后根据以下规则在最终历史记录中将每个提交 &lt;code&gt;C&lt;/code&gt; 简化为其替换 &lt;code&gt;C'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2f5d7fdcf8fcb013dcf3c597507de91a5cb0f77d" translate="yes" xml:space="preserve">
          <source>Then simply fork your topic branches from the stable remotes as explained earlier.</source>
          <target state="translated">然后按照前面的解释,简单地从稳定的远程中分叉出你的主题分支。</target>
        </trans-unit>
        <trans-unit id="b19a7b2e2b2e2252f0564256c9b87915d5db46d3" translate="yes" xml:space="preserve">
          <source>Then suppose you modify the last three commits:</source>
          <target state="translated">那么假设你修改了最后三次提交。</target>
        </trans-unit>
        <trans-unit id="e69e2e34d497710c4127a780d2a5ed5c7d7fac83" translate="yes" xml:space="preserve">
          <source>Then there are two ways to get a smaller repository. A safer way is to clone, that keeps your original intact.</source>
          <target state="translated">那么有两种方法可以让仓库变小。比较安全的方法是克隆,这样可以保持你的原件不变。</target>
        </trans-unit>
        <trans-unit id="5c871054b486e3acaf28dc409c1ab3e693b4fc90" translate="yes" xml:space="preserve">
          <source>Then this &lt;code&gt;git p4 clone&lt;/code&gt; command:</source>
          <target state="translated">然后这个 &lt;code&gt;git p4 clone&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="db9b57b987ef397bc0b191d278e31ed2d827cb0a" translate="yes" xml:space="preserve">
          <source>Then you can disable sparse checkout. Sparse checkout support in &lt;code&gt;git read-tree&lt;/code&gt; and similar commands is disabled by default. You need to turn &lt;code&gt;core.sparseCheckout&lt;/code&gt; on in order to have sparse checkout support.</source>
          <target state="translated">然后，您可以禁用稀疏签出。 &lt;code&gt;git read-tree&lt;/code&gt; 和类似命令中的稀疏签出支持默认情况下处于禁用状态。您需要打开 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 才能获得稀疏签出支持。</target>
        </trans-unit>
        <trans-unit id="87a33f516a8ffec885e906dbb29e388a5f30ada0" translate="yes" xml:space="preserve">
          <source>Then you can pull and merge, leaving &lt;code&gt;frotz.c&lt;/code&gt; and &lt;code&gt;filfre.c&lt;/code&gt; changes still in the working tree.</source>
          <target state="translated">然后，您可以拉并合并，将 &lt;code&gt;frotz.c&lt;/code&gt; 和 &lt;code&gt;filfre.c&lt;/code&gt; 的更改仍保留在工作树中。</target>
        </trans-unit>
        <trans-unit id="fa280cd97c17d646b4ce0e60bbbcb27953b34fb3" translate="yes" xml:space="preserve">
          <source>Then you can push both the test and release trees using &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;:</source>
          <target state="translated">然后，您可以使用&lt;a href=&quot;git-push&quot;&gt;git-push [1]推送&lt;/a&gt;测试和发布树：</target>
        </trans-unit>
        <trans-unit id="9015e54306232b9477b76c544780cb6cb29e184c" translate="yes" xml:space="preserve">
          <source>Then you might want a &lt;code&gt;.mailmap&lt;/code&gt; file that looks like:</source>
          <target state="translated">然后，您可能需要一个 &lt;code&gt;.mailmap&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="bdefcc2b7f4d341c71ca424367a0164c209ac375" translate="yes" xml:space="preserve">
          <source>Then you transfer file.bundle to the target machine B. Because this bundle does not require any existing object to be extracted, you can create a new repository on machine B by cloning from it:</source>
          <target state="translated">然后将file.bundle转移到目标机器B上,因为这个bundle不需要提取任何现有的对象,所以你可以在机器B上通过克隆它来创建一个新的仓库。</target>
        </trans-unit>
        <trans-unit id="e826c3727c0c79aa7b30f2352881ef1c5a35f171" translate="yes" xml:space="preserve">
          <source>Then you would define a &quot;filter.indent.clean&quot; and &quot;filter.indent.smudge&quot; configuration in your .git/config to specify a pair of commands to modify the contents of C programs when the source files are checked in (&quot;clean&quot; is run) and checked out (no change is made because the command is &quot;cat&quot;).</source>
          <target state="translated">那么你就在你的.git/config中定义一个 &quot;filter.indent.clean &quot;和 &quot;filter.indent.smudge &quot;的配置,来指定一对命令,以便在源文件检查进来(运行 &quot;clean&quot;)和检查出去(因为命令是 &quot;cat&quot;,所以没有修改)时修改C程序的内容。</target>
        </trans-unit>
        <trans-unit id="c6308f4c83137c8ddf705f0b33927bc3a2a2d3bf" translate="yes" xml:space="preserve">
          <source>Then, make that directory into a Git repository by running &lt;code&gt;git init&lt;/code&gt;, but this time, since its name is not the usual &lt;code&gt;.git&lt;/code&gt;, we do things slightly differently:</source>
          <target state="translated">然后，通过运行 &lt;code&gt;git init&lt;/code&gt; 将该目录放入Git存储库，但这一次，由于其名称不是通常的 &lt;code&gt;.git&lt;/code&gt; ，因此我们做的事情略有不同：</target>
        </trans-unit>
        <trans-unit id="4d45e0228f3dfbda52666260c02f45c435d7f13c" translate="yes" xml:space="preserve">
          <source>Then, use &lt;code&gt;git bisect &amp;lt;term-old&amp;gt;&lt;/code&gt; and &lt;code&gt;git bisect &amp;lt;term-new&amp;gt;&lt;/code&gt; instead of &lt;code&gt;git bisect good&lt;/code&gt; and &lt;code&gt;git bisect bad&lt;/code&gt; to mark commits.</source>
          <target state="translated">然后，使用 &lt;code&gt;git bisect &amp;lt;term-old&amp;gt;&lt;/code&gt; 和 &lt;code&gt;git bisect &amp;lt;term-new&amp;gt;&lt;/code&gt; 代替 &lt;code&gt;git bisect good&lt;/code&gt; 和 &lt;code&gt;git bisect bad&lt;/code&gt; 标记提交。</target>
        </trans-unit>
        <trans-unit id="b100177b4f5d14520d5631ccbd2bc2ff52393e78" translate="yes" xml:space="preserve">
          <source>Then, you run this command:</source>
          <target state="translated">然后,你运行这个命令。</target>
        </trans-unit>
        <trans-unit id="ebbdc2314a6104dc9178c4c9ed7835ad78f84727" translate="yes" xml:space="preserve">
          <source>Then, you would define a &quot;diff.tex.xfuncname&quot; configuration to specify a regular expression that matches a line that you would want to appear as the hunk header &quot;TEXT&quot;. Add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">然后，您将定义&amp;ldquo; diff.tex.xfuncname&amp;rdquo;配置，以指定一个正则表达式，该正则表达式与您希望以粗体标题&amp;ldquo; TEXT&amp;rdquo;出现的行匹配。像这样在您的 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件（或 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 文件）中添加一个部分：</target>
        </trans-unit>
        <trans-unit id="8d94c9456285c171a8f18dcac7b76fd1fccc9ff4" translate="yes" xml:space="preserve">
          <source>There are (number of parents + 1) &lt;code&gt;@&lt;/code&gt; characters in the chunk header for combined diff format.</source>
          <target state="translated">组合式diff格式的块标题中有（父级数+ 1）个 &lt;code&gt;@&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="f7e9cf96a6ce9ed5c513750352c4736c076b5145" translate="yes" xml:space="preserve">
          <source>There are CPP wrapper macros and ifdefs to hide most of these details. See &lt;code&gt;trace2.h&lt;/code&gt; for more details. The following discussion will only describe the simplified forms.</source>
          <target state="translated">有CPP包装器宏和ifdefs隐藏了大多数这些细节。有关更多详细信息，请参见 &lt;code&gt;trace2.h&lt;/code&gt; 。以下讨论将仅描述简化形式。</target>
        </trans-unit>
        <trans-unit id="e4287f1e47cb2bfc1b9e5f25165aef43ceec9d6c" translate="yes" xml:space="preserve">
          <source>There are a few built-in low-level merge drivers defined that can be asked for via the &lt;code&gt;merge&lt;/code&gt; attribute.</source>
          <target state="translated">定义了一些内置的低级合并驱动程序，可以通过 &lt;code&gt;merge&lt;/code&gt; 属性要求它们。</target>
        </trans-unit>
        <trans-unit id="12f3989319ea3c0cba3d029a62ee2c306fd0616b" translate="yes" xml:space="preserve">
          <source>There are a few built-in patterns to make this easier, and &lt;code&gt;tex&lt;/code&gt; is one of them, so you do not have to write the above in your configuration file (you still need to enable this with the attribute mechanism, via &lt;code&gt;.gitattributes&lt;/code&gt;). The following built in patterns are available:</source>
          <target state="translated">有一些内置模式可以简化此过程，而 &lt;code&gt;tex&lt;/code&gt; 是其中之一，因此您不必在配置文件中编写以上内容（您仍然需要通过 &lt;code&gt;.gitattributes&lt;/code&gt; 通过属性机制启用此功能）。可以使用以下内置模式：</target>
        </trans-unit>
        <trans-unit id="336d04ab3583042f88f12edf2d051324b94f62a0" translate="yes" xml:space="preserve">
          <source>There are a few issues to resolve before we can completely switch to Trace2.</source>
          <target state="translated">在我们完全切换到Trace2之前,有几个问题需要解决。</target>
        </trans-unit>
        <trans-unit id="f553cccafe9fdfa62552e6e1af4be573be245c47" translate="yes" xml:space="preserve">
          <source>There are a few special-purpose refs that do not begin with &lt;code&gt;refs/&lt;/code&gt;. The most notable example is &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">有一些特殊用途的ref并非以 &lt;code&gt;refs/&lt;/code&gt; 开头。最著名的例子是 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc9f53378dabd08666f7e5c5af2a717dbbd37e28" translate="yes" xml:space="preserve">
          <source>There are a number of factors which affect how much memory fast-import requires to perform an import. Like critical sections of core Git, fast-import uses its own memory allocators to amortize any overheads associated with malloc. In practice fast-import tends to amortize any malloc overheads to 0, due to its use of large block allocations.</source>
          <target state="translated">有很多因素会影响 fast-import 在执行导入时需要多少内存。和 Git 的核心部分一样,fast-import 使用自己的内存分配器来摊销与 malloc 相关的开销。在实践中,由于使用了大块分配,fast-import 倾向于将所有 malloc 开销摊销为 0。</target>
        </trans-unit>
        <trans-unit id="e0b2b532209e8b05d8ee20f67e782301986fd65a" translate="yes" xml:space="preserve">
          <source>There are also cases where existing indexes written by git versions before 2.17 will reference directories that don&amp;rsquo;t exist anymore, potentially causing many &quot;could not open directory&quot; warnings to be printed on &quot;git status&quot;. These are new warnings for existing issues that were previously silently discarded.</source>
          <target state="translated">在某些情况下，由2.17之前的git版本编写的现有索引将引用不再存在的目录，从而可能导致在&amp;ldquo; git status&amp;rdquo;上显示许多&amp;ldquo;无法打开目录&amp;rdquo;警告。这些是针对以前已被静默丢弃的现有问题的新警告。</target>
        </trans-unit>
        <trans-unit id="aec0acb7fb7522f7c5da2df9b13975842cb9d1be" translate="yes" xml:space="preserve">
          <source>There are also more complex operations that can be performed. But beware that because the patch is applied only to the index and not the working tree, the working tree will appear to &quot;undo&quot; the change in the index. For example, introducing a new line into the index that is in neither the HEAD nor the working tree will stage the new line for commit, but the line will appear to be reverted in the working tree.</source>
          <target state="translated">还可以进行更复杂的操作。但要注意的是,由于补丁只应用于索引而非工作树,工作树会出现 &quot;撤销 &quot;索引中的更改。例如,在索引中引入一个既不在 HEAD 也不在工作树中的新行,会对新行进行阶段性提交,但在工作树中该行会被还原。</target>
        </trans-unit>
        <trans-unit id="a266660a35cd18470141c43d8a3ffa2b3074c06a" translate="yes" xml:space="preserve">
          <source>There are also other situations that cause dangling objects. For example, a &quot;dangling blob&quot; may arise because you did a &lt;code&gt;git add&lt;/code&gt; of a file, but then, before you actually committed it and made it part of the bigger picture, you changed something else in that file and committed that &lt;strong&gt;updated&lt;/strong&gt; thing&amp;mdash;​the old state that you added originally ends up not being pointed to by any commit or tree, so it&amp;rsquo;s now a dangling blob object.</source>
          <target state="translated">还有其他情况会导致物体悬空。例如，由于您对文件进行 &lt;code&gt;git add&lt;/code&gt; ，可能会出现&amp;ldquo;悬空的斑点&amp;rdquo; ，但是，在实际提交该文件并将其作为大图的一部分之前，您更改了该文件中的其他内容并提交了&lt;strong&gt;更新的内容&lt;/strong&gt; -最初添加的旧状态最终没有被任何提交或树指向，因此现在是一个悬空的Blob对象。</target>
        </trans-unit>
        <trans-unit id="232088d916b340ecad3098c72c2ebccbe30b76e5" translate="yes" xml:space="preserve">
          <source>There are also several operations which should be avoided entirely, as they will make the patch impossible to apply:</source>
          <target state="translated">此外,还有几种操作也应完全避免,因为它们会使补丁无法应用。</target>
        </trans-unit>
        <trans-unit id="eeb0752be9462c9bd2e54575f2023419e06b3d3b" translate="yes" xml:space="preserve">
          <source>There are also ways to automate the bisecting process if you have a test script that can tell a good from a bad commit. See &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; for more information about this and other &lt;code&gt;git
bisect&lt;/code&gt; features.</source>
          <target state="translated">如果您的测试脚本可以从错误的提交中分辨出好消息，那么还有其他方法可以自动执行平分过程。有关此功能和其他 &lt;code&gt;git bisect&lt;/code&gt; 功能的更多信息，请参见&lt;a href=&quot;git-bisect&quot;&gt;git-bisect [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="753d0dde7d0dbacd496fb113e3e96e5ea6d9494d" translate="yes" xml:space="preserve">
          <source>There are four different types of objects: &quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;, and &quot;tag&quot;.</source>
          <target state="translated">有四种不同类型的对象。&quot;blob&quot;,&quot;树&quot;,&quot;提交 &quot;和 &quot;标签&quot;。</target>
        </trans-unit>
        <trans-unit id="a3d0232ce28c94288cf502f722ca216e09b8c5b1" translate="yes" xml:space="preserve">
          <source>There are implementations of Git that do not leave usable values in some fields (e.g. JGit); by excluding these fields from the comparison, the &lt;code&gt;minimal&lt;/code&gt; mode may help interoperability when the same repository is used by these other systems at the same time.</source>
          <target state="translated">有一些Git的实现并没有在某些领域（例如JGit）中留下可用的值。通过从比较中排除这些字段， &lt;code&gt;minimal&lt;/code&gt; 模式可以帮助当其他系统同时使用同一存储库时的互操作性。</target>
        </trans-unit>
        <trans-unit id="ac26d523869587e187089ca0cfe8dfa88bde0428" translate="yes" xml:space="preserve">
          <source>There are many more; see the &quot;SPECIFYING REVISIONS&quot; section of the &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; man page for the complete list of ways to name revisions. Some examples:</source>
          <target state="translated">还有更多；有关命名修订的完整方法列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;手册页的&amp;ldquo; SPECIFYING REVISIONS&amp;rdquo;部分。一些例子：</target>
        </trans-unit>
        <trans-unit id="caa64d4f477bb9cc6ae8b8763c8d93ec4bfb0cef" translate="yes" xml:space="preserve">
          <source>There are no facilities for helping users find what unwanted crud they should delete, which means they are much more likely to have incomplete or partial cleanups that sometimes result in confusion and people wasting time trying to understand. (For example, folks tend to just look for big files to delete instead of big directories or extensions, and once they do so, then sometime later folks using the new repository who are going through history will notice a build artifact directory that has some files but not others, or a cache of dependencies (node_modules or similar) which couldn&amp;rsquo;t have ever been functional since it&amp;rsquo;s missing some files.)</source>
          <target state="translated">没有任何工具可以帮助用户找到应该删除的多余杂物，这意味着他们很可能会进行不完全或部分清理，有时会造成混乱，导致人们浪费时间去理解。（例如，人们倾向于只查找要删除的大文件，而不是大目录或扩展名，一旦这样做，那么以后使用新存储库的人们会在历史记录中看到一个构建工件目录，其中包含一些文件但不是其他，或者是依赖项的缓存（node_modules或类似的东西），因为丢失了一些文件，这些缓存本来无法发挥作用。）</target>
        </trans-unit>
        <trans-unit id="ce4a9f9a1026ea763732ff998a2bcfb7b60f26ca" translate="yes" xml:space="preserve">
          <source>There are no public Trace2 data structures.</source>
          <target state="translated">没有公共的Trace2数据结构。</target>
        </trans-unit>
        <trans-unit id="5a1dbdef2a9d4fcde2fec24ad984bfc7ec6f3aa2" translate="yes" xml:space="preserve">
          <source>There are numerous other tools, such as StGit, which exist for the purpose of maintaining a patch series. These are outside of the scope of this manual.</source>
          <target state="translated">还有许多其他的工具,比如StGit,它们是为了维护补丁系列而存在的。这些都不在本手册的范围之内。</target>
        </trans-unit>
        <trans-unit id="306721e74c73edf4b4a1c2554be600724c25d3f0" translate="yes" xml:space="preserve">
          <source>There are other estimates saying that 80% of the cost related to software is about maintenance &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">还有其他估计表明与软件相关的成本中有80％与维护有关&lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7eccee0caa41472aded0ea349d3d3fa4831b32ab" translate="yes" xml:space="preserve">
          <source>There are other real-world examples of using update and post-update hooks found in the Documentation/howto directory.</source>
          <target state="translated">在Documentation/howto目录下还有其他使用更新和更新后钩子的实际例子。</target>
        </trans-unit>
        <trans-unit id="ddc4304f0c733f93eaa36c71971b210be6c86baa" translate="yes" xml:space="preserve">
          <source>There are several built-in formats, and you can define additional formats by setting a pretty.&amp;lt;name&amp;gt; config option to either another format name, or a &lt;code&gt;format:&lt;/code&gt; string, as described below (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Here are the details of the built-in formats:</source>
          <target state="translated">内置的格式有几种，您可以通过将pretty。&amp;lt;name&amp;gt; config选项设置为另一个格式名称或 &lt;code&gt;format:&lt;/code&gt; string 来定义其他格式，如下所述（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。以下是内置格式的详细信息：</target>
        </trans-unit>
        <trans-unit id="172e083c83bf7e6cbde177805c61722f6bdc0777" translate="yes" xml:space="preserve">
          <source>There are some numbers about bugs in general, like a NIST study in 2002 &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt; that said:</source>
          <target state="translated">一般而言，关于错误的数字很多，例如2002年的NIST研究&lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt;说：</target>
        </trans-unit>
        <trans-unit id="1a73feb2f257a54073e6e874ef78ceeefd47d29e" translate="yes" xml:space="preserve">
          <source>There are some subtle differences how the backends behave.</source>
          <target state="translated">后台的表现有一些微妙的差异。</target>
        </trans-unit>
        <trans-unit id="a41ebe77f2eb54fbd4f30714a2e14c8c1d436ea0" translate="yes" xml:space="preserve">
          <source>There are three commands with similar names: &lt;code&gt;git reset&lt;/code&gt;, &lt;code&gt;git restore&lt;/code&gt; and &lt;code&gt;git revert&lt;/code&gt;.</source>
          <target state="translated">有三个名称相似的命令： &lt;code&gt;git reset&lt;/code&gt; ， &lt;code&gt;git restore&lt;/code&gt; 和 &lt;code&gt;git revert&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27e17ed315eeb27fa67bd10d3870c4d2deb8a92d" translate="yes" xml:space="preserve">
          <source>There are three different approaches: use an add-on to turn off line wraps, configure Thunderbird to not mangle patches, or use an external editor to keep Thunderbird from mangling the patches.</source>
          <target state="translated">有三种不同的方法:使用插件关闭行包装,配置Thunderbird不乱打补丁,或者使用外部编辑器来防止Thunderbird乱打补丁。</target>
        </trans-unit>
        <trans-unit id="8c553f5839a8296a42918c5ea6f6a2fcca19fa49" translate="yes" xml:space="preserve">
          <source>There are three main tools that can be used for this:</source>
          <target state="translated">主要有三个工具可以使用。</target>
        </trans-unit>
        <trans-unit id="86e24f426735724adb9ab7ea59c461905251e8e9" translate="yes" xml:space="preserve">
          <source>There are three ways to specify which refs to update on the remote end.</source>
          <target state="translated">有三种方法可以指定在远程端更新哪些refs。</target>
        </trans-unit>
        <trans-unit id="5544b2d42620b4375dbc730230171fe04b9f972b" translate="yes" xml:space="preserve">
          <source>There are two different types of capabilities: normal capabilities, which can be used to convey information or alter the behavior of a request, and commands, which are the core actions that a client wants to perform (fetch, push, etc).</source>
          <target state="translated">能力有两种不同的类型:普通能力和命令,前者可以用来传递信息或改变请求的行为,后者是客户端要执行的核心操作(获取、推送等)。</target>
        </trans-unit>
        <trans-unit id="c2015c03c4c8786233c499c7815e06c17100a16b" translate="yes" xml:space="preserve">
          <source>There are two formats accepted for patch files:</source>
          <target state="translated">补丁文件有两种格式可接受。</target>
        </trans-unit>
        <trans-unit id="9b5e9b84c7e0cf0cc62bfad7ffc7f5a42847bbc1" translate="yes" xml:space="preserve">
          <source>There are two kinds of fixes, discussed in the following subsections:</source>
          <target state="translated">有两种修复方式,在下面的小节中讨论。</target>
        </trans-unit>
        <trans-unit id="afe3df249e404830655fd820b0b8e96397ac9183" translate="yes" xml:space="preserve">
          <source>There are two main tools that can be used to include changes from one branch on another: &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; and &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;.</source>
          <target state="translated">有两个主要工具可用于包括从一个分支到另一个分支的更改：&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;和&lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1432c9def859812f2dcccb492cbe2b422538cffb" translate="yes" xml:space="preserve">
          <source>There are two ways to specify which commits to operate on.</source>
          <target state="translated">有两种方法可以指定对哪些提交进行操作。</target>
        </trans-unit>
        <trans-unit id="04a6eae6f43fc050171fa2270096884eaba0fee3" translate="yes" xml:space="preserve">
          <source>There is a difference between listing multiple &amp;lt;refspec&amp;gt; directly on &lt;em&gt;git pull&lt;/em&gt; command line and having multiple &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; entries in your configuration for a &amp;lt;repository&amp;gt; and running a &lt;em&gt;git pull&lt;/em&gt; command without any explicit &amp;lt;refspec&amp;gt; parameters. &amp;lt;refspec&amp;gt;s listed explicitly on the command line are always merged into the current branch after fetching. In other words, if you list more than one remote ref, &lt;em&gt;git pull&lt;/em&gt; will create an Octopus merge. On the other hand, if you do not list any explicit &amp;lt;refspec&amp;gt; parameter on the command line, &lt;em&gt;git pull&lt;/em&gt; will fetch all the &amp;lt;refspec&amp;gt;s it finds in the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; configuration and merge only the first &amp;lt;refspec&amp;gt; found into the current branch. This is because making an Octopus from remote refs is rarely done, while keeping track of multiple remote heads in one-go by fetching more than one is often useful.</source>
          <target state="translated">直接在&lt;em&gt;git pull&lt;/em&gt;命令行上列出多个&amp;lt; &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; &amp;gt;和在配置中为&amp;lt;repository&amp;gt;获取多个remote。&amp;lt;repository&amp;gt; .fetch条目，以及运行不带任何显式&amp;lt;refspec&amp;gt;参数的&lt;em&gt;git pull&lt;/em&gt;命令之间有区别。在命令行中明确列出的&amp;lt;refspec&amp;gt;总是在获取后合并到当前分支中。换句话说，如果您列出多个远程引用，则&lt;em&gt;git pull&lt;/em&gt;将创建一个八达通合并。另一方面，如果未在命令行上列出任何显式的&amp;lt;refspec&amp;gt;参数，则&lt;em&gt;git pull&lt;/em&gt;将获取在 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 找到的所有&amp;lt; refspec&amp;gt;。&amp;lt;repository&amp;gt; .fetch配置并仅将找到的第一个&amp;lt;refspec&amp;gt;合并到当前分支中。这是因为很少用远程引用来制作章鱼，而通过获取多个来一次跟踪多个远程头通常是有用的。</target>
        </trans-unit>
        <trans-unit id="08d27e369ae02f07111163548604defe0fd7ba02" translate="yes" xml:space="preserve">
          <source>There is a fourth official branch that is used slightly differently:</source>
          <target state="translated">还有第四个官科,使用方法略有不同。</target>
        </trans-unit>
        <trans-unit id="3ab0818052937d36eff9b5a2767bc99b339b1151" translate="yes" xml:space="preserve">
          <source>There is a script in contrib/thunderbird-patch-inline which can help you include patches with Thunderbird in an easy way. To use it, do the steps above and then use the script as the external editor.</source>
          <target state="translated">在 contrib/thunderbird-patch-inline 中有一个脚本,它可以帮助你以一种简单的方式加入 Thunderbird 的补丁。要使用它,请执行上面的步骤,然后使用该脚本作为外部编辑器。</target>
        </trans-unit>
        <trans-unit id="1232149fc68bcd969b013f8dcdb8f804dc24a0d6" translate="yes" xml:space="preserve">
          <source>There is a tradeoff of course: merges require a more careful branch management. The following subsections discuss the important points.</source>
          <target state="translated">当然有一个权衡:合并需要更细致的分支机构管理。以下各小节将讨论重要的几点。</target>
        </trans-unit>
        <trans-unit id="dad64266cc32a47cdf74ec10317455f91f86159c" translate="yes" xml:space="preserve">
          <source>There is already a project called BBChop created by Ealdwulf Wuffinga on Github that does something like that using Bayesian Search Theory &lt;a href=&quot;#9&quot;&gt;[9]&lt;/a&gt;:</source>
          <target state="translated">Ealdwulf Wuffinga在Github上已经有一个名为BBChop的项目，该项目使用贝叶斯搜索理论&lt;a href=&quot;#9&quot;&gt;[9]进行&lt;/a&gt;类似的操作：</target>
        </trans-unit>
        <trans-unit id="72c8cb7314c2d9e687a4188f4607320887a3abaf" translate="yes" xml:space="preserve">
          <source>There is also a deprecated &lt;code&gt;[section.subsection]&lt;/code&gt; syntax. With this syntax, the subsection name is converted to lower-case and is also compared case sensitively. These subsection names follow the same restrictions as section names.</source>
          <target state="translated">还有不推荐使用的 &lt;code&gt;[section.subsection]&lt;/code&gt; 语法。使用此语法，小节名称将转换为小写，并且还会区分大小写进行比较。这些小节名称遵循与节名称相同的限制。</target>
        </trans-unit>
        <trans-unit id="562a7aac41f0a6a2b8bd94c80ba1df49ae8c2861" translate="yes" xml:space="preserve">
          <source>There is also an alternate -z format recommended for machine parsing. In that format, the status field is the same, but some other things change. First, the &lt;code&gt;-&amp;gt;&lt;/code&gt; is omitted from rename entries and the field order is reversed (e.g &lt;code&gt;from -&amp;gt; to&lt;/code&gt; becomes &lt;code&gt;to from&lt;/code&gt;). Second, a NUL (ASCII 0) follows each filename, replacing space as a field separator and the terminating newline (but a space still separates the status field from the first filename). Third, filenames containing special characters are not specially formatted; no quoting or backslash-escaping is performed.</source>
          <target state="translated">建议使用另一种-z格式进行机器解析。在这种格式下，状态字段是相同的，但其他一些内容会发生变化。首先，在重命名条目中省略了 &lt;code&gt;-&amp;gt;&lt;/code&gt; ，并且字段顺序相反（例如， &lt;code&gt;from -&amp;gt; to&lt;/code&gt; 变为 &lt;code&gt;to from&lt;/code&gt; ）。其次，每个文件名后面都有一个NUL（ASCII 0），用空格代替字段分隔符和结尾的换行符（但空格仍将状态字段与第一个文件名分隔开）。第三，包含特殊字符的文件名不是特殊格式的。不执行引号或反斜杠转义。</target>
        </trans-unit>
        <trans-unit id="23b53316aea0dd64f8f21ea0eae539235bf45a74" translate="yes" xml:space="preserve">
          <source>There is also an option to sort by versions, this can be done by using the fieldname &lt;code&gt;version:refname&lt;/code&gt; or its alias &lt;code&gt;v:refname&lt;/code&gt;.</source>
          <target state="translated">还有一个按版本排序的选项，可以通过使用字段名 &lt;code&gt;version:refname&lt;/code&gt; 或其别名 &lt;code&gt;v:refname&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="490f0c7223e032436f3ed74187899d6766a21bb5" translate="yes" xml:space="preserve">
          <source>There is another common situation where you may encounter non-fast-forward rejection when you try to push, and it is possible even when you are pushing into a repository nobody else pushes into. After you push commit A yourself (in the first picture in this section), replace it with &quot;git commit --amend&quot; to produce commit B, and you try to push it out, because forgot that you have pushed A out already. In such a case, and only if you are certain that nobody in the meantime fetched your earlier commit A (and started building on top of it), you can run &quot;git push --force&quot; to overwrite it. In other words, &quot;git push --force&quot; is a method reserved for a case where you do mean to lose history.</source>
          <target state="translated">还有一种常见的情况是,当你尝试推送时,可能会遇到非快进式的拒绝,即使是你推送到一个没有人推送的仓库里,也有可能出现这种情况。你自己推送了提交A后(本节第一张图),用 &quot;git commit --amend &quot;替换成提交B,然后你想推送出去,因为忘了你已经推送了A。在这种情况下,只有当你确定在此期间没有人取走你之前的提交A(并在它的基础上开始构建),你可以运行 &quot;git push --force &quot;来覆盖它。换句话说,&quot;git push --force &quot;是一种保留给您确实要丢失历史记录的情况的方法。</target>
        </trans-unit>
        <trans-unit id="76938def2c927fda8d1c815e17291d57380d4a8a" translate="yes" xml:space="preserve">
          <source>There is another tweak in the bisection algorithm that has not been described in the &quot;bisection algorithm&quot; above.</source>
          <target state="translated">在二分法算法中还有一个调整,上面的 &quot;二分法算法 &quot;中没有介绍。</target>
        </trans-unit>
        <trans-unit id="6cd697be600e420b39bb68cc6d967c4ceca70af4" translate="yes" xml:space="preserve">
          <source>There is no option for &lt;code&gt;git rm&lt;/code&gt; to remove from the index only the paths that have disappeared from the filesystem. However, depending on the use case, there are several ways that can be done.</source>
          <target state="translated">没有为没有选项 &lt;code&gt;git rm&lt;/code&gt; 从索引中只有那些从文件系统中消失的路径删除。但是，根据使用情况，有几种方法可以完成。</target>
        </trans-unit>
        <trans-unit id="60bcaa98facce6fa9b4916fcb4556840549eaf70" translate="yes" xml:space="preserve">
          <source>There is no other restriction on the replaced and replacement objects. Merge commits can be replaced by non-merge commits and vice versa.</source>
          <target state="translated">对被替换和替换对象没有其他限制。合并提交可以被非合并提交所取代,反之亦然。</target>
        </trans-unit>
        <trans-unit id="5b920fe2651a1acef3f4de11b5f87d418bf37e32" translate="yes" xml:space="preserve">
          <source>There is now a new commit &lt;code&gt;e&lt;/code&gt;, but it is referenced only by &lt;code&gt;HEAD&lt;/code&gt;. We can of course add yet another commit in this state:</source>
          <target state="translated">现在有一个新的提交 &lt;code&gt;e&lt;/code&gt; ，但仅由 &lt;code&gt;HEAD&lt;/code&gt; 引用。我们当然可以在这种状态下添加另一个提交：</target>
        </trans-unit>
        <trans-unit id="e84a3494173a3e4e1765afc114a7bb8588db5e4e" translate="yes" xml:space="preserve">
          <source>There is one special case not mentioned above, which is treated differently. Normally, a merge results in a merge commit, with two parents, one pointing at each of the two lines of development that were merged.</source>
          <target state="translated">有一种特殊的情况上面没有提到,它的处理方式是不同的。通常情况下,合并的结果是一个合并提交,有两个父节点,一个指向被合并的两条开发线。</target>
        </trans-unit>
        <trans-unit id="9c233ac02212216497063926a3cd425b73c1b106" translate="yes" xml:space="preserve">
          <source>There may be other problems when using &lt;code&gt;git rev-list&lt;/code&gt; related to pending objects.</source>
          <target state="translated">使用与待处理对象相关的 &lt;code&gt;git rev-list&lt;/code&gt; 时，可能还会有其他问题。</target>
        </trans-unit>
        <trans-unit id="3cc97d3b58e95d007d294ed252208117b7ea36ad" translate="yes" xml:space="preserve">
          <source>There was a discussion at one point on the linux kernel mailing list of whether it was ok to always ask end user to bisect, and very good points were made to support the point of view that it is ok.</source>
          <target state="translated">在linux内核邮件列表上曾经讨论过是否可以总是要求终端用户进行二分法,并且提出了非常好的观点,支持这样做的观点。</target>
        </trans-unit>
        <trans-unit id="e31f2056d77b9761665b1e39804c963e7c7e3f73" translate="yes" xml:space="preserve">
          <source>Therefore if the refspec for the remote includes e.g. &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt;, or you manually run e.g. &lt;code&gt;git fetch
--prune &amp;lt;name&amp;gt; &quot;refs/tags/*:refs/tags/*&quot;&lt;/code&gt; it won&amp;rsquo;t be stale remote tracking branches that are deleted, but any local tag that doesn&amp;rsquo;t exist on the remote.</source>
          <target state="translated">因此，如果远程的refspec包括例如 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; ，或者您手动运行例如 &lt;code&gt;git fetch --prune &amp;lt;name&amp;gt; &quot;refs/tags/*:refs/tags/*&quot;&lt;/code&gt; 它将不会过期的远程跟踪分支将被删除，但是远程上不存在的任何本地标记。</target>
        </trans-unit>
        <trans-unit id="22e33781a4f63d74c967572b3d2d5742f6f5b3cf" translate="yes" xml:space="preserve">
          <source>These are applied in sequence. The set of filepairs &lt;code&gt;git diff-*&lt;/code&gt; commands find are used as the input to diffcore-break, and the output from diffcore-break is used as the input to the next transformation. The final result is then passed to the output routine and generates either diff-raw format (see Output format sections of the manual for &lt;code&gt;git diff-*&lt;/code&gt; commands) or diff-patch format.</source>
          <target state="translated">这些按顺序应用。找到的文件对 &lt;code&gt;git diff-*&lt;/code&gt; 命令集用作diffcore-break的输入，而diffcore-break的输出用作下一个转换的输入。然后将最终结果传递到输出例程，并生成diff-raw格式（有关 &lt;code&gt;git diff-*&lt;/code&gt; 命令，请参见手册的&amp;ldquo;输出格式&amp;rdquo;部分）或diff-patch格式。</target>
        </trans-unit>
        <trans-unit id="5e4c5d2d8cb413a7bc102a12d4b32266eb5dffbd" translate="yes" xml:space="preserve">
          <source>These are concerned with describing the specific Git command after the command line, config, and environment are inspected. e.g: &lt;code&gt;void trace2_cmd_name(const char *name)&lt;/code&gt;, &lt;code&gt;void trace2_cmd_mode(const char *mode)&lt;/code&gt;.</source>
          <target state="translated">这些与检查命令行，配置和环境之后描述特定的Git命令有关。例如： &lt;code&gt;void trace2_cmd_name(const char *name)&lt;/code&gt; ， &lt;code&gt;void trace2_cmd_mode(const char *mode)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd918e1aed68e545e545890a5d457bd39124acbb" translate="yes" xml:space="preserve">
          <source>These are concerned with recording performance data over regions or spans of code. e.g: &lt;code&gt;void trace2_region_enter(const char *category, const char *label, const struct repository *repo)&lt;/code&gt;.</source>
          <target state="translated">这些与在代码的区域或跨度上记录性能数据有关。例如： &lt;code&gt;void trace2_region_enter(const char *category, const char *label, const struct repository *repo)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10ea7c6e4b3ea51596f6b19ba236a57b5e812041" translate="yes" xml:space="preserve">
          <source>These are concerned with the lifetime of the overall git process. e.g: &lt;code&gt;void trace2_initialize_clock()&lt;/code&gt;, &lt;code&gt;void trace2_initialize()&lt;/code&gt;, &lt;code&gt;int trace2_is_enabled()&lt;/code&gt;, &lt;code&gt;void trace2_cmd_start(int argc, const char **argv)&lt;/code&gt;.</source>
          <target state="translated">这些与整个git过程的生命周期有关。例如： &lt;code&gt;void trace2_initialize_clock()&lt;/code&gt; ， &lt;code&gt;void trace2_initialize()&lt;/code&gt; ， &lt;code&gt;int trace2_is_enabled()&lt;/code&gt; ， &lt;code&gt;void trace2_cmd_start(int argc, const char **argv)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3dce3473c941e3b3b27a31ac8449a2f1991a75d0" translate="yes" xml:space="preserve">
          <source>These are concerned with the various spawned child processes, including shell scripts, git commands, editors, pagers, and hooks.</source>
          <target state="translated">这些涉及到各种产卵的子进程,包括shell脚本、git命令、编辑器、分页器和钩子。</target>
        </trans-unit>
        <trans-unit id="64d6caf87f558c78a882445d71ea9cd47be32d78" translate="yes" xml:space="preserve">
          <source>These are internal helper commands used by other commands; end users typically do not use them directly.</source>
          <target state="translated">这些都是其他命令使用的内部辅助命令,最终用户一般不会直接使用它们。</target>
        </trans-unit>
        <trans-unit id="14e40973cf60a547a4fee511ff95c4f84a31a06f" translate="yes" xml:space="preserve">
          <source>These are only used with the &lt;code&gt;dcommit&lt;/code&gt; and &lt;code&gt;rebase&lt;/code&gt; commands.</source>
          <target state="translated">这些仅与 &lt;code&gt;dcommit&lt;/code&gt; 和 &lt;code&gt;rebase&lt;/code&gt; 命令一起使用。</target>
        </trans-unit>
        <trans-unit id="1f4226446a769c76931ca392e2a09f31777b3654" translate="yes" xml:space="preserve">
          <source>These are optional command-line options for init. Each of these flags can point to a relative repository path (--tags=project/tags) or a full url (--tags=https://foo.org/project/tags). You can specify more than one --tags and/or --branches options, in case your Subversion repository places tags or branches under multiple paths. The option --stdlayout is a shorthand way of setting trunk,tags,branches as the relative paths, which is the Subversion default. If any of the other options are given as well, they take precedence.</source>
          <target state="translated">这些都是init的可选命令行选项,它们可以指向相对仓库路径(-tags=project/tags)或完整的url(-tags=)。每一个标志都可以指向一个相对的版本库路径 (--tags=project/tags)或一个完整的 URL (--tagshttps://foo.org/project/tags)。你可以指定多个 --tags 和/或 --branches 选项,以防你的 Subversion 仓库将标签或分支放在多个路径下。选项 --stdlayout 是将 trunk,tags,branches 设置为相对路径的速记方式,这是 Subversion 的默认值。如果同时给出了其他选项,则它们优先。</target>
        </trans-unit>
        <trans-unit id="ef89fe03d8c6b725e4e01a5ddca75169500d3912" translate="yes" xml:space="preserve">
          <source>These attributes affect how the contents stored in the repository are copied to the working tree files when commands such as &lt;code&gt;git switch&lt;/code&gt;, &lt;code&gt;git checkout&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; run. They also affect how Git stores the contents you prepare in the working tree in the repository upon &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">当运行诸如 &lt;code&gt;git switch&lt;/code&gt; ， &lt;code&gt;git checkout&lt;/code&gt; 和 &lt;code&gt;git merge&lt;/code&gt; 之类的命令时，这些属性影响存储在存储库中的内容如何复制到工作树文件中。它们还会影响 &lt;code&gt;git add&lt;/code&gt; 和 &lt;code&gt;git commit&lt;/code&gt; 时Git如何将您准备的内容存储在存储库中的工作树中。</target>
        </trans-unit>
        <trans-unit id="1e36f59cc4fba5296689c97860f8ef3c808cbf54" translate="yes" xml:space="preserve">
          <source>These can be easily kept up to date using &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;可以很容易地使它们保持最新状态。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
