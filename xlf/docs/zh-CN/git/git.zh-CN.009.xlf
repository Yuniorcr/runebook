<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="172ca906089028fc890c646e25bab698db638084" translate="yes" xml:space="preserve">
          <source>Some functions have a &lt;code&gt;_fl()&lt;/code&gt; suffix to indicate that they take &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line-number&lt;/code&gt; arguments.</source>
          <target state="translated">某些函数具有 &lt;code&gt;_fl()&lt;/code&gt; 后缀，以指示它们采用 &lt;code&gt;file&lt;/code&gt; 和 &lt;code&gt;line-number&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="cf5b41401ecbf41c583b9f31bc11f9978bf853cb" translate="yes" xml:space="preserve">
          <source>Some functions have a &lt;code&gt;_printf_fl()&lt;/code&gt; suffix to indicate that they also take a varargs argument.</source>
          <target state="translated">某些函数具有 &lt;code&gt;_printf_fl()&lt;/code&gt; 后缀，以指示它们也采用varargs参数。</target>
        </trans-unit>
        <trans-unit id="c20fab9f2e759692fa04bbce7cef5cc908557231" translate="yes" xml:space="preserve">
          <source>Some functions have a &lt;code&gt;_va_fl()&lt;/code&gt; suffix to indicate that they also take a &lt;code&gt;va_list&lt;/code&gt; argument.</source>
          <target state="translated">某些函数具有 &lt;code&gt;_va_fl()&lt;/code&gt; 后缀，以指示它们也带有 &lt;code&gt;va_list&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="eba90c7cd2e8efb76a00a6ef6fd10ba0e6c2d355" translate="yes" xml:space="preserve">
          <source>Some improvements to the algorithms inside &quot;git bisect&quot; are possible and some new features could help in some cases, but overall &quot;git bisect&quot; works already very well, is used a lot, and is already very useful. To back up that last claim, let&amp;rsquo;s give the final word to Ingo Molnar when he was asked by the author how much time does he think &quot;git bisect&quot; saves him when he uses it:</source>
          <target state="translated">可以对&amp;ldquo; git bisect&amp;rdquo;内部的算法进行一些改进，并且某些情况下可以使用一些新功能，但是总体上，&amp;ldquo; git bisect&amp;rdquo;已经很好地工作了，使用了很多，并且已经非常有用。为了支持最后一个要求，让我们在作者问Ingo Molnar时说最后一句话，他认为使用git bisect可以节省多少时间：</target>
        </trans-unit>
        <trans-unit id="051a4238025a126fd35cea3d27808e1a33c19d81" translate="yes" xml:space="preserve">
          <source>Some key/value pairs are common to all events and some are event-specific.</source>
          <target state="translated">有些键/值对是所有事件共有的,有些则是特定事件。</target>
        </trans-unit>
        <trans-unit id="171887e25dc7a6bd359791fb5478731797724aa1" translate="yes" xml:space="preserve">
          <source>Some malformed strings may be accepted as valid dates. In some of these cases Git will still be able to obtain the correct date from the malformed string. There are also some types of malformed strings which Git will parse wrong, and yet consider valid. Seriously malformed strings will be rejected.</source>
          <target state="translated">有些畸形的字符串可能会被接受为有效的日期。在这种情况下,Git仍然可以从畸形的字符串中获得正确的日期。也有一些类型的畸形字符串,Git会将其解析为错误的,但仍然认为是有效的。严重畸形的字符串将被拒绝。</target>
        </trans-unit>
        <trans-unit id="783d5fee630f867a836aab31a09a1120dfa61932" translate="yes" xml:space="preserve">
          <source>Some more interesting work has been done in the upstream project, and &lt;code&gt;origin&lt;/code&gt; has advanced:</source>
          <target state="translated">在上游项目中完成了一些更有趣的工作，并且 &lt;code&gt;origin&lt;/code&gt; 有所发展：</target>
        </trans-unit>
        <trans-unit id="f3d95fe16308405a40d9c1590f99de534764e169" translate="yes" xml:space="preserve">
          <source>Some old repositories have tags without a tagger. The fast-import protocol was pretty strict about that, and did not allow that. So fake a tagger to be able to fast-import the output.</source>
          <target state="translated">一些老仓库的标签没有标签器。快速导入协议对这一点要求很严格,不允许这样。所以伪造一个标签器,才能快速导入输出。</target>
        </trans-unit>
        <trans-unit id="5f1322ce775635ebc0b366d585bc7dbdc07c75d2" translate="yes" xml:space="preserve">
          <source>Some optional features and policies</source>
          <target state="translated">一些可选的功能和政策</target>
        </trans-unit>
        <trans-unit id="184f39eeceeacf637176614462d419ff5408c775" translate="yes" xml:space="preserve">
          <source>Some other SCM systems let the user create a tag from multiple files which are not from the same commit/changeset. Or to create tags which are a subset of the files available in the repository.</source>
          <target state="translated">其他一些 SCM 系统允许用户从多个文件中创建一个标签,这些文件不是来自同一个提交/变更集。或者创建标签,这些标签是版本库中可用文件的一个子集。</target>
        </trans-unit>
        <trans-unit id="e0986df979670ad50493b8dd4aeecf085f900c18" translate="yes" xml:space="preserve">
          <source>Some other commands that also work on files in the working tree and/or in the index can take &lt;code&gt;--staged&lt;/code&gt; and/or &lt;code&gt;--worktree&lt;/code&gt;.</source>
          <target state="translated">其他一些对工作树和/或索引中的文件也起作用的命令可以采用 &lt;code&gt;--staged&lt;/code&gt; 和/或 &lt;code&gt;--worktree&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e825ac68d84922615f20a915d3c1eb9e9c71680" translate="yes" xml:space="preserve">
          <source>Some placeholders may depend on other options given to the revision traversal engine. For example, the &lt;code&gt;%g*&lt;/code&gt; reflog options will insert an empty string unless we are traversing reflog entries (e.g., by &lt;code&gt;git log -g&lt;/code&gt;). The &lt;code&gt;%d&lt;/code&gt; and &lt;code&gt;%D&lt;/code&gt; placeholders will use the &quot;short&quot; decoration format if &lt;code&gt;--decorate&lt;/code&gt; was not already provided on the command line.</source>
          <target state="translated">一些占位符可能取决于赋予修订遍历引擎的其他选项。例如， &lt;code&gt;%g*&lt;/code&gt; reflog选项将插入一个空字符串，除非我们遍历reflog条目（例如，通过 &lt;code&gt;git log -g&lt;/code&gt; ）。的 &lt;code&gt;%d&lt;/code&gt; 和 &lt;code&gt;%D&lt;/code&gt; 占位符将使用&amp;ldquo;短&amp;rdquo;装饰格式如果 &lt;code&gt;--decorate&lt;/code&gt; 是不是已经提供的命令行。</target>
        </trans-unit>
        <trans-unit id="b90f1a06edbdea1cb1ea924bb534bf207be4c8cd" translate="yes" xml:space="preserve">
          <source>Some special diff options allow diffing the working directory against any of these stages:</source>
          <target state="translated">一些特殊的diff选项允许对这些阶段中的任何阶段进行工作目录的diff。</target>
        </trans-unit>
        <trans-unit id="379a99bc56f81a74676a3582df5345ad077361ae" translate="yes" xml:space="preserve">
          <source>Some workflows require that one or more branches of development on one machine be replicated on another machine, but the two machines cannot be directly connected, and therefore the interactive Git protocols (git, ssh, http) cannot be used.</source>
          <target state="translated">有些工作流程需要将一台机器上的一个或多个开发分支复制到另一台机器上,但两台机器不能直接连接,因此不能使用交互式Git协议(git、ssh、http)。</target>
        </trans-unit>
        <trans-unit id="4efa70b7553b32aea10bdaaf89e5cdb60eb1465e" translate="yes" xml:space="preserve">
          <source>Somebody asks you to pull, and the changes sound worthy of merging.</source>
          <target state="translated">有人让你拉,这些变化听起来值得合并。</target>
        </trans-unit>
        <trans-unit id="75bb6efa7b5bca1608dd13b1f00b4537d22f7537" translate="yes" xml:space="preserve">
          <source>Somebody hands you a copy of a file, and asks which commits modified a file such that it contained the given content either before or after the commit. You can find out with this:</source>
          <target state="translated">有人递给你一个文件的副本,并询问哪些提交修改了文件,使其在提交前或提交后包含了给定的内容。你可以用这个来了解。</target>
        </trans-unit>
        <trans-unit id="7ef51555538cdc5f80247933eec8146e7de62402" translate="yes" xml:space="preserve">
          <source>Someone can do a history rewrite, realize they messed up, restore from the backups in refs/original/, and then redo their git-filter-branch command. (The backup in refs/original/ is not a real backup; it dereferences tags first.)</source>
          <target state="translated">有人可以做一个历史重写,意识到自己搞砸了,从 refs/original/的备份中恢复,然后重做 git-filter-branch 命令。(refs/original/中的备份并不是真正的备份,它是先引用标签。)</target>
        </trans-unit>
        <trans-unit id="8b7568eaac49251d7ecfa53edc4f2d50e2427376" translate="yes" xml:space="preserve">
          <source>Someone can have a set of &quot;working and tested filters&quot; which they document or provide to a coworker, who then runs them on a different OS where the same commands are not working/tested (some examples in the git-filter-branch manpage are also affected by this). BSD vs. GNU userland differences can really bite. If lucky, error messages are spewed. But just as likely, the commands either don&amp;rsquo;t do the filtering requested, or silently corrupt by making some unwanted change. The unwanted change may only affect a few commits, so it&amp;rsquo;s not necessarily obvious either. (The fact that problems won&amp;rsquo;t necessarily be obvious means they are likely to go unnoticed until the rewritten history is in use for quite a while, at which point it&amp;rsquo;s really hard to justify another flag-day for another rewrite.)</source>
          <target state="translated">某人可以拥有一组&amp;ldquo;工作和经过测试的过滤器&amp;rdquo;，他们可以记录这些文件或提供给同事，然后由他们在无法运行/测试相同命令的其他OS上运行它们（git-filter-branch联机帮助页中的一些示例为也受此影响）。 BSD与GNU用户领域的差异确实可以引起人们的关注。如果幸运的话，会出现错误消息。但是很有可能，这些命令要么不执行请求的过滤，要么通过进行一些不必要的更改而无声地破坏。不需要的更改可能只影响一些提交，因此也不一定很明显。 （事实上​​，问题不一定会很明显，这意味着在重写的历史记录使用了相当长的一段时间后，问题很可能不会被注意到，在这一点上，很难为另一个重写日辩解是很困难的。）</target>
        </trans-unit>
        <trans-unit id="f6f28be0bc03c39873befbc10c61feb3cd6f09d9" translate="yes" xml:space="preserve">
          <source>Sometime later when enough time has passed and testing done, you can pull the same branch into the &lt;code&gt;release&lt;/code&gt; tree ready to go upstream. This is where you see the value of keeping each patch (or patch series) in its own branch. It means that the patches can be moved into the &lt;code&gt;release&lt;/code&gt; tree in any order.</source>
          <target state="translated">稍后，经过足够的时间并完成测试后，您可以将同一分支拉入 &lt;code&gt;release&lt;/code&gt; 树中，以准备上游。在这里，您可以看到将每个修补程序（或修补程序系列）保留在自己的分支中的价值。这意味着补丁可以以任何顺序移入 &lt;code&gt;release&lt;/code&gt; 树。</target>
        </trans-unit>
        <trans-unit id="f3de282e58de418da244c9ed4c8dec9bb8a8937a" translate="yes" xml:space="preserve">
          <source>Sometimes it happens that the current state cannot be tested, for example if it does not compile because there was a bug preventing it at that time. This is what the special exit code 125 is for. It tells &quot;git bisect run&quot; that the current commit should be marked as untestable and that another one should be chosen and checked out.</source>
          <target state="translated">有时会发生无法测试当前状态的情况,比如当时有bug阻止了它的编译,所以无法编译。这就是特殊的退出代码125的作用。它告诉 &quot;git bisect run&quot;,当前的提交应该被标记为不可测试,应该选择另一个提交进行检查。</target>
        </trans-unit>
        <trans-unit id="ab0983c0f5d9e7bd28c3834685713747f93c2919" translate="yes" xml:space="preserve">
          <source>Sometimes it is desirable to see the diff of a text-converted version of some binary files. For example, a word processor document can be converted to an ASCII text representation, and the diff of the text shown. Even though this conversion loses some information, the resulting diff is useful for human viewing (but cannot be applied directly).</source>
          <target state="translated">有时,人们希望看到一些二进制文件的文本转换版本的差异。例如,一个文字处理文件可以被转换为ASCII文本表示,并显示文本的差异。尽管这种转换会损失一些信息,但产生的diff对人类的观察还是很有用的(但不能直接应用)。</target>
        </trans-unit>
        <trans-unit id="a66c6ccc61eb22dbd8fb180270521a352bb26eb7" translate="yes" xml:space="preserve">
          <source>Sometimes the thing fixed in b.2. cannot be amended to the not-quite perfect commit it fixes, because that commit is buried deeply in a patch series. That is exactly what interactive rebase is for: use it after plenty of &quot;a&quot;s and &quot;b&quot;s, by rearranging and editing commits, and squashing multiple commits into one.</source>
          <target state="translated">有时在 b.2.中修复的东西不能被修改成它所修复的不太完美的提交,因为那个提交被深深地埋在补丁系列中。这正是交互式重垒的作用:在大量的 &quot;a &quot;和 &quot;b &quot;之后,通过重新安排和编辑提交,将多个提交压成一个。</target>
        </trans-unit>
        <trans-unit id="7d8c42c4820860471a909b97a129a9232304c94a" translate="yes" xml:space="preserve">
          <source>Sometimes what you want instead is a set of patches; for this you can use &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;:</source>
          <target state="translated">有时，您需要的是一组补丁。为此，您可以使用&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="abb396ee2420ccad29c3b6a0f48213b60cfe8e4f" translate="yes" xml:space="preserve">
          <source>Sometimes you are not looking for the commit that introduced a breakage, but rather for a commit that caused a change between some other &quot;old&quot; state and &quot;new&quot; state. For example, you might be looking for the commit that introduced a particular fix. Or you might be looking for the first commit in which the source-code filenames were finally all converted to your company&amp;rsquo;s naming standard. Or whatever.</source>
          <target state="translated">有时，您不是在寻找导致损坏的提交，而是在导致其他&amp;ldquo;旧&amp;rdquo;状态和&amp;ldquo;新&amp;rdquo;状态之间发生更改的提交。例如，您可能正在寻找引入了特定修复程序的提交。或者，您可能正在寻找第一次提交，其中最终将源代码文件名全部转换为公司的命名标准。管他呢。</target>
        </trans-unit>
        <trans-unit id="709d16fb784b306222cc9b75f2da6965fd037ce9" translate="yes" xml:space="preserve">
          <source>Sometimes you are only interested in parts of the history, for example the commits modifying a particular &amp;lt;path&amp;gt;. But there are two parts of &lt;code&gt;History Simplification&lt;/code&gt;, one part is selecting the commits and the other is how to do it, as there are various strategies to simplify the history.</source>
          <target state="translated">有时您只对历史的某些部分感兴趣，例如，修改特定&amp;lt;path&amp;gt;的提交。但是 &lt;code&gt;History Simplification&lt;/code&gt; 有两个部分，一个是选择提交，另一个是如何执行，因为有多种策略可以简化历史。</target>
        </trans-unit>
        <trans-unit id="3329bd14db714a1ebe54846da15c65686d4c297b" translate="yes" xml:space="preserve">
          <source>Sometimes you may wish to create a new branch &lt;code&gt;without&lt;/code&gt; actually checking it out and switching to it. If so, just use the command</source>
          <target state="translated">有时您可能希望创建一个新分支， &lt;code&gt;without&lt;/code&gt; 实际签出并切换到该分支。如果是这样，只需使用命令</target>
        </trans-unit>
        <trans-unit id="9e0d77cc540587abb285618787352fd870a1def8" translate="yes" xml:space="preserve">
          <source>Sometimes you want to edit a commit deeper in your history. One approach is to use &lt;code&gt;git format-patch&lt;/code&gt; to create a series of patches and then reset the state to before the patches:</source>
          <target state="translated">有时您想在历史记录中更深入地编辑提交。一种方法是使用 &lt;code&gt;git format-patch&lt;/code&gt; 创建一系列补丁，然后将状态重置为补丁之前：</target>
        </trans-unit>
        <trans-unit id="17cc71829facf5cb6a6b321a2cbf6c64d2bc06da" translate="yes" xml:space="preserve">
          <source>Sometimes you would need to override a setting of an attribute for a path to &lt;code&gt;Unspecified&lt;/code&gt; state. This can be done by listing the name of the attribute prefixed with an exclamation point &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">有时，您需要覆盖到 &lt;code&gt;Unspecified&lt;/code&gt; 状态的路径的属性设置。这可以通过列出以感叹号为前缀的属性名称来完成 &lt;code&gt;!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18f66cee3089e3b2788a7d42c7fbfe71e8e6eab6" translate="yes" xml:space="preserve">
          <source>Sometimes, more than one builtin is contained in one source file. For example, &lt;code&gt;cmd_whatchanged()&lt;/code&gt; and &lt;code&gt;cmd_log()&lt;/code&gt; both reside in &lt;code&gt;builtin/log.c&lt;/code&gt;, since they share quite a bit of code. In that case, the commands which are &lt;code&gt;not&lt;/code&gt; named like the &lt;code&gt;.c&lt;/code&gt; file in which they live have to be listed in &lt;code&gt;BUILT_INS&lt;/code&gt; in the &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">有时，一个源文件中包含多个内置文件。例如， &lt;code&gt;cmd_whatchanged()&lt;/code&gt; 和 &lt;code&gt;cmd_log()&lt;/code&gt; 都驻留在 &lt;code&gt;builtin/log.c&lt;/code&gt; ，因为它们共享了很多代码。在这种情况下， &lt;code&gt;not&lt;/code&gt; 命名的命令（如它们所在的 &lt;code&gt;.c&lt;/code&gt; 文件）必须在 &lt;code&gt;Makefile&lt;/code&gt; 的 &lt;code&gt;BUILT_INS&lt;/code&gt; 中列出。</target>
        </trans-unit>
        <trans-unit id="59356e5b6f2fcc25a08169f8960c8b579beeb31f" translate="yes" xml:space="preserve">
          <source>Sometimes, you do not know where to look for a feature. In many such cases, it helps to search through the output of &lt;code&gt;git log&lt;/code&gt;, and then &lt;code&gt;git show&lt;/code&gt; the corresponding commit.</source>
          <target state="translated">有时，您不知道在哪里寻找功能。在许多情况下，它有助于搜索 &lt;code&gt;git log&lt;/code&gt; 的输出，然后 &lt;code&gt;git show&lt;/code&gt; 相应的提交。</target>
        </trans-unit>
        <trans-unit id="94a8d6cf12f26243dde0f5140dd4760ee8881bb4" translate="yes" xml:space="preserve">
          <source>Sort based on the key given. Prefix &lt;code&gt;-&lt;/code&gt; to sort in descending order of the value. Supports &quot;version:refname&quot; or &quot;v:refname&quot; (tag names are treated as versions). The &quot;version:refname&quot; sort order can also be affected by the &quot;versionsort.suffix&quot; configuration variable. See &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt; for more sort options, but be aware keys like &lt;code&gt;committerdate&lt;/code&gt; that require access to the objects themselves will not work for refs whose objects have not yet been fetched from the remote, and will give a &lt;code&gt;missing object&lt;/code&gt; error.</source>
          <target state="translated">根据给定的键排序。前缀 &lt;code&gt;-&lt;/code&gt; 以值的降序排序。支持&amp;ldquo;版本：refname&amp;rdquo;或&amp;ldquo; v：refname&amp;rdquo;（标记名称被视为版本）。 &amp;ldquo; version：refname&amp;rdquo;排序顺序也可能受&amp;ldquo; versionsort.suffix&amp;rdquo;配置变量影响。有关更多排序选项，请参见&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt;，但是请注意，诸如 &lt;code&gt;committerdate&lt;/code&gt; 之类的键需要访问对象本身，这些键对于尚未从远程获取对象的ref无效，并且会 &lt;code&gt;missing object&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="4f8164295fbfdf007f932844e4ac7576dc2d1ee2" translate="yes" xml:space="preserve">
          <source>Sort based on the key given. Prefix &lt;code&gt;-&lt;/code&gt; to sort in descending order of the value. You may use the --sort=&amp;lt;key&amp;gt; option multiple times, in which case the last key becomes the primary key. Also supports &quot;version:refname&quot; or &quot;v:refname&quot; (tag names are treated as versions). The &quot;version:refname&quot; sort order can also be affected by the &quot;versionsort.suffix&quot; configuration variable. The keys supported are the same as those in &lt;code&gt;git for-each-ref&lt;/code&gt;. Sort order defaults to the value configured for the &lt;code&gt;tag.sort&lt;/code&gt; variable if it exists, or lexicographic order otherwise. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">根据给定的键排序。前缀 &lt;code&gt;-&lt;/code&gt; 以值的降序排序。您可以多次使用--sort = &amp;lt;key&amp;gt;选项，在这种情况下，最后一个键成为主键。还支持&amp;ldquo;版本：refname&amp;rdquo;或&amp;ldquo; v：refname&amp;rdquo;（标记名称被视为版本）。 &amp;ldquo; version：refname&amp;rdquo;排序顺序也可能受&amp;ldquo; versionsort.suffix&amp;rdquo;配置变量影响。支持的键与 &lt;code&gt;git for-each-ref&lt;/code&gt; 中的键相同。排序顺序默认为为 &lt;code&gt;tag.sort&lt;/code&gt; 变量配置的值（如果存在），否则为字典顺序。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="235c15477db9421be496a9bdb61ee9fe5440e8e8" translate="yes" xml:space="preserve">
          <source>Sort based on the key given. Prefix &lt;code&gt;-&lt;/code&gt; to sort in descending order of the value. You may use the --sort=&amp;lt;key&amp;gt; option multiple times, in which case the last key becomes the primary key. The keys supported are the same as those in &lt;code&gt;git
for-each-ref&lt;/code&gt;. Sort order defaults to the value configured for the &lt;code&gt;branch.sort&lt;/code&gt; variable if exists, or to sorting based on the full refname (including &lt;code&gt;refs/...&lt;/code&gt; prefix). This lists detached HEAD (if present) first, then local branches and finally remote-tracking branches. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">根据给定的键排序。前缀 &lt;code&gt;-&lt;/code&gt; 以值的降序排序。您可以多次使用--sort = &amp;lt;key&amp;gt;选项，在这种情况下，最后一个键成为主键。支持的键与 &lt;code&gt;git for-each-ref&lt;/code&gt; 的键相同。排序顺序默认为为 &lt;code&gt;branch.sort&lt;/code&gt; 变量配置的值（如果存在），或者默认为基于完整的refname（包括 &lt;code&gt;refs/...&lt;/code&gt; 前缀）进行排序。这首先列出了分离的HEAD（如果存在），然后列出了本地分支，最后列出了远程跟踪分支。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f1523e64bd22fd24a21f855bbd22c50e1efc550" translate="yes" xml:space="preserve">
          <source>Sort commits by date when possible.</source>
          <target state="translated">尽可能按日期排序提交。</target>
        </trans-unit>
        <trans-unit id="2c6b9826784b28663433b0a6dc2f2674e6b29a9a" translate="yes" xml:space="preserve">
          <source>Sort output according to the number of commits per author instead of author alphabetic order.</source>
          <target state="translated">根据每个作者的提交次数来排序,而不是按照作者的字母顺序。</target>
        </trans-unit>
        <trans-unit id="97d057704ff7369f19e3dfc333c10a22925317f1" translate="yes" xml:space="preserve">
          <source>Sorting and filtering branches are case insensitive.</source>
          <target state="translated">排序和过滤分支不区分大小写。</target>
        </trans-unit>
        <trans-unit id="5ce7d777697e6536cabaa9eaf03abf69552dd696" translate="yes" xml:space="preserve">
          <source>Sorting and filtering refs are case insensitive.</source>
          <target state="translated">排序和过滤参考文献是不区分大小写的。</target>
        </trans-unit>
        <trans-unit id="9d38ff15fbd7490d8843677184f9c7afbcdf73ce" translate="yes" xml:space="preserve">
          <source>Sorting and filtering tags are case insensitive.</source>
          <target state="translated">排序和过滤标签是不分大小写的。</target>
        </trans-unit>
        <trans-unit id="74d012567bc749743b2f7f680471d74e8b0444d4" translate="yes" xml:space="preserve">
          <source>Source code management (tool).</source>
          <target state="translated">源码管理(工具)。</target>
        </trans-unit>
        <trans-unit id="36b1651cdc36dfe13b6c0271ea5052804f0ae0c9" translate="yes" xml:space="preserve">
          <source>Sparse checkout</source>
          <target state="translated">稀疏的结账</target>
        </trans-unit>
        <trans-unit id="7aaf15f27eda1de7eaf7b123729519d3afe58336" translate="yes" xml:space="preserve">
          <source>Specifically, the following are removed until none of them remain:</source>
          <target state="translated">具体来说,就是将以下内容删除,直到一个都不剩。</target>
        </trans-unit>
        <trans-unit id="6fb30b05a9f660538f592f3613160c9d3d393240" translate="yes" xml:space="preserve">
          <source>Specified branch is an ancestor of the remote HEAD</source>
          <target state="translated">指定的分支是远程HEAD的祖先。</target>
        </trans-unit>
        <trans-unit id="095f9fffc528a2b593b5d023d80910beab9fba54" translate="yes" xml:space="preserve">
          <source>Specified branch resolves to an object that exists locally</source>
          <target state="translated">指定的分支解析到本地存在的对象。</target>
        </trans-unit>
        <trans-unit id="aa507335de58b83c95563636f96d43ebd2769930" translate="yes" xml:space="preserve">
          <source>Specifies a minimum trust level for signature verification. If this option is unset, then signature verification for merge operations require a key with at least &lt;code&gt;marginal&lt;/code&gt; trust. Other operations that perform signature verification require a key with at least &lt;code&gt;undefined&lt;/code&gt; trust. Setting this option overrides the required trust-level for all operations. Supported values, in increasing order of significance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd7d2d739debb36a1057aa4a730675102718bfe" translate="yes" xml:space="preserve">
          <source>Specifies a port different from the default port (SMTP servers typically listen to smtp port 25, but may also listen to submission port 587, or the common SSL smtp port 465); symbolic port names (e.g. &quot;submission&quot; instead of 587) are also accepted. The port can also be set with the &lt;code&gt;sendemail.smtpServerPort&lt;/code&gt; configuration variable.</source>
          <target state="translated">指定与默认端口不同的端口（SMTP服务器通常侦听smtp端口25，但也可能侦听提交端口587或公共SSL smtp端口465）；也接受符号端口名（例如，&amp;ldquo; submission&amp;rdquo;代替587）。也可以使用 &lt;code&gt;sendemail.smtpServerPort&lt;/code&gt; 配置变量来设置端口。</target>
        </trans-unit>
        <trans-unit id="07c63275a8584ac825542ccb56fd0f5b3bf25b5a" translate="yes" xml:space="preserve">
          <source>Specifies compression level for newly-compressed data in the generated pack. If not specified, pack compression level is determined first by pack.compression, then by core.compression, and defaults to -1, the zlib default, if neither is set. Add --no-reuse-object if you want to force a uniform compression level on all data no matter the source.</source>
          <target state="translated">为生成的压缩包中新压缩的数据指定压缩级别。如果没有指定,压缩包的压缩级别首先由pack.compression决定,然后由core.compression决定,如果两者都没有设置,则默认为-1,即zlib默认值。如果你想在所有数据上强制使用统一的压缩级别,不管数据源是什么,可以添加--no-reuse-object。</target>
        </trans-unit>
        <trans-unit id="2e586cba19f8fbc5a10baac47fbd5c9e37781d67" translate="yes" xml:space="preserve">
          <source>Specifies how a merge is handled when the merged-in history is already a descendant of the current history. &lt;code&gt;--ff&lt;/code&gt; is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the &lt;code&gt;refs/tags/&lt;/code&gt; hierarchy, in which case &lt;code&gt;--no-ff&lt;/code&gt; is assumed.</source>
          <target state="translated">指定当合并的历史记录已经是当前历史记录的后代时，如何处理合并。除非合并未存储在 &lt;code&gt;refs/tags/&lt;/code&gt; 层次结构中其自然位置的带注释（且可能带有符号）的标记，否则默认为 &lt;code&gt;--ff&lt;/code&gt; ，在这种情况下，假定为 &lt;code&gt;--no-ff&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e4cfa4b695628b655fba3d437b2ed50df8c7399" translate="yes" xml:space="preserve">
          <source>Specifies how many context lines should be used in calls to diff made by the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;. The default is &quot;5&quot;.</source>
          <target state="translated">指定在&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt;进行的diff调用中应使用多少个上下文行。默认值为&amp;ldquo; 5&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ee05d66bfede680eae8d8ce792188074b5498ff4" translate="yes" xml:space="preserve">
          <source>Specifies how many submodules are fetched/cloned at the same time. A positive integer allows up to that number of submodules fetched in parallel. A value of 0 will give some reasonable default. If unset, it defaults to 1.</source>
          <target state="translated">指定同时取回/克隆多少个子模块。一个正的整数允许最多并行获取该数量的子模块。0的值会给出一些合理的默认值。如果未设置,默认为1。</target>
        </trans-unit>
        <trans-unit id="316fa49ea084b12859b1b97d79b0376bed50442d" translate="yes" xml:space="preserve">
          <source>Specifies how the submodules obtain alternates when submodules are cloned. Possible values are &lt;code&gt;no&lt;/code&gt;, &lt;code&gt;superproject&lt;/code&gt;. By default &lt;code&gt;no&lt;/code&gt; is assumed, which doesn&amp;rsquo;t add references. When the value is set to &lt;code&gt;superproject&lt;/code&gt; the submodule to be cloned computes its alternates location relative to the superprojects alternate.</source>
          <target state="translated">指定在克隆子模块时子模块如何获取备用模块。可能的值是 &lt;code&gt;no&lt;/code&gt; ， &lt;code&gt;superproject&lt;/code&gt; 。默认情况下，假定为 &lt;code&gt;no&lt;/code&gt; ，它不添加引用。当将该值设置为 &lt;code&gt;superproject&lt;/code&gt; ，要克隆的子模块将计算其相对于超级项目替代项的替代位置。</target>
        </trans-unit>
        <trans-unit id="b31fc36154a26e26a1c078ebba51ee8a4995b30b" translate="yes" xml:space="preserve">
          <source>Specifies how to treat errors with the alternates for a submodule as computed via &lt;code&gt;submodule.alternateLocation&lt;/code&gt;. Possible values are &lt;code&gt;ignore&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;die&lt;/code&gt;. Default is &lt;code&gt;die&lt;/code&gt;. Note that if set to &lt;code&gt;ignore&lt;/code&gt; or &lt;code&gt;info&lt;/code&gt;, and if there is an error with the computed alternate, the clone proceeds as if no alternate was specified.</source>
          <target state="translated">指定如何处理通过 &lt;code&gt;submodule.alternateLocation&lt;/code&gt; 计算的子模块的替代错误。可能的值是 &lt;code&gt;ignore&lt;/code&gt; ， &lt;code&gt;info&lt;/code&gt; ， &lt;code&gt;die&lt;/code&gt; 。默认值为 &lt;code&gt;die&lt;/code&gt; 。请注意，如果将其设置为 &lt;code&gt;ignore&lt;/code&gt; 或 &lt;code&gt;info&lt;/code&gt; ，并且计算的替代项出现错误，则克隆将继续进行，就像未指定替代项一样。</target>
        </trans-unit>
        <trans-unit id="d91861558c562fdeaaf804d5a6651390fea90d33" translate="yes" xml:space="preserve">
          <source>Specifies if commands recurse into submodules by default. This applies to all commands that have a &lt;code&gt;--recurse-submodules&lt;/code&gt; option (&lt;code&gt;checkout&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;pull&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;read-tree&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;restore&lt;/code&gt; and &lt;code&gt;switch&lt;/code&gt;) except &lt;code&gt;clone&lt;/code&gt; and &lt;code&gt;ls-files&lt;/code&gt;. Defaults to false. When set to true, it can be deactivated via the &lt;code&gt;--no-recurse-submodules&lt;/code&gt; option. Note that some Git commands lacking this option may call some of the above commands affected by &lt;code&gt;submodule.recurse&lt;/code&gt;; for instance &lt;code&gt;git remote update&lt;/code&gt; will call &lt;code&gt;git fetch&lt;/code&gt; but does not have a &lt;code&gt;--no-recurse-submodules&lt;/code&gt; option. For these commands a workaround is to temporarily change the configuration value by using &lt;code&gt;git -c submodule.recurse=0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be724c0999a6ad4178618a1619dc5ee566f604f6" translate="yes" xml:space="preserve">
          <source>Specifies if commands recurse into submodules by default. This applies to all commands that have a &lt;code&gt;--recurse-submodules&lt;/code&gt; option, except &lt;code&gt;clone&lt;/code&gt;. Defaults to false.</source>
          <target state="translated">指定默认情况下命令是否递归到子模块中。这适用于所有具有 &lt;code&gt;--recurse-submodules&lt;/code&gt; 选项的命令， &lt;code&gt;clone&lt;/code&gt; 除外。默认为false。</target>
        </trans-unit>
        <trans-unit id="521e20e338253b67c65fe5992b9e53ef105e078a" translate="yes" xml:space="preserve">
          <source>Specifies intentionally untracked files to ignore</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0da697fa597c14275c00dd14541ab0c3dfd994" translate="yes" xml:space="preserve">
          <source>Specifies the Fully Qualified Domain Name (FQDN) used in the HELO/EHLO command to the SMTP server. Some servers require the FQDN to match your IP address. If not set, git send-email attempts to determine your FQDN automatically. Default is the value of &lt;code&gt;sendemail.smtpDomain&lt;/code&gt;.</source>
          <target state="translated">指定在SMTP服务器的HELO / EHLO命令中使用的完全限定域名（FQDN）。某些服务器需要FQDN来匹配您的IP地址。如果未设置，则git send-email会尝试自动确定您的FQDN。默认值为 &lt;code&gt;sendemail.smtpDomain&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="5037aaf03dca1f2f538183f1496bfc2b7e1efabf" translate="yes" xml:space="preserve">
          <source>Specifies the default encoding to use for displaying of file contents in &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; and &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt;. It can be overridden by setting the &lt;code&gt;encoding&lt;/code&gt; attribute for relevant files (see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;). If this option is not set, the tools default to the locale encoding.</source>
          <target state="translated">指定用于在&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt;和&lt;a href=&quot;gitk&quot;&gt;gitk [1]中&lt;/a&gt;显示文件内容的默认编码。可以通过设置相关文件的 &lt;code&gt;encoding&lt;/code&gt; 属性来覆盖它（请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;）。如果未设置此选项，则工具默认为区域设置编码。</target>
        </trans-unit>
        <trans-unit id="9702444fd012da98ed5d8ff9c395c187404df9d9" translate="yes" xml:space="preserve">
          <source>Specifies the default value for the &lt;code&gt;--max-new-filters&lt;/code&gt; option of &lt;code&gt;git
commit-graph write&lt;/code&gt; (c.f., &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d7b044fb5611f2bdd400a7d800ea730223f6289" translate="yes" xml:space="preserve">
          <source>Specifies the dictionary used for spell checking commit messages in the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;. When set to &quot;none&quot; spell checking is turned off.</source>
          <target state="translated">在&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]中&lt;/a&gt;指定用于拼写检查提交消息的字典。设置为&amp;ldquo; none&amp;rdquo;时，将关闭拼写检查。</target>
        </trans-unit>
        <trans-unit id="d083f984efe9263940e7d58fa993a7931f1dd65f" translate="yes" xml:space="preserve">
          <source>Specifies the encoding used to output author names and commit summaries. Setting it to &lt;code&gt;none&lt;/code&gt; makes blame output unconverted data. For more information see the discussion about encoding in the &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; manual page.</source>
          <target state="translated">指定用于输出作者姓名和提交摘要的编码。将其设置为 &lt;code&gt;none&lt;/code&gt; 会使非输出未转换的数据。有关更多信息，请参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;手册页中有关编码的讨论。</target>
        </trans-unit>
        <trans-unit id="a27599ead22294e56acfe0afc5fbf545479773f2" translate="yes" xml:space="preserve">
          <source>Specifies the format used to output dates in &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. If unset the iso format is used. For supported values, see the discussion of the &lt;code&gt;--date&lt;/code&gt; option at &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">指定用于在&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]中&lt;/a&gt;输出日期的格式。如果未设置，则使用iso格式。有关受支持的值，请参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;上有关 &lt;code&gt;--date&lt;/code&gt; 选项的讨论。</target>
        </trans-unit>
        <trans-unit id="08d91dd5a7053d3bafb0000dd55ac78c15731e93" translate="yes" xml:space="preserve">
          <source>Specifies the format used to output dates. If --date is not provided, the value of the blame.date config variable is used. If the blame.date config variable is also not set, the iso format is used. For supported values, see the discussion of the --date option at &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">指定用于输出日期的格式。如果未提供--date，则使用blame.date配置变量的值。如果也未设置blame.date配置变量，则使用iso格式。有关受支持的值，请参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;上有关--date选项的讨论。</target>
        </trans-unit>
        <trans-unit id="08b582fd23612321f471de0a5131383c71313dc1" translate="yes" xml:space="preserve">
          <source>Specifies the general prompt string to display at the top of the dialog, before subsections for &lt;code&gt;argPrompt&lt;/code&gt; and &lt;code&gt;revPrompt&lt;/code&gt;. The default value includes the actual command.</source>
          <target state="translated">指定在 &lt;code&gt;argPrompt&lt;/code&gt; 和 &lt;code&gt;revPrompt&lt;/code&gt; 的小节之前显示在对话框顶部的常规提示字符串。默认值包括实际命令。</target>
        </trans-unit>
        <trans-unit id="a9e526c09a4c4719d9406e0b96ea75a516e14797" translate="yes" xml:space="preserve">
          <source>Specifies the maximal number of fetch operations to be run in parallel at a time (submodules, or remotes when the &lt;code&gt;--multiple&lt;/code&gt; option of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; is in effect).</source>
          <target state="translated">指定一次并行运行的最大提取操作数（当&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;的 &lt;code&gt;--multiple&lt;/code&gt; 选项生效时，子模块或远程）。</target>
        </trans-unit>
        <trans-unit id="841aeff1992a5e30906fb04c48bd487428f81ede" translate="yes" xml:space="preserve">
          <source>Specifies the number of threads to spawn when loading the index. This is meant to reduce index load time on multiprocessor machines. Specifying 0 or &lt;code&gt;true&lt;/code&gt; will cause Git to auto-detect the number of CPU&amp;rsquo;s and set the number of threads accordingly. Specifying 1 or &lt;code&gt;false&lt;/code&gt; will disable multithreading. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">指定加载索引时要产生的线程数。这是为了减少多处理器计算机上的索引加载时间。指定0或 &lt;code&gt;true&lt;/code&gt; 将导致Git自动检测CPU的数量并相应地设置线程数。指定1或 &lt;code&gt;false&lt;/code&gt; 将禁用多线程。默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1edc546a8b44445b5552ac6cb04ae2f0f6c55a7" translate="yes" xml:space="preserve">
          <source>Specifies the number of threads to spawn when resolving deltas. This requires that index-pack be compiled with pthreads otherwise this option is ignored with a warning. This is meant to reduce packing time on multiprocessor machines. The required amount of memory for the delta search window is however multiplied by the number of threads. Specifying 0 will cause Git to auto-detect the number of CPU&amp;rsquo;s and use maximum 3 threads.</source>
          <target state="translated">指定解决增量时要产生的线程数。这要求使用pthreads编译index-pack，否则该选项将被警告忽略。这是为了减少多处理器机器上的打包时间。但是，增量搜索窗口所需的内存量将乘以线程数。指定0将导致Git自动检测CPU的数量并最多使用3个线程。</target>
        </trans-unit>
        <trans-unit id="62a88cce2e4d60d8d3773b73f0efea252799f6cf" translate="yes" xml:space="preserve">
          <source>Specifies the number of threads to spawn when searching for best delta matches. This requires that &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; be compiled with pthreads otherwise this option is ignored with a warning. This is meant to reduce packing time on multiprocessor machines. The required amount of memory for the delta search window is however multiplied by the number of threads. Specifying 0 will cause Git to auto-detect the number of CPU&amp;rsquo;s and set the number of threads accordingly.</source>
          <target state="translated">指定搜索最佳增量匹配时要产生的线程数。这要求使用pthreads编译&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;，否则此选项将被警告忽略。这是为了减少多处理器机器上的打包时间。但是，增量搜索窗口所需的内存量将乘以线程数。指定0将导致Git自动检测CPU的数量并相应地设置线程数。</target>
        </trans-unit>
        <trans-unit id="b8f98a607312c9ba066372345125a9cb60221982" translate="yes" xml:space="preserve">
          <source>Specifies the number of threads to spawn when searching for best delta matches. This requires that pack-objects be compiled with pthreads otherwise this option is ignored with a warning. This is meant to reduce packing time on multiprocessor machines. The required amount of memory for the delta search window is however multiplied by the number of threads. Specifying 0 will cause Git to auto-detect the number of CPU&amp;rsquo;s and set the number of threads accordingly.</source>
          <target state="translated">指定搜索最佳增量匹配时要产生的线程数。这要求使用pthreads编译pack-objects，否则此选项将被警告忽略。这是为了减少多处理器机器上的打包时间。但是，增量搜索窗口所需的内存量将乘以线程数。指定0将导致Git自动检测CPU的数量并相应地设置线程数。</target>
        </trans-unit>
        <trans-unit id="a17b7410705517c5284c60d4c1158e205890521a" translate="yes" xml:space="preserve">
          <source>Specifies the number of times to retry a p4 command (notably, &lt;code&gt;p4 sync&lt;/code&gt;) if the network times out. The default value is 3. Set the value to 0 to disable retries or if your p4 version does not support retries (pre 2012.2).</source>
          <target state="translated">指定在网络超时时重试p4命令的次数（特别是 &lt;code&gt;p4 sync&lt;/code&gt; ）。默认值为3。将值设置为0可禁用重试，或者您的p4版本不支持重试（2012.2之前的版本）。</target>
        </trans-unit>
        <trans-unit id="0ebc03abb12118370c422382dc91c5979f3d39ba" translate="yes" xml:space="preserve">
          <source>Specifies the pathname to the file that contains patterns to describe paths that are not meant to be tracked, in addition to &lt;code&gt;.gitignore&lt;/code&gt; (per-directory) and &lt;code&gt;.git/info/exclude&lt;/code&gt;. Defaults to &lt;code&gt;$XDG_CONFIG_HOME/git/ignore&lt;/code&gt;. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is either not set or empty, &lt;code&gt;$HOME/.config/git/ignore&lt;/code&gt; is used instead. See &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="translated">指定文件的路径名，除了 &lt;code&gt;.gitignore&lt;/code&gt; （按目录）和 &lt;code&gt;.git/info/exclude&lt;/code&gt; 之外，该文件还包含描述不应该跟踪的路径的模式的文件。默认为 &lt;code&gt;$XDG_CONFIG_HOME/git/ignore&lt;/code&gt; 。如果 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; 未设置或为空，则改用 &lt;code&gt;$HOME/.config/git/ignore&lt;/code&gt; 。参见&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d124e54be4e690b62098ac284ac76a08ab37106b" translate="yes" xml:space="preserve">
          <source>Specifies the radius of history context in days to show in &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; for the selected commit, when the &lt;code&gt;Show History
Context&lt;/code&gt; menu item is invoked from &lt;code&gt;git gui blame&lt;/code&gt;. If this variable is set to zero, the whole history is shown.</source>
          <target state="translated">指定当从 &lt;code&gt;git gui blame&lt;/code&gt; 调用 &lt;code&gt;Show History Context&lt;/code&gt; 菜单项时，以天为单位的历史上下文的半径，以天为单位显示在&lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt;中。如果将此变量设置为零，则显示整个历史记录。</target>
        </trans-unit>
        <trans-unit id="f11e5547d2e0c72dd049c0935b29638a6ee69cf3" translate="yes" xml:space="preserve">
          <source>Specifies the shell command line to execute when the corresponding item of the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;&lt;code&gt;Tools&lt;/code&gt; menu is invoked. This option is mandatory for every tool. The command is executed from the root of the working directory, and in the environment it receives the name of the tool as &lt;code&gt;GIT_GUITOOL&lt;/code&gt;, the name of the currently selected file as &lt;code&gt;FILENAME&lt;/code&gt;, and the name of the current branch as &lt;code&gt;CUR_BRANCH&lt;/code&gt; (if the head is detached, &lt;code&gt;CUR_BRANCH&lt;/code&gt; is empty).</source>
          <target state="translated">指定当调用&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&amp;ldquo; &lt;/a&gt; &lt;code&gt;Tools&lt;/code&gt; 菜单的相应项时要执行的shell命令行。对于每个工具，此选项都是必需的。该命令从工作目录的根目录执行，在该环境中，该工具的名称为 &lt;code&gt;GIT_GUITOOL&lt;/code&gt; ，当前所选文件的名称为 &lt;code&gt;FILENAME&lt;/code&gt; ，当前分支的名称为 &lt;code&gt;CUR_BRANCH&lt;/code&gt; （如果头为分离， &lt;code&gt;CUR_BRANCH&lt;/code&gt; 为空）。</target>
        </trans-unit>
        <trans-unit id="b9843bcfef468e8924053c3490935a52737f70b4" translate="yes" xml:space="preserve">
          <source>Specifies the threshold to use in &lt;code&gt;git gui blame&lt;/code&gt; original location detection, measured in alphanumeric characters. See the &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; manual for more information on copy detection.</source>
          <target state="translated">指定在 &lt;code&gt;git gui blame&lt;/code&gt; 原始位置检测中使用的阈值，以字母数字字符度量。有关复制检测的更多信息，请参见&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;手册。</target>
        </trans-unit>
        <trans-unit id="35d941c623037130ce3eda15ee67700140f974b9" translate="yes" xml:space="preserve">
          <source>Specifies the title to use for the prompt dialog. The default is the tool name.</source>
          <target state="translated">指定提示对话框的标题。默认为工具名称。</target>
        </trans-unit>
        <trans-unit id="52c4a2a4dc795a08ca1c6e643c489de2ec8bd5e5" translate="yes" xml:space="preserve">
          <source>Specifies whether the index file should include an &quot;End Of Index Entry&quot; section. This reduces index load time on multiprocessor machines but produces a message &quot;ignoring EOIE extension&quot; when reading the index using Git versions before 2.20. Defaults to &lt;code&gt;true&lt;/code&gt; if index.threads has been explicitly enabled, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">指定索引文件是否应包含&amp;ldquo;索引条目末尾&amp;rdquo;部分。这样可以减少多处理器计算机上索引的加载时间，但是在使用2.20之前的Git版本读取索引时会生成一条消息&amp;ldquo;忽略EOIE扩展&amp;rdquo;。如果已明确启用index.threads，则默认为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="525e2825828b98c76d10ccc05a720012cdd9968e" translate="yes" xml:space="preserve">
          <source>Specifies whether the index file should include an &quot;Index Entry Offset Table&quot; section. This reduces index load time on multiprocessor machines but produces a message &quot;ignoring IEOT extension&quot; when reading the index using Git versions before 2.20. Defaults to &lt;code&gt;true&lt;/code&gt; if index.threads has been explicitly enabled, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">指定索引文件是否应包含&amp;ldquo;索引条目偏移表&amp;rdquo;部分。这减少了多处理器计算机上的索引加载时间，但是当使用2.20之前的Git版本读取索引时，会生成一条消息&amp;ldquo;忽略IEOT扩展&amp;rdquo;。如果已明确启用index.threads，则默认为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fdd8a31fc755f041d294b5f0a76be847216c212" translate="yes" xml:space="preserve">
          <source>Specifies which key format to use when signing with &lt;code&gt;--gpg-sign&lt;/code&gt;. Default is &quot;openpgp&quot; and another possible value is &quot;x509&quot;.</source>
          <target state="translated">指定使用 &lt;code&gt;--gpg-sign&lt;/code&gt; 签名时使用的密钥格式。默认值为&amp;ldquo; openpgp&amp;rdquo;，另一个可能的值为&amp;ldquo; x509&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="53399059f89e05e568d5d0da51714e4798f56246" translate="yes" xml:space="preserve">
          <source>Specifies which refs to fetch and which local refs to update. When no &amp;lt;refspec&amp;gt;s appear on the command line, the refs to fetch are read from &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; variables instead (see &lt;a href=&quot;#CRTB&quot;&gt;CONFIGURED REMOTE-TRACKING BRANCHES&lt;/a&gt; below).</source>
          <target state="translated">指定要获取的参考和要更新的本地参考。如果命令行上没有&amp;lt;refspec&amp;gt;出现，则从 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 变量中读取要获取的ref （请参阅下面的&lt;a href=&quot;#CRTB&quot;&gt;CONFIGURED REMOTE-TRACKING BRANCHES&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="60264eae7c0d99030432a57153dd31a20ae2e753" translate="yes" xml:space="preserve">
          <source>Specifies which refs to fetch and which local refs to update. When no &amp;lt;refspec&amp;gt;s appear on the command line, the refs to fetch are read from &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; variables instead (see &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">指定要获取的参考和要更新的本地参考。当命令行上没有&amp;lt;refspec&amp;gt;出现时，要从 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 变量读取要提取的ref （请参阅&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1874860df7878b35e35c3f03f4fe16310c6f5c2f" translate="yes" xml:space="preserve">
          <source>Specifies which refs to fetch and which local refs to update. When no &amp;lt;refspec&amp;gt;s appear on the command line, the refs to fetch are read from &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; variables instead (see the section &quot;CONFIGURED REMOTE-TRACKING BRANCHES&quot; in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c5a4fe1da6e3ddd052994379342b3963b9ece6" translate="yes" xml:space="preserve">
          <source>Specify a &quot;Bcc:&quot; value for each email. Default is the value of &lt;code&gt;sendemail.bcc&lt;/code&gt;.</source>
          <target state="translated">为每封电子邮件指定一个&amp;ldquo;密件抄送：&amp;rdquo;值。默认值为 &lt;code&gt;sendemail.bcc&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="490afafb9292b82bc6ff88488dc739661601f0fb" translate="yes" xml:space="preserve">
          <source>Specify a (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair that should be applied as a trailer to the input messages. See the description of this command.</source>
          <target state="translated">指定一个（&amp;lt;token&amp;gt;，&amp;lt;value&amp;gt;）对，该对应作为预告片应用于输入消息。请参阅此命令的描述。</target>
        </trans-unit>
        <trans-unit id="fda787c4a6303bd8c4899e47b2fd75ed69b102b2" translate="yes" xml:space="preserve">
          <source>Specify a comma separate list of common whitespace problems to notice in the same format as the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable.</source>
          <target state="translated">指定逗号分隔的常见空格问题列表，以与 &lt;code&gt;core.whitespace&lt;/code&gt; 配置变量相同的格式注意。</target>
        </trans-unit>
        <trans-unit id="f01423252b19025369d9eaeaea940daec72c630e" translate="yes" xml:space="preserve">
          <source>Specify a command to execute once per patch file which should generate patch file specific &quot;Cc:&quot; entries. Output of this command must be single email address per line. Default is the value of &lt;code&gt;sendemail.ccCmd&lt;/code&gt; configuration value.</source>
          <target state="translated">指定每个修补程序文件执行一次的命令，该命令应生成特定于修补程序文件的&amp;ldquo; Cc：&amp;rdquo;条目。此命令的输出必须是每行一个电子邮件地址。默认值为 &lt;code&gt;sendemail.ccCmd&lt;/code&gt; 配置值。</target>
        </trans-unit>
        <trans-unit id="8a69aa64125bc041f34a0988fcc820e93ea1cefe" translate="yes" xml:space="preserve">
          <source>Specify a command to execute once per patch file which should generate patch file specific &quot;To:&quot; entries. Output of this command must be single email address per line. Default is the value of &lt;code&gt;sendemail.tocmd&lt;/code&gt; configuration value.</source>
          <target state="translated">指定每个补丁文件执行一次的命令，该命令应生成补丁文件特定的&amp;ldquo; To：&amp;rdquo;条目。此命令的输出必须是每行一个电子邮件地址。默认值为 &lt;code&gt;sendemail.tocmd&lt;/code&gt; 配置值。</target>
        </trans-unit>
        <trans-unit id="f6cbbfb6d081efa8553064ef51812c93149ccd37" translate="yes" xml:space="preserve">
          <source>Specify a custom command for viewing diffs. &lt;code&gt;git-difftool&lt;/code&gt; ignores the configured defaults and runs &lt;code&gt;$command $LOCAL $REMOTE&lt;/code&gt; when this option is specified. Additionally, &lt;code&gt;$BASE&lt;/code&gt; is set in the environment.</source>
          <target state="translated">指定用于查看差异的自定义命令。 &lt;code&gt;git-difftool&lt;/code&gt; 忽略配置的默认值，并在指定此选项时运行 &lt;code&gt;$command $LOCAL $REMOTE&lt;/code&gt; 。此外，在环境中设置了 &lt;code&gt;$BASE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8f61e37f968bf27d42f1bb30c54e88a19aa0b4c" translate="yes" xml:space="preserve">
          <source>Specify a starting &quot;Cc:&quot; value for each email. Default is the value of &lt;code&gt;sendemail.cc&lt;/code&gt;.</source>
          <target state="translated">为每封电子邮件指定一个起始的&amp;ldquo;抄送：&amp;rdquo;值。默认值为 &lt;code&gt;sendemail.cc&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="d751165243a07b0d8cf01d157a40d624e1274cc2" translate="yes" xml:space="preserve">
          <source>Specify a web browser that may be used by some commands. Currently only &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; and &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; may use it.</source>
          <target state="translated">指定某些命令可能使用的Web浏览器。目前只有&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;和&lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt;可以使用它。</target>
        </trans-unit>
        <trans-unit id="3184d8ec3f5fc0c7b49c79eaaa392759be7aeb74" translate="yes" xml:space="preserve">
          <source>Specify an additional category of recipients to suppress the auto-cc of:</source>
          <target state="translated">指定一个额外的收件人类别,以抑制自动接收。</target>
        </trans-unit>
        <trans-unit id="6c3bb30f438f4e33cf02f17fe7e170959d2a5bad" translate="yes" xml:space="preserve">
          <source>Specify an external helper to be called when a username or password credential is needed; the helper may consult external storage to avoid prompting the user for the credentials. Note that multiple helpers may be defined. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for details.</source>
          <target state="translated">指定需要用户名或密码凭据时要调用的外部帮助程序；帮助程序可以咨询外部存储，以避免提示用户输入凭据。注意，可以定义多个助手。有关详细信息，请参见&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5898b8f989a6a4118fc60032ee65af46c3876839" translate="yes" xml:space="preserve">
          <source>Specify an external helper to be called when a username or password credential is needed; the helper may consult external storage to avoid prompting the user for the credentials. This is normally the name of a credential helper with possible arguments, but may also be an absolute path with arguments or, if preceded by &lt;code&gt;!&lt;/code&gt;, shell commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88abf188bf279fdc57952e5f78070fe3d6b977d1" translate="yes" xml:space="preserve">
          <source>Specify an island name which gets to have its objects be packed first. This creates a kind of pseudo-pack at the front of one pack, so that the objects from the specified island are hopefully faster to copy into any pack that should be served to a user requesting these objects. In practice this means that the island specified should likely correspond to what is the most commonly cloned in the repo. See also &quot;DELTA ISLANDS&quot; in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;.</source>
          <target state="translated">指定一个岛名，该岛名首先要打包。这会在一个包的最前面创建一种伪包，以便希望将来自指定岛的对象更快地复制到应提供给请求这些对象的用户的任何包中。实际上，这意味着指定的岛可能应该对应于回购中最常克隆的岛。另请参见&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]中的&lt;/a&gt; &amp;ldquo; DELTA ISLANDS&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="4f4ddca39682ecb94c54d4e5428623a9fabd67c0" translate="yes" xml:space="preserve">
          <source>Specify any of the options listed under OPTIONS that do not change stream semantic to suit the frontend&amp;rsquo;s needs. This command is optional and is not needed to perform an import.</source>
          <target state="translated">指定&amp;ldquo;选项&amp;rdquo;下列出的任何选项，这些选项不会更改流语义以适应前端的需求。该命令是可选的，不需要执行导入。</target>
        </trans-unit>
        <trans-unit id="126df40ac6c274763f2820bec126088754eb50a7" translate="yes" xml:space="preserve">
          <source>Specify authenticate method for authentication with IMAP server. If Git was built with the NO_CURL option, or if your curl version is older than 7.34.0, or if you&amp;rsquo;re running git-imap-send with the &lt;code&gt;--no-curl&lt;/code&gt; option, the only supported method is &lt;code&gt;CRAM-MD5&lt;/code&gt;. If this is not set then &lt;code&gt;git imap-send&lt;/code&gt; uses the basic IMAP plaintext LOGIN command.</source>
          <target state="translated">指定用于使用IMAP服务器进行身份验证的身份验证方法。如果Git是使用NO_CURL选项构建的，或者您的curl版本早于7.34.0，或者如果您使用 &lt;code&gt;--no-curl&lt;/code&gt; 选项运行git-imap-send ，则唯一受支持的方法是 &lt;code&gt;CRAM-MD5&lt;/code&gt; 。如果未设置，则 &lt;code&gt;git imap-send&lt;/code&gt; 使用基本的IMAP纯文本LOGIN命令。</target>
        </trans-unit>
        <trans-unit id="db15aaae21c1056154eef62ce5f5cbd5e82beaa7" translate="yes" xml:space="preserve">
          <source>Specify encoding of compose message. Default is the value of the &lt;code&gt;sendemail.composeencoding&lt;/code&gt;; if that is unspecified, UTF-8 is assumed.</source>
          <target state="translated">指定撰写邮件的编码。默认值为 &lt;code&gt;sendemail.composeencoding&lt;/code&gt; 的值；如果未指定，则假定为UTF-8。</target>
        </trans-unit>
        <trans-unit id="bb2c4dacdd5136c6abef6fcc4de5e9c24a473010" translate="yes" xml:space="preserve">
          <source>Specify how differences in submodules are shown. When specifying &lt;code&gt;--submodule=short&lt;/code&gt; the &lt;code&gt;short&lt;/code&gt; format is used. This format just shows the names of the commits at the beginning and end of the range. When &lt;code&gt;--submodule&lt;/code&gt; or &lt;code&gt;--submodule=log&lt;/code&gt; is specified, the &lt;code&gt;log&lt;/code&gt; format is used. This format lists the commits in the range like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;&lt;code&gt;summary&lt;/code&gt; does. When &lt;code&gt;--submodule=diff&lt;/code&gt; is specified, the &lt;code&gt;diff&lt;/code&gt; format is used. This format shows an inline diff of the changes in the submodule contents between the commit range. Defaults to &lt;code&gt;diff.submodule&lt;/code&gt; or the &lt;code&gt;short&lt;/code&gt; format if the config option is unset.</source>
          <target state="translated">指定如何显示子模块中的差异。指定 &lt;code&gt;--submodule=short&lt;/code&gt; 时，使用 &lt;code&gt;short&lt;/code&gt; 格式。此格式仅显示范围开头和结尾的提交名称。当 &lt;code&gt;--submodule&lt;/code&gt; 或 &lt;code&gt;--submodule=log&lt;/code&gt; 被指定时，该 &lt;code&gt;log&lt;/code&gt; 用于格式。这种格式列出了&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1] &lt;/a&gt; &lt;code&gt;summary&lt;/code&gt; 所做的范围内的提交。当指定 &lt;code&gt;--submodule=diff&lt;/code&gt; 时，将使用 &lt;code&gt;diff&lt;/code&gt; 格式。此格式显示提交范围之间子模块内容更改的内联差异。默认为 &lt;code&gt;diff.submodule&lt;/code&gt; 或 &lt;code&gt;short&lt;/code&gt; 如果未设置config选项，则设置格式。</target>
        </trans-unit>
        <trans-unit id="e212f603460a2824026571f0244622b2735e495f" translate="yes" xml:space="preserve">
          <source>Specify how multiple patterns are combined using Boolean expressions. &lt;code&gt;--or&lt;/code&gt; is the default operator. &lt;code&gt;--and&lt;/code&gt; has higher precedence than &lt;code&gt;--or&lt;/code&gt;. &lt;code&gt;-e&lt;/code&gt; has to be used for all patterns.</source>
          <target state="translated">指定如何使用布尔表达式组合多个模式。 &lt;code&gt;--or&lt;/code&gt; 为默认运算符。 &lt;code&gt;--and&lt;/code&gt; 的优先级高于 &lt;code&gt;--or&lt;/code&gt; 。 &lt;code&gt;-e&lt;/code&gt; 必须用于所有模式。</target>
        </trans-unit>
        <trans-unit id="ffbe8c6ac43df98980b6107e62dec3dfa7156507" translate="yes" xml:space="preserve">
          <source>Specify how to handle &lt;code&gt;encoding&lt;/code&gt; header in commit objects. When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering such a commit object. With &lt;code&gt;yes&lt;/code&gt;, the commit message will be re-encoded into UTF-8. With &lt;code&gt;no&lt;/code&gt;, the original encoding will be preserved.</source>
          <target state="translated">指定如何处理提交对象中的 &lt;code&gt;encoding&lt;/code&gt; 标头。当要求 &lt;code&gt;abort&lt;/code&gt; （默认）时，该程序将在遇到此类提交对象时死亡。使用 &lt;code&gt;yes&lt;/code&gt; ，提交消息将被重新编码为UTF-8。如果使用 &lt;code&gt;no&lt;/code&gt; ，则将保留原始编码。</target>
        </trans-unit>
        <trans-unit id="37815a435af244972cccaee7f12b140bf366ab25" translate="yes" xml:space="preserve">
          <source>Specify how to handle signed tags. Since any transformation after the export can change the tag names (which can also happen when excluding revisions) the signatures will not match.</source>
          <target state="translated">指定如何处理已签名的标记。由于导出后的任何转换都可以更改标签名称(排除修订版时也会发生),签名将不匹配。</target>
        </trans-unit>
        <trans-unit id="2e5b9b1beb3e649edbd3450c18f18cbc2b0b3c2a" translate="yes" xml:space="preserve">
          <source>Specify how to handle tags whose tagged object is filtered out. Since revisions and files to export can be limited by path, tagged objects may be filtered completely.</source>
          <target state="translated">指定如何处理标签对象被过滤掉的标签。由于修订版和要导出的文件可受路径限制,所以标记对象可能会被完全过滤掉。</target>
        </trans-unit>
        <trans-unit id="58a10039b2ffb00f4c15d28cf7a59fdf8252b1ba" translate="yes" xml:space="preserve">
          <source>Specify layout mode. See configuration variable column.ui for option syntax in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">指定布局模式。有关&lt;a href=&quot;git-config&quot;&gt;git-config [1]中的&lt;/a&gt;选项语法，请参见配置变量column.ui 。</target>
        </trans-unit>
        <trans-unit id="cd9fc5283ae0d7709eafb7d7c044a946ec4a926f" translate="yes" xml:space="preserve">
          <source>Specify submit behavior when a conflict with p4 is found, as per --conflict. The default behavior is &lt;code&gt;ask&lt;/code&gt;.</source>
          <target state="translated">当发现与p4发生冲突时，请按照--conflict指定提交行为。默认行为是 &lt;code&gt;ask&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b47b0eac1308c340a251aaa9bc02b368f9e6ec9" translate="yes" xml:space="preserve">
          <source>Specify that the Git repository is to be shared amongst several users. This allows users belonging to the same group to push into that repository. When specified, the config variable &quot;core.sharedRepository&quot; is set so that files and directories under &lt;code&gt;$GIT_DIR&lt;/code&gt; are created with the requested permissions. When not specified, Git will use permissions reported by umask(2).</source>
          <target state="translated">指定要在多个用户之间共享Git存储库。这允许属于同一组的用户推入该存储库。指定后，设置配置变量&amp;ldquo; core.sharedRepository&amp;rdquo;，以便使用请求的权限创建 &lt;code&gt;$GIT_DIR&lt;/code&gt; 下的文件和目录。如果未指定，则Git将使用umask（2）报告的权限。</target>
        </trans-unit>
        <trans-unit id="553f83584ef890feb9fc0a5fa486ad4027a85d31" translate="yes" xml:space="preserve">
          <source>Specify that the p4 client spec should be used to identify p4 depot paths of interest. This is equivalent to specifying the option &lt;code&gt;--use-client-spec&lt;/code&gt;. See the &quot;CLIENT SPEC&quot; section above. This variable is a boolean, not the name of a p4 client.</source>
          <target state="translated">指定应使用p4客户端规范来识别感兴趣的p4仓库路径。这等效于指定选项 &lt;code&gt;--use-client-spec&lt;/code&gt; 。请参阅上面的&amp;ldquo;客户端规格&amp;rdquo;部分。此变量是布尔值，而不是p4客户端的名称。</target>
        </trans-unit>
        <trans-unit id="ee45839e9a36541472b0e6b0c79bb025ae2d044b" translate="yes" xml:space="preserve">
          <source>Specify the SVN username to perform the commit as. This option overrides the &lt;code&gt;username&lt;/code&gt; configuration property.</source>
          <target state="translated">指定SVN用户名以执行提交。此选项将覆盖 &lt;code&gt;username&lt;/code&gt; 配置属性。</target>
        </trans-unit>
        <trans-unit id="ce5445a596c457d8087a3ba95eb2c606f830762e" translate="yes" xml:space="preserve">
          <source>Specify the [svn-remote &quot;&amp;lt;remote name&amp;gt;&quot;] section to use, this allows SVN multiple repositories to be tracked. Default: &quot;svn&quot;</source>
          <target state="translated">指定要使用的[svn-remote&amp;ldquo; &amp;lt;远程名称&amp;gt;&amp;rdquo;]部分，这将允许跟踪SVN多个存储库。默认值：&amp;ldquo; svn&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="9617526476bf00e3e1b98443975d22edd359d482" translate="yes" xml:space="preserve">
          <source>Specify the address where replies from recipients should go to. Use this if replies to messages should go to another address than what is specified with the --from parameter.</source>
          <target state="translated">指定收件人回复的地址。如果回复邮件的地址与--from参数中指定的地址不同,请使用这个地址。</target>
        </trans-unit>
        <trans-unit id="ee03a68cf221fcf3ea580414a042d4bf2bb9f1e8" translate="yes" xml:space="preserve">
          <source>Specify the browser that will be used to display help in the &lt;code&gt;web&lt;/code&gt; format. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;.</source>
          <target state="translated">指定将用于以 &lt;code&gt;web&lt;/code&gt; 格式显示帮助的浏览器。参见&lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70ff10aa9e9d4bf715e29b8e032ab68c07b42b92" translate="yes" xml:space="preserve">
          <source>Specify the bundle version. Version 2 is the older format and can only be used with SHA-1 repositories; the newer version 3 contains capabilities that permit extensions. The default is the oldest supported format, based on the hash algorithm in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa86dc00b5d1ada804b541ee50aabffe17fa3ad" translate="yes" xml:space="preserve">
          <source>Specify the character used to indicate new, old or context lines in the generated patch. Normally they are &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; and ' ' respectively.</source>
          <target state="translated">指定用于在生成的修补程序中指示新行，旧行或上下文行的字符。通常它们分别是 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; 和''。</target>
        </trans-unit>
        <trans-unit id="966a510a55d7cdd1c3c8b5ab55defa7916878e77" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified browser. The specified command is evaluated in shell with the URLs passed as arguments. (See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb636a61044a94ec71c2c0e48db959f09a640e28" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified browser. The specified command is evaluated in shell with the URLs passed as arguments. (See git-web{litdd}browse[1].)</source>
          <target state="translated">指定调用指定浏览器的命令。指定的命令在shell中与作为参数传递的URL一起被评估。参见 git-web{litdd}browse[1]。</target>
        </trans-unit>
        <trans-unit id="f8ec599a595d519e45f7089bd76b8eb2f0cf86d7" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified diff tool.</source>
          <target state="translated">指定调用指定diff工具的命令。</target>
        </trans-unit>
        <trans-unit id="045550ad84d88752a76cca9657a08fe5f6314875" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified diff tool. The specified command is evaluated in shell with the following variables available: &lt;code&gt;LOCAL&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff pre-image and &lt;code&gt;REMOTE&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff post-image.</source>
          <target state="translated">指定命令以调用指定的差异工具。在Shell中使用以下可用变量评估指定的命令： &lt;code&gt;LOCAL&lt;/code&gt; 设置为包含diff前映像内容的临时文件的名称， &lt;code&gt;REMOTE&lt;/code&gt; 设置为包含diff post内容的临时文件的名称-图片。</target>
        </trans-unit>
        <trans-unit id="a4e7d7e1334d2dbe270d234d60ef8777bddd17c9" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified man viewer. The specified command is evaluated in shell with the man page passed as argument. (See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;.)</source>
          <target state="translated">指定命令以调用指定的man查看器。在shell中评估指定的命令，并将手册页作为参数传递。（请参阅&lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="3a2ff684c7c448a4b91310593e49dad0e76d3118" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified merge tool. The specified command is evaluated in shell with the following variables available: &lt;code&gt;BASE&lt;/code&gt; is the name of a temporary file containing the common base of the files to be merged, if available; &lt;code&gt;LOCAL&lt;/code&gt; is the name of a temporary file containing the contents of the file on the current branch; &lt;code&gt;REMOTE&lt;/code&gt; is the name of a temporary file containing the contents of the file from the branch being merged; &lt;code&gt;MERGED&lt;/code&gt; contains the name of the file to which the merge tool should write the results of a successful merge.</source>
          <target state="translated">指定命令以调用指定的合并工具。在外壳程序中使用以下可用变量评估指定的命令： &lt;code&gt;BASE&lt;/code&gt; 是临时文件的名称，其中包含要合并的文件的公共基础（如果有）； &lt;code&gt;LOCAL&lt;/code&gt; 是包含当前分支上文件内容的临时文件的名称； &lt;code&gt;REMOTE&lt;/code&gt; 是一个临时文件的名称，其中包含来自合并分支的文件内容； &lt;code&gt;MERGED&lt;/code&gt; 包含合并工具应该向其中写入成功合并结果的文件的名称。</target>
        </trans-unit>
        <trans-unit id="6a0cfc4c034bf82c50504b5853ea3a2048b66aa0" translate="yes" xml:space="preserve">
          <source>Specify the default pack index version. Valid values are 1 for legacy pack index used by Git versions prior to 1.5.2, and 2 for the new pack index with capabilities for packs larger than 4 GB as well as proper protection against the repacking of corrupted packs. Version 2 is the default. Note that version 2 is enforced and this config option ignored whenever the corresponding pack is larger than 2 GB.</source>
          <target state="translated">指定默认的数据包索引版本,有效值是1代表Git 1.5.2之前的版本使用的传统数据包索引,2代表新的数据包索引。有效值为1,代表1.5.2之前的Git版本所使用的传统包索引,2代表新的包索引,它能够处理大于4GB的包,并且能够防止损坏的包被重新打包。版本2是默认的。请注意,只要对应的包大于2GB,就会强制执行版本2,并忽略这个配置选项。</target>
        </trans-unit>
        <trans-unit id="237b5a9487d0a4c4f3b292963fb14ac9431d7354" translate="yes" xml:space="preserve">
          <source>Specify the directory from which templates will be copied. (See the &quot;TEMPLATE DIRECTORY&quot; section of &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;.)</source>
          <target state="translated">指定将从中复制模板的目录。（请参见&lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt;的&amp;ldquo;模板目录&amp;rdquo;部分。）</target>
        </trans-unit>
        <trans-unit id="9e017dab9e6089dc4c6b8916eff9198d29b5fa5a" translate="yes" xml:space="preserve">
          <source>Specify the directory from which templates will be used. (See the &quot;TEMPLATE DIRECTORY&quot; section below.)</source>
          <target state="translated">指定使用模板的目录。参见下面的 &quot;TEMPLATE DIRECTORY &quot;部分)。</target>
        </trans-unit>
        <trans-unit id="10fbc8bd7f7f67034717ffef3bdc652592011a96" translate="yes" xml:space="preserve">
          <source>Specify the directory from which templates will be used; (See the &quot;TEMPLATE DIRECTORY&quot; section of &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;.)</source>
          <target state="translated">指定将使用模板的目录；（请参见&lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt;的&amp;ldquo;模板目录&amp;rdquo;部分。）</target>
        </trans-unit>
        <trans-unit id="6d06560706961e8be925ad5b0c5ec94cdc91c729" translate="yes" xml:space="preserve">
          <source>Specify the encryption to use, either &lt;code&gt;ssl&lt;/code&gt; or &lt;code&gt;tls&lt;/code&gt;. Any other value reverts to plain SMTP. Default is the value of &lt;code&gt;sendemail.smtpEncryption&lt;/code&gt;.</source>
          <target state="translated">指定要使用的加密， &lt;code&gt;ssl&lt;/code&gt; 或 &lt;code&gt;tls&lt;/code&gt; 。其他任何值都将恢复为纯SMTP。默认值为 &lt;code&gt;sendemail.smtpEncryption&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="4d476f2efa135b04b0d382124ae1d7eb2f09baec" translate="yes" xml:space="preserve">
          <source>Specify the envelope sender used to send the emails. This is useful if your default address is not the address that is subscribed to a list. In order to use the &lt;code&gt;From&lt;/code&gt; address, set the value to &quot;auto&quot;. If you use the sendmail binary, you must have suitable privileges for the -f parameter. Default is the value of the &lt;code&gt;sendemail.envelopeSender&lt;/code&gt; configuration variable; if that is unspecified, choosing the envelope sender is left to your MTA.</source>
          <target state="translated">指定用于发送电子邮件的信封发件人。如果您的默认地址不是订阅列表的地址，这将很有用。为了使用 &lt;code&gt;From&lt;/code&gt; 地址，请将值设置为&amp;ldquo; auto&amp;rdquo;。如果使用sendmail二进制文件，则必须具有-f参数的适当特权。默认值为 &lt;code&gt;sendemail.envelopeSender&lt;/code&gt; 配置变量的值；如果未指定，则选择信封发件人留给您的MTA。</target>
        </trans-unit>
        <trans-unit id="57154856f70bd26e9f32c73474da174dbb6a71bf" translate="yes" xml:space="preserve">
          <source>Specify the format in which differences in submodules are shown. The &quot;short&quot; format just shows the names of the commits at the beginning and end of the range. The &quot;log&quot; format lists the commits in the range like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;&lt;code&gt;summary&lt;/code&gt; does. The &quot;diff&quot; format shows an inline diff of the changed contents of the submodule. Defaults to &quot;short&quot;.</source>
          <target state="translated">指定显示子模块差异的格式。&amp;ldquo;短&amp;rdquo;格式仅在范围的开头和结尾显示提交的名称。&amp;ldquo;日志&amp;rdquo;格式列出了&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1] &lt;/a&gt; &lt;code&gt;summary&lt;/code&gt; 所做的范围内的提交。&amp;ldquo; diff&amp;rdquo;格式显示子模块的更改内容的内联diff。默认为&amp;ldquo;短&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ee4e54ea6641c26749f683e2086f11110bfcb031" translate="yes" xml:space="preserve">
          <source>Specify the full path of &lt;code&gt;git-upload-pack&lt;/code&gt; on the remote host. This allows listing references from repositories accessed via SSH and where the SSH daemon does not use the PATH configured by the user.</source>
          <target state="translated">在远程主机上指定 &lt;code&gt;git-upload-pack&lt;/code&gt; 的完整路径。这允许列出来自通过SSH访问的存储库中的引用，并且SSH守护程序不使用用户配置的PATH。</target>
        </trans-unit>
        <trans-unit id="06ad205dd66ffad363b165c748636d60b7e9ddfc" translate="yes" xml:space="preserve">
          <source>Specify the given object format (hash algorithm) for the index file. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt;. The default is the algorithm for the current repository (set by &lt;code&gt;extensions.objectFormat&lt;/code&gt;), or &lt;code&gt;sha1&lt;/code&gt; if no value is set or outside a repository..</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b5df638fbdbefd14fe565482082a779d66f41cb" translate="yes" xml:space="preserve">
          <source>Specify the given object format (hash algorithm) for the pack. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt;. The default is the algorithm for the current repository (set by &lt;code&gt;extensions.objectFormat&lt;/code&gt;), or &lt;code&gt;sha1&lt;/code&gt; if no value is set or outside a repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a57f9547f120982212f828efa3a309472cc768" translate="yes" xml:space="preserve">
          <source>Specify the given object format (hash algorithm) for the repository. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt;. &lt;code&gt;sha1&lt;/code&gt; is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642e4180256fc24e29fea6cad40cadddb83843bb" translate="yes" xml:space="preserve">
          <source>Specify the hash algorithm to use. The acceptable values are &lt;code&gt;sha1&lt;/code&gt; and &lt;code&gt;sha256&lt;/code&gt;. If not specified, &lt;code&gt;sha1&lt;/code&gt; is assumed. It is an error to specify this key unless &lt;code&gt;core.repositoryFormatVersion&lt;/code&gt; is 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05f34f2b12543d24deddf183d7f5563e4746b8d" translate="yes" xml:space="preserve">
          <source>Specify the initial subject of the email thread. Only necessary if --compose is also set. If --compose is not set, this will be prompted for.</source>
          <target state="translated">指定邮件线程的初始主题。只有在设置了 --compose 的情况下才需要。如果没有设置--compose,则会提示输入。</target>
        </trans-unit>
        <trans-unit id="7f0e894272a77fe6a04290fbdb329a63eb87bf76" translate="yes" xml:space="preserve">
          <source>Specify the layout when list items in &lt;code&gt;git clean -i&lt;/code&gt;, which always shows files and directories in columns. See &lt;code&gt;column.ui&lt;/code&gt; for details.</source>
          <target state="translated">在 &lt;code&gt;git clean -i&lt;/code&gt; 中列出列表项时指定布局，该布局始终以列显示文件和目录。有关详细信息，请参见 &lt;code&gt;column.ui&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7208179bdf36d6bc3e9b1d1f4f91288e1356b3f" translate="yes" xml:space="preserve">
          <source>Specify the location of the CVS checkout to use for the export. This option does not require GIT_DIR to be set before execution if the current directory is within a Git repository. The default is the value of &lt;code&gt;cvsexportcommit.cvsdir&lt;/code&gt;.</source>
          <target state="translated">指定用于导出的CVS结帐的位置。如果当前目录位于Git存储库中，则此选项不需要在执行之前设置GIT_DIR。缺省值为 &lt;code&gt;cvsexportcommit.cvsdir&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="4c1271576d0edb7f1f0d6c8d0d3f48964a9bd30e" translate="yes" xml:space="preserve">
          <source>Specify the most recent revision to keep. All later revisions are discarded.</source>
          <target state="translated">指定要保留的最新版本。之后的所有修订版都将被丢弃。</target>
        </trans-unit>
        <trans-unit id="dbfd748a4216557f92920425eee493e6f587b7d2" translate="yes" xml:space="preserve">
          <source>Specify the name of a CVS checkout using the -w switch or execute it from the root of the CVS working copy. In the latter case GIT_DIR must be defined. See examples below.</source>
          <target state="translated">使用 -w 开关指定 CVS 检查程序的名称,或者从 CVS 工作副本的根目录下执行它。在后一种情况下,必须定义GIT_DIR。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="6f5685351080bbe842e1b77f6e72d7f56e71124e" translate="yes" xml:space="preserve">
          <source>Specify the path where the HTML documentation resides. File system paths and URLs are supported. HTML pages will be prefixed with this path when help is displayed in the &lt;code&gt;web&lt;/code&gt; format. This defaults to the documentation path of your Git installation.</source>
          <target state="translated">指定HTML文档所在的路径。支持文件系统路径和URL。当以 &lt;code&gt;web&lt;/code&gt; 格式显示帮助时，HTML页面将以该路径作为前缀。这默认为Git安装的文档路径。</target>
        </trans-unit>
        <trans-unit id="3939c032cc21518f83cfc7e855a79944401164b0" translate="yes" xml:space="preserve">
          <source>Specify the pathname of a file to use as the template for new commit messages.</source>
          <target state="translated">指定文件的路径名,作为新提交信息的模板。</target>
        </trans-unit>
        <trans-unit id="626310e55266a25c38521d0786f942652add8252" translate="yes" xml:space="preserve">
          <source>Specify the primary recipient of the emails generated. Generally, this will be the upstream maintainer of the project involved. Default is the value of the &lt;code&gt;sendemail.to&lt;/code&gt; configuration value; if that is unspecified, and --to-cmd is not specified, this will be prompted for.</source>
          <target state="translated">指定生成的电子邮件的主要收件人。通常，这将是所涉及项目的上游维护者。默认值为 &lt;code&gt;sendemail.to&lt;/code&gt; 配置值；如果未指定，并且未指定--to-cmd，则会提示您输入。</target>
        </trans-unit>
        <trans-unit id="904cbddb8fe90053f040a40b660f937c8ee221c5" translate="yes" xml:space="preserve">
          <source>Specify the program that will be used to browse your working repository in gitweb. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">在gitweb中指定将用于浏览您的工作存储库的程序。参见&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87648a4a4b9f3684c45dea895b93d3728e0b89f7" translate="yes" xml:space="preserve">
          <source>Specify the programs that may be used to display help in the &lt;code&gt;man&lt;/code&gt; format. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;.</source>
          <target state="translated">指定可用于以 &lt;code&gt;man&lt;/code&gt; 格式显示帮助的程序。参见&lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c051775f78daae77408669a949bcd688ddbd949c" translate="yes" xml:space="preserve">
          <source>Specify the restore location. If neither option is specified, by default the working tree is restored. Specifying &lt;code&gt;--staged&lt;/code&gt; will only restore the index. Specifying both restores both.</source>
          <target state="translated">指定还原位置。如果未指定任何选项，则默认情况下将还原工作树。指定 &lt;code&gt;--staged&lt;/code&gt; 将仅还原索引。同时指定两个都将恢复。</target>
        </trans-unit>
        <trans-unit id="95b7f682630cddb98a68355ef07c41860159997c" translate="yes" xml:space="preserve">
          <source>Specify the sender of the emails. If not specified on the command line, the value of the &lt;code&gt;sendemail.from&lt;/code&gt; configuration option is used. If neither the command-line option nor &lt;code&gt;sendemail.from&lt;/code&gt; are set, then the user will be prompted for the value. The default for the prompt will be the value of GIT_AUTHOR_IDENT, or GIT_COMMITTER_IDENT if that is not set, as returned by &quot;git var -l&quot;.</source>
          <target state="translated">指定电子邮件的发件人。如果未在命令行上指定，则使用 &lt;code&gt;sendemail.from&lt;/code&gt; 配置选项的值。如果既未设置命令行选项也 &lt;code&gt;sendemail.from&lt;/code&gt; 设置sendemail.from，则将提示用户输入该值。提示的默认值为GIT_AUTHOR_IDENT或GIT_COMMITTER_IDENT的值（如果未设置），由&amp;ldquo; git var -l&amp;rdquo;返回。</target>
        </trans-unit>
        <trans-unit id="8cba2f98ceccc0dae91e3c30287bb75513f4e951" translate="yes" xml:space="preserve">
          <source>Specify the style in which conflicted hunks are written out to working tree files upon merge. The default is &quot;merge&quot;, which shows a &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; conflict marker, changes made by one side, a &lt;code&gt;=======&lt;/code&gt; marker, changes made by the other side, and then a &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; marker. An alternate style, &quot;diff3&quot;, adds a &lt;code&gt;|||||||&lt;/code&gt; marker and the original text before the &lt;code&gt;=======&lt;/code&gt; marker.</source>
          <target state="translated">指定在合并时将冲突的块块写出到工作树文件中的样式。默认值为&amp;ldquo;合并&amp;rdquo;，它显示一个 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; &amp;lt;冲突标记，一侧进行更改，一个 &lt;code&gt;=======&lt;/code&gt; =标记，另一侧进行更改，然后显示 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 标记。替代样式&amp;ldquo; diff3&amp;rdquo;添加 &lt;code&gt;|||||||&lt;/code&gt; |标记和 &lt;code&gt;=======&lt;/code&gt; 标记之前的原始文本。</target>
        </trans-unit>
        <trans-unit id="d1c5be6270e8c898e52c9ccc68e940ca06ec404b" translate="yes" xml:space="preserve">
          <source>Specify the system that is used for large (binary) files. Please note that large file systems do not support the &lt;code&gt;git p4 submit&lt;/code&gt; command. Only Git LFS is implemented right now (see &lt;a href=&quot;https://git-lfs.github.com/&quot;&gt;https://git-lfs.github.com/&lt;/a&gt; for more information). Download and install the Git LFS command line extension to use this option and configure it like this:</source>
          <target state="translated">指定用于大型（二进制）文件的系统。请注意，大型文件系统不支持 &lt;code&gt;git p4 submit&lt;/code&gt; 命令。现在仅实现了Git LFS（有关更多信息，请参见&lt;a href=&quot;https://git-lfs.github.com/&quot;&gt;https://git-lfs.github.com/&lt;/a&gt;）。下载并安装Git LFS命令行扩展以使用此选项并进行如下配置：</target>
        </trans-unit>
        <trans-unit id="d0eef78fea38d4df295115dcb10e8e7ee7e56973" translate="yes" xml:space="preserve">
          <source>Specify the terminal width. By default &lt;code&gt;git column&lt;/code&gt; will detect the terminal width, or fall back to 80 if it is unable to do so.</source>
          <target state="translated">指定端子宽度。默认情况下， &lt;code&gt;git column&lt;/code&gt; 将检测终端宽度，如果无法检测则退回到80。</target>
        </trans-unit>
        <trans-unit id="724bb2755b4bad5b8b472dcd4850810c5212797c" translate="yes" xml:space="preserve">
          <source>Specify the transfer encoding to be used to send the message over SMTP. 7bit will fail upon encountering a non-ASCII message. quoted-printable can be useful when the repository contains files that contain carriage returns, but makes the raw patch email file (as saved from a MUA) much harder to inspect manually. base64 is even more fool proof, but also even more opaque. auto will use 8bit when possible, and quoted-printable otherwise.</source>
          <target state="translated">指定用于通过SMTP发送邮件的传输编码。7bit会在遇到非ASCII信息时失败。当存储库包含包含回车的文件时,加引号的可打印编码会很有用,但会使原始的补丁邮件文件(从MUA保存的)更难手动检查。base64更容易被发现,但也更不透明。</target>
        </trans-unit>
        <trans-unit id="9612f0c17aac603d9a46ca6cb5d976f3bf4c5bf3" translate="yes" xml:space="preserve">
          <source>Specify the type (default: &quot;blob&quot;).</source>
          <target state="translated">指定类型(默认:&quot;blob&quot;)。</target>
        </trans-unit>
        <trans-unit id="13769f1d436d268baed7051a7c066221785b088a" translate="yes" xml:space="preserve">
          <source>Specify the type of dates the frontend will supply to fast-import within &lt;code&gt;author&lt;/code&gt;, &lt;code&gt;committer&lt;/code&gt; and &lt;code&gt;tagger&lt;/code&gt; commands. See &amp;ldquo;Date Formats&amp;rdquo; below for details about which formats are supported, and their syntax.</source>
          <target state="translated">在 &lt;code&gt;author&lt;/code&gt; ， &lt;code&gt;committer&lt;/code&gt; 和 &lt;code&gt;tagger&lt;/code&gt; 命令中指定前端提供给快速导入的日期的类型。有关支持哪些格式及其语法的详细信息，请参见下面的&amp;ldquo;日期格式&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="19ebff060f03d17e125a48bf86da29f25cd1bf35" translate="yes" xml:space="preserve">
          <source>Specify the version with which new index files should be initialized. This does not affect existing repositories. If &lt;code&gt;feature.manyFiles&lt;/code&gt; is enabled, then the default is 4.</source>
          <target state="translated">指定用于初始化新索引文件的版本。这不会影响现有存储库。如果启用 &lt;code&gt;feature.manyFiles&lt;/code&gt; ，则默认值为4。</target>
        </trans-unit>
        <trans-unit id="1dcaca1644c579ca7480d7fe912a3d5f89533d59" translate="yes" xml:space="preserve">
          <source>Specify what action will be performed when there is already at least one trailer with the same &amp;lt;token&amp;gt; in the message. A setting provided with &lt;code&gt;--if-exists&lt;/code&gt; overrides all configuration variables and applies to all &lt;code&gt;--trailer&lt;/code&gt; options until the next occurrence of &lt;code&gt;--if-exists&lt;/code&gt; or &lt;code&gt;--no-if-exists&lt;/code&gt;. Possible actions are &lt;code&gt;addIfDifferent&lt;/code&gt;, &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; and &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">指定消息中已经存在至少一个具有相同&amp;lt;token&amp;gt;的预告片时将执行的操作。 &lt;code&gt;--if-exists&lt;/code&gt; 随附的设置会覆盖所有配置变量，并应用于所有 &lt;code&gt;--trailer&lt;/code&gt; 选项，直到下次出现 &lt;code&gt;--if-exists&lt;/code&gt; 或 &lt;code&gt;--no-if-exists&lt;/code&gt; 为止。可能的操作是 &lt;code&gt;addIfDifferent&lt;/code&gt; ， &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; ， &lt;code&gt;add&lt;/code&gt; ， &lt;code&gt;replace&lt;/code&gt; 和 &lt;code&gt;doNothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0811642f4a0657e779f7ae4b567538044cd6208f" translate="yes" xml:space="preserve">
          <source>Specify what action will be performed when there is no other trailer with the same &amp;lt;token&amp;gt; in the message. A setting provided with &lt;code&gt;--if-missing&lt;/code&gt; overrides all configuration variables and applies to all &lt;code&gt;--trailer&lt;/code&gt; options until the next occurrence of &lt;code&gt;--if-missing&lt;/code&gt; or &lt;code&gt;--no-if-missing&lt;/code&gt;. Possible actions are &lt;code&gt;doNothing&lt;/code&gt; or &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">指定在消息中没有其他具有相同&amp;lt;token&amp;gt;的预告片时将执行的操作。 &lt;code&gt;--if-missing&lt;/code&gt; 提供的设置将覆盖所有配置变量，并应用于所有 &lt;code&gt;--trailer&lt;/code&gt; 选项，直到下次出现 &lt;code&gt;--if-missing&lt;/code&gt; 或 &lt;code&gt;--no-if-missing&lt;/code&gt; 为止。可能的操作是 &lt;code&gt;doNothing&lt;/code&gt; 或 &lt;code&gt;add&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d686969af43bc9772a0a2bdde0f0d6918dfd1d4" translate="yes" xml:space="preserve">
          <source>Specify what destination ref to update with what source object. The format of a &amp;lt;refspec&amp;gt; parameter is an optional plus &lt;code&gt;+&lt;/code&gt;, followed by the source object &amp;lt;src&amp;gt;, followed by a colon &lt;code&gt;:&lt;/code&gt;, followed by the destination ref &amp;lt;dst&amp;gt;.</source>
          <target state="translated">指定要使用哪个源对象更新的目标引用。&amp;lt;refspec&amp;gt;参数的格式是可选的plus &lt;code&gt;+&lt;/code&gt; ，后跟源对象&amp;lt;src&amp;gt;，后跟冒号 &lt;code&gt;:&lt;/code&gt; ，然后是目标ref &amp;lt;dst&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="6138b51fead99efbf1d6930137f2b387251ef604" translate="yes" xml:space="preserve">
          <source>Specify where all new trailers will be added. A setting provided with &lt;code&gt;--where&lt;/code&gt; overrides all configuration variables and applies to all &lt;code&gt;--trailer&lt;/code&gt; options until the next occurrence of &lt;code&gt;--where&lt;/code&gt; or &lt;code&gt;--no-where&lt;/code&gt;. Possible values are &lt;code&gt;after&lt;/code&gt;, &lt;code&gt;before&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt; or &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">指定将所有新预告片添加到的位置。设置有设定 &lt;code&gt;--where&lt;/code&gt; 覆盖所有配置变量，适用于所有 &lt;code&gt;--trailer&lt;/code&gt; 选项，直到下一次出现 &lt;code&gt;--where&lt;/code&gt; 或 &lt;code&gt;--no-where&lt;/code&gt; 。可能的值是 &lt;code&gt;after&lt;/code&gt; ， &lt;code&gt;before&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; 或 &lt;code&gt;start&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9446eb9819e4ea522bac17e494630aff8d54bebb" translate="yes" xml:space="preserve">
          <source>Specify whether supported commands should output in columns. This variable consists of a list of tokens separated by spaces or commas:</source>
          <target state="translated">指定支持的命令是否应该以列的形式输出。这个变量由一个用空格或逗号分隔的标记列表组成。</target>
        </trans-unit>
        <trans-unit id="c44825f076cf0385d99447ca6f9388f9e5d821d6" translate="yes" xml:space="preserve">
          <source>Specify whether to output branch listing in &lt;code&gt;git branch&lt;/code&gt; in columns. See &lt;code&gt;column.ui&lt;/code&gt; for details.</source>
          <target state="translated">在列的 &lt;code&gt;git branch&lt;/code&gt; 中指定是否输出分支列表。有关详细信息，请参见 &lt;code&gt;column.ui&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb8ddb4258375ad9322849684e1d07ab6e005bcd" translate="yes" xml:space="preserve">
          <source>Specify whether to output tag listing in &lt;code&gt;git tag&lt;/code&gt; in columns. See &lt;code&gt;column.ui&lt;/code&gt; for details.</source>
          <target state="translated">指定是否在 &lt;code&gt;git tag&lt;/code&gt; 的列中输出标签列表。有关详细信息，请参见 &lt;code&gt;column.ui&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7607c69174b01d1bb15ae17f25fe8a2d96f9d58f" translate="yes" xml:space="preserve">
          <source>Specify whether to output untracked files in &lt;code&gt;git status&lt;/code&gt; in columns. See &lt;code&gt;column.ui&lt;/code&gt; for details.</source>
          <target state="translated">指定是否以 &lt;code&gt;git status&lt;/code&gt; 列输出未跟踪的文件。有关详细信息，请参见 &lt;code&gt;column.ui&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b984e35657451690beb2903dd3dd6390cb372f55" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;--no-symlinks&lt;/code&gt; instructs &lt;code&gt;git difftool&lt;/code&gt; to create copies instead. &lt;code&gt;--no-symlinks&lt;/code&gt; is the default on Windows.</source>
          <target state="translated">指定 &lt;code&gt;--no-symlinks&lt;/code&gt; 指示 &lt;code&gt;git difftool&lt;/code&gt; 创建副本。 &lt;code&gt;--no-symlinks&lt;/code&gt; 是Windows上的默认设置。</target>
        </trans-unit>
        <trans-unit id="3b6b4914f3cbc4ad3df641c0c4177b0ed1427ac9" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;-b&lt;/code&gt; causes a new branch to be created as if &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; were called and then checked out. In this case you can use the &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--no-track&lt;/code&gt; options, which will be passed to &lt;code&gt;git branch&lt;/code&gt;. As a convenience, &lt;code&gt;--track&lt;/code&gt; without &lt;code&gt;-b&lt;/code&gt; implies branch creation; see the description of &lt;code&gt;--track&lt;/code&gt; below.</source>
          <target state="translated">指定 &lt;code&gt;-b&lt;/code&gt; 将导致创建新分支，就像调用&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;然后将其检出一样。在这种情况下，您可以使用 &lt;code&gt;--track&lt;/code&gt; 或 &lt;code&gt;--no-track&lt;/code&gt; 选项，这些选项将传递给 &lt;code&gt;git branch&lt;/code&gt; 。为方便起见，不带 &lt;code&gt;-b&lt;/code&gt; 的 &lt;code&gt;--track&lt;/code&gt; 表示创建分支；请参阅下面的 &lt;code&gt;--track&lt;/code&gt; 说明。</target>
        </trans-unit>
        <trans-unit id="3d1224dfe57ea23830be77ce6389d9ea1f14e370" translate="yes" xml:space="preserve">
          <source>Specifying ranges</source>
          <target state="translated">指定范围</target>
        </trans-unit>
        <trans-unit id="c7c8ec2e47baa0d09987a0c4d6001b20abaaf2b4" translate="yes" xml:space="preserve">
          <source>Specifying references</source>
          <target state="translated">指定参考文献</target>
        </trans-unit>
        <trans-unit id="393f3ea7b8cd86c4b234c1534e51343677169802" translate="yes" xml:space="preserve">
          <source>Specifying revisions</source>
          <target state="translated">指定修订</target>
        </trans-unit>
        <trans-unit id="313d53ccb2201ad1fa56898f5e4fcf52a12b8cf8" translate="yes" xml:space="preserve">
          <source>Specifying revisions and ranges for Git</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c37f7a18e7a3b3fd20a0b124dbe1485c84e7ed4" translate="yes" xml:space="preserve">
          <source>Specifying several revisions means the set of commits reachable from any of the given commits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e60ddbfcfcb7ed6ee3dbb9222a892aaa26a36d" translate="yes" xml:space="preserve">
          <source>Specifying the location of the &quot;.git&quot; directory using this option (or &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable) turns off the repository discovery that tries to find a directory with &quot;.git&quot; subdirectory (which is how the repository and the top-level of the working tree are discovered), and tells Git that you are at the top level of the working tree. If you are not at the top-level directory of the working tree, you should tell Git where the top-level of the working tree is, with the &lt;code&gt;--work-tree=&amp;lt;path&amp;gt;&lt;/code&gt; option (or &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; environment variable)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12054d536cbd9889e1a4db4d75b48d8a7f03cd2" translate="yes" xml:space="preserve">
          <source>Specifying the refs</source>
          <target state="translated">指定裁判</target>
        </trans-unit>
        <trans-unit id="31f2abfdb1a3e7bab64495f843d089d388ea45e0" translate="yes" xml:space="preserve">
          <source>Spend extra cycles to find renames, copies and complete rewrites (very expensive).</source>
          <target state="translated">花费额外的周期去寻找重名、副本和完成改写(非常昂贵)。</target>
        </trans-unit>
        <trans-unit id="6b695c34f0798ffd5026fe42cf041af8a841d861" translate="yes" xml:space="preserve">
          <source>Spend extra time to make sure the smallest possible diff is produced.</source>
          <target state="translated">花额外的时间来确保产生最小的差异。</target>
        </trans-unit>
        <trans-unit id="8622c4dc8f748203e018cc0d2ec4e20b07c9830d" translate="yes" xml:space="preserve">
          <source>Split a commit apart into a sequence of commits</source>
          <target state="translated">将一个提交分割成一系列的提交。</target>
        </trans-unit>
        <trans-unit id="9da7a78d6cd0199fb3cad874edd1ba683b830e12" translate="yes" xml:space="preserve">
          <source>Split index</source>
          <target state="translated">拆分指数</target>
        </trans-unit>
        <trans-unit id="704e5487b89b9b30fcd9e576ab8763e642a1b938" translate="yes" xml:space="preserve">
          <source>Splits a mbox file or a Maildir into a list of files: &quot;0001&quot; &quot;0002&quot; .. in the specified directory so you can process them further from there.</source>
          <target state="translated">将一个mbox文件或一个Maildir分割成一个文件列表。&quot;0001&quot;&quot;0002&quot;......在指定的目录下,所以你可以从那里进一步处理它们。</target>
        </trans-unit>
        <trans-unit id="30bc5e98fc4346f828d1d387cd6e1c89bab7df56" translate="yes" xml:space="preserve">
          <source>Splits mail messages in a mailbox into commit log message, authorship information and patches, and applies them to the current branch.</source>
          <target state="translated">将邮箱中的邮件信息拆分为提交日志信息、作者信息和补丁,并应用到当前分支。</target>
        </trans-unit>
        <trans-unit id="05a6d55bcdcfd4539a8e45cc0dd3c2f28f1895ad" translate="yes" xml:space="preserve">
          <source>Splitting a (logically single) project into multiple repositories and tying them back together. This can be used to overcome current limitations of Git&amp;rsquo;s implementation to have finer grained access:</source>
          <target state="translated">将一个（逻辑上单一的）项目拆分为多个存储库，并将其重新绑定在一起。这可以用来克服Git实现的当前限制，以实现更细粒度的访问：</target>
        </trans-unit>
        <trans-unit id="dca5d29240b446b8bdd6f26fb0b4e46cb995769f" translate="yes" xml:space="preserve">
          <source>Splitting commits</source>
          <target state="translated">分割承诺</target>
        </trans-unit>
        <trans-unit id="ab83ac1fcfed8f50260b11e517c47e9b533419b5" translate="yes" xml:space="preserve">
          <source>Splitting the CVS log into patch sets is done by &lt;code&gt;cvsps&lt;/code&gt;. At least version 2.1 is required.</source>
          <target state="translated">将CVS日志分为补丁集是由 &lt;code&gt;cvsps&lt;/code&gt; 完成的。至少需要版本2.1。</target>
        </trans-unit>
        <trans-unit id="a74a609811ea3b4041281496e2aa5c500ba6558b" translate="yes" xml:space="preserve">
          <source>Sq-quote</source>
          <target state="translated">Sq-quote</target>
        </trans-unit>
        <trans-unit id="d3e10219341e654fff6647b0dadeaeaf0534cae6" translate="yes" xml:space="preserve">
          <source>Squelch the progress indicator.</source>
          <target state="translated">压制进度指标。</target>
        </trans-unit>
        <trans-unit id="56175f21751e04201e148f2612c700747850548a" translate="yes" xml:space="preserve">
          <source>Start &lt;code&gt;git gui&lt;/code&gt; and arrange to make exactly one commit before exiting and returning to the shell. The interface is limited to only commit actions, slightly reducing the application&amp;rsquo;s startup time and simplifying the menubar.</source>
          <target state="translated">启动 &lt;code&gt;git gui&lt;/code&gt; 并安排在退出并返回shell之前进行一次完全提交。该界面仅限于提交操作，从而略微减少了应用程序的启动时间并简化了菜单栏。</target>
        </trans-unit>
        <trans-unit id="1ad6edca0ad31761798d28bd8f2bcba01ec6ebde" translate="yes" xml:space="preserve">
          <source>Start a blame viewer on the specified file on the given version (or working directory if not specified).</source>
          <target state="translated">在给定的版本(或未指定的工作目录)上对指定的文件启动一个责难查看器。</target>
        </trans-unit>
        <trans-unit id="27818282f52d064df23dffafcd6a743ee7870fc8" translate="yes" xml:space="preserve">
          <source>Start a new Git repository for an existing code base</source>
          <target state="translated">为现有的代码库启动一个新的 Git 仓库。</target>
        </trans-unit>
        <trans-unit id="dbad6a143691392b17e55eedf5d0cc7e518343d6" translate="yes" xml:space="preserve">
          <source>Start a transaction. In contrast to a non-transactional session, a transaction will automatically abort if the session ends without an explicit commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="749535e22d531edd1c6d9e666c57e169bc2a2908" translate="yes" xml:space="preserve">
          <source>Start a tree browser showing all files in the specified commit. Files selected through the browser are opened in the blame viewer.</source>
          <target state="translated">启动树形浏览器,显示指定提交中的所有文件。通过浏览器选择的文件会在责难查看器中打开。</target>
        </trans-unit>
        <trans-unit id="4f65c13509b4c270214524b3ab095bad926fc4e3" translate="yes" xml:space="preserve">
          <source>Start an interactive rebase with &lt;code&gt;git rebase -i &amp;lt;commit&amp;gt;^&lt;/code&gt;, where &amp;lt;commit&amp;gt; is the commit you want to split. In fact, any commit range will do, as long as it contains that commit.</source>
          <target state="translated">使用 &lt;code&gt;git rebase -i &amp;lt;commit&amp;gt;^&lt;/code&gt; 启动交互式rebase ，其中&amp;lt;commit&amp;gt;是要拆分的提交。实际上，任何提交范围都可以，只要它包含该提交即可。</target>
        </trans-unit>
        <trans-unit id="e89944344f3db8073a18706746155c852e5164e1" translate="yes" xml:space="preserve">
          <source>Start cleaning files and directories, and then quit.</source>
          <target state="translated">开始清理文件和目录,然后退出。</target>
        </trans-unit>
        <trans-unit id="b87ef51ca99e7074691b94843e801ff9544539ca" translate="yes" xml:space="preserve">
          <source>Start development from a known tag</source>
          <target state="translated">从已知标签开始开发</target>
        </trans-unit>
        <trans-unit id="57f8f31bd16af3371648ce77ae5076e70d2a7e21" translate="yes" xml:space="preserve">
          <source>Start it with the last commit you want to retain as-is:</source>
          <target state="translated">从你想保留原样的最后一个提交开始。</target>
        </trans-unit>
        <trans-unit id="2deb883b26612605cc58ed80bbd657e3f5419b69" translate="yes" xml:space="preserve">
          <source>Start numbering the patches at &amp;lt;n&amp;gt; instead of 1.</source>
          <target state="translated">从&amp;lt;n&amp;gt;而不是1开始编号补丁。</target>
        </trans-unit>
        <trans-unit id="f25f51b92f6dabcbe2c2bbe2f01c2d471018dd10" translate="yes" xml:space="preserve">
          <source>Start off with just creating any random files that you want to maintain in your Git repository. We&amp;rsquo;ll start off with a few bad examples, just to get a feel for how this works:</source>
          <target state="translated">首先创建仅要在Git存储库中维护的任何随机文件。我们将从一些不好的例子开始，只是为了了解它是如何工作的：</target>
        </trans-unit>
        <trans-unit id="93ea699c6796ebb7b82a3a5927dc702e8f1a7316" translate="yes" xml:space="preserve">
          <source>Start the httpd instance and exit. Regenerate configuration files as necessary for spawning a new instance.</source>
          <target state="translated">启动 httpd 实例并退出。根据需要重新生成配置文件以生成新的实例。</target>
        </trans-unit>
        <trans-unit id="4e8cde71c6f29e3b4dc0142edc8a7bdf1a0bc89b" translate="yes" xml:space="preserve">
          <source>Start the stream with a &lt;code&gt;feature done&lt;/code&gt; stanza, and terminate it with a &lt;code&gt;done&lt;/code&gt; command.</source>
          <target state="translated">使用 &lt;code&gt;feature done&lt;/code&gt; 节开始流，并使用 &lt;code&gt;done&lt;/code&gt; 命令终止流。</target>
        </trans-unit>
        <trans-unit id="96e592387dc94e730df0ef669b5a78ed012d4c94" translate="yes" xml:space="preserve">
          <source>Starting a bisection</source>
          <target state="translated">开始分段</target>
        </trans-unit>
        <trans-unit id="b8f1956c80187223247d01b968f642bf0007a014" translate="yes" xml:space="preserve">
          <source>Starting point at which to create the new commits. If the --onto option is not specified, the starting point is &amp;lt;upstream&amp;gt;. May be any valid commit, and not just an existing branch name.</source>
          <target state="translated">创建新提交的起点。如果未指定--onto选项，则起始点为&amp;lt;上游&amp;gt;。可以是任何有效的提交，而不仅仅是现有的分支名称。</target>
        </trans-unit>
        <trans-unit id="b2a5514cb8b0c290a6aeca31b2e191aff35672b1" translate="yes" xml:space="preserve">
          <source>Stash the changes in a dirty working directory away</source>
          <target state="translated">把修改的内容藏在一个肮脏的工作目录中。</target>
        </trans-unit>
        <trans-unit id="9b5a6df7ffb5f85d09cbb9082f2a407aa81ca866" translate="yes" xml:space="preserve">
          <source>State directories: The two backends keep their state in different directories under .git/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb935cbc47e1b75159f277e4b22bfc5de7bbee9" translate="yes" xml:space="preserve">
          <source>Static configuration of usernames for a given authentication context.</source>
          <target state="translated">为给定的认证上下文静态配置用户名。</target>
        </trans-unit>
        <trans-unit id="20520ab082263228efd3ab7ffc11e41906666da4" translate="yes" xml:space="preserve">
          <source>Status letters C and R are always followed by a score (denoting the percentage of similarity between the source and target of the move or copy). Status letter M may be followed by a score (denoting the percentage of dissimilarity) for file rewrites.</source>
          <target state="translated">状态字母 C 和 R 后面总是跟着一个分数(表示移动或复制的源和目标之间相似性的百分比)。对于文件改写,状态字母M后面可能会有一个分数(表示相似性的百分比)。</target>
        </trans-unit>
        <trans-unit id="5910dfc64a273edb8d032604ca6d54bef3bf2f4e" translate="yes" xml:space="preserve">
          <source>Stop the httpd instance and exit. This does not generate any of the configuration files for spawning a new instance, nor does it close the browser.</source>
          <target state="translated">停止 httpd 实例并退出。这不会生成任何用于生成新实例的配置文件,也不会关闭浏览器。</target>
        </trans-unit>
        <trans-unit id="12d3bab755f474b20ad13c1ab918e01e5f4eb7c4" translate="yes" xml:space="preserve">
          <source>Stop when a given path disappears from the tree.</source>
          <target state="translated">当某个路径从树上消失时,停止。</target>
        </trans-unit>
        <trans-unit id="7363904e3ee0fd364e644f2e1b28c12dd383e027" translate="yes" xml:space="preserve">
          <source>Storage format</source>
          <target state="translated">存储格式</target>
        </trans-unit>
        <trans-unit id="9ff8274c9fcae633894b9e7ab1c37fd6e74f1f7a" translate="yes" xml:space="preserve">
          <source>Store Git commit times in the local time zone instead of UTC. This makes &lt;code&gt;git log&lt;/code&gt; (even without --date=local) show the same times that &lt;code&gt;svn log&lt;/code&gt; would in the local time zone.</source>
          <target state="translated">将Git提交时间存储在本地时区而不是UTC中。这使得 &lt;code&gt;git log&lt;/code&gt; （甚至没有--date = local）显示的时间与 &lt;code&gt;svn log&lt;/code&gt; 在本地时区的显示时间相同。</target>
        </trans-unit>
        <trans-unit id="c403801561a0441c1d742dd0499050f55d110cd9" translate="yes" xml:space="preserve">
          <source>Store a given stash created via &lt;code&gt;git stash create&lt;/code&gt; (which is a dangling merge commit) in the stash ref, updating the stash reflog. This is intended to be useful for scripts. It is probably not the command you want to use; see &quot;push&quot; above.</source>
          <target state="translated">将通过 &lt;code&gt;git stash create&lt;/code&gt; （这是一个悬空的合并提交）创建的给定存储存储在存储参考中，以更新存储参考日志。旨在对脚本有用。它可能不是您要使用的命令；请参阅上方的&amp;ldquo;推送&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b41300dc42c243e3949e2ecb7a4c10aea769103e" translate="yes" xml:space="preserve">
          <source>Store credentials indefinitely on disk. See &lt;a href=&quot;git-credential-store&quot;&gt;git-credential-store[1]&lt;/a&gt; for details.</source>
          <target state="translated">将凭据无限期地存储在磁盘上。有关详细信息，请参见&lt;a href=&quot;git-credential-store&quot;&gt;git-credential-store [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03384c8a5477964f7bc214ed7cbcde0772bb7755" translate="yes" xml:space="preserve">
          <source>Store the credential, if applicable to the helper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5597429620f06451a38a8e17b35a345310b01123" translate="yes" xml:space="preserve">
          <source>Store the fetched branch into a local branch before merging into the current branch:</source>
          <target state="translated">在合并到当前分支之前,将获取的分支存储到本地分支中。</target>
        </trans-unit>
        <trans-unit id="687760eb98a14d7d5a6fbbba834cf9ccaaf83ea1" translate="yes" xml:space="preserve">
          <source>Store the files instead of deflating them.</source>
          <target state="translated">存储文件,而不是放气。</target>
        </trans-unit>
        <trans-unit id="1512a579e2c05cbf63724a7c8d50327696297b00" translate="yes" xml:space="preserve">
          <source>Stores a set of &quot;objects&quot;, and an individual &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; is identified by its &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt;. The objects usually live in &lt;code&gt;$GIT_DIR/objects/&lt;/code&gt;.</source>
          <target state="translated">存储一组&amp;ldquo;对象&amp;rdquo;，并通过其&lt;a href=&quot;#def_object_name&quot;&gt;对象名称&lt;/a&gt;标识单个&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;。这些对象通常位于 &lt;code&gt;$GIT_DIR/objects/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6349a625008b244d26dbb9000ad7480816812a5" translate="yes" xml:space="preserve">
          <source>Stores shorthands for URL and default refnames for use when interacting with remote repositories via &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; commands. See the REMOTES section in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; for details. This mechanism is legacy and not likely to be found in modern repositories. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/remotes&quot; will be used instead.</source>
          <target state="translated">存储通过 &lt;code&gt;git fetch&lt;/code&gt; ， &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git push&lt;/code&gt; 命令与远程存储库进行交互时使用的URL速记和默认refname 。有关详细信息，请参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]中&lt;/a&gt;的REMOTES部分。这种机制是遗留的，不太可能在现代存储库中找到。如果设置了$ GIT_COMMON_DIR，将忽略该目录，而将使用&amp;ldquo; $ GIT_COMMON_DIR / remotes&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="39f2d5fc66110ba4ba0f8069c43a058a9f84529f" translate="yes" xml:space="preserve">
          <source>Storing multiple repositories as namespaces of a single repository avoids storing duplicate copies of the same objects, such as when storing multiple branches of the same source. The alternates mechanism provides similar support for avoiding duplicates, but alternates do not prevent duplication between new objects added to the repositories without ongoing maintenance, while namespaces do.</source>
          <target state="translated">将多个存储库作为单一存储库的命名空间来存储,可以避免存储相同对象的重复拷贝,例如存储同一源的多个分支时。交替机制为避免重复提供了类似的支持,但交替机制并不能防止在没有持续维护的情况下添加到存储库的新对象之间的重复,而命名空间则可以。</target>
        </trans-unit>
        <trans-unit id="ca1c76454e0d7e7718b023221d2b0aad3d2a1aba" translate="yes" xml:space="preserve">
          <source>Stream Comments</source>
          <target state="translated">流评论</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="5ab8d5b6efb1646dea2e4ea7d3282e3cb65c24cb" translate="yes" xml:space="preserve">
          <source>String to be printed at the beginning of each line.</source>
          <target state="translated">每行开头要打印的字符串。</target>
        </trans-unit>
        <trans-unit id="382f9b3217a7726b3a52ca62702799f6d5434b48" translate="yes" xml:space="preserve">
          <source>String to be printed at the end of each line, including newline character.</source>
          <target state="translated">每行末尾打印的字符串,包括换行符。</target>
        </trans-unit>
        <trans-unit id="ae0208ff14e492381101b38c4426143fc9d98dd6" translate="yes" xml:space="preserve">
          <source>String(s) &lt;code&gt;receive-pack&lt;/code&gt; and &lt;code&gt;upload-pack&lt;/code&gt; use to decide which refs to omit from their initial advertisements. Use more than one definition to specify multiple prefix strings. A ref that is under the hierarchies listed in the value of this variable is excluded, and is hidden when responding to &lt;code&gt;git push&lt;/code&gt; or &lt;code&gt;git
fetch&lt;/code&gt;. See &lt;code&gt;receive.hideRefs&lt;/code&gt; and &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; for program-specific versions of this config.</source>
          <target state="translated">字符串 &lt;code&gt;receive-pack&lt;/code&gt; 和 &lt;code&gt;upload-pack&lt;/code&gt; 用于确定从其初始广告中省略哪些引用。使用多个定义来指定多个前缀字符串。在此变量的值中列出的层次结构下的ref被排除，并且在响应 &lt;code&gt;git push&lt;/code&gt; 或 &lt;code&gt;git fetch&lt;/code&gt; 时被隐藏。有关此配置的程序特定版本，请参见 &lt;code&gt;receive.hideRefs&lt;/code&gt; 和 &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd5fa82aac351e4a1096fc62004ba110d66fe810" translate="yes" xml:space="preserve">
          <source>Strip leading and trailing empty lines, trailing whitespace, commentary and collapse consecutive empty lines.</source>
          <target state="translated">剥离前导和尾部空行、尾部空白、注释和折叠连续的空行。</target>
        </trans-unit>
        <trans-unit id="7c8cf84261f17414d41a19324152deb0638ecb13" translate="yes" xml:space="preserve">
          <source>Subcommands</source>
          <target state="translated">Subcommands</target>
        </trans-unit>
        <trans-unit id="2dacf65959849884a011f36f76a04eebea94c5ea" translate="yes" xml:space="preserve">
          <source>Submit</source>
          <target state="translated">Submit</target>
        </trans-unit>
        <trans-unit id="f3de51d87e152838b373a65e626718325c16a058" translate="yes" xml:space="preserve">
          <source>Submit only the specified commit or range of commits, instead of the full list of changes that are in the current Git branch.</source>
          <target state="translated">只提交指定的提交或提交范围,而不是提交当前 Git 分支中的全部变更。</target>
        </trans-unit>
        <trans-unit id="08c8f65685b697a18634ff4dd66ae0c7b7f8944c" translate="yes" xml:space="preserve">
          <source>Submit options</source>
          <target state="translated">提交选项</target>
        </trans-unit>
        <trans-unit id="3e96d88de40c1b4ce507f5624d2a7a2ae94fe14f" translate="yes" xml:space="preserve">
          <source>Submit variables</source>
          <target state="translated">提交变量</target>
        </trans-unit>
        <trans-unit id="0213e9a40d8de329179170c49c9f0b36b9c8f25d" translate="yes" xml:space="preserve">
          <source>Submit your commits back to p4:</source>
          <target state="translated">将你的提交回p4。</target>
        </trans-unit>
        <trans-unit id="45b948a665e37752fe7a51975e7be3fc7f05181f" translate="yes" xml:space="preserve">
          <source>Submitting changes from a Git repository back to the p4 repository requires a separate p4 client workspace. This should be specified using the &lt;code&gt;P4CLIENT&lt;/code&gt; environment variable or the Git configuration variable &lt;code&gt;git-p4.client&lt;/code&gt;. The p4 client must exist, but the client root will be created and populated if it does not already exist.</source>
          <target state="translated">将更改从Git存储库提交回p4存储库需要一个单独的p4客户端工作空间。应该使用 &lt;code&gt;P4CLIENT&lt;/code&gt; 环境变量或Git配置变量 &lt;code&gt;git-p4.client&lt;/code&gt; 来指定。p4客户端必须存在，但如果客户端根目录尚不存在，则会创建该根目录并进行填充。</target>
        </trans-unit>
        <trans-unit id="6fdf0bad4a57f28ad8887a6fe4e3d9618491f48f" translate="yes" xml:space="preserve">
          <source>Submitting patches to a project</source>
          <target state="translated">提交补丁到项目</target>
        </trans-unit>
        <trans-unit id="d2d7b7a6dabf5680ef6fc53443124ea60acd88af" translate="yes" xml:space="preserve">
          <source>Submitting requires a p4 client, which is not in the same location as the Git repository. Patches are applied, one at a time, to this p4 client and submitted from there.</source>
          <target state="translated">提交补丁需要一个 p4 客户端,它和 Git 仓库不在同一个位置。补丁每次都会应用到这个 p4 客户端,然后从那里提交。</target>
        </trans-unit>
        <trans-unit id="81d7b2b94000dc76db42f2c130ed58771103b34d" translate="yes" xml:space="preserve">
          <source>Submodule Rewriting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e107551e51d7866e29fbfac7f1a9d70e892a1c9c" translate="yes" xml:space="preserve">
          <source>Submodule operations can be configured using the following mechanisms (from highest to lowest precedence):</source>
          <target state="translated">子模块操作可以使用以下机制进行配置(从高到低的优先级)。</target>
        </trans-unit>
        <trans-unit id="12d390f8025584ad2ceb29d8156199827eb766f2" translate="yes" xml:space="preserve">
          <source>Submodules</source>
          <target state="translated">Submodules</target>
        </trans-unit>
        <trans-unit id="8b3b72a48d6b77673f309811c21a1f34bda69f2a" translate="yes" xml:space="preserve">
          <source>Submodules are initialized and cloned using their default settings. This is equivalent to running &lt;code&gt;git submodule update --init --recursive &amp;lt;pathspec&amp;gt;&lt;/code&gt; immediately after the clone is finished. This option is ignored if the cloned repository does not have a worktree/checkout (i.e. if any of &lt;code&gt;--no-checkout&lt;/code&gt;/&lt;code&gt;-n&lt;/code&gt;, &lt;code&gt;--bare&lt;/code&gt;, or &lt;code&gt;--mirror&lt;/code&gt; is given)</source>
          <target state="translated">子模块使用其默认设置进行初始化和克隆。这等效于克隆完成后立即运行 &lt;code&gt;git submodule update --init --recursive &amp;lt;pathspec&amp;gt;&lt;/code&gt; 。如果克隆库不具有worktree /结帐忽略此选项（即如果任何 &lt;code&gt;--no-checkout&lt;/code&gt; / &lt;code&gt;-n&lt;/code&gt; ， &lt;code&gt;--bare&lt;/code&gt; ，或 &lt;code&gt;--mirror&lt;/code&gt; 给出）</target>
        </trans-unit>
        <trans-unit id="f0558d8aae211aae78435cf5f18fbee56b357b16" translate="yes" xml:space="preserve">
          <source>Submodules can be used for at least two different use cases:</source>
          <target state="translated">子模块可以用于至少两个不同的用例。</target>
        </trans-unit>
        <trans-unit id="2a4ac6e80eae220504fcac25436c9a1e818ef8b5" translate="yes" xml:space="preserve">
          <source>Submodules can take the following forms:</source>
          <target state="translated">子模块可采取以下形式:</target>
        </trans-unit>
        <trans-unit id="8ee6b51df0a5b53ba35723ec36f91cb14154873c" translate="yes" xml:space="preserve">
          <source>Submodules have more state and instead report M the submodule has a different HEAD than recorded in the index m the submodule has modified content ? the submodule has untracked files since modified content or untracked files in a submodule cannot be added via &lt;code&gt;git add&lt;/code&gt; in the superproject to prepare a commit.</source>
          <target state="translated">子模块具有更多状态，而是报告M子模块具有与记录在索引m中不同的HEAD子模块已修改内容？该子模块具有未跟踪的文件，因为子模块中的修改内容或未跟踪的文件无法通过超级项目中的 &lt;code&gt;git add&lt;/code&gt; 添加以准备提交。</target>
        </trans-unit>
        <trans-unit id="2a03a02ecd76c4aa6d233be9ed15c5b8f09cfe2e" translate="yes" xml:space="preserve">
          <source>Subsection names are case sensitive and can contain any characters except newline and the null byte. Doublequote &lt;code&gt;&quot;&lt;/code&gt; and backslash can be included by escaping them as &lt;code&gt;\&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt;, respectively. Backslashes preceding other characters are dropped when reading; for example, &lt;code&gt;\t&lt;/code&gt; is read as &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;\0&lt;/code&gt; is read as &lt;code&gt;0&lt;/code&gt; Section headers cannot span multiple lines. Variables may belong directly to a section or to a given subsection. You can have &lt;code&gt;[section]&lt;/code&gt; if you have &lt;code&gt;[section &quot;subsection&quot;]&lt;/code&gt;, but you don&amp;rsquo;t need to.</source>
          <target state="translated">小节名称区分大小写，并且可以包含除换行符和空字节以外的任何字符。可以通过分别将转义为 &lt;code&gt;\&quot;&lt;/code&gt; 和 &lt;code&gt;\\&lt;/code&gt; 来包含双引号 &lt;code&gt;&quot;&lt;/code&gt; 和反斜杠。阅读时，其他字符前面的反斜杠将被删除；例如， &lt;code&gt;\t&lt;/code&gt; 读为 &lt;code&gt;t&lt;/code&gt; ， &lt;code&gt;\0&lt;/code&gt; 读为 &lt;code&gt;0&lt;/code&gt; 。节标题不能跨越多行。变量可以直接属于某个节或给定的子节。你可以有 &lt;code&gt;[section]&lt;/code&gt; 如果你有 &lt;code&gt;[section &quot;subsection&quot;]&lt;/code&gt; ，但你并不需要。</target>
        </trans-unit>
        <trans-unit id="99e9a313960d39fea11c6c21bc5f471c5ed54f4e" translate="yes" xml:space="preserve">
          <source>Subsequent requests are then made directly to the service &lt;code&gt;$GIT_URL/git-upload-pack&lt;/code&gt;. (This works the same for git-receive-pack).</source>
          <target state="translated">随后，直接向服务 &lt;code&gt;$GIT_URL/git-upload-pack&lt;/code&gt; 发出请求。（这与git-receive-pack相同）。</target>
        </trans-unit>
        <trans-unit id="ecd7815bae661c84db8b72f60f38c2e3bca8ef1f" translate="yes" xml:space="preserve">
          <source>Subsequent updates to branches always create new files under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory hierarchy.</source>
          <target state="translated">对分支的后续更新总是在 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 目录层次结构下创建新文件。</target>
        </trans-unit>
        <trans-unit id="b2bf2538aec79c0d5fa040a786e252ac3772aa80" translate="yes" xml:space="preserve">
          <source>Substitute the character &quot;/&quot; in branch names with &amp;lt;subst&amp;gt;</source>
          <target state="translated">用&amp;lt;subst&amp;gt;替换分支名称中的字符&amp;ldquo; /&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="d44c96fa5a053386ed38d9e6a7cca3107588bf57" translate="yes" xml:space="preserve">
          <source>Successful execution (a zero exit status) of this hook does not ensure the ref will actually be updated, it is only a prerequisite. As such it is not a good idea to send notices (e.g. email) from this hook. Consider using the post-receive hook instead.</source>
          <target state="translated">成功执行这个钩子(零退出状态)并不能确保ref会真正被更新,它只是一个先决条件。因此,从这个钩子发送通知(例如电子邮件)不是一个好主意。可以考虑使用post-receive钩子来代替。</target>
        </trans-unit>
        <trans-unit id="0454547376d4a4928bbfee6331b7c2a9fb4a2161" translate="yes" xml:space="preserve">
          <source>Such duplicates are generally frowned upon because they clutter up history, making it harder to follow. To clean things up, you need to transplant the commits on &lt;code&gt;topic&lt;/code&gt; to the new &lt;code&gt;subsystem&lt;/code&gt; tip, i.e., rebase &lt;code&gt;topic&lt;/code&gt;. This becomes a ripple effect: anyone downstream from &lt;code&gt;topic&lt;/code&gt; is forced to rebase too, and so on!</source>
          <target state="translated">此类副本通常令人讨厌，因为它们会使历史混乱，难以追踪。为了清理问题，您需要将关于 &lt;code&gt;topic&lt;/code&gt; 的提交移植到新的 &lt;code&gt;subsystem&lt;/code&gt; 技巧，即rebase &lt;code&gt;topic&lt;/code&gt; 。这会产生连锁反应： &lt;code&gt;topic&lt;/code&gt; 下游的任何人也必须重新设置基础，依此类推！</target>
        </trans-unit>
        <trans-unit id="8866d8895f273e182aecc88b4155660c1e2db399" translate="yes" xml:space="preserve">
          <source>Summarize &lt;code&gt;git log&lt;/code&gt; output</source>
          <target state="translated">汇总 &lt;code&gt;git log&lt;/code&gt; 输出</target>
        </trans-unit>
        <trans-unit id="ec1e3fb20faac142815eb47774b44cb84610e827" translate="yes" xml:space="preserve">
          <source>Summarizes &lt;code&gt;git log&lt;/code&gt; output in a format suitable for inclusion in release announcements. Each commit will be grouped by author and title.</source>
          <target state="translated">以适合发布公告的格式汇总 &lt;code&gt;git log&lt;/code&gt; 输出。每次提交将按作者和标题分组。</target>
        </trans-unit>
        <trans-unit id="5c7562d8e87120565b992b08061dcfabc4f3c861" translate="yes" xml:space="preserve">
          <source>Supplies raw data (for use as blob/file content, commit messages, or annotated tag messages) to fast-import. Data can be supplied using an exact byte count or delimited with a terminating line. Real frontends intended for production-quality conversions should always use the exact byte count format, as it is more robust and performs better. The delimited format is intended primarily for testing fast-import.</source>
          <target state="translated">为快速导入提供原始数据(用于blob/文件内容、提交消息或注释标签消息)。数据可以使用精确的字节数来提供,也可以用终止行来分隔。真正的前端用于生产质量的转换时,应该始终使用精确的字节数格式,因为它更强大,性能更好。分界线格式主要用于测试快速导入。</target>
        </trans-unit>
        <trans-unit id="e8dbb2eeb155ce2917c101c99bacbd864a5c427e" translate="yes" xml:space="preserve">
          <source>Support for these types of regular expressions is an optional compile-time dependency. If Git wasn&amp;rsquo;t compiled with support for them providing this option will cause it to die.</source>
          <target state="translated">对这些类型的正则表达式的支持是可选的编译时依赖性。如果没有为Git提供支持，则提供此选项将导致它死亡。</target>
        </trans-unit>
        <trans-unit id="8e97694d704a0343a9b684d493f12b44246fec5f" translate="yes" xml:space="preserve">
          <source>Support for this command is mandatory.</source>
          <target state="translated">该命令的支持是强制性的。</target>
        </trans-unit>
        <trans-unit id="e1b49c8e0d2e923baa9b1bdde89fd2d2c159197a" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;connect&lt;/code&gt;.</source>
          <target state="translated">支持的命令： &lt;code&gt;connect&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0b920ef57768d484ba1cc526d81f954a574c57f" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;list for-push&lt;/code&gt;, &lt;code&gt;export&lt;/code&gt;.</source>
          <target state="translated">支持的命令： &lt;code&gt;list for-push&lt;/code&gt; ， &lt;code&gt;export&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72ec6998fb5b35dff686188df85ab0e3ad151b49" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;list for-push&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;.</source>
          <target state="translated">支持的命令： &lt;code&gt;list for-push&lt;/code&gt; ， &lt;code&gt;push&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5829938d9cd5455d30d44c2ed56081b81ad0e8b1" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">支持的命令： &lt;code&gt;list&lt;/code&gt; ， &lt;code&gt;fetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4005d18cc0bff6da83fb1c69518c92481df2684" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;import&lt;/code&gt;.</source>
          <target state="translated">支持的命令： &lt;code&gt;list&lt;/code&gt; ， &lt;code&gt;import&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff15abbc5988387a102f85b87106fa0f9a061a4c" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;stateless-connect&lt;/code&gt;.</source>
          <target state="translated">支持的命令： &lt;code&gt;stateless-connect&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d7833eb7ee78a4c26a83fcc81c3d2e9095611eb" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;connect&quot; capability.</source>
          <target state="translated">如果帮手具有 &quot;连接 &quot;功能,则支持。</target>
        </trans-unit>
        <trans-unit id="3a93883be31e9529a29debf1107a5749f91adad7" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;export&quot; capability.</source>
          <target state="translated">如果帮手具有 &quot;导出 &quot;功能,则支持。</target>
        </trans-unit>
        <trans-unit id="18465219e925f5ab7417753a2928593ca3f010cd" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;fetch&quot; capability.</source>
          <target state="translated">如果帮手具有 &quot;fetch &quot;功能,则支持。</target>
        </trans-unit>
        <trans-unit id="6b3f007fcd47faeaf9e41420b8dd45804e011830" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;fetch&quot; or &quot;import&quot; capability.</source>
          <target state="translated">如果帮助程序具有 &quot;获取 &quot;或 &quot;导入 &quot;功能,则支持。</target>
        </trans-unit>
        <trans-unit id="4aca0b5526d05a696e7b36938ee6f6c5a0ea9ae4" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;import&quot; capability.</source>
          <target state="translated">如果帮手具有 &quot;导入 &quot;功能,则支持。</target>
        </trans-unit>
        <trans-unit id="e7ddf6d69b0131cf639e3107da22aa777a2105a4" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;option&quot; capability.</source>
          <target state="translated">如果帮手有 &quot;选项 &quot;功能,则支持。</target>
        </trans-unit>
        <trans-unit id="c098533fa12e5c25ff58bd90a0ea089d5ecbd91f" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;push&quot; capability.</source>
          <target state="translated">如果帮手有 &quot;推 &quot;的功能,则支持。</target>
        </trans-unit>
        <trans-unit id="fb7b526ef7e22c9e1afe23a10d0bc8d29b1f28b6" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;push&quot; or &quot;export&quot; capability.</source>
          <target state="translated">如果帮手具有 &quot;推送 &quot;或 &quot;导出 &quot;功能,则支持。</target>
        </trans-unit>
        <trans-unit id="b4c51ee5ffb300c10c9d8c4078d940f537159814" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;stateless-connect&quot; capability.</source>
          <target state="translated">如果帮助程序具有 &quot;无状态连接 &quot;功能,则支持。</target>
        </trans-unit>
        <trans-unit id="05ab661bd504730c5b7114057d0bdfc9f5d779d8" translate="yes" xml:space="preserve">
          <source>Supports file additions, removals, and commits that affect binary files.</source>
          <target state="translated">支持影响二进制文件的文件添加、删除和提交。</target>
        </trans-unit>
        <trans-unit id="837f71448f49e2e0d9f370a0f4924a3332c3ce70" translate="yes" xml:space="preserve">
          <source>Suppose a shared repository is set up in /pub/repo.git on the host foo.com. Then as an individual committer you can clone the shared repository over ssh with:</source>
          <target state="translated">假设在主机foo.com的/pub/repo.git中建立了一个共享仓库。那么作为一个个人提交者,你可以通过ssh克隆共享仓库。</target>
        </trans-unit>
        <trans-unit id="776b1e3e664257166a794955fe1e330d0ed23c81" translate="yes" xml:space="preserve">
          <source>Suppose further that the two development lines merge cleanly at C, so no conflict resolution is required.</source>
          <target state="translated">进一步假设两条发展线在C处完全合并,所以不需要解决冲突。</target>
        </trans-unit>
        <trans-unit id="e8f9a38765e97d2341920d57addc2939bc25d7eb" translate="yes" xml:space="preserve">
          <source>Suppose that Alice has started a new project with a Git repository in /home/alice/project, and that Bob, who has a home directory on the same machine, wants to contribute.</source>
          <target state="translated">假设Alice启动了一个新的项目,Git仓库在/home/alice/project中,而Bob在同一台机器上有一个主目录,他想做出贡献。</target>
        </trans-unit>
        <trans-unit id="f0185bb1f9b382ec2ad8024131a049405c5d0a74" translate="yes" xml:space="preserve">
          <source>Suppose that in the meantime on the lower line of development somebody adds a new calling site for that function at commit Y. The commits from Z leading to B all assume the old semantics of that function and the callers and the callee are consistent with each other. There is no bug at B, either.</source>
          <target state="translated">假设在下线开发的同时,有人在提交Y处为该函数添加了一个新的调用点,从Z到B的提交都假定了该函数的旧语义,调用者和被调用者是一致的。B处也没有bug。</target>
        </trans-unit>
        <trans-unit id="391a0e24d7cf4e807cbdc6c67d247a126500a7a1" translate="yes" xml:space="preserve">
          <source>Suppose that on the upper line of development, the meaning of one of the functions that exists at Z is changed at commit X. The commits from Z leading to A change both the function&amp;rsquo;s implementation and all calling sites that exist at Z, as well as new calling sites they add, to be consistent. There is no bug at A.</source>
          <target state="translated">假设在开发的最上面，在提交X处更改了Z处存在的功能之一的含义。从Z到A的提交更改了函数的实现以及Z处存在的所有调用站点，以及为了保持一致，他们添加了新的呼叫站点。A没有错误。</target>
        </trans-unit>
        <trans-unit id="4264938eda486beabd24f72d431c53e3aa7556fd" translate="yes" xml:space="preserve">
          <source>Suppose that you create a branch &lt;code&gt;mywork&lt;/code&gt; on a remote-tracking branch &lt;code&gt;origin&lt;/code&gt;, and create some commits on top of it:</source>
          <target state="translated">假设您在远程跟踪分支 &lt;code&gt;origin&lt;/code&gt; 上创建一个分支 &lt;code&gt;mywork&lt;/code&gt; ，并在其之上创建一些提交：</target>
        </trans-unit>
        <trans-unit id="3c9c906e2a1276113a369eaaabf56387154b9496" translate="yes" xml:space="preserve">
          <source>Suppose that you have created lots of logically separate changes and committed them together. Then, later you decide that it might be better to have each logical chunk associated with its own commit. You can use git reset to rewind history without changing the contents of your local files, and then successively use &lt;code&gt;git add -p&lt;/code&gt; to interactively select which hunks to include into each commit, using &lt;code&gt;git commit -c&lt;/code&gt; to pre-populate the commit message.</source>
          <target state="translated">假设您创建了许多逻辑上分开的更改并将它们一起提交。然后，稍后您决定让每个逻辑块与其自己的提交相关联可能会更好。您可以使用git reset来回滚历史记录，而无需更改本地文件的内容，然后依次使用 &lt;code&gt;git add -p&lt;/code&gt; 交互式地选择要包含在每个提交中的块，使用 &lt;code&gt;git commit -c&lt;/code&gt; 来预先填充提交消息。</target>
        </trans-unit>
        <trans-unit id="02fbd8fc87f2a350a49d8620ee0b30d4bf4e4abd" translate="yes" xml:space="preserve">
          <source>Suppose version 2.6.18 of your project worked, but the version at &quot;master&quot; crashes. Sometimes the best way to find the cause of such a regression is to perform a brute-force search through the project&amp;rsquo;s history to find the particular commit that caused the problem. The &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; command can help you do this:</source>
          <target state="translated">假设项目的2.6.18版可以正常工作，但是&amp;ldquo; master&amp;rdquo;上的版本崩溃了。有时，找到导致这种回归的原因的最好方法是对项目的历史记录进行蛮力搜索，以找出引起问题的特定提交。该&lt;a href=&quot;git-bisect&quot;&gt;混帐平分[1]&lt;/a&gt;命令可以帮助你做到这一点：</target>
        </trans-unit>
        <trans-unit id="fe43e13972d777424e11db2803667e644671ba7d" translate="yes" xml:space="preserve">
          <source>Suppose you are a contributor to a large project, and you want to add a complicated feature, and to present it to the other developers in a way that makes it easy for them to read your changes, verify that they are correct, and understand why you made each change.</source>
          <target state="translated">假设你是一个大型项目的贡献者,你想添加一个复杂的功能,并将其展示给其他开发者,使他们能够轻松地阅读你的修改,验证它们是否正确,并理解为什么你做了每一个修改。</target>
        </trans-unit>
        <trans-unit id="3acc0c164272600e31526ab46c74892c1aa07162" translate="yes" xml:space="preserve">
          <source>Suppose you are interrupted by an urgent fix request while you are in the middle of a large change. The files in your working tree are not in any shape to be committed yet, but you need to get to the other branch for a quick bugfix.</source>
          <target state="translated">假设你正在进行一个大的改动时,被一个紧急的修复请求打断了,你的工作树中的文件还没有提交,但你需要到另一个分支进行快速的错误修复。你的工作树中的文件还没有任何形式的提交,但你需要去另一个分支进行快速的错误修复。</target>
        </trans-unit>
        <trans-unit id="206336da1c56023f89c7e12354f95287caca26a2" translate="yes" xml:space="preserve">
          <source>Suppose you are working on something and you commit it, and then you continue working a bit more, but now you think that what you have in your working tree should be in another branch that has nothing to do with what you committed previously. You can start a new branch and reset it while keeping the changes in your working tree.</source>
          <target state="translated">假设你正在做某件事情,并提交了它,然后你又继续做了一些工作,但现在你认为你的工作树中的内容应该在另一个分支中,而这个分支与你之前提交的内容没有关系。你可以开始一个新的分支,然后重新设置,同时保留工作树中的变化。</target>
        </trans-unit>
        <trans-unit id="25caa4df3e00bbf0c1bcbf48ca3bbcb805b36ab6" translate="yes" xml:space="preserve">
          <source>Suppose you have added a file to your index, but later decide you do not want to add it to your commit. You can remove the file from the index while keeping your changes with git reset.</source>
          <target state="translated">假设您在索引中添加了一个文件,但后来决定不将其添加到提交中。你可以用 git reset 从索引中删除文件,同时保留你的修改。</target>
        </trans-unit>
        <trans-unit id="9419c8de1f4e3152ef10e8d631b17a6a8c4bb66f" translate="yes" xml:space="preserve">
          <source>Suppose you know that the commit e05db0fd fixed a certain problem. You&amp;rsquo;d like to find the earliest tagged release that contains that fix.</source>
          <target state="translated">假设您知道提交e05db0fd解决了某个问题。您想找到包含该修复程序的最早的带标记的发行版。</target>
        </trans-unit>
        <trans-unit id="c40ef08f6cb59edadae067c6870364980c310ebf" translate="yes" xml:space="preserve">
          <source>Suppose you specified &lt;code&gt;foo&lt;/code&gt; as the &amp;lt;paths&amp;gt;. We shall call commits that modify &lt;code&gt;foo&lt;/code&gt; !TREESAME, and the rest TREESAME. (In a diff filtered for &lt;code&gt;foo&lt;/code&gt;, they look different and equal, respectively.)</source>
          <target state="translated">假设您将 &lt;code&gt;foo&lt;/code&gt; 指定为&amp;lt;paths&amp;gt;。我们将调用修改 &lt;code&gt;foo&lt;/code&gt; ！TREESAME的提交，其余的调用TREESAME。（在针对 &lt;code&gt;foo&lt;/code&gt; 过滤的差异中，它们分别看起来不同且相等。）</target>
        </trans-unit>
        <trans-unit id="cb2a200ea83c58efe22ad112266f5c75d08a4a2e" translate="yes" xml:space="preserve">
          <source>Suppose you want to check whether two branches point at the same point in history.</source>
          <target state="translated">假设你想检查两个分支是否指向历史上的同一个点。</target>
        </trans-unit>
        <trans-unit id="a4ad635bf26628e292f1bfd04aa9f0a4ae18d146" translate="yes" xml:space="preserve">
          <source>Suppose you want to know how many commits you&amp;rsquo;ve made on &lt;code&gt;mybranch&lt;/code&gt; since it diverged from &lt;code&gt;origin&lt;/code&gt;:</source>
          <target state="translated">假设您想知道自 &lt;code&gt;mybranch&lt;/code&gt; 脱离 &lt;code&gt;origin&lt;/code&gt; 以来您已经进行了多少次提交：</target>
        </trans-unit>
        <trans-unit id="f9ddeae1484388d5dab75e34df1cfd67e52a3e70" translate="yes" xml:space="preserve">
          <source>Suppose you want to rebase the side branch starting at &quot;A&quot; to &quot;Q&quot;. Make sure that the current HEAD is &quot;B&quot;, and call</source>
          <target state="translated">假设你想把从 &quot;A &quot;开始的侧枝重垒为 &quot;Q&quot;。确保当前的 HEAD 是 &quot;B&quot;,然后调用</target>
        </trans-unit>
        <trans-unit id="b5613771383533c24d3d428fdc1ae60e9fd438c4" translate="yes" xml:space="preserve">
          <source>Suppose you want to remove a file (containing confidential information or copyright violation) from all commits:</source>
          <target state="translated">假设你想从所有的提交中删除一个文件(包含机密信息或侵犯版权)。</target>
        </trans-unit>
        <trans-unit id="ff7d0768a57dca637d6eab253f0d487ae1222161" translate="yes" xml:space="preserve">
          <source>Suppose you would like to see all the commits reachable from the branch head named &lt;code&gt;master&lt;/code&gt; but not from any other head in your repository.</source>
          <target state="translated">假设您希望看到所有提交都可以从名为 &lt;code&gt;master&lt;/code&gt; 的分支头访问，而不能从存储库中的其他任何头访问。</target>
        </trans-unit>
        <trans-unit id="9946995b81548e47df6c8b8392c1840733fdb964" translate="yes" xml:space="preserve">
          <source>Suppress all output, including the listing of updated refs, unless an error occurs. Progress is not reported to the standard error stream.</source>
          <target state="translated">除非发生错误,否则抑制所有输出,包括更新的参考文献列表。进度不会报告给标准错误流。</target>
        </trans-unit>
        <trans-unit id="c4b3a6cd7a8560fe90c65c121ee87d36135f6602" translate="yes" xml:space="preserve">
          <source>Suppress all progress reports.</source>
          <target state="translated">压制所有进度报告。</target>
        </trans-unit>
        <trans-unit id="a819bd2ff05cd55161823638237268e190be312a" translate="yes" xml:space="preserve">
          <source>Suppress commit description and provide a commit count summary only.</source>
          <target state="translated">隐藏提交描述,只提供提交次数摘要。</target>
        </trans-unit>
        <trans-unit id="e799a643bdb9c82fda51c43573cb85b70de9e54e" translate="yes" xml:space="preserve">
          <source>Suppress commit summary message.</source>
          <target state="translated">抑制提交摘要信息。</target>
        </trans-unit>
        <trans-unit id="1a696049e271af3ebf56a00bfbec639053a19da0" translate="yes" xml:space="preserve">
          <source>Suppress diff output. Useful for commands like &lt;code&gt;git show&lt;/code&gt; that show the patch by default, or to cancel the effect of &lt;code&gt;--patch&lt;/code&gt;.</source>
          <target state="translated">抑制差异输出。对于像 &lt;code&gt;git show&lt;/code&gt; 这样的命令很有用，这些命令默认情况下显示补丁，或取消 &lt;code&gt;--patch&lt;/code&gt; 的效果。</target>
        </trans-unit>
        <trans-unit id="93e56a37493c6ba4434b0b6ea5eb008e9221a320" translate="yes" xml:space="preserve">
          <source>Suppress the author name and timestamp from the output.</source>
          <target state="translated">从输出中删除作者姓名和时间戳。</target>
        </trans-unit>
        <trans-unit id="f43798729bfff9f209d330c349626cb5165ac751" translate="yes" xml:space="preserve">
          <source>Swap two inputs; that is, show differences from index or on-disk file to tree contents.</source>
          <target state="translated">交换两个输入;即显示从索引或磁盘文件到树内容的差异。</target>
        </trans-unit>
        <trans-unit id="e5e55f7f46ad773b6efc6aca47e818298efdba7d" translate="yes" xml:space="preserve">
          <source>Switch branches</source>
          <target state="translated">切换分支</target>
        </trans-unit>
        <trans-unit id="c1c3479fb48988243819a9ed632d7db49472e85a" translate="yes" xml:space="preserve">
          <source>Switch branches or restore working tree files</source>
          <target state="translated">切换分支或恢复工作树文件</target>
        </trans-unit>
        <trans-unit id="dfdb03e90173f2e2bacd7c02f01c4407ebc5e4a7" translate="yes" xml:space="preserve">
          <source>Switch to &lt;code&gt;topic/wip&lt;/code&gt; branch and keep working.</source>
          <target state="translated">切换到 &lt;code&gt;topic/wip&lt;/code&gt; 分支并继续工作。</target>
        </trans-unit>
        <trans-unit id="376cbb6cbd05a4fda1d6b5e220f115dcce8e44f1" translate="yes" xml:space="preserve">
          <source>Switch to a commit for inspection and discardable experiments. See the &quot;DETACHED HEAD&quot; section in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; for details.</source>
          <target state="translated">切换到提交进行检查和可丢弃实验。有关详细信息，请参见&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]中&lt;/a&gt;的&amp;ldquo; DETACHED HEAD&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="0362a7c9eb4dad56855ff5dd55a91d5b93e6f9c7" translate="yes" xml:space="preserve">
          <source>Switch to a specified branch. The working tree and the index are updated to match the branch. All new commits will be added to the tip of this branch.</source>
          <target state="translated">切换到指定的分支。工作树和索引会被更新以匹配该分支。所有新提交的内容都会被添加到该分支的顶端。</target>
        </trans-unit>
        <trans-unit id="c4a37023c84f04e66def4788394f47d95de02383" translate="yes" xml:space="preserve">
          <source>Switching branches does not require a clean index and working tree (i.e. no differences compared to &lt;code&gt;HEAD&lt;/code&gt;). The operation is aborted however if the operation leads to loss of local changes, unless told otherwise with &lt;code&gt;--discard-changes&lt;/code&gt; or &lt;code&gt;--merge&lt;/code&gt;.</source>
          <target state="translated">切换分支不需要干净的索引和工作树（即，与 &lt;code&gt;HEAD&lt;/code&gt; 相比没有区别）。但是，如果该操作导致丢失本地更改，则该操作将中止，除非使用 &lt;code&gt;--discard-changes&lt;/code&gt; 或 &lt;code&gt;--merge&lt;/code&gt; 另行通知。</target>
        </trans-unit>
        <trans-unit id="2a44d54fe8d0fbe571632defb5e0f0bfcb635688" translate="yes" xml:space="preserve">
          <source>Symbolic identifiers</source>
          <target state="translated">符号标识符</target>
        </trans-unit>
        <trans-unit id="edf50a81800d6af816fa28268463b4a137a670b4" translate="yes" xml:space="preserve">
          <source>Symbolic reference: instead of containing the &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; id itself, it is of the format 'ref: refs/some/thing' and when referenced, it recursively dereferences to this reference. '&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;' is a prime example of a symref. Symbolic references are manipulated with the &lt;a href=&quot;git-symbolic-ref&quot;&gt;git-symbolic-ref[1]&lt;/a&gt; command.</source>
          <target state="translated">符号引用：它不包含&lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; id本身，而是采用'ref：refs / some / thing'格式，并且在被引用时，以递归方式取消引用此引用。' &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; '是symref的主要示例。使用&lt;a href=&quot;git-symbolic-ref&quot;&gt;git-symbolic-ref [1]&lt;/a&gt;命令可操纵符号引用。</target>
        </trans-unit>
        <trans-unit id="6dc4afea6b4b62629fc3af96ff8aeb71d81ce355" translate="yes" xml:space="preserve">
          <source>Symbolic reference: instead of containing the &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; id itself, it is of the format &lt;code&gt;ref: refs/some/thing&lt;/code&gt; and when referenced, it recursively dereferences to this reference. &lt;code&gt;&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;&lt;/code&gt; is a prime example of a symref. Symbolic references are manipulated with the &lt;a href=&quot;git-symbolic-ref&quot;&gt;git-symbolic-ref[1]&lt;/a&gt; command.</source>
          <target state="translated">符号引用：它不包含&lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; ID本身，而是采用 &lt;code&gt;ref: refs/some/thing&lt;/code&gt; 的格式，并且在被引用时，以递归方式取消引用此引用。 &lt;code&gt;&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;&lt;/code&gt; 是symref的主要示例。使用&lt;a href=&quot;git-symbolic-ref&quot;&gt;git-symbolic-ref [1]&lt;/a&gt;命令可操纵符号引用。</target>
        </trans-unit>
        <trans-unit id="7d980e6b3e0dc3c2265b8f39aea640f21a2c26c7" translate="yes" xml:space="preserve">
          <source>Symlinks in &lt;code&gt;$GIT_DIR&lt;/code&gt; are not resolved before matching.</source>
          <target state="translated">匹配之前， &lt;code&gt;$GIT_DIR&lt;/code&gt; 不会解析。</target>
        </trans-unit>
        <trans-unit id="905f63092ff26517a7aa8083857b3c8af9707002" translate="yes" xml:space="preserve">
          <source>Sync</source>
          <target state="translated">Sync</target>
        </trans-unit>
        <trans-unit id="1cafa24e02c13e63ccc749c8cc50c089372b01c9" translate="yes" xml:space="preserve">
          <source>Sync options</source>
          <target state="translated">同步选项</target>
        </trans-unit>
        <trans-unit id="a05ba5351cf72e05a13ed22352248517859a3ce9" translate="yes" xml:space="preserve">
          <source>Synchronizes submodules' remote URL configuration setting to the value specified in &lt;code&gt;.gitmodules&lt;/code&gt;. It will only affect those submodules which already have a URL entry in .git/config (that is the case when they are initialized or freshly added). This is useful when submodule URLs change upstream and you need to update your local repositories accordingly.</source>
          <target state="translated">将子模块的远程URL配置设置同步到 &lt;code&gt;.gitmodules&lt;/code&gt; 中指定的值。它只会影响那些已经在.git / config中具有URL条目的子模块（在初始化或新添加子模块时就是这种情况）。当子模块URL向上游更改并且您需要相应地更新本地存储库时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="3ac8d1a1aa5500a3e968826312a150affc9dc46d" translate="yes" xml:space="preserve">
          <source>Syncing repositories</source>
          <target state="translated">同步存储库</target>
        </trans-unit>
        <trans-unit id="566e604d58292e23d183e78e39f3823e9b42de23" translate="yes" xml:space="preserve">
          <source>Synonym for --dirstat=cumulative</source>
          <target state="translated">同义词 --dirstat=累积的</target>
        </trans-unit>
        <trans-unit id="f1c4d35b0c03f286600f7fb27eae33fe27989165" translate="yes" xml:space="preserve">
          <source>Synonym for --dirstat=files,param1,param2&amp;hellip;​</source>
          <target state="translated">--dirstat = files，param1，param2 ...的同义词</target>
        </trans-unit>
        <trans-unit id="030318e98e2891ff258d5f1c486159aabe2ec3cd" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; (the noun).</source>
          <target state="translated">&lt;a href=&quot;#def_commit&quot;&gt;提交的&lt;/a&gt;同义词（名词）。</target>
        </trans-unit>
        <trans-unit id="98387ba9809590c01ed4197e28a198c994b76d39" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_object_name&quot;&gt;对象名称的&lt;/a&gt;同义词。</target>
        </trans-unit>
        <trans-unit id="05205baafaafa5f371ceb6761f66c9a9092bfca8" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; (for arch people).</source>
          <target state="translated">&lt;a href=&quot;#def_repository&quot;&gt;存储库的&lt;/a&gt;同义词（对于拱门人）。</target>
        </trans-unit>
        <trans-unit id="bd983733ce10be3d6383ba3ae94c790c5998f587" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;code&gt;--date=relative&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--date=relative&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="7204033ad0a3ce5a123aa68893dbb1ec2d44eb7f" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;code&gt;-p --raw&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-p --raw&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="e2c85a45d4841ec1bc0daa5da30d63888f50f751" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;code&gt;-p --stat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-p --stat&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="4826ecc5c9ae249b105cc0f800bf317e1bf3ce71" translate="yes" xml:space="preserve">
          <source>Synonym to &lt;code&gt;--more=-1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--more=-1&lt;/code&gt; 的同义词</target>
        </trans-unit>
        <trans-unit id="375d34b627071e9b56cd3502d59bf963af19d37c" translate="yes" xml:space="preserve">
          <source>Synonym to &lt;code&gt;merge.log&lt;/code&gt;; this is deprecated and will be removed in the future.</source>
          <target state="translated">同义词 &lt;code&gt;merge.log&lt;/code&gt; ; 不推荐使用，以后将删除它。</target>
        </trans-unit>
        <trans-unit id="d87db41828b59d9f281eb9d60b0fac7e88c656b9" translate="yes" xml:space="preserve">
          <source>Synonyms to --log and --no-log; these are deprecated and will be removed in the future.</source>
          <target state="translated">与--log和--no-log的同义词;这两个词已经过时,将来会被删除。</target>
        </trans-unit>
        <trans-unit id="c9c7aa6b4fd156059c823cdabeac32daf66bec16" translate="yes" xml:space="preserve">
          <source>Synonyms to --stat and --no-stat; these are deprecated and will be removed in the future.</source>
          <target state="translated">与--stat和--no-stat的同义词;这两个词已经过时,将来会被删除。</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="121e826ad7717bacfd25c6cf738291790df9e550" translate="yes" xml:space="preserve">
          <source>Syntax is compatible with the file used by &lt;code&gt;git cvsimport&lt;/code&gt; but an empty email address can be supplied with &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">语法与 &lt;code&gt;git cvsimport&lt;/code&gt; 所使用的文件兼容，但是 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 可以提供一个空的电子邮件地址：</target>
        </trans-unit>
        <trans-unit id="bd2d182068c3eb81ead850c75865e8ae2f054c99" translate="yes" xml:space="preserve">
          <source>System-wide configuration file.</source>
          <target state="translated">全系统的配置文件。</target>
        </trans-unit>
        <trans-unit id="bb78aa3d24f5df42764064db56cde78ca1a563d8" translate="yes" xml:space="preserve">
          <source>T: change in the type of the file</source>
          <target state="translated">T:改变文件的类型</target>
        </trans-unit>
        <trans-unit id="a5e95b00d8bbc7641f64bca05aef94e0873eb866" translate="yes" xml:space="preserve">
          <source>THIS COMMAND IS EXPERIMENTAL. ITS BEHAVIOR, AND THE BEHAVIOR OF OTHER COMMANDS IN THE PRESENCE OF SPARSE-CHECKOUTS, WILL LIKELY CHANGE IN THE FUTURE.</source>
          <target state="translated">本命令是试验性的。它的行为,以及其他命令在出现稀疏检查时的行为,很可能会在未来发生变化。</target>
        </trans-unit>
        <trans-unit id="9667ca46bdeede85b6c2fc52e7779cc06938e375" translate="yes" xml:space="preserve">
          <source>THIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE.</source>
          <target state="translated">这个命令是试验性的,行为可能会改变。</target>
        </trans-unit>
        <trans-unit id="da2da317615483c79a5e32887ba14bbfd135afb2" translate="yes" xml:space="preserve">
          <source>THIS OPTION IS EXPERIMENTAL! SHA-256 support is experimental and still in an early stage. A SHA-256 repository will in general not be able to share work with &quot;regular&quot; SHA-1 repositories. It should be assumed that, e.g., Git internal file formats in relation to SHA-256 repositories may change in backwards-incompatible ways. Only use &lt;code&gt;--object-format=sha256&lt;/code&gt; for testing purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667949023cc3f454cb0d70e83c52143e1650458d" translate="yes" xml:space="preserve">
          <source>TRAILER:</source>
          <target state="translated">TRAILER:</target>
        </trans-unit>
        <trans-unit id="a2ba9a257606db8185ab32e1350e244ce43cc422" translate="yes" xml:space="preserve">
          <source>Tag Object</source>
          <target state="translated">标签对象</target>
        </trans-unit>
        <trans-unit id="cb8b1e1903f812d19eec6ff05583389fd13d1603" translate="yes" xml:space="preserve">
          <source>Tag format</source>
          <target state="translated">标签格式</target>
        </trans-unit>
        <trans-unit id="7e41343aeba4393f005c76977eda409bbd77862f" translate="yes" xml:space="preserve">
          <source>Tag names are automatically prefixed with &lt;code&gt;refs/tags/&lt;/code&gt; when stored in Git, so importing the CVS branch symbol &lt;code&gt;RELENG-1_0-FINAL&lt;/code&gt; would use just &lt;code&gt;RELENG-1_0-FINAL&lt;/code&gt; for &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, and fast-import will write the corresponding ref as &lt;code&gt;refs/tags/RELENG-1_0-FINAL&lt;/code&gt;.</source>
          <target state="translated">当标签名称存储在Git中时，标签名称会自动加上 &lt;code&gt;refs/tags/&lt;/code&gt; 前缀，因此导入CVS分支符号 &lt;code&gt;RELENG-1_0-FINAL&lt;/code&gt; 只会对 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 使用 &lt;code&gt;RELENG-1_0-FINAL&lt;/code&gt; ，而fast-import会将相应的ref写为 &lt;code&gt;refs/tags/RELENG-1_0-FINAL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e6fe4e0ae7885e683d9ee3f683c218e6902b977" translate="yes" xml:space="preserve">
          <source>Tag objects (created with &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u&lt;/code&gt;) are called &quot;annotated&quot; tags; they contain a creation date, the tagger name and e-mail, a tagging message, and an optional GnuPG signature. Whereas a &quot;lightweight&quot; tag is simply a name for an object (usually a commit object).</source>
          <target state="translated">标记对象（使用 &lt;code&gt;-a&lt;/code&gt; ， &lt;code&gt;-s&lt;/code&gt; 或 &lt;code&gt;-u&lt;/code&gt; 创建）称为&amp;ldquo;带注释&amp;rdquo;标记；它们包含创建日期，标记者名称和电子邮件，标记消息以及可选的GnuPG签名。而&amp;ldquo;轻量级&amp;rdquo;标签只是对象（通常是提交对象）的名称。</target>
        </trans-unit>
        <trans-unit id="71ea1d47718752d76e2ffd9d2603ad43ca73b3c9" translate="yes" xml:space="preserve">
          <source>Tagging a version</source>
          <target state="translated">标记一个版本</target>
        </trans-unit>
        <trans-unit id="637cc41ee731974198f97641d9bdfb130460784b" translate="yes" xml:space="preserve">
          <source>Tags are expected to always point at the same version of a project, while heads are expected to advance as development progresses.</source>
          <target state="translated">标签要始终指向项目的同一个版本,而头部则要随着开发进度推进。</target>
        </trans-unit>
        <trans-unit id="888bc919d88641f62426fddc6b7cfc9f6452b8d3" translate="yes" xml:space="preserve">
          <source>Take an existing commit object, and reuse the log message and the authorship information (including the timestamp) when creating the commit.</source>
          <target state="translated">使用现有的提交对象,并在创建提交时重用日志信息和作者信息(包括时间戳)。</target>
        </trans-unit>
        <trans-unit id="69d5f1e03c82cbcd587369170c6624b0cf043d55" translate="yes" xml:space="preserve">
          <source>Take the commit message from the given file. This option disables the &lt;code&gt;--edit&lt;/code&gt; option.</source>
          <target state="translated">从给定文件中获取提交消息。此选项禁用 &lt;code&gt;--edit&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="55362ac1695784c6e28770360066065f70c4271a" translate="yes" xml:space="preserve">
          <source>Take the commit message from the given file. Use &lt;code&gt;-&lt;/code&gt; to read the message from the standard input.</source>
          <target state="translated">从给定文件中获取提交消息。使用 &lt;code&gt;-&lt;/code&gt; 从标准输入中读取消息。</target>
        </trans-unit>
        <trans-unit id="e36d4d8811a867676a670c71431af6f45b8cdbfc" translate="yes" xml:space="preserve">
          <source>Take the configuration from the given file instead of .git/config. Using the &quot;--global&quot; option forces this to ~/.gitconfig. Using the &quot;--system&quot; option forces this to $(prefix)/etc/gitconfig.</source>
          <target state="translated">从给定文件中获取配置,而不是.git/config。使用&quot;--global &quot;选项强制将其转为~/.gitconfig。使用&quot;--system &quot;选项,则会将其强制到$(prefix)/etc/gitconfig。</target>
        </trans-unit>
        <trans-unit id="29a57524801de08e4acaf7aa5d5fef7d3a95fdaf" translate="yes" xml:space="preserve">
          <source>Take the given blob object (for example, another note) as the note message. (Use &lt;code&gt;git notes copy &amp;lt;object&amp;gt;&lt;/code&gt; instead to copy notes between objects.)</source>
          <target state="translated">将给定的Blob对象（例如，另一个便笺）作为便笺消息。（使用 &lt;code&gt;git notes copy &amp;lt;object&amp;gt;&lt;/code&gt; 来在对象之间复制注释。）</target>
        </trans-unit>
        <trans-unit id="d362e00efeb54e4840d9ea63f1d18d0cce50b4f2" translate="yes" xml:space="preserve">
          <source>Take the list of merged objects from &amp;lt;file&amp;gt; instead of stdin.</source>
          <target state="translated">从&amp;lt;file&amp;gt;而不是stdin获取合并对象的列表。</target>
        </trans-unit>
        <trans-unit id="85714dc37d705ec3059aca2b86357cf12078cff0" translate="yes" xml:space="preserve">
          <source>Take the list of refs from stdin, one per line. If there are refs specified on the command line in addition to this option, then the refs from stdin are processed after those on the command line.</source>
          <target state="translated">从 stdin 中获取 refs 列表,每行一个。如果除了这个选项之外,命令行上还有指定的参考文献,那么来自stdin的参考文献将在命令行上的参考文献之后处理。</target>
        </trans-unit>
        <trans-unit id="e793a474854bfcd7a2387829ec157d014acaec34" translate="yes" xml:space="preserve">
          <source>Take the note message from the given file. Use &lt;code&gt;-&lt;/code&gt; to read the note message from the standard input. Lines starting with &lt;code&gt;#&lt;/code&gt; and empty lines other than a single line between paragraphs will be stripped out.</source>
          <target state="translated">从给定的文件中获取注释消息。使用 &lt;code&gt;-&lt;/code&gt; 从标准输入中读取注释消息。以 &lt;code&gt;#&lt;/code&gt; 开头的行和段落之间的空行（段落之间的单行除外）将被删除。</target>
        </trans-unit>
        <trans-unit id="b415454b3e57aca4cd9775be68c013d0b1cba35f" translate="yes" xml:space="preserve">
          <source>Take the tag message from the given file. Use &lt;code&gt;-&lt;/code&gt; to read the message from the standard input. Implies &lt;code&gt;-a&lt;/code&gt; if none of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is given.</source>
          <target state="translated">从给定的文件中获取标签消息。使用 &lt;code&gt;-&lt;/code&gt; 从标准输入中读取消息。意味着 &lt;code&gt;-a&lt;/code&gt; 如果没有的 &lt;code&gt;-a&lt;/code&gt; ， &lt;code&gt;-s&lt;/code&gt; ，或 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 给出。</target>
        </trans-unit>
        <trans-unit id="437fabd9a3b90a4e3feee997e0efd394e0e18037" translate="yes" xml:space="preserve">
          <source>Take the version from the current branch as the tentative merge result, and declare that the merge has conflicts. This is suitable for binary files that do not have a well-defined merge semantics.</source>
          <target state="translated">以当前分支的版本作为暂定的合并结果,并声明合并有冲突。这适用于没有明确定义合并语义的二进制文件。</target>
        </trans-unit>
        <trans-unit id="8adfe6e8bfbfb71c863cfc8d3c7f83de8a17ccfc" translate="yes" xml:space="preserve">
          <source>Takes the list of merged objects on stdin and produces a suitable commit message to be used for the merge commit, usually to be passed as the &lt;code&gt;&amp;lt;merge-message&amp;gt;&lt;/code&gt; argument of &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">在stdin上获取合并对象的列表，并生成用于合并提交的合适的提交消息，通常作为 &lt;code&gt;git merge&lt;/code&gt; 的 &lt;code&gt;&amp;lt;merge-message&amp;gt;&lt;/code&gt; 参数传递。</target>
        </trans-unit>
        <trans-unit id="a792b2d24cbb9bea552de7c52e443e6ec570f86e" translate="yes" xml:space="preserve">
          <source>Takes the patches given on the command line and emails them out. Patches can be specified as files, directories (which will send all files in the directory), or directly as a revision list. In the last case, any format accepted by &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; can be passed to git send-email.</source>
          <target state="translated">取得命令行上给出的补丁，并通过电子邮件发送出去。修补程序可以指定为文件，目录（将发送目录中的所有文件），也可以直接指定为修订列表。在最后一种情况下，&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;接受的任何格式都可以传递给git send-email。</target>
        </trans-unit>
        <trans-unit id="6a0ff7754ecf08c3c8186e018764aeb2fd2691af" translate="yes" xml:space="preserve">
          <source>Talk to the IMAP server using git&amp;rsquo;s own IMAP routines instead of using libcurl. Ignored if Git was built with the NO_OPENSSL option set.</source>
          <target state="translated">使用git自己的IMAP例程而不是libcurl与IMAP服务器通信。忽略是否​​使用NO_OPENSSL选项集构建了Git。</target>
        </trans-unit>
        <trans-unit id="8452733fe9983e27bdd86ccd2806b4879b9eed76" translate="yes" xml:space="preserve">
          <source>Target of the home link on the top of all pages (the first part of view &quot;breadcrumbs&quot;). By default it is set to the absolute URI of a current page (to the value of &lt;code&gt;$my_uri&lt;/code&gt; variable, or to &quot;/&quot; if &lt;code&gt;$my_uri&lt;/code&gt; is undefined or is an empty string).</source>
          <target state="translated">所有页面顶部的主页链接的目标（视图&amp;ldquo;面包屑&amp;rdquo;的第一部分）。默认情况下，它设置为当前页面的绝对URI（设置为 &lt;code&gt;$my_uri&lt;/code&gt; 变量的值，如果 &lt;code&gt;$my_uri&lt;/code&gt; 未定义或为空字符串，则设置为&amp;ldquo; /&amp;rdquo; ）。</target>
        </trans-unit>
        <trans-unit id="b83c8f8bfe5de4730b897d69d4046995d166efe4" translate="yes" xml:space="preserve">
          <source>Targets are defined using a VTable allowing easy extension to other formats in the future. This might be used to define a binary format, for example.</source>
          <target state="translated">目标是用VTable定义的,允许将来很容易扩展到其他格式。例如,这可以用来定义一个二进制格式。</target>
        </trans-unit>
        <trans-unit id="b51ba0493561f3b3deddd8211a5a385cd8601db7" translate="yes" xml:space="preserve">
          <source>Technical discussion</source>
          <target state="translated">技术讨论</target>
        </trans-unit>
        <trans-unit id="7d2e519ddfe0c57b9b7de69eeaa388f193a9848e" translate="yes" xml:space="preserve">
          <source>Tell Git that canonical representation of files in the repository has changed over time (e.g. earlier commits record text files with CRLF line endings, but recent ones use LF line endings). In such a repository, Git can convert the data recorded in commits to a canonical form before performing a merge to reduce unnecessary conflicts. For more information, see section &quot;Merging branches with differing checkin/checkout attributes&quot; in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">告诉Git，存储库中文件的规范表示已随着时间而改变（例如，较早的提交具有CRLF行尾的记录文本文件，但是最近的提交使用LF行尾）。在这样的存储库中，Git可以在执行合并之前将提交中记录的数据转换为规范形式，以减少不必要的冲突。有关更多信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]中的&lt;/a&gt; &amp;ldquo;合并具有不同签入/签出属性的分支&amp;rdquo;一节。</target>
        </trans-unit>
        <trans-unit id="b5b3a0f2444b1d5713e25e3bc88878530e280cdf" translate="yes" xml:space="preserve">
          <source>Tell Git to use it.</source>
          <target state="translated">告诉Git使用它。</target>
        </trans-unit>
        <trans-unit id="bebd78f164bb96ec184a42572b9740f676dbf149" translate="yes" xml:space="preserve">
          <source>Tell cvsexportcommit that the current working directory is not only a Git checkout, but also the CVS checkout. Therefore, Git will reset the working directory to the parent commit before proceeding.</source>
          <target state="translated">告诉 cvsexportcommit 当前的工作目录不仅是 Git 的签出,也是 CVS 的签出。因此,Git 会在继续之前将工作目录重置为父提交。</target>
        </trans-unit>
        <trans-unit id="ccc8867e7c10f12bec70f18c0ebdd4b98ffcfd5b" translate="yes" xml:space="preserve">
          <source>Tell git-credential-cache&amp;mdash;​daemon to ignore SIGHUP, instead of quitting.</source>
          <target state="translated">告诉git-credential-cache-守护程序忽略SIGHUP，而不是退出。</target>
        </trans-unit>
        <trans-unit id="500ee09ba16068aaf0936f5ee6b5ef58c4f8bd06" translate="yes" xml:space="preserve">
          <source>Tell the command to automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected.</source>
          <target state="translated">告诉命令自动缓存已经被修改和删除的文件,但没有告诉 Git 的新文件不受影响。</target>
        </trans-unit>
        <trans-unit id="a69e5b7ab968a315154a9d1fd7cf0d147021841a" translate="yes" xml:space="preserve">
          <source>Telling Git about your changes.</source>
          <target state="translated">把你的变化告诉Git。</target>
        </trans-unit>
        <trans-unit id="52aedbe077c84f7c253f79171da85dc15b08fdf7" translate="yes" xml:space="preserve">
          <source>Telling Git your name</source>
          <target state="translated">告诉Git你的名字</target>
        </trans-unit>
        <trans-unit id="47964a2a2b9ba19cb7edfe94ae99ae894e487ad7" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;git add&lt;/code&gt; to continue adding files when some files cannot be added due to indexing errors. Equivalent to the &lt;code&gt;--ignore-errors&lt;/code&gt; option of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;. &lt;code&gt;add.ignore-errors&lt;/code&gt; is deprecated, as it does not follow the usual naming convention for configuration variables.</source>
          <target state="translated">当由于索引错误而无法添加某些文件时，告诉 &lt;code&gt;git add&lt;/code&gt; 继续添加文件。等效于&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;的 &lt;code&gt;--ignore-errors&lt;/code&gt; 选项。不建议使用 &lt;code&gt;add.ignore-errors&lt;/code&gt; ，因为它不遵循配置变量的常规命名约定。</target>
        </trans-unit>
        <trans-unit id="e23c71acb4f3fb6cc5e3124fdbba41789615dcfa" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;git apply&lt;/code&gt; how to handle whitespaces, in the same way as the &lt;code&gt;--whitespace&lt;/code&gt; option. See &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;.</source>
          <target state="translated">告诉 &lt;code&gt;git apply&lt;/code&gt; 和 &lt;code&gt;--whitespace&lt;/code&gt; 选项一样，如何处理空格。参见&lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b4fd4c56fbd55fd6a4b61da1b1b25feb1363cb0" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;git branch&lt;/code&gt;, &lt;code&gt;git switch&lt;/code&gt; and &lt;code&gt;git checkout&lt;/code&gt; to set up new branches so that &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; will appropriately merge from the starting point branch. Note that even if this option is not set, this behavior can be chosen per-branch using the &lt;code&gt;--track&lt;/code&gt; and &lt;code&gt;--no-track&lt;/code&gt; options. The valid settings are: &lt;code&gt;false&lt;/code&gt; &amp;mdash; no automatic setup is done; &lt;code&gt;true&lt;/code&gt; &amp;mdash; automatic setup is done when the starting point is a remote-tracking branch; &lt;code&gt;always&lt;/code&gt; &amp;mdash; automatic setup is done when the starting point is either a local branch or remote-tracking branch. This option defaults to true.</source>
          <target state="translated">告诉 &lt;code&gt;git branch&lt;/code&gt; ， &lt;code&gt;git switch&lt;/code&gt; 和 &lt;code&gt;git checkout&lt;/code&gt; 设置新分支，以便&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;从起点分支适当合并。请注意，即使未设置此选项，也可以使用 &lt;code&gt;--track&lt;/code&gt; 和 &lt;code&gt;--no-track&lt;/code&gt; 选项在每个分支中选择此行为。有效设置为： &lt;code&gt;false&lt;/code&gt; -不执行自动设置；否则为false。 &lt;code&gt;true&lt;/code&gt; &amp;mdash;当起点是远程跟踪分支时，将完成自动设置； &lt;code&gt;always&lt;/code&gt; -当起点是本地分支或远程跟踪分支时，将完成自动设置。此选项默认为true。</target>
        </trans-unit>
        <trans-unit id="33792c2c707e004799933a452c481ccd3dd6df72" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;merge-recursive&lt;/code&gt; to use a different diff algorithm, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--diff-algorithm&lt;/code&gt;.</source>
          <target state="translated">告诉 &lt;code&gt;merge-recursive&lt;/code&gt; 使用不同的diff算法，这可以帮助避免由于不重要的匹配行（例如，来自不同函数的括号）而导致的合并错误。另请参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--diff-algorithm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="322e9bf79fc78c188017b38cca0390d8ca24df83" translate="yes" xml:space="preserve">
          <source>Tells Git if the executable bit of files in the working tree is to be honored.</source>
          <target state="translated">告诉 Git 是否要尊重工作树中文件的可执行位。</target>
        </trans-unit>
        <trans-unit id="e732c8317ebf66ceb1e3db1424bc67bd01187e09" translate="yes" xml:space="preserve">
          <source>Template directory</source>
          <target state="translated">模板目录</target>
        </trans-unit>
        <trans-unit id="ab43df8613b6388c0548cc8be9da228db8e98898" translate="yes" xml:space="preserve">
          <source>Temporarily setting aside work in progress</source>
          <target state="translated">暂时搁置正在进行的工作</target>
        </trans-unit>
        <trans-unit id="8e2754fc91f29834706af71cfa26258d56805769" translate="yes" xml:space="preserve">
          <source>Temporary files</source>
          <target state="translated">临时文件</target>
        </trans-unit>
        <trans-unit id="9c01e9143498ee202aefdfaa27172587b4069975" translate="yes" xml:space="preserve">
          <source>Terminate entries with NUL, instead of LF. This implies the &lt;code&gt;--porcelain=v1&lt;/code&gt; output format if no other format is given.</source>
          <target state="translated">用NUL（而不是LF）终止条目。如果未指定其他格式，则表示 &lt;code&gt;--porcelain=v1&lt;/code&gt; 输出格式。</target>
        </trans-unit>
        <trans-unit id="07c6a191135373ac9d2aee0a3bde3b658792a63e" translate="yes" xml:space="preserve">
          <source>Terminate with error if there is no &lt;code&gt;done&lt;/code&gt; command at the end of the stream. This option might be useful for detecting errors that cause the frontend to terminate before it has started to write a stream.</source>
          <target state="translated">如果流的末尾没有 &lt;code&gt;done&lt;/code&gt; 命令，则以错误终止。此选项对于检测导致前端在开始写入流之前终止的错误很有用。</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="cf10c8624337ce67bcf480537830a31a54a327a5" translate="yes" xml:space="preserve">
          <source>Test suites are very nice. But when they are used alone, they are supposed to be used so that all the tests are checked after each commit. This means that they are not very efficient, because many tests are run for no interesting result, and they suffer from combinatorial explosion.</source>
          <target state="translated">测试套件是非常好的。但是当它们单独使用时,它们应该被使用,以便在每次提交后检查所有的测试。这意味着它们的效率并不高,因为很多测试都是为了没有有趣的结果而运行的,而且它们受到组合爆炸的影响。</target>
        </trans-unit>
        <trans-unit id="c7039b793911c3e74e0619b364427be7bb23668d" translate="yes" xml:space="preserve">
          <source>Testing has been done using both the CLI CVS client, and the Eclipse CVS plugin. Most functionality works fine with both of these clients.</source>
          <target state="translated">我们使用CLI CVS客户端和Eclipse CVS插件进行了测试。大部分功能在这两种客户端下都能正常工作。</target>
        </trans-unit>
        <trans-unit id="499b8eda34fd3ef3837b1d2448aadbb6279371d8" translate="yes" xml:space="preserve">
          <source>Testing partial commits</source>
          <target state="translated">测试部分提交</target>
        </trans-unit>
        <trans-unit id="c5dcd73cdfef43c79255820898dee98a4377a12f" translate="yes" xml:space="preserve">
          <source>Text editor for use by Git commands. The value is meant to be interpreted by the shell when it is used. Examples: &lt;code&gt;~/bin/vi&lt;/code&gt;, &lt;code&gt;$SOME_ENVIRONMENT_VARIABLE&lt;/code&gt;, &lt;code&gt;&quot;C:\Program Files\Vim\gvim.exe&quot;
--nofork&lt;/code&gt;. The order of preference is the &lt;code&gt;$GIT_EDITOR&lt;/code&gt; environment variable, then &lt;code&gt;core.editor&lt;/code&gt; configuration, then &lt;code&gt;$VISUAL&lt;/code&gt;, then &lt;code&gt;$EDITOR&lt;/code&gt;, and then the default chosen at compile time, which is usually &lt;code&gt;vi&lt;/code&gt;.</source>
          <target state="translated">Git命令使用的文本编辑器。该值应在使用时由Shell解释。示例： &lt;code&gt;~/bin/vi&lt;/code&gt; ， &lt;code&gt;$SOME_ENVIRONMENT_VARIABLE&lt;/code&gt; ， &lt;code&gt;&quot;C:\Program Files\Vim\gvim.exe&quot; --nofork&lt;/code&gt; 。优先顺序是 &lt;code&gt;$GIT_EDITOR&lt;/code&gt; 环境变量，然后是 &lt;code&gt;core.editor&lt;/code&gt; 配置，然后是 &lt;code&gt;$VISUAL&lt;/code&gt; ，然后是 &lt;code&gt;$EDITOR&lt;/code&gt; ，然后是编译时选择的默认值，通常是 &lt;code&gt;vi&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="016aa532b4e9fa7fee1cc89b5c6aa348edd44f21" translate="yes" xml:space="preserve">
          <source>Text editor used by &lt;code&gt;git rebase -i&lt;/code&gt; for editing the rebase instruction file. The value is meant to be interpreted by the shell when it is used. It can be overridden by the &lt;code&gt;GIT_SEQUENCE_EDITOR&lt;/code&gt; environment variable. When not configured the default commit message editor is used instead.</source>
          <target state="translated">&lt;code&gt;git rebase -i&lt;/code&gt; 使用的文本编辑器，用于编辑rebase指令文件。该值应在使用时由Shell解释。可以被 &lt;code&gt;GIT_SEQUENCE_EDITOR&lt;/code&gt; 环境变量覆盖。如果未配置，则使用默认的提交消息编辑器。</target>
        </trans-unit>
        <trans-unit id="a8fe9598336f37cb9328ca8052e59b151a7933de" translate="yes" xml:space="preserve">
          <source>Text viewer for use by Git commands (e.g., &lt;code&gt;less&lt;/code&gt;). The value is meant to be interpreted by the shell. The order of preference is the &lt;code&gt;$GIT_PAGER&lt;/code&gt; environment variable, then &lt;code&gt;core.pager&lt;/code&gt; configuration, then &lt;code&gt;$PAGER&lt;/code&gt;, and then the default chosen at compile time (usually &lt;code&gt;less&lt;/code&gt;).</source>
          <target state="translated">Git命令使用的文本查看器（例如， &lt;code&gt;less&lt;/code&gt; ）。该值应由外壳解释。优先顺序是 &lt;code&gt;$GIT_PAGER&lt;/code&gt; 环境变量，然后是 &lt;code&gt;core.pager&lt;/code&gt; 配置，然后是 &lt;code&gt;$PAGER&lt;/code&gt; ，然后是在编译时选择的默认值（通常 &lt;code&gt;less&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0bd1b0b7ad0ea4fe7d508b463e4e610ef00887b1" translate="yes" xml:space="preserve">
          <source>That is, a pattern followed by an attributes list, separated by whitespaces. Leading and trailing whitespaces are ignored. Lines that begin with &lt;code&gt;#&lt;/code&gt; are ignored. Patterns that begin with a double quote are quoted in C style. When the pattern matches the path in question, the attributes listed on the line are given to the path.</source>
          <target state="translated">也就是说，模式后面是属性列表，由空格隔开。前导和尾随空格将被忽略。以 &lt;code&gt;#&lt;/code&gt; 开头的行将被忽略。以双引号开头的模式以C样式引用。当模式与所讨论的路径匹配时，将在行上列出的属性赋予该路径。</target>
        </trans-unit>
        <trans-unit id="a2ed6bb3b9b6e451ccc6f660ef58cfb1d5aab73c" translate="yes" xml:space="preserve">
          <source>That is, from left to right:</source>
          <target state="translated">就是说,从左到右。</target>
        </trans-unit>
        <trans-unit id="8f093c96f9e4fd62eb55be18fd622f6079c4aad2" translate="yes" xml:space="preserve">
          <source>That is, from the left to the right:</source>
          <target state="translated">就是说,从左边到右边。</target>
        </trans-unit>
        <trans-unit id="11e8a09abfceb997eddb8423e1781ebd95db28e7" translate="yes" xml:space="preserve">
          <source>That is:</source>
          <target state="translated">那就是:</target>
        </trans-unit>
        <trans-unit id="aa54aa26ef67ef77a7b5a4203a2f21478483f336" translate="yes" xml:space="preserve">
          <source>That means that even if you offer only read access (e.g. by using the pserver method), &lt;code&gt;git-cvsserver&lt;/code&gt; should have write access to the database to work reliably (otherwise you need to make sure that the database is up to date any time &lt;code&gt;git-cvsserver&lt;/code&gt; is executed).</source>
          <target state="translated">这意味着，即使你（通过使用pserver的方法如）提供只读访问， &lt;code&gt;git-cvsserver&lt;/code&gt; 应该具有对数据库的工作可靠的写权限（否则你需要确保数据库是最新的任何时间 &lt;code&gt;git-cvsserver&lt;/code&gt; 已执行）。</target>
        </trans-unit>
        <trans-unit id="452813997abf32b7a81b495ef3287ae8cfa66246" translate="yes" xml:space="preserve">
          <source>That means that if you do a &lt;code&gt;git read-tree -m &amp;lt;newtree&amp;gt;&lt;/code&gt; followed by a &lt;code&gt;git checkout-index -f -u -a&lt;/code&gt;, the &lt;code&gt;git checkout-index&lt;/code&gt; only checks out the stuff that really changed.</source>
          <target state="translated">这意味着，如果您执行 &lt;code&gt;git read-tree -m &amp;lt;newtree&amp;gt;&lt;/code&gt; 后接 &lt;code&gt;git checkout-index -f -u -a&lt;/code&gt; ，则 &lt;code&gt;git checkout-index&lt;/code&gt; 仅签出真正更改的内容。</target>
        </trans-unit>
        <trans-unit id="a1aaaec20914cfb53973b0431f384394f0c406ca" translate="yes" xml:space="preserve">
          <source>That puts the heads and tags for each fork in their own island (named &quot;1234&quot; or similar), and the pull refs for each go into their own &quot;1234-pull&quot;.</source>
          <target state="translated">这样就把每个分叉的头和标签放在自己的岛中(命名为 &quot;1234 &quot;或类似的),而每个分叉的拉动参考则进入自己的 &quot;1234-pull&quot;。</target>
        </trans-unit>
        <trans-unit id="767670eb6ab18d660b358046eb00166f0a64fef3" translate="yes" xml:space="preserve">
          <source>That will produce the diff between the tips of the two branches. If you&amp;rsquo;d prefer to find the diff from their common ancestor to test, you can use three dots instead of two:</source>
          <target state="translated">这将在两个分支的尖端之间产生差异。如果您希望从他们的共同祖先找到差异进行测试，则可以使用三个点而不是两个点：</target>
        </trans-unit>
        <trans-unit id="2ab4548e0b841bbace5e0a92c23778ab654224e3" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why the &quot;git replace&quot; command was created. Technically it stores replacements &quot;refs&quot; in the &quot;refs/replace/&quot; hierarchy. These &quot;refs&quot; are like branches (that are stored in &quot;refs/heads/&quot;) or tags (that are stored in &quot;refs/tags&quot;), and that means that they can automatically be shared like branches or tags among developers.</source>
          <target state="translated">这就是创建&amp;ldquo; git replace&amp;rdquo;命令的原因。从技术上讲，它将替换&amp;ldquo; refs&amp;rdquo;存储在&amp;ldquo; refs / replace /&amp;rdquo;层次结构中。这些&amp;ldquo;引用&amp;rdquo;就像分支（存储在&amp;ldquo; refs / heads /&amp;rdquo;中）或标签（存储在&amp;ldquo; refs / tags&amp;rdquo;中）一样，这意味着它们可以像分支或标签一样在开发人员之间自动共享。</target>
        </trans-unit>
        <trans-unit id="e7f78784e12fead6a14f302d919d7dfe2a02b05b" translate="yes" xml:space="preserve">
          <source>The &quot;child_class&quot; field is a rough classification, such as &quot;editor&quot;, &quot;pager&quot;, &quot;transport/*&quot;, and &quot;hook&quot;. Unclassified children are classified with &quot;?&quot;.</source>
          <target state="translated">&quot;child_class &quot;字段是一个粗略的分类,如 &quot;editor&quot;、&quot;pager&quot;、&quot;transport/*&quot;、&quot;hook &quot;等。未分类的孩子用&quot;?&quot;来分类。</target>
        </trans-unit>
        <trans-unit id="fe5496d60fae83b54bfa30bb265cd284e395a597" translate="yes" xml:space="preserve">
          <source>The &quot;child_id&quot; field can be used to match this child_start with the corresponding child_exit event.</source>
          <target state="translated">&quot;child_id &quot;字段可以用来匹配这个child_start和相应的child_exit事件。</target>
        </trans-unit>
        <trans-unit id="2ee1a593683be8a9c62bf7139373ea713a6461c3" translate="yes" xml:space="preserve">
          <source>The &quot;commit&quot; object links a physical state of a tree with a description of how we got there and why. Use the &lt;code&gt;--pretty=raw&lt;/code&gt; option to &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; or &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; to examine your favorite commit:</source>
          <target state="translated">&amp;ldquo;提交&amp;rdquo;对象将一棵树的物理状态与我们如何到达那里以及为什么的描述联系起来。使用 &lt;code&gt;--pretty=raw&lt;/code&gt; 选项在&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;或&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;中检查您喜欢的提交：</target>
        </trans-unit>
        <trans-unit id="6db6601ce62b96f9f8fba54efac9ee5967a731f4" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; value consists of a list of triplets in the form &lt;code&gt;(&quot;&amp;lt;label&amp;gt;&quot;, &quot;&amp;lt;link&amp;gt;&quot;, &quot;&amp;lt;position&amp;gt;&quot;)&lt;/code&gt; where &quot;position&quot; is the label after which to insert the link, &quot;link&quot; is a format string where &lt;code&gt;%n&lt;/code&gt; expands to the project name, &lt;code&gt;%f&lt;/code&gt; to the project path within the filesystem (i.e. &quot;$projectroot/$project&quot;), &lt;code&gt;%h&lt;/code&gt; to the current hash ('h' gitweb parameter) and &lt;code&gt;%b&lt;/code&gt; to the current hash base ('hb' gitweb parameter); &lt;code&gt;%%&lt;/code&gt; expands to '%'.</source>
          <target state="translated">&amp;ldquo;默认&amp;rdquo;值由格式 &lt;code&gt;(&quot;&amp;lt;label&amp;gt;&quot;, &quot;&amp;lt;link&amp;gt;&quot;, &quot;&amp;lt;position&amp;gt;&quot;)&lt;/code&gt; 的三元组列表组成，其中&amp;ldquo;位置&amp;rdquo;是插入链接的标签，&amp;ldquo;链接&amp;rdquo;是一个格式字符串，其中 &lt;code&gt;%n&lt;/code&gt; 扩展为项目名称， &lt;code&gt;%f&lt;/code&gt; 为文件系统内的项目路径（即&amp;ldquo; $ projectroot / $ project&amp;rdquo;）， &lt;code&gt;%h&lt;/code&gt; 为当前哈希（'h'gitweb参数）， &lt;code&gt;%b&lt;/code&gt; 为当前的哈希库（'hb'gitweb参数）； &lt;code&gt;%%&lt;/code&gt; 扩展为'％'。</target>
        </trans-unit>
        <trans-unit id="a92a8477d5d97d17f1c481b90522235992b0aec5" translate="yes" xml:space="preserve">
          <source>The &quot;delete&quot; subcommand deletes single entries from the reflog. Its argument must be an &lt;code&gt;exact&lt;/code&gt; entry (e.g. &quot;&lt;code&gt;git reflog delete
master@{2}&lt;/code&gt;&quot;). This subcommand is also typically not used directly by end users.</source>
          <target state="translated">&amp;ldquo;删除&amp;rdquo;子命令从引用日志中删除单个条目。它的参数必须是一个 &lt;code&gt;exact&lt;/code&gt; 条目（例如&amp;ldquo; &lt;code&gt;git reflog delete master@{2}&lt;/code&gt; &amp;rdquo;）。最终用户通常也不会直接使用此子命令。</target>
        </trans-unit>
        <trans-unit id="15cc724d6cfbdaca681c81ec6b39527ea7ba3e75" translate="yes" xml:space="preserve">
          <source>The &quot;downwards graduation&quot; discussed above cannot be done by actually merging downwards, however, since that would merge &lt;code&gt;all&lt;/code&gt; changes on the unstable branch into the stable one. Hence the following:</source>
          <target state="translated">上面讨论的&amp;ldquo;向下分级&amp;rdquo;不能通过实际向下合并来完成，但是，因为那样会将不稳定分支上的 &lt;code&gt;all&lt;/code&gt; 更改合并到稳定分支中。因此，以下内容：</target>
        </trans-unit>
        <trans-unit id="4b681909e4d1085f8faa13044f43a355b4e9ca0a" translate="yes" xml:space="preserve">
          <source>The &quot;exec&quot; command launches the command in a shell (the one specified in &lt;code&gt;$SHELL&lt;/code&gt;, or the default shell if &lt;code&gt;$SHELL&lt;/code&gt; is not set), so you can use shell features (like &quot;cd&quot;, &quot;&amp;gt;&quot;, &quot;;&quot; &amp;hellip;​). The command is run from the root of the working tree.</source>
          <target state="translated">&amp;ldquo; exec&amp;rdquo;命令在外壳程序（ &lt;code&gt;$SHELL&lt;/code&gt; 指定的命令，如果未设置 &lt;code&gt;$SHELL&lt;/code&gt; 则为默认外壳程序）中启动命令，因此您可以使用外壳程序功能（如&amp;ldquo; cd&amp;rdquo;，&amp;ldquo;&amp;ldquo;&amp;gt;&amp;rdquo;，&amp;ldquo;;&amp;rdquo;） ......）该命令从工作树的根目录运行。</target>
        </trans-unit>
        <trans-unit id="3e27bb28ac33a3ed0da91ec19b0543d1741f2754" translate="yes" xml:space="preserve">
          <source>The &quot;exec_id&quot; field is a command-unique id and is only useful if the &lt;code&gt;exec()&lt;/code&gt; fails and a corresponding exec_result event is generated.</source>
          <target state="translated">&amp;ldquo; exec_id&amp;rdquo;字段是命令唯一的ID，仅在 &lt;code&gt;exec()&lt;/code&gt; 失败并且生成了相应的exec_result事件时才有用。</target>
        </trans-unit>
        <trans-unit id="111dec81403753e6a7d49025386f92b4f5a7ce80" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; subcommand checks whether a ref has a reflog. It exits with zero status if the reflog exists, and non-zero status if it does not.</source>
          <target state="translated">存在 &quot;子命令用于检查一个 ref 是否有 reflog,如果 reflog 存在,则以零状态退出,如果不存在,则以非零状态退出。如果reflog存在,则以零状态退出,如果不存在,则以非零状态退出。</target>
        </trans-unit>
        <trans-unit id="b084a3a2964fff409a1c4bd5eaf3ff2af985bb46" translate="yes" xml:space="preserve">
          <source>The &quot;experimental&quot; branch is the one you just created, and the &quot;master&quot; branch is a default branch that was created for you automatically. The asterisk marks the branch you are currently on; type</source>
          <target state="translated">实验 &quot;分支是您刚刚创建的分支,&quot;主 &quot;分支是自动为您创建的默认分支。星号表示你目前所在的分支,输入</target>
        </trans-unit>
        <trans-unit id="8a5c55e5646a8a6620c2e2207d5f34af5eadc4f2" translate="yes" xml:space="preserve">
          <source>The &quot;expire&quot; subcommand prunes older reflog entries. Entries older than &lt;code&gt;expire&lt;/code&gt; time, or entries older than &lt;code&gt;expire-unreachable&lt;/code&gt; time and not reachable from the current tip, are removed from the reflog. This is typically not used directly by end users &amp;mdash; instead, see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; expire&amp;rdquo;子命令修剪较旧的引用日志条目。早于 &lt;code&gt;expire&lt;/code&gt; 时间的条目，或早于 &lt;code&gt;expire-unreachable&lt;/code&gt; 时间且无法从当前提示访问的条目，都将从reflog中删除。最终用户通常不直接使用它，而是参见&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51ddfbdb206861a134ce9d36a0cd6f8dcb912a92" translate="yes" xml:space="preserve">
          <source>The &quot;extent of changes&quot; parameter can be tweaked from the default 80% (that is, unless more than 80% of the original material is deleted, the broken pairs are merged back into a single modification) by giving a second number to -B option, like these:</source>
          <target state="translated">&quot;修改范围 &quot;参数可以从默认的80%(也就是除非删除超过80%的原始材料,否则破损的对子会被合并回一个修改),通过给-B选项赋予第二个数字来调整,比如这些。</target>
        </trans-unit>
        <trans-unit id="4be913eb74285fc0f11c845775de3706d8e8ac4f" translate="yes" xml:space="preserve">
          <source>The &quot;git-diff-tree&quot; command begins its output by printing the hash of what is being compared. After that, all the commands print one output line per changed file.</source>
          <target state="translated">&quot;git-diff-tree &quot;命令的输出首先是打印正在比较的内容的哈希值。之后,所有的命令都是每修改一个文件打印一行输出。</target>
        </trans-unit>
        <trans-unit id="14e841537fdff67ebd6d58e11774065ab0f0ebfa" translate="yes" xml:space="preserve">
          <source>The &quot;indent&quot; filter is well-behaved in this regard: it will not modify input that is already correctly indented. In this case, the lack of a smudge filter means that the clean filter &lt;code&gt;must&lt;/code&gt; accept its own output without modifying it.</source>
          <target state="translated">&amp;ldquo;缩进&amp;rdquo;过滤器在这方面表现良好：它不会修改已经正确缩进的输入。在这种情况下，缺少污迹过滤器意味着干净的过滤器 &lt;code&gt;must&lt;/code&gt; 接受其自身的输出而不进行修改。</target>
        </trans-unit>
        <trans-unit id="2a9f18fc49cc181471bfbc97a47a88e9bcc1179f" translate="yes" xml:space="preserve">
          <source>The &quot;index&quot; holds a snapshot of the content of the working tree, and it is this snapshot that is taken as the contents of the next commit. Thus after making any changes to the working tree, and before running the commit command, you must use the &lt;code&gt;add&lt;/code&gt; command to add any new or modified files to the index.</source>
          <target state="translated">&amp;ldquo;索引&amp;rdquo;保存着工作树内容的快照，正是该快照被用作下一次提交的内容。因此，在对工作树进行任何更改之后，并且在运行commit命令之前，必须使用 &lt;code&gt;add&lt;/code&gt; 命令将所有新文件或修改过的文件添加到索引中。</target>
        </trans-unit>
        <trans-unit id="6b5b86b50febe55839cf4e73fade50a78b6b0a0e" translate="yes" xml:space="preserve">
          <source>The &quot;master&quot; branch that was created at the time you cloned is a copy of the HEAD in the repository that you cloned from. That repository may also have had other branches, though, and your local repository keeps branches which track each of those remote branches, called remote-tracking branches, which you can view using the &lt;code&gt;-r&lt;/code&gt; option to &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;:</source>
          <target state="translated">克隆时创建的&amp;ldquo; master&amp;rdquo;分支是克隆源中HEAD的副本。但是，该存储库可能还具有其他分支，并且本地存储库保留跟踪每个远程分支的分支，称为远程跟踪分支，您可以使用&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;的 &lt;code&gt;-r&lt;/code&gt; 选项进行查看：</target>
        </trans-unit>
        <trans-unit id="b0e05ae2162ea2794c2d7383fd67bd0eb622aa45" translate="yes" xml:space="preserve">
          <source>The &quot;name&quot; field is an arbitrary string to describe the command mode. For example, checkout can checkout a branch or an individual file. And these variations typically have different performance characteristics that are not comparable.</source>
          <target state="translated">&quot;name &quot;字段是一个任意的字符串,用来描述命令模式。例如,checkout可以检查一个分支或单个文件。而这些变化通常具有不同的性能特点,没有可比性。</target>
        </trans-unit>
        <trans-unit id="dd5002fa5ace7f79f3506e0a4b77fdeff5bda038" translate="yes" xml:space="preserve">
          <source>The &quot;non-cached&quot; mode takes a different approach, and is potentially the more useful of the two in that what it does can&amp;rsquo;t be emulated with a &lt;code&gt;git write-tree&lt;/code&gt; + &lt;code&gt;git diff-tree&lt;/code&gt;. Thus that&amp;rsquo;s the default mode. The non-cached version asks the question:</source>
          <target state="translated">&amp;ldquo;非缓存&amp;rdquo;模式采用了不同的方法，并且可能在两者中更有用，因为它不能用 &lt;code&gt;git write-tree&lt;/code&gt; + &lt;code&gt;git diff-tree&lt;/code&gt; 来模拟。因此，这是默认模式。非缓存版本会提出以下问题：</target>
        </trans-unit>
        <trans-unit id="fb600e178320a3e93fbf20a6c6f69b12e2843e17" translate="yes" xml:space="preserve">
          <source>The &quot;pull&quot; command thus performs two operations: it fetches changes from a remote branch, then merges them into the current branch.</source>
          <target state="translated">因此,&quot;pull &quot;命令执行两个操作:它从远程分支获取变更,然后将它们合并到当前分支。</target>
        </trans-unit>
        <trans-unit id="70b3edc9504f2665b7793306c4b0a620ef20dadb" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository that is destination of a push operation. This parameter can be either a URL (see the section &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; below) or the name of a remote (see the section &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; below).</source>
          <target state="translated">作为推送操作目标的&amp;ldquo;远程&amp;rdquo;存储库。此参数可以是URL（请参阅下面的&lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt;部分）或遥控器的名称（请参见下面的&lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt;部分）。</target>
        </trans-unit>
        <trans-unit id="0610be2d46404a8f9561c2512c45bc2650bc2b77" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository that is the source of a fetch or pull operation. This parameter can be either a URL (see the section &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; below) or the name of a remote (see the section &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; below).</source>
          <target state="translated">作为提取或拉取操作来源的&amp;ldquo;远程&amp;rdquo;存储库。此参数可以是URL（请参阅下面的&lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt;部分）或遥控器的名称（请参见下面的&lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt;部分）。</target>
        </trans-unit>
        <trans-unit id="672e385879e10047919cb534a388204453fa9b9b" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository to query. This parameter can be either a URL or the name of a remote (see the GIT URLS and REMOTES sections of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">要查询的&amp;ldquo;远程&amp;rdquo;存储库。此参数可以是URL或远程名称（请参阅&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;的GIT URLS和REMOTES部分）。</target>
        </trans-unit>
        <trans-unit id="c6967bbb137406cb4cb1860aeca604a66e63b551" translate="yes" xml:space="preserve">
          <source>The &quot;show&quot; subcommand (which is also the default, in the absence of any subcommands) shows the log of the reference provided in the command-line (or &lt;code&gt;HEAD&lt;/code&gt;, by default). The reflog covers all recent actions, and in addition the &lt;code&gt;HEAD&lt;/code&gt; reflog records branch switching. &lt;code&gt;git reflog show&lt;/code&gt; is an alias for &lt;code&gt;git log -g --abbrev-commit
--pretty=oneline&lt;/code&gt;; see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for more information.</source>
          <target state="translated">&amp;ldquo; show&amp;rdquo;子命令（在没有任何子命令的情况下也是默认值）显示命令行（默认为 &lt;code&gt;HEAD&lt;/code&gt; ）中提供的引用的日志。刷新日志涵盖了所有最近的操作，此外， &lt;code&gt;HEAD&lt;/code&gt; 刷新日志还记录了分支切换。 &lt;code&gt;git reflog show&lt;/code&gt; 是 &lt;code&gt;git log -g --abbrev-commit --pretty=oneline&lt;/code&gt; 的别名；有关更多信息，请参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f44e4ac17ec1a545f86623659c266196a2646a2" translate="yes" xml:space="preserve">
          <source>The &quot;status&quot; command is a useful way to get a quick summary of the situation:</source>
          <target state="translated">&quot;状态 &quot;命令是快速了解情况的有用方法。</target>
        </trans-unit>
        <trans-unit id="97877392fd9cfcae446bf7fdee6a5be7af0d7e1e" translate="yes" xml:space="preserve">
          <source>The &quot;tar.gz&quot; and &quot;tgz&quot; formats are defined automatically and default to &lt;code&gt;gzip -cn&lt;/code&gt;. You may override them with custom commands.</source>
          <target state="translated">&amp;ldquo; tar.gz&amp;rdquo;和&amp;ldquo; tgz&amp;rdquo;格式是自动定义的，默认为 &lt;code&gt;gzip -cn&lt;/code&gt; 。您可以使用自定义命令覆盖它们。</target>
        </trans-unit>
        <trans-unit id="de5a671425f0a835fc1aa7cc9c82d529d93b1856" translate="yes" xml:space="preserve">
          <source>The &quot;tree&quot; object here refers to the new state of the tree:</source>
          <target state="translated">这里的 &quot;树 &quot;对象指的是树的新状态。</target>
        </trans-unit>
        <trans-unit id="e01253337b76bf7642cbcef035c48eb0188a2f7d" translate="yes" xml:space="preserve">
          <source>The &quot;value&quot; field may be an integer or a string.</source>
          <target state="translated">值 &quot;字段可以是一个整数或字符串。</target>
        </trans-unit>
        <trans-unit id="38b8f4a1de6f86897b3e2a50acc4b0dda41fe280" translate="yes" xml:space="preserve">
          <source>The &amp;lt;dataref&amp;gt; represents the blob, tree, or commit object at &amp;lt;path&amp;gt; and can be used in later &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;cat-blob&lt;/code&gt;, &lt;code&gt;filemodify&lt;/code&gt;, or &lt;code&gt;ls&lt;/code&gt; commands.</source>
          <target state="translated">&amp;lt;dataref&amp;gt;表示&amp;lt;path&amp;gt;处的blob，tree或commit对象，可以在以后的 &lt;code&gt;get-mark&lt;/code&gt; ， &lt;code&gt;cat-blob&lt;/code&gt; ， &lt;code&gt;filemodify&lt;/code&gt; 或 &lt;code&gt;ls&lt;/code&gt; 命令中使用。</target>
        </trans-unit>
        <trans-unit id="118ecd88d0a05a5c1cb4a877b8fac543b0b9ad8d" translate="yes" xml:space="preserve">
          <source>The &amp;lt;dst&amp;gt; tells which ref on the remote side is updated with this push. Arbitrary expressions cannot be used here, an actual ref must be named. If &lt;code&gt;git push [&amp;lt;repository&amp;gt;]&lt;/code&gt; without any &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; argument is set to update some ref at the destination with &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; with &lt;code&gt;remote.&amp;lt;repository&amp;gt;.push&lt;/code&gt; configuration variable, &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; part can be omitted&amp;mdash;​such a push will update a ref that &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; normally updates without any &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; on the command line. Otherwise, missing &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; means to update the same ref as the &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;dst&amp;gt;告知通过此推送更新远程端的哪个引用。此处不能使用任意表达式，必须命名实际引用。如果 &lt;code&gt;git push [&amp;lt;repository&amp;gt;]&lt;/code&gt; 不带任何 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 参数的git push [&amp;lt;repository&amp;gt;]设置为使用带有 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.push&lt;/code&gt; 配置变量的 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 更新目标处的某些ref，则可以省略 &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; 部分-这样push将更新 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 通常不会在命令行上添加任何 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 的引用。否则，缺少 &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; 意味着要更新与 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 相同的引用。</target>
        </trans-unit>
        <trans-unit id="a11f746174b65907575be3c7e94b2869a6db53ed" translate="yes" xml:space="preserve">
          <source>The &amp;lt;feature&amp;gt; part of the command may be any one of the following:</source>
          <target state="translated">命令的&amp;lt;feature&amp;gt;部分可以是以下任意一项：</target>
        </trans-unit>
        <trans-unit id="12c10723a00c71e41369dc4ab439f9bc656fc9a7" translate="yes" xml:space="preserve">
          <source>The &amp;lt;file&amp;gt; list given to the command can be exact pathnames, file glob patterns, or leading directory names. The command removes only the paths that are known to Git. Giving the name of a file that you have not told Git about does not remove that file.</source>
          <target state="translated">赋予命令的&amp;lt;file&amp;gt;列表可以是确切的路径名，文件全局模​​式或前导目录名。该命令仅删除Git已知的路径。提供您未告知Git的文件名不会删除该文件。</target>
        </trans-unit>
        <trans-unit id="d9a9d78d51370431396c79c2da7d525a4215ec53" translate="yes" xml:space="preserve">
          <source>The &amp;lt;paths&amp;gt; parameters, when given, are used to limit the diff to the named paths (you can give directory names and get diff for all files under them).</source>
          <target state="translated">如果指定了&amp;lt;paths&amp;gt;参数，则用于将diff限制为命名路径（您可以指定目录名称，并获取其下所有文件的diff）。</target>
        </trans-unit>
        <trans-unit id="be0e9224a3c31468000ef31d0ee2d41289501c7f" translate="yes" xml:space="preserve">
          <source>The &amp;lt;src&amp;gt; is often the name of the branch you would want to push, but it can be any arbitrary &quot;SHA-1 expression&quot;, such as &lt;code&gt;master~4&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt; (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;).</source>
          <target state="translated">在&amp;lt;SRC&amp;gt;通常是你想推，但它可以是任何任意的&amp;ldquo;SHA-1的表达&amp;rdquo;，如分支的名字 &lt;code&gt;master~4&lt;/code&gt; 或 &lt;code&gt;HEAD&lt;/code&gt; （参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7] &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="94b79c58bc3ec3bceec3b732165a2a52f94063c6" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, is present in the database but never &lt;code&gt;directly&lt;/code&gt; used. A dangling commit could be a root node.</source>
          <target state="translated">&amp;lt;type&amp;gt;对象&amp;lt;object&amp;gt;，存在于数据库中，但从未 &lt;code&gt;directly&lt;/code&gt; 使用过。悬空的提交可能是根节点。</target>
        </trans-unit>
        <trans-unit id="c165697ba8df58634f80c6f82752d5afcdee5578" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, is referred to but isn&amp;rsquo;t present in the database.</source>
          <target state="translated">&amp;lt;type&amp;gt;对象&amp;lt;object&amp;gt;被引用，但在数据库中不存在。</target>
        </trans-unit>
        <trans-unit id="5e6573bf54036812f2655d363c6262b69c0dca40" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, isn&amp;rsquo;t actually referred to directly or indirectly in any of the trees or commits seen. This can mean that there&amp;rsquo;s another root node that you&amp;rsquo;re not specifying or that the tree is corrupt. If you haven&amp;rsquo;t missed a root node then you might as well delete unreachable nodes since they can&amp;rsquo;t be used.</source>
          <target state="translated">实际上，在看到的任何树或提交中实际上都没有直接或间接引用&amp;lt;type&amp;gt;对象&amp;lt;object&amp;gt;。这可能意味着您没有指定另一个根节点，或者树已损坏。如果您没有错过根节点，那么您最好删除无法访问的节点，因为它们无法使用。</target>
        </trans-unit>
        <trans-unit id="afa0888330a84b7e0fff615f1c9b8a57ecf94505" translate="yes" xml:space="preserve">
          <source>The 'git sh-i18n scriptlet is designed to be sourced (using &lt;code&gt;.&lt;/code&gt;) by Git&amp;rsquo;s porcelain programs implemented in shell script. It provides wrappers for the GNU &lt;code&gt;gettext&lt;/code&gt; and &lt;code&gt;eval_gettext&lt;/code&gt; functions accessible through the &lt;code&gt;gettext.sh&lt;/code&gt; script, and provides pass-through fallbacks on systems without GNU gettext.</source>
          <target state="translated">'git sh-i18n脚本集旨在通过使用Git的shell脚本中的瓷器程序来获取（使用 &lt;code&gt;.&lt;/code&gt; ）。它提供了包装的GNU &lt;code&gt;gettext&lt;/code&gt; 和 &lt;code&gt;eval_gettext&lt;/code&gt; 通过访问功能 &lt;code&gt;gettext.sh&lt;/code&gt; 脚本，并提供了直通的系统上没有回退的gettext GNU。</target>
        </trans-unit>
        <trans-unit id="75c51ca5866a2731f86888419b9fb61d16567aec" translate="yes" xml:space="preserve">
          <source>The (fully qualified) refname from which to show notes when showing commit messages. The value of this variable can be set to a glob, in which case notes from all matching refs will be shown. You may also specify this configuration variable several times. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">当显示提交消息时,要显示注释的(完全限定的)refname。这个变量的值可以设置为 glob,在这种情况下,会显示所有匹配的 refs 的注释。您也可以多次指定这个配置变量。对于不存在的 refs 会发出警告,但不匹配的 glob 会被忽略。</target>
        </trans-unit>
        <trans-unit id="1e4ce979f13cefaaddaddc6c3ce47e1170286daa" translate="yes" xml:space="preserve">
          <source>The (possibly remote) repository to clone from. See the &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; section below for more information on specifying repositories.</source>
          <target state="translated">要克隆的（可能是远程的）存储库。有关指定存储库的更多信息，请参见下面的&lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="0958323d0ba18cc1a0d938e257756d1659d52ec9" translate="yes" xml:space="preserve">
          <source>The --exclude-existing form is a filter that does the inverse. It reads refs from stdin, one ref per line, and shows those that don&amp;rsquo;t exist in the local repository.</source>
          <target state="translated">--exclude-existing形式是进行逆运算的过滤器。它从stdin读取引用，每行一个引用，并显示本地存储库中不存在的引用。</target>
        </trans-unit>
        <trans-unit id="a043107d8410def266c54e81fdffaefcdaf6dd4c" translate="yes" xml:space="preserve">
          <source>The --smtp-server-option option must be repeated for each option you want to pass to the server. Likewise, different lines in the configuration files must be used for each option.</source>
          <target state="translated">对于要传递给服务器的每个选项,必须重复使用--smtp-server-option选项。同样,配置文件中的每个选项也必须使用不同的行。</target>
        </trans-unit>
        <trans-unit id="b478196a2fb02489b622996c5ea9b31713647e4d" translate="yes" xml:space="preserve">
          <source>The .git location may be auto-discovered, or come from &lt;code&gt;$GIT_DIR&lt;/code&gt; environment variable. If the repository is auto discovered via a .git file (e.g. from submodules, or a linked worktree), the .git location would be the final location where the .git directory is, not where the .git file is.</source>
          <target state="translated">.git位置可以自动发现，也可以来自 &lt;code&gt;$GIT_DIR&lt;/code&gt; 环境变量。如果通过.git文件（例如从子模块或链接的工作树）自动发现存储库，则.git位置将是.git目录的最终位置，而不是.git文件的位置。</target>
        </trans-unit>
        <trans-unit id="489d70f8c8831a28cdf6bb81a4079dab3fec8b7e" translate="yes" xml:space="preserve">
          <source>The 40-hex object name of the object.</source>
          <target state="translated">对象的40个十六进制的对象名称。</target>
        </trans-unit>
        <trans-unit id="edba0bac58d4604af8b0ccc3234ca39328b25c20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; command can create a tar or zip archive from any version of a project; for example:</source>
          <target state="translated">在&lt;a href=&quot;git-archive&quot;&gt;GIT中-归档[1]&lt;/a&gt;命令可以创建一个tar或zip从项目的任何版本的存档; 例如：</target>
        </trans-unit>
        <trans-unit id="8ff01ddb94fa5e45588517f77b5eb76be2068bf4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; command correctly handles history that includes merge commits. However, when the commit that it finds is a merge commit, the user may need to work harder than usual to figure out why that commit introduced a problem.</source>
          <target state="translated">在&lt;a href=&quot;git-bisect&quot;&gt;GIT-平分[1]&lt;/a&gt;命令正确处理历史，其包括合并的提交。但是，当它找到的提交是合并提交时，用户可能需要比平时更努力地工作，以弄清为什么该提交引起了问题。</target>
        </trans-unit>
        <trans-unit id="a1047413b5c194a852bce97f1a7a5b5c064c8f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt; command can show the contents of any object, though the higher-level &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; is usually more useful.</source>
          <target state="translated">在&lt;a href=&quot;git-cat-file&quot;&gt;GIT中-CAT-文件[1]&lt;/a&gt;命令可以显示任何对象的内容，虽然上级&lt;a href=&quot;git-show&quot;&gt;GIT中出现[1]&lt;/a&gt;通常更有用。</target>
        </trans-unit>
        <trans-unit id="0ea75322cb21a3c3c8fac48d1e6228de3fae3cce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; command allows constructing commits with arbitrary parents and trees.</source>
          <target state="translated">该&lt;a href=&quot;git-commit-tree&quot;&gt;混帐提交树[1]&lt;/a&gt;命令允许构建任意父母和树木的提交。</target>
        </trans-unit>
        <trans-unit id="efc26cd7227657520a6926ebb23db38544c357a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-describe&quot;&gt;git-describe[1]&lt;/a&gt; command does the opposite, naming the revision using a tag on which the given commit is based:</source>
          <target state="translated">在&lt;a href=&quot;git-describe&quot;&gt;GIT-描述[1]&lt;/a&gt;命令则相反，使用其上所基于的指定的提交标记命名修订：</target>
        </trans-unit>
        <trans-unit id="9903942bbbf43f525c7cf036d25898c86f9d9d7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt; command runs a number of self-consistency checks on the repository, and reports on any problems. This may take some time.</source>
          <target state="translated">在&lt;a href=&quot;git-fsck&quot;&gt;GIT-fsck的[1]&lt;/a&gt;命令运行一个数字上存储库自一致性检查的，并且在出现任何问题的报告。这可能要花点时间。</target>
        </trans-unit>
        <trans-unit id="ff835519b77a7ea3e8c99474cee535ec38ab3bd6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt; command will sometimes complain about dangling objects. They are not a problem.</source>
          <target state="translated">在&lt;a href=&quot;git-fsck&quot;&gt;GIT-fsck的[1]&lt;/a&gt;命令有时会抱怨悬空对象。他们不是问题。</target>
        </trans-unit>
        <trans-unit id="d818a9097a56e35195bf0f4a41317be4c1298cc7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; command performs packing, pruning, and more for you, so is normally the only high-level command you need.</source>
          <target state="translated">在&lt;a href=&quot;git-gc&quot;&gt;GIT-GC [1]&lt;/a&gt;命令进行包装，修剪，多用于你，所以通常是唯一的需要高级命令。</target>
        </trans-unit>
        <trans-unit id="7674cbc9fda493edc257e040882a4d3b2fee5da7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; command provides a simple way to start browsing the repository using gitweb. The default server when using instaweb is lighttpd.</source>
          <target state="translated">在&lt;a href=&quot;git-instaweb&quot;&gt;GIT-instaweb [1]&lt;/a&gt;命令提供了一种简单的方法来开始浏览使用的GitWeb信息库。使用instaweb时的默认服务器是lighttpd。</target>
        </trans-unit>
        <trans-unit id="3d865565a2d1aab8d65d5524c33990e3ecd5eee4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; and &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; commands also provide special help for merges:</source>
          <target state="translated">在&lt;a href=&quot;git-log&quot;&gt;git的日志[1]&lt;/a&gt;和&lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt;命令，还提供了合并特别的帮助：</target>
        </trans-unit>
        <trans-unit id="869571e8bf360d23843fed69fde509a99aec51ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; command can show lists of commits. On its own, it shows all commits reachable from the parent commit; but you can also make more specific requests:</source>
          <target state="translated">在&lt;a href=&quot;git-log&quot;&gt;GIT中日志[1]&lt;/a&gt;命令可以显示提交的列表。它单独显示所有从父提交可到达的提交；但您也可以提出更具体的要求：</target>
        </trans-unit>
        <trans-unit id="49730fd39b9c73a554b2cce254c7d8e26a1047e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; command is a low-level command that is occasionally useful for translating some name for a commit to the object name for that commit:</source>
          <target state="translated">在&lt;a href=&quot;git-rev-parse&quot;&gt;GIT-REV-解析[1]&lt;/a&gt;命令是一个低级别的命令，该命令是用于平移一些名称承诺为提交对象名偶尔有用：</target>
        </trans-unit>
        <trans-unit id="d0ac1c8438cdf91fddee2ad5a2dd381f720a6756" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; command is available since Git 1.5.3. Users with Git 1.5.2 can look up the submodule commits in the repository and manually check them out; earlier versions won&amp;rsquo;t recognize the submodules at all.</source>
          <target state="translated">在&lt;a href=&quot;git-submodule&quot;&gt;GIT-子模块[1]&lt;/a&gt;命令是可用的，因为GIT中1.5.3。使用Git 1.5.2的用户可以在存储库中查找子模块的提交并手动将其检出。早期版本根本无法识别子模块。</target>
        </trans-unit>
        <trans-unit id="8ffc16af4f4197ccdbaaceb3fe6721dcc4562d83" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; command updates the index with information from the working directory. You generally update the index information by just specifying the filename you want to update, like so:</source>
          <target state="translated">在&lt;a href=&quot;git-update-index&quot;&gt;GIT中更新索引[1]&lt;/a&gt;命令更新与从工作目录信息的索引。通常，您只需指定要更新的文件名即可更新索引信息，如下所示：</target>
        </trans-unit>
        <trans-unit id="0eb5eb47b21a25e2f8cbcad63d82e49ed7b46c03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;git filter-repo&lt;/a&gt; tool is an alternative to git-filter-branch which does not suffer from these performance problems or the safety problems (mentioned below). For those with existing tooling which relies upon git-filter-branch, &lt;code&gt;git filter-repo&lt;/code&gt; also provides &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;filter-lamely&lt;/a&gt;, a drop-in git-filter-branch replacement (with a few caveats). While filter-lamely suffers from all the same safety issues as git-filter-branch, it at least ameliorates the performance issues a little.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20874526426e66810d4174f5227a378a8de7e91c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;git filter-repo&lt;/a&gt; tool is an alternative to git-filter-branch which does not suffer from these performance problems or the safety problems (mentioned below). For those with existing tooling which relies upon git-filter-branch, &lt;code&gt;git repo-filter&lt;/code&gt; also provides &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;filter-lamely&lt;/a&gt;, a drop-in git-filter-branch replacement (with a few caveats). While filter-lamely suffers from all the same safety issues as git-filter-branch, it at least ameliorates the performance issues a little.</source>
          <target state="translated">在&lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;GIT中过滤回购&lt;/a&gt;工具是与git滤波器分支的替代在不脱离这些性能问题或安全性问题（后述）受到影响。对于那些拥有依赖git-filter-branch的现有工具的人， &lt;code&gt;git repo-filter&lt;/code&gt; 还提供&lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;filter-lamely&lt;/a&gt;，即插即用的 git-filter-branch替换（有一些警告）。尽管filter-lamely遭受了与git-filter-branch相同的所有安全问题，但它至少可以稍微改善性能问题。</target>
        </trans-unit>
        <trans-unit id="ad21d56fce6cdd39ef4f92ed0708902d059eaafc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;user-manual&quot;&gt;Git User&amp;rsquo;s Manual&lt;/a&gt; provides a more comprehensive introduction to Git.</source>
          <target state="translated">在&lt;a href=&quot;user-manual&quot;&gt;Git的用户手册&lt;/a&gt;提供了更全面的介绍Git的。</target>
        </trans-unit>
        <trans-unit id="89c784f1b1d17488cfe361d4581fd69d6d34303d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;user-manual#git-concepts&quot;&gt;Git concepts chapter of the user-manual&lt;/a&gt; and &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; both provide introductions to the underlying Git architecture.</source>
          <target state="translated">&lt;a href=&quot;user-manual#git-concepts&quot;&gt;用户手册&lt;/a&gt;和&lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt;的Git概念一章都提供了底层Git体系结构的介绍。</target>
        </trans-unit>
        <trans-unit id="5f7a0a0ce9975de955e97678d53d0386ebf8b091" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; file is used to define the skip-worktree reference bitmap. When Git updates the working directory, it updates the skip-worktree bits in the index based on this file. The files matching the patterns in the file will appear in the working directory, and the rest will not.</source>
          <target state="translated">在 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 文件被用来定义的跳跃worktree参考位图。当Git更新工作目录时，它将根据该文件更新索引中的skip-worktree位。与文件中的模式匹配的文件将显示在工作目录中，其余文件则不会显示。</target>
        </trans-unit>
        <trans-unit id="18927ccc4077efc9fa00280f487bf7ea52068011" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;any&amp;gt;&lt;/code&gt; part of the command may contain any sequence of bytes that does not contain &lt;code&gt;LF&lt;/code&gt;. The &lt;code&gt;LF&lt;/code&gt; after the command is optional. Callers may wish to process the output through a tool such as sed to remove the leading part of the line, for example:</source>
          <target state="translated">命令的 &lt;code&gt;&amp;lt;any&amp;gt;&lt;/code&gt; 部分可以包含不包含 &lt;code&gt;LF&lt;/code&gt; 的任何字节序列。该 &lt;code&gt;LF&lt;/code&gt; 命令后是可选的。调用者可能希望通过诸如sed之类的工具来处理输出，以删除行的开头部分，例如：</target>
        </trans-unit>
        <trans-unit id="38ecaff497a30523addb0d68ac2f3ff7d62121ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) or the full 40-byte SHA-1 of a Git tag, commit, or tree object, preexisting or waiting to be written. The path is relative to the top level of the tree named by &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 可以是一个参考标记（ &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ）或GIT中标签的全部40个字节的SHA-1，提交，或者树对象，预先存在的或等待写入。路径相对于 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 命名的树的顶层。</target>
        </trans-unit>
        <trans-unit id="df9429d81584e26f1a55e7eff78d6952383c6adf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set previously or a full 40-byte SHA-1 of a Git blob, preexisting or ready to be written.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 可以是参考标记（ &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ）预先设定或一个的blob的完整的40字节SHA-1，先前存在的或准备好被写入。</target>
        </trans-unit>
        <trans-unit id="d38490ce2af2d9b14b21e7e25c13d2a1c79c408e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; part of the command may contain any of the options listed in the OPTIONS section that do not change import semantics, without the leading &lt;code&gt;--&lt;/code&gt; and is treated in the same way.</source>
          <target state="translated">该命令的 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 部分可能包含OPTIONS部分中列出的任何选项，这些选项不会更改导入语义，并且不带前导 &lt;code&gt;--&lt;/code&gt; 并以相同的方式处理。</target>
        </trans-unit>
        <trans-unit id="73cfe0e2f7b7cccff976b7e355044194793ceedb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;pushurl&amp;gt;&lt;/code&gt; is used for pushes only. It is optional and defaults to &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;pushurl&amp;gt;&lt;/code&gt; 仅用于推动。它是可选的，默认为 &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="226bf97de37dae89426f4bcaf2c8464c2aaac4ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;rev&amp;gt;^-[&amp;lt;n&amp;gt;]&lt;/code&gt; notation includes &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; but excludes the &amp;lt;n&amp;gt;th parent (i.e. a shorthand for &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt;), with &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1 if not given. This is typically useful for merge commits where you can just pass &lt;code&gt;&amp;lt;commit&amp;gt;^-&lt;/code&gt; to get all the commits in the branch that was merged in merge commit &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; (including &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; itself).</source>
          <target state="translated">所述 &lt;code&gt;&amp;lt;rev&amp;gt;^-[&amp;lt;n&amp;gt;]&lt;/code&gt; 表示法包括 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 但不包括&amp;lt;N&amp;gt;个亲本（即，简写 &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt; ）中，用 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1，如果没有给。这通常对合并提交很有用，在合并提交中，您只需传递 &lt;code&gt;&amp;lt;commit&amp;gt;^-&lt;/code&gt; 即可获取合并提交 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 中已合并的分支中的所有提交（包括 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 本身）。</target>
        </trans-unit>
        <trans-unit id="382c52b269a126869d3f5e611e50db349c01a555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; is just a good idea when you know the rest will be filenames; it will prevent problems with a filename of, for example, &lt;code&gt;-a&lt;/code&gt;. Using &lt;code&gt;--&lt;/code&gt; is probably a good policy in scripts.</source>
          <target state="translated">当您知道其余的将是文件名时， &lt;code&gt;--&lt;/code&gt; 只是一个好主意；它将防止文件名例如 &lt;code&gt;-a&lt;/code&gt; 出现问题。在脚本中使用 &lt;code&gt;--&lt;/code&gt; 可能是一个很好的策略。</target>
        </trans-unit>
        <trans-unit id="1a7c2f7d5b7ec8386e86076d812d974232af3082" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--cached&lt;/code&gt; option is used to ask a command that usually works on files in the working tree to &lt;strong&gt;only&lt;/strong&gt; work with the index. For example, &lt;code&gt;git grep&lt;/code&gt;, when used without a commit to specify from which commit to look for strings in, usually works on files in the working tree, but with the &lt;code&gt;--cached&lt;/code&gt; option, it looks for strings in the index.</source>
          <target state="translated">该 &lt;code&gt;--cached&lt;/code&gt; 选项是问，通常在工作中的文件工作树的命令&lt;strong&gt;只&lt;/strong&gt;工作与索引。例如， &lt;code&gt;git grep&lt;/code&gt; 不用提交来指定从哪个提交中查找字符串时，通常可用于工作树中的文件，但是使用 &lt;code&gt;--cached&lt;/code&gt; 选项时，它将在索引中查找字符串。</target>
        </trans-unit>
        <trans-unit id="93eb90d6c0bfdb16dcadbf4c72d38d80f8bf4451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--dry-run&lt;/code&gt; option can be used to obtain a summary of what is included by any of the above for the next commit by giving the same set of parameters (options and paths).</source>
          <target state="translated">所述 &lt;code&gt;--dry-run&lt;/code&gt; 选项可以用于获得什么是由任何上述的包括的总结下被赋予了相同的一组参数（选项和路径）提交。</target>
        </trans-unit>
        <trans-unit id="45e26263ba79c46b47e35a4fe67d4d8f33b37e0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--env-filter&lt;/code&gt; option can be used to modify committer and/or author identity. For example, if you found out that your commits have the wrong identity due to a misconfigured user.email, you can make a correction, before publishing the project, like this:</source>
          <target state="translated">所述 &lt;code&gt;--env-filter&lt;/code&gt; 选项可以用于修改提交者和/或作者的身份。例如，如果您发现由于user.email配置错误导致提交的身份错误，则可以在发布项目之前进行更正，如下所示：</target>
        </trans-unit>
        <trans-unit id="b4b7635118d0a90fb277012f2d96d5181b61e4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--index&lt;/code&gt; option is used to ask a command that usually works on files in the working tree to &lt;strong&gt;also&lt;/strong&gt; affect the index. For example, &lt;code&gt;git stash apply&lt;/code&gt; usually merges changes recorded in a stash entry to the working tree, but with the &lt;code&gt;--index&lt;/code&gt; option, it also merges changes to the index as well.</source>
          <target state="translated">该 &lt;code&gt;--index&lt;/code&gt; 选项是问，通常在工作中的文件工作树的命令&lt;strong&gt;还&lt;/strong&gt;影响指数。例如， &lt;code&gt;git stash apply&lt;/code&gt; 通常将存储在存储条目中的更改合并到工作树中，但是使用 &lt;code&gt;--index&lt;/code&gt; 选项，它也将更改合并到索引中。</target>
        </trans-unit>
        <trans-unit id="f5e672ca7275921f27bc57abfee8498efa38d837" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--numstat&lt;/code&gt; option gives the diffstat(1) information but is designed for easier machine consumption. An entry in &lt;code&gt;--numstat&lt;/code&gt; output looks like this:</source>
          <target state="translated">该 &lt;code&gt;--numstat&lt;/code&gt; 选项给出的diffstat（1）信息，但设计更容易机消费。 &lt;code&gt;--numstat&lt;/code&gt; 输出中的条目如下所示：</target>
        </trans-unit>
        <trans-unit id="824224d8413c92cfa07b10a7d5f109653a254225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--patch&lt;/code&gt; option implies &lt;code&gt;--keep-index&lt;/code&gt;. You can use &lt;code&gt;--no-keep-index&lt;/code&gt; to override this.</source>
          <target state="translated">该 &lt;code&gt;--patch&lt;/code&gt; 选项意味着 &lt;code&gt;--keep-index&lt;/code&gt; 。您可以使用 &lt;code&gt;--no-keep-index&lt;/code&gt; 覆盖它。</target>
        </trans-unit>
        <trans-unit id="cd53bf0606653a9e38fc2f67928f722d519b8437" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--prune-tags&lt;/code&gt; option is equivalent to having &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; declared in the refspecs of the remote. This can lead to some seemingly strange interactions:</source>
          <target state="translated">&lt;code&gt;--prune-tags&lt;/code&gt; 选项等效于在遥控器的refspec中声明 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; 。这可能导致一些看似奇怪的交互：</target>
        </trans-unit>
        <trans-unit id="eedbb7a82985c4671f5041c09553972a9225fc17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rebase-merges&lt;/code&gt; mode is similar in spirit to the deprecated &lt;code&gt;--preserve-merges&lt;/code&gt; but works with interactive rebases, where commits can be reordered, inserted and dropped at will.</source>
          <target state="translated">该 &lt;code&gt;--rebase-merges&lt;/code&gt; 模式在本质上弃用类似 &lt;code&gt;--preserve-merges&lt;/code&gt; ，但与互动底垫，在这里提交可以重新排序，插入和随意丢弃的作品。</target>
        </trans-unit>
        <trans-unit id="8061f1189be4b513311a10997c4e6fc449baeaf4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--simplify-by-decoration&lt;/code&gt; option allows you to view only the big picture of the topology of the history, by omitting commits that are not referenced by tags. Commits are marked as !TREESAME (in other words, kept after history simplification rules described above) if (1) they are referenced by tags, or (2) they change the contents of the paths given on the command line. All other commits are marked as TREESAME (subject to be simplified away).</source>
          <target state="translated">该 &lt;code&gt;--simplify-by-decoration&lt;/code&gt; 选项允许你只查看历史的拓扑结构的大局，通过省略未通过标签引用的提交。如果（1）标记引用了提交，或（2）更改了命令行上给定路径的内容，则将提交标记为！TREESAME（换句话说，在上述的历史简化规则之后保留）。所有其他提交都标记为TREESAME（将被简化）。</target>
        </trans-unit>
        <trans-unit id="16b8753fdc735c82bb8e4b4e3197e33fe132b018" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--summary&lt;/code&gt; option describes newly added, deleted, renamed and copied files. The &lt;code&gt;--stat&lt;/code&gt; option adds diffstat(1) graph to the output. These options can be combined with other options, such as &lt;code&gt;-p&lt;/code&gt;, and are meant for human consumption.</source>
          <target state="translated">该 &lt;code&gt;--summary&lt;/code&gt; 选项描述新添加，删除，重命名和复制的文件。所述 &lt;code&gt;--stat&lt;/code&gt; 选项添加diffstat（1）图来输出。这些选项可以与其他选项结合使用，例如 &lt;code&gt;-p&lt;/code&gt; ，供人类使用。</target>
        </trans-unit>
        <trans-unit id="629d4eddaa3e0be951f311129548061d6a37661e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--threads&lt;/code&gt; option (and the grep.threads configuration) will be ignored when &lt;code&gt;--open-files-in-pager&lt;/code&gt; is used, forcing a single-threaded execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb3a538afbb18a8ca912f0cecf9a31cb6701775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; option instructs &lt;code&gt;git config&lt;/code&gt; to ensure that incoming and outgoing values are canonicalize-able under the given &amp;lt;type&amp;gt;. If no &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; is given, no canonicalization will be performed. Callers may unset an existing &lt;code&gt;--type&lt;/code&gt; specifier with &lt;code&gt;--no-type&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; 选项指示 &lt;code&gt;git config&lt;/code&gt; ，以确保输入和输出值。规范化-能够在给定的&amp;lt;类型&amp;gt;。如果未 &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; ，则将不执行规范化。 &lt;code&gt;--type&lt;/code&gt; 者可以使用 &lt;code&gt;--no-type&lt;/code&gt; 取消设置现有的--type指定符。</target>
        </trans-unit>
        <trans-unit id="0c9422891d35819a54a8ef0ba6d7016d122547ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-M&lt;/code&gt; and &lt;code&gt;-C&lt;/code&gt; options require O(n^2) processing time where n is the number of potential rename/copy targets. This option prevents rename/copy detection from running if the number of rename/copy targets exceeds the specified number.</source>
          <target state="translated">在 &lt;code&gt;-M&lt;/code&gt; 和 &lt;code&gt;-C&lt;/code&gt; 选项需要为O（n ^ 2）的处理时间，其中n是潜在的重命名的数目/复制目标。如果重命名/复制目标的数量超过指定数目，此选项将阻止运行重命名/复制检测。</target>
        </trans-unit>
        <trans-unit id="73fff0c26b859dbfe915afb814a50fa7bc541c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-C&lt;/code&gt; options have the exact same semantics as &lt;code&gt;-m&lt;/code&gt; and &lt;code&gt;-M&lt;/code&gt;, except instead of the branch being renamed it along with its config and reflog will be copied to a new name.</source>
          <target state="translated">在 &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;-C&lt;/code&gt; 选项有相同的语义 &lt;code&gt;-m&lt;/code&gt; 和 &lt;code&gt;-M&lt;/code&gt; ，除了支路，而不是给它改名与它的配置和引用日志一起将被复制到一个新的名字。</target>
        </trans-unit>
        <trans-unit id="89a7df63322c3f15984d17c0e2db0a5d71e95aa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; and &lt;code&gt;-F&lt;/code&gt; options can be given any number of times, in any order. The commit log message will be composed in the order in which the options are given.</source>
          <target state="translated">该 &lt;code&gt;-m&lt;/code&gt; 和 &lt;code&gt;-F&lt;/code&gt; 选项可以给任意次数，以任何顺序。提交日志消息将按照给出选项的顺序组成。</target>
        </trans-unit>
        <trans-unit id="f4502e6a26132411ed2e9fd1c43849a487e5e5a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; option is mutually exclusive with &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, and &lt;code&gt;-F&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;-m&lt;/code&gt; 选项是互相排斥的 &lt;code&gt;-c&lt;/code&gt; ， &lt;code&gt;-C&lt;/code&gt; ，和 &lt;code&gt;-F&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38779d2c15d6e090718b82e6af2f8c359ec976d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.git-credentials&lt;/code&gt; file is stored in plaintext. Each credential is stored on its own line as a URL like:</source>
          <target state="translated">在 &lt;code&gt;.git-credentials&lt;/code&gt; 文件存储在纯文本。每个凭证都以URL的形式存储在自己的行中，例如：</target>
        </trans-unit>
        <trans-unit id="905c63d14654cde00625cb5e82c7038bc34ea94e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.gitmodules&lt;/code&gt; file inside the superproject. A project usually uses this file to suggest defaults for the upstream collection of repositories for the mapping that is required between a submodule&amp;rsquo;s name and its path.</source>
          <target state="translated">超级项目中的 &lt;code&gt;.gitmodules&lt;/code&gt; 文件。项目通常使用此文件为子模块名称和其路径之间所需的映射建议上游存储库集合的默认值。</target>
        </trans-unit>
        <trans-unit id="0bb4fdb786947245a90430b5697a0e9422df1d21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.gitmodules&lt;/code&gt; file, located in the top-level directory of a Git working tree, is a text file with a syntax matching the requirements of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;.gitmodules&lt;/code&gt; 文件，位于一个Git工作树的顶层目录，是相匹配的要求，语法的文本文件&lt;a href=&quot;git-config&quot;&gt;的git-配置[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5324d8792f18dd9ac59490b336e09b1bd43353e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.mailmap&lt;/code&gt; feature is used to coalesce together commits by the same person in the shortlog, where their name and/or email address was spelled differently.</source>
          <target state="translated">该 &lt;code&gt;.mailmap&lt;/code&gt; 功能由同一个人在shortlog，他们的名称和/或电子邮件地址被拼写不同用于聚结在一起提交。</target>
        </trans-unit>
        <trans-unit id="73c3a5a96a8a6a48d412facd438733454a4a63a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; ref is set to point at the commit that introduced the change that is difficult to apply.</source>
          <target state="translated">该 &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; 裁判在设置点提交介绍了这是难以适用的变化。</target>
        </trans-unit>
        <trans-unit id="df208c183263acdaf73c0a978db9f5c35380bc6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; environment variables and the &lt;code&gt;--date&lt;/code&gt; option support the following date formats:</source>
          <target state="translated">该 &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt; ， &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; 环境变量和 &lt;code&gt;--date&lt;/code&gt; 选项支持以下日期格式：</target>
        </trans-unit>
        <trans-unit id="ad08232602558aa9979e8ccc7bf4df9612b12ec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; environment variables support the following date formats:</source>
          <target state="translated">该 &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt; ， &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; 环境变量支持以下日期格式：</target>
        </trans-unit>
        <trans-unit id="9c24e5e1da9f8726ec7abe4516a017b9495c2fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable may be passed to &lt;code&gt;git-http-backend&lt;/code&gt; to bypass the check for the &quot;git-daemon-export-ok&quot; file in each repository before allowing export of that repository.</source>
          <target state="translated">可以在允许导出该存储库之前，将 &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; 环境变量传递给 &lt;code&gt;git-http-backend&lt;/code&gt; 以绕过每个存储库中对&amp;ldquo; git-daemon-export-ok&amp;rdquo;文件的检查。</target>
        </trans-unit>
        <trans-unit id="387cfeb550226cfd9e601b1b72a83920c3f36040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_HTTP_MAX_REQUEST_BUFFER&lt;/code&gt; environment variable (or the &lt;code&gt;http.maxRequestBuffer&lt;/code&gt; config variable) may be set to change the largest ref negotiation request that git will handle during a fetch; any fetch requiring a larger buffer will not succeed. This value should not normally need to be changed, but may be helpful if you are fetching from a repository with an extremely large number of refs. The value can be specified with a unit (e.g., &lt;code&gt;100M&lt;/code&gt; for 100 megabytes). The default is 10 megabytes.</source>
          <target state="translated">所述 &lt;code&gt;GIT_HTTP_MAX_REQUEST_BUFFER&lt;/code&gt; 环境变量（或 &lt;code&gt;http.maxRequestBuffer&lt;/code&gt; 配置变量）可以被设置为改变最大REF协商请求git会期间获取处理; 任何需要较大缓冲区的提取都不会成功。通常不需要更改该值，但是如果您从具有大量引用的存储库中获取数据，则可能会有所帮助。可以用单位指定该值（例如 &lt;code&gt;100M&lt;/code&gt; 表示100兆字节）。默认值为10 MB。</target>
        </trans-unit>
        <trans-unit id="166eca4501cd90cd3b21f8df969c5ee397d12242" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_NO_REPLACE_OBJECTS&lt;/code&gt; environment variable can be set to achieve the same effect as the &lt;code&gt;--no-replace-objects&lt;/code&gt; option.</source>
          <target state="translated">该 &lt;code&gt;GIT_NO_REPLACE_OBJECTS&lt;/code&gt; 环境变量可以设置来实现的同样的效果 &lt;code&gt;--no-replace-objects&lt;/code&gt; 的选择。</target>
        </trans-unit>
        <trans-unit id="8bee9745a8d6377da5f35089625008b4042f0f35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_PUSH_CERT*&lt;/code&gt; environment variables can be inspected, just as in &lt;code&gt;pre-receive&lt;/code&gt; hook, after accepting a signed push.</source>
          <target state="translated">所述 &lt;code&gt;GIT_PUSH_CERT*&lt;/code&gt; 环境变量可以被检查，就如同在 &lt;code&gt;pre-receive&lt;/code&gt; 钩，接受签字推后。</target>
        </trans-unit>
        <trans-unit id="8bc6550bd201f7a8ce8611abf35f278e4b89d03c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; pointer stays the same.</source>
          <target state="translated">该 &lt;code&gt;HEAD&lt;/code&gt; 指针保持不变。</target>
        </trans-unit>
        <trans-unit id="652c0cf20ffd72216eb399a1f559569365b85933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after &lt;code&gt;&amp;lt;delim&amp;gt; LF&lt;/code&gt; is optional (it used to be required).</source>
          <target state="translated">所述 &lt;code&gt;LF&lt;/code&gt; 后 &lt;code&gt;&amp;lt;delim&amp;gt; LF&lt;/code&gt; 是可选的（它用于需要）。</target>
        </trans-unit>
        <trans-unit id="c1bff9f88ec1fe482fd273291dfad27de492749b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; is optional (it used to be required) but recommended. Always including it makes debugging a fast-import stream easier as the next command always starts in column 0 of the next line, even if &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; did not end with an &lt;code&gt;LF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; 之后的 &lt;code&gt;LF&lt;/code&gt; 是可选的（以前是必需的），但建议使用。始终包含它可以使调试快速导入流变得更加容易，因为下一条命令始终在下一行的第0列中开始，即使 &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; 并非以 &lt;code&gt;LF&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="ec7a854b1a4c70ca562f0584186eed412906ec8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after the command is optional (it used to be required).</source>
          <target state="translated">的 &lt;code&gt;LF&lt;/code&gt; 的命令之后是可选的（它用于需要）。</target>
        </trans-unit>
        <trans-unit id="9a136595a2c2895a25e4571b5fe242dd49c2174e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after the command is optional (it used to be required). Note that for reasons of backward compatibility, if the commit ends with a &lt;code&gt;data&lt;/code&gt; command (i.e. it has no &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filedelete&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt;, &lt;code&gt;filedeleteall&lt;/code&gt; or &lt;code&gt;notemodify&lt;/code&gt; commands) then two &lt;code&gt;LF&lt;/code&gt; commands may appear at the end of the command instead of just one.</source>
          <target state="translated">的 &lt;code&gt;LF&lt;/code&gt; 的命令之后是可选的（它用于需要）。请注意，出于向后兼容的原因，如果提交以 &lt;code&gt;data&lt;/code&gt; 命令结尾（即，它没有 &lt;code&gt;from&lt;/code&gt; ， &lt;code&gt;merge&lt;/code&gt; ， &lt;code&gt;filemodify&lt;/code&gt; ， &lt;code&gt;filedelete&lt;/code&gt; ， &lt;code&gt;filecopy&lt;/code&gt; ， &lt;code&gt;filerename&lt;/code&gt; ， &lt;code&gt;filedeleteall&lt;/code&gt; 或 &lt;code&gt;notemodify&lt;/code&gt; 命令），则两个 &lt;code&gt;LF&lt;/code&gt; 命令可能会出现在命令末尾而不是一个。</target>
        </trans-unit>
        <trans-unit id="6afb1837ee3e8f65249dcb4905156711b603dd19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MERGE_HEAD&lt;/code&gt; ref is set to point to the other branch head.</source>
          <target state="translated">该 &lt;code&gt;MERGE_HEAD&lt;/code&gt; Ref设定点到另一个分支头。</target>
        </trans-unit>
        <trans-unit id="4dcd07a8427d3cae73e7340717a2be5da78b122e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^0&lt;/code&gt; suffix is necessary as fast-import does not permit a branch to start from itself, and the branch is created in memory before the &lt;code&gt;from&lt;/code&gt; command is even read from the input. Adding &lt;code&gt;^0&lt;/code&gt; will force fast-import to resolve the commit through Git&amp;rsquo;s revision parsing library, rather than its internal branch table, thereby loading in the existing value of the branch.</source>
          <target state="translated">该 &lt;code&gt;^0&lt;/code&gt; 后缀是必要的，因为快速导入不允许一个分支，从自身做起，并在内存中创建分支之前， &lt;code&gt;from&lt;/code&gt; 命令甚至从输入读取。添加 &lt;code&gt;^0&lt;/code&gt; 将强制快速导入通过Git的修订版解析库而不是其内部分支表来解析提交，从而加载分支的现有值。</target>
        </trans-unit>
        <trans-unit id="675155c0bc0c9682b02ea7dc72c6fe717f8d57df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^r1 r2&lt;/code&gt; set operation appears so often that there is a shorthand for it. When you have two commits &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; (named according to the syntax explained in SPECIFYING REVISIONS above), you can ask for commits that are reachable from r2 excluding those that are reachable from r1 by &lt;code&gt;^r1 r2&lt;/code&gt; and it can be written as &lt;code&gt;r1..r2&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;^r1 r2&lt;/code&gt; 设置操作似乎经常有它的简写。当您有两个提交 &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;r2&lt;/code&gt; （根据上面&amp;ldquo;指定版本&amp;rdquo;中所述的语法命名）时，可以要求从r2可以到达的提交（不包括从r1到 &lt;code&gt;^r1 r2&lt;/code&gt; 可以到达的提交），可以将其写为 &lt;code&gt;r1..r2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c300333c575f956c2060e4236a825e5a15abf118" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a/&lt;/code&gt; and &lt;code&gt;b/&lt;/code&gt; filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, &lt;code&gt;/dev/null&lt;/code&gt; is &lt;code&gt;not&lt;/code&gt; used in place of the &lt;code&gt;a/&lt;/code&gt; or &lt;code&gt;b/&lt;/code&gt; filenames.</source>
          <target state="translated">所述 &lt;code&gt;a/&lt;/code&gt; 和 &lt;code&gt;b/&lt;/code&gt; 文件名是，除非重命名/拷贝所涉及的相同。特别是，即使是创建或删除，也 &lt;code&gt;not&lt;/code&gt; 使用 &lt;code&gt;/dev/null&lt;/code&gt; 代替 &lt;code&gt;a/&lt;/code&gt; 或 &lt;code&gt;b/&lt;/code&gt; 文件名。</target>
        </trans-unit>
        <trans-unit id="49bd789d4ba6e2342461dc4954bea6426d4910cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;author.name&lt;/code&gt; and &lt;code&gt;committer.name&lt;/code&gt; and their corresponding email options override &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; if set and are overridden themselves by the environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab33dae66d0744b7d6024e6ba0526d3cbdb099d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base commit&lt;/code&gt; is shown as &quot;base-commit: &quot; followed by the 40-hex of the commit object name. A &lt;code&gt;prerequisite patch&lt;/code&gt; is shown as &quot;prerequisite-patch-id: &quot; followed by the 40-hex &lt;code&gt;patch id&lt;/code&gt;, which can be obtained by passing the patch through the &lt;code&gt;git patch-id --stable&lt;/code&gt; command.</source>
          <target state="translated">所述 &lt;code&gt;base commit&lt;/code&gt; 被示出为&amp;ldquo;基提交：&amp;rdquo;，后跟提交对象名称的40进制。甲 &lt;code&gt;prerequisite patch&lt;/code&gt; 被示出为&amp;ldquo;前提贴片-ID：&amp;rdquo;，接着在40进制 &lt;code&gt;patch id&lt;/code&gt; ，其可以通过使补丁通过获得 &lt;code&gt;git patch-id --stable&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="4310c66d08d5e3db5f29a0976c449ecfedbc1c27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;category&lt;/code&gt; field may be used in a future enhancement to do category-based filtering.</source>
          <target state="translated">该 &lt;code&gt;category&lt;/code&gt; 字段可能在未来的增强可以用来做基于类别的过滤。</target>
        </trans-unit>
        <trans-unit id="957c03f80393df2f84f209da8b3d5d5b6c66e351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commit walkers&lt;/code&gt; are sometimes also called &lt;code&gt;dumb transports&lt;/code&gt;, because they do not require any Git aware smart server like Git Native transport does. Any stock HTTP server that does not even support directory index would suffice. But you must prepare your repository with &lt;code&gt;git update-server-info&lt;/code&gt; to help dumb transport downloaders.</source>
          <target state="translated">在 &lt;code&gt;commit walkers&lt;/code&gt; 有时也被称为 &lt;code&gt;dumb transports&lt;/code&gt; ，因为它们不需要任何的Git知道智能服务器如Git机传输一样。任何甚至不支持目录索引的现有HTTP服务器都足够。但是您必须使用 &lt;code&gt;git update-server-info&lt;/code&gt; 准备您的存储库，以帮助简化传输下载程序。</target>
        </trans-unit>
        <trans-unit id="16292719b3497b67052d324a828a5bf607c10cb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;committer&lt;/code&gt; command indicates who made this commit, and when they made it.</source>
          <target state="translated">该 &lt;code&gt;committer&lt;/code&gt; 命令指示谁做此承诺，当他们做到了。</target>
        </trans-unit>
        <trans-unit id="7e0ffba56fb259ff8ccb9999d0c02587815b0675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable allows you to define what &lt;code&gt;diff&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; should consider whitespace errors for all paths in the project (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). This attribute gives you finer control per path.</source>
          <target state="translated">该 &lt;code&gt;core.whitespace&lt;/code&gt; 配置变量允许您定义什么 &lt;code&gt;diff&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 应该考虑空白为项目中的所有路径错误（见&lt;a href=&quot;git-config&quot;&gt;的git-配置[1] &lt;/a&gt;）。此属性使您可以更好地控制每个路径。</target>
        </trans-unit>
        <trans-unit id="c4cf312c5837f50305786c4fff7bd921da0df1e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; command following &lt;code&gt;committer&lt;/code&gt; must supply the commit message (see below for &lt;code&gt;data&lt;/code&gt; command syntax). To import an empty commit message use a 0 length data. Commit messages are free-form and are not interpreted by Git. Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified.</source>
          <target state="translated">的 &lt;code&gt;data&lt;/code&gt; 的命令以下 &lt;code&gt;committer&lt;/code&gt; 必须提供提交消息（参见下面的 &lt;code&gt;data&lt;/code&gt; 命令语法）。要导入空的提交消息，请使用长度为0的数据。提交消息是自由格式的，不会被Git解释。当前，它们必须以UTF-8编码，因为快速导入不允许指定其他编码。</target>
        </trans-unit>
        <trans-unit id="fe1dcaff1f205cb554cce0caa7f556f5b3750431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; command following &lt;code&gt;tagger&lt;/code&gt; must supply the annotated tag message (see below for &lt;code&gt;data&lt;/code&gt; command syntax). To import an empty tag message use a 0 length data. Tag messages are free-form and are not interpreted by Git. Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified.</source>
          <target state="translated">&lt;code&gt;tagger&lt;/code&gt; 后面的 &lt;code&gt;data&lt;/code&gt; 命令必须提供带注释的标记消息（有关 &lt;code&gt;data&lt;/code&gt; 命令语法，请参见下文）。要导入空标签消息，请使用长度为0的数据。标记消息是自由格式的，不会被Git解释。当前，它们必须以UTF-8编码，因为快速导入不允许指定其他编码。</target>
        </trans-unit>
        <trans-unit id="463a929e2c19b7bbf028008ad9aa5a5763e6cf66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export-marks&lt;/code&gt; and &lt;code&gt;import-marks&lt;/code&gt; capabilities, if specified, affect this command in so far as they are passed on to &lt;code&gt;git fast-export&lt;/code&gt;, which then will load/store a table of marks for local objects. This can be used to implement for incremental operations.</source>
          <target state="translated">该 &lt;code&gt;export-marks&lt;/code&gt; 和 &lt;code&gt;import-marks&lt;/code&gt; 功能，如果指定，在只要它们传递影响这个命令到 &lt;code&gt;git fast-export&lt;/code&gt; ，然后将加载/存储本地对象标记的表。这可用于实现增量操作。</target>
        </trans-unit>
        <trans-unit id="b29369cc7c91f799f3a98b04ce067ccee4eaff48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra-info&lt;/code&gt; is again command-dependent. If it is empty, the preceding SP is also omitted. Currently, no commands pass any &lt;code&gt;extra-info&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;extra-info&lt;/code&gt; 再次命令依赖性。如果为空，则也忽略前面的SP。当前，没有命令传递任何 &lt;code&gt;extra-info&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42c3cfeeb6fb7d3b809e4b2424ab05b633a62a10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with &lt;code&gt;%n&lt;/code&gt; instead of &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; 格式允许你指定要显示哪些信息。它的工作方式类似于printf格式，但值得注意的例外是，您使用 &lt;code&gt;%n&lt;/code&gt; 而不是 &lt;code&gt;\n&lt;/code&gt; 换行了。</target>
        </trans-unit>
        <trans-unit id="6d12446e6ba50613ffa6591e4d86ab902d5b116f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; command is the same as in the &lt;code&gt;commit&lt;/code&gt; command; see above for details.</source>
          <target state="translated">在 &lt;code&gt;from&lt;/code&gt; 命令是一样的，在 &lt;code&gt;commit&lt;/code&gt; 命令; 有关详情，请参见上文。</target>
        </trans-unit>
        <trans-unit id="d9bc1ff5b134d7635edcea3cd4e631a291483167" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; command is used to specify the commit to initialize this branch from. This revision will be the first ancestor of the new commit. The state of the tree built at this commit will begin with the state at the &lt;code&gt;from&lt;/code&gt; commit, and be altered by the content modifications in this commit.</source>
          <target state="translated">在 &lt;code&gt;from&lt;/code&gt; 命令用于指定承诺初始化这个分支。此修订版将是新提交的第一个祖先。在此提交时构建的树的状态将以 &lt;code&gt;from&lt;/code&gt; 提交时的状态开始，并被该提交中的内容修改所改变。</target>
        </trans-unit>
        <trans-unit id="75dab416c6ca16533650ccb3bdbb6f1c8c80e31e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git add&lt;/code&gt; command will not add ignored files by default. If any ignored files were explicitly specified on the command line, &lt;code&gt;git add&lt;/code&gt; will fail with a list of ignored files. Ignored files reached by directory recursion or filename globbing performed by Git (quote your globs before the shell) will be silently ignored. The &lt;code&gt;git add&lt;/code&gt; command can be used to add ignored files with the &lt;code&gt;-f&lt;/code&gt; (force) option.</source>
          <target state="translated">该 &lt;code&gt;git add&lt;/code&gt; 命令默认情况下不会加忽略的文件。如果在命令行上明确指定了任何被忽略的文件，则 &lt;code&gt;git add&lt;/code&gt; 将失败，并显示被忽略文件的列表。由目录递归或Git执行的文件名通配符（在shell之前引用您的通配符）所到达的忽略文件将被静默忽略。在 &lt;code&gt;git add&lt;/code&gt; 命令可以用来添加与被忽略的文件 &lt;code&gt;-f&lt;/code&gt; （强制）选项。</target>
        </trans-unit>
        <trans-unit id="9bd7293224a598d82d7fb9b059bf233156e9f91a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git bundle&lt;/code&gt; command packages objects and references in an archive at the originating machine, which can then be imported into another repository using &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt;, or &lt;code&gt;git clone&lt;/code&gt;, after moving the archive by some means (e.g., by sneakernet).</source>
          <target state="translated">在 &lt;code&gt;git bundle&lt;/code&gt; 命令包的对象和引用在归档在源机器，其然后可以被导入到使用另一种存储库 &lt;code&gt;git fetch&lt;/code&gt; ， &lt;code&gt;git pull&lt;/code&gt; ，或 &lt;code&gt;git clone&lt;/code&gt; ，通过某种手段移动存档（例如，通过sneakernet）之后。</target>
        </trans-unit>
        <trans-unit id="3d9620664b0c9d56c3287a812c3ff6b6d1c8717f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git diff-*&lt;/code&gt; family works by first comparing two sets of files:</source>
          <target state="translated">该 &lt;code&gt;git diff-*&lt;/code&gt; 系列作品第一比较两组文件：</target>
        </trans-unit>
        <trans-unit id="597ca1f538bf6e2f60b9e6f9e15d7129efb080fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fetch&lt;/code&gt; operation always stores the head of the last fetched branch in FETCH_HEAD. For example, if you run &lt;code&gt;git fetch&lt;/code&gt; without specifying a local branch as the target of the operation</source>
          <target state="translated">该 &lt;code&gt;git fetch&lt;/code&gt; 操作总是存储在FETCH_HEAD最后取分支的头。例如，如果您运行 &lt;code&gt;git fetch&lt;/code&gt; 而不将本地分支指定为操作的目标</target>
        </trans-unit>
        <trans-unit id="f809c0db2fabe1b716a044f1ae315c3eafe27e59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fmt-merge-msg&lt;/code&gt; command can be used to give a good default for automated &lt;code&gt;git merge&lt;/code&gt; invocations. The automated message can include the branch description.</source>
          <target state="translated">该 &lt;code&gt;git fmt-merge-msg&lt;/code&gt; 命令可以用来提供一个良好的默认自动 &lt;code&gt;git merge&lt;/code&gt; 调用。自动消息可以包括分支描述。</target>
        </trans-unit>
        <trans-unit id="dae50540309298598631c32bc4ba09615f81ee1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git gc --auto&lt;/code&gt; command will run the &lt;code&gt;pre-auto-gc&lt;/code&gt; hook. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">该 &lt;code&gt;git gc --auto&lt;/code&gt; 命令将运行 &lt;code&gt;pre-auto-gc&lt;/code&gt; 挂钩。有关更多信息，请参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cfc7fc175318cd6dff60f69f9572984dc7656815" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git grep&lt;/code&gt; command can search for strings in any version of your project, so</source>
          <target state="translated">该 &lt;code&gt;git grep&lt;/code&gt; 命令可以在项目的任何版本的搜索字符串，所以</target>
        </trans-unit>
        <trans-unit id="10370106ed757f0fcfa619078db112558b3f4b4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git log&lt;/code&gt; command has a weakness: it must present commits in a list. When the history has lines of development that diverged and then merged back together, the order in which &lt;code&gt;git log&lt;/code&gt; presents those commits is meaningless.</source>
          <target state="translated">在 &lt;code&gt;git log&lt;/code&gt; 命令有一个弱点：它必须在列表中出现的提交。当历史上的发展路线发生分歧然后又融合在一起时， &lt;code&gt;git log&lt;/code&gt; 呈现这些提交的顺序就没有意义了。</target>
        </trans-unit>
        <trans-unit id="2918fcbf92a1ba7da67f920488e3f1571c6c776d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git pull&lt;/code&gt; command can also be given &lt;code&gt;.&lt;/code&gt; as the &quot;remote&quot; repository, in which case it just merges in a branch from the current repository; so the commands</source>
          <target state="translated">该 &lt;code&gt;git pull&lt;/code&gt; 命令也可以给予 &lt;code&gt;.&lt;/code&gt; 作为&amp;ldquo;远程&amp;rdquo;存储库，在这种情况下，它只是合并到当前存储库的一个分支中；所以命令</target>
        </trans-unit>
        <trans-unit id="ae6be494d942d11be1fef84bf75e14340e42ba70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git sh-setup&lt;/code&gt; scriptlet is designed to be sourced (using &lt;code&gt;.&lt;/code&gt;) by other shell scripts to set up some variables pointing at the normal Git directories and a few helper shell functions.</source>
          <target state="translated">在 &lt;code&gt;git sh-setup&lt;/code&gt; 小脚本设计（使用进行采购 &lt;code&gt;.&lt;/code&gt; 其他shell脚本）设置一些变量，在普通的Git目录和几个帮手外壳功能指向。</target>
        </trans-unit>
        <trans-unit id="b8d00251834fb59fdb3aac3b6b6d2fd6617d8c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git status&lt;/code&gt; command can be used to obtain a summary of which files have changes that are staged for the next commit.</source>
          <target state="translated">在 &lt;code&gt;git status&lt;/code&gt; 命令可以用来获取其摘要文件有上演下一个提交更改。</target>
        </trans-unit>
        <trans-unit id="1114dd8f20b27292636eee44dbca10b695a7e192" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git submodule add &amp;lt;repo&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt; command does a couple of things:</source>
          <target state="translated">在 &lt;code&gt;git submodule add &amp;lt;repo&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt; 命令执行一两件事情：</target>
        </trans-unit>
        <trans-unit id="851ad3692f8ce86e89fabf82d757953cfb293665" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git svn log&lt;/code&gt; command will not work on repositories using this, either. Using this conflicts with the &lt;code&gt;useSvmProps&lt;/code&gt; option for (hopefully) obvious reasons.</source>
          <target state="translated">该 &lt;code&gt;git svn log&lt;/code&gt; 命令将不会使用该资料库的工作，无论是。出于明显的原因，使用此方法与 &lt;code&gt;useSvmProps&lt;/code&gt; 选项冲突。</target>
        </trans-unit>
        <trans-unit id="54f2e5960f99dce6a894019f61b5f183cfaf541a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git switch&lt;/code&gt; command normally expects a branch head, but will also accept an arbitrary commit when invoked with --detach; for example, you can check out the commit referenced by a tag:</source>
          <target state="translated">在 &lt;code&gt;git switch&lt;/code&gt; 命令通常期望的分支头，同时也将接受当与--detach调用任意提交; 例如，您可以签出标签引用的提交：</target>
        </trans-unit>
        <trans-unit id="5df4353714e03396f22186d308b555d9fc45aa0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git unpack-objects&lt;/code&gt; command can read the packed archive and expand the objects contained in the pack into &quot;one-file one-object&quot; format; this is typically done by the smart-pull commands when a pack is created on-the-fly for efficient network transport by their peers.</source>
          <target state="translated">该 &lt;code&gt;git unpack-objects&lt;/code&gt; 命令可以读取打包存档，并展开包含在包中的对象为&amp;ldquo;一个文件一个对象&amp;rdquo;的格式; 当动态创建数据包以使其对等方高效进行网络传输时，通常通过smart-pull命令完成此操作。</target>
        </trans-unit>
        <trans-unit id="472b18d3af19081ec08acbffb4a8b9828ded3de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git write-tree&lt;/code&gt; command refuses to write a nonsensical tree, and it will complain about unmerged entries if it sees a single entry that is not stage 0.</source>
          <target state="translated">该 &lt;code&gt;git write-tree&lt;/code&gt; 命令不听使唤了一个荒谬的树，它会抱怨未合并的项目，如果它看到一个条目不是0期。</target>
        </trans-unit>
        <trans-unit id="57ed6fd41631cf164adf8f1a5f87022b80e95155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git-fetch&lt;/code&gt; command, with no arguments, will update all of the remote-tracking branches to the latest version found in the original repository. It will not touch any of your own branches&amp;mdash;​not even the &quot;master&quot; branch that was created for you on clone.</source>
          <target state="translated">该 &lt;code&gt;git-fetch&lt;/code&gt; 命令，不带任何参数，将所有的远程跟踪分支更新到了原版本库中的最新版本。它不会碰到您自己的任何分支-甚至不会为克隆上为您创建的&amp;ldquo; master&amp;rdquo;分支。</target>
        </trans-unit>
        <trans-unit id="b7a1f970e8485b643b6fd9d3ee5bf5ec87b44b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gitlink&lt;/code&gt; entry contains the object name of the commit that the superproject expects the submodule&amp;rsquo;s working directory to be at.</source>
          <target state="translated">该 &lt;code&gt;gitlink&lt;/code&gt; 条目包含对象名称的提交是上层项目预计子模块的工作目录是在。</target>
        </trans-unit>
        <trans-unit id="59421f1cfeaef33b3d6dfff512008a45b2069f51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;help.browser&lt;/code&gt;, &lt;code&gt;web.browser&lt;/code&gt; and &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; will also be checked if the &lt;code&gt;web&lt;/code&gt; format is chosen (either by command-line option or configuration variable). See &lt;code&gt;-w|--web&lt;/code&gt; in the OPTIONS section above and &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a22a2e8dd656430183eebd26fcd541802b3980" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;help.browser&lt;/code&gt;, &lt;code&gt;web.browser&lt;/code&gt; and &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; will also be checked if the &lt;code&gt;web&lt;/code&gt; format is chosen (either by command-line option or configuration variable). See &lt;code&gt;-w|--web&lt;/code&gt; in the OPTIONS section above and git-web{litdd}browse[1].</source>
          <target state="translated">的 &lt;code&gt;help.browser&lt;/code&gt; ， &lt;code&gt;web.browser&lt;/code&gt; 和 &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 也将被如果检查的 &lt;code&gt;web&lt;/code&gt; 被选择的格式（通过命令行选项或配置变量）。请参阅上面&amp;ldquo;选项&amp;rdquo;部分中的 &lt;code&gt;-w|--web&lt;/code&gt; 和git-web {litdd} browse [1]。</target>
        </trans-unit>
        <trans-unit id="d643b3df461bdc6854f7d047b7c0264699b4e1d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;includeIf&lt;/code&gt; sections allow you to include config directives from another source. These sections behave identically to each other with the exception that &lt;code&gt;includeIf&lt;/code&gt; sections may be ignored if their condition does not evaluate to true; see &quot;Conditional includes&quot; below.</source>
          <target state="translated">在 &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;includeIf&lt;/code&gt; 部分允许您包括来自其他来源的配置指令。这些部分的行为相同，不同之处在于，如果条件条件未为true ，则 &lt;code&gt;includeIf&lt;/code&gt; 部分可能会被忽略；请参阅下面的&amp;ldquo;有条件的包含&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="25df8c5531688eabec317d8bad065a9bd5755f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; command associates a label with the current HEAD when that command is executed. These labels are created as worktree-local refs (&lt;code&gt;refs/rewritten/&amp;lt;label&amp;gt;&lt;/code&gt;) that will be deleted when the rebase finishes. That way, rebase operations in multiple worktrees linked to the same repository do not interfere with one another. If the &lt;code&gt;label&lt;/code&gt; command fails, it is rescheduled immediately, with a helpful message how to proceed.</source>
          <target state="translated">所述 &lt;code&gt;label&lt;/code&gt; 的命令被执行的命令时，标签与当前HEAD相关联。这些标签被创建为工作树本地引用（ &lt;code&gt;refs/rewritten/&amp;lt;label&amp;gt;&lt;/code&gt; rewrite / &amp;lt;label&amp;gt;），在完成基准调整后将被删除。这样，链接到同一存储库的多个工作树中的变基操作不会相互干扰。如果 &lt;code&gt;label&lt;/code&gt; 命令失败，则会立即重新安排其时间，并提供一条有用的消息，说明如何继续。</target>
        </trans-unit>
        <trans-unit id="fcbbe57ad1bbeeeea536166f770fc1a1a385d28e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list&lt;/code&gt; command may produce a list of key-value pairs. The following keys are defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21f07c748b4f824d325c5d844a166616c79a19e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list&lt;/code&gt; command produces a list of refs in which each ref may be followed by a list of attributes. The following ref list attributes are defined.</source>
          <target state="translated">该 &lt;code&gt;list&lt;/code&gt; 命令产生参其中每个裁判可以跟随的属性列表的列表。定义了以下引用列表属性。</target>
        </trans-unit>
        <trans-unit id="a1948673e2dc6e9b36baf9466260194608388c73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ls&lt;/code&gt; command can also be used where a &lt;code&gt;filemodify&lt;/code&gt; directive can appear, allowing it to be used in the middle of a commit.</source>
          <target state="translated">的 &lt;code&gt;ls&lt;/code&gt; 命令还可以用于其中 &lt;code&gt;filemodify&lt;/code&gt; 指令可以出现，允许它在一个提交中间使用。</target>
        </trans-unit>
        <trans-unit id="9f751fdc4139000f76be8c4b7f0362d024d6ccd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maint&lt;/code&gt; branch should now be fast-forwarded to the newly released code so that maintenance fixes can be tracked for the current release:</source>
          <target state="translated">现在应该将 &lt;code&gt;maint&lt;/code&gt; 分支快速转发到新发布的代码，以便可以跟踪当前版本的维护修补程序：</target>
        </trans-unit>
        <trans-unit id="3d08be0d91fe4ba76005ea415ec8dd980a19baaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;man.viewer&lt;/code&gt; configuration variable will be checked if the &lt;code&gt;man&lt;/code&gt; format is chosen. The following values are currently supported:</source>
          <target state="translated">所述 &lt;code&gt;man.viewer&lt;/code&gt; 如果配置变量将被检查 &lt;code&gt;man&lt;/code&gt; 被选择的格式。当前支持以下值：</target>
        </trans-unit>
        <trans-unit id="4d99fda454f21ad231a7b020da5a33fbc1590dfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;master&lt;/code&gt; branch is supposed to be a superset of &lt;code&gt;maint&lt;/code&gt;. If this condition does not hold, then &lt;code&gt;maint&lt;/code&gt; contains some commits that are not included on &lt;code&gt;master&lt;/code&gt;. The fixes represented by those commits will therefore not be included in your feature release.</source>
          <target state="translated">该 &lt;code&gt;master&lt;/code&gt; 分支应该是一个超集 &lt;code&gt;maint&lt;/code&gt; 。如果此条件不成立，则 &lt;code&gt;maint&lt;/code&gt; 包含 &lt;code&gt;master&lt;/code&gt; 上未包括的某些提交。因此，这些提交表示的修复将不会包含在您的功能版本中。</target>
        </trans-unit>
        <trans-unit id="60a9438818e32daade34327aac8510a028d0a280" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.driver&lt;/code&gt; variable&amp;rsquo;s value is used to construct a command to run to merge ancestor&amp;rsquo;s version (&lt;code&gt;%O&lt;/code&gt;), current version (&lt;code&gt;%A&lt;/code&gt;) and the other branches' version (&lt;code&gt;%B&lt;/code&gt;). These three tokens are replaced with the names of temporary files that hold the contents of these versions when the command line is built. Additionally, %L will be replaced with the conflict marker size (see below).</source>
          <target state="translated">的 &lt;code&gt;merge.*.driver&lt;/code&gt; 变量的值被用来构建一个命令来运行，以合并的祖先的版本（ &lt;code&gt;%O&lt;/code&gt; ），当前版本（ &lt;code&gt;%A&lt;/code&gt; ），另一个分支的版本（ &lt;code&gt;%B&lt;/code&gt; ）。在构建命令行时，这三个标记将替换为保存这些版本内容的临时文件的名称。此外，％L将替换为冲突标记大小（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="8135860bcb3c213dc65a79f9d59c1c4cf76a9b52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.name&lt;/code&gt; variable gives the driver a human-readable name.</source>
          <target state="translated">该 &lt;code&gt;merge.*.name&lt;/code&gt; 变量给司机一个人类可读的名称。</target>
        </trans-unit>
        <trans-unit id="531f58358e8d95bd1e04306b8f06edec09e06aba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.recursive&lt;/code&gt; variable specifies what other merge driver to use when the merge driver is called for an internal merge between common ancestors, when there are more than one. When left unspecified, the driver itself is used for both internal merge and the final merge.</source>
          <target state="translated">该 &lt;code&gt;merge.*.recursive&lt;/code&gt; 变量指定什么其他的合并驱动程序时，有一个以上的使用时，合并驱动程序称为共同祖先之间的内部合并。如果未指定，则驱动程序本身将用于内部合并和最终合并。</target>
        </trans-unit>
        <trans-unit id="0e9e9f9df980dcf05008ee310843fafb365f76e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge&lt;/code&gt; command will merge the specified revision(s) into whatever is HEAD at that time. With &lt;code&gt;-C &amp;lt;original-commit&amp;gt;&lt;/code&gt;, the commit message of the specified merge commit will be used. When the &lt;code&gt;-C&lt;/code&gt; is changed to a lower-case &lt;code&gt;-c&lt;/code&gt;, the message will be opened in an editor after a successful merge so that the user can edit the message.</source>
          <target state="translated">该 &lt;code&gt;merge&lt;/code&gt; 命令将合并指定的修订版本到什么是HEAD在那个时候。通过 &lt;code&gt;-C &amp;lt;original-commit&amp;gt;&lt;/code&gt; ，将使用指定的合并提交的提交消息。当 &lt;code&gt;-C&lt;/code&gt; 更改为小写字母 &lt;code&gt;-c&lt;/code&gt; 时，成功合并后，该消息将在编辑器中打开，以便用户可以编辑该消息。</target>
        </trans-unit>
        <trans-unit id="103d9db55b62f87264ea4e2293c619e5e886c09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode &amp;lt;mode&amp;gt;,&amp;lt;mode&amp;gt;..&amp;lt;mode&amp;gt;&lt;/code&gt; line appears only if at least one of the &amp;lt;mode&amp;gt; is different from the rest. Extended headers with information about detected contents movement (renames and copying detection) are designed to work with diff of two &amp;lt;tree-ish&amp;gt; and are not used by combined diff format.</source>
          <target state="translated">的 &lt;code&gt;mode &amp;lt;mode&amp;gt;,&amp;lt;mode&amp;gt;..&amp;lt;mode&amp;gt;&lt;/code&gt; 线只有在&amp;lt;模式&amp;gt;中的至少一个是从所述静止不同出现。具有有关检测到的内容移动（重命名和复制检测）信息的扩展头设计用于处理两个&amp;lt;tree-ish&amp;gt;的diff，并且不被组合的diff格式使用。</target>
        </trans-unit>
        <trans-unit id="2bdce5756dcfa3f7f3ee04d8a9aa0f072d4148cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-changelist&lt;/code&gt; hook is executed after the changelist message has been edited by the user. It can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes a single parameter, the name of the file that holds the proposed changelist text. Exiting with a non-zero status causes the command to abort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faca035b6e964f3e1a2e62a14bd12a5a551dfc56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-post-changelist&lt;/code&gt; hook is invoked after the submit has successfully occured in P4. It takes no parameters and is meant primarily for notification and cannot affect the outcome of the git p4 submit action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="245bf1c27c1e24c16ea60d971116c678983044e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-pre-submit&lt;/code&gt; hook is executed if it exists and is executable. The hook takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevents &lt;code&gt;git-p4 submit&lt;/code&gt; from launching.</source>
          <target state="translated">如果 &lt;code&gt;p4-pre-submit&lt;/code&gt; 钩存在且可执行，则执行该钩。挂钩不带参数，标准输入也不带任何内容。从此脚本以非零状态退出会阻止 &lt;code&gt;git-p4 submit&lt;/code&gt; 启动。</target>
        </trans-unit>
        <trans-unit id="5b18899976ae8ddf5fa851e0121915b85076d95b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-pre-submit&lt;/code&gt; hook is executed if it exists and is executable. The hook takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevents &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. It can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; command line option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1a28ab3e2441205f479d6f2df8ea0d456e98e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-prepare-changelist&lt;/code&gt; hook is executed right after preparing the default changelist message and before the editor is started. It takes one parameter, the name of the file that contains the changelist text. Exiting with a non-zero status from the script will abort the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ac82e7ce6eab5b9d775518541be1b358e64d26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;post-update&lt;/code&gt; hook can tell what are the heads that were pushed, but it does not know what their original and updated values are, so it is a poor place to do log old..new. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook does get both original and updated values of the refs. You might consider it instead if you need them.</source>
          <target state="translated">在 &lt;code&gt;post-update&lt;/code&gt; 挂钩可以告诉什么是推送的头，但它不知道他们原来的和更新的值，所以它是做记录old..new一个穷地方。在&lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;后收到&lt;/em&gt;&lt;/a&gt;钩并得到裁判的原件和更新的值。如果需要，可以考虑考虑。</target>
        </trans-unit>
        <trans-unit id="7b1878af31d43f94d962552d8195f8f92835c4ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pre-receive&lt;/code&gt; hook MUST NOT update any refs to point to quarantined objects. Other programs accessing the repository will not be able to see the objects (and if the pre-receive hook fails, those refs would become corrupted). For safety, any ref updates from within &lt;code&gt;pre-receive&lt;/code&gt; are automatically rejected.</source>
          <target state="translated">在 &lt;code&gt;pre-receive&lt;/code&gt; 钩不得更新任何裁判给点隔离的对象。其他访问存储库的程序将无法查看对象（如果预接收挂钩失败，则这些引用将被损坏）。为了安全起见，来自 &lt;code&gt;pre-receive&lt;/code&gt; 内部的所有参考更新都会被自动拒绝。</target>
        </trans-unit>
        <trans-unit id="eb98cabc50bf16dce560817c25a1c4d64601cce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pu&lt;/code&gt; branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; &lt;code&gt;tmp&lt;/code&gt; will not be.</source>
          <target state="translated">该 &lt;code&gt;pu&lt;/code&gt; 即使它没有快进的，因为它是一个加号前缀分公司将被更新; &lt;code&gt;tmp&lt;/code&gt; 不会。</target>
        </trans-unit>
        <trans-unit id="d5f7235d0f9a5c833ca324eff7dc4ec19b6e7285" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pull&lt;/code&gt; command knows where to get updates from because of certain configuration variables that were set by the first &lt;code&gt;git clone&lt;/code&gt; command; see &lt;code&gt;git config -l&lt;/code&gt; and the &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; man page for details.</source>
          <target state="translated">由于第一个 &lt;code&gt;git clone&lt;/code&gt; 命令设置了某些配置变量，因此 &lt;code&gt;pull&lt;/code&gt; 命令知道从何处获取更新。有关详细信息，请参见 &lt;code&gt;git config -l&lt;/code&gt; 和&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;手册页。</target>
        </trans-unit>
        <trans-unit id="9716ab4c9bb8eabfdb4d2f2052c2761838dfc4ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r1^!&lt;/code&gt; notation includes commit &lt;code&gt;r1&lt;/code&gt; but excludes all of its parents. By itself, this notation denotes the single commit &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;r1^!&lt;/code&gt; 表示法包括提交 &lt;code&gt;r1&lt;/code&gt; ,但不包括其所有父项。该符号本身表示单个提交 &lt;code&gt;r1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec7b0d87246117fbc7ede1e9fb5e445953432dc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r1^@&lt;/code&gt; notation means all parents of &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;r1^@&lt;/code&gt; 符号表示的所有家长 &lt;code&gt;r1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="906a6c33616cfaeeffbd4277ee44152fa9cd28f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;raw&lt;/code&gt; format shows the entire commit exactly as stored in the commit object. Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and &lt;code&gt;parents&lt;/code&gt; information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with &lt;code&gt;git log --raw&lt;/code&gt;. To get full object names in a raw diff format, use &lt;code&gt;--no-abbrev&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;raw&lt;/code&gt; 格式示出了整个提交完全一样存储在commit对象。值得注意的是，无论是否使用--abbrev或--no-abbrev，哈希值都会完整显示，并且 &lt;code&gt;parents&lt;/code&gt; 信息显示了真正的父级提交，而没有考虑嫁接或简化历史记录。注意，这种格式会影响提交的显示方式，但不会影响diff的显示方式，例如 &lt;code&gt;git log --raw&lt;/code&gt; 。要获取原始diff格式的完整对象名称，请使用 &lt;code&gt;--no-abbrev&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e2ae08cd51826a72547a4936e1fee7033d540d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursive&lt;/code&gt; strategy can take the following options:</source>
          <target state="translated">该 &lt;code&gt;recursive&lt;/code&gt; 策略可以采取下列选项：</target>
        </trans-unit>
        <trans-unit id="2274cd304e0d47984767afeee4d877ca51fbdd54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refs/heads/*&lt;/code&gt; namespace will only accept commit objects, and updates only if they can be fast-forwarded.</source>
          <target state="translated">该 &lt;code&gt;refs/heads/*&lt;/code&gt; 命名空间将只接受提交对象，且仅当他们可以更新快进。</target>
        </trans-unit>
        <trans-unit id="73d202d810478ee27aec0a92a74e6cf7efe8db45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refs/tags/*&lt;/code&gt; namespace will accept any kind of object (as commits, trees and blobs can be tagged), and any updates to them will be rejected.</source>
          <target state="translated">该 &lt;code&gt;refs/tags/*&lt;/code&gt; 命名空间将接受任何类型的对象（如提交，树木和斑点可以被标记），并给他们任何更新将被拒绝。</target>
        </trans-unit>
        <trans-unit id="8f1fa8b6ca43d585bbef39f492a9db57e9ecc9a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reset&lt;/code&gt; command can also be used to create lightweight (non-annotated) tags. For example:</source>
          <target state="translated">该 &lt;code&gt;reset&lt;/code&gt; 命令也可以用于创建轻量（未标注）标签。例如：</target>
        </trans-unit>
        <trans-unit id="bd2e909f258c6aa58fa07c5acaee67caeb1da10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reset&lt;/code&gt; command resets the HEAD, index and worktree to the specified revision. It is similar to an &lt;code&gt;exec git reset --hard &amp;lt;label&amp;gt;&lt;/code&gt;, but refuses to overwrite untracked files. If the &lt;code&gt;reset&lt;/code&gt; command fails, it is rescheduled immediately, with a helpful message how to edit the todo list (this typically happens when a &lt;code&gt;reset&lt;/code&gt; command was inserted into the todo list manually and contains a typo).</source>
          <target state="translated">的 &lt;code&gt;reset&lt;/code&gt; 命令重置HEAD，索引和worktree到指定的修订版本。它类似于 &lt;code&gt;exec git reset --hard &amp;lt;label&amp;gt;&lt;/code&gt; ，但是拒绝覆盖未跟踪的文件。如果 &lt;code&gt;reset&lt;/code&gt; 命令失败，则会立即重新安排时间表，并提供一条有用的消息，说明如何编辑待办事项列表（通常在将 &lt;code&gt;reset&lt;/code&gt; 命令手动插入待办事项列表并包含错字时会发生这种情况）。</target>
        </trans-unit>
        <trans-unit id="f2c26b231ec380ef2e111ace64d683b597b18aa2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;seen&lt;/code&gt; branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; &lt;code&gt;tmp&lt;/code&gt; will not be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06cca2918a8a255dfff1d384369e4d4195e47f51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shortlog&lt;/code&gt; view is more compact; it shows one commit per line.</source>
          <target state="translated">所述 &lt;code&gt;shortlog&lt;/code&gt; 视图更紧凑; 它显示每行一次提交。</target>
        </trans-unit>
        <trans-unit id="49d7635e517e74681985e2d5acfe0d3faa2b57eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tagger&lt;/code&gt; command uses the same format as &lt;code&gt;committer&lt;/code&gt; within &lt;code&gt;commit&lt;/code&gt;; again see above for details.</source>
          <target state="translated">所述 &lt;code&gt;tagger&lt;/code&gt; 命令使用相同的格式 &lt;code&gt;committer&lt;/code&gt; 内 &lt;code&gt;commit&lt;/code&gt; ; 再次参见上面的详细信息。</target>
        </trans-unit>
        <trans-unit id="c5d1574573f9cb9deb3517e06eb81c31c726f5b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;textconv&lt;/code&gt; config option is used to define a program for performing such a conversion. The program should take a single argument, the name of a file to convert, and produce the resulting text on stdout.</source>
          <target state="translated">所述 &lt;code&gt;textconv&lt;/code&gt; 配置选项被用来定义用于执行这种转换的程序。该程序应使用单个参数，即要转换的文件的名称，并在stdout上生成结果文本。</target>
        </trans-unit>
        <trans-unit id="5a024de933cb7ecb7f2684cd23c20dd59cced4c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tformat:&lt;/code&gt; format works exactly like &lt;code&gt;format:&lt;/code&gt;, except that it provides &quot;terminator&quot; semantics instead of &quot;separator&quot; semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries. This means that the final entry of a single-line format will be properly terminated with a new line, just as the &quot;oneline&quot; format does. For example:</source>
          <target state="translated">该 &lt;code&gt;tformat:&lt;/code&gt; 格式的操作完全相同 &lt;code&gt;format:&lt;/code&gt; ，不同之处在于它提供了&amp;ldquo;终结者&amp;rdquo;的语义，而不是&amp;ldquo;分隔符&amp;rdquo;的语义。换句话说，每个提交都附加了消息终止符（通常是换行符），而不是在条目之间放置分隔符。这意味着单行格式的最后输入将以换行正确终止，就像&amp;ldquo; oneline&amp;rdquo;格式一样。例如：</target>
        </trans-unit>
        <trans-unit id="df62988b77ac61a631e6a3bd598e4269b439619e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables determine what ends up in the &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; field of commit objects. If you need the &lt;code&gt;author&lt;/code&gt; or &lt;code&gt;committer&lt;/code&gt; to be different, the &lt;code&gt;author.name&lt;/code&gt;, &lt;code&gt;author.email&lt;/code&gt;, &lt;code&gt;committer.name&lt;/code&gt; or &lt;code&gt;committer.email&lt;/code&gt; variables can be set. Also, all of these can be overridden by the &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt;, &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; and &lt;code&gt;EMAIL&lt;/code&gt; environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52696bbc1bd35a1c1c6d78b6535a11990db3bb34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables determine what ends up in the &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; field of commit objects. If you need the &lt;code&gt;author&lt;/code&gt; or &lt;code&gt;committer&lt;/code&gt; to be different, the &lt;code&gt;author.name&lt;/code&gt;, &lt;code&gt;author.email&lt;/code&gt;, &lt;code&gt;committer.name&lt;/code&gt; or &lt;code&gt;committer.email&lt;/code&gt; variables can be set. Also, all of these can be overridden by the &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt;, &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; and &lt;code&gt;EMAIL&lt;/code&gt; environment variables. See &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; for more information.</source>
          <target state="translated">该 &lt;code&gt;user.name&lt;/code&gt; 和 &lt;code&gt;user.email&lt;/code&gt; 变量决定什么在结束了 &lt;code&gt;author&lt;/code&gt; 与 &lt;code&gt;committer&lt;/code&gt; 提交的对象领域。如果您需要 &lt;code&gt;author&lt;/code&gt; 或 &lt;code&gt;committer&lt;/code&gt; 者不同，则可以设置 &lt;code&gt;author.name&lt;/code&gt; ， &lt;code&gt;author.email&lt;/code&gt; ， &lt;code&gt;committer.name&lt;/code&gt; 或 &lt;code&gt;committer.email&lt;/code&gt; 变量。此外，所有这些都可以被 &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt; ， &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt; ， &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt; ， &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; 和 &lt;code&gt;EMAIL&lt;/code&gt; 环境变量覆盖。参见&lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]&lt;/a&gt; 想要查询更多的信息。</target>
        </trans-unit>
        <trans-unit id="e856d2a5737e8a442522cf9dc045cf46da5c837d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;worktree list&lt;/code&gt; command has two output formats. The default format shows the details on a single line with columns. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ffcc56d5f44fe2ccdfd792b9ad74a964b837f9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&amp;hellip;​&lt;/em&gt; (three-dot) Symmetric Difference Notation</source>
          <target state="translated">该&lt;em&gt;...&lt;/em&gt;（三个点）对称差符号</target>
        </trans-unit>
        <trans-unit id="3ca01d997f3f16d56fc54554bfe9b469c32c5dff" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;..&lt;/em&gt; (two-dot) Range Notation</source>
          <target state="translated">该&lt;em&gt;..&lt;/em&gt;（双点）范围标识</target>
        </trans-unit>
        <trans-unit id="28292c9406d9116658f021a9e7e686e22523649d" translate="yes" xml:space="preserve">
          <source>The C rewrite is first included with Git version 2.22 (and Git for Windows version 2.19). This option serves as an escape hatch to re-enable the legacy version in case any bugs are found in the rewrite. This option and the shell script version of &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; will be removed in some future release.</source>
          <target state="translated">C重写首先包含在Git 2.22版（和Git for Windows 2.19版）中。如果在重写中发现任何错误，此选项可作为逃生窗口以重新启用旧版本。此选项和&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;的shell脚本版本将在将来的发行版中删除。</target>
        </trans-unit>
        <trans-unit id="dbe462d7e2f126482bf0dec3d004def2c9c89bb6" translate="yes" xml:space="preserve">
          <source>The CVS module you want to import. Relative to &amp;lt;CVSROOT&amp;gt;. If not given, &lt;code&gt;git cvsimport&lt;/code&gt; tries to read it from &lt;code&gt;CVS/Repository&lt;/code&gt;.</source>
          <target state="translated">您要导入的CVS模块。相对于&amp;lt;CVSROOT&amp;gt;。如果未给出， &lt;code&gt;git cvsimport&lt;/code&gt; 尝试从 &lt;code&gt;CVS/Repository&lt;/code&gt; 读取它。</target>
        </trans-unit>
        <trans-unit id="d9fdb00c7bf3f2937ed399ea5a7eb5783533387f" translate="yes" xml:space="preserve">
          <source>The Event Format Target</source>
          <target state="translated">事件格式目标</target>
        </trans-unit>
        <trans-unit id="91f31eeacecff37ec38db2aff37269235d7422bb" translate="yes" xml:space="preserve">
          <source>The GIT_TRACE_&amp;lt;key&amp;gt; mechanism allows each &amp;lt;key&amp;gt; to write to a different file (in addition to just stderr).</source>
          <target state="translated">GIT_TRACE_ &amp;lt;key&amp;gt;机制允许每个&amp;lt;key&amp;gt;写入不同的文件（除了stderr之外）。</target>
        </trans-unit>
        <trans-unit id="eb9c24f633d0777727caf33c8ede260c0246d232" translate="yes" xml:space="preserve">
          <source>The GPG key ID of the key that signed the push certificate.</source>
          <target state="translated">签署推送证书的密钥的 GPG 密钥 ID。</target>
        </trans-unit>
        <trans-unit id="7fd047e9e0dcddc0ec24d2bfa4a8d0b4477b60c4" translate="yes" xml:space="preserve">
          <source>The Git Repository</source>
          <target state="translated">Git 仓库</target>
        </trans-unit>
        <trans-unit id="ec69c4a3fd32f0743df23ab218ec13475fdae8cc" translate="yes" xml:space="preserve">
          <source>The Git configuration file contains a number of variables that affect the Git commands' behavior. The files &lt;code&gt;.git/config&lt;/code&gt; and optionally &lt;code&gt;config.worktree&lt;/code&gt; (see &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; below) in each repository are used to store the configuration for that repository, and &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; is used to store a per-user configuration as fallback values for the &lt;code&gt;.git/config&lt;/code&gt; file. The file &lt;code&gt;/etc/gitconfig&lt;/code&gt; can be used to store a system-wide default configuration.</source>
          <target state="translated">Git配置文件包含许多影响Git命令行为的变量。每个存储库中的文件 &lt;code&gt;.git/config&lt;/code&gt; 和可选的 &lt;code&gt;config.worktree&lt;/code&gt; （请参见下面的 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; ）用于存储该存储库的配置，而 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 用于存储每个用户的配置作为后备值在 &lt;code&gt;.git/config&lt;/code&gt; 文件。 &lt;code&gt;/etc/gitconfig&lt;/code&gt; 文件可用于存储系统范围的默认配置。</target>
        </trans-unit>
        <trans-unit id="57dbf68c8f67f403d793ac43faa2e8d1a6fb8f3b" translate="yes" xml:space="preserve">
          <source>The Git configuration file contains a number of variables that affect the Git commands' behavior. The files &lt;code&gt;.git/config&lt;/code&gt; and optionally &lt;code&gt;config.worktree&lt;/code&gt; (see the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;) in each repository are used to store the configuration for that repository, and &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; is used to store a per-user configuration as fallback values for the &lt;code&gt;.git/config&lt;/code&gt; file. The file &lt;code&gt;/etc/gitconfig&lt;/code&gt; can be used to store a system-wide default configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4676de1f2b8af7673ad60d0d802fc7e29d8da30" translate="yes" xml:space="preserve">
          <source>The Git object directory contains a &lt;code&gt;pack&lt;/code&gt; directory containing packfiles (with suffix &quot;.pack&quot;) and pack-indexes (with suffix &quot;.idx&quot;). The pack-indexes provide a way to lookup objects and navigate to their offset within the pack, but these must come in pairs with the packfiles. This pairing depends on the file names, as the pack-index differs only in suffix with its pack- file. While the pack-indexes provide fast lookup per packfile, this performance degrades as the number of packfiles increases, because abbreviations need to inspect every packfile and we are more likely to have a miss on our most-recently-used packfile. For some large repositories, repacking into a single packfile is not feasible due to storage space or excessive repack times.</source>
          <target state="translated">Git对象目录包含一个 &lt;code&gt;pack&lt;/code&gt; 目录，该目录包含packfiles（后缀&amp;ldquo; .pack&amp;rdquo;）和pack-indexes（后缀&amp;ldquo; .idx&amp;rdquo;）。包索引提供了一种查找对象并导航到包内偏移量的方法，但这些对象必须与包文件成对出现。配对取决于文件名，因为pack-index仅在带有后缀的pack-file中有所不同。尽管pack-indexs提供了每个packfile的快速查找功能，但是随着packfile数量的增加，这种性能会下降，因为缩写需要检查每个packfile，而我们最有可能会错过最近使用的packfile。对于某些大型存储库，由于存储空间或重新包装时间过多，将其重新包装到单个packfile中是不可行的。</target>
        </trans-unit>
        <trans-unit id="a2329c4ac9f08d776040ac221ffa562b7323c3f6" translate="yes" xml:space="preserve">
          <source>The Git protocol gives better performance and reliability, but on a host with a web server set up, HTTP exports may be simpler to set up.</source>
          <target state="translated">Git协议能提供更好的性能和可靠性,但在设置了Web服务器的主机上,HTTP导出的设置可能更简单。</target>
        </trans-unit>
        <trans-unit id="1179b23d825b14c0a26acd1779bd21e4b7a2880e" translate="yes" xml:space="preserve">
          <source>The Git remote to import this CVS repository into. Moves all CVS branches into remotes/&amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt; akin to the way &lt;code&gt;git clone&lt;/code&gt; uses &lt;code&gt;origin&lt;/code&gt; by default.</source>
          <target state="translated">将这个CVS信息库导入到的Git远程。将所有CVS分支移动到类似于 &lt;code&gt;git clone&lt;/code&gt; 默认使用 &lt;code&gt;origin&lt;/code&gt; 的方式的remotes / &amp;lt;remote&amp;gt; / &amp;lt;branch&amp;gt;中。</target>
        </trans-unit>
        <trans-unit id="bd47eb27f30e04cbdc75cd21789edadd8836d3bb" translate="yes" xml:space="preserve">
          <source>The Git repository browser</source>
          <target state="translated">Git 仓库浏览器</target>
        </trans-unit>
        <trans-unit id="076055123196294023f50dc3852a8243be06956f" translate="yes" xml:space="preserve">
          <source>The Git repository browser. Shows branches, commit history and file differences. gitk is the utility started by &lt;code&gt;git gui&lt;/code&gt;'s Repository Visualize actions.</source>
          <target state="translated">Git存储库浏览器。显示分支，提交历史记录和文件差异。gitk是由 &lt;code&gt;git gui&lt;/code&gt; 的 &amp;ldquo;存储库可视化&amp;rdquo;操作启动的实用程序。</target>
        </trans-unit>
        <trans-unit id="703dfd23887a83d4329e915dd0bcbd7608c6b6a7" translate="yes" xml:space="preserve">
          <source>The Git repository to import to. If the directory doesn&amp;rsquo;t exist, it will be created. Default is the current directory.</source>
          <target state="translated">要导入到的Git存储库。如果该目录不存在，将创建该目录。默认为当前目录。</target>
        </trans-unit>
        <trans-unit id="6970e04ce98d2b4a3b2c6e8de2880e4a745e2c4f" translate="yes" xml:space="preserve">
          <source>The HEAD then refers to the SHA-1 of the commit instead of to a branch, and git branch shows that you are no longer on a branch:</source>
          <target state="translated">然后,HEAD指的是提交的SHA-1,而不是分支,git branch显示你已经不在一个分支上了。</target>
        </trans-unit>
        <trans-unit id="895d60d2bce01273de11df4a950c78fe3184bcf0" translate="yes" xml:space="preserve">
          <source>The HTTP USER_AGENT string presented to an HTTP server. The default value represents the version of the client Git such as git/1.7.1. This option allows you to override this value to a more common value such as Mozilla/4.0. This may be necessary, for instance, if connecting through a firewall that restricts HTTP connections to a set of common USER_AGENT strings (but not including those like git/1.7.1). Can be overridden by the &lt;code&gt;GIT_HTTP_USER_AGENT&lt;/code&gt; environment variable.</source>
          <target state="translated">提供给HTTP服务器的HTTP USER_AGENT字符串。默认值表示客户端Git的版本，例如git / 1.7.1。此选项使您可以将此值替代为更常见的值，例如Mozilla / 4.0。例如，如果通过限制HTTP连接到一组常见USER_AGENT字符串（但不包括git / 1.7.1的字符串）的防火墙进行连接，则可能有必要。可以被 &lt;code&gt;GIT_HTTP_USER_AGENT&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="00aa9820c66c0255936f6c8707aec2ad36a5c140" translate="yes" xml:space="preserve">
          <source>The HTTP daemon command-line that will be executed. Command-line options may be specified here, and the configuration file will be added at the end of the command-line. Currently apache2, lighttpd, mongoose, plackup, python and webrick are supported. (Default: lighttpd)</source>
          <target state="translated">将要执行的HTTP守护进程命令行。命令行选项可以在这里指定,配置文件将添加在命令行的最后。目前支持apache2、lighttpd、mongoose、plackup、python和webrick。(默认:lighttpd)</target>
        </trans-unit>
        <trans-unit id="adee6c32cf5372a9cc214e1cabc3f604f4a421cf" translate="yes" xml:space="preserve">
          <source>The HTTP daemon command-line to start gitweb on your working repository. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">HTTP守护程序命令行，用于在您的工作存储库上启动gitweb。参见&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a20118bebd861685578a19065b0fb24ab670ec89" translate="yes" xml:space="preserve">
          <source>The MIDX file format uses a chunk-based approach (similar to the commit-graph file) that allows optional data to be added.</source>
          <target state="translated">MIDX文件格式使用基于分块的方法(类似于提交-图形文件),允许添加可选的数据。</target>
        </trans-unit>
        <trans-unit id="64e372cd9f501c41226d338629f4adfe7884c507" translate="yes" xml:space="preserve">
          <source>The MIDX is stored in a file named &lt;code&gt;multi-pack-index&lt;/code&gt; in the .git/objects/pack directory. This could be stored in the pack directory of an alternate. It refers only to packfiles in that same directory.</source>
          <target state="translated">MIDX存储在.git / objects / pack目录中名为 &lt;code&gt;multi-pack-index&lt;/code&gt; 的文件中。这可以存储在备用目录的pack目录中。它仅引用相同目录中的packfiles。</target>
        </trans-unit>
        <trans-unit id="be240040a2b303919e9f8b3f8c55bd2d4b871823" translate="yes" xml:space="preserve">
          <source>The MIDX keeps only one record per object ID. If an object appears in multiple packfiles, then the MIDX selects the copy in the most- recently modified packfile.</source>
          <target state="translated">MIDX 每个对象 ID 只保留一条记录。如果一个对象出现在多个包文件中,那么 MIDX 会选择最近修改的包文件中的副本。</target>
        </trans-unit>
        <trans-unit id="d248ab48f510e2fbd4b16391dc71868ce2bb9eb7" translate="yes" xml:space="preserve">
          <source>The MUA corrupted your patch; &quot;am&quot; would complain that the patch does not apply. Look in the .git/rebase-apply/ subdirectory and see what &lt;code&gt;patch&lt;/code&gt; file contains and check for the common corruption patterns mentioned above.</source>
          <target state="translated">MUA损坏了您的补丁；&amp;ldquo; am&amp;rdquo;会抱怨该补丁不适用。在.git / rebase-apply /子目录中查找并查看 &lt;code&gt;patch&lt;/code&gt; 文件包含的内容，并检查上述常见损坏模式。</target>
        </trans-unit>
        <trans-unit id="dcfedffa2e791a211c838c6711816e41fded8f05" translate="yes" xml:space="preserve">
          <source>The Normal Format Target</source>
          <target state="translated">标准格式目标</target>
        </trans-unit>
        <trans-unit id="500d32200a061b0c3eb8acb59a37b1ba3087273e" translate="yes" xml:space="preserve">
          <source>The Object Database</source>
          <target state="translated">对象数据库</target>
        </trans-unit>
        <trans-unit id="b3b387e6e23160b9001074a3b231e88c333277a0" translate="yes" xml:space="preserve">
          <source>The PERF target is intended for interactive performance analysis during development and is quite noisy.</source>
          <target state="translated">PERF目标是为了在开发过程中进行交互式的性能分析,是相当嘈杂的。</target>
        </trans-unit>
        <trans-unit id="716ba6c2a540215443944eab8349af10087e97bb" translate="yes" xml:space="preserve">
          <source>The Performance Format Target</source>
          <target state="translated">性能格式目标</target>
        </trans-unit>
        <trans-unit id="ca04878afc5a61720c26b830b963e827e884a4f1" translate="yes" xml:space="preserve">
          <source>The SSL version to use when negotiating an SSL connection, if you want to force the default. The available and default version depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; option; see the libcurl documentation for more details on the format of this option and for the ssl version supported. Actually the possible values of this option are:</source>
          <target state="translated">如果要强制使用默认值，则在协商SSL连接时要使用的SSL版本。可用的默认版本取决于libcurl是针对NSS还是OpenSSL构建的，以及所使用的加密库的特定配置。在内部，这会设置 &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; 选项；有关此选项的格式和受支持的ssl版本的更多详细信息，请参见libcurl文档。实际上，此选项的可能值为：</target>
        </trans-unit>
        <trans-unit id="018a79839a5b69e87551f5d2d8901721b830b6f5" translate="yes" xml:space="preserve">
          <source>The SSL version to use when negotiating an SSL connection, if you want to force the default. The available and default version depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; option; see the libcurl documentation for more details on the format of this option and for the ssl version supported. Currently the possible values of this option are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8d77384dcf5927fceefc0c82e6aa35599c0a0b" translate="yes" xml:space="preserve">
          <source>The Trace2 API can be used to print debug, performance, and telemetry information to stderr or a file. The Trace2 feature is inactive unless explicitly enabled by enabling one or more Trace2 Targets.</source>
          <target state="translated">Trace2 API 可用于将调试、性能和遥测信息打印到 stderr 或文件中。除非通过启用一个或多个 Trace2 Targets 来明确启用,否则 Trace2 功能是不活跃的。</target>
        </trans-unit>
        <trans-unit id="6bdbd91221731e97e635f28174406bd894d81047" translate="yes" xml:space="preserve">
          <source>The Trace2 API defines a set of high-level messages with known fields, such as (&lt;code&gt;start&lt;/code&gt;: &lt;code&gt;argv&lt;/code&gt;) and (&lt;code&gt;exit&lt;/code&gt;: {&lt;code&gt;exit-code&lt;/code&gt;, &lt;code&gt;elapsed-time&lt;/code&gt;}).</source>
          <target state="translated">Trace2 API定义了一组具有已知字段的高级消息，例如（ &lt;code&gt;start&lt;/code&gt; ： &lt;code&gt;argv&lt;/code&gt; ）和（ &lt;code&gt;exit&lt;/code&gt; ：{ &lt;code&gt;exit-code&lt;/code&gt; ， &lt;code&gt;elapsed-time&lt;/code&gt; }）。</target>
        </trans-unit>
        <trans-unit id="c8d932fd39b46f7d652bfdd2be6511ab09fc4671" translate="yes" xml:space="preserve">
          <source>The Trace2 API is intended to replace the existing (Trace1) printf-style tracing provided by the existing &lt;code&gt;GIT_TRACE&lt;/code&gt; and &lt;code&gt;GIT_TRACE_PERFORMANCE&lt;/code&gt; facilities. During initial implementation, Trace2 and Trace1 may operate in parallel.</source>
          <target state="translated">Trace2 API旨在替代现有 &lt;code&gt;GIT_TRACE&lt;/code&gt; 和 &lt;code&gt;GIT_TRACE_PERFORMANCE&lt;/code&gt; 工具提供的现有（Trace1）printf样式跟踪。在初始实施期间，Trace2和Trace1可以并行运行。</target>
        </trans-unit>
        <trans-unit id="a5397d7e9698d7ad87ff097450bf8a8e1a772416" translate="yes" xml:space="preserve">
          <source>The Trace2 code also defines a set of private functions and data types in the &lt;code&gt;trace2/&lt;/code&gt; directory. These symbols are prefixed with &lt;code&gt;tr2_&lt;/code&gt; and should only be used by functions in &lt;code&gt;trace2.c&lt;/code&gt;.</source>
          <target state="translated">Trace2代码还在 &lt;code&gt;trace2/&lt;/code&gt; 目录中定义了一组私有函数和数据类型。这些符号以 &lt;code&gt;tr2_&lt;/code&gt; 为前缀，并且只能由 &lt;code&gt;trace2.c&lt;/code&gt; 中的函数使用。</target>
        </trans-unit>
        <trans-unit id="8e231fe7d9a0eb53151c1a418399ded2fd9db9e8" translate="yes" xml:space="preserve">
          <source>The URL for a submodule. This variable is copied from the .gitmodules file to the git config via &lt;code&gt;git submodule init&lt;/code&gt;. The user can change the configured URL before obtaining the submodule via &lt;code&gt;git submodule update&lt;/code&gt;. If neither submodule.&amp;lt;name&amp;gt;.active or submodule.active are set, the presence of this variable is used as a fallback to indicate whether the submodule is of interest to git commands. See &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">子模块的URL。此变量通过 &lt;code&gt;git submodule init&lt;/code&gt; 从.gitmodules文件复制到git config 。用户可以在通过 &lt;code&gt;git submodule update&lt;/code&gt; 获得子模块之前更改配置的URL 。如果未设置submodule。&amp;lt;name&amp;gt; .active或submodule.active，则此变量的存在将用作回退，以指示git命令是否对子模块感兴趣。有关详细信息，请参见&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt;和&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="307f8458b88cd1196dc3047eb250fdb8e3348b46" translate="yes" xml:space="preserve">
          <source>The URL of a remote repository. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; or &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">远程存储库的URL。参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;或&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="92c06c873fe7803ddcdb456ba837dbd24d10b389" translate="yes" xml:space="preserve">
          <source>The URL to the remote repository.</source>
          <target state="translated">远程存储库的URL。</target>
        </trans-unit>
        <trans-unit id="846d99295948de526a5621f0a520c5a9a78af747" translate="yes" xml:space="preserve">
          <source>The Workflow</source>
          <target state="translated">工作流程</target>
        </trans-unit>
        <trans-unit id="91d8165377483e9123ecf4a3d5455b3b1999d185" translate="yes" xml:space="preserve">
          <source>The above can also be written as simply</source>
          <target state="translated">上述内容也可以简单写成</target>
        </trans-unit>
        <trans-unit id="13c712cb6756cc53fb3407886d0503d18cb537c0" translate="yes" xml:space="preserve">
          <source>The above command copies all branches from the remote refs/heads/ namespace and stores them to the local refs/remotes/origin/ namespace, unless the branch.&amp;lt;name&amp;gt;.fetch option is used to specify a non-default refspec.</source>
          <target state="translated">上面的命令从远程refs / heads /命名空间复制所有分支，并将它们存储到本地refs / remotes / origin /命名空间，除非使用branch。&amp;lt;name&amp;gt; .fetch选项指定非默认的refspec。</target>
        </trans-unit>
        <trans-unit id="61e1efd32cbb415eea7b734b98558317a6d1aac3" translate="yes" xml:space="preserve">
          <source>The above command would change the origin repository to</source>
          <target state="translated">上面的命令会将源码库改为</target>
        </trans-unit>
        <trans-unit id="cc504649b9359e7717badcdf0f10e04d6127c3a0" translate="yes" xml:space="preserve">
          <source>The above configuration expects your public repositories to live under &lt;code&gt;/pub/git&lt;/code&gt; and will serve them as &lt;code&gt;http://git.domain.org/dir-under-pub-git&lt;/code&gt;, both as clonable Git URL and as browseable gitweb interface. If you then start your &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; with &lt;code&gt;--base-path=/pub/git --export-all&lt;/code&gt; then you can even use the &lt;code&gt;git://&lt;/code&gt; URL with exactly the same path.</source>
          <target state="translated">上面的配置期望您的公共存储库位于 &lt;code&gt;/pub/git&lt;/code&gt; 下，并将它们作为 &lt;code&gt;http://git.domain.org/dir-under-pub-git&lt;/code&gt; ，可克隆的Git URL和可浏览的gitweb界面使用。如果然后使用 &lt;code&gt;--base-path=/pub/git --export-all&lt;/code&gt; 启动&lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt;，那么您甚至可以使用路径完全相同的 &lt;code&gt;git://&lt;/code&gt; URL。</target>
        </trans-unit>
        <trans-unit id="baa5f35656f9b3f3ba646932132fa97233a197b9" translate="yes" xml:space="preserve">
          <source>The above is all you need to know to resolve a simple merge. But Git also provides more information to help resolve conflicts:</source>
          <target state="translated">以上就是解决一个简单的合并问题所需要知道的全部内容。但Git也提供了更多信息来帮助解决冲突。</target>
        </trans-unit>
        <trans-unit id="70fce3bc08ea4ed40bcc99c52f88c26bd24f0b87" translate="yes" xml:space="preserve">
          <source>The above is the description of a Git merge at the lowest level, to help you understand what conceptually happens under the hood. In practice, nobody, not even Git itself, runs &lt;code&gt;git cat-file&lt;/code&gt; three times for this. There is a &lt;code&gt;git merge-index&lt;/code&gt; program that extracts the stages to temporary files and calls a &quot;merge&quot; script on it:</source>
          <target state="translated">上面是最低级别的Git合并的描述，以帮助您了解引擎盖下的概念。实际上，没有人，甚至是Git本身，都没有为此运行过 &lt;code&gt;git cat-file&lt;/code&gt; 3次。有一个 &lt;code&gt;git merge-index&lt;/code&gt; 程序，可将阶段提取到临时文件并在其上调用&amp;ldquo;合并&amp;rdquo;脚本：</target>
        </trans-unit>
        <trans-unit id="eb77c0d462477bf4637c28037a03befbbf605c33" translate="yes" xml:space="preserve">
          <source>The absolute path to the worktree in which the ref is checked out, if it is checked out in any linked worktree. Empty string otherwise.</source>
          <target state="translated">如果ref在任何链接的工作树中被签出,则表示该工作树的绝对路径。否则为空字符串。</target>
        </trans-unit>
        <trans-unit id="76cd9fb4bfcc53cf44ccfea4ed1923acc958405e" translate="yes" xml:space="preserve">
          <source>The accepted attributes are &lt;code&gt;bold&lt;/code&gt;, &lt;code&gt;dim&lt;/code&gt;, &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;blink&lt;/code&gt;, &lt;code&gt;reverse&lt;/code&gt;, &lt;code&gt;italic&lt;/code&gt;, and &lt;code&gt;strike&lt;/code&gt; (for crossed-out or &quot;strikethrough&quot; letters). The position of any attributes with respect to the colors (before, after, or in between), doesn&amp;rsquo;t matter. Specific attributes may be turned off by prefixing them with &lt;code&gt;no&lt;/code&gt; or &lt;code&gt;no-&lt;/code&gt; (e.g., &lt;code&gt;noreverse&lt;/code&gt;, &lt;code&gt;no-ul&lt;/code&gt;, etc).</source>
          <target state="translated">可接受的属性为 &lt;code&gt;bold&lt;/code&gt; ， &lt;code&gt;dim&lt;/code&gt; ， &lt;code&gt;ul&lt;/code&gt; ， &lt;code&gt;blink&lt;/code&gt; ， &lt;code&gt;reverse&lt;/code&gt; ， &lt;code&gt;italic&lt;/code&gt; 和 &lt;code&gt;strike&lt;/code&gt; （对于划线或&amp;ldquo;删除线&amp;rdquo;字母）。任何属性相对于颜色的位置（之前，之后或之间）都无关紧要。可以通过给特定属性加上 &lt;code&gt;no&lt;/code&gt; 或 &lt;code&gt;no-&lt;/code&gt; （例如 &lt;code&gt;noreverse&lt;/code&gt; ， &lt;code&gt;no-ul&lt;/code&gt; 等）来关闭特定属性。</target>
        </trans-unit>
        <trans-unit id="0bb8a69a5cde6b982a60a95e4956ebdf1a59fa5f" translate="yes" xml:space="preserve">
          <source>The accepted patterns in the cone pattern set are:</source>
          <target state="translated">锥型图案集中可接受的图案有:</target>
        </trans-unit>
        <trans-unit id="ec26e1bb6d1ddd903fea6ea4b1aec39f9a4bdff7" translate="yes" xml:space="preserve">
          <source>The action of fixing up manually what a failed automatic &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; left behind.</source>
          <target state="translated">手动修复失败的自动&lt;a href=&quot;#def_merge&quot;&gt;合并&lt;/a&gt;留下的操作。</target>
        </trans-unit>
        <trans-unit id="91929f919cdca3ddad9711d4446a1108e24ab05c" translate="yes" xml:space="preserve">
          <source>The action of updating all or part of the &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; with a &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; or &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; from the &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt;, and updating the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; and &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; if the whole working tree has been pointed at a new &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;.</source>
          <target state="translated">更新的全部或部分行动&lt;a href=&quot;#def_working_tree&quot;&gt;工作树&lt;/a&gt;与&lt;a href=&quot;#def_tree_object&quot;&gt;树对象&lt;/a&gt;或&lt;a href=&quot;#def_blob_object&quot;&gt;BLOB&lt;/a&gt;从&lt;a href=&quot;#def_object_database&quot;&gt;对象数据库&lt;/a&gt;，并更新&lt;a href=&quot;#def_index&quot;&gt;索引&lt;/a&gt;和&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;，如果整个工作树已经指出，在一个新的&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf91c6dac7e4978798d8310657f124dd799f4bf4" translate="yes" xml:space="preserve">
          <source>The action that will be run. Defaults to &lt;code&gt;projects_list&lt;/code&gt; if repo is not set, and to &lt;code&gt;summary&lt;/code&gt; otherwise.</source>
          <target state="translated">将要运行的动作。如果未设置repo，则默认为 &lt;code&gt;projects_list&lt;/code&gt; ，否则为 &lt;code&gt;summary&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e262b52287502541a33fa85d5cf2fdae897da448" translate="yes" xml:space="preserve">
          <source>The active branch LRU, when coupled with the filename string pool and lazy loading of subtrees, allows fast-import to efficiently import projects with 2,000+ branches and 45,114+ files in a very limited memory footprint (less than 2.7 MiB per active branch).</source>
          <target state="translated">活动分支LRU,结合文件名字符串池和子树的懒惰加载,允许快速导入,以非常有限的内存占用(每个活动分支小于2.7 MiB)有效地导入2000多个分支和45114个文件的项目。</target>
        </trans-unit>
        <trans-unit id="5b37048d4139b83b97c29aa7a22d2da66c283ae2" translate="yes" xml:space="preserve">
          <source>The actual configuration line should be on one line.</source>
          <target state="translated">实际的配置行应在一行。</target>
        </trans-unit>
        <trans-unit id="b70c0ba474f3173fff896ac2745af10a69e6cc3b" translate="yes" xml:space="preserve">
          <source>The additional AliasMatch makes it so that</source>
          <target state="translated">额外的AliasMatch使它可以使</target>
        </trans-unit>
        <trans-unit id="d6139a3bd26979c3a7767519a48aa9c385b73634" translate="yes" xml:space="preserve">
          <source>The advantage of doing this is that the history of &lt;code&gt;next&lt;/code&gt; will be clean. For example, some topics merged into &lt;code&gt;next&lt;/code&gt; may have initially looked promising, but were later found to be undesirable or premature. In such a case, the topic is reverted out of &lt;code&gt;next&lt;/code&gt; but the fact remains in the history that it was once merged and reverted. By recreating &lt;code&gt;next&lt;/code&gt;, you give another incarnation of such topics a clean slate to retry, and a feature release is a good point in history to do so.</source>
          <target state="translated">这样做的好处是 &lt;code&gt;next&lt;/code&gt; 的历史将很干净。例如，合并到 &lt;code&gt;next&lt;/code&gt; 主题中的某些主题起初看起来很有希望，但后来被发现是不受欢迎或不成熟的。在这种情况下，该主题会从下 &lt;code&gt;next&lt;/code&gt; 还原出来，但事实是它曾经被合并和还原过。通过重新创建 &lt;code&gt;next&lt;/code&gt; ，您可以使这些主题的另一种形式完全可以重试，并且功能发布是历史上这样做的好时机。</target>
        </trans-unit>
        <trans-unit id="2f1746fed6139a8489ee3d916322bdcbeb17e684" translate="yes" xml:space="preserve">
          <source>The advantage of using an external diff command is flexibility. You are not bound to find line-oriented changes, nor is it necessary for the output to resemble unified diff. You are free to locate and report changes in the most appropriate way for your data format.</source>
          <target state="translated">使用外部diff命令的好处是灵活。你不一定要找到面向行的变化,也不一定要输出类似统一的diff命令。你可以自由地以最适合你的数据格式的方式来定位和报告变化。</target>
        </trans-unit>
        <trans-unit id="37f935f00ace4f7aca8e441adbbf1abe0704a83a" translate="yes" xml:space="preserve">
          <source>The am backend drops any &quot;empty&quot; commits, regardless of whether the commit started empty (had no changes relative to its parent to start with) or ended empty (all changes were already applied upstream in other commits).</source>
          <target state="translated">Am后端会丢弃任何 &quot;空 &quot;的提交,不管该提交是空开始(相对于它的父提交没有任何变化)还是空结束(所有的变化都已经应用到上游的其他提交中)。</target>
        </trans-unit>
        <trans-unit id="dca841501c279516ee09991304a0c48e7701d81e" translate="yes" xml:space="preserve">
          <source>The apply backend has not traditionally called the post-commit hook, while the merge backend has. Both have called the post-checkout hook, though the merge backend has squelched its output. Further, both backends only call the post-checkout hook with the starting point commit of the rebase, not the intermediate commits nor the final commit. In each case, the calling of these hooks was by accident of implementation rather than by design (both backends were originally implemented as shell scripts and happened to invoke other commands like &lt;code&gt;git checkout&lt;/code&gt; or &lt;code&gt;git commit&lt;/code&gt; that would call the hooks). Both backends should have the same behavior, though it is not entirely clear which, if any, is correct. We will likely make rebase stop calling either of these hooks in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d847a3833f639a38bf6461e5e337a484ba4ec15" translate="yes" xml:space="preserve">
          <source>The apply backend has safety problems with an ill-timed interrupt; if the user presses Ctrl-C at the wrong time to try to abort the rebase, the rebase can enter a state where it cannot be aborted with a subsequent &lt;code&gt;git rebase --abort&lt;/code&gt;. The merge backend does not appear to suffer from the same shortcoming. (See &lt;a href=&quot;https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/&quot;&gt;https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/&lt;/a&gt; for details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee2d136841d9fd2b1d297f54743df3833db5f0a" translate="yes" xml:space="preserve">
          <source>The apply backend unfortunately drops intentionally empty commits, i.e. commits that started empty, though these are rare in practice. It also drops commits that become empty and has no option for controlling this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589a509b2859f73d9f2a04b58c811ba95394014f" translate="yes" xml:space="preserve">
          <source>The apply backend works by creating a sequence of patches (by calling &lt;code&gt;format-patch&lt;/code&gt; internally), and then applying the patches in sequence (calling &lt;code&gt;am&lt;/code&gt; internally). Patches are composed of multiple hunks, each with line numbers, a context region, and the actual changes. The line numbers have to be taken with some fuzz, since the other side will likely have inserted or deleted lines earlier in the file. The context region is meant to help find how to adjust the line numbers in order to apply the changes to the right lines. However, if multiple areas of the code have the same surrounding lines of context, the wrong one can be picked. There are real-world cases where this has caused commits to be reapplied incorrectly with no conflicts reported. Setting diff.context to a larger value may prevent such types of problems, but increases the chance of spurious conflicts (since it will require more lines of matching context to apply).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="013053835d145f0cc494db8211a188c9999bae09" translate="yes" xml:space="preserve">
          <source>The area where a pair of conflicting changes happened is marked with markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. The part before the &lt;code&gt;=======&lt;/code&gt; is typically your side, and the part afterwards is typically their side.</source>
          <target state="translated">发生一对冲突的更改的区域用标记 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;=======&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 标记。 &lt;code&gt;=======&lt;/code&gt; 之前的部分通常是您的一面，之后的部分通常是他们的一面。</target>
        </trans-unit>
        <trans-unit id="bbce7a566319a0fa5122538fad84df16b94a33f3" translate="yes" xml:space="preserve">
          <source>The argument to this option may be a glob on ref names, a ref, or the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is equivalent to specifying this option multiple times, one for each matching ref name.</source>
          <target state="translated">这个选项的参数可以是 ref 名称的 glob,也可以是 ref,或者是提交的 SHA-1(可能是缩写)。指定 glob 相当于多次指定这个选项,每个匹配的 ref 名称都有一个。</target>
        </trans-unit>
        <trans-unit id="6083c463b2a8fa637d23cd99c59e9746cb6a7539" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;diff&lt;/code&gt; affects how Git generates diffs for particular files. It can tell Git whether to generate a textual patch for the path or to treat the path as a binary file. It can also affect what line is shown on the hunk header &lt;code&gt;@@ -k,l +n,m @@&lt;/code&gt; line, tell Git to use an external command to generate the diff, or ask Git to convert binary files to a text format before generating the diff.</source>
          <target state="translated">&lt;code&gt;diff&lt;/code&gt; 属性影响Git如何为特定文件生成差异。它可以告诉Git是为路径生成文本补丁还是将路径视为二进制文件。它还可能会影响大块标题 &lt;code&gt;@@ -k,l +n,m @@&lt;/code&gt; 行，告诉Git使用外部命令生成diff，或要求Git在将二进制文件转换为文本格式之前产生差异。</target>
        </trans-unit>
        <trans-unit id="e3fef41e3a691b83ea57e915fd492f173e96b0ec" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;merge&lt;/code&gt; affects how three versions of a file are merged when a file-level merge is necessary during &lt;code&gt;git merge&lt;/code&gt;, and other commands such as &lt;code&gt;git revert&lt;/code&gt; and &lt;code&gt;git cherry-pick&lt;/code&gt;.</source>
          <target state="translated">当在 &lt;code&gt;git merge&lt;/code&gt; 和其他命令（如 &lt;code&gt;git revert&lt;/code&gt; 和 &lt;code&gt;git cherry-pick&lt;/code&gt; )期间需要进行文件级合并时，属性 &lt;code&gt;merge&lt;/code&gt; 影响文件三个版本的合并方式。</target>
        </trans-unit>
        <trans-unit id="2fe7b4a122d21c0258f6159b6aeead7d915c58b4" translate="yes" xml:space="preserve">
          <source>The attributes allow a fine-grained control, how the line endings are converted. Here is an example that will make Git normalize .txt, .vcproj and .sh files, ensure that .vcproj files have CRLF and .sh files have LF in the working directory, and prevent .jpg files from being normalized regardless of their content.</source>
          <target state="translated">属性允许精细地控制行尾的转换方式。下面是一个例子,它将使 Git 规范化 .txt、.vcproj 和 .sh 文件,确保 .vcproj 文件在工作目录下有 CRLF,.sh 文件在工作目录下有 LF,并防止 .jpg 文件无论内容如何都被规范化。</target>
        </trans-unit>
        <trans-unit id="d53ffa6d811b54f0c7bdf879ab5abd1f6c7675e8" translate="yes" xml:space="preserve">
          <source>The author and committer names are by convention some form of a personal name (that is, the name by which other humans refer to you), although Git does not enforce or require any particular form. Arbitrary Unicode may be used, subject to the constraints listed above. This name has no effect on authentication; for that, see the &lt;code&gt;credential.username&lt;/code&gt; variable in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0849ab3d36b0ce6d3f6183dc21f6e83ad1520176" translate="yes" xml:space="preserve">
          <source>The author name and email address to use when no author information can be found in the patch description.</source>
          <target state="translated">当在补丁描述中找不到作者信息时,要使用的作者姓名和电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="b012a2641006f12bad01716515743698d7deabe2" translate="yes" xml:space="preserve">
          <source>The author of a piece of code.</source>
          <target state="translated">一段代码的作者。</target>
        </trans-unit>
        <trans-unit id="147440e8e5aa984c82659720dc655a2dca5add95" translate="yes" xml:space="preserve">
          <source>The backend process sets GIT_COMMITTER_NAME to &lt;code&gt;$REMOTE_USER&lt;/code&gt; and GIT_COMMITTER_EMAIL to &lt;code&gt;${REMOTE_USER}@http.${REMOTE_ADDR}&lt;/code&gt;, ensuring that any reflogs created by &lt;code&gt;git-receive-pack&lt;/code&gt; contain some identifying information of the remote user who performed the push.</source>
          <target state="translated">后端进程将GIT_COMMITTER_NAME设置为 &lt;code&gt;$REMOTE_USER&lt;/code&gt; ，将GIT_COMMITTER_EMAIL设置为 &lt;code&gt;${REMOTE_USER}@http.${REMOTE_ADDR}&lt;/code&gt; ，以确保 &lt;code&gt;git-receive-pack&lt;/code&gt; 创建的所有reflog 都包含执行推送的远程用户的一些标识信息。</target>
        </trans-unit>
        <trans-unit id="21e5e59ef58a1f64125adda00de18248644f6705" translate="yes" xml:space="preserve">
          <source>The base object could also be deltified if it&amp;rsquo;s in the same pack. Ref-delta can also refer to an object outside the pack (i.e. the so-called &quot;thin pack&quot;). When stored on disk however, the pack should be self contained to avoid cyclic dependency.</source>
          <target state="translated">如果基础对象位于同一包中，则也可以将其删除。引用增量还可以引用包外部的对象（即所谓的&amp;ldquo;瘦包&amp;rdquo;）。但是，当存储在磁盘上时，该软件包应该是自包含的，以避免循环依赖性。</target>
        </trans-unit>
        <trans-unit id="1877d075d52f12eee201f2607da0c072a35f24bc" translate="yes" xml:space="preserve">
          <source>The base tree information block is used for maintainers or third party testers to know the exact state the patch series applies to. It consists of the &lt;code&gt;base commit&lt;/code&gt;, which is a well-known commit that is part of the stable part of the project history everybody else works off of, and zero or more &lt;code&gt;prerequisite patches&lt;/code&gt;, which are well-known patches in flight that is not yet part of the &lt;code&gt;base commit&lt;/code&gt; that need to be applied on top of &lt;code&gt;base commit&lt;/code&gt; in topological order before the patches can be applied.</source>
          <target state="translated">基础树信息块用于维护人员或第三方测试人员，以了解补丁程序系列适用的确切状态。它由 &lt;code&gt;base commit&lt;/code&gt; （这是众所周知的提交，它是其他所有人都在其中进行的项目历史的稳定部分的一部分）和零个或多个 &lt;code&gt;prerequisite patches&lt;/code&gt; ，这些补丁是尚未运行的众所周知的补丁所述的部分 &lt;code&gt;base commit&lt;/code&gt; 的顶部施加这种需要 &lt;code&gt;base commit&lt;/code&gt; 在拓扑顺序可以应用补丁之前。</target>
        </trans-unit>
        <trans-unit id="dc39b1b9637026dfb15dfa743421fbe1dc2277e7" translate="yes" xml:space="preserve">
          <source>The basic colors accepted are &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;black&lt;/code&gt;, &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt;, &lt;code&gt;yellow&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt;, &lt;code&gt;magenta&lt;/code&gt;, &lt;code&gt;cyan&lt;/code&gt; and &lt;code&gt;white&lt;/code&gt;. The first color given is the foreground; the second is the background.</source>
          <target state="translated">接受的基本颜色为 &lt;code&gt;normal&lt;/code&gt; 色， &lt;code&gt;black&lt;/code&gt; ， &lt;code&gt;red&lt;/code&gt; ， &lt;code&gt;green&lt;/code&gt; ， &lt;code&gt;yellow&lt;/code&gt; ， &lt;code&gt;blue&lt;/code&gt; ， &lt;code&gt;magenta&lt;/code&gt; ， &lt;code&gt;cyan&lt;/code&gt; 和 &lt;code&gt;white&lt;/code&gt; 。给定的第一个颜色是前景色；第二个是背景。</target>
        </trans-unit>
        <trans-unit id="440eb92d2667463744ad365910f079c5b0c24b8b" translate="yes" xml:space="preserve">
          <source>The basic colors accepted are &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;black&lt;/code&gt;, &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt;, &lt;code&gt;yellow&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt;, &lt;code&gt;magenta&lt;/code&gt;, &lt;code&gt;cyan&lt;/code&gt; and &lt;code&gt;white&lt;/code&gt;. The first color given is the foreground; the second is the background. All the basic colors except &lt;code&gt;normal&lt;/code&gt; have a bright variant that can be speficied by prefixing the color with &lt;code&gt;bright&lt;/code&gt;, like &lt;code&gt;brightred&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e1b119ab89bbecfc6f0f5d854268dcecbb088f" translate="yes" xml:space="preserve">
          <source>The basic form described in DESCRIPTION with a Git directory, a working directory, a &lt;code&gt;gitlink&lt;/code&gt;, and a &lt;code&gt;.gitmodules&lt;/code&gt; entry.</source>
          <target state="translated">描述中描述的基本形式，带有一个Git目录，一个工作目录，一个 &lt;code&gt;gitlink&lt;/code&gt; 和一个 &lt;code&gt;.gitmodules&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="b21f7863c055f0aa6938a038ffa25acf7017fe84" translate="yes" xml:space="preserve">
          <source>The basic greedy diff algorithm. Currently, this is the default.</source>
          <target state="translated">基本的greedy diff算法。目前,这是默认的。</target>
        </trans-unit>
        <trans-unit id="ebbd31d9dd00322abaa4bb83a8b03f787c70d43c" translate="yes" xml:space="preserve">
          <source>The basic requirements:</source>
          <target state="translated">基本要求:</target>
        </trans-unit>
        <trans-unit id="675f96a5f033def81701bda4e874ec2fbad8a388" translate="yes" xml:space="preserve">
          <source>The below documentation is the same as what&amp;rsquo;s found in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">以下文档与&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;中的文档相同：</target>
        </trans-unit>
        <trans-unit id="f55762f9996c39bda184001319965b733714f313" translate="yes" xml:space="preserve">
          <source>The best way to get one is by using the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; command to download a copy of an existing repository. If you don&amp;rsquo;t already have a project in mind, here are some interesting examples:</source>
          <target state="translated">最好的方法是使用&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;命令下载现有存储库的副本。如果您还没有一个项目，这里有一些有趣的例子：</target>
        </trans-unit>
        <trans-unit id="e2b6c88cac94cf24687d4ba9657759c1ab28582a" translate="yes" xml:space="preserve">
          <source>The best way to see how this works is using the &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; command; running gitk now on a Git repository and looking for merge commits will help understand how Git organizes history.</source>
          <target state="translated">观察它如何工作的最好方法是使用&lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt;命令。现在在Git存储库上运行gitk并查找合并提交将有助于了解Git如何组织历史记录。</target>
        </trans-unit>
        <trans-unit id="8130ad227eb2e1ffe8f116dc4280c5919bb4cd97" translate="yes" xml:space="preserve">
          <source>The branch &lt;code&gt;test&lt;/code&gt; is short for &lt;code&gt;refs/heads/test&lt;/code&gt;.</source>
          <target state="translated">分支 &lt;code&gt;test&lt;/code&gt; 是 &lt;code&gt;refs/heads/test&lt;/code&gt; 的缩写。</target>
        </trans-unit>
        <trans-unit id="420b2dd61e4562065a5bd273fcdbaecde70d1742" translate="yes" xml:space="preserve">
          <source>The branch LRU builtin to fast-import tends to behave very well, and the cost of activating an inactive branch is so low that bouncing around between branches has virtually no impact on import performance.</source>
          <target state="translated">Fast-import内置的分支LRU往往表现得非常好,激活一个非活动分支的成本非常低,在分支之间跳来跳去对导入性能几乎没有影响。</target>
        </trans-unit>
        <trans-unit id="58be5b6cbe7d7c0a923608fe1415c68702e2aa84" translate="yes" xml:space="preserve">
          <source>The chain of operation</source>
          <target state="translated">业务链</target>
        </trans-unit>
        <trans-unit id="cb0b83bdafd60672fc0fb681d6c09ff33adfb7dc" translate="yes" xml:space="preserve">
          <source>The changes are still visible in the submodule&amp;rsquo;s reflog.</source>
          <target state="translated">更改仍在子模块的引用日志中可见。</target>
        </trans-unit>
        <trans-unit id="e18a17400a7fdeb34351715eb209f43bb56b69d6" translate="yes" xml:space="preserve">
          <source>The clone command creates a new directory named after the project (&lt;code&gt;git&lt;/code&gt; or &lt;code&gt;linux&lt;/code&gt; in the examples above). After you cd into this directory, you will see that it contains a copy of the project files, called the &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;, together with a special top-level directory named &lt;code&gt;.git&lt;/code&gt;, which contains all the information about the history of the project.</source>
          <target state="translated">clone命令创建一个以项目命名的新目录（在上面的示例中为 &lt;code&gt;git&lt;/code&gt; 或 &lt;code&gt;linux&lt;/code&gt; ）。cd到该目录后，您将看到它包含项目文件的副本，称为&lt;a href=&quot;#def_working_tree&quot;&gt;工作树&lt;/a&gt;，以及一个名为 &lt;code&gt;.git&lt;/code&gt; 的特殊顶级目录，其中包含有关项目历史记录的所有信息。</target>
        </trans-unit>
        <trans-unit id="9b1ff6b6614bf65ff7cf18fa7ac8ca0c73c31da4" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;git commit -a&lt;/code&gt; first looks at your working tree, notices that you have modified hello.c and removed goodbye.c, and performs necessary &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git rm&lt;/code&gt; for you.</source>
          <target state="translated">&lt;code&gt;git commit -a&lt;/code&gt; 命令首先查看您的工作树，注意到您已经修改了hello.c并删除了goodbye.c，并为您执行了必要的 &lt;code&gt;git add&lt;/code&gt; 和 &lt;code&gt;git rm&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95cb34ce247ae47a8a7d5a122ee875bb99decb40" translate="yes" xml:space="preserve">
          <source>The command allows for creation and fast-forwarding of sha1 refs (heads/tags) on the remote end (strictly speaking, it is the local end &lt;code&gt;git-receive-pack&lt;/code&gt; runs, but to the user who is sitting at the send-pack end, it is updating the remote. Confused?)</source>
          <target state="translated">该命令允许在远程端（严格地说，它是本地端 &lt;code&gt;git-receive-pack&lt;/code&gt; 运行，但是对于坐在send-pack端的用户）创建和快速转发sha1 refs（头/标签），它正在更新遥控器。感到困惑吗？）</target>
        </trans-unit>
        <trans-unit id="2b42e9d45bef456324952e5870d272017a1a991c" translate="yes" xml:space="preserve">
          <source>The command also looks at &lt;code&gt;core.trustctime&lt;/code&gt; configuration variable. It can be useful when the inode change time is regularly modified by something outside Git (file system crawlers and backup systems use ctime for marking files processed) (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">该命令还将查看 &lt;code&gt;core.trustctime&lt;/code&gt; 配置变量。当init更改时间由Git外部的某些东西定期修改（文件系统搜寻器和备份系统使用ctime标记已处理的文件）时，它很有用（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b2d2a0a5d3ee3b745ff8e27d667799782d3fee27" translate="yes" xml:space="preserve">
          <source>The command by default does not allow an update that is not a fast-forward to prevent such loss of history.</source>
          <target state="translated">该命令默认不允许更新不是快进,以防止这种历史损失。</target>
        </trans-unit>
        <trans-unit id="57bd298a9fbda93bedda739fa9a93ffd1fbe53dd" translate="yes" xml:space="preserve">
          <source>The command by default packs all tags and refs that are already packed, and leaves other refs alone. This is because branches are expected to be actively developed and packing their tips does not help performance. This option causes branch tips to be packed as well. Useful for a repository with many branches of historical interests.</source>
          <target state="translated">默认情况下,该命令会打包所有已经打包好的标签和引用,而不考虑其他引用。这是因为分支应该是积极开发的,打包它们的提示对性能没有帮助。这个选项会使分支的提示也被打包。对于有许多历史性分支的版本库来说,这个选项很有用。</target>
        </trans-unit>
        <trans-unit id="affc62639786f9435bc3e40b781bdaefab9bf88f" translate="yes" xml:space="preserve">
          <source>The command can also be used to restore the content in the index with &lt;code&gt;--staged&lt;/code&gt;, or restore both the working tree and the index with &lt;code&gt;--staged --worktree&lt;/code&gt;.</source>
          <target state="translated">该命令还可以用来与恢复索引内容 &lt;code&gt;--staged&lt;/code&gt; ，或同时还原工作树，并与指数 &lt;code&gt;--staged --worktree&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="033264e01f6eaf7651e64aee25dc83cea3397f0e" translate="yes" xml:space="preserve">
          <source>The command finds the most recent tag that is reachable from a commit. If the tag points to the commit, then only the tag is shown. Otherwise, it suffixes the tag name with the number of additional commits on top of the tagged object and the abbreviated object name of the most recent commit. The result is a &quot;human-readable&quot; object name which can also be used to identify the commit to other git commands.</source>
          <target state="translated">功能:该命令用于查找可从提交中获取的最新标签。如果标签指向提交,则只显示该标签。否则,它会在标签名称后加上标签对象上的其他提交次数和最近提交的缩写对象名称。结果是一个 &quot;人可读 &quot;的对象名,它也可以用来识别其他 git 命令的提交。</target>
        </trans-unit>
        <trans-unit id="3ab56fbe7068ffbc29e1e09d644dcd93a3d4ced5" translate="yes" xml:space="preserve">
          <source>The command honors &lt;code&gt;color.status&lt;/code&gt; (or &lt;code&gt;status.color&lt;/code&gt; &amp;mdash; they mean the same thing and the latter is kept for backward compatibility) and &lt;code&gt;color.status.&amp;lt;slot&amp;gt;&lt;/code&gt; configuration variables to colorize its output.</source>
          <target state="translated">该命令使用 &lt;code&gt;color.status&lt;/code&gt; （或 &lt;code&gt;status.color&lt;/code&gt; ，它们表示相同的东西，并且保留后者是为了向后兼容）和 &lt;code&gt;color.status.&amp;lt;slot&amp;gt;&lt;/code&gt; 配置变量以使其输出着色。</target>
        </trans-unit>
        <trans-unit id="426f574eb4223ad0c1806f2471b371a9ce2ce62b" translate="yes" xml:space="preserve">
          <source>The command honors &lt;code&gt;core.filemode&lt;/code&gt; configuration variable. If your repository is on a filesystem whose executable bits are unreliable, this should be set to &lt;code&gt;false&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). This causes the command to ignore differences in file modes recorded in the index and the file mode on the filesystem if they differ only on executable bit. On such an unfortunate filesystem, you may need to use &lt;code&gt;git update-index --chmod=&lt;/code&gt;.</source>
          <target state="translated">该命令使用 &lt;code&gt;core.filemode&lt;/code&gt; 配置变量。如果您的存储库位于其可执行位不可靠的文件系统上，则应将其设置为 &lt;code&gt;false&lt;/code&gt; （请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。如果仅在可执行位上存在差异，该命令将导致该命令忽略索引中记录的文件模式和文件系统上的文件模式的差异。在这种不幸的文件系统上，您可能需要使用 &lt;code&gt;git update-index --chmod=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c1fbeab69cdf1a35e381ef7eff39e0ef873ae8e" translate="yes" xml:space="preserve">
          <source>The command is kept primarily for historical reasons; fingers of many people who learned Git long before &lt;code&gt;git log&lt;/code&gt; was invented by reading Linux kernel mailing list are trained to type it.</source>
          <target state="translated">该命令的保留主要是出于历史原因；在通过阅读Linux内核邮件列表发明 &lt;code&gt;git log&lt;/code&gt; 之前很久就学会了Git的许多人的手指都受过训练来键入它。</target>
        </trans-unit>
        <trans-unit id="078766939aed50311c1dcee68ff982a08734592e" translate="yes" xml:space="preserve">
          <source>The command line for those commands that support taking submodules as part of their pathspecs. Most commands have a boolean flag &lt;code&gt;--recurse-submodules&lt;/code&gt; which specify whether to recurse into submodules. Examples are &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;checkout&lt;/code&gt;. Some commands take enums, such as &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;, where you can specify how submodules are affected.</source>
          <target state="translated">这些命令的命令行支持将子模块作为其路径规范的一部分。大多数命令都有一个布尔标志 &lt;code&gt;--recurse-submodules&lt;/code&gt; ，用于指定是否递归到子模块中。例如 &lt;code&gt;grep&lt;/code&gt; 和 &lt;code&gt;checkout&lt;/code&gt; 。一些命令带有枚举，例如 &lt;code&gt;fetch&lt;/code&gt; 和 &lt;code&gt;push&lt;/code&gt; ，您可以在其中指定如何影响子模块。</target>
        </trans-unit>
        <trans-unit id="0c67f633874ba0fbe1af2a193c1c589167c2ab4d" translate="yes" xml:space="preserve">
          <source>The command looks at &lt;code&gt;core.ignorestat&lt;/code&gt; configuration variable. See &lt;code&gt;Using &quot;assume unchanged&quot; bit&lt;/code&gt; section above.</source>
          <target state="translated">该命令查看 &lt;code&gt;core.ignorestat&lt;/code&gt; 配置变量。请参阅上面的 &lt;code&gt;Using &quot;assume unchanged&quot; bit&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="5f7f0d79e587cabe73eebce8a6424fb5cae3c144" translate="yes" xml:space="preserve">
          <source>The command looks at &lt;code&gt;core.ignorestat&lt;/code&gt; configuration variable. When this is true, paths updated with &lt;code&gt;git update-index paths...&lt;/code&gt; and paths updated with other Git commands that update both index and working tree (e.g. &lt;code&gt;git apply --index&lt;/code&gt;, &lt;code&gt;git checkout-index -u&lt;/code&gt;, and &lt;code&gt;git read-tree -u&lt;/code&gt;) are automatically marked as &quot;assume unchanged&quot;. Note that &quot;assume unchanged&quot; bit is &lt;strong&gt;not&lt;/strong&gt; set if &lt;code&gt;git update-index --refresh&lt;/code&gt; finds the working tree file matches the index (use &lt;code&gt;git update-index --really-refresh&lt;/code&gt; if you want to mark them as &quot;assume unchanged&quot;).</source>
          <target state="translated">该命令查看 &lt;code&gt;core.ignorestat&lt;/code&gt; 配置变量。如果为真，则使用 &lt;code&gt;git update-index paths...&lt;/code&gt; 以及使用其他同时更新索引和工作树的Git命令更新的路径（例如 &lt;code&gt;git apply --index&lt;/code&gt; ， &lt;code&gt;git checkout-index -u&lt;/code&gt; 和 &lt;code&gt;git read-tree -u&lt;/code&gt; ）会自动标记为&amp;ldquo;假定未更改&amp;rdquo;。请注意，如果 &lt;code&gt;git update-index --refresh&lt;/code&gt; 找到与索引匹配的工作树文件，则&lt;strong&gt;不会&lt;/strong&gt;设置&amp;ldquo;假定不变&amp;rdquo;位（如果要将它们标记为&amp;ldquo;假定不变&amp;rdquo;，请使用 &lt;code&gt;git update-index --really-refresh&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="719021beca97cba355f40567331ed4531fab91cd" translate="yes" xml:space="preserve">
          <source>The command loop shows the list of subcommands available, and gives a prompt &quot;What now&amp;gt; &quot;. In general, when the prompt ends with a single &lt;code&gt;&amp;gt;&lt;/code&gt;, you can pick only one of the choices given and type return, like this:</source>
          <target state="translated">命令循环显示可用的子命令列表，并提示&amp;ldquo; What now&amp;gt;&amp;rdquo;。通常，当提示以单个 &lt;code&gt;&amp;gt;&lt;/code&gt; 结束时，您只能选择给定的选项之一并键入return，如下所示：</target>
        </trans-unit>
        <trans-unit id="653e31d7d7203bdc451cd54eed957012f41434d3" translate="yes" xml:space="preserve">
          <source>The command refuses to process new mailboxes until the current operation is finished, so if you decide to start over from scratch, run &lt;code&gt;git am --abort&lt;/code&gt; before running the command with mailbox names.</source>
          <target state="translated">该命令将拒绝处理新的邮箱，直到当前操作完成为止，因此，如果您决定从头开始， &lt;code&gt;git am --abort&lt;/code&gt; 在运行带有邮箱名称的命令之前运行git am --abort。</target>
        </trans-unit>
        <trans-unit id="024617064e80c5362385868f7a76ff908e5b8451" translate="yes" xml:space="preserve">
          <source>The command removes only the paths that are known to Git.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc41d8aed51eb71b1c7af7000815eb2a4b359d3" translate="yes" xml:space="preserve">
          <source>The command stream is terminated by a blank line. In some cases (indicated in the documentation of the relevant commands), this blank line is followed by a payload in some other protocol (e.g., the pack protocol), while in others it indicates the end of input.</source>
          <target state="translated">命令流以空行结束。在某些情况下(在相关命令的文档中说明),这个空行后面是其他协议(如打包协议)中的有效载荷,而在其他情况下,它表示输入的结束。</target>
        </trans-unit>
        <trans-unit id="9f45aa4005fcc34aa135332c57403a61747c3270" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; command to control what is shown and how, and options applicable to the &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; command to control how the changes each commit introduces are shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1cdce0d3b2e7df2146074a7208b9f02c1bab1a7" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git diff-tree&lt;/code&gt; command to control how the changes the commit introduces are shown.</source>
          <target state="translated">该命令采用适用于 &lt;code&gt;git diff-tree&lt;/code&gt; 命令的选项，以控制如何显示提交引入的更改。</target>
        </trans-unit>
        <trans-unit id="35fc48f2de1638c3a16917e24656f5cccec37735" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git log&lt;/code&gt; command to control what is shown and how. See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">该命令采用适用于 &lt;code&gt;git log&lt;/code&gt; 命令的选项来控制显示的内容和方式。参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="704cfc598be528aca39957bda30b48a4e32947ac" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git rev-list&lt;/code&gt; command to control what is shown and how, and options applicable to the &lt;code&gt;git diff-*&lt;/code&gt; commands to control how the changes each commit introduces are shown.</source>
          <target state="translated">该命令具有适用于 &lt;code&gt;git rev-list&lt;/code&gt; 命令的选项以控制显示内容和方式，以及适用于 &lt;code&gt;git diff-*&lt;/code&gt; 命令的选项以控制如何显示每次提交引入的更改。</target>
        </trans-unit>
        <trans-unit id="05dd6533643357a7eb4c0a33aa8aafdf86be046c" translate="yes" xml:space="preserve">
          <source>The command takes various subcommands, and different options depending on the subcommand:</source>
          <target state="translated">该命令采取不同的子命令,根据子命令的不同,选项也不同。</target>
        </trans-unit>
        <trans-unit id="5dfb0879d1b00c6726b4c473489aecee6c7360c1" translate="yes" xml:space="preserve">
          <source>The command that the diff driver should call to generate the text-converted version of a file. The result of the conversion is used to generate a human-readable diff. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff驱动程序应调用该命令以生成文件的文本转换版本。转换结果用于生成人类可读的差异。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76561fd073c2b7875043b506e4a6c918bbf27fef" translate="yes" xml:space="preserve">
          <source>The command usually removes loose refs under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; hierarchy after packing them. This option tells it not to.</source>
          <target state="translated">打包后，该命令通常会删除 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 层次结构下的松散引用。此选项告诉它不这样做。</target>
        </trans-unit>
        <trans-unit id="77170493947dd63f2044149c05ae4eb27dc0d118" translate="yes" xml:space="preserve">
          <source>The command usually shows percentage progress. This flag suppresses it.</source>
          <target state="translated">该命令通常显示进度百分比。此标志将抑制它的显示。</target>
        </trans-unit>
        <trans-unit id="3df5350b5d92a4c7df677ed19aeefaf4fd05338a" translate="yes" xml:space="preserve">
          <source>The command which is used to convert the content of a blob object to a worktree file upon checkout. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">签出后用于将blob对象的内容转换为工作树文件的命令。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e78c7e2042e4de22f48dc29ab38867e1c8242106" translate="yes" xml:space="preserve">
          <source>The command which is used to convert the content of a worktree file to a blob upon checkin. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">该命令用于在签入时将工作树文件的内容转换为Blob。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a6711f072ffccd6a7948d8fcfc289d0284bd97d1" translate="yes" xml:space="preserve">
          <source>The command will only rewrite the &lt;code&gt;positive&lt;/code&gt; refs mentioned in the command line (e.g. if you pass &lt;code&gt;a..b&lt;/code&gt;, only &lt;code&gt;b&lt;/code&gt; will be rewritten). If you specify no filters, the commits will be recommitted without any changes, which would normally have no effect. Nevertheless, this may be useful in the future for compensating for some Git bugs or such, therefore such a usage is permitted.</source>
          <target state="translated">该命令将仅重写命令行中提到的 &lt;code&gt;positive&lt;/code&gt; 引用（例如，如果传递 &lt;code&gt;a..b&lt;/code&gt; ，则仅 &lt;code&gt;b&lt;/code&gt; 将被重写）。如果您未指定任何过滤器，则将重新提交提交而无需进行任何更改，这通常是无效的。不过，这在将来可能会用于补偿某些Git漏洞等，因此是允许的。</target>
        </trans-unit>
        <trans-unit id="6c1d44a42d537aa236fa8b0c18f8ebc1e0d665b8" translate="yes" xml:space="preserve">
          <source>The command writes the commit object name of the common ancestor to the standard output, so we captured its output to a variable, because we will be using it in the next step. By the way, the common ancestor commit is the &quot;Initial commit&quot; commit in this case. You can tell it by:</source>
          <target state="translated">该命令将共同祖先的提交对象名称写入标准输出,所以我们将其输出捕获到一个变量中,因为我们将在下一步使用它。顺便说一下,在本例中,共同祖先提交是 &quot;初始提交 &quot;提交。你可以通过以下方式来判断。</target>
        </trans-unit>
        <trans-unit id="277f50b8984fb8f1e24e58a015e232c719b0136b" translate="yes" xml:space="preserve">
          <source>The command&amp;rsquo;s second form creates a new branch head named &amp;lt;branchname&amp;gt; which points to the current &lt;code&gt;HEAD&lt;/code&gt;, or &amp;lt;start-point&amp;gt; if given. As a special case, for &amp;lt;start-point&amp;gt;, you may use &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; as a shortcut for the merge base of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; if there is exactly one merge base. You can leave out at most one of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, in which case it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">该命令的第二种形式创建一个名为&amp;lt;branchname&amp;gt;的新分支头，该分支头指向当前 &lt;code&gt;HEAD&lt;/code&gt; 或&amp;lt;start-point&amp;gt;（如果给定）。作为一种特殊情况，对于&amp;lt;start-point&amp;gt;，如果存在一个合并基数，则可以使用 &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; 作为 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 合并基数的快捷方式。您最多可以忽略 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 之一，在这种情况下，默认为 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0384db43c537c0cba33bbce02fa39c058435bd6c" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude-from=&amp;lt;file&amp;gt; specifies a file containing a list of patterns. Patterns are ordered in the same order they appear in the file.</source>
          <target state="translated">命令行标志--exclude-from = &amp;lt;file&amp;gt;指定包含模式列表的文件。模式按它们在文件中出现的顺序排列。</target>
        </trans-unit>
        <trans-unit id="84de3c7a7b3ba54b91bb57a464ea60b526231897" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude-per-directory=&amp;lt;name&amp;gt; specifies a name of the file in each directory &lt;code&gt;git ls-files&lt;/code&gt; examines, normally &lt;code&gt;.gitignore&lt;/code&gt;. Files in deeper directories take precedence. Patterns are ordered in the same order they appear in the files.</source>
          <target state="translated">命令行标志--exclude-per-directory = &amp;lt;名称&amp;gt;指定 &lt;code&gt;git ls-files&lt;/code&gt; 检查的每个目录中文件的名称，通常为 &lt;code&gt;.gitignore&lt;/code&gt; 。较深目录中的文件优先。模式按它们在文件中出现的顺序排列。</target>
        </trans-unit>
        <trans-unit id="de25d36c95ea6a374c3001c57d5c8bbae6052f57" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude=&amp;lt;pattern&amp;gt; specifies a single pattern. Patterns are ordered in the same order they appear in the command line.</source>
          <target state="translated">命令行标志--exclude = &amp;lt;pattern&amp;gt;指定单个模式。模式的排列顺序与它们在命令行中出现的顺序相同。</target>
        </trans-unit>
        <trans-unit id="57163e2560363b464673a4a43dc95a7ad9f9ef3b" translate="yes" xml:space="preserve">
          <source>The commit &quot;D&quot; is called a &quot;merge base&quot; for branch &quot;main&quot; and &quot;dev&quot; because it&amp;rsquo;s the best common ancestor for these branches for a merge.</source>
          <target state="translated">提交&amp;ldquo; D&amp;rdquo;被称为分支&amp;ldquo; main&amp;rdquo;和&amp;ldquo; dev&amp;rdquo;的&amp;ldquo;合并基础&amp;rdquo;，因为它是这些分支进行合并的最佳共同祖先。</target>
        </trans-unit>
        <trans-unit id="f185c14cbc82f3e4dae044b7f66a7608424887fa" translate="yes" xml:space="preserve">
          <source>The commit author name is taken from the &quot;From: &quot; line of the message, and commit author date is taken from the &quot;Date: &quot; line of the message. The &quot;Subject: &quot; line is used as the title of the commit, after stripping common prefix &quot;[PATCH &amp;lt;anything&amp;gt;]&quot;. The &quot;Subject: &quot; line is supposed to concisely describe what the commit is about in one line of text.</source>
          <target state="translated">提交作者的姓名来自消息的&amp;ldquo;发件人：&amp;rdquo;行，提交作者的日期来自消息的&amp;ldquo;日期：&amp;rdquo;行。除去公共前缀&amp;ldquo; [PATCH &amp;lt;任何内容&amp;gt;]&amp;rdquo;后，&amp;ldquo;主题：&amp;rdquo;行用作提交的标题。&amp;ldquo; Subject：&amp;rdquo;行应该简洁地描述一行文本中的提交内容。</target>
        </trans-unit>
        <trans-unit id="2f12acdb07fb960bc2fd1e07b27cc4a2b35ad054" translate="yes" xml:space="preserve">
          <source>The commit list format can be changed by setting the configuration option rebase.instructionFormat. A customized instruction format will automatically have the long commit hash prepended to the format.</source>
          <target state="translated">提交列表格式可以通过设置配置选项 rebase.instructionFormat 来改变。自定义的指令格式会自动在格式前加上长的提交哈希。</target>
        </trans-unit>
        <trans-unit id="56b4186deed0365516ca63a760921d1d85d5abd6" translate="yes" xml:space="preserve">
          <source>The commit log message extracted from e-mail, usually except the title line which comes from e-mail Subject.</source>
          <target state="translated">从电子邮件中提取的提交日志信息,通常除了标题行来自电子邮件主题外。</target>
        </trans-unit>
        <trans-unit id="448543278984728d32d400e55fc12701ecc9668d" translate="yes" xml:space="preserve">
          <source>The commit log message, author name and author email are taken from the e-mail, and after minimally decoding MIME transfer encoding, re-coded in the charset specified by i18n.commitencoding (defaulting to UTF-8) by transliterating them. This used to be optional but now it is the default.</source>
          <target state="translated">提交日志信息、作者姓名和作者邮件是从邮件中提取的,经过最小化的 MIME 传输编码解码后,用 i18n.commitencoding 指定的字符集(默认为 UTF-8)进行转写。这在过去是可选的,但现在是默认的。</target>
        </trans-unit>
        <trans-unit id="682ec5a16062666d3ac4c15995f4c320f0569ce3" translate="yes" xml:space="preserve">
          <source>The commit message is formed by the title taken from the &quot;Subject: &quot;, a blank line and the body of the message up to where the patch begins. Excess whitespace at the end of each line is automatically stripped.</source>
          <target state="translated">提交消息是由 &quot;Subject.&quot;中的标题、空行和消息的正文组成,直到补丁开始的地方。&quot;主题 &quot;中的标题、空行和消息的正文,直到补丁开始的地方。每行末尾多余的空白会被自动删除。</target>
        </trans-unit>
        <trans-unit id="9d14a63335261988fcede52b815289c8a87983a5" translate="yes" xml:space="preserve">
          <source>The commit message is supplied either directly with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option, or indirectly from the tag or commit when the second tree-ish denotes such an object, or it is requested by invoking an editor (see &lt;code&gt;--edit&lt;/code&gt; option below).</source>
          <target state="translated">提交消息可以通过 &lt;code&gt;-m&lt;/code&gt; 或 &lt;code&gt;-F&lt;/code&gt; 选项直接提供，或者在第二个树状结构表示此类对象或通过调用编辑器进行请求时间接从标记或提交中提供（请参见下面的 &lt;code&gt;--edit&lt;/code&gt; 选项） 。</target>
        </trans-unit>
        <trans-unit id="50413d61f19e8e0d39eb4098c01c599c7c407f25" translate="yes" xml:space="preserve">
          <source>The commit object names shown above would be different for you, but they should match the HEAD commit object names of your repositories. You can check it by running &lt;code&gt;git ls-remote ../a&lt;/code&gt;.</source>
          <target state="translated">上面显示的提交对象名称对您而言将有所不同，但它们应与存储库的HEAD提交对象名称匹配。您可以通过运行 &lt;code&gt;git ls-remote ../a&lt;/code&gt; 进行检查。</target>
        </trans-unit>
        <trans-unit id="8b7bb35b4ae403135d95400938252724b91ca0d2" translate="yes" xml:space="preserve">
          <source>The commit objects record the encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user. For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in &lt;code&gt;X&lt;/code&gt; and we are outputting in &lt;code&gt;X&lt;/code&gt;, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output.</source>
          <target state="translated">提交对象在其编码标头中记录用于日志消息的编码。此选项可用于告诉命令以用户首选的编码方式重新编码提交日志消息。对于非管道命令，此默认为UTF-8。注意，如果一个对象声称要用 &lt;code&gt;X&lt;/code&gt; 编码并且我们要用 &lt;code&gt;X&lt;/code&gt; 输出，我们将逐字输出该对象；这意味着可以将原始提交中的无效序列复制到输出中。</target>
        </trans-unit>
        <trans-unit id="8a40378090f508382eab3e21e0b4382b3bab0ad4" translate="yes" xml:space="preserve">
          <source>The commit, equivalent to what other systems call a &quot;changeset&quot; or &quot;version&quot;, represents a step in the project&amp;rsquo;s history, and each parent represents an immediately preceding step. Commits with more than one parent represent merges of independent lines of development.</source>
          <target state="translated">提交与其他系统称为&amp;ldquo;变更集&amp;rdquo;或&amp;ldquo;版本&amp;rdquo;的提交等效，表示项目历史记录中的一个步骤，每个父级表示紧接的前一个步骤。与多个父代的提交代表了独立开发线的合并。</target>
        </trans-unit>
        <trans-unit id="7d3d64efc4f4511458592fa6c8a58dcfb8579da7" translate="yes" xml:space="preserve">
          <source>The commits are guaranteed to be listed in the order that they were processed by rebase.</source>
          <target state="translated">保证按照Rebase处理的顺序列出提交的内容。</target>
        </trans-unit>
        <trans-unit id="00a94582df69c83885533dbdc944c957c3a549e0" translate="yes" xml:space="preserve">
          <source>The commits marked with &lt;code&gt;*&lt;/code&gt; touch the same area in the same file; you need to resolve the conflicts when creating the commit marked with &lt;code&gt;+&lt;/code&gt;. Then you can test the result to make sure your work-in-progress still works with what is in the latest master.</source>
          <target state="translated">标有 &lt;code&gt;*&lt;/code&gt; 的提交触及同一文件中的同一区域；您需要在创建带有 &lt;code&gt;+&lt;/code&gt; 标记的提交时解决冲突。然后，您可以测试结果，以确保您的在制品仍可与最新的母版中的作品一起使用。</target>
        </trans-unit>
        <trans-unit id="a3fd88845d0ae86224cb7a800b3122f1cf56cb03" translate="yes" xml:space="preserve">
          <source>The commits that were previously saved into the temporary area are then reapplied to the current branch, one by one, in order. Note that any commits in HEAD which introduce the same textual changes as a commit in HEAD..&amp;lt;upstream&amp;gt; are omitted (i.e., a patch already accepted upstream with a different commit message or timestamp will be skipped).</source>
          <target state="translated">然后，将先前保存到临时区域中的提交依次重新应用于当前分支。请注意，在HEAD中引入与HEAD .. &amp;lt;upstream&amp;gt;中的提交相同的文本更改的所有提交都将被忽略（即，将跳过上游已接受的具有不同提交消息或时间戳的补丁程序）。</target>
        </trans-unit>
        <trans-unit id="18d247bf08e46b2d89a403ce14a86d7b99503646" translate="yes" xml:space="preserve">
          <source>The complete message in a commit and tag object is &lt;code&gt;contents&lt;/code&gt;. Its first line is &lt;code&gt;contents:subject&lt;/code&gt;, where subject is the concatenation of all lines of the commit message up to the first blank line. The next line is &lt;code&gt;contents:body&lt;/code&gt;, where body is all of the lines after the first blank line. The optional GPG signature is &lt;code&gt;contents:signature&lt;/code&gt;. The first &lt;code&gt;N&lt;/code&gt; lines of the message is obtained using &lt;code&gt;contents:lines=N&lt;/code&gt;. Additionally, the trailers as interpreted by &lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers[1]&lt;/a&gt; are obtained as &lt;code&gt;trailers&lt;/code&gt; (or by using the historical alias &lt;code&gt;contents:trailers&lt;/code&gt;). Non-trailer lines from the trailer block can be omitted with &lt;code&gt;trailers:only&lt;/code&gt;. Whitespace-continuations can be removed from trailers so that each trailer appears on a line by itself with its full content with &lt;code&gt;trailers:unfold&lt;/code&gt;. Both can be used together as &lt;code&gt;trailers:unfold,only&lt;/code&gt;.</source>
          <target state="translated">提交和标记对象中的完整消息为 &lt;code&gt;contents&lt;/code&gt; 。它的第一行是 &lt;code&gt;contents:subject&lt;/code&gt; ，其中subject是提交消息中所有行的连接，直到第一行空白为止。下一行是 &lt;code&gt;contents:body&lt;/code&gt; ，其中body是第一个空白行之后的所有行。可选的GPG签名为 &lt;code&gt;contents:signature&lt;/code&gt; 。使用 &lt;code&gt;contents:lines=N&lt;/code&gt; 获得消息的前 &lt;code&gt;N&lt;/code&gt; 行。另外，由&lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers [1]解释的预告片&lt;/a&gt;可以作为 &lt;code&gt;trailers&lt;/code&gt; 获得（或使用历史别名 &lt;code&gt;contents:trailers&lt;/code&gt; ）。可以使用 &lt;code&gt;trailers:only&lt;/code&gt; 省略来自预告片块的非预告线。可以从预告片中删除空白连续符，以便每个预告片都单独显示在一行中，并且其全部内容与 &lt;code&gt;trailers:unfold&lt;/code&gt; 相同。两者都可以一起用作 &lt;code&gt;trailers:unfold,only&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cfefd9783776d68186cc88921bf5543257f8ee9" translate="yes" xml:space="preserve">
          <source>The complete series produces the same end result as your own (probably much messier!) development process did.</source>
          <target state="translated">完整的系列产生的最终结果和你自己的开发过程一样(可能更乱!)。</target>
        </trans-unit>
        <trans-unit id="94ed81b46eb91e159691e77d6f1f3c669ea0f93b" translate="yes" xml:space="preserve">
          <source>The condition starts with a keyword followed by a colon and some data whose format and meaning depends on the keyword. Supported keywords are:</source>
          <target state="translated">该条件以关键字开始,后面是冒号和一些数据,其格式和含义取决于关键字。支持的关键字有:</target>
        </trans-unit>
        <trans-unit id="b796e8b15faa41177d638a7b320c951a662a1b91" translate="yes" xml:space="preserve">
          <source>The config settings that start with &lt;code&gt;feature.&lt;/code&gt; modify the defaults of a group of other config settings. These groups are created by the Git developer community as recommended defaults and are subject to change. In particular, new config options may be added with different defaults.</source>
          <target state="translated">以 &lt;code&gt;feature.&lt;/code&gt; 开头的配置设置。修改一组其他配置设置的默认值。这些组由Git开发人员社区创建，作为建议的默认值，并且会随时更改。特别是，可以使用不同的默认值添加新的配置选项。</target>
        </trans-unit>
        <trans-unit id="0fd18e355006d4a8cb0ab9547d6ae9db29a772ac" translate="yes" xml:space="preserve">
          <source>The config variable &lt;code&gt;ssh.variant&lt;/code&gt; can be set to override this detection. Valid values are &lt;code&gt;ssh&lt;/code&gt; (to use OpenSSH options), &lt;code&gt;plink&lt;/code&gt;, &lt;code&gt;putty&lt;/code&gt;, &lt;code&gt;tortoiseplink&lt;/code&gt;, &lt;code&gt;simple&lt;/code&gt; (no options except the host and remote command). The default auto-detection can be explicitly requested using the value &lt;code&gt;auto&lt;/code&gt;. Any other value is treated as &lt;code&gt;ssh&lt;/code&gt;. This setting can also be overridden via the environment variable &lt;code&gt;GIT_SSH_VARIANT&lt;/code&gt;.</source>
          <target state="translated">可以将配置变量 &lt;code&gt;ssh.variant&lt;/code&gt; 设置为覆盖此检测。有效值为 &lt;code&gt;ssh&lt;/code&gt; （使用OpenSSH选项）， &lt;code&gt;plink&lt;/code&gt; ， &lt;code&gt;putty&lt;/code&gt; ， &lt;code&gt;tortoiseplink&lt;/code&gt; ， &lt;code&gt;simple&lt;/code&gt; （除host和remote命令外没有其他选项）。可以使用值 &lt;code&gt;auto&lt;/code&gt; 显式请求默认的自动检测。其他任何值均视为 &lt;code&gt;ssh&lt;/code&gt; 。也可以通过环境变量 &lt;code&gt;GIT_SSH_VARIANT&lt;/code&gt; 覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="82dcb1f42fdd78b7a73229a297c6923dd8af63df" translate="yes" xml:space="preserve">
          <source>The configuration file &lt;code&gt;$GIT_DIR/config&lt;/code&gt; in the superproject. Git only recurses into active submodules (see &quot;ACTIVE SUBMODULES&quot; section below).</source>
          <target state="translated">超级项目中的配置文件 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 。Git仅递归到活动子模块中（请参阅下面的&amp;ldquo;活动子模块&amp;rdquo;部分）。</target>
        </trans-unit>
        <trans-unit id="774734ca6d9570e50bffe1b21770dfa34405f67a" translate="yes" xml:space="preserve">
          <source>The configuration file is used to override the default settings that were built into gitweb at the time the &lt;code&gt;gitweb.cgi&lt;/code&gt; script was generated.</source>
          <target state="translated">该配置文件用于覆盖生成 &lt;code&gt;gitweb.cgi&lt;/code&gt; 脚本时内置在gitweb中的默认设置。</target>
        </trans-unit>
        <trans-unit id="b47107ae705aecdb184ade3561dff30a01436bf4" translate="yes" xml:space="preserve">
          <source>The configuration inside the submodule. This includes &lt;code&gt;$GIT_DIR/config&lt;/code&gt; in the submodule, but also settings in the tree such as a &lt;code&gt;.gitattributes&lt;/code&gt; or &lt;code&gt;.gitignore&lt;/code&gt; files that specify behavior of commands inside the submodule.</source>
          <target state="translated">子模块内部的配置。这包括子模块中的 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; ，还包括树中的设置，例如 &lt;code&gt;.gitattributes&lt;/code&gt; 或 &lt;code&gt;.gitignore&lt;/code&gt; 文件，用于指定子模块内部命令的行为。</target>
        </trans-unit>
        <trans-unit id="9f6d6d393008f1bcb3935ac97c688c0c97bcd837" translate="yes" xml:space="preserve">
          <source>The configuration of submodules</source>
          <target state="translated">子模块的配置</target>
        </trans-unit>
        <trans-unit id="386a88f6456b2a92a88834767dd0b8e7846f5609" translate="yes" xml:space="preserve">
          <source>The configuration variables &lt;code&gt;$projects_list_group_categories&lt;/code&gt; and &lt;code&gt;$project_list_default_category&lt;/code&gt; are described in &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;</source>
          <target state="translated">配置变量 &lt;code&gt;$projects_list_group_categories&lt;/code&gt; 和 &lt;code&gt;$project_list_default_category&lt;/code&gt; 在&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt;中描述</target>
        </trans-unit>
        <trans-unit id="7bf08d06e6b6627f964eab6068d66314f0702240" translate="yes" xml:space="preserve">
          <source>The configuration variables are used by both the Git plumbing and the porcelains. The variables are divided into sections, wherein the fully qualified variable name of the variable itself is the last dot-separated segment and the section name is everything before the last dot. The variable names are case-insensitive, allow only alphanumeric characters and &lt;code&gt;-&lt;/code&gt;, and must start with an alphabetic character. Some variables may appear multiple times; we say then that the variable is multivalued.</source>
          <target state="translated">Git管道和瓷器都使用配置变量。变量分为多个部分，其中变量本身的完全限定变量名称是最后一个点分隔的段，而部分名称是最后一个点之前的所有内容。变量名称不区分大小写，仅允许字母数字字符和 &lt;code&gt;-&lt;/code&gt; ，并且必须以字母字符开头。有些变量可能会出现多次；那么我们说变量是多值的。</target>
        </trans-unit>
        <trans-unit id="9ba005fddfd40c1aca4a3afcc24f0bfe0be0d141" translate="yes" xml:space="preserve">
          <source>The configuration variables described below configure some of gitweb links: their target and their look (text or image), and where to find page prerequisites (stylesheet, favicon, images, scripts). Usually they are left at their default values, with the possible exception of &lt;code&gt;@stylesheets&lt;/code&gt; variable.</source>
          <target state="translated">下文描述的配置变量配置了一些gitweb链接：它们的目标和外观（文本或图像），以及在哪里可以找到页面先决条件（样式表，图标，图像，脚本）。通常，它们保留其默认值， &lt;code&gt;@stylesheets&lt;/code&gt; 变量可能除外。</target>
        </trans-unit>
        <trans-unit id="352cabf788111a2af3c96521f974380812252a38" translate="yes" xml:space="preserve">
          <source>The configuration variables described below control how gitweb finds Git repositories, and how repositories are displayed and accessed.</source>
          <target state="translated">下面描述的配置变量控制着gitweb如何找到Git仓库,以及如何显示和访问仓库。</target>
        </trans-unit>
        <trans-unit id="3f43fd6b4f50ff73ead39001e9e7b24eaf91129d" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;@{-&amp;lt;n&amp;gt;}&lt;/code&gt; means the &amp;lt;n&amp;gt;th branch/commit checked out before the current one.</source>
          <target state="translated">构造 &lt;code&gt;@{-&amp;lt;n&amp;gt;}&lt;/code&gt; 表示在当前分支之前签出的第&amp;lt;n&amp;gt;个分支/提交。</target>
        </trans-unit>
        <trans-unit id="532c17d263ea0447251201d507a716aaf6f28f2e" translate="yes" xml:space="preserve">
          <source>The content to be committed can be specified in several ways:</source>
          <target state="translated">可以通过多种方式指定要提交的内容。</target>
        </trans-unit>
        <trans-unit id="a3c1db69a05b050bddfd156a5df9e51b55df4af8" translate="yes" xml:space="preserve">
          <source>The contents of the actual line is output after the above header, prefixed by a TAB. This is to allow adding more header elements later.</source>
          <target state="translated">实际行的内容是在上述头之后输出的,前面加一个TAB。这是为了以后可以添加更多的头元素。</target>
        </trans-unit>
        <trans-unit id="07ff8c430a66890255703acd59c46fb9590b9dc8" translate="yes" xml:space="preserve">
          <source>The contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level.</source>
          <target state="translated">blob对象的内容是未被解释的字节序列。在核心层没有编码转换。</target>
        </trans-unit>
        <trans-unit id="1b5efb2fc6b2c2f5d21112887ebec33fa1322cd1" translate="yes" xml:space="preserve">
          <source>The contents of the included file are inserted immediately, as if they had been found at the location of the include directive. If the value of the variable is a relative path, the path is considered to be relative to the configuration file in which the include directive was found. See below for examples.</source>
          <target state="translated">包含的文件内容会被立即插入,就像它们是在include指令的位置被找到的一样。如果变量的值是一个相对路径,那么这个路径被认为是相对于包含指令所在的配置文件的。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="8e2acace54c1bc95e05b068c1615156bf7369b0d" translate="yes" xml:space="preserve">
          <source>The core Git is often called &quot;plumbing&quot;, with the prettier user interfaces on top of it called &quot;porcelain&quot;. You may not want to use the plumbing directly very often, but it can be good to know what the plumbing does when the porcelain isn&amp;rsquo;t flushing.</source>
          <target state="translated">核心Git通常称为&amp;ldquo;管道&amp;rdquo;，其上的更漂亮的用户界面称为&amp;ldquo;瓷器&amp;rdquo;。您可能不希望经常直接使用管道，但是最好知道不冲洗瓷器时管道的作用。</target>
        </trans-unit>
        <trans-unit id="bdff9728a51893f686262a6a471251953f8ca49c" translate="yes" xml:space="preserve">
          <source>The core.multiPackIndex config setting must be on to consume MIDX files.</source>
          <target state="translated">core.multiPackIndex配置设置必须开启才能消耗MIDX文件。</target>
        </trans-unit>
        <trans-unit id="4fd34d18ba310e6b91e875c3fcf517fe13b68829" translate="yes" xml:space="preserve">
          <source>The cost matrix is populated thusly: for each pair of commits, both diffs are generated and the &quot;diff of diffs&quot; is generated, with 3 context lines, then the number of lines in that diff is used as cost.</source>
          <target state="translated">成本矩阵是这样填充的:对于每一对提交,都会生成两个diff,并生成 &quot;diff的diff&quot;,其中有3个上下文行,那么该diff的行数就作为成本。</target>
        </trans-unit>
        <trans-unit id="588bd7a488f6b8b596aae7dca46a3809b4412eb0" translate="yes" xml:space="preserve">
          <source>The cost of an edge &lt;code&gt;o--C&lt;/code&gt; is the size of &lt;code&gt;C&lt;/code&gt;'s diff, modified by a fudge factor that should be smaller than 100%. The cost of an edge &lt;code&gt;o--o&lt;/code&gt; is free. The fudge factor is necessary because even if &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have nothing in common, they may still share a few empty lines and such, possibly making the assignment &lt;code&gt;1--C&lt;/code&gt;, &lt;code&gt;o--o&lt;/code&gt; slightly cheaper than &lt;code&gt;1--o&lt;/code&gt;, &lt;code&gt;o--C&lt;/code&gt; even if &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have nothing in common. With the fudge factor we require a much larger common part to consider patches as corresponding.</source>
          <target state="translated">边缘 &lt;code&gt;o--C&lt;/code&gt; 的成本是 &lt;code&gt;C&lt;/code&gt; 的diff 的大小，并通过应小于100％的软化系数进行修改。边缘 &lt;code&gt;o--o&lt;/code&gt; 的成本是免费的。忽悠系数是必要的，因为即使 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 没有共同点，它们仍可能共享一些空行，因此，可能使分配 &lt;code&gt;1--C&lt;/code&gt; ， &lt;code&gt;o--o&lt;/code&gt; 比 &lt;code&gt;1--o&lt;/code&gt; ， &lt;code&gt;o--C&lt;/code&gt; 便宜-C即使 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 没有共同点。有了软糖因素，我们需要一个更大的公用部分，才能将补丁视为相应的补丁。</target>
        </trans-unit>
        <trans-unit id="4d1179f527fe5d2769266ab8147ad92b0a56c021" translate="yes" xml:space="preserve">
          <source>The credential is split into a set of named attributes, with one attribute per line. Each attribute is specified by a key-value pair, separated by an &lt;code&gt;=&lt;/code&gt; (equals) sign, followed by a newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1995b336f91a29b5d0cf1cb6bf6d7c2407fa802c" translate="yes" xml:space="preserve">
          <source>The credential is split into a set of named attributes, with one attribute per line. Each attribute is specified by a key-value pair, separated by an &lt;code&gt;=&lt;/code&gt; (equals) sign, followed by a newline. The key may contain any bytes except &lt;code&gt;=&lt;/code&gt;, newline, or NUL. The value may contain any bytes except newline or NUL. In both cases, all bytes are treated as-is (i.e., there is no quoting, and one cannot transmit a value with newline or NUL in it). The list of attributes is terminated by a blank line or end-of-file. Git understands the following attributes:</source>
          <target state="translated">凭证分为一组命名属性，每行一个属性。每个属性由键值对指定，并由 &lt;code&gt;=&lt;/code&gt; （等号）分隔，后跟换行符。密钥可以包含除 &lt;code&gt;=&lt;/code&gt; ，换行符或NUL 以外的任何字节。该值可以包含除换行符或NUL之外的任何字节。在这两种情况下，所有字节均按原样处理（即，不加引号，并且不能传输其中包含换行符或NUL的值）。属性列表以空白行或文件结尾终止。Git理解以下属性：</target>
        </trans-unit>
        <trans-unit id="332163de0b53725f6a8fdbb5dfbee2d72f5e952f" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s password, if we are asking it to be stored.</source>
          <target state="translated">凭据的密码（如果我们要求将其存储）。</target>
        </trans-unit>
        <trans-unit id="b2af82f2f4002bb109eae365a3025f169b56089c" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s username, if we already have one (e.g., from a URL, from the user, or from a previously run helper).</source>
          <target state="translated">凭据的用户名（如果已经有）（例如，来自URL，用户或先前运行的帮助程序）。</target>
        </trans-unit>
        <trans-unit id="4208e146b9bfac727faabb9820edc29c027631a0" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s username, if we already have one (e.g., from a URL, the configuration, the user, or from a previously run helper).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327d8af868005c380ff04a569542ec1ad381deca" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. In more detail: Your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is normally derived from the state of the tree referred to by HEAD. HEAD is a reference to one of the &lt;a href=&quot;#def_head&quot;&gt;heads&lt;/a&gt; in your repository, except when using a &lt;a href=&quot;#def_detached_HEAD&quot;&gt;detached HEAD&lt;/a&gt;, in which case it directly references an arbitrary commit.</source>
          <target state="translated">当前&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;。更详细地：您的&lt;a href=&quot;#def_working_tree&quot;&gt;工作树&lt;/a&gt;通常是从HEAD所指的树的状态派生的。HEAD是对的一个参考&lt;a href=&quot;#def_head&quot;&gt;的头&lt;/a&gt;在你的仓库，使用时除外&lt;a href=&quot;#def_detached_HEAD&quot;&gt;分离的头&lt;/a&gt;，在这种情况下，直接引用任意提交。</target>
        </trans-unit>
        <trans-unit id="6a22129f9e2c1c598b41ac7718060a19c57ba2df" translate="yes" xml:space="preserve">
          <source>The current branch and &lt;code&gt;HEAD&lt;/code&gt; pointer stay at the last commit successfully made.</source>
          <target state="translated">当前分支和 &lt;code&gt;HEAD&lt;/code&gt; 指针停留在成功完成的最后一次提交上。</target>
        </trans-unit>
        <trans-unit id="0f49d1c21e2564ca60f22933641a619ec1965bd6" translate="yes" xml:space="preserve">
          <source>The current branch is reset to &amp;lt;upstream&amp;gt;, or &amp;lt;newbase&amp;gt; if the --onto option was supplied. This has the exact same effect as &lt;code&gt;git reset --hard &amp;lt;upstream&amp;gt;&lt;/code&gt; (or &amp;lt;newbase&amp;gt;). ORIG_HEAD is set to point at the tip of the branch before the reset.</source>
          <target state="translated">如果提供了--onto选项，则将当前分支重置为&amp;lt;上游&amp;gt;或&amp;lt;newbase&amp;gt;。这与 &lt;code&gt;git reset --hard &amp;lt;upstream&amp;gt;&lt;/code&gt; （或&amp;lt;newbase&amp;gt;）完全相同。将ORIG_HEAD设置为指向重置之前分支的尖端。</target>
        </trans-unit>
        <trans-unit id="485fe33a04a6d00e71aec5bce139a108011107ac" translate="yes" xml:space="preserve">
          <source>The current command-line parameters used for each variant are as follows:</source>
          <target state="translated">目前各变量使用的命令行参数如下。</target>
        </trans-unit>
        <trans-unit id="f1d20a076d93bfe14eb345a4d54fe76b72904bc4" translate="yes" xml:space="preserve">
          <source>The current index and work tree is derived from $H, but the user may have local changes in them since $H.</source>
          <target state="translated">当前的索引和工作树来自$H,但用户可能会在$H之后对它们进行局部修改。</target>
        </trans-unit>
        <trans-unit id="7bc299cda3bedfdcbabc4a6883d29c81bf74d5df" translate="yes" xml:space="preserve">
          <source>The current index file for the repository. It is usually not found in a bare repository.</source>
          <target state="translated">版本库的当前索引文件。它通常在裸仓库中找不到。</target>
        </trans-unit>
        <trans-unit id="6561295b83003ebae9a9c6ca19e06cdfe7bf9b70" translate="yes" xml:space="preserve">
          <source>The currently defined format versions are:</source>
          <target state="translated">目前定义的格式版本有:</target>
        </trans-unit>
        <trans-unit id="66a8472981ef80b1cce56bd59cf5f4d97c11f9f9" translate="yes" xml:space="preserve">
          <source>The currently supported hooks are described below.</source>
          <target state="translated">目前支持的钩子描述如下。</target>
        </trans-unit>
        <trans-unit id="8715361e5840de7b556e67eacf990927a206b328" translate="yes" xml:space="preserve">
          <source>The custom diff driver command. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">定制diff驱动程序命令。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e530b24daf8e53e45f57000d6a6174670a1f6d2" translate="yes" xml:space="preserve">
          <source>The data content for the file has not been supplied yet. The frontend wants to supply it as part of this modify command.</source>
          <target state="translated">文件的数据内容还没有提供。前台希望将其作为修改命令的一部分来提供。</target>
        </trans-unit>
        <trans-unit id="f92713104ec45ad60b839fa902e6ffedd1e05a41" translate="yes" xml:space="preserve">
          <source>The data content for the file was already supplied by a prior &lt;code&gt;blob&lt;/code&gt; command. The frontend just needs to connect it.</source>
          <target state="translated">该文件的数据内容已由先前的 &lt;code&gt;blob&lt;/code&gt; 命令提供。前端只需要连接它。</target>
        </trans-unit>
        <trans-unit id="abeb69d3d4bae2cc1a5a16e58850f1c93c17369b" translate="yes" xml:space="preserve">
          <source>The data content for the note has not been supplied yet. The frontend wants to supply it as part of this modify command.</source>
          <target state="translated">注释的数据内容还没有提供。前台希望将其作为本次修改命令的一部分来提供。</target>
        </trans-unit>
        <trans-unit id="81c47d0a0bfa5328ac109608aa42a36ac0ca6a45" translate="yes" xml:space="preserve">
          <source>The data content for the note was already supplied by a prior &lt;code&gt;blob&lt;/code&gt; command. The frontend just needs to connect it to the commit that is to be annotated.</source>
          <target state="translated">注释的数据内容已由先前的 &lt;code&gt;blob&lt;/code&gt; 命令提供。前端只需要将其连接到要注释的提交即可。</target>
        </trans-unit>
        <trans-unit id="d1c68865b9a230a071410342b903f7a0e48271ba" translate="yes" xml:space="preserve">
          <source>The data that follows the keyword &lt;code&gt;gitdir:&lt;/code&gt; is used as a glob pattern. If the location of the .git directory matches the pattern, the include condition is met.</source>
          <target state="translated">关键字 &lt;code&gt;gitdir:&lt;/code&gt; 之后的数据用作全局模式。如果.git目录的位置与该模式匹配，则满足包含条件。</target>
        </trans-unit>
        <trans-unit id="c1597312d460a92e79d09c37c305ec85acdf7d09" translate="yes" xml:space="preserve">
          <source>The data that follows the keyword &lt;code&gt;onbranch:&lt;/code&gt; is taken to be a pattern with standard globbing wildcards and two additional ones, &lt;code&gt;**/&lt;/code&gt; and &lt;code&gt;/**&lt;/code&gt;, that can match multiple path components. If we are in a worktree where the name of the branch that is currently checked out matches the pattern, the include condition is met.</source>
          <target state="translated">关键字 &lt;code&gt;onbranch:&lt;/code&gt; 之后的数据被视为具有标准通配符和另外两个 &lt;code&gt;**/&lt;/code&gt; 和 &lt;code&gt;/**&lt;/code&gt; 的模式，它们可以匹配多个路径分量。如果我们位于当前检出的分支名称与模式匹配的工作树中，则满足包含条件。</target>
        </trans-unit>
        <trans-unit id="7c053d7b296d35ca64db938819dea858103dc6da" translate="yes" xml:space="preserve">
          <source>The data transfer of the packfile is always multiplexed, using the same semantics of the &lt;code&gt;side-band-64k&lt;/code&gt; capability from protocol version 1. This means that each packet, during the packfile data stream, is made up of a leading 4-byte pkt-line length (typical of the pkt-line format), followed by a 1-byte stream code, followed by the actual data.</source>
          <target state="translated">使用协议版本1 的 &lt;code&gt;side-band-64k&lt;/code&gt; 功能的相同语义，总是对packfile的数据传输进行多路复用。这意味着在packfile数据流期间，每个数据包均由前导4字节pkt-行长度（通常是pkt-line格式），然后是1字节流代码，然后是实际数据。</target>
        </trans-unit>
        <trans-unit id="c2900c14cd751c2ba06b33eb8d53cbdb905b94a4" translate="yes" xml:space="preserve">
          <source>The database cannot be reliably regenerated in a consistent form after the branch it is tracking has changed. Example: For merged branches, &lt;code&gt;git-cvsserver&lt;/code&gt; only tracks one branch of development, and after a &lt;code&gt;git merge&lt;/code&gt; an incrementally updated database may track a different branch than a database regenerated from scratch, causing inconsistent CVS revision numbers. &lt;code&gt;git-cvsserver&lt;/code&gt; has no way of knowing which branch it would have picked if it had been run incrementally pre-merge. So if you have to fully or partially (from old backup) regenerate the database, you should be suspicious of pre-existing CVS sandboxes.</source>
          <target state="translated">跟踪的分支已更改后，无法以一致的形式可靠地重新生成数据库。示例：对于合并的分支， &lt;code&gt;git-cvsserver&lt;/code&gt; 仅跟踪开发的一个分支，并且在 &lt;code&gt;git merge&lt;/code&gt; ，增量更新的数据库可能会跟踪与从头开始重新生成的数据库不同的分支，从而导致不一致的CVS版本号。 &lt;code&gt;git-cvsserver&lt;/code&gt; 无法知道如果在合并前以增量方式运行它将选择哪个分支。因此，如果您必须全部或部分（从旧备份中）重新生成数据库，则应该对预先存在的CVS沙箱感到怀疑。</target>
        </trans-unit>
        <trans-unit id="44d2a77b29a1133933d2693560e181324cc0bf34" translate="yes" xml:space="preserve">
          <source>The database has an object whose hash doesn&amp;rsquo;t match the object database value. This indicates a serious data integrity problem.</source>
          <target state="translated">数据库中有一个对象，其哈希值与对象数据库的值不匹配。这表明存在严重的数据完整性问题。</target>
        </trans-unit>
        <trans-unit id="9944b3cc77c01bf0f8e3a227e6281fac295bdf59" translate="yes" xml:space="preserve">
          <source>The date used for the author identity when creating commit or tag objects, or when writing reflogs. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for valid formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2821bcf3a61c45db1fdab7123e1f2d0deeb254" translate="yes" xml:space="preserve">
          <source>The date used for the committer identity when creating commit or tag objects, or when writing reflogs. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for valid formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28234e35fb4524e90d740d3154dc66c02cb1f7a2" translate="yes" xml:space="preserve">
          <source>The default &amp;lt;ref&amp;gt; is &quot;master&quot;.</source>
          <target state="translated">默认的&amp;lt;ref&amp;gt;是&amp;ldquo; master&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c033f0ddddff0b7a496ef058316bfe1c29b59dcb" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge. If the upstream branch of 'A' is 'origin/B' sometimes we say &quot;'A' is tracking 'origin/B'&quot;.</source>
          <target state="translated">合并到所讨论的分支中的默认&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;（或所讨论的分支被重新建立为基础）。它是通过branch。&amp;lt;name&amp;gt; .remote和branch。&amp;lt;name&amp;gt; .merge配置的。如果'A'的上游分支是'origin / B'，有时我们说&amp;ldquo;'A'正在跟踪'origin / B'&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0e2c938aad423666052c9b862a31c7bd282b15cb" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge. If the upstream branch of &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;origin/B&lt;/code&gt; sometimes we say &quot;&lt;code&gt;A&lt;/code&gt; is tracking &lt;code&gt;origin/B&lt;/code&gt;&quot;.</source>
          <target state="translated">合并到所讨论的分支中的默认&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;（或所讨论的分支被重新建立为基础）。它是通过branch。&amp;lt;name&amp;gt; .remote和branch。&amp;lt;name&amp;gt; .merge配置的。如果 &lt;code&gt;A&lt;/code&gt; 的上游分支是 &lt;code&gt;origin/B&lt;/code&gt; 有时我们会说&amp;ldquo; &lt;code&gt;A&lt;/code&gt; 正在跟踪 &lt;code&gt;origin/B&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2a57474834373f0012a2eee4dc03542456f6b683" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;applypatch-msg&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;commit-msg&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">启用后，默认的 &lt;code&gt;applypatch-msg&lt;/code&gt; 挂钩将运行 &lt;code&gt;commit-msg&lt;/code&gt; 挂钩（如果已启用）。</target>
        </trans-unit>
        <trans-unit id="1004092b458b148233da1997202a081689268a8e" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;commit-msg&lt;/code&gt; hook, when enabled, detects duplicate &quot;Signed-off-by&quot; lines, and aborts the commit if one is found.</source>
          <target state="translated">默认的 &lt;code&gt;commit-msg&lt;/code&gt; 挂钩启用后，会检测到重复的&amp;ldquo; Signed-by-by&amp;rdquo;行，如果找到则中止提交。</target>
        </trans-unit>
        <trans-unit id="54e7a2ab7a7ead4c100931e31ff4408636c3868d" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;post-receive&lt;/code&gt; hook is empty, but there is a sample script &lt;code&gt;post-receive-email&lt;/code&gt; provided in the &lt;code&gt;contrib/hooks&lt;/code&gt; directory in Git distribution, which implements sending commit emails.</source>
          <target state="translated">默认的 &lt;code&gt;post-receive&lt;/code&gt; 钩子为空，但是Git发行版的 &lt;code&gt;contrib/hooks&lt;/code&gt; 目录中提供了一个示例脚本 &lt;code&gt;post-receive-email&lt;/code&gt; ，该脚本实现了发送提交电子邮件。</target>
        </trans-unit>
        <trans-unit id="a71e842d9eb90ca6731ba585809c1f8c19eb80f6" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-applypatch&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;pre-commit&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">如果启用了默认的 &lt;code&gt;pre-applypatch&lt;/code&gt; 挂钩，则它将运行 &lt;code&gt;pre-commit&lt;/code&gt; 挂钩（如果已启用）。</target>
        </trans-unit>
        <trans-unit id="b4266565542333c335464dc9285134a4a9b31011" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-commit&lt;/code&gt; hook, when enabled&amp;mdash;​and with the &lt;code&gt;hooks.allownonascii&lt;/code&gt; config option unset or set to false&amp;mdash;​prevents the use of non-ASCII filenames.</source>
          <target state="translated">默认的 &lt;code&gt;pre-commit&lt;/code&gt; 挂钩在 &lt;code&gt;hooks.allownonascii&lt;/code&gt; 时-并且未设置hooks.allownonascii config选项或将其设置为false-防止使用非ASCII文件名。</target>
        </trans-unit>
        <trans-unit id="c591fe93d0021a0c7991225b1a062c31f35ddd16" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-commit&lt;/code&gt; hook, when enabled, catches introduction of lines with trailing whitespaces and aborts the commit when such a line is found.</source>
          <target state="translated">默认的 &lt;code&gt;pre-commit&lt;/code&gt; 钩启用时会捕获带有尾随空格的行的引入，并在找到这样的行时中止提交。</target>
        </trans-unit>
        <trans-unit id="5c24125124251d23fec260bbe8f20bf4ce1ae496" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-merge-commit&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;pre-commit&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">如果启用了默认的 &lt;code&gt;pre-merge-commit&lt;/code&gt; 钩子，那么它将运行 &lt;code&gt;pre-commit&lt;/code&gt; （如果已启用）钩子。</target>
        </trans-unit>
        <trans-unit id="c0f0841a2790ebd8e4684a32dafde265e2735139" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;update&lt;/code&gt; hook, when enabled&amp;mdash;​and with &lt;code&gt;hooks.allowunannotated&lt;/code&gt; config option unset or set to false&amp;mdash;​prevents unannotated tags to be pushed.</source>
          <target state="translated">默认 &lt;code&gt;update&lt;/code&gt; 挂钩在 &lt;code&gt;hooks.allowunannotated&lt;/code&gt; 时以及未设置hooks.allowunannotated config选项或将其设置为false的情况下，将阻止推送未注释的标签。</target>
        </trans-unit>
        <trans-unit id="e99caaee535fa5770d85355802dd91eb002c650f" translate="yes" xml:space="preserve">
          <source>The default behavior of this command when no &amp;lt;refspec&amp;gt; is given can be configured by setting the &lt;code&gt;push&lt;/code&gt; option of the remote, or the &lt;code&gt;push.default&lt;/code&gt; configuration variable.</source>
          <target state="translated">可以通过设置遥控器的 &lt;code&gt;push&lt;/code&gt; 选项或 &lt;code&gt;push.default&lt;/code&gt; 配置变量来配置未给出&amp;lt;refspec&amp;gt;时此命令的默认行为。</target>
        </trans-unit>
        <trans-unit id="04fb2222b71daf513a74198926f20b6eb1c65e53" translate="yes" xml:space="preserve">
          <source>The default can be changed by the &lt;code&gt;commit.cleanup&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">可以通过 &lt;code&gt;commit.cleanup&lt;/code&gt; 配置变量更改默认值（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6d2b951210087bf6a12979c879cea7654da192ce" translate="yes" xml:space="preserve">
          <source>The default can be changed using the status.showUntrackedFiles configuration variable documented in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;git-config&quot;&gt;git-config [1]中&lt;/a&gt;记录的status.showUntrackedFiles配置变量来更改默认值。</target>
        </trans-unit>
        <trans-unit id="f4804356dda86c0d39019920e2a204580a3348e0" translate="yes" xml:space="preserve">
          <source>The default configuration with no configuration file at all may work perfectly well for some installations. Still, a configuration file is useful for customizing or tweaking the behavior of gitweb in many ways, and some optional features will not be present unless explicitly enabled using the configurable &lt;code&gt;%features&lt;/code&gt; variable (see also &quot;Configuring gitweb features&quot; section below).</source>
          <target state="translated">完全没有配置文件的默认配置在某些安装中可能效果很好。尽管如此，配置文件仍然可以通过多种方式用于自定义或调整gitweb的行为，除非使用可配置的 &lt;code&gt;%features&lt;/code&gt; 变量显式启用，否则某些可选功能将不存在（另请参见下面的&amp;ldquo;配置gitweb功能&amp;rdquo;部分）。</target>
        </trans-unit>
        <trans-unit id="ba35598baf99b4759b4ac8e8e152046ad84f4f70" translate="yes" xml:space="preserve">
          <source>The default destination is &lt;code&gt;syslog&lt;/code&gt; if &lt;code&gt;--inetd&lt;/code&gt; or &lt;code&gt;--detach&lt;/code&gt; is specified, otherwise &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">如果指定了 &lt;code&gt;--inetd&lt;/code&gt; 或 &lt;code&gt;--detach&lt;/code&gt; ,则默认目标为 &lt;code&gt;syslog&lt;/code&gt; ，否则为 &lt;code&gt;stderr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08a91820da4ab8ff0557091a83e78baf95e62cbc" translate="yes" xml:space="preserve">
          <source>The default development &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. Whenever you create a Git &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;, a branch named &quot;master&quot; is created, and becomes the active branch. In most cases, this contains the local development, though that is purely by convention and is not required.</source>
          <target state="translated">默认的开发&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;。每当创建Git &lt;a href=&quot;#def_repository&quot;&gt;存储库时&lt;/a&gt;，都会创建一个名为&amp;ldquo; master&amp;rdquo;的分支，并成为活动分支。在大多数情况下，这包含本地开发，尽管这完全是约定的，不是必需的。</target>
        </trans-unit>
        <trans-unit id="9cfb0587d78b80316db2bf990e0689e616d2c4e9" translate="yes" xml:space="preserve">
          <source>The default diff tool to use when &lt;code&gt;--gui&lt;/code&gt; is specified.</source>
          <target state="translated">指定 &lt;code&gt;--gui&lt;/code&gt; 时使用的默认差异工具。</target>
        </trans-unit>
        <trans-unit id="2106f60990b064f5f08c291bb6d584e30eb4aef6" translate="yes" xml:space="preserve">
          <source>The default diff tool to use.</source>
          <target state="translated">默认使用的diff工具。</target>
        </trans-unit>
        <trans-unit id="ef7818a768aaedb1852c90af2f69c6d87d81a9be" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output a signature containing the Git version number. Use this variable to change that default. Set this variable to the empty string (&quot;&quot;) to suppress signature generation.</source>
          <target state="translated">format-patch 的默认值是输出包含 Git 版本号的签名。使用这个变量可以改变这个默认值。将此变量设为空字符串(&quot;&quot;),以抑制生成签名。</target>
        </trans-unit>
        <trans-unit id="04f69f6bfbe685cc6892bfe73707b968c4b7e627" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output files with the &lt;code&gt;[PATCH]&lt;/code&gt; subject prefix. Use this variable to change that prefix.</source>
          <target state="translated">format-patch的默认设置是输出带有 &lt;code&gt;[PATCH]&lt;/code&gt; 主题前缀的文件。使用此变量可以更改该前缀。</target>
        </trans-unit>
        <trans-unit id="9305a301a407a477c0982cd809ad589540305e9b" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output files with the suffix &lt;code&gt;.patch&lt;/code&gt;. Use this variable to change that suffix (make sure to include the dot if you want it).</source>
          <target state="translated">format-patch的默认设置是输出带有后缀 &lt;code&gt;.patch&lt;/code&gt; 的文件。使用此变量可以更改该后缀（如果需要，请确保包含点）。</target>
        </trans-unit>
        <trans-unit id="82f6ff06915abbfaa5bafadf3e71c6515eea8a49" translate="yes" xml:space="preserve">
          <source>The default for the patch directory is patches or the value of the &lt;code&gt;$QUILT_PATCHES&lt;/code&gt; environment variable.</source>
          <target state="translated">修补程序目录的默认值为修补程序或 &lt;code&gt;$QUILT_PATCHES&lt;/code&gt; 环境变量的值。</target>
        </trans-unit>
        <trans-unit id="63e417c4ba57abb65259188be896bb91267bad84" translate="yes" xml:space="preserve">
          <source>The default for the series file is &amp;lt;patches&amp;gt;/series or the value of the &lt;code&gt;$QUILT_SERIES&lt;/code&gt; environment variable.</source>
          <target state="translated">系列文件的默认值为&amp;lt;patches&amp;gt; / series或 &lt;code&gt;$QUILT_SERIES&lt;/code&gt; 环境变量的值。</target>
        </trans-unit>
        <trans-unit id="43b413a4d69c795f1a4cc6e5069d43aa254cba9e" translate="yes" xml:space="preserve">
          <source>The default format does not show what the original said in the conflicting area. You cannot tell how many lines are deleted and replaced with Barbie&amp;rsquo;s remark on your side. The only thing you can tell is that your side wants to say it is hard and you&amp;rsquo;d prefer to go shopping, while the other side wants to claim it is easy.</source>
          <target state="translated">默认格式不显示原件在冲突区域中所说的内容。您无法判断删除了多少行并替换为您旁边的芭比娃娃的言论。您唯一可以说的是，您的一方要说很难，并且您更喜欢去购物，而另一方则想声称这很容易。</target>
        </trans-unit>
        <trans-unit id="2c9ac4b5e02925d5a2242fa228d32b0af91d581b" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;--no-notes&lt;/code&gt;, unless the &lt;code&gt;format.notes&lt;/code&gt; configuration is set.</source>
          <target state="translated">除非设置了 &lt;code&gt;format.notes&lt;/code&gt; 配置，否则默认值为 &lt;code&gt;--no-notes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e210eb7dbec89858b8e72d64e2d379a9aada6a48" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;--no-thread&lt;/code&gt;, unless the &lt;code&gt;format.thread&lt;/code&gt; configuration is set. If &lt;code&gt;--thread&lt;/code&gt; is specified without a style, it defaults to the style specified by &lt;code&gt;format.thread&lt;/code&gt; if any, or else &lt;code&gt;shallow&lt;/code&gt;.</source>
          <target state="translated">除非设置了 &lt;code&gt;format.thread&lt;/code&gt; 配置，否则默认值为 &lt;code&gt;--no-thread&lt;/code&gt; 。如果 &lt;code&gt;--thread&lt;/code&gt; 是一个没有风格的指定，则默认为按指定的样式 &lt;code&gt;format.thread&lt;/code&gt; 如果有的话，否则 &lt;code&gt;shallow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9abe1131612b105426f13be17707662aa8662d23" translate="yes" xml:space="preserve">
          <source>The default is false, except &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; will probe and set core.ignoreCase true if appropriate when the repository is created.</source>
          <target state="translated">缺省值为false，除了&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;或&lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt;将在创建存储库时在适当的情况下探测并设置core.ignoreCase为true。</target>
        </trans-unit>
        <trans-unit id="fcf73b7882b6e3d265136d0071b137412decce56" translate="yes" xml:space="preserve">
          <source>The default is not to print any annotation lines. If no number is given to &lt;code&gt;-n&lt;/code&gt;, only the first line is printed. If the tag is not annotated, the commit message is displayed instead.</source>
          <target state="translated">默认设置是不打印任何注释行。如果 &lt;code&gt;-n&lt;/code&gt; 没有给出数字，则仅打印第一行。如果未注释标签，则显示提交消息。</target>
        </trans-unit>
        <trans-unit id="19baf950afb8f746e54b7299adf6fbd6966f659a" translate="yes" xml:space="preserve">
          <source>The default is to diff against our branch (-2) and the cleanly resolved paths. The option -0 can be given to omit diff output for unmerged entries and just show &quot;Unmerged&quot;.</source>
          <target state="translated">默认情况下,我们会对我们的分支(-2)和干净的解析路径进行比较。选项-0可以用来省略未合并条目的diff输出,只显示 &quot;Unmerged&quot;。</target>
        </trans-unit>
        <trans-unit id="70f152ab57d660d365ae81763277f72b2d86f307" translate="yes" xml:space="preserve">
          <source>The default is true (when core.filemode is not specified in the config file).</source>
          <target state="translated">默认为true(当配置文件中没有指定core.filemode时)。</target>
        </trans-unit>
        <trans-unit id="03228e9bc81b32ffbccac2430f1d794dd7591d2a" translate="yes" xml:space="preserve">
          <source>The default is true, except &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; will probe and set core.symlinks false if appropriate when the repository is created.</source>
          <target state="translated">缺省值为true，除了&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;或&lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt;将探测并设置core.symlinks为false时（如果创建存储库）。</target>
        </trans-unit>
        <trans-unit id="72445c1104c1c11ef748913a9c6e570e5a73c947" translate="yes" xml:space="preserve">
          <source>The default location of the CVS checkout to use for the export.</source>
          <target state="translated">用于导出的CVS结账的默认位置。</target>
        </trans-unit>
        <trans-unit id="116262510e324641581bf8e5fe54c44cc1ec58f5" translate="yes" xml:space="preserve">
          <source>The default merge strategy to use when pulling a single branch.</source>
          <target state="translated">拉取单个分支时默认使用的合并策略。</target>
        </trans-unit>
        <trans-unit id="a808540aa8de08b00cb350dbc14ab54e33fa8faf" translate="yes" xml:space="preserve">
          <source>The default merge strategy to use when pulling multiple branches at once.</source>
          <target state="translated">当同时拉取多个分支时,默认使用的合并策略。</target>
        </trans-unit>
        <trans-unit id="e2e648395119cc70a2e9e998b6f3d4c60294fc12" translate="yes" xml:space="preserve">
          <source>The default mode for format-patch to determine which parts of the cover letter will be populated using the branch&amp;rsquo;s description. See the &lt;code&gt;--cover-from-description&lt;/code&gt; option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">format-patch的默认模式，用于确定使用分支的说明填充求职信的哪些部分。请参阅&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]中&lt;/a&gt;的 &lt;code&gt;--cover-from-description&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="063faead523251f77be0529092965c3429cc8003" translate="yes" xml:space="preserve">
          <source>The default module path for &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; to use instead of /usr/lib/apache2/modules. Only used if httpd is Apache.</source>
          <target state="translated">&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;代替/ usr / lib / apache2 / modules使用的默认模块路径。仅当httpd是Apache时使用。</target>
        </trans-unit>
        <trans-unit id="91f8aff2bf27bb7f60525104a4a75d78c7ffe52b" translate="yes" xml:space="preserve">
          <source>The default notes merge strategy is &quot;manual&quot;, which checks out conflicting notes in a special work tree for resolving notes conflicts (&lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt;), and instructs the user to resolve the conflicts in that work tree. When done, the user can either finalize the merge with &lt;code&gt;git notes merge --commit&lt;/code&gt;, or abort the merge with &lt;code&gt;git notes merge --abort&lt;/code&gt;.</source>
          <target state="translated">默认的便笺合并策略是&amp;ldquo;手动&amp;rdquo;，它在特殊的工作树中检出冲突的便笺以解决便笺冲突（ &lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt; ），并指示用户解决该工作树中的冲突。完成后，用户可以使用 &lt;code&gt;git notes merge --commit&lt;/code&gt; 最终确定合并，也可以使用git notes merge --abort中止 &lt;code&gt;git notes merge --abort&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d49acb565d9b642605b0a997d7ebc3213ecdde25" translate="yes" xml:space="preserve">
          <source>The default pretty format for log/show/whatchanged command, See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;.</source>
          <target state="translated">log / show / whatchanged命令的默认漂亮格式，请参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;，&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;，&lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c642123af45071133c151f29614b42c5bfc1ffac" translate="yes" xml:space="preserve">
          <source>The default program to execute on the remote side when fetching. See option --upload-pack of &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt;.</source>
          <target state="translated">提取时在远程端执行的默认程序。参见&lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]的&lt;/a&gt; --upload-pack选项。</target>
        </trans-unit>
        <trans-unit id="02bc1378d0d05db5e7ff2ca7062e80f4098e5579" translate="yes" xml:space="preserve">
          <source>The default program to execute on the remote side when pushing. See option --receive-pack of &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">推送时要在远程执行的默认程序。参见选项--receive-pack的&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1520b8813a02e6817b17665a2200c8c1eb73489c" translate="yes" xml:space="preserve">
          <source>The default remote is the remote of the remote-tracking branch of the current branch. If no such remote-tracking branch exists or the HEAD is detached, &quot;origin&quot; is assumed to be the default remote. If the superproject doesn&amp;rsquo;t have a default remote configured the superproject is its own authoritative upstream and the current working directory is used instead.</source>
          <target state="translated">默认远程是当前分支的远程跟踪分支的远程。如果不存在这样的远程跟踪分支或HEAD被分离，则将&amp;ldquo;源&amp;rdquo;假定为默认远程。如果超级项目没有配置默认远程，则超级项目是其自己的权威上游，而使用当前的工作目录。</target>
        </trans-unit>
        <trans-unit id="0d78370864f4fde80869e4efb080139612c8d161" translate="yes" xml:space="preserve">
          <source>The default set of &quot;refspec&quot; for &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;的默认&amp;ldquo; refspec&amp;rdquo;集。参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e7461b63dbe3a9bd4be74e77260f6121d70becf" translate="yes" xml:space="preserve">
          <source>The default set of &quot;refspec&quot; for &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;的默认&amp;ldquo; refspec&amp;rdquo;集。参见&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b1d55965a766c32086046542d13a0c5cafb5d20" translate="yes" xml:space="preserve">
          <source>The default set of branches for &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;. See &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt;的默认分支集。参见&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f8a6ecfdcb232e0e35afa31c75a9bb76e3ba014" translate="yes" xml:space="preserve">
          <source>The default template directory includes some directory structure, suggested &quot;exclude patterns&quot; (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), and sample hook files.</source>
          <target state="translated">默认的模板目录包括一些目录结构，建议的&amp;ldquo;排除模式&amp;rdquo;（请参阅&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;）和示例挂钩文件。</target>
        </trans-unit>
        <trans-unit id="5c5dda91be7317473d73b4f4f28156d762d8905f" translate="yes" xml:space="preserve">
          <source>The default threading style for &lt;code&gt;git format-patch&lt;/code&gt;. Can be a boolean value, or &lt;code&gt;shallow&lt;/code&gt; or &lt;code&gt;deep&lt;/code&gt;. &lt;code&gt;shallow&lt;/code&gt; threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the &lt;code&gt;--in-reply-to&lt;/code&gt;, and the first patch mail, in this order. &lt;code&gt;deep&lt;/code&gt; threading makes every mail a reply to the previous one. A true boolean value is the same as &lt;code&gt;shallow&lt;/code&gt;, and a false value disables threading.</source>
          <target state="translated">&lt;code&gt;git format-patch&lt;/code&gt; 的默认线程样式。可以是布尔值，也可以是 &lt;code&gt;shallow&lt;/code&gt; 或 &lt;code&gt;deep&lt;/code&gt; 。 &lt;code&gt;shallow&lt;/code&gt; 线程使每个邮件都回复到该系列的 &lt;code&gt;--in-reply-to&lt;/code&gt; ，该标题是从求职信，-in-reply-to和第一个补丁邮件中按此顺序选择的。 &lt;code&gt;deep&lt;/code&gt; 线程使每封邮件都回复上一封邮件。布尔值的真值与 &lt;code&gt;shallow&lt;/code&gt; 值相同，假值的值则禁用线程化。</target>
        </trans-unit>
        <trans-unit id="0eb7f832f6b33a6020eb8629fee287c4b15b4801" translate="yes" xml:space="preserve">
          <source>The default upstream &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. Most projects have at least one upstream project which they track. By default 'origin' is used for that purpose. New upstream updates will be fetched into &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branches&lt;/a&gt; named origin/name-of-upstream-branch, which you can see using &lt;code&gt;git branch -r&lt;/code&gt;.</source>
          <target state="translated">默认的上游&lt;a href=&quot;#def_repository&quot;&gt;存储库&lt;/a&gt;。大多数项目都有至少一个要跟踪的上游项目。默认情况下，&amp;ldquo; origin&amp;rdquo;用于此目的。新的上游更新将被提取到名为origin / of-streamstream-branch的&lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;远程跟踪&lt;/a&gt;分支中，您可以使用 &lt;code&gt;git branch -r&lt;/code&gt; 看到它们。</target>
        </trans-unit>
        <trans-unit id="4f838be44da45fd1828d0b46b391485ccd56187e" translate="yes" xml:space="preserve">
          <source>The default upstream &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. Most projects have at least one upstream project which they track. By default &lt;code&gt;origin&lt;/code&gt; is used for that purpose. New upstream updates will be fetched into &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branches&lt;/a&gt; named origin/name-of-upstream-branch, which you can see using &lt;code&gt;git branch -r&lt;/code&gt;.</source>
          <target state="translated">默认的上游&lt;a href=&quot;#def_repository&quot;&gt;存储库&lt;/a&gt;。大多数项目都有至少一个要跟踪的上游项目。默认情况下， &lt;code&gt;origin&lt;/code&gt; 用于此目的。新的上游更新将被提取到名为origin / of-streamstream-branch的&lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;远程跟踪&lt;/a&gt;分支中，您可以使用 &lt;code&gt;git branch -r&lt;/code&gt; 看到它们。</target>
        </trans-unit>
        <trans-unit id="66087a54aa582dff2f539d6f92ec2461ac3012fd" translate="yes" xml:space="preserve">
          <source>The default value for --window is 10 and --depth is 50. The maximum depth is 4095.</source>
          <target state="translated">--window的默认值是10,-depth的默认值是50。最大深度为4095。</target>
        </trans-unit>
        <trans-unit id="90d3816cdd271ff4f563d74700f0c34c9ae7702c" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;$projectroot&lt;/code&gt; is &lt;code&gt;/pub/git&lt;/code&gt;. You can change it during building gitweb via &lt;code&gt;GITWEB_PROJECTROOT&lt;/code&gt; build configuration variable.</source>
          <target state="translated">默认值为 &lt;code&gt;$projectroot&lt;/code&gt; 是 &lt;code&gt;/pub/git&lt;/code&gt; 。您可以在构建gitweb期间通过 &lt;code&gt;GITWEB_PROJECTROOT&lt;/code&gt; 构建配置变量进行更改。</target>
        </trans-unit>
        <trans-unit id="78bcbc1a976cbafa1db494161487aec966c7436d" translate="yes" xml:space="preserve">
          <source>The default value is either &lt;code&gt;static/gitweb.js&lt;/code&gt;, or &lt;code&gt;static/gitweb.min.js&lt;/code&gt; if the &lt;code&gt;JSMIN&lt;/code&gt; build variable was defined, i.e. if JavaScript minifier was used at build time. &lt;strong&gt;Note&lt;/strong&gt; that this single file is generated from multiple individual JavaScript &quot;modules&quot;.</source>
          <target state="translated">如果定义了 &lt;code&gt;JSMIN&lt;/code&gt; 构建变量，则默认值为 &lt;code&gt;static/gitweb.js&lt;/code&gt; 或 &lt;code&gt;static/gitweb.min.js&lt;/code&gt; ，即，如果在构建时使用了JavaScript minifier。&lt;strong&gt;请注意&lt;/strong&gt;，这个文件是由多个单独的JavaScript&amp;ldquo;模块&amp;rdquo;生成的。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="88fcf9aad2af8490af6dabfabbb5732019a6c8e1" translate="yes" xml:space="preserve">
          <source>The default value of this variable is determined by the &lt;code&gt;GITWEB_LIST&lt;/code&gt; makefile variable at installation time. If this variable is empty, gitweb will fall back to scanning the &lt;code&gt;$projectroot&lt;/code&gt; directory for repositories.</source>
          <target state="translated">该变量的默认值由安装时的 &lt;code&gt;GITWEB_LIST&lt;/code&gt; makefile变量确定。如果此变量为空，则gitweb将退回到扫描 &lt;code&gt;$projectroot&lt;/code&gt; 目录以查找存储库。</target>
        </trans-unit>
        <trans-unit id="da622b41696b803144c5254aad9443c84211d515" translate="yes" xml:space="preserve">
          <source>The default value of this variable is determined by the build-time configuration variable &lt;code&gt;GITWEB_PROJECT_MAXDEPTH&lt;/code&gt;, which defaults to 2007.</source>
          <target state="translated">此变量的默认值由构建时配置变量 &lt;code&gt;GITWEB_PROJECT_MAXDEPTH&lt;/code&gt; 确定，其默认值为2007。</target>
        </trans-unit>
        <trans-unit id="777a0a86855d35a436d0a0e990f3b787a636cb43" translate="yes" xml:space="preserve">
          <source>The defined extensions are:</source>
          <target state="translated">已定义的扩展是:</target>
        </trans-unit>
        <trans-unit id="2309a4e043845fb6e7e786e69af3d5ed57221f3f" translate="yes" xml:space="preserve">
          <source>The definition of a diff driver is done in &lt;code&gt;gitconfig&lt;/code&gt;, not &lt;code&gt;gitattributes&lt;/code&gt; file, so strictly speaking this manual page is a wrong place to talk about it. However&amp;hellip;​</source>
          <target state="translated">diff驱动程序的定义是在 &lt;code&gt;gitconfig&lt;/code&gt; 中完成的，而不是在 &lt;code&gt;gitattributes&lt;/code&gt; 文件中完成的，因此严格来说，本手册页是谈论它的错误位置。但是...</target>
        </trans-unit>
        <trans-unit id="05fbc211f0bbdc85a5cbba915fe02006f8119e9e" translate="yes" xml:space="preserve">
          <source>The definition of a merge driver is done in the &lt;code&gt;.git/config&lt;/code&gt; file, not in the &lt;code&gt;gitattributes&lt;/code&gt; file, so strictly speaking this manual page is a wrong place to talk about it. However&amp;hellip;​</source>
          <target state="translated">合并驱动程序的定义是在 &lt;code&gt;.git/config&lt;/code&gt; 文件中完成的，而不是在 &lt;code&gt;gitattributes&lt;/code&gt; 文件中完成的，因此严格来说，本手册页是谈论它的错误位置。但是...</target>
        </trans-unit>
        <trans-unit id="096c7fcd9c9053c9edd8c72ca9c95b04e65c3409" translate="yes" xml:space="preserve">
          <source>The deletion removes the superproject&amp;rsquo;s tracking data, which are both the &lt;code&gt;gitlink&lt;/code&gt; entry and the section in the &lt;code&gt;.gitmodules&lt;/code&gt; file. The submodule&amp;rsquo;s working directory is removed from the file system, but the Git directory is kept around as it to make it possible to checkout past commits without requiring fetching from another repository.</source>
          <target state="translated">删除操作将删除超级项目的跟踪数据，该数据既是 &lt;code&gt;gitlink&lt;/code&gt; 条目，也是 &lt;code&gt;.gitmodules&lt;/code&gt; 文件中的部分。子模块的工作目录已从文件系统中删除，但是保留了Git目录，因为它可以签出过去的提交而无需从另一个存储库获取。</target>
        </trans-unit>
        <trans-unit id="c4fe2a741691af413a8b078592b8e6a937844e84" translate="yes" xml:space="preserve">
          <source>The delta data is a sequence of instructions to reconstruct an object from the base object. If the base object is deltified, it must be converted to canonical form first. Each instruction appends more and more data to the target object until it&amp;rsquo;s complete. There are two supported instructions so far: one for copy a byte range from the source object and one for inserting new data embedded in the instruction itself.</source>
          <target state="translated">增量数据是从基本对象重建对象的指令序列。如果基础对象被删除，则必须首先将其转换为规范形式。每条指令都会将越来越多的数据附加到目标对象，直到完成为止。到目前为止，有两种支持的指令：一种用于从源对象复制字节范围，另一种用于插入指令本身中嵌入的新数据。</target>
        </trans-unit>
        <trans-unit id="892bc72de2972bd5305c51b8962327a3cfb2518f" translate="yes" xml:space="preserve">
          <source>The depth parameter used in the delta compression algorithm used by &lt;code&gt;git gc --aggressive&lt;/code&gt;. This defaults to 50, which is the default for the &lt;code&gt;--depth&lt;/code&gt; option when &lt;code&gt;--aggressive&lt;/code&gt; isn&amp;rsquo;t in use.</source>
          <target state="translated">&lt;code&gt;git gc --aggressive&lt;/code&gt; 使用的增量压缩算法中使用的深度参数。默认值为50，这是未使用 &lt;code&gt;--depth&lt;/code&gt; 时 &lt;code&gt;--aggressive&lt;/code&gt; 选项的默认值。</target>
        </trans-unit>
        <trans-unit id="71588492154c20723b86643e523c1d2b33771cc9" translate="yes" xml:space="preserve">
          <source>The design of fast-import allows it to import large projects in a minimum amount of memory usage and processing time. Assuming the frontend is able to keep up with fast-import and feed it a constant stream of data, import times for projects holding 10+ years of history and containing 100,000+ individual commits are generally completed in just 1-2 hours on quite modest (~$2,000 USD) hardware.</source>
          <target state="translated">fast-import的设计使得它可以在最小的内存使用量和处理时间内导入大型项目。假设前端能够跟上fast-import的速度,并为其提供源源不断的数据流,那么对于拥有10年以上历史、包含100,000+个人提交的项目,在相当小的硬件(约2000美元)上,导入时间一般只需1-2小时即可完成。</target>
        </trans-unit>
        <trans-unit id="cfd00b61765196c337cd6805a450f0ea641f8da0" translate="yes" xml:space="preserve">
          <source>The details of the credential will be provided on the helper&amp;rsquo;s stdin stream. The exact format is the same as the input/output format of the &lt;code&gt;git credential&lt;/code&gt; plumbing command (see the section &lt;code&gt;INPUT/OUTPUT
FORMAT&lt;/code&gt; in &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt; for a detailed specification).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c420d947d2d5939e423cde725977f1dbb1cf946b" translate="yes" xml:space="preserve">
          <source>The developer might want to rebase those commits to a newer &lt;code&gt;master&lt;/code&gt; while keeping the branch topology, for example when the first topic branch is expected to be integrated into &lt;code&gt;master&lt;/code&gt; much earlier than the second one, say, to resolve merge conflicts with changes to the DownloadButton class that made it into &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">开发人员可能希望在保留分支拓扑的同时将这些提交重新分配到较新的 &lt;code&gt;master&lt;/code&gt; ，例如，当第一个主题分支要比第二个主题更早地集成到 &lt;code&gt;master&lt;/code&gt; 中时，例如，解决合并冲突和对DownloadButton的更改成为 &lt;code&gt;master&lt;/code&gt; 班级。</target>
        </trans-unit>
        <trans-unit id="38adb1a4eb1052b4c27e8f4f4a52ae35ba0619ad" translate="yes" xml:space="preserve">
          <source>The diff above shows the differences between the working-tree version of file.txt and the stage 2 and stage 3 versions. So instead of preceding each line by a single &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, it now uses two columns: the first column is used for differences between the first parent and the working directory copy, and the second for differences between the second parent and the working directory copy. (See the &quot;COMBINED DIFF FORMAT&quot; section of &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt; for a details of the format.)</source>
          <target state="translated">上面的差异显示了file.txt的工作树版本与阶段2和阶段3版本之间的差异。因此，它现在不再使用每行前面的单个 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; ，而是使用两列：第一列用于第一个父级和工作目录副本之间的差异，第二列用于第二个父级和工作目录副本之间的差异。 （有关格式的详细信息，请参见&lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt;的&amp;ldquo; COMBINED DIFF FORMAT&amp;rdquo;部分。）</target>
        </trans-unit>
        <trans-unit id="330f16adb7b4cb162abae538c3471400c6f3dfa4" translate="yes" xml:space="preserve">
          <source>The diff commands &lt;code&gt;git diff-index&lt;/code&gt;, &lt;code&gt;git diff-files&lt;/code&gt;, and &lt;code&gt;git diff-tree&lt;/code&gt; can be told to manipulate differences they find in unconventional ways before showing &lt;code&gt;diff&lt;/code&gt; output. The manipulation is collectively called &quot;diffcore transformation&quot;. This short note describes what they are and how to use them to produce &lt;code&gt;diff&lt;/code&gt; output that is easier to understand than the conventional kind.</source>
          <target state="translated">可以告诉diff命令 &lt;code&gt;git diff-index&lt;/code&gt; ， &lt;code&gt;git diff-files&lt;/code&gt; 和 &lt;code&gt;git diff-tree&lt;/code&gt; 在显示 &lt;code&gt;diff&lt;/code&gt; 输出之前以非常规的方式操纵他们发现的差异。该操作统称为&amp;ldquo; diffcore变换&amp;rdquo;。此简短说明描述了它们是什么以及如何使用它们来生成 &lt;code&gt;diff&lt;/code&gt; 输出，该输出比常规类型更易于理解。</target>
        </trans-unit>
        <trans-unit id="4e50a3e21215031cd44c450ab91735643c2d6198" translate="yes" xml:space="preserve">
          <source>The diffcore mechanism is fed a list of such comparison results (each of which is called &quot;filepair&quot;, although at this point each of them talks about a single file), and transforms such a list into another list. There are currently 5 such transformations:</source>
          <target state="translated">diffcore机制被送入一个这样的比较结果的列表(每一个比较结果都被称为 &quot;filepair&quot;,尽管此时每一个比较结果都在谈论一个文件),并将这样的列表转换为另一个列表。目前有5种这样的转换方式。</target>
        </trans-unit>
        <trans-unit id="5ccc68add0025f283e287a514f59373a91910067" translate="yes" xml:space="preserve">
          <source>The directory holding the sha1 objects is missing.</source>
          <target state="translated">保存sha1对象的目录不见了。</target>
        </trans-unit>
        <trans-unit id="3e56ce3070b6d1fe8bc11b5262f83540c8411c39" translate="yes" xml:space="preserve">
          <source>The directory to find the quilt patches.</source>
          <target state="translated">找到被子补丁的目录。</target>
        </trans-unit>
        <trans-unit id="0bb0f16c4fefb50922eb2b1990a8580cecff19f2" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is with:</source>
          <target state="translated">最简单的方法就是用。</target>
        </trans-unit>
        <trans-unit id="114ebd710b84299f5cb327f93e8be01e979eae23" translate="yes" xml:space="preserve">
          <source>The easy case</source>
          <target state="translated">简单的案例</target>
        </trans-unit>
        <trans-unit id="ae6685a0ed898fdf61a802d261028cc9079a0958" translate="yes" xml:space="preserve">
          <source>The editor used to edit the commit log message will be chosen from the &lt;code&gt;GIT_EDITOR&lt;/code&gt; environment variable, the core.editor configuration variable, the &lt;code&gt;VISUAL&lt;/code&gt; environment variable, or the &lt;code&gt;EDITOR&lt;/code&gt; environment variable (in that order). See &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; for details.</source>
          <target state="translated">将从 &lt;code&gt;GIT_EDITOR&lt;/code&gt; 环境变量，core.editor配置变量， &lt;code&gt;VISUAL&lt;/code&gt; 环境变量或 &lt;code&gt;EDITOR&lt;/code&gt; 环境变量（按此顺序）中选择用于编辑提交日志消息的编辑器。有关详细信息，请参见&lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e4dbd523803a96213d55b1fc234d8888f00a89f" translate="yes" xml:space="preserve">
          <source>The effect of the &lt;code&gt;git add&lt;/code&gt; was to add one entry to the index file:</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; 的作用是在索引文件中添加一个条目：</target>
        </trans-unit>
        <trans-unit id="8c668b981ec948c02063906a293d8a4332dec951" translate="yes" xml:space="preserve">
          <source>The effect of this is best shown by way of comparing to &lt;code&gt;--full-history&lt;/code&gt; with parent rewriting. The example turns into:</source>
          <target state="translated">通过与 &lt;code&gt;--full-history&lt;/code&gt; 与父代重写进行比较，可以最好地表明其效果。该示例变为：</target>
        </trans-unit>
        <trans-unit id="f01b79da1b24a8459870505ceabc7acd5dc253cb" translate="yes" xml:space="preserve">
          <source>The effective value of &quot;core.notesRef&quot; (possibly overridden by GIT_NOTES_REF) is also implicitly added to the list of refs to be displayed.</source>
          <target state="translated">core.notesRef &quot;的有效值(可能会被GIT_NOTES_REF覆盖)也会被隐性地添加到要显示的refs列表中。</target>
        </trans-unit>
        <trans-unit id="47170c140110158e7cecc3842f11a773c4cf2ae7" translate="yes" xml:space="preserve">
          <source>The effects of this are mostly persistent, e.g. when packs and loose objects are coalesced into one another pack the existing deltas in that pack might get re-used, but there are also various cases where we might pick a sub-optimal delta from a newer pack instead.</source>
          <target state="translated">这种影响主要是持久的,例如,当包和松散的对象被凝聚到另一个包中时,该包中现有的三角洲可能会被重新使用,但也有各种情况下,我们可能会从一个较新的包中挑选一个次优的三角洲来代替。</target>
        </trans-unit>
        <trans-unit id="bf28d97f6ba9304b5153752f84c8628b03d2d10b" translate="yes" xml:space="preserve">
          <source>The email address used in the author and committer identities if no other relevant environment variable or configuration setting has been set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e306fa99dcf31c1372828d693f49a0c8b3dc6a" translate="yes" xml:space="preserve">
          <source>The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;author.email&lt;/code&gt; configuration settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e46e2a5bb8fdd59d614c9b7aa9560522ab90daa" translate="yes" xml:space="preserve">
          <source>The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;committer.email&lt;/code&gt; configuration settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05ce4cdee1f111bdf6e1a5c14e6220d9920c4e2" translate="yes" xml:space="preserve">
          <source>The equivalence test is based on the diff, after removing whitespace and line numbers. git-cherry therefore detects when commits have been &quot;copied&quot; by means of &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;, &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; or &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">去除空白和行号后，等效测试基于差异。因此，&lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry&lt;/a&gt;通过git-cherry-pick [1]，&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;或&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;检测提交的时间。</target>
        </trans-unit>
        <trans-unit id="1c5c570f3616a5224dd6e91327ceb211453e9ddc" translate="yes" xml:space="preserve">
          <source>The error event may be emitted more than once. The format string allows post-processors to group errors by type without worrying about specific error arguments.</source>
          <target state="translated">错误事件可以发出一次以上。该格式字符串允许后处理器按类型对错误进行分组,而不必担心具体的错误参数。</target>
        </trans-unit>
        <trans-unit id="2c5c3dbbaebe5825bdfa9c22deed2d10f337e86e" translate="yes" xml:space="preserve">
          <source>The event format target is a JSON-based format of event data suitable for telemetry analysis. This format is enabled with the &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; environment variable or the &lt;code&gt;trace2.eventTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">事件格式目标是适用于遥测分析的事件数据的基于JSON的格式。此格式通过 &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; 环境变量或 &lt;code&gt;trace2.eventTarget&lt;/code&gt; 系统或全局配置设置启用。</target>
        </trans-unit>
        <trans-unit id="bb53cc945a6f48ddfeb31dcd9983e9640d488cf9" translate="yes" xml:space="preserve">
          <source>The ever-versatile &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; command can also be used to examine tree objects, but &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt; will give you more details:</source>
          <target state="translated">多功能&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;命令也可以用于检查树对象，但是&lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt;将为您提供更多详细信息：</target>
        </trans-unit>
        <trans-unit id="2cae5c144ae6a6f552f7dcee7bbaf0209258a3bd" translate="yes" xml:space="preserve">
          <source>The example configuration presented here is guaranteed to be backwards and forward compatible.</source>
          <target state="translated">这里介绍的例子配置保证向后和向前兼容。</target>
        </trans-unit>
        <trans-unit id="77578078110fe9093d1036dd58aeebc2db7df1b8" translate="yes" xml:space="preserve">
          <source>The exit code from this hook invocation is ignored, however a non-zero exit code will generate an error message.</source>
          <target state="translated">这个钩子调用的退出代码会被忽略,但是一个非零的退出代码会产生一个错误信息。</target>
        </trans-unit>
        <trans-unit id="1e405cb397afa437170eea29059b03dcf97426f6" translate="yes" xml:space="preserve">
          <source>The exit code from this hook invocation is ignored; the only thing left for &lt;code&gt;git-receive-pack&lt;/code&gt; to do at that point is to exit itself anyway.</source>
          <target state="translated">挂钩调用的退出代码将被忽略；那时 &lt;code&gt;git-receive-pack&lt;/code&gt; 要做的唯一一件事就是退出自己。</target>
        </trans-unit>
        <trans-unit id="5a81c04e486b5c66b0be7554a6e91773cfd1a9a9" translate="yes" xml:space="preserve">
          <source>The exit status determines whether git will use the data from the hook to limit its search. On error, it will fall back to verifying all files and folders.</source>
          <target state="translated">退出状态决定了git是否会使用钩子的数据来限制它的搜索。如果出错,它将回到验证所有文件和文件夹的状态。</target>
        </trans-unit>
        <trans-unit id="bfebe1cb22dde824ad5950ca41e165ed720dc31c" translate="yes" xml:space="preserve">
          <source>The exit status of the hook is ignored for any state except for the &quot;prepared&quot; state. In the &quot;prepared&quot; state, a non-zero exit status will cause the transaction to be aborted. The hook will not be called with &quot;aborted&quot; state in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863cf74b97781c15eaa4bf39c81be105821817bd" translate="yes" xml:space="preserve">
          <source>The exit value of this program is negative on error, and the number of conflicts otherwise (truncated to 127 if there are more than that many conflicts). If the merge was clean, the exit value is 0.</source>
          <target state="translated">该程序的退出值在错误时为负值,否则为冲突数(如果冲突数超过那么多,则截断为127)。如果合并是干净的,则退出值为0。</target>
        </trans-unit>
        <trans-unit id="600e0ed5040d09634bf101b6adc431e3349d2258" translate="yes" xml:space="preserve">
          <source>The expected use case of this is to write supporting explanation for the commit that does not belong to the commit log message proper, and include it with the patch submission. While one can simply write these explanations after &lt;code&gt;format-patch&lt;/code&gt; has run but before sending, keeping them as Git notes allows them to be maintained between versions of the patch series (but see the discussion of the &lt;code&gt;notes.rewrite&lt;/code&gt; configuration options in &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; to use this workflow).</source>
          <target state="translated">预期的用例是为不属于提交日志消息的提交编写支持说明，并将其包含在补丁提交中。尽管可以在 &lt;code&gt;format-patch&lt;/code&gt; 运行之后但在发送之前简单地编写这些解释，但将它们保留为Git注释可以在补丁系列的各个版本之间进行维护（但请参见 &lt;code&gt;notes.rewrite&lt;/code&gt; 配置选项的讨论&lt;a href=&quot;git-notes&quot;&gt;git-notes [ 1]&lt;/a&gt;使用此工作流程）。</target>
        </trans-unit>
        <trans-unit id="7c7921a0c6ea4cec42a427f589011997d35e15f9" translate="yes" xml:space="preserve">
          <source>The external command can optionally write a single line to its standard output to be sent to the requestor as an error message when it declines the service.</source>
          <target state="translated">外部命令可以选择在其标准输出中写一行,作为拒绝服务时的错误信息发送给请求者。</target>
        </trans-unit>
        <trans-unit id="34c4f9db557882c9df4177a31e00a543de8934c9" translate="yes" xml:space="preserve">
          <source>The extra &lt;code&gt;NUL&lt;/code&gt; before the preimage path in renamed case is to allow scripts that read the output to tell if the current record being read is a single-path record or a rename/copy record without reading ahead. After reading added and deleted lines, reading up to &lt;code&gt;NUL&lt;/code&gt; would yield the pathname, but if that is &lt;code&gt;NUL&lt;/code&gt;, the record will show two paths.</source>
          <target state="translated">在重命名情况下，前映像路径之前的额外 &lt;code&gt;NUL&lt;/code&gt; 是允许读取输出的脚本告诉正在读取的当前记录是单路径记录还是重命名/复制记录，而无需提前读取。在读取添加和删除的行之后，最多读取 &lt;code&gt;NUL&lt;/code&gt; 会产生路径名，但是如果为 &lt;code&gt;NUL&lt;/code&gt; ，则记录将显示两个路径。</target>
        </trans-unit>
        <trans-unit id="1b54438722ed3844a0702f9ed09c56d6aef28ee2" translate="yes" xml:space="preserve">
          <source>The fast-import backend itself can import into an empty repository (one that has already been initialized by &lt;code&gt;git init&lt;/code&gt;) or incrementally update an existing populated repository. Whether or not incremental imports are supported from a particular foreign source depends on the frontend program in use.</source>
          <target state="translated">快速导入后端本身可以导入到一个空的存储库（已经由 &lt;code&gt;git init&lt;/code&gt; 初始化的存储库）中，也可以增量更新现有的填充存储库。是否从特定外部来源支持增量导入取决于所使用的前端程序。</target>
        </trans-unit>
        <trans-unit id="3dfacf796b68e98a60c628fed43445479dc82ce1" translate="yes" xml:space="preserve">
          <source>The fast-import mechanism used by &lt;code&gt;git p4&lt;/code&gt; creates one pack file for each invocation of &lt;code&gt;git p4 sync&lt;/code&gt;. Normally, Git garbage compression (&lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;) automatically compresses these to fewer pack files, but explicit invocation of &lt;code&gt;git repack -adf&lt;/code&gt; may improve performance.</source>
          <target state="translated">&lt;code&gt;git p4&lt;/code&gt; 使用的快速导入机制为 &lt;code&gt;git p4 sync&lt;/code&gt; 的每次调用创建一个打包文件。通常，Git垃圾压缩（&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;）自动将它们压缩为更少的打包文件，但是显式调用 &lt;code&gt;git repack -adf&lt;/code&gt; 可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="53e903dc94674f5b365dd31d16a6c2e334c714e3" translate="yes" xml:space="preserve">
          <source>The fetch and push protocols are not designed to prevent one side from stealing data from the other repository that was not intended to be shared. If you have private data that you need to protect from a malicious peer, your best option is to store it in another repository. This applies to both clients and servers. In particular, namespaces on a server are not effective for read access control; you should only grant read access to a namespace to clients that you would trust with read access to the entire repository.</source>
          <target state="translated">获取和推送协议并不是为了防止一方从另一个存储库中窃取不打算共享的数据而设计的。如果你有需要保护的私有数据不被恶意的对等方窃取,你最好的选择是将其存储在另一个存储库中。这适用于客户端和服务器。特别是,服务器上的命名空间对于读取访问控制是无效的;你应该只将对命名空间的读取访问权授予那些你会信任的对整个存储库有读取访问权的客户端。</target>
        </trans-unit>
        <trans-unit id="648bf821f46e9909499e1fbac0dd96a1ab871eb7" translate="yes" xml:space="preserve">
          <source>The fields (including the &lt;code&gt;-&amp;gt;&lt;/code&gt;) are separated from each other by a single space. If a filename contains whitespace or other nonprintable characters, that field will be quoted in the manner of a C string literal: surrounded by ASCII double quote (34) characters, and with interior special characters backslash-escaped.</source>
          <target state="translated">各个字段（包括 &lt;code&gt;-&amp;gt;&lt;/code&gt; ）之间用一个空格隔开。如果文件名包含空格或其他不可打印的字符，则该字段将以C字符串文字的形式引用：用ASCII双引号（34）字符包围，并用反斜杠转义的内部特殊字符。</target>
        </trans-unit>
        <trans-unit id="3994e582754827987cb1dab035b29a73b90c4b3e" translate="yes" xml:space="preserve">
          <source>The file consists of sections and variables. A section begins with the name of the section in square brackets and continues until the next section begins. Section names are case-insensitive. Only alphanumeric characters, &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;.&lt;/code&gt; are allowed in section names. Each variable must belong to some section, which means that there must be a section header before the first setting of a variable.</source>
          <target state="translated">该文件包含节和变量。一个部分以方括号中的部分名称开头，一直持续到下一个部分开始为止。节名称不区分大小写。仅字母数字字符 &lt;code&gt;-&lt;/code&gt; 和 &lt;code&gt;.&lt;/code&gt; 节名称中允许使用。每个变量必须属于某个节，这意味着在第一次设置变量之前必须有一个节头。</target>
        </trans-unit>
        <trans-unit id="b77694751b662ffffe51a33dc2cd7f9b8be897f4" translate="yes" xml:space="preserve">
          <source>The file contains one subsection per submodule, and the subsection value is the name of the submodule. The name is set to the path where the submodule has been added unless it was customized with the &lt;code&gt;--name&lt;/code&gt; option of &lt;code&gt;git submodule add&lt;/code&gt;. Each submodule section also contains the following required keys:</source>
          <target state="translated">该文件每个子模块包含一个子节，该子节的值是子模块的名称。该名称设置为添加子模块的路径，除非使用 &lt;code&gt;git submodule add&lt;/code&gt; 的 &lt;code&gt;--name&lt;/code&gt; 选项对其进行了自定义。每个子模块部分还包含以下必需键：</target>
        </trans-unit>
        <trans-unit id="d7d8ebbce919f993c68a8bac80b9fbb16d92024e" translate="yes" xml:space="preserve">
          <source>The file format includes parameters for the object ID hash function, so a future change of hash algorithm does not require a change in format.</source>
          <target state="translated">文件格式中包含了对象ID哈希函数的参数,所以将来改变哈希算法不需要改变格式。</target>
        </trans-unit>
        <trans-unit id="1bb6e340dc566db02505e0c4003761a9d85c40c1" translate="yes" xml:space="preserve">
          <source>The file is concluded with a trailer:</source>
          <target state="translated">文件的最后是一个预告片。</target>
        </trans-unit>
        <trans-unit id="996f5fbcdb16f7d7ee85c3a6ae77d46a1781884a" translate="yes" xml:space="preserve">
          <source>The file parameters can point at the user&amp;rsquo;s working file (e.g. &lt;code&gt;new-file&lt;/code&gt; in &quot;git-diff-files&quot;), &lt;code&gt;/dev/null&lt;/code&gt; (e.g. &lt;code&gt;old-file&lt;/code&gt; when a new file is added), or a temporary file (e.g. &lt;code&gt;old-file&lt;/code&gt; in the index). &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; should not worry about unlinking the temporary file --- it is removed when &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; exits.</source>
          <target state="translated">该文件中的参数可以在用户的工作文件指向（如 &lt;code&gt;new-file&lt;/code&gt; 在&amp;ldquo;混帐的Diff-文件&amp;rdquo;）， &lt;code&gt;/dev/null&lt;/code&gt; （如 &lt;code&gt;old-file&lt;/code&gt; 时添加一个新的文件），或临时文件（如 &lt;code&gt;old-file&lt;/code&gt; 索引中的文件）。 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 不必担心取消链接临时文件---在退出 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 时将其删除。</target>
        </trans-unit>
        <trans-unit id="b979e5d416845ad4db7c29ab613bf67d05d7d448" translate="yes" xml:space="preserve">
          <source>The files are read in the order given above, with last value found taking precedence over values read earlier. When multiple values are taken then all values of a key from all files will be used.</source>
          <target state="translated">文件按上述顺序读取,最后找到的值优先于前面读取的值。当取多个值时,则将使用所有文件中一个键的所有值。</target>
        </trans-unit>
        <trans-unit id="22cd650e22be9431ebec70f16e27f0954b25a243" translate="yes" xml:space="preserve">
          <source>The files to read the patch from. &lt;code&gt;-&lt;/code&gt; can be used to read from the standard input.</source>
          <target state="translated">从中读取补丁的文件。 &lt;code&gt;-&lt;/code&gt; 可用于从标准输入中读取。</target>
        </trans-unit>
        <trans-unit id="fc839d554b73db3187cb52551b31c221d5647965" translate="yes" xml:space="preserve">
          <source>The filter is expected to respond with a list of &quot;key=value&quot; pairs terminated with a flush packet. If the filter does not experience problems then the list must contain a &quot;success&quot; status. Right after these packets the filter is expected to send the content in zero or more pkt-line packets and a flush packet at the end. Finally, a second list of &quot;key=value&quot; pairs terminated with a flush packet is expected. The filter can change the status in the second list or keep the status as is with an empty list. Please note that the empty list must be terminated with a flush packet regardless.</source>
          <target state="translated">过滤器应该用一个 &quot;key=value &quot;对的列表来响应,并以一个冲洗包结束。如果过滤器没有遇到问题,那么这个列表必须包含一个 &quot;成功 &quot;状态。就在这些数据包之后,过滤器要以0个或更多的pkt-line数据包发送内容,并在最后发送一个flush数据包。最后,预计第二个 &quot;key=value &quot;对的列表将以一个flush包结束。过滤器可以改变第二个列表中的状态,也可以用一个空列表保持状态不变。请注意,无论如何,空列表都必须以一个flush包结束。</target>
        </trans-unit>
        <trans-unit id="48c7b9e769ad1a8ac7a03d8a91befba4e1dc75d4" translate="yes" xml:space="preserve">
          <source>The filter that will be applied when fetching from this promisor remote.</source>
          <target state="translated">从这个远程承诺者获取信息时应用的过滤器。</target>
        </trans-unit>
        <trans-unit id="67e1cbcd0bc26ca591869ec55e18981d4a05f31d" translate="yes" xml:space="preserve">
          <source>The filters are applied in the order as listed below. The &amp;lt;command&amp;gt; argument is always evaluated in the shell context using the &lt;code&gt;eval&lt;/code&gt; command (with the notable exception of the commit filter, for technical reasons). Prior to that, the &lt;code&gt;$GIT_COMMIT&lt;/code&gt; environment variable will be set to contain the id of the commit being rewritten. Also, GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE, GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL, and GIT_COMMITTER_DATE are taken from the current commit and exported to the environment, in order to affect the author and committer identities of the replacement commit created by &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; after the filters have run.</source>
          <target state="translated">过滤器的应用顺序如下。始终在shell上下文中使用 &lt;code&gt;eval&lt;/code&gt; 命令评估&amp;lt;command&amp;gt;参数（出于技术原因，commit过滤器明显例外）。在此之前， &lt;code&gt;$GIT_COMMIT&lt;/code&gt; 环境变量将设置为包含要重写的提交的ID。另外，GIT_AUTHOR_NAME，GIT_AUTHOR_EMAIL，GIT_AUTHOR_DATE，GIT_COMMITTER_NAME，GIT_COMMITTER_EMAIL和GIT_COMMITTER_DATE均从当前提交中提取并导出到环境中，以影响由&lt;a href=&quot;git-commit-tree&quot;&gt;[1]&lt;/a&gt;在git-commit-tree之后创建的替换提交的作者和提交者身份筛选器已运行。</target>
        </trans-unit>
        <trans-unit id="96e6a8e11c595c66ed126e7ed94498b41b8ef74c" translate="yes" xml:space="preserve">
          <source>The final &quot;/&quot; is important. The exported name is literally just prefixed with the specified string. Contrast this with the following example.</source>
          <target state="translated">最后的&quot;/&quot;很重要。导出的名称实际上只是用指定的字符串作为前缀。与下面的例子进行对比。</target>
        </trans-unit>
        <trans-unit id="5e71083855686454b686d549c1aa754044d9c24f" translate="yes" xml:space="preserve">
          <source>The final result will be a series of commits, one for each patch in the original mailbox, with authorship and commit log message each taken from the message containing each patch.</source>
          <target state="translated">最后的结果将是一系列的提交,每个补丁在原始邮箱中都有一个,作者和提交日志信息分别取自包含每个补丁的消息。</target>
        </trans-unit>
        <trans-unit id="d06dc79919ba8d7d4e32bae22586b9e61ea6ab90" translate="yes" xml:space="preserve">
          <source>The first &quot;git bisect&quot; subcommand to use is &quot;git bisect start&quot; to start the search. Then bounds must be set to limit the commit space. This is done usually by giving one &quot;bad&quot; and at least one &quot;good&quot; commit. They can be passed in the initial call to &quot;git bisect start&quot; like this:</source>
          <target state="translated">第一个要使用的 &quot;git bisect &quot;子命令是 &quot;git bisect start&quot;,开始搜索。然后,必须设置限制提交空间的界限,这通常是通过给出一个 &quot;坏 &quot;和至少一个 &quot;好 &quot;的提交来完成的。这通常是通过给出一个 &quot;坏的 &quot;和至少一个 &quot;好的 &quot;提交来完成的,它们可以在 &quot;git bisect start &quot;的初始调用中传递。在调用 &quot;git bisect start &quot;时,可以像这样传递它们。</target>
        </trans-unit>
        <trans-unit id="7d24667b8a3af4ae680279e90e5939ecc7d57754" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;N&lt;/code&gt; lines of the message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dd96cc8c67fe6f3794e1faadfc16d4e75778490" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;origin&lt;/code&gt;, just tells Git to fetch from the repository you originally cloned from. The second argument tells Git to fetch the branch named &lt;code&gt;todo&lt;/code&gt; from the remote repository, and to store it locally under the name &lt;code&gt;refs/heads/my-todo-work&lt;/code&gt;.</source>
          <target state="translated">第一个参数 &lt;code&gt;origin&lt;/code&gt; 只是告诉Git从最初克隆的存储库中获取。第二个参数告诉Git 从远程存储库获取名为 &lt;code&gt;todo&lt;/code&gt; 的分支，并将其以 &lt;code&gt;refs/heads/my-todo-work&lt;/code&gt; 的名称本地存储。</target>
        </trans-unit>
        <trans-unit id="81bbac8df429c9294b949507806676c0327c9227" translate="yes" xml:space="preserve">
          <source>The first character given by this option will be the default character used when another separator is not specified in the config for this trailer.</source>
          <target state="translated">该选项给出的第一个字符将是该预告片配置中未指定其他分隔符时的默认字符。</target>
        </trans-unit>
        <trans-unit id="39b9ae2f52daae0742c9cd959c54a342268035c6" translate="yes" xml:space="preserve">
          <source>The first command fetches the &lt;code&gt;maint&lt;/code&gt; branch from the repository at &lt;code&gt;git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt; and the second command uses &lt;code&gt;FETCH_HEAD&lt;/code&gt; to examine the branch with &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;. The fetched objects will eventually be removed by git&amp;rsquo;s built-in housekeeping (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;).</source>
          <target state="translated">第一个命令从 &lt;code&gt;git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt; 的存储库中获取 &lt;code&gt;maint&lt;/code&gt; 分支，第二个命令使用 &lt;code&gt;FETCH_HEAD&lt;/code&gt; 通过&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;检查该分支。所获取的对象最终将由git的内置管家删除（请参见&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fc54aa6f7f46c36afb224191ab9ce02506aa2fd9" translate="yes" xml:space="preserve">
          <source>The first defense against such problems is backups. You can back up a Git directory using clone, or just using cp, tar, or any other backup mechanism.</source>
          <target state="translated">对此类问题的第一道防线就是备份。你可以使用clone备份Git目录,或者直接使用cp、tar或其他备份机制。</target>
        </trans-unit>
        <trans-unit id="eb17679ed2c14d3eecb0f1bd83c98beea1f4bea4" translate="yes" xml:space="preserve">
          <source>The first format is what gets used when &lt;code&gt;--stage&lt;/code&gt; is omitted or is not &lt;code&gt;--stage=all&lt;/code&gt;. The field tempname is the temporary file name holding the file content and path is the tracked path name in the index. Only the requested entries are output.</source>
          <target state="translated">第一种格式是 &lt;code&gt;--stage&lt;/code&gt; 省略或不是 &lt;code&gt;--stage=all&lt;/code&gt; 时使用的格式。字段tempname是保存文件内容的临时文件名，path是索引中跟踪的路径名。仅输出所请求的条目。</target>
        </trans-unit>
        <trans-unit id="e7e26fcb00a95d796be86027e9776fd349443123" translate="yes" xml:space="preserve">
          <source>The first is simple and appropriate if you do not have secure storage available for a password. It is generally configured by adding this to your config:</source>
          <target state="translated">第一种方法很简单,如果你没有安全的密码存储空间,那么这种方法是合适的。一般是通过在你的config中添加这个来配置的。</target>
        </trans-unit>
        <trans-unit id="51f664b1e28dce07dd2c1ef3f2cc4ddb005556f4" translate="yes" xml:space="preserve">
          <source>The first issue is performance. Unlike any previous option, the &lt;code&gt;--simplify-merges&lt;/code&gt; option requires walking the entire commit history before returning a single result. This can make the option difficult to use for very large repositories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="561e4f0c34cc864db97b2078e570c6b7cf2ee83d" translate="yes" xml:space="preserve">
          <source>The first line of the input feeds 0 as the mode to remove the path; the SHA-1 does not matter as long as it is well formatted. Then the second and third line feeds stage 1 and stage 2 entries for that path. After the above, we would end up with this:</source>
          <target state="translated">输入的第一行输入0作为删除路径的模式,SHA-1并不重要,只要格式良好即可。然后第二行和第三行输入该路径的阶段1和阶段2条目。经过上面的操作,我们最终会得到这样的结果。</target>
        </trans-unit>
        <trans-unit id="d7a467221d570ce5d2e2454d168c252049fa7e64" translate="yes" xml:space="preserve">
          <source>The first number is the number of objects which are kept in individual files. The second is the amount of space taken up by those &quot;loose&quot; objects.</source>
          <target state="translated">第一个数字是保存在单个文件中的对象数量。第二个数字是这些 &quot;松散 &quot;物体所占的空间。</target>
        </trans-unit>
        <trans-unit id="a3a16231598a15324fe96a0d30a2003f1c762045" translate="yes" xml:space="preserve">
          <source>The first paragraph of the message, which typically is a single line, is taken as the &quot;subject&quot; of the commit or the tag message. Instead of &lt;code&gt;contents:subject&lt;/code&gt;, field &lt;code&gt;subject&lt;/code&gt; can also be used to obtain same results. &lt;code&gt;:sanitize&lt;/code&gt; can be appended to &lt;code&gt;subject&lt;/code&gt; for subject line suitable for filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1517f019c895db91a3158888218e464c0e667ed4" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the hook is the indicator for the working directory being updated. &quot;1&quot; meaning working directory was updated or &quot;0&quot; when the working directory was not updated.</source>
          <target state="translated">传递给钩子的第一个参数是被更新的工作目录的指示器,&quot;1 &quot;表示工作目录被更新,&quot;0 &quot;表示工作目录没有被更新。&quot;1 &quot;表示工作目录被更新,&quot;0 &quot;表示工作目录没有被更新。</target>
        </trans-unit>
        <trans-unit id="69f4b05a4b19ebccc10062a19a78b72d37ff6b60" translate="yes" xml:space="preserve">
          <source>The first rule takes precedence in the case of a single &amp;lt;commit&amp;gt;. To apply the second rule, i.e., format everything since the beginning of history up until &amp;lt;commit&amp;gt;, use the &lt;code&gt;--root&lt;/code&gt; option: &lt;code&gt;git format-patch
--root &amp;lt;commit&amp;gt;&lt;/code&gt;. If you want to format only &amp;lt;commit&amp;gt; itself, you can do this with &lt;code&gt;git format-patch -1 &amp;lt;commit&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">对于单个&amp;lt;commit&amp;gt;，第一个规则优先。要应用第二条规则，即格式化从历史记录开始到&amp;lt;commit&amp;gt;的所有内容，请使用 &lt;code&gt;--root&lt;/code&gt; 选项： &lt;code&gt;git format-patch --root &amp;lt;commit&amp;gt;&lt;/code&gt; 。如果只想格式化&amp;lt;commit&amp;gt;本身，则可以使用 &lt;code&gt;git format-patch -1 &amp;lt;commit&amp;gt;&lt;/code&gt; 进行格式化。</target>
        </trans-unit>
        <trans-unit id="088dfc95ab36375e45956a12e0a84d20b54cd1e3" translate="yes" xml:space="preserve">
          <source>The first step is trivial: when you want to tell Git about any changes to your working tree, you use the &lt;code&gt;git update-index&lt;/code&gt; program. That program normally just takes a list of filenames you want to update, but to avoid trivial mistakes, it refuses to add new entries to the index (or remove existing ones) unless you explicitly tell it that you&amp;rsquo;re adding a new entry with the &lt;code&gt;--add&lt;/code&gt; flag (or removing an entry with the &lt;code&gt;--remove&lt;/code&gt;) flag.</source>
          <target state="translated">第一步很简单：当您想告诉Git您对工作树的任何更改时，请使用 &lt;code&gt;git update-index&lt;/code&gt; 程序。该程序通常只获取您要更新的文件名列表，但为避免琐碎的错误，除非您明确告诉它要添加新条目，否则它将拒绝向索引添加新条目（或删除现有条目）。 &lt;code&gt;--add&lt;/code&gt; 标志（或使用 &lt;code&gt;--remove&lt;/code&gt; 删除条目）标志。</target>
        </trans-unit>
        <trans-unit id="a1763915dd6826ebefd6dfcb3fd9fb79e61ff2f7" translate="yes" xml:space="preserve">
          <source>The first time that a commit shows up in the stream, it has various other information about it printed out with a one-word tag at the beginning of each line describing the extra commit information (author, email, committer, dates, summary, etc.).</source>
          <target state="translated">当一个提交第一次出现在流中时,它的各种其他信息都会被打印出来,每行开头都有一个单字标签,描述额外的提交信息(作者、电子邮件、提交者、日期、摘要等)。</target>
        </trans-unit>
        <trans-unit id="33e2d00ff1c333999b37d340bc5ae3e8a3bfd826" translate="yes" xml:space="preserve">
          <source>The first time you run it, you will be prompted for your credentials. Enter the app-specific or your regular password as appropriate. If you have credential helper configured (see &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt;), the password will be saved in the credential store so you won&amp;rsquo;t have to type it the next time.</source>
          <target state="translated">首次运行时，将提示您输入凭据。输入特定于应用程序的密码或您的常规密码。如果您配置了凭据帮助程序（请参阅&lt;a href=&quot;git-credential&quot;&gt;git-credential [1]&lt;/a&gt;），则密码将保存在凭据存储区中，因此下次无需键入密码。</target>
        </trans-unit>
        <trans-unit id="1c77b9db9c00c5ba7e83e0fb24758e48237c23ee" translate="yes" xml:space="preserve">
          <source>The first two lines indicate that it is showing the two branches with the titles of their top-of-the-tree commits, you are currently on &lt;code&gt;master&lt;/code&gt; branch (notice the asterisk &lt;code&gt;*&lt;/code&gt; character), and the first column for the later output lines is used to show commits contained in the &lt;code&gt;master&lt;/code&gt; branch, and the second column for the &lt;code&gt;mybranch&lt;/code&gt; branch. Three commits are shown along with their titles. All of them have non blank characters in the first column (&lt;code&gt;*&lt;/code&gt; shows an ordinary commit on the current branch, &lt;code&gt;-&lt;/code&gt; is a merge commit), which means they are now part of the &lt;code&gt;master&lt;/code&gt; branch. Only the &quot;Some work&quot; commit has the plus &lt;code&gt;+&lt;/code&gt; character in the second column, because &lt;code&gt;mybranch&lt;/code&gt; has not been merged to incorporate these commits from the master branch. The string inside brackets before the commit log message is a short name you can use to name the commit. In the above example, &lt;code&gt;master&lt;/code&gt; and &lt;code&gt;mybranch&lt;/code&gt; are branch heads. &lt;code&gt;master^&lt;/code&gt; is the first parent of &lt;code&gt;master&lt;/code&gt; branch head. Please see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; if you want to see more complex cases.</source>
          <target state="translated">前两行表明它正在显示两个分支，并具有其树顶提交的标题，您当前位于 &lt;code&gt;master&lt;/code&gt; 分支上（请注意星号 &lt;code&gt;*&lt;/code&gt; 字符），后面输出行的第一列是用于显示 &lt;code&gt;master&lt;/code&gt; 分支中包含的提交，以及 &lt;code&gt;mybranch&lt;/code&gt; 分支的第二列。显示了三个提交及其标题。它们全部在第一列中具有非空白字符（ &lt;code&gt;*&lt;/code&gt; 显示当前分支上的普通提交， &lt;code&gt;-&lt;/code&gt; 是合并提交），这意味着它们现在是 &lt;code&gt;master&lt;/code&gt; 分支的一部分。只有&amp;ldquo;某些工作&amp;rdquo;提交才有加号 &lt;code&gt;+&lt;/code&gt; 第二列中的字符，因为 &lt;code&gt;mybranch&lt;/code&gt; 尚未合并以合并master分支中的这些提交。提交日志消息前方括号内的字符串是可用于命名提交的缩写。在上面的示例中， &lt;code&gt;master&lt;/code&gt; 和 &lt;code&gt;mybranch&lt;/code&gt; 是分支头。 &lt;code&gt;master^&lt;/code&gt; 是 &lt;code&gt;master&lt;/code&gt; 分支头的第一个父代。如果您想查看更复杂的情况，请参阅&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b2c923c8cb34a6329089d3ed63e2b76d6f7ceed" translate="yes" xml:space="preserve">
          <source>The folder to drop the mails into, which is typically the Drafts folder. For example: &quot;INBOX.Drafts&quot;, &quot;INBOX/Drafts&quot; or &quot;[Gmail]/Drafts&quot;. Required.</source>
          <target state="translated">要将邮件投递到的文件夹,通常是Drafts文件夹。例如:&quot;INBOX.Drafts&quot;、&quot;INBOX/Drafts &quot;或&quot;[Gmail]/Drafts&quot;。&quot;INBOX.Drafts&quot;,&quot;INBOX/Drafts &quot;或&quot;[Gmail]/Drafts&quot;。需要。</target>
        </trans-unit>
        <trans-unit id="396ef1fe12b6dc07f4e5a4f66f87333df9fb56e3" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;update&lt;/code&gt; procedures are only available via the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration variable:</source>
          <target state="translated">以下 &lt;code&gt;update&lt;/code&gt; 过程仅可通过 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 配置变量使用：</target>
        </trans-unit>
        <trans-unit id="109e44e80a38f6553ddae4455bbabc5ec0d98180" translate="yes" xml:space="preserve">
          <source>The following Thunderbird extensions are needed: AboutConfig from &lt;a href=&quot;http://aboutconfig.mozdev.org/&quot;&gt;http://aboutconfig.mozdev.org/&lt;/a&gt; and External Editor from &lt;a href=&quot;http://globs.org/articles.php?lng=en&amp;amp;pg=8&quot;&gt;http://globs.org/articles.php?lng=en&amp;amp;pg=8&lt;/a&gt;</source>
          <target state="translated">需要以下Thunderbird扩展：&lt;a href=&quot;http://aboutconfig.mozdev.org/&quot;&gt;http&lt;/a&gt; ://aboutconfig.mozdev.org/中的AboutConfig 和&lt;a href=&quot;http://globs.org/articles.php?lng=en&amp;amp;pg=8&quot;&gt;http://globs.org/articles.php?lng=en&amp;amp;pg=8中的&lt;/a&gt;外部编辑器</target>
        </trans-unit>
        <trans-unit id="f6722fafbaf6d78a6b809eec36e0605e28b20857" translate="yes" xml:space="preserve">
          <source>The following are helper commands used by the above; end users typically do not use them directly.</source>
          <target state="translated">以下是上述使用的辅助命令,最终用户一般不直接使用。</target>
        </trans-unit>
        <trans-unit id="7e10909a1942dd56a826033bd880f2f38314517d" translate="yes" xml:space="preserve">
          <source>The following command switches to the &quot;master&quot; branch:</source>
          <target state="translated">下面的命令可以切换到 &quot;主 &quot;分支。</target>
        </trans-unit>
        <trans-unit id="7a4f4c25f3029fcde1d4a38239fa9b13c5887156" translate="yes" xml:space="preserve">
          <source>The following command-line options change import semantics and may therefore not be passed as option:</source>
          <target state="translated">以下命令行选项改变了导入语义,因此不能作为选项传递。</target>
        </trans-unit>
        <trans-unit id="932cde1c301ce345d40b274a1f81ff3e5be711e6" translate="yes" xml:space="preserve">
          <source>The following command-specific comments apply:</source>
          <target state="translated">以下是对特定命令的评论。</target>
        </trans-unit>
        <trans-unit id="d6f2de10386ef19748ad0fa0931b3359b3969227" translate="yes" xml:space="preserve">
          <source>The following config settings can be used to modify &lt;code&gt;git p4&lt;/code&gt; behavior. They all are in the &lt;code&gt;git-p4&lt;/code&gt; section.</source>
          <target state="translated">以下配置设置可用于修改 &lt;code&gt;git p4&lt;/code&gt; 行为。它们都在 &lt;code&gt;git-p4&lt;/code&gt; 部分中。</target>
        </trans-unit>
        <trans-unit id="f68ee79cc1f0c0e26a0c766d89a6823644298bab" translate="yes" xml:space="preserve">
          <source>The following configuration variables tell gitweb where to find files. The values of these variables are paths on the filesystem.</source>
          <target state="translated">以下配置变量告诉gitweb在哪里查找文件。这些变量的值是文件系统中的路径。</target>
        </trans-unit>
        <trans-unit id="446ebc694e2441273405a78869483ed3506272c8" translate="yes" xml:space="preserve">
          <source>The following date formats are supported. A frontend should select the format it will use for this import by passing the format name in the --date-format=&amp;lt;fmt&amp;gt; command-line option.</source>
          <target state="translated">支持以下日期格式。前端应通过在--date-format = &amp;lt;fmt&amp;gt;命令行选项中传递格式名称来选择用于此导入的格式。</target>
        </trans-unit>
        <trans-unit id="e77a52167245e31f57d9305063355588365e98e5" translate="yes" xml:space="preserve">
          <source>The following description divides the low-level commands into commands that manipulate objects (in the repository, index, and working tree), commands that interrogate and compare objects, and commands that move objects and references between repositories.</source>
          <target state="translated">下面的描述将低级命令分为操作对象(在资源库、索引和工作树中)的命令、查询和比较对象的命令以及在资源库之间移动对象和引用的命令。</target>
        </trans-unit>
        <trans-unit id="0ccfcc7705084a20c6fb8eba32c2c2f3d02467cc" translate="yes" xml:space="preserve">
          <source>The following documentation pages are guides about Git concepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce90b7b29314319d9c33a8b52e106d84ec9670f" translate="yes" xml:space="preserve">
          <source>The following escape sequences (beside &lt;code&gt;\&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt;) are recognized: &lt;code&gt;\n&lt;/code&gt; for newline character (NL), &lt;code&gt;\t&lt;/code&gt; for horizontal tabulation (HT, TAB) and &lt;code&gt;\b&lt;/code&gt; for backspace (BS). Other char escape sequences (including octal escape sequences) are invalid.</source>
          <target state="translated">可以识别以下转义序列（在 &lt;code&gt;\&quot;&lt;/code&gt; 和 &lt;code&gt;\\&lt;/code&gt; 旁边）： &lt;code&gt;\n&lt;/code&gt; 代表换行符（NL）， &lt;code&gt;\t&lt;/code&gt; 代表水平制表符（HT，TAB）， &lt;code&gt;\b&lt;/code&gt; 代表退格键（BS）。其他char逃逸序列（包括八进制）转义序列）无效。</target>
        </trans-unit>
        <trans-unit id="11e92a0ce8b123a34278f747bf61153deb05c5a4" translate="yes" xml:space="preserve">
          <source>The following example shows three branches, &quot;master&quot;, &quot;fixes&quot; and &quot;mhf&quot;:</source>
          <target state="translated">下面的例子显示了三个分支,&quot;master&quot;、&quot;fixes &quot;和 &quot;mhf&quot;。</target>
        </trans-unit>
        <trans-unit id="4297ab330b843af6f1af2259ff9a055a87b6bf37" translate="yes" xml:space="preserve">
          <source>The following features from &amp;lsquo;svn log&amp;rsquo; are supported:</source>
          <target state="translated">支持&amp;ldquo; svn日志&amp;rdquo;中的以下功能：</target>
        </trans-unit>
        <trans-unit id="9b96392c24cd31061920293e2fd2511a8543969f" translate="yes" xml:space="preserve">
          <source>The following flags further affect the behavior when comparing commits (but not trees).</source>
          <target state="translated">以下标志会进一步影响比较提交(但不是树)时的行为。</target>
        </trans-unit>
        <trans-unit id="c98119f1eba9806e1383e47ef0aa9d751dbdff13" translate="yes" xml:space="preserve">
          <source>The following format are available:</source>
          <target state="translated">有以下格式可供选择:</target>
        </trans-unit>
        <trans-unit id="5f08fc55d496958a337ddcb6a67febfb89f85554" translate="yes" xml:space="preserve">
          <source>The following key/value pairs are common to all events:</source>
          <target state="translated">以下键/值对是所有事件的共同点:</target>
        </trans-unit>
        <trans-unit id="0a5e5ff367236dbd6bf5580d5af5e71ae090b770" translate="yes" xml:space="preserve">
          <source>The following options affect the way the simplification is performed:</source>
          <target state="translated">以下选项会影响简化的方式。</target>
        </trans-unit>
        <trans-unit id="d99d5d2882d3fb95fadc56a0416699f5b886386d" translate="yes" xml:space="preserve">
          <source>The following options are available in either location:</source>
          <target state="translated">以下选项可在任一地点使用:</target>
        </trans-unit>
        <trans-unit id="6e9dd1ef0925dcf9e09b1e6e501e8d0360e77eba" translate="yes" xml:space="preserve">
          <source>The following options are defined and (under suitable circumstances) set by Git if the remote helper has the &lt;code&gt;option&lt;/code&gt; capability.</source>
          <target state="translated">如果远程帮助程序具有 &lt;code&gt;option&lt;/code&gt; 功能，则由Git定义并（在适当的情况下）设置以下选项。</target>
        </trans-unit>
        <trans-unit id="ad97d4ffb6c58a93bf3193a5402926d11d214aa1" translate="yes" xml:space="preserve">
          <source>The following options select the commits to be shown:</source>
          <target state="translated">以下选项选择要显示的提交。</target>
        </trans-unit>
        <trans-unit id="04bd1c24e8e494894e5123ce96e6c123a135b194" translate="yes" xml:space="preserve">
          <source>The following options:</source>
          <target state="translated">以下选项:</target>
        </trans-unit>
        <trans-unit id="7b3b3b2ba3a3d71942fecd2cbccdbee3fd847246" translate="yes" xml:space="preserve">
          <source>The following sequence attempts to backport a patch, bails out because the code the patch applies to has changed too much, and then tries again, this time exercising more care about matching up context lines.</source>
          <target state="translated">下面的序列试图回溯一个补丁,因为补丁所应用的代码变化太大而退出,然后再次尝试,这次在匹配上下文行时更加小心。</target>
        </trans-unit>
        <trans-unit id="0fb6c7c3c1a2e6361aa6d0f3ddafd309ebc6378c" translate="yes" xml:space="preserve">
          <source>The following sequence checks out the &lt;code&gt;master&lt;/code&gt; branch, reverts the &lt;code&gt;Makefile&lt;/code&gt; to two revisions back, deletes &lt;code&gt;hello.c&lt;/code&gt; by mistake, and gets it back from the index.</source>
          <target state="translated">以下序列检出 &lt;code&gt;master&lt;/code&gt; 分支，将 &lt;code&gt;Makefile&lt;/code&gt; 恢复为两个修订版本，错误地删除 &lt;code&gt;hello.c&lt;/code&gt; ，然后将其从索引中取回。</target>
        </trans-unit>
        <trans-unit id="b8a40037f7e020ad1f156eb7f08942ca8112c080" translate="yes" xml:space="preserve">
          <source>The following sequence switches to the &lt;code&gt;master&lt;/code&gt; branch, reverts the &lt;code&gt;Makefile&lt;/code&gt; to two revisions back, deletes hello.c by mistake, and gets it back from the index.</source>
          <target state="translated">以下序列切换到 &lt;code&gt;master&lt;/code&gt; 分支，将 &lt;code&gt;Makefile&lt;/code&gt; 恢复为两个修订版本，错误地删除hello.c，然后将其从索引中恢复。</target>
        </trans-unit>
        <trans-unit id="75477915a08ed3777518303fe3302c5a880167a8" translate="yes" xml:space="preserve">
          <source>The following sequences have a special meaning:</source>
          <target state="translated">以下序列具有特殊意义。</target>
        </trans-unit>
        <trans-unit id="b07d72a39fdd44876a293ab8f917fa6a1014bd8c" translate="yes" xml:space="preserve">
          <source>The following subcommands are available:</source>
          <target state="translated">可使用以下子命令。</target>
        </trans-unit>
        <trans-unit id="55332124e1bbf00265c49abce68b19cb8696bb39" translate="yes" xml:space="preserve">
          <source>The following syntaxes may be used with them:</source>
          <target state="translated">可与它们一起使用下列语法:</target>
        </trans-unit>
        <trans-unit id="f9c489d8b69bf82a63ff4a237dd2bd772b8fb351" translate="yes" xml:space="preserve">
          <source>The following tables show what happens when there are unmerged entries:</source>
          <target state="translated">下表显示了有未合并条目时的情况。</target>
        </trans-unit>
        <trans-unit id="3cc98c85c7406728df501340aea8c7fdc3f04d78" translate="yes" xml:space="preserve">
          <source>The following tips and tricks have been collected from various users of fast-import, and are offered here as suggestions.</source>
          <target state="translated">以下技巧和窍门是由fast-import的不同用户收集的,在此提供给大家作为建议。</target>
        </trans-unit>
        <trans-unit id="177a564b8e3982405afb3b516ab4bbb5063d1ee7" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=blob:limit=&amp;lt;n&amp;gt;[kmg]&lt;/code&gt; omits blobs larger than n bytes or units. n may be zero. The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB. For example, &lt;code&gt;blob:limit=1k&lt;/code&gt; is the same as &lt;code&gt;blob:limit=1024&lt;/code&gt;.</source>
          <target state="translated">形式 &lt;code&gt;--filter=blob:limit=&amp;lt;n&amp;gt;[kmg]&lt;/code&gt; 省略了斑点大于n个字节或单元大。n可以为零。后缀k，m和g可用于命名KiB，MiB或GiB中的单位。例如， &lt;code&gt;blob:limit=1k&lt;/code&gt; 与 &lt;code&gt;blob:limit=1024&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="94349f8d4383b34d05a696da3b05af67f12eec03" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=blob:none&lt;/code&gt; omits all blobs.</source>
          <target state="translated">&lt;code&gt;--filter=blob:none&lt;/code&gt; 形式省略所有斑点。</target>
        </trans-unit>
        <trans-unit id="39c705af761382dd23f074438f9b0e646bf492af" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=combine:&amp;lt;filter1&amp;gt;+&amp;lt;filter2&amp;gt;+&amp;hellip;​&amp;lt;filterN&amp;gt;&lt;/code&gt; can also be used to combined several filters, but this is harder than just repeating the &lt;code&gt;--filter&lt;/code&gt; flag and is usually not necessary. Filters are joined by &lt;code&gt;+&lt;/code&gt; and individual filters are %-encoded (i.e. URL-encoded). Besides the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; characters, the following characters are reserved and also must be encoded: &lt;code&gt;~!@#$^&amp;amp;*()[]{}\;&quot;,&amp;lt;&amp;gt;?&lt;/code&gt;&lt;code&gt;'`&lt;/code&gt; as well as all characters with ASCII code &amp;lt;= &lt;code&gt;0x20&lt;/code&gt;, which includes space and newline.</source>
          <target state="translated">形式 &lt;code&gt;--filter=combine:&amp;lt;filter1&amp;gt;+&amp;lt;filter2&amp;gt;+&amp;hellip;​&amp;lt;filterN&amp;gt;&lt;/code&gt; 也可以被用于组合几个过滤器，但是这不是仅仅重复较硬 &lt;code&gt;--filter&lt;/code&gt; 标志，通常是没有必要的。过滤器以 &lt;code&gt;+&lt;/code&gt; 开头，各个过滤器均经过％编码（即URL编码）。除 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 字符外，还保留以下字符，并且还必须对其进行编码： &lt;code&gt;~!@#$^&amp;amp;*()[]{}\;&quot;,&amp;lt;&amp;gt;?&lt;/code&gt; &lt;code&gt;'`&lt;/code&gt; 以及所有ASCII码&amp;lt; = &lt;code&gt;0x20&lt;/code&gt; ，其中包括空格和换行符。</target>
        </trans-unit>
        <trans-unit id="d52505ec75878146eb9054dceb4728d58b485513" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=sparse:oid=&amp;lt;blob-ish&amp;gt;&lt;/code&gt; uses a sparse-checkout specification contained in the blob (or blob-expression) &lt;code&gt;&amp;lt;blob-ish&amp;gt;&lt;/code&gt; to omit blobs that would not be not required for a sparse checkout on the requested refs.</source>
          <target state="translated">形式 &lt;code&gt;--filter=sparse:oid=&amp;lt;blob-ish&amp;gt;&lt;/code&gt; 使用稀疏结账规范包含在团块（团块或表达） &lt;code&gt;&amp;lt;blob-ish&amp;gt;&lt;/code&gt; 到不会被不需要用于稀疏结帐上省略斑点所要求的裁判。</target>
        </trans-unit>
        <trans-unit id="ef46a11218e9457b2745a05e86c211527bd23b7c" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=tree:&amp;lt;depth&amp;gt;&lt;/code&gt; omits all blobs and trees whose depth from the root tree is &amp;gt;= &amp;lt;depth&amp;gt; (minimum depth if an object is located at multiple depths in the commits traversed). &amp;lt;depth&amp;gt;=0 will not include any trees or blobs unless included explicitly in the command-line (or standard input when --stdin is used). &amp;lt;depth&amp;gt;=1 will include only the tree and blobs which are referenced directly by a commit reachable from &amp;lt;commit&amp;gt; or an explicitly-given object. &amp;lt;depth&amp;gt;=2 is like &amp;lt;depth&amp;gt;=1 while also including trees and blobs one more level removed from an explicitly-given commit or tree.</source>
          <target state="translated">形式 &lt;code&gt;--filter=tree:&amp;lt;depth&amp;gt;&lt;/code&gt; 会忽略所有从根树开始的深度大于等于= &amp;lt;depth&amp;gt;（如果对象在遍历的提交中位于多个深度处的最小深度）的所有Blob和树。除非在命令行中明确包含（或使用--stdin时的标准输入），否则&amp;lt;depth&amp;gt; = 0将不包含任何树或blob。 &amp;lt;depth&amp;gt; = 1将仅包含由&amp;lt;commit&amp;gt;或显式给出的对象可到达的提交直接引用的树和blob。 &amp;lt;depth&amp;gt; = 2类似于&amp;lt;depth&amp;gt; = 1，同时还包括树和blob，它们从显式给定的提交或树中删除了一个级别。</target>
        </trans-unit>
        <trans-unit id="143c72f9a0abe1adb065cd1c00c0271a08c274c4" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-any&lt;/code&gt; will allow object traversal to continue if a missing object is encountered. Missing objects will silently be omitted from the results.</source>
          <target state="translated">如果遇到丢失的对象，格式 &lt;code&gt;--missing=allow-any&lt;/code&gt; 将允许对象遍历继续。缺少的对象将在结果中被忽略。</target>
        </trans-unit>
        <trans-unit id="bdde6c336c8ea83ffd865ad36b93358c59c8c01f" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-any&lt;/code&gt; will allow object traversal to continue if a missing object is encountered. No fetch of a missing object will occur. Missing objects will silently be omitted from the results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac33b80327bef1bf98d899063defe39f6edf744" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. No fetch of a missing object will occur. An unexpected missing object will raise an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="280716e3ccf86616960848b089fdadef81ba797d" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing object will raise an error.</source>
          <target state="translated">&lt;code&gt;--missing=allow-promisor&lt;/code&gt; 的形式类似于 &lt;code&gt;allow-any&lt;/code&gt; ，但仅允许针对期望的Promisor丢失对象继续进行对象遍历。意外丢失的对象将引发错误。</target>
        </trans-unit>
        <trans-unit id="563d9e750d01dbe920d57035d16bed3d91b9aea6" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing objects will raise an error.</source>
          <target state="translated">&lt;code&gt;--missing=allow-promisor&lt;/code&gt; 的形式类似于 &lt;code&gt;allow-any&lt;/code&gt; ，但仅允许针对期望的Promisor丢失对象继续进行对象遍历。意外丢失的对象将引发错误。</target>
        </trans-unit>
        <trans-unit id="85974afd39adff2510445a34b40c988ae3340623" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that pack-objects stop with an error if a missing object is encountered. If the repository is a partial clone, an attempt to fetch missing objects will be made before declaring them missing. This is the default action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c618ed732782b866de4c7dcf716daa2ac64119" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that pack-objects stop with an error if a missing object is encountered. This is the default action.</source>
          <target state="translated">如果遇到丢失的对象，则 &lt;code&gt;--missing=error&lt;/code&gt; 格式请求打包对象以错误停止。这是默认操作。</target>
        </trans-unit>
        <trans-unit id="2ed32158adb2f2f236ac5307d5ba7c30f0630796" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that rev-list stop with an error if a missing object is encountered. This is the default action.</source>
          <target state="translated">如果遇到缺少的对象，则 &lt;code&gt;--missing=error&lt;/code&gt; 格式请求rev-list停止并显示错误。这是默认操作。</target>
        </trans-unit>
        <trans-unit id="67e4b67693941fe412533d5210bde2a413de8fb1" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=print&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will also print a list of the missing objects. Object IDs are prefixed with a &amp;ldquo;?&amp;rdquo; character.</source>
          <target state="translated">&lt;code&gt;--missing=print&lt;/code&gt; 的形式类似于 &lt;code&gt;allow-any&lt;/code&gt; ，但也会打印缺失对象的列表。对象ID的前缀为&amp;ldquo;？&amp;rdquo; 字符。</target>
        </trans-unit>
        <trans-unit id="09994cb2384da5eddbe0ae0a9a1ceca76d8c8bcc" translate="yes" xml:space="preserve">
          <source>The format of a &amp;lt;refspec&amp;gt; parameter is an optional plus &lt;code&gt;+&lt;/code&gt;, followed by the source &amp;lt;src&amp;gt;, followed by a colon &lt;code&gt;:&lt;/code&gt;, followed by the destination ref &amp;lt;dst&amp;gt;. The colon can be omitted when &amp;lt;dst&amp;gt; is empty. &amp;lt;src&amp;gt; is typically a ref, but it can also be a fully spelled hex object name.</source>
          <target state="translated">&amp;lt;refspec&amp;gt;参数的格式是可选的plus &lt;code&gt;+&lt;/code&gt; ，后跟源&amp;lt;src&amp;gt;，后跟冒号 &lt;code&gt;:&lt;/code&gt; ，然后是目标ref &amp;lt;dst&amp;gt;。&amp;lt;dst&amp;gt;为空时，可以省略冒号。&amp;lt;src&amp;gt;通常是引用，但也可以是完全拼写的十六进制对象名称。</target>
        </trans-unit>
        <trans-unit id="05c09db4c870e826391cf6ebde5a8cc33d2791f6" translate="yes" xml:space="preserve">
          <source>The format of these files is username followed by the encrypted password, for example:</source>
          <target state="translated">这些文件的格式是用户名,后面是加密的密码,例如。</target>
        </trans-unit>
        <trans-unit id="65670970ee487305077ce344ca1fb6c36a889cee" translate="yes" xml:space="preserve">
          <source>The former lets your shell expand the fileglob, and you are asking the dot-C files in your working tree to be overwritten with the version in the index. The latter passes the &lt;code&gt;*.c&lt;/code&gt; to Git, and you are asking the paths in the index that match the pattern to be checked out to your working tree. After running &lt;code&gt;git add hello.c; rm hello.c&lt;/code&gt;, you will &lt;code&gt;not&lt;/code&gt; see &lt;code&gt;hello.c&lt;/code&gt; in your working tree with the former, but with the latter you will.</source>
          <target state="translated">前者让您的shell扩展fileglob，然后您要求工作树中的dot-C文件被索引中的版本覆盖。后者将 &lt;code&gt;*.c&lt;/code&gt; 传递给Git，您正在询问索引中与要检出的模式匹配到您的工作树的路径。运行 &lt;code&gt;git add hello.c; rm hello.c&lt;/code&gt; ，您 &lt;code&gt;not&lt;/code&gt; 在工作树中与前者一起看到 &lt;code&gt;hello.c&lt;/code&gt; ，但与后者会看到。</target>
        </trans-unit>
        <trans-unit id="b363974f459c2a2b237a919650aa9dc9f75161d2" translate="yes" xml:space="preserve">
          <source>The frontend must specify the number of bytes of data.</source>
          <target state="translated">前端必须指定数据的字节数。</target>
        </trans-unit>
        <trans-unit id="23957db0f038e6b4263285c2923ad6ce72a805ca" translate="yes" xml:space="preserve">
          <source>The full SHA-1 object name (40-byte hexadecimal string), or a leading substring that is unique within the repository. E.g. dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the same commit object if there is no other object in your repository whose object name starts with dae86e.</source>
          <target state="translated">完整的 SHA-1 对象名称(40 字节的十六进制字符串),或者在版本库中唯一的前导子串,例如 dae86e1950b1277e545cee180551750029cfe735 和 dae86e 都命名为同一个提交对象,如果版本库中没有其他对象的话。例如 dae86e1950b1277e545cee180551750029cfe735 和 dae86e 都命名为同一个提交对象,如果你的版本库中没有其他对象的名字以 dae86e 开头。</target>
        </trans-unit>
        <trans-unit id="ce332106cb9361add9aaf31aea030a425aeed7be" translate="yes" xml:space="preserve">
          <source>The full name is occasionally useful if, for example, there ever exists a tag and a branch with the same name.</source>
          <target state="translated">例如,如果存在一个标签和一个同名的分支,全名偶尔会有用。</target>
        </trans-unit>
        <trans-unit id="d24187cae372eb76b2a26570ccfd9def8c8abdf6" translate="yes" xml:space="preserve">
          <source>The full pattern set allows for arbitrary pattern matches and complicated inclusion/exclusion rules. These can result in O(N*M) pattern matches when updating the index, where N is the number of patterns and M is the number of paths in the index. To combat this performance issue, a more restricted pattern set is allowed when &lt;code&gt;core.spareCheckoutCone&lt;/code&gt; is enabled.</source>
          <target state="translated">完整模式集允许任意模式匹配和复杂的包含/排除规则。这些可能导致更新索引时出现O（N * M）个模式匹配，其中N是模式数量，M是索引中路径的数量。为了解决此性能问题，启用 &lt;code&gt;core.spareCheckoutCone&lt;/code&gt; 时允许使用更多受限制的模式集。</target>
        </trans-unit>
        <trans-unit id="271f7ad4b6b86f815e34a99cf6372d6f7edf455d" translate="yes" xml:space="preserve">
          <source>The full pattern set allows for arbitrary pattern matches and complicated inclusion/exclusion rules. These can result in O(N*M) pattern matches when updating the index, where N is the number of patterns and M is the number of paths in the index. To combat this performance issue, a more restricted pattern set is allowed when &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3e98918a57498bee35c9ef416c5932bb448c1f" translate="yes" xml:space="preserve">
          <source>The full syntax for a p4 view is documented in &lt;code&gt;p4 help views&lt;/code&gt;. &lt;code&gt;git p4&lt;/code&gt; knows only a subset of the view syntax. It understands multi-line mappings, overlays with &lt;code&gt;+&lt;/code&gt;, exclusions with &lt;code&gt;-&lt;/code&gt; and double-quotes around whitespace. Of the possible wildcards, &lt;code&gt;git p4&lt;/code&gt; only handles &lt;code&gt;&amp;hellip;​&lt;/code&gt;, and only when it is at the end of the path. &lt;code&gt;git p4&lt;/code&gt; will complain if it encounters an unhandled wildcard.</source>
          <target state="translated">&lt;code&gt;p4 help views&lt;/code&gt; 视图中记录了p4视图的完整语法。 &lt;code&gt;git p4&lt;/code&gt; 只知道视图语法的一个子集。它了解多行映射，带 &lt;code&gt;+&lt;/code&gt; 的叠加层，带 &lt;code&gt;-&lt;/code&gt; 的排除对象以及空格周围的双引号。可能的通配符， &lt;code&gt;git p4&lt;/code&gt; 只处理 &lt;code&gt;&amp;hellip;​&lt;/code&gt; ，只有当它在路的尽头。如果 &lt;code&gt;git p4&lt;/code&gt; 遇到未处理的通配符，它​​将抱怨。</target>
        </trans-unit>
        <trans-unit id="18d1519c9cf5420b92be3f082cd6f0aa89c3d260" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;skip_commit&lt;/code&gt; is defined as follows:</source>
          <target state="translated">函数 &lt;code&gt;skip_commit&lt;/code&gt; 定义如下：</target>
        </trans-unit>
        <trans-unit id="af7dd50b5e9b3d3ec2ae519f399794527002dc23" translate="yes" xml:space="preserve">
          <source>The functions defined by the Trace2 API are declared and documented in &lt;code&gt;trace2.h&lt;/code&gt;. It defines the API functions and wrapper macros for Trace2.</source>
          <target state="translated">由TRACE2 API定义的函数声明和中记录 &lt;code&gt;trace2.h&lt;/code&gt; 。它定义了Trace2的API函数和包装器宏。</target>
        </trans-unit>
        <trans-unit id="e5521fd46bed9d589b56b651d5f3ef04e9a3b2a8" translate="yes" xml:space="preserve">
          <source>The future of bisecting</source>
          <target state="translated">二分法的未来</target>
        </trans-unit>
        <trans-unit id="2aa4427c10c7d5c13ef7bbb9898f5fea28090dd1" translate="yes" xml:space="preserve">
          <source>The general idea is this: we generate a cost matrix between the commits in both commit ranges, then solve the least-cost assignment.</source>
          <target state="translated">一般的想法是:我们在两个提交范围内的提交之间生成一个成本矩阵,然后解决最小成本分配。</target>
        </trans-unit>
        <trans-unit id="0339eef2339eb8367ea8564b9ff6721cd9dea407" translate="yes" xml:space="preserve">
          <source>The git commit is created relative to the current origin revision (HEAD by default). A parent commit is created based on the origin, and then the unshelve commit is created based on that.</source>
          <target state="translated">git 提交是相对于当前的原点修订版(默认为 HEAD)而创建的。父提交是基于原点创建的,然后在此基础上创建unshelve提交。</target>
        </trans-unit>
        <trans-unit id="a5bbcd1beb35762403be84a14e62e0a4eb5d5226" translate="yes" xml:space="preserve">
          <source>The git object database</source>
          <target state="translated">git对象数据库</target>
        </trans-unit>
        <trans-unit id="80d403b9b878573aec88e9c705123dc6feedf769" translate="yes" xml:space="preserve">
          <source>The gitweb CGI script for viewing Git repositories over the web uses a perl script fragment as its configuration file. You can set variables using &quot;&lt;code&gt;our $variable = value&lt;/code&gt;&quot;; text from a &quot;#&quot; character until the end of a line is ignored. See &lt;strong&gt;perlsyn&lt;/strong&gt;(1) for details.</source>
          <target state="translated">用于在Web上查看Git存储库的gitweb CGI脚本使用perl脚本片段作为其配置文件。您可以使用&amp;ldquo; &lt;code&gt;our $variable = value&lt;/code&gt; &amp;rdquo; 来设置变量；从&amp;ldquo;＃&amp;rdquo;字符到行尾的文本将被忽略。有关详细信息，请参见&lt;strong&gt;perlsyn&lt;/strong&gt;（1）。</target>
        </trans-unit>
        <trans-unit id="a1a6c42c76028a67bf39dd75b77a2307812be731" translate="yes" xml:space="preserve">
          <source>The gitweb cgi script provides users an easy way to browse your project&amp;rsquo;s revisions, file contents and logs without having to install Git. Features like RSS/Atom feeds and blame/annotation details may optionally be enabled.</source>
          <target state="translated">gitweb cgi脚本为用户提供了一种无需安装Git即可轻松浏览项目修订版，文件内容和日志的简便方法。可以选择启用RSS / Atom提要和责备/注释详细信息之类的功能。</target>
        </trans-unit>
        <trans-unit id="eefcb42be74db518327d9c82beb9a165d884846e" translate="yes" xml:space="preserve">
          <source>The gitweb features that are configurable via &lt;code&gt;%feature&lt;/code&gt; hash are listed below. This should be a complete list, but ultimately the authoritative and complete list is in gitweb.cgi source code, with features described in the comments.</source>
          <target state="translated">下面列出了可通过 &lt;code&gt;%feature&lt;/code&gt; 哈希配置的gitweb功能。这应该是一个完整列表，但最终的权威和完整列表在gitweb.cgi源代码中，并在注释中描述了功能。</target>
        </trans-unit>
        <trans-unit id="bee84a897df9efb668b9aee969a1e660ed8af0a4" translate="yes" xml:space="preserve">
          <source>The gitweb.extraBranchRefs is actually a multi-valued configuration variable, so following example is also correct and the result is the same as of the snippet above:</source>
          <target state="translated">gitweb.extraBranchRefs实际上是一个多值的配置变量,所以下面的例子也是正确的,结果和上面的片段一样。</target>
        </trans-unit>
        <trans-unit id="ab9a5e4603e46ba18e0a4c5efe881c7ac8def35b" translate="yes" xml:space="preserve">
          <source>The given URL is recorded into &lt;code&gt;.gitmodules&lt;/code&gt; for use by subsequent users cloning the superproject. If the URL is given relative to the superproject&amp;rsquo;s repository, the presumption is the superproject and submodule repositories will be kept together in the same relative location, and only the superproject&amp;rsquo;s URL needs to be provided. git-submodule will correctly locate the submodule using the relative URL in &lt;code&gt;.gitmodules&lt;/code&gt;.</source>
          <target state="translated">给定的URL被记录到 &lt;code&gt;.gitmodules&lt;/code&gt; 中，供后续用户克隆超级项目使用。如果URL是相对于超级项目的存储库给出的，则假定超级项目和子模块存储库将被放置在相同的相对位置，并且仅需提供超级项目的URL。git-submodule将使用 &lt;code&gt;.gitmodules&lt;/code&gt; 中的相对URL正确定位子模块。</target>
        </trans-unit>
        <trans-unit id="1190edfebfe2406cf333713a0e461379865b033f" translate="yes" xml:space="preserve">
          <source>The goal of this tutorial is to introduce two fundamental pieces of Git&amp;rsquo;s architecture&amp;mdash;​the object database and the index file&amp;mdash;​and to provide the reader with everything necessary to understand the rest of the Git documentation.</source>
          <target state="translated">本教程的目的是介绍Git体系结构的两个基本部分-对象数据库和索引文件-并为读者提供理解其余Git文档所需的一切。</target>
        </trans-unit>
        <trans-unit id="880a291c14c1099392ebdd9b73ec08c93b7220d1" translate="yes" xml:space="preserve">
          <source>The hard case</source>
          <target state="translated">硬壳</target>
        </trans-unit>
        <trans-unit id="71b4cfb50bd8944708a6926991c13ef0bfbac07d" translate="yes" xml:space="preserve">
          <source>The hashes are 40 hex characters long. When Git upgrades to a new hash algorithm, this might need to be updated. (It should match whatever index-pack outputs after &quot;pack\t&quot; or &quot;keep\t&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2a187748caf680c0e66173f60176ec60ea02ab" translate="yes" xml:space="preserve">
          <source>The header consists of 256 4-byte network byte order integers. N-th entry of this table records the number of objects in the corresponding pack, the first byte of whose object name is less than or equal to N. This is called the &lt;code&gt;first-level fan-out&lt;/code&gt; table.</source>
          <target state="translated">标头由256个4字节网络字节顺序整数组成。该表的第N个条目记录相应数据包中的对象数，其对象名称的第一个字节小于或等于N。这称为 &lt;code&gt;first-level fan-out&lt;/code&gt; 表。</target>
        </trans-unit>
        <trans-unit id="0e2dd021a6a8dc94bfb40a62a04904f17b8f1dab" translate="yes" xml:space="preserve">
          <source>The header is followed by number of object entries, each of which looks like this:</source>
          <target state="translated">头部后面是对象项的数量,每个对象项的样子是这样的。</target>
        </trans-unit>
        <trans-unit id="10743ced5c1563e940127b440ba806235a399ac8" translate="yes" xml:space="preserve">
          <source>The header is followed by sorted 24-byte entries, one entry per object in the pack. Each entry is:</source>
          <target state="translated">头部后面是经过排序的24字节条目,包中每个对象一个条目。每个条目是:</target>
        </trans-unit>
        <trans-unit id="03910dca7f1c0af7f3d0e6986f455aceaec86f05" translate="yes" xml:space="preserve">
          <source>The header of the email is configurable via command-line options. If not specified on the command line, the user will be prompted with a ReadLine enabled interface to provide the necessary information.</source>
          <target state="translated">电子邮件的标题可以通过命令行选项进行配置。如果没有在命令行中指定,用户将被提示使用ReadLine接口来提供必要的信息。</target>
        </trans-unit>
        <trans-unit id="53d28fdf80ee055eff1005765033449c285d4f79" translate="yes" xml:space="preserve">
          <source>The hook always runs after the automatic note copying (see &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) has happened, and thus has access to these notes.</source>
          <target state="translated">挂钩总是在自动注释复制后运行（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]中的&lt;/a&gt; &amp;ldquo; notes.rewrite。&amp;lt;command&amp;gt;&amp;rdquo; ），因此可以访问这些注释。</target>
        </trans-unit>
        <trans-unit id="55997df4465d2b793292e1300e70ff2f9e1a3588" translate="yes" xml:space="preserve">
          <source>The hook executes once for each ref to be updated, and takes three parameters:</source>
          <target state="translated">钩子对每一个要更新的 ref 执行一次,需要三个参数。</target>
        </trans-unit>
        <trans-unit id="7918f32150a1e75fa34aeef2474d601c36b3a718" translate="yes" xml:space="preserve">
          <source>The hook is allowed to edit the changelist file and can be used to normalize the text into some project standard format. It can also be used to refuse the Submit after inspect the message file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6422fdbff7a8b80abf6e11b9c756369981239875" translate="yes" xml:space="preserve">
          <source>The hook is allowed to edit the message file in place, and can be used to normalize the message into some project standard format. It can also be used to refuse the commit after inspecting the message file.</source>
          <target state="translated">该钩子允许在原地编辑消息文件,并可用于将消息规范为某种项目标准格式。也可以用来在检查完消息文件后拒绝提交。</target>
        </trans-unit>
        <trans-unit id="7dd8785c8f6fdd3a8a45999afa9f773631b556f1" translate="yes" xml:space="preserve">
          <source>The hook receives a list of the rewritten commits on stdin, in the format</source>
          <target state="translated">钩子在 stdin 上接收重写的提交列表,格式为</target>
        </trans-unit>
        <trans-unit id="ffb0d43685532aa46e893849969758ab23367451" translate="yes" xml:space="preserve">
          <source>The hook receives the commit with which the tip of the current branch is going to be updated. It can exit with a non-zero status to refuse the push (when it does so, it must not modify the index or the working tree). Or it can make any necessary changes to the working tree and to the index to bring them to the desired state when the tip of the current branch is updated to the new commit, and exit with a zero status.</source>
          <target state="translated">钩子接收提交,当前分支的顶端将被更新。它可以以非零状态退出,拒绝推送(当它这样做时,它不能修改索引或工作树)。或者它可以对工作树和索引进行必要的修改,以便在当前分支的顶端更新到新的提交时,使它们达到所需的状态,然后以零状态退出。</target>
        </trans-unit>
        <trans-unit id="6e0236cadc345b5114c4c6984e7438ed153e1f2f" translate="yes" xml:space="preserve">
          <source>The hook should exit with non-zero status if it wants to disallow updating the named ref. Otherwise it should exit with zero.</source>
          <target state="translated">如果钩子要禁止更新命名的 ref,它应该以非零状态退出。否则应该以零退出。</target>
        </trans-unit>
        <trans-unit id="9739d79c49b82b53238e48aeefee9c342d93a499" translate="yes" xml:space="preserve">
          <source>The hook should output to stdout the list of all files in the working directory that may have changed since the requested time. The logic should be inclusive so that it does not miss any potential changes. The paths should be relative to the root of the working directory and be separated by a single NUL.</source>
          <target state="translated">钩子应该将工作目录中自请求时间以来可能发生变化的所有文件列表输出到stdp。这个逻辑应该是包容的,这样就不会错过任何潜在的变化。路径应该是相对于工作目录的根目录的,并且用一个NUL分隔。</target>
        </trans-unit>
        <trans-unit id="726cd696e8b088103d80193483306d60860caef4" translate="yes" xml:space="preserve">
          <source>The hook takes exactly one argument, which is the current state the given reference transaction is in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022998a9843b7be307eb2d587f13704cf2ce86bd" translate="yes" xml:space="preserve">
          <source>The horizontal line of history A---Q is taken to be the first parent of each merge. The commits are:</source>
          <target state="translated">历史上的横线A---Q取为每次合并的第一个父级。提交的内容是:</target>
        </trans-unit>
        <trans-unit id="41f47ff55448de90533c1d6461f6a54aa470a338" translate="yes" xml:space="preserve">
          <source>The human-readable name used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;author.name&lt;/code&gt; configuration settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a50b3e42cc3505776fea766e525fbf7e68884e" translate="yes" xml:space="preserve">
          <source>The human-readable name used in the committer identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;committer.name&lt;/code&gt; configuration settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf0ebdfb4273a6fce7952dfa28834b6e411cd7f" translate="yes" xml:space="preserve">
          <source>The hypothetical proxy command entries actually have a postfix to discern what URL they apply to. Here is how to change the entry for kernel.org to &quot;ssh&quot;.</source>
          <target state="translated">假设的代理命令条目实际上有一个后缀来辨别它们适用于什么URL。下面是如何将kernel.org的条目改为 &quot;ssh&quot;。</target>
        </trans-unit>
        <trans-unit id="4399284bfb632a08cce3f3533db563320f49af23" translate="yes" xml:space="preserve">
          <source>The id of a tree object to diff against.</source>
          <target state="translated">要对比的树对象的id。</target>
        </trans-unit>
        <trans-unit id="0505b9e9f78e78efa1c8b76bc422638cba05b1b7" translate="yes" xml:space="preserve">
          <source>The id of a tree object.</source>
          <target state="translated">树对象的id。</target>
        </trans-unit>
        <trans-unit id="2e60e84271eec03fd28b067b32c84bb5fbe76999" translate="yes" xml:space="preserve">
          <source>The id of the tree object(s) to be read/merged.</source>
          <target state="translated">要读取/合并的树对象的id。</target>
        </trans-unit>
        <trans-unit id="fb9074ec22bab96e3e97d4855db9bfaed224187c" translate="yes" xml:space="preserve">
          <source>The idea is that every 3 test for example, &quot;git bisect&quot; could ask the user to test a commit that has already been found to be &quot;good&quot; or &quot;bad&quot; (because one of its descendants or one of its ancestors has been found to be &quot;good&quot; or &quot;bad&quot; respectively). If it happens that a commit has been previously incorrectly classified then the bisection can be aborted early, hopefully before too many mistakes have been made. Then the user will have to look at what happened and then restart the bisection using a fixed bisect log.</source>
          <target state="translated">我们的想法是,每隔 3 次测试,例如,&quot;git bisect &quot;可以要求用户测试一个已经被发现是 &quot;好 &quot;或 &quot;坏 &quot;的提交(因为它的一个后代或它的一个祖先分别被发现是 &quot;好 &quot;或 &quot;坏&quot;)。如果碰巧一个提交之前已经被错误地分类,那么可以提前中止二分法,希望是在犯了太多错误之前。然后,用户必须查看发生了什么,然后使用固定的二分法日志重新开始二分法。</target>
        </trans-unit>
        <trans-unit id="b3a07b8c786a1b03697e9ded467b22cd2ece1ab4" translate="yes" xml:space="preserve">
          <source>The idea is to manually tell &lt;code&gt;git rebase&lt;/code&gt; &quot;where the old &lt;code&gt;subsystem&lt;/code&gt; ended and your &lt;code&gt;topic&lt;/code&gt; began&quot;, that is, what the old merge base between them was. You will have to find a way to name the last commit of the old &lt;code&gt;subsystem&lt;/code&gt;, for example:</source>
          <target state="translated">这个想法是手动告诉 &lt;code&gt;git rebase&lt;/code&gt; &amp;ldquo;旧 &lt;code&gt;subsystem&lt;/code&gt; 在哪里结束并且您的 &lt;code&gt;topic&lt;/code&gt; 开始了&amp;rdquo;，即它们之间的旧合并基础是什么。您将必须找到一种方法来命名旧 &lt;code&gt;subsystem&lt;/code&gt; 的最后一次提交，例如：</target>
        </trans-unit>
        <trans-unit id="1ff2a3a30d68d12ef6b058f357f43e3bd9cd4f0f" translate="yes" xml:space="preserve">
          <source>The idx files to verify.</source>
          <target state="translated">要核实的idx文件。</target>
        </trans-unit>
        <trans-unit id="fd29bd486dc43b124e6d98a808e18b86c2905ae4" translate="yes" xml:space="preserve">
          <source>The import checks out from CVS every revision of every file. Reportedly cvsimport can average some twenty revisions per second, so for a medium-sized project this should not take more than a couple of minutes. Larger projects or remote repositories may take longer.</source>
          <target state="translated">导入会从 CVS 中检查出每个文件的每一次修订。据报道,cvsimport 平均每秒可以修改 20 个版本,所以对于一个中等规模的项目来说,这应该不会超过几分钟。更大的项目或远程仓库可能需要更长的时间。</target>
        </trans-unit>
        <trans-unit id="69f04e00f7076b8b130e67c7134e53f7f1076bf2" translate="yes" xml:space="preserve">
          <source>The import is incremental, so if you call it again next month it will fetch any CVS updates that have been made in the meantime. For this to work, you must not modify the imported branches; instead, create new branches for your own changes, and merge in the imported branches as necessary.</source>
          <target state="translated">导入是增量式的,所以如果您下个月再调用它,它将获取在此期间所做的任何 CVS 更新。为了使这个方法有效,你不能修改导入的分支;相反,你必须为你自己的修改创建新的分支,并在必要时合并导入的分支。</target>
        </trans-unit>
        <trans-unit id="807035ab1f5be4f0cb3563dc9b49740571ca0fa4" translate="yes" xml:space="preserve">
          <source>The index</source>
          <target state="translated">该指数</target>
        </trans-unit>
        <trans-unit id="4284ed429265f3c1afc30e4fc09197d88352698c" translate="yes" xml:space="preserve">
          <source>The index and the working tree are adjusted as if you had previously run &lt;code&gt;git checkout &amp;lt;start_point&amp;gt;&lt;/code&gt;. This allows you to start a new history that records a set of paths similar to &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; by easily running &lt;code&gt;git commit -a&lt;/code&gt; to make the root commit.</source>
          <target state="translated">就像您以前运行 &lt;code&gt;git checkout &amp;lt;start_point&amp;gt;&lt;/code&gt; 一样，将调整索引和工作树。这样，您可以轻松运行 &lt;code&gt;git commit -a&lt;/code&gt; 进行根提交，从而开始一个新的历史记录，该记录记录了一组类似于 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 的路径。</target>
        </trans-unit>
        <trans-unit id="0818281aa21612fb5fa362015c64c5645d861084" translate="yes" xml:space="preserve">
          <source>The index contains all the information necessary to generate a single (uniquely determined) tree object.</source>
          <target state="translated">该索引包含了生成单个(唯一确定的)树对象的所有必要信息。</target>
        </trans-unit>
        <trans-unit id="3d9fb9e020c0d003a42d72f87f16ba2ba38226e6" translate="yes" xml:space="preserve">
          <source>The index enables fast comparisons between the tree object it defines and the working tree.</source>
          <target state="translated">该索引可以实现它定义的树对象和工作树之间的快速比较。</target>
        </trans-unit>
        <trans-unit id="eb65460c6179ccddcd4479166e9da44d8f5c40d8" translate="yes" xml:space="preserve">
          <source>The index file</source>
          <target state="translated">索引文件</target>
        </trans-unit>
        <trans-unit id="181ab401ce7a15640077d5cb413c24fc6eb6a97e" translate="yes" xml:space="preserve">
          <source>The index file is a cache of the state of a directory tree, used to create commits, check out working directories, and hold the various trees involved in a merge.</source>
          <target state="translated">索引文件是一个目录树状态的缓存,用于创建提交,检查工作目录,并保存合并中涉及的各种树。</target>
        </trans-unit>
        <trans-unit id="a98935eae61bfe66b9928e790965f624bf2f8b5b" translate="yes" xml:space="preserve">
          <source>The index file is initialized with a list of all paths and, for each path, a blob object and a set of attributes. The blob object represents the contents of the file as of the head of the current branch. The attributes (last modified time, size, etc.) are taken from the corresponding file in the working tree. Subsequent changes to the working tree can be found by comparing these attributes. The index may be updated with new content, and new commits may be created from the content stored in the index.</source>
          <target state="translated">索引文件用所有路径的列表和每个路径的blob对象和一组属性来初始化。blob对象表示当前分支头部的文件内容。属性(最后修改的时间、大小等)取自工作树中的相应文件。通过比较这些属性可以发现工作树的后续变化。索引可以用新的内容更新,也可以从索引中存储的内容创建新的提交。</target>
        </trans-unit>
        <trans-unit id="803387e9a63472a3287bdc2446032cf6e023e1d9" translate="yes" xml:space="preserve">
          <source>The index is a binary file (generally kept in &lt;code&gt;.git/index&lt;/code&gt;) containing a sorted list of path names, each with permissions and the SHA-1 of a blob object; &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; can show you the contents of the index:</source>
          <target state="translated">索引是一个二进制文件（通常保存在 &lt;code&gt;.git/index&lt;/code&gt; 中），其中包含路径名的排序列表，每个路径名均具有权限和blob对象的SHA-1；&lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]&lt;/a&gt;可以向您显示索引的内容：</target>
        </trans-unit>
        <trans-unit id="a9316182499a37d7c3626ac01aa8aab4c013b473" translate="yes" xml:space="preserve">
          <source>The index is also capable of storing multiple entries (called &quot;stages&quot;) for a given pathname. These stages are used to hold the various unmerged version of a file when a merge is in progress.</source>
          <target state="translated">索引还能够为一个给定的路径名存储多个条目(称为 &quot;阶段&quot;)。这些阶段用于在合并过程中保存文件的各种未合并版本。</target>
        </trans-unit>
        <trans-unit id="188f5a2d7cb942916f4771a1884b995e88b4142c" translate="yes" xml:space="preserve">
          <source>The index is thus a sort of temporary staging area, which is filled with a tree which you are in the process of working on.</source>
          <target state="translated">因此,索引是一种临时的中转站,里面装的是你正在做的一棵树。</target>
        </trans-unit>
        <trans-unit id="272f4c7f98ef3d0d8ac3fea3ee0b1455507c7b6c" translate="yes" xml:space="preserve">
          <source>The index is updated after successful completion, but the change must still be committed.</source>
          <target state="translated">成功完成后,索引会被更新,但更改仍然必须被提交。</target>
        </trans-unit>
        <trans-unit id="aaf3f3d73cad6f7ed8d83d0912688100fa696756" translate="yes" xml:space="preserve">
          <source>The index line includes the blob object names before and after the change. The &amp;lt;mode&amp;gt; is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.</source>
          <target state="translated">索引行包含更改前后的Blob对象名称。如果文件模式未更改，则包含&amp;lt;mode&amp;gt;；否则，将显示&amp;lt;mode&amp;gt;。否则，单独的行指示旧模式和新模式。</target>
        </trans-unit>
        <trans-unit id="0c2192b5aebec33a414387c35e4e32f7ffc2561e" translate="yes" xml:space="preserve">
          <source>The index may contain unmerged entries because of a previous failed merge. By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out. Using &lt;code&gt;-f&lt;/code&gt; will ignore these unmerged entries. The contents from a specific side of the merge can be checked out of the index by using &lt;code&gt;--ours&lt;/code&gt; or &lt;code&gt;--theirs&lt;/code&gt;. With &lt;code&gt;-m&lt;/code&gt;, changes made to the working tree file can be discarded to re-create the original conflicted merge result.</source>
          <target state="translated">由于先前合并失败，索引可能包含未合并的条目。默认情况下，如果您尝试从索引中检出此类条目，则检出操作将失败并且将不检出任何内容。使用 &lt;code&gt;-f&lt;/code&gt; 将忽略这些未合并的条目。可以使用 &lt;code&gt;--ours&lt;/code&gt; 或 &lt;code&gt;--theirs&lt;/code&gt; 从合并的特定方面将内容从索引中检出。使用 &lt;code&gt;-m&lt;/code&gt; ，可以放弃对工作树文件的更改以重新创建原始的冲突合并结果。</target>
        </trans-unit>
        <trans-unit id="4d0d51f29d49355316c3cef38c96a8eb5dfc2a8a" translate="yes" xml:space="preserve">
          <source>The index must be in a fully merged state.</source>
          <target state="translated">索引必须处于完全合并的状态。</target>
        </trans-unit>
        <trans-unit id="76af7fc7918327fcfae98949c1f8a57aa6273691" translate="yes" xml:space="preserve">
          <source>The information &lt;code&gt;git rerere&lt;/code&gt; records is also used when running &lt;code&gt;git rebase&lt;/code&gt;. After blowing away the test merge and continuing development on the topic branch:</source>
          <target state="translated">运行 &lt;code&gt;git rebase&lt;/code&gt; 时也会使用信息 &lt;code&gt;git rerere&lt;/code&gt; 记录。在完成测试合并并继续在主题分支上进行开发之后：</target>
        </trans-unit>
        <trans-unit id="15901a24c7f8cf8a87522005a6e5af387df87a55" translate="yes" xml:space="preserve">
          <source>The information regarding a particular file, stored in the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;. An index entry can be unmerged, if a &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; was started, but not yet finished (i.e. if the index contains multiple versions of that file).</source>
          <target state="translated">有关特定文件的信息，存储在&lt;a href=&quot;#def_index&quot;&gt;索引中&lt;/a&gt;。如果&lt;a href=&quot;#def_merge&quot;&gt;合并&lt;/a&gt;开始但尚未完成（例如，如果索引包含该文件的多个版本），则可以取消合并索引条目。</target>
        </trans-unit>
        <trans-unit id="e1b41d54924f3d005ef481db0b83a44bcb5b9a26" translate="yes" xml:space="preserve">
          <source>The initial &lt;code&gt;git svn clone&lt;/code&gt; can be quite time-consuming (especially for large Subversion repositories). If multiple people (or one person with multiple machines) want to use &lt;code&gt;git svn&lt;/code&gt; to interact with the same Subversion repository, you can do the initial &lt;code&gt;git svn clone&lt;/code&gt; to a repository on a server and have each person clone that repository with &lt;code&gt;git clone&lt;/code&gt;:</source>
          <target state="translated">最初的 &lt;code&gt;git svn clone&lt;/code&gt; 可能非常耗时（特别是对于大型Subversion存储库）。如果多个人（或一个拥有多台计算机的人）想要使用 &lt;code&gt;git svn&lt;/code&gt; 与同一个Subversion存储库进行交互，则可以将 &lt;code&gt;git svn clone&lt;/code&gt; 初始克隆到服务器上的存储库，并让每个人使用 &lt;code&gt;git clone&lt;/code&gt; 克隆该存储库：</target>
        </trans-unit>
        <trans-unit id="086eba2d4da1f4350d7506d860bddbb6a3656718" translate="yes" xml:space="preserve">
          <source>The initial clone may be time-consuming for a large project, but you will only need to clone once.</source>
          <target state="translated">对于一个大型项目来说,初始克隆可能会很耗时,但你只需要克隆一次。</target>
        </trans-unit>
        <trans-unit id="de40e4660568a286f9924fcf84aa107b9295fcd9" translate="yes" xml:space="preserve">
          <source>The initial revision lays the foundation for almost everything Git has today, but is small enough to read in one sitting.</source>
          <target state="translated">初次修订奠定了今天Git几乎所有的基础,但体积小,可以一次读完。</target>
        </trans-unit>
        <trans-unit id="c62040180edff3420ed3a70f2f1e520bccaa26ac" translate="yes" xml:space="preserve">
          <source>The insane thing. You really want to call the new version &quot;X&quot; too, &lt;code&gt;even though&lt;/code&gt; others have already seen the old one. So just use &lt;code&gt;git tag -f&lt;/code&gt; again, as if you hadn&amp;rsquo;t already published the old one.</source>
          <target state="translated">疯了 您真的也想将新版本称为&amp;ldquo; X&amp;rdquo;， &lt;code&gt;even though&lt;/code&gt; 其他人已经看到了旧版本。因此，只需再次使用 &lt;code&gt;git tag -f&lt;/code&gt; ，就好像您尚未发布旧版本一样。</target>
        </trans-unit>
        <trans-unit id="861707a12241605e66eb9230fb32f3c54a08448e" translate="yes" xml:space="preserve">
          <source>The intent of this option is to pick and choose lines of the patch to apply, or even to modify the contents of lines to be staged. This can be quicker and more flexible than using the interactive hunk selector. However, it is easy to confuse oneself and create a patch that does not apply to the index. See EDITING PATCHES below.</source>
          <target state="translated">这个选项的意图是挑选要应用补丁的行,甚至修改要分期的行的内容。这可以比使用交互式的块状选择器更快、更灵活。但是,很容易混淆自己的视线,创建一个不适用索引的补丁。参见下面的编辑补丁。</target>
        </trans-unit>
        <trans-unit id="44c76b656c6ccb35aba2b96c920b5e782121a3bc" translate="yes" xml:space="preserve">
          <source>The interactive backend drops commits by default that started empty and halts if it hits a commit that ended up empty. The &lt;code&gt;--keep-empty&lt;/code&gt; option exists for the interactive backend to allow it to keep commits that started empty.</source>
          <target state="translated">交互式后端默认丢弃开始为空的提交，如果命中最终为空的提交则停止。该 &lt;code&gt;--keep-empty&lt;/code&gt; 选项存在互动后端以使其保持这一开始空提交。</target>
        </trans-unit>
        <trans-unit id="c4d1b3aab1a5f39909af0bdb9766437575ff6138" translate="yes" xml:space="preserve">
          <source>The interactive mode is meant for this type of workflow:</source>
          <target state="translated">交互式模式就是针对这类工作流程的。</target>
        </trans-unit>
        <trans-unit id="bed5d62a356c4ef72d5d10899b110555c8810a69" translate="yes" xml:space="preserve">
          <source>The interactive rebase command was originally designed to handle individual patch series. As such, it makes sense to exclude merge commits from the todo list, as the developer may have merged the then-current &lt;code&gt;master&lt;/code&gt; while working on the branch, only to rebase all the commits onto &lt;code&gt;master&lt;/code&gt; eventually (skipping the merge commits).</source>
          <target state="translated">交互式rebase命令最初旨在处理各个修补程序系列。因此，将合并提交从待办事项列表中排除是有意义的，因为开发人员在分支上工作时可能已经合并了当时的 &lt;code&gt;master&lt;/code&gt; ，最终只是将所有提交重新基于 &lt;code&gt;master&lt;/code&gt; （跳过合并提交）。</target>
        </trans-unit>
        <trans-unit id="54aff08446e09f30da133e329eb3f3646033c66c" translate="yes" xml:space="preserve">
          <source>The interactive rebase will stop when a command fails (i.e. exits with non-0 status) to give you an opportunity to fix the problem. You can continue with &lt;code&gt;git rebase --continue&lt;/code&gt;.</source>
          <target state="translated">当命令失败（即以非0状态退出）时，交互式知识库将停止，从而为您提供解决问题的机会。您可以继续 &lt;code&gt;git rebase --continue&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a7f537099e4a0d8d8faba9c5e743d565b88b9dd" translate="yes" xml:space="preserve">
          <source>The interface (input, output, set of options and the semantics) to these low-level commands are meant to be a lot more stable than Porcelain level commands, because these commands are primarily for scripted use. The interface to Porcelain commands on the other hand are subject to change in order to improve the end user experience.</source>
          <target state="translated">这些低级命令的接口(输入、输出、选项集和语义)要比Porcelain级别的命令稳定得多,因为这些命令主要是供脚本使用的。另一方面,为了改善最终用户的体验,Porcelain命令的接口是可以改变的。</target>
        </trans-unit>
        <trans-unit id="bf907bc1bbd0905aa866d8781057341315704641" translate="yes" xml:space="preserve">
          <source>The internal block size to use when converting a revision specifier such as &lt;code&gt;@all&lt;/code&gt; into a list of specific change numbers. Instead of using a single call to &lt;code&gt;p4 changes&lt;/code&gt; to find the full list of changes for the conversion, there are a sequence of calls to &lt;code&gt;p4 changes -m&lt;/code&gt;, each of which requests one block of changes of the given size. The default block size is 500, which should usually be suitable.</source>
          <target state="translated">将修订说明符（例如 &lt;code&gt;@all&lt;/code&gt; )转换为特定更改编号列表时要使用的内部块大小。除了使用单个对 &lt;code&gt;p4 changes&lt;/code&gt; 调用来查找转换的完整列表之外，还有一系列对 &lt;code&gt;p4 changes -m&lt;/code&gt; 的调用，每个调用都请求一个给定大小的更改块。默认的块大小是500，通常应该合适。</target>
        </trans-unit>
        <trans-unit id="b58ee91a98701b75ecd0edc6713c67b3efbc3330" translate="yes" xml:space="preserve">
          <source>The internals are documented in the &lt;a href=&quot;api-index&quot;&gt;Git API documentation&lt;/a&gt;.</source>
          <target state="translated">内部信息记录在&lt;a href=&quot;api-index&quot;&gt;Git API文档中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52e0ef5f6de2b43e809ff876c18bbee69e575471" translate="yes" xml:space="preserve">
          <source>The key may contain any bytes except &lt;code&gt;=&lt;/code&gt;, newline, or NUL. The value may contain any bytes except newline or NUL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051387312310d89e1f2cd1a7644ba37793a94a7c" translate="yes" xml:space="preserve">
          <source>The known attack vectors are as follows:</source>
          <target state="translated">已知的攻击载体如下:</target>
        </trans-unit>
        <trans-unit id="d0880a7ce92ec68d75b7997f1b8b330766294029" translate="yes" xml:space="preserve">
          <source>The lack of a central group of &quot;committers&quot; means there is less need for formal decisions about who is &quot;in&quot; and who is &quot;out&quot;.</source>
          <target state="translated">缺乏一个 &quot;承诺者 &quot;的中心小组,意味着不需要正式决定谁 &quot;加入 &quot;和谁 &quot;退出&quot;。</target>
        </trans-unit>
        <trans-unit id="d217f82f775261a888c8090d4fd57de90a2943db" translate="yes" xml:space="preserve">
          <source>The last diff is empty, but no new commits have been made, and the head still doesn&amp;rsquo;t contain the new line:</source>
          <target state="translated">最后一个差异为空，但未进行任何新的提交，并且头仍不包含新行：</target>
        </trans-unit>
        <trans-unit id="fc6ae42476a6037281df209d5a37adfb042c084d" translate="yes" xml:space="preserve">
          <source>The last three commits (&lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;HEAD^&lt;/code&gt;, and &lt;code&gt;HEAD~2&lt;/code&gt;) were bad and you do not want to ever see them again. Do &lt;strong&gt;not&lt;/strong&gt; do this if you have already given these commits to somebody else. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for the implications of doing so.)</source>
          <target state="translated">最后三个提交（ &lt;code&gt;HEAD&lt;/code&gt; ， &lt;code&gt;HEAD^&lt;/code&gt; 和 &lt;code&gt;HEAD~2&lt;/code&gt; ）很糟糕，您不想再看到它们。难道&lt;strong&gt;不是&lt;/strong&gt;如果你已经给了这些提交给别人做。 （有关这样做的含义，请参见&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]中&lt;/a&gt;的&amp;ldquo;从UPSTREAM REBASE恢复&amp;rdquo;一节。）</target>
        </trans-unit>
        <trans-unit id="9b2685798225cd4befed46a027cdbd30eb245ee2" translate="yes" xml:space="preserve">
          <source>The latest stash you created is stored in &lt;code&gt;refs/stash&lt;/code&gt;; older stashes are found in the reflog of this reference and can be named using the usual reflog syntax (e.g. &lt;code&gt;stash@{0}&lt;/code&gt; is the most recently created stash, &lt;code&gt;stash@{1}&lt;/code&gt; is the one before it, &lt;code&gt;stash@{2.hours.ago}&lt;/code&gt; is also possible). Stashes may also be referenced by specifying just the stash index (e.g. the integer &lt;code&gt;n&lt;/code&gt; is equivalent to &lt;code&gt;stash@{n}&lt;/code&gt;).</source>
          <target state="translated">您创建的最新存储存储在 &lt;code&gt;refs/stash&lt;/code&gt; 中；在此引用的引用日志中可以找到较旧的隐藏项，并且可以使用常规引用日志语法进行命名（例如， &lt;code&gt;stash@{0}&lt;/code&gt; 是最新创建的隐藏项， &lt;code&gt;stash@{1}&lt;/code&gt; 是之前 &lt;code&gt;stash@{2.hours.ago}&lt;/code&gt; ）。还可以通过仅指定存储索引来引用存储（例如，整数 &lt;code&gt;n&lt;/code&gt; 等于 &lt;code&gt;stash@{n}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8bb7601b8118e6905d96f76a29452df6bc2ae98e" translate="yes" xml:space="preserve">
          <source>The latter is not available by default, unless configured.</source>
          <target state="translated">后者在默认情况下不可用,除非配置。</target>
        </trans-unit>
        <trans-unit id="9096be046e467fbce79d2a6fe63b310a7a8be174" translate="yes" xml:space="preserve">
          <source>The latter use of the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values can be overridden by giving the &lt;code&gt;--refmap=&amp;lt;refspec&amp;gt;&lt;/code&gt; parameter(s) on the command line.</source>
          <target state="translated">可以通过在命令行上提供 &lt;code&gt;--refmap=&amp;lt;refspec&amp;gt;&lt;/code&gt; 参数来覆盖对 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 值的后者使用。</target>
        </trans-unit>
        <trans-unit id="55ffd562f6b8b4abf7958d261df418cb81ead100" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, to retry when trying to lock an individual reference. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 100 (i.e., retry for 100ms).</source>
          <target state="translated">当试图锁定一个单独的引用时,重试的时间长度,以毫秒为单位。值0表示完全不重试;-1表示无限期重试。默认值为100(即重试100毫秒)。</target>
        </trans-unit>
        <trans-unit id="68a6d4f84896f5fe182696f59cffd1c668106a0a" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, to retry when trying to lock the &lt;code&gt;packed-refs&lt;/code&gt; file. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 1000 (i.e., retry for 1 second).</source>
          <target state="translated">尝试锁定 &lt;code&gt;packed-refs&lt;/code&gt; 文件时重试的时间长度（以毫秒为单位）。值0表示完全不重试；-1表示无限期尝试。默认值为1000（即重试1秒）。</target>
        </trans-unit>
        <trans-unit id="fff6cc41c6311b04938a1f36a103054a2f1d2e11" translate="yes" xml:space="preserve">
          <source>The list above is ordered by decreasing precedence; a URL that matches a config key&amp;rsquo;s path is preferred to one that matches its user name. For example, if the URL is &lt;code&gt;https://user@example.com/foo/bar&lt;/code&gt; a config key match of &lt;code&gt;https://example.com/foo&lt;/code&gt; will be preferred over a config key match of &lt;code&gt;https://user@example.com&lt;/code&gt;.</source>
          <target state="translated">上面的列表通过降低优先级进行排序；与配置键的路径匹配的URL优先于与用户名匹配的URL。例如，如果URL是 &lt;code&gt;https://user@example.com/foo/bar&lt;/code&gt; 的一个配置密钥匹配 &lt;code&gt;https://example.com/foo&lt;/code&gt; 将优于的一个配置关键匹配 &lt;code&gt;https://user@example.com&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34cf6a4a25da733f5b8366288a8f31ad385fa0ee" translate="yes" xml:space="preserve">
          <source>The list of identifiers, and other information, of the objects in a &lt;a href=&quot;#def_pack&quot;&gt;pack&lt;/a&gt;, to assist in efficiently accessing the contents of a pack.</source>
          <target state="translated">&lt;a href=&quot;#def_pack&quot;&gt;包中&lt;/a&gt;对象的标识符列表和其他信息，以帮助有效地访问包中的内容。</target>
        </trans-unit>
        <trans-unit id="58413b6422259538de8b3cfc5351841a4fb3ade2" translate="yes" xml:space="preserve">
          <source>The list of mailbox files to read patches from. If you do not supply this argument, the command reads from the standard input. If you supply directories, they will be treated as Maildirs.</source>
          <target state="translated">要读取补丁的邮箱文件列表。如果你不提供这个参数,命令将从标准输入中读取。如果你提供了目录,它们将被视为Maildirs。</target>
        </trans-unit>
        <trans-unit id="811a0eecf6c6689902c9fc1e00fe667f20b10132" translate="yes" xml:space="preserve">
          <source>The list of remotes which are fetched by &quot;git remote update &amp;lt;group&amp;gt;&quot;. See &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">由&amp;ldquo; git remote update &amp;lt;组&amp;gt;&amp;rdquo;获取的远程列表。参见&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3aadf5969931435dfd81a576572d271c1b7df1e4" translate="yes" xml:space="preserve">
          <source>The list you get with &quot;ls&quot; :-)</source>
          <target state="translated">你用 &quot;ls &quot;得到的列表:-)</target>
        </trans-unit>
        <trans-unit id="2d5bfecbee3eeb5c71f69bd43de88bc34222a07d" translate="yes" xml:space="preserve">
          <source>The local offset is specified by &lt;code&gt;&amp;lt;offutc&amp;gt;&lt;/code&gt; as a positive or negative offset from UTC. For example EST (which is 5 hours behind UTC) would be expressed in &lt;code&gt;&amp;lt;tz&amp;gt;&lt;/code&gt; by &amp;ldquo;-0500&amp;rdquo; while UTC is &amp;ldquo;+0000&amp;rdquo;. The local offset does not affect &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;; it is used only as an advisement to help formatting routines display the timestamp.</source>
          <target state="translated">&lt;code&gt;&amp;lt;offutc&amp;gt;&lt;/code&gt; 将本地偏移量指定为相对于UTC的正偏移量或负偏移量。例如，EST（比UTC晚5小时）将以 &lt;code&gt;&amp;lt;tz&amp;gt;&lt;/code&gt; 表示为&amp;ldquo; -0500&amp;rdquo;，而UTC是&amp;ldquo; +0000&amp;rdquo;。本地偏移量不影响 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; ；它仅用作建议，以帮助格式化例程显示时间戳。</target>
        </trans-unit>
        <trans-unit id="ab508d82c7d8a4545e2bb32ec9ec4fb2386a14cb" translate="yes" xml:space="preserve">
          <source>The location of an augmenting mailmap file. The default mailmap, located in the root of the repository, is loaded first, then the mailmap file pointed to by this variable. The location of the mailmap file may be in a repository subdirectory, or somewhere outside of the repository itself. See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">扩充邮件映射文件的位置。首先加载位于存储库根目录中的默认邮件映射，然后加载此变量指向的邮件映射文件。邮件映射文件的位置可以在存储库子目录中，也可以在存储库本身之外的某个位置。参见&lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt;和&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3bb0979c637e06c575b3f731f106ded5d4b916f" translate="yes" xml:space="preserve">
          <source>The location of per-instance and system-wide configuration files can be overridden using the following environment variables:</source>
          <target state="translated">可以使用以下环境变量覆盖每个实例和全系统配置文件的位置。</target>
        </trans-unit>
        <trans-unit id="9446c1e5cce4b2ece4fc10ff79540962e21c6551" translate="yes" xml:space="preserve">
          <source>The magic word &lt;code&gt;top&lt;/code&gt; (magic signature: &lt;code&gt;/&lt;/code&gt;) makes the pattern match from the root of the working tree, even when you are running the command from inside a subdirectory.</source>
          <target state="translated">魔术字 &lt;code&gt;top&lt;/code&gt; （魔术签名： &lt;code&gt;/&lt;/code&gt; ）使模式从工作树的根开始匹配，即使您是在子目录中运行命令也是如此。</target>
        </trans-unit>
        <trans-unit id="64ba77ac0581cbecc6b691422d0c5681817b2387" translate="yes" xml:space="preserve">
          <source>The main command loop has 6 subcommands (plus help and quit).</source>
          <target state="translated">主命令循环有6个子命令(加上帮助和退出)。</target>
        </trans-unit>
        <trans-unit id="0b0bee129956915b1cb776d4190a01b55932ed3c" translate="yes" xml:space="preserve">
          <source>The main command loop has 6 subcommands.</source>
          <target state="translated">主命令循环有6个子命令。</target>
        </trans-unit>
        <trans-unit id="821ddd85eba2b4bc6e95a82521b10b32287622db" translate="yes" xml:space="preserve">
          <source>The main trunk is stored in the Git branch named &lt;code&gt;origin&lt;/code&gt;, and additional CVS branches are stored in Git branches with the same names. The most recent version of the main trunk is also left checked out on the &lt;code&gt;master&lt;/code&gt; branch, so you can start adding your own changes right away.</source>
          <target state="translated">主干存储在名为 &lt;code&gt;origin&lt;/code&gt; 的Git分支中，其他CVS分支以相同的名称存储在Git分支中。主干线的最新版本还剩下签出的 &lt;code&gt;master&lt;/code&gt; 分支，这样你就可以开始添加你自己改变的时候了。</target>
        </trans-unit>
        <trans-unit id="f31023370321849385c22bc8ae521136bfffac45" translate="yes" xml:space="preserve">
          <source>The mapping of file names from the p4 depot path to Git, by default, involves removing the entire depot path. With this option, the full p4 depot path is retained in Git. For example, path &lt;code&gt;//depot/main/foo/bar.c&lt;/code&gt;, when imported from &lt;code&gt;//depot/main/&lt;/code&gt;, becomes &lt;code&gt;foo/bar.c&lt;/code&gt;. With &lt;code&gt;--keep-path&lt;/code&gt;, the Git path is instead &lt;code&gt;depot/main/foo/bar.c&lt;/code&gt;.</source>
          <target state="translated">默认情况下，从p4仓库路径到Git的文件名映射涉及删除整个仓库路径。使用此选项，完整的p4仓库路径将保留在Git中。例如，路径 &lt;code&gt;//depot/main/foo/bar.c&lt;/code&gt; ，从导入时 &lt;code&gt;//depot/main/&lt;/code&gt; 变得 &lt;code&gt;foo/bar.c&lt;/code&gt; 。与 &lt;code&gt;--keep-path&lt;/code&gt; ，所述路径GIT中是代替 &lt;code&gt;depot/main/foo/bar.c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="696795b724c116f40755fe0ffd2f815f95c8f529" translate="yes" xml:space="preserve">
          <source>The mark command is optional here as some frontends have chosen to generate the Git SHA-1 for the blob on their own, and feed that directly to &lt;code&gt;commit&lt;/code&gt;. This is typically more work than it&amp;rsquo;s worth however, as marks are inexpensive to store and easy to use.</source>
          <target state="translated">mark命令在这里是可选的，因为一些前端已经选择自行生成Blob的Git SHA-1，并直接将其 &lt;code&gt;commit&lt;/code&gt; 以进行提交。但是，由于标记的存储成本低且易于使用，因此这通常比值得的工作还要多。</target>
        </trans-unit>
        <trans-unit id="154d6f76415eae422478f55f25c1ddb853a4e1ab" translate="yes" xml:space="preserve">
          <source>The maximum delta depth used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; when no maximum depth is given on the command line. Defaults to 50. Maximum value is 4095.</source>
          <target state="translated">&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;在命令行上未指定最大深度时使用的最大增量深度。默认值为50。最大值为4095。</target>
        </trans-unit>
        <trans-unit id="9325da9117f9b4afd884e4f7e837bf9ca641172e" translate="yes" xml:space="preserve">
          <source>The maximum memory in bytes used for caching deltas in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; before writing them out to a pack. This cache is used to speed up the writing object phase by not having to recompute the final delta result once the best match for all objects is found. Repacking large repositories on machines which are tight with memory might be badly impacted by this though, especially if this cache pushes the system into swapping. A value of 0 means no limit. The smallest size of 1 byte may be used to virtually disable this cache. Defaults to 256 MiB.</source>
          <target state="translated">在将&lt;a href=&quot;git-pack-objects&quot;&gt;Delta-pack-objects [1]中的&lt;/a&gt;增量写入数据包之前，用于缓存增量的最大内存（以字节为单位）。一旦找到了所有对象的最佳匹配项，就不必重新计算最终的增量结果，此缓存可用于加快写入对象的阶段。但是，在内存紧张的计算机上重新打包大型存储库可能会受到严重影响，特别是如果此缓存将系统推向交换状态。值为0表示没有限制。 1字节的最小大小可用于虚拟禁用此缓存。默认为256 MiB。</target>
        </trans-unit>
        <trans-unit id="a0015a1c1a155cb39bc99dd58a785f6e45fb6909" translate="yes" xml:space="preserve">
          <source>The maximum size of a delta, that is cached in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This cache is used to speed up the writing object phase by not having to recompute the final delta result once the best match for all objects is found. Defaults to 1000. Maximum value is 65535.</source>
          <target state="translated">增量的最大大小，该大小缓存在&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]中&lt;/a&gt;。一旦找到所有对象的最佳匹配，就不必重新计算最终的增量结果，就可以使用该缓存来加快写入对象的阶段。默认值为1000。最大值为65535。</target>
        </trans-unit>
        <trans-unit id="d2696797b76aad16406d56dd354feaf085869327" translate="yes" xml:space="preserve">
          <source>The maximum size of a pack. This setting only affects packing to a file when repacking, i.e. the git:// protocol is unaffected. It can be overridden by the &lt;code&gt;--max-pack-size&lt;/code&gt; option of &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. Reaching this limit results in the creation of multiple packfiles; which in turn prevents bitmaps from being created. The minimum size allowed is limited to 1 MiB. The default is unlimited. Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">一包的最大尺寸。此设置仅在重新打包时影响打包到文件，即git：//协议不受影响。可以通过&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;的 &lt;code&gt;--max-pack-size&lt;/code&gt; 选项覆盖它。达到此限制将导致创建多个packfile；反过来又阻止了位图的创建。允许的最小大小限制为1 MiB。默认值为无限制。支持 &lt;code&gt;k&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; 或 &lt;code&gt;g&lt;/code&gt; 的通用单位后缀。</target>
        </trans-unit>
        <trans-unit id="bb8ed32c533714ca4a8bb85ec574c3c5791f3a2f" translate="yes" xml:space="preserve">
          <source>The maximum size of memory that is consumed by each thread in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for pack window memory when no limit is given on the command line. The value can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. When left unconfigured (or set explicitly to 0), there will be no limit.</source>
          <target state="translated">当在命令行上未给出限制时，&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]中&lt;/a&gt;的每个线程在pack窗口内存中占用的最大内存大小。该值可以带有&amp;ldquo; k&amp;rdquo;，&amp;ldquo; m&amp;rdquo;或&amp;ldquo; g&amp;rdquo;后缀。取消配置（或显式设置为0）时，将没有限制。</target>
        </trans-unit>
        <trans-unit id="565cc584b68c5b675a716ec7daae7fd9f3343784" translate="yes" xml:space="preserve">
          <source>The meaning of each part of feature configuration is described below:</source>
          <target state="translated">下面将介绍功能配置中各部分的含义。</target>
        </trans-unit>
        <trans-unit id="9c067af8c6826c60723d70b61f19783aa20b528e" translate="yes" xml:space="preserve">
          <source>The merge backend keeps intentionally empty commits by default (though with -i they are marked as empty in the todo list editor, or they can be dropped automatically with --no-keep-empty).</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
