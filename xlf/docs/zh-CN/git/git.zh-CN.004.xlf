<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="813a368009448480dbec96398e42a0584e7bd447" translate="yes" xml:space="preserve">
          <source>As a given feature goes from experimental to stable, it also &quot;graduates&quot; between the corresponding branches of the software. &lt;code&gt;git.git&lt;/code&gt; uses the following &lt;code&gt;integration branches&lt;/code&gt;:</source>
          <target state="translated">当给定的功能从实验性变为稳定时，它还会在软件的相应分支之间&amp;ldquo;迁移&amp;rdquo;。 &lt;code&gt;git.git&lt;/code&gt; 使用以下 &lt;code&gt;integration branches&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b64fd0a9b4f65c1520607403d9b5b0753895060e" translate="yes" xml:space="preserve">
          <source>As a last resort, you can search for the corrupted objects and attempt to replace them by hand. Back up your repository before attempting this in case you corrupt things even more in the process.</source>
          <target state="translated">作为最后的手段,你可以搜索被破坏的对象,并尝试用手替换它们。在尝试这样做之前,请先备份你的版本库,以防在这个过程中损坏更多的东西。</target>
        </trans-unit>
        <trans-unit id="55349f46b4e35ef9e012280dbd1cc43373573ca9" translate="yes" xml:space="preserve">
          <source>As a noun: A single point in the Git history; the entire history of a project is represented as a set of interrelated commits. The word &quot;commit&quot; is often used by Git in the same places other revision control systems use the words &quot;revision&quot; or &quot;version&quot;. Also used as a short hand for &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;.</source>
          <target state="translated">作为名词：Git历史中的一点；项目的整个历史记录都表示为一组相互关联的提交。Git经常在其他修订控制系统使用&amp;ldquo;修订&amp;rdquo;或&amp;ldquo;版本&amp;rdquo;的地方使用&amp;ldquo;提交&amp;rdquo;一词。也用作&lt;a href=&quot;#def_commit_object&quot;&gt;提交对象&lt;/a&gt;的简写。</target>
        </trans-unit>
        <trans-unit id="ff1fc843fbc05442df0cf0a8f29973ba8fa37083" translate="yes" xml:space="preserve">
          <source>As a noun: unless it is a &lt;a href=&quot;#def_fast_forward&quot;&gt;fast-forward&lt;/a&gt;, a successful merge results in the creation of a new &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; representing the result of the merge, and having as &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt; the tips of the merged &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;. This commit is referred to as a &quot;merge commit&quot;, or sometimes just a &quot;merge&quot;.</source>
          <target state="translated">作为名词：除非是&lt;a href=&quot;#def_fast_forward&quot;&gt;快速前进&lt;/a&gt;，否则成功的合并将导致创建表示合并结果的新&lt;a href=&quot;#def_commit&quot;&gt;提交&lt;/a&gt;，并以合并&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;的技巧作为&lt;a href=&quot;#def_parent&quot;&gt;父&lt;/a&gt;代。此提交称为&amp;ldquo;合并提交&amp;rdquo;，有时也称为&amp;ldquo;合并&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c1c9a37d68f66f1f75bfd831a2c5dd7a1272c9cd" translate="yes" xml:space="preserve">
          <source>As a real example, this is how I update my public Git repository. Kernel.org mirror network takes care of the propagation to other publicly visible machines:</source>
          <target state="translated">作为一个真实的例子,我是这样更新我的公共 Git 仓库的。Kernel.org 镜像网络负责传播到其他公开可见的机器。</target>
        </trans-unit>
        <trans-unit id="d46b292b551e86be1737ae9deb37c787b011393c" translate="yes" xml:space="preserve">
          <source>As a result, if both sides have a change and one side has reverted that change, the result is to include the change. This is because the code has changed on one side and there is no net change on the other, and in this scenario, Git adopts the change.</source>
          <target state="translated">结果,如果两边都有变化,而其中一边又把这个变化还原了,结果就是把这个变化包含进去。这是因为一方的代码发生了变化,而另一方没有净变化,在这种情况下,Git采用了这个变化。</target>
        </trans-unit>
        <trans-unit id="d7533f66604d80a31300bb1ce995d97beafc16f1" translate="yes" xml:space="preserve">
          <source>As a result, the general consistency of an object can always be tested independently of the contents or the type of the object: all objects can be validated by verifying that (a) their hashes match the content of the file and (b) the object successfully inflates to a stream of bytes that forms a sequence of &lt;code&gt;&amp;lt;ascii type without space&amp;gt; + &amp;lt;space&amp;gt; + &amp;lt;ascii decimal size&amp;gt; +
&amp;lt;byte\0&amp;gt; + &amp;lt;binary object data&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">结果，始终可以独立于对象的内容或类型来测试对象的总体一致性：可以通过验证以下各项来验证所有对象：成功地膨胀为字节流，该字节流形成 &lt;code&gt;&amp;lt;ascii type without space&amp;gt; + &amp;lt;space&amp;gt; + &amp;lt;ascii decimal size&amp;gt; + &amp;lt;byte\0&amp;gt; + &amp;lt;binary object data&amp;gt;&lt;/code&gt; 的序列。</target>
        </trans-unit>
        <trans-unit id="d1e2c8156579db2980e4a3d9117d5ad5706a2358" translate="yes" xml:space="preserve">
          <source>As a result, the general consistency of an object can always be tested independently of the contents or the type of the object: all objects can be validated by verifying that (a) their hashes match the content of the file and (b) the object successfully inflates to a stream of bytes that forms a sequence of &lt;code&gt;&amp;lt;ascii type without space&amp;gt; + &amp;lt;space&amp;gt; + &amp;lt;ascii decimal size&amp;gt;&lt;br/&gt;
&amp;lt;byte\0&amp;gt; + &amp;lt;binary object data&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">结果，始终可以独立于对象的内容或类型来测试对象的总体一致性：可以通过验证以下各项来验证所有对象：（a）它们的哈希值与文件的内容匹配，以及（b）对象成功地膨胀为字节流，该字节流形成 &lt;code&gt;&amp;lt;ascii type without space&amp;gt; + &amp;lt;space&amp;gt; + &amp;lt;ascii decimal size&amp;gt;&lt;br/&gt; &amp;lt;byte\0&amp;gt; + &amp;lt;binary object data&amp;gt;&lt;/code&gt; 的序列。</target>
        </trans-unit>
        <trans-unit id="1a86b8dd400c7fa63fb2fa4b8a7674ea4f9c20d3" translate="yes" xml:space="preserve">
          <source>As a reviewer aid, insert a range-diff (see &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt;) into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. &lt;code&gt;previous&lt;/code&gt; can be a single revision naming the tip of the previous series if it shares a common base with the series being formatted (for example &lt;code&gt;git format-patch --cover-letter --range-diff=feature/v1 -3
feature/v2&lt;/code&gt;), or a revision range if the two versions of the series are disjoint (for example &lt;code&gt;git format-patch --cover-letter
--range-diff=feature/v1~3..feature/v1 -3 feature/v2&lt;/code&gt;).</source>
          <target state="translated">作为审阅者的帮助，请在求职信中插入range-diff（请参阅&lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff [1]&lt;/a&gt;），或作为1-patch系列单独补丁的注释，以显示该补丁先前版本之间的差异系列和当前正在格式化的系列。 &lt;code&gt;previous&lt;/code&gt; ，如果这股与系列被格式化一个共同的基（例如可以是单一的修订的命名之前的系列的尖端 &lt;code&gt;git format-patch --cover-letter --range-diff=feature/v1 -3 feature/v2&lt;/code&gt; ），或者如果系列的两个版本不相交，则为修订范围（例如 &lt;code&gt;git format-patch --cover-letter --range-diff=feature/v1~3..feature/v1 -3 feature/v2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7fd619ea41aade7bb01c884d2572b761cf9ff25b" translate="yes" xml:space="preserve">
          <source>As a reviewer aid, insert an interdiff into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. &lt;code&gt;previous&lt;/code&gt; is a single revision naming the tip of the previous series which shares a common base with the series being formatted (for example &lt;code&gt;git format-patch
--cover-letter --interdiff=feature/v1 -3 feature/v2&lt;/code&gt;).</source>
          <target state="translated">作为审阅者的帮助，在求职信中插入一个interdiff，或作为1-patch系列单独补丁的注释，以显示该补丁系列的先前版本与当前正在格式化的系列之间的差异。 &lt;code&gt;previous&lt;/code&gt; 是一个单独的修订版，命名了先前系列的技巧，该系列与要格式化的系列具有共同的基础（例如 &lt;code&gt;git format-patch --cover-letter --interdiff=feature/v1 -3 feature/v2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a396a38596332774142e3633350d3c5ee12f3978" translate="yes" xml:space="preserve">
          <source>As a special case for the date-type fields, you may specify a format for the date by adding &lt;code&gt;:&lt;/code&gt; followed by date format name (see the values the &lt;code&gt;--date&lt;/code&gt; option to &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; takes).</source>
          <target state="translated">作为日期类型字段的一种特殊情况，您可以通过添加 &lt;code&gt;:&lt;/code&gt; 以及日期格式名称来指定日期格式（请参阅&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;的 &lt;code&gt;--date&lt;/code&gt; 选项的值）。</target>
        </trans-unit>
        <trans-unit id="45ade4e7bdf6353bad954746718b0b4bd913e21c" translate="yes" xml:space="preserve">
          <source>As a special case, you can also do &lt;code&gt;git update-index --refresh&lt;/code&gt;, which will refresh the &quot;stat&quot; information of each index to match the current stat information. It will 'not' update the object status itself, and it will only update the fields that are used to quickly test whether an object still matches its old backing store object.</source>
          <target state="translated">作为一种特殊情况，您还可以执行 &lt;code&gt;git update-index --refresh&lt;/code&gt; ，这将刷新每个索引的&amp;ldquo; stat&amp;rdquo;信息以匹配当前的stat信息。它将&amp;ldquo;不&amp;rdquo;更新对象本身的状态，并且仅更新用于快速测试对象是否仍与其旧的后备存储对象匹配的字段。</target>
        </trans-unit>
        <trans-unit id="d3a1d61e69563f75beec1cc2498f12801534880e" translate="yes" xml:space="preserve">
          <source>As a special case, you can also do &lt;code&gt;git update-index --refresh&lt;/code&gt;, which will refresh the &quot;stat&quot; information of each index to match the current stat information. It will &lt;code&gt;not&lt;/code&gt; update the object status itself, and it will only update the fields that are used to quickly test whether an object still matches its old backing store object.</source>
          <target state="translated">作为一种特殊情况，您还可以执行 &lt;code&gt;git update-index --refresh&lt;/code&gt; ，这将刷新每个索引的&amp;ldquo;统计&amp;rdquo;信息以匹配当前的统计信息。它 &lt;code&gt;not&lt;/code&gt; 更新对象状态本身，而只会更新用于快速测试对象是否仍与其旧的后备存储对象匹配的字段。</target>
        </trans-unit>
        <trans-unit id="4f896fc12182c6581528d02b73cafa58c18c0571" translate="yes" xml:space="preserve">
          <source>As a special case, you may use &quot;A...B&quot; as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD.</source>
          <target state="translated">作为一种特殊情况,如果A和B正好有一个合并基数,你可以用 &quot;A...B &quot;作为A和B的合并基数的快捷方式。您最多可以不使用A和B中的一个,在这种情况下,它默认为HEAD。</target>
        </trans-unit>
        <trans-unit id="f60f56407a2b12c7ab7900d72be353ae897d29d5" translate="yes" xml:space="preserve">
          <source>As a special case, you may use &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; as a shortcut for the merge base of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; if there is exactly one merge base. You can leave out at most one of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, in which case it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">作为一种特殊情况，如果存在一个合并基数，则可以使用 &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; 作为 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 合并基数的快捷方式。您最多可以忽略 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 之一，在这种情况下，默认为 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10cc0995f68a1af6b96ca8bc169efe97ff360947" translate="yes" xml:space="preserve">
          <source>As a special case, you may use &lt;code&gt;A...B&lt;/code&gt; as a shortcut for the merge base of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; if there is exactly one merge base. You can leave out at most one of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, in which case it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">作为一种特殊情况，如果存在一个合并库，则可以使用 &lt;code&gt;A...B&lt;/code&gt; 作为 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 合并库的快捷方式。您最多可以忽略 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 之一，在这种情况下，默认为 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c98a50738baa944b04be5906cf4230cda7da50f7" translate="yes" xml:space="preserve">
          <source>As a special extension, the commit filter may emit multiple commit ids; in that case, the rewritten children of the original commit will have all of them as parents.</source>
          <target state="translated">作为一个特殊的扩展,提交过滤器可能会发出多个提交id;在这种情况下,原始提交的重写子代将以所有子代为父代。</target>
        </trans-unit>
        <trans-unit id="014231faf08aed1fd006d6569258568e8c26510e" translate="yes" xml:space="preserve">
          <source>As a special shortcut,</source>
          <target state="translated">作为一种特殊的快捷方式。</target>
        </trans-unit>
        <trans-unit id="4df53d3c6d9483bf31546176476f770bb64d7028" translate="yes" xml:space="preserve">
          <source>As a verb: The action of storing a new snapshot of the project&amp;rsquo;s state in the Git history, by creating a new commit representing the current state of the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; and advancing &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; to point at the new commit.</source>
          <target state="translated">作为动词：通过创建代表&lt;a href=&quot;#def_index&quot;&gt;索引&lt;/a&gt;当前状态的新提交并前进&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;使其指向新提交，在Git历史记录中存储项目状态的新快照的操作。</target>
        </trans-unit>
        <trans-unit id="e121b03809309d600afd50d432f7cbb397b47657" translate="yes" xml:space="preserve">
          <source>As a verb: To bring the contents of another &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; (possibly from an external &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;) into the current branch. In the case where the merged-in branch is from a different repository, this is done by first &lt;a href=&quot;#def_fetch&quot;&gt;fetching&lt;/a&gt; the remote branch and then merging the result into the current branch. This combination of fetch and merge operations is called a &lt;a href=&quot;#def_pull&quot;&gt;pull&lt;/a&gt;. Merging is performed by an automatic process that identifies changes made since the branches diverged, and then applies all those changes together. In cases where changes conflict, manual intervention may be required to complete the merge.</source>
          <target state="translated">作为动词：将另一个&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;的内容（可能来自外部&lt;a href=&quot;#def_repository&quot;&gt;存储库&lt;/a&gt;）带入当前分支。如果合并的分支来自不同的存储库，则可以通过首先&lt;a href=&quot;#def_fetch&quot;&gt;获取&lt;/a&gt;远程分支，然后将结果合并到当前分支中来完成此操作。提取和合并操作的这种组合称为&lt;a href=&quot;#def_pull&quot;&gt;pull&lt;/a&gt;。合并是通过自动过程执行的，该过程会识别自分支分支以来所做的更改，然后将所有这些更改一起应用。如果更改冲突，则可能需要手动干预才能完成合并。</target>
        </trans-unit>
        <trans-unit id="30669ffae471bf3f6383626501505c5e90309074" translate="yes" xml:space="preserve">
          <source>As active branches store metadata about the files contained on that branch, their in-memory storage size can grow to a considerable size (see below).</source>
          <target state="translated">由于活动分支存储了该分支所包含的文件的元数据,它们的内存存储大小会增长到相当大的规模(见下文)。</target>
        </trans-unit>
        <trans-unit id="5905e313567b9a612b1c4b05bb63adbe4c8ba180" translate="yes" xml:space="preserve">
          <source>As an alternative, to keep the topic branch clean of test merges, you could blow away the test merge, and keep building on top of the tip before the test merge:</source>
          <target state="translated">作为一个替代方案,为了保持主题分支的测试合并的干净,你可以吹掉测试合并,在测试合并之前,继续在提示的基础上进行构建。</target>
        </trans-unit>
        <trans-unit id="cabda80231ec81bd47e1b2a8cca346f3b12eb94b" translate="yes" xml:space="preserve">
          <source>As an example use case, consider the following commit history:</source>
          <target state="translated">作为一个用例,考虑以下提交历史。</target>
        </trans-unit>
        <trans-unit id="d1cfcd564d3c903d2d8f64e4c4116cc502a9ccb3" translate="yes" xml:space="preserve">
          <source>As an example, a typical orderfile for the core Git probably would look like this:</source>
          <target state="translated">举个例子,一个典型的核心 Git 的订单文件大概是这样的。</target>
        </trans-unit>
        <trans-unit id="393e086dc57d2576b08e508b4c5a81ba83fe2ed2" translate="yes" xml:space="preserve">
          <source>As an example, suppose you are trying to find the commit that broke a feature that was known to work in version &lt;code&gt;v2.6.13-rc2&lt;/code&gt; of your project. You start a bisect session as follows:</source>
          <target state="translated">例如，假设您正在尝试查找破坏了已知在项目的 &lt;code&gt;v2.6.13-rc2&lt;/code&gt; 版本中起作用的功能的提交。您按以下方式启动bisect会话：</target>
        </trans-unit>
        <trans-unit id="f51fd8c0acda05665f38c4533584f1e7599db6e4" translate="yes" xml:space="preserve">
          <source>As an example, the command below will show the path and currently checked out commit for each submodule:</source>
          <target state="translated">举个例子,下面的命令将显示每个子模块的路径和当前签出的提交。</target>
        </trans-unit>
        <trans-unit id="3760e902be67f22552bbeb65e39e836e5efd1bcb" translate="yes" xml:space="preserve">
          <source>As an example, use the following attributes if your &lt;code&gt;*.ps1&lt;/code&gt; files are UTF-16 encoded with byte order mark (BOM) and you want Git to perform automatic line ending conversion based on your platform.</source>
          <target state="translated">例如，如果您的 &lt;code&gt;*.ps1&lt;/code&gt; 文件使用字节顺序标记（BOM）进行UTF-16编码，并且您希望Git根据您的平台执行自动行尾转换，请使用以下属性。</target>
        </trans-unit>
        <trans-unit id="51bf467f4f316d3645d71a2a1258673146c504e9" translate="yes" xml:space="preserve">
          <source>As another useful shortcut, the &quot;HEAD&quot; of a repository can be referred to just using the name of that repository. So, for example, &quot;origin&quot; is usually a shortcut for the HEAD branch in the repository &quot;origin&quot;.</source>
          <target state="translated">作为另一个有用的快捷方式,一个版本库的 &quot;HEAD &quot;可以只用该版本库的名称来表示,例如,&quot;origin &quot;通常是版本库 &quot;origin &quot;中HEAD分支的快捷方式。所以,例如,&quot;origin &quot;通常是版本库 &quot;origin &quot;中 HEAD 分支的快捷方式。</target>
        </trans-unit>
        <trans-unit id="8026d1f9c2456b3e1c9c2d009b9420179e138763" translate="yes" xml:space="preserve">
          <source>As before, if we do &lt;code&gt;git diff-files -p&lt;/code&gt; in our git-tutorial project, we&amp;rsquo;ll still see the same difference we saw last time: the index file hasn&amp;rsquo;t changed by the act of committing anything. However, now that we have committed something, we can also learn to use a new command: &lt;code&gt;git diff-index&lt;/code&gt;.</source>
          <target state="translated">和以前一样，如果我们在git-tutorial项目中执行 &lt;code&gt;git diff-files -p&lt;/code&gt; ，我们仍然会看到与上次相同的区别：索引文件并没有因为提交任何内容而改变。但是，既然我们已经提交了一些东西，我们还可以学习使用新命令： &lt;code&gt;git diff-index&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf611fa72ccf0565756cc79d030368187f807460" translate="yes" xml:space="preserve">
          <source>As described in &quot;Projects list file format&quot; section, you can control which projects are &lt;strong&gt;visible&lt;/strong&gt; by selectively including repositories in projects list file, and setting &lt;code&gt;$projects_list&lt;/code&gt; gitweb configuration variable to point to it. With &lt;code&gt;$strict_export&lt;/code&gt; set, projects list file can be used to control which repositories are &lt;strong&gt;available&lt;/strong&gt; as well.</source>
          <target state="translated">如&amp;ldquo;项目列表文件格式&amp;rdquo;部分中所述，可以通过在项目列表文件中选择性地包含存储库，并设置 &lt;code&gt;$projects_list&lt;/code&gt; gitweb配置变量以指向哪些项目，来控制&lt;strong&gt;可见&lt;/strong&gt;的项目。通过设置 &lt;code&gt;$strict_export&lt;/code&gt; ，项目列表文件也可以用于控制哪些存储库&lt;strong&gt;可用&lt;/strong&gt;。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7cd736f89da40ebc01b21f3f068771d165721a3" translate="yes" xml:space="preserve">
          <source>As described in step 1) b) of the bisection algorithm, we remove all the ancestors of the good commits because they are supposed to be good too.</source>
          <target state="translated">如二分法算法的步骤1)b)所述,我们删除所有好的提交的祖先,因为它们也应该是好的。</target>
        </trans-unit>
        <trans-unit id="4986ad28ead3398292128508370a98b8f0d98d3c" translate="yes" xml:space="preserve">
          <source>As development continues in the p4 repository, those changes can be included in the Git repository using:</source>
          <target state="translated">随着开发在p4仓库中的继续进行,可以使用以下方法将这些更改加入Git仓库中。</target>
        </trans-unit>
        <trans-unit id="b95c634f5d2da95f8f228babb7d2d483e4c0fbd6" translate="yes" xml:space="preserve">
          <source>As explained in the comments, you can reorder commits, squash them together, edit commit messages, etc. by editing the list. Once you are satisfied, save the list and close your editor, and the rebase will begin.</source>
          <target state="translated">正如评论中所解释的那样,您可以通过编辑列表来重新排序提交,将它们挤在一起,编辑提交信息等。一旦您满意,保存列表并关闭编辑器,然后就可以开始重新排序了。</target>
        </trans-unit>
        <trans-unit id="7111298f6d4fcf0e45bb2162c1a76bdcc1c9c21b" translate="yes" xml:space="preserve">
          <source>As in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X. The delta reveals regions of X that are similar to Y to the attacker.</source>
          <target state="translated">如同#1一样,攻击者选择一个对象ID X来窃取。受害者发送一个攻击者已经拥有的对象Y,而攻击者谎称自己拥有X而不是Y,所以受害者发送Y作为对X的delta,delta显示出X的区域与攻击者的Y相似。</target>
        </trans-unit>
        <trans-unit id="5b094bea742cc2d9c8adaa2beb6a0f04f6aac290" translate="yes" xml:space="preserve">
          <source>As long as a &quot;smudge&amp;rarr;clean&quot; results in the same output as a &quot;clean&quot; even on files that are already smudged, this strategy will automatically resolve all filter-related conflicts. Filters that do not act in this way may cause additional merge conflicts that must be resolved manually.</source>
          <target state="translated">只要&amp;ldquo;涂抹&amp;rarr;清除&amp;rdquo;结果与&amp;ldquo;清除&amp;rdquo;结果相同，即使在已经被涂抹的文件上，此策略也会自动解决所有与过滤器相关的冲突。不以此方式运行的过滤器可能会导致其他合并冲突，必须手动解决。</target>
        </trans-unit>
        <trans-unit id="1864f8816e6742ed19679415e2b4f0693aaf2aa7" translate="yes" xml:space="preserve">
          <source>As no direct connection between the repositories exists, the user must specify a basis for the bundle that is held by the destination repository: the bundle assumes that all objects in the basis are already in the destination repository.</source>
          <target state="translated">由于存储库之间不存在直接的连接,用户必须为捆绑指定一个由目标存储库持有的基础:捆绑假设基础中的所有对象都已经在目标存储库中。</target>
        </trans-unit>
        <trans-unit id="cf5a5d1f8e11ad4218ba16acff45cd1e219fd7d0" translate="yes" xml:space="preserve">
          <source>As objects are unpacked they&amp;rsquo;re written to the object store, so there can be cases where malicious objects get introduced even though the &quot;fetch&quot; failed, only to have a subsequent &quot;fetch&quot; succeed because only new incoming objects are checked, not those that have already been written to the object store. That difference in behavior should not be relied upon. In the future, such objects may be quarantined for &quot;fetch&quot; as well.</source>
          <target state="translated">当对象解压缩后，它们将被写入对象存储，因此，即使&amp;ldquo;获取&amp;rdquo;失败，也可能会引入恶意对象，但只有随后的&amp;ldquo;获取&amp;rdquo;成功，因为仅检查新的传入对象，而不检查那些对象已经写入对象存储的对象。不应依赖行为上的差异。将来，此类对象也可能会被隔离以进行&amp;ldquo;提取&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="09eeb717613e6d721cd260fee5aeb319ede3cef4" translate="yes" xml:space="preserve">
          <source>As of cURL v7.60.0, the Secure Channel backend can use the certificate bundle provided via &lt;code&gt;http.sslCAInfo&lt;/code&gt;, but that would override the Windows Certificate Store. Since this is not desirable by default, Git will tell cURL not to use that bundle by default when the &lt;code&gt;schannel&lt;/code&gt; backend was configured via &lt;code&gt;http.sslBackend&lt;/code&gt;, unless &lt;code&gt;http.schannelUseSSLCAInfo&lt;/code&gt; overrides this behavior.</source>
          <target state="translated">从cURL v7.60.0开始，安全通道后端可以使用通过 &lt;code&gt;http.sslCAInfo&lt;/code&gt; 提供的证书捆绑包，但这将覆盖Windows证书存储。由于默认情况下不希望这样做，因此当通过 &lt;code&gt;http.sslBackend&lt;/code&gt; 配置 &lt;code&gt;schannel&lt;/code&gt; 后端时，Git会告诉cURL默认情况下不使用该捆绑包，除非 &lt;code&gt;http.schannelUseSSLCAInfo&lt;/code&gt; 覆盖了此行为。</target>
        </trans-unit>
        <trans-unit id="965229350b7d9b7b4d3000cae9b4d2865a3ca80c" translate="yes" xml:space="preserve">
          <source>As one can see it lacks the 'sub' element.</source>
          <target state="translated">可以看出,它缺少了 &quot;子 &quot;的元素。</target>
        </trans-unit>
        <trans-unit id="581927934e29a8f082f8e666e70165083e8e5a90" translate="yes" xml:space="preserve">
          <source>As soon as fast-import completes the Git repository is completely valid and ready for use. Typically this takes only a very short time, even for considerably large projects (100,000+ commits).</source>
          <target state="translated">一旦快速导入完成,Git 仓库就完全有效,可以使用了。通常情况下,这只需要很短的时间,即使是大型项目(100,000+提交)也是如此。</target>
        </trans-unit>
        <trans-unit id="7ef5bfd643e7695a1fe3a9fa38e890221a2a3138" translate="yes" xml:space="preserve">
          <source>As stated earlier, the repo-id is currently always 1, so there will only be one def_repo event. Later, if in-proc submodules are supported, a def_repo event should be emitted for each submodule visited.</source>
          <target state="translated">如前所述,目前repo-id总是1,所以只有一个def_repo事件。以后,如果支持in-proc子模块,那么每个被访问的子模块都应该发出一个def_repo事件。</target>
        </trans-unit>
        <trans-unit id="d80ca2ccc438317d745ae5338aae99312b25f26c" translate="yes" xml:space="preserve">
          <source>As the Git commits form a directed acyclic graph (DAG), finding the best bisection commit to test at each step is not so simple. Anyway Linus found and implemented a &quot;truly stupid&quot; algorithm, later improved by Junio Hamano, that works quite well.</source>
          <target state="translated">由于Git的提交形成了一个有向无环图(DAG),所以在每一步都要找到最佳的二分提交来测试,并不是那么简单。反正Linus发现并实现了一个 &quot;真正愚蠢 &quot;的算法,后来由滨野淳夫改进,效果相当不错。</target>
        </trans-unit>
        <trans-unit id="58257bfeca486a2bf1fd8b1803660be56d2b010d" translate="yes" xml:space="preserve">
          <source>As the most common special case, specifying only two commits on the command line means computing the merge base between the given two commits.</source>
          <target state="translated">作为最常见的特殊情况,在命令行中只指定两个提交,意味着计算给定的两个提交之间的合并基础。</target>
        </trans-unit>
        <trans-unit id="2031564d4e49bc946d835c341012879d4274c799" translate="yes" xml:space="preserve">
          <source>As the result, the attributes assignment to &lt;code&gt;t/abc&lt;/code&gt; becomes:</source>
          <target state="translated">结果，分配给 &lt;code&gt;t/abc&lt;/code&gt; 的属性变为：</target>
        </trans-unit>
        <trans-unit id="192578c95c2280ba3c2f61313d8bf0f6a57ae4fb" translate="yes" xml:space="preserve">
          <source>As this option had confusing syntax, it is no longer supported. Please use &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--set-upstream-to&lt;/code&gt; instead.</source>
          <target state="translated">由于此选项具有令人困惑的语法，因此不再受支持。请改用 &lt;code&gt;--track&lt;/code&gt; 或 &lt;code&gt;--set-upstream-to&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="843f190460819446fe8a020e4f922195a92ea733" translate="yes" xml:space="preserve">
          <source>As we know N from the beginning, we know that min(X, N - X) can&amp;rsquo;t be greater than N/2. So during steps 2) and 3), if we would associate N/2 to a commit, then we know this is the best bisection point. So in this case we can just stop processing any other commit and return the current commit.</source>
          <target state="translated">正如我们从一开始就知道N一样，我们知道min（X，N-X）不能大于N / 2。因此，在步骤2）和3）中，如果我们将N / 2与一个提交相关联，那么我们知道这是最好的平分点。因此，在这种情况下，我们可以停止处理任何其他提交并返回当前提交。</target>
        </trans-unit>
        <trans-unit id="85eb1d605d24cad051a866066f0da97dcc80577c" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git push&lt;/code&gt; will complain if this does not result in a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;; see the following section for details on handling this case.</source>
          <target state="translated">与 &lt;code&gt;git fetch&lt;/code&gt; 一样，如果 &lt;code&gt;git push&lt;/code&gt; 不会导致&lt;a href=&quot;#fast-forwards&quot;&gt;快进&lt;/a&gt;，则会进行抱怨；有关处理这种情况的详细信息，请参见以下部分。</target>
        </trans-unit>
        <trans-unit id="8efa157c58c7162f458fc6766132a5f146c4534e" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;git fetch&lt;/code&gt;, you may also set up configuration options to save typing; so, for example:</source>
          <target state="translated">与 &lt;code&gt;git fetch&lt;/code&gt; 一样，您也可以设置配置选项以保存输入内容。因此，例如：</target>
        </trans-unit>
        <trans-unit id="e2e201452993c8ff29862a314b348165ba75fd76" translate="yes" xml:space="preserve">
          <source>As with other commands of this type, &lt;em&gt;git diff-index&lt;/em&gt; does not actually look at the contents of the file at all. So maybe &lt;code&gt;kernel/sched.c&lt;/code&gt; hasn&amp;rsquo;t actually changed, and it&amp;rsquo;s just that you touched it. In either case, it&amp;rsquo;s a note that you need to &lt;em&gt;git update-index&lt;/em&gt; it to make the index be in sync.</source>
          <target state="translated">与其他此类命令一样，&lt;em&gt;git diff-index&lt;/em&gt;实际上根本不会查看文件的内容。所以也许 &lt;code&gt;kernel/sched.c&lt;/code&gt; 并没有真正改变，只是您感动了它。无论哪种情况，都要注意的是，您需要&lt;em&gt;git update-index&lt;/em&gt;使其索引保持同步。</target>
        </trans-unit>
        <trans-unit id="1a219cc037572dc449858e58401a98b9487e41ef" translate="yes" xml:space="preserve">
          <source>As with pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, all of the rules described above about what&amp;rsquo;s not allowed as an update can be overridden by adding an the optional leading &lt;code&gt;+&lt;/code&gt; to a refspec (or using &lt;code&gt;--force&lt;/code&gt; command line option). The only exception to this is that no amount of forcing will make the &lt;code&gt;refs/heads/*&lt;/code&gt; namespace accept a non-commit object.</source>
          <target state="translated">与使用&lt;a href=&quot;git-push&quot;&gt;git-push [1]推送&lt;/a&gt;一样，可以通过在refspec中添加可选的前导 &lt;code&gt;+&lt;/code&gt; （或使用 &lt;code&gt;--force&lt;/code&gt; 命令行选项）来覆盖上述有关不允许更新的所有规则。唯一的例外是没有任何强制将使 &lt;code&gt;refs/heads/*&lt;/code&gt; 名称空间接受非提交对象。</target>
        </trans-unit>
        <trans-unit id="3ed71506050bfa72b1ea4f1ce93514b64d8904d8" translate="yes" xml:space="preserve">
          <source>As with the bug described above the solution is to one-off do a &quot;git status&quot; run with &lt;code&gt;core.untrackedCache=false&lt;/code&gt; to flush out the leftover bad data.</source>
          <target state="translated">与上述错误一样，解决方案是一次性使用 &lt;code&gt;core.untrackedCache=false&lt;/code&gt; 进行&amp;ldquo; git status&amp;rdquo;运行，以清除剩余的不良数据。</target>
        </trans-unit>
        <trans-unit id="7f65f9810b42bc29820c9b18c26064984a955e8e" translate="yes" xml:space="preserve">
          <source>As with the case to record your own changes, you can use &lt;code&gt;-a&lt;/code&gt; option to save typing. One difference is that during a merge resolution, you cannot use &lt;code&gt;git commit&lt;/code&gt; with pathnames to alter the order the changes are committed, because the merge should be recorded as a single commit. In fact, the command refuses to run when given pathnames (but see &lt;code&gt;-i&lt;/code&gt; option).</source>
          <target state="translated">与记录自己的更改一样，您可以使用 &lt;code&gt;-a&lt;/code&gt; 选项保存输入。一个区别是，在合并解析期间，不能将 &lt;code&gt;git commit&lt;/code&gt; 与路径名一起使用来更改更改的提交顺序，因为合并应记录为单个提交。实际上，当给定路径名时，该命令拒绝运行（但请参见 &lt;code&gt;-i&lt;/code&gt; 选项）。</target>
        </trans-unit>
        <trans-unit id="b22aaf02415c185eaf98c36bda4bb6f6375b4276" translate="yes" xml:space="preserve">
          <source>As yet another alternative, the &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; command lists the commits reachable from its arguments with a display on the left-hand side that indicates which arguments that commit is reachable from. So, if you run something like</source>
          <target state="translated">作为另一种选择，&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt;命令列出了从其参数可访问的提交，并在左侧显示了可指示从哪个参数可访问的提交。因此，如果您运行类似</target>
        </trans-unit>
        <trans-unit id="ab55ac3413eea0cf585d324d891a90eb1c44a9c7" translate="yes" xml:space="preserve">
          <source>As you can see, a commit is defined by:</source>
          <target state="translated">如你所见,一个提交的定义是:</target>
        </trans-unit>
        <trans-unit id="6777c5e47b1bbdf59716ff3b0a0a681c16313dcb" translate="yes" xml:space="preserve">
          <source>As you can see, a commit shows who made the latest change, what they did, and why.</source>
          <target state="translated">正如你所看到的,一个提交显示了谁做了最新的改变,他们做了什么,以及为什么。</target>
        </trans-unit>
        <trans-unit id="a0f1d03e1580f855020045fffe8e5647f3b9c420" translate="yes" xml:space="preserve">
          <source>As you can see, a tree object contains a list of entries, each with a mode, object type, SHA-1 name, and name, sorted by name. It represents the contents of a single directory tree.</source>
          <target state="translated">正如你所看到的,一个树对象包含一个条目列表,每个条目都有模式、对象类型、SHA-1名称和名称,按名称排序。它代表了一个目录树的内容。</target>
        </trans-unit>
        <trans-unit id="ec8afd8db14f6b2c4703101087783a19cada8ee5" translate="yes" xml:space="preserve">
          <source>As you can see, this tells us which branch we&amp;rsquo;re currently on, and it tells us this by naming a file under the .git directory, which itself contains a SHA-1 name referring to a commit object, which we can examine with cat-file:</source>
          <target state="translated">如您所见，它通过在.git目录下命名一个文件来告诉我们当前的分支，该文件本身包含指向提交对象的SHA-1名称，我们可以使用该文件进行检查。猫文件：</target>
        </trans-unit>
        <trans-unit id="7345319011443769ac795138deb4faa77176b52c" translate="yes" xml:space="preserve">
          <source>Ask git-credential to give us a username and password for this description. This is done by running &lt;code&gt;git credential fill&lt;/code&gt;, feeding the description from step (1) to its standard input. The complete credential description (including the credential per se, i.e. the login and password) will be produced on standard output, like:</source>
          <target state="translated">要求git-credential为我们提供此描述的用户名和密码。这是通过运行 &lt;code&gt;git credential fill&lt;/code&gt; 来完成的，将步骤（1）中的描述馈送到其标准输入。完整的凭证描述（包括凭证本身，即登录名和密码）将在标准输出中生成，例如：</target>
        </trans-unit>
        <trans-unit id="353866df360a6151213ae26714b0b27ee93959c9" translate="yes" xml:space="preserve">
          <source>Ask the user to confirm that a patch set should actually be sent to SVN. For each patch, one may answer &quot;yes&quot; (accept this patch), &quot;no&quot; (discard this patch), &quot;all&quot; (accept all patches), or &quot;quit&quot;.</source>
          <target state="translated">要求用户确认补丁集是否真的应该被发送到SVN。对于每个补丁,可以回答 &quot;是&quot;(接受这个补丁)、&quot;否&quot;(放弃这个补丁)、&quot;全部&quot;(接受所有补丁)或 &quot;退出&quot;。</target>
        </trans-unit>
        <trans-unit id="74885a8f797e3dd4d74ed362a01fa5f6e719e159" translate="yes" xml:space="preserve">
          <source>Associating multiple Arch branches to one Git branch is possible; the result will make the most sense only if no commits are made to the first branch, after the second branch is created. Still, this is useful to convert Arch repositories that had been rotated periodically.</source>
          <target state="translated">将多个Arch分支关联到一个Git分支是可能的;只有在创建第二个分支后,没有对第一个分支进行提交的情况下,结果才是最合理的。不过,这对于转换定期轮换的Arch仓库还是很有用的。</target>
        </trans-unit>
        <trans-unit id="3fae130157899ed03a40dd2250aa34f89aff67c5" translate="yes" xml:space="preserve">
          <source>Assume the following history exists and the current branch is &quot;&lt;code&gt;master&lt;/code&gt;&quot;:</source>
          <target state="translated">假设存在以下历史记录，并且当前分支为&amp;ldquo; &lt;code&gt;master&lt;/code&gt; &amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="faa8cbaa5281b0af933b5133552cbab39bea906e" translate="yes" xml:space="preserve">
          <source>Assume the following history exists and the current branch is &quot;topic&quot;:</source>
          <target state="translated">假设存在以下历史,当前分支为 &quot;主题&quot;。</target>
        </trans-unit>
        <trans-unit id="3cd2aff8a20d9db05868ff5d3b79174e0521391d" translate="yes" xml:space="preserve">
          <source>Assume the output looks like this:</source>
          <target state="translated">假设输出是这样的。</target>
        </trans-unit>
        <trans-unit id="97613cb38d31b0bbed31ce68ca2dcace37e030ff" translate="yes" xml:space="preserve">
          <source>Assume you have a tarball project.tar.gz with your initial work. You can place it under Git revision control as follows.</source>
          <target state="translated">假设你有一个包含初始工作的 tar 包 project.tar.gz。你可以把它放在 Git 的修订控制下,如下所示。</target>
        </trans-unit>
        <trans-unit id="679231bf1096aa234d1b1628f62bacea198b2922" translate="yes" xml:space="preserve">
          <source>Assume you have local changes in &quot;master&quot;, but you need to refetch &quot;r2&quot;.</source>
          <target state="translated">假设你在 &quot;master &quot;中有本地变化,但你需要重新获取 &quot;r2&quot;。</target>
        </trans-unit>
        <trans-unit id="be7f011565f1c258dd11dc44833bb09a98dcf45f" translate="yes" xml:space="preserve">
          <source>Assume you want to transfer the history from a repository R1 on machine A to another repository R2 on machine B. For whatever reason, direct connection between A and B is not allowed, but we can move data from A to B via some mechanism (CD, email, etc.). We want to update R2 with development made on the branch master in R1.</source>
          <target state="translated">假设你想把A机器上的一个仓库R1的历史记录转移到B机器上的另一个仓库R2上,不管出于什么原因,A和B之间是不允许直接连接的,但是我们可以通过某种机制(光盘、邮件等)把数据从A转移到B。我们要用R1中的分支主库上的开发来更新R2。</target>
        </trans-unit>
        <trans-unit id="2183deafca588db3e5f3e1c7cf0d56a53d10c987" translate="yes" xml:space="preserve">
          <source>Assume your existing repo is at /home/alice/myproject. Create a new &quot;bare&quot; repository (a repository without a working tree) and fetch your project into it:</source>
          <target state="translated">假设你现有的仓库在 /home/alice/myproject。创建一个新的 &quot;裸露 &quot;仓库(一个没有工作树的仓库),并将你的项目放入其中。</target>
        </trans-unit>
        <trans-unit id="28e522eb4dcb1a9410bd8273e0683d16ad9d1887" translate="yes" xml:space="preserve">
          <source>Assume your personal repository is in the directory &lt;code&gt;~/proj&lt;/code&gt;. We first create a new clone of the repository and tell &lt;code&gt;git daemon&lt;/code&gt; that it is meant to be public:</source>
          <target state="translated">假设您的个人存储库位于目录 &lt;code&gt;~/proj&lt;/code&gt; 。我们首先创建存储库的新克隆，并告诉 &lt;code&gt;git daemon&lt;/code&gt; 它是公开的：</target>
        </trans-unit>
        <trans-unit id="2f08c00864cc26377518c6e9b880162905e8d349" translate="yes" xml:space="preserve">
          <source>Assuming that gitweb is installed to &lt;code&gt;/var/www/perl&lt;/code&gt;, the following Apache configuration (for mod_perl 2.x) is suitable.</source>
          <target state="translated">假设gitweb已安装到 &lt;code&gt;/var/www/perl&lt;/code&gt; ，则以下Apache配置（对于mod_perl 2.x）是合适的。</target>
        </trans-unit>
        <trans-unit id="f21b72294adb0bdfa94f142e28bd7e66d94e6e2e" translate="yes" xml:space="preserve">
          <source>Assuming the submodule has a Git directory at &lt;code&gt;$GIT_DIR/modules/foo/&lt;/code&gt; and a working directory at &lt;code&gt;path/to/bar/&lt;/code&gt;, the superproject tracks the submodule via a &lt;code&gt;gitlink&lt;/code&gt; entry in the tree at &lt;code&gt;path/to/bar&lt;/code&gt; and an entry in its &lt;code&gt;.gitmodules&lt;/code&gt; file (see &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;) of the form &lt;code&gt;submodule.foo.path = path/to/bar&lt;/code&gt;.</source>
          <target state="translated">假设子模块具有在一个Git目录 &lt;code&gt;$GIT_DIR/modules/foo/&lt;/code&gt; 和在工作目录 &lt;code&gt;path/to/bar/&lt;/code&gt; ，上层项目跟踪通过该子模块 &lt;code&gt;gitlink&lt;/code&gt; 树在进入 &lt;code&gt;path/to/bar&lt;/code&gt; ，并在进入其格式为 &lt;code&gt;submodule.foo.path = path/to/bar&lt;/code&gt; &lt;code&gt;.gitmodules&lt;/code&gt; 文件（请参阅&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="60da90e959e19c4160d1646a608d2bc5b787c602" translate="yes" xml:space="preserve">
          <source>Assuming you are using the merge approach discussed above, when you are releasing your project you will need to do some additional branch management work.</source>
          <target state="translated">假设你使用的是上面讨论的合并方法,当你发布项目时,你需要做一些额外的分支管理工作。</target>
        </trans-unit>
        <trans-unit id="1388e5cd4892a287239160f51404821c63ca478d" translate="yes" xml:space="preserve">
          <source>At any point you can view the history of your changes using</source>
          <target state="translated">在任何时候,你都可以查看你的更改历史,使用的是</target>
        </trans-unit>
        <trans-unit id="e40d41f48140a6f9c8ed7743f53a14cc49f4d4d6" translate="yes" xml:space="preserve">
          <source>At any point you may use the &lt;code&gt;--abort&lt;/code&gt; option to abort this process and return mywork to the state it had before you started the rebase:</source>
          <target state="translated">在任何时候，您都可以使用 &lt;code&gt;--abort&lt;/code&gt; 选项中止此过程，并将mywork返回到开始重新设置基准之前的状态：</target>
        </trans-unit>
        <trans-unit id="21e6c111ed6dea301f6219c21f04088d951095f1" translate="yes" xml:space="preserve">
          <source>At any time, we can create a new commit using &lt;code&gt;git commit&lt;/code&gt; (without the &quot;-a&quot; option), and verify that the state committed only includes the changes stored in the index file, not the additional change that is still only in our working tree:</source>
          <target state="translated">在任何时候，我们都可以使用 &lt;code&gt;git commit&lt;/code&gt; （不带&amp;ldquo; -a&amp;rdquo;选项）来创建新的提交，并验证提交的状态仅包括存储在索引文件中的更改，而不是仅在工作中仍存在的其他更改树：</target>
        </trans-unit>
        <trans-unit id="c62227c162304e2658e4b654489602aed406e046" translate="yes" xml:space="preserve">
          <source>At the beginning, the content of the index will be identical to that of the HEAD. The command &lt;code&gt;git diff --cached&lt;/code&gt;, which shows the difference between the HEAD and the index, should therefore produce no output at that point.</source>
          <target state="translated">首先，索引的内容将与HEAD的内容相同。因此，显示HEAD与索引之间的 &lt;code&gt;git diff --cached&lt;/code&gt; 的命令git diff --cached不应在该点产生任何输出。</target>
        </trans-unit>
        <trans-unit id="8edc58a934b3ed21297a24f7c0434615621064c8" translate="yes" xml:space="preserve">
          <source>At this point the index file still has all the WIP changes you committed as &lt;code&gt;snapshot WIP&lt;/code&gt;. This updates the index to show your WIP files as uncommitted.</source>
          <target state="translated">此时，索引文件仍具有您提交为 &lt;code&gt;snapshot WIP&lt;/code&gt; 所有WIP更改。这将更新索引以将您的WIP文件显示为未提交。</target>
        </trans-unit>
        <trans-unit id="6fb30ce8f93c559deaf24b4ad05d6dda3c1a1ac8" translate="yes" xml:space="preserve">
          <source>At this point there are basically 2 ways to drive the search. It can be driven manually by the user or it can be driven automatically by a script or a command.</source>
          <target state="translated">这时基本上有2种方式来驱动搜索。可以由用户手动驱动,也可以由脚本或命令自动驱动。</target>
        </trans-unit>
        <trans-unit id="73d7e84e91592f3766bf21a35fce90d676b02b60" translate="yes" xml:space="preserve">
          <source>At this point we can see what the commit does, check it out (if it&amp;rsquo;s not already checked out) or tinker with it, for example:</source>
          <target state="translated">在这一点上，我们可以看到提交的功能，将其检出（如果尚未检出）或修改它，例如：</target>
        </trans-unit>
        <trans-unit id="9821aa659e4d6623e87210d9f79f8fb8048ff5ce" translate="yes" xml:space="preserve">
          <source>At this point you could delete the experimental branch with</source>
          <target state="translated">这时你可以用以下方法删除实验分支</target>
        </trans-unit>
        <trans-unit id="9f18a8a14c3813ef07a4e4179ae90618a19f07d0" translate="yes" xml:space="preserve">
          <source>At this point you should know everything necessary to read the man pages for any of the git commands; one good place to start would be with the commands mentioned in &lt;a href=&quot;giteveryday&quot;&gt;giteveryday[7]&lt;/a&gt;. You should be able to find any unknown jargon in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">至此，您应该了解阅读任何git命令的手册页所需的所有知识；一个不错的起点是使用&lt;a href=&quot;giteveryday&quot;&gt;giteveryday [7]中&lt;/a&gt;提到的命令。您应该能够在&lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]中&lt;/a&gt;找到任何未知的术语。</target>
        </trans-unit>
        <trans-unit id="870751f448af1f37fa82b626c9d940e8d540a997" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;git diff&lt;/code&gt; shows the changes cleanly merged as in the previous example, as well as the changes in the conflicted files. Edit and resolve the conflict and mark it resolved with &lt;code&gt;git add&lt;/code&gt; as usual:</source>
          <target state="translated">此时， &lt;code&gt;git diff&lt;/code&gt; 显示了与上一个示例完全合并的更改以及冲突文件中的更改。像往常一样编辑并解决冲突，并使用 &lt;code&gt;git add&lt;/code&gt; 标记为已解决：</target>
        </trans-unit>
        <trans-unit id="1c8e0f856e1b344e50a8f9f6370e6aeaf4be3455" translate="yes" xml:space="preserve">
          <source>At this point, you could use &lt;code&gt;pull&lt;/code&gt; to merge your changes back in; the result would create a new merge commit, like this:</source>
          <target state="translated">此时，您可以使用 &lt;code&gt;pull&lt;/code&gt; 合并您的更改；结果将创建一个新的合并提交，如下所示：</target>
        </trans-unit>
        <trans-unit id="0cd76265a60d161772d69d7db5cee25c535ce122" translate="yes" xml:space="preserve">
          <source>At this time, the &lt;code&gt;merge&lt;/code&gt; command will &lt;strong&gt;always&lt;/strong&gt; use the &lt;code&gt;recursive&lt;/code&gt; merge strategy for regular merges, and &lt;code&gt;octopus&lt;/code&gt; for octopus merges, with no way to choose a different one. To work around this, an &lt;code&gt;exec&lt;/code&gt; command can be used to call &lt;code&gt;git merge&lt;/code&gt; explicitly, using the fact that the labels are worktree-local refs (the ref &lt;code&gt;refs/rewritten/onto&lt;/code&gt; would correspond to the label &lt;code&gt;onto&lt;/code&gt;, for example).</source>
          <target state="translated">此时，该 &lt;code&gt;merge&lt;/code&gt; 命令将&lt;strong&gt;一直&lt;/strong&gt;使用 &lt;code&gt;recursive&lt;/code&gt; 定期合并的合并战略， &lt;code&gt;octopus&lt;/code&gt; 章鱼合并，没有办法来选择不同的一个。为了解决这个问题，一个 &lt;code&gt;exec&lt;/code&gt; 命令可以用来调用 &lt;code&gt;git merge&lt;/code&gt; 明确，使用的事实，标签worktree本地裁判（裁判 &lt;code&gt;refs/rewritten/onto&lt;/code&gt; 将对应于标签 &lt;code&gt;onto&lt;/code&gt; ，例如）。</target>
        </trans-unit>
        <trans-unit id="c05aeaaa9fcd28f51dfdd6a6420e663787cde8e1" translate="yes" xml:space="preserve">
          <source>Attempt authentication without seeking a username or password. This can be used to attempt GSS-Negotiate authentication without specifying a username in the URL, as libcurl normally requires a username for authentication.</source>
          <target state="translated">在不寻求用户名或密码的情况下尝试认证。这可以用来尝试GSS-Negotiate认证,而不需要在URL中指定用户名,因为libcurl通常需要一个用户名来进行认证。</target>
        </trans-unit>
        <trans-unit id="b7ef94beb2ddaab144a55b166c213b4001e85f5a" translate="yes" xml:space="preserve">
          <source>Attempt to auto-register archives at &lt;code&gt;http://mirrors.sourcecontrol.net&lt;/code&gt; This is particularly useful with the -D option.</source>
          <target state="translated">尝试在 &lt;code&gt;http://mirrors.sourcecontrol.net&lt;/code&gt; 上自动注册档案文件。这对于-D选项特别有用。</target>
        </trans-unit>
        <trans-unit id="7d9e2779fbfa7bc1835b11ad0c4ebabfce18ac06" translate="yes" xml:space="preserve">
          <source>Attempt to detect merges based on the commit message with a custom regex. It can be used with &lt;code&gt;-m&lt;/code&gt; to enable the default regexes as well. You must escape forward slashes.</source>
          <target state="translated">尝试基于带有自定义正则表达式的提交消息来检测合并。它可以与 &lt;code&gt;-m&lt;/code&gt; 一起使用以启用默认正则表达式。您必须转义正斜杠。</target>
        </trans-unit>
        <trans-unit id="b8801ab881aa4eb66128b4665e3908eb4d237716" translate="yes" xml:space="preserve">
          <source>Attempt to detect merges based on the commit message. This option will enable default regexes that try to capture the source branch name from the commit message.</source>
          <target state="translated">尝试根据提交信息检测合并。这个选项将启用默认的重构码,尝试从提交信息中获取源分支名称。</target>
        </trans-unit>
        <trans-unit id="8811bcf98c754b208d76412300be8b3f7a7a0962" translate="yes" xml:space="preserve">
          <source>Attempt to use AUTH SSL/TLS and encrypted data transfers when connecting via regular FTP protocol. This might be needed if the FTP server requires it for security reasons or you wish to connect securely whenever remote FTP server supports it. Default is false since it might trigger certificate verification errors on misconfigured servers.</source>
          <target state="translated">通过常规FTP协议连接时,尝试使用AUTH SSL/TLS和加密数据传输。如果FTP服务器出于安全原因需要使用AUTH SSL/TLS,或者您希望在远程FTP服务器支持的情况下安全连接,则可能需要使用该选项。默认为false,因为它可能会在配置错误的服务器上触发证书验证错误。</target>
        </trans-unit>
        <trans-unit id="653466560b06acd7928eb1dabc7b9fa724a015d3" translate="yes" xml:space="preserve">
          <source>Attempts to recreate empty directories that core Git cannot track based on information in $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log files. Empty directories are automatically recreated when using &quot;git svn clone&quot; and &quot;git svn rebase&quot;, so &quot;mkdirs&quot; is intended for use after commands like &quot;git checkout&quot; or &quot;git reset&quot;. (See the svn-remote.&amp;lt;name&amp;gt;.automkdirs config file option for more information.)</source>
          <target state="translated">尝试根据$ GIT_DIR / svn / &amp;lt;refname&amp;gt; /unhandled.log文件中的信息重新创建核心Git无法跟踪的空目录。使用&amp;ldquo; git svn clone&amp;rdquo;和&amp;ldquo; git svn rebase&amp;rdquo;时会自动重新创建空目录，因此&amp;ldquo; mkdirs&amp;rdquo;旨在在&amp;ldquo; git checkout&amp;rdquo;或&amp;ldquo; git reset&amp;rdquo;之类的命令之后使用。（有关更多信息，请参见svn-remote。&amp;lt;name&amp;gt; .automkdirs配置文件选项。）</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="6945a05135c86ba329a2113c1a6c328943460d7a" translate="yes" xml:space="preserve">
          <source>Augment the output of all queried config options with the origin type (file, standard input, blob, command line) and the actual origin (config file path, ref, or blob id if applicable).</source>
          <target state="translated">在所有被查询的配置选项的输出中增加起源类型(文件、标准输入、blob、命令行)和实际的起源(配置文件路径、ref或blob id(如果适用))。</target>
        </trans-unit>
        <trans-unit id="d01bdb4337dbc4feb334d71a4ce4b2957ce12b06" translate="yes" xml:space="preserve">
          <source>Author and committer information is taken from the following environment variables, if set:</source>
          <target state="translated">作者和提交者的信息来自以下环境变量(如果设置了)。</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="3a3b18a78fb302a466d9706ed638e25ca72e2b20" translate="yes" xml:space="preserve">
          <source>Automatically bisect a broken build between v1.2 and HEAD:</source>
          <target state="translated">在V1.2和HEAD之间自动分割一个破碎的构建。</target>
        </trans-unit>
        <trans-unit id="b961e5ffc1b4a2335ddafbf9005a05ec9394a9ac" translate="yes" xml:space="preserve">
          <source>Automatically bisect a broken test case:</source>
          <target state="translated">自动分割一个破损的测试用例。</target>
        </trans-unit>
        <trans-unit id="efbd5b3ba20268a44c57d801ed284c730cc6da62" translate="yes" xml:space="preserve">
          <source>Automatically bisect a test failure between origin and HEAD:</source>
          <target state="translated">自动将原点和HEAD之间的测试失败进行二分。</target>
        </trans-unit>
        <trans-unit id="305f7f7499890d95ab081f6ff6a94a43fd8f7472" translate="yes" xml:space="preserve">
          <source>Automatically bisect with temporary modifications (hot-fix):</source>
          <target state="translated">通过临时修改(热修复),自动进行二分法。</target>
        </trans-unit>
        <trans-unit id="f3ce497b64c12f23e2601126336fc2efac214445" translate="yes" xml:space="preserve">
          <source>Automatically correct and execute mistyped commands after waiting for the given number of deciseconds (0.1 sec). If more than one command can be deduced from the entered text, nothing will be executed. If the value of this option is negative, the corrected command will be executed immediately. If the value is 0 - the command will be just shown but not executed. This is the default.</source>
          <target state="translated">在等待给定的决定秒数(0.1秒)后,自动纠正并执行打错的命令。如果从输入的文本中可以推断出一个以上的命令,则不会执行任何命令。如果该选项的值为负数,则会立即执行修正后的命令。如果该值为0--命令将只显示而不执行。这是默认值。</target>
        </trans-unit>
        <trans-unit id="c95bbf7a5ca8016973d83b1a1be57b0354ee0b3c" translate="yes" xml:space="preserve">
          <source>Automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts.</source>
          <target state="translated">在操作开始前自动创建一个临时储藏条目,并在操作结束后应用它。这意味着你可以在一个肮脏的工作树上运行rebase。然而,使用时要小心:在成功的rebase之后,最后的储藏库应用可能会导致非平凡的冲突。</target>
        </trans-unit>
        <trans-unit id="cdfa0a080ceaba7371e2c4f216b1a9549ed01683" translate="yes" xml:space="preserve">
          <source>Automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run the operation on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts.</source>
          <target state="translated">在操作开始前自动创建一个临时储藏条目,并在操作结束后应用它。这意味着你可以在一个肮脏的工作树上运行操作。但是,请谨慎使用:合并成功后的最终储藏库应用可能会导致非平凡的冲突。</target>
        </trans-unit>
        <trans-unit id="172ed809f35e71e5eeb8f45359fa6e87d4adb464" translate="yes" xml:space="preserve">
          <source>Automatically enter the &lt;code&gt;Amend Last Commit&lt;/code&gt; mode of the interface.</source>
          <target state="translated">自动进入该界面的&amp;ldquo; &lt;code&gt;Amend Last Commit&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="ea4a15096a50442dde0b46a87fa45d92f2d785b9" translate="yes" xml:space="preserve">
          <source>Automatically reschedule &lt;code&gt;exec&lt;/code&gt; commands that failed. This only makes sense in interactive mode (or when an &lt;code&gt;--exec&lt;/code&gt; option was provided).</source>
          <target state="translated">自动重新计划失败的 &lt;code&gt;exec&lt;/code&gt; 命令。这仅在交互模式下（或提供了 &lt;code&gt;--exec&lt;/code&gt; 选项时）才有意义。</target>
        </trans-unit>
        <trans-unit id="49d8a969b318bfe4bd71c313d20f34515eed00b4" translate="yes" xml:space="preserve">
          <source>Automatically reschedule &lt;code&gt;exec&lt;/code&gt; commands that failed. This only makes sense in interactive mode (or when an &lt;code&gt;--exec&lt;/code&gt; option was provided). This is the same as specifying the &lt;code&gt;--reschedule-failed-exec&lt;/code&gt; option.</source>
          <target state="translated">自动重新计划失败的 &lt;code&gt;exec&lt;/code&gt; 命令。这仅在交互模式下（或提供了 &lt;code&gt;--exec&lt;/code&gt; 选项时）才有意义。这与指定 &lt;code&gt;--reschedule-failed-exec&lt;/code&gt; 选项相同。</target>
        </trans-unit>
        <trans-unit id="d8ac3fef9b72ebf093fec8697b2ecc321af38b99" translate="yes" xml:space="preserve">
          <source>Automating</source>
          <target state="translated">Automating</target>
        </trans-unit>
        <trans-unit id="91b5703f47ead0e97d542b1a3caaad3f90e51a85" translate="yes" xml:space="preserve">
          <source>Avatar support. When this feature is enabled, views such as &quot;shortlog&quot; or &quot;commit&quot; will display an avatar associated with the email of each committer and author.</source>
          <target state="translated">支持头像。启用该功能后,&quot;shortlog &quot;或 &quot;commit &quot;等视图将显示与每个提交者和作者的电子邮件相关联的头像。</target>
        </trans-unit>
        <trans-unit id="c6d2705a42ecaf3f83b93f2bb10c67222bc9051b" translate="yes" xml:space="preserve">
          <source>Avoid using these constructs, or do so with extreme caution.</source>
          <target state="translated">避免使用这些构造,或者在使用时极为谨慎。</target>
        </trans-unit>
        <trans-unit id="58d07623af97c330a561d59f75b429cfa3bf0d0e" translate="yes" xml:space="preserve">
          <source>Avoiding bug prone merges</source>
          <target state="translated">避免容易出现错误的合并</target>
        </trans-unit>
        <trans-unit id="e75c3f820aba1b207ca074d2c527699299d0d6c8" translate="yes" xml:space="preserve">
          <source>Avoiding repetition</source>
          <target state="translated">避免重复</target>
        </trans-unit>
        <trans-unit id="8c9b7d07bde7114458252fe7c7c79eff561fa5a3" translate="yes" xml:space="preserve">
          <source>Avoiding testing a commit</source>
          <target state="translated">避免测试提交</target>
        </trans-unit>
        <trans-unit id="b6679b7397715a4a559a3f90cd5da98012c5192b" translate="yes" xml:space="preserve">
          <source>Avoiding untestable commits</source>
          <target state="translated">避免不可测试的提交</target>
        </trans-unit>
        <trans-unit id="c06045f474b6de45fbcfae00e6444b3eed002fd3" translate="yes" xml:space="preserve">
          <source>BBChop is like &lt;code&gt;git bisect&lt;/code&gt; (or equivalent), but works when your bug is intermittent. That is, it works in the presence of false negatives (when a version happens to work this time even though it contains the bug). It assumes that there are no false positives (in principle, the same approach would work, but adding it may be non-trivial).</source>
          <target state="translated">BBChop就像 &lt;code&gt;git bisect&lt;/code&gt; （或等效版本）一样，但是当您的错误是间歇性的时可以使用。就是说，它在存在假阴性的情况下可以工作（当这个版本即使它包含错误时也恰好可以正常工作）。它假设没有误报（原则上，相同的方法会起作用，但添加它可能并非易事）。</target>
        </trans-unit>
        <trans-unit id="58da1ac28249462c67af1a7a678bbb84e64c5732" translate="yes" xml:space="preserve">
          <source>Back in the compose window: add whatever other text you wish to the message, complete the addressing and subject fields, and press send.</source>
          <target state="translated">回到撰写窗口:在信息中添加任何其他你想要的文字,完成地址和主题字段,然后按发送。</target>
        </trans-unit>
        <trans-unit id="0e4c8fb0c7c0f01878ae288a3240d6945abd9968" translate="yes" xml:space="preserve">
          <source>Back when this document was originally written, many porcelain commands were shell scripts. For simplicity, it still uses them as examples to illustrate how plumbing is fit together to form the porcelain commands. The source tree includes some of these scripts in contrib/examples/ for reference. Although these are not implemented as shell scripts anymore, the description of what the plumbing layer commands do is still valid.</source>
          <target state="translated">当初写这个文档的时候,很多瓷器命令都是shell脚本。为了简单起见,它仍然用它们作为例子来说明如何将管道组合起来形成瓷器命令。源码树在contrib/examples/中包含了其中的一些脚本,供参考。虽然这些脚本不再作为shell脚本来实现,但对水暖层命令的描述仍然有效。</target>
        </trans-unit>
        <trans-unit id="3cd5a2617e84a99ed87281238ca40ff62c45eb00" translate="yes" xml:space="preserve">
          <source>Backend extra options</source>
          <target state="translated">后台额外选项</target>
        </trans-unit>
        <trans-unit id="68cec68bccaee9cd80346d9802ee1e4fe905591f" translate="yes" xml:space="preserve">
          <source>Backend for fast Git data importers</source>
          <target state="translated">快速Git数据导入器的后端</target>
        </trans-unit>
        <trans-unit id="332ccbbf6a93a641f5828315e15dfb5ba3534887" translate="yes" xml:space="preserve">
          <source>Background refresh</source>
          <target state="translated">背景刷新</target>
        </trans-unit>
        <trans-unit id="3768e81347249432d7250e290eff2b7dcfb031aa" translate="yes" xml:space="preserve">
          <source>Backwards compatibility with &lt;code&gt;crlf&lt;/code&gt; attribute</source>
          <target state="translated">向后兼容 &lt;code&gt;crlf&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="0f4f796a2c073cee4b5657a9746bebeb8b591e9a" translate="yes" xml:space="preserve">
          <source>Base URL for relative URLs in pages generated by gitweb, (e.g. &lt;code&gt;$logo&lt;/code&gt;, &lt;code&gt;$favicon&lt;/code&gt;, &lt;code&gt;@stylesheets&lt;/code&gt; if they are relative URLs), needed and used &lt;code&gt;&amp;lt;base href=&quot;$base_url&quot;&amp;gt;&lt;/code&gt; only for URLs with nonempty PATH_INFO. Usually gitweb sets its value correctly, and there is no need to set this variable, e.g. to $my_uri or &quot;/&quot;. See &lt;code&gt;$per_request_config&lt;/code&gt; if you need to override it anyway.</source>
          <target state="translated">由gitweb生成的页面中的相对URL的基本URL（例如 &lt;code&gt;$logo&lt;/code&gt; ， &lt;code&gt;$favicon&lt;/code&gt; ， &lt;code&gt;@stylesheets&lt;/code&gt; ,如果它们是相对URL），则仅对具有非空PATH_INFO的URL进行 &lt;code&gt;&amp;lt;base href=&quot;$base_url&quot;&amp;gt;&lt;/code&gt; 并使用。通常，gitweb正确设置其值，并且不需要设置此变量，例如，设置为$ my_uri或&amp;ldquo; /&amp;rdquo;。如果仍然需要覆盖它，请参见 &lt;code&gt;$per_request_config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="097ac79311bf794decc7505841440135a2fcc1ec" translate="yes" xml:space="preserve">
          <source>Base tree information</source>
          <target state="translated">基础树信息</target>
        </trans-unit>
        <trans-unit id="41acf5ab02f1a6facad6c843b7f1be13be76b889" translate="yes" xml:space="preserve">
          <source>Basic Command Messages</source>
          <target state="translated">基本指令信息</target>
        </trans-unit>
        <trans-unit id="32df76cf3cbd146d03819bb90c4b2e01188b5795" translate="yes" xml:space="preserve">
          <source>Basic Snapshotting</source>
          <target state="translated">基本快照</target>
        </trans-unit>
        <trans-unit id="8f3df0ee4c430ab18f213f1998c456e450457574" translate="yes" xml:space="preserve">
          <source>Basic bisect commands: start, bad, good</source>
          <target state="translated">基本的二分法命令:开始、坏、好。</target>
        </trans-unit>
        <trans-unit id="4c8d5fdc5db9950cf7bea592d196bad4f803b3fb" translate="yes" xml:space="preserve">
          <source>Basic examples</source>
          <target state="translated">基本例子</target>
        </trans-unit>
        <trans-unit id="8edc4390b3f014a72c7bad2082d4af28321b0a0d" translate="yes" xml:space="preserve">
          <source>Basically, the initial version of &lt;code&gt;git log&lt;/code&gt; was a shell script:</source>
          <target state="translated">基本上， &lt;code&gt;git log&lt;/code&gt; 的初始版本是一个shell脚本：</target>
        </trans-unit>
        <trans-unit id="434712fddf7623f4187c1faf83b1bb6fa207c805" translate="yes" xml:space="preserve">
          <source>Batch output</source>
          <target state="translated">批量输出</target>
        </trans-unit>
        <trans-unit id="09375d82ef48456f50bfb9b6b51c1eb3256d2719" translate="yes" xml:space="preserve">
          <source>Be a little more verbose and show remote url after name. NOTE: This must be placed between &lt;code&gt;remote&lt;/code&gt; and &lt;code&gt;subcommand&lt;/code&gt;.</source>
          <target state="translated">稍微冗长一些，并在名称后显示远程URL。注意：必须将其放置在 &lt;code&gt;remote&lt;/code&gt; 和 &lt;code&gt;subcommand&lt;/code&gt; 之间。</target>
        </trans-unit>
        <trans-unit id="05ae4f9773fc15757112e4e005a53743a8b9b6cb" translate="yes" xml:space="preserve">
          <source>Be a little more verbose and show remote url after name. NOTE: This must be placed between &lt;code&gt;remote&lt;/code&gt; and subcommand.</source>
          <target state="translated">稍微冗长一些，并在名称后显示远程URL。注意：必须将其放在 &lt;code&gt;remote&lt;/code&gt; 和子命令之间。</target>
        </trans-unit>
        <trans-unit id="8c658e70993b255c8802b7997e9b78d1f1aa3285" translate="yes" xml:space="preserve">
          <source>Be aware that commits that the old version of example/master pointed at may be lost, as we saw in the previous section.</source>
          <target state="translated">请注意,正如我们在上一节中看到的那样,旧版本的example/master指向的提交可能会丢失。</target>
        </trans-unit>
        <trans-unit id="f1a69fc5e5785e6c85861e4893e3a9a94deb0c9c" translate="yes" xml:space="preserve">
          <source>Be careful with that last command: in addition to losing any changes in the working directory, it will also remove all later commits from this branch. If this branch is the only branch containing those commits, they will be lost. Also, don&amp;rsquo;t use &lt;code&gt;git reset&lt;/code&gt; on a publicly-visible branch that other developers pull from, as it will force needless merges on other developers to clean up the history. If you need to undo changes that you have pushed, use &lt;code&gt;git revert&lt;/code&gt; instead.</source>
          <target state="translated">最后一条命令要小心：除了丢失工作目录中的任何更改外，它还将从此分支中删除所有以后的提交。如果此分支是包含这些提交的唯一分支，则它们将丢失。另外，请勿在其他开发人员从其公开的可见分支上使用 &lt;code&gt;git reset&lt;/code&gt; ，因为它将强制对其他开发人员进行不必要的合并以清理历史记录。如果需要撤消已推送的更改，请改用 &lt;code&gt;git revert&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a106ab03cbfb468582a31c86875853bbaafe530d" translate="yes" xml:space="preserve">
          <source>Be chatty.</source>
          <target state="translated">聊得来。</target>
        </trans-unit>
        <trans-unit id="0226bfbddcb9791bd20d59aa488cf4bfb67ab797" translate="yes" xml:space="preserve">
          <source>Be more quiet when creating or deleting a branch, suppressing non-error messages.</source>
          <target state="translated">在创建或删除分支时要更加安静,抑制非错误信息。</target>
        </trans-unit>
        <trans-unit id="925261c1087472fc24273a6f0433e6dab581a46e" translate="yes" xml:space="preserve">
          <source>Be pedantic (paranoid) when applying patches. Invokes patch with --fuzz=0</source>
          <target state="translated">应用补丁时要有迂腐(偏执)。调用--fuzz=0的补丁</target>
        </trans-unit>
        <trans-unit id="5a76ff079f12b1a74eb9b1c43645e96dd86361c1" translate="yes" xml:space="preserve">
          <source>Be quiet, only report errors, but not the files that are successfully removed.</source>
          <target state="translated">安静,只报错,但不报成功删除的文件。</target>
        </trans-unit>
        <trans-unit id="3b0a3e777f7a9dd999ab064af69bac80ddbc5083" translate="yes" xml:space="preserve">
          <source>Be quiet, only report errors. The default behavior is set by the &lt;code&gt;reset.quiet&lt;/code&gt; config option. &lt;code&gt;--quiet&lt;/code&gt; and &lt;code&gt;--no-quiet&lt;/code&gt; will override the default behavior.</source>
          <target state="translated">保持安静，只报告错误。默认行为由 &lt;code&gt;reset.quiet&lt;/code&gt; config选项设置。 &lt;code&gt;--quiet&lt;/code&gt; 和 &lt;code&gt;--no-quiet&lt;/code&gt; 将覆盖默认行为。</target>
        </trans-unit>
        <trans-unit id="4f313b181847f334463e2b9b9cfece6969bdba71" translate="yes" xml:space="preserve">
          <source>Be quiet.</source>
          <target state="translated">不要动</target>
        </trans-unit>
        <trans-unit id="57fac52c9e565c186d12f20b18e356a6357e3a35" translate="yes" xml:space="preserve">
          <source>Be quiet. Implies --no-stat.</source>
          <target state="translated">安静。意味着 ----无状态。</target>
        </trans-unit>
        <trans-unit id="35516ed1ed9df26f7366465685509e0334c0b48a" translate="yes" xml:space="preserve">
          <source>Be quiet. Only print error messages.</source>
          <target state="translated">安静点 只打印错误信息。</target>
        </trans-unit>
        <trans-unit id="89978c5e1540e90f998db2cd0eadcb073170d060" translate="yes" xml:space="preserve">
          <source>Be verbose about what is going on, including progress status.</source>
          <target state="translated">对正在进行的事情,包括进度状况,要多说几句。</target>
        </trans-unit>
        <trans-unit id="4e80f48c004a90076351b14f311e5f6e4c744c6f" translate="yes" xml:space="preserve">
          <source>Be verbose.</source>
          <target state="translated">啰嗦点。</target>
        </trans-unit>
        <trans-unit id="e38a34eb197b14381b23c4e10c689eabe1fdd749" translate="yes" xml:space="preserve">
          <source>Be verbose. Implies --stat.</source>
          <target state="translated">啰嗦。意味着-stat。</target>
        </trans-unit>
        <trans-unit id="d448b8a2b9d0f1627827f1dfcde2eef631321fa0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;--&lt;/code&gt; disambiguates revisions and paths in some commands, it cannot be used for those commands to separate options and revisions. You can use &lt;code&gt;--end-of-options&lt;/code&gt; for this (it also works for commands that do not distinguish between revisions in paths, in which case it is simply an alias for &lt;code&gt;--&lt;/code&gt;).</source>
          <target state="translated">因为 &lt;code&gt;--&lt;/code&gt; 消除了某些命令中的修订和路径的歧义，所以不能将其用于这些命令来分隔选项和修订。您可以使用 &lt;code&gt;--end-of-options&lt;/code&gt; 为这个（它也适用于那些不修订版之间的区别的路径命令，在这种情况下，它仅仅是一个别名 &lt;code&gt;--&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ed27c3aa81ab7c3b7b68607b6265fd75466941ef" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;git rebase&lt;/code&gt; replays each commit from the working branch on top of the &amp;lt;upstream&amp;gt; branch using the given strategy, using the &lt;code&gt;ours&lt;/code&gt; strategy simply empties all patches from the &amp;lt;branch&amp;gt;, which makes little sense.</source>
          <target state="translated">由于 &lt;code&gt;git rebase&lt;/code&gt; 使用给定策略在&amp;lt;upstream&amp;gt;分支顶部重放工作分支中的每个提交，因此使用 &lt;code&gt;ours&lt;/code&gt; 策略只是清空&amp;lt;branch&amp;gt;中的所有修补程序，这没有什么意义。</target>
        </trans-unit>
        <trans-unit id="611de3be2abb35df567ae0fa30747c7d8e2e7993" translate="yes" xml:space="preserve">
          <source>Because importing commits from other Git repositories is much faster than importing them from p4, a mechanism exists to find p4 changes first in Git remotes. If branches exist under &lt;code&gt;refs/remote/origin/p4&lt;/code&gt;, those will be fetched and used when syncing from p4. This variable can be set to &lt;code&gt;false&lt;/code&gt; to disable this behavior.</source>
          <target state="translated">由于从其他Git存储库导入提交要比从p4导入提交快得多，因此存在一种机制，可以在Git远程服务器中首先查找p4更改。如果分支存在于 &lt;code&gt;refs/remote/origin/p4&lt;/code&gt; 下，则从p4进行同步时将提取并使用这些分支。可以将此变量设置为 &lt;code&gt;false&lt;/code&gt; 以禁用此行为。</target>
        </trans-unit>
        <trans-unit id="8b27b448c938b73dbdadc78ef0ba4dafccd89967" translate="yes" xml:space="preserve">
          <source>Because of this rule, version bumps should be kept to an absolute minimum. Instead, we generally prefer these strategies:</source>
          <target state="translated">由于这个规则,版本颠簸应该保持在绝对最小的范围内。相反,我们一般更倾向于这些策略。</target>
        </trans-unit>
        <trans-unit id="9d9f1c640b4582c4a49afdb8c70b2833e5da2875" translate="yes" xml:space="preserve">
          <source>Because text conversion can be slow, especially when doing a large number of them with &lt;code&gt;git log -p&lt;/code&gt;, Git provides a mechanism to cache the output and use it in future diffs. To enable caching, set the &quot;cachetextconv&quot; variable in your diff driver&amp;rsquo;s config. For example:</source>
          <target state="translated">因为文本转换可能很慢，尤其是当使用 &lt;code&gt;git log -p&lt;/code&gt; 进行大量转换时，Git提供了一种机制来缓存输出并在以后的差异中使用它。要启用缓存，请在差异驱动程序的配置中设置&amp;ldquo; cachetextconv&amp;rdquo;变量。例如：</target>
        </trans-unit>
        <trans-unit id="0cc6b3eb8dba093f368da6924e1615ce67ee83a2" translate="yes" xml:space="preserve">
          <source>Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not consider &lt;code&gt;subdir/git-foo.sh&lt;/code&gt;.</source>
          <target state="translated">因为此示例使外壳程序扩展星号（即，您正在明确列出文件），所以它不考虑 &lt;code&gt;subdir/git-foo.sh&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6959f8959917da0048164f701d2c1653881d1c94" translate="yes" xml:space="preserve">
          <source>Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not remove &lt;code&gt;subdir/git-foo.sh&lt;/code&gt;.</source>
          <target state="translated">因为此示例使外壳程序扩展星号（即，您正在明确列出文件），所以它不会删除 &lt;code&gt;subdir/git-foo.sh&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19c5affce108c66b3b01079a5ffc874aa2199c4e" translate="yes" xml:space="preserve">
          <source>Because you&amp;rsquo;re asking for raw output, you&amp;rsquo;ll now get something like</source>
          <target state="translated">因为您要的是原始输出，所以现在您会得到类似</target>
        </trans-unit>
        <trans-unit id="6c83aee082a9b203ae0a8b1d789ef54ecb5119e2" translate="yes" xml:space="preserve">
          <source>Because your branch did not contain anything more than what had already been merged into the &lt;code&gt;master&lt;/code&gt; branch, the merge operation did not actually do a merge. Instead, it just updated the top of the tree of your branch to that of the &lt;code&gt;master&lt;/code&gt; branch. This is often called &lt;code&gt;fast-forward&lt;/code&gt; merge.</source>
          <target state="translated">因为您的分支所包含的内容不超过已经合并到 &lt;code&gt;master&lt;/code&gt; 分支中的内容，所以合并操作实际上并未进行合并。相反，它只是将分支树的顶部更新为 &lt;code&gt;master&lt;/code&gt; 分支的顶部。这通常称为 &lt;code&gt;fast-forward&lt;/code&gt; 合并。</target>
        </trans-unit>
        <trans-unit id="870bf9816d9b0c5ffd88b816d5bee6377c654145" translate="yes" xml:space="preserve">
          <source>Before 2.17, the untracked cache had a bug where replacing a directory with a symlink to another directory could cause it to incorrectly show files tracked by git as untracked. See the &quot;status: add a failing test showing a core.untrackedCache bug&quot; commit to git.git. A workaround for that is (and this might work for other undiscovered bugs in the future):</source>
          <target state="translated">在2.17之前,untracked cache有一个bug,即用一个指向另一个目录的符号链接替换一个目录,可能会导致它错误地将git跟踪的文件显示为untracked。请看 git.git 的 &quot;status:add a failing test showing a core.untrackedCache bug&quot; commit。一个变通的办法是(这可能适用于未来其他未发现的错误)。</target>
        </trans-unit>
        <trans-unit id="201415c3562a156d29edac8b78dcea637cbede90" translate="yes" xml:space="preserve">
          <source>Before Git invokes a hook, it changes its working directory to either $GIT_DIR in a bare repository or the root of the working tree in a non-bare repository. An exception are hooks triggered during a push (&lt;code&gt;pre-receive&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;post-receive&lt;/code&gt;, &lt;code&gt;post-update&lt;/code&gt;, &lt;code&gt;push-to-checkout&lt;/code&gt;) which are always executed in $GIT_DIR.</source>
          <target state="translated">在Git调用钩子之前，它将其工作目录更改为裸存储库中的$ GIT_DIR或非裸存储库中工作树的根。一个例外是推时触发挂钩（ &lt;code&gt;pre-receive&lt;/code&gt; ， &lt;code&gt;update&lt;/code&gt; ， &lt;code&gt;post-receive&lt;/code&gt; ， &lt;code&gt;post-update&lt;/code&gt; ， &lt;code&gt;push-to-checkout&lt;/code&gt; ），它总是在$ GIT_DIR执行。</target>
        </trans-unit>
        <trans-unit id="5cb683352fd365c05d1a2f3a901dc43ac75f481f" translate="yes" xml:space="preserve">
          <source>Before Git v2.0, the default prefix was &quot;&quot; (no prefix). This meant that SVN-tracking refs were put at &quot;refs/remotes/*&quot;, which is incompatible with how Git&amp;rsquo;s own remote-tracking refs are organized. If you still want the old default, you can get it by passing &lt;code&gt;--prefix &quot;&quot;&lt;/code&gt; on the command line (&lt;code&gt;--prefix=&quot;&quot;&lt;/code&gt; may not work if your Perl&amp;rsquo;s Getopt::Long is &amp;lt; v2.37).</source>
          <target state="translated">在Git v2.0之前，默认前缀为&amp;ldquo;&amp;rdquo;（无前缀）。这意味着SVN跟踪引用放置在&amp;ldquo; refs / remotes / *&amp;rdquo;上，这与Git自己的远程跟踪引用的组织方式不兼容。如果仍然希望使用旧的默认值，则可以通过在命令行上传递 &lt;code&gt;--prefix &quot;&quot;&lt;/code&gt; 来获得（如果您的Perl的Getopt :: Long &amp;lt;v2.37，则 &lt;code&gt;--prefix=&quot;&quot;&lt;/code&gt; 可能不起作用）。</target>
        </trans-unit>
        <trans-unit id="c9087c912c36612c549b23a216e2ca49dd6b41fb" translate="yes" xml:space="preserve">
          <source>Before any patches are applied, ORIG_HEAD is set to the tip of the current branch. This is useful if you have problems with multiple commits, like running &lt;code&gt;git am&lt;/code&gt; on the wrong branch or an error in the commits that is more easily fixed by changing the mailbox (e.g. errors in the &quot;From:&quot; lines).</source>
          <target state="translated">在应用任何补丁之前，将ORIG_HEAD设置为当前分支的尖端。如果您有多个提交问题，例如在错误的分支上运行 &lt;code&gt;git am&lt;/code&gt; 或通过更改邮箱更容易解决的提交错误（例如，&amp;ldquo;发件人：&amp;rdquo;行中的错误），则该功能很有用。</target>
        </trans-unit>
        <trans-unit id="21c90195abdd4404631a1dbe99e365dc5749da75" translate="yes" xml:space="preserve">
          <source>Before any ref is updated, if $GIT_DIR/hooks/pre-receive file exists and is executable, it will be invoked once with no parameters. The standard input of the hook will be one line per ref to be updated:</source>
          <target state="translated">在更新任何 ref 之前,如果 $GIT_DIR/hooks/pre-receive 文件存在且可执行,它将被调用一次,没有参数。钩子的标准输入将是每个要更新的 ref 的一行。</target>
        </trans-unit>
        <trans-unit id="add64b4c118b3f9ba1a8f5777c12299edaee08fe" translate="yes" xml:space="preserve">
          <source>Before applying outside changes, you should get your own work in good shape and committed locally, so it will not be clobbered if there are conflicts. See also &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;. &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; will stop without doing anything when local uncommitted changes overlap with files that &lt;code&gt;git pull&lt;/code&gt;/&lt;code&gt;git merge&lt;/code&gt; may need to update.</source>
          <target state="translated">在应用外部更改之前，您应该使自己的工作保持良好状态并在本地进行工作，这样在发生冲突时就不会给工作造成麻烦。另见&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;。当本地未提交的更改与 &lt;code&gt;git pull&lt;/code&gt; / &lt;code&gt;git merge&lt;/code&gt; 可能需要更新的文件重叠时， &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git merge&lt;/code&gt; 将停止而不进行任何操作。</target>
        </trans-unit>
        <trans-unit id="5b4786a5cabe8cc8e9d6176c7a8f4c8ac1126f56" translate="yes" xml:space="preserve">
          <source>Before creating any commits, you should introduce yourself to Git. The easiest way to do so is to use &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">在创建任何提交之前，您应该向Git进行自我介绍。最简单的方法是使用&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="fda40fac347bfbef9972589a0b7125a0c0bcff59" translate="yes" xml:space="preserve">
          <source>Before discussing another option, &lt;code&gt;--show-pulls&lt;/code&gt;, we need to create a new example history.</source>
          <target state="translated">在讨论另一个选项 &lt;code&gt;--show-pulls&lt;/code&gt; 之前，我们需要创建一个新的示例历史记录。</target>
        </trans-unit>
        <trans-unit id="0407957d0e82cce71a4172b7606149052dc8e0c6" translate="yes" xml:space="preserve">
          <source>Before each ref is updated, if $GIT_DIR/hooks/update file exists and is executable, it is invoked once per ref, with three parameters:</source>
          <target state="translated">在每个ref更新之前,如果$GIT_DIR/hooks/update文件存在且可执行,则每个ref调用一次,有三个参数。</target>
        </trans-unit>
        <trans-unit id="19ac0c97c048cb907215a798a4fb3cdaff4d9a6f" translate="yes" xml:space="preserve">
          <source>Before fetching, remove any local tags that no longer exist on the remote if &lt;code&gt;--prune&lt;/code&gt; is enabled. This option should be used more carefully, unlike &lt;code&gt;--prune&lt;/code&gt; it will remove any local references (local tags) that have been created. This option is a shorthand for providing the explicit tag refspec along with &lt;code&gt;--prune&lt;/code&gt;, see the discussion about that in its documentation.</source>
          <target state="translated">提取之前，如果启用了 &lt;code&gt;--prune&lt;/code&gt; ，请删除远程服务器上不再存在的所有本地标签。与 &lt;code&gt;--prune&lt;/code&gt; 不同，应该更谨慎地使用此选项，它将删除已创建的所有本地引用（本地标签）。此选项是提供显式标签 &lt;code&gt;--prune&lt;/code&gt; 和--prune的简写，请参阅其文档中的讨论。</target>
        </trans-unit>
        <trans-unit id="8e73bf59416129baf4984229453394f0315b226d" translate="yes" xml:space="preserve">
          <source>Before fetching, remove any remote-tracking references that no longer exist on the remote. Tags are not subject to pruning if they are fetched only because of the default tag auto-following or due to a --tags option. However, if tags are fetched due to an explicit refspec (either on the command line or in the remote configuration, for example if the remote was cloned with the --mirror option), then they are also subject to pruning. Supplying &lt;code&gt;--prune-tags&lt;/code&gt; is a shorthand for providing the tag refspec.</source>
          <target state="translated">提取之前，请删除遥控器上不再存在的所有远程跟踪参考。如果仅由于默认标签自动跟随或--tags选项而获取标签，则不对它们进行修剪。但是，如果由于显式refspec（在命令行或在远程配置中，例如，如果使用--mirror选项克隆了远程服务器）而获取了标记，则也将对其进行修剪。提供 &lt;code&gt;--prune-tags&lt;/code&gt; 是提供标签refspec的简写。</target>
        </trans-unit>
        <trans-unit id="0a0fe23adf5213b01d47b6f6f762c51483096baa" translate="yes" xml:space="preserve">
          <source>Before making a commit out of staged contents so far, stage the contents of paths given on the command line as well. This is usually not what you want unless you are concluding a conflicted merge.</source>
          <target state="translated">在提交之前,先将命令行上给出的路径内容也进行缓存。这通常不是你想要的,除非你要完成一个冲突的合并。</target>
        </trans-unit>
        <trans-unit id="c77aea15ac35dd0f59cc96b6055cd1857904fd59" translate="yes" xml:space="preserve">
          <source>Before moving the index into its final destination create an empty .keep file for the associated pack file. This option is usually necessary with --stdin to prevent a simultaneous &lt;code&gt;git repack&lt;/code&gt; process from deleting the newly constructed pack and index before refs can be updated to use objects contained in the pack.</source>
          <target state="translated">在将索引移到最终目的地之前，为关联的打包文件创建一个空的.keep文件。--stdin通常需要此选项，以防止同时 &lt;code&gt;git repack&lt;/code&gt; 进程在可以将引用更新为使用包中包含的对象之前删除新建的包和索引。</target>
        </trans-unit>
        <trans-unit id="1684b3761b33822ae0ce64e85db5417e09a004a4" translate="yes" xml:space="preserve">
          <source>Before opening a compose window, use Edit&amp;rarr;Account Settings to uncheck the &quot;Compose messages in HTML format&quot; setting in the &quot;Composition &amp;amp; Addressing&quot; panel of the account to be used to send the patch.</source>
          <target state="translated">打开撰写窗口之前，请使用&amp;ldquo;编辑&amp;rdquo;&amp;rarr;&amp;ldquo;帐户设置&amp;rdquo;取消选中用于发送补丁程序的帐户的&amp;ldquo;组成和寻址&amp;rdquo;面板中的&amp;ldquo; HTML格式的撰写邮件&amp;rdquo;设置。</target>
        </trans-unit>
        <trans-unit id="4236fe92cbd33fabad183244090db7c652c48ab2" translate="yes" xml:space="preserve">
          <source>Before processing any input, load the marks specified in &amp;lt;file&amp;gt;. The input file must exist, must be readable, and must use the same format as produced by --export-marks.</source>
          <target state="translated">在处理任何输入之前，请加载&amp;lt;file&amp;gt;中指定的标记。输入文件必须存在，必须可读，并且必须使用与--export-marks产生的格式相同的格式。</target>
        </trans-unit>
        <trans-unit id="293840b5790c8dfe363015950d52920cf320165c" translate="yes" xml:space="preserve">
          <source>Before processing any input, load the marks specified in &amp;lt;file&amp;gt;. The input file must exist, must be readable, and must use the same format as produced by --export-marks. Multiple options may be supplied to import more than one set of marks. If a mark is defined to different values, the last file wins.</source>
          <target state="translated">在处理任何输入之前，请加载&amp;lt;file&amp;gt;中指定的标记。输入文件必须存在，必须可读，并且必须使用与--export-marks产生的格式相同的格式。可以提供多个选项来导入多个标记。如果将标记定义为不同的值，则最后一个文件为准。</target>
        </trans-unit>
        <trans-unit id="6ec1c5712ad3f679b2da84284672de74a981a5d9" translate="yes" xml:space="preserve">
          <source>Before sourcing it, your script should set up a few variables; &lt;code&gt;USAGE&lt;/code&gt; (and &lt;code&gt;LONG_USAGE&lt;/code&gt;, if any) is used to define message given by &lt;code&gt;usage()&lt;/code&gt; shell function. &lt;code&gt;SUBDIRECTORY_OK&lt;/code&gt; can be set if the script can run from a subdirectory of the working tree (some commands do not).</source>
          <target state="translated">在采购它之前，您的脚本应该设置一些变量。 &lt;code&gt;USAGE&lt;/code&gt; （和 &lt;code&gt;LONG_USAGE&lt;/code&gt; ，如果有的话）用于定义use &lt;code&gt;usage()&lt;/code&gt; shell函数给出的消息。如果脚本可以从工作树的子目录运行（某些命令不能），则可以设置 &lt;code&gt;SUBDIRECTORY_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c54227fb5e450fcf91fd096bb9f0a84e555b6148" translate="yes" xml:space="preserve">
          <source>Before starting rebase, stash local modifications away (see &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;) if needed, and apply the stash entry when done. &lt;code&gt;--no-autostash&lt;/code&gt; is useful to override the &lt;code&gt;rebase.autoStash&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">在开始变基之前，如有必要，将本地修改存储起来（请参阅&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;），并在完成后应用存储项。 &lt;code&gt;--no-autostash&lt;/code&gt; 有助于覆盖 &lt;code&gt;rebase.autoStash&lt;/code&gt; 配置变量（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="20a98eb8f5ae5eb6921d2e55163fa9540eded227" translate="yes" xml:space="preserve">
          <source>Before starting, verify that there is corruption, and figure out where it is with &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;; this may be time-consuming.</source>
          <target state="translated">开始之前，请验证是否存在损坏，并使用&lt;a href=&quot;git-fsck&quot;&gt;git-fsck [1]&lt;/a&gt;找出损坏的位置。这可能很耗时。</target>
        </trans-unit>
        <trans-unit id="197ebbc21bdf962ed1c382324d4f3dcec04005ba" translate="yes" xml:space="preserve">
          <source>Before the colon may be anything that names a commit, and after it may be any path to a file tracked by Git.</source>
          <target state="translated">冒号前可以是任何提交的名称,冒号后可以是 Git 跟踪的任何文件的路径。</target>
        </trans-unit>
        <trans-unit id="0b4c2c97b5d492d26987ff45d09af0bb0c545781" translate="yes" xml:space="preserve">
          <source>Behave as if &lt;code&gt;git rev-parse&lt;/code&gt; was invoked from the &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; subdirectory of the working tree. Any relative filenames are resolved as if they are prefixed by &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; and will be printed in that form.</source>
          <target state="translated">行为就像从工作树的 &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; 子目录中调用了 &lt;code&gt;git rev-parse&lt;/code&gt; 一样。所有相对文件名都将以 &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; 为前缀进行解析，并以该格式打印。</target>
        </trans-unit>
        <trans-unit id="d02e70ae5f9ffc8904b317a23e079b2151794572" translate="yes" xml:space="preserve">
          <source>Behave as normal citool, but instead of making a commit simply terminate with a zero exit code. It still checks that the index does not contain any unmerged entries, so you can use it as a GUI version of &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt;</source>
          <target state="translated">行为与普通citool相同，但是除了进行提交外，只需以零退出代码终止即可。它仍然检查索引是否不包含任何未合并的条目，因此您可以将其用作&lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool [1]&lt;/a&gt;的GUI版本。</target>
        </trans-unit>
        <trans-unit id="1e338425ed36637ba6fc8582364ec79dbafaa8d3" translate="yes" xml:space="preserve">
          <source>Behavioral differences</source>
          <target state="translated">行为上的差异</target>
        </trans-unit>
        <trans-unit id="f0f0d8dfa2a076d1fea883054912f530ebc927c2" translate="yes" xml:space="preserve">
          <source>Besides blobs, trees, and commits, the only remaining type of object is a &quot;tag&quot;, which we won&amp;rsquo;t discuss here; refer to &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; for details.</source>
          <target state="translated">除了Blob，树和提交之外，唯一剩余的对象类型是&amp;ldquo;标记&amp;rdquo;，在此不再赘述。有关详细信息，请参考&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6077f120aaceb5046721fb58c100f8432db9b449" translate="yes" xml:space="preserve">
          <source>Besides specifying a range of commits that should be listed using the special notations explained in the description, additional commit limiting may be applied.</source>
          <target state="translated">除了使用描述中解释的特殊符号指定应该列出的提交范围外,还可以应用额外的提交限制。</target>
        </trans-unit>
        <trans-unit id="5d284c47fc77be8e46a6b104d3f25aff12fd50b7" translate="yes" xml:space="preserve">
          <source>Best bisecting practices</source>
          <target state="translated">最佳二分法</target>
        </trans-unit>
        <trans-unit id="6bc3ae89d4cbb3ba42878fb25652862ae42aa5fe" translate="yes" xml:space="preserve">
          <source>Beware that the default for &lt;code&gt;git send-email&lt;/code&gt; is to thread emails itself. If you want &lt;code&gt;git format-patch&lt;/code&gt; to take care of threading, you will want to ensure that threading is disabled for &lt;code&gt;git send-email&lt;/code&gt;.</source>
          <target state="translated">注意， &lt;code&gt;git send-email&lt;/code&gt; 的默认设置是使电子邮件本身成为线程。如果您希望 &lt;code&gt;git format-patch&lt;/code&gt; 负责线程处理，则需要确保 &lt;code&gt;git send-email&lt;/code&gt; 禁用了线程处理。</target>
        </trans-unit>
        <trans-unit id="945fefcb0d1953c9bddf033fe3e99288cf86cd4d" translate="yes" xml:space="preserve">
          <source>Bidirectional operation between a Subversion repository and Git</source>
          <target state="translated">Subversion仓库和Git之间的双向操作。</target>
        </trans-unit>
        <trans-unit id="6f22ed9717123d2ce9d3d667f975fb97ec48ef54" translate="yes" xml:space="preserve">
          <source>Binary files are searched as well.</source>
          <target state="translated">二进制文件也会被搜索到。</target>
        </trans-unit>
        <trans-unit id="8e08702a04bb0e3631c0db1c03ac41d9b78e02c9" translate="yes" xml:space="preserve">
          <source>Bisect log and bisect replay</source>
          <target state="translated">两段式日志和两段式回放</target>
        </trans-unit>
        <trans-unit id="caafd94a0cc48f8af98290661863ae3463dcd188" translate="yes" xml:space="preserve">
          <source>Bisect reset</source>
          <target state="translated">分割复位</target>
        </trans-unit>
        <trans-unit id="cfe9732e61ea56b98e10d88f828ff42f6e52d08e" translate="yes" xml:space="preserve">
          <source>Bisect run</source>
          <target state="translated">两段式运行</target>
        </trans-unit>
        <trans-unit id="e7eb00dc48d63079c3871fc0a679fc1160511d2f" translate="yes" xml:space="preserve">
          <source>Bisect skip</source>
          <target state="translated">二段跳</target>
        </trans-unit>
        <trans-unit id="5887bb0558b5608c8166ca0492b459bf81b4ac9e" translate="yes" xml:space="preserve">
          <source>Bisect visualize/view</source>
          <target state="translated">二分法可视化/查看</target>
        </trans-unit>
        <trans-unit id="5adebf631a26d512accb5dd4088829dcb8650be4" translate="yes" xml:space="preserve">
          <source>Bisecting between Z and D* would hit a single culprit commit Y*, and understanding why Y* was broken would probably be easier.</source>
          <target state="translated">在Z和D*之间进行Bisecting,会打出一个单一的罪魁祸首犯Y*,了解Y*为什么会被打破,可能会更容易。</target>
        </trans-unit>
        <trans-unit id="e52337c43cc4b33ac0d524be43e0ee7aabfe896f" translate="yes" xml:space="preserve">
          <source>Bisecting build failures</source>
          <target state="translated">分割构建失败</target>
        </trans-unit>
        <trans-unit id="247595ab20eacd2b287d2671e0cd44ffe5d63f96" translate="yes" xml:space="preserve">
          <source>Bisecting sporadic bugs</source>
          <target state="translated">分割零星虫子</target>
        </trans-unit>
        <trans-unit id="c849a8d6d5f17f13126d2a3ffa47e78949cbd571" translate="yes" xml:space="preserve">
          <source>Bisection Helpers</source>
          <target state="translated">双节帮助者</target>
        </trans-unit>
        <trans-unit id="81ab75db6833dc6c35d461635f7c0fa8e4339b5c" translate="yes" xml:space="preserve">
          <source>Bisection algorithm</source>
          <target state="translated">分割算法</target>
        </trans-unit>
        <trans-unit id="1073b9bc85c670179e7dcf4cfd5cd0b022c46d78" translate="yes" xml:space="preserve">
          <source>Bisection algorithm debugging</source>
          <target state="translated">分割算法调试</target>
        </trans-unit>
        <trans-unit id="2146a76855ff13537405bb4dc1d3e621b6d2530e" translate="yes" xml:space="preserve">
          <source>Bisection algorithm discussed</source>
          <target state="translated">讨论的二段式算法</target>
        </trans-unit>
        <trans-unit id="3e65a55a7b3fcaab5f39381d806f63fcab2ecabb" translate="yes" xml:space="preserve">
          <source>BitKeeper/cvsps speak for &quot;&lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt;&quot;. Since Git does not store changes, but states, it really does not make sense to use the term &quot;changesets&quot; with Git.</source>
          <target state="translated">BitKeeper / cvsps表示&amp;ldquo; &lt;a href=&quot;#def_commit&quot;&gt;提交&lt;/a&gt; &amp;rdquo;。由于Git不存储更改，而是声明，因此在Git中使用术语&amp;ldquo;更改集&amp;rdquo;确实没有任何意义。</target>
        </trans-unit>
        <trans-unit id="57bd2a9f31bd11a6f563b358aadd2a286592b86a" translate="yes" xml:space="preserve">
          <source>Blank lines are ignored, and lines that don&amp;rsquo;t match this specification are used as option group headers (start the line with a space to create such lines on purpose).</source>
          <target state="translated">空行将被忽略，与该规范不匹配的行将用作选项组标题（以空格开头的行有意创建此类行）。</target>
        </trans-unit>
        <trans-unit id="5327cbfdb1bf8f5a47bca233a1bde391d44b215a" translate="yes" xml:space="preserve">
          <source>Blank lines are ignored, so they can be used as separators for readability.</source>
          <target state="translated">空白线会被忽略,因此它们可以被用作分隔符,以便于阅读。</target>
        </trans-unit>
        <trans-unit id="d7077b7354ef7afaa6b1de41b77813742be4c707" translate="yes" xml:space="preserve">
          <source>Blob Object</source>
          <target state="translated">Blob对象</target>
        </trans-unit>
        <trans-unit id="f04feb5337017d625e39e5a69c692bf6273fb704" translate="yes" xml:space="preserve">
          <source>Blocks of moved text are detected as in &lt;code&gt;blocks&lt;/code&gt; mode. The blocks are painted using either the &lt;code&gt;color.diff.{old,new}Moved&lt;/code&gt; color or &lt;code&gt;color.diff.{old,new}MovedAlternative&lt;/code&gt;. The change between the two colors indicates that a new block was detected.</source>
          <target state="translated">与在 &lt;code&gt;blocks&lt;/code&gt; 模式下一样，检测到已移动文本的块。使用 &lt;code&gt;color.diff.{old,new}Moved&lt;/code&gt; color或 &lt;code&gt;color.diff.{old,new}MovedAlternative&lt;/code&gt; 。两种颜色之间的变化表示检测到新的块。</target>
        </trans-unit>
        <trans-unit id="f42755e1f80735be0fde7ac7e2cbeb956df2c96e" translate="yes" xml:space="preserve">
          <source>Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the &lt;code&gt;color.diff.{old,new}Moved&lt;/code&gt; color. Adjacent blocks cannot be told apart.</source>
          <target state="translated">贪婪地检测到至少包含20个字母数字字符的移动文本块。使用 &lt;code&gt;color.diff.{old,new}Moved&lt;/code&gt; 颜色绘制检测到的块。不能将相邻的块区分开。</target>
        </trans-unit>
        <trans-unit id="66547f4a0e63cd4ad00756855db6ddba1142e4d3" translate="yes" xml:space="preserve">
          <source>Bob begins with:</source>
          <target state="translated">鲍勃以。</target>
        </trans-unit>
        <trans-unit id="bcf42567e6f70a4579bf8687eb5f4e62c5870c89" translate="yes" xml:space="preserve">
          <source>Bob then makes some changes and commits them:</source>
          <target state="translated">然后,鲍勃做了一些修改并提交。</target>
        </trans-unit>
        <trans-unit id="d0685c88b15694d30796d8493ed6c8ce3e6b4b74" translate="yes" xml:space="preserve">
          <source>Boolean false literals are &lt;code&gt;no&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; and the empty string.</source>
          <target state="translated">布尔型false文字是 &lt;code&gt;no&lt;/code&gt; ， &lt;code&gt;off&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;0&lt;/code&gt; 和空字符串。</target>
        </trans-unit>
        <trans-unit id="c8e93181a2c2334cd611c796a9d2346e913aadda" translate="yes" xml:space="preserve">
          <source>Boolean true literals are &lt;code&gt;yes&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;1&lt;/code&gt;. Also, a variable defined without &lt;code&gt;= &amp;lt;value&amp;gt;&lt;/code&gt; is taken as true.</source>
          <target state="translated">布尔值真实文字为 &lt;code&gt;yes&lt;/code&gt; ， &lt;code&gt;on&lt;/code&gt; ， &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 。同样，将不带 &lt;code&gt;= &amp;lt;value&amp;gt;&lt;/code&gt; 定义的变量视为true。</target>
        </trans-unit>
        <trans-unit id="f03ce708ae8563bbe292f147105bcbebd35fdd1f" translate="yes" xml:space="preserve">
          <source>Boolean value indicating if the submodule is of interest to git commands. This config option takes precedence over the submodule.active config option. See &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for details.</source>
          <target state="translated">布尔值，指示子模块是否对git命令感兴趣。此配置选项优先于submodule.active配置选项。有关详细信息，请参见&lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40de397dbe4a181644b13a510b500ba0dfa90dc8" translate="yes" xml:space="preserve">
          <source>Boolean variable which defines if large files are automatically pushed to a server.</source>
          <target state="translated">布尔变量,用于定义是否将大文件自动推送到服务器。</target>
        </trans-unit>
        <trans-unit id="edb8137a3de82e7f1ab7c05bad252ac0da09a46a" translate="yes" xml:space="preserve">
          <source>Boolean. When true &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted from PERF output. May be overridden by the &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; environment variable. Defaults to false.</source>
          <target state="translated">布尔值。当为true &lt;code&gt;time&lt;/code&gt; ， &lt;code&gt;filename&lt;/code&gt; 和 &lt;code&gt;line&lt;/code&gt; 字段时，将从PERF输出中省略。可以被 &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; 环境变量覆盖。默认为false。</target>
        </trans-unit>
        <trans-unit id="e7da8527471f3ea2c3faf910dfb4b6accdd8c262" translate="yes" xml:space="preserve">
          <source>Boolean. When true &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted from event output. May be overridden by the &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; environment variable. Defaults to false.</source>
          <target state="translated">布尔值。如果为true &lt;code&gt;time&lt;/code&gt; ， &lt;code&gt;filename&lt;/code&gt; 和 &lt;code&gt;line&lt;/code&gt; 字段，则从事件输出中省略。可以被 &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; 环境变量覆盖。默认为false。</target>
        </trans-unit>
        <trans-unit id="d6cb13ebbd3c085c01cd755d0c697831e337b51f" translate="yes" xml:space="preserve">
          <source>Boolean. When true &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted from normal output. May be overridden by the &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; environment variable. Defaults to false.</source>
          <target state="translated">布尔值。如果为true &lt;code&gt;time&lt;/code&gt; ， &lt;code&gt;filename&lt;/code&gt; 和 &lt;code&gt;line&lt;/code&gt; 字段，则从常规输出中省略。可以被 &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; 环境变量覆盖。默认为false。</target>
        </trans-unit>
        <trans-unit id="2c3dcfd71724f2fb257997b8beb70ed9ac8363b1" translate="yes" xml:space="preserve">
          <source>Boolean. When true Git will print error messages when a trace target destination cannot be opened for writing. By default, these errors are suppressed and tracing is silently disabled. May be overridden by the &lt;code&gt;GIT_TRACE2_DST_DEBUG&lt;/code&gt; environment variable.</source>
          <target state="translated">布尔值。如果为true，当无法打开跟踪目标位置进行写入时，Git将打印错误消息。默认情况下，将抑制这些错误，并且将静默禁用跟踪。可以被 &lt;code&gt;GIT_TRACE2_DST_DEBUG&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="51e76e8d328efb625976c83e352d738d4b25cc97" translate="yes" xml:space="preserve">
          <source>Boolean. When true, client and server processes will advertise their unique session IDs to their remote counterpart. Defaults to false.</source>
          <target state="translated">布尔型。当为 &quot;true &quot;时,客户端和服务器进程将向其远程对应方宣传其唯一的会话ID。默认值为false。</target>
        </trans-unit>
        <trans-unit id="e5522e55cd06bc09c2f312c8e91e3e9369d6fed7" translate="yes" xml:space="preserve">
          <source>Borrow the objects from reference repositories specified with the &lt;code&gt;--reference&lt;/code&gt; options only to reduce network transfer, and stop borrowing from them after a clone is made by making necessary local copies of borrowed objects. This option can also be used when cloning locally from a repository that already borrows objects from another repository&amp;mdash;​the new repository will borrow objects from the same repository, and this option can be used to stop the borrowing.</source>
          <target state="translated">从使用 &lt;code&gt;--reference&lt;/code&gt; 选项指定的参考存储库中借用对象仅是为了减少网络传输，并在复制后通过制作借用对象的必要本地副本来停止从对象借用。从已经从另一个存储库借用对象的存储库本地克隆时，也可以使用此选项-新存储库将从同一个存储库借用对象，并且该选项可用于停止借用。</target>
        </trans-unit>
        <trans-unit id="5694355a4e9f21af75bfd457be1c695646467936" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;--cacheinfo&lt;/code&gt; and &lt;code&gt;--info-only&lt;/code&gt; behave similarly: the index is updated but the object database isn&amp;rsquo;t. &lt;code&gt;--cacheinfo&lt;/code&gt; is useful when the object is in the database but the file isn&amp;rsquo;t available locally. &lt;code&gt;--info-only&lt;/code&gt; is useful when the file is available, but you do not wish to update the object database.</source>
          <target state="translated">无论 &lt;code&gt;--cacheinfo&lt;/code&gt; 和 &lt;code&gt;--info-only&lt;/code&gt; 的行为类似：索引更新，但是对象数据库是没有的。当对象位于数据库中但文件在本地不可用时， &lt;code&gt;--cacheinfo&lt;/code&gt; 很有用。当文件可用时， &lt;code&gt;--info-only&lt;/code&gt; 很有用，但是您不希望更新对象数据库。</target>
        </trans-unit>
        <trans-unit id="210e82ac599d9d8944e3c5eb9d03d4a4abcf7207" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;plink&lt;/code&gt; and &lt;code&gt;alink&lt;/code&gt; point outside the tree, so they would respectively print:</source>
          <target state="translated">无论 &lt;code&gt;plink&lt;/code&gt; 和 &lt;code&gt;alink&lt;/code&gt; 外树点，因此他们将分别打印：</target>
        </trans-unit>
        <trans-unit id="9a953a9b4782d5c56832edbe239c8ec4aaa470f8" translate="yes" xml:space="preserve">
          <source>Both fixes are tested well, and at this point, you want to merge in both of them. You could merge in &lt;code&gt;diff-fix&lt;/code&gt; first and then &lt;code&gt;commit-fix&lt;/code&gt; next, like this:</source>
          <target state="translated">这两个修复程序都经过了良好的测试，此时，您希望将它们合并。您可以先在 &lt;code&gt;diff-fix&lt;/code&gt; 中合并，然后再在 &lt;code&gt;commit-fix&lt;/code&gt; 中合并，如下所示：</target>
        </trans-unit>
        <trans-unit id="9af6db9f29dd4e151f33497260a5a0b8ba4e0513" translate="yes" xml:space="preserve">
          <source>Both ofs-delta and ref-delta store the &quot;delta&quot; to be applied to another object (called &lt;code&gt;base object&lt;/code&gt;) to reconstruct the object. The difference between them is, ref-delta directly encodes 20-byte base object name. If the base object is in the same pack, ofs-delta encodes the offset of the base object in the pack instead.</source>
          <target state="translated">ofs-delta和ref-delta都存储要应用到另一个对象（称为 &lt;code&gt;base object&lt;/code&gt; ）以重构对象的&amp;ldquo; delta&amp;rdquo; 。它们之间的区别是，ref-delta直接编码20字节的基础对象名称。如果基础对象在同一包中，则ofs-delta会代替编码该基础对象在包中的偏移量。</target>
        </trans-unit>
        <trans-unit id="70067b173cdeaaf22d52d43a160f5295eccba4fc" translate="yes" xml:space="preserve">
          <source>Both ofs-delta and ref-delta store the &quot;delta&quot; to be applied to another object (called &lt;code&gt;base object&lt;/code&gt;) to reconstruct the object. The difference between them is, ref-delta directly encodes base object name. If the base object is in the same pack, ofs-delta encodes the offset of the base object in the pack instead.</source>
          <target state="translated">ofs-delta和ref-delta都存储要应用到另一个对象（称为 &lt;code&gt;base object&lt;/code&gt; ）以重构对象的&amp;ldquo; delta&amp;rdquo; 。它们之间的区别是，ref-delta直接编码基础对象名称。如果基础对象在同一数据包中，则ofs-delta会代替编码该基础对象在数据包中的偏移量。</target>
        </trans-unit>
        <trans-unit id="b68fc1d55d49e0827f78d9949a9c5a2eecaf05eb" translate="yes" xml:space="preserve">
          <source>Both settings can be overridden on the command line by using the &quot;--ignore-submodules&quot; option. The &lt;code&gt;git submodule&lt;/code&gt; commands are not affected by this setting.</source>
          <target state="translated">可以使用&amp;ldquo; --ignore-submodules&amp;rdquo;选项在命令行上覆盖这两种设置。在 &lt;code&gt;git submodule&lt;/code&gt; 的命令不受此设置。</target>
        </trans-unit>
        <trans-unit id="2bb1e035fa86f5b4222d3ab1eb33c1658eed9a23" translate="yes" xml:space="preserve">
          <source>Both standard output and standard error output are forwarded to &lt;code&gt;git send-pack&lt;/code&gt; on the other end, so you can simply &lt;code&gt;echo&lt;/code&gt; messages for the user.</source>
          <target state="translated">标准输出和标准错误输出都转发到另一端的 &lt;code&gt;git send-pack&lt;/code&gt; ，因此您可以简单地为用户 &lt;code&gt;echo&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="7c76084a5f517b3242aa149971fbcce3ceb62c61" translate="yes" xml:space="preserve">
          <source>Both the &amp;lt;eolinfo&amp;gt; in the index (&quot;i/&amp;lt;eolinfo&amp;gt;&quot;) and in the working tree (&quot;w/&amp;lt;eolinfo&amp;gt;&quot;) are shown for regular files, followed by the (&quot;attr/&amp;lt;eolattr&amp;gt;&quot;).</source>
          <target state="translated">在常规文件中显示索引（&amp;ldquo; i / &amp;lt;eolinfo&amp;gt;&amp;rdquo;）和工作树（&amp;ldquo; w / &amp;lt;eolinfo&amp;gt;&amp;rdquo;）中的&amp;lt;eolinfo&amp;gt;，后跟（&amp;ldquo; attr / &amp;lt;eolattr&amp;gt;&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="c634179a023801afb75e60cfb7d88f35c1e83a21" translate="yes" xml:space="preserve">
          <source>Both the symlink &amp;amp; realpath versions of paths will be matched outside of &lt;code&gt;$GIT_DIR&lt;/code&gt;. E.g. if ~/git is a symlink to /mnt/storage/git, both &lt;code&gt;gitdir:~/git&lt;/code&gt; and &lt;code&gt;gitdir:/mnt/storage/git&lt;/code&gt; will match.</source>
          <target state="translated">路径的symlink和realpath版本都将在 &lt;code&gt;$GIT_DIR&lt;/code&gt; 之外进行匹配。例如，如果〜/ git是/ mnt / storage / git的符号链接，则 &lt;code&gt;gitdir:~/git&lt;/code&gt; 和 &lt;code&gt;gitdir:/mnt/storage/git&lt;/code&gt; 都将匹配。</target>
        </trans-unit>
        <trans-unit id="fb26b800dd56fd61a55a4281547b9e60ac65a113" translate="yes" xml:space="preserve">
          <source>Branch Headers</source>
          <target state="translated">分部标题</target>
        </trans-unit>
        <trans-unit id="6e15a503d2a4c17b67a8c3c7f34c58a07a49a276" translate="yes" xml:space="preserve">
          <source>Branch description, can be edited with &lt;code&gt;git branch --edit-description&lt;/code&gt;. Branch description is automatically added in the format-patch cover letter or request-pull summary.</source>
          <target state="translated">分支描述，可以使用 &lt;code&gt;git branch --edit-description&lt;/code&gt; 进行编辑。分支描述会自动添加到格式补丁的求职信或请求摘要中。</target>
        </trans-unit>
        <trans-unit id="5bec4527e15afa13a84c736e3c723988984e6324" translate="yes" xml:space="preserve">
          <source>Branch detection</source>
          <target state="translated">分支检测</target>
        </trans-unit>
        <trans-unit id="f63ceca75fd06c6b871dea1a79cac70839c63882" translate="yes" xml:space="preserve">
          <source>Branch management for a release</source>
          <target state="translated">发布的分支机构管理</target>
        </trans-unit>
        <trans-unit id="50637014a89740451f5074b5c0e9645bb5f5e1e3" translate="yes" xml:space="preserve">
          <source>Branch management for next and pu after a feature release</source>
          <target state="translated">在功能发布后对next和pu进行分支管理。</target>
        </trans-unit>
        <trans-unit id="847b5d9af115c8e50f1c00175c8525563c7e932f" translate="yes" xml:space="preserve">
          <source>Branch management for next and seen after a feature release</source>
          <target state="translated">分支管理,用于下一步和功能发布后的查看。</target>
        </trans-unit>
        <trans-unit id="cbca9c5458a752e67c3b22c7754c8dd03612ff9c" translate="yes" xml:space="preserve">
          <source>Branch of repository to add as submodule. The name of the branch is recorded as &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; in &lt;code&gt;.gitmodules&lt;/code&gt; for &lt;code&gt;update --remote&lt;/code&gt;. A special value of &lt;code&gt;.&lt;/code&gt; is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository. If the option is not specified, it defaults to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">要添加为子模块的存储库分支。该分支的名称被记录为 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 在 &lt;code&gt;.gitmodules&lt;/code&gt; 用于 &lt;code&gt;update --remote&lt;/code&gt; 。的特殊值 &lt;code&gt;.&lt;/code&gt; 用于表示子模块中的分支名称应与当前存储库中的当前分支相同。如果未指定该选项，则默认为 &lt;code&gt;master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b69ea5570ecde693b275ccf40b6be842c78a8726" translate="yes" xml:space="preserve">
          <source>Branch of repository to add as submodule. The name of the branch is recorded as &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; in &lt;code&gt;.gitmodules&lt;/code&gt; for &lt;code&gt;update --remote&lt;/code&gt;. A special value of &lt;code&gt;.&lt;/code&gt; is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository. If the option is not specified, it defaults to the remote &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">要添加为子模块的存储库分支。该分支的名称被记录为 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 在 &lt;code&gt;.gitmodules&lt;/code&gt; 用于 &lt;code&gt;update --remote&lt;/code&gt; 。的特殊值 &lt;code&gt;.&lt;/code&gt; 用于表示子模块中的分支名称应与当前存储库中的当前分支相同。如果未指定该选项，则默认为远程 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3db6088987588160d14194fc92edec728f16ab3" translate="yes" xml:space="preserve">
          <source>Branch off of a specific tag.</source>
          <target state="translated">特定标签的分支。</target>
        </trans-unit>
        <trans-unit id="a41d6fc58b77cd15fdc95f9b8068f3bedb454bc6" translate="yes" xml:space="preserve">
          <source>Branch to checkout; if it refers to a branch (i.e., a name that, when prepended with &quot;refs/heads/&quot;, is a valid ref), then that branch is checked out. Otherwise, if it refers to a valid commit, your &lt;code&gt;HEAD&lt;/code&gt; becomes &quot;detached&quot; and you are no longer on any branch (see below for details).</source>
          <target state="translated">结帐至结帐；如果它引用一个分支（即名称，当以&amp;ldquo; refs / heads /&amp;rdquo;开头时是有效的引用），则将该分支检出。否则，如果它引用有效的提交，则 &lt;code&gt;HEAD&lt;/code&gt; 将变为&amp;ldquo;分离&amp;rdquo;，并且您将不再位于任何分支上（有关详细信息，请参见下文）。</target>
        </trans-unit>
        <trans-unit id="8b21526e9a7ba9f6110db09d1bb17e93bbda77fa" translate="yes" xml:space="preserve">
          <source>Branch to switch to.</source>
          <target state="translated">支部切换到。</target>
        </trans-unit>
        <trans-unit id="79cd2f09f7574ee3c255526cc9dfc53740a35d6b" translate="yes" xml:space="preserve">
          <source>Branch updates can be forced with --force, but it&amp;rsquo;s recommended that this only be used on an otherwise quiet repository. Using --force is not necessary for an initial import into an empty repository.</source>
          <target state="translated">可以使用--force强制执行分支更新，但建议仅在其他安静的存储库上使用。初始导入到空存储库中不需要使用--force。</target>
        </trans-unit>
        <trans-unit id="e985dfb396afc27ce07bbb1b298aa21e35e0ea0d" translate="yes" xml:space="preserve">
          <source>Branches are cheap and easy, so this is a good way to try something out.</source>
          <target state="translated">枝条便宜又简单,所以这是个不错的尝试方式。</target>
        </trans-unit>
        <trans-unit id="879b754d99bf64defbd79d89d51b97c6e52dfbf4" translate="yes" xml:space="preserve">
          <source>Branches are classified as active and inactive. The memory usage of the two classes is significantly different.</source>
          <target state="translated">分支机构分为活跃和非活跃两类。两类分支的内存使用量有很大不同。</target>
        </trans-unit>
        <trans-unit id="19038dfa38a59c4f1be05e3d92e0f1bca8b5557f" translate="yes" xml:space="preserve">
          <source>Branches in Git are really nothing more than pointers into the Git object database from within the &lt;code&gt;.git/refs/&lt;/code&gt; subdirectory, and as we already discussed, the &lt;code&gt;HEAD&lt;/code&gt; branch is nothing but a symlink to one of these object pointers.</source>
          <target state="translated">Git中的分支实际上只不过是从 &lt;code&gt;.git/refs/&lt;/code&gt; 子目录中进入Git对象数据库的指针，正如我们已经讨论的， &lt;code&gt;HEAD&lt;/code&gt; 分支不过是指向这些对象指针之一的符号链接。</target>
        </trans-unit>
        <trans-unit id="125404877d39f029f0e27e0fb84f104c52bd667b" translate="yes" xml:space="preserve">
          <source>Branches on which no commits have been made are not imported.</source>
          <target state="translated">没有提交的分支不被导入。</target>
        </trans-unit>
        <trans-unit id="415a16be057cec5701bb9e0fd3bff5400f270979" translate="yes" xml:space="preserve">
          <source>Branches, remote-tracking branches, and tags are all references to commits. All references are named with a slash-separated path name starting with &lt;code&gt;refs&lt;/code&gt;; the names we&amp;rsquo;ve been using so far are actually shorthand:</source>
          <target state="translated">分支，远程跟踪分支和标记都是对提交的引用。所有引用均以以斜杠分隔的路径名命名，以 &lt;code&gt;refs&lt;/code&gt; 开头；到目前为止，我们一直使用的名称实际上是速记：</target>
        </trans-unit>
        <trans-unit id="b3d9b26ec0345692adbda512336186fddd0ce297" translate="yes" xml:space="preserve">
          <source>Branching and Merging</source>
          <target state="translated">分支和合并</target>
        </trans-unit>
        <trans-unit id="15e01902c81d07c3b90042ff2531422b8b3d1b86" translate="yes" xml:space="preserve">
          <source>Break complete rewrite changes into pairs of delete and create. This serves two purposes:</source>
          <target state="translated">将完整的重写更改分成删除和创建两对。这有两个目的。</target>
        </trans-unit>
        <trans-unit id="672fc0738ea8c1007bcaceee5284378a52766797" translate="yes" xml:space="preserve">
          <source>Browse the &lt;code&gt;modules&lt;/code&gt; available. It will give you a list of the heads in the repository. You will not be able to browse the tree from there. Only the heads.</source>
          <target state="translated">浏览可用的 &lt;code&gt;modules&lt;/code&gt; 。它将为您提供存储库中负责人的列表。您将无法从那里浏览树。只有元首。</target>
        </trans-unit>
        <trans-unit id="abb2e552cc2091e364809101c300cc4143caaa39" translate="yes" xml:space="preserve">
          <source>Browsing every revision of the repository.</source>
          <target state="translated">浏览版本库的每个版本。</target>
        </trans-unit>
        <trans-unit id="f92f422e95f0fd94e3584d36660177eaf6c3a90d" translate="yes" xml:space="preserve">
          <source>Browsing revisions</source>
          <target state="translated">浏览修订版</target>
        </trans-unit>
        <trans-unit id="6d55509876929eae63b680c2015c0e8dcd714d8d" translate="yes" xml:space="preserve">
          <source>Buffering happens as documented under the &lt;code&gt;GIT_FLUSH&lt;/code&gt; option in &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;. The caller is responsible for avoiding deadlocks caused by overfilling an input buffer or reading from an empty output buffer.</source>
          <target state="translated">缓冲发生在&lt;a href=&quot;git&quot;&gt;git [1]中&lt;/a&gt;的 &lt;code&gt;GIT_FLUSH&lt;/code&gt; 选项下。调用程序负责避免由于输入缓冲区溢出或从空的输出缓冲区读取而导致的死锁。</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="30410812dc9752c13886986132ffab9500651b55" translate="yes" xml:space="preserve">
          <source>Bugs in the implementation of overlap mappings exist. If multiple depot paths map through overlays to the same location in the repository, &lt;code&gt;git p4&lt;/code&gt; can choose the wrong one. This is hard to solve without dedicating a client spec just for &lt;code&gt;git p4&lt;/code&gt;.</source>
          <target state="translated">存在重叠映射实现中的错误。如果多个仓库路径通过覆盖图映射到存储库中的同一位置，则 &lt;code&gt;git p4&lt;/code&gt; 可能选择错误的路径。如果不为 &lt;code&gt;git p4&lt;/code&gt; 专门指定客户规范，这很难解决。</target>
        </trans-unit>
        <trans-unit id="8c875875a4eba5d2b4104ba5b53fe3484e74b27e" translate="yes" xml:space="preserve">
          <source>Build a tree-object from ls-tree formatted text</source>
          <target state="translated">从ls-tree格式化的文本建立一个树形对象。</target>
        </trans-unit>
        <trans-unit id="043dc36933914b47740e7f5065ce440656dbe0ca" translate="yes" xml:space="preserve">
          <source>Build pack index file for an existing packed archive</source>
          <target state="translated">为现有的打包存档建立打包索引文件</target>
        </trans-unit>
        <trans-unit id="8dd0ad60c49a72540d98588b5b0558fd314e85ee" translate="yes" xml:space="preserve">
          <source>Built-in 3-way merge driver is used to merge the contents in a way similar to &lt;code&gt;merge&lt;/code&gt; command of &lt;code&gt;RCS&lt;/code&gt; suite. This is suitable for ordinary text files.</source>
          <target state="translated">内置的三向合并驱动程序用于以类似于 &lt;code&gt;RCS&lt;/code&gt; 套件的 &lt;code&gt;merge&lt;/code&gt; 命令的方式合并内容。这适用于普通文本文件。</target>
        </trans-unit>
        <trans-unit id="0829c07e98ca5098038c31cb2a5b51c3902a8814" translate="yes" xml:space="preserve">
          <source>Built-in merge drivers</source>
          <target state="translated">内置合并驱动程序</target>
        </trans-unit>
        <trans-unit id="fe507ac4ab5d31826c1b03d804bf3ff265bad65b" translate="yes" xml:space="preserve">
          <source>Bundling your work together</source>
          <target state="translated">将您的工作捆绑在一起</target>
        </trans-unit>
        <trans-unit id="25fde7a2ceaafceba047201a41d303d6c07bd23d" translate="yes" xml:space="preserve">
          <source>But BBChop is independent of any VCS and it would be easier for Git users to have something integrated in Git.</source>
          <target state="translated">但BBChop是独立于任何VCS的,如果能在Git中集成一些东西,对Git用户来说会更方便。</target>
        </trans-unit>
        <trans-unit id="f7eefc5fb4183d567fceb246626226ef9afb8bf2" translate="yes" xml:space="preserve">
          <source>But Ingo Molnar and H. Peter Anvin (another well known linux kernel developer) both complained that sometimes the best bisection points all happened to be in an area where all the commits are untestable. And in this case the user was asked to test many untestable commits, which could be very inefficient.</source>
          <target state="translated">但Ingo Molnar和H.Peter Anvin(另一位著名的linux内核开发者)都抱怨说,有时最好的二分法点恰好都在一个所有提交都不可测试的区域。而在这种情况下,用户被要求测试许多不可测试的提交,这可能是非常低效的。</target>
        </trans-unit>
        <trans-unit id="74140d3773084e209fc43c63f870a2ce5abd4ea1" translate="yes" xml:space="preserve">
          <source>But if you have pushed things out (or others could just read your repository directly), then others will have already seen the old tag. In that case you can do one of two things:</source>
          <target state="translated">但是如果你已经把东西推送出去了(或者其他人可以直接读取你的版本库),那么其他人就已经看到了旧的标签。在这种情况下,你可以做两件事中的一件。</target>
        </trans-unit>
        <trans-unit id="66013f3cefed95fb73f834fded3820e6a1071c28" translate="yes" xml:space="preserve">
          <source>But if you try to push, you will attempt to update the branch (that now points at A) with commit B. This does &lt;code&gt;not&lt;/code&gt; fast-forward. If you did so, the changes introduced by commit A will be lost, because everybody will now start building on top of B.</source>
          <target state="translated">但是，如果您尝试推送，则将尝试使用提交B更新分支（现在指向A）。这 &lt;code&gt;not&lt;/code&gt; 快进。如果这样做，则提交A引入的更改将丢失，因为现在每个人都将开始在B的基础上进行构建。</target>
        </trans-unit>
        <trans-unit id="fd8e45cbd58877735e25105978c0aca9791da6ee" translate="yes" xml:space="preserve">
          <source>But in some repository setups, you may have several related but separate groups of ref tips, with clients tending to fetch those groups independently. For example, imagine that you are hosting several &quot;forks&quot; of a repository in a single shared object store, and letting clients view them as separate repositories through &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; or separate repos using the alternates mechanism. A naive repack may find that the optimal delta for an object is against a base that is only found in another fork. But when a client fetches, they will not have the base object, and we&amp;rsquo;ll have to find a new delta on the fly.</source>
          <target state="translated">但是在某些存储库设置中，您可能有几个相关但独立的参考提示组，客户端倾向于独立获取这些组。例如，假设您在单个共享库中托管一个存储库的多个&amp;ldquo;分支&amp;rdquo;，然后让客户端通过 &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; 将它们视为独立的存储库，或者使用替代机制将其视为独立的存储库。幼稚的重新打包可能会发现对象的最佳增量与仅在另一个fork中找到的基准相对。但是，当客户端获取数据时，它们将没有基础对象，我们将不得不动态查找新的增量。</target>
        </trans-unit>
        <trans-unit id="a02a23b585c823168e0aade261aba54b02ee9df4" translate="yes" xml:space="preserve">
          <source>But now we can do</source>
          <target state="translated">但现在我们可以做</target>
        </trans-unit>
        <trans-unit id="d83b34d996269d86f487bc1b1bf210759565be26" translate="yes" xml:space="preserve">
          <source>But the above ways to work around untestable areas are a little bit clunky. Using special branches is nice because these branches can be shared by developers like usual branches, but the risk is that people will get many such branches. And it disrupts the normal &quot;git bisect&quot; work-flow. So, if you want to use &quot;git bisect run&quot; completely automatically, you have to add special code in your script to restart bisection in the special branches.</source>
          <target state="translated">但以上绕过不可测试区域的方法有点笨拙。使用特殊的分支是不错的,因为这些分支可以像平常的分支一样被开发者共享,但风险是人们会得到很多这样的分支。而且会破坏正常的 &quot;git一分为二 &quot;的工作流程。所以,如果你想完全自动地使用 &quot;git bisect run&quot;,你必须在你的脚本中添加特殊的代码来重启特殊分支中的bisection。</target>
        </trans-unit>
        <trans-unit id="d51bf10c62a548cc7f488f7d7c601612ef19bfbf" translate="yes" xml:space="preserve">
          <source>But there are other ways to refer to commits. You can use any initial part of the name that is long enough to uniquely identify the commit:</source>
          <target state="translated">但是还有其他的方式来引用提交。您可以使用名称的任何首字母部分,只要足够长,就可以唯一地识别提交。</target>
        </trans-unit>
        <trans-unit id="7cbb3ccd9eb2da169028fcad03ea4127b40731fc" translate="yes" xml:space="preserve">
          <source>But this is wrong because at step 1) a) we keep only the ancestors of the bad commit. So we get more information when a commit is marked as &quot;bad&quot;, because we also know that the ancestors of the previous &quot;bad&quot; commit that are not ancestors of the new &quot;bad&quot; commit are not the first bad commit. We don&amp;rsquo;t know if they are good or bad, but we know that they are not the first bad commit because they are not ancestor of the new &quot;bad&quot; commit.</source>
          <target state="translated">但这是错误的，因为在步骤1）a）中，我们仅保留错误提交的祖先。因此，当将提交标记为&amp;ldquo;不良&amp;rdquo;时，我们会获得更多信息，因为我们还知道，先前的&amp;ldquo;不良&amp;rdquo;提交的祖先不是新的&amp;ldquo;不良&amp;rdquo;提交的祖先，也不是第一个不良提交。我们不知道它们是好是坏，但我们知道它们不是第一个错误的提交，因为它们不是新的&amp;ldquo;错误&amp;rdquo;提交的祖先。</target>
        </trans-unit>
        <trans-unit id="e9cd8c15ffc7ac156f5f412fb85c3db80183014e" translate="yes" xml:space="preserve">
          <source>But we can guess that improving on existing software is very costly because you have to watch out for regressions. At least this would make the above studies consistent among themselves.</source>
          <target state="translated">但我们可以猜测,在现有软件的基础上进行改进是非常昂贵的,因为你必须小心回归。至少这可以使上述研究之间保持一致。</target>
        </trans-unit>
        <trans-unit id="01400b0b75aa93032834530c59a576c885a202c7" translate="yes" xml:space="preserve">
          <source>But what happens if the first bad commit is &quot;B&quot; and if it has been fixed in the &quot;main&quot; branch by commit &quot;F&quot;?</source>
          <target state="translated">但是,如果第一个坏的提交是 &quot;B&quot;,而在 &quot;main &quot;分支中已经通过提交 &quot;F &quot;进行了修复,会发生什么?</target>
        </trans-unit>
        <trans-unit id="2333cc37236068d07ee88795051fd2e9ba955821" translate="yes" xml:space="preserve">
          <source>But you can use &lt;code&gt;reset --keep&lt;/code&gt; to remove the unwanted commit after you switched to &lt;code&gt;branch2&lt;/code&gt;.</source>
          <target state="translated">但是在切换到 &lt;code&gt;branch2&lt;/code&gt; 之后，可以使用 &lt;code&gt;reset --keep&lt;/code&gt; 删除不需要的提交。</target>
        </trans-unit>
        <trans-unit id="5d0b3a86464faedd1c461b3e2ac63fc4ba06661b" translate="yes" xml:space="preserve">
          <source>But you decided that the topic branch is not ready for public consumption yet. &quot;pull&quot; or &quot;merge&quot; always leaves the original tip of the current branch in &lt;code&gt;ORIG_HEAD&lt;/code&gt;, so resetting hard to it brings your index file and the working tree back to that state, and resets the tip of the branch to that commit.</source>
          <target state="translated">但是您认为主题分支尚未准备好供公众使用。&amp;ldquo; pull&amp;rdquo;或&amp;ldquo; merge&amp;rdquo;总是将当前分支的原始尖端 &lt;code&gt;ORIG_HEAD&lt;/code&gt; 在ORIG_HEAD中，因此对其进行硬重置会使索引文件和工作树回到该状态，并将分支的尖端重置为该提交。</target>
        </trans-unit>
        <trans-unit id="ec1fc17da64a933cb8c9dafb08caa5e756b65a2b" translate="yes" xml:space="preserve">
          <source>By adding a glob that matches the names of integration branches to this multi-valued configuration variable, the default merge message computed for merges into these integration branches will omit &quot;into &amp;lt;branch name&amp;gt;&quot; from its title.</source>
          <target state="translated">通过向该多值配置变量添加与集成分支的名称匹配的glob，为合并到这些集成分支而计算的默认合并消息将在其标题中省略&amp;ldquo;进入&amp;lt;分支名称&amp;gt;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c58a4c0205c696c7f9950dee21d8c3e1a3d8c1de" translate="yes" xml:space="preserve">
          <source>By default (or if &lt;code&gt;--no-reapply-cherry-picks&lt;/code&gt; is given), these commits will be automatically dropped. Because this necessitates reading all upstream commits, this can be expensive in repos with a large number of upstream commits that need to be read.</source>
          <target state="translated">默认情况下（或者如果给出 &lt;code&gt;--no-reapply-cherry-picks&lt;/code&gt; ），这些提交将被自动删除。因为这需要读取所有上游提交，所以在回购中，由于需要读取大量上游提交，因此这样做可能会很昂贵。</target>
        </trans-unit>
        <trans-unit id="18ba832b59818b9d406aeb54ba66e145b5697021" translate="yes" xml:space="preserve">
          <source>By default (without --all or --tags) &lt;code&gt;git describe&lt;/code&gt; only shows annotated tags. For more information about creating annotated tags see the -a and -s options to &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;.</source>
          <target state="translated">默认情况下（不带--all或--tags）， &lt;code&gt;git describe&lt;/code&gt; 仅显示带注释的标签。有关创建带注释的标签的更多信息，请参见&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;的-a和-s选项。</target>
        </trans-unit>
        <trans-unit id="2aacef9af72c222fb1b6acf47a0fa851e92d4733" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;git fetch&lt;/code&gt; refuses to update the head which corresponds to the current branch. This flag disables the check. This is purely for the internal use for &lt;code&gt;git pull&lt;/code&gt; to communicate with &lt;code&gt;git fetch&lt;/code&gt;, and unless you are implementing your own Porcelain you are not supposed to use it.</source>
          <target state="translated">默认情况下， &lt;code&gt;git fetch&lt;/code&gt; 拒绝更新与当前分支相对应的head。该标志禁用检查。这纯粹是供 &lt;code&gt;git pull&lt;/code&gt; 与 &lt;code&gt;git fetch&lt;/code&gt; 进行通信的内部使用，除非您实现自己的Porcelain，否则不应使用它。</target>
        </trans-unit>
        <trans-unit id="1d408902dc303f6c00a1b0f596a5c28e377e82f7" translate="yes" xml:space="preserve">
          <source>By default Git will look for your hooks in the &lt;code&gt;$GIT_DIR/hooks&lt;/code&gt; directory. Set this to different path, e.g. &lt;code&gt;/etc/git/hooks&lt;/code&gt;, and Git will try to find your hooks in that directory, e.g. &lt;code&gt;/etc/git/hooks/pre-receive&lt;/code&gt; instead of in &lt;code&gt;$GIT_DIR/hooks/pre-receive&lt;/code&gt;.</source>
          <target state="translated">默认情况下，Git将在 &lt;code&gt;$GIT_DIR/hooks&lt;/code&gt; 目录中寻找您的钩子。将此设置为其他路径，例如 &lt;code&gt;/etc/git/hooks&lt;/code&gt; ，Git将尝试在该目录（例如 &lt;code&gt;/etc/git/hooks/pre-receive&lt;/code&gt; )中找到钩子，而不是在 &lt;code&gt;$GIT_DIR/hooks/pre-receive&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2707cacda66e328227d997bd98a14207b5d80af5" translate="yes" xml:space="preserve">
          <source>By default a &amp;lt;ref&amp;gt; not starting with refs/ is treated as the name of a remote-tracking branch (under refs/remotes/). This behavior can be modified using the --import-local option.</source>
          <target state="translated">默认情况下，不以refs /开头的&amp;lt;ref&amp;gt;被视为远程跟踪分支的名称（在refs / remotes /下）。可以使用--import-local选项修改此行为。</target>
        </trans-unit>
        <trans-unit id="9fda6ea140eac0d5f03c38d0b89c06bf6c01dbaa" translate="yes" xml:space="preserve">
          <source>By default all Git repositories under &lt;code&gt;$projectroot&lt;/code&gt; are visible and available to gitweb. The list of projects is generated by default by scanning the &lt;code&gt;$projectroot&lt;/code&gt; directory for Git repositories (for object databases to be more exact; gitweb is not interested in a working area, and is best suited to showing &quot;bare&quot; repositories).</source>
          <target state="translated">默认情况下， &lt;code&gt;$projectroot&lt;/code&gt; 下的所有Git存储库都是可见的，并可供gitweb使用。默认情况下，通过扫描 &lt;code&gt;$projectroot&lt;/code&gt; 目录中的Git存储库来生成项目列表（对于对象数据库更精确； gitweb对工作区域不感兴趣，最适合显示&amp;ldquo;裸露&amp;rdquo;存储库）。</target>
        </trans-unit>
        <trans-unit id="7d4dbfd64b78e6eb7460def3863c1e38e1d55fa2" translate="yes" xml:space="preserve">
          <source>By default all Git repositories under &lt;code&gt;$projectroot&lt;/code&gt; are visible and available to gitweb. You can however configure how gitweb controls access to repositories.</source>
          <target state="translated">默认情况下， &lt;code&gt;$projectroot&lt;/code&gt; 下的所有Git存储库都是可见的，并可供gitweb使用。但是，您可以配置gitweb如何控制对存储库的访问。</target>
        </trans-unit>
        <trans-unit id="6b749c474f0e8be473f5227adae69d6b82e99699" translate="yes" xml:space="preserve">
          <source>By default entries added by &quot;git add -N&quot; appear as an existing empty file in &quot;git diff&quot; and a new file in &quot;git diff --cached&quot;. This option makes the entry appear as a new file in &quot;git diff&quot; and non-existent in &quot;git diff --cached&quot;. This option could be reverted with &lt;code&gt;--ita-visible-in-index&lt;/code&gt;. Both options are experimental and could be removed in future.</source>
          <target state="translated">默认情况下，由&amp;ldquo; git add -N&amp;rdquo;添加的条目在&amp;ldquo; git diff&amp;rdquo;中显示为现有的空文件，在&amp;ldquo; git diff --cached&amp;rdquo;中显示为新文件。此选项使该条目在&amp;ldquo; git diff&amp;rdquo;中显示为新文件，而在&amp;ldquo; git diff --cached&amp;rdquo;中不存在。可以使用 &lt;code&gt;--ita-visible-in-index&lt;/code&gt; 还原此选项。这两种选择都是试验性的，将来可能会删除。</target>
        </trans-unit>
        <trans-unit id="f92479038911d91ec691ca1995b6f59bbf4d3495" translate="yes" xml:space="preserve">
          <source>By default it uses SQLite databases in the Git directory, named &lt;code&gt;gitcvs.&amp;lt;module_name&amp;gt;.sqlite&lt;/code&gt;. Note that the SQLite backend creates temporary files in the same directory as the database file on write so it might not be enough to grant the users using &lt;code&gt;git-cvsserver&lt;/code&gt; write access to the database file without granting them write access to the directory, too.</source>
          <target state="translated">默认情况下，它使用Git目录中名为 &lt;code&gt;gitcvs.&amp;lt;module_name&amp;gt;.sqlite&lt;/code&gt; SQLite数据库。请注意，SQLite后端在写入时与数据库文件位于同一目录中创建临时文件，因此可能不足以授予使用 &lt;code&gt;git-cvsserver&lt;/code&gt; 的用户对数据库文件的写访问权限，而又不授予他们对该目录的写访问权限。</target>
        </trans-unit>
        <trans-unit id="c6b06e8b566ecf1a19a23c408ec4ad0c91c68502" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;man&lt;/code&gt; program will be used to display the manual page, but the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable may be used to choose other display programs (see below).</source>
          <target state="translated">默认情况下， &lt;code&gt;man&lt;/code&gt; 程序将用于显示手册页，但是 &lt;code&gt;man.viewer&lt;/code&gt; 配置变量可以用于选择其他显示程序（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="2e5b50ac3c7c5c555c2ca84f458ac39569a0ee21" translate="yes" xml:space="preserve">
          <source>By default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the author date by using the same value as the committer date.</source>
          <target state="translated">默认情况下,该命令将邮件中的日期作为提交作者的日期,而将提交的时间作为提交者的日期。这就允许用户使用与提交人日期相同的值来隐瞒作者日期。</target>
        </trans-unit>
        <trans-unit id="eb47d162dbfc8bcd3a02f766bf35ff994d86e7f7" translate="yes" xml:space="preserve">
          <source>By default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the committer date by using the same value as the author date.</source>
          <target state="translated">默认情况下,该命令将邮件中的日期作为提交作者的日期,而将提交的时间作为提交者的日期。这就允许用户使用与作者日期相同的数值来隐瞒提交者的日期。</target>
        </trans-unit>
        <trans-unit id="6aeb14014b871b17a9d4f0da107bb610e5ea0157" translate="yes" xml:space="preserve">
          <source>By default the command shows all refs that match &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;. This option makes it stop after showing that many refs.</source>
          <target state="translated">默认情况下，该命令显示与 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 匹配的所有引用。此选项使它在显示很多参考之后停止。</target>
        </trans-unit>
        <trans-unit id="7d63d3915d070cca4c5d36e324ecb4a7f6a0679f" translate="yes" xml:space="preserve">
          <source>By default the command will try to detect the patch format automatically. This option allows the user to bypass the automatic detection and specify the patch format that the patch(es) should be interpreted as. Valid formats are mbox, mboxrd, stgit, stgit-series and hg.</source>
          <target state="translated">默认情况下,该命令将尝试自动检测补丁格式。此选项允许用户绕过自动检测,并指定应将补丁解释为的补丁格式。有效的格式是 mbox、mboxrd、stgit、stgit-series 和 hg。</target>
        </trans-unit>
        <trans-unit id="ee6799585dabe2a3016ffbe61452694b948c3ff6" translate="yes" xml:space="preserve">
          <source>By default the hooks directory is &lt;code&gt;$GIT_DIR/hooks&lt;/code&gt;, but that can be changed via the &lt;code&gt;core.hooksPath&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">默认情况下，hooks目录为 &lt;code&gt;$GIT_DIR/hooks&lt;/code&gt; ，但是可以通过 &lt;code&gt;core.hooksPath&lt;/code&gt; 配置变量（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）进行更改。</target>
        </trans-unit>
        <trans-unit id="1e420d062677a0d01238cac1bc0b0f93a32eaab8" translate="yes" xml:space="preserve">
          <source>By default the new trailer will appear at the end of all the existing trailers. If there is no existing trailer, the new trailer will appear after the commit message part of the output, and, if there is no line with only spaces at the end of the commit message part, one blank line will be added before the new trailer.</source>
          <target state="translated">默认情况下,新的预告片会出现在所有现有预告片的最后。如果没有现有的预告片,新的预告片将出现在输出的提交消息部分之后,如果提交消息部分的末尾没有只有空格的行,则在新的预告片之前增加一行空白。</target>
        </trans-unit>
        <trans-unit id="64ba0ec6c1bed38e21fc7f4f4a0aef9c8ebe7286" translate="yes" xml:space="preserve">
          <source>By default the server leaves the &lt;code&gt;-k&lt;/code&gt; mode blank for all files, which causes the CVS client to treat them as a text files, subject to end-of-line conversion on some platforms.</source>
          <target state="translated">默认情况下，服务器将所有文件的 &lt;code&gt;-k&lt;/code&gt; 模式保留为空白，这会使CVS客户端将它们视为文本文件，但在某些平台上需要进行行尾转换。</target>
        </trans-unit>
        <trans-unit id="54dcb4758211c9d2e362cc73ee7a92ca62d914ac" translate="yes" xml:space="preserve">
          <source>By default this file controls only which projects are &lt;strong&gt;visible&lt;/strong&gt; on projects list page (note that entries that do not point to correctly recognized Git repositories won&amp;rsquo;t be displayed by gitweb). Even if a project is not visible on projects list page, you can view it nevertheless by hand-crafting a gitweb URL. By setting &lt;code&gt;$strict_export&lt;/code&gt; configuration variable (see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;) to true value you can allow viewing only of repositories also shown on the overview page (i.e. only projects explicitly listed in projects list file will be accessible).</source>
          <target state="translated">默认情况下，此文件仅控制哪些项目在项目列表页面上&lt;strong&gt;可见&lt;/strong&gt;（请注意，gitweb不会显示未指向正确识别的Git存储库的条目）。即使项目在项目列表页面上不可见，您仍然可以通过手工制作gitweb URL来查看它。通过将 &lt;code&gt;$strict_export&lt;/code&gt; 配置变量（请参见&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt;）设置为true值，您可以只查看也在概述页面上显示的存储库（即，仅可访问在项目列表文件中明确列出的项目）。</target>
        </trans-unit>
        <trans-unit id="eff6e029914fd799d6a59537c15d9f46e8d635a6" translate="yes" xml:space="preserve">
          <source>By default when &lt;code&gt;--all&lt;/code&gt; is specified, reflogs from all working trees are processed. This option limits the processing to reflogs from the current working tree only.</source>
          <target state="translated">默认情况下，当指定 &lt;code&gt;--all&lt;/code&gt; 时，将处理所有工作树的引用日志。此选项将处理限制为仅来自当前工作树的重新引用。</target>
        </trans-unit>
        <trans-unit id="898aa5511bdcc79b6cc36a9d8f0c7e7e9ffc1277" translate="yes" xml:space="preserve">
          <source>By default when fetching from a shallow repository, &lt;code&gt;git fetch&lt;/code&gt; refuses refs that require updating .git/shallow. This option updates .git/shallow and accept such refs.</source>
          <target state="translated">默认情况下，当从浅存储库中 &lt;code&gt;git fetch&lt;/code&gt; ，git fetch拒绝需要更新.git / shallow的引用。此选项更新.git / shallow并接受此类引用。</target>
        </trans-unit>
        <trans-unit id="8a946900900b0969e5566670798dfa0b25059b02" translate="yes" xml:space="preserve">
          <source>By default, &quot;updateInstead&quot; will refuse the push if the working tree or the index have any difference from the HEAD, but the &lt;code&gt;push-to-checkout&lt;/code&gt; hook can be used to customize this. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">默认情况下，如果工作树或索引与HEAD有任何不同，&amp;ldquo; updateInstead&amp;rdquo;将拒绝推送，但是可以使用 &lt;code&gt;push-to-checkout&lt;/code&gt; 挂钩自定义此推送。参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccc06ea9e45b9e60a670cf461c22563d24643639" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; creates packs that use delta-base offset. If you need to share your repository with Git older than version 1.4.4, either directly or via a dumb protocol such as http, then you need to set this option to &quot;false&quot; and repack. Access from old Git versions over the native protocol are unaffected by this option.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;创建使用基于增量偏移的包。如果您需要直接或通过诸如http之类的哑协议与早于1.4.4版本的Git共享存储库，则需要将此选项设置为&amp;ldquo; false&amp;rdquo;并重新打包。通过本机协议从旧Git版本进行的访问不受此选项的影响。</target>
        </trans-unit>
        <trans-unit id="207b9ec4a7354c6cbc08217ef08c22e3683c8d13" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; show files which are not currently tracked by Git. Directories which contain only untracked files, are shown with the directory name only. Showing untracked files means that Git needs to lstat() all the files in the whole repository, which might be slow on some systems. So, this variable controls how the commands displays the untracked files. Possible values are:</source>
          <target state="translated">默认情况下，&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;和&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;显示Git当前未跟踪的文件。仅包含未跟踪文件的目录仅显示目录名称。显示未跟踪的文件意味着Git需要lstat（）整个存储库中的所有文件，这在某些系统上可能很慢。因此，此变量控制命令如何显示未跟踪的文件。可能的值为：</target>
        </trans-unit>
        <trans-unit id="0594913527635a38d7d1da1f58cf2049e0d81ae9" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; shows paths relative to the current directory. Setting this variable to &lt;code&gt;false&lt;/code&gt; shows paths relative to the repository root (this was the default for Git prior to v1.5.4).</source>
          <target state="translated">默认情况下，&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;显示相对于当前目录的路径。将此变量设置为 &lt;code&gt;false&lt;/code&gt; 会显示相对于存储库根目录的路径（这是v1.5.4之前的Git的默认设置）。</target>
        </trans-unit>
        <trans-unit id="93044cb17b41f6ff0ab9ae102eca02ce8d5cdb16" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;add&lt;/code&gt; checks out &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, however, &lt;code&gt;--no-checkout&lt;/code&gt; can be used to suppress checkout in order to make customizations, such as configuring sparse-checkout. See &quot;Sparse checkout&quot; in &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;add&lt;/code&gt; 签出 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; ，但是 &lt;code&gt;--no-checkout&lt;/code&gt; 可用于禁止签出以进行自定义，例如配置稀疏签出。参见&lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]中的&lt;/a&gt; &amp;ldquo;稀疏签出&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="d6911782a1bf788b96e52d6283b9603906afd385" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;add&lt;/code&gt; refuses to create a new working tree when &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch name and is already checked out by another working tree, or if &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is already assigned to some working tree but is missing (for instance, if &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; was deleted manually). This option overrides these safeguards. To add a missing but locked working tree path, specify &lt;code&gt;--force&lt;/code&gt; twice.</source>
          <target state="translated">默认情况下，当 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 是分支名称并且已经被另一个工作树检出时，或者如果 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 已经分配给某个工作树但丢失了，例如， &lt;code&gt;add&lt;/code&gt; 拒绝创建新的工作树（例如，如果 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 是手动删除的）。此选项将覆盖这些安全措施。要添加丢失但已锁定的工作树路径，请两次指定 &lt;code&gt;--force&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6808cb2e8497f1a21da404e6487ab0df6e47fd0" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git add&lt;/code&gt; will warn when adding an embedded repository to the index without using &lt;code&gt;git submodule add&lt;/code&gt; to create an entry in &lt;code&gt;.gitmodules&lt;/code&gt;. This option will suppress the warning (e.g., if you are manually performing operations on submodules).</source>
          <target state="translated">默认情况下，当将嵌入式存储库 &lt;code&gt;git submodule add&lt;/code&gt; 到索引而不使用git submodule add在 &lt;code&gt;.gitmodules&lt;/code&gt; 中创建条目时， &lt;code&gt;git add&lt;/code&gt; 将发出警告。此选项将禁止显示警告（例如，如果您正在手动对子模块执行操作）。</target>
        </trans-unit>
        <trans-unit id="9f7a911ab745fcc1ecc2d75cf5b4666d5616a0f2" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git am&lt;/code&gt; will fail if the patch does not apply cleanly. When set to true, this setting tells &lt;code&gt;git am&lt;/code&gt; to fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally (equivalent to giving the &lt;code&gt;--3way&lt;/code&gt; option from the command line). Defaults to &lt;code&gt;false&lt;/code&gt;. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;.</source>
          <target state="translated">默认情况下，如果补丁不能很好地应用， &lt;code&gt;git am&lt;/code&gt; 将会失败。当设置为true，这个设置告诉 &lt;code&gt;git am&lt;/code&gt; 依傍3路合并，如果补丁记录它应该适用于斑点的身份和我们现有的斑点本地（相当于给 &lt;code&gt;--3way&lt;/code&gt; 从选项命令行）。默认为 &lt;code&gt;false&lt;/code&gt; 。参见&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04d5b79eb2c1cc00ec23b84308367755078f2519" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git apply&lt;/code&gt; expects that the patch being applied is a unified diff with at least one line of context. This provides good safety measures, but breaks down when applying a diff generated with &lt;code&gt;--unified=0&lt;/code&gt;. To bypass these checks use &lt;code&gt;--unidiff-zero&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;git apply&lt;/code&gt; 期望所应用的补丁是具有至少一行上下文的统一差异。这提供了良好的安全措施，但是在应用 &lt;code&gt;--unified=0&lt;/code&gt; 生成的diff时会崩溃。要绕过这些检查，请使用 &lt;code&gt;--unidiff-zero&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc5e77409adaefd524775157d3aa209b06e80ef9" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git diff-tree --stdin&lt;/code&gt; does not show differences for merge commits. With this flag, it shows differences to that commit from all of its parents. See also &lt;code&gt;-c&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;git diff-tree --stdin&lt;/code&gt; 不显示合并提交的差异。使用此标志，它显示了其所有父项与该提交的差异。另请参见 &lt;code&gt;-c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44f438a687f3c8843b562164d423119ef0393e39" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git diff-tree --stdin&lt;/code&gt; shows differences, either in machine-readable form (without &lt;code&gt;-p&lt;/code&gt;) or in patch form (with &lt;code&gt;-p&lt;/code&gt;). This output can be suppressed. It is only useful with &lt;code&gt;-v&lt;/code&gt; flag.</source>
          <target state="translated">默认情况下， &lt;code&gt;git diff-tree --stdin&lt;/code&gt; 以机器可读形式（不带 &lt;code&gt;-p&lt;/code&gt; ）或补丁程序形式（带 &lt;code&gt;-p&lt;/code&gt; ）显示差异。该输出可以被抑制。仅与 &lt;code&gt;-v&lt;/code&gt; 标志一起使用。</target>
        </trans-unit>
        <trans-unit id="40ac50c3f37c319af999ce66ed951594dd739e7b" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git log&lt;/code&gt; does not generate any diff output. The options below can be used to show the changes made by each commit.</source>
          <target state="translated">默认情况下， &lt;code&gt;git log&lt;/code&gt; 不会生成任何差异输出。以下选项可用于显示每次提交所做的更改。</target>
        </trans-unit>
        <trans-unit id="41ecfd2369ab83f2851da4837d8f55ae828a688b" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git merge&lt;/code&gt; command refuses to merge histories that do not share a common ancestor. This option can be used to override this safety when merging histories of two projects that started their lives independently. As that is a very rare occasion, no configuration variable to enable this by default exists and will not be added.</source>
          <target state="translated">默认情况下， &lt;code&gt;git merge&lt;/code&gt; 命令拒绝合并不共享共同祖先的历史记录。当合并两个独立开始的项目的历史时，可以使用此选项来覆盖此安全性。因为这是非常罕见的情况，所以默认情况下不存在用于启用此功能的配置变量，因此不会添加。</target>
        </trans-unit>
        <trans-unit id="c206e08a568b5af4b242b43f3b62e41c9c2a00a0" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git status&lt;/code&gt; will automatically refresh the index, updating the cached stat information from the working tree and writing out the result. Writing out the updated index is an optimization that isn&amp;rsquo;t strictly necessary (&lt;code&gt;status&lt;/code&gt; computes the values for itself, but writing them out is just to save subsequent programs from repeating our computation). When &lt;code&gt;status&lt;/code&gt; is run in the background, the lock held during the write may conflict with other simultaneous processes, causing them to fail. Scripts running &lt;code&gt;status&lt;/code&gt; in the background should consider using &lt;code&gt;git --no-optional-locks status&lt;/code&gt; (see &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details).</source>
          <target state="translated">默认情况下， &lt;code&gt;git status&lt;/code&gt; 将自动刷新索引，从工作树中更新缓存的统计信息并写出结果。写出更新的索引不是严格必要的优化（ &lt;code&gt;status&lt;/code&gt; 自行计算值，但是写出它们只是为了节省后续程序免于重复我们的计算）。当 &lt;code&gt;status&lt;/code&gt; 在后台运行时，写期间持有的锁可能会与其他同时进行的进程发生冲突，从而导致它们失败。脚本在后台运行 &lt;code&gt;status&lt;/code&gt; 应考虑使用 &lt;code&gt;git --no-optional-locks status&lt;/code&gt; （有关详细信息，请参见&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0166a80c7cb65bd63925a576fc16b6b5666a6f97" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git tag&lt;/code&gt; in sign-with-default mode (-s) will use your committer identity (of the form &lt;code&gt;Your Name &amp;lt;your@email.address&amp;gt;&lt;/code&gt;) to find a key. If you want to use a different default key, you can specify it in the repository configuration as follows:</source>
          <target state="translated">默认情况下，使用默认签名模式（-s）的 &lt;code&gt;git tag&lt;/code&gt; 将使用您的提交者身份（格式为 &lt;code&gt;Your Name &amp;lt;your@email.address&amp;gt;&lt;/code&gt; ）来查找密钥。如果要使用其他默认密钥，则可以在存储库配置中如下指定它：</target>
        </trans-unit>
        <trans-unit id="ab2e2876fa31ec281a3a2c1b794b7dec91ae3790" translate="yes" xml:space="preserve">
          <source>By default, Git determines the command line arguments to use based on the basename of the configured SSH command (configured using the environment variable &lt;code&gt;GIT_SSH&lt;/code&gt; or &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; or the config setting &lt;code&gt;core.sshCommand&lt;/code&gt;). If the basename is unrecognized, Git will attempt to detect support of OpenSSH options by first invoking the configured SSH command with the &lt;code&gt;-G&lt;/code&gt; (print configuration) option and will subsequently use OpenSSH options (if that is successful) or no options besides the host and remote command (if it fails).</source>
          <target state="translated">默认情况下，Git根据已配置的SSH命令（使用环境变量 &lt;code&gt;GIT_SSH&lt;/code&gt; 或 &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; 或配置设置 &lt;code&gt;core.sshCommand&lt;/code&gt; 进行配置）的基本名称来确定要使用的命令行参数。如果无法识别基本名称，Git将尝试通过首先使用 &lt;code&gt;-G&lt;/code&gt; （打印配置）选项调用已配置的SSH命令来尝试检测对OpenSSH选项的支持，随后将使用OpenSSH选项（如果成功）或除主机和主机之外不使用任何选项。远程命令（如果失败）。</target>
        </trans-unit>
        <trans-unit id="b85b0c2bab173615caaf4bbe66c1c28d30e786cc" translate="yes" xml:space="preserve">
          <source>By default, Git does not consider the &quot;path&quot; component of an http URL to be worth matching via external helpers. This means that a credential stored for &lt;code&gt;https://example.com/foo.git&lt;/code&gt; will also be used for &lt;code&gt;https://example.com/bar.git&lt;/code&gt;. If you do want to distinguish these cases, set this option to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">默认情况下，Git认为HTTP URL的&amp;ldquo;路径&amp;rdquo;组件不值得通过外部帮助器进行匹配。这意味着为 &lt;code&gt;https://example.com/foo.git&lt;/code&gt; 存储的凭据也将用于 &lt;code&gt;https://example.com/bar.git&lt;/code&gt; 。如果确实要区分这些情况，请将此选项设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffe1eaf4d1c9cc64df80a6b16dfbf1fa771b52c9" translate="yes" xml:space="preserve">
          <source>By default, Git does not create an extra merge commit when merging a commit that is a descendant of the current commit. Instead, the tip of the current branch is fast-forwarded. When set to &lt;code&gt;false&lt;/code&gt;, this variable tells Git to create an extra merge commit in such a case (equivalent to giving the &lt;code&gt;--no-ff&lt;/code&gt; option from the command line). When set to &lt;code&gt;only&lt;/code&gt;, only such fast-forward merges are allowed (equivalent to giving the &lt;code&gt;--ff-only&lt;/code&gt; option from the command line).</source>
          <target state="translated">默认情况下，当合并作为当前提交的后代的提交时，Git不会创建额外的合并提交。相反，当前分支的尖端是快进的。当设置为 &lt;code&gt;false&lt;/code&gt; 时，此变量告诉Git在这种情况下创建一个额外的合并提交（相当于从命令行提供 &lt;code&gt;--no-ff&lt;/code&gt; 选项）。设置为 &lt;code&gt;only&lt;/code&gt; 时，仅允许进行此类快速合并（等同于 &lt;code&gt;--ff-only&lt;/code&gt; 提供--ff-only选项）。</target>
        </trans-unit>
        <trans-unit id="32c0486f322ae0e4678fa0824298d7c086e9ee4f" translate="yes" xml:space="preserve">
          <source>By default, Git does not create an extra merge commit when merging a commit that is a descendant of the current commit. Instead, the tip of the current branch is fast-forwarded. When set to &lt;code&gt;false&lt;/code&gt;, this variable tells Git to create an extra merge commit in such a case (equivalent to giving the &lt;code&gt;--no-ff&lt;/code&gt; option from the command line). When set to &lt;code&gt;only&lt;/code&gt;, only such fast-forward merges are allowed (equivalent to giving the &lt;code&gt;--ff-only&lt;/code&gt; option from the command line). This setting overrides &lt;code&gt;merge.ff&lt;/code&gt; when pulling.</source>
          <target state="translated">默认情况下，当合并作为当前提交的后代的提交时，Git不会创建额外的合并提交。相反，当前分支的尖端是快进的。当设置为 &lt;code&gt;false&lt;/code&gt; 时，此变量告诉Git在这种情况下创建一个额外的合并提交（相当于从命令行提供 &lt;code&gt;--no-ff&lt;/code&gt; 选项）。设置为 &lt;code&gt;only&lt;/code&gt; 时，仅允许这种快速合并（相当于 &lt;code&gt;--ff-only&lt;/code&gt; 提供--ff-only选项）。拉动时，此设置将覆盖 &lt;code&gt;merge.ff&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9c5fc6eaa57215e9d40c1ce676f37f95dcd7eef" translate="yes" xml:space="preserve">
          <source>By default, Git expects files to be stored with Unix line endings. As such, the carriage return (&lt;code&gt;^M&lt;/code&gt;) that is part of a Windows line ending is shown because it is considered to be trailing whitespace. Git defaults to showing trailing whitespace only on new lines, not existing ones.</source>
          <target state="translated">默认情况下，Git期望文件以Unix行结尾存储。这样，将显示作为Windows行尾的一部分的回车符（ &lt;code&gt;^M&lt;/code&gt; ），因为它被认为是尾随空格。Git默认只在新行上显示尾随空格，而不在现有行上显示尾随空格。</target>
        </trans-unit>
        <trans-unit id="e39ec591fb076f73ed5744e6cef724be12b06bb7" translate="yes" xml:space="preserve">
          <source>By default, Git uses the same style as the one used by the &quot;merge&quot; program from the RCS suite to present such a conflicted hunk, like this:</source>
          <target state="translated">默认情况下,Git使用与RCS套件中的 &quot;merge &quot;程序相同的风格来呈现这样一个冲突的hunk,比如这样。</target>
        </trans-unit>
        <trans-unit id="632bd7b7934c758c995d70fcf0643a53a17ef93c" translate="yes" xml:space="preserve">
          <source>By default, Git will report, to the server, commits reachable from all local refs to find common commits in an attempt to reduce the size of the to-be-received packfile. If specified, Git will only report commits reachable from the given tips. This is useful to speed up fetches when the user knows which local ref is likely to have commits in common with the upstream ref being fetched.</source>
          <target state="translated">默认情况下,Git 会向服务器报告从所有本地 refs 中可以到达的提交,以找到共同的提交,从而减少将要接收的 packfile 的大小。如果指定了这个选项,Git 将只报告从给定的提示中可以到达的提交。当用户知道哪个本地 ref 可能与上游 ref 有共同的提交时,这对加快获取速度很有用。</target>
        </trans-unit>
        <trans-unit id="ec00d75621e8cccd0e732ba6afc6d14548cb8a4e" translate="yes" xml:space="preserve">
          <source>By default, Thunderbird will both wrap emails as well as flag them as being &lt;code&gt;format=flowed&lt;/code&gt;, both of which will make the resulting email unusable by Git.</source>
          <target state="translated">默认情况下，Thunderbird会同时包装电子邮件并将其标记为 &lt;code&gt;format=flowed&lt;/code&gt; ，这两者都会使生成的电子邮件无法被Git使用。</target>
        </trans-unit>
        <trans-unit id="cb931511b378f47ed0453a8a3e156978cca15ca4" translate="yes" xml:space="preserve">
          <source>By default, a &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;token&amp;gt;:&amp;lt;value&amp;gt;&lt;/code&gt; argument given using &lt;code&gt;--trailer&lt;/code&gt; will be appended after the existing trailers only if the last trailer has a different (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair (or if there is no existing trailer). The &amp;lt;token&amp;gt; and &amp;lt;value&amp;gt; parts will be trimmed to remove starting and trailing whitespace, and the resulting trimmed &amp;lt;token&amp;gt; and &amp;lt;value&amp;gt; will appear in the message like this:</source>
          <target state="translated">默认情况下，仅当最后一个预告片具有不同的对（&amp;lt;token&amp;gt;，&amp;lt;value&amp;gt;）对时，使用 &lt;code&gt;--trailer&lt;/code&gt; 给出的 &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;token&amp;gt;:&amp;lt;value&amp;gt;&lt;/code&gt; 参数将附加在现有预告片之后。 （或者如果没有现有的预告片）。将修剪&amp;lt;token&amp;gt;和&amp;lt;value&amp;gt;部分，以删除开始和结尾的空格，并且结果修剪后的&amp;lt;token&amp;gt;和&amp;lt;value&amp;gt;将出现在消息中，如下所示：</target>
        </trans-unit>
        <trans-unit id="434e3c7441379e0ab27bf268d6dee72f73412814" translate="yes" xml:space="preserve">
          <source>By default, a patch that affects outside the working area (either a Git controlled working tree, or the current working directory when &quot;git apply&quot; is used as a replacement of GNU patch) is rejected as a mistake (or a mischief).</source>
          <target state="translated">默认情况下,影响到工作区域之外的补丁(无论是 Git 控制的工作树,还是使用 &quot;git apply &quot;替代 GNU 补丁时的当前工作目录)都会被视为错误(或恶作剧)而被拒绝。</target>
        </trans-unit>
        <trans-unit id="ea0000563105721871c07339b879614c007bc152" translate="yes" xml:space="preserve">
          <source>By default, a rebase will simply drop merge commits from the todo list, and put the rebased commits into a single, linear branch. With &lt;code&gt;--rebase-merges&lt;/code&gt;, the rebase will instead try to preserve the branching structure within the commits that are to be rebased, by recreating the merge commits. Any resolved merge conflicts or manual amendments in these merge commits will have to be resolved/re-applied manually.</source>
          <target state="translated">默认情况下，rebase会简单地将合并提交从todo列表中删除，并将重新提交的提交放入单个线性分支中。使用 &lt;code&gt;--rebase-merges&lt;/code&gt; ，rebase将通过重新创建合并提交来尝试在要重新提交的提交中保留分支结构。这些合并提交中的任何已解决的合并冲突或手动修订都必须手动解决/重新应用。</target>
        </trans-unit>
        <trans-unit id="92f108d472fe60a4c0a9d93474bd0154c5c0a9e2" translate="yes" xml:space="preserve">
          <source>By default, all working trees will be examined by the following options when there are more than one (see &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;): &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--reflog&lt;/code&gt; and &lt;code&gt;--indexed-objects&lt;/code&gt;. This option forces them to examine the current working tree only.</source>
          <target state="translated">默认情况下，所有工作的树木将被下面的选项时，有检查不止一个（见&lt;a href=&quot;git-worktree&quot;&gt;的git-worktree [1] &lt;/a&gt;）： &lt;code&gt;--all&lt;/code&gt; ， &lt;code&gt;--reflog&lt;/code&gt; 和 &lt;code&gt;--indexed-objects&lt;/code&gt; 。此选项强制他们仅检查当前的工作树。</target>
        </trans-unit>
        <trans-unit id="1feea061cb833e84202a29cce6b0929662b79ff4" translate="yes" xml:space="preserve">
          <source>By default, any branch can be used as the source for a &lt;code&gt;git p4 submit&lt;/code&gt; operation. This configuration variable, if set, permits only the named branches to be used as submit sources. Branch names must be the short names (no &quot;refs/heads/&quot;), and should be separated by commas (&quot;,&quot;), with no spaces.</source>
          <target state="translated">默认情况下，任何分支都可以用作 &lt;code&gt;git p4 submit&lt;/code&gt; 操作的源。如果设置了此配置变量，则仅允许将命名的分支用作提交源。分支名称必须是短名称（没有&amp;ldquo; refs / heads /&amp;rdquo;），并且应以逗号（&amp;ldquo;，&amp;rdquo;）分隔，且不能有空格。</target>
        </trans-unit>
        <trans-unit id="cb82df8bc2b9bbd18ae6db77878aee5f1360ef3d" translate="yes" xml:space="preserve">
          <source>By default, any of the given pathnames which match an ignore pattern will be output, one per line. If no pattern matches a given path, nothing will be output for that path; this means that path will not be ignored.</source>
          <target state="translated">默认情况下,任何符合忽略模式的路径名都会被输出,每行一个。如果没有与给定路径匹配的模式,则该路径将不会输出任何内容;这意味着该路径不会被忽略。</target>
        </trans-unit>
        <trans-unit id="9840f412411908e4167e9b89fe91af90f41421dd" translate="yes" xml:space="preserve">
          <source>By default, any tag that points into the histories being fetched is also fetched; the effect is to fetch tags that point at branches that you are interested in. This default behavior can be changed by using the --tags or --no-tags options or by configuring remote.&amp;lt;name&amp;gt;.tagOpt. By using a refspec that fetches tags explicitly, you can fetch tags that do not point into branches you are interested in as well.</source>
          <target state="translated">默认情况下，任何指向要获取的历史记录的标记也会被获取；效果是获取指向您感兴趣的分支的标记。可以使用--tags或--no-tags选项或配置remote。&amp;lt;name&amp;gt; .tagOpt来更改此默认行为。通过使用显式获取标签的refspec，您还可以获取不指向您感兴趣的分支的标签。</target>
        </trans-unit>
        <trans-unit id="859edf72ede027900910837f2758e52dd7b73b08" translate="yes" xml:space="preserve">
          <source>By default, cherry-picking a commit with an empty message will fail. This option overrides that behavior, allowing commits with empty messages to be cherry picked.</source>
          <target state="translated">默认情况下,挑空消息的提交会失败。这个选项可以重写这个行为,允许带空消息的提交被摘取。</target>
        </trans-unit>
        <trans-unit id="c2ea9611dc2821c1e170c93c6a453dad2dd69c2d" translate="yes" xml:space="preserve">
          <source>By default, cherry-picking an empty commit will fail, indicating that an explicit invocation of &lt;code&gt;git commit
--allow-empty&lt;/code&gt; is required. This option overrides that behavior, allowing empty commits to be preserved automatically in a cherry-pick. Note that when &quot;--ff&quot; is in effect, empty commits that meet the &quot;fast-forward&quot; requirement will be kept even without this option. Note also, that use of this option only keeps commits that were initially empty (i.e. the commit recorded the same tree as its parent). Commits which are made empty due to a previous commit are dropped. To force the inclusion of those commits use &lt;code&gt;--keep-redundant-commits&lt;/code&gt;.</source>
          <target state="translated">默认情况下，挑选空提交失败，这表明需要显式调用 &lt;code&gt;git commit --allow-empty&lt;/code&gt; 。此选项将覆盖该行为，从而允许空提交自动保留在&amp;ldquo;自动选择&amp;rdquo;中。请注意，当&amp;ldquo; --ff&amp;rdquo;生效时，即使没有此选项，也会保留符合&amp;ldquo;快进&amp;rdquo;要求的空提交。还要注意，使用此选项只会保留最初为空的提交（即，提交记录的树与其父树相同）。由于先前的提交而变为空的提交将被丢弃。要强制包含这些提交，请使用 &lt;code&gt;--keep-redundant-commits&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99709c182dff4928785c30a9c26112a6276f34d2" translate="yes" xml:space="preserve">
          <source>By default, each output file is numbered sequentially from 1, and uses the first line of the commit message (massaged for pathname safety) as the filename. With the &lt;code&gt;--numbered-files&lt;/code&gt; option, the output file names will only be numbers, without the first line of the commit appended. The names of the output files are printed to standard output, unless the &lt;code&gt;--stdout&lt;/code&gt; option is specified.</source>
          <target state="translated">默认情况下，每个输出文件从1开始按顺序编号，并使用提交消息的第一行（为保证路径名的安全性而使用）作为文件名。使用 &lt;code&gt;--numbered-files&lt;/code&gt; 选项，输出文件名将仅是数字，而未附加提交的第一行。除非指定了 &lt;code&gt;--stdout&lt;/code&gt; 选项，否则输出文件的名称将打印到标准输出中。</target>
        </trans-unit>
        <trans-unit id="3d27fcf4c77eeb925cb728d43582e85b263ea253" translate="yes" xml:space="preserve">
          <source>By default, files recorded in the index but not checked out are reported as deleted. This flag makes &lt;code&gt;git diff-index&lt;/code&gt; say that all non-checked-out files are up to date.</source>
          <target state="translated">默认情况下，记录在索引中但未检出的文件被报告为已删除。这个标志使 &lt;code&gt;git diff-index&lt;/code&gt; 表示所有未检出的文件都是最新的。</target>
        </trans-unit>
        <trans-unit id="96d263210b58deac758523391a09d64f715778b1" translate="yes" xml:space="preserve">
          <source>By default, git checks if a branch is force-updated during fetch. Pass --no-show-forced-updates or set fetch.showForcedUpdates to false to skip this check for performance reasons. If used during &lt;code&gt;git-pull&lt;/code&gt; the --ff-only option will still check for forced updates before attempting a fast-forward update. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">默认情况下，git检查在提取过程中是否强制更新了分支。传递--no-show-forced-updates或将fetch.showForcedUpdates设置为false可出于性能原因跳过此检查。如果在 &lt;code&gt;git-pull&lt;/code&gt; 期间使用，则&amp;ndash;ff-only选项仍将在尝试快速转发更新之前检查强制更新。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bcd22a0eaa98a42d194f3bb1ae51915a7ffdb1a6" translate="yes" xml:space="preserve">
          <source>By default, git checks if a branch is force-updated during fetch. This can be disabled through fetch.showForcedUpdates, but the --show-forced-updates option guarantees this check occurs. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">默认情况下，git检查在提取过程中是否强制更新了分支。可以通过fetch.showForcedUpdates禁用此功能，但是--show-forced-updates选项可确保进行此检查。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd1e0c76aa334eb061df6d08bfae08afe6a12c47" translate="yes" xml:space="preserve">
          <source>By default, git-receive-pack will advertise the atomic push capability to its clients. If you don&amp;rsquo;t want to advertise this capability, set this variable to false.</source>
          <target state="translated">默认情况下，git-receive-pack将向其客户端通告原子推送功能。如果您不想宣传此功能，请将此变量设置为false。</target>
        </trans-unit>
        <trans-unit id="1a975a4b5c6ec62cbf8bcd46f9c353ac381aea16" translate="yes" xml:space="preserve">
          <source>By default, git-receive-pack will run &quot;git-gc --auto&quot; after receiving data from git-push and updating refs. You can stop it by setting this variable to false.</source>
          <target state="translated">默认情况下,git-receive-pack 会在接收到 git-push 的数据并更新 refs 后运行 &quot;git-gc --auto&quot;。你可以把这个变量设置为false来停止它。</target>
        </trans-unit>
        <trans-unit id="5b0b6ce94f774ad8adadd56d738f2417c24f77c0" translate="yes" xml:space="preserve">
          <source>By default, if &lt;code&gt;--staged&lt;/code&gt; is given, the contents are restored from &lt;code&gt;HEAD&lt;/code&gt;, otherwise from the index. Use &lt;code&gt;--source&lt;/code&gt; to restore from a different commit.</source>
          <target state="translated">默认情况下，如果给定 &lt;code&gt;--staged&lt;/code&gt; ，则从 &lt;code&gt;HEAD&lt;/code&gt; 还原内容，否则从索引还原。使用 &lt;code&gt;--source&lt;/code&gt; 从其他提交还原。</target>
        </trans-unit>
        <trans-unit id="a70c8c423de4cae10f96eacc568cc485314e2875" translate="yes" xml:space="preserve">
          <source>By default, notes are saved to and read from &lt;code&gt;refs/notes/commits&lt;/code&gt;, but this default can be overridden. See the OPTIONS, CONFIGURATION, and ENVIRONMENT sections below. If this ref does not exist, it will be quietly created when it is first needed to store a note.</source>
          <target state="translated">默认情况下，便笺将保存到 &lt;code&gt;refs/notes/commits&lt;/code&gt; 并从中读取，但是此默认值可以被覆盖。请参阅下面的&amp;ldquo;选项&amp;rdquo;，&amp;ldquo;配置&amp;rdquo;和&amp;ldquo;环境&amp;rdquo;部分。如果此引用不存在，则在第一次需要存储注释时将自动创建该引用。</target>
        </trans-unit>
        <trans-unit id="7db5a2446c4341c306923f095d2e7f8486b88ca6" translate="yes" xml:space="preserve">
          <source>By default, only &lt;code&gt;upload-pack&lt;/code&gt; service is enabled, which serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients, which are invoked from &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt;, and &lt;code&gt;git clone&lt;/code&gt;.</source>
          <target state="translated">默认情况下，仅启用 &lt;code&gt;upload-pack&lt;/code&gt; 服务，该服务为 &lt;code&gt;git fetch-pack&lt;/code&gt; 和 &lt;code&gt;git ls-remote&lt;/code&gt; 客户端提供服务，这些客户端是从 &lt;code&gt;git fetch&lt;/code&gt; ， &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git clone&lt;/code&gt; 调用的。</target>
        </trans-unit>
        <trans-unit id="d1846d634d738a19049ad205d84e7a2d6c7d9843" translate="yes" xml:space="preserve">
          <source>By default, only tags on fetched branches are imported (see &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">默认情况下，仅导入获取的分支上的标签（请参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="330929bfac5b0158d7117057a21f395479839e07" translate="yes" xml:space="preserve">
          <source>By default, only the &lt;code&gt;upload-pack&lt;/code&gt; service is enabled, which serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients, which are invoked from &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt;, and &lt;code&gt;git clone&lt;/code&gt;. If the client is authenticated, the &lt;code&gt;receive-pack&lt;/code&gt; service is enabled, which serves &lt;code&gt;git send-pack&lt;/code&gt; clients, which is invoked from &lt;code&gt;git push&lt;/code&gt;.</source>
          <target state="translated">默认情况下，仅启用 &lt;code&gt;upload-pack&lt;/code&gt; 服务，该服务为 &lt;code&gt;git fetch-pack&lt;/code&gt; 和 &lt;code&gt;git ls-remote&lt;/code&gt; 客户端提供服务，这些客户端是从 &lt;code&gt;git fetch&lt;/code&gt; ， &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git clone&lt;/code&gt; 调用的。如果客户端通过了身份验证，则会启用 &lt;code&gt;receive-pack&lt;/code&gt; 服务，该服务为 &lt;code&gt;git send-pack&lt;/code&gt; 客户端提供服务，该客户端从 &lt;code&gt;git push&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="0265af70a38c5e98df8aec91888bb8ebd90e0b3b" translate="yes" xml:space="preserve">
          <source>By default, or when &lt;code&gt;no-rebase-cousins&lt;/code&gt; was specified, commits which do not have &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt; as direct ancestor will keep their original branch point, i.e. commits that would be excluded by &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;'s &lt;code&gt;--ancestry-path&lt;/code&gt; option will keep their original ancestry by default. If the &lt;code&gt;rebase-cousins&lt;/code&gt; mode is turned on, such commits are instead rebased onto &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt; (or &lt;code&gt;&amp;lt;onto&amp;gt;&lt;/code&gt;, if specified).</source>
          <target state="translated">默认情况下，或者当指定 &lt;code&gt;no-rebase-cousins&lt;/code&gt; 时，没有 &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt; 作为直接祖先的提交将保留其原始分支点，即&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;的 &lt;code&gt;--ancestry-path&lt;/code&gt; 排除的提交。 path选项将默认保留其原始血统。如果打开了 &lt;code&gt;rebase-cousins&lt;/code&gt; 模式，则这些提交将改基于 &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt; （或 &lt;code&gt;&amp;lt;onto&amp;gt;&lt;/code&gt; ，如果指定）。</target>
        </trans-unit>
        <trans-unit id="37d300d0f44033465a93b6aee94bab48b54dbf53" translate="yes" xml:space="preserve">
          <source>By default, p4 branches are stored in &lt;code&gt;refs/remotes/p4/&lt;/code&gt;, where they will be treated as remote-tracking branches by &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; and other commands. This option instead puts p4 branches in &lt;code&gt;refs/heads/p4/&lt;/code&gt;. Note that future sync operations must specify &lt;code&gt;--import-local&lt;/code&gt; as well so that they can find the p4 branches in refs/heads.</source>
          <target state="translated">默认情况下，p4分支存储在 &lt;code&gt;refs/remotes/p4/&lt;/code&gt; ，在这里它们将被&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;和其他命令视为远程跟踪分支。相反，此选项将p4分支放在 &lt;code&gt;refs/heads/p4/&lt;/code&gt; 。请注意，将来的同步操作也必须指定 &lt;code&gt;--import-local&lt;/code&gt; ，以便它们可以在引用/ heads中找到p4分支。</target>
        </trans-unit>
        <trans-unit id="52600650ec12082f5a2bcdafd01bd7a6322055cf" translate="yes" xml:space="preserve">
          <source>By default, rebasing commits with an empty message will fail. This option overrides that behavior, allowing commits with empty messages to be rebased.</source>
          <target state="translated">默认情况下,对空消息的提交进行重定基会失败。这个选项可以覆盖这个行为,允许对空消息的提交进行重归。</target>
        </trans-unit>
        <trans-unit id="aab8804804be7a1049e7aa89e2807caa0461793c" translate="yes" xml:space="preserve">
          <source>By default, running a command such as &lt;code&gt;git fast-export
master~5..master&lt;/code&gt; will not include the commit master~5 and will make master~4 no longer have master~5 as a parent (though both the old master~4 and new master~4 will have all the same files). Use --reference-excluded-parents to instead have the stream refer to commits in the excluded range of history by their sha1sum. Note that the resulting stream can only be used by a repository which already contains the necessary parent commits.</source>
          <target state="translated">默认情况下，运行诸如 &lt;code&gt;git fast-export master~5..master&lt;/code&gt; 将不包含commit master〜5，并且将使master〜4不再具有master〜5作为父级（尽管旧的master〜4和新的master〜4将具有相同的文件）。使用--reference-excluded-parents可以使流按其sha1sum引用历史记录排除范围内的提交。请注意，结果流只能由已经包含必要的父提交的存储库使用。</target>
        </trans-unit>
        <trans-unit id="d83beffd98b552e4707fcc4f203041336c446345" translate="yes" xml:space="preserve">
          <source>By default, shows the tags, heads, and remote refs.</source>
          <target state="translated">默认情况下,显示标签、头和远程参考。</target>
        </trans-unit>
        <trans-unit id="9534d3a85e2055ad7b75dcf81f0ec911d150730a" translate="yes" xml:space="preserve">
          <source>By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e. &lt;code&gt;medium&lt;/code&gt;, which is the default, &lt;code&gt;full&lt;/code&gt;, and &lt;code&gt;fuller&lt;/code&gt;).</source>
          <target state="translated">默认情况下，选项卡以漂亮的格式扩展，该格式将日志消息缩进4个空格（例如， &lt;code&gt;medium&lt;/code&gt; 是默认值， &lt;code&gt;full&lt;/code&gt; 和 &lt;code&gt;fuller&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f8c576d24c20a06a3fa3293a553efd1880bf67bd" translate="yes" xml:space="preserve">
          <source>By default, tags that point at objects that are downloaded from the remote repository are fetched and stored locally. This option disables this automatic tag following. The default behavior for a remote may be specified with the remote.&amp;lt;name&amp;gt;.tagOpt setting. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">默认情况下，指向并指向从远程存储库下载的对象的标记，并将其存储在本地。此选项禁用此自动标记跟随。可以使用remote。&amp;lt;name&amp;gt; .tagOpt设置指定远程的默认行为。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ffdb9a1efc1700312a38f928a2009acf370d9974" translate="yes" xml:space="preserve">
          <source>By default, the branches and their commits are shown in reverse chronological order. This option makes them appear in topological order (i.e., descendant commits are shown before their parents).</source>
          <target state="translated">默认情况下,分支和它们的提交是按时间倒序显示的。该选项使它们按拓扑顺序显示(即子代提交在父代提交之前显示)。</target>
        </trans-unit>
        <trans-unit id="7d6c7baaf0bf9e427c6cfd338efdec2fba7e7759" translate="yes" xml:space="preserve">
          <source>By default, the command outputs warning messages but applies the patch. When &lt;code&gt;git-apply&lt;/code&gt; is used for statistics and not applying a patch, it defaults to &lt;code&gt;nowarn&lt;/code&gt;.</source>
          <target state="translated">默认情况下，该命令输出警告消息，但会应用补丁程序。当 &lt;code&gt;git-apply&lt;/code&gt; 用于统计而不应用补丁时，默认为 &lt;code&gt;nowarn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a611e350871da16559e274274576dfaf4df893f3" translate="yes" xml:space="preserve">
          <source>By default, the command passes &lt;code&gt;--delta-base-offset&lt;/code&gt; option to &lt;code&gt;git pack-objects&lt;/code&gt;; this typically results in slightly smaller packs, but the generated packs are incompatible with versions of Git older than version 1.4.4. If you need to share your repository with such ancient Git versions, either directly or via the dumb http protocol, then you need to set the configuration variable &lt;code&gt;repack.UseDeltaBaseOffset&lt;/code&gt; to &quot;false&quot; and repack. Access from old Git versions over the native protocol is unaffected by this option as the conversion is performed on the fly as needed in that case.</source>
          <target state="translated">默认情况下，该命令将 &lt;code&gt;--delta-base-offset&lt;/code&gt; 选项传递给 &lt;code&gt;git pack-objects&lt;/code&gt; ；这通常会导致程序包略小，但是生成的程序包与早于1.4.4版本的Git版本不兼容。如果您需要直接或通过哑http协议与此类古老的Git版本共享存储库，则需要将配置变量 &lt;code&gt;repack.UseDeltaBaseOffset&lt;/code&gt; 设置为&amp;ldquo; false&amp;rdquo;并重新打包。通过本地协议从旧Git版本进行访问不受此选项的影响，因为在这种情况下，转换是根据需要动态进行的。</target>
        </trans-unit>
        <trans-unit id="4f861a2e54471285f5e27b71719f8d0cdb51509e" translate="yes" xml:space="preserve">
          <source>By default, the command shows the filename for each match. &lt;code&gt;-h&lt;/code&gt; option is used to suppress this output. &lt;code&gt;-H&lt;/code&gt; is there for completeness and does not do anything except it overrides &lt;code&gt;-h&lt;/code&gt; given earlier on the command line.</source>
          <target state="translated">默认情况下，该命令显示每个匹配项的文件名。 &lt;code&gt;-h&lt;/code&gt; 选项用于禁止输出。 &lt;code&gt;-H&lt;/code&gt; 用于完整性，除了覆盖命令行前面给出的 &lt;code&gt;-h&lt;/code&gt; 外，不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="13a9b6e24e13c9eb4f96f597a6a5cd1c71b0690a" translate="yes" xml:space="preserve">
          <source>By default, the commands above can be executed only with the &lt;code&gt;-c&lt;/code&gt; option; the shell is not interactive.</source>
          <target state="translated">缺省情况下，以上命令只能通过 &lt;code&gt;-c&lt;/code&gt; 选项执行。外壳不是交互式的。</target>
        </trans-unit>
        <trans-unit id="96284dfd9f407661b68729a78fcd24af10b360fa" translate="yes" xml:space="preserve">
          <source>By default, the commits are shown in reverse chronological order.</source>
          <target state="translated">默认情况下,提交的内容会按时间倒序显示。</target>
        </trans-unit>
        <trans-unit id="41e61e3f14f2f076835cbd248b96763ec755aaf1" translate="yes" xml:space="preserve">
          <source>By default, the configuration flag &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; is enabled in shared repositories, so that you cannot force a non fast-forwarding push into it.</source>
          <target state="translated">默认情况下，共享存储库中启用了配置标志 &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; ，因此您不能强制将非快速转发推送到其中。</target>
        </trans-unit>
        <trans-unit id="96f5a0af42c4430da235fb8eb151d52244069b6f" translate="yes" xml:space="preserve">
          <source>By default, the notes shown are from the notes refs listed in the &lt;code&gt;core.notesRef&lt;/code&gt; and &lt;code&gt;notes.displayRef&lt;/code&gt; variables (or corresponding environment overrides). See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for more details.</source>
          <target state="translated">默认情况下，显示的注释来自 &lt;code&gt;core.notesRef&lt;/code&gt; 和 &lt;code&gt;notes.displayRef&lt;/code&gt; 变量（或相应的环境替代）中列出的注释refs 。有关更多详细信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="720f82840fb154598c30c373c9317d22846223a4" translate="yes" xml:space="preserve">
          <source>By default, the output omits merges that are reachable from only one tip being shown. This option makes them visible.</source>
          <target state="translated">默认情况下,输出会省略那些只能从显示的一个提示中到达的合并。此选项使它们可见。</target>
        </trans-unit>
        <trans-unit id="5af8b38407e84c0cf68e927bffe60812fcb3c4e9" translate="yes" xml:space="preserve">
          <source>By default, the repository &quot;config&quot; file is shared across all working trees. If the config variables &lt;code&gt;core.bare&lt;/code&gt; or &lt;code&gt;core.worktree&lt;/code&gt; are already present in the config file, they will be applied to the main working trees only.</source>
          <target state="translated">默认情况下，存储库&amp;ldquo; config&amp;rdquo;文件在所有工作树之间共享。如果配置文件中已经存在配置变量 &lt;code&gt;core.bare&lt;/code&gt; 或 &lt;code&gt;core.worktree&lt;/code&gt; ，它们将仅应用于主要工作树。</target>
        </trans-unit>
        <trans-unit id="1d794a43930ea258acdc77025c8009e643f727f7" translate="yes" xml:space="preserve">
          <source>By default, the repository &lt;code&gt;config&lt;/code&gt; file is shared across all working trees. If the config variables &lt;code&gt;core.bare&lt;/code&gt; or &lt;code&gt;core.worktree&lt;/code&gt; are already present in the config file, they will be applied to the main working trees only.</source>
          <target state="translated">默认情况下，存储库 &lt;code&gt;config&lt;/code&gt; 文件在所有工作树之间共享。如果配置文件中已经存在配置变量 &lt;code&gt;core.bare&lt;/code&gt; 或 &lt;code&gt;core.worktree&lt;/code&gt; ，它们将仅应用于主要工作树。</target>
        </trans-unit>
        <trans-unit id="973434bf7e817a557d276186c33c139503bc7733" translate="yes" xml:space="preserve">
          <source>By default, the restore sources for working tree and the index are the index and &lt;code&gt;HEAD&lt;/code&gt; respectively. &lt;code&gt;--source&lt;/code&gt; could be used to specify a commit as the restore source.</source>
          <target state="translated">默认情况下，工作树和索引的还原源分别是索引和 &lt;code&gt;HEAD&lt;/code&gt; 。 &lt;code&gt;--source&lt;/code&gt; 可用于将提交指定为还原源。</target>
        </trans-unit>
        <trans-unit id="6198a2f3a4209e82ce868cd683f2d31abc69a314" translate="yes" xml:space="preserve">
          <source>By default, the sparse-checkout file uses the same syntax as &lt;code&gt;.gitignore&lt;/code&gt; files.</source>
          <target state="translated">默认情况下，稀疏签出文件使用与 &lt;code&gt;.gitignore&lt;/code&gt; 文件相同的语法。</target>
        </trans-unit>
        <trans-unit id="22a25d0b8a2e5ce87fbc59e939918c48f09b2958" translate="yes" xml:space="preserve">
          <source>By default, the subject of a single patch is &quot;[PATCH] &quot; followed by the concatenation of lines from the commit message up to the first blank line (see the DISCUSSION section of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;).</source>
          <target state="translated">默认情况下，单个补丁的主题是&amp;ldquo; [PATCH]&amp;rdquo;，然后是从提交消息到第一行空白的行连接（请参阅&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;的DISCUSSION部分）。</target>
        </trans-unit>
        <trans-unit id="9704a5c766445678507f7af7f587edd379d84cf0" translate="yes" xml:space="preserve">
          <source>By default, this uses the same built-in 3-way merge driver as is the case when the &lt;code&gt;merge&lt;/code&gt; attribute is set. However, the &lt;code&gt;merge.default&lt;/code&gt; configuration variable can name different merge driver to be used with paths for which the &lt;code&gt;merge&lt;/code&gt; attribute is unspecified.</source>
          <target state="translated">默认情况下，它使用与设置 &lt;code&gt;merge&lt;/code&gt; 属性时相同的内置3向合并驱动程序。但是， &lt;code&gt;merge.default&lt;/code&gt; 配置变量可以命名要用于未指定 &lt;code&gt;merge&lt;/code&gt; 属性的路径的其他合并驱动程序。</target>
        </trans-unit>
        <trans-unit id="fb719865937ac64c446567c5ed40eaa328116bc6" translate="yes" xml:space="preserve">
          <source>By default, this will return your tree to the commit that was checked out before &lt;code&gt;git bisect start&lt;/code&gt;. (A new &lt;code&gt;git bisect start&lt;/code&gt; will also do that, as it cleans up the old bisection state.)</source>
          <target state="translated">默认情况下，这会将您的树返回到 &lt;code&gt;git bisect start&lt;/code&gt; 之前签出的提交。（新的 &lt;code&gt;git bisect start&lt;/code&gt; 也可以做到这一点，因为它可以清理旧的二等分状态。）</target>
        </trans-unit>
        <trans-unit id="d0131180d6acb72b151d5763656b5ee5ec67d9f6" translate="yes" xml:space="preserve">
          <source>By default, tracked files are not shown at all since they are not subject to exclude rules; but see &amp;lsquo;--no-index&amp;rsquo;.</source>
          <target state="translated">默认情况下，跟踪文件完全不显示，因为它们不受排除规则的约束。但请参阅&amp;ldquo; --no-index&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ee4ea00c852fc490eaeacd22a0f5f3632d72c3c5" translate="yes" xml:space="preserve">
          <source>By default, when Git does a merge, it uses a strategy called the recursive strategy, which does a fancy three-way merge. In such a case, when Git performs the merge, it considers exactly three points: the two heads and a third point, called the &lt;code&gt;merge base&lt;/code&gt;, which is usually the common ancestor of those commits. Git does not consider the history or the individual commits that have happened on those branches at all.</source>
          <target state="translated">默认情况下，当Git进行合并时，它会使用一种称为递归策略的策略，该策略会执行精美的三向合并。在这种情况下，当Git执行合并时，它将精确地考虑三个点：两个头和一个称为 &lt;code&gt;merge base&lt;/code&gt; 的第三点，通常是那些提交的共同祖先。Git根本不考虑这些分支上的历史记录或单个提交。</target>
        </trans-unit>
        <trans-unit id="055c65bfcac14882dd3e00e849a98c92a82c1b80" translate="yes" xml:space="preserve">
          <source>By default, when a file &lt;code&gt;path&lt;/code&gt; exists in the index, &lt;code&gt;git update-index&lt;/code&gt; refuses an attempt to add &lt;code&gt;path/file&lt;/code&gt;. Similarly if a file &lt;code&gt;path/file&lt;/code&gt; exists, a file &lt;code&gt;path&lt;/code&gt; cannot be added. With --replace flag, existing entries that conflict with the entry being added are automatically removed with warning messages.</source>
          <target state="translated">默认情况下，当索引中存在文件 &lt;code&gt;path&lt;/code&gt; 时， &lt;code&gt;git update-index&lt;/code&gt; 拒绝尝试添加 &lt;code&gt;path/file&lt;/code&gt; 。同样，如果存在文件 &lt;code&gt;path/file&lt;/code&gt; ，则无法添加文件 &lt;code&gt;path&lt;/code&gt; 。使用--replace标志，将与警告消息一起自动删除与要添加的条目冲突的现有条目。</target>
        </trans-unit>
        <trans-unit id="299147d01326bdbf4534148e9d9d3fd6c07e2d71" translate="yes" xml:space="preserve">
          <source>By default, when running &lt;code&gt;git sparse-checkout init&lt;/code&gt;, the root directory is added as a parent pattern. At this point, the sparse-checkout file contains the following patterns:</source>
          <target state="translated">默认情况下，运行 &lt;code&gt;git sparse-checkout init&lt;/code&gt; 时，会将根目录添加为父模式。此时，稀疏签出文件包含以下模式：</target>
        </trans-unit>
        <trans-unit id="783945c123405237e5678d472e74b9fc2e2ebcbd" translate="yes" xml:space="preserve">
          <source>By default, when tracing is activated, Git redacts the values of cookies, the &quot;Authorization:&quot; header, and the &quot;Proxy-Authorization:&quot; header. Set this variable to &lt;code&gt;0&lt;/code&gt; to prevent this redaction.</source>
          <target state="translated">默认情况下，激活跟踪时，Git会编辑cookie，&amp;ldquo; Authorization：&amp;rdquo;标头和&amp;ldquo; Proxy-Authorization：&amp;rdquo;标头的值。将此变量设置为 &lt;code&gt;0&lt;/code&gt; 以防止此编辑。</target>
        </trans-unit>
        <trans-unit id="93102cd6e4e7e1fd617df0a6116a6e8dabe44d67" translate="yes" xml:space="preserve">
          <source>By design, Git treats data trusted to it with caution. However, even in the absence of bugs in Git itself, it is still possible that hardware or operating system errors could corrupt data.</source>
          <target state="translated">根据设计,Git会谨慎对待信任的数据。然而,即使Git本身没有错误,硬件或操作系统的错误仍有可能破坏数据。</target>
        </trans-unit>
        <trans-unit id="0405b4cdacdc12c8e141d09b19a221661400dcb6" translate="yes" xml:space="preserve">
          <source>By examining &lt;code&gt;t/.gitattributes&lt;/code&gt; (which is in the same directory as the path in question), Git finds that the first line matches. &lt;code&gt;merge&lt;/code&gt; attribute is set. It also finds that the second line matches, and attributes &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; are unset.</source>
          <target state="translated">通过检查 &lt;code&gt;t/.gitattributes&lt;/code&gt; （与所讨论的路径位于同一目录中），Git发现第一行匹配。设置 &lt;code&gt;merge&lt;/code&gt; 属性。它还发现第二行匹配，并且属性 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 未设置。</target>
        </trans-unit>
        <trans-unit id="6019b6edc3f8183a9650b814f1e96d2397d6c92e" translate="yes" xml:space="preserve">
          <source>By now, you know what the index is (and find the corresponding data structures in &lt;code&gt;cache.h&lt;/code&gt;), and that there are just a couple of object types (blobs, trees, commits and tags) which inherit their common structure from &lt;code&gt;struct object&lt;/code&gt;, which is their first member (and thus, you can cast e.g. &lt;code&gt;(struct object *)commit&lt;/code&gt; to achieve the &lt;code&gt;same&lt;/code&gt; as &lt;code&gt;&amp;amp;commit&amp;rarr;object&lt;/code&gt;, i.e. get at the object name and flags).</source>
          <target state="translated">到目前为止，您已经知道索引是什么（并在 &lt;code&gt;cache.h&lt;/code&gt; 中找到相应的数据结构），并且只有两种对象类型（blob，tree，commit和tag）从 &lt;code&gt;struct object&lt;/code&gt; 继承了它们的通用结构，这是他们的第一个成员（因此，你可以投如 &lt;code&gt;(struct object *)commit&lt;/code&gt; 以达到 &lt;code&gt;same&lt;/code&gt; 的 &lt;code&gt;&amp;amp;commit&amp;rarr;object&lt;/code&gt; ，即在对象的名称和标志得到）。</target>
        </trans-unit>
        <trans-unit id="a2527de53eca60aedafd214cc771f0facd3ab5eb" translate="yes" xml:space="preserve">
          <source>By now, you know what the index is (and find the corresponding data structures in &lt;code&gt;cache.h&lt;/code&gt;), and that there are just a couple of object types (blobs, trees, commits and tags) which inherit their common structure from &lt;code&gt;struct object&lt;/code&gt;, which is their first member (and thus, you can cast e.g. &lt;code&gt;(struct object *)commit&lt;/code&gt; to achieve the &lt;code&gt;same&lt;/code&gt; as &lt;code&gt;&amp;amp;commit-&amp;gt;object&lt;/code&gt;, i.e. get at the object name and flags).</source>
          <target state="translated">到目前为止，您已经知道索引是什么（并在 &lt;code&gt;cache.h&lt;/code&gt; 中找到相应的数据结构），并且只有两种对象类型（blob，tree，commit和tag）从 &lt;code&gt;struct object&lt;/code&gt; 继承了它们的通用结构，这是他们的第一个成员（因此，你可以投如 &lt;code&gt;(struct object *)commit&lt;/code&gt; 以达到 &lt;code&gt;same&lt;/code&gt; 的 &lt;code&gt;&amp;amp;commit-&amp;gt;object&lt;/code&gt; ，即在对象的名称和标志得到）。</target>
        </trans-unit>
        <trans-unit id="7fc0a0343ad2fdcba9cb4eccfe4e06a4bbef7383" translate="yes" xml:space="preserve">
          <source>By replacing the command &quot;pick&quot; with the command &quot;edit&quot;, you can tell &lt;code&gt;git rebase&lt;/code&gt; to stop after applying that commit, so that you can edit the files and/or the commit message, amend the commit, and continue rebasing.</source>
          <target state="translated">通过使用命令&amp;ldquo; edit&amp;rdquo;替换命令&amp;ldquo; pick&amp;rdquo;，您可以告诉 &lt;code&gt;git rebase&lt;/code&gt; 在应用该提交后停止，以便您可以编辑文件和/或提交消息，修改提交，并继续进行基础调整。</target>
        </trans-unit>
        <trans-unit id="38723ef3d6552eb371410d9afcccdbb440b0f54e" translate="yes" xml:space="preserve">
          <source>By setting this variable to a string, &lt;code&gt;git receive-pack&lt;/code&gt; will accept a &lt;code&gt;git push --signed&lt;/code&gt; and verifies it by using a &quot;nonce&quot; protected by HMAC using this string as a secret key.</source>
          <target state="translated">通过将此变量设置为字符串， &lt;code&gt;git receive-pack&lt;/code&gt; 将接受 &lt;code&gt;git push --signed&lt;/code&gt; 并通过使用受此字符串作为密钥的，受HMAC保护的&amp;ldquo; nonce&amp;rdquo;进行验证。</target>
        </trans-unit>
        <trans-unit id="b0ec84a28e8863d61bfe49155bbc56f1b080a18a" translate="yes" xml:space="preserve">
          <source>By specifying &lt;code&gt;base&lt;/code&gt; as the limit, you can avoid listing commits between &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;topic&lt;/code&gt;:</source>
          <target state="translated">通过将 &lt;code&gt;base&lt;/code&gt; 指定为限制，可以避免列出 &lt;code&gt;base&lt;/code&gt; 和 &lt;code&gt;topic&lt;/code&gt; 之间的提交：</target>
        </trans-unit>
        <trans-unit id="bac0dcb4a691d6bbb7adf78bc3225e969e991ed2" translate="yes" xml:space="preserve">
          <source>By specifying a single suffix in this variable, any tagname containing that suffix will appear before the corresponding main release. E.g. if the variable is set to &quot;-rc&quot;, then all &quot;1.0-rcX&quot; tags will appear before &quot;1.0&quot;. If specified multiple times, once per suffix, then the order of suffixes in the configuration will determine the sorting order of tagnames with those suffixes. E.g. if &quot;-pre&quot; appears before &quot;-rc&quot; in the configuration, then all &quot;1.0-preX&quot; tags will be listed before any &quot;1.0-rcX&quot; tags. The placement of the main release tag relative to tags with various suffixes can be determined by specifying the empty suffix among those other suffixes. E.g. if the suffixes &quot;-rc&quot;, &quot;&quot;, &quot;-ck&quot; and &quot;-bfs&quot; appear in the configuration in this order, then all &quot;v4.8-rcX&quot; tags are listed first, followed by &quot;v4.8&quot;, then &quot;v4.8-ckX&quot; and finally &quot;v4.8-bfsX&quot;.</source>
          <target state="translated">通过在此变量中指定一个后缀,任何包含该后缀的 tagname 都会出现在相应的主版本之前,例如,如果将该变量设置为&quot;-rc&quot;,那么所有 &quot;1.0-rcX &quot;标签都会出现在 &quot;1.0 &quot;之前。例如,如果将该变量设置为&quot;-rc&quot;,那么所有 &quot;1.0-rcX &quot;标记将出现在 &quot;1.0 &quot;之前。如果多次指定,每个后缀指定一次,那么配置中后缀的顺序将决定带有这些后缀的 tagnames 的排序顺序。例如,如果配置中&quot;-pre &quot;出现在&quot;-rc &quot;之前,那么所有 &quot;1.0-preX &quot;标记将列在任何 &quot;1.0-rcX &quot;标记之前。主发布标签相对于具有各种后缀的标签的位置,可以通过指定这些其他后缀中的空后缀来确定。例如,如果后缀&quot;-rc&quot;、&quot;&quot;、&quot;-ck &quot;和&quot;-bfs &quot;按此顺序出现在配置中,那么所有 &quot;v4.8-rcX &quot;标记将首先列出,然后是 &quot;v4.8&quot;,然后是 &quot;v4.8-ckX&quot;,最后是 &quot;v4.8-bfsX&quot;。</target>
        </trans-unit>
        <trans-unit id="73d10606466530ea834324e2af3cd4f5fdf3b7ef" translate="yes" xml:space="preserve">
          <source>By using &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; arguments, e.g., path limiters, you can limit the set of revisions which get rewritten. However, positive refs on the command line are distinguished: we don&amp;rsquo;t let them be excluded by such limiters. For this purpose, they are instead rewritten to point at the nearest ancestor that was not excluded.</source>
          <target state="translated">通过使用&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;参数，例如路径限制器，您可以限制要重写的修订版本集。但是，命令行上的正引用是有区别的：我们不允许这些限制器排除它们。为此，它们被重写为指向未被排除的最接近的祖先。</target>
        </trans-unit>
        <trans-unit id="2fbc7b3eb43b76b2746e664c28cb9ad054eb9a86" translate="yes" xml:space="preserve">
          <source>Bypass the post-rewrite hook.</source>
          <target state="translated">绕过改写后的钩子。</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="2b7976aa8c8ee62577557b0faf6cd45c7d87d599" translate="yes" xml:space="preserve">
          <source>C: copy of a file into a new one</source>
          <target state="translated">C:将一个文件复制到一个新的文件中。</target>
        </trans-unit>
        <trans-unit id="8cb2e80198d1a22ece7b2150ad287e7b39ba33cd" translate="yes" xml:space="preserve">
          <source>CHUNK DATA:</source>
          <target state="translated">CHUNK数据。</target>
        </trans-unit>
        <trans-unit id="9da2b59eccc71e5c2791bd9f721e6de7f9e4a527" translate="yes" xml:space="preserve">
          <source>CHUNK LOOKUP:</source>
          <target state="translated">CHUNK LOOKUP。</target>
        </trans-unit>
        <trans-unit id="80b98464bb70114a32291bbd946cd28be305c2cc" translate="yes" xml:space="preserve">
          <source>CONF.VAR (from -c option) and web.browser</source>
          <target state="translated">CONF.VAR(来自-c选项)和web.browser。</target>
        </trans-unit>
        <trans-unit id="3dbd7d6cec79d8e6d8ed5bf27ab1a1f14a9e6a20" translate="yes" xml:space="preserve">
          <source>CONF.VAR is looked up in the Git config files. If it&amp;rsquo;s set, then its value specifies the browser that should be used.</source>
          <target state="translated">在Git配置文件中查找CONF.VAR。如果已设置，则其值指定应使用的浏览器。</target>
        </trans-unit>
        <trans-unit id="025c408a5504f0e808d096b14c696e6a19ee3cbf" translate="yes" xml:space="preserve">
          <source>CONTENT_TYPE</source>
          <target state="translated">CONTENT_TYPE</target>
        </trans-unit>
        <trans-unit id="45649b220c5ae097eced7a136897aeb49a47599c" translate="yes" xml:space="preserve">
          <source>CRLF Line Ending Conversions</source>
          <target state="translated">CRLF线端转换</target>
        </trans-unit>
        <trans-unit id="4d982ea44c2ace64324fd7fbacbc4c4d91f3e200" translate="yes" xml:space="preserve">
          <source>CRLF conversion bears a slight chance of corrupting data. When it is enabled, Git will convert CRLF to LF during commit and LF to CRLF during checkout. A file that contains a mixture of LF and CRLF before the commit cannot be recreated by Git. For text files this is the right thing to do: it corrects line endings such that we have only LF line endings in the repository. But for binary files that are accidentally classified as text the conversion can corrupt data.</source>
          <target state="translated">CRLF转换有轻微的破坏数据的可能性。启用该功能后,Git 会在提交时将 CRLF 转换为 LF,在签出时将 LF 转换为 CRLF。提交前包含LF和CRLF混合的文件不能被Git重新创建。对于文本文件来说,这样做是正确的:它纠正了行尾,使我们在版本库中只有LF行尾。但对于不小心被归类为文本的二进制文件,转换会破坏数据。</target>
        </trans-unit>
        <trans-unit id="b2dadeb076c332a230cd3f419ccce73fc473e9b1" translate="yes" xml:space="preserve">
          <source>CVS 1.11.17 on MacOSX (from Fink package)</source>
          <target state="translated">MacOSX上的CVS 1.11.17 (来自Fink包)</target>
        </trans-unit>
        <trans-unit id="31ba0d2766dea7911d9b0133542d1dae7c40d21b" translate="yes" xml:space="preserve">
          <source>CVS 1.12.9 on Debian</source>
          <target state="translated">CVS 1.12.9 在 Debian 上</target>
        </trans-unit>
        <trans-unit id="c10230da83b7ef151899f83d727ffc465e699ce7" translate="yes" xml:space="preserve">
          <source>CVS by default uses the Unix username when writing its commit logs. Using this option and an author-conv-file maps the name recorded in CVS to author name, e-mail and optional time zone:</source>
          <target state="translated">CVS 在写提交日志时默认使用 Unix 用户名。使用这个选项和author-conv-file可以将CVS中记录的名字映射为作者名、电子邮件和可选的时区。</target>
        </trans-unit>
        <trans-unit id="edcdc296b2872a295927e706b64b0873d75bd7e8" translate="yes" xml:space="preserve">
          <source>CVS clients cannot tag, branch or perform Git merges.</source>
          <target state="translated">CVS 客户端不能标记、分支或执行 Git 合并。</target>
        </trans-unit>
        <trans-unit id="98b46c65d5bf63821f6ce6bd595bdc32473d951c" translate="yes" xml:space="preserve">
          <source>CVS module/Git head name</source>
          <target state="translated">CVS模块/Git头名称</target>
        </trans-unit>
        <trans-unit id="49adb1e8c5b17953ca229c40061a8d1bb5bb8b5e" translate="yes" xml:space="preserve">
          <source>CVS users are accustomed to giving a group of developers commit access to a common repository. As we&amp;rsquo;ve seen, this is also possible with Git. However, the distributed nature of Git allows other development models, and you may want to first consider whether one of them might be a better fit for your project.</source>
          <target state="translated">CVS用户习惯于给一组开发人员提交对公共存储库的访问权限。如我们所见，Git也可以做到这一点。但是，Git的分布式特性允许其他开发模型，您可能首先要考虑其中一种是否更适合您的项目。</target>
        </trans-unit>
        <trans-unit id="aed153eb92fac6b914dbc191a216beb300201f66" translate="yes" xml:space="preserve">
          <source>CVS-style shared repository.</source>
          <target state="translated">CVS风格的共享存储库。</target>
        </trans-unit>
        <trans-unit id="f52ad32f29f6847c4f98f4be5fc01986743d4aae" translate="yes" xml:space="preserve">
          <source>Cache credentials in memory for a short period of time. See &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache[1]&lt;/a&gt; for details.</source>
          <target state="translated">在短时间内将凭据缓存在内存中。有关详细信息，请参见&lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68d01495331ef3ec55abb430492aa431fb98900b" translate="yes" xml:space="preserve">
          <source>Cached mode</source>
          <target state="translated">缓存模式</target>
        </trans-unit>
        <trans-unit id="bc41c881675379eb55dc52ac754cd0a47e293c0b" translate="yes" xml:space="preserve">
          <source>Caching. Textconv caching can speed up repeated diffs, such as those you might trigger by running &lt;code&gt;git log -p&lt;/code&gt;.</source>
          <target state="translated">正在缓存。Textconv缓存可以加快重复的差异，例如运行 &lt;code&gt;git log -p&lt;/code&gt; 可能触发的差异。</target>
        </trans-unit>
        <trans-unit id="b3bd71fe43527e264035373707bb05e34bacabd4" translate="yes" xml:space="preserve">
          <source>Call the corresponding server-side command to support the client&amp;rsquo;s &lt;code&gt;git push&lt;/code&gt;, &lt;code&gt;git fetch&lt;/code&gt;, or &lt;code&gt;git archive --remote&lt;/code&gt; request.</source>
          <target state="translated">调用相应的服务器端命令以支持客户端的 &lt;code&gt;git push&lt;/code&gt; ， &lt;code&gt;git fetch&lt;/code&gt; 或 &lt;code&gt;git archive --remote&lt;/code&gt; 请求。</target>
        </trans-unit>
        <trans-unit id="3907fb8eaa84bdb8f3cc45ad006023c90615ad1f" translate="yes" xml:space="preserve">
          <source>Can attempt to connect to &lt;code&gt;git receive-pack&lt;/code&gt; (for pushing), &lt;code&gt;git upload-pack&lt;/code&gt;, etc for communication using git&amp;rsquo;s native packfile protocol. This requires a bidirectional, full-duplex connection.</source>
          <target state="translated">可以尝试使用git的本地packfile协议连接到 &lt;code&gt;git receive-pack&lt;/code&gt; （用于推送）， &lt;code&gt;git upload-pack&lt;/code&gt; 等进行通信。这需要双向全双工连接。</target>
        </trans-unit>
        <trans-unit id="0c6fd80a7557d1e5d2aaff98df3b675a4f3e3e9e" translate="yes" xml:space="preserve">
          <source>Can be overridden by the &lt;code&gt;GIT_PROXY_COMMAND&lt;/code&gt; environment variable (which always applies universally, without the special &quot;for&quot; handling).</source>
          <target state="translated">可以被 &lt;code&gt;GIT_PROXY_COMMAND&lt;/code&gt; 环境变量覆盖（该变量始终通用，没有特殊的&amp;ldquo; for&amp;rdquo;处理）。</target>
        </trans-unit>
        <trans-unit id="0f39962decf24e67df63f769ebf7a91027019ae1" translate="yes" xml:space="preserve">
          <source>Can be overridden by the &lt;code&gt;GIT_SSL_CIPHER_LIST&lt;/code&gt; environment variable. To force git to use libcurl&amp;rsquo;s default cipher list and ignore any explicit http.sslCipherList option, set &lt;code&gt;GIT_SSL_CIPHER_LIST&lt;/code&gt; to the empty string.</source>
          <target state="translated">可以被 &lt;code&gt;GIT_SSL_CIPHER_LIST&lt;/code&gt; 环境变量覆盖。要强制git使用libcurl的默认密码列表并忽略任何显式的http.sslCipherList选项，请将 &lt;code&gt;GIT_SSL_CIPHER_LIST&lt;/code&gt; 设置为空字符串。</target>
        </trans-unit>
        <trans-unit id="29d57ff400cc012cacf16bd510a83a1f80c69dcf" translate="yes" xml:space="preserve">
          <source>Can be overridden by the &lt;code&gt;GIT_SSL_VERSION&lt;/code&gt; environment variable. To force git to use libcurl&amp;rsquo;s default ssl version and ignore any explicit http.sslversion option, set &lt;code&gt;GIT_SSL_VERSION&lt;/code&gt; to the empty string.</source>
          <target state="translated">可以被 &lt;code&gt;GIT_SSL_VERSION&lt;/code&gt; 环境变量覆盖。要强制git使用libcurl的默认ssl版本并忽略任何显式的http.sslversion选项，请将 &lt;code&gt;GIT_SSL_VERSION&lt;/code&gt; 设置为空字符串。</target>
        </trans-unit>
        <trans-unit id="8710d5603018e270e9135bc9b07e18583e6e40b7" translate="yes" xml:space="preserve">
          <source>Can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable.</source>
          <target state="translated">可以用 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="f3ab6f60ab10fc57456b8912494e28284fd290bc" translate="yes" xml:space="preserve">
          <source>Can be set using the &lt;code&gt;GITWEB_SITENAME&lt;/code&gt; at build time. Unset by default.</source>
          <target state="translated">可以在构建时使用 &lt;code&gt;GITWEB_SITENAME&lt;/code&gt; 进行设置。默认情况下未设置。</target>
        </trans-unit>
        <trans-unit id="217827b02c2eeb06477e279b6b6efc5d7d10ed39" translate="yes" xml:space="preserve">
          <source>Can be used in conjunction with &lt;code&gt;--single-branch&lt;/code&gt; to clone and maintain a branch with no references other than a single cloned branch. This is useful e.g. to maintain minimal clones of the default branch of some repository for search indexing.</source>
          <target state="translated">可以与 &lt;code&gt;--single-branch&lt;/code&gt; 一起使用，以克隆和维护除单个克隆分支之外没有其他引用的分支。例如，这对于维护某些存储库的默认分支的最小克隆以进行搜索索引很有用。</target>
        </trans-unit>
        <trans-unit id="a9691ee782e933498eb75769eeec906fc37e3a47" translate="yes" xml:space="preserve">
          <source>Can discover remote refs and output objects reachable from them as a stream in fast-import format.</source>
          <target state="translated">可以发现远程的参考文献,并以快速导入格式的流的形式输出可从它们到达的对象。</target>
        </trans-unit>
        <trans-unit id="90035edf92bee77fbf7fe329bbc961839dc96080" translate="yes" xml:space="preserve">
          <source>Can discover remote refs and push local commits and the history leading up to them to new or existing remote refs.</source>
          <target state="translated">可以发现远程参考,并将本地提交和导致它们的历史推送给新的或现有的远程参考。</target>
        </trans-unit>
        <trans-unit id="138c5e6b546882127de4e82d6394ea6b4a6a09ca" translate="yes" xml:space="preserve">
          <source>Can discover remote refs and push specified objects from a fast-import stream to remote refs.</source>
          <target state="translated">可以发现远程参照物,并从快速导入流中推送指定对象到远程参照物。</target>
        </trans-unit>
        <trans-unit id="b4530b46452bf0ddccff90b10194b6dc8dee0aff" translate="yes" xml:space="preserve">
          <source>Can discover remote refs and transfer objects reachable from them to the local object store.</source>
          <target state="translated">可以发现远程参照物,并将其可到达的对象转移到本地对象存储中。</target>
        </trans-unit>
        <trans-unit id="7decaa19c2a5956f9383448e881b3336964a5bef" translate="yes" xml:space="preserve">
          <source>Can guarantee that when a clone is requested, the received pack is self contained and is connected.</source>
          <target state="translated">能保证在请求克隆的时候,收到的包是自带的,并且是连接的。</target>
        </trans-unit>
        <trans-unit id="b7ebace43478348d6004d061ea665f140df1bb53" translate="yes" xml:space="preserve">
          <source>Can try to connect to &lt;code&gt;git upload-pack&lt;/code&gt; (for fetching), &lt;code&gt;git receive-pack&lt;/code&gt;, etc for communication using the Git&amp;rsquo;s native packfile protocol. This requires a bidirectional, full-duplex connection.</source>
          <target state="translated">可以尝试使用Git的本地packfile协议连接到 &lt;code&gt;git upload-pack&lt;/code&gt; （用于获取）， &lt;code&gt;git receive-pack&lt;/code&gt; 等进行通信。这需要双向全双工连接。</target>
        </trans-unit>
        <trans-unit id="4cb14361f0a5ad881a24c94d8c006e5f643d8a87" translate="yes" xml:space="preserve">
          <source>Cancel the operation and return to the pre-sequence state.</source>
          <target state="translated">取消操作,回到序列前状态。</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="20243c460d0e899aa2ea919e5a33ddf3fc3c28ee" translate="yes" xml:space="preserve">
          <source>Capabilities for Fetching</source>
          <target state="translated">获取能力</target>
        </trans-unit>
        <trans-unit id="2cf429aa6c517aac8e25fa8619402627623a5d1f" translate="yes" xml:space="preserve">
          <source>Capabilities for Pushing</source>
          <target state="translated">推进能力</target>
        </trans-unit>
        <trans-unit id="a02cd245f4a5359f48f45e974d4d2aeb3f737ec2" translate="yes" xml:space="preserve">
          <source>Capability advertisement</source>
          <target state="translated">能力广告</target>
        </trans-unit>
        <trans-unit id="c22170810a14c7bbd4efce02f795f3261d0f8ee1" translate="yes" xml:space="preserve">
          <source>Captures information about the user&amp;rsquo;s machine, Git client, and repository state, as well as a form requesting information about the behavior the user observed, into a single text file which the user can then share, for example to the Git mailing list, in order to report an observed bug.</source>
          <target state="translated">将有关用户机器，Git客户端和存储库状态的信息以及请求有关用户观察到的行为的信息的表单捕获到单个文本文件中，然后用户可以共享该文本文件，例如，将其共享到Git邮件列表报告观察到的错误。</target>
        </trans-unit>
        <trans-unit id="fbb741f1d3fe925738bd52e124aa5bcdfaec72b5" translate="yes" xml:space="preserve">
          <source>Case 3 is slightly tricky and needs explanation. The result from this rule logically should be to remove the path if the user staged the removal of the path and then switching to a new branch. That however will prevent the initial checkout from happening, so the rule is modified to use M (new tree) only when the content of the index is empty. Otherwise the removal of the path is kept as long as $H and $M are the same.</source>
          <target state="translated">情况3稍微有点棘手,需要解释一下。从这个规则的逻辑上看,如果用户阶段性的删除路径,然后切换到新的分支,那么结果应该是删除路径。然而这样会阻止初始签出的发生,所以规则修改为只有当索引内容为空时才使用M(新树)。否则只要$H和$M相同,就会保留删除路径。</target>
        </trans-unit>
        <trans-unit id="e09c27f67e4fbebb877a3f28eee7f79c8bd9d162" translate="yes" xml:space="preserve">
          <source>Case insensitive match.</source>
          <target state="translated">不区分大小写的匹配。</target>
        </trans-unit>
        <trans-unit id="3ba6868684fb15f285ba371e8f8692f5e6c1b769" translate="yes" xml:space="preserve">
          <source>Cause the logical variables to be listed. In addition, all the variables of the Git configuration file .git/config are listed as well. (However, the configuration variables listing functionality is deprecated in favor of &lt;code&gt;git config -l&lt;/code&gt;.)</source>
          <target state="translated">使逻辑变量被列出。此外，还列出了Git配置文件.git / config的所有变量。（但是，不推荐使用配置变量列出功能，而推荐使用 &lt;code&gt;git config -l&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="b783ff5188b18ab4ca3191c5116581bc5ecb01a2" translate="yes" xml:space="preserve">
          <source>Causes fast-import to echo the entire line to its own standard output. This command is optional and is not needed to perform an import.</source>
          <target state="translated">使 fast-import 将整个行呼应到它自己的标准输出。这个命令是可选的,在执行导入时不需要。</target>
        </trans-unit>
        <trans-unit id="12b02e08644454fc1547d338b5de4943ef66f77b" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print a blob in &lt;code&gt;cat-file --batch&lt;/code&gt; format to the file descriptor set with &lt;code&gt;--cat-blob-fd&lt;/code&gt; or &lt;code&gt;stdout&lt;/code&gt; if unspecified.</source>
          <target state="translated">导致快速导入将 &lt;code&gt;cat-file --batch&lt;/code&gt; 格式的blob打印到使用 &lt;code&gt;--cat-blob-fd&lt;/code&gt; 或 &lt;code&gt;stdout&lt;/code&gt; (如果未指定）设置的文件描述符。</target>
        </trans-unit>
        <trans-unit id="b8e75699b5276c39faaefd045a6a5b904b73ada6" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print a blob to a file descriptor previously arranged with the &lt;code&gt;--cat-blob-fd&lt;/code&gt; argument. The command otherwise has no impact on the current import; its main purpose is to retrieve blobs that may be in fast-import&amp;rsquo;s memory but not accessible from the target repository.</source>
          <target state="translated">使快速导入将blob打印到先前使用 &lt;code&gt;--cat-blob-fd&lt;/code&gt; 参数排列的文件描述符。否则，该命令不会对当前导入产生任何影响。其主要目的是检索可能在快速导入的内存中但无法从目标存储库访问的blob。</target>
        </trans-unit>
        <trans-unit id="7ec5756843c97a7c2f1df63914ede6a2099f489a" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print a line describing a directory entry in &lt;code&gt;ls-tree&lt;/code&gt; format to the file descriptor set with &lt;code&gt;--cat-blob-fd&lt;/code&gt; or &lt;code&gt;stdout&lt;/code&gt; if unspecified.</source>
          <target state="translated">导致快速导入将以 &lt;code&gt;ls-tree&lt;/code&gt; 格式描述目录条目的行打印到使用 &lt;code&gt;--cat-blob-fd&lt;/code&gt; 或 &lt;code&gt;stdout&lt;/code&gt; (如果未指定）设置的文件描述符。</target>
        </trans-unit>
        <trans-unit id="886958bd2ea3f9b4ef6490b2b36e023c05b21b29" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print the SHA-1 corresponding to a mark to stdout or to the file descriptor previously arranged with the &lt;code&gt;--cat-blob-fd&lt;/code&gt; argument. The command otherwise has no impact on the current import; its purpose is to retrieve SHA-1s that later commits might want to refer to in their commit messages.</source>
          <target state="translated">使快速导入打印与标准输出标记或先前使用 &lt;code&gt;--cat-blob-fd&lt;/code&gt; 参数排列的文件描述符相对应的SHA-1 。否则，该命令不会对当前导入产生任何影响。其目的是检索SHA-1，以后的提交可能要在其提交消息中引用它们。</target>
        </trans-unit>
        <trans-unit id="a62399ea6471f58f0ac3e20d903be4ac533d6d4e" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print the SHA-1 corresponding to a mark to the file descriptor set with &lt;code&gt;--cat-blob-fd&lt;/code&gt;, or &lt;code&gt;stdout&lt;/code&gt; if unspecified.</source>
          <target state="translated">使快速导入将与标记相对应的SHA-1打印到使用 &lt;code&gt;--cat-blob-fd&lt;/code&gt; 或 &lt;code&gt;stdout&lt;/code&gt; (如果未指定）设置的文件描述符。</target>
        </trans-unit>
        <trans-unit id="b482598ddd71627c6a7b2ff32a0b59803f8fd34f" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print the entire &lt;code&gt;progress&lt;/code&gt; line unmodified to its standard output channel (file descriptor 1) when the command is processed from the input stream. The command otherwise has no impact on the current import, or on any of fast-import&amp;rsquo;s internal state.</source>
          <target state="translated">从输入流处理命令时，使快速导入将未经修改的整个 &lt;code&gt;progress&lt;/code&gt; 行打印到其标准输出通道（文件描述符1）。否则，该命令对当前导入或快速导入的任何内部状态都没有影响。</target>
        </trans-unit>
        <trans-unit id="55a89527100d7affacb785a535913eceec75eda6" translate="yes" xml:space="preserve">
          <source>Caution</source>
          <target state="translated">Caution</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="62c56e9140b73b971227c6e095597a6888ab6f0b" translate="yes" xml:space="preserve">
          <source>Certain operations by Git can be influenced by assigning particular attributes to a path. Currently, the following operations are attributes-aware.</source>
          <target state="translated">Git 的某些操作可以通过给路径分配特定的属性来影响。目前,以下操作都是属性感知的。</target>
        </trans-unit>
        <trans-unit id="ce89ebfc7c6f30e38c61f750189a14aac995df3f" translate="yes" xml:space="preserve">
          <source>Change daemon&amp;rsquo;s uid and gid before entering the service loop. When only &lt;code&gt;--user&lt;/code&gt; is given without &lt;code&gt;--group&lt;/code&gt;, the primary group ID for the user is used. The values of the option are given to &lt;code&gt;getpwnam(3)&lt;/code&gt; and &lt;code&gt;getgrnam(3)&lt;/code&gt; and numeric IDs are not supported.</source>
          <target state="translated">进入服务循环之前，请更改守护程序的uid和gid。如果仅给出 &lt;code&gt;--user&lt;/code&gt; 而不给出 &lt;code&gt;--group&lt;/code&gt; ，则使用该用户的主要组ID。该选项的值分别提供给 &lt;code&gt;getpwnam(3)&lt;/code&gt; 和 &lt;code&gt;getgrnam(3)&lt;/code&gt; ,并且不支持数字ID。</target>
        </trans-unit>
        <trans-unit id="f8d5e6dcdbe26b10de586e21b98816e7aa3c05a4" translate="yes" xml:space="preserve">
          <source>Change output color. Followed by &lt;code&gt;:&amp;lt;colorname&amp;gt;&lt;/code&gt;, where color names are described under Values in the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. For example, &lt;code&gt;%(color:bold red)&lt;/code&gt;.</source>
          <target state="translated">更改输出颜色。后跟 &lt;code&gt;:&amp;lt;colorname&amp;gt;&lt;/code&gt; ，其中颜色名称在&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;的&amp;ldquo; CONFIGURATION FILE&amp;rdquo;部分的&amp;ldquo; Values&amp;rdquo;下描述。例如， &lt;code&gt;%(color:bold red)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e718f5f36cc4b622f94d06a68422a543373288f" translate="yes" xml:space="preserve">
          <source>Changed Tracked Entries</source>
          <target state="translated">已更改的跟踪条目</target>
        </trans-unit>
        <trans-unit id="a838ac0a12d74a72136f3630d86af0c9b1c990e6" translate="yes" xml:space="preserve">
          <source>Changes URLs for the remote. Sets first URL for remote &amp;lt;name&amp;gt; that matches regex &amp;lt;oldurl&amp;gt; (first URL if no &amp;lt;oldurl&amp;gt; is given) to &amp;lt;newurl&amp;gt;. If &amp;lt;oldurl&amp;gt; doesn&amp;rsquo;t match any URL, an error occurs and nothing is changed.</source>
          <target state="translated">更改遥控器的URL。将与正则表达式&amp;lt;oldurl&amp;gt;匹配的远程&amp;lt;name&amp;gt;的第一个URL（如果没有给出&amp;lt;oldurl&amp;gt;的话，则设置第一个URL）为&amp;lt;newurl&amp;gt;。如果&amp;lt;oldurl&amp;gt;与任何URL不匹配，则将发生错误，并且不会进行任何更改。</target>
        </trans-unit>
        <trans-unit id="5f81b14c458a3f96e356b0db1d9a8184d3aa46df" translate="yes" xml:space="preserve">
          <source>Changes between the index and your last commit; what you would be committing if you run &quot;git commit&quot; without &quot;-a&quot; option.</source>
          <target state="translated">索引和上次提交之间的变化;如果你运行 &quot;git commit &quot;而不使用&quot;-a &quot;选项,你将提交的内容。</target>
        </trans-unit>
        <trans-unit id="3cc6102e534f7e5270274b498981fc65c20ab548" translate="yes" xml:space="preserve">
          <source>Changes between the index and your last commit; what you would be committing if you run &lt;code&gt;git commit&lt;/code&gt; without &lt;code&gt;-a&lt;/code&gt; option.</source>
          <target state="translated">索引和上一次提交之间的更改；如果运行不带 &lt;code&gt;-a&lt;/code&gt; 选项的 &lt;code&gt;git commit&lt;/code&gt; ,将提交的内容。</target>
        </trans-unit>
        <trans-unit id="c2b554b2b0f0318db4bfdd8caad455aa5f11a835" translate="yes" xml:space="preserve">
          <source>Changes between the tips of the topic and the master branches.</source>
          <target state="translated">题的提示和主枝之间的变化。</target>
        </trans-unit>
        <trans-unit id="bb16f58635d0a49bf7d13f03eb1b1023bc073b68" translate="yes" xml:space="preserve">
          <source>Changes in the working tree not yet staged for the next commit.</source>
          <target state="translated">工作树上的变化还没有到下一次提交的阶段。</target>
        </trans-unit>
        <trans-unit id="7ac9e8718cf2c5d1390484c758626a70c63f62f2" translate="yes" xml:space="preserve">
          <source>Changes in the working tree since your last commit; what you would be committing if you run &quot;git commit -a&quot;</source>
          <target state="translated">自上次提交以来工作树上的变化;如果运行 &quot;git commit -a&quot;,你将会提交什么?</target>
        </trans-unit>
        <trans-unit id="0276a1b15d4851a5710ebd5d60ca95705260caaa" translate="yes" xml:space="preserve">
          <source>Changes in the working tree since your last commit; what you would be committing if you run &lt;code&gt;git commit -a&lt;/code&gt;</source>
          <target state="translated">自上次提交以来工作树中的更改；如果您运行 &lt;code&gt;git commit -a&lt;/code&gt; 将会提交什么</target>
        </trans-unit>
        <trans-unit id="959e8030a92b92d7979097ada92148067be55d31" translate="yes" xml:space="preserve">
          <source>Changes that occurred on the master branch since when the topic branch was started off it.</source>
          <target state="translated">自主题分支开始后,主分支上发生的变化。</target>
        </trans-unit>
        <trans-unit id="dcc9e0a603da36a49c01908e321b093eae90c8fa" translate="yes" xml:space="preserve">
          <source>Changes the list of branches tracked by the named remote. This can be used to track a subset of the available remote branches after the initial setup for a remote.</source>
          <target state="translated">更改被命名的远程服务器所跟踪的分支列表。这可以用来在初始化远程设置后追踪可用的远程分支的子集。</target>
        </trans-unit>
        <trans-unit id="0bccb8c649445d0e9e5ceb6a829109a7f170728f" translate="yes" xml:space="preserve">
          <source>Changes the verbosity of messages displayed by the helper. A value of 0 for &amp;lt;n&amp;gt; means that processes operate quietly, and the helper produces only error output. 1 is the default level of verbosity, and higher values of &amp;lt;n&amp;gt; correspond to the number of -v flags passed on the command line.</source>
          <target state="translated">更改助手显示的消息的详细程度。 &amp;lt;n&amp;gt;的值为0表示进程安静地运行，并且助手仅产生错误输出。默认级别为1，&amp;lt;n&amp;gt;的较高值对应于在命令行上传递的-v标志的数量。</target>
        </trans-unit>
        <trans-unit id="dd3116927a9e7dd7238b571d53ce2cf77fe23ee1" translate="yes" xml:space="preserve">
          <source>Changesets from p4 are imported using Git fast-import.</source>
          <target state="translated">变更集从p4中使用Git fast-import导入。</target>
        </trans-unit>
        <trans-unit id="cab94268d38355d76ce36a45e9bc285de9460c51" translate="yes" xml:space="preserve">
          <source>Changing gitweb&amp;rsquo;s behavior</source>
          <target state="translated">改变gitweb的行为</target>
        </trans-unit>
        <trans-unit id="1e7847382a16c8079c307e0f617f25cfce7cb965" translate="yes" xml:space="preserve">
          <source>Changing gitweb&amp;rsquo;s look</source>
          <target state="translated">改变gitweb的外观</target>
        </trans-unit>
        <trans-unit id="5812a54bc86041329c11b2c54c0ad4f0c8785223" translate="yes" xml:space="preserve">
          <source>Character encoding the commit messages are converted to when running &lt;code&gt;git log&lt;/code&gt; and friends.</source>
          <target state="translated">运行 &lt;code&gt;git log&lt;/code&gt; 和friends 时，将编码提交消息的字符转换为。</target>
        </trans-unit>
        <trans-unit id="1ae63f6ea8b36d3c621f3c26e7c68c400e2fdc6f" translate="yes" xml:space="preserve">
          <source>Character encoding the commit messages are stored in; Git itself does not care per se, but this information is necessary e.g. when importing commits from emails or in the gitk graphical history browser (and possibly at other places in the future or in other porcelains). See e.g. &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;. Defaults to &lt;code&gt;utf-8&lt;/code&gt;.</source>
          <target state="translated">存储提交消息的字符编码；Git本身本身并不关心，但是该信息是必需的，例如，当从电子邮件或gitk图形历史浏览器中（以及将来可能在其他地方或在其他瓷器中）导入提交时。参见例如&lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]&lt;/a&gt;。默认为 &lt;code&gt;utf-8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d76545473270b409d5ad4bb0d1fe44d81e97f58" translate="yes" xml:space="preserve">
          <source>Check for corruption:</source>
          <target state="translated">检查是否有腐败。</target>
        </trans-unit>
        <trans-unit id="b7d8cdc518631e2251ad5f880bdb559475d2d3c6" translate="yes" xml:space="preserve">
          <source>Check if &amp;lt;path&amp;gt; is a valid repository or a gitfile that points at a valid repository, and print the location of the repository. If &amp;lt;path&amp;gt; is a gitfile then the resolved path to the real repository is printed.</source>
          <target state="translated">检查&amp;lt;path&amp;gt;是有效的存储库还是指向有效存储库的gitfile，然后打印存储库的位置。如果&amp;lt;path&amp;gt;是一个gitfile，则将打印到实际存储库的解析路径。</target>
        </trans-unit>
        <trans-unit id="e60019605e61c29f438d2140b618df2fa7a2cf81" translate="yes" xml:space="preserve">
          <source>Check if the command would error out, without updating the index or the files in the working tree for real.</source>
          <target state="translated">检查命令是否会出错,没有真正更新工作树中的索引或文件。</target>
        </trans-unit>
        <trans-unit id="03d22f18e900d425734c737c0518f14811d19a56" translate="yes" xml:space="preserve">
          <source>Check if the first &amp;lt;commit&amp;gt; is an ancestor of the second &amp;lt;commit&amp;gt;, and exit with status 0 if true, or with status 1 if not. Errors are signaled by a non-zero status that is not 1.</source>
          <target state="translated">检查第一个&amp;lt;commit&amp;gt;的祖先是否是第二个&amp;lt;commit&amp;gt;的祖先，如果为true，则退出状态为0；否则，退出为状态1。错误由非零的非1状态表示。</target>
        </trans-unit>
        <trans-unit id="83e838c1d2166b2d88caf18328aef0c7567d558a" translate="yes" xml:space="preserve">
          <source>Check not just objects in GIT_OBJECT_DIRECTORY ($GIT_DIR/objects), but also the ones found in alternate object pools listed in GIT_ALTERNATE_OBJECT_DIRECTORIES or $GIT_DIR/objects/info/alternates, and in packed Git archives found in $GIT_DIR/objects/pack and corresponding pack subdirectories in alternate object pools. This is now default; you can turn it off with --no-full.</source>
          <target state="translated">不仅检查 GIT_OBJECT_DIRECTORY ($GIT_DIR/objects)中的对象,还检查在 GIT_ALTERNATE_OBJECT_DIRECTORIES 或 $GIT_DIR/objects/info/alternates 中列出的备用对象池中的对象,以及在 $GIT_DIR/objects/pack 和备用对象池中相应的打包子目录中发现的 Git 档案。现在是默认的,你可以用--no-full关闭它。</target>
        </trans-unit>
        <trans-unit id="e79b0680caa2ca1906fd2adf6eaff8974f4a2257" translate="yes" xml:space="preserve">
          <source>Check only the connectivity of reachable objects, making sure that any objects referenced by a reachable tag, commit, or tree is present. This speeds up the operation by avoiding reading blobs entirely (though it does still check that referenced blobs exist). This will detect corruption in commits and trees, but not do any semantic checks (e.g., for format errors). Corruption in blob objects will not be detected at all.</source>
          <target state="translated">只检查可到达对象的连接性,确保任何被可到达标记、提交或树引用的对象都存在。这样可以完全避免读取 blobs,从而加快操作速度(尽管它仍然会检查被引用的 blobs 是否存在)。这将检测提交和树中的损坏,但不进行任何语义检查(例如,格式错误)。完全不会检测到blob对象中的损坏。</target>
        </trans-unit>
        <trans-unit id="1059c6a2d1e02e3f2100e501993e9695ffee2a93" translate="yes" xml:space="preserve">
          <source>Check that the change you made is no longer visible, since it was made on the experimental branch and you&amp;rsquo;re back on the master branch.</source>
          <target state="translated">检查所做的更改是否不再可见，因为它是在实验分支上进行的，并且您又回到了master分支上。</target>
        </trans-unit>
        <trans-unit id="283494db1332f5a5bdeebb22027e88d6ecd9fccd" translate="yes" xml:space="preserve">
          <source>Check the GPG signature of commits</source>
          <target state="translated">检查提交的GPG签名</target>
        </trans-unit>
        <trans-unit id="9942c8361d672deabca4bf9b4378db88e5831693" translate="yes" xml:space="preserve">
          <source>Check the GPG signature of tags</source>
          <target state="translated">检查标签的GPG签名</target>
        </trans-unit>
        <trans-unit id="06577cf94f38a79b885fc18bdd8c2be1bcd96e2b" translate="yes" xml:space="preserve">
          <source>Check the validity of a signed commit object by passing the signature to &lt;code&gt;gpg --verify&lt;/code&gt; and show the output.</source>
          <target state="translated">通过将签名传递给 &lt;code&gt;gpg --verify&lt;/code&gt; 来检查已签名提交对象的有效性，并显示输出。</target>
        </trans-unit>
        <trans-unit id="73422e6d03195802a17e28660f8c31a3d87204d7" translate="yes" xml:space="preserve">
          <source>Check whether two branches point at the same history</source>
          <target state="translated">检查两个分支是否指向同一历史</target>
        </trans-unit>
        <trans-unit id="7a3ffea957d19415bf259687b6fc87b1ce4c0522" translate="yes" xml:space="preserve">
          <source>Check your xinetd(8) documentation and setup, this is from a Fedora system. Others might be different.</source>
          <target state="translated">请检查您的 xinetd(8)文档和设置,这是 Fedora 系统的。其他系统可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="6515762734c69625b8244e79b73529d8fd67b97e" translate="yes" xml:space="preserve">
          <source>Checking for patch corruption</source>
          <target state="translated">检查补丁损坏</target>
        </trans-unit>
        <trans-unit id="c722b668af2290a67a3950339daf5303bf70266c" translate="yes" xml:space="preserve">
          <source>Checking merge bases</source>
          <target state="translated">检查合并基地</target>
        </trans-unit>
        <trans-unit id="fa7ccb17065ab13f50e5f4aa48f888b7f36943e2" translate="yes" xml:space="preserve">
          <source>Checking out an old version of a file</source>
          <target state="translated">检查一个文件的旧版本</target>
        </trans-unit>
        <trans-unit id="4285903ce1710560050a0803b330dcd049bfbfef" translate="yes" xml:space="preserve">
          <source>Checking the repository for corruption</source>
          <target state="translated">检查存储库是否存在腐败</target>
        </trans-unit>
        <trans-unit id="2ac84684aef52ff693250170ef43a76e48af3284" translate="yes" xml:space="preserve">
          <source>Checking whitespace errors</source>
          <target state="translated">检查空白处的错误</target>
        </trans-unit>
        <trans-unit id="527933c1f680ec617db3dd975f754535f385100b" translate="yes" xml:space="preserve">
          <source>Checking-out and checking-in</source>
          <target state="translated">退房和入住</target>
        </trans-unit>
        <trans-unit id="49265102fbdeaea303ebc0238044241c00c923d0" translate="yes" xml:space="preserve">
          <source>Checklist for shrinking a repository</source>
          <target state="translated">缩小存储库的检查表</target>
        </trans-unit>
        <trans-unit id="ce166f9433a0a0acaace5836679192e776275599" translate="yes" xml:space="preserve">
          <source>Checks if a given &lt;code&gt;refname&lt;/code&gt; is acceptable, and exits with a non-zero status if it is not.</source>
          <target state="translated">检查给定的 &lt;code&gt;refname&lt;/code&gt; 是否可接受，如果不是，则以非零状态退出。</target>
        </trans-unit>
        <trans-unit id="3e78b611c92e074aefd3477b078d67a70bbe5ddb" translate="yes" xml:space="preserve">
          <source>Checksums and object ids</source>
          <target state="translated">校验和和对象ID</target>
        </trans-unit>
        <trans-unit id="d8021a065c8c671df3a58cb63e7469b8167a446a" translate="yes" xml:space="preserve">
          <source>Child Process Messages</source>
          <target state="translated">儿童进程信息</target>
        </trans-unit>
        <trans-unit id="5091e72502f618e2b372fcb37e80054927942ac3" translate="yes" xml:space="preserve">
          <source>Child Processes</source>
          <target state="translated">儿童进程</target>
        </trans-unit>
        <trans-unit id="c8895429bfc3ae045740a98bd7892c21d37107b3" translate="yes" xml:space="preserve">
          <source>Choose a diff algorithm. The variants are as follows:</source>
          <target state="translated">选择一种差异算法。变体如下:</target>
        </trans-unit>
        <trans-unit id="59db2d4b9fea86d4c731a426cb932a15c94c9596" translate="yes" xml:space="preserve">
          <source>Choosing textconv versus external diff</source>
          <target state="translated">选择textconv与外部差异</target>
        </trans-unit>
        <trans-unit id="613b7dff145eefd66d417456a88da290b004ada8" translate="yes" xml:space="preserve">
          <source>Chunk header format is modified to prevent people from accidentally feeding it to &lt;code&gt;patch -p1&lt;/code&gt;. Combined diff format was created for review of merge commit changes, and was not meant to be applied. The change is similar to the change in the extended &lt;code&gt;index&lt;/code&gt; header:</source>
          <target state="translated">块头格式已修改，以防止人们不小心将其提供给 &lt;code&gt;patch -p1&lt;/code&gt; 。已创建组合差异格式以查看合并提交更改，但并不适用。该更改类似于扩展 &lt;code&gt;index&lt;/code&gt; 标头中的更改：</target>
        </trans-unit>
        <trans-unit id="bea8190708ca1584f76d1babb3a7796e3e643692" translate="yes" xml:space="preserve">
          <source>Clean up unnecessary files and optimize the local repository. &quot;GC&quot; stands for &quot;garbage collection,&quot; but this task performs many smaller tasks. This task can be expensive for large repositories, as it repacks all Git objects into a single pack-file. It can also be disruptive in some situations, as it deletes stale data. See &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; for more details on garbage collection in Git.</source>
          <target state="translated">清理不必要的文件并优化本地存储库。&amp;ldquo; GC&amp;rdquo;代表&amp;ldquo;垃圾收集&amp;rdquo;，但是此任务执行许多较小的任务。对于大型存储库，此任务可能会很昂贵，因为它将所有Git对象重新打包到一个打包文件中。在某些情况下，它也可能会造成破坏，因为它会删除陈旧的数据。有关&lt;a href=&quot;git-gc&quot;&gt;Git中&lt;/a&gt;垃圾回收的更多详细信息，请参见git-gc [1]。</target>
        </trans-unit>
        <trans-unit id="42dcbc11ebcca8013128e188e07a667fd189817d" translate="yes" xml:space="preserve">
          <source>Cleans the working tree by recursively removing files that are not under version control, starting from the current directory.</source>
          <target state="translated">从当前目录开始,通过递归删除不受版本控制的文件来清理工作树。</target>
        </trans-unit>
        <trans-unit id="f2d831c9f71cd3ff7b3b6c7c49408fcedc1e2e96" translate="yes" xml:space="preserve">
          <source>Cleanup unnecessary files and optimize the local repository</source>
          <target state="translated">清理不必要的文件,优化本地资源库</target>
        </trans-unit>
        <trans-unit id="94f8adfaa49f4f08c745b4d0d2c62d9ba66072a5" translate="yes" xml:space="preserve">
          <source>Clearly this work-flow uses the virtuous circle between test suites and &quot;git bisect&quot;. In fact it makes it the standard procedure to deal with regression.</source>
          <target state="translated">很明显,这个工作流程使用了测试套件和 &quot;git bisect &quot;之间的良性循环。事实上,它让它成为了处理回归的标准程序。</target>
        </trans-unit>
        <trans-unit id="119db12fc152f2f55488f08da986c3c46bdf64a9" translate="yes" xml:space="preserve">
          <source>Clears any list of &quot;To:&quot;, &quot;Cc:&quot;, &quot;Bcc:&quot; addresses previously set via config.</source>
          <target state="translated">清除之前通过配置设置的 &quot;To:&quot;、&quot;Cc:&quot;、&quot;Bcc:&quot;地址列表。</target>
        </trans-unit>
        <trans-unit id="cf4a0e26c9f93f0530be9fa71dab1af1cbaa231f" translate="yes" xml:space="preserve">
          <source>Clears the previously read value of &lt;code&gt;sendemail.identity&lt;/code&gt; set via config, if any.</source>
          <target state="translated">清除通过配置设置的 &lt;code&gt;sendemail.identity&lt;/code&gt; 的先前读取的值（如果有）。</target>
        </trans-unit>
        <trans-unit id="90944cef36d3464ed0283d5129626cf4ab8fc85b" translate="yes" xml:space="preserve">
          <source>Click on New Mail.</source>
          <target state="translated">点击 &quot;新邮件&quot;。</target>
        </trans-unit>
        <trans-unit id="89585875df151078ae7b77d81e2bd1b067e7d065" translate="yes" xml:space="preserve">
          <source>Client spec</source>
          <target state="translated">客户规格</target>
        </trans-unit>
        <trans-unit id="55e7359e50be70477f290b070978067b2a01b4d1" translate="yes" xml:space="preserve">
          <source>Client specified as an option to all p4 commands, with &lt;code&gt;-c &amp;lt;client&amp;gt;&lt;/code&gt;, including the client spec.</source>
          <target state="translated">使用 &lt;code&gt;-c &amp;lt;client&amp;gt;&lt;/code&gt; （包括客户端规范）将客户端指定为所有p4命令的选项。</target>
        </trans-unit>
        <trans-unit id="80c2bc0ea4027c7a64da85db4dd1237d395876ca" translate="yes" xml:space="preserve">
          <source>Clients known to work</source>
          <target state="translated">已知工作的客户</target>
        </trans-unit>
        <trans-unit id="74d55b5e93bc1fa20e1ae7e006b74220ee6a2f8c" translate="yes" xml:space="preserve">
          <source>Clients may &lt;code&gt;not&lt;/code&gt; use other sha1 expressions, even if the end result is reachable. E.g., neither a relative commit like &lt;code&gt;master^&lt;/code&gt; nor a literal sha1 like &lt;code&gt;abcd1234&lt;/code&gt; is allowed, even if the result is reachable from the refs.</source>
          <target state="translated">即使最终结果可以达到，客户端也 &lt;code&gt;not&lt;/code&gt; 使用其他sha1表达式。例如，即使结果可以从 &lt;code&gt;abcd1234&lt;/code&gt; 也不允许像 &lt;code&gt;master^&lt;/code&gt; 这样的相对提交，也不像abcd1234这样的文字sha1 是允许的。</target>
        </trans-unit>
        <trans-unit id="5c33076e8c658be1dfe63e1df1ac676b47602d66" translate="yes" xml:space="preserve">
          <source>Clients may request a commit or tree that is pointed to directly by a ref. E.g., &lt;code&gt;git archive --remote=origin v1.0&lt;/code&gt;.</source>
          <target state="translated">客户端可以请求由引用直接指向的提交或树。例如， &lt;code&gt;git archive --remote=origin v1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbed12af7936ed3ad4075cea19b034f51ea55c2c" translate="yes" xml:space="preserve">
          <source>Clients may request a sub-tree within a commit or tree using the &lt;code&gt;ref:path&lt;/code&gt; syntax. E.g., &lt;code&gt;git archive --remote=origin v1.0:Documentation&lt;/code&gt;.</source>
          <target state="translated">客户端可以使用 &lt;code&gt;ref:path&lt;/code&gt; 语法在提交或树中请求子树。例如， &lt;code&gt;git archive --remote=origin v1.0:Documentation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9839e8d4aa3c14e4b54e191e51eb2179e4fdaa19" translate="yes" xml:space="preserve">
          <source>Clients should now be able to check out the project. Use the CVS &lt;code&gt;module&lt;/code&gt; name to indicate what Git &lt;code&gt;head&lt;/code&gt; you want to check out. This also sets the name of your newly checked-out directory, unless you tell it otherwise with &lt;code&gt;-d &amp;lt;dir_name&amp;gt;&lt;/code&gt;. For example, this checks out &lt;code&gt;master&lt;/code&gt; branch to the &lt;code&gt;project-master&lt;/code&gt; directory:</source>
          <target state="translated">客户现在应该可以签出该项目。使用CVS &lt;code&gt;module&lt;/code&gt; 名称来指示您要检出的Git &lt;code&gt;head&lt;/code&gt; 。这还将设置新签出目录的名称，除非您使用 &lt;code&gt;-d &amp;lt;dir_name&amp;gt;&lt;/code&gt; 另行指定。例如，这会将 &lt;code&gt;master&lt;/code&gt; 分支检出到 &lt;code&gt;project-master&lt;/code&gt; 目录：</target>
        </trans-unit>
        <trans-unit id="d8cdb573350de78596e4852bc9cacfc94e8d17ed" translate="yes" xml:space="preserve">
          <source>Clone</source>
          <target state="translated">Clone</target>
        </trans-unit>
        <trans-unit id="d69c0c434d503834765604d22b28037bee413bfc" translate="yes" xml:space="preserve">
          <source>Clone a repository into a new directory</source>
          <target state="translated">克隆一个版本库到一个新的目录。</target>
        </trans-unit>
        <trans-unit id="8b7342cb68e63a734e787beefc74dd4c8bf74d08" translate="yes" xml:space="preserve">
          <source>Clone a repository:</source>
          <target state="translated">克隆一个版本库。</target>
        </trans-unit>
        <trans-unit id="e3bdbcd4fc3a4b615a5be68aca4686a1e8d61dd3" translate="yes" xml:space="preserve">
          <source>Clone and sync variables</source>
          <target state="translated">克隆和同步变量</target>
        </trans-unit>
        <trans-unit id="fc5a57d2c10be47f020b40eb294f6e546edcb1fb" translate="yes" xml:space="preserve">
          <source>Clone from upstream while borrowing from an existing local directory:</source>
          <target state="translated">从上游克隆,同时借用现有的本地目录。</target>
        </trans-unit>
        <trans-unit id="31427bc4154831dc13e03739efd0e5c8ceee16ff" translate="yes" xml:space="preserve">
          <source>Clone from upstream:</source>
          <target state="translated">从上游克隆。</target>
        </trans-unit>
        <trans-unit id="40d0639c1781d7a9c100ef0a6d2c0dcfcc6b282c" translate="yes" xml:space="preserve">
          <source>Clone it with &lt;code&gt;git clone file:///path/to/repo&lt;/code&gt;. The clone will not have the removed objects. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;. (Note that cloning with a plain path just hardlinks everything!)</source>
          <target state="translated">用 &lt;code&gt;git clone file:///path/to/repo&lt;/code&gt; 克隆它。克隆将没有已删除的对象。参见&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;。（请注意，使用普通路径克隆只会硬链接所有内容！）</target>
        </trans-unit>
        <trans-unit id="25701c0360e9d04455f2222c02f2b66094990098" translate="yes" xml:space="preserve">
          <source>Clone only the history leading to the tip of a single branch, either specified by the &lt;code&gt;--branch&lt;/code&gt; option or the primary branch remote&amp;rsquo;s &lt;code&gt;HEAD&lt;/code&gt; points at. Further fetches into the resulting repository will only update the remote-tracking branch for the branch this option was used for the initial cloning. If the HEAD at the remote did not point at any branch when &lt;code&gt;--single-branch&lt;/code&gt; clone was made, no remote-tracking branch is created.</source>
          <target state="translated">仅克隆通向单个分支顶端的历史记录，该历史记录由 &lt;code&gt;--branch&lt;/code&gt; 选项指定，或者由主分支远程的 &lt;code&gt;HEAD&lt;/code&gt; 指向。进一步提取到生成的存储库中只会更新该选项用于初始克隆的分支的远程跟踪分支。如果进行 &lt;code&gt;--single-branch&lt;/code&gt; 克隆时，远程的HEAD没有指向任何分支，则不会创建远程跟踪分支。</target>
        </trans-unit>
        <trans-unit id="7a471e90dac3e294ddb7787043d7eb11c0e7a242" translate="yes" xml:space="preserve">
          <source>Clone options</source>
          <target state="translated">克隆选项</target>
        </trans-unit>
        <trans-unit id="0befa381e0a34bfc395f53162eefbad3dae21f70" translate="yes" xml:space="preserve">
          <source>Clone the upstream and work on it. Feed changes to upstream.</source>
          <target state="translated">克隆上游,并对其进行工作。向上游馈赠变化。</target>
        </trans-unit>
        <trans-unit id="4b6b25b2b84758722a0670042a124566ce1d193f" translate="yes" xml:space="preserve">
          <source>Clones a repository into a newly created directory, creates remote-tracking branches for each branch in the cloned repository (visible using &lt;code&gt;git branch --remotes&lt;/code&gt;), and creates and checks out an initial branch that is forked from the cloned repository&amp;rsquo;s currently active branch.</source>
          <target state="translated">将存储 &lt;code&gt;git branch --remotes&lt;/code&gt; 到新创建的目录中，为克隆的存储库中的每个分支创建远程跟踪分支（使用git branch --remotes可见），并创建并签出从克隆的存储库当前活动分支派生的初始分支。</target>
        </trans-unit>
        <trans-unit id="df1a2527d982b2181fc5936a0c039535ce1accdb" translate="yes" xml:space="preserve">
          <source>Cloning or syncing does not require a p4 client; file contents are collected using &lt;code&gt;p4 print&lt;/code&gt;.</source>
          <target state="translated">克隆或同步不需要p4客户端。使用 &lt;code&gt;p4 print&lt;/code&gt; 收集文件内容。</target>
        </trans-unit>
        <trans-unit id="53e412082749509777418e5cdc87503adeb4bf14" translate="yes" xml:space="preserve">
          <source>Collect and show committer identities instead of authors.</source>
          <target state="translated">收集并显示提交者的身份,而不是作者。</target>
        </trans-unit>
        <trans-unit id="752dedb02a973d0d43ace0dca55082bee051171e" translate="yes" xml:space="preserve">
          <source>Collect information for user to file a bug report</source>
          <target state="translated">收集用户信息以提交错误报告</target>
        </trans-unit>
        <trans-unit id="fccaafaced7e706bc2bd06241362e04977c0cd36" translate="yes" xml:space="preserve">
          <source>Colon-delimited list of refs or globs indicating which refs, in addition to the default from &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages. This overrides the &lt;code&gt;notes.displayRef&lt;/code&gt; setting.</source>
          <target state="translated">用冒号分隔的ref或glob列表，指示除了显示 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 消息时从 &lt;code&gt;core.notesRef&lt;/code&gt; 或GIT_NOTES_REF读取的默认引用之外，哪些引用。这将覆盖 &lt;code&gt;notes.displayRef&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="b13a61ccbe64b645a15179edff14e97b6ecd8c00" translate="yes" xml:space="preserve">
          <source>Color branches to highlight current, local, and remote-tracking branches. The value must be always (the default), never, or auto.</source>
          <target state="translated">用颜色来突出当前、本地和远程跟踪的分支。该值必须是始终(默认)、从不或自动。</target>
        </trans-unit>
        <trans-unit id="b15070a1530d4c810f05017f7f35501b365479b6" translate="yes" xml:space="preserve">
          <source>Color the status sign (one of these: &lt;code&gt;*&lt;/code&gt;&lt;code&gt;!&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;) of each commit corresponding to the branch it&amp;rsquo;s in. The value must be always (the default), never, or auto.</source>
          <target state="translated">为与该分支所在的分支对应的每个提交的状态标志（其中一个： &lt;code&gt;*&lt;/code&gt; &lt;code&gt;!&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; ）上色。该值必须始终为（默认），从不或自动。</target>
        </trans-unit>
        <trans-unit id="51d8265f4f18e755692a71f862affd712731021e" translate="yes" xml:space="preserve">
          <source>Colors may also be given as numbers between 0 and 255; these use ANSI 256-color mode (but note that not all terminals may support this). If your terminal supports it, you may also specify 24-bit RGB values as hex, like &lt;code&gt;#ff0ab3&lt;/code&gt;.</source>
          <target state="translated">颜色也可以指定为0到255之间的数字。它们使用ANSI 256色模式（但请注意，并非所有终端都可以支持此模式）。如果您的终端支持，您还可以将24位RGB值指定为十六进制，例如 &lt;code&gt;#ff0ab3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39ae0d23566f06a8646ef3abdd586851a9e465cd" translate="yes" xml:space="preserve">
          <source>Combined diff format</source>
          <target state="translated">组合差异格式</target>
        </trans-unit>
        <trans-unit id="5bb60f78b33e9a4f091db8f97f338043390512bd" translate="yes" xml:space="preserve">
          <source>Combining test suites, git bisect and other systems together</source>
          <target state="translated">将测试套件、git bisect和其他系统结合在一起。</target>
        </trans-unit>
        <trans-unit id="4a4a4bb517ec5013313be130afe65f9c77f0eaea" translate="yes" xml:space="preserve">
          <source>Coming from a system such as Perforce or Subversion this should be quite simple, as the fast-import mark can also be the Perforce changeset number or the Subversion revision number.</source>
          <target state="translated">来自Perforce或Subversion这样的系统,这应该很简单,因为快速导入标记也可以是Perforce的变更集号或Subversion的修订号。</target>
        </trans-unit>
        <trans-unit id="b894fab4f168cef475b1c68a083475614077b1e5" translate="yes" xml:space="preserve">
          <source>Coming up with the correct shell snippet to do the filtering you want is sometimes difficult unless you&amp;rsquo;re just doing a trivial modification such as deleting a couple files. Unfortunately, people often learn if the snippet is right or wrong by trying it out, but the rightness or wrongness can vary depending on special circumstances (spaces in filenames, non-ascii filenames, funny author names or emails, invalid timezones, presence of grafts or replace objects, etc.), meaning they may have to wait a long time, hit an error, then restart. The performance of git-filter-branch is so bad that this cycle is painful, reducing the time available to carefully re-check (to say nothing about what it does to the patience of the person doing the rewrite even if they do technically have more time available). This problem is extra compounded because errors from broken filters may not be shown for a long time and/or get lost in a sea of output. Even worse, broken filters often just result in silent incorrect rewrites.</source>
          <target state="translated">有时使用正确的shell代码片段进行所需的过滤有时会很困难，除非您只是进行了一些细微的修改（例如删除几个文件）。不幸的是，人们经常通过尝试来了解代码片段是对还是错，但是正确或错误可能会因特殊情况而异（文件名中的空格，非ASCII文件名，有趣的作者姓名或电子邮件，时区无效，存在嫁接）或替换对象等），这意味着它们可能需要等待很长时间，遇到错误，然后重新启动。 git-filter-branch的性能太差了，以至于这个循环很痛苦，从而减少了仔细检查的时间（更不用说它对重写者的耐心了，即使他们在技术上做了更多时间可用）。这个问题变得更加复杂，因为来自破碎的过滤器的错误可能不会长时间显示和/或在大量的输出中丢失。更糟糕的是，损坏的过滤器通常只会导致无声的错误重写。</target>
        </trans-unit>
        <trans-unit id="8fb52c1564722a1fe5f6cf4e3d44bce48182e716" translate="yes" xml:space="preserve">
          <source>Command Detail Messages</source>
          <target state="translated">命令详情信息</target>
        </trans-unit>
        <trans-unit id="f7e08456d089a047ccd465ae00e5bf2544bfdac7" translate="yes" xml:space="preserve">
          <source>Command Details</source>
          <target state="translated">命令详情</target>
        </trans-unit>
        <trans-unit id="84cf71d717103c00cc33f4f16f173970104ae46e" translate="yes" xml:space="preserve">
          <source>Command aliases for the &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; command wrapper - e.g. after defining &lt;code&gt;alias.last = cat-file commit HEAD&lt;/code&gt;, the invocation &lt;code&gt;git last&lt;/code&gt; is equivalent to &lt;code&gt;git cat-file commit HEAD&lt;/code&gt;. To avoid confusion and troubles with script usage, aliases that hide existing Git commands are ignored. Arguments are split by spaces, the usual shell quoting and escaping is supported. A quote pair or a backslash can be used to quote them.</source>
          <target state="translated">&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;命令包装程序的命令别名-例如，在定义 &lt;code&gt;alias.last = cat-file commit HEAD&lt;/code&gt; ，调用 &lt;code&gt;git last&lt;/code&gt; 与 &lt;code&gt;git cat-file commit HEAD&lt;/code&gt; 等效。为了避免混淆和脚本使用麻烦，将忽略隐藏现有Git命令的别名。参数由空格分隔，支持通常的shell引用和转义。可以使用引号对或反斜杠对它们进行引用。</target>
        </trans-unit>
        <trans-unit id="bb334d175dc8351e4e643438be75bf5083df9523" translate="yes" xml:space="preserve">
          <source>Command and arguments are separated by an unescaped space.</source>
          <target state="translated">命令和参数之间用一个不带空格的空间隔开。</target>
        </trans-unit>
        <trans-unit id="bd186454b9919f30925b251fcf7e4e52ca77972c" translate="yes" xml:space="preserve">
          <source>Command request</source>
          <target state="translated">命令请求</target>
        </trans-unit>
        <trans-unit id="fa701362a88f56992e33094194fa924ccdfa36dc" translate="yes" xml:space="preserve">
          <source>Command to be run each time gitk has to determine the revision range to show. The command is expected to print on its standard output a list of additional revisions to be shown, one per line. Use this instead of explicitly specifying a &lt;code&gt;&amp;lt;revision range&amp;gt;&lt;/code&gt; if the set of commits to show may vary between refreshes.</source>
          <target state="translated">每次gitk必须确定要显示的修订范围时都要运行的命令。预计该命令将在其标准输出上显示要显示的其他修订列表，每行一个。如果要显示的提交集在两次刷新之间可能有所不同，请使用此选项来代替显式指定 &lt;code&gt;&amp;lt;revision range&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d073f0ac32697a8093342645a8234491e985e6ff" translate="yes" xml:space="preserve">
          <source>Command used to setup a tunnel to the IMAP server through which commands will be piped instead of using a direct network connection to the server. Required when imap.host is not set.</source>
          <target state="translated">命令用于设置一个通往IMAP服务器的隧道,通过隧道传输命令,而不是使用直接的网络连接到服务器。当imap.host未设置时需要。</target>
        </trans-unit>
        <trans-unit id="5fbae08a3e549b8259aa734268f8fc50962c7173" translate="yes" xml:space="preserve">
          <source>Command-line interface conventions</source>
          <target state="translated">命令行界面约定</target>
        </trans-unit>
        <trans-unit id="45e5f3f72e961cb70134ba35f7a27a9620e515f7" translate="yes" xml:space="preserve">
          <source>Commands</source>
          <target state="translated">Commands</target>
        </trans-unit>
        <trans-unit id="5415f180d40029f0ddfc48b35f157e8ad10f48bc" translate="yes" xml:space="preserve">
          <source>Commands are given by the caller on the helper&amp;rsquo;s standard input, one per line.</source>
          <target state="translated">调用者在助手的标准输入上给出命令，每行一个。</target>
        </trans-unit>
        <trans-unit id="03880aa7f8436e082afca33e516cbcd9355d3554" translate="yes" xml:space="preserve">
          <source>Commands such as &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt; that let you edit messages by launching an editor use the value of this variable when it is set, and the environment variable &lt;code&gt;GIT_EDITOR&lt;/code&gt; is not set. See &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt;.</source>
          <target state="translated">允许您通过启动编辑器来编辑消息的命令（例如 &lt;code&gt;commit&lt;/code&gt; 和 &lt;code&gt;tag&lt;/code&gt; )使用该变量的值（在设置了该变量的 &lt;code&gt;GIT_EDITOR&lt;/code&gt; ），而未设置环境变量GIT_EDITOR。参见&lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0abcd0747bb8576b597002ab49f39285f1f4ef29" translate="yes" xml:space="preserve">
          <source>Commands such as &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt; that let you edit messages consider a line that begins with this character commented, and removes them after the editor returns (default &lt;code&gt;#&lt;/code&gt;).</source>
          <target state="translated">使您可以编辑消息的诸如 &lt;code&gt;commit&lt;/code&gt; 和 &lt;code&gt;tag&lt;/code&gt; 之类的命令，将以该字符注释的行开始，并在编辑器返回后将其删除（默认为 &lt;code&gt;#&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6030cf68b2071379f06ab06312828ccb10c46868" translate="yes" xml:space="preserve">
          <source>Commands that output paths (e.g. &lt;code&gt;ls-files&lt;/code&gt;, &lt;code&gt;diff&lt;/code&gt;), will quote &quot;unusual&quot; characters in the pathname by enclosing the pathname in double-quotes and escaping those characters with backslashes in the same way C escapes control characters (e.g. &lt;code&gt;\t&lt;/code&gt; for TAB, &lt;code&gt;\n&lt;/code&gt; for LF, &lt;code&gt;\\&lt;/code&gt; for backslash) or bytes with values larger than 0x80 (e.g. octal &lt;code&gt;\302\265&lt;/code&gt; for &quot;micro&quot; in UTF-8). If this variable is set to false, bytes higher than 0x80 are not considered &quot;unusual&quot; any more. Double-quotes, backslash and control characters are always escaped regardless of the setting of this variable. A simple space character is not considered &quot;unusual&quot;. Many commands can output pathnames completely verbatim using the &lt;code&gt;-z&lt;/code&gt; option. The default value is true.</source>
          <target state="translated">输出路径的命令（例如 &lt;code&gt;ls-files&lt;/code&gt; ， &lt;code&gt;diff&lt;/code&gt; ）将通过在路径名中用双引号引起来并在路径名中引用&amp;ldquo;不寻常的&amp;rdquo;字符，并以反斜杠对这些字符进行转义，就像C会转义控制字符一样（例如 &lt;code&gt;\t&lt;/code&gt; 为TAB） ， &lt;code&gt;\n&lt;/code&gt; 对于LF， &lt;code&gt;\\&lt;/code&gt; 对于反斜杠）或值大于0x80的字节（例如，在UTF-8中为&amp;ldquo; micro&amp;rdquo;的八进制 &lt;code&gt;\302\265&lt;/code&gt; ）。如果将此变量设置为false，则不再将大于0x80的字节视为&amp;ldquo;异常&amp;rdquo;。无论此变量的设置如何，双引号，反斜杠和控制字符始终会转义。简单的空格字符不被认为是&amp;ldquo;异常&amp;rdquo;。许多命令可以使用 &lt;code&gt;-z&lt;/code&gt; 选项。默认值是true。</target>
        </trans-unit>
        <trans-unit id="240a8b9ba4498383936942814599bad7b6fd9115" translate="yes" xml:space="preserve">
          <source>Commands that support the enhanced option parser accepts unique prefix of a long option as if it is fully spelled out, but use this with a caution. For example, &lt;code&gt;git commit --amen&lt;/code&gt; behaves as if you typed &lt;code&gt;git commit --amend&lt;/code&gt;, but that is true only until a later version of Git introduces another option that shares the same prefix, e.g. &lt;code&gt;git commit --amenity&lt;/code&gt; option.</source>
          <target state="translated">支持增强选项解析器的命令会接受长选项的唯一前缀，就好像它是完全拼写的一样，但请谨慎使用。例如， &lt;code&gt;git commit --amen&lt;/code&gt; 的行为就像您键入 &lt;code&gt;git commit --amend&lt;/code&gt; 一样，但这只有在更高版本的Git引入另一个共享相同前缀的选项时才是正确的，例如 &lt;code&gt;git commit --amenity&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="40539e4d461e31ee218fa661fb2b14e246e5b1ba" translate="yes" xml:space="preserve">
          <source>Commands that support the enhanced option parser allow you to aggregate short options. This means that you can for example use &lt;code&gt;git rm -rf&lt;/code&gt; or &lt;code&gt;git clean -fdx&lt;/code&gt;.</source>
          <target state="translated">支持增强的选项分析器的命令允许您聚合简短选项。这意味着您可以使用例如 &lt;code&gt;git rm -rf&lt;/code&gt; 或 &lt;code&gt;git clean -fdx&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3f5763bea669fa755ce44d52b210df9afaf62df" translate="yes" xml:space="preserve">
          <source>Commands which have the enhanced option parser activated all understand a couple of magic command-line options:</source>
          <target state="translated">激活了增强型选项解析器的命令都能理解几个神奇的命令行选项。</target>
        </trans-unit>
        <trans-unit id="1164e5e23a09019a23028b34e0716555534c7c84" translate="yes" xml:space="preserve">
          <source>Comment lines appearing within the &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; part of &lt;code&gt;data&lt;/code&gt; commands are always taken to be part of the body of the data and are therefore never ignored by fast-import. This makes it safe to import any file/message content whose lines might start with &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="translated">出现在 &lt;code&gt;data&lt;/code&gt; 命令 &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; 部分中的注释行始终被视为数据主体的一部分，因此，快速导入永远不会忽略它们。这样可以安全地导入任何以 &lt;code&gt;#&lt;/code&gt; 开头的文件/消息内容。</target>
        </trans-unit>
        <trans-unit id="a91a1b2d9c14de30d84e97a50ebe0d84ec870d0d" translate="yes" xml:space="preserve">
          <source>Commit Exclusions</source>
          <target state="translated">排除承诺</target>
        </trans-unit>
        <trans-unit id="d05672f731c8973c38856897c1597b273795a8b8" translate="yes" xml:space="preserve">
          <source>Commit Formatting</source>
          <target state="translated">提交格式化</target>
        </trans-unit>
        <trans-unit id="dd5ce850ad942688eb2a5bc300a25747c87232f5" translate="yes" xml:space="preserve">
          <source>Commit Limiting</source>
          <target state="translated">承诺限制</target>
        </trans-unit>
        <trans-unit id="b518afb06183e6dd261846ce6b7c3883dfb90753" translate="yes" xml:space="preserve">
          <source>Commit Object</source>
          <target state="translated">提交对象</target>
        </trans-unit>
        <trans-unit id="d0a18b5ae3a3d7dd2d18ac07312a3fb851663f8e" translate="yes" xml:space="preserve">
          <source>Commit Ordering</source>
          <target state="translated">委托加工</target>
        </trans-unit>
        <trans-unit id="56db2f16b9009b18c00586ca09141e3f326e2939" translate="yes" xml:space="preserve">
          <source>Commit Rewording</source>
          <target state="translated">承诺改写</target>
        </trans-unit>
        <trans-unit id="71e9094af761c78deb267d59e41cd349f42db60f" translate="yes" xml:space="preserve">
          <source>Commit all reference updates queued for the transaction, ending the transaction.</source>
          <target state="translated">提交所有为交易排队的参考更新,结束交易。</target>
        </trans-unit>
        <trans-unit id="cf42eef97d741d8fac1d744839ed812ca253ade6" translate="yes" xml:space="preserve">
          <source>Commit automatically if the patch applied cleanly. It will not commit if any hunks fail to apply or there were other problems.</source>
          <target state="translated">如果补丁应用得很干净,会自动提交。如果有任何hunks没有应用或有其他问题,它将不会提交。</target>
        </trans-unit>
        <trans-unit id="d6fc46793322e7555ef7eec902c3baf2d380d288" translate="yes" xml:space="preserve">
          <source>Commit each diff from the current branch directly to the SVN repository, and then rebase or reset (depending on whether or not there is a diff between SVN and head). This will create a revision in SVN for each commit in Git.</source>
          <target state="translated">将当前分支的每一个 diff 直接提交到 SVN 仓库,然后重设或重置(取决于 SVN 和 head 之间是否有 diff)。这将为 Git 的每一次提交在 SVN 中创建一个修订版。</target>
        </trans-unit>
        <trans-unit id="32d864cf4da09ae0ccb717144326eeb4d87e8ec8" translate="yes" xml:space="preserve">
          <source>Commit information</source>
          <target state="translated">承诺信息</target>
        </trans-unit>
        <trans-unit id="cdf751d893db0a24e80b369d44da2bfa908750cb" translate="yes" xml:space="preserve">
          <source>Commit log messages are typically encoded in UTF-8, but other extended ASCII encodings are also supported. This includes ISO-8859-x, CP125x and many others, but &lt;code&gt;not&lt;/code&gt; UTF-16/32, EBCDIC and CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.).</source>
          <target state="translated">提交日志消息通常以UTF-8编码，但也支持其他扩展ASCII编码。这包括ISO-8859-x，CP125x和许多其他文件，但 &lt;code&gt;not&lt;/code&gt; UTF-16 / 32，EBCDIC和CJK多字节编码（GBK，Shift-JIS，Big5，EUC-x，CP9xx等）。</target>
        </trans-unit>
        <trans-unit id="a8ef9cdaba51b8bab239b7175f652bb22d7bc77a" translate="yes" xml:space="preserve">
          <source>Commit messages (even if they are all UTF-8) by default become corrupted due to not being updated &amp;mdash; any references to other commit hashes in commit messages will now refer to no-longer-extant commits.</source>
          <target state="translated">默认情况下，提交消息（即使它们都是UTF-8）也会由于未更新而损坏-提交消息中对其他提交哈希的任何引用现在都将引用不再存在的提交。</target>
        </trans-unit>
        <trans-unit id="a0d43ade6a679ebd3be023e33c0ed655845a2385" translate="yes" xml:space="preserve">
          <source>Commit notes are blobs containing extra information about an object (usually information to supplement a commit&amp;rsquo;s message). These blobs are taken from notes refs. A notes ref is usually a branch which contains &quot;files&quot; whose paths are the object names for the objects they describe, with some directory separators included for performance reasons &lt;sup&gt;[&lt;a href=&quot;#_footnote_1&quot; id=&quot;_footnoteref_1&quot;&gt;1&lt;/a&gt;]&lt;/sup&gt;.</source>
          <target state="translated">提交注释是包含有关对象的额外信息（通常是用于补充提交消息的信息）的Blob。这些斑点来自注释参考。notes ref通常是一个分支，其中包含&amp;ldquo;文件&amp;rdquo;，其路径是它们描述的对象的对象名称，出于性能原因还包括一些目录分隔符&lt;sup&gt;[ &lt;a href=&quot;#_footnote_1&quot; id=&quot;_footnoteref_1&quot;&gt;1&lt;/a&gt; ]&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="217104e18a0c907f96ea2b24a19144c9ed0cdcc1" translate="yes" xml:space="preserve">
          <source>Commit notes are blobs containing extra information about an object (usually information to supplement a commit&amp;rsquo;s message). These blobs are taken from notes refs. A notes ref is usually a branch which contains &quot;files&quot; whose paths are the object names for the objects they describe, with some directory separators included for performance reasons &lt;sup&gt;[&lt;a href=&quot;#_footnotedef_1&quot; id=&quot;_footnoteref_1&quot;&gt;1&lt;/a&gt;]&lt;/sup&gt;.</source>
          <target state="translated">提交注释是包含有关对象的额外信息（通常是用于补充提交消息的信息）的Blob。这些斑点来自注释参考。注释ref通常是一个分支，其中包含&amp;ldquo;文件&amp;rdquo;，其路径是它们描述的对象的对象名称，出于性能原因&lt;sup&gt;[ &lt;a href=&quot;#_footnotedef_1&quot; id=&quot;_footnoteref_1&quot;&gt;1&lt;/a&gt; ]&lt;/sup&gt;包括一些目录分隔符。</target>
        </trans-unit>
        <trans-unit id="340dec00f8e27e530fc4429d17a96a5706fe14b1" translate="yes" xml:space="preserve">
          <source>Commit objects created with the above setting record the value of &lt;code&gt;i18n.commitEncoding&lt;/code&gt; in its &lt;code&gt;encoding&lt;/code&gt; header. This is to help other people who look at them later. Lack of this header implies that the commit log message is encoded in UTF-8.</source>
          <target state="translated">使用上述设置创建的提交对象将 &lt;code&gt;i18n.commitEncoding&lt;/code&gt; 的值记录在其 &lt;code&gt;encoding&lt;/code&gt; 头中。这是为了帮助以后查看它们的其他人。缺少此标头意味着提交日志消息以UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="3e636bd205abbae562ddd3b2c8e7ad0ad71d57b9" translate="yes" xml:space="preserve">
          <source>Commit the now-current index with whatever commit message is appropriate now.</source>
          <target state="translated">将现在的索引提交给任何适合现在的提交信息。</target>
        </trans-unit>
        <trans-unit id="0d30e12bd35c1bbb537786b722f71f7710203505" translate="yes" xml:space="preserve">
          <source>Commit the superproject:</source>
          <target state="translated">承诺超级项目。</target>
        </trans-unit>
        <trans-unit id="c2ba6e6758d4e077ba6384de032e88b129ac1452" translate="yes" xml:space="preserve">
          <source>Commit to end at (defaults to HEAD). This names the commit at the tip of the history you are asking to be pulled.</source>
          <target state="translated">结束的提交(默认为 HEAD)。这是您要求拉取的历史记录顶端的提交的名称。</target>
        </trans-unit>
        <trans-unit id="5d83b220e2a717b4332302a14b01dfcf38b82250" translate="yes" xml:space="preserve">
          <source>Commit to start at. This names a commit that is already in the upstream history.</source>
          <target state="translated">从哪个提交开始。命名一个已经在上游历史中的提交。</target>
        </trans-unit>
        <trans-unit id="58a3fb0fa9151eaf5eb44aad642ac139bbd8d0a3" translate="yes" xml:space="preserve">
          <source>Commit to this SVN URL (the full path). This is intended to allow existing &lt;code&gt;git svn&lt;/code&gt; repositories created with one transport method (e.g. &lt;code&gt;svn://&lt;/code&gt; or &lt;code&gt;http://&lt;/code&gt; for anonymous read) to be reused if a user is later given access to an alternate transport method (e.g. &lt;code&gt;svn+ssh://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;) for commit.</source>
          <target state="translated">提交到此SVN URL（完整路径）。这是为了允许在以后允许用户访问另一种传输方法（例如 &lt;code&gt;svn+ssh://&lt;/code&gt; ）的情况下，重用使用一种传输方法（例如 &lt;code&gt;svn://&lt;/code&gt; 或 &lt;code&gt;http://&lt;/code&gt; 进行匿名读取）创建的现有 &lt;code&gt;git svn&lt;/code&gt; 存储库。 //或 &lt;code&gt;https://&lt;/code&gt; ）进行提交。</target>
        </trans-unit>
        <trans-unit id="5d95f392f7b327e450a5cff3a7d0d778dd7bb17a" translate="yes" xml:space="preserve">
          <source>Commit-ish object names to describe. Defaults to HEAD if omitted.</source>
          <target state="translated">要描述的提交类对象名称。如果省略,默认为 HEAD。</target>
        </trans-unit>
        <trans-unit id="806d7e617bf08278640b3918df6eb314e00c91ba" translate="yes" xml:space="preserve">
          <source>Commits A and B would no longer belong to a branch with a symbolic name, and so would be unreachable. As such, these commits would be removed by a &lt;code&gt;git gc&lt;/code&gt; command on the origin repository.</source>
          <target state="translated">提交A和B将不再属于具有符号名称的分支，因此将不可访问。这样，这些提交将通过源存储库上的 &lt;code&gt;git gc&lt;/code&gt; 命令删除。</target>
        </trans-unit>
        <trans-unit id="cd34e82ef88e8c2479cf92c1c7e01e1f9402380d" translate="yes" xml:space="preserve">
          <source>Commits are included if they are not TREESAME to any parent (though this can be changed, see &lt;code&gt;--sparse&lt;/code&gt; below). If the commit was a merge, and it was TREESAME to one parent, follow only that parent. (Even if there are several TREESAME parents, follow only one of them.) Otherwise, follow all parents.</source>
          <target state="translated">如果不是对任何父级的TREESAME，则包含提交（尽管可以更改，请参见下面的 &lt;code&gt;--sparse&lt;/code&gt; ）。如果提交是合并，并且对一个父对象是TREESAME，则仅遵循该父对象。（即使有几个TREESAME父母，也只能跟随其中一个。）否则，请跟随所有父母。</target>
        </trans-unit>
        <trans-unit id="639abedb72340eed90c014868e55014692d325d7" translate="yes" xml:space="preserve">
          <source>Commits modifying the given &amp;lt;paths&amp;gt; are selected.</source>
          <target state="translated">选择修改给定&amp;lt;paths&amp;gt;的提交。</target>
        </trans-unit>
        <trans-unit id="e092c6ca44bf3dcd26785c6425ee818e873ea1fd" translate="yes" xml:space="preserve">
          <source>Commits that are referred by some branch or tag are selected.</source>
          <target state="translated">被某个分支或标签引用的承诺被选中。</target>
        </trans-unit>
        <trans-unit id="6d094219b19302ca10342a1d1eec0568558c2bd8" translate="yes" xml:space="preserve">
          <source>Commits that are walked are included if they are not TREESAME to any parent.</source>
          <target state="translated">走过的承诺,如果对任何一个家长来说都不是TREESAME,那么就包括在内。</target>
        </trans-unit>
        <trans-unit id="ef7e9aac4d19855b4ef3c8efc0ae0f7c81184b39" translate="yes" xml:space="preserve">
          <source>Commits the diff of two tree-ish arguments from the command-line. This command does not rely on being inside a &lt;code&gt;git svn
init&lt;/code&gt;-ed repository. This command takes three arguments, (a) the original tree to diff against, (b) the new tree result, (c) the URL of the target Subversion repository. The final argument (URL) may be omitted if you are working from a &lt;code&gt;git svn&lt;/code&gt;-aware repository (that has been &lt;code&gt;init&lt;/code&gt;-ed with &lt;code&gt;git svn&lt;/code&gt;). The -r&amp;lt;revision&amp;gt; option is required for this.</source>
          <target state="translated">从命令行提交两个树状参数的差异。此命令不依赖于位于 &lt;code&gt;git svn init&lt;/code&gt; 存储库中。此命令采用三个参数，（a）要与之相对的原始树，（b）新的树结果，（c）目标Subversion存储库的URL。如果您正在 &lt;code&gt;git svn&lt;/code&gt; -aware仓库（已使用 &lt;code&gt;git svn&lt;/code&gt; &lt;code&gt;init&lt;/code&gt; -ed ）中工作，则可以省略最后一个参数（URL ）。为此，需要-r &amp;lt;revision&amp;gt;选项。</target>
        </trans-unit>
        <trans-unit id="958e7e955e68b84d191b41f660f0af907a1a26e7" translate="yes" xml:space="preserve">
          <source>Commits to cherry-pick. For a more complete list of ways to spell commits, see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;. Sets of commits can be passed but no traversal is done by default, as if the &lt;code&gt;--no-walk&lt;/code&gt; option was specified, see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;. Note that specifying a range will feed all &amp;lt;commit&amp;gt;&amp;hellip;​ arguments to a single revision walk (see a later example that uses &lt;code&gt;maint master..next&lt;/code&gt;).</source>
          <target state="translated">致力于摘樱桃。有关拼写提交方式的更完整列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;。可以传递一组提交，但默认情况下不会进行遍历，就像指定了 &lt;code&gt;--no-walk&lt;/code&gt; 选项一样，请参见&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;。请注意，指定范围会将所有&amp;lt;commit&amp;gt; ...参数提供给一个修订版本（请参阅后面的使用 &lt;code&gt;maint master..next&lt;/code&gt; 的示例）。</target>
        </trans-unit>
        <trans-unit id="dbab89c03eabe421a0f756d1774250a10ff8a483" translate="yes" xml:space="preserve">
          <source>Commits to revert. For a more complete list of ways to spell commit names, see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;. Sets of commits can also be given but no traversal is done by default, see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; and its &lt;code&gt;--no-walk&lt;/code&gt; option.</source>
          <target state="translated">承诺还原。有关拼写提交名称的方法的完整列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;。也可以给出一组提交，但是默认情况下不进行遍历，请参见&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;及其 &lt;code&gt;--no-walk&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="49656a8c34bd2a56ea7b1c4c19ee41def8e375e6" translate="yes" xml:space="preserve">
          <source>Commits, usually other branch heads, to merge into our branch. Specifying more than one commit will create a merge with more than two parents (affectionately called an Octopus merge).</source>
          <target state="translated">提交,通常是其他分支的头,要合并到我们的分支。指定一个以上的提交,将创建一个有两个以上父分支的合并(亲切地称为章鱼合并)。</target>
        </trans-unit>
        <trans-unit id="c73e3ca2125dd6b66724a23fd1d9404dae439c7b" translate="yes" xml:space="preserve">
          <source>Committing everything directly on the integration branches leads to many problems: Bad commits cannot be undone, so they must be reverted one by one, which creates confusing histories and further error potential when you forget to revert part of a group of changes. Working in parallel mixes up the changes, creating further confusion.</source>
          <target state="translated">直接在集成分支上提交所有内容会导致很多问题。坏的提交不能被撤销,所以必须一个一个地还原,这就造成了混乱的历史,而且当你忘记还原一组变化的一部分时,还可能出现错误。并行工作会把变更混在一起,造成进一步的混乱。</target>
        </trans-unit>
        <trans-unit id="fe3255bd451d3471e881939414843a91c1360c6e" translate="yes" xml:space="preserve">
          <source>Committing git state</source>
          <target state="translated">提交git状态</target>
        </trans-unit>
        <trans-unit id="429882fbdbb00bcd134816d89830eb4242096534" translate="yes" xml:space="preserve">
          <source>Common Git shell script setup code</source>
          <target state="translated">常见的Git shell脚本设置代码</target>
        </trans-unit>
        <trans-unit id="8a9ecfa5494a6336bbbe04b6056604a3b2505855" translate="yes" xml:space="preserve">
          <source>Common Key/Value Pairs</source>
          <target state="translated">常见的键/值对</target>
        </trans-unit>
        <trans-unit id="1af5706ae88f10b9ead3cfff1d78f59757380eca" translate="yes" xml:space="preserve">
          <source>Common diff options</source>
          <target state="translated">常见的差异选项</target>
        </trans-unit>
        <trans-unit id="edbc971d96420cb012b0de74d40a7c8b6d1a73dd" translate="yes" xml:space="preserve">
          <source>Common issues</source>
          <target state="translated">共同问题</target>
        </trans-unit>
        <trans-unit id="17cfc9441a242e68c384e9b5b8cf9a0e4a24fffd" translate="yes" xml:space="preserve">
          <source>Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">支持 &lt;code&gt;k&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; 或 &lt;code&gt;g&lt;/code&gt; 的通用单位后缀。</target>
        </trans-unit>
        <trans-unit id="2d454855d2445672da925706dc840080c654c187" translate="yes" xml:space="preserve">
          <source>Compare a tree to the working tree or index</source>
          <target state="translated">将一棵树与工作树或索引进行比较</target>
        </trans-unit>
        <trans-unit id="b052eee7a70522f76de64441f0532b8b978732a8" translate="yes" xml:space="preserve">
          <source>Compare the commits specified by the two ranges, where &lt;code&gt;&amp;lt;range1&amp;gt;&lt;/code&gt; is considered an older version of &lt;code&gt;&amp;lt;range2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">比较两个范围指定的提交，其中 &lt;code&gt;&amp;lt;range1&amp;gt;&lt;/code&gt; 被认为是 &lt;code&gt;&amp;lt;range2&amp;gt;&lt;/code&gt; 的较早版本。</target>
        </trans-unit>
        <trans-unit id="cbedfc6f6fea6e33a27f5f1a33053dbff1a37614" translate="yes" xml:space="preserve">
          <source>Compare the version before the last commit and the last commit.</source>
          <target state="translated">比较上次提交前的版本和上次提交的版本。</target>
        </trans-unit>
        <trans-unit id="108964900757319250c09d41bf5206fee17fbebf" translate="yes" xml:space="preserve">
          <source>Compare the working tree with the &quot;base&quot; version (stage #1), &quot;our branch&quot; (stage #2) or &quot;their branch&quot; (stage #3). The index contains these stages only for unmerged entries i.e. while resolving conflicts. See &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt; section &quot;3-Way Merge&quot; for detailed information.</source>
          <target state="translated">将工作树与&amp;ldquo;基本&amp;rdquo;版本（阶段1），&amp;ldquo;我们的分支&amp;rdquo;（阶段2）或&amp;ldquo;其分支&amp;rdquo;（阶段3）进行比较。索引仅包含未合并条目的这些阶段，即解决冲突时。有关详细信息，请参见&lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt;部分&amp;ldquo; 3-Way Merge&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="417383ec38892ec59642ec5eded68ccdbddd54d0" translate="yes" xml:space="preserve">
          <source>Compare to &lt;code&gt;--full-history&lt;/code&gt; without rewriting above. Note that &lt;code&gt;E&lt;/code&gt; was pruned away because it is TREESAME, but the parent list of P was rewritten to contain &lt;code&gt;E&lt;/code&gt;'s parent &lt;code&gt;I&lt;/code&gt;. The same happened for &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt;, and &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;--full-history&lt;/code&gt; 比较，而无需在上面重写。需要注意的是 &lt;code&gt;E&lt;/code&gt; 被修剪掉，因为它是TREESAME，但P的父列表被改写为包含 &lt;code&gt;E&lt;/code&gt; 的父母 &lt;code&gt;I&lt;/code&gt; 。 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt; 以及 &lt;code&gt;X&lt;/code&gt; ， &lt;code&gt;Y&lt;/code&gt; 和 &lt;code&gt;Q&lt;/code&gt; 发生相同的情况。</target>
        </trans-unit>
        <trans-unit id="4186f0f14c1670feb8e3a98bffba021e85440c5e" translate="yes" xml:space="preserve">
          <source>Compare two commit ranges (e.g. two versions of a branch)</source>
          <target state="translated">比较两个提交范围(例如一个分支的两个版本)。</target>
        </trans-unit>
        <trans-unit id="efcf6f2f0a57938476e9e49afce7ef20662e5045" translate="yes" xml:space="preserve">
          <source>Compares files in the working tree and the index</source>
          <target state="translated">比较工作树和索引中的文件。</target>
        </trans-unit>
        <trans-unit id="b51a5025d034c563fd7e4cf2f1781edb403c8a61" translate="yes" xml:space="preserve">
          <source>Compares the content and mode of blobs found via two tree objects</source>
          <target state="translated">比较通过两个树状对象找到的blobs的内容和模式。</target>
        </trans-unit>
        <trans-unit id="4bed9c3374f6538cd59dc69ff688ff3c6921c3b0" translate="yes" xml:space="preserve">
          <source>Compares the content and mode of the blobs found in a tree object with the corresponding tracked files in the working tree, or with the corresponding paths in the index. When &amp;lt;path&amp;gt; arguments are present, compares only paths matching those patterns. Otherwise all tracked files are compared.</source>
          <target state="translated">将在树对象中找到的斑点的内容和模式与工作树中的相应跟踪文件或索引中的相应路径进行比较。如果存在&amp;lt;path&amp;gt;参数，则仅比较与那些模式匹配的路径。否则，将比较所有跟踪的文件。</target>
        </trans-unit>
        <trans-unit id="37c34b145e3b8ab67ff7b61ff3d11d3a3ac26e63" translate="yes" xml:space="preserve">
          <source>Compares the content and mode of the blobs found via two tree objects.</source>
          <target state="translated">比较通过两个树对象找到的 blobs 的内容和模式。</target>
        </trans-unit>
        <trans-unit id="7bbeb5d1d5d86904df9d33155d8ac31a0ac700db" translate="yes" xml:space="preserve">
          <source>Compares the files in the working tree and the index. When paths are specified, compares only those named paths. Otherwise all entries in the index are compared. The output format is the same as for &lt;code&gt;git diff-index&lt;/code&gt; and &lt;code&gt;git diff-tree&lt;/code&gt;.</source>
          <target state="translated">比较工作树中的文件和索引。指定路径后，仅比较那些已命名的路径。否则，将比较索引中的所有条目。输出格式与 &lt;code&gt;git diff-index&lt;/code&gt; 和 &lt;code&gt;git diff-tree&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f362db0c69868c1d491d62f5976e73dedfebf2ca" translate="yes" xml:space="preserve">
          <source>Comparing blobs or trees that have been replaced with those that replace them will not work properly. And using &lt;code&gt;git reset --hard&lt;/code&gt; to go back to a replaced commit will move the branch to the replacement commit instead of the replaced commit.</source>
          <target state="translated">将已替换的Blob或树与替换后的Blob或树进行比较无法正常工作。并且使用 &lt;code&gt;git reset --hard&lt;/code&gt; 返回到替换的提交会将分支转移到替换的提交而不是替换的提交。</target>
        </trans-unit>
        <trans-unit id="e0150129e57bff1f18c9fdecdc5f6497b9177eb2" translate="yes" xml:space="preserve">
          <source>Comparing branches</source>
          <target state="translated">比较分支机构</target>
        </trans-unit>
        <trans-unit id="275ba455480c0eb203a002756ce88295e425384f" translate="yes" xml:space="preserve">
          <source>Comparing with arbitrary commits</source>
          <target state="translated">与任意提交比较</target>
        </trans-unit>
        <trans-unit id="a5fe2fffc7c971eb7adbd101285b86b784af988e" translate="yes" xml:space="preserve">
          <source>Compiler-specific info string</source>
          <target state="translated">编译器专用信息字符串</target>
        </trans-unit>
        <trans-unit id="0623cdc962e5b3ec3734b834b479126f0b30d78b" translate="yes" xml:space="preserve">
          <source>Complete list of all commands</source>
          <target state="translated">所有命令的完整列表</target>
        </trans-unit>
        <trans-unit id="09a81cc081fc6614431d0059db9771c7f435cba4" translate="yes" xml:space="preserve">
          <source>Components which are missing from the URL (e.g., there is no username in the example above) will be left unset.</source>
          <target state="translated">URL中缺少的组件(例如上面的例子中没有用户名)将不被设置。</target>
        </trans-unit>
        <trans-unit id="678bc9ada07c728ccee1f48de02cb28152653f42" translate="yes" xml:space="preserve">
          <source>Composing</source>
          <target state="translated">Composing</target>
        </trans-unit>
        <trans-unit id="3a4b462b90ad947c014f566102a2e5a0dd92671e" translate="yes" xml:space="preserve">
          <source>Comprehensive reference documentation is available through the man pages, or &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; command. For example, for the command &lt;code&gt;git clone &amp;lt;repo&amp;gt;&lt;/code&gt;, you can either use:</source>
          <target state="translated">完整的参考文档可通过手册页或&lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt;命令获得。例如，对于命令 &lt;code&gt;git clone &amp;lt;repo&amp;gt;&lt;/code&gt; ，您可以使用：</target>
        </trans-unit>
        <trans-unit id="90ae7930698f6a9514e277afc75b1efe24fb78ff" translate="yes" xml:space="preserve">
          <source>Compress $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log files and remove $GIT_DIR/svn/&amp;lt;refname&amp;gt;/index files.</source>
          <target state="translated">压缩$ GIT_DIR / svn / &amp;lt;refname&amp;gt; /unhandled.log文件，然后删除$ GIT_DIR / svn / &amp;lt;refname&amp;gt; / index文件。</target>
        </trans-unit>
        <trans-unit id="af5758a107c963e9444cff5454d146835b9b660b" translate="yes" xml:space="preserve">
          <source>Compute object ID and optionally creates a blob from a file</source>
          <target state="translated">计算对象ID,并可选择从文件中创建一个blob。</target>
        </trans-unit>
        <trans-unit id="01c4a7d17645c800690175029629fd7aeb958298" translate="yes" xml:space="preserve">
          <source>Compute the best common ancestors of all supplied commits, in preparation for an n-way merge. This mimics the behavior of &lt;code&gt;git show-branch --merge-base&lt;/code&gt;.</source>
          <target state="translated">计算所有提供的提交中最好的共同祖先，以准备进行n次合并。这模仿了 &lt;code&gt;git show-branch --merge-base&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="9bde35c0f2dc15b67baddfc39466c5eba5799786" translate="yes" xml:space="preserve">
          <source>Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.</source>
          <target state="translated">通过计算从源文件中删除或添加到目标文件中的行数来计算dirstat的数量。这忽略了文件中纯代码的移动量。换句话说,重新安排文件中的行数不会像其他变化那样被计算。这是没有参数时的默认行为。</target>
        </trans-unit>
        <trans-unit id="d5135b971c817889635eeca2e7a1431f33e06f37" translate="yes" xml:space="preserve">
          <source>Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest &lt;code&gt;--dirstat&lt;/code&gt; behavior, since it does not have to look at the file contents at all.</source>
          <target state="translated">通过计算更改的文件数来计算目录统计数。每个更改的文件在dirstat分析中均相等计数。这是在计算上最便宜的 &lt;code&gt;--dirstat&lt;/code&gt; 行为，因为它根本不必查看文件内容。</target>
        </trans-unit>
        <trans-unit id="3058cd552896436a63e7fe6f202c943042969930" translate="yes" xml:space="preserve">
          <source>Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive &lt;code&gt;--dirstat&lt;/code&gt; behavior than the &lt;code&gt;changes&lt;/code&gt; behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other &lt;code&gt;--*stat&lt;/code&gt; options.</source>
          <target state="translated">通过执行常规的基于行的差异分析，并计算已删除/添加的行数，计算目录统计号。（对于二进制文件，请改为计算64字节的块，因为二进制文件没有自然的行概念）。与 &lt;code&gt;changes&lt;/code&gt; 行为相比，这是更昂贵的 &lt;code&gt;--dirstat&lt;/code&gt; 行为，但是它确实将文件中重新排列的行数与其他更改一样多。结果输出与您从其他 &lt;code&gt;--*stat&lt;/code&gt; 选项获得的输出一致。</target>
        </trans-unit>
        <trans-unit id="6a0b0a16b974bf1fed36c439dfbdefde29d32d7c" translate="yes" xml:space="preserve">
          <source>Compute unique ID for a patch</source>
          <target state="translated">计算补丁的唯一ID</target>
        </trans-unit>
        <trans-unit id="8998103614864fe1630f3c6a0063c614dbc4eadb" translate="yes" xml:space="preserve">
          <source>Computes the object ID value for an object with specified type with the contents of the named file (which can be outside of the work tree), and optionally writes the resulting object into the object database. Reports its object ID to its standard output. When &amp;lt;type&amp;gt; is not specified, it defaults to &quot;blob&quot;.</source>
          <target state="translated">使用命名文件的内容（可以在工作树之外）计算具有指定类型的对象的对象ID值，并可以选择将结果对象写入对象数据库。将其对象ID报告给其标准输出。如果未指定&amp;lt;type&amp;gt;，则默认为&amp;ldquo; blob&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="937949a3d933696c9d4185384073018afe774033" translate="yes" xml:space="preserve">
          <source>Concatenates the contents of said Makefiles in the head of the branch &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">将所述Makefile的内容连接到分支 &lt;code&gt;master&lt;/code&gt; 的头部。</target>
        </trans-unit>
        <trans-unit id="7d484eb61cfd5469110c2312d1ec91512fe53e6a" translate="yes" xml:space="preserve">
          <source>Conceptually there are only four object types: commit, tree, tag and blob. However to save space, an object could be stored as a &quot;delta&quot; of another &quot;base&quot; object. These representations are assigned new types ofs-delta and ref-delta, which is only valid in a pack file.</source>
          <target state="translated">从概念上讲,只有四种对象类型:commit、tree、tag和blob,但为了节省空间,一个对象可以作为另一个 &quot;基础 &quot;对象的 &quot;delta &quot;存储。然而为了节省空间,一个对象可以被存储为另一个 &quot;基础 &quot;对象的 &quot;delta&quot;。这些表示方式被分配了新的类型ofs-delta和ref-delta,这只在pack文件中有效。</target>
        </trans-unit>
        <trans-unit id="f9ce6c77a92950f557622abcc328a5c52bc5ce16" translate="yes" xml:space="preserve">
          <source>Conceptually, &lt;code&gt;git write-tree&lt;/code&gt; sync()s the current index contents into a set of tree files. In order to have that match what is actually in your directory right now, you need to have done a &lt;code&gt;git update-index&lt;/code&gt; phase before you did the &lt;code&gt;git write-tree&lt;/code&gt;.</source>
          <target state="translated">从概念上讲， &lt;code&gt;git write-tree&lt;/code&gt; sync（）将当前索引内容放入一组树文件中。为了与当前目录中的实际内容相匹配，您需要先执行 &lt;code&gt;git update-index&lt;/code&gt; 阶段，然后再执行 &lt;code&gt;git write-tree&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ca3e3f6198d8db66027f645ef57e4ac30e9a37f" translate="yes" xml:space="preserve">
          <source>Conceptually, the feature enters at an unstable branch (usually &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;pu&lt;/code&gt;), and &quot;graduates&quot; to &lt;code&gt;master&lt;/code&gt; for the next release once it is considered stable enough.</source>
          <target state="translated">从概念上讲，该功能会进入不稳定的分支（通常为 &lt;code&gt;next&lt;/code&gt; 或 &lt;code&gt;pu&lt;/code&gt; ），一旦认为足够稳定，&amp;ldquo;毕业生&amp;rdquo;即可 &lt;code&gt;master&lt;/code&gt; 下一个版本。</target>
        </trans-unit>
        <trans-unit id="f6ef470943762cee844729c89f18b4378eb7782a" translate="yes" xml:space="preserve">
          <source>Conceptually, the feature enters at an unstable branch (usually &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;seen&lt;/code&gt;), and &quot;graduates&quot; to &lt;code&gt;master&lt;/code&gt; for the next release once it is considered stable enough.</source>
          <target state="translated">从概念上讲，该功能会进入不稳定的分支（通常是 &lt;code&gt;next&lt;/code&gt; 或 &lt;code&gt;seen&lt;/code&gt; ），一旦被认为足够稳定，&amp;ldquo;毕业生&amp;rdquo;便可以 &lt;code&gt;master&lt;/code&gt; 下一个版本。</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="c144db8f4732a9347031a1b40f149e52d91f565f" translate="yes" xml:space="preserve">
          <source>Concrete example</source>
          <target state="translated">具体例子</target>
        </trans-unit>
        <trans-unit id="1805d25f90c97785232c09de6be3d92c9bae4482" translate="yes" xml:space="preserve">
          <source>Conditional includes</source>
          <target state="translated">条件包括</target>
        </trans-unit>
        <trans-unit id="1eca678ae2103e84056e13fabe651ada3207805a" translate="yes" xml:space="preserve">
          <source>Cone pattern set</source>
          <target state="translated">锥形图案组</target>
        </trans-unit>
        <trans-unit id="eb7272ff2c451e4d56ff0b5035c89e6773552a2b" translate="yes" xml:space="preserve">
          <source>Config file-only options</source>
          <target state="translated">只配置文件选项</target>
        </trans-unit>
        <trans-unit id="422fb4b2c323c56fc618406ee76b1fefb87edd1b" translate="yes" xml:space="preserve">
          <source>Config variables</source>
          <target state="translated">配置变量</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="acdba8395423767de730ee1b75436df3a0ebc87e" translate="yes" xml:space="preserve">
          <source>Configuration file</source>
          <target state="translated">配置文件</target>
        </trans-unit>
        <trans-unit id="70c34b77eccd45b690bac76f834e5695507ca571" translate="yes" xml:space="preserve">
          <source>Configuration mechanism</source>
          <target state="translated">配置机制</target>
        </trans-unit>
        <trans-unit id="f4d40d6c54ed064cd5675e2b020be36dc38807c6" translate="yes" xml:space="preserve">
          <source>Configuration options</source>
          <target state="translated">配置选项</target>
        </trans-unit>
        <trans-unit id="38b23d1375544f4a68ea9228188041f47459e054" translate="yes" xml:space="preserve">
          <source>Configuration variables</source>
          <target state="translated">配置变量</target>
        </trans-unit>
        <trans-unit id="8a66ea31ab3d6b079e67d729ad34365bb857146f" translate="yes" xml:space="preserve">
          <source>Configure a &quot;tar.xz&quot; format for making LZMA-compressed tarfiles. You can use it specifying &lt;code&gt;--format=tar.xz&lt;/code&gt;, or by creating an output file like &lt;code&gt;-o foo.tar.xz&lt;/code&gt;.</source>
          <target state="translated">配置&amp;ldquo; tar.xz&amp;rdquo;格式以制作LZMA压缩的tarfile。您可以通过指定 &lt;code&gt;--format=tar.xz&lt;/code&gt; 或通过创建输出文件（如 &lt;code&gt;-o foo.tar.xz&lt;/code&gt; )来使用它。</target>
        </trans-unit>
        <trans-unit id="f6a6815a7f24dfffdb1d929dd323aaec05a9ab47" translate="yes" xml:space="preserve">
          <source>Configure a &lt;code&gt;fix&lt;/code&gt; trailer with a key that contains a &lt;code&gt;#&lt;/code&gt; and no space after this character, and show how it works:</source>
          <target state="translated">使用包含 &lt;code&gt;#&lt;/code&gt; 且该字符后没有空格的键来配置 &lt;code&gt;fix&lt;/code&gt; 预告片，并显示其工作方式：</target>
        </trans-unit>
        <trans-unit id="ce90c0bc932e5f1df9b68ee7ec6c0da58d747ea5" translate="yes" xml:space="preserve">
          <source>Configure a &lt;code&gt;see&lt;/code&gt; trailer with a command to show the subject of a commit that is related, and show how it works:</source>
          <target state="translated">使用命令配置 &lt;code&gt;see&lt;/code&gt; 拖车，以显示相关提交的主题，并显示其工作方式：</target>
        </trans-unit>
        <trans-unit id="c9ccaafdcef74174cf7734bdb6a6d7caabe83888" translate="yes" xml:space="preserve">
          <source>Configure a &lt;code&gt;sign&lt;/code&gt; trailer with a &lt;code&gt;Signed-off-by&lt;/code&gt; key, and then add two of these trailers to a message:</source>
          <target state="translated">配置 &lt;code&gt;sign&lt;/code&gt; 拖车带 &lt;code&gt;Signed-off-by&lt;/code&gt; 键，然后添加两个这些拖车的消息：</target>
        </trans-unit>
        <trans-unit id="e0f5abc21cdfc10087712a4df06b45d6f1ed9b35" translate="yes" xml:space="preserve">
          <source>Configure a &lt;code&gt;sign&lt;/code&gt; trailer with a command to automatically add a 'Signed-off-by: ' with the author information only if there is no 'Signed-off-by: ' already, and show how it works:</source>
          <target state="translated">使用命令配置 &lt;code&gt;sign&lt;/code&gt; 预告片，以仅在尚无&amp;ldquo; Signed-off-by：&amp;rdquo;的情况下自动添加带有作者信息的&amp;ldquo; Signed-off ::&amp;rdquo;，并显示其工作方式：</target>
        </trans-unit>
        <trans-unit id="f50c440d2f6f9060cd052adb1632feec1a0c614d" translate="yes" xml:space="preserve">
          <source>Configure a commit template with some trailers with empty values (using sed to show and keep the trailing spaces at the end of the trailers), then configure a commit-msg hook that uses &lt;code&gt;git interpret-trailers&lt;/code&gt; to remove trailers with empty values and to add a &lt;code&gt;git-version&lt;/code&gt; trailer:</source>
          <target state="translated">使用一些带有空值的预告片配置提交模板（使用sed在预告片的末尾显示并保留尾随空格），然后配置使用 &lt;code&gt;git interpret-trailers&lt;/code&gt; 的commit-msg挂钩，以删除具有空值的预告片并添加一个 &lt;code&gt;git-version&lt;/code&gt; 预告片：</target>
        </trans-unit>
        <trans-unit id="3f6c615a6da0f7262f6f2dbcc08ecf276b931a9e" translate="yes" xml:space="preserve">
          <source>Configure your general composition window to not wrap.</source>
          <target state="translated">配置你的普通构图窗口不进行封装。</target>
        </trans-unit>
        <trans-unit id="3551290f2193aa1e636343f0cbcbc633f639f8c4" translate="yes" xml:space="preserve">
          <source>Configure your mail server composition as plain text: Edit&amp;hellip;​Account Settings&amp;hellip;​Composition &amp;amp; Addressing, uncheck &quot;Compose Messages in HTML&quot;.</source>
          <target state="translated">将您的邮件服务器组成配置为纯文本：编辑...帐户设置...组成和地址，取消选中&amp;ldquo;用HTML编写邮件&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3e29b2ee31b493715ce39183ea79ba9aca718b3b" translate="yes" xml:space="preserve">
          <source>Configured remote-tracking branches</source>
          <target state="translated">配置了远程跟踪分支</target>
        </trans-unit>
        <trans-unit id="4976060b350e89ec5dfdb2a1c1950efb45f52bc3" translate="yes" xml:space="preserve">
          <source>Configuring database backend</source>
          <target state="translated">配置数据库后端</target>
        </trans-unit>
        <trans-unit id="c983b7934801a3688ed66b5498ab09519448fc97" translate="yes" xml:space="preserve">
          <source>Configuring gitweb features</source>
          <target state="translated">配置gitweb功能</target>
        </trans-unit>
        <trans-unit id="40e0a19569f8f1844d5a471098cc89ca36d5ca64" translate="yes" xml:space="preserve">
          <source>Configuring remote-tracking branches</source>
          <target state="translated">配置远程跟踪分支</target>
        </trans-unit>
        <trans-unit id="9e40cad468539cb8231b63b11fdb5df741e2d14b" translate="yes" xml:space="preserve">
          <source>Confirm just before sending:</source>
          <target state="translated">在发送前确认。</target>
        </trans-unit>
        <trans-unit id="ecda02ba517320c0b15d176b3e447e83063fff66" translate="yes" xml:space="preserve">
          <source>Conflict markers are left in the problematic files, and after you resolve the conflicts manually, you can update the index with the contents and run Git commit, as you normally would when creating a new file.</source>
          <target state="translated">冲突标记会留在有问题的文件中,手动解决冲突后,可以像平常创建新文件时一样,用内容更新索引并运行Git提交。</target>
        </trans-unit>
        <trans-unit id="b82d334ed6758888e34c8a34df72370a5d90993b" translate="yes" xml:space="preserve">
          <source>Conflicts can occur when applying a commit to p4. When this happens, the default behavior (&quot;ask&quot;) is to prompt whether to skip this commit and continue, or quit. This option can be used to bypass the prompt, causing conflicting commits to be automatically skipped, or to quit trying to apply commits, without prompting.</source>
          <target state="translated">在对 p4 进行提交时,可能会发生冲突。当这种情况发生时,默认的行为(&quot;ask&quot;)是提示是否跳过这个提交并继续,或者退出。这个选项可以用来绕过提示,导致冲突的提交被自动跳过,或者退出尝试提交,而无需提示。</target>
        </trans-unit>
        <trans-unit id="d9246582c40c7034c419d5e149871effa77f01da" translate="yes" xml:space="preserve">
          <source>Connects to given service. Standard input and standard output of helper are connected to specified service (git prefix is included in service name so e.g. fetching uses &lt;code&gt;git-upload-pack&lt;/code&gt; as service) on remote side. Valid replies to this command are empty line (connection established), &lt;code&gt;fallback&lt;/code&gt; (no smart transport support, fall back to dumb transports) and just exiting with error message printed (can&amp;rsquo;t connect, don&amp;rsquo;t bother trying to fall back). After line feed terminating the positive (empty) response, the output of service starts. After the connection ends, the remote helper exits.</source>
          <target state="translated">连接到给定的服务。辅助程序的标准输入和标准输出连接到远程侧上的指定服务（服务名称中包含git前缀，因此，例如，获取使用 &lt;code&gt;git-upload-pack&lt;/code&gt; 作为服务）。对此命令的有效答复是：空行（建立连接）， &lt;code&gt;fallback&lt;/code&gt; （无智能传输支持，回退到哑传输）以及仅退出并显示错误消息（无法连接，不必费心尝试回退）。在换行终止正（空）响应之后，服务的输出开始。连接结束后，远程帮助程序将退出。</target>
        </trans-unit>
        <trans-unit id="ab69689298b341c622fdf07baf6d7935162cc21e" translate="yes" xml:space="preserve">
          <source>Consider &lt;code&gt;.gitattributes&lt;/code&gt; in the index only, ignoring the working tree.</source>
          <target state="translated">仅考虑 &lt;code&gt;.gitattributes&lt;/code&gt; 中的.gitattributes，而忽略工作树。</target>
        </trans-unit>
        <trans-unit id="2e9b2aca01cec344e42ddb2f6c4d43d446641ec6" translate="yes" xml:space="preserve">
          <source>Consider any object recorded in the index also as a head node for an unreachability trace.</source>
          <target state="translated">将索引中记录的任何对象也视为不可到达性跟踪的头节点。</target>
        </trans-unit>
        <trans-unit id="5dd8963c37ba70016cc97181d1437d9d279837cb" translate="yes" xml:space="preserve">
          <source>Consider only commits that are enough to explain how the files that match the specified paths came to be.</source>
          <target state="translated">只考虑那些足以解释与指定路径相匹配的文件是如何产生的提交。</target>
        </trans-unit>
        <trans-unit id="ba0254d514d0f2ca6e4ebd12fd91b2a48fa85b1d" translate="yes" xml:space="preserve">
          <source>Consider the following .gitmodules file:</source>
          <target state="translated">考虑以下.gitmodules文件。</target>
        </trans-unit>
        <trans-unit id="8a3a2dda249f0930d1314682106ca1561464766d" translate="yes" xml:space="preserve">
          <source>Consider the limiting patterns to be Perl-compatible regular expressions.</source>
          <target state="translated">认为限制模式是Perl兼容的正则表达式。</target>
        </trans-unit>
        <trans-unit id="d3cbcdfc580ee16544a677fdcaea7364f6ffede7" translate="yes" xml:space="preserve">
          <source>Consider the limiting patterns to be basic regular expressions; this is the default.</source>
          <target state="translated">认为限制模式是基本的正则表达式,这是默认的。</target>
        </trans-unit>
        <trans-unit id="cc80930760a8dae17ccff09b94b94b8c2a73e3d6" translate="yes" xml:space="preserve">
          <source>Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions.</source>
          <target state="translated">认为限制模式是扩展的正则表达式,而不是默认的基本正则表达式。</target>
        </trans-unit>
        <trans-unit id="0bd0c2e95b3ce3558e3f029a387e02dcaec9fc10" translate="yes" xml:space="preserve">
          <source>Consider the limiting patterns to be fixed strings (don&amp;rsquo;t interpret pattern as a regular expression).</source>
          <target state="translated">将限制模式视为固定字符串（不要将模式解释为正则表达式）。</target>
        </trans-unit>
        <trans-unit id="ce08a982fc80bf880f9e5e7fbbc19290d0e13642" translate="yes" xml:space="preserve">
          <source>Consider this history:</source>
          <target state="translated">考虑到这段历史。</target>
        </trans-unit>
        <trans-unit id="6e0518d23c6b434e11a17284519d985d575f8d5b" translate="yes" xml:space="preserve">
          <source>Considers adding content from all git-*.sh scripts:</source>
          <target state="translated">考虑从所有git-*.sh脚本中添加内容。</target>
        </trans-unit>
        <trans-unit id="aa183b32e2469308bcac751961ddf4f45522d312" translate="yes" xml:space="preserve">
          <source>Construct a commit message for use with &lt;code&gt;rebase --autosquash&lt;/code&gt;. The commit message subject line is taken from the specified commit with a prefix of &quot;squash! &quot;. Can be used with additional commit message options (&lt;code&gt;-m&lt;/code&gt;/&lt;code&gt;-c&lt;/code&gt;/&lt;code&gt;-C&lt;/code&gt;/&lt;code&gt;-F&lt;/code&gt;). See &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details.</source>
          <target state="translated">构造一个与 &lt;code&gt;rebase --autosquash&lt;/code&gt; 一起使用的提交消息。提交消息主题行是从具有&amp;ldquo; squash！&amp;rdquo;前缀的指定提交中提取的。可以与其他提交消息选项（ &lt;code&gt;-m&lt;/code&gt; / &lt;code&gt;-c&lt;/code&gt; / &lt;code&gt;-C&lt;/code&gt; / &lt;code&gt;-F&lt;/code&gt; ）一起使用。有关详细信息，请参见&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="613af883ed6da1442ba9d47b0f082fab42f334c7" translate="yes" xml:space="preserve">
          <source>Construct a commit message for use with &lt;code&gt;rebase --autosquash&lt;/code&gt;. The commit message will be the subject line from the specified commit with a prefix of &quot;fixup! &quot;. See &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details.</source>
          <target state="translated">构造一个与 &lt;code&gt;rebase --autosquash&lt;/code&gt; 一起使用的提交消息。提交消息将是指定提交的主题行，其前缀为&amp;ldquo; fixup！&amp;rdquo;。有关详细信息，请参见&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26410cb72d41a741e69a55d63cb8badf7f0b0bd2" translate="yes" xml:space="preserve">
          <source>Contains administrative data for linked working trees. Each subdirectory contains the working tree-related part of a linked working tree. This directory is ignored if $GIT_COMMON_DIR is set, in which case &quot;$GIT_COMMON_DIR/worktrees&quot; will be used instead.</source>
          <target state="translated">包含链接工作树的管理数据。每一个子目录都包含了链接工作树的相关部分,如果设置了$GIT_COMMON_DIR,这个目录将被忽略。如果设置了 $GIT_COMMON_DIR,这个目录将被忽略,在这种情况下,将使用 &quot;$GIT_COMMON_DIR/worktrees &quot;代替。</target>
        </trans-unit>
        <trans-unit id="926bb57bf277ea775a3bccb0602b810a03d08da9" translate="yes" xml:space="preserve">
          <source>Contains the git-repositories of the submodules.</source>
          <target state="translated">包含子模块的git仓库。</target>
        </trans-unit>
        <trans-unit id="2017a3b0e62c7744478a46c444d4d27cb868b22a" translate="yes" xml:space="preserve">
          <source>Content which does not differ between the index and working tree may be shown on context lines, beginning with a &quot; &quot; (space). You can stage context lines for removal by converting the space to a &quot;-&quot;. The resulting working tree file will appear to re-add the content.</source>
          <target state="translated">索引和工作树之间没有区别的内容可以显示在上下文行上,以&quot;&quot;(空格)开头。您可以通过将空格转换为&quot;-&quot;来对上下文行进行删除。由此产生的工作树文件将显示为重新添加的内容。</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="475c13751eb255f66e4aec9a66a81a56d379a598" translate="yes" xml:space="preserve">
          <source>Continue listing the history of a file beyond renames (works only for a single file).</source>
          <target state="translated">在重命名之后继续列出文件的历史记录(只对单个文件有效)。</target>
        </trans-unit>
        <trans-unit id="4798719de8c426782f7160e2b872b0281bb19c57" translate="yes" xml:space="preserve">
          <source>Continue the operation in progress using the information in &lt;code&gt;.git/sequencer&lt;/code&gt;. Can be used to continue after resolving conflicts in a failed cherry-pick or revert.</source>
          <target state="translated">使用 &lt;code&gt;.git/sequencer&lt;/code&gt; 中的信息继续进行中的操作。在解决失败的樱桃选择或还原中的冲突后，可用于继续操作。</target>
        </trans-unit>
        <trans-unit id="75e8c6f43c030fe85b04f600a5aefef84d4215ca" translate="yes" xml:space="preserve">
          <source>Continue the rebase with &lt;code&gt;git rebase --continue&lt;/code&gt;.</source>
          <target state="translated">继续使用 &lt;code&gt;git rebase --continue&lt;/code&gt; 进行重新设置。</target>
        </trans-unit>
        <trans-unit id="fbb3e402bf66bc40e025c029cebd9e3786831d84" translate="yes" xml:space="preserve">
          <source>Continuing with our test-project, let&amp;rsquo;s modify file.txt again:</source>
          <target state="translated">继续我们的测试项目，让我们再次修改file.txt：</target>
        </trans-unit>
        <trans-unit id="6f930d8a34d56a441268a0623f0c037df7494b75" translate="yes" xml:space="preserve">
          <source>Control GSSAPI credential delegation. The delegation is disabled by default in libcurl since version 7.21.7. Set parameter to tell the server what it is allowed to delegate when it comes to user credentials. Used with GSS/kerberos. Possible values are:</source>
          <target state="translated">控制GSSAPI证书授权。自7.21.7版本起,libcurl默认禁用授权。设置参数来告诉服务器,当涉及到用户凭证时,它可以委托什么。与GSS/kerberos一起使用。可能的值是</target>
        </trans-unit>
        <trans-unit id="732c632643ca337cd77cc6d082dfc0d1c8e3c9e5" translate="yes" xml:space="preserve">
          <source>Control how information about the commits in the local repository is sent when negotiating the contents of the packfile to be sent by the server. Set to &quot;skipping&quot; to use an algorithm that skips commits in an effort to converge faster, but may result in a larger-than-necessary packfile; The default is &quot;default&quot; which instructs Git to use the default algorithm that never skips commits (unless the server has acknowledged it or one of its descendants). If &lt;code&gt;feature.experimental&lt;/code&gt; is enabled, then this setting defaults to &quot;skipping&quot;. Unknown values will cause &lt;code&gt;git fetch&lt;/code&gt; to error out.</source>
          <target state="translated">控制在协商服务器要发送的packfile内容时如何发送有关本地存储库中提交的信息。设置为&amp;ldquo;跳过&amp;rdquo;以使用跳过提交的算法，以加快收敛速度​​，但可能会导致所需的packfile更大。默认值为&amp;ldquo; default&amp;rdquo;，它指示Git使用永不跳过提交的默认算法（除非服务器已确认它或其后代之一）。如果启用了 &lt;code&gt;feature.experimental&lt;/code&gt; ，则此设置默认为&amp;ldquo;跳过&amp;rdquo;。未知值将导致 &lt;code&gt;git fetch&lt;/code&gt; 错误输出。</target>
        </trans-unit>
        <trans-unit id="8ae71e6ee5d07ac322bf2300466d8fa2871661c2" translate="yes" xml:space="preserve">
          <source>Control how information about the commits in the local repository is sent when negotiating the contents of the packfile to be sent by the server. Set to &quot;skipping&quot; to use an algorithm that skips commits in an effort to converge faster, but may result in a larger-than-necessary packfile; or set to &quot;noop&quot; to not send any information at all, which will almost certainly result in a larger-than-necessary packfile, but will skip the negotiation step. The default is &quot;default&quot; which instructs Git to use the default algorithm that never skips commits (unless the server has acknowledged it or one of its descendants). If &lt;code&gt;feature.experimental&lt;/code&gt; is enabled, then this setting defaults to &quot;skipping&quot;. Unknown values will cause &lt;code&gt;git fetch&lt;/code&gt; to error out.</source>
          <target state="translated">控制在协商服务器要发送的packfile内容时如何发送有关本地存储库中提交的信息。设置为&amp;ldquo;跳过&amp;rdquo;以使用一种算法，该算法会跳过提交以加快收敛速度​​，但可能会导致打包文件大于必要的大小。或设置为&amp;ldquo; noop&amp;rdquo;根本不发送任何信息，这几乎肯定会导致大于所需的packfile，但将跳过协商步骤。默认值为&amp;ldquo; default&amp;rdquo;，它指示Git使用从不跳过提交的默认算法（除非服务器已确认它或其后代之一）。如果启用了 &lt;code&gt;feature.experimental&lt;/code&gt; ，则此设置默认为&amp;ldquo;跳过&amp;rdquo;。未知值将导致 &lt;code&gt;git fetch&lt;/code&gt; 错误输出。</target>
        </trans-unit>
        <trans-unit id="aa2d757e789e92329feff3e9e393ffe1cf9826bc" translate="yes" xml:space="preserve">
          <source>Control how ref update status is printed. Valid values are &lt;code&gt;full&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt;. Default value is &lt;code&gt;full&lt;/code&gt;. See section OUTPUT in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; for detail.</source>
          <target state="translated">控制如何打印参考更新状态。有效值是 &lt;code&gt;full&lt;/code&gt; 且 &lt;code&gt;compact&lt;/code&gt; 。默认值是 &lt;code&gt;full&lt;/code&gt; 。有关详细信息，请参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]中的&lt;/a&gt; OUTPUT部分。</target>
        </trans-unit>
        <trans-unit id="8e05cd92bb18e6dbe129763361ebf98f054218bc" translate="yes" xml:space="preserve">
          <source>Control the order in which files appear in the output. This overrides the &lt;code&gt;diff.orderFile&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). To cancel &lt;code&gt;diff.orderFile&lt;/code&gt;, use &lt;code&gt;-O/dev/null&lt;/code&gt;.</source>
          <target state="translated">控制文件在输出中出现的顺序。这将覆盖 &lt;code&gt;diff.orderFile&lt;/code&gt; 配置变量（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。要取消 &lt;code&gt;diff.orderFile&lt;/code&gt; ，请使用 &lt;code&gt;-O/dev/null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95cfa5bd9ed3c9eff692bd91fe02de0af906819b" translate="yes" xml:space="preserve">
          <source>Controlling access to Git repositories</source>
          <target state="translated">控制对Git仓库的访问</target>
        </trans-unit>
        <trans-unit id="302680d7e637a6c4d28c5bc8380af3a8487a3fd0" translate="yes" xml:space="preserve">
          <source>Controlling the daemon</source>
          <target state="translated">控制守护进程</target>
        </trans-unit>
        <trans-unit id="5f8b43605d2bc36ca036762a54d85472bbaf393e" translate="yes" xml:space="preserve">
          <source>Controls addition of &lt;code&gt;In-Reply-To&lt;/code&gt; and &lt;code&gt;References&lt;/code&gt; headers to make the second and subsequent mails appear as replies to the first. Also controls generation of the &lt;code&gt;Message-Id&lt;/code&gt; header to reference.</source>
          <target state="translated">控制&amp;ldquo; &lt;code&gt;In-Reply-To&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;References&lt;/code&gt; &amp;rdquo;标题的添加，以使第二封邮件和后续邮件作为对第一封邮件的答复。还控制要引用的 &lt;code&gt;Message-Id&lt;/code&gt; 标头的生成。</target>
        </trans-unit>
        <trans-unit id="2d73e883baf4d5a02fe3808167b349dacd41e248" translate="yes" xml:space="preserve">
          <source>Controls the amount of output shown by the recursive merge strategy. Level 0 outputs nothing except a final error message if conflicts were detected. Level 1 outputs only conflicts, 2 outputs conflicts and file changes. Level 5 and above outputs debugging information. The default is level 2. Can be overridden by the &lt;code&gt;GIT_MERGE_VERBOSITY&lt;/code&gt; environment variable.</source>
          <target state="translated">控制递归合并策略显示的输出量。如果检测到冲突，级别0除了最终错误消息外什么也不会输出。级别1仅输出冲突，级别2输出冲突和文件更改。5级及以上级别输出调试信息。默认值为级别2。可以被 &lt;code&gt;GIT_MERGE_VERBOSITY&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="d76ea066512503130cc69199cf2d62634818fae1" translate="yes" xml:space="preserve">
          <source>Controls whether one-level refnames are accepted (i.e., refnames that do not contain multiple &lt;code&gt;/&lt;/code&gt;-separated components). The default is &lt;code&gt;--no-allow-onelevel&lt;/code&gt;.</source>
          <target state="translated">控制是否接受一级引用名称（即，不包含多个 &lt;code&gt;/&lt;/code&gt; 分隔的组件的引用名称）。默认值为 &lt;code&gt;--no-allow-onelevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65d9a75f19717f80d02990ede6313f9c8dc92c2a" translate="yes" xml:space="preserve">
          <source>Controls which diff tool is used by &lt;a href=&quot;git-difftool&quot;&gt;git-difftool[1]&lt;/a&gt; when the -g/--gui flag is specified. This variable overrides the value configured in &lt;code&gt;merge.guitool&lt;/code&gt;. The list below shows the valid built-in values. Any other value is treated as a custom diff tool and requires that a corresponding difftool.&amp;lt;guitool&amp;gt;.cmd variable is defined.</source>
          <target state="translated">当指定-g / &lt;a href=&quot;git-difftool&quot;&gt;-gui&lt;/a&gt;标志时，控制git-difftool [1]使用哪个diff工具。此变量将覆盖 &lt;code&gt;merge.guitool&lt;/code&gt; 中配置的值。下面的列表显示了有效的内置值。任何其他值都被视为自定义差异工具，并且需要定义相应的difftool。&amp;lt;guitool&amp;gt; .cmd变量。</target>
        </trans-unit>
        <trans-unit id="866c417f86e708b803c2ccd6543f9e30d5664def" translate="yes" xml:space="preserve">
          <source>Controls which diff tool is used by &lt;a href=&quot;git-difftool&quot;&gt;git-difftool[1]&lt;/a&gt;. This variable overrides the value configured in &lt;code&gt;merge.tool&lt;/code&gt;. The list below shows the valid built-in values. Any other value is treated as a custom diff tool and requires that a corresponding difftool.&amp;lt;tool&amp;gt;.cmd variable is defined.</source>
          <target state="translated">控制&lt;a href=&quot;git-difftool&quot;&gt;git-difftool [1]&lt;/a&gt;使用哪个diff工具。此变量将覆盖 &lt;code&gt;merge.tool&lt;/code&gt; 中配置的值。下面的列表显示了有效的内置值。任何其他值都将被视为自定义差异工具，并且需要定义相应的difftool。&amp;lt;tool&amp;gt; .cmd变量。</target>
        </trans-unit>
        <trans-unit id="5cb013e070a3b4cddc50474dc321b1da7ea13759" translate="yes" xml:space="preserve">
          <source>Controls which merge tool is used by &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt; when the -g/--gui flag is specified. The list below shows the valid built-in values. Any other value is treated as a custom merge tool and requires that a corresponding mergetool.&amp;lt;guitool&amp;gt;.cmd variable is defined.</source>
          <target state="translated">当指定-g /-gui标志时，控制&lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool [1]&lt;/a&gt;使用哪个合并工具。下面的列表显示了有效的内置值。任何其他值都被视为自定义合并工具，并且需要定义相应的mergetool。&amp;lt;guitool&amp;gt; .cmd变量。</target>
        </trans-unit>
        <trans-unit id="18ee15c4e31cbcbd84b87172e325dafb065adff0" translate="yes" xml:space="preserve">
          <source>Controls which merge tool is used by &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt;. The list below shows the valid built-in values. Any other value is treated as a custom merge tool and requires that a corresponding mergetool.&amp;lt;tool&amp;gt;.cmd variable is defined.</source>
          <target state="translated">控制&lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool [1]&lt;/a&gt;使用哪个合并工具。下面的列表显示了有效的内置值。其他任何值都被视为自定义合并工具，并且需要定义相应的mergetool。&amp;lt;tool&amp;gt; .cmd变量。</target>
        </trans-unit>
        <trans-unit id="474792f82dd9247329dbb1b3dcfbbed1c865f4c2" translate="yes" xml:space="preserve">
          <source>Controls which parts of the cover letter will be automatically populated using the branch&amp;rsquo;s description.</source>
          <target state="translated">控制使用分支的说明自动填充求职信的哪些部分。</target>
        </trans-unit>
        <trans-unit id="c3102343a37aa52f6a069dc8bc5f12c9420d06d2" translate="yes" xml:space="preserve">
          <source>Conventions for public functions and macros</source>
          <target state="translated">公共函数和宏的约定</target>
        </trans-unit>
        <trans-unit id="24ce25558484789421068a0f3fdf9552add6eb44" translate="yes" xml:space="preserve">
          <source>Conversely, text files that Git does not detect can have normalization enabled manually.</source>
          <target state="translated">相反,Git 没有检测到的文本文件可以手动启用标准化。</target>
        </trans-unit>
        <trans-unit id="e49f6aaa8529aed7e4294b528b8e93971284c07e" translate="yes" xml:space="preserve">
          <source>Convert raw file data into a blob, for future use in a &lt;code&gt;commit&lt;/code&gt; command. This command is optional and is not needed to perform an import.</source>
          <target state="translated">将原始文件数据转换为Blob，以供将来在 &lt;code&gt;commit&lt;/code&gt; 命令中使用。该命令是可选的，不需要执行导入。</target>
        </trans-unit>
        <trans-unit id="93865ee1f19358443956a81b8175d73f301958b3" translate="yes" xml:space="preserve">
          <source>Convert token &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; in the anonymized output. If &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; is omitted, map &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; to itself (i.e., do not anonymize it). See the section on &lt;code&gt;ANONYMIZING&lt;/code&gt; below.</source>
          <target state="translated">在匿名输出中将标记 &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; 转换为 &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; 。如果省略了 &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; ，则将&amp;lt; &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; 映射到自身（即，不要使其匿名）。请参阅下面有关 &lt;code&gt;ANONYMIZING&lt;/code&gt; 的部分。</target>
        </trans-unit>
        <trans-unit id="30c15e3645b0a2e6438456f892ca0f7bb2ab425e" translate="yes" xml:space="preserve">
          <source>Convert underscores in tag and branch names to dots.</source>
          <target state="translated">将标签和分支名称中的下划线转换为点。</target>
        </trans-unit>
        <trans-unit id="717ec262f5a03d7fab61894de5327ed8b2dce9d6" translate="yes" xml:space="preserve">
          <source>Copy a branch and the corresponding reflog.</source>
          <target state="translated">复制一个分支和相应的重新记录。</target>
        </trans-unit>
        <trans-unit id="d010ed84eae444d5db43ea15cd0c22cd88feae0f" translate="yes" xml:space="preserve">
          <source>Copy files from the index to the working tree</source>
          <target state="translated">将文件从索引中复制到工作树中</target>
        </trans-unit>
        <trans-unit id="c76ee4ad9dd156a08ecfefcfcb1c22de051a4c57" translate="yes" xml:space="preserve">
          <source>Copy over the packed files from &quot;project lead&quot; public repository to your public repository, unless the &quot;project lead&quot; repository lives on the same machine as yours. In the latter case, you can use &lt;code&gt;objects/info/alternates&lt;/code&gt; file to point at the repository you are borrowing from.</source>
          <target state="translated">将打包的文件从&amp;ldquo;项目负责人&amp;rdquo;公共资源库复制到您的公共资源库，除非&amp;ldquo;项目负责人&amp;rdquo;资源库与您的计算机位于同一台计算机上。在后一种情况下，您可以使用 &lt;code&gt;objects/info/alternates&lt;/code&gt; 文件来指向您要从中借用的存储库。</target>
        </trans-unit>
        <trans-unit id="d8b3dca28c0ddf8873f77c43f29755622d908cce" translate="yes" xml:space="preserve">
          <source>Copy the Message-ID header at the end of the commit message. This is useful in order to associate commits with mailing list discussions.</source>
          <target state="translated">在提交信息的结尾处复制Message-ID头。这对于将提交与邮件列表讨论关联起来很有用。</target>
        </trans-unit>
        <trans-unit id="5a3f70a82898c2a8456ad61672927bc441665238" translate="yes" xml:space="preserve">
          <source>Copy the modified files to a temporary location and perform a directory diff on them. This mode never prompts before launching the diff tool.</source>
          <target state="translated">将修改后的文件复制到一个临时位置,并对其进行目录比较。这种模式在启动diff工具前从不提示。</target>
        </trans-unit>
        <trans-unit id="c190e9af114c74dc1cae547f652783f706162e52" translate="yes" xml:space="preserve">
          <source>Copy the notes for the first object onto the second object (defaults to HEAD). Abort if the second object already has notes, or if the first object has none (use -f to overwrite existing notes to the second object). This subcommand is equivalent to: &lt;code&gt;git notes add [-f] -C $(git notes list &amp;lt;from-object&amp;gt;) &amp;lt;to-object&amp;gt;&lt;/code&gt;</source>
          <target state="translated">将第一个对象的注释复制到第二个对象上（默认为HEAD）。如果第二个对象已经有注释，或者如果第一个对象没有注释，则中止（使用-f覆盖第二个对象的现有注释）。此子命令等效于： &lt;code&gt;git notes add [-f] -C $(git notes list &amp;lt;from-object&amp;gt;) &amp;lt;to-object&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f67d1ba5e94aaa446c4cd38a50c12bd9c63d60dc" translate="yes" xml:space="preserve">
          <source>Copying repositories</source>
          <target state="translated">复制存储库</target>
        </trans-unit>
        <trans-unit id="36e54cbb8f2eeebb702575f30e1a34b2297f308c" translate="yes" xml:space="preserve">
          <source>Core git executable to use. By default set to &lt;code&gt;$GIT_BINDIR/git&lt;/code&gt;, which in turn is by default set to &lt;code&gt;$(bindir)/git&lt;/code&gt;. If you use Git installed from a binary package, you should usually set this to &quot;/usr/bin/git&quot;. This can just be &quot;git&quot; if your web server has a sensible PATH; from security point of view it is better to use absolute path to git binary. If you have multiple Git versions installed it can be used to choose which one to use. Must be (correctly) set for gitweb to be able to work.</source>
          <target state="translated">要使用的核心git可执行文件。默认情况下设置为 &lt;code&gt;$GIT_BINDIR/git&lt;/code&gt; ，默认情况下又设置为 &lt;code&gt;$(bindir)/git&lt;/code&gt; 。如果使用从二进制软件包安装的Git，通常应将其设置为&amp;ldquo; / usr / bin / git&amp;rdquo;。如果您的Web服务器具有明智的PATH，则可能只是&amp;ldquo; git&amp;rdquo;。从安全角度来看，最好使用绝对路径来生成git二进制文件。如果您安装了多个Git版本，则可以使用它来选择使用哪个版本。必须（正确）设置gitweb才能工作。</target>
        </trans-unit>
        <trans-unit id="85a8806cd8d64571a9c2262e310bf038f08a1274" translate="yes" xml:space="preserve">
          <source>Count changes in a child directory for the parent directory as well. Note that when using &lt;code&gt;cumulative&lt;/code&gt;, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the &lt;code&gt;noncumulative&lt;/code&gt; parameter.</source>
          <target state="translated">同样在父目录的子目录中计算更改。请注意，使用 &lt;code&gt;cumulative&lt;/code&gt; ，报告的百分比之和可能超过100％。可以使用 &lt;code&gt;noncumulative&lt;/code&gt; 参数指定默认（非累积）行为。</target>
        </trans-unit>
        <trans-unit id="492f2e2be05a1aa8d8af437be99e7dacb8d4f9d0" translate="yes" xml:space="preserve">
          <source>Count unpacked number of objects and their disk consumption</source>
          <target state="translated">统计未打包的对象数量和它们的磁盘消耗。</target>
        </trans-unit>
        <trans-unit id="763b234fba543bb2523cf09d67150c10446b45b7" translate="yes" xml:space="preserve">
          <source>Countermand &lt;code&gt;commit.gpgSign&lt;/code&gt; configuration variable that is set to force each and every commit to be signed.</source>
          <target state="translated">Countermand &lt;code&gt;commit.gpgSign&lt;/code&gt; 配置变量，该变量设置为强制对每个提交进行签名。</target>
        </trans-unit>
        <trans-unit id="6096cddc00ec928df60a796e3d4cfb0bb68acdbe" translate="yes" xml:space="preserve">
          <source>Counting the number of commits on a branch</source>
          <target state="translated">计算一个分支的提交次数。</target>
        </trans-unit>
        <trans-unit id="5c28a68396ec48f8ddfeca624f27118d20e2f2ea" translate="yes" xml:space="preserve">
          <source>Crash reports</source>
          <target state="translated">碰撞报告</target>
        </trans-unit>
        <trans-unit id="97b6cc167e6a90cd26177184d37208b481756eef" translate="yes" xml:space="preserve">
          <source>Create &amp;lt;ref&amp;gt; with &amp;lt;newvalue&amp;gt; after verifying it does not exist. The given &amp;lt;newvalue&amp;gt; may not be zero.</source>
          <target state="translated">确认&amp;lt;ref&amp;gt;不存在后，用&amp;lt;newvalue&amp;gt;创建它。给定的&amp;lt;newvalue&amp;gt;不能为零。</target>
        </trans-unit>
        <trans-unit id="821a77e6f90a06fed7c0ea5afb5c7aa03a8e4a48" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; and checkout &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; into it. The new working directory is linked to the current repository, sharing everything except working directory specific files such as &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt;, etc. As a convenience, &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; may be a bare &quot;&lt;code&gt;-&lt;/code&gt;&quot;, which is synonymous with &lt;code&gt;@{-1}&lt;/code&gt;.</source>
          <target state="translated">创建 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 并签入 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 。新的工作目录链接到当前存储库，共享除工作目录特定文件（如 &lt;code&gt;HEAD&lt;/code&gt; ， &lt;code&gt;index&lt;/code&gt; 等）外的所有内容。为方便起见， &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 可能是裸露的&amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo;，它与 &lt;code&gt;@{-1}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d3e6679c48a19f8a3804fc16c43252c9d4a1106" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; and checkout &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; into it. The new working directory is linked to the current repository, sharing everything except working directory specific files such as HEAD, index, etc. &lt;code&gt;-&lt;/code&gt; may also be specified as &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;; it is synonymous with &lt;code&gt;@{-1}&lt;/code&gt;.</source>
          <target state="translated">创建 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 并签入 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 。新的工作目录链接到当前存储库，共享一切，除了工作目录的特定文件，例如HEAD，索引等 &lt;code&gt;-&lt;/code&gt; 也可被指定为 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; ; 它是 &lt;code&gt;@{-1}&lt;/code&gt; 同义词。</target>
        </trans-unit>
        <trans-unit id="918c3c2a066586184896c329601a42f88338b5c6" translate="yes" xml:space="preserve">
          <source>Create a &quot;thin&quot; pack by omitting the common objects between a sender and a receiver in order to reduce network transfer. This option only makes sense in conjunction with --stdout.</source>
          <target state="translated">通过省略发送方和接收方之间的共同对象来创建一个 &quot;瘦 &quot;包,以减少网络传输。这个选项只有和-stdout一起使用才有意义。</target>
        </trans-unit>
        <trans-unit id="ec9cb277fe09464e753dba1a9c058b6a9566ff6f" translate="yes" xml:space="preserve">
          <source>Create a /path/to/my/codebase/.git directory.</source>
          <target state="translated">创建一个/path/to/my/codebase/.git目录。</target>
        </trans-unit>
        <trans-unit id="c0a6d61d3fd0fcaf6c684be3f4ae17d7a1fadcb9" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;shallow&lt;/code&gt; clone with a history truncated to the specified number of commits. Implies &lt;code&gt;--single-branch&lt;/code&gt; unless &lt;code&gt;--no-single-branch&lt;/code&gt; is given to fetch the histories near the tips of all branches. If you want to clone submodules shallowly, also pass &lt;code&gt;--shallow-submodules&lt;/code&gt;.</source>
          <target state="translated">创建一个 &lt;code&gt;shallow&lt;/code&gt; 克隆，其历史记录被截断为指定的提交数。表示 &lt;code&gt;--single-branch&lt;/code&gt; ,除非给出 &lt;code&gt;--no-single-branch&lt;/code&gt; 来获取所有分支的尖端附近的历史记录。如果要浅层克隆子模块，则还要传递 &lt;code&gt;--shallow-submodules&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efb2e81b939b9a77d43ecb93b07dc1f2ed7276af" translate="yes" xml:space="preserve">
          <source>Create a Zip archive that contains the contents of the latest commit on the current branch. Note that the output format is inferred by the extension of the output file.</source>
          <target state="translated">创建一个包含当前分支最新提交内容的 Zip 档案。请注意,输出格式由输出文件的扩展名来推断。</target>
        </trans-unit>
        <trans-unit id="98ed6a63ab53ebc7b5cb53eddb5b05ee6e17c097" translate="yes" xml:space="preserve">
          <source>Create a bare repository to publish your changes to the public:</source>
          <target state="translated">创建一个裸仓库来向公众发布你的更改。</target>
        </trans-unit>
        <trans-unit id="8ecd6ae5a1546c899c5e4d339f3b41e08bfa5878" translate="yes" xml:space="preserve">
          <source>Create a bare repository. If &lt;code&gt;GIT_DIR&lt;/code&gt; environment is not set, it is set to the current working directory.</source>
          <target state="translated">创建一个裸仓库。如果未设置 &lt;code&gt;GIT_DIR&lt;/code&gt; 环境，则将其设置为当前工作目录。</target>
        </trans-unit>
        <trans-unit id="8d2657b83c3c9eabb4154adbe14301af394e1de8" translate="yes" xml:space="preserve">
          <source>Create a branch in the SVN repository.</source>
          <target state="translated">在SVN仓库中创建一个分支。</target>
        </trans-unit>
        <trans-unit id="9535ca3b3bba3d55a9a78d2e5a327a9df5b9b7ac" translate="yes" xml:space="preserve">
          <source>Create a compressed tarball for v1.4.0 release, but without a global extended pax header.</source>
          <target state="translated">为v1.4.0版本创建一个压缩的tar包,但没有全局扩展的pax头。</target>
        </trans-unit>
        <trans-unit id="b5319dfc6eb9dc4a079ba2789cc4bdb586f57276" translate="yes" xml:space="preserve">
          <source>Create a compressed tarball for v1.4.0 release.</source>
          <target state="translated">为v1.4.0版本创建一个压缩压缩包。</target>
        </trans-unit>
        <trans-unit id="faa66e3a606f56a97105d3be717d6c143b22dab2" translate="yes" xml:space="preserve">
          <source>Create a graft commit. A new commit is created with the same content as &amp;lt;commit&amp;gt; except that its parents will be [&amp;lt;parent&amp;gt;&amp;hellip;​] instead of &amp;lt;commit&amp;gt;'s parents. A replacement ref is then created to replace &amp;lt;commit&amp;gt; with the newly created commit. Use &lt;code&gt;--convert-graft-file&lt;/code&gt; to convert a &lt;code&gt;$GIT_DIR/info/grafts&lt;/code&gt; file and use replace refs instead.</source>
          <target state="translated">创建嫁接提交。创建一个新提交的内容与&amp;lt;commit&amp;gt;相同，不同之处在于其父级将是[&amp;lt;parent&amp;gt; ...]，而不是&amp;lt;commit&amp;gt;的父级。然后创建一个替换引用，用新创建的提交替换&amp;lt;commit&amp;gt;。使用 &lt;code&gt;--convert-graft-file&lt;/code&gt; 转换 &lt;code&gt;$GIT_DIR/info/grafts&lt;/code&gt; 文件，并使用replace refs代替。</target>
        </trans-unit>
        <trans-unit id="571580d25d73e20010dd7b861b6579499c2d2548" translate="yes" xml:space="preserve">
          <source>Create a new &lt;code&gt;orphan&lt;/code&gt; branch, named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt;. All tracked files are removed.</source>
          <target state="translated">创建一个新的 &lt;code&gt;orphan&lt;/code&gt; 分支，名为 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 。删除所有跟踪的文件。</target>
        </trans-unit>
        <trans-unit id="4e15c57fd9f8556efdaf616337a8d6e6219013e8" translate="yes" xml:space="preserve">
          <source>Create a new &lt;code&gt;orphan&lt;/code&gt; branch, named &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt;, started from &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; and switch to it. The first commit made on this new branch will have no parents and it will be the root of a new history totally disconnected from all the other branches and commits.</source>
          <target state="translated">从 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 开始创建一个名为 &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; 的新 &lt;code&gt;orphan&lt;/code&gt; 分支，然后切换到该分支。在这个新分支上进行的第一次提交将没有父母，这将是与所有其他分支和提交完全脱节的新历史的根源。</target>
        </trans-unit>
        <trans-unit id="74397bf89a3d7366727db29fa6dec88cf03174e1" translate="yes" xml:space="preserve">
          <source>Create a new Git repository from an existing p4 repository using &lt;code&gt;git p4 clone&lt;/code&gt;, giving it one or more p4 depot paths. Incorporate new commits from p4 changes with &lt;code&gt;git p4 sync&lt;/code&gt;. The &lt;code&gt;sync&lt;/code&gt; command is also used to include new branches from other p4 depot paths. Submit Git changes back to p4 using &lt;code&gt;git p4 submit&lt;/code&gt;. The command &lt;code&gt;git p4 rebase&lt;/code&gt; does a sync plus rebases the current branch onto the updated p4 remote branch.</source>
          <target state="translated">使用 &lt;code&gt;git p4 clone&lt;/code&gt; 从现有的p4存储库中创建一个新的Git存储库，为它提供一个或多个p4库路径。从 &lt;code&gt;git p4 sync&lt;/code&gt; 合并p4更改中的新提交。该 &lt;code&gt;sync&lt;/code&gt; 命令也被用来从包括其他P4仓库路径新分支。提交使用 &lt;code&gt;git p4 submit&lt;/code&gt; Submit将Git更改回p4。 &lt;code&gt;git p4 rebase&lt;/code&gt; 命令执行同步，并将当前分支重新部署到更新的p4远程分支上。</target>
        </trans-unit>
        <trans-unit id="32283e2eb1bd521d20f1290e2eaa64ee550622d7" translate="yes" xml:space="preserve">
          <source>Create a new branch head pointing to one of these versions and check it out using &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt;:</source>
          <target state="translated">创建一个指向这些版本之一的新分支头，并使用&lt;a href=&quot;git-switch&quot;&gt;git-switch [1]将&lt;/a&gt;其检出：</target>
        </trans-unit>
        <trans-unit id="4de51286c04f5ea0c9795b4b604e6322cb3596eb" translate="yes" xml:space="preserve">
          <source>Create a new branch named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; starting at &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; before switching to the branch. This is a convenient shortcut for:</source>
          <target state="translated">从 &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; 开始创建一个名为 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 的新分支，然后再切换到该分支。这是方便的快捷方式：</target>
        </trans-unit>
        <trans-unit id="adb753b3b1e8742e8dfb04c8a3bbb9df0384a74c" translate="yes" xml:space="preserve">
          <source>Create a new branch named &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; and start it at &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">创建一个名为 &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; 的新分支，并在 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 处启动它；有关详细信息，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f67db00a28beeae8e81324408bce6703c7ea6026" translate="yes" xml:space="preserve">
          <source>Create a new commit containing the current contents of the index and the given log message describing the changes. The new commit is a direct child of HEAD, usually the tip of the current branch, and the branch is updated to point to it (unless no branch is associated with the working tree, in which case HEAD is &quot;detached&quot; as described in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;).</source>
          <target state="translated">创建一个新的提交，其中包含索引的当前内容以及描述更改的给定日志消息。新提交是HEAD的直接子项，通常是当前分支的尖端，并且分支被更新为指向它（除非没有分支与工作树相关联，在这种情况下，HEAD是&amp;ldquo;分离的&amp;rdquo;，如&lt;a href=&quot;git-checkout&quot;&gt;git中所述） -checkout [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="775d2ff1f35d4b43a574ee93495db02f2d8cbc5e" translate="yes" xml:space="preserve">
          <source>Create a new commit object</source>
          <target state="translated">创建一个新的提交对象</target>
        </trans-unit>
        <trans-unit id="ed82c0a774a3c01694b195d2170f6d11389fd2c2" translate="yes" xml:space="preserve">
          <source>Create a new location. See the notes below for details on how to choose the right protocol.</source>
          <target state="translated">创建一个新的位置。有关如何选择正确协议的详细信息,请参见下面的说明。</target>
        </trans-unit>
        <trans-unit id="6b44ae75f523438b3f2cff76c3ac2f27de583720" translate="yes" xml:space="preserve">
          <source>Create a new pack-file containing objects in small pack-files referenced by the multi-pack-index. If the size given by the &lt;code&gt;--batch-size=&amp;lt;size&amp;gt;&lt;/code&gt; argument is zero, then create a pack containing all objects referenced by the multi-pack-index. For a non-zero batch size, Select the pack-files by examining packs from oldest-to-newest, computing the &quot;expected size&quot; by counting the number of objects in the pack referenced by the multi-pack-index, then divide by the total number of objects in the pack and multiply by the pack size. We select packs with expected size below the batch size until the set of packs have total expected size at least the batch size, or all pack-files are considered. If only one pack-file is selected, then do nothing. If a new pack-file is created, rewrite the multi-pack-index to reference the new pack-file. A later run of &lt;code&gt;git multi-pack-index expire&lt;/code&gt; will delete the pack-files that were part of this batch.</source>
          <target state="translated">创建一个新的包文件，其中包含由multi-pack-index引用的小包文件中的对象。如果大小由 &lt;code&gt;--batch-size=&amp;lt;size&amp;gt;&lt;/code&gt; 给定参数为零，然后创建一个包，其中包含由multi-pack-index引用的所有对象。对于非零的批处理大小，请通过检查从最早到最新的软件包来选择软件包文件，通过计算由multi-pack-index引用的软件包中的对象数来计算&amp;ldquo;预期大小&amp;rdquo;，然后除以包装中物体的总数，然后乘以包装尺寸。我们选择预期大小小于批次大小的软件包，直到该组软件包的总预期大小至少为批次大小，或考虑所有的软件包文件。如果仅选择一个打包文件，则不执行任何操作。如果创建了新的打包文件，请重写multi-pack-index以引用新的打包文件。稍后运行 &lt;code&gt;git multi-pack-index expire&lt;/code&gt; 将删除该批处理中的打包文件。</target>
        </trans-unit>
        <trans-unit id="8524608a0d692976af91ac05836567c4a22e40c7" translate="yes" xml:space="preserve">
          <source>Create a new pack-file containing objects in small pack-files referenced by the multi-pack-index. If the size given by the &lt;code&gt;--batch-size=&amp;lt;size&amp;gt;&lt;/code&gt; argument is zero, then create a pack containing all objects referenced by the multi-pack-index. For a non-zero batch size, Select the pack-files by examining packs from oldest-to-newest, computing the &quot;expected size&quot; by counting the number of objects in the pack referenced by the multi-pack-index, then divide by the total number of objects in the pack and multiply by the pack size. We select packs with expected size below the batch size until the set of packs have total expected size at least the batch size. If the total size does not reach the batch size, then do nothing. If a new pack- file is created, rewrite the multi-pack-index to reference the new pack-file. A later run of &lt;code&gt;git multi-pack-index expire&lt;/code&gt; will delete the pack-files that were part of this batch.</source>
          <target state="translated">创建一个新的包文件，其中包含由multi-pack-index引用的小包文件中的对象。如果 &lt;code&gt;--batch-size=&amp;lt;size&amp;gt;&lt;/code&gt; 给定的大小参数为零，然后创建一个包，其中包含由multi-pack-index引用的所有对象。对于非零的批处理大小，请通过检查从最早到最新的软件包来选择软件包文件，通过计算由multi-pack-index引用的软件包中的对象数来计算&amp;ldquo;预期大小&amp;rdquo;，然后除以包装中的对象总数乘以包装尺寸。我们选择预期大小小于批次大小的包装，直到包装组的总预期大小至少为批次大小。如果总大小未达到批处理大小，则什么也不做。如果创建了新的打包文件，请重写multi-pack-index以引用新的打包文件。稍后运行 &lt;code&gt;git multi-pack-index expire&lt;/code&gt; 将删除该批处理中的打包文件。</target>
        </trans-unit>
        <trans-unit id="9c41169f0fcbee00370950fd445a3c201d3fc72d" translate="yes" xml:space="preserve">
          <source>Create a packed archive of objects</source>
          <target state="translated">创建一个打包的对象档案</target>
        </trans-unit>
        <trans-unit id="aeccdf3a7f8e818b38876ba10e91ea37e1459401" translate="yes" xml:space="preserve">
          <source>Create a placeholder file in the local Git repository for each empty directory fetched from Subversion. This includes directories that become empty by removing all entries in the Subversion repository (but not the directory itself). The placeholder files are also tracked and removed when no longer necessary.</source>
          <target state="translated">在本地 Git 仓库中为每个从 Subversion 获取的空目录创建一个占位文件。这包括通过删除 Subversion 仓库中的所有条目(但不是目录本身)而变成空的目录。占位符文件也会被跟踪,并在不再需要时被删除。</target>
        </trans-unit>
        <trans-unit id="b0b2f30f73f128bf11ff805dcea18e4929006e9b" translate="yes" xml:space="preserve">
          <source>Create a reflog for the tag. To globally enable reflogs for tags, see &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. The negated form &lt;code&gt;--no-create-reflog&lt;/code&gt; only overrides an earlier &lt;code&gt;--create-reflog&lt;/code&gt;, but currently does not negate the setting of &lt;code&gt;core.logAllRefUpdates&lt;/code&gt;.</source>
          <target state="translated">为标签创建引用日志。要全局启用标签reflogs，见 &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; 在&lt;a href=&quot;git-config&quot;&gt;GIT-配置[1] &lt;/a&gt;。否定的形式 &lt;code&gt;--no-create-reflog&lt;/code&gt; 仅覆盖更早的 &lt;code&gt;--create-reflog&lt;/code&gt; ，但当前不否定 &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; 的设置。</target>
        </trans-unit>
        <trans-unit id="1c95e8dd01a1c19533d3be2260c095f09f00ed3d" translate="yes" xml:space="preserve">
          <source>Create a shallow clone with a history after the specified time.</source>
          <target state="translated">在指定时间后创建一个有历史记录的浅层克隆。</target>
        </trans-unit>
        <trans-unit id="81a994e450296531fc46153834310318c564b7aa" translate="yes" xml:space="preserve">
          <source>Create a shallow clone with a history, excluding commits reachable from a specified remote branch or tag. This option can be specified multiple times.</source>
          <target state="translated">创建一个有历史记录的浅层克隆,其中不包括从指定的远程分支或标签中获取的提交。这个选项可以指定多次。</target>
        </trans-unit>
        <trans-unit id="543a21269e742ae7ebc9058bf397ba34f632562d" translate="yes" xml:space="preserve">
          <source>Create a stash entry (which is a regular commit object) and return its object name, without storing it anywhere in the ref namespace. This is intended to be useful for scripts. It is probably not the command you want to use; see &quot;push&quot; above.</source>
          <target state="translated">创建一个stash条目(这是一个常规的提交对象),并返回它的对象名,而不在ref命名空间的任何地方存储它。这对脚本很有用。这可能不是你想使用的命令,请参见上面的 &quot;push&quot;。</target>
        </trans-unit>
        <trans-unit id="b36a0ee3d907a9108a54a206fff8047195a2242d" translate="yes" xml:space="preserve">
          <source>Create a tag by using the tags_subdir instead of the branches_subdir specified during git svn init.</source>
          <target state="translated">使用 tags_subdir 而不是 git svn init 时指定的 branches_subdir 来创建一个标签。</target>
        </trans-unit>
        <trans-unit id="d1e89b6bf885576f5776e13a6adbdccbb0c64b51" translate="yes" xml:space="preserve">
          <source>Create a tag in the SVN repository. This is a shorthand for &lt;code&gt;branch -t&lt;/code&gt;.</source>
          <target state="translated">在SVN信息库中创建一个标签。这是 &lt;code&gt;branch -t&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="f83eaaff0df7b915922dc3a5427d0b2485d874b0" translate="yes" xml:space="preserve">
          <source>Create a tar archive that contains the contents of the latest commit on the current branch, and extract it in the &lt;code&gt;/var/tmp/junk&lt;/code&gt; directory.</source>
          <target state="translated">创建一个tar归档文件，其中包含当前分支上最新提交的内容，并将其解压缩到 &lt;code&gt;/var/tmp/junk&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="79432159892c99c66a4b92db80f46b317928f9e7" translate="yes" xml:space="preserve">
          <source>Create a topic branch and develop.</source>
          <target state="translated">建立专题支部,制定。</target>
        </trans-unit>
        <trans-unit id="3c6e23e4bafb619b381ac21bdc202b4da275dceb" translate="yes" xml:space="preserve">
          <source>Create a tree object from the current index</source>
          <target state="translated">从当前索引中创建一个树对象</target>
        </trans-unit>
        <trans-unit id="199cc87a17f205a9debb1daf10f2cfd04f927e64" translate="yes" xml:space="preserve">
          <source>Create an archive of files from a named tree</source>
          <target state="translated">从一个命名的树中创建一个文件档案</target>
        </trans-unit>
        <trans-unit id="11842098ab38c4b23c00972df92c03d934dd00f4" translate="yes" xml:space="preserve">
          <source>Create an empty Git repository or reinitialize an existing one</source>
          <target state="translated">创建一个空的 Git 仓库或重新初始化一个现有的仓库。</target>
        </trans-unit>
        <trans-unit id="4bf9b028076fc8c72d20bdece3ec7191ce92cd0a" translate="yes" xml:space="preserve">
          <source>Create and switch to a new branch at the same time:</source>
          <target state="translated">同时创建并切换到一个新的分支。</target>
        </trans-unit>
        <trans-unit id="e2fd9501d48be0c26b22e7150b7353eff7148f41" translate="yes" xml:space="preserve">
          <source>Create multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with &lt;code&gt;Content-Disposition: attachment&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;Content-Disposition: attachment&lt;/code&gt; 创建多部分/混合的附件，其第一部分是提交消息，补丁本身在第二部分中。</target>
        </trans-unit>
        <trans-unit id="09cc7488a79d34bbf5d70e088375c60a2a44d3fc" translate="yes" xml:space="preserve">
          <source>Create multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with &lt;code&gt;Content-Disposition: inline&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;Content-Disposition: inline&lt;/code&gt; 创建多部分/混合的附件，其第一部分是提交消息，补丁本身在第二部分。</target>
        </trans-unit>
        <trans-unit id="1fbaabd2de6436a9809de570bfef7e43943388cb" translate="yes" xml:space="preserve">
          <source>Create or update a branch with a new commit, recording one logical change to the project.</source>
          <target state="translated">创建或更新一个新提交的分支,记录项目的一个逻辑变化。</target>
        </trans-unit>
        <trans-unit id="b926e4f1bd2c9ddbabaf20296d6e0bdae2102d0d" translate="yes" xml:space="preserve">
          <source>Create parent folders. This parameter is equivalent to the parameter --parents on svn cp commands and is useful for non-standard repository layouts.</source>
          <target state="translated">创建父文件夹。这个参数相当于svn cp命令中的参数--parents,对于非标准的版本库布局很有用。</target>
        </trans-unit>
        <trans-unit id="008d223ce25dddb7eb7d24c361668074bbed6dad" translate="yes" xml:space="preserve">
          <source>Create the branch &lt;code&gt;experimental&lt;/code&gt; in the &lt;code&gt;origin&lt;/code&gt; repository by copying the current &lt;code&gt;master&lt;/code&gt; branch. This form is only needed to create a new branch or tag in the remote repository when the local name and the remote name are different; otherwise, the ref name on its own will work.</source>
          <target state="translated">通过复制当前的 &lt;code&gt;master&lt;/code&gt; 分支，在 &lt;code&gt;origin&lt;/code&gt; 存储库中创建 &lt;code&gt;experimental&lt;/code&gt; 分支。仅当本地名称和远程名称不同时，才需要使用此表单在远程存储库中创建新的分支或标记。否则，引用名称本身将起作用。</target>
        </trans-unit>
        <trans-unit id="157f2dfeff99612ce2fdbdc6f8123dc09aa74a0b" translate="yes" xml:space="preserve">
          <source>Create the branch&amp;rsquo;s reflog. This activates recording of all changes made to the branch ref, enabling use of date based sha1 expressions such as &quot;&amp;lt;branchname&amp;gt;@{yesterday}&quot;. Note that in non-bare repositories, reflogs are usually enabled by default by the &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; config option. The negated form &lt;code&gt;--no-create-reflog&lt;/code&gt; only overrides an earlier &lt;code&gt;--create-reflog&lt;/code&gt;, but currently does not negate the setting of &lt;code&gt;core.logAllRefUpdates&lt;/code&gt;.</source>
          <target state="translated">创建分支的引用日志。这将激活对分支引用所做的所有更改的记录，从而允许使用基于日期的sha1表达式，例如&amp;ldquo; &amp;lt;分支名称&amp;gt; @ {yesterday}&amp;rdquo;。请注意，在非裸存储库中，通常默认情况下通过 &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; 配置选项启用引用日志。否定的形式 &lt;code&gt;--no-create-reflog&lt;/code&gt; 仅覆盖更早的 &lt;code&gt;--create-reflog&lt;/code&gt; ，但当前不否定 &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; 的设置。</target>
        </trans-unit>
        <trans-unit id="6e2b0a6de869fa2e1ebef49223a669515c01db9f" translate="yes" xml:space="preserve">
          <source>Create the new branch&amp;rsquo;s reflog; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">创建新分支的引用日志；有关详细信息，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="770931923d2f84baa80a7c6281d4bb0c7e7ff5dc" translate="yes" xml:space="preserve">
          <source>Create, list, delete or verify a tag object signed with GPG</source>
          <target state="translated">创建、列出、删除或验证用GPG签名的标签对象。</target>
        </trans-unit>
        <trans-unit id="884d013fa41e619bec3679b144edae3781c7f0c5" translate="yes" xml:space="preserve">
          <source>Create, list, delete refs to replace objects</source>
          <target state="translated">创建、列出、删除替换对象的参考文献。</target>
        </trans-unit>
        <trans-unit id="b126e5a5d6c912b3969ba9d70dcd92e7124db848" translate="yes" xml:space="preserve">
          <source>Creates (or recreates) the named branch, optionally starting from a specific revision. The reset command allows a frontend to issue a new &lt;code&gt;from&lt;/code&gt; command for an existing branch, or to create a new branch from an existing commit without creating a new commit.</source>
          <target state="translated">创建（或重新创建）命名分支，可以选择从特定版本开始。reset命令允许前端为现有分支发出新的 &lt;code&gt;from&lt;/code&gt; 命令，或者从现有提交创建新分支而不创建新提交。</target>
        </trans-unit>
        <trans-unit id="999e99d0bbec6ceb96391dfde9cf6cc8fcd81661" translate="yes" xml:space="preserve">
          <source>Creates a file holding the contents of the blob specified by sha1. It returns the name of the temporary file in the following format: .merge_file_XXXXX</source>
          <target state="translated">创建一个保存由 sha1 指定的 blob 内容的文件。它返回临时文件的名称,格式如下:.merge_file_XXXXX。</target>
        </trans-unit>
        <trans-unit id="09d3cd201fc386ccac2ad9f5c22bafbf8bdbb2f4" translate="yes" xml:space="preserve">
          <source>Creates a local branch, &lt;code&gt;master&lt;/code&gt; from this remote and checks it out.</source>
          <target state="translated">创建一个本地分支，从此远程 &lt;code&gt;master&lt;/code&gt; 并将其检出。</target>
        </trans-unit>
        <trans-unit id="7f64654581811c2b404b1b8dce4e1e1130a9678f" translate="yes" xml:space="preserve">
          <source>Creates a new branch or updates an existing branch by creating a new commit and updating the branch to point at the newly created commit.</source>
          <target state="translated">创建一个新的分支或更新一个现有的分支,方法是创建一个新的提交,并更新分支指向新创建的提交。</target>
        </trans-unit>
        <trans-unit id="1d59a731f68874f36286c257dc8063d7c2d003c5" translate="yes" xml:space="preserve">
          <source>Creates a new commit object based on the provided tree object and emits the new commit object id on stdout. The log message is read from the standard input, unless &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; options are given.</source>
          <target state="translated">基于提供的树对象创建一个新的提交对象，并在stdout上发出新的提交对象ID。除非给出 &lt;code&gt;-m&lt;/code&gt; 或 &lt;code&gt;-F&lt;/code&gt; 选项，否则将从标准输入中读取日志消息。</target>
        </trans-unit>
        <trans-unit id="47450bdc6c156b7e9d8dff8eb5153c36f0034363" translate="yes" xml:space="preserve">
          <source>Creates a tag object</source>
          <target state="translated">创建一个标签对象</target>
        </trans-unit>
        <trans-unit id="befea765dea04bdbe90515b52ec037d05fcd654f" translate="yes" xml:space="preserve">
          <source>Creates a temporary file with a blob&amp;rsquo;s contents</source>
          <target state="translated">创建一个包含blob内容的临时文件</target>
        </trans-unit>
        <trans-unit id="352027cd4f1050e7a8d58f4759fd4887117240f0" translate="yes" xml:space="preserve">
          <source>Creates a tree object using the current index. The name of the new tree object is printed to standard output.</source>
          <target state="translated">使用当前的索引创建一个树对象。新树对象的名称被打印到标准输出。</target>
        </trans-unit>
        <trans-unit id="7652dba54710524ad06e288b0394d9ec8f781534" translate="yes" xml:space="preserve">
          <source>Creates an annotated tag object from an existing commit or branch. Lightweight tags are not supported by this command, as they are not recommended for recording meaningful points in time.</source>
          <target state="translated">从现有的提交或分支中创建一个标注的标签对象。此命令不支持轻量级标签,因为不建议用它们来记录有意义的时间点。</target>
        </trans-unit>
        <trans-unit id="94955619715d4d7ab1e29b4a0777170b742991c7" translate="yes" xml:space="preserve">
          <source>Creates an annotated tag referring to a specific commit. To create lightweight (non-annotated) tags see the &lt;code&gt;reset&lt;/code&gt; command below.</source>
          <target state="translated">创建引用特定提交的带注释的标签。要创建轻量级（无注释）标签，请参见下面的 &lt;code&gt;reset&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="1c5caa9b586b6725b423618f01dee45981d01339" translate="yes" xml:space="preserve">
          <source>Creates an archive of the specified format containing the tree structure for the named tree, and writes it out to the standard output. If &amp;lt;prefix&amp;gt; is specified it is prepended to the filenames in the archive.</source>
          <target state="translated">创建指定格式的存档，其中包含命名树的树结构，并将其写到标准输出中。如果指定了&amp;lt;prefix&amp;gt;，它会放在归档文件中的文件名之前。</target>
        </trans-unit>
        <trans-unit id="902be57432c35cdc5fd0ebc974090ec5fe10886f" translate="yes" xml:space="preserve">
          <source>Creates an empty Git repository in a subdirectory called &lt;code&gt;project&lt;/code&gt;.</source>
          <target state="translated">在名为 &lt;code&gt;project&lt;/code&gt; 的子目录中创建一个空的Git存储库。</target>
        </trans-unit>
        <trans-unit id="d5bd8f97656dc6346e6c11ca45adb1cb8cf3739a" translate="yes" xml:space="preserve">
          <source>Creates and checks out a new branch named &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; starting from the commit at which the &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; was originally created, applies the changes recorded in &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; to the new working tree and index. If that succeeds, and &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is a reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;, it then drops the &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">从最初创建 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 的提交开始创建并签 &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; 为&amp;lt;branchname&amp;gt;的新分支，并将记录在 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 中的更改应用于新的工作树和索引。如果成功，并且 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 是 &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 形式的引用，则它将删除 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdbbe8fe0fb510b54456d0e5f7552d0ff50cdb17" translate="yes" xml:space="preserve">
          <source>Creates and checks out a new branch named &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; starting from the commit at which the &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; was originally created, applies the changes recorded in &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; to the new working tree and index. If that succeeds, and &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is a reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;, it then drops the &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt;. When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, applies the latest one.</source>
          <target state="translated">创建并签出一个名为新分支 &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; 开始从提交在该 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 最初创建，应用记录在修改 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 新的工作树和索引。如果成功，并且 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 是 &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 形式的引用，则它将删除 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 。如果没有给出 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; ，则应用最新的。</target>
        </trans-unit>
        <trans-unit id="817de4fcd985997655ed18eb9db24df013f605f3" translate="yes" xml:space="preserve">
          <source>Creates graft commits for all entries in &lt;code&gt;$GIT_DIR/info/grafts&lt;/code&gt; and deletes that file upon success. The purpose is to help users with transitioning off of the now-deprecated graft file.</source>
          <target state="translated">为 &lt;code&gt;$GIT_DIR/info/grafts&lt;/code&gt; 所有条目创建移植提交，并在成功后删除该文件。目的是帮助用户过渡到现已弃用的嫁接文件。</target>
        </trans-unit>
        <trans-unit id="dffa1bc89fe4773c581e2bab0e59b1fe8148dfd2" translate="yes" xml:space="preserve">
          <source>Creates the branch &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; and start it at &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;; if it already exists, then reset it to &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;. This is equivalent to running &quot;git branch&quot; with &quot;-f&quot;; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">创建分支 &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; 并在 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 处启动它；如果已经存在，则将其重置为 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 。这等效于用&amp;ldquo; -f&amp;rdquo;运行&amp;ldquo; git branch&amp;rdquo;；有关详细信息，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="051c90bf7349afef9519ebfd754be98e47ed9dee" translate="yes" xml:space="preserve">
          <source>Creating a branch in such a configuration requires disambiguating which location to use using the -d or --destination flag:</source>
          <target state="translated">在这样的配置中创建分支,需要使用-d或-d-destination标志来确定使用哪个位置。</target>
        </trans-unit>
        <trans-unit id="e6bedfd34ce489d63a7de42dd785dfdc0700c1e9" translate="yes" xml:space="preserve">
          <source>Creating a changelog and tarball for a software release</source>
          <target state="translated">为软件发行版创建变更日志和压缩包。</target>
        </trans-unit>
        <trans-unit id="c40a17b4008177323999b06c207c30d124e6c258" translate="yes" xml:space="preserve">
          <source>Creating a git repository</source>
          <target state="translated">创建一个git版本库</target>
        </trans-unit>
        <trans-unit id="040db03d97cbb631e8d9e6687acd4b2ef2582aa9" translate="yes" xml:space="preserve">
          <source>Creating a new Git repository couldn&amp;rsquo;t be easier: all Git repositories start out empty, and the only thing you need to do is find yourself a subdirectory that you want to use as a working tree - either an empty one for a totally new project, or an existing working tree that you want to import into Git.</source>
          <target state="translated">创建一个新的Git存储库再简单不过了：所有Git存储库开始都是空的，唯一要做的就是找到一个自己的子目录，用作工作树-要么是一个空目录，一个全新的项目，或您要导入到Git的现有工作树。</target>
        </trans-unit>
        <trans-unit id="00e49b6089f98df76d1261d9c963ee126709d119" translate="yes" xml:space="preserve">
          <source>Creating a new branch</source>
          <target state="translated">创建一个新的分支</target>
        </trans-unit>
        <trans-unit id="c39cd6567c9d07f33e0b16412b2e647902776ceb" translate="yes" xml:space="preserve">
          <source>Creating a new commit takes three steps:</source>
          <target state="translated">创建一个新的提交需要三个步骤。</target>
        </trans-unit>
        <trans-unit id="8ab78a3735f73dea4916eb1431c8608a2d083ad2" translate="yes" xml:space="preserve">
          <source>Creating a new commit that reverts an earlier change is very easy; just pass the &lt;a href=&quot;git-revert&quot;&gt;git-revert[1]&lt;/a&gt; command a reference to the bad commit; for example, to revert the most recent commit:</source>
          <target state="translated">创建一个新的提交以恢复先前的更改非常容易；只需将&lt;a href=&quot;git-revert&quot;&gt;git-revert [1]&lt;/a&gt;命令传递给错误提交的引用即可；例如，还原最近的提交：</target>
        </trans-unit>
        <trans-unit id="324b268505a0bd944ee2d5d30c8a3d50fc28d90f" translate="yes" xml:space="preserve">
          <source>Creating a new repository</source>
          <target state="translated">创建一个新的存储库</target>
        </trans-unit>
        <trans-unit id="36dbdbb03a117f7df33bdb409d5809a8b5ea5e6e" translate="yes" xml:space="preserve">
          <source>Creating a new repository from scratch is very easy:</source>
          <target state="translated">从头开始创建一个新的版本库是非常容易的。</target>
        </trans-unit>
        <trans-unit id="88eec46a3edc17fddca4fd44d28bb64f8780df72" translate="yes" xml:space="preserve">
          <source>Creating a tree object is trivial, and is done with &lt;code&gt;git write-tree&lt;/code&gt;. There are no options or other input: &lt;code&gt;git write-tree&lt;/code&gt; will take the current index state, and write an object that describes that whole index. In other words, we&amp;rsquo;re now tying together all the different filenames with their contents (and their permissions), and we&amp;rsquo;re creating the equivalent of a Git &quot;directory&quot; object:</source>
          <target state="translated">创建树对象很简单，可以使用 &lt;code&gt;git write-tree&lt;/code&gt; 完成。没有选项或其他输入： &lt;code&gt;git write-tree&lt;/code&gt; 将采用当前索引状态，并编写一个描述整个索引的对象。换句话说，我们现在将所有不同的文件名及其内容（及其权限）联系在一起，并创建与Git&amp;ldquo;目录&amp;rdquo;对象等效的文件：</target>
        </trans-unit>
        <trans-unit id="719e91bca781d7da4469d32275de7f00e97366b0" translate="yes" xml:space="preserve">
          <source>Creating an archive</source>
          <target state="translated">创建档案</target>
        </trans-unit>
        <trans-unit id="57d940de5ca0935e018fd03ec556851a3258029c" translate="yes" xml:space="preserve">
          <source>Creating good commit messages</source>
          <target state="translated">创建良好的提交信息</target>
        </trans-unit>
        <trans-unit id="d793460efe87481af6fc2a69bf4007ae5b376697" translate="yes" xml:space="preserve">
          <source>Creating replacement objects</source>
          <target state="translated">创建替换对象</target>
        </trans-unit>
        <trans-unit id="ab3dc2ecc52838a3e77a21918b25403d09705634" translate="yes" xml:space="preserve">
          <source>Creating tags</source>
          <target state="translated">创建标签</target>
        </trans-unit>
        <trans-unit id="b0acbd1aa53ddfa814233d47e25a83dac45b77c7" translate="yes" xml:space="preserve">
          <source>Creating the commit using the content you told Git about in step 2.</source>
          <target state="translated">使用第二步中告诉 Git 的内容创建提交。</target>
        </trans-unit>
        <trans-unit id="4d969b5791f8a038b7f947a6c2bb33127dd04018" translate="yes" xml:space="preserve">
          <source>Creating the perfect patch series</source>
          <target state="translated">创建完美的补丁系列</target>
        </trans-unit>
        <trans-unit id="a2955539fd234d4e940b20d8a9e91ef656e850f2" translate="yes" xml:space="preserve">
          <source>Creating, deleting, and modifying branches is quick and easy; here&amp;rsquo;s a summary of the commands:</source>
          <target state="translated">创建，删除和修改分支非常容易。这是命令的摘要：</target>
        </trans-unit>
        <trans-unit id="3c7835c41262e0651be74f2c3160cc75a963df48" translate="yes" xml:space="preserve">
          <source>Credential contexts</source>
          <target state="translated">凭证背景</target>
        </trans-unit>
        <trans-unit id="e937ff4d2bc216cfc4de72aa94ecda9f1b6485b0" translate="yes" xml:space="preserve">
          <source>Credential helpers are programs executed by Git to fetch or save credentials from and to long-term storage (where &quot;long-term&quot; is simply longer than a single Git process; e.g., credentials may be stored in-memory for a few minutes, or indefinitely on disk).</source>
          <target state="translated">凭证助手是Git执行的程序,用于从Git中获取或保存凭证,并将其长期保存(这里的 &quot;长期 &quot;是指比单个Git进程更长的时间,例如,凭证可能会在内存中保存几分钟,也可能会无限期地保存在磁盘上)。</target>
        </trans-unit>
        <trans-unit id="458543c678ae3dd16b97b21c03b00e9eaaddd45b" translate="yes" xml:space="preserve">
          <source>Credential helpers to cache or store passwords, or to interact with a system password wallet or keychain.</source>
          <target state="translated">凭证助手来缓存或存储密码,或与系统密码钱包或钥匙链交互。</target>
        </trans-unit>
        <trans-unit id="2fe8ef32f03f0033712fed8d5429cd4799dc6471" translate="yes" xml:space="preserve">
          <source>Credential helpers, on the other hand, are external programs from which Git can request both usernames and passwords; they typically interface with secure storage provided by the OS or other programs.</source>
          <target state="translated">而凭证助手则是Git可以请求用户名和密码的外部程序,它们通常与操作系统或其他程序提供的安全存储接口。</target>
        </trans-unit>
        <trans-unit id="d62300d6222786cbbaa983d6e9106aadd99d8d3d" translate="yes" xml:space="preserve">
          <source>Credential storage will by default write to the first existing file in the list. If none of these files exist, &lt;code&gt;~/.git-credentials&lt;/code&gt; will be created and written to.</source>
          <target state="translated">默认情况下，凭据存储将写入列表中的第一个现有文件。如果这些文件都不存在，将创建 &lt;code&gt;~/.git-credentials&lt;/code&gt; 并将其写入。</target>
        </trans-unit>
        <trans-unit id="dd097a229701c1db23e0a192b0e48637872c75b8" translate="yes" xml:space="preserve">
          <source>Credentials</source>
          <target state="translated">Credentials</target>
        </trans-unit>
        <trans-unit id="04644cadae9bd99f31c78c3cb1b0f35e0308dcbf" translate="yes" xml:space="preserve">
          <source>Cross-platform issues</source>
          <target state="translated">跨平台问题</target>
        </trans-unit>
        <trans-unit id="cdcc78e86a10c02802811b9eb8dc2446a5f35189" translate="yes" xml:space="preserve">
          <source>Currently a dummy fall-through function implemented as a wrapper around &lt;code&gt;printf(1)&lt;/code&gt; with variables expanded by the &lt;a href=&quot;git-sh-i18n--envsubst&quot;&gt;git-sh-i18n--envsubst[1]&lt;/a&gt; helper. Will be replaced by a real gettext implementation in a later version.</source>
          <target state="translated">当前，一个伪&lt;a href=&quot;git-sh-i18n--envsubst&quot;&gt;掉线&lt;/a&gt;函数实现为 &lt;code&gt;printf(1)&lt;/code&gt; 的包装，并由git-sh-i18n--envsubst [1]辅助函数扩展了变量。在更高版本中将由真实的gettext实现替换。</target>
        </trans-unit>
        <trans-unit id="70e47cc9d61ac64c248d54da47cefec3c90e34c9" translate="yes" xml:space="preserve">
          <source>Currently a dummy fall-through function implemented as a wrapper around &lt;code&gt;printf(1)&lt;/code&gt; with variables expanded by the git-sh-i18n{litdd}envsubst[1] helper. Will be replaced by a real gettext implementation in a later version.</source>
          <target state="translated">当前，一个伪掉线函数实现为 &lt;code&gt;printf(1)&lt;/code&gt; 的包装，并由git-sh-i18n {litdd} envsubst [1]辅助函数扩展了变量。在更高版本中将由真实的gettext实现替换。</target>
        </trans-unit>
        <trans-unit id="87c8476a8fe8246e9cc89649a2d435a7d613617a" translate="yes" xml:space="preserve">
          <source>Currently a dummy fall-through function implemented as a wrapper around &lt;code&gt;printf(1)&lt;/code&gt;. Will be replaced by a real gettext implementation in a later version.</source>
          <target state="translated">当前，一个伪掉线函数实现为 &lt;code&gt;printf(1)&lt;/code&gt; 的包装器。在更高版本中将由真实的gettext实现替换。</target>
        </trans-unit>
        <trans-unit id="d0a323c8531b99ccfcb3b5693dd52db2df3f23ff" translate="yes" xml:space="preserve">
          <source>Currently available providers are &lt;strong&gt;&quot;gravatar&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;picon&quot;&lt;/strong&gt;. Only one provider at a time can be selected (&lt;code&gt;default&lt;/code&gt; is one element list). If an unknown provider is specified, the feature is disabled. &lt;strong&gt;Note&lt;/strong&gt; that some providers might require extra Perl packages to be installed; see &lt;code&gt;gitweb/INSTALL&lt;/code&gt; for more details.</source>
          <target state="translated">当前可用的提供者是&lt;strong&gt;&amp;ldquo; gravatar&amp;rdquo;&lt;/strong&gt;和&lt;strong&gt;&amp;ldquo; picon&amp;rdquo;&lt;/strong&gt;。一次只能选择一个提供程序（ &lt;code&gt;default&lt;/code&gt; 为一个元素列表）。如果指定了未知的提供程序，则该功能将被禁用。&lt;strong&gt;请注意&lt;/strong&gt;，某些提供程序可能需要安装额外的Perl软件包。有关更多详细信息，请参见 &lt;code&gt;gitweb/INSTALL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="717fdd8a8fe2000b9c0c629f6c5d467ecf014cfe" translate="yes" xml:space="preserve">
          <source>Currently for internal use only. Set a prefix which gives a path from above a repository down to its root. One use is to give submodules context about the superproject that invoked it.</source>
          <target state="translated">目前只供内部使用。设置一个前缀,它给出了一个从上面的版本库向下到根的路径。一个用途是给子模块提供关于调用它的超级项目的上下文。</target>
        </trans-unit>
        <trans-unit id="44c98bf149dc1ad4ae7705ea185729a070e4f82e" translate="yes" xml:space="preserve">
          <source>Currently recognized fields are:</source>
          <target state="translated">目前承认的领域有:</target>
        </trans-unit>
        <trans-unit id="96e2ac5c1dd546ca41ecd7f60aa78cd7c4c66ca3" translate="yes" xml:space="preserve">
          <source>Currently the command updates the following files. Please see &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for description of what they are for:</source>
          <target state="translated">当前，该命令更新以下文件。请参阅&lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt;了解它们的用途：</target>
        </trans-unit>
        <trans-unit id="58cad17f651d6b9e5474187d9de4ce3c98aebe87" translate="yes" xml:space="preserve">
          <source>Currently this is used by &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; and &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; when &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; or &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; will checkout the &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; branch on another remote, and by &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt; when &lt;code&gt;git worktree add&lt;/code&gt; refers to a remote branch. This setting might be used for other checkout-like commands or functionality in the future.</source>
          <target state="translated">目前，这是用来通过&lt;a href=&quot;git-switch&quot;&gt;GIT-开关[1]&lt;/a&gt;和&lt;a href=&quot;git-checkout&quot;&gt;git的结账[1]&lt;/a&gt;时 &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; 或 &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; 将检出 &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; 遥控器上的另一分支，并且通过&lt;a href=&quot;git-worktree&quot;&gt;GIT-worktree [1]&lt;/a&gt;时 &lt;code&gt;git worktree add&lt;/code&gt; 引用远程分支。将来，此设置可能会用于其他类似结帐的命令或功能。</target>
        </trans-unit>
        <trans-unit id="5c5b7b525cb2eea52baefaf69e3b28ebe43a1b5d" translate="yes" xml:space="preserve">
          <source>Currently, this is always &quot;r1&quot; for the main repository. This field is in anticipation of in-proc submodules in the future.</source>
          <target state="translated">目前,对于主仓库来说,这总是 &quot;r1&quot;。这个字段是为将来的程序内子模块做准备的。</target>
        </trans-unit>
        <trans-unit id="61e7655efd8d1ffbd67943a6b48d51eb7bcb7281" translate="yes" xml:space="preserve">
          <source>Custom commands may also be specified.</source>
          <target state="translated">也可以指定自定义命令。</target>
        </trans-unit>
        <trans-unit id="071b814c810acef4a305418b7617eb91825385c2" translate="yes" xml:space="preserve">
          <source>Custom helpers</source>
          <target state="translated">自定义助手</target>
        </trans-unit>
        <trans-unit id="441c592e043641e18ffb271284d516b14fe37bc0" translate="yes" xml:space="preserve">
          <source>Custom macro attributes can be defined only in top-level gitattributes files (&lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt;, the &lt;code&gt;.gitattributes&lt;/code&gt; file at the top level of the working tree, or the global or system-wide gitattributes files), not in &lt;code&gt;.gitattributes&lt;/code&gt; files in working tree subdirectories. The built-in macro attribute &quot;binary&quot; is equivalent to:</source>
          <target state="translated">自定义宏属性只能在顶级gitattributes文件（ &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; ，位于工作树顶级的 &lt;code&gt;.gitattributes&lt;/code&gt; 文件或全局或系统范围的gitattributes文件）中定义，而不能在 &lt;code&gt;.gitattributes&lt;/code&gt; 文件中定义在工作树子目录中。内置的宏属性&amp;ldquo; binary&amp;rdquo;等效于：</target>
        </trans-unit>
        <trans-unit id="3e39087b89619b8882da1dce388a569a8e549573" translate="yes" xml:space="preserve">
          <source>Customizing word diff</source>
          <target state="translated">自定义单词差异</target>
        </trans-unit>
        <trans-unit id="a28effa0c8276898e045b96b9d1ba0f760229cf5" translate="yes" xml:space="preserve">
          <source>Cute name for &lt;a href=&quot;#def_core_git&quot;&gt;core Git&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_core_git&quot;&gt;核心Git的&lt;/a&gt;可爱名字。</target>
        </trans-unit>
        <trans-unit id="7033e3578a96d1e9400e567b4c0c23cd21d2c6e2" translate="yes" xml:space="preserve">
          <source>Cute name for programs and program suites depending on &lt;a href=&quot;#def_core_git&quot;&gt;core Git&lt;/a&gt;, presenting a high level access to core Git. Porcelains expose more of a &lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt; interface than the &lt;a href=&quot;#def_plumbing&quot;&gt;plumbing&lt;/a&gt;.</source>
          <target state="translated">取决于&lt;a href=&quot;#def_core_git&quot;&gt;核心Git的&lt;/a&gt;程序和程序套件的可爱名称，表示对核心Git的高级访问。瓷器比&lt;a href=&quot;#def_plumbing&quot;&gt;水暖器&lt;/a&gt;更能暴露出&lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt;界面。</target>
        </trans-unit>
        <trans-unit id="c276dc0072d6e81f335296db56eec5a1bdc2bed9" translate="yes" xml:space="preserve">
          <source>Cutting down bisection by giving more parameters to bisect start</source>
          <target state="translated">通过提供更多的参数来减少二分法的开始。</target>
        </trans-unit>
        <trans-unit id="9e78b27ca0bc764cd94adfc012f3ea2c4c32e8ff" translate="yes" xml:space="preserve">
          <source>D: deletion of a file</source>
          <target state="translated">D:删除文件</target>
        </trans-unit>
        <trans-unit id="4ecdb0fd037d3dafe4f4e2a354bcfe9ed6b3a537" translate="yes" xml:space="preserve">
          <source>DAG</source>
          <target state="translated">DAG</target>
        </trans-unit>
        <trans-unit id="5a7759c99cc9f0c4d7897147bc310328ba1b2ac4" translate="yes" xml:space="preserve">
          <source>Dangling objects</source>
          <target state="translated">悬挂物</target>
        </trans-unit>
        <trans-unit id="d8788504c151968602d8ccc8fc1d2150b059a336" translate="yes" xml:space="preserve">
          <source>Data Messages</source>
          <target state="translated">数据信息</target>
        </trans-unit>
        <trans-unit id="4b1f2d8717c44b631b95852544cce5392a548364" translate="yes" xml:space="preserve">
          <source>Data events are tagged with the active thread name. They are used to report the per-thread parameters.</source>
          <target state="translated">数据事件被标记为活动线程名称。它们用于报告每个线程的参数。</target>
        </trans-unit>
        <trans-unit id="4bee01a9236d0c6bfb9a9c78d868c75e8d0aa93e" translate="yes" xml:space="preserve">
          <source>Data messages added to a region.</source>
          <target state="translated">数据信息添加到一个区域。</target>
        </trans-unit>
        <trans-unit id="e5169e0ca17e29bbdf784cf8e268aafa8934e51d" translate="yes" xml:space="preserve">
          <source>Data written to stdin of the specified &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; is assumed to be sent to a git:// server, git-upload-pack, git-receive-pack or git-upload-archive (depending on situation), and data read from stdout of &amp;lt;command&amp;gt; is assumed to be received from the same service.</source>
          <target state="translated">假定写入指定 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 的 stdin的数据被发送到git：//服务器，git-upload-pack，git-receive-pack或git-upload-archive（取决于情况），并且从中读取数据假定&amp;lt;command&amp;gt;的stdout是从同一服务接收的。</target>
        </trans-unit>
        <trans-unit id="ce4b9abd8c39b6edc1077cdc5fbd525d6784cc17" translate="yes" xml:space="preserve">
          <source>Database backend</source>
          <target state="translated">数据库后端</target>
        </trans-unit>
        <trans-unit id="88e3b202bead5498b3c26df9a24b06dbb71997e1" translate="yes" xml:space="preserve">
          <source>Database name. The exact meaning depends on the selected database driver, for SQLite this is a filename. Supports variable substitution (see below). May not contain semicolons (&lt;code&gt;;&lt;/code&gt;). Default: &lt;code&gt;%Ggitcvs.%m.sqlite&lt;/code&gt;</source>
          <target state="translated">数据库名称。确切含义取决于所选的数据库驱动程序，对于SQLite，这是文件名。支持变量替换（请参见下文）。不得包含分号（ &lt;code&gt;;&lt;/code&gt; ）。默认值： &lt;code&gt;%Ggitcvs.%m.sqlite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec7281a9f03369f6fca87bc704dcd61eb8d42fc2" translate="yes" xml:space="preserve">
          <source>Database password. Only useful if setting &lt;code&gt;dbDriver&lt;/code&gt;, since SQLite has no concept of database passwords.</source>
          <target state="translated">数据库密码。仅在设置 &lt;code&gt;dbDriver&lt;/code&gt; 时有用，因为SQLite没有数据库密码的概念。</target>
        </trans-unit>
        <trans-unit id="6cb047cae02c9bba7b0e3391be2c746d7c4c4487" translate="yes" xml:space="preserve">
          <source>Database table name prefix. Prepended to the names of any database tables used, allowing a single database to be used for several repositories. Supports variable substitution (see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details). Any non-alphabetic characters will be replaced with underscores.</source>
          <target state="translated">数据库表名称前缀。在所使用的任何数据库表的名称之前，可以将一个数据库用于多个存储库。支持变量替换（有关详细信息，请参见&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;）。任何非字母字符将被下划线替换。</target>
        </trans-unit>
        <trans-unit id="ba01b17d3115051f1a477d09b8cec632c83f89d1" translate="yes" xml:space="preserve">
          <source>Database table name prefix. Supports variable substitution (see below). Any non-alphabetic characters will be replaced with underscores.</source>
          <target state="translated">数据库表名前缀。支持变量替换(见下文)。任何非字母字符将被下划线代替。</target>
        </trans-unit>
        <trans-unit id="a13030629fc1c33a937c268b335dcb627627128f" translate="yes" xml:space="preserve">
          <source>Database used by git-cvsserver to cache revision information derived from the Git repository. The exact meaning depends on the used database driver, for SQLite (which is the default driver) this is a filename. Supports variable substitution (see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details). May not contain semicolons (&lt;code&gt;;&lt;/code&gt;). Default: &lt;code&gt;%Ggitcvs.%m.sqlite&lt;/code&gt;</source>
          <target state="translated">git-cvsserver用于缓存从Git存储库派生的修订信息的数据库。确切含义取决于使用的数据库驱动程序，对于SQLite（这是默认驱动程序），这是文件名。支持变量替换（有关详细信息，请参见&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;）。不得包含分号（ &lt;code&gt;;&lt;/code&gt; ）。默认值： &lt;code&gt;%Ggitcvs.%m.sqlite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb3915ed16cfcd6e4965fc92e19dfdb3f354cb3d" translate="yes" xml:space="preserve">
          <source>Database user and password. Only useful if setting &lt;code&gt;gitcvs.dbDriver&lt;/code&gt;, since SQLite has no concept of database users and/or passwords. &lt;code&gt;gitcvs.dbUser&lt;/code&gt; supports variable substitution (see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details).</source>
          <target state="translated">数据库用户和密码。仅在设置 &lt;code&gt;gitcvs.dbDriver&lt;/code&gt; 时有用，因为SQLite没有数据库用户和/或密码的概念。 &lt;code&gt;gitcvs.dbUser&lt;/code&gt; 支持变量替换（有关详细信息，请参见&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="161446d05bce5c35b9bb58271e5e12dbad31f437" translate="yes" xml:space="preserve">
          <source>Database user. Only useful if setting &lt;code&gt;dbDriver&lt;/code&gt;, since SQLite has no concept of database users. Supports variable substitution (see below).</source>
          <target state="translated">数据库用户。仅在设置 &lt;code&gt;dbDriver&lt;/code&gt; 时有用，因为SQLite没有数据库用户的概念。支持变量替换（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="3fcd7b7ae338d342a7674f84f0c1f730e65ba9c0" translate="yes" xml:space="preserve">
          <source>Date Formats</source>
          <target state="translated">日期格式</target>
        </trans-unit>
        <trans-unit id="adf2309d1c810bb87f6dbfe62284445270cc7ea8" translate="yes" xml:space="preserve">
          <source>Date formats</source>
          <target state="translated">日期格式</target>
        </trans-unit>
        <trans-unit id="8dd9c41bb94ad9101ba89e79d1af605fb457f638" translate="yes" xml:space="preserve">
          <source>Debug gitignore / exclude files</source>
          <target state="translated">调试gitignore/exclude文件。</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="49a655454d59f6253c27bfd18c23a18e1916a070" translate="yes" xml:space="preserve">
          <source>Debugging would be easier if the fallback configuration file (&lt;code&gt;/etc/gitweb.conf&lt;/code&gt;) and environment variable to override its location (&lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt;) had names reflecting their &quot;fallback&quot; role. The current names are kept to avoid breaking working setups.</source>
          <target state="translated">如果后备配置文件（ &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; ）和环境变量覆盖其位置（ &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; ）的名称反映了其&amp;ldquo;后备&amp;rdquo;角色，则调试会更容易。保留当前名称，以避免破坏工作设置。</target>
        </trans-unit>
        <trans-unit id="25623d3d6597110b3dc53adcb06a990460c0bdc2" translate="yes" xml:space="preserve">
          <source>Decide not to merge. The only clean-ups you need are to reset the index file to the &lt;code&gt;HEAD&lt;/code&gt; commit to reverse 2. and to clean up working tree changes made by 2. and 3.; &lt;code&gt;git merge --abort&lt;/code&gt; can be used for this.</source>
          <target state="translated">决定不合并。您需要执行的唯一清除操作是将索引文件重置为 &lt;code&gt;HEAD&lt;/code&gt; commit以反转2，并清除2和3对工作树所做的更改。 &lt;code&gt;git merge --abort&lt;/code&gt; 可用于此目的。</target>
        </trans-unit>
        <trans-unit id="461dd8f77b9a26481c7b52783d8ce19864c00a87" translate="yes" xml:space="preserve">
          <source>Deepen or shorten the history of a shallow repository to exclude commits reachable from a specified remote branch or tag. This option can be specified multiple times.</source>
          <target state="translated">加深或缩短浅层仓库的历史记录,以排除从指定的远程分支或标签中可以到达的提交。这个选项可以指定多次。</target>
        </trans-unit>
        <trans-unit id="fc0ba6fe75550f8aa46ad04018df5509f99a82b6" translate="yes" xml:space="preserve">
          <source>Deepen or shorten the history of a shallow repository to include all reachable commits after &amp;lt;date&amp;gt;.</source>
          <target state="translated">加深或缩短浅存储库的历史记录，以包括&amp;lt;date&amp;gt;之后的所有可到达的提交。</target>
        </trans-unit>
        <trans-unit id="b85c21ce1c36df4fd97d8d980d2975325f47caee" translate="yes" xml:space="preserve">
          <source>Deepens the history of a shallow repository based on time.</source>
          <target state="translated">以时间为基础,深化浅显库的历史。</target>
        </trans-unit>
        <trans-unit id="0b2ab70fb2f23273e2c8d92c10b43dfc891dac12" translate="yes" xml:space="preserve">
          <source>Deepens the history of a shallow repository excluding ref. Multiple options add up.</source>
          <target state="translated">深化浅显贮藏室的历史,不包括裁判。多个选项加起来。</target>
        </trans-unit>
        <trans-unit id="e87814f404c8c230e2c89d6eeca5b7883036cc70" translate="yes" xml:space="preserve">
          <source>Deepens the history of a shallow repository relative to current boundary. Only valid when used with &quot;option depth&quot;.</source>
          <target state="translated">加深浅层存储库相对于当前边界的历史。仅当与 &quot;选项深度 &quot;一起使用时有效。</target>
        </trans-unit>
        <trans-unit id="919906ebf6455d2b9a3b4a65ed3f4d4732631f26" translate="yes" xml:space="preserve">
          <source>Deepens the history of a shallow repository.</source>
          <target state="translated">深化了浅显贮藏室的历史。</target>
        </trans-unit>
        <trans-unit id="3a0a0372c4178042ae74a7b526723e3fc6d8263f" translate="yes" xml:space="preserve">
          <source>Deeper technical details are often marked as Notes, which you can skip on your first reading.</source>
          <target state="translated">更深层次的技术细节往往被标记为Notes,你可以在第一次阅读时跳过。</target>
        </trans-unit>
        <trans-unit id="c4f869ad0eb5d764449c5b4f72c2193187ec9d1f" translate="yes" xml:space="preserve">
          <source>Default backend to use for rebasing. Possible choices are &lt;code&gt;apply&lt;/code&gt; or &lt;code&gt;merge&lt;/code&gt;. In the future, if the merge backend gains all remaining capabilities of the apply backend, this setting may become unused.</source>
          <target state="translated">用于后端的默认后端。可能的选择是 &lt;code&gt;apply&lt;/code&gt; 或 &lt;code&gt;merge&lt;/code&gt; 。将来，如果合并后端获得了应用后端的所有剩余功能，则此设置可能变得不可用。</target>
        </trans-unit>
        <trans-unit id="99090e0d8272b9b94f21bc377653439f260895be" translate="yes" xml:space="preserve">
          <source>Default behavior is to replace at most one line. This replaces all lines matching the key (and optionally the &lt;code&gt;value-pattern&lt;/code&gt;).</source>
          <target state="translated">默认行为是最多替换一行。这将替换与键（以及可选的 &lt;code&gt;value-pattern&lt;/code&gt; ）匹配的所有行。</target>
        </trans-unit>
        <trans-unit id="d20e487318f9399c04b2a3d79bfe7af0545b07ad" translate="yes" xml:space="preserve">
          <source>Default behavior is to replace at most one line. This replaces all lines matching the key (and optionally the value_regex).</source>
          <target state="translated">默认行为是最多替换一行。这将替换所有与key(和可选的value_regex)匹配的行。</target>
        </trans-unit>
        <trans-unit id="749b51b1c09b9f840f85503ac08122dc83ca64a1" translate="yes" xml:space="preserve">
          <source>Default behaviour</source>
          <target state="translated">默认行为</target>
        </trans-unit>
        <trans-unit id="169920c54a1f81ff4c7f4ea2f9bc3ec52999c692" translate="yes" xml:space="preserve">
          <source>Default category for projects for which none is specified. If this is set to the empty string, such projects will remain uncategorized and listed at the top, above categorized projects. Used only if project categories are enabled, which means if &lt;code&gt;$projects_list_group_categories&lt;/code&gt; is true. By default set to &quot;&quot; (empty string).</source>
          <target state="translated">未指定项目的默认类别。如果将其设置为空字符串，则此类项目将保持未分类状态，并在已分类项目上方的顶部列出。仅在启用项目类别（即 &lt;code&gt;$projects_list_group_categories&lt;/code&gt; 为true）时使用。默认情况下设置为&amp;ldquo;&amp;rdquo;（空字符串）。</target>
        </trans-unit>
        <trans-unit id="9a7724b74acb9022ccf2c23f91703070df10d1ad" translate="yes" xml:space="preserve">
          <source>Default charset for text files. If this is not set, the web server configuration will be used. Unset by default.</source>
          <target state="translated">文本文件的默认字符集。如果没有设置,将使用Web服务器的配置。默认情况下未设置。</target>
        </trans-unit>
        <trans-unit id="f158e700b844e38a0dc931109afe37923be30e86" translate="yes" xml:space="preserve">
          <source>Default for the &lt;code&gt;--format&lt;/code&gt; option. (See &lt;code&gt;Pretty Formats&lt;/code&gt; above.) Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 选项的默认值。（请参阅上面的 &lt;code&gt;Pretty Formats&lt;/code&gt; 。）默认为 &lt;code&gt;medium&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="218b9a84e8b1c5c4d3bddc9fdedc0acd32221314" translate="yes" xml:space="preserve">
          <source>Default format for human-readable dates. (Compare the &lt;code&gt;--date&lt;/code&gt; option.) Defaults to &quot;default&quot;, which means to write dates like &lt;code&gt;Sat May 8 19:35:34 2010 -0500&lt;/code&gt;.</source>
          <target state="translated">可读日期的默认格式。（比较 &lt;code&gt;--date&lt;/code&gt; 选项。）默认为&amp;ldquo; default&amp;rdquo;，这意味着要写一些类似 &lt;code&gt;Sat May 8 19:35:34 2010 -0500&lt;/code&gt; 的日期。</target>
        </trans-unit>
        <trans-unit id="ba0eb309e5345eec5c3b84841217719e93588d00" translate="yes" xml:space="preserve">
          <source>Default is 1 MiB if NO_MMAP was set at compile time, otherwise 32 MiB on 32 bit platforms and 1 GiB on 64 bit platforms. This should be reasonable for all users/operating systems. You probably do not need to adjust this value.</source>
          <target state="translated">如果在编译时设置了NO_MMAP,默认为1 MiB,否则32位平台为32 MiB,64位平台为1 GiB。这对于所有用户/操作系统来说应该是合理的。你可能不需要调整这个值。</target>
        </trans-unit>
        <trans-unit id="d9147e34112ee790abb9f9db27d98b411473bac1" translate="yes" xml:space="preserve">
          <source>Default is 256 MiB on 32 bit platforms and 32 TiB (effectively unlimited) on 64 bit platforms. This should be reasonable for all users/operating systems, except on the largest projects. You probably do not need to adjust this value.</source>
          <target state="translated">32位平台的默认值是256 MiB,64位平台的默认值是32 TiB(实际上是无限的)。这对所有用户/操作系统来说都是合理的,除了大型项目。你可能不需要调整这个值。</target>
        </trans-unit>
        <trans-unit id="4e49064ea050150a0f08182ce6ea67e133f00a9b" translate="yes" xml:space="preserve">
          <source>Default is 512 MiB on all platforms. This should be reasonable for most projects as source code and other text files can still be delta compressed, but larger binary media files won&amp;rsquo;t be.</source>
          <target state="translated">在所有平台上，默认值为512 MiB。对于大多数项目来说，这应该是合理的，因为源代码和其他文本文件仍可以进行增量压缩，但更大的二进制媒体文件则不能。</target>
        </trans-unit>
        <trans-unit id="dda4dcbc7195d800c473af9dc2bffe5e2a28d17c" translate="yes" xml:space="preserve">
          <source>Default is 96 MiB on all platforms. This should be reasonable for all users/operating systems, except on the largest projects. You probably do not need to adjust this value.</source>
          <target state="translated">所有平台的默认值是96 MiB。这对所有用户/操作系统来说都是合理的,除了大型项目。你可能不需要调整这个值。</target>
        </trans-unit>
        <trans-unit id="41aaa0897fbd85df874ab9d046a41b0b5b6fcbb7" translate="yes" xml:space="preserve">
          <source>Default is the value of &lt;code&gt;sendemail.confirm&lt;/code&gt; configuration value; if that is unspecified, default to &lt;code&gt;auto&lt;/code&gt; unless any of the suppress options have been specified, in which case default to &lt;code&gt;compose&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;sendemail.confirm&lt;/code&gt; 的配置值；如果未指定，则默认为 &lt;code&gt;auto&lt;/code&gt; 除非已指定任何抑制选项，在这种情况下，默认为 &lt;code&gt;compose&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3569c1c552117db58dc989b670cc81e2f0b5eea8" translate="yes" xml:space="preserve">
          <source>Default is the value of &lt;code&gt;sendemail.suppresscc&lt;/code&gt; configuration value; if that is unspecified, default to &lt;code&gt;self&lt;/code&gt; if --suppress-from is specified, as well as &lt;code&gt;body&lt;/code&gt; if --no-signed-off-cc is specified.</source>
          <target state="translated">默认值为 &lt;code&gt;sendemail.suppresscc&lt;/code&gt; 的配置值；如果未指定，则如果指定了--suppress-from ，则默认为 &lt;code&gt;self&lt;/code&gt; ;如果指定了--no-signed-off-cc ，则默认为 &lt;code&gt;body&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d9cf7354837a1e6f3330509773c724888f83eee" translate="yes" xml:space="preserve">
          <source>Default is the value of &lt;code&gt;sendemail.validate&lt;/code&gt;; if this is not set, default to &lt;code&gt;--validate&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;sendemail.validate&lt;/code&gt; 的值；如果未设置，则默认为 &lt;code&gt;--validate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56e75db08a7bfbfa3cf0e2da2dfaa6006039a1d9" translate="yes" xml:space="preserve">
          <source>Default is the value of the &lt;code&gt;sendemail.transferEncoding&lt;/code&gt; configuration value; if that is unspecified, default to &lt;code&gt;auto&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;sendemail.transferEncoding&lt;/code&gt; 配置值；如果未指定，则默认为 &lt;code&gt;auto&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64e9c61ef316384afc27b43382c7032d837b6c45" translate="yes" xml:space="preserve">
          <source>Default mimetype for the blob_plain (raw) view, if mimetype checking doesn&amp;rsquo;t result in some other type; by default &quot;text/plain&quot;. Gitweb guesses mimetype of a file to display based on extension of its filename, using &lt;code&gt;$mimetypes_file&lt;/code&gt; (if set and file exists) and &lt;code&gt;/etc/mime.types&lt;/code&gt; files (see &lt;strong&gt;mime.types&lt;/strong&gt;(5) manpage; only filename extension rules are supported by gitweb).</source>
          <target state="translated">如果mimetype检查没有导致其他类型，则blob_plain（原始）视图的默认mimetype；否则，为false。默认情况下为&amp;ldquo;文本/纯文本&amp;rdquo;。Gitweb使用 &lt;code&gt;$mimetypes_file&lt;/code&gt; （如果存在设置和文件）和 &lt;code&gt;/etc/mime.types&lt;/code&gt; 文件（请参见&lt;strong&gt;mime.types&lt;/strong&gt;（5）联机帮助页）根据文件名的扩展名猜测要显示的文件的mimetype。 gitweb）。</target>
        </trans-unit>
        <trans-unit id="a652e3e440b54f22526cd10c4e33c94f21d2c36b" translate="yes" xml:space="preserve">
          <source>Default mode</source>
          <target state="translated">默认模式</target>
        </trans-unit>
        <trans-unit id="acfd9cc6edb5212a1b417bbccf2370d2aa946d1d" translate="yes" xml:space="preserve">
          <source>Default value is &quot;project&quot;. Unknown value means unsorted.</source>
          <target state="translated">默认值为 &quot;项目&quot;。未知值表示未排序。</target>
        </trans-unit>
        <trans-unit id="d13eeb854d667ceefdf012fc9e848fc81153988f" translate="yes" xml:space="preserve">
          <source>Default value of ordering of projects on projects list page, which means the ordering used if you don&amp;rsquo;t explicitly sort projects list (if there is no &quot;o&quot; CGI query parameter in the URL). Valid values are &quot;none&quot; (unsorted), &quot;project&quot; (projects are by project name, i.e. path to repository relative to &lt;code&gt;$projectroot&lt;/code&gt;), &quot;descr&quot; (project description), &quot;owner&quot;, and &quot;age&quot; (by date of most current commit).</source>
          <target state="translated">项目列表页面上项目排序的默认值，这意味着如果您未明确对项目列表进行排序（如果URL中没有&amp;ldquo; o&amp;rdquo; CGI查询参数），则使用该排序。有效值为&amp;ldquo; none&amp;rdquo;（未排序），&amp;ldquo; project&amp;rdquo;（项目按项目名称，即相对于 &lt;code&gt;$projectroot&lt;/code&gt; 存储库路径），&amp;ldquo; descr&amp;rdquo;（项目描述），&amp;ldquo; owner&amp;rdquo;和&amp;ldquo; age&amp;rdquo;（按日期排序）最新提交）。</target>
        </trans-unit>
        <trans-unit id="8ac357056e8ed36929d1a15c1654ca84f035985a" translate="yes" xml:space="preserve">
          <source>Default values for &amp;lt;repository&amp;gt; and &amp;lt;branch&amp;gt; are read from the &quot;remote&quot; and &quot;merge&quot; configuration for the current branch as set by &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;&lt;code&gt;--track&lt;/code&gt;.</source>
          <target state="translated">从&lt;a href=&quot;git-branch&quot;&gt;git-branch [1] &lt;/a&gt; &lt;code&gt;--track&lt;/code&gt; 设置的当前分支的&amp;ldquo; remote&amp;rdquo;和&amp;ldquo; merge&amp;rdquo;配置中读取&amp;lt;repository&amp;gt;和&amp;lt;branch&amp;gt;的默认值。</target>
        </trans-unit>
        <trans-unit id="83771af0d9e990cfd4209b40879c5dd720b86a4b" translate="yes" xml:space="preserve">
          <source>Defaults to false.</source>
          <target state="translated">默认值为false。</target>
        </trans-unit>
        <trans-unit id="6daf684c4aa7d6effe6c46260cf795487441628a" translate="yes" xml:space="preserve">
          <source>Defaults to false. If this is set to a non zero number or true (identical to -1 or an unlimited number), the submodule summary will be enabled and a summary of commits for modified submodules will be shown (see --summary-limit option of &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;). Please note that the summary output command will be suppressed for all submodules when &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; is set to &lt;code&gt;all&lt;/code&gt; or only for those submodules where &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt;. The only exception to that rule is that status and commit will show staged submodule changes. To also view the summary for ignored submodules you can either use the --ignore-submodules=dirty command-line option or the &lt;code&gt;git submodule summary&lt;/code&gt; command, which shows a similar output but does not honor these settings.</source>
          <target state="translated">默认为false。如果这被设置为非零数或真（相同为-1或无限数量），子模块摘要将被使能并提交的改性子模块的概要将被显示（参见--summary限制选项&lt;a href=&quot;git-submodule&quot;&gt;git- submodule [1]&lt;/a&gt;）。请注意，当 &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; 设置为 &lt;code&gt;all&lt;/code&gt; 或仅对 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt; 那些子模块设置为时，将禁止所有子模块执行summary输出命令。该规则的唯一例外是状态和提交将显示分段的子模块更改。要同时查看被忽略子模块的摘要，可以使用--ignore-submodules = dirty命令行选项或 &lt;code&gt;git submodule summary&lt;/code&gt; 命令，显示类似的输出，但不支持这些设置。</target>
        </trans-unit>
        <trans-unit id="c1010884442d5e06536e1ee0f4d961539164dc8e" translate="yes" xml:space="preserve">
          <source>Defines a URL from which the submodule repository can be cloned. This may be either an absolute URL ready to be passed to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or (if it begins with ./ or ../) a location relative to the superproject&amp;rsquo;s origin repository.</source>
          <target state="translated">定义可从中克隆子模块存储库的URL。这可以是准备传递给&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;的绝对URL，也可以是相对于超级项目的原始存储库的位置（如果以./或../开头）。</target>
        </trans-unit>
        <trans-unit id="7eec12b7977eefefa22fa2534e2c96073288e53c" translate="yes" xml:space="preserve">
          <source>Defines a human-readable name for a custom low-level merge driver. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">为自定义的低级合并驱动程序定义易于理解的名称。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3e9ca6f11c09da4d43e81ad293147f43b5584aa" translate="yes" xml:space="preserve">
          <source>Defines how wide the commit message window is in the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;. &quot;75&quot; is the default.</source>
          <target state="translated">定义&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]中&lt;/a&gt;的提交消息窗口的宽度。默认值为&amp;ldquo; 75&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8f256827cbc850fb3bdad834aa2364767d096745" translate="yes" xml:space="preserve">
          <source>Defines the action &lt;code&gt;git push&lt;/code&gt; should take if no refspec is explicitly given. Different values are well-suited for specific workflows; for instance, in a purely central workflow (i.e. the fetch source is equal to the push destination), &lt;code&gt;upstream&lt;/code&gt; is probably what you want. Possible values are:</source>
          <target state="translated">定义如果未明确给出refspec，则 &lt;code&gt;git push&lt;/code&gt; 应该执行的操作。不同的值非常适合特定的工作流程；例如，在纯粹的中央工作流程中（即，获取源等于推送目的地）， &lt;code&gt;upstream&lt;/code&gt; 可能就是您想要的。可能的值为：</target>
        </trans-unit>
        <trans-unit id="fa5a260857f4dcd659067f9cae013659cbddf760" translate="yes" xml:space="preserve">
          <source>Defines the action &lt;code&gt;git push&lt;/code&gt; should take if no refspec is given (whether from the command-line, config, or elsewhere). Different values are well-suited for specific workflows; for instance, in a purely central workflow (i.e. the fetch source is equal to the push destination), &lt;code&gt;upstream&lt;/code&gt; is probably what you want. Possible values are:</source>
          <target state="translated">定义如果未提供refspec（无论是从命令行，配置还是其他位置），则 &lt;code&gt;git push&lt;/code&gt; 应该执行的操作。不同的值非常适合特定的工作流程；例如，在纯粹的中央工作流程中（即，获取源等于推送目的地）， &lt;code&gt;upstream&lt;/code&gt; 可能就是您想要的。可能的值为：</target>
        </trans-unit>
        <trans-unit id="4188e24ee4c51e0130a50e687a2164cdec0105c9" translate="yes" xml:space="preserve">
          <source>Defines the command that implements a custom low-level merge driver. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">定义实现自定义低级合并驱动程序的命令。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70c9d97cb193a6213d042cd9cd1b6638dde57f03" translate="yes" xml:space="preserve">
          <source>Defines the default update procedure for the named submodule, i.e. how the submodule is updated by &quot;git submodule update&quot; command in the superproject. This is only used by &lt;code&gt;git
submodule init&lt;/code&gt; to initialize the configuration variable of the same name. Allowed values here are &lt;code&gt;checkout&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;none&lt;/code&gt;. See description of &lt;code&gt;update&lt;/code&gt; command in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; for their meaning. For security reasons, the &lt;code&gt;!command&lt;/code&gt; form is not accepted here.</source>
          <target state="translated">定义命名子模块的默认更新过程，即，如何通过超级项目中的&amp;ldquo; git submodule update&amp;rdquo;命令更新子模块。这仅由 &lt;code&gt;git submodule init&lt;/code&gt; 用来初始化同名的配置变量。此处允许的值为 &lt;code&gt;checkout&lt;/code&gt; ， &lt;code&gt;rebase&lt;/code&gt; ， &lt;code&gt;merge&lt;/code&gt; 或 &lt;code&gt;none&lt;/code&gt; 。有关其含义，请参见&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]中&lt;/a&gt;的 &lt;code&gt;update&lt;/code&gt; 命令描述。出于安全原因，此处不接受 &lt;code&gt;!command&lt;/code&gt; 形式。</target>
        </trans-unit>
        <trans-unit id="90471e779c375b0a1c4452c6d06b08a0b6dc6757" translate="yes" xml:space="preserve">
          <source>Defines the path, relative to the top-level directory of the Git working tree, where the submodule is expected to be checked out. The path name must not end with a &lt;code&gt;/&lt;/code&gt;. All submodule paths must be unique within the .gitmodules file.</source>
          <target state="translated">定义相对于Git工作树的顶级目录的路径，该子模块应在该目录中检出。路径名不能以 &lt;code&gt;/&lt;/code&gt; 结尾。 .gitmodules文件中的所有子模块路径必须唯一。</target>
        </trans-unit>
        <trans-unit id="b4ca29387dcb9b04d487429eaa7be9fc96326e7a" translate="yes" xml:space="preserve">
          <source>Defines under what circumstances &quot;git status&quot; and the diff family show a submodule as modified. The following values are supported:</source>
          <target state="translated">定义在什么情况下 &quot;git status &quot;和diff family会显示一个子模块被修改。支持以下值。</target>
        </trans-unit>
        <trans-unit id="7943cfcce8d9f75d29b4fa34e3b6ac1f1de5b3ae" translate="yes" xml:space="preserve">
          <source>Defines under what circumstances &quot;git status&quot; and the diff family show a submodule as modified. When set to &quot;all&quot;, it will never be considered modified (but it will nonetheless show up in the output of status and commit when it has been staged), &quot;dirty&quot; will ignore all changes to the submodules work tree and takes only differences between the HEAD of the submodule and the commit recorded in the superproject into account. &quot;untracked&quot; will additionally let submodules with modified tracked files in their work tree show up. Using &quot;none&quot; (the default when this option is not set) also shows submodules that have untracked files in their work tree as changed. This setting overrides any setting made in .gitmodules for this submodule, both settings can be overridden on the command line by using the &quot;--ignore-submodules&quot; option. The &lt;code&gt;git submodule&lt;/code&gt; commands are not affected by this setting.</source>
          <target state="translated">定义在什么情况下&amp;ldquo; git status&amp;rdquo;和diff系列显示已修改的子模块。当设置为&amp;ldquo; all&amp;rdquo;时，将永远不会将其视为已修改（但仍会在状态输出中显示，并在上演时提交），&amp;ldquo; dirty&amp;rdquo;将忽略对子模块工作树的所有更改，并且仅保留差异子模块的HEAD和记录在超级项目中的提交之间的距离。 &amp;ldquo;未跟踪&amp;rdquo;将另外显示其工作树中具有已修改跟踪文件的子模块。使用&amp;ldquo;无&amp;rdquo;（未设置此选项时的默认值）还会显示其工作树中具有未跟踪文件的子模块已更改。此设置会覆盖.gitmodules中对此子模块所做的任何设置，可以通过在命令行上使用&amp;ldquo;--ignore-submodules&amp;rdquo;选项。 &lt;code&gt;git submodule&lt;/code&gt; 命令不受此设置的影响。</target>
        </trans-unit>
        <trans-unit id="e1fef4851ecba56a95f304dccae2b919c9e6d073" translate="yes" xml:space="preserve">
          <source>Defines which attributes to assign to a path, similar to per-directory &lt;code&gt;.gitattributes&lt;/code&gt; files. See also: &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">定义要分配给路径的属性，类似于每个目录的 &lt;code&gt;.gitattributes&lt;/code&gt; 文件。另请参阅：&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7011f57e8da17dd35f52484933047dc4fb201acb" translate="yes" xml:space="preserve">
          <source>Defines, together with branch.&amp;lt;name&amp;gt;.remote, the upstream branch for the given branch. It tells &lt;code&gt;git fetch&lt;/code&gt;/&lt;code&gt;git pull&lt;/code&gt;/&lt;code&gt;git rebase&lt;/code&gt; which branch to merge and can also affect &lt;code&gt;git push&lt;/code&gt; (see push.default). When in branch &amp;lt;name&amp;gt;, it tells &lt;code&gt;git fetch&lt;/code&gt; the default refspec to be marked for merging in FETCH_HEAD. The value is handled like the remote part of a refspec, and must match a ref which is fetched from the remote given by &quot;branch.&amp;lt;name&amp;gt;.remote&quot;. The merge information is used by &lt;code&gt;git pull&lt;/code&gt; (which at first calls &lt;code&gt;git fetch&lt;/code&gt;) to lookup the default branch for merging. Without this option, &lt;code&gt;git pull&lt;/code&gt; defaults to merge the first refspec fetched. Specify multiple values to get an octopus merge. If you wish to setup &lt;code&gt;git pull&lt;/code&gt; so that it merges into &amp;lt;name&amp;gt; from another branch in the local repository, you can point branch.&amp;lt;name&amp;gt;.merge to the desired branch, and use the relative path setting &lt;code&gt;.&lt;/code&gt; (a period) for branch.&amp;lt;name&amp;gt;.remote.</source>
          <target state="translated">与branch。&amp;lt;name&amp;gt; .remote一起定义给定分支的上游分支。它告诉 &lt;code&gt;git fetch&lt;/code&gt; / &lt;code&gt;git pull&lt;/code&gt; / &lt;code&gt;git rebase&lt;/code&gt; 合并哪个分支，也可以影响 &lt;code&gt;git push&lt;/code&gt; （请参阅push.default）。在分支&amp;lt;name&amp;gt;中时，它告诉 &lt;code&gt;git fetch&lt;/code&gt; 将标记为要合并到FETCH_HEAD中的默认refspec。该值的处理方式类似于refspec的远程部分，并且必须匹配从&amp;ldquo; branch。&amp;lt;name&amp;gt; .remote&amp;rdquo;给定的远程获取的ref。 &lt;code&gt;git pull&lt;/code&gt; （首先调用 &lt;code&gt;git fetch&lt;/code&gt; ）使用合并信息来查找要合并的默认分支。没有这个选项， &lt;code&gt;git pull&lt;/code&gt; 默认情况下合并获取的第一个refspec。指定多个值以获取章鱼合并。如果要设置 &lt;code&gt;git pull&lt;/code&gt; 以便它从本地存储库中的另一个分支合并到&amp;lt;name&amp;gt;中，则可以将branch。&amp;lt;name&amp;gt; .merge指向所需的分支，并使用相对路径设置 &lt;code&gt;.&lt;/code&gt; （一个句号）。&amp;lt;name&amp;gt; .remote。</target>
        </trans-unit>
        <trans-unit id="f11af95383d16d6bd1e7925886e81b428b4cbfea" translate="yes" xml:space="preserve">
          <source>Defining a custom hunk-header</source>
          <target state="translated">定义一个自定义的hunk-header</target>
        </trans-unit>
        <trans-unit id="ca3594ffd9ab11c72c2e8d78b4c8b59973682e4f" translate="yes" xml:space="preserve">
          <source>Defining a custom merge driver</source>
          <target state="translated">定义自定义合并驱动程序</target>
        </trans-unit>
        <trans-unit id="9708d6426545c2cece09aff33765fae2b095ca8b" translate="yes" xml:space="preserve">
          <source>Defining an external diff driver</source>
          <target state="translated">定义外部差分驱动</target>
        </trans-unit>
        <trans-unit id="eeff7bb1e3fba8a2873ef88f8308472b5d5082ff" translate="yes" xml:space="preserve">
          <source>Defining attributes per path</source>
          <target state="translated">定义每个路径的属性</target>
        </trans-unit>
        <trans-unit id="c0c022d1a19819ea36656f34517c46cf40cc0616" translate="yes" xml:space="preserve">
          <source>Defining macro attributes</source>
          <target state="translated">定义宏属性</target>
        </trans-unit>
        <trans-unit id="6bc10970bef0d1a497b62db2ecbaba494c65fd0f" translate="yes" xml:space="preserve">
          <source>Defining submodule properties</source>
          <target state="translated">定义子模块属性</target>
        </trans-unit>
        <trans-unit id="b40047a3b93162ae49d16e0fd58c1fcd8942970b" translate="yes" xml:space="preserve">
          <source>Deinitialized submodule: A &lt;code&gt;gitlink&lt;/code&gt;, and a &lt;code&gt;.gitmodules&lt;/code&gt; entry, but no submodule working directory. The submodule&amp;rsquo;s Git directory may be there as after deinitializing the Git directory is kept around. The directory which is supposed to be the working directory is empty instead.</source>
          <target state="translated">已取消初始化的子模块： &lt;code&gt;gitlink&lt;/code&gt; 和 &lt;code&gt;.gitmodules&lt;/code&gt; 条目，但没有子模块工作目录。子模块的Git目录可能在该目录中，因为在取消初始化Git目录之后，该目录仍然存在。应该是工作目录的目录为空。</target>
        </trans-unit>
        <trans-unit id="b4c200bb0d1f7ba2b7c3e166470a4cb39be0daab" translate="yes" xml:space="preserve">
          <source>Delay</source>
          <target state="translated">Delay</target>
        </trans-unit>
        <trans-unit id="ce169dc044a35b855e4edb1b1a97682afa804f83" translate="yes" xml:space="preserve">
          <source>Delete &amp;lt;ref&amp;gt; after verifying it exists with &amp;lt;oldvalue&amp;gt;, if given. If given, &amp;lt;oldvalue&amp;gt; may not be zero.</source>
          <target state="translated">如果使用&amp;lt;oldvalue&amp;gt;验证&amp;lt;ref&amp;gt;存在，请删除它。如果给定，&amp;lt;oldvalue&amp;gt;可能不为零。</target>
        </trans-unit>
        <trans-unit id="4a38bab2ae9dd8b2cb4a0dc3ff8ff31445d9e605" translate="yes" xml:space="preserve">
          <source>Delete a branch. The branch must be fully merged in its upstream branch, or in &lt;code&gt;HEAD&lt;/code&gt; if no upstream was set with &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--set-upstream-to&lt;/code&gt;.</source>
          <target state="translated">删除分支。如果未使用 &lt;code&gt;--track&lt;/code&gt; 或 &lt;code&gt;--set-upstream-to&lt;/code&gt; 设置上游，则该分支必须在其上游分支或 &lt;code&gt;HEAD&lt;/code&gt; 中完全合并。</target>
        </trans-unit>
        <trans-unit id="e9f3df8cb2d062f0173b4dadd305c9e0eadc7f1f" translate="yes" xml:space="preserve">
          <source>Delete an unneeded branch</source>
          <target state="translated">删除一个不需要的分支</target>
        </trans-unit>
        <trans-unit id="3627df6f5c316b48c9a0e828b45ee4b23f9a149d" translate="yes" xml:space="preserve">
          <source>Delete existing replace refs for the given objects.</source>
          <target state="translated">删除给定对象的现有替换参考。</target>
        </trans-unit>
        <trans-unit id="6b8d128c004ee953175f88ab766106d4cfa01d06" translate="yes" xml:space="preserve">
          <source>Delete existing tags with the given names.</source>
          <target state="translated">刪除現有的標籤。</target>
        </trans-unit>
        <trans-unit id="ec34ecd3e43b7835223d180bb5b62d7a1f50ff85" translate="yes" xml:space="preserve">
          <source>Delete the &quot;test&quot; branch even if the &quot;master&quot; branch (or whichever branch is currently checked out) does not have all commits from the test branch.</source>
          <target state="translated">删除 &quot;test &quot;分支,即使 &quot;master &quot;分支(或当前检查出的任何一个分支)没有从测试分支提交所有的内容。</target>
        </trans-unit>
        <trans-unit id="5060fa25753a50b8acf6be2071a5d6f5afc4acd3" translate="yes" xml:space="preserve">
          <source>Delete the pack-files that are tracked by the MIDX file, but have no objects referenced by the MIDX. Rewrite the MIDX file afterward to remove all references to these pack-files.</source>
          <target state="translated">删除被 MIDX 文件跟踪,但没有 MIDX 引用的对象的 pack-file。之后重写MIDX文件,删除对这些包文件的所有引用。</target>
        </trans-unit>
        <trans-unit id="34a0e7fb9687c81637f401d26cc5a141535336e8" translate="yes" xml:space="preserve">
          <source>Delete the remote-tracking branches &quot;todo&quot;, &quot;html&quot; and &quot;man&quot;. The next &lt;code&gt;fetch&lt;/code&gt; or &lt;code&gt;pull&lt;/code&gt; will create them again unless you configure them not to. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">删除远程跟踪分支&amp;ldquo; todo&amp;rdquo;，&amp;ldquo; html&amp;rdquo;和&amp;ldquo; man&amp;rdquo;。除非您不配置它们，否则下一次 &lt;code&gt;fetch&lt;/code&gt; 或 &lt;code&gt;pull&lt;/code&gt; 将再次创建它们。参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48060c17f13289e334a3727f4f1de95de800b004" translate="yes" xml:space="preserve">
          <source>Delete the symbolic ref &amp;lt;name&amp;gt;.</source>
          <target state="translated">删除符号引用&amp;lt;名称&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="0b8a7c3943e03f2a2e8f697e98962af3bfbc2534" translate="yes" xml:space="preserve">
          <source>Deleted submodule: A submodule can be deleted by running &lt;code&gt;git rm &amp;lt;submodule path&amp;gt; &amp;amp;&amp;amp; git commit&lt;/code&gt;. This can be undone using &lt;code&gt;git revert&lt;/code&gt;.</source>
          <target state="translated">删除的子模块：可以通过运行 &lt;code&gt;git rm &amp;lt;submodule path&amp;gt; &amp;amp;&amp;amp; git commit&lt;/code&gt; 删除子模块。可以使用 &lt;code&gt;git revert&lt;/code&gt; 撤消。</target>
        </trans-unit>
        <trans-unit id="bbae550cd78e8e22873a526e5dae0892e13b85e4" translate="yes" xml:space="preserve">
          <source>Deletes stale references associated with &amp;lt;name&amp;gt;. By default, stale remote-tracking branches under &amp;lt;name&amp;gt; are deleted, but depending on global configuration and the configuration of the remote we might even prune local tags that haven&amp;rsquo;t been pushed there. Equivalent to &lt;code&gt;git
fetch --prune &amp;lt;name&amp;gt;&lt;/code&gt;, except that no new references will be fetched.</source>
          <target state="translated">删除与&amp;lt;name&amp;gt;关联的陈旧引用。默认情况下，&amp;lt;name&amp;gt;下的陈旧的远程跟踪分支将被删除，但是根据全局配置和远程服务器的配置，我们甚至可以修剪尚未推送到此处的本地标签。等同于 &lt;code&gt;git fetch --prune &amp;lt;name&amp;gt;&lt;/code&gt; ，除了不会获取任何新引用。</target>
        </trans-unit>
        <trans-unit id="24d8888ac9265ebf12b5751431da3b3a66a3bc35" translate="yes" xml:space="preserve">
          <source>Delimited format</source>
          <target state="translated">限定格式</target>
        </trans-unit>
        <trans-unit id="b2cf66f0df0d42ad5ab4aaeb19f2b65bda3f8e44" translate="yes" xml:space="preserve">
          <source>Delta compression will not be attempted for blobs for paths with the attribute &lt;code&gt;delta&lt;/code&gt; set to false.</source>
          <target state="translated">对于属性 &lt;code&gt;delta&lt;/code&gt; 设置为false的路径，将不尝试对Blob进行Delta压缩。</target>
        </trans-unit>
        <trans-unit id="06d8459b781df550338ff8874296d04e07653551" translate="yes" xml:space="preserve">
          <source>Delta islands</source>
          <target state="translated">三角洲群岛</target>
        </trans-unit>
        <trans-unit id="1c00a92357090dcc2a4a087a5faeaa3dd4ef60a6" translate="yes" xml:space="preserve">
          <source>Delta islands solve this problem by allowing you to group your refs into distinct &quot;islands&quot;. Pack-objects computes which objects are reachable from which islands, and refuses to make a delta from an object &lt;code&gt;A&lt;/code&gt; against a base which is not present in all of &lt;code&gt;A&lt;/code&gt;'s islands. This results in slightly larger packs (because we miss some delta opportunities), but guarantees that a fetch of one island will not have to recompute deltas on the fly due to crossing island boundaries.</source>
          <target state="translated">三角洲岛屿允许您将裁判分为不同的&amp;ldquo;小岛&amp;rdquo;，从而解决了这一问题。打包对象计算从哪个岛可以到达哪些对象，并拒绝从对象 &lt;code&gt;A&lt;/code&gt; 相对于所有 &lt;code&gt;A&lt;/code&gt; 的岛中都不存在的基准得出增量。这样会导致包的数量稍大（因为我们错过了一些三角洲机会），但可以保证获取一个岛屿不会因为跨越岛屿边界而即时重新计算三角洲。</target>
        </trans-unit>
        <trans-unit id="89e6ba5af92c1476da557467d420cb383ed75bc2" translate="yes" xml:space="preserve">
          <source>Deltified representation</source>
          <target state="translated">认证代表</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="fcd6a0d5490f96a9ee2d3abff638da71da537fbf" translate="yes" xml:space="preserve">
          <source>Depending on the operation, git will use one of the following refspecs, if you don&amp;rsquo;t provide one on the command line. &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is the name of this file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; and &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; defaults to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">如果您没有在命令行中提供refspec，则git将使用以下refspec之一，具体取决于操作。 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 是 &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 中此文件的名称，而 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 默认为 &lt;code&gt;master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea16e3702c686bd547a284907194ee7b4ffac191" translate="yes" xml:space="preserve">
          <source>Depot path syntax</source>
          <target state="translated">仓库路径语法</target>
        </trans-unit>
        <trans-unit id="1983f893b78285086fe35838f9f2f81d38d4d745" translate="yes" xml:space="preserve">
          <source>Deprecated alias for &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; 的已弃用别名。</target>
        </trans-unit>
        <trans-unit id="05b4a62238617bb5a4be973f552dc324fff173a4" translate="yes" xml:space="preserve">
          <source>Deprecated alias for &lt;code&gt;sendemail.smtpEncryption = ssl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sendemail.smtpEncryption = ssl&lt;/code&gt; 已弃用别名。</target>
        </trans-unit>
        <trans-unit id="a4db2bebc38aa1316eeea066286d1da6378d7b28" translate="yes" xml:space="preserve">
          <source>Deprecated alias for &lt;code&gt;versionsort.suffix&lt;/code&gt;. Ignored if &lt;code&gt;versionsort.suffix&lt;/code&gt; is set.</source>
          <target state="translated">&lt;code&gt;versionsort.suffix&lt;/code&gt; 的已弃用别名。如果设置了 &lt;code&gt;versionsort.suffix&lt;/code&gt; ，则将其忽略。</target>
        </trans-unit>
        <trans-unit id="d156ce209204264f931768dbe9676b2798b77199" translate="yes" xml:space="preserve">
          <source>Deprecated synonym for &lt;code&gt;find-renames=&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;find-renames=&amp;lt;n&amp;gt;&lt;/code&gt; 的已弃用同义词。</target>
        </trans-unit>
        <trans-unit id="f08e2766ccb54250d4b3556b2590b15bf5d66a82" translate="yes" xml:space="preserve">
          <source>Dereference tags into object IDs as well. They will be shown with &quot;^{}&quot; appended.</source>
          <target state="translated">将标签也衍生到对象ID中。它们将以附加&quot;^{}&quot;来显示。</target>
        </trans-unit>
        <trans-unit id="19ab5a2b07f917835d2a43707ceb85ed7b98a04e" translate="yes" xml:space="preserve">
          <source>Describe the patterns in the sparse-checkout file.</source>
          <target state="translated">描述稀疏结账文件中的模式。</target>
        </trans-unit>
        <trans-unit id="3adaea2f7c94d999c480c31a9d97431cd4a29972" translate="yes" xml:space="preserve">
          <source>Describe the state of the working tree. When the working tree matches HEAD, the output is the same as &quot;git describe HEAD&quot;. If the working tree has local modification &quot;-dirty&quot; is appended to it. If a repository is corrupt and Git cannot determine if there is local modification, Git will error out, unless &amp;lsquo;--broken&amp;rsquo; is given, which appends the suffix &quot;-broken&quot; instead.</source>
          <target state="translated">描述工作树的状态。当工作树匹配HEAD时，输出与&amp;ldquo; git describe HEAD&amp;rdquo;相同。如果工作树具有本地修改，则将&amp;ldquo; -dirty&amp;rdquo;附加到工作树上。如果存储库已损坏，并且Git无法确定是否存在本地修改，则Git会出错，除非给出'--broken'，而是在后缀后缀&amp;ldquo; -broken&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="d6cee108138bd9a1ce855b1d73c719745374ce44" translate="yes" xml:space="preserve">
          <source>Design details</source>
          <target state="translated">设计细节</target>
        </trans-unit>
        <trans-unit id="7e2d8329f700e85ec6f60947dd853588b3fee1c7" translate="yes" xml:space="preserve">
          <source>Designed with http and stateless-rpc in mind. With clear flush semantics the http remote helper can simply act as a proxy</source>
          <target state="translated">以http和无状态的rpc为设计理念。通过清晰的flush语义,http远程帮助程序可以简单地作为代理。</target>
        </trans-unit>
        <trans-unit id="a30dd6eb385d802e85851897aa84247984d6f5fe" translate="yes" xml:space="preserve">
          <source>Detach from the shell. Implies --syslog.</source>
          <target state="translated">从shell中分离出来。意味着-syslog。</target>
        </trans-unit>
        <trans-unit id="e5497c96dfd8b989db42ae40a552822ac0beda8b" translate="yes" xml:space="preserve">
          <source>Detached head</source>
          <target state="translated">独立的头</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="67aa19cf55a723bbb26944cac78345fab055b208" translate="yes" xml:space="preserve">
          <source>Detect copies as well as renames. See also &lt;code&gt;--find-copies-harder&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is specified, it has the same meaning as for &lt;code&gt;-M&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">检测副本以及重命名。另请参见 &lt;code&gt;--find-copies-harder&lt;/code&gt; 。如果指定 &lt;code&gt;n&lt;/code&gt; ，则其含义与 &lt;code&gt;-M&amp;lt;n&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01c2501577dd3675d86bed17ffb08591c732fcb7" translate="yes" xml:space="preserve">
          <source>Detect copies harder. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. A boolean.</source>
          <target state="translated">更努力地检测副本。参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;。一个布尔值。</target>
        </trans-unit>
        <trans-unit id="1b3059b4d74c2df5e3146bf7b20891041e88ba9a" translate="yes" xml:space="preserve">
          <source>Detect copies. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. This can be true, false, or a score as expected by &lt;code&gt;git diff -C&lt;/code&gt;.</source>
          <target state="translated">检测副本。参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;。这可以是真，假或 &lt;code&gt;git diff -C&lt;/code&gt; 期望的分数。</target>
        </trans-unit>
        <trans-unit id="1070111ce881d033aa11a2603f524ec35d0cf5af" translate="yes" xml:space="preserve">
          <source>Detect moved or copied lines within a file. When a commit moves or copies a block of lines (e.g. the original file has A and then B, and the commit changes it to B and then A), the traditional &lt;code&gt;blame&lt;/code&gt; algorithm notices only half of the movement and typically blames the lines that were moved up (i.e. B) to the parent and assigns blame to the lines that were moved down (i.e. A) to the child commit. With this option, both groups of lines are blamed on the parent by running extra passes of inspection.</source>
          <target state="translated">检测文件中移动或复制的行。当提交移动或复制一行代码块时（例如，原始文件的A依次为B，然后提交更改为B然后是A），传统的 &lt;code&gt;blame&lt;/code&gt; 算法仅注意到移动的一半，通常将其归咎于向父级上移（即B），并向子级提交下移（即A）的行负责。使用此选项，通过运行额外的检查通道，两组线都归咎于父级。</target>
        </trans-unit>
        <trans-unit id="1b96566ef127f8d019345c2f29a72c790e874b75" translate="yes" xml:space="preserve">
          <source>Detect renames. If &lt;code&gt;n&lt;/code&gt; is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file&amp;rsquo;s size). For example, &lt;code&gt;-M90%&lt;/code&gt; means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn&amp;rsquo;t changed. Without a &lt;code&gt;%&lt;/code&gt; sign, the number is to be read as a fraction, with a decimal point before it. I.e., &lt;code&gt;-M5&lt;/code&gt; becomes 0.5, and is thus the same as &lt;code&gt;-M50%&lt;/code&gt;. Similarly, &lt;code&gt;-M05&lt;/code&gt; is the same as &lt;code&gt;-M5%&lt;/code&gt;. To limit detection to exact renames, use &lt;code&gt;-M100%&lt;/code&gt;. The default similarity index is 50%.</source>
          <target state="translated">检测重命名。如果指定了 &lt;code&gt;n&lt;/code&gt; ，则它是相似性索引的阈值（即，与文件大小相比增加/删除的数量）。例如， &lt;code&gt;-M90%&lt;/code&gt; 表示如果文件的90％以上没有更改，则 Git应该将删除/添加对视为重命名。如果没有 &lt;code&gt;%&lt;/code&gt; 符号，则该数字应作为分数读取，并在其前面加上小数点。即， &lt;code&gt;-M5&lt;/code&gt; 变为0.5，因此与 &lt;code&gt;-M50%&lt;/code&gt; 相同。同样， &lt;code&gt;-M05&lt;/code&gt; 与 &lt;code&gt;-M5%&lt;/code&gt; 相同。要将检测范围限制为完全重命名，请使用 &lt;code&gt;-M100%&lt;/code&gt; 。默认相似度索引为50％。</target>
        </trans-unit>
        <trans-unit id="6d7e84e2caa06e6a8098c62271376428c6e7bd4b" translate="yes" xml:space="preserve">
          <source>Detect renames. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. Renames will be represented in p4 using explicit &lt;code&gt;move&lt;/code&gt; operations. There is no corresponding option to detect copies, but there are variables for both moves and copies.</source>
          <target state="translated">检测重命名。参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;。重命名将使用显式 &lt;code&gt;move&lt;/code&gt; 操作在p4中表示。没有检测副本的相应选项，但是移动和副本都有变量。</target>
        </trans-unit>
        <trans-unit id="5ffd73e1a52e577bf08689eed36f6c4de2377e40" translate="yes" xml:space="preserve">
          <source>Detect renames. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. This can be true, false, or a score as expected by &lt;code&gt;git diff -M&lt;/code&gt;.</source>
          <target state="translated">检测重命名。参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;。这可以是真，假或 &lt;code&gt;git diff -M&lt;/code&gt; 期望的分数。</target>
        </trans-unit>
        <trans-unit id="4eef9174ad5648c91981effc420fca59fc15dfb0" translate="yes" xml:space="preserve">
          <source>Determine the reference name to use for a new branch:</source>
          <target state="translated">确定用于新分支的参考名称。</target>
        </trans-unit>
        <trans-unit id="2fd1f63eeed6a134512b420d9c8a0d335169ab6d" translate="yes" xml:space="preserve">
          <source>Determine whether there are commits in &lt;code&gt;&amp;lt;head&amp;gt;..&amp;lt;upstream&amp;gt;&lt;/code&gt; that are equivalent to those in the range &lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">确定 &lt;code&gt;&amp;lt;head&amp;gt;..&amp;lt;upstream&amp;gt;&lt;/code&gt; 中是否有等同于 &lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt; 范围内的提交。</target>
        </trans-unit>
        <trans-unit id="c3dd19e2791ee2ded730804490298d3d980bfa4d" translate="yes" xml:space="preserve">
          <source>Determines if &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; should trust the file modification timestamp or not. By default the timestamps are not trusted.</source>
          <target state="translated">确定&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt;是否应该信任文件修改时间戳。默认情况下，时间戳不受信任。</target>
        </trans-unit>
        <trans-unit id="e154fe8e767c839e2059b235fd308381f6d8cea3" translate="yes" xml:space="preserve">
          <source>Determines if &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; shows untracked files in the file list. The default is &quot;true&quot;.</source>
          <target state="translated">确定&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]是否&lt;/a&gt;在文件列表中显示未跟踪的文件。默认值为&amp;ldquo; true&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3f3ff5df4fcb4c5f3c82bb56b168b10367f53dcc" translate="yes" xml:space="preserve">
          <source>Determines if new branches created with &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; should default to tracking remote branches with matching names or not. Default: &quot;false&quot;.</source>
          <target state="translated">确定使用&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt;创建的新分支是否应默认跟踪具有匹配名称的远程分支。默认值：&amp;ldquo; false&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2f06095b37712166bde39a43d96d1f0785678946" translate="yes" xml:space="preserve">
          <source>Determines what to do about the untracked cache feature of the index. It will be kept, if this variable is unset or set to &lt;code&gt;keep&lt;/code&gt;. It will automatically be added if set to &lt;code&gt;true&lt;/code&gt;. And it will automatically be removed, if set to &lt;code&gt;false&lt;/code&gt;. Before setting it to &lt;code&gt;true&lt;/code&gt;, you should check that mtime is working properly on your system. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;. &lt;code&gt;keep&lt;/code&gt; by default, unless &lt;code&gt;feature.manyFiles&lt;/code&gt; is enabled which sets this setting to &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">确定如何处理索引的未跟踪缓存功能。如果未设置此变量或将其设置为 &lt;code&gt;keep&lt;/code&gt; ，它将被保留。如果设置为 &lt;code&gt;true&lt;/code&gt; ，它将自动添加。如果设置为 &lt;code&gt;false&lt;/code&gt; ，它将被自动删除。在将其设置为 &lt;code&gt;true&lt;/code&gt; 之前，您应该检查mtime在系统上是否正常工作。参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;。默认情况下 &lt;code&gt;keep&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，除非启用 &lt;code&gt;feature.manyFiles&lt;/code&gt; ，默认情况下将此设置设置为true。</target>
        </trans-unit>
        <trans-unit id="64ca3fdabc3574a39df154eb5758766a9b3dabde" translate="yes" xml:space="preserve">
          <source>Developing against a shared repository</source>
          <target state="translated">在共享资源库中开发</target>
        </trans-unit>
        <trans-unit id="4359a6a8e374a18f2b4c156842b9c3a0fec4c744" translate="yes" xml:space="preserve">
          <source>Developing with git</source>
          <target state="translated">使用git开发</target>
        </trans-unit>
        <trans-unit id="a7a451f70e401e1b204facb3a3e4f97e68c2b291" translate="yes" xml:space="preserve">
          <source>Development cost</source>
          <target state="translated">开发费用</target>
        </trans-unit>
        <trans-unit id="a2efcf35d137bb5a7503ecfbad3617a7e3a45807" translate="yes" xml:space="preserve">
          <source>Die if the pack contains broken links. For internal use only.</source>
          <target state="translated">如果数据包中包含断裂的链接,则死机。仅供内部使用。</target>
        </trans-unit>
        <trans-unit id="c1ab34d973a0a532c231ce665c73c7ea8acc0a78" translate="yes" xml:space="preserve">
          <source>Die if the pack contains broken objects. For internal use only.</source>
          <target state="translated">如果包内有破损的物体,则死机。仅供内部使用。</target>
        </trans-unit>
        <trans-unit id="d986c34724963dfe3d695e6191fc573a97f2025e" translate="yes" xml:space="preserve">
          <source>Die with error code != 0 when a reference is undefined, instead of printing &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">当未定义引用时打印错误代码！= 0，而不是打印 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78795c9d90cdad9316079a8696dae908d814a635" translate="yes" xml:space="preserve">
          <source>Die, if the pack contains broken objects or links.</source>
          <target state="translated">如果包中有破损的对象或链接,则死机。</target>
        </trans-unit>
        <trans-unit id="98ae64918b361ad15c4c43eb611e71c996a3c9bc" translate="yes" xml:space="preserve">
          <source>Die, if the pack is larger than &amp;lt;size&amp;gt;.</source>
          <target state="translated">死亡，如果背包大于&amp;lt;size&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="cd98a991a043eaea48f8e37b61339dac2bfa9ec4" translate="yes" xml:space="preserve">
          <source>Diff Formatting</source>
          <target state="translated">差异格式化</target>
        </trans-unit>
        <trans-unit id="de7932e0191749b8b9963fe2d05250ad20e02e5f" translate="yes" xml:space="preserve">
          <source>Diff against the &quot;base&quot; version, &quot;our branch&quot; or &quot;their branch&quot; respectively. With these options, diffs for merged entries are not shown.</source>
          <target state="translated">分别与 &quot;基础 &quot;版本、&quot;我们的分支 &quot;或 &quot;他们的分支 &quot;进行比较。有了这些选项,就不会显示合并条目的差异。</target>
        </trans-unit>
        <trans-unit id="d39943b940373b977991e15fc719e23de47c6ceb" translate="yes" xml:space="preserve">
          <source>Diff format for merges</source>
          <target state="translated">合并时的差异格式</target>
        </trans-unit>
        <trans-unit id="3df1676524ddf0754323048bbcc379e44af54c67" translate="yes" xml:space="preserve">
          <source>Diff formatting</source>
          <target state="translated">不同的格式</target>
        </trans-unit>
        <trans-unit id="654f69ec27f8d4e0f2ecb2d08ba20e4caaa5cbd4" translate="yes" xml:space="preserve">
          <source>Diff is shown using the specified diff driver. Each driver may specify one or more options, as described in the following section. The options for the diff driver &quot;foo&quot; are defined by the configuration variables in the &quot;diff.foo&quot; section of the Git config file.</source>
          <target state="translated">使用指定的diff驱动来显示diff。每个驱动都可以指定一个或多个选项,如下节所述。diff驱动 &quot;foo &quot;的选项由Git配置文件中 &quot;diff.foo &quot;部分的配置变量定义。</target>
        </trans-unit>
        <trans-unit id="e9752af49676495496d54c49d4451c932889ab3e" translate="yes" xml:space="preserve">
          <source>Diffcore-break: for splitting up complete rewrites</source>
          <target state="translated">Diffcore-break:用于分割完整的重写。</target>
        </trans-unit>
        <trans-unit id="f8cbeab8828f936b2faf8e2c773445ac763403ab" translate="yes" xml:space="preserve">
          <source>Diffcore-merge-broken: for putting complete rewrites back together</source>
          <target state="translated">Diffcore-merge-broken:用于将完整的重写内容重新组合起来。</target>
        </trans-unit>
        <trans-unit id="037fc9af4089dca681837ff54ffb59e13b625177" translate="yes" xml:space="preserve">
          <source>Diffcore-order: for sorting the output based on filenames</source>
          <target state="translated">Diffcore-order:用于根据文件名对输出进行排序。</target>
        </trans-unit>
        <trans-unit id="93ec538cb6f31f250a629fbfef107579093c9275" translate="yes" xml:space="preserve">
          <source>Diffcore-pickaxe: for detecting addition/deletion of specified string</source>
          <target state="translated">Diffcore-pickaxe:用于检测指定字符串的添加/删除。</target>
        </trans-unit>
        <trans-unit id="be51b7621711d155d6251fd428e07de999420e36" translate="yes" xml:space="preserve">
          <source>Diffcore-rename: for detecting renames and copies</source>
          <target state="translated">Diffcore-rename:用于检测重名和复制。</target>
        </trans-unit>
        <trans-unit id="339450e1f1c9c473dd2ab70ee2a31028e8f96d6e" translate="yes" xml:space="preserve">
          <source>Directed acyclic graph. The &lt;a href=&quot;#def_commit_object&quot;&gt;commit objects&lt;/a&gt; form a directed acyclic graph, because they have parents (directed), and the graph of commit objects is acyclic (there is no &lt;a href=&quot;#def_chain&quot;&gt;chain&lt;/a&gt; which begins and ends with the same &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;).</source>
          <target state="translated">有向无环图。在&lt;a href=&quot;#def_commit_object&quot;&gt;对象提交&lt;/a&gt;形成有向无环图，因为它们具有父母（定向），和提交对象的图形是无环（没有&lt;a href=&quot;#def_chain&quot;&gt;链&lt;/a&gt;，其开始和结束以相同的&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c625315e724838d98d1c1aabd8894d579826b898" translate="yes" xml:space="preserve">
          <source>Directly insert the specified info into the index. For backward compatibility, you can also give these three arguments as three separate parameters, but new users are encouraged to use a single-parameter form.</source>
          <target state="translated">直接将指定的信息插入到索引中。为了向后兼容,你也可以把这三个参数作为三个独立的参数,但鼓励新用户使用单参数形式。</target>
        </trans-unit>
        <trans-unit id="9885bf10483d3b24cb6bcd826a7eb7299ae266e3" translate="yes" xml:space="preserve">
          <source>Directory in which to place the individual messages.</source>
          <target state="translated">放置各个信息的目录。</target>
        </trans-unit>
        <trans-unit id="bdcdfee6c90a03fd94f3c634dadb758ff39de642" translate="yes" xml:space="preserve">
          <source>Directory rename detection</source>
          <target state="translated">目录重命名检测</target>
        </trans-unit>
        <trans-unit id="aa2b3e6516957862f26d56361af6f4de78735eee" translate="yes" xml:space="preserve">
          <source>Directory rename detection works with the merge backend to provide you warnings in such cases.</source>
          <target state="translated">目录重命名检测与合并后台一起工作,在这种情况下为您提供警告。</target>
        </trans-unit>
        <trans-unit id="0c0e7bc3f2d3ebf022d4ca57e3f30fa5aada7044" translate="yes" xml:space="preserve">
          <source>Directory rename heuristics are enabled in the merge and interactive backends. Due to the lack of accurate tree information, directory rename detection is disabled in the am backend.</source>
          <target state="translated">在合并和交互式后端启用了目录重命名启发式方法,由于缺乏准确的树信息,在am后端禁用了目录重命名检测。由于缺乏准确的树信息,am后端目录重命名检测被禁用。</target>
        </trans-unit>
        <trans-unit id="8016592b1dadffa6a4ff10aa4ea912d754ba679a" translate="yes" xml:space="preserve">
          <source>Disable SMTP authentication. Short hand for &lt;code&gt;--smtp-auth=none&lt;/code&gt;</source>
          <target state="translated">禁用SMTP身份验证。短手 &lt;code&gt;--smtp-auth=none&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8effb38233ed8f993bad8ba7def3e4c7198d5381" translate="yes" xml:space="preserve">
          <source>Disable all charset re-coding of the metadata.</source>
          <target state="translated">禁用元数据的所有字符集重新编码。</target>
        </trans-unit>
        <trans-unit id="bff793fc9150fa9cc2d296006f1d7ecf24724c75" translate="yes" xml:space="preserve">
          <source>Disable all logging.</source>
          <target state="translated">禁用所有记录。</target>
        </trans-unit>
        <trans-unit id="6a02367b3dfa3269f43aabd8b369dc39498517bc" translate="yes" xml:space="preserve">
          <source>Disable all output of the program. Implies &lt;code&gt;--exit-code&lt;/code&gt;.</source>
          <target state="translated">禁用程序的所有输出。意味着 &lt;code&gt;--exit-code&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d72da5aaef63acc8729bbf0d8f490956106bf35b" translate="yes" xml:space="preserve">
          <source>Disable output of diffs for merge commits (default). Useful to override &lt;code&gt;-m&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt;, or &lt;code&gt;--cc&lt;/code&gt;.</source>
          <target state="translated">为合并提交禁用差异输出（默认）。对覆盖 &lt;code&gt;-m&lt;/code&gt; ， &lt;code&gt;-c&lt;/code&gt; 或 &lt;code&gt;--cc&lt;/code&gt; 很有用。</target>
        </trans-unit>
        <trans-unit id="65ffdeb8d93ba1775007aefed8ede380f65dc5fc" translate="yes" xml:space="preserve">
          <source>Disable recursive fetching of submodules (this has the same effect as using the &lt;code&gt;--recurse-submodules=no&lt;/code&gt; option).</source>
          <target state="translated">禁用子模块的递归提取（与使用 &lt;code&gt;--recurse-submodules=no&lt;/code&gt; 选项具有相同的效果）。</target>
        </trans-unit>
        <trans-unit id="9197fea967c3dddcae2815fd5c61af7013500ac4" translate="yes" xml:space="preserve">
          <source>Disable sparse checkout support even if &lt;code&gt;core.sparseCheckout&lt;/code&gt; is true.</source>
          <target state="translated">即使 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 为true，也请禁用稀疏签出支持。</target>
        </trans-unit>
        <trans-unit id="90bc67ccb52fc4f00ea5bb7d3ea677b5d866b7a3" translate="yes" xml:space="preserve">
          <source>Disable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; config setting, and restore the working directory to include all files. Leaves the sparse-checkout file intact so a later &lt;code&gt;git sparse-checkout init&lt;/code&gt; command may return the working directory to the same state.</source>
          <target state="translated">禁用 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 配置设置，并还原工作目录以包括所有文件。使sparse-checkout文件保持完整，因此以后的 &lt;code&gt;git sparse-checkout init&lt;/code&gt; 命令可能会使工作目录返回相同状态。</target>
        </trans-unit>
        <trans-unit id="850c7ae0114510cb68dad1845148d77f171826d0" translate="yes" xml:space="preserve">
          <source>Disable the automatic rebase after all commits have been successfully submitted. Can also be set with git-p4.disableRebase.</source>
          <target state="translated">在所有提交成功后,禁用自动重垒。也可以使用 git-p4.disableRebase 进行设置。</target>
        </trans-unit>
        <trans-unit id="70abb355de69ea1d7f24feac052795b5a3ce287a" translate="yes" xml:space="preserve">
          <source>Disable the automatic sync of p4/master from Perforce after commits have been submitted. Implies --disable-rebase. Can also be set with git-p4.disableP4Sync. Sync with origin/master still goes ahead if possible.</source>
          <target state="translated">提交提交后,禁用 Perforce 的 p4/master 自动同步。意味着 --disable-rebase,也可以用 git-p4.disableP4Sync 设置。也可以用 git-p4.disableP4Sync 设置。如果可能的话,与origin/master的同步仍然会进行。</target>
        </trans-unit>
        <trans-unit id="81f65186f299582e8d75d06c846cd0089af76798" translate="yes" xml:space="preserve">
          <source>Disable the creation of an attachment, overriding the configuration setting.</source>
          <target state="translated">禁用附件的创建,覆盖配置设置。</target>
        </trans-unit>
        <trans-unit id="bf4cee356cf7010ff2baed05e8bfe18333a1862b" translate="yes" xml:space="preserve">
          <source>Disable the indent heuristic.</source>
          <target state="translated">禁用缩进启发式。</target>
        </trans-unit>
        <trans-unit id="ca23a42f95c7adc909029c511091f97b9f4f227c" translate="yes" xml:space="preserve">
          <source>Disable the output shown by --stats, making fast-import usually be silent when it is successful. However, if the import stream has directives intended to show user output (e.g. &lt;code&gt;progress&lt;/code&gt; directives), the corresponding messages will still be shown.</source>
          <target state="translated">禁用--stats显示的输出，通常使成功导入时，快速导入通常处于静默状态。但是，如果导入流具有旨在显示用户输出的指令（例如， &lt;code&gt;progress&lt;/code&gt; 指令），则仍将显示相应的消息。</target>
        </trans-unit>
        <trans-unit id="10ad29909e3f37bb2f27c987f74a4679173f8135" translate="yes" xml:space="preserve">
          <source>Disable the use of format=flowed: Edit..Preferences..Advanced..Config Editor. Search for &quot;mailnews.send_plaintext_flowed&quot;. Toggle it to make sure it is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">禁用format = flowed：Edit..Preferences..Advanced..Config编辑器。搜索&amp;ldquo; mailnews.send_plaintext_flowed&amp;rdquo;。切换它以确保将其设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="858dc1d60e7e85d31f91783e5cf3256c04a8098e" translate="yes" xml:space="preserve">
          <source>Disable word diff again.</source>
          <target state="translated">再次禁用字差。</target>
        </trans-unit>
        <trans-unit id="52c6bf677e030bd9b9c77d01d12b29e894c5d472" translate="yes" xml:space="preserve">
          <source>Disables the &lt;code&gt;renormalize&lt;/code&gt; option. This overrides the &lt;code&gt;merge.renormalize&lt;/code&gt; configuration variable.</source>
          <target state="translated">禁用 &lt;code&gt;renormalize&lt;/code&gt; 选项。这将覆盖 &lt;code&gt;merge.renormalize&lt;/code&gt; 配置变量。</target>
        </trans-unit>
        <trans-unit id="493a0332cb486f682d77bc8e837afda65d0ed478" translate="yes" xml:space="preserve">
          <source>Disallow external diff drivers.</source>
          <target state="translated">不允许使用外部差速器。</target>
        </trans-unit>
        <trans-unit id="ede3a1ef0a8990ff80cb58919eb8be7140b4f5fa" translate="yes" xml:space="preserve">
          <source>Discard the specified revision as well, keeping the nearest parent instead.</source>
          <target state="translated">将指定的修订版也丢弃,而保留最近的父版。</target>
        </trans-unit>
        <trans-unit id="8fb937b602b4f2ef21c7fab00ac15de3b3ba49ea" translate="yes" xml:space="preserve">
          <source>Discussion</source>
          <target state="translated">Discussion</target>
        </trans-unit>
        <trans-unit id="f1c3b4b6756e9452cf8283101c3b08d9ce1ba40d" translate="yes" xml:space="preserve">
          <source>Discussion on fork-point mode</source>
          <target state="translated">关于叉点模式的讨论</target>
        </trans-unit>
        <trans-unit id="cb8eae11c31d8b3c1e7747fe036d2ab3b1d1b780" translate="yes" xml:space="preserve">
          <source>Display branch listing in columns. See configuration variable column.branch for option syntax.&lt;code&gt;--column&lt;/code&gt; and &lt;code&gt;--no-column&lt;/code&gt; without options are equivalent to &lt;code&gt;always&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt; respectively.</source>
          <target state="translated">在列中显示分支列表。有关选项语法，请参见配置变量column.branch。 &lt;code&gt;--column&lt;/code&gt; 和 &lt;code&gt;--no-column&lt;/code&gt; 不带选项相当于 &lt;code&gt;always&lt;/code&gt; 和 &lt;code&gt;never&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="25deb208645941865b584087b241dc58f16bb18f" translate="yes" xml:space="preserve">
          <source>Display data in columns</source>
          <target state="translated">按列显示数据</target>
        </trans-unit>
        <trans-unit id="00fa8df96d22edc1ad7e63a08b37f36b16a61d74" translate="yes" xml:space="preserve">
          <source>Display diffs for the current state of the resolution. It is useful for tracking what has changed while the user is resolving conflicts. Additional arguments are passed directly to the system &lt;code&gt;diff&lt;/code&gt; command installed in PATH.</source>
          <target state="translated">显示分辨率当前状态的差异。这对于跟踪用户解决冲突时发生的更改很有用。其他参数直接传递给安装在PATH中的system &lt;code&gt;diff&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="a0cdcc7c7b07a8e4a90c3d5151fd195fb7223cf9" translate="yes" xml:space="preserve">
          <source>Display gitattributes information</source>
          <target state="translated">显示gitattributes信息</target>
        </trans-unit>
        <trans-unit id="941f2ea6c160e300fb40d6a55431420274d37d56" translate="yes" xml:space="preserve">
          <source>Display help information about Git</source>
          <target state="translated">显示关于Git的帮助信息</target>
        </trans-unit>
        <trans-unit id="5a9a3798add08be0e1f47ed8edfc2983b20e1a95" translate="yes" xml:space="preserve">
          <source>Display manual page for the command in the &lt;code&gt;info&lt;/code&gt; format. The &lt;code&gt;info&lt;/code&gt; program will be used for that purpose.</source>
          <target state="translated">以 &lt;code&gt;info&lt;/code&gt; 格式显示命令的手册页。该 &lt;code&gt;info&lt;/code&gt; 程序将用于该目的。</target>
        </trans-unit>
        <trans-unit id="e1ec38994d3bd8f0be2469bcb050567ebcdb5526" translate="yes" xml:space="preserve">
          <source>Display manual page for the command in the &lt;code&gt;man&lt;/code&gt; format. This option may be used to override a value set in the &lt;code&gt;help.format&lt;/code&gt; configuration variable.</source>
          <target state="translated">以 &lt;code&gt;man&lt;/code&gt; 格式显示命令的手册页。此选项可用于覆盖在 &lt;code&gt;help.format&lt;/code&gt; 配置变量中设置的值。</target>
        </trans-unit>
        <trans-unit id="92ffa56daac223805fbe702e38ef997d8109fbdd" translate="yes" xml:space="preserve">
          <source>Display manual page for the command in the &lt;code&gt;web&lt;/code&gt; (HTML) format. A web browser will be used for that purpose.</source>
          <target state="translated">以 &lt;code&gt;web&lt;/code&gt; （HTML）格式显示命令的手册页。为此将使用网络浏览器。</target>
        </trans-unit>
        <trans-unit id="f3b82a6e6a357a0bf9773d3a79c96ba1e61e31cb" translate="yes" xml:space="preserve">
          <source>Display or do not display detailed ahead/behind counts for the branch relative to its upstream branch. Defaults to true.</source>
          <target state="translated">显示或不显示分支相对于其上游分支的详细超前/落后计数。默认为 &quot;true&quot;。</target>
        </trans-unit>
        <trans-unit id="f65810bba6d242e31829fe1b50da76b80381c4b9" translate="yes" xml:space="preserve">
          <source>Display some basic statistics about the objects fast-import has created, the packfiles they were stored into, and the memory used by fast-import during this run. Showing this output is currently the default, but can be disabled with --quiet.</source>
          <target state="translated">显示关于 fast-import 所创建的对象的一些基本统计数据、它们被存储到的 packfiles 以及 fast-import 在这次运行中使用的内存。目前默认显示这个输出,但可以用--quiet禁用。</target>
        </trans-unit>
        <trans-unit id="64158f1a0a1ec112852f04c5185015874a0e4c81" translate="yes" xml:space="preserve">
          <source>Display specific annotated tag (tag object).</source>
          <target state="translated">显示特定的注释标签(标签对象)。</target>
        </trans-unit>
        <trans-unit id="c6c2de616f34899ad73b615717fbe54f7ad5df4c" translate="yes" xml:space="preserve">
          <source>Display tag listing in columns. See configuration variable column.tag for option syntax.&lt;code&gt;--column&lt;/code&gt; and &lt;code&gt;--no-column&lt;/code&gt; without options are equivalent to &lt;code&gt;always&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt; respectively.</source>
          <target state="translated">在列中显示标签列表。有关选项语法，请参见配置变量column.tag。 &lt;code&gt;--column&lt;/code&gt; 和 &lt;code&gt;--no-column&lt;/code&gt; 不带选项相当于 &lt;code&gt;always&lt;/code&gt; 和 &lt;code&gt;never&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="1a3622cde828191996e0ecf195f03d03b3ec44d7" translate="yes" xml:space="preserve">
          <source>Display the currently running version of &lt;code&gt;git gui&lt;/code&gt;.</source>
          <target state="translated">显示当前正在运行的 &lt;code&gt;git gui&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="93da4437ffd9aa5715f14a3f0dacdb3439b3cf81" translate="yes" xml:space="preserve">
          <source>Display the full sha1s in the output listing rather than abbreviating them.</source>
          <target state="translated">在输出列表中显示完整的sha1s,而不是缩写它们。</target>
        </trans-unit>
        <trans-unit id="9f1c97cf9d8e74c2fc80265ab817ac9d7b832aa6" translate="yes" xml:space="preserve">
          <source>Display untracked files in columns. See configuration variable column.status for option syntax.&lt;code&gt;--column&lt;/code&gt; and &lt;code&gt;--no-column&lt;/code&gt; without options are equivalent to &lt;code&gt;always&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt; respectively.</source>
          <target state="translated">在列中显示未跟踪的文件。有关选项语法，请参见配置变量column.status。 &lt;code&gt;--column&lt;/code&gt; 和 &lt;code&gt;--no-column&lt;/code&gt; 不带选项相当于 &lt;code&gt;always&lt;/code&gt; 和 &lt;code&gt;never&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="7092e241896d60ac87e32bb3193290cccc38af84" translate="yes" xml:space="preserve">
          <source>Display usage.</source>
          <target state="translated">显示用途。</target>
        </trans-unit>
        <trans-unit id="7079ee902153dd291ddf916bbe088b722407f696" translate="yes" xml:space="preserve">
          <source>Displays changes in a repository or a selected set of commits. This includes visualizing the commit graph, showing information related to each commit, and the files in the trees of each revision.</source>
          <target state="translated">显示一个版本库或一组选定的提交中的变化,包括可视化的提交图,显示与每个提交相关的信息,以及每个版本树中的文件。这包括可视化的提交图,显示与每个提交相关的信息,以及每个版本树中的文件。</target>
        </trans-unit>
        <trans-unit id="298c129f2e50c144c7e71d42c00becc8dea6a583" translate="yes" xml:space="preserve">
          <source>Displays paths that have differences between the index file and the current HEAD commit, paths that have differences between the working tree and the index file, and paths in the working tree that are not tracked by Git (and are not ignored by &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;). The first are what you &lt;code&gt;would&lt;/code&gt; commit by running &lt;code&gt;git commit&lt;/code&gt;; the second and third are what you &lt;code&gt;could&lt;/code&gt; commit by running &lt;code&gt;git add&lt;/code&gt; before running &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">显示索引文件和当前HEAD提交之间具有差异的路径，工作树和索引文件之间具有差异的路径以及Git不会跟踪（并且&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;不会忽略的路径））。首先你是什么人 &lt;code&gt;would&lt;/code&gt; 通过运行犯 &lt;code&gt;git commit&lt;/code&gt; ; 第二和第三个是在运行 &lt;code&gt;git commit&lt;/code&gt; 之前 &lt;code&gt;could&lt;/code&gt; 通过运行 &lt;code&gt;git add&lt;/code&gt; 提交的内容。</target>
        </trans-unit>
        <trans-unit id="a629570fab6639c414ba6b626507dad99fc801af" translate="yes" xml:space="preserve">
          <source>Displays references available in a local repository along with the associated commit IDs. Results can be filtered using a pattern and tags can be dereferenced into object IDs. Additionally, it can be used to test whether a particular ref exists.</source>
          <target state="translated">显示本地版本库中可用的引用以及相关的提交 ID。结果可以使用模式进行过滤,标签可以衍生为对象 ID。此外,它还可以用来测试一个特定的引用是否存在。</target>
        </trans-unit>
        <trans-unit id="552e170818d4ff73bae847a17956173c4cb34b11" translate="yes" xml:space="preserve">
          <source>Displays references available in a remote repository along with the associated commit IDs.</source>
          <target state="translated">显示远程仓库中可用的引用以及相关的提交 ID。</target>
        </trans-unit>
        <trans-unit id="96528dc0170b433d5bf734338e53f84118e8892f" translate="yes" xml:space="preserve">
          <source>Displays summary about given repository. This is the default command if no action is specified in URL, and only repository is specified.</source>
          <target state="translated">显示指定版本库的摘要。如果在URL中没有指定动作,并且只指定了仓库,则该命令为默认命令。</target>
        </trans-unit>
        <trans-unit id="a0bdba2bfb43b133e65f6e75b6b8767f5a655c4d" translate="yes" xml:space="preserve">
          <source>Distributed workflows</source>
          <target state="translated">分布式工作流程</target>
        </trans-unit>
        <trans-unit id="862f8a0b24f2fede02b5c7614fea634d5e3205d5" translate="yes" xml:space="preserve">
          <source>Do everything except actually send the emails.</source>
          <target state="translated">除了实际发送邮件外,其他都要做。</target>
        </trans-unit>
        <trans-unit id="c0cf7c46b6d09d46245bbf190b286bb681387914" translate="yes" xml:space="preserve">
          <source>Do everything except actually send the updates.</source>
          <target state="translated">除了实际发送更新外,其他的都要做。</target>
        </trans-unit>
        <trans-unit id="2391ab0a15e29de8c553f138bc9a5e5e1eff2f5d" translate="yes" xml:space="preserve">
          <source>Do not GPG-sign commit, to countermand a &lt;code&gt;--gpg-sign&lt;/code&gt; option given earlier on the command line.</source>
          <target state="translated">不要使用GPG-sign提交来 &lt;code&gt;--gpg-sign&lt;/code&gt; 命令行前面给出的--gpg-sign选项。</target>
        </trans-unit>
        <trans-unit id="e60712f9f236c24928017c46a4121b75b37250b5" translate="yes" xml:space="preserve">
          <source>Do not actually prune any entries; just show what would have been pruned.</source>
          <target state="translated">不要实际修剪任何条目,只需显示本应修剪的内容。</target>
        </trans-unit>
        <trans-unit id="c1e5372fe0faa123824db425165ec2fea2793861" translate="yes" xml:space="preserve">
          <source>Do not add the Message-ID header to the commit message. &lt;code&gt;no-message-id&lt;/code&gt; is useful to override &lt;code&gt;am.messageid&lt;/code&gt;.</source>
          <target state="translated">不要将Message-ID标头添加到提交消息中。 &lt;code&gt;no-message-id&lt;/code&gt; 有助于覆盖 &lt;code&gt;am.messageid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57e3f3ba3ed0b684d610d78f35decbf2d82cbdb0" translate="yes" xml:space="preserve">
          <source>Do not assume that the remote repository is complete in its current state, and verify all objects in the entire local ref&amp;rsquo;s history exist in the remote repository.</source>
          <target state="translated">不要假设远程存储库在其当前状态下是完整的，请验证远程存储库中是否存在整个本地引用历史记录中的所有对象。</target>
        </trans-unit>
        <trans-unit id="90fec1270ba2d2b20ae4223418ef68e2bfdd8b58" translate="yes" xml:space="preserve">
          <source>Do not change the message at all.</source>
          <target state="translated">完全不要改变信息。</target>
        </trans-unit>
        <trans-unit id="08226113a8a9e7f80d0cdebc9507aad8bbcea024" translate="yes" xml:space="preserve">
          <source>Do not checkout the new working tree at each iteration of the bisection process. Instead just update a special reference named &lt;code&gt;BISECT_HEAD&lt;/code&gt; to make it point to the commit that should be tested.</source>
          <target state="translated">不要在二等分过程的每次迭代中检出新的工作树。相反，只需更新一个名为 &lt;code&gt;BISECT_HEAD&lt;/code&gt; 的特殊引用，使其指向应进行测试的提交即可。</target>
        </trans-unit>
        <trans-unit id="032bbf4a51cb5f8b4c87bc5a87ccbf7ce7d9972e" translate="yes" xml:space="preserve">
          <source>Do not complain about a failed merge program (a merge program failure usually indicates conflicts during the merge). This is for porcelains which might want to emit custom messages.</source>
          <target state="translated">不要抱怨合并程序失败(合并程序失败通常表示合并过程中的冲突)。这是为那些可能想要发出自定义消息的瓷器准备的。</target>
        </trans-unit>
        <trans-unit id="828652d2b0b568421d6c7e9bbf13386dea23e106" translate="yes" xml:space="preserve">
          <source>Do not consider commits that are referenced only by an entry in a reflog to be reachable. This option is meant only to search for commits that used to be in a ref, but now aren&amp;rsquo;t, but are still in that corresponding reflog.</source>
          <target state="translated">不要认为仅由reflog中的条目引用的提交是可到达的。此选项仅用于搜索以前在引用中但现在不在引用中但仍在相应引用日志中的提交。</target>
        </trans-unit>
        <trans-unit id="e869fbf733c283b771007d82b91f9b0969cfb747" translate="yes" xml:space="preserve">
          <source>Do not consider it an error to request removing notes from an object that does not have notes attached to it.</source>
          <target state="translated">不要认为要求从一个没有附加注解的对象中删除注解是一个错误。</target>
        </trans-unit>
        <trans-unit id="1ecb147f602b4581f87540a29b063aa61604b712" translate="yes" xml:space="preserve">
          <source>Do not consider tags matching the given &lt;code&gt;glob(7)&lt;/code&gt; pattern, excluding the &quot;refs/tags/&quot; prefix. If used with &lt;code&gt;--all&lt;/code&gt;, it also does not consider local branches and remote-tracking references matching the pattern, excluding respectively &quot;refs/heads/&quot; and &quot;refs/remotes/&quot; prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated and tags matching any of the patterns will be excluded. When combined with --match a tag will be considered when it matches at least one --match pattern and does not match any of the --exclude patterns. Use &lt;code&gt;--no-exclude&lt;/code&gt; to clear and reset the list of patterns.</source>
          <target state="translated">不要考虑与给定 &lt;code&gt;glob(7)&lt;/code&gt; 模式匹配的标签，但不包括&amp;ldquo; refs / tags /&amp;rdquo;前缀。如果与 &lt;code&gt;--all&lt;/code&gt; 一起使用，它还将不考虑与该模式匹配的本地分支和远程跟踪引用，分别不包括&amp;ldquo; refs / heads /&amp;rdquo;和&amp;ldquo; refs / remotes /&amp;rdquo;前缀；从不考虑其他类型的引用。如果多次给出，则将累积模式列表，并且将排除与任何模式匹配的标签。与--match结合使用时，如果标签至少匹配一个--match模式且不匹配任何--exclude模式，则将考虑标记。使用 &lt;code&gt;--no-exclude&lt;/code&gt; 清除并重置模式列表。</target>
        </trans-unit>
        <trans-unit id="cbee51a4ce4cd8d3b18625054a20f9ac8b7d3532" translate="yes" xml:space="preserve">
          <source>Do not consider the on-disk file at all.</source>
          <target state="translated">完全不考虑磁盘上的文件。</target>
        </trans-unit>
        <trans-unit id="037f30ef5e84974359cf44c16519221f2879783e" translate="yes" xml:space="preserve">
          <source>Do not create a commit, but show a list of paths that are to be committed, paths with local changes that will be left uncommitted and paths that are untracked.</source>
          <target state="translated">不要创建提交,而是显示要提交的路径列表,有局部变化的路径将不提交,未跟踪的路径。</target>
        </trans-unit>
        <trans-unit id="8cc46cc75e4001540bdd6b36d05862e218e46c47" translate="yes" xml:space="preserve">
          <source>Do not create objects in the object database for all &amp;lt;file&amp;gt; arguments that follow this flag; just insert their object IDs into the index.</source>
          <target state="translated">不要在对象数据库中为该标志后面的所有&amp;lt;file&amp;gt;自变量创建对象；只需将其对象ID插入索引中即可。</target>
        </trans-unit>
        <trans-unit id="7cb5295efb5286a379b8d83e6238db5f1ea1b2fa" translate="yes" xml:space="preserve">
          <source>Do not fetch remotely; only run &lt;code&gt;git rebase&lt;/code&gt; against the last fetched commit from the upstream SVN.</source>
          <target state="translated">不要远程获取；仅针对从上游SVN提取的最后一次提交运行 &lt;code&gt;git rebase&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97bf9439cf9070cedb99b3389632fc0fbbcf9edf" translate="yes" xml:space="preserve">
          <source>Do not honor textconv filter settings. This is the default.</source>
          <target state="translated">不尊重textconv过滤器设置。这是默认的。</target>
        </trans-unit>
        <trans-unit id="642b94f1b0f16f8086c6d9b3c2a88d58a07a371f" translate="yes" xml:space="preserve">
          <source>Do not ignore whitespace when performing move detection.</source>
          <target state="translated">在进行移动检测时,不要忽略空白处。</target>
        </trans-unit>
        <trans-unit id="59383a29c043832ab98b518f841a638207c2a6f4" translate="yes" xml:space="preserve">
          <source>Do not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as &lt;code&gt;--color-moved-ws=no&lt;/code&gt;.</source>
          <target state="translated">执行移动检测时，请勿忽略空格。这可用于覆盖配置设置。与 &lt;code&gt;--color-moved-ws=no&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f9b8ad508a1efad0691851330497788c20711761" translate="yes" xml:space="preserve">
          <source>Do not include a patch that matches a commit in &amp;lt;until&amp;gt;..&amp;lt;since&amp;gt;. This will examine all patches reachable from &amp;lt;since&amp;gt; but not from &amp;lt;until&amp;gt; and compare them with the patches being generated, and any patch that matches is ignored.</source>
          <target state="translated">不要包含与&amp;lt;until&amp;gt; .. &amp;lt;since&amp;gt;中的提交匹配的补丁。这将检查从&amp;lt;since&amp;gt;可访问的所有补丁，但不能从&amp;lt;until&amp;gt;进行访问，并将它们与正在生成的补丁进行比较，所有匹配的补丁都将被忽略。</target>
        </trans-unit>
        <trans-unit id="06c89fdde45df9764a8423e7bd3a2334bae4fdd3" translate="yes" xml:space="preserve">
          <source>Do not include refs matching &lt;code&gt;&amp;lt;glob-pattern&amp;gt;&lt;/code&gt; that the next &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--branches&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt;, &lt;code&gt;--remotes&lt;/code&gt;, or &lt;code&gt;--glob&lt;/code&gt; would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--branches&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt;, &lt;code&gt;--remotes&lt;/code&gt;, or &lt;code&gt;--glob&lt;/code&gt; option (other options or arguments do not clear accumulated patterns).</source>
          <target state="translated">不要包括与 &lt;code&gt;&amp;lt;glob-pattern&amp;gt;&lt;/code&gt; 匹配的refs ， &lt;code&gt;--branches&lt;/code&gt; 下一个 &lt;code&gt;--all&lt;/code&gt; ，-- branches，-- &lt;code&gt;--tags&lt;/code&gt; ，-- &lt;code&gt;--remotes&lt;/code&gt; 或 &lt;code&gt;--glob&lt;/code&gt; 都会考虑使用这些引用。重复此选项将累积排除模式，直到下一个 &lt;code&gt;--all&lt;/code&gt; ，-- &lt;code&gt;--branches&lt;/code&gt; ，-- &lt;code&gt;--tags&lt;/code&gt; ，-- &lt;code&gt;--remotes&lt;/code&gt; 或 &lt;code&gt;--glob&lt;/code&gt; 选项（其他选项或参数不会清除累积的模式）。</target>
        </trans-unit>
        <trans-unit id="56a32ccb3c1f1c18304a762968ab21163044c5c3" translate="yes" xml:space="preserve">
          <source>Do not include the output of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; in the commit message template when using an editor to prepare the default commit message.</source>
          <target state="translated">使用编辑器准备默认提交消息时，请勿在提交消息模板中包括&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;的输出。</target>
        </trans-unit>
        <trans-unit id="6b5bd4195c1d74a2912285d2c4eb0c2dba4c1afa" translate="yes" xml:space="preserve">
          <source>Do not interpret any more arguments as options.</source>
          <target state="translated">不要将更多的参数解释为选项。</target>
        </trans-unit>
        <trans-unit id="e5da1b4ac510b79eb35b9d691f72663928bb7698" translate="yes" xml:space="preserve">
          <source>Do not invoke &lt;code&gt;git unpack-objects&lt;/code&gt; on received data, but create a single packfile out of it instead, and store it in the object database. If provided twice then the pack is locked against repacking.</source>
          <target state="translated">不要在接收到的数据上调用 &lt;code&gt;git unpack-objects&lt;/code&gt; ，而是从中创建一个单独的packfile，并将其存储在对象数据库中。如果提供两次，则包装被锁定以防止重新包装。</target>
        </trans-unit>
        <trans-unit id="beae705e0d7e9c4e2c66edfac5f5628c8ca8684b" translate="yes" xml:space="preserve">
          <source>Do not issue an error message if the &amp;lt;name&amp;gt; is not a symbolic ref but a detached HEAD; instead exit with non-zero status silently.</source>
          <target state="translated">如果&amp;lt;name&amp;gt;不是符号ref而是分离的HEAD，请不要发出错误消息。而是以非零状态静默退出。</target>
        </trans-unit>
        <trans-unit id="25d9eebc562b1a06ce597634bc396c0323e9fb5d" translate="yes" xml:space="preserve">
          <source>Do not keep commits that start empty before the rebase (i.e. that do not change anything from its parent) in the result. The default is to keep commits which start empty, since creating such commits requires passing the --allow-empty override flag to &lt;code&gt;git commit&lt;/code&gt;, signifying that a user is very intentionally creating such a commit and thus wants to keep it.</source>
          <target state="translated">在结果变基之前，不要保留开始为空的提交（即，不会对其父对象进行任何更改）的提交。默认是保留开始为空的提交，因为创建此类提交要求将--allow-empty覆盖标志传递给 &lt;code&gt;git commit&lt;/code&gt; ，表示用户非常有意创建此类提交并因此希望保留它。</target>
        </trans-unit>
        <trans-unit id="d96f65c98da537beaa0a86a4d3aea2125b47b691" translate="yes" xml:space="preserve">
          <source>Do not limit the listing to the current working directory. Implies --full-name.</source>
          <target state="translated">不要将列表限制在当前工作目录中。意味着--全名。</target>
        </trans-unit>
        <trans-unit id="0ec876803cf466a9324414e97bc9d68e8edc56a9" translate="yes" xml:space="preserve">
          <source>Do not list empty directories. Has no effect without --directory.</source>
          <target state="translated">不列出空目录。如果没有--directory,则没有效果。</target>
        </trans-unit>
        <trans-unit id="96b8b2c721697c15e0778ab602142e2343cf1855" translate="yes" xml:space="preserve">
          <source>Do not list one-line descriptions from the actual commits being merged.</source>
          <target state="translated">不要列举实际提交中的单行描述。</target>
        </trans-unit>
        <trans-unit id="50c8933f0d365d96e0aba5401a78a6eff6e0fcc0" translate="yes" xml:space="preserve">
          <source>Do not merge to downstream except with a good reason: upstream API changes affect your branch; your branch no longer merges to upstream cleanly; etc.</source>
          <target state="translated">除非有充分的理由,否则不要合并到下游:上游API的变化影响了你的分支;你的分支不再干净利落地合并到上游;等等。</target>
        </trans-unit>
        <trans-unit id="20453559ed97130ebcc8684bdfc96d4e211050a6" translate="yes" xml:space="preserve">
          <source>Do not notice anything as error.</source>
          <target state="translated">不要发现任何错误。</target>
        </trans-unit>
        <trans-unit id="6c8215f8ad086bc4c804beee0595714130addff4" translate="yes" xml:space="preserve">
          <source>Do not output contents of changes in binary files, instead display a notice that those files changed. Patches generated using this option cannot be applied properly, but they are still useful for code review.</source>
          <target state="translated">不输出二进制文件中的更改内容,而是显示这些文件更改的通知。使用此选项生成的补丁不能被正确应用,但它们对代码审查仍然有用。</target>
        </trans-unit>
        <trans-unit id="2523ea10fe468312c71da3f45d33ec2f934186fc" translate="yes" xml:space="preserve">
          <source>Do not output flag parameters.</source>
          <target state="translated">不要输出标志参数。</target>
        </trans-unit>
        <trans-unit id="97d9ab4b88ae45778b7b3d001e321ad0dc14c371" translate="yes" xml:space="preserve">
          <source>Do not output flags and parameters meant for &lt;code&gt;git rev-list&lt;/code&gt; command.</source>
          <target state="translated">不要输出用于 &lt;code&gt;git rev-list&lt;/code&gt; 命令的标志和参数。</target>
        </trans-unit>
        <trans-unit id="f763f44ab0f0b262c4086b5b655e472e8e1fbc54" translate="yes" xml:space="preserve">
          <source>Do not output flags and parameters not meant for &lt;code&gt;git rev-list&lt;/code&gt; command.</source>
          <target state="translated">不要输出不适合 &lt;code&gt;git rev-list&lt;/code&gt; 命令的标志和参数。</target>
        </trans-unit>
        <trans-unit id="08b6c73b9a5b9ae8b10db84ed02aa9ff12c3dacb" translate="yes" xml:space="preserve">
          <source>Do not output matched lines; instead, exit with status 0 when there is a match and with non-zero status when there isn&amp;rsquo;t.</source>
          <target state="translated">不输出匹配的线；相反，如果存在匹配项，则以状态0退出；如果不存在，则以非零状态退出。</target>
        </trans-unit>
        <trans-unit id="ee712c84633a2927c1551bcb0103dc0873b40235" translate="yes" xml:space="preserve">
          <source>Do not output non-flag parameters.</source>
          <target state="translated">不要输出非标志参数。</target>
        </trans-unit>
        <trans-unit id="803c0ba19a9790046951938b8c5d1389018a1cc7" translate="yes" xml:space="preserve">
          <source>Do not pay attention to ignored files specified via the &lt;code&gt;.gitignore&lt;/code&gt; mechanism. Only useful when searching files in the current directory with &lt;code&gt;--no-index&lt;/code&gt;.</source>
          <target state="translated">不要注意通过 &lt;code&gt;.gitignore&lt;/code&gt; 机制指定的忽略文件。仅在使用 &lt;code&gt;--no-index&lt;/code&gt; 搜索当前目录中的文件时有用。</target>
        </trans-unit>
        <trans-unit id="ac83dbcf3d4693958a0fe122034c7cc31b273fa9" translate="yes" xml:space="preserve">
          <source>Do not perform optional operations that require locks. This is equivalent to setting the &lt;code&gt;GIT_OPTIONAL_LOCKS&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">不要执行需要锁定的可选操作。这等效于将 &lt;code&gt;GIT_OPTIONAL_LOCKS&lt;/code&gt; 设置为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3857914d38ac6fc1cf3a0581728d470a65e02771" translate="yes" xml:space="preserve">
          <source>Do not pipe Git output into a pager.</source>
          <target state="translated">不要把Git的输出管到寻呼机里。</target>
        </trans-unit>
        <trans-unit id="d083af3d8a98a88b0736219c9a712ace923e74ce" translate="yes" xml:space="preserve">
          <source>Do not print any progress information.</source>
          <target state="translated">不要打印任何进度信息。</target>
        </trans-unit>
        <trans-unit id="4f306796a802facf6a3ec8eb763307ebdfcd6b65" translate="yes" xml:space="preserve">
          <source>Do not print any results to stdout. When combined with &lt;code&gt;--verify&lt;/code&gt; this can be used to silently check if a reference exists.</source>
          <target state="translated">不要将任何结果打印到标准输出。与 &lt;code&gt;--verify&lt;/code&gt; 结合使用时，可用于静默检查引用是否存在。</target>
        </trans-unit>
        <trans-unit id="d36888af86796f130618636768f7e10c682f8ef3" translate="yes" xml:space="preserve">
          <source>Do not print commits with more than one parent. This is exactly the same as &lt;code&gt;--max-parents=1&lt;/code&gt;.</source>
          <target state="translated">不要打印多于一个父项的提交。这与 &lt;code&gt;--max-parents=1&lt;/code&gt; 完全相同。</target>
        </trans-unit>
        <trans-unit id="ca4c10c14f4ba2f9f3e2f89755711c5fc9a52157" translate="yes" xml:space="preserve">
          <source>Do not print remote URL to stderr.</source>
          <target state="translated">不要将远程URL打印到stderr。</target>
        </trans-unit>
        <trans-unit id="808049e7ffec5b6e655b6a9d9ae72d8ecb3de856" translate="yes" xml:space="preserve">
          <source>Do not print the names of the generated files to standard output.</source>
          <target state="translated">不要将生成的文件名打印成标准输出。</target>
        </trans-unit>
        <trans-unit id="bc87e43a7d98a5c7571b51e67897a36a4ca8ab2b" translate="yes" xml:space="preserve">
          <source>Do not prompt before launching a diff tool.</source>
          <target state="translated">在启动diff工具之前,请不要提示。</target>
        </trans-unit>
        <trans-unit id="2138cd0cdb77e09db32e703a72fd51381cd4185f" translate="yes" xml:space="preserve">
          <source>Do not prune any loose objects.</source>
          <target state="translated">不要修剪任何松散的物体。</target>
        </trans-unit>
        <trans-unit id="4ab3f3b957170dab775cfb00bbc8606872c3ea09" translate="yes" xml:space="preserve">
          <source>Do not rebase the tree against p4/master following a submit.</source>
          <target state="translated">在提交后,不要根据p4/master重新确定树的基数。</target>
        </trans-unit>
        <trans-unit id="ee64f5e74349135c206f878ac8dae99d11617c4a" translate="yes" xml:space="preserve">
          <source>Do not remove &lt;code&gt;\r&lt;/code&gt; from lines ending with &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">不要从 &lt;code&gt;\r\n&lt;/code&gt; 结尾的行中删除 &lt;code&gt;\r&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f6ac36312ee3d608ed232e28cf93ff206d0103e" translate="yes" xml:space="preserve">
          <source>Do not remove anything; just report the object names whose notes would be removed.</source>
          <target state="translated">不要删除任何东西,只需报告其注解将被删除的对象名称。</target>
        </trans-unit>
        <trans-unit id="e1b8d19002620396e3e17ca0d394f58c32270c15" translate="yes" xml:space="preserve">
          <source>Do not remove anything; just report what it would remove.</source>
          <target state="translated">不要删除任何东西,只需报告它将删除什么。</target>
        </trans-unit>
        <trans-unit id="04f9e0c42631154ae3b06c4af5993cc618a97379" translate="yes" xml:space="preserve">
          <source>Do not remove skip-worktree (AKA &quot;index-only&quot;) entries even when the &lt;code&gt;--remove&lt;/code&gt; option was specified.</source>
          <target state="translated">即使指定了 &lt;code&gt;--remove&lt;/code&gt; 选项，也不要删除skip-worktree（也称为&amp;ldquo;仅索引&amp;rdquo;）条目。</target>
        </trans-unit>
        <trans-unit id="4b9504bc1ba7b31d1b6d4966504b5b4e06f71072" translate="yes" xml:space="preserve">
          <source>Do not report commits up to (and including) limit.</source>
          <target state="translated">不报告不超过(含)限额的承诺。</target>
        </trans-unit>
        <trans-unit id="9138bfc60c9fa423aea20fccd1621b6159919774" translate="yes" xml:space="preserve">
          <source>Do not report progress or other information over &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">不要通过 &lt;code&gt;stderr&lt;/code&gt; 报告进度或其他信息。</target>
        </trans-unit>
        <trans-unit id="01c55be9743ceb727e1460223caf6f63698fc951" translate="yes" xml:space="preserve">
          <source>Do not set up &quot;upstream&quot; configuration, even if the &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; configuration variable is true.</source>
          <target state="translated">即使 &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; 配置变量为true ，也不要设置&amp;ldquo;上游&amp;rdquo;配置。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
