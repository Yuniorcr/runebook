<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="21c90195abdd4404631a1dbe99e365dc5749da75" translate="yes" xml:space="preserve">
          <source>Before any ref is updated, if $GIT_DIR/hooks/pre-receive file exists and is executable, it will be invoked once with no parameters. The standard input of the hook will be one line per ref to be updated:</source>
          <target state="translated">在更新任何 ref 之前,如果 $GIT_DIR/hooks/pre-receive 文件存在且可执行,它将被调用一次,没有参数。钩子的标准输入将是每个要更新的 ref 的一行。</target>
        </trans-unit>
        <trans-unit id="add64b4c118b3f9ba1a8f5777c12299edaee08fe" translate="yes" xml:space="preserve">
          <source>Before applying outside changes, you should get your own work in good shape and committed locally, so it will not be clobbered if there are conflicts. See also &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;. &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; will stop without doing anything when local uncommitted changes overlap with files that &lt;code&gt;git pull&lt;/code&gt;/&lt;code&gt;git merge&lt;/code&gt; may need to update.</source>
          <target state="translated">在应用外部更改之前，您应该使自己的工作保持良好状态并在本地进行工作，这样在发生冲突时就不会给工作造成麻烦。另见&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;。当本地未提交的更改与 &lt;code&gt;git pull&lt;/code&gt; / &lt;code&gt;git merge&lt;/code&gt; 可能需要更新的文件重叠时， &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git merge&lt;/code&gt; 将停止而不进行任何操作。</target>
        </trans-unit>
        <trans-unit id="5b4786a5cabe8cc8e9d6176c7a8f4c8ac1126f56" translate="yes" xml:space="preserve">
          <source>Before creating any commits, you should introduce yourself to Git. The easiest way to do so is to use &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">在创建任何提交之前，您应该向Git进行自我介绍。最简单的方法是使用&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="0407957d0e82cce71a4172b7606149052dc8e0c6" translate="yes" xml:space="preserve">
          <source>Before each ref is updated, if $GIT_DIR/hooks/update file exists and is executable, it is invoked once per ref, with three parameters:</source>
          <target state="translated">在每个ref更新之前,如果$GIT_DIR/hooks/update文件存在且可执行,则每个ref调用一次,有三个参数。</target>
        </trans-unit>
        <trans-unit id="19ac0c97c048cb907215a798a4fb3cdaff4d9a6f" translate="yes" xml:space="preserve">
          <source>Before fetching, remove any local tags that no longer exist on the remote if &lt;code&gt;--prune&lt;/code&gt; is enabled. This option should be used more carefully, unlike &lt;code&gt;--prune&lt;/code&gt; it will remove any local references (local tags) that have been created. This option is a shorthand for providing the explicit tag refspec along with &lt;code&gt;--prune&lt;/code&gt;, see the discussion about that in its documentation.</source>
          <target state="translated">提取之前，如果启用了 &lt;code&gt;--prune&lt;/code&gt; ，请删除远程服务器上不再存在的所有本地标签。与 &lt;code&gt;--prune&lt;/code&gt; 不同，应该更谨慎地使用此选项，它将删除已创建的所有本地引用（本地标签）。此选项是提供显式标签 &lt;code&gt;--prune&lt;/code&gt; 和--prune的简写，请参阅其文档中的讨论。</target>
        </trans-unit>
        <trans-unit id="8e73bf59416129baf4984229453394f0315b226d" translate="yes" xml:space="preserve">
          <source>Before fetching, remove any remote-tracking references that no longer exist on the remote. Tags are not subject to pruning if they are fetched only because of the default tag auto-following or due to a --tags option. However, if tags are fetched due to an explicit refspec (either on the command line or in the remote configuration, for example if the remote was cloned with the --mirror option), then they are also subject to pruning. Supplying &lt;code&gt;--prune-tags&lt;/code&gt; is a shorthand for providing the tag refspec.</source>
          <target state="translated">提取之前，请删除遥控器上不再存在的所有远程跟踪参考。如果仅由于默认标签自动跟随或--tags选项而获取标签，则不对它们进行修剪。但是，如果由于显式refspec（在命令行或在远程配置中，例如，如果使用--mirror选项克隆了远程服务器）而获取了标记，则也将对其进行修剪。提供 &lt;code&gt;--prune-tags&lt;/code&gt; 是提供标签refspec的简写。</target>
        </trans-unit>
        <trans-unit id="0a0fe23adf5213b01d47b6f6f762c51483096baa" translate="yes" xml:space="preserve">
          <source>Before making a commit out of staged contents so far, stage the contents of paths given on the command line as well. This is usually not what you want unless you are concluding a conflicted merge.</source>
          <target state="translated">在提交之前,先将命令行上给出的路径内容也进行缓存。这通常不是你想要的,除非你要完成一个冲突的合并。</target>
        </trans-unit>
        <trans-unit id="c77aea15ac35dd0f59cc96b6055cd1857904fd59" translate="yes" xml:space="preserve">
          <source>Before moving the index into its final destination create an empty .keep file for the associated pack file. This option is usually necessary with --stdin to prevent a simultaneous &lt;code&gt;git repack&lt;/code&gt; process from deleting the newly constructed pack and index before refs can be updated to use objects contained in the pack.</source>
          <target state="translated">在将索引移到最终目的地之前，为关联的打包文件创建一个空的.keep文件。--stdin通常需要此选项，以防止同时 &lt;code&gt;git repack&lt;/code&gt; 进程在可以将引用更新为使用包中包含的对象之前删除新建的包和索引。</target>
        </trans-unit>
        <trans-unit id="1684b3761b33822ae0ce64e85db5417e09a004a4" translate="yes" xml:space="preserve">
          <source>Before opening a compose window, use Edit&amp;rarr;Account Settings to uncheck the &quot;Compose messages in HTML format&quot; setting in the &quot;Composition &amp;amp; Addressing&quot; panel of the account to be used to send the patch.</source>
          <target state="translated">打开撰写窗口之前，请使用&amp;ldquo;编辑&amp;rdquo;&amp;rarr;&amp;ldquo;帐户设置&amp;rdquo;取消选中用于发送补丁程序的帐户的&amp;ldquo;组成和寻址&amp;rdquo;面板中的&amp;ldquo; HTML格式的撰写邮件&amp;rdquo;设置。</target>
        </trans-unit>
        <trans-unit id="4236fe92cbd33fabad183244090db7c652c48ab2" translate="yes" xml:space="preserve">
          <source>Before processing any input, load the marks specified in &amp;lt;file&amp;gt;. The input file must exist, must be readable, and must use the same format as produced by --export-marks.</source>
          <target state="translated">在处理任何输入之前，请加载&amp;lt;file&amp;gt;中指定的标记。输入文件必须存在，必须可读，并且必须使用与--export-marks产生的格式相同的格式。</target>
        </trans-unit>
        <trans-unit id="293840b5790c8dfe363015950d52920cf320165c" translate="yes" xml:space="preserve">
          <source>Before processing any input, load the marks specified in &amp;lt;file&amp;gt;. The input file must exist, must be readable, and must use the same format as produced by --export-marks. Multiple options may be supplied to import more than one set of marks. If a mark is defined to different values, the last file wins.</source>
          <target state="translated">在处理任何输入之前，请加载&amp;lt;file&amp;gt;中指定的标记。输入文件必须存在，必须可读，并且必须使用与--export-marks产生的格式相同的格式。可以提供多个选项来导入多个标记。如果将标记定义为不同的值，则最后一个文件为准。</target>
        </trans-unit>
        <trans-unit id="6ec1c5712ad3f679b2da84284672de74a981a5d9" translate="yes" xml:space="preserve">
          <source>Before sourcing it, your script should set up a few variables; &lt;code&gt;USAGE&lt;/code&gt; (and &lt;code&gt;LONG_USAGE&lt;/code&gt;, if any) is used to define message given by &lt;code&gt;usage()&lt;/code&gt; shell function. &lt;code&gt;SUBDIRECTORY_OK&lt;/code&gt; can be set if the script can run from a subdirectory of the working tree (some commands do not).</source>
          <target state="translated">在采购它之前，您的脚本应该设置一些变量。 &lt;code&gt;USAGE&lt;/code&gt; （和 &lt;code&gt;LONG_USAGE&lt;/code&gt; ，如果有的话）用于定义use &lt;code&gt;usage()&lt;/code&gt; shell函数给出的消息。如果脚本可以从工作树的子目录运行（某些命令不能），则可以设置 &lt;code&gt;SUBDIRECTORY_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c54227fb5e450fcf91fd096bb9f0a84e555b6148" translate="yes" xml:space="preserve">
          <source>Before starting rebase, stash local modifications away (see &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;) if needed, and apply the stash entry when done. &lt;code&gt;--no-autostash&lt;/code&gt; is useful to override the &lt;code&gt;rebase.autoStash&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">在开始变基之前，如有必要，将本地修改存储起来（请参阅&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;），并在完成后应用存储项。 &lt;code&gt;--no-autostash&lt;/code&gt; 有助于覆盖 &lt;code&gt;rebase.autoStash&lt;/code&gt; 配置变量（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="20a98eb8f5ae5eb6921d2e55163fa9540eded227" translate="yes" xml:space="preserve">
          <source>Before starting, verify that there is corruption, and figure out where it is with &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;; this may be time-consuming.</source>
          <target state="translated">开始之前，请验证是否存在损坏，并使用&lt;a href=&quot;git-fsck&quot;&gt;git-fsck [1]&lt;/a&gt;找出损坏的位置。这可能很耗时。</target>
        </trans-unit>
        <trans-unit id="197ebbc21bdf962ed1c382324d4f3dcec04005ba" translate="yes" xml:space="preserve">
          <source>Before the colon may be anything that names a commit, and after it may be any path to a file tracked by Git.</source>
          <target state="translated">冒号前可以是任何提交的名称,冒号后可以是 Git 跟踪的任何文件的路径。</target>
        </trans-unit>
        <trans-unit id="0b4c2c97b5d492d26987ff45d09af0bb0c545781" translate="yes" xml:space="preserve">
          <source>Behave as if &lt;code&gt;git rev-parse&lt;/code&gt; was invoked from the &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; subdirectory of the working tree. Any relative filenames are resolved as if they are prefixed by &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; and will be printed in that form.</source>
          <target state="translated">行为就像从工作树的 &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; 子目录中调用了 &lt;code&gt;git rev-parse&lt;/code&gt; 一样。所有相对文件名都将以 &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; 为前缀进行解析，并以该格式打印。</target>
        </trans-unit>
        <trans-unit id="d02e70ae5f9ffc8904b317a23e079b2151794572" translate="yes" xml:space="preserve">
          <source>Behave as normal citool, but instead of making a commit simply terminate with a zero exit code. It still checks that the index does not contain any unmerged entries, so you can use it as a GUI version of &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt;</source>
          <target state="translated">行为与普通citool相同，但是除了进行提交外，只需以零退出代码终止即可。它仍然检查索引是否不包含任何未合并的条目，因此您可以将其用作&lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool [1]&lt;/a&gt;的GUI版本。</target>
        </trans-unit>
        <trans-unit id="1e338425ed36637ba6fc8582364ec79dbafaa8d3" translate="yes" xml:space="preserve">
          <source>Behavioral differences</source>
          <target state="translated">行为上的差异</target>
        </trans-unit>
        <trans-unit id="f0f0d8dfa2a076d1fea883054912f530ebc927c2" translate="yes" xml:space="preserve">
          <source>Besides blobs, trees, and commits, the only remaining type of object is a &quot;tag&quot;, which we won&amp;rsquo;t discuss here; refer to &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; for details.</source>
          <target state="translated">除了Blob，树和提交之外，唯一剩余的对象类型是&amp;ldquo;标记&amp;rdquo;，在此不再赘述。有关详细信息，请参考&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6077f120aaceb5046721fb58c100f8432db9b449" translate="yes" xml:space="preserve">
          <source>Besides specifying a range of commits that should be listed using the special notations explained in the description, additional commit limiting may be applied.</source>
          <target state="translated">除了使用描述中解释的特殊符号指定应该列出的提交范围外,还可以应用额外的提交限制。</target>
        </trans-unit>
        <trans-unit id="5d284c47fc77be8e46a6b104d3f25aff12fd50b7" translate="yes" xml:space="preserve">
          <source>Best bisecting practices</source>
          <target state="translated">最佳二分法</target>
        </trans-unit>
        <trans-unit id="6bc3ae89d4cbb3ba42878fb25652862ae42aa5fe" translate="yes" xml:space="preserve">
          <source>Beware that the default for &lt;code&gt;git send-email&lt;/code&gt; is to thread emails itself. If you want &lt;code&gt;git format-patch&lt;/code&gt; to take care of threading, you will want to ensure that threading is disabled for &lt;code&gt;git send-email&lt;/code&gt;.</source>
          <target state="translated">注意， &lt;code&gt;git send-email&lt;/code&gt; 的默认设置是使电子邮件本身成为线程。如果您希望 &lt;code&gt;git format-patch&lt;/code&gt; 负责线程处理，则需要确保 &lt;code&gt;git send-email&lt;/code&gt; 禁用了线程处理。</target>
        </trans-unit>
        <trans-unit id="945fefcb0d1953c9bddf033fe3e99288cf86cd4d" translate="yes" xml:space="preserve">
          <source>Bidirectional operation between a Subversion repository and Git</source>
          <target state="translated">Subversion仓库和Git之间的双向操作。</target>
        </trans-unit>
        <trans-unit id="6f22ed9717123d2ce9d3d667f975fb97ec48ef54" translate="yes" xml:space="preserve">
          <source>Binary files are searched as well.</source>
          <target state="translated">二进制文件也会被搜索到。</target>
        </trans-unit>
        <trans-unit id="8e08702a04bb0e3631c0db1c03ac41d9b78e02c9" translate="yes" xml:space="preserve">
          <source>Bisect log and bisect replay</source>
          <target state="translated">两段式日志和两段式回放</target>
        </trans-unit>
        <trans-unit id="caafd94a0cc48f8af98290661863ae3463dcd188" translate="yes" xml:space="preserve">
          <source>Bisect reset</source>
          <target state="translated">分割复位</target>
        </trans-unit>
        <trans-unit id="cfe9732e61ea56b98e10d88f828ff42f6e52d08e" translate="yes" xml:space="preserve">
          <source>Bisect run</source>
          <target state="translated">两段式运行</target>
        </trans-unit>
        <trans-unit id="e7eb00dc48d63079c3871fc0a679fc1160511d2f" translate="yes" xml:space="preserve">
          <source>Bisect skip</source>
          <target state="translated">二段跳</target>
        </trans-unit>
        <trans-unit id="5887bb0558b5608c8166ca0492b459bf81b4ac9e" translate="yes" xml:space="preserve">
          <source>Bisect visualize/view</source>
          <target state="translated">二分法可视化/查看</target>
        </trans-unit>
        <trans-unit id="5adebf631a26d512accb5dd4088829dcb8650be4" translate="yes" xml:space="preserve">
          <source>Bisecting between Z and D* would hit a single culprit commit Y*, and understanding why Y* was broken would probably be easier.</source>
          <target state="translated">在Z和D*之间进行Bisecting,会打出一个单一的罪魁祸首犯Y*,了解Y*为什么会被打破,可能会更容易。</target>
        </trans-unit>
        <trans-unit id="e52337c43cc4b33ac0d524be43e0ee7aabfe896f" translate="yes" xml:space="preserve">
          <source>Bisecting build failures</source>
          <target state="translated">分割构建失败</target>
        </trans-unit>
        <trans-unit id="247595ab20eacd2b287d2671e0cd44ffe5d63f96" translate="yes" xml:space="preserve">
          <source>Bisecting sporadic bugs</source>
          <target state="translated">分割零星虫子</target>
        </trans-unit>
        <trans-unit id="c849a8d6d5f17f13126d2a3ffa47e78949cbd571" translate="yes" xml:space="preserve">
          <source>Bisection Helpers</source>
          <target state="translated">双节帮助者</target>
        </trans-unit>
        <trans-unit id="81ab75db6833dc6c35d461635f7c0fa8e4339b5c" translate="yes" xml:space="preserve">
          <source>Bisection algorithm</source>
          <target state="translated">分割算法</target>
        </trans-unit>
        <trans-unit id="1073b9bc85c670179e7dcf4cfd5cd0b022c46d78" translate="yes" xml:space="preserve">
          <source>Bisection algorithm debugging</source>
          <target state="translated">分割算法调试</target>
        </trans-unit>
        <trans-unit id="2146a76855ff13537405bb4dc1d3e621b6d2530e" translate="yes" xml:space="preserve">
          <source>Bisection algorithm discussed</source>
          <target state="translated">讨论的二段式算法</target>
        </trans-unit>
        <trans-unit id="3e65a55a7b3fcaab5f39381d806f63fcab2ecabb" translate="yes" xml:space="preserve">
          <source>BitKeeper/cvsps speak for &quot;&lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt;&quot;. Since Git does not store changes, but states, it really does not make sense to use the term &quot;changesets&quot; with Git.</source>
          <target state="translated">BitKeeper / cvsps表示&amp;ldquo; &lt;a href=&quot;#def_commit&quot;&gt;提交&lt;/a&gt; &amp;rdquo;。由于Git不存储更改，而是声明，因此在Git中使用术语&amp;ldquo;更改集&amp;rdquo;确实没有任何意义。</target>
        </trans-unit>
        <trans-unit id="57bd2a9f31bd11a6f563b358aadd2a286592b86a" translate="yes" xml:space="preserve">
          <source>Blank lines are ignored, and lines that don&amp;rsquo;t match this specification are used as option group headers (start the line with a space to create such lines on purpose).</source>
          <target state="translated">空行将被忽略，与该规范不匹配的行将用作选项组标题（以空格开头的行有意创建此类行）。</target>
        </trans-unit>
        <trans-unit id="5327cbfdb1bf8f5a47bca233a1bde391d44b215a" translate="yes" xml:space="preserve">
          <source>Blank lines are ignored, so they can be used as separators for readability.</source>
          <target state="translated">空白线会被忽略,因此它们可以被用作分隔符,以便于阅读。</target>
        </trans-unit>
        <trans-unit id="d7077b7354ef7afaa6b1de41b77813742be4c707" translate="yes" xml:space="preserve">
          <source>Blob Object</source>
          <target state="translated">Blob对象</target>
        </trans-unit>
        <trans-unit id="f04feb5337017d625e39e5a69c692bf6273fb704" translate="yes" xml:space="preserve">
          <source>Blocks of moved text are detected as in &lt;code&gt;blocks&lt;/code&gt; mode. The blocks are painted using either the &lt;code&gt;color.diff.{old,new}Moved&lt;/code&gt; color or &lt;code&gt;color.diff.{old,new}MovedAlternative&lt;/code&gt;. The change between the two colors indicates that a new block was detected.</source>
          <target state="translated">与在 &lt;code&gt;blocks&lt;/code&gt; 模式下一样，检测到已移动文本的块。使用 &lt;code&gt;color.diff.{old,new}Moved&lt;/code&gt; color或 &lt;code&gt;color.diff.{old,new}MovedAlternative&lt;/code&gt; 。两种颜色之间的变化表示检测到新的块。</target>
        </trans-unit>
        <trans-unit id="f42755e1f80735be0fde7ac7e2cbeb956df2c96e" translate="yes" xml:space="preserve">
          <source>Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the &lt;code&gt;color.diff.{old,new}Moved&lt;/code&gt; color. Adjacent blocks cannot be told apart.</source>
          <target state="translated">贪婪地检测到至少包含20个字母数字字符的移动文本块。使用 &lt;code&gt;color.diff.{old,new}Moved&lt;/code&gt; 颜色绘制检测到的块。不能将相邻的块区分开。</target>
        </trans-unit>
        <trans-unit id="66547f4a0e63cd4ad00756855db6ddba1142e4d3" translate="yes" xml:space="preserve">
          <source>Bob begins with:</source>
          <target state="translated">鲍勃以。</target>
        </trans-unit>
        <trans-unit id="bcf42567e6f70a4579bf8687eb5f4e62c5870c89" translate="yes" xml:space="preserve">
          <source>Bob then makes some changes and commits them:</source>
          <target state="translated">然后,鲍勃做了一些修改并提交。</target>
        </trans-unit>
        <trans-unit id="d0685c88b15694d30796d8493ed6c8ce3e6b4b74" translate="yes" xml:space="preserve">
          <source>Boolean false literals are &lt;code&gt;no&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; and the empty string.</source>
          <target state="translated">布尔型false文字是 &lt;code&gt;no&lt;/code&gt; ， &lt;code&gt;off&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;0&lt;/code&gt; 和空字符串。</target>
        </trans-unit>
        <trans-unit id="c8e93181a2c2334cd611c796a9d2346e913aadda" translate="yes" xml:space="preserve">
          <source>Boolean true literals are &lt;code&gt;yes&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;1&lt;/code&gt;. Also, a variable defined without &lt;code&gt;= &amp;lt;value&amp;gt;&lt;/code&gt; is taken as true.</source>
          <target state="translated">布尔值真实文字为 &lt;code&gt;yes&lt;/code&gt; ， &lt;code&gt;on&lt;/code&gt; ， &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 。同样，将不带 &lt;code&gt;= &amp;lt;value&amp;gt;&lt;/code&gt; 定义的变量视为true。</target>
        </trans-unit>
        <trans-unit id="f03ce708ae8563bbe292f147105bcbebd35fdd1f" translate="yes" xml:space="preserve">
          <source>Boolean value indicating if the submodule is of interest to git commands. This config option takes precedence over the submodule.active config option. See &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for details.</source>
          <target state="translated">布尔值，指示子模块是否对git命令感兴趣。此配置选项优先于submodule.active配置选项。有关详细信息，请参见&lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40de397dbe4a181644b13a510b500ba0dfa90dc8" translate="yes" xml:space="preserve">
          <source>Boolean variable which defines if large files are automatically pushed to a server.</source>
          <target state="translated">布尔变量,用于定义是否将大文件自动推送到服务器。</target>
        </trans-unit>
        <trans-unit id="edb8137a3de82e7f1ab7c05bad252ac0da09a46a" translate="yes" xml:space="preserve">
          <source>Boolean. When true &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted from PERF output. May be overridden by the &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; environment variable. Defaults to false.</source>
          <target state="translated">布尔值。当为true &lt;code&gt;time&lt;/code&gt; ， &lt;code&gt;filename&lt;/code&gt; 和 &lt;code&gt;line&lt;/code&gt; 字段时，将从PERF输出中省略。可以被 &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; 环境变量覆盖。默认为false。</target>
        </trans-unit>
        <trans-unit id="e7da8527471f3ea2c3faf910dfb4b6accdd8c262" translate="yes" xml:space="preserve">
          <source>Boolean. When true &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted from event output. May be overridden by the &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; environment variable. Defaults to false.</source>
          <target state="translated">布尔值。如果为true &lt;code&gt;time&lt;/code&gt; ， &lt;code&gt;filename&lt;/code&gt; 和 &lt;code&gt;line&lt;/code&gt; 字段，则从事件输出中省略。可以被 &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; 环境变量覆盖。默认为false。</target>
        </trans-unit>
        <trans-unit id="d6cb13ebbd3c085c01cd755d0c697831e337b51f" translate="yes" xml:space="preserve">
          <source>Boolean. When true &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted from normal output. May be overridden by the &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; environment variable. Defaults to false.</source>
          <target state="translated">布尔值。如果为true &lt;code&gt;time&lt;/code&gt; ， &lt;code&gt;filename&lt;/code&gt; 和 &lt;code&gt;line&lt;/code&gt; 字段，则从常规输出中省略。可以被 &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; 环境变量覆盖。默认为false。</target>
        </trans-unit>
        <trans-unit id="2c3dcfd71724f2fb257997b8beb70ed9ac8363b1" translate="yes" xml:space="preserve">
          <source>Boolean. When true Git will print error messages when a trace target destination cannot be opened for writing. By default, these errors are suppressed and tracing is silently disabled. May be overridden by the &lt;code&gt;GIT_TRACE2_DST_DEBUG&lt;/code&gt; environment variable.</source>
          <target state="translated">布尔值。如果为true，当无法打开跟踪目标位置进行写入时，Git将打印错误消息。默认情况下，将抑制这些错误，并且将静默禁用跟踪。可以被 &lt;code&gt;GIT_TRACE2_DST_DEBUG&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="e5522e55cd06bc09c2f312c8e91e3e9369d6fed7" translate="yes" xml:space="preserve">
          <source>Borrow the objects from reference repositories specified with the &lt;code&gt;--reference&lt;/code&gt; options only to reduce network transfer, and stop borrowing from them after a clone is made by making necessary local copies of borrowed objects. This option can also be used when cloning locally from a repository that already borrows objects from another repository&amp;mdash;​the new repository will borrow objects from the same repository, and this option can be used to stop the borrowing.</source>
          <target state="translated">从使用 &lt;code&gt;--reference&lt;/code&gt; 选项指定的参考存储库中借用对象仅是为了减少网络传输，并在复制后通过制作借用对象的必要本地副本来停止从对象借用。从已经从另一个存储库借用对象的存储库本地克隆时，也可以使用此选项-新存储库将从同一个存储库借用对象，并且该选项可用于停止借用。</target>
        </trans-unit>
        <trans-unit id="5694355a4e9f21af75bfd457be1c695646467936" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;--cacheinfo&lt;/code&gt; and &lt;code&gt;--info-only&lt;/code&gt; behave similarly: the index is updated but the object database isn&amp;rsquo;t. &lt;code&gt;--cacheinfo&lt;/code&gt; is useful when the object is in the database but the file isn&amp;rsquo;t available locally. &lt;code&gt;--info-only&lt;/code&gt; is useful when the file is available, but you do not wish to update the object database.</source>
          <target state="translated">无论 &lt;code&gt;--cacheinfo&lt;/code&gt; 和 &lt;code&gt;--info-only&lt;/code&gt; 的行为类似：索引更新，但是对象数据库是没有的。当对象位于数据库中但文件在本地不可用时， &lt;code&gt;--cacheinfo&lt;/code&gt; 很有用。当文件可用时， &lt;code&gt;--info-only&lt;/code&gt; 很有用，但是您不希望更新对象数据库。</target>
        </trans-unit>
        <trans-unit id="210e82ac599d9d8944e3c5eb9d03d4a4abcf7207" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;plink&lt;/code&gt; and &lt;code&gt;alink&lt;/code&gt; point outside the tree, so they would respectively print:</source>
          <target state="translated">无论 &lt;code&gt;plink&lt;/code&gt; 和 &lt;code&gt;alink&lt;/code&gt; 外树点，因此他们将分别打印：</target>
        </trans-unit>
        <trans-unit id="9a953a9b4782d5c56832edbe239c8ec4aaa470f8" translate="yes" xml:space="preserve">
          <source>Both fixes are tested well, and at this point, you want to merge in both of them. You could merge in &lt;code&gt;diff-fix&lt;/code&gt; first and then &lt;code&gt;commit-fix&lt;/code&gt; next, like this:</source>
          <target state="translated">这两个修复程序都经过了良好的测试，此时，您希望将它们合并。您可以先在 &lt;code&gt;diff-fix&lt;/code&gt; 中合并，然后再在 &lt;code&gt;commit-fix&lt;/code&gt; 中合并，如下所示：</target>
        </trans-unit>
        <trans-unit id="9af6db9f29dd4e151f33497260a5a0b8ba4e0513" translate="yes" xml:space="preserve">
          <source>Both ofs-delta and ref-delta store the &quot;delta&quot; to be applied to another object (called &lt;code&gt;base object&lt;/code&gt;) to reconstruct the object. The difference between them is, ref-delta directly encodes 20-byte base object name. If the base object is in the same pack, ofs-delta encodes the offset of the base object in the pack instead.</source>
          <target state="translated">ofs-delta和ref-delta都存储要应用到另一个对象（称为 &lt;code&gt;base object&lt;/code&gt; ）以重构对象的&amp;ldquo; delta&amp;rdquo; 。它们之间的区别是，ref-delta直接编码20字节的基础对象名称。如果基础对象在同一包中，则ofs-delta会代替编码该基础对象在包中的偏移量。</target>
        </trans-unit>
        <trans-unit id="b68fc1d55d49e0827f78d9949a9c5a2eecaf05eb" translate="yes" xml:space="preserve">
          <source>Both settings can be overridden on the command line by using the &quot;--ignore-submodules&quot; option. The &lt;code&gt;git submodule&lt;/code&gt; commands are not affected by this setting.</source>
          <target state="translated">可以使用&amp;ldquo; --ignore-submodules&amp;rdquo;选项在命令行上覆盖这两种设置。在 &lt;code&gt;git submodule&lt;/code&gt; 的命令不受此设置。</target>
        </trans-unit>
        <trans-unit id="2bb1e035fa86f5b4222d3ab1eb33c1658eed9a23" translate="yes" xml:space="preserve">
          <source>Both standard output and standard error output are forwarded to &lt;code&gt;git send-pack&lt;/code&gt; on the other end, so you can simply &lt;code&gt;echo&lt;/code&gt; messages for the user.</source>
          <target state="translated">标准输出和标准错误输出都转发到另一端的 &lt;code&gt;git send-pack&lt;/code&gt; ，因此您可以简单地为用户 &lt;code&gt;echo&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="7c76084a5f517b3242aa149971fbcce3ceb62c61" translate="yes" xml:space="preserve">
          <source>Both the &amp;lt;eolinfo&amp;gt; in the index (&quot;i/&amp;lt;eolinfo&amp;gt;&quot;) and in the working tree (&quot;w/&amp;lt;eolinfo&amp;gt;&quot;) are shown for regular files, followed by the (&quot;attr/&amp;lt;eolattr&amp;gt;&quot;).</source>
          <target state="translated">在常规文件中显示索引（&amp;ldquo; i / &amp;lt;eolinfo&amp;gt;&amp;rdquo;）和工作树（&amp;ldquo; w / &amp;lt;eolinfo&amp;gt;&amp;rdquo;）中的&amp;lt;eolinfo&amp;gt;，后跟（&amp;ldquo; attr / &amp;lt;eolattr&amp;gt;&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="c634179a023801afb75e60cfb7d88f35c1e83a21" translate="yes" xml:space="preserve">
          <source>Both the symlink &amp;amp; realpath versions of paths will be matched outside of &lt;code&gt;$GIT_DIR&lt;/code&gt;. E.g. if ~/git is a symlink to /mnt/storage/git, both &lt;code&gt;gitdir:~/git&lt;/code&gt; and &lt;code&gt;gitdir:/mnt/storage/git&lt;/code&gt; will match.</source>
          <target state="translated">路径的symlink和realpath版本都将在 &lt;code&gt;$GIT_DIR&lt;/code&gt; 之外进行匹配。例如，如果〜/ git是/ mnt / storage / git的符号链接，则 &lt;code&gt;gitdir:~/git&lt;/code&gt; 和 &lt;code&gt;gitdir:/mnt/storage/git&lt;/code&gt; 都将匹配。</target>
        </trans-unit>
        <trans-unit id="fb26b800dd56fd61a55a4281547b9e60ac65a113" translate="yes" xml:space="preserve">
          <source>Branch Headers</source>
          <target state="translated">分部标题</target>
        </trans-unit>
        <trans-unit id="6e15a503d2a4c17b67a8c3c7f34c58a07a49a276" translate="yes" xml:space="preserve">
          <source>Branch description, can be edited with &lt;code&gt;git branch --edit-description&lt;/code&gt;. Branch description is automatically added in the format-patch cover letter or request-pull summary.</source>
          <target state="translated">分支描述，可以使用 &lt;code&gt;git branch --edit-description&lt;/code&gt; 进行编辑。分支描述会自动添加到格式补丁的求职信或请求摘要中。</target>
        </trans-unit>
        <trans-unit id="5bec4527e15afa13a84c736e3c723988984e6324" translate="yes" xml:space="preserve">
          <source>Branch detection</source>
          <target state="translated">分支检测</target>
        </trans-unit>
        <trans-unit id="f63ceca75fd06c6b871dea1a79cac70839c63882" translate="yes" xml:space="preserve">
          <source>Branch management for a release</source>
          <target state="translated">发布的分支机构管理</target>
        </trans-unit>
        <trans-unit id="50637014a89740451f5074b5c0e9645bb5f5e1e3" translate="yes" xml:space="preserve">
          <source>Branch management for next and pu after a feature release</source>
          <target state="translated">在功能发布后对next和pu进行分支管理。</target>
        </trans-unit>
        <trans-unit id="cbca9c5458a752e67c3b22c7754c8dd03612ff9c" translate="yes" xml:space="preserve">
          <source>Branch of repository to add as submodule. The name of the branch is recorded as &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; in &lt;code&gt;.gitmodules&lt;/code&gt; for &lt;code&gt;update --remote&lt;/code&gt;. A special value of &lt;code&gt;.&lt;/code&gt; is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository. If the option is not specified, it defaults to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">要添加为子模块的存储库分支。该分支的名称被记录为 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 在 &lt;code&gt;.gitmodules&lt;/code&gt; 用于 &lt;code&gt;update --remote&lt;/code&gt; 。的特殊值 &lt;code&gt;.&lt;/code&gt; 用于表示子模块中的分支名称应与当前存储库中的当前分支相同。如果未指定该选项，则默认为 &lt;code&gt;master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3db6088987588160d14194fc92edec728f16ab3" translate="yes" xml:space="preserve">
          <source>Branch off of a specific tag.</source>
          <target state="translated">特定标签的分支。</target>
        </trans-unit>
        <trans-unit id="a41d6fc58b77cd15fdc95f9b8068f3bedb454bc6" translate="yes" xml:space="preserve">
          <source>Branch to checkout; if it refers to a branch (i.e., a name that, when prepended with &quot;refs/heads/&quot;, is a valid ref), then that branch is checked out. Otherwise, if it refers to a valid commit, your &lt;code&gt;HEAD&lt;/code&gt; becomes &quot;detached&quot; and you are no longer on any branch (see below for details).</source>
          <target state="translated">结帐至结帐；如果它引用一个分支（即名称，当以&amp;ldquo; refs / heads /&amp;rdquo;开头时是有效的引用），则将该分支检出。否则，如果它引用有效的提交，则 &lt;code&gt;HEAD&lt;/code&gt; 将变为&amp;ldquo;分离&amp;rdquo;，并且您将不再位于任何分支上（有关详细信息，请参见下文）。</target>
        </trans-unit>
        <trans-unit id="8b21526e9a7ba9f6110db09d1bb17e93bbda77fa" translate="yes" xml:space="preserve">
          <source>Branch to switch to.</source>
          <target state="translated">支部切换到。</target>
        </trans-unit>
        <trans-unit id="79cd2f09f7574ee3c255526cc9dfc53740a35d6b" translate="yes" xml:space="preserve">
          <source>Branch updates can be forced with --force, but it&amp;rsquo;s recommended that this only be used on an otherwise quiet repository. Using --force is not necessary for an initial import into an empty repository.</source>
          <target state="translated">可以使用--force强制执行分支更新，但建议仅在其他安静的存储库上使用。初始导入到空存储库中不需要使用--force。</target>
        </trans-unit>
        <trans-unit id="e985dfb396afc27ce07bbb1b298aa21e35e0ea0d" translate="yes" xml:space="preserve">
          <source>Branches are cheap and easy, so this is a good way to try something out.</source>
          <target state="translated">枝条便宜又简单,所以这是个不错的尝试方式。</target>
        </trans-unit>
        <trans-unit id="879b754d99bf64defbd79d89d51b97c6e52dfbf4" translate="yes" xml:space="preserve">
          <source>Branches are classified as active and inactive. The memory usage of the two classes is significantly different.</source>
          <target state="translated">分支机构分为活跃和非活跃两类。两类分支的内存使用量有很大不同。</target>
        </trans-unit>
        <trans-unit id="19038dfa38a59c4f1be05e3d92e0f1bca8b5557f" translate="yes" xml:space="preserve">
          <source>Branches in Git are really nothing more than pointers into the Git object database from within the &lt;code&gt;.git/refs/&lt;/code&gt; subdirectory, and as we already discussed, the &lt;code&gt;HEAD&lt;/code&gt; branch is nothing but a symlink to one of these object pointers.</source>
          <target state="translated">Git中的分支实际上只不过是从 &lt;code&gt;.git/refs/&lt;/code&gt; 子目录中进入Git对象数据库的指针，正如我们已经讨论的， &lt;code&gt;HEAD&lt;/code&gt; 分支不过是指向这些对象指针之一的符号链接。</target>
        </trans-unit>
        <trans-unit id="125404877d39f029f0e27e0fb84f104c52bd667b" translate="yes" xml:space="preserve">
          <source>Branches on which no commits have been made are not imported.</source>
          <target state="translated">没有提交的分支不被导入。</target>
        </trans-unit>
        <trans-unit id="415a16be057cec5701bb9e0fd3bff5400f270979" translate="yes" xml:space="preserve">
          <source>Branches, remote-tracking branches, and tags are all references to commits. All references are named with a slash-separated path name starting with &lt;code&gt;refs&lt;/code&gt;; the names we&amp;rsquo;ve been using so far are actually shorthand:</source>
          <target state="translated">分支，远程跟踪分支和标记都是对提交的引用。所有引用均以以斜杠分隔的路径名命名，以 &lt;code&gt;refs&lt;/code&gt; 开头；到目前为止，我们一直使用的名称实际上是速记：</target>
        </trans-unit>
        <trans-unit id="b3d9b26ec0345692adbda512336186fddd0ce297" translate="yes" xml:space="preserve">
          <source>Branching and Merging</source>
          <target state="translated">分支和合并</target>
        </trans-unit>
        <trans-unit id="15e01902c81d07c3b90042ff2531422b8b3d1b86" translate="yes" xml:space="preserve">
          <source>Break complete rewrite changes into pairs of delete and create. This serves two purposes:</source>
          <target state="translated">将完整的重写更改分成删除和创建两对。这有两个目的。</target>
        </trans-unit>
        <trans-unit id="672fc0738ea8c1007bcaceee5284378a52766797" translate="yes" xml:space="preserve">
          <source>Browse the &lt;code&gt;modules&lt;/code&gt; available. It will give you a list of the heads in the repository. You will not be able to browse the tree from there. Only the heads.</source>
          <target state="translated">浏览可用的 &lt;code&gt;modules&lt;/code&gt; 。它将为您提供存储库中负责人的列表。您将无法从那里浏览树。只有元首。</target>
        </trans-unit>
        <trans-unit id="abb2e552cc2091e364809101c300cc4143caaa39" translate="yes" xml:space="preserve">
          <source>Browsing every revision of the repository.</source>
          <target state="translated">浏览版本库的每个版本。</target>
        </trans-unit>
        <trans-unit id="f92f422e95f0fd94e3584d36660177eaf6c3a90d" translate="yes" xml:space="preserve">
          <source>Browsing revisions</source>
          <target state="translated">浏览修订版</target>
        </trans-unit>
        <trans-unit id="6d55509876929eae63b680c2015c0e8dcd714d8d" translate="yes" xml:space="preserve">
          <source>Buffering happens as documented under the &lt;code&gt;GIT_FLUSH&lt;/code&gt; option in &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;. The caller is responsible for avoiding deadlocks caused by overfilling an input buffer or reading from an empty output buffer.</source>
          <target state="translated">缓冲发生在&lt;a href=&quot;git&quot;&gt;git [1]中&lt;/a&gt;的 &lt;code&gt;GIT_FLUSH&lt;/code&gt; 选项下。调用程序负责避免由于输入缓冲区溢出或从空的输出缓冲区读取而导致的死锁。</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="30410812dc9752c13886986132ffab9500651b55" translate="yes" xml:space="preserve">
          <source>Bugs in the implementation of overlap mappings exist. If multiple depot paths map through overlays to the same location in the repository, &lt;code&gt;git p4&lt;/code&gt; can choose the wrong one. This is hard to solve without dedicating a client spec just for &lt;code&gt;git p4&lt;/code&gt;.</source>
          <target state="translated">存在重叠映射实现中的错误。如果多个仓库路径通过覆盖图映射到存储库中的同一位置，则 &lt;code&gt;git p4&lt;/code&gt; 可能选择错误的路径。如果不为 &lt;code&gt;git p4&lt;/code&gt; 专门指定客户规范，这很难解决。</target>
        </trans-unit>
        <trans-unit id="8c875875a4eba5d2b4104ba5b53fe3484e74b27e" translate="yes" xml:space="preserve">
          <source>Build a tree-object from ls-tree formatted text</source>
          <target state="translated">从ls-tree格式化的文本建立一个树形对象。</target>
        </trans-unit>
        <trans-unit id="043dc36933914b47740e7f5065ce440656dbe0ca" translate="yes" xml:space="preserve">
          <source>Build pack index file for an existing packed archive</source>
          <target state="translated">为现有的打包存档建立打包索引文件</target>
        </trans-unit>
        <trans-unit id="8dd0ad60c49a72540d98588b5b0558fd314e85ee" translate="yes" xml:space="preserve">
          <source>Built-in 3-way merge driver is used to merge the contents in a way similar to &lt;code&gt;merge&lt;/code&gt; command of &lt;code&gt;RCS&lt;/code&gt; suite. This is suitable for ordinary text files.</source>
          <target state="translated">内置的三向合并驱动程序用于以类似于 &lt;code&gt;RCS&lt;/code&gt; 套件的 &lt;code&gt;merge&lt;/code&gt; 命令的方式合并内容。这适用于普通文本文件。</target>
        </trans-unit>
        <trans-unit id="0829c07e98ca5098038c31cb2a5b51c3902a8814" translate="yes" xml:space="preserve">
          <source>Built-in merge drivers</source>
          <target state="translated">内置合并驱动程序</target>
        </trans-unit>
        <trans-unit id="fe507ac4ab5d31826c1b03d804bf3ff265bad65b" translate="yes" xml:space="preserve">
          <source>Bundling your work together</source>
          <target state="translated">将您的工作捆绑在一起</target>
        </trans-unit>
        <trans-unit id="25fde7a2ceaafceba047201a41d303d6c07bd23d" translate="yes" xml:space="preserve">
          <source>But BBChop is independent of any VCS and it would be easier for Git users to have something integrated in Git.</source>
          <target state="translated">但BBChop是独立于任何VCS的,如果能在Git中集成一些东西,对Git用户来说会更方便。</target>
        </trans-unit>
        <trans-unit id="f7eefc5fb4183d567fceb246626226ef9afb8bf2" translate="yes" xml:space="preserve">
          <source>But Ingo Molnar and H. Peter Anvin (another well known linux kernel developer) both complained that sometimes the best bisection points all happened to be in an area where all the commits are untestable. And in this case the user was asked to test many untestable commits, which could be very inefficient.</source>
          <target state="translated">但Ingo Molnar和H.Peter Anvin(另一位著名的linux内核开发者)都抱怨说,有时最好的二分法点恰好都在一个所有提交都不可测试的区域。而在这种情况下,用户被要求测试许多不可测试的提交,这可能是非常低效的。</target>
        </trans-unit>
        <trans-unit id="74140d3773084e209fc43c63f870a2ce5abd4ea1" translate="yes" xml:space="preserve">
          <source>But if you have pushed things out (or others could just read your repository directly), then others will have already seen the old tag. In that case you can do one of two things:</source>
          <target state="translated">但是如果你已经把东西推送出去了(或者其他人可以直接读取你的版本库),那么其他人就已经看到了旧的标签。在这种情况下,你可以做两件事中的一件。</target>
        </trans-unit>
        <trans-unit id="66013f3cefed95fb73f834fded3820e6a1071c28" translate="yes" xml:space="preserve">
          <source>But if you try to push, you will attempt to update the branch (that now points at A) with commit B. This does &lt;code&gt;not&lt;/code&gt; fast-forward. If you did so, the changes introduced by commit A will be lost, because everybody will now start building on top of B.</source>
          <target state="translated">但是，如果您尝试推送，则将尝试使用提交B更新分支（现在指向A）。这 &lt;code&gt;not&lt;/code&gt; 快进。如果这样做，则提交A引入的更改将丢失，因为现在每个人都将开始在B的基础上进行构建。</target>
        </trans-unit>
        <trans-unit id="fd8e45cbd58877735e25105978c0aca9791da6ee" translate="yes" xml:space="preserve">
          <source>But in some repository setups, you may have several related but separate groups of ref tips, with clients tending to fetch those groups independently. For example, imagine that you are hosting several &quot;forks&quot; of a repository in a single shared object store, and letting clients view them as separate repositories through &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; or separate repos using the alternates mechanism. A naive repack may find that the optimal delta for an object is against a base that is only found in another fork. But when a client fetches, they will not have the base object, and we&amp;rsquo;ll have to find a new delta on the fly.</source>
          <target state="translated">但是在某些存储库设置中，您可能有几个相关但独立的参考提示组，客户端倾向于独立获取这些组。例如，假设您在单个共享库中托管一个存储库的多个&amp;ldquo;分支&amp;rdquo;，然后让客户端通过 &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; 将它们视为独立的存储库，或者使用替代机制将其视为独立的存储库。幼稚的重新打包可能会发现对象的最佳增量与仅在另一个fork中找到的基准相对。但是，当客户端获取数据时，它们将没有基础对象，我们将不得不动态查找新的增量。</target>
        </trans-unit>
        <trans-unit id="a02a23b585c823168e0aade261aba54b02ee9df4" translate="yes" xml:space="preserve">
          <source>But now we can do</source>
          <target state="translated">但现在我们可以做</target>
        </trans-unit>
        <trans-unit id="d83b34d996269d86f487bc1b1bf210759565be26" translate="yes" xml:space="preserve">
          <source>But the above ways to work around untestable areas are a little bit clunky. Using special branches is nice because these branches can be shared by developers like usual branches, but the risk is that people will get many such branches. And it disrupts the normal &quot;git bisect&quot; work-flow. So, if you want to use &quot;git bisect run&quot; completely automatically, you have to add special code in your script to restart bisection in the special branches.</source>
          <target state="translated">但以上绕过不可测试区域的方法有点笨拙。使用特殊的分支是不错的,因为这些分支可以像平常的分支一样被开发者共享,但风险是人们会得到很多这样的分支。而且会破坏正常的 &quot;git一分为二 &quot;的工作流程。所以,如果你想完全自动地使用 &quot;git bisect run&quot;,你必须在你的脚本中添加特殊的代码来重启特殊分支中的bisection。</target>
        </trans-unit>
        <trans-unit id="d51bf10c62a548cc7f488f7d7c601612ef19bfbf" translate="yes" xml:space="preserve">
          <source>But there are other ways to refer to commits. You can use any initial part of the name that is long enough to uniquely identify the commit:</source>
          <target state="translated">但是还有其他的方式来引用提交。您可以使用名称的任何首字母部分,只要足够长,就可以唯一地识别提交。</target>
        </trans-unit>
        <trans-unit id="7cbb3ccd9eb2da169028fcad03ea4127b40731fc" translate="yes" xml:space="preserve">
          <source>But this is wrong because at step 1) a) we keep only the ancestors of the bad commit. So we get more information when a commit is marked as &quot;bad&quot;, because we also know that the ancestors of the previous &quot;bad&quot; commit that are not ancestors of the new &quot;bad&quot; commit are not the first bad commit. We don&amp;rsquo;t know if they are good or bad, but we know that they are not the first bad commit because they are not ancestor of the new &quot;bad&quot; commit.</source>
          <target state="translated">但这是错误的，因为在步骤1）a）中，我们仅保留错误提交的祖先。因此，当将提交标记为&amp;ldquo;不良&amp;rdquo;时，我们会获得更多信息，因为我们还知道，先前的&amp;ldquo;不良&amp;rdquo;提交的祖先不是新的&amp;ldquo;不良&amp;rdquo;提交的祖先，也不是第一个不良提交。我们不知道它们是好是坏，但我们知道它们不是第一个错误的提交，因为它们不是新的&amp;ldquo;错误&amp;rdquo;提交的祖先。</target>
        </trans-unit>
        <trans-unit id="e9cd8c15ffc7ac156f5f412fb85c3db80183014e" translate="yes" xml:space="preserve">
          <source>But we can guess that improving on existing software is very costly because you have to watch out for regressions. At least this would make the above studies consistent among themselves.</source>
          <target state="translated">但我们可以猜测,在现有软件的基础上进行改进是非常昂贵的,因为你必须小心回归。至少这可以使上述研究之间保持一致。</target>
        </trans-unit>
        <trans-unit id="01400b0b75aa93032834530c59a576c885a202c7" translate="yes" xml:space="preserve">
          <source>But what happens if the first bad commit is &quot;B&quot; and if it has been fixed in the &quot;main&quot; branch by commit &quot;F&quot;?</source>
          <target state="translated">但是,如果第一个坏的提交是 &quot;B&quot;,而在 &quot;main &quot;分支中已经通过提交 &quot;F &quot;进行了修复,会发生什么?</target>
        </trans-unit>
        <trans-unit id="2333cc37236068d07ee88795051fd2e9ba955821" translate="yes" xml:space="preserve">
          <source>But you can use &lt;code&gt;reset --keep&lt;/code&gt; to remove the unwanted commit after you switched to &lt;code&gt;branch2&lt;/code&gt;.</source>
          <target state="translated">但是在切换到 &lt;code&gt;branch2&lt;/code&gt; 之后，可以使用 &lt;code&gt;reset --keep&lt;/code&gt; 删除不需要的提交。</target>
        </trans-unit>
        <trans-unit id="5d0b3a86464faedd1c461b3e2ac63fc4ba06661b" translate="yes" xml:space="preserve">
          <source>But you decided that the topic branch is not ready for public consumption yet. &quot;pull&quot; or &quot;merge&quot; always leaves the original tip of the current branch in &lt;code&gt;ORIG_HEAD&lt;/code&gt;, so resetting hard to it brings your index file and the working tree back to that state, and resets the tip of the branch to that commit.</source>
          <target state="translated">但是您认为主题分支尚未准备好供公众使用。&amp;ldquo; pull&amp;rdquo;或&amp;ldquo; merge&amp;rdquo;总是将当前分支的原始尖端 &lt;code&gt;ORIG_HEAD&lt;/code&gt; 在ORIG_HEAD中，因此对其进行硬重置会使索引文件和工作树回到该状态，并将分支的尖端重置为该提交。</target>
        </trans-unit>
        <trans-unit id="18ba832b59818b9d406aeb54ba66e145b5697021" translate="yes" xml:space="preserve">
          <source>By default (without --all or --tags) &lt;code&gt;git describe&lt;/code&gt; only shows annotated tags. For more information about creating annotated tags see the -a and -s options to &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;.</source>
          <target state="translated">默认情况下（不带--all或--tags）， &lt;code&gt;git describe&lt;/code&gt; 仅显示带注释的标签。有关创建带注释的标签的更多信息，请参见&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;的-a和-s选项。</target>
        </trans-unit>
        <trans-unit id="2aacef9af72c222fb1b6acf47a0fa851e92d4733" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;git fetch&lt;/code&gt; refuses to update the head which corresponds to the current branch. This flag disables the check. This is purely for the internal use for &lt;code&gt;git pull&lt;/code&gt; to communicate with &lt;code&gt;git fetch&lt;/code&gt;, and unless you are implementing your own Porcelain you are not supposed to use it.</source>
          <target state="translated">默认情况下， &lt;code&gt;git fetch&lt;/code&gt; 拒绝更新与当前分支相对应的head。该标志禁用检查。这纯粹是供 &lt;code&gt;git pull&lt;/code&gt; 与 &lt;code&gt;git fetch&lt;/code&gt; 进行通信的内部使用，除非您实现自己的Porcelain，否则不应使用它。</target>
        </trans-unit>
        <trans-unit id="1d408902dc303f6c00a1b0f596a5c28e377e82f7" translate="yes" xml:space="preserve">
          <source>By default Git will look for your hooks in the &lt;code&gt;$GIT_DIR/hooks&lt;/code&gt; directory. Set this to different path, e.g. &lt;code&gt;/etc/git/hooks&lt;/code&gt;, and Git will try to find your hooks in that directory, e.g. &lt;code&gt;/etc/git/hooks/pre-receive&lt;/code&gt; instead of in &lt;code&gt;$GIT_DIR/hooks/pre-receive&lt;/code&gt;.</source>
          <target state="translated">默认情况下，Git将在 &lt;code&gt;$GIT_DIR/hooks&lt;/code&gt; 目录中寻找您的钩子。将此设置为其他路径，例如 &lt;code&gt;/etc/git/hooks&lt;/code&gt; ，Git将尝试在该目录（例如 &lt;code&gt;/etc/git/hooks/pre-receive&lt;/code&gt; )中找到钩子，而不是在 &lt;code&gt;$GIT_DIR/hooks/pre-receive&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2707cacda66e328227d997bd98a14207b5d80af5" translate="yes" xml:space="preserve">
          <source>By default a &amp;lt;ref&amp;gt; not starting with refs/ is treated as the name of a remote-tracking branch (under refs/remotes/). This behavior can be modified using the --import-local option.</source>
          <target state="translated">默认情况下，不以refs /开头的&amp;lt;ref&amp;gt;被视为远程跟踪分支的名称（在refs / remotes /下）。可以使用--import-local选项修改此行为。</target>
        </trans-unit>
        <trans-unit id="9fda6ea140eac0d5f03c38d0b89c06bf6c01dbaa" translate="yes" xml:space="preserve">
          <source>By default all Git repositories under &lt;code&gt;$projectroot&lt;/code&gt; are visible and available to gitweb. The list of projects is generated by default by scanning the &lt;code&gt;$projectroot&lt;/code&gt; directory for Git repositories (for object databases to be more exact; gitweb is not interested in a working area, and is best suited to showing &quot;bare&quot; repositories).</source>
          <target state="translated">默认情况下， &lt;code&gt;$projectroot&lt;/code&gt; 下的所有Git存储库都是可见的，并可供gitweb使用。默认情况下，通过扫描 &lt;code&gt;$projectroot&lt;/code&gt; 目录中的Git存储库来生成项目列表（对于对象数据库更精确； gitweb对工作区域不感兴趣，最适合显示&amp;ldquo;裸露&amp;rdquo;存储库）。</target>
        </trans-unit>
        <trans-unit id="7d4dbfd64b78e6eb7460def3863c1e38e1d55fa2" translate="yes" xml:space="preserve">
          <source>By default all Git repositories under &lt;code&gt;$projectroot&lt;/code&gt; are visible and available to gitweb. You can however configure how gitweb controls access to repositories.</source>
          <target state="translated">默认情况下， &lt;code&gt;$projectroot&lt;/code&gt; 下的所有Git存储库都是可见的，并可供gitweb使用。但是，您可以配置gitweb如何控制对存储库的访问。</target>
        </trans-unit>
        <trans-unit id="6b749c474f0e8be473f5227adae69d6b82e99699" translate="yes" xml:space="preserve">
          <source>By default entries added by &quot;git add -N&quot; appear as an existing empty file in &quot;git diff&quot; and a new file in &quot;git diff --cached&quot;. This option makes the entry appear as a new file in &quot;git diff&quot; and non-existent in &quot;git diff --cached&quot;. This option could be reverted with &lt;code&gt;--ita-visible-in-index&lt;/code&gt;. Both options are experimental and could be removed in future.</source>
          <target state="translated">默认情况下，由&amp;ldquo; git add -N&amp;rdquo;添加的条目在&amp;ldquo; git diff&amp;rdquo;中显示为现有的空文件，在&amp;ldquo; git diff --cached&amp;rdquo;中显示为新文件。此选项使该条目在&amp;ldquo; git diff&amp;rdquo;中显示为新文件，而在&amp;ldquo; git diff --cached&amp;rdquo;中不存在。可以使用 &lt;code&gt;--ita-visible-in-index&lt;/code&gt; 还原此选项。这两种选择都是试验性的，将来可能会删除。</target>
        </trans-unit>
        <trans-unit id="f92479038911d91ec691ca1995b6f59bbf4d3495" translate="yes" xml:space="preserve">
          <source>By default it uses SQLite databases in the Git directory, named &lt;code&gt;gitcvs.&amp;lt;module_name&amp;gt;.sqlite&lt;/code&gt;. Note that the SQLite backend creates temporary files in the same directory as the database file on write so it might not be enough to grant the users using &lt;code&gt;git-cvsserver&lt;/code&gt; write access to the database file without granting them write access to the directory, too.</source>
          <target state="translated">默认情况下，它使用Git目录中名为 &lt;code&gt;gitcvs.&amp;lt;module_name&amp;gt;.sqlite&lt;/code&gt; SQLite数据库。请注意，SQLite后端在写入时与数据库文件位于同一目录中创建临时文件，因此可能不足以授予使用 &lt;code&gt;git-cvsserver&lt;/code&gt; 的用户对数据库文件的写访问权限，而又不授予他们对该目录的写访问权限。</target>
        </trans-unit>
        <trans-unit id="c6b06e8b566ecf1a19a23c408ec4ad0c91c68502" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;man&lt;/code&gt; program will be used to display the manual page, but the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable may be used to choose other display programs (see below).</source>
          <target state="translated">默认情况下， &lt;code&gt;man&lt;/code&gt; 程序将用于显示手册页，但是 &lt;code&gt;man.viewer&lt;/code&gt; 配置变量可以用于选择其他显示程序（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="2e5b50ac3c7c5c555c2ca84f458ac39569a0ee21" translate="yes" xml:space="preserve">
          <source>By default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the author date by using the same value as the committer date.</source>
          <target state="translated">默认情况下,该命令将邮件中的日期作为提交作者的日期,而将提交的时间作为提交者的日期。这就允许用户使用与提交人日期相同的值来隐瞒作者日期。</target>
        </trans-unit>
        <trans-unit id="eb47d162dbfc8bcd3a02f766bf35ff994d86e7f7" translate="yes" xml:space="preserve">
          <source>By default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the committer date by using the same value as the author date.</source>
          <target state="translated">默认情况下,该命令将邮件中的日期作为提交作者的日期,而将提交的时间作为提交者的日期。这就允许用户使用与作者日期相同的数值来隐瞒提交者的日期。</target>
        </trans-unit>
        <trans-unit id="6aeb14014b871b17a9d4f0da107bb610e5ea0157" translate="yes" xml:space="preserve">
          <source>By default the command shows all refs that match &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;. This option makes it stop after showing that many refs.</source>
          <target state="translated">默认情况下，该命令显示与 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 匹配的所有引用。此选项使它在显示很多参考之后停止。</target>
        </trans-unit>
        <trans-unit id="7d63d3915d070cca4c5d36e324ecb4a7f6a0679f" translate="yes" xml:space="preserve">
          <source>By default the command will try to detect the patch format automatically. This option allows the user to bypass the automatic detection and specify the patch format that the patch(es) should be interpreted as. Valid formats are mbox, mboxrd, stgit, stgit-series and hg.</source>
          <target state="translated">默认情况下,该命令将尝试自动检测补丁格式。此选项允许用户绕过自动检测,并指定应将补丁解释为的补丁格式。有效的格式是 mbox、mboxrd、stgit、stgit-series 和 hg。</target>
        </trans-unit>
        <trans-unit id="ee6799585dabe2a3016ffbe61452694b948c3ff6" translate="yes" xml:space="preserve">
          <source>By default the hooks directory is &lt;code&gt;$GIT_DIR/hooks&lt;/code&gt;, but that can be changed via the &lt;code&gt;core.hooksPath&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">默认情况下，hooks目录为 &lt;code&gt;$GIT_DIR/hooks&lt;/code&gt; ，但是可以通过 &lt;code&gt;core.hooksPath&lt;/code&gt; 配置变量（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）进行更改。</target>
        </trans-unit>
        <trans-unit id="1e420d062677a0d01238cac1bc0b0f93a32eaab8" translate="yes" xml:space="preserve">
          <source>By default the new trailer will appear at the end of all the existing trailers. If there is no existing trailer, the new trailer will appear after the commit message part of the output, and, if there is no line with only spaces at the end of the commit message part, one blank line will be added before the new trailer.</source>
          <target state="translated">默认情况下,新的预告片会出现在所有现有预告片的最后。如果没有现有的预告片,新的预告片将出现在输出的提交消息部分之后,如果提交消息部分的末尾没有只有空格的行,则在新的预告片之前增加一行空白。</target>
        </trans-unit>
        <trans-unit id="64ba0ec6c1bed38e21fc7f4f4a0aef9c8ebe7286" translate="yes" xml:space="preserve">
          <source>By default the server leaves the &lt;code&gt;-k&lt;/code&gt; mode blank for all files, which causes the CVS client to treat them as a text files, subject to end-of-line conversion on some platforms.</source>
          <target state="translated">默认情况下，服务器将所有文件的 &lt;code&gt;-k&lt;/code&gt; 模式保留为空白，这会使CVS客户端将它们视为文本文件，但在某些平台上需要进行行尾转换。</target>
        </trans-unit>
        <trans-unit id="54dcb4758211c9d2e362cc73ee7a92ca62d914ac" translate="yes" xml:space="preserve">
          <source>By default this file controls only which projects are &lt;strong&gt;visible&lt;/strong&gt; on projects list page (note that entries that do not point to correctly recognized Git repositories won&amp;rsquo;t be displayed by gitweb). Even if a project is not visible on projects list page, you can view it nevertheless by hand-crafting a gitweb URL. By setting &lt;code&gt;$strict_export&lt;/code&gt; configuration variable (see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;) to true value you can allow viewing only of repositories also shown on the overview page (i.e. only projects explicitly listed in projects list file will be accessible).</source>
          <target state="translated">默认情况下，此文件仅控制哪些项目在项目列表页面上&lt;strong&gt;可见&lt;/strong&gt;（请注意，gitweb不会显示未指向正确识别的Git存储库的条目）。即使项目在项目列表页面上不可见，您仍然可以通过手工制作gitweb URL来查看它。通过将 &lt;code&gt;$strict_export&lt;/code&gt; 配置变量（请参见&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt;）设置为true值，您可以只查看也在概述页面上显示的存储库（即，仅可访问在项目列表文件中明确列出的项目）。</target>
        </trans-unit>
        <trans-unit id="eff6e029914fd799d6a59537c15d9f46e8d635a6" translate="yes" xml:space="preserve">
          <source>By default when &lt;code&gt;--all&lt;/code&gt; is specified, reflogs from all working trees are processed. This option limits the processing to reflogs from the current working tree only.</source>
          <target state="translated">默认情况下，当指定 &lt;code&gt;--all&lt;/code&gt; 时，将处理所有工作树的引用日志。此选项将处理限制为仅来自当前工作树的重新引用。</target>
        </trans-unit>
        <trans-unit id="898aa5511bdcc79b6cc36a9d8f0c7e7e9ffc1277" translate="yes" xml:space="preserve">
          <source>By default when fetching from a shallow repository, &lt;code&gt;git fetch&lt;/code&gt; refuses refs that require updating .git/shallow. This option updates .git/shallow and accept such refs.</source>
          <target state="translated">默认情况下，当从浅存储库中 &lt;code&gt;git fetch&lt;/code&gt; ，git fetch拒绝需要更新.git / shallow的引用。此选项更新.git / shallow并接受此类引用。</target>
        </trans-unit>
        <trans-unit id="8a946900900b0969e5566670798dfa0b25059b02" translate="yes" xml:space="preserve">
          <source>By default, &quot;updateInstead&quot; will refuse the push if the working tree or the index have any difference from the HEAD, but the &lt;code&gt;push-to-checkout&lt;/code&gt; hook can be used to customize this. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">默认情况下，如果工作树或索引与HEAD有任何不同，&amp;ldquo; updateInstead&amp;rdquo;将拒绝推送，但是可以使用 &lt;code&gt;push-to-checkout&lt;/code&gt; 挂钩自定义此推送。参见&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccc06ea9e45b9e60a670cf461c22563d24643639" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; creates packs that use delta-base offset. If you need to share your repository with Git older than version 1.4.4, either directly or via a dumb protocol such as http, then you need to set this option to &quot;false&quot; and repack. Access from old Git versions over the native protocol are unaffected by this option.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;创建使用基于增量偏移的包。如果您需要直接或通过诸如http之类的哑协议与早于1.4.4版本的Git共享存储库，则需要将此选项设置为&amp;ldquo; false&amp;rdquo;并重新打包。通过本机协议从旧Git版本进行的访问不受此选项的影响。</target>
        </trans-unit>
        <trans-unit id="207b9ec4a7354c6cbc08217ef08c22e3683c8d13" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; show files which are not currently tracked by Git. Directories which contain only untracked files, are shown with the directory name only. Showing untracked files means that Git needs to lstat() all the files in the whole repository, which might be slow on some systems. So, this variable controls how the commands displays the untracked files. Possible values are:</source>
          <target state="translated">默认情况下，&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;和&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;显示Git当前未跟踪的文件。仅包含未跟踪文件的目录仅显示目录名称。显示未跟踪的文件意味着Git需要lstat（）整个存储库中的所有文件，这在某些系统上可能很慢。因此，此变量控制命令如何显示未跟踪的文件。可能的值为：</target>
        </trans-unit>
        <trans-unit id="0594913527635a38d7d1da1f58cf2049e0d81ae9" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; shows paths relative to the current directory. Setting this variable to &lt;code&gt;false&lt;/code&gt; shows paths relative to the repository root (this was the default for Git prior to v1.5.4).</source>
          <target state="translated">默认情况下，&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;显示相对于当前目录的路径。将此变量设置为 &lt;code&gt;false&lt;/code&gt; 会显示相对于存储库根目录的路径（这是v1.5.4之前的Git的默认设置）。</target>
        </trans-unit>
        <trans-unit id="93044cb17b41f6ff0ab9ae102eca02ce8d5cdb16" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;add&lt;/code&gt; checks out &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, however, &lt;code&gt;--no-checkout&lt;/code&gt; can be used to suppress checkout in order to make customizations, such as configuring sparse-checkout. See &quot;Sparse checkout&quot; in &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;add&lt;/code&gt; 签出 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; ，但是 &lt;code&gt;--no-checkout&lt;/code&gt; 可用于禁止签出以进行自定义，例如配置稀疏签出。参见&lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]中的&lt;/a&gt; &amp;ldquo;稀疏签出&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="d6911782a1bf788b96e52d6283b9603906afd385" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;add&lt;/code&gt; refuses to create a new working tree when &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch name and is already checked out by another working tree, or if &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is already assigned to some working tree but is missing (for instance, if &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; was deleted manually). This option overrides these safeguards. To add a missing but locked working tree path, specify &lt;code&gt;--force&lt;/code&gt; twice.</source>
          <target state="translated">默认情况下，当 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 是分支名称并且已经被另一个工作树检出时，或者如果 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 已经分配给某个工作树但丢失了，例如， &lt;code&gt;add&lt;/code&gt; 拒绝创建新的工作树（例如，如果 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 是手动删除的）。此选项将覆盖这些安全措施。要添加丢失但已锁定的工作树路径，请两次指定 &lt;code&gt;--force&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6808cb2e8497f1a21da404e6487ab0df6e47fd0" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git add&lt;/code&gt; will warn when adding an embedded repository to the index without using &lt;code&gt;git submodule add&lt;/code&gt; to create an entry in &lt;code&gt;.gitmodules&lt;/code&gt;. This option will suppress the warning (e.g., if you are manually performing operations on submodules).</source>
          <target state="translated">默认情况下，当将嵌入式存储库 &lt;code&gt;git submodule add&lt;/code&gt; 到索引而不使用git submodule add在 &lt;code&gt;.gitmodules&lt;/code&gt; 中创建条目时， &lt;code&gt;git add&lt;/code&gt; 将发出警告。此选项将禁止显示警告（例如，如果您正在手动对子模块执行操作）。</target>
        </trans-unit>
        <trans-unit id="9f7a911ab745fcc1ecc2d75cf5b4666d5616a0f2" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git am&lt;/code&gt; will fail if the patch does not apply cleanly. When set to true, this setting tells &lt;code&gt;git am&lt;/code&gt; to fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally (equivalent to giving the &lt;code&gt;--3way&lt;/code&gt; option from the command line). Defaults to &lt;code&gt;false&lt;/code&gt;. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;.</source>
          <target state="translated">默认情况下，如果补丁不能很好地应用， &lt;code&gt;git am&lt;/code&gt; 将会失败。当设置为true，这个设置告诉 &lt;code&gt;git am&lt;/code&gt; 依傍3路合并，如果补丁记录它应该适用于斑点的身份和我们现有的斑点本地（相当于给 &lt;code&gt;--3way&lt;/code&gt; 从选项命令行）。默认为 &lt;code&gt;false&lt;/code&gt; 。参见&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04d5b79eb2c1cc00ec23b84308367755078f2519" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git apply&lt;/code&gt; expects that the patch being applied is a unified diff with at least one line of context. This provides good safety measures, but breaks down when applying a diff generated with &lt;code&gt;--unified=0&lt;/code&gt;. To bypass these checks use &lt;code&gt;--unidiff-zero&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;git apply&lt;/code&gt; 期望所应用的补丁是具有至少一行上下文的统一差异。这提供了良好的安全措施，但是在应用 &lt;code&gt;--unified=0&lt;/code&gt; 生成的diff时会崩溃。要绕过这些检查，请使用 &lt;code&gt;--unidiff-zero&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc5e77409adaefd524775157d3aa209b06e80ef9" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git diff-tree --stdin&lt;/code&gt; does not show differences for merge commits. With this flag, it shows differences to that commit from all of its parents. See also &lt;code&gt;-c&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;git diff-tree --stdin&lt;/code&gt; 不显示合并提交的差异。使用此标志，它显示了其所有父项与该提交的差异。另请参见 &lt;code&gt;-c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44f438a687f3c8843b562164d423119ef0393e39" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git diff-tree --stdin&lt;/code&gt; shows differences, either in machine-readable form (without &lt;code&gt;-p&lt;/code&gt;) or in patch form (with &lt;code&gt;-p&lt;/code&gt;). This output can be suppressed. It is only useful with &lt;code&gt;-v&lt;/code&gt; flag.</source>
          <target state="translated">默认情况下， &lt;code&gt;git diff-tree --stdin&lt;/code&gt; 以机器可读形式（不带 &lt;code&gt;-p&lt;/code&gt; ）或补丁程序形式（带 &lt;code&gt;-p&lt;/code&gt; ）显示差异。该输出可以被抑制。仅与 &lt;code&gt;-v&lt;/code&gt; 标志一起使用。</target>
        </trans-unit>
        <trans-unit id="41ecfd2369ab83f2851da4837d8f55ae828a688b" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git merge&lt;/code&gt; command refuses to merge histories that do not share a common ancestor. This option can be used to override this safety when merging histories of two projects that started their lives independently. As that is a very rare occasion, no configuration variable to enable this by default exists and will not be added.</source>
          <target state="translated">默认情况下， &lt;code&gt;git merge&lt;/code&gt; 命令拒绝合并不共享共同祖先的历史记录。当合并两个独立开始的项目的历史时，可以使用此选项来覆盖此安全性。因为这是非常罕见的情况，所以默认情况下不存在用于启用此功能的配置变量，因此不会添加。</target>
        </trans-unit>
        <trans-unit id="c206e08a568b5af4b242b43f3b62e41c9c2a00a0" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git status&lt;/code&gt; will automatically refresh the index, updating the cached stat information from the working tree and writing out the result. Writing out the updated index is an optimization that isn&amp;rsquo;t strictly necessary (&lt;code&gt;status&lt;/code&gt; computes the values for itself, but writing them out is just to save subsequent programs from repeating our computation). When &lt;code&gt;status&lt;/code&gt; is run in the background, the lock held during the write may conflict with other simultaneous processes, causing them to fail. Scripts running &lt;code&gt;status&lt;/code&gt; in the background should consider using &lt;code&gt;git --no-optional-locks status&lt;/code&gt; (see &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details).</source>
          <target state="translated">默认情况下， &lt;code&gt;git status&lt;/code&gt; 将自动刷新索引，从工作树中更新缓存的统计信息并写出结果。写出更新的索引不是严格必要的优化（ &lt;code&gt;status&lt;/code&gt; 自行计算值，但是写出它们只是为了节省后续程序免于重复我们的计算）。当 &lt;code&gt;status&lt;/code&gt; 在后台运行时，写期间持有的锁可能会与其他同时进行的进程发生冲突，从而导致它们失败。脚本在后台运行 &lt;code&gt;status&lt;/code&gt; 应考虑使用 &lt;code&gt;git --no-optional-locks status&lt;/code&gt; （有关详细信息，请参见&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0166a80c7cb65bd63925a576fc16b6b5666a6f97" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git tag&lt;/code&gt; in sign-with-default mode (-s) will use your committer identity (of the form &lt;code&gt;Your Name &amp;lt;your@email.address&amp;gt;&lt;/code&gt;) to find a key. If you want to use a different default key, you can specify it in the repository configuration as follows:</source>
          <target state="translated">默认情况下，使用默认签名模式（-s）的 &lt;code&gt;git tag&lt;/code&gt; 将使用您的提交者身份（格式为 &lt;code&gt;Your Name &amp;lt;your@email.address&amp;gt;&lt;/code&gt; ）来查找密钥。如果要使用其他默认密钥，则可以在存储库配置中如下指定它：</target>
        </trans-unit>
        <trans-unit id="ab2e2876fa31ec281a3a2c1b794b7dec91ae3790" translate="yes" xml:space="preserve">
          <source>By default, Git determines the command line arguments to use based on the basename of the configured SSH command (configured using the environment variable &lt;code&gt;GIT_SSH&lt;/code&gt; or &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; or the config setting &lt;code&gt;core.sshCommand&lt;/code&gt;). If the basename is unrecognized, Git will attempt to detect support of OpenSSH options by first invoking the configured SSH command with the &lt;code&gt;-G&lt;/code&gt; (print configuration) option and will subsequently use OpenSSH options (if that is successful) or no options besides the host and remote command (if it fails).</source>
          <target state="translated">默认情况下，Git根据已配置的SSH命令（使用环境变量 &lt;code&gt;GIT_SSH&lt;/code&gt; 或 &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; 或配置设置 &lt;code&gt;core.sshCommand&lt;/code&gt; 进行配置）的基本名称来确定要使用的命令行参数。如果无法识别基本名称，Git将尝试通过首先使用 &lt;code&gt;-G&lt;/code&gt; （打印配置）选项调用已配置的SSH命令来尝试检测对OpenSSH选项的支持，随后将使用OpenSSH选项（如果成功）或除主机和主机之外不使用任何选项。远程命令（如果失败）。</target>
        </trans-unit>
        <trans-unit id="b85b0c2bab173615caaf4bbe66c1c28d30e786cc" translate="yes" xml:space="preserve">
          <source>By default, Git does not consider the &quot;path&quot; component of an http URL to be worth matching via external helpers. This means that a credential stored for &lt;code&gt;https://example.com/foo.git&lt;/code&gt; will also be used for &lt;code&gt;https://example.com/bar.git&lt;/code&gt;. If you do want to distinguish these cases, set this option to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">默认情况下，Git认为HTTP URL的&amp;ldquo;路径&amp;rdquo;组件不值得通过外部帮助器进行匹配。这意味着为 &lt;code&gt;https://example.com/foo.git&lt;/code&gt; 存储的凭据也将用于 &lt;code&gt;https://example.com/bar.git&lt;/code&gt; 。如果确实要区分这些情况，请将此选项设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffe1eaf4d1c9cc64df80a6b16dfbf1fa771b52c9" translate="yes" xml:space="preserve">
          <source>By default, Git does not create an extra merge commit when merging a commit that is a descendant of the current commit. Instead, the tip of the current branch is fast-forwarded. When set to &lt;code&gt;false&lt;/code&gt;, this variable tells Git to create an extra merge commit in such a case (equivalent to giving the &lt;code&gt;--no-ff&lt;/code&gt; option from the command line). When set to &lt;code&gt;only&lt;/code&gt;, only such fast-forward merges are allowed (equivalent to giving the &lt;code&gt;--ff-only&lt;/code&gt; option from the command line).</source>
          <target state="translated">默认情况下，当合并作为当前提交的后代的提交时，Git不会创建额外的合并提交。相反，当前分支的尖端是快进的。当设置为 &lt;code&gt;false&lt;/code&gt; 时，此变量告诉Git在这种情况下创建一个额外的合并提交（相当于从命令行提供 &lt;code&gt;--no-ff&lt;/code&gt; 选项）。设置为 &lt;code&gt;only&lt;/code&gt; 时，仅允许进行此类快速合并（等同于 &lt;code&gt;--ff-only&lt;/code&gt; 提供--ff-only选项）。</target>
        </trans-unit>
        <trans-unit id="32c0486f322ae0e4678fa0824298d7c086e9ee4f" translate="yes" xml:space="preserve">
          <source>By default, Git does not create an extra merge commit when merging a commit that is a descendant of the current commit. Instead, the tip of the current branch is fast-forwarded. When set to &lt;code&gt;false&lt;/code&gt;, this variable tells Git to create an extra merge commit in such a case (equivalent to giving the &lt;code&gt;--no-ff&lt;/code&gt; option from the command line). When set to &lt;code&gt;only&lt;/code&gt;, only such fast-forward merges are allowed (equivalent to giving the &lt;code&gt;--ff-only&lt;/code&gt; option from the command line). This setting overrides &lt;code&gt;merge.ff&lt;/code&gt; when pulling.</source>
          <target state="translated">默认情况下，当合并作为当前提交的后代的提交时，Git不会创建额外的合并提交。相反，当前分支的尖端是快进的。当设置为 &lt;code&gt;false&lt;/code&gt; 时，此变量告诉Git在这种情况下创建一个额外的合并提交（相当于从命令行提供 &lt;code&gt;--no-ff&lt;/code&gt; 选项）。设置为 &lt;code&gt;only&lt;/code&gt; 时，仅允许这种快速合并（相当于 &lt;code&gt;--ff-only&lt;/code&gt; 提供--ff-only选项）。拉动时，此设置将覆盖 &lt;code&gt;merge.ff&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e39ec591fb076f73ed5744e6cef724be12b06bb7" translate="yes" xml:space="preserve">
          <source>By default, Git uses the same style as the one used by the &quot;merge&quot; program from the RCS suite to present such a conflicted hunk, like this:</source>
          <target state="translated">默认情况下,Git使用与RCS套件中的 &quot;merge &quot;程序相同的风格来呈现这样一个冲突的hunk,比如这样。</target>
        </trans-unit>
        <trans-unit id="632bd7b7934c758c995d70fcf0643a53a17ef93c" translate="yes" xml:space="preserve">
          <source>By default, Git will report, to the server, commits reachable from all local refs to find common commits in an attempt to reduce the size of the to-be-received packfile. If specified, Git will only report commits reachable from the given tips. This is useful to speed up fetches when the user knows which local ref is likely to have commits in common with the upstream ref being fetched.</source>
          <target state="translated">默认情况下,Git 会向服务器报告从所有本地 refs 中可以到达的提交,以找到共同的提交,从而减少将要接收的 packfile 的大小。如果指定了这个选项,Git 将只报告从给定的提示中可以到达的提交。当用户知道哪个本地 ref 可能与上游 ref 有共同的提交时,这对加快获取速度很有用。</target>
        </trans-unit>
        <trans-unit id="ec00d75621e8cccd0e732ba6afc6d14548cb8a4e" translate="yes" xml:space="preserve">
          <source>By default, Thunderbird will both wrap emails as well as flag them as being &lt;code&gt;format=flowed&lt;/code&gt;, both of which will make the resulting email unusable by Git.</source>
          <target state="translated">默认情况下，Thunderbird会同时包装电子邮件并将其标记为 &lt;code&gt;format=flowed&lt;/code&gt; ，这两者都会使生成的电子邮件无法被Git使用。</target>
        </trans-unit>
        <trans-unit id="cb931511b378f47ed0453a8a3e156978cca15ca4" translate="yes" xml:space="preserve">
          <source>By default, a &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;token&amp;gt;:&amp;lt;value&amp;gt;&lt;/code&gt; argument given using &lt;code&gt;--trailer&lt;/code&gt; will be appended after the existing trailers only if the last trailer has a different (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair (or if there is no existing trailer). The &amp;lt;token&amp;gt; and &amp;lt;value&amp;gt; parts will be trimmed to remove starting and trailing whitespace, and the resulting trimmed &amp;lt;token&amp;gt; and &amp;lt;value&amp;gt; will appear in the message like this:</source>
          <target state="translated">默认情况下，仅当最后一个预告片具有不同的对（&amp;lt;token&amp;gt;，&amp;lt;value&amp;gt;）对时，使用 &lt;code&gt;--trailer&lt;/code&gt; 给出的 &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;token&amp;gt;:&amp;lt;value&amp;gt;&lt;/code&gt; 参数将附加在现有预告片之后。 （或者如果没有现有的预告片）。将修剪&amp;lt;token&amp;gt;和&amp;lt;value&amp;gt;部分，以删除开始和结尾的空格，并且结果修剪后的&amp;lt;token&amp;gt;和&amp;lt;value&amp;gt;将出现在消息中，如下所示：</target>
        </trans-unit>
        <trans-unit id="434e3c7441379e0ab27bf268d6dee72f73412814" translate="yes" xml:space="preserve">
          <source>By default, a patch that affects outside the working area (either a Git controlled working tree, or the current working directory when &quot;git apply&quot; is used as a replacement of GNU patch) is rejected as a mistake (or a mischief).</source>
          <target state="translated">默认情况下,影响到工作区域之外的补丁(无论是 Git 控制的工作树,还是使用 &quot;git apply &quot;替代 GNU 补丁时的当前工作目录)都会被视为错误(或恶作剧)而被拒绝。</target>
        </trans-unit>
        <trans-unit id="ea0000563105721871c07339b879614c007bc152" translate="yes" xml:space="preserve">
          <source>By default, a rebase will simply drop merge commits from the todo list, and put the rebased commits into a single, linear branch. With &lt;code&gt;--rebase-merges&lt;/code&gt;, the rebase will instead try to preserve the branching structure within the commits that are to be rebased, by recreating the merge commits. Any resolved merge conflicts or manual amendments in these merge commits will have to be resolved/re-applied manually.</source>
          <target state="translated">默认情况下，rebase会简单地将合并提交从todo列表中删除，并将重新提交的提交放入单个线性分支中。使用 &lt;code&gt;--rebase-merges&lt;/code&gt; ，rebase将通过重新创建合并提交来尝试在要重新提交的提交中保留分支结构。这些合并提交中的任何已解决的合并冲突或手动修订都必须手动解决/重新应用。</target>
        </trans-unit>
        <trans-unit id="92f108d472fe60a4c0a9d93474bd0154c5c0a9e2" translate="yes" xml:space="preserve">
          <source>By default, all working trees will be examined by the following options when there are more than one (see &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;): &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--reflog&lt;/code&gt; and &lt;code&gt;--indexed-objects&lt;/code&gt;. This option forces them to examine the current working tree only.</source>
          <target state="translated">默认情况下，所有工作的树木将被下面的选项时，有检查不止一个（见&lt;a href=&quot;git-worktree&quot;&gt;的git-worktree [1] &lt;/a&gt;）： &lt;code&gt;--all&lt;/code&gt; ， &lt;code&gt;--reflog&lt;/code&gt; 和 &lt;code&gt;--indexed-objects&lt;/code&gt; 。此选项强制他们仅检查当前的工作树。</target>
        </trans-unit>
        <trans-unit id="1feea061cb833e84202a29cce6b0929662b79ff4" translate="yes" xml:space="preserve">
          <source>By default, any branch can be used as the source for a &lt;code&gt;git p4 submit&lt;/code&gt; operation. This configuration variable, if set, permits only the named branches to be used as submit sources. Branch names must be the short names (no &quot;refs/heads/&quot;), and should be separated by commas (&quot;,&quot;), with no spaces.</source>
          <target state="translated">默认情况下，任何分支都可以用作 &lt;code&gt;git p4 submit&lt;/code&gt; 操作的源。如果设置了此配置变量，则仅允许将命名的分支用作提交源。分支名称必须是短名称（没有&amp;ldquo; refs / heads /&amp;rdquo;），并且应以逗号（&amp;ldquo;，&amp;rdquo;）分隔，且不能有空格。</target>
        </trans-unit>
        <trans-unit id="cb82df8bc2b9bbd18ae6db77878aee5f1360ef3d" translate="yes" xml:space="preserve">
          <source>By default, any of the given pathnames which match an ignore pattern will be output, one per line. If no pattern matches a given path, nothing will be output for that path; this means that path will not be ignored.</source>
          <target state="translated">默认情况下,任何符合忽略模式的路径名都会被输出,每行一个。如果没有与给定路径匹配的模式,则该路径将不会输出任何内容;这意味着该路径不会被忽略。</target>
        </trans-unit>
        <trans-unit id="9840f412411908e4167e9b89fe91af90f41421dd" translate="yes" xml:space="preserve">
          <source>By default, any tag that points into the histories being fetched is also fetched; the effect is to fetch tags that point at branches that you are interested in. This default behavior can be changed by using the --tags or --no-tags options or by configuring remote.&amp;lt;name&amp;gt;.tagOpt. By using a refspec that fetches tags explicitly, you can fetch tags that do not point into branches you are interested in as well.</source>
          <target state="translated">默认情况下，任何指向要获取的历史记录的标记也会被获取；效果是获取指向您感兴趣的分支的标记。可以使用--tags或--no-tags选项或配置remote。&amp;lt;name&amp;gt; .tagOpt来更改此默认行为。通过使用显式获取标签的refspec，您还可以获取不指向您感兴趣的分支的标签。</target>
        </trans-unit>
        <trans-unit id="859edf72ede027900910837f2758e52dd7b73b08" translate="yes" xml:space="preserve">
          <source>By default, cherry-picking a commit with an empty message will fail. This option overrides that behavior, allowing commits with empty messages to be cherry picked.</source>
          <target state="translated">默认情况下,挑空消息的提交会失败。这个选项可以重写这个行为,允许带空消息的提交被摘取。</target>
        </trans-unit>
        <trans-unit id="c2ea9611dc2821c1e170c93c6a453dad2dd69c2d" translate="yes" xml:space="preserve">
          <source>By default, cherry-picking an empty commit will fail, indicating that an explicit invocation of &lt;code&gt;git commit
--allow-empty&lt;/code&gt; is required. This option overrides that behavior, allowing empty commits to be preserved automatically in a cherry-pick. Note that when &quot;--ff&quot; is in effect, empty commits that meet the &quot;fast-forward&quot; requirement will be kept even without this option. Note also, that use of this option only keeps commits that were initially empty (i.e. the commit recorded the same tree as its parent). Commits which are made empty due to a previous commit are dropped. To force the inclusion of those commits use &lt;code&gt;--keep-redundant-commits&lt;/code&gt;.</source>
          <target state="translated">默认情况下，挑选空提交失败，这表明需要显式调用 &lt;code&gt;git commit --allow-empty&lt;/code&gt; 。此选项将覆盖该行为，从而允许空提交自动保留在&amp;ldquo;自动选择&amp;rdquo;中。请注意，当&amp;ldquo; --ff&amp;rdquo;生效时，即使没有此选项，也会保留符合&amp;ldquo;快进&amp;rdquo;要求的空提交。还要注意，使用此选项只会保留最初为空的提交（即，提交记录的树与其父树相同）。由于先前的提交而变为空的提交将被丢弃。要强制包含这些提交，请使用 &lt;code&gt;--keep-redundant-commits&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99709c182dff4928785c30a9c26112a6276f34d2" translate="yes" xml:space="preserve">
          <source>By default, each output file is numbered sequentially from 1, and uses the first line of the commit message (massaged for pathname safety) as the filename. With the &lt;code&gt;--numbered-files&lt;/code&gt; option, the output file names will only be numbers, without the first line of the commit appended. The names of the output files are printed to standard output, unless the &lt;code&gt;--stdout&lt;/code&gt; option is specified.</source>
          <target state="translated">默认情况下，每个输出文件从1开始按顺序编号，并使用提交消息的第一行（为保证路径名的安全性而使用）作为文件名。使用 &lt;code&gt;--numbered-files&lt;/code&gt; 选项，输出文件名将仅是数字，而未附加提交的第一行。除非指定了 &lt;code&gt;--stdout&lt;/code&gt; 选项，否则输出文件的名称将打印到标准输出中。</target>
        </trans-unit>
        <trans-unit id="3d27fcf4c77eeb925cb728d43582e85b263ea253" translate="yes" xml:space="preserve">
          <source>By default, files recorded in the index but not checked out are reported as deleted. This flag makes &lt;code&gt;git diff-index&lt;/code&gt; say that all non-checked-out files are up to date.</source>
          <target state="translated">默认情况下，记录在索引中但未检出的文件被报告为已删除。这个标志使 &lt;code&gt;git diff-index&lt;/code&gt; 表示所有未检出的文件都是最新的。</target>
        </trans-unit>
        <trans-unit id="96d263210b58deac758523391a09d64f715778b1" translate="yes" xml:space="preserve">
          <source>By default, git checks if a branch is force-updated during fetch. Pass --no-show-forced-updates or set fetch.showForcedUpdates to false to skip this check for performance reasons. If used during &lt;code&gt;git-pull&lt;/code&gt; the --ff-only option will still check for forced updates before attempting a fast-forward update. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">默认情况下，git检查在提取过程中是否强制更新了分支。传递--no-show-forced-updates或将fetch.showForcedUpdates设置为false可出于性能原因跳过此检查。如果在 &lt;code&gt;git-pull&lt;/code&gt; 期间使用，则&amp;ndash;ff-only选项仍将在尝试快速转发更新之前检查强制更新。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bcd22a0eaa98a42d194f3bb1ae51915a7ffdb1a6" translate="yes" xml:space="preserve">
          <source>By default, git checks if a branch is force-updated during fetch. This can be disabled through fetch.showForcedUpdates, but the --show-forced-updates option guarantees this check occurs. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">默认情况下，git检查在提取过程中是否强制更新了分支。可以通过fetch.showForcedUpdates禁用此功能，但是--show-forced-updates选项可确保进行此检查。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd1e0c76aa334eb061df6d08bfae08afe6a12c47" translate="yes" xml:space="preserve">
          <source>By default, git-receive-pack will advertise the atomic push capability to its clients. If you don&amp;rsquo;t want to advertise this capability, set this variable to false.</source>
          <target state="translated">默认情况下，git-receive-pack将向其客户端通告原子推送功能。如果您不想宣传此功能，请将此变量设置为false。</target>
        </trans-unit>
        <trans-unit id="1a975a4b5c6ec62cbf8bcd46f9c353ac381aea16" translate="yes" xml:space="preserve">
          <source>By default, git-receive-pack will run &quot;git-gc --auto&quot; after receiving data from git-push and updating refs. You can stop it by setting this variable to false.</source>
          <target state="translated">默认情况下,git-receive-pack 会在接收到 git-push 的数据并更新 refs 后运行 &quot;git-gc --auto&quot;。你可以把这个变量设置为false来停止它。</target>
        </trans-unit>
        <trans-unit id="a70c8c423de4cae10f96eacc568cc485314e2875" translate="yes" xml:space="preserve">
          <source>By default, notes are saved to and read from &lt;code&gt;refs/notes/commits&lt;/code&gt;, but this default can be overridden. See the OPTIONS, CONFIGURATION, and ENVIRONMENT sections below. If this ref does not exist, it will be quietly created when it is first needed to store a note.</source>
          <target state="translated">默认情况下，便笺将保存到 &lt;code&gt;refs/notes/commits&lt;/code&gt; 并从中读取，但是此默认值可以被覆盖。请参阅下面的&amp;ldquo;选项&amp;rdquo;，&amp;ldquo;配置&amp;rdquo;和&amp;ldquo;环境&amp;rdquo;部分。如果此引用不存在，则在第一次需要存储注释时将自动创建该引用。</target>
        </trans-unit>
        <trans-unit id="7db5a2446c4341c306923f095d2e7f8486b88ca6" translate="yes" xml:space="preserve">
          <source>By default, only &lt;code&gt;upload-pack&lt;/code&gt; service is enabled, which serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients, which are invoked from &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt;, and &lt;code&gt;git clone&lt;/code&gt;.</source>
          <target state="translated">默认情况下，仅启用 &lt;code&gt;upload-pack&lt;/code&gt; 服务，该服务为 &lt;code&gt;git fetch-pack&lt;/code&gt; 和 &lt;code&gt;git ls-remote&lt;/code&gt; 客户端提供服务，这些客户端是从 &lt;code&gt;git fetch&lt;/code&gt; ， &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git clone&lt;/code&gt; 调用的。</target>
        </trans-unit>
        <trans-unit id="d1846d634d738a19049ad205d84e7a2d6c7d9843" translate="yes" xml:space="preserve">
          <source>By default, only tags on fetched branches are imported (see &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">默认情况下，仅导入获取的分支上的标签（请参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="330929bfac5b0158d7117057a21f395479839e07" translate="yes" xml:space="preserve">
          <source>By default, only the &lt;code&gt;upload-pack&lt;/code&gt; service is enabled, which serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients, which are invoked from &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt;, and &lt;code&gt;git clone&lt;/code&gt;. If the client is authenticated, the &lt;code&gt;receive-pack&lt;/code&gt; service is enabled, which serves &lt;code&gt;git send-pack&lt;/code&gt; clients, which is invoked from &lt;code&gt;git push&lt;/code&gt;.</source>
          <target state="translated">默认情况下，仅启用 &lt;code&gt;upload-pack&lt;/code&gt; 服务，该服务为 &lt;code&gt;git fetch-pack&lt;/code&gt; 和 &lt;code&gt;git ls-remote&lt;/code&gt; 客户端提供服务，这些客户端是从 &lt;code&gt;git fetch&lt;/code&gt; ， &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git clone&lt;/code&gt; 调用的。如果客户端通过了身份验证，则会启用 &lt;code&gt;receive-pack&lt;/code&gt; 服务，该服务为 &lt;code&gt;git send-pack&lt;/code&gt; 客户端提供服务，该客户端从 &lt;code&gt;git push&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="0265af70a38c5e98df8aec91888bb8ebd90e0b3b" translate="yes" xml:space="preserve">
          <source>By default, or when &lt;code&gt;no-rebase-cousins&lt;/code&gt; was specified, commits which do not have &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt; as direct ancestor will keep their original branch point, i.e. commits that would be excluded by &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;'s &lt;code&gt;--ancestry-path&lt;/code&gt; option will keep their original ancestry by default. If the &lt;code&gt;rebase-cousins&lt;/code&gt; mode is turned on, such commits are instead rebased onto &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt; (or &lt;code&gt;&amp;lt;onto&amp;gt;&lt;/code&gt;, if specified).</source>
          <target state="translated">默认情况下，或者当指定 &lt;code&gt;no-rebase-cousins&lt;/code&gt; 时，没有 &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt; 作为直接祖先的提交将保留其原始分支点，即&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;的 &lt;code&gt;--ancestry-path&lt;/code&gt; 排除的提交。 path选项将默认保留其原始血统。如果打开了 &lt;code&gt;rebase-cousins&lt;/code&gt; 模式，则这些提交将改基于 &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt; （或 &lt;code&gt;&amp;lt;onto&amp;gt;&lt;/code&gt; ，如果指定）。</target>
        </trans-unit>
        <trans-unit id="37d300d0f44033465a93b6aee94bab48b54dbf53" translate="yes" xml:space="preserve">
          <source>By default, p4 branches are stored in &lt;code&gt;refs/remotes/p4/&lt;/code&gt;, where they will be treated as remote-tracking branches by &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; and other commands. This option instead puts p4 branches in &lt;code&gt;refs/heads/p4/&lt;/code&gt;. Note that future sync operations must specify &lt;code&gt;--import-local&lt;/code&gt; as well so that they can find the p4 branches in refs/heads.</source>
          <target state="translated">默认情况下，p4分支存储在 &lt;code&gt;refs/remotes/p4/&lt;/code&gt; ，在这里它们将被&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;和其他命令视为远程跟踪分支。相反，此选项将p4分支放在 &lt;code&gt;refs/heads/p4/&lt;/code&gt; 。请注意，将来的同步操作也必须指定 &lt;code&gt;--import-local&lt;/code&gt; ，以便它们可以在引用/ heads中找到p4分支。</target>
        </trans-unit>
        <trans-unit id="52600650ec12082f5a2bcdafd01bd7a6322055cf" translate="yes" xml:space="preserve">
          <source>By default, rebasing commits with an empty message will fail. This option overrides that behavior, allowing commits with empty messages to be rebased.</source>
          <target state="translated">默认情况下,对空消息的提交进行重定基会失败。这个选项可以覆盖这个行为,允许对空消息的提交进行重归。</target>
        </trans-unit>
        <trans-unit id="aab8804804be7a1049e7aa89e2807caa0461793c" translate="yes" xml:space="preserve">
          <source>By default, running a command such as &lt;code&gt;git fast-export
master~5..master&lt;/code&gt; will not include the commit master~5 and will make master~4 no longer have master~5 as a parent (though both the old master~4 and new master~4 will have all the same files). Use --reference-excluded-parents to instead have the stream refer to commits in the excluded range of history by their sha1sum. Note that the resulting stream can only be used by a repository which already contains the necessary parent commits.</source>
          <target state="translated">默认情况下，运行诸如 &lt;code&gt;git fast-export master~5..master&lt;/code&gt; 将不包含commit master〜5，并且将使master〜4不再具有master〜5作为父级（尽管旧的master〜4和新的master〜4将具有相同的文件）。使用--reference-excluded-parents可以使流按其sha1sum引用历史记录排除范围内的提交。请注意，结果流只能由已经包含必要的父提交的存储库使用。</target>
        </trans-unit>
        <trans-unit id="d83beffd98b552e4707fcc4f203041336c446345" translate="yes" xml:space="preserve">
          <source>By default, shows the tags, heads, and remote refs.</source>
          <target state="translated">默认情况下,显示标签、头和远程参考。</target>
        </trans-unit>
        <trans-unit id="9534d3a85e2055ad7b75dcf81f0ec911d150730a" translate="yes" xml:space="preserve">
          <source>By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e. &lt;code&gt;medium&lt;/code&gt;, which is the default, &lt;code&gt;full&lt;/code&gt;, and &lt;code&gt;fuller&lt;/code&gt;).</source>
          <target state="translated">默认情况下，选项卡以漂亮的格式扩展，该格式将日志消息缩进4个空格（例如， &lt;code&gt;medium&lt;/code&gt; 是默认值， &lt;code&gt;full&lt;/code&gt; 和 &lt;code&gt;fuller&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f8c576d24c20a06a3fa3293a553efd1880bf67bd" translate="yes" xml:space="preserve">
          <source>By default, tags that point at objects that are downloaded from the remote repository are fetched and stored locally. This option disables this automatic tag following. The default behavior for a remote may be specified with the remote.&amp;lt;name&amp;gt;.tagOpt setting. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">默认情况下，指向并指向从远程存储库下载的对象的标记，并将其存储在本地。此选项禁用此自动标记跟随。可以使用remote。&amp;lt;name&amp;gt; .tagOpt设置指定远程的默认行为。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ffdb9a1efc1700312a38f928a2009acf370d9974" translate="yes" xml:space="preserve">
          <source>By default, the branches and their commits are shown in reverse chronological order. This option makes them appear in topological order (i.e., descendant commits are shown before their parents).</source>
          <target state="translated">默认情况下,分支和它们的提交是按时间倒序显示的。该选项使它们按拓扑顺序显示(即子代提交在父代提交之前显示)。</target>
        </trans-unit>
        <trans-unit id="7d6c7baaf0bf9e427c6cfd338efdec2fba7e7759" translate="yes" xml:space="preserve">
          <source>By default, the command outputs warning messages but applies the patch. When &lt;code&gt;git-apply&lt;/code&gt; is used for statistics and not applying a patch, it defaults to &lt;code&gt;nowarn&lt;/code&gt;.</source>
          <target state="translated">默认情况下，该命令输出警告消息，但会应用补丁程序。当 &lt;code&gt;git-apply&lt;/code&gt; 用于统计而不应用补丁时，默认为 &lt;code&gt;nowarn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a611e350871da16559e274274576dfaf4df893f3" translate="yes" xml:space="preserve">
          <source>By default, the command passes &lt;code&gt;--delta-base-offset&lt;/code&gt; option to &lt;code&gt;git pack-objects&lt;/code&gt;; this typically results in slightly smaller packs, but the generated packs are incompatible with versions of Git older than version 1.4.4. If you need to share your repository with such ancient Git versions, either directly or via the dumb http protocol, then you need to set the configuration variable &lt;code&gt;repack.UseDeltaBaseOffset&lt;/code&gt; to &quot;false&quot; and repack. Access from old Git versions over the native protocol is unaffected by this option as the conversion is performed on the fly as needed in that case.</source>
          <target state="translated">默认情况下，该命令将 &lt;code&gt;--delta-base-offset&lt;/code&gt; 选项传递给 &lt;code&gt;git pack-objects&lt;/code&gt; ；这通常会导致程序包略小，但是生成的程序包与早于1.4.4版本的Git版本不兼容。如果您需要直接或通过哑http协议与此类古老的Git版本共享存储库，则需要将配置变量 &lt;code&gt;repack.UseDeltaBaseOffset&lt;/code&gt; 设置为&amp;ldquo; false&amp;rdquo;并重新打包。通过本地协议从旧Git版本进行访问不受此选项的影响，因为在这种情况下，转换是根据需要动态进行的。</target>
        </trans-unit>
        <trans-unit id="4f861a2e54471285f5e27b71719f8d0cdb51509e" translate="yes" xml:space="preserve">
          <source>By default, the command shows the filename for each match. &lt;code&gt;-h&lt;/code&gt; option is used to suppress this output. &lt;code&gt;-H&lt;/code&gt; is there for completeness and does not do anything except it overrides &lt;code&gt;-h&lt;/code&gt; given earlier on the command line.</source>
          <target state="translated">默认情况下，该命令显示每个匹配项的文件名。 &lt;code&gt;-h&lt;/code&gt; 选项用于禁止输出。 &lt;code&gt;-H&lt;/code&gt; 用于完整性，除了覆盖命令行前面给出的 &lt;code&gt;-h&lt;/code&gt; 外，不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="13a9b6e24e13c9eb4f96f597a6a5cd1c71b0690a" translate="yes" xml:space="preserve">
          <source>By default, the commands above can be executed only with the &lt;code&gt;-c&lt;/code&gt; option; the shell is not interactive.</source>
          <target state="translated">缺省情况下，以上命令只能通过 &lt;code&gt;-c&lt;/code&gt; 选项执行。外壳不是交互式的。</target>
        </trans-unit>
        <trans-unit id="96284dfd9f407661b68729a78fcd24af10b360fa" translate="yes" xml:space="preserve">
          <source>By default, the commits are shown in reverse chronological order.</source>
          <target state="translated">默认情况下,提交的内容会按时间倒序显示。</target>
        </trans-unit>
        <trans-unit id="41e61e3f14f2f076835cbd248b96763ec755aaf1" translate="yes" xml:space="preserve">
          <source>By default, the configuration flag &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; is enabled in shared repositories, so that you cannot force a non fast-forwarding push into it.</source>
          <target state="translated">默认情况下，共享存储库中启用了配置标志 &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; ，因此您不能强制将非快速转发推送到其中。</target>
        </trans-unit>
        <trans-unit id="96f5a0af42c4430da235fb8eb151d52244069b6f" translate="yes" xml:space="preserve">
          <source>By default, the notes shown are from the notes refs listed in the &lt;code&gt;core.notesRef&lt;/code&gt; and &lt;code&gt;notes.displayRef&lt;/code&gt; variables (or corresponding environment overrides). See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for more details.</source>
          <target state="translated">默认情况下，显示的注释来自 &lt;code&gt;core.notesRef&lt;/code&gt; 和 &lt;code&gt;notes.displayRef&lt;/code&gt; 变量（或相应的环境替代）中列出的注释refs 。有关更多详细信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="720f82840fb154598c30c373c9317d22846223a4" translate="yes" xml:space="preserve">
          <source>By default, the output omits merges that are reachable from only one tip being shown. This option makes them visible.</source>
          <target state="translated">默认情况下,输出会省略那些只能从显示的一个提示中到达的合并。此选项使它们可见。</target>
        </trans-unit>
        <trans-unit id="5af8b38407e84c0cf68e927bffe60812fcb3c4e9" translate="yes" xml:space="preserve">
          <source>By default, the repository &quot;config&quot; file is shared across all working trees. If the config variables &lt;code&gt;core.bare&lt;/code&gt; or &lt;code&gt;core.worktree&lt;/code&gt; are already present in the config file, they will be applied to the main working trees only.</source>
          <target state="translated">默认情况下，存储库&amp;ldquo; config&amp;rdquo;文件在所有工作树之间共享。如果配置文件中已经存在配置变量 &lt;code&gt;core.bare&lt;/code&gt; 或 &lt;code&gt;core.worktree&lt;/code&gt; ，它们将仅应用于主要工作树。</target>
        </trans-unit>
        <trans-unit id="973434bf7e817a557d276186c33c139503bc7733" translate="yes" xml:space="preserve">
          <source>By default, the restore sources for working tree and the index are the index and &lt;code&gt;HEAD&lt;/code&gt; respectively. &lt;code&gt;--source&lt;/code&gt; could be used to specify a commit as the restore source.</source>
          <target state="translated">默认情况下，工作树和索引的还原源分别是索引和 &lt;code&gt;HEAD&lt;/code&gt; 。 &lt;code&gt;--source&lt;/code&gt; 可用于将提交指定为还原源。</target>
        </trans-unit>
        <trans-unit id="6198a2f3a4209e82ce868cd683f2d31abc69a314" translate="yes" xml:space="preserve">
          <source>By default, the sparse-checkout file uses the same syntax as &lt;code&gt;.gitignore&lt;/code&gt; files.</source>
          <target state="translated">默认情况下，稀疏签出文件使用与 &lt;code&gt;.gitignore&lt;/code&gt; 文件相同的语法。</target>
        </trans-unit>
        <trans-unit id="22a25d0b8a2e5ce87fbc59e939918c48f09b2958" translate="yes" xml:space="preserve">
          <source>By default, the subject of a single patch is &quot;[PATCH] &quot; followed by the concatenation of lines from the commit message up to the first blank line (see the DISCUSSION section of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;).</source>
          <target state="translated">默认情况下，单个补丁的主题是&amp;ldquo; [PATCH]&amp;rdquo;，然后是从提交消息到第一行空白的行连接（请参阅&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;的DISCUSSION部分）。</target>
        </trans-unit>
        <trans-unit id="9704a5c766445678507f7af7f587edd379d84cf0" translate="yes" xml:space="preserve">
          <source>By default, this uses the same built-in 3-way merge driver as is the case when the &lt;code&gt;merge&lt;/code&gt; attribute is set. However, the &lt;code&gt;merge.default&lt;/code&gt; configuration variable can name different merge driver to be used with paths for which the &lt;code&gt;merge&lt;/code&gt; attribute is unspecified.</source>
          <target state="translated">默认情况下，它使用与设置 &lt;code&gt;merge&lt;/code&gt; 属性时相同的内置3向合并驱动程序。但是， &lt;code&gt;merge.default&lt;/code&gt; 配置变量可以命名要用于未指定 &lt;code&gt;merge&lt;/code&gt; 属性的路径的其他合并驱动程序。</target>
        </trans-unit>
        <trans-unit id="fb719865937ac64c446567c5ed40eaa328116bc6" translate="yes" xml:space="preserve">
          <source>By default, this will return your tree to the commit that was checked out before &lt;code&gt;git bisect start&lt;/code&gt;. (A new &lt;code&gt;git bisect start&lt;/code&gt; will also do that, as it cleans up the old bisection state.)</source>
          <target state="translated">默认情况下，这会将您的树返回到 &lt;code&gt;git bisect start&lt;/code&gt; 之前签出的提交。（新的 &lt;code&gt;git bisect start&lt;/code&gt; 也可以做到这一点，因为它可以清理旧的二等分状态。）</target>
        </trans-unit>
        <trans-unit id="d0131180d6acb72b151d5763656b5ee5ec67d9f6" translate="yes" xml:space="preserve">
          <source>By default, tracked files are not shown at all since they are not subject to exclude rules; but see &amp;lsquo;--no-index&amp;rsquo;.</source>
          <target state="translated">默认情况下，跟踪文件完全不显示，因为它们不受排除规则的约束。但请参阅&amp;ldquo; --no-index&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="055c65bfcac14882dd3e00e849a98c92a82c1b80" translate="yes" xml:space="preserve">
          <source>By default, when a file &lt;code&gt;path&lt;/code&gt; exists in the index, &lt;code&gt;git update-index&lt;/code&gt; refuses an attempt to add &lt;code&gt;path/file&lt;/code&gt;. Similarly if a file &lt;code&gt;path/file&lt;/code&gt; exists, a file &lt;code&gt;path&lt;/code&gt; cannot be added. With --replace flag, existing entries that conflict with the entry being added are automatically removed with warning messages.</source>
          <target state="translated">默认情况下，当索引中存在文件 &lt;code&gt;path&lt;/code&gt; 时， &lt;code&gt;git update-index&lt;/code&gt; 拒绝尝试添加 &lt;code&gt;path/file&lt;/code&gt; 。同样，如果存在文件 &lt;code&gt;path/file&lt;/code&gt; ，则无法添加文件 &lt;code&gt;path&lt;/code&gt; 。使用--replace标志，将与警告消息一起自动删除与要添加的条目冲突的现有条目。</target>
        </trans-unit>
        <trans-unit id="299147d01326bdbf4534148e9d9d3fd6c07e2d71" translate="yes" xml:space="preserve">
          <source>By default, when running &lt;code&gt;git sparse-checkout init&lt;/code&gt;, the root directory is added as a parent pattern. At this point, the sparse-checkout file contains the following patterns:</source>
          <target state="translated">默认情况下，运行 &lt;code&gt;git sparse-checkout init&lt;/code&gt; 时，会将根目录添加为父模式。此时，稀疏签出文件包含以下模式：</target>
        </trans-unit>
        <trans-unit id="93102cd6e4e7e1fd617df0a6116a6e8dabe44d67" translate="yes" xml:space="preserve">
          <source>By design, Git treats data trusted to it with caution. However, even in the absence of bugs in Git itself, it is still possible that hardware or operating system errors could corrupt data.</source>
          <target state="translated">根据设计,Git会谨慎对待信任的数据。然而,即使Git本身没有错误,硬件或操作系统的错误仍有可能破坏数据。</target>
        </trans-unit>
        <trans-unit id="0405b4cdacdc12c8e141d09b19a221661400dcb6" translate="yes" xml:space="preserve">
          <source>By examining &lt;code&gt;t/.gitattributes&lt;/code&gt; (which is in the same directory as the path in question), Git finds that the first line matches. &lt;code&gt;merge&lt;/code&gt; attribute is set. It also finds that the second line matches, and attributes &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; are unset.</source>
          <target state="translated">通过检查 &lt;code&gt;t/.gitattributes&lt;/code&gt; （与所讨论的路径位于同一目录中），Git发现第一行匹配。设置 &lt;code&gt;merge&lt;/code&gt; 属性。它还发现第二行匹配，并且属性 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;bar&lt;/code&gt; 未设置。</target>
        </trans-unit>
        <trans-unit id="6019b6edc3f8183a9650b814f1e96d2397d6c92e" translate="yes" xml:space="preserve">
          <source>By now, you know what the index is (and find the corresponding data structures in &lt;code&gt;cache.h&lt;/code&gt;), and that there are just a couple of object types (blobs, trees, commits and tags) which inherit their common structure from &lt;code&gt;struct object&lt;/code&gt;, which is their first member (and thus, you can cast e.g. &lt;code&gt;(struct object *)commit&lt;/code&gt; to achieve the &lt;code&gt;same&lt;/code&gt; as &lt;code&gt;&amp;amp;commit&amp;rarr;object&lt;/code&gt;, i.e. get at the object name and flags).</source>
          <target state="translated">到目前为止，您已经知道索引是什么（并在 &lt;code&gt;cache.h&lt;/code&gt; 中找到相应的数据结构），并且只有两种对象类型（blob，tree，commit和tag）从 &lt;code&gt;struct object&lt;/code&gt; 继承了它们的通用结构，这是他们的第一个成员（因此，你可以投如 &lt;code&gt;(struct object *)commit&lt;/code&gt; 以达到 &lt;code&gt;same&lt;/code&gt; 的 &lt;code&gt;&amp;amp;commit&amp;rarr;object&lt;/code&gt; ，即在对象的名称和标志得到）。</target>
        </trans-unit>
        <trans-unit id="7fc0a0343ad2fdcba9cb4eccfe4e06a4bbef7383" translate="yes" xml:space="preserve">
          <source>By replacing the command &quot;pick&quot; with the command &quot;edit&quot;, you can tell &lt;code&gt;git rebase&lt;/code&gt; to stop after applying that commit, so that you can edit the files and/or the commit message, amend the commit, and continue rebasing.</source>
          <target state="translated">通过使用命令&amp;ldquo; edit&amp;rdquo;替换命令&amp;ldquo; pick&amp;rdquo;，您可以告诉 &lt;code&gt;git rebase&lt;/code&gt; 在应用该提交后停止，以便您可以编辑文件和/或提交消息，修改提交，并继续进行基础调整。</target>
        </trans-unit>
        <trans-unit id="38723ef3d6552eb371410d9afcccdbb440b0f54e" translate="yes" xml:space="preserve">
          <source>By setting this variable to a string, &lt;code&gt;git receive-pack&lt;/code&gt; will accept a &lt;code&gt;git push --signed&lt;/code&gt; and verifies it by using a &quot;nonce&quot; protected by HMAC using this string as a secret key.</source>
          <target state="translated">通过将此变量设置为字符串， &lt;code&gt;git receive-pack&lt;/code&gt; 将接受 &lt;code&gt;git push --signed&lt;/code&gt; 并通过使用受此字符串作为密钥的，受HMAC保护的&amp;ldquo; nonce&amp;rdquo;进行验证。</target>
        </trans-unit>
        <trans-unit id="b0ec84a28e8863d61bfe49155bbc56f1b080a18a" translate="yes" xml:space="preserve">
          <source>By specifying &lt;code&gt;base&lt;/code&gt; as the limit, you can avoid listing commits between &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;topic&lt;/code&gt;:</source>
          <target state="translated">通过将 &lt;code&gt;base&lt;/code&gt; 指定为限制，可以避免列出 &lt;code&gt;base&lt;/code&gt; 和 &lt;code&gt;topic&lt;/code&gt; 之间的提交：</target>
        </trans-unit>
        <trans-unit id="bac0dcb4a691d6bbb7adf78bc3225e969e991ed2" translate="yes" xml:space="preserve">
          <source>By specifying a single suffix in this variable, any tagname containing that suffix will appear before the corresponding main release. E.g. if the variable is set to &quot;-rc&quot;, then all &quot;1.0-rcX&quot; tags will appear before &quot;1.0&quot;. If specified multiple times, once per suffix, then the order of suffixes in the configuration will determine the sorting order of tagnames with those suffixes. E.g. if &quot;-pre&quot; appears before &quot;-rc&quot; in the configuration, then all &quot;1.0-preX&quot; tags will be listed before any &quot;1.0-rcX&quot; tags. The placement of the main release tag relative to tags with various suffixes can be determined by specifying the empty suffix among those other suffixes. E.g. if the suffixes &quot;-rc&quot;, &quot;&quot;, &quot;-ck&quot; and &quot;-bfs&quot; appear in the configuration in this order, then all &quot;v4.8-rcX&quot; tags are listed first, followed by &quot;v4.8&quot;, then &quot;v4.8-ckX&quot; and finally &quot;v4.8-bfsX&quot;.</source>
          <target state="translated">通过在此变量中指定一个后缀,任何包含该后缀的 tagname 都会出现在相应的主版本之前,例如,如果将该变量设置为&quot;-rc&quot;,那么所有 &quot;1.0-rcX &quot;标签都会出现在 &quot;1.0 &quot;之前。例如,如果将该变量设置为&quot;-rc&quot;,那么所有 &quot;1.0-rcX &quot;标记将出现在 &quot;1.0 &quot;之前。如果多次指定,每个后缀指定一次,那么配置中后缀的顺序将决定带有这些后缀的 tagnames 的排序顺序。例如,如果配置中&quot;-pre &quot;出现在&quot;-rc &quot;之前,那么所有 &quot;1.0-preX &quot;标记将列在任何 &quot;1.0-rcX &quot;标记之前。主发布标签相对于具有各种后缀的标签的位置,可以通过指定这些其他后缀中的空后缀来确定。例如,如果后缀&quot;-rc&quot;、&quot;&quot;、&quot;-ck &quot;和&quot;-bfs &quot;按此顺序出现在配置中,那么所有 &quot;v4.8-rcX &quot;标记将首先列出,然后是 &quot;v4.8&quot;,然后是 &quot;v4.8-ckX&quot;,最后是 &quot;v4.8-bfsX&quot;。</target>
        </trans-unit>
        <trans-unit id="73d10606466530ea834324e2af3cd4f5fdf3b7ef" translate="yes" xml:space="preserve">
          <source>By using &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; arguments, e.g., path limiters, you can limit the set of revisions which get rewritten. However, positive refs on the command line are distinguished: we don&amp;rsquo;t let them be excluded by such limiters. For this purpose, they are instead rewritten to point at the nearest ancestor that was not excluded.</source>
          <target state="translated">通过使用&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;参数，例如路径限制器，您可以限制要重写的修订版本集。但是，命令行上的正引用是有区别的：我们不允许这些限制器排除它们。为此，它们被重写为指向未被排除的最接近的祖先。</target>
        </trans-unit>
        <trans-unit id="2fbc7b3eb43b76b2746e664c28cb9ad054eb9a86" translate="yes" xml:space="preserve">
          <source>Bypass the post-rewrite hook.</source>
          <target state="translated">绕过改写后的钩子。</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="2b7976aa8c8ee62577557b0faf6cd45c7d87d599" translate="yes" xml:space="preserve">
          <source>C: copy of a file into a new one</source>
          <target state="translated">C:将一个文件复制到一个新的文件中。</target>
        </trans-unit>
        <trans-unit id="8cb2e80198d1a22ece7b2150ad287e7b39ba33cd" translate="yes" xml:space="preserve">
          <source>CHUNK DATA:</source>
          <target state="translated">CHUNK数据。</target>
        </trans-unit>
        <trans-unit id="9da2b59eccc71e5c2791bd9f721e6de7f9e4a527" translate="yes" xml:space="preserve">
          <source>CHUNK LOOKUP:</source>
          <target state="translated">CHUNK LOOKUP。</target>
        </trans-unit>
        <trans-unit id="025c408a5504f0e808d096b14c696e6a19ee3cbf" translate="yes" xml:space="preserve">
          <source>CONTENT_TYPE</source>
          <target state="translated">CONTENT_TYPE</target>
        </trans-unit>
        <trans-unit id="45649b220c5ae097eced7a136897aeb49a47599c" translate="yes" xml:space="preserve">
          <source>CRLF Line Ending Conversions</source>
          <target state="translated">CRLF线端转换</target>
        </trans-unit>
        <trans-unit id="4d982ea44c2ace64324fd7fbacbc4c4d91f3e200" translate="yes" xml:space="preserve">
          <source>CRLF conversion bears a slight chance of corrupting data. When it is enabled, Git will convert CRLF to LF during commit and LF to CRLF during checkout. A file that contains a mixture of LF and CRLF before the commit cannot be recreated by Git. For text files this is the right thing to do: it corrects line endings such that we have only LF line endings in the repository. But for binary files that are accidentally classified as text the conversion can corrupt data.</source>
          <target state="translated">CRLF转换有轻微的破坏数据的可能性。启用该功能后,Git 会在提交时将 CRLF 转换为 LF,在签出时将 LF 转换为 CRLF。提交前包含LF和CRLF混合的文件不能被Git重新创建。对于文本文件来说,这样做是正确的:它纠正了行尾,使我们在版本库中只有LF行尾。但对于不小心被归类为文本的二进制文件,转换会破坏数据。</target>
        </trans-unit>
        <trans-unit id="b2dadeb076c332a230cd3f419ccce73fc473e9b1" translate="yes" xml:space="preserve">
          <source>CVS 1.11.17 on MacOSX (from Fink package)</source>
          <target state="translated">MacOSX上的CVS 1.11.17 (来自Fink包)</target>
        </trans-unit>
        <trans-unit id="31ba0d2766dea7911d9b0133542d1dae7c40d21b" translate="yes" xml:space="preserve">
          <source>CVS 1.12.9 on Debian</source>
          <target state="translated">CVS 1.12.9 在 Debian 上</target>
        </trans-unit>
        <trans-unit id="c10230da83b7ef151899f83d727ffc465e699ce7" translate="yes" xml:space="preserve">
          <source>CVS by default uses the Unix username when writing its commit logs. Using this option and an author-conv-file maps the name recorded in CVS to author name, e-mail and optional time zone:</source>
          <target state="translated">CVS 在写提交日志时默认使用 Unix 用户名。使用这个选项和author-conv-file可以将CVS中记录的名字映射为作者名、电子邮件和可选的时区。</target>
        </trans-unit>
        <trans-unit id="edcdc296b2872a295927e706b64b0873d75bd7e8" translate="yes" xml:space="preserve">
          <source>CVS clients cannot tag, branch or perform Git merges.</source>
          <target state="translated">CVS 客户端不能标记、分支或执行 Git 合并。</target>
        </trans-unit>
        <trans-unit id="98b46c65d5bf63821f6ce6bd595bdc32473d951c" translate="yes" xml:space="preserve">
          <source>CVS module/Git head name</source>
          <target state="translated">CVS模块/Git头名称</target>
        </trans-unit>
        <trans-unit id="49adb1e8c5b17953ca229c40061a8d1bb5bb8b5e" translate="yes" xml:space="preserve">
          <source>CVS users are accustomed to giving a group of developers commit access to a common repository. As we&amp;rsquo;ve seen, this is also possible with Git. However, the distributed nature of Git allows other development models, and you may want to first consider whether one of them might be a better fit for your project.</source>
          <target state="translated">CVS用户习惯于给一组开发人员提交对公共存储库的访问权限。如我们所见，Git也可以做到这一点。但是，Git的分布式特性允许其他开发模型，您可能首先要考虑其中一种是否更适合您的项目。</target>
        </trans-unit>
        <trans-unit id="aed153eb92fac6b914dbc191a216beb300201f66" translate="yes" xml:space="preserve">
          <source>CVS-style shared repository.</source>
          <target state="translated">CVS风格的共享存储库。</target>
        </trans-unit>
        <trans-unit id="f52ad32f29f6847c4f98f4be5fc01986743d4aae" translate="yes" xml:space="preserve">
          <source>Cache credentials in memory for a short period of time. See &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache[1]&lt;/a&gt; for details.</source>
          <target state="translated">在短时间内将凭据缓存在内存中。有关详细信息，请参见&lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68d01495331ef3ec55abb430492aa431fb98900b" translate="yes" xml:space="preserve">
          <source>Cached mode</source>
          <target state="translated">缓存模式</target>
        </trans-unit>
        <trans-unit id="bc41c881675379eb55dc52ac754cd0a47e293c0b" translate="yes" xml:space="preserve">
          <source>Caching. Textconv caching can speed up repeated diffs, such as those you might trigger by running &lt;code&gt;git log -p&lt;/code&gt;.</source>
          <target state="translated">正在缓存。Textconv缓存可以加快重复的差异，例如运行 &lt;code&gt;git log -p&lt;/code&gt; 可能触发的差异。</target>
        </trans-unit>
        <trans-unit id="b3bd71fe43527e264035373707bb05e34bacabd4" translate="yes" xml:space="preserve">
          <source>Call the corresponding server-side command to support the client&amp;rsquo;s &lt;code&gt;git push&lt;/code&gt;, &lt;code&gt;git fetch&lt;/code&gt;, or &lt;code&gt;git archive --remote&lt;/code&gt; request.</source>
          <target state="translated">调用相应的服务器端命令以支持客户端的 &lt;code&gt;git push&lt;/code&gt; ， &lt;code&gt;git fetch&lt;/code&gt; 或 &lt;code&gt;git archive --remote&lt;/code&gt; 请求。</target>
        </trans-unit>
        <trans-unit id="3907fb8eaa84bdb8f3cc45ad006023c90615ad1f" translate="yes" xml:space="preserve">
          <source>Can attempt to connect to &lt;code&gt;git receive-pack&lt;/code&gt; (for pushing), &lt;code&gt;git upload-pack&lt;/code&gt;, etc for communication using git&amp;rsquo;s native packfile protocol. This requires a bidirectional, full-duplex connection.</source>
          <target state="translated">可以尝试使用git的本地packfile协议连接到 &lt;code&gt;git receive-pack&lt;/code&gt; （用于推送）， &lt;code&gt;git upload-pack&lt;/code&gt; 等进行通信。这需要双向全双工连接。</target>
        </trans-unit>
        <trans-unit id="0c6fd80a7557d1e5d2aaff98df3b675a4f3e3e9e" translate="yes" xml:space="preserve">
          <source>Can be overridden by the &lt;code&gt;GIT_PROXY_COMMAND&lt;/code&gt; environment variable (which always applies universally, without the special &quot;for&quot; handling).</source>
          <target state="translated">可以被 &lt;code&gt;GIT_PROXY_COMMAND&lt;/code&gt; 环境变量覆盖（该变量始终通用，没有特殊的&amp;ldquo; for&amp;rdquo;处理）。</target>
        </trans-unit>
        <trans-unit id="0f39962decf24e67df63f769ebf7a91027019ae1" translate="yes" xml:space="preserve">
          <source>Can be overridden by the &lt;code&gt;GIT_SSL_CIPHER_LIST&lt;/code&gt; environment variable. To force git to use libcurl&amp;rsquo;s default cipher list and ignore any explicit http.sslCipherList option, set &lt;code&gt;GIT_SSL_CIPHER_LIST&lt;/code&gt; to the empty string.</source>
          <target state="translated">可以被 &lt;code&gt;GIT_SSL_CIPHER_LIST&lt;/code&gt; 环境变量覆盖。要强制git使用libcurl的默认密码列表并忽略任何显式的http.sslCipherList选项，请将 &lt;code&gt;GIT_SSL_CIPHER_LIST&lt;/code&gt; 设置为空字符串。</target>
        </trans-unit>
        <trans-unit id="29d57ff400cc012cacf16bd510a83a1f80c69dcf" translate="yes" xml:space="preserve">
          <source>Can be overridden by the &lt;code&gt;GIT_SSL_VERSION&lt;/code&gt; environment variable. To force git to use libcurl&amp;rsquo;s default ssl version and ignore any explicit http.sslversion option, set &lt;code&gt;GIT_SSL_VERSION&lt;/code&gt; to the empty string.</source>
          <target state="translated">可以被 &lt;code&gt;GIT_SSL_VERSION&lt;/code&gt; 环境变量覆盖。要强制git使用libcurl的默认ssl版本并忽略任何显式的http.sslversion选项，请将 &lt;code&gt;GIT_SSL_VERSION&lt;/code&gt; 设置为空字符串。</target>
        </trans-unit>
        <trans-unit id="8710d5603018e270e9135bc9b07e18583e6e40b7" translate="yes" xml:space="preserve">
          <source>Can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable.</source>
          <target state="translated">可以用 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="f3ab6f60ab10fc57456b8912494e28284fd290bc" translate="yes" xml:space="preserve">
          <source>Can be set using the &lt;code&gt;GITWEB_SITENAME&lt;/code&gt; at build time. Unset by default.</source>
          <target state="translated">可以在构建时使用 &lt;code&gt;GITWEB_SITENAME&lt;/code&gt; 进行设置。默认情况下未设置。</target>
        </trans-unit>
        <trans-unit id="217827b02c2eeb06477e279b6b6efc5d7d10ed39" translate="yes" xml:space="preserve">
          <source>Can be used in conjunction with &lt;code&gt;--single-branch&lt;/code&gt; to clone and maintain a branch with no references other than a single cloned branch. This is useful e.g. to maintain minimal clones of the default branch of some repository for search indexing.</source>
          <target state="translated">可以与 &lt;code&gt;--single-branch&lt;/code&gt; 一起使用，以克隆和维护除单个克隆分支之外没有其他引用的分支。例如，这对于维护某些存储库的默认分支的最小克隆以进行搜索索引很有用。</target>
        </trans-unit>
        <trans-unit id="a9691ee782e933498eb75769eeec906fc37e3a47" translate="yes" xml:space="preserve">
          <source>Can discover remote refs and output objects reachable from them as a stream in fast-import format.</source>
          <target state="translated">可以发现远程的参考文献,并以快速导入格式的流的形式输出可从它们到达的对象。</target>
        </trans-unit>
        <trans-unit id="90035edf92bee77fbf7fe329bbc961839dc96080" translate="yes" xml:space="preserve">
          <source>Can discover remote refs and push local commits and the history leading up to them to new or existing remote refs.</source>
          <target state="translated">可以发现远程参考,并将本地提交和导致它们的历史推送给新的或现有的远程参考。</target>
        </trans-unit>
        <trans-unit id="138c5e6b546882127de4e82d6394ea6b4a6a09ca" translate="yes" xml:space="preserve">
          <source>Can discover remote refs and push specified objects from a fast-import stream to remote refs.</source>
          <target state="translated">可以发现远程参照物,并从快速导入流中推送指定对象到远程参照物。</target>
        </trans-unit>
        <trans-unit id="b4530b46452bf0ddccff90b10194b6dc8dee0aff" translate="yes" xml:space="preserve">
          <source>Can discover remote refs and transfer objects reachable from them to the local object store.</source>
          <target state="translated">可以发现远程参照物,并将其可到达的对象转移到本地对象存储中。</target>
        </trans-unit>
        <trans-unit id="7decaa19c2a5956f9383448e881b3336964a5bef" translate="yes" xml:space="preserve">
          <source>Can guarantee that when a clone is requested, the received pack is self contained and is connected.</source>
          <target state="translated">能保证在请求克隆的时候,收到的包是自带的,并且是连接的。</target>
        </trans-unit>
        <trans-unit id="b7ebace43478348d6004d061ea665f140df1bb53" translate="yes" xml:space="preserve">
          <source>Can try to connect to &lt;code&gt;git upload-pack&lt;/code&gt; (for fetching), &lt;code&gt;git receive-pack&lt;/code&gt;, etc for communication using the Git&amp;rsquo;s native packfile protocol. This requires a bidirectional, full-duplex connection.</source>
          <target state="translated">可以尝试使用Git的本地packfile协议连接到 &lt;code&gt;git upload-pack&lt;/code&gt; （用于获取）， &lt;code&gt;git receive-pack&lt;/code&gt; 等进行通信。这需要双向全双工连接。</target>
        </trans-unit>
        <trans-unit id="4cb14361f0a5ad881a24c94d8c006e5f643d8a87" translate="yes" xml:space="preserve">
          <source>Cancel the operation and return to the pre-sequence state.</source>
          <target state="translated">取消操作,回到序列前状态。</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="20243c460d0e899aa2ea919e5a33ddf3fc3c28ee" translate="yes" xml:space="preserve">
          <source>Capabilities for Fetching</source>
          <target state="translated">获取能力</target>
        </trans-unit>
        <trans-unit id="2cf429aa6c517aac8e25fa8619402627623a5d1f" translate="yes" xml:space="preserve">
          <source>Capabilities for Pushing</source>
          <target state="translated">推进能力</target>
        </trans-unit>
        <trans-unit id="a02cd245f4a5359f48f45e974d4d2aeb3f737ec2" translate="yes" xml:space="preserve">
          <source>Capability advertisement</source>
          <target state="translated">能力广告</target>
        </trans-unit>
        <trans-unit id="fbb741f1d3fe925738bd52e124aa5bcdfaec72b5" translate="yes" xml:space="preserve">
          <source>Case 3 is slightly tricky and needs explanation. The result from this rule logically should be to remove the path if the user staged the removal of the path and then switching to a new branch. That however will prevent the initial checkout from happening, so the rule is modified to use M (new tree) only when the content of the index is empty. Otherwise the removal of the path is kept as long as $H and $M are the same.</source>
          <target state="translated">情况3稍微有点棘手,需要解释一下。从这个规则的逻辑上看,如果用户阶段性的删除路径,然后切换到新的分支,那么结果应该是删除路径。然而这样会阻止初始签出的发生,所以规则修改为只有当索引内容为空时才使用M(新树)。否则只要$H和$M相同,就会保留删除路径。</target>
        </trans-unit>
        <trans-unit id="e09c27f67e4fbebb877a3f28eee7f79c8bd9d162" translate="yes" xml:space="preserve">
          <source>Case insensitive match.</source>
          <target state="translated">不区分大小写的匹配。</target>
        </trans-unit>
        <trans-unit id="3ba6868684fb15f285ba371e8f8692f5e6c1b769" translate="yes" xml:space="preserve">
          <source>Cause the logical variables to be listed. In addition, all the variables of the Git configuration file .git/config are listed as well. (However, the configuration variables listing functionality is deprecated in favor of &lt;code&gt;git config -l&lt;/code&gt;.)</source>
          <target state="translated">使逻辑变量被列出。此外，还列出了Git配置文件.git / config的所有变量。（但是，不推荐使用配置变量列出功能，而推荐使用 &lt;code&gt;git config -l&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="b783ff5188b18ab4ca3191c5116581bc5ecb01a2" translate="yes" xml:space="preserve">
          <source>Causes fast-import to echo the entire line to its own standard output. This command is optional and is not needed to perform an import.</source>
          <target state="translated">使 fast-import 将整个行呼应到它自己的标准输出。这个命令是可选的,在执行导入时不需要。</target>
        </trans-unit>
        <trans-unit id="12b02e08644454fc1547d338b5de4943ef66f77b" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print a blob in &lt;code&gt;cat-file --batch&lt;/code&gt; format to the file descriptor set with &lt;code&gt;--cat-blob-fd&lt;/code&gt; or &lt;code&gt;stdout&lt;/code&gt; if unspecified.</source>
          <target state="translated">导致快速导入将 &lt;code&gt;cat-file --batch&lt;/code&gt; 格式的blob打印到使用 &lt;code&gt;--cat-blob-fd&lt;/code&gt; 或 &lt;code&gt;stdout&lt;/code&gt; (如果未指定）设置的文件描述符。</target>
        </trans-unit>
        <trans-unit id="b8e75699b5276c39faaefd045a6a5b904b73ada6" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print a blob to a file descriptor previously arranged with the &lt;code&gt;--cat-blob-fd&lt;/code&gt; argument. The command otherwise has no impact on the current import; its main purpose is to retrieve blobs that may be in fast-import&amp;rsquo;s memory but not accessible from the target repository.</source>
          <target state="translated">使快速导入将blob打印到先前使用 &lt;code&gt;--cat-blob-fd&lt;/code&gt; 参数排列的文件描述符。否则，该命令不会对当前导入产生任何影响。其主要目的是检索可能在快速导入的内存中但无法从目标存储库访问的blob。</target>
        </trans-unit>
        <trans-unit id="7ec5756843c97a7c2f1df63914ede6a2099f489a" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print a line describing a directory entry in &lt;code&gt;ls-tree&lt;/code&gt; format to the file descriptor set with &lt;code&gt;--cat-blob-fd&lt;/code&gt; or &lt;code&gt;stdout&lt;/code&gt; if unspecified.</source>
          <target state="translated">导致快速导入将以 &lt;code&gt;ls-tree&lt;/code&gt; 格式描述目录条目的行打印到使用 &lt;code&gt;--cat-blob-fd&lt;/code&gt; 或 &lt;code&gt;stdout&lt;/code&gt; (如果未指定）设置的文件描述符。</target>
        </trans-unit>
        <trans-unit id="886958bd2ea3f9b4ef6490b2b36e023c05b21b29" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print the SHA-1 corresponding to a mark to stdout or to the file descriptor previously arranged with the &lt;code&gt;--cat-blob-fd&lt;/code&gt; argument. The command otherwise has no impact on the current import; its purpose is to retrieve SHA-1s that later commits might want to refer to in their commit messages.</source>
          <target state="translated">使快速导入打印与标准输出标记或先前使用 &lt;code&gt;--cat-blob-fd&lt;/code&gt; 参数排列的文件描述符相对应的SHA-1 。否则，该命令不会对当前导入产生任何影响。其目的是检索SHA-1，以后的提交可能要在其提交消息中引用它们。</target>
        </trans-unit>
        <trans-unit id="a62399ea6471f58f0ac3e20d903be4ac533d6d4e" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print the SHA-1 corresponding to a mark to the file descriptor set with &lt;code&gt;--cat-blob-fd&lt;/code&gt;, or &lt;code&gt;stdout&lt;/code&gt; if unspecified.</source>
          <target state="translated">使快速导入将与标记相对应的SHA-1打印到使用 &lt;code&gt;--cat-blob-fd&lt;/code&gt; 或 &lt;code&gt;stdout&lt;/code&gt; (如果未指定）设置的文件描述符。</target>
        </trans-unit>
        <trans-unit id="b482598ddd71627c6a7b2ff32a0b59803f8fd34f" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print the entire &lt;code&gt;progress&lt;/code&gt; line unmodified to its standard output channel (file descriptor 1) when the command is processed from the input stream. The command otherwise has no impact on the current import, or on any of fast-import&amp;rsquo;s internal state.</source>
          <target state="translated">从输入流处理命令时，使快速导入将未经修改的整个 &lt;code&gt;progress&lt;/code&gt; 行打印到其标准输出通道（文件描述符1）。否则，该命令对当前导入或快速导入的任何内部状态都没有影响。</target>
        </trans-unit>
        <trans-unit id="55a89527100d7affacb785a535913eceec75eda6" translate="yes" xml:space="preserve">
          <source>Caution</source>
          <target state="translated">Caution</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="62c56e9140b73b971227c6e095597a6888ab6f0b" translate="yes" xml:space="preserve">
          <source>Certain operations by Git can be influenced by assigning particular attributes to a path. Currently, the following operations are attributes-aware.</source>
          <target state="translated">Git 的某些操作可以通过给路径分配特定的属性来影响。目前,以下操作都是属性感知的。</target>
        </trans-unit>
        <trans-unit id="ce89ebfc7c6f30e38c61f750189a14aac995df3f" translate="yes" xml:space="preserve">
          <source>Change daemon&amp;rsquo;s uid and gid before entering the service loop. When only &lt;code&gt;--user&lt;/code&gt; is given without &lt;code&gt;--group&lt;/code&gt;, the primary group ID for the user is used. The values of the option are given to &lt;code&gt;getpwnam(3)&lt;/code&gt; and &lt;code&gt;getgrnam(3)&lt;/code&gt; and numeric IDs are not supported.</source>
          <target state="translated">进入服务循环之前，请更改守护程序的uid和gid。如果仅给出 &lt;code&gt;--user&lt;/code&gt; 而不给出 &lt;code&gt;--group&lt;/code&gt; ，则使用该用户的主要组ID。该选项的值分别提供给 &lt;code&gt;getpwnam(3)&lt;/code&gt; 和 &lt;code&gt;getgrnam(3)&lt;/code&gt; ,并且不支持数字ID。</target>
        </trans-unit>
        <trans-unit id="f8d5e6dcdbe26b10de586e21b98816e7aa3c05a4" translate="yes" xml:space="preserve">
          <source>Change output color. Followed by &lt;code&gt;:&amp;lt;colorname&amp;gt;&lt;/code&gt;, where color names are described under Values in the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. For example, &lt;code&gt;%(color:bold red)&lt;/code&gt;.</source>
          <target state="translated">更改输出颜色。后跟 &lt;code&gt;:&amp;lt;colorname&amp;gt;&lt;/code&gt; ，其中颜色名称在&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;的&amp;ldquo; CONFIGURATION FILE&amp;rdquo;部分的&amp;ldquo; Values&amp;rdquo;下描述。例如， &lt;code&gt;%(color:bold red)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e718f5f36cc4b622f94d06a68422a543373288f" translate="yes" xml:space="preserve">
          <source>Changed Tracked Entries</source>
          <target state="translated">已更改的跟踪条目</target>
        </trans-unit>
        <trans-unit id="a838ac0a12d74a72136f3630d86af0c9b1c990e6" translate="yes" xml:space="preserve">
          <source>Changes URLs for the remote. Sets first URL for remote &amp;lt;name&amp;gt; that matches regex &amp;lt;oldurl&amp;gt; (first URL if no &amp;lt;oldurl&amp;gt; is given) to &amp;lt;newurl&amp;gt;. If &amp;lt;oldurl&amp;gt; doesn&amp;rsquo;t match any URL, an error occurs and nothing is changed.</source>
          <target state="translated">更改遥控器的URL。将与正则表达式&amp;lt;oldurl&amp;gt;匹配的远程&amp;lt;name&amp;gt;的第一个URL（如果没有给出&amp;lt;oldurl&amp;gt;的话，则设置第一个URL）为&amp;lt;newurl&amp;gt;。如果&amp;lt;oldurl&amp;gt;与任何URL不匹配，则将发生错误，并且不会进行任何更改。</target>
        </trans-unit>
        <trans-unit id="5f81b14c458a3f96e356b0db1d9a8184d3aa46df" translate="yes" xml:space="preserve">
          <source>Changes between the index and your last commit; what you would be committing if you run &quot;git commit&quot; without &quot;-a&quot; option.</source>
          <target state="translated">索引和上次提交之间的变化;如果你运行 &quot;git commit &quot;而不使用&quot;-a &quot;选项,你将提交的内容。</target>
        </trans-unit>
        <trans-unit id="c2b554b2b0f0318db4bfdd8caad455aa5f11a835" translate="yes" xml:space="preserve">
          <source>Changes between the tips of the topic and the master branches.</source>
          <target state="translated">题的提示和主枝之间的变化。</target>
        </trans-unit>
        <trans-unit id="bb16f58635d0a49bf7d13f03eb1b1023bc073b68" translate="yes" xml:space="preserve">
          <source>Changes in the working tree not yet staged for the next commit.</source>
          <target state="translated">工作树上的变化还没有到下一次提交的阶段。</target>
        </trans-unit>
        <trans-unit id="7ac9e8718cf2c5d1390484c758626a70c63f62f2" translate="yes" xml:space="preserve">
          <source>Changes in the working tree since your last commit; what you would be committing if you run &quot;git commit -a&quot;</source>
          <target state="translated">自上次提交以来工作树上的变化;如果运行 &quot;git commit -a&quot;,你将会提交什么?</target>
        </trans-unit>
        <trans-unit id="959e8030a92b92d7979097ada92148067be55d31" translate="yes" xml:space="preserve">
          <source>Changes that occurred on the master branch since when the topic branch was started off it.</source>
          <target state="translated">自主题分支开始后,主分支上发生的变化。</target>
        </trans-unit>
        <trans-unit id="dcc9e0a603da36a49c01908e321b093eae90c8fa" translate="yes" xml:space="preserve">
          <source>Changes the list of branches tracked by the named remote. This can be used to track a subset of the available remote branches after the initial setup for a remote.</source>
          <target state="translated">更改被命名的远程服务器所跟踪的分支列表。这可以用来在初始化远程设置后追踪可用的远程分支的子集。</target>
        </trans-unit>
        <trans-unit id="0bccb8c649445d0e9e5ceb6a829109a7f170728f" translate="yes" xml:space="preserve">
          <source>Changes the verbosity of messages displayed by the helper. A value of 0 for &amp;lt;n&amp;gt; means that processes operate quietly, and the helper produces only error output. 1 is the default level of verbosity, and higher values of &amp;lt;n&amp;gt; correspond to the number of -v flags passed on the command line.</source>
          <target state="translated">更改助手显示的消息的详细程度。 &amp;lt;n&amp;gt;的值为0表示进程安静地运行，并且助手仅产生错误输出。默认级别为1，&amp;lt;n&amp;gt;的较高值对应于在命令行上传递的-v标志的数量。</target>
        </trans-unit>
        <trans-unit id="dd3116927a9e7dd7238b571d53ce2cf77fe23ee1" translate="yes" xml:space="preserve">
          <source>Changesets from p4 are imported using Git fast-import.</source>
          <target state="translated">变更集从p4中使用Git fast-import导入。</target>
        </trans-unit>
        <trans-unit id="cab94268d38355d76ce36a45e9bc285de9460c51" translate="yes" xml:space="preserve">
          <source>Changing gitweb&amp;rsquo;s behavior</source>
          <target state="translated">改变gitweb的行为</target>
        </trans-unit>
        <trans-unit id="1e7847382a16c8079c307e0f617f25cfce7cb965" translate="yes" xml:space="preserve">
          <source>Changing gitweb&amp;rsquo;s look</source>
          <target state="translated">改变gitweb的外观</target>
        </trans-unit>
        <trans-unit id="5812a54bc86041329c11b2c54c0ad4f0c8785223" translate="yes" xml:space="preserve">
          <source>Character encoding the commit messages are converted to when running &lt;code&gt;git log&lt;/code&gt; and friends.</source>
          <target state="translated">运行 &lt;code&gt;git log&lt;/code&gt; 和friends 时，将编码提交消息的字符转换为。</target>
        </trans-unit>
        <trans-unit id="1ae63f6ea8b36d3c621f3c26e7c68c400e2fdc6f" translate="yes" xml:space="preserve">
          <source>Character encoding the commit messages are stored in; Git itself does not care per se, but this information is necessary e.g. when importing commits from emails or in the gitk graphical history browser (and possibly at other places in the future or in other porcelains). See e.g. &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;. Defaults to &lt;code&gt;utf-8&lt;/code&gt;.</source>
          <target state="translated">存储提交消息的字符编码；Git本身本身并不关心，但是该信息是必需的，例如，当从电子邮件或gitk图形历史浏览器中（以及将来可能在其他地方或在其他瓷器中）导入提交时。参见例如&lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]&lt;/a&gt;。默认为 &lt;code&gt;utf-8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d76545473270b409d5ad4bb0d1fe44d81e97f58" translate="yes" xml:space="preserve">
          <source>Check for corruption:</source>
          <target state="translated">检查是否有腐败。</target>
        </trans-unit>
        <trans-unit id="b7d8cdc518631e2251ad5f880bdb559475d2d3c6" translate="yes" xml:space="preserve">
          <source>Check if &amp;lt;path&amp;gt; is a valid repository or a gitfile that points at a valid repository, and print the location of the repository. If &amp;lt;path&amp;gt; is a gitfile then the resolved path to the real repository is printed.</source>
          <target state="translated">检查&amp;lt;path&amp;gt;是有效的存储库还是指向有效存储库的gitfile，然后打印存储库的位置。如果&amp;lt;path&amp;gt;是一个gitfile，则将打印到实际存储库的解析路径。</target>
        </trans-unit>
        <trans-unit id="e60019605e61c29f438d2140b618df2fa7a2cf81" translate="yes" xml:space="preserve">
          <source>Check if the command would error out, without updating the index or the files in the working tree for real.</source>
          <target state="translated">检查命令是否会出错,没有真正更新工作树中的索引或文件。</target>
        </trans-unit>
        <trans-unit id="03d22f18e900d425734c737c0518f14811d19a56" translate="yes" xml:space="preserve">
          <source>Check if the first &amp;lt;commit&amp;gt; is an ancestor of the second &amp;lt;commit&amp;gt;, and exit with status 0 if true, or with status 1 if not. Errors are signaled by a non-zero status that is not 1.</source>
          <target state="translated">检查第一个&amp;lt;commit&amp;gt;的祖先是否是第二个&amp;lt;commit&amp;gt;的祖先，如果为true，则退出状态为0；否则，退出为状态1。错误由非零的非1状态表示。</target>
        </trans-unit>
        <trans-unit id="83e838c1d2166b2d88caf18328aef0c7567d558a" translate="yes" xml:space="preserve">
          <source>Check not just objects in GIT_OBJECT_DIRECTORY ($GIT_DIR/objects), but also the ones found in alternate object pools listed in GIT_ALTERNATE_OBJECT_DIRECTORIES or $GIT_DIR/objects/info/alternates, and in packed Git archives found in $GIT_DIR/objects/pack and corresponding pack subdirectories in alternate object pools. This is now default; you can turn it off with --no-full.</source>
          <target state="translated">不仅检查 GIT_OBJECT_DIRECTORY ($GIT_DIR/objects)中的对象,还检查在 GIT_ALTERNATE_OBJECT_DIRECTORIES 或 $GIT_DIR/objects/info/alternates 中列出的备用对象池中的对象,以及在 $GIT_DIR/objects/pack 和备用对象池中相应的打包子目录中发现的 Git 档案。现在是默认的,你可以用--no-full关闭它。</target>
        </trans-unit>
        <trans-unit id="e79b0680caa2ca1906fd2adf6eaff8974f4a2257" translate="yes" xml:space="preserve">
          <source>Check only the connectivity of reachable objects, making sure that any objects referenced by a reachable tag, commit, or tree is present. This speeds up the operation by avoiding reading blobs entirely (though it does still check that referenced blobs exist). This will detect corruption in commits and trees, but not do any semantic checks (e.g., for format errors). Corruption in blob objects will not be detected at all.</source>
          <target state="translated">只检查可到达对象的连接性,确保任何被可到达标记、提交或树引用的对象都存在。这样可以完全避免读取 blobs,从而加快操作速度(尽管它仍然会检查被引用的 blobs 是否存在)。这将检测提交和树中的损坏,但不进行任何语义检查(例如,格式错误)。完全不会检测到blob对象中的损坏。</target>
        </trans-unit>
        <trans-unit id="1059c6a2d1e02e3f2100e501993e9695ffee2a93" translate="yes" xml:space="preserve">
          <source>Check that the change you made is no longer visible, since it was made on the experimental branch and you&amp;rsquo;re back on the master branch.</source>
          <target state="translated">检查所做的更改是否不再可见，因为它是在实验分支上进行的，并且您又回到了master分支上。</target>
        </trans-unit>
        <trans-unit id="283494db1332f5a5bdeebb22027e88d6ecd9fccd" translate="yes" xml:space="preserve">
          <source>Check the GPG signature of commits</source>
          <target state="translated">检查提交的GPG签名</target>
        </trans-unit>
        <trans-unit id="9942c8361d672deabca4bf9b4378db88e5831693" translate="yes" xml:space="preserve">
          <source>Check the GPG signature of tags</source>
          <target state="translated">检查标签的GPG签名</target>
        </trans-unit>
        <trans-unit id="06577cf94f38a79b885fc18bdd8c2be1bcd96e2b" translate="yes" xml:space="preserve">
          <source>Check the validity of a signed commit object by passing the signature to &lt;code&gt;gpg --verify&lt;/code&gt; and show the output.</source>
          <target state="translated">通过将签名传递给 &lt;code&gt;gpg --verify&lt;/code&gt; 来检查已签名提交对象的有效性，并显示输出。</target>
        </trans-unit>
        <trans-unit id="73422e6d03195802a17e28660f8c31a3d87204d7" translate="yes" xml:space="preserve">
          <source>Check whether two branches point at the same history</source>
          <target state="translated">检查两个分支是否指向同一历史</target>
        </trans-unit>
        <trans-unit id="7a3ffea957d19415bf259687b6fc87b1ce4c0522" translate="yes" xml:space="preserve">
          <source>Check your xinetd(8) documentation and setup, this is from a Fedora system. Others might be different.</source>
          <target state="translated">请检查您的 xinetd(8)文档和设置,这是 Fedora 系统的。其他系统可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="6515762734c69625b8244e79b73529d8fd67b97e" translate="yes" xml:space="preserve">
          <source>Checking for patch corruption</source>
          <target state="translated">检查补丁损坏</target>
        </trans-unit>
        <trans-unit id="c722b668af2290a67a3950339daf5303bf70266c" translate="yes" xml:space="preserve">
          <source>Checking merge bases</source>
          <target state="translated">检查合并基地</target>
        </trans-unit>
        <trans-unit id="fa7ccb17065ab13f50e5f4aa48f888b7f36943e2" translate="yes" xml:space="preserve">
          <source>Checking out an old version of a file</source>
          <target state="translated">检查一个文件的旧版本</target>
        </trans-unit>
        <trans-unit id="4285903ce1710560050a0803b330dcd049bfbfef" translate="yes" xml:space="preserve">
          <source>Checking the repository for corruption</source>
          <target state="translated">检查存储库是否存在腐败</target>
        </trans-unit>
        <trans-unit id="2ac84684aef52ff693250170ef43a76e48af3284" translate="yes" xml:space="preserve">
          <source>Checking whitespace errors</source>
          <target state="translated">检查空白处的错误</target>
        </trans-unit>
        <trans-unit id="527933c1f680ec617db3dd975f754535f385100b" translate="yes" xml:space="preserve">
          <source>Checking-out and checking-in</source>
          <target state="translated">退房和入住</target>
        </trans-unit>
        <trans-unit id="49265102fbdeaea303ebc0238044241c00c923d0" translate="yes" xml:space="preserve">
          <source>Checklist for shrinking a repository</source>
          <target state="translated">缩小存储库的检查表</target>
        </trans-unit>
        <trans-unit id="ce166f9433a0a0acaace5836679192e776275599" translate="yes" xml:space="preserve">
          <source>Checks if a given &lt;code&gt;refname&lt;/code&gt; is acceptable, and exits with a non-zero status if it is not.</source>
          <target state="translated">检查给定的 &lt;code&gt;refname&lt;/code&gt; 是否可接受，如果不是，则以非零状态退出。</target>
        </trans-unit>
        <trans-unit id="d8021a065c8c671df3a58cb63e7469b8167a446a" translate="yes" xml:space="preserve">
          <source>Child Process Messages</source>
          <target state="translated">儿童进程信息</target>
        </trans-unit>
        <trans-unit id="5091e72502f618e2b372fcb37e80054927942ac3" translate="yes" xml:space="preserve">
          <source>Child Processes</source>
          <target state="translated">儿童进程</target>
        </trans-unit>
        <trans-unit id="c8895429bfc3ae045740a98bd7892c21d37107b3" translate="yes" xml:space="preserve">
          <source>Choose a diff algorithm. The variants are as follows:</source>
          <target state="translated">选择一种差异算法。变体如下:</target>
        </trans-unit>
        <trans-unit id="59db2d4b9fea86d4c731a426cb932a15c94c9596" translate="yes" xml:space="preserve">
          <source>Choosing textconv versus external diff</source>
          <target state="translated">选择textconv与外部差异</target>
        </trans-unit>
        <trans-unit id="613b7dff145eefd66d417456a88da290b004ada8" translate="yes" xml:space="preserve">
          <source>Chunk header format is modified to prevent people from accidentally feeding it to &lt;code&gt;patch -p1&lt;/code&gt;. Combined diff format was created for review of merge commit changes, and was not meant to be applied. The change is similar to the change in the extended &lt;code&gt;index&lt;/code&gt; header:</source>
          <target state="translated">块头格式已修改，以防止人们不小心将其提供给 &lt;code&gt;patch -p1&lt;/code&gt; 。已创建组合差异格式以查看合并提交更改，但并不适用。该更改类似于扩展 &lt;code&gt;index&lt;/code&gt; 标头中的更改：</target>
        </trans-unit>
        <trans-unit id="42dcbc11ebcca8013128e188e07a667fd189817d" translate="yes" xml:space="preserve">
          <source>Cleans the working tree by recursively removing files that are not under version control, starting from the current directory.</source>
          <target state="translated">从当前目录开始,通过递归删除不受版本控制的文件来清理工作树。</target>
        </trans-unit>
        <trans-unit id="f2d831c9f71cd3ff7b3b6c7c49408fcedc1e2e96" translate="yes" xml:space="preserve">
          <source>Cleanup unnecessary files and optimize the local repository</source>
          <target state="translated">清理不必要的文件,优化本地资源库</target>
        </trans-unit>
        <trans-unit id="94f8adfaa49f4f08c745b4d0d2c62d9ba66072a5" translate="yes" xml:space="preserve">
          <source>Clearly this work-flow uses the virtuous circle between test suites and &quot;git bisect&quot;. In fact it makes it the standard procedure to deal with regression.</source>
          <target state="translated">很明显,这个工作流程使用了测试套件和 &quot;git bisect &quot;之间的良性循环。事实上,它让它成为了处理回归的标准程序。</target>
        </trans-unit>
        <trans-unit id="119db12fc152f2f55488f08da986c3c46bdf64a9" translate="yes" xml:space="preserve">
          <source>Clears any list of &quot;To:&quot;, &quot;Cc:&quot;, &quot;Bcc:&quot; addresses previously set via config.</source>
          <target state="translated">清除之前通过配置设置的 &quot;To:&quot;、&quot;Cc:&quot;、&quot;Bcc:&quot;地址列表。</target>
        </trans-unit>
        <trans-unit id="cf4a0e26c9f93f0530be9fa71dab1af1cbaa231f" translate="yes" xml:space="preserve">
          <source>Clears the previously read value of &lt;code&gt;sendemail.identity&lt;/code&gt; set via config, if any.</source>
          <target state="translated">清除通过配置设置的 &lt;code&gt;sendemail.identity&lt;/code&gt; 的先前读取的值（如果有）。</target>
        </trans-unit>
        <trans-unit id="90944cef36d3464ed0283d5129626cf4ab8fc85b" translate="yes" xml:space="preserve">
          <source>Click on New Mail.</source>
          <target state="translated">点击 &quot;新邮件&quot;。</target>
        </trans-unit>
        <trans-unit id="89585875df151078ae7b77d81e2bd1b067e7d065" translate="yes" xml:space="preserve">
          <source>Client spec</source>
          <target state="translated">客户规格</target>
        </trans-unit>
        <trans-unit id="55e7359e50be70477f290b070978067b2a01b4d1" translate="yes" xml:space="preserve">
          <source>Client specified as an option to all p4 commands, with &lt;code&gt;-c &amp;lt;client&amp;gt;&lt;/code&gt;, including the client spec.</source>
          <target state="translated">使用 &lt;code&gt;-c &amp;lt;client&amp;gt;&lt;/code&gt; （包括客户端规范）将客户端指定为所有p4命令的选项。</target>
        </trans-unit>
        <trans-unit id="80c2bc0ea4027c7a64da85db4dd1237d395876ca" translate="yes" xml:space="preserve">
          <source>Clients known to work</source>
          <target state="translated">已知工作的客户</target>
        </trans-unit>
        <trans-unit id="74d55b5e93bc1fa20e1ae7e006b74220ee6a2f8c" translate="yes" xml:space="preserve">
          <source>Clients may &lt;code&gt;not&lt;/code&gt; use other sha1 expressions, even if the end result is reachable. E.g., neither a relative commit like &lt;code&gt;master^&lt;/code&gt; nor a literal sha1 like &lt;code&gt;abcd1234&lt;/code&gt; is allowed, even if the result is reachable from the refs.</source>
          <target state="translated">即使最终结果可以达到，客户端也 &lt;code&gt;not&lt;/code&gt; 使用其他sha1表达式。例如，即使结果可以从 &lt;code&gt;abcd1234&lt;/code&gt; 也不允许像 &lt;code&gt;master^&lt;/code&gt; 这样的相对提交，也不像abcd1234这样的文字sha1 是允许的。</target>
        </trans-unit>
        <trans-unit id="5c33076e8c658be1dfe63e1df1ac676b47602d66" translate="yes" xml:space="preserve">
          <source>Clients may request a commit or tree that is pointed to directly by a ref. E.g., &lt;code&gt;git archive --remote=origin v1.0&lt;/code&gt;.</source>
          <target state="translated">客户端可以请求由引用直接指向的提交或树。例如， &lt;code&gt;git archive --remote=origin v1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbed12af7936ed3ad4075cea19b034f51ea55c2c" translate="yes" xml:space="preserve">
          <source>Clients may request a sub-tree within a commit or tree using the &lt;code&gt;ref:path&lt;/code&gt; syntax. E.g., &lt;code&gt;git archive --remote=origin v1.0:Documentation&lt;/code&gt;.</source>
          <target state="translated">客户端可以使用 &lt;code&gt;ref:path&lt;/code&gt; 语法在提交或树中请求子树。例如， &lt;code&gt;git archive --remote=origin v1.0:Documentation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9839e8d4aa3c14e4b54e191e51eb2179e4fdaa19" translate="yes" xml:space="preserve">
          <source>Clients should now be able to check out the project. Use the CVS &lt;code&gt;module&lt;/code&gt; name to indicate what Git &lt;code&gt;head&lt;/code&gt; you want to check out. This also sets the name of your newly checked-out directory, unless you tell it otherwise with &lt;code&gt;-d &amp;lt;dir_name&amp;gt;&lt;/code&gt;. For example, this checks out &lt;code&gt;master&lt;/code&gt; branch to the &lt;code&gt;project-master&lt;/code&gt; directory:</source>
          <target state="translated">客户现在应该可以签出该项目。使用CVS &lt;code&gt;module&lt;/code&gt; 名称来指示您要检出的Git &lt;code&gt;head&lt;/code&gt; 。这还将设置新签出目录的名称，除非您使用 &lt;code&gt;-d &amp;lt;dir_name&amp;gt;&lt;/code&gt; 另行指定。例如，这会将 &lt;code&gt;master&lt;/code&gt; 分支检出到 &lt;code&gt;project-master&lt;/code&gt; 目录：</target>
        </trans-unit>
        <trans-unit id="d8cdb573350de78596e4852bc9cacfc94e8d17ed" translate="yes" xml:space="preserve">
          <source>Clone</source>
          <target state="translated">Clone</target>
        </trans-unit>
        <trans-unit id="d69c0c434d503834765604d22b28037bee413bfc" translate="yes" xml:space="preserve">
          <source>Clone a repository into a new directory</source>
          <target state="translated">克隆一个版本库到一个新的目录。</target>
        </trans-unit>
        <trans-unit id="8b7342cb68e63a734e787beefc74dd4c8bf74d08" translate="yes" xml:space="preserve">
          <source>Clone a repository:</source>
          <target state="translated">克隆一个版本库。</target>
        </trans-unit>
        <trans-unit id="e3bdbcd4fc3a4b615a5be68aca4686a1e8d61dd3" translate="yes" xml:space="preserve">
          <source>Clone and sync variables</source>
          <target state="translated">克隆和同步变量</target>
        </trans-unit>
        <trans-unit id="fc5a57d2c10be47f020b40eb294f6e546edcb1fb" translate="yes" xml:space="preserve">
          <source>Clone from upstream while borrowing from an existing local directory:</source>
          <target state="translated">从上游克隆,同时借用现有的本地目录。</target>
        </trans-unit>
        <trans-unit id="31427bc4154831dc13e03739efd0e5c8ceee16ff" translate="yes" xml:space="preserve">
          <source>Clone from upstream:</source>
          <target state="translated">从上游克隆。</target>
        </trans-unit>
        <trans-unit id="40d0639c1781d7a9c100ef0a6d2c0dcfcc6b282c" translate="yes" xml:space="preserve">
          <source>Clone it with &lt;code&gt;git clone file:///path/to/repo&lt;/code&gt;. The clone will not have the removed objects. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;. (Note that cloning with a plain path just hardlinks everything!)</source>
          <target state="translated">用 &lt;code&gt;git clone file:///path/to/repo&lt;/code&gt; 克隆它。克隆将没有已删除的对象。参见&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;。（请注意，使用普通路径克隆只会硬链接所有内容！）</target>
        </trans-unit>
        <trans-unit id="25701c0360e9d04455f2222c02f2b66094990098" translate="yes" xml:space="preserve">
          <source>Clone only the history leading to the tip of a single branch, either specified by the &lt;code&gt;--branch&lt;/code&gt; option or the primary branch remote&amp;rsquo;s &lt;code&gt;HEAD&lt;/code&gt; points at. Further fetches into the resulting repository will only update the remote-tracking branch for the branch this option was used for the initial cloning. If the HEAD at the remote did not point at any branch when &lt;code&gt;--single-branch&lt;/code&gt; clone was made, no remote-tracking branch is created.</source>
          <target state="translated">仅克隆通向单个分支顶端的历史记录，该历史记录由 &lt;code&gt;--branch&lt;/code&gt; 选项指定，或者由主分支远程的 &lt;code&gt;HEAD&lt;/code&gt; 指向。进一步提取到生成的存储库中只会更新该选项用于初始克隆的分支的远程跟踪分支。如果进行 &lt;code&gt;--single-branch&lt;/code&gt; 克隆时，远程的HEAD没有指向任何分支，则不会创建远程跟踪分支。</target>
        </trans-unit>
        <trans-unit id="7a471e90dac3e294ddb7787043d7eb11c0e7a242" translate="yes" xml:space="preserve">
          <source>Clone options</source>
          <target state="translated">克隆选项</target>
        </trans-unit>
        <trans-unit id="0befa381e0a34bfc395f53162eefbad3dae21f70" translate="yes" xml:space="preserve">
          <source>Clone the upstream and work on it. Feed changes to upstream.</source>
          <target state="translated">克隆上游,并对其进行工作。向上游馈赠变化。</target>
        </trans-unit>
        <trans-unit id="4b6b25b2b84758722a0670042a124566ce1d193f" translate="yes" xml:space="preserve">
          <source>Clones a repository into a newly created directory, creates remote-tracking branches for each branch in the cloned repository (visible using &lt;code&gt;git branch --remotes&lt;/code&gt;), and creates and checks out an initial branch that is forked from the cloned repository&amp;rsquo;s currently active branch.</source>
          <target state="translated">将存储 &lt;code&gt;git branch --remotes&lt;/code&gt; 到新创建的目录中，为克隆的存储库中的每个分支创建远程跟踪分支（使用git branch --remotes可见），并创建并签出从克隆的存储库当前活动分支派生的初始分支。</target>
        </trans-unit>
        <trans-unit id="df1a2527d982b2181fc5936a0c039535ce1accdb" translate="yes" xml:space="preserve">
          <source>Cloning or syncing does not require a p4 client; file contents are collected using &lt;code&gt;p4 print&lt;/code&gt;.</source>
          <target state="translated">克隆或同步不需要p4客户端。使用 &lt;code&gt;p4 print&lt;/code&gt; 收集文件内容。</target>
        </trans-unit>
        <trans-unit id="53e412082749509777418e5cdc87503adeb4bf14" translate="yes" xml:space="preserve">
          <source>Collect and show committer identities instead of authors.</source>
          <target state="translated">收集并显示提交者的身份,而不是作者。</target>
        </trans-unit>
        <trans-unit id="fccaafaced7e706bc2bd06241362e04977c0cd36" translate="yes" xml:space="preserve">
          <source>Colon-delimited list of refs or globs indicating which refs, in addition to the default from &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages. This overrides the &lt;code&gt;notes.displayRef&lt;/code&gt; setting.</source>
          <target state="translated">用冒号分隔的ref或glob列表，指示除了显示 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 消息时从 &lt;code&gt;core.notesRef&lt;/code&gt; 或GIT_NOTES_REF读取的默认引用之外，哪些引用。这将覆盖 &lt;code&gt;notes.displayRef&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="b13a61ccbe64b645a15179edff14e97b6ecd8c00" translate="yes" xml:space="preserve">
          <source>Color branches to highlight current, local, and remote-tracking branches. The value must be always (the default), never, or auto.</source>
          <target state="translated">用颜色来突出当前、本地和远程跟踪的分支。该值必须是始终(默认)、从不或自动。</target>
        </trans-unit>
        <trans-unit id="b15070a1530d4c810f05017f7f35501b365479b6" translate="yes" xml:space="preserve">
          <source>Color the status sign (one of these: &lt;code&gt;*&lt;/code&gt;&lt;code&gt;!&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;) of each commit corresponding to the branch it&amp;rsquo;s in. The value must be always (the default), never, or auto.</source>
          <target state="translated">为与该分支所在的分支对应的每个提交的状态标志（其中一个： &lt;code&gt;*&lt;/code&gt; &lt;code&gt;!&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; ）上色。该值必须始终为（默认），从不或自动。</target>
        </trans-unit>
        <trans-unit id="51d8265f4f18e755692a71f862affd712731021e" translate="yes" xml:space="preserve">
          <source>Colors may also be given as numbers between 0 and 255; these use ANSI 256-color mode (but note that not all terminals may support this). If your terminal supports it, you may also specify 24-bit RGB values as hex, like &lt;code&gt;#ff0ab3&lt;/code&gt;.</source>
          <target state="translated">颜色也可以指定为0到255之间的数字。它们使用ANSI 256色模式（但请注意，并非所有终端都可以支持此模式）。如果您的终端支持，您还可以将24位RGB值指定为十六进制，例如 &lt;code&gt;#ff0ab3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39ae0d23566f06a8646ef3abdd586851a9e465cd" translate="yes" xml:space="preserve">
          <source>Combined diff format</source>
          <target state="translated">组合差异格式</target>
        </trans-unit>
        <trans-unit id="5bb60f78b33e9a4f091db8f97f338043390512bd" translate="yes" xml:space="preserve">
          <source>Combining test suites, git bisect and other systems together</source>
          <target state="translated">将测试套件、git bisect和其他系统结合在一起。</target>
        </trans-unit>
        <trans-unit id="4a4a4bb517ec5013313be130afe65f9c77f0eaea" translate="yes" xml:space="preserve">
          <source>Coming from a system such as Perforce or Subversion this should be quite simple, as the fast-import mark can also be the Perforce changeset number or the Subversion revision number.</source>
          <target state="translated">来自Perforce或Subversion这样的系统,这应该很简单,因为快速导入标记也可以是Perforce的变更集号或Subversion的修订号。</target>
        </trans-unit>
        <trans-unit id="b894fab4f168cef475b1c68a083475614077b1e5" translate="yes" xml:space="preserve">
          <source>Coming up with the correct shell snippet to do the filtering you want is sometimes difficult unless you&amp;rsquo;re just doing a trivial modification such as deleting a couple files. Unfortunately, people often learn if the snippet is right or wrong by trying it out, but the rightness or wrongness can vary depending on special circumstances (spaces in filenames, non-ascii filenames, funny author names or emails, invalid timezones, presence of grafts or replace objects, etc.), meaning they may have to wait a long time, hit an error, then restart. The performance of git-filter-branch is so bad that this cycle is painful, reducing the time available to carefully re-check (to say nothing about what it does to the patience of the person doing the rewrite even if they do technically have more time available). This problem is extra compounded because errors from broken filters may not be shown for a long time and/or get lost in a sea of output. Even worse, broken filters often just result in silent incorrect rewrites.</source>
          <target state="translated">有时使用正确的shell代码片段进行所需的过滤有时会很困难，除非您只是进行了一些细微的修改（例如删除几个文件）。不幸的是，人们经常通过尝试来了解代码片段是对还是错，但是正确或错误可能会因特殊情况而异（文件名中的空格，非ASCII文件名，有趣的作者姓名或电子邮件，时区无效，存在嫁接）或替换对象等），这意味着它们可能需要等待很长时间，遇到错误，然后重新启动。 git-filter-branch的性能太差了，以至于这个循环很痛苦，从而减少了仔细检查的时间（更不用说它对重写者的耐心了，即使他们在技术上做了更多时间可用）。这个问题变得更加复杂，因为来自破碎的过滤器的错误可能不会长时间显示和/或在大量的输出中丢失。更糟糕的是，损坏的过滤器通常只会导致无声的错误重写。</target>
        </trans-unit>
        <trans-unit id="8fb52c1564722a1fe5f6cf4e3d44bce48182e716" translate="yes" xml:space="preserve">
          <source>Command Detail Messages</source>
          <target state="translated">命令详情信息</target>
        </trans-unit>
        <trans-unit id="f7e08456d089a047ccd465ae00e5bf2544bfdac7" translate="yes" xml:space="preserve">
          <source>Command Details</source>
          <target state="translated">命令详情</target>
        </trans-unit>
        <trans-unit id="84cf71d717103c00cc33f4f16f173970104ae46e" translate="yes" xml:space="preserve">
          <source>Command aliases for the &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; command wrapper - e.g. after defining &lt;code&gt;alias.last = cat-file commit HEAD&lt;/code&gt;, the invocation &lt;code&gt;git last&lt;/code&gt; is equivalent to &lt;code&gt;git cat-file commit HEAD&lt;/code&gt;. To avoid confusion and troubles with script usage, aliases that hide existing Git commands are ignored. Arguments are split by spaces, the usual shell quoting and escaping is supported. A quote pair or a backslash can be used to quote them.</source>
          <target state="translated">&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;命令包装程序的命令别名-例如，在定义 &lt;code&gt;alias.last = cat-file commit HEAD&lt;/code&gt; ，调用 &lt;code&gt;git last&lt;/code&gt; 与 &lt;code&gt;git cat-file commit HEAD&lt;/code&gt; 等效。为了避免混淆和脚本使用麻烦，将忽略隐藏现有Git命令的别名。参数由空格分隔，支持通常的shell引用和转义。可以使用引号对或反斜杠对它们进行引用。</target>
        </trans-unit>
        <trans-unit id="bb334d175dc8351e4e643438be75bf5083df9523" translate="yes" xml:space="preserve">
          <source>Command and arguments are separated by an unescaped space.</source>
          <target state="translated">命令和参数之间用一个不带空格的空间隔开。</target>
        </trans-unit>
        <trans-unit id="bd186454b9919f30925b251fcf7e4e52ca77972c" translate="yes" xml:space="preserve">
          <source>Command request</source>
          <target state="translated">命令请求</target>
        </trans-unit>
        <trans-unit id="fa701362a88f56992e33094194fa924ccdfa36dc" translate="yes" xml:space="preserve">
          <source>Command to be run each time gitk has to determine the revision range to show. The command is expected to print on its standard output a list of additional revisions to be shown, one per line. Use this instead of explicitly specifying a &lt;code&gt;&amp;lt;revision range&amp;gt;&lt;/code&gt; if the set of commits to show may vary between refreshes.</source>
          <target state="translated">每次gitk必须确定要显示的修订范围时都要运行的命令。预计该命令将在其标准输出上显示要显示的其他修订列表，每行一个。如果要显示的提交集在两次刷新之间可能有所不同，请使用此选项来代替显式指定 &lt;code&gt;&amp;lt;revision range&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d073f0ac32697a8093342645a8234491e985e6ff" translate="yes" xml:space="preserve">
          <source>Command used to setup a tunnel to the IMAP server through which commands will be piped instead of using a direct network connection to the server. Required when imap.host is not set.</source>
          <target state="translated">命令用于设置一个通往IMAP服务器的隧道,通过隧道传输命令,而不是使用直接的网络连接到服务器。当imap.host未设置时需要。</target>
        </trans-unit>
        <trans-unit id="5fbae08a3e549b8259aa734268f8fc50962c7173" translate="yes" xml:space="preserve">
          <source>Command-line interface conventions</source>
          <target state="translated">命令行界面约定</target>
        </trans-unit>
        <trans-unit id="45e5f3f72e961cb70134ba35f7a27a9620e515f7" translate="yes" xml:space="preserve">
          <source>Commands</source>
          <target state="translated">Commands</target>
        </trans-unit>
        <trans-unit id="5415f180d40029f0ddfc48b35f157e8ad10f48bc" translate="yes" xml:space="preserve">
          <source>Commands are given by the caller on the helper&amp;rsquo;s standard input, one per line.</source>
          <target state="translated">调用者在助手的标准输入上给出命令，每行一个。</target>
        </trans-unit>
        <trans-unit id="03880aa7f8436e082afca33e516cbcd9355d3554" translate="yes" xml:space="preserve">
          <source>Commands such as &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt; that let you edit messages by launching an editor use the value of this variable when it is set, and the environment variable &lt;code&gt;GIT_EDITOR&lt;/code&gt; is not set. See &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt;.</source>
          <target state="translated">允许您通过启动编辑器来编辑消息的命令（例如 &lt;code&gt;commit&lt;/code&gt; 和 &lt;code&gt;tag&lt;/code&gt; )使用该变量的值（在设置了该变量的 &lt;code&gt;GIT_EDITOR&lt;/code&gt; ），而未设置环境变量GIT_EDITOR。参见&lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0abcd0747bb8576b597002ab49f39285f1f4ef29" translate="yes" xml:space="preserve">
          <source>Commands such as &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt; that let you edit messages consider a line that begins with this character commented, and removes them after the editor returns (default &lt;code&gt;#&lt;/code&gt;).</source>
          <target state="translated">使您可以编辑消息的诸如 &lt;code&gt;commit&lt;/code&gt; 和 &lt;code&gt;tag&lt;/code&gt; 之类的命令，将以该字符注释的行开始，并在编辑器返回后将其删除（默认为 &lt;code&gt;#&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6030cf68b2071379f06ab06312828ccb10c46868" translate="yes" xml:space="preserve">
          <source>Commands that output paths (e.g. &lt;code&gt;ls-files&lt;/code&gt;, &lt;code&gt;diff&lt;/code&gt;), will quote &quot;unusual&quot; characters in the pathname by enclosing the pathname in double-quotes and escaping those characters with backslashes in the same way C escapes control characters (e.g. &lt;code&gt;\t&lt;/code&gt; for TAB, &lt;code&gt;\n&lt;/code&gt; for LF, &lt;code&gt;\\&lt;/code&gt; for backslash) or bytes with values larger than 0x80 (e.g. octal &lt;code&gt;\302\265&lt;/code&gt; for &quot;micro&quot; in UTF-8). If this variable is set to false, bytes higher than 0x80 are not considered &quot;unusual&quot; any more. Double-quotes, backslash and control characters are always escaped regardless of the setting of this variable. A simple space character is not considered &quot;unusual&quot;. Many commands can output pathnames completely verbatim using the &lt;code&gt;-z&lt;/code&gt; option. The default value is true.</source>
          <target state="translated">输出路径的命令（例如 &lt;code&gt;ls-files&lt;/code&gt; ， &lt;code&gt;diff&lt;/code&gt; ）将通过在路径名中用双引号引起来并在路径名中引用&amp;ldquo;不寻常的&amp;rdquo;字符，并以反斜杠对这些字符进行转义，就像C会转义控制字符一样（例如 &lt;code&gt;\t&lt;/code&gt; 为TAB） ， &lt;code&gt;\n&lt;/code&gt; 对于LF， &lt;code&gt;\\&lt;/code&gt; 对于反斜杠）或值大于0x80的字节（例如，在UTF-8中为&amp;ldquo; micro&amp;rdquo;的八进制 &lt;code&gt;\302\265&lt;/code&gt; ）。如果将此变量设置为false，则不再将大于0x80的字节视为&amp;ldquo;异常&amp;rdquo;。无论此变量的设置如何，双引号，反斜杠和控制字符始终会转义。简单的空格字符不被认为是&amp;ldquo;异常&amp;rdquo;。许多命令可以使用 &lt;code&gt;-z&lt;/code&gt; 选项。默认值是true。</target>
        </trans-unit>
        <trans-unit id="240a8b9ba4498383936942814599bad7b6fd9115" translate="yes" xml:space="preserve">
          <source>Commands that support the enhanced option parser accepts unique prefix of a long option as if it is fully spelled out, but use this with a caution. For example, &lt;code&gt;git commit --amen&lt;/code&gt; behaves as if you typed &lt;code&gt;git commit --amend&lt;/code&gt;, but that is true only until a later version of Git introduces another option that shares the same prefix, e.g. &lt;code&gt;git commit --amenity&lt;/code&gt; option.</source>
          <target state="translated">支持增强选项解析器的命令会接受长选项的唯一前缀，就好像它是完全拼写的一样，但请谨慎使用。例如， &lt;code&gt;git commit --amen&lt;/code&gt; 的行为就像您键入 &lt;code&gt;git commit --amend&lt;/code&gt; 一样，但这只有在更高版本的Git引入另一个共享相同前缀的选项时才是正确的，例如 &lt;code&gt;git commit --amenity&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="40539e4d461e31ee218fa661fb2b14e246e5b1ba" translate="yes" xml:space="preserve">
          <source>Commands that support the enhanced option parser allow you to aggregate short options. This means that you can for example use &lt;code&gt;git rm -rf&lt;/code&gt; or &lt;code&gt;git clean -fdx&lt;/code&gt;.</source>
          <target state="translated">支持增强的选项分析器的命令允许您聚合简短选项。这意味着您可以使用例如 &lt;code&gt;git rm -rf&lt;/code&gt; 或 &lt;code&gt;git clean -fdx&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3f5763bea669fa755ce44d52b210df9afaf62df" translate="yes" xml:space="preserve">
          <source>Commands which have the enhanced option parser activated all understand a couple of magic command-line options:</source>
          <target state="translated">激活了增强型选项解析器的命令都能理解几个神奇的命令行选项。</target>
        </trans-unit>
        <trans-unit id="1164e5e23a09019a23028b34e0716555534c7c84" translate="yes" xml:space="preserve">
          <source>Comment lines appearing within the &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; part of &lt;code&gt;data&lt;/code&gt; commands are always taken to be part of the body of the data and are therefore never ignored by fast-import. This makes it safe to import any file/message content whose lines might start with &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="translated">出现在 &lt;code&gt;data&lt;/code&gt; 命令 &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; 部分中的注释行始终被视为数据主体的一部分，因此，快速导入永远不会忽略它们。这样可以安全地导入任何以 &lt;code&gt;#&lt;/code&gt; 开头的文件/消息内容。</target>
        </trans-unit>
        <trans-unit id="a91a1b2d9c14de30d84e97a50ebe0d84ec870d0d" translate="yes" xml:space="preserve">
          <source>Commit Exclusions</source>
          <target state="translated">排除承诺</target>
        </trans-unit>
        <trans-unit id="d05672f731c8973c38856897c1597b273795a8b8" translate="yes" xml:space="preserve">
          <source>Commit Formatting</source>
          <target state="translated">提交格式化</target>
        </trans-unit>
        <trans-unit id="dd5ce850ad942688eb2a5bc300a25747c87232f5" translate="yes" xml:space="preserve">
          <source>Commit Limiting</source>
          <target state="translated">承诺限制</target>
        </trans-unit>
        <trans-unit id="b518afb06183e6dd261846ce6b7c3883dfb90753" translate="yes" xml:space="preserve">
          <source>Commit Object</source>
          <target state="translated">提交对象</target>
        </trans-unit>
        <trans-unit id="d0a18b5ae3a3d7dd2d18ac07312a3fb851663f8e" translate="yes" xml:space="preserve">
          <source>Commit Ordering</source>
          <target state="translated">委托加工</target>
        </trans-unit>
        <trans-unit id="cf42eef97d741d8fac1d744839ed812ca253ade6" translate="yes" xml:space="preserve">
          <source>Commit automatically if the patch applied cleanly. It will not commit if any hunks fail to apply or there were other problems.</source>
          <target state="translated">如果补丁应用得很干净,会自动提交。如果有任何hunks没有应用或有其他问题,它将不会提交。</target>
        </trans-unit>
        <trans-unit id="d6fc46793322e7555ef7eec902c3baf2d380d288" translate="yes" xml:space="preserve">
          <source>Commit each diff from the current branch directly to the SVN repository, and then rebase or reset (depending on whether or not there is a diff between SVN and head). This will create a revision in SVN for each commit in Git.</source>
          <target state="translated">将当前分支的每一个 diff 直接提交到 SVN 仓库,然后重设或重置(取决于 SVN 和 head 之间是否有 diff)。这将为 Git 的每一次提交在 SVN 中创建一个修订版。</target>
        </trans-unit>
        <trans-unit id="32d864cf4da09ae0ccb717144326eeb4d87e8ec8" translate="yes" xml:space="preserve">
          <source>Commit information</source>
          <target state="translated">承诺信息</target>
        </trans-unit>
        <trans-unit id="cdf751d893db0a24e80b369d44da2bfa908750cb" translate="yes" xml:space="preserve">
          <source>Commit log messages are typically encoded in UTF-8, but other extended ASCII encodings are also supported. This includes ISO-8859-x, CP125x and many others, but &lt;code&gt;not&lt;/code&gt; UTF-16/32, EBCDIC and CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.).</source>
          <target state="translated">提交日志消息通常以UTF-8编码，但也支持其他扩展ASCII编码。这包括ISO-8859-x，CP125x和许多其他文件，但 &lt;code&gt;not&lt;/code&gt; UTF-16 / 32，EBCDIC和CJK多字节编码（GBK，Shift-JIS，Big5，EUC-x，CP9xx等）。</target>
        </trans-unit>
        <trans-unit id="a8ef9cdaba51b8bab239b7175f652bb22d7bc77a" translate="yes" xml:space="preserve">
          <source>Commit messages (even if they are all UTF-8) by default become corrupted due to not being updated &amp;mdash; any references to other commit hashes in commit messages will now refer to no-longer-extant commits.</source>
          <target state="translated">默认情况下，提交消息（即使它们都是UTF-8）也会由于未更新而损坏-提交消息中对其他提交哈希的任何引用现在都将引用不再存在的提交。</target>
        </trans-unit>
        <trans-unit id="a0d43ade6a679ebd3be023e33c0ed655845a2385" translate="yes" xml:space="preserve">
          <source>Commit notes are blobs containing extra information about an object (usually information to supplement a commit&amp;rsquo;s message). These blobs are taken from notes refs. A notes ref is usually a branch which contains &quot;files&quot; whose paths are the object names for the objects they describe, with some directory separators included for performance reasons &lt;sup&gt;[&lt;a href=&quot;#_footnote_1&quot; id=&quot;_footnoteref_1&quot;&gt;1&lt;/a&gt;]&lt;/sup&gt;.</source>
          <target state="translated">提交注释是包含有关对象的额外信息（通常是用于补充提交消息的信息）的Blob。这些斑点来自注释参考。notes ref通常是一个分支，其中包含&amp;ldquo;文件&amp;rdquo;，其路径是它们描述的对象的对象名称，出于性能原因还包括一些目录分隔符&lt;sup&gt;[ &lt;a href=&quot;#_footnote_1&quot; id=&quot;_footnoteref_1&quot;&gt;1&lt;/a&gt; ]&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="340dec00f8e27e530fc4429d17a96a5706fe14b1" translate="yes" xml:space="preserve">
          <source>Commit objects created with the above setting record the value of &lt;code&gt;i18n.commitEncoding&lt;/code&gt; in its &lt;code&gt;encoding&lt;/code&gt; header. This is to help other people who look at them later. Lack of this header implies that the commit log message is encoded in UTF-8.</source>
          <target state="translated">使用上述设置创建的提交对象将 &lt;code&gt;i18n.commitEncoding&lt;/code&gt; 的值记录在其 &lt;code&gt;encoding&lt;/code&gt; 头中。这是为了帮助以后查看它们的其他人。缺少此标头意味着提交日志消息以UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="3e636bd205abbae562ddd3b2c8e7ad0ad71d57b9" translate="yes" xml:space="preserve">
          <source>Commit the now-current index with whatever commit message is appropriate now.</source>
          <target state="translated">将现在的索引提交给任何适合现在的提交信息。</target>
        </trans-unit>
        <trans-unit id="0d30e12bd35c1bbb537786b722f71f7710203505" translate="yes" xml:space="preserve">
          <source>Commit the superproject:</source>
          <target state="translated">承诺超级项目。</target>
        </trans-unit>
        <trans-unit id="c2ba6e6758d4e077ba6384de032e88b129ac1452" translate="yes" xml:space="preserve">
          <source>Commit to end at (defaults to HEAD). This names the commit at the tip of the history you are asking to be pulled.</source>
          <target state="translated">结束的提交(默认为 HEAD)。这是您要求拉取的历史记录顶端的提交的名称。</target>
        </trans-unit>
        <trans-unit id="5d83b220e2a717b4332302a14b01dfcf38b82250" translate="yes" xml:space="preserve">
          <source>Commit to start at. This names a commit that is already in the upstream history.</source>
          <target state="translated">从哪个提交开始。命名一个已经在上游历史中的提交。</target>
        </trans-unit>
        <trans-unit id="58a3fb0fa9151eaf5eb44aad642ac139bbd8d0a3" translate="yes" xml:space="preserve">
          <source>Commit to this SVN URL (the full path). This is intended to allow existing &lt;code&gt;git svn&lt;/code&gt; repositories created with one transport method (e.g. &lt;code&gt;svn://&lt;/code&gt; or &lt;code&gt;http://&lt;/code&gt; for anonymous read) to be reused if a user is later given access to an alternate transport method (e.g. &lt;code&gt;svn+ssh://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;) for commit.</source>
          <target state="translated">提交到此SVN URL（完整路径）。这是为了允许在以后允许用户访问另一种传输方法（例如 &lt;code&gt;svn+ssh://&lt;/code&gt; ）的情况下，重用使用一种传输方法（例如 &lt;code&gt;svn://&lt;/code&gt; 或 &lt;code&gt;http://&lt;/code&gt; 进行匿名读取）创建的现有 &lt;code&gt;git svn&lt;/code&gt; 存储库。 //或 &lt;code&gt;https://&lt;/code&gt; ）进行提交。</target>
        </trans-unit>
        <trans-unit id="5d95f392f7b327e450a5cff3a7d0d778dd7bb17a" translate="yes" xml:space="preserve">
          <source>Commit-ish object names to describe. Defaults to HEAD if omitted.</source>
          <target state="translated">要描述的提交类对象名称。如果省略,默认为 HEAD。</target>
        </trans-unit>
        <trans-unit id="806d7e617bf08278640b3918df6eb314e00c91ba" translate="yes" xml:space="preserve">
          <source>Commits A and B would no longer belong to a branch with a symbolic name, and so would be unreachable. As such, these commits would be removed by a &lt;code&gt;git gc&lt;/code&gt; command on the origin repository.</source>
          <target state="translated">提交A和B将不再属于具有符号名称的分支，因此将不可访问。这样，这些提交将通过源存储库上的 &lt;code&gt;git gc&lt;/code&gt; 命令删除。</target>
        </trans-unit>
        <trans-unit id="cd34e82ef88e8c2479cf92c1c7e01e1f9402380d" translate="yes" xml:space="preserve">
          <source>Commits are included if they are not TREESAME to any parent (though this can be changed, see &lt;code&gt;--sparse&lt;/code&gt; below). If the commit was a merge, and it was TREESAME to one parent, follow only that parent. (Even if there are several TREESAME parents, follow only one of them.) Otherwise, follow all parents.</source>
          <target state="translated">如果不是对任何父级的TREESAME，则包含提交（尽管可以更改，请参见下面的 &lt;code&gt;--sparse&lt;/code&gt; ）。如果提交是合并，并且对一个父对象是TREESAME，则仅遵循该父对象。（即使有几个TREESAME父母，也只能跟随其中一个。）否则，请跟随所有父母。</target>
        </trans-unit>
        <trans-unit id="639abedb72340eed90c014868e55014692d325d7" translate="yes" xml:space="preserve">
          <source>Commits modifying the given &amp;lt;paths&amp;gt; are selected.</source>
          <target state="translated">选择修改给定&amp;lt;paths&amp;gt;的提交。</target>
        </trans-unit>
        <trans-unit id="e092c6ca44bf3dcd26785c6425ee818e873ea1fd" translate="yes" xml:space="preserve">
          <source>Commits that are referred by some branch or tag are selected.</source>
          <target state="translated">被某个分支或标签引用的承诺被选中。</target>
        </trans-unit>
        <trans-unit id="6d094219b19302ca10342a1d1eec0568558c2bd8" translate="yes" xml:space="preserve">
          <source>Commits that are walked are included if they are not TREESAME to any parent.</source>
          <target state="translated">走过的承诺,如果对任何一个家长来说都不是TREESAME,那么就包括在内。</target>
        </trans-unit>
        <trans-unit id="ef7e9aac4d19855b4ef3c8efc0ae0f7c81184b39" translate="yes" xml:space="preserve">
          <source>Commits the diff of two tree-ish arguments from the command-line. This command does not rely on being inside a &lt;code&gt;git svn
init&lt;/code&gt;-ed repository. This command takes three arguments, (a) the original tree to diff against, (b) the new tree result, (c) the URL of the target Subversion repository. The final argument (URL) may be omitted if you are working from a &lt;code&gt;git svn&lt;/code&gt;-aware repository (that has been &lt;code&gt;init&lt;/code&gt;-ed with &lt;code&gt;git svn&lt;/code&gt;). The -r&amp;lt;revision&amp;gt; option is required for this.</source>
          <target state="translated">从命令行提交两个树状参数的差异。此命令不依赖于位于 &lt;code&gt;git svn init&lt;/code&gt; 存储库中。此命令采用三个参数，（a）要与之相对的原始树，（b）新的树结果，（c）目标Subversion存储库的URL。如果您正在 &lt;code&gt;git svn&lt;/code&gt; -aware仓库（已使用 &lt;code&gt;git svn&lt;/code&gt; &lt;code&gt;init&lt;/code&gt; -ed ）中工作，则可以省略最后一个参数（URL ）。为此，需要-r &amp;lt;revision&amp;gt;选项。</target>
        </trans-unit>
        <trans-unit id="958e7e955e68b84d191b41f660f0af907a1a26e7" translate="yes" xml:space="preserve">
          <source>Commits to cherry-pick. For a more complete list of ways to spell commits, see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;. Sets of commits can be passed but no traversal is done by default, as if the &lt;code&gt;--no-walk&lt;/code&gt; option was specified, see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;. Note that specifying a range will feed all &amp;lt;commit&amp;gt;&amp;hellip;​ arguments to a single revision walk (see a later example that uses &lt;code&gt;maint master..next&lt;/code&gt;).</source>
          <target state="translated">致力于摘樱桃。有关拼写提交方式的更完整列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;。可以传递一组提交，但默认情况下不会进行遍历，就像指定了 &lt;code&gt;--no-walk&lt;/code&gt; 选项一样，请参见&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;。请注意，指定范围会将所有&amp;lt;commit&amp;gt; ...参数提供给一个修订版本（请参阅后面的使用 &lt;code&gt;maint master..next&lt;/code&gt; 的示例）。</target>
        </trans-unit>
        <trans-unit id="dbab89c03eabe421a0f756d1774250a10ff8a483" translate="yes" xml:space="preserve">
          <source>Commits to revert. For a more complete list of ways to spell commit names, see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;. Sets of commits can also be given but no traversal is done by default, see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; and its &lt;code&gt;--no-walk&lt;/code&gt; option.</source>
          <target state="translated">承诺还原。有关拼写提交名称的方法的完整列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;。也可以给出一组提交，但是默认情况下不进行遍历，请参见&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;及其 &lt;code&gt;--no-walk&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="49656a8c34bd2a56ea7b1c4c19ee41def8e375e6" translate="yes" xml:space="preserve">
          <source>Commits, usually other branch heads, to merge into our branch. Specifying more than one commit will create a merge with more than two parents (affectionately called an Octopus merge).</source>
          <target state="translated">提交,通常是其他分支的头,要合并到我们的分支。指定一个以上的提交,将创建一个有两个以上父分支的合并(亲切地称为章鱼合并)。</target>
        </trans-unit>
        <trans-unit id="c73e3ca2125dd6b66724a23fd1d9404dae439c7b" translate="yes" xml:space="preserve">
          <source>Committing everything directly on the integration branches leads to many problems: Bad commits cannot be undone, so they must be reverted one by one, which creates confusing histories and further error potential when you forget to revert part of a group of changes. Working in parallel mixes up the changes, creating further confusion.</source>
          <target state="translated">直接在集成分支上提交所有内容会导致很多问题。坏的提交不能被撤销,所以必须一个一个地还原,这就造成了混乱的历史,而且当你忘记还原一组变化的一部分时,还可能出现错误。并行工作会把变更混在一起,造成进一步的混乱。</target>
        </trans-unit>
        <trans-unit id="fe3255bd451d3471e881939414843a91c1360c6e" translate="yes" xml:space="preserve">
          <source>Committing git state</source>
          <target state="translated">提交git状态</target>
        </trans-unit>
        <trans-unit id="429882fbdbb00bcd134816d89830eb4242096534" translate="yes" xml:space="preserve">
          <source>Common Git shell script setup code</source>
          <target state="translated">常见的Git shell脚本设置代码</target>
        </trans-unit>
        <trans-unit id="8a9ecfa5494a6336bbbe04b6056604a3b2505855" translate="yes" xml:space="preserve">
          <source>Common Key/Value Pairs</source>
          <target state="translated">常见的键/值对</target>
        </trans-unit>
        <trans-unit id="1af5706ae88f10b9ead3cfff1d78f59757380eca" translate="yes" xml:space="preserve">
          <source>Common diff options</source>
          <target state="translated">常见的差异选项</target>
        </trans-unit>
        <trans-unit id="17cfc9441a242e68c384e9b5b8cf9a0e4a24fffd" translate="yes" xml:space="preserve">
          <source>Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">支持 &lt;code&gt;k&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; 或 &lt;code&gt;g&lt;/code&gt; 的通用单位后缀。</target>
        </trans-unit>
        <trans-unit id="2d454855d2445672da925706dc840080c654c187" translate="yes" xml:space="preserve">
          <source>Compare a tree to the working tree or index</source>
          <target state="translated">将一棵树与工作树或索引进行比较</target>
        </trans-unit>
        <trans-unit id="b052eee7a70522f76de64441f0532b8b978732a8" translate="yes" xml:space="preserve">
          <source>Compare the commits specified by the two ranges, where &lt;code&gt;&amp;lt;range1&amp;gt;&lt;/code&gt; is considered an older version of &lt;code&gt;&amp;lt;range2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">比较两个范围指定的提交，其中 &lt;code&gt;&amp;lt;range1&amp;gt;&lt;/code&gt; 被认为是 &lt;code&gt;&amp;lt;range2&amp;gt;&lt;/code&gt; 的较早版本。</target>
        </trans-unit>
        <trans-unit id="cbedfc6f6fea6e33a27f5f1a33053dbff1a37614" translate="yes" xml:space="preserve">
          <source>Compare the version before the last commit and the last commit.</source>
          <target state="translated">比较上次提交前的版本和上次提交的版本。</target>
        </trans-unit>
        <trans-unit id="108964900757319250c09d41bf5206fee17fbebf" translate="yes" xml:space="preserve">
          <source>Compare the working tree with the &quot;base&quot; version (stage #1), &quot;our branch&quot; (stage #2) or &quot;their branch&quot; (stage #3). The index contains these stages only for unmerged entries i.e. while resolving conflicts. See &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt; section &quot;3-Way Merge&quot; for detailed information.</source>
          <target state="translated">将工作树与&amp;ldquo;基本&amp;rdquo;版本（阶段1），&amp;ldquo;我们的分支&amp;rdquo;（阶段2）或&amp;ldquo;其分支&amp;rdquo;（阶段3）进行比较。索引仅包含未合并条目的这些阶段，即解决冲突时。有关详细信息，请参见&lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt;部分&amp;ldquo; 3-Way Merge&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="417383ec38892ec59642ec5eded68ccdbddd54d0" translate="yes" xml:space="preserve">
          <source>Compare to &lt;code&gt;--full-history&lt;/code&gt; without rewriting above. Note that &lt;code&gt;E&lt;/code&gt; was pruned away because it is TREESAME, but the parent list of P was rewritten to contain &lt;code&gt;E&lt;/code&gt;'s parent &lt;code&gt;I&lt;/code&gt;. The same happened for &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt;, and &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;--full-history&lt;/code&gt; 比较，而无需在上面重写。需要注意的是 &lt;code&gt;E&lt;/code&gt; 被修剪掉，因为它是TREESAME，但P的父列表被改写为包含 &lt;code&gt;E&lt;/code&gt; 的父母 &lt;code&gt;I&lt;/code&gt; 。 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt; 以及 &lt;code&gt;X&lt;/code&gt; ， &lt;code&gt;Y&lt;/code&gt; 和 &lt;code&gt;Q&lt;/code&gt; 发生相同的情况。</target>
        </trans-unit>
        <trans-unit id="4186f0f14c1670feb8e3a98bffba021e85440c5e" translate="yes" xml:space="preserve">
          <source>Compare two commit ranges (e.g. two versions of a branch)</source>
          <target state="translated">比较两个提交范围(例如一个分支的两个版本)。</target>
        </trans-unit>
        <trans-unit id="efcf6f2f0a57938476e9e49afce7ef20662e5045" translate="yes" xml:space="preserve">
          <source>Compares files in the working tree and the index</source>
          <target state="translated">比较工作树和索引中的文件。</target>
        </trans-unit>
        <trans-unit id="b51a5025d034c563fd7e4cf2f1781edb403c8a61" translate="yes" xml:space="preserve">
          <source>Compares the content and mode of blobs found via two tree objects</source>
          <target state="translated">比较通过两个树状对象找到的blobs的内容和模式。</target>
        </trans-unit>
        <trans-unit id="4bed9c3374f6538cd59dc69ff688ff3c6921c3b0" translate="yes" xml:space="preserve">
          <source>Compares the content and mode of the blobs found in a tree object with the corresponding tracked files in the working tree, or with the corresponding paths in the index. When &amp;lt;path&amp;gt; arguments are present, compares only paths matching those patterns. Otherwise all tracked files are compared.</source>
          <target state="translated">将在树对象中找到的斑点的内容和模式与工作树中的相应跟踪文件或索引中的相应路径进行比较。如果存在&amp;lt;path&amp;gt;参数，则仅比较与那些模式匹配的路径。否则，将比较所有跟踪的文件。</target>
        </trans-unit>
        <trans-unit id="37c34b145e3b8ab67ff7b61ff3d11d3a3ac26e63" translate="yes" xml:space="preserve">
          <source>Compares the content and mode of the blobs found via two tree objects.</source>
          <target state="translated">比较通过两个树对象找到的 blobs 的内容和模式。</target>
        </trans-unit>
        <trans-unit id="7bbeb5d1d5d86904df9d33155d8ac31a0ac700db" translate="yes" xml:space="preserve">
          <source>Compares the files in the working tree and the index. When paths are specified, compares only those named paths. Otherwise all entries in the index are compared. The output format is the same as for &lt;code&gt;git diff-index&lt;/code&gt; and &lt;code&gt;git diff-tree&lt;/code&gt;.</source>
          <target state="translated">比较工作树中的文件和索引。指定路径后，仅比较那些已命名的路径。否则，将比较索引中的所有条目。输出格式与 &lt;code&gt;git diff-index&lt;/code&gt; 和 &lt;code&gt;git diff-tree&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f362db0c69868c1d491d62f5976e73dedfebf2ca" translate="yes" xml:space="preserve">
          <source>Comparing blobs or trees that have been replaced with those that replace them will not work properly. And using &lt;code&gt;git reset --hard&lt;/code&gt; to go back to a replaced commit will move the branch to the replacement commit instead of the replaced commit.</source>
          <target state="translated">将已替换的Blob或树与替换后的Blob或树进行比较无法正常工作。并且使用 &lt;code&gt;git reset --hard&lt;/code&gt; 返回到替换的提交会将分支转移到替换的提交而不是替换的提交。</target>
        </trans-unit>
        <trans-unit id="e0150129e57bff1f18c9fdecdc5f6497b9177eb2" translate="yes" xml:space="preserve">
          <source>Comparing branches</source>
          <target state="translated">比较分支机构</target>
        </trans-unit>
        <trans-unit id="275ba455480c0eb203a002756ce88295e425384f" translate="yes" xml:space="preserve">
          <source>Comparing with arbitrary commits</source>
          <target state="translated">与任意提交比较</target>
        </trans-unit>
        <trans-unit id="0623cdc962e5b3ec3734b834b479126f0b30d78b" translate="yes" xml:space="preserve">
          <source>Complete list of all commands</source>
          <target state="translated">所有命令的完整列表</target>
        </trans-unit>
        <trans-unit id="678bc9ada07c728ccee1f48de02cb28152653f42" translate="yes" xml:space="preserve">
          <source>Composing</source>
          <target state="translated">Composing</target>
        </trans-unit>
        <trans-unit id="3a4b462b90ad947c014f566102a2e5a0dd92671e" translate="yes" xml:space="preserve">
          <source>Comprehensive reference documentation is available through the man pages, or &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; command. For example, for the command &lt;code&gt;git clone &amp;lt;repo&amp;gt;&lt;/code&gt;, you can either use:</source>
          <target state="translated">完整的参考文档可通过手册页或&lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt;命令获得。例如，对于命令 &lt;code&gt;git clone &amp;lt;repo&amp;gt;&lt;/code&gt; ，您可以使用：</target>
        </trans-unit>
        <trans-unit id="90ae7930698f6a9514e277afc75b1efe24fb78ff" translate="yes" xml:space="preserve">
          <source>Compress $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log files and remove $GIT_DIR/svn/&amp;lt;refname&amp;gt;/index files.</source>
          <target state="translated">压缩$ GIT_DIR / svn / &amp;lt;refname&amp;gt; /unhandled.log文件，然后删除$ GIT_DIR / svn / &amp;lt;refname&amp;gt; / index文件。</target>
        </trans-unit>
        <trans-unit id="af5758a107c963e9444cff5454d146835b9b660b" translate="yes" xml:space="preserve">
          <source>Compute object ID and optionally creates a blob from a file</source>
          <target state="translated">计算对象ID,并可选择从文件中创建一个blob。</target>
        </trans-unit>
        <trans-unit id="01c4a7d17645c800690175029629fd7aeb958298" translate="yes" xml:space="preserve">
          <source>Compute the best common ancestors of all supplied commits, in preparation for an n-way merge. This mimics the behavior of &lt;code&gt;git show-branch --merge-base&lt;/code&gt;.</source>
          <target state="translated">计算所有提供的提交中最好的共同祖先，以准备进行n次合并。这模仿了 &lt;code&gt;git show-branch --merge-base&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="9bde35c0f2dc15b67baddfc39466c5eba5799786" translate="yes" xml:space="preserve">
          <source>Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.</source>
          <target state="translated">通过计算从源文件中删除或添加到目标文件中的行数来计算dirstat的数量。这忽略了文件中纯代码的移动量。换句话说,重新安排文件中的行数不会像其他变化那样被计算。这是没有参数时的默认行为。</target>
        </trans-unit>
        <trans-unit id="d5135b971c817889635eeca2e7a1431f33e06f37" translate="yes" xml:space="preserve">
          <source>Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest &lt;code&gt;--dirstat&lt;/code&gt; behavior, since it does not have to look at the file contents at all.</source>
          <target state="translated">通过计算更改的文件数来计算目录统计数。每个更改的文件在dirstat分析中均相等计数。这是在计算上最便宜的 &lt;code&gt;--dirstat&lt;/code&gt; 行为，因为它根本不必查看文件内容。</target>
        </trans-unit>
        <trans-unit id="3058cd552896436a63e7fe6f202c943042969930" translate="yes" xml:space="preserve">
          <source>Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive &lt;code&gt;--dirstat&lt;/code&gt; behavior than the &lt;code&gt;changes&lt;/code&gt; behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other &lt;code&gt;--*stat&lt;/code&gt; options.</source>
          <target state="translated">通过执行常规的基于行的差异分析，并计算已删除/添加的行数，计算目录统计号。（对于二进制文件，请改为计算64字节的块，因为二进制文件没有自然的行概念）。与 &lt;code&gt;changes&lt;/code&gt; 行为相比，这是更昂贵的 &lt;code&gt;--dirstat&lt;/code&gt; 行为，但是它确实将文件中重新排列的行数与其他更改一样多。结果输出与您从其他 &lt;code&gt;--*stat&lt;/code&gt; 选项获得的输出一致。</target>
        </trans-unit>
        <trans-unit id="6a0b0a16b974bf1fed36c439dfbdefde29d32d7c" translate="yes" xml:space="preserve">
          <source>Compute unique ID for a patch</source>
          <target state="translated">计算补丁的唯一ID</target>
        </trans-unit>
        <trans-unit id="8998103614864fe1630f3c6a0063c614dbc4eadb" translate="yes" xml:space="preserve">
          <source>Computes the object ID value for an object with specified type with the contents of the named file (which can be outside of the work tree), and optionally writes the resulting object into the object database. Reports its object ID to its standard output. When &amp;lt;type&amp;gt; is not specified, it defaults to &quot;blob&quot;.</source>
          <target state="translated">使用命名文件的内容（可以在工作树之外）计算具有指定类型的对象的对象ID值，并可以选择将结果对象写入对象数据库。将其对象ID报告给其标准输出。如果未指定&amp;lt;type&amp;gt;，则默认为&amp;ldquo; blob&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="937949a3d933696c9d4185384073018afe774033" translate="yes" xml:space="preserve">
          <source>Concatenates the contents of said Makefiles in the head of the branch &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">将所述Makefile的内容连接到分支 &lt;code&gt;master&lt;/code&gt; 的头部。</target>
        </trans-unit>
        <trans-unit id="7d484eb61cfd5469110c2312d1ec91512fe53e6a" translate="yes" xml:space="preserve">
          <source>Conceptually there are only four object types: commit, tree, tag and blob. However to save space, an object could be stored as a &quot;delta&quot; of another &quot;base&quot; object. These representations are assigned new types ofs-delta and ref-delta, which is only valid in a pack file.</source>
          <target state="translated">从概念上讲,只有四种对象类型:commit、tree、tag和blob,但为了节省空间,一个对象可以作为另一个 &quot;基础 &quot;对象的 &quot;delta &quot;存储。然而为了节省空间,一个对象可以被存储为另一个 &quot;基础 &quot;对象的 &quot;delta&quot;。这些表示方式被分配了新的类型ofs-delta和ref-delta,这只在pack文件中有效。</target>
        </trans-unit>
        <trans-unit id="f9ce6c77a92950f557622abcc328a5c52bc5ce16" translate="yes" xml:space="preserve">
          <source>Conceptually, &lt;code&gt;git write-tree&lt;/code&gt; sync()s the current index contents into a set of tree files. In order to have that match what is actually in your directory right now, you need to have done a &lt;code&gt;git update-index&lt;/code&gt; phase before you did the &lt;code&gt;git write-tree&lt;/code&gt;.</source>
          <target state="translated">从概念上讲， &lt;code&gt;git write-tree&lt;/code&gt; sync（）将当前索引内容放入一组树文件中。为了与当前目录中的实际内容相匹配，您需要先执行 &lt;code&gt;git update-index&lt;/code&gt; 阶段，然后再执行 &lt;code&gt;git write-tree&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ca3e3f6198d8db66027f645ef57e4ac30e9a37f" translate="yes" xml:space="preserve">
          <source>Conceptually, the feature enters at an unstable branch (usually &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;pu&lt;/code&gt;), and &quot;graduates&quot; to &lt;code&gt;master&lt;/code&gt; for the next release once it is considered stable enough.</source>
          <target state="translated">从概念上讲，该功能会进入不稳定的分支（通常为 &lt;code&gt;next&lt;/code&gt; 或 &lt;code&gt;pu&lt;/code&gt; ），一旦认为足够稳定，&amp;ldquo;毕业生&amp;rdquo;即可 &lt;code&gt;master&lt;/code&gt; 下一个版本。</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="c144db8f4732a9347031a1b40f149e52d91f565f" translate="yes" xml:space="preserve">
          <source>Concrete example</source>
          <target state="translated">具体例子</target>
        </trans-unit>
        <trans-unit id="1805d25f90c97785232c09de6be3d92c9bae4482" translate="yes" xml:space="preserve">
          <source>Conditional includes</source>
          <target state="translated">条件包括</target>
        </trans-unit>
        <trans-unit id="1eca678ae2103e84056e13fabe651ada3207805a" translate="yes" xml:space="preserve">
          <source>Cone pattern set</source>
          <target state="translated">锥形图案组</target>
        </trans-unit>
        <trans-unit id="eb7272ff2c451e4d56ff0b5035c89e6773552a2b" translate="yes" xml:space="preserve">
          <source>Config file-only options</source>
          <target state="translated">只配置文件选项</target>
        </trans-unit>
        <trans-unit id="422fb4b2c323c56fc618406ee76b1fefb87edd1b" translate="yes" xml:space="preserve">
          <source>Config variables</source>
          <target state="translated">配置变量</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="acdba8395423767de730ee1b75436df3a0ebc87e" translate="yes" xml:space="preserve">
          <source>Configuration file</source>
          <target state="translated">配置文件</target>
        </trans-unit>
        <trans-unit id="70c34b77eccd45b690bac76f834e5695507ca571" translate="yes" xml:space="preserve">
          <source>Configuration mechanism</source>
          <target state="translated">配置机制</target>
        </trans-unit>
        <trans-unit id="f4d40d6c54ed064cd5675e2b020be36dc38807c6" translate="yes" xml:space="preserve">
          <source>Configuration options</source>
          <target state="translated">配置选项</target>
        </trans-unit>
        <trans-unit id="38b23d1375544f4a68ea9228188041f47459e054" translate="yes" xml:space="preserve">
          <source>Configuration variables</source>
          <target state="translated">配置变量</target>
        </trans-unit>
        <trans-unit id="8a66ea31ab3d6b079e67d729ad34365bb857146f" translate="yes" xml:space="preserve">
          <source>Configure a &quot;tar.xz&quot; format for making LZMA-compressed tarfiles. You can use it specifying &lt;code&gt;--format=tar.xz&lt;/code&gt;, or by creating an output file like &lt;code&gt;-o foo.tar.xz&lt;/code&gt;.</source>
          <target state="translated">配置&amp;ldquo; tar.xz&amp;rdquo;格式以制作LZMA压缩的tarfile。您可以通过指定 &lt;code&gt;--format=tar.xz&lt;/code&gt; 或通过创建输出文件（如 &lt;code&gt;-o foo.tar.xz&lt;/code&gt; )来使用它。</target>
        </trans-unit>
        <trans-unit id="f6a6815a7f24dfffdb1d929dd323aaec05a9ab47" translate="yes" xml:space="preserve">
          <source>Configure a &lt;code&gt;fix&lt;/code&gt; trailer with a key that contains a &lt;code&gt;#&lt;/code&gt; and no space after this character, and show how it works:</source>
          <target state="translated">使用包含 &lt;code&gt;#&lt;/code&gt; 且该字符后没有空格的键来配置 &lt;code&gt;fix&lt;/code&gt; 预告片，并显示其工作方式：</target>
        </trans-unit>
        <trans-unit id="ce90c0bc932e5f1df9b68ee7ec6c0da58d747ea5" translate="yes" xml:space="preserve">
          <source>Configure a &lt;code&gt;see&lt;/code&gt; trailer with a command to show the subject of a commit that is related, and show how it works:</source>
          <target state="translated">使用命令配置 &lt;code&gt;see&lt;/code&gt; 拖车，以显示相关提交的主题，并显示其工作方式：</target>
        </trans-unit>
        <trans-unit id="c9ccaafdcef74174cf7734bdb6a6d7caabe83888" translate="yes" xml:space="preserve">
          <source>Configure a &lt;code&gt;sign&lt;/code&gt; trailer with a &lt;code&gt;Signed-off-by&lt;/code&gt; key, and then add two of these trailers to a message:</source>
          <target state="translated">配置 &lt;code&gt;sign&lt;/code&gt; 拖车带 &lt;code&gt;Signed-off-by&lt;/code&gt; 键，然后添加两个这些拖车的消息：</target>
        </trans-unit>
        <trans-unit id="e0f5abc21cdfc10087712a4df06b45d6f1ed9b35" translate="yes" xml:space="preserve">
          <source>Configure a &lt;code&gt;sign&lt;/code&gt; trailer with a command to automatically add a 'Signed-off-by: ' with the author information only if there is no 'Signed-off-by: ' already, and show how it works:</source>
          <target state="translated">使用命令配置 &lt;code&gt;sign&lt;/code&gt; 预告片，以仅在尚无&amp;ldquo; Signed-off-by：&amp;rdquo;的情况下自动添加带有作者信息的&amp;ldquo; Signed-off ::&amp;rdquo;，并显示其工作方式：</target>
        </trans-unit>
        <trans-unit id="f50c440d2f6f9060cd052adb1632feec1a0c614d" translate="yes" xml:space="preserve">
          <source>Configure a commit template with some trailers with empty values (using sed to show and keep the trailing spaces at the end of the trailers), then configure a commit-msg hook that uses &lt;code&gt;git interpret-trailers&lt;/code&gt; to remove trailers with empty values and to add a &lt;code&gt;git-version&lt;/code&gt; trailer:</source>
          <target state="translated">使用一些带有空值的预告片配置提交模板（使用sed在预告片的末尾显示并保留尾随空格），然后配置使用 &lt;code&gt;git interpret-trailers&lt;/code&gt; 的commit-msg挂钩，以删除具有空值的预告片并添加一个 &lt;code&gt;git-version&lt;/code&gt; 预告片：</target>
        </trans-unit>
        <trans-unit id="3f6c615a6da0f7262f6f2dbcc08ecf276b931a9e" translate="yes" xml:space="preserve">
          <source>Configure your general composition window to not wrap.</source>
          <target state="translated">配置你的普通构图窗口不进行封装。</target>
        </trans-unit>
        <trans-unit id="3551290f2193aa1e636343f0cbcbc633f639f8c4" translate="yes" xml:space="preserve">
          <source>Configure your mail server composition as plain text: Edit&amp;hellip;​Account Settings&amp;hellip;​Composition &amp;amp; Addressing, uncheck &quot;Compose Messages in HTML&quot;.</source>
          <target state="translated">将您的邮件服务器组成配置为纯文本：编辑...帐户设置...组成和地址，取消选中&amp;ldquo;用HTML编写邮件&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3e29b2ee31b493715ce39183ea79ba9aca718b3b" translate="yes" xml:space="preserve">
          <source>Configured remote-tracking branches</source>
          <target state="translated">配置了远程跟踪分支</target>
        </trans-unit>
        <trans-unit id="4976060b350e89ec5dfdb2a1c1950efb45f52bc3" translate="yes" xml:space="preserve">
          <source>Configuring database backend</source>
          <target state="translated">配置数据库后端</target>
        </trans-unit>
        <trans-unit id="c983b7934801a3688ed66b5498ab09519448fc97" translate="yes" xml:space="preserve">
          <source>Configuring gitweb features</source>
          <target state="translated">配置gitweb功能</target>
        </trans-unit>
        <trans-unit id="40e0a19569f8f1844d5a471098cc89ca36d5ca64" translate="yes" xml:space="preserve">
          <source>Configuring remote-tracking branches</source>
          <target state="translated">配置远程跟踪分支</target>
        </trans-unit>
        <trans-unit id="9e40cad468539cb8231b63b11fdb5df741e2d14b" translate="yes" xml:space="preserve">
          <source>Confirm just before sending:</source>
          <target state="translated">在发送前确认。</target>
        </trans-unit>
        <trans-unit id="ecda02ba517320c0b15d176b3e447e83063fff66" translate="yes" xml:space="preserve">
          <source>Conflict markers are left in the problematic files, and after you resolve the conflicts manually, you can update the index with the contents and run Git commit, as you normally would when creating a new file.</source>
          <target state="translated">冲突标记会留在有问题的文件中,手动解决冲突后,可以像平常创建新文件时一样,用内容更新索引并运行Git提交。</target>
        </trans-unit>
        <trans-unit id="b82d334ed6758888e34c8a34df72370a5d90993b" translate="yes" xml:space="preserve">
          <source>Conflicts can occur when applying a commit to p4. When this happens, the default behavior (&quot;ask&quot;) is to prompt whether to skip this commit and continue, or quit. This option can be used to bypass the prompt, causing conflicting commits to be automatically skipped, or to quit trying to apply commits, without prompting.</source>
          <target state="translated">在对 p4 进行提交时,可能会发生冲突。当这种情况发生时,默认的行为(&quot;ask&quot;)是提示是否跳过这个提交并继续,或者退出。这个选项可以用来绕过提示,导致冲突的提交被自动跳过,或者退出尝试提交,而无需提示。</target>
        </trans-unit>
        <trans-unit id="d9246582c40c7034c419d5e149871effa77f01da" translate="yes" xml:space="preserve">
          <source>Connects to given service. Standard input and standard output of helper are connected to specified service (git prefix is included in service name so e.g. fetching uses &lt;code&gt;git-upload-pack&lt;/code&gt; as service) on remote side. Valid replies to this command are empty line (connection established), &lt;code&gt;fallback&lt;/code&gt; (no smart transport support, fall back to dumb transports) and just exiting with error message printed (can&amp;rsquo;t connect, don&amp;rsquo;t bother trying to fall back). After line feed terminating the positive (empty) response, the output of service starts. After the connection ends, the remote helper exits.</source>
          <target state="translated">连接到给定的服务。辅助程序的标准输入和标准输出连接到远程侧上的指定服务（服务名称中包含git前缀，因此，例如，获取使用 &lt;code&gt;git-upload-pack&lt;/code&gt; 作为服务）。对此命令的有效答复是：空行（建立连接）， &lt;code&gt;fallback&lt;/code&gt; （无智能传输支持，回退到哑传输）以及仅退出并显示错误消息（无法连接，不必费心尝试回退）。在换行终止正（空）响应之后，服务的输出开始。连接结束后，远程帮助程序将退出。</target>
        </trans-unit>
        <trans-unit id="ab69689298b341c622fdf07baf6d7935162cc21e" translate="yes" xml:space="preserve">
          <source>Consider &lt;code&gt;.gitattributes&lt;/code&gt; in the index only, ignoring the working tree.</source>
          <target state="translated">仅考虑 &lt;code&gt;.gitattributes&lt;/code&gt; 中的.gitattributes，而忽略工作树。</target>
        </trans-unit>
        <trans-unit id="2e9b2aca01cec344e42ddb2f6c4d43d446641ec6" translate="yes" xml:space="preserve">
          <source>Consider any object recorded in the index also as a head node for an unreachability trace.</source>
          <target state="translated">将索引中记录的任何对象也视为不可到达性跟踪的头节点。</target>
        </trans-unit>
        <trans-unit id="5dd8963c37ba70016cc97181d1437d9d279837cb" translate="yes" xml:space="preserve">
          <source>Consider only commits that are enough to explain how the files that match the specified paths came to be.</source>
          <target state="translated">只考虑那些足以解释与指定路径相匹配的文件是如何产生的提交。</target>
        </trans-unit>
        <trans-unit id="ba0254d514d0f2ca6e4ebd12fd91b2a48fa85b1d" translate="yes" xml:space="preserve">
          <source>Consider the following .gitmodules file:</source>
          <target state="translated">考虑以下.gitmodules文件。</target>
        </trans-unit>
        <trans-unit id="8a3a2dda249f0930d1314682106ca1561464766d" translate="yes" xml:space="preserve">
          <source>Consider the limiting patterns to be Perl-compatible regular expressions.</source>
          <target state="translated">认为限制模式是Perl兼容的正则表达式。</target>
        </trans-unit>
        <trans-unit id="d3cbcdfc580ee16544a677fdcaea7364f6ffede7" translate="yes" xml:space="preserve">
          <source>Consider the limiting patterns to be basic regular expressions; this is the default.</source>
          <target state="translated">认为限制模式是基本的正则表达式,这是默认的。</target>
        </trans-unit>
        <trans-unit id="cc80930760a8dae17ccff09b94b94b8c2a73e3d6" translate="yes" xml:space="preserve">
          <source>Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions.</source>
          <target state="translated">认为限制模式是扩展的正则表达式,而不是默认的基本正则表达式。</target>
        </trans-unit>
        <trans-unit id="0bd0c2e95b3ce3558e3f029a387e02dcaec9fc10" translate="yes" xml:space="preserve">
          <source>Consider the limiting patterns to be fixed strings (don&amp;rsquo;t interpret pattern as a regular expression).</source>
          <target state="translated">将限制模式视为固定字符串（不要将模式解释为正则表达式）。</target>
        </trans-unit>
        <trans-unit id="ce08a982fc80bf880f9e5e7fbbc19290d0e13642" translate="yes" xml:space="preserve">
          <source>Consider this history:</source>
          <target state="translated">考虑到这段历史。</target>
        </trans-unit>
        <trans-unit id="6e0518d23c6b434e11a17284519d985d575f8d5b" translate="yes" xml:space="preserve">
          <source>Considers adding content from all git-*.sh scripts:</source>
          <target state="translated">考虑从所有git-*.sh脚本中添加内容。</target>
        </trans-unit>
        <trans-unit id="aa183b32e2469308bcac751961ddf4f45522d312" translate="yes" xml:space="preserve">
          <source>Construct a commit message for use with &lt;code&gt;rebase --autosquash&lt;/code&gt;. The commit message subject line is taken from the specified commit with a prefix of &quot;squash! &quot;. Can be used with additional commit message options (&lt;code&gt;-m&lt;/code&gt;/&lt;code&gt;-c&lt;/code&gt;/&lt;code&gt;-C&lt;/code&gt;/&lt;code&gt;-F&lt;/code&gt;). See &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details.</source>
          <target state="translated">构造一个与 &lt;code&gt;rebase --autosquash&lt;/code&gt; 一起使用的提交消息。提交消息主题行是从具有&amp;ldquo; squash！&amp;rdquo;前缀的指定提交中提取的。可以与其他提交消息选项（ &lt;code&gt;-m&lt;/code&gt; / &lt;code&gt;-c&lt;/code&gt; / &lt;code&gt;-C&lt;/code&gt; / &lt;code&gt;-F&lt;/code&gt; ）一起使用。有关详细信息，请参见&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="613af883ed6da1442ba9d47b0f082fab42f334c7" translate="yes" xml:space="preserve">
          <source>Construct a commit message for use with &lt;code&gt;rebase --autosquash&lt;/code&gt;. The commit message will be the subject line from the specified commit with a prefix of &quot;fixup! &quot;. See &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details.</source>
          <target state="translated">构造一个与 &lt;code&gt;rebase --autosquash&lt;/code&gt; 一起使用的提交消息。提交消息将是指定提交的主题行，其前缀为&amp;ldquo; fixup！&amp;rdquo;。有关详细信息，请参见&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26410cb72d41a741e69a55d63cb8badf7f0b0bd2" translate="yes" xml:space="preserve">
          <source>Contains administrative data for linked working trees. Each subdirectory contains the working tree-related part of a linked working tree. This directory is ignored if $GIT_COMMON_DIR is set, in which case &quot;$GIT_COMMON_DIR/worktrees&quot; will be used instead.</source>
          <target state="translated">包含链接工作树的管理数据。每一个子目录都包含了链接工作树的相关部分,如果设置了$GIT_COMMON_DIR,这个目录将被忽略。如果设置了 $GIT_COMMON_DIR,这个目录将被忽略,在这种情况下,将使用 &quot;$GIT_COMMON_DIR/worktrees &quot;代替。</target>
        </trans-unit>
        <trans-unit id="926bb57bf277ea775a3bccb0602b810a03d08da9" translate="yes" xml:space="preserve">
          <source>Contains the git-repositories of the submodules.</source>
          <target state="translated">包含子模块的git仓库。</target>
        </trans-unit>
        <trans-unit id="2017a3b0e62c7744478a46c444d4d27cb868b22a" translate="yes" xml:space="preserve">
          <source>Content which does not differ between the index and working tree may be shown on context lines, beginning with a &quot; &quot; (space). You can stage context lines for removal by converting the space to a &quot;-&quot;. The resulting working tree file will appear to re-add the content.</source>
          <target state="translated">索引和工作树之间没有区别的内容可以显示在上下文行上,以&quot;&quot;(空格)开头。您可以通过将空格转换为&quot;-&quot;来对上下文行进行删除。由此产生的工作树文件将显示为重新添加的内容。</target>
        </trans-unit>
        <trans-unit id="475c13751eb255f66e4aec9a66a81a56d379a598" translate="yes" xml:space="preserve">
          <source>Continue listing the history of a file beyond renames (works only for a single file).</source>
          <target state="translated">在重命名之后继续列出文件的历史记录(只对单个文件有效)。</target>
        </trans-unit>
        <trans-unit id="4798719de8c426782f7160e2b872b0281bb19c57" translate="yes" xml:space="preserve">
          <source>Continue the operation in progress using the information in &lt;code&gt;.git/sequencer&lt;/code&gt;. Can be used to continue after resolving conflicts in a failed cherry-pick or revert.</source>
          <target state="translated">使用 &lt;code&gt;.git/sequencer&lt;/code&gt; 中的信息继续进行中的操作。在解决失败的樱桃选择或还原中的冲突后，可用于继续操作。</target>
        </trans-unit>
        <trans-unit id="75e8c6f43c030fe85b04f600a5aefef84d4215ca" translate="yes" xml:space="preserve">
          <source>Continue the rebase with &lt;code&gt;git rebase --continue&lt;/code&gt;.</source>
          <target state="translated">继续使用 &lt;code&gt;git rebase --continue&lt;/code&gt; 进行重新设置。</target>
        </trans-unit>
        <trans-unit id="fbb3e402bf66bc40e025c029cebd9e3786831d84" translate="yes" xml:space="preserve">
          <source>Continuing with our test-project, let&amp;rsquo;s modify file.txt again:</source>
          <target state="translated">继续我们的测试项目，让我们再次修改file.txt：</target>
        </trans-unit>
        <trans-unit id="6f930d8a34d56a441268a0623f0c037df7494b75" translate="yes" xml:space="preserve">
          <source>Control GSSAPI credential delegation. The delegation is disabled by default in libcurl since version 7.21.7. Set parameter to tell the server what it is allowed to delegate when it comes to user credentials. Used with GSS/kerberos. Possible values are:</source>
          <target state="translated">控制GSSAPI证书授权。自7.21.7版本起,libcurl默认禁用授权。设置参数来告诉服务器,当涉及到用户凭证时,它可以委托什么。与GSS/kerberos一起使用。可能的值是</target>
        </trans-unit>
        <trans-unit id="732c632643ca337cd77cc6d082dfc0d1c8e3c9e5" translate="yes" xml:space="preserve">
          <source>Control how information about the commits in the local repository is sent when negotiating the contents of the packfile to be sent by the server. Set to &quot;skipping&quot; to use an algorithm that skips commits in an effort to converge faster, but may result in a larger-than-necessary packfile; The default is &quot;default&quot; which instructs Git to use the default algorithm that never skips commits (unless the server has acknowledged it or one of its descendants). If &lt;code&gt;feature.experimental&lt;/code&gt; is enabled, then this setting defaults to &quot;skipping&quot;. Unknown values will cause &lt;code&gt;git fetch&lt;/code&gt; to error out.</source>
          <target state="translated">控制在协商服务器要发送的packfile内容时如何发送有关本地存储库中提交的信息。设置为&amp;ldquo;跳过&amp;rdquo;以使用跳过提交的算法，以加快收敛速度​​，但可能会导致所需的packfile更大。默认值为&amp;ldquo; default&amp;rdquo;，它指示Git使用永不跳过提交的默认算法（除非服务器已确认它或其后代之一）。如果启用了 &lt;code&gt;feature.experimental&lt;/code&gt; ，则此设置默认为&amp;ldquo;跳过&amp;rdquo;。未知值将导致 &lt;code&gt;git fetch&lt;/code&gt; 错误输出。</target>
        </trans-unit>
        <trans-unit id="aa2d757e789e92329feff3e9e393ffe1cf9826bc" translate="yes" xml:space="preserve">
          <source>Control how ref update status is printed. Valid values are &lt;code&gt;full&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt;. Default value is &lt;code&gt;full&lt;/code&gt;. See section OUTPUT in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; for detail.</source>
          <target state="translated">控制如何打印参考更新状态。有效值是 &lt;code&gt;full&lt;/code&gt; 且 &lt;code&gt;compact&lt;/code&gt; 。默认值是 &lt;code&gt;full&lt;/code&gt; 。有关详细信息，请参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]中的&lt;/a&gt; OUTPUT部分。</target>
        </trans-unit>
        <trans-unit id="8e05cd92bb18e6dbe129763361ebf98f054218bc" translate="yes" xml:space="preserve">
          <source>Control the order in which files appear in the output. This overrides the &lt;code&gt;diff.orderFile&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). To cancel &lt;code&gt;diff.orderFile&lt;/code&gt;, use &lt;code&gt;-O/dev/null&lt;/code&gt;.</source>
          <target state="translated">控制文件在输出中出现的顺序。这将覆盖 &lt;code&gt;diff.orderFile&lt;/code&gt; 配置变量（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。要取消 &lt;code&gt;diff.orderFile&lt;/code&gt; ，请使用 &lt;code&gt;-O/dev/null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95cfa5bd9ed3c9eff692bd91fe02de0af906819b" translate="yes" xml:space="preserve">
          <source>Controlling access to Git repositories</source>
          <target state="translated">控制对Git仓库的访问</target>
        </trans-unit>
        <trans-unit id="302680d7e637a6c4d28c5bc8380af3a8487a3fd0" translate="yes" xml:space="preserve">
          <source>Controlling the daemon</source>
          <target state="translated">控制守护进程</target>
        </trans-unit>
        <trans-unit id="5f8b43605d2bc36ca036762a54d85472bbaf393e" translate="yes" xml:space="preserve">
          <source>Controls addition of &lt;code&gt;In-Reply-To&lt;/code&gt; and &lt;code&gt;References&lt;/code&gt; headers to make the second and subsequent mails appear as replies to the first. Also controls generation of the &lt;code&gt;Message-Id&lt;/code&gt; header to reference.</source>
          <target state="translated">控制&amp;ldquo; &lt;code&gt;In-Reply-To&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;References&lt;/code&gt; &amp;rdquo;标题的添加，以使第二封邮件和后续邮件作为对第一封邮件的答复。还控制要引用的 &lt;code&gt;Message-Id&lt;/code&gt; 标头的生成。</target>
        </trans-unit>
        <trans-unit id="2d73e883baf4d5a02fe3808167b349dacd41e248" translate="yes" xml:space="preserve">
          <source>Controls the amount of output shown by the recursive merge strategy. Level 0 outputs nothing except a final error message if conflicts were detected. Level 1 outputs only conflicts, 2 outputs conflicts and file changes. Level 5 and above outputs debugging information. The default is level 2. Can be overridden by the &lt;code&gt;GIT_MERGE_VERBOSITY&lt;/code&gt; environment variable.</source>
          <target state="translated">控制递归合并策略显示的输出量。如果检测到冲突，级别0除了最终错误消息外什么也不会输出。级别1仅输出冲突，级别2输出冲突和文件更改。5级及以上级别输出调试信息。默认值为级别2。可以被 &lt;code&gt;GIT_MERGE_VERBOSITY&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="d76ea066512503130cc69199cf2d62634818fae1" translate="yes" xml:space="preserve">
          <source>Controls whether one-level refnames are accepted (i.e., refnames that do not contain multiple &lt;code&gt;/&lt;/code&gt;-separated components). The default is &lt;code&gt;--no-allow-onelevel&lt;/code&gt;.</source>
          <target state="translated">控制是否接受一级引用名称（即，不包含多个 &lt;code&gt;/&lt;/code&gt; 分隔的组件的引用名称）。默认值为 &lt;code&gt;--no-allow-onelevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65d9a75f19717f80d02990ede6313f9c8dc92c2a" translate="yes" xml:space="preserve">
          <source>Controls which diff tool is used by &lt;a href=&quot;git-difftool&quot;&gt;git-difftool[1]&lt;/a&gt; when the -g/--gui flag is specified. This variable overrides the value configured in &lt;code&gt;merge.guitool&lt;/code&gt;. The list below shows the valid built-in values. Any other value is treated as a custom diff tool and requires that a corresponding difftool.&amp;lt;guitool&amp;gt;.cmd variable is defined.</source>
          <target state="translated">当指定-g / &lt;a href=&quot;git-difftool&quot;&gt;-gui&lt;/a&gt;标志时，控制git-difftool [1]使用哪个diff工具。此变量将覆盖 &lt;code&gt;merge.guitool&lt;/code&gt; 中配置的值。下面的列表显示了有效的内置值。任何其他值都被视为自定义差异工具，并且需要定义相应的difftool。&amp;lt;guitool&amp;gt; .cmd变量。</target>
        </trans-unit>
        <trans-unit id="866c417f86e708b803c2ccd6543f9e30d5664def" translate="yes" xml:space="preserve">
          <source>Controls which diff tool is used by &lt;a href=&quot;git-difftool&quot;&gt;git-difftool[1]&lt;/a&gt;. This variable overrides the value configured in &lt;code&gt;merge.tool&lt;/code&gt;. The list below shows the valid built-in values. Any other value is treated as a custom diff tool and requires that a corresponding difftool.&amp;lt;tool&amp;gt;.cmd variable is defined.</source>
          <target state="translated">控制&lt;a href=&quot;git-difftool&quot;&gt;git-difftool [1]&lt;/a&gt;使用哪个diff工具。此变量将覆盖 &lt;code&gt;merge.tool&lt;/code&gt; 中配置的值。下面的列表显示了有效的内置值。任何其他值都将被视为自定义差异工具，并且需要定义相应的difftool。&amp;lt;tool&amp;gt; .cmd变量。</target>
        </trans-unit>
        <trans-unit id="5cb013e070a3b4cddc50474dc321b1da7ea13759" translate="yes" xml:space="preserve">
          <source>Controls which merge tool is used by &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt; when the -g/--gui flag is specified. The list below shows the valid built-in values. Any other value is treated as a custom merge tool and requires that a corresponding mergetool.&amp;lt;guitool&amp;gt;.cmd variable is defined.</source>
          <target state="translated">当指定-g /-gui标志时，控制&lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool [1]&lt;/a&gt;使用哪个合并工具。下面的列表显示了有效的内置值。任何其他值都被视为自定义合并工具，并且需要定义相应的mergetool。&amp;lt;guitool&amp;gt; .cmd变量。</target>
        </trans-unit>
        <trans-unit id="18ee15c4e31cbcbd84b87172e325dafb065adff0" translate="yes" xml:space="preserve">
          <source>Controls which merge tool is used by &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt;. The list below shows the valid built-in values. Any other value is treated as a custom merge tool and requires that a corresponding mergetool.&amp;lt;tool&amp;gt;.cmd variable is defined.</source>
          <target state="translated">控制&lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool [1]&lt;/a&gt;使用哪个合并工具。下面的列表显示了有效的内置值。其他任何值都被视为自定义合并工具，并且需要定义相应的mergetool。&amp;lt;tool&amp;gt; .cmd变量。</target>
        </trans-unit>
        <trans-unit id="474792f82dd9247329dbb1b3dcfbbed1c865f4c2" translate="yes" xml:space="preserve">
          <source>Controls which parts of the cover letter will be automatically populated using the branch&amp;rsquo;s description.</source>
          <target state="translated">控制使用分支的说明自动填充求职信的哪些部分。</target>
        </trans-unit>
        <trans-unit id="c3102343a37aa52f6a069dc8bc5f12c9420d06d2" translate="yes" xml:space="preserve">
          <source>Conventions for public functions and macros</source>
          <target state="translated">公共函数和宏的约定</target>
        </trans-unit>
        <trans-unit id="24ce25558484789421068a0f3fdf9552add6eb44" translate="yes" xml:space="preserve">
          <source>Conversely, text files that Git does not detect can have normalization enabled manually.</source>
          <target state="translated">相反,Git 没有检测到的文本文件可以手动启用标准化。</target>
        </trans-unit>
        <trans-unit id="e49f6aaa8529aed7e4294b528b8e93971284c07e" translate="yes" xml:space="preserve">
          <source>Convert raw file data into a blob, for future use in a &lt;code&gt;commit&lt;/code&gt; command. This command is optional and is not needed to perform an import.</source>
          <target state="translated">将原始文件数据转换为Blob，以供将来在 &lt;code&gt;commit&lt;/code&gt; 命令中使用。该命令是可选的，不需要执行导入。</target>
        </trans-unit>
        <trans-unit id="30c15e3645b0a2e6438456f892ca0f7bb2ab425e" translate="yes" xml:space="preserve">
          <source>Convert underscores in tag and branch names to dots.</source>
          <target state="translated">将标签和分支名称中的下划线转换为点。</target>
        </trans-unit>
        <trans-unit id="717ec262f5a03d7fab61894de5327ed8b2dce9d6" translate="yes" xml:space="preserve">
          <source>Copy a branch and the corresponding reflog.</source>
          <target state="translated">复制一个分支和相应的重新记录。</target>
        </trans-unit>
        <trans-unit id="d010ed84eae444d5db43ea15cd0c22cd88feae0f" translate="yes" xml:space="preserve">
          <source>Copy files from the index to the working tree</source>
          <target state="translated">将文件从索引中复制到工作树中</target>
        </trans-unit>
        <trans-unit id="c76ee4ad9dd156a08ecfefcfcb1c22de051a4c57" translate="yes" xml:space="preserve">
          <source>Copy over the packed files from &quot;project lead&quot; public repository to your public repository, unless the &quot;project lead&quot; repository lives on the same machine as yours. In the latter case, you can use &lt;code&gt;objects/info/alternates&lt;/code&gt; file to point at the repository you are borrowing from.</source>
          <target state="translated">将打包的文件从&amp;ldquo;项目负责人&amp;rdquo;公共资源库复制到您的公共资源库，除非&amp;ldquo;项目负责人&amp;rdquo;资源库与您的计算机位于同一台计算机上。在后一种情况下，您可以使用 &lt;code&gt;objects/info/alternates&lt;/code&gt; 文件来指向您要从中借用的存储库。</target>
        </trans-unit>
        <trans-unit id="d8b3dca28c0ddf8873f77c43f29755622d908cce" translate="yes" xml:space="preserve">
          <source>Copy the Message-ID header at the end of the commit message. This is useful in order to associate commits with mailing list discussions.</source>
          <target state="translated">在提交信息的结尾处复制Message-ID头。这对于将提交与邮件列表讨论关联起来很有用。</target>
        </trans-unit>
        <trans-unit id="5a3f70a82898c2a8456ad61672927bc441665238" translate="yes" xml:space="preserve">
          <source>Copy the modified files to a temporary location and perform a directory diff on them. This mode never prompts before launching the diff tool.</source>
          <target state="translated">将修改后的文件复制到一个临时位置,并对其进行目录比较。这种模式在启动diff工具前从不提示。</target>
        </trans-unit>
        <trans-unit id="c190e9af114c74dc1cae547f652783f706162e52" translate="yes" xml:space="preserve">
          <source>Copy the notes for the first object onto the second object (defaults to HEAD). Abort if the second object already has notes, or if the first object has none (use -f to overwrite existing notes to the second object). This subcommand is equivalent to: &lt;code&gt;git notes add [-f] -C $(git notes list &amp;lt;from-object&amp;gt;) &amp;lt;to-object&amp;gt;&lt;/code&gt;</source>
          <target state="translated">将第一个对象的注释复制到第二个对象上（默认为HEAD）。如果第二个对象已经有注释，或者如果第一个对象没有注释，则中止（使用-f覆盖第二个对象的现有注释）。此子命令等效于： &lt;code&gt;git notes add [-f] -C $(git notes list &amp;lt;from-object&amp;gt;) &amp;lt;to-object&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f67d1ba5e94aaa446c4cd38a50c12bd9c63d60dc" translate="yes" xml:space="preserve">
          <source>Copying repositories</source>
          <target state="translated">复制存储库</target>
        </trans-unit>
        <trans-unit id="36e54cbb8f2eeebb702575f30e1a34b2297f308c" translate="yes" xml:space="preserve">
          <source>Core git executable to use. By default set to &lt;code&gt;$GIT_BINDIR/git&lt;/code&gt;, which in turn is by default set to &lt;code&gt;$(bindir)/git&lt;/code&gt;. If you use Git installed from a binary package, you should usually set this to &quot;/usr/bin/git&quot;. This can just be &quot;git&quot; if your web server has a sensible PATH; from security point of view it is better to use absolute path to git binary. If you have multiple Git versions installed it can be used to choose which one to use. Must be (correctly) set for gitweb to be able to work.</source>
          <target state="translated">要使用的核心git可执行文件。默认情况下设置为 &lt;code&gt;$GIT_BINDIR/git&lt;/code&gt; ，默认情况下又设置为 &lt;code&gt;$(bindir)/git&lt;/code&gt; 。如果使用从二进制软件包安装的Git，通常应将其设置为&amp;ldquo; / usr / bin / git&amp;rdquo;。如果您的Web服务器具有明智的PATH，则可能只是&amp;ldquo; git&amp;rdquo;。从安全角度来看，最好使用绝对路径来生成git二进制文件。如果您安装了多个Git版本，则可以使用它来选择使用哪个版本。必须（正确）设置gitweb才能工作。</target>
        </trans-unit>
        <trans-unit id="85a8806cd8d64571a9c2262e310bf038f08a1274" translate="yes" xml:space="preserve">
          <source>Count changes in a child directory for the parent directory as well. Note that when using &lt;code&gt;cumulative&lt;/code&gt;, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the &lt;code&gt;noncumulative&lt;/code&gt; parameter.</source>
          <target state="translated">同样在父目录的子目录中计算更改。请注意，使用 &lt;code&gt;cumulative&lt;/code&gt; ，报告的百分比之和可能超过100％。可以使用 &lt;code&gt;noncumulative&lt;/code&gt; 参数指定默认（非累积）行为。</target>
        </trans-unit>
        <trans-unit id="492f2e2be05a1aa8d8af437be99e7dacb8d4f9d0" translate="yes" xml:space="preserve">
          <source>Count unpacked number of objects and their disk consumption</source>
          <target state="translated">统计未打包的对象数量和它们的磁盘消耗。</target>
        </trans-unit>
        <trans-unit id="763b234fba543bb2523cf09d67150c10446b45b7" translate="yes" xml:space="preserve">
          <source>Countermand &lt;code&gt;commit.gpgSign&lt;/code&gt; configuration variable that is set to force each and every commit to be signed.</source>
          <target state="translated">Countermand &lt;code&gt;commit.gpgSign&lt;/code&gt; 配置变量，该变量设置为强制对每个提交进行签名。</target>
        </trans-unit>
        <trans-unit id="6096cddc00ec928df60a796e3d4cfb0bb68acdbe" translate="yes" xml:space="preserve">
          <source>Counting the number of commits on a branch</source>
          <target state="translated">计算一个分支的提交次数。</target>
        </trans-unit>
        <trans-unit id="5c28a68396ec48f8ddfeca624f27118d20e2f2ea" translate="yes" xml:space="preserve">
          <source>Crash reports</source>
          <target state="translated">碰撞报告</target>
        </trans-unit>
        <trans-unit id="97b6cc167e6a90cd26177184d37208b481756eef" translate="yes" xml:space="preserve">
          <source>Create &amp;lt;ref&amp;gt; with &amp;lt;newvalue&amp;gt; after verifying it does not exist. The given &amp;lt;newvalue&amp;gt; may not be zero.</source>
          <target state="translated">确认&amp;lt;ref&amp;gt;不存在后，用&amp;lt;newvalue&amp;gt;创建它。给定的&amp;lt;newvalue&amp;gt;不能为零。</target>
        </trans-unit>
        <trans-unit id="5d3e6679c48a19f8a3804fc16c43252c9d4a1106" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; and checkout &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; into it. The new working directory is linked to the current repository, sharing everything except working directory specific files such as HEAD, index, etc. &lt;code&gt;-&lt;/code&gt; may also be specified as &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;; it is synonymous with &lt;code&gt;@{-1}&lt;/code&gt;.</source>
          <target state="translated">创建 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 并签入 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 。新的工作目录链接到当前存储库，共享一切，除了工作目录的特定文件，例如HEAD，索引等 &lt;code&gt;-&lt;/code&gt; 也可被指定为 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; ; 它是 &lt;code&gt;@{-1}&lt;/code&gt; 同义词。</target>
        </trans-unit>
        <trans-unit id="918c3c2a066586184896c329601a42f88338b5c6" translate="yes" xml:space="preserve">
          <source>Create a &quot;thin&quot; pack by omitting the common objects between a sender and a receiver in order to reduce network transfer. This option only makes sense in conjunction with --stdout.</source>
          <target state="translated">通过省略发送方和接收方之间的共同对象来创建一个 &quot;瘦 &quot;包,以减少网络传输。这个选项只有和-stdout一起使用才有意义。</target>
        </trans-unit>
        <trans-unit id="ec9cb277fe09464e753dba1a9c058b6a9566ff6f" translate="yes" xml:space="preserve">
          <source>Create a /path/to/my/codebase/.git directory.</source>
          <target state="translated">创建一个/path/to/my/codebase/.git目录。</target>
        </trans-unit>
        <trans-unit id="c0a6d61d3fd0fcaf6c684be3f4ae17d7a1fadcb9" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;shallow&lt;/code&gt; clone with a history truncated to the specified number of commits. Implies &lt;code&gt;--single-branch&lt;/code&gt; unless &lt;code&gt;--no-single-branch&lt;/code&gt; is given to fetch the histories near the tips of all branches. If you want to clone submodules shallowly, also pass &lt;code&gt;--shallow-submodules&lt;/code&gt;.</source>
          <target state="translated">创建一个 &lt;code&gt;shallow&lt;/code&gt; 克隆，其历史记录被截断为指定的提交数。表示 &lt;code&gt;--single-branch&lt;/code&gt; ,除非给出 &lt;code&gt;--no-single-branch&lt;/code&gt; 来获取所有分支的尖端附近的历史记录。如果要浅层克隆子模块，则还要传递 &lt;code&gt;--shallow-submodules&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efb2e81b939b9a77d43ecb93b07dc1f2ed7276af" translate="yes" xml:space="preserve">
          <source>Create a Zip archive that contains the contents of the latest commit on the current branch. Note that the output format is inferred by the extension of the output file.</source>
          <target state="translated">创建一个包含当前分支最新提交内容的 Zip 档案。请注意,输出格式由输出文件的扩展名来推断。</target>
        </trans-unit>
        <trans-unit id="98ed6a63ab53ebc7b5cb53eddb5b05ee6e17c097" translate="yes" xml:space="preserve">
          <source>Create a bare repository to publish your changes to the public:</source>
          <target state="translated">创建一个裸仓库来向公众发布你的更改。</target>
        </trans-unit>
        <trans-unit id="8ecd6ae5a1546c899c5e4d339f3b41e08bfa5878" translate="yes" xml:space="preserve">
          <source>Create a bare repository. If &lt;code&gt;GIT_DIR&lt;/code&gt; environment is not set, it is set to the current working directory.</source>
          <target state="translated">创建一个裸仓库。如果未设置 &lt;code&gt;GIT_DIR&lt;/code&gt; 环境，则将其设置为当前工作目录。</target>
        </trans-unit>
        <trans-unit id="8d2657b83c3c9eabb4154adbe14301af394e1de8" translate="yes" xml:space="preserve">
          <source>Create a branch in the SVN repository.</source>
          <target state="translated">在SVN仓库中创建一个分支。</target>
        </trans-unit>
        <trans-unit id="9535ca3b3bba3d55a9a78d2e5a327a9df5b9b7ac" translate="yes" xml:space="preserve">
          <source>Create a compressed tarball for v1.4.0 release, but without a global extended pax header.</source>
          <target state="translated">为v1.4.0版本创建一个压缩的tar包,但没有全局扩展的pax头。</target>
        </trans-unit>
        <trans-unit id="b5319dfc6eb9dc4a079ba2789cc4bdb586f57276" translate="yes" xml:space="preserve">
          <source>Create a compressed tarball for v1.4.0 release.</source>
          <target state="translated">为v1.4.0版本创建一个压缩压缩包。</target>
        </trans-unit>
        <trans-unit id="faa66e3a606f56a97105d3be717d6c143b22dab2" translate="yes" xml:space="preserve">
          <source>Create a graft commit. A new commit is created with the same content as &amp;lt;commit&amp;gt; except that its parents will be [&amp;lt;parent&amp;gt;&amp;hellip;​] instead of &amp;lt;commit&amp;gt;'s parents. A replacement ref is then created to replace &amp;lt;commit&amp;gt; with the newly created commit. Use &lt;code&gt;--convert-graft-file&lt;/code&gt; to convert a &lt;code&gt;$GIT_DIR/info/grafts&lt;/code&gt; file and use replace refs instead.</source>
          <target state="translated">创建嫁接提交。创建一个新提交的内容与&amp;lt;commit&amp;gt;相同，不同之处在于其父级将是[&amp;lt;parent&amp;gt; ...]，而不是&amp;lt;commit&amp;gt;的父级。然后创建一个替换引用，用新创建的提交替换&amp;lt;commit&amp;gt;。使用 &lt;code&gt;--convert-graft-file&lt;/code&gt; 转换 &lt;code&gt;$GIT_DIR/info/grafts&lt;/code&gt; 文件，并使用replace refs代替。</target>
        </trans-unit>
        <trans-unit id="571580d25d73e20010dd7b861b6579499c2d2548" translate="yes" xml:space="preserve">
          <source>Create a new &lt;code&gt;orphan&lt;/code&gt; branch, named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt;. All tracked files are removed.</source>
          <target state="translated">创建一个新的 &lt;code&gt;orphan&lt;/code&gt; 分支，名为 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 。删除所有跟踪的文件。</target>
        </trans-unit>
        <trans-unit id="4e15c57fd9f8556efdaf616337a8d6e6219013e8" translate="yes" xml:space="preserve">
          <source>Create a new &lt;code&gt;orphan&lt;/code&gt; branch, named &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt;, started from &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; and switch to it. The first commit made on this new branch will have no parents and it will be the root of a new history totally disconnected from all the other branches and commits.</source>
          <target state="translated">从 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 开始创建一个名为 &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; 的新 &lt;code&gt;orphan&lt;/code&gt; 分支，然后切换到该分支。在这个新分支上进行的第一次提交将没有父母，这将是与所有其他分支和提交完全脱节的新历史的根源。</target>
        </trans-unit>
        <trans-unit id="74397bf89a3d7366727db29fa6dec88cf03174e1" translate="yes" xml:space="preserve">
          <source>Create a new Git repository from an existing p4 repository using &lt;code&gt;git p4 clone&lt;/code&gt;, giving it one or more p4 depot paths. Incorporate new commits from p4 changes with &lt;code&gt;git p4 sync&lt;/code&gt;. The &lt;code&gt;sync&lt;/code&gt; command is also used to include new branches from other p4 depot paths. Submit Git changes back to p4 using &lt;code&gt;git p4 submit&lt;/code&gt;. The command &lt;code&gt;git p4 rebase&lt;/code&gt; does a sync plus rebases the current branch onto the updated p4 remote branch.</source>
          <target state="translated">使用 &lt;code&gt;git p4 clone&lt;/code&gt; 从现有的p4存储库中创建一个新的Git存储库，为它提供一个或多个p4库路径。从 &lt;code&gt;git p4 sync&lt;/code&gt; 合并p4更改中的新提交。该 &lt;code&gt;sync&lt;/code&gt; 命令也被用来从包括其他P4仓库路径新分支。提交使用 &lt;code&gt;git p4 submit&lt;/code&gt; Submit将Git更改回p4。 &lt;code&gt;git p4 rebase&lt;/code&gt; 命令执行同步，并将当前分支重新部署到更新的p4远程分支上。</target>
        </trans-unit>
        <trans-unit id="32283e2eb1bd521d20f1290e2eaa64ee550622d7" translate="yes" xml:space="preserve">
          <source>Create a new branch head pointing to one of these versions and check it out using &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt;:</source>
          <target state="translated">创建一个指向这些版本之一的新分支头，并使用&lt;a href=&quot;git-switch&quot;&gt;git-switch [1]将&lt;/a&gt;其检出：</target>
        </trans-unit>
        <trans-unit id="4de51286c04f5ea0c9795b4b604e6322cb3596eb" translate="yes" xml:space="preserve">
          <source>Create a new branch named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; starting at &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; before switching to the branch. This is a convenient shortcut for:</source>
          <target state="translated">从 &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; 开始创建一个名为 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 的新分支，然后再切换到该分支。这是方便的快捷方式：</target>
        </trans-unit>
        <trans-unit id="adb753b3b1e8742e8dfb04c8a3bbb9df0384a74c" translate="yes" xml:space="preserve">
          <source>Create a new branch named &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; and start it at &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">创建一个名为 &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; 的新分支，并在 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 处启动它；有关详细信息，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f67db00a28beeae8e81324408bce6703c7ea6026" translate="yes" xml:space="preserve">
          <source>Create a new commit containing the current contents of the index and the given log message describing the changes. The new commit is a direct child of HEAD, usually the tip of the current branch, and the branch is updated to point to it (unless no branch is associated with the working tree, in which case HEAD is &quot;detached&quot; as described in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;).</source>
          <target state="translated">创建一个新的提交，其中包含索引的当前内容以及描述更改的给定日志消息。新提交是HEAD的直接子项，通常是当前分支的尖端，并且分支被更新为指向它（除非没有分支与工作树相关联，在这种情况下，HEAD是&amp;ldquo;分离的&amp;rdquo;，如&lt;a href=&quot;git-checkout&quot;&gt;git中所述） -checkout [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="775d2ff1f35d4b43a574ee93495db02f2d8cbc5e" translate="yes" xml:space="preserve">
          <source>Create a new commit object</source>
          <target state="translated">创建一个新的提交对象</target>
        </trans-unit>
        <trans-unit id="ed82c0a774a3c01694b195d2170f6d11389fd2c2" translate="yes" xml:space="preserve">
          <source>Create a new location. See the notes below for details on how to choose the right protocol.</source>
          <target state="translated">创建一个新的位置。有关如何选择正确协议的详细信息,请参见下面的说明。</target>
        </trans-unit>
        <trans-unit id="8524608a0d692976af91ac05836567c4a22e40c7" translate="yes" xml:space="preserve">
          <source>Create a new pack-file containing objects in small pack-files referenced by the multi-pack-index. If the size given by the &lt;code&gt;--batch-size=&amp;lt;size&amp;gt;&lt;/code&gt; argument is zero, then create a pack containing all objects referenced by the multi-pack-index. For a non-zero batch size, Select the pack-files by examining packs from oldest-to-newest, computing the &quot;expected size&quot; by counting the number of objects in the pack referenced by the multi-pack-index, then divide by the total number of objects in the pack and multiply by the pack size. We select packs with expected size below the batch size until the set of packs have total expected size at least the batch size. If the total size does not reach the batch size, then do nothing. If a new pack- file is created, rewrite the multi-pack-index to reference the new pack-file. A later run of &lt;code&gt;git multi-pack-index expire&lt;/code&gt; will delete the pack-files that were part of this batch.</source>
          <target state="translated">创建一个新的包文件，其中包含由multi-pack-index引用的小包文件中的对象。如果 &lt;code&gt;--batch-size=&amp;lt;size&amp;gt;&lt;/code&gt; 给定的大小参数为零，然后创建一个包，其中包含由multi-pack-index引用的所有对象。对于非零的批处理大小，请通过检查从最早到最新的软件包来选择软件包文件，通过计算由multi-pack-index引用的软件包中的对象数来计算&amp;ldquo;预期大小&amp;rdquo;，然后除以包装中的对象总数乘以包装尺寸。我们选择预期大小小于批次大小的包装，直到包装组的总预期大小至少为批次大小。如果总大小未达到批处理大小，则什么也不做。如果创建了新的打包文件，请重写multi-pack-index以引用新的打包文件。稍后运行 &lt;code&gt;git multi-pack-index expire&lt;/code&gt; 将删除该批处理中的打包文件。</target>
        </trans-unit>
        <trans-unit id="9c41169f0fcbee00370950fd445a3c201d3fc72d" translate="yes" xml:space="preserve">
          <source>Create a packed archive of objects</source>
          <target state="translated">创建一个打包的对象档案</target>
        </trans-unit>
        <trans-unit id="aeccdf3a7f8e818b38876ba10e91ea37e1459401" translate="yes" xml:space="preserve">
          <source>Create a placeholder file in the local Git repository for each empty directory fetched from Subversion. This includes directories that become empty by removing all entries in the Subversion repository (but not the directory itself). The placeholder files are also tracked and removed when no longer necessary.</source>
          <target state="translated">在本地 Git 仓库中为每个从 Subversion 获取的空目录创建一个占位文件。这包括通过删除 Subversion 仓库中的所有条目(但不是目录本身)而变成空的目录。占位符文件也会被跟踪,并在不再需要时被删除。</target>
        </trans-unit>
        <trans-unit id="b0b2f30f73f128bf11ff805dcea18e4929006e9b" translate="yes" xml:space="preserve">
          <source>Create a reflog for the tag. To globally enable reflogs for tags, see &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. The negated form &lt;code&gt;--no-create-reflog&lt;/code&gt; only overrides an earlier &lt;code&gt;--create-reflog&lt;/code&gt;, but currently does not negate the setting of &lt;code&gt;core.logAllRefUpdates&lt;/code&gt;.</source>
          <target state="translated">为标签创建引用日志。要全局启用标签reflogs，见 &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; 在&lt;a href=&quot;git-config&quot;&gt;GIT-配置[1] &lt;/a&gt;。否定的形式 &lt;code&gt;--no-create-reflog&lt;/code&gt; 仅覆盖更早的 &lt;code&gt;--create-reflog&lt;/code&gt; ，但当前不否定 &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; 的设置。</target>
        </trans-unit>
        <trans-unit id="1c95e8dd01a1c19533d3be2260c095f09f00ed3d" translate="yes" xml:space="preserve">
          <source>Create a shallow clone with a history after the specified time.</source>
          <target state="translated">在指定时间后创建一个有历史记录的浅层克隆。</target>
        </trans-unit>
        <trans-unit id="81a994e450296531fc46153834310318c564b7aa" translate="yes" xml:space="preserve">
          <source>Create a shallow clone with a history, excluding commits reachable from a specified remote branch or tag. This option can be specified multiple times.</source>
          <target state="translated">创建一个有历史记录的浅层克隆,其中不包括从指定的远程分支或标签中获取的提交。这个选项可以指定多次。</target>
        </trans-unit>
        <trans-unit id="543a21269e742ae7ebc9058bf397ba34f632562d" translate="yes" xml:space="preserve">
          <source>Create a stash entry (which is a regular commit object) and return its object name, without storing it anywhere in the ref namespace. This is intended to be useful for scripts. It is probably not the command you want to use; see &quot;push&quot; above.</source>
          <target state="translated">创建一个stash条目(这是一个常规的提交对象),并返回它的对象名,而不在ref命名空间的任何地方存储它。这对脚本很有用。这可能不是你想使用的命令,请参见上面的 &quot;push&quot;。</target>
        </trans-unit>
        <trans-unit id="b36a0ee3d907a9108a54a206fff8047195a2242d" translate="yes" xml:space="preserve">
          <source>Create a tag by using the tags_subdir instead of the branches_subdir specified during git svn init.</source>
          <target state="translated">使用 tags_subdir 而不是 git svn init 时指定的 branches_subdir 来创建一个标签。</target>
        </trans-unit>
        <trans-unit id="d1e89b6bf885576f5776e13a6adbdccbb0c64b51" translate="yes" xml:space="preserve">
          <source>Create a tag in the SVN repository. This is a shorthand for &lt;code&gt;branch -t&lt;/code&gt;.</source>
          <target state="translated">在SVN信息库中创建一个标签。这是 &lt;code&gt;branch -t&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="f83eaaff0df7b915922dc3a5427d0b2485d874b0" translate="yes" xml:space="preserve">
          <source>Create a tar archive that contains the contents of the latest commit on the current branch, and extract it in the &lt;code&gt;/var/tmp/junk&lt;/code&gt; directory.</source>
          <target state="translated">创建一个tar归档文件，其中包含当前分支上最新提交的内容，并将其解压缩到 &lt;code&gt;/var/tmp/junk&lt;/code&gt; 目录中。</target>
        </trans-unit>
        <trans-unit id="79432159892c99c66a4b92db80f46b317928f9e7" translate="yes" xml:space="preserve">
          <source>Create a topic branch and develop.</source>
          <target state="translated">建立专题支部,制定。</target>
        </trans-unit>
        <trans-unit id="3c6e23e4bafb619b381ac21bdc202b4da275dceb" translate="yes" xml:space="preserve">
          <source>Create a tree object from the current index</source>
          <target state="translated">从当前索引中创建一个树对象</target>
        </trans-unit>
        <trans-unit id="199cc87a17f205a9debb1daf10f2cfd04f927e64" translate="yes" xml:space="preserve">
          <source>Create an archive of files from a named tree</source>
          <target state="translated">从一个命名的树中创建一个文件档案</target>
        </trans-unit>
        <trans-unit id="11842098ab38c4b23c00972df92c03d934dd00f4" translate="yes" xml:space="preserve">
          <source>Create an empty Git repository or reinitialize an existing one</source>
          <target state="translated">创建一个空的 Git 仓库或重新初始化一个现有的仓库。</target>
        </trans-unit>
        <trans-unit id="4bf9b028076fc8c72d20bdece3ec7191ce92cd0a" translate="yes" xml:space="preserve">
          <source>Create and switch to a new branch at the same time:</source>
          <target state="translated">同时创建并切换到一个新的分支。</target>
        </trans-unit>
        <trans-unit id="e2fd9501d48be0c26b22e7150b7353eff7148f41" translate="yes" xml:space="preserve">
          <source>Create multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with &lt;code&gt;Content-Disposition: attachment&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;Content-Disposition: attachment&lt;/code&gt; 创建多部分/混合的附件，其第一部分是提交消息，补丁本身在第二部分中。</target>
        </trans-unit>
        <trans-unit id="09cc7488a79d34bbf5d70e088375c60a2a44d3fc" translate="yes" xml:space="preserve">
          <source>Create multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with &lt;code&gt;Content-Disposition: inline&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;Content-Disposition: inline&lt;/code&gt; 创建多部分/混合的附件，其第一部分是提交消息，补丁本身在第二部分。</target>
        </trans-unit>
        <trans-unit id="1fbaabd2de6436a9809de570bfef7e43943388cb" translate="yes" xml:space="preserve">
          <source>Create or update a branch with a new commit, recording one logical change to the project.</source>
          <target state="translated">创建或更新一个新提交的分支,记录项目的一个逻辑变化。</target>
        </trans-unit>
        <trans-unit id="b926e4f1bd2c9ddbabaf20296d6e0bdae2102d0d" translate="yes" xml:space="preserve">
          <source>Create parent folders. This parameter is equivalent to the parameter --parents on svn cp commands and is useful for non-standard repository layouts.</source>
          <target state="translated">创建父文件夹。这个参数相当于svn cp命令中的参数--parents,对于非标准的版本库布局很有用。</target>
        </trans-unit>
        <trans-unit id="008d223ce25dddb7eb7d24c361668074bbed6dad" translate="yes" xml:space="preserve">
          <source>Create the branch &lt;code&gt;experimental&lt;/code&gt; in the &lt;code&gt;origin&lt;/code&gt; repository by copying the current &lt;code&gt;master&lt;/code&gt; branch. This form is only needed to create a new branch or tag in the remote repository when the local name and the remote name are different; otherwise, the ref name on its own will work.</source>
          <target state="translated">通过复制当前的 &lt;code&gt;master&lt;/code&gt; 分支，在 &lt;code&gt;origin&lt;/code&gt; 存储库中创建 &lt;code&gt;experimental&lt;/code&gt; 分支。仅当本地名称和远程名称不同时，才需要使用此表单在远程存储库中创建新的分支或标记。否则，引用名称本身将起作用。</target>
        </trans-unit>
        <trans-unit id="157f2dfeff99612ce2fdbdc6f8123dc09aa74a0b" translate="yes" xml:space="preserve">
          <source>Create the branch&amp;rsquo;s reflog. This activates recording of all changes made to the branch ref, enabling use of date based sha1 expressions such as &quot;&amp;lt;branchname&amp;gt;@{yesterday}&quot;. Note that in non-bare repositories, reflogs are usually enabled by default by the &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; config option. The negated form &lt;code&gt;--no-create-reflog&lt;/code&gt; only overrides an earlier &lt;code&gt;--create-reflog&lt;/code&gt;, but currently does not negate the setting of &lt;code&gt;core.logAllRefUpdates&lt;/code&gt;.</source>
          <target state="translated">创建分支的引用日志。这将激活对分支引用所做的所有更改的记录，从而允许使用基于日期的sha1表达式，例如&amp;ldquo; &amp;lt;分支名称&amp;gt; @ {yesterday}&amp;rdquo;。请注意，在非裸存储库中，通常默认情况下通过 &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; 配置选项启用引用日志。否定的形式 &lt;code&gt;--no-create-reflog&lt;/code&gt; 仅覆盖更早的 &lt;code&gt;--create-reflog&lt;/code&gt; ，但当前不否定 &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; 的设置。</target>
        </trans-unit>
        <trans-unit id="6e2b0a6de869fa2e1ebef49223a669515c01db9f" translate="yes" xml:space="preserve">
          <source>Create the new branch&amp;rsquo;s reflog; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">创建新分支的引用日志；有关详细信息，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="770931923d2f84baa80a7c6281d4bb0c7e7ff5dc" translate="yes" xml:space="preserve">
          <source>Create, list, delete or verify a tag object signed with GPG</source>
          <target state="translated">创建、列出、删除或验证用GPG签名的标签对象。</target>
        </trans-unit>
        <trans-unit id="884d013fa41e619bec3679b144edae3781c7f0c5" translate="yes" xml:space="preserve">
          <source>Create, list, delete refs to replace objects</source>
          <target state="translated">创建、列出、删除替换对象的参考文献。</target>
        </trans-unit>
        <trans-unit id="b126e5a5d6c912b3969ba9d70dcd92e7124db848" translate="yes" xml:space="preserve">
          <source>Creates (or recreates) the named branch, optionally starting from a specific revision. The reset command allows a frontend to issue a new &lt;code&gt;from&lt;/code&gt; command for an existing branch, or to create a new branch from an existing commit without creating a new commit.</source>
          <target state="translated">创建（或重新创建）命名分支，可以选择从特定版本开始。reset命令允许前端为现有分支发出新的 &lt;code&gt;from&lt;/code&gt; 命令，或者从现有提交创建新分支而不创建新提交。</target>
        </trans-unit>
        <trans-unit id="999e99d0bbec6ceb96391dfde9cf6cc8fcd81661" translate="yes" xml:space="preserve">
          <source>Creates a file holding the contents of the blob specified by sha1. It returns the name of the temporary file in the following format: .merge_file_XXXXX</source>
          <target state="translated">创建一个保存由 sha1 指定的 blob 内容的文件。它返回临时文件的名称,格式如下:.merge_file_XXXXX。</target>
        </trans-unit>
        <trans-unit id="09d3cd201fc386ccac2ad9f5c22bafbf8bdbb2f4" translate="yes" xml:space="preserve">
          <source>Creates a local branch, &lt;code&gt;master&lt;/code&gt; from this remote and checks it out.</source>
          <target state="translated">创建一个本地分支，从此远程 &lt;code&gt;master&lt;/code&gt; 并将其检出。</target>
        </trans-unit>
        <trans-unit id="7f64654581811c2b404b1b8dce4e1e1130a9678f" translate="yes" xml:space="preserve">
          <source>Creates a new branch or updates an existing branch by creating a new commit and updating the branch to point at the newly created commit.</source>
          <target state="translated">创建一个新的分支或更新一个现有的分支,方法是创建一个新的提交,并更新分支指向新创建的提交。</target>
        </trans-unit>
        <trans-unit id="1d59a731f68874f36286c257dc8063d7c2d003c5" translate="yes" xml:space="preserve">
          <source>Creates a new commit object based on the provided tree object and emits the new commit object id on stdout. The log message is read from the standard input, unless &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; options are given.</source>
          <target state="translated">基于提供的树对象创建一个新的提交对象，并在stdout上发出新的提交对象ID。除非给出 &lt;code&gt;-m&lt;/code&gt; 或 &lt;code&gt;-F&lt;/code&gt; 选项，否则将从标准输入中读取日志消息。</target>
        </trans-unit>
        <trans-unit id="47450bdc6c156b7e9d8dff8eb5153c36f0034363" translate="yes" xml:space="preserve">
          <source>Creates a tag object</source>
          <target state="translated">创建一个标签对象</target>
        </trans-unit>
        <trans-unit id="befea765dea04bdbe90515b52ec037d05fcd654f" translate="yes" xml:space="preserve">
          <source>Creates a temporary file with a blob&amp;rsquo;s contents</source>
          <target state="translated">创建一个包含blob内容的临时文件</target>
        </trans-unit>
        <trans-unit id="352027cd4f1050e7a8d58f4759fd4887117240f0" translate="yes" xml:space="preserve">
          <source>Creates a tree object using the current index. The name of the new tree object is printed to standard output.</source>
          <target state="translated">使用当前的索引创建一个树对象。新树对象的名称被打印到标准输出。</target>
        </trans-unit>
        <trans-unit id="7652dba54710524ad06e288b0394d9ec8f781534" translate="yes" xml:space="preserve">
          <source>Creates an annotated tag object from an existing commit or branch. Lightweight tags are not supported by this command, as they are not recommended for recording meaningful points in time.</source>
          <target state="translated">从现有的提交或分支中创建一个标注的标签对象。此命令不支持轻量级标签,因为不建议用它们来记录有意义的时间点。</target>
        </trans-unit>
        <trans-unit id="94955619715d4d7ab1e29b4a0777170b742991c7" translate="yes" xml:space="preserve">
          <source>Creates an annotated tag referring to a specific commit. To create lightweight (non-annotated) tags see the &lt;code&gt;reset&lt;/code&gt; command below.</source>
          <target state="translated">创建引用特定提交的带注释的标签。要创建轻量级（无注释）标签，请参见下面的 &lt;code&gt;reset&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="1c5caa9b586b6725b423618f01dee45981d01339" translate="yes" xml:space="preserve">
          <source>Creates an archive of the specified format containing the tree structure for the named tree, and writes it out to the standard output. If &amp;lt;prefix&amp;gt; is specified it is prepended to the filenames in the archive.</source>
          <target state="translated">创建指定格式的存档，其中包含命名树的树结构，并将其写到标准输出中。如果指定了&amp;lt;prefix&amp;gt;，它会放在归档文件中的文件名之前。</target>
        </trans-unit>
        <trans-unit id="902be57432c35cdc5fd0ebc974090ec5fe10886f" translate="yes" xml:space="preserve">
          <source>Creates an empty Git repository in a subdirectory called &lt;code&gt;project&lt;/code&gt;.</source>
          <target state="translated">在名为 &lt;code&gt;project&lt;/code&gt; 的子目录中创建一个空的Git存储库。</target>
        </trans-unit>
        <trans-unit id="cdbbe8fe0fb510b54456d0e5f7552d0ff50cdb17" translate="yes" xml:space="preserve">
          <source>Creates and checks out a new branch named &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; starting from the commit at which the &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; was originally created, applies the changes recorded in &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; to the new working tree and index. If that succeeds, and &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is a reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;, it then drops the &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt;. When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, applies the latest one.</source>
          <target state="translated">创建并签出一个名为新分支 &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; 开始从提交在该 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 最初创建，应用记录在修改 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 新的工作树和索引。如果成功，并且 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 是 &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 形式的引用，则它将删除 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 。如果没有给出 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; ，则应用最新的。</target>
        </trans-unit>
        <trans-unit id="817de4fcd985997655ed18eb9db24df013f605f3" translate="yes" xml:space="preserve">
          <source>Creates graft commits for all entries in &lt;code&gt;$GIT_DIR/info/grafts&lt;/code&gt; and deletes that file upon success. The purpose is to help users with transitioning off of the now-deprecated graft file.</source>
          <target state="translated">为 &lt;code&gt;$GIT_DIR/info/grafts&lt;/code&gt; 所有条目创建移植提交，并在成功后删除该文件。目的是帮助用户过渡到现已弃用的嫁接文件。</target>
        </trans-unit>
        <trans-unit id="dffa1bc89fe4773c581e2bab0e59b1fe8148dfd2" translate="yes" xml:space="preserve">
          <source>Creates the branch &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; and start it at &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;; if it already exists, then reset it to &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;. This is equivalent to running &quot;git branch&quot; with &quot;-f&quot;; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">创建分支 &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; 并在 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 处启动它；如果已经存在，则将其重置为 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 。这等效于用&amp;ldquo; -f&amp;rdquo;运行&amp;ldquo; git branch&amp;rdquo;；有关详细信息，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="051c90bf7349afef9519ebfd754be98e47ed9dee" translate="yes" xml:space="preserve">
          <source>Creating a branch in such a configuration requires disambiguating which location to use using the -d or --destination flag:</source>
          <target state="translated">在这样的配置中创建分支,需要使用-d或-d-destination标志来确定使用哪个位置。</target>
        </trans-unit>
        <trans-unit id="e6bedfd34ce489d63a7de42dd785dfdc0700c1e9" translate="yes" xml:space="preserve">
          <source>Creating a changelog and tarball for a software release</source>
          <target state="translated">为软件发行版创建变更日志和压缩包。</target>
        </trans-unit>
        <trans-unit id="c40a17b4008177323999b06c207c30d124e6c258" translate="yes" xml:space="preserve">
          <source>Creating a git repository</source>
          <target state="translated">创建一个git版本库</target>
        </trans-unit>
        <trans-unit id="040db03d97cbb631e8d9e6687acd4b2ef2582aa9" translate="yes" xml:space="preserve">
          <source>Creating a new Git repository couldn&amp;rsquo;t be easier: all Git repositories start out empty, and the only thing you need to do is find yourself a subdirectory that you want to use as a working tree - either an empty one for a totally new project, or an existing working tree that you want to import into Git.</source>
          <target state="translated">创建一个新的Git存储库再简单不过了：所有Git存储库开始都是空的，唯一要做的就是找到一个自己的子目录，用作工作树-要么是一个空目录，一个全新的项目，或您要导入到Git的现有工作树。</target>
        </trans-unit>
        <trans-unit id="00e49b6089f98df76d1261d9c963ee126709d119" translate="yes" xml:space="preserve">
          <source>Creating a new branch</source>
          <target state="translated">创建一个新的分支</target>
        </trans-unit>
        <trans-unit id="c39cd6567c9d07f33e0b16412b2e647902776ceb" translate="yes" xml:space="preserve">
          <source>Creating a new commit takes three steps:</source>
          <target state="translated">创建一个新的提交需要三个步骤。</target>
        </trans-unit>
        <trans-unit id="8ab78a3735f73dea4916eb1431c8608a2d083ad2" translate="yes" xml:space="preserve">
          <source>Creating a new commit that reverts an earlier change is very easy; just pass the &lt;a href=&quot;git-revert&quot;&gt;git-revert[1]&lt;/a&gt; command a reference to the bad commit; for example, to revert the most recent commit:</source>
          <target state="translated">创建一个新的提交以恢复先前的更改非常容易；只需将&lt;a href=&quot;git-revert&quot;&gt;git-revert [1]&lt;/a&gt;命令传递给错误提交的引用即可；例如，还原最近的提交：</target>
        </trans-unit>
        <trans-unit id="324b268505a0bd944ee2d5d30c8a3d50fc28d90f" translate="yes" xml:space="preserve">
          <source>Creating a new repository</source>
          <target state="translated">创建一个新的存储库</target>
        </trans-unit>
        <trans-unit id="36dbdbb03a117f7df33bdb409d5809a8b5ea5e6e" translate="yes" xml:space="preserve">
          <source>Creating a new repository from scratch is very easy:</source>
          <target state="translated">从头开始创建一个新的版本库是非常容易的。</target>
        </trans-unit>
        <trans-unit id="88eec46a3edc17fddca4fd44d28bb64f8780df72" translate="yes" xml:space="preserve">
          <source>Creating a tree object is trivial, and is done with &lt;code&gt;git write-tree&lt;/code&gt;. There are no options or other input: &lt;code&gt;git write-tree&lt;/code&gt; will take the current index state, and write an object that describes that whole index. In other words, we&amp;rsquo;re now tying together all the different filenames with their contents (and their permissions), and we&amp;rsquo;re creating the equivalent of a Git &quot;directory&quot; object:</source>
          <target state="translated">创建树对象很简单，可以使用 &lt;code&gt;git write-tree&lt;/code&gt; 完成。没有选项或其他输入： &lt;code&gt;git write-tree&lt;/code&gt; 将采用当前索引状态，并编写一个描述整个索引的对象。换句话说，我们现在将所有不同的文件名及其内容（及其权限）联系在一起，并创建与Git&amp;ldquo;目录&amp;rdquo;对象等效的文件：</target>
        </trans-unit>
        <trans-unit id="719e91bca781d7da4469d32275de7f00e97366b0" translate="yes" xml:space="preserve">
          <source>Creating an archive</source>
          <target state="translated">创建档案</target>
        </trans-unit>
        <trans-unit id="57d940de5ca0935e018fd03ec556851a3258029c" translate="yes" xml:space="preserve">
          <source>Creating good commit messages</source>
          <target state="translated">创建良好的提交信息</target>
        </trans-unit>
        <trans-unit id="d793460efe87481af6fc2a69bf4007ae5b376697" translate="yes" xml:space="preserve">
          <source>Creating replacement objects</source>
          <target state="translated">创建替换对象</target>
        </trans-unit>
        <trans-unit id="ab3dc2ecc52838a3e77a21918b25403d09705634" translate="yes" xml:space="preserve">
          <source>Creating tags</source>
          <target state="translated">创建标签</target>
        </trans-unit>
        <trans-unit id="b0acbd1aa53ddfa814233d47e25a83dac45b77c7" translate="yes" xml:space="preserve">
          <source>Creating the commit using the content you told Git about in step 2.</source>
          <target state="translated">使用第二步中告诉 Git 的内容创建提交。</target>
        </trans-unit>
        <trans-unit id="4d969b5791f8a038b7f947a6c2bb33127dd04018" translate="yes" xml:space="preserve">
          <source>Creating the perfect patch series</source>
          <target state="translated">创建完美的补丁系列</target>
        </trans-unit>
        <trans-unit id="a2955539fd234d4e940b20d8a9e91ef656e850f2" translate="yes" xml:space="preserve">
          <source>Creating, deleting, and modifying branches is quick and easy; here&amp;rsquo;s a summary of the commands:</source>
          <target state="translated">创建，删除和修改分支非常容易。这是命令的摘要：</target>
        </trans-unit>
        <trans-unit id="3c7835c41262e0651be74f2c3160cc75a963df48" translate="yes" xml:space="preserve">
          <source>Credential contexts</source>
          <target state="translated">凭证背景</target>
        </trans-unit>
        <trans-unit id="458543c678ae3dd16b97b21c03b00e9eaaddd45b" translate="yes" xml:space="preserve">
          <source>Credential helpers to cache or store passwords, or to interact with a system password wallet or keychain.</source>
          <target state="translated">凭证助手来缓存或存储密码,或与系统密码钱包或钥匙链交互。</target>
        </trans-unit>
        <trans-unit id="2fe8ef32f03f0033712fed8d5429cd4799dc6471" translate="yes" xml:space="preserve">
          <source>Credential helpers, on the other hand, are external programs from which Git can request both usernames and passwords; they typically interface with secure storage provided by the OS or other programs.</source>
          <target state="translated">而凭证助手则是Git可以请求用户名和密码的外部程序,它们通常与操作系统或其他程序提供的安全存储接口。</target>
        </trans-unit>
        <trans-unit id="d62300d6222786cbbaa983d6e9106aadd99d8d3d" translate="yes" xml:space="preserve">
          <source>Credential storage will by default write to the first existing file in the list. If none of these files exist, &lt;code&gt;~/.git-credentials&lt;/code&gt; will be created and written to.</source>
          <target state="translated">默认情况下，凭据存储将写入列表中的第一个现有文件。如果这些文件都不存在，将创建 &lt;code&gt;~/.git-credentials&lt;/code&gt; 并将其写入。</target>
        </trans-unit>
        <trans-unit id="70e47cc9d61ac64c248d54da47cefec3c90e34c9" translate="yes" xml:space="preserve">
          <source>Currently a dummy fall-through function implemented as a wrapper around &lt;code&gt;printf(1)&lt;/code&gt; with variables expanded by the git-sh-i18n{litdd}envsubst[1] helper. Will be replaced by a real gettext implementation in a later version.</source>
          <target state="translated">当前，一个伪掉线函数实现为 &lt;code&gt;printf(1)&lt;/code&gt; 的包装，并由git-sh-i18n {litdd} envsubst [1]辅助函数扩展了变量。在更高版本中将由真实的gettext实现替换。</target>
        </trans-unit>
        <trans-unit id="87c8476a8fe8246e9cc89649a2d435a7d613617a" translate="yes" xml:space="preserve">
          <source>Currently a dummy fall-through function implemented as a wrapper around &lt;code&gt;printf(1)&lt;/code&gt;. Will be replaced by a real gettext implementation in a later version.</source>
          <target state="translated">当前，一个伪掉线函数实现为 &lt;code&gt;printf(1)&lt;/code&gt; 的包装器。在更高版本中将由真实的gettext实现替换。</target>
        </trans-unit>
        <trans-unit id="d0a323c8531b99ccfcb3b5693dd52db2df3f23ff" translate="yes" xml:space="preserve">
          <source>Currently available providers are &lt;strong&gt;&quot;gravatar&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;picon&quot;&lt;/strong&gt;. Only one provider at a time can be selected (&lt;code&gt;default&lt;/code&gt; is one element list). If an unknown provider is specified, the feature is disabled. &lt;strong&gt;Note&lt;/strong&gt; that some providers might require extra Perl packages to be installed; see &lt;code&gt;gitweb/INSTALL&lt;/code&gt; for more details.</source>
          <target state="translated">当前可用的提供者是&lt;strong&gt;&amp;ldquo; gravatar&amp;rdquo;&lt;/strong&gt;和&lt;strong&gt;&amp;ldquo; picon&amp;rdquo;&lt;/strong&gt;。一次只能选择一个提供程序（ &lt;code&gt;default&lt;/code&gt; 为一个元素列表）。如果指定了未知的提供程序，则该功能将被禁用。&lt;strong&gt;请注意&lt;/strong&gt;，某些提供程序可能需要安装额外的Perl软件包。有关更多详细信息，请参见 &lt;code&gt;gitweb/INSTALL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="717fdd8a8fe2000b9c0c629f6c5d467ecf014cfe" translate="yes" xml:space="preserve">
          <source>Currently for internal use only. Set a prefix which gives a path from above a repository down to its root. One use is to give submodules context about the superproject that invoked it.</source>
          <target state="translated">目前只供内部使用。设置一个前缀,它给出了一个从上面的版本库向下到根的路径。一个用途是给子模块提供关于调用它的超级项目的上下文。</target>
        </trans-unit>
        <trans-unit id="44c98bf149dc1ad4ae7705ea185729a070e4f82e" translate="yes" xml:space="preserve">
          <source>Currently recognized fields are:</source>
          <target state="translated">目前承认的领域有:</target>
        </trans-unit>
        <trans-unit id="96e2ac5c1dd546ca41ecd7f60aa78cd7c4c66ca3" translate="yes" xml:space="preserve">
          <source>Currently the command updates the following files. Please see &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for description of what they are for:</source>
          <target state="translated">当前，该命令更新以下文件。请参阅&lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt;了解它们的用途：</target>
        </trans-unit>
        <trans-unit id="58cad17f651d6b9e5474187d9de4ce3c98aebe87" translate="yes" xml:space="preserve">
          <source>Currently this is used by &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; and &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; when &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; or &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; will checkout the &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; branch on another remote, and by &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt; when &lt;code&gt;git worktree add&lt;/code&gt; refers to a remote branch. This setting might be used for other checkout-like commands or functionality in the future.</source>
          <target state="translated">目前，这是用来通过&lt;a href=&quot;git-switch&quot;&gt;GIT-开关[1]&lt;/a&gt;和&lt;a href=&quot;git-checkout&quot;&gt;git的结账[1]&lt;/a&gt;时 &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; 或 &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; 将检出 &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; 遥控器上的另一分支，并且通过&lt;a href=&quot;git-worktree&quot;&gt;GIT-worktree [1]&lt;/a&gt;时 &lt;code&gt;git worktree add&lt;/code&gt; 引用远程分支。将来，此设置可能会用于其他类似结帐的命令或功能。</target>
        </trans-unit>
        <trans-unit id="5c5b7b525cb2eea52baefaf69e3b28ebe43a1b5d" translate="yes" xml:space="preserve">
          <source>Currently, this is always &quot;r1&quot; for the main repository. This field is in anticipation of in-proc submodules in the future.</source>
          <target state="translated">目前,对于主仓库来说,这总是 &quot;r1&quot;。这个字段是为将来的程序内子模块做准备的。</target>
        </trans-unit>
        <trans-unit id="071b814c810acef4a305418b7617eb91825385c2" translate="yes" xml:space="preserve">
          <source>Custom helpers</source>
          <target state="translated">自定义助手</target>
        </trans-unit>
        <trans-unit id="441c592e043641e18ffb271284d516b14fe37bc0" translate="yes" xml:space="preserve">
          <source>Custom macro attributes can be defined only in top-level gitattributes files (&lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt;, the &lt;code&gt;.gitattributes&lt;/code&gt; file at the top level of the working tree, or the global or system-wide gitattributes files), not in &lt;code&gt;.gitattributes&lt;/code&gt; files in working tree subdirectories. The built-in macro attribute &quot;binary&quot; is equivalent to:</source>
          <target state="translated">自定义宏属性只能在顶级gitattributes文件（ &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; ，位于工作树顶级的 &lt;code&gt;.gitattributes&lt;/code&gt; 文件或全局或系统范围的gitattributes文件）中定义，而不能在 &lt;code&gt;.gitattributes&lt;/code&gt; 文件中定义在工作树子目录中。内置的宏属性&amp;ldquo; binary&amp;rdquo;等效于：</target>
        </trans-unit>
        <trans-unit id="3e39087b89619b8882da1dce388a569a8e549573" translate="yes" xml:space="preserve">
          <source>Customizing word diff</source>
          <target state="translated">自定义单词差异</target>
        </trans-unit>
        <trans-unit id="a28effa0c8276898e045b96b9d1ba0f760229cf5" translate="yes" xml:space="preserve">
          <source>Cute name for &lt;a href=&quot;#def_core_git&quot;&gt;core Git&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_core_git&quot;&gt;核心Git的&lt;/a&gt;可爱名字。</target>
        </trans-unit>
        <trans-unit id="7033e3578a96d1e9400e567b4c0c23cd21d2c6e2" translate="yes" xml:space="preserve">
          <source>Cute name for programs and program suites depending on &lt;a href=&quot;#def_core_git&quot;&gt;core Git&lt;/a&gt;, presenting a high level access to core Git. Porcelains expose more of a &lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt; interface than the &lt;a href=&quot;#def_plumbing&quot;&gt;plumbing&lt;/a&gt;.</source>
          <target state="translated">取决于&lt;a href=&quot;#def_core_git&quot;&gt;核心Git的&lt;/a&gt;程序和程序套件的可爱名称，表示对核心Git的高级访问。瓷器比&lt;a href=&quot;#def_plumbing&quot;&gt;水暖器&lt;/a&gt;更能暴露出&lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt;界面。</target>
        </trans-unit>
        <trans-unit id="c276dc0072d6e81f335296db56eec5a1bdc2bed9" translate="yes" xml:space="preserve">
          <source>Cutting down bisection by giving more parameters to bisect start</source>
          <target state="translated">通过提供更多的参数来减少二分法的开始。</target>
        </trans-unit>
        <trans-unit id="9e78b27ca0bc764cd94adfc012f3ea2c4c32e8ff" translate="yes" xml:space="preserve">
          <source>D: deletion of a file</source>
          <target state="translated">D:删除文件</target>
        </trans-unit>
        <trans-unit id="4ecdb0fd037d3dafe4f4e2a354bcfe9ed6b3a537" translate="yes" xml:space="preserve">
          <source>DAG</source>
          <target state="translated">DAG</target>
        </trans-unit>
        <trans-unit id="5a7759c99cc9f0c4d7897147bc310328ba1b2ac4" translate="yes" xml:space="preserve">
          <source>Dangling objects</source>
          <target state="translated">悬挂物</target>
        </trans-unit>
        <trans-unit id="d8788504c151968602d8ccc8fc1d2150b059a336" translate="yes" xml:space="preserve">
          <source>Data Messages</source>
          <target state="translated">数据信息</target>
        </trans-unit>
        <trans-unit id="4b1f2d8717c44b631b95852544cce5392a548364" translate="yes" xml:space="preserve">
          <source>Data events are tagged with the active thread name. They are used to report the per-thread parameters.</source>
          <target state="translated">数据事件被标记为活动线程名称。它们用于报告每个线程的参数。</target>
        </trans-unit>
        <trans-unit id="4bee01a9236d0c6bfb9a9c78d868c75e8d0aa93e" translate="yes" xml:space="preserve">
          <source>Data messages added to a region.</source>
          <target state="translated">数据信息添加到一个区域。</target>
        </trans-unit>
        <trans-unit id="e5169e0ca17e29bbdf784cf8e268aafa8934e51d" translate="yes" xml:space="preserve">
          <source>Data written to stdin of the specified &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; is assumed to be sent to a git:// server, git-upload-pack, git-receive-pack or git-upload-archive (depending on situation), and data read from stdout of &amp;lt;command&amp;gt; is assumed to be received from the same service.</source>
          <target state="translated">假定写入指定 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 的 stdin的数据被发送到git：//服务器，git-upload-pack，git-receive-pack或git-upload-archive（取决于情况），并且从中读取数据假定&amp;lt;command&amp;gt;的stdout是从同一服务接收的。</target>
        </trans-unit>
        <trans-unit id="ce4b9abd8c39b6edc1077cdc5fbd525d6784cc17" translate="yes" xml:space="preserve">
          <source>Database backend</source>
          <target state="translated">数据库后端</target>
        </trans-unit>
        <trans-unit id="88e3b202bead5498b3c26df9a24b06dbb71997e1" translate="yes" xml:space="preserve">
          <source>Database name. The exact meaning depends on the selected database driver, for SQLite this is a filename. Supports variable substitution (see below). May not contain semicolons (&lt;code&gt;;&lt;/code&gt;). Default: &lt;code&gt;%Ggitcvs.%m.sqlite&lt;/code&gt;</source>
          <target state="translated">数据库名称。确切含义取决于所选的数据库驱动程序，对于SQLite，这是文件名。支持变量替换（请参见下文）。不得包含分号（ &lt;code&gt;;&lt;/code&gt; ）。默认值： &lt;code&gt;%Ggitcvs.%m.sqlite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec7281a9f03369f6fca87bc704dcd61eb8d42fc2" translate="yes" xml:space="preserve">
          <source>Database password. Only useful if setting &lt;code&gt;dbDriver&lt;/code&gt;, since SQLite has no concept of database passwords.</source>
          <target state="translated">数据库密码。仅在设置 &lt;code&gt;dbDriver&lt;/code&gt; 时有用，因为SQLite没有数据库密码的概念。</target>
        </trans-unit>
        <trans-unit id="6cb047cae02c9bba7b0e3391be2c746d7c4c4487" translate="yes" xml:space="preserve">
          <source>Database table name prefix. Prepended to the names of any database tables used, allowing a single database to be used for several repositories. Supports variable substitution (see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details). Any non-alphabetic characters will be replaced with underscores.</source>
          <target state="translated">数据库表名称前缀。在所使用的任何数据库表的名称之前，可以将一个数据库用于多个存储库。支持变量替换（有关详细信息，请参见&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;）。任何非字母字符将被下划线替换。</target>
        </trans-unit>
        <trans-unit id="ba01b17d3115051f1a477d09b8cec632c83f89d1" translate="yes" xml:space="preserve">
          <source>Database table name prefix. Supports variable substitution (see below). Any non-alphabetic characters will be replaced with underscores.</source>
          <target state="translated">数据库表名前缀。支持变量替换(见下文)。任何非字母字符将被下划线代替。</target>
        </trans-unit>
        <trans-unit id="a13030629fc1c33a937c268b335dcb627627128f" translate="yes" xml:space="preserve">
          <source>Database used by git-cvsserver to cache revision information derived from the Git repository. The exact meaning depends on the used database driver, for SQLite (which is the default driver) this is a filename. Supports variable substitution (see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details). May not contain semicolons (&lt;code&gt;;&lt;/code&gt;). Default: &lt;code&gt;%Ggitcvs.%m.sqlite&lt;/code&gt;</source>
          <target state="translated">git-cvsserver用于缓存从Git存储库派生的修订信息的数据库。确切含义取决于使用的数据库驱动程序，对于SQLite（这是默认驱动程序），这是文件名。支持变量替换（有关详细信息，请参见&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;）。不得包含分号（ &lt;code&gt;;&lt;/code&gt; ）。默认值： &lt;code&gt;%Ggitcvs.%m.sqlite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb3915ed16cfcd6e4965fc92e19dfdb3f354cb3d" translate="yes" xml:space="preserve">
          <source>Database user and password. Only useful if setting &lt;code&gt;gitcvs.dbDriver&lt;/code&gt;, since SQLite has no concept of database users and/or passwords. &lt;code&gt;gitcvs.dbUser&lt;/code&gt; supports variable substitution (see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details).</source>
          <target state="translated">数据库用户和密码。仅在设置 &lt;code&gt;gitcvs.dbDriver&lt;/code&gt; 时有用，因为SQLite没有数据库用户和/或密码的概念。 &lt;code&gt;gitcvs.dbUser&lt;/code&gt; 支持变量替换（有关详细信息，请参见&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="161446d05bce5c35b9bb58271e5e12dbad31f437" translate="yes" xml:space="preserve">
          <source>Database user. Only useful if setting &lt;code&gt;dbDriver&lt;/code&gt;, since SQLite has no concept of database users. Supports variable substitution (see below).</source>
          <target state="translated">数据库用户。仅在设置 &lt;code&gt;dbDriver&lt;/code&gt; 时有用，因为SQLite没有数据库用户的概念。支持变量替换（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="3fcd7b7ae338d342a7674f84f0c1f730e65ba9c0" translate="yes" xml:space="preserve">
          <source>Date Formats</source>
          <target state="translated">日期格式</target>
        </trans-unit>
        <trans-unit id="adf2309d1c810bb87f6dbfe62284445270cc7ea8" translate="yes" xml:space="preserve">
          <source>Date formats</source>
          <target state="translated">日期格式</target>
        </trans-unit>
        <trans-unit id="8dd9c41bb94ad9101ba89e79d1af605fb457f638" translate="yes" xml:space="preserve">
          <source>Debug gitignore / exclude files</source>
          <target state="translated">调试gitignore/exclude文件。</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="49a655454d59f6253c27bfd18c23a18e1916a070" translate="yes" xml:space="preserve">
          <source>Debugging would be easier if the fallback configuration file (&lt;code&gt;/etc/gitweb.conf&lt;/code&gt;) and environment variable to override its location (&lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt;) had names reflecting their &quot;fallback&quot; role. The current names are kept to avoid breaking working setups.</source>
          <target state="translated">如果后备配置文件（ &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; ）和环境变量覆盖其位置（ &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; ）的名称反映了其&amp;ldquo;后备&amp;rdquo;角色，则调试会更容易。保留当前名称，以避免破坏工作设置。</target>
        </trans-unit>
        <trans-unit id="25623d3d6597110b3dc53adcb06a990460c0bdc2" translate="yes" xml:space="preserve">
          <source>Decide not to merge. The only clean-ups you need are to reset the index file to the &lt;code&gt;HEAD&lt;/code&gt; commit to reverse 2. and to clean up working tree changes made by 2. and 3.; &lt;code&gt;git merge --abort&lt;/code&gt; can be used for this.</source>
          <target state="translated">决定不合并。您需要执行的唯一清除操作是将索引文件重置为 &lt;code&gt;HEAD&lt;/code&gt; commit以反转2，并清除2和3对工作树所做的更改。 &lt;code&gt;git merge --abort&lt;/code&gt; 可用于此目的。</target>
        </trans-unit>
        <trans-unit id="461dd8f77b9a26481c7b52783d8ce19864c00a87" translate="yes" xml:space="preserve">
          <source>Deepen or shorten the history of a shallow repository to exclude commits reachable from a specified remote branch or tag. This option can be specified multiple times.</source>
          <target state="translated">加深或缩短浅层仓库的历史记录,以排除从指定的远程分支或标签中可以到达的提交。这个选项可以指定多次。</target>
        </trans-unit>
        <trans-unit id="fc0ba6fe75550f8aa46ad04018df5509f99a82b6" translate="yes" xml:space="preserve">
          <source>Deepen or shorten the history of a shallow repository to include all reachable commits after &amp;lt;date&amp;gt;.</source>
          <target state="translated">加深或缩短浅存储库的历史记录，以包括&amp;lt;date&amp;gt;之后的所有可到达的提交。</target>
        </trans-unit>
        <trans-unit id="b85c21ce1c36df4fd97d8d980d2975325f47caee" translate="yes" xml:space="preserve">
          <source>Deepens the history of a shallow repository based on time.</source>
          <target state="translated">以时间为基础,深化浅显库的历史。</target>
        </trans-unit>
        <trans-unit id="0b2ab70fb2f23273e2c8d92c10b43dfc891dac12" translate="yes" xml:space="preserve">
          <source>Deepens the history of a shallow repository excluding ref. Multiple options add up.</source>
          <target state="translated">深化浅显贮藏室的历史,不包括裁判。多个选项加起来。</target>
        </trans-unit>
        <trans-unit id="e87814f404c8c230e2c89d6eeca5b7883036cc70" translate="yes" xml:space="preserve">
          <source>Deepens the history of a shallow repository relative to current boundary. Only valid when used with &quot;option depth&quot;.</source>
          <target state="translated">加深浅层存储库相对于当前边界的历史。仅当与 &quot;选项深度 &quot;一起使用时有效。</target>
        </trans-unit>
        <trans-unit id="919906ebf6455d2b9a3b4a65ed3f4d4732631f26" translate="yes" xml:space="preserve">
          <source>Deepens the history of a shallow repository.</source>
          <target state="translated">深化了浅显贮藏室的历史。</target>
        </trans-unit>
        <trans-unit id="3a0a0372c4178042ae74a7b526723e3fc6d8263f" translate="yes" xml:space="preserve">
          <source>Deeper technical details are often marked as Notes, which you can skip on your first reading.</source>
          <target state="translated">更深层次的技术细节往往被标记为Notes,你可以在第一次阅读时跳过。</target>
        </trans-unit>
        <trans-unit id="d20e487318f9399c04b2a3d79bfe7af0545b07ad" translate="yes" xml:space="preserve">
          <source>Default behavior is to replace at most one line. This replaces all lines matching the key (and optionally the value_regex).</source>
          <target state="translated">默认行为是最多替换一行。这将替换所有与key(和可选的value_regex)匹配的行。</target>
        </trans-unit>
        <trans-unit id="749b51b1c09b9f840f85503ac08122dc83ca64a1" translate="yes" xml:space="preserve">
          <source>Default behaviour</source>
          <target state="translated">默认行为</target>
        </trans-unit>
        <trans-unit id="169920c54a1f81ff4c7f4ea2f9bc3ec52999c692" translate="yes" xml:space="preserve">
          <source>Default category for projects for which none is specified. If this is set to the empty string, such projects will remain uncategorized and listed at the top, above categorized projects. Used only if project categories are enabled, which means if &lt;code&gt;$projects_list_group_categories&lt;/code&gt; is true. By default set to &quot;&quot; (empty string).</source>
          <target state="translated">未指定项目的默认类别。如果将其设置为空字符串，则此类项目将保持未分类状态，并在已分类项目上方的顶部列出。仅在启用项目类别（即 &lt;code&gt;$projects_list_group_categories&lt;/code&gt; 为true）时使用。默认情况下设置为&amp;ldquo;&amp;rdquo;（空字符串）。</target>
        </trans-unit>
        <trans-unit id="9a7724b74acb9022ccf2c23f91703070df10d1ad" translate="yes" xml:space="preserve">
          <source>Default charset for text files. If this is not set, the web server configuration will be used. Unset by default.</source>
          <target state="translated">文本文件的默认字符集。如果没有设置,将使用Web服务器的配置。默认情况下未设置。</target>
        </trans-unit>
        <trans-unit id="f158e700b844e38a0dc931109afe37923be30e86" translate="yes" xml:space="preserve">
          <source>Default for the &lt;code&gt;--format&lt;/code&gt; option. (See &lt;code&gt;Pretty Formats&lt;/code&gt; above.) Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 选项的默认值。（请参阅上面的 &lt;code&gt;Pretty Formats&lt;/code&gt; 。）默认为 &lt;code&gt;medium&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="218b9a84e8b1c5c4d3bddc9fdedc0acd32221314" translate="yes" xml:space="preserve">
          <source>Default format for human-readable dates. (Compare the &lt;code&gt;--date&lt;/code&gt; option.) Defaults to &quot;default&quot;, which means to write dates like &lt;code&gt;Sat May 8 19:35:34 2010 -0500&lt;/code&gt;.</source>
          <target state="translated">可读日期的默认格式。（比较 &lt;code&gt;--date&lt;/code&gt; 选项。）默认为&amp;ldquo; default&amp;rdquo;，这意味着要写一些类似 &lt;code&gt;Sat May 8 19:35:34 2010 -0500&lt;/code&gt; 的日期。</target>
        </trans-unit>
        <trans-unit id="ba0eb309e5345eec5c3b84841217719e93588d00" translate="yes" xml:space="preserve">
          <source>Default is 1 MiB if NO_MMAP was set at compile time, otherwise 32 MiB on 32 bit platforms and 1 GiB on 64 bit platforms. This should be reasonable for all users/operating systems. You probably do not need to adjust this value.</source>
          <target state="translated">如果在编译时设置了NO_MMAP,默认为1 MiB,否则32位平台为32 MiB,64位平台为1 GiB。这对于所有用户/操作系统来说应该是合理的。你可能不需要调整这个值。</target>
        </trans-unit>
        <trans-unit id="d9147e34112ee790abb9f9db27d98b411473bac1" translate="yes" xml:space="preserve">
          <source>Default is 256 MiB on 32 bit platforms and 32 TiB (effectively unlimited) on 64 bit platforms. This should be reasonable for all users/operating systems, except on the largest projects. You probably do not need to adjust this value.</source>
          <target state="translated">32位平台的默认值是256 MiB,64位平台的默认值是32 TiB(实际上是无限的)。这对所有用户/操作系统来说都是合理的,除了大型项目。你可能不需要调整这个值。</target>
        </trans-unit>
        <trans-unit id="4e49064ea050150a0f08182ce6ea67e133f00a9b" translate="yes" xml:space="preserve">
          <source>Default is 512 MiB on all platforms. This should be reasonable for most projects as source code and other text files can still be delta compressed, but larger binary media files won&amp;rsquo;t be.</source>
          <target state="translated">在所有平台上，默认值为512 MiB。对于大多数项目来说，这应该是合理的，因为源代码和其他文本文件仍可以进行增量压缩，但更大的二进制媒体文件则不能。</target>
        </trans-unit>
        <trans-unit id="dda4dcbc7195d800c473af9dc2bffe5e2a28d17c" translate="yes" xml:space="preserve">
          <source>Default is 96 MiB on all platforms. This should be reasonable for all users/operating systems, except on the largest projects. You probably do not need to adjust this value.</source>
          <target state="translated">所有平台的默认值是96 MiB。这对所有用户/操作系统来说都是合理的,除了大型项目。你可能不需要调整这个值。</target>
        </trans-unit>
        <trans-unit id="41aaa0897fbd85df874ab9d046a41b0b5b6fcbb7" translate="yes" xml:space="preserve">
          <source>Default is the value of &lt;code&gt;sendemail.confirm&lt;/code&gt; configuration value; if that is unspecified, default to &lt;code&gt;auto&lt;/code&gt; unless any of the suppress options have been specified, in which case default to &lt;code&gt;compose&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;sendemail.confirm&lt;/code&gt; 的配置值；如果未指定，则默认为 &lt;code&gt;auto&lt;/code&gt; 除非已指定任何抑制选项，在这种情况下，默认为 &lt;code&gt;compose&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3569c1c552117db58dc989b670cc81e2f0b5eea8" translate="yes" xml:space="preserve">
          <source>Default is the value of &lt;code&gt;sendemail.suppresscc&lt;/code&gt; configuration value; if that is unspecified, default to &lt;code&gt;self&lt;/code&gt; if --suppress-from is specified, as well as &lt;code&gt;body&lt;/code&gt; if --no-signed-off-cc is specified.</source>
          <target state="translated">默认值为 &lt;code&gt;sendemail.suppresscc&lt;/code&gt; 的配置值；如果未指定，则如果指定了--suppress-from ，则默认为 &lt;code&gt;self&lt;/code&gt; ;如果指定了--no-signed-off-cc ，则默认为 &lt;code&gt;body&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d9cf7354837a1e6f3330509773c724888f83eee" translate="yes" xml:space="preserve">
          <source>Default is the value of &lt;code&gt;sendemail.validate&lt;/code&gt;; if this is not set, default to &lt;code&gt;--validate&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;sendemail.validate&lt;/code&gt; 的值；如果未设置，则默认为 &lt;code&gt;--validate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56e75db08a7bfbfa3cf0e2da2dfaa6006039a1d9" translate="yes" xml:space="preserve">
          <source>Default is the value of the &lt;code&gt;sendemail.transferEncoding&lt;/code&gt; configuration value; if that is unspecified, default to &lt;code&gt;auto&lt;/code&gt;.</source>
          <target state="translated">默认值为 &lt;code&gt;sendemail.transferEncoding&lt;/code&gt; 配置值；如果未指定，则默认为 &lt;code&gt;auto&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64e9c61ef316384afc27b43382c7032d837b6c45" translate="yes" xml:space="preserve">
          <source>Default mimetype for the blob_plain (raw) view, if mimetype checking doesn&amp;rsquo;t result in some other type; by default &quot;text/plain&quot;. Gitweb guesses mimetype of a file to display based on extension of its filename, using &lt;code&gt;$mimetypes_file&lt;/code&gt; (if set and file exists) and &lt;code&gt;/etc/mime.types&lt;/code&gt; files (see &lt;strong&gt;mime.types&lt;/strong&gt;(5) manpage; only filename extension rules are supported by gitweb).</source>
          <target state="translated">如果mimetype检查没有导致其他类型，则blob_plain（原始）视图的默认mimetype；否则，为false。默认情况下为&amp;ldquo;文本/纯文本&amp;rdquo;。Gitweb使用 &lt;code&gt;$mimetypes_file&lt;/code&gt; （如果存在设置和文件）和 &lt;code&gt;/etc/mime.types&lt;/code&gt; 文件（请参见&lt;strong&gt;mime.types&lt;/strong&gt;（5）联机帮助页）根据文件名的扩展名猜测要显示的文件的mimetype。 gitweb）。</target>
        </trans-unit>
        <trans-unit id="a652e3e440b54f22526cd10c4e33c94f21d2c36b" translate="yes" xml:space="preserve">
          <source>Default mode</source>
          <target state="translated">默认模式</target>
        </trans-unit>
        <trans-unit id="acfd9cc6edb5212a1b417bbccf2370d2aa946d1d" translate="yes" xml:space="preserve">
          <source>Default value is &quot;project&quot;. Unknown value means unsorted.</source>
          <target state="translated">默认值为 &quot;项目&quot;。未知值表示未排序。</target>
        </trans-unit>
        <trans-unit id="d13eeb854d667ceefdf012fc9e848fc81153988f" translate="yes" xml:space="preserve">
          <source>Default value of ordering of projects on projects list page, which means the ordering used if you don&amp;rsquo;t explicitly sort projects list (if there is no &quot;o&quot; CGI query parameter in the URL). Valid values are &quot;none&quot; (unsorted), &quot;project&quot; (projects are by project name, i.e. path to repository relative to &lt;code&gt;$projectroot&lt;/code&gt;), &quot;descr&quot; (project description), &quot;owner&quot;, and &quot;age&quot; (by date of most current commit).</source>
          <target state="translated">项目列表页面上项目排序的默认值，这意味着如果您未明确对项目列表进行排序（如果URL中没有&amp;ldquo; o&amp;rdquo; CGI查询参数），则使用该排序。有效值为&amp;ldquo; none&amp;rdquo;（未排序），&amp;ldquo; project&amp;rdquo;（项目按项目名称，即相对于 &lt;code&gt;$projectroot&lt;/code&gt; 存储库路径），&amp;ldquo; descr&amp;rdquo;（项目描述），&amp;ldquo; owner&amp;rdquo;和&amp;ldquo; age&amp;rdquo;（按日期排序）最新提交）。</target>
        </trans-unit>
        <trans-unit id="8ac357056e8ed36929d1a15c1654ca84f035985a" translate="yes" xml:space="preserve">
          <source>Default values for &amp;lt;repository&amp;gt; and &amp;lt;branch&amp;gt; are read from the &quot;remote&quot; and &quot;merge&quot; configuration for the current branch as set by &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;&lt;code&gt;--track&lt;/code&gt;.</source>
          <target state="translated">从&lt;a href=&quot;git-branch&quot;&gt;git-branch [1] &lt;/a&gt; &lt;code&gt;--track&lt;/code&gt; 设置的当前分支的&amp;ldquo; remote&amp;rdquo;和&amp;ldquo; merge&amp;rdquo;配置中读取&amp;lt;repository&amp;gt;和&amp;lt;branch&amp;gt;的默认值。</target>
        </trans-unit>
        <trans-unit id="83771af0d9e990cfd4209b40879c5dd720b86a4b" translate="yes" xml:space="preserve">
          <source>Defaults to false.</source>
          <target state="translated">默认值为false。</target>
        </trans-unit>
        <trans-unit id="6daf684c4aa7d6effe6c46260cf795487441628a" translate="yes" xml:space="preserve">
          <source>Defaults to false. If this is set to a non zero number or true (identical to -1 or an unlimited number), the submodule summary will be enabled and a summary of commits for modified submodules will be shown (see --summary-limit option of &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;). Please note that the summary output command will be suppressed for all submodules when &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; is set to &lt;code&gt;all&lt;/code&gt; or only for those submodules where &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt;. The only exception to that rule is that status and commit will show staged submodule changes. To also view the summary for ignored submodules you can either use the --ignore-submodules=dirty command-line option or the &lt;code&gt;git submodule summary&lt;/code&gt; command, which shows a similar output but does not honor these settings.</source>
          <target state="translated">默认为false。如果这被设置为非零数或真（相同为-1或无限数量），子模块摘要将被使能并提交的改性子模块的概要将被显示（参见--summary限制选项&lt;a href=&quot;git-submodule&quot;&gt;git- submodule [1]&lt;/a&gt;）。请注意，当 &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; 设置为 &lt;code&gt;all&lt;/code&gt; 或仅对 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt; 那些子模块设置为时，将禁止所有子模块执行summary输出命令。该规则的唯一例外是状态和提交将显示分段的子模块更改。要同时查看被忽略子模块的摘要，可以使用--ignore-submodules = dirty命令行选项或 &lt;code&gt;git submodule summary&lt;/code&gt; 命令，显示类似的输出，但不支持这些设置。</target>
        </trans-unit>
        <trans-unit id="c1010884442d5e06536e1ee0f4d961539164dc8e" translate="yes" xml:space="preserve">
          <source>Defines a URL from which the submodule repository can be cloned. This may be either an absolute URL ready to be passed to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or (if it begins with ./ or ../) a location relative to the superproject&amp;rsquo;s origin repository.</source>
          <target state="translated">定义可从中克隆子模块存储库的URL。这可以是准备传递给&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;的绝对URL，也可以是相对于超级项目的原始存储库的位置（如果以./或../开头）。</target>
        </trans-unit>
        <trans-unit id="7eec12b7977eefefa22fa2534e2c96073288e53c" translate="yes" xml:space="preserve">
          <source>Defines a human-readable name for a custom low-level merge driver. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">为自定义的低级合并驱动程序定义易于理解的名称。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3e9ca6f11c09da4d43e81ad293147f43b5584aa" translate="yes" xml:space="preserve">
          <source>Defines how wide the commit message window is in the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;. &quot;75&quot; is the default.</source>
          <target state="translated">定义&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]中&lt;/a&gt;的提交消息窗口的宽度。默认值为&amp;ldquo; 75&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8f256827cbc850fb3bdad834aa2364767d096745" translate="yes" xml:space="preserve">
          <source>Defines the action &lt;code&gt;git push&lt;/code&gt; should take if no refspec is explicitly given. Different values are well-suited for specific workflows; for instance, in a purely central workflow (i.e. the fetch source is equal to the push destination), &lt;code&gt;upstream&lt;/code&gt; is probably what you want. Possible values are:</source>
          <target state="translated">定义如果未明确给出refspec，则 &lt;code&gt;git push&lt;/code&gt; 应该执行的操作。不同的值非常适合特定的工作流程；例如，在纯粹的中央工作流程中（即，获取源等于推送目的地）， &lt;code&gt;upstream&lt;/code&gt; 可能就是您想要的。可能的值为：</target>
        </trans-unit>
        <trans-unit id="4188e24ee4c51e0130a50e687a2164cdec0105c9" translate="yes" xml:space="preserve">
          <source>Defines the command that implements a custom low-level merge driver. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">定义实现自定义低级合并驱动程序的命令。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70c9d97cb193a6213d042cd9cd1b6638dde57f03" translate="yes" xml:space="preserve">
          <source>Defines the default update procedure for the named submodule, i.e. how the submodule is updated by &quot;git submodule update&quot; command in the superproject. This is only used by &lt;code&gt;git
submodule init&lt;/code&gt; to initialize the configuration variable of the same name. Allowed values here are &lt;code&gt;checkout&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;none&lt;/code&gt;. See description of &lt;code&gt;update&lt;/code&gt; command in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; for their meaning. For security reasons, the &lt;code&gt;!command&lt;/code&gt; form is not accepted here.</source>
          <target state="translated">定义命名子模块的默认更新过程，即，如何通过超级项目中的&amp;ldquo; git submodule update&amp;rdquo;命令更新子模块。这仅由 &lt;code&gt;git submodule init&lt;/code&gt; 用来初始化同名的配置变量。此处允许的值为 &lt;code&gt;checkout&lt;/code&gt; ， &lt;code&gt;rebase&lt;/code&gt; ， &lt;code&gt;merge&lt;/code&gt; 或 &lt;code&gt;none&lt;/code&gt; 。有关其含义，请参见&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]中&lt;/a&gt;的 &lt;code&gt;update&lt;/code&gt; 命令描述。出于安全原因，此处不接受 &lt;code&gt;!command&lt;/code&gt; 形式。</target>
        </trans-unit>
        <trans-unit id="90471e779c375b0a1c4452c6d06b08a0b6dc6757" translate="yes" xml:space="preserve">
          <source>Defines the path, relative to the top-level directory of the Git working tree, where the submodule is expected to be checked out. The path name must not end with a &lt;code&gt;/&lt;/code&gt;. All submodule paths must be unique within the .gitmodules file.</source>
          <target state="translated">定义相对于Git工作树的顶级目录的路径，该子模块应在该目录中检出。路径名不能以 &lt;code&gt;/&lt;/code&gt; 结尾。 .gitmodules文件中的所有子模块路径必须唯一。</target>
        </trans-unit>
        <trans-unit id="b4ca29387dcb9b04d487429eaa7be9fc96326e7a" translate="yes" xml:space="preserve">
          <source>Defines under what circumstances &quot;git status&quot; and the diff family show a submodule as modified. The following values are supported:</source>
          <target state="translated">定义在什么情况下 &quot;git status &quot;和diff family会显示一个子模块被修改。支持以下值。</target>
        </trans-unit>
        <trans-unit id="7943cfcce8d9f75d29b4fa34e3b6ac1f1de5b3ae" translate="yes" xml:space="preserve">
          <source>Defines under what circumstances &quot;git status&quot; and the diff family show a submodule as modified. When set to &quot;all&quot;, it will never be considered modified (but it will nonetheless show up in the output of status and commit when it has been staged), &quot;dirty&quot; will ignore all changes to the submodules work tree and takes only differences between the HEAD of the submodule and the commit recorded in the superproject into account. &quot;untracked&quot; will additionally let submodules with modified tracked files in their work tree show up. Using &quot;none&quot; (the default when this option is not set) also shows submodules that have untracked files in their work tree as changed. This setting overrides any setting made in .gitmodules for this submodule, both settings can be overridden on the command line by using the &quot;--ignore-submodules&quot; option. The &lt;code&gt;git submodule&lt;/code&gt; commands are not affected by this setting.</source>
          <target state="translated">定义在什么情况下&amp;ldquo; git status&amp;rdquo;和diff系列显示已修改的子模块。当设置为&amp;ldquo; all&amp;rdquo;时，将永远不会将其视为已修改（但仍会在状态输出中显示，并在上演时提交），&amp;ldquo; dirty&amp;rdquo;将忽略对子模块工作树的所有更改，并且仅保留差异子模块的HEAD和记录在超级项目中的提交之间的距离。 &amp;ldquo;未跟踪&amp;rdquo;将另外显示其工作树中具有已修改跟踪文件的子模块。使用&amp;ldquo;无&amp;rdquo;（未设置此选项时的默认值）还会显示其工作树中具有未跟踪文件的子模块已更改。此设置会覆盖.gitmodules中对此子模块所做的任何设置，可以通过在命令行上使用&amp;ldquo;--ignore-submodules&amp;rdquo;选项。 &lt;code&gt;git submodule&lt;/code&gt; 命令不受此设置的影响。</target>
        </trans-unit>
        <trans-unit id="e1fef4851ecba56a95f304dccae2b919c9e6d073" translate="yes" xml:space="preserve">
          <source>Defines which attributes to assign to a path, similar to per-directory &lt;code&gt;.gitattributes&lt;/code&gt; files. See also: &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">定义要分配给路径的属性，类似于每个目录的 &lt;code&gt;.gitattributes&lt;/code&gt; 文件。另请参阅：&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7011f57e8da17dd35f52484933047dc4fb201acb" translate="yes" xml:space="preserve">
          <source>Defines, together with branch.&amp;lt;name&amp;gt;.remote, the upstream branch for the given branch. It tells &lt;code&gt;git fetch&lt;/code&gt;/&lt;code&gt;git pull&lt;/code&gt;/&lt;code&gt;git rebase&lt;/code&gt; which branch to merge and can also affect &lt;code&gt;git push&lt;/code&gt; (see push.default). When in branch &amp;lt;name&amp;gt;, it tells &lt;code&gt;git fetch&lt;/code&gt; the default refspec to be marked for merging in FETCH_HEAD. The value is handled like the remote part of a refspec, and must match a ref which is fetched from the remote given by &quot;branch.&amp;lt;name&amp;gt;.remote&quot;. The merge information is used by &lt;code&gt;git pull&lt;/code&gt; (which at first calls &lt;code&gt;git fetch&lt;/code&gt;) to lookup the default branch for merging. Without this option, &lt;code&gt;git pull&lt;/code&gt; defaults to merge the first refspec fetched. Specify multiple values to get an octopus merge. If you wish to setup &lt;code&gt;git pull&lt;/code&gt; so that it merges into &amp;lt;name&amp;gt; from another branch in the local repository, you can point branch.&amp;lt;name&amp;gt;.merge to the desired branch, and use the relative path setting &lt;code&gt;.&lt;/code&gt; (a period) for branch.&amp;lt;name&amp;gt;.remote.</source>
          <target state="translated">与branch。&amp;lt;name&amp;gt; .remote一起定义给定分支的上游分支。它告诉 &lt;code&gt;git fetch&lt;/code&gt; / &lt;code&gt;git pull&lt;/code&gt; / &lt;code&gt;git rebase&lt;/code&gt; 合并哪个分支，也可以影响 &lt;code&gt;git push&lt;/code&gt; （请参阅push.default）。在分支&amp;lt;name&amp;gt;中时，它告诉 &lt;code&gt;git fetch&lt;/code&gt; 将标记为要合并到FETCH_HEAD中的默认refspec。该值的处理方式类似于refspec的远程部分，并且必须匹配从&amp;ldquo; branch。&amp;lt;name&amp;gt; .remote&amp;rdquo;给定的远程获取的ref。 &lt;code&gt;git pull&lt;/code&gt; （首先调用 &lt;code&gt;git fetch&lt;/code&gt; ）使用合并信息来查找要合并的默认分支。没有这个选项， &lt;code&gt;git pull&lt;/code&gt; 默认情况下合并获取的第一个refspec。指定多个值以获取章鱼合并。如果要设置 &lt;code&gt;git pull&lt;/code&gt; 以便它从本地存储库中的另一个分支合并到&amp;lt;name&amp;gt;中，则可以将branch。&amp;lt;name&amp;gt; .merge指向所需的分支，并使用相对路径设置 &lt;code&gt;.&lt;/code&gt; （一个句号）。&amp;lt;name&amp;gt; .remote。</target>
        </trans-unit>
        <trans-unit id="f11af95383d16d6bd1e7925886e81b428b4cbfea" translate="yes" xml:space="preserve">
          <source>Defining a custom hunk-header</source>
          <target state="translated">定义一个自定义的hunk-header</target>
        </trans-unit>
        <trans-unit id="ca3594ffd9ab11c72c2e8d78b4c8b59973682e4f" translate="yes" xml:space="preserve">
          <source>Defining a custom merge driver</source>
          <target state="translated">定义自定义合并驱动程序</target>
        </trans-unit>
        <trans-unit id="9708d6426545c2cece09aff33765fae2b095ca8b" translate="yes" xml:space="preserve">
          <source>Defining an external diff driver</source>
          <target state="translated">定义外部差分驱动</target>
        </trans-unit>
        <trans-unit id="c0c022d1a19819ea36656f34517c46cf40cc0616" translate="yes" xml:space="preserve">
          <source>Defining macro attributes</source>
          <target state="translated">定义宏属性</target>
        </trans-unit>
        <trans-unit id="b40047a3b93162ae49d16e0fd58c1fcd8942970b" translate="yes" xml:space="preserve">
          <source>Deinitialized submodule: A &lt;code&gt;gitlink&lt;/code&gt;, and a &lt;code&gt;.gitmodules&lt;/code&gt; entry, but no submodule working directory. The submodule&amp;rsquo;s Git directory may be there as after deinitializing the Git directory is kept around. The directory which is supposed to be the working directory is empty instead.</source>
          <target state="translated">已取消初始化的子模块： &lt;code&gt;gitlink&lt;/code&gt; 和 &lt;code&gt;.gitmodules&lt;/code&gt; 条目，但没有子模块工作目录。子模块的Git目录可能在该目录中，因为在取消初始化Git目录之后，该目录仍然存在。应该是工作目录的目录为空。</target>
        </trans-unit>
        <trans-unit id="b4c200bb0d1f7ba2b7c3e166470a4cb39be0daab" translate="yes" xml:space="preserve">
          <source>Delay</source>
          <target state="translated">Delay</target>
        </trans-unit>
        <trans-unit id="ce169dc044a35b855e4edb1b1a97682afa804f83" translate="yes" xml:space="preserve">
          <source>Delete &amp;lt;ref&amp;gt; after verifying it exists with &amp;lt;oldvalue&amp;gt;, if given. If given, &amp;lt;oldvalue&amp;gt; may not be zero.</source>
          <target state="translated">如果使用&amp;lt;oldvalue&amp;gt;验证&amp;lt;ref&amp;gt;存在，请删除它。如果给定，&amp;lt;oldvalue&amp;gt;可能不为零。</target>
        </trans-unit>
        <trans-unit id="4a38bab2ae9dd8b2cb4a0dc3ff8ff31445d9e605" translate="yes" xml:space="preserve">
          <source>Delete a branch. The branch must be fully merged in its upstream branch, or in &lt;code&gt;HEAD&lt;/code&gt; if no upstream was set with &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--set-upstream-to&lt;/code&gt;.</source>
          <target state="translated">删除分支。如果未使用 &lt;code&gt;--track&lt;/code&gt; 或 &lt;code&gt;--set-upstream-to&lt;/code&gt; 设置上游，则该分支必须在其上游分支或 &lt;code&gt;HEAD&lt;/code&gt; 中完全合并。</target>
        </trans-unit>
        <trans-unit id="e9f3df8cb2d062f0173b4dadd305c9e0eadc7f1f" translate="yes" xml:space="preserve">
          <source>Delete an unneeded branch</source>
          <target state="translated">删除一个不需要的分支</target>
        </trans-unit>
        <trans-unit id="3627df6f5c316b48c9a0e828b45ee4b23f9a149d" translate="yes" xml:space="preserve">
          <source>Delete existing replace refs for the given objects.</source>
          <target state="translated">删除给定对象的现有替换参考。</target>
        </trans-unit>
        <trans-unit id="6b8d128c004ee953175f88ab766106d4cfa01d06" translate="yes" xml:space="preserve">
          <source>Delete existing tags with the given names.</source>
          <target state="translated">刪除現有的標籤。</target>
        </trans-unit>
        <trans-unit id="ec34ecd3e43b7835223d180bb5b62d7a1f50ff85" translate="yes" xml:space="preserve">
          <source>Delete the &quot;test&quot; branch even if the &quot;master&quot; branch (or whichever branch is currently checked out) does not have all commits from the test branch.</source>
          <target state="translated">删除 &quot;test &quot;分支,即使 &quot;master &quot;分支(或当前检查出的任何一个分支)没有从测试分支提交所有的内容。</target>
        </trans-unit>
        <trans-unit id="5060fa25753a50b8acf6be2071a5d6f5afc4acd3" translate="yes" xml:space="preserve">
          <source>Delete the pack-files that are tracked by the MIDX file, but have no objects referenced by the MIDX. Rewrite the MIDX file afterward to remove all references to these pack-files.</source>
          <target state="translated">删除被 MIDX 文件跟踪,但没有 MIDX 引用的对象的 pack-file。之后重写MIDX文件,删除对这些包文件的所有引用。</target>
        </trans-unit>
        <trans-unit id="34a0e7fb9687c81637f401d26cc5a141535336e8" translate="yes" xml:space="preserve">
          <source>Delete the remote-tracking branches &quot;todo&quot;, &quot;html&quot; and &quot;man&quot;. The next &lt;code&gt;fetch&lt;/code&gt; or &lt;code&gt;pull&lt;/code&gt; will create them again unless you configure them not to. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">删除远程跟踪分支&amp;ldquo; todo&amp;rdquo;，&amp;ldquo; html&amp;rdquo;和&amp;ldquo; man&amp;rdquo;。除非您不配置它们，否则下一次 &lt;code&gt;fetch&lt;/code&gt; 或 &lt;code&gt;pull&lt;/code&gt; 将再次创建它们。参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48060c17f13289e334a3727f4f1de95de800b004" translate="yes" xml:space="preserve">
          <source>Delete the symbolic ref &amp;lt;name&amp;gt;.</source>
          <target state="translated">删除符号引用&amp;lt;名称&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="0b8a7c3943e03f2a2e8f697e98962af3bfbc2534" translate="yes" xml:space="preserve">
          <source>Deleted submodule: A submodule can be deleted by running &lt;code&gt;git rm &amp;lt;submodule path&amp;gt; &amp;amp;&amp;amp; git commit&lt;/code&gt;. This can be undone using &lt;code&gt;git revert&lt;/code&gt;.</source>
          <target state="translated">删除的子模块：可以通过运行 &lt;code&gt;git rm &amp;lt;submodule path&amp;gt; &amp;amp;&amp;amp; git commit&lt;/code&gt; 删除子模块。可以使用 &lt;code&gt;git revert&lt;/code&gt; 撤消。</target>
        </trans-unit>
        <trans-unit id="bbae550cd78e8e22873a526e5dae0892e13b85e4" translate="yes" xml:space="preserve">
          <source>Deletes stale references associated with &amp;lt;name&amp;gt;. By default, stale remote-tracking branches under &amp;lt;name&amp;gt; are deleted, but depending on global configuration and the configuration of the remote we might even prune local tags that haven&amp;rsquo;t been pushed there. Equivalent to &lt;code&gt;git
fetch --prune &amp;lt;name&amp;gt;&lt;/code&gt;, except that no new references will be fetched.</source>
          <target state="translated">删除与&amp;lt;name&amp;gt;关联的陈旧引用。默认情况下，&amp;lt;name&amp;gt;下的陈旧的远程跟踪分支将被删除，但是根据全局配置和远程服务器的配置，我们甚至可以修剪尚未推送到此处的本地标签。等同于 &lt;code&gt;git fetch --prune &amp;lt;name&amp;gt;&lt;/code&gt; ，除了不会获取任何新引用。</target>
        </trans-unit>
        <trans-unit id="24d8888ac9265ebf12b5751431da3b3a66a3bc35" translate="yes" xml:space="preserve">
          <source>Delimited format</source>
          <target state="translated">限定格式</target>
        </trans-unit>
        <trans-unit id="b2cf66f0df0d42ad5ab4aaeb19f2b65bda3f8e44" translate="yes" xml:space="preserve">
          <source>Delta compression will not be attempted for blobs for paths with the attribute &lt;code&gt;delta&lt;/code&gt; set to false.</source>
          <target state="translated">对于属性 &lt;code&gt;delta&lt;/code&gt; 设置为false的路径，将不尝试对Blob进行Delta压缩。</target>
        </trans-unit>
        <trans-unit id="06d8459b781df550338ff8874296d04e07653551" translate="yes" xml:space="preserve">
          <source>Delta islands</source>
          <target state="translated">三角洲群岛</target>
        </trans-unit>
        <trans-unit id="1c00a92357090dcc2a4a087a5faeaa3dd4ef60a6" translate="yes" xml:space="preserve">
          <source>Delta islands solve this problem by allowing you to group your refs into distinct &quot;islands&quot;. Pack-objects computes which objects are reachable from which islands, and refuses to make a delta from an object &lt;code&gt;A&lt;/code&gt; against a base which is not present in all of &lt;code&gt;A&lt;/code&gt;'s islands. This results in slightly larger packs (because we miss some delta opportunities), but guarantees that a fetch of one island will not have to recompute deltas on the fly due to crossing island boundaries.</source>
          <target state="translated">三角洲岛屿允许您将裁判分为不同的&amp;ldquo;小岛&amp;rdquo;，从而解决了这一问题。打包对象计算从哪个岛可以到达哪些对象，并拒绝从对象 &lt;code&gt;A&lt;/code&gt; 相对于所有 &lt;code&gt;A&lt;/code&gt; 的岛中都不存在的基准得出增量。这样会导致包的数量稍大（因为我们错过了一些三角洲机会），但可以保证获取一个岛屿不会因为跨越岛屿边界而即时重新计算三角洲。</target>
        </trans-unit>
        <trans-unit id="89e6ba5af92c1476da557467d420cb383ed75bc2" translate="yes" xml:space="preserve">
          <source>Deltified representation</source>
          <target state="translated">认证代表</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="fcd6a0d5490f96a9ee2d3abff638da71da537fbf" translate="yes" xml:space="preserve">
          <source>Depending on the operation, git will use one of the following refspecs, if you don&amp;rsquo;t provide one on the command line. &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is the name of this file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; and &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; defaults to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">如果您没有在命令行中提供refspec，则git将使用以下refspec之一，具体取决于操作。 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 是 &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 中此文件的名称，而 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 默认为 &lt;code&gt;master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea16e3702c686bd547a284907194ee7b4ffac191" translate="yes" xml:space="preserve">
          <source>Depot path syntax</source>
          <target state="translated">仓库路径语法</target>
        </trans-unit>
        <trans-unit id="1983f893b78285086fe35838f9f2f81d38d4d745" translate="yes" xml:space="preserve">
          <source>Deprecated alias for &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; 的已弃用别名。</target>
        </trans-unit>
        <trans-unit id="05b4a62238617bb5a4be973f552dc324fff173a4" translate="yes" xml:space="preserve">
          <source>Deprecated alias for &lt;code&gt;sendemail.smtpEncryption = ssl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sendemail.smtpEncryption = ssl&lt;/code&gt; 已弃用别名。</target>
        </trans-unit>
        <trans-unit id="a4db2bebc38aa1316eeea066286d1da6378d7b28" translate="yes" xml:space="preserve">
          <source>Deprecated alias for &lt;code&gt;versionsort.suffix&lt;/code&gt;. Ignored if &lt;code&gt;versionsort.suffix&lt;/code&gt; is set.</source>
          <target state="translated">&lt;code&gt;versionsort.suffix&lt;/code&gt; 的已弃用别名。如果设置了 &lt;code&gt;versionsort.suffix&lt;/code&gt; ，则将其忽略。</target>
        </trans-unit>
        <trans-unit id="d156ce209204264f931768dbe9676b2798b77199" translate="yes" xml:space="preserve">
          <source>Deprecated synonym for &lt;code&gt;find-renames=&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;find-renames=&amp;lt;n&amp;gt;&lt;/code&gt; 的已弃用同义词。</target>
        </trans-unit>
        <trans-unit id="f08e2766ccb54250d4b3556b2590b15bf5d66a82" translate="yes" xml:space="preserve">
          <source>Dereference tags into object IDs as well. They will be shown with &quot;^{}&quot; appended.</source>
          <target state="translated">将标签也衍生到对象ID中。它们将以附加&quot;^{}&quot;来显示。</target>
        </trans-unit>
        <trans-unit id="19ab5a2b07f917835d2a43707ceb85ed7b98a04e" translate="yes" xml:space="preserve">
          <source>Describe the patterns in the sparse-checkout file.</source>
          <target state="translated">描述稀疏结账文件中的模式。</target>
        </trans-unit>
        <trans-unit id="3adaea2f7c94d999c480c31a9d97431cd4a29972" translate="yes" xml:space="preserve">
          <source>Describe the state of the working tree. When the working tree matches HEAD, the output is the same as &quot;git describe HEAD&quot;. If the working tree has local modification &quot;-dirty&quot; is appended to it. If a repository is corrupt and Git cannot determine if there is local modification, Git will error out, unless &amp;lsquo;--broken&amp;rsquo; is given, which appends the suffix &quot;-broken&quot; instead.</source>
          <target state="translated">描述工作树的状态。当工作树匹配HEAD时，输出与&amp;ldquo; git describe HEAD&amp;rdquo;相同。如果工作树具有本地修改，则将&amp;ldquo; -dirty&amp;rdquo;附加到工作树上。如果存储库已损坏，并且Git无法确定是否存在本地修改，则Git会出错，除非给出'--broken'，而是在后缀后缀&amp;ldquo; -broken&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="d6cee108138bd9a1ce855b1d73c719745374ce44" translate="yes" xml:space="preserve">
          <source>Design details</source>
          <target state="translated">设计细节</target>
        </trans-unit>
        <trans-unit id="7e2d8329f700e85ec6f60947dd853588b3fee1c7" translate="yes" xml:space="preserve">
          <source>Designed with http and stateless-rpc in mind. With clear flush semantics the http remote helper can simply act as a proxy</source>
          <target state="translated">以http和无状态的rpc为设计理念。通过清晰的flush语义,http远程帮助程序可以简单地作为代理。</target>
        </trans-unit>
        <trans-unit id="a30dd6eb385d802e85851897aa84247984d6f5fe" translate="yes" xml:space="preserve">
          <source>Detach from the shell. Implies --syslog.</source>
          <target state="translated">从shell中分离出来。意味着-syslog。</target>
        </trans-unit>
        <trans-unit id="e5497c96dfd8b989db42ae40a552822ac0beda8b" translate="yes" xml:space="preserve">
          <source>Detached head</source>
          <target state="translated">独立的头</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="67aa19cf55a723bbb26944cac78345fab055b208" translate="yes" xml:space="preserve">
          <source>Detect copies as well as renames. See also &lt;code&gt;--find-copies-harder&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is specified, it has the same meaning as for &lt;code&gt;-M&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">检测副本以及重命名。另请参见 &lt;code&gt;--find-copies-harder&lt;/code&gt; 。如果指定 &lt;code&gt;n&lt;/code&gt; ，则其含义与 &lt;code&gt;-M&amp;lt;n&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01c2501577dd3675d86bed17ffb08591c732fcb7" translate="yes" xml:space="preserve">
          <source>Detect copies harder. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. A boolean.</source>
          <target state="translated">更努力地检测副本。参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;。一个布尔值。</target>
        </trans-unit>
        <trans-unit id="1b3059b4d74c2df5e3146bf7b20891041e88ba9a" translate="yes" xml:space="preserve">
          <source>Detect copies. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. This can be true, false, or a score as expected by &lt;code&gt;git diff -C&lt;/code&gt;.</source>
          <target state="translated">检测副本。参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;。这可以是真，假或 &lt;code&gt;git diff -C&lt;/code&gt; 期望的分数。</target>
        </trans-unit>
        <trans-unit id="1070111ce881d033aa11a2603f524ec35d0cf5af" translate="yes" xml:space="preserve">
          <source>Detect moved or copied lines within a file. When a commit moves or copies a block of lines (e.g. the original file has A and then B, and the commit changes it to B and then A), the traditional &lt;code&gt;blame&lt;/code&gt; algorithm notices only half of the movement and typically blames the lines that were moved up (i.e. B) to the parent and assigns blame to the lines that were moved down (i.e. A) to the child commit. With this option, both groups of lines are blamed on the parent by running extra passes of inspection.</source>
          <target state="translated">检测文件中移动或复制的行。当提交移动或复制一行代码块时（例如，原始文件的A依次为B，然后提交更改为B然后是A），传统的 &lt;code&gt;blame&lt;/code&gt; 算法仅注意到移动的一半，通常将其归咎于向父级上移（即B），并向子级提交下移（即A）的行负责。使用此选项，通过运行额外的检查通道，两组线都归咎于父级。</target>
        </trans-unit>
        <trans-unit id="1b96566ef127f8d019345c2f29a72c790e874b75" translate="yes" xml:space="preserve">
          <source>Detect renames. If &lt;code&gt;n&lt;/code&gt; is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file&amp;rsquo;s size). For example, &lt;code&gt;-M90%&lt;/code&gt; means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn&amp;rsquo;t changed. Without a &lt;code&gt;%&lt;/code&gt; sign, the number is to be read as a fraction, with a decimal point before it. I.e., &lt;code&gt;-M5&lt;/code&gt; becomes 0.5, and is thus the same as &lt;code&gt;-M50%&lt;/code&gt;. Similarly, &lt;code&gt;-M05&lt;/code&gt; is the same as &lt;code&gt;-M5%&lt;/code&gt;. To limit detection to exact renames, use &lt;code&gt;-M100%&lt;/code&gt;. The default similarity index is 50%.</source>
          <target state="translated">检测重命名。如果指定了 &lt;code&gt;n&lt;/code&gt; ，则它是相似性索引的阈值（即，与文件大小相比增加/删除的数量）。例如， &lt;code&gt;-M90%&lt;/code&gt; 表示如果文件的90％以上没有更改，则 Git应该将删除/添加对视为重命名。如果没有 &lt;code&gt;%&lt;/code&gt; 符号，则该数字应作为分数读取，并在其前面加上小数点。即， &lt;code&gt;-M5&lt;/code&gt; 变为0.5，因此与 &lt;code&gt;-M50%&lt;/code&gt; 相同。同样， &lt;code&gt;-M05&lt;/code&gt; 与 &lt;code&gt;-M5%&lt;/code&gt; 相同。要将检测范围限制为完全重命名，请使用 &lt;code&gt;-M100%&lt;/code&gt; 。默认相似度索引为50％。</target>
        </trans-unit>
        <trans-unit id="6d7e84e2caa06e6a8098c62271376428c6e7bd4b" translate="yes" xml:space="preserve">
          <source>Detect renames. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. Renames will be represented in p4 using explicit &lt;code&gt;move&lt;/code&gt; operations. There is no corresponding option to detect copies, but there are variables for both moves and copies.</source>
          <target state="translated">检测重命名。参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;。重命名将使用显式 &lt;code&gt;move&lt;/code&gt; 操作在p4中表示。没有检测副本的相应选项，但是移动和副本都有变量。</target>
        </trans-unit>
        <trans-unit id="5ffd73e1a52e577bf08689eed36f6c4de2377e40" translate="yes" xml:space="preserve">
          <source>Detect renames. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. This can be true, false, or a score as expected by &lt;code&gt;git diff -M&lt;/code&gt;.</source>
          <target state="translated">检测重命名。参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;。这可以是真，假或 &lt;code&gt;git diff -M&lt;/code&gt; 期望的分数。</target>
        </trans-unit>
        <trans-unit id="4eef9174ad5648c91981effc420fca59fc15dfb0" translate="yes" xml:space="preserve">
          <source>Determine the reference name to use for a new branch:</source>
          <target state="translated">确定用于新分支的参考名称。</target>
        </trans-unit>
        <trans-unit id="2fd1f63eeed6a134512b420d9c8a0d335169ab6d" translate="yes" xml:space="preserve">
          <source>Determine whether there are commits in &lt;code&gt;&amp;lt;head&amp;gt;..&amp;lt;upstream&amp;gt;&lt;/code&gt; that are equivalent to those in the range &lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">确定 &lt;code&gt;&amp;lt;head&amp;gt;..&amp;lt;upstream&amp;gt;&lt;/code&gt; 中是否有等同于 &lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt; 范围内的提交。</target>
        </trans-unit>
        <trans-unit id="c3dd19e2791ee2ded730804490298d3d980bfa4d" translate="yes" xml:space="preserve">
          <source>Determines if &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; should trust the file modification timestamp or not. By default the timestamps are not trusted.</source>
          <target state="translated">确定&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt;是否应该信任文件修改时间戳。默认情况下，时间戳不受信任。</target>
        </trans-unit>
        <trans-unit id="e154fe8e767c839e2059b235fd308381f6d8cea3" translate="yes" xml:space="preserve">
          <source>Determines if &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; shows untracked files in the file list. The default is &quot;true&quot;.</source>
          <target state="translated">确定&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]是否&lt;/a&gt;在文件列表中显示未跟踪的文件。默认值为&amp;ldquo; true&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3f3ff5df4fcb4c5f3c82bb56b168b10367f53dcc" translate="yes" xml:space="preserve">
          <source>Determines if new branches created with &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; should default to tracking remote branches with matching names or not. Default: &quot;false&quot;.</source>
          <target state="translated">确定使用&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt;创建的新分支是否应默认跟踪具有匹配名称的远程分支。默认值：&amp;ldquo; false&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2f06095b37712166bde39a43d96d1f0785678946" translate="yes" xml:space="preserve">
          <source>Determines what to do about the untracked cache feature of the index. It will be kept, if this variable is unset or set to &lt;code&gt;keep&lt;/code&gt;. It will automatically be added if set to &lt;code&gt;true&lt;/code&gt;. And it will automatically be removed, if set to &lt;code&gt;false&lt;/code&gt;. Before setting it to &lt;code&gt;true&lt;/code&gt;, you should check that mtime is working properly on your system. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;. &lt;code&gt;keep&lt;/code&gt; by default, unless &lt;code&gt;feature.manyFiles&lt;/code&gt; is enabled which sets this setting to &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">确定如何处理索引的未跟踪缓存功能。如果未设置此变量或将其设置为 &lt;code&gt;keep&lt;/code&gt; ，它将被保留。如果设置为 &lt;code&gt;true&lt;/code&gt; ，它将自动添加。如果设置为 &lt;code&gt;false&lt;/code&gt; ，它将被自动删除。在将其设置为 &lt;code&gt;true&lt;/code&gt; 之前，您应该检查mtime在系统上是否正常工作。参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;。默认情况下 &lt;code&gt;keep&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，除非启用 &lt;code&gt;feature.manyFiles&lt;/code&gt; ，默认情况下将此设置设置为true。</target>
        </trans-unit>
        <trans-unit id="64ca3fdabc3574a39df154eb5758766a9b3dabde" translate="yes" xml:space="preserve">
          <source>Developing against a shared repository</source>
          <target state="translated">在共享资源库中开发</target>
        </trans-unit>
        <trans-unit id="4359a6a8e374a18f2b4c156842b9c3a0fec4c744" translate="yes" xml:space="preserve">
          <source>Developing with git</source>
          <target state="translated">使用git开发</target>
        </trans-unit>
        <trans-unit id="a7a451f70e401e1b204facb3a3e4f97e68c2b291" translate="yes" xml:space="preserve">
          <source>Development cost</source>
          <target state="translated">开发费用</target>
        </trans-unit>
        <trans-unit id="a2efcf35d137bb5a7503ecfbad3617a7e3a45807" translate="yes" xml:space="preserve">
          <source>Die if the pack contains broken links. For internal use only.</source>
          <target state="translated">如果数据包中包含断裂的链接,则死机。仅供内部使用。</target>
        </trans-unit>
        <trans-unit id="c1ab34d973a0a532c231ce665c73c7ea8acc0a78" translate="yes" xml:space="preserve">
          <source>Die if the pack contains broken objects. For internal use only.</source>
          <target state="translated">如果包内有破损的物体,则死机。仅供内部使用。</target>
        </trans-unit>
        <trans-unit id="d986c34724963dfe3d695e6191fc573a97f2025e" translate="yes" xml:space="preserve">
          <source>Die with error code != 0 when a reference is undefined, instead of printing &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">当未定义引用时打印错误代码！= 0，而不是打印 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78795c9d90cdad9316079a8696dae908d814a635" translate="yes" xml:space="preserve">
          <source>Die, if the pack contains broken objects or links.</source>
          <target state="translated">如果包中有破损的对象或链接,则死机。</target>
        </trans-unit>
        <trans-unit id="98ae64918b361ad15c4c43eb611e71c996a3c9bc" translate="yes" xml:space="preserve">
          <source>Die, if the pack is larger than &amp;lt;size&amp;gt;.</source>
          <target state="translated">死亡，如果背包大于&amp;lt;size&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="cd98a991a043eaea48f8e37b61339dac2bfa9ec4" translate="yes" xml:space="preserve">
          <source>Diff Formatting</source>
          <target state="translated">差异格式化</target>
        </trans-unit>
        <trans-unit id="de7932e0191749b8b9963fe2d05250ad20e02e5f" translate="yes" xml:space="preserve">
          <source>Diff against the &quot;base&quot; version, &quot;our branch&quot; or &quot;their branch&quot; respectively. With these options, diffs for merged entries are not shown.</source>
          <target state="translated">分别与 &quot;基础 &quot;版本、&quot;我们的分支 &quot;或 &quot;他们的分支 &quot;进行比较。有了这些选项,就不会显示合并条目的差异。</target>
        </trans-unit>
        <trans-unit id="d39943b940373b977991e15fc719e23de47c6ceb" translate="yes" xml:space="preserve">
          <source>Diff format for merges</source>
          <target state="translated">合并时的差异格式</target>
        </trans-unit>
        <trans-unit id="654f69ec27f8d4e0f2ecb2d08ba20e4caaa5cbd4" translate="yes" xml:space="preserve">
          <source>Diff is shown using the specified diff driver. Each driver may specify one or more options, as described in the following section. The options for the diff driver &quot;foo&quot; are defined by the configuration variables in the &quot;diff.foo&quot; section of the Git config file.</source>
          <target state="translated">使用指定的diff驱动来显示diff。每个驱动都可以指定一个或多个选项,如下节所述。diff驱动 &quot;foo &quot;的选项由Git配置文件中 &quot;diff.foo &quot;部分的配置变量定义。</target>
        </trans-unit>
        <trans-unit id="e9752af49676495496d54c49d4451c932889ab3e" translate="yes" xml:space="preserve">
          <source>Diffcore-break: for splitting up complete rewrites</source>
          <target state="translated">Diffcore-break:用于分割完整的重写。</target>
        </trans-unit>
        <trans-unit id="f8cbeab8828f936b2faf8e2c773445ac763403ab" translate="yes" xml:space="preserve">
          <source>Diffcore-merge-broken: for putting complete rewrites back together</source>
          <target state="translated">Diffcore-merge-broken:用于将完整的重写内容重新组合起来。</target>
        </trans-unit>
        <trans-unit id="037fc9af4089dca681837ff54ffb59e13b625177" translate="yes" xml:space="preserve">
          <source>Diffcore-order: for sorting the output based on filenames</source>
          <target state="translated">Diffcore-order:用于根据文件名对输出进行排序。</target>
        </trans-unit>
        <trans-unit id="93ec538cb6f31f250a629fbfef107579093c9275" translate="yes" xml:space="preserve">
          <source>Diffcore-pickaxe: for detecting addition/deletion of specified string</source>
          <target state="translated">Diffcore-pickaxe:用于检测指定字符串的添加/删除。</target>
        </trans-unit>
        <trans-unit id="be51b7621711d155d6251fd428e07de999420e36" translate="yes" xml:space="preserve">
          <source>Diffcore-rename: for detecting renames and copies</source>
          <target state="translated">Diffcore-rename:用于检测重名和复制。</target>
        </trans-unit>
        <trans-unit id="339450e1f1c9c473dd2ab70ee2a31028e8f96d6e" translate="yes" xml:space="preserve">
          <source>Directed acyclic graph. The &lt;a href=&quot;#def_commit_object&quot;&gt;commit objects&lt;/a&gt; form a directed acyclic graph, because they have parents (directed), and the graph of commit objects is acyclic (there is no &lt;a href=&quot;#def_chain&quot;&gt;chain&lt;/a&gt; which begins and ends with the same &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;).</source>
          <target state="translated">有向无环图。在&lt;a href=&quot;#def_commit_object&quot;&gt;对象提交&lt;/a&gt;形成有向无环图，因为它们具有父母（定向），和提交对象的图形是无环（没有&lt;a href=&quot;#def_chain&quot;&gt;链&lt;/a&gt;，其开始和结束以相同的&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c625315e724838d98d1c1aabd8894d579826b898" translate="yes" xml:space="preserve">
          <source>Directly insert the specified info into the index. For backward compatibility, you can also give these three arguments as three separate parameters, but new users are encouraged to use a single-parameter form.</source>
          <target state="translated">直接将指定的信息插入到索引中。为了向后兼容,你也可以把这三个参数作为三个独立的参数,但鼓励新用户使用单参数形式。</target>
        </trans-unit>
        <trans-unit id="9885bf10483d3b24cb6bcd826a7eb7299ae266e3" translate="yes" xml:space="preserve">
          <source>Directory in which to place the individual messages.</source>
          <target state="translated">放置各个信息的目录。</target>
        </trans-unit>
        <trans-unit id="bdcdfee6c90a03fd94f3c634dadb758ff39de642" translate="yes" xml:space="preserve">
          <source>Directory rename detection</source>
          <target state="translated">目录重命名检测</target>
        </trans-unit>
        <trans-unit id="0c0e7bc3f2d3ebf022d4ca57e3f30fa5aada7044" translate="yes" xml:space="preserve">
          <source>Directory rename heuristics are enabled in the merge and interactive backends. Due to the lack of accurate tree information, directory rename detection is disabled in the am backend.</source>
          <target state="translated">在合并和交互式后端启用了目录重命名启发式方法,由于缺乏准确的树信息,在am后端禁用了目录重命名检测。由于缺乏准确的树信息,am后端目录重命名检测被禁用。</target>
        </trans-unit>
        <trans-unit id="8016592b1dadffa6a4ff10aa4ea912d754ba679a" translate="yes" xml:space="preserve">
          <source>Disable SMTP authentication. Short hand for &lt;code&gt;--smtp-auth=none&lt;/code&gt;</source>
          <target state="translated">禁用SMTP身份验证。短手 &lt;code&gt;--smtp-auth=none&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8effb38233ed8f993bad8ba7def3e4c7198d5381" translate="yes" xml:space="preserve">
          <source>Disable all charset re-coding of the metadata.</source>
          <target state="translated">禁用元数据的所有字符集重新编码。</target>
        </trans-unit>
        <trans-unit id="bff793fc9150fa9cc2d296006f1d7ecf24724c75" translate="yes" xml:space="preserve">
          <source>Disable all logging.</source>
          <target state="translated">禁用所有记录。</target>
        </trans-unit>
        <trans-unit id="6a02367b3dfa3269f43aabd8b369dc39498517bc" translate="yes" xml:space="preserve">
          <source>Disable all output of the program. Implies &lt;code&gt;--exit-code&lt;/code&gt;.</source>
          <target state="translated">禁用程序的所有输出。意味着 &lt;code&gt;--exit-code&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65ffdeb8d93ba1775007aefed8ede380f65dc5fc" translate="yes" xml:space="preserve">
          <source>Disable recursive fetching of submodules (this has the same effect as using the &lt;code&gt;--recurse-submodules=no&lt;/code&gt; option).</source>
          <target state="translated">禁用子模块的递归提取（与使用 &lt;code&gt;--recurse-submodules=no&lt;/code&gt; 选项具有相同的效果）。</target>
        </trans-unit>
        <trans-unit id="9197fea967c3dddcae2815fd5c61af7013500ac4" translate="yes" xml:space="preserve">
          <source>Disable sparse checkout support even if &lt;code&gt;core.sparseCheckout&lt;/code&gt; is true.</source>
          <target state="translated">即使 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 为true，也请禁用稀疏签出支持。</target>
        </trans-unit>
        <trans-unit id="90bc67ccb52fc4f00ea5bb7d3ea677b5d866b7a3" translate="yes" xml:space="preserve">
          <source>Disable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; config setting, and restore the working directory to include all files. Leaves the sparse-checkout file intact so a later &lt;code&gt;git sparse-checkout init&lt;/code&gt; command may return the working directory to the same state.</source>
          <target state="translated">禁用 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 配置设置，并还原工作目录以包括所有文件。使sparse-checkout文件保持完整，因此以后的 &lt;code&gt;git sparse-checkout init&lt;/code&gt; 命令可能会使工作目录返回相同状态。</target>
        </trans-unit>
        <trans-unit id="850c7ae0114510cb68dad1845148d77f171826d0" translate="yes" xml:space="preserve">
          <source>Disable the automatic rebase after all commits have been successfully submitted. Can also be set with git-p4.disableRebase.</source>
          <target state="translated">在所有提交成功后,禁用自动重垒。也可以使用 git-p4.disableRebase 进行设置。</target>
        </trans-unit>
        <trans-unit id="70abb355de69ea1d7f24feac052795b5a3ce287a" translate="yes" xml:space="preserve">
          <source>Disable the automatic sync of p4/master from Perforce after commits have been submitted. Implies --disable-rebase. Can also be set with git-p4.disableP4Sync. Sync with origin/master still goes ahead if possible.</source>
          <target state="translated">提交提交后,禁用 Perforce 的 p4/master 自动同步。意味着 --disable-rebase,也可以用 git-p4.disableP4Sync 设置。也可以用 git-p4.disableP4Sync 设置。如果可能的话,与origin/master的同步仍然会进行。</target>
        </trans-unit>
        <trans-unit id="81f65186f299582e8d75d06c846cd0089af76798" translate="yes" xml:space="preserve">
          <source>Disable the creation of an attachment, overriding the configuration setting.</source>
          <target state="translated">禁用附件的创建,覆盖配置设置。</target>
        </trans-unit>
        <trans-unit id="bf4cee356cf7010ff2baed05e8bfe18333a1862b" translate="yes" xml:space="preserve">
          <source>Disable the indent heuristic.</source>
          <target state="translated">禁用缩进启发式。</target>
        </trans-unit>
        <trans-unit id="ca23a42f95c7adc909029c511091f97b9f4f227c" translate="yes" xml:space="preserve">
          <source>Disable the output shown by --stats, making fast-import usually be silent when it is successful. However, if the import stream has directives intended to show user output (e.g. &lt;code&gt;progress&lt;/code&gt; directives), the corresponding messages will still be shown.</source>
          <target state="translated">禁用--stats显示的输出，通常使成功导入时，快速导入通常处于静默状态。但是，如果导入流具有旨在显示用户输出的指令（例如， &lt;code&gt;progress&lt;/code&gt; 指令），则仍将显示相应的消息。</target>
        </trans-unit>
        <trans-unit id="10ad29909e3f37bb2f27c987f74a4679173f8135" translate="yes" xml:space="preserve">
          <source>Disable the use of format=flowed: Edit..Preferences..Advanced..Config Editor. Search for &quot;mailnews.send_plaintext_flowed&quot;. Toggle it to make sure it is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">禁用format = flowed：Edit..Preferences..Advanced..Config编辑器。搜索&amp;ldquo; mailnews.send_plaintext_flowed&amp;rdquo;。切换它以确保将其设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="858dc1d60e7e85d31f91783e5cf3256c04a8098e" translate="yes" xml:space="preserve">
          <source>Disable word diff again.</source>
          <target state="translated">再次禁用字差。</target>
        </trans-unit>
        <trans-unit id="52c6bf677e030bd9b9c77d01d12b29e894c5d472" translate="yes" xml:space="preserve">
          <source>Disables the &lt;code&gt;renormalize&lt;/code&gt; option. This overrides the &lt;code&gt;merge.renormalize&lt;/code&gt; configuration variable.</source>
          <target state="translated">禁用 &lt;code&gt;renormalize&lt;/code&gt; 选项。这将覆盖 &lt;code&gt;merge.renormalize&lt;/code&gt; 配置变量。</target>
        </trans-unit>
        <trans-unit id="493a0332cb486f682d77bc8e837afda65d0ed478" translate="yes" xml:space="preserve">
          <source>Disallow external diff drivers.</source>
          <target state="translated">不允许使用外部差速器。</target>
        </trans-unit>
        <trans-unit id="ede3a1ef0a8990ff80cb58919eb8be7140b4f5fa" translate="yes" xml:space="preserve">
          <source>Discard the specified revision as well, keeping the nearest parent instead.</source>
          <target state="translated">将指定的修订版也丢弃,而保留最近的父版。</target>
        </trans-unit>
        <trans-unit id="8fb937b602b4f2ef21c7fab00ac15de3b3ba49ea" translate="yes" xml:space="preserve">
          <source>Discussion</source>
          <target state="translated">Discussion</target>
        </trans-unit>
        <trans-unit id="f1c3b4b6756e9452cf8283101c3b08d9ce1ba40d" translate="yes" xml:space="preserve">
          <source>Discussion on fork-point mode</source>
          <target state="translated">关于叉点模式的讨论</target>
        </trans-unit>
        <trans-unit id="cb8eae11c31d8b3c1e7747fe036d2ab3b1d1b780" translate="yes" xml:space="preserve">
          <source>Display branch listing in columns. See configuration variable column.branch for option syntax.&lt;code&gt;--column&lt;/code&gt; and &lt;code&gt;--no-column&lt;/code&gt; without options are equivalent to &lt;code&gt;always&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt; respectively.</source>
          <target state="translated">在列中显示分支列表。有关选项语法，请参见配置变量column.branch。 &lt;code&gt;--column&lt;/code&gt; 和 &lt;code&gt;--no-column&lt;/code&gt; 不带选项相当于 &lt;code&gt;always&lt;/code&gt; 和 &lt;code&gt;never&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="25deb208645941865b584087b241dc58f16bb18f" translate="yes" xml:space="preserve">
          <source>Display data in columns</source>
          <target state="translated">按列显示数据</target>
        </trans-unit>
        <trans-unit id="00fa8df96d22edc1ad7e63a08b37f36b16a61d74" translate="yes" xml:space="preserve">
          <source>Display diffs for the current state of the resolution. It is useful for tracking what has changed while the user is resolving conflicts. Additional arguments are passed directly to the system &lt;code&gt;diff&lt;/code&gt; command installed in PATH.</source>
          <target state="translated">显示分辨率当前状态的差异。这对于跟踪用户解决冲突时发生的更改很有用。其他参数直接传递给安装在PATH中的system &lt;code&gt;diff&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="a0cdcc7c7b07a8e4a90c3d5151fd195fb7223cf9" translate="yes" xml:space="preserve">
          <source>Display gitattributes information</source>
          <target state="translated">显示gitattributes信息</target>
        </trans-unit>
        <trans-unit id="941f2ea6c160e300fb40d6a55431420274d37d56" translate="yes" xml:space="preserve">
          <source>Display help information about Git</source>
          <target state="translated">显示关于Git的帮助信息</target>
        </trans-unit>
        <trans-unit id="5a9a3798add08be0e1f47ed8edfc2983b20e1a95" translate="yes" xml:space="preserve">
          <source>Display manual page for the command in the &lt;code&gt;info&lt;/code&gt; format. The &lt;code&gt;info&lt;/code&gt; program will be used for that purpose.</source>
          <target state="translated">以 &lt;code&gt;info&lt;/code&gt; 格式显示命令的手册页。该 &lt;code&gt;info&lt;/code&gt; 程序将用于该目的。</target>
        </trans-unit>
        <trans-unit id="e1ec38994d3bd8f0be2469bcb050567ebcdb5526" translate="yes" xml:space="preserve">
          <source>Display manual page for the command in the &lt;code&gt;man&lt;/code&gt; format. This option may be used to override a value set in the &lt;code&gt;help.format&lt;/code&gt; configuration variable.</source>
          <target state="translated">以 &lt;code&gt;man&lt;/code&gt; 格式显示命令的手册页。此选项可用于覆盖在 &lt;code&gt;help.format&lt;/code&gt; 配置变量中设置的值。</target>
        </trans-unit>
        <trans-unit id="92ffa56daac223805fbe702e38ef997d8109fbdd" translate="yes" xml:space="preserve">
          <source>Display manual page for the command in the &lt;code&gt;web&lt;/code&gt; (HTML) format. A web browser will be used for that purpose.</source>
          <target state="translated">以 &lt;code&gt;web&lt;/code&gt; （HTML）格式显示命令的手册页。为此将使用网络浏览器。</target>
        </trans-unit>
        <trans-unit id="f3b82a6e6a357a0bf9773d3a79c96ba1e61e31cb" translate="yes" xml:space="preserve">
          <source>Display or do not display detailed ahead/behind counts for the branch relative to its upstream branch. Defaults to true.</source>
          <target state="translated">显示或不显示分支相对于其上游分支的详细超前/落后计数。默认为 &quot;true&quot;。</target>
        </trans-unit>
        <trans-unit id="f65810bba6d242e31829fe1b50da76b80381c4b9" translate="yes" xml:space="preserve">
          <source>Display some basic statistics about the objects fast-import has created, the packfiles they were stored into, and the memory used by fast-import during this run. Showing this output is currently the default, but can be disabled with --quiet.</source>
          <target state="translated">显示关于 fast-import 所创建的对象的一些基本统计数据、它们被存储到的 packfiles 以及 fast-import 在这次运行中使用的内存。目前默认显示这个输出,但可以用--quiet禁用。</target>
        </trans-unit>
        <trans-unit id="64158f1a0a1ec112852f04c5185015874a0e4c81" translate="yes" xml:space="preserve">
          <source>Display specific annotated tag (tag object).</source>
          <target state="translated">显示特定的注释标签(标签对象)。</target>
        </trans-unit>
        <trans-unit id="c6c2de616f34899ad73b615717fbe54f7ad5df4c" translate="yes" xml:space="preserve">
          <source>Display tag listing in columns. See configuration variable column.tag for option syntax.&lt;code&gt;--column&lt;/code&gt; and &lt;code&gt;--no-column&lt;/code&gt; without options are equivalent to &lt;code&gt;always&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt; respectively.</source>
          <target state="translated">在列中显示标签列表。有关选项语法，请参见配置变量column.tag。 &lt;code&gt;--column&lt;/code&gt; 和 &lt;code&gt;--no-column&lt;/code&gt; 不带选项相当于 &lt;code&gt;always&lt;/code&gt; 和 &lt;code&gt;never&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="1a3622cde828191996e0ecf195f03d03b3ec44d7" translate="yes" xml:space="preserve">
          <source>Display the currently running version of &lt;code&gt;git gui&lt;/code&gt;.</source>
          <target state="translated">显示当前正在运行的 &lt;code&gt;git gui&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="93da4437ffd9aa5715f14a3f0dacdb3439b3cf81" translate="yes" xml:space="preserve">
          <source>Display the full sha1s in the output listing rather than abbreviating them.</source>
          <target state="translated">在输出列表中显示完整的sha1s,而不是缩写它们。</target>
        </trans-unit>
        <trans-unit id="9f1c97cf9d8e74c2fc80265ab817ac9d7b832aa6" translate="yes" xml:space="preserve">
          <source>Display untracked files in columns. See configuration variable column.status for option syntax.&lt;code&gt;--column&lt;/code&gt; and &lt;code&gt;--no-column&lt;/code&gt; without options are equivalent to &lt;code&gt;always&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt; respectively.</source>
          <target state="translated">在列中显示未跟踪的文件。有关选项语法，请参见配置变量column.status。 &lt;code&gt;--column&lt;/code&gt; 和 &lt;code&gt;--no-column&lt;/code&gt; 不带选项相当于 &lt;code&gt;always&lt;/code&gt; 和 &lt;code&gt;never&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="7092e241896d60ac87e32bb3193290cccc38af84" translate="yes" xml:space="preserve">
          <source>Display usage.</source>
          <target state="translated">显示用途。</target>
        </trans-unit>
        <trans-unit id="7079ee902153dd291ddf916bbe088b722407f696" translate="yes" xml:space="preserve">
          <source>Displays changes in a repository or a selected set of commits. This includes visualizing the commit graph, showing information related to each commit, and the files in the trees of each revision.</source>
          <target state="translated">显示一个版本库或一组选定的提交中的变化,包括可视化的提交图,显示与每个提交相关的信息,以及每个版本树中的文件。这包括可视化的提交图,显示与每个提交相关的信息,以及每个版本树中的文件。</target>
        </trans-unit>
        <trans-unit id="298c129f2e50c144c7e71d42c00becc8dea6a583" translate="yes" xml:space="preserve">
          <source>Displays paths that have differences between the index file and the current HEAD commit, paths that have differences between the working tree and the index file, and paths in the working tree that are not tracked by Git (and are not ignored by &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;). The first are what you &lt;code&gt;would&lt;/code&gt; commit by running &lt;code&gt;git commit&lt;/code&gt;; the second and third are what you &lt;code&gt;could&lt;/code&gt; commit by running &lt;code&gt;git add&lt;/code&gt; before running &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">显示索引文件和当前HEAD提交之间具有差异的路径，工作树和索引文件之间具有差异的路径以及Git不会跟踪（并且&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;不会忽略的路径））。首先你是什么人 &lt;code&gt;would&lt;/code&gt; 通过运行犯 &lt;code&gt;git commit&lt;/code&gt; ; 第二和第三个是在运行 &lt;code&gt;git commit&lt;/code&gt; 之前 &lt;code&gt;could&lt;/code&gt; 通过运行 &lt;code&gt;git add&lt;/code&gt; 提交的内容。</target>
        </trans-unit>
        <trans-unit id="a629570fab6639c414ba6b626507dad99fc801af" translate="yes" xml:space="preserve">
          <source>Displays references available in a local repository along with the associated commit IDs. Results can be filtered using a pattern and tags can be dereferenced into object IDs. Additionally, it can be used to test whether a particular ref exists.</source>
          <target state="translated">显示本地版本库中可用的引用以及相关的提交 ID。结果可以使用模式进行过滤,标签可以衍生为对象 ID。此外,它还可以用来测试一个特定的引用是否存在。</target>
        </trans-unit>
        <trans-unit id="552e170818d4ff73bae847a17956173c4cb34b11" translate="yes" xml:space="preserve">
          <source>Displays references available in a remote repository along with the associated commit IDs.</source>
          <target state="translated">显示远程仓库中可用的引用以及相关的提交 ID。</target>
        </trans-unit>
        <trans-unit id="96528dc0170b433d5bf734338e53f84118e8892f" translate="yes" xml:space="preserve">
          <source>Displays summary about given repository. This is the default command if no action is specified in URL, and only repository is specified.</source>
          <target state="translated">显示指定版本库的摘要。如果在URL中没有指定动作,并且只指定了仓库,则该命令为默认命令。</target>
        </trans-unit>
        <trans-unit id="a0bdba2bfb43b133e65f6e75b6b8767f5a655c4d" translate="yes" xml:space="preserve">
          <source>Distributed workflows</source>
          <target state="translated">分布式工作流程</target>
        </trans-unit>
        <trans-unit id="862f8a0b24f2fede02b5c7614fea634d5e3205d5" translate="yes" xml:space="preserve">
          <source>Do everything except actually send the emails.</source>
          <target state="translated">除了实际发送邮件外,其他都要做。</target>
        </trans-unit>
        <trans-unit id="c0cf7c46b6d09d46245bbf190b286bb681387914" translate="yes" xml:space="preserve">
          <source>Do everything except actually send the updates.</source>
          <target state="translated">除了实际发送更新外,其他的都要做。</target>
        </trans-unit>
        <trans-unit id="2391ab0a15e29de8c553f138bc9a5e5e1eff2f5d" translate="yes" xml:space="preserve">
          <source>Do not GPG-sign commit, to countermand a &lt;code&gt;--gpg-sign&lt;/code&gt; option given earlier on the command line.</source>
          <target state="translated">不要使用GPG-sign提交来 &lt;code&gt;--gpg-sign&lt;/code&gt; 命令行前面给出的--gpg-sign选项。</target>
        </trans-unit>
        <trans-unit id="e60712f9f236c24928017c46a4121b75b37250b5" translate="yes" xml:space="preserve">
          <source>Do not actually prune any entries; just show what would have been pruned.</source>
          <target state="translated">不要实际修剪任何条目,只需显示本应修剪的内容。</target>
        </trans-unit>
        <trans-unit id="c1e5372fe0faa123824db425165ec2fea2793861" translate="yes" xml:space="preserve">
          <source>Do not add the Message-ID header to the commit message. &lt;code&gt;no-message-id&lt;/code&gt; is useful to override &lt;code&gt;am.messageid&lt;/code&gt;.</source>
          <target state="translated">不要将Message-ID标头添加到提交消息中。 &lt;code&gt;no-message-id&lt;/code&gt; 有助于覆盖 &lt;code&gt;am.messageid&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57e3f3ba3ed0b684d610d78f35decbf2d82cbdb0" translate="yes" xml:space="preserve">
          <source>Do not assume that the remote repository is complete in its current state, and verify all objects in the entire local ref&amp;rsquo;s history exist in the remote repository.</source>
          <target state="translated">不要假设远程存储库在其当前状态下是完整的，请验证远程存储库中是否存在整个本地引用历史记录中的所有对象。</target>
        </trans-unit>
        <trans-unit id="90fec1270ba2d2b20ae4223418ef68e2bfdd8b58" translate="yes" xml:space="preserve">
          <source>Do not change the message at all.</source>
          <target state="translated">完全不要改变信息。</target>
        </trans-unit>
        <trans-unit id="08226113a8a9e7f80d0cdebc9507aad8bbcea024" translate="yes" xml:space="preserve">
          <source>Do not checkout the new working tree at each iteration of the bisection process. Instead just update a special reference named &lt;code&gt;BISECT_HEAD&lt;/code&gt; to make it point to the commit that should be tested.</source>
          <target state="translated">不要在二等分过程的每次迭代中检出新的工作树。相反，只需更新一个名为 &lt;code&gt;BISECT_HEAD&lt;/code&gt; 的特殊引用，使其指向应进行测试的提交即可。</target>
        </trans-unit>
        <trans-unit id="032bbf4a51cb5f8b4c87bc5a87ccbf7ce7d9972e" translate="yes" xml:space="preserve">
          <source>Do not complain about a failed merge program (a merge program failure usually indicates conflicts during the merge). This is for porcelains which might want to emit custom messages.</source>
          <target state="translated">不要抱怨合并程序失败(合并程序失败通常表示合并过程中的冲突)。这是为那些可能想要发出自定义消息的瓷器准备的。</target>
        </trans-unit>
        <trans-unit id="828652d2b0b568421d6c7e9bbf13386dea23e106" translate="yes" xml:space="preserve">
          <source>Do not consider commits that are referenced only by an entry in a reflog to be reachable. This option is meant only to search for commits that used to be in a ref, but now aren&amp;rsquo;t, but are still in that corresponding reflog.</source>
          <target state="translated">不要认为仅由reflog中的条目引用的提交是可到达的。此选项仅用于搜索以前在引用中但现在不在引用中但仍在相应引用日志中的提交。</target>
        </trans-unit>
        <trans-unit id="e869fbf733c283b771007d82b91f9b0969cfb747" translate="yes" xml:space="preserve">
          <source>Do not consider it an error to request removing notes from an object that does not have notes attached to it.</source>
          <target state="translated">不要认为要求从一个没有附加注解的对象中删除注解是一个错误。</target>
        </trans-unit>
        <trans-unit id="1ecb147f602b4581f87540a29b063aa61604b712" translate="yes" xml:space="preserve">
          <source>Do not consider tags matching the given &lt;code&gt;glob(7)&lt;/code&gt; pattern, excluding the &quot;refs/tags/&quot; prefix. If used with &lt;code&gt;--all&lt;/code&gt;, it also does not consider local branches and remote-tracking references matching the pattern, excluding respectively &quot;refs/heads/&quot; and &quot;refs/remotes/&quot; prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated and tags matching any of the patterns will be excluded. When combined with --match a tag will be considered when it matches at least one --match pattern and does not match any of the --exclude patterns. Use &lt;code&gt;--no-exclude&lt;/code&gt; to clear and reset the list of patterns.</source>
          <target state="translated">不要考虑与给定 &lt;code&gt;glob(7)&lt;/code&gt; 模式匹配的标签，但不包括&amp;ldquo; refs / tags /&amp;rdquo;前缀。如果与 &lt;code&gt;--all&lt;/code&gt; 一起使用，它还将不考虑与该模式匹配的本地分支和远程跟踪引用，分别不包括&amp;ldquo; refs / heads /&amp;rdquo;和&amp;ldquo; refs / remotes /&amp;rdquo;前缀；从不考虑其他类型的引用。如果多次给出，则将累积模式列表，并且将排除与任何模式匹配的标签。与--match结合使用时，如果标签至少匹配一个--match模式且不匹配任何--exclude模式，则将考虑标记。使用 &lt;code&gt;--no-exclude&lt;/code&gt; 清除并重置模式列表。</target>
        </trans-unit>
        <trans-unit id="037f30ef5e84974359cf44c16519221f2879783e" translate="yes" xml:space="preserve">
          <source>Do not create a commit, but show a list of paths that are to be committed, paths with local changes that will be left uncommitted and paths that are untracked.</source>
          <target state="translated">不要创建提交,而是显示要提交的路径列表,有局部变化的路径将不提交,未跟踪的路径。</target>
        </trans-unit>
        <trans-unit id="8cc46cc75e4001540bdd6b36d05862e218e46c47" translate="yes" xml:space="preserve">
          <source>Do not create objects in the object database for all &amp;lt;file&amp;gt; arguments that follow this flag; just insert their object IDs into the index.</source>
          <target state="translated">不要在对象数据库中为该标志后面的所有&amp;lt;file&amp;gt;自变量创建对象；只需将其对象ID插入索引中即可。</target>
        </trans-unit>
        <trans-unit id="7cb5295efb5286a379b8d83e6238db5f1ea1b2fa" translate="yes" xml:space="preserve">
          <source>Do not fetch remotely; only run &lt;code&gt;git rebase&lt;/code&gt; against the last fetched commit from the upstream SVN.</source>
          <target state="translated">不要远程获取；仅针对从上游SVN提取的最后一次提交运行 &lt;code&gt;git rebase&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97bf9439cf9070cedb99b3389632fc0fbbcf9edf" translate="yes" xml:space="preserve">
          <source>Do not honor textconv filter settings. This is the default.</source>
          <target state="translated">不尊重textconv过滤器设置。这是默认的。</target>
        </trans-unit>
        <trans-unit id="642b94f1b0f16f8086c6d9b3c2a88d58a07a371f" translate="yes" xml:space="preserve">
          <source>Do not ignore whitespace when performing move detection.</source>
          <target state="translated">在进行移动检测时,不要忽略空白处。</target>
        </trans-unit>
        <trans-unit id="59383a29c043832ab98b518f841a638207c2a6f4" translate="yes" xml:space="preserve">
          <source>Do not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as &lt;code&gt;--color-moved-ws=no&lt;/code&gt;.</source>
          <target state="translated">执行移动检测时，请勿忽略空格。这可用于覆盖配置设置。与 &lt;code&gt;--color-moved-ws=no&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f9b8ad508a1efad0691851330497788c20711761" translate="yes" xml:space="preserve">
          <source>Do not include a patch that matches a commit in &amp;lt;until&amp;gt;..&amp;lt;since&amp;gt;. This will examine all patches reachable from &amp;lt;since&amp;gt; but not from &amp;lt;until&amp;gt; and compare them with the patches being generated, and any patch that matches is ignored.</source>
          <target state="translated">不要包含与&amp;lt;until&amp;gt; .. &amp;lt;since&amp;gt;中的提交匹配的补丁。这将检查从&amp;lt;since&amp;gt;可访问的所有补丁，但不能从&amp;lt;until&amp;gt;进行访问，并将它们与正在生成的补丁进行比较，所有匹配的补丁都将被忽略。</target>
        </trans-unit>
        <trans-unit id="06c89fdde45df9764a8423e7bd3a2334bae4fdd3" translate="yes" xml:space="preserve">
          <source>Do not include refs matching &lt;code&gt;&amp;lt;glob-pattern&amp;gt;&lt;/code&gt; that the next &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--branches&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt;, &lt;code&gt;--remotes&lt;/code&gt;, or &lt;code&gt;--glob&lt;/code&gt; would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--branches&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt;, &lt;code&gt;--remotes&lt;/code&gt;, or &lt;code&gt;--glob&lt;/code&gt; option (other options or arguments do not clear accumulated patterns).</source>
          <target state="translated">不要包括与 &lt;code&gt;&amp;lt;glob-pattern&amp;gt;&lt;/code&gt; 匹配的refs ， &lt;code&gt;--branches&lt;/code&gt; 下一个 &lt;code&gt;--all&lt;/code&gt; ，-- branches，-- &lt;code&gt;--tags&lt;/code&gt; ，-- &lt;code&gt;--remotes&lt;/code&gt; 或 &lt;code&gt;--glob&lt;/code&gt; 都会考虑使用这些引用。重复此选项将累积排除模式，直到下一个 &lt;code&gt;--all&lt;/code&gt; ，-- &lt;code&gt;--branches&lt;/code&gt; ，-- &lt;code&gt;--tags&lt;/code&gt; ，-- &lt;code&gt;--remotes&lt;/code&gt; 或 &lt;code&gt;--glob&lt;/code&gt; 选项（其他选项或参数不会清除累积的模式）。</target>
        </trans-unit>
        <trans-unit id="56a32ccb3c1f1c18304a762968ab21163044c5c3" translate="yes" xml:space="preserve">
          <source>Do not include the output of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; in the commit message template when using an editor to prepare the default commit message.</source>
          <target state="translated">使用编辑器准备默认提交消息时，请勿在提交消息模板中包括&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;的输出。</target>
        </trans-unit>
        <trans-unit id="6b5bd4195c1d74a2912285d2c4eb0c2dba4c1afa" translate="yes" xml:space="preserve">
          <source>Do not interpret any more arguments as options.</source>
          <target state="translated">不要将更多的参数解释为选项。</target>
        </trans-unit>
        <trans-unit id="e5da1b4ac510b79eb35b9d691f72663928bb7698" translate="yes" xml:space="preserve">
          <source>Do not invoke &lt;code&gt;git unpack-objects&lt;/code&gt; on received data, but create a single packfile out of it instead, and store it in the object database. If provided twice then the pack is locked against repacking.</source>
          <target state="translated">不要在接收到的数据上调用 &lt;code&gt;git unpack-objects&lt;/code&gt; ，而是从中创建一个单独的packfile，并将其存储在对象数据库中。如果提供两次，则包装被锁定以防止重新包装。</target>
        </trans-unit>
        <trans-unit id="beae705e0d7e9c4e2c66edfac5f5628c8ca8684b" translate="yes" xml:space="preserve">
          <source>Do not issue an error message if the &amp;lt;name&amp;gt; is not a symbolic ref but a detached HEAD; instead exit with non-zero status silently.</source>
          <target state="translated">如果&amp;lt;name&amp;gt;不是符号ref而是分离的HEAD，请不要发出错误消息。而是以非零状态静默退出。</target>
        </trans-unit>
        <trans-unit id="d96f65c98da537beaa0a86a4d3aea2125b47b691" translate="yes" xml:space="preserve">
          <source>Do not limit the listing to the current working directory. Implies --full-name.</source>
          <target state="translated">不要将列表限制在当前工作目录中。意味着--全名。</target>
        </trans-unit>
        <trans-unit id="0ec876803cf466a9324414e97bc9d68e8edc56a9" translate="yes" xml:space="preserve">
          <source>Do not list empty directories. Has no effect without --directory.</source>
          <target state="translated">不列出空目录。如果没有--directory,则没有效果。</target>
        </trans-unit>
        <trans-unit id="96b8b2c721697c15e0778ab602142e2343cf1855" translate="yes" xml:space="preserve">
          <source>Do not list one-line descriptions from the actual commits being merged.</source>
          <target state="translated">不要列举实际提交中的单行描述。</target>
        </trans-unit>
        <trans-unit id="50c8933f0d365d96e0aba5401a78a6eff6e0fcc0" translate="yes" xml:space="preserve">
          <source>Do not merge to downstream except with a good reason: upstream API changes affect your branch; your branch no longer merges to upstream cleanly; etc.</source>
          <target state="translated">除非有充分的理由,否则不要合并到下游:上游API的变化影响了你的分支;你的分支不再干净利落地合并到上游;等等。</target>
        </trans-unit>
        <trans-unit id="20453559ed97130ebcc8684bdfc96d4e211050a6" translate="yes" xml:space="preserve">
          <source>Do not notice anything as error.</source>
          <target state="translated">不要发现任何错误。</target>
        </trans-unit>
        <trans-unit id="6c8215f8ad086bc4c804beee0595714130addff4" translate="yes" xml:space="preserve">
          <source>Do not output contents of changes in binary files, instead display a notice that those files changed. Patches generated using this option cannot be applied properly, but they are still useful for code review.</source>
          <target state="translated">不输出二进制文件中的更改内容,而是显示这些文件更改的通知。使用此选项生成的补丁不能被正确应用,但它们对代码审查仍然有用。</target>
        </trans-unit>
        <trans-unit id="2523ea10fe468312c71da3f45d33ec2f934186fc" translate="yes" xml:space="preserve">
          <source>Do not output flag parameters.</source>
          <target state="translated">不要输出标志参数。</target>
        </trans-unit>
        <trans-unit id="97d9ab4b88ae45778b7b3d001e321ad0dc14c371" translate="yes" xml:space="preserve">
          <source>Do not output flags and parameters meant for &lt;code&gt;git rev-list&lt;/code&gt; command.</source>
          <target state="translated">不要输出用于 &lt;code&gt;git rev-list&lt;/code&gt; 命令的标志和参数。</target>
        </trans-unit>
        <trans-unit id="f763f44ab0f0b262c4086b5b655e472e8e1fbc54" translate="yes" xml:space="preserve">
          <source>Do not output flags and parameters not meant for &lt;code&gt;git rev-list&lt;/code&gt; command.</source>
          <target state="translated">不要输出不适合 &lt;code&gt;git rev-list&lt;/code&gt; 命令的标志和参数。</target>
        </trans-unit>
        <trans-unit id="08b6c73b9a5b9ae8b10db84ed02aa9ff12c3dacb" translate="yes" xml:space="preserve">
          <source>Do not output matched lines; instead, exit with status 0 when there is a match and with non-zero status when there isn&amp;rsquo;t.</source>
          <target state="translated">不输出匹配的线；相反，如果存在匹配项，则以状态0退出；如果不存在，则以非零状态退出。</target>
        </trans-unit>
        <trans-unit id="ee712c84633a2927c1551bcb0103dc0873b40235" translate="yes" xml:space="preserve">
          <source>Do not output non-flag parameters.</source>
          <target state="translated">不要输出非标志参数。</target>
        </trans-unit>
        <trans-unit id="803c0ba19a9790046951938b8c5d1389018a1cc7" translate="yes" xml:space="preserve">
          <source>Do not pay attention to ignored files specified via the &lt;code&gt;.gitignore&lt;/code&gt; mechanism. Only useful when searching files in the current directory with &lt;code&gt;--no-index&lt;/code&gt;.</source>
          <target state="translated">不要注意通过 &lt;code&gt;.gitignore&lt;/code&gt; 机制指定的忽略文件。仅在使用 &lt;code&gt;--no-index&lt;/code&gt; 搜索当前目录中的文件时有用。</target>
        </trans-unit>
        <trans-unit id="ac83dbcf3d4693958a0fe122034c7cc31b273fa9" translate="yes" xml:space="preserve">
          <source>Do not perform optional operations that require locks. This is equivalent to setting the &lt;code&gt;GIT_OPTIONAL_LOCKS&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">不要执行需要锁定的可选操作。这等效于将 &lt;code&gt;GIT_OPTIONAL_LOCKS&lt;/code&gt; 设置为 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3857914d38ac6fc1cf3a0581728d470a65e02771" translate="yes" xml:space="preserve">
          <source>Do not pipe Git output into a pager.</source>
          <target state="translated">不要把Git的输出管到寻呼机里。</target>
        </trans-unit>
        <trans-unit id="d083af3d8a98a88b0736219c9a712ace923e74ce" translate="yes" xml:space="preserve">
          <source>Do not print any progress information.</source>
          <target state="translated">不要打印任何进度信息。</target>
        </trans-unit>
        <trans-unit id="4f306796a802facf6a3ec8eb763307ebdfcd6b65" translate="yes" xml:space="preserve">
          <source>Do not print any results to stdout. When combined with &lt;code&gt;--verify&lt;/code&gt; this can be used to silently check if a reference exists.</source>
          <target state="translated">不要将任何结果打印到标准输出。与 &lt;code&gt;--verify&lt;/code&gt; 结合使用时，可用于静默检查引用是否存在。</target>
        </trans-unit>
        <trans-unit id="d36888af86796f130618636768f7e10c682f8ef3" translate="yes" xml:space="preserve">
          <source>Do not print commits with more than one parent. This is exactly the same as &lt;code&gt;--max-parents=1&lt;/code&gt;.</source>
          <target state="translated">不要打印多于一个父项的提交。这与 &lt;code&gt;--max-parents=1&lt;/code&gt; 完全相同。</target>
        </trans-unit>
        <trans-unit id="ca4c10c14f4ba2f9f3e2f89755711c5fc9a52157" translate="yes" xml:space="preserve">
          <source>Do not print remote URL to stderr.</source>
          <target state="translated">不要将远程URL打印到stderr。</target>
        </trans-unit>
        <trans-unit id="808049e7ffec5b6e655b6a9d9ae72d8ecb3de856" translate="yes" xml:space="preserve">
          <source>Do not print the names of the generated files to standard output.</source>
          <target state="translated">不要将生成的文件名打印成标准输出。</target>
        </trans-unit>
        <trans-unit id="bc87e43a7d98a5c7571b51e67897a36a4ca8ab2b" translate="yes" xml:space="preserve">
          <source>Do not prompt before launching a diff tool.</source>
          <target state="translated">在启动diff工具之前,请不要提示。</target>
        </trans-unit>
        <trans-unit id="2138cd0cdb77e09db32e703a72fd51381cd4185f" translate="yes" xml:space="preserve">
          <source>Do not prune any loose objects.</source>
          <target state="translated">不要修剪任何松散的物体。</target>
        </trans-unit>
        <trans-unit id="4ab3f3b957170dab775cfb00bbc8606872c3ea09" translate="yes" xml:space="preserve">
          <source>Do not rebase the tree against p4/master following a submit.</source>
          <target state="translated">在提交后,不要根据p4/master重新确定树的基数。</target>
        </trans-unit>
        <trans-unit id="ee64f5e74349135c206f878ac8dae99d11617c4a" translate="yes" xml:space="preserve">
          <source>Do not remove &lt;code&gt;\r&lt;/code&gt; from lines ending with &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">不要从 &lt;code&gt;\r\n&lt;/code&gt; 结尾的行中删除 &lt;code&gt;\r&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f6ac36312ee3d608ed232e28cf93ff206d0103e" translate="yes" xml:space="preserve">
          <source>Do not remove anything; just report the object names whose notes would be removed.</source>
          <target state="translated">不要删除任何东西,只需报告其注解将被删除的对象名称。</target>
        </trans-unit>
        <trans-unit id="e1b8d19002620396e3e17ca0d394f58c32270c15" translate="yes" xml:space="preserve">
          <source>Do not remove anything; just report what it would remove.</source>
          <target state="translated">不要删除任何东西,只需报告它将删除什么。</target>
        </trans-unit>
        <trans-unit id="04f9e0c42631154ae3b06c4af5993cc618a97379" translate="yes" xml:space="preserve">
          <source>Do not remove skip-worktree (AKA &quot;index-only&quot;) entries even when the &lt;code&gt;--remove&lt;/code&gt; option was specified.</source>
          <target state="translated">即使指定了 &lt;code&gt;--remove&lt;/code&gt; 选项，也不要删除skip-worktree（也称为&amp;ldquo;仅索引&amp;rdquo;）条目。</target>
        </trans-unit>
        <trans-unit id="4b9504bc1ba7b31d1b6d4966504b5b4e06f71072" translate="yes" xml:space="preserve">
          <source>Do not report commits up to (and including) limit.</source>
          <target state="translated">不报告不超过(含)限额的承诺。</target>
        </trans-unit>
        <trans-unit id="01c55be9743ceb727e1460223caf6f63698fc951" translate="yes" xml:space="preserve">
          <source>Do not set up &quot;upstream&quot; configuration, even if the &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; configuration variable is true.</source>
          <target state="translated">即使 &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; 配置变量为true ，也不要设置&amp;ldquo;上游&amp;rdquo;配置。</target>
        </trans-unit>
        <trans-unit id="1128ceb9ee850f084ee9c90bbc32c35e1a0677f6" translate="yes" xml:space="preserve">
          <source>Do not set up &quot;upstream&quot; configuration, even if the branch.autoSetupMerge configuration variable is true.</source>
          <target state="translated">不要设置 &quot;上游 &quot;配置,即使 branch.autoSetupMerge 配置变量为真。</target>
        </trans-unit>
        <trans-unit id="040575d6c90a48f5c39a665aeb7044e9eb43b684" translate="yes" xml:space="preserve">
          <source>Do not show a diffstat as part of the rebase process.</source>
          <target state="translated">不要在rebase过程中显示diffstat。</target>
        </trans-unit>
        <trans-unit id="6441f1c36e56fb2fa459a5f0796f9c305a9cf68e" translate="yes" xml:space="preserve">
          <source>Do not show any source or destination prefix.</source>
          <target state="translated">不要显示任何源或目的前缀。</target>
        </trans-unit>
        <trans-unit id="c24868a69fc39c6ac2b9ca770ce8aa6841828fe0" translate="yes" xml:space="preserve">
          <source>Do not show naming strings for each commit.</source>
          <target state="translated">不要显示每次提交的命名字符串。</target>
        </trans-unit>
        <trans-unit id="8fa5b27db8fcf759f01b0280edfd6b3431051bf3" translate="yes" xml:space="preserve">
          <source>Do not show notes. This negates the above &lt;code&gt;--notes&lt;/code&gt; option, by resetting the list of notes refs from which notes are shown. Options are parsed in the order given on the command line, so e.g. &quot;--notes --notes=foo --no-notes --notes=bar&quot; will only show notes from &quot;refs/notes/bar&quot;.</source>
          <target state="translated">不要显示笔记。通过重置显示注释的注释引用列表，可以取消上述 &lt;code&gt;--notes&lt;/code&gt; 选项。选项是按照命令行中给定的顺序进行解析的，因此&amp;ldquo; --notes --notes = foo --no-notes --notes = bar&amp;rdquo;将仅显示&amp;ldquo; refs / notes / bar&amp;rdquo;中的注释。</target>
        </trans-unit>
        <trans-unit id="9b02c841f1914bb7e6442db5b21cd8ed24132388" translate="yes" xml:space="preserve">
          <source>Do not show peeled tags or pseudorefs like &lt;code&gt;HEAD&lt;/code&gt; in the output.</source>
          <target state="translated">不要在输出中显示剥离的标签或伪引用（例如 &lt;code&gt;HEAD&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="2e0add30bcab4fc1d372892ee84a569922f89e58" translate="yes" xml:space="preserve">
          <source>Do not show the progress.</source>
          <target state="translated">不要显示进度。</target>
        </trans-unit>
        <trans-unit id="bb40d4a42e4bfb4ff33aaa6fa93d55da54d2c4f4" translate="yes" xml:space="preserve">
          <source>Do not strip/add &lt;code&gt;[PATCH]&lt;/code&gt; from the first line of the commit log message.</source>
          <target state="translated">不要从提交日志消息的第一行剥离/添加 &lt;code&gt;[PATCH]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa99438dbaa0b24c2ee497186eaab642c50dd94c" translate="yes" xml:space="preserve">
          <source>Do not sync p4/master with Perforce following a submit. Implies git-p4.disableRebase.</source>
          <target state="translated">在提交后,不要将 p4/master 与 Perforce 同步。意味着 git-p4.disableRebase。</target>
        </trans-unit>
        <trans-unit id="7b33c8101974f45df18e3e02278464887692318a" translate="yes" xml:space="preserve">
          <source>Do not treat &lt;code&gt;---&lt;/code&gt; as the end of the commit message. Use this when you know your input contains just the commit message itself (and not an email or the output of &lt;code&gt;git format-patch&lt;/code&gt;).</source>
          <target state="translated">不要将 &lt;code&gt;---&lt;/code&gt; 视为提交消息的结尾。当您知道您的输入仅包含提交消息本身（而不是电子邮件或 &lt;code&gt;git format-patch&lt;/code&gt; 的输出）时，请使用此选项。</target>
        </trans-unit>
        <trans-unit id="be1e8c28e0eca20ad17d3a007d8e373df410066a" translate="yes" xml:space="preserve">
          <source>Do not treat root commits as boundaries in &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. This option defaults to false.</source>
          <target state="translated">在&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]中&lt;/a&gt;不要将根提交视为边界。此选项默认为false。</target>
        </trans-unit>
        <trans-unit id="1ff1f1d3f9c5e718776c8b3b20fdd0d08c30cdae" translate="yes" xml:space="preserve">
          <source>Do not treat root commits as boundaries. This can also be controlled via the &lt;code&gt;blame.showRoot&lt;/code&gt; config option.</source>
          <target state="translated">不要将根提交视为边界。也可以通过 &lt;code&gt;blame.showRoot&lt;/code&gt; 配置选项进行控制。</target>
        </trans-unit>
        <trans-unit id="24a9efa9a70e1fda7e6a923e07fce62a5dfc6f39" translate="yes" xml:space="preserve">
          <source>Do not trust the line counts in the hunk headers, but infer them by inspecting the patch (e.g. after editing the patch without adjusting the hunk headers appropriately).</source>
          <target state="translated">不要相信hunk headers中的行数,而是通过检查补丁来推断(例如,在编辑补丁后没有适当调整hunk headers)。</target>
        </trans-unit>
        <trans-unit id="ab779b8d99fe56229fa093a46cdef1a09efa24ca" translate="yes" xml:space="preserve">
          <source>Do not try &amp;lt;directory&amp;gt;/.git/ if &amp;lt;directory&amp;gt; is no Git directory.</source>
          <target state="translated">如果&amp;lt;directory&amp;gt;不是Git目录，请不要尝试&amp;lt;directory&amp;gt; /。git /。</target>
        </trans-unit>
        <trans-unit id="5c47444dc7f2fc014cd4e67acdf260f62a7c8e62" translate="yes" xml:space="preserve">
          <source>Do not try to update submodules. This option is only respected when passed before --refresh.</source>
          <target state="translated">不要尝试更新子模块。只有在--refresh之前通过时,才会尊重这个选项。</target>
        </trans-unit>
        <trans-unit id="2177408392188ae81b2d122883b73ab471a2d934" translate="yes" xml:space="preserve">
          <source>Do not update the server information with &lt;code&gt;git update-server-info&lt;/code&gt;. This option skips updating local catalog files needed to publish this repository (or a direct copy of it) over HTTP or FTP. See &lt;a href=&quot;git-update-server-info&quot;&gt;git-update-server-info[1]&lt;/a&gt;.</source>
          <target state="translated">不要使用 &lt;code&gt;git update-server-info&lt;/code&gt; 更新服务器信息。此选项跳过通过HTTP或FTP发布发布此存储库（或其直接副本）所需的更新本地目录文件。参见&lt;a href=&quot;git-update-server-info&quot;&gt;git-update-server-info [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5053c19fad3601db22669a9dc4a1e312a5878c5e" translate="yes" xml:space="preserve">
          <source>Do not use any ref whose name matches a given shell pattern. The pattern can be one of branch name, tag name or fully qualified ref name. If given multiple times, a ref will be excluded when it matches any of the given patterns. When used together with --refs, a ref will be used as a match only when it matches at least one --refs pattern and does not match any --exclude patterns. Use &lt;code&gt;--no-exclude&lt;/code&gt; to clear the list of exclude patterns.</source>
          <target state="translated">不要使用名称与给定的外壳模式匹配的任何引用。该模式可以是分支名称，标记名称或标准引用名称之一。如果多次给定，则当ref与任何给定模式匹配时，它将被排除。与--refs一起使用时，仅当ref至少匹配一个--refs模式且不匹配任何--exclude模式时，ref才用作匹配项。使用 &lt;code&gt;--no-exclude&lt;/code&gt; 清除排除模式列表。</target>
        </trans-unit>
        <trans-unit id="267f50c7506b016b112f51819982f3c9ad863c01" translate="yes" xml:space="preserve">
          <source>Do not use branch names, but only tags to name the commits</source>
          <target state="translated">不要使用分支名,而只用标签来命名提交的内容</target>
        </trans-unit>
        <trans-unit id="5e1b9e0ae819ac2e51b8b3ec6d4f3a636596bd47" translate="yes" xml:space="preserve">
          <source>Do not use local URLs here if you plan to publish your superproject!</source>
          <target state="translated">如果您计划发布您的超级项目,请不要在这里使用本地URL!</target>
        </trans-unit>
        <trans-unit id="2120668c1016ed8353ecc179a2be3de457f3b18c" translate="yes" xml:space="preserve">
          <source>Do not use replacement refs to replace Git objects. See &lt;a href=&quot;git-replace&quot;&gt;git-replace[1]&lt;/a&gt; for more information.</source>
          <target state="translated">不要使用替换引用来替换Git对象。有关更多信息，请参见&lt;a href=&quot;git-replace&quot;&gt;git-replace [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46609390af561170d35a55596a89f9a47d125a47" translate="yes" xml:space="preserve">
          <source>Do not use the --amend option of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; on a change you&amp;rsquo;ve already dcommitted. It is considered bad practice to --amend commits you&amp;rsquo;ve already pushed to a remote repository for other users, and dcommit with SVN is analogous to that.</source>
          <target state="translated">请勿在已&lt;a href=&quot;git-commit&quot;&gt;提交&lt;/a&gt;的更改上使用git-commit [1]的--amend选项。-修改已经推送给其他用户的远程存储库的提交，这是一种不好的做法，而使用SVN进行dcommit与此类似。</target>
        </trans-unit>
        <trans-unit id="6b2f85cff30ddf16b20f53be5327aa0354418c7a" translate="yes" xml:space="preserve">
          <source>Do not verify the pack contents; only show the histogram of delta chain length. With &lt;code&gt;--verbose&lt;/code&gt;, list of objects is also shown.</source>
          <target state="translated">不要检查包装内容物；仅显示增量链长度的直方图。使用 &lt;code&gt;--verbose&lt;/code&gt; ，还显示对象列表。</target>
        </trans-unit>
        <trans-unit id="a72712d97eed5eb258082e78ab4de395a4c06778" translate="yes" xml:space="preserve">
          <source>Do nothing; only show what would happen</source>
          <target state="translated">什么都不做,只显示会发生什么</target>
        </trans-unit>
        <trans-unit id="c577d001dfd39377917177f9d18813c77808015f" translate="yes" xml:space="preserve">
          <source>Do some work in the newly created Git repository:</source>
          <target state="translated">在新创建的Git仓库中做一些工作。</target>
        </trans-unit>
        <trans-unit id="d54d62a688502dd57d02a2d25bcfc45fa6646725" translate="yes" xml:space="preserve">
          <source>Do we want to maintain that ability or simply write to the existing Trace2 targets (and convert &amp;lt;key&amp;gt; to a &quot;category&quot;).</source>
          <target state="translated">我们要保持这种能力还是只写现有的Trace2目标（并将&amp;lt;key&amp;gt;转换为&amp;ldquo;类别&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="93e5f9e78ae780b1443364c8b7bf637aab6beb2e" translate="yes" xml:space="preserve">
          <source>Do your work in your repository on &lt;code&gt;master&lt;/code&gt; branch.</source>
          <target state="translated">在 &lt;code&gt;master&lt;/code&gt; 分支的存储库中进行工作。</target>
        </trans-unit>
        <trans-unit id="5732ac98ebf7d9e51cffa639f3f3c4cdaefb04a8" translate="yes" xml:space="preserve">
          <source>Does not have a default value; you must configure this variable to enable note rewriting.</source>
          <target state="translated">没有默认值,你必须配置这个变量才能启用笔记重写。</target>
        </trans-unit>
        <trans-unit id="2a5f7374d914462e8df26d1af49c06790c2a1cc2" translate="yes" xml:space="preserve">
          <source>Does not have a default value; you must configure this variable to enable note rewriting. Set it to &lt;code&gt;refs/notes/commits&lt;/code&gt; to enable rewriting for the default commit notes.</source>
          <target state="translated">没有默认值；您必须配置此变量以启用便笺重写。将其设置为 &lt;code&gt;refs/notes/commits&lt;/code&gt; 以启用对默认提交说明的重写。</target>
        </trans-unit>
        <trans-unit id="42b7d5032e74e82b8de24d902e036f1902672dbe" translate="yes" xml:space="preserve">
          <source>Does not touch the index file or the working tree at all (but resets the head to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;, just like all modes do). This leaves all your changed files &quot;Changes to be committed&quot;, as &lt;code&gt;git status&lt;/code&gt; would put it.</source>
          <target state="translated">完全不触摸索引文件或工作树（而是将头重置为 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; ，就像所有模式一样）。就像 &lt;code&gt;git status&lt;/code&gt; 那样，这会将所有更改的文件保留为&amp;ldquo;要提交的更改&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="b8aff1882bc4744bec2ac3cf958c11aa9673615c" translate="yes" xml:space="preserve">
          <source>Does this seem a bit complicated? It &lt;strong&gt;should&lt;/strong&gt; be. There is no way that it would be correct to just &quot;fix&quot; it automatically. People need to know that their tags might have been changed.</source>
          <target state="translated">这看起来有点复杂吗？它&lt;strong&gt;应该&lt;/strong&gt;是。仅仅自动&amp;ldquo;修复&amp;rdquo;它是不可能的。人们需要知道他们的标签可能已更改。</target>
        </trans-unit>
        <trans-unit id="61f5489636e8756fab43669da94d9c6eb1552eb4" translate="yes" xml:space="preserve">
          <source>Doing a &lt;code&gt;git describe&lt;/code&gt; on a tag-name will just show the tag name:</source>
          <target state="translated">在标记名上执行 &lt;code&gt;git describe&lt;/code&gt; 只会显示标记名：</target>
        </trans-unit>
        <trans-unit id="4b69a1e19eb2053bb173df0509ff0e4b7b042821" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t actually add the file(s), just show if they exist and/or will be ignored.</source>
          <target state="translated">实际上不添加文件，仅显示它们是否存在和/或将被忽略。</target>
        </trans-unit>
        <trans-unit id="f54d87f7c2ff7fc56cad12eba47750dc91bee0b4" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t actually remove any file(s). Instead, just show if they exist in the index and would otherwise be removed by the command.</source>
          <target state="translated">实际上不删除任何文件。而是仅显示它们是否存在于索引中，否则将被命令删除。</target>
        </trans-unit>
        <trans-unit id="3c2e4a22e8795c4f8e08b8be88d75867a6768a7f" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t actually remove any objects, only show those that would have been removed.</source>
          <target state="translated">实际上不删除任何对象，仅显示将要删除的对象。</target>
        </trans-unit>
        <trans-unit id="8a190a462c45d47d231a38f49fbd7f2f651bc199" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t actually remove anything, just show what would be done.</source>
          <target state="translated">实际上不删除任何内容，只是显示将要执行的操作。</target>
        </trans-unit>
        <trans-unit id="788dd7013c132044903c150a0852f5a8328a9d58" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t add the file(s), but only refresh their stat() information in the index.</source>
          <target state="translated">不添加文件，而仅刷新索引中的stat（）信息。</target>
        </trans-unit>
        <trans-unit id="f4886df5278511a526465d27599221df6718296c" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allow recursing into subdirectories</source>
          <target state="translated">不允许递归到子目录</target>
        </trans-unit>
        <trans-unit id="2b7948ae75b37ecb202b98940fbd260554ad9c60" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t apply changes to files matching the given path pattern. This can be useful when importing patchsets, where you want to exclude certain files or directories.</source>
          <target state="translated">不要将更改应用于与给定路径模式匹配的文件。在导入要排除某些文件或目录的补丁集时，这很有用。</target>
        </trans-unit>
        <trans-unit id="2f2b3b379c55090808ba7e10cb915259f5f77fb1" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t bother trying to optimize the frontend to stick to one branch at a time during an import. Although doing so might be slightly faster for fast-import, it tends to increase the complexity of the frontend code considerably.</source>
          <target state="translated">在导入过程中，不必费心尝试优化前端以一次坚持一个分支。尽管这样做对于快速导入可能会稍快一些，但它往往会大大增加前端代码的复杂性。</target>
        </trans-unit>
        <trans-unit id="9fcb0638343c39672840bc9fb655ac9cf336ccdb" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t check for &lt;code&gt;gitcvs.enabled&lt;/code&gt; in config. You also have to specify a list of allowed directories (see below) if you want to use this option.</source>
          <target state="translated">不要在配置中检查 &lt;code&gt;gitcvs.enabled&lt;/code&gt; 。如果要使用此选项，还必须指定允许目录的列表（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="f17e0ba24864a0b6291f2e5b252834a0764b0842" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t checkout new files, only refresh files already checked out.</source>
          <target state="translated">不签出新文件，仅刷新已签出的文件。</target>
        </trans-unit>
        <trans-unit id="22dcca7d230068e332b541f07dc3e71c28dc5b04" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t clone any tags, and set &lt;code&gt;remote.&amp;lt;remote&amp;gt;.tagOpt=--no-tags&lt;/code&gt; in the config, ensuring that future &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt; operations won&amp;rsquo;t follow any tags. Subsequent explicit tag fetches will still work, (see &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">不要克隆任何标签，并设置 &lt;code&gt;remote.&amp;lt;remote&amp;gt;.tagOpt=--no-tags&lt;/code&gt; 配置中没有标签，确保将来的 &lt;code&gt;git pull&lt;/code&gt; 和 &lt;code&gt;git fetch&lt;/code&gt; 操作不会跟随任何标签。随后的显式标签获取仍将起作用（请参见&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3928941c430ea9498986b54cb54f9b256c71e581" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t confuse that object with the file &lt;code&gt;hello&lt;/code&gt; itself. The object is literally just those specific &lt;strong&gt;contents&lt;/strong&gt; of the file, and however much you later change the contents in file &lt;code&gt;hello&lt;/code&gt;, the object we just looked at will never change. Objects are immutable.</source>
          <target state="translated">不要将该对象与文件 &lt;code&gt;hello&lt;/code&gt; 本身混淆。该对象实际上只是文件的那些特定&lt;strong&gt;内容&lt;/strong&gt;，但是以后您在文件 &lt;code&gt;hello&lt;/code&gt; 中更改内容时，我们刚刚查看的对象将永远不会更改。对象是不可变的。</target>
        </trans-unit>
        <trans-unit id="cf554901f1ba37dc7b685eec286604a92a0846c0" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t look in the index when undertaking the checks. This can be used to debug why a path became tracked by e.g. &lt;code&gt;git add .&lt;/code&gt; and was not ignored by the rules as expected by the user or when developing patterns including negation to match a path previously added with &lt;code&gt;git add -f&lt;/code&gt;.</source>
          <target state="translated">进行检查时不要查看索引。这可以用来调试为什么 &lt;code&gt;git add .&lt;/code&gt; 跟踪路径的原因。并没有被用户期望的规则忽略，也没有在开发包括否定的模式以匹配先前使用 &lt;code&gt;git add -f&lt;/code&gt; 添加的路径时被用户忽略。</target>
        </trans-unit>
        <trans-unit id="5a869b3f77007c08fe64b3ee7ff33b9bfbbe7c94" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t match the pattern in binary files.</source>
          <target state="translated">与二进制文件中的模式不匹配。</target>
        </trans-unit>
        <trans-unit id="5a5ec41a36a96759ae5f2ddb0abb3aacee88e9b9" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t output anything, just set exit status. This is only valid with a single pathname.</source>
          <target state="translated">不输出任何内容，只需设置退出状态即可。仅对单个路径名有效。</target>
        </trans-unit>
        <trans-unit id="c7bdd135c2e86877ecc2a31a6eaa651f0cae6dc5" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t print anything to standard output. This form is primarily meant to allow the caller to test the exit status to see if a range of objects is fully connected (or not). It is faster than redirecting stdout to &lt;code&gt;/dev/null&lt;/code&gt; as the output does not have to be formatted.</source>
          <target state="translated">不要将任何内容打印到标准输出。这种形式主要是为了允许调用者测试退出状态，以查看一定范围内的对象是否完全连接。它比将stdout重定向到 &lt;code&gt;/dev/null&lt;/code&gt; 更快，因为不必格式化输出。</target>
        </trans-unit>
        <trans-unit id="0fe178924f571848754ae3ca5c4cf62bf5caeff8" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t prompt before each invocation of the merge resolution program. This is the default if the merge resolution program is explicitly specified with the &lt;code&gt;--tool&lt;/code&gt; option or with the &lt;code&gt;merge.tool&lt;/code&gt; configuration variable.</source>
          <target state="translated">在每次调用合并解析程序之前不要提示。这是默认的，如果合并的决议程序明确地指定 &lt;code&gt;--tool&lt;/code&gt; 选项或 &lt;code&gt;merge.tool&lt;/code&gt; 配置变量。</target>
        </trans-unit>
        <trans-unit id="aa836ce110cb6ce4b0a545e26c40cb721f663696" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t require an exact match if given an SVN revision, instead find the commit corresponding to the state of the SVN repository (on the current branch) at the specified revision.</source>
          <target state="translated">如果给定了SVN修订版，则不需要完全匹配，而是在指定的修订版中找到与SVN存储库状态（在当前分支上）相对应的提交。</target>
        </trans-unit>
        <trans-unit id="30faa3ecbc3ccb0ab260167231bedadc40f9ae9d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t require an exact match if given an SVN revision; if there is not an exact match return the closest match searching forward in the history.</source>
          <target state="translated">如果提供了SVN版本，则不需要完全匹配；如果没有精确匹配，则返回历史记录中向前搜索的最接近的匹配。</target>
        </trans-unit>
        <trans-unit id="ef2daf7d2683c0bf520ff3f8d38713d17a81ee22" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t require objects present in packs from alternate object directories to be present in local packs.</source>
          <target state="translated">不需要本地对象中包含备用对象目录中包含的对象。</target>
        </trans-unit>
        <trans-unit id="e1e770659b3cd4fc8fd1b8c1f885e57fa2890f04" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t rescan the working directory for changes after the tool finishes execution.</source>
          <target state="translated">工具执行完毕后，请勿重新扫描工作目录以查找更改。</target>
        </trans-unit>
        <trans-unit id="1955458ea299c15696f62795bf10129efdff9000" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use the standard ignore rules (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), but still use the ignore rules given with &lt;code&gt;-e&lt;/code&gt; options from the command line. This allows removing all untracked files, including build products. This can be used (possibly in conjunction with &lt;code&gt;git restore&lt;/code&gt; or &lt;code&gt;git reset&lt;/code&gt;) to create a pristine working directory to test a clean build.</source>
          <target state="translated">不要使用标准的忽略规则（请参阅&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;），但仍要使用命令行中 &lt;code&gt;-e&lt;/code&gt; 选项提供的忽略规则。这允许删除所有未跟踪的文件，包括构建产品。可以使用它（可能与 &lt;code&gt;git restore&lt;/code&gt; 或 &lt;code&gt;git reset&lt;/code&gt; 结合使用）创建一个原始的工作目录以测试干净的构建。</target>
        </trans-unit>
        <trans-unit id="95e3ebfd9dfe40579e0e7bb35d42c2f1d1029d68" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t worry about the fact that the file that the &lt;code&gt;HEAD&lt;/code&gt; link points to doesn&amp;rsquo;t even exist yet &amp;mdash; you haven&amp;rsquo;t created the commit that will start your &lt;code&gt;HEAD&lt;/code&gt; development branch yet.</source>
          <target state="translated">不必担心 &lt;code&gt;HEAD&lt;/code&gt; 链接指向的文件甚至还不存在的事实-您尚未创建将启动 &lt;code&gt;HEAD&lt;/code&gt; 开发分支的提交。</target>
        </trans-unit>
        <trans-unit id="1da5527fefac2ac016e63872cd219c0c8262438e" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t write objects with broken content or links.</source>
          <target state="translated">不要写内容或链接损坏的对象。</target>
        </trans-unit>
        <trans-unit id="e7a1a9f0e0a5a192e64b7762fcd9606f05d43ef7" translate="yes" xml:space="preserve">
          <source>Dotted Range Notations</source>
          <target state="translated">虚线范围符号</target>
        </trans-unit>
        <trans-unit id="fe1f0cdd2295f0fc3d04581839d09ed55a16a282" translate="yes" xml:space="preserve">
          <source>Download from a remote Git repository via HTTP</source>
          <target state="translated">通过HTTP从远程Git仓库下载。</target>
        </trans-unit>
        <trans-unit id="836b914c612e9d15306b7c7c51825eb694378b40" translate="yes" xml:space="preserve">
          <source>Download objects and refs from another repository</source>
          <target state="translated">从其他资源库下载对象和参考资料</target>
        </trans-unit>
        <trans-unit id="8d0359221c31b38a499fab5fd3539fb10094e3f5" translate="yes" xml:space="preserve">
          <source>Downloader from http and https URL first obtains the topmost commit object name from the remote site by looking at the specified refname under &lt;code&gt;repo.git/refs/&lt;/code&gt; directory, and then tries to obtain the commit object by downloading from &lt;code&gt;repo.git/objects/xx/xxx...&lt;/code&gt; using the object name of that commit object. Then it reads the commit object to find out its parent commits and the associate tree object; it repeats this process until it gets all the necessary objects. Because of this behavior, they are sometimes also called &lt;code&gt;commit walkers&lt;/code&gt;.</source>
          <target state="translated">从http和https URL的下载程序首先通过查看 &lt;code&gt;repo.git/refs/&lt;/code&gt; 目录下的指定refname来从远程站点获取最高的提交对象名称，然后尝试通过从 &lt;code&gt;repo.git/objects/xx/xxx...&lt;/code&gt; 下载来获取提交对象。/ xxx ...使用该提交对象的对象名称。然后，它读取提交对象以找出其父提交和关联树对象；它重复此过程，直到获得所有必需的对象。由于这种行为，它们有时也称为 &lt;code&gt;commit walkers&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="412ca0a4593b6bb25e0ce340f46f24955e9564f1" translate="yes" xml:space="preserve">
          <source>Downloads a remote Git repository via HTTP.</source>
          <target state="translated">通过 HTTP 下载远程 Git 仓库。</target>
        </trans-unit>
        <trans-unit id="d85415280c4796b4419737c81adcd5229edbb60b" translate="yes" xml:space="preserve">
          <source>Draw a text-based graphical representation of the commit history on the left hand side of the output. This may cause extra lines to be printed in between commits, in order for the graph history to be drawn properly. Cannot be combined with &lt;code&gt;--no-walk&lt;/code&gt;.</source>
          <target state="translated">在输出的左侧绘制提交历史记录的基于文本的图形表示。这可能会导致在两次提交之间打印额外的行，以便正确绘制图形历史记录。不能与 &lt;code&gt;--no-walk&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="b9a3e66d069ffbfcdae00ac848d80a3d7117cd5f" translate="yes" xml:space="preserve">
          <source>Driving a bisection automatically</source>
          <target state="translated">自动驱动二段式</target>
        </trans-unit>
        <trans-unit id="8c3114460a846e0f3462ade2fcc59d06117961f0" translate="yes" xml:space="preserve">
          <source>Driving a bisection manually</source>
          <target state="translated">手动驱动二段式</target>
        </trans-unit>
        <trans-unit id="cae458d58531d4d41393b21599b7e5c5946ef1f2" translate="yes" xml:space="preserve">
          <source>Dry run. Check the pack file without actually unpacking the objects.</source>
          <target state="translated">干运行。在不实际解压对象的情况下检查包文件。</target>
        </trans-unit>
        <trans-unit id="5c890eaf0d21c06618fd87da2696a29e291c6564" translate="yes" xml:space="preserve">
          <source>Due to historical reasons a relative &lt;code&gt;filename&lt;/code&gt; is first searched relative to the current directory for &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;clone&lt;/code&gt; and relative to the root of the working tree for &lt;code&gt;fetch&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is not found, it is searched like any other command in &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">由于历史原因，首先要相对于当前目录搜索一个相对 &lt;code&gt;filename&lt;/code&gt; 以进行 &lt;code&gt;init&lt;/code&gt; 和 &lt;code&gt;clone&lt;/code&gt; 以及相对于工作树的根目录进行 &lt;code&gt;fetch&lt;/code&gt; 。如果未找到 &lt;code&gt;filename&lt;/code&gt; ，则会像 &lt;code&gt;$PATH&lt;/code&gt; 任何其他命令一样搜索它。</target>
        </trans-unit>
        <trans-unit id="7ad95c4fe8f7afde6130611f6d6b430e519d5657" translate="yes" xml:space="preserve">
          <source>Due to limitations of the current implementation, some configuration variables do not take effect until after the initial fetch and checkout. Configuration variables known to not take effect are: &lt;code&gt;remote.&amp;lt;name&amp;gt;.mirror&lt;/code&gt; and &lt;code&gt;remote.&amp;lt;name&amp;gt;.tagOpt&lt;/code&gt;. Use the corresponding &lt;code&gt;--mirror&lt;/code&gt; and &lt;code&gt;--no-tags&lt;/code&gt; options instead.</source>
          <target state="translated">由于当前实施方式的限制，某些配置变量要等到初始获取和签出后才能生效。已知不会生效的配置变量是： &lt;code&gt;remote.&amp;lt;name&amp;gt;.mirror&lt;/code&gt; 和 &lt;code&gt;remote.&amp;lt;name&amp;gt;.tagOpt&lt;/code&gt; 。请改用相应的 &lt;code&gt;--mirror&lt;/code&gt; 和 &lt;code&gt;--no-tags&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="d45f204a58b5658a36a8173fede6b8a78f6ae4f4" translate="yes" xml:space="preserve">
          <source>Due to the immutable nature of Git objects, old objects can be archived into shared, read-only directories. This variable specifies a &quot;:&quot; separated (on Windows &quot;;&quot; separated) list of Git object directories which can be used to search for Git objects. New objects will not be written to these directories.</source>
          <target state="translated">由于 Git 对象的不可更改性,旧的对象可以被归档到共享的只读目录中,这个变量指定了一个以&quot;:&quot;分隔(在 Windows 中以&quot;;&quot;分隔)的 Git 对象目录列表,用来搜索 Git 对象。这个变量指定了一个以&quot;:&quot;分隔(在 Windows 中以&quot;;&quot;分隔)的 Git 对象目录列表,可以用来搜索 Git 对象。新的对象不会被写入这些目录。</target>
        </trans-unit>
        <trans-unit id="23b7a95dc6b5470754cb8fce020cce7d3aab1ac0" translate="yes" xml:space="preserve">
          <source>Due to the non-quarantine nature of the &lt;code&gt;fetch.fsckObjects&lt;/code&gt; implementation it cannot be relied upon to leave the object store clean like &lt;code&gt;receive.fsckObjects&lt;/code&gt; can.</source>
          <target state="translated">由于 &lt;code&gt;fetch.fsckObjects&lt;/code&gt; 实现的非隔离性质，因此不能像 &lt;code&gt;receive.fsckObjects&lt;/code&gt; 一样依靠它来保持对象存储的整洁。</target>
        </trans-unit>
        <trans-unit id="68e19d88dc6eefe7753376e94bb2d970e8771158" translate="yes" xml:space="preserve">
          <source>Dumps the internal marks table to &amp;lt;file&amp;gt; when complete. Marks are written one per line as &lt;code&gt;:markid SHA-1&lt;/code&gt;. Frontends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs. As &amp;lt;file&amp;gt; is only opened and truncated at checkpoint (or completion) the same path can also be safely given to --import-marks.</source>
          <target state="translated">完成后将内部标记表转储到&amp;lt;file&amp;gt;。标记每行写为 &lt;code&gt;:markid SHA-1&lt;/code&gt; 。前端可以使用此文件在完成导入后验证导入，或在增量运行中保存标记表。由于&amp;lt;file&amp;gt;仅在检查点（或完成点）打开和截断，因此也可以安全地给--import-marks提供相同的路径。</target>
        </trans-unit>
        <trans-unit id="d5f9d9df34707e95a5d4be8e3705f8049d385295" translate="yes" xml:space="preserve">
          <source>Dumps the internal marks table to &amp;lt;file&amp;gt; when complete. Marks are written one per line as &lt;code&gt;:markid SHA-1&lt;/code&gt;. Only marks for revisions are dumped; marks for blobs are ignored. Backends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs. As &amp;lt;file&amp;gt; is only opened and truncated at completion, the same path can also be safely given to --import-marks. The file will not be written if no new object has been marked/exported.</source>
          <target state="translated">完成后将内部标记表转储到&amp;lt;file&amp;gt;。标记每行写为 &lt;code&gt;:markid SHA-1&lt;/code&gt; 。仅转储修订标记；斑点标记将被忽略。后端可以使用此文件在完成导入后验证导入，或在增量运行中保存标记表。由于&amp;lt;file&amp;gt;仅在完成时打开和截断，因此也可以安全地给--import-marks提供相同的路径。如果未标记/导出新对象，则不会写入文件。</target>
        </trans-unit>
        <trans-unit id="aec3ad9b971b7ff8255345b154c94258f560f0d2" translate="yes" xml:space="preserve">
          <source>During a merge, the working tree files are updated to reflect the result of the merge. Among the changes made to the common ancestor&amp;rsquo;s version, non-overlapping ones (that is, you changed an area of the file while the other side left that area intact, or vice versa) are incorporated in the final result verbatim. When both sides made changes to the same area, however, Git cannot randomly pick one side over the other, and asks you to resolve it by leaving what both sides did to that area.</source>
          <target state="translated">在合并期间，将更新工作树文件以反映合并结果。在对共同祖先版本所做的更改中，非重叠更改（即，您更改了文件区域，而另一侧则保留了该区域，反之亦然）被逐字包含在最终结果中。但是，当双方对同一区域进行更改时，Git不能随机选择另一侧，而要求您通过将双方所做的事情留给该区域来解决。</target>
        </trans-unit>
        <trans-unit id="d0b0f9a14f12b4d06a31ddb153754d3c653f1bb2" translate="yes" xml:space="preserve">
          <source>During fsck git may find issues with legacy data which wouldn&amp;rsquo;t be generated by current versions of git, and which wouldn&amp;rsquo;t be sent over the wire if &lt;code&gt;transfer.fsckObjects&lt;/code&gt; was set. This feature is intended to support working with legacy repositories containing such data.</source>
          <target state="translated">在fsck期间，git可能会发现遗留数据的问题，这些问题不会由git的当前版本生成，并且如果设置了 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; ,则不会通过网络发送。此功能旨在支持使用包含此类数据的旧版存储库。</target>
        </trans-unit>
        <trans-unit id="0eedfc5c015b233e6082e4e46ded41bc5da25b25" translate="yes" xml:space="preserve">
          <source>During the merge, the index holds three versions of each file. Each of these three &quot;file stages&quot; represents a different version of the file:</source>
          <target state="translated">在合并过程中,索引持有每个文件的三个版本。这三个 &quot;文件阶段 &quot;中的每一个都代表了文件的不同版本。</target>
        </trans-unit>
        <trans-unit id="338f11841fc746012903e84c16b88356c6508da5" translate="yes" xml:space="preserve">
          <source>During the normal execution of several Git commands, call-outs are made to optional scripts that allow a developer to add functionality or checking. Typically, the hooks allow for a command to be pre-verified and potentially aborted, and allow for a post-notification after the operation is done. The hook scripts are found in the &lt;code&gt;$GIT_DIR/hooks/&lt;/code&gt; directory, and are enabled by simply removing the &lt;code&gt;.sample&lt;/code&gt; suffix from the filename. In earlier versions of Git you had to make them executable.</source>
          <target state="translated">在正常执行几个Git命令期间，将对可选脚本进行调用，这些脚本允许开发人员添加功能或检查。通常，钩子允许对命令进行预验证并可能中止，并在操作完成后允许进行后通知。钩子脚本位于 &lt;code&gt;$GIT_DIR/hooks/&lt;/code&gt; 目录中，只需从文件名中删除 &lt;code&gt;.sample&lt;/code&gt; 后缀即可启用它们。在早期版本的Git中，您必须使它们可执行。</target>
        </trans-unit>
        <trans-unit id="0c9afe2970bcd3db38ea14d913886ce00bad52d6" translate="yes" xml:space="preserve">
          <source>E.g, &lt;code&gt;format:&quot;The author of %h was %an, %ar%nThe title was &amp;gt;&amp;gt;%s&amp;lt;&amp;lt;%n&quot;&lt;/code&gt; would show something like this:</source>
          <target state="translated">例如， &lt;code&gt;format:&quot;The author of %h was %an, %ar%nThe title was &amp;gt;&amp;gt;%s&amp;lt;&amp;lt;%n&quot;&lt;/code&gt; 将显示如下内容：</target>
        </trans-unit>
        <trans-unit id="f48496348ce670a87dfe7a89fce6efc7850de45b" translate="yes" xml:space="preserve">
          <source>EVENT Format</source>
          <target state="translated">事件格式</target>
        </trans-unit>
        <trans-unit id="6c7b6f5f1d21b52d57339a7396d0f52ff8e6b468" translate="yes" xml:space="preserve">
          <source>Each &quot;index&quot; entry has two bits worth of &quot;stage&quot; state. stage 0 is the normal one, and is the only one you&amp;rsquo;d see in any kind of normal use.</source>
          <target state="translated">每个&amp;ldquo;索引&amp;rdquo;条目都有两个位的&amp;ldquo;阶段&amp;rdquo;状态值。阶段0是正常阶段，并且是您在任何正常使用情况下都会看到的唯一阶段。</target>
        </trans-unit>
        <trans-unit id="81f54a7f6a9b658757fad1b0dd5d1a9971c93ea4" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;%feature&lt;/code&gt; hash element is a hash reference and has the following structure:</source>
          <target state="translated">每个 &lt;code&gt;%feature&lt;/code&gt; 哈希元素都是一个哈希引用，并具有以下结构：</target>
        </trans-unit>
        <trans-unit id="b26592933b83f1f492565be647afc2706b49b317" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;-p&lt;/code&gt; indicates the id of a parent commit object.</source>
          <target state="translated">每个 &lt;code&gt;-p&lt;/code&gt; 指示父提交对象的ID。</target>
        </trans-unit>
        <trans-unit id="e2a09fd45cc17448d565b97a290193dc0600d3ce" translate="yes" xml:space="preserve">
          <source>Each action is implemented as a subroutine, and must be present in %actions hash. Some actions are disabled by default, and must be turned on via feature mechanism. For example to enable &lt;code&gt;blame&lt;/code&gt; view add the following to gitweb configuration file:</source>
          <target state="translated">每个操作均作为子例程实现，并且必须存在于％actions哈希中。默认情况下，某些操作是禁用的，必须通过功能机制将其打开。例如，要启用 &lt;code&gt;blame&lt;/code&gt; 视图，请将以下内容添加到gitweb配置文件中：</target>
        </trans-unit>
        <trans-unit id="4a431caa46e2fb6d34e98615d6339148b9977f86" translate="yes" xml:space="preserve">
          <source>Each attribute can be in one of these states for a given path:</source>
          <target state="translated">对于一个给定的路径,每个属性都可以处于这些状态中的一种。</target>
        </trans-unit>
        <trans-unit id="80fa6b90c4af909cefe5f1fba5144ae109300923" translate="yes" xml:space="preserve">
          <source>Each blame entry always starts with a line of:</source>
          <target state="translated">每个责备条目总是以一行开始。</target>
        </trans-unit>
        <trans-unit id="890525cbde82d7616c57fdec079512ee27038efd" translate="yes" xml:space="preserve">
          <source>Each commit imported by &lt;code&gt;git p4&lt;/code&gt; has a line at the end of the log message indicating the p4 depot location and change number. This line is used by later &lt;code&gt;git p4 sync&lt;/code&gt; operations to know which p4 changes are new.</source>
          <target state="translated">&lt;code&gt;git p4&lt;/code&gt; 导入的每个提交在日志消息的末尾都有一行，指示p4库的位置和更改号。以后的 &lt;code&gt;git p4 sync&lt;/code&gt; 操作使用此行来知道哪些p4更改是新的。</target>
        </trans-unit>
        <trans-unit id="0d7aba1c95771e1fa299e8f177a2cb8fdb72c0d3" translate="yes" xml:space="preserve">
          <source>Each event is a JSON-object containing multiple key/value pairs written as a single line and followed by a LF.</source>
          <target state="translated">每个事件是一个JSON对象,包含多个键/值对,写成一行,后面跟着一个LF。</target>
        </trans-unit>
        <trans-unit id="93024a055d9225f66feed1627e9698b1aeced23b" translate="yes" xml:space="preserve">
          <source>Each group of changes (called a &quot;hunk&quot;) in the textual diff output is prefixed with a line of the form:</source>
          <target state="translated">文本差异输出中的每一组变化(称为 &quot;hunk&quot;)都在前面加了一行,形式为:。</target>
        </trans-unit>
        <trans-unit id="82afba91b0fbc1511d9d66475a7a1226634e3792" translate="yes" xml:space="preserve">
          <source>Each instruction has variable length. Instruction type is determined by the seventh bit of the first octet. The following diagrams follow the convention in RFC 1951 (Deflate compressed data format).</source>
          <target state="translated">每条指令的长度是可变的。指令类型由第一个八位组的第七位决定。以下图表遵循RFC 1951(Deflate压缩数据格式)中的约定。</target>
        </trans-unit>
        <trans-unit id="e70c1e613f5f534aeea8db8eaf0d4059228f6833" translate="yes" xml:space="preserve">
          <source>Each line in &lt;code&gt;gitattributes&lt;/code&gt; file is of form:</source>
          <target state="translated">&lt;code&gt;gitattributes&lt;/code&gt; 文件中的每一行都是以下形式：</target>
        </trans-unit>
        <trans-unit id="1c072d6c2cdd76489a2967b2e7ee81381c672ff3" translate="yes" xml:space="preserve">
          <source>Each line in a &lt;code&gt;gitignore&lt;/code&gt; file specifies a pattern. When deciding whether to ignore a path, Git normally checks &lt;code&gt;gitignore&lt;/code&gt; patterns from multiple sources, with the following order of precedence, from highest to lowest (within one level of precedence, the last matching pattern decides the outcome):</source>
          <target state="translated">&lt;code&gt;gitignore&lt;/code&gt; 文件中的每一行都指定一个模式。在决定是否忽略路径时，Git通常会从多个来源检查 &lt;code&gt;gitignore&lt;/code&gt; 模式，并按照从高到低的顺序（从一个优先级，最后一个匹配模式决定结果）：</target>
        </trans-unit>
        <trans-unit id="d043aa624315c625b39f19b7c5a71a08d0fbefd2" translate="yes" xml:space="preserve">
          <source>Each line of options has this format:</source>
          <target state="translated">每一行的选项都有这样的格式。</target>
        </trans-unit>
        <trans-unit id="ce263659ab1a0135f8fda2a68c8ecc96cb2e4b52" translate="yes" xml:space="preserve">
          <source>Each line of the &lt;code&gt;git ls-files --unmerged&lt;/code&gt; output begins with the blob mode bits, blob SHA-1, 'stage number', and the filename. The 'stage number' is Git&amp;rsquo;s way to say which tree it came from: stage 1 corresponds to the &lt;code&gt;$orig&lt;/code&gt; tree, stage 2 to the &lt;code&gt;HEAD&lt;/code&gt; tree, and stage 3 to the &lt;code&gt;$target&lt;/code&gt; tree.</source>
          <target state="translated">&lt;code&gt;git ls-files --unmerged&lt;/code&gt; 输出的每一行都以blob模式位，blob SHA-1，&amp;ldquo;阶段号&amp;rdquo;和文件名开头。 &amp;ldquo;阶段号&amp;rdquo;是Git表示它来自哪棵树的方式：阶段1对应于 &lt;code&gt;$orig&lt;/code&gt; 树，阶段2对应于 &lt;code&gt;HEAD&lt;/code&gt; 树，阶段3对应于 &lt;code&gt;$target&lt;/code&gt; 树。</target>
        </trans-unit>
        <trans-unit id="ac1b4287ed9a44af81d40c798f15ea7666d1fc7e" translate="yes" xml:space="preserve">
          <source>Each linked working tree has a private sub-directory in the repository&amp;rsquo;s $GIT_DIR/worktrees directory. The private sub-directory&amp;rsquo;s name is usually the base name of the linked working tree&amp;rsquo;s path, possibly appended with a number to make it unique. For example, when &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; the command &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; creates the linked working tree in &lt;code&gt;/path/other/test-next&lt;/code&gt; and also creates a &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; directory (or &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; if &lt;code&gt;test-next&lt;/code&gt; is already taken).</source>
          <target state="translated">每个链接的工作树在存储库的$ GIT_DIR / worktrees目录中都有一个私有子目录。私有子目录的名称通常是链接的工作树路径的基本名称，可能还会附加一个数字以使其唯一。例如，当 &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; 命令 &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; 创建的链接工作树 &lt;code&gt;/path/other/test-next&lt;/code&gt; ，也创建了一个 &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; 目录（如果已使用 &lt;code&gt;test-next&lt;/code&gt; ,则为 &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0e13434b85bdba9c36937ef9acd2f33c427adfe8" translate="yes" xml:space="preserve">
          <source>Each of the attribute requirements for the path takes one of these forms:</source>
          <target state="translated">路径的每个属性要求都有以下几种形式。</target>
        </trans-unit>
        <trans-unit id="58398b8104bc9622bb9865f6e7c9793546a9471d" translate="yes" xml:space="preserve">
          <source>Each of the four branches is usually a direct descendant of the one above it.</source>
          <target state="translated">四个分支中的每一个通常都是它上面那个分支的直系子孙。</target>
        </trans-unit>
        <trans-unit id="dfc2dc1cc1f2e4f6e3d7ce6e6191c01415d0880b" translate="yes" xml:space="preserve">
          <source>Each of these options must appear first on the command line.</source>
          <target state="translated">这些选项中的每一个都必须首先出现在命令行中。</target>
        </trans-unit>
        <trans-unit id="79d9036a8f3f011f6caea432d8fa6198deb15d8c" translate="yes" xml:space="preserve">
          <source>Each other line contains a single pattern.</source>
          <target state="translated">其他每一行都包含一个图案。</target>
        </trans-unit>
        <trans-unit id="36e6db0cb81d09d2c644d8a7c4b702648cc38f78" translate="yes" xml:space="preserve">
          <source>Each patch can be applied in order.</source>
          <target state="translated">每个贴片都可以按顺序应用。</target>
        </trans-unit>
        <trans-unit id="6d39c2ae5926cd9b5a6631ab32e0430d3e598f09" translate="yes" xml:space="preserve">
          <source>Each patch includes a single logical change, together with a message explaining the change.</source>
          <target state="translated">每个补丁都包括一个单一的逻辑变化,以及解释该变化的信息。</target>
        </trans-unit>
        <trans-unit id="493d693b4f2b5ea37d0460dc9ff9f76e6d401041" translate="yes" xml:space="preserve">
          <source>Each pattern pair consists of the source side (before the colon) and the destination side (after the colon). The ref to be pushed is determined by finding a match that matches the source side, and where it is pushed is determined by using the destination side.</source>
          <target state="translated">每个模式对由源侧(冒号前)和目的侧(冒号后)组成。要推送的 ref 是通过找到与源侧匹配的匹配项来确定的,而推送的位置是通过目的侧来确定的。</target>
        </trans-unit>
        <trans-unit id="b313cea753099ce8f3968fb8a5c9e65e86c611ac" translate="yes" xml:space="preserve">
          <source>Each pattern pair consists of the source side (before the colon) and the destination side (after the colon). The ref to be pushed is determined by finding a match that matches the source side, and where it is pushed is determined by using the destination side. The rules used to match a ref are the same rules used by &lt;code&gt;git rev-parse&lt;/code&gt; to resolve a symbolic ref name. See &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">每个模式对均由源侧（在冒号之前）和目标侧（在冒号之后）组成。通过查找与源端匹配的匹配项来确定要推送的ref，并通过使用目标端来确定将其推送到何处。用于匹配引用的规则与 &lt;code&gt;git rev-parse&lt;/code&gt; 用于解析符号引用名称的规则相同。参见&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2aa7f4f33bfb7b26b4af691cb7e2c6d52612b8b" translate="yes" xml:space="preserve">
          <source>Each remote helper is expected to support only a subset of commands. The operations a helper supports are declared to Git in the response to the &lt;code&gt;capabilities&lt;/code&gt; command (see COMMANDS, below).</source>
          <target state="translated">期望每个远程帮助程序仅支持命令的子集。在对 &lt;code&gt;capabilities&lt;/code&gt; 命令的响应中，将帮助程序支持的操作声明给Git （请参阅下面的COMMANDS）。</target>
        </trans-unit>
        <trans-unit id="640db855296fc622a8934e713d8f1835acdff3f5" translate="yes" xml:space="preserve">
          <source>Each time a new shared index file is created, the old shared index files are deleted if their modification time is older than what is specified by the splitIndex.sharedIndexExpire config variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">每次创建新的共享索引文件时，如果旧的共享索引文件的修改时间早于splitIndex.sharedIndexExpire配置变量（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）所指定的修改时间，则它们将被删除。</target>
        </trans-unit>
        <trans-unit id="6b67247d73793e579b74a9b09ccf935b5a398f89" translate="yes" xml:space="preserve">
          <source>Each time a superproject update moves a populated submodule (e.g. when switching between commits before and after the move) a stale submodule checkout will remain in the old location and an empty directory will appear in the new location. To populate the submodule again in the new location the user will have to run &quot;git submodule update&quot; afterwards. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. Both steps will be obsolete when recursive submodule update has been implemented.</source>
          <target state="translated">每次超级项目更新移动一个已填充的子模块时(例如在移动前后的提交之间切换时),一个陈旧的子模块签出会留在旧位置,而新位置会出现一个空目录。如果要在新位置重新填充子模块,用户必须在之后运行 &quot;git submodule update&quot;。只有在使用git文件时,删除旧目录才是安全的,否则子模块的历史也会被删除。当实现了递归子模块更新后,这两个步骤都将被淘汰。</target>
        </trans-unit>
        <trans-unit id="70398d4e57fc6de31488380bf7caac1138d58530" translate="yes" xml:space="preserve">
          <source>Each time a superproject update removes a populated submodule (e.g. when switching between commits before and after the removal) a stale submodule checkout will remain in the old location. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. This step will be obsolete when recursive submodule update has been implemented.</source>
          <target state="translated">每次超级项目更新删除一个填充的子模块时(例如在删除前后的提交之间切换时),一个陈旧的子模块签出会保留在旧的位置。只有在使用gitfile的时候,删除旧目录才是安全的,否则子模块的历史也会被删除。当实现了递归子模块更新后,这一步将被淘汰。</target>
        </trans-unit>
        <trans-unit id="49035126eea24f612f322a34d235d8eeac55e17a" translate="yes" xml:space="preserve">
          <source>Each time you resolve the conflicts in a file and update the index:</source>
          <target state="translated">每次解决文件中的冲突并更新索引。</target>
        </trans-unit>
        <trans-unit id="91df855bba63011edb2c56419d0fb8efa1e50e11" translate="yes" xml:space="preserve">
          <source>Earlier we said that trivial merges are done inside &lt;code&gt;git read-tree -m&lt;/code&gt;. For example, if the file did not change from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; or &lt;code&gt;$target&lt;/code&gt;, or if the file changed from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;$target&lt;/code&gt; the same way, obviously the final outcome is what is in &lt;code&gt;HEAD&lt;/code&gt;. What the above example shows is that file &lt;code&gt;hello.c&lt;/code&gt; was changed from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;$target&lt;/code&gt; in a different way. You could resolve this by running your favorite 3-way merge program, e.g. &lt;code&gt;diff3&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, or Git&amp;rsquo;s own merge-file, on the blob objects from these three stages yourself, like this:</source>
          <target state="translated">之前我们说过，琐碎的合并是在 &lt;code&gt;git read-tree -m&lt;/code&gt; 内部完成的。例如，如果文件没有从 &lt;code&gt;$orig&lt;/code&gt; 更改为 &lt;code&gt;HEAD&lt;/code&gt; 或 &lt;code&gt;$target&lt;/code&gt; ，或者文件从 &lt;code&gt;$orig&lt;/code&gt; 更改为 &lt;code&gt;HEAD&lt;/code&gt; ,而 &lt;code&gt;$orig&lt;/code&gt; 更改 &lt;code&gt;$target&lt;/code&gt; ，则最终结果显然是 &lt;code&gt;HEAD&lt;/code&gt; 。什么上面的例子中显示的是该文件 &lt;code&gt;hello.c&lt;/code&gt; 从改变 &lt;code&gt;$orig&lt;/code&gt; 到 &lt;code&gt;HEAD&lt;/code&gt; 和 &lt;code&gt;$orig&lt;/code&gt; 到 &lt;code&gt;$target&lt;/code&gt; 以不同的方式。您可以通过运行您喜欢的3向合并程序来解决此问题，例如 &lt;code&gt;diff3&lt;/code&gt; ， &lt;code&gt;merge&lt;/code&gt; 或Git自己的合并文件，位于您自己来自这三个阶段的blob对象上，如下所示：</target>
        </trans-unit>
        <trans-unit id="cf0ee6adeaeadff98f7e216b0d8eb81b31226098" translate="yes" xml:space="preserve">
          <source>Earlier, we saw that one file under &lt;code&gt;.git/objects/??/&lt;/code&gt; directory is stored for each Git object you create. This representation is efficient to create atomically and safely, but not so convenient to transport over the network. Since Git objects are immutable once they are created, there is a way to optimize the storage by &quot;packing them together&quot;. The command</source>
          <target state="translated">之前，我们看到为您创建的每个Git对象都在 &lt;code&gt;.git/objects/??/&lt;/code&gt; 目录下存储了一个文件。这种表示方式可以有效地原子安全地创建，但是在网络上传输却不那么方便。由于Git对象一旦创建便是不可变的，因此有一种方法可以通过&amp;ldquo;将它们打包在一起&amp;rdquo;来优化存储。命令</target>
        </trans-unit>
        <trans-unit id="b4c8a83331a00582f4030fa5296077717cda7730" translate="yes" xml:space="preserve">
          <source>Ease of use. It is often much simpler to write a binary to text transformation than it is to perform your own diff. In many cases, existing programs can be used as textconv filters (e.g., exif, odt2txt).</source>
          <target state="translated">易用性。编写一个二进制到文本的转换通常比你自己执行diff要简单得多。在许多情况下,现有的程序可以用作文本转换过滤器(例如,exif、odt2txt)。</target>
        </trans-unit>
        <trans-unit id="b4d52eb229c8c557c44ab0035085b989953060f9" translate="yes" xml:space="preserve">
          <source>Easily extendable as capabilities are moved into their own section of the protocol, no longer being hidden behind a NUL byte and limited by the size of a pkt-line</source>
          <target state="translated">当功能被移到协议的自己的部分时,易于扩展,不再被隐藏在NUL字节后面,也不再受限于pkt-line的大小。</target>
        </trans-unit>
        <trans-unit id="c0ecd6c3f25fc4cb4d76566a21fece2ca48f95ab" translate="yes" xml:space="preserve">
          <source>Easy case: The changes are literally the same.</source>
          <target state="translated">简单的案例。字面上的变化是一样的。</target>
        </trans-unit>
        <trans-unit id="d4f35a5d52e75e1ab425158dcb45339db600d3f4" translate="yes" xml:space="preserve">
          <source>Eclipse 3.0, 3.1.2 on MacOSX (see Eclipse CVS Client Notes)</source>
          <target state="translated">MacOSX上的Eclipse 3.0、3.1.2 (见Eclipse CVS客户端说明)</target>
        </trans-unit>
        <trans-unit id="f5e176bd2c2df731632b9ca0ee7983e84b3d8517" translate="yes" xml:space="preserve">
          <source>Eclipse cvs client notes</source>
          <target state="translated">Eclipse cvs 客户端注释</target>
        </trans-unit>
        <trans-unit id="ea0675157801730c96e515d20a6ad02ac765e6d4" translate="yes" xml:space="preserve">
          <source>Edit an object&amp;rsquo;s content interactively. The existing content for &amp;lt;object&amp;gt; is pretty-printed into a temporary file, an editor is launched on the file, and the result is parsed to create a new object of the same type as &amp;lt;object&amp;gt;. A replacement ref is then created to replace &amp;lt;object&amp;gt; with the newly created object. See &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; for details about how the editor will be chosen.</source>
          <target state="translated">交互式编辑对象的内容。&amp;lt;object&amp;gt;的现有内容被漂亮地打印到一个临时文件中，在该文件上启动编辑器，然后解析结果以创建与&amp;lt;object&amp;gt;相同类型的新对象。然后创建替换引用，以将&amp;lt;object&amp;gt;替换为新创建的对象。有关如何选择编辑器的详细信息，请参见&lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f76fc2a41a48ffbf729f7fe389bfe3f0b08de68" translate="yes" xml:space="preserve">
          <source>Edit the commit message before committing to SVN. This is off by default for objects that are commits, and forced on when committing tree objects.</source>
          <target state="translated">在提交到SVN之前编辑提交信息。对于提交的对象,默认情况下是关闭的,当提交树状对象时,则强制开启。</target>
        </trans-unit>
        <trans-unit id="c92b0955a7a67e8bc1f5f7afd177ec4ed55d0e4c" translate="yes" xml:space="preserve">
          <source>Edit the files in place.</source>
          <target state="translated">就地编辑文件。</target>
        </trans-unit>
        <trans-unit id="b87cea5cffa31e45fd50bcd7540894242796f029" translate="yes" xml:space="preserve">
          <source>Edit the notes for a given object (defaults to HEAD).</source>
          <target state="translated">编辑给定对象的注释(默认为HEAD)。</target>
        </trans-unit>
        <trans-unit id="81933d4e997d5f22262236af308c480381855b0f" translate="yes" xml:space="preserve">
          <source>Edit the todo list during an interactive rebase.</source>
          <target state="translated">在交互式重启期间编辑待办事项列表。</target>
        </trans-unit>
        <trans-unit id="f392476dbdf7968fc4726a7173f15cf238dddd46" translate="yes" xml:space="preserve">
          <source>Editing patches</source>
          <target state="translated">编辑补丁</target>
        </trans-unit>
        <trans-unit id="8f25a859269ca51039632dd6bba28fb061cfb8d4" translate="yes" xml:space="preserve">
          <source>Effects</source>
          <target state="translated">Effects</target>
        </trans-unit>
        <trans-unit id="7002bc1d2bcb94f212817ade973f1baffe1d4266" translate="yes" xml:space="preserve">
          <source>Either a &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;, or a &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; together with the dependent &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; and tree objects (i.e. a stored representation of a working tree).</source>
          <target state="translated">一个&lt;a href=&quot;#def_working_tree&quot;&gt;工作树&lt;/a&gt;，或一个&lt;a href=&quot;#def_tree_object&quot;&gt;树对象&lt;/a&gt;以及相关的&lt;a href=&quot;#def_blob_object&quot;&gt;Blob&lt;/a&gt;和树对象（即工作树的存储表示）。</target>
        </trans-unit>
        <trans-unit id="bc0851580574fafe647ac3b5e7bd049ba47eee8d" translate="yes" xml:space="preserve">
          <source>Either the hash or the filename under [URL]/refs/ to pull.</source>
          <target state="translated">拉取[URL]/refs/下的哈希或文件名。</target>
        </trans-unit>
        <trans-unit id="3c055884457fa0453683ceee26bbe41d08beb912" translate="yes" xml:space="preserve">
          <source>Either way, if you have a string of untestable commits, it might happen that the regression you are looking for has been introduced by one of these untestable commits. In this case it&amp;rsquo;s not possible to tell for sure which commit introduced the regression.</source>
          <target state="translated">无论哪种方式，如果您有一串不可测的提交，则可能是您正在寻找的回归是由这些不可测的提交之一引入的。在这种情况下，无法确定是哪个提交引入了回归。</target>
        </trans-unit>
        <trans-unit id="84add5b2952787581cb9a8851eef63d1ec75d22b" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="translated">Email</target>
        </trans-unit>
        <trans-unit id="727400f70d8ff4dd021cd3b46cd8407431accd18" translate="yes" xml:space="preserve">
          <source>Empty commits</source>
          <target state="translated">空的承诺</target>
        </trans-unit>
        <trans-unit id="64c856db8d7087653e88ddbd52d985c5029c26f3" translate="yes" xml:space="preserve">
          <source>Empty context lines that do not have &lt;code&gt;any&lt;/code&gt; whitespace.</source>
          <target state="translated">没有 &lt;code&gt;any&lt;/code&gt; 空格的空上下文行。</target>
        </trans-unit>
        <trans-unit id="bc35de4b332414e34ea66c4e2722d1b3c677ee26" translate="yes" xml:space="preserve">
          <source>Enable &quot;sparse checkout&quot; feature. See &lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout[1]&lt;/a&gt; for more information.</source>
          <target state="translated">启用&amp;ldquo;稀疏签出&amp;rdquo;功能。有关更多信息，请参见&lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1506b425dd0a659b4e3f7dbaad1db76c1920ca2" translate="yes" xml:space="preserve">
          <source>Enable (1) or disable (0) debug output. If enabled, SMTP commands and replies will be printed. Useful to debug TLS connection and authentication problems.</source>
          <target state="translated">启用 (1)或禁用 (0)调试输出。如果启用,将打印SMTP命令和回复。对调试TLS连接和验证问题很有用。</target>
        </trans-unit>
        <trans-unit id="5ca5f9ffb4eef636571b0732ca8e82f4b117bf57" translate="yes" xml:space="preserve">
          <source>Enable Git&amp;rsquo;s password prompt for the SSL certificate. Otherwise OpenSSL will prompt the user, possibly many times, if the certificate or private key is encrypted. Can be overridden by the &lt;code&gt;GIT_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; environment variable.</source>
          <target state="translated">为SSL证书启用Git的密码提示。否则，如果证书或私钥已加密，则OpenSSL可能会多次提示用户。可以被 &lt;code&gt;GIT_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="202cfbf6c643ccf61c3e6855fb4942a959d7c88c" translate="yes" xml:space="preserve">
          <source>Enable and configure &quot;patches&quot; view, which displays list of commits in email (plain text) output format; see also &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;. The value is the maximum number of patches in a patchset generated in &quot;patches&quot; view. Set the &lt;code&gt;default&lt;/code&gt; field to a list containing single item of or to an empty list to disable patch view, or to a list containing a single negative number to remove any limit. Default value is 16.</source>
          <target state="translated">启用并配置&amp;ldquo;补丁&amp;rdquo;视图，以电子邮件（纯文本）输出格式显示提交列表；另见&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;。该值是在&amp;ldquo;补丁&amp;rdquo;视图中生成的补丁集中最大补丁数。将 &lt;code&gt;default&lt;/code&gt; 字段设置为包含单个项目的列表，或设置为空列表以禁用补丁程序视图，或设置为包含单个负数的列表以消除任何限制。预设值为16。</target>
        </trans-unit>
        <trans-unit id="3ec940cc58a7e0a3ca8323d3832e04ecb527aead" translate="yes" xml:space="preserve">
          <source>Enable and configure the &quot;snapshot&quot; action, which allows user to download a compressed archive of any tree or commit, as produced by &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; and possibly additionally compressed. This can potentially generate high traffic if you have large project.</source>
          <target state="translated">启用并配置&amp;ldquo;快照&amp;rdquo;操作，该操作允许用户下载由&lt;a href=&quot;git-archive&quot;&gt;git-archive [1]生成&lt;/a&gt;并可能附加压缩的任何树或提交的压缩存档。如果您有大型项目，这可能会产生高流量。</target>
        </trans-unit>
        <trans-unit id="875ff7ca114490b100a4ae7597d23eb505e57466" translate="yes" xml:space="preserve">
          <source>Enable and configure the ability to change a common time zone for dates in gitweb output via JavaScript. Dates in gitweb output include authordate and committerdate in &quot;commit&quot;, &quot;commitdiff&quot; and &quot;log&quot; views, and taggerdate in &quot;tag&quot; view. Enabled by default.</source>
          <target state="translated">启用并配置通过 JavaScript 更改 gitweb 输出中的日期的通用时区的功能。gitweb输出的日期包括 &quot;commit&quot;、&quot;commitdiff &quot;和 &quot;log &quot;视图中的authordate和committerdate,以及 &quot;tag &quot;视图中的taggerdate。默认为启用。</target>
        </trans-unit>
        <trans-unit id="e1b8a656580e419265edb3d93e7fbf612f88122b" translate="yes" xml:space="preserve">
          <source>Enable config options that are new to Git, and are being considered for future defaults. Config settings included here may be added or removed with each release, including minor version updates. These settings may have unintended interactions since they are so new. Please enable this setting if you are interested in providing feedback on experimental features. The new default values are:</source>
          <target state="translated">启用 Git 的新配置选项,并考虑将其作为未来的默认值。这里的配置设置可能会在每次发布时被添加或删除,包括小版本更新。由于这些设置太新,可能会产生一些意外的互动。如果您对提供实验性功能的反馈感兴趣,请启用此设置。新的默认值是</target>
        </trans-unit>
        <trans-unit id="8740fb3b16d2502b6a07330a252227f128574417" translate="yes" xml:space="preserve">
          <source>Enable config options that optimize for repos with many files in the working directory. With many files, commands such as &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git checkout&lt;/code&gt; may be slow and these new defaults improve performance:</source>
          <target state="translated">启用可优化回购的配置选项，其中包含工作目录中的许多文件。对于许多文件，诸如 &lt;code&gt;git status&lt;/code&gt; 和 &lt;code&gt;git checkout&lt;/code&gt; 之类的命令可能会很慢，并且这些新的默认设置可提高性能：</target>
        </trans-unit>
        <trans-unit id="b62688a948f16b8896e24589781ecaee64693ffd" translate="yes" xml:space="preserve">
          <source>Enable displaying how much time and how many Git commands it took to generate and display each page in the page footer (at the bottom of page). For example the footer might contain: &quot;This page took 6.53325 seconds and 13 Git commands to generate.&quot; Disabled by default.</source>
          <target state="translated">启用在页面页脚(页面底部)显示每页生成并显示所花的时间和Git命令数量。例如页脚可能包含:&quot;本页面生成耗时6.53325秒,生成13条Git命令。&quot; 默认为禁用。</target>
        </trans-unit>
        <trans-unit id="c9bd131fb11e7d8a575c789c619c56115c835cfc" translate="yes" xml:space="preserve">
          <source>Enable displaying remote heads (remote-tracking branches) in the &quot;heads&quot; list. In most cases the list of remote-tracking branches is an unnecessary internal private detail, and this feature is therefore disabled by default. &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;, which is usually used to browse local repositories, enables and uses this feature.</source>
          <target state="translated">启用在&amp;ldquo;标题&amp;rdquo;列表中显示远程标题（远程跟踪分支）。在大多数情况下，远程跟踪分支列表是不必要的内部私有详细信息，因此默认情况下禁用此功能。&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;（通常用于浏览本地存储库）启用并使用此功能。</target>
        </trans-unit>
        <trans-unit id="39da6c4d119e094eeb647ff45a2f63bf34d04c9c" translate="yes" xml:space="preserve">
          <source>Enable grep search, which lists the files in currently selected tree (directory) containing the given string; see &lt;a href=&quot;git-grep&quot;&gt;git-grep[1]&lt;/a&gt;. This can be potentially CPU-intensive, of course. Enabled by default.</source>
          <target state="translated">启用grep搜索，该搜索将列出当前所选树（目录）中包含给定字符串的文件；参见&lt;a href=&quot;git-grep&quot;&gt;git-grep [1]&lt;/a&gt;。当然，这可能会占用大量CPU资源。默认启用。</target>
        </trans-unit>
        <trans-unit id="393e4a210cdfd96d50c3abf9958899d9c77b22c9" translate="yes" xml:space="preserve">
          <source>Enable more strict checking, namely to catch a file mode recorded with g+w bit set, which was created by older versions of Git. Existing repositories, including the Linux kernel, Git itself, and sparse repository have old objects that triggers this check, but it is recommended to check new projects with this flag.</source>
          <target state="translated">启用更严格的检查,即抓取g+w位设置记录的文件模式,这是由旧版本的Git创建的。现有的仓库,包括 Linux 内核、Git 本身和稀疏仓库都有旧的对象会触发这个检查,但建议用这个标志检查新项目。</target>
        </trans-unit>
        <trans-unit id="8081f1426d8047f2f5c9039fb2b3187c4aed51ad" translate="yes" xml:space="preserve">
          <source>Enable multipart/mixed attachments as the default for &lt;code&gt;format-patch&lt;/code&gt;. The value can also be a double quoted string which will enable attachments as the default and set the value as the boundary. See the --attach option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">启用多部分/混合附件作为 &lt;code&gt;format-patch&lt;/code&gt; 的默认值。该值也可以是双引号字符串，该字符串将使附件成为默认值，并将该值设置为边界。参见&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]中&lt;/a&gt;的--attach选项。</target>
        </trans-unit>
        <trans-unit id="d973b021f64131371542864785f310ed020b9e66" translate="yes" xml:space="preserve">
          <source>Enable or disable files system monitor feature. These options take effect whatever the value of the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">启用或禁用文件系统监视器功能。无论 &lt;code&gt;core.fsmonitor&lt;/code&gt; 配置变量的值如何，这些选项都会生效（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。但是，当更改与配置值不符时，会发出警告，因为配置值将在下次读取索引时生效，这将删除该选项的预期效果。</target>
        </trans-unit>
        <trans-unit id="d83423bb73684fa975c3f77aeba009920792cf88" translate="yes" xml:space="preserve">
          <source>Enable or disable split index mode. If split-index mode is already enabled and &lt;code&gt;--split-index&lt;/code&gt; is given again, all changes in $GIT_DIR/index are pushed back to the shared index file.</source>
          <target state="translated">启用或禁用拆分索引模式。如果已经启用了分割索引模式​​，并且再次给出了 &lt;code&gt;--split-index&lt;/code&gt; ,则$ GIT_DIR / index中的所有更改都将推回到共享索引文件中。</target>
        </trans-unit>
        <trans-unit id="f8b0173e3fdc03c4e03595346f1584e741b798c1" translate="yes" xml:space="preserve">
          <source>Enable or disable untracked cache feature. Please use &lt;code&gt;--test-untracked-cache&lt;/code&gt; before enabling it.</source>
          <target state="translated">启用或禁用未跟踪的缓存功能。启用前请使用 &lt;code&gt;--test-untracked-cache&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d058dbf876c4efd16b9ed5eae486a10be79bb86" translate="yes" xml:space="preserve">
          <source>Enable parallel index preload for operations like &lt;code&gt;git diff&lt;/code&gt;</source>
          <target state="translated">为 &lt;code&gt;git diff&lt;/code&gt; 之类的操作启用并行索引预加载</target>
        </trans-unit>
        <trans-unit id="1aa8a755e195170094ad7c0108b7874b637b96b6" translate="yes" xml:space="preserve">
          <source>Enable showing size of blobs (ordinary files) in a &quot;tree&quot; view, in a separate column, similar to what &lt;code&gt;ls -l&lt;/code&gt; does; see description of &lt;code&gt;-l&lt;/code&gt; option in &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt; manpage. This costs a bit of I/O. Enabled by default.</source>
          <target state="translated">启用在&amp;ldquo;树&amp;rdquo;视图的单独列中显示blob（普通文件）大小的功能，类似于 &lt;code&gt;ls -l&lt;/code&gt; 所做的；请参见&lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt;联机帮助页中的 &lt;code&gt;-l&lt;/code&gt; 选项的说明。这会花费一些I / O。默认启用。</target>
        </trans-unit>
        <trans-unit id="72fa50bb7bb0362a9a5efa2aa6f34941c4906089" translate="yes" xml:space="preserve">
          <source>Enable stricter reference checking by requiring an exact ref path. Aside from returning an error code of 1, it will also print an error message if &lt;code&gt;--quiet&lt;/code&gt; was not specified.</source>
          <target state="translated">通过要求精确的引用路径来启用更严格的引用检查。如果未指定 &lt;code&gt;--quiet&lt;/code&gt; ，则除了返回错误代码1之外，它还会打印一条错误消息。</target>
        </trans-unit>
        <trans-unit id="48730f76cba5f67862630837d3f93d8ce9288066" translate="yes" xml:space="preserve">
          <source>Enable text search, which will list the commits which match author, committer or commit text to a given string; see the description of &lt;code&gt;--author&lt;/code&gt;, &lt;code&gt;--committer&lt;/code&gt; and &lt;code&gt;--grep&lt;/code&gt; options in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; manpage. Enabled by default.</source>
          <target state="translated">启用文本搜索，它将列出与作者，提交者或将文本匹配到给定字符串的提交；看到的描述 &lt;code&gt;--author&lt;/code&gt; ， &lt;code&gt;--committer&lt;/code&gt; 和 &lt;code&gt;--grep&lt;/code&gt; 在选项&lt;a href=&quot;git-log&quot;&gt;GIT-日志[1]&lt;/a&gt;手册页。默认启用。</target>
        </trans-unit>
        <trans-unit id="5bf942f17a0adbd66d5dff03794ede7ed6ce3a03" translate="yes" xml:space="preserve">
          <source>Enable the &quot;blame&quot; and &quot;blame_incremental&quot; blob views, showing for each line the last commit that modified it; see &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. This can be very CPU-intensive and is therefore disabled by default.</source>
          <target state="translated">启用&amp;ldquo; blame&amp;rdquo;和&amp;ldquo; blame_incremental&amp;rdquo; blob视图，为每行显示最后修改它的提交；参见&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;。这可能会占用大量CPU，因此默认情况下处于禁用状态。</target>
        </trans-unit>
        <trans-unit id="d7fc03efc211d064bf3be01f125339a0be59fcba" translate="yes" xml:space="preserve">
          <source>Enable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; setting. If the sparse-checkout file does not exist, then populate it with patterns that match every file in the root directory and no other directories, then will remove all directories tracked by Git. Add patterns to the sparse-checkout file to repopulate the working directory.</source>
          <target state="translated">启用 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 设置。如果稀疏检出文件不存在，则使用与根目录中的每个文件匹配且与其他目录不匹配的模式填充该文件，然后将删除Git跟踪的所有目录。将模式添加到稀疏检出文件以重新填充工作目录。</target>
        </trans-unit>
        <trans-unit id="388296e4f7d314018094f8c18fc5c6de39a494b4" translate="yes" xml:space="preserve">
          <source>Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.</source>
          <target state="translated">启用启发式,移动 diff hunk 的边界,使补丁更容易阅读。这是默认的。</target>
        </trans-unit>
        <trans-unit id="01f1f887420f77509dbb30a6ca88007ca92eded6" translate="yes" xml:space="preserve">
          <source>Enable the reflog. Updates to a ref &amp;lt;ref&amp;gt; is logged to the file &quot;&lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt;&quot;, by appending the new and old SHA-1, the date/time and the reason of the update, but only when the file exists. If this configuration variable is set to &lt;code&gt;true&lt;/code&gt;, missing &quot;&lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt;&quot; file is automatically created for branch heads (i.e. under &lt;code&gt;refs/heads/&lt;/code&gt;), remote refs (i.e. under &lt;code&gt;refs/remotes/&lt;/code&gt;), note refs (i.e. under &lt;code&gt;refs/notes/&lt;/code&gt;), and the symbolic ref &lt;code&gt;HEAD&lt;/code&gt;. If it is set to &lt;code&gt;always&lt;/code&gt;, then a missing reflog is automatically created for any ref under &lt;code&gt;refs/&lt;/code&gt;.</source>
          <target state="translated">启用引用日志。通过附加新旧SHA-1，更新的日期/时间和原因（仅当文件存在时），将对ref &amp;lt;ref&amp;gt;的更新记录到文件&amp;ldquo; &lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt; &amp;rdquo;中。如果此配置变量设置为 &lt;code&gt;true&lt;/code&gt; ，缺失&amp;ldquo; &lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt; &amp;rdquo;文件是为分支头自动创建（即下 &lt;code&gt;refs/heads/&lt;/code&gt; ），远程参考文献（即下 &lt;code&gt;refs/remotes/&lt;/code&gt; ），音符参（即在 &lt;code&gt;refs/notes/&lt;/code&gt; ）和符号ref &lt;code&gt;HEAD&lt;/code&gt; 。如果它被设置为 &lt;code&gt;always&lt;/code&gt; ，那么缺少引用日志自动为下任裁判创建 &lt;code&gt;refs/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b50a25e099857665aa0b9ce95777350330756bcc" translate="yes" xml:space="preserve">
          <source>Enable the so called pickaxe search, which will list the commits that introduced or removed a given string in a file. This can be practical and quite faster alternative to &quot;blame&quot; action, but it is still potentially CPU-intensive. Enabled by default.</source>
          <target state="translated">启用所谓的 &quot;皮卡索搜索&quot;,它将列出在文件中引入或删除某个字符串的提交。这比起 &quot;责备 &quot;操作更实用、更快速,但仍有可能耗费CPU。默认情况下是启用的。</target>
        </trans-unit>
        <trans-unit id="e8928096a1d83fe75290fee4b17a3faa5d2c2864" translate="yes" xml:space="preserve">
          <source>Enable the specified feature. This requires that fast-import supports the specified feature, and aborts if it does not.</source>
          <target state="translated">启用指定的功能。这要求fast-import支持指定的功能,如果不支持,则中止。</target>
        </trans-unit>
        <trans-unit id="cb33ed4fbb60981dda9e34bad99e8fe5205271b1" translate="yes" xml:space="preserve">
          <source>Enable/disable the service site-wide per default. Note that a service disabled site-wide can still be enabled per repository if it is marked overridable and the repository enables the service with a configuration item.</source>
          <target state="translated">根据默认情况在整个站点启用/禁用服务。请注意,如果服务被标记为可覆盖,并且版本库通过配置项启用了服务,那么仍然可以在每个版本库中启用全站点禁用的服务。</target>
        </trans-unit>
        <trans-unit id="35a563959614f6c71c72cc0395ec6a9ebde3235d" translate="yes" xml:space="preserve">
          <source>Enables (or disables) progress messages displayed by the transport helper during a command.</source>
          <target state="translated">启用(或禁用)传输辅助程序在命令期间显示的进度信息。</target>
        </trans-unit>
        <trans-unit id="55ef71c7bfb2fa4d7687d0c6a055c6d9acec70dd" translate="yes" xml:space="preserve">
          <source>Enables a curl full trace dump of all incoming and outgoing data, including descriptive information, of the git transport protocol. This is similar to doing curl &lt;code&gt;--trace-ascii&lt;/code&gt; on the command line. This option overrides setting the &lt;code&gt;GIT_CURL_VERBOSE&lt;/code&gt; environment variable. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">对git传输协议的所有传入和传出数据（包括描述性信息）启用curl完整跟踪转储。这类似于在命令行上执行curl &lt;code&gt;--trace-ascii&lt;/code&gt; 。此选项将覆盖设置 &lt;code&gt;GIT_CURL_VERBOSE&lt;/code&gt; 环境变量。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6691f775d187ea6f64d054b6823e9e86f9c085bf" translate="yes" xml:space="preserve">
          <source>Enables general trace messages, e.g. alias expansion, built-in command execution and external command execution.</source>
          <target state="translated">启用一般的跟踪信息,如别名扩展、内置命令执行和外部命令执行。</target>
        </trans-unit>
        <trans-unit id="e48905b14288617c8ceaa87834665d923c04c051" translate="yes" xml:space="preserve">
          <source>Enables more detailed trace messages from the &quot;trace2&quot; library. Output from &lt;code&gt;GIT_TRACE2&lt;/code&gt; is a simple text-based format for human readability.</source>
          <target state="translated">启用来自&amp;ldquo; trace2&amp;rdquo;库的更详细的跟踪消息。 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 的输出是一种简单的基于文本的格式，易于阅读。</target>
        </trans-unit>
        <trans-unit id="660988c86be3da054f2d2df3321eefbdd55b0999" translate="yes" xml:space="preserve">
          <source>Enables performance related trace messages, e.g. total execution time of each Git command. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">启用与性能相关的跟踪消息，例如，每个Git命令的总执行时间。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc7b8ed816ac9633bd1375cea1e49bf11b8f4cfe" translate="yes" xml:space="preserve">
          <source>Enables the &quot;cone mode&quot; of the sparse checkout feature. When the sparse-checkout file contains a limited set of patterns, then this mode provides significant performance advantages. See &lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout[1]&lt;/a&gt; for more information.</source>
          <target state="translated">启用稀疏签出功能的&amp;ldquo;圆锥模式&amp;rdquo;。当稀疏签出文件包含一组有限的模式时，此模式将提供明显的性能优势。有关更多信息，请参见&lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69a28feccce4c72bcadfb900d39f7f184847d39a" translate="yes" xml:space="preserve">
          <source>Enables trace messages for all accesses to any packs. For each access, the pack file name and an offset in the pack is recorded. This may be helpful for troubleshooting some pack-related performance problems. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">启用对任何包的所有访问的跟踪消息。对于每次访问，都会记录包文件名和包中的偏移量。这可能有助于解决某些与包装有关的性能问题。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="facc11ad57d6672e51f919b154eb028564e3944e" translate="yes" xml:space="preserve">
          <source>Enables trace messages for all packets coming in or out of a given program. This can help with debugging object negotiation or other protocol issues. Tracing is turned off at a packet starting with &quot;PACK&quot; (but see &lt;code&gt;GIT_TRACE_PACKFILE&lt;/code&gt; below). See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">为进出给定程序的所有数据包启用跟踪消息。这可以帮助调试对象协商或其他协议问题。对于以&amp;ldquo; PACK&amp;rdquo;开头的数据包，将关闭跟踪（但请参见下面的 &lt;code&gt;GIT_TRACE_PACKFILE&lt;/code&gt; ）。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a96e0b90f936140e14c4f59157281584502b280" translate="yes" xml:space="preserve">
          <source>Enables trace messages for the filesystem monitor extension. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">为文件系统监视器扩展启用跟踪消息。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="226b098ac2b03df2efedb4d6f3177d8a53d1323d" translate="yes" xml:space="preserve">
          <source>Enables trace messages printing the .git, working tree and current working directory after Git has completed its setup phase. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">在Git完成设置阶段后，启用跟踪消息，以打印.git，工作树和当前工作目录。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0876ec8b14060e46110f6e776b65e26631e1613f" translate="yes" xml:space="preserve">
          <source>Enables trace messages that can help debugging fetching / cloning of shallow repositories. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">启用跟踪消息，可以帮助调试浅存储库的获取/克隆。有关可用的跟踪输出选项，请参见 &lt;code&gt;GIT_TRACE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9d84b12f1c34508f5365e4fa51faae6983f4d76" translate="yes" xml:space="preserve">
          <source>Enables tracing of packfiles sent or received by a given program. Unlike other trace output, this trace is verbatim: no headers, and no quoting of binary data. You almost certainly want to direct into a file (e.g., &lt;code&gt;GIT_TRACE_PACKFILE=/tmp/my.pack&lt;/code&gt;) rather than displaying it on the terminal or mixing it with other trace output.</source>
          <target state="translated">启用对给定程序发送或接收的packfile的跟踪。与其他跟踪输出不同，此跟踪是逐字记录的：没有标题，也没有引用二进制数据。几乎可以肯定，您希望直接导入文件（例如， &lt;code&gt;GIT_TRACE_PACKFILE=/tmp/my.pack&lt;/code&gt; ），而不是在终端上显示该文件或将其与其他跟踪输出混合。</target>
        </trans-unit>
        <trans-unit id="e7a1430764d62a995667824305a6bb53b99cb2fa" translate="yes" xml:space="preserve">
          <source>Enabling a Target</source>
          <target state="translated">启用目标</target>
        </trans-unit>
        <trans-unit id="3ff218bfdfe647deb6f8afd9e1fb8602500fad3a" translate="yes" xml:space="preserve">
          <source>Encoding to use when displaying logs. (See &lt;code&gt;Discussion&lt;/code&gt; above.) Defaults to the value of &lt;code&gt;i18n.commitEncoding&lt;/code&gt; if set, and UTF-8 otherwise.</source>
          <target state="translated">显示日志时使用的编码。（请参阅上面的 &lt;code&gt;Discussion&lt;/code&gt; 。）如果设置，则默认为 &lt;code&gt;i18n.commitEncoding&lt;/code&gt; 的值，否则为UTF-8。</target>
        </trans-unit>
        <trans-unit id="89269a8275f94980b4ffe877e221e0d466987782" translate="yes" xml:space="preserve">
          <source>End-of-line conversion</source>
          <target state="translated">线端转换</target>
        </trans-unit>
        <trans-unit id="ab7c0d7ed2b514b7971808ab6a9cdbd8fa7e7be5" translate="yes" xml:space="preserve">
          <source>Enhanced option parser</source>
          <target state="translated">增强的选项解析器</target>
        </trans-unit>
        <trans-unit id="d48b2fd91c06d512d371b7025cd11deeb23b34ad" translate="yes" xml:space="preserve">
          <source>Ensure at least &amp;lt;n&amp;gt; lines of surrounding context match before and after each change. When fewer lines of surrounding context exist they all must match. By default no context is ever ignored.</source>
          <target state="translated">在每次更改之前和之后，请确保至少有&amp;lt;n&amp;gt;行周围上下文匹配。当周围环境的行数减少时，它们都必须匹配。默认情况下，不会忽略任何上下文。</target>
        </trans-unit>
        <trans-unit id="6825ec27b2b654ed999d31628f8e31396467a23b" translate="yes" xml:space="preserve">
          <source>Ensure mod_cgi, mod_alias, and mod_env are enabled, set GIT_PROJECT_ROOT (or DocumentRoot) appropriately, and create a ScriptAlias to the CGI:</source>
          <target state="translated">确保mod_cgi、mod_alias和mod_env被启用,适当地设置GIT_PROJECT_ROOT(或DocumentRoot),并为CGI创建一个ScriptAlias。</target>
        </trans-unit>
        <trans-unit id="136727d71b4774df6f61241cd1f96329e996c416" translate="yes" xml:space="preserve">
          <source>Ensure that &lt;code&gt;mod_cgi&lt;/code&gt;, &lt;code&gt;mod_alias&lt;/code&gt;, &lt;code&gt;mod_auth&lt;/code&gt;, &lt;code&gt;mod_setenv&lt;/code&gt; are loaded, then set &lt;code&gt;GIT_PROJECT_ROOT&lt;/code&gt; appropriately and redirect all requests to the CGI:</source>
          <target state="translated">确保已加载 &lt;code&gt;mod_cgi&lt;/code&gt; ， &lt;code&gt;mod_alias&lt;/code&gt; ， &lt;code&gt;mod_auth&lt;/code&gt; ， &lt;code&gt;mod_setenv&lt;/code&gt; ，然后适当设置 &lt;code&gt;GIT_PROJECT_ROOT&lt;/code&gt; 并将所有请求重定向到CGI：</target>
        </trans-unit>
        <trans-unit id="05b99bf62f144f697a8ee2786cac4dbb9ea1f0fb" translate="yes" xml:space="preserve">
          <source>Ensures that a reference name is well formed</source>
          <target state="translated">确保参考名称的形成良好。</target>
        </trans-unit>
        <trans-unit id="ced8b1d7750a47c0481b135a1b95578c79b545a4" translate="yes" xml:space="preserve">
          <source>Ensuring good performance</source>
          <target state="translated">确保良好的业绩</target>
        </trans-unit>
        <trans-unit id="bbdd824923a22a7ee366da56344be9b791387ca5" translate="yes" xml:space="preserve">
          <source>Ensuring reliability</source>
          <target state="translated">确保可靠性</target>
        </trans-unit>
        <trans-unit id="35254b488f033ee2fce6cea7c360bd0f51157448" translate="yes" xml:space="preserve">
          <source>Enter &lt;code&gt;git name-rev&lt;/code&gt;:</source>
          <target state="translated">输入 &lt;code&gt;git name-rev&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="35cd2b0a8df7f89252ec5f994efe80c34ae3bb81" translate="yes" xml:space="preserve">
          <source>Entries that begin with &lt;code&gt;&quot;&lt;/code&gt; (double-quote) will be interpreted as C-style quoted paths, removing leading and trailing double-quotes and respecting backslash escapes. E.g., the value &lt;code&gt;&quot;path-with-\&quot;-and-:-in-it&quot;:vanilla-path&lt;/code&gt; has two paths: &lt;code&gt;path-with-&quot;-and-:-in-it&lt;/code&gt; and &lt;code&gt;vanilla-path&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;&quot;&lt;/code&gt; （双引号）开头的条目将被解释为C样式的带引号的路径，删除前导和尾随的双引号并遵守反斜杠转义符。例如，值 &lt;code&gt;&quot;path-with-\&quot;-and-:-in-it&quot;:vanilla-path&lt;/code&gt; 有两条路径： &lt;code&gt;path-with-&quot;-and-:-in-it&lt;/code&gt; 和 &lt;code&gt;vanilla-path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="8403ba2a4a5aa9baffc30d3d46a39f555141e42f" translate="yes" xml:space="preserve">
          <source>Environment and configuration variables</source>
          <target state="translated">环境和配置变量</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="translated">环境变量</target>
        </trans-unit>
        <trans-unit id="2e9c1d645028b692809462da156b1ceab497759c" translate="yes" xml:space="preserve">
          <source>Environment variables passed to command</source>
          <target state="translated">传递给命令的环境变量</target>
        </trans-unit>
        <trans-unit id="0939f663868ba2e69e812a3d630f787f9c5cfc8e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt;, with &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1 if not given.</source>
          <target state="translated">等效于 &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt; ，如果未给出 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1。</target>
        </trans-unit>
        <trans-unit id="0c3185db11169cc7a29ed7dd80f79aa18ce0f759" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;--word-diff=color&lt;/code&gt; plus (if a regex was specified) &lt;code&gt;--word-diff-regex=&amp;lt;regex&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;--word-diff=color&lt;/code&gt; plus（如果指定了正则表达式）-- &lt;code&gt;--word-diff-regex=&amp;lt;regex&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fce804cbafec5e50fdfe3953fee8d48f776185de" translate="yes" xml:space="preserve">
          <source>Equivalent to passing &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt;. Note that &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; does not need to be the exact branch point of the branches. Example: after rebasing a branch &lt;code&gt;my-topic&lt;/code&gt;, &lt;code&gt;git range-diff my-topic@{u} my-topic@{1} my-topic&lt;/code&gt; would show the differences introduced by the rebase.</source>
          <target state="translated">等效于传递 &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt; 。请注意， &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; 不必是分支的确切分支点。示例：在对分支 &lt;code&gt;my-topic&lt;/code&gt; 重新设置基础之后， &lt;code&gt;git range-diff my-topic@{u} my-topic@{1} my-topic&lt;/code&gt; 将显示重新引入的差异。</target>
        </trans-unit>
        <trans-unit id="fee223c131ae45dd7f0054cc61edf8587521b104" translate="yes" xml:space="preserve">
          <source>Equivalent to passing &lt;code&gt;&amp;lt;rev2&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;rev1&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">等效于传递 &lt;code&gt;&amp;lt;rev2&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;rev1&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9b3a0b879a412ed7b377d180ca1727a3b8f2d6d" translate="yes" xml:space="preserve">
          <source>Error out if the stream ends without a &lt;code&gt;done&lt;/code&gt; command. Without this feature, errors causing the frontend to end abruptly at a convenient point in the stream can go undetected. This may occur, for example, if an import front end dies in mid-operation without emitting SIGTERM or SIGKILL at its subordinate git fast-import instance.</source>
          <target state="translated">如果流在没有 &lt;code&gt;done&lt;/code&gt; 命令的情况下结束，则会出错。如果没有此功能，则导致前端在流中的方便点突然终止的错误可能无法检测到。例如，如果导入前端在操作中死亡而在其下属git fast-import实例中未发出SIGTERM或SIGKILL，则可能发生这种情况。</target>
        </trans-unit>
        <trans-unit id="137e434092ea32c83e7a34f0c9bc0aa62d172e84" translate="yes" xml:space="preserve">
          <source>Especially useful for interoperability with a foreign versioning system.</source>
          <target state="translated">对于与国外版本系统的互操作性特别有用。</target>
        </trans-unit>
        <trans-unit id="058d99599bd9d3348c2826266e98651571ad20e7" translate="yes" xml:space="preserve">
          <source>Evaluates an arbitrary shell command in each checked out submodule. The command has access to the variables $name, $sm_path, $displaypath, $sha1 and $toplevel: $name is the name of the relevant submodule section in &lt;code&gt;.gitmodules&lt;/code&gt;, $sm_path is the path of the submodule as recorded in the immediate superproject, $displaypath contains the relative path from the current working directory to the submodules root directory, $sha1 is the commit as recorded in the immediate superproject, and $toplevel is the absolute path to the top-level of the immediate superproject. Note that to avoid conflicts with &lt;code&gt;$PATH&lt;/code&gt; on Windows, the &lt;code&gt;$path&lt;/code&gt; variable is now a deprecated synonym of &lt;code&gt;$sm_path&lt;/code&gt; variable. Any submodules defined in the superproject but not checked out are ignored by this command. Unless given &lt;code&gt;--quiet&lt;/code&gt;, foreach prints the name of each submodule before evaluating the command. If &lt;code&gt;--recursive&lt;/code&gt; is given, submodules are traversed recursively (i.e. the given shell command is evaluated in nested submodules as well). A non-zero return from the command in any submodule causes the processing to terminate. This can be overridden by adding &lt;code&gt;|| :&lt;/code&gt; to the end of the command.</source>
          <target state="translated">在每个检出的子模块中评估一个任意的shell命令。该命令可以访问变量$ name，$ sm_path，$ displaypath，$ sha1和$ toplevel：$ name是 &lt;code&gt;.gitmodules&lt;/code&gt; 中相关子模块部分的名称，$ sm_path是直接超级项目中记录的子模块的路径，$ displaypath包含从当前工作目录到子模块根目录的相对路径，$ sha1是即时超级项目中记录的提交，而$ toplevel是即时超级项目顶层的绝对路径。请注意，为避免与Windows 上的 &lt;code&gt;$PATH&lt;/code&gt; 冲突，现在 &lt;code&gt;$path&lt;/code&gt; 变量已弃用 &lt;code&gt;$sm_path&lt;/code&gt; 同义词变量。该命令将忽略在超级项目中定义但未检出的所有子模块。除非给出 &lt;code&gt;--quiet&lt;/code&gt; ，否则foreach在评估命令之前会打印每个子模块的名称。如果给出了 &lt;code&gt;--recursive&lt;/code&gt; ，则递归遍历子模块（即，给定的shell命令也在嵌套子模块中求值）。任何子模块中命令的非零返回都会导致处理终止。可以通过添加 &lt;code&gt;|| :&lt;/code&gt; 来覆盖：到命令末尾。</target>
        </trans-unit>
        <trans-unit id="3346640c72369c22dbe8ece1ce186df75f62b7da" translate="yes" xml:space="preserve">
          <source>Even if you don&amp;rsquo;t need to edit files but only want to e.g. rename or remove some and thus can avoid checking out each file (i.e. you can use --index-filter), you still are passing shell snippets for your filters. This means that for every commit, you have to have a prepared git repo where those filters can be run. That&amp;rsquo;s a significant setup.</source>
          <target state="translated">即使您不需要编辑文件，而只想重命名或删除某些文件，从而避免检出每个文件（例如，可以使用--index-filter），您仍将传递shell片段作为过滤器。这意味着对于每次提交，您都必须有一个准备好的git repo，可以在其中运行那些过滤器。这是一个重要的设置。</target>
        </trans-unit>
        <trans-unit id="5eb6ad0af0ebc64a82d836be8d647670a50936f8" translate="yes" xml:space="preserve">
          <source>Even if you hide refs, a client may still be able to steal the target objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">即使您隐藏了引用，客户端也仍然可以通过&lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt;手册页的&amp;ldquo;安全&amp;rdquo;部分中介绍的技术来窃取目标对象。最好将私有数据保存在单独的存储库中。</target>
        </trans-unit>
        <trans-unit id="631b3a432b8ec594fabc393b96af10483ed3b9bf" translate="yes" xml:space="preserve">
          <source>Even if you may have local modifications in your working tree, you can safely say &lt;code&gt;git pull&lt;/code&gt; when you know that the change in the other branch does not overlap with them.</source>
          <target state="translated">即使您在工作树中进行了局部修改，当您知道另一个分支中的更改与它们没有重叠时，也可以放心地说 &lt;code&gt;git pull&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9dc426299074d12c83589e674bb08692f265116" translate="yes" xml:space="preserve">
          <source>Even when version sort is used in &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;, tagnames with the same base version but different suffixes are still sorted lexicographically, resulting e.g. in prerelease tags appearing after the main release (e.g. &quot;1.0-rc1&quot; after &quot;1.0&quot;). This variable can be specified to determine the sorting order of tags with different suffixes.</source>
          <target state="translated">即使在&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]中&lt;/a&gt;使用了版本排序，具有相同基本版本但后缀不同的标记名仍按字典顺序进行排序，从而导致例如在主发行版之后出现预发行版标记（例如，&amp;ldquo; 1.0&amp;rdquo;之后的&amp;ldquo; 1.0-rc1&amp;rdquo;） 。可以指定此变量来确定具有不同后缀的标签的排序顺序。</target>
        </trans-unit>
        <trans-unit id="9e079d1f744d65307fba536fb55c673ed5690ed3" translate="yes" xml:space="preserve">
          <source>Event-Specific Key/Value Pairs</source>
          <target state="translated">事件特定的键/值对</target>
        </trans-unit>
        <trans-unit id="574b5ade849d92dcfbdbf5ca26c3f1b37761f49f" translate="yes" xml:space="preserve">
          <source>Events are written as lines of the form:</source>
          <target state="translated">事件写成行的形式。</target>
        </trans-unit>
        <trans-unit id="af0aec79a3d13a4c4b91dbf7a8bc02d48eb692d6" translate="yes" xml:space="preserve">
          <source>Eventually the conclusion started with:</source>
          <target state="translated">最终结论是:</target>
        </trans-unit>
        <trans-unit id="e1529d50cc2b2be76fa87bc3d3169dd428571183" translate="yes" xml:space="preserve">
          <source>Eventually there will be no more revisions left to inspect, and the command will print out a description of the first bad commit. The reference &lt;code&gt;refs/bisect/bad&lt;/code&gt; will be left pointing at that commit.</source>
          <target state="translated">最终将没有更多的修订需要检查，该命令将打印出第一个错误提交的描述。参考 &lt;code&gt;refs/bisect/bad&lt;/code&gt; 将指向该提交。</target>
        </trans-unit>
        <trans-unit id="33494a61e10c94c6a655dac5cf7ce556eb778f1d" translate="yes" xml:space="preserve">
          <source>Every change in the history of a project is represented by a commit. The &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; command shows the most recent commit on the current branch:</source>
          <target state="translated">项目历史中的每个更改都由提交表示。在&lt;a href=&quot;git-show&quot;&gt;GIT中出现[1]&lt;/a&gt;命令显示最近提交的当前分支：</target>
        </trans-unit>
        <trans-unit id="c0294fb403c28f35bf86f99624f936e70c163f9d" translate="yes" xml:space="preserve">
          <source>Every commit (except the very first commit in a project) also has a parent commit which shows what happened before this commit. Following the chain of parents will eventually take you back to the beginning of the project.</source>
          <target state="translated">每一个提交(除了项目中的第一个提交)都有一个父提交,它显示了这个提交之前发生的事情。沿着父提交的链条,你最终会回到项目的开始。</target>
        </trans-unit>
        <trans-unit id="2fd9540af511da41e4e859d7e772df1cd2e0716c" translate="yes" xml:space="preserve">
          <source>Every commit has a 40-hexdigit id, sometimes called the &quot;object name&quot; or the &quot;SHA-1 id&quot;, shown on the first line of the &lt;code&gt;git show&lt;/code&gt; output. You can usually refer to a commit by a shorter name, such as a tag or a branch name, but this longer name can also be useful. Most importantly, it is a globally unique name for this commit: so if you tell somebody else the object name (for example in email), then you are guaranteed that name will refer to the same commit in their repository that it does in yours (assuming their repository has that commit at all). Since the object name is computed as a hash over the contents of the commit, you are guaranteed that the commit can never change without its name also changing.</source>
          <target state="translated">每个提交都有一个40进制的ID，有时也称为&amp;ldquo;对象名称&amp;rdquo;或&amp;ldquo; SHA-1 ID&amp;rdquo;，显示在 &lt;code&gt;git show&lt;/code&gt; 输出的第一行。通常，您可以使用较短的名称（例如标记或分支名称）来引用提交，但是该较长的名称也很有用。最重要的是，它是此提交的全局唯一名称：因此，如果您告诉其他人对象名称（例如在电子邮件中），则可以确保该名称将引用其存储库中与您自己的存储库相同的提交（假设他们的存储库完全具有该提交）。由于对象名称是作为提交内容上的哈希值计算的，因此可以保证，在提交名称也未更改的情况下，提交将永远不会更改。</target>
        </trans-unit>
        <trans-unit id="2c58cc3c4a4eeeefba12cfd52db7d6b22833ae51" translate="yes" xml:space="preserve">
          <source>Every commit usually has one &quot;parent&quot; commit which points to the previous state of the project:</source>
          <target state="translated">每个提交通常都有一个 &quot;父 &quot;提交,它指向项目的前一个状态。</target>
        </trans-unit>
        <trans-unit id="1a873d3296fdc5740fd2d57065300557ff50e9de" translate="yes" xml:space="preserve">
          <source>Every git repository is marked with a numeric version in the &lt;code&gt;core.repositoryformatversion&lt;/code&gt; key of its &lt;code&gt;config&lt;/code&gt; file. This version specifies the rules for operating on the on-disk repository data. An implementation of git which does not understand a particular version advertised by an on-disk repository MUST NOT operate on that repository; doing so risks not only producing wrong results, but actually losing data.</source>
          <target state="translated">每个git存储库在其 &lt;code&gt;config&lt;/code&gt; 文件的 &lt;code&gt;core.repositoryformatversion&lt;/code&gt; 键中均标记有数字版本。此版本指定了对磁盘存储库数据进行操作的规则。 git的实现不能理解磁盘存储库发布的特定版本，因此不得在该存储库上运行；这样做不仅有可能产生错误的结果，而且还会丢失数据。</target>
        </trans-unit>
        <trans-unit id="62d7b4b8755b9c58dc64c45f9e43e9a1848ebae6" translate="yes" xml:space="preserve">
          <source>Every helper must support the &quot;capabilities&quot; command, which Git uses to determine what other commands the helper will accept. Those other commands can be used to discover and update remote refs, transport objects between the object database and the remote repository, and update the local object store.</source>
          <target state="translated">每个辅助程序都必须支持 &quot;capabilities &quot;命令,Git用它来决定该辅助程序会接受哪些其他命令。这些命令可以用来发现和更新远程 refs,在对象数据库和远程仓库之间传输对象,以及更新本地对象存储。</target>
        </trans-unit>
        <trans-unit id="a5adcecab706a9dd84c1d3eebe8cd1a4069a04b5" translate="yes" xml:space="preserve">
          <source>Every non-overlapping match of the &amp;lt;regex&amp;gt; is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append &lt;code&gt;|[^[:space:]]&lt;/code&gt; to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline.</source>
          <target state="translated">&amp;lt;regex&amp;gt;的每个非重叠匹配都被视为一个单词。这些匹配之间的任何内容都被视为空格，并且为了发现差异而忽略（！）。您可能要在正则表达式后附加 &lt;code&gt;|[^[:space:]]&lt;/code&gt; ，以确保它与所有非空白字符匹配。包含换行符的匹配会在换行符处被静默截断（！）。</target>
        </trans-unit>
        <trans-unit id="ca9e8deab33d39332d7b528ab194c9573c58ac97" translate="yes" xml:space="preserve">
          <source>Every notes change creates a new commit at the specified notes ref. You can therefore inspect the history of the notes by invoking, e.g., &lt;code&gt;git log -p notes/commits&lt;/code&gt;. Currently the commit message only records which operation triggered the update, and the commit authorship is determined according to the usual rules (see &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;). These details may change in the future.</source>
          <target state="translated">每次注释更改都会在指定的注释引用处创建一个新提交。因此，您可以通过调用检查注释的历史记录，例如 &lt;code&gt;git log -p notes/commits&lt;/code&gt; 。当前，提交消息仅记录哪个操作触发了更新，并且提交作者身份是根据通常的规则确定的（请参阅&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;）。这些细节将来可能会更改。</target>
        </trans-unit>
        <trans-unit id="5bfad9a034d5ed29730f0b4fba66efb6b1249b9d" translate="yes" xml:space="preserve">
          <source>Every once in a while have your frontend emit a &lt;code&gt;progress&lt;/code&gt; message to fast-import. The contents of the messages are entirely free-form, so one suggestion would be to output the current month and year each time the current commit date moves into the next month. Your users will feel better knowing how much of the data stream has been processed.</source>
          <target state="translated">偶尔让您的前端发出 &lt;code&gt;progress&lt;/code&gt; 消息以快速导入。消息的内容完全是自由格式，因此建议每当当前提交日期移至下个月时，输出当前月份和年份。了解多少数据流已被处理，您的用户会感觉更好。</target>
        </trans-unit>
        <trans-unit id="cda48ad1074123130b527f02f3f1db8c4fd5c129" translate="yes" xml:space="preserve">
          <source>Every once in a while, &lt;code&gt;git repack&lt;/code&gt; the public repository. Go back to step 5. and continue working.</source>
          <target state="translated">&lt;code&gt;git repack&lt;/code&gt; 偶尔会重新打包公共存储库。返回第5步，继续工作。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
