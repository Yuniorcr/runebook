<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="89c3a76b400f69bc409951d41f44580e1ce5b550" translate="yes" xml:space="preserve">
          <source>When a scripting language specific quoting is in effect, everything between a top-level opening atom and its matching %(end) is evaluated according to the semantics of the opening atom and only its result from the top-level is quoted.</source>
          <target state="translated">当脚本语言特有的引号生效时,顶层开口原子与其匹配的%(end)之间的所有内容都会根据开口原子的语义进行评估,只有其来自顶层的结果才会被引用。</target>
        </trans-unit>
        <trans-unit id="1d0d6b410e7d083b396401fa9485dd3214d89132" translate="yes" xml:space="preserve">
          <source>When a variable is said to take a boolean value, many synonyms are accepted for &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;; these are all case-insensitive.</source>
          <target state="translated">当一个变量被认为是布尔值时，很多同义词都接受 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; ; 这些都不区分大小写。</target>
        </trans-unit>
        <trans-unit id="085e4eddfd9be8c4f3b576466769939a6475604e" translate="yes" xml:space="preserve">
          <source>When accepting a new code drop for a vendor branch, you probably want to record both the removal of paths and additions of new paths as well as modifications of existing paths.</source>
          <target state="translated">在接受厂商分支的新代码投放时,你可能既要记录路径的删除,也要记录新路径的添加以及现有路径的修改。</target>
        </trans-unit>
        <trans-unit id="98d4ec1ab85d43886cf359223c5c65ec41aa50b0" translate="yes" xml:space="preserve">
          <source>When accepting a signed push (see &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;), the signed push certificate is stored in a blob and an environment variable &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; can be consulted for its object name. See the description of &lt;code&gt;post-receive&lt;/code&gt; hook for an example. In addition, the certificate is verified using GPG and the result is exported with the following environment variables:</source>
          <target state="translated">接受签名的推送（请参阅&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;）时，签名的推送证书存储在Blob中，可以使用环境变量 &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; 来获取其对象名称。有关示例，请参见 &lt;code&gt;post-receive&lt;/code&gt; 挂钩的描述。此外，使用GPG验证证书，并使用以下环境变量导出结果：</target>
        </trans-unit>
        <trans-unit id="5d78f94855bee5654824b328b5c74fbbbf68d2ce" translate="yes" xml:space="preserve">
          <source>When acquiring credentials, consider the &quot;path&quot; component of an http or https URL to be important. Defaults to false. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">获取凭据时，请考虑http或https URL的&amp;ldquo;路径&amp;rdquo;部分很重要。默认为false。有关更多信息，请参见&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36125e3b1dadcf8415f427875bfbe6e3edb592ec" translate="yes" xml:space="preserve">
          <source>When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting).</source>
          <target state="translated">当向已经有注释的对象添加注释时,覆盖现有的注释(而不是中止)。</target>
        </trans-unit>
        <trans-unit id="31a6893d1f507cb4bce24b6631d6f67bbe0ca8c3" translate="yes" xml:space="preserve">
          <source>When advertising tips of available history from an alternate, use the shell to execute the specified command instead of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. The first argument is the absolute path of the alternate. Output must contain one hex object id per line (i.e., the same as produced by &lt;code&gt;git for-each-ref
--format='%(objectname)'&lt;/code&gt;).</source>
          <target state="translated">当通过备用广告发布可用历史的提示时，请使用Shell执行指定的命令，而不是&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt;。第一个参数是替代项的绝对路径。输出必须每行包含一个十六进制对象ID（即，与 &lt;code&gt;git for-each-ref --format='%(objectname)'&lt;/code&gt; 产生的ID相同）。</target>
        </trans-unit>
        <trans-unit id="aee562f05eaa47b0988f9365fa4403a675334ce1" translate="yes" xml:space="preserve">
          <source>When an argument can be misunderstood as either a revision or a path, they can be disambiguated by placing &lt;code&gt;--&lt;/code&gt; between them. E.g. &lt;code&gt;git diff -- HEAD&lt;/code&gt; is, &quot;I have a file called HEAD in my work tree. Please show changes between the version I staged in the index and what I have in the work tree for that file&quot;, not &quot;show difference between the HEAD commit and the work tree as a whole&quot;. You can say &lt;code&gt;git diff HEAD --&lt;/code&gt; to ask for the latter.</source>
          <target state="translated">当一个参数可以被误解为一个修订版或路径，它们可以通过将被消除歧义 &lt;code&gt;--&lt;/code&gt; 在它们之间。例如 &lt;code&gt;git diff -- HEAD&lt;/code&gt; 是，&amp;ldquo;我的工作树中有一个名为HEAD的文件。请显示在索引中暂存的版本与该文件的工作树中的版本之间的更改&amp;rdquo;，而不是&amp;ldquo;显示HEAD commit和整个工作树&amp;rdquo;。您可以说 &lt;code&gt;git diff HEAD --&lt;/code&gt; 要求后者。</target>
        </trans-unit>
        <trans-unit id="8ed1e316e9f06aa8f0fbb451acc5e5dd1d53d618" translate="yes" xml:space="preserve">
          <source>When an argument may be understood either as a reference or as a file name, choose to understand it as a format-patch argument (&lt;code&gt;--format-patch&lt;/code&gt;) or as a file name (&lt;code&gt;--no-format-patch&lt;/code&gt;). By default, when such a conflict occurs, git send-email will fail.</source>
          <target state="translated">当参数可以被理解为引用或文件名时，请选择将其理解为格式补丁参数（ &lt;code&gt;--format-patch&lt;/code&gt; ）或文件名（ &lt;code&gt;--no-format-patch&lt;/code&gt; ）。默认情况下，发生此类冲突时，git send-email将失败。</target>
        </trans-unit>
        <trans-unit id="daa45faaafc93f57dcfa6219226fd8a2224c7353" translate="yes" xml:space="preserve">
          <source>When an interactive command (such as &lt;code&gt;git add --patch&lt;/code&gt;) shows a colorized diff, git will pipe the diff through the shell command defined by this configuration variable. The command may mark up the diff further for human consumption, provided that it retains a one-to-one correspondence with the lines in the original diff. Defaults to disabled (no filtering).</source>
          <target state="translated">当交互式命令（例如 &lt;code&gt;git add --patch&lt;/code&gt; ）显示彩色的差异时，git将通过此配置变量定义的shell命令通过管道传递差异。该命令可以进一步标记差异以供人类使用，前提是该命令与原始差异中的行保持一一对应的关系。默认为禁用（不过滤）。</target>
        </trans-unit>
        <trans-unit id="66bd09d84d7f728fe64b22afe9c1d5b02faccf2f" translate="yes" xml:space="preserve">
          <source>When an optional Git branch name (or a Git commit object name) is specified as an argument, the subcommand works on the specified branch, not on the current branch.</source>
          <target state="translated">当指定一个可选的 Git 分支名(或 Git 提交对象名)作为参数时,子命令会在指定的分支上工作,而不是在当前分支上工作。</target>
        </trans-unit>
        <trans-unit id="54600ca959ccb5286a6125f852754e8a441f6246" translate="yes" xml:space="preserve">
          <source>When an update changes a branch (or more in general, a ref) that used to point at commit A to point at another commit B, it is called a fast-forward update if and only if B is a descendant of A.</source>
          <target state="translated">当一个更新将过去指向提交A的分支(或者更笼统地说,是一个ref)改变为指向另一个提交B的分支时,如果且仅当B是A的后裔时,它被称为快进更新。</target>
        </trans-unit>
        <trans-unit id="b999dfcfa57d71ee62dbc42f4d8a0527e63491d1" translate="yes" xml:space="preserve">
          <source>When applying a patch, detect a new or modified line that has whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that solely consist of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors.</source>
          <target state="translated">应用补丁程序时，请检测出现空白错误的新行或修改行。哪些空白错误由 &lt;code&gt;core.whitespace&lt;/code&gt; 配置控制。默认情况下，尾随空格（包括仅由空格组成的行）和在行的初始缩进内紧随其后是制表符的空格字符都被视为空格错误。</target>
        </trans-unit>
        <trans-unit id="b3581e25b4edfc3eae85f688560f931e31414d31" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore additions made by the patch. This can be used to extract the common part between two files by first running &lt;code&gt;diff&lt;/code&gt; on them and applying the result with this option, which would apply the deletion part but not the addition part.</source>
          <target state="translated">应用补丁程序时，请忽略补丁程序添加的内容。可以通过首先在两个文件上运行 &lt;code&gt;diff&lt;/code&gt; 并使用此选项应用结果来提取两个文件之间的公共部分，这将应用删除部分，而不应用加法部分。</target>
        </trans-unit>
        <trans-unit id="6bf2c606b0bf760a50dfcc2e9e2a1dfc6d6ce1b9" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore changes in whitespace in context lines if necessary. Context lines will preserve their whitespace, and they will not undergo whitespace fixing regardless of the value of the &lt;code&gt;--whitespace&lt;/code&gt; option. New lines will still be fixed, though.</source>
          <target state="translated">应用补丁程序时，如有必要，请忽略上下文行中空格的更改。上下文行将保留其空格，并且无论 &lt;code&gt;--whitespace&lt;/code&gt; 选项的值如何，它们都不会进行空格固定。不过，新行仍将固定。</target>
        </trans-unit>
        <trans-unit id="588f408b6e1e0374e87fb8fe5ff6e5cd0dca42b8" translate="yes" xml:space="preserve">
          <source>When applying the patch only to the working tree, mark new files to be added to the index later (see &lt;code&gt;--intent-to-add&lt;/code&gt; option in &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;). This option is ignored unless running in a Git repository and &lt;code&gt;--index&lt;/code&gt; is not specified. Note that &lt;code&gt;--index&lt;/code&gt; could be implied by other options such as &lt;code&gt;--cached&lt;/code&gt; or &lt;code&gt;--3way&lt;/code&gt;.</source>
          <target state="translated">当仅将补丁应用到工作树时，请标记以后要添加到索引的新文件（请参阅&lt;a href=&quot;git-add&quot;&gt;git-add [1]中的&lt;/a&gt; &lt;code&gt;--intent-to-add&lt;/code&gt; 选项）。除非在Git存储库中运行并且未指定 &lt;code&gt;--index&lt;/code&gt; ,否则将忽略此选项。请注意，-- &lt;code&gt;--index&lt;/code&gt; 可能由 &lt;code&gt;--cached&lt;/code&gt; 或 &lt;code&gt;--3way&lt;/code&gt; 等其他选项隐含。</target>
        </trans-unit>
        <trans-unit id="59fa333bf5332a3a74a0fa1b62097787ae41682d" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering a signed tag. With &lt;code&gt;strip&lt;/code&gt;, the tags will silently be made unsigned, with &lt;code&gt;warn-strip&lt;/code&gt; they will be made unsigned but a warning will be displayed, with &lt;code&gt;verbatim&lt;/code&gt;, they will be silently exported and with &lt;code&gt;warn&lt;/code&gt;, they will be exported, but you will see a warning.</source>
          <target state="translated">当要求 &lt;code&gt;abort&lt;/code&gt; （默认设置）时，该程序将在遇到签名标签时死亡。使用 &lt;code&gt;strip&lt;/code&gt; ，标签将被静默地设置为无符号，使用 &lt;code&gt;warn-strip&lt;/code&gt; ,它们将被设置为无符号，但是将显示警告，使用 &lt;code&gt;verbatim&lt;/code&gt; 显示，它们将被静默导出，使用 &lt;code&gt;warn&lt;/code&gt; ，将被导出，但是您将看到一个警告。 。</target>
        </trans-unit>
        <trans-unit id="a094fa226ab8da9ad05df22ffe9e8c64cbd9aea9" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering such a tag. With &lt;code&gt;drop&lt;/code&gt; it will omit such tags from the output. With &lt;code&gt;rewrite&lt;/code&gt;, if the tagged object is a commit, it will rewrite the tag to tag an ancestor commit (via parent rewriting; see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;)</source>
          <target state="translated">当要求 &lt;code&gt;abort&lt;/code&gt; （这是默认设置）时，该程序将在遇到此类标签​​时死亡。使用 &lt;code&gt;drop&lt;/code&gt; 时，将从输出中省略此类标签。使用 &lt;code&gt;rewrite&lt;/code&gt; ，如果标记的对象是提交，它将重写标签以标记祖先提交（通过父级重写；请参见&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="034f3e54dc418fd0aaba391926e4cdc6f9338cc5" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;--incremental&lt;/code&gt; option, the command outputs the result as it is built. The output generally will talk about lines touched by more recent commits first (i.e. the lines will be annotated out of order) and is meant to be used by interactive viewers.</source>
          <target state="translated">当使用 &lt;code&gt;--incremental&lt;/code&gt; 选项调用时，命令将在生成结果时输出结果。通常，输出将首先讨论较新的提交所触及的行（即，行将被无序注释），并打算由交互式查看器使用。</target>
        </trans-unit>
        <trans-unit id="37ed40c0b9c191bc52be1eea56e95c21c8c30c92" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, check out stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">从索引中检出路径时，请检出第2阶段（ &lt;code&gt;ours&lt;/code&gt; ）或第3阶段（ &lt;code&gt;theirs&lt;/code&gt; ）的未合并路径。</target>
        </trans-unit>
        <trans-unit id="b2d7eb083886da1526ca38a6780f9e98825df5e6" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.</source>
          <target state="translated">当从索引中检查路径时,不要在未合并的条目时失败,而是忽略未合并的条目。</target>
        </trans-unit>
        <trans-unit id="87b021689017efd0b4fbe642f48fde6408f7cde4" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths.</source>
          <target state="translated">当从索引中检查出路径时,这个选项可以让你在指定的路径中重新创建冲突的合并。</target>
        </trans-unit>
        <trans-unit id="44968c91f62b2f1c7eb77848556b128eac9d4512" translate="yes" xml:space="preserve">
          <source>When cloning an SVN repository, if none of the options for describing the repository layout is used (--trunk, --tags, --branches, --stdlayout), &lt;code&gt;git svn clone&lt;/code&gt; will create a Git repository with completely linear history, where branches and tags appear as separate directories in the working copy. While this is the easiest way to get a copy of a complete repository, for projects with many branches it will lead to a working copy many times larger than just the trunk. Thus for projects using the standard directory structure (trunk/branches/tags), it is recommended to clone with option &lt;code&gt;--stdlayout&lt;/code&gt;. If the project uses a non-standard structure, and/or if branches and tags are not required, it is easiest to only clone one directory (typically trunk), without giving any repository layout options. If the full history with branches and tags is required, the options &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; must be used.</source>
          <target state="translated">克隆SVN储存库时，如果不使用任何描述储存库布局的选项（--trunk，-tags，-branches，-stdlayout），则 &lt;code&gt;git svn clone&lt;/code&gt; 将创建具有完全线性历史记录的Git储存库，其中分支和标签在工作副本中显示为单独的目录。尽管这是获得完整存储库副本的最简单方法，但是对于具有许多分支的项目，这将导致其工作副本比主干大许多倍。因此，对于使用标准目录结构（trunk / branches / tags）的项目，建议使用 &lt;code&gt;--stdlayout&lt;/code&gt; 选项进行克隆。如果项目使用非标准结构，并且/或者如果不需要分支和标记，则最简单的方法是仅克隆一个目录（通常是主干），而不提供任何存储库布局选项。如果需要用树枝和标签的全部历史，选项 &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; 必须使用。</target>
        </trans-unit>
        <trans-unit id="cf5bdc8ee9de0e891bd2e2ffd6ad5374a27fb398" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; You can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules.</source>
          <target state="translated">克隆或提取包含子模块的存储库时，默认情况下不会检出子模块；您可以指示 &lt;code&gt;clone&lt;/code&gt; 递归到子模块中。 &lt;code&gt;git submodule&lt;/code&gt; 的 &lt;code&gt;init&lt;/code&gt; 和 &lt;code&gt;update&lt;/code&gt; 子命令将维护已检出的子模块，并在您的工作树中对其进行适当的修订。另外，您可以设置 &lt;code&gt;submodule.recurse&lt;/code&gt; 以使 &lt;code&gt;checkout&lt;/code&gt; 递归到子模块中。</target>
        </trans-unit>
        <trans-unit id="2bdda0ba49ff183f8b76fb42fb3146b89e404d42" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; you can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules (note that &lt;code&gt;submodule.recurse&lt;/code&gt; also affects other Git commands, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a complete list).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d739b21b6194611c8a45df16bb823ac3b01a4bd" translate="yes" xml:space="preserve">
          <source>When combined with the &lt;code&gt;run&lt;/code&gt; subcommand, run maintenance tasks only if certain thresholds are met. For example, the &lt;code&gt;gc&lt;/code&gt; task runs when the number of loose objects exceeds the number stored in the &lt;code&gt;gc.auto&lt;/code&gt; config setting, or when the number of pack-files exceeds the &lt;code&gt;gc.autoPackLimit&lt;/code&gt; config setting. Not compatible with the &lt;code&gt;--schedule&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61eed3296a596b65de979964c073754bc8210abb" translate="yes" xml:space="preserve">
          <source>When combined with the &lt;code&gt;run&lt;/code&gt; subcommand, run maintenance tasks only if certain time conditions are met, as specified by the &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.schedule&lt;/code&gt; config value for each &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt;. This config value specifies a number of seconds since the last time that task ran, according to the &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.lastRun&lt;/code&gt; config value. The tasks that are tested are those provided by the &lt;code&gt;--task=&amp;lt;task&amp;gt;&lt;/code&gt; option(s) or those with &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.enabled&lt;/code&gt; set to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96f700dec6ecf67635f001fe97af20a3a1af7ba" translate="yes" xml:space="preserve">
          <source>When combining multiple &lt;code&gt;--contains&lt;/code&gt; and &lt;code&gt;--no-contains&lt;/code&gt; filters, only references that contain at least one of the &lt;code&gt;--contains&lt;/code&gt; commits and contain none of the &lt;code&gt;--no-contains&lt;/code&gt; commits are shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3693ecef45adf0e594fc21eeb7dc1180a98b303e" translate="yes" xml:space="preserve">
          <source>When combining multiple &lt;code&gt;--merged&lt;/code&gt; and &lt;code&gt;--no-merged&lt;/code&gt; filters, only references that are reachable from at least one of the &lt;code&gt;--merged&lt;/code&gt; commits and from none of the &lt;code&gt;--no-merged&lt;/code&gt; commits are shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f5e261fa8e1325a05e77f0fa02cd4e804a016b" translate="yes" xml:space="preserve">
          <source>When committing fixups, consider using &lt;code&gt;merge&lt;/code&gt; to connect the commit(s) which are supplying file revisions to the fixup branch. Doing so will allow tools such as &lt;code&gt;git blame&lt;/code&gt; to track through the real commit history and properly annotate the source files.</source>
          <target state="translated">提交修订时，请考虑使用 &lt;code&gt;merge&lt;/code&gt; 将提供文件修订的提交连接到fixup分支。这样做将允许诸如 &lt;code&gt;git blame&lt;/code&gt; 之类的工具跟踪真实的提交历史记录并正确注释源文件。</target>
        </trans-unit>
        <trans-unit id="187746ad8497cb1dac2dfe493269450955422d85" translate="yes" xml:space="preserve">
          <source>When committing to svn from Git (as part of &lt;code&gt;set-tree&lt;/code&gt; or &lt;code&gt;dcommit&lt;/code&gt; operations), if the existing log message doesn&amp;rsquo;t already have a &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line, append a &lt;code&gt;From:&lt;/code&gt; line based on the Git commit&amp;rsquo;s author string. If you use this, then &lt;code&gt;--use-log-author&lt;/code&gt; will retrieve a valid author string for all commits.</source>
          <target state="translated">从Git提交svn时（作为 &lt;code&gt;set-tree&lt;/code&gt; 或 &lt;code&gt;dcommit&lt;/code&gt; 操作的一部分），如果现有日志消息中尚没有 &lt;code&gt;From:&lt;/code&gt; 或 &lt;code&gt;Signed-off-by:&lt;/code&gt; 行，请根据Git提交的内容附加 &lt;code&gt;From:&lt;/code&gt; 行作者字符串。如果使用此选项，则 &lt;code&gt;--use-log-author&lt;/code&gt; 将为所有提交检索有效的作者字符串。</target>
        </trans-unit>
        <trans-unit id="93d9f9b7d88e7e5ba3d52728cd609bd56e74440d" translate="yes" xml:space="preserve">
          <source>When committing to svn from Git (as part of &lt;code&gt;set-tree&lt;/code&gt; or &lt;code&gt;dcommit&lt;/code&gt; operations), if the existing log message doesn&amp;rsquo;t already have a &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by&lt;/code&gt; trailer, append a &lt;code&gt;From:&lt;/code&gt; line based on the Git commit&amp;rsquo;s author string. If you use this, then &lt;code&gt;--use-log-author&lt;/code&gt; will retrieve a valid author string for all commits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df4d9e8de337675930b7c7d126c3cbfdb0d919e8" translate="yes" xml:space="preserve">
          <source>When common porcelain operations that create objects are run, they will check whether the repository has grown substantially since the last maintenance, and if so run &lt;code&gt;git gc&lt;/code&gt; automatically. See &lt;code&gt;gc.auto&lt;/code&gt; below for how to disable this behavior.</source>
          <target state="translated">当运行创建对象的常用瓷器操作时，它们将检查自上次维护以来存储库是否已显着增长，如果是，则自动运行 &lt;code&gt;git gc&lt;/code&gt; 。有关如何禁用此行为的信息，请参见下面的 &lt;code&gt;gc.auto&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cef5cc19d56f034a0850f6ce0dc6add0c966a70" translate="yes" xml:space="preserve">
          <source>When comparing two trees, the ID of both trees (separated by a space and terminated by a newline) is printed before the difference. When comparing commits, the ID of the first (or only) commit, followed by a newline, is printed.</source>
          <target state="translated">当比较两棵树时,在差异之前打印两棵树的ID(用空格隔开,用换行结束)。当比较提交时,打印第一个(或唯一的)提交的ID,后面加一个换行。</target>
        </trans-unit>
        <trans-unit id="fe249445673b1134855083e0c3b366c4aeeb2c8e" translate="yes" xml:space="preserve">
          <source>When converting a value to its canonical form using the &lt;code&gt;--type=bool&lt;/code&gt; type specifier, &lt;code&gt;git config&lt;/code&gt; will ensure that the output is &quot;true&quot; or &quot;false&quot; (spelled in lowercase).</source>
          <target state="translated">使用 &lt;code&gt;--type=bool&lt;/code&gt; 类型说明符将值转换为规范形式时， &lt;code&gt;git config&lt;/code&gt; 将确保输出为&amp;ldquo; true&amp;rdquo;或&amp;ldquo; false&amp;rdquo;（拼写为小写）。</target>
        </trans-unit>
        <trans-unit id="5800d8777d6f116b967a3c4b503079e04a8dd27b" translate="yes" xml:space="preserve">
          <source>When copying a remote repository, you&amp;rsquo;ll want to at a minimum update the index cache when you do this, and especially with other peoples' repositories you often want to make sure that the index cache is in some known state (you don&amp;rsquo;t know &lt;strong&gt;what&lt;/strong&gt; they&amp;rsquo;ve done and not yet checked in), so usually you&amp;rsquo;ll precede the &lt;code&gt;git update-index&lt;/code&gt; with a</source>
          <target state="translated">复制远程存储库时，您至少需要在执行此操作时更新索引缓存，尤其是在其他人的存储库中，通常需要确保索引缓存处于某种已知状态（您不希望这样做）。知道&lt;strong&gt;什么&lt;/strong&gt;他们做了，并没有检查），所以通常你会在之前 &lt;code&gt;git update-index&lt;/code&gt; 用</target>
        </trans-unit>
        <trans-unit id="a0c9c076efebd050282e8220820bf37e469a5914" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite (see the &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; option), determines what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">在重写过程中复制笔记时（请参阅&amp;ldquo; notes.rewrite。&amp;lt;command&amp;gt;&amp;rdquo;选项），确定目标提交已包含笔记时该怎么做。必须是 &lt;code&gt;overwrite&lt;/code&gt; ， &lt;code&gt;concatenate&lt;/code&gt; ， &lt;code&gt;cat_sort_uniq&lt;/code&gt; 或 &lt;code&gt;ignore&lt;/code&gt; 之一。默认为 &lt;code&gt;concatenate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2daf889c63a8ae3ef0bd84b9e0a7bae3186ea5d" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. May be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">在重写过程中复制注释时,指定应该复制其注释的(完全限定的)ref。可能是一个 glob,在这种情况下,所有匹配的 refs 中的注释都会被复制。您也可以多次指定这个配置。</target>
        </trans-unit>
        <trans-unit id="c445d369a5c50740a59f3ad28697ace644e2811e" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. The ref may be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">在重写过程中复制笔记时,指定应该复制其笔记的(完全限定的)ref。ref可能是一个glob,在这种情况下,所有匹配的ref中的注释都会被复制。您也可以多次指定这个配置。</target>
        </trans-unit>
        <trans-unit id="1243aaab79ff33e7a2d49c8eb8b4f16703a1c016" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">在重写过程中复制笔记时，如果目标提交已包含笔记该怎么办。必须是 &lt;code&gt;overwrite&lt;/code&gt; ， &lt;code&gt;concatenate&lt;/code&gt; ， &lt;code&gt;cat_sort_uniq&lt;/code&gt; 或 &lt;code&gt;ignore&lt;/code&gt; 之一。默认为 &lt;code&gt;concatenate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb6ea94e62e06bb5ee870300111df0d9f630f320" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. This overrides the &lt;code&gt;core.rewriteMode&lt;/code&gt; setting.</source>
          <target state="translated">在重写过程中复制笔记时，如果目标提交已包含笔记该怎么办。必须是 &lt;code&gt;overwrite&lt;/code&gt; ， &lt;code&gt;concatenate&lt;/code&gt; ， &lt;code&gt;cat_sort_uniq&lt;/code&gt; 或 &lt;code&gt;ignore&lt;/code&gt; 之一。这将覆盖 &lt;code&gt;core.rewriteMode&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="fa7e030aba2e9a9a4e5882753f19d2b4a66b4e16" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">创建新分支时，如果 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 是分支，则将其标记为新分支的&amp;ldquo;上游&amp;rdquo;。如果 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 是远程跟踪分支，则为默认设置。有关详细信息，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]中的&lt;/a&gt; &amp;ldquo; --track&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="4e04dc75cba18b40521f918d2128a9cc7f50298f" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d8049451fa958ada38921d90347d3ee7c4d771" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. &lt;code&gt;-c&lt;/code&gt; is implied. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">创建新分支时，请设置&amp;ldquo;上游&amp;rdquo;配置。 &lt;code&gt;-c&lt;/code&gt; 是隐含的。有关详细 &lt;code&gt;--track&lt;/code&gt; ，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]中的&lt;/a&gt;--track。</target>
        </trans-unit>
        <trans-unit id="fc590aa31fec73c4296b9f428640a84b6d3e91a7" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">创建新分支时，请设置&amp;ldquo;上游&amp;rdquo;配置。有关详细信息，请参见&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]中的&lt;/a&gt; &amp;ldquo; --track&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="67211ea9327a11f7c102d4d6622e44707e57316e" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries to mark the start-point branch as &quot;upstream&quot; from the new branch. This configuration will tell git to show the relationship between the two branches in &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git branch -v&lt;/code&gt;. Furthermore, it directs &lt;code&gt;git pull&lt;/code&gt; without arguments to pull from the upstream when the new branch is checked out.</source>
          <target state="translated">创建新分支时，请设置 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 和 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 配置条目，以将起点分支标记为新分支的&amp;ldquo;上游&amp;rdquo;。此配置将告诉git显示处于 &lt;code&gt;git status&lt;/code&gt; 和 &lt;code&gt;git branch -v&lt;/code&gt; 的两个分支之间的关系。此外，它指示不带参数的 &lt;code&gt;git pull&lt;/code&gt; 在签出新分支时从上游拉出。</target>
        </trans-unit>
        <trans-unit id="30421c6d8900807173aa121649f943a72b9b4dbe" translate="yes" xml:space="preserve">
          <source>When creating a packed archive in a repository that has existing packs, the command reuses existing deltas. This sometimes results in a slightly suboptimal pack. This flag tells the command not to reuse existing deltas but compute them from scratch.</source>
          <target state="translated">当在有现有包的仓库中创建打包后的存档时,该命令会重复使用现有的 deltas。这有时会导致一个略微次优的包。这个标志告诉命令不要重复使用现有的三角区,而是从头开始计算。</target>
        </trans-unit>
        <trans-unit id="40641904740525d3a46d2f53ea1f042429403d62" translate="yes" xml:space="preserve">
          <source>When creating files, prepend &amp;lt;string&amp;gt; (usually a directory including a trailing /)</source>
          <target state="translated">创建文件时，请在&amp;lt;string&amp;gt;之前添加前缀（通常是包含尾随/的目录）</target>
        </trans-unit>
        <trans-unit id="55d2573d14b31c180f96244b6210a62251fe4b79" translate="yes" xml:space="preserve">
          <source>When dealing with &lt;code&gt;git diff-tree&lt;/code&gt; output, it takes advantage of the fact that the patch is prefixed with the object name of the commit, and outputs two 40-byte hexadecimal strings. The first string is the patch ID, and the second string is the commit ID. This can be used to make a mapping from patch ID to commit ID.</source>
          <target state="translated">处理 &lt;code&gt;git diff-tree&lt;/code&gt; 输出时，它利用了补丁以提交对象名称为前缀的事实，并输出两个40字节的十六进制字符串。第一个字符串是补丁ID，第二个字符串是提交ID。这可用于从补丁程序ID到提交ID的映射。</target>
        </trans-unit>
        <trans-unit id="d776ef3252048cd13183a8501d7c0015731386cd" translate="yes" xml:space="preserve">
          <source>When deciding what attributes are assigned to a path, Git consults &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file (which has the highest precedence), &lt;code&gt;.gitattributes&lt;/code&gt; file in the same directory as the path in question, and its parent directories up to the toplevel of the work tree (the further the directory that contains &lt;code&gt;.gitattributes&lt;/code&gt; is from the path in question, the lower its precedence). Finally global and system-wide files are considered (they have the lowest precedence).</source>
          <target state="translated">在确定将哪些属性分配给路径时，Git会参考 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 文件（优先级最高） &lt;code&gt;.gitattributes&lt;/code&gt; 文件与所讨论路径位于同一目录中，以及其父目录直至该目录的顶层。工作树（包含 &lt;code&gt;.gitattributes&lt;/code&gt; 的目录距离所讨论的路径越远，其优先级越低）。最后，考虑全局文件和系统范围的文件（它们的优先级最低）。</target>
        </trans-unit>
        <trans-unit id="be47e73cae5925c270f0353e0b448f44fba38688" translate="yes" xml:space="preserve">
          <source>When deinitialized or deleted (see below), the submodule&amp;rsquo;s Git directory is automatically moved to &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; of the superproject.</source>
          <target state="translated">当 &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; 或删除时（参见下文），子模块的Git目录将自动移至超级项目的$ GIT_DIR / modules / &amp;lt;name&amp;gt; /中。</target>
        </trans-unit>
        <trans-unit id="d6198e5c096df70165a4ba7282b14c9062838d85" translate="yes" xml:space="preserve">
          <source>When displaying names of reachable objects, in addition to the SHA-1 also display a name that describes &lt;strong&gt;how&lt;/strong&gt; they are reachable, compatible with &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;, e.g. &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt;.</source>
          <target state="translated">当显示可到达对象的名称时，除了SHA-1之外，还会显示描述它们&lt;strong&gt;如何&lt;/strong&gt;可到达的名称，与&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt;兼容，例如 &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39ccc422d97039f55d5b75b982904e65809f0ab0" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in a porcelain-ready format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">在进行空运行时，以瓷器就绪格式提供输出。有关详细信息，请参见&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;。意味着 &lt;code&gt;--dry-run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91fdf83cd4cf2351c13b94fc0d59dcd9a51c5b73" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the long-format. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">空试时，以长格式提供输出。意味着 &lt;code&gt;--dry-run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7320eee3c7f6d76666dfe697952518d827846a03" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the short-format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">空试时，以短格式给出输出。有关详细信息，请参见&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;。意味着 &lt;code&gt;--dry-run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9aa102d4a4b04252e6d4b5a0080dce309ef777d4" translate="yes" xml:space="preserve">
          <source>When doing a repository conversion, use a unique mark per commit (&lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt;) and supply the --export-marks option on the command line. fast-import will dump a file which lists every mark and the Git object SHA-1 that corresponds to it. If the frontend can tie the marks back to the source repository, it is easy to verify the accuracy and completeness of the import by comparing each Git commit to the corresponding source revision.</source>
          <target state="translated">在进行存储库转换时，每次提交使用唯一标记（ &lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt; ），并在命令行上提供--export-marks选项。快速导入将转储一个文件，其中列出了每个标记以及与之对应的Git对象SHA-1。如果前端可以将标记重新绑定到源存储库，则可以通过将每个Git提交与相应的源修订版本进行比较，轻松地验证导入的准确性和完整性。</target>
        </trans-unit>
        <trans-unit id="6f397bf185a0b1be7403f8c718221517e54d79b2" translate="yes" xml:space="preserve">
          <source>When editing the commit message, start the editor with the contents in the given file. The &lt;code&gt;commit.template&lt;/code&gt; configuration variable is often used to give this option implicitly to the command. This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order. If the user exits the editor without editing the message, the commit is aborted. This has no effect when a message is given by other means, e.g. with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; options.</source>
          <target state="translated">编辑提交消息时，请使用给定文件中的内容启动编辑器。所述 &lt;code&gt;commit.template&lt;/code&gt; 配置变量经常被用于隐含地给这个选项添加到命令。此机制可用于希望引导参与者以什么顺序在消息中写些什么的项目。如果用户退出编辑器而不编辑消息，则提交将中止。当通过其他方式（例如，使用 &lt;code&gt;-m&lt;/code&gt; 或 &lt;code&gt;-F&lt;/code&gt; 选项）给出消息时，这无效。</target>
        </trans-unit>
        <trans-unit id="7835173f74e58e15c8891f5a3e0b3af743fd1c66" translate="yes" xml:space="preserve">
          <source>When editing, provide the raw object contents rather than pretty-printed ones. Currently this only affects trees, which will be shown in their binary form. This is harder to work with, but can help when repairing a tree that is so corrupted it cannot be pretty-printed. Note that you may need to configure your editor to cleanly read and write binary data.</source>
          <target state="translated">当编辑时,提供原始对象内容,而不是漂亮的打印内容。目前这只影响树,树将以二进制形式显示。这是比较难处理的,但在修复一棵被破坏得无法以漂亮打印的树时,会有帮助。请注意,你可能需要配置你的编辑器来清洁地读写二进制数据。</target>
        </trans-unit>
        <trans-unit id="ce47e94310de9fcb0d82c1f052bbcc38f3a11f76" translate="yes" xml:space="preserve">
          <source>When enabled, the default &lt;code&gt;post-update&lt;/code&gt; hook runs &lt;code&gt;git update-server-info&lt;/code&gt; to keep the information used by dumb transports (e.g., HTTP) up to date. If you are publishing a Git repository that is accessible via HTTP, you should probably enable this hook.</source>
          <target state="translated">启用后，默认 &lt;code&gt;post-update&lt;/code&gt; 挂钩将运行 &lt;code&gt;git update-server-info&lt;/code&gt; ,以使哑传输（例如HTTP）使用的信息保持最新。如果要发布可通过HTTP访问的Git存储库，则可能应启用此挂钩。</target>
        </trans-unit>
        <trans-unit id="a529b1482d7666548417edb1d901df1240194350" translate="yes" xml:space="preserve">
          <source>When encountering a non-ASCII message or subject that does not declare its encoding, add headers/quoting to indicate it is encoded in &amp;lt;encoding&amp;gt;. Default is the value of the &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt;; if that is unspecified, this will be prompted for if any non-ASCII files are encountered.</source>
          <target state="translated">遇到未声明其编码的非ASCII消息或主题时，请添加标头/引号以指示其已在&amp;lt;encoding&amp;gt;中进行编码。默认值为 &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt; 的值；如果未指定，则将提示您是否遇到任何非ASCII文件。</target>
        </trans-unit>
        <trans-unit id="c331bd8bb74634e4f18684aaa53f36ba8f8cf37d" translate="yes" xml:space="preserve">
          <source>When erasing credentials, matching credentials will be erased from all files.</source>
          <target state="translated">擦除凭证时,匹配的凭证将从所有文件中擦除。</target>
        </trans-unit>
        <trans-unit id="74e58a3904b06fc63c005d33dc33b553098868b7" translate="yes" xml:space="preserve">
          <source>When extensions.worktreeConfig is enabled, the config file &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; is read after &lt;code&gt;.git/config&lt;/code&gt; is.</source>
          <target state="translated">启用extensions.worktreeConfig后，将在 &lt;code&gt;.git/config&lt;/code&gt; 之后读取配置文件 &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a73371934954e7de3c00c5b21339d1552e97b06" translate="yes" xml:space="preserve">
          <source>When false, merge the current branch into the upstream branch.</source>
          <target state="translated">当为假时,将当前分支合并到上游分支。</target>
        </trans-unit>
        <trans-unit id="d5dfb7a500ca38e6f311c3fe54f4fbaf71bc47ce" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. Providing an empty &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; to the &lt;code&gt;--refmap&lt;/code&gt; option causes Git to ignore the configured refspecs and rely entirely on the refspecs supplied as command-line arguments. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8afe72df4116adf55dd615031acfafbceae0ec5" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="translated">当获取命令行上列出的引用时，请使用指定的refspec（可以多次提供）将引用映射到远程跟踪分支，而不是远程存储库的 &lt;code&gt;remote.*.fetch&lt;/code&gt; 配置变量的值。有关详细信息，请参见&amp;ldquo;配置的远程跟踪分支&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="f131c02a4584603f0de6ca46a404ddf3258dbf13" translate="yes" xml:space="preserve">
          <source>When files are modified outside of Git, the user will need to stage the modified files explicitly (e.g. see &lt;code&gt;Examples&lt;/code&gt; section in &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;). Git will not normally detect changes to those files.</source>
          <target state="translated">在Git之外修改文件时，用户将需要显式地登台修改过的文件（例如，参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]中的&amp;ldquo; &lt;/a&gt; &lt;code&gt;Examples&lt;/code&gt; 部分）。Git通常不会检测到这些文件的更改。</target>
        </trans-unit>
        <trans-unit id="e95f7718835508fa2f714691dae7615b5ccee03a" translate="yes" xml:space="preserve">
          <source>When filtering history with &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt;, does not prune some history. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">当过滤历史 &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt; ，不修剪一些历史。（有关详细说明，请参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;中的&amp;ldquo;历史记录简化&amp;rdquo; 。）</target>
        </trans-unit>
        <trans-unit id="18f94df4064f0faddb37415d13a088dd57356563" translate="yes" xml:space="preserve">
          <source>When first created, objects are stored in individual files, but for efficiency may later be compressed together into &quot;pack files&quot;.</source>
          <target state="translated">当第一次创建时,对象被存储在单独的文件中,但为了提高效率,以后可能会被压缩在一起成为 &quot;打包文件&quot;。</target>
        </trans-unit>
        <trans-unit id="3ce1186a221491da0c957498f84e962314b0f4f4" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;.</source>
          <target state="translated">给定要显示的提交范围（例如 &lt;code&gt;commit1..commit2&lt;/code&gt; 或 &lt;code&gt;commit2 ^commit1&lt;/code&gt; ）时，仅显示直接存在于 &lt;code&gt;commit1&lt;/code&gt; 和 &lt;code&gt;commit2&lt;/code&gt; 之间的祖先链上的提交，即既是 &lt;code&gt;commit1&lt;/code&gt; 的后代又是commit2的后代的 &lt;code&gt;commit2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e006844e32fc3d063be827d3911798e9ae2b69bd" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">给定要显示的提交范围（例如 &lt;code&gt;commit1..commit2&lt;/code&gt; 或 &lt;code&gt;commit2 ^commit1&lt;/code&gt; ）时，仅显示直接存在于 &lt;code&gt;commit1&lt;/code&gt; 和 &lt;code&gt;commit2&lt;/code&gt; 之间的祖先链上的提交，即既是 &lt;code&gt;commit1&lt;/code&gt; 的后代又是commit2的祖先的 &lt;code&gt;commit2&lt;/code&gt; 。 （有关详细说明，请参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;中的&amp;ldquo;历史记录简化&amp;rdquo; 。）</target>
        </trans-unit>
        <trans-unit id="8281565ed0f01821dd04f5b4f8a282147fc8eb15" translate="yes" xml:space="preserve">
          <source>When given a two-part name section.key, the value for section.&amp;lt;url&amp;gt;.key whose &amp;lt;url&amp;gt; part matches the best to the given URL is returned (if no such key exists, the value for section.key is used as a fallback). When given just the section as name, do so for all the keys in the section and list them. Returns error code 1 if no value is found.</source>
          <target state="translated">当给定一个由两部分组成的名称section.key时，将返回其&amp;lt;url&amp;gt;部分与给定URL最匹配的section。&amp;lt;url&amp;gt; .key的值（如果不存在这样的密钥，则使用section.key的值作为备用）。如果仅以该部分的名称作为名称，请对该部分中的所有键进行命名并列出它们。如果找不到值，则返回错误代码1。</target>
        </trans-unit>
        <trans-unit id="f88bacf945cb9e0553c03a8ac1d906d306ca24eb" translate="yes" xml:space="preserve">
          <source>When given an SVN revision number of the form &lt;code&gt;rN&lt;/code&gt;, returns the corresponding Git commit hash (this can optionally be followed by a tree-ish to specify which branch should be searched). When given a tree-ish, returns the corresponding SVN revision number.</source>
          <target state="translated">当给定SVN版本号为 &lt;code&gt;rN&lt;/code&gt; 时，返回相应的Git commit哈希值（可以选择后面跟一个树状语句来指定应该搜索哪个分支）。给定树状结构时，返回相应的SVN版本号。</target>
        </trans-unit>
        <trans-unit id="a96423d691859ec79cd98b29f7765677feb267ba" translate="yes" xml:space="preserve">
          <source>When given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end.</source>
          <target state="translated">当给定,并且要克隆的仓库是通过ssh访问时,这将为另一端运行的命令指定一个非默认路径。</target>
        </trans-unit>
        <trans-unit id="d1fb59a7ba9cbb456b044d488d1684f86345d108" translate="yes" xml:space="preserve">
          <source>When given, and the repository to fetch from is handled by &lt;code&gt;git fetch-pack&lt;/code&gt;, &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; is passed to the command to specify non-default path for the command run on the other end.</source>
          <target state="translated">如果给定了信息，并且要从中获取信息的存储库由 &lt;code&gt;git fetch-pack&lt;/code&gt; 处理，则 &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; 会传递给命令，以为另一端运行的命令指定非默认路径。</target>
        </trans-unit>
        <trans-unit id="347806ba4d643d64e35fb6159f6ca9df9bd36627" translate="yes" xml:space="preserve">
          <source>When giving multiple pattern expressions combined with &lt;code&gt;--or&lt;/code&gt;, this flag is specified to limit the match to files that have lines to match all of them.</source>
          <target state="translated">当给出多个与 &lt;code&gt;--or&lt;/code&gt; 组合的模式表达式时，将指定此标志以将匹配项限制为具有所有行都匹配的文件。</target>
        </trans-unit>
        <trans-unit id="a0b6fe15df65f2d5daa97101d52d41abe4f1ad3a" translate="yes" xml:space="preserve">
          <source>When grepping the object store (with &lt;code&gt;--cached&lt;/code&gt; or giving tree objects), running with multiple threads might perform slower than single threaded if &lt;code&gt;--textconv&lt;/code&gt; is given and there&amp;rsquo;re too many text conversions. So if you experience low performance in this case, it might be desirable to use &lt;code&gt;--threads=1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aea2178dff194f0c4c01be5fd5d2a4667a09068" translate="yes" xml:space="preserve">
          <source>When he&amp;rsquo;s ready, he tells Alice to pull changes from the repository at /home/bob/myrepo. She does this with:</source>
          <target state="translated">准备就绪后，他告诉Alice从/ home / bob / myrepo的存储库中提取更改。她这样做是：</target>
        </trans-unit>
        <trans-unit id="66bba6f8c73ac5f72ec362ac6e58a5210f96d2e5" translate="yes" xml:space="preserve">
          <source>When importing a renamed file or directory, simply delete the old name(s) and modify the new name(s) during the corresponding commit. Git performs rename detection after-the-fact, rather than explicitly during a commit.</source>
          <target state="translated">当导入一个重命名的文件或目录时,只需删除旧名,并在相应的提交中修改新名即可。Git 会在事后进行重命名检测,而不是在提交时明确地进行检测。</target>
        </trans-unit>
        <trans-unit id="547b791fe6e4a112ecfb6e63c2e9ee0d26e77b05" translate="yes" xml:space="preserve">
          <source>When in cone mode, the &lt;code&gt;git sparse-checkout set&lt;/code&gt; subcommand takes a list of directories instead of a list of sparse-checkout patterns. In this mode, the command &lt;code&gt;git sparse-checkout set A/B/C&lt;/code&gt; sets the directory &lt;code&gt;A/B/C&lt;/code&gt; as a recursive pattern, the directories &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A/B&lt;/code&gt; are added as parent patterns. The resulting sparse-checkout file is now</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdd5299d04b153fd0e295904b9e12eec6b499c8" translate="yes" xml:space="preserve">
          <source>When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt;). Note that the current worktree&amp;rsquo;s HEAD will not have its path printed (it will always be your current directory).</source>
          <target state="translated">在列表模式下，显示sha1并提交每个标题的主题行，以及与上游分支的关系（如果有）。如果给出两次，则打印链接的工作树的路径（如果有）以及上游分支的名称（另请参见 &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt; ）。请注意，当前工作树的HEAD不会打印其路径（它将始终是您的当前目录）。</target>
        </trans-unit>
        <trans-unit id="df3e42ff48559b3d46a4606cc43ea02a4d5742e5" translate="yes" xml:space="preserve">
          <source>When informative errors are turned on, git-daemon will report more verbose errors to the client, differentiating conditions like &quot;no such repository&quot; from &quot;repository not exported&quot;. This is more convenient for clients, but may leak information about the existence of unexported repositories. When informative errors are not enabled, all errors report &quot;access denied&quot; to the client. The default is --no-informative-errors.</source>
          <target state="translated">当开启信息错误时,git-daemon会向客户端报告更详细的错误,将 &quot;没有这样的仓库 &quot;和 &quot;没有导出仓库 &quot;这样的情况区分开来。这对客户端来说比较方便,但可能会泄露未导出版本库的信息。当不启用信息错误时,所有错误都会向客户端报告 &quot;拒绝访问&quot;。默认值是--no-informative-errors。</target>
        </trans-unit>
        <trans-unit id="882f7c25abfabdf5a0527656f301ec49c21b72e8" translate="yes" xml:space="preserve">
          <source>When initializing submodules, a &lt;code&gt;.gitmodules&lt;/code&gt; file in the top-level directory of the containing repository is used to find the url of each submodule. This file should be formatted in the same way as &lt;code&gt;$GIT_DIR/config&lt;/code&gt;. The key to each submodule url is &quot;submodule.$name.url&quot;. See &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">初始化子模块时，包含存储库的顶级目录中的 &lt;code&gt;.gitmodules&lt;/code&gt; 文件用于查找每个子模块的url。该文件的格式应与 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 。每个子模块URL的键是&amp;ldquo; submodule。$ name.url&amp;rdquo;。有关详细信息，请参见&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="854c3f2001a62b8064a99a360e1e32072b64ad8e" translate="yes" xml:space="preserve">
          <source>When initially invoking &lt;code&gt;git am&lt;/code&gt;, you give it the names of the mailboxes to process. Upon seeing the first patch that does not apply, it aborts in the middle. You can recover from this in one of two ways:</source>
          <target state="translated">最初调用 &lt;code&gt;git am&lt;/code&gt; 时，您给它提供了要处理的邮箱的名称。看到不适用的第一个补丁后，它会在中间中止。您可以通过以下两种方式之一从中恢复：</target>
        </trans-unit>
        <trans-unit id="ae919810620b188b4a098cb2c7010981f59eb2a8" translate="yes" xml:space="preserve">
          <source>When invoking a custom merge tool, Git uses a set of temporary files to pass to the tool. If the tool returns an error and this variable is set to &lt;code&gt;true&lt;/code&gt;, then these temporary files will be preserved, otherwise they will be removed after the tool has exited. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">调用自定义合并工具时，Git使用一组临时文件传递给该工具。如果工具返回错误且此变量设置为 &lt;code&gt;true&lt;/code&gt; ，则将保留这些临时文件，否则将在工具退出后将其删除。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b149cf0c1c59f45e7d020f119cab62bcf88ef5e" translate="yes" xml:space="preserve">
          <source>When it comes to editing that commit, execute &lt;code&gt;git reset HEAD^&lt;/code&gt;. The effect is that the HEAD is rewound by one, and the index follows suit. However, the working tree stays the same.</source>
          <target state="translated">在编辑提交时，执行 &lt;code&gt;git reset HEAD^&lt;/code&gt; 。效果是将HEAD倒退一个，索引也随之变化。但是，工作树保持不变。</target>
        </trans-unit>
        <trans-unit id="54d95c16d8a8ecd15ca228486caba0d9b645aa97" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to apply a change, the following happens:</source>
          <target state="translated">当不清楚如何应用变化时,会发生以下情况。</target>
        </trans-unit>
        <trans-unit id="42b78027e34d66bfdfc08d7cf571f024832571b4" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to reconcile the changes, the following happens:</source>
          <target state="translated">当如何协调这些变化不明显时,就会发生以下情况。</target>
        </trans-unit>
        <trans-unit id="ac3a9525cba718f2ba4c34b577914369145b2d3f" translate="yes" xml:space="preserve">
          <source>When listing references from an alternate, list only references that begin with the given prefix. Prefixes match as if they were given as arguments to &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. To list multiple prefixes, separate them with whitespace. If &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; is set, setting &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; has no effect.</source>
          <target state="translated">从备用列表列出引用时，仅列出以给定前缀开头的引用。前缀匹配，就好像它们是&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]的参数一样&lt;/a&gt;。要列出多个前缀，请用空格分隔它们。如果 &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; 设置，设置 &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; 没有任何效果。</target>
        </trans-unit>
        <trans-unit id="9485b24ac5fd9e24de580d1b4ae98203a381daa8" translate="yes" xml:space="preserve">
          <source>When listing, use the specified &amp;lt;format&amp;gt;, which can be one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;. When omitted, the format defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">列出时，请使用指定的&amp;lt;format&amp;gt;，它可以是 &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;medium&lt;/code&gt; 和 &lt;code&gt;long&lt;/code&gt; 之一。如果省略，则格式默认为 &lt;code&gt;short&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0de171dd2f5efd6969d6cc172c7d84e26d4bf231" translate="yes" xml:space="preserve">
          <source>When loosening unreachable objects, do not bother loosening any objects older than &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt;. This can be used to optimize out the write of any objects that would be immediately pruned by a follow-up &lt;code&gt;git prune&lt;/code&gt;.</source>
          <target state="translated">松开无法到达的对象时，请勿费心松开任何 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 之前的对象。这可以用来优化对任何由后续 &lt;code&gt;git prune&lt;/code&gt; 修剪的对象的写入。</target>
        </trans-unit>
        <trans-unit id="2ecd3bb7ffbd4f19e0c8d754d499b7e6453c84ef" translate="yes" xml:space="preserve">
          <source>When merging an annotated (and possibly signed) tag, Git always creates a merge commit even if a fast-forward merge is possible, and the commit message template is prepared with the tag message. Additionally, if the tag is signed, the signature check is reported as a comment in the message template. See also &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;.</source>
          <target state="translated">合并带注释（且可能已签名）的标签时，即使可能进行快速合并，Git也会始终创建合并提交，并且使用标签消息准备提交消息模板。此外，如果标记已签名，则签名检查将作为注释报告在消息模板中。另见&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe18117100b1e7049979d08b3604c39a0ff0f463" translate="yes" xml:space="preserve">
          <source>When merging notes, be more verbose. When pruning notes, report all object names whose notes are removed.</source>
          <target state="translated">合并注解时,要更加详细。修剪注解时,报告所有注解被删除的对象名称。</target>
        </trans-unit>
        <trans-unit id="2a6ffb56c555f1836377a0b4eb9f01a6db423b92" translate="yes" xml:space="preserve">
          <source>When merging notes, operate quietly.</source>
          <target state="translated">合并笔记时,要悄悄操作。</target>
        </trans-unit>
        <trans-unit id="452e3643271eefd0a90ad1d2e336613f571129ec" translate="yes" xml:space="preserve">
          <source>When merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: &quot;manual&quot; (default), &quot;ours&quot;, &quot;theirs&quot;, &quot;union&quot; and &quot;cat_sort_uniq&quot;. This option overrides the &quot;notes.mergeStrategy&quot; configuration setting. See the &quot;NOTES MERGE STRATEGIES&quot; section below for more information on each notes merge strategy.</source>
          <target state="translated">合并笔记时,使用给定的策略解决笔记冲突。识别的策略有以下几种。&quot;manual&quot;(默认),&quot;ours&quot;,&quot;theirs&quot;,&quot;union &quot;和 &quot;cat_sort_uniq&quot;。这个选项会覆盖 &quot;Notes.mergeStrategy &quot;配置设置。请参阅下面的 &quot;notes合并策略 &quot;一节,了解每个笔记合并策略的更多信息。</target>
        </trans-unit>
        <trans-unit id="a1f0170f40742ebfd5d162ab78a6fe6f60fbd4e1" translate="yes" xml:space="preserve">
          <source>When missing or is set to &lt;code&gt;default&lt;/code&gt;, many fields in the stat structure are checked to detect if a file has been modified since Git looked at it. When this configuration variable is set to &lt;code&gt;minimal&lt;/code&gt;, sub-second part of mtime and ctime, the uid and gid of the owner of the file, the inode number (and the device number, if Git was compiled to use it), are excluded from the check among these fields, leaving only the whole-second part of mtime (and ctime, if &lt;code&gt;core.trustCtime&lt;/code&gt; is set) and the filesize to be checked.</source>
          <target state="translated">当丢失或设置为 &lt;code&gt;default&lt;/code&gt; ，将检查stat结构中的许多字段，以检测自Git查看文件以来是否已修改文件。当该配置变量被设置为 &lt;code&gt;minimal&lt;/code&gt; 修改时间和的ctime，UID的，子第二部分和GID的文件的inode编号的所有者（和器件号码，如果GIT中被编译使用它），被排除在在这些字段中进行检查，仅保留mtime的整个第二部分（如果设置了 &lt;code&gt;core.trustCtime&lt;/code&gt; ，则保留 ctime ）和要检查的文件大小。</target>
        </trans-unit>
        <trans-unit id="0689b4b76e007bf9e9f69e1368a4eed9e3d9055a" translate="yes" xml:space="preserve">
          <source>When more than one pattern matches the path, a later line overrides an earlier line. This overriding is done per attribute.</source>
          <target state="translated">当有多个模式与路径匹配时,后面的一行会覆盖前面的一行。这种覆盖是按属性进行的。</target>
        </trans-unit>
        <trans-unit id="7de11bcf0fc6f31a9913abfce53b7b83c6075119" translate="yes" xml:space="preserve">
          <source>When moved lines are colored using e.g. the &lt;code&gt;diff.colorMoved&lt;/code&gt; setting, this option controls the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; how spaces are treated for details of valid modes see &lt;code&gt;--color-moved-ws&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">当移动的线被使用例如有色 &lt;code&gt;diff.colorMoved&lt;/code&gt; 设置，这个选项控制 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 空间如何为有效模式中的处理的细节见 &lt;code&gt;--color-moved-ws&lt;/code&gt; 在&lt;a href=&quot;git-diff&quot;&gt;GIT-DIFF [1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52b8058d0bfbbff70a9ce60ad478453479b9a747" translate="yes" xml:space="preserve">
          <source>When multiple patches are output, the subject prefix will instead be &quot;[PATCH n/m] &quot;. To force 1/1 to be added for a single patch, use &lt;code&gt;-n&lt;/code&gt;. To omit patch numbers from the subject, use &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">当输出多个音色时，主题前缀将改为&amp;ldquo; [PATCH n / m]&amp;rdquo;。要强制为单个补丁添加1/1，请使用 &lt;code&gt;-n&lt;/code&gt; 。要从主题中省略补丁号，请使用 &lt;code&gt;-N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1cdd3c7b73eb4476790691d3f8180aaaecc09ec" translate="yes" xml:space="preserve">
          <source>When multiple working trees are used, most of files in $GIT_DIR are per-worktree with a few known exceptions. All files under &lt;code&gt;common&lt;/code&gt; however will be shared between all working trees.</source>
          <target state="translated">当使用多个工作树时，$ GIT_DIR中的大多数文件都是每个工作树，但有一些已知的例外。但是，所有 &lt;code&gt;common&lt;/code&gt; 目录下的所有文件都将在所有工作树之间共享。</target>
        </trans-unit>
        <trans-unit id="dea6d60865820d20f017799a5c24231f89c30494" translate="yes" xml:space="preserve">
          <source>When neither the command-line nor the configuration specify what to push, the default behavior is used, which corresponds to the &lt;code&gt;simple&lt;/code&gt; value for &lt;code&gt;push.default&lt;/code&gt;: the current branch is pushed to the corresponding upstream branch, but as a safety measure, the push is aborted if the upstream branch does not have the same name as the local one.</source>
          <target state="translated">当命令行和配置均未指定要推送的内容时，将使用默认行为，该行为对应于 &lt;code&gt;push.default&lt;/code&gt; 的 &lt;code&gt;simple&lt;/code&gt; 值。default：将当前分支推送到相应的上游分支，但作为安全措施，使用push如果上游分支与本地分支的名称不同，则将中止。</target>
        </trans-unit>
        <trans-unit id="60de604c8e6be170ca14a17caf3d8c66cf8e4c1f" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, &lt;code&gt;stash@{0}&lt;/code&gt; is assumed, otherwise &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; must be a reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">如果未给出 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; ，则假定为 &lt;code&gt;stash@{0}&lt;/code&gt; ，否则， &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 必须是 &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 形式的引用。</target>
        </trans-unit>
        <trans-unit id="1cb728a038f1c7e17113ec68844d5bac04accdd7" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; argument is given from the command line, &lt;code&gt;git push&lt;/code&gt; behaves as if each &amp;lt;value&amp;gt; of this variable is given as &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">当从命令行中没有给出 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 参数时， &lt;code&gt;git push&lt;/code&gt; 的行为就像该变量的每个&amp;lt;value&amp;gt;都以 &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt; 的形式给出一样。</target>
        </trans-unit>
        <trans-unit id="a166fc08fc71ee0e3d700a37b70f8845fb53d565" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--whitespace&lt;/code&gt; flag is given from the command line, this configuration item is used as the default.</source>
          <target state="translated">如果 &lt;code&gt;--whitespace&lt;/code&gt; 未给出--whitespace标志，则此配置项用作默认值。</target>
        </trans-unit>
        <trans-unit id="b29755631cf67968424c24b41012b3c14a5bc20f" translate="yes" xml:space="preserve">
          <source>When no refspec was given on the command line, then &lt;code&gt;git pull&lt;/code&gt; uses the refspec from the configuration or &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt;. In such cases, the following rules apply:</source>
          <target state="translated">如果在命令行上未提供 &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; ，则 &lt;code&gt;git pull&lt;/code&gt; 使用配置或$ GIT_DIR / remotes / &amp;lt;origin&amp;gt;中的refspec。在这种情况下，以下规则适用：</target>
        </trans-unit>
        <trans-unit id="feee7e6efffd7b04e5558aa779c91bc6a7b795bd" translate="yes" xml:space="preserve">
          <source>When no remote is specified (via -r) the &lt;code&gt;HEAD&lt;/code&gt; branch from CVS is imported to the &lt;code&gt;origin&lt;/code&gt; branch within the Git repository, as &lt;code&gt;HEAD&lt;/code&gt; already has a special meaning for Git. When a remote is specified the &lt;code&gt;HEAD&lt;/code&gt; branch is named remotes/&amp;lt;remote&amp;gt;/master mirroring &lt;code&gt;git clone&lt;/code&gt; behaviour. Use this option if you want to import into a different branch.</source>
          <target state="translated">如果未指定任何远程（通过-r），则CVS 的 &lt;code&gt;HEAD&lt;/code&gt; 分支将导入到Git存储库中的 &lt;code&gt;origin&lt;/code&gt; 分支，因为 &lt;code&gt;HEAD&lt;/code&gt; 对Git已经具有特殊含义。指定一个远程对象后， &lt;code&gt;HEAD&lt;/code&gt; 分支将命名为remotes / &amp;lt;remote&amp;gt; / master镜像 &lt;code&gt;git clone&lt;/code&gt; 行为。如果要导入到其他分支，请使用此选项。</target>
        </trans-unit>
        <trans-unit id="ac03f302c1aadb048fb52d65d000d2a5006af96e" translate="yes" xml:space="preserve">
          <source>When no remote is specified, by default the &lt;code&gt;origin&lt;/code&gt; remote will be used, unless there&amp;rsquo;s an upstream branch configured for the current branch.</source>
          <target state="translated">如果未指定任何远程，默认情况下将使用 &lt;code&gt;origin&lt;/code&gt; 远程，除非为当前分支配置了上游分支。</target>
        </trans-unit>
        <trans-unit id="d52e3dbbfef371828cf1a5d65a8a3d7860fbbc07" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for pushing. It also overrides &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing from branch &amp;lt;name&amp;gt;. When you pull from one place (e.g. your upstream) and push to another place (e.g. your own publishing repository), you would want to set &lt;code&gt;remote.pushDefault&lt;/code&gt; to specify the remote to push to for all branches, and use this option to override it for a specific branch.</source>
          <target state="translated">在分支&amp;lt;名称&amp;gt;上时，它将覆盖 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 以进行推送。它还会覆盖 &lt;code&gt;remote.pushDefault&lt;/code&gt; 以从分支&amp;lt;名称&amp;gt;进行推送。当您从一个地方（例如上游）拉出并推送到另一个地方（例如您自己的发布存储库）时，您需要设置 &lt;code&gt;remote.pushDefault&lt;/code&gt; 以指定要推送到所有分支的远程，并使用此选项覆盖对于特定的分支。</target>
        </trans-unit>
        <trans-unit id="2c5d62eaf7dc4c0abb09284bfc14bacce3f382aa" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it tells &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; which remote to fetch from/push to. The remote to push to may be overridden with &lt;code&gt;remote.pushDefault&lt;/code&gt; (for all branches). The remote to push to, for the current branch, may be further overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt;. If no remote is configured, or if you are not on any branch, it defaults to &lt;code&gt;origin&lt;/code&gt; for fetching and &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing. Additionally, &lt;code&gt;.&lt;/code&gt; (a period) is the current local repository (a dot-repository), see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;'s final note below.</source>
          <target state="translated">在分支&amp;lt;name&amp;gt;上时，它告诉 &lt;code&gt;git fetch&lt;/code&gt; 和 &lt;code&gt;git push&lt;/code&gt; 从哪个远程获取/推送到。推送到的遥控器可能会被 &lt;code&gt;remote.pushDefault&lt;/code&gt; （对于所有分支）覆盖。对于当前分支，要推送到的远程对象可能会被 &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; 进一步覆盖。如果没有远程配置，或者如果你没有任何分支，则默认为 &lt;code&gt;origin&lt;/code&gt; 的获取和 &lt;code&gt;remote.pushDefault&lt;/code&gt; 推。此外， &lt;code&gt;.&lt;/code&gt; （句点）是当前的本地存储库（点存储库），请参见 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 的最后注释。</target>
        </trans-unit>
        <trans-unit id="99875f2b6ac5843dc20c0934eb9cdf10f7711c8e" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;fsmonitor valid&quot; bit for the paths. See section &quot;File System Monitor&quot; below for more information.</source>
          <target state="translated">当指定了其中一个标志时,不会更新路径中记录的对象名称,而是设置和解除路径的 &quot;fsmonitor valid &quot;位。相反,这些选项会设置和取消设置路径的 &quot;fsmonitor valid &quot;位。更多信息请参见下面的 &quot;文件系统监视器 &quot;一节。</target>
        </trans-unit>
        <trans-unit id="095b3a1631077463d64190b5c04e9903f37eec26" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;skip-worktree&quot; bit for the paths. See section &quot;Skip-worktree bit&quot; below for more information.</source>
          <target state="translated">当指定这些标志之一时,不会更新路径中记录的对象名称。相反,这些选项会设置和取消设置路径的 &quot;skip-worktree &quot;位。更多信息请参见下面的 &quot;跳过工作树位 &quot;一节。</target>
        </trans-unit>
        <trans-unit id="6e8f4e10b13b6ff83d83df5063d58c36d64a87b8" translate="yes" xml:space="preserve">
          <source>When one or more &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; are specified explicitly (whether on the command line or via &lt;code&gt;--stdin&lt;/code&gt;), it can be either a single pattern, or a pair of such pattern separated by a colon &quot;:&quot; (this means that a ref name cannot have a colon in it). A single pattern &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is just a shorthand for &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">当显式指定一个或多个 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 时（无论是在命令行上还是通过 &lt;code&gt;--stdin&lt;/code&gt; ），它可以是单个模式，也可以是一对这样的模式，并用冒号&amp;ldquo;：&amp;rdquo;分隔（这意味着ref名称中不能包含冒号）。单个模式 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 只是 &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="9a9b16c534806b7638cc46892a28dd173752ed8c" translate="yes" xml:space="preserve">
          <source>When packing a blob fast-import always attempts to deltify against the last blob written. Unless specifically arranged for by the frontend, this will probably not be a prior version of the same file, so the generated delta will not be the smallest possible. The resulting packfile will be compressed, but will not be optimal.</source>
          <target state="translated">当打包一个blob时,fast-import总是试图对照最后写入的blob进行deltify。除非前台特别安排,否则这可能不是同一文件的先前版本,所以生成的delta不会是最小的。生成的packfile会被压缩,但不会是最佳的。</target>
        </trans-unit>
        <trans-unit id="76e4bf1d99930055a44aa05818b2c065730f60bb" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-paths&lt;/code&gt;.</source>
          <target state="translated">当传递给 &lt;code&gt;init&lt;/code&gt; 或 &lt;code&gt;clone&lt;/code&gt; 时,此正则表达式将保留为配置键。有关 &lt;code&gt;--ignore-paths&lt;/code&gt; 的描述，请参见 &lt;code&gt;fetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6a3308486ea0114e28423fc585e726bdfefa0d3" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-refs&lt;/code&gt;.</source>
          <target state="translated">当传递给 &lt;code&gt;init&lt;/code&gt; 或 &lt;code&gt;clone&lt;/code&gt; 时,此正则表达式将保留为配置键。有关 &lt;code&gt;--ignore-refs&lt;/code&gt; 的描述，请参见 &lt;code&gt;fetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="247954c989ece2f916f72b869f8bb1eb7f01f09e" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">当传递给 &lt;code&gt;init&lt;/code&gt; 或 &lt;code&gt;clone&lt;/code&gt; 时,此正则表达式将保留为配置键。有关 &lt;code&gt;--include-paths&lt;/code&gt; 的描述，请参见 &lt;code&gt;fetch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="701b3c119f368819101d8af88b842359e5cb7ac8" translate="yes" xml:space="preserve">
          <source>When paths are given, show them (note that this isn&amp;rsquo;t really raw pathnames, but rather a list of patterns to match). Otherwise implicitly uses the root level of the tree as the sole path argument.</source>
          <target state="translated">给定路径后，显示它们（请注意，这实际上不是原始路径名，而是要匹配的模式列表）。否则，隐式使用树的根级别作为唯一路径参数。</target>
        </trans-unit>
        <trans-unit id="a12bc3537fe67daac72917848a655d5078c91711" translate="yes" xml:space="preserve">
          <source>When pathspec is given on the command line, commit the contents of the files that match the pathspec without recording the changes already added to the index. The contents of these files are also staged for the next commit on top of what have been staged before.</source>
          <target state="translated">当命令行给出pathspec时,提交符合pathspec的文件内容,而不记录已经添加到索引中的更改。这些文件的内容也会在下一次提交时,在之前的缓存上进行缓存。</target>
        </trans-unit>
        <trans-unit id="1a6dc462ca36ebe8779cf750259e000c162a076a" translate="yes" xml:space="preserve">
          <source>When pathspec is given to &lt;code&gt;git stash push&lt;/code&gt;, the new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</source>
          <target state="translated">当给 &lt;code&gt;git stash push&lt;/code&gt; 提供pathspec时，新的stash条目仅记录与pathspec匹配的文件的修改状态。然后，索引条目和工作树文件也仅针对这些文件回滚到HEAD中的状态，而与pathspec不匹配的文件将完整保留。</target>
        </trans-unit>
        <trans-unit id="20284d20320c7f9cdd342728ed75cf98e12a1b6c" translate="yes" xml:space="preserve">
          <source>When possible, &lt;code&gt;pack-objects&lt;/code&gt; tries to reuse existing on-disk deltas to avoid having to search for new ones on the fly. This is an important optimization for serving fetches, because it means the server can avoid inflating most objects at all and just send the bytes directly from disk. This optimization can&amp;rsquo;t work when an object is stored as a delta against a base which the receiver does not have (and which we are not already sending). In that case the server &quot;breaks&quot; the delta and has to find a new one, which has a high CPU cost. Therefore it&amp;rsquo;s important for performance that the set of objects in on-disk delta relationships match what a client would fetch.</source>
          <target state="translated">在可能的情况下， &lt;code&gt;pack-objects&lt;/code&gt; 尝试重用现有的磁盘增量，以避免在运行中寻找新的增量。对于服务提取来说，这是一项重要的优化，因为这意味着服务器可以完全避免膨胀大多数对象，而直接从磁盘发送字节。当将对象存储为相对于接收者没有（并且我们尚未发送）的基准的增量时，此优化将无法进行。在这种情况下，服务器&amp;ldquo;破坏&amp;rdquo;增量并必须找到一个新的CPU，这将导致CPU成本高昂。因此，对磁盘而言，增量差异关系中的对象集必须与客户端获取的内容相匹配对于性能而言非常重要。</target>
        </trans-unit>
        <trans-unit id="a5d1e2c9c76493f4d0a607592b15388eabc93e4e" translate="yes" xml:space="preserve">
          <source>When present, it will also copy the value of &lt;code&gt;submodule.$name.update&lt;/code&gt;. This command does not alter existing information in .git/config. You can then customize the submodule clone URLs in .git/config for your local setup and proceed to &lt;code&gt;git submodule update&lt;/code&gt;; you can also just use &lt;code&gt;git submodule update --init&lt;/code&gt; without the explicit &lt;code&gt;init&lt;/code&gt; step if you do not intend to customize any submodule locations.</source>
          <target state="translated">如果存在，它还将复制 &lt;code&gt;submodule.$name.update&lt;/code&gt; 的值。此命令不会更改.git / config中的现有信息。然后，您可以在.git / config中为本地设置自定义子模块克隆URL，然后继续进行 &lt;code&gt;git submodule update&lt;/code&gt; ；如果您不打算自定义任何子模块位置，则也可以只使用 &lt;code&gt;git submodule update --init&lt;/code&gt; 而不使用显式的 &lt;code&gt;init&lt;/code&gt; 步骤。</target>
        </trans-unit>
        <trans-unit id="fb5aacfd35a68a879acea2ba6edf150f79c935f9" translate="yes" xml:space="preserve">
          <source>When pushing to a remote that is different from the remote you normally pull from, work as &lt;code&gt;current&lt;/code&gt;. This is the safest option and is suited for beginners.</source>
          <target state="translated">当推入与您通常从其拔出的遥控器不同的遥控器时，请以 &lt;code&gt;current&lt;/code&gt; 工作。这是最安全的选择，适合初学者。</target>
        </trans-unit>
        <trans-unit id="f99e4f9643f5e033d51557f2aab4b69c000e9e23" translate="yes" xml:space="preserve">
          <source>When pushing, request the remote server to update refs in a single atomic transaction. If successful, all refs will be updated, or none will. If the remote side does not support this capability, the push will fail.</source>
          <target state="translated">推送时,请求远程服务器在一个原子事务中更新 refs。如果成功,所有的 refs 都会被更新,或者没有。如果远端不支持这个功能,推送将失败。</target>
        </trans-unit>
        <trans-unit id="24e8d08f5bcd393fd98db303b5bfff38ae149335" translate="yes" xml:space="preserve">
          <source>When reading the &lt;code&gt;core.repositoryformatversion&lt;/code&gt; variable, a git implementation which supports version 1 MUST also read any configuration keys found in the &lt;code&gt;extensions&lt;/code&gt; section of the configuration file.</source>
          <target state="translated">在读取 &lt;code&gt;core.repositoryformatversion&lt;/code&gt; 变量时，支持版本1的git实现也必须读取配置文件的 &lt;code&gt;extensions&lt;/code&gt; 部分中找到的所有配置键。</target>
        </trans-unit>
        <trans-unit id="d49438aa2f88cdc57a3b7001a0406b8491bbad55" translate="yes" xml:space="preserve">
          <source>When reading trailers, there can be whitespaces after the token, the separator and the value. There can also be whitespaces inside the token and the value. The value may be split over multiple lines with each subsequent line starting with whitespace, like the &quot;folding&quot; in RFC 822.</source>
          <target state="translated">读取预告片时,标记、分隔符和值后面可能会有空格。在标记和值内也可以有空格。值可以分成多行,每一行都以空格开始,就像RFC 822中的 &quot;折叠&quot;。</target>
        </trans-unit>
        <trans-unit id="c808cfa1e01223bf6f90ceb1edbec20a1b9b3321" translate="yes" xml:space="preserve">
          <source>When reading, the values are read from the system, global and repository local configuration files by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--local&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt; and &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to read from only that location (see &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;).</source>
          <target state="translated">读取时，默认情况下会从系统，全局和存储库本地配置文件中读取值，并且选项 &lt;code&gt;--system&lt;/code&gt; ，-- &lt;code&gt;--global&lt;/code&gt; ，-- &lt;code&gt;--local&lt;/code&gt; ，-- &lt;code&gt;--worktree&lt;/code&gt; 和 &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; 可用于告知命令仅从该位置读取（请参阅&lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="35058e27fd0502a5cbd6b1225fdbfa49a5b7004d" translate="yes" xml:space="preserve">
          <source>When recording the commit, append a line that says &quot;(cherry picked from commit &amp;hellip;​)&quot; to the original commit message in order to indicate which commit this change was cherry-picked from. This is done only for cherry picks without conflicts. Do not use this option if you are cherry-picking from your private branch because the information is useless to the recipient. If on the other hand you are cherry-picking between two publicly visible branches (e.g. backporting a fix to a maintenance branch for an older release from a development branch), adding this information can be useful.</source>
          <target state="translated">在记录提交时，请在原始提交消息后添加一行``（从提交中提取樱桃...）''，以表明此更改是从哪个提交中挑选出来的。这仅适用于没有冲突的樱桃采摘。如果您是从私人分支中挑选樱桃，请不要使用此选项，因为该信息对收件人毫无用处。另一方面，如果您在两个公开可见的分支之间进行挑剔（例如，将修补程序向后移植到维护分支，以便从开发分支中发布较旧的版本），则添加此信息可能会很有用。</target>
        </trans-unit>
        <trans-unit id="ccaf8e1c6e304870dc79f0b6ba9e209459375c19" translate="yes" xml:space="preserve">
          <source>When recording your own work, the contents of modified files in your working tree are temporarily stored to a staging area called the &quot;index&quot; with &lt;code&gt;git add&lt;/code&gt;. A file can be reverted back, only in the index but not in the working tree, to that of the last commit with &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt;, which effectively reverts &lt;code&gt;git add&lt;/code&gt; and prevents the changes to this file from participating in the next commit. After building the state to be committed incrementally with these commands, &lt;code&gt;git commit&lt;/code&gt; (without any pathname parameter) is used to record what has been staged so far. This is the most basic form of the command. An example:</source>
          <target state="translated">记录自己的作品时，使用 &lt;code&gt;git add&lt;/code&gt; 将工作树中已修改文件的内容临时存储到称为&amp;ldquo;索引&amp;rdquo;的登台区域中。可以使用 &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt; 将文件仅在索引中但不能在工作树中还原为最后一次提交的文件，可以有效地还原 &lt;code&gt;git add&lt;/code&gt; 并防止对该文件的更改参与到git下一次提交。在使用这些命令建立要递增 &lt;code&gt;git commit&lt;/code&gt; 的状态之后，使用git commit（不带任何pathname参数）来记录到目前为止已执行的操作。这是命令的最基本形式。一个例子：</target>
        </trans-unit>
        <trans-unit id="35cd60207a202ee3a283a2d8b2047b148806b6b3" translate="yes" xml:space="preserve">
          <source>When remote and local branch are both named &quot;test&quot;:</source>
          <target state="translated">当远程和本地分支都命名为 &quot;test &quot;时。</target>
        </trans-unit>
        <trans-unit id="2eefb86cce90a60f5ab07db6487aa99da3ba4333" translate="yes" xml:space="preserve">
          <source>When rename/copy is involved, &lt;code&gt;file1&lt;/code&gt; and &lt;code&gt;file2&lt;/code&gt; show the name of the source file of the rename/copy and the name of the file that rename/copy produces, respectively.</source>
          <target state="translated">当涉及重命名/复制时， &lt;code&gt;file1&lt;/code&gt; 和 &lt;code&gt;file2&lt;/code&gt; 分别显示重命名/复制的源文件的名称和重命名/复制生成的文件的名称。</target>
        </trans-unit>
        <trans-unit id="3475b12f6b8e32c3a9c4f496f5f906d95460d63d" translate="yes" xml:space="preserve">
          <source>When repacking with delta islands the delta window tends to get clogged with candidates that are forbidden by the config. Repacking with a big --window helps (and doesn&amp;rsquo;t take as long as it otherwise might because we can reject some object pairs based on islands before doing any computation on the content).</source>
          <target state="translated">当重新打包delta岛时，delta窗口会被配置所禁止的候选者阻塞。用大--window进行重新包装会有所帮助（并且不需要花那么长的时间，因为在对内容进行任何计算之前，我们可以基于岛拒绝某些对象对）。</target>
        </trans-unit>
        <trans-unit id="9f9b14ed67913870e54606a7e4140c245c13e689" translate="yes" xml:space="preserve">
          <source>When restoring files in the working tree from the index, use stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">从索引还原工作树中的文件时，对于未合并的路径，请使用阶段＃2（ &lt;code&gt;ours&lt;/code&gt; ）或＃3（ &lt;code&gt;theirs&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f350add778942f50c4b0b2f8798762ec9d6fc205" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, &lt;code&gt;--merge&lt;/code&gt; or &lt;code&gt;--conflict&lt;/code&gt; is specified. Unmerged paths on the working tree are left alone.</source>
          <target state="translated">从索引还原工作树上的文件时，如果存在未合并的条目并且 &lt;code&gt;--conflict&lt;/code&gt; 指定 &lt;code&gt;--ours&lt;/code&gt; ，-- &lt;code&gt;--theirs&lt;/code&gt; ，-- &lt;code&gt;--merge&lt;/code&gt; 或--conflict，请不要中止该操作。工作树上未合并的路径将保留。</target>
        </trans-unit>
        <trans-unit id="84ac309392e16a1f3dcc1a792805de1c5dea7161" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths.</source>
          <target state="translated">当从索引中恢复工作树上的文件时,在未合并的路径中重新创建冲突的合并。</target>
        </trans-unit>
        <trans-unit id="0bde8e78161181c9b276b62a2eb0f3a92764228a" translate="yes" xml:space="preserve">
          <source>When retrieving svn commits into Git (as part of &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, or &lt;code&gt;dcommit&lt;/code&gt; operations), look for the first &lt;code&gt;From:&lt;/code&gt; line or &lt;code&gt;Signed-off-by&lt;/code&gt; trailer in the log message and use that as the author string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273a9228c51e5936f4d142f339102a2bbdd8c3b8" translate="yes" xml:space="preserve">
          <source>When retrieving svn commits into Git (as part of &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, or &lt;code&gt;dcommit&lt;/code&gt; operations), look for the first &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line in the log message and use that as the author string.</source>
          <target state="translated">当将svn commits检索到Git中（作为 &lt;code&gt;fetch&lt;/code&gt; ， &lt;code&gt;rebase&lt;/code&gt; 或 &lt;code&gt;dcommit&lt;/code&gt; 操作的一部分）时，请在日志消息中查找第一个 &lt;code&gt;From:&lt;/code&gt; 或 &lt;code&gt;Signed-off-by:&lt;/code&gt; by- ：行并将其用作作者字符串。</target>
        </trans-unit>
        <trans-unit id="78d119701beb340fc1dce20129de3c1bebaf8055" translate="yes" xml:space="preserve">
          <source>When revision range specifiers are used to limit the annotation, lines that have not changed since the range boundary (either the commit v2.6.18 or the most recent commit that is more than 3 weeks old in the above example) are blamed for that range boundary commit.</source>
          <target state="translated">当使用修订范围指定符来限制注解时,自范围边界以来没有变化的行(无论是上例中的提交v2.6.18还是超过3周的最近一次提交)将被归咎于该范围边界提交。</target>
        </trans-unit>
        <trans-unit id="802f2e7848870b44ce9f04fb441477cd05447e6c" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;) and this variable is set to &lt;code&gt;true&lt;/code&gt;, Git automatically copies your notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;, but see &quot;notes.rewriteRef&quot; below.</source>
          <target state="translated">当使用&amp;lt;command&amp;gt;进行重写提交（当前为 &lt;code&gt;amend&lt;/code&gt; 或 &lt;code&gt;rebase&lt;/code&gt; ）并且此变量设置为 &lt;code&gt;true&lt;/code&gt; 时，Git会自动将您的笔记从原始副本复制到重写的提交中。默认为 &lt;code&gt;true&lt;/code&gt; ，但请参见下面的&amp;ldquo; notes.rewriteRef&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b9c5c034bfc575d885230ecf217359276486be76" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;), if this variable is &lt;code&gt;false&lt;/code&gt;, git will not copy notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;. See also &quot;&lt;code&gt;notes.rewriteRef&lt;/code&gt;&quot; below.</source>
          <target state="translated">当使用&amp;lt;command&amp;gt;重写提交时（当前是 &lt;code&gt;amend&lt;/code&gt; 或 &lt;code&gt;rebase&lt;/code&gt; ），如果此变量为 &lt;code&gt;false&lt;/code&gt; ，则git不会将笔记从原始副本复制到重写的提交中。默认为 &lt;code&gt;true&lt;/code&gt; 。另请参见下面的&amp;ldquo; &lt;code&gt;notes.rewriteRef&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0528b909a801bc351dbefd46a3e339150f63bb9d" translate="yes" xml:space="preserve">
          <source>When rewriting commits, which notes to copy from the original to the rewritten commit. Must be a colon-delimited list of refs or globs.</source>
          <target state="translated">当重写提交时,要从原提交中复制哪些注释到重写后的提交中。必须是以冒号分隔的参考文献或globs列表。</target>
        </trans-unit>
        <trans-unit id="777967b1b1cbeac1b786b4e659ef472d75c08474" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument.</source>
          <target state="translated">从项目的子目录运行时，可以告诉它排除目录之外的更改，并使用此选项显示相对于它的路径名。当您不在子目录中（例如，在裸仓库中）时，可以通过指定&amp;lt;path&amp;gt;作为参数来命名要相对于哪个子目录进行输出。</target>
        </trans-unit>
        <trans-unit id="1526deda1d1c171ba9bb8aedb499ef46fa3558ac" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument. &lt;code&gt;--no-relative&lt;/code&gt; can be used to countermand both &lt;code&gt;diff.relative&lt;/code&gt; config option and previous &lt;code&gt;--relative&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27ca634a7183f46a280e82c3af06c829ca10b89" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory.</source>
          <target state="translated">当从子目录运行时,命令通常输出相对于当前目录的路径。这个选项会强制输出相对于项目顶层目录的路径。</target>
        </trans-unit>
        <trans-unit id="ed0ff11c4a5dd052209fd6d888b93db83b1003f1" translate="yes" xml:space="preserve">
          <source>When run in a directory that does not have &quot;.git&quot; repository directory, Git tries to find such a directory in the parent directories to find the top of the working tree, but by default it does not cross filesystem boundaries. This environment variable can be set to true to tell Git not to stop at filesystem boundaries. Like &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt;, this will not affect an explicit repository directory set via &lt;code&gt;GIT_DIR&lt;/code&gt; or on the command line.</source>
          <target state="translated">当在没有&amp;ldquo; .git&amp;rdquo;存储库目录的目录中运行时，Git会尝试在父目录中找到这样的目录以查找工作树的顶部，但是默认情况下它不会跨越文件系统边界。可以将此环境变量设置为true，以告诉Git不要在文件系统边界停止。像 &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt; 一样，这不会影响通过 &lt;code&gt;GIT_DIR&lt;/code&gt; 或在命令行上设置的显式存储库目录。</target>
        </trans-unit>
        <trans-unit id="9ce1b9e20fc14e8e8925879039b8daf3d52acd6a" translate="yes" xml:space="preserve">
          <source>When running the command with &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-m&lt;/code&gt; options, the merge result may need to overwrite paths that are not tracked in the current branch. The command usually refuses to proceed with the merge to avoid losing such a path. However this safety valve sometimes gets in the way. For example, it often happens that the other branch added a file that used to be a generated file in your branch, and the safety valve triggers when you try to switch to that branch after you ran &lt;code&gt;make&lt;/code&gt; but before running &lt;code&gt;make clean&lt;/code&gt; to remove the generated file. This option tells the command to read per-directory exclude file (usually &lt;code&gt;.gitignore&lt;/code&gt;) and allows such an untracked but explicitly ignored file to be overwritten.</source>
          <target state="translated">当使用 &lt;code&gt;-u&lt;/code&gt; 和 &lt;code&gt;-m&lt;/code&gt; 选项运行命令时，合并结果可能需要覆盖当前分支中未跟踪的路径。该命令通常拒绝继续合并，以免丢失此类路径。但是，此安全阀有时会妨碍您的操作。例如，它常常发生其他分支还说，曾经在你的分支生成的文件的文件，和安全阀触发器，当您尝试切换到该分支你跑后 &lt;code&gt;make&lt;/code&gt; ，但在运行之前 &lt;code&gt;make clean&lt;/code&gt; 去除产生文件。此选项告诉命令读取每个目录的排除文件（通常是 &lt;code&gt;.gitignore&lt;/code&gt; ），并允许覆盖这种未跟踪但被显式忽略的文件。</target>
        </trans-unit>
        <trans-unit id="df426fd8f20937aff52c156a03a07b3202618140" translate="yes" xml:space="preserve">
          <source>When sending a patch this way, most often you are sending your own patch, so in addition to the &quot;&lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt;&quot; marker you should omit &lt;code&gt;From:&lt;/code&gt; and &lt;code&gt;Date:&lt;/code&gt; lines from the patch file. The patch title is likely to be different from the subject of the discussion the patch is in response to, so it is likely that you would want to keep the Subject: line, like the example above.</source>
          <target state="translated">以这种方式发送补丁程序时，通常是发送自己的补丁程序，因此，除了&amp;ldquo; &lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt; &amp;rdquo;标记外，还应 &lt;code&gt;From:&lt;/code&gt; 补丁程序文件中省略From：和 &lt;code&gt;Date:&lt;/code&gt; 行。补丁标题可能与补丁所针对的讨论主题不同，因此，您可能希望保留Subject：行，如上例所示。</target>
        </trans-unit>
        <trans-unit id="85b26b0293721642a3d3ba409cae09a21a570f47" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always highlight matches. When &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use color only when the output is written to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">设置为 &lt;code&gt;always&lt;/code&gt; 时，始终突出显示匹配项。如果为 &lt;code&gt;false&lt;/code&gt; （或 &lt;code&gt;never&lt;/code&gt; ），则永不。设置为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;auto&lt;/code&gt; 时，仅在将输出写入终端时使用颜色。如果未设置，则使用 &lt;code&gt;color.ui&lt;/code&gt; 的值（默认情况下为 &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dfd0a45591bf4cdb6d73f4e9b16cc039b04690be" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always use colors for interactive prompts and displays (such as those used by &quot;git-add --interactive&quot; and &quot;git-clean --interactive&quot;). When false (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use colors only when the output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">设置为 &lt;code&gt;always&lt;/code&gt; 时，始终为交互提示和显示使用颜色（例如&amp;ldquo; git-add --interactive&amp;rdquo;和&amp;ldquo; git-clean --interactive&amp;rdquo;使用的颜色）。如果为假（或 &lt;code&gt;never&lt;/code&gt; ），则永不。设置为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;auto&lt;/code&gt; 时，仅在输出到终端时才使用颜色。如果未设置，则使用 &lt;code&gt;color.ui&lt;/code&gt; 的值（默认情况下为 &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9ba7d00c9f4d532d2b9486b8c87259ed84e278f3" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;change&lt;/code&gt;, tells &lt;code&gt;git apply&lt;/code&gt; to ignore changes in whitespace, in the same way as the &lt;code&gt;--ignore-space-change&lt;/code&gt; option. When set to one of: no, none, never, false tells &lt;code&gt;git apply&lt;/code&gt; to respect all whitespace differences. See &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;.</source>
          <target state="translated">设置为 &lt;code&gt;change&lt;/code&gt; 时，告诉 &lt;code&gt;git apply&lt;/code&gt; 忽略空白中的更改，与 &lt;code&gt;--ignore-space-change&lt;/code&gt; 选项相同。当设置为以下之一时：不，不，从不，false告诉 &lt;code&gt;git apply&lt;/code&gt; 于尊重所有空白差异。参见&lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d6e4c3c7b2c6d56efae11b1e0ed0dcb5ce2357b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;merges&lt;/code&gt;, rebase using &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">当设置为 &lt;code&gt;merges&lt;/code&gt; ，使用变基 &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; ，以便本地合并提交被包括在变基（见&lt;a href=&quot;git-rebase&quot;&gt;GIT-变基[1]&lt;/a&gt;的详细信息）。</target>
        </trans-unit>
        <trans-unit id="3726def44fed6d7863a8f10abeef80361e6f2701" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), rebase with the &lt;code&gt;--preserve-merges&lt;/code&gt; option passed to &lt;code&gt;git rebase&lt;/code&gt; so that locally created merge commits will not be flattened.</source>
          <target state="translated">当设置为 &lt;code&gt;preserve&lt;/code&gt; （不推荐使用 &lt;code&gt;merges&lt;/code&gt; 时），请使用 &lt;code&gt;--preserve-merges&lt;/code&gt; 选项传递给 &lt;code&gt;git rebase&lt;/code&gt; 进行重新设置基准,以便本地创建的合并提交不会被展平。</target>
        </trans-unit>
        <trans-unit id="14ded32327ec4343589fd7082ddc1f7fdc8962f6" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git reset&lt;/code&gt; will default to the &lt;code&gt;--quiet&lt;/code&gt; option.</source>
          <target state="translated">设置为true时， &lt;code&gt;git reset&lt;/code&gt; 将默认为 &lt;code&gt;--quiet&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="01f095efe30e9d32fee48e094d88f96d4eba1bad" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git-rerere&lt;/code&gt; updates the index with the resulting contents after it cleanly resolves conflicts using previously recorded resolution. Defaults to false.</source>
          <target state="translated">设置为true时， &lt;code&gt;git-rerere&lt;/code&gt; 使用先前记录的分辨率完全解决冲突后，将使用结果内容更新索引。默认为false。</target>
        </trans-unit>
        <trans-unit id="e2cc234f1ab166d2852bd6878a576806a19d5021" translate="yes" xml:space="preserve">
          <source>When set to true, a clone of this submodule will be performed as a shallow clone (with a history depth of 1) unless the user explicitly asks for a non-shallow clone.</source>
          <target state="translated">当设置为 &quot;true &quot;时,除非用户明确要求非浅层克隆,否则该子模块的克隆将以浅层克隆的方式进行(历史深度为1)。</target>
        </trans-unit>
        <trans-unit id="6b72e60e4df8bc4b62a55c38ddf1b7b574998e6d" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run merge on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92df8026c7e3a5d595e452302b48399c0fa7807" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="translated">设置为true时，在操作开始之前自动创建一个临时存储项，并在操作结束之后应用它。这意味着您可以在肮脏的工作树上运行rebase。但是，请谨慎使用：成功重新设置基准之后的最终存储应用程序可能会导致非平凡的冲突。可以通过&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;的 &lt;code&gt;--no-autostash&lt;/code&gt; 和 &lt;code&gt;--autostash&lt;/code&gt; 选项覆盖此选项。默认为false。</target>
        </trans-unit>
        <trans-unit id="454e58d95a3a4a743aeef0859eac2b9c78e6f07a" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any local tags that no longer exist on the remote if pruning is activated in general via &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt;, &lt;code&gt;fetch.prune&lt;/code&gt; or &lt;code&gt;--prune&lt;/code&gt;. Overrides &lt;code&gt;fetch.pruneTags&lt;/code&gt; settings, if any.</source>
          <target state="translated">设置为true时，默认情况下，如果通常通过 &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; ， &lt;code&gt;fetch.prune&lt;/code&gt; 或 &lt;code&gt;--prune&lt;/code&gt; 激活了修剪，则默认情况下从此远程获取还将删除远程上不再存在的所有本地标记。覆盖 &lt;code&gt;fetch.pruneTags&lt;/code&gt; 设置（如果有）。</target>
        </trans-unit>
        <trans-unit id="2f08cdfbf2bbbb5ba49961d7515ae4f7f92a166e" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any remote-tracking references that no longer exist on the remote (as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line). Overrides &lt;code&gt;fetch.prune&lt;/code&gt; settings, if any.</source>
          <target state="translated">设置为true时，默认情况下从此远程获取还将删除远程上不再存在的所有远程跟踪引用（就像在命令行上给出了 &lt;code&gt;--prune&lt;/code&gt; 选项一样）。覆盖 &lt;code&gt;fetch.prune&lt;/code&gt; 设置（如果有）。</target>
        </trans-unit>
        <trans-unit id="5739477a3b9489a88899be9378f898520709209f" translate="yes" xml:space="preserve">
          <source>When set to true, git-receive-pack will advertise the push options capability to its clients. False by default.</source>
          <target state="translated">当设置为 &quot;true &quot;时,git-receive-pack 会向客户宣传推送选项的功能。默认为False。</target>
        </trans-unit>
        <trans-unit id="af12eb66ec26d00e256f0fbfcc7125aeb108aa2e" translate="yes" xml:space="preserve">
          <source>When set to true, this remote will be used to fetch promisor objects.</source>
          <target state="translated">当设置为 &quot;true &quot;时,这个远程将被用来获取承诺者对象。</target>
        </trans-unit>
        <trans-unit id="384788e82f8977bea09d8463e5bbfca26ec8a699" translate="yes" xml:space="preserve">
          <source>When set, the fetch or receive will abort in the case of a malformed object or a link to a nonexistent object. In addition, various other issues are checked for, including legacy issues (see &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;), and potential security issues like the existence of a &lt;code&gt;.GIT&lt;/code&gt; directory or a malicious &lt;code&gt;.gitmodules&lt;/code&gt; file (see the release notes for v2.2.1 and v2.17.1 for details). Other sanity and security checks may be added in future releases.</source>
          <target state="translated">设置此选项后，如果对象格式错误或指向不存在的对象的链接，则提取或接收将中止。此外，还会检查其他各种问题，包括遗留问题（请参阅 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ）以及潜在的安全问题，例如是否存在 &lt;code&gt;.GIT&lt;/code&gt; 目录或恶意的 &lt;code&gt;.gitmodules&lt;/code&gt; 文件（请参阅v2的发行说明）。 2.1和v2.17.1了解详情）。其他健全性和安全性检查可能会在将来的版本中添加。</target>
        </trans-unit>
        <trans-unit id="51a9809b150b3fa600feb6c1ea57e78e8de9e787" translate="yes" xml:space="preserve">
          <source>When showing &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;porcelain&lt;/code&gt; status output, print the filename verbatim and terminate the entries with NUL, instead of LF. If no format is given, implies the &lt;code&gt;--porcelain&lt;/code&gt; output format. Without the &lt;code&gt;-z&lt;/code&gt; option, filenames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">当显示 &lt;code&gt;short&lt;/code&gt; 或 &lt;code&gt;porcelain&lt;/code&gt; 状态输出时，逐字打印文件名，并以NUL（而不是LF）终止输入。如果未给出格式，则表示 &lt;code&gt;--porcelain&lt;/code&gt; 输出格式。如果不使用 &lt;code&gt;-z&lt;/code&gt; 选项，则引用带有&amp;ldquo;不寻常&amp;rdquo;字符的文件名，如配置变量 &lt;code&gt;core.quotePath&lt;/code&gt; 所述（参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="43f2e6f1690661b84f31283fe1b400a9df885029" translate="yes" xml:space="preserve">
          <source>When showing a change that involves a rename or a copy, &lt;code&gt;--stat&lt;/code&gt; output formats the pathnames compactly by combining common prefix and suffix of the pathnames. For example, a change that moves &lt;code&gt;arch/i386/Makefile&lt;/code&gt; to &lt;code&gt;arch/x86/Makefile&lt;/code&gt; while modifying 4 lines will be shown like this:</source>
          <target state="translated">显示涉及重命名或副本的更改时，-- &lt;code&gt;--stat&lt;/code&gt; 输出通过组合路径名的公共前缀和后缀来紧凑地格式化路径名。例如，在修改4行的同时将 &lt;code&gt;arch/i386/Makefile&lt;/code&gt; 移至 &lt;code&gt;arch/x86/Makefile&lt;/code&gt; 的更改将如下所示：</target>
        </trans-unit>
        <trans-unit id="5d4332d6cfe825bd00a3bfef76e9ffde728a5dde" translate="yes" xml:space="preserve">
          <source>When showing commit messages, also show notes which are stored in the given ref. The ref must be fully qualified. If the given ref does not exist, it is not an error but means that no notes should be printed.</source>
          <target state="translated">当显示提交消息时,也会显示存储在给定 ref 中的注释。ref必须是完全限定的。如果给定的 ref 不存在,这不是错误,而是意味着不应该打印注释。</target>
        </trans-unit>
        <trans-unit id="43020b05da28d5245a5572e708a459c7bb4d40bf" translate="yes" xml:space="preserve">
          <source>When showing object names, prefix them with &lt;code&gt;^&lt;/code&gt; and strip &lt;code&gt;^&lt;/code&gt; prefix from the object names that already have one.</source>
          <target state="translated">显示对象名称时，请在它们前面加上 &lt;code&gt;^&lt;/code&gt; ,并从已经有一个的对象名称中删除 &lt;code&gt;^&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="bf158ec030a04af48fd84ff99f4cdef61dbc802c" translate="yes" xml:space="preserve">
          <source>When showing the value of &amp;lt;name&amp;gt; as a symbolic ref, try to shorten the value, e.g. from &lt;code&gt;refs/heads/master&lt;/code&gt; to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">将&amp;lt;name&amp;gt;的值显示为符号ref时，请尝试将其值缩短，例如从 &lt;code&gt;refs/heads/master&lt;/code&gt; 改为 &lt;code&gt;master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d07871fea9de7a0886062f3dfa8bbc506d97b667" translate="yes" xml:space="preserve">
          <source>When shown by &lt;code&gt;git diff-tree -c&lt;/code&gt;, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents). When shown by &lt;code&gt;git diff-files -c&lt;/code&gt;, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka &quot;our version&quot;, file2 is stage 3 aka &quot;their version&quot;).</source>
          <target state="translated">当由 &lt;code&gt;git diff-tree -c&lt;/code&gt; 显示时，它将合并提交的父项与合并结果进行比较（即file1..fileN是父项）。当由 &lt;code&gt;git diff-files -c&lt;/code&gt; 显示时，它将两个未解析的合并父对象与工作树文件进行比较（即file1是阶段2 aka&amp;ldquo;我们的版本&amp;rdquo;，file2是阶段3 aka&amp;ldquo;其版本&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="aea42e2933202e5e3d5f69076d6bebeb378dfcd9" translate="yes" xml:space="preserve">
          <source>When some commits have been skipped (using &quot;git bisect skip&quot;), then the bisection algorithm is the same for step 1) to 3). But then we use roughly the following steps:</source>
          <target state="translated">当跳过了一些提交(使用 &quot;git bisect skip&quot;),那么第1)到第3)步的二分算法是一样的。但我们大致使用以下步骤。</target>
        </trans-unit>
        <trans-unit id="4192528671a22eca45fcad6bb5614a7ec165a5d4" translate="yes" xml:space="preserve">
          <source>When specified one or more times, &lt;code&gt;-L&lt;/code&gt; restricts annotation to the requested lines.</source>
          <target state="translated">如果指定一次或多次，则 &lt;code&gt;-L&lt;/code&gt; 将注释限制为所请求的行。</target>
        </trans-unit>
        <trans-unit id="75acd7ee44b0e77c6b233d3615dca447d4cfdc8c" translate="yes" xml:space="preserve">
          <source>When specifying the -v option the format used is:</source>
          <target state="translated">当指定-v选项时,使用的格式是:。</target>
        </trans-unit>
        <trans-unit id="3b090cc032845d040434a6c212a06329d4b2d7ed" translate="yes" xml:space="preserve">
          <source>When subcommands such as &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;rename&lt;/code&gt;, and &lt;code&gt;remove&lt;/code&gt; can&amp;rsquo;t find the remote in question, the exit status is &lt;code&gt;2&lt;/code&gt;. When the remote already exists, the exit status is &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0550af8039db48de114d18431bb7375cee83b91b" translate="yes" xml:space="preserve">
          <source>When switching branches with &lt;code&gt;--merge&lt;/code&gt;, staged changes may be lost.</source>
          <target state="translated">当使用 &lt;code&gt;--merge&lt;/code&gt; 切换分支时，分阶段的更改可能会丢失。</target>
        </trans-unit>
        <trans-unit id="1f4fa4b7e00510c39cb24519dad3b49f07cff89d" translate="yes" xml:space="preserve">
          <source>When switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">当切换分支时,如果您对一个或多个文件进行了本地修改,而这些修改在当前分支和您要切换的分支之间是不同的,那么为了在上下文中保留您的修改,命令将拒绝切换分支。但是,如果使用这个选项,当前分支、工作树内容和新分支之间会进行三方合并,您将在新分支上。</target>
        </trans-unit>
        <trans-unit id="7b0d58bb9103d272bfd260e85d337e6780ed225d" translate="yes" xml:space="preserve">
          <source>When switching branches, proceed even if the index or the working tree differs from &lt;code&gt;HEAD&lt;/code&gt;. This is used to throw away local changes.</source>
          <target state="translated">切换分支时，即使索引或工作树不同于 &lt;code&gt;HEAD&lt;/code&gt; ，也要继续进行。这用于丢弃本地更改。</target>
        </trans-unit>
        <trans-unit id="c0e1144ec53aca779c8724f81a0ba0a804f51a81" translate="yes" xml:space="preserve">
          <source>When the &quot;-C&quot; option is used, the original contents of modified files, and deleted files (and also unmodified files, if the &quot;--find-copies-harder&quot; option is used) are considered as candidates of the source files in rename/copy operation. If the input were like these filepairs, that talk about a modified file fileY and a newly created file file0:</source>
          <target state="translated">当使用&quot;-C &quot;选项时,在进行重命名/复制操作时,修改过的文件和删除过的文件(如果使用&quot;--find-copies-harder &quot;选项,也包括未修改过的文件)的原始内容被视为源文件的候选文件。如果输入的文件是这样的文件对,那就说明一个被修改的文件Y和一个新创建的文件0。</target>
        </trans-unit>
        <trans-unit id="f6565c60ff0e235a6b049473d40ff8e72074a702" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; argument is a branch name, the &lt;code&gt;--detach&lt;/code&gt; option can be used to detach &lt;code&gt;HEAD&lt;/code&gt; at the tip of the branch (&lt;code&gt;git checkout
&amp;lt;branch&amp;gt;&lt;/code&gt; would check out that branch without detaching &lt;code&gt;HEAD&lt;/code&gt;).</source>
          <target state="translated">当 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 参数是一个分支名， &lt;code&gt;--detach&lt;/code&gt; 选项可用于分离 &lt;code&gt;HEAD&lt;/code&gt; 在分支的前端部（ &lt;code&gt;git checkout &amp;lt;branch&amp;gt;&lt;/code&gt; 将检查出不拆卸该分支 &lt;code&gt;HEAD&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="588cf4af82a088b4d8241fca9de08188511b35c3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--aggressive&lt;/code&gt; option is supplied, &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; will be invoked with the &lt;code&gt;-f&lt;/code&gt; flag, which in turn will pass &lt;code&gt;--no-reuse-delta&lt;/code&gt; to &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This will throw away any existing deltas and re-compute them, at the expense of spending much more time on the repacking.</source>
          <target state="translated">当 &lt;code&gt;--aggressive&lt;/code&gt; 选项被提供时，&lt;a href=&quot;git-repack&quot;&gt;GIT-重新包装[1]&lt;/a&gt;将与被调用 &lt;code&gt;-f&lt;/code&gt; 标志，这反过来将通过 &lt;code&gt;--no-reuse-delta&lt;/code&gt; 到&lt;a href=&quot;git-pack-objects&quot;&gt;GIT中包对象[1] &lt;/a&gt;。这将丢弃所有现有的增量并重新计算它们，但要花费更多的时间进行重新包装。</target>
        </trans-unit>
        <trans-unit id="36c732582138b85601314513444f94ba223454f7" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--auto-merge&lt;/code&gt; is given, meld will merge all non-conflicting parts automatically, highlight the conflicting parts and wait for user decision. Setting &lt;code&gt;mergetool.meld.useAutoMerge&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; tells Git to unconditionally use the &lt;code&gt;--auto-merge&lt;/code&gt; option with &lt;code&gt;meld&lt;/code&gt;. Setting this value to &lt;code&gt;auto&lt;/code&gt; makes git detect whether &lt;code&gt;--auto-merge&lt;/code&gt; is supported and will only use &lt;code&gt;--auto-merge&lt;/code&gt; when available. A value of &lt;code&gt;false&lt;/code&gt; avoids using &lt;code&gt;--auto-merge&lt;/code&gt; altogether, and is the default value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82879b1b4c41ea78abef977470f6f223214f239a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--stdin&lt;/code&gt; option is provided, the patterns are read from standard in as a newline-delimited list instead of from the arguments.</source>
          <target state="translated">当 &lt;code&gt;--stdin&lt;/code&gt; 提供选项，模式从标准作为新行分隔的列表，而不是从参数读取。</target>
        </trans-unit>
        <trans-unit id="0e72b560677fc7dbf879d4b64bab949efbe4ffc6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-l&lt;/code&gt; option is used, format changes to</source>
          <target state="translated">使用 &lt;code&gt;-l&lt;/code&gt; 选项时，格式更改为</target>
        </trans-unit>
        <trans-unit id="2d7535050bbd171bed81a20302444843893d883d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-z&lt;/code&gt; option is given, pathnames are printed as is and without any quoting and lines are terminated with a NUL (ASCII 0x00) byte.</source>
          <target state="translated">当 &lt;code&gt;-z&lt;/code&gt; 选项，则路径名被打印为是，没有任何引用和线端接一个NUL（ASCII 0&amp;times;00）字节。</target>
        </trans-unit>
        <trans-unit id="e231e06fa3f3b3606e814466b6e12bf27e65315d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;.gitattributes&lt;/code&gt; file is missing from the work tree, the path in the index is used as a fall-back. During checkout process, &lt;code&gt;.gitattributes&lt;/code&gt; in the index is used and then the file in the working tree is used as a fall-back.</source>
          <target state="translated">当工作树中缺少 &lt;code&gt;.gitattributes&lt;/code&gt; 文件时，索引中的路径将用作后备路径。在签出过程中，将使用索引中的 &lt;code&gt;.gitattributes&lt;/code&gt; ，然后将工作树中的文件用作后备。</target>
        </trans-unit>
        <trans-unit id="ca6fe469ff13b0a4412dea9bd34db705e00a71db" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;LESS&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;FRX&lt;/code&gt; (if &lt;code&gt;LESS&lt;/code&gt; environment variable is set, Git does not change it at all). If you want to selectively override Git&amp;rsquo;s default setting for &lt;code&gt;LESS&lt;/code&gt;, you can set &lt;code&gt;core.pager&lt;/code&gt; to e.g. &lt;code&gt;less -S&lt;/code&gt;. This will be passed to the shell by Git, which will translate the final command to &lt;code&gt;LESS=FRX less -S&lt;/code&gt;. The environment does not set the &lt;code&gt;S&lt;/code&gt; option but the command line does, instructing less to truncate long lines. Similarly, setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;less -+F&lt;/code&gt; will deactivate the &lt;code&gt;F&lt;/code&gt; option specified by the environment from the command-line, deactivating the &quot;quit if one screen&quot; behavior of &lt;code&gt;less&lt;/code&gt;. One can specifically activate some flags for particular commands: for example, setting &lt;code&gt;pager.blame&lt;/code&gt; to &lt;code&gt;less -S&lt;/code&gt; enables line truncation only for &lt;code&gt;git blame&lt;/code&gt;.</source>
          <target state="translated">当未设置 &lt;code&gt;LESS&lt;/code&gt; 环境变量时，Git会将其设置为 &lt;code&gt;FRX&lt;/code&gt; （如果设置了 &lt;code&gt;LESS&lt;/code&gt; 环境变量，则Git根本不会更改它）。如果你想选择覆写Git的默认设置 &lt;code&gt;LESS&lt;/code&gt; ，你可以设置 &lt;code&gt;core.pager&lt;/code&gt; 到如 &lt;code&gt;less -S&lt;/code&gt; 。这将由Git传递给Shell，它将最终命令转换为 &lt;code&gt;LESS=FRX less -S&lt;/code&gt; 。环境未设置 &lt;code&gt;S&lt;/code&gt; 选项，但命令行设置了该选项，减少了截断长行的指示。同样，如果设置 &lt;code&gt;core.pager&lt;/code&gt; 到 &lt;code&gt;less -+F&lt;/code&gt; 将停用 &lt;code&gt;F&lt;/code&gt; 由环境从命令行指定的选项，停用了 &lt;code&gt;less&lt;/code&gt; 的&amp;ldquo;如果一个屏幕退出&amp;rdquo;的行为。可以专门为某些命令激活一些标志：例如，将 &lt;code&gt;pager.blame&lt;/code&gt; 设置为 &lt;code&gt;less -S&lt;/code&gt; 仅对 &lt;code&gt;git blame&lt;/code&gt; 启用行截断。</target>
        </trans-unit>
        <trans-unit id="74ad9f83ee4c2323b6a50919a4a444bb844e349c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable is changed, the file system monitor is added to or removed from the index the next time a command reads the index. When &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; are used, the file system monitor is immediately added to or removed from the index.</source>
          <target state="translated">更改 &lt;code&gt;core.fsmonitor&lt;/code&gt; 配置变量后，下次命令读取索引时，会将文件系统监视器添加到索引中或从索引中删除。使用 &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; ，文件系统监视器将立即添加到索引中或从索引中删除。</target>
        </trans-unit>
        <trans-unit id="a4c9cc7c80e5659747cb4b3bf0914ba1addde698" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable is changed, the untracked cache is added to or removed from the index the next time a command reads the index; while when &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; are used, the untracked cache is immediately added to or removed from the index.</source>
          <target state="translated">更改 &lt;code&gt;core.untrackedCache&lt;/code&gt; 配置变量后，下次命令读取索引时，会将未跟踪的高速缓存添加到索引中或从索引中删除；当使用 &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; ，立即将未跟踪的高速缓存添加到索引或从索引中删除。</target>
        </trans-unit>
        <trans-unit id="a212ca612f0b7b9b082dffe71078dd396d414402" translate="yes" xml:space="preserve">
          <source>When the attribute &lt;code&gt;ident&lt;/code&gt; is set for a path, Git replaces &lt;code&gt;$Id$&lt;/code&gt; in the blob object with &lt;code&gt;$Id:&lt;/code&gt;, followed by the 40-character hexadecimal blob object name, followed by a dollar sign &lt;code&gt;$&lt;/code&gt; upon checkout. Any byte sequence that begins with &lt;code&gt;$Id:&lt;/code&gt; and ends with &lt;code&gt;$&lt;/code&gt; in the worktree file is replaced with &lt;code&gt;$Id$&lt;/code&gt; upon check-in.</source>
          <target state="translated">为路径设置属性 &lt;code&gt;ident&lt;/code&gt; 时，Git用 &lt;code&gt;$Id$&lt;/code&gt; 替换blob对象中的 &lt;code&gt;$Id:&lt;/code&gt; ，后跟40个字符的十六进制blob对象名，然后在结帐时加上美元符号 &lt;code&gt;$&lt;/code&gt; 。与开头的字节序列 &lt;code&gt;$Id:&lt;/code&gt; 和结束与 &lt;code&gt;$&lt;/code&gt; 在worktree文件被替换 &lt;code&gt;$Id$&lt;/code&gt; 在办理登机手续。</target>
        </trans-unit>
        <trans-unit id="c5a78c9a8f92224d51a41a84dbc93a853baeb6f6" translate="yes" xml:space="preserve">
          <source>When the browser, specified by options or configuration variables, is not among the supported ones, then the corresponding &lt;code&gt;browser.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration variable will be looked up. If this variable exists then &lt;code&gt;git web--browse&lt;/code&gt; will treat the specified tool as a custom command and will use a shell eval to run the command with the URLs passed as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa514f01de77ed627378917f2aa0b40cefa8c9a0" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the files and directories to be cleaned, and goes into its interactive command loop.</source>
          <target state="translated">当命令进入交互模式后,会显示出要清理的文件和目录,并进入其交互命令循环。</target>
        </trans-unit>
        <trans-unit id="8e767c7023b00ca52d4fb770ab49ce4dc284f987" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the output of the &lt;code&gt;status&lt;/code&gt; subcommand, and then goes into its interactive command loop.</source>
          <target state="translated">当命令进入交互模式时，它将显示 &lt;code&gt;status&lt;/code&gt; 子命令的输出，然后进入其交互命令循环。</target>
        </trans-unit>
        <trans-unit id="e95952399796aad65deb415e39c303153d01cdf9" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the current directory relative to the top-level directory.</source>
          <target state="translated">当从子目录调用命令时,显示当前目录相对于顶层目录的路径。</target>
        </trans-unit>
        <trans-unit id="45506eccf72696bf6e0287a6eeda327142bb0f41" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the top-level directory relative to the current directory (typically a sequence of &quot;../&quot;, or an empty string).</source>
          <target state="translated">当从子目录中调用命令时,显示顶层目录相对于当前目录的路径(通常是&quot;./&quot;的序列,或一个空字符串)。</target>
        </trans-unit>
        <trans-unit id="609d76b7287e730d5e5fcae1b57a1cde4d02d1ae" translate="yes" xml:space="preserve">
          <source>When the command is run without pathspec, it errors out, instead of deinit-ing everything, to prevent mistakes.</source>
          <target state="translated">当命令在没有pathspec的情况下运行时,会出错,而不是deinit-ing一切,以防止错误。</target>
        </trans-unit>
        <trans-unit id="2ebded60d45ed8776b0324d8d2138df90f552a15" translate="yes" xml:space="preserve">
          <source>When the command line does not specify what to push with &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; arguments or &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--mirror&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt; options, the command finds the default &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; by consulting &lt;code&gt;remote.*.push&lt;/code&gt; configuration, and if it is not found, honors &lt;code&gt;push.default&lt;/code&gt; configuration to decide what to push (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for the meaning of &lt;code&gt;push.default&lt;/code&gt;).</source>
          <target state="translated">当命令行未使用 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; &lt;code&gt;--mirror&lt;/code&gt; &amp;gt; ...自变量或 &lt;code&gt;--all&lt;/code&gt; ，-- mirror，-- &lt;code&gt;--tags&lt;/code&gt; 选项指定要推送的内容时，该命令将通过参考 &lt;code&gt;remote.*.push&lt;/code&gt; 配置查找默认的 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; ，然后如果未找到，则使用 &lt;code&gt;push.default&lt;/code&gt; 配置来决定要推送的内容（有关 &lt;code&gt;push.default&lt;/code&gt; 的含义，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4f61ade639e58b8586884fe92cb9eea816606ac2" translate="yes" xml:space="preserve">
          <source>When the command line does not specify where to push with the &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument, &lt;code&gt;branch.*.remote&lt;/code&gt; configuration for the current branch is consulted to determine where to push. If the configuration is missing, it defaults to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">当命令行未使用 &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; 参数指定推送位置时，将查询当前分支的 &lt;code&gt;branch.*.remote&lt;/code&gt; 配置以确定推送位置。如果缺少配置，则默认为 &lt;code&gt;origin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dd963bd8e58b7ff2b11f8f622df35ecbcf28d58" translate="yes" xml:space="preserve">
          <source>When the commit diffs differ, &lt;code&gt;git range-diff&lt;/code&gt; recreates the original diffs' coloring, and adds outer -/+ diff markers with the &lt;strong&gt;background&lt;/strong&gt; being red/green to make it easier to see e.g. when there was a change in what exact lines were added.</source>
          <target state="translated">当提交差异不同时， &lt;code&gt;git range-diff&lt;/code&gt; 会重新创建原始差异的颜色，并添加外部-/ +差异标记，&lt;strong&gt;背景&lt;/strong&gt;为红色/绿色，以便于查看，例如，当添加的确切行发生更改时。</target>
        </trans-unit>
        <trans-unit id="3625aba84b870871330cdfd48d8779c4e4badb58" translate="yes" xml:space="preserve">
          <source>When the commit log message begins with &quot;squash! &amp;hellip;​&quot; (or &quot;fixup! &amp;hellip;​&quot;), and there is already a commit in the todo list that matches the same &lt;code&gt;...&lt;/code&gt;, automatically modify the todo list of rebase -i so that the commit marked for squashing comes right after the commit to be modified, and change the action of the moved commit from &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;squash&lt;/code&gt; (or &lt;code&gt;fixup&lt;/code&gt;). A commit matches the &lt;code&gt;...&lt;/code&gt; if the commit subject matches, or if the &lt;code&gt;...&lt;/code&gt; refers to the commit&amp;rsquo;s hash. As a fall-back, partial matches of the commit subject work, too. The recommended way to create fixup/squash commits is by using the &lt;code&gt;--fixup&lt;/code&gt;/&lt;code&gt;--squash&lt;/code&gt; options of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">当提交日志消息以&amp;ldquo; squash！&amp;hellip;&amp;rdquo;（或&amp;ldquo; fixup！&amp;hellip;``&amp;rdquo;）开头，并且在待办事项列表中已经存在与相同 &lt;code&gt;...&lt;/code&gt; 匹配的提交时，自动修改rebase -i的待办事项列表。这样，标记为压扁的提交就在要修改的提交之后出现，并将移动的提交的动作从 &lt;code&gt;pick&lt;/code&gt; 更改为 &lt;code&gt;squash&lt;/code&gt; （或 &lt;code&gt;fixup&lt;/code&gt; ）。如果提交主题匹配，或者 &lt;code&gt;...&lt;/code&gt; 引用提交的哈希，则提交与 &lt;code&gt;...&lt;/code&gt; 匹配。作为后备，提交主题的部分匹配也起作用。创建fixup / squash提交的推荐方法是使用&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;的 &lt;code&gt;--fixup&lt;/code&gt; / &lt;code&gt;--squash&lt;/code&gt; 选项。。</target>
        </trans-unit>
        <trans-unit id="777196d17b1a10c66d0cd105e5fb66da2363f7b1" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.partialclone&lt;/code&gt; is set, it indicates that the repo was created with a partial clone (or later performed a partial fetch) and that the remote may have omitted sending certain unwanted objects. Such a remote is called a &quot;promisor remote&quot; and it promises that all such omitted objects can be fetched from it in the future.</source>
          <target state="translated">设置配置密钥 &lt;code&gt;extensions.partialclone&lt;/code&gt; 时，它表示该回购是使用部分克隆创建的（或稍后执行部分提取的操作），并且遥控器可能已省略了发送某些不需要的对象的操作。这种远程称为&amp;ldquo;承诺远程&amp;rdquo;，它承诺将来可以从中获取所有这些省略的对象。</target>
        </trans-unit>
        <trans-unit id="ef73607bec133cc1d32aaf64deafc8c72104731d" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.preciousObjects&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, objects in the repository MUST NOT be deleted (e.g., by &lt;code&gt;git-prune&lt;/code&gt; or &lt;code&gt;git repack -d&lt;/code&gt;).</source>
          <target state="translated">当配置键 &lt;code&gt;extensions.preciousObjects&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 时，不得删除存储库中的对象（例如，通过 &lt;code&gt;git-prune&lt;/code&gt; 或 &lt;code&gt;git repack -d&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e23e26ad367e6b915821bbb7b38753fa6fd4c240" translate="yes" xml:space="preserve">
          <source>When the current working directory is below the repository directory print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">当当前工作目录在仓库目录下时打印 &quot;true&quot;,否则打印 &quot;false&quot;。</target>
        </trans-unit>
        <trans-unit id="8a7aa53d7bbe6bfa657a2a1bb84359882384d7fa" translate="yes" xml:space="preserve">
          <source>When the current working directory is inside the work tree of the repository print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">当当前工作目录在仓库的工作树内时打印 &quot;true&quot;,否则打印 &quot;false&quot;。</target>
        </trans-unit>
        <trans-unit id="e614fb1c074d0b3ebd865c7756d786dc01074ea4" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called to generate diffs, and Git does not use its builtin diff machinery. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7dc6a4dcd86a8d725c2332772df83ad820f427" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called, instead of the diff invocation described above. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="translated">设置环境变量 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 时，将调用由其命名的程序，而不是上述的diff调用。对于添加，删除或修改的路径，使用7个参数调用 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ec4de571b6827b1e0107c62834d6f8cf9f50bba2" translate="yes" xml:space="preserve">
          <source>When the git-rebase command is run, it will first execute a &quot;pre-rebase&quot; hook if one exists. You can use this hook to do sanity checks and reject the rebase if it isn&amp;rsquo;t appropriate. Please see the template pre-rebase hook script for an example.</source>
          <target state="translated">运行git-rebase命令时，如果存在，它将首先执行&amp;ldquo; pre-rebase&amp;rdquo;钩子。您可以使用此挂钩进行健全性检查，如果不合适的话，可以拒绝重新设置基准。有关示例，请参阅模板变基前挂钩脚本。</target>
        </trans-unit>
        <trans-unit id="4663df00f4cd516023be3e887d8ecce789e72f00" translate="yes" xml:space="preserve">
          <source>When the history involves criss-cross merges, there can be more than one &lt;code&gt;best&lt;/code&gt; common ancestor for two commits. For example, with this topology:</source>
          <target state="translated">当历史涉及纵横交错的合并时，两次提交可能有多个 &lt;code&gt;best&lt;/code&gt; 共同祖先。例如，使用此拓扑：</target>
        </trans-unit>
        <trans-unit id="58beafa5cea14c3b99014fb314d938b1ee9fac65" translate="yes" xml:space="preserve">
          <source>When the man viewer, specified by the &lt;code&gt;man.viewer&lt;/code&gt; configuration variables, is not among the supported ones, then the corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration variable will be looked up. If this variable exists then the specified tool will be treated as a custom command and a shell eval will be used to run the command with the man page passed as arguments.</source>
          <target state="translated">如果由 &lt;code&gt;man.viewer&lt;/code&gt; 配置变量指定的man查看器不在受支持的对象中，则将查找对应的 &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 配置变量。如果存在此变量，则将指定的工具视为自定义命令，并且将使用shell eval将手册页作为参数传递来运行该命令。</target>
        </trans-unit>
        <trans-unit id="d01c091e9d01b5baf9f294a1d7b9c823d7d014bc" translate="yes" xml:space="preserve">
          <source>When the output goes to a terminal, it is color-coded by default, just like regular &lt;code&gt;git diff&lt;/code&gt;'s output. In addition, the first line (adding a commit) is green, the last line (deleting a commit) is red, the second line (with a perfect match) is yellow like the commit header of &lt;code&gt;git
show&lt;/code&gt;'s output, and the third line colors the old commit red, the new one green and the rest like &lt;code&gt;git show&lt;/code&gt;'s commit header.</source>
          <target state="translated">当输出到达终端时，默认情况下会使用彩色编码，就像常规 &lt;code&gt;git diff&lt;/code&gt; 的输出一样。此外，第一行（添加提交）为绿色，最后一行（删除提交）为红色，第二行（具有完美匹配）为黄色，就像 &lt;code&gt;git show&lt;/code&gt; 的输出的提交标头一样，第三行一行为旧提交红色，新提交绿色，其余为 &lt;code&gt;git show&lt;/code&gt; 的提交标头。</target>
        </trans-unit>
        <trans-unit id="ecf68ce55bda2542529810833e005e7f157f71c2" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. &lt;code&gt;--no-3way&lt;/code&gt; can be used to override am.threeWay configuration variable. For more information, see am.threeWay in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">如果补丁不能完全适用，则如果该补丁记录了它应该应用于的Blob的身份，并且我们可以在本地使用这些Blob，则退回到三路合并。 &lt;code&gt;--no-3way&lt;/code&gt; 可用于覆盖am.threeWay配置变量。有关更多信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]中的&lt;/a&gt; am.threeWay 。</target>
        </trans-unit>
        <trans-unit id="28728fcf386b485f532ec99285643062f0405ba5" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to, and we have those blobs available locally, possibly leaving the conflict markers in the files in the working tree for the user to resolve. This option implies the &lt;code&gt;--index&lt;/code&gt; option, and is incompatible with the &lt;code&gt;--reject&lt;/code&gt; and the &lt;code&gt;--cached&lt;/code&gt; options.</source>
          <target state="translated">如果补丁不能完全适用，则如果该补丁记录了它应该应用于的Blob的标识，则退回到三路合并，并且这些Blob在本地可用，可能会将冲突标记保留在工作树的文件中供用户解决。此选项暗含 &lt;code&gt;--index&lt;/code&gt; 选项，并且与 &lt;code&gt;--reject&lt;/code&gt; 和 &lt;code&gt;--cached&lt;/code&gt; 选项不兼容。</target>
        </trans-unit>
        <trans-unit id="bdd1b4760c591dff915e966378bff929405d28b1" translate="yes" xml:space="preserve">
          <source>When the push is complete, outputs one or more &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; or &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; lines to indicate success or failure of each pushed ref. The status report output is terminated by a blank line. The option field &amp;lt;why&amp;gt; may be quoted in a C style string if it contains an LF.</source>
          <target state="translated">推送完成后，输出一个或多个 &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; 或 &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; 线表示每个推送参考的成功或失败。状态报告输出以空白行终止。如果选项字段&amp;lt;why&amp;gt;包含LF，则可以在C样式字符串中加引号。</target>
        </trans-unit>
        <trans-unit id="c36826b0bb47b2400e28127fc2b6b138c228a63f" translate="yes" xml:space="preserve">
          <source>When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the &lt;code&gt;+&lt;/code&gt; sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.</source>
          <target state="translated">当已知要提取的远程分支定期重绕并重新设置基准时，可以预期其新提示将不会是其先前提示的后代（上次获取时存储在您的远程跟踪分支中）。您可能希望使用 &lt;code&gt;+&lt;/code&gt; 号表示此类分支需要非快进更新。无法通过这种行为来确定或声明分支将在存储库中可用；拉取用户只需知道这是分支的预期使用模式即可。</target>
        </trans-unit>
        <trans-unit id="c2d02d0fdbdd6b68f91184ab0fd8a5fcfd84e982" translate="yes" xml:space="preserve">
          <source>When the repository is bare print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">当存储库为裸露时打印 &quot;true&quot;,否则打印 &quot;false&quot;。</target>
        </trans-unit>
        <trans-unit id="4881892c9231f2a8cbf0d32abf5995af521026ca" translate="yes" xml:space="preserve">
          <source>When the repository is shallow print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">当库位较浅时打印 &quot;true&quot;,否则打印 &quot;false&quot;。</target>
        </trans-unit>
        <trans-unit id="37826a890a4b64bdd1230276a23bd80630675ca5" translate="yes" xml:space="preserve">
          <source>When the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; has the commit at a tip of a ref that is different from the ref you have locally, you can use the &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; syntax, to have its local name, a colon &lt;code&gt;:&lt;/code&gt;, and its remote name.</source>
          <target state="translated">当以 &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 命名的存储库在与本地引用不同的ref的提示处提交时，可以使用 &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; 语法，以其本地名称冒号 &lt;code&gt;:&lt;/code&gt; ，和它的远程名称。</target>
        </trans-unit>
        <trans-unit id="a7fe7f8247bda757ca8d697055bcfe0913ae2caf" translate="yes" xml:space="preserve">
          <source>When the repository to clone from is on a local machine, this flag bypasses the normal &quot;Git aware&quot; transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories. The files under &lt;code&gt;.git/objects/&lt;/code&gt; directory are hardlinked to save space when possible.</source>
          <target state="translated">当要从中进行克隆的存储库位于本地计算机上时，此标志将绕过常规的&amp;ldquo; Git感知&amp;rdquo;传输机制，并通过在对象和引用目录下创建HEAD以及所有内容的副本来克隆存储库。 &lt;code&gt;.git/objects/&lt;/code&gt; 目录下的文件经过硬链接以尽可能节省空间。</target>
        </trans-unit>
        <trans-unit id="87edb2bef2f28c0f63de7720d331d50db0279e94" translate="yes" xml:space="preserve">
          <source>When the repository to clone is on the local machine, instead of using hard links, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to share the objects with the source repository. The resulting repository starts out without any object of its own.</source>
          <target state="translated">当要克隆的存储库位于本地计算机上时，而不是使用硬链接，而是自动设置 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; 与源存储库共享对象。生成的存储库开始时没有其自己的任何对象。</target>
        </trans-unit>
        <trans-unit id="e18b845f941d21aaf5232c387f67cb23d0a4e759" translate="yes" xml:space="preserve">
          <source>When the result of a &lt;code&gt;git bisect&lt;/code&gt; is a non-merge commit, you should normally be able to discover the problem by examining just that commit. Developers can make this easy by breaking their changes into small self-contained commits. That won&amp;rsquo;t help in the case above, however, because the problem isn&amp;rsquo;t obvious from examination of any single commit; instead, a global view of the development is required. To make matters worse, the change in semantics in the problematic function may be just one small part of the changes in the upper line of development.</source>
          <target state="translated">当 &lt;code&gt;git bisect&lt;/code&gt; 的结果是非合并提交时，通常应该可以通过仅检查该提交来发现问题。开发人员可以通过将更改分成小的独立提交来简化此过程。但是，这在上面的情况下无济于事，因为从检查任何一次提交来看问题都不明显；取而代之的是，需要对发展情况有一个全局的认识。更糟糕的是，问题功能中语义的更改可能只是开发上限更改的一小部分。</target>
        </trans-unit>
        <trans-unit id="57dfd8622d0e5d97d5c5344dbdac2c35010a468d" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, shared index files that were not modified since the time this variable specifies will be removed when a new shared index file is created. The value &quot;now&quot; expires all entries immediately, and &quot;never&quot; suppresses expiration altogether. The default value is &quot;2.weeks.ago&quot;. Note that a shared index file is considered modified (for the purpose of expiration) each time a new split-index file is either created based on it or read from it. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">使用拆分索引功能时，在创建新的共享索引文件时，将删除自此变量指定的时间以来未修改的共享索引文件。值&amp;ldquo;现在&amp;rdquo;立即使所有条目到期，而值&amp;ldquo;从不&amp;rdquo;则完全禁止到期。默认值为&amp;ldquo; 2.weeks.ago&amp;rdquo;。请注意，每次基于共享索引文件创建新的拆分索引文件或从中读取拆分索引文件时，都将其视为已修改（出于过期目的）。参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="887ef75c2523fd6b4da84b3a0a714f4995305746" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, this specifies the percent of entries the split index can contain compared to the total number of entries in both the split index and the shared index before a new shared index is written. The value should be between 0 and 100. If the value is 0 then a new shared index is always written, if it is 100 a new shared index is never written. By default the value is 20, so a new shared index is written if the number of entries in the split index would be greater than 20 percent of the total number of entries. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">使用拆分索引功能时，它指定在写入新的共享索引之前，拆分索引可以包含的条目数与拆分索引和共享索引中的条目总数的百分比。该值应介于0到100之间。如果该值为0，则始终写入新的共享索引；如果为100，则永远不会写入新的共享索引。默认情况下，该值为20，因此，如果拆分索引中的条目数大于条目总数的20％，则会写入新的共享索引。参见&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1631afdb92ffecd0a40ddcd8f40433691ff79d82" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt; (or just &lt;code&gt;i&lt;/code&gt;), the rebase is run in interactive mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249674ff1351f5c865508a34f368a209ce692426" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt;, the rebase is run in interactive mode.</source>
          <target state="translated">当值是 &lt;code&gt;interactive&lt;/code&gt; ，rebase以交互模式运行。</target>
        </trans-unit>
        <trans-unit id="2a8620af5de619d02cbdb1290090cf457f4270c6" translate="yes" xml:space="preserve">
          <source>When the working tree is updated, using --recurse-submodules will also recursively reset the working tree of all active submodules according to the commit recorded in the superproject, also setting the submodules' HEAD to be detached at that commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc30d1504ae5818b5ebed3f68f464e3d8d41b06" translate="yes" xml:space="preserve">
          <source>When there are approximately more than this many loose objects in the repository, &lt;code&gt;git gc --auto&lt;/code&gt; will pack them. Some Porcelain commands use this command to perform a light-weight garbage collection from time to time. The default value is 6700.</source>
          <target state="translated">当存储库中的松散对象大约超过这个数目时， &lt;code&gt;git gc --auto&lt;/code&gt; 会将它们打包。某些瓷器命令会不时使用此命令执行轻量级垃圾收集。默认值为6700。</target>
        </trans-unit>
        <trans-unit id="c316674f184677333eb7d2b00fe1f02bf0eda4b8" translate="yes" xml:space="preserve">
          <source>When there are content conflicts, the merge machinery tries to annotate each side&amp;rsquo;s conflict markers with the commits where the content came from. Since the apply backend drops the original information about the rebased commits and their parents (and instead generates new fake commits based off limited information in the generated patches), those commits cannot be identified; instead it has to fall back to a commit summary. Also, when merge.conflictStyle is set to diff3, the apply backend will use &quot;constructed merge base&quot; to label the content from the merge base, and thus provide no information about the merge base commit whatsoever.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62fefa7cb364ff9a836bef0837ac15925fecc8f2" translate="yes" xml:space="preserve">
          <source>When there are more than this many packs that are not marked with &lt;code&gt;*.keep&lt;/code&gt; file in the repository, &lt;code&gt;git gc
--auto&lt;/code&gt; consolidates them into one larger pack. The default value is 50. Setting this to 0 disables it. Setting &lt;code&gt;gc.auto&lt;/code&gt; to 0 will also disable this.</source>
          <target state="translated">如果在存储库中有很多未用 &lt;code&gt;*.keep&lt;/code&gt; 文件标记的包， &lt;code&gt;git gc --auto&lt;/code&gt; 会将它们合并为一个更大的包。默认值为50。将其设置为0将禁用它。将 &lt;code&gt;gc.auto&lt;/code&gt; 设置为0也将禁用此功能。</target>
        </trans-unit>
        <trans-unit id="a99bf9777c550eb2f6602e82876314f8cadcb15d" translate="yes" xml:space="preserve">
          <source>When there is only one argument given and it is not &lt;code&gt;--&lt;/code&gt; (e.g. &lt;code&gt;git
checkout abc&lt;/code&gt;), and when the argument is both a valid &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (e.g. a branch &lt;code&gt;abc&lt;/code&gt; exists) and a valid &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (e.g. a file or a directory whose name is &quot;abc&quot; exists), Git would usually ask you to disambiguate. Because checking out a branch is so common an operation, however, &lt;code&gt;git checkout abc&lt;/code&gt; takes &quot;abc&quot; as a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; in such a situation. Use &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; if you want to checkout these paths out of the index.</source>
          <target state="translated">当存在仅给出一个参数，它不是 &lt;code&gt;--&lt;/code&gt; （例如 &lt;code&gt;git checkout abc&lt;/code&gt; ），并且当参数是既有效 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; （例如，分支 &lt;code&gt;abc&lt;/code&gt; 存在）和一个有效的 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (例如，文件或名称为&amp;ldquo; abc&amp;rdquo;的目录），Git通常会要求您消除歧义。因为签出分支是一项常见的操作，但是，在这种情况下， &lt;code&gt;git checkout abc&lt;/code&gt; 将&amp;ldquo; abc&amp;rdquo;作为 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 。如果 &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; 索引中检出这些路径，请使用git checkout-&amp;lt;pathspec&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="3ff1d02c565a22d417998ec283b077273b716d4a" translate="yes" xml:space="preserve">
          <source>When these environment variables are set, the corresponding command-line arguments may not be used.</source>
          <target state="translated">当设置这些环境变量时,可能不会使用相应的命令行参数。</target>
        </trans-unit>
        <trans-unit id="86c4d2dcd046b538b0d9c792061f20bffd3f8c8e" translate="yes" xml:space="preserve">
          <source>When this flag is provided, the pack is read from stdin instead and a copy is then written to &amp;lt;pack-file&amp;gt;. If &amp;lt;pack-file&amp;gt; is not specified, the pack is written to objects/pack/ directory of the current Git repository with a default name determined from the pack content. If &amp;lt;pack-file&amp;gt; is not specified consider using --keep to prevent a race condition between this process and &lt;code&gt;git repack&lt;/code&gt;.</source>
          <target state="translated">提供此标志时，将改为从stdin中读取包，然后将副本写入&amp;lt;pack-file&amp;gt;。如果未指定&amp;lt;pack-file&amp;gt;，则使用默认的名称（根据包内容确定）将其写入当前Git存储库的objects / pack /目录。如果未指定&amp;lt;pack-file&amp;gt;，请考虑使用--keep来防止此进程与 &lt;code&gt;git repack&lt;/code&gt; 之间发生竞争。</target>
        </trans-unit>
        <trans-unit id="c91915e7d5f6096e68c1652d49f4ac505147354d" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the object names recorded for the paths are not updated. Instead, this option sets/unsets the &quot;assume unchanged&quot; bit for the paths. When the &quot;assume unchanged&quot; bit is on, the user promises not to change the file and allows Git to assume that the working tree file matches what is recorded in the index. If you want to change the working tree file, you need to unset the bit to tell Git. This is sometimes helpful when working with a big project on a filesystem that has very slow lstat(2) system call (e.g. cifs).</source>
          <target state="translated">当指定这个标志时,不会更新路径中记录的对象名称。相反,这个选项会设置/取消路径的 &quot;假定不变 &quot;位。当 &quot;假定不变 &quot;位开启时,用户承诺不更改文件,并允许 Git 假定工作树文件与索引中记录的内容一致。如果你想改变工作树文件,你需要取消设置该位来告诉 Git。这在处理一个大项目时,有时会很有帮助,因为这个项目的文件系统的lstat(2)系统调用速度很慢(比如cifs)。</target>
        </trans-unit>
        <trans-unit id="b1f75c6b9b1b22670befceda22525699cad697f2" translate="yes" xml:space="preserve">
          <source>When this form of &lt;code&gt;git read-tree&lt;/code&gt; returns successfully, you can see which of the &quot;local changes&quot; that you made were carried forward by running &lt;code&gt;git diff-index --cached $M&lt;/code&gt;. Note that this does not necessarily match what &lt;code&gt;git diff-index --cached $H&lt;/code&gt; would have produced before such a two tree merge. This is because of cases 18 and 19 --- if you already had the changes in $M (e.g. maybe you picked it up via e-mail in a patch form), &lt;code&gt;git diff-index
--cached $H&lt;/code&gt; would have told you about the change before this merge, but it would not show in &lt;code&gt;git diff-index --cached $M&lt;/code&gt; output after the two-tree merge.</source>
          <target state="translated">当这种形式的 &lt;code&gt;git read-tree&lt;/code&gt; 成功返回时，您可以通过运行 &lt;code&gt;git diff-index --cached $M&lt;/code&gt; 来查看进行了哪些&amp;ldquo;本地更改&amp;rdquo; 。请注意，这不一定与 &lt;code&gt;git diff-index --cached $H&lt;/code&gt; 在这样的两棵树合并之前产生的结果匹配。这是由于情况18和19 ---如果您已经在$ M中进行了更改（例如，您可能以补丁程序形式通过电子邮件将其获取了），则 &lt;code&gt;git diff-index --cached $H&lt;/code&gt; 会告诉您关于此合并之前的更改的信息，但是在两棵树合并之后，不会在 &lt;code&gt;git diff-index --cached $M&lt;/code&gt; 输出中显示。</target>
        </trans-unit>
        <trans-unit id="a7b5d3881356f9c9c7fd25660fd80f9c16873a97" translate="yes" xml:space="preserve">
          <source>When this option is specified, the behavior is as if a special &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; argument were added at the beginning of the command line, where &amp;lt;value&amp;gt; is taken to be the standard output of the specified command with any leading and trailing whitespace trimmed off.</source>
          <target state="translated">指定此选项后，行为就像在命令行的开头添加了特殊的 &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 参数一样，其中&amp;lt;value&amp;gt;被视为指定命令的标准输出，并带有任何前导和尾随空白修剪掉。</target>
        </trans-unit>
        <trans-unit id="fe0e96d95c4eefa9bfe72917d015cf48a18efcc2" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de58814133990da5a575ac12a35ef9b3b981ae4a" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves. Note that any components which are missing from the URL (e.g., there is no username in the example above) will be set to empty; if you want to provide a URL and override some attributes, provide the URL attribute first, followed by any overrides.</source>
          <target state="translated">当 &lt;code&gt;git credential&lt;/code&gt; 读取此特殊属性时，该值将解析为URL，并视为已读取其组成部分（例如， &lt;code&gt;url=https://example.com&lt;/code&gt; 的行为就好像 &lt;code&gt;protocol=https&lt;/code&gt; 和 &lt;code&gt;host=example.com&lt;/code&gt; 已提供）。这可以帮助呼叫者避免自己解析URL。请注意，URL中缺少的任何组件（例如，在上面的示例中没有用户名）将被设置为空；如果要提供URL并覆盖某些属性，请首先提供URL属性，然后再提供任何覆盖。</target>
        </trans-unit>
        <trans-unit id="882eafec7b82da90c1fd3ae7dc7040457d013cf9" translate="yes" xml:space="preserve">
          <source>When trace files are written to a target directory, they will be named according to the last component of the SID (optionally followed by a counter to avoid filename collisions).</source>
          <target state="translated">当跟踪文件被写入目标目录时,它们将根据SID的最后一个组件命名(可选择在后面加一个计数器以避免文件名冲突)。</target>
        </trans-unit>
        <trans-unit id="1771ffd8c74f9f0b2e623ff3c52581b28a17469b" translate="yes" xml:space="preserve">
          <source>When tracking multiple directories (using --stdlayout, --branches, or --tags options), git svn will attempt to connect to the root (or highest allowed level) of the Subversion repository. This default allows better tracking of history if entire projects are moved within a repository, but may cause issues on repositories where read access restrictions are in place. Passing &lt;code&gt;--no-minimize-url&lt;/code&gt; will allow git svn to accept URLs as-is without attempting to connect to a higher level directory. This option is off by default when only one URL/branch is tracked (it would do little good).</source>
          <target state="translated">当跟踪多个目录（使用--stdlayout，--branches或--tags选项）时，git svn将尝试连接到Subversion存储库的根目录（或允许的最高级别）。如果整个项目都在存储库中移动，则使用默认值可以更好地跟踪历史记录，但是可能会在存在读取访问限制的存储库上引起问题。传递 &lt;code&gt;--no-minimize-url&lt;/code&gt; 将允许git svn照原样接受URL，而无需尝试连接到更高级别的目录。当仅跟踪一个URL /分支时，默认情况下此选项为关闭（效果不佳）。</target>
        </trans-unit>
        <trans-unit id="442a6a05d34f849ad275ea5e7d6f50f5aafe59d9" translate="yes" xml:space="preserve">
          <source>When true, and when reachability bitmaps are enabled, pack-objects will try to send parts of the bitmapped packfile verbatim. This can reduce memory and CPU usage to serve fetches, but might result in sending a slightly larger pack. Defaults to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce35b3add797f616ba5b3be537b437a03e625f0" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;false&lt;/code&gt; unless &lt;code&gt;feature.experimental&lt;/code&gt; is enabled.</source>
          <target state="translated">如果为true，git会默认使用 &lt;code&gt;--sparse&lt;/code&gt; 在选项 &lt;code&gt;git pack-objects&lt;/code&gt; 时 &lt;code&gt;--revs&lt;/code&gt; 选项存在。该算法仅遍历出现在引入新对象的路径中的树。在计算包裹以发送小额零钱时，这可能具有显着的性能优势。但是，如果包含的提交包含某些类型的直接重命名，则可能会将额外的对象添加到打包文件。除非启用 &lt;code&gt;feature.experimental&lt;/code&gt; ,否则默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a46d4189a8b9229b7d91d54cdebfebe81ffd9ae6" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d73311a3b4a00977d7e2237078b01efb9320bfa" translate="yes" xml:space="preserve">
          <source>When true, git will include a &quot;hash cache&quot; section in the bitmap index (if one is written). This cache can be used to feed git&amp;rsquo;s delta heuristics, potentially leading to better deltas between bitmapped and non-bitmapped objects (e.g., when serving a fetch between an older, bitmapped pack and objects that have been pushed since the last gc). The downside is that it consumes 4 bytes per object of disk space. Defaults to true.</source>
          <target state="translated">如果为true，则git将在位图索引中包含&amp;ldquo;哈希缓存&amp;rdquo;部分（如果已写入）。该缓存可用于馈送git的增量启发式，有可能导致位图对象与非位图对象之间的增量更好（例如，在较旧的位图包与自上次gc之后推送的对象之间进行获取时）。缺点是每个对象磁盘空间消耗4个字节。默认为true。</target>
        </trans-unit>
        <trans-unit id="98f36898b39f3ac14609adb644f7b367554be4b3" translate="yes" xml:space="preserve">
          <source>When true, git will use pack bitmaps (if available) when packing to stdout (e.g., during the server side of a fetch). Defaults to true. You should not generally need to turn this off unless you are debugging pack bitmaps.</source>
          <target state="translated">当为 &quot;true &quot;时,git 会在打包到 stdout 时使用打包位图(如果有的话)(例如,在取件的服务器端)。默认值为true。一般来说,除非你在调试打包位图,否则不需要关闭这个选项。</target>
        </trans-unit>
        <trans-unit id="3060361b8b64f7f4f15aa5d402b402d65fd1ef21" translate="yes" xml:space="preserve">
          <source>When true, git will write a bitmap index when packing all objects to disk (e.g., when &lt;code&gt;git repack -a&lt;/code&gt; is run). This index can speed up the &quot;counting objects&quot; phase of subsequent packs created for clones and fetches, at the cost of some disk space and extra time spent on the initial repack. This has no effect if multiple packfiles are created. Defaults to true on bare repos, false otherwise.</source>
          <target state="translated">如果为true，则git在将所有对象打包到磁盘时（例如，运行 &lt;code&gt;git repack -a&lt;/code&gt; 时）将写入位图索引。该索引可以加快为克隆和提取创建的后续包的&amp;ldquo;计数对象&amp;rdquo;阶段，但要花一些磁盘空间和花在初始重新打包上的额外时间。如果创建了多个packfile，这将无效。对于裸仓库，默认为true，否则为false。</target>
        </trans-unit>
        <trans-unit id="b7b0c56b83a62c5cf7d9e0b77ba1430747588d7a" translate="yes" xml:space="preserve">
          <source>When true, rebase branches on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;branch.&amp;lt;name&amp;gt;.rebase&quot; for setting this on a per-branch basis.</source>
          <target state="translated">为true时，将在已获取分支的顶部重新分支，而不是在运行&amp;ldquo; git pull&amp;rdquo;时从默认远程合并默认分支。请参阅&amp;ldquo; branch。&amp;lt;名称&amp;gt; .rebase&amp;rdquo;以基于每个分支进行设置。</target>
        </trans-unit>
        <trans-unit id="c15c8ba9ac152f7e581087f6ca67eb8a95961a05" translate="yes" xml:space="preserve">
          <source>When true, rebase the branch &amp;lt;name&amp;gt; on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;pull.rebase&quot; for doing this in a non branch-specific manner.</source>
          <target state="translated">设置为true时，将分支&amp;lt;名称&amp;gt;重新设置在获取的分支之上，而不是在运行&amp;ldquo; git pull&amp;rdquo;时从默认远程合并默认分支。请参阅&amp;ldquo; pull.rebase&amp;rdquo;以非特定于分支的方式执行此操作。</target>
        </trans-unit>
        <trans-unit id="32f2ccfcaf97ac2d1b8fdcbcf4ee46e8d18499a7" translate="yes" xml:space="preserve">
          <source>When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.</source>
          <target state="translated">当为真时,在获取后将当前分支重基到上游分支之上。如果有一个远程跟踪分支与上游分支相对应,且上游分支自上次获取后被重基,则重基使用该信息以避免重基非本地变化。</target>
        </trans-unit>
        <trans-unit id="e3872f2dbeef66b0c7927df02dbbfa3a35c8d12b" translate="yes" xml:space="preserve">
          <source>When two trees are given, it compares the first tree with the second. When a single commit is given, it compares the commit with its parents. The remaining commits, when given, are used as if they are parents of the first commit.</source>
          <target state="translated">当给定两棵树时,它将第一棵树和第二棵树进行比较。当给定一个提交时,它将该提交与它的父提交进行比较。其余的提交,如果给定,则作为第一个提交的父提交来使用。</target>
        </trans-unit>
        <trans-unit id="6b17aa5b71b9d47ea9adc71f193314f65da5b538" translate="yes" xml:space="preserve">
          <source>When two trees are specified, the user is telling &lt;code&gt;git read-tree&lt;/code&gt; the following:</source>
          <target state="translated">当指定了两棵树时，用户告诉 &lt;code&gt;git read-tree&lt;/code&gt; 以下内容：</target>
        </trans-unit>
        <trans-unit id="0b1c4e2bbef526c82867f5bdebb7889317040a32" translate="yes" xml:space="preserve">
          <source>When unpacking a corrupt packfile, the command dies at the first corruption. This flag tells it to keep going and make the best effort to recover as many objects as possible.</source>
          <target state="translated">当解压一个损坏的打包文件时,命令在第一次损坏时就会死亡。这个标志告诉它继续前进,尽最大努力恢复尽可能多的对象。</target>
        </trans-unit>
        <trans-unit id="5a3166bdcd39ee71b5c10c4011020b35e1491541" translate="yes" xml:space="preserve">
          <source>When unspecified, all references, after filtering done with --heads and --tags, are shown. When &amp;lt;refs&amp;gt;&amp;hellip;​ are specified, only references matching the given patterns are displayed.</source>
          <target state="translated">未指定时，将显示使用--heads和--tags过滤后的所有引用。当指定&amp;lt;refs&amp;gt; ...时，仅显示与给定模式匹配的参考。</target>
        </trans-unit>
        <trans-unit id="fa62c673234c7d272766be9489825a6b1fba8b8c" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the untracked cache, it can further improve performance by avoiding the cost of scanning the entire working directory looking for new files.</source>
          <target state="translated">当与未跟踪的缓存一起使用时,它可以避免扫描整个工作目录寻找新文件的成本,从而进一步提高性能。</target>
        </trans-unit>
        <trans-unit id="4699c35836688678c5cc37f1963f740eb7581527" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;-B&lt;/code&gt;, omit also the preimage in the deletion part of a delete/create pair.</source>
          <target state="translated">与 &lt;code&gt;-B&lt;/code&gt; 一起使用时，还删除删除/创建对的删除部分中的原映像。</target>
        </trans-unit>
        <trans-unit id="81ec7d099c83d3c361cd6013c655cfcd1bc1c8c9" translate="yes" xml:space="preserve">
          <source>When used with -C/-c/--amend options, or when committing after a conflicting cherry-pick, declare that the authorship of the resulting commit now belongs to the committer. This also renews the author timestamp.</source>
          <target state="translated">当与-C/-c/--amend选项一起使用时,或者在冲突的cherry-pick之后提交时,声明提交结果的作者身份现在属于提交者。这也会更新作者的时间戳。</target>
        </trans-unit>
        <trans-unit id="b6df5147373d036993fb497c4d7575874db40c5c" translate="yes" xml:space="preserve">
          <source>When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number &lt;code&gt;n&lt;/code&gt; controls this aspect of the -B option (defaults to 50%). &lt;code&gt;-B20%&lt;/code&gt; specifies that a change with addition and deletion compared to 20% or more of the file&amp;rsquo;s size are eligible for being picked up as a possible source of a rename to another file.</source>
          <target state="translated">与-M一起使用时，完全重写的文件也被视为重命名的源（通常-M仅将消失的文件视为重命名的源），数字 &lt;code&gt;n&lt;/code&gt; 控制-B选项的这一方面。 （默认为50％）。 &lt;code&gt;-B20%&lt;/code&gt; 指定与文件大小的20％或更多相比，带有添加和删除的更改有资格作为重命名为另一个文件的可能来源。</target>
        </trans-unit>
        <trans-unit id="372d4fbee27ed51979ac65f708d9745903af8bc0" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;--all&lt;/code&gt; print description for all recognized commands. This is the default.</source>
          <target state="translated">与 &lt;code&gt;--all&lt;/code&gt; 打印说明一起使用时，可识别所有命令。这是默认值。</target>
        </trans-unit>
        <trans-unit id="9b2454d94f74e12e4789baf13180d6dd9add197c" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;-ad&lt;/code&gt;, any unreachable objects from existing packs will be appended to the end of the packfile instead of being removed. In addition, any unreachable loose objects will be packed (and their loose counterparts removed).</source>
          <target state="translated">与 &lt;code&gt;-ad&lt;/code&gt; 一起使用时，现有包中所有无法访问的对象都将附加到packfile的末尾，而不是被删除。此外，所有不可触及的松散物品都将被打包（并清除其松散的对应物品）。</target>
        </trans-unit>
        <trans-unit id="80b1c638669214a11658afe3022f9a5fd154c307" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;value-pattern&lt;/code&gt; argument, treat &lt;code&gt;value-pattern&lt;/code&gt; as an exact string instead of a regular expression. This will restrict the name/value pairs that are matched to only those where the value is exactly equal to the &lt;code&gt;value-pattern&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93c22c6857bec96ca286a73d77a732b313ba7be" translate="yes" xml:space="preserve">
          <source>When using --error-unmatch to expand the user supplied &amp;lt;file&amp;gt; (i.e. path pattern) arguments to paths, pretend that paths which were removed in the index since the named &amp;lt;tree-ish&amp;gt; are still present. Using this option with &lt;code&gt;-s&lt;/code&gt; or &lt;code&gt;-u&lt;/code&gt; options does not make any sense.</source>
          <target state="translated">当使用--error-unmatch将用户提供的&amp;lt;file&amp;gt;（即路径模式）参数扩展到路径时，请假装由于指定的&amp;lt;tree-ish&amp;gt;而在索引中删除的路径仍然存在。将此选项与 &lt;code&gt;-s&lt;/code&gt; 或 &lt;code&gt;-u&lt;/code&gt; 选项一起使用没有任何意义。</target>
        </trans-unit>
        <trans-unit id="c409615f2beb16e70015d6d6f46a1b549d1fd7f1" translate="yes" xml:space="preserve">
          <source>When using --hash (and not --dereference) the output format is: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;</source>
          <target state="translated">使用--hash（而不是--dereference）时，输出格式为： &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4048d2aa35caefecff5d81ef992bce0c4fb7143f" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;--full-history&lt;/code&gt;, Git walks every edge. This will discover the commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; and the merge &lt;code&gt;M&lt;/code&gt;, but also will reveal the merge commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt;. With parent rewriting, the resulting graph is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081b8dc63c3bf5b426e1b11153b55d3d12af50bd" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;--get&lt;/code&gt;, and the requested variable is not found, behave as if &amp;lt;value&amp;gt; were the value assigned to the that variable.</source>
          <target state="translated">使用 &lt;code&gt;--get&lt;/code&gt; 时，未找到请求的变量，其行为就像&amp;lt;value&amp;gt;是分配给该变量的值一样。</target>
        </trans-unit>
        <trans-unit id="a0e35ae72d386768f718c98e1facc75ecb16026b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;git diff&lt;/code&gt; to compare with work tree files, do not consider stat-only change as changed. Instead, silently run &lt;code&gt;git update-index --refresh&lt;/code&gt; to update the cached stat information for paths whose contents in the work tree match the contents in the index. This option defaults to true. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain, and not lower level &lt;code&gt;diff&lt;/code&gt; commands such as &lt;code&gt;git diff-files&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;git diff&lt;/code&gt; 与工作树文件进行比较时，请勿将仅统计更改视为已更改。取而代之的是，静默运行 &lt;code&gt;git update-index --refresh&lt;/code&gt; 来更新其工作树中的内容与索引中的内容匹配的路径的缓存统计信息。此选项默认为true。请注意，这仅影响 &lt;code&gt;git diff&lt;/code&gt; 瓷器，而不影响较低级别的 &lt;code&gt;diff&lt;/code&gt; 命令，例如 &lt;code&gt;git diff-files&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b88f8d37a4b8b52b11aa1a9190d81927513fc837" translate="yes" xml:space="preserve">
          <source>When using either the ssh:// or file:// transport, the GIT_PROTOCOL environment variable must be set explicitly to include &quot;version=2&quot;.</source>
          <target state="translated">当使用ssh://或file://传输时,GIT_PROTOCOL环境变量必须明确设置为包含 &quot;version=2&quot;。</target>
        </trans-unit>
        <trans-unit id="0ba437f399f8167203a8f1358d574f4341e76291" translate="yes" xml:space="preserve">
          <source>When using multiple --branches or --tags, &lt;code&gt;git svn&lt;/code&gt; does not automatically handle name collisions (for example, if two branches from different paths have the same name, or if a branch and a tag have the same name). In these cases, use &lt;code&gt;init&lt;/code&gt; to set up your Git repository then, before your first &lt;code&gt;fetch&lt;/code&gt;, edit the $GIT_DIR/config file so that the branches and tags are associated with different name spaces. For example:</source>
          <target state="translated">当使用多个--branches或--tags时， &lt;code&gt;git svn&lt;/code&gt; 不会自动处理名称冲突（例如，如果来自不同路径的两个分支具有相同的名称，或者分支和标记具有相同的名称）。在这些情况下，请使用 &lt;code&gt;init&lt;/code&gt; 设置您的Git存储库，然后在第一次 &lt;code&gt;fetch&lt;/code&gt; 之前，编辑$ GIT_DIR / config文件，以使分支和标记与不同的名称空间相关联。例如：</target>
        </trans-unit>
        <trans-unit id="66eede648bb8458831446e45d1bace5161e3e57f" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--simplify-merges&lt;/code&gt; option, the commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; disappear from the results. This is because the rewritten second parents of &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; are reachable from their first parents. Those edges are removed and then the commits look like single-parent commits that are TREESAME to their parent. This also happens to the commit &lt;code&gt;N&lt;/code&gt;, resulting in a history view as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2aee242441b06254e02f3a0a2e1341fe75fee4" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--verify&lt;/code&gt; flag, the command requires an exact path:</source>
          <target state="translated">使用 &lt;code&gt;--verify&lt;/code&gt; 标志时，该命令需要一个确切的路径：</target>
        </trans-unit>
        <trans-unit id="33199341df233e06da35e7d1be5de579f81a31d0" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;refspec&lt;/code&gt; capability, git normally updates the private ref on successful push. This update is disabled when the remote-helper declares the capability &lt;code&gt;no-private-update&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;refspec&lt;/code&gt; 功能时，git通常会在成功推送后更新私有ref。当远程帮助程序声明功能 &lt;code&gt;no-private-update&lt;/code&gt; 时，将禁用此更新。</target>
        </trans-unit>
        <trans-unit id="bea3a627ae5a8f7b20a77e60b7a062e9084db269" translate="yes" xml:space="preserve">
          <source>When using the default mode, &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; both have a TREESAME parent, so those edges are walked and the others are ignored. The resulting history graph is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9344e268a1ce18a0fd23fc1ab7349b109ba09f95" translate="yes" xml:space="preserve">
          <source>When using the deprecated &lt;code&gt;[section.subsection]&lt;/code&gt; syntax, changing a value will result in adding a multi-line key instead of a change, if the subsection is given with at least one uppercase character. For example when the config looks like</source>
          <target state="translated">使用不建议使用的 &lt;code&gt;[section.subsection]&lt;/code&gt; 语法时，如果子节至少使用一个大写字符，则更改值将导致添加多行键而不是进行更改。例如，当配置看起来像</target>
        </trans-unit>
        <trans-unit id="d587eeb587978498a5260d6dbb9ec4ed92ae5139" translate="yes" xml:space="preserve">
          <source>When using the git:// transport, you can request to use protocol v2 by sending &quot;version=2&quot; as an extra parameter:</source>
          <target state="translated">当使用 git://传输时,你可以通过发送 &quot;version=2 &quot;作为额外参数来请求使用协议 v2。</target>
        </trans-unit>
        <trans-unit id="32ff889e17de28054dd0cab540306ba1d148a08f" translate="yes" xml:space="preserve">
          <source>When using the http:// or https:// transport a client makes a &quot;smart&quot; info/refs request as described in &lt;code&gt;http-protocol.txt&lt;/code&gt; and requests that v2 be used by supplying &quot;version=2&quot; in the &lt;code&gt;Git-Protocol&lt;/code&gt; header.</source>
          <target state="translated">当使用http：//或https：//传输时，客户端会按照 &lt;code&gt;http-protocol.txt&lt;/code&gt; 中的说明发出&amp;ldquo;智能&amp;rdquo;信息/引用请求，并通过在 &lt;code&gt;Git-Protocol&lt;/code&gt; 提供&amp;ldquo; version = 2&amp;rdquo;来请求使用v2 标头。</target>
        </trans-unit>
        <trans-unit id="1119c741c1d5ff1dc358a8c521dcf54497e7a91a" translate="yes" xml:space="preserve">
          <source>When we discuss merges we&amp;rsquo;ll also see the special name MERGE_HEAD, which refers to the other branch that we&amp;rsquo;re merging in to the current branch.</source>
          <target state="translated">在讨论合并时，我们还会看到特殊名称MERGE_HEAD，它表示我们要合并到当前分支的另一个分支。</target>
        </trans-unit>
        <trans-unit id="26b492dec7c9b7098cc4171f2408a6f7f7e92986" translate="yes" xml:space="preserve">
          <source>When we need to be precise, we will use the word &quot;branch&quot; to mean a line of development, and &quot;branch head&quot; (or just &quot;head&quot;) to mean a reference to the most recent commit on a branch. In the example above, the branch head named &quot;A&quot; is a pointer to one particular commit, but we refer to the line of three commits leading up to that point as all being part of &quot;branch A&quot;.</source>
          <target state="translated">当我们需要精确的时候,我们会用 &quot;分支 &quot;来表示一条开发线,用 &quot;分支头&quot;(或者直接用 &quot;头&quot;)来表示对一个分支上最近一次提交的引用。在上面的例子中,名为 &quot;A &quot;的分支头是一个指向某个特定提交的指针,但我们将通往该点的三条提交线都称为 &quot;分支A &quot;的一部分。</target>
        </trans-unit>
        <trans-unit id="af865a0e18421a331501b917b6b084d9f08c05af" translate="yes" xml:space="preserve">
          <source>When we want to find out what commits in &lt;code&gt;M&lt;/code&gt; are contaminated with the bug introduced by &lt;code&gt;D&lt;/code&gt; and need fixing, however, we might want to view only the subset of &lt;code&gt;D..M&lt;/code&gt; that are actually descendants of &lt;code&gt;D&lt;/code&gt;, i.e. excluding &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;K&lt;/code&gt;. This is exactly what the &lt;code&gt;--ancestry-path&lt;/code&gt; option does. Applied to the &lt;code&gt;D..M&lt;/code&gt; range, it results in:</source>
          <target state="translated">当我们要找出在什么承诺 &lt;code&gt;M&lt;/code&gt; 的污染与引进的bug &lt;code&gt;D&lt;/code&gt; 和需要固定，但是，我们可能只需要查看的子集 &lt;code&gt;D..M&lt;/code&gt; 是实际上的后裔 &lt;code&gt;D&lt;/code&gt; ，即不包括 &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;K&lt;/code&gt; 。这正是 &lt;code&gt;--ancestry-path&lt;/code&gt; 选项的作用。应用于 &lt;code&gt;D..M&lt;/code&gt; 范围，结果为：</target>
        </trans-unit>
        <trans-unit id="bd2b751f52f03b9f39eaea429dccc385cd6f8cb7" translate="yes" xml:space="preserve">
          <source>When writing a script that is expected to handle random user-input, it is a good practice to make it explicit which arguments are which by placing disambiguating &lt;code&gt;--&lt;/code&gt; at appropriate places.</source>
          <target state="translated">在编写预计处理随机用户输入的脚本，这是一个很好的做法，使之明确其论据是它通过将多义性 &lt;code&gt;--&lt;/code&gt; 在适当的地方。</target>
        </trans-unit>
        <trans-unit id="ec9cac719dc2571ad31301b21a571a63039a88c5" translate="yes" xml:space="preserve">
          <source>When writing remote-helpers for decentralized version control systems, it is advised to keep a local copy of the repository to interact with, and to let the private namespace refs point to this local repository, while the refs/remotes namespace is used to track the remote repository.</source>
          <target state="translated">在为分散式版本控制系统编写远程帮助程序时,建议保留一个本地版本库的副本与之交互,并让私有命名空间refs指向这个本地版本库,而refs/remotes命名空间则用于跟踪远程版本库。</target>
        </trans-unit>
        <trans-unit id="20c75e316d5f2bc9ee11a82eb08a64c8e94c8af1" translate="yes" xml:space="preserve">
          <source>When writing, the new value is written to the repository local configuration file by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt;, &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to write to that location (you can say &lt;code&gt;--local&lt;/code&gt; but that is the default).</source>
          <target state="translated">写入时，默认情况下，新值将写入存储库本地配置文件，并且选项 &lt;code&gt;--system&lt;/code&gt; ，-- &lt;code&gt;--global&lt;/code&gt; ，-- &lt;code&gt;--worktree&lt;/code&gt; 和 &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; 可用于告诉命令写入该位置（您可以说 &lt;code&gt;--local&lt;/code&gt; ,但这是默认设置）。</target>
        </trans-unit>
        <trans-unit id="cd8a515ddc50bbc57c4721fd114c9828b7d7e56b" translate="yes" xml:space="preserve">
          <source>When you are happy with the state of this change, you can merge it into the &quot;test&quot; branch in preparation to make it public:</source>
          <target state="translated">当你对这个变化的状态感到满意时,你可以将它合并到 &quot;测试 &quot;分支中,准备将它公开。</target>
        </trans-unit>
        <trans-unit id="778f60f4a64466f8d291144e663a70b4838a03f8" translate="yes" xml:space="preserve">
          <source>When you are in the middle of something, you learn that there are upstream changes that are possibly relevant to what you are doing. When your local changes do not conflict with the changes in the upstream, a simple &lt;code&gt;git pull&lt;/code&gt; will let you move forward.</source>
          <target state="translated">当您处于某种中间状态时，您会了解到上游的变化可能与您所做的事情有关。当本地更改与上游更改不冲突时，简单的 &lt;code&gt;git pull&lt;/code&gt; 将使您前进。</target>
        </trans-unit>
        <trans-unit id="f6b623b307a4c06027202dc5b8021ae4a369fe95" translate="yes" xml:space="preserve">
          <source>When you are in the middle of something, your boss comes in and demands that you fix something immediately. Traditionally, you would make a commit to a temporary branch to store your changes away, and return to your original branch to make the emergency fix, like this:</source>
          <target state="translated">当你正在做一件事的时候,你的老板来了,要求你立即修复某件事情。传统上,你会在一个临时的分支上做一个承诺,把你的修改储存起来,然后回到你原来的分支进行紧急修复,就像这样。</target>
        </trans-unit>
        <trans-unit id="5dab203d26aab56f5ab1012e5091a813403ff2db" translate="yes" xml:space="preserve">
          <source>When you are interested in finding the origin for lines 40-60 for file &lt;code&gt;foo&lt;/code&gt;, you can use the &lt;code&gt;-L&lt;/code&gt; option like so (they mean the same thing &amp;mdash; both ask for 21 lines starting at line 40):</source>
          <target state="translated">如果您有兴趣查找文件 &lt;code&gt;foo&lt;/code&gt; 的 40-60行的原点，则可以使用 &lt;code&gt;-L&lt;/code&gt; 选项（它们的意思是相同的-都要求从40行开始的21行）：</target>
        </trans-unit>
        <trans-unit id="709f7df580972f427522b82ef732f913e20c2078" translate="yes" xml:space="preserve">
          <source>When you are not interested in changes older than version v2.6.18, or changes older than 3 weeks, you can use revision range specifiers similar to &lt;code&gt;git rev-list&lt;/code&gt;:</source>
          <target state="translated">如果您对版本v2.6.18之前的更改不感兴趣，或者对3周以上的更改不感兴趣，则可以使用类似于 &lt;code&gt;git rev-list&lt;/code&gt; 的修订范围说明符：</target>
        </trans-unit>
        <trans-unit id="da9f31c43174e26846193d472d4442e982c36d7b" translate="yes" xml:space="preserve">
          <source>When you are working in a small closely knit group, it is not unusual to interact with the same repository over and over again. By defining &lt;code&gt;remote&lt;/code&gt; repository shorthand, you can make it easier:</source>
          <target state="translated">当您在一个紧密的小型小组中工作时，一次又一次地与同一个存储库进行交互并不罕见。通过定义 &lt;code&gt;remote&lt;/code&gt; 存储库速记，可以使其变得更容易：</target>
        </trans-unit>
        <trans-unit id="9ac50cc4cb199a994adc57ff3704f94a4fe6fd25" translate="yes" xml:space="preserve">
          <source>When you ask &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; to show the conflicts, it runs a three-way diff between the conflicted merge results in the work tree with stages 2 and 3 to show only hunks whose contents come from both sides, mixed (in other words, when a hunk&amp;rsquo;s merge results come only from stage 2, that part is not conflicting and is not shown. Same for stage 3).</source>
          <target state="translated">当您要求&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;显示冲突时，它将在工作树的阶段2和3的冲突合并结果之间运行三向diff，以仅显示其内容来自双方的混合块（在其他换句话说，当大块的合并结果仅来自阶段2时​​，该部分不会冲突且不会显示（与阶段3相同）。</target>
        </trans-unit>
        <trans-unit id="23850e192db360b828b88cc125a57c30022897e8" translate="yes" xml:space="preserve">
          <source>When you perform a squash merge, a merge commit isn&amp;rsquo;t created; instead, the changes from one side are applied as a regular commit to the other side. This means that the merge base for these branches won&amp;rsquo;t have changed, and so when Git goes to perform its next merge, it considers all of the changes that it considered the last time plus the new changes. That means any conflicts may need to be re-resolved. Similarly, anything using the &lt;code&gt;...&lt;/code&gt; notation in &lt;code&gt;git
diff&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt;, or a GUI will result in showing all of the changes since the original merge base.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0add0b9e7571c844c4ae8fb98b59f1c64d874a" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; or &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; and only have one remote, it may implicitly fall back on checking out and tracking e.g. &lt;code&gt;origin/&amp;lt;something&amp;gt;&lt;/code&gt;. This stops working as soon as you have more than one remote with a &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; reference. This setting allows for setting the name of a preferred remote that should always win when it comes to disambiguation. The typical use-case is to set this to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">当您运行 &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; 或 &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; 并且只有一个远程控制器时，它可能隐式地退回到签出并跟踪，例如 &lt;code&gt;origin/&amp;lt;something&amp;gt;&lt;/code&gt; 。只要有多个带有 &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; 引用的遥控器，这就会停止工作。此设置允许设置首选遥控器的名称，在消除歧义时应始终取胜。典型的用例是将此设置为 &lt;code&gt;origin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f93e702904ad75a7ffcc41597ebc2474895e0b0" translate="yes" xml:space="preserve">
          <source>When you start a 3-way merge with an index file that is already populated, it is assumed that it represents the state of the files in your work tree, and you can even have files with changes unrecorded in the index file. It is further assumed that this state is &quot;derived&quot; from the stage 2 tree. The 3-way merge refuses to run if it finds an entry in the original index file that does not match stage 2.</source>
          <target state="translated">当你用一个已经填充的索引文件开始3路合并时,假定它代表了工作树中文件的状态,你甚至可以有文件的变化没有记录在索引文件中。进一步假设这个状态是由第2阶段的树 &quot;衍生 &quot;出来的。如果在原始索引文件中发现一个与阶段2不匹配的条目,3-way合并将拒绝运行。</target>
        </trans-unit>
        <trans-unit id="6831d00e1f830a484b6c5799e343f596bbc55899" translate="yes" xml:space="preserve">
          <source>When you want to just integrate with the work leading to the commit that happens to be tagged, e.g. synchronizing with an upstream release point, you may not want to make an unnecessary merge commit.</source>
          <target state="translated">当你只想整合导致提交的工作,而这个工作恰好被标记,例如与上游发布点同步,你可能不想做一个不必要的合并提交。</target>
        </trans-unit>
        <trans-unit id="2f28e5d62e5a87453e903e81e941382b8ac566c1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready, just run</source>
          <target state="translated">准备好后，就跑步</target>
        </trans-unit>
        <trans-unit id="4aa6b6296b8d97b342099d335ec15bc55634ad41" translate="yes" xml:space="preserve">
          <source>When your topic branch is long-lived, however, your topic branch would end up having many such &quot;Merge from master&quot; commits on it, which would unnecessarily clutter the development history. Readers of the Linux kernel mailing list may remember that Linus complained about such too frequent test merges when a subsystem maintainer asked to pull from a branch full of &quot;useless merges&quot;.</source>
          <target state="translated">然而,当你的主题分支寿命很长时,你的主题分支最终会有很多这样的 &quot;Merge from master &quot;的提交,这将不必要地使开发历史混乱。Linux内核邮件列表的读者可能还记得,当一个子系统维护者要求从一个满是 &quot;无用的合并 &quot;的分支中拔出时,Linus抱怨过这种过于频繁的测试合并。</target>
        </trans-unit>
        <trans-unit id="bd4128428344ae6c28977b2bc5cf00953da1175f" translate="yes" xml:space="preserve">
          <source>When your topic branch modifies an overlapping area that your master branch (or upstream) touched since your topic branch forked from it, you may want to test it with the latest master, even before your topic branch is ready to be pushed upstream:</source>
          <target state="translated">当你的主题分支修改了你的主分支(或上游)在你的主题分支分叉后所触及的重叠区域时,你可能需要用最新的主分支来测试它,甚至在你的主题分支准备推送到上游之前。</target>
        </trans-unit>
        <trans-unit id="4f4eaf255ffc69df0530167a4810c74e9370cd43" translate="yes" xml:space="preserve">
          <source>Whenever possible, section headings should clearly describe the task they explain how to do, in language that requires no more knowledge than necessary: for example, &quot;importing patches into a project&quot; rather than &quot;the &lt;code&gt;git am&lt;/code&gt; command&quot;</source>
          <target state="translated">只要有可能，各节标题都应使用不需要多于必要知识的语言清楚地描述他们解释如何做的任务：例如，&amp;ldquo;将补丁导入项目&amp;rdquo;而不是&amp;ldquo; &lt;code&gt;git am&lt;/code&gt; 命令&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="11683716a14fb2e59c3ad4d48a607606706a0329" translate="yes" xml:space="preserve">
          <source>Where &quot;oldsha1&quot; is the 40 character hexadecimal value previously stored in &amp;lt;ref&amp;gt;, &quot;newsha1&quot; is the 40 character hexadecimal value of &amp;lt;newvalue&amp;gt; and &quot;committer&quot; is the committer&amp;rsquo;s name, email address and date in the standard Git committer ident format.</source>
          <target state="translated">其中&amp;ldquo; oldsha1&amp;rdquo;是先前存储在&amp;lt;ref&amp;gt;中的40个字符的十六进制值，&amp;ldquo; newsha1&amp;rdquo;是&amp;lt;newvalue&amp;gt;的40个字符的十六进制值，而&amp;ldquo; committer&amp;rdquo;是提交者的名称，电子邮件地址和标准Git提交者标识格式的日期。 。</target>
        </trans-unit>
        <trans-unit id="9a6682bd90b10ed7b65387d46ac6e3098ba208ce" translate="yes" xml:space="preserve">
          <source>Where all fields are as described above and &quot;message&quot; is the value supplied to the -m option.</source>
          <target state="translated">其中,所有字段都如上所述,&quot;message &quot;是提供给-m选项的值。</target>
        </trans-unit>
        <trans-unit id="1047cdb3a9504c1e49ba180691c6de133fb29736" translate="yes" xml:space="preserve">
          <source>Where to create the Git repository. If not provided, the last component in the p4 depot path is used to create a new directory.</source>
          <target state="translated">创建 Git 仓库的位置。如果没有提供,则使用p4仓库路径中的最后一个组件来创建一个新的目录。</target>
        </trans-unit>
        <trans-unit id="de8afe671960d7a395defa2e40a80901d96e2485" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;--batch-check='%(objectname) %(objecttype)'&lt;/code&gt; would produce:</source>
          <target state="translated">而 &lt;code&gt;--batch-check='%(objectname) %(objecttype)'&lt;/code&gt; 会产生：</target>
        </trans-unit>
        <trans-unit id="92669e9b8b127c2ba15691914d72dae97b880d0d" translate="yes" xml:space="preserve">
          <source>Whether Git detects directory renames, affecting what happens at merge time to new files added to a directory on one side of history when that directory was renamed on the other side of history. If merge.directoryRenames is set to &quot;false&quot;, directory rename detection is disabled, meaning that such new files will be left behind in the old directory. If set to &quot;true&quot;, directory rename detection is enabled, meaning that such new files will be moved into the new directory. If set to &quot;conflict&quot;, a conflict will be reported for such paths. If merge.renames is false, merge.directoryRenames is ignored and treated as false. Defaults to &quot;conflict&quot;.</source>
          <target state="translated">Git 是否会检测目录重名,影响合并时对历史上一方目录的新文件的检测,当该目录在历史的另一方被重名时,会发生什么情况。如果merge.directoryRenames设置为 &quot;false&quot;,则目录重名检测将被关闭,这意味着这些新文件将被留在旧目录中。如果设置为 &quot;true&quot;,则启用目录重命名检测,这意味着这些新文件将被移到新目录中。如果设置为 &quot;冲突&quot;,则会报告此类路径的冲突。如果merge.renames为false,merge.directoryRenames将被忽略,并作为false处理。默认为 &quot;冲突&quot;。</target>
        </trans-unit>
        <trans-unit id="6720b94e3bf2c12c61b3c14de0415d18239394a0" translate="yes" xml:space="preserve">
          <source>Whether Git detects renames. If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. Defaults to the value of diff.renames.</source>
          <target state="translated">Git 是否会检测重名,如果设置为 &quot;false&quot;,则禁用重名检测。如果设置为 &quot;false&quot;,则禁用重命名检测。如果设置为 &quot;true&quot;,则启用基本重名检测。默认为 diff.renames 的值。</target>
        </trans-unit>
        <trans-unit id="d1f68ec7a1f81e21d54ab2e76eaccedf11117ff8" translate="yes" xml:space="preserve">
          <source>Whether and how Git detects renames in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; . If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. If set to &quot;copies&quot; or &quot;copy&quot;, Git will detect copies, as well. Defaults to the value of diff.renames.</source>
          <target state="translated">Git是否以及如何检测&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;和&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]中的&lt;/a&gt;重命名。如果设置为&amp;ldquo; false&amp;rdquo;，则禁用重命名检测。如果设置为&amp;ldquo; true&amp;rdquo;，则启用基本的重命名检测。如果设置为&amp;ldquo;份数&amp;rdquo;或&amp;ldquo;副本&amp;rdquo;，Git也将检测到副本。默认为diff.renames的值。</target>
        </trans-unit>
        <trans-unit id="cd914284b278d491020fec9d972b776a56df2f14" translate="yes" xml:space="preserve">
          <source>Whether and how Git detects renames. If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. If set to &quot;copies&quot; or &quot;copy&quot;, Git will detect copies, as well. Defaults to true. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain like &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, and not lower level commands such as &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt;.</source>
          <target state="translated">Git是否以及如何检测到重命名。如果设置为&amp;ldquo; false&amp;rdquo;，则禁用重命名检测。如果设置为&amp;ldquo; true&amp;rdquo;，则启用基本的重命名检测。如果设置为&amp;ldquo;份数&amp;rdquo;或&amp;ldquo;副本&amp;rdquo;，Git也将检测到副本。默认为true。请注意，这仅影响 &lt;code&gt;git diff&lt;/code&gt; Porcelain，如&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;和&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;，而不影响较低级别的命令，例如&lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2329b3f81f31d1e7aac7efc37e396ae5ccc9b5fe" translate="yes" xml:space="preserve">
          <source>Whether git should follow HTTP redirects. If set to &lt;code&gt;true&lt;/code&gt;, git will transparently follow any redirect issued by a server it encounters. If set to &lt;code&gt;false&lt;/code&gt;, git will treat all redirects as errors. If set to &lt;code&gt;initial&lt;/code&gt;, git will follow redirects only for the initial request to a remote, but not for subsequent follow-up HTTP requests. Since git uses the redirected URL as the base for the follow-up requests, this is generally sufficient. The default is &lt;code&gt;initial&lt;/code&gt;.</source>
          <target state="translated">git是否应遵循HTTP重定向。如果设置为 &lt;code&gt;true&lt;/code&gt; ，git将透明地遵循它遇到的服务器发出的任何重定向。如果设置为 &lt;code&gt;false&lt;/code&gt; ，git会将所有重定向视为错误。如果设置为 &lt;code&gt;initial&lt;/code&gt; ，则git只会将重定向用于初始请求到远程的重定向，而不用于后续的后续HTTP请求。由于git使用重定向的URL作为后续请求的基础，因此通常就足够了。默认值为 &lt;code&gt;initial&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd0092aedf4252969afafd8803ba8faf98999493" translate="yes" xml:space="preserve">
          <source>Whether that update is allowed without &lt;code&gt;--force&lt;/code&gt; depends on the ref namespace it&amp;rsquo;s being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; section of &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; for what those are. Exceptions to those rules particular to &lt;code&gt;git fetch&lt;/code&gt; are noted below.</source>
          <target state="translated">不使用 &lt;code&gt;--force&lt;/code&gt; 是否允许该更新取决于要获取的ref名称空间，要获取的对象的类型以及是否将该更新视为快速转发。通常，提取时适用相同的规则，有关内容请参见&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;的 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; 部分。以下是 &lt;code&gt;git fetch&lt;/code&gt; 特有的那些规则的例外情况。</target>
        </trans-unit>
        <trans-unit id="9c31395d6226db0f96527cf13d7284a32596aaef" translate="yes" xml:space="preserve">
          <source>Whether the CVS server interface is enabled for this repository. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">是否为此存储库启用了CVS服务器接口。参见&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e99c94b5e67663cef6460c2b09cda34348e975de" translate="yes" xml:space="preserve">
          <source>Whether to enable the grouping of projects by category on the project list page. The category of a project is determined by the &lt;code&gt;$GIT_DIR/category&lt;/code&gt; file or the &lt;code&gt;gitweb.category&lt;/code&gt; variable in each repository&amp;rsquo;s configuration. Disabled by default (set to 0).</source>
          <target state="translated">是否在项目列表页面上按类别启用项目分组。项目的类别由每个存储库配置中的 &lt;code&gt;$GIT_DIR/category&lt;/code&gt; 文件或 &lt;code&gt;gitweb.category&lt;/code&gt; 变量确定。默认情况下禁用（设置为0）。</target>
        </trans-unit>
        <trans-unit id="be60442dc9a2bb750c3ffb3e91f602fa8cf454b7" translate="yes" xml:space="preserve">
          <source>Whether to print the diffstat between ORIG_HEAD and the merge result at the end of the merge. True by default.</source>
          <target state="translated">是否在合并结束时打印ORIG_HEAD和合并结果之间的差异统计。默认为true。</target>
        </trans-unit>
        <trans-unit id="e6d010b4fa5fb27d92c64dc2f59319c4e77b544c" translate="yes" xml:space="preserve">
          <source>Whether to show a diffstat of what changed upstream since the last rebase. False by default.</source>
          <target state="translated">是否显示自上次 rebase 以来上游变化的 diffstat。默认为False。</target>
        </trans-unit>
        <trans-unit id="2153c59644d7df4b2ed210d8ef453074b1a6c2ac" translate="yes" xml:space="preserve">
          <source>Whether to skip reading settings from the system-wide $(prefix)/etc/gitconfig file. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">是否跳过系统范围的$（prefix）/ etc / gitconfig文件中的设置。有关详细信息，请参见&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c8173d7da296bd9c5f5aef35e3d739c8852bc79" translate="yes" xml:space="preserve">
          <source>Whether to skip reading settings from the system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; file. This environment variable can be used along with &lt;code&gt;$HOME&lt;/code&gt; and &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; to create a predictable environment for a picky script, or you can set it temporarily to avoid using a buggy &lt;code&gt;/etc/gitconfig&lt;/code&gt; file while waiting for someone with sufficient permissions to fix it.</source>
          <target state="translated">是否跳过系统范围的 &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; 文件中的设置。此环境变量可以与 &lt;code&gt;$HOME&lt;/code&gt; 和 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; 一起使用，以为挑剔的脚本创建可预测的环境，或者可以临时设置它，以避免在等待具有足够权限的人对其进行修复时使用有问题的 &lt;code&gt;/etc/gitconfig&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="488ddc0ec5d5c663a8e8059a323ed70db5316b78" translate="yes" xml:space="preserve">
          <source>Whether to use ANSI escape sequences to add color to patches. If this is set to &lt;code&gt;always&lt;/code&gt;, &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;, &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, and &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; will use color for all patches. If it is set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, those commands will only use color when output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">是否使用ANSI转义序列为色块添加颜色。如果将其设置为 &lt;code&gt;always&lt;/code&gt; ，则&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;，&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;和&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;将对所有修补程序使用颜色。如果将其设置为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;auto&lt;/code&gt; ，则这些命令仅在输出到终端时才使用颜色。如果未设置，则使用 &lt;code&gt;color.ui&lt;/code&gt; 的值（默认情况下为 &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="21386b2036d855c8d8dd6eb4c84085329fcf2561" translate="yes" xml:space="preserve">
          <source>Whether to use empty blobs as rename source.</source>
          <target state="translated">是否使用空的 blobs 作为重命名源。</target>
        </trans-unit>
        <trans-unit id="63ea1a80cc99dbbdec2d362a1b57aa7468c9ed6d" translate="yes" xml:space="preserve">
          <source>Whether to verify the SSL certificate when fetching or pushing over HTTPS. Defaults to true. Can be overridden by the &lt;code&gt;GIT_SSL_NO_VERIFY&lt;/code&gt; environment variable.</source>
          <target state="translated">在获取或通过HTTPS推送时是否验证SSL证书。默认为true。可以被 &lt;code&gt;GIT_SSL_NO_VERIFY&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="ec9fdb5354be84561f27023760593b27a86cd126" translate="yes" xml:space="preserve">
          <source>Which file to place a pattern in depends on how the pattern is meant to be used.</source>
          <target state="translated">将图案放在哪个文件中取决于图案的使用方式。</target>
        </trans-unit>
        <trans-unit id="9342c5a7ca74e113fca6826c098da1e9dea46c59" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose by default when resolving notes conflicts. Must be one of &lt;code&gt;manual&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt;, &lt;code&gt;theirs&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;cat_sort_uniq&lt;/code&gt;. Defaults to &lt;code&gt;manual&lt;/code&gt;. See &quot;NOTES MERGE STRATEGIES&quot; section above for more information on each strategy.</source>
          <target state="translated">解决音符冲突时默认选择哪种合并策略。必须是 &lt;code&gt;manual&lt;/code&gt; ， &lt;code&gt;ours&lt;/code&gt; ， &lt;code&gt;theirs&lt;/code&gt; ， &lt;code&gt;union&lt;/code&gt; 或 &lt;code&gt;cat_sort_uniq&lt;/code&gt; 之一。默认为 &lt;code&gt;manual&lt;/code&gt; 。有关每种策略的更多信息，请参见上面的&amp;ldquo;合并提示策略&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="7dd75dabb694bc7182031b6cdb5c605283f3ff3a" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose by default when resolving notes conflicts. Must be one of &lt;code&gt;manual&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt;, &lt;code&gt;theirs&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;cat_sort_uniq&lt;/code&gt;. Defaults to &lt;code&gt;manual&lt;/code&gt;. See &quot;NOTES MERGE STRATEGIES&quot; section of &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; for more information on each strategy.</source>
          <target state="translated">解决音符冲突时默认选择哪种合并策略。必须是 &lt;code&gt;manual&lt;/code&gt; ， &lt;code&gt;ours&lt;/code&gt; ， &lt;code&gt;theirs&lt;/code&gt; ， &lt;code&gt;union&lt;/code&gt; 或 &lt;code&gt;cat_sort_uniq&lt;/code&gt; 之一。默认为 &lt;code&gt;manual&lt;/code&gt; 。有关每种策略的更多信息，请参见&lt;a href=&quot;git-notes&quot;&gt;git-notes [1]的&lt;/a&gt; &amp;ldquo;注释合并策略&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="9bd73c0d97037644e549ed3fed8d2491f5cfc8e0" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose when doing a notes merge into refs/notes/&amp;lt;name&amp;gt;. This overrides the more general &quot;notes.mergeStrategy&quot;. See the &quot;NOTES MERGE STRATEGIES&quot; section above for more information on each available strategy.</source>
          <target state="translated">做注释时选择哪种合并策略合并为refs / notes / &amp;lt;name&amp;gt;。这将覆盖更通用的&amp;ldquo; notes.mergeStrategy&amp;rdquo;。有关每种可用策略的更多信息，请参见上面的&amp;ldquo;注意合并策略&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="f202b61699020bcfa082fe897d7a8560aea486a1" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose when doing a notes merge into refs/notes/&amp;lt;name&amp;gt;. This overrides the more general &quot;notes.mergeStrategy&quot;. See the &quot;NOTES MERGE STRATEGIES&quot; section in &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; for more information on the available strategies.</source>
          <target state="translated">做注释时选择哪种合并策略合并为refs / notes / &amp;lt;name&amp;gt;。这将覆盖更通用的&amp;ldquo; notes.mergeStrategy&amp;rdquo;。有关可用策略的更多信息，请参见&lt;a href=&quot;git-notes&quot;&gt;git-notes [1]中&lt;/a&gt;的&amp;ldquo; NOTES MERGE STRATEGIES&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="556a322f94dd1e45943ded0ebea9906e93ca0c80" translate="yes" xml:space="preserve">
          <source>Which ref (or refs, if a glob or specified more than once), in addition to the default set by &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages with the &lt;code&gt;git log&lt;/code&gt; family of commands. This setting can be overridden on the command line or by the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable. See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">除了使用 &lt;code&gt;core.notesRef&lt;/code&gt; 或 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 设置的默认值之外，还可以使用哪个ref（如果一个glob或多次指定，则引用）从使用 &lt;code&gt;git log&lt;/code&gt; 系列命令显示提交消息时读取注释。可以在命令行上或通过 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 环境变量来覆盖此设置。参见&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="08e8ee8d98ea130471cc368fbf1a571f3d29a34d" translate="yes" xml:space="preserve">
          <source>Which ref to manipulate notes from, instead of &lt;code&gt;refs/notes/commits&lt;/code&gt;. This overrides the &lt;code&gt;core.notesRef&lt;/code&gt; setting.</source>
          <target state="translated">从哪个ref操纵注释，而不是 &lt;code&gt;refs/notes/commits&lt;/code&gt; 。这将覆盖 &lt;code&gt;core.notesRef&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="180171a89f79828ca3aedfa4194b8ff07f802f3f" translate="yes" xml:space="preserve">
          <source>Which refs, in addition to the default set by &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages with the &lt;code&gt;log&lt;/code&gt; family of commands. See &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;.</source>
          <target state="translated">除了使用 &lt;code&gt;core.notesRef&lt;/code&gt; 或 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 设置的默认值之外，当使用 &lt;code&gt;log&lt;/code&gt; 系列命令显示提交消息时，该ref 还将读取注释。参见&lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4dbbdac6096ee85d080e618f1dfec3eb7804653" translate="yes" xml:space="preserve">
          <source>Which will add the following to a file named &lt;code&gt;.gitconfig&lt;/code&gt; in your home directory:</source>
          <target state="translated">这会将以下内容添加到主目录中名为 &lt;code&gt;.gitconfig&lt;/code&gt; 的文件中：</target>
        </trans-unit>
        <trans-unit id="0b383fc769f1bfb4acb136b5be3ea84e9742db33" translate="yes" xml:space="preserve">
          <source>Which would result in:</source>
          <target state="translated">这将导致:</target>
        </trans-unit>
        <trans-unit id="5efe59371f7c539c77a16fb753d65287a4a1a881" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; is usually used to specify what files are in, you can also specify what files are &lt;code&gt;not&lt;/code&gt; in, using negate patterns. For example, to remove the file &lt;code&gt;unwanted&lt;/code&gt;:</source>
          <target state="translated">虽然 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 通常用于指定其中的文件，但是您也可以使用取反模式来指定 &lt;code&gt;not&lt;/code&gt; 文件。例如，要删除 &lt;code&gt;unwanted&lt;/code&gt; 的文件：</target>
        </trans-unit>
        <trans-unit id="133c634c89411bc7bbb73a5aa8f4cda72b5442c2" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; is usually used to specify what files are included, you can also specify what files are &lt;code&gt;not&lt;/code&gt; included, using negative patterns. For example, to remove the file &lt;code&gt;unwanted&lt;/code&gt;:</source>
          <target state="translated">虽然 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 通常用于指定要包括的文件，但是您也可以使用负模式来指定 &lt;code&gt;not&lt;/code&gt; 包括的文件。例如，要删除 &lt;code&gt;unwanted&lt;/code&gt; 的文件：</target>
        </trans-unit>
        <trans-unit id="118bfe73a3b1ef14dd8bb7fedadb7cb55f01bcfb" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;&lt;/code&gt; was about specifying a single commit parent, these three notations also consider its parents. For example you can say &lt;code&gt;HEAD^2^@&lt;/code&gt;, however you cannot say &lt;code&gt;HEAD^@^2&lt;/code&gt;.</source>
          <target state="translated">尽管 &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;&lt;/code&gt; 是关于指定单个提交父级的，但是这三个表示法也考虑了其父级。例如，您可以说 &lt;code&gt;HEAD^2^@&lt;/code&gt; ，但是不能说 &lt;code&gt;HEAD^@^2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eaec58c53324781fb42b4e63ea8a9cb23361a1d5" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git archimport&lt;/code&gt; will try to create sensible branch names for the archives that it imports, it is also possible to specify Git branch names manually. To do so, write a Git branch name after each &amp;lt;archive/branch&amp;gt; parameter, separated by a colon. This way, you can shorten the Arch branch names and convert Arch jargon to Git jargon, for example mapping a &quot;PROJECT--devo--VERSION&quot; branch to &quot;master&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e92ccd1a34f0875d32051d1b819b76c11daddf" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git archimport&lt;/code&gt; will try to create sensible branch names for the archives that it imports, it is also possible to specify Git branch names manually. To do so, write a Git branch name after each &amp;lt;archive/branch&amp;gt; parameter, separated by a colon. This way, you can shorten the Arch branch names and convert Arch jargon to Git jargon, for example mapping a &quot;PROJECT{litdd}devo{litdd}VERSION&quot; branch to &quot;master&quot;.</source>
          <target state="translated">虽然 &lt;code&gt;git archimport&lt;/code&gt; 将尝试为其导入的档案创建明智的分支名称，但也可以手动指定Git分支名称。为此，请在每个&amp;lt;archive / branch&amp;gt;参数后写一个Git分支名称，并用冒号分隔。这样，您可以缩短Arch分支名称，并将Arch术语转换为Git术语，例如将&amp;ldquo; PROJECT {litdd} devo {litdd} VERSION&amp;rdquo;分支映射到&amp;ldquo; master&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="becb5324e2c3fe06edf2ea3e91b298d56c7ab4c0" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git log -G&quot;frotz\(nitfol&quot;&lt;/code&gt; will show this commit, &lt;code&gt;git log
-S&quot;frotz\(nitfol&quot; --pickaxe-regex&lt;/code&gt; will not (because the number of occurrences of that string did not change).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3c7753b36510ea58174f6c4603b4398587f401" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git log -G&quot;regexec\(regexp&quot;&lt;/code&gt; will show this commit, &lt;code&gt;git log
-S&quot;regexec\(regexp&quot; --pickaxe-regex&lt;/code&gt; will not (because the number of occurrences of that string did not change).</source>
          <target state="translated">虽然 &lt;code&gt;git log -G&quot;regexec\(regexp&quot;&lt;/code&gt; 将显示此提交，而 &lt;code&gt;git log -S&quot;regexec\(regexp&quot; --pickaxe-regex&lt;/code&gt; 则不会）（因为该字符串的出现次数未更改）。</target>
        </trans-unit>
        <trans-unit id="9fa3ab181478a04a41a15d625153bef4e8a57c74" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git svn&lt;/code&gt; can track copy history (including branches and tags) for repositories adopting a standard layout, it cannot yet represent merge history that happened inside git back upstream to SVN users. Therefore it is advised that users keep history as linear as possible inside Git to ease compatibility with SVN (see the CAVEATS section below).</source>
          <target state="translated">尽管 &lt;code&gt;git svn&lt;/code&gt; 可以跟踪采用标准布局的存储库的复制历史记录（包括分支和标签），但它尚不能表示git内部返回到SVN用户的合并历史记录。因此，建议用户在Git内将历史记录保持尽可能线性，以简化与SVN的兼容性（请参阅下面的CAVEATS部分）。</target>
        </trans-unit>
        <trans-unit id="a541171ff58e87a1f0dd9a2efc98b39d30771db4" translate="yes" xml:space="preserve">
          <source>While Git can store and handle any file of any type, there are some settings that work better than others. In general, we recommend that text files be stored in UTF-8 without a byte-order mark (BOM) with LF (Unix-style) endings. We also recommend the use of UTF-8 (again, without BOM) in commit messages. These are the settings that work best across platforms and with tools such as &lt;code&gt;git diff&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dffb65164b8303d8f69a39b7acb7d5c91ede142" translate="yes" xml:space="preserve">
          <source>While Git normally leaves file contents alone, it can be configured to normalize line endings to LF in the repository and, optionally, to convert them to CRLF when files are checked out.</source>
          <target state="translated">虽然Git通常不会去管文件内容,但它可以配置在版本库中把行结尾规范化为LF,还可以在文件被签出时将其转换为CRLF。</target>
        </trans-unit>
        <trans-unit id="28e5e3e789710acfbe64ae88514ac76e33edddf4" translate="yes" xml:space="preserve">
          <source>While a tree represents a particular directory state of a working directory, a commit represents that state in &quot;time&quot;, and explains how to get there.</source>
          <target state="translated">树代表了一个工作目录的特定目录状态,而提交则代表了这个状态的 &quot;时间&quot;,并解释了如何到达那里。</target>
        </trans-unit>
        <trans-unit id="4340adfab1f511dfd0a9b398534e55b63d70f9b2" translate="yes" xml:space="preserve">
          <source>While an &quot;easy case recovery&quot; sometimes appears to be successful even in the hard case, it may have unintended consequences. For example, a commit that was removed via &lt;code&gt;git rebase
      --interactive&lt;/code&gt; will be &lt;strong&gt;resurrected&lt;/strong&gt;!</source>
          <target state="translated">尽管即使在困难的情况下，&amp;ldquo;简单的案例恢复&amp;rdquo;有时似乎也会成功，但它可能会带来意想不到的后果。例如，通过 &lt;code&gt;git rebase --interactive&lt;/code&gt; 删除的提交将被&lt;strong&gt;复活&lt;/strong&gt;！</target>
        </trans-unit>
        <trans-unit id="aeca28e54d758d00b7b9efe81e9021c3ae168604" translate="yes" xml:space="preserve">
          <source>While at it, check the &lt;code&gt;info&lt;/code&gt; and &lt;code&gt;final-commit&lt;/code&gt; files as well. If what is in &lt;code&gt;final-commit&lt;/code&gt; is not exactly what you would want to see in the commit log message, it is very likely that the receiver would end up hand editing the log message when applying your patch. Things like &quot;Hi, this is my first patch.\n&quot; in the patch e-mail should come after the three-dash line that signals the end of the commit message.</source>
          <target state="translated">同时，还要检查 &lt;code&gt;info&lt;/code&gt; 和 &lt;code&gt;final-commit&lt;/code&gt; 文件。如果 &lt;code&gt;final-commit&lt;/code&gt; 中的内容与提交日志消息中所显示的不完全相同，那么接收方很有可能最终会在应用补丁时最终手动编辑日志消息。修补程序电子邮件中的诸如&amp;ldquo;嗨，这是我的第一个修补程序。\ n&amp;rdquo;之类的内容应位于表示提交消息结束的三点划线之后。</target>
        </trans-unit>
        <trans-unit id="8ae695a4eabf8fe5dbbd3e5b96e3d4b6e1234599" translate="yes" xml:space="preserve">
          <source>While creating changes is useful, it&amp;rsquo;s even more useful if you can tell later what changed. The most useful command for this is another of the &lt;code&gt;diff&lt;/code&gt; family, namely &lt;code&gt;git diff-tree&lt;/code&gt;.</source>
          <target state="translated">虽然创建更改很有用，但是如果您以后可以告诉您更改内容，则将更加有用。对此最有用的命令是 &lt;code&gt;diff&lt;/code&gt; 系列的另一个命令，即 &lt;code&gt;git diff-tree&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e66bf2723385d320e1625ad06ac948bff457808d" translate="yes" xml:space="preserve">
          <source>While it is possible to override all attributes, well behaving helpers should refrain from doing so for any attribute other than username and password.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a06403fddbfbdfed756ddcbe7e1b6ff85edd7a" translate="yes" xml:space="preserve">
          <source>While one could just alter the configuration settings in the gitweb CGI itself, those changes would be lost upon upgrade. Configuration settings might also be placed into a file in the same directory as the CGI script with the default name &lt;code&gt;gitweb_config.perl&lt;/code&gt; &amp;mdash; allowing one to have multiple gitweb instances with different configurations by the use of symlinks.</source>
          <target state="translated">尽管可以更改gitweb CGI本身中的配置设置，但这些更改在升级时将丢失。配置设置也可以放置在与CGI脚本相同目录中的文件中，默认名称为 &lt;code&gt;gitweb_config.perl&lt;/code&gt; －通过使用符号链接，允许一个具有多个具有不同配置的gitweb实例。</target>
        </trans-unit>
        <trans-unit id="3129dc27b36b536bbc925e644f78f32bde86376a" translate="yes" xml:space="preserve">
          <source>While parent object ids are provided on the command line, author and committer information is taken from the following environment variables, if set:</source>
          <target state="translated">虽然父对象的id是在命令行中提供的,但作者和提交者的信息来自于以下环境变量(如果设置了)。</target>
        </trans-unit>
        <trans-unit id="7921bb694427f6298ff631684ef33f9b3436be57" translate="yes" xml:space="preserve">
          <source>While you are in the middle of working on something complicated, you find an unrelated but obvious and trivial bug. You would like to fix it before continuing. You can use &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; to save the current state of your work, and after fixing the bug (or, optionally after doing so on a different branch and then coming back), unstash the work-in-progress changes.</source>
          <target state="translated">在您从事复杂工作的过程中，您会发现一个不相关但明显而琐碎的错误。您想先修复它，然后再继续。您可以使用&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;保存工作的当前状态，并在修复了错误之后（或者，可以选择在其他分支上执行此错误，然后再返回），然后取消存储进行中的更改。</target>
        </trans-unit>
        <trans-unit id="aa47dd8a2f0ebe83c1c9e1c5b54451eb489a4bd1" translate="yes" xml:space="preserve">
          <source>Whitespace separated fields; any run of whitespace can be used as field separator (rules for Perl&amp;rsquo;s &quot;&lt;code&gt;split(&quot; &quot;, $line)&lt;/code&gt;&quot;).</source>
          <target state="translated">空格分隔的字段；任何空格都可以用作字段分隔符（Perl的&amp;ldquo; &lt;code&gt;split(&quot; &quot;, $line)&lt;/code&gt; &amp;ldquo;规则）。</target>
        </trans-unit>
        <trans-unit id="863aeb0371f511e273bc66c19d53b7877f38ac8a" translate="yes" xml:space="preserve">
          <source>Whitespace-separated list of allowed SMTP-AUTH mechanisms. This setting forces using only the listed mechanisms. Example:</source>
          <target state="translated">以空格分隔的允许的SMTP-AUTH机制列表。此设置只强制使用列出的机制。例如:</target>
        </trans-unit>
        <trans-unit id="389ff74463b52646838e41646e64e38a902b85eb" translate="yes" xml:space="preserve">
          <source>Why bisecting merge commits can be harder than bisecting linear history</source>
          <target state="translated">为什么二分合并提交比二分线性历史更难?</target>
        </trans-unit>
        <trans-unit id="d83d7d2d8de91edadaae0bc956ce69ac2202b5c1" translate="yes" xml:space="preserve">
          <source>Why do I have a file that&amp;rsquo;s always modified?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae988a6589a0546387522087a0861a61e3e4225" translate="yes" xml:space="preserve">
          <source>Wildcards in the pattern such as &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; are treated as literal characters.</source>
          <target state="translated">模式中的通配符，例如 &lt;code&gt;*&lt;/code&gt; 或 &lt;code&gt;?&lt;/code&gt; 被视为文字字符。</target>
        </trans-unit>
        <trans-unit id="af4b569cb0fc1bae5a933e3532b964dc5d61facd" translate="yes" xml:space="preserve">
          <source>Will copy all files listed from the index to the working directory (not overwriting existing files).</source>
          <target state="translated">将把索引中列出的所有文件复制到工作目录中(不覆盖现有文件)。</target>
        </trans-unit>
        <trans-unit id="712e5286413fd90307ff92f23e110885525f2bb8" translate="yes" xml:space="preserve">
          <source>Will fail unless you manually run &lt;code&gt;git fetch origin-push&lt;/code&gt;. This method is of course entirely defeated by something that runs &lt;code&gt;git fetch
--all&lt;/code&gt;, in that case you&amp;rsquo;d need to either disable it or do something more tedious like:</source>
          <target state="translated">除非您手动运行 &lt;code&gt;git fetch origin-push&lt;/code&gt; ,否则它将失败。当然，此方法完全被运行 &lt;code&gt;git fetch --all&lt;/code&gt; 的东西所击败，在这种情况下，您需要禁用它或做一些更乏味的事情，例如：</target>
        </trans-unit>
        <trans-unit id="bfd8a0b8d0916903c6596ed358a3cc07670d304e" translate="yes" xml:space="preserve">
          <source>Windows-only: allow redirecting the standard input/output/error handles to paths specified by the environment variables. This is particularly useful in multi-threaded applications where the canonical way to pass standard handles via &lt;code&gt;CreateProcess()&lt;/code&gt; is not an option because it would require the handles to be marked inheritable (and consequently &lt;strong&gt;every&lt;/strong&gt; spawned process would inherit them, possibly blocking regular Git operations). The primary intended use case is to use named pipes for communication (e.g. &lt;code&gt;\\.\pipe\my-git-stdin-123&lt;/code&gt;).</source>
          <target state="translated">仅限Windows：允许将标准输入/输出/错误句柄重定向到环境变量指定的路径。这在多线程应用程序中特别有用，在该应用程序中，不能通过 &lt;code&gt;CreateProcess()&lt;/code&gt; 传递标准句柄的规范方法是可选的，因为它将要求将句柄标记为可继承（因此，&lt;strong&gt;每个&lt;/strong&gt;生成的进程都将继承它们，从而可能阻止常规的Git操作） ）。主要的预期用例是使用命名管道进行通信（例如 &lt;code&gt;\\.\pipe\my-git-stdin-123&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9c510c80ca0db551792868481dfce7936d126272" translate="yes" xml:space="preserve">
          <source>Windows-only: comma-separated list of environment variables' names that need to be unset before spawning any other process. Defaults to &lt;code&gt;PERL5LIB&lt;/code&gt; to account for the fact that Git for Windows insists on using its own Perl interpreter.</source>
          <target state="translated">仅限Windows：用逗号分隔的环境变量名称列表，需要在产生任何其他进程之前取消设置。默认值是 &lt;code&gt;PERL5LIB&lt;/code&gt; ,以说明Git for Windows坚持使用自己的Perl解释器的事实。</target>
        </trans-unit>
        <trans-unit id="e74f053e0d02cafdbd0bbd14c65f9fd314f00d13" translate="yes" xml:space="preserve">
          <source>Windows-only: override whether spawned processes inherit only standard file handles (&lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;) or all handles. Can be &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Defaults to &lt;code&gt;auto&lt;/code&gt;, which means &lt;code&gt;true&lt;/code&gt; on Windows 7 and later, and &lt;code&gt;false&lt;/code&gt; on older Windows versions.</source>
          <target state="translated">仅限Windows：覆盖生成的进程仅继承标准文件句柄（ &lt;code&gt;stdin&lt;/code&gt; ， &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; ）还是继承所有句柄。可以是 &lt;code&gt;auto&lt;/code&gt; ， &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。默认为 &lt;code&gt;auto&lt;/code&gt; ，这意味着在Windows 7及更高版本上为 &lt;code&gt;true&lt;/code&gt; ，在较早的Windows版本上为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="949442d2f0c16b026f680dbb7df65e881242333c" translate="yes" xml:space="preserve">
          <source>With --abbrev set to 0, the command can be used to find the closest tagname without any suffix:</source>
          <target state="translated">当 --abbrev 设置为 0 时,该命令可以用来寻找最接近的 tagname,不需要任何后缀。</target>
        </trans-unit>
        <trans-unit id="a158e0380ec8b734a269ad9d0f52eb5eb98f2274" translate="yes" xml:space="preserve">
          <source>With --all, the command can use branch heads as references, so the output shows the reference path as well:</source>
          <target state="translated">使用--all,命令可以使用分支头作为引用,所以输出也会显示引用路径。</target>
        </trans-unit>
        <trans-unit id="65ee9a1948ccba3bbf4e1e0783ded1eb1bf032c9" translate="yes" xml:space="preserve">
          <source>With --batch or --batch-check, follow symlinks inside the repository when requesting objects with extended SHA-1 expressions of the form tree-ish:path-in-tree. Instead of providing output about the link itself, provide output about the linked-to object. If a symlink points outside the tree-ish (e.g. a link to /foo or a root-level link to ../foo), the portion of the link which is outside the tree will be printed.</source>
          <target state="translated">使用 --batch 或 --batch-check,当请求使用扩展的 SHA-1 表达式(形式为 tree-ish:path-in-tree)的对象时,可以在版本库中跟踪符号链接。不提供关于链接本身的输出,而是提供关于链接到的对象的输出。如果一个符号链接指向树状结构之外(例如指向/foo的链接或指向./foo的根级链接),那么树状结构之外的链接部分将被打印出来。</target>
        </trans-unit>
        <trans-unit id="4f48f3dcfb8092537ede5a515e981d6e213aeb9f" translate="yes" xml:space="preserve">
          <source>With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing.</source>
          <target state="translated">使用--no-commit执行合并,并在创建合并提交前停止,让用户在提交前有机会检查并进一步调整合并结果。</target>
        </trans-unit>
        <trans-unit id="3e8c9cc261afe4f0a3a9c88b1d66c9688df929d7" translate="yes" xml:space="preserve">
          <source>With --no-log do not list one-line descriptions from the actual commits being merged.</source>
          <target state="translated">使用--no-log时,不列出实际提交中的单行描述。</target>
        </trans-unit>
        <trans-unit id="e1adfa5cefd427bf7d3a2a21965629dcaf3c3388" translate="yes" xml:space="preserve">
          <source>With --no-signoff do not add a Signed-off-by line.</source>
          <target state="translated">使用--no-signoff时,不添加Signed-off-by行。</target>
        </trans-unit>
        <trans-unit id="268060b1be32cd8bc70e7e3bb40c821b809c90c3" translate="yes" xml:space="preserve">
          <source>With --no-squash perform the merge and commit the result. This option can be used to override --squash.</source>
          <target state="translated">使用 --no-squash 执行合并并提交结果。这个选项可以用来覆盖--squash。</target>
        </trans-unit>
        <trans-unit id="2060c61f3742702f58530c81f5eefb302aeb60c1" translate="yes" xml:space="preserve">
          <source>With --squash, --commit is not allowed, and will fail.</source>
          <target state="translated">使用--squash,--commit是不允许的,而且会失败。</target>
        </trans-unit>
        <trans-unit id="865b225dd999d9769e36118a7e13e933131732f5" translate="yes" xml:space="preserve">
          <source>With -n or --no-stat do not show a diffstat at the end of the merge.</source>
          <target state="translated">使用-n或--no-stat在合并结束时不显示diffstat。</target>
        </trans-unit>
        <trans-unit id="008f5911b332311009571603d4810039f3b0a542" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--add&lt;/code&gt;, instead of changing existing URLs, new URL is added.</source>
          <target state="translated">使用 &lt;code&gt;--add&lt;/code&gt; ，而不是更改现有URL，而是添加新URL。</target>
        </trans-unit>
        <trans-unit id="6b50c366c66c543504b13b437403fc08b0e99b0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--add&lt;/code&gt;, instead of replacing the list of currently tracked branches, adds to that list.</source>
          <target state="translated">使用 &lt;code&gt;--add&lt;/code&gt; ，而不是替换当前跟踪的分支列表，而是添加到该列表。</target>
        </trans-unit>
        <trans-unit id="b5c6ad97197083d8f93283087955bd70bd89f95f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--all&lt;/code&gt; flag, all refs that exist locally are transferred to the remote side. You cannot specify any &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; if you use this flag.</source>
          <target state="translated">使用 &lt;code&gt;--all&lt;/code&gt; 标志，本地存在的所有引用都将传输到远程端。如果使用此标志，则不能指定任何 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="487cd0ed38992f1c8c21d61869ab0ba8c9131e91" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--all&lt;/code&gt;, all URLs for the remote will be listed.</source>
          <target state="translated">使用 &lt;code&gt;--all&lt;/code&gt; ，将列出远程的所有URL。</target>
        </trans-unit>
        <trans-unit id="ea729f224a85b66147f6e662a1c5d14a2abdd751" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--contains&lt;/code&gt;, shows only the branches that contain the named commit (in other words, the branches whose tip commits are descendants of the named commit), &lt;code&gt;--no-contains&lt;/code&gt; inverts it. With &lt;code&gt;--merged&lt;/code&gt;, only branches merged into the named commit (i.e. the branches whose tip commits are reachable from the named commit) will be listed. With &lt;code&gt;--no-merged&lt;/code&gt; only branches not merged into the named commit will be listed. If the &amp;lt;commit&amp;gt; argument is missing it defaults to &lt;code&gt;HEAD&lt;/code&gt; (i.e. the tip of the current branch).</source>
          <target state="translated">使用 &lt;code&gt;--contains&lt;/code&gt; ，仅显示包含命名提交的分支（换句话说，其尖端提交是命名提交的后代的分支），-- &lt;code&gt;--no-contains&lt;/code&gt; 反转。使用 &lt;code&gt;--merged&lt;/code&gt; ，将仅列出合并到命名提交中的分支（即，可以从命名提交到达其尖端提交的分支）。使用 &lt;code&gt;--no-merged&lt;/code&gt; ,将仅列出未合并到命名提交中的分支。如果缺少&amp;lt;commit&amp;gt;参数，则默认为 &lt;code&gt;HEAD&lt;/code&gt; （即当前分支的尖端）。</target>
        </trans-unit>
        <trans-unit id="a1afc8d7fd506e98e5a974a8f26c84b23238fb92" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create-reflog&lt;/code&gt;, update-ref will create a reflog for each ref even if one would not ordinarily be created.</source>
          <target state="translated">使用 &lt;code&gt;--create-reflog&lt;/code&gt; ，即使通常不会创建一个引用，update-ref也会为每个引用创建一个引用日志。</target>
        </trans-unit>
        <trans-unit id="7fef88021ca55186dc4070339cc8624e9a30485c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--delete&lt;/code&gt;, instead of changing existing URLs, all URLs matching regex &amp;lt;url&amp;gt; are deleted for remote &amp;lt;name&amp;gt;. Trying to delete all non-push URLs is an error.</source>
          <target state="translated">使用 &lt;code&gt;--delete&lt;/code&gt; ，而不是更改现有URL，将删除所有与正则表达式&amp;lt;url&amp;gt;匹配的URL，以用于远程&amp;lt;name&amp;gt;。尝试删除所有非推送URL是一个错误。</target>
        </trans-unit>
        <trans-unit id="30918cb51e4372be35c787127ec3b8958bb72e8d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--dry-run&lt;/code&gt; option, report what branches will be pruned, but do not actually prune them.</source>
          <target state="translated">使用 &lt;code&gt;--dry-run&lt;/code&gt; 选项，报告将修剪哪些分支，但实际上不修剪它们。</target>
        </trans-unit>
        <trans-unit id="e4cd9a1b8d31ddff1298b3b28b732552e240fb7a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--dry-run&lt;/code&gt; option, report what branches would be pruned, but do not actually prune them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5189cda6779864f8bd2f5726b39c4529ff52ddf8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--ff-only&lt;/code&gt;, resolve the merge as a fast-forward when possible. When not possible, refuse to merge and exit with a non-zero status.</source>
          <target state="translated">使用 &lt;code&gt;--ff-only&lt;/code&gt; ，在可能的情况下将合并解析为快进。如果不可能，请拒绝合并并以非零状态退出。</target>
        </trans-unit>
        <trans-unit id="7e8f4fddd68a3a89ff49906c538a7ca7b5ef9dea" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--ff&lt;/code&gt;, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit). When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.</source>
          <target state="translated">使用 &lt;code&gt;--ff&lt;/code&gt; ，尽可能将合并解析为快进（仅更新分支指针以匹配合并的分支；不创建合并提交）。如果不可能（当合并的历史记录不是当前历史记录的后代时），请创建合并提交。</target>
        </trans-unit>
        <trans-unit id="1362a77896d8f49d16b2f9c5015389cf3c365072" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--force&lt;/code&gt;, the fast-forward check is disabled for all refs.</source>
          <target state="translated">使用 &lt;code&gt;--force&lt;/code&gt; ，将禁用所有引用的快进检查。</target>
        </trans-unit>
        <trans-unit id="ba76b155ec3c447a87cfd160419204d256e0f486" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--keep-cr&lt;/code&gt;, call &lt;code&gt;git mailsplit&lt;/code&gt; (see &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit[1]&lt;/a&gt;) with the same option, to prevent it from stripping CR at the end of lines. &lt;code&gt;am.keepcr&lt;/code&gt; configuration variable can be used to specify the default behaviour. &lt;code&gt;--no-keep-cr&lt;/code&gt; is useful to override &lt;code&gt;am.keepcr&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;--keep-cr&lt;/code&gt; ，使用相同的选项调用 &lt;code&gt;git mailsplit&lt;/code&gt; （请参阅&lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit [1]&lt;/a&gt;），以防止它在行尾剥离CR。 &lt;code&gt;am.keepcr&lt;/code&gt; 配置变量可用于指定默认行为。 &lt;code&gt;--no-keep-cr&lt;/code&gt; 对于覆盖 &lt;code&gt;am.keepcr&lt;/code&gt; 很有用。</target>
        </trans-unit>
        <trans-unit id="22e7d426b38d094430582cb84fc0432b42834058" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--no-ff&lt;/code&gt;, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward.</source>
          <target state="translated">使用 &lt;code&gt;--no-ff&lt;/code&gt; ，即使在合并可以替代为快进的情况下，也可以在所有情况下创建合并提交。</target>
        </trans-unit>
        <trans-unit id="5aa5b8e96804090cb89f3aab6cdc283e2c00d87e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--no-tags&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; does not import tags from the remote repository.</source>
          <target state="translated">使用 &lt;code&gt;--no-tags&lt;/code&gt; 选项， &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 不会从远程存储库导入标签。</target>
        </trans-unit>
        <trans-unit id="37eed19521c790d78f1c0615d39722d6298a6cc8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--patch&lt;/code&gt;, you can interactively select hunks from the diff between HEAD and the working tree to be stashed. The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">使用 &lt;code&gt;--patch&lt;/code&gt; ，您可以从HEAD与要隐藏的工作树之间的差异中交互选择块。存储项的构造应使其索引状态与存储库的索引状态相同，并且其工作树仅包含交互式选择的更改。然后，所选更改将从工作树中回滚。请参阅&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;的&amp;ldquo;交互模式&amp;rdquo;部分，以了解如何操作 &lt;code&gt;--patch&lt;/code&gt; 模式。</target>
        </trans-unit>
        <trans-unit id="8d4d7e74d0f493c9b38977e43daed9cfd8d04693" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--pretty&lt;/code&gt; format other than &lt;code&gt;oneline&lt;/code&gt; and &lt;code&gt;reference&lt;/code&gt; (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as &lt;code&gt;ref@{Nth}&lt;/code&gt; (where &lt;code&gt;Nth&lt;/code&gt; is the reverse-chronological index in the reflog) or as &lt;code&gt;ref@{timestamp}&lt;/code&gt; (with the timestamp for that entry), depending on a few rules:</source>
          <target state="translated">使用 &lt;code&gt;--pretty&lt;/code&gt; 格式而不是 &lt;code&gt;oneline&lt;/code&gt; 和 &lt;code&gt;reference&lt;/code&gt; （出于明显的原因），这会导致输出从reflog中获取两行额外的信息。根据一些规则，输出中的reflog指示符可能显示为 &lt;code&gt;ref@{Nth}&lt;/code&gt; （其中 &lt;code&gt;Nth&lt;/code&gt; 是reflog中的倒序索引）或 &lt;code&gt;ref@{timestamp}&lt;/code&gt; （具有该条目的时间戳）。</target>
        </trans-unit>
        <trans-unit id="35b7bcaa0d1a12c16e7ebe5749afd0aa0913b69d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--prune&lt;/code&gt; option, run pruning against all the remotes that are updated.</source>
          <target state="translated">使用 &lt;code&gt;--prune&lt;/code&gt; 选项，对所有已更新的远程运行修剪。</target>
        </trans-unit>
        <trans-unit id="9a993d0e8bfe45705897018a009a33a68fb547fb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--push&lt;/code&gt;, push URLs are manipulated instead of fetch URLs.</source>
          <target state="translated">使用 &lt;code&gt;--push&lt;/code&gt; ，将操纵推入URL而不是获取URL。</target>
        </trans-unit>
        <trans-unit id="d0c8d67cd6d67334176bbc781201963c60a05697" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--push&lt;/code&gt;, push URLs are queried rather than fetch URLs.</source>
          <target state="translated">使用 &lt;code&gt;--push&lt;/code&gt; ，查询的是推送URL，而不是获取URL。</target>
        </trans-unit>
        <trans-unit id="a26943d9e66efe8045d055005cf22b61dc280b47" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--stdin&lt;/code&gt;, update-ref reads instructions from standard input and performs all modifications together. Specify commands of the form:</source>
          <target state="translated">使用 &lt;code&gt;--stdin&lt;/code&gt; ，update-ref从标准输入读取指令，并一起执行所有修改。指定格式的命令：</target>
        </trans-unit>
        <trans-unit id="46644e8c0f7ae9adba68ae4958242044a646f477" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--tags&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; imports every tag from the remote repository.</source>
          <target state="translated">使用 &lt;code&gt;--tags&lt;/code&gt; 选项， &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 从远程存储库导入每个标签。</target>
        </trans-unit>
        <trans-unit id="9afd8cc2d67d37867f3891e80c5ed22f0441334c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--topo-order&lt;/code&gt;, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together.</source>
          <target state="translated">使用 &lt;code&gt;--topo-order&lt;/code&gt; ，它们将显示8 6 5 3 7 4 2 1（或8 7 4 2 6 5 3 1）；为了避免显示来自两个并行开发轨道的提交混合在一起，在较新的提交之前显示一些较旧的提交。</target>
        </trans-unit>
        <trans-unit id="bbe3bdb143c872f8bc3522bea317a2ad84af9235" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--auto&lt;/code&gt;, the remote is queried to determine its &lt;code&gt;HEAD&lt;/code&gt;, then the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set to the same branch. e.g., if the remote &lt;code&gt;HEAD&lt;/code&gt; is pointed at &lt;code&gt;next&lt;/code&gt;, &quot;&lt;code&gt;git remote set-head origin -a&lt;/code&gt;&quot; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/next&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">使用 &lt;code&gt;-a&lt;/code&gt; 或 &lt;code&gt;--auto&lt;/code&gt; ，查询远程以确定其 &lt;code&gt;HEAD&lt;/code&gt; ，然后将符号引用 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 设置到同一分支。例如，如果远程 &lt;code&gt;HEAD&lt;/code&gt; 指向 &lt;code&gt;next&lt;/code&gt; ，则&amp;ldquo; &lt;code&gt;git remote set-head origin -a&lt;/code&gt; &amp;rdquo;会将symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; 设置为 &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; 。仅当 &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; 已经存在时，这才起作用。如果不是，则必须先获取它。</target>
        </trans-unit>
        <trans-unit id="ca79465e71cd43be9bc8a1c0daf2d4aececc9880" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--auto&lt;/code&gt;, the remote is queried to determine its &lt;code&gt;HEAD&lt;/code&gt;, then the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set to the same branch. e.g., if the remote &lt;code&gt;HEAD&lt;/code&gt; is pointed at &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;git remote set-head origin -a&lt;/code&gt; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/next&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f69d8ea721996a0e954b69bd77400aaa01f9c55" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-d&lt;/code&gt; flag, it deletes the named &amp;lt;ref&amp;gt; after verifying it still contains &amp;lt;oldvalue&amp;gt;.</source>
          <target state="translated">使用 &lt;code&gt;-d&lt;/code&gt; 标志，它在验证命名的&amp;lt;ref&amp;gt;仍然包含&amp;lt;oldvalue&amp;gt;后将其删除。</target>
        </trans-unit>
        <trans-unit id="da9e1b9da40421df76a154165f2b54d479838ea5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;--delete&lt;/code&gt;, the symbolic ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is deleted.</source>
          <target state="translated">使用 &lt;code&gt;-d&lt;/code&gt; 或 &lt;code&gt;--delete&lt;/code&gt; ，将删除符号ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b0b5064fe468e227911615a2b7fcbafb431eef7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-f&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; is run immediately after the remote information is set up.</source>
          <target state="translated">使用 &lt;code&gt;-f&lt;/code&gt; 选项，在设置远程信息后立即运行 &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c11581a6169e0a17084bd502989c1df6d5ff9b6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-m &amp;lt;master&amp;gt;&lt;/code&gt; option, a symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set up to point at remote&amp;rsquo;s &lt;code&gt;&amp;lt;master&amp;gt;&lt;/code&gt; branch. See also the set-head command.</source>
          <target state="translated">使用 &lt;code&gt;-m &amp;lt;master&amp;gt;&lt;/code&gt; 选项，可以将符号引用 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 设置为指向remote的 &lt;code&gt;&amp;lt;master&amp;gt;&lt;/code&gt; 分支。另请参见set-head命令。</target>
        </trans-unit>
        <trans-unit id="734f06f2f4ad450ab9efcf1cd7537f18bb0a22f5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-n&lt;/code&gt; option, the remote heads are not queried first with &lt;code&gt;git ls-remote &amp;lt;name&amp;gt;&lt;/code&gt;; cached information is used instead.</source>
          <target state="translated">使用 &lt;code&gt;-n&lt;/code&gt; 选项，不首先使用 &lt;code&gt;git ls-remote &amp;lt;name&amp;gt;&lt;/code&gt; 查询远程头；而是使用缓存的信息。</target>
        </trans-unit>
        <trans-unit id="dd75e538fb39d452e807a34068040583ee9147bc" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; option, instead of the default glob refspec for the remote to track all branches under the &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/&lt;/code&gt; namespace, a refspec to track only &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is created. You can give more than one &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; to track multiple branches without grabbing all branches.</source>
          <target state="translated">使用 &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; 选项，代替用于跟踪 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/&lt;/code&gt; 名称空间下所有分支的远程默认glob refspec，将创建仅跟踪 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 的refspec 。您可以指定多个 &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; 来跟踪多个分支，而不用抓住所有分支。</target>
        </trans-unit>
        <trans-unit id="3a17d1e0c132aee2d2be1ec1ea02b9a88fab2a36" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, a new trailer will be added, even if some trailers with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair are already in the message.</source>
          <target state="translated">使用 &lt;code&gt;add&lt;/code&gt; ，即使消息中已经有一些具有相同（&amp;lt;token&amp;gt;，&amp;lt;value&amp;gt;）对的预告片，也会添加新的预告片。</target>
        </trans-unit>
        <trans-unit id="bdb99f7baa9796a7b973194e1a5ab4a7e3d82b92" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, a new trailer will be added.</source>
          <target state="translated">使用 &lt;code&gt;add&lt;/code&gt; ，将添加一个新的预告片。</target>
        </trans-unit>
        <trans-unit id="3d04d4d1926f980c37f6ca9761913ed7f096d165" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, create a new branch named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; starting at &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, and check out &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; into the new working tree. If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;. By default, &lt;code&gt;-b&lt;/code&gt; refuses to create a new branch if it already exists. &lt;code&gt;-B&lt;/code&gt; overrides this safeguard, resetting &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b61b0983644b0774834807009f4d278bb642b5a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, create a new branch named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; starting at &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, and check out &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; into the new working tree. If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted, it defaults to HEAD. By default, &lt;code&gt;-b&lt;/code&gt; refuses to create a new branch if it already exists. &lt;code&gt;-B&lt;/code&gt; overrides this safeguard, resetting &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">随着 &lt;code&gt;add&lt;/code&gt; ，创建一个名为新分支 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 开始 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; ，并检查了 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 进入新的工作树。如果省略 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; ，则默认为HEAD。缺省情况下， &lt;code&gt;-b&lt;/code&gt; 拒绝创建新分支（如果已存在）。 &lt;code&gt;-B&lt;/code&gt; 覆盖此保护措施，将 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 重置为 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d424a0ce9af1bab4df82ba9ed9c152743e40b774" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, detach &lt;code&gt;HEAD&lt;/code&gt; in the new working tree. See &quot;DETACHED HEAD&quot; in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a273ddd960841784db1a589aad98c4feff6c226" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, detach HEAD in the new working tree. See &quot;DETACHED HEAD&quot; in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;add&lt;/code&gt; ，将HEAD分离到新的工作树中。参见&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]中的&lt;/a&gt; &amp;ldquo; DETACHED HEAD&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="187a01bfec37522a00b693f68238b703a4e0897c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, suppress feedback messages.</source>
          <target state="translated">使用 &lt;code&gt;add&lt;/code&gt; ，抑制反馈消息。</target>
        </trans-unit>
        <trans-unit id="45995ca3706219a58e816f38cd1d9bf0922ce8ca" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;addIfDifferent&lt;/code&gt;, a new trailer will be added only if no trailer with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair is already in the message.</source>
          <target state="translated">使用 &lt;code&gt;addIfDifferent&lt;/code&gt; ，仅当消息中不存在具有相同（&amp;lt;token&amp;gt;，&amp;lt;value&amp;gt;）对的预告片时，才会添加新的预告片。</target>
        </trans-unit>
        <trans-unit id="6e3bd24c09b16e87e69f4ad565a18cc8f733f593" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt;, a new trailer will be added only if no trailer with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair is above or below the line where the new trailer will be added.</source>
          <target state="translated">使用 &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; 时，仅当没有新的预告片具有相同（&amp;lt;token&amp;gt;，&amp;lt;value&amp;gt;）对时，才会添加新的预告片。</target>
        </trans-unit>
        <trans-unit id="c538516bcb20191b3fc9da51228fff3eefb68cdf" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;doNothing&lt;/code&gt;, nothing will be done.</source>
          <target state="translated">使用 &lt;code&gt;doNothing&lt;/code&gt; ，将不会执行任何操作。</target>
        </trans-unit>
        <trans-unit id="91898a3512235050c32c7a99a50c8394d7a8397d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;doNothing&lt;/code&gt;, nothing will be done; that is no new trailer will be added if there is already one with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">使用 &lt;code&gt;doNothing&lt;/code&gt; ，什么也做不了；如果消息中已经存在具有相同&amp;lt;token&amp;gt;的预告片，则不会添加新预告片。</target>
        </trans-unit>
        <trans-unit id="fafece11b5178185f0dda98fe61f1218eca3ec1e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; (or variants thereof, e.g. with &lt;code&gt;--cover-letter&lt;/code&gt; or using &lt;code&gt;Z..C&lt;/code&gt; instead of &lt;code&gt;-3 C&lt;/code&gt; to specify the range), the base tree information block is shown at the end of the first message the command outputs (either the first patch, or the cover letter), like this:</source>
          <target state="translated">使用 &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; （或其变体，例如，使用 &lt;code&gt;--cover-letter&lt;/code&gt; 或使用 &lt;code&gt;Z..C&lt;/code&gt; 代替 &lt;code&gt;-3 C&lt;/code&gt; 来指定范围）时，基本树信息块显示为命令输出的第一条消息的末尾（第一个补丁或求职信），如下所示：</target>
        </trans-unit>
        <trans-unit id="0dbfc249aea522f6a40d4b8be190d1fc0f0eadd8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;list&lt;/code&gt;, output in an easy-to-parse format for scripts. This format will remain stable across Git versions and regardless of user configuration. See below for details.</source>
          <target state="translated">使用 &lt;code&gt;list&lt;/code&gt; ，以易于解析的格式输出脚本。无论用户配置如何，此格式在Git版本之间都将保持稳定。有关详情，请参见下文。</target>
        </trans-unit>
        <trans-unit id="021957faebf0fa8a6ba6fb4276abb6b8c72afba9" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;lock&lt;/code&gt;, an explanation why the working tree is locked.</source>
          <target state="translated">使用 &lt;code&gt;lock&lt;/code&gt; ，说明工作树被锁定的原因。</target>
        </trans-unit>
        <trans-unit id="bbe63cab2529b193584b4f7d1c86ee0207fc9968" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, do not remove anything; just report what it would remove.</source>
          <target state="translated">使用 &lt;code&gt;prune&lt;/code&gt; 时，请勿移除任何东西；只需报告将删除的内容即可。</target>
        </trans-unit>
        <trans-unit id="97f5cdb302d7f0a46689004724feb3d1aca29383" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, only expire unused working trees older than &amp;lt;time&amp;gt;.</source>
          <target state="translated">使用 &lt;code&gt;prune&lt;/code&gt; 时，只会使早于&amp;lt;time&amp;gt;的未使用的工作树过期。</target>
        </trans-unit>
        <trans-unit id="fe3d9726d2a7e550ec17d9d6b1b3e9e51367506e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, only expire unused working trees older than &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ffa86e9306849b846038bae2a07ad322d0f86c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, report all removals.</source>
          <target state="translated">使用 &lt;code&gt;prune&lt;/code&gt; ，报告所有删除。</target>
        </trans-unit>
        <trans-unit id="f6631b122f785beeb20cb0ef884a421b144138ae" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;replace&lt;/code&gt;, an existing trailer with the same &amp;lt;token&amp;gt; will be deleted and the new trailer will be added. The deleted trailer will be the closest one (with the same &amp;lt;token&amp;gt;) to the place where the new one will be added.</source>
          <target state="translated">使用 &lt;code&gt;replace&lt;/code&gt; ，将删除具有相同&amp;lt;token&amp;gt;的现有预告片，并添加新的预告片。删除的预告片将是最接近的预告片（具有相同的&amp;lt;token&amp;gt;），该位置将添加新的预告片。</target>
        </trans-unit>
        <trans-unit id="a80ff1485c839f0e248b3acec4853d6b6aaf0d80" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt;, without &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, instead of creating a new branch from &lt;code&gt;HEAD&lt;/code&gt;, if there exists a tracking branch in exactly one remote matching the basename of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as &quot;upstream&quot; from the new branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b787c22358696a7fd63895c838388aed6d7912a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt;, without &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, instead of creating a new branch from HEAD, if there exists a tracking branch in exactly one remote matching the basename of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as &quot;upstream&quot; from the new branch.</source>
          <target state="translated">使用工作 &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt; ，而不使用 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; ，而不是从HEAD创建新分支，如果在与 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 的基本名称完全匹配的一个远程中存在跟踪分支，则将新分支基于远程跟踪分支，并将远程跟踪分支标记为新分支的&amp;ldquo;上游&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="660d18378dc3af084a2ac18df92d87c9aea68c5a" translate="yes" xml:space="preserve">
          <source>With Git bisect it&amp;rsquo;s a breeze: in the best case i can get a ~15 step kernel bisection done in 20-30 minutes, in an automated way. Even with manual help or when bisecting multiple, overlapping bugs, it&amp;rsquo;s rarely more than an hour.</source>
          <target state="translated">使用Git bisect轻而易举：在最佳情况下，我可以在20-30分钟内以自动化方式完成〜15步的内核二分法。即使有了手动帮助，或者将多个重叠的错误一分为二，也很少超过一个小时。</target>
        </trans-unit>
        <trans-unit id="46d101f0f209ac246ff187c45b6b808668e526b7" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;-D&lt;/code&gt; option, &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; will be deleted. You may specify more than one branch for deletion. If the branch currently has a reflog then the reflog will also be deleted.</source>
          <target state="translated">使用 &lt;code&gt;-d&lt;/code&gt; 或 &lt;code&gt;-D&lt;/code&gt; 选项，将删除 &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; 。您可以指定多个分支进行删除。如果分支当前有一个参考日志，则该参考日志也将被删除。</target>
        </trans-unit>
        <trans-unit id="f74d36fd60998cbf589b7f2b7f7bc156998c0334" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-M&lt;/code&gt; option, &amp;lt;oldbranch&amp;gt; will be renamed to &amp;lt;newbranch&amp;gt;. If &amp;lt;oldbranch&amp;gt; had a corresponding reflog, it is renamed to match &amp;lt;newbranch&amp;gt;, and a reflog entry is created to remember the branch renaming. If &amp;lt;newbranch&amp;gt; exists, -M must be used to force the rename to happen.</source>
          <target state="translated">使用 &lt;code&gt;-m&lt;/code&gt; 或 &lt;code&gt;-M&lt;/code&gt; 选项，&amp;lt;oldbranch&amp;gt;将重命名为&amp;lt;newbranch&amp;gt;。如果&amp;lt;oldbranch&amp;gt;具有相应的引用日志，则将其重命名为与&amp;lt;newbranch&amp;gt;匹配，并创建一个引用日志条目以记住分支重命名。如果&amp;lt;newbranch&amp;gt;存在，则必须使用-M强制进行重命名。</target>
        </trans-unit>
        <trans-unit id="078f9b93867e54fc6fd5cb6cccb717d173a4bdbb" translate="yes" xml:space="preserve">
          <source>With a small group, developers may just pull changes from each other&amp;rsquo;s repositories without the need for a central maintainer.</source>
          <target state="translated">在一个小组的情况下，开发人员可以从彼此的存储库中提取更改，而无需中央维护者。</target>
        </trans-unit>
        <trans-unit id="d93af44627c4056a70413d4d1086a466c1eb6057" translate="yes" xml:space="preserve">
          <source>With an optional &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; argument, use the ref to find the notes to display. The ref can specify the full refname when it begins with &lt;code&gt;refs/notes/&lt;/code&gt;; when it begins with &lt;code&gt;notes/&lt;/code&gt;, &lt;code&gt;refs/&lt;/code&gt; and otherwise &lt;code&gt;refs/notes/&lt;/code&gt; is prefixed to form a full name of the ref.</source>
          <target state="translated">通过可选的 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 参数，使用ref查找要显示的注释。当ref以 &lt;code&gt;refs/notes/&lt;/code&gt; 开头时，可以指定完整的refname ；当它与开始 &lt;code&gt;notes/&lt;/code&gt; ， &lt;code&gt;refs/&lt;/code&gt; 否则 &lt;code&gt;refs/notes/&lt;/code&gt; 前缀，以形成REF的全名。</target>
        </trans-unit>
        <trans-unit id="5888510f888416379a4d4b5651fc198f809cb1eb" translate="yes" xml:space="preserve">
          <source>With an optional argument, you can return to a different commit instead:</source>
          <target state="translated">通过一个可选参数,你可以返回到另一个提交。</target>
        </trans-unit>
        <trans-unit id="70761b9c0ed85e86f5fe4551851f4fb12dda8ef2" translate="yes" xml:space="preserve">
          <source>With centralized revision control systems this is often accomplished by including every module in one single repository. Developers can check out all modules or only the modules they need to work with. They can even modify files across several modules in a single commit while moving things around or updating APIs and translations.</source>
          <target state="translated">在集中式的修订控制系统中,这通常是通过将每个模块包含在一个单一的版本库中来实现的。开发人员可以查看所有模块,也可以只查看他们需要的模块,他们甚至可以在一次提交中修改多个模块的文件,同时移动东西或更新API和翻译。他们甚至可以在一次提交中修改多个模块的文件,同时移动东西或更新API和翻译。</target>
        </trans-unit>
        <trans-unit id="4c6d117a828bd4f381c3ccbd2807a5bac87363d5" translate="yes" xml:space="preserve">
          <source>With most hosting providers that support SSH, a single key pair uniquely identifies a user. Therefore, to use multiple accounts, it&amp;rsquo;s necessary to create a key pair for each account. If you&amp;rsquo;re using a reasonably modern OpenSSH version, you can create a new key pair with something like &lt;code&gt;ssh-keygen -t ed25519 -f ~/.ssh/id_committer&lt;/code&gt;. You can then register the public key (in this case, &lt;code&gt;~/.ssh/id_committer.pub&lt;/code&gt;; note the &lt;code&gt;.pub&lt;/code&gt;) with the hosting provider.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34547cdab6bbebc8d70f8627cf92ce4ed49693c0" translate="yes" xml:space="preserve">
          <source>With no arguments, shows a list of existing remotes. Several subcommands are available to perform operations on the remotes.</source>
          <target state="translated">无参数时,显示现有遥控器的列表。有几个子命令可以对遥控器进行操作。</target>
        </trans-unit>
        <trans-unit id="2d8eac222dcf5b2fb83219646b45ebbea55b5081" translate="yes" xml:space="preserve">
          <source>With no arguments, shows the status of existing submodules. Several subcommands are available to perform operations on the submodules.</source>
          <target state="translated">无参数时,显示现有子模块的状态。有几个子命令可以对子模块进行操作。</target>
        </trans-unit>
        <trans-unit id="2955e54fe9fa9b7446c513283cbd98f27b722daf" translate="yes" xml:space="preserve">
          <source>With no arguments, this will:</source>
          <target state="translated">在没有争论的情况下,这将。</target>
        </trans-unit>
        <trans-unit id="07ab1293ff3b475c814f1fed59da838b442b2582" translate="yes" xml:space="preserve">
          <source>With no options and no COMMAND or GUIDE given, the synopsis of the &lt;code&gt;git&lt;/code&gt; command and a list of the most commonly used Git commands are printed on the standard output.</source>
          <target state="translated">如果没有选项，也没有提供COMMAND或GUIDE，则 &lt;code&gt;git&lt;/code&gt; 命令的提要和最常用的Git命令的列表会打印在标准输出上。</target>
        </trans-unit>
        <trans-unit id="5afd0acc1bfdb6a1daab0a26aea947b62407909e" translate="yes" xml:space="preserve">
          <source>With something like git.git current tree, I get:</source>
          <target state="translated">用git.git current tree这样的东西,我得到了。</target>
        </trans-unit>
        <trans-unit id="48292de53da5a3060e12b426e889eefbf2d24e76" translate="yes" xml:space="preserve">
          <source>With that configuration the full path to browse repositories would be:</source>
          <target state="translated">有了这个配置,浏览仓库的完整路径将是。</target>
        </trans-unit>
        <trans-unit id="de963656527f9e7a6067d643ee4aa5bfca1b2d08" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--append&lt;/code&gt; option, include all commits that are present in the existing commit-graph file.</source>
          <target state="translated">使用 &lt;code&gt;--append&lt;/code&gt; 选项，包括现有提交图文件中存在的所有提交。</target>
        </trans-unit>
        <trans-unit id="14495f11a1a9217fb75c7d6db611a80cccd6e859" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--branch&lt;/code&gt; option, the command takes a name and checks if it can be used as a valid branch name (e.g. when creating a new branch). But be cautious when using the previous checkout syntax that may refer to a detached HEAD state. The rule &lt;code&gt;git check-ref-format --branch $name&lt;/code&gt; implements may be stricter than what &lt;code&gt;git check-ref-format refs/heads/$name&lt;/code&gt; says (e.g. a dash may appear at the beginning of a ref component, but it is explicitly forbidden at the beginning of a branch name). When run with &lt;code&gt;--branch&lt;/code&gt; option in a repository, the input is first expanded for the &amp;ldquo;previous checkout syntax&amp;rdquo; &lt;code&gt;@{-n}&lt;/code&gt;. For example, &lt;code&gt;@{-1}&lt;/code&gt; is a way to refer the last thing that was checked out using &quot;git switch&quot; or &quot;git checkout&quot; operation. This option should be used by porcelains to accept this syntax anywhere a branch name is expected, so they can act as if you typed the branch name. As an exception note that, the &amp;ldquo;previous checkout operation&amp;rdquo; might result in a commit object name when the N-th last thing checked out was not a branch.</source>
          <target state="translated">使用 &lt;code&gt;--branch&lt;/code&gt; 选项，该命令将使用一个名称，并检查它是否可以用作有效的分支名称（例如，在创建新分支时）。但是，在使用以前的可能指向分离的HEAD状态的签出语法时，请务必谨慎。该规则 &lt;code&gt;git check-ref-format --branch $name&lt;/code&gt; 工具可能会更严格比什么 &lt;code&gt;git check-ref-format refs/heads/$name&lt;/code&gt; 说（如破折号，可能会出现在裁判组件的开始，但它是明确分支名称的开头禁止）。在存储库中使用 &lt;code&gt;--branch&lt;/code&gt; 选项运行时，将首先针对&amp;ldquo;先前的检出语法&amp;rdquo; &lt;code&gt;@{-n}&lt;/code&gt; 扩展输入。例如， &lt;code&gt;@{-1}&lt;/code&gt; 是一种引用使用&amp;ldquo; git switch&amp;rdquo;或&amp;ldquo; git checkout&amp;rdquo;操作检出的最后一件东西的方法。瓷器应使用此选项在需要分支名称的任何地方接受此语法，以便它们可以像您键入分支名称一样起作用。作为例外，请注意，如果第N位不是签出分支，则&amp;ldquo;先前的签出操作&amp;rdquo;可能会导致提交对象名称。</target>
        </trans-unit>
        <trans-unit id="294719ccdfaa2864ec086fd6924ef46c18c6d01c" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--changed-paths&lt;/code&gt; option, compute and write information about the paths changed between a commit and its first parent. This operation can take a while on large repositories. It provides significant performance gains for getting history of a directory or a file with &lt;code&gt;git log -- &amp;lt;path&amp;gt;&lt;/code&gt;. If this option is given, future commit-graph writes will automatically assume that this option was intended. Use &lt;code&gt;--no-changed-paths&lt;/code&gt; to stop storing this data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac44a38e65d55dddeac740d3be63e38e85fa148" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--max-new-filters=&amp;lt;n&amp;gt;&lt;/code&gt; option, generate at most &lt;code&gt;n&lt;/code&gt; new Bloom filters (if &lt;code&gt;--changed-paths&lt;/code&gt; is specified). If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;, no limit is enforced. Only commits present in the new layer count against this limit. To retroactively compute Bloom filters over earlier layers, it is advised to use &lt;code&gt;--split=replace&lt;/code&gt;. Overrides the &lt;code&gt;commitGraph.maxNewFilters&lt;/code&gt; configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26f07033bd08bfdb6102afbc60e4bb690a51e35" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--reachable&lt;/code&gt; option, generate the new commit graph by walking commits starting at all refs. (Cannot be combined with &lt;code&gt;--stdin-commits&lt;/code&gt; or &lt;code&gt;--stdin-packs&lt;/code&gt;.)</source>
          <target state="translated">使用 &lt;code&gt;--reachable&lt;/code&gt; 选项，通过在所有引用处开始的提交来生成新的提交图。（不能与 &lt;code&gt;--stdin-commits&lt;/code&gt; 或 &lt;code&gt;--stdin-packs&lt;/code&gt; 结合使用。）</target>
        </trans-unit>
        <trans-unit id="bced3fa737464959bcb0c4d4992aedaa6293d7b5" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--shallow&lt;/code&gt; option, only check the tip commit-graph file in a chain of split commit-graphs.</source>
          <target state="translated">使用 &lt;code&gt;--shallow&lt;/code&gt; 选项，仅在分割的提交图链中检查提示提交图文件。</target>
        </trans-unit>
        <trans-unit id="023fb87ae200847a2eb976930adb7f7ff9a576bb" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--split&lt;/code&gt; option, write the commit-graph as a chain of multiple commit-graph files stored in &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt;. The new commits not already in the commit-graph are added in a new &quot;tip&quot; file. This file is merged with the existing file if the following merge conditions are met:</source>
          <target state="translated">使用 &lt;code&gt;--split&lt;/code&gt; 选项，将提交图写入存储在 &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt; 中的多个提交图文件链中。提交图中尚未包含的新提交将添加到新的&amp;ldquo;提示&amp;rdquo;文件中。如果满足以下合并条件，则此文件与现有文件合并：</target>
        </trans-unit>
        <trans-unit id="6bf69abea1fff62b20072adaab62de0f43e36b76" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--split[=&amp;lt;strategy&amp;gt;]&lt;/code&gt; option, write the commit-graph as a chain of multiple commit-graph files stored in &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt;. Commit-graph layers are merged based on the strategy and other splitting options. The new commits not already in the commit-graph are added in a new &quot;tip&quot; file. This file is merged with the existing file if the following merge conditions are met:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f402e69b2097f87a53ae26564ee053ba1f630ec" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-commits&lt;/code&gt; option, generate the new commit graph by walking commits starting at the commits specified in stdin as a list of OIDs in hex, one OID per line. (Cannot be combined with &lt;code&gt;--stdin-packs&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">使用 &lt;code&gt;--stdin-commits&lt;/code&gt; 选项，通过遍历从stdin中指定的提交（以十六进制的OID列表）开始的提交（每行一个OID）来生成新的提交图。（不能与 &lt;code&gt;--reachable&lt;/code&gt; &lt;code&gt;--stdin-packs&lt;/code&gt; 或--reachable结合使用。）</target>
        </trans-unit>
        <trans-unit id="4837cdd22ed59b809de4737c644da886aae1ea19" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-commits&lt;/code&gt; option, generate the new commit graph by walking commits starting at the commits specified in stdin as a list of OIDs in hex, one OID per line. OIDs that resolve to non-commits (either directly, or by peeling tags) are silently ignored. OIDs that are malformed, or do not exist generate an error. (Cannot be combined with &lt;code&gt;--stdin-packs&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf73ef52d157ce1e4ddc4b827c0a6415ea79de1" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-packs&lt;/code&gt; option, generate the new commit graph by walking objects only in the specified pack-indexes. (Cannot be combined with &lt;code&gt;--stdin-commits&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">使用 &lt;code&gt;--stdin-packs&lt;/code&gt; 选项，仅通过在指定的pack-indexs中遍历对象即可生成新的提交图。（不能与 &lt;code&gt;--reachable&lt;/code&gt; &lt;code&gt;--stdin-commits&lt;/code&gt; 或--reachable结合使用。）</target>
        </trans-unit>
        <trans-unit id="17857b1a19de2786ab177b98550f7755d5958169" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;subsystem&lt;/code&gt; reflog: after &lt;code&gt;git fetch&lt;/code&gt;, the old tip of &lt;code&gt;subsystem&lt;/code&gt; is at &lt;code&gt;subsystem@{1}&lt;/code&gt;. Subsequent fetches will increase the number. (See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt;.)</source>
          <target state="translated">使用 &lt;code&gt;subsystem&lt;/code&gt; reflog：在 &lt;code&gt;git fetch&lt;/code&gt; 之后， &lt;code&gt;subsystem&lt;/code&gt; 的旧提示位于 &lt;code&gt;subsystem@{1}&lt;/code&gt; 。随后的提取将增加数量。（请参见&lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="b4f2100600cd65d2bb507aefd40b38b428ed31a7" translate="yes" xml:space="preserve">
          <source>With the example above that would give:</source>
          <target state="translated">有了上面的例子,就会有。</target>
        </trans-unit>
        <trans-unit id="a003c8ea87ae62c71ced8657b18db066ae621f53" translate="yes" xml:space="preserve">
          <source>With the exception of raw file data (which Git does not interpret) the fast-import input format is text (ASCII) based. This text based format simplifies development and debugging of frontend programs, especially when a higher level language such as Perl, Python or Ruby is being used.</source>
          <target state="translated">除了原始文件数据(Git 不解释),快速导入的输入格式是基于文本(ASCII)的。这种基于文本的格式简化了前端程序的开发和调试,尤其是在使用Perl、Python或Ruby等高级语言时。</target>
        </trans-unit>
        <trans-unit id="832b24adba81a74f8f3c27d1a374c3c9abe6eae9" translate="yes" xml:space="preserve">
          <source>With the latter, you can use the manual viewer of your choice; see &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; for more information.</source>
          <target state="translated">对于后者，您可以使用所选的手动查看器。有关更多信息，请参见&lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd552b2cf02d64fea6c3a2fbecdcfeec69fa5199" translate="yes" xml:space="preserve">
          <source>With the right arguments, &lt;code&gt;git diff&lt;/code&gt; can also show us the difference between the working directory and the last commit, or between the index and the last commit:</source>
          <target state="translated">使用正确的参数， &lt;code&gt;git diff&lt;/code&gt; 也可以向我们显示工作目录和最后一次提交之间的差异，或者索引和最后一次提交之间的差异：</target>
        </trans-unit>
        <trans-unit id="6936b3f47f8ae1f272ba09aecb9105ac3f327d8a" translate="yes" xml:space="preserve">
          <source>With the strategies that use 3-way merge (including the default, &lt;code&gt;recursive&lt;/code&gt;), if a change is made on both branches, but later reverted on one of the branches, that change will be present in the merged result; some people find this behavior confusing. It occurs because only the heads and the merge base are considered when performing a merge, not the individual commits. The merge algorithm therefore considers the reverted change as no change at all, and substitutes the changed version instead.</source>
          <target state="translated">对于使用三向合并的策略（包括默认的 &lt;code&gt;recursive&lt;/code&gt; ），如果在两个分支上都进行了更改，但随后又在其中一个分支上进行了还原，则该更改将出现在合并结果中；有些人觉得这种行为令人困惑。发生这种情况是因为执行合并时仅考虑头和合并基数，而不考虑单个提交。因此，合并算法将还原后的更改视为完全没有更改，并替代了更改后的版本。</target>
        </trans-unit>
        <trans-unit id="993a54cdc4357f066aea765f4571bf68eff0acc7" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git cherry-pick&lt;/code&gt; will let you edit the commit message prior to committing.</source>
          <target state="translated">使用此选项， &lt;code&gt;git cherry-pick&lt;/code&gt; 将允许您在提交之前编辑提交消息。</target>
        </trans-unit>
        <trans-unit id="333853f3b4bc551496449cd51ab3f625f2fd83b5" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git gc&lt;/code&gt; checks whether any housekeeping is required; if not, it exits without performing any work.</source>
          <target state="translated">使用此选项， &lt;code&gt;git gc&lt;/code&gt; 检查是否需要任何内务处理；如果没有，它将退出而不进行任何工作。</target>
        </trans-unit>
        <trans-unit id="71e625d3b0cf2785820345a3c9b0fc38126ae685" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git revert&lt;/code&gt; will let you edit the commit message prior to committing the revert. This is the default if you run the command from a terminal.</source>
          <target state="translated">使用此选项， &lt;code&gt;git revert&lt;/code&gt; 将允许您在提交还原之前编辑提交消息。如果从终端运行命令，则这是默认设置。</target>
        </trans-unit>
        <trans-unit id="c4b763c3b176a1288a147104d8354f56c0e27e09" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git revert&lt;/code&gt; will not start the commit message editor.</source>
          <target state="translated">使用此选项， &lt;code&gt;git revert&lt;/code&gt; 将不会启动提交消息编辑器。</target>
        </trans-unit>
        <trans-unit id="8c4fe13a9c7d1e41585a8e2b5418a2b1ca5a28f1" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;merge-recursive&lt;/code&gt; spends a little extra time to avoid mismerges that sometimes occur due to unimportant matching lines (e.g., braces from distinct functions). Use this when the branches to be merged have diverged wildly. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--patience&lt;/code&gt;.</source>
          <target state="translated">使用此选项， &lt;code&gt;merge-recursive&lt;/code&gt; 花费一些额外的时间来避免有时由于不重要的匹配行（例如，来自不同函数的花括号）而导致的合并错误。当要合并的分支发散很大时，请使用此选项。另请参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--patience&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b7fa933690b4dfe40d9dc500f9cfa6ba3897c3d" translate="yes" xml:space="preserve">
          <source>With this option, diff output for a merge commit shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents.</source>
          <target state="translated">有了这个选项,合并提交的 diff 输出会同时显示每个父文件与合并结果的差异,而不是每次显示父文件与结果之间的成对差异。此外,它只列出所有父文件中被修改的文件。</target>
        </trans-unit>
        <trans-unit id="3524864d6b6fccf88decb6caefb79eeb0a8e7c7e" translate="yes" xml:space="preserve">
          <source>With this option, git will replace all refnames, paths, blob contents, commit and tag messages, names, and email addresses in the output with anonymized data. Two instances of the same string will be replaced equivalently (e.g., two commits with the same author will have the same anonymized author in the output, but bear no resemblance to the original author string). The relationship between commits, branches, and tags is retained, as well as the commit timestamps (but the commit messages and refnames bear no resemblance to the originals). The relative makeup of the tree is retained (e.g., if you have a root tree with 10 files and 3 trees, so will the output), but their names and the contents of the files will be replaced.</source>
          <target state="translated">使用此选项,git 将用匿名数据替换输出中的所有 refnames、路径、blob 内容、提交和标签信息、姓名和电子邮件地址。同一字符串的两个实例将被等价替换(例如,两个作者相同的提交在输出中会有相同的匿名作者,但与原始作者字符串没有相似之处)。提交、分支和标签之间的关系以及提交时间戳都会被保留(但提交消息和 refnames 与原件没有相似之处)。树的相对构成会被保留(例如,如果你的根树有 10 个文件和 3 棵树,那么输出也会被保留),但它们的名字和文件的内容会被替换。</target>
        </trans-unit>
        <trans-unit id="cbb1ff7744c2585e2c6b4c0275539aaae99818d7" translate="yes" xml:space="preserve">
          <source>With this option, parents that are hidden by grafts are packed nevertheless.</source>
          <target state="translated">有了这个选项,被移植物隐藏的父母就会被包装不过。</target>
        </trans-unit>
        <trans-unit id="64d24b372615e7424e92210d8b3079a3b6d54b46" translate="yes" xml:space="preserve">
          <source>With this option, the command includes the current branch to the list of revs to be shown when it is not given on the command line.</source>
          <target state="translated">有了这个选项,当命令行上没有给出时,命令会将当前分支加入到要显示的 revs 列表中。</target>
        </trans-unit>
        <trans-unit id="a7994938c4128018ec7f46d918cac8d359a1f2eb" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;git show-branch&lt;/code&gt; without extra parameters would show only the primary branches. In addition, if you happen to be on your topic branch, it is shown as well.</source>
          <target state="translated">这样，没有额外参数的 &lt;code&gt;git show-branch&lt;/code&gt; 将仅显示主要分支。此外，如果您恰好位于主题分支上，则也会显示该主题。</target>
        </trans-unit>
        <trans-unit id="7d389d82d11c207ddbcbb54d477d308b2e5d9f7f" translate="yes" xml:space="preserve">
          <source>With this, Alice can perform the first part of the &quot;pull&quot; operation alone using the &lt;code&gt;git fetch&lt;/code&gt; command without merging them with her own branch, using:</source>
          <target state="translated">这样，Alice可以使用 &lt;code&gt;git fetch&lt;/code&gt; 命令单独执行&amp;ldquo;拉&amp;rdquo;操作的第一部分，而无需使用以下命令将它们与自己的分支合并：</target>
        </trans-unit>
        <trans-unit id="6062bf6506f2ab2b976dee38aa5322c59a129e2f" translate="yes" xml:space="preserve">
          <source>Within a linked working tree, $GIT_DIR is set to point to this private directory (e.g. &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; in the example) and $GIT_COMMON_DIR is set to point back to the main working tree&amp;rsquo;s $GIT_DIR (e.g. &lt;code&gt;/path/main/.git&lt;/code&gt;). These settings are made in a &lt;code&gt;.git&lt;/code&gt; file located at the top directory of the linked working tree.</source>
          <target state="translated">在链接的工作树中，将$ GIT_DIR设置为指向此私有目录（例如， &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; 中的/path/main/.git/worktrees/test-next），而将$ GIT_COMMON_DIR设置为指向主工作树的$ GIT_DIR （例如 &lt;code&gt;/path/main/.git&lt;/code&gt; ）。这些设置在链接工作树顶部目录中的 &lt;code&gt;.git&lt;/code&gt; 文件中进行。</target>
        </trans-unit>
        <trans-unit id="28d243903fe73e45525c0f96e48fd5d6abc9c7f9" translate="yes" xml:space="preserve">
          <source>Within a linked working tree, &lt;code&gt;$GIT_DIR&lt;/code&gt; is set to point to this private directory (e.g. &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; in the example) and &lt;code&gt;$GIT_COMMON_DIR&lt;/code&gt; is set to point back to the main working tree&amp;rsquo;s &lt;code&gt;$GIT_DIR&lt;/code&gt; (e.g. &lt;code&gt;/path/main/.git&lt;/code&gt;). These settings are made in a &lt;code&gt;.git&lt;/code&gt; file located at the top directory of the linked working tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f531335c76344721aaf744205582ff3be68651bd" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--all&lt;/code&gt; and without any &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt;, the heads that exist both on the local side and on the remote side are updated.</source>
          <target state="translated">如果没有 &lt;code&gt;--all&lt;/code&gt; 并且没有任何 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; ，则更新在本地和远程存在的磁头。</target>
        </trans-unit>
        <trans-unit id="af870a4c72e2ec7c668a803b1e745b16df6d1c9d" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--follow-symlinks&lt;/code&gt;, these would print data about the symlink itself. In the case of &lt;code&gt;HEAD:link&lt;/code&gt;, you would see</source>
          <target state="translated">没有 &lt;code&gt;--follow-symlinks&lt;/code&gt; ，它们将打印有关符号链接本身的数据。对于 &lt;code&gt;HEAD:link&lt;/code&gt; ，您将看到</target>
        </trans-unit>
        <trans-unit id="a213d6298e44415b29925050ee6ffa235637e828" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--force&lt;/code&gt;, the &amp;lt;src&amp;gt; ref is stored at the remote only if &amp;lt;dst&amp;gt; does not exist, or &amp;lt;dst&amp;gt; is a proper subset (i.e. an ancestor) of &amp;lt;src&amp;gt;. This check, known as &quot;fast-forward check&quot;, is performed in order to avoid accidentally overwriting the remote ref and lose other peoples' commits from there.</source>
          <target state="translated">如果没有 &lt;code&gt;--force&lt;/code&gt; ，则仅当&amp;lt;dst&amp;gt;不存在或&amp;lt;dst&amp;gt;是&amp;lt;src&amp;gt;的适当子集（即祖先）时，&amp;lt;src&amp;gt; ref才会存储在远程目录中。为了避免意外覆盖远程引用并从那里丢失其他人的提交，执行了称为&amp;ldquo;快速检查&amp;rdquo;的检查。</target>
        </trans-unit>
        <trans-unit id="44aa5155d389a8a00fc9a9c0d5c5dc24c0b6b423" translate="yes" xml:space="preserve">
          <source>Without additional configuration, pushes the current branch to the configured upstream (&lt;code&gt;remote.origin.merge&lt;/code&gt; configuration variable) if it has the same name as the current branch, and errors out without pushing otherwise.</source>
          <target state="translated">如果没有其他配置，则将当前分支推送到已配置的上游（ &lt;code&gt;remote.origin.merge&lt;/code&gt; 配置变量）（如果它与当前分支具有相同的名称），并且在不进行推送的情况下出错。</target>
        </trans-unit>
        <trans-unit id="0d4981e0bf66e69e6f534946531426d82d26ec6d" translate="yes" xml:space="preserve">
          <source>Without an optional path parameter, all files and subdirectories of the current working directory are included in the archive. If one or more paths are specified, only these are included.</source>
          <target state="translated">如果没有可选的路径参数,当前工作目录的所有文件和子目录都会被包含在归档中。如果指定了一个或多个路径,则只包含这些路径。</target>
        </trans-unit>
        <trans-unit id="0aaf17e36c6d625d7976371bb21725d2cea205e0" translate="yes" xml:space="preserve">
          <source>Without any credential helpers defined, Git will try the following strategies to ask the user for usernames and passwords:</source>
          <target state="translated">在没有定义任何凭证助手的情况下,Git会尝试以下策略来要求用户输入用户名和密码。</target>
        </trans-unit>
        <trans-unit id="6f8c2669a27a9c22abf3f515b27b1a9a5be3b6dc" translate="yes" xml:space="preserve">
          <source>Without disambiguating &lt;code&gt;--&lt;/code&gt;, Git makes a reasonable guess, but errors out and asking you to disambiguate when ambiguous. E.g. if you have a file called HEAD in your work tree, &lt;code&gt;git diff HEAD&lt;/code&gt; is ambiguous, and you have to say either &lt;code&gt;git diff HEAD --&lt;/code&gt; or &lt;code&gt;git diff -- HEAD&lt;/code&gt; to disambiguate.</source>
          <target state="translated">没有歧义 &lt;code&gt;--&lt;/code&gt; ，Git会做出合理的猜测，但会出错并要求您在歧义时消除歧义。例如，如果您的工作树中有一个名为HEAD的文件，则 &lt;code&gt;git diff HEAD&lt;/code&gt; 模棱两可，您必须说 &lt;code&gt;git diff HEAD --&lt;/code&gt; 或 &lt;code&gt;git diff -- HEAD&lt;/code&gt; 才能消除歧义。</target>
        </trans-unit>
        <trans-unit id="636ef8b24660180a9f9d02cde9f707a809036029" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;-z&lt;/code&gt; option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">如果不使用 &lt;code&gt;-z&lt;/code&gt; 选项，则引用带有&amp;ldquo;不寻常&amp;rdquo;字符的路径名，如配置变量 &lt;code&gt;core.quotePath&lt;/code&gt; 所述（参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fbf6695514712c3a8e39b514953f35111f6c3ca8" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;-z&lt;/code&gt; option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Using &lt;code&gt;-z&lt;/code&gt; the filename is output verbatim and the line is terminated by a NUL byte.</source>
          <target state="translated">如果不使用 &lt;code&gt;-z&lt;/code&gt; 选项，则引用带有&amp;ldquo;不寻常&amp;rdquo;字符的路径名，如配置变量 &lt;code&gt;core.quotePath&lt;/code&gt; 所述（参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。使用 &lt;code&gt;-z&lt;/code&gt; ，文件名将按原样输出，并且该行以NUL字节终止。</target>
        </trans-unit>
        <trans-unit id="94da29d7f90d6f6f16856adba693bd0f5ed5aeb9" translate="yes" xml:space="preserve">
          <source>Without the &lt;em&gt;--more=1&lt;/em&gt; option, &lt;em&gt;git show-branch&lt;/em&gt; would not output the &lt;em&gt;[master^]&lt;/em&gt; commit, as &lt;em&gt;[mybranch]&lt;/em&gt; commit is a common ancestor of both &lt;em&gt;master&lt;/em&gt; and &lt;em&gt;mybranch&lt;/em&gt; tips. Please see &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">没有&lt;em&gt;--more = 1&lt;/em&gt;选项，&lt;em&gt;git show-branch&lt;/em&gt;将不会输出&lt;em&gt;[master ^]&lt;/em&gt;提交，因为&lt;em&gt;[mybranch]&lt;/em&gt;提交是&lt;em&gt;master&lt;/em&gt;和&lt;em&gt;mybranch&lt;/em&gt;技巧的共同祖先。有关详细信息，请参见&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c29d8269d6df0a76bd7b7031ef1a5a35a844def8" translate="yes" xml:space="preserve">
          <source>Without this flag, &lt;code&gt;git log -p &amp;lt;path&amp;gt;...&lt;/code&gt; shows commits that touch the specified paths, and diffs about the same specified paths. With this, the full diff is shown for commits that touch the specified paths; this means that &quot;&amp;lt;path&amp;gt;&amp;hellip;​&quot; limits only commits, and doesn&amp;rsquo;t limit diff for those commits.</source>
          <target state="translated">如果没有此标志，则 &lt;code&gt;git log -p &amp;lt;path&amp;gt;...&lt;/code&gt; 显示接触指定路径的提交，以及与相同指定路径有关的差异。这样，对于接触指定路径的提交，将显示完整差异。这意味着&amp;ldquo; &amp;lt;path&amp;gt;&amp;hellip;...&amp;rdquo;仅限制提交，而不限制这些提交的差异。</target>
        </trans-unit>
        <trans-unit id="b86cf57585935f6e60cc9059e45208393d99c9a8" translate="yes" xml:space="preserve">
          <source>Without this option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">如果没有此选项，则引用带有&amp;ldquo;不寻常&amp;rdquo;字符的路径名，如配置变量 &lt;code&gt;core.quotePath&lt;/code&gt; 所述（参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8450aafea5471fb336aa6711b707fb955fd65d91" translate="yes" xml:space="preserve">
          <source>Workflow for a third party library</source>
          <target state="translated">第三方图书馆的工作流程</target>
        </trans-unit>
        <trans-unit id="8dfb0e4b50fd82c5ff8bc5fed81147f5e4aadb05" translate="yes" xml:space="preserve">
          <source>Workflow for an artificially split repo</source>
          <target state="translated">人工分割回购的工作流程</target>
        </trans-unit>
        <trans-unit id="825ce9e97dc41179ec167b83be91179b5dacd316" translate="yes" xml:space="preserve">
          <source>Workflows</source>
          <target state="translated">Workflows</target>
        </trans-unit>
        <trans-unit id="72b02433b5041ac5ef6045242ff8d0e2784944a3" translate="yes" xml:space="preserve">
          <source>Working branch; defaults to HEAD.</source>
          <target state="translated">工作分支;默认为 HEAD。</target>
        </trans-unit>
        <trans-unit id="a2b68acce45b31c1701e61880a9ac430bd217ef5" translate="yes" xml:space="preserve">
          <source>Working directory specific configuration file for the main working directory in multiple working directory setup (see &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;).</source>
          <target state="translated">多个工作目录设置中主要工作目录的工作目录特定配置文件（请参阅&lt;a href=&quot;git-worktree&quot;&gt;git-worktree [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="29f32a47a3074cae8d2558abdc45a4c7a3f4de27" translate="yes" xml:space="preserve">
          <source>Working directory specific configuration file.</source>
          <target state="translated">工作目录专用配置文件。</target>
        </trans-unit>
        <trans-unit id="b7010e71f35d363293e1c71cea9eb7b673f227d7" translate="yes" xml:space="preserve">
          <source>Working trees can be identified by path, either relative or absolute.</source>
          <target state="translated">工作树可以通过路径来识别,可以是相对的,也可以是绝对的。</target>
        </trans-unit>
        <trans-unit id="e5850a4e043e763eb3c70b51337df764ed12f013" translate="yes" xml:space="preserve">
          <source>Working with others</source>
          <target state="translated">与他人合作</target>
        </trans-unit>
        <trans-unit id="883363a342498bf776fadbacf0d9322246ddce5d" translate="yes" xml:space="preserve">
          <source>Working with others, shared repository style</source>
          <target state="translated">与他人合作,共享存储库风格</target>
        </trans-unit>
        <trans-unit id="62159bf12f9108d11431e1d1114bdbbeecf78451" translate="yes" xml:space="preserve">
          <source>Works just like --signature except the signature is read from a file.</source>
          <target state="translated">除了从文件中读取签名外,工作原理和--signature一样。</target>
        </trans-unit>
        <trans-unit id="097006f59137099e2d2ccff414198fea83903044" translate="yes" xml:space="preserve">
          <source>Works just like format.signature except the contents of the file specified by this variable will be used as the signature.</source>
          <target state="translated">和format.signature一样,除了这个变量指定的文件内容将被用作签名。</target>
        </trans-unit>
        <trans-unit id="c45647582ec4fc92bdcd3ecd1a16e9638ca339a8" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt;, where &amp;lt;remote&amp;gt; is the current branch&amp;rsquo;s remote (or &lt;code&gt;origin&lt;/code&gt;, if no remote is configured for the current branch).</source>
          <target state="translated">像 &lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt; 一样工作，其中&amp;lt;remote&amp;gt;是当前分支的远程对象（如果没有为当前分支配置任何远程对象，则是 &lt;code&gt;origin&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="96f0b3b7db8530493b30466426fa80c5c21f66c1" translate="yes" xml:space="preserve">
          <source>Wrap code spawning child processes.</source>
          <target state="translated">包裹代码产生子进程。</target>
        </trans-unit>
        <trans-unit id="1f9c72af7bca7c9666626fcb471d6065e154c93d" translate="yes" xml:space="preserve">
          <source>Write a MIDX file for the packfiles in an alternate object store.</source>
          <target state="translated">在另一个对象存储中为packfiles写一个MIDX文件。</target>
        </trans-unit>
        <trans-unit id="36b48ab2e331354b7c3cc2f14ff9d8ea9d1001c3" translate="yes" xml:space="preserve">
          <source>Write a MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">为当前.git文件夹中的packfiles写一个MIDX文件。</target>
        </trans-unit>
        <trans-unit id="b42a0c66496716fcd8c88f5906d20e5cf08f4975" translate="yes" xml:space="preserve">
          <source>Write a chapter on using plumbing and writing scripts.</source>
          <target state="translated">写一章使用水管和写脚本。</target>
        </trans-unit>
        <trans-unit id="c8e128b9f546fd58c7e614d0f8b8821821084ae1" translate="yes" xml:space="preserve">
          <source>Write a commit-graph after fetching. This overrides the config setting &lt;code&gt;fetch.writeCommitGraph&lt;/code&gt;.</source>
          <target state="translated">提取后写一个提交图。这将覆盖配置设置 &lt;code&gt;fetch.writeCommitGraph&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e518a1279678087b263b8a6d5d4572c2e8b9dd3b" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file based on the commits found in packfiles.</source>
          <target state="translated">根据packfiles中的提交内容,编写一个提交图文件。</target>
        </trans-unit>
        <trans-unit id="31a24952f6ac97438fc3f890b7eeabaf5006955a" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file based on the commits found in packfiles. If the config option &lt;code&gt;core.commitGraph&lt;/code&gt; is disabled, then this command will output a warning, then return success without writing a commit-graph file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a7e9f2485bf10bd9980490fdf55b0594e99b5f" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file containing all commits in the current commit-graph file along with those reachable from &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">编写一个提交图文件，其中包含当前提交图文件中的所有提交以及可从 &lt;code&gt;HEAD&lt;/code&gt; 访问的提交。</target>
        </trans-unit>
        <trans-unit id="8c34e4cbacab76dc7a95f5e0f46081aab1f59603" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file containing all reachable commits.</source>
          <target state="translated">写一个包含所有可到达的提交的提交图文件。</target>
        </trans-unit>
        <trans-unit id="e1238f6b25cc5d29bebfcc60e794e1647b6dd786" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file for the packed commits in your local &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">在本地 &lt;code&gt;.git&lt;/code&gt; 目录中为打包的提交编写一个提交图文件。</target>
        </trans-unit>
        <trans-unit id="7ba716e808cc8cf569e10d2453e1761bc59eae40" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file, extending the current commit-graph file using commits in &lt;code&gt;&amp;lt;pack-index&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">编写一个提交图文件，使用 &lt;code&gt;&amp;lt;pack-index&amp;gt;&lt;/code&gt; 中的提交扩展当前提交图文件。</target>
        </trans-unit>
        <trans-unit id="73c3a355bd823c82bb9b3a929df0d2e920a5e648" translate="yes" xml:space="preserve">
          <source>Write a new MIDX file.</source>
          <target state="translated">编写一个新的MIDX文件。</target>
        </trans-unit>
        <trans-unit id="b0d7b6d61dd4b6501290a029b72f9ed15f8cc305" translate="yes" xml:space="preserve">
          <source>Write a reachability bitmap index as part of the repack. This only makes sense when used with &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;-A&lt;/code&gt;, as the bitmaps must be able to refer to all reachable objects. This option overrides the setting of &lt;code&gt;repack.writeBitmaps&lt;/code&gt;. This option has no effect if multiple packfiles are created.</source>
          <target state="translated">写一个可达性位图索引作为重新打包的一部分。这仅在与 &lt;code&gt;-a&lt;/code&gt; 或 &lt;code&gt;-A&lt;/code&gt; 一起使用时才有意义，因为位图必须能够引用所有可访问的对象。此选项将覆盖 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; 的设置。如果创建了多个packfile，则此选项无效。</target>
        </trans-unit>
        <trans-unit id="0ec591cf31eda36450bc843a926c4fd529f9a0da" translate="yes" xml:space="preserve">
          <source>Write a set of patterns to the sparse-checkout file, as given as a list of arguments following the &lt;code&gt;set&lt;/code&gt; subcommand. Update the working directory to match the new patterns. Enable the core.sparseCheckout config setting if it is not already enabled.</source>
          <target state="translated">将一组模式写入稀疏检出文件，如 &lt;code&gt;set&lt;/code&gt; 子命令后面的参数列表所示。更新工作目录以匹配新模式。启用core.sparseCheckout配置设置（如果尚未启用）。</target>
        </trans-unit>
        <trans-unit id="041470620f3506e6e154d55da89dd48b2bba6ec8" translate="yes" xml:space="preserve">
          <source>Write and verify Git commit-graph files</source>
          <target state="translated">编写和验证Git提交图文件</target>
        </trans-unit>
        <trans-unit id="fbde21d9f61e2faa3e597fb0c951212436d2d05f" translate="yes" xml:space="preserve">
          <source>Write and verify multi-pack-indexes</source>
          <target state="translated">编写和验证多包索引</target>
        </trans-unit>
        <trans-unit id="0874d3d36a3af067f281de19e268427b067828a4" translate="yes" xml:space="preserve">
          <source>Write dangling objects into .git/lost-found/commit/ or .git/lost-found/other/, depending on type. If the object is a blob, the contents are written into the file, rather than its object name.</source>
          <target state="translated">将悬空对象写入 .git/lost-found/commit/或 .git/lost-found/other/,取决于类型。如果对象是 blob,内容会被写入文件,而不是对象名。</target>
        </trans-unit>
        <trans-unit id="d9accbc71f1215e3614372f554930a021fe71b0a" translate="yes" xml:space="preserve">
          <source>Write into pairs of files (.pack and .idx), using &amp;lt;base-name&amp;gt; to determine the name of the created file. When this option is used, the two files in a pair are written in &amp;lt;base-name&amp;gt;-&amp;lt;SHA-1&amp;gt;.{pack,idx} files. &amp;lt;SHA-1&amp;gt; is a hash based on the pack content and is written to the standard output of the command.</source>
          <target state="translated">使用&amp;lt;base-name&amp;gt;写入文件对（.pack和.idx），以确定所创建文件的名称。使用此选项时，成对的两个文件将写入&amp;lt;base-name&amp;gt;-&amp;lt;SHA-1&amp;gt;。{pack，idx}文件中。&amp;lt;SHA-1&amp;gt;是基于包内容的哈希，并被写入命令的标准输出。</target>
        </trans-unit>
        <trans-unit id="7fe0c30065baa84a0511c3d3081d91c7d606dfea" translate="yes" xml:space="preserve">
          <source>Write or verify a multi-pack-index (MIDX) file.</source>
          <target state="translated">编写或验证一个多包索引(MIDX)文件。</target>
        </trans-unit>
        <trans-unit id="e39d29fa27aa3fd795b76126771a3ffa6c08d16a" translate="yes" xml:space="preserve">
          <source>Write responses to &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;cat-blob&lt;/code&gt;, and &lt;code&gt;ls&lt;/code&gt; queries to the file descriptor &amp;lt;fd&amp;gt; instead of &lt;code&gt;stdout&lt;/code&gt;. Allows &lt;code&gt;progress&lt;/code&gt; output intended for the end-user to be separated from other output.</source>
          <target state="translated">将对 &lt;code&gt;get-mark&lt;/code&gt; ， &lt;code&gt;cat-blob&lt;/code&gt; 和 &lt;code&gt;ls&lt;/code&gt; 查询的响应写到文件描述符&amp;lt;fd&amp;gt;而不是 &lt;code&gt;stdout&lt;/code&gt; 。允许将最终用户的 &lt;code&gt;progress&lt;/code&gt; 输出与其他输出分开。</target>
        </trans-unit>
        <trans-unit id="e189db14fd9c8dacb74b437fa25a566d7b39760b" translate="yes" xml:space="preserve">
          <source>Write the archive to &amp;lt;file&amp;gt; instead of stdout.</source>
          <target state="translated">将存档写到&amp;lt;file&amp;gt;而不是stdout。</target>
        </trans-unit>
        <trans-unit id="7dc7fd5fc893589e612150dc5a94bc95c63f6644" translate="yes" xml:space="preserve">
          <source>Write the generated pack index into the specified file. Without this option the name of pack index file is constructed from the name of packed archive file by replacing .pack with .idx (and the program fails if the name of packed archive does not end with .pack).</source>
          <target state="translated">将生成的打包索引写入指定的文件中。如果没有这个选项,打包索引文件的名称是通过将.pack替换为.idx从打包存档文件的名称中构建出来的(如果打包存档的名称不以.pack结尾,程序就会失败)。</target>
        </trans-unit>
        <trans-unit id="898b44ae7851f33ec7de0339d5f319ea640d48c2" translate="yes" xml:space="preserve">
          <source>Write the list of remote refs fetched in the &lt;code&gt;FETCH_HEAD&lt;/code&gt; file directly under &lt;code&gt;$GIT_DIR&lt;/code&gt;. This is the default. Passing &lt;code&gt;--no-write-fetch-head&lt;/code&gt; from the command line tells Git not to write the file. Under &lt;code&gt;--dry-run&lt;/code&gt; option, the file is never written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee51e3bc5f984d1828334228be7ce34fc987d1e" translate="yes" xml:space="preserve">
          <source>Write the pack contents (what would have been written to .pack file) out to the standard output.</source>
          <target state="translated">将包的内容(本来要写到.包文件的内容)写到标准输出。</target>
        </trans-unit>
        <trans-unit id="f8fab17bc8f3e5385c26a96bd869170c9b748651" translate="yes" xml:space="preserve">
          <source>Write the resulting index out in the named on-disk format version. Supported versions are 2, 3 and 4. The current default version is 2 or 3, depending on whether extra features are used, such as &lt;code&gt;git add -N&lt;/code&gt;.</source>
          <target state="translated">用指定的磁盘格式版本写出结果索引。支持的版本为2、3和4。当前的默认版本为2或3，具体取决于是否使用了其他功能，例如 &lt;code&gt;git add -N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efedecbf7e9a176a45aaee6d10ad017d653ffad6" translate="yes" xml:space="preserve">
          <source>Write to standard error. Note that if &lt;code&gt;--detach&lt;/code&gt; is specified, the process disconnects from the real standard error, making this destination effectively equivalent to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">写入标准错误。请注意，如果指定了 &lt;code&gt;--detach&lt;/code&gt; ，则该过程将与实际的标准错误断开连接，从而使该目标实际上等效于 &lt;code&gt;none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04570d31869f8fe0ff9437709cb2be3000b6efb7" translate="yes" xml:space="preserve">
          <source>Write to syslog, using the &lt;code&gt;git-daemon&lt;/code&gt; identifier.</source>
          <target state="translated">使用 &lt;code&gt;git-daemon&lt;/code&gt; 标识符写入syslog 。</target>
        </trans-unit>
        <trans-unit id="b06c59a883065a2aa7a048f19cdd388e420a56a1" translate="yes" xml:space="preserve">
          <source>Write whatever message you want, and all the lines that start with &lt;code&gt;#&lt;/code&gt; will be pruned out, and the rest will be used as the commit message for the change. If you decide you don&amp;rsquo;t want to commit anything after all at this point (you can continue to edit things and update the index), you can just leave an empty message. Otherwise &lt;code&gt;git commit&lt;/code&gt; will commit the change for you.</source>
          <target state="translated">编写所需的任何消息，所有以 &lt;code&gt;#&lt;/code&gt; 开头的行都将被删除，其余的将用作更改的提交消息。如果您决定此时根本不提交任何内容（您可以继续编辑内容并更新索引），则可以留下一条空消息。否则 &lt;code&gt;git commit&lt;/code&gt; 将为您提交更改。</target>
        </trans-unit>
        <trans-unit id="61b122f3a92e6ba319a161e3ee36a5061ca2ea4c" translate="yes" xml:space="preserve">
          <source>Writes a tree object that represents a subdirectory &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. This can be used to write the tree object for a subproject that is in the named subdirectory.</source>
          <target state="translated">编写一个表示子目录 &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; 的树对象。这可用于为命名子目录中的子项目编写树对象。</target>
        </trans-unit>
        <trans-unit id="157114a94f76dd225b6968a998012309617b01fe" translate="yes" xml:space="preserve">
          <source>Writes the commit-id into the filename under $GIT_DIR/refs/&amp;lt;filename&amp;gt; on the local end after the transfer is complete.</source>
          <target state="translated">传输完成后，将提交ID写入本地端$ GIT_DIR / refs / &amp;lt;filename&amp;gt;下的文件名中。</target>
        </trans-unit>
        <trans-unit id="e02c77bcdadadb66d0f7703e015b6bcd89a6c5e3" translate="yes" xml:space="preserve">
          <source>X: &quot;unknown&quot; change type (most probably a bug, please report it)</source>
          <target state="translated">X:&quot;未知 &quot;的更改类型(很可能是个错误,请报告)。</target>
        </trans-unit>
        <trans-unit id="c4701ab33311f5af4d25d032b9d36f7ee2d229e7" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;must&lt;/code&gt; therefore ensure that the most recent commit of the branch you want to dcommit to is the &lt;code&gt;first&lt;/code&gt; parent of the merge. Chaos will ensue otherwise, especially if the first parent is an older commit on the same SVN branch.</source>
          <target state="translated">因此，您 &lt;code&gt;must&lt;/code&gt; 确保要提交到的分支的最新提交是合并的 &lt;code&gt;first&lt;/code&gt; 父级。否则将导致混乱，特别是如果第一个父节点是同一SVN分支上的较早提交。</target>
        </trans-unit>
        <trans-unit id="33b03e34a8212275c562b3fd47359312e9fb9f26" translate="yes" xml:space="preserve">
          <source>You also could say &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;clean&lt;/code&gt; above as long as the choice is unique.</source>
          <target state="translated">您也可以在上面说 &lt;code&gt;c&lt;/code&gt; 或 &lt;code&gt;clean&lt;/code&gt; ，只要选择是唯一的即可。</target>
        </trans-unit>
        <trans-unit id="3633df0f340d7a5b00e10a65751fa4510ce91fa7" translate="yes" xml:space="preserve">
          <source>You also could say &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;sta&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt; above as long as the choice is unique.</source>
          <target state="translated">只要选择是唯一的，您也可以在上面说 &lt;code&gt;s&lt;/code&gt; 或 &lt;code&gt;sta&lt;/code&gt; 或 &lt;code&gt;status&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80dcbb43282a1e399b57f0acd29e7d516598c299" translate="yes" xml:space="preserve">
          <source>You also need to ensure that each repository is &quot;bare&quot; (without a Git index file) for &lt;code&gt;cvs commit&lt;/code&gt; to work. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">您还需要确保每个存储库都是&amp;ldquo;裸露的&amp;rdquo;（没有Git索引文件），以便 &lt;code&gt;cvs commit&lt;/code&gt; 工作。参见&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63d1d5a88c78a80cfc3950acb2e452ff58df3b69" translate="yes" xml:space="preserve">
          <source>You also should not rewind branches in a submodule beyond commits that were ever recorded in any superproject.</source>
          <target state="translated">你也不应该将子模块中的分支倒带,超过任何超级项目中曾经记录的提交。</target>
        </trans-unit>
        <trans-unit id="9cb8652293d991a8fc334c9f946fb5900f566815" translate="yes" xml:space="preserve">
          <source>You are happily working on something, and find the changes in these files are in good order. You do not want to see them when you run &lt;code&gt;git diff&lt;/code&gt;, because you plan to work on other files and changes with these files are distracting.</source>
          <target state="translated">您很高兴在做某事，并且发现这些文件中的更改井井有条。您不希望在运行 &lt;code&gt;git diff&lt;/code&gt; 时看到它们，因为您计划使用其他文件，而这些文件的更改会分散您的注意力。</target>
        </trans-unit>
        <trans-unit id="48f9e78ec61620aadfc7c1e71bab372f08845a6f" translate="yes" xml:space="preserve">
          <source>You are in the middle of a refactoring session and your boss comes in and demands that you fix something immediately. You might typically use &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; to store your changes away temporarily, however, your working tree is in such a state of disarray (with new, moved, and removed files, and other bits and pieces strewn around) that you don&amp;rsquo;t want to risk disturbing any of it. Instead, you create a temporary linked working tree to make the emergency fix, remove it when done, and then resume your earlier refactoring session.</source>
          <target state="translated">您正处于重构会话的中间，老板进来并要求您立即修复某些问题。通常，您可能会使用&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;暂时存储所做的更改，但是，您的工作树处于混乱状态（新文件，已移动和已删除的文件以及其他零碎的东西）不想冒任何干扰的风险。而是，您创建一个临时链接的工作树来进行紧急修复，完成后将其删除，然后恢复较早的重构会话。</target>
        </trans-unit>
        <trans-unit id="bb2df2ca18755cbd46a4ed871293669f22530506" translate="yes" xml:space="preserve">
          <source>You are now ready to commit. You can see what is about to be committed using &lt;code&gt;git diff&lt;/code&gt; with the --cached option:</source>
          <target state="translated">您现在可以提交了。您可以使用带有--cached选项的 &lt;code&gt;git diff&lt;/code&gt; 查看即将提交的内容：</target>
        </trans-unit>
        <trans-unit id="074e56336e1be0630703b280d6a3b60899f28a4c" translate="yes" xml:space="preserve">
          <source>You can adjust how pages generated by gitweb look using the variables described below. You can change the site name, add common headers and footers for all pages, and add a description of this gitweb installation on its main page (which is the projects list page), etc.</source>
          <target state="translated">你可以使用下面描述的变量调整gitweb生成的页面的外观。你可以更改站点名称,为所有页面添加通用的页眉和页脚,并在其主页面(也就是项目列表页)上添加对这个gitweb安装的描述等。</target>
        </trans-unit>
        <trans-unit id="f5130cbe18f25cdc12700266fadc1f554b9c37ce" translate="yes" xml:space="preserve">
          <source>You can also ask git log to show patches:</source>
          <target state="translated">你也可以要求git日志显示补丁。</target>
        </trans-unit>
        <trans-unit id="f5378640dc8884e7695fa8d24ebc61aad94be600" translate="yes" xml:space="preserve">
          <source>You can also check out &lt;code&gt;origin/todo&lt;/code&gt; directly to examine it or write a one-off patch. See &lt;a href=&quot;#detached-head&quot;&gt;detached head&lt;/a&gt;.</source>
          <target state="translated">您也可以直接签出 &lt;code&gt;origin/todo&lt;/code&gt; 以进行检查或编写一次性补丁。见&lt;a href=&quot;#detached-head&quot;&gt;超脱的头&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7520d8990c9fc0c63fb723451f5a4b04ab5ce6bc" translate="yes" xml:space="preserve">
          <source>You can also control this behavior with the &lt;code&gt;core.whitespace&lt;/code&gt; setting if you don&amp;rsquo;t wish to remove the carriage returns from your line endings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dba829f7b6e6b2354184e851e59ecadab491f50" translate="yes" xml:space="preserve">
          <source>You can also edit a patch series with an interactive rebase. This is the same as &lt;a href=&quot;#reordering-patch-series&quot;&gt;reordering a patch series using &lt;code&gt;format-patch&lt;/code&gt;&lt;/a&gt;, so use whichever interface you like best.</source>
          <target state="translated">您还可以使用交互式变基来编辑补丁系列。这与&lt;a href=&quot;#reordering-patch-series&quot;&gt;使用 &lt;code&gt;format-patch&lt;/code&gt; &lt;/a&gt;对补丁系列进行重新排序相同，因此请使用最喜欢的接口。</target>
        </trans-unit>
        <trans-unit id="a56f9e1e04034dbb228cdfc1e0cb38c07a8bcbf1" translate="yes" xml:space="preserve">
          <source>You can also fetch branches from other repositories; so</source>
          <target state="translated">您也可以从其他仓库中获取分支,所以</target>
        </trans-unit>
        <trans-unit id="bb4e25e283a061b1bebe5a9dd36fbbd03f0e1b4b" translate="yes" xml:space="preserve">
          <source>You can also give &lt;code&gt;git log&lt;/code&gt; a &quot;range&quot; of commits where the first is not necessarily an ancestor of the second; for example, if the tips of the branches &quot;stable&quot; and &quot;master&quot; diverged from a common commit some time ago, then</source>
          <target state="translated">您还可以给 &lt;code&gt;git log&lt;/code&gt; 一个提交的&amp;ldquo;范围&amp;rdquo;，其中第一个不一定是第二个的祖先；例如，如果分支&amp;ldquo; stable&amp;rdquo;和&amp;ldquo; master&amp;rdquo;的提示与某个时间前的共同提交不同，则</target>
        </trans-unit>
        <trans-unit id="c219057e4d44e965fab9fe1f77892cd8f09c5753" translate="yes" xml:space="preserve">
          <source>You can also give commits names of your own; after running</source>
          <target state="translated">您也可以给自己的提交命名,在运行了</target>
        </trans-unit>
        <trans-unit id="ef70822bb0476f59f3e8869ce9a522611ff6cac9" translate="yes" xml:space="preserve">
          <source>You can also just enter your password when prompted. While it is possible to place the password (which must be percent-encoded) in the URL, this is not particularly secure and can lead to accidental exposure of credentials, so it is not recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cecebc054603ae5ff87afcd3e6caec5420b5c866" translate="yes" xml:space="preserve">
          <source>You can also override locations of gitweb configuration files during runtime by setting the following environment variables: &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt;, &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; and &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; to a non-empty value.</source>
          <target state="translated">您还可以通过将以下环境变量设置为运行时，在运行时覆盖gitweb配置文件的位置： &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt; ， &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; 和 &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; 为非空值。</target>
        </trans-unit>
        <trans-unit id="c335f539c67224e67ef9ba8bcb55a78f32c2ba64" translate="yes" xml:space="preserve">
          <source>You can also revert an earlier change, for example, the next-to-last:</source>
          <target state="translated">你也可以恢复之前的变化,例如,下一个到最后一个。</target>
        </trans-unit>
        <trans-unit id="f6f0f4e5da7f74f3d7e6aefa5597ca88126ce358" translate="yes" xml:space="preserve">
          <source>You can also run &lt;code&gt;git daemon&lt;/code&gt; as an inetd service; see the &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; man page for details. (See especially the examples section.)</source>
          <target state="translated">您还可以将 &lt;code&gt;git daemon&lt;/code&gt; 作为inetd服务运行；有关详细信息，请参见&lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt;手册页。（尤其请参见示例部分。）</target>
        </trans-unit>
        <trans-unit id="f0a51538febea0717277859dfbb5418b689055cc" translate="yes" xml:space="preserve">
          <source>You can also see what references it offers:</source>
          <target state="translated">你也可以看看它提供的参考资料。</target>
        </trans-unit>
        <trans-unit id="f06fdd5b89ee465ae510128ba09f10dd8adf5eac" translate="yes" xml:space="preserve">
          <source>You can also skip a range of commits, instead of just one commit, using range notation. For example:</source>
          <target state="translated">您也可以使用范围符号跳过一系列的提交,而不是只跳过一个提交。例如:</target>
        </trans-unit>
        <trans-unit id="54e517ee1d2086de2439776d35ac41cdff2f30f7" translate="yes" xml:space="preserve">
          <source>You can also track branches from repositories other than the one you cloned from, using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;:</source>
          <target state="translated">您还可以使用&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;跟踪来自克隆存储库之外的存储库的分支：</target>
        </trans-unit>
        <trans-unit id="28b63a93050077dfe73e5bbbcd2b4df244cc4f26" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; to create commits, view changes in the index and the working tree files, and individually select diff hunks for inclusion in the index (by right-clicking on the diff hunk and choosing &quot;Stage Hunk For Commit&quot;).</source>
          <target state="translated">您还可以使用&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt;创建提交，查看索引和工作树文件中的更改，以及分别选择要包含在索引中的diff块（通过右键单击diff块并选择&amp;ldquo; Stage Hunk For承诺&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="2d89b19204028ed2768f0a7d6951c7af3234e547" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; to generate patches for A, B and C, and the identifiers for P, X, Y, Z are appended at the end of the first message.</source>
          <target state="translated">您还可以使用 &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; 来生成A，B和C的补丁，并且P，X，Y，Z的标识符将附加在第一条消息的末尾。</target>
        </trans-unit>
        <trans-unit id="2c144befb1f45c546071ce64e48b303dc0e810a7" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git show&lt;/code&gt; to see any such file:</source>
          <target state="translated">您还可以使用 &lt;code&gt;git show&lt;/code&gt; 查看任何此类文件：</target>
        </trans-unit>
        <trans-unit id="49c3eff4b4dfbb20ea17f1bea994d4ab08b8a178" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;git_commit_non_empty_tree &quot;$@&quot;&lt;/code&gt; instead of &lt;code&gt;git commit-tree &quot;$@&quot;&lt;/code&gt; if you don&amp;rsquo;t wish to keep commits with a single parent and that makes no change to the tree.</source>
          <target state="translated">如果您不想与单个父节点保持提交并且对树没有任何更改，也可以使用 &lt;code&gt;git_commit_non_empty_tree &quot;$@&quot;&lt;/code&gt; 代替 &lt;code&gt;git commit-tree &quot;$@&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="015df615c0d1b650e7dd0d33e1d03af134ab36e3" translate="yes" xml:space="preserve">
          <source>You can always just jump back to your original &lt;code&gt;master&lt;/code&gt; branch by doing</source>
          <target state="translated">您总是可以通过执行以下操作跳回到原始 &lt;code&gt;master&lt;/code&gt; 分支</target>
        </trans-unit>
        <trans-unit id="e3173f9b04378ce969d4435b57687de248be9e7d" translate="yes" xml:space="preserve">
          <source>You can always view an old version of a file by just checking out the correct revision first. But sometimes it is more convenient to be able to view an old version of a single file without checking anything out; this command does that:</source>
          <target state="translated">你总是可以通过先检查出正确的版本来查看一个文件的旧版本。但有时更方便的做法是不检查任何东西就能查看单个文件的旧版本,这个命令就能做到。</target>
        </trans-unit>
        <trans-unit id="ac57e48df46d91546d0b6c2ab36f112078813032" translate="yes" xml:space="preserve">
          <source>You can at any time create a new branch by just picking an arbitrary point in the project history, and just writing the SHA-1 name of that object into a file under &lt;code&gt;.git/refs/heads/&lt;/code&gt;. You can use any filename you want (and indeed, subdirectories), but the convention is that the &quot;normal&quot; branch is called &lt;code&gt;master&lt;/code&gt;. That&amp;rsquo;s just a convention, though, and nothing enforces it.</source>
          <target state="translated">您可以随时创建一个新分支，只需在项目历史记录中选择一个任意点，然后将该对象的SHA-1名称 &lt;code&gt;.git/refs/heads/&lt;/code&gt; 下的文件中即可。您可以使用所需的任何文件名（甚至是子目录），但习惯上将&amp;ldquo;普通&amp;rdquo;分支称为 &lt;code&gt;master&lt;/code&gt; 。不过，这只是一个约定，没有任何强制要求。</target>
        </trans-unit>
        <trans-unit id="28fdfbc805da6922683f26cc12f785c6a111b6ce" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;. The URL in this file will be used to access the repository. This file should have the following format:</source>
          <target state="translated">您可以选择在 &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 提供文件名。该文件中的URL将用于访问存储库。该文件应具有以下格式：</target>
        </trans-unit>
        <trans-unit id="184c3e9bbc8e0af36908329654dfda91364d6a99" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a file in &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt;. The URL in this file will be used to access the repository. The refspec in this file will be used as default when you do not provide a refspec on the command line. This file should have the following format:</source>
          <target state="translated">您可以选择在 &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 提供文件名。该文件中的URL将用于访问存储库。如果未在命令行上提供refspec，则此文件中的refspec将用作默认值。该文件应具有以下格式：</target>
        </trans-unit>
        <trans-unit id="a92f2a4a63c6c2d142357d1e5947af0b6de272f3" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a remote which you had previously configured using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;, &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or even by a manual edit to the &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file. The URL of this remote will be used to access the repository. The refspec of this remote will be used by default when you do not provide a refspec on the command line. The entry in the config file would appear like this:</source>
          <target state="translated">您可以选择提供以前使用&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;，&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;甚至通过手动编辑 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件配置的远程服务器的名称。该遥控器的URL将用于访问存储库。如果您未在命令行上提供refspec，则默认情况下将使用此遥控器的refspec。配置文件中的条目将如下所示：</target>
        </trans-unit>
        <trans-unit id="d377d9322805f2d9d1e87d74e556de9916d572ec" translate="yes" xml:space="preserve">
          <source>You can choose whether you want to trust the index file entirely (using the &lt;code&gt;--cached&lt;/code&gt; flag) or ask the diff logic to show any files that don&amp;rsquo;t match the stat state as being &quot;tentatively changed&quot;. Both of these operations are very useful indeed.</source>
          <target state="translated">您可以选择是完全信任索引文件（使用 &lt;code&gt;--cached&lt;/code&gt; 标志），还是让diff逻辑将&amp;ldquo;不正确地&amp;rdquo;显示为与stat状态不匹配的任何文件显示出来。这两个操作确实非常有用。</target>
        </trans-unit>
        <trans-unit id="7c0716128ee4fbd827cb316e0652131c44810ab6" translate="yes" xml:space="preserve">
          <source>You can configure gitweb to only list and allow viewing of the explicitly exported repositories, via &lt;code&gt;$export_ok&lt;/code&gt; variable in gitweb config file; see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; manpage. If it evaluates to true, gitweb shows repositories only if this file named by &lt;code&gt;$export_ok&lt;/code&gt; exists in its object database (if directory has the magic file named &lt;code&gt;$export_ok&lt;/code&gt;).</source>
          <target state="translated">您可以通过gitweb配置文件中的 &lt;code&gt;$export_ok&lt;/code&gt; 变量将gitweb配置为仅列出并允许查看显式导出的存储库。请参见&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt;联机帮助页。如果评估结果为true，则gitweb仅在对象数据库中存在 &lt;code&gt;$export_ok&lt;/code&gt; 命名的文件时（如果目录中包含名为 &lt;code&gt;$export_ok&lt;/code&gt; 的魔术文件），才显示存储库。</target>
        </trans-unit>
        <trans-unit id="03a65df391294815ab470e62357c9e62de1fcfb2" translate="yes" xml:space="preserve">
          <source>You can configure individual repositories shown in gitweb by creating file in the &lt;code&gt;GIT_DIR&lt;/code&gt; of Git repository, or by setting some repo configuration variable (in &lt;code&gt;GIT_DIR/config&lt;/code&gt;, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">您可以通过在Git存储库的 &lt;code&gt;GIT_DIR&lt;/code&gt; 中创建文件，或通过设置一些存储库配置变量（在 &lt;code&gt;GIT_DIR/config&lt;/code&gt; 中，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）来配置gitweb中显示的各个存储库。</target>
        </trans-unit>
        <trans-unit id="45321feeff0945f0a2ba053e8ab969c82cc417c8" translate="yes" xml:space="preserve">
          <source>You can configure the database backend with the following configuration variables:</source>
          <target state="translated">您可以通过以下配置变量来配置数据库后端。</target>
        </trans-unit>
        <trans-unit id="d268b7f609741cf4701b8230b6d95314deb17a7a" translate="yes" xml:space="preserve">
          <source>You can create a new commit that undoes whatever was done by the old commit. This is the correct thing if your mistake has already been made public.</source>
          <target state="translated">你可以创建一个新的提交,撤销旧提交所做的一切。如果你的错误已经被公开,这才是正确的做法。</target>
        </trans-unit>
        <trans-unit id="d8a9d4babf707e6fca47541eba4fa0b4e8c8edd2" translate="yes" xml:space="preserve">
          <source>You can customize the rules that &lt;code&gt;git diff --word-diff&lt;/code&gt; uses to split words in a line, by specifying an appropriate regular expression in the &quot;diff.*.wordRegex&quot; configuration variable. For example, in TeX a backslash followed by a sequence of letters forms a command, but several such commands can be run together without intervening whitespace. To separate them, use a regular expression in your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">您可以通过在&amp;ldquo; diff。*。wordRegex&amp;rdquo;配置变量中指定适当的正则表达式，来定制 &lt;code&gt;git diff --word-diff&lt;/code&gt; 用于在一行中分割单词的规则。例如，在TeX中，反斜杠后跟一个字母序列构成一个命令，但是几个这样的命令可以一起运行而无需插入空格。要分隔它们，请在 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 文件（或 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 文件）中使用正则表达式，如下所示：</target>
        </trans-unit>
        <trans-unit id="38bcfec4c9f80337cd439b12b7afb0a63bb0fcb7" translate="yes" xml:space="preserve">
          <source>You can declare that a filter turns a content that by itself is unusable into a usable content by setting the filter.&amp;lt;driver&amp;gt;.required configuration variable to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">您可以通过将filter。&amp;lt;driver&amp;gt; .required配置变量设置为 &lt;code&gt;true&lt;/code&gt; 来声明过滤器将本身无法使用的内容转换为可用内容。</target>
        </trans-unit>
        <trans-unit id="d7aeeb9d27bdf323aad4937a225d2c2d1d7d6f4b" translate="yes" xml:space="preserve">
          <source>You can easily create such a branch with Git using interactive rebase.</source>
          <target state="translated">你可以用Git的交互式Rebase轻松创建这样一个分支。</target>
        </trans-unit>
        <trans-unit id="2f7816df4cc860a9cfdb50146ff125e3acb46178" translate="yes" xml:space="preserve">
          <source>You can enforce finer grained permissions using update hooks. See &lt;a href=&quot;https://git-scm.com/docs/howto/update-hook-example&quot;&gt;Controlling access to branches using update hooks&lt;/a&gt;.</source>
          <target state="translated">您可以使用更新挂钩来强制执行更细粒度的权限。请参阅&lt;a href=&quot;https://git-scm.com/docs/howto/update-hook-example&quot;&gt;使用更新挂钩控制对分支的访问&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dca6628a0b53b9b002cd44ea35104ed275c53c21" translate="yes" xml:space="preserve">
          <source>You can examine one of those dangling commits with, for example,</source>
          <target state="translated">你可以用,例如,检查其中一个悬空的提交。</target>
        </trans-unit>
        <trans-unit id="4807484ba96d5012055b128c8602211fd418a27a" translate="yes" xml:space="preserve">
          <source>You can examine such index state with &lt;code&gt;git ls-files --unmerged&lt;/code&gt; command. An example:</source>
          <target state="translated">您可以使用 &lt;code&gt;git ls-files --unmerged&lt;/code&gt; 命令检查这种索引状态。一个例子：</target>
        </trans-unit>
        <trans-unit id="b5f066a300ab7fb920ca504e5ef4559d46dabfb5" translate="yes" xml:space="preserve">
          <source>You can examine the data represented in the object database and the index with various helper tools. For every object, you can use &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt; to examine details about the object:</source>
          <target state="translated">您可以使用各种帮助程序工具检查对象数据库中表示的数据和索引。对于每个对象，您可以使用&lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1]&lt;/a&gt;检查有关该对象的详细信息：</target>
        </trans-unit>
        <trans-unit id="fd093df539bb25e8d4c6b75d7c53e29317d7deb5" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to the tool by setting the configuration variable &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to kdiff3 by setting &lt;code&gt;difftool.kdiff3.path&lt;/code&gt;. Otherwise, &lt;code&gt;git difftool&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">您可以通过设置配置变量 &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 来显式提供该工具的完整路径。例如，您可以通过设置 &lt;code&gt;difftool.kdiff3.path&lt;/code&gt; 来配置kdiff3的绝对路径。否则， &lt;code&gt;git difftool&lt;/code&gt; 假定该工具在PATH中可用。</target>
        </trans-unit>
        <trans-unit id="146074b490cdd862abeb41d866c18f9aaa225cf8" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to the tool by setting the configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to kdiff3 by setting &lt;code&gt;mergetool.kdiff3.path&lt;/code&gt;. Otherwise, &lt;code&gt;git mergetool&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">您可以通过设置配置变量 &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 来显式提供该工具的完整路径。例如，您可以通过设置 &lt;code&gt;mergetool.kdiff3.path&lt;/code&gt; 来配置kdiff3的绝对路径。否则， &lt;code&gt;git mergetool&lt;/code&gt; 假定该工具在PATH中可用。</target>
        </trans-unit>
        <trans-unit id="77cbe572067fa57bc4362002e12fc6b7b8a04482" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to your preferred browser by setting the configuration variable &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to firefox by setting &lt;code&gt;browser.firefox.path&lt;/code&gt;. Otherwise, &lt;code&gt;git web--browse&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d73514fe413b4199a0b5fc2096f965b3e1620ee" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to your preferred man viewer by setting the configuration variable &lt;code&gt;man.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to konqueror by setting &lt;code&gt;man.konqueror.path&lt;/code&gt;. Otherwise, &lt;code&gt;git help&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">您可以通过设置配置变量 &lt;code&gt;man.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 来明确提供首选的man查看器的完整路径。例如，您可以通过设置 &lt;code&gt;man.konqueror.path&lt;/code&gt; 来配置konqueror的绝对路径。否则， &lt;code&gt;git help&lt;/code&gt; 会假定该工具在PATH中可用。</target>
        </trans-unit>
        <trans-unit id="11d166169fafafa437c100a2b764012cf5981ced" translate="yes" xml:space="preserve">
          <source>You can focus your efforts to check at a few points (for example rc and beta releases) that all the T test cases pass for all the N configurations. And when some tests don&amp;rsquo;t pass you can use &quot;git bisect&quot; (or better &quot;git bisect run&quot;). So you should perform roughly:</source>
          <target state="translated">您可以集中精力检查几个点（例如rc和beta版本），所有N个配置都通过了所有T测试用例。并且当某些测试未通过时，您可以使用&amp;ldquo; git bisect&amp;rdquo;（或更好的&amp;ldquo; git bisect run&amp;rdquo;）。因此，您应该大致执行以下操作：</target>
        </trans-unit>
        <trans-unit id="59d0d873078b4f91b40c2ee1e2770f185d430915" translate="yes" xml:space="preserve">
          <source>You can further cut down the number of trials, if you know what part of the tree is involved in the problem you are tracking down, by specifying path parameters when issuing the &lt;code&gt;bisect start&lt;/code&gt; command:</source>
          <target state="translated">如果您知道要跟踪的问题涉及树的哪一部分，则可以通过发出 &lt;code&gt;bisect start&lt;/code&gt; 命令时指定路径参数来进一步减少试验次数：</target>
        </trans-unit>
        <trans-unit id="e5857d2949fb11d516cd50de71765499d023b3f6" translate="yes" xml:space="preserve">
          <source>You can generate diffs between any two versions using &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;:</source>
          <target state="translated">您可以使用&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;在任意两个版本之间生成差异：</target>
        </trans-unit>
        <trans-unit id="98e4a2c67e91124741c5ae666b50315da705ecdc" translate="yes" xml:space="preserve">
          <source>You can generate the projects list index file using the project_index action (the &lt;code&gt;TXT&lt;/code&gt; link on projects list page) directly from gitweb; see also &quot;Generating projects list using gitweb&quot; section below.</source>
          <target state="translated">您可以直接从gitweb 使用project_index操作（项目列表页面上的 &lt;code&gt;TXT&lt;/code&gt; 链接）生成项目列表索引文件；另请参见下面的&amp;ldquo;使用gitweb生成项目列表&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5b042e446e3f9ebd4b31fc02aac55f5c329ead7e" translate="yes" xml:space="preserve">
          <source>You can get a list of all available encodings on your platform with the following command:</source>
          <target state="translated">你可以通过以下命令获得你的平台上所有可用编码的列表。</target>
        </trans-unit>
        <trans-unit id="3d921181a0df868b1892f0a3e234a9c29e516883" translate="yes" xml:space="preserve">
          <source>You can get just the old (respectively new) term with &lt;code&gt;git bisect terms
--term-old&lt;/code&gt; or &lt;code&gt;git bisect terms --term-good&lt;/code&gt;.</source>
          <target state="translated">您可以使用 &lt;code&gt;git bisect terms --term-old&lt;/code&gt; 或 &lt;code&gt;git bisect terms --term-good&lt;/code&gt; 来获得旧的（相应的）术语。</target>
        </trans-unit>
        <trans-unit id="41b9643f0720517e2c1772471e0c09d5c46b9644" translate="yes" xml:space="preserve">
          <source>You can give the &lt;code&gt;-m&lt;/code&gt; flag to the command, which would try a three-way merge:</source>
          <target state="translated">您可以将 &lt;code&gt;-m&lt;/code&gt; 标志赋予该命令，该命令将尝试三向合并：</target>
        </trans-unit>
        <trans-unit id="36617ae8104572554e1e13e9574934aea0623eb3" translate="yes" xml:space="preserve">
          <source>You can go back and modify the old commit. You should never do this if you have already made the history public; Git does not normally expect the &quot;history&quot; of a project to change, and cannot correctly perform repeated merges from a branch that has had its history changed.</source>
          <target state="translated">您可以返回并修改旧的提交。如果您已经公开了历史记录,千万不要这么做;Git 通常不会期望项目的 &quot;历史记录 &quot;会发生变化,也不能正确地从一个已经改变了历史记录的分支中重复合并。</target>
        </trans-unit>
        <trans-unit id="427cec7db1c8d9c41ec669de64df63aacc49a26f" translate="yes" xml:space="preserve">
          <source>You can grow a new branch from any commit. For example, switch to &quot;HEAD~3&quot; and create branch &quot;fixup&quot;:</source>
          <target state="translated">你可以从任何提交中生长一个新的分支。例如,切换到 &quot;HEAD~3 &quot;并创建分支 &quot;fixup&quot;。</target>
        </trans-unit>
        <trans-unit id="8abddb96169bb94a7080d5c82ed5cac7b229954a" translate="yes" xml:space="preserve">
          <source>You can have a mixture of files show up as &quot;has been updated&quot; and &quot;is still dirty in the working directory&quot; together. You can always tell which file is in which state, since the &quot;has been updated&quot; ones show a valid sha1, and the &quot;not in sync with the index&quot; ones will always have the special all-zero sha1.</source>
          <target state="translated">你可以让混合的文件一起显示为 &quot;已经更新 &quot;和 &quot;在工作目录中仍然是脏文件&quot;。你总是可以判断出哪个文件处于哪种状态,因为 &quot;已经更新 &quot;的文件会显示一个有效的sha1,而 &quot;与索引不同步 &quot;的文件总是有一个特殊的全零的sha1。</target>
        </trans-unit>
        <trans-unit id="ae3f7bca446e950bd716349b25ee5d05aaee6a26" translate="yes" xml:space="preserve">
          <source>You can include a config file from another by setting the special &lt;code&gt;include.path&lt;/code&gt; (or &lt;code&gt;includeIf.*.path&lt;/code&gt;) variable to the name of the file to be included. The variable takes a pathname as its value, and is subject to tilde expansion. These variables can be given multiple times.</source>
          <target state="translated">您可以通过将特殊的 &lt;code&gt;include.path&lt;/code&gt; （或 &lt;code&gt;includeIf.*.path&lt;/code&gt; ）变量设置为要包含的文件的名称来包含另一个配置文件。该变量采用路径名作为其值，并且受波浪号的影响。这些变量可以多次给出。</target>
        </trans-unit>
        <trans-unit id="5145f6f36a43ec5e98537ca833d15e8282538fcf" translate="yes" xml:space="preserve">
          <source>You can include a config file from another conditionally by setting a &lt;code&gt;includeIf.&amp;lt;condition&amp;gt;.path&lt;/code&gt; variable to the name of the file to be included.</source>
          <target state="translated">通过将 &lt;code&gt;includeIf.&amp;lt;condition&amp;gt;.path&lt;/code&gt; 变量设置为要包含的文件的名称，可以有条件地包含另一个配置文件。</target>
        </trans-unit>
        <trans-unit id="509dfc228243cbfccb732c55df31d8f926c42b85" translate="yes" xml:space="preserve">
          <source>You can include other configuration file using read_config_file() subroutine. For example, one might want to put gitweb configuration related to access control for viewing repositories via Gitolite (one of Git repository management tools) in a separate file, e.g. in &lt;code&gt;/etc/gitweb-gitolite.conf&lt;/code&gt;. To include it, put</source>
          <target state="translated">您可以使用read_config_file（）子例程包含其他配置文件。例如，可能要把与访问控制相关的gitweb配置放在一个单独的文件中，以便通过Gitolite（一种Git存储库管理工具）查看存储库，例如在 &lt;code&gt;/etc/gitweb-gitolite.conf&lt;/code&gt; 中。要包括它，把</target>
        </trans-unit>
        <trans-unit id="645452c6d997e8f480a9efb060142f580408b9f7" translate="yes" xml:space="preserve">
          <source>You can make a different change on the master branch:</source>
          <target state="translated">你可以在主分支上做不同的改变。</target>
        </trans-unit>
        <trans-unit id="9d56811ee77d2943d64ee7741c452578a4d84979" translate="yes" xml:space="preserve">
          <source>You can make interesting things happen to a repository every time you push into it, by setting up &lt;code&gt;hooks&lt;/code&gt; there. See documentation for &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;.</source>
          <target state="translated">每次在存储库中建立 &lt;code&gt;hooks&lt;/code&gt; 时，都可以使它发生有趣的事情。参见&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]的&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="31caee42f233cd83de2778af5287eb406c23a1ef" translate="yes" xml:space="preserve">
          <source>You can make sure &lt;code&gt;git show-branch&lt;/code&gt; matches the state before those two &lt;code&gt;git merge&lt;/code&gt; you just did. Then, instead of running two &lt;code&gt;git merge&lt;/code&gt; commands in a row, you would merge these two branch heads (this is known as &lt;code&gt;making an Octopus&lt;/code&gt;):</source>
          <target state="translated">您可以确保 &lt;code&gt;git show-branch&lt;/code&gt; 与您刚完成的两个 &lt;code&gt;git merge&lt;/code&gt; 之前的状态匹配。然后，您不必 &lt;code&gt;git merge&lt;/code&gt; 运行两个git merge命令，而是合并这两个分支头（这被称为 &lt;code&gt;making an Octopus&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="b0c1a53571be700b171dec8a7fa266ccfd88fbe8" translate="yes" xml:space="preserve">
          <source>You can make the appropriate change to your working tree, run &lt;code&gt;git add
&amp;lt;file&amp;gt;&lt;/code&gt; or &lt;code&gt;git rm &amp;lt;file&amp;gt;&lt;/code&gt;, as appropriate, to stage it, and then &lt;code&gt;git
commit --amend&lt;/code&gt;. Your change will be included in the commit, and you&amp;rsquo;ll be prompted to edit the commit message again; if you wish to use the original message verbatim, you can use the &lt;code&gt;--no-edit&lt;/code&gt; option to &lt;code&gt;git
commit&lt;/code&gt; in addition, or just save and quit when your editor opens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f748b043bbe97de82ec4f7b6a5308c58b703d36" translate="yes" xml:space="preserve">
          <source>You can make the server use the end-of-line conversion attributes to set the &lt;code&gt;-k&lt;/code&gt; modes for files by setting the &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; config variable. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for more information about end-of-line conversion.</source>
          <target state="translated">您可以通过设置 &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 配置变量，使服务器使用行尾转换属性来设置文件的 &lt;code&gt;-k&lt;/code&gt; 模式。有关行尾转换的更多信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="015443f769a79760c1933372fa244563a6a25aba" translate="yes" xml:space="preserve">
          <source>You can omit having to type return here, by setting the configuration variable &lt;code&gt;interactive.singleKey&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">您可以通过将配置变量 &lt;code&gt;interactive.singleKey&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 来省略在此处键入return的操作。</target>
        </trans-unit>
        <trans-unit id="358c29af25eb707e9507c2c41ba2c41fddac22f4" translate="yes" xml:space="preserve">
          <source>You can override these rules either by command-line options or by environment variables. The &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--system&lt;/code&gt; and &lt;code&gt;--worktree&lt;/code&gt; options will limit the file used to the global, system-wide or per-worktree file respectively. The &lt;code&gt;GIT_CONFIG&lt;/code&gt; environment variable has a similar effect, but you can specify any filename you want.</source>
          <target state="translated">您可以通过命令行选项或环境变量覆盖这些规则。该 &lt;code&gt;--global&lt;/code&gt; ， &lt;code&gt;--system&lt;/code&gt; 和 &lt;code&gt;--worktree&lt;/code&gt; 选项将限制用于全局，全系统或分别为每worktree文件的文件。该 &lt;code&gt;GIT_CONFIG&lt;/code&gt; 环境变量有类似的效果，但您可以指定任何你想要的文件名。</target>
        </trans-unit>
        <trans-unit id="b9256a8bfff0f4e1e2098927e9ff118ae66b3eab" translate="yes" xml:space="preserve">
          <source>You can perform &quot;git pull&quot;, resolve potential conflicts, and &quot;git push&quot; the result. A &quot;git pull&quot; will create a merge commit C between commits A and B.</source>
          <target state="translated">您可以执行 &quot;git pull&quot;,解决潜在的冲突,然后将结果 &quot;git push&quot;。git pull &quot;将在提交A和B之间创建一个合并提交C。</target>
        </trans-unit>
        <trans-unit id="189a9ed33e189223869b33620d09d0f720bf3fe1" translate="yes" xml:space="preserve">
          <source>You can provide options via the credential.helper configuration variable (this example drops the cache time to 5 minutes):</source>
          <target state="translated">你可以通过credential.helper配置变量提供选项(本例将缓存时间降为5分钟)。</target>
        </trans-unit>
        <trans-unit id="82656460f1d1171626ca7a2547e75d0458741fd5" translate="yes" xml:space="preserve">
          <source>You can query/set/replace/unset options with this command. The name is actually the section and the key separated by a dot, and the value will be escaped.</source>
          <target state="translated">你可以用这个命令查询/设置/替换/取消设置选项。名称实际上是用点号分隔的部分和键,值会被转义。</target>
        </trans-unit>
        <trans-unit id="10e463ee2669848fa9bb9fc90b4474d38bbf73be" translate="yes" xml:space="preserve">
          <source>You can rejoin two diverging branches of development using &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;:</source>
          <target state="translated">您可以使用&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;重新加入两个不同的开发分支：</target>
        </trans-unit>
        <trans-unit id="3e4277417393477fbeb632e41395d74e0a0e4169" translate="yes" xml:space="preserve">
          <source>You can repack this private repository whenever you feel like.</source>
          <target state="translated">你可以随时重新打包这个私人仓库。</target>
        </trans-unit>
        <trans-unit id="3425cb44f3c2a0393cb24a6806cf1648e47fe578" translate="yes" xml:space="preserve">
          <source>You can repeat steps 2-4 multiple times to break the original code into any number of commits.</source>
          <target state="translated">你可以多次重复步骤2-4,将原代码分解成任意数量的提交。</target>
        </trans-unit>
        <trans-unit id="f016259f2ce9ae7193e573b7fa2135698ca39f54" translate="yes" xml:space="preserve">
          <source>You can rewrite the commit log messages using &lt;code&gt;--msg-filter&lt;/code&gt;. For example, &lt;code&gt;git svn-id&lt;/code&gt; strings in a repository created by &lt;code&gt;git svn&lt;/code&gt; can be removed this way:</source>
          <target state="translated">您可以使用 &lt;code&gt;--msg-filter&lt;/code&gt; 重写提交日志消息。例如，可以通过以下方式删除由 &lt;code&gt;git svn&lt;/code&gt; 创建的存储库中的 &lt;code&gt;git svn-id&lt;/code&gt; 字符串：</target>
        </trans-unit>
        <trans-unit id="6928e91b0b4a87a6f0188b338ec935fa803e932d" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;git-bundle verify&lt;/code&gt; to see if you can extract from a bundle that was created with a basis:</source>
          <target state="translated">您可以运行 &lt;code&gt;git-bundle verify&lt;/code&gt; 来查看是否可以从基于基础创建的捆绑包中提取：</target>
        </trans-unit>
        <trans-unit id="28f57e6715a38d45260ef8d226913fe9d5e46420" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;gitk --all&lt;/code&gt; again to see how the commit ancestry looks like, or run &lt;code&gt;show-branch&lt;/code&gt;, which tells you this.</source>
          <target state="translated">您可以再次运行 &lt;code&gt;gitk --all&lt;/code&gt; 来查看提交祖先的外观，或者运行 &lt;code&gt;show-branch&lt;/code&gt; ，告诉您这一点。</target>
        </trans-unit>
        <trans-unit id="ee22a2dcf21325c45ae74e5933824496ebc88dee" translate="yes" xml:space="preserve">
          <source>You can save space and make Git faster by moving these loose objects in to a &quot;pack file&quot;, which stores a group of objects in an efficient compressed format; the details of how pack files are formatted can be found in &lt;a href=&quot;pack-format&quot;&gt;pack format&lt;/a&gt;.</source>
          <target state="translated">通过将这些松散的对象移入&amp;ldquo;打包文件&amp;rdquo;，可以节省空间并使Git更快，该文件以有效的压缩格式存储一组对象。有关打包文件格式的详细信息，请参见&lt;a href=&quot;pack-format&quot;&gt;打包格式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="923ef556c5ea1d367a9ceb952e817561488d6f46" translate="yes" xml:space="preserve">
          <source>You can see easily that the above is a rename.</source>
          <target state="translated">你很容易就能看出,以上是重名。</target>
        </trans-unit>
        <trans-unit id="5724c58e846fc905ad55d8bc9c332033225407c5" translate="yes" xml:space="preserve">
          <source>You can set this to &lt;code&gt;link&lt;/code&gt;, in which case a hardlink followed by a delete of the source are used to make sure that object creation will not overwrite existing objects.</source>
          <target state="translated">您可以将其设置为 &lt;code&gt;link&lt;/code&gt; ，在这种情况下，使用硬链接和删除源代码来确保对象创建不会覆盖现有对象。</target>
        </trans-unit>
        <trans-unit id="02df8661fe031a54ab42701feedaa37cd7c87875" translate="yes" xml:space="preserve">
          <source>You can setup one single value (single entry/item in this list) at build time by setting the &lt;code&gt;GITWEB_BASE_URL&lt;/code&gt; build-time configuration variable. By default it is set to (), i.e. an empty list. This means that gitweb would not try to create project URL (to fetch) from project name.</source>
          <target state="translated">您可以通过设置 &lt;code&gt;GITWEB_BASE_URL&lt;/code&gt; 构建时配置变量在构建时设置一个单一值（此列表中的单个条目/项目）。默认情况下，它设置为（），即一个空列表。这意味着gitweb不会尝试从项目名称创建（获取）项目URL。</target>
        </trans-unit>
        <trans-unit id="af5fba33ca90f8278cecf2701efca5c8b71085ca" translate="yes" xml:space="preserve">
          <source>You can specify a list of allowed directories. If no directories are given, all are allowed. This is an additional restriction, gitcvs access still needs to be enabled by the &lt;code&gt;gitcvs.enabled&lt;/code&gt; config option unless &lt;code&gt;--export-all&lt;/code&gt; was given, too.</source>
          <target state="translated">您可以指定允许目录的列表。如果没有给出目录，则全部允许。这是一个额外的限制，除非也给出了 &lt;code&gt;--export-all&lt;/code&gt; ，否则仍需要通过 &lt;code&gt;gitcvs.enabled&lt;/code&gt; config选项启用gitcvs访问。</target>
        </trans-unit>
        <trans-unit id="a2f1a86c57fcd513fcca4d9c2bf5f81069f36bf3" translate="yes" xml:space="preserve">
          <source>You can specify extra mail header lines to be added to each message, defaults for the subject prefix and file suffix, number patches when outputting more than one patch, add &quot;To:&quot; or &quot;Cc:&quot; headers, configure attachments, change the patch output directory, and sign off patches with configuration variables.</source>
          <target state="translated">您可以指定要添加到每个邮件的额外邮件头行、主题前缀和文件后缀的默认值、输出多个补丁时的补丁数量、添加 &quot;To:&quot;或 &quot;Cc:&quot;头、配置附件、更改补丁输出目录,以及使用配置变量签署补丁。</target>
        </trans-unit>
        <trans-unit id="c33dd2cd2261f81cbd0fc492df4e16b1e747c25d" translate="yes" xml:space="preserve">
          <source>You can specify the information shown for each object by using a custom &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;. The &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; is copied literally to stdout for each object, with placeholders of the form &lt;code&gt;%(atom)&lt;/code&gt; expanded, followed by a newline. The available atoms are:</source>
          <target state="translated">您可以使用自定义 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 指定每个对象显示的信息。对于每个对象，将 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 逐字地复制到stdout，并扩展格式为 &lt;code&gt;%(atom)&lt;/code&gt; 的占位符，后跟换行符。可用原子为：</target>
        </trans-unit>
        <trans-unit id="50f1e86bfea2179ec0dc9556f31c0b7322253687" translate="yes" xml:space="preserve">
          <source>You can store the files in the repository with Unix line endings and convert them automatically to your platform&amp;rsquo;s line endings. To do that, set the configuration option &lt;code&gt;core.eol&lt;/code&gt; to &lt;code&gt;native&lt;/code&gt; and see the following entry for information about how to configure files as text or binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a94d83b2aa4f52ca10b82e1786cdc28d9f55e56" translate="yes" xml:space="preserve">
          <source>You can tell Git to ignore certain files by creating a file called &lt;code&gt;.gitignore&lt;/code&gt; in the top level of your working directory, with contents such as:</source>
          <target state="translated">您可以通过在工作目录的顶层创建一个名为 &lt;code&gt;.gitignore&lt;/code&gt; 的文件来告诉Git忽略某些文件，其内容如下：</target>
        </trans-unit>
        <trans-unit id="491f06c247008ffc2db5fcd9f930c35d5e25a466" translate="yes" xml:space="preserve">
          <source>You can tell Git to split the Git internal information from the directory that it tracks, but we&amp;rsquo;ll ignore that for now: it&amp;rsquo;s not how normal projects work, and it&amp;rsquo;s really only meant for special uses. So the mental model of &quot;the Git information is always tied directly to the working tree that it describes&quot; may not be technically 100% accurate, but it&amp;rsquo;s a good model for all normal use.</source>
          <target state="translated">您可以告诉Git从它跟踪的目录中拆分Git内部信息，但是我们暂时将其忽略：这不是正常项目的工作方式，它实际上仅用于特殊用途。因此，&amp;ldquo; Git信息始终直接与其所描述的工作树相关联&amp;rdquo;的思维模型在技术上可能并非100％准确，但是对于所有正常使用而言，这都是一个很好的模型。</target>
        </trans-unit>
        <trans-unit id="eba2ddb51d288f0b3a9988b4f1ccbdcde132a1f4" translate="yes" xml:space="preserve">
          <source>You can test whether the filesystem supports that with the &lt;code&gt;--test-untracked-cache&lt;/code&gt; option. The &lt;code&gt;--untracked-cache&lt;/code&gt; option used to implicitly perform that test in older versions of Git, but that&amp;rsquo;s no longer the case.</source>
          <target state="translated">您可以使用 &lt;code&gt;--test-untracked-cache&lt;/code&gt; 选项测试文件系统是否支持该功能。该 &lt;code&gt;--untracked-cache&lt;/code&gt; 用于隐含期权执行旧版本的Git的那个测试，但是这不再是这种情况。</target>
        </trans-unit>
        <trans-unit id="33337304817f97abbb584fa2c7541a14abb9bfcd" translate="yes" xml:space="preserve">
          <source>You can then fix the conflicts during the rebase. Presumably you have not published your topic other than by mail, so rebasing it is not a problem.</source>
          <target state="translated">然后你可以在重垒时解决冲突。大概你除了邮件之外,还没有发布过你的主题,所以重基不是问题。</target>
        </trans-unit>
        <trans-unit id="d6b74e3d43432e56c49f83bf0e8c1bc1b7ac50b8" translate="yes" xml:space="preserve">
          <source>You can then import these into your mail client and send them by hand. However, if you have a lot to send at once, you may prefer to use the &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; script to automate the process. Consult the mailing list for your project first to determine their requirements for submitting patches.</source>
          <target state="translated">然后，您可以将它们导入到您的邮件客户端中并手动发送。但是，如果您一次&lt;a href=&quot;git-send-email&quot;&gt;发送的邮件&lt;/a&gt;太多，则可能更喜欢使用git-send-email [1]脚本来自动执行该过程。请先咨询您项目的邮件列表，以确定其提交补丁的要求。</target>
        </trans-unit>
        <trans-unit id="ad2194dc994cc556c2451e6a9d4c256f90b5afd4" translate="yes" xml:space="preserve">
          <source>You can then transplant the old &lt;code&gt;subsystem..topic&lt;/code&gt; to the new tip by saying (for the reflog case, and assuming you are on &lt;code&gt;topic&lt;/code&gt; already):</source>
          <target state="translated">然后，您可以通过说（对于reflog案例，并假设您已经关注 &lt;code&gt;topic&lt;/code&gt; ）将旧的 &lt;code&gt;subsystem..topic&lt;/code&gt; ..topic 移植到新技巧中：</target>
        </trans-unit>
        <trans-unit id="b5bb69809c9820257d5f27c5ec379a4130c453d8" translate="yes" xml:space="preserve">
          <source>You can think of this as a set operation. Commits given on the command line form a set of commits that are reachable from any of them, and then commits reachable from any of the ones given with &lt;code&gt;^&lt;/code&gt; in front are subtracted from that set. The remaining commits are what comes out in the command&amp;rsquo;s output. Various other options and paths parameters can be used to further limit the result.</source>
          <target state="translated">您可以将其视为固定操作。在命令行上给出的提交构成了一组可从它们中的任何一个到达的提交，然后从该集合中减去前面带 &lt;code&gt;^&lt;/code&gt; 给出的任何一个可到达的提交。其余的提交就是命令输出中显示的内容。各种其他选项和路径参数可用于进一步限制结果。</target>
        </trans-unit>
        <trans-unit id="497fe81f829587b397446cebabae5d6848f111c9" translate="yes" xml:space="preserve">
          <source>You can think of this as a set operation. Commits reachable from any of the commits given on the command line form a set, and then commits reachable from any of the ones given with &lt;code&gt;^&lt;/code&gt; in front are subtracted from that set. The remaining commits are what comes out in the command&amp;rsquo;s output. Various other options and paths parameters can be used to further limit the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eacfd2b96f144de251fd3721b44d6ad9ca988b86" translate="yes" xml:space="preserve">
          <source>You can try running &lt;code&gt;find .git/objects -type f&lt;/code&gt; before and after you run &lt;code&gt;git prune-packed&lt;/code&gt; if you are curious. Also &lt;code&gt;git
count-objects&lt;/code&gt; would tell you how many unpacked objects are in your repository and how much space they are consuming.</source>
          <target state="translated">如果您好奇，可以在运行 &lt;code&gt;git prune-packed&lt;/code&gt; 之前和之后尝试运行 &lt;code&gt;find .git/objects -type f&lt;/code&gt; 。此外 &lt;code&gt;git count-objects&lt;/code&gt; 会告诉你很多解压对象是如何在你的仓库和多少空间，他们消耗。</target>
        </trans-unit>
        <trans-unit id="78c0fba98badb6e25ce1949ee53cb8839b8be51a" translate="yes" xml:space="preserve">
          <source>You can update the shared repository with your changes by first committing your changes, and then using the &lt;code&gt;git push&lt;/code&gt; command:</source>
          <target state="translated">您可以使用更改来更新共享存储库，方法是先提交更改，然后使用 &lt;code&gt;git push&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="fe24364fca4da5268b93a1c7c864762589bec5d4" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; to examine the contents of a blob; take, for example, the blob in the entry for &lt;code&gt;COPYING&lt;/code&gt; from the tree above:</source>
          <target state="translated">您可以使用&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;来检查blob的内容；以上面树中的 &lt;code&gt;COPYING&lt;/code&gt; 条目中的blob为例：</target>
        </trans-unit>
        <trans-unit id="cdee252fbf6b663369bb36f7a81711483c778043" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git stash push --keep-index&lt;/code&gt; when you want to make two or more commits out of the changes in the work tree, and you want to test each change before committing:</source>
          <target state="translated">如果 &lt;code&gt;git stash push --keep-index&lt;/code&gt; 工作树中的更改中进行两个或多个提交，并且要在提交之前测试每个更改，可以使用git stash push --keep-index：</target>
        </trans-unit>
        <trans-unit id="b954fc6ff3f193031cbeca4547760f3425491805" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git stash&lt;/code&gt; to simplify the above, like this:</source>
          <target state="translated">您可以使用 &lt;code&gt;git stash&lt;/code&gt; 简化上述操作，如下所示：</target>
        </trans-unit>
        <trans-unit id="c482710749f3dcad6cbdc9701b2eb8b0d7f62e6a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;stable-1&lt;/code&gt; to refer to the commit 1b2e1d63ff.</source>
          <target state="translated">您可以使用 &lt;code&gt;stable-1&lt;/code&gt; 来引用提交1b2e1d63ff。</target>
        </trans-unit>
        <trans-unit id="783e49ef6897108ce62c504df5bb1071160ba897" translate="yes" xml:space="preserve">
          <source>You can use a basis based on time:</source>
          <target state="translated">你可以使用基于时间的基础。</target>
        </trans-unit>
        <trans-unit id="0dcaab83279bcfe9c2e3dbaa6b4f0d035029ab31" translate="yes" xml:space="preserve">
          <source>You can use a tag that is present in both:</source>
          <target state="translated">你可以使用两者都存在的标签。</target>
        </trans-unit>
        <trans-unit id="0967772702daca79ec55cd9be52c70fe75848751" translate="yes" xml:space="preserve">
          <source>You can use different &lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt; values to control this behavior:</source>
          <target state="translated">您可以使用不同的 &lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt; 值来控制此行为：</target>
        </trans-unit>
        <trans-unit id="72733e82f897a2af21fcfc3df3447e66ece75165" translate="yes" xml:space="preserve">
          <source>You can use it as a human-readable bundle replacement (see &lt;a href=&quot;git-bundle&quot;&gt;git-bundle[1]&lt;/a&gt;), or as a format that can be edited before being fed to &lt;code&gt;git fast-import&lt;/code&gt; in order to do history rewrites (an ability relied on by tools like &lt;code&gt;git filter-repo&lt;/code&gt;).</source>
          <target state="translated">您可以将其用作人类可读的bundle替换（请参阅&lt;a href=&quot;git-bundle&quot;&gt;git-bundle [1]&lt;/a&gt;），也可以将其用作可以在馈入 &lt;code&gt;git fast-import&lt;/code&gt; 之前进行编辑的格式，以进行历史记录重写（工具依赖此功能）像 &lt;code&gt;git filter-repo&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6b34e82e0ff80209e7866272f371ddd1420b0f13" translate="yes" xml:space="preserve">
          <source>You can use mod_perl with gitweb. You must install Apache::Registry (for mod_perl 1.x) or ModPerl::Registry (for mod_perl 2.x) to enable this support.</source>
          <target state="translated">你可以在 gitweb 上使用 mod_perl。你必须安装Apache::Registry (适用于mod_perl 1.x)或ModPerl::Registry (适用于mod_perl 2.x)以启用此支持。</target>
        </trans-unit>
        <trans-unit id="625924bfa2e6c050ea9730ca7a0edb6cfce2bfdc" translate="yes" xml:space="preserve">
          <source>You can use notes to add annotations with information that was not available at the time a commit was written.</source>
          <target state="translated">您可以使用备注来添加在提交时没有的信息的注释。</target>
        </trans-unit>
        <trans-unit id="0bbbcd5b5890880e82d452d584e7cf77013dabac" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@&lt;/code&gt; construct with an empty ref part to get at a reflog entry of the current branch. For example, if you are on branch &lt;code&gt;blabla&lt;/code&gt; then &lt;code&gt;@{1}&lt;/code&gt; means the same as &lt;code&gt;blabla@{1}&lt;/code&gt;.</source>
          <target state="translated">您可以将 &lt;code&gt;@&lt;/code&gt; 构造与一个空的ref部分一起使用，以获取当前分支的reflog条目。例如，如果您在分支 &lt;code&gt;blabla&lt;/code&gt; 上,则 &lt;code&gt;@{1}&lt;/code&gt; 含义与 &lt;code&gt;blabla@{1}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd3a4b2dd2cada66b7023aa9fae3c933422c9fcc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@{-N}&lt;/code&gt; syntax to refer to the N-th last branch/commit checked out using &quot;git checkout&quot; operation. You may also specify &lt;code&gt;-&lt;/code&gt; which is synonymous to &lt;code&gt;@{-1}&lt;/code&gt;.</source>
          <target state="translated">您可以使用 &lt;code&gt;@{-N}&lt;/code&gt; 语法使用&amp;ldquo; git checkout&amp;rdquo;操作来引用第N个最后一个分支/提交。您还可以指定 &lt;code&gt;-&lt;/code&gt; 与 &lt;code&gt;@{-1}&lt;/code&gt; 同义。</target>
        </trans-unit>
        <trans-unit id="e21f11f93a4b8bdb963de3cd700b58b5db33242a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@{-N}&lt;/code&gt; syntax to refer to the N-th last branch/commit switched to using &quot;git switch&quot; or &quot;git checkout&quot; operation. You may also specify &lt;code&gt;-&lt;/code&gt; which is synonymous to &lt;code&gt;@{-1}&lt;/code&gt;. This is often used to switch quickly between two branches, or to undo a branch switch by mistake.</source>
          <target state="translated">您可以使用 &lt;code&gt;@{-N}&lt;/code&gt; 语法来引用使用&amp;ldquo; git switch&amp;rdquo;或&amp;ldquo; git checkout&amp;rdquo;操作切换到第N个最后一个分支/提交。您还可以指定 &lt;code&gt;-&lt;/code&gt; 与 &lt;code&gt;@{-1}&lt;/code&gt; 同义。这通常用于在两个分支之间快速切换，或错误地撤消分支开关。</target>
        </trans-unit>
        <trans-unit id="736fc09a09a7b16017fd49ac75e258e953294134" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;gitweb.owner&lt;/code&gt; repository configuration variable to set repository&amp;rsquo;s owner. It is displayed in the project list and summary page.</source>
          <target state="translated">您可以使用 &lt;code&gt;gitweb.owner&lt;/code&gt; 存储库配置变量来设置存储库的所有者。它显示在项目列表和摘要页面中。</target>
        </trans-unit>
        <trans-unit id="b3762dc0cf78ebbd7cf935ac045ade59a2e3acbf" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;htpasswd&lt;/code&gt; facility that comes with Apache to make these files, but Apache&amp;rsquo;s MD5 crypt method differs from the one used by most C library&amp;rsquo;s crypt() function, so don&amp;rsquo;t use the -m option.</source>
          <target state="translated">您可以使用Apache随附的 &lt;code&gt;htpasswd&lt;/code&gt; 工具来制作这些文件，但是Apache的MD5 crypt方法不同于大多数C库的crypt（）函数使用的方法，因此请不要使用-m选项。</target>
        </trans-unit>
        <trans-unit id="80aa1363be3995d4ec384e59561a0e7a0903c070" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;map&lt;/code&gt; convenience function in this filter, and other convenience functions, too. For example, calling &lt;code&gt;skip_commit &quot;$@&quot;&lt;/code&gt; will leave out the current commit (but not its changes! If you want that, use &lt;code&gt;git rebase&lt;/code&gt; instead).</source>
          <target state="translated">您也可以在此过滤器中使用 &lt;code&gt;map&lt;/code&gt; 便捷功能，以及其他便捷功能。例如，调用 &lt;code&gt;skip_commit &quot;$@&quot;&lt;/code&gt; 将忽略当前的提交（但不会更改其更改！如果需要，请使用 &lt;code&gt;git rebase&lt;/code&gt; 代替）。</target>
        </trans-unit>
        <trans-unit id="c32abff787b36e9c877031d224291d8c643f61f1" translate="yes" xml:space="preserve">
          <source>You can use the following files in repository:</source>
          <target state="translated">你可以在版本库中使用以下文件。</target>
        </trans-unit>
        <trans-unit id="b6c6eac74692734c5ec1dc3c689d37b0eb0dcea6" translate="yes" xml:space="preserve">
          <source>You can use the number of commits:</source>
          <target state="translated">你可以使用提交的数量。</target>
        </trans-unit>
        <trans-unit id="4a928f707b340dd3df65a93fa7f9942c5a65d9b2" translate="yes" xml:space="preserve">
          <source>You can very easily automatically bisect broken builds using something like:</source>
          <target state="translated">你可以很容易地使用类似这样的东西来自动分割破碎的构建。</target>
        </trans-unit>
        <trans-unit id="77487b0c89edd8fd842e99d65a1b39d2c6b378f5" translate="yes" xml:space="preserve">
          <source>You can work through the conflict with a number of tools:</source>
          <target state="translated">你可以通过一些工具来解决冲突。</target>
        </trans-unit>
        <trans-unit id="918d78d55a9c451b1a86101242b3194591c9e6cc" translate="yes" xml:space="preserve">
          <source>You can write the mandatory option parameter to an option as a separate word on the command line. That means that all the following uses work:</source>
          <target state="translated">你可以在命令行中把强制性的选项参数写成一个单独的词。这意味着下面所有的用法都可以使用。</target>
        </trans-unit>
        <trans-unit id="03d917937bc98856220155e739ac2f8752cca599" translate="yes" xml:space="preserve">
          <source>You can write your own custom helpers to interface with any system in which you keep credentials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f91f3a076bca347349424f4008dca0a1518c15" translate="yes" xml:space="preserve">
          <source>You can write your own custom helpers to interface with any system in which you keep credentials. See credential.h for details.</source>
          <target state="translated">你可以编写你自己的自定义帮助程序,以便与你保存凭证的任何系统对接。详情请参见 credential.h。</target>
        </trans-unit>
        <trans-unit id="c06b90a2f16de670e5df5d7464445ae0f28559f2" translate="yes" xml:space="preserve">
          <source>You could be using the &lt;code&gt;objects/info/alternates&lt;/code&gt; or &lt;code&gt;$GIT_ALTERNATE_OBJECT_DIRECTORIES&lt;/code&gt; mechanisms to &lt;code&gt;borrow&lt;/code&gt; objects from other object stores. A repository with this kind of incomplete object store is not suitable to be published for use with dumb transports but otherwise is OK as long as &lt;code&gt;objects/info/alternates&lt;/code&gt; points at the object stores it borrows from.</source>
          <target state="translated">您可能正在使用 &lt;code&gt;objects/info/alternates&lt;/code&gt; 或 &lt;code&gt;$GIT_ALTERNATE_OBJECT_DIRECTORIES&lt;/code&gt; 机制从其他对象存储库 &lt;code&gt;borrow&lt;/code&gt; 对象。具有这种不完整对象存储库的存储库不适合发布为与哑传输一起使用，但是只要 &lt;code&gt;objects/info/alternates&lt;/code&gt; 指向它从中借用的对象存储库就可以了。</target>
        </trans-unit>
        <trans-unit id="e2e5ecc00e320fd7f95c1d7def9e5cd07e7e5d74" translate="yes" xml:space="preserve">
          <source>You could do without using any branches at all, by keeping as many local repositories as you would like to have branches, and merging between them with &lt;em&gt;git pull&lt;/em&gt;, just like you merge between branches. The advantage of this approach is that it lets you keep a set of files for each &lt;code&gt;branch&lt;/code&gt; checked out and you may find it easier to switch back and forth if you juggle multiple lines of development simultaneously. Of course, you will pay the price of more disk usage to hold multiple working trees, but disk space is cheap these days.</source>
          <target state="translated">您可以完全不使用任何分支，只要保留想要拥有分支的本地存储库，然后使用&lt;em&gt;git pull&lt;/em&gt;在它们之间合并就可以了，就像您在分支之间合并一样。这种方法的优点是，它使您可以为每个 &lt;code&gt;branch&lt;/code&gt; 保留一组文件，并且如果同时处理多行开发，可能会发现来回切换更加容易。当然，您将付出更多磁盘使用量的代价来容纳多个工作树，但是如今磁盘空间很便宜。</target>
        </trans-unit>
        <trans-unit id="8ff03510fc9dfa2f41199478909f4845fc0f0bb6" translate="yes" xml:space="preserve">
          <source>You could have an incomplete but locally usable repository by creating a shallow clone. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;.</source>
          <target state="translated">通过创建浅表克隆，您可能拥有不完整但在本地可用的存储库。参见&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f736fa76fc678c4f130db13f45faf6b48f41687a" translate="yes" xml:space="preserve">
          <source>You could just visually inspect the commits since e05db0fd:</source>
          <target state="translated">你可以直接目视检查自e05db0fd以来的提交。</target>
        </trans-unit>
        <trans-unit id="0d78b2a8d8354041e789d882f2348db69275bdcd" translate="yes" xml:space="preserve">
          <source>You could omit &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, in which case the command degenerates to &quot;check out the current branch&quot;, which is a glorified no-op with rather expensive side-effects to show only the tracking information, if exists, for the current branch.</source>
          <target state="translated">您可以省略 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; ，在这种情况下，该命令将退化为&amp;ldquo;检出当前分支&amp;rdquo;，这是一个光荣的no-op，具有相当昂贵的副作用，仅显示当前分支的跟踪信息（如果存在）。</target>
        </trans-unit>
        <trans-unit id="7c5b22847ee058ce78c26cbc63e773fbbc9499cd" translate="yes" xml:space="preserve">
          <source>You create a commit object by giving it the tree that describes the state at the time of the commit, and a list of parents:</source>
          <target state="translated">你创建一个提交对象,给它一个描述提交时状态的树和一个父对象列表。</target>
        </trans-unit>
        <trans-unit id="0fca09140e6ecd8df23b487785db8ea6f6692c80" translate="yes" xml:space="preserve">
          <source>You do not want any end-of-line conversions applied to, nor textual diffs produced for, any binary file you track. You would need to specify e.g.</source>
          <target state="translated">您不希望任何行末转换应用于您跟踪的任何二进制文件,也不希望为其产生文本差异。您需要指定,例如</target>
        </trans-unit>
        <trans-unit id="3b6ec2c54535f15330b4b3b431cf4481da43a55b" translate="yes" xml:space="preserve">
          <source>You do random edits, without running &lt;code&gt;git update-index&lt;/code&gt;. And then you notice that the tip of your &quot;upstream&quot; tree has advanced since you pulled from him:</source>
          <target state="translated">您可以执行随机编辑，而无需运行 &lt;code&gt;git update-index&lt;/code&gt; 。然后您注意到，自从他拔出树后，&amp;ldquo;上游&amp;rdquo;树的尖端已经提前：</target>
        </trans-unit>
        <trans-unit id="96b7f9c5e1f885ad6155a2dabe0351e9e08cd246" translate="yes" xml:space="preserve">
          <source>You do your real work in your working tree that has your primary repository hanging under it as its &lt;code&gt;.git&lt;/code&gt; subdirectory. You &lt;strong&gt;could&lt;/strong&gt; make that repository accessible remotely and ask people to pull from it, but in practice that is not the way things are usually done. A recommended way is to have a public repository, make it reachable by other people, and when the changes you made in your primary working tree are in good shape, update the public repository from it. This is often called &lt;code&gt;pushing&lt;/code&gt;.</source>
          <target state="translated">您可以在工作树中进行实际工作，该工作树将主存储库作为其 &lt;code&gt;.git&lt;/code&gt; 子目录挂在其下。您&lt;strong&gt;可以&lt;/strong&gt;使该存储库可远程访问，并要求人们退出该存储库，但实际上，这并不是通常的工作方式。一种推荐的方法是拥有一个公共存储库，使其可以被其他人访问，并且当您在主工作树中所做的更改处于良好状态时，请从中更新公共存储库。这通常称为 &lt;code&gt;pushing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0911499c26fd93762ba87b20e89843bed2558fd8" translate="yes" xml:space="preserve">
          <source>You have made some commits, but realize they were premature to be in the &lt;code&gt;master&lt;/code&gt; branch. You want to continue polishing them in a topic branch, so create &lt;code&gt;topic/wip&lt;/code&gt; branch off of the current &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">您已经进行了一些提交，但是意识到它们还不成熟，无法进入 &lt;code&gt;master&lt;/code&gt; 分支。您想继续在主题分支中对其进行 &lt;code&gt;topic/wip&lt;/code&gt; ，因此在当前 &lt;code&gt;HEAD&lt;/code&gt; 之外创建topic / wip分支。</target>
        </trans-unit>
        <trans-unit id="9321ccbae87a4bc4f97065bb17cb67a1a81520be" translate="yes" xml:space="preserve">
          <source>You have now created your first Git repository. Of course, since it&amp;rsquo;s empty, that&amp;rsquo;s not very useful, so let&amp;rsquo;s start populating it with data.</source>
          <target state="translated">现在，您已经创建了第一个Git存储库。当然，由于它是空的，所以不是很有用，所以让我们开始用数据填充它。</target>
        </trans-unit>
        <trans-unit id="d177c25ea329a8110bbd819e0cb66c6b6619b0d7" translate="yes" xml:space="preserve">
          <source>You have now successfully copied somebody else&amp;rsquo;s (mine) remote repository, and checked it out.</source>
          <target state="translated">现在，您已经成功复制了别人的（我的）远程存储库，并将其签出。</target>
        </trans-unit>
        <trans-unit id="3cc6b09871d23a7d903d56d9d6eb61d9c29d1dd4" translate="yes" xml:space="preserve">
          <source>You have performed no merges into mywork, so it is just a simple linear sequence of patches on top of &lt;code&gt;origin&lt;/code&gt;:</source>
          <target state="translated">您没有执行任何合并到mywork中的操作，因此它只是 &lt;code&gt;origin&lt;/code&gt; 上一个简单的线性补丁序列：</target>
        </trans-unit>
        <trans-unit id="2f8744f866557cd48a608818edcb46f21bfb3d75" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;git submodule update&lt;/code&gt; after &lt;code&gt;git pull&lt;/code&gt; if you want to update submodules, too.</source>
          <target state="translated">如果您也想更新子模块，则必须在 &lt;code&gt;git pull&lt;/code&gt; 之后运行 &lt;code&gt;git submodule update&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f82b6e7678c4aeade044d41684916154b148e08d" translate="yes" xml:space="preserve">
          <source>You haven&amp;rsquo;t specified any nodes as heads so it won&amp;rsquo;t be possible to differentiate between un-parented commits and root nodes.</source>
          <target state="translated">您尚未将任何节点指定为头节点，因此无法区分非父提交和根节点。</target>
        </trans-unit>
        <trans-unit id="60617aeef2563268db523c5fdc5a619452e83d26" translate="yes" xml:space="preserve">
          <source>You may also add new content that does not exist in the patch; simply add new lines, each starting with &quot;+&quot;. The addition will appear reverted in the working tree.</source>
          <target state="translated">您也可以添加补丁中不存在的新内容;只需添加新行,每行以 &quot;+&quot;开头。添加的内容会在工作树中出现还原。</target>
        </trans-unit>
        <trans-unit id="ef502914f7e8ab4571571ef4343614d654bb655c" translate="yes" xml:space="preserve">
          <source>You may also have third-party helpers installed; search for &lt;code&gt;credential-*&lt;/code&gt; in the output of &lt;code&gt;git help -a&lt;/code&gt;, and consult the documentation of individual helpers. Once you have selected a helper, you can tell Git to use it by putting its name into the credential.helper variable.</source>
          <target state="translated">您可能还安装了第三方帮助程序；在 &lt;code&gt;git help -a&lt;/code&gt; 的输出中搜索 &lt;code&gt;credential-*&lt;/code&gt; ，并查阅各个帮助器的文档。选择了一个帮助程序后，可以通过将其名称放入credential.helper变量来告诉Git使用它。</target>
        </trans-unit>
        <trans-unit id="f2298abd2d14c4384844acf0edbfaf0baea1ecae" translate="yes" xml:space="preserve">
          <source>You may also include a &lt;code&gt;!&lt;/code&gt; in front of the ref name to negate the entry, explicitly exposing it, even if an earlier entry marked it as hidden. If you have multiple hideRefs values, later entries override earlier ones (and entries in more-specific config files override less-specific ones).</source>
          <target state="translated">您可能还包括一个 &lt;code&gt;!&lt;/code&gt; 引用名称前面的值可否定该条目，显式公开它，即使较早的条目将其标记为隐藏。如果您有多个hideRefs值，则以后的条目将覆盖较早的条目（而更特定的配置文件中的条目将覆盖较不特定的配置文件）。</target>
        </trans-unit>
        <trans-unit id="ea31f49a09c0b721c12c5805f99a1757f98a096f" translate="yes" xml:space="preserve">
          <source>You may also use &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt;, which lets you merge the unmerged files using external tools such as Emacs or kdiff3.</source>
          <target state="translated">您还可以使用&lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool [1]&lt;/a&gt;，它允许您使用外部工具（例如Emacs或kdiff3）合并未合并的文件。</target>
        </trans-unit>
        <trans-unit id="9adc4f69fd1939534db6a41ec486285df53ebd63" translate="yes" xml:space="preserve">
          <source>You may execute several commands by either using one instance of &lt;code&gt;--exec&lt;/code&gt; with several commands:</source>
          <target state="translated">您可以通过将 &lt;code&gt;--exec&lt;/code&gt; 的一个实例与多个命令一起使用来执行多个命令：</target>
        </trans-unit>
        <trans-unit id="a70c5e0fed390964e6d887a35161883ab1754024" translate="yes" xml:space="preserve">
          <source>You may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with fresh commits so it can be remerged successfully without needing to &quot;revert the reversion&quot; (see the &lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;revert-a-faulty-merge How-To&lt;/a&gt; for details).</source>
          <target state="translated">还原主题分支合并后，您可能会发现这很有用，因为此选项使用新提交重新创建了主题分支，因此可以成功地合并主题分支，而无需&amp;ldquo;还原还原&amp;rdquo;（请参阅&lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;revert-a-faulty-merge操作&lt;/a&gt;方法细节）。</target>
        </trans-unit>
        <trans-unit id="08631c52a6efa8d7c45c6edcb816f877829615bc" translate="yes" xml:space="preserve">
          <source>You may force &lt;code&gt;git push&lt;/code&gt; to perform the update anyway by preceding the branch name with a plus sign:</source>
          <target state="translated">您可以通过在分支名称前加一个加号来强制 &lt;code&gt;git push&lt;/code&gt; 执行更新：</target>
        </trans-unit>
        <trans-unit id="ae2bd0ef4c886d9dfce1ee8146a7755d847ffcc2" translate="yes" xml:space="preserve">
          <source>You may often find that during a bisect session you want to have temporary modifications (e.g. s/#define DEBUG 0/#define DEBUG 1/ in a header file, or &quot;revision that does not have this commit needs this patch applied to work around another problem this bisection is not interested in&quot;) applied to the revision being tested.</source>
          <target state="translated">你可能经常会发现,在一个二分法会话中,你希望对被测试的版本进行临时修改 (例如,s/#define DEBUG 0/#define DEBUG 1/在头文件中,或者 &quot;没有这个提交的版本需要应用这个补丁来解决另一个二分法不感兴趣的问题&quot;)。</target>
        </trans-unit>
        <trans-unit id="014dba50ebab24a63a38baad57ed8364492c1d37" translate="yes" xml:space="preserve">
          <source>You may override individual configuration parameters when running any git command by using the &lt;code&gt;-c&lt;/code&gt; option. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">您可以使用 &lt;code&gt;-c&lt;/code&gt; 选项在运行任何git命令时覆盖各个配置参数。有关详细信息，请参见&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac5fdcda86efd0f875c444e1e9c4b64fbcccd8a8" translate="yes" xml:space="preserve">
          <source>You may specify configuration in your .git/config</source>
          <target state="translated">您可以在您的.git/config中指定配置。</target>
        </trans-unit>
        <trans-unit id="13fb0fac683620e44c1d9b40bc74efe99d0db2f0" translate="yes" xml:space="preserve">
          <source>You may still choose to publish branches whose history is rewritten, and it may be useful for others to be able to fetch those branches in order to examine or test them, but they should not attempt to pull such branches into their own work.</source>
          <target state="translated">你仍然可以选择发布那些历史被改写的分支,这对其他人来说可能是有用的,可以取这些分支来检查或测试它们,但他们不应该试图将这些分支拉到自己的工作中。</target>
        </trans-unit>
        <trans-unit id="eb01db138b0fd8c4f790bf23de91d970f6b3f25c" translate="yes" xml:space="preserve">
          <source>You may want to use &lt;code&gt;sslVerify=false&lt;/code&gt; while troubleshooting, if you suspect that the reason you are having trouble connecting is because the certificate you use at the private server &lt;code&gt;example.com&lt;/code&gt; you are trying to set up (or have set up) may not be verified correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594c958b8686511065ebf30dd08d761eb22eafab" translate="yes" xml:space="preserve">
          <source>You might need to instead use: &lt;code&gt;folder = &quot;[Google Mail]/Drafts&quot;&lt;/code&gt; if you get an error that the &quot;Folder doesn&amp;rsquo;t exist&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb3e9e45a2fe07905a833e4999cf989715a0ad3" translate="yes" xml:space="preserve">
          <source>You might need to instead use: folder = &quot;[Google Mail]/Drafts&quot; if you get an error that the &quot;Folder doesn&amp;rsquo;t exist&quot;.</source>
          <target state="translated">如果您收到&amp;ldquo;文件夹不存在&amp;rdquo;的错误消息，则可能需要改用：folder =&amp;ldquo; [Google Mail] / Drafts&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ce52beb4e545845637d5d5a0a1bc64e60b253c82" translate="yes" xml:space="preserve">
          <source>You might want to build on one of these remote-tracking branches on a branch of your own, just as you would for a tag:</source>
          <target state="translated">你可能想在这些远程跟踪分支中的一个分支上建立一个自己的分支,就像你对一个标签一样。</target>
        </trans-unit>
        <trans-unit id="d0620c25fa90dc1aefb86ac91dfbd9e4eb8b29d0" translate="yes" xml:space="preserve">
          <source>You might want to recreate merge commits, e.g. if you have a history like this:</source>
          <target state="translated">你可能需要重新创建合并提交,例如,如果你有这样的历史记录。</target>
        </trans-unit>
        <trans-unit id="76dbf6258421c615799bec755123a1d09c6ae993" translate="yes" xml:space="preserve">
          <source>You need to push the new tag to a public Git server (see &quot;DISTRIBUTED WORKFLOWS&quot; below). This makes the tag available to others tracking your project. The push could also trigger a post-update hook to perform release-related items such as building release tarballs and preformatted documentation pages.</source>
          <target state="translated">您需要将新的标签推送到一个公共的 Git 服务器上(参见下面的 &quot;分布式工作流&quot;)。这样,其他跟踪您项目的人就可以使用这个标签。推送还可以触发一个更新后的钩子,以执行与发布相关的项目,比如构建发布的 tarballs 和预格式化的文档页面。</target>
        </trans-unit>
        <trans-unit id="23c2bb7cb1fc9b6f4a240d36b5b4f0b94079730d" translate="yes" xml:space="preserve">
          <source>You need to set the configuration variable &lt;code&gt;rerere.enabled&lt;/code&gt; in order to enable this command.</source>
          <target state="translated">您需要设置配置变量 &lt;code&gt;rerere.enabled&lt;/code&gt; 才能启用此命令。</target>
        </trans-unit>
        <trans-unit id="beb1062efd31de3a255af22760556d9dc5fafa01" translate="yes" xml:space="preserve">
          <source>You normally only do signed tags for major releases or things like that, while the light-weight tags are useful for any marking you want to do &amp;mdash; any time you decide that you want to remember a certain point, just create a private tag for it, and you have a nice symbolic name for the state at that point.</source>
          <target state="translated">通常，您只对主要版本或类似内容进行签名标签，而轻量级标签则对您要进行的任何标记都是有用的-每当您决定要记住某个要点时，只需为其创建一个私有标签即可，此时您拥有一个很好的州名称符号。</target>
        </trans-unit>
        <trans-unit id="0eafb62c845e9f30a39264ada6b686e1d1ebb7b8" translate="yes" xml:space="preserve">
          <source>You often interact with the same remote repository by regularly and repeatedly fetching from it. In order to keep track of the progress of such a remote repository, &lt;code&gt;git fetch&lt;/code&gt; allows you to configure &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; configuration variables.</source>
          <target state="translated">您经常通过定期重复地从同一个远程存储库中进行交互来与之交互。为了跟踪此类远程存储库的进度， &lt;code&gt;git fetch&lt;/code&gt; 允许您配置 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 配置变量。</target>
        </trans-unit>
        <trans-unit id="0b67cab4bffb98d3ad72ff6748f9f8b98887d9f3" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to invoke this command directly; it is meant to be used as a credential helper by other parts of Git. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; or &lt;code&gt;EXAMPLES&lt;/code&gt; below.</source>
          <target state="translated">您可能不想直接调用此命令。它打算被Git的其他部分用作凭证帮助器。参见&lt;a href=&quot;gitcredentials&quot;&gt;下面的gitcredentials [7]&lt;/a&gt;或 &lt;code&gt;EXAMPLES&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="467e6fc50e0615f651de6ffbcc6e0f17ecbae432" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to invoke this command directly; it is meant to be used as a credential helper by other parts of git. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; or &lt;code&gt;EXAMPLES&lt;/code&gt; below.</source>
          <target state="translated">您可能不想直接调用此命令。它打算被git的其他部分用作凭证帮助器。参见&lt;a href=&quot;gitcredentials&quot;&gt;下面的gitcredentials [7]&lt;/a&gt;或 &lt;code&gt;EXAMPLES&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c924d93ebd8e89f99e14509235b47dec1acfaa5d" translate="yes" xml:space="preserve">
          <source>You read a &quot;tree&quot; file from the object database, and use that to populate (and overwrite&amp;mdash;​don&amp;rsquo;t do this if your index contains any unsaved state that you might want to restore later!) your current index. Normal operation is just</source>
          <target state="translated">您从对象数据库中读取了一个``树''文件，并使用该文件来填充（并覆盖-如果索引包含任何未保存的状态，可能需要稍后还原！请不要这样做！）正常运行只是</target>
        </trans-unit>
        <trans-unit id="e01bf60bb2a8e848b7516e87eb6405fb0e476f7b" translate="yes" xml:space="preserve">
          <source>You really filtered all refs: use &lt;code&gt;--tag-name-filter cat -- --all&lt;/code&gt; when calling git-filter-branch.</source>
          <target state="translated">您真的过滤了所有引用：调用git-filter-branch时，使用 &lt;code&gt;--tag-name-filter cat -- --all&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cb205f517a67a8e523ed9cfa8681dc8f8d7b0ce" translate="yes" xml:space="preserve">
          <source>You really removed all variants of a filename, if a blob was moved over its lifetime. &lt;code&gt;git log --name-only --follow --all -- filename&lt;/code&gt; can help you find renames.</source>
          <target state="translated">如果在文件生命周期内移动了Blob，则实际上删除了文件名的所有变体。 &lt;code&gt;git log --name-only --follow --all -- filename&lt;/code&gt; 可以帮助您查找重命名。</target>
        </trans-unit>
        <trans-unit id="a347f016fee70b8901448b2a81ecd1980ba100a9" translate="yes" xml:space="preserve">
          <source>You see, Git is actually the best tool to find out about the source of Git itself!</source>
          <target state="translated">你看,Git其实是了解Git本身源头的最好工具!</target>
        </trans-unit>
        <trans-unit id="2f7c7430f5ab3ddee895946cce58e0edcbc9b3f3" translate="yes" xml:space="preserve">
          <source>You should &lt;strong&gt;never&lt;/strong&gt; do any work of your own on the branches that are created by &lt;code&gt;git cvsimport&lt;/code&gt;. By default initial import will create and populate a &quot;master&quot; branch from the CVS repository&amp;rsquo;s main branch which you&amp;rsquo;re free to work with; after that, you need to &lt;code&gt;git merge&lt;/code&gt; incremental imports, or any CVS branches, yourself. It is advisable to specify a named remote via -r to separate and protect the incoming branches.</source>
          <target state="translated">你应该&lt;strong&gt;永远不会&lt;/strong&gt;做由创建的分支自己的任何工作 &lt;code&gt;git cvsimport&lt;/code&gt; 。默认情况下，初始导入会从CVS存储库的主分支创建并填充一个&amp;ldquo;主&amp;rdquo;分支，您可以自由使用它；之后，您需要自己自己 &lt;code&gt;git merge&lt;/code&gt; 增量导入或任何CVS分支。建议通过-r指定一个命名的远程对象，以分隔并保护传入的分支。</target>
        </trans-unit>
        <trans-unit id="ac5b50c688e69b32b2a523ca6520323d9259e65e" translate="yes" xml:space="preserve">
          <source>You should consider using &lt;code&gt;dcommit&lt;/code&gt; instead of this command. Commit specified commit or tree objects to SVN. This relies on your imported fetch data being up to date. This makes absolutely no attempts to do patching when committing to SVN, it simply overwrites files with those specified in the tree or commit. All merging is assumed to have taken place independently of &lt;code&gt;git svn&lt;/code&gt; functions.</source>
          <target state="translated">您应该考虑使用 &lt;code&gt;dcommit&lt;/code&gt; 代替此命令。将指定的提交或树对象提交到SVN。这取决于您导入的最新数据。提交到SVN时，绝对不会尝试打补丁，它只是使用树或提交中指定的文件覆盖文件。假定所有合并均独立于 &lt;code&gt;git svn&lt;/code&gt; 函数进行。</target>
        </trans-unit>
        <trans-unit id="f0db0149a7a61b2b34d3de583889773851c606fb" translate="yes" xml:space="preserve">
          <source>You should now compile the checked-out version and test it. If that version works correctly, type</source>
          <target state="translated">现在你应该编译检查出来的版本并进行测试。如果该版本工作正常,输入</target>
        </trans-unit>
        <trans-unit id="adc89a3f88e3fe44040e1f3bf11644a95272fcdb" translate="yes" xml:space="preserve">
          <source>You should put your personal name, generally a form using a given name and family name. For example, the current maintainer of Git uses &quot;Junio C Hamano&quot;. This will be the name portion that is stored in every commit you make.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce522d2b57e2c5b1484c387e3121e7cf3c762ef" translate="yes" xml:space="preserve">
          <source>You should refrain from abusing this option to sneak substantial changes into a merge commit. Small fixups like bumping release/version name would be acceptable.</source>
          <target state="translated">你应该避免滥用这个选项来偷偷地在合并提交中做实质性的修改。小规模的修改,比如增加版本号/版本名称,是可以接受的。</target>
        </trans-unit>
        <trans-unit id="de1993c72b3b1ad3dd18c76738408f9f041af6eb" translate="yes" xml:space="preserve">
          <source>You should understand the implications of rewriting history if you amend a commit that has already been published. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.)</source>
          <target state="translated">如果您修改已经发布的提交，则应该了解重写历史的含义。（请参阅&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]中&lt;/a&gt;的&amp;ldquo;从UPSTREAM REBASE恢复&amp;rdquo;部分。）</target>
        </trans-unit>
        <trans-unit id="a5048e0c5c1221139fe969fc6db15713d2b83eb5" translate="yes" xml:space="preserve">
          <source>You should understand the implications of using &lt;code&gt;git rebase&lt;/code&gt; on a repository that you share. See also RECOVERING FROM UPSTREAM REBASE below.</source>
          <target state="translated">您应该了解在共享的存储库上使用 &lt;code&gt;git rebase&lt;/code&gt; 的含义。另请参见下面的从UPSTREAM REBASE恢复。</target>
        </trans-unit>
        <trans-unit id="7550fee71eb33261ce4427a0e3743a34c95d7107" translate="yes" xml:space="preserve">
          <source>You should work through &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt; before reading this tutorial.</source>
          <target state="translated">在阅读本教程之前，您应该先阅读&lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33b464d633d5d3d359d8c081bd1ef24a08ba23d1" translate="yes" xml:space="preserve">
          <source>You then transfer the bundle to the other machine to replace /home/me/tmp/file.bundle, and pull from it.</source>
          <target state="translated">然后,你将 bundle 转移到另一台机器上,替换 /home/me/tmp/file.bundle,并从中拉出。</target>
        </trans-unit>
        <trans-unit id="98122f0a874f3f8b610fdbc33b228a3b5afee64a" translate="yes" xml:space="preserve">
          <source>You update your working directory from the index by &quot;checking out&quot; files. This is not a very common operation, since normally you&amp;rsquo;d just keep your files updated, and rather than write to your working directory, you&amp;rsquo;d tell the index files about the changes in your working directory (i.e. &lt;code&gt;git update-index&lt;/code&gt;).</source>
          <target state="translated">您可以通过&amp;ldquo;签出&amp;rdquo;文件来从索引更新工作目录。这不是很常见的操作，因为通常您只是保持文件更新，而不是写入工作目录，而是告诉索引文件工作目录中的更改（即 &lt;code&gt;git update-index&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="57134770b9c7f61c90927970f67f3d2eceaa4a12" translate="yes" xml:space="preserve">
          <source>You will continue to do your day-to-day work in your personal repository, but periodically &quot;push&quot; changes from your personal repository into your public repository, allowing other developers to pull from that repository. So the flow of changes, in a situation where there is one other developer with a public repository, looks like this:</source>
          <target state="translated">您将继续在您的个人版本库中进行日常工作,但定期将您个人版本库中的变更 &quot;推送 &quot;到您的公共版本库中,允许其他开发者从该版本库中提取。所以,在有一个其他开发者使用公共仓库的情况下,变化的流程是这样的。</target>
        </trans-unit>
        <trans-unit id="cee01be09864f7d5b244e4c87ca6f6106e652b44" translate="yes" xml:space="preserve">
          <source>You will need to run &lt;code&gt;git add --renormalize&lt;/code&gt; to have this take effect. Note that if you are making these changes on a project that is used across platforms, you&amp;rsquo;ll probably want to make it in a per-user configuration file or in the one in &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt;, since making it in a &lt;code&gt;.gitattributes&lt;/code&gt; file in the repository will apply to all users of the repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8876e4496883cded62698bb08d4c1d5f289e1dee" translate="yes" xml:space="preserve">
          <source>You will see both of these things throughout the code.</source>
          <target state="translated">你会在整个代码中看到这两点。</target>
        </trans-unit>
        <trans-unit id="4dda56fbfc3230573e73ab526d0f70db698497a1" translate="yes" xml:space="preserve">
          <source>You will see informational messages on dangling objects. They are objects that still exist in the repository but are no longer referenced by any of your branches, and can (and will) be removed after a while with &lt;code&gt;gc&lt;/code&gt;. You can run &lt;code&gt;git fsck --no-dangling&lt;/code&gt; to suppress these messages, and still view real errors.</source>
          <target state="translated">您将看到有关悬空对象的信息性消息。它们是仍然存在于存储库中的对象，但是不再由您的任何分支引用，并且可以（并且将）在一段时间后使用 &lt;code&gt;gc&lt;/code&gt; 删除。您可以运行 &lt;code&gt;git fsck --no-dangling&lt;/code&gt; 以禁止显示这些消息，并仍然查看实际错误。</target>
        </trans-unit>
        <trans-unit id="f2fc4e070409aa778dc2444037511e0ef4801d3d" translate="yes" xml:space="preserve">
          <source>You will see two files, &lt;code&gt;pack-*.pack&lt;/code&gt; and &lt;code&gt;pack-*.idx&lt;/code&gt;, in &lt;code&gt;.git/objects/pack&lt;/code&gt; directory. They are closely related to each other, and if you ever copy them by hand to a different repository for whatever reason, you should make sure you copy them together. The former holds all the data from the objects in the pack, and the latter holds the index for random access.</source>
          <target state="translated">您将在 &lt;code&gt;.git/objects/pack&lt;/code&gt; 目录中看到两个文件 &lt;code&gt;pack-*.pack&lt;/code&gt; 和 &lt;code&gt;pack-*.idx&lt;/code&gt; 。它们彼此之间密切相关，并且如果出于任何原因将它们手动复制到其他存储库，则应确保将它们一起复制。前者保存来自数据包中对象的所有数据，而后者保存随机访问的索引。</target>
        </trans-unit>
        <trans-unit id="266addba668945d927bfdfb63b85369114140000" translate="yes" xml:space="preserve">
          <source>You will still have to tell people by other means, such as mail. (Git provides the &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull[1]&lt;/a&gt; to send preformatted pull requests to upstream maintainers to simplify this task.)</source>
          <target state="translated">您仍然必须通过其他方式（例如邮件）告诉别人。（Git提供了&lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull [1]&lt;/a&gt;来向上游维护者发送预先格式化的请求，以简化此任务。）</target>
        </trans-unit>
        <trans-unit id="67a2c97a3fe15102ccbc39363d071f9caa744775" translate="yes" xml:space="preserve">
          <source>You would normally use &lt;code&gt;git merge-index&lt;/code&gt; with supplied &lt;code&gt;git merge-one-file&lt;/code&gt; to do this last step. The script updates the files in the working tree as it merges each path and at the end of a successful merge.</source>
          <target state="translated">您通常会使用 &lt;code&gt;git merge-index&lt;/code&gt; 和提供的 &lt;code&gt;git merge-one-file&lt;/code&gt; 来完成最后一步。该脚本会在合并每个路径时以及在成功合并结束时更新工作树中的文件。</target>
        </trans-unit>
        <trans-unit id="acf5d70c570af359d1fc1b3db4b2e1cb44907ec4" translate="yes" xml:space="preserve">
          <source>You wouldn&amp;rsquo;t need to ever change it in gitweb config file.</source>
          <target state="translated">您无需在gitweb配置文件中进行更改。</target>
        </trans-unit>
        <trans-unit id="065eff42d50778a1002dd0b7a890143f4063288e" translate="yes" xml:space="preserve">
          <source>You write your current index file to a &quot;tree&quot; object with the program</source>
          <target state="translated">你可以用程序将你当前的索引文件写成一个 &quot;树 &quot;对象</target>
        </trans-unit>
        <trans-unit id="49012e7b5c219e4c44033d7ce0ec88b78d68a780" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve now initialized the working directory&amp;mdash;​you may notice a new directory created, named &quot;.git&quot;.</source>
          <target state="translated">现在您已经初始化了工作目录-您可能会注意到创建了一个名为&amp;ldquo; .git&amp;rdquo;的新目录。</target>
        </trans-unit>
        <trans-unit id="8e4b96aa3f69a0a980be2d48bd9eb2298bc44f3c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve now made your first real Git commit. And if you&amp;rsquo;re interested in looking at what &lt;code&gt;git commit&lt;/code&gt; really does, feel free to investigate: it&amp;rsquo;s a few very simple shell scripts to generate the helpful (?) commit message headers, and a few one-liners that actually do the commit itself (&lt;code&gt;git commit&lt;/code&gt;).</source>
          <target state="translated">现在，您已经完成了第一次真正的Git提交。而且，如果您有兴趣查看 &lt;code&gt;git commit&lt;/code&gt; 的实际功能，请随时进行调查：这是一些非常简单的shell脚本，用于生成有用的（？）commit消息标头，还有一些实际执行提交本身的单行代码（ &lt;code&gt;git commit&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6fd65e242e5023949f1979a313cb8892375303bf" translate="yes" xml:space="preserve">
          <source>Your &quot;public repository&quot; is now ready to accept your changes. Come back to the machine you have your private repository. From there, run this command:</source>
          <target state="translated">你的 &quot;公共仓库 &quot;现在已经准备好接受你的修改了。回到你的私有仓库的机器上。在那里,运行这个命令。</target>
        </trans-unit>
        <trans-unit id="77f5c1536424041eff5dddce9b9dc699480c5921" translate="yes" xml:space="preserve">
          <source>Your private repository&amp;rsquo;s Git directory is usually &lt;code&gt;.git&lt;/code&gt;, but your public repository is often named after the project name, i.e. &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt;. Let&amp;rsquo;s create such a public repository for project &lt;code&gt;my-git&lt;/code&gt;. After logging into the remote machine, create an empty directory:</source>
          <target state="translated">私有存储库的Git目录通常为 &lt;code&gt;.git&lt;/code&gt; ，但公共存储库通常以项目名称（即 &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; )命名。让我们为项目 &lt;code&gt;my-git&lt;/code&gt; 创建一个公共存储库。登录到远程计算机后，创建一个空目录：</target>
        </trans-unit>
        <trans-unit id="b96e6decf426a8986abe42a514d0d538e2f36071" translate="yes" xml:space="preserve">
          <source>Your work tree is still based on your HEAD ($JC), but you have some edits since. Three-way merge makes sure that you have not added or modified index entries since $JC, and if you haven&amp;rsquo;t, then does the right thing. So with the following sequence:</source>
          <target state="translated">您的工作树仍基于HEAD（$ JC），但此后您进行了一些编辑。三向合并确保自$ JC起没有添加或修改索引条目，如果没有，则做正确的事情。因此，按以下顺序进行：</target>
        </trans-unit>
        <trans-unit id="8ff2148494456dea5c056275d6718302d7ecd982" translate="yes" xml:space="preserve">
          <source>Zero or more &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filedelete&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt;, &lt;code&gt;filedeleteall&lt;/code&gt; and &lt;code&gt;notemodify&lt;/code&gt; commands may be included to update the contents of the branch prior to creating the commit. These commands may be supplied in any order. However it is recommended that a &lt;code&gt;filedeleteall&lt;/code&gt; command precede all &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt; and &lt;code&gt;notemodify&lt;/code&gt; commands in the same commit, as &lt;code&gt;filedeleteall&lt;/code&gt; wipes the branch clean (see below).</source>
          <target state="translated">可以包含零个或多个 &lt;code&gt;filemodify&lt;/code&gt; ， &lt;code&gt;filedelete&lt;/code&gt; ， &lt;code&gt;filecopy&lt;/code&gt; ， &lt;code&gt;filerename&lt;/code&gt; ， &lt;code&gt;filedeleteall&lt;/code&gt; 和 &lt;code&gt;notemodify&lt;/code&gt; 命令，以在创建提交之前更新分支的内容。这些命令可以以任何顺序提供。但是，建议在同一提交中使用 &lt;code&gt;filedeleteall&lt;/code&gt; 命令在所有 &lt;code&gt;filemodify&lt;/code&gt; ， &lt;code&gt;filecopy&lt;/code&gt; ， &lt;code&gt;filerename&lt;/code&gt; 和 &lt;code&gt;notemodify&lt;/code&gt; 命令之前，因为 &lt;code&gt;filedeleteall&lt;/code&gt; 会清除分支（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="480b45cead8c71eaa647209c97491be4a36ea289" translate="yes" xml:space="preserve">
          <source>Zero or more protocol options may be entered after the last &lt;code&gt;push&lt;/code&gt; command, before the batch&amp;rsquo;s terminating blank line.</source>
          <target state="translated">在最后一个 &lt;code&gt;push&lt;/code&gt; 命令之后，批处理的终止空白行之前，可以输入零个或多个协议选项。</target>
        </trans-unit>
        <trans-unit id="fbdec3db39874b3b5b75476184662777ddc44fd6" translate="yes" xml:space="preserve">
          <source>[&amp;lt;git-rev-list-args&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;git-rev-list-args&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="b3a075bbccfeeb4bedba2aca4addb159d1acee3d" translate="yes" xml:space="preserve">
          <source>[&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;path&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="d31c8b5c3af548ff2d95f4e227ea28f0f9277441" translate="yes" xml:space="preserve">
          <source>[&amp;lt;refname&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;refname&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="e961d55ee5b355694495464c07c86f7fba23e9a9" translate="yes" xml:space="preserve">
          <source>[--] &amp;lt;path&amp;gt;&amp;hellip;​</source>
          <target state="translated">[-] &amp;lt;路径&amp;gt; ...</target>
        </trans-unit>
        <trans-unit id="1eb3d578c1f910d18345d8eb23a781efa2f8d23d" translate="yes" xml:space="preserve">
          <source>[0] &lt;a href=&quot;https://bugs.chromium.org/p/git/issues/detail?id=6&quot;&gt;https://bugs.chromium.org/p/git/issues/detail?id=6&lt;/a&gt; Chromium work item for: Multi-Pack Index (MIDX)</source>
          <target state="translated">[0] &lt;a href=&quot;https://bugs.chromium.org/p/git/issues/detail?id=6&quot;&gt;https://bugs.chromium.org/p/git/issues/detail?id=6&lt;/a&gt;铬工作项，用于：多包装指数（MIDX）</target>
        </trans-unit>
        <trans-unit id="25a96ba2d3b7a7d8ee2c18075362c090194ac1d0" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&quot;&gt;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&lt;/a&gt; An earlier RFC for the multi-pack-index feature</source>
          <target state="translated">[1] &lt;a href=&quot;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&quot;&gt;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&lt;/a&gt;用于多包索引功能的早期RFC</target>
        </trans-unit>
        <trans-unit id="347fffb72e72a788a9461ff2e246ae61494e14d7" translate="yes" xml:space="preserve">
          <source>[2] &lt;a href=&quot;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&quot;&gt;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&lt;/a&gt; Git Merge 2018 Contributor&amp;rsquo;s summit notes (includes discussion of MIDX)</source>
          <target state="translated">[2] &lt;a href=&quot;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&quot;&gt;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&lt;/a&gt; Git Merge 2018贡献者峰会笔记（包括对MIDX的讨论）</target>
        </trans-unit>
        <trans-unit id="feea73f842c5a1ec74b307b98128568bae22544a" translate="yes" xml:space="preserve">
          <source>[DEPRECATED: use &lt;code&gt;--rebase-merges&lt;/code&gt; instead] Recreate merge commits instead of flattening the history by replaying commits a merge commit introduces. Merge conflict resolutions or manual amendments to merge commits are not preserved.</source>
          <target state="translated">[不建议使用： &lt;code&gt;--rebase-merges&lt;/code&gt; ]重新创建合并提交，而不是通过重播合并提交引入的提交来使历史变平。合并冲突解决方案或手动修订以合并提交不会保留。</target>
        </trans-unit>
        <trans-unit id="a59f280e0e654176579fad979c6b2390d4560b5d" translate="yes" xml:space="preserve">
          <source>[EXPERIMENTAL] Set to &lt;code&gt;true&lt;/code&gt; to use the experimental built-in implementation of the interactive version of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; instead of the Perl script version. Is &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">[EXPERIMENTAL]设置为 &lt;code&gt;true&lt;/code&gt; 可以使用&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;交互式版本的实验性内置实现而不是Perl脚本版本。默认为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8205d704abeeab8758bae84f0f9eac80a6c4899" translate="yes" xml:space="preserve">
          <source>[NOTE] &lt;code&gt;git rerere&lt;/code&gt; relies on the conflict markers in the file to detect the conflict. If the file already contains lines that look the same as lines with conflict markers, &lt;code&gt;git rerere&lt;/code&gt; may fail to record a conflict resolution. To work around this, the &lt;code&gt;conflict-marker-size&lt;/code&gt; setting in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; can be used.</source>
          <target state="translated">[注意] &lt;code&gt;git rerere&lt;/code&gt; 依靠文件中的冲突标记来检测冲突。如果文件中已经包含与带有冲突标记的行看起来相同的行，则 &lt;code&gt;git rerere&lt;/code&gt; 可能无法记录冲突解决方案。要解决此问题，可以使用&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]中&lt;/a&gt;的 &lt;code&gt;conflict-marker-size&lt;/code&gt; 设置。</target>
        </trans-unit>
        <trans-unit id="ac4bc8630c3c03bfd813e3fe5057d1c466974ce5" translate="yes" xml:space="preserve">
          <source>[[[1]]] &lt;a href=&quot;https://www.nist.gov/sites/default/files/documents/director/planning/report02-3.pdf&quot;&gt;&lt;em&gt;The Economic Impacts of Inadequate Infratructure for Software Testing&lt;/em&gt;. Nist Planning Report 02-3&lt;/a&gt;, see Executive Summary and Chapter 8.</source>
          <target state="translated">[[[1]]]基础设施&lt;a href=&quot;https://www.nist.gov/sites/default/files/documents/director/planning/report02-3.pdf&quot;&gt;&lt;em&gt;不足对软件测试的经济影响&lt;/em&gt;。Nist规划报告02-3&lt;/a&gt;，请参阅执行摘要和第8章。</target>
        </trans-unit>
        <trans-unit id="e5f919a0494a6ccb56ff39496ebf8651f04232d2" translate="yes" xml:space="preserve">
          <source>[[[2]]] &lt;a href=&quot;http://www.oracle.com/technetwork/java/codeconvtoc-136057.html&quot;&gt;&lt;em&gt;Code Conventions for the Java Programming Language&lt;/em&gt;. Sun Microsystems.&lt;/a&gt;</source>
          <target state="translated">[[[2]]] &lt;a href=&quot;http://www.oracle.com/technetwork/java/codeconvtoc-136057.html&quot;&gt;&lt;em&gt;Java编程语言的代码约定&lt;/em&gt;。Sun Microsystems。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de6da26d7d92c3d4bdee11d004d96506e88a1b00" translate="yes" xml:space="preserve">
          <source>[[[3]]] &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;&lt;em&gt;Software maintenance&lt;/em&gt;. Wikipedia.&lt;/a&gt;</source>
          <target state="translated">[[[3]]] &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;&lt;em&gt;软件维护&lt;/em&gt;。维基百科。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a21dac2771422b1ce396ac7103119df3289ef40d" translate="yes" xml:space="preserve">
          <source>[[[4]]] &lt;a href=&quot;https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/&quot;&gt;Junio C Hamano. &lt;em&gt;Automated bisect success story&lt;/em&gt;.&lt;/a&gt;</source>
          <target state="translated">[[[4]]] &lt;a href=&quot;https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/&quot;&gt;Junio C Hamano。&lt;em&gt;自动对分成功案例&lt;/em&gt;。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06e39006ce98590e4632510795aafbc71a8d5177" translate="yes" xml:space="preserve">
          <source>[[[5]]] &lt;a href=&quot;https://lwn.net/Articles/317154/&quot;&gt;Christian Couder. &lt;em&gt;Fully automated bisecting with &quot;git bisect run&quot;&lt;/em&gt;. LWN.net.&lt;/a&gt;</source>
          <target state="translated">[[[5]] &lt;a href=&quot;https://lwn.net/Articles/317154/&quot;&gt;克里斯蒂安&amp;middot;库德（Christian Couder）。&lt;em&gt;带有&amp;ldquo; git bisect run&amp;rdquo;的完全二等分法&lt;/em&gt;。LWN.net。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a12b60ab9e79fee2e4613d666532029fdb7e1f4d" translate="yes" xml:space="preserve">
          <source>[[[6]]] &lt;a href=&quot;https://lwn.net/Articles/277872/&quot;&gt;Jonathan Corbet. &lt;em&gt;Bisection divides users and developers&lt;/em&gt;. LWN.net.&lt;/a&gt;</source>
          <target state="translated">[[[6]] &lt;a href=&quot;https://lwn.net/Articles/277872/&quot;&gt;乔纳森&amp;middot;科贝特（Jonathan Corbet）。&lt;em&gt;二等分用户和开发人员&lt;/em&gt;。LWN.net。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb3a1d698c871451809a03759d2052ad730db3fa" translate="yes" xml:space="preserve">
          <source>[[[7]]] &lt;a href=&quot;https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/&quot;&gt;Ingo Molnar. &lt;em&gt;Re: BUG 2.6.23-rc3 can&amp;rsquo;t see sd partitions on Alpha&lt;/em&gt;. Linux-kernel mailing list.&lt;/a&gt;</source>
          <target state="translated">[[[7]]] &lt;a href=&quot;https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/&quot;&gt;Ingo Molnar。&lt;em&gt;回复：BUG 2.6.23-rc3在Alpha上看不到sd分区&lt;/em&gt;。Linux内核邮件列表。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91adb50bf54c20a1b51a7a5bd4f97f72154e309d" translate="yes" xml:space="preserve">
          <source>[[[8]]] &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html&quot;&gt;Junio C Hamano and the git-list. &lt;em&gt;git-bisect(1) Manual Page&lt;/em&gt;. Linux Kernel Archives.&lt;/a&gt;</source>
          <target state="translated">[[[8]]] &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html&quot;&gt;Junio C Hamano和git-list。&lt;em&gt;git-bisect（1）手册页&lt;/em&gt;。Linux内核档案。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62e3bcbb19b635de003c473322577e0da443bd26" translate="yes" xml:space="preserve">
          <source>[[[9]]] &lt;a href=&quot;https://github.com/Ealdwulf/bbchop&quot;&gt;Ealdwulf. &lt;em&gt;bbchop&lt;/em&gt;. GitHub.&lt;/a&gt;</source>
          <target state="translated">[[[9]] &lt;a href=&quot;https://github.com/Ealdwulf/bbchop&quot;&gt;Ealdwulf。&lt;em&gt;bbchop&lt;/em&gt;。GitHub。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4720dfbb1b4c30f403e79c3ea73865f0f4c5faef" translate="yes" xml:space="preserve">
          <source>[user@]host.xz:/~[user]/path/to/repo.git/</source>
          <target state="translated">[user@]host.xz:/~[user]/path/to/repo.git/</target>
        </trans-unit>
        <trans-unit id="5995beae7c11faa4cc7064555dea6942a8fa3779" translate="yes" xml:space="preserve">
          <source>[user@]host.xz:path/to/repo.git/</source>
          <target state="translated">[user@]host.xz:path/to/repo.git/</target>
        </trans-unit>
        <trans-unit id="8bc9eff643c5f26b1d25ab8fdf5a5ddc87d11ead" translate="yes" xml:space="preserve">
          <source>\0 line termination on output and do not quote filenames. See OUTPUT FORMAT below for more information.</source>
          <target state="translated">\ 0在输出端终止，不引用文件名。有关更多信息，请参见下面的输出格式。</target>
        </trans-unit>
        <trans-unit id="d0b23d6e6728ae49ec5909ad48b79671e7245999" translate="yes" xml:space="preserve">
          <source>\0 line termination on output and do not quote filenames. See OUTPUT below for more information.</source>
          <target state="translated">\ 0在输出端终止，不引用文件名。有关更多信息，请参见下面的输出。</target>
        </trans-unit>
        <trans-unit id="ec441d8e621550cb4deb96e2b1ad67311ed0768f" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; directory that is a &lt;code&gt;bare&lt;/code&gt; repository (i.e. without its own working tree), that is typically used for exchanging histories with others by pushing into it and fetching from it.</source>
          <target state="translated">一个 &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; 目录，它是一个 &lt;code&gt;bare&lt;/code&gt; 仓库（即没有其自己的工作树），通常用于通过推入并从中获取历史记录来与他人交换历史记录。</target>
        </trans-unit>
        <trans-unit id="ea844fb65222d001b2e2f561d577c3d6a932db4a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;.git&lt;/code&gt; directory at the root of the working tree;</source>
          <target state="translated">一个 &lt;code&gt;.git&lt;/code&gt; 在工作树的根目录下;</target>
        </trans-unit>
        <trans-unit id="f0d4bf33608fee8383e25a39f62fec37be3db742" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;lot&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;lot&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc234069c4e3ee03ef8f7670cb491ed5411b65b6" translate="yes" xml:space="preserve">
          <source>a NUL (only exists if renamed/copied);</source>
          <target state="translated">a NUL(仅在重命名/复制时存在)。</target>
        </trans-unit>
        <trans-unit id="079f5a842faae1ecf0933e998354e66093295bb8" translate="yes" xml:space="preserve">
          <source>a NUL.</source>
          <target state="translated">a 无。</target>
        </trans-unit>
        <trans-unit id="e9278592288a5c5c028d9d1d04c2201af670c4f7" translate="yes" xml:space="preserve">
          <source>a URL like &quot;git://example.org/path/to/repo.git&quot; will be rewritten to &quot;ssh://example.org/path/to/repo.git&quot; for pushes, but pulls will still use the original URL.</source>
          <target state="translated">像 &quot;git://example.org/path/to/repo.git &quot;这样的URL会被重写成 &quot;ssh://example.org/path/to/repo.git &quot;来进行推送,但拉取仍然会使用原来的URL。</target>
        </trans-unit>
        <trans-unit id="96a7d2b2a7356a40bc207f3d1e0038c9f743ef8f" translate="yes" xml:space="preserve">
          <source>a URL like &quot;work:repo.git&quot; or like &quot;host.xz:/path/to/repo.git&quot; will be rewritten in any context that takes a URL to be &quot;git://git.host.xz/repo.git&quot;.</source>
          <target state="translated">像 &quot;work:repo.git &quot;或 &quot;host.xz:/path/to/repo.git &quot;这样的URL在任何情况下都会被重写为 &quot;git://git.host.xz/repo.git&quot;。</target>
        </trans-unit>
        <trans-unit id="da90a472a42edab28f6103dd507b377a59e39919" translate="yes" xml:space="preserve">
          <source>a colon.</source>
          <target state="translated">a 冒号。</target>
        </trans-unit>
        <trans-unit id="07112c294a121f7cc6ed6654ce50e53f206b098f" translate="yes" xml:space="preserve">
          <source>a comment describing this commit.</source>
          <target state="translated">描述本次提交的评论。</target>
        </trans-unit>
        <trans-unit id="6fd45c543fb44740f3ae2218676d1d2f809372d6" translate="yes" xml:space="preserve">
          <source>a committer: The name of the person who actually created the commit, with the date it was done. This may be different from the author, for example, if the author was someone who wrote a patch and emailed it to the person who used it to create the commit.</source>
          <target state="translated">一个提交人。实际创建提交的人的名字,并标明创建日期。这可能与作者不同,例如,如果作者是写了一个补丁,然后通过电子邮件发给了用它来创建提交的人。</target>
        </trans-unit>
        <trans-unit id="475363380919fa9dad3daaa5151af4a7ecf7fe63" translate="yes" xml:space="preserve">
          <source>a file called &lt;code&gt;HEAD&lt;/code&gt;, that has &lt;code&gt;ref: refs/heads/master&lt;/code&gt; in it. This is similar to a symbolic link and points at &lt;code&gt;refs/heads/master&lt;/code&gt; relative to the &lt;code&gt;HEAD&lt;/code&gt; file.</source>
          <target state="translated">名为 &lt;code&gt;HEAD&lt;/code&gt; 的文件，其中具有 &lt;code&gt;ref: refs/heads/master&lt;/code&gt; 。这类似于符号链接，指向相对于 &lt;code&gt;HEAD&lt;/code&gt; 文件的 &lt;code&gt;refs/heads/master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="956892125b0edbb5f2b693d0431acccf4dd5c1cd" translate="yes" xml:space="preserve">
          <source>a file in the &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; directory.</source>
          <target state="translated">在文件 &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="7a8f92bb4f6fe9e686ed78d483dc8804c1d0837c" translate="yes" xml:space="preserve">
          <source>a file in the &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; directory, or</source>
          <target state="translated">在文件 &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 目录，或</target>
        </trans-unit>
        <trans-unit id="6fb331171394d95fbb7a35c4b995f2a83f23618c" translate="yes" xml:space="preserve">
          <source>a file that has &lt;code&gt;any&lt;/code&gt; difference what-so-ever in the three trees will stay as separate entries in the index. It&amp;rsquo;s up to &quot;porcelain policy&quot; to determine how to remove the non-0 stages, and insert a merged version.</source>
          <target state="translated">三棵树中没有 &lt;code&gt;any&lt;/code&gt; 差异的文件将作为单独的条目保留在索引中。由&amp;ldquo;瓷器政策&amp;rdquo;决定如何删除非0阶段并插入合并版本。</target>
        </trans-unit>
        <trans-unit id="fcb1d336b0be584d8054e8f7d63b3480aea0ee1d" translate="yes" xml:space="preserve">
          <source>a function called &lt;code&gt;cmd_&amp;lt;bla&amp;gt;&lt;/code&gt;, typically defined in &lt;code&gt;builtin/&amp;lt;bla.c&amp;gt;&lt;/code&gt; (note that older versions of Git used to have it in &lt;code&gt;builtin-&amp;lt;bla&amp;gt;.c&lt;/code&gt; instead), and declared in &lt;code&gt;builtin.h&lt;/code&gt;.</source>
          <target state="translated">一个称为 &lt;code&gt;cmd_&amp;lt;bla&amp;gt;&lt;/code&gt; 的函数，通常在 &lt;code&gt;builtin/&amp;lt;bla.c&amp;gt;&lt;/code&gt; 定义（请注意，较早版本的Git以前将其放在 &lt;code&gt;builtin-&amp;lt;bla&amp;gt;.c&lt;/code&gt; ），并在 &lt;code&gt;builtin.h&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="d20b77e1575c57d2803f17741070661ffe1f7923" translate="yes" xml:space="preserve">
          <source>a line that begins with &quot;Index: &quot;</source>
          <target state="translated">以 &quot;索引 &quot;开头的一行。&quot;</target>
        </trans-unit>
        <trans-unit id="eac485dbe3dc8258452b85ab1fdc03917425590f" translate="yes" xml:space="preserve">
          <source>a line that begins with &quot;diff -&quot;, or</source>
          <target state="translated">以 &quot;diff-&quot;开头的一行,或</target>
        </trans-unit>
        <trans-unit id="8cb077e79c6b205418cec26b6f4930fe1ae56b3b" translate="yes" xml:space="preserve">
          <source>a newline.</source>
          <target state="translated">一个新行。</target>
        </trans-unit>
        <trans-unit id="678e3fa85625ddb634df3223f890cd55081ea7cd" translate="yes" xml:space="preserve">
          <source>a raw &lt;code&gt;%&lt;/code&gt;</source>
          <target state="translated">原始 &lt;code&gt;%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6a839de3aabe2c207992e1add851477714b9c5e" translate="yes" xml:space="preserve">
          <source>a remote in the Git configuration file: &lt;code&gt;$GIT_DIR/config&lt;/code&gt;,</source>
          <target state="translated">Git配置文件中的远程： &lt;code&gt;$GIT_DIR/config&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="f9af7071efb1bd7dd22ebf85f05d8810442b8586" translate="yes" xml:space="preserve">
          <source>a space between time and time zone</source>
          <target state="translated">时区间</target>
        </trans-unit>
        <trans-unit id="65b604e2f985f7317d6866f6730d409a3832783e" translate="yes" xml:space="preserve">
          <source>a space instead of the &lt;code&gt;T&lt;/code&gt; date/time delimiter</source>
          <target state="translated">一个空格而不是 &lt;code&gt;T&lt;/code&gt; 日期/时间定界符</target>
        </trans-unit>
        <trans-unit id="5bc00ebd3440c4f401b07128f1c136e115562dd8" translate="yes" xml:space="preserve">
          <source>a space.</source>
          <target state="translated">a 空间。</target>
        </trans-unit>
        <trans-unit id="97a7ee5f8a960df69981e9527fa176cfdf9705cf" translate="yes" xml:space="preserve">
          <source>a subdirectory called &lt;code&gt;objects&lt;/code&gt;, which will contain all the objects of your project. You should never have any real reason to look at the objects directly, but you might want to know that these objects are what contains all the real &lt;code&gt;data&lt;/code&gt; in your repository.</source>
          <target state="translated">一个名为 &lt;code&gt;objects&lt;/code&gt; 的子目录，它将包含项目的所有对象。您永远不应有任何真正的理由直接查看对象，但您可能想知道这些对象就是存储库中所有真实 &lt;code&gt;data&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="045a27e5aab449465c7a517674ebf98a06438921" translate="yes" xml:space="preserve">
          <source>a subdirectory called &lt;code&gt;refs&lt;/code&gt;, which contains references to objects.</source>
          <target state="translated">称为 &lt;code&gt;refs&lt;/code&gt; 的子目录，其中包含对对象的引用。</target>
        </trans-unit>
        <trans-unit id="03097f133fc01ec710880af30fddc9a8cd7c34db" translate="yes" xml:space="preserve">
          <source>a tab or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used.</source>
          <target state="translated">使用 &lt;code&gt;-z&lt;/code&gt; 选项时使用制表符或NUL 。</target>
        </trans-unit>
        <trans-unit id="9346da07fb77dd97b82dc62a47eb3edc36d2b7a0" translate="yes" xml:space="preserve">
          <source>a tab or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used; only exists for C or R.</source>
          <target state="translated">使用 &lt;code&gt;-z&lt;/code&gt; 选项时使用制表符或NUL ；仅对于C或R存在。</target>
        </trans-unit>
        <trans-unit id="c40734bc76bdc997f13a3bade66db88cc0dc137e" translate="yes" xml:space="preserve">
          <source>a tab;</source>
          <target state="translated">一个标签。</target>
        </trans-unit>
        <trans-unit id="19150edbe2f84d3c01f8f24ddf7de6b06a212def" translate="yes" xml:space="preserve">
          <source>a tree: The SHA-1 name of a tree object (as defined below), representing the contents of a directory at a certain point in time.</source>
          <target state="translated">一棵树。树对象的SHA-1名称(定义见下文),表示某一时间点目录的内容。</target>
        </trans-unit>
        <trans-unit id="013edfaa8480f23dc64a9a565714902a0f70e19a" translate="yes" xml:space="preserve">
          <source>a valid head &lt;code&gt;name&lt;/code&gt; (i.e. a &lt;code&gt;refs/heads/&amp;lt;head&amp;gt;&lt;/code&gt; reference).</source>
          <target state="translated">有效的 &lt;code&gt;refs/heads/&amp;lt;head&amp;gt;&lt;/code&gt; &lt;code&gt;name&lt;/code&gt; （即refs / heads / &amp;lt;head&amp;gt;参考）。</target>
        </trans-unit>
        <trans-unit id="c3796b26d9f35f82d5c7ba0548ce633809586698" translate="yes" xml:space="preserve">
          <source>a valid tag &lt;code&gt;name&lt;/code&gt; (i.e. a &lt;code&gt;refs/tags/&amp;lt;tag&amp;gt;&lt;/code&gt; reference).</source>
          <target state="translated">有效的标签 &lt;code&gt;name&lt;/code&gt; （即 &lt;code&gt;refs/tags/&amp;lt;tag&amp;gt;&lt;/code&gt; 参考）。</target>
        </trans-unit>
        <trans-unit id="fdbf716e8cd4fd3ff778984618bbe33ffeee814c" translate="yes" xml:space="preserve">
          <source>a) are ancestor of the &quot;bad&quot; commit (including the &quot;bad&quot; commit itself), b) are not ancestor of a &quot;good&quot; commit (excluding the &quot;good&quot; commits).</source>
          <target state="translated">a)是 &quot;坏 &quot;提交的祖先(包括 &quot;坏 &quot;提交本身),b)不是 &quot;好 &quot;提交的祖先(不包括 &quot;好 &quot;提交)。</target>
        </trans-unit>
        <trans-unit id="8682c02d1bc4bfce128a794497013605d86c32b6" translate="yes" xml:space="preserve">
          <source>a) regular use</source>
          <target state="translated">a)定期使用</target>
        </trans-unit>
        <trans-unit id="4ff2759bc14568ced83be0be38a4abafea668a32" translate="yes" xml:space="preserve">
          <source>abbreviated commit hash</source>
          <target state="translated">缩略提交哈希值</target>
        </trans-unit>
        <trans-unit id="83baab4c4f5445b3450e34e24f8066fea1ac11f2" translate="yes" xml:space="preserve">
          <source>abbreviated parent hashes</source>
          <target state="translated">缩略的父哈希</target>
        </trans-unit>
        <trans-unit id="33579b1cb5338205dc784843012a5c0a9e8cacae" translate="yes" xml:space="preserve">
          <source>abbreviated tree hash</source>
          <target state="translated">缩略树形哈希</target>
        </trans-unit>
        <trans-unit id="b61646f016483b318b49a910668a966b6ce09ede" translate="yes" xml:space="preserve">
          <source>abort</source>
          <target state="translated">abort</target>
        </trans-unit>
        <trans-unit id="832e60dfe198126ed45442b9d54f0a366515eefc" translate="yes" xml:space="preserve">
          <source>absorbgitdirs</source>
          <target state="translated">absorbgitdirs</target>
        </trans-unit>
        <trans-unit id="f412f21dd1d844e9ed4c1cbd73b06dc725c5d8bd" translate="yes" xml:space="preserve">
          <source>access method (one of &quot;ext&quot; or &quot;pserver&quot;)</source>
          <target state="translated">访问方式</target>
        </trans-unit>
        <trans-unit id="34eb4c4ef005207e8b8f916b9f1fffacccd6945e" translate="yes" xml:space="preserve">
          <source>action</source>
          <target state="translated">action</target>
        </trans-unit>
        <trans-unit id="326b426f9ac7a96ed6baf62f8838565416d27df8" translate="yes" xml:space="preserve">
          <source>actions</source>
          <target state="translated">actions</target>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="6d8bcdb6bdc1c6a236c5092142b208eb67008cee" translate="yes" xml:space="preserve">
          <source>add &amp;lt;path&amp;gt; [&amp;lt;commit-ish&amp;gt;]</source>
          <target state="translated">添加&amp;lt;path&amp;gt; [&amp;lt;commit-ish&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="89052c7d90a34c914815c621a3c8abaf890dfcb5" translate="yes" xml:space="preserve">
          <source>add [-b &amp;lt;branch&amp;gt;] [-f|--force] [--name &amp;lt;name&amp;gt;] [--reference &amp;lt;repository&amp;gt;] [--depth &amp;lt;depth&amp;gt;] [--] &amp;lt;repository&amp;gt; [&amp;lt;path&amp;gt;]</source>
          <target state="translated">添加[-b &amp;lt;分支&amp;gt;] [-f | --force] [--name &amp;lt;名称&amp;gt;] [-引用&amp;lt;存储库&amp;gt;] [--depth &amp;lt;depth&amp;gt;] [-] &amp;lt;存储库&amp;gt; [&amp;lt;路径&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="96b545065b00a5b7501087e2c1e93926449febd5" translate="yes" xml:space="preserve">
          <source>add a missing &lt;code&gt;\n&lt;/code&gt; to the last line if necessary.</source>
          <target state="translated">如有必要，请在最后一行添加缺少的 &lt;code&gt;\n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90bc127779a3e8fd8565532d33e4a134cd45f11d" translate="yes" xml:space="preserve">
          <source>add everything under the current directory.</source>
          <target state="translated">添加当前目录下的所有内容。</target>
        </trans-unit>
        <trans-unit id="cb81f0f2d76a3c8759a19442b315f5c3a72e8b01" translate="yes" xml:space="preserve">
          <source>add untracked</source>
          <target state="translated">追加</target>
        </trans-unit>
        <trans-unit id="c22e3f3bd42e15a0bc002a5cba9cb2e9cb547df3" translate="yes" xml:space="preserve">
          <source>add.ignore-errors (deprecated)</source>
          <target state="translated">add.ignore-errors(已废弃)</target>
        </trans-unit>
        <trans-unit id="0d6211d85b6c5ebebd00bc700587b97d87d96f79" translate="yes" xml:space="preserve">
          <source>add.ignoreErrors</source>
          <target state="translated">add.ignoreErrors</target>
        </trans-unit>
        <trans-unit id="47d07ea3a984d5f17b8a52280b424c7e874d91e2" translate="yes" xml:space="preserve">
          <source>add.interactive.useBuiltin</source>
          <target state="translated">add.interactive.useBuiltin</target>
        </trans-unit>
        <trans-unit id="e441bfa1c3e8c860d35d02080c0d58234a3dc31b" translate="yes" xml:space="preserve">
          <source>addEmbeddedRepo</source>
          <target state="translated">addEmbeddedRepo</target>
        </trans-unit>
        <trans-unit id="5fba0af68b4dc6017c79ff69ba4b3844f76b2dc5" translate="yes" xml:space="preserve">
          <source>addEmptyPathspec</source>
          <target state="translated">addEmptyPathspec</target>
        </trans-unit>
        <trans-unit id="a9b80c1de3c9ac007c7c119f277608c2e2a51269" translate="yes" xml:space="preserve">
          <source>addIgnoredFile</source>
          <target state="translated">addIgnoredFile</target>
        </trans-unit>
        <trans-unit id="ceb99972d01848a4af9e45ab5cd53f0d9ea700b4" translate="yes" xml:space="preserve">
          <source>added content</source>
          <target state="translated">附加内容</target>
        </trans-unit>
        <trans-unit id="782f82176de20dd76d4373d2acfc3406073964ff" translate="yes" xml:space="preserve">
          <source>adding context (&quot; &quot;) or removal (&quot;-&quot;) lines</source>
          <target state="translated">添加上下文(&quot; &quot;)或删除(&quot;-&quot;)行。</target>
        </trans-unit>
        <trans-unit id="39de4cfc4c6e6827c5f11475b89460e1b545a7f9" translate="yes" xml:space="preserve">
          <source>adds the following to &lt;code&gt;.git/config&lt;/code&gt;:</source>
          <target state="translated">将以下内容添加到 &lt;code&gt;.git/config&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f6acb502d3f3dcf967568ec1f1f05756c7001015" translate="yes" xml:space="preserve">
          <source>advice.*</source>
          <target state="translated">advice.*</target>
        </trans-unit>
        <trans-unit id="0608c4054662dd902e1314f7e450e3eaa81c1143" translate="yes" xml:space="preserve">
          <source>agent</source>
          <target state="translated">agent</target>
        </trans-unit>
        <trans-unit id="dc642557f3a1ed15b666c3bf8c010e9d1bceffe0" translate="yes" xml:space="preserve">
          <source>alias.*</source>
          <target state="translated">alias.*</target>
        </trans-unit>
        <trans-unit id="16f3bac085c702b24dd56dd8fdf474c5d21e6639" translate="yes" xml:space="preserve">
          <source>alice and cindy can push into master, only bob can push into doc-update. david is the release manager and is the only person who can create and push version tags.</source>
          <target state="translated">Alice和Cindy可以推送到master,只有Bob可以推送到doc-update。David是发布经理,也是唯一可以创建和推送版本标签的人。</target>
        </trans-unit>
        <trans-unit id="ae21c64a87f6bb0b8e16e55c48be4cc638d7bd3f" translate="yes" xml:space="preserve">
          <source>align</source>
          <target state="translated">align</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="29702e41afdcf565d852a6355913f10360a2f8b0" translate="yes" xml:space="preserve">
          <source>all parent object ids</source>
          <target state="translated">所有父对象ID</target>
        </trans-unit>
        <trans-unit id="6664a4a284b9aeecc837369fce6272fe3547f795" translate="yes" xml:space="preserve">
          <source>allow-indentation-change</source>
          <target state="translated">allow-indentation-change</target>
        </trans-unit>
        <trans-unit id="890c8ad25c4c255f4dda7bba71ccde4b6eb54f1a" translate="yes" xml:space="preserve">
          <source>allows you to browse any commits from the last 2 weeks of commits that modified files under the &quot;drivers&quot; directory. (Note: you can adjust gitk&amp;rsquo;s fonts by holding down the control key while pressing &quot;-&quot; or &quot;+&quot;.)</source>
          <target state="translated">允许您浏览修改后的&amp;ldquo;驱动程序&amp;rdquo;目录下文件的最近两周提交中的所有提交。（注意：您可以在按住Control键的同时按下&amp;ldquo;-&amp;rdquo;或&amp;ldquo; +&amp;rdquo;来调整gitk的字体。）</target>
        </trans-unit>
        <trans-unit id="8733169fb7d8912aa579031eed0a4b26ef5718fe" translate="yes" xml:space="preserve">
          <source>alternate object database</source>
          <target state="translated">备用对象数据库</target>
        </trans-unit>
        <trans-unit id="385d97ddc2cf0f165b1e517e2de9a74c662d0d92" translate="yes" xml:space="preserve">
          <source>alternate: absolute path of alternate object databases; may appear multiple times, one line per path. Note that if the path contains non-printable characters, it may be surrounded by double-quotes and contain C-style backslashed escape sequences.</source>
          <target state="translated">alternate:备用对象数据库的绝对路径;可以多次出现,每个路径一行。请注意,如果路径中包含不可打印的字符,它可能被双引号包围,并包含C型反斜线转义序列。</target>
        </trans-unit>
        <trans-unit id="459a9aeba984b09598ccfb2133b8ae65d179153d" translate="yes" xml:space="preserve">
          <source>although the full, 40-character SHA-1s would be supplied. If the foreign ref does not yet exist the &lt;code&gt;&amp;lt;remote SHA-1&amp;gt;&lt;/code&gt; will be 40 &lt;code&gt;0&lt;/code&gt;. If a ref is to be deleted, the &lt;code&gt;&amp;lt;local ref&amp;gt;&lt;/code&gt; will be supplied as &lt;code&gt;(delete)&lt;/code&gt; and the &lt;code&gt;&amp;lt;local
SHA-1&amp;gt;&lt;/code&gt; will be 40 &lt;code&gt;0&lt;/code&gt;. If the local commit was specified by something other than a name which could be expanded (such as &lt;code&gt;HEAD~&lt;/code&gt;, or a SHA-1) it will be supplied as it was originally given.</source>
          <target state="translated">尽管将提供完整的40个字符的SHA-1。如果外部引用尚不存在，则 &lt;code&gt;&amp;lt;remote SHA-1&amp;gt;&lt;/code&gt; 将为40 &lt;code&gt;0&lt;/code&gt; 。如果要删除参考， &lt;code&gt;&amp;lt;local ref&amp;gt;&lt;/code&gt; 将作为 &lt;code&gt;(delete)&lt;/code&gt; ，而 &lt;code&gt;&amp;lt;local SHA-1&amp;gt;&lt;/code&gt; 将为40 &lt;code&gt;0&lt;/code&gt; 。如果本地提交是由可以扩展的名称（例如 &lt;code&gt;HEAD~&lt;/code&gt; 或SHA-1）以外的其他名称指定的，则将按照最初提供的名称提供。</target>
        </trans-unit>
        <trans-unit id="b16bb5afab4c1802eaeada40ac59f4ec78c01be8" translate="yes" xml:space="preserve">
          <source>always show in columns</source>
          <target state="translated">始终显示在列</target>
        </trans-unit>
        <trans-unit id="b0c4ba6a734338f8b0a5e21fcbb05d3afcd198af" translate="yes" xml:space="preserve">
          <source>always shows the difference between the HEAD and the index file&amp;mdash;​this is what you&amp;rsquo;d commit if you created the commit now&amp;mdash;​and that</source>
          <target state="translated">总是显示HEAD和索引文件之间的差异-这是您现在创建提交时要提交的内容-并且</target>
        </trans-unit>
        <trans-unit id="96e8155732e8324ae26f64d4516eb6fe696ac84f" translate="yes" xml:space="preserve">
          <source>am</source>
          <target state="translated">am</target>
        </trans-unit>
        <trans-unit id="400226a3b8758d7d662c424a478d16cceecd29ed" translate="yes" xml:space="preserve">
          <source>am.keepcr</source>
          <target state="translated">am.keepcr</target>
        </trans-unit>
        <trans-unit id="80b11664f9cdc0c4da5b2cf9cbae91e78f24cb5f" translate="yes" xml:space="preserve">
          <source>am.threeWay</source>
          <target state="translated">am.threeWay</target>
        </trans-unit>
        <trans-unit id="d9de89ed653daadc282d17fa341547ccd80f5e0c" translate="yes" xml:space="preserve">
          <source>amWorkDir</source>
          <target state="translated">amWorkDir</target>
        </trans-unit>
        <trans-unit id="b1cc99b811681fb579eeabe4a14a5e1ec1bab455" translate="yes" xml:space="preserve">
          <source>amend the previous commit, adding all your new changes, using your original message.</source>
          <target state="translated">修改之前的提交,添加所有新的变化,使用您的原始信息。</target>
        </trans-unit>
        <trans-unit id="461152b367e8ab9740fb2e9ee2da4d7175e9e2a2" translate="yes" xml:space="preserve">
          <source>an LF or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used, to terminate the record.</source>
          <target state="translated">使用 &lt;code&gt;-z&lt;/code&gt; 选项时，LF或NUL 终止记录。</target>
        </trans-unit>
        <trans-unit id="75eada615f3da2b986734d58bb672366de760679" translate="yes" xml:space="preserve">
          <source>an author: The name of the person responsible for this change, together with its date.</source>
          <target state="translated">一个作者。负责这一变更的人的姓名及其日期;</target>
        </trans-unit>
        <trans-unit id="b441fe44ea3ab3bff759abb792c8a7f4c7974b0c" translate="yes" xml:space="preserve">
          <source>an entry in &lt;code&gt;BUILTIN_OBJECTS&lt;/code&gt; in the &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Makefile&lt;/code&gt; 中 &lt;code&gt;BUILTIN_OBJECTS&lt;/code&gt; 中的一个条目。</target>
        </trans-unit>
        <trans-unit id="9d25597e1ded62863dd59e418a49b42af285a609" translate="yes" xml:space="preserve">
          <source>an entry in the &lt;code&gt;commands[]&lt;/code&gt; array in &lt;code&gt;git.c&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;git.c&lt;/code&gt; 中的 &lt;code&gt;commands[]&lt;/code&gt; 数组中的一个条目，以及</target>
        </trans-unit>
        <trans-unit id="5037f82b8aa7002eda9aed7d8c0898525bc2f00d" translate="yes" xml:space="preserve">
          <source>and Git will continue applying the rest of the patches.</source>
          <target state="translated">而Git将继续应用其余的补丁。</target>
        </trans-unit>
        <trans-unit id="b3b2e45f7b37ac14dc28b61e29aee3c419229fda" translate="yes" xml:space="preserve">
          <source>and Git will create the commit for you and continue applying the remaining patches from the mailbox.</source>
          <target state="translated">然后 Git 会为你创建提交,并继续应用邮箱中的剩余补丁。</target>
        </trans-unit>
        <trans-unit id="7067f391e9f25da3da4a562c780b468101adb659" translate="yes" xml:space="preserve">
          <source>and Git will prompt you for a commit message and then create the new commit. Check to make sure it looks like what you expected with</source>
          <target state="translated">然后 Git 会提示你提交信息,然后创建新的提交。检查一下是否和你预期的一样,用</target>
        </trans-unit>
        <trans-unit id="11bda7867b55ea900931dbe2ab8c87a36a0443d9" translate="yes" xml:space="preserve">
          <source>and bundle topic branches still cooking.</source>
          <target state="translated">并捆绑主题分支仍在烹饪。</target>
        </trans-unit>
        <trans-unit id="06675e26cc6f5bedf7b0e9b9d71e33fb64fa4ef8" translate="yes" xml:space="preserve">
          <source>and email them.</source>
          <target state="translated">并给他们发邮件。</target>
        </trans-unit>
        <trans-unit id="d5d63b233efdc161b2104f0e091d210beeb2fe60" translate="yes" xml:space="preserve">
          <source>and hack away. The equivalent of &lt;code&gt;cvs update&lt;/code&gt; is</source>
          <target state="translated">然后砍掉 相当于 &lt;code&gt;cvs update&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="d4b59596148297f0688711ac4f92721dbc18215b" translate="yes" xml:space="preserve">
          <source>and if it detects that the file &quot;file0&quot; is completely rewritten, it changes it to:</source>
          <target state="translated">而如果它检测到文件 &quot;file0 &quot;被完全重写,它就将其改为。</target>
        </trans-unit>
        <trans-unit id="e1426704be98b9dd3d938c5a6a31b3fe4ee9a995" translate="yes" xml:space="preserve">
          <source>and in fact a lot of the common Git command combinations can be scripted with the &lt;code&gt;git xyz&lt;/code&gt; interfaces. You can learn things by just looking at what the various git scripts do. For example, &lt;code&gt;git reset&lt;/code&gt; used to be the above two lines implemented in &lt;code&gt;git reset&lt;/code&gt;, but some things like &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; are slightly more complex scripts around the basic Git commands.</source>
          <target state="translated">实际上，许多常见的Git命令组合都可以使用 &lt;code&gt;git xyz&lt;/code&gt; 接口编写脚本。您可以通过查看各种git脚本来学习事物。例如， &lt;code&gt;git reset&lt;/code&gt; 曾经是在 &lt;code&gt;git reset&lt;/code&gt; 中实现的上述两行，但是诸如 &lt;code&gt;git status&lt;/code&gt; 和 &lt;code&gt;git commit&lt;/code&gt; 之类的东西是基本Git命令周围稍微复杂的脚本。</target>
        </trans-unit>
        <trans-unit id="c2f880dab39040d1bcbb6d73323cfccc9f1141f6" translate="yes" xml:space="preserve">
          <source>and it is assumed unchanged.</source>
          <target state="translated">并假定其不变。</target>
        </trans-unit>
        <trans-unit id="6fdb49363e42ba495e98dac786aceef7ea588734" translate="yes" xml:space="preserve">
          <source>and it will be gone. There&amp;rsquo;s no external repository, and there&amp;rsquo;s no history outside the project you created.</source>
          <target state="translated">它将消失。没有外部存储库，在您创建的项目之外也没有历史记录。</target>
        </trans-unit>
        <trans-unit id="14be792a7fbd836c220980afe820c5835c201a25" translate="yes" xml:space="preserve">
          <source>and it would create the new branch &lt;code&gt;mybranch&lt;/code&gt; at the earlier commit, and check out the state at that time.</source>
          <target state="translated">它将在较早的提交时创建新的分支 &lt;code&gt;mybranch&lt;/code&gt; ，然后检查当时的状态。</target>
        </trans-unit>
        <trans-unit id="fb7e74a8bf932246eae1a7c59b5aab5d50647a84" translate="yes" xml:space="preserve">
          <source>and its path_info based equivalent</source>
          <target state="translated">及其基于path_info的等价物</target>
        </trans-unit>
        <trans-unit id="a6415488fda4ace1ca3739dceaaf3db60a5dafcb" translate="yes" xml:space="preserve">
          <source>and just looked for the sha of the missing object (4b9458b) in that whole thing. It&amp;rsquo;s up to you&amp;mdash;​Git does &lt;strong&gt;have&lt;/strong&gt; a lot of information, it is just missing one particular blob version.</source>
          <target state="translated">并在整个过程中寻找丢失的物体的阴影（4b9458b）。这取决于您-Git确实&lt;strong&gt;有&lt;/strong&gt;很多信息，只是缺少一个特定的Blob版本。</target>
        </trans-unit>
        <trans-unit id="eb603cb6e80c68fe39b18e84f04c311f5ab01061" translate="yes" xml:space="preserve">
          <source>and make the shared repository writable by the group.</source>
          <target state="translated">并使共享存储库可以被组写入。</target>
        </trans-unit>
        <trans-unit id="40981e3225f4d7efce8a1f1ac883a144a32ed884" translate="yes" xml:space="preserve">
          <source>and once you&amp;rsquo;re happy with your manual merge, just do a</source>
          <target state="translated">一旦您对手动合并感到满意，只需执行</target>
        </trans-unit>
        <trans-unit id="f6523905096e4cb79385536bede182fe1d21d437" translate="yes" xml:space="preserve">
          <source>and optionally give a branch-name for the remote end as a second argument.</source>
          <target state="translated">并在第二个参数中给出远程端的分支名称。</target>
        </trans-unit>
        <trans-unit id="1f7c0eb7c2d3e76709e99a0799e2c00adb5d4360" translate="yes" xml:space="preserve">
          <source>and running &lt;code&gt;git config section.Subsection.key value2&lt;/code&gt; will result in</source>
          <target state="translated">并运行 &lt;code&gt;git config section.Subsection.key value2&lt;/code&gt; 将导致</target>
        </trans-unit>
        <trans-unit id="b8d13d365846b56f54fcde0e313df5ef17ad9601" translate="yes" xml:space="preserve">
          <source>and see two files:</source>
          <target state="translated">并看到两个文件。</target>
        </trans-unit>
        <trans-unit id="1846440a645e968f28127df0e1b2bcc1010c9293" translate="yes" xml:space="preserve">
          <source>and that is what higher level &lt;code&gt;git merge -s resolve&lt;/code&gt; is implemented with.</source>
          <target state="translated">这就是实现更高级别的 &lt;code&gt;git merge -s resolve&lt;/code&gt; 的目的。</target>
        </trans-unit>
        <trans-unit id="dbbcc5be724df383b84cd8c32e02ab45353e6975" translate="yes" xml:space="preserve">
          <source>and the &quot;parent&quot; object refers to the previous commit:</source>
          <target state="translated">和 &quot;父 &quot;对象指的是之前的提交。</target>
        </trans-unit>
        <trans-unit id="4982e2ffe4444f7d8ccaa2ccbbc307cc4fa3f8c7" translate="yes" xml:space="preserve">
          <source>and the contents of the deleted file fileX is similar enough to the contents of the created file file0, then rename detection merges these filepairs and creates:</source>
          <target state="translated">和被删除的文件fileX的内容与创建的文件file0的内容足够相似,那么重命名检测就会合并这些文件对,并创建。</target>
        </trans-unit>
        <trans-unit id="3cf2f14796ecd3906febf042b64b0f6c0a0234bc" translate="yes" xml:space="preserve">
          <source>and the contents of these files is just the compressed data plus a header identifying their length and their type. The type is either a blob, a tree, a commit, or a tag.</source>
          <target state="translated">而这些文件的内容只是压缩后的数据加上一个标明其长度和类型的头。类型可以是一个blob,一个树,一个提交,或者一个标签。</target>
        </trans-unit>
        <trans-unit id="97b7ea8f565fdb4b8f72207a4543ec3a6beb2426" translate="yes" xml:space="preserve">
          <source>and the new object name to be stored in the ref.</source>
          <target state="translated">和新的对象名称存储在ref.中。</target>
        </trans-unit>
        <trans-unit id="06596f8fbe14d561db35acf97529690afeae6531" translate="yes" xml:space="preserve">
          <source>and the result of &lt;code&gt;git merge-base A M&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;. Commit &lt;code&gt;2&lt;/code&gt; is also a common ancestor between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;M&lt;/code&gt;, but &lt;code&gt;1&lt;/code&gt; is a better common ancestor, because &lt;code&gt;2&lt;/code&gt; is an ancestor of &lt;code&gt;1&lt;/code&gt;. Hence, &lt;code&gt;2&lt;/code&gt; is not a merge base.</source>
          <target state="translated">并且 &lt;code&gt;git merge-base A M&lt;/code&gt; 的结果是 &lt;code&gt;1&lt;/code&gt; 。提交 &lt;code&gt;2&lt;/code&gt; 也是 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;M&lt;/code&gt; 之间的共同祖先，但是 &lt;code&gt;1&lt;/code&gt; 是更好的共同祖先，因为 &lt;code&gt;2&lt;/code&gt; 是 &lt;code&gt;1&lt;/code&gt; 的祖先。因此， &lt;code&gt;2&lt;/code&gt; 不是合并基础。</target>
        </trans-unit>
        <trans-unit id="bf29b3f3be3e9d8f538aa9b7974f9c3a714fd3f2" translate="yes" xml:space="preserve">
          <source>and then annotate the change between the commit and its parents, using &lt;code&gt;commit^!&lt;/code&gt; notation:</source>
          <target state="translated">然后使用 &lt;code&gt;commit^!&lt;/code&gt; 注释提交及其父项之间的更改。符号：</target>
        </trans-unit>
        <trans-unit id="3d8806f072cf60f02c7512a460d821442ce16fa0" translate="yes" xml:space="preserve">
          <source>and then giving the reason for the commit on stdin (either through redirection from a pipe or file, or by just typing it at the tty).</source>
          <target state="translated">然后在stdin上给出提交的原因(可以通过管道或文件的重定向,也可以直接在tty上输入)。</target>
        </trans-unit>
        <trans-unit id="2fd91a322e9e060ddc98865e40de279b845a572c" translate="yes" xml:space="preserve">
          <source>and then he just cut-and-pastes the output commands after verifying that they look OK.</source>
          <target state="translated">然后他只是在验证输出命令看起来没问题后,将其剪切并粘贴。</target>
        </trans-unit>
        <trans-unit id="b658ed87bd1868d8fc441785cf7c93c3c281001b" translate="yes" xml:space="preserve">
          <source>and then moving BFC after BBC and squashing it.</source>
          <target state="translated">然后把BFC搬到BBC之后,再把它压下去。</target>
        </trans-unit>
        <trans-unit id="339c37a1cbc67af9c8927014dc829b0049bb4b31" translate="yes" xml:space="preserve">
          <source>and then untar the new code in the working tree. Alternately you could &lt;code&gt;rsync&lt;/code&gt; the changes into the working tree.</source>
          <target state="translated">然后将新代码解压缩到工作树中。或者，您可以将更改 &lt;code&gt;rsync&lt;/code&gt; 到工作树中。</target>
        </trans-unit>
        <trans-unit id="617666725e1b9f6239b44390652378dd9926ce18" translate="yes" xml:space="preserve">
          <source>and these are evaluated in this order.</source>
          <target state="translated">而这些都是按照这个顺序进行评估的。</target>
        </trans-unit>
        <trans-unit id="9adeb030984d30c37dccabf36290b3a5065c7248" translate="yes" xml:space="preserve">
          <source>and they&amp;rsquo;ll be gone. (You should only run &lt;code&gt;git prune&lt;/code&gt; on a quiescent repository&amp;mdash;​it&amp;rsquo;s kind of like doing a filesystem fsck recovery: you don&amp;rsquo;t want to do that while the filesystem is mounted. &lt;code&gt;git prune&lt;/code&gt; is designed not to cause any harm in such cases of concurrent accesses to a repository but you might receive confusing or scary messages.)</source>
          <target state="translated">他们会消失的。（你应该只运行 &lt;code&gt;git prune&lt;/code&gt; 在静止repository-这有点像做了文件系统的fsck恢复：你不想这样做，而文件系统安装 &lt;code&gt;git prune&lt;/code&gt; 被设计为不造成任何伤害在这种情况下，并发访问存储库，但您可能会收到混乱或令人恐惧的消息。）</target>
        </trans-unit>
        <trans-unit id="cd197c11bb84be1a5bb09ba9b42e3b50427dcfec" translate="yes" xml:space="preserve">
          <source>and this will just output the name of the resulting tree, in this case (if you have done exactly as I&amp;rsquo;ve described) it should be</source>
          <target state="translated">并且这只会输出结果树的名称，在这种情况下（如果您完全按照我的描述进行过操作）应该是</target>
        </trans-unit>
        <trans-unit id="b1af0fa00d023b5f61dc1f79856e5725ea01dd35" translate="yes" xml:space="preserve">
          <source>and thus it is really quite easy to parse for some line- and word-oriented parser (which should be quite natural for most scripting languages).</source>
          <target state="translated">因此,对于一些面向行和字的解析器来说,它真的很容易解析(对于大多数脚本语言来说,这应该是很自然的)。</target>
        </trans-unit>
        <trans-unit id="66cee198375e167a1653a383c43e2bb725e3ca7a" translate="yes" xml:space="preserve">
          <source>and use the &quot;linus&quot; keyword with &lt;code&gt;git pull&lt;/code&gt; instead of the full URL.</source>
          <target state="translated">并在 &lt;code&gt;git pull&lt;/code&gt; 中使用&amp;ldquo; linus&amp;rdquo;关键字，而不是完整的URL。</target>
        </trans-unit>
        <trans-unit id="d296b286b6d11f02bc95ddc0eea6f99abc87487a" translate="yes" xml:space="preserve">
          <source>and you can now, since you told Git about the previous state of &lt;code&gt;hello&lt;/code&gt;, ask Git what has changed in the tree compared to your old index, using the &lt;code&gt;git diff-files&lt;/code&gt; command:</source>
          <target state="translated">现在您可以告诉Git以前的 &lt;code&gt;hello&lt;/code&gt; 状态了，可以使用 &lt;code&gt;git diff-files&lt;/code&gt; 命令询问Git与旧索引相比树中发生了什么变化：</target>
        </trans-unit>
        <trans-unit id="c22810b9d38d8e650ac736b5ccfb992ea7f0787f" translate="yes" xml:space="preserve">
          <source>and you have now told Git to track those two files.</source>
          <target state="translated">而您现在已经让 Git 追踪这两个文件。</target>
        </trans-unit>
        <trans-unit id="7078b738b08f05f21971cffe5f9577bcab9aaf44" translate="yes" xml:space="preserve">
          <source>and you will end up with an index with all of the &amp;lt;tree1&amp;gt; entries in &quot;stage1&quot;, all of the &amp;lt;tree2&amp;gt; entries in &quot;stage2&quot; and all of the &amp;lt;tree3&amp;gt; entries in &quot;stage3&quot;. When performing a merge of another branch into the current branch, we use the common ancestor tree as &amp;lt;tree1&amp;gt;, the current branch head as &amp;lt;tree2&amp;gt;, and the other branch head as &amp;lt;tree3&amp;gt;.</source>
          <target state="translated">然后您将获得一个索引，其中包含&amp;ldquo; stage1&amp;rdquo;中的所有&amp;lt;tree1&amp;gt;条目，&amp;ldquo; stage2&amp;rdquo;中的所有&amp;lt;tree2&amp;gt;条目以及&amp;ldquo; stage3&amp;rdquo;中的所有&amp;lt;tree3&amp;gt;条目。当将另一个分支合并到当前分支时，我们将公共祖先树用作&amp;lt;tree1&amp;gt;，将当前分支头用作&amp;lt;tree2&amp;gt;，并将另一个分支头用作&amp;lt;tree3&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="17b48e857b44d8864349e98c537796214a8362f4" translate="yes" xml:space="preserve">
          <source>and your index file will now be equivalent to the tree that you saved earlier. However, that is only your 'index' file: your working directory contents have not been modified.</source>
          <target state="translated">而你的索引文件现在将等同于你之前保存的树。然而,这只是你的 &quot;索引 &quot;文件:你的工作目录内容没有被修改。</target>
        </trans-unit>
        <trans-unit id="9f158fb3a1f2423d0104e077166f5b26c8204522" translate="yes" xml:space="preserve">
          <source>and your index file will now be equivalent to the tree that you saved earlier. However, that is only your &lt;code&gt;index&lt;/code&gt; file: your working directory contents have not been modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7df7a4e50a38db45b495588bed9a4abd67c32fe" translate="yes" xml:space="preserve">
          <source>and your repository is good again!</source>
          <target state="translated">你的仓库又好了!</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="86c8af583af4d12d1e63765efb1b3cf2c23eb581" translate="yes" xml:space="preserve">
          <source>any external helpers are named by their protocol (e.g., use &lt;code&gt;hg&lt;/code&gt; to allow the &lt;code&gt;git-remote-hg&lt;/code&gt; helper)</source>
          <target state="translated">任何外部帮助程序均由其协议命名（例如，使用 &lt;code&gt;hg&lt;/code&gt; 允许 &lt;code&gt;git-remote-hg&lt;/code&gt; 帮助程序）</target>
        </trans-unit>
        <trans-unit id="8fe566b6d0fcd9f8f079b9cbd5dff1c192d0bda1" translate="yes" xml:space="preserve">
          <source>any path matches itself</source>
          <target state="translated">任何符合自身的路径</target>
        </trans-unit>
        <trans-unit id="951f5c774520ac2d893d49506bb03ddb31fc70a0" translate="yes" xml:space="preserve">
          <source>api index</source>
          <target state="translated">api指数</target>
        </trans-unit>
        <trans-unit id="1ac3324252e6efe491b8f90f3588d4cd0cfc38d7" translate="yes" xml:space="preserve">
          <source>api trace2</source>
          <target state="translated">api trace2</target>
        </trans-unit>
        <trans-unit id="37f7547fef4fd60a7d07405e2e68e608cab796d3" translate="yes" xml:space="preserve">
          <source>api-trace2</source>
          <target state="translated">api-trace2</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="69f45da1683c501696ebfa086d25192af3807dc6" translate="yes" xml:space="preserve">
          <source>apply</source>
          <target state="translated">apply</target>
        </trans-unit>
        <trans-unit id="0c2fcb1d034ab205423e1d7ec6d29da9bf89a06b" translate="yes" xml:space="preserve">
          <source>apply [--index] [-q|--quiet] [&amp;lt;stash&amp;gt;]</source>
          <target state="translated">应用[--index] [-q | --quiet] [&amp;lt;stash&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="41e3e8c05614ede7d2046024aa32acb852d9e90a" translate="yes" xml:space="preserve">
          <source>apply backend: When applying a patch, ignore changes in whitespace in context lines. Unfortunately, this means that if the &quot;old&quot; lines being replaced by the patch differ only in whitespace from the existing file, you will get a merge conflict instead of a successful patch application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c563ce0a13a71f68c4323807b8df4dc3dd3653" translate="yes" xml:space="preserve">
          <source>apply the change that would be shown by &lt;code&gt;git show topic^&lt;/code&gt;. In this example, the patch does not apply cleanly, so information about the conflict is written to the index and working tree and no new commit results.</source>
          <target state="translated">应用将由 &lt;code&gt;git show topic^&lt;/code&gt; 的更改。在此示例中，补丁不能完全应用，因此有关冲突的信息将写入索引和工作树中，而不会产生新的提交结果。</target>
        </trans-unit>
        <trans-unit id="07666f4e66bd4bf8ab64d3029da991c3b016c0f9" translate="yes" xml:space="preserve">
          <source>apply them, interactively, with your sign-offs.</source>
          <target state="translated">在您的签收中交互式地应用它们。</target>
        </trans-unit>
        <trans-unit id="c778c31b66fdb0077c39c1643484bc80e939a6ef" translate="yes" xml:space="preserve">
          <source>apply.ignoreWhitespace</source>
          <target state="translated">apply.ignoreWhitespace</target>
        </trans-unit>
        <trans-unit id="3828727a8ed2b41298eb944c27d30c630bbaecf8" translate="yes" xml:space="preserve">
          <source>apply.whitespace</source>
          <target state="translated">apply.whitespace</target>
        </trans-unit>
        <trans-unit id="e90a34fe73108d3def10c8aa75dd41cf4b8df564" translate="yes" xml:space="preserve">
          <source>applypatch-msg</source>
          <target state="translated">applypatch-msg</target>
        </trans-unit>
        <trans-unit id="6edf8749a5d3dba0628223b6880e8abfb4f10d76" translate="yes" xml:space="preserve">
          <source>araxis</source>
          <target state="translated">araxis</target>
        </trans-unit>
        <trans-unit id="8c4f0e515d3499448f3629d033cf224f688edc27" translate="yes" xml:space="preserve">
          <source>arbitrary shell command that takes a single argument (the sha1 of the commit recorded in the superproject) is executed. When &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; is set to &lt;code&gt;!command&lt;/code&gt;, the remainder after the exclamation mark is the custom command.</source>
          <target state="translated">执行带有单个参数（在超级项目中记录的提交的sha1）的任意shell命令。当 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 设置为 &lt;code&gt;!command&lt;/code&gt; 时，感叹号后的其余部分为自定义命令。</target>
        </trans-unit>
        <trans-unit id="ebfb55f4432b592119a10592e4f26272cc72359e" translate="yes" xml:space="preserve">
          <source>archive</source>
          <target state="translated">archive</target>
        </trans-unit>
        <trans-unit id="02ffa0b70f36225abe68ab3c5392918d20ddbb24" translate="yes" xml:space="preserve">
          <source>are files GIT_EXTERNAL_DIFF can use to read the contents of &amp;lt;old|new&amp;gt;,</source>
          <target state="translated">是文件GIT_EXTERNAL_DIFF可以用来读取&amp;lt;old | new&amp;gt;的内容的文件，</target>
        </trans-unit>
        <trans-unit id="f04207e23f9202de330ee8bdec5f2a1b205be329" translate="yes" xml:space="preserve">
          <source>are incompatible with the following options:</source>
          <target state="translated">与下列选项不兼容:</target>
        </trans-unit>
        <trans-unit id="bf5659661ce871a6788ee6b1bec9770f7f549075" translate="yes" xml:space="preserve">
          <source>are roughly equivalent.</source>
          <target state="translated">大致相当。</target>
        </trans-unit>
        <trans-unit id="bfc0acfc5f4a94969ee2f529469c80db6f5db191" translate="yes" xml:space="preserve">
          <source>are the 40-hexdigit SHA-1 hashes,</source>
          <target state="translated">是40个六位数的SHA-1哈希值。</target>
        </trans-unit>
        <trans-unit id="377a5f0a9c724f4b4e656d090beb28e896803b78" translate="yes" xml:space="preserve">
          <source>are the octal representation of the file modes.</source>
          <target state="translated">是文件模式的八进制表示。</target>
        </trans-unit>
        <trans-unit id="536f158f6dfd529865dcb865a97bb16804e34d70" translate="yes" xml:space="preserve">
          <source>arguments</source>
          <target state="translated">arguments</target>
        </trans-unit>
        <trans-unit id="d73d25bb51bc0192ff2858618720527615dee66a" translate="yes" xml:space="preserve">
          <source>arrange &lt;code&gt;git push&lt;/code&gt; to push all local branches to their corresponding branch of the mothership machine.</source>
          <target state="translated">安排 &lt;code&gt;git push&lt;/code&gt; 将所有本地分支推送到母机的相应分支。</target>
        </trans-unit>
        <trans-unit id="7dc74bb7dc6b2238e853c884d0d310e31daffb87" translate="yes" xml:space="preserve">
          <source>as long as the shared repository does not have any branches other than &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">只要共享存储库没有 &lt;code&gt;master&lt;/code&gt; 以外的任何分支。</target>
        </trans-unit>
        <trans-unit id="cb2841c784dffc3f3e69b38c87cb3ad64f719624" translate="yes" xml:space="preserve">
          <source>as they are probably more user specific than repository specific. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for more information about this.</source>
          <target state="translated">因为它们可能更特定于用户而不是特定于存储库。有关更多信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec09624f8bf140a91e574552f4201e093095f93f" translate="yes" xml:space="preserve">
          <source>ask each</source>
          <target state="translated">相问</target>
        </trans-unit>
        <trans-unit id="a4da794aacaf85856a7722c9d864566d302089fc" translate="yes" xml:space="preserve">
          <source>at this point the two branches have diverged, with different changes made in each. To merge the changes made in experimental into master, run</source>
          <target state="translated">此时,两个分支已经发生了分歧,各自做了不同的修改。要将实验分支的修改合并到主分支中,请运行</target>
        </trans-unit>
        <trans-unit id="56cb56551e60df919190b545acc4efd3487df2da" translate="yes" xml:space="preserve">
          <source>at-open-brace &lt;code&gt;@{&lt;/code&gt; is used as a notation to access a reflog entry.</source>
          <target state="translated">at-open-brace &lt;code&gt;@{&lt;/code&gt; 用作访问引用日志条目的表示法。</target>
        </trans-unit>
        <trans-unit id="c6f57180e462a4f1e9de24fbe811cfb2c24a0cf9" translate="yes" xml:space="preserve">
          <source>atom</source>
          <target state="translated">atom</target>
        </trans-unit>
        <trans-unit id="fc88c6b3cc380853de27e44642207df9743ff63d" translate="yes" xml:space="preserve">
          <source>attr</source>
          <target state="translated">attr</target>
        </trans-unit>
        <trans-unit id="c0357eb71b4a8821fe200d8b8eb01baef86fac5a" translate="yes" xml:space="preserve">
          <source>author date (format respects --date= option)</source>
          <target state="translated">作者日期(格式尊重-date=选项)</target>
        </trans-unit>
        <trans-unit id="2a06a73ff8fc368a2739a3e178ba7f2389794fbb" translate="yes" xml:space="preserve">
          <source>author date, ISO 8601-like format</source>
          <target state="translated">作者日期</target>
        </trans-unit>
        <trans-unit id="242b07f5f5075eaa7fd5b51606a9b4162ff6c885" translate="yes" xml:space="preserve">
          <source>author date, RFC2822 style</source>
          <target state="translated">作者日期,RFC2822风格</target>
        </trans-unit>
        <trans-unit id="203f076a8dfae351b5cbfcddc2f39e2529b4ab40" translate="yes" xml:space="preserve">
          <source>author date, UNIX timestamp</source>
          <target state="translated">作者日期,UNIX时间戳</target>
        </trans-unit>
        <trans-unit id="5b659229f527fa360f4003ca474cb9646e5df53b" translate="yes" xml:space="preserve">
          <source>author date, relative</source>
          <target state="translated">撰稿日期,相对</target>
        </trans-unit>
        <trans-unit id="d04a676256ca4278418fc83a6c6099b60b59d9c4" translate="yes" xml:space="preserve">
          <source>author date, short format (&lt;code&gt;YYYY-MM-DD&lt;/code&gt;)</source>
          <target state="translated">作者日期，短格式（ &lt;code&gt;YYYY-MM-DD&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ca050c864ebffd969007968bf223faf21875eae7" translate="yes" xml:space="preserve">
          <source>author date, strict ISO 8601 format</source>
          <target state="translated">作者日期,严格的ISO 8601格式</target>
        </trans-unit>
        <trans-unit id="7ddbfb879a548122c7fc198acb1c1b2f4c9b9921" translate="yes" xml:space="preserve">
          <source>author email</source>
          <target state="translated">作者邮箱</target>
        </trans-unit>
        <trans-unit id="8edafcfb5bfb68f54b13aeb0dafbb6187a753701" translate="yes" xml:space="preserve">
          <source>author email (respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">作者电子邮件（使用.mailmap，请参阅&lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt;或&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="83daf4aca33631f2eb4acd6a25a656b0af3f5ee2" translate="yes" xml:space="preserve">
          <source>author email local-part (the part before the &lt;code&gt;@&lt;/code&gt; sign)</source>
          <target state="translated">作者电子邮件本地部分（ &lt;code&gt;@&lt;/code&gt; 符号之前的部分）</target>
        </trans-unit>
        <trans-unit id="5d4130a7bcbeec5d4a298b1e471f17266d9c3b2a" translate="yes" xml:space="preserve">
          <source>author local-part (see &lt;code&gt;%al&lt;/code&gt;) respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">尊重.mailmap的本地作者（请参阅 &lt;code&gt;%al&lt;/code&gt; ），请参阅&lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt;或&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="a38923d0b44faf2fd760ba1064fa8cccf3161910" translate="yes" xml:space="preserve">
          <source>author local-part (see &lt;code&gt;%cl&lt;/code&gt;) respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">作者本地部分（请参阅 &lt;code&gt;%cl&lt;/code&gt; ）尊重.mailmap，请参阅&lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt;或&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="c377e3db13b17a5dec490aa3f6ac58e35bd02ae8" translate="yes" xml:space="preserve">
          <source>author name</source>
          <target state="translated">作者名</target>
        </trans-unit>
        <trans-unit id="bd2cf54c8d8427c36e72436dee6f5edfa55f4e21" translate="yes" xml:space="preserve">
          <source>author name (respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">作者名称（使用.mailmap，请参阅&lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt;或&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="aa42d4b548d53eeb1e514e0662eb0b64c3782193" translate="yes" xml:space="preserve">
          <source>author name, email and date</source>
          <target state="translated">作者姓名、邮箱和日期</target>
        </trans-unit>
        <trans-unit id="d00ed3c485ca1a6ad6088b1642369eb27039d0b8" translate="yes" xml:space="preserve">
          <source>author.email</source>
          <target state="translated">author.email</target>
        </trans-unit>
        <trans-unit id="290b3c3f6920221191e3db343ad6fbf3a2f939e8" translate="yes" xml:space="preserve">
          <source>author.name</source>
          <target state="translated">author.name</target>
        </trans-unit>
        <trans-unit id="9c3bb49ffea1144231cbe02d904b8d9018744e9d" translate="yes" xml:space="preserve">
          <source>avatar</source>
          <target state="translated">avatar</target>
        </trans-unit>
        <trans-unit id="0bb01d8924d6b902321a6c09d5c0a45ab1342655" translate="yes" xml:space="preserve">
          <source>b) independent fixup</source>
          <target state="translated">(b)独立修复</target>
        </trans-unit>
        <trans-unit id="aeca33ec4bf9a7bd6b90cc303f5a8ac32af312c1" translate="yes" xml:space="preserve">
          <source>backport a critical fix.</source>
          <target state="translated">回传一个关键的修复。</target>
        </trans-unit>
        <trans-unit id="fe676f1ea27d4114d62d0b88a9999860d1c162c1" translate="yes" xml:space="preserve">
          <source>bare repository</source>
          <target state="translated">裸仓库</target>
        </trans-unit>
        <trans-unit id="e95c0d71e5a737bfc209f7013e45e233a7480a96" translate="yes" xml:space="preserve">
          <source>base-name</source>
          <target state="translated">base-name</target>
        </trans-unit>
        <trans-unit id="5b2505039ac5af9e197f5dad04113906a9cf9a2a" translate="yes" xml:space="preserve">
          <source>bc</source>
          <target state="translated">bc</target>
        </trans-unit>
        <trans-unit id="3c2369c6416caa1993808240594282dd4fcb95c1" translate="yes" xml:space="preserve">
          <source>bc3</source>
          <target state="translated">bc3</target>
        </trans-unit>
        <trans-unit id="b7c7d5d4b182d06d7f89fcb3d277474733c67444" translate="yes" xml:space="preserve">
          <source>be quiet if files exist or are not in the index</source>
          <target state="translated">沉默寡言</target>
        </trans-unit>
        <trans-unit id="bfa1cf02635b780783c9853aaca57e1c719e79ad" translate="yes" xml:space="preserve">
          <source>because the hostnames differ. Nor would it match &lt;code&gt;foo.example.com&lt;/code&gt;; Git compares hostnames exactly, without considering whether two hosts are part of the same domain. Likewise, a config entry for &lt;code&gt;http://example.com&lt;/code&gt; would not match: Git compares the protocols exactly.</source>
          <target state="translated">因为主机名不同。也不会匹配 &lt;code&gt;foo.example.com&lt;/code&gt; ; Git会精确比较主机名，而无需考虑两个主机是否属于同一域。同样， &lt;code&gt;http://example.com&lt;/code&gt; ：//example.com的配置条目也将不匹配：Git会精确比较协议。</target>
        </trans-unit>
        <trans-unit id="bd766456dd7d080025c5f2a3029a29c2bb5419ef" translate="yes" xml:space="preserve">
          <source>because the hostnames differ. Nor would it match &lt;code&gt;foo.example.com&lt;/code&gt;; Git compares hostnames exactly, without considering whether two hosts are part of the same domain. Likewise, a config entry for &lt;code&gt;http://example.com&lt;/code&gt; would not match: Git compares the protocols exactly. However, you may use wildcards in the domain name and other pattern matching techniques as with the &lt;code&gt;http.&amp;lt;url&amp;gt;.*&lt;/code&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c02ceb78ff4863ee1a75d232c4f53af56b182ec9" translate="yes" xml:space="preserve">
          <source>becomes:</source>
          <target state="translated">becomes:</target>
        </trans-unit>
        <trans-unit id="7e57cfe843145135aee1f4d0d63ceb7842093712" translate="yes" xml:space="preserve">
          <source>binary</source>
          <target state="translated">binary</target>
        </trans-unit>
        <trans-unit id="fc5afa849d013727d8acf30682a03a891f7aca7e" translate="yes" xml:space="preserve">
          <source>bisect</source>
          <target state="translated">bisect</target>
        </trans-unit>
        <trans-unit id="e04a67a1c220ec3759550df9a963521323148d66" translate="yes" xml:space="preserve">
          <source>blame</source>
          <target state="translated">blame</target>
        </trans-unit>
        <trans-unit id="72092ff956b5b07bf4d598501177651a9897b3f1" translate="yes" xml:space="preserve">
          <source>blame.blankBoundary</source>
          <target state="translated">blame.blankBoundary</target>
        </trans-unit>
        <trans-unit id="2862b4a0ea76b67385f8581e3bd4cf75e32e65d0" translate="yes" xml:space="preserve">
          <source>blame.coloring</source>
          <target state="translated">blame.coloring</target>
        </trans-unit>
        <trans-unit id="c55af0af464fc28e395cedf375c27ed38ea08dd7" translate="yes" xml:space="preserve">
          <source>blame.date</source>
          <target state="translated">blame.date</target>
        </trans-unit>
        <trans-unit id="574525f7353221a33787a1a7d1232b7faf51b9bb" translate="yes" xml:space="preserve">
          <source>blame.ignoreRevsFile</source>
          <target state="translated">blame.ignoreRevsFile</target>
        </trans-unit>
        <trans-unit id="8d9e3a327869e356dde043a93aea128672ec4a32" translate="yes" xml:space="preserve">
          <source>blame.markIgnoredLines</source>
          <target state="translated">blame.markIgnoredLines</target>
        </trans-unit>
        <trans-unit id="96c64bfbb0487dbb1fe121cc068a07b1b6f2001d" translate="yes" xml:space="preserve">
          <source>blame.markUnblamables</source>
          <target state="translated">blame.markUnblamables</target>
        </trans-unit>
        <trans-unit id="244ba240ca074db6d0f0d4bb8de34505a6383151" translate="yes" xml:space="preserve">
          <source>blame.showEmail</source>
          <target state="translated">blame.showEmail</target>
        </trans-unit>
        <trans-unit id="f2560ddc149bc689a9eb1559b1e046e4885feda7" translate="yes" xml:space="preserve">
          <source>blame.showRoot</source>
          <target state="translated">blame.showRoot</target>
        </trans-unit>
        <trans-unit id="3bc20f9fcb1740f5d09c92cd6bf8bd32d164c6ae" translate="yes" xml:space="preserve">
          <source>blame_incremental</source>
          <target state="translated">blame_incremental</target>
        </trans-unit>
        <trans-unit id="0fd0bcfb44f83e7d5ac7a8922578276b9af48746" translate="yes" xml:space="preserve">
          <source>blob</source>
          <target state="translated">blob</target>
        </trans-unit>
        <trans-unit id="815675cd53e5196255182a0fd392e03df0fcd193" translate="yes" xml:space="preserve">
          <source>blob object</source>
          <target state="translated">blob对象</target>
        </trans-unit>
        <trans-unit id="751eae742e521df559ef7ed559fa3259d5b09b0d" translate="yes" xml:space="preserve">
          <source>blob_plain</source>
          <target state="translated">blob_plain</target>
        </trans-unit>
        <trans-unit id="c06f874d67ebcdd1994d59e3867ceb303b9b6698" translate="yes" xml:space="preserve">
          <source>blobdiff</source>
          <target state="translated">blobdiff</target>
        </trans-unit>
        <trans-unit id="f7d5b2b95861daea9933ef0a243f733bbc79235e" translate="yes" xml:space="preserve">
          <source>blocks</source>
          <target state="translated">blocks</target>
        </trans-unit>
        <trans-unit id="02083f4579e08a612425c0c1a17ee47add783b94" translate="yes" xml:space="preserve">
          <source>body</source>
          <target state="translated">body</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="f6edb368393f0758009b3afd170f648a63e11385" translate="yes" xml:space="preserve">
          <source>both &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; are merge-bases of A and B. Neither one is better than the other (both are &lt;code&gt;best&lt;/code&gt; merge bases). When the &lt;code&gt;--all&lt;/code&gt; option is not given, it is unspecified which best one is output.</source>
          <target state="translated">既 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;2&lt;/code&gt; 是A和B的合并碱基既不一个比另一个（均为更好 &lt;code&gt;best&lt;/code&gt; 合并碱基）。如果未指定 &lt;code&gt;--all&lt;/code&gt; 选项，则不确定输出哪个最佳选项。</target>
        </trans-unit>
        <trans-unit id="ab885ad5b5ecb443f904caddcf71de38ec2ad4fc" translate="yes" xml:space="preserve">
          <source>both from a symlink following standpoint &lt;strong&gt;and&lt;/strong&gt; an error checking standpoint. The &quot;refs/&quot; rule for symlinks means that symlinks that point to &quot;outside&quot; the tree are safe: they&amp;rsquo;ll be followed for reading but not for writing (so we&amp;rsquo;ll never write through a ref symlink to some other tree, if you have copied a whole archive by creating a symlink tree).</source>
          <target state="translated">从符号链接的角度&lt;strong&gt;和&lt;/strong&gt;错误检查的角度来看。符号链接的&amp;ldquo; refs /&amp;rdquo;规则意味着指向树&amp;ldquo;外部&amp;rdquo;的符号链接是安全的：将遵循它们进行读取而不是写入（因此，如果出现以下情况，我们将永远不会将ref符号链接写入其他树）您已经通过创建符号链接树复制了整个存档）。</target>
        </trans-unit>
        <trans-unit id="10d735e581f1e2505cd69675691925490e447c44" translate="yes" xml:space="preserve">
          <source>branch</source>
          <target state="translated">branch</target>
        </trans-unit>
        <trans-unit id="d9ebdce6e5eb5490d2736b1657cb3bbdff2a24c8" translate="yes" xml:space="preserve">
          <source>branch &amp;lt;branchname&amp;gt; [&amp;lt;stash&amp;gt;]</source>
          <target state="translated">分支&amp;lt;分支名称&amp;gt; [&amp;lt;存储&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="4d89d47c3496bed1c997cfd4749bbb345956b062" translate="yes" xml:space="preserve">
          <source>branch name: refers to the commit at the head of the given branch</source>
          <target state="translated">分支名:指的是给定分支头的提交。</target>
        </trans-unit>
        <trans-unit id="7cf9cb4f1f0d11974da193a921ad56188af0dbfb" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.description</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.description</target>
        </trans-unit>
        <trans-unit id="c972b8f442dc56f76ff5821861f38f9df9f740a2" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.merge</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.merge</target>
        </trans-unit>
        <trans-unit id="12b705785a619a7af3091b413cd10bc5f913cd36" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.mergeOptions</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.mergeOptions</target>
        </trans-unit>
        <trans-unit id="e3044fee5f265c567fa94779be6a4b05485a2ef5" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.pushRemote</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.pushRemote</target>
        </trans-unit>
        <trans-unit id="089608ebf4ab438938386db74054dd0539e68174" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.rebase</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.rebase</target>
        </trans-unit>
        <trans-unit id="ae2da89c53e9406d5454991c9de79d2701626513" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.remote</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.remote</target>
        </trans-unit>
        <trans-unit id="c1beb4d53b0941d5b69587d5619ae40af0e82fb0" translate="yes" xml:space="preserve">
          <source>branch.autoSetupMerge</source>
          <target state="translated">branch.autoSetupMerge</target>
        </trans-unit>
        <trans-unit id="a348d9eb171112632f68ea4fa0280f35b7af36d9" translate="yes" xml:space="preserve">
          <source>branch.autoSetupRebase</source>
          <target state="translated">branch.autoSetupRebase</target>
        </trans-unit>
        <trans-unit id="c4907ecf78c64eedfc547e343a00efb0d648c80c" translate="yes" xml:space="preserve">
          <source>branch.sort</source>
          <target state="translated">branch.sort</target>
        </trans-unit>
        <trans-unit id="52a9ce4a0d3c21f1c0c5dc576930fbb59ad74018" translate="yes" xml:space="preserve">
          <source>branches</source>
          <target state="translated">branches</target>
        </trans-unit>
        <trans-unit id="ef98362b8a6b0c8cd804b0d227aa1ffeaba89786" translate="yes" xml:space="preserve">
          <source>browser</source>
          <target state="translated">browser</target>
        </trans-unit>
        <trans-unit id="d7b49d5666ac0fe3243cf929f3fbea5d40512cc5" translate="yes" xml:space="preserve">
          <source>browser.&amp;lt;tool&amp;gt;.cmd</source>
          <target state="translated">browser.&amp;lt;tool&amp;gt;.cmd</target>
        </trans-unit>
        <trans-unit id="1afa7a8068dc2826b24730832089e6b8ae806f4d" translate="yes" xml:space="preserve">
          <source>browser.&amp;lt;tool&amp;gt;.path</source>
          <target state="translated">browser.&amp;lt;tool&amp;gt;.path</target>
        </trans-unit>
        <trans-unit id="ce3731defbdc7875cff0c020e900192d6b65542c" translate="yes" xml:space="preserve">
          <source>bugreport</source>
          <target state="translated">bugreport</target>
        </trans-unit>
        <trans-unit id="26a194e96e2873f688a8836d3ee9bd5e7be08547" translate="yes" xml:space="preserve">
          <source>built-in values (some set during build stage),</source>
          <target state="translated">内置值(有些在构建阶段设置)。</target>
        </trans-unit>
        <trans-unit id="7581496de8d7f905da83e60fe5216caab582c109" translate="yes" xml:space="preserve">
          <source>bumping format version numbers of individual data files (e.g., index, packfiles, etc). This restricts the incompatibilities only to those files.</source>
          <target state="translated">颠覆个别数据文件(如索引、packfiles等)的格式版本号。这就将不兼容性限制在这些文件上。</target>
        </trans-unit>
        <trans-unit id="d59795de8a4d83834e525b589b2bb0c12e4542c1" translate="yes" xml:space="preserve">
          <source>bundle</source>
          <target state="translated">bundle</target>
        </trans-unit>
        <trans-unit id="c8bebbf42f3ec7d29b62f6981d42b56fa9e07016" translate="yes" xml:space="preserve">
          <source>but can be used to amend a merge commit.</source>
          <target state="translated">但可以用来修改合并提交。</target>
        </trans-unit>
        <trans-unit id="e0e9a8eb5c66f16a9e8325bbfe07678355605d3b" translate="yes" xml:space="preserve">
          <source>but if $REV is empty, the commit object name from master will be printed.</source>
          <target state="translated">但如果$REV为空,则会打印出master的提交对象名称。</target>
        </trans-unit>
        <trans-unit id="d086642ebaf2071be1a4671ed3801412d03ee7ac" translate="yes" xml:space="preserve">
          <source>but that may become cumbersome, when you have many attributes. Using macro attributes, you can define an attribute that, when set, also sets or unsets a number of other attributes at the same time. The system knows a built-in macro attribute, &lt;code&gt;binary&lt;/code&gt;:</source>
          <target state="translated">但是当您拥有许多属性时，这可能会变得很麻烦。使用宏属性，您可以定义一个属性，该属性在设置后还将同时设置或取消设置许多其他属性。系统知道内置宏属性 &lt;code&gt;binary&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b354ac610248436418f0a768b2a238f599b63512" translate="yes" xml:space="preserve">
          <source>but that may sometimes help you guess which tags might come after the given commit.</source>
          <target state="translated">但这有时可能会帮助你猜测哪些标签可能会在给定的提交之后出现。</target>
        </trans-unit>
        <trans-unit id="481514e03c29bd6e6c21bcf330cca66f7a8e5e03" translate="yes" xml:space="preserve">
          <source>but the command invocation was &lt;code&gt;git diff-files myfile&lt;/code&gt;, then the junkfile entry would be removed from the list because only &quot;myfile&quot; is under consideration.</source>
          <target state="translated">但是命令调用是 &lt;code&gt;git diff-files myfile&lt;/code&gt; ，然后将从列表中删除垃圾文件条目，因为仅考虑了&amp;ldquo; myfile&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9a4d92b29b4ea9cb527dbdd917995ee8e6390c1d" translate="yes" xml:space="preserve">
          <source>but this time instead of immediately making the commit, let&amp;rsquo;s take an intermediate step, and ask for diffs along the way to keep track of what&amp;rsquo;s happening:</source>
          <target state="translated">但是这次不是立即进行提交，而是让我们采取一个中间步骤，并在过程中要求差异以跟踪正在发生的事情：</target>
        </trans-unit>
        <trans-unit id="4a4c509be280ffc999d52daf10f3af16adbf10ad" translate="yes" xml:space="preserve">
          <source>but to avoid common mistakes with filename globbing etc., the command will not normally add totally new entries or remove old entries, i.e. it will normally just update existing cache entries.</source>
          <target state="translated">但为了避免文件名globbing等常见错误,该命令通常不会添加全新的条目或删除旧的条目,也就是说,它通常只是更新现有的缓存条目。</target>
        </trans-unit>
        <trans-unit id="0c8f2a0a85b88cfa647434356130399dff07d5d7" translate="yes" xml:space="preserve">
          <source>but with the algorithm used by git bisect we get:</source>
          <target state="translated">但用git bisect的算法,我们得到。</target>
        </trans-unit>
        <trans-unit id="08885cdf79de4806bc91b025b32f3b00703dcf8c" translate="yes" xml:space="preserve">
          <source>by listing files as arguments to the &lt;code&gt;commit&lt;/code&gt; command (without --interactive or --patch switch), in which case the commit will ignore changes staged in the index, and instead record the current content of the listed files (which must already be known to Git);</source>
          <target state="translated">通过列出文件作为 &lt;code&gt;commit&lt;/code&gt; 命令的参数（不带--interactive或--patch开关），在这种情况下，提交将忽略索引中暂存的更改，而是记录列出文件的当前内容（必须已经知道）到Git）;</target>
        </trans-unit>
        <trans-unit id="3836fcf09d79e41b99edac70e256133efc12bff7" translate="yes" xml:space="preserve">
          <source>by moving the &quot;pick 4&quot; line will result in the following history:</source>
          <target state="translated">通过移动 &quot;pick 4 &quot;行将导致以下历史。</target>
        </trans-unit>
        <trans-unit id="906ba5e6f6707165a9878468ec60f33a2ff34b96" translate="yes" xml:space="preserve">
          <source>by using &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to incrementally &quot;add&quot; changes to the index before using the &lt;code&gt;commit&lt;/code&gt; command (Note: even modified files must be &quot;added&quot;);</source>
          <target state="translated">通过在使用 &lt;code&gt;commit&lt;/code&gt; 命令之前使用&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;增量地&amp;ldquo;添加&amp;rdquo;对索引的更改（注意：即使已修改的文件也必须&amp;ldquo;添加&amp;rdquo;）；</target>
        </trans-unit>
        <trans-unit id="e48f31443a096bff3238667996c3f171f13b5f0c" translate="yes" xml:space="preserve">
          <source>by using &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt; to remove files from the working tree and the index, again before using the &lt;code&gt;commit&lt;/code&gt; command;</source>
          <target state="translated">再次使用 &lt;code&gt;commit&lt;/code&gt; 命令之前，使用&lt;a href=&quot;git-rm&quot;&gt;git-rm [1]&lt;/a&gt;从工作树和索引中删除文件；</target>
        </trans-unit>
        <trans-unit id="093a3f97e95959ebe22524ee0ce832b0babc748b" translate="yes" xml:space="preserve">
          <source>by using the --interactive or --patch switches with the &lt;code&gt;commit&lt;/code&gt; command to decide one by one which files or hunks should be part of the commit in addition to contents in the index, before finalizing the operation. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate these modes.</source>
          <target state="translated">通过使用--interactive或--patch开关与 &lt;code&gt;commit&lt;/code&gt; 命令一起，在完成操作之前，一一决定除索引中的内容外，哪些文件或块应该是提交的一部分。请参阅&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;的&amp;ldquo;交互模式&amp;rdquo;部分以了解如何操作这些模式。</target>
        </trans-unit>
        <trans-unit id="4834ad1b53b94300bc089b00aaeed76c52aebbcd" translate="yes" xml:space="preserve">
          <source>by using the -a switch with the &lt;code&gt;commit&lt;/code&gt; command to automatically &quot;add&quot; changes from all known files (i.e. all files that are already listed in the index) and to automatically &quot;rm&quot; files in the index that have been removed from the working tree, and then perform the actual commit;</source>
          <target state="translated">通过使用带有 &lt;code&gt;commit&lt;/code&gt; 命令的-a开关，可以自动&amp;ldquo;添加&amp;rdquo;所有已知文件（即已在索引中列出的所有文件）中的更改，并自动&amp;ldquo;删除&amp;rdquo;已从工作树中删除的索引中的文件，然后执行实际的提交；</target>
        </trans-unit>
        <trans-unit id="b03592806efabfeeb709f5a70a7c172669b00538" translate="yes" xml:space="preserve">
          <source>cache</source>
          <target state="translated">cache</target>
        </trans-unit>
        <trans-unit id="0c93713c1e43fccf897b7b4f02e822c65d557fdf" translate="yes" xml:space="preserve">
          <source>cached</source>
          <target state="translated">cached</target>
        </trans-unit>
        <trans-unit id="9eafea1e818b36cfe83084dbfcee79ccb268deb8" translate="yes" xml:space="preserve">
          <source>cancel the cherry-pick. In other words, return to the pre-cherry-pick state, preserving any local modifications you had in the working tree.</source>
          <target state="translated">取消摘取樱桃的操作。换句话说,回到采摘前的状态,保留工作树中的任何局部修改。</target>
        </trans-unit>
        <trans-unit id="21ca164274e6e0b587a5c99674b651b198887373" translate="yes" xml:space="preserve">
          <source>cat-blob</source>
          <target state="translated">cat-blob</target>
        </trans-unit>
        <trans-unit id="1b0b597309b09f88e890e96ee25a4239e209bcc6" translate="yes" xml:space="preserve">
          <source>cat-blob-fd</source>
          <target state="translated">cat-blob-fd</target>
        </trans-unit>
        <trans-unit id="1b860f3f13df1c0a7cb167ae98ab823bd793ef37" translate="yes" xml:space="preserve">
          <source>cat-file</source>
          <target state="translated">cat-file</target>
        </trans-unit>
        <trans-unit id="6bdc4dd4748a2bfb630e761b44a4eee74e5812c1" translate="yes" xml:space="preserve">
          <source>category (or &lt;code&gt;gitweb.category&lt;/code&gt;)</source>
          <target state="translated">类别（或 &lt;code&gt;gitweb.category&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="d027a2f7150c9c1d54212c981331ced097d02521" translate="yes" xml:space="preserve">
          <source>cd_to_toplevel</source>
          <target state="translated">cd_to_toplevel</target>
        </trans-unit>
        <trans-unit id="2cf64e447b84b497b2491b7af072a229eefe2651" translate="yes" xml:space="preserve">
          <source>chain</source>
          <target state="translated">chain</target>
        </trans-unit>
        <trans-unit id="eea15bfc0410c3d01d0daf4a8e336e46da972ca0" translate="yes" xml:space="preserve">
          <source>changeset</source>
          <target state="translated">changeset</target>
        </trans-unit>
        <trans-unit id="60863ff2c00bd434be8f30a313cc6bf530d01628" translate="yes" xml:space="preserve">
          <source>check the branch names in an external repository (if not known).</source>
          <target state="translated">检查外部仓库中的分支名称(如果不知道)。</target>
        </trans-unit>
        <trans-unit id="1f1c087ebd5ee9330247a27b3cb5e1c3309d1b49" translate="yes" xml:space="preserve">
          <source>check-ignore</source>
          <target state="translated">check-ignore</target>
        </trans-unit>
        <trans-unit id="d5491e7e7124a22dd73fa746ba129c59f9dc6d5d" translate="yes" xml:space="preserve">
          <source>checkout</source>
          <target state="translated">checkout</target>
        </trans-unit>
        <trans-unit id="f1d6e05726e233a2ab8de16435d659a28a2e35a7" translate="yes" xml:space="preserve">
          <source>checkout a new branch &lt;code&gt;mine&lt;/code&gt; from master.</source>
          <target state="translated">从master 结帐一个新的分支 &lt;code&gt;mine&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="baa127da3b2e7bb80d470a5c5b3ed484fc3ecffa" translate="yes" xml:space="preserve">
          <source>checkout-index</source>
          <target state="translated">checkout-index</target>
        </trans-unit>
        <trans-unit id="77ccc4847f3f5995981f07a9aaa766d505e363d0" translate="yes" xml:space="preserve">
          <source>checkout.defaultRemote</source>
          <target state="translated">checkout.defaultRemote</target>
        </trans-unit>
        <trans-unit id="dede2b7b3445b7f569a7e102150c9e77ea7be895" translate="yes" xml:space="preserve">
          <source>checkout.guess</source>
          <target state="translated">checkout.guess</target>
        </trans-unit>
        <trans-unit id="7993ca6fc917dfcd7447613538a9f2529705f4e5" translate="yes" xml:space="preserve">
          <source>checkoutAmbiguousRemoteBranchName</source>
          <target state="translated">checkoutAmbiguousRemoteBranchName</target>
        </trans-unit>
        <trans-unit id="9c92181fd5e68d410f28e18265218b8c3a8a1b78" translate="yes" xml:space="preserve">
          <source>checks if the current directory is within the working tree of the repository, and otherwise dies.</source>
          <target state="translated">检查当前目录是否在版本库的工作树中,否则死亡。</target>
        </trans-unit>
        <trans-unit id="2e41d31ec807e404264bdbe4cf0898e0675b3d63" translate="yes" xml:space="preserve">
          <source>checks if the working tree associated with the repository exists, and otherwise dies. Often done before calling cd_to_toplevel, which is impossible to do if there is no working tree.</source>
          <target state="translated">检查与版本库相关联的工作树是否存在,否则死亡。通常在调用cd_to_toplevel之前完成,如果没有工作树,则无法完成。</target>
        </trans-unit>
        <trans-unit id="6ce38e1ed1561eb51f91bed4e5b8b42001fa1cda" translate="yes" xml:space="preserve">
          <source>checks out all files in the index. Cannot be used together with explicit filenames.</source>
          <target state="translated">检查索引中的所有文件。不能与显式文件名一起使用。</target>
        </trans-unit>
        <trans-unit id="b095764396dd7603ab632901ad86334026f5e97f" translate="yes" xml:space="preserve">
          <source>checks out an older version. Continue like this, telling Git at each stage whether the version it gives you is good or bad, and notice that the number of revisions left to test is cut approximately in half each time.</source>
          <target state="translated">检查出一个旧版本。继续这样做,在每个阶段告诉Git它给你的版本是好是坏,注意到每次测试剩下的修改次数大约减少一半。</target>
        </trans-unit>
        <trans-unit id="9d48ee970ac151e88a06bd52df27d444e45a115f" translate="yes" xml:space="preserve">
          <source>checks that the working tree and index associated with the repository have no uncommitted changes to tracked files. Otherwise it emits an error message of the form &lt;code&gt;Cannot
&amp;lt;action&amp;gt;: &amp;lt;reason&amp;gt;. &amp;lt;hint&amp;gt;&lt;/code&gt;, and dies. Example:</source>
          <target state="translated">检查与存储库关联的工作树和索引是否对跟踪的文件没有未提交的更改。否则，它将发出以下形式的错误消息： &lt;code&gt;Cannot &amp;lt;action&amp;gt;: &amp;lt;reason&amp;gt;. &amp;lt;hint&amp;gt;&lt;/code&gt; ，然后死亡。例：</target>
        </trans-unit>
        <trans-unit id="fde288e73fa35b620c1d091cd10bc2b4ef783b38" translate="yes" xml:space="preserve">
          <source>cherry-pick</source>
          <target state="translated">cherry-pick</target>
        </trans-unit>
        <trans-unit id="4d3ec7cec131af0636c8c4eb3ed9fad46bbbd8fe" translate="yes" xml:space="preserve">
          <source>cherry-picking</source>
          <target state="translated">cherry-picking</target>
        </trans-unit>
        <trans-unit id="13bb03a5ed8a80118d832f3194a1f24bdfb90600" translate="yes" xml:space="preserve">
          <source>chromium (also supported as chromium-browser)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1aab85a96cc8931c6cead1715bf9f08fbd159e1" translate="yes" xml:space="preserve">
          <source>citool</source>
          <target state="translated">citool</target>
        </trans-unit>
        <trans-unit id="6a1cec45eaf37b34e1b1d89130d7746fe4006346" translate="yes" xml:space="preserve">
          <source>clean</source>
          <target state="translated">clean</target>
        </trans-unit>
        <trans-unit id="6191f3c6c1156403f2abec74131f05962f1abaa8" translate="yes" xml:space="preserve">
          <source>clean.requireForce</source>
          <target state="translated">clean.requireForce</target>
        </trans-unit>
        <trans-unit id="168cbb2ea52b9e34d271accecfa7d7951e948a99" translate="yes" xml:space="preserve">
          <source>clear</source>
          <target state="translated">clear</target>
        </trans-unit>
        <trans-unit id="5e0072329d5085c5bc5c23c2fa873dd42900958b" translate="yes" xml:space="preserve">
          <source>clone</source>
          <target state="translated">clone</target>
        </trans-unit>
        <trans-unit id="65b7b2d52a3b114f58dca240d43da422bee2212d" translate="yes" xml:space="preserve">
          <source>clone sets these configuration variables by default. It arranges &lt;code&gt;git pull&lt;/code&gt; to fetch and store the branches of mothership machine to local &lt;code&gt;remotes/origin/*&lt;/code&gt; remote-tracking branches.</source>
          <target state="translated">默认情况下，clone设置这些配置变量。它安排 &lt;code&gt;git pull&lt;/code&gt; 来获取母机的分支并将其存储到本地 &lt;code&gt;remotes/origin/*&lt;/code&gt; 远程跟踪分支。</target>
        </trans-unit>
        <trans-unit id="915d6fb92a6ac08fb7138984ea283c14a9573f89" translate="yes" xml:space="preserve">
          <source>clone.defaultRemoteName</source>
          <target state="translated">clone.defaultRemoteName</target>
        </trans-unit>
        <trans-unit id="b0039cf0af8bf144bcdb5512b615336fbd740a49" translate="yes" xml:space="preserve">
          <source>cloneurl (or multiple-valued &lt;code&gt;gitweb.url&lt;/code&gt;)</source>
          <target state="translated">cloneurl（或多值 &lt;code&gt;gitweb.url&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ada0de0751f70d1f9286c0a71669d799d3961206" translate="yes" xml:space="preserve">
          <source>codecompare</source>
          <target state="translated">codecompare</target>
        </trans-unit>
        <trans-unit id="d2cff126ddc906e1a4a856fa830eddaf46fcb2f4" translate="yes" xml:space="preserve">
          <source>collapse multiple consecutive empty lines into one empty line</source>
          <target state="translated">将多个连续的空行折叠成一个空行。</target>
        </trans-unit>
        <trans-unit id="6dd0fe8001145bec4a12d0e22da711c4970d000b" translate="yes" xml:space="preserve">
          <source>color</source>
          <target state="translated">color</target>
        </trans-unit>
        <trans-unit id="a5c6de6e1d6a5426c3f20e289bee4cb63cd9b46d" translate="yes" xml:space="preserve">
          <source>color specification, as described under Values in the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. By default, colors are shown only when enabled for log output (by &lt;code&gt;color.diff&lt;/code&gt;, &lt;code&gt;color.ui&lt;/code&gt;, or &lt;code&gt;--color&lt;/code&gt;, and respecting the &lt;code&gt;auto&lt;/code&gt; settings of the former if we are going to a terminal). &lt;code&gt;%C(auto,...)&lt;/code&gt; is accepted as a historical synonym for the default (e.g., &lt;code&gt;%C(auto,red)&lt;/code&gt;). Specifying &lt;code&gt;%C(always,...)&lt;/code&gt; will show the colors even when color is not otherwise enabled (though consider just using &lt;code&gt;--color=always&lt;/code&gt; to enable color for the whole output, including this format and anything else git might color). &lt;code&gt;auto&lt;/code&gt; alone (i.e. &lt;code&gt;%C(auto)&lt;/code&gt;) will turn on auto coloring on the next placeholders until the color is switched again.</source>
          <target state="translated">颜色规范，如&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;的&amp;ldquo;配置文件&amp;rdquo;部分中的&amp;ldquo;值&amp;rdquo;下所述。默认情况下，仅在启用日志输出时才显示颜色（通过 &lt;code&gt;color.diff&lt;/code&gt; ， &lt;code&gt;color.ui&lt;/code&gt; 或 &lt;code&gt;--color&lt;/code&gt; ，并且如果要连接到终端，则要遵循前者的 &lt;code&gt;auto&lt;/code&gt; 设置）。 &lt;code&gt;%C(auto,...)&lt;/code&gt; 作为默认值的历史同义词（例如， &lt;code&gt;%C(auto,red)&lt;/code&gt; ）被接受。即使未启用颜色 &lt;code&gt;%C(always,...)&lt;/code&gt; 指定％C（always，...）也会显示颜色（尽管考虑仅使用 &lt;code&gt;--color=always&lt;/code&gt; 为整个输出启用颜色，包括此格式以及git可能会着色的其他任何颜色）。 &lt;code&gt;auto&lt;/code&gt; 单独（即 &lt;code&gt;%C(auto)&lt;/code&gt; ）将在下一个占位符上启用自动着色，直到再次切换颜色为止。</target>
        </trans-unit>
        <trans-unit id="a4f66bcbf0c2d907db9d73e18998c425a594621e" translate="yes" xml:space="preserve">
          <source>color.advice</source>
          <target state="translated">color.advice</target>
        </trans-unit>
        <trans-unit id="8c847b9d6812ac606092130570e37493e972ad8a" translate="yes" xml:space="preserve">
          <source>color.advice.hint</source>
          <target state="translated">color.advice.hint</target>
        </trans-unit>
        <trans-unit id="46ab34863195debec0a658a6884ce1958a8721f8" translate="yes" xml:space="preserve">
          <source>color.blame.highlightRecent</source>
          <target state="translated">color.blame.highlightRecent</target>
        </trans-unit>
        <trans-unit id="cf152df8d71a4044f40941cffe12b4c5947d84c6" translate="yes" xml:space="preserve">
          <source>color.blame.repeatedLines</source>
          <target state="translated">color.blame.repeatedLines</target>
        </trans-unit>
        <trans-unit id="8ab572aa07e705b6cbb5dc02e6cc07d1c537adb5" translate="yes" xml:space="preserve">
          <source>color.branch</source>
          <target state="translated">color.branch</target>
        </trans-unit>
        <trans-unit id="ca9ef171160b4af8190637b4572026e1b567c98a" translate="yes" xml:space="preserve">
          <source>color.branch.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.branch.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ce3eb96e296266263902a69bbdcb71f2305cb04d" translate="yes" xml:space="preserve">
          <source>color.decorate.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.decorate.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="afd9432dd61dede344700077be0856defef90c96" translate="yes" xml:space="preserve">
          <source>color.diff</source>
          <target state="translated">color.diff</target>
        </trans-unit>
        <trans-unit id="f6c051574f795381da2ac0bc58ffe0019036f226" translate="yes" xml:space="preserve">
          <source>color.diff.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.diff.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92611cb178c25cb2a36a185c2d51eb34ec21f182" translate="yes" xml:space="preserve">
          <source>color.grep</source>
          <target state="translated">color.grep</target>
        </trans-unit>
        <trans-unit id="514f2bfe2d4e52955ecf7c8018e222f3399098ca" translate="yes" xml:space="preserve">
          <source>color.grep.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.grep.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2a6e9053b32a43b99b387012d73632508c2e585a" translate="yes" xml:space="preserve">
          <source>color.interactive</source>
          <target state="translated">color.interactive</target>
        </trans-unit>
        <trans-unit id="dd02e0dce40f7d7025a402d431583fd14b053a0f" translate="yes" xml:space="preserve">
          <source>color.interactive.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.interactive.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="51223f4d2a0db29c55b88b1aeefff0292cdf6915" translate="yes" xml:space="preserve">
          <source>color.pager</source>
          <target state="translated">color.pager</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
