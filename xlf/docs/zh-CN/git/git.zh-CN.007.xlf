<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="6da92828bff93237c525d505f61963005fa8aa9b" translate="yes" xml:space="preserve">
          <source>Merges can be also made simpler by using smaller branches or by using many topic branches instead of only long version related branches.</source>
          <target state="translated">合并也可以通过使用更小的分支或使用许多主题分支而不是只使用长的版本相关分支来简化。</target>
        </trans-unit>
        <trans-unit id="18462046f484e3565df5821cdce8eadab95f1224" translate="yes" xml:space="preserve">
          <source>Merges have many advantages, so we try to solve as many problems as possible with merges alone. Cherry-picking is still occasionally useful; see &quot;Merging upwards&quot; below for an example.</source>
          <target state="translated">合并有很多优点,所以我们尽量只用合并来解决问题。挑剔偶尔还是有用的,请看下面 &quot;向上合并 &quot;的例子。</target>
        </trans-unit>
        <trans-unit id="40de0d4de887a374168bf79e72c7aa0fa4594d6e" translate="yes" xml:space="preserve">
          <source>Merging</source>
          <target state="translated">Merging</target>
        </trans-unit>
        <trans-unit id="f2204607f23628214b6d42add29d21c7f2e29b95" translate="yes" xml:space="preserve">
          <source>Merging branches with differing checkin/checkout attributes</source>
          <target state="translated">合并具有不同签入/签出属性的分支。</target>
        </trans-unit>
        <trans-unit id="c535f2db054f922c7b696495f8b89a913e2a11c4" translate="yes" xml:space="preserve">
          <source>Merging external work</source>
          <target state="translated">合并外部工作</target>
        </trans-unit>
        <trans-unit id="603157d894d36cb77fbe21d75b0d20a12dc01779" translate="yes" xml:space="preserve">
          <source>Merging inside a &lt;a href=&quot;#def_shallow_clone&quot;&gt;shallow clone&lt;/a&gt; will work as long as a merge base is in the recent history. Otherwise, it will be like merging unrelated histories and may have to result in huge conflicts. This limitation may make such a repository unsuitable to be used in merge based workflows.</source>
          <target state="translated">一个内部合并&lt;a href=&quot;#def_shallow_clone&quot;&gt;浅克隆&lt;/a&gt;将工作只要合并基础是在最近的历史。否则，这就像合并无关的历史记录一样，可能会导致巨大的冲突。此限制可能使这样的存储库不适合在基于合并的工作流中使用。</target>
        </trans-unit>
        <trans-unit id="ab26fbd41a8ed9c39ebd7d129433578a03343e81" translate="yes" xml:space="preserve">
          <source>Merging multiple trees</source>
          <target state="translated">合并多棵树</target>
        </trans-unit>
        <trans-unit id="f73ac93115d3cdadc50aebe7fa9b08f89899740b" translate="yes" xml:space="preserve">
          <source>Merging multiple trees, continued</source>
          <target state="translated">合并多棵树,继续</target>
        </trans-unit>
        <trans-unit id="98b404243306169adb88696dc4ad2165a137c1ac" translate="yes" xml:space="preserve">
          <source>Merging tag</source>
          <target state="translated">合并标签</target>
        </trans-unit>
        <trans-unit id="1af53d3a2af732fec14191525698059a5e40b8d4" translate="yes" xml:space="preserve">
          <source>Merging two branches</source>
          <target state="translated">合并两个分支</target>
        </trans-unit>
        <trans-unit id="6153c9c2afc2b444427af54ff710f1f84e9dda45" translate="yes" xml:space="preserve">
          <source>Merging upwards</source>
          <target state="translated">向上合并</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="ede02150d3611f561b342e50cd978f7d1c7b1d2a" translate="yes" xml:space="preserve">
          <source>Miscellaneous capabilities</source>
          <target state="translated">杂项能力</target>
        </trans-unit>
        <trans-unit id="68e2e957e53389b060cb16e85d086c46b6c88151" translate="yes" xml:space="preserve">
          <source>Missing From or In-Reply-To headers will be prompted for.</source>
          <target state="translated">遗漏的发件人或回信头将被提示。</target>
        </trans-unit>
        <trans-unit id="00b61542d0211972bc61982931e3e8c50577c383" translate="yes" xml:space="preserve">
          <source>Modified content is represented by &quot;-&quot; lines (removing the old content) followed by &quot;+&quot; lines (adding the replacement content). You can prevent staging the modification by converting &quot;-&quot; lines to &quot; &quot;, and removing &quot;+&quot; lines. Beware that modifying only half of the pair is likely to introduce confusing changes to the index.</source>
          <target state="translated">修改后的内容用&quot;-&quot;行表示(删除旧内容),后面用 &quot;+&quot;行表示(添加替换内容)。您可以通过将&quot;-&quot;行转换为&quot; &quot;,并删除 &quot;+&quot;行来防止分期修改。要注意的是,只修改一半的对子,很可能会给索引带来混乱的变化。</target>
        </trans-unit>
        <trans-unit id="6e5a153f7d9724480c99f8d43544411a606a03ba" translate="yes" xml:space="preserve">
          <source>Modifies the index or directory cache. Each file mentioned is updated into the index and any &lt;code&gt;unmerged&lt;/code&gt; or &lt;code&gt;needs updating&lt;/code&gt; state is cleared.</source>
          <target state="translated">修改索引或目录缓存。提到的每个文件都会更新到索引中，并且清除所有未 &lt;code&gt;unmerged&lt;/code&gt; 或 &lt;code&gt;needs updating&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="f87d4010c94238df04ebfd441b3a0111f33d7a25" translate="yes" xml:space="preserve">
          <source>Modify behavior of the next command naming a &amp;lt;ref&amp;gt;. The only valid option is &lt;code&gt;no-deref&lt;/code&gt; to avoid dereferencing a symbolic ref.</source>
          <target state="translated">修改下一个命名为&amp;lt;ref&amp;gt;的命令的行为。唯一有效的选项是 &lt;code&gt;no-deref&lt;/code&gt; ,以避免取消引用符号ref。</target>
        </trans-unit>
        <trans-unit id="eeb79095663bd56bf370bd2096cd4a5ecc99b3a1" translate="yes" xml:space="preserve">
          <source>Modify some files, then add their updated contents to the index:</source>
          <target state="translated">修改一些文件,然后将其更新的内容添加到索引中。</target>
        </trans-unit>
        <trans-unit id="19db1a3cc38a1c275e20ba3eb14f5761050f2bac" translate="yes" xml:space="preserve">
          <source>Modifying the index is easy:</source>
          <target state="translated">修改索引很容易。</target>
        </trans-unit>
        <trans-unit id="3d6095a82dcd262f6e6b119640e8d9b20bcf7da2" translate="yes" xml:space="preserve">
          <source>More detail on the following is available from the &lt;a href=&quot;user-manual#git-concepts&quot;&gt;Git concepts chapter of the user-manual&lt;/a&gt; and &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;user-manual#git-concepts&quot;&gt;用户手册&lt;/a&gt;和&lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt;的Git概念章节提供了有关以下内容的更多详细信息。</target>
        </trans-unit>
        <trans-unit id="06099ebf3c1fb2d228710b5b862871e1eab3c063" translate="yes" xml:space="preserve">
          <source>More generally, a branch that is created from a remote-tracking branch will pull by default from that branch. See the descriptions of the &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; options in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;, and the discussion of the &lt;code&gt;--track&lt;/code&gt; option in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, to learn how to control these defaults.</source>
          <target state="translated">更一般地，从远程跟踪分支创建的分支将默认从该分支中​​拉出。请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]中&lt;/a&gt; &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 和 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 选项的描述，以及&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;中有关 &lt;code&gt;--track&lt;/code&gt; 选项的讨论，以了解如何控制这些默认值。</target>
        </trans-unit>
        <trans-unit id="415ceff2cb011b2c5375c0d469dab2cba200eaed" translate="yes" xml:space="preserve">
          <source>More generally, among the two commits to compute the merge base from, one is specified by the first commit argument on the command line; the other commit is a (possibly hypothetical) commit that is a merge across all the remaining commits on the command line.</source>
          <target state="translated">一般来说,在计算合并基数的两个提交中,一个是由命令行上的第一个提交参数指定的;另一个提交是一个(可能是假设的)提交,是命令行上所有剩余提交的合并。</target>
        </trans-unit>
        <trans-unit id="816cda5b46035bd1542e1775969151ec4a09cada" translate="yes" xml:space="preserve">
          <source>More importantly, it allows the update of a ref file to follow these symbolic pointers, whether they are symlinks or these &quot;regular file symbolic refs&quot;. It follows &lt;strong&gt;real&lt;/strong&gt; symlinks only if they start with &quot;refs/&quot;: otherwise it will just try to read them and update them as a regular file (i.e. it will allow the filesystem to follow them, but will overwrite such a symlink to somewhere else with a regular filename).</source>
          <target state="translated">更重要的是，它允许更新引用文件以遵循这些符号指针，无论它们是符号链接还是这些&amp;ldquo;常规文件符号引用&amp;rdquo;。仅当它们以&amp;ldquo; refs /&amp;rdquo;开头时，它才遵循&lt;strong&gt;真实的&lt;/strong&gt;符号链接：否则，它将尝试读取它们并将其更新为常规文件（即，它将允许文件系统跟随它们，但是将此类符号链接覆盖为其他符号）常规文件名）。</target>
        </trans-unit>
        <trans-unit id="2be26ffe68463b96abc5601cef9bdbafbf2f631d" translate="yes" xml:space="preserve">
          <source>More interestingly, you can also give &lt;code&gt;git diff-tree&lt;/code&gt; the &lt;code&gt;--pretty&lt;/code&gt; flag, which tells it to also show the commit message and author and date of the commit, and you can tell it to show a whole series of diffs. Alternatively, you can tell it to be &quot;silent&quot;, and not show the diffs at all, but just show the actual commit message.</source>
          <target state="translated">更有趣的是，你也可以给 &lt;code&gt;git diff-tree&lt;/code&gt; 的 &lt;code&gt;--pretty&lt;/code&gt; 标志，告诉它也显示提交信息和作者的提交日期，你可以告诉它显示了一系列的diff的。另外，您可以说它是&amp;ldquo;无声的&amp;rdquo;，根本不显示差异，而仅显示实际的提交消息。</target>
        </trans-unit>
        <trans-unit id="854ef0fd2eba012b7c2e6ecb33388db153e60f9a" translate="yes" xml:space="preserve">
          <source>More on recovery from repository corruption. See: &lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&lt;/a&gt;&lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&lt;/a&gt;</source>
          <target state="translated">有关从存储库损坏中恢复的更多信息。参见：&lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&quot;&gt;https&lt;/a&gt; : //lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/ &lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@ woody.linux-foundation.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1784c94f3b7a373b03c0ae45229574de43eee20" translate="yes" xml:space="preserve">
          <source>More precisely, &lt;code&gt;git pull&lt;/code&gt; runs &lt;code&gt;git fetch&lt;/code&gt; with the given parameters and calls &lt;code&gt;git merge&lt;/code&gt; to merge the retrieved branch heads into the current branch. With &lt;code&gt;--rebase&lt;/code&gt;, it runs &lt;code&gt;git rebase&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">更精确地讲， &lt;code&gt;git pull&lt;/code&gt; 使用给定的参数运行 &lt;code&gt;git fetch&lt;/code&gt; ，并调用 &lt;code&gt;git merge&lt;/code&gt; 将检索到的分支头合并到当前分支中。使用 &lt;code&gt;--rebase&lt;/code&gt; ，它将运行 &lt;code&gt;git rebase&lt;/code&gt; 而不是 &lt;code&gt;git merge&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17f51f170751975b2cc4764665c6e712fb67447f" translate="yes" xml:space="preserve">
          <source>Most CVS command arguments that read CVS tags or revision numbers (typically -r) work, and also support any git refspec (tag, branch, commit ID, etc). However, CVS revision numbers for non-default branches are not well emulated, and cvs log does not show tags or branches at all. (Non-main-branch CVS revision numbers superficially resemble CVS revision numbers, but they actually encode a git commit ID directly, rather than represent the number of revisions since the branch point.)</source>
          <target state="translated">大多数读取 CVS 标签或版本号的 CVS 命令参数(通常是 -r)都可以使用,并且也支持任何 git refspec(标签、分支、提交 ID 等)。然而,非默认分支的 CVS 版本号并不能很好地模拟,cvs 日志根本不显示标签或分支。(非主分支的CVS修订号表面上和CVS修订号很像,但实际上是直接编码一个git提交ID,而不是代表自分支点以来的修订次数。)</target>
        </trans-unit>
        <trans-unit id="880f481ef12ec663b5ff4186eb50766022add75f" translate="yes" xml:space="preserve">
          <source>Most bottlenecks appear to be in foreign source data access (the source just cannot extract revisions fast enough) or disk IO (fast-import writes as fast as the disk will take the data). Imports will run faster if the source data is stored on a different drive than the destination Git repository (due to less IO contention).</source>
          <target state="translated">大多数瓶颈似乎是在国外的源数据访问(源数据不能足够快地提取修订版)或磁盘IO(快速导入写入的速度与磁盘接收数据的速度一样快)。如果源数据存储在与目标 Git 仓库不同的硬盘上,导入速度会更快(因为 IO 争用较少)。</target>
        </trans-unit>
        <trans-unit id="b1a743b45e6efbd5b49b8c3c8d73ad9b477276e1" translate="yes" xml:space="preserve">
          <source>Most commits have only one parent, but it is also common for a commit to have multiple parents. In that case the commit represents a merge, with the parent references pointing to the heads of the merged branches.</source>
          <target state="translated">大多数提交只有一个父节点,但一个提交有多个父节点的情况也很常见。在这种情况下,提交代表了一个合并,父级引用指向合并后的分支的头。</target>
        </trans-unit>
        <trans-unit id="4d50eced4caaa6d0cca3ee6a1e2e2e07d0d5849b" translate="yes" xml:space="preserve">
          <source>Most importantly, merging works at the branch level, while cherry-picking works at the commit level. This means that a merge can carry over the changes from 1, 10, or 1000 commits with equal ease, which in turn means the workflow scales much better to a large number of contributors (and contributions). Merges are also easier to understand because a merge commit is a &quot;promise&quot; that all changes from all its parents are now included.</source>
          <target state="translated">最重要的是,合并工作在分支级别,而摘取工作在提交级别。这意味着,合并可以同样轻松地将1个、10个或1000个提交中的变更带入,这反过来又意味着工作流可以更好地扩展到大量的贡献者(和贡献)。合并也更容易理解,因为一个合并提交是一个 &quot;承诺&quot;,即所有来自其父提交的修改现在都被包含在内。</target>
        </trans-unit>
        <trans-unit id="2e130c2e2dd2a16594642aa625e1fc3c4df26608" translate="yes" xml:space="preserve">
          <source>Most of features are configured via &lt;code&gt;%feature&lt;/code&gt; hash; however some of extra gitweb features can be turned on and configured using variables described below. This list beside configuration variables that control how gitweb looks does contain variables configuring administrative side of gitweb (e.g. cross-site scripting prevention; admittedly this as side effect affects how &quot;summary&quot; pages look like, or load limiting).</source>
          <target state="translated">大多数功能都是通过 &lt;code&gt;%feature&lt;/code&gt; 哈希配置的；但是，某些额外的gitweb功能可以使用以下所述的变量打开和配置。控制gitweb外观的配置变量旁边的列表确实包含配置gitweb的管理方面的变量（例如，跨站点脚本防护；不可否认，这是因为副作用会影响&amp;ldquo;摘要&amp;rdquo;页面的外观或负载限制）。</target>
        </trans-unit>
        <trans-unit id="12c479c9b5f1b05779ca1427f8469c4d0c8e41b4" translate="yes" xml:space="preserve">
          <source>Most of what &lt;code&gt;git rev-list&lt;/code&gt; did is contained in &lt;code&gt;revision.c&lt;/code&gt; and &lt;code&gt;revision.h&lt;/code&gt;. It wraps the options in a struct named &lt;code&gt;rev_info&lt;/code&gt;, which controls how and what revisions are walked, and more.</source>
          <target state="translated">&lt;code&gt;git rev-list&lt;/code&gt; 所做的大部分工作都包含在 &lt;code&gt;revision.c&lt;/code&gt; 和 &lt;code&gt;revision.h&lt;/code&gt; 。它将选项包装在名为 &lt;code&gt;rev_info&lt;/code&gt; 的结构中，该结构控制如何以及如何修改修订内容，等等。</target>
        </trans-unit>
        <trans-unit id="9ceb817bd0e340cfd6e3a665612ec974c7873cd6" translate="yes" xml:space="preserve">
          <source>Most operations that add an object to the database update the modification time of the object if it is already present so that #1 applies.</source>
          <target state="translated">大多数在数据库中添加对象的操作都会更新对象的修改时间,如果对象已经存在,那么#1就适用。</target>
        </trans-unit>
        <trans-unit id="ed4a3f36c4746567049b5d83d49f91438e7cd1fa" translate="yes" xml:space="preserve">
          <source>Most projects also use &lt;a href=&quot;#def_tag&quot;&gt;tags&lt;/a&gt;. Tags, like heads, are references into the project&amp;rsquo;s history, and can be listed using the &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; command:</source>
          <target state="translated">大多数项目还使用&lt;a href=&quot;#def_tag&quot;&gt;标签&lt;/a&gt;。标签（如heads）是对项目历史的引用，可以使用&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;命令列出：</target>
        </trans-unit>
        <trans-unit id="6e9a1bc6364ad2c889e7f09c69628c8251c67662" translate="yes" xml:space="preserve">
          <source>Most projects with multiple contributors (such as the Linux kernel, or Git itself) have frequent merges, and &lt;code&gt;gitk&lt;/code&gt; does a better job of visualizing their history. For example,</source>
          <target state="translated">大多数具有多个贡献者的项目（例如Linux内核或Git本身）都有频繁的合并，而 &lt;code&gt;gitk&lt;/code&gt; 在可视化其历史方面做得更好。例如，</target>
        </trans-unit>
        <trans-unit id="b110af03cd46bd74e1684a2cb53fb12fe52de561" translate="yes" xml:space="preserve">
          <source>Mostly a synonym to &lt;a href=&quot;#def_shallow_repository&quot;&gt;shallow repository&lt;/a&gt; but the phrase makes it more explicit that it was created by running &lt;code&gt;git clone --depth=&amp;hellip;​&lt;/code&gt; command.</source>
          <target state="translated">大多的代名词，以&lt;a href=&quot;#def_shallow_repository&quot;&gt;浅资源库&lt;/a&gt;，但那句使得它更加明确，它是由运行时创建 &lt;code&gt;git clone --depth=&amp;hellip;​&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="0a0252ca3dca0dd6561eccb6a1ba0495bf433801" translate="yes" xml:space="preserve">
          <source>Mostly a synonym to &lt;a href=&quot;#def_shallow_repository&quot;&gt;shallow repository&lt;/a&gt; but the phrase makes it more explicit that it was created by running &lt;code&gt;git clone --depth=...&lt;/code&gt; command.</source>
          <target state="translated">通常是&lt;a href=&quot;#def_shallow_repository&quot;&gt;浅层存储库&lt;/a&gt;的同义词，但该短语使它更明确地表明它是通过运行 &lt;code&gt;git clone --depth=...&lt;/code&gt; 命令创建的。</target>
        </trans-unit>
        <trans-unit id="437db9b7f03fcf9c59c19e8599b81a4181786550" translate="yes" xml:space="preserve">
          <source>Move a working tree to a new location. Note that the main working tree or linked working trees containing submodules cannot be moved.</source>
          <target state="translated">将工作树移动到新的位置。注意,主工作树或包含子模块的链接工作树不能移动。</target>
        </trans-unit>
        <trans-unit id="00451deb449902283a1a1b09ee616f563047050b" translate="yes" xml:space="preserve">
          <source>Move objects and refs by archive</source>
          <target state="translated">按档案移动对象和参考资料</target>
        </trans-unit>
        <trans-unit id="0a2aa584391bc2ed097c1ace071233493faa0978" translate="yes" xml:space="preserve">
          <source>Move or rename a file, a directory, or a symlink</source>
          <target state="translated">移动或重命名一个文件、一个目录或一个符号链接。</target>
        </trans-unit>
        <trans-unit id="4bc0abe3ae87a3007e76abb67d150957939b61b8" translate="yes" xml:space="preserve">
          <source>Move or rename a file, directory or symlink.</source>
          <target state="translated">移动或重命名一个文件、目录或符号链接。</target>
        </trans-unit>
        <trans-unit id="24cb8f062e449dc4167b50460e2e7341fe4e0aa6" translate="yes" xml:space="preserve">
          <source>Move/rename a branch and the corresponding reflog.</source>
          <target state="translated">移动/重命名一个分支和相应的重新记录。</target>
        </trans-unit>
        <trans-unit id="86a2fcc8fa8d4ad8c3c46b9d3e5182feb14f1b60" translate="yes" xml:space="preserve">
          <source>Moved lines are not highlighted.</source>
          <target state="translated">被移动的线条不会被高亮显示。</target>
        </trans-unit>
        <trans-unit id="e5cbd47a10df638d21a9258d79ed6bd371f01027" translate="yes" xml:space="preserve">
          <source>Moved lines of code are colored differently. It can be changed by the &lt;code&gt;diff.colorMoved&lt;/code&gt; configuration setting. The &amp;lt;mode&amp;gt; defaults to &lt;code&gt;no&lt;/code&gt; if the option is not given and to &lt;code&gt;zebra&lt;/code&gt; if the option with no mode is given. The mode must be one of:</source>
          <target state="translated">移动的代码行的颜色不同。可以通过 &lt;code&gt;diff.colorMoved&lt;/code&gt; 配置设置进行更改。如果没有给出选项，&amp;lt;mode&amp;gt;默认为 &lt;code&gt;no&lt;/code&gt; ,如果没有给出选项，则默认为 &lt;code&gt;zebra&lt;/code&gt; 。该模式必须是以下之一：</target>
        </trans-unit>
        <trans-unit id="b99084289befcccb3b6f25bb5a902159aaa2283b" translate="yes" xml:space="preserve">
          <source>Moved lines of code are colored differently. The &amp;lt;mode&amp;gt; defaults to &lt;code&gt;no&lt;/code&gt; if the option is not given and to &lt;code&gt;zebra&lt;/code&gt; if the option with no mode is given. The mode must be one of:</source>
          <target state="translated">移动的代码行的颜色不同。如果没有给出选项，&amp;lt;mode&amp;gt;默认为 &lt;code&gt;no&lt;/code&gt; ,如果没有给出选项，则默认为 &lt;code&gt;zebra&lt;/code&gt; 。该模式必须是以下之一：</target>
        </trans-unit>
        <trans-unit id="b9c1e9c13eb039f68657e5a15bbd12085ba143c2" translate="yes" xml:space="preserve">
          <source>Moving a submodule using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will update the gitfile and core.worktree setting to make the submodule work in the new location. It also will attempt to update the submodule.&amp;lt;name&amp;gt;.path setting in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file and stage that file (unless -n is used).</source>
          <target state="translated">使用gitfile移动子模块（这意味着它们已使用1.7.8或更高版本的Git版本克隆）将更新gitfile和core.worktree设置，以使子模块在新位置工作。它还将尝试更新&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;文件中的submodule。&amp;lt;name&amp;gt; .path设置并暂存该文件（除非使用-n）。</target>
        </trans-unit>
        <trans-unit id="64f4589d8b3cd6346365a117e7caa3c7d877c770" translate="yes" xml:space="preserve">
          <source>Mua-specific hints</source>
          <target state="translated">Mua专用提示</target>
        </trans-unit>
        <trans-unit id="c811c6583f834ffbc46d39586b81b1cb3e49b3e5" translate="yes" xml:space="preserve">
          <source>Multi-pack-index (midx) files have the following format:</source>
          <target state="translated">多包索引(midx)文件的格式如下:</target>
        </trans-unit>
        <trans-unit id="53148ea4bd03c54715064a8f67e0cc8cc140f85c" translate="yes" xml:space="preserve">
          <source>Multiple --notes options can be combined to control which notes are being displayed. Examples: &quot;--notes=foo&quot; will show only notes from &quot;refs/notes/foo&quot;; &quot;--notes=foo --notes&quot; will show both notes from &quot;refs/notes/foo&quot; and from the default notes ref(s).</source>
          <target state="translated">可以结合多个---笔记选项来控制显示哪些笔记。例如:&quot;--notes=foo &quot;将只显示 &quot;refs/notes/foo &quot;的笔记;&quot;--notes=foo --notes &quot;将只显示 &quot;refs/notes/foo &quot;的笔记。&quot;--notes=foo &quot;将只显示 &quot;refs/notes/foo &quot;中的笔记;&quot;--notes=foo --notes &quot;将同时显示 &quot;refs/notes/foo &quot;中的笔记和默认的笔记参考资料。</target>
        </trans-unit>
        <trans-unit id="63667e9cd419f9751274dd2f16bda1512b373262" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;--filter=&lt;/code&gt; flags can be specified to combine filters. Only objects which are accepted by every filter are included.</source>
          <target state="translated">可以指定多个 &lt;code&gt;--filter=&lt;/code&gt; 标志来组合过滤器。仅包括每个过滤器都接受的对象。</target>
        </trans-unit>
        <trans-unit id="dc96f8ef1ccc109ff4dae28503fa1d96c62fb1de" translate="yes" xml:space="preserve">
          <source>Multiple checkout in general is still experimental, and the support for submodules is incomplete. It is NOT recommended to make multiple checkouts of a superproject.</source>
          <target state="translated">多重签出一般来说还是实验性的,对子模块的支持还不完整。不建议对一个超级项目进行多次签出。</target>
        </trans-unit>
        <trans-unit id="5a07b93df04fb253e2e899a192e36f3454a882cd" translate="yes" xml:space="preserve">
          <source>Multiple fetch, branches, and tags keys are supported:</source>
          <target state="translated">支持多个取值、分支和标签键。</target>
        </trans-unit>
        <trans-unit id="b46275ca6ba0af124488d22d1e877279bfe2e6c0" translate="yes" xml:space="preserve">
          <source>Multiple lines can be added to an option by using the &lt;code&gt;--add&lt;/code&gt; option. If you want to update or unset an option which can occur on multiple lines, a POSIX regexp &lt;code&gt;value_regex&lt;/code&gt; needs to be given. Only the existing values that match the regexp are updated or unset. If you want to handle the lines that do &lt;strong&gt;not&lt;/strong&gt; match the regex, just prepend a single exclamation mark in front (see also &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt;).</source>
          <target state="translated">可以使用 &lt;code&gt;--add&lt;/code&gt; 选项将多行添加到一个选项。如果要更新或取消设置可能在多行上出现的选项，则需要提供POSIX regexp &lt;code&gt;value_regex&lt;/code&gt; 。仅与regexp匹配的现有值会被更新或未设置。如果要处理与正则表达式&lt;strong&gt;不&lt;/strong&gt;匹配的行，只需在前面加上一个感叹号即可（另请参见&lt;a href=&quot;#EXAMPLES&quot;&gt;示例&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="77c43675935243a813626f8da7cb046544167112" translate="yes" xml:space="preserve">
          <source>Multiple tags on the same revision are not imported.</source>
          <target state="translated">同一版本上的多个标签不会被导入。</target>
        </trans-unit>
        <trans-unit id="f2beb5df6d3d8f2a372e3411ba76c2a81700ed4b" translate="yes" xml:space="preserve">
          <source>Multiple values may be given to the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable. Their corresponding programs will be tried in the order listed in the configuration file.</source>
          <target state="translated">可以为 &lt;code&gt;man.viewer&lt;/code&gt; 配置变量提供多个值。将按照配置文件中列出的顺序尝试使用它们相应的程序。</target>
        </trans-unit>
        <trans-unit id="ee6ae3f9558f190018d900b972ec0dd86c3ef0ee" translate="yes" xml:space="preserve">
          <source>Munging the diff output</source>
          <target state="translated">芒格差分输出</target>
        </trans-unit>
        <trans-unit id="31284f7dc1d9489b6ba33462518d05bce29455ee" translate="yes" xml:space="preserve">
          <source>Must be a blob id</source>
          <target state="translated">一定是个blob id</target>
        </trans-unit>
        <trans-unit id="bab4c6d734b3b13c2268e7fc81c79c9b99eef1dd" translate="yes" xml:space="preserve">
          <source>NORMAL Format</source>
          <target state="translated">正常格式</target>
        </trans-unit>
        <trans-unit id="4b5d099fcd6efcc01a4251de7ab2ddb7c47dd96b" translate="yes" xml:space="preserve">
          <source>NOTE! &lt;code&gt;git checkout-index&lt;/code&gt; normally refuses to overwrite old files, so if you have an old version of the tree already checked out, you will need to use the &lt;code&gt;-f&lt;/code&gt; flag ('before' the &lt;code&gt;-a&lt;/code&gt; flag or the filename) to 'force' the checkout.</source>
          <target state="translated">注意！ &lt;code&gt;git checkout-index&lt;/code&gt; 通常拒绝覆盖旧文件，因此，如果您已经检出了旧版本的树，则需要使用 &lt;code&gt;-f&lt;/code&gt; 标志（在 &lt;code&gt;-a&lt;/code&gt; 标志或文件名之前）&amp;ldquo;强制&amp;rdquo;结帐。</target>
        </trans-unit>
        <trans-unit id="1264e842b1d5e884b1bcd9c56e546555c80966fe" translate="yes" xml:space="preserve">
          <source>NOTE! A &lt;code&gt;--remove&lt;/code&gt; flag does 'not' mean that subsequent filenames will necessarily be removed: if the files still exist in your directory structure, the index will be updated with their new status, not removed. The only thing &lt;code&gt;--remove&lt;/code&gt; means is that update-index will be considering a removed file to be a valid thing, and if the file really does not exist any more, it will update the index accordingly.</source>
          <target state="translated">注意！一个 &lt;code&gt;--remove&lt;/code&gt; 标志是&amp;ldquo;不&amp;rdquo;意味着后续的文件名一定会被删除：如果文件仍然在你的目录结构中存在该指数将与他们的新身份，不会被删除更新。 &lt;code&gt;--remove&lt;/code&gt; 唯一的意思是，update-index将认为已删除的文件是有效的东西，如果该文件确实不存在，它将相应地更新索引。</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="cab1b18ac6c645752b07db74b58a821d43db7033" translate="yes" xml:space="preserve">
          <source>Name for the new branch.</source>
          <target state="translated">新分支机构的名称:</target>
        </trans-unit>
        <trans-unit id="ae3aefe579fe0e7749a842bc31610ab7a07dfe4c" translate="yes" xml:space="preserve">
          <source>Name of a HTML file which, if it exists, is included on the gitweb projects overview page (&quot;projects_list&quot; view). Relative to the directory containing the gitweb.cgi script. Default value can be adjusted during build time using &lt;code&gt;GITWEB_HOMETEXT&lt;/code&gt; variable. By default set to &lt;code&gt;indextext.html&lt;/code&gt;.</source>
          <target state="translated">HTML文件的名称（如果存在）包含在gitweb项目概述页面（&amp;ldquo; projects_list&amp;rdquo;视图）中。相对于包含gitweb.cgi脚本的目录。可以在构建期间使用 &lt;code&gt;GITWEB_HOMETEXT&lt;/code&gt; 变量调整默认值。默认情况下设置为 &lt;code&gt;indextext.html&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b26ce2bab88403572eb261078ddb7db93d3d704e" translate="yes" xml:space="preserve">
          <source>Name of a file with HTML to be included at the bottom of each page. Relative to the directory containing the &lt;code&gt;gitweb.cgi&lt;/code&gt; script. Can be set using &lt;code&gt;GITWEB_SITE_FOOTER&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">每页底部包含HTML的文件名。相对于包含 &lt;code&gt;gitweb.cgi&lt;/code&gt; 脚本的目录。可以在构建时使用 &lt;code&gt;GITWEB_SITE_FOOTER&lt;/code&gt; 进行设置。无默认值。</target>
        </trans-unit>
        <trans-unit id="cb37057e9d095a173db9c241ef8419b86a202d02" translate="yes" xml:space="preserve">
          <source>Name of a file with HTML to be included at the top of each page. Relative to the directory containing the &lt;code&gt;gitweb.cgi&lt;/code&gt; script. Can be set using &lt;code&gt;GITWEB_SITE_HEADER&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">每页顶部包含HTML的文件名。相对于包含 &lt;code&gt;gitweb.cgi&lt;/code&gt; 脚本的目录。可以在构建时使用 &lt;code&gt;GITWEB_SITE_HEADER&lt;/code&gt; 进行设置。无默认值。</target>
        </trans-unit>
        <trans-unit id="389075bf1328d95e30f257d38d278dd3a0c94121" translate="yes" xml:space="preserve">
          <source>Name of a plain text file listing projects, or a name of directory to be scanned for projects.</source>
          <target state="translated">列出项目的纯文本文件的名称,或要扫描项目的目录名称。</target>
        </trans-unit>
        <trans-unit id="c0afa4635407444ed041e335278cc30cd2a11b14" translate="yes" xml:space="preserve">
          <source>Name of the SSL backend to use (e.g. &quot;openssl&quot; or &quot;schannel&quot;). This option is ignored if cURL lacks support for choosing the SSL backend at runtime.</source>
          <target state="translated">要使用的SSL后端名称(例如 &quot;openssl &quot;或 &quot;schannel&quot;)。如果cURL不支持在运行时选择SSL后端,那么这个选项将被忽略。</target>
        </trans-unit>
        <trans-unit id="4d338fcbbcef71a5bde9a77e37abcbca835f1d4a" translate="yes" xml:space="preserve">
          <source>Name of the user running &lt;code&gt;git-cvsserver&lt;/code&gt;. If no name can be determined, the numeric uid is used.</source>
          <target state="translated">运行 &lt;code&gt;git-cvsserver&lt;/code&gt; 的用户名。如果无法确定名称，则使用数字uid。</target>
        </trans-unit>
        <trans-unit id="33a3a9f4baab999f10555d77c61fc17ad7a2e690" translate="yes" xml:space="preserve">
          <source>Name of your site or organization, to appear in page titles. Set it to something descriptive for clearer bookmarks etc. If this variable is not set or is, then gitweb uses the value of the &lt;code&gt;SERVER_NAME&lt;/code&gt;&lt;code&gt;CGI&lt;/code&gt; environment variable, setting site name to &quot;$SERVER_NAME Git&quot;, or &quot;Untitled Git&quot; if this variable is not set (e.g. if running gitweb as standalone script).</source>
          <target state="translated">您的网站或组织的名称，以显示在页面标题中。将其设置为描述性更强的书签等内容。如果未设置或未设置此变量，则gitweb使用 &lt;code&gt;SERVER_NAME&lt;/code&gt; &lt;code&gt;CGI&lt;/code&gt; 环境变量的值，将站点名称设置为&amp;ldquo; $ SERVER_NAME Git&amp;rdquo;，如果此变量为，则设置为&amp;ldquo; Untitled Git&amp;rdquo;未设置（例如，如果将gitweb作为独立脚本运行）。</target>
        </trans-unit>
        <trans-unit id="ac84f0f88b7824faf06c4b53397972bcd09b01be" translate="yes" xml:space="preserve">
          <source>Name output in &lt;code&gt;[PATCH n/m]&lt;/code&gt; format, even with a single patch.</source>
          <target state="translated">即使使用单个音色，也以 &lt;code&gt;[PATCH n/m]&lt;/code&gt; 格式输出名称。</target>
        </trans-unit>
        <trans-unit id="ffd008dca3705155e76303827e2a4d3059068c9a" translate="yes" xml:space="preserve">
          <source>Name output in &lt;code&gt;[PATCH]&lt;/code&gt; format.</source>
          <target state="translated">名称以 &lt;code&gt;[PATCH]&lt;/code&gt; 格式输出。</target>
        </trans-unit>
        <trans-unit id="fe45d9f50e3991235a5aaf79d20ba4e50638c193" translate="yes" xml:space="preserve">
          <source>Named file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 命名文件</target>
        </trans-unit>
        <trans-unit id="e694d096f60594b306ed977a1cb3bf7e40731642" translate="yes" xml:space="preserve">
          <source>Named file in &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 命名文件</target>
        </trans-unit>
        <trans-unit id="4d0059ee6bf7ca65460797daae6395c800b562c5" translate="yes" xml:space="preserve">
          <source>Named pointers called refs mark interesting points in history. A ref may contain the SHA-1 name of an object or the name of another ref. Refs with names beginning &lt;code&gt;ref/head/&lt;/code&gt; contain the SHA-1 name of the most recent commit (or &quot;head&quot;) of a branch under development. SHA-1 names of tags of interest are stored under &lt;code&gt;ref/tags/&lt;/code&gt;. A special ref named &lt;code&gt;HEAD&lt;/code&gt; contains the name of the currently checked-out branch.</source>
          <target state="translated">名为refs的命名指针标记了历史上的有趣点。一个引用可能包含一个对象的SHA-1名称或另一个引用的名称。名称以 &lt;code&gt;ref/head/&lt;/code&gt; 开头的引用包含正在开发的分支的最新提交（或&amp;ldquo; head&amp;rdquo;）的SHA-1名称。感兴趣的标签的SHA-1名称存储在 &lt;code&gt;ref/tags/&lt;/code&gt; 。名为 &lt;code&gt;HEAD&lt;/code&gt; 的特殊引用包含当前已签出分支的名称。</target>
        </trans-unit>
        <trans-unit id="afc8b12ea961269025f67734b3112ac3163fa044" translate="yes" xml:space="preserve">
          <source>Named remote in configuration file</source>
          <target state="translated">在配置文件中命名为远程</target>
        </trans-unit>
        <trans-unit id="60da66dd4d339a94ae12e8c7a620ab333cdfa554" translate="yes" xml:space="preserve">
          <source>Names a low-level merge driver to be used when performing an internal merge between common ancestors. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">命名在公共祖先之间执行内部合并时要使用的低级合并驱动程序。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7238264e2238da432cea4cee3e4e4ec456281760" translate="yes" xml:space="preserve">
          <source>Naming branches, tags, and other references</source>
          <target state="translated">命名分支、标签和其他引用</target>
        </trans-unit>
        <trans-unit id="a8a795a40591e9038f52c089f34245ee06ab71bc" translate="yes" xml:space="preserve">
          <source>Naming commits</source>
          <target state="translated">命名承诺</target>
        </trans-unit>
        <trans-unit id="7b635b48de06412b114cd8e91f1912aac5470b03" translate="yes" xml:space="preserve">
          <source>Nearly proper rewriting of tag objects is supported. If the tag has a message attached, a new tag object will be created with the same message, author, and timestamp. If the tag has a signature attached, the signature will be stripped. It is by definition impossible to preserve signatures. The reason this is &quot;nearly&quot; proper, is because ideally if the tag did not change (points to the same object, has the same name, etc.) it should retain any signature. That is not the case, signatures will always be removed, buyer beware. There is also no support for changing the author or timestamp (or the tag message for that matter). Tags which point to other tags will be rewritten to point to the underlying commit.</source>
          <target state="translated">支持对标签对象进行近乎正确的重写,如果标签有消息,则会创建一个具有相同消息、作者和时间戳的新标签对象。如果标签附有消息,则会创建一个具有相同消息、作者和时间戳的新标签对象。如果标签附加了签名,则签名将被删除。根据定义,保存签名是不可能的。这样做 &quot;几乎 &quot;是正确的,因为在理想情况下,如果标签没有改变(指向相同的对象,具有相同的名称等),它应该保留任何签名。事实并非如此,签名总是会被删除,买家要小心。也不支持更改作者或时间戳(或标签信息)。指向其他标签的标签将被重写为指向底层提交。</target>
        </trans-unit>
        <trans-unit id="ec8ce921b28e9d3cf6cf20eaf08287c17f378d35" translate="yes" xml:space="preserve">
          <source>Negating options</source>
          <target state="translated">否定选项</target>
        </trans-unit>
        <trans-unit id="781db1e57c260d141571a81cbcc3db723749ad7f" translate="yes" xml:space="preserve">
          <source>Nevertheless, the code at C is broken, because the callers added on the lower line of development have not been converted to the new semantics introduced on the upper line of development. So if all you know is that D is bad, that Z is good, and that &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; identifies C as the culprit, how will you figure out that the problem is due to this change in semantics?</source>
          <target state="translated">但是，C处的代码已损坏，因为在开发的下一行添加的调用者尚未转换为在开发的上一行引入的新语义。因此，如果您仅知道D是不好的，Z是好的，并且&lt;a href=&quot;git-bisect&quot;&gt;git-bisect [1]&lt;/a&gt;将C认定为罪魁祸首，那么您如何确定问题是由于语义上的这种变化引起的？</target>
        </trans-unit>
        <trans-unit id="a6160e254f396c410b853d5ee2bc722e35ccb61c" translate="yes" xml:space="preserve">
          <source>Nevertheless, this is a common practice for people that need a simple way to publish a work-in-progress patch series, and it is an acceptable compromise as long as you warn other developers that this is how you intend to manage the branch.</source>
          <target state="translated">尽管如此,这对于需要简单的方式来发布工作中的补丁系列的人来说,是一种常见的做法,只要你警告其他开发者这是你打算管理分支的方式,这就是一种可以接受的妥协。</target>
        </trans-unit>
        <trans-unit id="208a508aabbf19798034826f77ed481ec28e90cc" translate="yes" xml:space="preserve">
          <source>New features:</source>
          <target state="translated">新特点:</target>
        </trans-unit>
        <trans-unit id="c191eda851b2a021b1ece3943d51bb10c7c6e4eb" translate="yes" xml:space="preserve">
          <source>New marks are created automatically. Existing marks can be moved to another object simply by reusing the same &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; in another &lt;code&gt;mark&lt;/code&gt; command.</source>
          <target state="translated">新标记将自动创建。只需在另一个 &lt;code&gt;mark&lt;/code&gt; 命令中重用相同的 &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; ，就可以将现有标记移动到另一个对象。</target>
        </trans-unit>
        <trans-unit id="34f293962e034aa3adab30d6ce7bb006c129576e" translate="yes" xml:space="preserve">
          <source>New objects written by fast-import are not available immediately. Most fast-import commands have no visible effect until the next checkpoint (or completion). The frontend can send commands to fill fast-import&amp;rsquo;s input pipe without worrying about how quickly they will take effect, which improves performance by simplifying scheduling.</source>
          <target state="translated">快速导入写入的新对象无法立即使用。大多数快速导入命令在下一个检查点（或完成）之前没有可见效果。前端可以发送命令来填充快速导入的输入管道，而不必担心它们生效的速度，这可以通过简化调度来提高性能。</target>
        </trans-unit>
        <trans-unit id="bd5d84635e8045ac3e97cdc31b8e7c57fb2006ba" translate="yes" xml:space="preserve">
          <source>New remote-tracking branches will be stored under the shorthand name that you gave &lt;code&gt;git remote add&lt;/code&gt;, in this case &lt;code&gt;staging&lt;/code&gt;:</source>
          <target state="translated">新的远程跟踪分支将以您为 &lt;code&gt;git remote add&lt;/code&gt; 提供的简写名称存储，在这种情况下为 &lt;code&gt;staging&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="408210d4e2e7bc9a95a98e6b1bf8a3bd1ff14459" translate="yes" xml:space="preserve">
          <source>New users are encouraged to use &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; instead. The &lt;code&gt;whatchanged&lt;/code&gt; command is essentially the same as &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; but defaults to show the raw format diff output and to skip merges.</source>
          <target state="translated">鼓励新用户改用&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;。的 &lt;code&gt;whatchanged&lt;/code&gt; 命令是基本上相同&lt;a href=&quot;git-log&quot;&gt;的git日志[1]&lt;/a&gt;但缺省为显示原始格式diff的输出和跳过合并。</target>
        </trans-unit>
        <trans-unit id="04e09d741912def77b41c31c7fd7bada0af8f8f2" translate="yes" xml:space="preserve">
          <source>Newer &lt;code&gt;git diff&lt;/code&gt; output has embedded &lt;code&gt;index information&lt;/code&gt; for each blob to help identify the original version that the patch applies to. When this flag is given, and if the original versions of the blobs are available locally, builds a temporary index containing those blobs.</source>
          <target state="translated">较新的 &lt;code&gt;git diff&lt;/code&gt; 输出为每个Blob 嵌入了 &lt;code&gt;index information&lt;/code&gt; ，以帮助标识补丁程序适用的原始版本。给定此标志时，如果Blob的原始版本在本地可用，则构建一个包含这些Blob的临时索引。</target>
        </trans-unit>
        <trans-unit id="7f94af506f4cd517718453425d685ea35e84d4c7" translate="yes" xml:space="preserve">
          <source>Newly created objects are initially created in a file named after the object&amp;rsquo;s SHA-1 hash (stored in &lt;code&gt;.git/objects&lt;/code&gt;).</source>
          <target state="translated">新创建的对象最初是在以对象的SHA-1哈希命名的文件中创建的（存储在 &lt;code&gt;.git/objects&lt;/code&gt; 中）。</target>
        </trans-unit>
        <trans-unit id="5efdf7f0d1fca004c74269609acfa25723d86160" translate="yes" xml:space="preserve">
          <source>Next step: get familiar with the object naming. Read &lt;a href=&quot;#naming-commits&quot;&gt;Naming commits&lt;/a&gt;. There are quite a few ways to name an object (and not only revisions!). All of these are handled in &lt;code&gt;sha1_name.c&lt;/code&gt;. Just have a quick look at the function &lt;code&gt;get_sha1()&lt;/code&gt;. A lot of the special handling is done by functions like &lt;code&gt;get_sha1_basic()&lt;/code&gt; or the likes.</source>
          <target state="translated">下一步：熟悉对象命名。阅读&lt;a href=&quot;#naming-commits&quot;&gt;命名提交&lt;/a&gt;。有许多种命名对象的方法（不仅限于修订版！）。所有这些都在 &lt;code&gt;sha1_name.c&lt;/code&gt; 中处理。快速浏览一下函数 &lt;code&gt;get_sha1()&lt;/code&gt; 。许多特殊处理是由诸如 &lt;code&gt;get_sha1_basic()&lt;/code&gt; 之类的函数完成的。</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">今后的步骤</target>
        </trans-unit>
        <trans-unit id="817a91571b93a177740989ad9e63a1941cffb303" translate="yes" xml:space="preserve">
          <source>Next time, after seeing the same conflicted automerge, running &lt;code&gt;git rerere&lt;/code&gt; will perform a three-way merge between the earlier conflicted automerge, the earlier manual resolution, and the current conflicted automerge. If this three-way merge resolves cleanly, the result is written out to your working tree file, so you do not have to manually resolve it. Note that &lt;code&gt;git rerere&lt;/code&gt; leaves the index file alone, so you still need to do the final sanity checks with &lt;code&gt;git diff&lt;/code&gt; (or &lt;code&gt;git diff -c&lt;/code&gt;) and &lt;code&gt;git add&lt;/code&gt; when you are satisfied.</source>
          <target state="translated">下次，在看到相同的冲突自动合并后，运行 &lt;code&gt;git rerere&lt;/code&gt; 将在早期冲突的自动合并，早期手动解析和当前冲突的自动合并之间执行三向合并。如果此三向合并能够完全解决，则结果将写到您的工作树文件中，因此您不必手动解决它。请注意， &lt;code&gt;git rerere&lt;/code&gt; 仅保留索引文件，因此，当您满意时，仍然需要使用 &lt;code&gt;git diff&lt;/code&gt; （或 &lt;code&gt;git diff -c&lt;/code&gt; ）和 &lt;code&gt;git add&lt;/code&gt; 进行最终的健全性检查。</target>
        </trans-unit>
        <trans-unit id="74ccc5b41472ca3ff8486dd211ddfe0cae9246c3" translate="yes" xml:space="preserve">
          <source>Next, commit the changes stored in the index. The &lt;code&gt;-c&lt;/code&gt; option specifies to pre-populate the commit message from the original message that you started with in the first commit. This is helpful to avoid retyping it. The &lt;code&gt;HEAD@{1}&lt;/code&gt; is a special notation for the commit that &lt;code&gt;HEAD&lt;/code&gt; used to be at prior to the original reset commit (1 change ago). See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; for more details. You may also use any other valid commit reference.</source>
          <target state="translated">接下来，提交存储在索引中的更改。该 &lt;code&gt;-c&lt;/code&gt; 选项指定要预填充从你开始在第一次提交的原始邮件提交信息。这有助于避免重新键入。的 &lt;code&gt;HEAD@{1}&lt;/code&gt; 是一个特殊的符号为提交该 &lt;code&gt;HEAD&lt;/code&gt; 曾经是在之前的原始复位提交（1个改变前）。有关更多详细信息，请参见&lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt;。您还可以使用任何其他有效的提交引用。</target>
        </trans-unit>
        <trans-unit id="d481150e66b12915d203137377672c89781fe045" translate="yes" xml:space="preserve">
          <source>Next, copy &lt;code&gt;proj.git&lt;/code&gt; to the server where you plan to host the public repository. You can use scp, rsync, or whatever is most convenient.</source>
          <target state="translated">接下来，将 &lt;code&gt;proj.git&lt;/code&gt; 复制到计划承载公共存储库的服务器。您可以使用scp，rsync或任何最方便的方法。</target>
        </trans-unit>
        <trans-unit id="04e0b9feb1c4a494995ed09ad261d2d4e9ce11c5" translate="yes" xml:space="preserve">
          <source>Next, give every team member read/write access to this repository. One easy way to do this is to give all the team members ssh access to the machine where the repository is hosted. If you don&amp;rsquo;t want to give them a full shell on the machine, there is a restricted shell which only allows users to do Git pushes and pulls; see &lt;a href=&quot;git-shell&quot;&gt;git-shell[1]&lt;/a&gt;.</source>
          <target state="translated">接下来，授予每个团队成员对该存储库的读/写访问权限。一种简单的方法是使所有团队成员ssh都可以访问托管存储库的计算机。如果您不想在机器上给他们提供完整的外壳，则有一个受限制的外壳，该外壳仅允许用户执行Git推拉操作。参见&lt;a href=&quot;git-shell&quot;&gt;git-shell [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="28d55d870524553fca2220c18e5b9bb0de3dcbdb" translate="yes" xml:space="preserve">
          <source>Next, tell Git to take a snapshot of the contents of all files under the current directory (note the &lt;code&gt;.&lt;/code&gt;), with &lt;code&gt;git add&lt;/code&gt;:</source>
          <target state="translated">接下来，让Git采取的所有文件的内容的快照在当前目录下（注意 &lt;code&gt;.&lt;/code&gt; ），用 &lt;code&gt;git add&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="596419ac8ea3393898cb55dbbde5c3613a819bd1" translate="yes" xml:space="preserve">
          <source>Next, we interactively select diff hunks to add using the &lt;code&gt;git add -p&lt;/code&gt; facility. This will ask you about each diff hunk in sequence and you can use simple commands such as &quot;yes, include this&quot;, &quot;No don&amp;rsquo;t include this&quot; or even the very powerful &quot;edit&quot; facility.</source>
          <target state="translated">接下来，我们使用 &lt;code&gt;git add -p&lt;/code&gt; 工具以交互方式选择diff块。这将按顺序询问您每个差异块，您可以使用简单的命令，例如&amp;ldquo;是，包含此&amp;rdquo;，&amp;ldquo;否不包含此&amp;rdquo;或什至功能非常强大的&amp;ldquo;编辑&amp;rdquo;功能。</target>
        </trans-unit>
        <trans-unit id="8951da293ad0f99492d7f4956f721a58ac3b7ff1" translate="yes" xml:space="preserve">
          <source>No checkout of HEAD is performed after the clone is complete.</source>
          <target state="translated">克隆完成后不对HEAD进行检查。</target>
        </trans-unit>
        <trans-unit id="cfeba19b6e040607769791cbfbefd83c894b180c" translate="yes" xml:space="preserve">
          <source>No modifications to submodules are ignored, all of committed differences, and modifications to tracked and untracked files are shown. This is the default option.</source>
          <target state="translated">不忽略对子模块的修改,所有已提交的差异以及对已跟踪和未跟踪文件的修改都会被显示。这是默认选项。</target>
        </trans-unit>
        <trans-unit id="e2a67085604f2eb59fb72fa11fe30ca6d6e00a34" translate="yes" xml:space="preserve">
          <source>No other changes are made. In particular, the local modifications you had before you started merge will stay the same and the index entries for them stay as they were, i.e. matching &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">没有其他更改。特别是，在开始合并之前进行的本地修改将保持不变，并且它们的索引条目保持不变，即匹配 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c967d0b967e1e36091e8958a5454d9ea9951dded" translate="yes" xml:space="preserve">
          <source>No other modifications are made.</source>
          <target state="translated">不做其他修改。</target>
        </trans-unit>
        <trans-unit id="57658df76cf3f4fecaffea0a60cae0068e21e278" translate="yes" xml:space="preserve">
          <source>No patch introduces a regression: after applying any initial part of the series, the resulting project still compiles and works, and has no bugs that it didn&amp;rsquo;t have before.</source>
          <target state="translated">没有补丁会导致回归：应用了该系列的任何初始部分之后，生成的项目仍然可以编译和运行，并且没有以前没有的错误。</target>
        </trans-unit>
        <trans-unit id="0d39633312554b0ea8cb734d680c4698c57a7afd" translate="yes" xml:space="preserve">
          <source>No pattern matches the path, and nothing says if the path has or does not have the attribute, the attribute for the path is said to be Unspecified.</source>
          <target state="translated">没有模式与路径匹配,也没有说路径有无属性,说路径的属性是Unspecified。</target>
        </trans-unit>
        <trans-unit id="c90ed1cbdf989952fffa921b682ee1beb354558a" translate="yes" xml:space="preserve">
          <source>No special setup is needed for SSH access, other than having Git tools in the PATH. If you have clients that do not accept the CVS_SERVER environment variable, you can rename &lt;code&gt;git-cvsserver&lt;/code&gt; to &lt;code&gt;cvs&lt;/code&gt;.</source>
          <target state="translated">除了PATH中具有Git工具外，不需要其他特殊设置即可进行SSH访问。如果您的客户端不接受CVS_SERVER环境变量，则可以将 &lt;code&gt;git-cvsserver&lt;/code&gt; 重命名为 &lt;code&gt;cvs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5febeaff9fb6579d7fb9744e50b3994bde6d8e3" translate="yes" xml:space="preserve">
          <source>Non-ascii filenames can be silently removed despite being in a desired directory. Keeping only wanted paths is often done using pipelines like &lt;code&gt;git ls-files | grep -v ^WANTED_DIR/ | xargs git rm&lt;/code&gt;. ls-files will only quote filenames if needed, so folks may not notice that one of the files didn&amp;rsquo;t match the regex (at least not until it&amp;rsquo;s much too late). Yes, someone who knows about core.quotePath can avoid this (unless they have other special characters like \t, \n, or &quot;), and people who use ls-files -z with something other than grep can avoid this, but that doesn&amp;rsquo;t mean they will.</source>
          <target state="translated">即使位于所需目录中，非ascii文件名也可以静默删除。通常只使用 &lt;code&gt;git ls-files | grep -v ^WANTED_DIR/ | xargs git rm&lt;/code&gt; 等管道来保留所需路径。 grep -v ^ WANTED_DIR / | xargs git rm。 ls文件仅在需要时才引用文件名，因此人们可能不会注意到其中一个文件与正则表达式不匹配（至少直到太晚才匹配）。是的，知道core.quotePath的人可以避免这种情况（除非他们有其他特殊字符，例如\ t，\ n或&amp;ldquo;），并且使用ls-files -z和grep以外的东西的人可以避免这种情况，但是那并不意味着他们会。</target>
        </trans-unit>
        <trans-unit id="e2858812ab58a3c85b7437528709a46037dcfba6" translate="yes" xml:space="preserve">
          <source>Non-cached mode</source>
          <target state="translated">非缓存模式</target>
        </trans-unit>
        <trans-unit id="28592521357265f4a182551c4308e7cea911b93e" translate="yes" xml:space="preserve">
          <source>Non-empty context lines that have one extra whitespace at the beginning.</source>
          <target state="translated">非空的上下文行,在开头有一个额外的空白。</target>
        </trans-unit>
        <trans-unit id="54b4652d3bd254c89ec712af1b81619180dc7f11" translate="yes" xml:space="preserve">
          <source>None of the provided paths are ignored.</source>
          <target state="translated">提供的路径都不会被忽略。</target>
        </trans-unit>
        <trans-unit id="53d641d85a09ede95cefeac02aadaca1a7fcd396" translate="yes" xml:space="preserve">
          <source>Normalize &lt;code&gt;refname&lt;/code&gt; by removing any leading slash (&lt;code&gt;/&lt;/code&gt;) characters and collapsing runs of adjacent slashes between name components into a single slash. If the normalized refname is valid then print it to standard output and exit with a status of 0, otherwise exit with a non-zero status. (&lt;code&gt;--print&lt;/code&gt; is a deprecated way to spell &lt;code&gt;--normalize&lt;/code&gt;.)</source>
          <target state="translated">通过删除任何前导斜杠（ &lt;code&gt;/&lt;/code&gt; ）字符并将名称组件之间的相邻斜杠折叠成单个斜杠来规范化 &lt;code&gt;refname&lt;/code&gt; 。如果标准化的refname有效，则将其打印到标准输出并以0状态退出，否则以非零状态退出。（ &lt;code&gt;--print&lt;/code&gt; 是拼写 &lt;code&gt;--normalize&lt;/code&gt; 的不赞成使用的方法。）</target>
        </trans-unit>
        <trans-unit id="cd7a46a34b030b4fa7a1f4c298bb470454f5bdc6" translate="yes" xml:space="preserve">
          <source>Normally &lt;code&gt;git write-tree&lt;/code&gt; ensures that the objects referenced by the directory exist in the object database. This option disables this check.</source>
          <target state="translated">通常， &lt;code&gt;git write-tree&lt;/code&gt; 确保目录引用的对象存在于对象数据库中。此选项禁用此检查。</target>
        </trans-unit>
        <trans-unit id="88fcf17b3fc3a47614adb1a8f9a3b0161d3a2185" translate="yes" xml:space="preserve">
          <source>Normally a &quot;commit&quot; has one parent: the previous state of the tree before a certain change was made. However, sometimes it can have two or more parent commits, in which case we call it a &quot;merge&quot;, due to the fact that such a commit brings together (&quot;merges&quot;) two or more previous states represented by other commits.</source>
          <target state="translated">通常,一个 &quot;提交 &quot;只有一个父提交:在做某项修改之前,树的前一个状态。然而,有时它可能有两个或更多的父提交,在这种情况下,我们称它为 &quot;合并&quot;,因为这种提交将两个或更多由其他提交代表的先前状态合并在一起(&quot;合并&quot;)。</target>
        </trans-unit>
        <trans-unit id="a69474e938cf33a616aeca615fe9997480c7c945" translate="yes" xml:space="preserve">
          <source>Normally a commit would identify a new &quot;HEAD&quot; state, and while Git doesn&amp;rsquo;t care where you save the note about that state, in practice we tend to just write the result to the file that is pointed at by &lt;code&gt;.git/HEAD&lt;/code&gt;, so that we can always see what the last committed state was.</source>
          <target state="translated">通常，一次提交会标识一个新的&amp;ldquo; HEAD&amp;rdquo;状态，尽管Git不在乎您保存该状态的注释的位置，但实际上，我们倾向于将结果 &lt;code&gt;.git/HEAD&lt;/code&gt; 指向的文件中，这样我们就可以始终看到最后一个提交状态。</target>
        </trans-unit>
        <trans-unit id="de60fcb388acbd1518bd224ad2216b3a990124fa" translate="yes" xml:space="preserve">
          <source>Normally batch output is flushed after each object is output, so that a process can interactively read and write from &lt;code&gt;cat-file&lt;/code&gt;. With this option, the output uses normal stdio buffering; this is much more efficient when invoking &lt;code&gt;--batch-check&lt;/code&gt; on a large number of objects.</source>
          <target state="translated">通常，在输出每个对象之后，将刷新批处理输出，以便进程可以从 &lt;code&gt;cat-file&lt;/code&gt; 交互式读取和写入。使用此选项时，输出使用普通的stdio缓冲。当对大量对象调用 &lt;code&gt;--batch-check&lt;/code&gt; 时，此方法效率更高。</target>
        </trans-unit>
        <trans-unit id="38e091b35be2fc0762233a3d599b506f3b643fb1" translate="yes" xml:space="preserve">
          <source>Normally commits are only added to a project, never taken away or replaced. Git is designed with this assumption, and violating it will cause Git&amp;rsquo;s merge machinery (for example) to do the wrong thing.</source>
          <target state="translated">通常，提交只会添加到项目中，而不会被删除或替换。Git是根据这种假设设计的，违反它会导致Git的合并机器（例如）做错事。</target>
        </trans-unit>
        <trans-unit id="9122c3565585fe79768943dc25f1cf167ffbd58d" translate="yes" xml:space="preserve">
          <source>Normally the &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; stores the name of a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;, and commands that operate on the history HEAD represents operate on the history leading to the tip of the branch the HEAD points at. However, Git also allows you to &lt;a href=&quot;#def_checkout&quot;&gt;check out&lt;/a&gt; an arbitrary &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; that isn&amp;rsquo;t necessarily the tip of any particular branch. The HEAD in such a state is called &quot;detached&quot;.</source>
          <target state="translated">通常，&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;存储&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;的名称，并且在历史记录HEAD上执行的命令在指向HEAD所指向的分支尖端的历史记录上进行操作。但是，Git还允许您&lt;a href=&quot;#def_checkout&quot;&gt;检出&lt;/a&gt;不一定是任何特定分支提示的任意&lt;a href=&quot;#def_commit&quot;&gt;提交&lt;/a&gt;。处于这种状态的HEAD称为&amp;ldquo;分离&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cc5f74671cf296af564ff0627cbd1c153eed7819" translate="yes" xml:space="preserve">
          <source>Normally the branch merged in is the HEAD of the remote repository, but the choice is determined by the branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge options; see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">通常合并到的分支是远程存储库的HEAD，但是选择由分支决定。&amp;lt;name&amp;gt; .remote和branch。&amp;lt;name&amp;gt; .merge选项；有关详细信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f22467859cfedb6f904df5424dcd9afb82c226b1" translate="yes" xml:space="preserve">
          <source>Normally whenever a branch head in a public repository is modified, it is modified to point to a descendant of the commit that it pointed to before. By forcing a push in this situation, you break that convention. (See &lt;a href=&quot;#problems-With-rewriting-history&quot;&gt;Problems with rewriting history&lt;/a&gt;.)</source>
          <target state="translated">通常，只要修改了公共存储库中的分支头，便会对其进行修改以指向它之前指向的提交的后代。通过在这种情况下强行推动，您将打破惯例。（请参阅&lt;a href=&quot;#problems-With-rewriting-history&quot;&gt;重写历史记录中的问题&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="43244e83cbae6a59cf653d315de1a56015589247" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;git rerere&lt;/code&gt; is run without arguments or user-intervention. However, it has several commands that allow it to interact with its working state.</source>
          <target state="translated">通常， &lt;code&gt;git rerere&lt;/code&gt; 是在没有参数或用户干预的情况下运行的。但是，它有几个命令可以使其与其工作状态进行交互。</target>
        </trans-unit>
        <trans-unit id="d7d70adae9e248dcbf5927b7eeba22fdf79a73fb" translate="yes" xml:space="preserve">
          <source>Normally, only files unknown to Git are removed, but if the &lt;code&gt;-x&lt;/code&gt; option is specified, ignored files are also removed. This can, for example, be useful to remove all build products.</source>
          <target state="translated">通常，仅删除Git未知的文件，但是如果指定 &lt;code&gt;-x&lt;/code&gt; 选项，也会删除忽略的文件。例如，这对于删除所有构建产品很有用。</target>
        </trans-unit>
        <trans-unit id="ea1a90319260338e8b5ddefd985427f3690ce910" translate="yes" xml:space="preserve">
          <source>Normally, the &quot;git svn clone&quot; and &quot;git svn rebase&quot; commands attempt to recreate empty directories that are in the Subversion repository. If this option is set to &quot;false&quot;, then empty directories will only be created if the &quot;git svn mkdirs&quot; command is run explicitly. If unset, &lt;code&gt;git svn&lt;/code&gt; assumes this option to be &quot;true&quot;.</source>
          <target state="translated">通常，&amp;ldquo; git svn clone&amp;rdquo;和&amp;ldquo; git svn rebase&amp;rdquo;命令会尝试重新创建Subversion存储库中的空目录。如果此选项设置为&amp;ldquo; false&amp;rdquo;，则只有在显式运行&amp;ldquo; git svn mkdirs&amp;rdquo;命令时，才会创建空目录。如果未设置，则 &lt;code&gt;git svn&lt;/code&gt; 假定此选项为&amp;ldquo; true&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cbab35b86acdc7c387af4e06856d3dc90a27828f" translate="yes" xml:space="preserve">
          <source>Normally, the &quot;name&quot; field contains the canonical name of the command. When a canonical name is not available, one of these special values are used:</source>
          <target state="translated">通常,&quot;name &quot;字段包含命令的规范名称。如果没有正式名称,则使用下列特殊值之一:</target>
        </trans-unit>
        <trans-unit id="a72159c3df537e6c1eeaac201666cb67a55dea2c" translate="yes" xml:space="preserve">
          <source>Normally, the first commit in an SVN branch consists of a copy operation. &lt;code&gt;git svn&lt;/code&gt; will read this commit to get the SVN revision the branch was created from. It will then try to find the Git commit that corresponds to this SVN revision, and use that as the parent of the branch. However, it is possible that there is no suitable Git commit to serve as parent. This will happen, among other reasons, if the SVN branch is a copy of a revision that was not fetched by &lt;code&gt;git svn&lt;/code&gt; (e.g. because it is an old revision that was skipped with &lt;code&gt;--revision&lt;/code&gt;), or if in SVN a directory was copied that is not tracked by &lt;code&gt;git svn&lt;/code&gt; (such as a branch that is not tracked at all, or a subdirectory of a tracked branch). In these cases, &lt;code&gt;git svn&lt;/code&gt; will still create a Git branch, but instead of using an existing Git commit as the parent of the branch, it will read the SVN history of the directory the branch was copied from and create appropriate Git commits. This is indicated by the message &quot;Initializing parent: &amp;lt;branchname&amp;gt;&quot;.</source>
          <target state="translated">通常，SVN分支中的第一次提交由复制操作组成。 &lt;code&gt;git svn&lt;/code&gt; 将读取此提交以获取创建分支的SVN版本。然后它将尝试查找与该SVN修订版相对应的Git提交，并将其用作分支的父级。但是，可能没有合适的Git提交充当父项。除其他原因外，如果SVN分支是 &lt;code&gt;git svn&lt;/code&gt; 未获取的修订的副本（例如，因为它是使用 &lt;code&gt;--revision&lt;/code&gt; 跳过的旧修订），或者在SVN中复制了目录，则会发生这种情况 &lt;code&gt;git svn&lt;/code&gt; 不能跟踪的内容（例如完全不被跟踪的分支或被跟踪的分支的子目录）。在这种情况下， &lt;code&gt;git svn&lt;/code&gt; 仍会创建一个Git分支，但不会使用现有的Git提交作为该分支的父级，而是会读取复制该分支的目录的SVN历史记录并创建适当的Git提交。消息&amp;ldquo;正在初始化父项：&amp;lt;分支名称&amp;gt;&amp;rdquo;指示。</target>
        </trans-unit>
        <trans-unit id="4d54b3aadfbad6c493d83bcb2428d0cb9e46992e" translate="yes" xml:space="preserve">
          <source>Normally, when no &amp;lt;path&amp;gt; is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If any paths are specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions for nested git directories mentioned under &lt;code&gt;--force&lt;/code&gt;) will be removed.</source>
          <target state="translated">通常，如果未指定&amp;lt;path&amp;gt;，则git clean不会递归到未跟踪的目录中，以免删除过多。指定-d使其也递归到此类目录。如果指定了任何路径，则-d不相关；所有与指定路径匹配的未跟踪文件（ &lt;code&gt;--force&lt;/code&gt; 下提到的嵌套git目录除外）将被删除。</target>
        </trans-unit>
        <trans-unit id="429c7c6d611a6b06377c7694b2f456c87ba75047" translate="yes" xml:space="preserve">
          <source>Not all pattern types support patterns containing \0. Git will error out if a given pattern type can&amp;rsquo;t support such a pattern. The &lt;code&gt;--perl-regexp&lt;/code&gt; pattern type when compiled against the PCRE v2 backend has the widest support for these types of patterns.</source>
          <target state="translated">并非所有模式类型都支持包含\ 0的模式。如果给定的模式类型不支持这种模式，Git将会出错。当针对PCRE v2后端编译时，-- &lt;code&gt;--perl-regexp&lt;/code&gt; 模式类型对这些模式类型有最广泛的支持。</target>
        </trans-unit>
        <trans-unit id="fc85aa9ed9f2a57ce72e656178cf6fe66c794d02" translate="yes" xml:space="preserve">
          <source>Not all values are equally unambiguous:</source>
          <target state="translated">并非所有的价值都同样不含糊。</target>
        </trans-unit>
        <trans-unit id="8394b0fb9c23c1116919b0832addc200fe1387df" translate="yes" xml:space="preserve">
          <source>Not to worry. It left the (trivial) conflict in &lt;code&gt;hello&lt;/code&gt; in the same form you should already be well used to if you&amp;rsquo;ve ever used CVS, so let&amp;rsquo;s just open &lt;code&gt;hello&lt;/code&gt; in our editor (whatever that may be), and fix it up somehow. I&amp;rsquo;d suggest just making it so that &lt;code&gt;hello&lt;/code&gt; contains all four lines:</source>
          <target state="translated">不要担心。它以您已经习惯使用CVS的相同形式在 &lt;code&gt;hello&lt;/code&gt; 中留下了（琐碎的）冲突，因此，让我们在编辑器中打开 &lt;code&gt;hello&lt;/code&gt; （无论如何），然后以某种方式进行修复即可。我建议您这样做，以便 &lt;code&gt;hello&lt;/code&gt; 包含所有四行：</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="b7ed8e5f5bf09b0c843d3af582307ddfb588c4c6" translate="yes" xml:space="preserve">
          <source>Note about fast-forwards</source>
          <target state="translated">关于快进的说明</target>
        </trans-unit>
        <trans-unit id="318ccd302e94c5b26153ff4314826ba81af60a67" translate="yes" xml:space="preserve">
          <source>Note about git config --global</source>
          <target state="translated">关于git config --global的说明</target>
        </trans-unit>
        <trans-unit id="a858b9b8c7722185661603839f0881f8c7f88318" translate="yes" xml:space="preserve">
          <source>Note about konqueror</source>
          <target state="translated">征服者注意事项</target>
        </trans-unit>
        <trans-unit id="01b5dd07775875ee6aa9a8a3da76365c637f9b1a" translate="yes" xml:space="preserve">
          <source>Note also that multiple copies of an object may be present in the object database; in this case, it is undefined which copy&amp;rsquo;s size or delta base will be reported.</source>
          <target state="translated">还要注意，对象数据库中可能存在一个对象的多个副本。在这种情况下，将不确定将报告哪个副本的大小或增量基数。</target>
        </trans-unit>
        <trans-unit id="e92cbc9ca374ec932eab116752367c5739918c53" translate="yes" xml:space="preserve">
          <source>Note for Git users, that it is equivalent as keeping only the commit given by:</source>
          <target state="translated">请注意,对于 Git 用户来说,这相当于只保留了由以下公式给出的提交。</target>
        </trans-unit>
        <trans-unit id="9cd066f98a94620416bd40171030f2cd3deb4780" translate="yes" xml:space="preserve">
          <source>Note how the rule to only follow the TREESAME parent, if one is available, removed &lt;code&gt;B&lt;/code&gt; from consideration entirely. &lt;code&gt;C&lt;/code&gt; was considered via &lt;code&gt;N&lt;/code&gt;, but is TREESAME. Root commits are compared to an empty tree, so &lt;code&gt;I&lt;/code&gt; is !TREESAME.</source>
          <target state="translated">请注意如何仅遵循TREESAME父级的规则（如果有）将 &lt;code&gt;B&lt;/code&gt; 完全从考虑中删除。 &lt;code&gt;C&lt;/code&gt; 是通过 &lt;code&gt;N&lt;/code&gt; 考虑的，但它是TREESAME。将根提交与一棵空树进行比较，所以 &lt;code&gt;I&lt;/code&gt; 是！TREESAME。</target>
        </trans-unit>
        <trans-unit id="8bfd2da46a110f046c6975fde1a8b82933cacdc7" translate="yes" xml:space="preserve">
          <source>Note how there is no need for an entry for &lt;code&gt;&amp;lt;jane@laptop.(none)&amp;gt;&lt;/code&gt;, because the real name of that author is already correct.</source>
          <target state="translated">请注意，无需输入 &lt;code&gt;&amp;lt;jane@laptop.(none)&amp;gt;&lt;/code&gt; ，因为该作者的真实姓名已经正确。</target>
        </trans-unit>
        <trans-unit id="a357a7dbcbc2a41b2d3445e7cfb8ae38a48bfe09" translate="yes" xml:space="preserve">
          <source>Note in the example that we set up a triangular workflow, where we pull from one location and push to another. In a non-triangular workflow, &lt;code&gt;@{push}&lt;/code&gt; is the same as &lt;code&gt;@{upstream}&lt;/code&gt;, and there is no need for it.</source>
          <target state="translated">请注意，在示例中，我们建立了一个三角工作流程，在该工作流程中，我们从一个位置拉出并推到另一个位置。在非三角工作流程中， &lt;code&gt;@{push}&lt;/code&gt; 与 &lt;code&gt;@{upstream}&lt;/code&gt; 相同，因此不需要。</target>
        </trans-unit>
        <trans-unit id="01660f89f7c458ce6428d6e0df0b322692b74596" translate="yes" xml:space="preserve">
          <source>Note that &quot;%f&quot; is the name of the path that is being worked on. Depending on the version that is being filtered, the corresponding file on disk may not exist, or may have different contents. So, smudge and clean commands should not try to access the file on disk, but only act as filters on the content provided to them on standard input.</source>
          <target state="translated">请注意,&quot;%f &quot;是正在处理的路径名称。根据被过滤的版本,磁盘上对应的文件可能不存在,或者有不同的内容。所以,smudge和clean命令不应试图访问磁盘上的文件,而只是作为对标准输入中提供给它们的内容进行过滤。</target>
        </trans-unit>
        <trans-unit id="014f6a8d43d7b297d024fa501c939621bed28154" translate="yes" xml:space="preserve">
          <source>Note that &quot;../&quot; is not special and will match literally, which is unlikely what you want.</source>
          <target state="translated">请注意,&quot;./&quot;并不特殊,会按字面意思匹配,这不太可能是你想要的。</target>
        </trans-unit>
        <trans-unit id="8b91ded5c4fad4671b25fb8bfeab09bc89a0acef" translate="yes" xml:space="preserve">
          <source>Note that (3) is a historical artefact and will be ignored if the (1) and (2) specify that the submodule is not active. In other words, if we have a &lt;code&gt;submodule.&amp;lt;name&amp;gt;.active&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; or if the submodule&amp;rsquo;s path is excluded in the pathspec in &lt;code&gt;submodule.active&lt;/code&gt;, the url doesn&amp;rsquo;t matter whether it is present or not. This is illustrated in the example that follows.</source>
          <target state="translated">请注意，（3）是历史人工制品，如果（1）和（2）指定子模块未处于活动状态，则将被忽略。换句话说，如果我们有一个 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.active&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; ，或者如果子模块的路径被排除在pathspec &lt;code&gt;submodule.active&lt;/code&gt; ，网址不要紧，无论它存在与否。在下面的示例中对此进行了说明。</target>
        </trans-unit>
        <trans-unit id="6fec9940a0e0728d1bf92151624eb87584d6019f" translate="yes" xml:space="preserve">
          <source>Note that --more, --list, --independent and --merge-base options are mutually exclusive.</source>
          <target state="translated">请注意,--more、--list、--independent和--merge-base选项是相互排斥的。</target>
        </trans-unit>
        <trans-unit id="9b9a74f48dd77c7cda36904d8ae57495c22af6f7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;--force&lt;/code&gt; applies to all the refs that are pushed, hence using it with &lt;code&gt;push.default&lt;/code&gt; set to &lt;code&gt;matching&lt;/code&gt; or with multiple push destinations configured with &lt;code&gt;remote.*.push&lt;/code&gt; may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart). To force a push to only one branch, use a &lt;code&gt;+&lt;/code&gt; in front of the refspec to push (e.g &lt;code&gt;git push
origin +master&lt;/code&gt; to force a push to the &lt;code&gt;master&lt;/code&gt; branch). See the &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; section above for details.</source>
          <target state="translated">请注意 &lt;code&gt;--force&lt;/code&gt; 适用于所有推送的ref，因此将 &lt;code&gt;push.default&lt;/code&gt; 设置为 &lt;code&gt;matching&lt;/code&gt; 或将其与配置了 &lt;code&gt;remote.*.push&lt;/code&gt; 多个推送目标一起使用。*。push可能会覆盖当前分支以外的其他ref（包括本地ref严格落后于他们的远程对象）。要强制只推送到一个分支，请在refspec前面使用 &lt;code&gt;+&lt;/code&gt; 进行推送（例如 &lt;code&gt;git push origin +master&lt;/code&gt; 强制推送到 &lt;code&gt;master&lt;/code&gt; 分支）。有关详细信息，请参见上面的 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="f71426a1d6dfa55d8e5b4bb3bb7ddab1eba41559" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;--patch&lt;/code&gt; can accept no pathspec and will prompt to restore all modified paths.</source>
          <target state="translated">请注意，-- &lt;code&gt;--patch&lt;/code&gt; 不能接受任何路径说明，并且会提示您还原所有修改的路径。</target>
        </trans-unit>
        <trans-unit id="788dab85e40bdd496cc4b3d8bdc2f5695fd79580" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;combined diff&lt;/code&gt; lists only files which were modified from all parents.</source>
          <target state="translated">请注意， &lt;code&gt;combined diff&lt;/code&gt; 仅列出从所有父级修改而来的文件。</target>
        </trans-unit>
        <trans-unit id="e64bae554ef50a53010f144d204d2601ed2388af" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git --help ...&lt;/code&gt; is identical to &lt;code&gt;git help ...&lt;/code&gt; because the former is internally converted into the latter.</source>
          <target state="translated">请注意， &lt;code&gt;git --help ...&lt;/code&gt; 与 &lt;code&gt;git help ...&lt;/code&gt; 相同，因为前者在内部转换为后者。</target>
        </trans-unit>
        <trans-unit id="0f050e4f28b585b64021f162ba65306d71b16a1c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git add&lt;/code&gt; always adds just the current contents of a file to the index; further changes to the same file will be ignored unless you run &lt;code&gt;git add&lt;/code&gt; on the file again.</source>
          <target state="translated">注意， &lt;code&gt;git add&lt;/code&gt; 总是只将文件的当前内容添加到索引中。除非再次在文件上运行 &lt;code&gt;git add&lt;/code&gt; ，否则将忽略对该文件的进一步更改。</target>
        </trans-unit>
        <trans-unit id="a75d3b6c972faf4b238fb20e64f0ae5ba4c5e6f0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git diff-tree&lt;/code&gt; can use the tree encapsulated in a commit object.</source>
          <target state="translated">注意， &lt;code&gt;git diff-tree&lt;/code&gt; 可以使用封装在提交对象中的树。</target>
        </trans-unit>
        <trans-unit id="c22023840a6edf8cbd10c5905bf1fe0b2598253c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;trailers&lt;/code&gt; do not follow and are not intended to follow many rules for RFC 822 headers. For example they do not follow the encoding rules and probably many other rules.</source>
          <target state="translated">请注意， &lt;code&gt;trailers&lt;/code&gt; 不遵循且不旨在遵循RFC 822标头的许多规则。例如，它们不遵循编码规则，并且可能不遵循许多其他规则。</target>
        </trans-unit>
        <trans-unit id="99d4b644b5be625d6423f4cb1035eccb3ada0dfe" translate="yes" xml:space="preserve">
          <source>Note that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa. Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly.</source>
          <target state="translated">请注意,Git在核心层将路径名简单地视为非NUL字节的序列,不存在路径名编码转换(Mac和Windows除外)。因此,即使在使用传统的扩展ASCII编码的平台和文件系统上,使用非ASCII的路径名也能正常工作。然而,在这些系统上创建的版本库在基于UTF-8的系统(如Linux、Mac、Windows)上将无法正常工作,反之亦然。此外,许多基于Git的工具会简单地假设路径名为UTF-8,而无法正确显示其他编码。</target>
        </trans-unit>
        <trans-unit id="9883f1d7503e774a80aca1b5641976f5b274bd93" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;filerename&lt;/code&gt; is the same as a &lt;code&gt;filecopy&lt;/code&gt; followed by a &lt;code&gt;filedelete&lt;/code&gt; of the source location. There is a slight performance advantage to using &lt;code&gt;filerename&lt;/code&gt;, but the advantage is so small that it is never worth trying to convert a delete/add pair in source material into a rename for fast-import. This &lt;code&gt;filerename&lt;/code&gt; command is provided just to simplify frontends that already have rename information and don&amp;rsquo;t want bother with decomposing it into a &lt;code&gt;filecopy&lt;/code&gt; followed by a &lt;code&gt;filedelete&lt;/code&gt;.</source>
          <target state="translated">注意， &lt;code&gt;filerename&lt;/code&gt; 相同一个 &lt;code&gt;filecopy&lt;/code&gt; 后跟一个 &lt;code&gt;filedelete&lt;/code&gt; 源位置的。使用 &lt;code&gt;filerename&lt;/code&gt; 会有一点性能上的优势，但是优势是如此之小，以至于永远不值得尝试将源资料中的删除/添加对转换为用于快速导入的重命名。提供此 &lt;code&gt;filerename&lt;/code&gt; 命令只是为了简化已经具有重命名信息的前端，并且不希望将其分解为文件 &lt;code&gt;filecopy&lt;/code&gt; 然后再分解为文件 &lt;code&gt;filedelete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f7296e0d288c1c6e4ca2a5e972f6c90872dfac0" translate="yes" xml:space="preserve">
          <source>Note that a commit does not itself contain any information about what actually changed; all changes are calculated by comparing the contents of the tree referred to by this commit with the trees associated with its parents. In particular, Git does not attempt to record file renames explicitly, though it can identify cases where the existence of the same file data at changing paths suggests a rename. (See, for example, the &lt;code&gt;-M&lt;/code&gt; option to &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;).</source>
          <target state="translated">注意，提交本身并不包含有关实际更改的任何信息。通过将此提交所引用的树的内容与其父级关联的树进行比较，可以计算出所有更改。特别地，Git不会尝试明确记录文件重命名，尽管它可以识别在更改路径处存在相同文件数据提示重命名的情况。（例如，参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;的 &lt;code&gt;-M&lt;/code&gt; 选项）。</target>
        </trans-unit>
        <trans-unit id="54977b94f7c8617e07e8f365a31b9faa2fc062c5" translate="yes" xml:space="preserve">
          <source>Note that a more compact instruction does not change offset and size encoding. For example, if only offset2 is omitted like below, offset3 still contains bits 16-23. It does not become offset2 and contains bits 8-15 even if it&amp;rsquo;s right next to offset1.</source>
          <target state="translated">注意，更紧凑的指令不会更改偏移量和大小编码。例如，如果仅像下面这样省略了offset2，则offset3仍包含位16-23。即使它紧靠offset1，它也不会变为offset2并包含8-15位。</target>
        </trans-unit>
        <trans-unit id="2599b1548726c0979f146506e9008608bae9db4a" translate="yes" xml:space="preserve">
          <source>Note that a rebase merge works by replaying each commit from the working branch on top of the &amp;lt;upstream&amp;gt; branch. Because of this, when a merge conflict happens, the side reported as &lt;code&gt;ours&lt;/code&gt; is the so-far rebased series, starting with &amp;lt;upstream&amp;gt;, and &lt;code&gt;theirs&lt;/code&gt; is the working branch. In other words, the sides are swapped.</source>
          <target state="translated">请注意，rebase合并通过重播&amp;lt;upstream&amp;gt;分支顶部的工作分支中的每个提交来工作。因此，当发生合并冲突时，报告为 &lt;code&gt;ours&lt;/code&gt; 方的那一面是迄今为止的基础系列，从&amp;lt;upstream&amp;gt;开始，而 &lt;code&gt;theirs&lt;/code&gt; 是工作分支。换句话说，双方交换。</target>
        </trans-unit>
        <trans-unit id="8523c23f527cd324df8d4075c34f666be6f6f3b7" translate="yes" xml:space="preserve">
          <source>Note that all forms other than &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;:&amp;lt;expect&amp;gt;&lt;/code&gt; that specifies the expected current value of the ref explicitly are still experimental and their semantics may change as we gain experience with this feature.</source>
          <target state="translated">请注意，除了 &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;:&amp;lt;expect&amp;gt;&lt;/code&gt; 以外，所有其他形式都明确指定了ref的当前预期值，这些形式仍处于实验阶段，随着我们对该功能的经验积累，它们的语义可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="4c01852cae3ff7462ff1404dd165465e299075b3" translate="yes" xml:space="preserve">
          <source>Note that all these configuration variables should probably be set using the &lt;code&gt;--global&lt;/code&gt; flag, for example like this:</source>
          <target state="translated">请注意，所有这些配置变量都应使用 &lt;code&gt;--global&lt;/code&gt; 标志设置，例如：</target>
        </trans-unit>
        <trans-unit id="11bfa085b8a4e40f2da0245c59f1751f600a1ada" translate="yes" xml:space="preserve">
          <source>Note that any of the &lt;code&gt;refs/*&lt;/code&gt; cases above may come either from the &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory or from the &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; file. While the ref name encoding is unspecified, UTF-8 is preferred as some output processing may assume ref names in UTF-8.</source>
          <target state="translated">请注意，上面的任何 &lt;code&gt;refs/*&lt;/code&gt; 情况都可能来自 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 目录或 &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; 文件。虽然未指定引用名称编码，但首选使用UTF-8，因为某些输出处理可能会假定UTF-8中使用了引用名称。</target>
        </trans-unit>
        <trans-unit id="508d8a380e829238fc278b6ce7f900eddc6afba3" translate="yes" xml:space="preserve">
          <source>Note that any protocol restrictions will be applied to the rewritten URL. If the rewrite changes the URL to use a custom protocol or remote helper, you may need to adjust the &lt;code&gt;protocol.*.allow&lt;/code&gt; config to permit the request. In particular, protocols you expect to use for submodules must be set to &lt;code&gt;always&lt;/code&gt; rather than the default of &lt;code&gt;user&lt;/code&gt;. See the description of &lt;code&gt;protocol.allow&lt;/code&gt; above.</source>
          <target state="translated">请注意，所有协议限制都将应用于重写的URL。如果重写将URL更改为使用自定义协议或远程帮助程序，则可能需要调整 &lt;code&gt;protocol.*.allow&lt;/code&gt; config以允许请求。特别是，您希望用于子模块的协议必须设置为 &lt;code&gt;always&lt;/code&gt; 而不是 &lt;code&gt;user&lt;/code&gt; 的默认值。请参阅上面对 &lt;code&gt;protocol.allow&lt;/code&gt; 的描述。</target>
        </trans-unit>
        <trans-unit id="85755e8e95f86917d98f865efeaea006efa16988" translate="yes" xml:space="preserve">
          <source>Note that any tree or blob object can be examined using &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; with the &amp;lt;revision&amp;gt;:&amp;lt;path&amp;gt; syntax. This can sometimes be useful for browsing the contents of a tree that is not currently checked out.</source>
          <target state="translated">注意，可以使用&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;和&amp;lt;revision&amp;gt;：&amp;lt;path&amp;gt;语法检查任何树或blob对象。有时这对于浏览当前未检出的树的内容很有用。</target>
        </trans-unit>
        <trans-unit id="fbb379f0a0fd79434d80db46f9a2b53054c72c7c" translate="yes" xml:space="preserve">
          <source>Note that attributes are by default taken from the &lt;code&gt;.gitattributes&lt;/code&gt; files in the tree that is being archived. If you want to tweak the way the output is generated after the fact (e.g. you committed without adding an appropriate export-ignore in its &lt;code&gt;.gitattributes&lt;/code&gt;), adjust the checked out &lt;code&gt;.gitattributes&lt;/code&gt; file as necessary and use &lt;code&gt;--worktree-attributes&lt;/code&gt; option. Alternatively you can keep necessary attributes that should apply while archiving any tree in your &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file.</source>
          <target state="translated">请注意，默认情况下，属性是从要归档的树中的 &lt;code&gt;.gitattributes&lt;/code&gt; 文件中获取的。如果要调整事后生成输出的方式（例如，您在未在 &lt;code&gt;.gitattributes&lt;/code&gt; 中添加适当的export-ignore的情况下提交），请根据需要调整检出的 &lt;code&gt;.gitattributes&lt;/code&gt; 文件，并使用 &lt;code&gt;--worktree-attributes&lt;/code&gt; 选项。或者，您可以保留在 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 文件中归档任何树时应应用的必要属性。</target>
        </trans-unit>
        <trans-unit id="cff58353f0553493321de729107a5ed939f5819e" translate="yes" xml:space="preserve">
          <source>Note that changing the compression level will not automatically recompress all existing objects. You can force recompression by passing the -F option to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;.</source>
          <target state="translated">请注意，更改压缩级别不会自动重新压缩所有现有对象。您可以通过将-F选项传递给&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;来强制重新压缩。</target>
        </trans-unit>
        <trans-unit id="64e3311b0fc4c31b0c8a5b69594b7b0fffce6672" translate="yes" xml:space="preserve">
          <source>Note that commands that operate on the history of the current branch (e.g. &lt;code&gt;git commit&lt;/code&gt; to build a new history on top of it) still work while the HEAD is detached. They update the HEAD to point at the tip of the updated history without affecting any branch. Commands that update or inquire information &lt;code&gt;about&lt;/code&gt; the current branch (e.g. &lt;code&gt;git
branch --set-upstream-to&lt;/code&gt; that sets what remote-tracking branch the current branch integrates with) obviously do not work, as there is no (real) current branch to ask about in this state.</source>
          <target state="translated">请注意，在分离了HEAD的情况下，对当前分支的历史记录进行操作的命令（例如 &lt;code&gt;git commit&lt;/code&gt; 在其顶部构建新历史记录）仍然有效。他们将HEAD更新为指向更新历史记录的尖端，而不会影响任何分支。更新或查询 &lt;code&gt;about&lt;/code&gt; 当前分支的信息的命令（例如 &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; ，用于设置当前分支与之集成的远程跟踪分支）显然不起作用，因为没有（真实）当前分支要询问在这种状态下。</target>
        </trans-unit>
        <trans-unit id="c16e502657efa32285522830eee76fe68f8a2daa" translate="yes" xml:space="preserve">
          <source>Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled.</source>
          <target state="translated">请注意,尽管第一种模式的名称,但如果启用,所有模式中的颜色都用于突出显示已更改的部分。</target>
        </trans-unit>
        <trans-unit id="53b666711e62d15ce074196074eb30f8dac41460" translate="yes" xml:space="preserve">
          <source>Note that diff options passed to the command affect how the primary product of &lt;code&gt;format-patch&lt;/code&gt; is generated, and they are not passed to the underlying &lt;code&gt;range-diff&lt;/code&gt; machinery used to generate the cover-letter material (this may change in the future).</source>
          <target state="translated">请注意，传递给命令的diff选项会影响 &lt;code&gt;format-patch&lt;/code&gt; 的主乘积的生成方式，并且不会传递给用于生成封面信纸材料的基础 &lt;code&gt;range-diff&lt;/code&gt; 机械（将来可能会更改）。</target>
        </trans-unit>
        <trans-unit id="e0e05126bbcc50063c2790c39405469ee70a21a8" translate="yes" xml:space="preserve">
          <source>Note that during &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git pull --rebase&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt; and &lt;code&gt;theirs&lt;/code&gt; may appear swapped. See the explanation of the same options in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; for details.</source>
          <target state="translated">请注意，在 &lt;code&gt;git rebase&lt;/code&gt; 和 &lt;code&gt;git pull --rebase&lt;/code&gt; 期间， &lt;code&gt;ours&lt;/code&gt; 和 &lt;code&gt;theirs&lt;/code&gt; 可能会互换。有关详细信息，请参见&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]中&lt;/a&gt;相同选项的说明。</target>
        </trans-unit>
        <trans-unit id="1af7aa20d72debc79fb9171e27e72669f87bd742" translate="yes" xml:space="preserve">
          <source>Note that during &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git pull --rebase&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt; and &lt;code&gt;theirs&lt;/code&gt; may appear swapped; &lt;code&gt;--ours&lt;/code&gt; gives the version from the branch the changes are rebased onto, while &lt;code&gt;--theirs&lt;/code&gt; gives the version from the branch that holds your work that is being rebased.</source>
          <target state="translated">注意，在 &lt;code&gt;git rebase&lt;/code&gt; 和 &lt;code&gt;git pull --rebase&lt;/code&gt; 期间， &lt;code&gt;ours&lt;/code&gt; 和 &lt;code&gt;theirs&lt;/code&gt; 可能会互换； &lt;code&gt;--ours&lt;/code&gt; 提供更改所基于的分支的版本，而 &lt;code&gt;--theirs&lt;/code&gt; 提供包含要重新构建的工作的分支的版本。</target>
        </trans-unit>
        <trans-unit id="c0c3e4b221eecb8ab2fd8007bde41fbeccbc289b" translate="yes" xml:space="preserve">
          <source>Note that earlier implementation left a broken pair as a separate creation and deletion patches. This was an unnecessary hack and the latest implementation always merges all the broken pairs back into modifications, but the resulting patch output is formatted differently for easier review in case of such a complete rewrite by showing the entire contents of old version prefixed with &lt;code&gt;-&lt;/code&gt;, followed by the entire contents of new version prefixed with &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">请注意，较早的实现留下了一对中断对作为单独的创建和删除补丁。这是不必要的修改，并且最新的实现总是将所有断开的对合并为修改，但是对于这样的完整重写，通过显示以 &lt;code&gt;-&lt;/code&gt; 开头的旧版本的全部内容，可以将修补程序输出的格式设置为不同格式，以便于更轻松地查看。由新版本的全部内容加上 &lt;code&gt;+&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="1e94eb3093be7f837a0c2027288d60b6c3b52e2c" translate="yes" xml:space="preserve">
          <source>Note that earlier versions of this command did not complain and produced incorrect results if you gave these options.</source>
          <target state="translated">请注意,如果你给了这些选项,这个命令的早期版本不会抱怨,并产生不正确的结果。</target>
        </trans-unit>
        <trans-unit id="5d58dd5b84f29e01b510ca03eab20796ad3c7cbe" translate="yes" xml:space="preserve">
          <source>Note that extra commits can be shown to give a meaningful history.</source>
          <target state="translated">请注意,额外的提交可以显示出一个有意义的历史。</target>
        </trans-unit>
        <trans-unit id="5d8bcfac8a1a61a9e4be4013c3b0af7c68e4f7e1" translate="yes" xml:space="preserve">
          <source>Note that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit. Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit.</source>
          <target state="translated">请注意,快进更新并不创建合并提交,因此无法使用 --no-commit 来停止这些合并。因此,如果你想确保你的分支不被合并命令修改或更新,请使用 --no-ff 和 --no-commit。</target>
        </trans-unit>
        <trans-unit id="f0d1c52e1eb6b4521a19e733ce553d5995206cf5" translate="yes" xml:space="preserve">
          <source>Note that fast-import automatically switches packfiles when the current packfile reaches --max-pack-size, or 4 GiB, whichever limit is smaller. During an automatic packfile switch fast-import does not update the branch refs, tags or marks.</source>
          <target state="translated">请注意,当当前的 packfile 达到 --max-pack-size 或 4 GiB 时,fast-import 会自动切换 packfile,以较小的限制为准。在自动切换打包文件的过程中,fast-import 不会更新分支参考、标签或标记。</target>
        </trans-unit>
        <trans-unit id="6615d1d4a8cbe8f9f5da36594407e26f3b365d70" translate="yes" xml:space="preserve">
          <source>Note that git log starts with the most recent commit and works backwards through the parents; however, since Git history can contain multiple independent lines of development, the particular order that commits are listed in may be somewhat arbitrary.</source>
          <target state="translated">需要注意的是,git日志从最近的提交开始,然后从父代开始往后排;不过,由于Git历史可以包含多条独立的开发线路,所以提交的顺序可能有些随意。</target>
        </trans-unit>
        <trans-unit id="b6e44338fe1bf08aabf78cd81639eb77b1309fea" translate="yes" xml:space="preserve">
          <source>Note that git pull always merges into the current branch, regardless of what else is given on the command line.</source>
          <target state="translated">请注意,无论命令行中给出了什么,git pull 总是会合并到当前分支。</target>
        </trans-unit>
        <trans-unit id="bcdb8efaa60d12b40472e9e7be3ed7ef20fcfd01" translate="yes" xml:space="preserve">
          <source>Note that git-svn keeps track of the highest revision in which a branch or tag has appeared. If the subset of branches or tags is changed after fetching, then $GIT_DIR/svn/.metadata must be manually edited to remove (or reset) branches-maxRev and/or tags-maxRev as appropriate.</source>
          <target state="translated">注意 git-svn 会跟踪分支或标签出现的最高版本。如果分支或标签的子集在获取后发生了变化,那么必须手动编辑 $GIT_DIR/svn/.metadata 来移除(或重置)branches-maxRev 和/或 tags-maxRev。</target>
        </trans-unit>
        <trans-unit id="9d6b14c8954c11ebf9dc491ca128004d883ac7cd" translate="yes" xml:space="preserve">
          <source>Note that he doesn&amp;rsquo;t need to give the path to Alice&amp;rsquo;s repository; when Bob cloned Alice&amp;rsquo;s repository, Git stored the location of her repository in the repository configuration, and that location is used for pulls:</source>
          <target state="translated">请注意，他不需要提供通往Alice的存储库的路径。当Bob克隆Alice的存储库时，Git将其存储库的位置存储在存储库配置中，该位置用于拉取：</target>
        </trans-unit>
        <trans-unit id="d033887586c63461935e98a544790f02b6895719" translate="yes" xml:space="preserve">
          <source>Note that if no extensions are specified in the config file, then &lt;code&gt;core.repositoryformatversion&lt;/code&gt; SHOULD be set to &lt;code&gt;0&lt;/code&gt; (setting it to &lt;code&gt;1&lt;/code&gt; provides no benefit, and makes the repository incompatible with older implementations of git).</source>
          <target state="translated">请注意，如果未在配置文件中指定扩展名， &lt;code&gt;core.repositoryformatversion&lt;/code&gt; 将core.repositoryformatversion设置为 &lt;code&gt;0&lt;/code&gt; （将其设置为 &lt;code&gt;1&lt;/code&gt; 不会带来任何好处，并使存储库与git的较早实现不兼容）。</target>
        </trans-unit>
        <trans-unit id="855e515073658cd86a49dd1065464c65266acbcf" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;bidi-import&lt;/code&gt; capability is used the complete batch sequence has to be buffered before starting to send data to fast-import to prevent mixing of commands and fast-import responses on the helper&amp;rsquo;s stdin.</source>
          <target state="translated">请注意，如果使用了 &lt;code&gt;bidi-import&lt;/code&gt; 功能，则在开始将数据发送到快速导入之前，必须缓冲完整的批处理序列，以防止在助手的stdin上混合命令和快速导入响应。</target>
        </trans-unit>
        <trans-unit id="b689c65aa31e82a2dbc37c89c0ac3187b41716e6" translate="yes" xml:space="preserve">
          <source>Note that if the current branch head was your only reference to a particular point in history, then resetting that branch may leave you with no way to find the history it used to point to; so use this command carefully.</source>
          <target state="translated">请注意,如果当前的分支头是您对历史上某一特定点的唯一参考,那么重置该分支可能会让您无法找到它曾经指向的历史;所以请谨慎使用此命令。</target>
        </trans-unit>
        <trans-unit id="e6c226fbc041b7aed3f8d988d110ae660c99fecc" translate="yes" xml:space="preserve">
          <source>Note that if the number of kept packs is more than gc.autoPackLimit, this configuration variable is ignored, all packs except the base pack will be repacked. After this the number of packs should go below gc.autoPackLimit and gc.bigPackThreshold should be respected again.</source>
          <target state="translated">请注意,如果保留的包的数量超过了gc.autoPackLimit,这个配置变量会被忽略,除了基本包之外的所有包都会被重新打包。在这之后,包的数量应该低于gc.autoPackLimit,并且gc.bigPackThreshold应该再次被尊重。</target>
        </trans-unit>
        <trans-unit id="876a2eaaf30082c69c38a89b274fd268226ca0ba" translate="yes" xml:space="preserve">
          <source>Note that if you also want to skip the first commit of the range you would issue the command:</source>
          <target state="translated">需要注意的是,如果你也想跳过这个范围的第一次提交,你可以使用命令。</target>
        </trans-unit>
        <trans-unit id="102fd7adeeb68915f128c7eebf4ae04f1c363d22" translate="yes" xml:space="preserve">
          <source>Note that in general, Alice would want her local changes committed before initiating this &quot;pull&quot;. If Bob&amp;rsquo;s work conflicts with what Alice did since their histories forked, Alice will use her working tree and the index to resolve conflicts, and existing local changes will interfere with the conflict resolution process (Git will still perform the fetch but will refuse to merge --- Alice will have to get rid of her local changes in some way and pull again when this happens).</source>
          <target state="translated">请注意，通常，爱丽丝希望在启动此&amp;ldquo;拉&amp;rdquo;之前提交她的本地更改。如果Bob的工作与自从其历史分叉以来Alice的工作发生冲突，Alice将使用其工作树和索引来解决冲突，并且现有的本地更改将干扰冲突解决过程（Git仍将执行获取操作，但将拒绝合并- -爱丽丝必须以某种方式摆脱局部变化，并在发生这种情况时再次拉动。</target>
        </trans-unit>
        <trans-unit id="51fccf4fe2d201a349cf25a2b82190079f387e94" translate="yes" xml:space="preserve">
          <source>Note that in older documentation you may see the index called the &quot;current directory cache&quot; or just the &quot;cache&quot;. It has three important properties:</source>
          <target state="translated">请注意,在旧的文档中,你可能会看到被称为 &quot;当前目录缓存 &quot;或只是 &quot;缓存 &quot;的索引。它有三个重要的属性。</target>
        </trans-unit>
        <trans-unit id="33bb6a06b88e89af07ea98fc22445ba64a91b75d" translate="yes" xml:space="preserve">
          <source>Note that in this file, the exception for &lt;code&gt;core.bare&lt;/code&gt; and &lt;code&gt;core.worktree&lt;/code&gt; is gone. If you have them in $GIT_DIR/config before, you must move them to the &lt;code&gt;config.worktree&lt;/code&gt; of the main working tree. You may also take this opportunity to review and move other configuration that you do not want to share to all working trees:</source>
          <target state="translated">请注意，在此文件中， &lt;code&gt;core.bare&lt;/code&gt; 和 &lt;code&gt;core.worktree&lt;/code&gt; 的异常消失了。如果以前将它们放在$ GIT_DIR / config中，则必须将它们移动到主工作树的 &lt;code&gt;config.worktree&lt;/code&gt; 中。您还可以借此机会查看并移动不想共享给所有工作树的其他配置：</target>
        </trans-unit>
        <trans-unit id="f62684e2b0c86eaa1fac93a58127ba986d09144a" translate="yes" xml:space="preserve">
          <source>Note that it is currently &lt;strong&gt;always&lt;/strong&gt; an array reference, even if feature doesn&amp;rsquo;t accept any configuration parameters, and 'default' is used only to turn it on or off. In such case you turn feature on by setting this element to &lt;code&gt;[1]&lt;/code&gt;, and torn it off by setting it to &lt;code&gt;[0]&lt;/code&gt;. See also the passage about the &quot;blame&quot; feature in the &quot;Examples&quot; section.</source>
          <target state="translated">请注意，即使Feature不接受任何配置参数，它当前也&lt;strong&gt;始终&lt;/strong&gt;是数组引用，并且'default'仅用于打开或关闭它。在这种情况下，您可以通过将该元素设置为 &lt;code&gt;[1]&lt;/code&gt; 来打开功能，并通过将其设置为 &lt;code&gt;[0]&lt;/code&gt; 来将其关闭。另请参见&amp;ldquo;示例&amp;rdquo;部分中有关&amp;ldquo;怪&amp;rdquo;功能的段落。</target>
        </trans-unit>
        <trans-unit id="c6d71837c5b2acf93d8b7a746fdb13a8f313316a" translate="yes" xml:space="preserve">
          <source>Note that it is possible for refname to not have sha1-new when this hook runs. This can easily occur if another user modifies the ref after it was updated by &lt;code&gt;git-receive-pack&lt;/code&gt;, but before the hook was able to evaluate it. It is recommended that hooks rely on sha1-new rather than the current value of refname.</source>
          <target state="translated">请注意，运行此挂钩时，refname可能没有sha1-new。如果其他用户在 &lt;code&gt;git-receive-pack&lt;/code&gt; 更新ref之后但在挂钩能够对其进行评估之前修改了ref，则很容易发生这种情况。建议挂钩依赖sha1-new而不是refname的当前值。</target>
        </trans-unit>
        <trans-unit id="288f25c901caafda3b52f9e96d7bc31178f41bbc" translate="yes" xml:space="preserve">
          <source>Note that merge commits may have more than one parent:</source>
          <target state="translated">请注意,合并提交可能有多个父提交。</target>
        </trans-unit>
        <trans-unit id="b4bd4c01bcc139c9e086b4c697c46e8ed5645dbb" translate="yes" xml:space="preserve">
          <source>Note that namespaces which include a &lt;code&gt;/&lt;/code&gt; will expand to a hierarchy of namespaces; for example, &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; will store refs under &lt;code&gt;refs/namespaces/foo/refs/namespaces/bar/&lt;/code&gt;. This makes paths in &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; behave hierarchically, so that cloning with &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; produces the same result as cloning with &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; and cloning from that repo with &lt;code&gt;GIT_NAMESPACE=bar&lt;/code&gt;. It also avoids ambiguity with strange namespace paths such as &lt;code&gt;foo/refs/heads/&lt;/code&gt;, which could otherwise generate directory/file conflicts within the &lt;code&gt;refs&lt;/code&gt; directory.</source>
          <target state="translated">请注意，包含 &lt;code&gt;/&lt;/code&gt; 的名称空间将扩展为名称空间的层次结构；例如， &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; 会将引用存储在 &lt;code&gt;refs/namespaces/foo/refs/namespaces/bar/&lt;/code&gt; 。这使得 &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; 中的路径具有分层行为，因此使用 &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; 进行克隆产生的结果与使用 &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; 进行克隆以及使用 &lt;code&gt;GIT_NAMESPACE=bar&lt;/code&gt; 进行该回购进行克隆的结果相同。它还可以避免与奇怪的名称空间路径（例如 &lt;code&gt;foo/refs/heads/&lt;/code&gt; 产生歧义，否则可能会在 &lt;code&gt;refs&lt;/code&gt; 目录内生成目录/文件冲突。</target>
        </trans-unit>
        <trans-unit id="5960cd2f6a18c56540790aa3e8525ad5bfd7623b" translate="yes" xml:space="preserve">
          <source>Note that no attempts whatsoever are made to validate the encoding.</source>
          <target state="translated">请注意,无论如何都不会尝试验证编码。</target>
        </trans-unit>
        <trans-unit id="a90bb6c9021795be1cb1c05d155b4badc4462ac4" translate="yes" xml:space="preserve">
          <source>Note that not all diffs can feature all types. For instance, diffs from the index to the working tree can never have Added entries (because the set of paths included in the diff is limited by what is in the index). Similarly, copied and renamed entries cannot appear if detection for those types is disabled.</source>
          <target state="translated">请注意,并不是所有的diff都能包含所有类型。例如,从索引到工作树的diff永远不会有Added条目(因为diff中包含的路径集受到索引中的限制)。同样,如果禁止检测复制和重命名的条目,这些类型也不能出现。</target>
        </trans-unit>
        <trans-unit id="b214bd38041e6a3ecd59f0a8d74547fecd3e66a2" translate="yes" xml:space="preserve">
          <source>Note that omitting the &lt;code&gt;=&lt;/code&gt; in &lt;code&gt;git -c foo.bar ...&lt;/code&gt; is allowed and sets &lt;code&gt;foo.bar&lt;/code&gt; to the boolean true value (just like &lt;code&gt;[foo]bar&lt;/code&gt; would in a config file). Including the equals but with an empty value (like &lt;code&gt;git -c
foo.bar= ...&lt;/code&gt;) sets &lt;code&gt;foo.bar&lt;/code&gt; to the empty string which &lt;code&gt;git config
--type=bool&lt;/code&gt; will convert to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">请注意，允许在 &lt;code&gt;git -c foo.bar ...&lt;/code&gt; 中省略 &lt;code&gt;=&lt;/code&gt; 并将 &lt;code&gt;foo.bar&lt;/code&gt; 设置为布尔值true（就像配置文件中的 &lt;code&gt;[foo]bar&lt;/code&gt; 一样）。包含等于但具有空值的值（例如 &lt;code&gt;git -c foo.bar= ...&lt;/code&gt; ） &lt;code&gt;foo.bar&lt;/code&gt; 设置为空字符串， &lt;code&gt;git config --type=bool&lt;/code&gt; 将其转换为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d893e89ed900e1f0840df95a39350717d32e84c" translate="yes" xml:space="preserve">
          <source>Note that per repository configuration can be set in &lt;code&gt;$GIT_DIR/cloneurl&lt;/code&gt; file, or as values of multi-value &lt;code&gt;gitweb.url&lt;/code&gt; configuration variable in project config. Per-repository configuration takes precedence over value composed from &lt;code&gt;@git_base_url_list&lt;/code&gt; elements and project name.</source>
          <target state="translated">请注意，可以在 &lt;code&gt;$GIT_DIR/cloneurl&lt;/code&gt; 文件中设置每个存储库配置，也可以在项目config &lt;code&gt;gitweb.url&lt;/code&gt; 配置为多值gitweb.url配置变量的值。每个存储库配置优先于由 &lt;code&gt;@git_base_url_list&lt;/code&gt; 元素和项目名称组成的值。</target>
        </trans-unit>
        <trans-unit id="fccadef8ff02c3c7b5e8091c077ff771f4d090ed" translate="yes" xml:space="preserve">
          <source>Note that rule 3 disallows many cases that do not have any privacy implications. These rules are subject to change in future versions of git, and the server accessed by &lt;code&gt;git archive --remote&lt;/code&gt; may or may not follow these exact rules.</source>
          <target state="translated">请注意，规则3禁止许多不涉及隐私的情况。这些规则在将来的git版本中可能会发生变化，并且 &lt;code&gt;git archive --remote&lt;/code&gt; 访问的服务器可能会遵循也可能不会遵循这些确切规则。</target>
        </trans-unit>
        <trans-unit id="6b2cd45b5672bcfb50850c37a2d3873eae0b00dc" translate="yes" xml:space="preserve">
          <source>Note that running &lt;code&gt;git repack&lt;/code&gt; without the &lt;code&gt;--local&lt;/code&gt; option in a repository cloned with &lt;code&gt;--shared&lt;/code&gt; will copy objects from the source repository into a pack in the cloned repository, removing the disk space savings of &lt;code&gt;clone --shared&lt;/code&gt;. It is safe, however, to run &lt;code&gt;git gc&lt;/code&gt;, which uses the &lt;code&gt;--local&lt;/code&gt; option by default.</source>
          <target state="translated">需要注意的是运行 &lt;code&gt;git repack&lt;/code&gt; ，而不 &lt;code&gt;--local&lt;/code&gt; 与克隆一个仓库的选择 &lt;code&gt;--shared&lt;/code&gt; 将从源库对象复制到一个包中的克隆库，删除的磁盘空间节省 &lt;code&gt;clone --shared&lt;/code&gt; 。但是，运行 &lt;code&gt;git gc&lt;/code&gt; 是安全的，默认情况下使用 &lt;code&gt;--local&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="140dadc93eb0ab3b9abb37d56f2b3ec8284a753b" translate="yes" xml:space="preserve">
          <source>Note that since this operation is very I/O expensive, it might be a good idea to redirect the temporary directory off-disk with the &lt;code&gt;-d&lt;/code&gt; option, e.g. on tmpfs. Reportedly the speedup is very noticeable.</source>
          <target state="translated">请注意，由于此操作的I / O开销非常大，因此最好使用 &lt;code&gt;-d&lt;/code&gt; 选项在磁盘外重定向临时目录，例如在tmpfs上。据说加速非常明显。</target>
        </trans-unit>
        <trans-unit id="406b2d499d377ca290ed5b4924c72cd2cd51a43f" translate="yes" xml:space="preserve">
          <source>Note that some configuration can be controlled on per-repository rather than gitweb-wide basis: see &quot;Per-repository gitweb configuration&quot; subsection on &lt;a href=&quot;gitweb&quot;&gt;gitweb[1]&lt;/a&gt; manpage.</source>
          <target state="translated">请注意，可以在每个存储库而不是整个gitweb的基础上控制某些配置：请参见&lt;a href=&quot;gitweb&quot;&gt;gitweb [1]&lt;/a&gt;联机帮助页的&amp;ldquo;每个存储库gitweb配置&amp;rdquo;小节。</target>
        </trans-unit>
        <trans-unit id="0d8f5c59efaf04f91fb17771a5f9956f75377d81" translate="yes" xml:space="preserve">
          <source>Note that terminology has changed since that revision. For example, the README in that revision uses the word &quot;changeset&quot; to describe what we now call a &lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt;.</source>
          <target state="translated">请注意，自该修订版以来，术语已更改。例如，该修订版中的自述文件使用单词&amp;ldquo; changeset&amp;rdquo;来描述我们现在称为&lt;a href=&quot;#def_commit_object&quot;&gt;commit的内容&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1162a2144d0b881d5670bbd9b0805334b2b73beb" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;t_rel&lt;/code&gt; field contains the observed run time in seconds for the child process (starting before the fork/exec/spawn and stopping after the waitpid() and includes OS process creation overhead). So this time will be slightly larger than the atexit time reported by the child process itself.</source>
          <target state="translated">请注意， &lt;code&gt;t_rel&lt;/code&gt; 字段包含观察到的子进程的运行时间（以秒为单位）（在fork / exec / spawn之前开始，在waitpid（）之后停止，并且包括OS进程创建开销）。因此，此时间将比子进程本身报告的退出时间略长。</target>
        </trans-unit>
        <trans-unit id="b7757b33b688da6e41f6e15271bd961d7647767a" translate="yes" xml:space="preserve">
          <source>Note that the SVN URL of the commiturl config key includes the SVN branch. If you rather want to set the commit URL for an entire SVN repository use svn-remote.&amp;lt;name&amp;gt;.pushurl instead.</source>
          <target state="translated">请注意，commiturl配置键的SVN URL包含SVN分支。如果您想为整个SVN存储库设置提交URL，请使用svn-remote。&amp;lt;name&amp;gt; .pushurl。</target>
        </trans-unit>
        <trans-unit id="cb5d63c2ce1d70a7eb8e0b6357957166a5a229f7" translate="yes" xml:space="preserve">
          <source>Note that the asterisk &lt;code&gt;*&lt;/code&gt; is quoted from the shell in this example; this lets Git, and not the shell, expand the pathnames of files and subdirectories under the &lt;code&gt;Documentation/&lt;/code&gt; directory.</source>
          <target state="translated">请注意，在此示例中，星号 &lt;code&gt;*&lt;/code&gt; 从外壳引号引起来；这使Git而不是Shell可以扩展 &lt;code&gt;Documentation/&lt;/code&gt; 目录下文件和子目录的路径名。</target>
        </trans-unit>
        <trans-unit id="ce32bdb056375627c69f9422ed26926b9107752d" translate="yes" xml:space="preserve">
          <source>Note that the asterisk &lt;code&gt;*&lt;/code&gt; is quoted from the shell in this example; this lets the command include the files from subdirectories of &lt;code&gt;Documentation/&lt;/code&gt; directory.</source>
          <target state="translated">请注意，在此示例中，星号 &lt;code&gt;*&lt;/code&gt; 从外壳引号引起来；这使命令可以包含 &lt;code&gt;Documentation/&lt;/code&gt; 目录的子目录中的文件。</target>
        </trans-unit>
        <trans-unit id="8938c6c44864ae040ef79f140140b8a3da4caab5" translate="yes" xml:space="preserve">
          <source>Note that the commit message will already be filled in for you with some information about the merge. Normally you can just use this default message unchanged, but you may add additional commentary of your own if desired.</source>
          <target state="translated">请注意,提交信息中已经为您填写了一些关于合并的信息。一般来说,您可以不加修改地使用这个默认信息,但如果需要的话,您可以添加自己的注释。</target>
        </trans-unit>
        <trans-unit id="131272668a67eaa5ac9294087a9ff4488c82c210" translate="yes" xml:space="preserve">
          <source>Note that the example that we will use is really a toy example, we will be looking for the first commit that has a version like &quot;2.6.26-something&quot;, that is the commit that has a &quot;SUBLEVEL = 26&quot; line in the top level Makefile. This is a toy example because there are better ways to find this commit with Git than using &quot;git bisect&quot; (for example &quot;git blame&quot; or &quot;git log -S&amp;lt;string&amp;gt;&quot;).</source>
          <target state="translated">请注意，我们将使用的示例实际上是一个玩具示例，我们将寻找具有&amp;ldquo; 2.6.26-something&amp;rdquo;之类的版本的第一个提交，即在顶层Makefile。这是一个玩具示例，因为与使用&amp;ldquo; git bisect&amp;rdquo;（例如&amp;ldquo; git blame&amp;rdquo;或&amp;ldquo; git log -S &amp;lt;string&amp;gt;&amp;rdquo;）相比，使用Git查找此提交的方法更好。</target>
        </trans-unit>
        <trans-unit id="5e386156a3e0996458a30d74f4a22474e7420343" translate="yes" xml:space="preserve">
          <source>Note that the files all have mode 644 or 755: Git actually only pays attention to the executable bit.</source>
          <target state="translated">注意,文件的模式都是644或755:Git其实只关注可执行位。</target>
        </trans-unit>
        <trans-unit id="d2e57a867612d1ae307185458bab810ae89e20a5" translate="yes" xml:space="preserve">
          <source>Note that the first word of an alias does not necessarily have to be a command. It can be a command-line option that will be passed into the invocation of &lt;code&gt;git&lt;/code&gt;. In particular, this is useful when used with &lt;code&gt;-c&lt;/code&gt; to pass in one-time configurations or &lt;code&gt;-p&lt;/code&gt; to force pagination. For example, &lt;code&gt;loud-rebase = -c commit.verbose=true rebase&lt;/code&gt; can be defined such that running &lt;code&gt;git loud-rebase&lt;/code&gt; would be equivalent to &lt;code&gt;git -c commit.verbose=true rebase&lt;/code&gt;. Also, &lt;code&gt;ps = -p status&lt;/code&gt; would be a helpful alias since &lt;code&gt;git ps&lt;/code&gt; would paginate the output of &lt;code&gt;git status&lt;/code&gt; where the original command does not.</source>
          <target state="translated">请注意，别名的第一个单词不一定必须是命令。它可以是命令行选项，将传递给 &lt;code&gt;git&lt;/code&gt; 调用。特别是，当与 &lt;code&gt;-c&lt;/code&gt; 一起使用以一次性配置通过或 &lt;code&gt;-p&lt;/code&gt; 强制分页使用时，这很有用。例如，可以定义 &lt;code&gt;loud-rebase = -c commit.verbose=true rebase&lt;/code&gt; ，以便运行 &lt;code&gt;git loud-rebase&lt;/code&gt; &lt;code&gt;git -c commit.verbose=true rebase&lt;/code&gt; -rebase与git -c commit.verbose = true rebase等效。同样， &lt;code&gt;ps = -p status&lt;/code&gt; 将是一个有用的别名，因为 &lt;code&gt;git ps&lt;/code&gt; 将对 &lt;code&gt;git status&lt;/code&gt; 的输出进行分页，而原始命令则不这样做。</target>
        </trans-unit>
        <trans-unit id="650b87912cfe39dc5747fbba67473a3822f86ab9" translate="yes" xml:space="preserve">
          <source>Note that the form &lt;code&gt;--filter=sparse:path=&amp;lt;path&amp;gt;&lt;/code&gt; that wants to read from an arbitrary path on the filesystem has been dropped for security reasons.</source>
          <target state="translated">请注意，出于安全原因，已删除了要从文件系统上任意路径读取的 &lt;code&gt;--filter=sparse:path=&amp;lt;path&amp;gt;&lt;/code&gt; 形式。</target>
        </trans-unit>
        <trans-unit id="d8075e043d9a3ca9826ff1989c66c1905d9648ca" translate="yes" xml:space="preserve">
          <source>Note that the grafts mechanism is outdated and can lead to problems transferring objects between repositories; see &lt;a href=&quot;git-replace&quot;&gt;git-replace[1]&lt;/a&gt; for a more flexible and robust system to do the same thing.</source>
          <target state="translated">请注意，嫁接机制已经过时，可能导致在存储库之间传输对象时出现问题。请参阅&lt;a href=&quot;git-replace&quot;&gt;git-replace [1]&lt;/a&gt;以获取更灵活，更强大的系统来执行相同的操作。</target>
        </trans-unit>
        <trans-unit id="0b0bdd8828d416a94597b15ce8aefc2c0b976fde" translate="yes" xml:space="preserve">
          <source>Note that the last point clashes with the other two: a topic that has been merged elsewhere should not be rebased. See the section on RECOVERING FROM UPSTREAM REBASE in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">请注意，最后一点与其他两点冲突：已经在其他地方合并的主题不应重新设置基础。请参阅&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]中的&lt;/a&gt;从UPSTRREAM REBASE恢复。</target>
        </trans-unit>
        <trans-unit id="bd4901c4d1f08f37f3106399dbc26a76568f48fe" translate="yes" xml:space="preserve">
          <source>Note that the leading character does not have to be a dot; for example, you can use &lt;code&gt;--suffix=-patch&lt;/code&gt; to get &lt;code&gt;0001-description-of-my-change-patch&lt;/code&gt;.</source>
          <target state="translated">注意，前导字符不必是点。例如，您可以使用 &lt;code&gt;--suffix=-patch&lt;/code&gt; 获得 &lt;code&gt;0001-description-of-my-change-patch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="833f1e85ef857dfcde43c87fdacaaa1075b0d6b3" translate="yes" xml:space="preserve">
          <source>Note that the maintainer(s) may impose restrictions, such as &quot;Signed-off-by&quot; requirements, that all commits/patches submitted for inclusion must adhere to. Consult your project&amp;rsquo;s documentation for more information.</source>
          <target state="translated">请注意，维护者可能会施加一些限制，例如&amp;ldquo;签署人&amp;rdquo;要求，必须遵守提交的所有提交/补丁。有关更多信息，请查阅项目的文档。</target>
        </trans-unit>
        <trans-unit id="50f092ab1e91fa0de2c9ed05785c4a967888dc6a" translate="yes" xml:space="preserve">
          <source>Note that the name &quot;origin&quot; is just the name that Git uses by default to refer to the repository that you cloned from.</source>
          <target state="translated">请注意,&quot;origin &quot;只是Git默认使用的名称,用来指代你克隆的仓库。</target>
        </trans-unit>
        <trans-unit id="22728656f144a546aef50a70cd21a26fce3a8c1d" translate="yes" xml:space="preserve">
          <source>Note that the patch is always used as-is without charset conversion, even with this flag.</source>
          <target state="translated">请注意,即使有这个标志,补丁也总是在没有进行字符集转换的情况下按原样使用。</target>
        </trans-unit>
        <trans-unit id="9bea9d7e3f1393135579965b1439ff9a7baaf238" translate="yes" xml:space="preserve">
          <source>Note that the push URL and the fetch URL, even though they can be set differently, must still refer to the same place. What you pushed to the push URL should be what you would see if you immediately fetched from the fetch URL. If you are trying to fetch from one place (e.g. your upstream) and push to another (e.g. your publishing repository), use two separate remotes.</source>
          <target state="translated">请注意,push URL和fetch URL虽然可以设置不同,但仍然必须指向同一个地方。你推送到推送 URL 的内容应该是你立即从获取 URL 获取时看到的内容。如果你试图从一个地方(例如你的上游)获取并推送到另一个地方(例如你的发布库),请使用两个不同的远程。</target>
        </trans-unit>
        <trans-unit id="f8efe69c6940942131795b6ce6c48d7e64d9560b" translate="yes" xml:space="preserve">
          <source>Note that the reflog history is very different from normal Git history. While normal history is shared by every repository that works on the same project, the reflog history is not shared: it tells you only about how the branches in your local repository have changed over time.</source>
          <target state="translated">请注意,reflog历史记录与普通的Git历史记录有很大不同。正常的历史记录是由同一项目的每个仓库共享的,而 reflog 历史记录则不是共享的:它只告诉你本地仓库中的分支随着时间的推移发生了什么变化。</target>
        </trans-unit>
        <trans-unit id="9a9c3b4049e20efd5a28033d7014008a8c2ac264" translate="yes" xml:space="preserve">
          <source>Note that the script (&lt;code&gt;my_script&lt;/code&gt; in the above example) should exit with code 0 if the current source code is good/old, and exit with a code between 1 and 127 (inclusive), except 125, if the current source code is bad/new.</source>
          <target state="translated">请注意，如果当前源代码良好/旧，则脚本（上例中的 &lt;code&gt;my_script&lt;/code&gt; ）应以代码0退出，而如果当前源代码不良/则应以1至127（含）之间的代码退出（125除外）。新。</target>
        </trans-unit>
        <trans-unit id="5586aefc0f8bd69c9dcf3cf3294d72d0db17f0fc" translate="yes" xml:space="preserve">
          <source>Note that the second point is true even across machines. You can duplicate a remote Git repository with &lt;strong&gt;any&lt;/strong&gt; regular copy mechanism, be it &lt;code&gt;scp&lt;/code&gt;, &lt;code&gt;rsync&lt;/code&gt; or &lt;code&gt;wget&lt;/code&gt;.</source>
          <target state="translated">请注意，即使在机器之间，第二点也是正确的。您可以使用&lt;strong&gt;任何&lt;/strong&gt;常规复制机制（例如 &lt;code&gt;scp&lt;/code&gt; ， &lt;code&gt;rsync&lt;/code&gt; 或 &lt;code&gt;wget&lt;/code&gt; )复制远程Git存储库。</target>
        </trans-unit>
        <trans-unit id="e9e6bb5468c99a3a334f80fab3dbb52fc16223c6" translate="yes" xml:space="preserve">
          <source>Note that the session-id of the child process is not available to the current/spawning process, so the child&amp;rsquo;s PID is reported here as a hint for post-processing. (But it is only a hint because the child process may be a shell script which doesn&amp;rsquo;t have a session-id.)</source>
          <target state="translated">请注意，子进程的session-id对当前/生成进程不可用，因此此处将报告子进程的PID作为后期处理的提示。（但这只是一个提示，因为子进程可能是一个没有会话ID的shell脚本。）</target>
        </trans-unit>
        <trans-unit id="e98f559f39ce7645bbbb14c50cc4f9c4dc239749" translate="yes" xml:space="preserve">
          <source>Note that the sizes of objects on disk are reported accurately, but care should be taken in drawing conclusions about which refs or objects are responsible for disk usage. The size of a packed non-delta object may be much larger than the size of objects which delta against it, but the choice of which object is the base and which is the delta is arbitrary and is subject to change during a repack.</source>
          <target state="translated">请注意,磁盘上对象的大小是准确报告的,但在得出关于哪个参考或对象对磁盘使用负责的结论时应小心。一个包装好的非delta对象的大小可能会比与其相对应的delta对象的大小大得多,但选择哪个对象是基础,哪个是delta是任意的,而且在重新包装时可能会改变。</target>
        </trans-unit>
        <trans-unit id="47fc7cad6a527b522ab5e266e3e278a07a579735" translate="yes" xml:space="preserve">
          <source>Note that the suffix you get if you type these commands today may be longer than what Linus saw above when he ran these commands, as your Git repository may have new commits whose object names begin with 975b that did not exist back then, and &quot;-g975b&quot; suffix alone may not be sufficient to disambiguate these commits.</source>
          <target state="translated">请注意,今天输入这些命令得到的后缀可能比 Linus 执行这些命令时看到的还要长,因为你的 Git 仓库中可能有新的提交,其对象名是以 975b 开头的,而这些提交在当时并不存在,仅靠&quot;-g975b &quot;后缀可能不足以混淆这些提交。</target>
        </trans-unit>
        <trans-unit id="7eeba5803dc504042af48f9504a175baa6f39016" translate="yes" xml:space="preserve">
          <source>Note that the target of a &lt;code&gt;push&lt;/code&gt; is normally a &lt;a href=&quot;#def_bare_repository&quot;&gt;bare&lt;/a&gt; repository. You can also push to a repository that has a checked-out working tree, but a push to update the currently checked-out branch is denied by default to prevent confusion. See the description of the receive.denyCurrentBranch option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">请注意， &lt;code&gt;push&lt;/code&gt; 的目标通常是&lt;a href=&quot;#def_bare_repository&quot;&gt;裸&lt;/a&gt;仓库。您也可以推送到具有签出工作树的存储库，但是默认情况下拒绝推送更新当前签出分支的操作​​，以免造成混淆。有关详细信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]中&lt;/a&gt;对receive.denyCurrentBranch选项的描述。</target>
        </trans-unit>
        <trans-unit id="110e365a18d2e41e53b11ff50c7bbd9d01eae2f0" translate="yes" xml:space="preserve">
          <source>Note that the two techniques outlined above (exporting via &lt;a href=&quot;#exporting-via-http&quot;&gt;http&lt;/a&gt; or &lt;a href=&quot;#exporting-via-git&quot;&gt;git&lt;/a&gt;) allow other maintainers to fetch your latest changes, but they do not allow write access, which you will need to update the public repository with the latest changes created in your private repository.</source>
          <target state="translated">请注意，上面概述的两种技术（通过&lt;a href=&quot;#exporting-via-http&quot;&gt;http&lt;/a&gt;或&lt;a href=&quot;#exporting-via-git&quot;&gt;git&lt;/a&gt;导出）允许其他维护者获取您的最新更改，但它们不允许写访问，您需要使用私有存储库中创建的最新更改来更新公共存储库。</target>
        </trans-unit>
        <trans-unit id="ae8ea7d3546a16ede3faa6039563fb0d737e4467" translate="yes" xml:space="preserve">
          <source>Note that the version which &lt;code&gt;git bisect&lt;/code&gt; checks out for you at each point is just a suggestion, and you&amp;rsquo;re free to try a different version if you think it would be a good idea. For example, occasionally you may land on a commit that broke something unrelated; run</source>
          <target state="translated">请注意， &lt;code&gt;git bisect&lt;/code&gt; 每次都为您签出的版本只是一个建议，如果您认为这是个好主意，则可以随意尝试使用其他版本。例如，有时您可能遇到了破坏了无关内容的提交；跑</target>
        </trans-unit>
        <trans-unit id="1000c60b0f402f5d9e4c69088fd79818a06e5e98" translate="yes" xml:space="preserve">
          <source>Note that there are two ways to checkout a particular branch. As described elsewhere on this page, the &quot;module&quot; parameter of cvs checkout is interpreted as a branch name, and it becomes the main branch. It remains the main branch for a given sandbox even if you temporarily make another branch sticky with cvs update -r. Alternatively, the -r argument can indicate some other branch to actually checkout, even though the module is still the &quot;main&quot; branch. Tradeoffs (as currently implemented): Each new &quot;module&quot; creates a new database on disk with a history for the given module, and after the database is created, operations against that main branch are fast. Or alternatively, -r doesn&amp;rsquo;t take any extra disk space, but may be significantly slower for many operations, like cvs update.</source>
          <target state="translated">请注意，有两种方法可以检出特定分支。如本页其他地方所述，cvs checkout的&amp;ldquo; module&amp;rdquo;参数被解释为分支名称，并且它成为主分支。即使您使用cvs update -r暂时使另一个分支保持粘性，它仍然是给定沙箱的主要分支。或者，-r参数可以指示其他要实际签出的分支，即使该模块仍然是&amp;ldquo;主&amp;rdquo;分支。权衡（当前实现）：每个新的&amp;ldquo;模块&amp;rdquo;都会在磁盘上创建一个新数据库，其中包含给定模块的历史记录，并且在创建数据库之后，针对该主分支的操作​​很快。或者，-r不会占用任何额外的磁盘空间，但是对于许多操作（例如cvs更新）可能会明显慢一些。</target>
        </trans-unit>
        <trans-unit id="4fe39a3f8a6c98b987fad41f0865478fee4d146d" translate="yes" xml:space="preserve">
          <source>Note that these are applied before commit ordering and formatting options, such as &lt;code&gt;--reverse&lt;/code&gt;.</source>
          <target state="translated">请注意，这些选项在提交顺序和格式选项（例如 &lt;code&gt;--reverse&lt;/code&gt; )之前应用。</target>
        </trans-unit>
        <trans-unit id="ccb8cdc33c08512e4436bbf3b8db5bc9921ae58d" translate="yes" xml:space="preserve">
          <source>Note that this affects all diff-based output types, e.g. those produced by &lt;code&gt;--stat&lt;/code&gt;, etc.</source>
          <target state="translated">请注意，这会影响所有基于差异的输出类型，例如 &lt;code&gt;--stat&lt;/code&gt; 等产生的类型。</target>
        </trans-unit>
        <trans-unit id="0691624d8498eccd40578875388b7f8bab2a7b6c" translate="yes" xml:space="preserve">
          <source>Note that this applies only to accessing the repository&amp;rsquo;s disk contents directly. An older client which understands only format &lt;code&gt;0&lt;/code&gt; may still connect via &lt;code&gt;git://&lt;/code&gt; to a repository using format &lt;code&gt;1&lt;/code&gt;, as long as the server process understands format &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">请注意，这仅适用于直接访问存储库的磁盘内容。只要服务器进程理解格式 &lt;code&gt;1&lt;/code&gt; ，只能理解格式 &lt;code&gt;0&lt;/code&gt; 的旧客户端仍可以通过 &lt;code&gt;git://&lt;/code&gt; 连接到使用格式 &lt;code&gt;1&lt;/code&gt; 的存储库。</target>
        </trans-unit>
        <trans-unit id="c3528bf60e5e55bcec2b34b4efbb66a2e2ad0ca9" translate="yes" xml:space="preserve">
          <source>Note that this assumes that none of the blobs and commit messages referenced by that revision range contains the string &lt;code&gt;refs/heads/master&lt;/code&gt;.</source>
          <target state="translated">请注意，这假定该修订范围引用的Blob和提交消息均不包含字符串 &lt;code&gt;refs/heads/master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2c1b09dd03782a35574f4220ce1860b1a59abed" translate="yes" xml:space="preserve">
          <source>Note that this configuration variable is ignored if it is seen in the repository-level config (this is a safety measure against fetching from untrusted repositories).</source>
          <target state="translated">请注意,如果在仓库级配置中看到这个配置变量,则会被忽略(这是为了防止从不受信任的仓库中获取的安全措施)。</target>
        </trans-unit>
        <trans-unit id="8243e24ce26ee48638bea5b267bba5916eee07a8" translate="yes" xml:space="preserve">
          <source>Note that this is currently only implemented for the client side of clones and fetches.</source>
          <target state="translated">需要注意的是,这一点目前只在克隆和获取的客户端实现。</target>
        </trans-unit>
        <trans-unit id="7278e2ca069b871494710e49f702957a299741e8" translate="yes" xml:space="preserve">
          <source>Note that this is the old file data; so the object that Git named in its response to the initial tree was a tree with a snapshot of the directory state that was recorded by the first commit.</source>
          <target state="translated">请注意,这是旧的文件数据;所以Git在响应初始树中命名的对象是一棵树,上面有第一次提交记录的目录状态快照。</target>
        </trans-unit>
        <trans-unit id="8524e2a4579b70a19e36821a3f8f1b43bac12c4a" translate="yes" xml:space="preserve">
          <source>Note that this list is non-comprehensive and not necessarily complete. For command-specific variables, you will find a more detailed description in the appropriate manual page.</source>
          <target state="translated">请注意,这个列表并不全面,也不一定完整。对于特定的命令变量,你可以在相应的手册页面找到更详细的描述。</target>
        </trans-unit>
        <trans-unit id="a06dd344c0e0f4252ac8d0d18c1815e7f413d617" translate="yes" xml:space="preserve">
          <source>Note that this may contain embedded LF or CRLF characters that are not escaped, so the event may spill across multiple lines.</source>
          <target state="translated">请注意,这可能包含没有转义的嵌入式LF或CRLF字符,因此事件可能会跨越多行。</target>
        </trans-unit>
        <trans-unit id="954610f540e4dda45ac67b28e742adb370b9dd1c" translate="yes" xml:space="preserve">
          <source>Note that this may mean that multiple Git commits are created for a single SVN revision.</source>
          <target state="translated">请注意,这可能意味着一个SVN修订版会有多个Git提交。</target>
        </trans-unit>
        <trans-unit id="69a24fcf6b082a94d6b3e16af2197fed496268e4" translate="yes" xml:space="preserve">
          <source>Note that this option is only useful if you are actually sending the emails and want to identify yourself as the sender, but retain the original author (and &lt;code&gt;git am&lt;/code&gt; will correctly pick up the in-body header). Note also that &lt;code&gt;git send-email&lt;/code&gt; already handles this transformation for you, and this option should not be used if you are feeding the result to &lt;code&gt;git send-email&lt;/code&gt;.</source>
          <target state="translated">请注意，此选项仅在您实际发送电子邮件并希望将自己标识为发件人但保留原始作者的情况下才有用（而 &lt;code&gt;git am&lt;/code&gt; 将正确提取体内标头）。另请注意， &lt;code&gt;git send-email&lt;/code&gt; 已经为您处理了此转换，如果 &lt;code&gt;git send-email&lt;/code&gt; 结果提供给git send-email，则不应使用此选项。</target>
        </trans-unit>
        <trans-unit id="d0a34c500aa8e9fdf22f16d59ae03a1a8711ff64" translate="yes" xml:space="preserve">
          <source>Note that this option uses the no overlay mode by default (see also &lt;code&gt;--overlay&lt;/code&gt;), and currently doesn&amp;rsquo;t support overlay mode.</source>
          <target state="translated">请注意，此选项默认情况下使用无覆盖模式（另请参阅 &lt;code&gt;--overlay&lt;/code&gt; ），并且当前不支持覆盖模式。</target>
        </trans-unit>
        <trans-unit id="e3aa2cd05420cf442d246cf6450d49e1768c842c" translate="yes" xml:space="preserve">
          <source>Note that this variable is honored even when set in a configuration file in a &quot;.git&quot; subdirectory of a directory and its value differs from the latter directory (e.g. &quot;/path/to/.git/config&quot; has core.worktree set to &quot;/different/path&quot;), which is most likely a misconfiguration. Running Git commands in the &quot;/path/to&quot; directory will still use &quot;/different/path&quot; as the root of the work tree and can cause confusion unless you know what you are doing (e.g. you are creating a read-only snapshot of the same index to a location different from the repository&amp;rsquo;s usual working tree).</source>
          <target state="translated">请注意，即使在目录的&amp;ldquo; .git&amp;rdquo;子目录中的配置文件中设置了该变量，它的值也与后者不同（例如，&amp;ldquo; / path / to / .git / config&amp;rdquo;将core.worktree设置为&amp;ldquo; / different / path&amp;rdquo;），很可能是配置错误。在&amp;ldquo; / path / to&amp;rdquo;目录中运行Git命令仍将使用&amp;ldquo; / different / path&amp;rdquo;作为工作树的根目录，除非您知道自己在做什么（例如，您正在创建一个只读快照），否则会引起混乱。与存储库通常的工作树不同的位置使用相同的索引）。</target>
        </trans-unit>
        <trans-unit id="f66853802a66e4aff14a38d5843516f4164ff5ba" translate="yes" xml:space="preserve">
          <source>Note that this will create the new branch, but it will not switch the working tree to it; use &quot;git switch &amp;lt;newbranch&amp;gt;&quot; to switch to the new branch.</source>
          <target state="translated">请注意，这将创建新分支，但不会将工作树切换到该分支。使用&amp;ldquo; git switch &amp;lt;newbranch&amp;gt;&amp;rdquo;切换到新分支。</target>
        </trans-unit>
        <trans-unit id="48c8adea213e6ac01f80c59a6b72ca8bc5d0c4be" translate="yes" xml:space="preserve">
          <source>Note that unreachable, packed objects will remain. If this is not desired, see &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;.</source>
          <target state="translated">请注意，无法到达的打包对象将保留。如果不希望这样做，请参见&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9c873a19166627d45cbe06c1e92f0fc64675a0f" translate="yes" xml:space="preserve">
          <source>Note that users fetching over dumb protocols will have to fetch the whole new pack in order to get any contained object, no matter how many other objects in that pack they already have locally.</source>
          <target state="translated">需要注意的是,用户通过哑巴协议取件时,必须取到整个新的包,才能得到任何包含的对象,不管他们在该包中已经有多少其他对象在本地。</target>
        </trans-unit>
        <trans-unit id="511b177ad0f4f309a1f22f8d5a0729bb57a27072" translate="yes" xml:space="preserve">
          <source>Note that we deliberately chose not to re-code the commit log message when a commit is made to force UTF-8 at the commit object level, because re-coding to UTF-8 is not necessarily a reversible operation.</source>
          <target state="translated">需要注意的是,当提交时,我们特意选择不对提交日志信息进行重新编码,在提交对象层面强制执行UTF-8,因为重新编码为UTF-8并不一定是可逆的操作。</target>
        </trans-unit>
        <trans-unit id="352feed71993cca2768c0de80ab4efdfef627645" translate="yes" xml:space="preserve">
          <source>Note that we pick a single island for each regex to go into, using &quot;last one wins&quot; ordering (which allows repo-specific config to take precedence over user-wide config, and so forth).</source>
          <target state="translated">需要注意的是,我们为每个regex挑选一个单独的岛,使用 &quot;最后一个获胜 &quot;的排序方式(允许repo特定的配置优先于用户范围的配置,等等)。</target>
        </trans-unit>
        <trans-unit id="0f413678af329d8b352f68927252d8a326f2b212" translate="yes" xml:space="preserve">
          <source>Note that when matching against a tree object, attributes are still obtained from working tree, not from the given tree object.</source>
          <target state="translated">请注意,当与树对象进行匹配时,属性仍然是从工作树中获取的,而不是从给定的树对象中获取的。</target>
        </trans-unit>
        <trans-unit id="6f16ff14e66ecdeaed0888755a04ec80e3903de7" translate="yes" xml:space="preserve">
          <source>Note that when providing a &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;, you must use &lt;code&gt;--list&lt;/code&gt;; otherwise the command may be interpreted as branch creation.</source>
          <target state="translated">请注意，提供 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 时，必须使用 &lt;code&gt;--list&lt;/code&gt; ；否则，该命令可以解释为分支创建。</target>
        </trans-unit>
        <trans-unit id="2e31fbecbd095ab339f753f545ee8ad3cdcfd7be" translate="yes" xml:space="preserve">
          <source>Note that when you&amp;rsquo;ve moved or copied a Git repository, your Git index file (which caches various information, notably some of the &quot;stat&quot; information for the files involved) will likely need to be refreshed. So after you do a &lt;code&gt;cp -a&lt;/code&gt; to create a new copy, you&amp;rsquo;ll want to do</source>
          <target state="translated">请注意，在移动或复制Git存储库后，可能需要刷新Git索引文件（该文件缓存各种信息，尤其是所涉及文件的某些&amp;ldquo;状态&amp;rdquo;信息）。因此，在执行 &lt;code&gt;cp -a&lt;/code&gt; 创建新副本之后，您将需要</target>
        </trans-unit>
        <trans-unit id="b6e7add23d70ae9c79a92003e95b0646493f7240" translate="yes" xml:space="preserve">
          <source>Note that without &lt;code&gt;--full-history&lt;/code&gt;, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked.</source>
          <target state="translated">请注意，如果没有 &lt;code&gt;--full-history&lt;/code&gt; ，这仍然会简化合并：如果父项之一是TREESAME，我们将仅遵循该父项，因此合并的另一端永远不会走。</target>
        </trans-unit>
        <trans-unit id="26c6b6e45f05961054f9762544f517daa6e3a44f" translate="yes" xml:space="preserve">
          <source>Note that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected.</source>
          <target state="translated">需要注意的是,如果不进行父子改写,还真谈不上承诺之间的父子关系,所以我们将其显示为断联。</target>
        </trans-unit>
        <trans-unit id="40996350a13d178ee15ae3215e9ae292d6702c1c" translate="yes" xml:space="preserve">
          <source>Note that you can get more information on a packfile by calling &lt;a href=&quot;git-verify-pack&quot;&gt;git-verify-pack[1]&lt;/a&gt;. However, as this command considers only the index file itself, it&amp;rsquo;s both faster and more flexible.</source>
          <target state="translated">请注意，您可以通过调用&lt;a href=&quot;git-verify-pack&quot;&gt;git-verify-pack [1]&lt;/a&gt;获得有关packfile的更多信息。但是，由于此命令仅考虑索引文件本身，因此既更快又更灵活。</target>
        </trans-unit>
        <trans-unit id="191247c1388c3f45dfe82bf6b2f0384fea86edc8" translate="yes" xml:space="preserve">
          <source>Note that you cannot generally put &lt;code&gt;git for-each-ref&lt;/code&gt; directly into the config value, as it does not take a repository path as an argument (but you can wrap the command above in a shell script).</source>
          <target state="translated">注意，通常不能将 &lt;code&gt;git for-each-ref&lt;/code&gt; 直接放入config值中，因为它没有将存储库路径作为参数（但是您可以将以上命令包装在shell脚本中）。</target>
        </trans-unit>
        <trans-unit id="0fb44a035d4df6f6306133b267ae1546e220d2ba" translate="yes" xml:space="preserve">
          <source>Note that you should not do Octopus just because you can. An octopus is a valid thing to do and often makes it easier to view the commit history if you are merging more than two independent changes at the same time. However, if you have merge conflicts with any of the branches you are merging in and need to hand resolve, that is an indication that the development happened in those branches were not independent after all, and you should merge two at a time, documenting how you resolved the conflicts, and the reason why you preferred changes made in one side over the other. Otherwise it would make the project history harder to follow, not easier.</source>
          <target state="translated">请注意,你不应该因为可以做章鱼就做章鱼。八爪鱼是一件很有效的事情,如果你同时合并了两个以上的独立变化,它通常会让你更容易查看提交历史。但是,如果你在合并的任何一个分支有合并冲突,需要手工解决,那就说明这些分支发生的开发毕竟不是独立的,你应该一次合并两个,记录下你是如何解决冲突的,以及你更倾向于一方所做的改动而不是另一方的原因。否则会使项目历史更难遵循,而不是更容易。</target>
        </trans-unit>
        <trans-unit id="482be6a864fbdcc5f9a936e9708b6d9c3eb14ff5" translate="yes" xml:space="preserve">
          <source>Note the addition of the &lt;code&gt;+&lt;/code&gt; sign. Alternatively, you can use the &lt;code&gt;-f&lt;/code&gt; flag to force the remote update, as in:</source>
          <target state="translated">请注意 &lt;code&gt;+&lt;/code&gt; 号的添加。或者，您可以使用 &lt;code&gt;-f&lt;/code&gt; 标志来强制进行远程更新，如下所示：</target>
        </trans-unit>
        <trans-unit id="c14d9654c43dfc38c5ce0e390578cf211f8eb175" translate="yes" xml:space="preserve">
          <source>Note the addition of the &lt;code&gt;+&lt;/code&gt; sign. Alternatively, you can use the &lt;code&gt;-f&lt;/code&gt; flag to force updates of all the fetched branches, as in:</source>
          <target state="translated">请注意 &lt;code&gt;+&lt;/code&gt; 号的添加。或者，您可以使用 &lt;code&gt;-f&lt;/code&gt; 标志来强制更新所有获取的分支，如下所示：</target>
        </trans-unit>
        <trans-unit id="2261964ad436001973909975a060cb501a98c780" translate="yes" xml:space="preserve">
          <source>Note the last point. Do &lt;code&gt;not&lt;/code&gt; use &lt;code&gt;git pull&lt;/code&gt; unless you actually want to merge the remote branch.</source>
          <target state="translated">注意最后一点。千万 &lt;code&gt;not&lt;/code&gt; 使用 &lt;code&gt;git pull&lt;/code&gt; ，除非你确实要合并的远程分支。</target>
        </trans-unit>
        <trans-unit id="b5d534f9876445dbbed162e13c3b9e1bade912b4" translate="yes" xml:space="preserve">
          <source>Note the major differences in &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, and &lt;code&gt;Q&lt;/code&gt; over &lt;code&gt;--full-history&lt;/code&gt;:</source>
          <target state="translated">请注意，在重大分歧 &lt;code&gt;N&lt;/code&gt; ， &lt;code&gt;P&lt;/code&gt; 和 &lt;code&gt;Q&lt;/code&gt; 在 &lt;code&gt;--full-history&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="592ed4ba86d62c504859114fd8d03df0827a06fa" translate="yes" xml:space="preserve">
          <source>Note the quotes around &lt;code&gt;*.c&lt;/code&gt;. The file &lt;code&gt;hello.c&lt;/code&gt; will also be checked out, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell).</source>
          <target state="translated">注意 &lt;code&gt;*.c&lt;/code&gt; 周围的引号。即使文件 &lt;code&gt;hello.c&lt;/code&gt; 不再存在于工作树中，也将被检出，这是因为文件globbing用于匹配索引中的条目（而不是外壳程序在工作树中的条目）。</target>
        </trans-unit>
        <trans-unit id="d840183324e7e2c4b1d9b149ae89bf837a67da9c" translate="yes" xml:space="preserve">
          <source>Note the quotes around &lt;code&gt;*.c&lt;/code&gt;. The file &lt;code&gt;hello.c&lt;/code&gt; will also be restored, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell).</source>
          <target state="translated">注意 &lt;code&gt;*.c&lt;/code&gt; 周围的引号。即使文件 &lt;code&gt;hello.c&lt;/code&gt; 不再位于工作树中，也将被还原，因为文件globbing用于匹配索引中的条目（而不是外壳程序在工作树中的条目）。</target>
        </trans-unit>
        <trans-unit id="86811ec658abf1645177c2f89c78cd1610e7ea04" translate="yes" xml:space="preserve">
          <source>Note what happens to the different &lt;code&gt;git diff-*&lt;/code&gt; versions here. After we&amp;rsquo;ve updated &lt;code&gt;hello&lt;/code&gt; in the index, &lt;code&gt;git diff-files -p&lt;/code&gt; now shows no differences, but &lt;code&gt;git diff-index -p HEAD&lt;/code&gt; still &lt;strong&gt;does&lt;/strong&gt; show that the current state is different from the state we committed. In fact, now &lt;code&gt;git diff-index&lt;/code&gt; shows the same difference whether we use the &lt;code&gt;--cached&lt;/code&gt; flag or not, since now the index is coherent with the working tree.</source>
          <target state="translated">注意这里不同的 &lt;code&gt;git diff-*&lt;/code&gt; 版本会发生什么。我们更新后 &lt;code&gt;hello&lt;/code&gt; 索引， &lt;code&gt;git diff-files -p&lt;/code&gt; 现在显示无显着差异，但 &lt;code&gt;git diff-index -p HEAD&lt;/code&gt; 仍然&lt;strong&gt;不&lt;/strong&gt;表明当前的状态是我们犯下的状态不同。实际上，无论是否使用 &lt;code&gt;--cached&lt;/code&gt; 标志，现在 &lt;code&gt;git diff-index&lt;/code&gt; 都显示相同的区别，因为现在索引与工作树是一致的。</target>
        </trans-unit>
        <trans-unit id="c96f5bf9205aae211cb148d5f8bcf4fb9ebed15b" translate="yes" xml:space="preserve">
          <source>Note, by the way, that lots of commands take a tree as an argument. But as we can see above, a tree can be referred to in many different ways&amp;mdash;​by the SHA-1 name for that tree, by the name of a commit that refers to the tree, by the name of a branch whose head refers to that tree, etc.--and most such commands can accept any of these names.</source>
          <target state="translated">请注意，顺便说一句，许多命令都将树作为参数。但是正如我们在上面看到的那样，可以用许多不同的方式来引用树-通过树的SHA-1名称，通过引用树的提交名称，通过其头部引用的分支的名称来引用到该树等），并且大多数此类命令可以接受这些名称中的任何一个。</target>
        </trans-unit>
        <trans-unit id="ba28d9bd22f696c9f9b774765c5cbeba6fcd1342" translate="yes" xml:space="preserve">
          <source>Note, for the reasons stated above usage of context-free patches is discouraged.</source>
          <target state="translated">请注意,基于上述原因,不鼓励使用无上下文补丁。</target>
        </trans-unit>
        <trans-unit id="22eddd855ac86c24360d06b5276ff8c7e192d879" translate="yes" xml:space="preserve">
          <source>Note, this safety check does not mean that a checkout will generate a file identical to the original file for a different setting of &lt;code&gt;core.eol&lt;/code&gt; and &lt;code&gt;core.autocrlf&lt;/code&gt;, but only for the current one. For example, a text file with &lt;code&gt;LF&lt;/code&gt; would be accepted with &lt;code&gt;core.eol=lf&lt;/code&gt; and could later be checked out with &lt;code&gt;core.eol=crlf&lt;/code&gt;, in which case the resulting file would contain &lt;code&gt;CRLF&lt;/code&gt;, although the original file contained &lt;code&gt;LF&lt;/code&gt;. However, in both work trees the line endings would be consistent, that is either all &lt;code&gt;LF&lt;/code&gt; or all &lt;code&gt;CRLF&lt;/code&gt;, but never mixed. A file with mixed line endings would be reported by the &lt;code&gt;core.safecrlf&lt;/code&gt; mechanism.</source>
          <target state="translated">请注意，此安全检查并不意味着对于不同的 &lt;code&gt;core.eol&lt;/code&gt; 和 &lt;code&gt;core.autocrlf&lt;/code&gt; 设置，签出将生成与原始文件相同的文件，而仅针对当前文件。例如，带有 &lt;code&gt;LF&lt;/code&gt; 的文本文件将被 &lt;code&gt;core.eol=lf&lt;/code&gt; 接受，随后可以被 &lt;code&gt;core.eol=crlf&lt;/code&gt; 检出，在这种情况下，尽管原始文件包含 &lt;code&gt;LF&lt;/code&gt; ，但结果文件将包含 &lt;code&gt;CRLF&lt;/code&gt; 。但是，在两个工作树中，行尾都是一致的，即全部为 &lt;code&gt;LF&lt;/code&gt; 或全部为 &lt;code&gt;CRLF&lt;/code&gt; ，但绝不混合。 &lt;code&gt;core.safecrlf&lt;/code&gt; 将报告包含混合行尾的文件 机制。</target>
        </trans-unit>
        <trans-unit id="955b317bd13857ee21eddce08c9664927a950a2e" translate="yes" xml:space="preserve">
          <source>Note. A single level of backslashes are eaten by the configuration file parser, so you would need to double the backslashes; the pattern above picks a line that begins with a backslash, and zero or more occurrences of &lt;code&gt;sub&lt;/code&gt; followed by &lt;code&gt;section&lt;/code&gt; followed by open brace, to the end of line.</source>
          <target state="translated">注意。配置文件解析器只使用一个级别的反斜杠，因此您需要将反斜杠加倍。上面的模式选择以反斜杠开头的行，然后出现零次或多次出现 &lt;code&gt;sub&lt;/code&gt; ,然后是 &lt;code&gt;section&lt;/code&gt; ,然后是大括号，直到行尾。</target>
        </trans-unit>
        <trans-unit id="c3a8d5b6840faaf677f5d3f6a79125e45b041b0b" translate="yes" xml:space="preserve">
          <source>Note. When the &quot;-C&quot; option is used with &lt;code&gt;--find-copies-harder&lt;/code&gt; option, &lt;code&gt;git diff-*&lt;/code&gt; commands feed unmodified filepairs to diffcore mechanism as well as modified ones. This lets the copy detector consider unmodified files as copy source candidates at the expense of making it slower. Without &lt;code&gt;--find-copies-harder&lt;/code&gt;, &lt;code&gt;git diff-*&lt;/code&gt; commands can detect copies only if the file that was copied happened to have been modified in the same changeset.</source>
          <target state="translated">注意。当&amp;ldquo; -C&amp;rdquo;选项与 &lt;code&gt;--find-copies-harder&lt;/code&gt; 选项一起使用时， &lt;code&gt;git diff-*&lt;/code&gt; 命令将未修改的文件对以及已修改的文件对馈入diffcore机制。这使复制检测器将未修改的文件视为候选复制源，但代价是使其变慢。如果没有 &lt;code&gt;--find-copies-harder&lt;/code&gt; &lt;code&gt;git diff-*&lt;/code&gt; ，则git diff- *命令仅在复制的文件碰巧已在同一变更集中被修改时，才能检测到副本。</target>
        </trans-unit>
        <trans-unit id="9ed1ac27dff5378ed96f590f4322050a04cabf6d" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;git revert&lt;/code&gt; is used to record some new commits to reverse the effect of some earlier commits (often only a faulty one). If you want to throw away all uncommitted changes in your working directory, you should see &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;, particularly the &lt;code&gt;--hard&lt;/code&gt; option. If you want to extract specific files as they were in another commit, you should see &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;, specifically the &lt;code&gt;--source&lt;/code&gt; option. Take care with these alternatives as both will discard uncommitted changes in your working directory.</source>
          <target state="translated">注意： &lt;code&gt;git revert&lt;/code&gt; 用于记录一些新的提交，以逆转某些较早提交的效果（通常只有一个错误的提交）。如果要丢弃工作目录中所有未提交的更改，则应看到&lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt;，尤其是 &lt;code&gt;--hard&lt;/code&gt; 选项。如果要提取特定文件，就像在另一个提交中一样，则应该看到&lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt;，特别是 &lt;code&gt;--source&lt;/code&gt; 选项。请谨慎使用这些替代方法，因为这两种方法都会丢弃工作目录中未提交的更改。</target>
        </trans-unit>
        <trans-unit id="6007883f602581f1393822506c41cbfbfd02c805" translate="yes" xml:space="preserve">
          <source>Note: A thin pack violates the packed archive format by omitting required objects and is thus unusable by Git without making it self-contained. Use &lt;code&gt;git index-pack --fix-thin&lt;/code&gt; (see &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack[1]&lt;/a&gt;) to restore the self-contained property.</source>
          <target state="translated">注意：精简包通过省略必需的对象而违反了打包的存档格式，因此，如果不使其独立，则Git无法使用它。使用 &lt;code&gt;git index-pack --fix-thin&lt;/code&gt; （请参阅&lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack [1]&lt;/a&gt;）恢复独立的属性。</target>
        </trans-unit>
        <trans-unit id="1f8f5701942fbb7ebefa9dee3f4f37f4528c7cfd" translate="yes" xml:space="preserve">
          <source>Note: Make sure you quote the result when passing it to &lt;code&gt;eval&lt;/code&gt;. See below for an example.</source>
          <target state="translated">注意：确保将结果传递给 &lt;code&gt;eval&lt;/code&gt; 时引用它。请参阅下面的示例。</target>
        </trans-unit>
        <trans-unit id="b0f0e4e61a2bb004cf3ec68d5169e8ba972a47ee" translate="yes" xml:space="preserve">
          <source>Note: Newer CVS versions (&amp;gt;= 1.12.11) also support specifying CVS_SERVER directly in CVSROOT like</source>
          <target state="translated">注意：较新的CVS版本（&amp;gt; = 1.12.11）也支持直接在CVSROOT中指定CVS_SERVER，例如</target>
        </trans-unit>
        <trans-unit id="b833243d544e1089f2767ea8843cab2eed5526b2" translate="yes" xml:space="preserve">
          <source>Note: Porcelain commands such as &lt;code&gt;git gc&lt;/code&gt; (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;), &lt;code&gt;git repack&lt;/code&gt; (see &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;) pass this option by default in modern Git when they put objects in your repository into pack files. So does &lt;code&gt;git bundle&lt;/code&gt; (see &lt;a href=&quot;git-bundle&quot;&gt;git-bundle[1]&lt;/a&gt;) when it creates a bundle.</source>
          <target state="translated">注意：诸如 &lt;code&gt;git gc&lt;/code&gt; （请参阅&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;）， &lt;code&gt;git repack&lt;/code&gt; （请参阅&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;）之类的瓷器命令在将存储库中的对象放入打包文件时，默认情况下会通过此选项。 &lt;code&gt;git bundle&lt;/code&gt; 创建捆绑时也是如此（请参阅&lt;a href=&quot;git-bundle&quot;&gt;git-bundle [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7a04bc9af081bc88d648e6675a2308737bd31c23" translate="yes" xml:space="preserve">
          <source>Note: Some inetd servers let you specify the name of the executable independently of the value of argv[0] (i.e. the name the program assumes it was executed with). In this case the correct line in /etc/inetd.conf looks like</source>
          <target state="translated">注意:有些 inetd 服务器允许你指定可执行文件的名称,而不是 argv[0]的值 (也就是程序假设执行时的名称)。在这种情况下,/etc/inetd.conf中的正确行数是这样的</target>
        </trans-unit>
        <trans-unit id="722ccad077353010f3a3bf5b634c417679782a2c" translate="yes" xml:space="preserve">
          <source>Note: Whenever the clean filter is changed, the repo should be renormalized: $ git add --renormalize .</source>
          <target state="translated">注意:无论何时改变清洁过滤器,都应该对repo进行重新归一化:$ git add --renormalize 。</target>
        </trans-unit>
        <trans-unit id="e979029bca285fbda95b190d7e0a6ad42b034f7b" translate="yes" xml:space="preserve">
          <source>Note: the first command (&lt;code&gt;label onto&lt;/code&gt;) labels the revision onto which the commits are rebased; The name &lt;code&gt;onto&lt;/code&gt; is just a convention, as a nod to the &lt;code&gt;--onto&lt;/code&gt; option.</source>
          <target state="translated">注意：第一个命令（ &lt;code&gt;label onto&lt;/code&gt; ）标记提交所依据的修订版本；名称 &lt;code&gt;onto&lt;/code&gt; 的名称只是约定，这是对 &lt;code&gt;--onto&lt;/code&gt; 选项的致意。</target>
        </trans-unit>
        <trans-unit id="c1bc321618eb470344ec0a0359d287ae90474ae5" translate="yes" xml:space="preserve">
          <source>Note: the following core Perl modules that may be installed with your distribution of Perl are required: MIME::Base64, MIME::QuotedPrint, Net::Domain and Net::SMTP. These additional Perl modules are also required: Authen::SASL and Mail::Address.</source>
          <target state="translated">注意:以下是需要安装在你的Perl发行版中的核心Perl模块。MIME::Base64,MIME::QuotedPrint,Net::Domain 和 Net::SMTP。这些附加的Perl模块也是必须的。Authen::SASL 和 Mail::Address。</target>
        </trans-unit>
        <trans-unit id="9ca0395056bb808a73d2de7297fac7a555e73c25" translate="yes" xml:space="preserve">
          <source>Note: you can specify the default pretty format in the repository configuration (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">注意：您可以在存储库配置中指定默认的漂亮格式（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="399df4ce8f932f9b96c0fdefbfc88e37bceafef0" translate="yes" xml:space="preserve">
          <source>Note: you need to ensure each user that is going to invoke &lt;code&gt;git-cvsserver&lt;/code&gt; has write access to the log file and to the database (see &lt;a href=&quot;#dbbackend&quot;&gt;Database Backend&lt;/a&gt;. If you want to offer write access over SSH, the users of course also need write access to the Git repository itself.</source>
          <target state="translated">注意：您需要确保每个将要调用 &lt;code&gt;git-cvsserver&lt;/code&gt; 的用户都具有对日志文件和数据库的写访问权限（请参阅&lt;a href=&quot;#dbbackend&quot;&gt;数据库后端&lt;/a&gt;。如果要通过SSH提供写访问权限，那么这些用户当然也需要写访问权限到Git仓库本身。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="803fb7d2ab5d83b44291b7856ec7ac09a4ad4990" translate="yes" xml:space="preserve">
          <source>Notes can also be added to patches prepared with &lt;code&gt;git format-patch&lt;/code&gt; by using the &lt;code&gt;--notes&lt;/code&gt; option. Such notes are added as a patch commentary after a three dash separator line.</source>
          <target state="translated">也可以使用 &lt;code&gt;--notes&lt;/code&gt; 选项将注释添加到使用 &lt;code&gt;git format-patch&lt;/code&gt; 准备的修补程序中。这些注释在三横线分隔线之后作为补丁注释添加。</target>
        </trans-unit>
        <trans-unit id="680f18d9848c14869bd7dca451d5f596480f4677" translate="yes" xml:space="preserve">
          <source>Notes merge strategies</source>
          <target state="translated">注释合并策略</target>
        </trans-unit>
        <trans-unit id="abd4e292c73314f22de94f0e2806350a1ebe4452" translate="yes" xml:space="preserve">
          <source>Notes on frequently confused options</source>
          <target state="translated">关于经常混淆的选项的说明</target>
        </trans-unit>
        <trans-unit id="f5aa58376045f00b2abde3758c9ee9232861fade" translate="yes" xml:space="preserve">
          <source>Notes ref to read and manipulate instead of &lt;code&gt;refs/notes/commits&lt;/code&gt;. Must be an unabbreviated ref name. This setting can be overridden through the environment and command line.</source>
          <target state="translated">Notes ref可以读取和操作，而不是 &lt;code&gt;refs/notes/commits&lt;/code&gt; 。必须是缩写的引用名称。可以通过环境和命令行覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="27c7345a105341e9d7ed2a9f6b06c674d31c0796" translate="yes" xml:space="preserve">
          <source>Notice all types of potential whitespace errors known to Git. The tab width is taken from the value of the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable.</source>
          <target state="translated">注意Git已知的所有类型的潜在空白错误。制表符宽度取自 &lt;code&gt;core.whitespace&lt;/code&gt; 配置变量的值。</target>
        </trans-unit>
        <trans-unit id="b1fa74b0ca5d38d82ab602be416ab241bc186864" translate="yes" xml:space="preserve">
          <source>Notice that regardless of which checkout command we use, &lt;code&gt;HEAD&lt;/code&gt; now refers directly to commit &lt;code&gt;b&lt;/code&gt;. This is known as being in detached &lt;code&gt;HEAD&lt;/code&gt; state. It means simply that &lt;code&gt;HEAD&lt;/code&gt; refers to a specific commit, as opposed to referring to a named branch. Let&amp;rsquo;s see what happens when we create a commit:</source>
          <target state="translated">注意，无论我们使用哪种checkout命令， &lt;code&gt;HEAD&lt;/code&gt; 现在都直接引用commit &lt;code&gt;b&lt;/code&gt; 。这称为处于分离 &lt;code&gt;HEAD&lt;/code&gt; 状态。这仅表示 &lt;code&gt;HEAD&lt;/code&gt; 引用了特定的提交，而不是引用了命名分支。让我们看看创建提交时会发生什么：</target>
        </trans-unit>
        <trans-unit id="223ae08c12689ce4cda40425ac912a2b7bc15955" translate="yes" xml:space="preserve">
          <source>Notify the helper this is a clone request (i.e. the current repository is guaranteed empty).</source>
          <target state="translated">通知帮助者这是一个克隆请求(即保证当前仓库是空的)。</target>
        </trans-unit>
        <trans-unit id="4abfc187ad76ac88063d3dc9dd98a5854ac68fcf" translate="yes" xml:space="preserve">
          <source>Now add the changes to the index that you want to have in the first commit. You can use &lt;code&gt;git add&lt;/code&gt; (possibly interactively) or &lt;code&gt;git gui&lt;/code&gt; (or both) to do that.</source>
          <target state="translated">现在，将更改添加到您希望在第一次提交中拥有的索引。您可以使用 &lt;code&gt;git add&lt;/code&gt; （可能是交互方式）或 &lt;code&gt;git gui&lt;/code&gt; （或两者都使用）来做到这一点。</target>
        </trans-unit>
        <trans-unit id="f89d262ba51a934099d56714cbb679d531203dd2" translate="yes" xml:space="preserve">
          <source>Now clone the superproject:</source>
          <target state="translated">现在克隆超级项目。</target>
        </trans-unit>
        <trans-unit id="ba793c9ae00cb4d237b36de220bcaff0d64b7a28" translate="yes" xml:space="preserve">
          <source>Now create the branches in which you are going to work; these start out at the current tip of origin/master branch, and should be set up (using the &lt;code&gt;--track&lt;/code&gt; option to &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;) to merge changes in from Linus by default.</source>
          <target state="translated">现在创建要在其中工作的分支；这些开始于当前的origin / master分支尖端，并且应该进行设置（使用&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;的 &lt;code&gt;--track&lt;/code&gt; 选项）以默认情况下合并来自Linus的更改。</target>
        </trans-unit>
        <trans-unit id="b3aa6a5493fd6ad1a98101f846b1686abf42b2c1" translate="yes" xml:space="preserve">
          <source>Now create the superproject and add all the submodules:</source>
          <target state="translated">现在创建超级项目并添加所有的子模块。</target>
        </trans-unit>
        <trans-unit id="aec2ee2ebf7f0a1017c29bcb872a25ae6bf7b23d" translate="yes" xml:space="preserve">
          <source>Now is a good point to take a break to let this information sink in.</source>
          <target state="translated">现在是一个很好的点,可以休息一下,让这些信息沉淀下来。</target>
        </trans-unit>
        <trans-unit id="8125d3bd8f5c390de8746d2ef58ce50b7de72c0b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s suppose that commit J is bad and commit G is good and that we apply the bisection algorithm like it has been previously described.</source>
          <target state="translated">现在让我们假设提交J是错误的，提交G是良好的，并且像前面已经描述的那样应用了二等分算法。</target>
        </trans-unit>
        <trans-unit id="880aeec71bcb81a6f397f1be442543fc2e21cab4" translate="yes" xml:space="preserve">
          <source>Now suppose that Joe wants his middle name initial used, and Jane prefers her family name fully spelled out. A proper &lt;code&gt;.mailmap&lt;/code&gt; file would look like:</source>
          <target state="translated">现在假设Joe希望使用他的中间名作为首字母缩写，而Jane则希望将她的姓氏写清楚。正确的 &lt;code&gt;.mailmap&lt;/code&gt; 文件如下所示：</target>
        </trans-unit>
        <trans-unit id="3e7c06961fbf7a9468c5f87e472b9bdf95e1fa5a" translate="yes" xml:space="preserve">
          <source>Now to apply some patches from the community. Think of a short snappy name for a branch to hold this patch (or related group of patches), and create a new branch from a recent stable tag of Linus&amp;rsquo;s branch. Picking a stable base for your branch will: 1) help you: by avoiding inclusion of unrelated and perhaps lightly tested changes 2) help future bug hunters that use &lt;code&gt;git bisect&lt;/code&gt; to find problems</source>
          <target state="translated">现在应用社区中的一些补丁。想一个分支的简短活泼名称来保存此补丁程序（或相关的补丁程序组），然后根据Linus分支的最近稳定标记创建一个新分支。挑选一个稳定的基地，为您的分支将：1）帮助您：通过避免无关包容，或许轻轻测试变化2）使用帮助未来的bug猎人 &lt;code&gt;git bisect&lt;/code&gt; 发现问题</target>
        </trans-unit>
        <trans-unit id="31a13e21421ef92e8ef4a0a89bea77231f7d36fb" translate="yes" xml:space="preserve">
          <source>Now use &lt;code&gt;git submodule update&lt;/code&gt; to clone the repositories and check out the commits specified in the superproject:</source>
          <target state="translated">现在使用 &lt;code&gt;git submodule update&lt;/code&gt; 克隆存储库，并检查超级项目中指定的提交：</target>
        </trans-unit>
        <trans-unit id="93f7a0302cd464e3e88673ccf5b8a8b034507a50" translate="yes" xml:space="preserve">
          <source>Now we are ready to experiment with the merge by hand.</source>
          <target state="translated">现在我们准备用手来实验合并。</target>
        </trans-unit>
        <trans-unit id="0479e792f6adb8abb7cacffe33ca0f7a5b48ab2f" translate="yes" xml:space="preserve">
          <source>Now we will suppose that there is only one &quot;first bad commit&quot;. This means that all its descendants are &quot;bad&quot; and all the other commits are &quot;good&quot;. And we will suppose that all commits have an equal probability of being good or bad, or of being the first bad commit, so knowing the state of c commits gives always the same amount of information wherever these c commits are on the graph and whatever c is. (So we suppose that these commits being for example on a branch or near a good or a bad commit does not give more or less information).</source>
          <target state="translated">现在我们假设只有一个 &quot;第一个坏的提交&quot;。这意味着它的所有子孙都是 &quot;坏 &quot;的,而所有其他的提交都是 &quot;好 &quot;的。我们假设所有的提交都有相同的概率是好的或坏的,或者是第一个坏的提交,所以知道c个提交的状态,无论这些c个提交在图上的什么地方,也无论c是什么,得到的信息量总是相同的。(所以我们假设这些提交在一个分支上,或者靠近一个好的或坏的提交,并不会提供更多或更少的信息)。</target>
        </trans-unit>
        <trans-unit id="16cb16561e679da512d88420e76326b5c722ec8f" translate="yes" xml:space="preserve">
          <source>Now when the background process runs &lt;code&gt;git fetch origin&lt;/code&gt; the references on &lt;code&gt;origin-push&lt;/code&gt; won&amp;rsquo;t be updated, and thus commands like:</source>
          <target state="translated">现在，当后台进程运行 &lt;code&gt;git fetch origin&lt;/code&gt; 时， &lt;code&gt;origin-push&lt;/code&gt; 上的引用将不会更新，因此命令如下：</target>
        </trans-unit>
        <trans-unit id="3ecf9739a1d0abf420c43be7ddca1b7fc46c48f7" translate="yes" xml:space="preserve">
          <source>Now you apply the patch(es), run some tests, and commit the change(s). If the patch is a multi-part series, then you should apply each as a separate commit to this branch.</source>
          <target state="translated">现在,您可以应用这些补丁,运行一些测试,然后提交这些更改。如果这个补丁是一个多部分的系列,那么你应该将每个补丁作为一个单独的提交提交到这个分支。</target>
        </trans-unit>
        <trans-unit id="ac8b110d69f8df7d9503ad0a18549a8731f4daf9" translate="yes" xml:space="preserve">
          <source>Now you are wiser, because you know that it happened 940 revisions before v0.99.</source>
          <target state="translated">现在你聪明了,因为你知道在v0.99之前发生了940次修订。</target>
        </trans-unit>
        <trans-unit id="54796c29834d872153c55921bf00540d7c6165a5" translate="yes" xml:space="preserve">
          <source>Now you can proceed with the creation of the feature release. Apply a tag to the tip of &lt;code&gt;master&lt;/code&gt; indicating the release version:</source>
          <target state="translated">现在，您可以继续创建功能版本。在 &lt;code&gt;master&lt;/code&gt; 版的顶端应用标签，以指示发行版本：</target>
        </trans-unit>
        <trans-unit id="d60447094204d4dec9840c772eacade572f28205" translate="yes" xml:space="preserve">
          <source>Now you know that blob 4b9458b3 is missing, and that the tree 2d9263c6 points to it. If you could find just one copy of that missing blob object, possibly in some other repository, you could move it into &lt;code&gt;.git/objects/4b/9458b3&amp;hellip;​&lt;/code&gt; and be done. Suppose you can&amp;rsquo;t. You can still examine the tree that pointed to it with &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt;, which might output something like:</source>
          <target state="translated">现在您知道缺少blob 4b9458b3，并且树2d9263c6指向它。如果你能找到只有一个失踪Blob对象的副本，可能在其他一些库，你可以将其移动到 &lt;code&gt;.git/objects/4b/9458b3&amp;hellip;​&lt;/code&gt; 和完成。假设你做不到。您仍然可以使用&lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt;检查指向它的树，该树可能会输出以下内容：</target>
        </trans-unit>
        <trans-unit id="c93b9bdc902ddf8466cfefc51dc1f28429545152" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;ve split out many of the changes into their own commits, and might no longer use the patch mode of &lt;code&gt;git add&lt;/code&gt;, in order to select all remaining uncommitted changes.</source>
          <target state="translated">现在，您已将许多更改拆分为自己的提交，并且可能不再使用 &lt;code&gt;git add&lt;/code&gt; 的修补程序模式来选择所有剩余的未提交的更改。</target>
        </trans-unit>
        <trans-unit id="69b6ae43249b3d4c8e61d7b20084413cd49e5e3e" translate="yes" xml:space="preserve">
          <source>Now, for the meat:</source>
          <target state="translated">现在,对于肉。</target>
        </trans-unit>
        <trans-unit id="4449e60d3fdd6703a4970ef116187e4c17d80dc4" translate="yes" xml:space="preserve">
          <source>Now, in this case we&amp;rsquo;ve intentionally created a situation where the merge will need to be fixed up by hand, though, so Git will do as much of it as it can automatically (which in this case is just merge the &lt;code&gt;example&lt;/code&gt; file, which had no differences in the &lt;code&gt;mybranch&lt;/code&gt; branch), and say:</source>
          <target state="translated">现在，在这种情况下，我们故意创建了一种情况，需要手动解决合并问题，因此Git会自动执行尽可能多的操作（在这种情况下，只是合并 &lt;code&gt;example&lt;/code&gt; 文件，在 &lt;code&gt;mybranch&lt;/code&gt; 分支中没有任何区别），然后说：</target>
        </trans-unit>
        <trans-unit id="93036e7630aadf8fab80b9b1079ffb3d1ea1e18f" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s pretend you are the one who did all the work in &lt;code&gt;mybranch&lt;/code&gt;, and the fruit of your hard work has finally been merged to the &lt;code&gt;master&lt;/code&gt; branch. Let&amp;rsquo;s go back to &lt;code&gt;mybranch&lt;/code&gt;, and run &lt;code&gt;git merge&lt;/code&gt; to get the &quot;upstream changes&quot; back to your branch.</source>
          <target state="translated">现在，让我们假设您是在 &lt;code&gt;mybranch&lt;/code&gt; 中完成所有工作的人，而您辛勤工作的成果终于被合并到 &lt;code&gt;master&lt;/code&gt; 分支中。让我们回到 &lt;code&gt;mybranch&lt;/code&gt; ，然后运行 &lt;code&gt;git merge&lt;/code&gt; 将&amp;ldquo;上游更改&amp;rdquo;返回到您的分支。</target>
        </trans-unit>
        <trans-unit id="7c23965b9cba90dec960d959f0eea85b60ea2b28" translate="yes" xml:space="preserve">
          <source>Now, since we&amp;rsquo;ve updated &lt;code&gt;hello&lt;/code&gt; in the index, we can commit the new version. We could do it by writing the tree by hand again, and committing the tree (this time we&amp;rsquo;d have to use the &lt;code&gt;-p HEAD&lt;/code&gt; flag to tell commit that the HEAD was the &lt;strong&gt;parent&lt;/strong&gt; of the new commit, and that this wasn&amp;rsquo;t an initial commit any more), but you&amp;rsquo;ve done that once already, so let&amp;rsquo;s just use the helpful script this time:</source>
          <target state="translated">现在，由于我们已经更新了索引中的 &lt;code&gt;hello&lt;/code&gt; ，因此可以提交新版本。我们可以通过再次手动编写树并提交树来完成此操作（这一次，我们必须使用 &lt;code&gt;-p HEAD&lt;/code&gt; 标志来告诉提交HEAD是新提交的&lt;strong&gt;父级&lt;/strong&gt;，而这不是再进行一次初始提交），但您已经完成了一次，因此，这次我们只使用有用的脚本：</target>
        </trans-unit>
        <trans-unit id="dfab069f398c1bff7a8b8aa3dadd95d2ce84088a" translate="yes" xml:space="preserve">
          <source>Now, to make it a bit more interesting, let&amp;rsquo;s assume that somebody else does some work in the original branch, and simulate that by going back to the master branch, and editing the same file differently there:</source>
          <target state="translated">现在，让它变得更有趣，让我们假设其他人在原始分支中做了一些工作，并通过回到master分支并在那里不同地编辑相同文件来模拟该工作：</target>
        </trans-unit>
        <trans-unit id="83bf1df5f5028baeb9804ff8b012e2bfb43363e7" translate="yes" xml:space="preserve">
          <source>Now, we want to go to the next stage in Git, which is to take the files that Git knows about in the index, and commit them as a real tree. We do that in two phases: creating a &lt;code&gt;tree&lt;/code&gt; object, and committing that &lt;code&gt;tree&lt;/code&gt; object as a &lt;code&gt;commit&lt;/code&gt; object together with an explanation of what the tree was all about, along with information of how we came to that state.</source>
          <target state="translated">现在，我们要进入Git的下一个阶段，即将Git知道的文件放入索引中，并将其提交为一棵真正的树。我们分两个阶段进行操作：创建一个 &lt;code&gt;tree&lt;/code&gt; 对象，并将该 &lt;code&gt;tree&lt;/code&gt; 对象作为 &lt;code&gt;commit&lt;/code&gt; 对象进行提交，同时对树的含义进行解释，并提供有关如何达到该状态的信息。</target>
        </trans-unit>
        <trans-unit id="4b50314ab323fb71cb3292dbd2b0326c17673414" translate="yes" xml:space="preserve">
          <source>Now, you will get the rewritten history saved in HEAD.</source>
          <target state="translated">现在,你将得到保存在HEAD中的重写历史。</target>
        </trans-unit>
        <trans-unit id="575836ebc8e262c11aa86a9dd4e0c52f7d072bcd" translate="yes" xml:space="preserve">
          <source>Now, you&amp;rsquo;ve got two branches, and you decide that you want to merge the work done. Before we do that, let&amp;rsquo;s introduce a cool graphical tool that helps you view what&amp;rsquo;s going on:</source>
          <target state="translated">现在，您有两个分支，您决定要合并已完成的工作。在此之前，我们先介绍一个很酷的图形工具，以帮助您查看正在发生的事情：</target>
        </trans-unit>
        <trans-unit id="910f1e558e60364937a941e26d7def6b701f836e" translate="yes" xml:space="preserve">
          <source>Nowadays though gitweb should create HTML base tag when needed (to set base URI for relative links), so it should work automatically.</source>
          <target state="translated">不过现在gitweb应该会在需要的时候创建HTML基础标签(为相对链接设置基础URI),所以它应该会自动工作。</target>
        </trans-unit>
        <trans-unit id="9a11d4479b92e7b2c9a9fc979b41f6f7eb2a1edf" translate="yes" xml:space="preserve">
          <source>Nowadays, &lt;code&gt;git log&lt;/code&gt; is a builtin, which means that it is &lt;code&gt;contained&lt;/code&gt; in the command &lt;code&gt;git&lt;/code&gt;. The source side of a builtin is</source>
          <target state="translated">如今， &lt;code&gt;git log&lt;/code&gt; 是内置的，这意味着它 &lt;code&gt;contained&lt;/code&gt; 在命令 &lt;code&gt;git&lt;/code&gt; 中。内置的源端是</target>
        </trans-unit>
        <trans-unit id="33e31083ab9551e7141ee8a3ee7a0a4d045c20a2" translate="yes" xml:space="preserve">
          <source>Number of bytes of a pack file to map into memory in a single mapping operation. Larger window sizes may allow your system to process a smaller number of large pack files more quickly. Smaller window sizes will negatively affect performance due to increased calls to the operating system&amp;rsquo;s memory manager, but may improve performance when accessing a large number of large pack files.</source>
          <target state="translated">在单个映射操作中要映射到内存中的打包文件的字节数。较大的窗口大小可以使您的系统更快地处理少量的大包文件。由于增加了对操作系统内存管理器的调用，较小的窗口大小将对性能产生负面影响，但在访问大量大文件包文件时可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="782270330831f0728fbf1b39424dcd7ac04c3bcf" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. If unset (or set to 0), 8 threads are used by default (for now).</source>
          <target state="translated">要使用的grep worker线程数,如果未设置(或设置为0),默认使用8个线程。如果未设置(或设置为0),默认使用8个线程(目前)。</target>
        </trans-unit>
        <trans-unit id="b3f7cd4c72eff1cd06e6ea960c75592f7883408d" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. See &lt;code&gt;grep.threads&lt;/code&gt; in &lt;a href=&quot;git-grep&quot;&gt;git-grep[1]&lt;/a&gt; for more information.</source>
          <target state="translated">要使用的grep工作线程数。见 &lt;code&gt;grep.threads&lt;/code&gt; 在&lt;a href=&quot;git-grep&quot;&gt;GIT-grep的[1]&lt;/a&gt;获得更多信息。</target>
        </trans-unit>
        <trans-unit id="340883bf973e4a0a0a15928c3b44200ef6d0edac" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. See &lt;code&gt;grep.threads&lt;/code&gt; in &lt;code&gt;CONFIGURATION&lt;/code&gt; for more information.</source>
          <target state="translated">要使用的grep工作线程数。见 &lt;code&gt;grep.threads&lt;/code&gt; 在 &lt;code&gt;CONFIGURATION&lt;/code&gt; 以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="4a06461d5cac364fcad71d6e428b30d7321d874b" translate="yes" xml:space="preserve">
          <source>Number of messages to be sent per connection, after that a relogin will happen. If the value is 0 or undefined, send all messages in one connection. See also the &lt;code&gt;--batch-size&lt;/code&gt; option of &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;.</source>
          <target state="translated">每个连接发送的消息数，之后将重新登录。如果值为0或未定义，则在一个连接中发送所有消息。另请参见&lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt;的 &lt;code&gt;--batch-size&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="263d5a12c4d7938e6b1945ed2d424a531e8ffd37" translate="yes" xml:space="preserve">
          <source>Number of parallel children to be used for all forms of fetching.</source>
          <target state="translated">所有形式的取材都要用到的平行子代数。</target>
        </trans-unit>
        <trans-unit id="5f124a70076360d6cdb202a3452dac6608d9c87a" translate="yes" xml:space="preserve">
          <source>Number of seconds to cache credentials (default: 900).</source>
          <target state="translated">缓存凭证的秒数(默认值:900)。</target>
        </trans-unit>
        <trans-unit id="0600a433ee142590b5ed0795ec15517899403cc1" translate="yes" xml:space="preserve">
          <source>OBJ_BLOB (3)</source>
          <target state="translated">OBJ_BLOB (3)</target>
        </trans-unit>
        <trans-unit id="20a9deedd57091e656a9ceb8afe723fea4c8ae28" translate="yes" xml:space="preserve">
          <source>OBJ_COMMIT (1)</source>
          <target state="translated">OBJ_COMMIT (1)</target>
        </trans-unit>
        <trans-unit id="33b36795cfe9033fd325f2c4f57ccf4bbcdb1c8c" translate="yes" xml:space="preserve">
          <source>OBJ_OFS_DELTA (6)</source>
          <target state="translated">OBJ_OFS_DELTA (6)</target>
        </trans-unit>
        <trans-unit id="ad63d6a2f7a5f774df4b60dc52ffc40dc66ab330" translate="yes" xml:space="preserve">
          <source>OBJ_REF_DELTA (7)</source>
          <target state="translated">OBJ_REF_DELTA (7)</target>
        </trans-unit>
        <trans-unit id="bf0dce0da3b6ff387e755df6e790a1cac5898dd7" translate="yes" xml:space="preserve">
          <source>OBJ_TAG (4)</source>
          <target state="translated">OBJ_TAG (4)</target>
        </trans-unit>
        <trans-unit id="2f77abc6705f39815a181a261b98c26e748660a6" translate="yes" xml:space="preserve">
          <source>OBJ_TREE (2)</source>
          <target state="translated">OBJ_TREE (2)</target>
        </trans-unit>
        <trans-unit id="bcb75e6bd3e418ec921606a22f47e84ce889c09d" translate="yes" xml:space="preserve">
          <source>OK, still with me? To give us an example to look at, let&amp;rsquo;s go back to the earlier repository with &quot;hello&quot; and &quot;example&quot; file, and bring ourselves back to the pre-merge state:</source>
          <target state="translated">好吧，还是和我在一起吗？让我们来看一个例子，让我们回到带有&amp;ldquo; hello&amp;rdquo;和&amp;ldquo; example&amp;rdquo;文件的早期存储库，然后使自己回到合并前的状态：</target>
        </trans-unit>
        <trans-unit id="6477da6d91ea639e6e30c40f69d7500177d55603" translate="yes" xml:space="preserve">
          <source>OK, this all sounds like a collection of totally nonsensical rules, but it&amp;rsquo;s actually exactly what you want in order to do a fast merge. The different stages represent the &quot;result tree&quot; (stage 0, aka &quot;merged&quot;), the original tree (stage 1, aka &quot;orig&quot;), and the two trees you are trying to merge (stage 2 and 3 respectively).</source>
          <target state="translated">好的，这听起来似乎是完全荒谬的规则的集合，但实际上正是您想要进行快速合并的目的。不同阶段代表&amp;ldquo;结果树&amp;rdquo;（阶段0，又称&amp;ldquo;合并&amp;rdquo;），原始树（阶段1，又称&amp;ldquo;原件&amp;rdquo;）和您要合并的两棵树（分别为阶段2和3）。</target>
        </trans-unit>
        <trans-unit id="30c34ea4528b5e99d721b2ada273c08402f70a1d" translate="yes" xml:space="preserve">
          <source>Object Traversal</source>
          <target state="translated">对象遍历</target>
        </trans-unit>
        <trans-unit id="e07348665c9e3f452362a58c36e1f55665279269" translate="yes" xml:space="preserve">
          <source>Object access and manipulation</source>
          <target state="translated">对象访问和操作</target>
        </trans-unit>
        <trans-unit id="d963c54afefdbe29bbc1f0380d42869afd8a753b" translate="yes" xml:space="preserve">
          <source>Object size identified by &amp;lt;object&amp;gt; is given in bytes, and right-justified with minimum width of 7 characters. Object size is given only for blobs (file) entries; for other entries &lt;code&gt;-&lt;/code&gt; character is used in place of size.</source>
          <target state="translated">由&amp;lt;object&amp;gt;标识的对象大小以字节为单位，并用7个字符的最小宽度右对齐。对象大小仅针对blob（文件）条目提供；对于其他条目 &lt;code&gt;-&lt;/code&gt; 使用字符代替大小。</target>
        </trans-unit>
        <trans-unit id="5a755e02f9fddc8d9863cff303858fc5c0963f4b" translate="yes" xml:space="preserve">
          <source>Object storage format</source>
          <target state="translated">对象存储格式</target>
        </trans-unit>
        <trans-unit id="4410a56144704dcadb0adeabc1f66b086332a778" translate="yes" xml:space="preserve">
          <source>Object store associated with this repository. Usually an object store is self sufficient (i.e. all the objects that are referred to by an object found in it are also found in it), but there are a few ways to violate it.</source>
          <target state="translated">与这个存储库相关联的对象存储。通常一个对象存储是自给自足的(即在其中找到的对象所引用的所有对象也在其中找到),但有一些方法可以违反它。</target>
        </trans-unit>
        <trans-unit id="66c888d10ab6a46198fcec7325df97ad7688050e" translate="yes" xml:space="preserve">
          <source>Object types</source>
          <target state="translated">对象类型</target>
        </trans-unit>
        <trans-unit id="397880af9235fafbc028a684c78f613458679a72" translate="yes" xml:space="preserve">
          <source>Objects that already exist in the repository will &lt;strong&gt;not&lt;/strong&gt; be unpacked from the packfile. Therefore, nothing will be unpacked if you use this command on a packfile that exists within the target repository.</source>
          <target state="translated">存储库中已存在的对象&lt;strong&gt;不会&lt;/strong&gt;从packfile中解压缩。因此，如果对目标存储库中存在的packfile使用此命令，则不会解包任何内容。</target>
        </trans-unit>
        <trans-unit id="f90e1faea66f4ee07afc15b9cfbe6b37aebe1076" translate="yes" xml:space="preserve">
          <source>Objects unreachable from the refs in packs named with --unpacked= option are added to the resulting pack, in addition to the reachable objects that are not in packs marked with *.keep files. This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">除了未在带有* .keep文件标记的包中的可访问对象之外，用--unpacked =选项命名的包中的引用中无法访问的对象也添加到了结果包中。这意味着 &lt;code&gt;--revs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4b47085e458e48bb4b0605ca6d2f6a3cc7755c2" translate="yes" xml:space="preserve">
          <source>Obsolete for: &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">已过时：&lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d42a49317326d6b79f20beebf76935d065ccac7f" translate="yes" xml:space="preserve">
          <source>Obviously, endless variations are possible; for example, to see all commits reachable from some head but not from any tag in the repository:</source>
          <target state="translated">显然,我们可以有无穷无尽的变化,例如,可以看到所有从某个头部提交的提交,而不是从版本库中的任何标签提交的提交。</target>
        </trans-unit>
        <trans-unit id="80e98962116f1f595b28a3f430e4b1f9c4dbde82" translate="yes" xml:space="preserve">
          <source>Occasionally, the maintainer may get merge conflicts when they try to pull changes from downstream. In this case, they can ask downstream to do the merge and resolve the conflicts themselves (perhaps they will know better how to resolve them). It is one of the rare cases where downstream &lt;code&gt;should&lt;/code&gt; merge from upstream.</source>
          <target state="translated">有时，维护者在尝试从下游拉出更改时可能会遇到合并冲突。在这种情况下，他们可以要求下游进行合并并自己解决冲突（也许他们会更好地解决问题）。这是少数情况下下游 &lt;code&gt;should&lt;/code&gt; 上游合并的情况之一。</target>
        </trans-unit>
        <trans-unit id="7c4df738049a7589e8637595f08e890f6ad9d98e" translate="yes" xml:space="preserve">
          <source>Of course some kind of software is developed, then used during some time without being improved on much, and then finally thrown away. In this case, of course, regressions may not be a big problem. But on the other hand, there is a lot of big software that is continually developed and maintained during years or even tens of years by a lot of people. And as there are often many people who depend (sometimes critically) on such software, regressions are a really big problem.</source>
          <target state="translated">当然某种软件开发出来后,在一段时间内使用,没有经过什么改进,最后就扔掉了。当然,在这种情况下,退步可能不是什么大问题。但另一方面,有很多大型软件是在几年甚至十几年的时间里,由很多人不断开发和维护的。而由于经常有很多人依赖(有时是关键性的)这样的软件,所以回归是一个非常大的问题。</target>
        </trans-unit>
        <trans-unit id="19fce424b8331b64c65b8a6acafb03304b015bfc" translate="yes" xml:space="preserve">
          <source>Of course the &quot;bad&quot; commit cannot be an ancestor of a &quot;good&quot; commit, because the ancestors of the good commits are supposed to be &quot;good&quot;. And all the &quot;good&quot; commits must be related to the bad commit. They cannot be on a branch that has no link with the branch of the &quot;bad&quot; commit. But it is possible for a good commit to be related to a bad commit and yet not be neither one of its ancestor nor one of its descendants.</source>
          <target state="translated">当然,&quot;坏 &quot;提交不可能是 &quot;好 &quot;提交的祖先,因为好提交的祖先应该是 &quot;好&quot;。而所有的 &quot;好 &quot;提交必须与 &quot;坏 &quot;提交有关。它们不能在一个与 &quot;坏 &quot;提交的分支没有联系的分支上。但是,一个好的提交与一个坏的提交有可能有关系,但既不是它的祖先,也不是它的子孙。</target>
        </trans-unit>
        <trans-unit id="7c78c10d5c75907a546f96553e9802bb23f4c982" translate="yes" xml:space="preserve">
          <source>Of course, there may be more than one answer&amp;mdash;​if the history branched after commit e05db0fd, then there could be multiple &quot;earliest&quot; tagged releases.</source>
          <target state="translated">当然，可能会有多个答案-如果在提交e05db0fd之后历史分支分支，那么可能会有多个``最早''的标记发行版。</target>
        </trans-unit>
        <trans-unit id="bc73231ef0df798acd7604c5e90f5ea460992bab" translate="yes" xml:space="preserve">
          <source>Often people use &lt;code&gt;git pull&lt;/code&gt; without giving any parameter. Traditionally, this has been equivalent to saying &lt;code&gt;git pull
origin&lt;/code&gt;. However, when configuration &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; is present while on branch &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, that value is used instead of &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">人们通常在不提供任何参数的情况下使用 &lt;code&gt;git pull&lt;/code&gt; 。传统上，这相当于说 &lt;code&gt;git pull origin&lt;/code&gt; 。然而，当配置 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 是在分支存在，而 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; ，则使用该值而不是 &lt;code&gt;origin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="813c6a487fc92be3bf23c6677bbfade25d37be89" translate="yes" xml:space="preserve">
          <source>Often the current branch head is an ancestor of the named commit. This is the most common case especially when invoked from &lt;code&gt;git pull&lt;/code&gt;: you are tracking an upstream repository, you have committed no local changes, and now you want to update to a newer upstream revision. In this case, a new commit is not needed to store the combined history; instead, the &lt;code&gt;HEAD&lt;/code&gt; (along with the index) is updated to point at the named commit, without creating an extra merge commit.</source>
          <target state="translated">当前分支头通常是指定提交的祖先。这是最常见的情况，尤其是从 &lt;code&gt;git pull&lt;/code&gt; 调用时：您正在跟踪上游存储库，尚未提交任何本地更改，现在想更新到较新的上游修订版。在这种情况下，不需要新的提交来存储组合的历史记录；相反，将 &lt;code&gt;HEAD&lt;/code&gt; （以及索引）更新为指向指定的提交，而不创建额外的合并提交。</target>
        </trans-unit>
        <trans-unit id="bc22c639538c04ca7d5608268e4dc9b34f324581" translate="yes" xml:space="preserve">
          <source>Often the overview of the change is useful to get a feel of each step</source>
          <target state="translated">通常情况下,变化的概述是有用的,以获得每个步骤的感觉</target>
        </trans-unit>
        <trans-unit id="a0ef5be0d5f74372c2549cc7906cdb110a910654" translate="yes" xml:space="preserve">
          <source>Often, &quot;please pull&quot; messages on the mailing list just provide two pieces of information: a repo URL and a branch name; this is designed to be easily cut&amp;amp;pasted at the end of a &lt;code&gt;git fetch&lt;/code&gt; command line:</source>
          <target state="translated">通常，邮件列表上的&amp;ldquo;请拉&amp;rdquo;消息仅提供两条信息：回购URL和分支名称；它的设计目的是在 &lt;code&gt;git fetch&lt;/code&gt; 命令行的末尾轻松剪切和粘贴：</target>
        </trans-unit>
        <trans-unit id="b90f5f996d698883902ffd1dba32d6eea369ef9a" translate="yes" xml:space="preserve">
          <source>Older documentation written before the packed-refs mechanism was introduced may still say things like &quot;.git/refs/heads/&amp;lt;branch&amp;gt; file exists&quot; when it means &quot;branch &amp;lt;branch&amp;gt; exists&quot;.</source>
          <target state="translated">引入packed-refs机制之前编写的较早的文档在其含义为&amp;ldquo; branch &amp;lt;branch&amp;gt;存在&amp;rdquo;时，仍可能会说诸如&amp;ldquo; .git / refs / heads / &amp;lt;branch&amp;gt;文件存在&amp;rdquo;之类的内容。</target>
        </trans-unit>
        <trans-unit id="a148aab8f38b980de65dd5f412fc336ae5d855f6" translate="yes" xml:space="preserve">
          <source>Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run &lt;code&gt;git merge&lt;/code&gt;. To make it easier to adjust such scripts to the updated behaviour, the environment variable &lt;code&gt;GIT_MERGE_AUTOEDIT&lt;/code&gt; can be set to &lt;code&gt;no&lt;/code&gt; at the beginning of them.</source>
          <target state="translated">较早的脚本可能取决于不允许用户编辑合并日志消息的历史行为。他们将在运行 &lt;code&gt;git merge&lt;/code&gt; 时看到一个打开的编辑器。为了更容易地将这些脚本调整为更新的行为，可以在它们的开头将环境变量 &lt;code&gt;GIT_MERGE_AUTOEDIT&lt;/code&gt; 设置为 &lt;code&gt;no&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a027c8ab6aede7960dbe3d141d016ee3e6589ef" translate="yes" xml:space="preserve">
          <source>Older versions of &lt;code&gt;meld&lt;/code&gt; do not support the &lt;code&gt;--output&lt;/code&gt; option. Git will attempt to detect whether &lt;code&gt;meld&lt;/code&gt; supports &lt;code&gt;--output&lt;/code&gt; by inspecting the output of &lt;code&gt;meld --help&lt;/code&gt;. Configuring &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; will make Git skip these checks and use the configured value instead. Setting &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; tells Git to unconditionally use the &lt;code&gt;--output&lt;/code&gt; option, and &lt;code&gt;false&lt;/code&gt; avoids using &lt;code&gt;--output&lt;/code&gt;.</source>
          <target state="translated">较早版本的 &lt;code&gt;meld&lt;/code&gt; 不支持 &lt;code&gt;--output&lt;/code&gt; 选项。 Git将通过检查 &lt;code&gt;meld --help&lt;/code&gt; 的输出来尝试检测 &lt;code&gt;meld&lt;/code&gt; 是否支持 &lt;code&gt;--output&lt;/code&gt; 。配置 &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; 将使Git跳过这些检查，而是使用配置的值。将 &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 会告诉Git无条件使用 &lt;code&gt;--output&lt;/code&gt; 选项，而 &lt;code&gt;false&lt;/code&gt; 则避免使用 &lt;code&gt;--output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8511fe9d48b84ff3883d162d35ccd3dcba224454" translate="yes" xml:space="preserve">
          <source>Older versions of Git (before 2.20) documented that the object names list should be sorted. This was never a requirement, the object names could appear in any order, but when reading the list we tracked whether the list was sorted for the purposes of an internal binary search implementation, which could save itself some work with an already sorted list. Unless you had a humongous list there was no reason to go out of your way to pre-sort the list. After Git version 2.20 a hash implementation is used instead, so there&amp;rsquo;s now no reason to pre-sort the list.</source>
          <target state="translated">较早版本的Git（2.20之前）记录了对象名称列表应进行排序。这从来都不是必需的，对象名称可以按任何顺序出现，但是在读取列表时，我们跟踪了列表是否出于内部二进制搜索实现的目的而进行了排序，这可以为已保存列表的工作节省一些时间。除非您的清单很大，否则没有理由不愿对清单进行预排序。在Git 2.20版本之后，使用哈希实现代替，因此现在没有理由对列表进行预排序。</target>
        </trans-unit>
        <trans-unit id="c51aaa3680fede028efcceee261b4919c277f552" translate="yes" xml:space="preserve">
          <source>Omit any commit that introduces the same change as another commit on the &amp;ldquo;other side&amp;rdquo; when the set of commits are limited with symmetric difference.</source>
          <target state="translated">当提交集受到对称差异限制时，请忽略任何与&amp;ldquo;另一端&amp;rdquo;上的另一次提交引入相同更改的提交。</target>
        </trans-unit>
        <trans-unit id="e35d3ce0c9ea9ff6d661fcb1cbc8e08ffef97df6" translate="yes" xml:space="preserve">
          <source>Omit diff output for unmerged entries and just show &quot;Unmerged&quot;. Can be used only when comparing the working tree with the index.</source>
          <target state="translated">省略未合并条目的差异输出,只显示 &quot;Unmerged&quot;。只能在比较工作树和索引时使用。</target>
        </trans-unit>
        <trans-unit id="3138b0b10501de06a44e08d0de4b10a83646644b" translate="yes" xml:space="preserve">
          <source>Omit objects that are known to be in the promisor remote. (This option has the purpose of operating only on locally created objects, so that when we repack, we still maintain a distinction between locally created objects [without .promisor] and objects from the promisor remote [with .promisor].) This is used with partial clone.</source>
          <target state="translated">省略那些已知在 promisor 远程中的对象。(这个选项的目的是只对本地创建的对象进行操作,这样当我们重新打包时,我们仍然会对本地创建的对象 [没有 .promonor]和来自 promisor remote [有 .promonor]的对象进行区分。)这个选项是和部分克隆一起使用的。</target>
        </trans-unit>
        <trans-unit id="fcfe3e3e988e33991f3ebb33b70ee9c58a79e5d0" translate="yes" xml:space="preserve">
          <source>Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and &lt;code&gt;/dev/null&lt;/code&gt;. The resulting patch is not meant to be applied with &lt;code&gt;patch&lt;/code&gt; or &lt;code&gt;git apply&lt;/code&gt;; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.</source>
          <target state="translated">忽略要删除的原映像，即仅输出标头，而不输出原映像和 &lt;code&gt;/dev/null&lt;/code&gt; 之间的差异。生成的补丁并不意味着要使用 &lt;code&gt;patch&lt;/code&gt; 或 &lt;code&gt;git apply&lt;/code&gt; ; 这仅适用于那些只希望在更改后专心阅读文本的人。另外，输出显然缺乏足够的信息来反向应用这种补丁，甚至是手动应用，因此是选项的名称。</target>
        </trans-unit>
        <trans-unit id="2c239b325c52048ed0e0df682e63161da794c522" translate="yes" xml:space="preserve">
          <source>Omitting &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; detaches &lt;code&gt;HEAD&lt;/code&gt; at the tip of the current branch.</source>
          <target state="translated">省略 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 会在当前分支的尖端分离 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f08ea1a85b441d7cdb4b9da4840e51d4a63074c" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;from&lt;/code&gt; command in the first commit of a new branch will cause fast-import to create that commit with no ancestor. This tends to be desired only for the initial commit of a project. If the frontend creates all files from scratch when making a new branch, a &lt;code&gt;merge&lt;/code&gt; command may be used instead of &lt;code&gt;from&lt;/code&gt; to start the commit with an empty tree. Omitting the &lt;code&gt;from&lt;/code&gt; command on existing branches is usually desired, as the current commit on that branch is automatically assumed to be the first ancestor of the new commit.</source>
          <target state="translated">在新分支的第一次提交中省略 &lt;code&gt;from&lt;/code&gt; 命令将导致快速导入在没有祖先的情况下创建该提交。仅对于项目的初始提交，这往往是期望的。如果前端在创建新分支时从头开始创建所有文件，则可以使用 &lt;code&gt;merge&lt;/code&gt; 命令而不是 &lt;code&gt;from&lt;/code&gt; 来从空树开始提交。通常希望在现有分支上省略 &lt;code&gt;from&lt;/code&gt; 命令，因为该分支上的当前提交会自动假定为新提交的第一个祖先。</target>
        </trans-unit>
        <trans-unit id="2e6ae0a1101e66bbdd1aff8c2583b81c23208b83" translate="yes" xml:space="preserve">
          <source>On Automatic following</source>
          <target state="translated">自动跟踪</target>
        </trans-unit>
        <trans-unit id="82b4aa90bf6690a7ed8e3558248667b070567fb7" translate="yes" xml:space="preserve">
          <source>On Backdating Tags</source>
          <target state="translated">关于追溯标签</target>
        </trans-unit>
        <trans-unit id="52c1ff7f8dbe6e1f6639547a437fb78c51994ab9" translate="yes" xml:space="preserve">
          <source>On Re-tagging</source>
          <target state="translated">关于重新标记</target>
        </trans-unit>
        <trans-unit id="a3e5a575b7ca5dced5a48ec2289cb57e77edaa64" translate="yes" xml:space="preserve">
          <source>On an inefficient filesystem with &lt;code&gt;core.ignorestat&lt;/code&gt; set</source>
          <target state="translated">在设置了 &lt;code&gt;core.ignorestat&lt;/code&gt; 的低效文件系统上</target>
        </trans-unit>
        <trans-unit id="ccf984a0700972bcd62e51c87e569c1158e56007" translate="yes" xml:space="preserve">
          <source>On large repositories, Git depends on compression to keep the history information from taking up too much space on disk or in memory. Some Git commands may automatically run &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;, so you don&amp;rsquo;t have to worry about running it manually. However, compressing a large repository may take a while, so you may want to call &lt;code&gt;gc&lt;/code&gt; explicitly to avoid automatic compression kicking in when it is not convenient.</source>
          <target state="translated">在大型存储库上，Git依靠压缩来防止历史信息占用磁盘或内存中的过多空间。一些Git命令可能会自动运行&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;，因此您不必担心手动运行它。但是，压缩大型存储库可能需要一段时间，因此您可能需要显式调用 &lt;code&gt;gc&lt;/code&gt; ,以避免在不方便时自动进行压缩。</target>
        </trans-unit>
        <trans-unit id="d4d8aed3bf55796608219c0adac254008695a3f9" translate="yes" xml:space="preserve">
          <source>On some file system/operating system combinations, this is unreliable. Set this config setting to &lt;code&gt;rename&lt;/code&gt; there; However, This will remove the check that makes sure that existing object files will not get overwritten.</source>
          <target state="translated">在某些文件系统/操作系统组合上，这是不可靠的。设置此配置设置以在那里 &lt;code&gt;rename&lt;/code&gt; ；但是，这将删除确保现有目标文件不会被覆盖的检查。</target>
        </trans-unit>
        <trans-unit id="5895edccc183158d9e3740d2cebb6ada4fc33444" translate="yes" xml:space="preserve">
          <source>On submit, re-author changes to reflect the Git author, regardless of who invokes &lt;code&gt;git p4 submit&lt;/code&gt;.</source>
          <target state="translated">提交时，无论谁调用 &lt;code&gt;git p4 submit&lt;/code&gt; ，都要重新编写更改以反映Git作者。</target>
        </trans-unit>
        <trans-unit id="625dc8e72565a5aa6c893e4054fd5a7bd4cd4c77" translate="yes" xml:space="preserve">
          <source>On success, the command returns the exit code 0.</source>
          <target state="translated">成功后,命令返回退出代码0。</target>
        </trans-unit>
        <trans-unit id="990e4d4ec388fa2b56426ae37da6b01c179599b8" translate="yes" xml:space="preserve">
          <source>On success, the exit status is &lt;code&gt;0&lt;/code&gt;. If the filter can&amp;rsquo;t find any commits to rewrite, the exit status is &lt;code&gt;2&lt;/code&gt;. On any other error, the exit status may be any other non-zero value.</source>
          <target state="translated">成功时，退出状态为 &lt;code&gt;0&lt;/code&gt; 。如果过滤器找不到任何要重写的提交，则退出状态为 &lt;code&gt;2&lt;/code&gt; 。在发生任何其他错误时，退出状态可以是任何其他非零值。</target>
        </trans-unit>
        <trans-unit id="9b26f7834b511fe2fcda898a4f6a6ea24bf02deb" translate="yes" xml:space="preserve">
          <source>On the filesystem, a submodule usually (but not always - see FORMS below) consists of (i) a Git directory located under the &lt;code&gt;$GIT_DIR/modules/&lt;/code&gt; directory of its superproject, (ii) a working directory inside the superproject&amp;rsquo;s working directory, and a &lt;code&gt;.git&lt;/code&gt; file at the root of the submodule&amp;rsquo;s working directory pointing to (i).</source>
          <target state="translated">在文件系统上，子模块通常（但不总是-参见下面的FORMS）由（i）位于其超级项目的 &lt;code&gt;$GIT_DIR/modules/&lt;/code&gt; 目录下的Git目录，（ii）超级项目的工作目录内的工作目录，以及一个 &lt;code&gt;.git&lt;/code&gt; 在子模块的工作目录指向的根文件于（i）。</target>
        </trans-unit>
        <trans-unit id="4db9025909f7f5bf5e13acbeaf805aa54cd01729" translate="yes" xml:space="preserve">
          <source>On the other hand if you do this often, then it can be worth having scripts to avoid too much typing.</source>
          <target state="translated">另一方面,如果你经常这样做,那么为了避免过多的打字,可以值得有脚本。</target>
        </trans-unit>
        <trans-unit id="683649c177c2041eda8a2d9bcca87e40a04a531c" translate="yes" xml:space="preserve">
          <source>On the other hand, if instead of merging at C you had rebased the history between Z to B on top of A, you would have gotten this linear history:</source>
          <target state="translated">另一方面,如果你不在C处合并,而是在A的基础上重新计算Z到B之间的历史,你就会得到这个线性历史。</target>
        </trans-unit>
        <trans-unit id="0322f18dd0193743bffa03c418d12c6fe0b24261" translate="yes" xml:space="preserve">
          <source>On the other hand, if you are fetching because you would want a one-shot merge from somebody else, you typically do not want to get tags from there. This happens more often for people near the toplevel but not limited to them. Mere mortals when pulling from each other do not necessarily want to automatically get private anchor point tags from the other person.</source>
          <target state="translated">另一方面,如果你是因为想从别人那里一次性合并而获取,你通常不希望从那里获取标签。这种情况更多发生在顶层附近的人身上,但不限于他们。单纯的凡人在从对方那里拉取时,不一定希望自动从对方那里获得私人锚点标签。</target>
        </trans-unit>
        <trans-unit id="ff26b6c1b15a595913b474bb862db9261a722064" translate="yes" xml:space="preserve">
          <source>On the other hand, when &lt;code&gt;git gc&lt;/code&gt; runs concurrently with another process, there is a risk of it deleting an object that the other process is using but hasn&amp;rsquo;t created a reference to. This may just cause the other process to fail or may corrupt the repository if the other process later adds a reference to the deleted object. Git has two features that significantly mitigate this problem:</source>
          <target state="translated">另一方面，当 &lt;code&gt;git gc&lt;/code&gt; 与另一个进程同时运行时，有可能会删除另一个进程正在使用但尚未创建引用的对象。如果其他进程以后添加对已删除对象的引用，则这可能只会导致另一个进程失败或损坏存储库。Git具有两个可以大大缓解此问题的功能：</target>
        </trans-unit>
        <trans-unit id="9cc6a0108c9ca30d35fc16f0e158699698e2687d" translate="yes" xml:space="preserve">
          <source>On the plus side, distributed revision control systems can much better integrate with external sources. In a centralized model, a single arbitrary snapshot of the external project is exported from its own revision control and then imported into the local revision control on a vendor branch. All the history is hidden. With distributed revision control you can clone the entire external history and much more easily follow development and re-merge local changes.</source>
          <target state="translated">从另一个方面来说,分布式的修订控制系统可以更好地与外部资源集成。在集中式模型中,外部项目的一个任意快照会从自己的修订控制中导出,然后导入到供应商分支上的本地修订控制中。所有的历史记录都是隐藏的。通过分布式修订控制,你可以克隆整个外部历史,并且更容易跟踪开发和重新合并本地变更。</target>
        </trans-unit>
        <trans-unit id="90597c320571938c2a30a9ec587f181632e3da9c" translate="yes" xml:space="preserve">
          <source>On the receiving side, failing fsckObjects will make those objects unreachable, see &quot;QUARANTINE ENVIRONMENT&quot; in &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;. On the fetch side, malformed objects will instead be left unreferenced in the repository.</source>
          <target state="translated">在接收方，失败的fsckObjects将使这些对象不可访问，请参见&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]中的&lt;/a&gt; &amp;ldquo; QUARANTINE ENVIRONMENT&amp;rdquo; 。在获取方面，格式错误的对象将改为在存储库中未引用。</target>
        </trans-unit>
        <trans-unit id="0cb32cbc06583a961d1463cba3f54ceac091ac9b" translate="yes" xml:space="preserve">
          <source>Once a patch completes the great cycle (moving from test to release, then pulled by Linus, and finally coming back into your local &lt;code&gt;origin/master&lt;/code&gt; branch), the branch for this change is no longer needed. You detect this when the output from:</source>
          <target state="translated">一旦补丁完成了重要的周期（从测试到发布，然后由Linus拉动，最后回到您的本地 &lt;code&gt;origin/master&lt;/code&gt; 分支），则不再需要此更改的分支。当来自以下位置的输出时，您将检测到此情况：</target>
        </trans-unit>
        <trans-unit id="b9ebb68ceda33b5f55394a76815abe93f554d5a0" translate="yes" xml:space="preserve">
          <source>Once again, check to verify that you&amp;rsquo;ve included what you want to. You may also wish to verify that git diff doesn&amp;rsquo;t show any remaining changes to be committed later.</source>
          <target state="translated">再次检查以确保您已包含要包含的内容。您可能还希望验证git diff不显示任何剩余更改以供以后提交。</target>
        </trans-unit>
        <trans-unit id="90e05562a65001025b0b72d96c6a4e4b947387b5" translate="yes" xml:space="preserve">
          <source>Once housekeeping is triggered by exceeding the limits of configuration options such as &lt;code&gt;gc.auto&lt;/code&gt; and &lt;code&gt;gc.autoPackLimit&lt;/code&gt;, all other housekeeping tasks (e.g. rerere, working trees, reflog&amp;hellip;​) will be performed as well.</source>
          <target state="translated">一旦超出配置选项的限制（例如 &lt;code&gt;gc.auto&lt;/code&gt; 和 &lt;code&gt;gc.autoPackLimit&lt;/code&gt; ）触发了内务处理，所有其他内务处理任务（例如rerere，工作树，刷新日志等）也将执行。</target>
        </trans-unit>
        <trans-unit id="e4fac50f608beca9583acae6e66b5b839bc7af82" translate="yes" xml:space="preserve">
          <source>Once satisfied with the hunks you want to include, you should verify what has been prepared for the first commit by using &lt;code&gt;git diff --cached&lt;/code&gt;. This shows all the changes that have been moved into the index and are about to be committed.</source>
          <target state="translated">对要包含的块满意之后，应使用 &lt;code&gt;git diff --cached&lt;/code&gt; 验证为首次提交准备的内容。这显示了所有已移入索引并将要提交的更改。</target>
        </trans-unit>
        <trans-unit id="3dd9fb6970c316fd22de16c64bf93a0699f63f8d" translate="yes" xml:space="preserve">
          <source>Once the commits are ready to be sent, run the following command:</source>
          <target state="translated">一旦准备好要发送的提交,运行以下命令。</target>
        </trans-unit>
        <trans-unit id="bc0e79bf062114aed97a847d2dbf78bde74bcedc" translate="yes" xml:space="preserve">
          <source>Once the index has been created, the list of object names is sorted and the SHA-1 hash of that list is printed to stdout. If --stdin was also used then this is prefixed by either &quot;pack\t&quot;, or &quot;keep\t&quot; if a new .keep file was successfully created. This is useful to remove a .keep file used as a lock to prevent the race with &lt;code&gt;git repack&lt;/code&gt; mentioned above.</source>
          <target state="translated">创建索引后，将对对象名称列表进行排序，并将该列表的SHA-1哈希打印到stdout。如果还使用了--stdin，则如果成功创建了新的.keep文件，则以&amp;ldquo; pack \ t&amp;rdquo;或&amp;ldquo; keep \ t&amp;rdquo;作为前缀。这对于删除用作锁定的.keep文件很有用，以防止上述 &lt;code&gt;git repack&lt;/code&gt; 竞争。</target>
        </trans-unit>
        <trans-unit id="267c8839170c35911e5505454167dce43ef8461e" translate="yes" xml:space="preserve">
          <source>Once the index is updated with the results of the conflict resolution, instead of creating a new commit, just run</source>
          <target state="translated">一旦根据冲突解决的结果更新了索引,就不需要创建新的提交,只需运行</target>
        </trans-unit>
        <trans-unit id="dce83a819a58902526be63ab88beb478ade1a830" translate="yes" xml:space="preserve">
          <source>Once tracking a Subversion repository (with any of the above methods), the Git repository can be updated from Subversion by the &lt;code&gt;fetch&lt;/code&gt; command and Subversion updated from Git by the &lt;code&gt;dcommit&lt;/code&gt; command.</source>
          <target state="translated">一旦跟踪了Subversion存储库（使用上述任何一种方法），就可以通过 &lt;code&gt;fetch&lt;/code&gt; 命令从Subversion更新Git存储库，并通过 &lt;code&gt;dcommit&lt;/code&gt; 命令从Git更新Subversion 。</target>
        </trans-unit>
        <trans-unit id="f7c323cf6aca82334469eb4ac31bb75f493bfcb2" translate="yes" xml:space="preserve">
          <source>Once you fetch from the remote repository, you &lt;code&gt;merge&lt;/code&gt; that with your current branch.</source>
          <target state="translated">从远程存储库中获取数据后， &lt;code&gt;merge&lt;/code&gt; 其与当前分支合并。</target>
        </trans-unit>
        <trans-unit id="196d7a30344d61fce15a29277d1febbefab63366" translate="yes" xml:space="preserve">
          <source>Once you have packed objects, you do not need to leave the unpacked objects that are contained in the pack file anymore.</source>
          <target state="translated">一旦你打包了对象,你就不需要再留下打包文件中包含的未打包的对象。</target>
        </trans-unit>
        <trans-unit id="19419c3fb2ffef21b9b034f5ca5d579751e9cffb" translate="yes" xml:space="preserve">
          <source>Once you have specified at least one bad and one good commit, &lt;code&gt;git
bisect&lt;/code&gt; selects a commit in the middle of that range of history, checks it out, and outputs something similar to the following:</source>
          <target state="translated">一旦指定了至少一个错误和一个良好的提交， &lt;code&gt;git bisect&lt;/code&gt; 将在该历史记录范围的中间选择一个提交，将其检出，并输出类似于以下内容的内容：</target>
        </trans-unit>
        <trans-unit id="a222e7e00ea22df97bc019f6fbda7d4a739d08f0" translate="yes" xml:space="preserve">
          <source>Once you know the three trees you are going to merge (the one &quot;original&quot; tree, aka the common tree, and the two &quot;result&quot; trees, aka the branches you want to merge), you do a &quot;merge&quot; read into the index. This will complain if it has to throw away your old index contents, so you should make sure that you&amp;rsquo;ve committed those&amp;mdash;​in fact you would normally always do a merge against your last commit (which should thus match what you have in your current index anyway).</source>
          <target state="translated">知道要合并的三棵树（一棵&amp;ldquo;原始&amp;rdquo;树，又称普通树，以及两棵&amp;ldquo;结果&amp;rdquo;树，又称要合并的分支）后，便进行&amp;ldquo;合并&amp;rdquo;读取到指数。如果必须丢弃旧的索引内容，这将会发出抱怨，因此您应该确保已提交了这些内容-实际上，您通常总是对上一次提交进行合并（因此应该与您的现有内容相匹配）当前索引）。</target>
        </trans-unit>
        <trans-unit id="2f6bdbc854c9f4a06850e81f40a40893a853f873" translate="yes" xml:space="preserve">
          <source>Once your commits are ready to be sent to the mailing list, run the following commands:</source>
          <target state="translated">一旦你的提交准备好了,就可以发送到邮件列表中,运行以下命令。</target>
        </trans-unit>
        <trans-unit id="1e3411b288c5ece442ec5affcc9ccff7867288ff" translate="yes" xml:space="preserve">
          <source>One can also modify context lines by staging them for removal (by converting &quot; &quot; to &quot;-&quot;) and adding a &quot;+&quot; line with the new content. Similarly, one can modify &quot;+&quot; lines for existing additions or modifications. In all cases, the new modification will appear reverted in the working tree.</source>
          <target state="translated">我们也可以修改上下文行,将它们分期删除(通过将&quot;&quot;转换为&quot;-&quot;),然后添加一个 &quot;+&quot;行,加上新的内容。同样,人们也可以为现有的添加或修改修改 &quot;+&quot;行。在所有情况下,新的修改都会在工作树中出现还原。</target>
        </trans-unit>
        <trans-unit id="cefda8701820e17ff3e5c1f9d74674c9ba3ca4b0" translate="yes" xml:space="preserve">
          <source>One feature worth pointing out is the three-way merge, which can help if you get conflicts: &lt;code&gt;git am -3&lt;/code&gt; will use index information contained in patches to figure out the merge base. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; for other options.</source>
          <target state="translated">值得指出的一项功能是三向合并，这在您遇到冲突 &lt;code&gt;git am -3&lt;/code&gt; 会有所帮助：git am -3将使用补丁程序中包含的索引信息来确定合并基础。有关其他选项，请参见&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91b115a828fd51fba09fc11d7213ae15c1c47544" translate="yes" xml:space="preserve">
          <source>One important aspect of Git is its distributed nature, which largely means there is no inherent &quot;upstream&quot; or &quot;downstream&quot; in the system. On the face of it, the above example might seem to indicate that the tag namespace is owned by the upper echelon of people and that tags only flow downwards, but that is not the case. It only shows that the usage pattern determines who are interested in whose tags.</source>
          <target state="translated">Git的一个重要方面是它的分布式特性,这很大程度上意味着系统中没有固有的 &quot;上游 &quot;或 &quot;下游&quot;。从表面上看,上面的例子似乎表明,标签命名空间是由上层人员拥有的,标签只能向下流动,但事实并非如此。它只是表明,使用模式决定了谁对谁的标签感兴趣。</target>
        </trans-unit>
        <trans-unit id="04ced8b13491984476dfed877ea62bd96c9df7a6" translate="yes" xml:space="preserve">
          <source>One major difference between &lt;code&gt;git submodule update&lt;/code&gt; and &lt;code&gt;git submodule add&lt;/code&gt; is that &lt;code&gt;git submodule update&lt;/code&gt; checks out a specific commit, rather than the tip of a branch. It&amp;rsquo;s like checking out a tag: the head is detached, so you&amp;rsquo;re not working on a branch.</source>
          <target state="translated">&lt;code&gt;git submodule update&lt;/code&gt; 和 &lt;code&gt;git submodule add&lt;/code&gt; 之间的主要区别是 &lt;code&gt;git submodule update&lt;/code&gt; 签出特定的提交，而不是分支的尖端。这就像签出一个标签：头部是分离的，所以您不在分支上工作。</target>
        </trans-unit>
        <trans-unit id="8d6438f7bb62b577ed24501432d3010343f7c06f" translate="yes" xml:space="preserve">
          <source>One nice about &quot;git bisect&quot; is that it is not only a developer tool. It can effectively be used by QA people or even end users (if they have access to the source code or if they can get access to all the builds).</source>
          <target state="translated">git bisect &quot;的一个好处是,它不仅仅是一个开发者工具。它可以有效地被QA人员甚至最终用户使用(如果他们能够访问源代码或者能够访问所有的构建)。</target>
        </trans-unit>
        <trans-unit id="142f19dfe765b1c5ce574050578fa3bc8f7c4c07" translate="yes" xml:space="preserve">
          <source>One note: the special &lt;code&gt;master&lt;/code&gt; head is the default branch, which is why the &lt;code&gt;.git/HEAD&lt;/code&gt; file was created points to it even if it doesn&amp;rsquo;t yet exist. Basically, the &lt;code&gt;HEAD&lt;/code&gt; link is supposed to always point to the branch you are working on right now, and you always start out expecting to work on the &lt;code&gt;master&lt;/code&gt; branch.</source>
          <target state="translated">注意：特殊的 &lt;code&gt;master&lt;/code&gt; 头是默认分支，这就是创建 &lt;code&gt;.git/HEAD&lt;/code&gt; 文件的原因，即使它不存在也是如此。基本上， &lt;code&gt;HEAD&lt;/code&gt; 链接应该总是指向您现在正在处理的分支，并且您总是开始期望在 &lt;code&gt;master&lt;/code&gt; 分支上工作。</target>
        </trans-unit>
        <trans-unit id="29a0c8f350324f991b248dd3aa593e11f5862130" translate="yes" xml:space="preserve">
          <source>One obvious improvement to this algorithm would be to look for a commit that has an associated value near the one of the best bisection commit, and that is on another branch, before using the PRNG. Because if such a commit exists, then it is not very likely to be untestable too, so it will probably give more information than a nearly randomly chosen one.</source>
          <target state="translated">对这个算法的一个明显改进是,在使用PRNG之前,先寻找一个相关值接近最佳二分法提交的提交,而且是在另一个分支上。因为如果存在这样的提交,那么它也不太可能是不可测试的,所以它可能会比一个近乎随机选择的提交提供更多的信息。</target>
        </trans-unit>
        <trans-unit id="e1159b72c8727d654a00df87bb5a62e68448d486" translate="yes" xml:space="preserve">
          <source>One of the following transports can be used to name the repository to download from:</source>
          <target state="translated">可以使用以下传输方式之一来命名要下载的版本库。</target>
        </trans-unit>
        <trans-unit id="f2e9320213d36179f9f718d529b707eca70ac72d" translate="yes" xml:space="preserve">
          <source>One of the ideas of having a branch is that you do some (possibly experimental) work in it, and eventually merge it back to the main branch. So assuming you created the above &lt;code&gt;mybranch&lt;/code&gt; that started out being the same as the original &lt;code&gt;master&lt;/code&gt; branch, let&amp;rsquo;s make sure we&amp;rsquo;re in that branch, and do some work there.</source>
          <target state="translated">拥有分支的想法之一是，您要在其中进行一些（可能是实验性的）工作，并最终将其合并回主分支。因此，假设您创建的 &lt;code&gt;mybranch&lt;/code&gt; 最初与原始 &lt;code&gt;master&lt;/code&gt; 分支相同，那么请确保我们在该分支中，并在那里进行一些工作。</target>
        </trans-unit>
        <trans-unit id="07b5c446feb269c31391e3ec2cd0376191f84e84" translate="yes" xml:space="preserve">
          <source>One of the identifiers &quot;&lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;#def_tree_object&quot;&gt;tree&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;#def_tag_object&quot;&gt;tag&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt;&quot; describing the type of an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;.</source>
          <target state="translated">标识符&amp;ldquo; &lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt; &amp;rdquo;，&amp;ldquo; &lt;a href=&quot;#def_tree_object&quot;&gt;tree&lt;/a&gt; &amp;rdquo;，&amp;ldquo; &lt;a href=&quot;#def_tag_object&quot;&gt;tag&lt;/a&gt; &amp;rdquo;或&amp;ldquo; &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; &amp;rdquo;之一，描述&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;的类型。</target>
        </trans-unit>
        <trans-unit id="4cfd499f1faa2bf47281b08252a27709dbf65c31" translate="yes" xml:space="preserve">
          <source>One or more of the options below may be used to determine the files shown:</source>
          <target state="translated">以下一个或多个选项可用于确定显示的文件。</target>
        </trans-unit>
        <trans-unit id="5fdc57e5472e4e105b70357796e6b6c7c9687799" translate="yes" xml:space="preserve">
          <source>One or more of the provided paths is ignored.</source>
          <target state="translated">忽略一个或多个提供的路径。</target>
        </trans-unit>
        <trans-unit id="fa8d672b6bbfcb201a67403df350a9a5a712d006" translate="yes" xml:space="preserve">
          <source>One phase in branch detection involves looking at p4 branches to find new ones to import. By default, all branches are inspected. This option limits the search to just those owned by the single user named in the variable.</source>
          <target state="translated">分支检测中的一个阶段包括查看p4分支,以找到新的分支来导入。默认情况下,所有的分支都会被检测。这个选项限制了搜索范围,只限于那些在变量中命名的单个用户所拥有的分支。</target>
        </trans-unit>
        <trans-unit id="11468bd4c23009003db390c522332f7c3d2a8eae" translate="yes" xml:space="preserve">
          <source>One problem with &quot;git replace&quot; is that currently it stores all the replacements refs in &quot;refs/replace/&quot;, but it would be perhaps better if the replacement refs that are useful only for bisecting would be in &quot;refs/replace/bisect/&quot;. This way the replacement refs could be used only for bisecting, while other refs directly in &quot;refs/replace/&quot; would be used nearly all the time.</source>
          <target state="translated">git replace 的一个问题是,目前它把所有的替换 refs 都存储在 &quot;refs/replace/&quot;中,但如果把只对二分法有用的替换 refs 放在 &quot;refs/replace/bisect/&quot;中也许会更好。这样一来,替换的参考文献就可以只用于二分法,而直接放在 &quot;refs/replace/&quot;中的其他参考文献几乎所有时间都会被使用。</target>
        </trans-unit>
        <trans-unit id="d1e2a86cedb580a377c28acdbf81410bf88bf79b" translate="yes" xml:space="preserve">
          <source>One record (for project / repository) per line; does not support line continuation (newline escaping).</source>
          <target state="translated">每行一条记录(针对项目/仓库);不支持续行(换行)。</target>
        </trans-unit>
        <trans-unit id="8e018f50410d5f4a4feb43d8b0ec18d17af4444c" translate="yes" xml:space="preserve">
          <source>One such software is the Linux kernel. And if we look at the Linux kernel, we can see that a lot of time and effort is spent to fight regressions. The release cycle start with a 2 weeks long merge window. Then the first release candidate (rc) version is tagged. And after that about 7 or 8 more rc versions will appear with around one week between each of them, before the final release.</source>
          <target state="translated">Linux内核就是这样一款软件。而如果我们看一下Linux内核,就会发现,我们花了很多时间和精力来对抗回归。发布周期从2周长的合并窗口开始。然后第一个发布候选版本(rc)被标记。在这之后,大约会出现7到8个更多的rc版本,每一个版本之间会相隔一周左右,然后才是最终的版本。</target>
        </trans-unit>
        <trans-unit id="bdac2081c61d66c365f2d2f97739c2e3f666a74e" translate="yes" xml:space="preserve">
          <source>One usage scenario is to run unit tests in the hook.</source>
          <target state="translated">一个使用场景是在钩子中运行单元测试。</target>
        </trans-unit>
        <trans-unit id="f9e9013eccf2a70e5a5f30b1ea62b3495fc5c835" translate="yes" xml:space="preserve">
          <source>One use of the content filtering is to massage the content into a shape that is more convenient for the platform, filesystem, and the user to use. For this mode of operation, the key phrase here is &quot;more convenient&quot; and not &quot;turning something unusable into usable&quot;. In other words, the intent is that if someone unsets the filter driver definition, or does not have the appropriate filter program, the project should still be usable.</source>
          <target state="translated">内容过滤的一个用途是将内容按摩成更方便平台、文件系统和用户使用的形状。对于这种操作模式,这里的关键词是 &quot;更方便&quot;,而不是 &quot;把不可用的东西变成可用的&quot;。换句话说,我们的意图是,如果有人取消了过滤驱动定义,或者没有相应的过滤程序,项目应该还是可以使用的。</target>
        </trans-unit>
        <trans-unit id="bf346c4d1c8b72f5f128424640398ae0ca4f5b99" translate="yes" xml:space="preserve">
          <source>One way to test if your MUA is set up correctly is:</source>
          <target state="translated">测试你的MUA设置是否正确的一个方法是。</target>
        </trans-unit>
        <trans-unit id="b7da7d48889d5c708679796bf76623241882d879" translate="yes" xml:space="preserve">
          <source>Only allow viewing of repositories also shown on the overview page. This for example makes &lt;code&gt;$export_ok&lt;/code&gt; file decide if repository is available and not only if it is shown. If &lt;code&gt;$projects_list&lt;/code&gt; points to file with list of project, only those repositories listed would be available for gitweb. Can be set during building gitweb via &lt;code&gt;GITWEB_STRICT_EXPORT&lt;/code&gt;. By default this variable is not set, which means that you can directly access those repositories that are hidden from projects list page (e.g. the are not listed in the $projects_list file).</source>
          <target state="translated">只允许查看也在概述页面上显示的存储库。例如，这使 &lt;code&gt;$export_ok&lt;/code&gt; 文件决定存储库是否可用，不仅决定是否显示存储库。如果 &lt;code&gt;$projects_list&lt;/code&gt; 指向包含项目列表的文件，则只有列出的存储库可用于gitweb。可以在构建gitweb时通过 &lt;code&gt;GITWEB_STRICT_EXPORT&lt;/code&gt; 进行设置。默认情况下，未设置此变量，这意味着您可以直接访问从项目列表页面隐藏的存储库（例如，未在$ projects_list文件中列出的存储库）。</target>
        </trans-unit>
        <trans-unit id="a9db6957ecdccb26c443588b379fe63817da234e" translate="yes" xml:space="preserve">
          <source>Only anonymous access is provided by pserve by default. To commit you will have to create pserver accounts, simply add a gitcvs.authdb setting in the config file of the repositories you want the cvsserver to allow writes to, for example:</source>
          <target state="translated">pserve默认只提供匿名访问。如果要提交,你必须创建 pserver 账户,只需在你希望 cvsserver 允许写入的仓库的配置文件中添加 gitcvs.authdb 设置即可,例如</target>
        </trans-unit>
        <trans-unit id="f8de1f9ddde9f99ee756c31ae048d708dda7832c" translate="yes" xml:space="preserve">
          <source>Only bind the web server to the local IP (127.0.0.1).</source>
          <target state="translated">只将Web服务器绑定到本地IP(127.0.0.1)。</target>
        </trans-unit>
        <trans-unit id="914060d4007bba68d0e5b57a08eb8520cbc0281b" translate="yes" xml:space="preserve">
          <source>Only consider tags matching the given &lt;code&gt;glob(7)&lt;/code&gt; pattern, excluding the &quot;refs/tags/&quot; prefix. If used with &lt;code&gt;--all&lt;/code&gt;, it also considers local branches and remote-tracking references matching the pattern, excluding respectively &quot;refs/heads/&quot; and &quot;refs/remotes/&quot; prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated, and tags matching any of the patterns will be considered. Use &lt;code&gt;--no-match&lt;/code&gt; to clear and reset the list of patterns.</source>
          <target state="translated">仅考虑匹配给定 &lt;code&gt;glob(7)&lt;/code&gt; 模式的标签，但不包括&amp;ldquo; refs / tags /&amp;rdquo;前缀。如果与 &lt;code&gt;--all&lt;/code&gt; 一起使用，它还将考虑与该模式匹配的本地分支和远程跟踪引用，分别排除&amp;ldquo; refs / heads /&amp;rdquo;和&amp;ldquo; refs / remotes /&amp;rdquo;前缀；从不考虑其他类型的引用。如果多次给出，将累积模式列表，并考虑与任何模式匹配的标签。使用 &lt;code&gt;--no-match&lt;/code&gt; 清除并重置模式列表。</target>
        </trans-unit>
        <trans-unit id="941066ff4f5ea2a1056ac361a36573c125ff04f2" translate="yes" xml:space="preserve">
          <source>Only create a packed archive if it would contain at least one object.</source>
          <target state="translated">只有在至少包含一个对象的情况下,才会创建一个打包的存档。</target>
        </trans-unit>
        <trans-unit id="83ca14f8cd2c9566aaa74ad9a438e0a15bc783b9" translate="yes" xml:space="preserve">
          <source>Only expire loose objects older than &amp;lt;time&amp;gt;.</source>
          <target state="translated">仅使早于&amp;lt;time&amp;gt;的松散对象过期。</target>
        </trans-unit>
        <trans-unit id="d50becec82fb156672fd24c1ecb55cefe6d9b0c0" translate="yes" xml:space="preserve">
          <source>Only list branches of the given object.</source>
          <target state="translated">只列出给定对象的分支。</target>
        </trans-unit>
        <trans-unit id="ae8314faed018be3007d334a54cd4f7b3bde067a" translate="yes" xml:space="preserve">
          <source>Only list branches which contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">仅列出包含指定提交的分支（如果未指定，则为HEAD）。暗示 &lt;code&gt;--list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b39fcb7ccfd206d2a11b5cac77f876ebbcdc59a6" translate="yes" xml:space="preserve">
          <source>Only list branches which don&amp;rsquo;t contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">仅列出不包含指定提交的分支（如果未指定，则为HEAD）。暗示 &lt;code&gt;--list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d91bc93b24e96b92cd74b3016507c8892f02d8e" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are not reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;, incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">仅列出其提示无法从指定提交（如果未指定，则为HEAD）无法到达的分支。表示 &lt;code&gt;--list&lt;/code&gt; ，与 &lt;code&gt;--merged&lt;/code&gt; 不兼容。</target>
        </trans-unit>
        <trans-unit id="368e1f5311ab357c6579dd2598d3554e5f69ab7b" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;, incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">仅列出其提示可从指定提交（如果未指定，则为HEAD）可到达的分支。表示 &lt;code&gt;--list&lt;/code&gt; ，与 &lt;code&gt;--no-merged&lt;/code&gt; 不兼容。</target>
        </trans-unit>
        <trans-unit id="dc004fe98c7c853edcd721c4a4743bbe17dc0ceb" translate="yes" xml:space="preserve">
          <source>Only list refs which contain the specified commit (HEAD if not specified).</source>
          <target state="translated">只列出包含指定提交的refs(如果没有指定HEAD)。</target>
        </trans-unit>
        <trans-unit id="53301ab6d13e8c23069a84dba2acf3daf5a67784" translate="yes" xml:space="preserve">
          <source>Only list refs which don&amp;rsquo;t contain the specified commit (HEAD if not specified).</source>
          <target state="translated">仅列出不包含指定提交的引用（如果未指定，则为HEAD）。</target>
        </trans-unit>
        <trans-unit id="13917fddfb76486aac0b6b32382a8222d7ef7129" translate="yes" xml:space="preserve">
          <source>Only list refs which points at the given object.</source>
          <target state="translated">只列出指向给定对象的参考文献。</target>
        </trans-unit>
        <trans-unit id="d63446ed3ed439dd64fa48118858d7dc8f885568" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are not reachable from the specified commit (HEAD if not specified), incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">仅列出其提示无法从指定提交（如果未指定， &lt;code&gt;--merged&lt;/code&gt; HEAD）无法获得的列表引用，与--merged不兼容。</target>
        </trans-unit>
        <trans-unit id="b4d24af2a09941026de883e7412997a62ab6d500" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are reachable from the specified commit (HEAD if not specified), incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">仅列出其提示可从指定提交（如果未指定，则为HEAD）可访问的列表引用，与 &lt;code&gt;--no-merged&lt;/code&gt; 不兼容。</target>
        </trans-unit>
        <trans-unit id="817a4e30ee524e4266621c0a4648ab3909ffeed4" translate="yes" xml:space="preserve">
          <source>Only list tags of the given object (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">仅列出给定对象的标签（如果未指定，则为HEAD）。暗示 &lt;code&gt;--list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83f1d08e3476b4b0f43eedc9885a23e56ff396f3" translate="yes" xml:space="preserve">
          <source>Only list tags which contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">仅列出包含指定提交的标签（如果未指定，则为HEAD）。暗示 &lt;code&gt;--list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bae480f98a8915919a61381cb993558ff75823a" translate="yes" xml:space="preserve">
          <source>Only list tags which don&amp;rsquo;t contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">仅列出不包含指定提交的标记（如果未指定，则为HEAD）。暗示 &lt;code&gt;--list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db9714bdab86b2c5263129a27ca40bb06f5dcdf2" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are not reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified), incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">仅列出其提交不能从指定提交（如果未指定， &lt;code&gt;--merged&lt;/code&gt; &lt;code&gt;HEAD&lt;/code&gt; ）无法与--merged兼容的标记。</target>
        </trans-unit>
        <trans-unit id="1c62aa2054943bc2c5749c5693c2757ab8e53449" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified), incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">仅列出可从指定提交（如果未指定，则为 &lt;code&gt;HEAD&lt;/code&gt; ）可实现提交的标记，与 &lt;code&gt;--no-merged&lt;/code&gt; 不兼容。</target>
        </trans-unit>
        <trans-unit id="b0cdb0cde0c40de0beaaced5d658f2a7018630fe" translate="yes" xml:space="preserve">
          <source>Only look at the history which touches the given subdirectory. The result will contain that directory (and only that) as its project root. Implies &lt;a href=&quot;#Remap_to_ancestor&quot;&gt;Remap to ancestor&lt;/a&gt;.</source>
          <target state="translated">只查看涉及给定子目录的历史记录。结果将包含该目录（并且仅包含该目录）作为其项目根目录。暗示重新&lt;a href=&quot;#Remap_to_ancestor&quot;&gt;映射到祖先&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2bbdf47a64eee45ee95696813788d11863c01152" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Lets the option parser stop at the first non-option argument. This can be used to parse sub-commands that take options themselves.</source>
          <target state="translated">仅在 &lt;code&gt;--parseopt&lt;/code&gt; 模式下有意义。使选项解析器在第一个非选项参数处停止。这可用于解析本身带有选项的子命令。</target>
        </trans-unit>
        <trans-unit id="d8057f98f6fd66c86adb34f091c531e316f7ca42" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Output the options in their long form if available, and with their arguments stuck.</source>
          <target state="translated">仅在 &lt;code&gt;--parseopt&lt;/code&gt; 模式下有意义。如果可用，则以其长格式输出选项，并且将其参数卡住。</target>
        </trans-unit>
        <trans-unit id="6000fe90599266e72e627572d6cdbc969916ee02" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Tells the option parser to echo out the first &lt;code&gt;--&lt;/code&gt; met instead of skipping it.</source>
          <target state="translated">仅在 &lt;code&gt;--parseopt&lt;/code&gt; 模式下有意义。告诉选项解析器回声出第一 &lt;code&gt;--&lt;/code&gt; 遇见的不是跳过它。</target>
        </trans-unit>
        <trans-unit id="fd3f5d99fba63ca8e5d281298074650f7e9548b0" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--verify&lt;/code&gt; mode. Do not output an error message if the first argument is not a valid object name; instead exit with non-zero status silently. SHA-1s for valid object names are printed to stdout on success.</source>
          <target state="translated">仅在 &lt;code&gt;--verify&lt;/code&gt; 模式下有意义。如果第一个参数不是有效的对象名称，则不输出错误消息；而是以非零状态静默退出。有效对象名称的SHA-1成功时将打印到标准输出。</target>
        </trans-unit>
        <trans-unit id="94590902338d0f64df58223a7c9238b6579f4aae" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--pathspec-from-file&lt;/code&gt;. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).</source>
          <target state="translated">仅对 &lt;code&gt;--pathspec-from-file&lt;/code&gt; 有意义。Pathspec元素用NUL字符分隔，所有其他字符按字面意义使用（包括换行符和引号）。</target>
        </trans-unit>
        <trans-unit id="0ecebefb0a1162c42954005e600970eacea40ab1" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--stdin&lt;/code&gt; or &lt;code&gt;--index-info&lt;/code&gt;; paths are separated with NUL character instead of LF.</source>
          <target state="translated">唯一有意义的与 &lt;code&gt;--stdin&lt;/code&gt; 或 &lt;code&gt;--index-info&lt;/code&gt; ; 路径用NUL字符而不是LF分隔。</target>
        </trans-unit>
        <trans-unit id="6ad4315a7f6c11660aa6c643c4b95eaab7a8d728" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--stdin&lt;/code&gt;; paths are separated with NUL character instead of LF.</source>
          <target state="translated">仅对 &lt;code&gt;--stdin&lt;/code&gt; 有意义；路径用NUL字符而不是LF分隔。</target>
        </trans-unit>
        <trans-unit id="2ebb91d27792ee23446f1d49f12e2e8cf850fef7" translate="yes" xml:space="preserve">
          <source>Only necessary if --compose is also set. If --compose is not set, this will be prompted for.</source>
          <target state="translated">只有在设置了--compose的情况下才需要。如果没有设置 ----组成,则会有提示。</target>
        </trans-unit>
        <trans-unit id="3a2cfa8e4dfa7576e427c217c4a335798a141827" translate="yes" xml:space="preserve">
          <source>Only one parameter should be set to &quot;1&quot; when the hook runs. The hook running passing &quot;1&quot;, &quot;1&quot; should not be possible.</source>
          <target state="translated">钩子运行时,只能设置一个参数为 &quot;1&quot;。钩子运行传递 &quot;1&quot;,&quot;1 &quot;应该是不可能的。</target>
        </trans-unit>
        <trans-unit id="bf7e12b67481a70907ee19a1cd34bdb9c2cfbcbb" translate="yes" xml:space="preserve">
          <source>Only output exact matches (a tag directly references the supplied commit). This is a synonym for --candidates=0.</source>
          <target state="translated">只输出完全匹配的内容(标签直接引用提供的提交)。这是 --candidates=0 的同义词。</target>
        </trans-unit>
        <trans-unit id="16dbfb260245eaec3998212f13b1a52e2d286e0a" translate="yes" xml:space="preserve">
          <source>Only p4 labels matching this regular expression will be exported. The default value is &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt;.</source>
          <target state="translated">仅匹配此正则表达式的p4标签将被导出。默认值为 &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eeb8bb30ea7ba21536e78e1ff49007a02268174b" translate="yes" xml:space="preserve">
          <source>Only p4 labels matching this regular expression will be imported. The default value is &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt;.</source>
          <target state="translated">仅匹配此正则表达式的p4标签将被导入。默认值为 &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2fdb861f4cc24f6e2448e8ab0d3c248ec24997f" translate="yes" xml:space="preserve">
          <source>Only perform tests on the working directory to make sure untracked cache can be used. You have to manually enable untracked cache using &lt;code&gt;--untracked-cache&lt;/code&gt; or &lt;code&gt;--force-untracked-cache&lt;/code&gt; or the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable afterwards if you really want to use it. If a test fails the exit code is 1 and a message explains what is not working as needed, otherwise the exit code is 0 and OK is printed.</source>
          <target state="translated">仅在工作目录上执行测试以确保可以使用未跟踪的缓存。您必须使用手动启用未跟踪缓存 &lt;code&gt;--untracked-cache&lt;/code&gt; 或 &lt;code&gt;--force-untracked-cache&lt;/code&gt; 或 &lt;code&gt;core.untrackedCache&lt;/code&gt; 配置变量之后，如果你真的想用它。如果测试失败，则退出代码为1，并显示一条消息，说明无法根据需要进行操作，否则退出代码为0，并打印OK。</target>
        </trans-unit>
        <trans-unit id="9b88e48a96d98ad3b76de8b5d274db692fc6b29c" translate="yes" xml:space="preserve">
          <source>Only print error and warning messages; all other output will be suppressed.</source>
          <target state="translated">只打印错误和警告信息,其他所有输出都将被抑制。</target>
        </trans-unit>
        <trans-unit id="3791d8648f923430d0795b4e9f5031ac211bf7f1" translate="yes" xml:space="preserve">
          <source>Only print error messages.</source>
          <target state="translated">只打印错误信息。</target>
        </trans-unit>
        <trans-unit id="affbeb73b1dd267a08167d9ea74afe477ad3529f" translate="yes" xml:space="preserve">
          <source>Only show the SHA-1 hash, not the reference name. When combined with --dereference the dereferenced tag will still be shown after the SHA-1.</source>
          <target state="translated">只显示SHA-1哈希值,不显示引用名称。当与--dereference结合使用时,在SHA-1之后仍然会显示被取消引用的标签。</target>
        </trans-unit>
        <trans-unit id="74a12c610ac9d71beb7074574ccb847224f9f712" translate="yes" xml:space="preserve">
          <source>Only show the given commits, but do not traverse their ancestors. This has no effect if a range is specified. If the argument &lt;code&gt;unsorted&lt;/code&gt; is given, the commits are shown in the order they were given on the command line. Otherwise (if &lt;code&gt;sorted&lt;/code&gt; or no argument was given), the commits are shown in reverse chronological order by commit time. Cannot be combined with &lt;code&gt;--graph&lt;/code&gt;.</source>
          <target state="translated">仅显示给定的提交，而不遍历其祖先。如果指定范围，则无效。如果给出了 &lt;code&gt;unsorted&lt;/code&gt; 参数，则按照在命令行中给出的顺序显示提交。否则（如果已 &lt;code&gt;sorted&lt;/code&gt; 或未提供任何参数），则提交将按提交时间以相反的时间顺序显示。不能与 &lt;code&gt;--graph&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="6ed956e65db38a49fac1dac50248e7edb1c43fb7" translate="yes" xml:space="preserve">
          <source>Only submodules using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will be removed from the work tree, as their repository lives inside the .git directory of the superproject. If a submodule (or one of those nested inside it) still uses a .git directory, &lt;code&gt;git rm&lt;/code&gt; will move the submodules git directory into the superprojects git directory to protect the submodule&amp;rsquo;s history. If it exists the submodule.&amp;lt;name&amp;gt; section in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file will also be removed and that file will be staged (unless --cached or -n are used).</source>
          <target state="translated">只有使用gitfile的子模块（这意味着它们是使用1.7.8或更高版本的Git版本克隆的）才会从工作树中删除，因为它们的存储库位于超级项目的.git目录中。如果子模块（或其中一个嵌套模块）仍使用.git目录，则 &lt;code&gt;git rm&lt;/code&gt; 会将子模块git目录移动到superprojects git目录中，以保护子模块的历史记录。如果存在，则&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;文件中的submodule。&amp;lt;name&amp;gt;部分也将被删除并暂存该文件（除非使用--cached或-n）。</target>
        </trans-unit>
        <trans-unit id="f3b6918bb732fd2722633a305233dd0ec34bff15" translate="yes" xml:space="preserve">
          <source>Only takes effect for dates shown in human-readable format, such as when using &lt;code&gt;--pretty&lt;/code&gt;. &lt;code&gt;log.date&lt;/code&gt; config variable sets a default value for the log command&amp;rsquo;s &lt;code&gt;--date&lt;/code&gt; option. By default, dates are shown in the original time zone (either committer&amp;rsquo;s or author&amp;rsquo;s). If &lt;code&gt;-local&lt;/code&gt; is appended to the format (e.g., &lt;code&gt;iso-local&lt;/code&gt;), the user&amp;rsquo;s local time zone is used instead.</source>
          <target state="translated">仅对以人类可读格式显示的日期生效，例如使用 &lt;code&gt;--pretty&lt;/code&gt; 时。 &lt;code&gt;log.date&lt;/code&gt; 配置变量为log命令的 &lt;code&gt;--date&lt;/code&gt; 选项设置默认值。默认情况下，日期显示在原始时区（提交者或作者的时间）中。如果将 &lt;code&gt;-local&lt;/code&gt; 附加到格式（例如 &lt;code&gt;iso-local&lt;/code&gt; ），则使用用户的本地时区。</target>
        </trans-unit>
        <trans-unit id="28227446e42814d459bad1017137f194a3d411bf" translate="yes" xml:space="preserve">
          <source>Only the initial ref advertisement is output, and the program exits immediately. This fits with the HTTP GET request model, where no request content is received but a response must be produced.</source>
          <target state="translated">只输出初始ref广告,程序立即退出。这符合HTTP GET请求模型,不接收请求内容,但必须产生响应。</target>
        </trans-unit>
        <trans-unit id="d70e32ee66c9f176a2ec41ee4464e248b98de054" translate="yes" xml:space="preserve">
          <source>Only the rev_map and refs/remotes/git-svn are changed (see &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; in the FILES section below for details). Follow &lt;code&gt;reset&lt;/code&gt; with a &lt;code&gt;fetch&lt;/code&gt; and then &lt;code&gt;git reset&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt; to move local branches onto the new tree.</source>
          <target state="translated">仅rev_map和refs / remotes / git-svn被更改（有关详细信息，请参见下面&amp;ldquo; FILES&amp;rdquo;部分中的 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; ）。按照 &lt;code&gt;reset&lt;/code&gt; 与 &lt;code&gt;fetch&lt;/code&gt; ，然后 &lt;code&gt;git reset&lt;/code&gt; 或 &lt;code&gt;git rebase&lt;/code&gt; 到移动本地分支到新树。</target>
        </trans-unit>
        <trans-unit id="32e7b8a674c1b57420afbf6e783864cc587eae94" translate="yes" xml:space="preserve">
          <source>Only the selected commits are shown, plus some to have a meaningful history.</source>
          <target state="translated">只显示选定的提交,加上一些有意义的历史。</target>
        </trans-unit>
        <trans-unit id="5988bcb17bfff8bdefbf4f11c653c30a84ac354c" translate="yes" xml:space="preserve">
          <source>Only untracked files in submodules will be ignored. Committed differences and modifications to tracked files will show up.</source>
          <target state="translated">只有子模块中未跟踪的文件会被忽略。已提交的差异和对已跟踪文件的修改会显示出来。</target>
        </trans-unit>
        <trans-unit id="a35d5f8b7ffccc1327ae3b4b170fadaf17be62a8" translate="yes" xml:space="preserve">
          <source>Only update and add files to the working directory, but don&amp;rsquo;t delete them, similar to how 'cp -R' would update the contents in the destination directory. This is the default mode in a &lt;a href=&quot;#def_checkout&quot;&gt;checkout&lt;/a&gt; when checking out files from the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; or a &lt;a href=&quot;#def_tree-ish&quot;&gt;tree-ish&lt;/a&gt;. In contrast, no-overlay mode also deletes tracked files not present in the source, similar to 'rsync --delete'.</source>
          <target state="translated">仅更新文件并将其添加到工作目录中，而不删除它们，类似于'cp -R'将更新目标目录中的内容。这是在默认模式&lt;a href=&quot;#def_checkout&quot;&gt;结账&lt;/a&gt;退房从文件时&lt;a href=&quot;#def_index&quot;&gt;指数&lt;/a&gt;或&lt;a href=&quot;#def_tree-ish&quot;&gt;树十岁上下&lt;/a&gt;。相反，无覆盖模式也会删除源中不存在的跟踪文件，类似于&amp;ldquo; rsync --delete&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a09a6feef23c1bf8bf8489c07fa754b0e3467e64" translate="yes" xml:space="preserve">
          <source>Only update and add files to the working directory, but don&amp;rsquo;t delete them, similar to how &lt;code&gt;cp -R&lt;/code&gt; would update the contents in the destination directory. This is the default mode in a &lt;a href=&quot;#def_checkout&quot;&gt;checkout&lt;/a&gt; when checking out files from the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; or a &lt;a href=&quot;#def_tree-ish&quot;&gt;tree-ish&lt;/a&gt;. In contrast, no-overlay mode also deletes tracked files not present in the source, similar to &lt;code&gt;rsync --delete&lt;/code&gt;.</source>
          <target state="translated">仅更新文件并将其添加到工作目录中，而不删除它们，类似于 &lt;code&gt;cp -R&lt;/code&gt; 将更新目标目录中的内容。这是在默认模式&lt;a href=&quot;#def_checkout&quot;&gt;结账&lt;/a&gt;退房从文件时&lt;a href=&quot;#def_index&quot;&gt;指数&lt;/a&gt;或&lt;a href=&quot;#def_tree-ish&quot;&gt;树十岁上下&lt;/a&gt;。相反，无覆盖模式也会删除源中不存在的跟踪文件，类似于 &lt;code&gt;rsync --delete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd6ac5160ec46e3d1df2371d183d50a5e06ffdbe" translate="yes" xml:space="preserve">
          <source>Only use refs whose names match a given shell pattern. The pattern can be one of branch name, tag name or fully qualified ref name. If given multiple times, use refs whose names match any of the given shell patterns. Use &lt;code&gt;--no-refs&lt;/code&gt; to clear any previous ref patterns given.</source>
          <target state="translated">仅使用名称与给定外壳模式匹配的引用。该模式可以是分支名称，标记名称或标准引用名称之一。如果多次给出，请使用名称与任何给定的shell模式匹配的refs。使用 &lt;code&gt;--no-refs&lt;/code&gt; 清除以前给定的所有引用模式。</target>
        </trans-unit>
        <trans-unit id="2d533153e7612cafa4bc7b83b50dd3abb697af0e" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;set-tree&lt;/code&gt; and &lt;code&gt;commit-diff&lt;/code&gt; commands.</source>
          <target state="translated">仅与 &lt;code&gt;dcommit&lt;/code&gt; ， &lt;code&gt;set-tree&lt;/code&gt; 和 &lt;code&gt;commit-diff&lt;/code&gt; 命令一起使用。</target>
        </trans-unit>
        <trans-unit id="901e1e4a237282bb48e582bb5bf0599881cd0084" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;init&lt;/code&gt; command. These are passed directly to &lt;code&gt;git init&lt;/code&gt;.</source>
          <target state="translated">仅与 &lt;code&gt;init&lt;/code&gt; 命令一起使用。这些直接传递给 &lt;code&gt;git init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5e61001de0ada8f2eb5dc9bbc0a16644112482b" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;set-tree&lt;/code&gt; command.</source>
          <target state="translated">仅与 &lt;code&gt;set-tree&lt;/code&gt; 命令一起使用。</target>
        </trans-unit>
        <trans-unit id="e227b5617ca7c2b377054ab1d12644a8cc591504" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--filter=&lt;/code&gt;; prints a list of the objects omitted by the filter. Object IDs are prefixed with a &amp;ldquo;~&amp;rdquo; character.</source>
          <target state="translated">仅对 &lt;code&gt;--filter=&lt;/code&gt; 有用；打印过滤器省略的对象列表。对象ID的前缀为&amp;ldquo;〜&amp;rdquo;字符。</target>
        </trans-unit>
        <trans-unit id="c898c5ecedbff05a6572c10f50d4d5872a590271" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; does not print the names of the object IDs that are found. This inverts &lt;code&gt;--object-names&lt;/code&gt;. This flag allows the output to be more easily parsed by commands such as &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt;.</source>
          <target state="translated">仅对 &lt;code&gt;--objects&lt;/code&gt; 有用；不打印找到的对象ID的名称。这会 &lt;code&gt;--object-names&lt;/code&gt; 。该标志允许通过&lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1]之&lt;/a&gt;类的命令更轻松地解析输出。</target>
        </trans-unit>
        <trans-unit id="cbbf115261d96b04c5005e948b7d150b4779f83e" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; print the names of the object IDs that are found. This is the default behavior.</source>
          <target state="translated">仅对 &lt;code&gt;--objects&lt;/code&gt; 有用；打印找到的对象ID的名称。这是默认行为。</target>
        </trans-unit>
        <trans-unit id="96aa4c0ed29b4ff25b67f82110d672c478c9f0a4" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; print the object IDs that are not in packs.</source>
          <target state="translated">仅对 &lt;code&gt;--objects&lt;/code&gt; 有用；打印不在包装中的对象ID。</target>
        </trans-unit>
        <trans-unit id="395c9938b3e2e6eaf4d1417f6499451782d5fa84" translate="yes" xml:space="preserve">
          <source>Only useful with one of the &lt;code&gt;--objects*&lt;/code&gt;; omits objects (usually blobs) from the list of printed objects. The &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; may be one of the following:</source>
          <target state="translated">仅对 &lt;code&gt;--objects*&lt;/code&gt; 之一有用；从打印对象列表中删除对象（通常是斑点）。所述 &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; 可以是下列之一：</target>
        </trans-unit>
        <trans-unit id="c55263ee2e693cf4a68e8c688a3aeedef8c016f1" translate="yes" xml:space="preserve">
          <source>Only valid setting is &quot;--unified=??&quot; or &quot;-u??&quot; to set the number of context lines shown when a unified diff is created. This takes precedence over any &quot;-U&quot; or &quot;--unified&quot; option value passed on the Git diff command line.</source>
          <target state="translated">只有&quot;--unified=? &quot;或&quot;-u? &quot;才是有效的设置,用于设置创建统一的 diff 时显示的上下文行数。它优先于Git diff命令行中传递的&quot;-U &quot;或&quot;--unified &quot;选项值。</target>
        </trans-unit>
        <trans-unit id="77fb8a535dafe4973135cbd89eaf06e8f07b4529" translate="yes" xml:space="preserve">
          <source>Only works if the changes (patch IDs based on the diff contents) on &lt;code&gt;subsystem&lt;/code&gt; are literally the same before and after the rebase &lt;code&gt;subsystem&lt;/code&gt; did.</source>
          <target state="translated">仅在 &lt;code&gt;subsystem&lt;/code&gt; 更改之前和之后， &lt;code&gt;subsystem&lt;/code&gt; 上的更改（基于diff内容的修补程序ID）在字面上相同时才起作用。</target>
        </trans-unit>
        <trans-unit id="5a64b44f8d7042d0b4832141c36a7e5d8d6c4434" translate="yes" xml:space="preserve">
          <source>Oops. That wasn&amp;rsquo;t very readable. It just spit out its own internal version of a &lt;code&gt;diff&lt;/code&gt;, but that internal version really just tells you that it has noticed that &quot;hello&quot; has been modified, and that the old object contents it had have been replaced with something else.</source>
          <target state="translated">哎呀。那不是很可读。它只是吐出了自己的 &lt;code&gt;diff&lt;/code&gt; 内部版本，但该内部版本实际上只是告诉您，它已经注意到&amp;ldquo; hello&amp;rdquo;已被修改，并且其旧对象内容已被其他内容替换。</target>
        </trans-unit>
        <trans-unit id="0e55d62611877e337f8aa065fb0b3d20e9fe0e5a" translate="yes" xml:space="preserve">
          <source>Open a compose window and click the external editor icon.</source>
          <target state="translated">打开编译窗口,点击外部编辑器图标。</target>
        </trans-unit>
        <trans-unit id="db4ff8c108e7b94773be0de613a7b629cb1df8fa" translate="yes" xml:space="preserve">
          <source>Open an editor and edit the text to explain what the branch is for, to be used by various other commands (e.g. &lt;code&gt;format-patch&lt;/code&gt;, &lt;code&gt;request-pull&lt;/code&gt;, and &lt;code&gt;merge&lt;/code&gt; (if enabled)). Multi-line explanations may be used.</source>
          <target state="translated">打开编辑器并编辑文本以解释分支的用途，该分支将由其他各种命令使用（例如 &lt;code&gt;format-patch&lt;/code&gt; ， &lt;code&gt;request-pull&lt;/code&gt; 和 &lt;code&gt;merge&lt;/code&gt; （如果启用））。可以使用多行说明。</target>
        </trans-unit>
        <trans-unit id="577c09c011d74bfddaa145d1c3817d3d9900cb19" translate="yes" xml:space="preserve">
          <source>Open the diff vs. the index in an editor and let the user edit it. After the editor was closed, adjust the hunk headers and apply the patch to the index.</source>
          <target state="translated">在编辑器中打开diff与index,让用户编辑。关闭编辑器后,调整hunk头,并将补丁应用到索引上。</target>
        </trans-unit>
        <trans-unit id="1e40bc8b6fc685aae183dd5f07e4256cd3e46abe" translate="yes" xml:space="preserve">
          <source>Open the matching files in the pager (not the output of &lt;code&gt;grep&lt;/code&gt;). If the pager happens to be &quot;less&quot; or &quot;vi&quot;, and the user specified only one pattern, the first file is positioned at the first match automatically. The &lt;code&gt;pager&lt;/code&gt; argument is optional; if specified, it must be stuck to the option without a space. If &lt;code&gt;pager&lt;/code&gt; is unspecified, the default pager will be used (see &lt;code&gt;core.pager&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">在分页器中打开匹配的文件（不是 &lt;code&gt;grep&lt;/code&gt; 的输出）。如果寻呼机恰好是&amp;ldquo;较少&amp;rdquo;或&amp;ldquo; vi&amp;rdquo;，并且用户仅指定了一个模式，则第一个文件将自动定位在第一个匹配项上。该 &lt;code&gt;pager&lt;/code&gt; 参数是可选的; 如果指定，则必须将其固定在选项中，且不能留空格。如果 &lt;code&gt;pager&lt;/code&gt; 未指定，则默认寻呼机将被使用（参见 &lt;code&gt;core.pager&lt;/code&gt; 在&lt;a href=&quot;git-config&quot;&gt;GIT-配置[1] &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8ab75f225f79420c5b860ca24bd40f7491c784f1" translate="yes" xml:space="preserve">
          <source>Opens an editor to modify the specified config file; either &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, or repository (default).</source>
          <target state="translated">打开编辑器来修改指定的配置文件；无论是 &lt;code&gt;--system&lt;/code&gt; ， &lt;code&gt;--global&lt;/code&gt; ，或储存库（默认值）。</target>
        </trans-unit>
        <trans-unit id="869e0439c9b6be4fa4547f64fcc46a677445443d" translate="yes" xml:space="preserve">
          <source>Operate quietly. Implies --no-progress.</source>
          <target state="translated">静静地运作。意味着没有进展。</target>
        </trans-unit>
        <trans-unit id="976297b1ff380abe9b067b3a1569ff64fe97ece7" translate="yes" xml:space="preserve">
          <source>Operate quietly. Progress is not reported to the standard error stream.</source>
          <target state="translated">静静地操作。不向标准误差流报告进度。</target>
        </trans-unit>
        <trans-unit id="09f22e6b29a644f35840ab8527beed58937c2452" translate="yes" xml:space="preserve">
          <source>Operating modes</source>
          <target state="translated">操作模式</target>
        </trans-unit>
        <trans-unit id="b5ddf3c63568d76ebc23d453be7fdb731eb8db1b" translate="yes" xml:space="preserve">
          <source>Operation Modes</source>
          <target state="translated">操作模式</target>
        </trans-unit>
        <trans-unit id="7196d0b4f156df0cb7286af7737967727f46300d" translate="yes" xml:space="preserve">
          <source>Operation modes</source>
          <target state="translated">操作模式</target>
        </trans-unit>
        <trans-unit id="1bc69d57cbb59ff5bdbc63f455c23bce178e5e54" translate="yes" xml:space="preserve">
          <source>Operations supported</source>
          <target state="translated">支持的业务</target>
        </trans-unit>
        <trans-unit id="573db325843d7fd90adea414c1ffec090ab48249" translate="yes" xml:space="preserve">
          <source>Optimize a pack that will be provided to a client with a shallow repository. This option, combined with --thin, can result in a smaller pack at the cost of speed.</source>
          <target state="translated">优化将提供给客户端的浅层存储库的数据包。这个选项和--thin结合起来,可以以牺牲速度为代价获得一个更小的包。</target>
        </trans-unit>
        <trans-unit id="4679da9817f2d593d1926870257534b31ee86cfa" translate="yes" xml:space="preserve">
          <source>Option commands must be the first commands on the input (not counting feature commands), to give an option command after any non-option command is an error.</source>
          <target state="translated">选项命令必须是输入的第一条命令(不算特征命令),在任何非选项命令之后给出选项命令是错误的。</target>
        </trans-unit>
        <trans-unit id="da44303dd559700c5ce39d2667eb27c2885407ef" translate="yes" xml:space="preserve">
          <source>Optional &amp;lt;path&amp;gt; arguments limit which submodules will be initialized. If no path is specified and submodule.active has been configured, submodules configured to be active will be initialized, otherwise all submodules are initialized.</source>
          <target state="translated">可选的&amp;lt;path&amp;gt;参数限制将初始化哪些子模块。如果未指定路径并且已配置submodule.active，则将初始化配置为活动的子模块，否则将初始化所有子模块。</target>
        </trans-unit>
        <trans-unit id="be215efb6b35fec1e17ea79655a45bba1595ca40" translate="yes" xml:space="preserve">
          <source>Optionally a new branch could be created with either &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, automatically from a remote branch of same name (see &lt;code&gt;--guess&lt;/code&gt;), or detach the working tree from any branch with &lt;code&gt;--detach&lt;/code&gt;, along with switching.</source>
          <target state="translated">可选地，可以使用 &lt;code&gt;-c&lt;/code&gt; ， &lt;code&gt;-C&lt;/code&gt; 从同名的远程分支自动创建一个新分支（请参阅 &lt;code&gt;--guess&lt;/code&gt; ），或者使用 &lt;code&gt;--detach&lt;/code&gt; 将工作树与任何分支分离，并进行切换。</target>
        </trans-unit>
        <trans-unit id="d773dc6382eb3328de30b1c7224e0be840082992" translate="yes" xml:space="preserve">
          <source>Optionally may output a &lt;code&gt;lock &amp;lt;file&amp;gt;&lt;/code&gt; line indicating the full path of a file under &lt;code&gt;$GIT_DIR/objects/pack&lt;/code&gt; which is keeping a pack until refs can be suitably updated. The path must end with &lt;code&gt;.keep&lt;/code&gt;. This is a mechanism to name a &amp;lt;pack,idx,keep&amp;gt; tuple by giving only the keep component. The kept pack will not be deleted by a concurrent repack, even though its objects may not be referenced until the fetch completes. The &lt;code&gt;.keep&lt;/code&gt; file will be deleted at the conclusion of the fetch.</source>
          <target state="translated">（可选）可以输出一条 &lt;code&gt;lock &amp;lt;file&amp;gt;&lt;/code&gt; 行，该行指示 &lt;code&gt;$GIT_DIR/objects/pack&lt;/code&gt; 下文件的完整路径，该文件将保留一个包，直到可以适当更新引用为止。该路径必须以 &lt;code&gt;.keep&lt;/code&gt; 结尾。这是通过仅提供keep组件来命名&amp;lt;pack，idx，keep&amp;gt;元组的机制。即使在提取完成之前可能不会引用其对象，也不会通过并发重新打包删除保留的包。该 &lt;code&gt;.keep&lt;/code&gt; 文件将在抓取的结论被删除。</target>
        </trans-unit>
        <trans-unit id="66770b44a484bf62b3beb74f057263164da82747" translate="yes" xml:space="preserve">
          <source>Optionally with -m:</source>
          <target state="translated">可选择用-m。</target>
        </trans-unit>
        <trans-unit id="3e5a4f0fcbf7c88862ec022584d8faedebb202bf" translate="yes" xml:space="preserve">
          <source>Optionally, a &amp;lt;ref&amp;gt; parameter can be prefixed with a plus &lt;code&gt;+&lt;/code&gt; sign to disable the fast-forward check only on that ref.</source>
          <target state="translated">（可选）可以在&amp;lt;ref&amp;gt;参数前面加上加号 &lt;code&gt;+&lt;/code&gt; 以仅对该ref禁用快速转发检查。</target>
        </trans-unit>
        <trans-unit id="5ad18880dec3737f40f1be35d71296de89bc6175" translate="yes" xml:space="preserve">
          <source>Optionally, it can merge a tree into the index, perform a fast-forward (i.e. 2-way) merge, or a 3-way merge, with the &lt;code&gt;-m&lt;/code&gt; flag. When used with &lt;code&gt;-m&lt;/code&gt;, the &lt;code&gt;-u&lt;/code&gt; flag causes it to also update the files in the work tree with the result of the merge.</source>
          <target state="translated">可选地，它可以将树合并到索引中，使用 &lt;code&gt;-m&lt;/code&gt; 标志执行快进（即2向）合并或3向合并。与 &lt;code&gt;-m&lt;/code&gt; 一起使用时， &lt;code&gt;-u&lt;/code&gt; 标志会使它也使用合并结果来更新工作树中的文件。</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="c844411e7897e1475e2bbc7e1cd47d6ca3b70b75" translate="yes" xml:space="preserve">
          <source>Options for --parseopt</source>
          <target state="translated">--parseopt的选项</target>
        </trans-unit>
        <trans-unit id="9c25d7f1531501faea711b1933ac2734dd8f1324" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="7eec6c07b2d8ff28d282e8d3918c0430dfd638ff" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;expire&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expire&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="e73b9df34672d383e318c543fe1ed5467baa2316" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;show&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;show&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="fcc02e852676cd8c1162b2b42e5759f86fcae990" translate="yes" xml:space="preserve">
          <source>Options for Files</source>
          <target state="translated">文件的选项</target>
        </trans-unit>
        <trans-unit id="fd6ce8b428a235dff74127968e45c8e950a3e68b" translate="yes" xml:space="preserve">
          <source>Options for Filtering</source>
          <target state="translated">筛选选项</target>
        </trans-unit>
        <trans-unit id="f0e43560a9524e814096613f5d3adbb780ab9547" translate="yes" xml:space="preserve">
          <source>Options for Frontends</source>
          <target state="translated">幌子的选择</target>
        </trans-unit>
        <trans-unit id="6de07b5e7d3355f1ee784587e4e9b9310ce89167" translate="yes" xml:space="preserve">
          <source>Options for Objects</source>
          <target state="translated">对象的选项</target>
        </trans-unit>
        <trans-unit id="7bba8ce1354b61b02f672f2468b0b0f0c600077c" translate="yes" xml:space="preserve">
          <source>Options for Output</source>
          <target state="translated">输出选项</target>
        </trans-unit>
        <trans-unit id="b8bceb2d83c081f4f5d71559b2d0f07edc9ee034" translate="yes" xml:space="preserve">
          <source>Options for a credential context can be configured either in &lt;code&gt;credential.*&lt;/code&gt; (which applies to all credentials), or &lt;code&gt;credential.&amp;lt;url&amp;gt;.*&lt;/code&gt;, where &amp;lt;url&amp;gt; matches the context as described above.</source>
          <target state="translated">凭证上下文的选项可以在 &lt;code&gt;credential.*&lt;/code&gt; （适用于所有凭证）或 &lt;code&gt;credential.&amp;lt;url&amp;gt;.*&lt;/code&gt; ，其中&amp;lt;url&amp;gt;如上所述与上下文匹配。</target>
        </trans-unit>
        <trans-unit id="99e5139a65bfab6cb84777a431cb5c7403976793" translate="yes" xml:space="preserve">
          <source>Options related to fetching</source>
          <target state="translated">与获取相关的选项</target>
        </trans-unit>
        <trans-unit id="d96532d12a36cc4bb8cc0dcd0b87def47cb21823" translate="yes" xml:space="preserve">
          <source>Options related to merging</source>
          <target state="translated">与合并有关的选项</target>
        </trans-unit>
        <trans-unit id="d2ce95980d5d4dcb8790725834688357cc504679" translate="yes" xml:space="preserve">
          <source>Options with long option names can be negated by prefixing &lt;code&gt;--no-&lt;/code&gt;. For example, &lt;code&gt;git branch&lt;/code&gt; has the option &lt;code&gt;--track&lt;/code&gt; which is &lt;code&gt;on&lt;/code&gt; by default. You can use &lt;code&gt;--no-track&lt;/code&gt; to override that behaviour. The same goes for &lt;code&gt;--color&lt;/code&gt; and &lt;code&gt;--no-color&lt;/code&gt;.</source>
          <target state="translated">带有长选项名称的选项可以通过前缀 &lt;code&gt;--no-&lt;/code&gt; 来否定。例如， &lt;code&gt;git branch&lt;/code&gt; 有选择 &lt;code&gt;--track&lt;/code&gt; 这是 &lt;code&gt;on&lt;/code&gt; 默认情况下。您可以使用 &lt;code&gt;--no-track&lt;/code&gt; 覆盖该行为。这同样适用于 &lt;code&gt;--color&lt;/code&gt; 和 &lt;code&gt;--no-color&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28e5f716aa8e690cf7323a0d5515626aac785807" translate="yes" xml:space="preserve">
          <source>Or if you are looking for the commit that fixed a bug, you might use</source>
          <target state="translated">或者,如果您正在寻找修复了错误的提交,您可以使用</target>
        </trans-unit>
        <trans-unit id="9bcee5b07c3eb51996fe06466cb572259d48e74e" translate="yes" xml:space="preserve">
          <source>Or if you want more control, you can inspect the current state using for example &quot;git bisect visualize&quot;. It will launch gitk (or &quot;git log&quot; if the &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is not set) to help you find a better bisection point.</source>
          <target state="translated">或者，如果您想要更多控制，则可以使用&amp;ldquo; git bisect visualize&amp;rdquo;等检查当前状态。它将启动gitk（如果未设置 &lt;code&gt;DISPLAY&lt;/code&gt; 环境变量，则将启动git log ）以帮助您找到更好的平分点。</target>
        </trans-unit>
        <trans-unit id="ee046ba1657a42f0c8096ff30555d679415a486a" translate="yes" xml:space="preserve">
          <source>Or you could recall that the &lt;code&gt;&amp;hellip;​&lt;/code&gt; operator selects all commits reachable from either one reference or the other but not both; so</source>
          <target state="translated">或者你可以回顾一下， &lt;code&gt;&amp;hellip;​&lt;/code&gt; 运营商都选择从提交任何一个参考值或其他但不能同时到达; 所以</target>
        </trans-unit>
        <trans-unit id="d85642c3d553b535f4731e23589126805881407c" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;ve already committed the merge that you want to throw away,</source>
          <target state="translated">或者，如果您已经提交了要丢弃的合并，</target>
        </trans-unit>
        <trans-unit id="7ec7c556c34b1673fc7046a255bf7eb40c6a1622" translate="yes" xml:space="preserve">
          <source>Or, prepare and create the commit in one step:</source>
          <target state="translated">或者,准备和创建提交一步到位。</target>
        </trans-unit>
        <trans-unit id="6d9770079506b18bb9154a95e976f54ab47a2b44" translate="yes" xml:space="preserve">
          <source>Ordinary changed entries have the following format:</source>
          <target state="translated">普通的变更条目有以下格式:</target>
        </trans-unit>
        <trans-unit id="789d55cf79d409acbcc0305ff19dbfa36d82a93d" translate="yes" xml:space="preserve">
          <source>Ordinary commits are only included if they are !TREESAME (though this can be changed, see &lt;code&gt;--sparse&lt;/code&gt; below).</source>
          <target state="translated">普通提交仅在它们为！TREESAME时才包括在内（尽管可以更改，请参见下面的 &lt;code&gt;--sparse&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3b945495727bab8a02c63542fdf26a485a2839f4" translate="yes" xml:space="preserve">
          <source>Original (version 1) pack-*.idx files have the following format:</source>
          <target state="translated">原始(第1版)pack-*.idx文件的格式如下:</target>
        </trans-unit>
        <trans-unit id="cd07568ac3f8fe8b9f1ca323e6aea33ce69f4d0c" translate="yes" xml:space="preserve">
          <source>Originally, &lt;code&gt;git svn&lt;/code&gt; recommended that developers pulled or merged from the &lt;code&gt;git svn&lt;/code&gt; branch. This was because the author favored &lt;code&gt;git svn set-tree B&lt;/code&gt; to commit a single head rather than the &lt;code&gt;git svn set-tree A..B&lt;/code&gt; notation to commit multiple commits. Use of &lt;code&gt;git pull&lt;/code&gt; or &lt;code&gt;git merge&lt;/code&gt; with &lt;code&gt;git svn set-tree A..B&lt;/code&gt; will cause non-linear history to be flattened when committing into SVN and this can lead to merge commits unexpectedly reversing previous commits in SVN.</source>
          <target state="translated">最初， &lt;code&gt;git svn&lt;/code&gt; 建议开发人员从 &lt;code&gt;git svn&lt;/code&gt; 分支中拉出或合并。这是因为作者更喜欢 &lt;code&gt;git svn set-tree B&lt;/code&gt; 提交一个单独的头部，而不是 &lt;code&gt;git svn set-tree A..B&lt;/code&gt; 表示法来提交多个提交。与 &lt;code&gt;git svn set-tree A..B&lt;/code&gt; 一起使用 &lt;code&gt;git pull&lt;/code&gt; 或 &lt;code&gt;git merge&lt;/code&gt; 会导致非线性历史在提交到SVN中时变平，这可能导致合并提交意外地反转了SVN中的先前提交。</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="14bc34cb5d8d9f5a1986c4b4ced74a089ed31e83" translate="yes" xml:space="preserve">
          <source>Other &amp;lt;rev&amp;gt;^ Parent Shorthand Notations</source>
          <target state="translated">其他&amp;lt;rev&amp;gt; ^家长简写</target>
        </trans-unit>
        <trans-unit id="a3c040aeed88ddd482d5dec178bd5bb0b940738f" translate="yes" xml:space="preserve">
          <source>Other Items</source>
          <target state="translated">其他项目</target>
        </trans-unit>
        <trans-unit id="9cb6f2fb01dfa81e12bc1e11f0e7b676e54669fd" translate="yes" xml:space="preserve">
          <source>Other Options</source>
          <target state="translated">其他选择</target>
        </trans-unit>
        <trans-unit id="b66b145fc26fc91268f852efc133debcedca1335" translate="yes" xml:space="preserve">
          <source>Other ambiguity resolutions might be added in the future, but for now any other cases will error out with an error indicating what we tried, and depending on the &lt;code&gt;advice.pushUnqualifiedRefname&lt;/code&gt; configuration (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) suggest what refs/ namespace you may have wanted to push to.</source>
          <target state="translated">将来可能会添加其他歧义解决方案，但就目前而言，任何其他情况都会出错，并显示一个错误，指出我们尝试了什么，并根据 &lt;code&gt;advice.pushUnqualifiedRefname&lt;/code&gt; 配置（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）建议使用哪种refs /名称空间可能想推动。</target>
        </trans-unit>
        <trans-unit id="0d7c9916d5a97cfdd8b058afc3d1bac1c0a81b1f" translate="yes" xml:space="preserve">
          <source>Other arbitrary characters can also be encoded. For instance, &lt;code&gt;combine:tree:3+blob:none&lt;/code&gt; and &lt;code&gt;combine:tree%3A3+blob%3Anone&lt;/code&gt; are equivalent.</source>
          <target state="translated">其他任意字符也可以被编码。例如， &lt;code&gt;combine:tree%3A3+blob%3Anone&lt;/code&gt; &lt;code&gt;combine:tree:3+blob:none&lt;/code&gt; 和Combine：tree％3A3 + blob％3Anone是等效的。</target>
        </trans-unit>
        <trans-unit id="fca088ce123c6c3692799642c2a4b46b5050ca1e" translate="yes" xml:space="preserve">
          <source>Other consecutive asterisks are considered invalid.</source>
          <target state="translated">其他连续的星号视为无效。</target>
        </trans-unit>
        <trans-unit id="060f4f2bc2ee9b99f69af6360a0055db64443a39" translate="yes" xml:space="preserve">
          <source>Other consecutive asterisks are considered regular asterisks and will match according to the previous rules.</source>
          <target state="translated">其他连续的星号均视为常规星号,按照前面的规则进行匹配。</target>
        </trans-unit>
        <trans-unit id="3c7b99f717eee9f16429ca9a79551f060c8f8236" translate="yes" xml:space="preserve">
          <source>Other diff formats</source>
          <target state="translated">其他差异格式</target>
        </trans-unit>
        <trans-unit id="81458045196e38ce4846b13cecf95d14abe58433" translate="yes" xml:space="preserve">
          <source>Other git-related tools may and do use their own variables. When inventing new variables for use in your own tool, make sure their names do not conflict with those that are used by Git itself and other popular tools, and describe them in your documentation.</source>
          <target state="translated">其他与 git 相关的工具可能也会使用自己的变量。当你在自己的工具中发明新的变量时,请确保它们的名字不与 Git 本身和其他流行工具的名字冲突,并在文档中描述它们。</target>
        </trans-unit>
        <trans-unit id="97855915001e4fe7ef5deb1c023c4697931e633c" translate="yes" xml:space="preserve">
          <source>Other options are available to control how the manual page is displayed. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; for more information, because &lt;code&gt;git --help ...&lt;/code&gt; is converted internally into &lt;code&gt;git
help ...&lt;/code&gt;.</source>
          <target state="translated">其他选项可用于控制手册页的显示方式。见&lt;a href=&quot;git-help&quot;&gt;混帐的帮助[1]&lt;/a&gt;以获取更多信息，因为 &lt;code&gt;git --help ...&lt;/code&gt; 在内部转换成 &lt;code&gt;git help ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9c8373137a028157f66c53c01b431d29c570146" translate="yes" xml:space="preserve">
          <source>Other tools</source>
          <target state="translated">其他工具</target>
        </trans-unit>
        <trans-unit id="89cbbb5c1b80969d7050a561dcd36c87c0241792" translate="yes" xml:space="preserve">
          <source>Other tools to fight regressions</source>
          <target state="translated">其他对抗倒退的工具</target>
        </trans-unit>
        <trans-unit id="15219db000aadb43433107a930098d54a12a2bf5" translate="yes" xml:space="preserve">
          <source>Other types of dangling objects (blobs and trees) are also possible, and dangling objects can arise in other situations.</source>
          <target state="translated">其他类型的悬空物体(blobs和树)也是可能的,悬空物体也会在其他情况下出现。</target>
        </trans-unit>
        <trans-unit id="a8ad1c87f168347a129392343ff35eecf4e32d0a" translate="yes" xml:space="preserve">
          <source>Other variables</source>
          <target state="translated">其他变量</target>
        </trans-unit>
        <trans-unit id="dd705eff4c453915d022538452adca45ea549424" translate="yes" xml:space="preserve">
          <source>Other ways</source>
          <target state="translated">其他方式</target>
        </trans-unit>
        <trans-unit id="cf96d288cbee7ebb53d0ff80a9f63e5beaf8b0b4" translate="yes" xml:space="preserve">
          <source>Otherwise the remote branch of the first refspec is merged.</source>
          <target state="translated">否则将合并第一个refspec的远程分支。</target>
        </trans-unit>
        <trans-unit id="32a9647b920b895ad400011726c72473bb775600" translate="yes" xml:space="preserve">
          <source>Otherwise, a tag reference that points directly at the given object (i.e., a lightweight tag) is created.</source>
          <target state="translated">否则,将创建一个直接指向给定对象的标签引用(即轻量级标签)。</target>
        </trans-unit>
        <trans-unit id="4b4eb603a71c26301f006805965a2bb224fe1a8d" translate="yes" xml:space="preserve">
          <source>Otherwise, all you need to do is start &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt;; it will listen on port 9418. By default, it will allow access to any directory that looks like a Git directory and contains the magic file git-daemon-export-ok. Passing some directory paths as &lt;code&gt;git daemon&lt;/code&gt; arguments will further restrict the exports to those paths.</source>
          <target state="translated">否则，您只需要启动&lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]即可&lt;/a&gt;；它将侦听端口9418。默认情况下，它将允许访问任何看起来像Git目录且包含魔术文件git-daemon-export-ok的目录。将某些目录路径作为 &lt;code&gt;git daemon&lt;/code&gt; 参数传递将进一步限制导出到这些路径。</target>
        </trans-unit>
        <trans-unit id="83933e66c19657c277855328b7212d55be330b69" translate="yes" xml:space="preserve">
          <source>Otherwise, if the &lt;code&gt;SSH_ASKPASS&lt;/code&gt; environment variable is set, its value is used as above.</source>
          <target state="translated">否则，如果设置了 &lt;code&gt;SSH_ASKPASS&lt;/code&gt; 环境变量，则其值将如上使用。</target>
        </trans-unit>
        <trans-unit id="06aca3f538987dd4baec5bd30c2c8ddce8b7736e" translate="yes" xml:space="preserve">
          <source>Otherwise, if the &lt;code&gt;core.askPass&lt;/code&gt; configuration variable is set, its value is used as above.</source>
          <target state="translated">否则，如果设置了 &lt;code&gt;core.askPass&lt;/code&gt; 配置变量，则其值将如上使用。</target>
        </trans-unit>
        <trans-unit id="4215362e197715214628992e14b639b7a98dbd7a" translate="yes" xml:space="preserve">
          <source>Otherwise, show the index format.</source>
          <target state="translated">否则,显示索引格式。</target>
        </trans-unit>
        <trans-unit id="1bddd3a0b4a752779f115c3518d3c2b277475b51" translate="yes" xml:space="preserve">
          <source>Otherwise, success is indicated the Unix way, i.e. by simply exiting with a zero exit status.</source>
          <target state="translated">否则,就会以Unix方式表示成功,即以零退出状态退出。</target>
        </trans-unit>
        <trans-unit id="adf9fb3bc458cf17571d90a6a9fffeaa1b715a6a" translate="yes" xml:space="preserve">
          <source>Otherwise, the merge proceeds in the usual way.</source>
          <target state="translated">否则,合并按常规方式进行。</target>
        </trans-unit>
        <trans-unit id="0d438a86f2545e54eff98d96612fdf5bccb833ed" translate="yes" xml:space="preserve">
          <source>Otherwise, the topic that was merged to suddenly contains more than a single (well-separated) change. The many resulting small merges will greatly clutter up history. Anyone who later investigates the history of a file will have to find out whether that merge affected the topic in development. An upstream might even inadvertently be merged into a &quot;more stable&quot; branch. And so on.</source>
          <target state="translated">否则,被合并到的主题突然包含了不止一个(分得很清楚)的变化。由此产生的许多小的合并将极大地混乱历史。任何后来调查一个文件历史的人,都必须找出那个合并是否影响了正在开发中的主题。一个上游甚至可能无意中被合并到一个 &quot;更稳定 &quot;的分支中。以此类推。</target>
        </trans-unit>
        <trans-unit id="9aea25a9a0905a830a51359c1723b329df787dff" translate="yes" xml:space="preserve">
          <source>Otherwise, the user is prompted on the terminal.</source>
          <target state="translated">否则,终端上会提示用户。</target>
        </trans-unit>
        <trans-unit id="38c6fc8779b3b84c1e5bc6184edd3674dd536e89" translate="yes" xml:space="preserve">
          <source>Otherwise, this command applies the arguments passed using the &lt;code&gt;--trailer&lt;/code&gt; option, if any, to the commit message part of each input file. The result is emitted on the standard output.</source>
          <target state="translated">否则，此命令 &lt;code&gt;--trailer&lt;/code&gt; 使用--trailer选项传递的参数（如果有）应用于每个输入文件的提交消息部分。结果在标准输出上发出。</target>
        </trans-unit>
        <trans-unit id="7befa93bf7555efa6c53836dd2ebb58604474c19" translate="yes" xml:space="preserve">
          <source>Otherwise, you need more information. How do you tell which version of the file has been lost?</source>
          <target state="translated">否则,你需要更多的信息。如何判断文件的哪个版本已经丢失?</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="bfba9983f4010a4e13ddf1f4da6c4d9462a74630" translate="yes" xml:space="preserve">
          <source>Output &quot;connectivity-ok&quot; if the received pack is self-contained and connected.</source>
          <target state="translated">如果接收到的数据包是自给自足并连接的,则输出 &quot;connectivity-ok&quot;。</target>
        </trans-unit>
        <trans-unit id="14d787baf83270b720015688dc1b0d825f139765" translate="yes" xml:space="preserve">
          <source>Output \0 instead of the character that normally follows a file name.</source>
          <target state="translated">输出/0代替通常文件名后的字符。</target>
        </trans-unit>
        <trans-unit id="02b83bf95635a4c88bd0634054e0b05541ae55d4" translate="yes" xml:space="preserve">
          <source>Output a condensed summary of extended header information such as creations, renames and mode changes.</source>
          <target state="translated">输出扩展头信息的精简摘要,如创建、重命名和模式变化。</target>
        </trans-unit>
        <trans-unit id="6dbea2796f7c2da05dc872fbc20cb3b286f106fd" translate="yes" xml:space="preserve">
          <source>Output a condensed summary of extended header information such as file creations or deletions (&quot;new&quot; or &quot;gone&quot;, optionally &quot;+l&quot; if it&amp;rsquo;s a symlink) and mode changes (&quot;+x&quot; or &quot;-x&quot; for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies &lt;code&gt;--stat&lt;/code&gt;.</source>
          <target state="translated">输出扩展头信息的简明摘要，例如文件创建或删除（&amp;ldquo;新&amp;rdquo;或&amp;ldquo;去&amp;rdquo;，如果是符号链接，则可选地为&amp;ldquo; + l&amp;rdquo;）和模式更改（&amp;ldquo; + x&amp;rdquo;或&amp;ldquo; -x&amp;rdquo;用于添加或删除）分别在diffstat中执行）。信息放在文件名部分和图形部分之间。暗示 &lt;code&gt;--stat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86b8e4f6e5044ecf1fc221aacfd89b826aa45a4b" translate="yes" xml:space="preserve">
          <source>Output all merge bases for the commits, instead of just one.</source>
          <target state="translated">输出所有提交的合并基础,而不是只输出一个。</target>
        </trans-unit>
        <trans-unit id="c4fd496863f1ea4adcfb9e1e5209189d8bcbae5b" translate="yes" xml:space="preserve">
          <source>Output an all-zero hash in each patch&amp;rsquo;s From header instead of the hash of the commit.</source>
          <target state="translated">在每个补丁的From头中输出全零哈希值，而不是提交的哈希值。</target>
        </trans-unit>
        <trans-unit id="646a42919af7ad3c76023f798af12df793449561" translate="yes" xml:space="preserve">
          <source>Output diff in reverse.</source>
          <target state="translated">输出差反。</target>
        </trans-unit>
        <trans-unit id="973b33dc2cc053fd8a3739d3b278f90232b34e64" translate="yes" xml:space="preserve">
          <source>Output excluded boundary commits. Boundary commits are prefixed with &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">输出排除的边界提交。边界提交的前缀为 &lt;code&gt;-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3872ebaf63738dccf26222059fb06a34ea9a53d" translate="yes" xml:space="preserve">
          <source>Output file names will be a simple number sequence without the default first line of the commit appended.</source>
          <target state="translated">输出文件名将是一个简单的数字序列,不附加默认的第一行提交。</target>
        </trans-unit>
        <trans-unit id="c03f08a8f205e4568e916e3cfaa50c6a48749706" translate="yes" xml:space="preserve">
          <source>Output format</source>
          <target state="translated">输出格式</target>
        </trans-unit>
        <trans-unit id="d018168db6adc860beb206930bf9272bcf4432cb" translate="yes" xml:space="preserve">
          <source>Output from &lt;code&gt;git describe&lt;/code&gt;; i.e. a closest tag, optionally followed by a dash and a number of commits, followed by a dash, a &lt;code&gt;g&lt;/code&gt;, and an abbreviated object name.</source>
          <target state="translated">&lt;code&gt;git describe&lt;/code&gt; 的输出；即最接近的标记，可以选择后面跟一个破折号和多个提交，然后跟一个破折号， &lt;code&gt;g&lt;/code&gt; 和一个缩写的对象名。</target>
        </trans-unit>
        <trans-unit id="57be6fd315ed7958a6a11b416634cb9af54c1202" translate="yes" xml:space="preserve">
          <source>Output information on each ref</source>
          <target state="translated">输出每个裁判的信息</target>
        </trans-unit>
        <trans-unit id="a471d58e2fcbf4f373e5dd800df97d7ecddc4b2a" translate="yes" xml:space="preserve">
          <source>Output only the last line of the &lt;code&gt;--stat&lt;/code&gt; format containing total number of modified files, as well as number of added and deleted lines.</source>
          <target state="translated">仅输出 &lt;code&gt;--stat&lt;/code&gt; 格式的最后一行，其中包含已修改文件的总数以及添加和删除的行数。</target>
        </trans-unit>
        <trans-unit id="09afa8b7712ce7db5d67e850045b13df59d4e1ae" translate="yes" xml:space="preserve">
          <source>Output only the names of config variables for &lt;code&gt;--list&lt;/code&gt; or &lt;code&gt;--get-regexp&lt;/code&gt;.</source>
          <target state="translated">仅输出 &lt;code&gt;--list&lt;/code&gt; 或 &lt;code&gt;--get-regexp&lt;/code&gt; 的配置变量的名称。</target>
        </trans-unit>
        <trans-unit id="86aa1f4dbf3c69df52c4dcdcb3513ddaac888349" translate="yes" xml:space="preserve">
          <source>Output only the trailers, not any other parts of the input.</source>
          <target state="translated">只输出拖车,不输出输入的任何其他部分。</target>
        </trans-unit>
        <trans-unit id="db37f07e7f23e51cc792b3b6ff625f7fbb6a099c" translate="yes" xml:space="preserve">
          <source>Output only trailers that exist in the input; do not add any from the command-line or by following configured &lt;code&gt;trailer.*&lt;/code&gt; rules.</source>
          <target state="translated">仅输出输入中存在的预告片；请勿从命令行或遵循已配置的 &lt;code&gt;trailer.*&lt;/code&gt; 规则添加任何内容。</target>
        </trans-unit>
        <trans-unit id="9f94a54620a30e7ce03e12a657369e604dddd0ea" translate="yes" xml:space="preserve">
          <source>Output stability</source>
          <target state="translated">输出稳定性</target>
        </trans-unit>
        <trans-unit id="eec068e91917644b4f85137aa6730536687188c8" translate="yes" xml:space="preserve">
          <source>Output the commits chosen to be shown (see Commit Limiting section above) in reverse order. Cannot be combined with &lt;code&gt;--walk-reflogs&lt;/code&gt;.</source>
          <target state="translated">以相反的顺序输出选择显示的提交（请参见上面的&amp;ldquo;提交限制&amp;rdquo;部分）。不能与 &lt;code&gt;--walk-reflogs&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="b5f16fa854dad4b03b2649c62b3407ce506ca41f" translate="yes" xml:space="preserve">
          <source>Output the distribution of relative amount of changes for each sub-directory. The behavior of &lt;code&gt;--dirstat&lt;/code&gt; can be customized by passing it a comma separated list of parameters. The defaults are controlled by the &lt;code&gt;diff.dirstat&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). The following parameters are available:</source>
          <target state="translated">输出每个子目录的相对变化量的分布。可以通过将 &lt;code&gt;--dirstat&lt;/code&gt; 的行为传递给逗号分隔的参数列表来进行自定义。默认值由 &lt;code&gt;diff.dirstat&lt;/code&gt; 配置变量控制（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。可以使用以下参数：</target>
        </trans-unit>
        <trans-unit id="f44ba9d91e7de35dadf965ce7b9f83b740777703" translate="yes" xml:space="preserve">
          <source>Output to a specific file instead of stdout.</source>
          <target state="translated">输出到一个特定的文件,而不是stdout。</target>
        </trans-unit>
        <trans-unit id="1374322e99ee5a882a272ee284ec9ea86e209683" translate="yes" xml:space="preserve">
          <source>Output uses the same format as &lt;code&gt;git cat-file --batch&lt;/code&gt;:</source>
          <target state="translated">输出使用与 &lt;code&gt;git cat-file --batch&lt;/code&gt; 相同的格式：</target>
        </trans-unit>
        <trans-unit id="50880c18d623e2367f83a87791b3da910b72fa81" translate="yes" xml:space="preserve">
          <source>Output uses the same format as &lt;code&gt;git ls-tree &amp;lt;tree&amp;gt; -- &amp;lt;path&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">输出使用与 &lt;code&gt;git ls-tree &amp;lt;tree&amp;gt; -- &amp;lt;path&amp;gt;&lt;/code&gt; 相同的格式：</target>
        </trans-unit>
        <trans-unit id="12aec147318e848c7d54969418eb1ab7603e65c0" translate="yes" xml:space="preserve">
          <source>Outputs some statistics to stderr. Has a small performance penalty.</source>
          <target state="translated">向stderr输出一些统计数据。有一个小的性能惩罚。</target>
        </trans-unit>
        <trans-unit id="bb044abda9deb6fdc3e0634ed0f85ce258bcc5dc" translate="yes" xml:space="preserve">
          <source>Outputs the SHA1 of every commit in &lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt;, prefixed with &lt;code&gt;-&lt;/code&gt; for commits that have an equivalent in &amp;lt;upstream&amp;gt;, and &lt;code&gt;+&lt;/code&gt; for commits that do not.</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt; 中输出每个提交的SHA1 ，以 &lt;code&gt;-&lt;/code&gt; 表示在&amp;lt;upstream&amp;gt;中具有等效值的提交，以 &lt;code&gt;+&lt;/code&gt; 表示在不具有它们的提交时的前缀。</target>
        </trans-unit>
        <trans-unit id="27115802f1c296a1dfb4ce768084e3e086e70c8c" translate="yes" xml:space="preserve">
          <source>Override &lt;code&gt;tag.gpgSign&lt;/code&gt; configuration variable that is set to force each and every tag to be signed.</source>
          <target state="translated">覆盖 &lt;code&gt;tag.gpgSign&lt;/code&gt; 配置变量，该变量设置为强制对每个标签进行签名。</target>
        </trans-unit>
        <trans-unit id="f98c38feba04de33a87daf02cddb4bc0af45f925" translate="yes" xml:space="preserve">
          <source>Override earlier --rebase.</source>
          <target state="translated">覆盖早先的--rebase。</target>
        </trans-unit>
        <trans-unit id="bf7cdfd38925dba890e8c6c44d76b710ca912a26" translate="yes" xml:space="preserve">
          <source>Override the HTTP proxy, normally configured using the &lt;code&gt;http_proxy&lt;/code&gt;, &lt;code&gt;https_proxy&lt;/code&gt;, and &lt;code&gt;all_proxy&lt;/code&gt; environment variables (see &lt;code&gt;curl(1)&lt;/code&gt;). In addition to the syntax understood by curl, it is possible to specify a proxy string with a user name but no password, in which case git will attempt to acquire one in the same way it does for other credentials. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information. The syntax thus is &lt;code&gt;[protocol://][user[:password]@]proxyhost[:port]&lt;/code&gt;. This can be overridden on a per-remote basis; see remote.&amp;lt;name&amp;gt;.proxy</source>
          <target state="translated">覆盖通常使用 &lt;code&gt;http_proxy&lt;/code&gt; ， &lt;code&gt;https_proxy&lt;/code&gt; 和 &lt;code&gt;all_proxy&lt;/code&gt; 环境变量配置的HTTP代理（请参见 &lt;code&gt;curl(1)&lt;/code&gt; ）。除了curl可以理解的语法外，还可以使用用户名而不是密码来指定代理字符串，在这种情况下git将尝试以与其他凭据相同的方式获取一个。有关更多信息，请参见&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt;。因此，语法为 &lt;code&gt;[protocol://][user[:password]@]proxyhost[:port]&lt;/code&gt; 。可以逐个远程覆盖它；参见remote。&amp;lt;名称&amp;gt; .proxy</target>
        </trans-unit>
        <trans-unit id="ca2a7d0ade908f47d0a242141742817435033d82" translate="yes" xml:space="preserve">
          <source>Override the author date used in the commit.</source>
          <target state="translated">覆盖提交中使用的作者日期。</target>
        </trans-unit>
        <trans-unit id="afbb46ef37a88110fa3c814b4440b9bab3c588ca" translate="yes" xml:space="preserve">
          <source>Override the commit author. Specify an explicit author using the standard &lt;code&gt;A U Thor &amp;lt;author@example.com&amp;gt;&lt;/code&gt; format. Otherwise &amp;lt;author&amp;gt; is assumed to be a pattern and is used to search for an existing commit by that author (i.e. rev-list --all -i --author=&amp;lt;author&amp;gt;); the commit author is then copied from the first such commit found.</source>
          <target state="translated">覆盖提交作者。使用标准 &lt;code&gt;A U Thor &amp;lt;author@example.com&amp;gt;&lt;/code&gt; 格式指定明确的作者。否则，假定&amp;lt;author&amp;gt;是一种模式，并用于搜索该作者的现有提交（即rev-list --all -i --author = &amp;lt;author&amp;gt;）；然后从找到的第一个此类提交中复制提交作者。</target>
        </trans-unit>
        <trans-unit id="e3aa6564c96bc2c1fa2d64bc52314ce125c2e1b2" translate="yes" xml:space="preserve">
          <source>Override the default help format used by &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;. Values &lt;code&gt;man&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;html&lt;/code&gt; are supported. &lt;code&gt;man&lt;/code&gt; is the default. &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;html&lt;/code&gt; are the same.</source>
          <target state="translated">覆盖&lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt;使用的默认帮助格式。支持值 &lt;code&gt;man&lt;/code&gt; ， &lt;code&gt;info&lt;/code&gt; ， &lt;code&gt;web&lt;/code&gt; 和 &lt;code&gt;html&lt;/code&gt; 。 &lt;code&gt;man&lt;/code&gt; 是默认设置。 &lt;code&gt;web&lt;/code&gt; 和 &lt;code&gt;html&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="90af133b98db5fc195076e23392ec3cd67c3e89c" translate="yes" xml:space="preserve">
          <source>Override the default tempdir.</source>
          <target state="translated">覆盖默认的tempdir。</target>
        </trans-unit>
        <trans-unit id="5b51681506c224a8c47f1343a9ecd64433151e38" translate="yes" xml:space="preserve">
          <source>Override the executable bit of the added files. The executable bit is only changed in the index, the files on disk are left unchanged.</source>
          <target state="translated">覆盖新增文件的可执行位。可执行位只在索引中改变,磁盘上的文件保持不变。</target>
        </trans-unit>
        <trans-unit id="2478241e90c06d40d8344e2c734cc9e34ffd0d73" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool that may be used to browse HTML help (see &lt;code&gt;-w&lt;/code&gt; option in &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;) or a working repository in gitweb (see &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;).</source>
          <target state="translated">覆盖给定工具的路径，该工具可用于浏览HTML帮助（请参阅&lt;a href=&quot;git-help&quot;&gt;git-help [1]中的&lt;/a&gt; &lt;code&gt;-w&lt;/code&gt; 选项）或gitweb中的可用存储库（请参阅&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="eeb1b59c781a411c8a2ade9041a0a224d6888a83" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool that may be used to display help in the &lt;code&gt;man&lt;/code&gt; format. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;.</source>
          <target state="translated">覆盖给定工具的路径，该路径可用于以 &lt;code&gt;man&lt;/code&gt; 格式显示帮助。参见&lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="adf75a51b2ad5d1ae80303fa7c85676af23cae71" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool. This is useful in case your tool is not in the PATH.</source>
          <target state="translated">覆盖给定工具的路径。这在你的工具不在PATH中时很有用。</target>
        </trans-unit>
        <trans-unit id="d7b3947bcc6a75423b4dad1a16da833c821be77f" translate="yes" xml:space="preserve">
          <source>Override the up-to-date check.</source>
          <target state="translated">覆盖最新的检查。</target>
        </trans-unit>
        <trans-unit id="4f22a960f4dfa712696d5fbbb0afb1a8a1360ea3" translate="yes" xml:space="preserve">
          <source>Overrides a previous &lt;code&gt;--no-walk&lt;/code&gt;.</source>
          <target state="translated">覆盖先前的 &lt;code&gt;--no-walk&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcd0bd07179d4dab7adf6735a6d8e2d1ef6bb9e3" translate="yes" xml:space="preserve">
          <source>Overwrite the contents of the files that match the pathspec. When the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (most often a commit) is not given, overwrite working tree with the contents in the index. When the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; is given, overwrite both the index and the working tree with the contents at the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">覆盖与pathspec匹配的文件的内容。如果未给出 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; （通常是一次提交），请使用索引中的内容覆盖工作树。当 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 给出，覆盖这两个索引和与内容在工作树 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdd66a641be22e4e3d7b30653f72f1e5443e834b" translate="yes" xml:space="preserve">
          <source>P4 does not have the same concept of a branch as Git. Instead, p4 organizes its content as a directory tree, where by convention different logical branches are in different locations in the tree. The &lt;code&gt;p4 branch&lt;/code&gt; command is used to maintain mappings between different areas in the tree, and indicate related content. &lt;code&gt;git p4&lt;/code&gt; can use these mappings to determine branch relationships.</source>
          <target state="translated">P4的分支概念与Git不同。相反，p4将其内容组织为目录树，按照惯例，目录树中的不同逻辑分支位于其中。在 &lt;code&gt;p4 branch&lt;/code&gt; 命令是用来维护不同领域之间的映射在树上，并注明相关内容。 &lt;code&gt;git p4&lt;/code&gt; 可以使用这些映射来确定分支关系。</target>
        </trans-unit>
        <trans-unit id="c377e9687b993a1d0b2786f798f75e99668d5825" translate="yes" xml:space="preserve">
          <source>P4 repositories can be added to an existing Git repository using &lt;code&gt;git p4 sync&lt;/code&gt; too:</source>
          <target state="translated">也可以使用 &lt;code&gt;git p4 sync&lt;/code&gt; 将P4存储库添加到现有的Git存储库中：</target>
        </trans-unit>
        <trans-unit id="899e81641132daf9598824927775cf00c10d02f7" translate="yes" xml:space="preserve">
          <source>PATH_INFO (if GIT_PROJECT_ROOT is set, otherwise PATH_TRANSLATED)</source>
          <target state="translated">PATH_INFO (如果GIT_PROJECT_ROOT被设置,否则为PATH_TRANSLATED)</target>
        </trans-unit>
        <trans-unit id="6decffd0412eaf2f154545c6af90e7d695d8d0f2" translate="yes" xml:space="preserve">
          <source>PATH_INFO usage</source>
          <target state="translated">PATH_INFO用法</target>
        </trans-unit>
        <trans-unit id="4a9500dfda14165da62b0d759d4f7a0a1828ddac" translate="yes" xml:space="preserve">
          <source>PERF Format</source>
          <target state="translated">PERF格式</target>
        </trans-unit>
        <trans-unit id="ac3820bb690c0e4f8afb899d021a87e2215d9f6c" translate="yes" xml:space="preserve">
          <source>Pack Idx file:</source>
          <target state="translated">包装Idx文件。</target>
        </trans-unit>
        <trans-unit id="8e5bd2c516c0b64c7a093133ad05311d5aa715dd" translate="yes" xml:space="preserve">
          <source>Pack heads and tags for efficient repository access</source>
          <target state="translated">包装头和标签以实现高效的存储库访问。</target>
        </trans-unit>
        <trans-unit id="916c15851c2e9c9482b6f7ae827a2ef3628cc3b5" translate="yes" xml:space="preserve">
          <source>Pack unpacked objects in a repository</source>
          <target state="translated">将未打包的对象打包到存储库中。</target>
        </trans-unit>
        <trans-unit id="fd708a7f9f7d413af09614d69248d6ad385118ff" translate="yes" xml:space="preserve">
          <source>Pack unreachable loose objects (and their loose counterparts removed). This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">装上无法触及的松散物品（并清除松散的对应物品）。这意味着 &lt;code&gt;--revs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eee993c07c74282866f868d204d9cb338384817b" translate="yes" xml:space="preserve">
          <source>Pack-*.pack files have the following format:</source>
          <target state="translated">Pack-*.pack文件的格式如下:</target>
        </trans-unit>
        <trans-unit id="f066589e1e591fe2ae534900eb4066417a728dbe" translate="yes" xml:space="preserve">
          <source>Packet-line framing</source>
          <target state="translated">包线框架</target>
        </trans-unit>
        <trans-unit id="df55d31d287518a9be7d4b1795862cdf2fc41470" translate="yes" xml:space="preserve">
          <source>Packfile optimization</source>
          <target state="translated">包装文件优化</target>
        </trans-unit>
        <trans-unit id="64fd302d4a38d46210fcac733698d9d782d1ce2e" translate="yes" xml:space="preserve">
          <source>Packfiles can be marked as &quot;special&quot; using empty files that share the initial name but replace &quot;.pack&quot; with &quot;.keep&quot; or &quot;.promisor&quot;. We can add an optional chunk of data to the multi-pack-index that records flags of information about the packfiles. This allows new states, such as &lt;code&gt;repacked&lt;/code&gt; or &lt;code&gt;redeltified&lt;/code&gt;, that can help with pack maintenance in a multi-pack environment. It may also be helpful to organize packfiles by object type (commit, tree, blob, etc.) and use this metadata to help that maintenance.</source>
          <target state="translated">可以使用共享初始名称但将&amp;ldquo; .pack&amp;rdquo;替换为&amp;ldquo; .keep&amp;rdquo;或&amp;ldquo; .promisor&amp;rdquo;的空文件将Packfiles标记为&amp;ldquo;特殊&amp;rdquo;。我们可以向multi-pack-index添加可选的数据块，该数据记录有关packfile的信息标志。这使得新的状态，如 &lt;code&gt;repacked&lt;/code&gt; 或 &lt;code&gt;redeltified&lt;/code&gt; ，在多组环境包维护，可以帮助。按对象类型（提交，树，blob等）组织打包文件并使用此元数据来帮助进行维护也可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="31a1b2f09e14954b347560b78870b7472ffa3669" translate="yes" xml:space="preserve">
          <source>Packing objects</source>
          <target state="translated">包装对象</target>
        </trans-unit>
        <trans-unit id="128ae9baa6dfe921179664d6c2722a23816ef24b" translate="yes" xml:space="preserve">
          <source>Packing your repository</source>
          <target state="translated">包装您的存储库</target>
        </trans-unit>
        <trans-unit id="1b3cc3c53ffc64e43edbae102e2fbe605f6c35c2" translate="yes" xml:space="preserve">
          <source>Packs (files that store many objects in compressed form, along with index files to allow them to be randomly accessed) are found in this directory.</source>
          <target state="translated">Packs(以压缩形式存储许多对象的文件,以及允许随机访问的索引文件)在这个目录中找到。</target>
        </trans-unit>
        <trans-unit id="5e77e9eb9a9ac23524177c29c90fcfbb2bbc9d8d" translate="yes" xml:space="preserve">
          <source>Packs are used to reduce the load on mirror systems, backup engines, disk storage, etc.</source>
          <target state="translated">包用于减少镜像系统、备份引擎、磁盘存储等的负载。</target>
        </trans-unit>
        <trans-unit id="62f32a40a6ada609c72de752933f4d26ac1e6bb8" translate="yes" xml:space="preserve">
          <source>Parallel operation</source>
          <target state="translated">并行操作</target>
        </trans-unit>
        <trans-unit id="669184806db1339e6c6beee1ab38494c4529dab6" translate="yes" xml:space="preserve">
          <source>Parent/child relations are only visible with &lt;code&gt;--parents&lt;/code&gt;, but that does not affect the commits selected in default mode, so we have shown the parent lines.</source>
          <target state="translated">父/子关系仅通过 &lt;code&gt;--parents&lt;/code&gt; 可见，但这不会影响默认模式下选择的提交，因此我们显示了父行。</target>
        </trans-unit>
        <trans-unit id="2efa637ebfd57586deb686233e5bd089abfab182" translate="yes" xml:space="preserve">
          <source>Parse the date string, and output the corresponding --max-age= parameter for &lt;code&gt;git rev-list&lt;/code&gt;.</source>
          <target state="translated">解析日期字符串，并为 &lt;code&gt;git rev-list&lt;/code&gt; 输出相应的--max-age =参数。</target>
        </trans-unit>
        <trans-unit id="26f771d12548577279103a59da15ea4fd6835ad3" translate="yes" xml:space="preserve">
          <source>Parse the date string, and output the corresponding --min-age= parameter for &lt;code&gt;git rev-list&lt;/code&gt;.</source>
          <target state="translated">解析日期字符串，并为 &lt;code&gt;git rev-list&lt;/code&gt; 输出相应的--min-age =参数。</target>
        </trans-unit>
        <trans-unit id="868df803566ac09bf6f4d16dac1cc6f9e22a2eb9" translate="yes" xml:space="preserve">
          <source>Parseopt</source>
          <target state="translated">Parseopt</target>
        </trans-unit>
        <trans-unit id="2f58caf00da93e9d39ff1263d9c88686c41f1f30" translate="yes" xml:space="preserve">
          <source>Part two of this tutorial explains the object database, the index file, and a few other odds and ends that you&amp;rsquo;ll need to make the most of Git. You can find it at &lt;a href=&quot;gittutorial-2&quot;&gt;gittutorial-2[7]&lt;/a&gt;.</source>
          <target state="translated">本教程的第二部分介绍了对象数据库，索引文件以及充分利用Git所需的其他一些零碎东西。您可以在&lt;a href=&quot;gittutorial-2&quot;&gt;gittutorial-2 [7]上&lt;/a&gt;找到它。</target>
        </trans-unit>
        <trans-unit id="8fc0213ea3567cb4b4477ecb78349de8a29f1b86" translate="yes" xml:space="preserve">
          <source>Partly for this reason, many experienced Git users, even when working on an otherwise merge-heavy project, keep the history linear by rebasing against the latest upstream version before publishing.</source>
          <target state="translated">部分原因是,许多有经验的 Git 用户,即使在处理一个合并量很大的项目时,也会在发布前根据最新的上游版本重新计算,以保持历史的线性。</target>
        </trans-unit>
        <trans-unit id="18fd2ef3833f23df7a3b9f0464ed57cacda16deb" translate="yes" xml:space="preserve">
          <source>Pass --quiet to git-fetch-pack and silence any other internally used git commands. Progress is not reported to the standard error stream.</source>
          <target state="translated">将 --quiet 传给 git-fetch-pack,让其他内部使用的 git 命令静音。进度不会报告到标准错误流中。</target>
        </trans-unit>
        <trans-unit id="c1e733f5e8ef91bfe63a917a4d6fc9ec48d03354" translate="yes" xml:space="preserve">
          <source>Pass --verbose to git-fetch and git-merge.</source>
          <target state="translated">将--verbose传递给git-fetch和git-merge。</target>
        </trans-unit>
        <trans-unit id="5a8b2c7c1f37cd374533e299d8006c239b39cc94" translate="yes" xml:space="preserve">
          <source>Pass &lt;code&gt;-b&lt;/code&gt; flag to &lt;code&gt;git mailinfo&lt;/code&gt; (see &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;).</source>
          <target state="translated">将 &lt;code&gt;-b&lt;/code&gt; 标志传递给 &lt;code&gt;git mailinfo&lt;/code&gt; （请参阅&lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6ad058b096d5d940b830a4807c658be882c3c4ae" translate="yes" xml:space="preserve">
          <source>Pass &lt;code&gt;-k&lt;/code&gt; flag to &lt;code&gt;git mailinfo&lt;/code&gt; (see &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;).</source>
          <target state="translated">将 &lt;code&gt;-k&lt;/code&gt; 标志传递给 &lt;code&gt;git mailinfo&lt;/code&gt; （请参阅&lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="08d9a4e291a48ec7e7744c9392f211c7729e475b" translate="yes" xml:space="preserve">
          <source>Pass &lt;code&gt;-n&lt;/code&gt; flag to &lt;code&gt;git mailinfo&lt;/code&gt; (see &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;).</source>
          <target state="translated">将 &lt;code&gt;-n&lt;/code&gt; 标志传递给 &lt;code&gt;git mailinfo&lt;/code&gt; （请参阅&lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c6c9ef8d9eb1e67c7d3dd624c5619505c72d0bcb" translate="yes" xml:space="preserve">
          <source>Pass &lt;code&gt;-q&lt;/code&gt; flag to &lt;code&gt;git unpack-objects&lt;/code&gt;; this makes the cloning process less verbose.</source>
          <target state="translated">将 &lt;code&gt;-q&lt;/code&gt; 标志传递给 &lt;code&gt;git unpack-objects&lt;/code&gt; ; 这使得克隆过程不再那么冗长。</target>
        </trans-unit>
        <trans-unit id="844d7ccb03cd6ed89f98fadab62d2737a8e85be6" translate="yes" xml:space="preserve">
          <source>Pass &lt;code&gt;-u&lt;/code&gt; flag to &lt;code&gt;git mailinfo&lt;/code&gt; (see &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;). The proposed commit log message taken from the e-mail is re-coded into UTF-8 encoding (configuration variable &lt;code&gt;i18n.commitencoding&lt;/code&gt; can be used to specify project&amp;rsquo;s preferred encoding if it is not UTF-8).</source>
          <target state="translated">将 &lt;code&gt;-u&lt;/code&gt; 标志传递给 &lt;code&gt;git mailinfo&lt;/code&gt; （请参阅&lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]&lt;/a&gt;）。从电子邮件中提取的建议提交日志消息将重新编码为UTF-8编码（如果配置变量 &lt;code&gt;i18n.commitencoding&lt;/code&gt; 不是UTF-8，则可用于指定项目的首选编码）。</target>
        </trans-unit>
        <trans-unit id="2bc55f5c25108364f3a39ef8fcf3a15e05538a97" translate="yes" xml:space="preserve">
          <source>Pass a configuration parameter to the command. The value given will override values from configuration files. The &amp;lt;name&amp;gt; is expected in the same format as listed by &lt;code&gt;git config&lt;/code&gt; (subkeys separated by dots).</source>
          <target state="translated">将配置参数传递给命令。给定的值将覆盖配置文件中的值。&amp;lt;name&amp;gt;的格式应与 &lt;code&gt;git config&lt;/code&gt; （子项用点分隔）列出的格式相同。</target>
        </trans-unit>
        <trans-unit id="53c6f0ea05fb13c74273eb0b4d13e04b5e8a0db8" translate="yes" xml:space="preserve">
          <source>Pass an additional HTTP header when communicating with a server. If more than one such entry exists, all of them are added as extra headers. To allow overriding the settings inherited from the system config, an empty value will reset the extra headers to the empty list.</source>
          <target state="translated">与服务器通信时,传递一个额外的HTTP头。如果存在多个这样的条目,所有的条目都会被添加为额外的头信息。为了允许覆盖从系统配置中继承的设置,一个空值会将额外的头信息重置为空列表。</target>
        </trans-unit>
        <trans-unit id="88461608ee691de1cd814b8c5a12a7fe39a53808" translate="yes" xml:space="preserve">
          <source>Pass merge strategy specific option through to the merge strategy.</source>
          <target state="translated">将合并策略的特定选项传递给合并策略。</target>
        </trans-unit>
        <trans-unit id="6972c66b8402bd099c21ba9d94ae803550d21e77" translate="yes" xml:space="preserve">
          <source>Pass the &amp;lt;strategy-option&amp;gt; through to the merge strategy. This implies &lt;code&gt;--merge&lt;/code&gt; and, if no strategy has been specified, &lt;code&gt;-s recursive&lt;/code&gt;. Note the reversal of &lt;code&gt;ours&lt;/code&gt; and &lt;code&gt;theirs&lt;/code&gt; as noted above for the &lt;code&gt;-m&lt;/code&gt; option.</source>
          <target state="translated">将&amp;lt;strategy-option&amp;gt;传递到合并策略。这意味着 &lt;code&gt;--merge&lt;/code&gt; ，如果未指定策略，则意味着 &lt;code&gt;-s recursive&lt;/code&gt; 。请注意，如上针对 &lt;code&gt;-m&lt;/code&gt; 选项所述， &lt;code&gt;ours&lt;/code&gt; 和 &lt;code&gt;theirs&lt;/code&gt; 的反向。</target>
        </trans-unit>
        <trans-unit id="471cf94bd65fc727b56b2f8e18afb269faa46e42" translate="yes" xml:space="preserve">
          <source>Pass the &lt;code&gt;--delta-islands&lt;/code&gt; option to &lt;code&gt;git-pack-objects&lt;/code&gt;, see &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;--delta-islands&lt;/code&gt; 选项传递给 &lt;code&gt;git-pack-objects&lt;/code&gt; ，请参见&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a1683fce9ff86fab10219f3cc0bfdfabc8f2cdd" translate="yes" xml:space="preserve">
          <source>Pass the &lt;code&gt;--local&lt;/code&gt; option to &lt;code&gt;git pack-objects&lt;/code&gt;. See &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;--local&lt;/code&gt; 选项传递给 &lt;code&gt;git pack-objects&lt;/code&gt; 。参见&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a642deef0312e0c6bd0a5561d0fd768ee8a59b73" translate="yes" xml:space="preserve">
          <source>Pass the &lt;code&gt;--no-reuse-delta&lt;/code&gt; option to &lt;code&gt;git-pack-objects&lt;/code&gt;, see &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;--no-reuse-delta&lt;/code&gt; 选项传递给 &lt;code&gt;git-pack-objects&lt;/code&gt; ，请参见&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d901d31c7644af40691b80c7d63e45696f17b53b" translate="yes" xml:space="preserve">
          <source>Pass the &lt;code&gt;--no-reuse-object&lt;/code&gt; option to &lt;code&gt;git-pack-objects&lt;/code&gt;, see &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;--no-reuse-object&lt;/code&gt; 选项传递给 &lt;code&gt;git-pack-objects&lt;/code&gt; ，请参见&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ee5cba414a5270880e2aa4a80f865762fee87e9" translate="yes" xml:space="preserve">
          <source>Pass the &lt;code&gt;-m&lt;/code&gt; flag to &lt;code&gt;git mailinfo&lt;/code&gt; (see &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;), so that the Message-ID header is added to the commit message. The &lt;code&gt;am.messageid&lt;/code&gt; configuration variable can be used to specify the default behaviour.</source>
          <target state="translated">将 &lt;code&gt;-m&lt;/code&gt; 标志传递给 &lt;code&gt;git mailinfo&lt;/code&gt; （请参阅&lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]&lt;/a&gt;），以便将Message-ID标头添加到提交消息中。该 &lt;code&gt;am.messageid&lt;/code&gt; 配置变量可以用来指定默认的行为。</target>
        </trans-unit>
        <trans-unit id="e26add554b4352375b32406b09e1002baf88696f" translate="yes" xml:space="preserve">
          <source>Pass the &lt;code&gt;-q&lt;/code&gt; option to &lt;code&gt;git pack-objects&lt;/code&gt;. See &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;-q&lt;/code&gt; 选项传递给 &lt;code&gt;git pack-objects&lt;/code&gt; 。参见&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d89c69fc0d489e2189a0abb8c756572cba9d279c" translate="yes" xml:space="preserve">
          <source>Pass the merge strategy-specific option through to the merge strategy. See &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details.</source>
          <target state="translated">将特定于合并策略的选项传递到合并策略。有关详细信息，请参见&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aae9caba3efe1e125b04992ec6689cc466bc71b8" translate="yes" xml:space="preserve">
          <source>Pass the specified string as a push option for consumption by hooks on the server side. If the server doesn&amp;rsquo;t support push options, error out. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for details.</source>
          <target state="translated">将指定的字符串作为推送选项传递，以供服务器端的挂钩使用。如果服务器不支持推送选项，请出错。有关详细信息，请参见&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;和&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3802841770affa53645333dabda9772d509a4944" translate="yes" xml:space="preserve">
          <source>Pass the timestamp fuzz factor to cvsps, in seconds. If unset, cvsps defaults to 300s.</source>
          <target state="translated">将时间戳模糊因子传递给 cvsps,以秒为单位,如果未设置,cvsps 默认为 300s。如果未设置,cvsps默认为300s。</target>
        </trans-unit>
        <trans-unit id="b62f7fb7ee127d211118f2c56411ed681d4dc9a8" translate="yes" xml:space="preserve">
          <source>Passed directly to &lt;code&gt;git rebase&lt;/code&gt; when using &lt;code&gt;dcommit&lt;/code&gt; if a &lt;code&gt;git reset&lt;/code&gt; cannot be used (see &lt;code&gt;dcommit&lt;/code&gt;).</source>
          <target state="translated">如果无法使用 &lt;code&gt;git reset&lt;/code&gt; ,则在使用 &lt;code&gt;dcommit&lt;/code&gt; 时直接传递给 &lt;code&gt;git rebase&lt;/code&gt; （请参阅 &lt;code&gt;dcommit&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e0a119c584f6be9edb9c41e31b2e495e1678cbc8" translate="yes" xml:space="preserve">
          <source>Passes the objects in the bundle to &lt;code&gt;git index-pack&lt;/code&gt; for storage in the repository, then prints the names of all defined references. If a list of references is given, only references matching those in the list are printed. This command is really plumbing, intended to be called only by &lt;code&gt;git fetch&lt;/code&gt;.</source>
          <target state="translated">将包中的对象传递到 &lt;code&gt;git index-pack&lt;/code&gt; 以便存储在存储库中，然后打印所有已定义引用的名称。如果给出了参考文献列表，则仅打印与列表中的那些文献匹配的参考文献。这个命令确实非常有用，只能由 &lt;code&gt;git fetch&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="76a10ff11a1c062361e6cf9a600e31448471fa51" translate="yes" xml:space="preserve">
          <source>Passing sh -c &quot;some commands&quot; to &quot;git bisect run&quot;</source>
          <target state="translated">将sh -c &quot;一些命令 &quot;传给 &quot;git bisect run&quot;</target>
        </trans-unit>
        <trans-unit id="5323220d01673f917e0cf25de9b3b16456b54e2a" translate="yes" xml:space="preserve">
          <source>Passing the pattern via &amp;lt;file&amp;gt; allows for providing a search pattern containing a \0.</source>
          <target state="translated">通过&amp;lt;file&amp;gt;传递模式允许提供包含\ 0的搜索模式。</target>
        </trans-unit>
        <trans-unit id="dc25b509070cc72f2f466576d5f86386a7b13eca" translate="yes" xml:space="preserve">
          <source>Password for SMTP-AUTH. The argument is optional: If no argument is specified, then the empty string is used as the password. Default is the value of &lt;code&gt;sendemail.smtpPass&lt;/code&gt;, however &lt;code&gt;--smtp-pass&lt;/code&gt; always overrides this value.</source>
          <target state="translated">SMTP-AUTH的密码。该参数是可选的：如果未指定任何参数，则将空字符串用作密码。默认值为 &lt;code&gt;sendemail.smtpPass&lt;/code&gt; 的值，但是 &lt;code&gt;--smtp-pass&lt;/code&gt; 始终会覆盖此值。</target>
        </trans-unit>
        <trans-unit id="bdca924d25420c3b18edd188df0ec914b14515eb" translate="yes" xml:space="preserve">
          <source>Password specified as an option to all p4 commands, with &lt;code&gt;-P &amp;lt;password&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4PASS&lt;/code&gt; can be used instead.</source>
          <target state="translated">使用 &lt;code&gt;-P &amp;lt;password&amp;gt;&lt;/code&gt; 将所有p4命令的密码指定为选项。可以改为使用环境变量 &lt;code&gt;P4PASS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3420ceeebad33fa39495a8a02933956bb0a3a55" translate="yes" xml:space="preserve">
          <source>Patch merge data from Arch is used to mark merges in Git as well. Git does not care much about tracking patches, and only considers a merge when a branch incorporates all the commits since the point they forked. The end result is that Git will have a good idea of how far branches have diverged. So the import process does lose some patch-trading metadata.</source>
          <target state="translated">Arch中的补丁合并数据在Git中也是用来标记合并的。Git 并不太在意对补丁的跟踪,只有当一个分支包含了分叉后的所有提交时,才会考虑合并。最终的结果是,Git会对分支的分叉程度了如指掌。所以导入过程确实会丢失一些补丁交易的元数据。</target>
        </trans-unit>
        <trans-unit id="31c42bf1738e25a658115f73ad50091aa9060241" translate="yes" xml:space="preserve">
          <source>Patch workflow</source>
          <target state="translated">补丁工作流程</target>
        </trans-unit>
        <trans-unit id="b1f5662dd2e222629919ebbe45b58d0f89867f94" translate="yes" xml:space="preserve">
          <source>Patch workflows</source>
          <target state="translated">补丁工作流程</target>
        </trans-unit>
        <trans-unit id="27352b2b463b7c072417a02bbdfc4fc80c3a786d" translate="yes" xml:space="preserve">
          <source>Patching</source>
          <target state="translated">Patching</target>
        </trans-unit>
        <trans-unit id="b560ead99e5ad114e3f8a677bf699dbd3c20bb23" translate="yes" xml:space="preserve">
          <source>Path (e.g., &lt;code&gt;repo.git&lt;/code&gt; in &lt;code&gt;https://example.com/repo.git&lt;/code&gt;). The path field of the config key must match the path field of the URL either exactly or as a prefix of slash-delimited path elements. This means a config key with path &lt;code&gt;foo/&lt;/code&gt; matches URL path &lt;code&gt;foo/bar&lt;/code&gt;. A prefix can only match on a slash (&lt;code&gt;/&lt;/code&gt;) boundary. Longer matches take precedence (so a config key with path &lt;code&gt;foo/bar&lt;/code&gt; is a better match to URL path &lt;code&gt;foo/bar&lt;/code&gt; than a config key with just path &lt;code&gt;foo/&lt;/code&gt;).</source>
          <target state="translated">路径（例如， &lt;code&gt;https://example.com/repo.git&lt;/code&gt; : &lt;code&gt;repo.git&lt;/code&gt; 中的repo.git）。config键的path字段必须与URL的路径字段完全匹配或作为斜杠分隔的路径元素的前缀匹配。这意味着路径为 &lt;code&gt;foo/&lt;/code&gt; 的配置键与URL路径 &lt;code&gt;foo/bar&lt;/code&gt; 匹配。前缀只能在斜杠（ &lt;code&gt;/&lt;/code&gt; ）边界上匹配。不再符合优先（因此与路径的配置关键 &lt;code&gt;foo/bar&lt;/code&gt; 是一个更好的匹配URL路径 &lt;code&gt;foo/bar&lt;/code&gt; 比只是路径的配置关键 &lt;code&gt;foo/&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="21d3e318bf1a1b4158750af5acdb00744a4b43b1" translate="yes" xml:space="preserve">
          <source>Path containing files with the CA certificates to verify the peer with when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_CAPATH&lt;/code&gt; environment variable.</source>
          <target state="translated">包含带有CA证书的文件的路径，用于在获取或推送HTTPS时验证对等方。可以被 &lt;code&gt;GIT_SSL_CAPATH&lt;/code&gt; 环境变量覆盖。</target>
        </trans-unit>
        <trans-unit id="fa0b12f866af9cc606a1a97e00f59d3f70f76032" translate="yes" xml:space="preserve">
          <source>Path names are encoded in UTF-8 normalization form C. This applies to tree objects, the index file, ref names, as well as path names in command line arguments, environment variables and config files (&lt;code&gt;.git/config&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;), &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;, &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;).</source>
          <target state="translated">路径名以UTF-8规范化形式C编码。这适用于树对象，索引文件，引用名称以及命令行参数，环境变量和配置文件（ &lt;code&gt;.git/config&lt;/code&gt; （请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;），&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;，&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;和&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9dbaaebd4a9c17d56a6b23f6ab97e6dcfee1c1d1" translate="yes" xml:space="preserve">
          <source>Path names in extended headers do not include the &lt;code&gt;a/&lt;/code&gt; and &lt;code&gt;b/&lt;/code&gt; prefixes.</source>
          <target state="translated">扩展头中的路径名不包含 &lt;code&gt;a/&lt;/code&gt; 和 &lt;code&gt;b/&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="398482aa4d5dc2ffcdb7a8eb1faf09763e2f1990" translate="yes" xml:space="preserve">
          <source>Path resolution via &lt;code&gt;git rev-parse --git-path&lt;/code&gt; uses either $GIT_DIR or $GIT_COMMON_DIR depending on the path. For example, in the linked working tree &lt;code&gt;git rev-parse --git-path HEAD&lt;/code&gt; returns &lt;code&gt;/path/main/.git/worktrees/test-next/HEAD&lt;/code&gt; (not &lt;code&gt;/path/other/test-next/.git/HEAD&lt;/code&gt; or &lt;code&gt;/path/main/.git/HEAD&lt;/code&gt;) while &lt;code&gt;git
rev-parse --git-path refs/heads/master&lt;/code&gt; uses $GIT_COMMON_DIR and returns &lt;code&gt;/path/main/.git/refs/heads/master&lt;/code&gt;, since refs are shared across all working trees, except refs/bisect and refs/worktree.</source>
          <target state="translated">通过 &lt;code&gt;git rev-parse --git-path&lt;/code&gt; 进行路径解析根据路径使用$ GIT_DIR或$ GIT_COMMON_DIR。例如，在链接的工作树中， &lt;code&gt;git rev-parse --git-path HEAD&lt;/code&gt; 返回 &lt;code&gt;/path/main/.git/worktrees/test-next/HEAD&lt;/code&gt; （不是 &lt;code&gt;/path/other/test-next/.git/HEAD&lt;/code&gt; 或 &lt;code&gt;/path/main/.git/HEAD&lt;/code&gt; ）而 &lt;code&gt;git rev-parse --git-path refs/heads/master&lt;/code&gt; 使用$ GIT_COMMON_DIR并返回 &lt;code&gt;/path/main/.git/refs/heads/master&lt;/code&gt; ，因为refs在所有共享工作树，但ref / bisect和ref / worktree除外。</target>
        </trans-unit>
        <trans-unit id="27ac1ba438abc8442b44c3b65ed4fee5e1af6eae" translate="yes" xml:space="preserve">
          <source>Path to a log file where the CVS server interface well&amp;hellip;​ logs various stuff. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">CVS服务器接口良好的日志文件路径...记录各种内容。参见&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad9a8cd142a486ee9476680d4a1bf638f8db23fe" translate="yes" xml:space="preserve">
          <source>Path to a store of trusted CA certificates for SMTP SSL/TLS certificate validation (either a directory that has been processed by &lt;code&gt;c_rehash&lt;/code&gt;, or a single file containing one or more PEM format certificates concatenated together: see verify(1) -CAfile and -CApath for more information on these). Set it to an empty string to disable certificate verification. Defaults to the value of the &lt;code&gt;sendemail.smtpsslcertpath&lt;/code&gt; configuration variable, if set, or the backing SSL library&amp;rsquo;s compiled-in default otherwise (which should be the best choice on most platforms).</source>
          <target state="translated">用于SMTP SSL / TLS证书验证的受信任CA证书的存储路径（由 &lt;code&gt;c_rehash&lt;/code&gt; 处理的目录，或包含一个或多个PEM格式证书并置在一起的单个文件：请参见verify（1）-CAfile和-CApath有关这些的更多信息）。将其设置为空字符串以禁用证书验证。默认值是 &lt;code&gt;sendemail.smtpsslcertpath&lt;/code&gt; 配置变量的值（如果已设置），否则为后备SSL库的默认编译值（在大多数平台上应为最佳选择）。</target>
        </trans-unit>
        <trans-unit id="b2ea00581c7262d0f351e52900685cd26b5cdc9c" translate="yes" xml:space="preserve">
          <source>Path to ca-certificates (either a directory or a single file). Set it to an empty string to disable certificate verification.</source>
          <target state="translated">ca-certificates的路径(可以是一个目录或一个文件)。将其设为空字符串,以禁用证书验证。</target>
        </trans-unit>
        <trans-unit id="59a42b0b47a7f9a3da70b7db0b79cb16c677b919" translate="yes" xml:space="preserve">
          <source>Path to the &lt;code&gt;git-receive-pack&lt;/code&gt; program on the remote end. Sometimes useful when pushing to a remote repository over ssh, and you do not have the program in a directory on the default $PATH.</source>
          <target state="translated">远端 &lt;code&gt;git-receive-pack&lt;/code&gt; 程序的路径。通过ssh推送到远程存储库时，有时会很有用，并且您的程序没有位于默认$ PATH的目录中。</target>
        </trans-unit>
        <trans-unit id="3b50759eb40ac2cfa3120816f612ac8999c3b60c" translate="yes" xml:space="preserve">
          <source>Path to the highlight executable to use (it must be the one from &lt;a href=&quot;http://www.andre-simon.de&quot;&gt;http://www.andre-simon.de&lt;/a&gt; due to assumptions about parameters and output). By default set to &lt;code&gt;highlight&lt;/code&gt;; set it to full path to highlight executable if it is not installed on your web server&amp;rsquo;s PATH. Note that &lt;code&gt;highlight&lt;/code&gt; feature must be set for gitweb to actually use syntax highlighting.</source>
          <target state="translated">要使用的突出显示可执行文件的路径（由于对参数和输出的假设，它必须是&lt;a href=&quot;http://www.andre-simon.de&quot;&gt;http://www.andre-simon.de中的文件&lt;/a&gt;）。默认设置为 &lt;code&gt;highlight&lt;/code&gt; ; 如果未将其安装在Web服务器的PATH中，请将其设置为完整路径以突出显示可执行文件。请注意，必须为gitweb设置 &lt;code&gt;highlight&lt;/code&gt; 功能才能实际使用语法突出显示。</target>
        </trans-unit>
        <trans-unit id="11df29eff55bbaa504f93c347ee5438c05683eb4" translate="yes" xml:space="preserve">
          <source>Path to wherever your core Git programs are installed. This can also be controlled by setting the GIT_EXEC_PATH environment variable. If no path is given, &lt;code&gt;git&lt;/code&gt; will print the current setting and then exit.</source>
          <target state="translated">安装核心Git程序的路径。也可以通过设置GIT_EXEC_PATH环境变量来控制。如果没有给出路径， &lt;code&gt;git&lt;/code&gt; 将打印当前设置，然后退出。</target>
        </trans-unit>
        <trans-unit id="8bee226624e5e35cc1c649560301ce6a88341f60" translate="yes" xml:space="preserve">
          <source>Pathname Format Notes and -z</source>
          <target state="translated">路径名格式注释和-z</target>
        </trans-unit>
        <trans-unit id="baad7e07c2b2e1eb7a0f4231584855cba490b25b" translate="yes" xml:space="preserve">
          <source>Pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">如配置变量 &lt;code&gt;core.quotePath&lt;/code&gt; 所述，引用带有&amp;ldquo;不寻常&amp;rdquo;字符的路径名（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="faafd85683bf6f5bc5b49f23461483144ba14fdc" translate="yes" xml:space="preserve">
          <source>Paths in which the change applied cleanly are updated both in the index file and in your working tree.</source>
          <target state="translated">在索引文件和工作树中,应用了干净的更改的路径都会更新。</target>
        </trans-unit>
        <trans-unit id="02f71c6b4a6bff00e221f1c59f788c05e9bf57ff" translate="yes" xml:space="preserve">
          <source>Paths may need to be prefixed with &lt;code&gt;--&lt;/code&gt; to separate them from options or the revision range, when confusion arises.</source>
          <target state="translated">出现混淆时，可能需要在路径前面加上 &lt;code&gt;--&lt;/code&gt; 来将它们与选项或修订范围分开。</target>
        </trans-unit>
        <trans-unit id="72d92e139b6d6167634cfbe91ec0c2ba1cace91a" translate="yes" xml:space="preserve">
          <source>Paths that merged cleanly are updated both in the index file and in your working tree.</source>
          <target state="translated">合并干净的路径在索引文件和工作树中都会更新。</target>
        </trans-unit>
        <trans-unit id="4d8223b3c254f584e9779f7d614adb9369021888" translate="yes" xml:space="preserve">
          <source>Paths to submodule(s). When specified this will restrict the command to only operate on the submodules found at the specified paths. (This argument is required with add).</source>
          <target state="translated">子模块的路径。当指定时,这将限制命令只在指定路径的子模块上运行。(这个参数是add时需要的)。</target>
        </trans-unit>
        <trans-unit id="d837befa2a08a2d2c5de9a52f9ba8092713b988b" translate="yes" xml:space="preserve">
          <source>Pathspec is passed in &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; instead of commandline args. If &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; is exactly &lt;code&gt;-&lt;/code&gt; then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). See also &lt;code&gt;--pathspec-file-nul&lt;/code&gt; and global &lt;code&gt;--literal-pathspecs&lt;/code&gt;.</source>
          <target state="translated">Pathspec在 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 中而不是命令行args中传递。如果 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 恰好 &lt;code&gt;-&lt;/code&gt; 使用标准输入。Pathspec元素由LF或CR / LF分隔。可以按照配置变量 &lt;code&gt;core.quotePath&lt;/code&gt; 的说明引用路径规范元素（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。另请参见 &lt;code&gt;--pathspec-file-nul&lt;/code&gt; 和全局 &lt;code&gt;--literal-pathspecs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c3fe95fefb92e7001401ae2dddbe0254cb07692" translate="yes" xml:space="preserve">
          <source>Pathspecs are used on the command line of &quot;git ls-files&quot;, &quot;git ls-tree&quot;, &quot;git add&quot;, &quot;git grep&quot;, &quot;git diff&quot;, &quot;git checkout&quot;, and many other commands to limit the scope of operations to some subset of the tree or worktree. See the documentation of each command for whether paths are relative to the current directory or toplevel. The pathspec syntax is as follows:</source>
          <target state="translated">路径规格在 &quot;git ls-files&quot;、&quot;git ls-tree&quot;、&quot;git add&quot;、&quot;git grep&quot;、&quot;git diff&quot;、&quot;git checkout &quot;和许多其他命令的命令行中使用,以将操作范围限制在树或工作树的某些子集上。关于路径是相对于当前目录还是toplevel,请参见每个命令的文档。pathspec的语法如下。</target>
        </trans-unit>
        <trans-unit id="3edd060b9dbe00aa0b104e48e6298fa38d5e841a" translate="yes" xml:space="preserve">
          <source>Pattern format</source>
          <target state="translated">模式格式</target>
        </trans-unit>
        <trans-unit id="fcba9b37f153a6df141f56c87f41e26ebdda34ce" translate="yes" xml:space="preserve">
          <source>Pattern used to limit paths in Git commands.</source>
          <target state="translated">用于限制 Git 命令中的路径的模式。</target>
        </trans-unit>
        <trans-unit id="eb7b848d74da9a813e33fe644876b71e9e6bcaa4" translate="yes" xml:space="preserve">
          <source>Patterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern. For example, the pattern &quot;&lt;code&gt;foo*bar&lt;/code&gt;&quot; matches &quot;&lt;code&gt;fooasdfbar&lt;/code&gt;&quot; and &quot;&lt;code&gt;foo/bar/baz/asdf&lt;/code&gt;&quot; but not &quot;&lt;code&gt;foobarx&lt;/code&gt;&quot;.</source>
          <target state="translated">模式的语法和语义与不带FNM_PATHNAME标志的fnmatch（3）所使用的模式具有相同的语法和语义，不同之处在于，如果删除任意数量的最终路径名组件，该路径名也会与该模式匹配。例如，模式&amp;ldquo; &lt;code&gt;foo*bar&lt;/code&gt; &amp;rdquo;匹配&amp;ldquo; &lt;code&gt;fooasdfbar&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;foo/bar/baz/asdf&lt;/code&gt; &amp;rdquo;，但不 &lt;code&gt;foobarx&lt;/code&gt; &amp;ldquo; foob​​arx &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="fb013761be8ab363fba21719f323aaadcbd3ba0f" translate="yes" xml:space="preserve">
          <source>Patterns read from &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 读取的模式。</target>
        </trans-unit>
        <trans-unit id="6698f9ee7644a05337be6a499b35a3dc93d5c62b" translate="yes" xml:space="preserve">
          <source>Patterns read from a &lt;code&gt;.gitignore&lt;/code&gt; file in the same directory as the path, or in any parent directory, with patterns in the higher level files (up to the toplevel of the work tree) being overridden by those in lower level files down to the directory containing the file. These patterns match relative to the location of the &lt;code&gt;.gitignore&lt;/code&gt; file. A project normally includes such &lt;code&gt;.gitignore&lt;/code&gt; files in its repository, containing patterns for files generated as part of the project build.</source>
          <target state="translated">从与路径相同的目录中或任何父目录中的 &lt;code&gt;.gitignore&lt;/code&gt; 文件读取的模式，较高级别文件（直到工作树的顶层）中的模式被较低级别文件中的模式覆盖，直至该目录包含文件。这些模式相对于 &lt;code&gt;.gitignore&lt;/code&gt; 文件的位置匹配。项目通常在其存储库中包含此类 &lt;code&gt;.gitignore&lt;/code&gt; 文件，其中包含作为项目构建一部分而生成的文件的模式。</target>
        </trans-unit>
        <trans-unit id="36ee091d7bc3859a1b36e4f946f23e3881e4ee18" translate="yes" xml:space="preserve">
          <source>Patterns read from the command line for those commands that support them.</source>
          <target state="translated">从命令行中读取支持这些命令的模式。</target>
        </trans-unit>
        <trans-unit id="eafc03d17e54d88cb802971c79de6de883bd2e33" translate="yes" xml:space="preserve">
          <source>Patterns read from the file specified by the configuration variable &lt;code&gt;core.excludesFile&lt;/code&gt;.</source>
          <target state="translated">从配置变量 &lt;code&gt;core.excludesFile&lt;/code&gt; 指定的文件中读取模式。</target>
        </trans-unit>
        <trans-unit id="3d5b457ce32a5c844bdd2578141f772cb2dfe28f" translate="yes" xml:space="preserve">
          <source>Patterns which a user wants Git to ignore in all situations (e.g., backup or temporary files generated by the user&amp;rsquo;s editor of choice) generally go into a file specified by &lt;code&gt;core.excludesFile&lt;/code&gt; in the user&amp;rsquo;s &lt;code&gt;~/.gitconfig&lt;/code&gt;. Its default value is $XDG_CONFIG_HOME/git/ignore. If $XDG_CONFIG_HOME is either not set or empty, $HOME/.config/git/ignore is used instead.</source>
          <target state="translated">用户希望Git在所有情况下都忽略的模式（例如，由用户选择的编辑器生成的备份或临时文件）通常进入用户 &lt;code&gt;~/.gitconfig&lt;/code&gt; 由 &lt;code&gt;core.excludesFile&lt;/code&gt; 指定的文件中。其默认值为$ XDG_CONFIG_HOME / git / ignore。如果$ XDG_CONFIG_HOME未设置或为空，则改用$ HOME / .config / git / ignore。</target>
        </trans-unit>
        <trans-unit id="5587255035843df5d5295452dbedab67822586cc" translate="yes" xml:space="preserve">
          <source>Patterns which are specific to a particular repository but which do not need to be shared with other related repositories (e.g., auxiliary files that live inside the repository but are specific to one user&amp;rsquo;s workflow) should go into the &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; file.</source>
          <target state="translated">特定于特定存储库但无需与其他相关存储库共享的模式（例如，位于存储库中但特定于一个用户工作流程的辅助文件）应放入 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="97235836632b1fb86b67505c96cba9f6f391329a" translate="yes" xml:space="preserve">
          <source>Patterns which should be version-controlled and distributed to other repositories via clone (i.e., files that all developers will want to ignore) should go into a &lt;code&gt;.gitignore&lt;/code&gt; file.</source>
          <target state="translated">应该由版本控制并通过克隆（即，所有开发人员都将要忽略的文件）分发给其他存储库的模式应放入 &lt;code&gt;.gitignore&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="74e957861d59dc180f4938a7e5cbcccc25f5a3ea" translate="yes" xml:space="preserve">
          <source>Patterns will normally need quoting.</source>
          <target state="translated">模式通常需要引用。</target>
        </trans-unit>
        <trans-unit id="df5e4a7c782200671a0c551a8ae8bde4cbfd4554" translate="yes" xml:space="preserve">
          <source>Peek at a remote&amp;rsquo;s branch, without configuring the remote in your local repository:</source>
          <target state="translated">查看远程分支，无需在本地存储库中配置远程：</target>
        </trans-unit>
        <trans-unit id="2eee9784312fca59a15483a1887af3e9d7aeb47b" translate="yes" xml:space="preserve">
          <source>People needing to do actual development will also want to read &lt;a href=&quot;#Developing-With-git&quot;&gt;Developing with Git&lt;/a&gt; and &lt;a href=&quot;#sharing-development&quot;&gt;Sharing development with others&lt;/a&gt;.</source>
          <target state="translated">需要做实际开发的人也将要阅读&lt;a href=&quot;#Developing-With-git&quot;&gt;Git的开发&lt;/a&gt;和&lt;a href=&quot;#sharing-development&quot;&gt;共享发展与他人&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d16acfd9d0006fc21d168918fe3efc81d8650072" translate="yes" xml:space="preserve">
          <source>People who play the &lt;a href=&quot;#INTEGRATOR&quot;&gt;Integrator&lt;/a&gt; role need to learn some more commands in addition to the above.</source>
          <target state="translated">除了上述内容，扮演&lt;a href=&quot;#INTEGRATOR&quot;&gt;Integrator&lt;/a&gt;角色的人员还需要学习更多命令。</target>
        </trans-unit>
        <trans-unit id="48b4677fc2e9a16153ae455818d81437374385ab" translate="yes" xml:space="preserve">
          <source>Per-repository gitweb configuration</source>
          <target state="translated">每个仓库的gitweb配置</target>
        </trans-unit>
        <trans-unit id="a457d6f200ccaae5acadefc147a0317025017a2f" translate="yes" xml:space="preserve">
          <source>Perforce keeps the encoding of a path as given by the originating OS. Git expects paths encoded as UTF-8. Use this config to tell git-p4 what encoding Perforce had used for the paths. This encoding is used to transcode the paths to UTF-8. As an example, Perforce on Windows often uses &quot;cp1252&quot; to encode path names.</source>
          <target state="translated">Perforce保留了原始操作系统给出的路径编码。Git 希望路径的编码为 UTF-8。使用这个配置来告诉 git-p4 Perforce 对路径使用的编码。这个编码用于将路径转码为UTF-8。举个例子,Windows 上的 Perforce 经常使用 &quot;cp1252&quot; 来编码路径名。</target>
        </trans-unit>
        <trans-unit id="03b8553af827c912cedc4f1a54e56b3f62407825" translate="yes" xml:space="preserve">
          <source>Perform a bare clone. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;.</source>
          <target state="translated">执行裸克隆。参见&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d72b7a492b7bd341e81ed1aa91cf43a8cb1b23e" translate="yes" xml:space="preserve">
          <source>Perform a merge, not just a read. The command will refuse to run if your index file has unmerged entries, indicating that you have not finished previous merge you started.</source>
          <target state="translated">执行合并,而不仅仅是读取。如果你的索引文件中有未合并的条目,该命令将拒绝运行,这表明你还没有完成之前开始的合并。</target>
        </trans-unit>
        <trans-unit id="eccacfa088a41a325854fbfce829a88ff14b78ec" translate="yes" xml:space="preserve">
          <source>Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is multiple of &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt;) in the log message before showing it in the output. &lt;code&gt;--expand-tabs&lt;/code&gt; is a short-hand for &lt;code&gt;--expand-tabs=8&lt;/code&gt;, and &lt;code&gt;--no-expand-tabs&lt;/code&gt; is a short-hand for &lt;code&gt;--expand-tabs=0&lt;/code&gt;, which disables tab expansion.</source>
          <target state="translated">在日志消息中执行选项卡扩展（在每个选项卡中留出足够的空间以填充到下一个显示列，该显示列是 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 的倍数），然后在输出中显示它。 &lt;code&gt;--expand-tabs&lt;/code&gt; 是 &lt;code&gt;--expand-tabs=8&lt;/code&gt; 的简写，而 &lt;code&gt;--no-expand-tabs&lt;/code&gt; 是 &lt;code&gt;--expand-tabs=0&lt;/code&gt; 的简写，它禁用标签扩展。</target>
        </trans-unit>
        <trans-unit id="6fe3dd23120fae0b6c8f1955f52c35dc123f3355" translate="yes" xml:space="preserve">
          <source>Perform move and/or copy detection, as described in the &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; manual page, and use it to generate rename and copy commands in the output dump.</source>
          <target state="translated">执行&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;手册页中所述的移动和/或复制检测，并使用它在输出转储中生成重命名和复制命令。</target>
        </trans-unit>
        <trans-unit id="567ab62415c3403908dcc89e62181367d58a1292" translate="yes" xml:space="preserve">
          <source>Perform only a single read-write cycle with stdin and stdout. This fits with the HTTP POST request processing model where a program may read the request, write a response, and must exit.</source>
          <target state="translated">对stdin和stdout只执行一次读写循环。这与HTTP POST请求处理模型相适应,程序可以读取请求,写入响应,并且必须退出。</target>
        </trans-unit>
        <trans-unit id="41e22f08445cd4ffeacb1dbe66209f768caca3d4" translate="yes" xml:space="preserve">
          <source>Perform sanity checks on patches. Currently, validation means the following:</source>
          <target state="translated">对补丁进行理智性检查。目前,验证指的是:</target>
        </trans-unit>
        <trans-unit id="5dd19cbcd38d018175e7d4b32fed6afd6bedcbe4" translate="yes" xml:space="preserve">
          <source>Perform the merge and commit the result. This option can be used to override --no-commit.</source>
          <target state="translated">执行合并并提交结果。这个选项可以用来覆盖--no-commit。</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="7b942adfd148d1f49e5f455e2928985f17ee890d" translate="yes" xml:space="preserve">
          <source>Performance and Compression Tuning</source>
          <target state="translated">性能和压缩调整</target>
        </trans-unit>
        <trans-unit id="9848b9866799244495cf3924e3205cf2b3c1519c" translate="yes" xml:space="preserve">
          <source>Performing a three-way merge</source>
          <target state="translated">执行三方合并</target>
        </trans-unit>
        <trans-unit id="c7a1bc80737fe18d499952e507805c3eb4a06cbb" translate="yes" xml:space="preserve">
          <source>Performing text diffs of binary files</source>
          <target state="translated">执行二进制文件的文本差异</target>
        </trans-unit>
        <trans-unit id="eefd6fa4d473259c02ba61e1f0886b5b36cd638b" translate="yes" xml:space="preserve">
          <source>Pick &lt;code&gt;HEAD&lt;/code&gt; when it asks what branch/tag to check out. Untick the &quot;launch commit wizard&quot; to avoid committing the .project file.</source>
          <target state="translated">在询问要签出哪个分支/标签时选择 &lt;code&gt;HEAD&lt;/code&gt; 。取消选中&amp;ldquo;启动提交向导&amp;rdquo;以避免提交.project文件。</target>
        </trans-unit>
        <trans-unit id="84307347f945f7519a1053bc099c7c72668957a6" translate="yes" xml:space="preserve">
          <source>Pick out and massage parameters</source>
          <target state="translated">挑选和按摩参数</target>
        </trans-unit>
        <trans-unit id="6fcb3939990224a308d3440baf7b583ff2b6b3d4" translate="yes" xml:space="preserve">
          <source>Pipe all output into &lt;code&gt;less&lt;/code&gt; (or if set, $PAGER) if standard output is a terminal. This overrides the &lt;code&gt;pager.&amp;lt;cmd&amp;gt;&lt;/code&gt; configuration options (see the &quot;Configuration Mechanism&quot; section below).</source>
          <target state="translated">如果标准输出是终端，则将所有输出传递到 &lt;code&gt;less&lt;/code&gt; （或设置为$ PAGER）中。这将覆盖 &lt;code&gt;pager.&amp;lt;cmd&amp;gt;&lt;/code&gt; 配置选项（请参阅下面的&amp;ldquo;配置机制&amp;rdquo;部分）。</target>
        </trans-unit>
        <trans-unit id="cbb76042b365f8d09d0e51150e4e490e9d51908c" translate="yes" xml:space="preserve">
          <source>Pitfalls with submodules</source>
          <target state="translated">子模块的陷阱</target>
        </trans-unit>
        <trans-unit id="9bdaaf18e8d137e15a223b206babd14884c750c4" translate="yes" xml:space="preserve">
          <source>Placeholders that affect formatting of later placeholders:</source>
          <target state="translated">占位符,影响以后占位符的格式。</target>
        </trans-unit>
        <trans-unit id="ac211ac96ed9534ab58287056fd17e14f5f3e99f" translate="yes" xml:space="preserve">
          <source>Placeholders that expand to a single literal character:</source>
          <target state="translated">占位符,可扩展为单个文字字符。</target>
        </trans-unit>
        <trans-unit id="d70cc19bb51191879a6f88620cd832b063255806" translate="yes" xml:space="preserve">
          <source>Placeholders that expand to information extracted from the commit:</source>
          <target state="translated">占位符,可扩展到从提交中提取的信息。</target>
        </trans-unit>
        <trans-unit id="a17341864ca5844ed689cbcc0e99aa3136fe86e9" translate="yes" xml:space="preserve">
          <source>Placing a &lt;code&gt;progress&lt;/code&gt; command immediately after a &lt;code&gt;checkpoint&lt;/code&gt; will inform the reader when the &lt;code&gt;checkpoint&lt;/code&gt; has been completed and it can safely access the refs that fast-import updated.</source>
          <target state="translated">放置一个 &lt;code&gt;progress&lt;/code&gt; 一后，立即命令 &lt;code&gt;checkpoint&lt;/code&gt; 将告诉读者时， &lt;code&gt;checkpoint&lt;/code&gt; 工作已经完成，它可以安全地访问快速导入更新的裁判。</target>
        </trans-unit>
        <trans-unit id="29d132c8dca94eedc4761b19f4e56a63b7eb3b41" translate="yes" xml:space="preserve">
          <source>Please note that these range notation can be used with both gitk and &quot;git log&quot;.</source>
          <target state="translated">请注意,这些范围符号可以与gitk和 &quot;git log &quot;同时使用。</target>
        </trans-unit>
        <trans-unit id="a872f84e7510205bc273ea7f3487281d6e0b57f1" translate="yes" xml:space="preserve">
          <source>Please note that using the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute may have a number of pitfalls:</source>
          <target state="translated">请注意，使用 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性可能会有很多陷阱：</target>
        </trans-unit>
        <trans-unit id="cddad527343fcd5e5d11ccf1bbf7e571af789394" translate="yes" xml:space="preserve">
          <source>Please note that you cannot use an existing &lt;code&gt;filter.&amp;lt;driver&amp;gt;.clean&lt;/code&gt; or &lt;code&gt;filter.&amp;lt;driver&amp;gt;.smudge&lt;/code&gt; command with &lt;code&gt;filter.&amp;lt;driver&amp;gt;.process&lt;/code&gt; because the former two use a different inter process communication protocol than the latter one.</source>
          <target state="translated">请注意，不能将现有的 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.clean&lt;/code&gt; &lt;code&gt;filter.&amp;lt;driver&amp;gt;.smudge&lt;/code&gt; 或filter。&amp;lt;driver&amp;gt; .smudge命令与 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.process&lt;/code&gt; .process一起使用，因为前两者使用的进程间通信协议与后者不同。</target>
        </trans-unit>
        <trans-unit id="c888d4a15197bdd365e37f0125b6b805c57d4e97" translate="yes" xml:space="preserve">
          <source>Please report any bugs or feature requests to &lt;a href=&quot;mailto:git@vger.kernel.org&quot;&gt;git@vger.kernel.org&lt;/a&gt;, putting &quot;gitweb&quot; in the subject of email.</source>
          <target state="translated">请向&lt;a href=&quot;mailto:git@vger.kernel.org&quot;&gt;git@vger.kernel.org&lt;/a&gt;报告任何错误或功能请求，并在电子邮件主题中添加&amp;ldquo; gitweb&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f21025df43e0479e4864841eab47e70f94cac837" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for alternative ways to add content to a commit.</source>
          <target state="translated">请参阅&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;了解向提交添加内容的替代方法。</target>
        </trans-unit>
        <trans-unit id="0aae3fa8eecc17be69c8d9ed6207c5a978bd3a01" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f7f1dd4c4366b63a145049cec2f6258fda24d83" translate="yes" xml:space="preserve">
          <source>Please see the &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; document.</source>
          <target state="translated">请参阅&lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="9a1b79b9af4861f2750548663461bdd94c841127" translate="yes" xml:space="preserve">
          <source>Plumbing Commands</source>
          <target state="translated">水管命令</target>
        </trans-unit>
        <trans-unit id="dec39f942885f611a23f70c734d12d63a6e011e1" translate="yes" xml:space="preserve">
          <source>Points to the location where you put &lt;code&gt;git-favicon.png&lt;/code&gt; on your web server, or to be more the generic URI of favicon, which will be served as &quot;image/png&quot; type. Web browsers that support favicons (website icons) may display them in the browser&amp;rsquo;s URL bar and next to the site name in bookmarks. Relative to the base URI of gitweb. Can be adjusted at build time using &lt;code&gt;GITWEB_FAVICON&lt;/code&gt; variable. By default set to &lt;code&gt;static/git-favicon.png&lt;/code&gt;.</source>
          <target state="translated">指向将 &lt;code&gt;git-favicon.png&lt;/code&gt; 放置在Web服务器上的位置，或更确切地说是favicon的通用URI，它将用作&amp;ldquo; image / png&amp;rdquo;类型。支持收藏夹图标（网站图标）的Web浏览器可以在浏览器的URL栏中以及书签中站点名称旁边显示它们。相对于gitweb的基本URI。可以在构建时使用 &lt;code&gt;GITWEB_FAVICON&lt;/code&gt; 变量进行调整。默认情况下设置为 &lt;code&gt;static/git-favicon.png&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a40c85c88d228670d36d1d2ec3cd1298a4f0842" translate="yes" xml:space="preserve">
          <source>Points to the location where you put &lt;code&gt;git-logo.png&lt;/code&gt; on your web server, or to be more the generic URI of logo, 72x27 size). This image is displayed in the top right corner of each gitweb page and used as a logo for the Atom feed. Relative to the base URI of gitweb (as a path). Can be adjusted when building gitweb using &lt;code&gt;GITWEB_LOGO&lt;/code&gt; variable By default set to &lt;code&gt;static/git-logo.png&lt;/code&gt;.</source>
          <target state="translated">指向将 &lt;code&gt;git-logo.png&lt;/code&gt; 放置在Web服务器上的位置，或者指向徽标的通用URI（大小为72x27）。该图像显示在每个gitweb页面的右上角，并用作Atom feed的徽标。相对于gitweb的基本URI（作为路径）。在使用 &lt;code&gt;GITWEB_LOGO&lt;/code&gt; 变量构建gitweb时可以调整，默认情况下设置为 &lt;code&gt;static/git-logo.png&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9efd93f849deab28e0c41b0eba10b16f24a27c09" translate="yes" xml:space="preserve">
          <source>Points to the location where you put &lt;code&gt;gitweb.js&lt;/code&gt; on your web server, or to be more generic the URI of JavaScript code used by gitweb. Relative to the base URI of gitweb. Can be set at build time using the &lt;code&gt;GITWEB_JS&lt;/code&gt; build-time configuration variable.</source>
          <target state="translated">指向您将 &lt;code&gt;gitweb.js&lt;/code&gt; 放置在Web服务器上的位置，或更一般地说，是gitweb使用的JavaScript代码的URI。相对于gitweb的基本URI。可以使用 &lt;code&gt;GITWEB_JS&lt;/code&gt; 构建时配置变量在构建时进行设置。</target>
        </trans-unit>
        <trans-unit id="dd1dad0df44ac8f0bb40744bffd4b05eb8a096a6" translate="yes" xml:space="preserve">
          <source>Populating a git repository</source>
          <target state="translated">填充一个git仓库</target>
        </trans-unit>
        <trans-unit id="4cbb689daa97a321dd935e9f85d305871f823e3a" translate="yes" xml:space="preserve">
          <source>Porcelain Format</source>
          <target state="translated">瓷器格式</target>
        </trans-unit>
        <trans-unit id="7ed7cead662f9f179a2456c29bfdc5633f939f7a" translate="yes" xml:space="preserve">
          <source>Porcelain Format Version 1</source>
          <target state="translated">瓷器格式1</target>
        </trans-unit>
        <trans-unit id="10c9d2c56f0a79c71fe3af29b00f0a78804206c5" translate="yes" xml:space="preserve">
          <source>Porcelain Format Version 2</source>
          <target state="translated">瓷器格式第2版</target>
        </trans-unit>
        <trans-unit id="f0ec9d0a213551004afb541fee3084e09f53878a" translate="yes" xml:space="preserve">
          <source>Port number (e.g., &lt;code&gt;8080&lt;/code&gt; in &lt;code&gt;http://example.com:8080/&lt;/code&gt;). This field must match exactly between the config key and the URL. Omitted port numbers are automatically converted to the correct default for the scheme before matching.</source>
          <target state="translated">端口号（例如， &lt;code&gt;http://example.com:8080/&lt;/code&gt; : &lt;code&gt;8080&lt;/code&gt; /中的8080）。此字段必须与config键和URL之间完全匹配。匹配之前，忽略的端口号会自动转换为方案的正确默认值。</target>
        </trans-unit>
        <trans-unit id="75288f00d3cca5affbead93289ac710b7d804777" translate="yes" xml:space="preserve">
          <source>Port specified as an option to all p4 commands, with &lt;code&gt;-p &amp;lt;port&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4PORT&lt;/code&gt; can be used instead.</source>
          <target state="translated">使用 &lt;code&gt;-p &amp;lt;port&amp;gt;&lt;/code&gt; 将端口指定为所有p4命令的选项。可以改用环境变量 &lt;code&gt;P4PORT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d03006f15a6deece98761a569d6fb9a550c11064" translate="yes" xml:space="preserve">
          <source>Possible status letters are:</source>
          <target state="translated">可能的状态信是:</target>
        </trans-unit>
        <trans-unit id="2e4db4c63c7f46787206b1d1234a6ef557d7a11f" translate="yes" xml:space="preserve">
          <source>Post-receive hook</source>
          <target state="translated">接收后挂钩</target>
        </trans-unit>
        <trans-unit id="bfc66b933494b39d9139ca2f875fbedec7e5e101" translate="yes" xml:space="preserve">
          <source>Post-update hook</source>
          <target state="translated">更新后的钩子</target>
        </trans-unit>
        <trans-unit id="f94b267b37a51057882021d23cd86eedc7aa6025" translate="yes" xml:space="preserve">
          <source>Pre-merge checks</source>
          <target state="translated">合并前检查</target>
        </trans-unit>
        <trans-unit id="b3efe66caa7433d78cc0ca460492b30524a4fffe" translate="yes" xml:space="preserve">
          <source>Pre-receive hook</source>
          <target state="translated">预收钩</target>
        </trans-unit>
        <trans-unit id="78240cc944ed7959bc15c94695f728eafb8fe296" translate="yes" xml:space="preserve">
          <source>Prefer to use &lt;code&gt;git svn rebase&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt;, rather than &lt;code&gt;git pull&lt;/code&gt; or &lt;code&gt;git merge&lt;/code&gt; to synchronize unintegrated commits with a &lt;code&gt;git svn&lt;/code&gt; branch. Doing so will keep the history of unintegrated commits linear with respect to the upstream SVN repository and allow the use of the preferred &lt;code&gt;git svn dcommit&lt;/code&gt; subcommand to push unintegrated commits back into SVN.</source>
          <target state="translated">最好使用 &lt;code&gt;git svn rebase&lt;/code&gt; 或 &lt;code&gt;git rebase&lt;/code&gt; ，而不是 &lt;code&gt;git pull&lt;/code&gt; 或 &lt;code&gt;git merge&lt;/code&gt; 来将未集成的提交与 &lt;code&gt;git svn&lt;/code&gt; 分支同步。这样做将使未集成提交的历史记录相对于上游SVN存储库保持线性，并允许使用首选的 &lt;code&gt;git svn dcommit&lt;/code&gt; 子命令将未集成的提交推回SVN。</target>
        </trans-unit>
        <trans-unit id="7858ef8a3e54ce180319d79ebe56992e0e058c1d" translate="yes" xml:space="preserve">
          <source>Prefix the 1-indexed byte-offset of the first match from the start of the matching line.</source>
          <target state="translated">从匹配行的开始,将第一个匹配的1个索引的字节集放在前面。</target>
        </trans-unit>
        <trans-unit id="f98eece57f5c0c3847ca98d0dc9e3916d907af8e" translate="yes" xml:space="preserve">
          <source>Prefix the line number to matching lines.</source>
          <target state="translated">将行号前缀在匹配行上。</target>
        </trans-unit>
        <trans-unit id="cba9c5d09c8d367bd67d9492c7466ff20503c458" translate="yes" xml:space="preserve">
          <source>Prepare a public repository accessible to others, just like the &quot;project lead&quot; person does.</source>
          <target state="translated">像 &quot;项目负责人 &quot;一样,准备一个可供他人访问的公共资源库。</target>
        </trans-unit>
        <trans-unit id="2a7490f3f599e93e81fac551095363496940e575" translate="yes" xml:space="preserve">
          <source>Prepare a public repository accessible to others.</source>
          <target state="translated">筹备一个可供他人访问的公共储存库;</target>
        </trans-unit>
        <trans-unit id="f3c2eb8e7f45787546457741123fe87f7a0f8282" translate="yes" xml:space="preserve">
          <source>Prepare each commit with its patch in one file per commit, formatted to resemble UNIX mailbox format. The output of this command is convenient for e-mail submission or for use with &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">在每个提交的一个文件中准备每个提交及其补丁，其格式类似于UNIX邮箱格式。该命令的输出便于提交电子邮件或与 &lt;code&gt;git am&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="5bf024f30d7d353a4bfdcd90569f916ebb19100a" translate="yes" xml:space="preserve">
          <source>Prepare patches for e-mail submission</source>
          <target state="translated">为电子邮件提交准备补丁</target>
        </trans-unit>
        <trans-unit id="a8276d8a28067c8245d05a67d9e202424a88780d" translate="yes" xml:space="preserve">
          <source>Prepare patches from the topmost &amp;lt;n&amp;gt; commits.</source>
          <target state="translated">从最前面的&amp;lt;n&amp;gt;个提交准备补丁。</target>
        </trans-unit>
        <trans-unit id="99740b269904a01f8762ffe4e520b6b559ecd506" translate="yes" xml:space="preserve">
          <source>Prepare the patch as a text file using your method of choice.</source>
          <target state="translated">使用你选择的方法将补丁准备成文本文件。</target>
        </trans-unit>
        <trans-unit id="f5c02726894a93a50b6991465d16de430338896a" translate="yes" xml:space="preserve">
          <source>Prepare the patch as a text file.</source>
          <target state="translated">将补丁准备成文本文件。</target>
        </trans-unit>
        <trans-unit id="5fdffb29f622a40bb487926aa05bf2c00b010193" translate="yes" xml:space="preserve">
          <source>Prepare to work on top of &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;, by detaching &lt;code&gt;HEAD&lt;/code&gt; at it (see &quot;DETACHED HEAD&quot; section), and updating the index and the files in the working tree. Local modifications to the files in the working tree are kept, so that the resulting working tree will be the state recorded in the commit plus the local modifications.</source>
          <target state="translated">准备在 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 上工作，方法是分离 &lt;code&gt;HEAD&lt;/code&gt; （请参阅&amp;ldquo; DETACHED HEAD&amp;rdquo;部分），并更新工作树中的索引和文件。保留了对工作树中文件的本地修改，因此生成的工作树将是提交中记录的状态加上本地修改。</target>
        </trans-unit>
        <trans-unit id="f2f7b858e8531ffd309df8bd0107db9d4a088dc3" translate="yes" xml:space="preserve">
          <source>Prepare your primary repository on your local machine. Your work is done there.</source>
          <target state="translated">在你的本地机器上准备好你的主仓库。你的工作就在那里完成。</target>
        </trans-unit>
        <trans-unit id="6351b7119828a745613d6b91f6668ddb5c9afa30" translate="yes" xml:space="preserve">
          <source>Prepare your work repository, by &lt;code&gt;git clone&lt;/code&gt; the public repository of the &quot;project lead&quot; (or a &quot;subsystem maintainer&quot;, if you work on a subsystem). The URL used for the initial cloning is stored in the remote.origin.url configuration variable.</source>
          <target state="translated">通过 &lt;code&gt;git clone&lt;/code&gt; &amp;ldquo;项目负责人&amp;rdquo;（或&amp;ldquo;子系统维护者&amp;rdquo;，如果您在子系统上工作）的公共资源库来准备工作资源库。用于初始克隆的URL存储在remote.origin.url配置变量中。</target>
        </trans-unit>
        <trans-unit id="ab02c2194a1b4abbc5e110578e0e0c5797b11598" translate="yes" xml:space="preserve">
          <source>Prepare your work repository, by running &lt;code&gt;git clone&lt;/code&gt; on the public repository of the &quot;project lead&quot;. The URL used for the initial cloning is stored in the remote.origin.url configuration variable.</source>
          <target state="translated">通过在&amp;ldquo;项目负责人&amp;rdquo;的公共存储库上运行 &lt;code&gt;git clone&lt;/code&gt; 来准备工作存储库。用于初始克隆的URL存储在remote.origin.url配置变量中。</target>
        </trans-unit>
        <trans-unit id="8d8f6ddbe39b836164638d60534dc0f8ce8c98b4" translate="yes" xml:space="preserve">
          <source>Prepend &amp;lt;path&amp;gt; to paths printed in informative messages such as &quot;Fetching submodule foo&quot;. This option is used internally when recursing over submodules.</source>
          <target state="translated">将&amp;lt;path&amp;gt;附加到在信息性消息中打印的路径，例如&amp;ldquo; Fetching submodule foo&amp;rdquo;。在子模块上递归时在内部使用此选项。</target>
        </trans-unit>
        <trans-unit id="0d9e5ac62ee99d055177c6a4f95d4b7fe25a63a3" translate="yes" xml:space="preserve">
          <source>Prepend &amp;lt;prefix&amp;gt;/ to each filename in the archive.</source>
          <target state="translated">在存档中的每个文件名前添加&amp;lt;prefix&amp;gt; /。</target>
        </trans-unit>
        <trans-unit id="a1528f0aff1e31c1f36c8998ca335269e9595dd6" translate="yes" xml:space="preserve">
          <source>Prepend &amp;lt;root&amp;gt; to all filenames. If a &quot;-p&quot; argument was also passed, it is applied before prepending the new root.</source>
          <target state="translated">在&amp;lt;root&amp;gt;之前添加所有文件名。如果还传递了&amp;ldquo; -p&amp;rdquo;参数，则在添加新的根目录之前应用该参数。</target>
        </trans-unit>
        <trans-unit id="04fbe49467d421955780154f308daccbf9dcf57a" translate="yes" xml:space="preserve">
          <source>Prepend &lt;code&gt;path&lt;/code&gt; to requested CVSROOT</source>
          <target state="translated">前面加上 &lt;code&gt;path&lt;/code&gt; 来要求CVSROOT</target>
        </trans-unit>
        <trans-unit id="0347b26685846c1b1d2b4efcd87239056762e453" translate="yes" xml:space="preserve">
          <source>Prepend an additional prefix to every line of output.</source>
          <target state="translated">在每一行输出前加上一个额外的前缀。</target>
        </trans-unit>
        <trans-unit id="965630002ec8181b6c5811ecd432fedf5278178d" translate="yes" xml:space="preserve">
          <source>Prepend comment character and blank to each line. Lines will automatically be terminated with a newline. On empty lines, only the comment character will be prepended.</source>
          <target state="translated">在每行前加上注释字符和空白。行将自动以换行结束。在空行中,只有注释字符会被预置。</target>
        </trans-unit>
        <trans-unit id="f16c17f5481a4b7eaab0eba6f32fe3b9bdb77e0a" translate="yes" xml:space="preserve">
          <source>Prepend the commit message with the provided prefix. Useful for patch series and the like.</source>
          <target state="translated">在提交信息前加上前缀。对补丁系列等有用。</target>
        </trans-unit>
        <trans-unit id="1cb847e80ec2973659a3bc43c24ba721cccfc0b9" translate="yes" xml:space="preserve">
          <source>Pretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line. An alternate repository is any repository whose object directory is specified in &lt;code&gt;objects/info/alternates&lt;/code&gt;. The set of included objects may be modified by &lt;code&gt;core.alternateRefsCommand&lt;/code&gt;, etc. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">假装好像在命令行上列出了所有作为备用存储库的引用提示的对象。备用存储库是对象目录在 &lt;code&gt;objects/info/alternates&lt;/code&gt; 中指定的任何存储库。可以通过 &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; 等修改包含的对象集。请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8790db7464ad43dc2580493a3a2b7fe9009b3b8" translate="yes" xml:space="preserve">
          <source>Pretend as if all objects mentioned by reflogs are listed on the command line as &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">假装reflog提及的所有对象在命令行上均以 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 列出。</target>
        </trans-unit>
        <trans-unit id="1bc40db9cd0077507e159c30d2cc8ff273e4cf52" translate="yes" xml:space="preserve">
          <source>Pretend as if all the branches (tags, remote branches, resp.) are listed on the command line as &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; is given, limit refs to ones matching given shell glob. If pattern lacks &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;/*&lt;/code&gt; at the end is implied.</source>
          <target state="translated">假设所有分支（标记，远程分支或相应）在命令行上均以 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 列出。如果给出了 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; ，则将引用限制为与给定的shell glob匹配的引用。如果缺乏模式 &lt;code&gt;?&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ，或 &lt;code&gt;[&lt;/code&gt; ， &lt;code&gt;/*&lt;/code&gt; 在最后是隐含的。</target>
        </trans-unit>
        <trans-unit id="a40d3b9ce3a70471c04394220cc5bbfab2baa7f5" translate="yes" xml:space="preserve">
          <source>Pretend as if all the refs in &lt;code&gt;refs/&lt;/code&gt;, along with &lt;code&gt;HEAD&lt;/code&gt;, are listed on the command line as &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">假设 &lt;code&gt;refs/&lt;/code&gt; 所有ref 以及 &lt;code&gt;HEAD&lt;/code&gt; 都在命令行中列为 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1435ebeededb24db5ecef4374cafc152c655d0c5" translate="yes" xml:space="preserve">
          <source>Pretend as if all the refs in &lt;code&gt;refs/heads&lt;/code&gt; are listed on the command line as &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; is given, limit branches to ones matching given shell glob. If pattern lacks &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;/*&lt;/code&gt; at the end is implied.</source>
          <target state="translated">假设好像 &lt;code&gt;refs/heads&lt;/code&gt; 中的所有refs在命令行上都列为 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 。如果给出了 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; ，则将分支限制为与给定的shell glob匹配的分支。如果缺乏模式 &lt;code&gt;?&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ，或 &lt;code&gt;[&lt;/code&gt; ， &lt;code&gt;/*&lt;/code&gt; 在最后是隐含的。</target>
        </trans-unit>
        <trans-unit id="873bc395593997376453ce378c315180f9e8037d" translate="yes" xml:space="preserve">
          <source>Pretend as if all the refs in &lt;code&gt;refs/remotes&lt;/code&gt; are listed on the command line as &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; is given, limit remote-tracking branches to ones matching given shell glob. If pattern lacks &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;/*&lt;/code&gt; at the end is implied.</source>
          <target state="translated">假设好像 &lt;code&gt;refs/remotes&lt;/code&gt; 中的所有ref在命令行上都以 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 的形式列出。如果给出了 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; ，则将远程跟踪分支限制为与给定的shell glob匹配的分支。如果缺乏模式 &lt;code&gt;?&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ，或 &lt;code&gt;[&lt;/code&gt; ， &lt;code&gt;/*&lt;/code&gt; 在最后是隐含的。</target>
        </trans-unit>
        <trans-unit id="779811bec709e50bc3c2986dda8163a1984c59e0" translate="yes" xml:space="preserve">
          <source>Pretend as if all the refs in &lt;code&gt;refs/tags&lt;/code&gt; are listed on the command line as &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; is given, limit tags to ones matching given shell glob. If pattern lacks &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;/*&lt;/code&gt; at the end is implied.</source>
          <target state="translated">假设好像 &lt;code&gt;refs/tags&lt;/code&gt; 中的所有refs在命令行上都列为 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 。如果给出了 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; ，则将标签限制为与给定的shell glob匹配的标签。如果缺乏模式 &lt;code&gt;?&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ，或 &lt;code&gt;[&lt;/code&gt; ， &lt;code&gt;/*&lt;/code&gt; 在最后是隐含的。</target>
        </trans-unit>
        <trans-unit id="fd8bdbdeb72b98a3e7d8a71774e4228e25fd4361" translate="yes" xml:space="preserve">
          <source>Pretend as if all the refs matching shell glob &lt;code&gt;&amp;lt;glob-pattern&amp;gt;&lt;/code&gt; are listed on the command line as &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. Leading &lt;code&gt;refs/&lt;/code&gt;, is automatically prepended if missing. If pattern lacks &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;/*&lt;/code&gt; at the end is implied.</source>
          <target state="translated">假设所有与shell glob &lt;code&gt;&amp;lt;glob-pattern&amp;gt;&lt;/code&gt; 匹配的参考都在命令行上列为 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 。如果缺少前导 &lt;code&gt;refs/&lt;/code&gt; ，则会自动添加。如果缺乏模式 &lt;code&gt;?&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ，或 &lt;code&gt;[&lt;/code&gt; ， &lt;code&gt;/*&lt;/code&gt; 在最后是隐含的。</target>
        </trans-unit>
        <trans-unit id="46b1cc7966c168f121c45715956556d8413ae7ad" translate="yes" xml:space="preserve">
          <source>Pretend as if all trees and blobs used by the index are listed on the command line. Note that you probably want to use &lt;code&gt;--objects&lt;/code&gt;, too.</source>
          <target state="translated">假设该索引使用的所有树和斑点都在命令行中列出。请注意，您可能也想使用 &lt;code&gt;--objects&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc70d02297620c66f8bef755f564908a1a4698d8" translate="yes" xml:space="preserve">
          <source>Pretend as if the bad bisection ref &lt;code&gt;refs/bisect/bad&lt;/code&gt; was listed and as if it was followed by &lt;code&gt;--not&lt;/code&gt; and the good bisection refs &lt;code&gt;refs/bisect/good-*&lt;/code&gt; on the command line. Cannot be combined with --first-parent.</source>
          <target state="translated">假装好像列出了错误的二等分引用 &lt;code&gt;refs/bisect/bad&lt;/code&gt; ，并且好像在命令行后是 &lt;code&gt;--not&lt;/code&gt; 以及好的两等分引用 &lt;code&gt;refs/bisect/good-*&lt;/code&gt; 。不能与--first-parent组合使用。</target>
        </trans-unit>
        <trans-unit id="0a3604cb0b2f73cd8456355c098a4f83f14d6060" translate="yes" xml:space="preserve">
          <source>Pretty formats</source>
          <target state="translated">漂亮的格式</target>
        </trans-unit>
        <trans-unit id="1b76ed128a23a5286f4a7e2538cc00e5737e0416" translate="yes" xml:space="preserve">
          <source>Pretty-print the contents of &amp;lt;object&amp;gt; based on its type.</source>
          <target state="translated">根据其类型漂亮打印&amp;lt;object&amp;gt;的内容。</target>
        </trans-unit>
        <trans-unit id="a741501b13f29bc4f4975a183857a345cfe33bda" translate="yes" xml:space="preserve">
          <source>Pretty-print the contents of the commit logs in a given format, where &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can be one of &lt;code&gt;oneline&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;, &lt;code&gt;fuller&lt;/code&gt;, &lt;code&gt;reference&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; and &lt;code&gt;tformat:&amp;lt;string&amp;gt;&lt;/code&gt;. When &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; is none of the above, and has &lt;code&gt;%placeholder&lt;/code&gt; in it, it acts as if &lt;code&gt;--pretty=tformat:&amp;lt;format&amp;gt;&lt;/code&gt; were given.</source>
          <target state="translated">以给定格式漂亮地打印提交日志的内容，其中 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 可以是 &lt;code&gt;oneline&lt;/code&gt; ， &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;medium&lt;/code&gt; ， &lt;code&gt;full&lt;/code&gt; ， &lt;code&gt;fuller&lt;/code&gt; ， &lt;code&gt;reference&lt;/code&gt; ， &lt;code&gt;email&lt;/code&gt; ， &lt;code&gt;raw&lt;/code&gt; ， &lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; 和 &lt;code&gt;tformat:&amp;lt;string&amp;gt;&lt;/code&gt; 之一。如果 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 都不是上述内容，并且其中包含 &lt;code&gt;%placeholder&lt;/code&gt; ，则它的作用就像 &lt;code&gt;--pretty=tformat:&amp;lt;format&amp;gt;&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="7bd89feebefa381d47a4005ee3e7a70495146fc2" translate="yes" xml:space="preserve">
          <source>Print a list of diff tools that may be used with &lt;code&gt;--tool&lt;/code&gt;.</source>
          <target state="translated">打印可以与 &lt;code&gt;--tool&lt;/code&gt; 一起使用的差异工具列表。</target>
        </trans-unit>
        <trans-unit id="4427ae28c9b6c7b34bdd7b24aed9e7c7d30f57b8" translate="yes" xml:space="preserve">
          <source>Print a list of merge tools that may be used with &lt;code&gt;--tool&lt;/code&gt;.</source>
          <target state="translated">打印可以与 &lt;code&gt;--tool&lt;/code&gt; 一起使用的合并工具的列表。</target>
        </trans-unit>
        <trans-unit id="66756bdfb6c604999780ed06815c6e483a2bcdd8" translate="yes" xml:space="preserve">
          <source>Print a log message describing a merge of the &quot;master&quot; branch from the &quot;origin&quot; remote.</source>
          <target state="translated">打印描述从远程 &quot;origin &quot;分支合并到 &quot;master &quot;分支的日志信息。</target>
        </trans-unit>
        <trans-unit id="e170a2249107ead5e4f805939d3f7ece45fff682" translate="yes" xml:space="preserve">
          <source>Print a message to the terminal whenever Git is waiting for editor input from the user.</source>
          <target state="translated">每当 Git 等待用户输入时,都会向终端打印一条信息。</target>
        </trans-unit>
        <trans-unit id="8080962c8d32b2cabab8eb19868e6e497af4f4fb" translate="yes" xml:space="preserve">
          <source>Print a number stating how many commits would have been listed, and suppress all other output. When used together with &lt;code&gt;--left-right&lt;/code&gt;, instead print the counts for left and right commits, separated by a tab. When used together with &lt;code&gt;--cherry-mark&lt;/code&gt;, omit patch equivalent commits from these counts and print the count for equivalent commits separated by a tab.</source>
          <target state="translated">打印一个数字，说明将列出多少个提交，并取消所有其他输出。与 &lt;code&gt;--left-right&lt;/code&gt; 一起使用时，请打印左右提交的计数，并用制表符分隔。与 &lt;code&gt;--cherry-mark&lt;/code&gt; 一起使用时，从这些计数中忽略补丁等效提交，并打印由制表符分隔的等效提交计数。</target>
        </trans-unit>
        <trans-unit id="5c8fe4e870e195a4e0e71c8a37d1ceb1bdba9faa" translate="yes" xml:space="preserve">
          <source>Print a short usage message and exit.</source>
          <target state="translated">打印简短的使用信息并退出。</target>
        </trans-unit>
        <trans-unit id="1605c83b597410df01a57b6af3b5c08c7935c987" translate="yes" xml:space="preserve">
          <source>Print all commits to the standard output in mbox format, instead of creating a file for each one.</source>
          <target state="translated">将所有提交打印成mbox格式的标准输出,而不是为每个提交创建一个文件。</target>
        </trans-unit>
        <trans-unit id="bb80930a87afbf3e0cd1b6dbc46ac66a79700ef9" translate="yes" xml:space="preserve">
          <source>Print also the children of the commit (in the form &quot;commit child&amp;hellip;​&quot;). Also enables parent rewriting, see &lt;code&gt;History Simplification&lt;/code&gt; above.</source>
          <target state="translated">还打印提交的子项（格式为&amp;ldquo;提交子项&amp;hellip;&amp;hellip;&amp;rdquo;）。还可以启用父级重写，请参见上面的&amp;ldquo; &lt;code&gt;History Simplification&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd486c8f7fa4f0862a9438df255d9ef58e4cce2f" translate="yes" xml:space="preserve">
          <source>Print also the parents of the commit (in the form &quot;commit parent&amp;hellip;​&quot;). Also enables parent rewriting, see &lt;code&gt;History Simplification&lt;/code&gt; above.</source>
          <target state="translated">还要打印提交的父母（以&amp;ldquo;提交父母&amp;hellip;&amp;hellip;&amp;rdquo;的形式）。还可以启用父级重写，请参见上面的&amp;ldquo; &lt;code&gt;History Simplification&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f770a9ba11cec50c667f92df6a9581699d1c849f" translate="yes" xml:space="preserve">
          <source>Print an empty line between matches from different files.</source>
          <target state="translated">在不同文件的匹配之间打印空行。</target>
        </trans-unit>
        <trans-unit id="dc6bbcf836701f45b1b031bc09ccba6ceff978b1" translate="yes" xml:space="preserve">
          <source>Print extra information on screen.</source>
          <target state="translated">在屏幕上打印额外信息。</target>
        </trans-unit>
        <trans-unit id="f77fc6854808124fa4634165848ea2138881c54f" translate="yes" xml:space="preserve">
          <source>Print lines matching a pattern</source>
          <target state="translated">打印符合图案的线条</target>
        </trans-unit>
        <trans-unit id="6fe4856d75dfab579fe9349a68cc2bed1d0dadcc" translate="yes" xml:space="preserve">
          <source>Print object information and contents for each object provided on stdin. May not be combined with any other options or arguments except &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt;, in which case the input lines also need to specify the path, separated by whitespace. See the section &lt;code&gt;BATCH OUTPUT&lt;/code&gt; below for details.</source>
          <target state="translated">打印stdin提供的每个对象的对象信息和内容。不得与 &lt;code&gt;--textconv&lt;/code&gt; 或 &lt;code&gt;--filters&lt;/code&gt; 以外的其他任何选项或参数组合使用，在这种情况下，输入行还需要指定路径，并用空格分隔。有关详细信息，请参见下面的 &lt;code&gt;BATCH OUTPUT&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="ca4d7c5adc217a6aa2342c6778492ad7113796ff" translate="yes" xml:space="preserve">
          <source>Print object information for each object provided on stdin. May not be combined with any other options or arguments except &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt;, in which case the input lines also need to specify the path, separated by whitespace. See the section &lt;code&gt;BATCH OUTPUT&lt;/code&gt; below for details.</source>
          <target state="translated">打印标准输入上提供的每个对象的对象信息。不得与 &lt;code&gt;--textconv&lt;/code&gt; 或 &lt;code&gt;--filters&lt;/code&gt; 以外的其他任何选项或参数组合使用，在这种情况下，输入行还需要指定路径，并用空格分隔。有关详细信息，请参见下面的 &lt;code&gt;BATCH OUTPUT&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="355c9197a67577b10c87d266b1fadda4f338ce43" translate="yes" xml:space="preserve">
          <source>Print objects that exist but that are never &lt;code&gt;directly&lt;/code&gt; used (default). &lt;code&gt;--no-dangling&lt;/code&gt; can be used to omit this information from the output.</source>
          <target state="translated">打印存在但从未 &lt;code&gt;directly&lt;/code&gt; 使用的对象（默认）。 &lt;code&gt;--no-dangling&lt;/code&gt; 可用于从输出中忽略此信息。</target>
        </trans-unit>
        <trans-unit id="2b45348ee53d58a25f5424ead463a255068c26a3" translate="yes" xml:space="preserve">
          <source>Print only merge commits. This is exactly the same as &lt;code&gt;--min-parents=2&lt;/code&gt;.</source>
          <target state="translated">仅打印合并提交。这与 &lt;code&gt;--min-parents=2&lt;/code&gt; 完全相同。</target>
        </trans-unit>
        <trans-unit id="fba7bfcdde0d986db48ca498619d9372ecc7d2c2" translate="yes" xml:space="preserve">
          <source>Print only the matched (non-empty) parts of a matching line, with each such part on a separate output line.</source>
          <target state="translated">只打印匹配行的匹配(非空)部分,每一个这样的部分都在一个单独的输出行上。</target>
        </trans-unit>
        <trans-unit id="a0fc3f1d0d97da65e736eae410fad9ae12d5c7be" translate="yes" xml:space="preserve">
          <source>Print out objects that exist but that aren&amp;rsquo;t reachable from any of the reference nodes.</source>
          <target state="translated">打印出存在但无法从任何参考节点访问的对象。</target>
        </trans-unit>
        <trans-unit id="e099bc42258fcb131e0b9e1b48df8c89349bb7b8" translate="yes" xml:space="preserve">
          <source>Print out the ref name given on the command line by which each commit was reached.</source>
          <target state="translated">打印出命令行中给出的每次提交的参考名称。</target>
        </trans-unit>
        <trans-unit id="dcb3dcb3ba78d15754773caa5f744c3c4effdf42" translate="yes" xml:space="preserve">
          <source>Print out the ref names of any commits that are shown by the log command. If &lt;code&gt;short&lt;/code&gt; is specified, the ref name prefixes &lt;code&gt;refs/heads/&lt;/code&gt;, &lt;code&gt;refs/tags/&lt;/code&gt; and &lt;code&gt;refs/remotes/&lt;/code&gt; will not be printed. If &lt;code&gt;full&lt;/code&gt; is specified, the full ref name (including prefix) will be printed. If &lt;code&gt;auto&lt;/code&gt; is specified, then if the output is going to a terminal, the ref names are shown as if &lt;code&gt;short&lt;/code&gt; were given, otherwise no ref names are shown. This is the same as the &lt;code&gt;--decorate&lt;/code&gt; option of the &lt;code&gt;git log&lt;/code&gt;.</source>
          <target state="translated">打印出log命令显示的所有提交的引用名称。如果指定了 &lt;code&gt;short&lt;/code&gt; ，则不会打印ref名称前缀 &lt;code&gt;refs/heads/&lt;/code&gt; ， &lt;code&gt;refs/tags/&lt;/code&gt; 和 &lt;code&gt;refs/remotes/&lt;/code&gt; 。如果 &lt;code&gt;full&lt;/code&gt; 被指定时，完整的裁判名（包括前缀）将被打印。如果指定了 &lt;code&gt;auto&lt;/code&gt; ，则如果输出将输出到终端，则引用名称显示为好像给出了 &lt;code&gt;short&lt;/code&gt; ，否则不显示引用名称。这与 &lt;code&gt;git log&lt;/code&gt; 的 &lt;code&gt;--decorate&lt;/code&gt; 选项相同。</target>
        </trans-unit>
        <trans-unit id="53ce43f1821ebff917f188f20f204c3e06f211d4" translate="yes" xml:space="preserve">
          <source>Print out the ref names of any commits that are shown. If &lt;code&gt;short&lt;/code&gt; is specified, the ref name prefixes &lt;code&gt;refs/heads/&lt;/code&gt;, &lt;code&gt;refs/tags/&lt;/code&gt; and &lt;code&gt;refs/remotes/&lt;/code&gt; will not be printed. If &lt;code&gt;full&lt;/code&gt; is specified, the full ref name (including prefix) will be printed. If &lt;code&gt;auto&lt;/code&gt; is specified, then if the output is going to a terminal, the ref names are shown as if &lt;code&gt;short&lt;/code&gt; were given, otherwise no ref names are shown. The default option is &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">打印显示的所有提交的引用名称。如果指定了 &lt;code&gt;short&lt;/code&gt; ，则不会打印ref名称前缀 &lt;code&gt;refs/heads/&lt;/code&gt; ， &lt;code&gt;refs/tags/&lt;/code&gt; 和 &lt;code&gt;refs/remotes/&lt;/code&gt; 。如果 &lt;code&gt;full&lt;/code&gt; 被指定时，完整的裁判名（包括前缀）将被打印。如果指定了 &lt;code&gt;auto&lt;/code&gt; ，则如果输出将输出到终端，则引用名称显示为好像给出了 &lt;code&gt;short&lt;/code&gt; ，否则不显示引用名称。默认选项是 &lt;code&gt;short&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2011b0d7f946e8a76de0461151323ce8a5c0f935" translate="yes" xml:space="preserve">
          <source>Print paths with conflicts that have not been autoresolved by rerere. This includes paths whose resolutions cannot be tracked by rerere, such as conflicting submodules.</source>
          <target state="translated">打印未被 rerere 自动解决冲突的路径。这包括那些无法通过 rerere 跟踪解决的路径,例如冲突的子模块。</target>
        </trans-unit>
        <trans-unit id="2cba919653a32310570084639bfa9ccc09fb9fa2" translate="yes" xml:space="preserve">
          <source>Print paths with conflicts whose merge resolution rerere will record.</source>
          <target state="translated">打印有冲突的路径,合并后的解决方法rerere会记录下来。</target>
        </trans-unit>
        <trans-unit id="71b60883716e5c9ed5e8d89999bad00a8a7a60a2" translate="yes" xml:space="preserve">
          <source>Print sizes in human readable format</source>
          <target state="translated">以人类可读格式打印的尺寸</target>
        </trans-unit>
        <trans-unit id="7acdcc1d8a4a904a279ce2f15ace2f46f09a0e30" translate="yes" xml:space="preserve">
          <source>Print the commit object name from the revision in the $REV shell variable:</source>
          <target state="translated">打印$REV shell变量中修订版的提交对象名称。</target>
        </trans-unit>
        <trans-unit id="395b30ff424b495b247b1df9486e5529542c8ab4" translate="yes" xml:space="preserve">
          <source>Print the contents of the commit in raw-format; each record is separated with a NUL character.</source>
          <target state="translated">以原始格式打印提交的内容,每条记录用NUL字符分隔。</target>
        </trans-unit>
        <trans-unit id="a77cbdea967e7bc1835e082ef3a9add5606ab710" translate="yes" xml:space="preserve">
          <source>Print the contents of the commit object before validating it.</source>
          <target state="translated">在验证之前,打印提交对象的内容。</target>
        </trans-unit>
        <trans-unit id="31d513cdd4715b4e34b1efb48c41837ed2726bf9" translate="yes" xml:space="preserve">
          <source>Print the contents of the tag object before validating it.</source>
          <target state="translated">打印标签对象的内容,然后再验证它。</target>
        </trans-unit>
        <trans-unit id="87753483ea6cbbd041325490c8537b3b3cada35c" translate="yes" xml:space="preserve">
          <source>Print the current notes ref. This provides an easy way to retrieve the current notes ref (e.g. from scripts).</source>
          <target state="translated">打印当前笔记参考。这提供了一个简单的方法来检索当前的笔记参考(例如,从脚本中)。</target>
        </trans-unit>
        <trans-unit id="e336397774a866fc04e04e67418c962536311ce3" translate="yes" xml:space="preserve">
          <source>Print the manpath (see &lt;code&gt;man(1)&lt;/code&gt;) for the man pages for this version of Git and exit.</source>
          <target state="translated">为该版本的Git的手册页打印manpath（请参阅 &lt;code&gt;man(1)&lt;/code&gt; ），然后退出。</target>
        </trans-unit>
        <trans-unit id="390fcf6665394474a4208236397a723ae5bbd841" translate="yes" xml:space="preserve">
          <source>Print the name of the current branch. In detached HEAD state, nothing is printed.</source>
          <target state="translated">打印当前分支的名称。在分离的HEAD状态下,不打印任何内容。</target>
        </trans-unit>
        <trans-unit id="727d2c972108087f617ca9a52e1404312cb08db7" translate="yes" xml:space="preserve">
          <source>Print the name of the previous thing checked out:</source>
          <target state="translated">打印前一个东西的名字签出。</target>
        </trans-unit>
        <trans-unit id="3642aa2b7cf9b2dae48578e1bdc6f3fea172cd09" translate="yes" xml:space="preserve">
          <source>Print the object IDs of any object referenced by the listed commits. &lt;code&gt;--objects foo ^bar&lt;/code&gt; thus means &amp;ldquo;send me all object IDs which I need to download if I have the commit object &lt;code&gt;bar&lt;/code&gt; but not &lt;code&gt;foo&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">打印列出的提交引用的任何对象的对象ID。 &lt;code&gt;--objects foo ^bar&lt;/code&gt; 意思是&amp;ldquo;如果有提交对象 &lt;code&gt;bar&lt;/code&gt; 但没有 &lt;code&gt;foo&lt;/code&gt; ,请发送所有我需要下载的对象ID &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="38fa474c9535276a4f6e33490b7ff8dcbbdc81f4" translate="yes" xml:space="preserve">
          <source>Print the object name of the current commit:</source>
          <target state="translated">打印当前提交的对象名称。</target>
        </trans-unit>
        <trans-unit id="ee021a7e92899d06aae374f43dcf779c8609f3ff" translate="yes" xml:space="preserve">
          <source>Print the path where the Info files documenting this version of Git are installed and exit.</source>
          <target state="translated">打印记录此版本 Git 的信息文件的安装路径,然后退出。</target>
        </trans-unit>
        <trans-unit id="f91d6d93e8468421a09b4a14a734bbd616d1eaec" translate="yes" xml:space="preserve">
          <source>Print the path, without trailing slash, where Git&amp;rsquo;s HTML documentation is installed and exit.</source>
          <target state="translated">打印安装Git的HTML文档并退出的路径，不带斜线。</target>
        </trans-unit>
        <trans-unit id="c416409aca85a3200dcaeb96638cdf0bb7fd9f1e" translate="yes" xml:space="preserve">
          <source>Print the raw commit timestamp.</source>
          <target state="translated">打印原始提交时间戳。</target>
        </trans-unit>
        <trans-unit id="a639de23ccd7b17d5228ed28b0950d8dd10397fd" translate="yes" xml:space="preserve">
          <source>Print the raw gpg status output to standard error instead of the normal human-readable output.</source>
          <target state="translated">将原始 gpg 状态输出打印为标准错误,而不是正常的人类可读输出。</target>
        </trans-unit>
        <trans-unit id="99ac22b00f0c79de0ff529dde835b6047cf02100" translate="yes" xml:space="preserve">
          <source>Print tree and blob ids in order of the commits. The tree and blob ids are printed after they are first referenced by a commit.</source>
          <target state="translated">按照提交的顺序打印树和blob的id。树和blob的id在提交后才被打印。</target>
        </trans-unit>
        <trans-unit id="3b22396fd69e4727d40157cf2f987d6e09d1fcff" translate="yes" xml:space="preserve">
          <source>Print usage information and exit</source>
          <target state="translated">打印使用信息并退出</target>
        </trans-unit>
        <trans-unit id="8b0271d848c59df8398c3108bdeba41e38e8636a" translate="yes" xml:space="preserve">
          <source>Print version information and exit</source>
          <target state="translated">打印版本信息并退出</target>
        </trans-unit>
        <trans-unit id="85ec1b3fb97897b6ced8a489e132839db30e011a" translate="yes" xml:space="preserve">
          <source>Prints a Git logical variable.</source>
          <target state="translated">打印 Git 的逻辑变量。</target>
        </trans-unit>
        <trans-unit id="401d02aaba20f08ba2e39483d254996af7aae137" translate="yes" xml:space="preserve">
          <source>Prints a list of useful guides on the standard output. This option overrides any given command or guide name.</source>
          <target state="translated">在标准输出上打印有用的指南列表。此选项可覆盖任何给定的命令或指南名称。</target>
        </trans-unit>
        <trans-unit id="fb51737d6bf1a9b6afa9ffc69b82cbde8918bef7" translate="yes" xml:space="preserve">
          <source>Prints all the available commands on the standard output. This option overrides any given command or guide name.</source>
          <target state="translated">在标准输出上打印所有可用的命令。此选项可覆盖任何给定的命令或指南名称。</target>
        </trans-unit>
        <trans-unit id="f5aac771b999435096d722ba3e59e6103d7d4c50" translate="yes" xml:space="preserve">
          <source>Prints information about the object at a path to a file descriptor previously arranged with the &lt;code&gt;--cat-blob-fd&lt;/code&gt; argument. This allows printing a blob from the active commit (with &lt;code&gt;cat-blob&lt;/code&gt;) or copying a blob or tree from a previous commit for use in the current one (with &lt;code&gt;filemodify&lt;/code&gt;).</source>
          <target state="translated">在先前使用 &lt;code&gt;--cat-blob-fd&lt;/code&gt; 参数排列的文件描述符的路径上打印有关对象的信息。这允许从活动提交中打印blob（使用 &lt;code&gt;cat-blob&lt;/code&gt; ），或者从先前提交中复制blob或树以用于当前提交（使用 &lt;code&gt;filemodify&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="67f72d83deebf87ad84204db25d15bef66391fa1" translate="yes" xml:space="preserve">
          <source>Prints the Git suite version that the &lt;code&gt;git&lt;/code&gt; program came from.</source>
          <target state="translated">打印 &lt;code&gt;git&lt;/code&gt; 程序来自的Git套件版本。</target>
        </trans-unit>
        <trans-unit id="31cffb4ffe2a30a3dd8ff5b977f393cbba618dfd" translate="yes" xml:space="preserve">
          <source>Prints the synopsis and a list of the most commonly used commands. If the option &lt;code&gt;--all&lt;/code&gt; or &lt;code&gt;-a&lt;/code&gt; is given then all available commands are printed. If a Git command is named this option will bring up the manual page for that command.</source>
          <target state="translated">打印概要和最常用命令的列表。如果给出 &lt;code&gt;--all&lt;/code&gt; 或 &lt;code&gt;-a&lt;/code&gt; 选项，则将打印所有可用命令。如果命名为Git命令，则此选项将调出该命令的手册页。</target>
        </trans-unit>
        <trans-unit id="866254572e1e21a744b0d521a136d91326c823cd" translate="yes" xml:space="preserve">
          <source>Problems related to branches:</source>
          <target state="translated">与分支机构有关的问题。</target>
        </trans-unit>
        <trans-unit id="ca677c6e0873752e051f5b6dc5cfbc5f3713a96f" translate="yes" xml:space="preserve">
          <source>Problems related to tags:</source>
          <target state="translated">与标签有关的问题。</target>
        </trans-unit>
        <trans-unit id="704eb4f9500e5abbbd40e21ecae0dbc6632f17d7" translate="yes" xml:space="preserve">
          <source>Problems related to timestamps:</source>
          <target state="translated">与时间戳有关的问题。</target>
        </trans-unit>
        <trans-unit id="face2a8f1265d0d2162b3bb8d6cc8c2e4f00bd1a" translate="yes" xml:space="preserve">
          <source>Problems with rewriting history</source>
          <target state="translated">重写历史的问题</target>
        </trans-unit>
        <trans-unit id="cb8ad1a0606d68ac22c37138a82e9dcd94bd7b47" translate="yes" xml:space="preserve">
          <source>Proceed even if the index or the working tree differs from &lt;code&gt;HEAD&lt;/code&gt;. Both the index and working tree are restored to match the switching target. If &lt;code&gt;--recurse-submodules&lt;/code&gt; is specified, submodule content is also restored to match the switching target. This is used to throw away local changes.</source>
          <target state="translated">即使索引或工作树不同于 &lt;code&gt;HEAD&lt;/code&gt; ,也继续进行。索引和工作树都将还原以匹配切换目标。如果指定了 &lt;code&gt;--recurse-submodules&lt;/code&gt; ，则还将还原子模块内容以匹配切换目标。这用于丢弃本地更改。</target>
        </trans-unit>
        <trans-unit id="81635a56ae860db0a8d1fccf460faed330395977" translate="yes" xml:space="preserve">
          <source>Process binary files as if they were text.</source>
          <target state="translated">把二进制文件当作文本处理。</target>
        </trans-unit>
        <trans-unit id="c13073a8e5c76f53a6790b53a64799c267eda4e9" translate="yes" xml:space="preserve">
          <source>Process files in the order specified in the &amp;lt;orderfile&amp;gt;, which has one shell glob pattern per line. This overrides the &lt;code&gt;diff.orderFile&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). To cancel &lt;code&gt;diff.orderFile&lt;/code&gt;, use &lt;code&gt;-O/dev/null&lt;/code&gt;.</source>
          <target state="translated">按照&amp;lt;orderfile&amp;gt;中指定的顺序处理文件，该命令每行具有一个Shell Glob模式。这将覆盖 &lt;code&gt;diff.orderFile&lt;/code&gt; 配置变量（请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。要取消 &lt;code&gt;diff.orderFile&lt;/code&gt; ，请使用 &lt;code&gt;-O/dev/null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efe0d70966f95f77c3e86b43812298f2ec9b000a" translate="yes" xml:space="preserve">
          <source>Process the reflogs of all references.</source>
          <target state="translated">处理所有参考资料的重新登录。</target>
        </trans-unit>
        <trans-unit id="0782c5b7801790281dc0fb4b01651b8bfdcbc4f5" translate="yes" xml:space="preserve">
          <source>Processes all packs. Any filenames on the command line are ignored.</source>
          <target state="translated">处理所有的包。命令行中的任何文件名都将被忽略。</target>
        </trans-unit>
        <trans-unit id="3c46a3f16a2a32b7eba71a8379b8360472d65d8d" translate="yes" xml:space="preserve">
          <source>Processes the specified option so that git fast-import behaves in a way that suits the frontend&amp;rsquo;s needs. Note that options specified by the frontend are overridden by any options the user may specify to git fast-import itself.</source>
          <target state="translated">处理指定的选项，以便git fast-import表现为适合前端需求的方式。请注意，前端指定的选项会被用户为git fast-import本身指定的任何选项所覆盖。</target>
        </trans-unit>
        <trans-unit id="2de3013c8cd324e1d7d27384810d30bdbff48678" translate="yes" xml:space="preserve">
          <source>Produce a merge commit message</source>
          <target state="translated">生成合并提交信息</target>
        </trans-unit>
        <trans-unit id="221bd606329bfae672e0ecc9594988658e144e37" translate="yes" xml:space="preserve">
          <source>Produce machine-readable output. The output status line for each ref will be tab-separated and sent to stdout instead of stderr. The full symbolic names of the refs will be given.</source>
          <target state="translated">生成机器可读的输出。每个 refs 的输出状态行将以 tab 分隔,并发送至 stdout 而不是 stderr。参考文献的完整符号名称将被给出。</target>
        </trans-unit>
        <trans-unit id="fa20429458d99d060783732e4d2e8bf497560d29" translate="yes" xml:space="preserve">
          <source>Produce output in the same format as &lt;code&gt;git blame&lt;/code&gt;, but with SVN revision numbers instead of Git commit hashes. In this mode, changes that haven&amp;rsquo;t been committed to SVN (including local working-copy edits) are shown as revision 0.</source>
          <target state="translated">产生与 &lt;code&gt;git blame&lt;/code&gt; 相同的格式的输出，但使用SVN版本号而不是Git提交哈希。在此模式下，尚未提交给SVN的更改（包括本地工作副本编辑）将显示为修订版0。</target>
        </trans-unit>
        <trans-unit id="cb195c53f13c5c90951762ba09047296d46995e9" translate="yes" xml:space="preserve">
          <source>Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the &lt;code&gt;HEAD&lt;/code&gt;, or record &lt;code&gt;$GIT_DIR/MERGE_HEAD&lt;/code&gt; (to cause the next &lt;code&gt;git commit&lt;/code&gt; command to create a merge commit). This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus).</source>
          <target state="translated">产生工作树和索引状态，就像发生真正的合并一样（合并信息除外），但实际上不进行提交，移动 &lt;code&gt;HEAD&lt;/code&gt; 或记录 &lt;code&gt;$GIT_DIR/MERGE_HEAD&lt;/code&gt; （以使下一个 &lt;code&gt;git commit&lt;/code&gt; 命令创建一个合并提交）。这使您可以在当前分支的顶部创建一个提交，其作用与合并另一个分支的作用相同（对于章鱼，则更多）。</target>
        </trans-unit>
        <trans-unit id="465a8ba2d1fbe9de5dbb0d6da6e9b4fc2bd5f63f" translate="yes" xml:space="preserve">
          <source>Produces a fast-import stream which imports the current value of the named ref. It may additionally import other refs as needed to construct the history efficiently. The script writes to a helper-specific private namespace. The value of the named ref should be written to a location in this namespace derived by applying the refspecs from the &quot;refspec&quot; capability to the name of the ref.</source>
          <target state="translated">产生一个快速导入流,导入命名的 ref 的当前值。它可以根据需要额外导入其他 refs,以有效地构建历史。脚本将写入一个特定于助记符的私有命名空间。命名的 ref 的值应该被写入这个命名空间中的一个位置,这个位置是通过将 &quot;refspec &quot;能力中的 refspecs 应用到 ref 的名字上而得到的。</target>
        </trans-unit>
        <trans-unit id="c940155095e7923b03e52693b949145b33288361" translate="yes" xml:space="preserve">
          <source>Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --no-progress or --verbose is specified. --progress forces progress status even if the standard error stream is not directed to a terminal.</source>
          <target state="translated">除非指定了 --no-progress 或 --verbose,否则当标准错误流连接到终端时,默认情况下,进度状态会在标准错误流上报告。即使标准错误流没有指向终端,--progress也会强制报告进度状态。</target>
        </trans-unit>
        <trans-unit id="2dcc9cf9e59b81f490159a20a52344236fd5a3dc" translate="yes" xml:space="preserve">
          <source>Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.</source>
          <target state="translated">除非指定了 -q,否则当标准错误流连接到终端时,默认情况下会在标准错误流上报告进度状态。即使标准错误流没有指向终端,该标志也会强制报告进度状态。</target>
        </trans-unit>
        <trans-unit id="e5cc82042c92eacaa55f040bd35ecdec7afbf1c3" translate="yes" xml:space="preserve">
          <source>Progress status is reported on the standard error stream by default when it is attached to a terminal, unless &lt;code&gt;--quiet&lt;/code&gt; is specified. This flag enables progress reporting even if not attached to a terminal, regardless of &lt;code&gt;--quiet&lt;/code&gt;.</source>
          <target state="translated">除非指定了 &lt;code&gt;--quiet&lt;/code&gt; ，否则默认情况下，将状态错误报告到标准错误流时，将在标准错误流上报告该状态。即使 &lt;code&gt;--quiet&lt;/code&gt; ，即使未连接到终端，此标志也可以启用进度报告。</target>
        </trans-unit>
        <trans-unit id="84082a3e9b3738ac2cad5de1d40208e556f0b5a9" translate="yes" xml:space="preserve">
          <source>Progress status is reported on the standard error stream by default when it is attached to a terminal, unless &lt;code&gt;--quiet&lt;/code&gt; is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.</source>
          <target state="translated">除非指定了 &lt;code&gt;--quiet&lt;/code&gt; ，否则默认情况下，将状态错误报告到标准错误流时，将在标准错误流上报告该状态。即使标准错误流未定向到终端，此标志也会强制显示进度状态。</target>
        </trans-unit>
        <trans-unit id="8942c3e281f4b4272bf2fa19690b7dbfeb0da954" translate="yes" xml:space="preserve">
          <source>Progress status is reported on the standard error stream by default when it is attached to a terminal. This flag enables progress reporting even if not attached to a terminal. Can&amp;rsquo;t use &lt;code&gt;--progress&lt;/code&gt; together with &lt;code&gt;--porcelain&lt;/code&gt; or &lt;code&gt;--incremental&lt;/code&gt;.</source>
          <target state="translated">默认情况下，进度状态在连接到终端时会在标准错误流上报告。即使未连接到终端，此标志也可以启用进度报告。不能将 &lt;code&gt;--progress&lt;/code&gt; 与 &lt;code&gt;--porcelain&lt;/code&gt; 或 &lt;code&gt;--incremental&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="a4a80ecee0b21f76717158fcc872d2fe8c9f70c9" translate="yes" xml:space="preserve">
          <source>Project list files should list one project per line, with each line having the following format</source>
          <target state="translated">项目列表文件每行应列出一个项目,每行的格式如下:1.</target>
        </trans-unit>
        <trans-unit id="64ddeaf66879746d77d52edba9fc6b51c3b5494f" translate="yes" xml:space="preserve">
          <source>Project specific override is not supported.</source>
          <target state="translated">不支持特定项目的覆盖。</target>
        </trans-unit>
        <trans-unit id="38cb6b6f38fc49666443f39245952417f433b632" translate="yes" xml:space="preserve">
          <source>Projects list file format</source>
          <target state="translated">项目清单文件格式</target>
        </trans-unit>
        <trans-unit id="99a6cf116ac91087c7f440f3f894b1353453be3c" translate="yes" xml:space="preserve">
          <source>Promisor packfiles are repacked separately: if there are packfiles that have an associated &quot;.promisor&quot; file, these packfiles will be repacked into another separate pack, and an empty &quot;.promisor&quot; file corresponding to the new separate pack will be written.</source>
          <target state="translated">承诺者包是单独重新打包的:如果有一些包有一个相关的&quot;.promonor &quot;文件,这些包将被重新打包到另一个单独的包中,并写入一个与新的单独包相对应的空&quot;.promonor &quot;文件。</target>
        </trans-unit>
        <trans-unit id="1e3e6d8a5678027c372d639c7caa1ae762739111" translate="yes" xml:space="preserve">
          <source>Prompt before each invocation of the diff tool.</source>
          <target state="translated">每次调用diff工具前都会有提示。</target>
        </trans-unit>
        <trans-unit id="011847e8f4535310d3585f3561b850f5eaa68bd2" translate="yes" xml:space="preserve">
          <source>Prompt before each invocation of the diff tool. This is the default behaviour; the option is provided to override any configuration settings.</source>
          <target state="translated">每次调用diff工具前都会有提示。这是默认行为;提供的选项可以覆盖任何配置设置。</target>
        </trans-unit>
        <trans-unit id="60f48217749656a50ce363c78d14fe3fba58b27e" translate="yes" xml:space="preserve">
          <source>Prompt before each invocation of the merge resolution program to give the user a chance to skip the path.</source>
          <target state="translated">在每次调用合并解析程序前提示,给用户一个跳过路径的机会。</target>
        </trans-unit>
        <trans-unit id="1bd1cfd1155b4114e14d09a7c37c4a191ca7ac30" translate="yes" xml:space="preserve">
          <source>Prompt before each invocation of the merge resolution program.</source>
          <target state="translated">每次调用合并解析程序前都会有提示。</target>
        </trans-unit>
        <trans-unit id="353a353b6eb50b67e795967c32fb24f9eeb5d549" translate="yes" xml:space="preserve">
          <source>Protocol notes: If you are using anonymous access via pserver, just select that. Those using SSH access should choose the &lt;code&gt;ext&lt;/code&gt; protocol, and configure &lt;code&gt;ext&lt;/code&gt; access on the Preferences&amp;rarr;Team&amp;rarr;CVS&amp;rarr;ExtConnection pane. Set CVS_SERVER to &quot;&lt;code&gt;git cvsserver&lt;/code&gt;&quot;. Note that password support is not good when using &lt;code&gt;ext&lt;/code&gt;, you will definitely want to have SSH keys setup.</source>
          <target state="translated">协议说明：如果您正在通过pserver使用匿名访问，则只需选择该选项即可。使用SSH访问的用户应选择 &lt;code&gt;ext&lt;/code&gt; 协议，然后在&amp;ldquo;首选项&amp;rdquo;&amp;rarr;&amp;ldquo;团队&amp;rdquo;&amp;rarr;&amp;ldquo; CVS&amp;rdquo;&amp;rarr;&amp;ldquo; ExtConnection&amp;rdquo;窗格上配置 &lt;code&gt;ext&lt;/code&gt; 访问。将CVS_SERVER设置为&amp;ldquo; &lt;code&gt;git cvsserver&lt;/code&gt; &amp;rdquo;。请注意，使用 &lt;code&gt;ext&lt;/code&gt; 时，密码支持不好，您肯定需要设置SSH密钥。</target>
        </trans-unit>
        <trans-unit id="4e8bf93a6f67bf7687593a7faf3fef64759fa4d3" translate="yes" xml:space="preserve">
          <source>Protocol version 2 is stateless by default. This means that all commands must only last a single round and be stateless from the perspective of the server side, unless the client has requested a capability indicating that state should be maintained by the server. Clients MUST NOT require state management on the server side in order to function correctly. This permits simple round-robin load-balancing on the server side, without needing to worry about state management.</source>
          <target state="translated">协议版本2默认是无状态的。这意味着所有的命令必须只持续一个回合,并且从服务器端的角度来看是无状态的,除非客户端请求了一个表明状态应该由服务器维护的能力。客户端必须不需要服务器端的状态管理才能正常运行。这就允许在服务器端进行简单的循环负载均衡,而不需要担心状态管理。</target>
        </trans-unit>
        <trans-unit id="a457f44dce93162338e37dcadcb5a7e148a161e8" translate="yes" xml:space="preserve">
          <source>Provide content or type and size information for repository objects</source>
          <target state="translated">为存储库对象提供内容或类型和大小信息。</target>
        </trans-unit>
        <trans-unit id="ce1130d2639274732ace3560e1b161a1f25e1593" translate="yes" xml:space="preserve">
          <source>Provide more progress information.</source>
          <target state="translated">提供更多的进展信息。</target>
        </trans-unit>
        <trans-unit id="ddd6c4f93ce8e6500d931f94e6b50cb8556ece89" translate="yes" xml:space="preserve">
          <source>Provides the default value for the &lt;code&gt;--from&lt;/code&gt; option to format-patch. Accepts a boolean value, or a name and email address. If false, format-patch defaults to &lt;code&gt;--no-from&lt;/code&gt;, using commit authors directly in the &quot;From:&quot; field of patch mails. If true, format-patch defaults to &lt;code&gt;--from&lt;/code&gt;, using your committer identity in the &quot;From:&quot; field of patch mails and including a &quot;From:&quot; field in the body of the patch mail if different. If set to a non-boolean value, format-patch uses that value instead of your committer identity. Defaults to false.</source>
          <target state="translated">提供 &lt;code&gt;--from&lt;/code&gt; 选项到format-patch 的默认值。接受布尔值或名称和电子邮件地址。如果为false，则format-patch默认为 &lt;code&gt;--no-from&lt;/code&gt; ，直接在补丁邮件的&amp;ldquo;发件人：&amp;rdquo;字段中使用提交作者。如果为true，则format-patch默认为 &lt;code&gt;--from&lt;/code&gt; ，使用补丁程序邮件的&amp;ldquo;发件人：&amp;rdquo;字段中的提交者身份，并在补丁程序邮件的正文中包括&amp;ldquo;发件人：&amp;rdquo;字段（如果不同）。如果设置为非布尔值，format-patch将使用该值而不是您的提交者身份。默认为false。</target>
        </trans-unit>
        <trans-unit id="07e705dc3eb04b1cd0e9d868ce2fbabc5a7b23e9" translate="yes" xml:space="preserve">
          <source>Provides the default value for the &lt;code&gt;--notes&lt;/code&gt; option to format-patch. Accepts a boolean value, or a ref which specifies where to get notes. If false, format-patch defaults to &lt;code&gt;--no-notes&lt;/code&gt;. If true, format-patch defaults to &lt;code&gt;--notes&lt;/code&gt;. If set to a non-boolean value, format-patch defaults to &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt;, where &lt;code&gt;ref&lt;/code&gt; is the non-boolean value. Defaults to false.</source>
          <target state="translated">为format-patch 的 &lt;code&gt;--notes&lt;/code&gt; 选项提供默认值。接受一个布尔值或一个ref，它指定在哪里获取注释。如果为false，则format-patch默认为 &lt;code&gt;--no-notes&lt;/code&gt; 。如果为true，则format-patch默认为 &lt;code&gt;--notes&lt;/code&gt; 。如果设置为非布尔值，则format-patch默认为 &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;ref&lt;/code&gt; 是非布尔值。默认为false。</target>
        </trans-unit>
        <trans-unit id="dae8413448109f25f13d1230fdfd21a6427a0a34" translate="yes" xml:space="preserve">
          <source>Provides the name of the object in the original source control system. fast-import will simply ignore this directive, but filter processes which operate on and modify the stream before feeding to fast-import may have uses for this information</source>
          <target state="translated">提供原始源控制系统中的对象名称。fast-import会简单地忽略这条指令,但在送入fast-import之前对流进行操作和修改的过滤过程可能会用到这些信息。</target>
        </trans-unit>
        <trans-unit id="354f719eac7091e1c38104be699d2a68f56df045" translate="yes" xml:space="preserve">
          <source>Providing cvs access to a git repository</source>
          <target state="translated">提供cvs对git仓库的访问。</target>
        </trans-unit>
        <trans-unit id="05a28ca41ca8e50984ed01529e7df3e3335567dc" translate="yes" xml:space="preserve">
          <source>Prune all unreachable objects from the object database</source>
          <target state="translated">删除对象数据库中所有无法到达的对象。</target>
        </trans-unit>
        <trans-unit id="347c95991436ac84fd290ccf1ebe7a72eadc41e7" translate="yes" xml:space="preserve">
          <source>Prune any reflog entries that point to &quot;broken commits&quot;. A broken commit is a commit that is not reachable from any of the reference tips and that refers, directly or indirectly, to a missing commit, tree, or blob object.</source>
          <target state="translated">修剪所有指向 &quot;断裂提交 &quot;的 reflog 条目。破损的提交是指无法从任何参考提示中获取的提交,并且直接或间接地指向一个缺失的提交、树或blob对象。</target>
        </trans-unit>
        <trans-unit id="a7eae2a7a6ec9df449cef235306188bcb1fafe15" translate="yes" xml:space="preserve">
          <source>Prune entries older than &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; that are not reachable from the current tip of the branch. If this option is not specified, the expiration time is taken from the configuration setting &lt;code&gt;gc.reflogExpireUnreachable&lt;/code&gt;, which in turn defaults to 30 days. &lt;code&gt;--expire-unreachable=all&lt;/code&gt; prunes unreachable entries regardless of their age; &lt;code&gt;--expire-unreachable=never&lt;/code&gt; turns off early pruning of unreachable entries (but see &lt;code&gt;--expire&lt;/code&gt;).</source>
          <target state="translated">从分支的当前尖端无法删除早于 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 的条目。如果未指定此选项，则到期时间将从配置设置 &lt;code&gt;gc.reflogExpireUnreachable&lt;/code&gt; 中获取，而该设置默认为30天。 &lt;code&gt;--expire-unreachable=all&lt;/code&gt; 修剪不可达条目，无论其年龄如何； &lt;code&gt;--expire-unreachable=never&lt;/code&gt; 关闭对不可达条目的早期修剪（但请参见 &lt;code&gt;--expire&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f510204b241f9f833d70b40e365b78ba855d5d73" translate="yes" xml:space="preserve">
          <source>Prune entries older than the specified time. If this option is not specified, the expiration time is taken from the configuration setting &lt;code&gt;gc.reflogExpire&lt;/code&gt;, which in turn defaults to 90 days. &lt;code&gt;--expire=all&lt;/code&gt; prunes entries regardless of their age; &lt;code&gt;--expire=never&lt;/code&gt; turns off pruning of reachable entries (but see &lt;code&gt;--expire-unreachable&lt;/code&gt;).</source>
          <target state="translated">修剪早于指定时间的条目。如果未指定此选项，则到期时间将从配置设置 &lt;code&gt;gc.reflogExpire&lt;/code&gt; 中获取，而该设置默认为90天。 &lt;code&gt;--expire=all&lt;/code&gt; 修剪条目，无论其年龄如何； &lt;code&gt;--expire=never&lt;/code&gt; 关闭对可达条目的修剪（但请参见 &lt;code&gt;--expire-unreachable&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9ca76117e69104a0e4e81d319f878c7014bb3c8a" translate="yes" xml:space="preserve">
          <source>Prune loose objects older than date (default is 2 weeks ago, overridable by the config variable &lt;code&gt;gc.pruneExpire&lt;/code&gt;). --prune=now prunes loose objects regardless of their age and increases the risk of corruption if another process is writing to the repository concurrently; see &quot;NOTES&quot; below. --prune is on by default.</source>
          <target state="translated">修剪早于日期的松散对象（默认为2周前，可被配置变量 &lt;code&gt;gc.pruneExpire&lt;/code&gt; 覆盖）。--prune = now修剪松散的对象而不管它们的年龄如何，如果另一个进程同时写入存储库，则会增加损坏的风险；请参阅下面的&amp;ldquo;注意&amp;rdquo;。--prune默认为打开状态。</target>
        </trans-unit>
        <trans-unit id="ad1903147c3980cb00334e6e57ade6c895b0d197" translate="yes" xml:space="preserve">
          <source>Prune records of conflicted merges that occurred a long time ago. By default, unresolved conflicts older than 15 days and resolved conflicts older than 60 days are pruned. These defaults are controlled via the &lt;code&gt;gc.rerereUnresolved&lt;/code&gt; and &lt;code&gt;gc.rerereResolved&lt;/code&gt; configuration variables respectively.</source>
          <target state="translated">修剪很久以前发生的合并冲突的记录。默认情况下，将修剪15天以上未解决的冲突和60天以上已解决的冲突。这些默认值分别通过 &lt;code&gt;gc.rerereUnresolved&lt;/code&gt; 和 &lt;code&gt;gc.rerereResolved&lt;/code&gt; 配置变量控制。</target>
        </trans-unit>
        <trans-unit id="9ae5dc95253bd1047251fe2f0130ef53d935cb16" translate="yes" xml:space="preserve">
          <source>Prune working tree information in $GIT_DIR/worktrees.</source>
          <target state="translated">修剪$GIT_DIR/worktrees中的工作树信息。</target>
        </trans-unit>
        <trans-unit id="1daa62e08ce5be741f0f9512af6fe6aea569309c" translate="yes" xml:space="preserve">
          <source>Pruning</source>
          <target state="translated">Pruning</target>
        </trans-unit>
        <trans-unit id="9780740ad9404eab5bef283300816b2d37b6c371" translate="yes" xml:space="preserve">
          <source>Pruning tags with &lt;code&gt;--prune-tags&lt;/code&gt; also works when fetching a URL instead of a named remote. These will all prune tags not found on origin:</source>
          <target state="translated">使用 &lt;code&gt;--prune-tags&lt;/code&gt; 修剪标签也可以在获取URL而不是命名的远程文件时使用。这些将删除在原始位置找不到的所有修剪标签：</target>
        </trans-unit>
        <trans-unit id="5d67c6362cb385f7b2fd7440df4474229e4ced1c" translate="yes" xml:space="preserve">
          <source>Pseudorefs are a class of files under &lt;code&gt;$GIT_DIR&lt;/code&gt; which behave like refs for the purposes of rev-parse, but which are treated specially by git. Pseudorefs both have names that are all-caps, and always start with a line consisting of a &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; followed by whitespace. So, HEAD is not a pseudoref, because it is sometimes a symbolic ref. They might optionally contain some additional data. &lt;code&gt;MERGE_HEAD&lt;/code&gt; and &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; are examples. Unlike &lt;a href=&quot;#def_per_worktree_ref&quot;&gt;per-worktree refs&lt;/a&gt;, these files cannot be symbolic refs, and never have reflogs. They also cannot be updated through the normal ref update machinery. Instead, they are updated by directly writing to the files. However, they can be read as if they were refs, so &lt;code&gt;git rev-parse
MERGE_HEAD&lt;/code&gt; will work.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR&lt;/code&gt; 是$ GIT_DIR下的一类文件，出于rev-parse的目的，它们的行为类似于引用，但git对其进行了特殊处理。伪引用的名称均为全大写，并且始终以由&lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt;和空格组成的行开头。因此，HEAD不是伪引用，因为它有时是符号引用。它们可以有选择地包含一些其他数据。 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 和 &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; 是示例。与&lt;a href=&quot;#def_per_worktree_ref&quot;&gt;每工作树引用&lt;/a&gt;不同，这些文件不能是符号引用，也永远不会有引用日志。它们也不能通过常规的ref更新机制进行更新。而是通过直接写入文件来更新它们。但是，它们可以像引用一样被读取，因此 &lt;code&gt;git rev-parse MERGE_HEAD&lt;/code&gt; 将起作用。</target>
        </trans-unit>
        <trans-unit id="b7a4dc2e6290047f1f86721c32ae669785e9b742" translate="yes" xml:space="preserve">
          <source>Public Git repositories</source>
          <target state="translated">公共Git仓库</target>
        </trans-unit>
        <trans-unit id="8f3f20e99361b4469a543cafe71c660d905701e0" translate="yes" xml:space="preserve">
          <source>Public api</source>
          <target state="translated">公共api</target>
        </trans-unit>
        <trans-unit id="661a1caa924e6377c910ab84f021b879aa1f3688" translate="yes" xml:space="preserve">
          <source>Public key of the https service. It may either be the filename of a PEM or DER encoded public key file or a string starting with &lt;code&gt;sha256//&lt;/code&gt; followed by the base64 encoded sha256 hash of the public key. See also libcurl &lt;code&gt;CURLOPT_PINNEDPUBLICKEY&lt;/code&gt;. git will exit with an error if this option is set but not supported by cURL.</source>
          <target state="translated">https服务的公钥。它可以是PEM或DER编码的公共密钥文件的文件名，也可以是以 &lt;code&gt;sha256//&lt;/code&gt; 开头的字符串，后跟公共密钥的base64编码的sha256哈希。另请参见libcurl &lt;code&gt;CURLOPT_PINNEDPUBLICKEY&lt;/code&gt; 。如果设置了此选项，但cURL不支持git，则会退出并出现错误。</target>
        </trans-unit>
        <trans-unit id="fcd79d77a075207d5bb03627d6390daac4adccdf" translate="yes" xml:space="preserve">
          <source>Publishing the changes from your local (private) repository to your remote (public) repository requires a write privilege on the remote machine. You need to have an SSH account there to run a single command, &lt;code&gt;git-receive-pack&lt;/code&gt;.</source>
          <target state="translated">将更改从本地（专用）存储库发布到远程（公共）存储库需要在远程计算机上具有写权限。您需要有一个SSH帐户才能运行单个命令 &lt;code&gt;git-receive-pack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d5654eba7f3fb26678d0b33453ea83f3704835b" translate="yes" xml:space="preserve">
          <source>Publishing your work</source>
          <target state="translated">发布您的作品</target>
        </trans-unit>
        <trans-unit id="5225d106493e2d5cee97f92acd212fcbe8379cc8" translate="yes" xml:space="preserve">
          <source>Pulling a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; means to &lt;a href=&quot;#def_fetch&quot;&gt;fetch&lt;/a&gt; it and &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; it. See also &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">拉&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;意味着&lt;a href=&quot;#def_fetch&quot;&gt;获取&lt;/a&gt;并&lt;a href=&quot;#def_merge&quot;&gt;合并&lt;/a&gt;它。另请参见&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ba996099ee22cf557dfd858fcdfe9998a7d87a8" translate="yes" xml:space="preserve">
          <source>Pulling down the submodules is a two-step process. First run &lt;code&gt;git submodule
init&lt;/code&gt; to add the submodule repository URLs to &lt;code&gt;.git/config&lt;/code&gt;:</source>
          <target state="translated">下拉子模块是一个分为两个步骤的过程。首先运行 &lt;code&gt;git submodule init&lt;/code&gt; 将子模块存储库URL添加到 &lt;code&gt;.git/config&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="67689e297cd4fdd92ebe641f7b6ed9bc63361f6b" translate="yes" xml:space="preserve">
          <source>Pulling into a dirty tree</source>
          <target state="translated">驶入一棵肮脏的树</target>
        </trans-unit>
        <trans-unit id="678a9bfb35ce5da855b86526d846cbdc7583b760" translate="yes" xml:space="preserve">
          <source>Push &quot;matching&quot; branches to &lt;code&gt;origin&lt;/code&gt;. See &amp;lt;refspec&amp;gt; in the &lt;a href=&quot;#OPTIONS&quot;&gt;OPTIONS&lt;/a&gt; section above for a description of &quot;matching&quot; branches.</source>
          <target state="translated">将&amp;ldquo;匹配&amp;rdquo;分支推至 &lt;code&gt;origin&lt;/code&gt; 。有关&amp;ldquo;匹配&amp;rdquo;分支的说明，请参见上面&amp;ldquo; &lt;a href=&quot;#OPTIONS&quot;&gt;选项&amp;rdquo;&lt;/a&gt;部分中的&amp;lt;refspec&amp;gt; 。</target>
        </trans-unit>
        <trans-unit id="e3d386bb2b306b430b8f1443632bcddb41f7fbbb" translate="yes" xml:space="preserve">
          <source>Push all branches (i.e. refs under &lt;code&gt;refs/heads/&lt;/code&gt;); cannot be used with other &amp;lt;refspec&amp;gt;.</source>
          <target state="translated">推送所有分支（即 &lt;code&gt;refs/heads/&lt;/code&gt; 下的refs）；不能与其他&amp;lt;refspec&amp;gt;一起使用。</target>
        </trans-unit>
        <trans-unit id="7ed05cac5fbf2fe13d768ad8d52cf3e6b3326c39" translate="yes" xml:space="preserve">
          <source>Push all the refs that would be pushed without this option, and also push annotated tags in &lt;code&gt;refs/tags&lt;/code&gt; that are missing from the remote but are pointing at commit-ish that are reachable from the refs being pushed. This can also be specified with configuration variable &lt;code&gt;push.followTags&lt;/code&gt;. For more information, see &lt;code&gt;push.followTags&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">推送所有不带此选项将被推送的ref，并推送带注释的标签到远程丢失的 &lt;code&gt;refs/tags&lt;/code&gt; ，但指向被推送的ref可以到达的commit-ish。也可以使用配置变量 &lt;code&gt;push.followTags&lt;/code&gt; 进行指定。有关详细信息，请参阅 &lt;code&gt;push.followTags&lt;/code&gt; 在&lt;a href=&quot;git-config&quot;&gt;GIT-配置[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="640e91962e4a94024fb44763555198cb451cbb5d" translate="yes" xml:space="preserve">
          <source>Push into another repository.</source>
          <target state="translated">推入另一个仓库。</target>
        </trans-unit>
        <trans-unit id="fc1129a549e46f5ee09d052c0e625db078207268" translate="yes" xml:space="preserve">
          <source>Push into the public repository from your primary repository.</source>
          <target state="translated">从你的主仓库推入公共仓库。</target>
        </trans-unit>
        <trans-unit id="a011ac29541d686365501a5376539fc2a54082f8" translate="yes" xml:space="preserve">
          <source>Push into the public repository from your primary repository. Run &lt;code&gt;git repack&lt;/code&gt;, and possibly &lt;code&gt;git prune&lt;/code&gt; if the transport used for pulling from your repository supports packed repositories.</source>
          <target state="translated">从主存储库推送到公共存储库。如果用于从存储库中提取的传输支持打包存储库，请运行 &lt;code&gt;git repack&lt;/code&gt; ，并可能运行git &lt;code&gt;git prune&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8251f9563aa908db5da52a9527e9f939a118d16" translate="yes" xml:space="preserve">
          <source>Push master, using file descriptor #7 to read data from git-receive-pack and file descriptor #8 to write data to same service.</source>
          <target state="translated">推送主站,使用文件描述符 #7 从 git-receive-pack 读取数据,使用文件描述符 #8 向同一服务写入数据。</target>
        </trans-unit>
        <trans-unit id="db6a77b6524cf46e0155fc78cb84e6ef6e8d26d4" translate="yes" xml:space="preserve">
          <source>Push objects over Git protocol to another repository</source>
          <target state="translated">通过Git协议将对象推送到另一个仓库。</target>
        </trans-unit>
        <trans-unit id="e328f2dc0a129ee52c24984713b8e3e05193f873" translate="yes" xml:space="preserve">
          <source>Push objects over HTTP/DAV to another repository</source>
          <target state="translated">通过HTTP/DAV将对象推送到另一个存储库。</target>
        </trans-unit>
        <trans-unit id="93e6fc3901865e79bc1dfa6c467266c7822bf760" translate="yes" xml:space="preserve">
          <source>Push the current branch to the remote ref matching &lt;code&gt;master&lt;/code&gt; in the &lt;code&gt;origin&lt;/code&gt; repository. This form is convenient to push the current branch without thinking about its local name.</source>
          <target state="translated">推当前分支到远程REF匹配 &lt;code&gt;master&lt;/code&gt; 在 &lt;code&gt;origin&lt;/code&gt; 存储库中。这种形式可以方便地推送当前分支，而无需考虑其本地名称。</target>
        </trans-unit>
        <trans-unit id="7221b3bad2db1abe78fb6e7112e947ec9066c484" translate="yes" xml:space="preserve">
          <source>Push your changes to the public repository, and announce it to the public.</source>
          <target state="translated">将你的修改推送到公共存储库,并向公众公布。</target>
        </trans-unit>
        <trans-unit id="44e2374abe889d292378278a32f8732ae3d0723a" translate="yes" xml:space="preserve">
          <source>Push your changes to your public repository, and ask your &quot;project lead&quot; and possibly your &quot;sub-subsystem maintainers&quot; to pull from it.</source>
          <target state="translated">将你的修改推送到你的公共仓库,并要求你的 &quot;项目负责人 &quot;和可能的 &quot;子子系统维护者 &quot;从中拉取。</target>
        </trans-unit>
        <trans-unit id="64c3ecd283374b8e31c77b37f0b37ed07f7e3e67" translate="yes" xml:space="preserve">
          <source>Pushes the given local &amp;lt;src&amp;gt; commit or branch to the remote branch described by &amp;lt;dst&amp;gt;. A batch sequence of one or more &lt;code&gt;push&lt;/code&gt; commands is terminated with a blank line (if there is only one reference to push, a single &lt;code&gt;push&lt;/code&gt; command is followed by a blank line). For example, the following would be two batches of &lt;code&gt;push&lt;/code&gt;, the first asking the remote-helper to push the local ref &lt;code&gt;master&lt;/code&gt; to the remote ref &lt;code&gt;master&lt;/code&gt; and the local &lt;code&gt;HEAD&lt;/code&gt; to the remote &lt;code&gt;branch&lt;/code&gt;, and the second asking to push ref &lt;code&gt;foo&lt;/code&gt; to ref &lt;code&gt;bar&lt;/code&gt; (forced update requested by the &lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">将给定的本地&amp;lt;src&amp;gt;提交或分支推送到&amp;lt;dst&amp;gt;描述的远程分支。一个或多个 &lt;code&gt;push&lt;/code&gt; 命令的批处理序列以空行终止（如果只有一个引用要推送，则单个 &lt;code&gt;push&lt;/code&gt; 命令后跟一个空行）。例如，以下是两批次的 &lt;code&gt;push&lt;/code&gt; ，第一批次要求远程助手将本地ref &lt;code&gt;master&lt;/code&gt; 推送到远程ref &lt;code&gt;master&lt;/code&gt; ，将本地 &lt;code&gt;HEAD&lt;/code&gt; 推送到远程 &lt;code&gt;branch&lt;/code&gt; ，第二批次要求将ref &lt;code&gt;foo&lt;/code&gt; 推送到ref &lt;code&gt;bar&lt;/code&gt; （ &lt;code&gt;+&lt;/code&gt; 要求强制更新）。</target>
        </trans-unit>
        <trans-unit id="ca5456a5df7b11e9ef0d22090b33d4f3bd62ba82" translate="yes" xml:space="preserve">
          <source>Pushes which fail due to problems with the incoming pack, missing objects, or due to the &lt;code&gt;pre-receive&lt;/code&gt; hook will not leave any on-disk data. This is usually helpful to prevent repeated failed pushes from filling up your disk, but can make debugging more challenging.</source>
          <target state="translated">由于传入数据包出现问题，缺少对象或由于 &lt;code&gt;pre-receive&lt;/code&gt; 挂钩而导致失败的推送不会留下任何磁盘上的数据。这通常有助于防止重复失败的推送操作填满磁盘，但会使调试更具挑战性。</target>
        </trans-unit>
        <trans-unit id="bd3f47195169191b06e6fb59aa660030c03d8082" translate="yes" xml:space="preserve">
          <source>Pushing a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; means to get the branch&amp;rsquo;s &lt;a href=&quot;#def_head_ref&quot;&gt;head ref&lt;/a&gt; from a remote &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;, find out if it is an ancestor to the branch&amp;rsquo;s local head ref, and in that case, putting all objects, which are &lt;a href=&quot;#def_reachable&quot;&gt;reachable&lt;/a&gt; from the local head ref, and which are missing from the remote repository, into the remote &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt;, and updating the remote head ref. If the remote &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; is not an ancestor to the local head, the push fails.</source>
          <target state="translated">推送&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;意味着从远程&lt;a href=&quot;#def_repository&quot;&gt;存储库中&lt;/a&gt;获取分支的&lt;a href=&quot;#def_head_ref&quot;&gt;head ref&lt;/a&gt;，确定它是否是分支的本地head ref的祖先，在这种情况下，放置所有从本地head ref &lt;a href=&quot;#def_reachable&quot;&gt;可以访问的&lt;/a&gt;对象，以及从远程存储库中丢失，进入远程&lt;a href=&quot;#def_object_database&quot;&gt;对象数据库&lt;/a&gt;，并更新远程头参考。如果远程&lt;a href=&quot;#def_head&quot;&gt;头&lt;/a&gt;不是本地头的祖先，则推送失败。</target>
        </trans-unit>
        <trans-unit id="a1b201ad98b52436e58805968e041862b0e44b88" translate="yes" xml:space="preserve">
          <source>Pushing an empty &amp;lt;src&amp;gt; allows you to delete the &amp;lt;dst&amp;gt; ref from the remote repository. Deletions are always accepted without a leading &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;), except when forbidden by configuration or hooks. See &lt;code&gt;receive.denyDeletes&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;code&gt;pre-receive&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; in &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">推送空的&amp;lt;src&amp;gt;允许您从远程存储库中删除&amp;lt;dst&amp;gt;引用。除非 &lt;code&gt;--force&lt;/code&gt; 或挂钩禁止，否则在refspec（或--force）中始终接受不带前导 &lt;code&gt;+&lt;/code&gt; 的删除。见 &lt;code&gt;receive.denyDeletes&lt;/code&gt; 在&lt;a href=&quot;git-config&quot;&gt;GIT-配置[1]&lt;/a&gt;和 &lt;code&gt;pre-receive&lt;/code&gt; 和 &lt;code&gt;update&lt;/code&gt; 在&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b554604b5dbdc966cb242c709d8d9564fd3f48c" translate="yes" xml:space="preserve">
          <source>Pushing changes to a public repository</source>
          <target state="translated">将变更推送至公共存储库</target>
        </trans-unit>
        <trans-unit id="eedfa4fe862b4ad2f2d3d15f8505bb4e78d4fc1a" translate="yes" xml:space="preserve">
          <source>Put all the committers in the same group, and make the repository writable by that group:</source>
          <target state="translated">将所有的提交者放在同一个组中,并使版本库可以被该组写入。</target>
        </trans-unit>
        <trans-unit id="c26397c67704ec958580d89b3087bf7a34700351" translate="yes" xml:space="preserve">
          <source>Put everything in the current head&amp;rsquo;s Documentation/ directory into &lt;code&gt;git-1.4.0-docs.zip&lt;/code&gt;, with the prefix &lt;code&gt;git-docs/&lt;/code&gt;.</source>
          <target state="translated">将当前文件头的Documentation /目录中的所有内容放入 &lt;code&gt;git-1.4.0-docs.zip&lt;/code&gt; 中，并将其前缀为 &lt;code&gt;git-docs/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea705b3a47d1cdf9261daf67230a93968f6edd0b" translate="yes" xml:space="preserve">
          <source>QUERY_STRING</source>
          <target state="translated">QUERY_STRING</target>
        </trans-unit>
        <trans-unit id="c3149be9220a8ce116523f671437212f69f45ea5" translate="yes" xml:space="preserve">
          <source>Quarantine environment</source>
          <target state="translated">检疫环境</target>
        </trans-unit>
        <trans-unit id="ec85d37cf9d9f3d10289231d732a03bb25cc011c" translate="yes" xml:space="preserve">
          <source>Query p4 for labels associated with the depot paths, and add them as tags in Git. Limited usefulness as only imports labels associated with new changelists. Deprecated.</source>
          <target state="translated">查询 p4 中与仓库路径相关联的标签,并将其作为标签添加到 Git 中。由于只导入与新的变更列表相关联的标签,实用性有限。已废弃。</target>
        </trans-unit>
        <trans-unit id="ce8d2336bc85bc6e5b624295904c32b955dda594" translate="yes" xml:space="preserve">
          <source>Quick reference guides: &lt;a href=&quot;https://github.github.com/training-kit/downloads/github-git-cheat-sheet.pdf&quot;&gt;GitHub Cheat Sheet&lt;/a&gt;&lt;small&gt;(PDF)&lt;/small&gt; | &lt;a href=&quot;https://ndpsoftware.com/git-cheatsheet.html&quot;&gt;Visual Git Cheat Sheet&lt;/a&gt;&lt;small&gt;(SVG | PNG)&lt;/small&gt;</source>
          <target state="translated">快速参考指南：&lt;a href=&quot;https://github.github.com/training-kit/downloads/github-git-cheat-sheet.pdf&quot;&gt;GitHub备忘单&lt;/a&gt;&lt;small&gt;（PDF）&lt;/small&gt; | &lt;a href=&quot;https://ndpsoftware.com/git-cheatsheet.html&quot;&gt;视觉Git备忘单&lt;/a&gt;&lt;small&gt;（SVG | PNG）&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3a11ac4a816649c90b2a876b8ed365a4f747816e" translate="yes" xml:space="preserve">
          <source>Quiet, suppress feedback messages.</source>
          <target state="translated">安静,压制反馈信息。</target>
        </trans-unit>
        <trans-unit id="2ac9102b0a2f3eb9abc09cf4e1c41ec0575ff1e1" translate="yes" xml:space="preserve">
          <source>Quiet, suppress feedback messages. Implies &lt;code&gt;--no-progress&lt;/code&gt;.</source>
          <target state="translated">安静，禁止显示反馈消息。表示 &lt;code&gt;--no-progress&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de1dab6bd571badbfbb3ddaa6f495be909332129" translate="yes" xml:space="preserve">
          <source>Quiet. If --refresh finds that the index needs an update, the default behavior is to error out. This option makes &lt;code&gt;git update-index&lt;/code&gt; continue anyway.</source>
          <target state="translated">安静。如果--refresh发现索引需要更新，则默认行为是出错。这个选项使 &lt;code&gt;git update-index&lt;/code&gt; 仍然继续。</target>
        </trans-unit>
        <trans-unit id="e1baedfd2936afaf34298be8c53a6f3520c17d3e" translate="yes" xml:space="preserve">
          <source>Quiet; do not warn about conflicts.</source>
          <target state="translated">安静;不警告冲突。</target>
        </trans-unit>
        <trans-unit id="e9770de83f70890562d92f9477d5315581d69261" translate="yes" xml:space="preserve">
          <source>Quite similarly, if &lt;code&gt;core.symlinks&lt;/code&gt; configuration variable is set to &lt;code&gt;false&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;), symbolic links are checked out as plain files, and this command does not modify a recorded file mode from symbolic link to regular file.</source>
          <target state="translated">同样，如果将 &lt;code&gt;core.symlinks&lt;/code&gt; 配置变量设置为 &lt;code&gt;false&lt;/code&gt; （请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;），则将符号链接检出为纯文件，并且此命令不会将记录文件模式从符号链接修改为常规文件。</target>
        </trans-unit>
        <trans-unit id="f0f61d9660842b035df0296041289cbf85b3ae28" translate="yes" xml:space="preserve">
          <source>Quote fields containing whitespace as if they were strings in C source code; i.e., surrounded by double-quotes and with backslash escapes. Use 40 &quot;0&quot; characters or the empty string to specify a zero value. To specify a missing value, omit the value and its preceding SP entirely.</source>
          <target state="translated">引用包含空格的字段,就像C源代码中的字符串一样,即用双引号包围,并使用反斜杠转义。使用40个 &quot;0 &quot;字符或空字符串来指定一个零值。要指定一个缺失的值,完全省略该值及其前面的SP。</target>
        </trans-unit>
        <trans-unit id="0550aeb8801a3ad8332244f3d277c748ecb56080" translate="yes" xml:space="preserve">
          <source>Quoted aliases and quoted addresses are not supported: lines that contain a &lt;code&gt;&quot;&lt;/code&gt; symbol are ignored.</source>
          <target state="translated">不支持带引号的别名和带引号的地址：包含 &lt;code&gt;&quot;&lt;/code&gt; 符号的行将被忽略。</target>
        </trans-unit>
        <trans-unit id="06576556d1ad802f247cad11ae748be47b70cd9c" translate="yes" xml:space="preserve">
          <source>R</source>
          <target state="translated">R</target>
        </trans-unit>
        <trans-unit id="38354f3564dc690008158ec27147b7718eef20da" translate="yes" xml:space="preserve">
          <source>R: renaming of a file</source>
          <target state="translated">R:重命名文件</target>
        </trans-unit>
        <trans-unit id="73ff05a9f629bff633fa7a0499495556f0f1a07f" translate="yes" xml:space="preserve">
          <source>README.html</source>
          <target state="translated">README.html</target>
        </trans-unit>
        <trans-unit id="986c96108f4514e08f8de60c616ff1d0727fd986" translate="yes" xml:space="preserve">
          <source>REMOTE_ADDR</source>
          <target state="translated">REMOTE_ADDR</target>
        </trans-unit>
        <trans-unit id="613cec3f00ac4a24def4b10bec39e10198b8d82e" translate="yes" xml:space="preserve">
          <source>REMOTE_USER</source>
          <target state="translated">REMOTE_USER</target>
        </trans-unit>
        <trans-unit id="a16e10b928e7c21c5b4ae3d47f9db3c0b6c782c3" translate="yes" xml:space="preserve">
          <source>REQUEST_METHOD</source>
          <target state="translated">REQUEST_METHOD</target>
        </trans-unit>
        <trans-unit id="697070f17a70b2490138caae401415ac7b401fbd" translate="yes" xml:space="preserve">
          <source>RFC 2822</source>
          <target state="translated">RFC 2822</target>
        </trans-unit>
        <trans-unit id="b34db1f303fd91c6e7039f452d5097c789b26cf1" translate="yes" xml:space="preserve">
          <source>Rather than checking out a branch to work on it, check out a commit for inspection and discardable experiments. This is the default behavior of &lt;code&gt;git checkout &amp;lt;commit&amp;gt;&lt;/code&gt; when &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; is not a branch name. See the &quot;DETACHED HEAD&quot; section below for details.</source>
          <target state="translated">与其签出分支来进行工作，不如签出检查和可丢弃实验的提交。当 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 不是分支名称时，这是 &lt;code&gt;git checkout &amp;lt;commit&amp;gt;&lt;/code&gt; 的默认行为。有关详细信息，请参见下面的&amp;ldquo;分离头&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="4e4bfd7d1a0190903bc19000a40525c987ff7008" translate="yes" xml:space="preserve">
          <source>Raw output format</source>
          <target state="translated">原始输出格式</target>
        </trans-unit>
        <trans-unit id="7b0a88cf0ceef9e929b45fca40ecfa70b119395a" translate="yes" xml:space="preserve">
          <source>Re-author p4 changes before submitting to p4. This option requires p4 admin privileges.</source>
          <target state="translated">在提交给p4之前重新授权p4的更改。这个选项需要p4管理员权限。</target>
        </trans-unit>
        <trans-unit id="a3d5287f4feb36f53be9e482bea0b4f69488906a" translate="yes" xml:space="preserve">
          <source>Read &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more details about each hook.</source>
          <target state="translated">阅读&lt;a href=&quot;githooks&quot;&gt;githooks [5]，&lt;/a&gt;以获得有关每个钩子的更多详细信息。</target>
        </trans-unit>
        <trans-unit id="3c99ae2389e194940d6e9dae44358b0f59db22c3" translate="yes" xml:space="preserve">
          <source>Read a list of commits from stdin and commit them in reverse order. Only the leading sha1 is read from each line, so &lt;code&gt;git rev-list --pretty=oneline&lt;/code&gt; output can be used.</source>
          <target state="translated">从stdin中读取提交列表，并以相反的顺序提交它们。每行仅读取前导sha1，因此可以使用 &lt;code&gt;git rev-list --pretty=oneline&lt;/code&gt; 输出。</target>
        </trans-unit>
        <trans-unit id="9a81bd113ea455376c0709dc2b5dec2fbcc3eae4" translate="yes" xml:space="preserve">
          <source>Read a packed archive (.pack) from the standard input, expanding the objects contained within and writing them into the repository in &quot;loose&quot; (one object per file) format.</source>
          <target state="translated">从标准输入中读取打包的档案(.pack),扩展其中包含的对象,并以 &quot;松散&quot;(每个文件一个对象)的格式将其写入存储库。</target>
        </trans-unit>
        <trans-unit id="cf4f210605880935e907e739e930d70c6c05f393" translate="yes" xml:space="preserve">
          <source>Read a patch from the standard input and compute the patch ID for it.</source>
          <target state="translated">从标准输入中读取一个补丁,并计算出它的补丁ID。</target>
        </trans-unit>
        <trans-unit id="118b284f547f2475f4692a5a06eacb1fa689da5d" translate="yes" xml:space="preserve">
          <source>Read a tar archive created by &lt;code&gt;git archive&lt;/code&gt; from the standard input and extract the commit ID stored in it. It reads only the first 1024 bytes of input, thus its runtime is not influenced by the size of the tar archive very much.</source>
          <target state="translated">从标准输入中读取由 &lt;code&gt;git archive&lt;/code&gt; archive创建的tar归档文件，并提取存储在其中的提交ID。它仅读取输入的前1024个字节，因此其运行时间不受tar归档文件大小的很大影响。</target>
        </trans-unit>
        <trans-unit id="8323be41a83f5e8edd45cebf33794d8211b9a65a" translate="yes" xml:space="preserve">
          <source>Read additional exclude patterns that apply only to the directory and its subdirectories in &amp;lt;file&amp;gt;.</source>
          <target state="translated">阅读仅适用于&amp;lt;file&amp;gt;中的目录及其子目录的其他排除模式。</target>
        </trans-unit>
        <trans-unit id="ec538abd0ecb84f4afa31116a9fde4a7bfbfc841" translate="yes" xml:space="preserve">
          <source>Read contacts, one per line, from the standard input after exhausting contacts provided on the command-line.</source>
          <target state="translated">在用完命令行提供的触点后,从标准输入端读取触点,每行一个。</target>
        </trans-unit>
        <trans-unit id="cc8be265c5565879cb19acef5a95bb650b329807" translate="yes" xml:space="preserve">
          <source>Read description of &lt;code&gt;%feature&lt;/code&gt; hash for detailed list, and descriptions. See also &quot;Configuring gitweb features&quot; section in &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;</source>
          <target state="translated">阅读 &lt;code&gt;%feature&lt;/code&gt; 哈希的描述以获取详细列表和描述。另请参见&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]中的&lt;/a&gt; &amp;ldquo;配置gitweb功能&amp;rdquo;部分</target>
        </trans-unit>
        <trans-unit id="15ad57eb2da16d3087f86e421c960f711d5a7f97" translate="yes" xml:space="preserve">
          <source>Read exclude patterns from &amp;lt;file&amp;gt;; 1 per line.</source>
          <target state="translated">从&amp;lt;file&amp;gt;中读取排除模式；每行1个。</target>
        </trans-unit>
        <trans-unit id="f6c76b424f91b25c9b13ee14e1604c5d3fa96f28" translate="yes" xml:space="preserve">
          <source>Read file names from the standard input, one per line, instead of from the command-line.</source>
          <target state="translated">从标准输入中读取文件名,每行一个,而不是从命令行读取。</target>
        </trans-unit>
        <trans-unit id="d0b5b313182b086a1f9af39ecd4467e46faca9cf" translate="yes" xml:space="preserve">
          <source>Read index information from stdin.</source>
          <target state="translated">从stdin读取索引信息。</target>
        </trans-unit>
        <trans-unit id="80670c79001d8f8c9a5be5d38404bf833dac649e" translate="yes" xml:space="preserve">
          <source>Read its description.</source>
          <target state="translated">阅读其描述。</target>
        </trans-unit>
        <trans-unit id="46ab10e675175e0e453c98d42b078fb4b46c2856" translate="yes" xml:space="preserve">
          <source>Read pathnames from the standard input, one per line, instead of from the command-line.</source>
          <target state="translated">从标准输入中读取路径名,每行一个,而不是从命令行读取。</target>
        </trans-unit>
        <trans-unit id="e51b79a68429169e8d905bac10a875d5d0bc0bbc" translate="yes" xml:space="preserve">
          <source>Read patterns from &amp;lt;file&amp;gt;, one per line.</source>
          <target state="translated">从&amp;lt;file&amp;gt;中读取模式，每行读取一个。</target>
        </trans-unit>
        <trans-unit id="fed49b353bd2e8ef2071f098ea90e8175a16e2cc" translate="yes" xml:space="preserve">
          <source>Read text, such as commit messages, notes, tags and branch descriptions, from the standard input and clean it in the manner used by Git.</source>
          <target state="translated">从标准输入中读取提交信息、注释、标签和分支描述等文本,并以 Git 的方式进行清理。</target>
        </trans-unit>
        <trans-unit id="eceb0ad0aa215d85bc1cfa0886bd096a3daed30d" translate="yes" xml:space="preserve">
          <source>Read the &lt;code&gt;.idx&lt;/code&gt; file for a Git packfile (created with &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; or &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack[1]&lt;/a&gt;) from the standard input, and dump its contents. The output consists of one object per line, with each line containing two or three space-separated columns:</source>
          <target state="translated">从标准输入中读取Gid打包文件（使用&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;或&lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack [1]&lt;/a&gt;创建）的 &lt;code&gt;.idx&lt;/code&gt; 文件，并转储其内容。输出每行包含一个对象，每行包含两个或三个以空格分隔的列：</target>
        </trans-unit>
        <trans-unit id="ddd6a34883963a795d5ebc22563eef2cf30acd2b" translate="yes" xml:space="preserve">
          <source>Read the NUL-terminated &lt;code&gt;ls-tree -z&lt;/code&gt; output instead.</source>
          <target state="translated">改为读取以NUL结尾的 &lt;code&gt;ls-tree -z&lt;/code&gt; 输出。</target>
        </trans-unit>
        <trans-unit id="3ea8fc0021add956f340de030bf6e8165a69896f" translate="yes" xml:space="preserve">
          <source>Read the commit log message from the given file. Use &lt;code&gt;-&lt;/code&gt; to read from the standard input. This can be given more than once and the content of each file becomes its own paragraph.</source>
          <target state="translated">从给定文件中读取提交日志消息。使用 &lt;code&gt;-&lt;/code&gt; 读取标准输入。可以多次给出此信息，并且每个文件的内容都变成其自己的段落。</target>
        </trans-unit>
        <trans-unit id="507fdedba9f69c5efbd0e8cf829abe30d4a7a120" translate="yes" xml:space="preserve">
          <source>Read the commit message to be used for the merge commit (in case one is created).</source>
          <target state="translated">读取合并提交时要用到的提交信息(如果创建了合并提交)。</target>
        </trans-unit>
        <trans-unit id="9362ea89cc38e10989edc212ebc0bf489cc001f5" translate="yes" xml:space="preserve">
          <source>Read the commit-graph file and verify its contents against the object database. Used to check for corrupted data.</source>
          <target state="translated">读取提交图文件并根据对象数据库验证其内容。用于检查是否有损坏的数据。</target>
        </trans-unit>
        <trans-unit id="9e4092c6ffe69dbb6a8bf7641feea7e173111c93" translate="yes" xml:space="preserve">
          <source>Read the object from standard input instead of from a file.</source>
          <target state="translated">从标准输入中读取对象,而不是从文件中读取。</target>
        </trans-unit>
        <trans-unit id="16a5e93c91809d39b015e5b24abf65dd6438e038" translate="yes" xml:space="preserve">
          <source>Read the revision arguments from the standard input, instead of individual object names. The revision arguments are processed the same way as &lt;code&gt;git rev-list&lt;/code&gt; with the &lt;code&gt;--objects&lt;/code&gt; flag uses its &lt;code&gt;commit&lt;/code&gt; arguments to build the list of objects it outputs. The objects on the resulting list are packed. Besides revisions, &lt;code&gt;--not&lt;/code&gt; or &lt;code&gt;--shallow &amp;lt;SHA-1&amp;gt;&lt;/code&gt; lines are also accepted.</source>
          <target state="translated">从标准输入而不是单个对象名称中读取修订参数。修订版本参数的处理方式与 &lt;code&gt;git rev-list&lt;/code&gt; 相同，使用 &lt;code&gt;--objects&lt;/code&gt; 标志使用其 &lt;code&gt;commit&lt;/code&gt; 参数来构建其输出的对象列表。结果列表上的对象已打包。此外修改， &lt;code&gt;--not&lt;/code&gt; 或 &lt;code&gt;--shallow &amp;lt;SHA-1&amp;gt;&lt;/code&gt; 线也被接受。</target>
        </trans-unit>
        <trans-unit id="7f840070f6a18eee1c3de888e1eec475edd1cfa4" translate="yes" xml:space="preserve">
          <source>Read, modify and delete symbolic refs</source>
          <target state="translated">读取、修改和删除符号引用</target>
        </trans-unit>
        <trans-unit id="356b6782c6512845fae8c2da14d692d4da174e8d" translate="yes" xml:space="preserve">
          <source>Reading from a named tree</source>
          <target state="translated">从命名的树中读取</target>
        </trans-unit>
        <trans-unit id="7405316147ea4906cae4c658957705537066053b" translate="yes" xml:space="preserve">
          <source>Reading from the active commit</source>
          <target state="translated">从活动提交中读取</target>
        </trans-unit>
        <trans-unit id="d5df5dafb2331c4e6af80c2f8a0c26176a288dab" translate="yes" xml:space="preserve">
          <source>Reads a packed archive (.pack) from the specified file, and builds a pack index file (.idx) for it. The packed archive together with the pack index can then be placed in the objects/pack/ directory of a Git repository.</source>
          <target state="translated">从指定的文件中读取打包后的存档(.pack),并为其建立一个打包索引文件(.idx)。然后,打包后的存档和打包索引可以放在 Git 仓库的 objects/pack/目录下。</target>
        </trans-unit>
        <trans-unit id="db9526754c129c75f60022c8e34e8db9d6855fac" translate="yes" xml:space="preserve">
          <source>Reads a single e-mail message from the standard input, and writes the commit log message in &amp;lt;msg&amp;gt; file, and the patches in &amp;lt;patch&amp;gt; file. The author name, e-mail and e-mail subject are written out to the standard output to be used by &lt;code&gt;git am&lt;/code&gt; to create a commit. It is usually not necessary to use this command directly. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; instead.</source>
          <target state="translated">从标准输入中读取单个电子邮件，并将提交日志消息写入&amp;lt;msg&amp;gt;文件，并将修补程序写入&amp;lt;patch&amp;gt;文件。作者名称，电子邮件和电子邮件主题被写到标准输出中，以供 &lt;code&gt;git am&lt;/code&gt; 创建提交。通常没有必要直接使用此命令。请参见&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91a54b1043f609f02e31617fc1ed3b549e2a4394" translate="yes" xml:space="preserve">
          <source>Reads a tag contents on standard input and creates a tag object that can also be used to sign other objects.</source>
          <target state="translated">读取标准输入的标签内容,并创建一个标签对象,该对象也可用于签署其他对象。</target>
        </trans-unit>
        <trans-unit id="1988117fbbba1a52186c7874f472ad690b235ffc" translate="yes" xml:space="preserve">
          <source>Reads given idx file for packed Git archive created with the &lt;code&gt;git pack-objects&lt;/code&gt; command and verifies idx file and the corresponding pack file.</source>
          <target state="translated">读取给定的idx文件，以使用 &lt;code&gt;git pack-objects&lt;/code&gt; 命令创建的打包Git存档，并验证idx文件和相应的打包文件。</target>
        </trans-unit>
        <trans-unit id="befcf9896fcbea450fd9bee257995fb96286ee5a" translate="yes" xml:space="preserve">
          <source>Reads list of objects from the standard input, and writes either one or more packed archives with the specified base-name to disk, or a packed archive to the standard output.</source>
          <target state="translated">从标准输入中读取对象列表,并将一个或多个带有指定基名的打包存档写入磁盘,或将打包存档写入标准输出。</target>
        </trans-unit>
        <trans-unit id="d7a9d36099b1ff6ac5bd15dd14e16c269b0389b8" translate="yes" xml:space="preserve">
          <source>Reads standard input in non-recursive &lt;code&gt;ls-tree&lt;/code&gt; output format, and creates a tree object. The order of the tree entries is normalized by mktree so pre-sorting the input is not required. The object name of the tree object built is written to the standard output.</source>
          <target state="translated">读取非递归 &lt;code&gt;ls-tree&lt;/code&gt; 输出格式的标准输入，并创建一个树对象。树条目的顺序由mktree规范化，因此不需要对输入进行预排序。构建的树对象的对象名称将写入标准输出。</target>
        </trans-unit>
        <trans-unit id="768de97d393241af581368bdb5b60add6bc4daa9" translate="yes" xml:space="preserve">
          <source>Reads the supplied diff output (i.e. &quot;a patch&quot;) and applies it to files. When running from a subdirectory in a repository, patched paths outside the directory are ignored. With the &lt;code&gt;--index&lt;/code&gt; option the patch is also applied to the index, and with the &lt;code&gt;--cached&lt;/code&gt; option the patch is only applied to the index. Without these options, the command applies the patch only to files, and does not require them to be in a Git repository.</source>
          <target state="translated">读取提供的差异输出（即&amp;ldquo;补丁&amp;rdquo;）并将其应用于文件。从存储库中的子目录运行时，目录外部的修补路径将被忽略。使用 &lt;code&gt;--index&lt;/code&gt; 选项，补丁也将应用于索引，使用 &lt;code&gt;--cached&lt;/code&gt; 选项，补丁仅应用于索引。如果没有这些选项，该命令仅将补丁应用于文件，而不要求它们位于Git存储库中。</target>
        </trans-unit>
        <trans-unit id="e5173f184d3064943fb31ef4b9c751d1119e1685" translate="yes" xml:space="preserve">
          <source>Reads the tree information given by &amp;lt;tree-ish&amp;gt; into the index, but does not actually &lt;strong&gt;update&lt;/strong&gt; any of the files it &quot;caches&quot;. (see: &lt;a href=&quot;git-checkout-index&quot;&gt;git-checkout-index[1]&lt;/a&gt;)</source>
          <target state="translated">将&amp;lt;tree-ish&amp;gt;给定的树信息读入索引，但实际上并不&lt;strong&gt;更新&lt;/strong&gt;它&amp;ldquo;缓存&amp;rdquo;的任何文件。（请参阅：&lt;a href=&quot;git-checkout-index&quot;&gt;git-checkout-index [1]&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="e432986c9c0bf1c0563c54e4546289b72e2b8f05" translate="yes" xml:space="preserve">
          <source>Reads three tree-ish, and output trivial merge results and conflicting stages to the standard output. This is similar to what three-way &lt;code&gt;git read-tree -m&lt;/code&gt; does, but instead of storing the results in the index, the command outputs the entries to the standard output.</source>
          <target state="translated">读取三个树状结构，并将琐碎的合并结果和冲突阶段输出到标准输出。这与三向 &lt;code&gt;git read-tree -m&lt;/code&gt; 的操作类似，但是命令不是将结果存储在索引中，而是将条目输出到标准输出。</target>
        </trans-unit>
        <trans-unit id="47a594db00e7ab66962cb542d6f07d66a982ad3f" translate="yes" xml:space="preserve">
          <source>Reads tree information into the index</source>
          <target state="translated">将树的信息读取到索引中</target>
        </trans-unit>
        <trans-unit id="209b43abaea4b5ac5dbb8b759ed99ebfaf6f9172" translate="yes" xml:space="preserve">
          <source>Reapply commits on top of another base tip</source>
          <target state="translated">在另一个基础提示上重新应用提交。</target>
        </trans-unit>
        <trans-unit id="95695a29b19740f8f73c24fedd25acfa8a46012d" translate="yes" xml:space="preserve">
          <source>Rebase</source>
          <target state="translated">Rebase</target>
        </trans-unit>
        <trans-unit id="f805426f874c522ca8e3397a261d025324269dce" translate="yes" xml:space="preserve">
          <source>Rebase all commits reachable from &amp;lt;branch&amp;gt;, instead of limiting them with an &amp;lt;upstream&amp;gt;. This allows you to rebase the root commit(s) on a branch. When used with --onto, it will skip changes already contained in &amp;lt;newbase&amp;gt; (instead of &amp;lt;upstream&amp;gt;) whereas without --onto it will operate on every change. When used together with both --onto and --preserve-merges, &lt;code&gt;all&lt;/code&gt; root commits will be rewritten to have &amp;lt;newbase&amp;gt; as parent instead.</source>
          <target state="translated">重新设置所有可从&amp;lt;branch&amp;gt;到达的提交，而不是使用&amp;lt;upstream&amp;gt;限制它们。这使您可以在分支上重新建立根提交。与--onto一起使用时，它将跳过&amp;lt;newbase&amp;gt;中已包含的更改（而不是&amp;lt;upstream&amp;gt;），而没有--onto时，它将对所有更改进行操作。与--onto和--preserve-merges一起使用时， &lt;code&gt;all&lt;/code&gt; 根提交都将被重写为以&amp;lt;newbase&amp;gt;作为父级。</target>
        </trans-unit>
        <trans-unit id="e5565e2c078bf46f769d916c78f2140677ea9bef" translate="yes" xml:space="preserve">
          <source>Rebase options</source>
          <target state="translated">重定基数选项</target>
        </trans-unit>
        <trans-unit id="716069514beaa612afd8a844f284c8d0a6aabce4" translate="yes" xml:space="preserve">
          <source>Rebase vs. pull/merge</source>
          <target state="translated">重构与拉拢/合并</target>
        </trans-unit>
        <trans-unit id="5e20f7eeaec14e3dc573b7394eb6cd8341f1bca1" translate="yes" xml:space="preserve">
          <source>Rebase your current HEAD on the last commit you want to retain as-is. For example, if you want to reorder the last 5 commits, use:</source>
          <target state="translated">将你当前的 HEAD 重新排序到你想保留的最后一个提交。例如,如果你想重新排列最后 5 个提交的顺序,可以使用</target>
        </trans-unit>
        <trans-unit id="7170c51391b558eaee43fbe3f7e40861483475fb" translate="yes" xml:space="preserve">
          <source>Rebasing (or any other form of rewriting) a branch that others have based work on is a bad idea: anyone downstream of it is forced to manually fix their history. This section explains how to do the fix from the downstream&amp;rsquo;s point of view. The real fix, however, would be to avoid rebasing the upstream in the first place.</source>
          <target state="translated">对其他人基于其工作的分支重新建立基础（或进行任何其他形式的重写）是一个坏主意：下游的任何人都必须手动修复其历史记录。本节从下游的角度说明如何进行修复。但是，真正的解决方法是首先避免对上游进行重新调整。</target>
        </trans-unit>
        <trans-unit id="8f0767f1f4e33ddf301ed23c7f2cab0332acde8d" translate="yes" xml:space="preserve">
          <source>Rebasing interactively means that you have a chance to edit the commits which are rebased. You can reorder the commits, and you can remove them (weeding out bad or otherwise unwanted patches).</source>
          <target state="translated">交互式重定名意味着你有机会编辑被重定名的提交内容,你可以对提交内容重新排序,也可以删除它们(剔除不好的或不需要的补丁)。你可以对提交的内容进行重新排序,也可以删除它们(剔除坏的或不需要的补丁)。</target>
        </trans-unit>
        <trans-unit id="451ba45ef5ba504d79efe1ccb8ef4e6b541d4b90" translate="yes" xml:space="preserve">
          <source>Rebasing merges</source>
          <target state="translated">重命名合并</target>
        </trans-unit>
        <trans-unit id="f41810dd94a2ab482398f10cf85665624d62733a" translate="yes" xml:space="preserve">
          <source>Recall that merge commits may have more than one parent; by default, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; follow the first parent listed in the commit, but you can also choose:</source>
          <target state="translated">回想一下，合并提交可能有多个父级。默认情况下， &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 遵循提交中列出的第一个父级，但是您也可以选择：</target>
        </trans-unit>
        <trans-unit id="b37c74948935714b7fd73afa3de16cd064ee51d6" translate="yes" xml:space="preserve">
          <source>Recall that the commit which will be committed after we resolve this conflict will have two parents instead of the usual one: one parent will be HEAD, the tip of the current branch; the other will be the tip of the other branch, which is stored temporarily in MERGE_HEAD.</source>
          <target state="translated">回想一下,在我们解决了这个冲突之后,将要提交的提交将有两个父体,而不是通常的一个:一个父体是 HEAD,即当前分支的顶端;另一个是另一个分支的顶端,它暂时存储在 MERGE_HEAD 中。</target>
        </trans-unit>
        <trans-unit id="9f6cd666ff59558e35fc1e4987f55228a4aa839c" translate="yes" xml:space="preserve">
          <source>Receive missing objects from another repository</source>
          <target state="translated">从另一个存储库接收丢失的对象</target>
        </trans-unit>
        <trans-unit id="3a1414f04e5ec5736bdcd32788841a475c616871" translate="yes" xml:space="preserve">
          <source>Receive what is pushed into the repository</source>
          <target state="translated">接收推送到版本库的内容。</target>
        </trans-unit>
        <trans-unit id="ca8f48326e259b3e6bb0b952b7bb30d324f93b41" translate="yes" xml:space="preserve">
          <source>Recipe: Copy maint</source>
          <target state="translated">配方。复制主要内容</target>
        </trans-unit>
        <trans-unit id="53d4283d5e8f18dd173ab180112f372c62ec5838" translate="yes" xml:space="preserve">
          <source>Recipe: Push/pull: Merging remote topics</source>
          <target state="translated">配方:推/拉:合并远程主题</target>
        </trans-unit>
        <trans-unit id="1f8640f7861cc46b56a1e4b42e9ca596b559f6db" translate="yes" xml:space="preserve">
          <source>Recipe: Push/pull: Publishing branches/topics</source>
          <target state="translated">配方:推/拉。出版部门/主题</target>
        </trans-unit>
        <trans-unit id="3a17d2c389fe13fb57af10dbacfb6b3db024c7c4" translate="yes" xml:space="preserve">
          <source>Recipe: Push/pull: Staying up to date</source>
          <target state="translated">配方:推/拉。掌握最新情况</target>
        </trans-unit>
        <trans-unit id="02b6d43b8510b59229854c014a4620861f29d737" translate="yes" xml:space="preserve">
          <source>Recipe: Release tagging</source>
          <target state="translated">配方。释放标签</target>
        </trans-unit>
        <trans-unit id="9d28e02794d321eb00b6d5b97832a596837552b2" translate="yes" xml:space="preserve">
          <source>Recipe: Rewind and rebuild next</source>
          <target state="translated">配方。下一次倒带和重建</target>
        </trans-unit>
        <trans-unit id="f8152ab6d8ec6437faa103dde674cb065aa68613" translate="yes" xml:space="preserve">
          <source>Recipe: Update maint to new release</source>
          <target state="translated">配方。更新主要内容为新版本</target>
        </trans-unit>
        <trans-unit id="29ee8bda8dd5e0f017624c7f75aa875a53804d32" translate="yes" xml:space="preserve">
          <source>Recipe: Verify &lt;em&gt;master&lt;/em&gt; is a superset of &lt;em&gt;maint&lt;/em&gt;</source>
          <target state="translated">配方：验证&lt;em&gt;主&lt;/em&gt;是的超集&lt;em&gt;MAINT&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ffd09f97e74a882a55504c37b0826f564e6b1346" translate="yes" xml:space="preserve">
          <source>Recipe: format-patch/am: Importing patches</source>
          <target state="translated">配方:format-patch/am。导入补丁</target>
        </trans-unit>
        <trans-unit id="363c9c30e4fafba7e8fc9192a52c83213c41b8ac" translate="yes" xml:space="preserve">
          <source>Recipe: format-patch/am: Keeping topics up to date</source>
          <target state="translated">配方:format-patch/am。保持主题的更新</target>
        </trans-unit>
        <trans-unit id="677a69c96c088fbfbe55531cae388f0a94e79290" translate="yes" xml:space="preserve">
          <source>Recipe: format-patch/am: Publishing branches/topics</source>
          <target state="translated">配方:格式-补丁/am。出版部门/主题</target>
        </trans-unit>
        <trans-unit id="7c405acad54185184a3b50d9aee58d7a13bab6ed" translate="yes" xml:space="preserve">
          <source>Recompress, remove unused cruft:</source>
          <target state="translated">再压缩,去掉不用的杂物。</target>
        </trans-unit>
        <trans-unit id="257831ab2bd13a64966a7f962a9574ea39ef3108" translate="yes" xml:space="preserve">
          <source>Record changes to the repository</source>
          <target state="translated">记录对存储库的更改</target>
        </trans-unit>
        <trans-unit id="13168b3a0cbb28fba7cf06c3c640480d4de874bc" translate="yes" xml:space="preserve">
          <source>Record only the fact that the path will be added later. An entry for the path is placed in the index with no content. This is useful for, among other things, showing the unstaged content of such files with &lt;code&gt;git diff&lt;/code&gt; and committing them with &lt;code&gt;git commit
-a&lt;/code&gt;.</source>
          <target state="translated">仅记录以下事实：以后将添加路径。路径的条目放置在索引中，没有内容。除其他功能外，这对于使用 &lt;code&gt;git diff&lt;/code&gt; 显示此类文件的未暂存内容，并使用 &lt;code&gt;git commit -a&lt;/code&gt; 提交它们很有用。</target>
        </trans-unit>
        <trans-unit id="908f8c6524a9d1fb52d4fa427c4917cc570c6355" translate="yes" xml:space="preserve">
          <source>Record that a mark refers to a given object without first creating any new object.</source>
          <target state="translated">记录一个标记指向一个给定的对象,而不首先创建任何新的对象。</target>
        </trans-unit>
        <trans-unit id="59ee078874bbbc459021c0c530f38bc7aaf471b2" translate="yes" xml:space="preserve">
          <source>Record that a mark refers to a given object without first creating any new object. Using --import-marks and referring to missing marks will cause fast-import to fail, so aliases can provide a way to set otherwise pruned commits to a valid value (e.g. the nearest non-pruned ancestor).</source>
          <target state="translated">记录一个标记对给定对象的引用,而不需要先创建任何新对象。使用--import-marks并引用缺失的标记会导致快速导入失败,因此别名可以提供一种方法,将其他修剪过的提交设置为有效值(例如最近的非修剪过的祖先)。</target>
        </trans-unit>
        <trans-unit id="d6adcb873ab9c7cd434052b29bbda78059575713" translate="yes" xml:space="preserve">
          <source>Record the base tree information to identify the state the patch series applies to. See the BASE TREE INFORMATION section below for details. If &amp;lt;commit&amp;gt; is &quot;auto&quot;, a base commit is automatically chosen. The &lt;code&gt;--no-base&lt;/code&gt; option overrides a &lt;code&gt;format.useAutoBase&lt;/code&gt; configuration.</source>
          <target state="translated">记录基础树信息以标识补丁程序系列适用的状态。有关详细信息，请参见下面的&amp;ldquo;基础树信息&amp;rdquo;部分。如果&amp;lt;commit&amp;gt;为&amp;ldquo; auto&amp;rdquo;，则自动选择基本提交。所述 &lt;code&gt;--no-base&lt;/code&gt; 选项覆盖一个 &lt;code&gt;format.useAutoBase&lt;/code&gt; 配置。</target>
        </trans-unit>
        <trans-unit id="1df60f45066883b70333fa04c8ca0ea0ac9a963e" translate="yes" xml:space="preserve">
          <source>Record the pristine state as the first commit in the history.</source>
          <target state="translated">记录原始状态作为历史上第一个承诺。</target>
        </trans-unit>
        <trans-unit id="2779532bfc36fb35edea59aae8e6a7c58766f0fd" translate="yes" xml:space="preserve">
          <source>Records all changes made to the branch tip named &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">记录对名为 &lt;code&gt;name&lt;/code&gt; 的分支提示所做的所有更改。</target>
        </trans-unit>
        <trans-unit id="e26cb9a4392a1984a3c8c89ac8ba4d1939bfa972" translate="yes" xml:space="preserve">
          <source>Records all changes made to the tag named &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">记录对名为 &lt;code&gt;name&lt;/code&gt; 的标记所做的所有更改。</target>
        </trans-unit>
        <trans-unit id="b4426300ccfff51ab94cf09d14eb70cb666bb2d4" translate="yes" xml:space="preserve">
          <source>Records of changes made to refs are stored in this directory. See &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref[1]&lt;/a&gt; for more information. This directory is ignored (except logs/HEAD) if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/logs&quot; will be used instead.</source>
          <target state="translated">对引用所做的更改记录存储在此目录中。有关更多信息，请参见&lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref [1]&lt;/a&gt;。如果设置了$ GIT_COMMON_DIR，则将忽略该目录（日志/ HEAD除外），而将使用&amp;ldquo; $ GIT_COMMON_DIR / logs&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4dfb1dccefe8c5960e96ace8700ff3694a2adfa8" translate="yes" xml:space="preserve">
          <source>Records of conflicted merge you have not resolved are kept for this many days when &lt;code&gt;git rerere gc&lt;/code&gt; is run. You can also use more human-readable &quot;1.month.ago&quot;, etc. The default is 15 days. See &lt;a href=&quot;git-rerere&quot;&gt;git-rerere[1]&lt;/a&gt;.</source>
          <target state="translated">当 &lt;code&gt;git rerere gc&lt;/code&gt; 运行时，您尚未解决的合并冲突的记录会保留许多天。您还可以使用更具可读性的&amp;ldquo; 1.month.ago&amp;rdquo;等。默认值为15天。参见&lt;a href=&quot;git-rerere&quot;&gt;git-rerere [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0041a23358783dc658fb86af817bd1e3c4818754" translate="yes" xml:space="preserve">
          <source>Records of conflicted merge you resolved earlier are kept for this many days when &lt;code&gt;git rerere gc&lt;/code&gt; is run. You can also use more human-readable &quot;1.month.ago&quot;, etc. The default is 60 days. See &lt;a href=&quot;git-rerere&quot;&gt;git-rerere[1]&lt;/a&gt;.</source>
          <target state="translated">当您运行 &lt;code&gt;git rerere gc&lt;/code&gt; 时，您先前解决的合并冲突的记录会保留许多天。您还可以使用更易于理解的&amp;ldquo; 1.month.ago&amp;rdquo;等。默认值为60天。参见&lt;a href=&quot;git-rerere&quot;&gt;git-rerere [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f27ef1289a3377cd529d96e1d59f394c9d2e51b" translate="yes" xml:space="preserve">
          <source>Recovering from repository corruption</source>
          <target state="translated">从存储库损坏中恢复</target>
        </trans-unit>
        <trans-unit id="45b084fa0ec2bcf4d8887dcc1ed74808ce39dd65" translate="yes" xml:space="preserve">
          <source>Recovering from upstream rebase</source>
          <target state="translated">从上游重基中恢复</target>
        </trans-unit>
        <trans-unit id="a2b2e17c2700a078248ea4a8793fdeb963f1e774" translate="yes" xml:space="preserve">
          <source>Recovering lost changes</source>
          <target state="translated">恢复丢失的变更</target>
        </trans-unit>
        <trans-unit id="c9f9ed2d4080ff53397fc95e602ba0c0a8018150" translate="yes" xml:space="preserve">
          <source>Recovering stash entries that were cleared/dropped erroneously</source>
          <target state="translated">恢复被错误清除/丢弃的存储条目。</target>
        </trans-unit>
        <trans-unit id="07417b29bf5742eeb9def793a7c341803a4ae6cf" translate="yes" xml:space="preserve">
          <source>Recurse into sub-trees.</source>
          <target state="translated">递进成子树。</target>
        </trans-unit>
        <trans-unit id="b71ca4a78b12182052bd243bd7fb2b5a8710c342" translate="yes" xml:space="preserve">
          <source>Recursively calls ls-files on each submodule in the repository. Currently there is only support for the --cached mode.</source>
          <target state="translated">循环调用版本库中每个子模块的ls-files。目前只支持-缓存模式。</target>
        </trans-unit>
        <trans-unit id="9594ad54e61dba1e097011c1262a0e12523ac73c" translate="yes" xml:space="preserve">
          <source>Recursively copies an existing file or subdirectory to a different location within the branch. The existing file or directory must exist. If the destination exists it will be completely replaced by the content copied from the source.</source>
          <target state="translated">递归地将现有的文件或子目录复制到分支的不同位置。现有的文件或目录必须存在。如果目的地存在,它将被从源文件复制的内容完全取代。</target>
        </trans-unit>
        <trans-unit id="784c487e0b0ebf6146a806df2269e12c1733d014" translate="yes" xml:space="preserve">
          <source>Recursively finds and lists the svn:ignore property on directories. The output is suitable for appending to the $GIT_DIR/info/exclude file.</source>
          <target state="translated">递归查找并列出目录上的svn:ignore属性。其输出适合于追加到$GIT_DIR/info/exclude文件中。</target>
        </trans-unit>
        <trans-unit id="8a1182cccab09515529f5c8d920459a7ff2c3ff2" translate="yes" xml:space="preserve">
          <source>Recursively finds the svn:ignore property on directories and creates matching .gitignore files. The resulting files are staged to be committed, but are not committed. Use -r/--revision to refer to a specific revision.</source>
          <target state="translated">递归查找目录的svn:ignore属性,并创建匹配的.gitignore文件。所产生的文件会被暂存以待提交,但不会被提交。使用 -r/--revision 来引用一个特定的修订版。</target>
        </trans-unit>
        <trans-unit id="8cf2dd32a75d92cd5c31b8e357091014ef76d06b" translate="yes" xml:space="preserve">
          <source>Recursively search in each submodule that has been initialized and checked out in the repository. When used in combination with the &amp;lt;tree&amp;gt; option the prefix of all submodule output will be the name of the parent project&amp;rsquo;s &amp;lt;tree&amp;gt; object.</source>
          <target state="translated">在资源库中已初始化并检出的每个子模块中递归搜索。当与&amp;lt;tree&amp;gt;选项结合使用时，所有子模块输出的前缀将是父项目的&amp;lt;tree&amp;gt;对象的名称。</target>
        </trans-unit>
        <trans-unit id="c70c81b356beafd0eeca89b16d9fdcb5f7371848" translate="yes" xml:space="preserve">
          <source>Redirection to a file (&lt;code&gt;/path/name&lt;/code&gt;) or pipe (&lt;code&gt;|command&lt;/code&gt;) is not supported.</source>
          <target state="translated">不支持重定向到文件（ &lt;code&gt;/path/name&lt;/code&gt; ）或管道（ &lt;code&gt;|command&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="89381280eddd66ed8601a4438d83804ded19d6ef" translate="yes" xml:space="preserve">
          <source>Reencoding content requires resources that might slow down certain Git operations (e.g &lt;code&gt;git checkout&lt;/code&gt; or &lt;code&gt;git add&lt;/code&gt;).</source>
          <target state="translated">重新编码内容需要的资源可能会减慢某些Git操作的速度（例如 &lt;code&gt;git checkout&lt;/code&gt; 或 &lt;code&gt;git add&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4d5f4726578da60b5802012abfa0452d24f12476" translate="yes" xml:space="preserve">
          <source>Reencoding content to non-UTF encodings can cause errors as the conversion might not be UTF-8 round trip safe. If you suspect your encoding to not be round trip safe, then add it to &lt;code&gt;core.checkRoundtripEncoding&lt;/code&gt; to make Git check the round trip encoding (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). SHIFT-JIS (Japanese character set) is known to have round trip issues with UTF-8 and is checked by default.</source>
          <target state="translated">将内容重新编码为非UTF编码会导致错误，因为此转换可能不是UTF-8往返安全的。如果您怀疑编码不是往返安全，则将其添加到 &lt;code&gt;core.checkRoundtripEncoding&lt;/code&gt; ,以使Git检查往返编码（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。已知SHIFT-JIS（日语字符集）在UTF-8中有往返问题，并且默认情况下已选中。</target>
        </trans-unit>
        <trans-unit id="f60624f9fc2a82abf8497341d9d81b9d0824e3d8" translate="yes" xml:space="preserve">
          <source>Ref list attributes</source>
          <target state="translated">参考列表属性</target>
        </trans-unit>
        <trans-unit id="042501eba486c2a8fe3dfeebed7e6a526acc65b2" translate="yes" xml:space="preserve">
          <source>Refer to trace2.h for details about all trace2 functions.</source>
          <target state="translated">关于所有trace2函数的细节,请参考trace2.h。</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="8189e74b00341c8128de1c9b04b6630dfed40f88" translate="yes" xml:space="preserve">
          <source>Reference advertisement will be omitted unless explicitly requested</source>
          <target state="translated">除非明确要求,否则将省略参考广告。</target>
        </trans-unit>
        <trans-unit id="219616f872f3c1f3f7c63db96c4bad5707f937ab" translate="yes" xml:space="preserve">
          <source>Reference logs, or &quot;reflogs&quot;, record when the tips of branches and other references were updated in the local repository. Reflogs are useful in various Git commands, to specify the old value of a reference. For example, &lt;code&gt;HEAD@{2}&lt;/code&gt; means &quot;where HEAD used to be two moves ago&quot;, &lt;code&gt;master@{one.week.ago}&lt;/code&gt; means &quot;where master used to point to one week ago in this local repository&quot;, and so on. See &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for more details.</source>
          <target state="translated">参考日志或&amp;ldquo;参考日志&amp;rdquo;记录何时在本地存储库中更新了分支的提示和其他参考。 Reflog在各种Git命令中很有用，用于指定引用的旧值。例如， &lt;code&gt;HEAD@{2}&lt;/code&gt; 表示&amp;ldquo; HEAD以前是两个动作之前的位置&amp;rdquo;， &lt;code&gt;master@{one.week.ago}&lt;/code&gt; @ { one.week.ago}表示&amp;ldquo; master在此本地存储库中以前指向一周的位置&amp;rdquo;，依此类推。有关更多详细信息，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="fdc0add895cb5f66656ac926ee760b1a52ebfc92" translate="yes" xml:space="preserve">
          <source>References are stored in subdirectories of this directory. The &lt;code&gt;git prune&lt;/code&gt; command knows to preserve objects reachable from refs found in this directory and its subdirectories. This directory is ignored (except refs/bisect, refs/rewritten and refs/worktree) if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/refs&quot; will be used instead.</source>
          <target state="translated">引用存储在此目录的子目录中。该 &lt;code&gt;git prune&lt;/code&gt; 命令知道要保留对象从裁判到达此目录及其子目录中找到。如果设置了$ GIT_COMMON_DIR，则将忽略此目录（refs / bisect，refs / rewrite和refs / worktree除外），而将使用&amp;ldquo; $ GIT_COMMON_DIR / refs&amp;rdquo;代替。</target>
        </trans-unit>
        <trans-unit id="a774e5bc9f4a8942d74474f466fea367c3f9fc07" translate="yes" xml:space="preserve">
          <source>References to commit objects at the head of each branch are stored in files under .git/refs/heads/.</source>
          <target state="translated">每个分支头部的提交对象的引用都存储在.git/refs/heads/下的文件中。</target>
        </trans-unit>
        <trans-unit id="586454a22a42afbc6e2564872cf76fa552b4a1a3" translate="yes" xml:space="preserve">
          <source>Reflogs</source>
          <target state="translated">Reflogs</target>
        </trans-unit>
        <trans-unit id="701486a68f3896a8a5368aead277807a6847151f" translate="yes" xml:space="preserve">
          <source>Refs</source>
          <target state="translated">Refs</target>
        </trans-unit>
        <trans-unit id="80074f188ddb96f7955691b6a7210a31a672772d" translate="yes" xml:space="preserve">
          <source>Refs are grouped into islands based on their &quot;names&quot;, and two regexes that produce the same name are considered to be in the same island. The names are computed from the regexes by concatenating any capture groups from the regex, with a &lt;code&gt;-&lt;/code&gt; dash in between. (And if there are no capture groups, then the name is the empty string, as in the above example.) This allows you to create arbitrary numbers of islands. Only up to 14 such capture groups are supported though.</source>
          <target state="translated">引用根据其&amp;ldquo;名称&amp;rdquo;分组到各个岛中，并且两个产生相同名称的正则表达式被视为在同一岛中。这些名称是通过将正则表达式中的任何捕获组连接在一起而在正则表达式中计算出来的，中间有 &lt;code&gt;-&lt;/code&gt; 破折号。（并且，如果没有捕获组，则名称为空字符串，如上例所示。）这使您可以创建任意数量的孤岛。但是，最多仅支持14个此类捕获组。</target>
        </trans-unit>
        <trans-unit id="2bb2083cc2f447acfd0f5d16022129235ca5b2cc" translate="yes" xml:space="preserve">
          <source>Refs that are per working tree can still be accessed from another working tree via two special paths, main-worktree and worktrees. The former gives access to per-worktree refs of the main working tree, while the latter to all linked working trees.</source>
          <target state="translated">每棵工作树的参考文献仍然可以通过两种特殊路径,即主工作树和工作树,从另一棵工作树访问。前者可以访问主工作树的每个工作树的参考文献,而后者可以访问所有链接的工作树。</target>
        </trans-unit>
        <trans-unit id="05e5994fa9181b6fad85ee509538c0ad6a6bc5c4" translate="yes" xml:space="preserve">
          <source>Refs that are per-&lt;a href=&quot;#def_working_tree&quot;&gt;worktree&lt;/a&gt;, rather than global. This is presently only &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; and any refs that start with &lt;code&gt;refs/bisect/&lt;/code&gt;, but might later include other unusual refs.</source>
          <target state="translated">&lt;a href=&quot;#def_working_tree&quot;&gt;引用&lt;/a&gt;是perworktree，而不是全局。目前这只是&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;以及以 &lt;code&gt;refs/bisect/&lt;/code&gt; 开头的所有ref ，但以后可能还会包含其他异常的ref。</target>
        </trans-unit>
        <trans-unit id="338d2a0e12d851337309cef01e7fe887153b0f55" translate="yes" xml:space="preserve">
          <source>Regardless of object type, all objects share the following characteristics: they are all deflated with zlib, and have a header that not only specifies their type, but also provides size information about the data in the object. It&amp;rsquo;s worth noting that the SHA-1 hash that is used to name the object is the hash of the original data plus this header, so &lt;code&gt;sha1sum&lt;/code&gt; 'file' does not match the object name for 'file'.</source>
          <target state="translated">无论对象类型如何，所有对象都具有以下特征：它们都使用zlib压缩，并且具有一个标头，该标头不仅指定其类型，还提供有关对象中数据的大小信息。值得注意的是，用于命名对象的SHA-1哈希是原始数据加上此标头的哈希，因此 &lt;code&gt;sha1sum&lt;/code&gt; 'file '与'file'的对象名不匹配。</target>
        </trans-unit>
        <trans-unit id="710a95e624a3349545888a56ed2557d883a0ebee" translate="yes" xml:space="preserve">
          <source>Region and Data Messages</source>
          <target state="translated">区域和数据信息</target>
        </trans-unit>
        <trans-unit id="039711232507cd9753ddba093da2350b27e67dca" translate="yes" xml:space="preserve">
          <source>Regions</source>
          <target state="translated">Regions</target>
        </trans-unit>
        <trans-unit id="f60734f6521040c876486255fe253adea3ef4364" translate="yes" xml:space="preserve">
          <source>Regions can be use to time an interesting section of code.</source>
          <target state="translated">区域可以用来为一段有趣的代码计时。</target>
        </trans-unit>
        <trans-unit id="e6931aebd376c6a517eae391382acbc891d72f65" translate="yes" xml:space="preserve">
          <source>Regions may be nested. This causes messages to be indented in the PERF target, for example. Elapsed times are relative to the start of the corresponding nesting level as expected. For example, if we add region message to:</source>
          <target state="translated">区域可以被嵌套。例如,这会导致消息在PERF目标中缩进。经过的时间是相对于相应的嵌套级别的开始而言的,这是预期的。例如,如果我们将区域消息添加到。</target>
        </trans-unit>
        <trans-unit id="1595f1bb6d790a7a3e5eb6fb03765aabf279806d" translate="yes" xml:space="preserve">
          <source>Register file contents in the working tree to the index</source>
          <target state="translated">将工作树中的文件内容注册到索引中。</target>
        </trans-unit>
        <trans-unit id="8a6eb409adc691aa11f00dc05c7a129c2f833328" translate="yes" xml:space="preserve">
          <source>Regressions are a big problem in the software industry. But it&amp;rsquo;s difficult to put some real numbers behind that claim.</source>
          <target state="translated">回归是软件行业中的一个大问题。但是很难在这个说法后面加上一些实际数字。</target>
        </trans-unit>
        <trans-unit id="4ab9d6c175961a8739069a73845c7f8b21150d86" translate="yes" xml:space="preserve">
          <source>Regressions: a big problem</source>
          <target state="translated">回归:一个大问题</target>
        </trans-unit>
        <trans-unit id="2256cc6ee2a5d077491a8a63ef76ac743c25d2d2" translate="yes" xml:space="preserve">
          <source>Related links</source>
          <target state="translated">相关链接</target>
        </trans-unit>
        <trans-unit id="b61e20d1d031c57060b03654349b1ab448029094" translate="yes" xml:space="preserve">
          <source>Relationship to the Existing Trace Api (api-trace.txt)</source>
          <target state="translated">与现有跟踪 API 的关系 (api-trace.txt)</target>
        </trans-unit>
        <trans-unit id="a5807b40eca9f80054603fbc4a7d22e009d2c415" translate="yes" xml:space="preserve">
          <source>Relative and non-relative marks may be combined by interweaving --(no-)-relative-marks with the --(import|export)-marks= options.</source>
          <target state="translated">通过将--(no-)-关系标记与--(import|export)-标记=选项交织在一起,可以将相对标记和非关系标记结合起来。</target>
        </trans-unit>
        <trans-unit id="31bc43768c6a353840de5e162fcf9b5cce4d9437" translate="yes" xml:space="preserve">
          <source>Relative to the tip of &lt;code&gt;topic&lt;/code&gt;: knowing that your &lt;code&gt;topic&lt;/code&gt; has three commits, the old tip of &lt;code&gt;subsystem&lt;/code&gt; must be &lt;code&gt;topic~3&lt;/code&gt;.</source>
          <target state="translated">相对于 &lt;code&gt;topic&lt;/code&gt; 提示：知道您的 &lt;code&gt;topic&lt;/code&gt; 有3个提交， &lt;code&gt;subsystem&lt;/code&gt; 的旧提示必须是 &lt;code&gt;topic~3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98786341673b229d09cd6bac6df5f38262cac094" translate="yes" xml:space="preserve">
          <source>Remain silent even on nonexistent files</source>
          <target state="translated">即使在不存在的文件上也保持沉默。</target>
        </trans-unit>
        <trans-unit id="cad2c2939c304ff819eff58f792783f6747c93cf" translate="yes" xml:space="preserve">
          <source>Remap all the path requests as relative to the given path. This is sort of &quot;Git root&quot; - if you run &lt;code&gt;git daemon&lt;/code&gt; with &lt;code&gt;--base-path=/srv/git&lt;/code&gt; on example.com, then if you later try to pull &lt;code&gt;git://example.com/hello.git&lt;/code&gt;, &lt;code&gt;git daemon&lt;/code&gt; will interpret the path as &lt;code&gt;/srv/git/hello.git&lt;/code&gt;.</source>
          <target state="translated">将所有路径请求重新映射为相对于给定路径。这有点像&amp;ldquo; Git根目录&amp;rdquo;-如果在example.com上使用 &lt;code&gt;--base-path=/srv/git&lt;/code&gt; 运行 &lt;code&gt;git daemon&lt;/code&gt; ，那么以后再尝试拉 &lt;code&gt;git://example.com/hello.git&lt;/code&gt; 时， &lt;code&gt;git daemon&lt;/code&gt; 会将路径解释为 &lt;code&gt;/srv/git/hello.git&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a5c393fce9fb8dc0d691f13288d22c0e7f1b235" translate="yes" xml:space="preserve">
          <source>Remap to ancestor</source>
          <target state="translated">重映射到祖先</target>
        </trans-unit>
        <trans-unit id="8d0121936c456fcf3d222b828ee9077e2cc34843" translate="yes" xml:space="preserve">
          <source>Remember how we did the &lt;code&gt;git update-index&lt;/code&gt; on file &lt;code&gt;hello&lt;/code&gt; and then we changed &lt;code&gt;hello&lt;/code&gt; afterward, and could compare the new state of &lt;code&gt;hello&lt;/code&gt; with the state we saved in the index file?</source>
          <target state="translated">还记得我们如何在文件 &lt;code&gt;hello&lt;/code&gt; 上执行 &lt;code&gt;git update-index&lt;/code&gt; ，然后又更改了 &lt;code&gt;hello&lt;/code&gt; ，并且可以将 &lt;code&gt;hello&lt;/code&gt; 的新状态与保存在索引文件中的状态进行比较吗？</target>
        </trans-unit>
        <trans-unit id="2cc52de1f31f7df8236151d526db4f676cdfb905" translate="yes" xml:space="preserve">
          <source>Remember, before running &lt;code&gt;git merge&lt;/code&gt;, our &lt;code&gt;master&lt;/code&gt; head was at &quot;Some fun.&quot; commit, while our &lt;code&gt;mybranch&lt;/code&gt; head was at &quot;Some work.&quot; commit.</source>
          <target state="translated">记住，在运行 &lt;code&gt;git merge&lt;/code&gt; 之前，我们的 &lt;code&gt;master&lt;/code&gt; 负责人是&amp;ldquo; Some fun&amp;rdquo;。承诺，而我们的 &lt;code&gt;mybranch&lt;/code&gt; 正忙于 &amp;ldquo;一些工作&amp;rdquo;。承诺。</target>
        </trans-unit>
        <trans-unit id="3e534e3639a4dd02297fd7fd07ede8a71c71535e" translate="yes" xml:space="preserve">
          <source>Remote HEAD must resolve to an object that exists locally</source>
          <target state="translated">远程HEAD必须解析到本地存在的对象。</target>
        </trans-unit>
        <trans-unit id="2033891925fe29daa47f6c451af0f18a87529563" translate="yes" xml:space="preserve">
          <source>Remote helper programs are invoked with one or (optionally) two arguments. The first argument specifies a remote repository as in Git; it is either the name of a configured remote or a URL. The second argument specifies a URL; it is usually of the form &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt;, but any arbitrary string is possible. The &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable is set up for the remote helper and can be used to determine where to store additional data or from which directory to invoke auxiliary Git commands.</source>
          <target state="translated">使用一个或（可选）两个参数调用远程帮助程序。第一个参数指定一个远程存储库，如Git中所示；它是配置的遥​​控器的名称或URL。第二个参数指定一个URL；它通常采用 &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt; 的形式，但是任何任意字符串都是可能的。所述 &lt;code&gt;GIT_DIR&lt;/code&gt; 环境变量设置为所述远程辅助，并且可以被用于确定在哪里存储附加数据或从该目录调用辅助GIT中的命令。</target>
        </trans-unit>
        <trans-unit id="8ee4f73d380c3c99d59209a069206bbd667c2977" translate="yes" xml:space="preserve">
          <source>Remote helper programs are normally not used directly by end users, but they are invoked by Git when it needs to interact with remote repositories Git does not support natively. A given helper will implement a subset of the capabilities documented here. When Git needs to interact with a repository using a remote helper, it spawns the helper as an independent process, sends commands to the helper&amp;rsquo;s standard input, and expects results from the helper&amp;rsquo;s standard output. Because a remote helper runs as an independent process from Git, there is no need to re-link Git to add a new helper, nor any need to link the helper with the implementation of Git.</source>
          <target state="translated">最终用户通常不直接使用远程帮助程序，但是当Git需要与远程存储库进行交互时，Git会调用它们，而Git本身不支持。给定的帮助者将实现此处记录的功能的子集。当Git需要使用远程帮助程序与存储库进行交互时，它会将帮助程序作为独立的进程生成，将命令发送到该帮助程序的标准输入，并期望该帮助程序的标准输出产生结果。因为远程帮助程序是作为独立于Git的独立进程运行的，所以无需重新链接Git以添加新的帮助程序，也无需将帮助程序与Git的实现进行链接。</target>
        </trans-unit>
        <trans-unit id="7f9d958435b39dd5e8519bc9a5ca0b414455c52e" translate="yes" xml:space="preserve">
          <source>Remotes</source>
          <target state="translated">Remotes</target>
        </trans-unit>
        <trans-unit id="1d36d5e98f5289fdb40f6238091d921b16cd3d1b" translate="yes" xml:space="preserve">
          <source>Remove &amp;lt;n&amp;gt; leading path components (separated by slashes) from traditional diff paths. E.g., with &lt;code&gt;-p2&lt;/code&gt;, a patch against &lt;code&gt;a/dir/file&lt;/code&gt; will be applied directly to &lt;code&gt;file&lt;/code&gt;. The default is 1.</source>
          <target state="translated">从传统差异路径中删除&amp;lt;n&amp;gt;前导路径部分（以斜杠分隔）。例如，使用 &lt;code&gt;-p2&lt;/code&gt; ，针对 &lt;code&gt;a/dir/file&lt;/code&gt; 的补丁将直接应用于 &lt;code&gt;file&lt;/code&gt; 。预设值为1。</target>
        </trans-unit>
        <trans-unit id="536f22b2b28f4e056331357f5ffb90610418f296" translate="yes" xml:space="preserve">
          <source>Remove &amp;lt;ref&amp;gt; from remote repository. The specified branch cannot be the remote HEAD. If -d is specified the following other conditions must also be met:</source>
          <target state="translated">从远程存储库中删除&amp;lt;ref&amp;gt;。指定的分支不能是远程HEAD。如果指定了-d，则还必须满足以下其他条件：</target>
        </trans-unit>
        <trans-unit id="9a577cbb08edd5d9773523cfc5cfe43dc9b03f45" translate="yes" xml:space="preserve">
          <source>Remove a single stash entry from the list of stash entries. When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, it removes the latest one. i.e. &lt;code&gt;stash@{0}&lt;/code&gt;, otherwise &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; must be a valid stash log reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">从存储条目列表中删除一个存储条目。如果没有给出 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; ，它将删除最新的。即 &lt;code&gt;stash@{0}&lt;/code&gt; ，否则 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 必须是有效的 &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 形式的隐藏日志引用。</target>
        </trans-unit>
        <trans-unit id="729e5fd8775c30c358fedf9e611fd4f6f670b5e7" translate="yes" xml:space="preserve">
          <source>Remove a single stashed state from the stash list and apply it on top of the current working tree state, i.e., do the inverse operation of &lt;code&gt;git stash push&lt;/code&gt;. The working directory must match the index.</source>
          <target state="translated">从存储列表中删除单个存储状态，并将其应用到当前工作树状态的顶部，即执行 &lt;code&gt;git stash push&lt;/code&gt; 的逆操作。工作目录必须与索引匹配。</target>
        </trans-unit>
        <trans-unit id="d34ae9e19d54c7604c479f4c5964ccef00bd4a98" translate="yes" xml:space="preserve">
          <source>Remove a working tree. Only clean working trees (no untracked files and no modification in tracked files) can be removed. Unclean working trees or ones with submodules can be removed with &lt;code&gt;--force&lt;/code&gt;. The main working tree cannot be removed.</source>
          <target state="translated">删除工作树。只能删除干净的工作树（没有未跟踪的文件，也没有对跟踪文件的修改）。不干净的工作树或带有子模块的树可以使用 &lt;code&gt;--force&lt;/code&gt; 删除。主工作树无法删除。</target>
        </trans-unit>
        <trans-unit id="df5a8d70d2380181bdc059d7c2ddc0a78e9d1412" translate="yes" xml:space="preserve">
          <source>Remove all lines matching the key from config file.</source>
          <target state="translated">删除配置文件中所有与密钥匹配的行。</target>
        </trans-unit>
        <trans-unit id="9fc0230ddf082dc45699878be1634350de11665f" translate="yes" xml:space="preserve">
          <source>Remove all notes for non-existing/unreachable objects.</source>
          <target state="translated">删除所有不存在的/无法到达的对象的注释。</target>
        </trans-unit>
        <trans-unit id="fc1b4600e49f3115828b9f3463a6567fd85094fb" translate="yes" xml:space="preserve">
          <source>Remove all the stash entries. Note that those entries will then be subject to pruning, and may be impossible to recover (see &lt;code&gt;Examples&lt;/code&gt; below for a possible strategy).</source>
          <target state="translated">删除所有隐藏条目。请注意，这些条目将随后被修剪，并且可能无法恢复（有关可能的策略，请参见下面的 &lt;code&gt;Examples&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="353e52e76ff6a9350e8485da73b547859aa497ce" translate="yes" xml:space="preserve">
          <source>Remove any whitespace-continuation in trailers, so that each trailer appears on a line by itself with its full content.</source>
          <target state="translated">删除预告片中的任何空白处,使每个预告片与其完整的内容单独成一行。</target>
        </trans-unit>
        <trans-unit id="de112945ec414c57cddaca5199f29ee2fc05a979" translate="yes" xml:space="preserve">
          <source>Remove directories from the SVN tree if there are no files left behind. SVN can version empty directories, and they are not removed by default if there are no files left in them. Git cannot version empty directories. Enabling this flag will make the commit to SVN act like Git.</source>
          <target state="translated">如果没有文件留下,就从SVN树中删除目录。SVN 可以对空目录进行版本更新,如果没有文件留下,默认情况下不会删除。Git 不能对空目录进行版本更新。启用这个标志会使提交到 SVN 的行为和 Git 一样。</target>
        </trans-unit>
        <trans-unit id="7e6c07487aafd5a1b8bbc132d0eb9f70eb39a580" translate="yes" xml:space="preserve">
          <source>Remove everything in body before a scissors line (see &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;). Can be activated by default using the &lt;code&gt;mailinfo.scissors&lt;/code&gt; configuration variable.</source>
          <target state="translated">&lt;a href=&quot;git-mailinfo&quot;&gt;剪掉&lt;/a&gt;剪刀线之前，清除身上的所有东西（请参阅git-mailinfo [1]）。可以使用 &lt;code&gt;mailinfo.scissors&lt;/code&gt; 配置变量默认激活。</target>
        </trans-unit>
        <trans-unit id="399fc61abd5e53e0ff9fe12417324d78f931368d" translate="yes" xml:space="preserve">
          <source>Remove everything in body before a scissors line. A line that mainly consists of scissors (either &quot;&amp;gt;8&quot; or &quot;8&amp;lt;&quot;) and perforation (dash &quot;-&quot;) marks is called a scissors line, and is used to request the reader to cut the message at that line. If such a line appears in the body of the message before the patch, everything before it (including the scissors line itself) is ignored when this option is used.</source>
          <target state="translated">剪掉剪刀线之前，先清除体内的所有东西。主要由剪刀（&amp;ldquo;&amp;gt; 8&amp;rdquo;或&amp;ldquo; 8 &amp;lt;&amp;rdquo;）和穿孔（破折号&amp;ldquo;-&amp;rdquo;）标记组成的行称为剪刀行，用于请求读者在该行处剪切消息。如果在修补程序之前的消息正文中出现这样的行，则使用此选项时，将忽略该行之前的所有内容（包括剪刀行本身）。</target>
        </trans-unit>
        <trans-unit id="3b6a842b7003d3eacad12733ce8974d4d54219eb" translate="yes" xml:space="preserve">
          <source>Remove extra objects that are already in pack files</source>
          <target state="translated">删除包文件中已有的额外对象</target>
        </trans-unit>
        <trans-unit id="17839ee8fd6b46f8390b41c3ab4800fda5ea86c3" translate="yes" xml:space="preserve">
          <source>Remove files from the index, or from the working tree and the index. &lt;code&gt;git rm&lt;/code&gt; will not remove a file from just your working directory. (There is no option to remove a file only from the working tree and yet keep it in the index; use &lt;code&gt;/bin/rm&lt;/code&gt; if you want to do that.) The files being removed have to be identical to the tip of the branch, and no updates to their contents can be staged in the index, though that default behavior can be overridden with the &lt;code&gt;-f&lt;/code&gt; option. When &lt;code&gt;--cached&lt;/code&gt; is given, the staged content has to match either the tip of the branch or the file on disk, allowing the file to be removed from just the index.</source>
          <target state="translated">从索引或工作树和索引中删除文件。 &lt;code&gt;git rm&lt;/code&gt; 不会仅从您的工作目录中删除文件。 （没有选择仅从工作树中删除文件，而是将其保留在索引中的选项；如果要这样做，请使用 &lt;code&gt;/bin/rm&lt;/code&gt; 。）要删除的文件必须与分支的尖端相同，尽管可以使用 &lt;code&gt;-f&lt;/code&gt; 选项覆盖默认行为，但无法在索引中暂存对其内容的更新。当 &lt;code&gt;--cached&lt;/code&gt; 给出，分级内容具有相匹配的分支的任一末端或磁盘上的文件，从而允许从刚刚索引中删除该文件。</target>
        </trans-unit>
        <trans-unit id="3cb238ca5adf89378484ddf4d733eeac1d7298bc" translate="yes" xml:space="preserve">
          <source>Remove files from the working tree and from the index</source>
          <target state="translated">从工作树和索引中删除文件。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
