<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="9f1df172d790d81927bf10eb32b7a53862fd94a5" translate="yes" xml:space="preserve">
          <source>Interrupted workflow</source>
          <target state="translated">工作流程中断</target>
        </trans-unit>
        <trans-unit id="b566252f7afe805214a7771e6b2a586b4e458c82" translate="yes" xml:space="preserve">
          <source>Introduction to &quot;git bisect&quot;</source>
          <target state="translated">&quot;git bisect &quot;介绍</target>
        </trans-unit>
        <trans-unit id="273a20c96a580af6e0e1fc6c4491680cd6e13de6" translate="yes" xml:space="preserve">
          <source>Intuitiveness is not the goal here. Repeatability is. The reason for the &quot;no arguments means no work&quot; behavior is that from scripts you are supposed to be able to do:</source>
          <target state="translated">直观性不是这里的目标。可重复性才是。之所以有 &quot;没有参数就意味着没有工作 &quot;的行为,是因为从脚本中你应该能够做到。</target>
        </trans-unit>
        <trans-unit id="6a9b44369c96eafd66d755034e5ce80488ad8832" translate="yes" xml:space="preserve">
          <source>Invocation</source>
          <target state="translated">Invocation</target>
        </trans-unit>
        <trans-unit id="1d5f124f7b2f261867ec41e2c056658bb6e88c34" translate="yes" xml:space="preserve">
          <source>Invoke a text editor (see GIT_EDITOR in &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt;) to edit an introductory message for the patch series.</source>
          <target state="translated">调用文本编辑器（请参阅&lt;a href=&quot;git-var&quot;&gt;git-var [1]中的&lt;/a&gt; GIT_EDITOR ）来编辑补丁系列的介绍性消息。</target>
        </trans-unit>
        <trans-unit id="9ba2ef7b89376be98d487b046c212677da3221b4" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged).</source>
          <target state="translated">提交成功的机械合并之前，请调用编辑器以进一步编辑自动生成的合并消息，以便用户可以解释并证明合并的合理性。所述 &lt;code&gt;--no-edit&lt;/code&gt; 选项可用于接受自动生成的消息（这通常泄气）。</target>
        </trans-unit>
        <trans-unit id="a978683542367bbc42f0a41dd9d11a4a00c553d9" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged). The &lt;code&gt;--edit&lt;/code&gt; (or &lt;code&gt;-e&lt;/code&gt;) option is still useful if you are giving a draft message with the &lt;code&gt;-m&lt;/code&gt; option from the command line and want to edit it in the editor.</source>
          <target state="translated">提交成功的机械合并之前，请调用编辑器以进一步编辑自动生成的合并消息，以便用户可以解释并证明合并的合理性。所述 &lt;code&gt;--no-edit&lt;/code&gt; 选项可用于接受自动生成的消息（这通常泄气）。该 &lt;code&gt;--edit&lt;/code&gt; （或 &lt;code&gt;-e&lt;/code&gt; ）选项仍然是有用的，如果你给同一个消息草稿 &lt;code&gt;-m&lt;/code&gt; 命令行选项，并希望在编辑器中编辑它。</target>
        </trans-unit>
        <trans-unit id="ab51558f752b86c08b9c277e1cd35bd4f5da28bc" translate="yes" xml:space="preserve">
          <source>Invoke the sendemail-validate hook if present (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">调用sendemail-validate挂钩（如果存在）（请参阅&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6307458f7efb25e5d4237ad7a4e972e464f2ab54" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git archive --remote&lt;/code&gt; and sends a generated archive to the other end over the Git protocol.</source>
          <target state="translated">由 &lt;code&gt;git archive --remote&lt;/code&gt; 调用，并通过Git协议将生成的存档发送到另一端。</target>
        </trans-unit>
        <trans-unit id="4591feb10dd06f62e310d9c287cf3f981ce9babf" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git fetch-pack&lt;/code&gt;, learns what objects the other side is missing, and sends them after packing.</source>
          <target state="translated">由 &lt;code&gt;git fetch-pack&lt;/code&gt; 调用，了解另一侧缺少哪些对象，并在打包后将其发送。</target>
        </trans-unit>
        <trans-unit id="a7f91dd525c007f2b681e8a032a0618f9a34ea1c" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git send-pack&lt;/code&gt; and updates the repository with the information fed from the remote end.</source>
          <target state="translated">由 &lt;code&gt;git send-pack&lt;/code&gt; 调用，并使用远程端提供的信息更新存储库。</target>
        </trans-unit>
        <trans-unit id="d65563f7b9f547034dceec39b8ac04f9c683c150" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-receive-pack&lt;/code&gt; on a possibly remote repository, and updates it from the current repository, sending named refs.</source>
          <target state="translated">在可能的远程存储库上调用 &lt;code&gt;git-receive-pack&lt;/code&gt; ，并从当前存储库更新它，发送命名的refs。</target>
        </trans-unit>
        <trans-unit id="b53ca0a7337f2511de77389036559a87c502bc3d" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-upload-pack&lt;/code&gt; on a possibly remote repository and asks it to send objects missing from this repository, to update the named heads. The list of commits available locally is found out by scanning the local refs/ hierarchy and sent to &lt;code&gt;git-upload-pack&lt;/code&gt; running on the other end.</source>
          <target state="translated">在可能是远程的存储库上调用 &lt;code&gt;git-upload-pack&lt;/code&gt; ，并要求它发送该存储库中缺少的对象，以更新命名的头部。通过扫描本地引用/层次结构可以找到本地可用的提交列表，并将其发送到另一端运行的 &lt;code&gt;git-upload-pack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a31ffeaabebc608f725ad5aea0019f330d8c2ea7" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;git add -e&lt;/code&gt; or selecting &lt;code&gt;e&lt;/code&gt; from the interactive hunk selector will open a patch in your editor; after the editor exits, the result is applied to the index. You are free to make arbitrary changes to the patch, but note that some changes may have confusing results, or even result in a patch that cannot be applied. If you want to abort the operation entirely (i.e., stage nothing new in the index), simply delete all lines of the patch. The list below describes some common things you may see in a patch, and which editing operations make sense on them.</source>
          <target state="translated">调用 &lt;code&gt;git add -e&lt;/code&gt; 或从交互式块选择器中选择 &lt;code&gt;e&lt;/code&gt; 将在编辑器中打开一个补丁。编辑器退出后，结果将应用于索引。您可以随意对补丁进行任何更改，但是请注意，某些更改可能会导致混乱的结果，甚至导致无法应用的补丁。如果要完全中止该操作（即，暂无索引中的新内容），只需删除补丁的所有行。下面的列表描述了您可能会在补丁中看到的一些常见内容，以及对其进行哪些编辑操作才有意义。</target>
        </trans-unit>
        <trans-unit id="7eda501750cd6c5e49ea1b4fd74542b592feab87" translate="yes" xml:space="preserve">
          <source>Involving QA people and if possible end users</source>
          <target state="translated">让QA人员,如果可能的话,让最终用户参与进来</target>
        </trans-unit>
        <trans-unit id="4ddb9cd693a2e162ef85f6fbfe4abc845111ebb9" translate="yes" xml:space="preserve">
          <source>Is a synonym for &lt;code&gt;zebra&lt;/code&gt;. This may change to a more sensible mode in the future.</source>
          <target state="translated">是 &lt;code&gt;zebra&lt;/code&gt; 的同义词。将来可能会更改为更明智的模式。</target>
        </trans-unit>
        <trans-unit id="4f13daaae3d7fc7ba5d15c4ccfc54188d83d267e" translate="yes" xml:space="preserve">
          <source>Is used as suggested name when creating new branches using the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;.</source>
          <target state="translated">在使用&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt;创建新分支时用作建议名称。</target>
        </trans-unit>
        <trans-unit id="6f3229278b909458bc76fcc500cf44677191a296" translate="yes" xml:space="preserve">
          <source>Islands are configured via the &lt;code&gt;pack.island&lt;/code&gt; option, which can be specified multiple times. Each value is a left-anchored regular expressions matching refnames. For example:</source>
          <target state="translated">通过 &lt;code&gt;pack.island&lt;/code&gt; 选项可以配置孤岛，可以多次指定。每个值都是与引用名称匹配的左锚正则表达式。例如：</target>
        </trans-unit>
        <trans-unit id="30ce4cb25faae86427d8ac22e8f50a0a74f3f393" translate="yes" xml:space="preserve">
          <source>Issues</source>
          <target state="translated">Issues</target>
        </trans-unit>
        <trans-unit id="0120e142d77ed0c1102a3548e5e6ca12ae1c469b" translate="yes" xml:space="preserve">
          <source>Issues which are security relevant should be disclosed privately to the Git Security mailing list &amp;lt;&lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">与安全相关的问题应在Git Security邮件列表&amp;lt; &lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt; &amp;gt;中私下披露。</target>
        </trans-unit>
        <trans-unit id="7e6ca0d89968d14a4a145a03ebcf512ab164b2cf" translate="yes" xml:space="preserve">
          <source>Issuing a &lt;code&gt;filedeleteall&lt;/code&gt; followed by the needed &lt;code&gt;filemodify&lt;/code&gt; commands to set the correct content will produce the same results as sending only the needed &lt;code&gt;filemodify&lt;/code&gt; and &lt;code&gt;filedelete&lt;/code&gt; commands. The &lt;code&gt;filedeleteall&lt;/code&gt; approach may however require fast-import to use slightly more memory per active branch (less than 1 MiB for even most large projects); so frontends that can easily obtain only the affected paths for a commit are encouraged to do so.</source>
          <target state="translated">发出 &lt;code&gt;filedeleteall&lt;/code&gt; ,后跟所需的 &lt;code&gt;filemodify&lt;/code&gt; 命令以设置正确的内容，将产生与仅发送所需的 &lt;code&gt;filemodify&lt;/code&gt; 和 &lt;code&gt;filedelete&lt;/code&gt; 命令相同的结果。但是， &lt;code&gt;filedeleteall&lt;/code&gt; 方法可能需要快速导入，以在每个活动分支中使用更多的内存（对于大多数大型项目，其内存不足1 MiB）。因此，鼓励那些可以轻松仅获取受影响路径的提交的前端这样做。</target>
        </trans-unit>
        <trans-unit id="bdf45bc4332be1bec5eceb55b9547e5441cbefc8" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s clone path to the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file and adds this file to the index, ready to be committed.</source>
          <target state="translated">它将子模块的克隆路径添加到&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;文件，并将此文件添加到索引，准备提交。</target>
        </trans-unit>
        <trans-unit id="8c81521fe76c33a9e0c12152a7126a3168cdc6bc" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s current commit ID to the index, ready to be committed.</source>
          <target state="translated">它将子模块的当前提交ID添加到索引中，准备提交。</target>
        </trans-unit>
        <trans-unit id="d31bfc2387ea73611500553c1004cb0667d4f160" translate="yes" xml:space="preserve">
          <source>It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number &lt;code&gt;m&lt;/code&gt; controls this aspect of the -B option (defaults to 60%). &lt;code&gt;-B/70%&lt;/code&gt; specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).</source>
          <target state="translated">它影响的是更改方式，即完全重写文件，而不是将一系列删除和插入与很少几行恰好在文本上作为上下文相匹配的行混合在一起，而是将所有旧内容都删除后再加上一个一次插入所有新内容，数字 &lt;code&gt;m&lt;/code&gt; 控制-B选项的这一方面（默认为60％）。 &lt;code&gt;-B/70%&lt;/code&gt; 指定结果中应保留少于原始值的30％，以便Git认为它是完全重写的（即，否则，所得的补丁将是一系列删除和插入以及上下文行混合在一起）。</target>
        </trans-unit>
        <trans-unit id="3769038328418f1b146bfedf460a0d4ea1eab91b" translate="yes" xml:space="preserve">
          <source>It also allows a &quot;ref&quot; file to be a symbolic pointer to another ref file by starting with the four-byte header sequence of &quot;ref:&quot;.</source>
          <target state="translated">它还允许一个 &quot;ref &quot;文件以 &quot;ref:&quot;四个字节的头序列开始,成为另一个ref文件的符号指针。</target>
        </trans-unit>
        <trans-unit id="c1a8e562ae70e23b9286b736cb60f8fd411f796d" translate="yes" xml:space="preserve">
          <source>It can also be useful in scripts passed to &quot;git bisect run&quot; to &quot;exit 255&quot; if some very abnormal situation is detected.</source>
          <target state="translated">在传递给 &quot;git bisect run &quot;的脚本中,如果检测到一些非常不正常的情况,&quot;exit 255 &quot;也会很有用。</target>
        </trans-unit>
        <trans-unit id="79b5b9aab5919bae0a6145dab082f1d19cd80f67" translate="yes" xml:space="preserve">
          <source>It can be cumbersome to input the same credentials over and over. Git provides two methods to reduce this annoyance:</source>
          <target state="translated">一遍遍地输入相同的凭证会很麻烦。Git 提供了两种方法来减少这种烦恼。</target>
        </trans-unit>
        <trans-unit id="4e1aaed29365e5e25e94340f3a0f563a3458fb95" translate="yes" xml:space="preserve">
          <source>It can be used to inspect the current working tree and refuse to make a commit if it does not pass certain test.</source>
          <target state="translated">它可以用来检查当前的工作树,如果它没有通过某些测试,则拒绝提交。</target>
        </trans-unit>
        <trans-unit id="15367977bf1bc97e62677f2311accebdf50497b6" translate="yes" xml:space="preserve">
          <source>It can efficiently represent information about merge conflicts between different tree objects, allowing each pathname to be associated with sufficient information about the trees involved that you can create a three-way merge between them.</source>
          <target state="translated">它可以有效地表示不同树对象之间的合并冲突信息,允许每个路径名与所涉及的树的足够信息相关联,你可以在它们之间创建一个三向合并。</target>
        </trans-unit>
        <trans-unit id="61f59429096395b0e09a9585119ef97dbe0f3099" translate="yes" xml:space="preserve">
          <source>It cannot show more than 29 branches and commits at a time.</source>
          <target state="translated">它不能同时显示超过29个分支和提交。</target>
        </trans-unit>
        <trans-unit id="84908290c2ad8351819557b635db90afccbc35f1" translate="yes" xml:space="preserve">
          <source>It clones the submodule from &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; to the given &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; under the current directory and by default checks out the master branch.</source>
          <target state="translated">它将子模块从 &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; 克隆到当前目录下的给定 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; ，并且默认情况下检出master分支。</target>
        </trans-unit>
        <trans-unit id="d2f2a22f8382dea93b62981d5e21e0c74a8c6b46" translate="yes" xml:space="preserve">
          <source>It could also be used to log the old..new status. However, it does not know the entire set of branches, so it would end up firing one e-mail per ref when used naively, though. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook is more suited to that.</source>
          <target state="translated">它也可以用来记录old..new状态。但是，它不知道整个分支机构，因此，如果天真地使用它，最终将为每个引用触发一封电子邮件。该&lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;-收到后&lt;/em&gt;&lt;/a&gt;钩更适合一点。</target>
        </trans-unit>
        <trans-unit id="784deb932c786d53caa1d9cefe7cd05964d957b0" translate="yes" xml:space="preserve">
          <source>It defaults to &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt;, which colors everything older than one year blue, recent changes between one month and one year old are kept white, and lines introduced within the last month are colored red.</source>
          <target state="translated">它默认为 &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt; ，该颜色将所有超过一年的颜色都涂成蓝色，一个月到一岁之间的最近更改保持白色，而上个月引入的线条被涂成红色。</target>
        </trans-unit>
        <trans-unit id="91de163844ee67c93c1b1c843cc5bef0832c9f25" translate="yes" xml:space="preserve">
          <source>It does its best to do the safe thing, it will check that the files are unchanged and up to date in the CVS checkout, and it will not autocommit by default.</source>
          <target state="translated">它尽量做到安全,它会在CVS的签出中检查文件是否没有变化,是否是最新的,它默认不会自动提交。</target>
        </trans-unit>
        <trans-unit id="92564150ed02a0207f639f4b1e8f897270e7157d" translate="yes" xml:space="preserve">
          <source>It does this by storing some additional data for each entry (such as the last modified time). This data is not displayed above, and is not stored in the created tree object, but it can be used to determine quickly which files in the working directory differ from what was stored in the index, and thus save Git from having to read all of the data from such files to look for changes.</source>
          <target state="translated">它通过为每个条目存储一些额外的数据(比如最后一次修改时间)来实现。这些数据不会显示在上面,也不会存储在创建的树对象中,但它可以用来快速确定工作目录中的哪些文件与索引中存储的不同,从而节省Git从这些文件中读取所有数据来查找修改。</target>
        </trans-unit>
        <trans-unit id="af8ba1869bb0a79ae9cea38b1af5617b9069dca1" translate="yes" xml:space="preserve">
          <source>It enables git to work together with a file system monitor (see the &quot;fsmonitor-watchman&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;) that can inform it as to what files have been modified. This enables git to avoid having to lstat() every file to find modified files.</source>
          <target state="translated">它使git可以与文件系统监视器（请参阅&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;的&amp;ldquo; fsmonitor-watchman&amp;rdquo;部分）一起使用，可以通知它已修改了哪些文件。这使git避免必须对每个文件进行lstat（）查找修改后的文件。</target>
        </trans-unit>
        <trans-unit id="af9f31199487ba705eebc5dd4bc13449d71955c8" translate="yes" xml:space="preserve">
          <source>It expects to be dealing with one project only. If it sees branches that have different roots, it will refuse to run. In that case, edit your &amp;lt;archive/branch&amp;gt; parameters to define clearly the scope of the import.</source>
          <target state="translated">它期望只处理一个项目。如果发现分支具有不同的根，它将拒绝运行。在这种情况下，请编辑您的&amp;lt;archive / branch&amp;gt;参数以明确定义导入范围。</target>
        </trans-unit>
        <trans-unit id="d015f51d5305572fa694969daaad327b702a39d6" translate="yes" xml:space="preserve">
          <source>It helps to divide these functions into groups for discussion purposes.</source>
          <target state="translated">为了讨论的目的,将这些功能分成几组是有帮助的。</target>
        </trans-unit>
        <trans-unit id="cf8815ec8cef4d3d8f9a8adf49f25148a4887929" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;unix
timestamp&amp;gt;&lt;/code&gt; is the number of seconds since the UNIX epoch. &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is &lt;code&gt;+0100&lt;/code&gt;.</source>
          <target state="translated">它是 &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;&amp;lt;unix timestamp&amp;gt;&lt;/code&gt; 是自UNIX时代以来的秒数。 &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; 是相对于UTC的正或负偏移。例如，CET（比UTC提前1小时）为 &lt;code&gt;+0100&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f4ae55d14bc9f41dc555ac55a4684de8bea2c17" translate="yes" xml:space="preserve">
          <source>It is OK to include files which have not actually changed. All changes including newly-created and deleted files should be included. When files are renamed, both the old and the new name should be included.</source>
          <target state="translated">可以包括没有实际改变的文件。所有的变化,包括新创建和删除的文件都应该包括在内。当文件被重新命名时,应包括新旧名称。</target>
        </trans-unit>
        <trans-unit id="854a36265382bec82daa5a74f777ff212834a549" translate="yes" xml:space="preserve">
          <source>It is a good idea to introduce yourself to Git with your name and public email address before doing any operation. The easiest way to do so is:</source>
          <target state="translated">在进行任何操作之前,最好先向Git介绍自己的名字和公共邮箱地址。最简单的方法是</target>
        </trans-unit>
        <trans-unit id="0dc733d75bf5327e08cfc3134be1a3042cbb2515" translate="yes" xml:space="preserve">
          <source>It is a rough equivalent for:</source>
          <target state="translated">它大致相当于:</target>
        </trans-unit>
        <trans-unit id="95c229774b9b51315840e554d56265719cd8be5c" translate="yes" xml:space="preserve">
          <source>It is also a good idea when using any VCS to have only one small logical change in each commit.</source>
          <target state="translated">在使用任何VCS时,每次提交时只做一个小的逻辑修改也是一个好主意。</target>
        </trans-unit>
        <trans-unit id="6c5a3acbba80472c3128c6339cb1639b4bd8a27a" translate="yes" xml:space="preserve">
          <source>It is also permitted for a notes ref to point directly to a tree object, in which case the history of the notes can be read with &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">还允许注释ref直接指向树对象，在这种情况下，可以使用 &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt; 读取注释的历史记录。</target>
        </trans-unit>
        <trans-unit id="df38f390855a08aaa74243c50bf2cb099b03fbb3" translate="yes" xml:space="preserve">
          <source>It is also possible for perpetually modified files to occur on any platform if a smudge or clean filter is in use on your system but a file was previously committed without running the smudge or clean filter. To fix this, run the following on an otherwise clean working tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16dc4f2558875d3f67cc118d8aee343695acae5" translate="yes" xml:space="preserve">
          <source>It is also possible to fetch a subset of branches or tags by using a comma-separated list of names within braces. For example:</source>
          <target state="translated">也可以通过在括号内使用逗号分隔的名称列表来获取分支或标签的子集。例如:</target>
        </trans-unit>
        <trans-unit id="12b7523072e662c296ea1a80ba59ec7ed5fcb7e4" translate="yes" xml:space="preserve">
          <source>It is also possible to introduce completely new merge commits from scratch by adding a command of the form &lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt;. This form will generate a tentative commit message and always open an editor to let the user edit it. This can be useful e.g. when a topic branch turns out to address more than a single concern and wants to be split into two or even more topic branches. Consider this todo list:</source>
          <target state="translated">通过添加 &lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt; 形式的命令，也可以从头开始引入全新的合并提交。此表单将生成一个临时提交消息，并始终打开编辑器让用户对其进行编辑。这可能很有用，例如，当一个主题分支最终解决的不仅仅是单个关注点，并且想要被拆分为两个或更多主题分支时。考虑以下待办事项清单：</target>
        </trans-unit>
        <trans-unit id="e8d4e8a65d3b558ba4900bdd06798676f68d11ad" translate="yes" xml:space="preserve">
          <source>It is also possible to provide true CVS access to a Git repository, so that developers can still use CVS; see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details.</source>
          <target state="translated">还可以提供对Git存储库的真正CVS访问，以便开发人员仍可以使用CVS。有关详细信息，请参见&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3fcb2e34d6c27144258c45911fcc9298afaeeefa" translate="yes" xml:space="preserve">
          <source>It is also possible to replace commits further back in the history, but this is an advanced topic to be left for &lt;a href=&quot;#cleaning-up-history&quot;&gt;another chapter&lt;/a&gt;.</source>
          <target state="translated">也可以在历史上更远的地方替换提交，但这是高级话题，需要&lt;a href=&quot;#cleaning-up-history&quot;&gt;再上一章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14665d6ab0c5fa19cd26aec534fecd5dda3c4692" translate="yes" xml:space="preserve">
          <source>It is also run after &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;, unless the &lt;code&gt;--no-checkout&lt;/code&gt; (&lt;code&gt;-n&lt;/code&gt;) option is used. The first parameter given to the hook is the null-ref, the second the ref of the new HEAD and the flag is always 1. Likewise for &lt;code&gt;git worktree add&lt;/code&gt; unless &lt;code&gt;--no-checkout&lt;/code&gt; is used.</source>
          <target state="translated">它也会在&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;之后运行，除非使用 &lt;code&gt;--no-checkout&lt;/code&gt; （ &lt;code&gt;-n&lt;/code&gt; ）选项。赋予钩子的第一个参数是null-ref，第二个参数是新HEAD的ref，并且标记始终为1。同样，对于 &lt;code&gt;git worktree add&lt;/code&gt; ,除非使用 &lt;code&gt;--no-checkout&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bf0b4701dd5a8615d5c5a4270f19ec18f43aa49" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;dst&amp;gt; matches more than one remote refs.</source>
          <target state="translated">如果&amp;lt;dst&amp;gt;匹配多个远程引用，则错误。</target>
        </trans-unit>
        <trans-unit id="47ed8fd8a6ccf512f8dd41b7de1bb50b3d494692" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;src&amp;gt; does not match exactly one of the local refs.</source>
          <target state="translated">如果&amp;lt;src&amp;gt;与本地引用之一不完全匹配，则会出现错误。</target>
        </trans-unit>
        <trans-unit id="08551e573ca80a9130c1ec33d2456a204ee6a838" translate="yes" xml:space="preserve">
          <source>It is an error to specify a ref that does not pass &quot;git check-ref-format&quot; scrutiny. Duplicated values are filtered.</source>
          <target state="translated">指定一个没有通过 &quot;git check-ref-format &quot;检查的 ref 是一个错误。重复的值会被过滤掉。</target>
        </trans-unit>
        <trans-unit id="91dc5c05cc945b2e35d03a4d25f4568585356b02" translate="yes" xml:space="preserve">
          <source>It is assumed that any handshaking procedures have already been completed (such as sending service request for git://) before this helper is started.</source>
          <target state="translated">假设在启动这个帮助程序之前,所有的握手程序都已经完成了(比如为git://发送服务请求)。</target>
        </trans-unit>
        <trans-unit id="7a3002fc7973dbc26474a90f4bdcb162301b4e67" translate="yes" xml:space="preserve">
          <source>It is currently only possible to recreate the merge commits using the &lt;code&gt;recursive&lt;/code&gt; merge strategy; Different merge strategies can be used only via explicit &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; commands.</source>
          <target state="translated">当前只能使用 &lt;code&gt;recursive&lt;/code&gt; 合并策略来重新创建合并提交。只能通过显式 &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; 命令使用不同的合并策略。</target>
        </trans-unit>
        <trans-unit id="bd70cf0a22a7ad38ee60197dd400f891cf0d57a3" translate="yes" xml:space="preserve">
          <source>It is expected that the content of the commit object you created while following the example above generates a different SHA-1 hash than the one shown above because the commit object records the time when it was created and the name of the person performing the commit.</source>
          <target state="translated">预计您在按照上面的例子创建的提交对象的内容会产生与上面所示不同的SHA-1哈希值,因为提交对象记录了创建的时间和执行提交的人的名字。</target>
        </trans-unit>
        <trans-unit id="f78a88555b80a7cb6f279e6cf8551b4ade125a2a" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines (this example shows a merge with two parents):</source>
          <target state="translated">它的后面是一个或多个扩展的标题行(这个例子显示的是两个父行的合并)。</target>
        </trans-unit>
        <trans-unit id="4d181ca929d0bcae1d19e843f3c648e99a609d36" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines:</source>
          <target state="translated">它的后面是一个或多个扩展的标题行。</target>
        </trans-unit>
        <trans-unit id="a6770fb3a63d614ebdc42bea002a81ec83ae2568" translate="yes" xml:space="preserve">
          <source>It is followed by two-line from-file/to-file header</source>
          <target state="translated">后面是两行从文件到文件的标题</target>
        </trans-unit>
        <trans-unit id="31bbdf9a81fa3062a8106d3f0d5511057b4a5222" translate="yes" xml:space="preserve">
          <source>It is highly functional. However, not all methods are implemented, and for those methods that are implemented, not all switches are implemented.</source>
          <target state="translated">它的功能很强。但是,并不是所有的方法都能实现,对于那些实现了的方法,也不是所有的开关都能实现。</target>
        </trans-unit>
        <trans-unit id="13209c7d424e2b65e2d35ccb5123d7d58e26c1e7" translate="yes" xml:space="preserve">
          <source>It is important to realize that at this point nothing refers to commit &lt;code&gt;f&lt;/code&gt;. Eventually commit &lt;code&gt;f&lt;/code&gt; (and by extension commit &lt;code&gt;e&lt;/code&gt;) will be deleted by the routine Git garbage collection process, unless we create a reference before that happens. If we have not yet moved away from commit &lt;code&gt;f&lt;/code&gt;, any of these will create a reference to it:</source>
          <target state="translated">重要的是要意识到，在这一点上，没有什么涉及提交 &lt;code&gt;f&lt;/code&gt; 。最终，提交 &lt;code&gt;f&lt;/code&gt; （以及扩展名为commit &lt;code&gt;e&lt;/code&gt; ）将被例程Git垃圾回收过程删除，除非我们在此之前创建了引用。如果我们还没有离开commit &lt;code&gt;f&lt;/code&gt; ，那么任何一个都会创建对它的引用：</target>
        </trans-unit>
        <trans-unit id="15e77b99d56294dd4d998fab1260c89fc2b1f677" translate="yes" xml:space="preserve">
          <source>It is likely that you will be pulling from the same remote repository from time to time. As a short hand, you can store the remote repository URL in the local repository&amp;rsquo;s config file like this:</source>
          <target state="translated">您可能会不时从同一远程存储库中提取信息。简而言之，您可以将远程存储库URL存储在本地存储库的配置文件中，如下所示：</target>
        </trans-unit>
        <trans-unit id="e468ce82ca7a37df3e0ccb7eddd0ee514020b622" translate="yes" xml:space="preserve">
          <source>It is likely that you will be working on more than one thing at a time. It is easy to manage those more-or-less independent tasks using branches with Git.</source>
          <target state="translated">你很可能同时在做一件以上的事情。使用 Git 的分支可以轻松管理这些或多或少独立的任务。</target>
        </trans-unit>
        <trans-unit id="cdfac588afc71ee687618e7ec3bc2f824e200606" translate="yes" xml:space="preserve">
          <source>It is not always easy for new developers to find their way through Git&amp;rsquo;s source code. This section gives you a little guidance to show where to start.</source>
          <target state="translated">对于新开发人员而言，通过Git的源代码找到自己的路并不总是那么容易。本节为您提供一些指导，以显示从哪里开始。</target>
        </trans-unit>
        <trans-unit id="deded1cb8baf6033568ee8de4cb9cb55818cb450" translate="yes" xml:space="preserve">
          <source>It is not recommended to use this feature if you intend to export changes back to CVS again later with &lt;code&gt;git cvsexportcommit&lt;/code&gt;.</source>
          <target state="translated">如果您打算稍后使用 &lt;code&gt;git cvsexportcommit&lt;/code&gt; 再次将更改导出回CVS，则不建议使用此功能。</target>
        </trans-unit>
        <trans-unit id="598d612724092a05c80fc92ca656e4e685e7e227" translate="yes" xml:space="preserve">
          <source>It is obviously a good idea not to have commits with changes that knowingly break things, even if some other commits later fix the breakage.</source>
          <target state="translated">很明显,不要让提交者在明知故犯的情况下进行修改,即使后来有其他提交者修复了错误,这也是一个好主意。</target>
        </trans-unit>
        <trans-unit id="8402ec5252190f6132c0772d2b1eafbec27785df" translate="yes" xml:space="preserve">
          <source>It is possible that a merge failure will prevent this process from being completely automatic. You will have to resolve any such merge failure and run &lt;code&gt;git rebase --continue&lt;/code&gt;. Another option is to bypass the commit that caused the merge failure with &lt;code&gt;git rebase --skip&lt;/code&gt;. To check out the original &amp;lt;branch&amp;gt; and remove the .git/rebase-apply working files, use the command &lt;code&gt;git rebase --abort&lt;/code&gt; instead.</source>
          <target state="translated">合并失败可能会阻止此过程完全自动化。您将必须解决任何此类合并失败并运行 &lt;code&gt;git rebase --continue&lt;/code&gt; 。另一个选择是使用 &lt;code&gt;git rebase --skip&lt;/code&gt; 绕过导致合并失败的提交。要检出原始的&amp;lt;branch&amp;gt;并删除.git / rebase-apply工作文件，请改用 &lt;code&gt;git rebase --abort&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="2ea7f2913c3e95cfd4ae5ff1f6d8aecb190ef204" translate="yes" xml:space="preserve">
          <source>It is possible to construct these old form repositories manually.</source>
          <target state="translated">可以手动构建这些旧的表格库。</target>
        </trans-unit>
        <trans-unit id="548453998a9c855739e7eb9ec21e0581e0ed374b" translate="yes" xml:space="preserve">
          <source>It is possible to disable use of replacement references for any command using the &lt;code&gt;--no-replace-objects&lt;/code&gt; option just after &lt;code&gt;git&lt;/code&gt;.</source>
          <target state="translated">可以在 &lt;code&gt;git&lt;/code&gt; 之后使用 &lt;code&gt;--no-replace-objects&lt;/code&gt; 选项禁用任何命令的替换引用。</target>
        </trans-unit>
        <trans-unit id="c06956dd566d0990dc7bdbc85eb39fd34edd8452" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header that looks like this:</source>
          <target state="translated">它的前面有一个 &quot;git diff &quot;头,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="fae83443f259566d0e3ea169c2bee02ad7796585" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header, that looks like this (when the &lt;code&gt;-c&lt;/code&gt; option is used):</source>
          <target state="translated">它前面带有&amp;ldquo; git diff&amp;rdquo;标头，如下所示（使用 &lt;code&gt;-c&lt;/code&gt; 选项时）：</target>
        </trans-unit>
        <trans-unit id="41c2e2ee7c9260a90ac9d47c12dc86595dc670c7" translate="yes" xml:space="preserve">
          <source>It is purely performance optimization, originally intended for MacOS X, where recursive directory traversal is slow. Gitweb follows symbolic links, but it detects cycles, ignoring any duplicate files and directories.</source>
          <target state="translated">这是纯粹的性能优化,最初是为MacOS X设计的,因为在MacOS X中,递归目录遍历很慢。Gitweb遵循符号链接,但它会检测循环,忽略任何重复的文件和目录。</target>
        </trans-unit>
        <trans-unit id="bcd29e9bb49344b0e527480d5a1209557826cefc" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; always be encoded using UTF-8.</source>
          <target state="translated">建议始终使用UTF-8 对 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 进行编码。</target>
        </trans-unit>
        <trans-unit id="987c2f12e083069e2c3c6529da1c2b8427b5d901" translate="yes" xml:space="preserve">
          <source>It is safer if both &lt;code&gt;test.sh&lt;/code&gt; and &lt;code&gt;check_test_case.sh&lt;/code&gt; are outside the repository to prevent interactions between the bisect, make and test processes and the scripts.</source>
          <target state="translated">如果 &lt;code&gt;test.sh&lt;/code&gt; 和 &lt;code&gt;check_test_case.sh&lt;/code&gt; 都在存储库之外，则更安全，以防止bisect，make和test进程与脚本之间的交互。</target>
        </trans-unit>
        <trans-unit id="07dbd897b2b790cda3e0cd6c93a27be05c0967a5" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to be able to checkout a commit that is not at the tip of any named branch, or even to create a new commit that is not referenced by a named branch. Let&amp;rsquo;s look at what happens when we checkout commit &lt;code&gt;b&lt;/code&gt; (here we show two ways this may be done):</source>
          <target state="translated">有时能够检出不在任何命名分支的尖端的提交，或者甚至创建未被命名分支引用的新提交，这很有用。让我们看一下在检出commit &lt;code&gt;b&lt;/code&gt; 时会发生什么（这里显示了两种方法可以完成）：</target>
        </trans-unit>
        <trans-unit id="19dd47dcbbf16a9cccaac6e901efe1eb6d41c6b4" translate="yes" xml:space="preserve">
          <source>It is still your responsibility to make sure that the email message sent by your email program meets the standards of your project. Many projects do not like patches to be attached. Some mail agents will transform patches (e.g. wrap lines, send them as format=flowed) in ways that make them fail. You will get angry flames ridiculing you if you don&amp;rsquo;t check this.</source>
          <target state="translated">确保您的电子邮件程序发送的电子邮件符合项目标准仍然是您的责任。许多项目不喜欢附加补丁。一些邮件代理将转换补丁程序（例如换行，以format = flowed格式发送），使补丁程序失败。如果不检查，您会生气的火焰嘲笑您。</target>
        </trans-unit>
        <trans-unit id="446989de9f552ff7a375d76851b391396cb21747" translate="yes" xml:space="preserve">
          <source>It is unlikely that you would have any conflicts here &amp;hellip;​ but you might if you spent a while on this step and had also pulled new versions from upstream.</source>
          <target state="translated">您不太可能在这里发生任何冲突...但是如果您花了一些时间在此步骤上并且还从上游拉出了新版本，则可能会发生冲突。</target>
        </trans-unit>
        <trans-unit id="5d35217f8f6c81e1e684634a0bdd90859d19f06a" translate="yes" xml:space="preserve">
          <source>It is up to the user to ensure that no In-Reply-To header already exists when &lt;code&gt;git send-email&lt;/code&gt; is asked to add it (especially note that &lt;code&gt;git format-patch&lt;/code&gt; can be configured to do the threading itself). Failure to do so may not produce the expected result in the recipient&amp;rsquo;s MUA.</source>
          <target state="translated">当要求 &lt;code&gt;git send-email&lt;/code&gt; 添加标题时，要由用户确保不存在In-Reply-To标头（尤其要注意，可以将 &lt;code&gt;git format-patch&lt;/code&gt; 配置为执行线程本身）。否则可能不会在收件人的MUA中产生预期的结果。</target>
        </trans-unit>
        <trans-unit id="28ab82f4261b972bffcbd084fca6120764f529fe" translate="yes" xml:space="preserve">
          <source>It is useful when you&amp;rsquo;re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into &lt;code&gt;-S&lt;/code&gt;, and keep going until you get the very first version of the block.</source>
          <target state="translated">当您正在寻找确切的代码块（例如结构），并且想知道该块自首次出现以来的历史记录时，它很有用：迭代使用该功能将原图像中的有趣块反馈到 &lt;code&gt;-S&lt;/code&gt; ，继续进行直到获得该块的第一个版本。</target>
        </trans-unit>
        <trans-unit id="212ba732375c1f9e18ce6b37fe943bc0a79e8a67" translate="yes" xml:space="preserve">
          <source>It is very important that the basis used be held by the destination. It is okay to err on the side of caution, causing the bundle file to contain objects already in the destination, as these are ignored when unpacking at the destination.</source>
          <target state="translated">使用的基础由目的地持有是非常重要的。谨慎起见,使捆绑文件包含已经在目的地的对象是可以的,因为这些对象在目的地解包时被忽略。</target>
        </trans-unit>
        <trans-unit id="f89d35d0ac276c4d31876791b9f069b985ca50ec" translate="yes" xml:space="preserve">
          <source>It may well be that among networking people, they may want to exchange the tags internal to their group, but in that workflow they are most likely tracking each other&amp;rsquo;s progress by having remote-tracking branches. Again, the heuristic to automatically follow such tags is a good thing.</source>
          <target state="translated">可能是在联网人员中，他们可能希望交换小组内部的标签，但是在该工作流程中，他们很可能会通过拥有远程跟踪分支机构来互相跟踪彼此的进度。同样，自动跟踪此类标签的启发式方法也是一件好事。</target>
        </trans-unit>
        <trans-unit id="b30dde80280e412c885fe09e1718d04b65bebbd4" translate="yes" xml:space="preserve">
          <source>It must be readable in order, from beginning to end, by someone intelligent with a basic grasp of the UNIX command line, but without any special knowledge of Git. If necessary, any other prerequisites should be specifically mentioned as they arise.</source>
          <target state="translated">它必须能让一个基本掌握 UNIX 命令行的聪明人从头到尾按顺序读懂,但不需要任何特殊的 Git 知识。如有必要,应在出现任何其他先决条件时具体说明。</target>
        </trans-unit>
        <trans-unit id="105999ab02cc181d3d21d02fda72679e92aee0b2" translate="yes" xml:space="preserve">
          <source>It should be stressed that this hierarchy is purely &lt;strong&gt;informal&lt;/strong&gt;. There is nothing fundamental in Git that enforces the &quot;chain of patch flow&quot; this hierarchy implies. You do not have to pull from only one remote repository.</source>
          <target state="translated">应该强调的是，这种等级制度纯粹是&lt;strong&gt;非正式的&lt;/strong&gt;。在Git中，没有什么根本可以执行此层次结构所暗示的&amp;ldquo;补丁流链&amp;rdquo;。您不必仅从一个远程存储库中提取。</target>
        </trans-unit>
        <trans-unit id="7beffad8901e95a09a82e88d22525a3cad3065d8" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add--interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593ae3fc1288babccd02a202f40d492d26634f5a" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add{litdd}interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="translated">它表明foo.png与HEAD有区别（但是是二进制的，因此行数无法显示），索引副本和工作树版本之间也没有区别（如果工作树版本也不同，则将显示 &lt;code&gt;binary&lt;/code&gt; 代替 &lt;code&gt;nothing&lt;/code&gt; ）。另一个文件git-add {litdd} interactive.perl，如果您提交索引中的内容，则添加403行，并删除35行，但是工作树文件有进一步的修改（一个添加和一个删除）。</target>
        </trans-unit>
        <trans-unit id="1f22531fd9489cd1b4496c81c3454037c20af1a5" translate="yes" xml:space="preserve">
          <source>It takes a variable number of parameters, each of which is the name of ref that was actually updated.</source>
          <target state="translated">它需要一个数量不等的参数,每个参数都是实际更新的 ref 的名称。</target>
        </trans-unit>
        <trans-unit id="8d1640303505dff202eb78d383641a82298beff2" translate="yes" xml:space="preserve">
          <source>It takes on the standard input the specification of the options to parse and understand, and echoes on the standard output a string suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt; to replace the arguments with normalized ones. In case of error, it outputs usage on the standard error stream, and exits with code 129.</source>
          <target state="translated">它采用标准输入来解析和理解选项的规范，并在标准输出上回显适合 &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; 的字符串，以用规范化参数替换参数。如果发生错误，它将在标准错误流上输出使用情况，并以代码129退出。</target>
        </trans-unit>
        <trans-unit id="9fc9d0adb73a5f351f66393e06f90ebbcd611062" translate="yes" xml:space="preserve">
          <source>It takes one to three parameters. The first is the name of the file that contains the commit log message. The second is the source of the commit message, and can be: &lt;code&gt;message&lt;/code&gt; (if a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option was given); &lt;code&gt;template&lt;/code&gt; (if a &lt;code&gt;-t&lt;/code&gt; option was given or the configuration option &lt;code&gt;commit.template&lt;/code&gt; is set); &lt;code&gt;merge&lt;/code&gt; (if the commit is a merge or a &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; file exists); &lt;code&gt;squash&lt;/code&gt; (if a &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; file exists); or &lt;code&gt;commit&lt;/code&gt;, followed by a commit SHA-1 (if a &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt; or &lt;code&gt;--amend&lt;/code&gt; option was given).</source>
          <target state="translated">它需要一到三个参数。第一个是包含提交日志消息的文件的名称。第二个是提交消息的来源，可以是： &lt;code&gt;message&lt;/code&gt; （如果给出了 &lt;code&gt;-m&lt;/code&gt; 或 &lt;code&gt;-F&lt;/code&gt; 选项）； &lt;code&gt;template&lt;/code&gt; （如果提供了 &lt;code&gt;-t&lt;/code&gt; 选项或设置了配置选项 &lt;code&gt;commit.template&lt;/code&gt; ）； &lt;code&gt;merge&lt;/code&gt; （如果提交是合并或存在 &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; 文件）； &lt;code&gt;squash&lt;/code&gt; （如果存在 &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; 文件）; 或 &lt;code&gt;commit&lt;/code&gt; ，然后是SHA-1提交（如果是 &lt;code&gt;-c&lt;/code&gt; ， &lt;code&gt;-C&lt;/code&gt; 或 &lt;code&gt;--amend&lt;/code&gt; 选项）。</target>
        </trans-unit>
        <trans-unit id="ee62cbb1781a10ccff3a10f01577042e41951364" translate="yes" xml:space="preserve">
          <source>It tells you that it did an &quot;Automatic merge&quot;, which failed due to conflicts in &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">它告诉您它执行了&amp;ldquo;自动合并&amp;rdquo;，由于 &lt;code&gt;hello&lt;/code&gt; 中的冲突而失败。</target>
        </trans-unit>
        <trans-unit id="31dbee78e4c488ce29554dd490d874937eb736b5" translate="yes" xml:space="preserve">
          <source>It used to be that the command defaulted to do &lt;code&gt;-x&lt;/code&gt; described above, and &lt;code&gt;-r&lt;/code&gt; was to disable it. Now the default is not to do &lt;code&gt;-x&lt;/code&gt; so this option is a no-op.</source>
          <target state="translated">过去，该命令默认执行上述的 &lt;code&gt;-x&lt;/code&gt; ，而 &lt;code&gt;-r&lt;/code&gt; 则禁用它。现在默认为不执行 &lt;code&gt;-x&lt;/code&gt; ,因此此选项为无操作。</target>
        </trans-unit>
        <trans-unit id="d5579126502958d7cf2a79d1e6eb0f1ab9f1fb74" translate="yes" xml:space="preserve">
          <source>It uses &lt;code&gt;showbranch.default&lt;/code&gt; multi-valued configuration items if no &amp;lt;rev&amp;gt; or &amp;lt;glob&amp;gt; is given on the command line.</source>
          <target state="translated">如果在命令行上没有给出&amp;lt;rev&amp;gt;或&amp;lt;glob&amp;gt;，它将使用 &lt;code&gt;showbranch.default&lt;/code&gt; 多值配置项。</target>
        </trans-unit>
        <trans-unit id="c599d3ca0dc61039dd83109e0beef002f0abd196" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;--export-all&lt;/code&gt; parameter is specified). If you pass some directory paths as &lt;code&gt;git daemon&lt;/code&gt; arguments, you can further restrict the offers to a whitelist comprising of those.</source>
          <target state="translated">它会验证目录中是否包含魔术文件&amp;ldquo; git-daemon-export-ok&amp;rdquo;，并且它将拒绝导出任何未明确标记为要导出的Git目录（除非指定了 &lt;code&gt;--export-all&lt;/code&gt; 参数） ）。如果您将某些目录路径作为 &lt;code&gt;git daemon&lt;/code&gt; 参数传递，则可以进一步将商品限制为包含这些商品的白名单。</target>
        </trans-unit>
        <trans-unit id="3fd1b09d35c94e426d7de9278697f8281d2f9b0b" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable is set).</source>
          <target state="translated">它会验证目录中是否包含魔术文件&amp;ldquo; git-daemon-export-ok&amp;rdquo;，并且它将拒绝导出任何未显式标记为要导出的Git目录（除非设置了 &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; 环境变量）。</target>
        </trans-unit>
        <trans-unit id="6a949f37aaca4177eee5df32a3761a98f4054a56" translate="yes" xml:space="preserve">
          <source>It was a tool of absolute last resort. I&amp;rsquo;d rather spend days looking at printk output than do a manual &lt;code&gt;patch bisection&lt;/code&gt;.</source>
          <target state="translated">这是绝对不得已的工具。我宁愿花几天的时间查看printk的输出，也不愿进行手工的 &lt;code&gt;patch bisection&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="839ea1dcb179bd0fd1a734d84c9b044b60c7a423" translate="yes" xml:space="preserve">
          <source>It will be useful to have a Git repository to experiment with as you read this manual.</source>
          <target state="translated">在阅读本手册的过程中,有一个 Git 仓库进行实验会很有用。</target>
        </trans-unit>
        <trans-unit id="a1e588b366d6eee7b2a111ab040de25b982fdb3f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible for a push to fail in this way when other people have the right to push to the same repository. In that case, the correct solution is to retry the push after first updating your work: either by a pull, or by a fetch followed by a rebase; see the &lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;next section&lt;/a&gt; and &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt; for more.</source>
          <target state="translated">当其他人有权推送到同一存储库时，推送也可能以这种方式失败。在这种情况下，正确的解决方案是在首先更新您的工作后重试推送：通过拉取，先获取后重新设置基准；请参阅&lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;下一节&lt;/a&gt;和&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt;了解更多信息。</target>
        </trans-unit>
        <trans-unit id="fb4f6e12e9b3bc515593c3c6f58a010f2584b187" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s best to remove one of the files such that you only have one file. You can do this with commands like the following (assuming two files &lt;code&gt;AFile.txt&lt;/code&gt; and &lt;code&gt;afile.txt&lt;/code&gt;) on an otherwise clean working tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ec6258a88fcfa8b2ee5adddb372d62ea174c2e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to try to use &lt;code&gt;pre-commit&lt;/code&gt; hooks (or, for commit messages, &lt;code&gt;commit-msg&lt;/code&gt; hooks) to check these things, which is great if you&amp;rsquo;re working as a solo developer and want the tooling to help you. However, using hooks on a developer machine is not effective as a policy control because a user can bypass these hooks with &lt;code&gt;--no-verify&lt;/code&gt; without being noticed (among various other ways). Git assumes that the user is in control of their local repositories and doesn&amp;rsquo;t try to prevent this or tattle on the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e637a625c72275676a912327970832afbb1fc7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s especially instructive to look at &quot;commit&quot; objects, since those tend to be small and fairly self-explanatory. In particular, if you follow the convention of having the top commit name in &lt;code&gt;.git/HEAD&lt;/code&gt;, you can do</source>
          <target state="translated">查看&amp;ldquo;提交&amp;rdquo;对象特别有启发性，因为这些对象通常很小并且很容易解释。特别是，如果遵循 &lt;code&gt;.git/HEAD&lt;/code&gt; 中具有最高提交名称的约定，则可以执行</target>
        </trans-unit>
        <trans-unit id="ebca6c1346b961bb4e2f8a08e1112a09cf4c4143" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s far too easy to accidentally mix up old and new history. It&amp;rsquo;s still possible with any tool, but git-filter-branch almost invites it. If lucky, the only downside is users getting frustrated that they don&amp;rsquo;t know how to shrink their repo and remove the old stuff. If unlucky, they merge old and new history and end up with multiple &quot;copies&quot; of each commit, some of which have unwanted or sensitive files and others which don&amp;rsquo;t. This comes about in multiple different ways:</source>
          <target state="translated">意外地混淆了新旧历史，这太容易了。仍然可以使用任何工具，但是git-filter-branch几乎可以邀请它。如果幸运的话，唯一的缺点就是用户会沮丧，因为他们不知道如何缩减存储库并删除旧内容。如果不走运，它们将合并新旧历史，并最终每次提交具有多个&amp;ldquo;副本&amp;rdquo;，其中一些包含不需要的文件或敏感文件，而另一些则没有。这以多种不同的方式实现：</target>
        </trans-unit>
        <trans-unit id="7fb3124f269af4d6382e41b308c15a44d9e7c09f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not safe to run &lt;code&gt;git submodule update&lt;/code&gt; if you&amp;rsquo;ve made and committed changes within a submodule without checking out a branch first. They will be silently overwritten:</source>
          <target state="translated">如果您在子模块中进行了更改并提交了更改而不先检出分支，则运行 &lt;code&gt;git submodule update&lt;/code&gt; 是不安全的。它们将被默默覆盖：</target>
        </trans-unit>
        <trans-unit id="199b24a07e7c4f542f5c9b6cd233e68c58c149e6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to push any type of object to any namespace outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt;. In the case of tags and commits, these will be treated as if they were the commits inside &lt;code&gt;refs/heads/*&lt;/code&gt; for the purposes of whether the update is allowed.</source>
          <target state="translated">可以将任何类型的对象推送到 &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 之外的任何名称空间。对于标记和提交，出于是否允许更新的目的，将它们视为 &lt;code&gt;refs/heads/*&lt;/code&gt; 中的提交。</target>
        </trans-unit>
        <trans-unit id="cd25bf8e6a6252931a48d686e2c25ca4a7c9f16e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s probably not worth it to use this option on a given repository without running tailored performance benchmarks on it. It takes a lot more time, and the resulting space/delta optimization may or may not be worth it. Not using this at all is the right trade-off for most users and their repositories.</source>
          <target state="translated">如果不在其上运行定制的性能基准，则在给定的存储库上使用此选项可能不值得。这需要花费更多时间，并且最终的空间/增量优化可能值得也可能不值得。对于大多数用户及其存储库，完全不使用此功能是正确的权衡。</target>
        </trans-unit>
        <trans-unit id="6c2d9fe7b4d73e7c5f324adf6070448f4f753fb5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s reasonable to e.g. configure &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; in &lt;code&gt;~/.gitconfig&lt;/code&gt; to have tags pruned whenever &lt;code&gt;git fetch --prune&lt;/code&gt; is run, without making every invocation of &lt;code&gt;git fetch&lt;/code&gt; without &lt;code&gt;--prune&lt;/code&gt; an error.</source>
          <target state="translated">合理的 &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; 是，例如，在 &lt;code&gt;~/.gitconfig&lt;/code&gt; 配置fetch.pruneTags = true， &lt;code&gt;git fetch --prune&lt;/code&gt; 在运行git fetch --prune时删除标签，而不会使没有 &lt;code&gt;--prune&lt;/code&gt; 的 &lt;code&gt;git fetch&lt;/code&gt; 每次调用都出错。</target>
        </trans-unit>
        <trans-unit id="bb5eba09f5b7ed44896e1f2e304b6636d8012774" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s tempting to try to use certain features of &lt;code&gt;git update-index&lt;/code&gt;, namely the assume-unchanged and skip-worktree bits, but these don&amp;rsquo;t work properly for this purpose and shouldn&amp;rsquo;t be used this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ec8a66f406e3cd9a737fd2597d771efa24775d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually much more common that you merge with somebody else than merging with your own branches, so it&amp;rsquo;s worth pointing out that Git makes that very easy too, and in fact, it&amp;rsquo;s not that different from doing a &lt;code&gt;git merge&lt;/code&gt;. In fact, a remote merge ends up being nothing more than &quot;fetch the work from a remote repository into a temporary tag&quot; followed by a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">与其他人合并通常比与自己的分支合并更普遍，因此值得指出的是Git也使合并变得非常容易，实际上，与 &lt;code&gt;git merge&lt;/code&gt; 并没有什么不同。实际上，远程合并最终不过是&amp;ldquo;从远程存储库中获取工作到临时标记中&amp;rdquo;，然后是 &lt;code&gt;git merge&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09aeea995eee0f7341283401be15ea3abb990fd5" translate="yes" xml:space="preserve">
          <source>Iterate over all refs that match &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; and show them according to the given &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;, after sorting them according to the given set of &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; is given, stop after showing that many refs. The interpolated values in &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can optionally be quoted as string literals in the specified host language allowing their direct evaluation in that language.</source>
          <target state="translated">根据给定的 &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; 设置对所有符合 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 的 ref进行迭代，并根据给定的 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 显示它们。如果给出了 &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; ,则在显示很多引用后停止。 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 中的内插值可以选择用指定的宿主语言引用为字符串文字，从而允许使用该语言直接评估。</target>
        </trans-unit>
        <trans-unit id="ddf6f030820afdde653bed6b6ae7f0e48144f06d" translate="yes" xml:space="preserve">
          <source>Join two or more development histories together</source>
          <target state="translated">将两个或更多的发展历史连接在一起</target>
        </trans-unit>
        <trans-unit id="045fff3a75d61e019edb089792c9fca9353d7073" translate="yes" xml:space="preserve">
          <source>Just as the filesystem &lt;code&gt;.&lt;/code&gt; (period) refers to the current directory, using a &lt;code&gt;.&lt;/code&gt; as a repository name in Git (a dot-repository) is a relative path and means your current repository.</source>
          <target state="translated">就像文件系统一样 &lt;code&gt;.&lt;/code&gt; （句点）使用指向当前目录 &lt;code&gt;.&lt;/code&gt; 作为Git中的存储库名称（点存储库）是相对路径，表示您当前的存储库。</target>
        </trans-unit>
        <trans-unit id="dec0baabf794bebc3957d3bc4ac6d462cd46c778" translate="yes" xml:space="preserve">
          <source>Just doing &lt;code&gt;git checkout-index&lt;/code&gt; does nothing. You probably meant &lt;code&gt;git checkout-index -a&lt;/code&gt;. And if you want to force it, you want &lt;code&gt;git checkout-index -f -a&lt;/code&gt;.</source>
          <target state="translated">只是做 &lt;code&gt;git checkout-index&lt;/code&gt; 没有任何作用。您可能是说 &lt;code&gt;git checkout-index -a&lt;/code&gt; 。如果要强制执行此操作，则需要 &lt;code&gt;git checkout-index -f -a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af0df6a1820c3268e00c2212c3d633096817d6ad" translate="yes" xml:space="preserve">
          <source>Just in case you are doing something exotic, it should be noted that all of the &amp;lt;commit&amp;gt; in the above description, except in the &lt;code&gt;--merge-base&lt;/code&gt; case and in the last two forms that use &lt;code&gt;..&lt;/code&gt; notations, can be any &amp;lt;tree&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4909a5e9d012cc77cb3f33966c75c24bd556a2c1" translate="yes" xml:space="preserve">
          <source>Just in case you are doing something exotic, it should be noted that all of the &amp;lt;commit&amp;gt; in the above description, except in the last two forms that use &quot;..&quot; notations, can be any &amp;lt;tree&amp;gt;.</source>
          <target state="translated">以防万一，您正在做一些奇特的事情，应该注意的是，上述描述中的所有&amp;lt;commit&amp;gt;，除了使用&amp;ldquo; ..&amp;rdquo;符号的最后两种形式之外，都可以是任何&amp;lt;tree&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="4be9ee55a1cb0649bc08a5f7fcba1609e56fcabe" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;push&lt;/code&gt;, a batch sequence of one or more &lt;code&gt;import&lt;/code&gt; is terminated with a blank line. For each batch of &lt;code&gt;import&lt;/code&gt;, the remote helper should produce a fast-import stream terminated by a &lt;code&gt;done&lt;/code&gt; command.</source>
          <target state="translated">就像 &lt;code&gt;push&lt;/code&gt; 一样，一个或多个 &lt;code&gt;import&lt;/code&gt; 的批处理序列以空行终止。对于每一批 &lt;code&gt;import&lt;/code&gt; ，远程帮助程序都应生成一个快速 &lt;code&gt;done&lt;/code&gt; 流，该流由完成的命令终止。</target>
        </trans-unit>
        <trans-unit id="586f68de6dc69eba27bb1d4e9d9bb6d0f56b4317" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (GMail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="translated">只需确保在电子邮件客户端中禁用换行即可（GMail的Web界面无论如何都会换行，因此您需要使用真正的IMAP客户端）。</target>
        </trans-unit>
        <trans-unit id="40ff32435dadcaf90c9ed938f5946c67e774e649" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (Gmail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="b97e8895c584b11a83b65d2dacb8c53b7178dd19" translate="yes" xml:space="preserve">
          <source>KMail</source>
          <target state="translated">KMail</target>
        </trans-unit>
        <trans-unit id="2341c447151da84825db8427aea972cadd7288d2" translate="yes" xml:space="preserve">
          <source>Keep a list of repositories you work with regularly:</source>
          <target state="translated">保存一个你经常合作的存储库的列表。</target>
        </trans-unit>
        <trans-unit id="2367d7104c669108a5a4faee96aaf23e4129a768" translate="yes" xml:space="preserve">
          <source>Keep changes in working tree while discarding some previous commits</source>
          <target state="translated">保留工作树中的变化,同时丢弃一些以前的提交。</target>
        </trans-unit>
        <trans-unit id="efc112fed108eb2af53bef134295307559c52881" translate="yes" xml:space="preserve">
          <source>Keep downloaded pack.</source>
          <target state="translated">保持下载的数据包。</target>
        </trans-unit>
        <trans-unit id="9b356018df37cea79789cf69374ce84ecae93c35" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;*&lt;/code&gt; (asterisk) wildcard of the local ref (right of the &lt;code&gt;:&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; be the farthest right path component; however the remote wildcard may be anywhere as long as it&amp;rsquo;s an independent path component (surrounded by &lt;code&gt;/&lt;/code&gt; or EOL). This type of configuration is not automatically created by &lt;code&gt;init&lt;/code&gt; and should be manually entered with a text-editor or using &lt;code&gt;git config&lt;/code&gt;.</source>
          <target state="translated">请记住，在 &lt;code&gt;*&lt;/code&gt; 地方裁判的（星号）通配符（右的 &lt;code&gt;:&lt;/code&gt; ）&lt;strong&gt;必须&lt;/strong&gt;是最右侧的路径组件; 但是，远程通配符可以是任意位置，只要它是一个独立的路径组件（由 &lt;code&gt;/&lt;/code&gt; 或EOL 包围）即可。这种类型的配置不是由 &lt;code&gt;init&lt;/code&gt; 自动创建的，应使用文本编辑器或 &lt;code&gt;git config&lt;/code&gt; 手动输入。</target>
        </trans-unit>
        <trans-unit id="f28d8482458ad8eaca4da9ce6d9f18435a267b61" translate="yes" xml:space="preserve">
          <source>Keep repeating the process: compile the tree, test it, and depending on whether it is good or bad run &lt;code&gt;git bisect good&lt;/code&gt; or &lt;code&gt;git bisect bad&lt;/code&gt; to ask for the next commit that needs testing.</source>
          <target state="translated">继续重复该过程：编译树，对其进行测试，然后根据它的好坏运行 &lt;code&gt;git bisect good&lt;/code&gt; 或 &lt;code&gt;git bisect bad&lt;/code&gt; ,以请求下一个需要测试的提交。</target>
        </trans-unit>
        <trans-unit id="4faf21022722c230f52c5287ce302764467e820e" translate="yes" xml:space="preserve">
          <source>Keep the commits that do not change anything from its parents in the result.</source>
          <target state="translated">保留结果中对其父母没有任何改变的承诺。</target>
        </trans-unit>
        <trans-unit id="ea4937dada87f98e69877594a5bd03ebc5a4fc74" translate="yes" xml:space="preserve">
          <source>Keep the current index contents, and read the contents of the named tree-ish under the directory at &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. The command will refuse to overwrite entries that already existed in the original index file.</source>
          <target state="translated">保留当前的索引内容，并在 &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; 目录下读取命名的tree-ish的内容。该命令将拒绝覆盖原始索引文件中已经存在的条目。</target>
        </trans-unit>
        <trans-unit id="d737c66ea055bf55ed844d15e52460a96096a67f" translate="yes" xml:space="preserve">
          <source>Keep the version from your branch in the work tree, but leave the path in the conflicted state for the user to sort out.</source>
          <target state="translated">在工作树中保留你的分支中的版本,但把路径留在冲突的状态中,让用户来整理。</target>
        </trans-unit>
        <trans-unit id="f9e507eaf43dc998f773c565be5cccbd49c418b4" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without a race condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e57eb6304d53fb35eb7b893fc3d7458db2c90c" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without race condition.</source>
          <target state="translated">创建后将工作树锁定。这等效于 &lt;code&gt;git worktree add&lt;/code&gt; 之后的 &lt;code&gt;git worktree lock&lt;/code&gt; ，但没有竞争条件。</target>
        </trans-unit>
        <trans-unit id="b288ae9d082d21fcccb8cbea92de9e2fd90c35f9" translate="yes" xml:space="preserve">
          <source>Keep unreachable objects in loose form. This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">将无法触及的物体保持在松散状态。这意味着 &lt;code&gt;--revs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fef7648dce54325886b4bd2e05123b8e3f3ba8b" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;project lead&quot; and possibly your &quot;sub-subsystem maintainers&quot;.</source>
          <target state="translated">继续在你的主仓库中工作。你的修改包括你自己的修改,你通过电子邮件收到的补丁,以及从你的 &quot;项目负责人 &quot;和可能的 &quot;子系统维护者 &quot;的 &quot;公共 &quot;仓库中拉出的合并。</target>
        </trans-unit>
        <trans-unit id="ca6eb7beb12ef44a32102578e1d606b2be688242" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;subsystem maintainers&quot;.</source>
          <target state="translated">继续在你的主仓库中工作。你的修改包括你自己的修改,你通过电子邮件收到的补丁,以及从你的 &quot;子系统维护者 &quot;的 &quot;公共 &quot;版本库中提取的合并。</target>
        </trans-unit>
        <trans-unit id="04e2360cc7b28c2ccb26642bb98ceb0fcbba2f5a" translate="yes" xml:space="preserve">
          <source>Keeping a patch series up to date using git rebase</source>
          <target state="translated">使用git rebase使补丁系列保持最新状态</target>
        </trans-unit>
        <trans-unit id="b81b785228a23fa6b75a5abffb474819b40a8136" translate="yes" xml:space="preserve">
          <source>Kill keywords: will extract files with &lt;code&gt;-kk&lt;/code&gt; from the CVS archive to avoid noisy changesets. Highly recommended, but off by default to preserve compatibility with early imported trees.</source>
          <target state="translated">Kill关键字：将使用 &lt;code&gt;-kk&lt;/code&gt; 从CVS存档中提取文件，以避免产生嘈杂的变更集。高度推荐，但默认情况下处于禁用状态，以保持与早期导入树的兼容性。</target>
        </trans-unit>
        <trans-unit id="02658e782a0ecc008f0ca6ffc2a20f7bdbee96d7" translate="yes" xml:space="preserve">
          <source>Label for the &quot;home link&quot; at the top of all pages, leading to &lt;code&gt;$home_link&lt;/code&gt; (usually the main gitweb page, which contains the projects list). It is used as the first component of gitweb&amp;rsquo;s &quot;breadcrumb trail&quot;: &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt;. Can be set at build time using the &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; variable. By default it is set to &quot;projects&quot;, as this link leads to the list of projects. Another popular choice is to set it to the name of site. Note that it is treated as raw HTML so it should not be set from untrusted sources.</source>
          <target state="translated">所有页面顶部的&amp;ldquo;主链接&amp;rdquo;标签，指向 &lt;code&gt;$home_link&lt;/code&gt; （通常是gitweb主页面，其中包含项目列表）。它用作gitweb的&amp;ldquo;面包屑跟踪&amp;rdquo;的第一个组件： &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt; 。可以在构建时使用 &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; 变量进行设置。默认情况下，它设置为&amp;ldquo;项目&amp;rdquo;，因为此链接指向项目列表。另一个流行的选择是将其设置为站点名称。请注意，它被视为原始HTML，因此不应从不受信任的来源进行设置。</target>
        </trans-unit>
        <trans-unit id="f135ec40c7a65e232b6284c7eadaae14bc4ec8e7" translate="yes" xml:space="preserve">
          <source>Labelling of conflicts markers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b52717c24503e82535f1da97544e03ef42f759" translate="yes" xml:space="preserve">
          <source>Large projects are often composed of smaller, self-contained modules. For example, an embedded Linux distribution&amp;rsquo;s source tree would include every piece of software in the distribution with some local modifications; a movie player might need to build against a specific, known-working version of a decompression library; several independent programs might all share the same build scripts.</source>
          <target state="translated">大型项目通常由较小的独立模块组成。例如，嵌入式Linux发行版的源代码树将包含发行版中的每个软件，并进行一些本地修改。电影播放器​​可能需要针对特定​​的已知工作版本的解压缩库进行构建；几个独立的程序可能都共享相同的构建脚本。</target>
        </trans-unit>
        <trans-unit id="eebf4c31734b36e391dbec8f9bdc861cf73858fc" translate="yes" xml:space="preserve">
          <source>Later, Bob can update his repo with Alice&amp;rsquo;s latest changes using</source>
          <target state="translated">稍后，鲍勃可以使用以下信息使用爱丽丝的最新更改来更新他的仓库</target>
        </trans-unit>
        <trans-unit id="b67e320eff785b446a82207f60f64bae4d9398b2" translate="yes" xml:space="preserve">
          <source>Later, you can see whether your changes have been applied by saying (still on &lt;code&gt;topic&lt;/code&gt;):</source>
          <target state="translated">稍后，您可以通过说（仍然是 &lt;code&gt;topic&lt;/code&gt; ）来查看您的更改是否已应用：</target>
        </trans-unit>
        <trans-unit id="0c480c6f24e2582817904a3ca717bfe059eaf9ba" translate="yes" xml:space="preserve">
          <source>Leading &lt;code&gt;Re:&lt;/code&gt;, &lt;code&gt;re:&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">领先的 &lt;code&gt;Re:&lt;/code&gt; ， &lt;code&gt;re:&lt;/code&gt; 和 &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cba31f4e857a58fc5d56324b4f5b7ba501d5431" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace are ignored.</source>
          <target state="translated">前面和后面的空白被忽略。</target>
        </trans-unit>
        <trans-unit id="9400d93a0e4bf560ae2ff2a8521028a1c12485de" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace.</source>
          <target state="translated">前面和后面的空白处。</target>
        </trans-unit>
        <trans-unit id="b0ca289dea1d9e545043917d0313a90afe03b7b2" translate="yes" xml:space="preserve">
          <source>Leading bracketed strings (between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, usually &lt;code&gt;[PATCH]&lt;/code&gt;).</source>
          <target state="translated">前括号括起来的字符串（在 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 之间，通常是 &lt;code&gt;[PATCH]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7f2cfa3cf0fb13a4db7434c1da2b8c70142683de" translate="yes" xml:space="preserve">
          <source>Leaving this value at the default size is fine unless you know that either the remote server or a proxy in the middle doesn&amp;rsquo;t support HTTP/1.1 (which introduced the chunked transfer encoding) or is known to be broken with chunked data. This is often (erroneously) suggested as a solution for generic push problems, but since almost every server and proxy supports at least HTTP/1.1, raising this value usually doesn&amp;rsquo;t solve most push problems. A server or proxy that didn&amp;rsquo;t correctly support HTTP/1.1 and chunked transfer encoding wouldn&amp;rsquo;t be that useful on the Internet today, since it would break lots of traffic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5fae931542a3559bb8c0d5b861a24e60a1ac67c" translate="yes" xml:space="preserve">
          <source>Left-, middle-, or right-align the content between %(align:&amp;hellip;​) and %(end). The &quot;align:&quot; is followed by &lt;code&gt;width=&amp;lt;width&amp;gt;&lt;/code&gt; and &lt;code&gt;position=&amp;lt;position&amp;gt;&lt;/code&gt; in any order separated by a comma, where the &lt;code&gt;&amp;lt;position&amp;gt;&lt;/code&gt; is either left, right or middle, default being left and &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; is the total length of the content with alignment. For brevity, the &quot;width=&quot; and/or &quot;position=&quot; prefixes may be omitted, and bare &amp;lt;width&amp;gt; and &amp;lt;position&amp;gt; used instead. For instance, &lt;code&gt;%(align:&amp;lt;width&amp;gt;,&amp;lt;position&amp;gt;)&lt;/code&gt;. If the contents length is more than the width then no alignment is performed. If used with &lt;code&gt;--quote&lt;/code&gt; everything in between %(align:&amp;hellip;​) and %(end) is quoted, but if nested then only the topmost level performs quoting.</source>
          <target state="translated">在％（align：...）和％（end）之间将内容左对齐，中对齐或右对齐。 &amp;ldquo; align：&amp;rdquo;后面是 &lt;code&gt;width=&amp;lt;width&amp;gt;&lt;/code&gt; 和 &lt;code&gt;position=&amp;lt;position&amp;gt;&lt;/code&gt; ，其后用逗号分隔的任何顺序，其中 &lt;code&gt;&amp;lt;position&amp;gt;&lt;/code&gt; 为左，右或中间，默认为left， &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; 为总数内容的长度与对齐方式。为简便起见，可以省略&amp;ldquo; width =&amp;rdquo;和/或&amp;ldquo; position =&amp;rdquo;前缀，而使用裸&amp;lt;width&amp;gt;和&amp;lt;position&amp;gt;代替。例如， &lt;code&gt;%(align:&amp;lt;width&amp;gt;,&amp;lt;position&amp;gt;)&lt;/code&gt; 。如果内容长度大于宽度，则不执行对齐。如果与 &lt;code&gt;--quote&lt;/code&gt; 一起使用，请引用％（align：&amp;hellip;）和％（end）之间的所有内容，但是如果嵌套，则只有最顶层执行引用。</target>
        </trans-unit>
        <trans-unit id="4913da5c2a93f28cfca5df10654d75686a764062" translate="yes" xml:space="preserve">
          <source>Legacy alias for &lt;code&gt;--smtp-encryption ssl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--smtp-encryption ssl&lt;/code&gt; 的旧别名。</target>
        </trans-unit>
        <trans-unit id="8c79d7d578b1dfedd061424fe06d7bbd7bf7860a" translate="yes" xml:space="preserve">
          <source>Legacy monitoring operations are not supported (edit, watch and related). Exports and tagging (tags and branches) are not supported at this stage.</source>
          <target state="translated">不支持遗留的监控操作(编辑、观察和相关)。现阶段不支持导出和标记(标记和分支)。</target>
        </trans-unit>
        <trans-unit id="efdb524a0ef0e2256e12ca50686b4d8bc222c208" translate="yes" xml:space="preserve">
          <source>Lesson three is: study the code. Really, it is the best way to learn about the organization of Git (after you know the basic concepts).</source>
          <target state="translated">第三课是:研究代码。真的,这是学习Git组织结构的最好方法(在你知道基本概念之后)。</target>
        </trans-unit>
        <trans-unit id="893b35eb2ef36c307a5615060033f2510cf02d9b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also suppose that we have a cleaned up graph like one after step 1) in the bisection algorithm above. This means that we can measure the information we get in terms of number of commit we can remove from the graph..</source>
          <target state="translated">我们还假设在上面的二分法中，我们在步骤1）之后有一个清理过的图。这意味着我们可以根据可以从图中删除的提交次数来衡量获得的信息。</target>
        </trans-unit>
        <trans-unit id="c8d0e17bfd7a63329a6082665d278b7fb499b0b6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s skip over the obvious details; the only really interesting part here is the call to &lt;code&gt;get_sha1()&lt;/code&gt;. It tries to interpret &lt;code&gt;argv[2]&lt;/code&gt; as an object name, and if it refers to an object which is present in the current repository, it writes the resulting SHA-1 into the variable &lt;code&gt;sha1&lt;/code&gt;.</source>
          <target state="translated">让我们跳过明显的细节；唯一真正有趣的部分是对 &lt;code&gt;get_sha1()&lt;/code&gt; 的调用。它尝试将 &lt;code&gt;argv[2]&lt;/code&gt; 解释为对象名称，如果它引用当前存储库中存在的对象，则会将生成的SHA-1写入变量 &lt;code&gt;sha1&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="cc9abf37f1be76cb29eb48ded27f1fe2938a8b22" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new project and create a small amount of history:</source>
          <target state="translated">让我们开始一个新项目并创建少量历史记录：</target>
        </trans-unit>
        <trans-unit id="f0d62f9783a955198cc607ca11b36e935a346c02" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the following graph as an example:</source>
          <target state="translated">让我们以下图为例：</target>
        </trans-unit>
        <trans-unit id="1c0b60e2ec5a47fbbf8d5055a8c4fd552a20bdbd" translate="yes" xml:space="preserve">
          <source>Lets you rewrite Git revision history by rewriting the branches mentioned in the &amp;lt;rev-list options&amp;gt;, applying custom filters on each revision. Those filters can modify each tree (e.g. removing a file or running a perl rewrite on all files) or information about each commit. Otherwise, all information (including original commit times or merge information) will be preserved.</source>
          <target state="translated">通过重写&amp;lt;rev-list options&amp;gt;中提到的分支，并在每个修订版上应用自定义过滤器，可以重写Git修订历史记录。这些过滤器可以修改每棵树（例如，删除文件或对所有文件运行perl重写）或有关每次提交的信息。否则，将保留所有信息（包括原始提交时间或合并信息）。</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="8a762e028503c19597a52f977263fd61a8df56e0" translate="yes" xml:space="preserve">
          <source>Lighttpd</source>
          <target state="translated">Lighttpd</target>
        </trans-unit>
        <trans-unit id="c20b9e30add4d8fcb9e944c3a79357b0eb58faf9" translate="yes" xml:space="preserve">
          <source>Like --allow-empty this command is primarily for use by foreign SCM interface scripts. It allows you to create a commit with an empty commit message without using plumbing commands like &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt;.</source>
          <target state="translated">像--allow-empty一样，此命令主要供外部SCM接口脚本使用。它允许您使用空的提交消息创建提交，而无需使用&lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]之&lt;/a&gt;类的探测命令。</target>
        </trans-unit>
        <trans-unit id="5f6f49e5a6f1778648e9730643fd43474f2dbc13" translate="yes" xml:space="preserve">
          <source>Like --get-all, but interprets the name as a regular expression and writes out the key names. Regular expression matching is currently case-sensitive and done against a canonicalized version of the key in which section and variable names are lowercased, but subsection names are not.</source>
          <target state="translated">与 --get-all 类似,但将名称解释为正则表达式,并写出键名。正则表达式匹配目前是区分大小写的,并且是针对规范化的键的版本进行的,其中章节和变量名称是小写的,但分节名称不是。</target>
        </trans-unit>
        <trans-unit id="f93e6625e77c19d6664d2e45faf25a33780dbe37" translate="yes" xml:space="preserve">
          <source>Like --import-marks but instead of erroring out, silently skips the file if it does not exist.</source>
          <target state="translated">和--import-marks一样,但如果文件不存在,不会出错,而是默默地跳过。</target>
        </trans-unit>
        <trans-unit id="0eda32196b28e34b5200ae38915b28d72ba0802b" translate="yes" xml:space="preserve">
          <source>Like --import-marks except in two respects: first, only one &quot;feature import-marks&quot; or &quot;feature import-marks-if-exists&quot; command is allowed per stream; second, an --import-marks= or --import-marks-if-exists command-line option overrides any of these &quot;feature&quot; commands in the stream; third, &quot;feature import-marks-if-exists&quot; like a corresponding command-line option silently skips a nonexistent file.</source>
          <target state="translated">和--import-marks一样,除了两个方面:第一,每个流只允许一个 &quot;特征导入-marks &quot;或 &quot;特征导入-marks-if-exists &quot;命令;第二,一个--import-marks=或--import-marks-if-exists命令行选项覆盖流中的任何一个 &quot;特征 &quot;命令;第三,&quot;特征导入-marks-if-exists &quot;像一个相应的命令行选项一样,默默地跳过一个不存在的文件。</target>
        </trans-unit>
        <trans-unit id="ea166a12e166b75ad46458f975797a03647dc62d" translate="yes" xml:space="preserve">
          <source>Like --keep create a .keep file before moving the index into its final destination, but rather than creating an empty file place &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; followed by an LF into the .keep file. The &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; message can later be searched for within all .keep files to locate any which have outlived their usefulness.</source>
          <target state="translated">像--keep一样，在将索引移到其最终目的地之前创建.keep文件，但不要在 &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; 后面创建一个空文件位置，然后在.keep文件中添加LF。所述 &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; 稍后可搜索内的所有文件.keep找到任何已失去了利用价值信息。</target>
        </trans-unit>
        <trans-unit id="da58772c0d323657b31dd0d6c68daa01b72022dc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--cherry-pick&lt;/code&gt; (see below) but mark equivalent commits with &lt;code&gt;=&lt;/code&gt; rather than omitting them, and inequivalent ones with &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;--cherry-pick&lt;/code&gt; 一样（请参阅下文），但用 &lt;code&gt;=&lt;/code&gt; 标记等效的提交，而不是用 &lt;code&gt;+&lt;/code&gt; 标记，而不等价的使用+标记。</target>
        </trans-unit>
        <trans-unit id="18b014ee75198b1ce501d5b1546fe06cd49ddd23" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--git-dir&lt;/code&gt;, but its output is always the canonicalized absolute path.</source>
          <target state="translated">与 &lt;code&gt;--git-dir&lt;/code&gt; 类似，但其输出始终是规范化的绝对​​路径。</target>
        </trans-unit>
        <trans-unit id="af1d4315bb510027eb7e61b588f2b477e26e55d4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--refresh&lt;/code&gt;, but checks stat information unconditionally, without regard to the &quot;assume unchanged&quot; setting.</source>
          <target state="translated">与 &lt;code&gt;--refresh&lt;/code&gt; 类似，但是无条件地检查统计信息，而不考虑&amp;ldquo;假定不变&amp;rdquo;设置。</target>
        </trans-unit>
        <trans-unit id="649d7b810a2269259a3e3571033e0da598ccd04e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;-C&lt;/code&gt;, but with &lt;code&gt;-c&lt;/code&gt; the editor is invoked, so that the user can further edit the commit message.</source>
          <target state="translated">与 &lt;code&gt;-C&lt;/code&gt; 相似，但与 &lt;code&gt;-c&lt;/code&gt; 一起调用编辑器，以便用户可以进一步编辑提交消息。</target>
        </trans-unit>
        <trans-unit id="72f500fc1c4bd05ad014fbedf9cd9b9fb51f168b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;-C&lt;/code&gt;, but with &lt;code&gt;-c&lt;/code&gt; the editor is invoked, so that the user can further edit the note message.</source>
          <target state="translated">与 &lt;code&gt;-C&lt;/code&gt; 相似，但与 &lt;code&gt;-c&lt;/code&gt; 一起调用编辑器，以便用户可以进一步编辑注释消息。</target>
        </trans-unit>
        <trans-unit id="f749f3d3ddfe6600b3752ee19e4bd9b6731f362f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;email&lt;/code&gt;, but lines in the commit message starting with &quot;From &quot; (preceded by zero or more &quot;&amp;gt;&quot;) are quoted with &quot;&amp;gt;&quot; so they aren&amp;rsquo;t confused as starting a new commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f2734a31de3aa99c55dc536f672e3afeacd6e67" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; this variable has corresponding &lt;code&gt;receive.fsck.skipList&lt;/code&gt; and &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; variants.</source>
          <target state="translated">像 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 此变量具有相应的 &lt;code&gt;receive.fsck.skipList&lt;/code&gt; 和 &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; 变体。</target>
        </trans-unit>
        <trans-unit id="8f4973bf138d30d1fbff518822c72869393d6ab3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;git push&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, imports handled by fast-import are safe to run alongside parallel &lt;code&gt;git repack -a -d&lt;/code&gt; or &lt;code&gt;git gc&lt;/code&gt; invocations, or any other Git operation (including &lt;code&gt;git prune&lt;/code&gt;, as loose objects are never used by fast-import).</source>
          <target state="translated">像 &lt;code&gt;git push&lt;/code&gt; 或 &lt;code&gt;git fetch&lt;/code&gt; 一样，快速导入处理的导入可以安全地与并行 &lt;code&gt;git repack -a -d&lt;/code&gt; 或 &lt;code&gt;git gc&lt;/code&gt; 调用或任何其他Git操作（包括 &lt;code&gt;git prune&lt;/code&gt; )一起运行，因为快速导入从不使用松散对象）。</target>
        </trans-unit>
        <trans-unit id="c7a0caab42cb430b8f7eb62e2b9ee91196438e5f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;git rebase&lt;/code&gt;; this requires that the working tree be clean and have no uncommitted changes.</source>
          <target state="translated">像 &lt;code&gt;git rebase&lt;/code&gt; ; 这要求工作树是干净的并且没有未提交的更改。</target>
        </trans-unit>
        <trans-unit id="94b902a35ff412729993e3558dc74f40d9a138f0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;mailmap.file&lt;/code&gt;, but consider the value as a reference to a blob in the repository. If both &lt;code&gt;mailmap.file&lt;/code&gt; and &lt;code&gt;mailmap.blob&lt;/code&gt; are given, both are parsed, with entries from &lt;code&gt;mailmap.file&lt;/code&gt; taking precedence. In a bare repository, this defaults to &lt;code&gt;HEAD:.mailmap&lt;/code&gt;. In a non-bare repository, it defaults to empty.</source>
          <target state="translated">类似于 &lt;code&gt;mailmap.file&lt;/code&gt; ，但应将该值视为对存储库中的blob的引用。如果同时给出了 &lt;code&gt;mailmap.file&lt;/code&gt; 和mailmap.blob， &lt;code&gt;mailmap.blob&lt;/code&gt; 两者都解析，其中 &lt;code&gt;mailmap.file&lt;/code&gt; 中的条目优先。在裸存储库中，默认为 &lt;code&gt;HEAD:.mailmap&lt;/code&gt; 。在非裸仓库中，它默认为空。</target>
        </trans-unit>
        <trans-unit id="e5b79d6b46ed0bad865e7c66642f5df5197bbc3e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pop&lt;/code&gt;, but do not remove the state from the stash list. Unlike &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; may be any commit that looks like a commit created by &lt;code&gt;stash push&lt;/code&gt; or &lt;code&gt;stash create&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;pop&lt;/code&gt; ，但不要从存储列表中删除状态。与 &lt;code&gt;pop&lt;/code&gt; 不同， &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 可以是任何看起来像由 &lt;code&gt;stash push&lt;/code&gt; 或 &lt;code&gt;stash create&lt;/code&gt; 创建的提交的提交。</target>
        </trans-unit>
        <trans-unit id="b42cf6e877b403442b6c5e230e0a3121abfa79f2" translate="yes" xml:space="preserve">
          <source>Like get, but returns all values for a multi-valued key.</source>
          <target state="translated">和get一样,但是返回一个多值键的所有值。</target>
        </trans-unit>
        <trans-unit id="73701f369b01fba26e9d0bb68ef652b62a8e8ce1" translate="yes" xml:space="preserve">
          <source>Like host.example:foo/repo, but use /home/foo/.ssh/somekey as keypair and user as user on remote side. This avoids needing to edit .ssh/config.</source>
          <target state="translated">就像host.example:foo/repo一样,但在远端使用/home/foo/.ssh/somekey作为密钥对,用户作为用户。这就避免了需要编辑 .ssh/config。</target>
        </trans-unit>
        <trans-unit id="6a22ef6226883a7823ee7468ab3e5221cd1b0fcc" translate="yes" xml:space="preserve">
          <source>Like many programs that switch user id, the daemon does not reset environment variables such as &lt;code&gt;$HOME&lt;/code&gt; when it runs git programs, e.g. &lt;code&gt;upload-pack&lt;/code&gt; and &lt;code&gt;receive-pack&lt;/code&gt;. When using this option, you may also want to set and export &lt;code&gt;HOME&lt;/code&gt; to point at the home directory of &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; before starting the daemon, and make sure any Git configuration files in that directory are readable by &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">与许多切换用户ID的程序一样，该守护程序在运行git程序（例如 &lt;code&gt;upload-pack&lt;/code&gt; 和 &lt;code&gt;receive-pack&lt;/code&gt; )时不会重置环境变量，例如 &lt;code&gt;$HOME&lt;/code&gt; 。使用此选项时，您可能还需要在启动守护程序之前设置和导出 &lt;code&gt;HOME&lt;/code&gt; ,以指向 &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; 的主目录，并确保 &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; 可以读取该目录中的所有Git配置文件。</target>
        </trans-unit>
        <trans-unit id="955d6409ae367c03bad138119c6bf959eda46b3c" translate="yes" xml:space="preserve">
          <source>Likewise, when the &lt;code&gt;LV&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;-c&lt;/code&gt;. You can override this setting by exporting &lt;code&gt;LV&lt;/code&gt; with another value or setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;lv +c&lt;/code&gt;.</source>
          <target state="translated">同样，当未设置 &lt;code&gt;LV&lt;/code&gt; 环境变量时，Git会将其设置为 &lt;code&gt;-c&lt;/code&gt; 。您可以通过用另一个值导出 &lt;code&gt;LV&lt;/code&gt; 或将 &lt;code&gt;core.pager&lt;/code&gt; 设置为 &lt;code&gt;lv +c&lt;/code&gt; 来覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="da647d41a556bd9f858a9fb821a95fe4fa6d0849" translate="yes" xml:space="preserve">
          <source>Limit commits to the ones touching files in the given paths. Note, to avoid ambiguity with respect to revision names use &quot;--&quot; to separate the paths from any preceding options.</source>
          <target state="translated">将提交限制在给定路径中的文件。注意,为了避免在修订名方面产生歧义,使用&quot;--&quot;将路径与前面的选项分开。</target>
        </trans-unit>
        <trans-unit id="a8f6287e3aa57458fad3449d202e28c228d6d460" translate="yes" xml:space="preserve">
          <source>Limit diff output to named subtrees.</source>
          <target state="translated">限制差异输出到命名的子树。</target>
        </trans-unit>
        <trans-unit id="73ea1d1481ae126a39e8d8a25424a40b0120067c" translate="yes" xml:space="preserve">
          <source>Limit fetching to ancestor-chains not longer than n. &lt;code&gt;git-upload-pack&lt;/code&gt; treats the special depth 2147483647 as infinite even if there is an ancestor-chain that long.</source>
          <target state="translated">将获取限制为不超过n的祖先链。 &lt;code&gt;git-upload-pack&lt;/code&gt; 将特殊深度2147483647视为无限，即使有一个祖先链那么长。</target>
        </trans-unit>
        <trans-unit id="3548328e70b776f579a206b5e26f3a2cdd3bf54c" translate="yes" xml:space="preserve">
          <source>Limit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a &lt;code&gt;shallow&lt;/code&gt; repository created by &lt;code&gt;git clone&lt;/code&gt; with &lt;code&gt;--depth=&amp;lt;depth&amp;gt;&lt;/code&gt; option (see &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;), deepen or shorten the history to the specified number of commits. Tags for the deepened commits are not fetched.</source>
          <target state="translated">限制从每个远程分支历史记录的顶端提取指定数量的提交。如果使用 &lt;code&gt;--depth=&amp;lt;depth&amp;gt;&lt;/code&gt; 选项（请参见&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;）将其提取到由 &lt;code&gt;git clone&lt;/code&gt; 创建的 &lt;code&gt;shallow&lt;/code&gt; 存储库中，请加深历史记录或将历史记录缩短为指定的提交次数。未获取深化提交的标签。</target>
        </trans-unit>
        <trans-unit id="406e704b5fa6637d1092aef900d6bea100f59424" translate="yes" xml:space="preserve">
          <source>Limit output to the one commit object which is roughly halfway between included and excluded commits. Note that the bad bisection ref &lt;code&gt;refs/bisect/bad&lt;/code&gt; is added to the included commits (if it exists) and the good bisection refs &lt;code&gt;refs/bisect/good-*&lt;/code&gt; are added to the excluded commits (if they exist). Thus, supposing there are no refs in &lt;code&gt;refs/bisect/&lt;/code&gt;, if</source>
          <target state="translated">将输出限制为一个提交对象，该对象大约介于包含提交和排除提交之间。请注意，错误的二等分引用 &lt;code&gt;refs/bisect/bad&lt;/code&gt; 被添加到包括的提交中（如果存在），而良好的二等分引用 &lt;code&gt;refs/bisect/good-*&lt;/code&gt; 被添加到被排除的提交中（如果它们存在）。因此，假设 &lt;code&gt;refs/bisect/&lt;/code&gt; 中没有ref ，如果</target>
        </trans-unit>
        <trans-unit id="2b149769f0e9e62c7755e40f7d9c9b100ff198f3" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones that match all given &lt;code&gt;--grep&lt;/code&gt;, instead of ones that match at least one.</source>
          <target state="translated">将提交输出限制为与所有给定的 &lt;code&gt;--grep&lt;/code&gt; 匹配的提交，而不是至少匹配一个的提交。</target>
        </trans-unit>
        <trans-unit id="119c553a83e823fd710ae4f2da2e455c4cb090b7" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression). With more than one &lt;code&gt;--author=&amp;lt;pattern&amp;gt;&lt;/code&gt;, commits whose author matches any of the given patterns are chosen (similarly for multiple &lt;code&gt;--committer=&amp;lt;pattern&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">将提交输出限制为具有与指定模式（正则表达式）匹配的作者/提交者标题行的提交。与多于一个的 &lt;code&gt;--author=&amp;lt;pattern&amp;gt;&lt;/code&gt; ，提交其作者匹配任何给定的图案的被选择（类似地对于多个 &lt;code&gt;--committer=&amp;lt;pattern&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dd1c85bc38b39ba5aff2bee57d4deea0c60fd712" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with log message that do not match the pattern specified with &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">将提交输出限制为日志消息与 &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; 指定的模式不匹配的提交。</target>
        </trans-unit>
        <trans-unit id="bd9eadb3ad8dfb9ffb371dc1589fe6576ab540f4" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with log message that matches the specified pattern (regular expression). With more than one &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt;, commits whose message matches any of the given patterns are chosen (but see &lt;code&gt;--all-match&lt;/code&gt;).</source>
          <target state="translated">将提交输出限制为具有与指定模式（正则表达式）匹配的日志消息的提交。使用多个 &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; ，将选择其消息与任何给定模式匹配的提交（但请参见 &lt;code&gt;--all-match&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d1b86714045e4612b85a2fa8cf22123bd3513cb6" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with reflog entries that match the specified pattern (regular expression). With more than one &lt;code&gt;--grep-reflog&lt;/code&gt;, commits whose reflog message matches any of the given patterns are chosen. It is an error to use this option unless &lt;code&gt;--walk-reflogs&lt;/code&gt; is in use.</source>
          <target state="translated">将提交输出限制为具有与指定模式（正则表达式）匹配的reflog条目的提交。使用多个 &lt;code&gt;--grep-reflog&lt;/code&gt; ，将选择其reflog消息与任何给定模式匹配的提交。除非正在使用 &lt;code&gt;--walk-reflogs&lt;/code&gt; ,否则使用此选项是错误的。</target>
        </trans-unit>
        <trans-unit id="2b5d877818bdb0956a66e366504390cf3fe65b29" translate="yes" xml:space="preserve">
          <source>Limit the commits output to specified time range.</source>
          <target state="translated">将提交的输出限制在指定的时间范围内。</target>
        </trans-unit>
        <trans-unit id="d8dbf5f629bd3296e9ab1177de95e69729e1d54b" translate="yes" xml:space="preserve">
          <source>Limit the displayed commits to those directly on the ancestry chain between the &amp;ldquo;from&amp;rdquo; and &amp;ldquo;to&amp;rdquo; commits in the given commit range. I.e. only display commits that are ancestor of the &amp;ldquo;to&amp;rdquo; commit and descendants of the &amp;ldquo;from&amp;rdquo; commit.</source>
          <target state="translated">将显示的提交限制为直接在给定提交范围内的&amp;ldquo; from&amp;rdquo;和&amp;ldquo; to&amp;rdquo;提交之间的祖先链上的提交。即仅显示&amp;ldquo; to&amp;rdquo;提交的祖先提交和&amp;ldquo; from&amp;rdquo;提交的后代。</target>
        </trans-unit>
        <trans-unit id="ed8c2d4ed1408e7d7da83719bcf77ad7b5896ff9" translate="yes" xml:space="preserve">
          <source>Limit the number of commits imported. Workaround for cases where cvsimport leaks memory.</source>
          <target state="translated">限制导入的提交次数。cvsimport 泄漏内存时的解决方法。</target>
        </trans-unit>
        <trans-unit id="1adada65b7a03da88bf0748c36055d961c64b07a" translate="yes" xml:space="preserve">
          <source>Limit the number of commits to output.</source>
          <target state="translated">限制输出的提交次数。</target>
        </trans-unit>
        <trans-unit id="38e02fe4379a543b3e47180cba4d6468bec3e601" translate="yes" xml:space="preserve">
          <source>Limit the revisions to show. This can be either a single revision meaning show from the given revision and back, or it can be a range in the form &quot;&lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt;..&lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt;&quot; to show all revisions between &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; and back to &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt;. Note, more advanced revision selection can be applied. For a more complete list of ways to spell object names, see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">将修订限制为显示。它既可以是单个修订版本，也可以从给定的修订版本开始显示，也可以是&amp;ldquo; &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; .. &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; &amp;rdquo; 形式的范围，以显示从 &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; 到回到 &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; 之间的所有修订版本。注意，可以应用更多高级版本选择。有关拼写对象名称的方法的完整列表，请参见&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="674ff0df4160db3404d979762630ae612e98f156" translate="yes" xml:space="preserve">
          <source>Limit the width of the graph part in --stat output. If set, applies to all commands generating --stat output except format-patch.</source>
          <target state="translated">限制-stat输出中图形部分的宽度。如果设置,则适用于除 format-patch 之外的所有生成 --stat 输出的命令。</target>
        </trans-unit>
        <trans-unit id="29e45322508b52ceb051971d532eab460b3dc7d7" translate="yes" xml:space="preserve">
          <source>Limit to &quot;refs/heads&quot; and &quot;refs/tags&quot;, respectively. These options are not mutually exclusive; when given both, references stored in &quot;refs/heads&quot; and &quot;refs/tags&quot; are displayed.</source>
          <target state="translated">分别限制为 &quot;refs/heads &quot;和 &quot;refs/tags&quot;。这些选项并不相互排斥;如果同时给出这两个选项,则会显示存储在 &quot;refs/heads &quot;和 &quot;refs/tags &quot;中的引用。</target>
        </trans-unit>
        <trans-unit id="66b9fb961da3804ca95085a20ace37a86529e6f7" translate="yes" xml:space="preserve">
          <source>Limit to only refs/heads and refs/tags, respectively. These options are &lt;code&gt;not&lt;/code&gt; mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed.</source>
          <target state="translated">分别仅限于裁判/标头和裁判/标牌。这些选项 &lt;code&gt;not&lt;/code&gt; 互斥的；同时给定时，将显示存储在refs / heads和refs / tags中的参考。</target>
        </trans-unit>
        <trans-unit id="cce06ee642a7b80587fe58f4572571b699424f46" translate="yes" xml:space="preserve">
          <source>Limit to only refs/heads and refs/tags, respectively. These options are &lt;code&gt;not&lt;/code&gt; mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed. Note that &lt;code&gt;git ls-remote -h&lt;/code&gt; used without anything else on the command line gives help, consistent with other git subcommands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="e8bb22d887f5d59400be2b36a39e61d714bda7bc" translate="yes" xml:space="preserve">
          <source>Limiting the diff output</source>
          <target state="translated">限制差异输出</target>
        </trans-unit>
        <trans-unit id="b7748eb338af2086cdad1f6af364c3481df64676" translate="yes" xml:space="preserve">
          <source>Limits the number of commits to show to 3.</source>
          <target state="translated">将显示的提交次数限制为3次。</target>
        </trans-unit>
        <trans-unit id="efd756293dbb86969a7022bf4157b3145d6076f3" translate="yes" xml:space="preserve">
          <source>Limits the paths affected by the operation.</source>
          <target state="translated">限制受操作影响的路径。</target>
        </trans-unit>
        <trans-unit id="8375cb461aa1ace8d2ffdda18edb87b333f2f4d1" translate="yes" xml:space="preserve">
          <source>Line numbers count from 1.</source>
          <target state="translated">行号从1开始计算。</target>
        </trans-unit>
        <trans-unit id="3d9326a0fc6538daba3b0f3096cf5c416812b52b" translate="yes" xml:space="preserve">
          <source>Lines starting with a hash (&quot;&lt;code&gt;#&lt;/code&gt;&quot;) are ignored, so they can be used for comments. Add a backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;) to the beginning of the pattern if it starts with a hash.</source>
          <target state="translated">以井号（&amp;ldquo; &lt;code&gt;#&lt;/code&gt; &amp;rdquo;）开头的行将被忽略，因此它们可用于注释。如果模式以哈希开头，请在模式的开头添加反斜杠（&amp;ldquo; &lt;code&gt;\&lt;/code&gt; &amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="8e28fd820953d60830c4b1106307e2e0b6872452" translate="yes" xml:space="preserve">
          <source>Linewrap the output by wrapping each line at &lt;code&gt;width&lt;/code&gt;. The first line of each entry is indented by &lt;code&gt;indent1&lt;/code&gt; spaces, and the second and subsequent lines are indented by &lt;code&gt;indent2&lt;/code&gt; spaces. &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;indent1&lt;/code&gt;, and &lt;code&gt;indent2&lt;/code&gt; default to 76, 6 and 9 respectively.</source>
          <target state="translated">通过将每行以 &lt;code&gt;width&lt;/code&gt; 换行来换行输出。每个条目的第一行由 &lt;code&gt;indent1&lt;/code&gt; 空格缩进，第二行和后续行由 &lt;code&gt;indent2&lt;/code&gt; 空格缩进。 &lt;code&gt;width&lt;/code&gt; ， &lt;code&gt;indent1&lt;/code&gt; 和 &lt;code&gt;indent2&lt;/code&gt; 分别默认为76、6和9。</target>
        </trans-unit>
        <trans-unit id="1d1f6a47e210ac264339f2e30472d9fdf4025a54" translate="yes" xml:space="preserve">
          <source>Links and their targets</source>
          <target state="translated">链接及其目标</target>
        </trans-unit>
        <trans-unit id="7177342122325630102d4a83723d13417535ac19" translate="yes" xml:space="preserve">
          <source>Linus Torvalds originally designed Git to be a user space file system, i.e. the infrastructure to hold files and directories. That ensured the efficiency and speed of Git.</source>
          <target state="translated">Linus Torvalds最初设计的Git是一个用户空间的文件系统,即存放文件和目录的基础设施。这保证了Git的效率和速度。</target>
        </trans-unit>
        <trans-unit id="9f9879c2ed0b6b8dfd5d9b1ecb4faa0c5584d26d" translate="yes" xml:space="preserve">
          <source>Linus Torvalds, for example, makes new kernel releases by tagging them, then running:</source>
          <target state="translated">例如,Linus Torvalds通过标记新的内核版本,然后运行。</target>
        </trans-unit>
        <trans-unit id="c215fd74e10e91e4728dc7ef559cf830d21a3457" translate="yes" xml:space="preserve">
          <source>Linus&amp;rsquo;s tree will be stored in the remote-tracking branch named origin/master, and can be updated using &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;; you can track other public trees using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; to set up a &quot;remote&quot; and &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; to keep them up to date; see &lt;a href=&quot;#repositories-and-branches&quot;&gt;Repositories and Branches&lt;/a&gt;.</source>
          <target state="translated">Linus的树将存储在名为origin / master的远程跟踪分支中，并且可以使用&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;进行更新；您可以使用&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;设置&amp;ldquo; remote&amp;rdquo;和&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;跟踪其他公共树来跟踪它们；请参阅&lt;a href=&quot;#repositories-and-branches&quot;&gt;存储库和分支&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a79bad3bb798b3bdc01c2a7bbb2df04a2b261bb" translate="yes" xml:space="preserve">
          <source>List (array reference) of feature parameters (if there are any), used also to toggle (enable or disable) given feature.</source>
          <target state="translated">特性参数列表(数组引用)(如果有的话),也用于切换(启用或禁用)指定的特性。</target>
        </trans-unit>
        <trans-unit id="7ee03188f58cdb7509c4f88e1a300f564da6d9fa" translate="yes" xml:space="preserve">
          <source>List all attributes that are associated with the specified paths. If this option is used, then &lt;code&gt;unspecified&lt;/code&gt; attributes will not be included in the output.</source>
          <target state="translated">列出与指定路径关联的所有属性。如果使用此选项，则 &lt;code&gt;unspecified&lt;/code&gt; 属性将不包括在输出中。</target>
        </trans-unit>
        <trans-unit id="250839942391006b259bdb87bdef885727a6f6a9" translate="yes" xml:space="preserve">
          <source>List all available configuration variables. This is a short summary of the list in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">列出所有可用的配置变量。这是&lt;a href=&quot;git-config&quot;&gt;git-config [1]中&lt;/a&gt;列表的简短摘要。</target>
        </trans-unit>
        <trans-unit id="12ac07106316dd6381b9d3b75b7cd7d028c9fa93" translate="yes" xml:space="preserve">
          <source>List all commits reachable from all refs</source>
          <target state="translated">列出所有参考文献中可达到的所有提交内容。</target>
        </trans-unit>
        <trans-unit id="dca598d76b2fd502e68ee09810f65324e1da32ae" translate="yes" xml:space="preserve">
          <source>List all tags (lightweight and annotated) in given repository.</source>
          <target state="translated">列出给定资源库中的所有标签(轻量级的和有注释的)。</target>
        </trans-unit>
        <trans-unit id="df1447e22cac81b01f2aee49d9517212423de9a9" translate="yes" xml:space="preserve">
          <source>List all variables set in config file, along with their values.</source>
          <target state="translated">列出在配置文件中设置的所有变量,以及它们的值。</target>
        </trans-unit>
        <trans-unit id="aa1b92c795a51cb41c1ee54087151d51eda95116" translate="yes" xml:space="preserve">
          <source>List both remote-tracking branches and local branches. Combine with &lt;code&gt;--list&lt;/code&gt; to match optional pattern(s).</source>
          <target state="translated">列出远程跟踪分支和本地分支。与 &lt;code&gt;--list&lt;/code&gt; 结合使用以匹配可选模式。</target>
        </trans-unit>
        <trans-unit id="670ea777adabe92ea2a21ddec9e8062878d9ce68" translate="yes" xml:space="preserve">
          <source>List branches. With optional &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt;, e.g. &lt;code&gt;git
branch --list 'maint-*'&lt;/code&gt;, list only the branches that match the pattern(s).</source>
          <target state="translated">列出分支。使用可选的 &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt; （例如 &lt;code&gt;git branch --list 'maint-*'&lt;/code&gt; ，仅列出与该模式匹配的分支。</target>
        </trans-unit>
        <trans-unit id="ecd6ee4f3b1cdf8c4e62426b401b6921926e6641" translate="yes" xml:space="preserve">
          <source>List commands by group. This is an internal/experimental option and may change or be removed in the future. Supported groups are: builtins, parseopt (builtin commands that use parse-options), main (all commands in libexec directory), others (all other commands in &lt;code&gt;$PATH&lt;/code&gt; that have git- prefix), list-&amp;lt;category&amp;gt; (see categories in command-list.txt), nohelpers (exclude helper commands), alias and config (retrieve command list from config variable completion.commands)</source>
          <target state="translated">按组列出命令。这是内部/实验选项，将来可能会更改或删除。支持的组为：内置，parseopt（使用parse-options的内置命令），main（libexec目录中的所有命令），其他（ &lt;code&gt;$PATH&lt;/code&gt; 中所有具有git-前缀的其他命令），list- &amp;lt;category&amp;gt;（请参见command-list.txt），nohelpers（不包括helper命令），别名和config（从config变量complete.commands中检索命令列表）</target>
        </trans-unit>
        <trans-unit id="238ed7681a7fd585fe1d585aba4d3e4521202ffa" translate="yes" xml:space="preserve">
          <source>List commits that are reachable by following the &lt;code&gt;parent&lt;/code&gt; links from the given commit(s), but exclude commits that are reachable from the one(s) given with a &lt;code&gt;^&lt;/code&gt; in front of them. The output is given in reverse chronological order by default.</source>
          <target state="translated">列出可通过遵循给定提交中的 &lt;code&gt;parent&lt;/code&gt; 链接到达的提交，但排除可从前面带有 &lt;code&gt;^&lt;/code&gt; 的给定提交中实现的提交。默认情况下，输出以相反的时间顺序给出。</target>
        </trans-unit>
        <trans-unit id="4360f3a3310a6afc913d6c5b075b5763b91121d3" translate="yes" xml:space="preserve">
          <source>List details of each working tree. The main working tree is listed first, followed by each of the linked working trees. The output details include whether the working tree is bare, the revision currently checked out, and the branch currently checked out (or &quot;detached HEAD&quot; if none).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8cd82f860b84646c498bf5c68b11bdf176a80b7" translate="yes" xml:space="preserve">
          <source>List details of each working tree. The main working tree is listed first, followed by each of the linked working trees. The output details include whether the working tree is bare, the revision currently checked out, the branch currently checked out (or &quot;detached HEAD&quot; if none), and &quot;locked&quot; if the worktree is locked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfacb775267bd93896cdbdf525c103ac26c16d4" translate="yes" xml:space="preserve">
          <source>List details of each worktree. The main worktree is listed first, followed by each of the linked worktrees. The output details include if the worktree is bare, the revision currently checked out, and the branch currently checked out (or &lt;code&gt;detached HEAD&lt;/code&gt; if none).</source>
          <target state="translated">列出每个工作树的详细信息。首先列出主工作树，然后是每个链接的工作树。输出详细信息包括工作树是否裸露，当前检出的修订版以及当前检出的分支（如果没有，则为 &lt;code&gt;detached HEAD&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1481dab663abae987b5437270fc0152b6258984f" translate="yes" xml:space="preserve">
          <source>List of Git base URLs. These URLs are used to generate URLs describing from where to fetch a project, which are shown on project summary page. The full fetch URL is &quot;&lt;code&gt;$git_base_url/$project&lt;/code&gt;&quot;, for each element of this list. You can set up multiple base URLs (for example one for &lt;code&gt;git://&lt;/code&gt; protocol, and one for &lt;code&gt;http://&lt;/code&gt; protocol).</source>
          <target state="translated">Git基本URL列表。这些URL用于生成描述从何处获取项目的URL，这些URL显示在项目摘要页面上。对于此列表的每个元素，完整的提取URL为&amp;ldquo; &lt;code&gt;$git_base_url/$project&lt;/code&gt; &amp;rdquo;。您可以设置多个基本URL（例如，一个用于 &lt;code&gt;git://&lt;/code&gt; 协议，一个用于 &lt;code&gt;http://&lt;/code&gt; 协议）。</target>
        </trans-unit>
        <trans-unit id="e9453e698a4a15232ec2c038afd4c298aede850c" translate="yes" xml:space="preserve">
          <source>List of URIs of stylesheets (relative to the base URI of a page). You might specify more than one stylesheet, for example to use &quot;gitweb.css&quot; as base with site specific modifications in a separate stylesheet to make it easier to upgrade gitweb. For example, you can add a &lt;code&gt;site&lt;/code&gt; stylesheet by putting</source>
          <target state="translated">样式表的URI列表（相对于页面的基本URI）。您可以指定多个样式表，例如以&amp;ldquo; gitweb.css&amp;rdquo;为基础，并在单独的样式表中进行特定于站点的修改，以使升级gitweb更加容易。例如，您可以通过以下方式添加 &lt;code&gt;site&lt;/code&gt; 样式表：</target>
        </trans-unit>
        <trans-unit id="d9ab3387c39e123d7aac2edb253dcdba7080f753" translate="yes" xml:space="preserve">
          <source>List of additional directories under &quot;refs&quot; which are going to be used as branch refs. For example if you have a gerrit setup where all branches under refs/heads/ are official, push-after-review ones and branches under refs/sandbox/, refs/wip and refs/other are user ones where permissions are much wider, then you might want to set this variable as follows:</source>
          <target state="translated">refs &quot;下的附加目录列表,这些目录将被用作分支 refs。例如,如果你有一个 gerrit 设置,其中 refs/heads/下的所有分支都是官方的,push-a-review 的,而 refs/sandbox/、refs/wip 和 refs/other 下的分支则是权限更宽的用户分支,那么你可能会想把这个变量设置成如下。</target>
        </trans-unit>
        <trans-unit id="c919f43c88ec5761218ece7f29ac150fc5c1298f" translate="yes" xml:space="preserve">
          <source>List of branches to be imported when branch detection is enabled. Each entry should be a pair of branch names separated by a colon (:). This example declares that both branchA and branchB were created from main:</source>
          <target state="translated">启用分支检测时要导入的分支列表。每个条目应该是一对分支名称,用冒号(:)分隔。这个例子声明分支A和分支B都是从main创建的。</target>
        </trans-unit>
        <trans-unit id="3d6057539fc43b4e5580b21aa940b705e61341be" translate="yes" xml:space="preserve">
          <source>List of p4 labels to ignore. This is built automatically as unimportable labels are discovered.</source>
          <target state="translated">要忽略的p4标签列表。这是在发现不重要的标签时自动建立的。</target>
        </trans-unit>
        <trans-unit id="ed979d0137e2b09484f09056901ac3efce874117" translate="yes" xml:space="preserve">
          <source>List only commits on the respective side of a symmetric difference, i.e. only those which would be marked &lt;code&gt;&amp;lt;&lt;/code&gt; resp. &lt;code&gt;&amp;gt;&lt;/code&gt; by &lt;code&gt;--left-right&lt;/code&gt;.</source>
          <target state="translated">列表仅在对称差异的相应一侧提交，即仅那些将被标记为 &lt;code&gt;&amp;lt;&lt;/code&gt; 分别。 &lt;code&gt;&amp;gt;&lt;/code&gt; 通过 &lt;code&gt;--left-right&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db38d2130aa4774e0a5e01e813cbe87b286b5c58" translate="yes" xml:space="preserve">
          <source>List only filenames (instead of the &quot;long&quot; output), one per line.</source>
          <target state="translated">只列出文件名(而不是 &quot;长 &quot;输出),每行一个。</target>
        </trans-unit>
        <trans-unit id="ca0ba00456e1892ce61ce3c77aa65cb5194d4e6c" translate="yes" xml:space="preserve">
          <source>List or delete (if used with -d) the remote-tracking branches. Combine with &lt;code&gt;--list&lt;/code&gt; to match the optional pattern(s).</source>
          <target state="translated">列出或删除（如果与-d一起使用）远程跟踪分支。与 &lt;code&gt;--list&lt;/code&gt; 结合使用，以匹配可选模式。</target>
        </trans-unit>
        <trans-unit id="22eb51b821276ed4742fd46da8d914f3eb506ca1" translate="yes" xml:space="preserve">
          <source>List output format</source>
          <target state="translated">列表输出格式</target>
        </trans-unit>
        <trans-unit id="961866b18d2006e9e2f1c57af615530c0dcb0176" translate="yes" xml:space="preserve">
          <source>List references in a local repository</source>
          <target state="translated">在本地存储库中列出引用</target>
        </trans-unit>
        <trans-unit id="7a309b311eeb5429dbbc4c270383e0c9240ea7dd" translate="yes" xml:space="preserve">
          <source>List references in a remote repository</source>
          <target state="translated">列出远程存储库中的引用</target>
        </trans-unit>
        <trans-unit id="c3c4b04779710ca49a121ec3b626bb207fe0cc86" translate="yes" xml:space="preserve">
          <source>List replace refs for objects that match the given pattern (or all if no pattern is given). Typing &quot;git replace&quot; without arguments, also lists all replace refs.</source>
          <target state="translated">列出与给定模式相匹配的对象的替换引用(如果没有给定模式,则列出全部)。输入 &quot;git replace &quot;时,如果没有参数,也会列出所有的替换参考。</target>
        </trans-unit>
        <trans-unit id="dd864736379915e26071e39557a37c9a699c5cd9" translate="yes" xml:space="preserve">
          <source>List some tags in a table with unequal column widths:</source>
          <target state="translated">在表中列出一些列宽不等的标签。</target>
        </trans-unit>
        <trans-unit id="c3a7e0023c585da8fc00add926f4e7fe3e4bed2d" translate="yes" xml:space="preserve">
          <source>List tags. With optional &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt;, e.g. &lt;code&gt;git tag --list
'v-*'&lt;/code&gt;, list only the tags that match the pattern(s).</source>
          <target state="translated">列出标签。使用可选的 &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt; ，例如 &lt;code&gt;git tag --list 'v-*'&lt;/code&gt; ，仅列出与模式匹配的标签。</target>
        </trans-unit>
        <trans-unit id="42f93b25d56793afc3463e924a37b81b3e45f73d" translate="yes" xml:space="preserve">
          <source>List the GIT_* environment variables that are local to the repository (e.g. GIT_DIR or GIT_WORK_TREE, but not GIT_EDITOR). Only the names of the variables are listed, not their value, even if they are set.</source>
          <target state="translated">列出版本库的 GIT_*环境变量 (例如 GIT_DIR 或 GIT_WORK_TREE,但不是 GIT_EDITOR)。只有变量的名字会被列出,而不是它们的值,即使它们被设置了。</target>
        </trans-unit>
        <trans-unit id="dc410162c15e0c2fc959648b2d515436ff66231c" translate="yes" xml:space="preserve">
          <source>List the contents of a tree object</source>
          <target state="translated">列出树对象的内容</target>
        </trans-unit>
        <trans-unit id="c77a61ab930b102983b7633429f2e1c89c8a648a" translate="yes" xml:space="preserve">
          <source>List the notes object for a given object. If no object is given, show a list of all note objects and the objects they annotate (in the format &quot;&amp;lt;note object&amp;gt; &amp;lt;annotated object&amp;gt;&quot;). This is the default subcommand if no subcommand is given.</source>
          <target state="translated">列出给定对象的注释对象。如果没有给出对象，则显示所有注释对象及其注释对象的列表（格式为&amp;ldquo; &amp;lt;注释对象&amp;gt; &amp;lt;注释对象&amp;gt;&amp;rdquo;）。如果未给出任何子命令，则这是默认子命令。</target>
        </trans-unit>
        <trans-unit id="160440cac4234691b237108179766c8ac388a3dd" translate="yes" xml:space="preserve">
          <source>List the stash entries that you currently have. Each &lt;code&gt;stash entry&lt;/code&gt; is listed with its name (e.g. &lt;code&gt;stash@{0}&lt;/code&gt; is the latest entry, &lt;code&gt;stash@{1}&lt;/code&gt; is the one before, etc.), the name of the branch that was current when the entry was made, and a short description of the commit the entry was based on.</source>
          <target state="translated">列出您当前拥有的存储项。每个 &lt;code&gt;stash entry&lt;/code&gt; 均以其名称列出（例如 &lt;code&gt;stash@{0}&lt;/code&gt; 是最新条目， &lt;code&gt;stash@{1}&lt;/code&gt; 是之前的条目，依此类推），创建条目时当前分支的名称以及一个条目所基于的提交的简短描述。</target>
        </trans-unit>
        <trans-unit id="0928a18c981cee8dd1bbd962ad11b79b09b49f73" translate="yes" xml:space="preserve">
          <source>List, create, or delete branches</source>
          <target state="translated">列出、创建或删除分支</target>
        </trans-unit>
        <trans-unit id="7d888e358c6ef40ec2a0a8a674979b45cd6d1cf4" translate="yes" xml:space="preserve">
          <source>Listed below are options that control the formatting of diff output. Some of them are specific to &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;, however other diff options may be given. See &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt; for more options.</source>
          <target state="translated">下面列出了控制diff输出格式的选项。其中一些特定于&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;，但是可以提供其他diff选项。有关更多选项，请参见&lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3248fa00aea630b8bbaf0b4709f9f26882639bdc" translate="yes" xml:space="preserve">
          <source>Listen on a specific IP address or hostname. IP addresses can be either an IPv4 address or an IPv6 address if supported. If IPv6 is not supported, then --listen=hostname is also not supported and --listen must be given an IPv4 address. Can be given more than once. Incompatible with &lt;code&gt;--inetd&lt;/code&gt; option.</source>
          <target state="translated">侦听特定的IP地址或主机名。 IP地址可以是IPv4地址或IPv6地址（如果支持）。如果不支持IPv6，则--listen = hostname也不受支持，并且必须为--listen提供IPv4地址。可以多次给予。与 &lt;code&gt;--inetd&lt;/code&gt; 选项不兼容。</target>
        </trans-unit>
        <trans-unit id="4f53ff7586b49256325ec58801bfe143f18e21e3" translate="yes" xml:space="preserve">
          <source>Listen on an alternative port. Incompatible with &lt;code&gt;--inetd&lt;/code&gt; option.</source>
          <target state="translated">在其他端口上监听。与 &lt;code&gt;--inetd&lt;/code&gt; 选项不兼容。</target>
        </trans-unit>
        <trans-unit id="3e35805a9773260286dfbc09d02caaf5994dc0ce" translate="yes" xml:space="preserve">
          <source>Listing a single attribute:</source>
          <target state="translated">列出单一属性。</target>
        </trans-unit>
        <trans-unit id="69751d90f1fec1736a7673316bf3b759c5271c7d" translate="yes" xml:space="preserve">
          <source>Listing all attributes for a file:</source>
          <target state="translated">列出一个文件的所有属性。</target>
        </trans-unit>
        <trans-unit id="e231fe1cc3d8844bfddb76169e22179c8767ce9e" translate="yes" xml:space="preserve">
          <source>Listing an attribute for multiple files:</source>
          <target state="translated">列出多个文件的属性。</target>
        </trans-unit>
        <trans-unit id="d1d9eec0e1bd38bd76cb67feb04b08b5d78c11bd" translate="yes" xml:space="preserve">
          <source>Listing branches from a specific remote</source>
          <target state="translated">列出来自特定远程的分支</target>
        </trans-unit>
        <trans-unit id="14162152c45d26fb9527c9f0660bef886294e5bf" translate="yes" xml:space="preserve">
          <source>Listing multiple attributes for a file:</source>
          <target state="translated">列出一个文件的多个属性。</target>
        </trans-unit>
        <trans-unit id="540f872616da666be00fd2f7f78a7ae984c11b9a" translate="yes" xml:space="preserve">
          <source>Lists all local or all remote-tracking branches in given repository.</source>
          <target state="translated">列出指定仓库中的所有本地或远程跟踪分支。</target>
        </trans-unit>
        <trans-unit id="b5500d120a9a13cb3af42448653e0cde10752de4" translate="yes" xml:space="preserve">
          <source>Lists commit objects in reverse chronological order</source>
          <target state="translated">按时间倒序列出提交对象。</target>
        </trans-unit>
        <trans-unit id="6385084e9b2c3e78376900259ba28376e3a28618" translate="yes" xml:space="preserve">
          <source>Lists the available Git repositories. This is the default command if no repository is specified in the URL.</source>
          <target state="translated">列出可用的 Git 仓库。如果在URL中没有指定仓库,这是默认命令。</target>
        </trans-unit>
        <trans-unit id="9438685d87876d6c82356bf9b864c1c6136c1266" translate="yes" xml:space="preserve">
          <source>Lists the capabilities of the helper, one per line, ending with a blank line. Each capability may be preceded with &lt;code&gt;*&lt;/code&gt;, which marks them mandatory for Git versions using the remote helper to understand. Any unknown mandatory capability is a fatal error.</source>
          <target state="translated">列出助手的功能，每行一个，以空行结尾。每个功能可能都带有 &lt;code&gt;*&lt;/code&gt; ，这表示使用远程帮助程序了解的Git版本必须使用它们。任何未知的强制性功能都是致命错误。</target>
        </trans-unit>
        <trans-unit id="8c594a1bf48edecf6065890a7f89cc7fa404495f" translate="yes" xml:space="preserve">
          <source>Lists the contents of a given tree object, like what &quot;/bin/ls -a&quot; does in the current working directory. Note that:</source>
          <target state="translated">列出一个给定树对象的内容,就像&quot;/bin/ls -a &quot;在当前工作目录下所做的那样。注意:</target>
        </trans-unit>
        <trans-unit id="9cc5eb61d77cd46774cb42ac22301b7d413d58c5" translate="yes" xml:space="preserve">
          <source>Lists the properties stored in the Subversion repository about a given file or directory. Use -r/--revision to refer to a specific Subversion revision.</source>
          <target state="translated">列出存储在Subversion版本库中的关于给定文件或目录的属性,使用-r/--revision来引用特定的Subversion版本。使用 -r/--revision 来引用一个特定的 Subversion 版本。</target>
        </trans-unit>
        <trans-unit id="11c5aa2ca7f7c3e091142bb69f047bf1ca338d7f" translate="yes" xml:space="preserve">
          <source>Lists the references defined in the bundle. If followed by a list of references, only references matching those given are printed out.</source>
          <target state="translated">列出 bundle 中定义的引用。如果后面跟着一个引用列表,则只打印出与给定引用相匹配的引用。</target>
        </trans-unit>
        <trans-unit id="ce5afcadd9730c2206b4e08d09ffc836dddfab54" translate="yes" xml:space="preserve">
          <source>Lists the refs, one per line, in the format &quot;&amp;lt;value&amp;gt; &amp;lt;name&amp;gt; [&amp;lt;attr&amp;gt; &amp;hellip;​]&quot;. The value may be a hex sha1 hash, &quot;@&amp;lt;dest&amp;gt;&quot; for a symref, &quot;:&amp;lt;keyword&amp;gt; &amp;lt;value&amp;gt;&quot; for a key-value pair, or &quot;?&quot; to indicate that the helper could not get the value of the ref. A space-separated list of attributes follows the name; unrecognized attributes are ignored. The list ends with a blank line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb27642bee7df675e576f1467eabd36ebf236a0c" translate="yes" xml:space="preserve">
          <source>Lists the refs, one per line, in the format &quot;&amp;lt;value&amp;gt; &amp;lt;name&amp;gt; [&amp;lt;attr&amp;gt; &amp;hellip;​]&quot;. The value may be a hex sha1 hash, &quot;@&amp;lt;dest&amp;gt;&quot; for a symref, or &quot;?&quot; to indicate that the helper could not get the value of the ref. A space-separated list of attributes follows the name; unrecognized attributes are ignored. The list ends with a blank line.</source>
          <target state="translated">以&amp;ldquo; &amp;lt;值&amp;gt; &amp;lt;名称&amp;gt; [&amp;lt;attr&amp;gt;&amp;hellip;]]的格式列出参考，每行一个。该值可以是十六进制的sha1哈希，对于symref来说是&amp;ldquo; @ &amp;lt;dest&amp;gt;&amp;rdquo;，或者是&amp;ldquo;？&amp;rdquo;。表示帮助程序无法获取引用的值。名称后用空格分隔的属性列表。无法识别的属性将被忽略。该列表以空行结尾。</target>
        </trans-unit>
        <trans-unit id="8cf165480241df10f979b6b7157595e5407c755f" translate="yes" xml:space="preserve">
          <source>Literal percent sign.</source>
          <target state="translated">字面的百分号。</target>
        </trans-unit>
        <trans-unit id="c9b025ce8a30fb92786ef26cc44501e09df585de" translate="yes" xml:space="preserve">
          <source>Literal space in command or argument.</source>
          <target state="translated">命令或参数中的字面空格。</target>
        </trans-unit>
        <trans-unit id="3e47004eca06847317d03882ea01098236feca24" translate="yes" xml:space="preserve">
          <source>Loads annotations as described above and automatically scrolls the view to center on line &lt;code&gt;100&lt;/code&gt;.</source>
          <target state="translated">如上所述加载注释，并自动将视图滚动到第 &lt;code&gt;100&lt;/code&gt; 行的中心。</target>
        </trans-unit>
        <trans-unit id="f638d2718f9a7fa3228a4c22ea27ab0cb7ce0ed8" translate="yes" xml:space="preserve">
          <source>Local directory</source>
          <target state="translated">本地名录</target>
        </trans-unit>
        <trans-unit id="83cd95e5e26d810cf34fa10fd02190221225a995" translate="yes" xml:space="preserve">
          <source>Locate a good region of the object graph in a damaged repository</source>
          <target state="translated">在损坏的存储库中找到对象图的良好区域。</target>
        </trans-unit>
        <trans-unit id="c6b89ef8cfe5b4e0d5f71a9018f7c23272508e1d" translate="yes" xml:space="preserve">
          <source>Location of repositories</source>
          <target state="translated">储存库的位置</target>
        </trans-unit>
        <trans-unit id="a8464429b3dd8a54d4c3a8d0aaf7809c3b93d077" translate="yes" xml:space="preserve">
          <source>Locations of Marks Files</source>
          <target state="translated">马克思档案的位置</target>
        </trans-unit>
        <trans-unit id="747742f75a08750185466d70d49a66f609262970" translate="yes" xml:space="preserve">
          <source>Locations of the common system-wide configuration file, the fallback system-wide configuration file and the per-instance configuration file are defined at compile time using build-time Makefile configuration variables, respectively &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt;, &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; and &lt;code&gt;GITWEB_CONFIG&lt;/code&gt;.</source>
          <target state="translated">在编译时，分别使用构建时Makefile配置变量 &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt; ， &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; 和 &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; 来定义公共系统范围配置文件，后备系统范围配置文件和按实例配置文件的位置。</target>
        </trans-unit>
        <trans-unit id="ff8e7c6671e74ff8d9e440b7a275b6b3047a92bf" translate="yes" xml:space="preserve">
          <source>Log details about the incoming connections and requested files.</source>
          <target state="translated">记录有关传入连接和请求文件的详细信息。</target>
        </trans-unit>
        <trans-unit id="c1bbca864796e717c6563546ee8bb0273fbae9ac" translate="yes" xml:space="preserve">
          <source>Logging updates</source>
          <target state="translated">更新记录</target>
        </trans-unit>
        <trans-unit id="e76f4d6fb1700b21a7cf7fc7a62d7a34c7014ae2" translate="yes" xml:space="preserve">
          <source>Long Running Filter Process</source>
          <target state="translated">长期运行的过滤过程</target>
        </trans-unit>
        <trans-unit id="555712d9829e6328a9b7d5ec70facbda745fb9b3" translate="yes" xml:space="preserve">
          <source>Look at the diffs from each branch. &lt;code&gt;git log --merge -p &amp;lt;path&amp;gt;&lt;/code&gt; will show diffs first for the &lt;code&gt;HEAD&lt;/code&gt; version and then the &lt;code&gt;MERGE_HEAD&lt;/code&gt; version.</source>
          <target state="translated">查看每个分支的差异。 &lt;code&gt;git log --merge -p &amp;lt;path&amp;gt;&lt;/code&gt; 将首先显示 &lt;code&gt;HEAD&lt;/code&gt; 版本的差异，然后显示 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="a326ab540e0d9536d53dbc94d57cb0c25e24d9a1" translate="yes" xml:space="preserve">
          <source>Look at the diffs. &lt;code&gt;git diff&lt;/code&gt; will show a three-way diff, highlighting changes from both the &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;MERGE_HEAD&lt;/code&gt; versions.</source>
          <target state="translated">看差异。 &lt;code&gt;git diff&lt;/code&gt; 将显示三向差异，突出显示 &lt;code&gt;HEAD&lt;/code&gt; 和 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 版本的更改。</target>
        </trans-unit>
        <trans-unit id="f8c63749f2ae2fa24fa7ef48c360ef59f66a1f48" translate="yes" xml:space="preserve">
          <source>Look at the originals. &lt;code&gt;git show :1:filename&lt;/code&gt; shows the common ancestor, &lt;code&gt;git show :2:filename&lt;/code&gt; shows the &lt;code&gt;HEAD&lt;/code&gt; version, and &lt;code&gt;git show :3:filename&lt;/code&gt; shows the &lt;code&gt;MERGE_HEAD&lt;/code&gt; version.</source>
          <target state="translated">看看原件。 &lt;code&gt;git show :1:filename&lt;/code&gt; 显示公共祖先， &lt;code&gt;git show :2:filename&lt;/code&gt; 显示 &lt;code&gt;HEAD&lt;/code&gt; 版本，而 &lt;code&gt;git show :3:filename&lt;/code&gt; 显示 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="6a423d84e076a3272fdc685127299ea63ea761ac" translate="yes" xml:space="preserve">
          <source>Look for a fix instead of a regression in the code</source>
          <target state="translated">在代码中寻找修复而不是回归。</target>
        </trans-unit>
        <trans-unit id="4ab23275475ac09a44d78ac861e7af3c95082023" translate="yes" xml:space="preserve">
          <source>Look for attributes in .gitattributes files in the working tree as well (see &lt;a href=&quot;#ATTRIBUTES&quot;&gt;ATTRIBUTES&lt;/a&gt;).</source>
          <target state="translated">在工作树的.gitattributes文件中也查找属性（请参阅&lt;a href=&quot;#ATTRIBUTES&quot;&gt;ATTRIBUTES&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5e41023ffb67a9b868c13a5cdc624ea0d794092d" translate="yes" xml:space="preserve">
          <source>Look for differences that change the number of occurrences of the specified object. Similar to &lt;code&gt;-S&lt;/code&gt;, just the argument is different in that it doesn&amp;rsquo;t search for a specific string but for a specific object id.</source>
          <target state="translated">寻找差异来改变指定对象的出现次数。与 &lt;code&gt;-S&lt;/code&gt; 相似，只是参数有所不同，因为它不搜索特定的字符串而是特定的对象id。</target>
        </trans-unit>
        <trans-unit id="a838d092d782360d96378f1e4ff8a0b5fffd060f" translate="yes" xml:space="preserve">
          <source>Look for differences that change the number of occurrences of the specified string (i.e. addition/deletion) in a file. Intended for the scripter&amp;rsquo;s use.</source>
          <target state="translated">寻找差异来改变文件中指定字符串出现的次数（即加/删除）。供脚本编写者使用。</target>
        </trans-unit>
        <trans-unit id="b8df136f2384d637ef409fc2baddd2b9dce73992" translate="yes" xml:space="preserve">
          <source>Look for differences whose patch text contains added/removed lines that match &amp;lt;regex&amp;gt;.</source>
          <target state="translated">查找其补丁文本包含与&amp;lt;regex&amp;gt;匹配的已添加/已删除行的差异。</target>
        </trans-unit>
        <trans-unit id="4cef9adbc5be0f5f01b5c2739071b69091cb4a32" translate="yes" xml:space="preserve">
          <source>Look for specified patterns in the tracked files in the work tree, blobs registered in the index file, or blobs in given tree objects. Patterns are lists of one or more search expressions separated by newline characters. An empty string as search expression matches all lines.</source>
          <target state="translated">在工作树中的跟踪文件、索引文件中注册的 blobs 或给定树对象中的 blobs 中查找指定的模式。模式是由一个或多个搜索表达式组成的列表,用换行符分隔。作为搜索表达式的空字符串会匹配所有行。</target>
        </trans-unit>
        <trans-unit id="07448c29252081320f670b2265de0e9cba50a292" translate="yes" xml:space="preserve">
          <source>Look up layout mode using configuration variable column.&amp;lt;name&amp;gt; and column.ui.</source>
          <target state="translated">使用配置变量column。&amp;lt;name&amp;gt;和column.ui查找布局模式。</target>
        </trans-unit>
        <trans-unit id="b62eefc27e1aeffa75b2d4761547bc2b8bc497bd" translate="yes" xml:space="preserve">
          <source>Looks at the current index and checks to see if merges or updates are needed by checking stat() information.</source>
          <target state="translated">查看当前索引,并通过检查stat()信息,检查是否需要合并或更新。</target>
        </trans-unit>
        <trans-unit id="4b7876b6a8ad520457ce71bfe745148e3c567edb" translate="yes" xml:space="preserve">
          <source>Looks for &lt;code&gt;solution&lt;/code&gt;, excluding files in &lt;code&gt;Documentation&lt;/code&gt;.</source>
          <target state="translated">寻找 &lt;code&gt;solution&lt;/code&gt; ，但不包括&amp;ldquo;文档&amp;rdquo;中的 &lt;code&gt;Documentation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f3233017974f60253fdf12d744b51a535433787" translate="yes" xml:space="preserve">
          <source>Looks for &lt;code&gt;time_t&lt;/code&gt; in all tracked .c and .h files in the working directory and its subdirectories.</source>
          <target state="translated">在工作目录及其子目录中的所有跟踪的.c和.h文件中查找 &lt;code&gt;time_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="558837c842e106c2ed3e4e9a131c3a7442c122b9" translate="yes" xml:space="preserve">
          <source>Looks for a line that has &lt;code&gt;#define&lt;/code&gt; and either &lt;code&gt;MAX_PATH&lt;/code&gt; or &lt;code&gt;PATH_MAX&lt;/code&gt;.</source>
          <target state="translated">查找具有 &lt;code&gt;#define&lt;/code&gt; 且 &lt;code&gt;MAX_PATH&lt;/code&gt; 或 &lt;code&gt;PATH_MAX&lt;/code&gt; 的行。</target>
        </trans-unit>
        <trans-unit id="432adcaf916374b14ccc5f4491d7cd8a1e3d3e44" translate="yes" xml:space="preserve">
          <source>Looks for a line that has &lt;code&gt;NODE&lt;/code&gt; or &lt;code&gt;Unexpected&lt;/code&gt; in files that have lines that match both.</source>
          <target state="translated">在具有匹配的行的文件中查找具有 &lt;code&gt;NODE&lt;/code&gt; 或 &lt;code&gt;Unexpected&lt;/code&gt; 的行。</target>
        </trans-unit>
        <trans-unit id="b11d66d44e8db145700e0edb6375620b652f740a" translate="yes" xml:space="preserve">
          <source>Low-level commands (plumbing)</source>
          <target state="translated">低级指令(管道)</target>
        </trans-unit>
        <trans-unit id="0ffc3dae4e51a700bf1ca804b93845e0102810f8" translate="yes" xml:space="preserve">
          <source>Low-level git operations</source>
          <target state="translated">低级别的git操作</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="5d487fc78e43a0306fd5f718aec828744ee6e786" translate="yes" xml:space="preserve">
          <source>M: modification of the contents or mode of a file</source>
          <target state="translated">M:修改文件的内容或模式。</target>
        </trans-unit>
        <trans-unit id="0f48f030cf13414eeafe91359c3c62bf97314f35" translate="yes" xml:space="preserve">
          <source>Magic Options</source>
          <target state="translated">魔法选项</target>
        </trans-unit>
        <trans-unit id="7d828d176880cf3ec5ec8010d93f54010eebda7b" translate="yes" xml:space="preserve">
          <source>Maildir splitting relies upon filenames being sorted to output patches in the correct order.</source>
          <target state="translated">Maildir拆分依赖于文件名的排序,以正确的顺序输出补丁。</target>
        </trans-unit>
        <trans-unit id="57a6217babf3a984d54a72505b0f2a4f3e1be542" translate="yes" xml:space="preserve">
          <source>Main porcelain commands</source>
          <target state="translated">主要瓷器指令</target>
        </trans-unit>
        <trans-unit id="46b62a0f964fab2f018eee342e7b4db44adbc685" translate="yes" xml:space="preserve">
          <source>Maintaining topic branches for a Linux subsystem maintainer</source>
          <target state="translated">为一个Linux子系统维护者维护主题分支。</target>
        </trans-unit>
        <trans-unit id="52f0f393e457cb924c234a7254a4daec3a0cbf32" translate="yes" xml:space="preserve">
          <source>Maintenance branch management after a feature release</source>
          <target state="translated">功能发布后的维护分支管理</target>
        </trans-unit>
        <trans-unit id="319909b05c9210e6ff8b8a19f69dc9189ee2cca4" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git gc --auto&lt;/code&gt; return immediately and run in background if the system supports it. Default is true.</source>
          <target state="translated">使 &lt;code&gt;git gc --auto&lt;/code&gt; 立即返回并在系统支持的情况下在后台运行。默认为true。</target>
        </trans-unit>
        <trans-unit id="77c42361d50b9bdea29b692160b9eae95cceb52e" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git show-ref&lt;/code&gt; act as a filter that reads refs from stdin of the form &quot;&lt;code&gt;^(?:&amp;lt;anything&amp;gt;\s)?&amp;lt;refname&amp;gt;(?:\^{})?$&lt;/code&gt;&quot; and performs the following actions on each: (1) strip &quot;^{}&quot; at the end of line if any; (2) ignore if pattern is provided and does not head-match refname; (3) warn if refname is not a well-formed refname and skip; (4) ignore if refname is a ref that exists in the local repository; (5) otherwise output the line.</source>
          <target state="translated">使 &lt;code&gt;git show-ref&lt;/code&gt; 充当过滤器，该过滤器从形式为&amp;ldquo; &lt;code&gt;^(?:&amp;lt;anything&amp;gt;\s)?&amp;lt;refname&amp;gt;(?:\^{})?$&lt;/code&gt; &amp;rdquo;的stdin中读取引用，并对每个引用执行以下操作：（1）如果有，请在行尾删除&amp;ldquo; ^ {}&amp;rdquo;；（2）忽略是否提供了模式，并且不与refname头匹配；（3）警告如果refname不是格式正确的refname并跳过；（4）忽略refname是否是本地存储库中存在的ref；（5）否则输出线。</target>
        </trans-unit>
        <trans-unit id="51befbcaeb5eba297db1a634b8802a7f0078cead" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git svn&lt;/code&gt; less verbose. Specify a second time to make it even less verbose.</source>
          <target state="translated">使 &lt;code&gt;git svn&lt;/code&gt; 不再那么冗长。指定第二次以使其不再那么冗长。</target>
        </trans-unit>
        <trans-unit id="2da3bd3f8069e8e437af583aecc3a384c81edd34" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;bare&lt;/code&gt; Git repository. That is, instead of creating &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; and placing the administrative files in &lt;code&gt;&amp;lt;directory&amp;gt;/.git&lt;/code&gt;, make the &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; itself the &lt;code&gt;$GIT_DIR&lt;/code&gt;. This obviously implies the &lt;code&gt;--no-checkout&lt;/code&gt; because there is nowhere to check out the working tree. Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to &lt;code&gt;refs/remotes/origin/&lt;/code&gt;. When this option is used, neither remote-tracking branches nor the related configuration variables are created.</source>
          <target state="translated">制作一个 &lt;code&gt;bare&lt;/code&gt; Git存储库。也就是说，不要创建 &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; 并将管理文件放置在 &lt;code&gt;&amp;lt;directory&amp;gt;/.git&lt;/code&gt; &lt;code&gt;$GIT_DIR&lt;/code&gt; 将 &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; 本身设置为$ GIT_DIR。显然这意味着 &lt;code&gt;--no-checkout&lt;/code&gt; ,因为没有地方可以检出工作树。同样，将远程的分支头直接复制到相应的本地分支头，而无需将它们映射到 &lt;code&gt;refs/remotes/origin/&lt;/code&gt; 。使用此选项时，不会创建远程跟踪分支或相关的配置变量。</target>
        </trans-unit>
        <trans-unit id="6ca024f41825508ff37398849dd7bbbd184e78e6" translate="yes" xml:space="preserve">
          <source>Make a GPG-signed tag, using the default e-mail address&amp;rsquo;s key. The default behavior of tag GPG-signing is controlled by &lt;code&gt;tag.gpgSign&lt;/code&gt; configuration variable if it exists, or disabled otherwise. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">使用默认电子邮件地址的密钥制作一个GPG签名的标签。标签GPG签名的默认行为由 &lt;code&gt;tag.gpgSign&lt;/code&gt; 配置变量（如果存在）控制，否则被禁用。参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5a6f6bd2dfbdab5f143e86ea9155fad4e43a30c" translate="yes" xml:space="preserve">
          <source>Make a GPG-signed tag, using the given key.</source>
          <target state="translated">使用给定的密钥,制作一个GPG签名的标签。</target>
        </trans-unit>
        <trans-unit id="99f2296af5452e1eec1986dbc7a0151a5ba6b1fc" translate="yes" xml:space="preserve">
          <source>Make a commit by taking the updated working tree contents of the paths specified on the command line, disregarding any contents that have been staged for other paths. This is the default mode of operation of &lt;code&gt;git commit&lt;/code&gt; if any paths are given on the command line, in which case this option can be omitted. If this option is specified together with &lt;code&gt;--amend&lt;/code&gt;, then no paths need to be specified, which can be used to amend the last commit without committing changes that have already been staged. If used together with &lt;code&gt;--allow-empty&lt;/code&gt; paths are also not required, and an empty commit will be created.</source>
          <target state="translated">通过获取在命令行上指定的路径的更新的工作树内容来提交，而不考虑为其他路径暂存的任何内容。如果在命令行上给出了任何路径，这是 &lt;code&gt;git commit&lt;/code&gt; 的默认操作模式，在这种情况下可以省略此选项。如果将此选项与 &lt;code&gt;--amend&lt;/code&gt; 一起指定，则无需指定路径，该路径可用于修改上一次提交而无需提交已经进行的更改。如果与 &lt;code&gt;--allow-empty&lt;/code&gt; 路径一起使用，则也不需要，并且将创建一个空提交。</target>
        </trans-unit>
        <trans-unit id="2e9bf6a1a9ac175346438fe9d4c19601601a0ebd" translate="yes" xml:space="preserve">
          <source>Make a list of the commits which are about to be rebased. Let the user edit that list before rebasing. This mode can also be used to split commits (see SPLITTING COMMITS below).</source>
          <target state="translated">编制一个即将被重新归类的提交列表,让用户在重新归类前编辑该列表。让用户在重定基之前编辑该列表。这个模式也可以用来拆分提交的内容(见下文拆分提交内容)。</target>
        </trans-unit>
        <trans-unit id="f382849103310ffba0e3d31128dfababfd915957" translate="yes" xml:space="preserve">
          <source>Make a local clone that borrows from the current directory, without checking things out:</source>
          <target state="translated">做一个借用当前目录的本地克隆,而不检查东西。</target>
        </trans-unit>
        <trans-unit id="d7a3e91b3667d18f363db6d6cc32c0afec1ed1d5" translate="yes" xml:space="preserve">
          <source>Make a side branch for every topic (feature, bugfix, &amp;hellip;​). Fork it off at the oldest integration branch that you will eventually want to merge it into.</source>
          <target state="translated">为每个主题（功能，错误修正等）建立一个分支。将其分叉到最旧的集成分支，您最终将要合并到该分支。</target>
        </trans-unit>
        <trans-unit id="89db797c5d89c53349b8d88ec549bb720f48d1f7" translate="yes" xml:space="preserve">
          <source>Make an unsigned, annotated tag object</source>
          <target state="translated">制作一个无符号、有注释的标签对象。</target>
        </trans-unit>
        <trans-unit id="f88ecf2f4eb0c5509c792cd2c61ea44a524baf96" translate="yes" xml:space="preserve">
          <source>Make corrections to working tree files.</source>
          <target state="translated">对工作树文件进行修正。</target>
        </trans-unit>
        <trans-unit id="79ee7beb56d7493ce335c85dd0a8333674bff17b" translate="yes" xml:space="preserve">
          <source>Make git-send-email less verbose. One line per email should be all that is output.</source>
          <target state="translated">让 git-send-email 不那么啰嗦。每封邮件应该只输出一行。</target>
        </trans-unit>
        <trans-unit id="ff429cc18c1dac972928cb3da6e4d06bbfe2d8ec" translate="yes" xml:space="preserve">
          <source>Make one commit and return to the shell when it is complete. This command returns a non-zero exit code if the window was closed in any way other than by making a commit.</source>
          <target state="translated">进行一次提交,完成后返回shell。如果窗口是以提交以外的任何方式关闭的,该命令将返回一个非零的退出代码。</target>
        </trans-unit>
        <trans-unit id="31ca9c9bf3eab94aff99250728fe74f77977b844" translate="yes" xml:space="preserve">
          <source>Make sure Git knows who to blame:</source>
          <target state="translated">确保Git知道该怪谁。</target>
        </trans-unit>
        <trans-unit id="cf12b54cc8063982ae2c9b96588de4f236c9e743" translate="yes" xml:space="preserve">
          <source>Make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If the value is &lt;code&gt;check&lt;/code&gt; then Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing, the push will be aborted and exit with non-zero status. If the value is &lt;code&gt;on-demand&lt;/code&gt; then all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If the value is &lt;code&gt;no&lt;/code&gt; then default behavior of ignoring submodules when pushing is retained. You may override this configuration at time of push by specifying &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt;.</source>
          <target state="translated">确保要推送的修订所使用的所有子模块提交在远程跟踪分支上均可用。如果值为 &lt;code&gt;check&lt;/code&gt; ,则Git将验证至少要在子模块的一个远程上可用的所有子模块提交（在要推送的修订中进行了更改）。如果缺少任何提交，则推送将被中止并以非零状态退出。如果该值是 &lt;code&gt;on-demand&lt;/code&gt; 则将推送要推送的修订中已更改的所有子模块。如果按需无法推送所有必要的修订，则它将也被中止并以非零状态退出。如果该值为 &lt;code&gt;no&lt;/code&gt; ,则保留在推送时忽略子模块的默认行为。您可以在推送时通过指定以下内容覆盖此配置 &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e58089d4f2b4b0ca2024cc65ec03ed1d72bcb40" translate="yes" xml:space="preserve">
          <source>Make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If the value is &lt;code&gt;check&lt;/code&gt; then Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing, the push will be aborted and exit with non-zero status. If the value is &lt;code&gt;on-demand&lt;/code&gt; then all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If the value is &lt;code&gt;no&lt;/code&gt; then default behavior of ignoring submodules when pushing is retained. You may override this configuration at time of push by specifying &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt;. If not set, &lt;code&gt;no&lt;/code&gt; is used by default, unless &lt;code&gt;submodule.recurse&lt;/code&gt; is set (in which case a &lt;code&gt;true&lt;/code&gt; value means &lt;code&gt;on-demand&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b6629c434b51e7d9186d1fc6fe97c1a3725440" translate="yes" xml:space="preserve">
          <source>Make sure committers have a umask of at most 027, so that the directories they create are writable and searchable by other group members.</source>
          <target state="translated">确保提交者的掩码最多为027,这样他们创建的目录就可以被其他组员写入和搜索。</target>
        </trans-unit>
        <trans-unit id="4b35196a3d616941ad0c8a125c3a9f25e1bdc376" translate="yes" xml:space="preserve">
          <source>Make sure this directory is available for others you want your changes to be pulled via the transport of your choice. Also you need to make sure that you have the &lt;code&gt;git-receive-pack&lt;/code&gt; program on the &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">确保此目录可用于您希望通过选择的传输来提取更改的其他目录。另外，您还需要确保 &lt;code&gt;$PATH&lt;/code&gt; 上有 &lt;code&gt;git-receive-pack&lt;/code&gt; 程序。</target>
        </trans-unit>
        <trans-unit id="6631b9ca24ae751d7ee25163002526a066325c25" translate="yes" xml:space="preserve">
          <source>Make the first mail (or all the mails with &lt;code&gt;--no-thread&lt;/code&gt;) appear as a reply to the given &amp;lt;message id&amp;gt;, which avoids breaking threads to provide a new patch series.</source>
          <target state="translated">使第一封邮件（或所有带有 &lt;code&gt;--no-thread&lt;/code&gt; 的邮件）作为对给定&amp;lt;message id&amp;gt;的答复，从而避免破坏线程以提供新的修补程序系列。</target>
        </trans-unit>
        <trans-unit id="5a1ce0ecb5c94a2505e8bfd1950281f48170d98f" translate="yes" xml:space="preserve">
          <source>Make the first mail (or all the mails with &lt;code&gt;--no-thread&lt;/code&gt;) appear as a reply to the given Message-Id, which avoids breaking threads to provide a new patch series. The second and subsequent emails will be sent as replies according to the &lt;code&gt;--[no-]chain-reply-to&lt;/code&gt; setting.</source>
          <target state="translated">使第一封邮件（或所有带有 &lt;code&gt;--no-thread&lt;/code&gt; 的邮件）作为对给定Message-Id的答复，从而避免破坏线程以提供新的修补程序系列。第二封电子邮件及其后的电子邮件将根据 &lt;code&gt;--[no-]chain-reply-to&lt;/code&gt; 设置作为答复发送。</target>
        </trans-unit>
        <trans-unit id="b064d6e8766baf86355fa160624701d28d48e0eb" translate="yes" xml:space="preserve">
          <source>Make the program exit with codes similar to diff(1). That is, it exits with 1 if there were differences and 0 means no differences.</source>
          <target state="translated">让程序以类似 diff(1)的代码退出。也就是说,如果有差异,则以1退出,0表示没有差异。</target>
        </trans-unit>
        <trans-unit id="033698ff1d93839c9dc26bb7039e879974408d51" translate="yes" xml:space="preserve">
          <source>Make the repository group-writable, (and g+sx, since the git group may be not the primary group of all users). This is used to loosen the permissions of an otherwise safe umask(2) value. Note that the umask still applies to the other permission bits (e.g. if umask is &lt;code&gt;0022&lt;/code&gt;, using &lt;code&gt;group&lt;/code&gt; will not remove read privileges from other (non-group) users). See &lt;code&gt;0xxx&lt;/code&gt; for how to exactly specify the repository permissions.</source>
          <target state="translated">使存储库组可写（和g + sx，因为git组可能不是所有用户的主要组）。这用于放宽原本安全的umask（2）值的权限。请注意，umask仍然适用于其他权限位（例如，如果umask为 &lt;code&gt;0022&lt;/code&gt; ，则使用 &lt;code&gt;group&lt;/code&gt; 不会删除其他（非组）用户的读取特权）。有关如何准确指定存储库权限的信息，请参见 &lt;code&gt;0xxx&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="daa563a54f59f3d95749377d0e4af4c611fecd18" translate="yes" xml:space="preserve">
          <source>Making a change</source>
          <target state="translated">做出改变</target>
        </trans-unit>
        <trans-unit id="9aef7fbf27451a8c36fe7bf7a109aea9540e01ca" translate="yes" xml:space="preserve">
          <source>Making changes</source>
          <target state="translated">做出改变</target>
        </trans-unit>
        <trans-unit id="992a7beb5615876037da9b0e5b4a3e7c21af51d8" translate="yes" xml:space="preserve">
          <source>Making some changes to the working directory using your favorite editor.</source>
          <target state="translated">使用你喜欢的编辑器对工作目录进行一些修改。</target>
        </trans-unit>
        <trans-unit id="bf4919466a0f70dfd02acc3627e75ad16a05f620" translate="yes" xml:space="preserve">
          <source>Manage multiple working trees</source>
          <target state="translated">管理多棵工作树</target>
        </trans-unit>
        <trans-unit id="6ec4a25401fa228522c7be97da233480069758e8" translate="yes" xml:space="preserve">
          <source>Manage multiple working trees attached to the same repository.</source>
          <target state="translated">管理连接到同一资源库的多个工作树。</target>
        </trans-unit>
        <trans-unit id="5f089a6eb7f251a9a2fe0a3f833141f8db37c3ff" translate="yes" xml:space="preserve">
          <source>Manage reflog information</source>
          <target state="translated">管理重新登录信息</target>
        </trans-unit>
        <trans-unit id="021ab6f7ef8793b1b816ea4bdd5e727ce06994e0" translate="yes" xml:space="preserve">
          <source>Manage set of tracked repositories</source>
          <target state="translated">管理一组跟踪的存储库</target>
        </trans-unit>
        <trans-unit id="65f908ba554d3d8c75571c008e2b6e59e8585d63" translate="yes" xml:space="preserve">
          <source>Manage the serialized commit-graph file.</source>
          <target state="translated">管理序列化的提交图文件。</target>
        </trans-unit>
        <trans-unit id="4a3e0eed31d02104159aa0bed6d5acb0e05768b8" translate="yes" xml:space="preserve">
          <source>Manage the set of repositories (&quot;remotes&quot;) whose branches you track.</source>
          <target state="translated">管理您跟踪的分支的存储库(&quot;远程&quot;)集。</target>
        </trans-unit>
        <trans-unit id="3507e0027b822825db37aad1b6a1e0779dcd0d96" translate="yes" xml:space="preserve">
          <source>Managing branches</source>
          <target state="translated">管理分支机构</target>
        </trans-unit>
        <trans-unit id="279735249dbe3dcc024592a529bd9cb39b1b8496" translate="yes" xml:space="preserve">
          <source>Manipulate the notes tree in &amp;lt;ref&amp;gt;. This overrides &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; and the &quot;core.notesRef&quot; configuration. The ref specifies the full refname when it begins with &lt;code&gt;refs/notes/&lt;/code&gt;; when it begins with &lt;code&gt;notes/&lt;/code&gt;, &lt;code&gt;refs/&lt;/code&gt; and otherwise &lt;code&gt;refs/notes/&lt;/code&gt; is prefixed to form a full name of the ref.</source>
          <target state="translated">在&amp;lt;ref&amp;gt;中操作注释树。这将覆盖 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 和&amp;ldquo; core.notesRef&amp;rdquo;配置。ref以 &lt;code&gt;refs/notes/&lt;/code&gt; 开头时指定完整的refname ；当它与开始 &lt;code&gt;notes/&lt;/code&gt; ， &lt;code&gt;refs/&lt;/code&gt; 否则 &lt;code&gt;refs/notes/&lt;/code&gt; 前缀，以形成REF的全名。</target>
        </trans-unit>
        <trans-unit id="ad0e6ab545d99b4fca1e842f2d64e34b5bf6ca91" translate="yes" xml:space="preserve">
          <source>Manipulating branches</source>
          <target state="translated">操作分支</target>
        </trans-unit>
        <trans-unit id="e163593ceb018ccfe91e5474069f8880c01bf32f" translate="yes" xml:space="preserve">
          <source>Manipulation commands</source>
          <target state="translated">操作命令</target>
        </trans-unit>
        <trans-unit id="a4c79f29e9d9d5fa1534359d2910523c3bd41716" translate="yes" xml:space="preserve">
          <source>Manipulators:</source>
          <target state="translated">Manipulators:</target>
        </trans-unit>
        <trans-unit id="2d6fc489721f7990b3e0a46d8dbd0fae7613420d" translate="yes" xml:space="preserve">
          <source>Many (most?) public remote repositories will not contain any of the checked out files or even an index file, and will &lt;strong&gt;only&lt;/strong&gt; contain the actual core Git files. Such a repository usually doesn&amp;rsquo;t even have the &lt;code&gt;.git&lt;/code&gt; subdirectory, but has all the Git files directly in the repository.</source>
          <target state="translated">许多（大多数？）公共远程存储库将不包含任何已检出的文件，甚至不包含索引文件，而&lt;strong&gt;仅&lt;/strong&gt;包含实际的核心Git文件。这样的存储库通常甚至没有 &lt;code&gt;.git&lt;/code&gt; 子目录，但是直接在存储库中具有所有Git文件。</target>
        </trans-unit>
        <trans-unit id="23a4d8d6b8951ee492fd478361a461e34445c192" translate="yes" xml:space="preserve">
          <source>Many Git commands also take sets of commits, which can be specified in a number of ways. Here are some examples with &lt;code&gt;git log&lt;/code&gt;:</source>
          <target state="translated">许多Git命令也采用提交集，可以用多种方式指定它们。这是 &lt;code&gt;git log&lt;/code&gt; 的一些例子：</target>
        </trans-unit>
        <trans-unit id="cb5f624f4f524730b1dad471a4cc62df1265c105" translate="yes" xml:space="preserve">
          <source>Many Git commands take revision parameters as arguments. Depending on the command, they denote a specific commit or, for commands which walk the revision graph (such as &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;), all commits which are reachable from that commit. For commands that walk the revision graph one can also specify a range of revisions explicitly.</source>
          <target state="translated">许多Git命令将修订版参数作为参数。根据命令，它们表示特定的提交，或者对于遍历修订图的命令（例如&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;），表示该提交可以到达的所有提交。对于沿修订图运行的命令，还可以显式指定一系列修订。</target>
        </trans-unit>
        <trans-unit id="8eadff7d5c23284bf3e40779cca1324c9880e38b" translate="yes" xml:space="preserve">
          <source>Many Git porcelainish commands take mixture of flags (i.e. parameters that begin with a dash &lt;code&gt;-&lt;/code&gt;) and parameters meant for the underlying &lt;code&gt;git rev-list&lt;/code&gt; command they use internally and flags and parameters for the other commands they use downstream of &lt;code&gt;git rev-list&lt;/code&gt;. This command is used to distinguish between them.</source>
          <target state="translated">许多GIT中porcelainish命令采取标志的混合物（即以破折号开始参数 &lt;code&gt;-&lt;/code&gt; ）和意味着底层参数 &lt;code&gt;git rev-list&lt;/code&gt; 它们内部使用命令和标志和参数为他们所使用的下游的其它命令 &lt;code&gt;git rev-list&lt;/code&gt; 。此命令用于区分它们。</target>
        </trans-unit>
        <trans-unit id="07f9a7fabb84ff55c93b5220c84bc1016373588c" translate="yes" xml:space="preserve">
          <source>Many command-line options can be provided as part of the fast-import stream itself by using the &lt;code&gt;feature&lt;/code&gt; or &lt;code&gt;option&lt;/code&gt; commands. However, some of these options are unsafe (e.g., allowing fast-import to access the filesystem outside of the repository). These options are disabled by default, but can be allowed by providing this option on the command line. This currently impacts only the &lt;code&gt;export-marks&lt;/code&gt;, &lt;code&gt;import-marks&lt;/code&gt;, and &lt;code&gt;import-marks-if-exists&lt;/code&gt; feature commands.</source>
          <target state="translated">通过使用 &lt;code&gt;feature&lt;/code&gt; 或 &lt;code&gt;option&lt;/code&gt; 命令，许多命令行选项可以作为快速导入流本身的一部分提供。但是，其中某些选项是不安全的（例如，允许快速导入来访问存储库外部的文件系统）。这些选项默认情况下是禁用的，但可以通过在命令行上提供此选项来允许。当前，这仅影响 &lt;code&gt;export-marks&lt;/code&gt; ， &lt;code&gt;import-marks&lt;/code&gt; 和 &lt;code&gt;import-marks-if-exists&lt;/code&gt; 功能命令。</target>
        </trans-unit>
        <trans-unit id="b810424b3fea997d54a1c6f50a7ffa7b2bdf31cc" translate="yes" xml:space="preserve">
          <source>Many commands allow wildcards in paths, but you need to protect them from getting globbed by the shell. These two mean different things:</source>
          <target state="translated">许多命令允许在路径中使用通配符,但你需要保护它们不被shell globbed。这两个意思是不同的。</target>
        </trans-unit>
        <trans-unit id="f769735173b4b17536b3bddf331e35fc94c1f6c2" translate="yes" xml:space="preserve">
          <source>Many commands take revisions (most often &quot;commits&quot;, but sometimes &quot;tree-ish&quot;, depending on the context and command) and paths as their arguments. Here are the rules:</source>
          <target state="translated">许多命令将修订版(最常见的是 &quot;提交&quot;,但有时是 &quot;树状&quot;,取决于上下文和命令)和路径作为参数。下面是一些规则。</target>
        </trans-unit>
        <trans-unit id="51a04d163df59d3e4e585f46784dd69c625e4feb" translate="yes" xml:space="preserve">
          <source>Many commands that can work on files in the working tree and/or in the index can take &lt;code&gt;--cached&lt;/code&gt; and/or &lt;code&gt;--index&lt;/code&gt; options. Sometimes people incorrectly think that, because the index was originally called cache, these two are synonyms. They are &lt;strong&gt;not&lt;/strong&gt; &amp;mdash; these two options mean very different things.</source>
          <target state="translated">许多可以在工作树和/或索引中处理文件的命令都可以使用 &lt;code&gt;--cached&lt;/code&gt; 和/或 &lt;code&gt;--index&lt;/code&gt; 选项。有时人们会错误地认为，因为索引最初称为缓存，所以这两个是同义词。他们是&lt;strong&gt;不是&lt;/strong&gt; -这两个选项的意思是完全不同的东西。</target>
        </trans-unit>
        <trans-unit id="41a419d79cd72b9d54b27ecee9672655c35e91cc" translate="yes" xml:space="preserve">
          <source>Many gitweb features can be enabled (or disabled) and configured using the &lt;code&gt;%feature&lt;/code&gt; hash. Names of gitweb features are keys of this hash.</source>
          <target state="translated">可以使用 &lt;code&gt;%feature&lt;/code&gt; 哈希值启用（或禁用）和配置许多gitweb功能。gitweb功能的名称是此哈希的键。</target>
        </trans-unit>
        <trans-unit id="919a2ac82af6ff1bc82b2171d1abca264db10f6e" translate="yes" xml:space="preserve">
          <source>Many installations of sshd do not invoke your shell as the login shell when you directly run programs; what this means is that if your login shell is &lt;em&gt;bash&lt;/em&gt;, only &lt;code&gt;.bashrc&lt;/code&gt; is read and not &lt;code&gt;.bash_profile&lt;/code&gt;. As a workaround, make sure &lt;code&gt;.bashrc&lt;/code&gt; sets up &lt;code&gt;$PATH&lt;/code&gt; so that you can run &lt;em&gt;git-receive-pack&lt;/em&gt; program.</source>
          <target state="translated">当直接运行程序时，许多sshd安装都不会将您的shell用作登录shell。这意味着如果您的登录shell是&lt;em&gt;bash&lt;/em&gt;，则仅读取 &lt;code&gt;.bashrc&lt;/code&gt; 而不读取 &lt;code&gt;.bash_profile&lt;/code&gt; 。解决方法是，确保 &lt;code&gt;.bashrc&lt;/code&gt; 设置 &lt;code&gt;$PATH&lt;/code&gt; 以便可以运行&lt;em&gt;git-receive-pack&lt;/em&gt;程序。</target>
        </trans-unit>
        <trans-unit id="b683891958210e2ee979b3e8c7ad10f12997dda2" translate="yes" xml:space="preserve">
          <source>Many mailers if not set up properly will corrupt whitespace. Here are two common types of corruption:</source>
          <target state="translated">很多邮件如果设置不当,就会损坏空白处。以下是两种常见的损坏类型。</target>
        </trans-unit>
        <trans-unit id="193dde6b7f3a20700543ed6450f24935f7b33dfa" translate="yes" xml:space="preserve">
          <source>Many of the higher-level commands were originally implemented as shell scripts using a smaller core of low-level Git commands. These can still be useful when doing unusual things with Git, or just as a way to understand its inner workings.</source>
          <target state="translated">许多更高级的命令最初都是以 shell 脚本的形式实现的,使用的是较小的低级 Git 命令。这些命令在使用Git做一些不寻常的事情时还是很有用的,或者只是作为一种了解Git内部工作的方式。</target>
        </trans-unit>
        <trans-unit id="3d6c28c55f8170d273c49f3e427a981c665cf6ea" translate="yes" xml:space="preserve">
          <source>Many operations in Git depend on your filesystem to have an efficient &lt;code&gt;lstat(2)&lt;/code&gt; implementation, so that &lt;code&gt;st_mtime&lt;/code&gt; information for working tree files can be cheaply checked to see if the file contents have changed from the version recorded in the index file. Unfortunately, some filesystems have inefficient &lt;code&gt;lstat(2)&lt;/code&gt;. If your filesystem is one of them, you can set &quot;assume unchanged&quot; bit to paths you have not changed to cause Git not to do this check. Note that setting this bit on a path does not mean Git will check the contents of the file to see if it has changed &amp;mdash; it makes Git to omit any checking and assume it has &lt;strong&gt;not&lt;/strong&gt; changed. When you make changes to working tree files, you have to explicitly tell Git about it by dropping &quot;assume unchanged&quot; bit, either before or after you modify them.</source>
          <target state="translated">Git中的许多操作都取决于您的文件系统是否具有有效的 &lt;code&gt;lstat(2)&lt;/code&gt; 实现，因此可以廉价地检查工作树文件的 &lt;code&gt;st_mtime&lt;/code&gt; 信息，以查看文件内容是否已从索引文件中记录的版本更改。不幸的是，某些文件系统的 &lt;code&gt;lstat(2)&lt;/code&gt; 效率低下。如果您的文件系统是其中之一，则可以将&amp;ldquo;假定未更改&amp;rdquo;位设置为尚未更改的路径，以使Git不执行此检查。请注意，在路径上设置此位并不意味着Git将检查文件的内容以查看其是否已更改-它使Git省略任何检查并假定它&lt;strong&gt;没有&lt;/strong&gt;更改。&lt;strong&gt;&lt;/strong&gt;改变了。对工作树文件进行更改时，必须在修改它们之前或之后通过删除&amp;ldquo;假定未更改&amp;rdquo;位来明确告知Git。</target>
        </trans-unit>
        <trans-unit id="a799d1cceae5d3b6566df7c502b0ed31229cf195" translate="yes" xml:space="preserve">
          <source>Many revision control systems provide an &lt;code&gt;add&lt;/code&gt; command that tells the system to start tracking changes to a new file. Git&amp;rsquo;s &lt;code&gt;add&lt;/code&gt; command does something simpler and more powerful: &lt;code&gt;git add&lt;/code&gt; is used both for new and newly modified files, and in both cases it takes a snapshot of the given files and stages that content in the index, ready for inclusion in the next commit.</source>
          <target state="translated">许多修订控制系统提供一个 &lt;code&gt;add&lt;/code&gt; 命令，该命令告诉系统开始跟踪对新文件的更改。Git的 &lt;code&gt;add&lt;/code&gt; 命令执行了更简单，更强大的功能： &lt;code&gt;git add&lt;/code&gt; 用于新文件和新修改的文​​件，并且在两种情况下，它都会获取给定文件的快照并分阶段存储索引中的内容，以备下次提交时使用。</target>
        </trans-unit>
        <trans-unit id="f4ad3aa56684a237b2a48778413d62e45b68868b" translate="yes" xml:space="preserve">
          <source>Many tags. Will create a tag for every commit, reflecting the commit name in the Arch repository.</source>
          <target state="translated">许多标签。将为每个提交创建一个标签,反映Arch仓库中的提交名称。</target>
        </trans-unit>
        <trans-unit id="6b4939f173ca46ae5e70f2a578215c85acafb3ce" translate="yes" xml:space="preserve">
          <source>Many thanks to Ingo Molnar for giving me very useful information that appears in this paper, for commenting on this paper, for his suggestions to improve &quot;git bisect&quot; and for evangelizing &quot;git bisect&quot; on the linux kernel mailing lists.</source>
          <target state="translated">非常感谢Ingo Molnar给我提供了本文中出现的非常有用的信息,感谢他对本文的评论,感谢他对改进 &quot;git bisect &quot;的建议,感谢他在linux内核邮件列表中对 &quot;git bisect &quot;的宣传。</target>
        </trans-unit>
        <trans-unit id="5bd4feea472ac1f81e9eed337015c1647da376b9" translate="yes" xml:space="preserve">
          <source>Many thanks to Junio Hamano for his help in reviewing this paper, for reviewing the patches I sent to the Git mailing list, for discussing some ideas and helping me improve them, for improving &quot;git bisect&quot; a lot and for his awesome work in maintaining and developing Git.</source>
          <target state="translated">非常感谢Junio Hamano在审阅本文时提供的帮助,感谢他审阅了我发给Git邮件列表的补丁,感谢他讨论了一些想法并帮助我改进,感谢他对 &quot;git bisect &quot;进行了很多改进,感谢他在维护和开发Git方面的出色工作。</target>
        </trans-unit>
        <trans-unit id="a308e878405ccac0452dc3a943e6c4f471d0d0f3" translate="yes" xml:space="preserve">
          <source>Many thanks to Linus Torvalds for inventing, developing and evangelizing &quot;git bisect&quot;, Git and Linux.</source>
          <target state="translated">非常感谢 Linus Torvalds 发明、开发和传播 &quot;git bisect&quot;、Git 和 Linux。</target>
        </trans-unit>
        <trans-unit id="64e052904657c30a32be467111b38e2db70890d3" translate="yes" xml:space="preserve">
          <source>Many thanks to the Linux-Kongress program committee for choosing the author to given a talk and for publishing this paper.</source>
          <target state="translated">非常感谢Linux-Kongress项目委员会选择作者做演讲并发表这篇论文。</target>
        </trans-unit>
        <trans-unit id="a813e2d801820a3507d225cfe410c73c1e3814a5" translate="yes" xml:space="preserve">
          <source>Many thanks to the many other great people who helped one way or another when I worked on Git, especially to Andreas Ericsson, Johannes Schindelin, H. Peter Anvin, Daniel Barkalow, Bill Lear, John Hawley, Shawn O. Pierce, Jeff King, Sam Vilain, Jon Seymour.</source>
          <target state="translated">非常感谢在我研究 Git 的过程中给予我帮助的其他很多人,尤其是 Andreas Ericsson、Johannes Schindelin、H.Peter Anvin、Daniel Barkalow、Bill Lear、John Hawley、Shawn O.Pierce、Jeff King、Sam Vilain 和 Jon Seymour。</target>
        </trans-unit>
        <trans-unit id="970bd5edbccf4926f346f36ced29b782ff134b0f" translate="yes" xml:space="preserve">
          <source>Many things can then be done very naturally:</source>
          <target state="translated">很多事情就可以很自然的完成。</target>
        </trans-unit>
        <trans-unit id="08ed471839ae0d35cbf114cdc8b4fb025451ea78" translate="yes" xml:space="preserve">
          <source>Map a P4 user to a name and email address in Git. Use a string with the following format to create a mapping:</source>
          <target state="translated">将一个 P4 用户映射到 Git 中的名字和电子邮件地址。使用以下格式的字符串来创建映射。</target>
        </trans-unit>
        <trans-unit id="84e3b6902de1ae94c28d951dff280df12bc818fa" translate="yes" xml:space="preserve">
          <source>Mapping authors</source>
          <target state="translated">绘图者</target>
        </trans-unit>
        <trans-unit id="ecca08ad6644372b493b29196801e0262451ee0a" translate="yes" xml:space="preserve">
          <source>Mapping between Subversion revision numbers and Git commit names. In a repository where the noMetadata option is not set, this can be rebuilt from the git-svn-id: lines that are at the end of every commit (see the &lt;code&gt;svn.noMetadata&lt;/code&gt; section above for details).</source>
          <target state="translated">Subversion版本号和Git提交名称之间的映射。在未设置noMetadata选项的存储库中，可以从git-svn-id：每次提交结束时的行重新构建它（有关详细信息，请参见上面的 &lt;code&gt;svn.noMetadata&lt;/code&gt; 部分）。</target>
        </trans-unit>
        <trans-unit id="f80c6e32aadbd525747e2562fb58002684c64ae1" translate="yes" xml:space="preserve">
          <source>Mark lines that were changed by an ignored revision that we attributed to another commit with a &lt;code&gt;?&lt;/code&gt; in the output of &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">标记被忽略的修订所更改的行，我们将其归因于另一个带有 &lt;code&gt;?&lt;/code&gt; 的提交 在&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;的输出中。</target>
        </trans-unit>
        <trans-unit id="e0a93a83bc77d4e299bb423ede0b0e7523360c05" translate="yes" xml:space="preserve">
          <source>Mark lines that were changed by an ignored revision that we could not attribute to another commit with a &lt;code&gt;*&lt;/code&gt; in the output of &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">标记被忽略的修订更改的行，我们无法将其归因于&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;输出中带有 &lt;code&gt;*&lt;/code&gt; 的另一个提交。</target>
        </trans-unit>
        <trans-unit id="ffa04a5e9e510ce8e8a9af22652c96cb5f2a2455" translate="yes" xml:space="preserve">
          <source>Mark the commit you want to split with the action &quot;edit&quot;.</source>
          <target state="translated">用 &quot;编辑 &quot;动作标记您要分割的提交。</target>
        </trans-unit>
        <trans-unit id="9ad05336158823a7d5e9d2740631e3ed3e7b77cc" translate="yes" xml:space="preserve">
          <source>Mark the series as the &amp;lt;n&amp;gt;-th iteration of the topic. The output filenames have &lt;code&gt;v&amp;lt;n&amp;gt;&lt;/code&gt; prepended to them, and the subject prefix (&quot;PATCH&quot; by default, but configurable via the &lt;code&gt;--subject-prefix&lt;/code&gt; option) has ` v&amp;lt;n&amp;gt;` appended to it. E.g. &lt;code&gt;--reroll-count=4&lt;/code&gt; may produce &lt;code&gt;v4-0001-add-makefile.patch&lt;/code&gt; file that has &quot;Subject: [PATCH v4 1/20] Add makefile&quot; in it.</source>
          <target state="translated">将系列标记为该主题的第&amp;lt;n&amp;gt;个迭代。输出文件名前带有 &lt;code&gt;v&amp;lt;n&amp;gt;&lt;/code&gt; ，主题前缀（默认为&amp;ldquo; PATCH&amp;rdquo;，但可通过 &lt;code&gt;--subject-prefix&lt;/code&gt; 选项配置）后附加`v &amp;lt;n&amp;gt;。例如 &lt;code&gt;--reroll-count=4&lt;/code&gt; 可能会生成其中带有&amp;ldquo;主题：[PATCH v4 1/20]添加makefile&amp;rdquo;的 &lt;code&gt;v4-0001-add-makefile.patch&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="eb02cc756d5e31341021dd6b9e08120c18cfff12" translate="yes" xml:space="preserve">
          <source>Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with &lt;code&gt;&amp;lt;&lt;/code&gt; and those from the right with &lt;code&gt;&amp;gt;&lt;/code&gt;. If combined with &lt;code&gt;--boundary&lt;/code&gt;, those commits are prefixed with &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">标记可从哪个对称差异到达提交。左侧的提交以 &lt;code&gt;&amp;lt;&lt;/code&gt; 为前缀，而右侧的提交以 &lt;code&gt;&amp;gt;&lt;/code&gt; 为前缀。如果与 &lt;code&gt;--boundary&lt;/code&gt; 结合使用，则这些提交的前缀为 &lt;code&gt;-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cf65e398a783b020004a05bc4b12965bd321675" translate="yes" xml:space="preserve">
          <source>Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with a &lt;code&gt;&amp;lt;&lt;/code&gt; symbol and those from the right with a &lt;code&gt;&amp;gt;&lt;/code&gt; symbol.</source>
          <target state="translated">标记可从哪个对称差异到达提交。从左侧提交的前缀为一个 &lt;code&gt;&amp;lt;&lt;/code&gt; 符号和那些从与右 &lt;code&gt;&amp;gt;&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="d120d1dcfa9af04a37a29923ad102f9ac75edbe0" translate="yes" xml:space="preserve">
          <source>Marking files as binary</source>
          <target state="translated">将文件标记为二进制文件</target>
        </trans-unit>
        <trans-unit id="3549e52dba075c1ca63de7856965a26fd121848f" translate="yes" xml:space="preserve">
          <source>Marks are stored in a sparse array, using 1 pointer (4 bytes or 8 bytes, depending on pointer size) per mark. Although the array is sparse, frontends are still strongly encouraged to use marks between 1 and n, where n is the total number of marks required for this import.</source>
          <target state="translated">标记被存储在一个稀疏的数组中,每个标记使用一个指针(4个字节或8个字节,取决于指针大小)。虽然这个数组是稀疏的,但我们仍然强烈鼓励前端使用1到n之间的标记,其中n是这个导入所需的标记总数。</target>
        </trans-unit>
        <trans-unit id="c020b534de76a3110681e8b3a1131c198a04e4dd" translate="yes" xml:space="preserve">
          <source>Marks must be declared (via &lt;code&gt;mark&lt;/code&gt;) before they can be used.</source>
          <target state="translated">必须先声明 &lt;code&gt;mark&lt;/code&gt; （通过mark），然后才能使用它们。</target>
        </trans-unit>
        <trans-unit id="e23875af098ed58ac7ddbf626ebbfd55b3530c2d" translate="yes" xml:space="preserve">
          <source>Marks the end of the stream. This command is optional unless the &lt;code&gt;done&lt;/code&gt; feature was requested using the &lt;code&gt;--done&lt;/code&gt; command-line option or &lt;code&gt;feature done&lt;/code&gt; command.</source>
          <target state="translated">标记流的结束。除非使用 &lt;code&gt;--done&lt;/code&gt; 命令行选项或 &lt;code&gt;feature done&lt;/code&gt; 命令请求 &lt;code&gt;done&lt;/code&gt; 功能，否则此命令是可选的。</target>
        </trans-unit>
        <trans-unit id="6dd5e3d7525f7c72ed149669f4682e8cf2613e2e" translate="yes" xml:space="preserve">
          <source>Match paths exactly (i.e. don&amp;rsquo;t allow &quot;/foo/repo&quot; when the real path is &quot;/foo/repo.git&quot; or &quot;/foo/repo/.git&quot;) and don&amp;rsquo;t do user-relative paths. &lt;code&gt;git daemon&lt;/code&gt; will refuse to start when this option is enabled and no whitelist is specified.</source>
          <target state="translated">完全匹配路径（即，当真实路径为&amp;ldquo; /foo/repo.git&amp;rdquo;或&amp;ldquo; /foo/repo/.git&amp;rdquo;时，不允许&amp;ldquo; / foo / repo&amp;rdquo;），并且不执行用户相对路径。启用此选项并且未指定白名单时， &lt;code&gt;git daemon&lt;/code&gt; 将拒绝启动。</target>
        </trans-unit>
        <trans-unit id="1c5cb990d5ea569aee72e359a127ac5dd4a253ea" translate="yes" xml:space="preserve">
          <source>Match the pattern only at word boundary (either begin at the beginning of a line, or preceded by a non-word character; end at the end of a line or followed by a non-word character).</source>
          <target state="translated">只在字的边界处匹配模式(要么在行首,要么在行前有一个非字字符;要么在行尾,要么在行后有一个非字字符)。</target>
        </trans-unit>
        <trans-unit id="ca182a2e7bbbd5ec9c62eec976529a0aa078540e" translate="yes" xml:space="preserve">
          <source>Match the regular expression limiting patterns without regard to letter case.</source>
          <target state="translated">匹配不考虑字母大小写的正则表达式限制模式。</target>
        </trans-unit>
        <trans-unit id="1452c4b1c4eed7c80174fb8c82a8ed6f95d98c4d" translate="yes" xml:space="preserve">
          <source>Maximum delta depth, for blob and tree deltification. Default is 50.</source>
          <target state="translated">最大的delta深度,用于blob和树的deltification。默认为50。</target>
        </trans-unit>
        <trans-unit id="384f40abc20254795ab29a564353f53402412c1e" translate="yes" xml:space="preserve">
          <source>Maximum number of branches to maintain active at once. See &amp;ldquo;Memory Utilization&amp;rdquo; below for details. Default is 5.</source>
          <target state="translated">一次保持活动状态的最大分支数。有关详细信息，请参见下面的&amp;ldquo;内存利用率&amp;rdquo;。默认值为5。</target>
        </trans-unit>
        <trans-unit id="0a8681cfb7605cda2b80805ca7e930924afc3f52" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes per thread to reserve for caching base objects that may be referenced by multiple deltified objects. By storing the entire decompressed base objects in a cache Git is able to avoid unpacking and decompressing frequently used base objects multiple times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba691ad2489c6a98bfddfb725c399a5433235ec" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to map simultaneously into memory from pack files. If Git needs to access more than this many bytes at once to complete an operation it will unmap existing regions to reclaim virtual address space within the process.</source>
          <target state="translated">从打包文件同时映射到内存的最大字节数。如果Git为了完成一个操作,需要同时访问超过这个数量的字节,它将在进程中取消映射现有的区域,以回收虚拟地址空间。</target>
        </trans-unit>
        <trans-unit id="015780ae5eaf5a16460a6c6f6a47f9fd68665f6e" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to reserve for caching base objects that may be referenced by multiple deltified objects. By storing the entire decompressed base objects in a cache Git is able to avoid unpacking and decompressing frequently used base objects multiple times.</source>
          <target state="translated">预留的最大字节数,用于缓存可能被多个解压缩对象引用的基础对象。通过将整个解压后的基础对象存储在缓存中,Git可以避免多次解包和解压频繁使用的基础对象。</target>
        </trans-unit>
        <trans-unit id="9639a9871e3fa301072f34b62bd6d8d1df5dfde8" translate="yes" xml:space="preserve">
          <source>Maximum number of concurrent clients, defaults to 32. Set it to zero for no limit.</source>
          <target state="translated">最大并发客户端数,默认为32。设置为零则没有限制。</target>
        </trans-unit>
        <trans-unit id="3fca64028c3b9d66663fb33bbabf381bdeaeb020" translate="yes" xml:space="preserve">
          <source>Maximum size in bytes of the buffer used by smart HTTP transports when POSTing data to the remote system. For requests larger than this buffer size, HTTP/1.1 and Transfer-Encoding: chunked is used to avoid creating a massive pack file locally. Default is 1 MiB, which is sufficient for most requests.</source>
          <target state="translated">智能HTTP传输在向远程系统POST数据时使用的缓冲区的最大大小,以字节为单位。对于大于这个缓冲区大小的请求,使用HTTP/1.1和Transfer-Encoding:chunked来避免在本地创建一个庞大的打包文件。默认为1 MiB,对于大多数请求来说已经足够了。</target>
        </trans-unit>
        <trans-unit id="d63005f2c2b8f8c3239933e10d80e78d75fee39e" translate="yes" xml:space="preserve">
          <source>Maximum size of a blob that fast-import will attempt to create a delta for, expressed in bytes. The default is 512m (512 MiB). Some importers may wish to lower this on systems with constrained memory.</source>
          <target state="translated">fast-import试图创建delta的blob的最大大小,以字节表示。默认值是512m(512 MiB)。在内存有限的系统中,一些导入者可能希望降低这个大小。</target>
        </trans-unit>
        <trans-unit id="d3dd84835c1a4e2de21619e12a6eaaff0c2d1fd8" translate="yes" xml:space="preserve">
          <source>Maximum size of each output pack file. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. The minimum size allowed is limited to 1 MiB. If specified, multiple packfiles may be created, which also prevents the creation of a bitmap index. The default is unlimited, unless the config variable &lt;code&gt;pack.packSizeLimit&lt;/code&gt; is set.</source>
          <target state="translated">每个输出包文件的最大大小。大小可以后缀&amp;ldquo; k&amp;rdquo;，&amp;ldquo; m&amp;rdquo;或&amp;ldquo; g&amp;rdquo;。允许的最小大小限制为1 MiB。如果指定，则可能会创建多个packfile，这也将阻止创建位图索引。除非设置了配置变量 &lt;code&gt;pack.packSizeLimit&lt;/code&gt; ，否则默认值为无限制。</target>
        </trans-unit>
        <trans-unit id="b8685db9c67d15fcb99750ad6a0c6f6dc3e27c92" translate="yes" xml:space="preserve">
          <source>Maximum size of each output packfile. The default is unlimited.</source>
          <target state="translated">每个输出包文件的最大尺寸。默认为无限大。</target>
        </trans-unit>
        <trans-unit id="ecff084a0c01e319db62c5b088c7a98c5cc26a2a" translate="yes" xml:space="preserve">
          <source>May be an unabbreviated ref name or a glob and may be specified multiple times. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">可以是一个不加缩写的参考名,也可以是一个glob,可以指定多次。对于不存在的参考文献会发出警告,但不匹配任何参考文献的glob会被默默忽略。</target>
        </trans-unit>
        <trans-unit id="706c83c32d28c2f1cb1aaafc37be7356f71e7631" translate="yes" xml:space="preserve">
          <source>May be set to a boolean value, or the string &lt;code&gt;if-asked&lt;/code&gt;. A true value causes all pushes to be GPG signed, as if &lt;code&gt;--signed&lt;/code&gt; is passed to &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;. The string &lt;code&gt;if-asked&lt;/code&gt; causes pushes to be signed if the server supports it, as if &lt;code&gt;--signed=if-asked&lt;/code&gt; is passed to &lt;code&gt;git push&lt;/code&gt;. A false value may override a value from a lower-priority config file. An explicit command-line flag always overrides this config option.</source>
          <target state="translated">可以设置为布尔值或字符串 &lt;code&gt;if-asked&lt;/code&gt; 。值为true会使所有推送都进行GPG签名，就像 &lt;code&gt;--signed&lt;/code&gt; 传递给&lt;a href=&quot;git-push&quot;&gt;git-push [1]一样&lt;/a&gt;。如果服务器支持，则字符串 &lt;code&gt;if-asked&lt;/code&gt; 导致对推送进行签名，就像 &lt;code&gt;--signed=if-asked&lt;/code&gt; 传递给 &lt;code&gt;git push&lt;/code&gt; 一样。假值可能会覆盖优先级较低的配置文件中的值。显式命令行标志始终会覆盖此配置选项。</target>
        </trans-unit>
        <trans-unit id="8555af2d5095b661ce8d37e9e0375fb4c8ea77d6" translate="yes" xml:space="preserve">
          <source>May be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If &lt;code&gt;check&lt;/code&gt; is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If &lt;code&gt;on-demand&lt;/code&gt; is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If &lt;code&gt;only&lt;/code&gt; is used all submodules will be recursively pushed while the superproject is left unpushed. A value of &lt;code&gt;no&lt;/code&gt; or using &lt;code&gt;--no-recurse-submodules&lt;/code&gt; can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required.</source>
          <target state="translated">可用于确保要推送的修订所使用的所有子模块提交在远程跟踪分支上均可用。如果使用 &lt;code&gt;check&lt;/code&gt; ,则Git将验证至少要在该子模块的一个远程上可用的所有要在修订版本中进行更改的子模块提交都可用。如果缺少任何提交，则推送将被中止并以非零状态退出。如果 &lt;code&gt;on-demand&lt;/code&gt; 使用，则将推送要推送的修订中已更改的所有子模块。如果按需无法推送所有必要的修订，它将也被中止并以非零状态退出。如果 &lt;code&gt;only&lt;/code&gt; 使用该选项，则在不按下超级项目的情况下将递归推送所有子模块。值为 &lt;code&gt;no&lt;/code&gt; 或使用 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; 当不需要子模块递归时，可用于覆盖push.recurseSubmodules配置变量。</target>
        </trans-unit>
        <trans-unit id="8be2a61b9ad007dcdaebc339c9660a293e37ceee" translate="yes" xml:space="preserve">
          <source>Mbox file to split. If not given, the mbox is read from the standard input.</source>
          <target state="translated">要分割的Mbox文件。如果没有给定,则从标准输入中读取mbox。</target>
        </trans-unit>
        <trans-unit id="1ce7743133ea15a3c11834ae295610d6b0aca98e" translate="yes" xml:space="preserve">
          <source>Memory utilization</source>
          <target state="translated">内存利用率</target>
        </trans-unit>
        <trans-unit id="94804378bc64156caa1411beabf938d0cc1f334a" translate="yes" xml:space="preserve">
          <source>Merge a topic branch into the current branch, which resulted in a fast-forward.</source>
          <target state="translated">将一个主题分支合并到当前分支中,导致快进。</target>
        </trans-unit>
        <trans-unit id="aa4cb5d8e33b071846e0985dfd9e8a73b7ff3b77" translate="yes" xml:space="preserve">
          <source>Merge branch &lt;code&gt;maint&lt;/code&gt; into the current branch, but do not make a new commit automatically:</source>
          <target state="translated">将分支 &lt;code&gt;maint&lt;/code&gt; 合并到当前分支，但不要自动进行新的提交：</target>
        </trans-unit>
        <trans-unit id="36c2108053218bb1c9bd1daf5d80ef9e2b56153b" translate="yes" xml:space="preserve">
          <source>Merge branch &lt;code&gt;obsolete&lt;/code&gt; into the current branch, using &lt;code&gt;ours&lt;/code&gt; merge strategy:</source>
          <target state="translated">合并分支 &lt;code&gt;obsolete&lt;/code&gt; 进当前的分支，使用 &lt;code&gt;ours&lt;/code&gt; 合并策略：</target>
        </trans-unit>
        <trans-unit id="2340cae4ab971b09adab3732a6eccbc0f94439af" translate="yes" xml:space="preserve">
          <source>Merge branches &lt;code&gt;fixes&lt;/code&gt; and &lt;code&gt;enhancements&lt;/code&gt; on top of the current branch, making an octopus merge:</source>
          <target state="translated">在当前分支的顶部合并分支的 &lt;code&gt;fixes&lt;/code&gt; 和 &lt;code&gt;enhancements&lt;/code&gt; ，从而实现章鱼的合并：</target>
        </trans-unit>
        <trans-unit id="3b3fe151c69070e113efe45497e8fbe34f98eda0" translate="yes" xml:space="preserve">
          <source>Merge into the current branch the remote branch &lt;code&gt;next&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 将远程分支合并到当前分支中：</target>
        </trans-unit>
        <trans-unit id="c5d9976d41384cd800a73252d5887846f7995334" translate="yes" xml:space="preserve">
          <source>Merge one patch into CVS</source>
          <target state="translated">将一个补丁合并到CVS中</target>
        </trans-unit>
        <trans-unit id="ebf628d17763f2d1db5244a9d541825468f6e3f2" translate="yes" xml:space="preserve">
          <source>Merge one patch into CVS (-c and -w options). The working directory is within the Git Repo</source>
          <target state="translated">将一个补丁合并到 CVS 中(-c 和 -w 选项)。工作目录在 Git Repo 中。</target>
        </trans-unit>
        <trans-unit id="374bc1e6ce1c863c36094e824049bd53454731f0" translate="yes" xml:space="preserve">
          <source>Merge pending patches into CVS automatically &amp;mdash; only if you really know what you are doing</source>
          <target state="translated">自动将待处理的补丁程序合并到CVS中-仅在您真正知道自己在做什么的情况下</target>
        </trans-unit>
        <trans-unit id="1ecf516cb34751fcee31d345dc521d62850b1084" translate="yes" xml:space="preserve">
          <source>Merge strategies</source>
          <target state="translated">合并战略</target>
        </trans-unit>
        <trans-unit id="6455bb1c3dd50961d850d4ec4f8b22adf354885c" translate="yes" xml:space="preserve">
          <source>Merge the given notes ref into the current notes ref. This will try to merge the changes made by the given notes ref (called &quot;remote&quot;) since the merge-base (if any) into the current notes ref (called &quot;local&quot;).</source>
          <target state="translated">将给定的注释参考文献合并到当前的注释参考文献中。这将尝试将给定的注释参考文献(称为 &quot;远程&quot;)自合并基地(如果有的话)以来所做的更改合并到当前的注释参考文献(称为 &quot;本地&quot;)中。</target>
        </trans-unit>
        <trans-unit id="06a4a977ae422fbb370e91879e13703bae28bf9d" translate="yes" xml:space="preserve">
          <source>Merge tracking</source>
          <target state="translated">合并跟踪</target>
        </trans-unit>
        <trans-unit id="af8c9dbb2cf6a08b436fada56eb16ee91017d8ce" translate="yes" xml:space="preserve">
          <source>Merge workflow</source>
          <target state="translated">合并工作流程</target>
        </trans-unit>
        <trans-unit id="01d28a50eda177ec75942bb24c131250cdadabfb" translate="yes" xml:space="preserve">
          <source>Merges</source>
          <target state="translated">Merges</target>
        </trans-unit>
        <trans-unit id="c4dada76f0f6e7dcbd827c4ba6bada46b3c6714c" translate="yes" xml:space="preserve">
          <source>Merges (to be discussed later), as well as operations such as &lt;code&gt;git reset&lt;/code&gt;, which change the currently checked-out commit, generally set ORIG_HEAD to the value HEAD had before the current operation.</source>
          <target state="translated">合并（稍后讨论）以及诸如 &lt;code&gt;git reset&lt;/code&gt; 之类的操作（这些操作会更改当前已签出的提交），通常会将ORIG_HEAD设置为当前操作之前HEAD的值。</target>
        </trans-unit>
        <trans-unit id="376269fe69e269c1639bc7c223893145d88653cf" translate="yes" xml:space="preserve">
          <source>Merges are always included. However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves. This results in</source>
          <target state="translated">合并总是包括在内。但是,它们的父列表会被重写。沿着每个父级列表,修剪掉那些自己不包含的提交。这将导致</target>
        </trans-unit>
        <trans-unit id="6da92828bff93237c525d505f61963005fa8aa9b" translate="yes" xml:space="preserve">
          <source>Merges can be also made simpler by using smaller branches or by using many topic branches instead of only long version related branches.</source>
          <target state="translated">合并也可以通过使用更小的分支或使用许多主题分支而不是只使用长的版本相关分支来简化。</target>
        </trans-unit>
        <trans-unit id="18462046f484e3565df5821cdce8eadab95f1224" translate="yes" xml:space="preserve">
          <source>Merges have many advantages, so we try to solve as many problems as possible with merges alone. Cherry-picking is still occasionally useful; see &quot;Merging upwards&quot; below for an example.</source>
          <target state="translated">合并有很多优点,所以我们尽量只用合并来解决问题。挑剔偶尔还是有用的,请看下面 &quot;向上合并 &quot;的例子。</target>
        </trans-unit>
        <trans-unit id="40de0d4de887a374168bf79e72c7aa0fa4594d6e" translate="yes" xml:space="preserve">
          <source>Merging</source>
          <target state="translated">Merging</target>
        </trans-unit>
        <trans-unit id="31c92682cbfd6598c97a2306d8a83a0e953592eb" translate="yes" xml:space="preserve">
          <source>Merging and rebasing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2204607f23628214b6d42add29d21c7f2e29b95" translate="yes" xml:space="preserve">
          <source>Merging branches with differing checkin/checkout attributes</source>
          <target state="translated">合并具有不同签入/签出属性的分支。</target>
        </trans-unit>
        <trans-unit id="c535f2db054f922c7b696495f8b89a913e2a11c4" translate="yes" xml:space="preserve">
          <source>Merging external work</source>
          <target state="translated">合并外部工作</target>
        </trans-unit>
        <trans-unit id="603157d894d36cb77fbe21d75b0d20a12dc01779" translate="yes" xml:space="preserve">
          <source>Merging inside a &lt;a href=&quot;#def_shallow_clone&quot;&gt;shallow clone&lt;/a&gt; will work as long as a merge base is in the recent history. Otherwise, it will be like merging unrelated histories and may have to result in huge conflicts. This limitation may make such a repository unsuitable to be used in merge based workflows.</source>
          <target state="translated">一个内部合并&lt;a href=&quot;#def_shallow_clone&quot;&gt;浅克隆&lt;/a&gt;将工作只要合并基础是在最近的历史。否则，这就像合并无关的历史记录一样，可能会导致巨大的冲突。此限制可能使这样的存储库不适合在基于合并的工作流中使用。</target>
        </trans-unit>
        <trans-unit id="ab26fbd41a8ed9c39ebd7d129433578a03343e81" translate="yes" xml:space="preserve">
          <source>Merging multiple trees</source>
          <target state="translated">合并多棵树</target>
        </trans-unit>
        <trans-unit id="f73ac93115d3cdadc50aebe7fa9b08f89899740b" translate="yes" xml:space="preserve">
          <source>Merging multiple trees, continued</source>
          <target state="translated">合并多棵树,继续</target>
        </trans-unit>
        <trans-unit id="98b404243306169adb88696dc4ad2165a137c1ac" translate="yes" xml:space="preserve">
          <source>Merging tag</source>
          <target state="translated">合并标签</target>
        </trans-unit>
        <trans-unit id="1af53d3a2af732fec14191525698059a5e40b8d4" translate="yes" xml:space="preserve">
          <source>Merging two branches</source>
          <target state="translated">合并两个分支</target>
        </trans-unit>
        <trans-unit id="6153c9c2afc2b444427af54ff710f1f84e9dda45" translate="yes" xml:space="preserve">
          <source>Merging upwards</source>
          <target state="translated">向上合并</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="ede02150d3611f561b342e50cd978f7d1c7b1d2a" translate="yes" xml:space="preserve">
          <source>Miscellaneous capabilities</source>
          <target state="translated">杂项能力</target>
        </trans-unit>
        <trans-unit id="5b0739f48e82ea34788c95cbd8a03adab72795db" translate="yes" xml:space="preserve">
          <source>Miscellaneous differences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e2e957e53389b060cb16e85d086c46b6c88151" translate="yes" xml:space="preserve">
          <source>Missing From or In-Reply-To headers will be prompted for.</source>
          <target state="translated">遗漏的发件人或回信头将被提示。</target>
        </trans-unit>
        <trans-unit id="00b61542d0211972bc61982931e3e8c50577c383" translate="yes" xml:space="preserve">
          <source>Modified content is represented by &quot;-&quot; lines (removing the old content) followed by &quot;+&quot; lines (adding the replacement content). You can prevent staging the modification by converting &quot;-&quot; lines to &quot; &quot;, and removing &quot;+&quot; lines. Beware that modifying only half of the pair is likely to introduce confusing changes to the index.</source>
          <target state="translated">修改后的内容用&quot;-&quot;行表示(删除旧内容),后面用 &quot;+&quot;行表示(添加替换内容)。您可以通过将&quot;-&quot;行转换为&quot; &quot;,并删除 &quot;+&quot;行来防止分期修改。要注意的是,只修改一半的对子,很可能会给索引带来混乱的变化。</target>
        </trans-unit>
        <trans-unit id="6e5a153f7d9724480c99f8d43544411a606a03ba" translate="yes" xml:space="preserve">
          <source>Modifies the index or directory cache. Each file mentioned is updated into the index and any &lt;code&gt;unmerged&lt;/code&gt; or &lt;code&gt;needs updating&lt;/code&gt; state is cleared.</source>
          <target state="translated">修改索引或目录缓存。提到的每个文件都会更新到索引中，并且清除所有未 &lt;code&gt;unmerged&lt;/code&gt; 或 &lt;code&gt;needs updating&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="f87d4010c94238df04ebfd441b3a0111f33d7a25" translate="yes" xml:space="preserve">
          <source>Modify behavior of the next command naming a &amp;lt;ref&amp;gt;. The only valid option is &lt;code&gt;no-deref&lt;/code&gt; to avoid dereferencing a symbolic ref.</source>
          <target state="translated">修改下一个命名为&amp;lt;ref&amp;gt;的命令的行为。唯一有效的选项是 &lt;code&gt;no-deref&lt;/code&gt; ,以避免取消引用符号ref。</target>
        </trans-unit>
        <trans-unit id="eeb79095663bd56bf370bd2096cd4a5ecc99b3a1" translate="yes" xml:space="preserve">
          <source>Modify some files, then add their updated contents to the index:</source>
          <target state="translated">修改一些文件,然后将其更新的内容添加到索引中。</target>
        </trans-unit>
        <trans-unit id="19db1a3cc38a1c275e20ba3eb14f5761050f2bac" translate="yes" xml:space="preserve">
          <source>Modifying the index is easy:</source>
          <target state="translated">修改索引很容易。</target>
        </trans-unit>
        <trans-unit id="3d6095a82dcd262f6e6b119640e8d9b20bcf7da2" translate="yes" xml:space="preserve">
          <source>More detail on the following is available from the &lt;a href=&quot;user-manual#git-concepts&quot;&gt;Git concepts chapter of the user-manual&lt;/a&gt; and &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;user-manual#git-concepts&quot;&gt;用户手册&lt;/a&gt;和&lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt;的Git概念章节提供了有关以下内容的更多详细信息。</target>
        </trans-unit>
        <trans-unit id="06099ebf3c1fb2d228710b5b862871e1eab3c063" translate="yes" xml:space="preserve">
          <source>More generally, a branch that is created from a remote-tracking branch will pull by default from that branch. See the descriptions of the &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; options in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;, and the discussion of the &lt;code&gt;--track&lt;/code&gt; option in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, to learn how to control these defaults.</source>
          <target state="translated">更一般地，从远程跟踪分支创建的分支将默认从该分支中​​拉出。请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]中&lt;/a&gt; &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 和 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 选项的描述，以及&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;中有关 &lt;code&gt;--track&lt;/code&gt; 选项的讨论，以了解如何控制这些默认值。</target>
        </trans-unit>
        <trans-unit id="415ceff2cb011b2c5375c0d469dab2cba200eaed" translate="yes" xml:space="preserve">
          <source>More generally, among the two commits to compute the merge base from, one is specified by the first commit argument on the command line; the other commit is a (possibly hypothetical) commit that is a merge across all the remaining commits on the command line.</source>
          <target state="translated">一般来说,在计算合并基数的两个提交中,一个是由命令行上的第一个提交参数指定的;另一个提交是一个(可能是假设的)提交,是命令行上所有剩余提交的合并。</target>
        </trans-unit>
        <trans-unit id="816cda5b46035bd1542e1775969151ec4a09cada" translate="yes" xml:space="preserve">
          <source>More importantly, it allows the update of a ref file to follow these symbolic pointers, whether they are symlinks or these &quot;regular file symbolic refs&quot;. It follows &lt;strong&gt;real&lt;/strong&gt; symlinks only if they start with &quot;refs/&quot;: otherwise it will just try to read them and update them as a regular file (i.e. it will allow the filesystem to follow them, but will overwrite such a symlink to somewhere else with a regular filename).</source>
          <target state="translated">更重要的是，它允许更新引用文件以遵循这些符号指针，无论它们是符号链接还是这些&amp;ldquo;常规文件符号引用&amp;rdquo;。仅当它们以&amp;ldquo; refs /&amp;rdquo;开头时，它才遵循&lt;strong&gt;真实的&lt;/strong&gt;符号链接：否则，它将尝试读取它们并将其更新为常规文件（即，它将允许文件系统跟随它们，但是将此类符号链接覆盖为其他符号）常规文件名）。</target>
        </trans-unit>
        <trans-unit id="2be26ffe68463b96abc5601cef9bdbafbf2f631d" translate="yes" xml:space="preserve">
          <source>More interestingly, you can also give &lt;code&gt;git diff-tree&lt;/code&gt; the &lt;code&gt;--pretty&lt;/code&gt; flag, which tells it to also show the commit message and author and date of the commit, and you can tell it to show a whole series of diffs. Alternatively, you can tell it to be &quot;silent&quot;, and not show the diffs at all, but just show the actual commit message.</source>
          <target state="translated">更有趣的是，你也可以给 &lt;code&gt;git diff-tree&lt;/code&gt; 的 &lt;code&gt;--pretty&lt;/code&gt; 标志，告诉它也显示提交信息和作者的提交日期，你可以告诉它显示了一系列的diff的。另外，您可以说它是&amp;ldquo;无声的&amp;rdquo;，根本不显示差异，而仅显示实际的提交消息。</target>
        </trans-unit>
        <trans-unit id="854ef0fd2eba012b7c2e6ecb33388db153e60f9a" translate="yes" xml:space="preserve">
          <source>More on recovery from repository corruption. See: &lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&lt;/a&gt;&lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&lt;/a&gt;</source>
          <target state="translated">有关从存储库损坏中恢复的更多信息。参见：&lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&quot;&gt;https&lt;/a&gt; : //lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/ &lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@ woody.linux-foundation.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1784c94f3b7a373b03c0ae45229574de43eee20" translate="yes" xml:space="preserve">
          <source>More precisely, &lt;code&gt;git pull&lt;/code&gt; runs &lt;code&gt;git fetch&lt;/code&gt; with the given parameters and calls &lt;code&gt;git merge&lt;/code&gt; to merge the retrieved branch heads into the current branch. With &lt;code&gt;--rebase&lt;/code&gt;, it runs &lt;code&gt;git rebase&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">更精确地讲， &lt;code&gt;git pull&lt;/code&gt; 使用给定的参数运行 &lt;code&gt;git fetch&lt;/code&gt; ，并调用 &lt;code&gt;git merge&lt;/code&gt; 将检索到的分支头合并到当前分支中。使用 &lt;code&gt;--rebase&lt;/code&gt; ，它将运行 &lt;code&gt;git rebase&lt;/code&gt; 而不是 &lt;code&gt;git merge&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17f51f170751975b2cc4764665c6e712fb67447f" translate="yes" xml:space="preserve">
          <source>Most CVS command arguments that read CVS tags or revision numbers (typically -r) work, and also support any git refspec (tag, branch, commit ID, etc). However, CVS revision numbers for non-default branches are not well emulated, and cvs log does not show tags or branches at all. (Non-main-branch CVS revision numbers superficially resemble CVS revision numbers, but they actually encode a git commit ID directly, rather than represent the number of revisions since the branch point.)</source>
          <target state="translated">大多数读取 CVS 标签或版本号的 CVS 命令参数(通常是 -r)都可以使用,并且也支持任何 git refspec(标签、分支、提交 ID 等)。然而,非默认分支的 CVS 版本号并不能很好地模拟,cvs 日志根本不显示标签或分支。(非主分支的CVS修订号表面上和CVS修订号很像,但实际上是直接编码一个git提交ID,而不是代表自分支点以来的修订次数。)</target>
        </trans-unit>
        <trans-unit id="880f481ef12ec663b5ff4186eb50766022add75f" translate="yes" xml:space="preserve">
          <source>Most bottlenecks appear to be in foreign source data access (the source just cannot extract revisions fast enough) or disk IO (fast-import writes as fast as the disk will take the data). Imports will run faster if the source data is stored on a different drive than the destination Git repository (due to less IO contention).</source>
          <target state="translated">大多数瓶颈似乎是在国外的源数据访问(源数据不能足够快地提取修订版)或磁盘IO(快速导入写入的速度与磁盘接收数据的速度一样快)。如果源数据存储在与目标 Git 仓库不同的硬盘上,导入速度会更快(因为 IO 争用较少)。</target>
        </trans-unit>
        <trans-unit id="b1a743b45e6efbd5b49b8c3c8d73ad9b477276e1" translate="yes" xml:space="preserve">
          <source>Most commits have only one parent, but it is also common for a commit to have multiple parents. In that case the commit represents a merge, with the parent references pointing to the heads of the merged branches.</source>
          <target state="translated">大多数提交只有一个父节点,但一个提交有多个父节点的情况也很常见。在这种情况下,提交代表了一个合并,父级引用指向合并后的分支的头。</target>
        </trans-unit>
        <trans-unit id="6e0466db6c595523512aab889a71c0ecc693c19a" translate="yes" xml:space="preserve">
          <source>Most hosting providers use a single SSH account for pushing; that is, all users push to the &lt;code&gt;git&lt;/code&gt; account (e.g., &lt;code&gt;git@git.example.org&lt;/code&gt;). If that&amp;rsquo;s the case for your provider, you can set up multiple aliases in SSH to make it clear which key pair to use. For example, you could write something like the following in &lt;code&gt;~/.ssh/config&lt;/code&gt;, substituting the proper private key file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d50eced4caaa6d0cca3ee6a1e2e2e07d0d5849b" translate="yes" xml:space="preserve">
          <source>Most importantly, merging works at the branch level, while cherry-picking works at the commit level. This means that a merge can carry over the changes from 1, 10, or 1000 commits with equal ease, which in turn means the workflow scales much better to a large number of contributors (and contributions). Merges are also easier to understand because a merge commit is a &quot;promise&quot; that all changes from all its parents are now included.</source>
          <target state="translated">最重要的是,合并工作在分支级别,而摘取工作在提交级别。这意味着,合并可以同样轻松地将1个、10个或1000个提交中的变更带入,这反过来又意味着工作流可以更好地扩展到大量的贡献者(和贡献)。合并也更容易理解,因为一个合并提交是一个 &quot;承诺&quot;,即所有来自其父提交的修改现在都被包含在内。</target>
        </trans-unit>
        <trans-unit id="2e130c2e2dd2a16594642aa625e1fc3c4df26608" translate="yes" xml:space="preserve">
          <source>Most of features are configured via &lt;code&gt;%feature&lt;/code&gt; hash; however some of extra gitweb features can be turned on and configured using variables described below. This list beside configuration variables that control how gitweb looks does contain variables configuring administrative side of gitweb (e.g. cross-site scripting prevention; admittedly this as side effect affects how &quot;summary&quot; pages look like, or load limiting).</source>
          <target state="translated">大多数功能都是通过 &lt;code&gt;%feature&lt;/code&gt; 哈希配置的；但是，某些额外的gitweb功能可以使用以下所述的变量打开和配置。控制gitweb外观的配置变量旁边的列表确实包含配置gitweb的管理方面的变量（例如，跨站点脚本防护；不可否认，这是因为副作用会影响&amp;ldquo;摘要&amp;rdquo;页面的外观或负载限制）。</target>
        </trans-unit>
        <trans-unit id="12c479c9b5f1b05779ca1427f8469c4d0c8e41b4" translate="yes" xml:space="preserve">
          <source>Most of what &lt;code&gt;git rev-list&lt;/code&gt; did is contained in &lt;code&gt;revision.c&lt;/code&gt; and &lt;code&gt;revision.h&lt;/code&gt;. It wraps the options in a struct named &lt;code&gt;rev_info&lt;/code&gt;, which controls how and what revisions are walked, and more.</source>
          <target state="translated">&lt;code&gt;git rev-list&lt;/code&gt; 所做的大部分工作都包含在 &lt;code&gt;revision.c&lt;/code&gt; 和 &lt;code&gt;revision.h&lt;/code&gt; 。它将选项包装在名为 &lt;code&gt;rev_info&lt;/code&gt; 的结构中，该结构控制如何以及如何修改修订内容，等等。</target>
        </trans-unit>
        <trans-unit id="9ceb817bd0e340cfd6e3a665612ec974c7873cd6" translate="yes" xml:space="preserve">
          <source>Most operations that add an object to the database update the modification time of the object if it is already present so that #1 applies.</source>
          <target state="translated">大多数在数据库中添加对象的操作都会更新对象的修改时间,如果对象已经存在,那么#1就适用。</target>
        </trans-unit>
        <trans-unit id="ed4a3f36c4746567049b5d83d49f91438e7cd1fa" translate="yes" xml:space="preserve">
          <source>Most projects also use &lt;a href=&quot;#def_tag&quot;&gt;tags&lt;/a&gt;. Tags, like heads, are references into the project&amp;rsquo;s history, and can be listed using the &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; command:</source>
          <target state="translated">大多数项目还使用&lt;a href=&quot;#def_tag&quot;&gt;标签&lt;/a&gt;。标签（如heads）是对项目历史的引用，可以使用&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;命令列出：</target>
        </trans-unit>
        <trans-unit id="6e9a1bc6364ad2c889e7f09c69628c8251c67662" translate="yes" xml:space="preserve">
          <source>Most projects with multiple contributors (such as the Linux kernel, or Git itself) have frequent merges, and &lt;code&gt;gitk&lt;/code&gt; does a better job of visualizing their history. For example,</source>
          <target state="translated">大多数具有多个贡献者的项目（例如Linux内核或Git本身）都有频繁的合并，而 &lt;code&gt;gitk&lt;/code&gt; 在可视化其历史方面做得更好。例如，</target>
        </trans-unit>
        <trans-unit id="b110af03cd46bd74e1684a2cb53fb12fe52de561" translate="yes" xml:space="preserve">
          <source>Mostly a synonym to &lt;a href=&quot;#def_shallow_repository&quot;&gt;shallow repository&lt;/a&gt; but the phrase makes it more explicit that it was created by running &lt;code&gt;git clone --depth=&amp;hellip;​&lt;/code&gt; command.</source>
          <target state="translated">大多的代名词，以&lt;a href=&quot;#def_shallow_repository&quot;&gt;浅资源库&lt;/a&gt;，但那句使得它更加明确，它是由运行时创建 &lt;code&gt;git clone --depth=&amp;hellip;​&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="0a0252ca3dca0dd6561eccb6a1ba0495bf433801" translate="yes" xml:space="preserve">
          <source>Mostly a synonym to &lt;a href=&quot;#def_shallow_repository&quot;&gt;shallow repository&lt;/a&gt; but the phrase makes it more explicit that it was created by running &lt;code&gt;git clone --depth=...&lt;/code&gt; command.</source>
          <target state="translated">通常是&lt;a href=&quot;#def_shallow_repository&quot;&gt;浅层存储库&lt;/a&gt;的同义词，但该短语使它更明确地表明它是通过运行 &lt;code&gt;git clone --depth=...&lt;/code&gt; 命令创建的。</target>
        </trans-unit>
        <trans-unit id="3a5117e8beb61f9ec394ef9854333d01751bcf99" translate="yes" xml:space="preserve">
          <source>Mounting one repository inside another</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfd3ade6b1a6694324bf4f4adc30f26dd2cc430" translate="yes" xml:space="preserve">
          <source>Move a working tree to a new location. Note that the main working tree or linked working trees containing submodules cannot be moved with this command. (The &lt;code&gt;git worktree repair&lt;/code&gt; command, however, can reestablish the connection with linked working trees if you move the main working tree manually.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437db9b7f03fcf9c59c19e8599b81a4181786550" translate="yes" xml:space="preserve">
          <source>Move a working tree to a new location. Note that the main working tree or linked working trees containing submodules cannot be moved.</source>
          <target state="translated">将工作树移动到新的位置。注意,主工作树或包含子模块的链接工作树不能移动。</target>
        </trans-unit>
        <trans-unit id="00451deb449902283a1a1b09ee616f563047050b" translate="yes" xml:space="preserve">
          <source>Move objects and refs by archive</source>
          <target state="translated">按档案移动对象和参考资料</target>
        </trans-unit>
        <trans-unit id="0a2aa584391bc2ed097c1ace071233493faa0978" translate="yes" xml:space="preserve">
          <source>Move or rename a file, a directory, or a symlink</source>
          <target state="translated">移动或重命名一个文件、一个目录或一个符号链接。</target>
        </trans-unit>
        <trans-unit id="4bc0abe3ae87a3007e76abb67d150957939b61b8" translate="yes" xml:space="preserve">
          <source>Move or rename a file, directory or symlink.</source>
          <target state="translated">移动或重命名一个文件、目录或符号链接。</target>
        </trans-unit>
        <trans-unit id="24cb8f062e449dc4167b50460e2e7341fe4e0aa6" translate="yes" xml:space="preserve">
          <source>Move/rename a branch and the corresponding reflog.</source>
          <target state="translated">移动/重命名一个分支和相应的重新记录。</target>
        </trans-unit>
        <trans-unit id="86a2fcc8fa8d4ad8c3c46b9d3e5182feb14f1b60" translate="yes" xml:space="preserve">
          <source>Moved lines are not highlighted.</source>
          <target state="translated">被移动的线条不会被高亮显示。</target>
        </trans-unit>
        <trans-unit id="e5cbd47a10df638d21a9258d79ed6bd371f01027" translate="yes" xml:space="preserve">
          <source>Moved lines of code are colored differently. It can be changed by the &lt;code&gt;diff.colorMoved&lt;/code&gt; configuration setting. The &amp;lt;mode&amp;gt; defaults to &lt;code&gt;no&lt;/code&gt; if the option is not given and to &lt;code&gt;zebra&lt;/code&gt; if the option with no mode is given. The mode must be one of:</source>
          <target state="translated">移动的代码行的颜色不同。可以通过 &lt;code&gt;diff.colorMoved&lt;/code&gt; 配置设置进行更改。如果没有给出选项，&amp;lt;mode&amp;gt;默认为 &lt;code&gt;no&lt;/code&gt; ,如果没有给出选项，则默认为 &lt;code&gt;zebra&lt;/code&gt; 。该模式必须是以下之一：</target>
        </trans-unit>
        <trans-unit id="b99084289befcccb3b6f25bb5a902159aaa2283b" translate="yes" xml:space="preserve">
          <source>Moved lines of code are colored differently. The &amp;lt;mode&amp;gt; defaults to &lt;code&gt;no&lt;/code&gt; if the option is not given and to &lt;code&gt;zebra&lt;/code&gt; if the option with no mode is given. The mode must be one of:</source>
          <target state="translated">移动的代码行的颜色不同。如果没有给出选项，&amp;lt;mode&amp;gt;默认为 &lt;code&gt;no&lt;/code&gt; ,如果没有给出选项，则默认为 &lt;code&gt;zebra&lt;/code&gt; 。该模式必须是以下之一：</target>
        </trans-unit>
        <trans-unit id="b9c1e9c13eb039f68657e5a15bbd12085ba143c2" translate="yes" xml:space="preserve">
          <source>Moving a submodule using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will update the gitfile and core.worktree setting to make the submodule work in the new location. It also will attempt to update the submodule.&amp;lt;name&amp;gt;.path setting in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file and stage that file (unless -n is used).</source>
          <target state="translated">使用gitfile移动子模块（这意味着它们已使用1.7.8或更高版本的Git版本克隆）将更新gitfile和core.worktree设置，以使子模块在新位置工作。它还将尝试更新&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;文件中的submodule。&amp;lt;name&amp;gt; .path设置并暂存该文件（除非使用-n）。</target>
        </trans-unit>
        <trans-unit id="64f4589d8b3cd6346365a117e7caa3c7d877c770" translate="yes" xml:space="preserve">
          <source>Mua-specific hints</source>
          <target state="translated">Mua专用提示</target>
        </trans-unit>
        <trans-unit id="c811c6583f834ffbc46d39586b81b1cb3e49b3e5" translate="yes" xml:space="preserve">
          <source>Multi-pack-index (midx) files have the following format:</source>
          <target state="translated">多包索引(midx)文件的格式如下:</target>
        </trans-unit>
        <trans-unit id="53148ea4bd03c54715064a8f67e0cc8cc140f85c" translate="yes" xml:space="preserve">
          <source>Multiple --notes options can be combined to control which notes are being displayed. Examples: &quot;--notes=foo&quot; will show only notes from &quot;refs/notes/foo&quot;; &quot;--notes=foo --notes&quot; will show both notes from &quot;refs/notes/foo&quot; and from the default notes ref(s).</source>
          <target state="translated">可以结合多个---笔记选项来控制显示哪些笔记。例如:&quot;--notes=foo &quot;将只显示 &quot;refs/notes/foo &quot;的笔记;&quot;--notes=foo --notes &quot;将只显示 &quot;refs/notes/foo &quot;的笔记。&quot;--notes=foo &quot;将只显示 &quot;refs/notes/foo &quot;中的笔记;&quot;--notes=foo --notes &quot;将同时显示 &quot;refs/notes/foo &quot;中的笔记和默认的笔记参考资料。</target>
        </trans-unit>
        <trans-unit id="63667e9cd419f9751274dd2f16bda1512b373262" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;--filter=&lt;/code&gt; flags can be specified to combine filters. Only objects which are accepted by every filter are included.</source>
          <target state="translated">可以指定多个 &lt;code&gt;--filter=&lt;/code&gt; 标志来组合过滤器。仅包括每个过滤器都接受的对象。</target>
        </trans-unit>
        <trans-unit id="dc96f8ef1ccc109ff4dae28503fa1d96c62fb1de" translate="yes" xml:space="preserve">
          <source>Multiple checkout in general is still experimental, and the support for submodules is incomplete. It is NOT recommended to make multiple checkouts of a superproject.</source>
          <target state="translated">多重签出一般来说还是实验性的,对子模块的支持还不完整。不建议对一个超级项目进行多次签出。</target>
        </trans-unit>
        <trans-unit id="5a07b93df04fb253e2e899a192e36f3454a882cd" translate="yes" xml:space="preserve">
          <source>Multiple fetch, branches, and tags keys are supported:</source>
          <target state="translated">支持多个取值、分支和标签键。</target>
        </trans-unit>
        <trans-unit id="279d7da4653c2486ef148e9e285812a9ab391b1e" translate="yes" xml:space="preserve">
          <source>Multiple lines can be added to an option by using the &lt;code&gt;--add&lt;/code&gt; option. If you want to update or unset an option which can occur on multiple lines, a &lt;code&gt;value-pattern&lt;/code&gt; (which is an extended regular expression, unless the &lt;code&gt;--fixed-value&lt;/code&gt; option is given) needs to be given. Only the existing values that match the pattern are updated or unset. If you want to handle the lines that do &lt;strong&gt;not&lt;/strong&gt; match the pattern, just prepend a single exclamation mark in front (see also &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt;), but note that this only works when the &lt;code&gt;--fixed-value&lt;/code&gt; option is not in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46275ca6ba0af124488d22d1e877279bfe2e6c0" translate="yes" xml:space="preserve">
          <source>Multiple lines can be added to an option by using the &lt;code&gt;--add&lt;/code&gt; option. If you want to update or unset an option which can occur on multiple lines, a POSIX regexp &lt;code&gt;value_regex&lt;/code&gt; needs to be given. Only the existing values that match the regexp are updated or unset. If you want to handle the lines that do &lt;strong&gt;not&lt;/strong&gt; match the regex, just prepend a single exclamation mark in front (see also &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt;).</source>
          <target state="translated">可以使用 &lt;code&gt;--add&lt;/code&gt; 选项将多行添加到一个选项。如果要更新或取消设置可能在多行上出现的选项，则需要提供POSIX regexp &lt;code&gt;value_regex&lt;/code&gt; 。仅与regexp匹配的现有值会被更新或未设置。如果要处理与正则表达式&lt;strong&gt;不&lt;/strong&gt;匹配的行，只需在前面加上一个感叹号即可（另请参见&lt;a href=&quot;#EXAMPLES&quot;&gt;示例&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="77c43675935243a813626f8da7cb046544167112" translate="yes" xml:space="preserve">
          <source>Multiple tags on the same revision are not imported.</source>
          <target state="translated">同一版本上的多个标签不会被导入。</target>
        </trans-unit>
        <trans-unit id="f2beb5df6d3d8f2a372e3411ba76c2a81700ed4b" translate="yes" xml:space="preserve">
          <source>Multiple values may be given to the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable. Their corresponding programs will be tried in the order listed in the configuration file.</source>
          <target state="translated">可以为 &lt;code&gt;man.viewer&lt;/code&gt; 配置变量提供多个值。将按照配置文件中列出的顺序尝试使用它们相应的程序。</target>
        </trans-unit>
        <trans-unit id="ee6ae3f9558f190018d900b972ec0dd86c3ef0ee" translate="yes" xml:space="preserve">
          <source>Munging the diff output</source>
          <target state="translated">芒格差分输出</target>
        </trans-unit>
        <trans-unit id="31284f7dc1d9489b6ba33462518d05bce29455ee" translate="yes" xml:space="preserve">
          <source>Must be a blob id</source>
          <target state="translated">一定是个blob id</target>
        </trans-unit>
        <trans-unit id="bab4c6d734b3b13c2268e7fc81c79c9b99eef1dd" translate="yes" xml:space="preserve">
          <source>NORMAL Format</source>
          <target state="translated">正常格式</target>
        </trans-unit>
        <trans-unit id="4b5d099fcd6efcc01a4251de7ab2ddb7c47dd96b" translate="yes" xml:space="preserve">
          <source>NOTE! &lt;code&gt;git checkout-index&lt;/code&gt; normally refuses to overwrite old files, so if you have an old version of the tree already checked out, you will need to use the &lt;code&gt;-f&lt;/code&gt; flag ('before' the &lt;code&gt;-a&lt;/code&gt; flag or the filename) to 'force' the checkout.</source>
          <target state="translated">注意！ &lt;code&gt;git checkout-index&lt;/code&gt; 通常拒绝覆盖旧文件，因此，如果您已经检出了旧版本的树，则需要使用 &lt;code&gt;-f&lt;/code&gt; 标志（在 &lt;code&gt;-a&lt;/code&gt; 标志或文件名之前）&amp;ldquo;强制&amp;rdquo;结帐。</target>
        </trans-unit>
        <trans-unit id="85ffa1dd083241144d9fbe2b1d63ba53159cc3e5" translate="yes" xml:space="preserve">
          <source>NOTE! &lt;code&gt;git checkout-index&lt;/code&gt; normally refuses to overwrite old files, so if you have an old version of the tree already checked out, you will need to use the &lt;code&gt;-f&lt;/code&gt; flag (&lt;code&gt;before&lt;/code&gt; the &lt;code&gt;-a&lt;/code&gt; flag or the filename) to &lt;code&gt;force&lt;/code&gt; the checkout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1264e842b1d5e884b1bcd9c56e546555c80966fe" translate="yes" xml:space="preserve">
          <source>NOTE! A &lt;code&gt;--remove&lt;/code&gt; flag does 'not' mean that subsequent filenames will necessarily be removed: if the files still exist in your directory structure, the index will be updated with their new status, not removed. The only thing &lt;code&gt;--remove&lt;/code&gt; means is that update-index will be considering a removed file to be a valid thing, and if the file really does not exist any more, it will update the index accordingly.</source>
          <target state="translated">注意！一个 &lt;code&gt;--remove&lt;/code&gt; 标志是&amp;ldquo;不&amp;rdquo;意味着后续的文件名一定会被删除：如果文件仍然在你的目录结构中存在该指数将与他们的新身份，不会被删除更新。 &lt;code&gt;--remove&lt;/code&gt; 唯一的意思是，update-index将认为已删除的文件是有效的东西，如果该文件确实不存在，它将相应地更新索引。</target>
        </trans-unit>
        <trans-unit id="14b973ba3566912be86ce74a38691b683bb1cd64" translate="yes" xml:space="preserve">
          <source>NOTE! A &lt;code&gt;--remove&lt;/code&gt; flag does &lt;code&gt;not&lt;/code&gt; mean that subsequent filenames will necessarily be removed: if the files still exist in your directory structure, the index will be updated with their new status, not removed. The only thing &lt;code&gt;--remove&lt;/code&gt; means is that update-index will be considering a removed file to be a valid thing, and if the file really does not exist any more, it will update the index accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="cab1b18ac6c645752b07db74b58a821d43db7033" translate="yes" xml:space="preserve">
          <source>Name for the new branch.</source>
          <target state="translated">新分支机构的名称:</target>
        </trans-unit>
        <trans-unit id="ae3aefe579fe0e7749a842bc31610ab7a07dfe4c" translate="yes" xml:space="preserve">
          <source>Name of a HTML file which, if it exists, is included on the gitweb projects overview page (&quot;projects_list&quot; view). Relative to the directory containing the gitweb.cgi script. Default value can be adjusted during build time using &lt;code&gt;GITWEB_HOMETEXT&lt;/code&gt; variable. By default set to &lt;code&gt;indextext.html&lt;/code&gt;.</source>
          <target state="translated">HTML文件的名称（如果存在）包含在gitweb项目概述页面（&amp;ldquo; projects_list&amp;rdquo;视图）中。相对于包含gitweb.cgi脚本的目录。可以在构建期间使用 &lt;code&gt;GITWEB_HOMETEXT&lt;/code&gt; 变量调整默认值。默认情况下设置为 &lt;code&gt;indextext.html&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b26ce2bab88403572eb261078ddb7db93d3d704e" translate="yes" xml:space="preserve">
          <source>Name of a file with HTML to be included at the bottom of each page. Relative to the directory containing the &lt;code&gt;gitweb.cgi&lt;/code&gt; script. Can be set using &lt;code&gt;GITWEB_SITE_FOOTER&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">每页底部包含HTML的文件名。相对于包含 &lt;code&gt;gitweb.cgi&lt;/code&gt; 脚本的目录。可以在构建时使用 &lt;code&gt;GITWEB_SITE_FOOTER&lt;/code&gt; 进行设置。无默认值。</target>
        </trans-unit>
        <trans-unit id="cb37057e9d095a173db9c241ef8419b86a202d02" translate="yes" xml:space="preserve">
          <source>Name of a file with HTML to be included at the top of each page. Relative to the directory containing the &lt;code&gt;gitweb.cgi&lt;/code&gt; script. Can be set using &lt;code&gt;GITWEB_SITE_HEADER&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">每页顶部包含HTML的文件名。相对于包含 &lt;code&gt;gitweb.cgi&lt;/code&gt; 脚本的目录。可以在构建时使用 &lt;code&gt;GITWEB_SITE_HEADER&lt;/code&gt; 进行设置。无默认值。</target>
        </trans-unit>
        <trans-unit id="389075bf1328d95e30f257d38d278dd3a0c94121" translate="yes" xml:space="preserve">
          <source>Name of a plain text file listing projects, or a name of directory to be scanned for projects.</source>
          <target state="translated">列出项目的纯文本文件的名称,或要扫描项目的目录名称。</target>
        </trans-unit>
        <trans-unit id="c0afa4635407444ed041e335278cc30cd2a11b14" translate="yes" xml:space="preserve">
          <source>Name of the SSL backend to use (e.g. &quot;openssl&quot; or &quot;schannel&quot;). This option is ignored if cURL lacks support for choosing the SSL backend at runtime.</source>
          <target state="translated">要使用的SSL后端名称(例如 &quot;openssl &quot;或 &quot;schannel&quot;)。如果cURL不支持在运行时选择SSL后端,那么这个选项将被忽略。</target>
        </trans-unit>
        <trans-unit id="4d338fcbbcef71a5bde9a77e37abcbca835f1d4a" translate="yes" xml:space="preserve">
          <source>Name of the user running &lt;code&gt;git-cvsserver&lt;/code&gt;. If no name can be determined, the numeric uid is used.</source>
          <target state="translated">运行 &lt;code&gt;git-cvsserver&lt;/code&gt; 的用户名。如果无法确定名称，则使用数字uid。</target>
        </trans-unit>
        <trans-unit id="33a3a9f4baab999f10555d77c61fc17ad7a2e690" translate="yes" xml:space="preserve">
          <source>Name of your site or organization, to appear in page titles. Set it to something descriptive for clearer bookmarks etc. If this variable is not set or is, then gitweb uses the value of the &lt;code&gt;SERVER_NAME&lt;/code&gt;&lt;code&gt;CGI&lt;/code&gt; environment variable, setting site name to &quot;$SERVER_NAME Git&quot;, or &quot;Untitled Git&quot; if this variable is not set (e.g. if running gitweb as standalone script).</source>
          <target state="translated">您的网站或组织的名称，以显示在页面标题中。将其设置为描述性更强的书签等内容。如果未设置或未设置此变量，则gitweb使用 &lt;code&gt;SERVER_NAME&lt;/code&gt; &lt;code&gt;CGI&lt;/code&gt; 环境变量的值，将站点名称设置为&amp;ldquo; $ SERVER_NAME Git&amp;rdquo;，如果此变量为，则设置为&amp;ldquo; Untitled Git&amp;rdquo;未设置（例如，如果将gitweb作为独立脚本运行）。</target>
        </trans-unit>
        <trans-unit id="ac84f0f88b7824faf06c4b53397972bcd09b01be" translate="yes" xml:space="preserve">
          <source>Name output in &lt;code&gt;[PATCH n/m]&lt;/code&gt; format, even with a single patch.</source>
          <target state="translated">即使使用单个音色，也以 &lt;code&gt;[PATCH n/m]&lt;/code&gt; 格式输出名称。</target>
        </trans-unit>
        <trans-unit id="ffd008dca3705155e76303827e2a4d3059068c9a" translate="yes" xml:space="preserve">
          <source>Name output in &lt;code&gt;[PATCH]&lt;/code&gt; format.</source>
          <target state="translated">名称以 &lt;code&gt;[PATCH]&lt;/code&gt; 格式输出。</target>
        </trans-unit>
        <trans-unit id="fe45d9f50e3991235a5aaf79d20ba4e50638c193" translate="yes" xml:space="preserve">
          <source>Named file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 命名文件</target>
        </trans-unit>
        <trans-unit id="e694d096f60594b306ed977a1cb3bf7e40731642" translate="yes" xml:space="preserve">
          <source>Named file in &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 命名文件</target>
        </trans-unit>
        <trans-unit id="4d0059ee6bf7ca65460797daae6395c800b562c5" translate="yes" xml:space="preserve">
          <source>Named pointers called refs mark interesting points in history. A ref may contain the SHA-1 name of an object or the name of another ref. Refs with names beginning &lt;code&gt;ref/head/&lt;/code&gt; contain the SHA-1 name of the most recent commit (or &quot;head&quot;) of a branch under development. SHA-1 names of tags of interest are stored under &lt;code&gt;ref/tags/&lt;/code&gt;. A special ref named &lt;code&gt;HEAD&lt;/code&gt; contains the name of the currently checked-out branch.</source>
          <target state="translated">名为refs的命名指针标记了历史上的有趣点。一个引用可能包含一个对象的SHA-1名称或另一个引用的名称。名称以 &lt;code&gt;ref/head/&lt;/code&gt; 开头的引用包含正在开发的分支的最新提交（或&amp;ldquo; head&amp;rdquo;）的SHA-1名称。感兴趣的标签的SHA-1名称存储在 &lt;code&gt;ref/tags/&lt;/code&gt; 。名为 &lt;code&gt;HEAD&lt;/code&gt; 的特殊引用包含当前已签出分支的名称。</target>
        </trans-unit>
        <trans-unit id="afc8b12ea961269025f67734b3112ac3163fa044" translate="yes" xml:space="preserve">
          <source>Named remote in configuration file</source>
          <target state="translated">在配置文件中命名为远程</target>
        </trans-unit>
        <trans-unit id="60da66dd4d339a94ae12e8c7a620ab333cdfa554" translate="yes" xml:space="preserve">
          <source>Names a low-level merge driver to be used when performing an internal merge between common ancestors. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">命名在公共祖先之间执行内部合并时要使用的低级合并驱动程序。有关详细信息，请参见&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7238264e2238da432cea4cee3e4e4ec456281760" translate="yes" xml:space="preserve">
          <source>Naming branches, tags, and other references</source>
          <target state="translated">命名分支、标签和其他引用</target>
        </trans-unit>
        <trans-unit id="a8a795a40591e9038f52c089f34245ee06ab71bc" translate="yes" xml:space="preserve">
          <source>Naming commits</source>
          <target state="translated">命名承诺</target>
        </trans-unit>
        <trans-unit id="7b635b48de06412b114cd8e91f1912aac5470b03" translate="yes" xml:space="preserve">
          <source>Nearly proper rewriting of tag objects is supported. If the tag has a message attached, a new tag object will be created with the same message, author, and timestamp. If the tag has a signature attached, the signature will be stripped. It is by definition impossible to preserve signatures. The reason this is &quot;nearly&quot; proper, is because ideally if the tag did not change (points to the same object, has the same name, etc.) it should retain any signature. That is not the case, signatures will always be removed, buyer beware. There is also no support for changing the author or timestamp (or the tag message for that matter). Tags which point to other tags will be rewritten to point to the underlying commit.</source>
          <target state="translated">支持对标签对象进行近乎正确的重写,如果标签有消息,则会创建一个具有相同消息、作者和时间戳的新标签对象。如果标签附有消息,则会创建一个具有相同消息、作者和时间戳的新标签对象。如果标签附加了签名,则签名将被删除。根据定义,保存签名是不可能的。这样做 &quot;几乎 &quot;是正确的,因为在理想情况下,如果标签没有改变(指向相同的对象,具有相同的名称等),它应该保留任何签名。事实并非如此,签名总是会被删除,买家要小心。也不支持更改作者或时间戳(或标签信息)。指向其他标签的标签将被重写为指向底层提交。</target>
        </trans-unit>
        <trans-unit id="ec8ce921b28e9d3cf6cf20eaf08287c17f378d35" translate="yes" xml:space="preserve">
          <source>Negating options</source>
          <target state="translated">否定选项</target>
        </trans-unit>
        <trans-unit id="781db1e57c260d141571a81cbcc3db723749ad7f" translate="yes" xml:space="preserve">
          <source>Nevertheless, the code at C is broken, because the callers added on the lower line of development have not been converted to the new semantics introduced on the upper line of development. So if all you know is that D is bad, that Z is good, and that &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; identifies C as the culprit, how will you figure out that the problem is due to this change in semantics?</source>
          <target state="translated">但是，C处的代码已损坏，因为在开发的下一行添加的调用者尚未转换为在开发的上一行引入的新语义。因此，如果您仅知道D是不好的，Z是好的，并且&lt;a href=&quot;git-bisect&quot;&gt;git-bisect [1]&lt;/a&gt;将C认定为罪魁祸首，那么您如何确定问题是由于语义上的这种变化引起的？</target>
        </trans-unit>
        <trans-unit id="a6160e254f396c410b853d5ee2bc722e35ccb61c" translate="yes" xml:space="preserve">
          <source>Nevertheless, this is a common practice for people that need a simple way to publish a work-in-progress patch series, and it is an acceptable compromise as long as you warn other developers that this is how you intend to manage the branch.</source>
          <target state="translated">尽管如此,这对于需要简单的方式来发布工作中的补丁系列的人来说,是一种常见的做法,只要你警告其他开发者这是你打算管理分支的方式,这就是一种可以接受的妥协。</target>
        </trans-unit>
        <trans-unit id="208a508aabbf19798034826f77ed481ec28e90cc" translate="yes" xml:space="preserve">
          <source>New features:</source>
          <target state="translated">新特点:</target>
        </trans-unit>
        <trans-unit id="c191eda851b2a021b1ece3943d51bb10c7c6e4eb" translate="yes" xml:space="preserve">
          <source>New marks are created automatically. Existing marks can be moved to another object simply by reusing the same &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; in another &lt;code&gt;mark&lt;/code&gt; command.</source>
          <target state="translated">新标记将自动创建。只需在另一个 &lt;code&gt;mark&lt;/code&gt; 命令中重用相同的 &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; ，就可以将现有标记移动到另一个对象。</target>
        </trans-unit>
        <trans-unit id="34f293962e034aa3adab30d6ce7bb006c129576e" translate="yes" xml:space="preserve">
          <source>New objects written by fast-import are not available immediately. Most fast-import commands have no visible effect until the next checkpoint (or completion). The frontend can send commands to fill fast-import&amp;rsquo;s input pipe without worrying about how quickly they will take effect, which improves performance by simplifying scheduling.</source>
          <target state="translated">快速导入写入的新对象无法立即使用。大多数快速导入命令在下一个检查点（或完成）之前没有可见效果。前端可以发送命令来填充快速导入的输入管道，而不必担心它们生效的速度，这可以通过简化调度来提高性能。</target>
        </trans-unit>
        <trans-unit id="bd5d84635e8045ac3e97cdc31b8e7c57fb2006ba" translate="yes" xml:space="preserve">
          <source>New remote-tracking branches will be stored under the shorthand name that you gave &lt;code&gt;git remote add&lt;/code&gt;, in this case &lt;code&gt;staging&lt;/code&gt;:</source>
          <target state="translated">新的远程跟踪分支将以您为 &lt;code&gt;git remote add&lt;/code&gt; 提供的简写名称存储，在这种情况下为 &lt;code&gt;staging&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="408210d4e2e7bc9a95a98e6b1bf8a3bd1ff14459" translate="yes" xml:space="preserve">
          <source>New users are encouraged to use &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; instead. The &lt;code&gt;whatchanged&lt;/code&gt; command is essentially the same as &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; but defaults to show the raw format diff output and to skip merges.</source>
          <target state="translated">鼓励新用户改用&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;。的 &lt;code&gt;whatchanged&lt;/code&gt; 命令是基本上相同&lt;a href=&quot;git-log&quot;&gt;的git日志[1]&lt;/a&gt;但缺省为显示原始格式diff的输出和跳过合并。</target>
        </trans-unit>
        <trans-unit id="04e09d741912def77b41c31c7fd7bada0af8f8f2" translate="yes" xml:space="preserve">
          <source>Newer &lt;code&gt;git diff&lt;/code&gt; output has embedded &lt;code&gt;index information&lt;/code&gt; for each blob to help identify the original version that the patch applies to. When this flag is given, and if the original versions of the blobs are available locally, builds a temporary index containing those blobs.</source>
          <target state="translated">较新的 &lt;code&gt;git diff&lt;/code&gt; 输出为每个Blob 嵌入了 &lt;code&gt;index information&lt;/code&gt; ，以帮助标识补丁程序适用的原始版本。给定此标志时，如果Blob的原始版本在本地可用，则构建一个包含这些Blob的临时索引。</target>
        </trans-unit>
        <trans-unit id="7f94af506f4cd517718453425d685ea35e84d4c7" translate="yes" xml:space="preserve">
          <source>Newly created objects are initially created in a file named after the object&amp;rsquo;s SHA-1 hash (stored in &lt;code&gt;.git/objects&lt;/code&gt;).</source>
          <target state="translated">新创建的对象最初是在以对象的SHA-1哈希命名的文件中创建的（存储在 &lt;code&gt;.git/objects&lt;/code&gt; 中）。</target>
        </trans-unit>
        <trans-unit id="5efdf7f0d1fca004c74269609acfa25723d86160" translate="yes" xml:space="preserve">
          <source>Next step: get familiar with the object naming. Read &lt;a href=&quot;#naming-commits&quot;&gt;Naming commits&lt;/a&gt;. There are quite a few ways to name an object (and not only revisions!). All of these are handled in &lt;code&gt;sha1_name.c&lt;/code&gt;. Just have a quick look at the function &lt;code&gt;get_sha1()&lt;/code&gt;. A lot of the special handling is done by functions like &lt;code&gt;get_sha1_basic()&lt;/code&gt; or the likes.</source>
          <target state="translated">下一步：熟悉对象命名。阅读&lt;a href=&quot;#naming-commits&quot;&gt;命名提交&lt;/a&gt;。有许多种命名对象的方法（不仅限于修订版！）。所有这些都在 &lt;code&gt;sha1_name.c&lt;/code&gt; 中处理。快速浏览一下函数 &lt;code&gt;get_sha1()&lt;/code&gt; 。许多特殊处理是由诸如 &lt;code&gt;get_sha1_basic()&lt;/code&gt; 之类的函数完成的。</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">今后的步骤</target>
        </trans-unit>
        <trans-unit id="817a91571b93a177740989ad9e63a1941cffb303" translate="yes" xml:space="preserve">
          <source>Next time, after seeing the same conflicted automerge, running &lt;code&gt;git rerere&lt;/code&gt; will perform a three-way merge between the earlier conflicted automerge, the earlier manual resolution, and the current conflicted automerge. If this three-way merge resolves cleanly, the result is written out to your working tree file, so you do not have to manually resolve it. Note that &lt;code&gt;git rerere&lt;/code&gt; leaves the index file alone, so you still need to do the final sanity checks with &lt;code&gt;git diff&lt;/code&gt; (or &lt;code&gt;git diff -c&lt;/code&gt;) and &lt;code&gt;git add&lt;/code&gt; when you are satisfied.</source>
          <target state="translated">下次，在看到相同的冲突自动合并后，运行 &lt;code&gt;git rerere&lt;/code&gt; 将在早期冲突的自动合并，早期手动解析和当前冲突的自动合并之间执行三向合并。如果此三向合并能够完全解决，则结果将写到您的工作树文件中，因此您不必手动解决它。请注意， &lt;code&gt;git rerere&lt;/code&gt; 仅保留索引文件，因此，当您满意时，仍然需要使用 &lt;code&gt;git diff&lt;/code&gt; （或 &lt;code&gt;git diff -c&lt;/code&gt; ）和 &lt;code&gt;git add&lt;/code&gt; 进行最终的健全性检查。</target>
        </trans-unit>
        <trans-unit id="74ccc5b41472ca3ff8486dd211ddfe0cae9246c3" translate="yes" xml:space="preserve">
          <source>Next, commit the changes stored in the index. The &lt;code&gt;-c&lt;/code&gt; option specifies to pre-populate the commit message from the original message that you started with in the first commit. This is helpful to avoid retyping it. The &lt;code&gt;HEAD@{1}&lt;/code&gt; is a special notation for the commit that &lt;code&gt;HEAD&lt;/code&gt; used to be at prior to the original reset commit (1 change ago). See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; for more details. You may also use any other valid commit reference.</source>
          <target state="translated">接下来，提交存储在索引中的更改。该 &lt;code&gt;-c&lt;/code&gt; 选项指定要预填充从你开始在第一次提交的原始邮件提交信息。这有助于避免重新键入。的 &lt;code&gt;HEAD@{1}&lt;/code&gt; 是一个特殊的符号为提交该 &lt;code&gt;HEAD&lt;/code&gt; 曾经是在之前的原始复位提交（1个改变前）。有关更多详细信息，请参见&lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt;。您还可以使用任何其他有效的提交引用。</target>
        </trans-unit>
        <trans-unit id="d481150e66b12915d203137377672c89781fe045" translate="yes" xml:space="preserve">
          <source>Next, copy &lt;code&gt;proj.git&lt;/code&gt; to the server where you plan to host the public repository. You can use scp, rsync, or whatever is most convenient.</source>
          <target state="translated">接下来，将 &lt;code&gt;proj.git&lt;/code&gt; 复制到计划承载公共存储库的服务器。您可以使用scp，rsync或任何最方便的方法。</target>
        </trans-unit>
        <trans-unit id="04e0b9feb1c4a494995ed09ad261d2d4e9ce11c5" translate="yes" xml:space="preserve">
          <source>Next, give every team member read/write access to this repository. One easy way to do this is to give all the team members ssh access to the machine where the repository is hosted. If you don&amp;rsquo;t want to give them a full shell on the machine, there is a restricted shell which only allows users to do Git pushes and pulls; see &lt;a href=&quot;git-shell&quot;&gt;git-shell[1]&lt;/a&gt;.</source>
          <target state="translated">接下来，授予每个团队成员对该存储库的读/写访问权限。一种简单的方法是使所有团队成员ssh都可以访问托管存储库的计算机。如果您不想在机器上给他们提供完整的外壳，则有一个受限制的外壳，该外壳仅允许用户执行Git推拉操作。参见&lt;a href=&quot;git-shell&quot;&gt;git-shell [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="28d55d870524553fca2220c18e5b9bb0de3dcbdb" translate="yes" xml:space="preserve">
          <source>Next, tell Git to take a snapshot of the contents of all files under the current directory (note the &lt;code&gt;.&lt;/code&gt;), with &lt;code&gt;git add&lt;/code&gt;:</source>
          <target state="translated">接下来，让Git采取的所有文件的内容的快照在当前目录下（注意 &lt;code&gt;.&lt;/code&gt; ），用 &lt;code&gt;git add&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="596419ac8ea3393898cb55dbbde5c3613a819bd1" translate="yes" xml:space="preserve">
          <source>Next, we interactively select diff hunks to add using the &lt;code&gt;git add -p&lt;/code&gt; facility. This will ask you about each diff hunk in sequence and you can use simple commands such as &quot;yes, include this&quot;, &quot;No don&amp;rsquo;t include this&quot; or even the very powerful &quot;edit&quot; facility.</source>
          <target state="translated">接下来，我们使用 &lt;code&gt;git add -p&lt;/code&gt; 工具以交互方式选择diff块。这将按顺序询问您每个差异块，您可以使用简单的命令，例如&amp;ldquo;是，包含此&amp;rdquo;，&amp;ldquo;否不包含此&amp;rdquo;或什至功能非常强大的&amp;ldquo;编辑&amp;rdquo;功能。</target>
        </trans-unit>
        <trans-unit id="8951da293ad0f99492d7f4956f721a58ac3b7ff1" translate="yes" xml:space="preserve">
          <source>No checkout of HEAD is performed after the clone is complete.</source>
          <target state="translated">克隆完成后不对HEAD进行检查。</target>
        </trans-unit>
        <trans-unit id="cfeba19b6e040607769791cbfbefd83c894b180c" translate="yes" xml:space="preserve">
          <source>No modifications to submodules are ignored, all of committed differences, and modifications to tracked and untracked files are shown. This is the default option.</source>
          <target state="translated">不忽略对子模块的修改,所有已提交的差异以及对已跟踪和未跟踪文件的修改都会被显示。这是默认选项。</target>
        </trans-unit>
        <trans-unit id="e2a67085604f2eb59fb72fa11fe30ca6d6e00a34" translate="yes" xml:space="preserve">
          <source>No other changes are made. In particular, the local modifications you had before you started merge will stay the same and the index entries for them stay as they were, i.e. matching &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">没有其他更改。特别是，在开始合并之前进行的本地修改将保持不变，并且它们的索引条目保持不变，即匹配 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de8a6fbc5b9c2db6f89c1e3ad733992686a5d62a" translate="yes" xml:space="preserve">
          <source>No other kinds of lines (e.g. empty lines or comment lines) are allowed in the file, even though some may be silently ignored. Do not view or edit the file with editors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c967d0b967e1e36091e8958a5454d9ea9951dded" translate="yes" xml:space="preserve">
          <source>No other modifications are made.</source>
          <target state="translated">不做其他修改。</target>
        </trans-unit>
        <trans-unit id="57658df76cf3f4fecaffea0a60cae0068e21e278" translate="yes" xml:space="preserve">
          <source>No patch introduces a regression: after applying any initial part of the series, the resulting project still compiles and works, and has no bugs that it didn&amp;rsquo;t have before.</source>
          <target state="translated">没有补丁会导致回归：应用了该系列的任何初始部分之后，生成的项目仍然可以编译和运行，并且没有以前没有的错误。</target>
        </trans-unit>
        <trans-unit id="0d39633312554b0ea8cb734d680c4698c57a7afd" translate="yes" xml:space="preserve">
          <source>No pattern matches the path, and nothing says if the path has or does not have the attribute, the attribute for the path is said to be Unspecified.</source>
          <target state="translated">没有模式与路径匹配,也没有说路径有无属性,说路径的属性是Unspecified。</target>
        </trans-unit>
        <trans-unit id="772b72b88edec66167df810a58edde895140fe67" translate="yes" xml:space="preserve">
          <source>No promises are made about the interface, or that this program won&amp;rsquo;t disappear without warning in the next version of Git. Don&amp;rsquo;t use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90ed1cbdf989952fffa921b682ee1beb354558a" translate="yes" xml:space="preserve">
          <source>No special setup is needed for SSH access, other than having Git tools in the PATH. If you have clients that do not accept the CVS_SERVER environment variable, you can rename &lt;code&gt;git-cvsserver&lt;/code&gt; to &lt;code&gt;cvs&lt;/code&gt;.</source>
          <target state="translated">除了PATH中具有Git工具外，不需要其他特殊设置即可进行SSH访问。如果您的客户端不接受CVS_SERVER环境变量，则可以将 &lt;code&gt;git-cvsserver&lt;/code&gt; 重命名为 &lt;code&gt;cvs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8302d8fa548b77adf094708d453bfd512d86a1e" translate="yes" xml:space="preserve">
          <source>No-op. Rebasing commits with an empty message used to fail and this option would override that behavior, allowing commits with empty messages to be rebased. Now commits with an empty message do not cause rebasing to halt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5febeaff9fb6579d7fb9744e50b3994bde6d8e3" translate="yes" xml:space="preserve">
          <source>Non-ascii filenames can be silently removed despite being in a desired directory. Keeping only wanted paths is often done using pipelines like &lt;code&gt;git ls-files | grep -v ^WANTED_DIR/ | xargs git rm&lt;/code&gt;. ls-files will only quote filenames if needed, so folks may not notice that one of the files didn&amp;rsquo;t match the regex (at least not until it&amp;rsquo;s much too late). Yes, someone who knows about core.quotePath can avoid this (unless they have other special characters like \t, \n, or &quot;), and people who use ls-files -z with something other than grep can avoid this, but that doesn&amp;rsquo;t mean they will.</source>
          <target state="translated">即使位于所需目录中，非ascii文件名也可以静默删除。通常只使用 &lt;code&gt;git ls-files | grep -v ^WANTED_DIR/ | xargs git rm&lt;/code&gt; 等管道来保留所需路径。 grep -v ^ WANTED_DIR / | xargs git rm。 ls文件仅在需要时才引用文件名，因此人们可能不会注意到其中一个文件与正则表达式不匹配（至少直到太晚才匹配）。是的，知道core.quotePath的人可以避免这种情况（除非他们有其他特殊字符，例如\ t，\ n或&amp;ldquo;），并且使用ls-files -z和grep以外的东西的人可以避免这种情况，但是那并不意味着他们会。</target>
        </trans-unit>
        <trans-unit id="e2858812ab58a3c85b7437528709a46037dcfba6" translate="yes" xml:space="preserve">
          <source>Non-cached mode</source>
          <target state="translated">非缓存模式</target>
        </trans-unit>
        <trans-unit id="28592521357265f4a182551c4308e7cea911b93e" translate="yes" xml:space="preserve">
          <source>Non-empty context lines that have one extra whitespace at the beginning.</source>
          <target state="translated">非空的上下文行,在开头有一个额外的空白。</target>
        </trans-unit>
        <trans-unit id="54b4652d3bd254c89ec712af1b81619180dc7f11" translate="yes" xml:space="preserve">
          <source>None of the provided paths are ignored.</source>
          <target state="translated">提供的路径都不会被忽略。</target>
        </trans-unit>
        <trans-unit id="53d641d85a09ede95cefeac02aadaca1a7fcd396" translate="yes" xml:space="preserve">
          <source>Normalize &lt;code&gt;refname&lt;/code&gt; by removing any leading slash (&lt;code&gt;/&lt;/code&gt;) characters and collapsing runs of adjacent slashes between name components into a single slash. If the normalized refname is valid then print it to standard output and exit with a status of 0, otherwise exit with a non-zero status. (&lt;code&gt;--print&lt;/code&gt; is a deprecated way to spell &lt;code&gt;--normalize&lt;/code&gt;.)</source>
          <target state="translated">通过删除任何前导斜杠（ &lt;code&gt;/&lt;/code&gt; ）字符并将名称组件之间的相邻斜杠折叠成单个斜杠来规范化 &lt;code&gt;refname&lt;/code&gt; 。如果标准化的refname有效，则将其打印到标准输出并以0状态退出，否则以非零状态退出。（ &lt;code&gt;--print&lt;/code&gt; 是拼写 &lt;code&gt;--normalize&lt;/code&gt; 的不赞成使用的方法。）</target>
        </trans-unit>
        <trans-unit id="cd7a46a34b030b4fa7a1f4c298bb470454f5bdc6" translate="yes" xml:space="preserve">
          <source>Normally &lt;code&gt;git write-tree&lt;/code&gt; ensures that the objects referenced by the directory exist in the object database. This option disables this check.</source>
          <target state="translated">通常， &lt;code&gt;git write-tree&lt;/code&gt; 确保目录引用的对象存在于对象数据库中。此选项禁用此检查。</target>
        </trans-unit>
        <trans-unit id="88fcf17b3fc3a47614adb1a8f9a3b0161d3a2185" translate="yes" xml:space="preserve">
          <source>Normally a &quot;commit&quot; has one parent: the previous state of the tree before a certain change was made. However, sometimes it can have two or more parent commits, in which case we call it a &quot;merge&quot;, due to the fact that such a commit brings together (&quot;merges&quot;) two or more previous states represented by other commits.</source>
          <target state="translated">通常,一个 &quot;提交 &quot;只有一个父提交:在做某项修改之前,树的前一个状态。然而,有时它可能有两个或更多的父提交,在这种情况下,我们称它为 &quot;合并&quot;,因为这种提交将两个或更多由其他提交代表的先前状态合并在一起(&quot;合并&quot;)。</target>
        </trans-unit>
        <trans-unit id="a69474e938cf33a616aeca615fe9997480c7c945" translate="yes" xml:space="preserve">
          <source>Normally a commit would identify a new &quot;HEAD&quot; state, and while Git doesn&amp;rsquo;t care where you save the note about that state, in practice we tend to just write the result to the file that is pointed at by &lt;code&gt;.git/HEAD&lt;/code&gt;, so that we can always see what the last committed state was.</source>
          <target state="translated">通常，一次提交会标识一个新的&amp;ldquo; HEAD&amp;rdquo;状态，尽管Git不在乎您保存该状态的注释的位置，但实际上，我们倾向于将结果 &lt;code&gt;.git/HEAD&lt;/code&gt; 指向的文件中，这样我们就可以始终看到最后一个提交状态。</target>
        </trans-unit>
        <trans-unit id="de60fcb388acbd1518bd224ad2216b3a990124fa" translate="yes" xml:space="preserve">
          <source>Normally batch output is flushed after each object is output, so that a process can interactively read and write from &lt;code&gt;cat-file&lt;/code&gt;. With this option, the output uses normal stdio buffering; this is much more efficient when invoking &lt;code&gt;--batch-check&lt;/code&gt; on a large number of objects.</source>
          <target state="translated">通常，在输出每个对象之后，将刷新批处理输出，以便进程可以从 &lt;code&gt;cat-file&lt;/code&gt; 交互式读取和写入。使用此选项时，输出使用普通的stdio缓冲。当对大量对象调用 &lt;code&gt;--batch-check&lt;/code&gt; 时，此方法效率更高。</target>
        </trans-unit>
        <trans-unit id="38e091b35be2fc0762233a3d599b506f3b643fb1" translate="yes" xml:space="preserve">
          <source>Normally commits are only added to a project, never taken away or replaced. Git is designed with this assumption, and violating it will cause Git&amp;rsquo;s merge machinery (for example) to do the wrong thing.</source>
          <target state="translated">通常，提交只会添加到项目中，而不会被删除或替换。Git是根据这种假设设计的，违反它会导致Git的合并机器（例如）做错事。</target>
        </trans-unit>
        <trans-unit id="9122c3565585fe79768943dc25f1cf167ffbd58d" translate="yes" xml:space="preserve">
          <source>Normally the &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; stores the name of a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;, and commands that operate on the history HEAD represents operate on the history leading to the tip of the branch the HEAD points at. However, Git also allows you to &lt;a href=&quot;#def_checkout&quot;&gt;check out&lt;/a&gt; an arbitrary &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; that isn&amp;rsquo;t necessarily the tip of any particular branch. The HEAD in such a state is called &quot;detached&quot;.</source>
          <target state="translated">通常，&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;存储&lt;a href=&quot;#def_branch&quot;&gt;分支&lt;/a&gt;的名称，并且在历史记录HEAD上执行的命令在指向HEAD所指向的分支尖端的历史记录上进行操作。但是，Git还允许您&lt;a href=&quot;#def_checkout&quot;&gt;检出&lt;/a&gt;不一定是任何特定分支提示的任意&lt;a href=&quot;#def_commit&quot;&gt;提交&lt;/a&gt;。处于这种状态的HEAD称为&amp;ldquo;分离&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cc5f74671cf296af564ff0627cbd1c153eed7819" translate="yes" xml:space="preserve">
          <source>Normally the branch merged in is the HEAD of the remote repository, but the choice is determined by the branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge options; see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">通常合并到的分支是远程存储库的HEAD，但是选择由分支决定。&amp;lt;name&amp;gt; .remote和branch。&amp;lt;name&amp;gt; .merge选项；有关详细信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f22467859cfedb6f904df5424dcd9afb82c226b1" translate="yes" xml:space="preserve">
          <source>Normally whenever a branch head in a public repository is modified, it is modified to point to a descendant of the commit that it pointed to before. By forcing a push in this situation, you break that convention. (See &lt;a href=&quot;#problems-With-rewriting-history&quot;&gt;Problems with rewriting history&lt;/a&gt;.)</source>
          <target state="translated">通常，只要修改了公共存储库中的分支头，便会对其进行修改以指向它之前指向的提交的后代。通过在这种情况下强行推动，您将打破惯例。（请参阅&lt;a href=&quot;#problems-With-rewriting-history&quot;&gt;重写历史记录中的问题&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="43244e83cbae6a59cf653d315de1a56015589247" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;git rerere&lt;/code&gt; is run without arguments or user-intervention. However, it has several commands that allow it to interact with its working state.</source>
          <target state="translated">通常， &lt;code&gt;git rerere&lt;/code&gt; 是在没有参数或用户干预的情况下运行的。但是，它有几个命令可以使其与其工作状态进行交互。</target>
        </trans-unit>
        <trans-unit id="d7d70adae9e248dcbf5927b7eeba22fdf79a73fb" translate="yes" xml:space="preserve">
          <source>Normally, only files unknown to Git are removed, but if the &lt;code&gt;-x&lt;/code&gt; option is specified, ignored files are also removed. This can, for example, be useful to remove all build products.</source>
          <target state="translated">通常，仅删除Git未知的文件，但是如果指定 &lt;code&gt;-x&lt;/code&gt; 选项，也会删除忽略的文件。例如，这对于删除所有构建产品很有用。</target>
        </trans-unit>
        <trans-unit id="ea1a90319260338e8b5ddefd985427f3690ce910" translate="yes" xml:space="preserve">
          <source>Normally, the &quot;git svn clone&quot; and &quot;git svn rebase&quot; commands attempt to recreate empty directories that are in the Subversion repository. If this option is set to &quot;false&quot;, then empty directories will only be created if the &quot;git svn mkdirs&quot; command is run explicitly. If unset, &lt;code&gt;git svn&lt;/code&gt; assumes this option to be &quot;true&quot;.</source>
          <target state="translated">通常，&amp;ldquo; git svn clone&amp;rdquo;和&amp;ldquo; git svn rebase&amp;rdquo;命令会尝试重新创建Subversion存储库中的空目录。如果此选项设置为&amp;ldquo; false&amp;rdquo;，则只有在显式运行&amp;ldquo; git svn mkdirs&amp;rdquo;命令时，才会创建空目录。如果未设置，则 &lt;code&gt;git svn&lt;/code&gt; 假定此选项为&amp;ldquo; true&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cbab35b86acdc7c387af4e06856d3dc90a27828f" translate="yes" xml:space="preserve">
          <source>Normally, the &quot;name&quot; field contains the canonical name of the command. When a canonical name is not available, one of these special values are used:</source>
          <target state="translated">通常,&quot;name &quot;字段包含命令的规范名称。如果没有正式名称,则使用下列特殊值之一:</target>
        </trans-unit>
        <trans-unit id="a72159c3df537e6c1eeaac201666cb67a55dea2c" translate="yes" xml:space="preserve">
          <source>Normally, the first commit in an SVN branch consists of a copy operation. &lt;code&gt;git svn&lt;/code&gt; will read this commit to get the SVN revision the branch was created from. It will then try to find the Git commit that corresponds to this SVN revision, and use that as the parent of the branch. However, it is possible that there is no suitable Git commit to serve as parent. This will happen, among other reasons, if the SVN branch is a copy of a revision that was not fetched by &lt;code&gt;git svn&lt;/code&gt; (e.g. because it is an old revision that was skipped with &lt;code&gt;--revision&lt;/code&gt;), or if in SVN a directory was copied that is not tracked by &lt;code&gt;git svn&lt;/code&gt; (such as a branch that is not tracked at all, or a subdirectory of a tracked branch). In these cases, &lt;code&gt;git svn&lt;/code&gt; will still create a Git branch, but instead of using an existing Git commit as the parent of the branch, it will read the SVN history of the directory the branch was copied from and create appropriate Git commits. This is indicated by the message &quot;Initializing parent: &amp;lt;branchname&amp;gt;&quot;.</source>
          <target state="translated">通常，SVN分支中的第一次提交由复制操作组成。 &lt;code&gt;git svn&lt;/code&gt; 将读取此提交以获取创建分支的SVN版本。然后它将尝试查找与该SVN修订版相对应的Git提交，并将其用作分支的父级。但是，可能没有合适的Git提交充当父项。除其他原因外，如果SVN分支是 &lt;code&gt;git svn&lt;/code&gt; 未获取的修订的副本（例如，因为它是使用 &lt;code&gt;--revision&lt;/code&gt; 跳过的旧修订），或者在SVN中复制了目录，则会发生这种情况 &lt;code&gt;git svn&lt;/code&gt; 不能跟踪的内容（例如完全不被跟踪的分支或被跟踪的分支的子目录）。在这种情况下， &lt;code&gt;git svn&lt;/code&gt; 仍会创建一个Git分支，但不会使用现有的Git提交作为该分支的父级，而是会读取复制该分支的目录的SVN历史记录并创建适当的Git提交。消息&amp;ldquo;正在初始化父项：&amp;lt;分支名称&amp;gt;&amp;rdquo;指示。</target>
        </trans-unit>
        <trans-unit id="4d54b3aadfbad6c493d83bcb2428d0cb9e46992e" translate="yes" xml:space="preserve">
          <source>Normally, when no &amp;lt;path&amp;gt; is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If any paths are specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions for nested git directories mentioned under &lt;code&gt;--force&lt;/code&gt;) will be removed.</source>
          <target state="translated">通常，如果未指定&amp;lt;path&amp;gt;，则git clean不会递归到未跟踪的目录中，以免删除过多。指定-d使其也递归到此类目录。如果指定了任何路径，则-d不相关；所有与指定路径匹配的未跟踪文件（ &lt;code&gt;--force&lt;/code&gt; 下提到的嵌套git目录除外）将被删除。</target>
        </trans-unit>
        <trans-unit id="429c7c6d611a6b06377c7694b2f456c87ba75047" translate="yes" xml:space="preserve">
          <source>Not all pattern types support patterns containing \0. Git will error out if a given pattern type can&amp;rsquo;t support such a pattern. The &lt;code&gt;--perl-regexp&lt;/code&gt; pattern type when compiled against the PCRE v2 backend has the widest support for these types of patterns.</source>
          <target state="translated">并非所有模式类型都支持包含\ 0的模式。如果给定的模式类型不支持这种模式，Git将会出错。当针对PCRE v2后端编译时，-- &lt;code&gt;--perl-regexp&lt;/code&gt; 模式类型对这些模式类型有最广泛的支持。</target>
        </trans-unit>
        <trans-unit id="fc85aa9ed9f2a57ce72e656178cf6fe66c794d02" translate="yes" xml:space="preserve">
          <source>Not all values are equally unambiguous:</source>
          <target state="translated">并非所有的价值都同样不含糊。</target>
        </trans-unit>
        <trans-unit id="8394b0fb9c23c1116919b0832addc200fe1387df" translate="yes" xml:space="preserve">
          <source>Not to worry. It left the (trivial) conflict in &lt;code&gt;hello&lt;/code&gt; in the same form you should already be well used to if you&amp;rsquo;ve ever used CVS, so let&amp;rsquo;s just open &lt;code&gt;hello&lt;/code&gt; in our editor (whatever that may be), and fix it up somehow. I&amp;rsquo;d suggest just making it so that &lt;code&gt;hello&lt;/code&gt; contains all four lines:</source>
          <target state="translated">不要担心。它以您已经习惯使用CVS的相同形式在 &lt;code&gt;hello&lt;/code&gt; 中留下了（琐碎的）冲突，因此，让我们在编辑器中打开 &lt;code&gt;hello&lt;/code&gt; （无论如何），然后以某种方式进行修复即可。我建议您这样做，以便 &lt;code&gt;hello&lt;/code&gt; 包含所有四行：</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="b7ed8e5f5bf09b0c843d3af582307ddfb588c4c6" translate="yes" xml:space="preserve">
          <source>Note about fast-forwards</source>
          <target state="translated">关于快进的说明</target>
        </trans-unit>
        <trans-unit id="318ccd302e94c5b26153ff4314826ba81af60a67" translate="yes" xml:space="preserve">
          <source>Note about git config --global</source>
          <target state="translated">关于git config --global的说明</target>
        </trans-unit>
        <trans-unit id="7da8f06b5e46e2bca162125caa0438ca1631ce6d" translate="yes" xml:space="preserve">
          <source>Note about git-config --global</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a858b9b8c7722185661603839f0881f8c7f88318" translate="yes" xml:space="preserve">
          <source>Note about konqueror</source>
          <target state="translated">征服者注意事项</target>
        </trans-unit>
        <trans-unit id="01b5dd07775875ee6aa9a8a3da76365c637f9b1a" translate="yes" xml:space="preserve">
          <source>Note also that multiple copies of an object may be present in the object database; in this case, it is undefined which copy&amp;rsquo;s size or delta base will be reported.</source>
          <target state="translated">还要注意，对象数据库中可能存在一个对象的多个副本。在这种情况下，将不确定将报告哪个副本的大小或增量基数。</target>
        </trans-unit>
        <trans-unit id="e92cbc9ca374ec932eab116752367c5739918c53" translate="yes" xml:space="preserve">
          <source>Note for Git users, that it is equivalent as keeping only the commit given by:</source>
          <target state="translated">请注意,对于 Git 用户来说,这相当于只保留了由以下公式给出的提交。</target>
        </trans-unit>
        <trans-unit id="9cd066f98a94620416bd40171030f2cd3deb4780" translate="yes" xml:space="preserve">
          <source>Note how the rule to only follow the TREESAME parent, if one is available, removed &lt;code&gt;B&lt;/code&gt; from consideration entirely. &lt;code&gt;C&lt;/code&gt; was considered via &lt;code&gt;N&lt;/code&gt;, but is TREESAME. Root commits are compared to an empty tree, so &lt;code&gt;I&lt;/code&gt; is !TREESAME.</source>
          <target state="translated">请注意如何仅遵循TREESAME父级的规则（如果有）将 &lt;code&gt;B&lt;/code&gt; 完全从考虑中删除。 &lt;code&gt;C&lt;/code&gt; 是通过 &lt;code&gt;N&lt;/code&gt; 考虑的，但它是TREESAME。将根提交与一棵空树进行比较，所以 &lt;code&gt;I&lt;/code&gt; 是！TREESAME。</target>
        </trans-unit>
        <trans-unit id="8bfd2da46a110f046c6975fde1a8b82933cacdc7" translate="yes" xml:space="preserve">
          <source>Note how there is no need for an entry for &lt;code&gt;&amp;lt;jane@laptop.(none)&amp;gt;&lt;/code&gt;, because the real name of that author is already correct.</source>
          <target state="translated">请注意，无需输入 &lt;code&gt;&amp;lt;jane@laptop.(none)&amp;gt;&lt;/code&gt; ，因为该作者的真实姓名已经正确。</target>
        </trans-unit>
        <trans-unit id="a357a7dbcbc2a41b2d3445e7cfb8ae38a48bfe09" translate="yes" xml:space="preserve">
          <source>Note in the example that we set up a triangular workflow, where we pull from one location and push to another. In a non-triangular workflow, &lt;code&gt;@{push}&lt;/code&gt; is the same as &lt;code&gt;@{upstream}&lt;/code&gt;, and there is no need for it.</source>
          <target state="translated">请注意，在示例中，我们建立了一个三角工作流程，在该工作流程中，我们从一个位置拉出并推到另一个位置。在非三角工作流程中， &lt;code&gt;@{push}&lt;/code&gt; 与 &lt;code&gt;@{upstream}&lt;/code&gt; 相同，因此不需要。</target>
        </trans-unit>
        <trans-unit id="01660f89f7c458ce6428d6e0df0b322692b74596" translate="yes" xml:space="preserve">
          <source>Note that &quot;%f&quot; is the name of the path that is being worked on. Depending on the version that is being filtered, the corresponding file on disk may not exist, or may have different contents. So, smudge and clean commands should not try to access the file on disk, but only act as filters on the content provided to them on standard input.</source>
          <target state="translated">请注意,&quot;%f &quot;是正在处理的路径名称。根据被过滤的版本,磁盘上对应的文件可能不存在,或者有不同的内容。所以,smudge和clean命令不应试图访问磁盘上的文件,而只是作为对标准输入中提供给它们的内容进行过滤。</target>
        </trans-unit>
        <trans-unit id="014f6a8d43d7b297d024fa501c939621bed28154" translate="yes" xml:space="preserve">
          <source>Note that &quot;../&quot; is not special and will match literally, which is unlikely what you want.</source>
          <target state="translated">请注意,&quot;./&quot;并不特殊,会按字面意思匹配,这不太可能是你想要的。</target>
        </trans-unit>
        <trans-unit id="8b91ded5c4fad4671b25fb8bfeab09bc89a0acef" translate="yes" xml:space="preserve">
          <source>Note that (3) is a historical artefact and will be ignored if the (1) and (2) specify that the submodule is not active. In other words, if we have a &lt;code&gt;submodule.&amp;lt;name&amp;gt;.active&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; or if the submodule&amp;rsquo;s path is excluded in the pathspec in &lt;code&gt;submodule.active&lt;/code&gt;, the url doesn&amp;rsquo;t matter whether it is present or not. This is illustrated in the example that follows.</source>
          <target state="translated">请注意，（3）是历史人工制品，如果（1）和（2）指定子模块未处于活动状态，则将被忽略。换句话说，如果我们有一个 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.active&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; ，或者如果子模块的路径被排除在pathspec &lt;code&gt;submodule.active&lt;/code&gt; ，网址不要紧，无论它存在与否。在下面的示例中对此进行了说明。</target>
        </trans-unit>
        <trans-unit id="6fec9940a0e0728d1bf92151624eb87584d6019f" translate="yes" xml:space="preserve">
          <source>Note that --more, --list, --independent and --merge-base options are mutually exclusive.</source>
          <target state="translated">请注意,--more、--list、--independent和--merge-base选项是相互排斥的。</target>
        </trans-unit>
        <trans-unit id="9b9a74f48dd77c7cda36904d8ae57495c22af6f7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;--force&lt;/code&gt; applies to all the refs that are pushed, hence using it with &lt;code&gt;push.default&lt;/code&gt; set to &lt;code&gt;matching&lt;/code&gt; or with multiple push destinations configured with &lt;code&gt;remote.*.push&lt;/code&gt; may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart). To force a push to only one branch, use a &lt;code&gt;+&lt;/code&gt; in front of the refspec to push (e.g &lt;code&gt;git push
origin +master&lt;/code&gt; to force a push to the &lt;code&gt;master&lt;/code&gt; branch). See the &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; section above for details.</source>
          <target state="translated">请注意 &lt;code&gt;--force&lt;/code&gt; 适用于所有推送的ref，因此将 &lt;code&gt;push.default&lt;/code&gt; 设置为 &lt;code&gt;matching&lt;/code&gt; 或将其与配置了 &lt;code&gt;remote.*.push&lt;/code&gt; 多个推送目标一起使用。*。push可能会覆盖当前分支以外的其他ref（包括本地ref严格落后于他们的远程对象）。要强制只推送到一个分支，请在refspec前面使用 &lt;code&gt;+&lt;/code&gt; 进行推送（例如 &lt;code&gt;git push origin +master&lt;/code&gt; 强制推送到 &lt;code&gt;master&lt;/code&gt; 分支）。有关详细信息，请参见上面的 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="f71426a1d6dfa55d8e5b4bb3bb7ddab1eba41559" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;--patch&lt;/code&gt; can accept no pathspec and will prompt to restore all modified paths.</source>
          <target state="translated">请注意，-- &lt;code&gt;--patch&lt;/code&gt; 不能接受任何路径说明，并且会提示您还原所有修改的路径。</target>
        </trans-unit>
        <trans-unit id="788dab85e40bdd496cc4b3d8bdc2f5695fd79580" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;combined diff&lt;/code&gt; lists only files which were modified from all parents.</source>
          <target state="translated">请注意， &lt;code&gt;combined diff&lt;/code&gt; 仅列出从所有父级修改而来的文件。</target>
        </trans-unit>
        <trans-unit id="e64bae554ef50a53010f144d204d2601ed2388af" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git --help ...&lt;/code&gt; is identical to &lt;code&gt;git help ...&lt;/code&gt; because the former is internally converted into the latter.</source>
          <target state="translated">请注意， &lt;code&gt;git --help ...&lt;/code&gt; 与 &lt;code&gt;git help ...&lt;/code&gt; 相同，因为前者在内部转换为后者。</target>
        </trans-unit>
        <trans-unit id="0f050e4f28b585b64021f162ba65306d71b16a1c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git add&lt;/code&gt; always adds just the current contents of a file to the index; further changes to the same file will be ignored unless you run &lt;code&gt;git add&lt;/code&gt; on the file again.</source>
          <target state="translated">注意， &lt;code&gt;git add&lt;/code&gt; 总是只将文件的当前内容添加到索引中。除非再次在文件上运行 &lt;code&gt;git add&lt;/code&gt; ，否则将忽略对该文件的进一步更改。</target>
        </trans-unit>
        <trans-unit id="a75d3b6c972faf4b238fb20e64f0ae5ba4c5e6f0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git diff-tree&lt;/code&gt; can use the tree encapsulated in a commit object.</source>
          <target state="translated">注意， &lt;code&gt;git diff-tree&lt;/code&gt; 可以使用封装在提交对象中的树。</target>
        </trans-unit>
        <trans-unit id="c22023840a6edf8cbd10c5905bf1fe0b2598253c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;trailers&lt;/code&gt; do not follow and are not intended to follow many rules for RFC 822 headers. For example they do not follow the encoding rules and probably many other rules.</source>
          <target state="translated">请注意， &lt;code&gt;trailers&lt;/code&gt; 不遵循且不旨在遵循RFC 822标头的许多规则。例如，它们不遵循编码规则，并且可能不遵循许多其他规则。</target>
        </trans-unit>
        <trans-unit id="99d4b644b5be625d6423f4cb1035eccb3ada0dfe" translate="yes" xml:space="preserve">
          <source>Note that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa. Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly.</source>
          <target state="translated">请注意,Git在核心层将路径名简单地视为非NUL字节的序列,不存在路径名编码转换(Mac和Windows除外)。因此,即使在使用传统的扩展ASCII编码的平台和文件系统上,使用非ASCII的路径名也能正常工作。然而,在这些系统上创建的版本库在基于UTF-8的系统(如Linux、Mac、Windows)上将无法正常工作,反之亦然。此外,许多基于Git的工具会简单地假设路径名为UTF-8,而无法正确显示其他编码。</target>
        </trans-unit>
        <trans-unit id="9883f1d7503e774a80aca1b5641976f5b274bd93" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;filerename&lt;/code&gt; is the same as a &lt;code&gt;filecopy&lt;/code&gt; followed by a &lt;code&gt;filedelete&lt;/code&gt; of the source location. There is a slight performance advantage to using &lt;code&gt;filerename&lt;/code&gt;, but the advantage is so small that it is never worth trying to convert a delete/add pair in source material into a rename for fast-import. This &lt;code&gt;filerename&lt;/code&gt; command is provided just to simplify frontends that already have rename information and don&amp;rsquo;t want bother with decomposing it into a &lt;code&gt;filecopy&lt;/code&gt; followed by a &lt;code&gt;filedelete&lt;/code&gt;.</source>
          <target state="translated">注意， &lt;code&gt;filerename&lt;/code&gt; 相同一个 &lt;code&gt;filecopy&lt;/code&gt; 后跟一个 &lt;code&gt;filedelete&lt;/code&gt; 源位置的。使用 &lt;code&gt;filerename&lt;/code&gt; 会有一点性能上的优势，但是优势是如此之小，以至于永远不值得尝试将源资料中的删除/添加对转换为用于快速导入的重命名。提供此 &lt;code&gt;filerename&lt;/code&gt; 命令只是为了简化已经具有重命名信息的前端，并且不希望将其分解为文件 &lt;code&gt;filecopy&lt;/code&gt; 然后再分解为文件 &lt;code&gt;filedelete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f7296e0d288c1c6e4ca2a5e972f6c90872dfac0" translate="yes" xml:space="preserve">
          <source>Note that a commit does not itself contain any information about what actually changed; all changes are calculated by comparing the contents of the tree referred to by this commit with the trees associated with its parents. In particular, Git does not attempt to record file renames explicitly, though it can identify cases where the existence of the same file data at changing paths suggests a rename. (See, for example, the &lt;code&gt;-M&lt;/code&gt; option to &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;).</source>
          <target state="translated">注意，提交本身并不包含有关实际更改的任何信息。通过将此提交所引用的树的内容与其父级关联的树进行比较，可以计算出所有更改。特别地，Git不会尝试明确记录文件重命名，尽管它可以识别在更改路径处存在相同文件数据提示重命名的情况。（例如，参见&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;的 &lt;code&gt;-M&lt;/code&gt; 选项）。</target>
        </trans-unit>
        <trans-unit id="54977b94f7c8617e07e8f365a31b9faa2fc062c5" translate="yes" xml:space="preserve">
          <source>Note that a more compact instruction does not change offset and size encoding. For example, if only offset2 is omitted like below, offset3 still contains bits 16-23. It does not become offset2 and contains bits 8-15 even if it&amp;rsquo;s right next to offset1.</source>
          <target state="translated">注意，更紧凑的指令不会更改偏移量和大小编码。例如，如果仅像下面这样省略了offset2，则offset3仍包含位16-23。即使它紧靠offset1，它也不会变为offset2并包含8-15位。</target>
        </trans-unit>
        <trans-unit id="2599b1548726c0979f146506e9008608bae9db4a" translate="yes" xml:space="preserve">
          <source>Note that a rebase merge works by replaying each commit from the working branch on top of the &amp;lt;upstream&amp;gt; branch. Because of this, when a merge conflict happens, the side reported as &lt;code&gt;ours&lt;/code&gt; is the so-far rebased series, starting with &amp;lt;upstream&amp;gt;, and &lt;code&gt;theirs&lt;/code&gt; is the working branch. In other words, the sides are swapped.</source>
          <target state="translated">请注意，rebase合并通过重播&amp;lt;upstream&amp;gt;分支顶部的工作分支中的每个提交来工作。因此，当发生合并冲突时，报告为 &lt;code&gt;ours&lt;/code&gt; 方的那一面是迄今为止的基础系列，从&amp;lt;upstream&amp;gt;开始，而 &lt;code&gt;theirs&lt;/code&gt; 是工作分支。换句话说，双方交换。</target>
        </trans-unit>
        <trans-unit id="8523c23f527cd324df8d4075c34f666be6f6f3b7" translate="yes" xml:space="preserve">
          <source>Note that all forms other than &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;:&amp;lt;expect&amp;gt;&lt;/code&gt; that specifies the expected current value of the ref explicitly are still experimental and their semantics may change as we gain experience with this feature.</source>
          <target state="translated">请注意，除了 &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;:&amp;lt;expect&amp;gt;&lt;/code&gt; 以外，所有其他形式都明确指定了ref的当前预期值，这些形式仍处于实验阶段，随着我们对该功能的经验积累，它们的语义可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="4c01852cae3ff7462ff1404dd165465e299075b3" translate="yes" xml:space="preserve">
          <source>Note that all these configuration variables should probably be set using the &lt;code&gt;--global&lt;/code&gt; flag, for example like this:</source>
          <target state="translated">请注意，所有这些配置变量都应使用 &lt;code&gt;--global&lt;/code&gt; 标志设置，例如：</target>
        </trans-unit>
        <trans-unit id="11bfa085b8a4e40f2da0245c59f1751f600a1ada" translate="yes" xml:space="preserve">
          <source>Note that any of the &lt;code&gt;refs/*&lt;/code&gt; cases above may come either from the &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory or from the &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; file. While the ref name encoding is unspecified, UTF-8 is preferred as some output processing may assume ref names in UTF-8.</source>
          <target state="translated">请注意，上面的任何 &lt;code&gt;refs/*&lt;/code&gt; 情况都可能来自 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 目录或 &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; 文件。虽然未指定引用名称编码，但首选使用UTF-8，因为某些输出处理可能会假定UTF-8中使用了引用名称。</target>
        </trans-unit>
        <trans-unit id="508d8a380e829238fc278b6ce7f900eddc6afba3" translate="yes" xml:space="preserve">
          <source>Note that any protocol restrictions will be applied to the rewritten URL. If the rewrite changes the URL to use a custom protocol or remote helper, you may need to adjust the &lt;code&gt;protocol.*.allow&lt;/code&gt; config to permit the request. In particular, protocols you expect to use for submodules must be set to &lt;code&gt;always&lt;/code&gt; rather than the default of &lt;code&gt;user&lt;/code&gt;. See the description of &lt;code&gt;protocol.allow&lt;/code&gt; above.</source>
          <target state="translated">请注意，所有协议限制都将应用于重写的URL。如果重写将URL更改为使用自定义协议或远程帮助程序，则可能需要调整 &lt;code&gt;protocol.*.allow&lt;/code&gt; config以允许请求。特别是，您希望用于子模块的协议必须设置为 &lt;code&gt;always&lt;/code&gt; 而不是 &lt;code&gt;user&lt;/code&gt; 的默认值。请参阅上面对 &lt;code&gt;protocol.allow&lt;/code&gt; 的描述。</target>
        </trans-unit>
        <trans-unit id="85755e8e95f86917d98f865efeaea006efa16988" translate="yes" xml:space="preserve">
          <source>Note that any tree or blob object can be examined using &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; with the &amp;lt;revision&amp;gt;:&amp;lt;path&amp;gt; syntax. This can sometimes be useful for browsing the contents of a tree that is not currently checked out.</source>
          <target state="translated">注意，可以使用&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;和&amp;lt;revision&amp;gt;：&amp;lt;path&amp;gt;语法检查任何树或blob对象。有时这对于浏览当前未检出的树的内容很有用。</target>
        </trans-unit>
        <trans-unit id="fbb379f0a0fd79434d80db46f9a2b53054c72c7c" translate="yes" xml:space="preserve">
          <source>Note that attributes are by default taken from the &lt;code&gt;.gitattributes&lt;/code&gt; files in the tree that is being archived. If you want to tweak the way the output is generated after the fact (e.g. you committed without adding an appropriate export-ignore in its &lt;code&gt;.gitattributes&lt;/code&gt;), adjust the checked out &lt;code&gt;.gitattributes&lt;/code&gt; file as necessary and use &lt;code&gt;--worktree-attributes&lt;/code&gt; option. Alternatively you can keep necessary attributes that should apply while archiving any tree in your &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file.</source>
          <target state="translated">请注意，默认情况下，属性是从要归档的树中的 &lt;code&gt;.gitattributes&lt;/code&gt; 文件中获取的。如果要调整事后生成输出的方式（例如，您在未在 &lt;code&gt;.gitattributes&lt;/code&gt; 中添加适当的export-ignore的情况下提交），请根据需要调整检出的 &lt;code&gt;.gitattributes&lt;/code&gt; 文件，并使用 &lt;code&gt;--worktree-attributes&lt;/code&gt; 选项。或者，您可以保留在 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 文件中归档任何树时应应用的必要属性。</target>
        </trans-unit>
        <trans-unit id="cff58353f0553493321de729107a5ed939f5819e" translate="yes" xml:space="preserve">
          <source>Note that changing the compression level will not automatically recompress all existing objects. You can force recompression by passing the -F option to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;.</source>
          <target state="translated">请注意，更改压缩级别不会自动重新压缩所有现有对象。您可以通过将-F选项传递给&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;来强制重新压缩。</target>
        </trans-unit>
        <trans-unit id="64e3311b0fc4c31b0c8a5b69594b7b0fffce6672" translate="yes" xml:space="preserve">
          <source>Note that commands that operate on the history of the current branch (e.g. &lt;code&gt;git commit&lt;/code&gt; to build a new history on top of it) still work while the HEAD is detached. They update the HEAD to point at the tip of the updated history without affecting any branch. Commands that update or inquire information &lt;code&gt;about&lt;/code&gt; the current branch (e.g. &lt;code&gt;git
branch --set-upstream-to&lt;/code&gt; that sets what remote-tracking branch the current branch integrates with) obviously do not work, as there is no (real) current branch to ask about in this state.</source>
          <target state="translated">请注意，在分离了HEAD的情况下，对当前分支的历史记录进行操作的命令（例如 &lt;code&gt;git commit&lt;/code&gt; 在其顶部构建新历史记录）仍然有效。他们将HEAD更新为指向更新历史记录的尖端，而不会影响任何分支。更新或查询 &lt;code&gt;about&lt;/code&gt; 当前分支的信息的命令（例如 &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; ，用于设置当前分支与之集成的远程跟踪分支）显然不起作用，因为没有（真实）当前分支要询问在这种状态下。</target>
        </trans-unit>
        <trans-unit id="ca37287a6d2fcb3a044758adb2f9a6569545f92f" translate="yes" xml:space="preserve">
          <source>Note that commits that do not include the trailer will not be counted. Likewise, commits with multiple trailers (e.g., multiple signoffs) may be counted more than once (but only once per unique trailer value in that commit).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021097bf28be68716f4d1858bb9538ff20243dc2" translate="yes" xml:space="preserve">
          <source>Note that commits which start empty are kept (unless --no-keep-empty is specified), and commits which are clean cherry-picks (as determined by &lt;code&gt;git log --cherry-mark ...&lt;/code&gt;) are detected and dropped as a preliminary step (unless --reapply-cherry-picks is passed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16e502657efa32285522830eee76fe68f8a2daa" translate="yes" xml:space="preserve">
          <source>Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled.</source>
          <target state="translated">请注意,尽管第一种模式的名称,但如果启用,所有模式中的颜色都用于突出显示已更改的部分。</target>
        </trans-unit>
        <trans-unit id="53b666711e62d15ce074196074eb30f8dac41460" translate="yes" xml:space="preserve">
          <source>Note that diff options passed to the command affect how the primary product of &lt;code&gt;format-patch&lt;/code&gt; is generated, and they are not passed to the underlying &lt;code&gt;range-diff&lt;/code&gt; machinery used to generate the cover-letter material (this may change in the future).</source>
          <target state="translated">请注意，传递给命令的diff选项会影响 &lt;code&gt;format-patch&lt;/code&gt; 的主乘积的生成方式，并且不会传递给用于生成封面信纸材料的基础 &lt;code&gt;range-diff&lt;/code&gt; 机械（将来可能会更改）。</target>
        </trans-unit>
        <trans-unit id="e0e05126bbcc50063c2790c39405469ee70a21a8" translate="yes" xml:space="preserve">
          <source>Note that during &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git pull --rebase&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt; and &lt;code&gt;theirs&lt;/code&gt; may appear swapped. See the explanation of the same options in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; for details.</source>
          <target state="translated">请注意，在 &lt;code&gt;git rebase&lt;/code&gt; 和 &lt;code&gt;git pull --rebase&lt;/code&gt; 期间， &lt;code&gt;ours&lt;/code&gt; 和 &lt;code&gt;theirs&lt;/code&gt; 可能会互换。有关详细信息，请参见&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]中&lt;/a&gt;相同选项的说明。</target>
        </trans-unit>
        <trans-unit id="1af7aa20d72debc79fb9171e27e72669f87bd742" translate="yes" xml:space="preserve">
          <source>Note that during &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git pull --rebase&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt; and &lt;code&gt;theirs&lt;/code&gt; may appear swapped; &lt;code&gt;--ours&lt;/code&gt; gives the version from the branch the changes are rebased onto, while &lt;code&gt;--theirs&lt;/code&gt; gives the version from the branch that holds your work that is being rebased.</source>
          <target state="translated">注意，在 &lt;code&gt;git rebase&lt;/code&gt; 和 &lt;code&gt;git pull --rebase&lt;/code&gt; 期间， &lt;code&gt;ours&lt;/code&gt; 和 &lt;code&gt;theirs&lt;/code&gt; 可能会互换； &lt;code&gt;--ours&lt;/code&gt; 提供更改所基于的分支的版本，而 &lt;code&gt;--theirs&lt;/code&gt; 提供包含要重新构建的工作的分支的版本。</target>
        </trans-unit>
        <trans-unit id="c0c3e4b221eecb8ab2fd8007bde41fbeccbc289b" translate="yes" xml:space="preserve">
          <source>Note that earlier implementation left a broken pair as a separate creation and deletion patches. This was an unnecessary hack and the latest implementation always merges all the broken pairs back into modifications, but the resulting patch output is formatted differently for easier review in case of such a complete rewrite by showing the entire contents of old version prefixed with &lt;code&gt;-&lt;/code&gt;, followed by the entire contents of new version prefixed with &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">请注意，较早的实现留下了一对中断对作为单独的创建和删除补丁。这是不必要的修改，并且最新的实现总是将所有断开的对合并为修改，但是对于这样的完整重写，通过显示以 &lt;code&gt;-&lt;/code&gt; 开头的旧版本的全部内容，可以将修补程序输出的格式设置为不同格式，以便于更轻松地查看。由新版本的全部内容加上 &lt;code&gt;+&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="1e94eb3093be7f837a0c2027288d60b6c3b52e2c" translate="yes" xml:space="preserve">
          <source>Note that earlier versions of this command did not complain and produced incorrect results if you gave these options.</source>
          <target state="translated">请注意,如果你给了这些选项,这个命令的早期版本不会抱怨,并产生不正确的结果。</target>
        </trans-unit>
        <trans-unit id="5d58dd5b84f29e01b510ca03eab20796ad3c7cbe" translate="yes" xml:space="preserve">
          <source>Note that extra commits can be shown to give a meaningful history.</source>
          <target state="translated">请注意,额外的提交可以显示出一个有意义的历史。</target>
        </trans-unit>
        <trans-unit id="5d8bcfac8a1a61a9e4be4013c3b0af7c68e4f7e1" translate="yes" xml:space="preserve">
          <source>Note that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit. Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit.</source>
          <target state="translated">请注意,快进更新并不创建合并提交,因此无法使用 --no-commit 来停止这些合并。因此,如果你想确保你的分支不被合并命令修改或更新,请使用 --no-ff 和 --no-commit。</target>
        </trans-unit>
        <trans-unit id="f0d1c52e1eb6b4521a19e733ce553d5995206cf5" translate="yes" xml:space="preserve">
          <source>Note that fast-import automatically switches packfiles when the current packfile reaches --max-pack-size, or 4 GiB, whichever limit is smaller. During an automatic packfile switch fast-import does not update the branch refs, tags or marks.</source>
          <target state="translated">请注意,当当前的 packfile 达到 --max-pack-size 或 4 GiB 时,fast-import 会自动切换 packfile,以较小的限制为准。在自动切换打包文件的过程中,fast-import 不会更新分支参考、标签或标记。</target>
        </trans-unit>
        <trans-unit id="6615d1d4a8cbe8f9f5da36594407e26f3b365d70" translate="yes" xml:space="preserve">
          <source>Note that git log starts with the most recent commit and works backwards through the parents; however, since Git history can contain multiple independent lines of development, the particular order that commits are listed in may be somewhat arbitrary.</source>
          <target state="translated">需要注意的是,git日志从最近的提交开始,然后从父代开始往后排;不过,由于Git历史可以包含多条独立的开发线路,所以提交的顺序可能有些随意。</target>
        </trans-unit>
        <trans-unit id="b6e44338fe1bf08aabf78cd81639eb77b1309fea" translate="yes" xml:space="preserve">
          <source>Note that git pull always merges into the current branch, regardless of what else is given on the command line.</source>
          <target state="translated">请注意,无论命令行中给出了什么,git pull 总是会合并到当前分支。</target>
        </trans-unit>
        <trans-unit id="bcdb8efaa60d12b40472e9e7be3ed7ef20fcfd01" translate="yes" xml:space="preserve">
          <source>Note that git-svn keeps track of the highest revision in which a branch or tag has appeared. If the subset of branches or tags is changed after fetching, then $GIT_DIR/svn/.metadata must be manually edited to remove (or reset) branches-maxRev and/or tags-maxRev as appropriate.</source>
          <target state="translated">注意 git-svn 会跟踪分支或标签出现的最高版本。如果分支或标签的子集在获取后发生了变化,那么必须手动编辑 $GIT_DIR/svn/.metadata 来移除(或重置)branches-maxRev 和/或 tags-maxRev。</target>
        </trans-unit>
        <trans-unit id="9d6b14c8954c11ebf9dc491ca128004d883ac7cd" translate="yes" xml:space="preserve">
          <source>Note that he doesn&amp;rsquo;t need to give the path to Alice&amp;rsquo;s repository; when Bob cloned Alice&amp;rsquo;s repository, Git stored the location of her repository in the repository configuration, and that location is used for pulls:</source>
          <target state="translated">请注意，他不需要提供通往Alice的存储库的路径。当Bob克隆Alice的存储库时，Git将其存储库的位置存储在存储库配置中，该位置用于拉取：</target>
        </trans-unit>
        <trans-unit id="d033887586c63461935e98a544790f02b6895719" translate="yes" xml:space="preserve">
          <source>Note that if no extensions are specified in the config file, then &lt;code&gt;core.repositoryformatversion&lt;/code&gt; SHOULD be set to &lt;code&gt;0&lt;/code&gt; (setting it to &lt;code&gt;1&lt;/code&gt; provides no benefit, and makes the repository incompatible with older implementations of git).</source>
          <target state="translated">请注意，如果未在配置文件中指定扩展名， &lt;code&gt;core.repositoryformatversion&lt;/code&gt; 将core.repositoryformatversion设置为 &lt;code&gt;0&lt;/code&gt; （将其设置为 &lt;code&gt;1&lt;/code&gt; 不会带来任何好处，并使存储库与git的较早实现不兼容）。</target>
        </trans-unit>
        <trans-unit id="855e515073658cd86a49dd1065464c65266acbcf" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;bidi-import&lt;/code&gt; capability is used the complete batch sequence has to be buffered before starting to send data to fast-import to prevent mixing of commands and fast-import responses on the helper&amp;rsquo;s stdin.</source>
          <target state="translated">请注意，如果使用了 &lt;code&gt;bidi-import&lt;/code&gt; 功能，则在开始将数据发送到快速导入之前，必须缓冲完整的批处理序列，以防止在助手的stdin上混合命令和快速导入响应。</target>
        </trans-unit>
        <trans-unit id="b689c65aa31e82a2dbc37c89c0ac3187b41716e6" translate="yes" xml:space="preserve">
          <source>Note that if the current branch head was your only reference to a particular point in history, then resetting that branch may leave you with no way to find the history it used to point to; so use this command carefully.</source>
          <target state="translated">请注意,如果当前的分支头是您对历史上某一特定点的唯一参考,那么重置该分支可能会让您无法找到它曾经指向的历史;所以请谨慎使用此命令。</target>
        </trans-unit>
        <trans-unit id="e6c226fbc041b7aed3f8d988d110ae660c99fecc" translate="yes" xml:space="preserve">
          <source>Note that if the number of kept packs is more than gc.autoPackLimit, this configuration variable is ignored, all packs except the base pack will be repacked. After this the number of packs should go below gc.autoPackLimit and gc.bigPackThreshold should be respected again.</source>
          <target state="translated">请注意,如果保留的包的数量超过了gc.autoPackLimit,这个配置变量会被忽略,除了基本包之外的所有包都会被重新打包。在这之后,包的数量应该低于gc.autoPackLimit,并且gc.bigPackThreshold应该再次被尊重。</target>
        </trans-unit>
        <trans-unit id="876a2eaaf30082c69c38a89b274fd268226ca0ba" translate="yes" xml:space="preserve">
          <source>Note that if you also want to skip the first commit of the range you would issue the command:</source>
          <target state="translated">需要注意的是,如果你也想跳过这个范围的第一次提交,你可以使用命令。</target>
        </trans-unit>
        <trans-unit id="56435425656273c2a6900d84ec2f6b2bfe4a637a" translate="yes" xml:space="preserve">
          <source>Note that if you are verifying a name from an untrusted source, it is wise to use &lt;code&gt;--end-of-options&lt;/code&gt; so that the name argument is not mistaken for another option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a094d13c9af525346a8eec9bbd2cdea3f73c32" translate="yes" xml:space="preserve">
          <source>Note that in all cases, the editor value will be passed to the shell, so any arguments containing spaces should be appropriately quoted. Additionally, if your editor normally detaches from the terminal when invoked, you should specify it with an argument that makes it not do that, or else Git will not see any changes. An example of a configuration addressing both of these issues on Windows would be the configuration &lt;code&gt;&quot;C:\Program Files\Vim\gvim.exe&quot; --nofork&lt;/code&gt;, which quotes the filename with spaces and specifies the &lt;code&gt;--nofork&lt;/code&gt; option to avoid backgrounding the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102fd7adeeb68915f128c7eebf4ae04f1c363d22" translate="yes" xml:space="preserve">
          <source>Note that in general, Alice would want her local changes committed before initiating this &quot;pull&quot;. If Bob&amp;rsquo;s work conflicts with what Alice did since their histories forked, Alice will use her working tree and the index to resolve conflicts, and existing local changes will interfere with the conflict resolution process (Git will still perform the fetch but will refuse to merge --- Alice will have to get rid of her local changes in some way and pull again when this happens).</source>
          <target state="translated">请注意，通常，爱丽丝希望在启动此&amp;ldquo;拉&amp;rdquo;之前提交她的本地更改。如果Bob的工作与自从其历史分叉以来Alice的工作发生冲突，Alice将使用其工作树和索引来解决冲突，并且现有的本地更改将干扰冲突解决过程（Git仍将执行获取操作，但将拒绝合并- -爱丽丝必须以某种方式摆脱局部变化，并在发生这种情况时再次拉动。</target>
        </trans-unit>
        <trans-unit id="51fccf4fe2d201a349cf25a2b82190079f387e94" translate="yes" xml:space="preserve">
          <source>Note that in older documentation you may see the index called the &quot;current directory cache&quot; or just the &quot;cache&quot;. It has three important properties:</source>
          <target state="translated">请注意,在旧的文档中,你可能会看到被称为 &quot;当前目录缓存 &quot;或只是 &quot;缓存 &quot;的索引。它有三个重要的属性。</target>
        </trans-unit>
        <trans-unit id="86ef833f0b802486b88e99a2562a2a2a3eec1f68" translate="yes" xml:space="preserve">
          <source>Note that in this file, the exception for &lt;code&gt;core.bare&lt;/code&gt; and &lt;code&gt;core.worktree&lt;/code&gt; is gone. If they exist in &lt;code&gt;$GIT_DIR/config&lt;/code&gt;, you must move them to the &lt;code&gt;config.worktree&lt;/code&gt; of the main working tree. You may also take this opportunity to review and move other configuration that you do not want to share to all working trees:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bb6a06b88e89af07ea98fc22445ba64a91b75d" translate="yes" xml:space="preserve">
          <source>Note that in this file, the exception for &lt;code&gt;core.bare&lt;/code&gt; and &lt;code&gt;core.worktree&lt;/code&gt; is gone. If you have them in $GIT_DIR/config before, you must move them to the &lt;code&gt;config.worktree&lt;/code&gt; of the main working tree. You may also take this opportunity to review and move other configuration that you do not want to share to all working trees:</source>
          <target state="translated">请注意，在此文件中， &lt;code&gt;core.bare&lt;/code&gt; 和 &lt;code&gt;core.worktree&lt;/code&gt; 的异常消失了。如果以前将它们放在$ GIT_DIR / config中，则必须将它们移动到主工作树的 &lt;code&gt;config.worktree&lt;/code&gt; 中。您还可以借此机会查看并移动不想共享给所有工作树的其他配置：</target>
        </trans-unit>
        <trans-unit id="22d9723cd6f0838bff4c15676f064d8d67f92e00" translate="yes" xml:space="preserve">
          <source>Note that increasing this value will increase the memory used on every relevant push that Git does over HTTP or HTTPS, since the entire buffer is allocated regardless of whether or not it is all used. Thus, it&amp;rsquo;s best to leave it at the default unless you are sure you need a different value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62684e2b0c86eaa1fac93a58127ba986d09144a" translate="yes" xml:space="preserve">
          <source>Note that it is currently &lt;strong&gt;always&lt;/strong&gt; an array reference, even if feature doesn&amp;rsquo;t accept any configuration parameters, and 'default' is used only to turn it on or off. In such case you turn feature on by setting this element to &lt;code&gt;[1]&lt;/code&gt;, and torn it off by setting it to &lt;code&gt;[0]&lt;/code&gt;. See also the passage about the &quot;blame&quot; feature in the &quot;Examples&quot; section.</source>
          <target state="translated">请注意，即使Feature不接受任何配置参数，它当前也&lt;strong&gt;始终&lt;/strong&gt;是数组引用，并且'default'仅用于打开或关闭它。在这种情况下，您可以通过将该元素设置为 &lt;code&gt;[1]&lt;/code&gt; 来打开功能，并通过将其设置为 &lt;code&gt;[0]&lt;/code&gt; 来将其关闭。另请参见&amp;ldquo;示例&amp;rdquo;部分中有关&amp;ldquo;怪&amp;rdquo;功能的段落。</target>
        </trans-unit>
        <trans-unit id="c6d71837c5b2acf93d8b7a746fdb13a8f313316a" translate="yes" xml:space="preserve">
          <source>Note that it is possible for refname to not have sha1-new when this hook runs. This can easily occur if another user modifies the ref after it was updated by &lt;code&gt;git-receive-pack&lt;/code&gt;, but before the hook was able to evaluate it. It is recommended that hooks rely on sha1-new rather than the current value of refname.</source>
          <target state="translated">请注意，运行此挂钩时，refname可能没有sha1-new。如果其他用户在 &lt;code&gt;git-receive-pack&lt;/code&gt; 更新ref之后但在挂钩能够对其进行评估之前修改了ref，则很容易发生这种情况。建议挂钩依赖sha1-new而不是refname的当前值。</target>
        </trans-unit>
        <trans-unit id="288f25c901caafda3b52f9e96d7bc31178f41bbc" translate="yes" xml:space="preserve">
          <source>Note that merge commits may have more than one parent:</source>
          <target state="translated">请注意,合并提交可能有多个父提交。</target>
        </trans-unit>
        <trans-unit id="f7a71f0bea03e654472a727d94dd31231e4320a4" translate="yes" xml:space="preserve">
          <source>Note that multiple helpers may be defined. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for details and examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4bd4c01bcc139c9e086b4c697c46e8ed5645dbb" translate="yes" xml:space="preserve">
          <source>Note that namespaces which include a &lt;code&gt;/&lt;/code&gt; will expand to a hierarchy of namespaces; for example, &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; will store refs under &lt;code&gt;refs/namespaces/foo/refs/namespaces/bar/&lt;/code&gt;. This makes paths in &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; behave hierarchically, so that cloning with &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; produces the same result as cloning with &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; and cloning from that repo with &lt;code&gt;GIT_NAMESPACE=bar&lt;/code&gt;. It also avoids ambiguity with strange namespace paths such as &lt;code&gt;foo/refs/heads/&lt;/code&gt;, which could otherwise generate directory/file conflicts within the &lt;code&gt;refs&lt;/code&gt; directory.</source>
          <target state="translated">请注意，包含 &lt;code&gt;/&lt;/code&gt; 的名称空间将扩展为名称空间的层次结构；例如， &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; 会将引用存储在 &lt;code&gt;refs/namespaces/foo/refs/namespaces/bar/&lt;/code&gt; 。这使得 &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; 中的路径具有分层行为，因此使用 &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; 进行克隆产生的结果与使用 &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; 进行克隆以及使用 &lt;code&gt;GIT_NAMESPACE=bar&lt;/code&gt; 进行该回购进行克隆的结果相同。它还可以避免与奇怪的名称空间路径（例如 &lt;code&gt;foo/refs/heads/&lt;/code&gt; 产生歧义，否则可能会在 &lt;code&gt;refs&lt;/code&gt; 目录内生成目录/文件冲突。</target>
        </trans-unit>
        <trans-unit id="5960cd2f6a18c56540790aa3e8525ad5bfd7623b" translate="yes" xml:space="preserve">
          <source>Note that no attempts whatsoever are made to validate the encoding.</source>
          <target state="translated">请注意,无论如何都不会尝试验证编码。</target>
        </trans-unit>
        <trans-unit id="a90bb6c9021795be1cb1c05d155b4badc4462ac4" translate="yes" xml:space="preserve">
          <source>Note that not all diffs can feature all types. For instance, diffs from the index to the working tree can never have Added entries (because the set of paths included in the diff is limited by what is in the index). Similarly, copied and renamed entries cannot appear if detection for those types is disabled.</source>
          <target state="translated">请注意,并不是所有的diff都能包含所有类型。例如,从索引到工作树的diff永远不会有Added条目(因为diff中包含的路径集受到索引中的限制)。同样,如果禁止检测复制和重命名的条目,这些类型也不能出现。</target>
        </trans-unit>
        <trans-unit id="b214bd38041e6a3ecd59f0a8d74547fecd3e66a2" translate="yes" xml:space="preserve">
          <source>Note that omitting the &lt;code&gt;=&lt;/code&gt; in &lt;code&gt;git -c foo.bar ...&lt;/code&gt; is allowed and sets &lt;code&gt;foo.bar&lt;/code&gt; to the boolean true value (just like &lt;code&gt;[foo]bar&lt;/code&gt; would in a config file). Including the equals but with an empty value (like &lt;code&gt;git -c
foo.bar= ...&lt;/code&gt;) sets &lt;code&gt;foo.bar&lt;/code&gt; to the empty string which &lt;code&gt;git config
--type=bool&lt;/code&gt; will convert to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">请注意，允许在 &lt;code&gt;git -c foo.bar ...&lt;/code&gt; 中省略 &lt;code&gt;=&lt;/code&gt; 并将 &lt;code&gt;foo.bar&lt;/code&gt; 设置为布尔值true（就像配置文件中的 &lt;code&gt;[foo]bar&lt;/code&gt; 一样）。包含等于但具有空值的值（例如 &lt;code&gt;git -c foo.bar= ...&lt;/code&gt; ） &lt;code&gt;foo.bar&lt;/code&gt; 设置为空字符串， &lt;code&gt;git config --type=bool&lt;/code&gt; 将其转换为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1650f0c21da45bf27c2f0a10dc06aba9ed69b7fe" translate="yes" xml:space="preserve">
          <source>Note that paths and refnames are split into tokens at slash boundaries. The command above would anonymize &lt;code&gt;subdir/secret.c&lt;/code&gt; as something like &lt;code&gt;path123/bar.c&lt;/code&gt;; you could then search for &lt;code&gt;bar.c&lt;/code&gt; in the anonymized repository to determine the final pathname.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d893e89ed900e1f0840df95a39350717d32e84c" translate="yes" xml:space="preserve">
          <source>Note that per repository configuration can be set in &lt;code&gt;$GIT_DIR/cloneurl&lt;/code&gt; file, or as values of multi-value &lt;code&gt;gitweb.url&lt;/code&gt; configuration variable in project config. Per-repository configuration takes precedence over value composed from &lt;code&gt;@git_base_url_list&lt;/code&gt; elements and project name.</source>
          <target state="translated">请注意，可以在 &lt;code&gt;$GIT_DIR/cloneurl&lt;/code&gt; 文件中设置每个存储库配置，也可以在项目config &lt;code&gt;gitweb.url&lt;/code&gt; 配置为多值gitweb.url配置变量的值。每个存储库配置优先于由 &lt;code&gt;@git_base_url_list&lt;/code&gt; 元素和项目名称组成的值。</target>
        </trans-unit>
        <trans-unit id="882882a5ca6dfe25f69ac7554d444a260301cac9" translate="yes" xml:space="preserve">
          <source>Note that raising this limit is only effective for disabling chunked transfer encoding and therefore should be used only where the remote server or a proxy only supports HTTP/1.0 or is noncompliant with the HTTP standard. Raising this is not, in general, an effective solution for most push problems, but can increase memory consumption significantly since the entire buffer is allocated even for small pushes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fccadef8ff02c3c7b5e8091c077ff771f4d090ed" translate="yes" xml:space="preserve">
          <source>Note that rule 3 disallows many cases that do not have any privacy implications. These rules are subject to change in future versions of git, and the server accessed by &lt;code&gt;git archive --remote&lt;/code&gt; may or may not follow these exact rules.</source>
          <target state="translated">请注意，规则3禁止许多不涉及隐私的情况。这些规则在将来的git版本中可能会发生变化，并且 &lt;code&gt;git archive --remote&lt;/code&gt; 访问的服务器可能会遵循也可能不会遵循这些确切规则。</target>
        </trans-unit>
        <trans-unit id="6b2cd45b5672bcfb50850c37a2d3873eae0b00dc" translate="yes" xml:space="preserve">
          <source>Note that running &lt;code&gt;git repack&lt;/code&gt; without the &lt;code&gt;--local&lt;/code&gt; option in a repository cloned with &lt;code&gt;--shared&lt;/code&gt; will copy objects from the source repository into a pack in the cloned repository, removing the disk space savings of &lt;code&gt;clone --shared&lt;/code&gt;. It is safe, however, to run &lt;code&gt;git gc&lt;/code&gt;, which uses the &lt;code&gt;--local&lt;/code&gt; option by default.</source>
          <target state="translated">需要注意的是运行 &lt;code&gt;git repack&lt;/code&gt; ，而不 &lt;code&gt;--local&lt;/code&gt; 与克隆一个仓库的选择 &lt;code&gt;--shared&lt;/code&gt; 将从源库对象复制到一个包中的克隆库，删除的磁盘空间节省 &lt;code&gt;clone --shared&lt;/code&gt; 。但是，运行 &lt;code&gt;git gc&lt;/code&gt; 是安全的，默认情况下使用 &lt;code&gt;--local&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="140dadc93eb0ab3b9abb37d56f2b3ec8284a753b" translate="yes" xml:space="preserve">
          <source>Note that since this operation is very I/O expensive, it might be a good idea to redirect the temporary directory off-disk with the &lt;code&gt;-d&lt;/code&gt; option, e.g. on tmpfs. Reportedly the speedup is very noticeable.</source>
          <target state="translated">请注意，由于此操作的I / O开销非常大，因此最好使用 &lt;code&gt;-d&lt;/code&gt; 选项在磁盘外重定向临时目录，例如在tmpfs上。据说加速非常明显。</target>
        </trans-unit>
        <trans-unit id="406b2d499d377ca290ed5b4924c72cd2cd51a43f" translate="yes" xml:space="preserve">
          <source>Note that some configuration can be controlled on per-repository rather than gitweb-wide basis: see &quot;Per-repository gitweb configuration&quot; subsection on &lt;a href=&quot;gitweb&quot;&gt;gitweb[1]&lt;/a&gt; manpage.</source>
          <target state="translated">请注意，可以在每个存储库而不是整个gitweb的基础上控制某些配置：请参见&lt;a href=&quot;gitweb&quot;&gt;gitweb [1]&lt;/a&gt;联机帮助页的&amp;ldquo;每个存储库gitweb配置&amp;rdquo;小节。</target>
        </trans-unit>
        <trans-unit id="ebdc2effe725ce03b669fc182e42bedc757b01ae" translate="yes" xml:space="preserve">
          <source>Note that some subcommand (e.g. &lt;code&gt;git grep&lt;/code&gt;) may behave differently when there are things on the command line other than &lt;code&gt;-h&lt;/code&gt;, but &lt;code&gt;git
subcmd -h&lt;/code&gt; without anything else on the command line is meant to consistently give the usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6bdc1118aa11562877a299d06f5353533bbf79" translate="yes" xml:space="preserve">
          <source>Note that specifying a protocol is mandatory and if the URL doesn&amp;rsquo;t specify a hostname (e.g., &quot;cert:///path/to/file&quot;) the credential will contain a hostname attribute whose value is an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8f5c59efaf04f91fb17771a5f9956f75377d81" translate="yes" xml:space="preserve">
          <source>Note that terminology has changed since that revision. For example, the README in that revision uses the word &quot;changeset&quot; to describe what we now call a &lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt;.</source>
          <target state="translated">请注意，自该修订版以来，术语已更改。例如，该修订版中的自述文件使用单词&amp;ldquo; changeset&amp;rdquo;来描述我们现在称为&lt;a href=&quot;#def_commit_object&quot;&gt;commit的内容&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9142b2dfed27b980836bfa3cd8737a30cbbd1e38" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;name&lt;/code&gt; forms of these variables conventionally refer to some form of a personal name. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and the environment variables section of &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for more information on these settings and the &lt;code&gt;credential.username&lt;/code&gt; option if you&amp;rsquo;re looking for authentication credentials instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1162a2144d0b881d5670bbd9b0805334b2b73beb" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;t_rel&lt;/code&gt; field contains the observed run time in seconds for the child process (starting before the fork/exec/spawn and stopping after the waitpid() and includes OS process creation overhead). So this time will be slightly larger than the atexit time reported by the child process itself.</source>
          <target state="translated">请注意， &lt;code&gt;t_rel&lt;/code&gt; 字段包含观察到的子进程的运行时间（以秒为单位）（在fork / exec / spawn之前开始，在waitpid（）之后停止，并且包括OS进程创建开销）。因此，此时间将比子进程本身报告的退出时间略长。</target>
        </trans-unit>
        <trans-unit id="b7757b33b688da6e41f6e15271bd961d7647767a" translate="yes" xml:space="preserve">
          <source>Note that the SVN URL of the commiturl config key includes the SVN branch. If you rather want to set the commit URL for an entire SVN repository use svn-remote.&amp;lt;name&amp;gt;.pushurl instead.</source>
          <target state="translated">请注意，commiturl配置键的SVN URL包含SVN分支。如果您想为整个SVN存储库设置提交URL，请使用svn-remote。&amp;lt;name&amp;gt; .pushurl。</target>
        </trans-unit>
        <trans-unit id="cb5d63c2ce1d70a7eb8e0b6357957166a5a229f7" translate="yes" xml:space="preserve">
          <source>Note that the asterisk &lt;code&gt;*&lt;/code&gt; is quoted from the shell in this example; this lets Git, and not the shell, expand the pathnames of files and subdirectories under the &lt;code&gt;Documentation/&lt;/code&gt; directory.</source>
          <target state="translated">请注意，在此示例中，星号 &lt;code&gt;*&lt;/code&gt; 从外壳引号引起来；这使Git而不是Shell可以扩展 &lt;code&gt;Documentation/&lt;/code&gt; 目录下文件和子目录的路径名。</target>
        </trans-unit>
        <trans-unit id="ce32bdb056375627c69f9422ed26926b9107752d" translate="yes" xml:space="preserve">
          <source>Note that the asterisk &lt;code&gt;*&lt;/code&gt; is quoted from the shell in this example; this lets the command include the files from subdirectories of &lt;code&gt;Documentation/&lt;/code&gt; directory.</source>
          <target state="translated">请注意，在此示例中，星号 &lt;code&gt;*&lt;/code&gt; 从外壳引号引起来；这使命令可以包含 &lt;code&gt;Documentation/&lt;/code&gt; 目录的子目录中的文件。</target>
        </trans-unit>
        <trans-unit id="8938c6c44864ae040ef79f140140b8a3da4caab5" translate="yes" xml:space="preserve">
          <source>Note that the commit message will already be filled in for you with some information about the merge. Normally you can just use this default message unchanged, but you may add additional commentary of your own if desired.</source>
          <target state="translated">请注意,提交信息中已经为您填写了一些关于合并的信息。一般来说,您可以不加修改地使用这个默认信息,但如果需要的话,您可以添加自己的注释。</target>
        </trans-unit>
        <trans-unit id="131272668a67eaa5ac9294087a9ff4488c82c210" translate="yes" xml:space="preserve">
          <source>Note that the example that we will use is really a toy example, we will be looking for the first commit that has a version like &quot;2.6.26-something&quot;, that is the commit that has a &quot;SUBLEVEL = 26&quot; line in the top level Makefile. This is a toy example because there are better ways to find this commit with Git than using &quot;git bisect&quot; (for example &quot;git blame&quot; or &quot;git log -S&amp;lt;string&amp;gt;&quot;).</source>
          <target state="translated">请注意，我们将使用的示例实际上是一个玩具示例，我们将寻找具有&amp;ldquo; 2.6.26-something&amp;rdquo;之类的版本的第一个提交，即在顶层Makefile。这是一个玩具示例，因为与使用&amp;ldquo; git bisect&amp;rdquo;（例如&amp;ldquo; git blame&amp;rdquo;或&amp;ldquo; git log -S &amp;lt;string&amp;gt;&amp;rdquo;）相比，使用Git查找此提交的方法更好。</target>
        </trans-unit>
        <trans-unit id="5e386156a3e0996458a30d74f4a22474e7420343" translate="yes" xml:space="preserve">
          <source>Note that the files all have mode 644 or 755: Git actually only pays attention to the executable bit.</source>
          <target state="translated">注意,文件的模式都是644或755:Git其实只关注可执行位。</target>
        </trans-unit>
        <trans-unit id="d2e57a867612d1ae307185458bab810ae89e20a5" translate="yes" xml:space="preserve">
          <source>Note that the first word of an alias does not necessarily have to be a command. It can be a command-line option that will be passed into the invocation of &lt;code&gt;git&lt;/code&gt;. In particular, this is useful when used with &lt;code&gt;-c&lt;/code&gt; to pass in one-time configurations or &lt;code&gt;-p&lt;/code&gt; to force pagination. For example, &lt;code&gt;loud-rebase = -c commit.verbose=true rebase&lt;/code&gt; can be defined such that running &lt;code&gt;git loud-rebase&lt;/code&gt; would be equivalent to &lt;code&gt;git -c commit.verbose=true rebase&lt;/code&gt;. Also, &lt;code&gt;ps = -p status&lt;/code&gt; would be a helpful alias since &lt;code&gt;git ps&lt;/code&gt; would paginate the output of &lt;code&gt;git status&lt;/code&gt; where the original command does not.</source>
          <target state="translated">请注意，别名的第一个单词不一定必须是命令。它可以是命令行选项，将传递给 &lt;code&gt;git&lt;/code&gt; 调用。特别是，当与 &lt;code&gt;-c&lt;/code&gt; 一起使用以一次性配置通过或 &lt;code&gt;-p&lt;/code&gt; 强制分页使用时，这很有用。例如，可以定义 &lt;code&gt;loud-rebase = -c commit.verbose=true rebase&lt;/code&gt; ，以便运行 &lt;code&gt;git loud-rebase&lt;/code&gt; &lt;code&gt;git -c commit.verbose=true rebase&lt;/code&gt; -rebase与git -c commit.verbose = true rebase等效。同样， &lt;code&gt;ps = -p status&lt;/code&gt; 将是一个有用的别名，因为 &lt;code&gt;git ps&lt;/code&gt; 将对 &lt;code&gt;git status&lt;/code&gt; 的输出进行分页，而原始命令则不这样做。</target>
        </trans-unit>
        <trans-unit id="650b87912cfe39dc5747fbba67473a3822f86ab9" translate="yes" xml:space="preserve">
          <source>Note that the form &lt;code&gt;--filter=sparse:path=&amp;lt;path&amp;gt;&lt;/code&gt; that wants to read from an arbitrary path on the filesystem has been dropped for security reasons.</source>
          <target state="translated">请注意，出于安全原因，已删除了要从文件系统上任意路径读取的 &lt;code&gt;--filter=sparse:path=&amp;lt;path&amp;gt;&lt;/code&gt; 形式。</target>
        </trans-unit>
        <trans-unit id="d8075e043d9a3ca9826ff1989c66c1905d9648ca" translate="yes" xml:space="preserve">
          <source>Note that the grafts mechanism is outdated and can lead to problems transferring objects between repositories; see &lt;a href=&quot;git-replace&quot;&gt;git-replace[1]&lt;/a&gt; for a more flexible and robust system to do the same thing.</source>
          <target state="translated">请注意，嫁接机制已经过时，可能导致在存储库之间传输对象时出现问题。请参阅&lt;a href=&quot;git-replace&quot;&gt;git-replace [1]&lt;/a&gt;以获取更灵活，更强大的系统来执行相同的操作。</target>
        </trans-unit>
        <trans-unit id="0b0bdd8828d416a94597b15ce8aefc2c0b976fde" translate="yes" xml:space="preserve">
          <source>Note that the last point clashes with the other two: a topic that has been merged elsewhere should not be rebased. See the section on RECOVERING FROM UPSTREAM REBASE in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">请注意，最后一点与其他两点冲突：已经在其他地方合并的主题不应重新设置基础。请参阅&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]中的&lt;/a&gt;从UPSTRREAM REBASE恢复。</target>
        </trans-unit>
        <trans-unit id="bd4901c4d1f08f37f3106399dbc26a76568f48fe" translate="yes" xml:space="preserve">
          <source>Note that the leading character does not have to be a dot; for example, you can use &lt;code&gt;--suffix=-patch&lt;/code&gt; to get &lt;code&gt;0001-description-of-my-change-patch&lt;/code&gt;.</source>
          <target state="translated">注意，前导字符不必是点。例如，您可以使用 &lt;code&gt;--suffix=-patch&lt;/code&gt; 获得 &lt;code&gt;0001-description-of-my-change-patch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="833f1e85ef857dfcde43c87fdacaaa1075b0d6b3" translate="yes" xml:space="preserve">
          <source>Note that the maintainer(s) may impose restrictions, such as &quot;Signed-off-by&quot; requirements, that all commits/patches submitted for inclusion must adhere to. Consult your project&amp;rsquo;s documentation for more information.</source>
          <target state="translated">请注意，维护者可能会施加一些限制，例如&amp;ldquo;签署人&amp;rdquo;要求，必须遵守提交的所有提交/补丁。有关更多信息，请查阅项目的文档。</target>
        </trans-unit>
        <trans-unit id="50f092ab1e91fa0de2c9ed05785c4a967888dc6a" translate="yes" xml:space="preserve">
          <source>Note that the name &quot;origin&quot; is just the name that Git uses by default to refer to the repository that you cloned from.</source>
          <target state="translated">请注意,&quot;origin &quot;只是Git默认使用的名称,用来指代你克隆的仓库。</target>
        </trans-unit>
        <trans-unit id="22728656f144a546aef50a70cd21a26fce3a8c1d" translate="yes" xml:space="preserve">
          <source>Note that the patch is always used as-is without charset conversion, even with this flag.</source>
          <target state="translated">请注意,即使有这个标志,补丁也总是在没有进行字符集转换的情况下按原样使用。</target>
        </trans-unit>
        <trans-unit id="9bea9d7e3f1393135579965b1439ff9a7baaf238" translate="yes" xml:space="preserve">
          <source>Note that the push URL and the fetch URL, even though they can be set differently, must still refer to the same place. What you pushed to the push URL should be what you would see if you immediately fetched from the fetch URL. If you are trying to fetch from one place (e.g. your upstream) and push to another (e.g. your publishing repository), use two separate remotes.</source>
          <target state="translated">请注意,push URL和fetch URL虽然可以设置不同,但仍然必须指向同一个地方。你推送到推送 URL 的内容应该是你立即从获取 URL 获取时看到的内容。如果你试图从一个地方(例如你的上游)获取并推送到另一个地方(例如你的发布库),请使用两个不同的远程。</target>
        </trans-unit>
        <trans-unit id="f8efe69c6940942131795b6ce6c48d7e64d9560b" translate="yes" xml:space="preserve">
          <source>Note that the reflog history is very different from normal Git history. While normal history is shared by every repository that works on the same project, the reflog history is not shared: it tells you only about how the branches in your local repository have changed over time.</source>
          <target state="translated">请注意,reflog历史记录与普通的Git历史记录有很大不同。正常的历史记录是由同一项目的每个仓库共享的,而 reflog 历史记录则不是共享的:它只告诉你本地仓库中的分支随着时间的推移发生了什么变化。</target>
        </trans-unit>
        <trans-unit id="9a9c3b4049e20efd5a28033d7014008a8c2ac264" translate="yes" xml:space="preserve">
          <source>Note that the script (&lt;code&gt;my_script&lt;/code&gt; in the above example) should exit with code 0 if the current source code is good/old, and exit with a code between 1 and 127 (inclusive), except 125, if the current source code is bad/new.</source>
          <target state="translated">请注意，如果当前源代码良好/旧，则脚本（上例中的 &lt;code&gt;my_script&lt;/code&gt; ）应以代码0退出，而如果当前源代码不良/则应以1至127（含）之间的代码退出（125除外）。新。</target>
        </trans-unit>
        <trans-unit id="5586aefc0f8bd69c9dcf3cf3294d72d0db17f0fc" translate="yes" xml:space="preserve">
          <source>Note that the second point is true even across machines. You can duplicate a remote Git repository with &lt;strong&gt;any&lt;/strong&gt; regular copy mechanism, be it &lt;code&gt;scp&lt;/code&gt;, &lt;code&gt;rsync&lt;/code&gt; or &lt;code&gt;wget&lt;/code&gt;.</source>
          <target state="translated">请注意，即使在机器之间，第二点也是正确的。您可以使用&lt;strong&gt;任何&lt;/strong&gt;常规复制机制（例如 &lt;code&gt;scp&lt;/code&gt; ， &lt;code&gt;rsync&lt;/code&gt; 或 &lt;code&gt;wget&lt;/code&gt; )复制远程Git存储库。</target>
        </trans-unit>
        <trans-unit id="e9e6bb5468c99a3a334f80fab3dbb52fc16223c6" translate="yes" xml:space="preserve">
          <source>Note that the session-id of the child process is not available to the current/spawning process, so the child&amp;rsquo;s PID is reported here as a hint for post-processing. (But it is only a hint because the child process may be a shell script which doesn&amp;rsquo;t have a session-id.)</source>
          <target state="translated">请注意，子进程的session-id对当前/生成进程不可用，因此此处将报告子进程的PID作为后期处理的提示。（但这只是一个提示，因为子进程可能是一个没有会话ID的shell脚本。）</target>
        </trans-unit>
        <trans-unit id="e98f559f39ce7645bbbb14c50cc4f9c4dc239749" translate="yes" xml:space="preserve">
          <source>Note that the sizes of objects on disk are reported accurately, but care should be taken in drawing conclusions about which refs or objects are responsible for disk usage. The size of a packed non-delta object may be much larger than the size of objects which delta against it, but the choice of which object is the base and which is the delta is arbitrary and is subject to change during a repack.</source>
          <target state="translated">请注意,磁盘上对象的大小是准确报告的,但在得出关于哪个参考或对象对磁盘使用负责的结论时应小心。一个包装好的非delta对象的大小可能会比与其相对应的delta对象的大小大得多,但选择哪个对象是基础,哪个是delta是任意的,而且在重新包装时可能会改变。</target>
        </trans-unit>
        <trans-unit id="47fc7cad6a527b522ab5e266e3e278a07a579735" translate="yes" xml:space="preserve">
          <source>Note that the suffix you get if you type these commands today may be longer than what Linus saw above when he ran these commands, as your Git repository may have new commits whose object names begin with 975b that did not exist back then, and &quot;-g975b&quot; suffix alone may not be sufficient to disambiguate these commits.</source>
          <target state="translated">请注意,今天输入这些命令得到的后缀可能比 Linus 执行这些命令时看到的还要长,因为你的 Git 仓库中可能有新的提交,其对象名是以 975b 开头的,而这些提交在当时并不存在,仅靠&quot;-g975b &quot;后缀可能不足以混淆这些提交。</target>
        </trans-unit>
        <trans-unit id="7eeba5803dc504042af48f9504a175baa6f39016" translate="yes" xml:space="preserve">
          <source>Note that the target of a &lt;code&gt;push&lt;/code&gt; is normally a &lt;a href=&quot;#def_bare_repository&quot;&gt;bare&lt;/a&gt; repository. You can also push to a repository that has a checked-out working tree, but a push to update the currently checked-out branch is denied by default to prevent confusion. See the description of the receive.denyCurrentBranch option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">请注意， &lt;code&gt;push&lt;/code&gt; 的目标通常是&lt;a href=&quot;#def_bare_repository&quot;&gt;裸&lt;/a&gt;仓库。您也可以推送到具有签出工作树的存储库，但是默认情况下拒绝推送更新当前签出分支的操作​​，以免造成混淆。有关详细信息，请参见&lt;a href=&quot;git-config&quot;&gt;git-config [1]中&lt;/a&gt;对receive.denyCurrentBranch选项的描述。</target>
        </trans-unit>
        <trans-unit id="110e365a18d2e41e53b11ff50c7bbd9d01eae2f0" translate="yes" xml:space="preserve">
          <source>Note that the two techniques outlined above (exporting via &lt;a href=&quot;#exporting-via-http&quot;&gt;http&lt;/a&gt; or &lt;a href=&quot;#exporting-via-git&quot;&gt;git&lt;/a&gt;) allow other maintainers to fetch your latest changes, but they do not allow write access, which you will need to update the public repository with the latest changes created in your private repository.</source>
          <target state="translated">请注意，上面概述的两种技术（通过&lt;a href=&quot;#exporting-via-http&quot;&gt;http&lt;/a&gt;或&lt;a href=&quot;#exporting-via-git&quot;&gt;git&lt;/a&gt;导出）允许其他维护者获取您的最新更改，但它们不允许写访问，您需要使用私有存储库中创建的最新更改来更新公共存储库。</target>
        </trans-unit>
        <trans-unit id="ae8ea7d3546a16ede3faa6039563fb0d737e4467" translate="yes" xml:space="preserve">
          <source>Note that the version which &lt;code&gt;git bisect&lt;/code&gt; checks out for you at each point is just a suggestion, and you&amp;rsquo;re free to try a different version if you think it would be a good idea. For example, occasionally you may land on a commit that broke something unrelated; run</source>
          <target state="translated">请注意， &lt;code&gt;git bisect&lt;/code&gt; 每次都为您签出的版本只是一个建议，如果您认为这是个好主意，则可以随意尝试使用其他版本。例如，有时您可能遇到了破坏了无关内容的提交；跑</target>
        </trans-unit>
        <trans-unit id="1000c60b0f402f5d9e4c69088fd79818a06e5e98" translate="yes" xml:space="preserve">
          <source>Note that there are two ways to checkout a particular branch. As described elsewhere on this page, the &quot;module&quot; parameter of cvs checkout is interpreted as a branch name, and it becomes the main branch. It remains the main branch for a given sandbox even if you temporarily make another branch sticky with cvs update -r. Alternatively, the -r argument can indicate some other branch to actually checkout, even though the module is still the &quot;main&quot; branch. Tradeoffs (as currently implemented): Each new &quot;module&quot; creates a new database on disk with a history for the given module, and after the database is created, operations against that main branch are fast. Or alternatively, -r doesn&amp;rsquo;t take any extra disk space, but may be significantly slower for many operations, like cvs update.</source>
          <target state="translated">请注意，有两种方法可以检出特定分支。如本页其他地方所述，cvs checkout的&amp;ldquo; module&amp;rdquo;参数被解释为分支名称，并且它成为主分支。即使您使用cvs update -r暂时使另一个分支保持粘性，它仍然是给定沙箱的主要分支。或者，-r参数可以指示其他要实际签出的分支，即使该模块仍然是&amp;ldquo;主&amp;rdquo;分支。权衡（当前实现）：每个新的&amp;ldquo;模块&amp;rdquo;都会在磁盘上创建一个新数据库，其中包含给定模块的历史记录，并且在创建数据库之后，针对该主分支的操作​​很快。或者，-r不会占用任何额外的磁盘空间，但是对于许多操作（例如cvs更新）可能会明显慢一些。</target>
        </trans-unit>
        <trans-unit id="4fe39a3f8a6c98b987fad41f0865478fee4d146d" translate="yes" xml:space="preserve">
          <source>Note that these are applied before commit ordering and formatting options, such as &lt;code&gt;--reverse&lt;/code&gt;.</source>
          <target state="translated">请注意，这些选项在提交顺序和格式选项（例如 &lt;code&gt;--reverse&lt;/code&gt; )之前应用。</target>
        </trans-unit>
        <trans-unit id="33723cad0621665104eb7762cf8f60a246a13517" translate="yes" xml:space="preserve">
          <source>Note that these configuration variables should probably be set using the &lt;code&gt;--global&lt;/code&gt; flag, for example like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb8cdc33c08512e4436bbf3b8db5bc9921ae58d" translate="yes" xml:space="preserve">
          <source>Note that this affects all diff-based output types, e.g. those produced by &lt;code&gt;--stat&lt;/code&gt;, etc.</source>
          <target state="translated">请注意，这会影响所有基于差异的输出类型，例如 &lt;code&gt;--stat&lt;/code&gt; 等产生的类型。</target>
        </trans-unit>
        <trans-unit id="0691624d8498eccd40578875388b7f8bab2a7b6c" translate="yes" xml:space="preserve">
          <source>Note that this applies only to accessing the repository&amp;rsquo;s disk contents directly. An older client which understands only format &lt;code&gt;0&lt;/code&gt; may still connect via &lt;code&gt;git://&lt;/code&gt; to a repository using format &lt;code&gt;1&lt;/code&gt;, as long as the server process understands format &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">请注意，这仅适用于直接访问存储库的磁盘内容。只要服务器进程理解格式 &lt;code&gt;1&lt;/code&gt; ，只能理解格式 &lt;code&gt;0&lt;/code&gt; 的旧客户端仍可以通过 &lt;code&gt;git://&lt;/code&gt; 连接到使用格式 &lt;code&gt;1&lt;/code&gt; 的存储库。</target>
        </trans-unit>
        <trans-unit id="c3528bf60e5e55bcec2b34b4efbb66a2e2ad0ca9" translate="yes" xml:space="preserve">
          <source>Note that this assumes that none of the blobs and commit messages referenced by that revision range contains the string &lt;code&gt;refs/heads/master&lt;/code&gt;.</source>
          <target state="translated">请注意，这假定该修订范围引用的Blob和提交消息均不包含字符串 &lt;code&gt;refs/heads/master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2c1b09dd03782a35574f4220ce1860b1a59abed" translate="yes" xml:space="preserve">
          <source>Note that this configuration variable is ignored if it is seen in the repository-level config (this is a safety measure against fetching from untrusted repositories).</source>
          <target state="translated">请注意,如果在仓库级配置中看到这个配置变量,则会被忽略(这是为了防止从不受信任的仓库中获取的安全措施)。</target>
        </trans-unit>
        <trans-unit id="8243e24ce26ee48638bea5b267bba5916eee07a8" translate="yes" xml:space="preserve">
          <source>Note that this is currently only implemented for the client side of clones and fetches.</source>
          <target state="translated">需要注意的是,这一点目前只在克隆和获取的客户端实现。</target>
        </trans-unit>
        <trans-unit id="7278e2ca069b871494710e49f702957a299741e8" translate="yes" xml:space="preserve">
          <source>Note that this is the old file data; so the object that Git named in its response to the initial tree was a tree with a snapshot of the directory state that was recorded by the first commit.</source>
          <target state="translated">请注意,这是旧的文件数据;所以Git在响应初始树中命名的对象是一棵树,上面有第一次提交记录的目录状态快照。</target>
        </trans-unit>
        <trans-unit id="8524e2a4579b70a19e36821a3f8f1b43bac12c4a" translate="yes" xml:space="preserve">
          <source>Note that this list is non-comprehensive and not necessarily complete. For command-specific variables, you will find a more detailed description in the appropriate manual page.</source>
          <target state="translated">请注意,这个列表并不全面,也不一定完整。对于特定的命令变量,你可以在相应的手册页面找到更详细的描述。</target>
        </trans-unit>
        <trans-unit id="a06dd344c0e0f4252ac8d0d18c1815e7f413d617" translate="yes" xml:space="preserve">
          <source>Note that this may contain embedded LF or CRLF characters that are not escaped, so the event may spill across multiple lines.</source>
          <target state="translated">请注意,这可能包含没有转义的嵌入式LF或CRLF字符,因此事件可能会跨越多行。</target>
        </trans-unit>
        <trans-unit id="954610f540e4dda45ac67b28e742adb370b9dd1c" translate="yes" xml:space="preserve">
          <source>Note that this may mean that multiple Git commits are created for a single SVN revision.</source>
          <target state="translated">请注意,这可能意味着一个SVN修订版会有多个Git提交。</target>
        </trans-unit>
        <trans-unit id="69a24fcf6b082a94d6b3e16af2197fed496268e4" translate="yes" xml:space="preserve">
          <source>Note that this option is only useful if you are actually sending the emails and want to identify yourself as the sender, but retain the original author (and &lt;code&gt;git am&lt;/code&gt; will correctly pick up the in-body header). Note also that &lt;code&gt;git send-email&lt;/code&gt; already handles this transformation for you, and this option should not be used if you are feeding the result to &lt;code&gt;git send-email&lt;/code&gt;.</source>
          <target state="translated">请注意，此选项仅在您实际发送电子邮件并希望将自己标识为发件人但保留原始作者的情况下才有用（而 &lt;code&gt;git am&lt;/code&gt; 将正确提取体内标头）。另请注意， &lt;code&gt;git send-email&lt;/code&gt; 已经为您处理了此转换，如果 &lt;code&gt;git send-email&lt;/code&gt; 结果提供给git send-email，则不应使用此选项。</target>
        </trans-unit>
        <trans-unit id="d0a34c500aa8e9fdf22f16d59ae03a1a8711ff64" translate="yes" xml:space="preserve">
          <source>Note that this option uses the no overlay mode by default (see also &lt;code&gt;--overlay&lt;/code&gt;), and currently doesn&amp;rsquo;t support overlay mode.</source>
          <target state="translated">请注意，此选项默认情况下使用无覆盖模式（另请参阅 &lt;code&gt;--overlay&lt;/code&gt; ），并且当前不支持覆盖模式。</target>
        </trans-unit>
        <trans-unit id="c4360f69bfd218e96ff125f09b08b60281e46fca" translate="yes" xml:space="preserve">
          <source>Note that this setting should only be set by &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; or &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;. Trying to change it after initialization will not work and will produce hard-to-diagnose issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3aa2cd05420cf442d246cf6450d49e1768c842c" translate="yes" xml:space="preserve">
          <source>Note that this variable is honored even when set in a configuration file in a &quot;.git&quot; subdirectory of a directory and its value differs from the latter directory (e.g. &quot;/path/to/.git/config&quot; has core.worktree set to &quot;/different/path&quot;), which is most likely a misconfiguration. Running Git commands in the &quot;/path/to&quot; directory will still use &quot;/different/path&quot; as the root of the work tree and can cause confusion unless you know what you are doing (e.g. you are creating a read-only snapshot of the same index to a location different from the repository&amp;rsquo;s usual working tree).</source>
          <target state="translated">请注意，即使在目录的&amp;ldquo; .git&amp;rdquo;子目录中的配置文件中设置了该变量，它的值也与后者不同（例如，&amp;ldquo; / path / to / .git / config&amp;rdquo;将core.worktree设置为&amp;ldquo; / different / path&amp;rdquo;），很可能是配置错误。在&amp;ldquo; / path / to&amp;rdquo;目录中运行Git命令仍将使用&amp;ldquo; / different / path&amp;rdquo;作为工作树的根目录，除非您知道自己在做什么（例如，您正在创建一个只读快照），否则会引起混乱。与存储库通常的工作树不同的位置使用相同的索引）。</target>
        </trans-unit>
        <trans-unit id="f66853802a66e4aff14a38d5843516f4164ff5ba" translate="yes" xml:space="preserve">
          <source>Note that this will create the new branch, but it will not switch the working tree to it; use &quot;git switch &amp;lt;newbranch&amp;gt;&quot; to switch to the new branch.</source>
          <target state="translated">请注意，这将创建新分支，但不会将工作树切换到该分支。使用&amp;ldquo; git switch &amp;lt;newbranch&amp;gt;&amp;rdquo;切换到新分支。</target>
        </trans-unit>
        <trans-unit id="f6e42ae8cab92e791d65bf753cdda97ba478a01b" translate="yes" xml:space="preserve">
          <source>Note that unless one of &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;--cc&lt;/code&gt;, or &lt;code&gt;-m&lt;/code&gt; is given, merge commits will never show a diff, even if a diff format like &lt;code&gt;--patch&lt;/code&gt; is selected, nor will they match search options like &lt;code&gt;-S&lt;/code&gt;. The exception is when &lt;code&gt;--first-parent&lt;/code&gt; is in use, in which merges are treated like normal single-parent commits (this can be overridden by providing a combined-diff option or with &lt;code&gt;--no-diff-merges&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c8adea213e6ac01f80c59a6b72ca8bc5d0c4be" translate="yes" xml:space="preserve">
          <source>Note that unreachable, packed objects will remain. If this is not desired, see &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;.</source>
          <target state="translated">请注意，无法到达的打包对象将保留。如果不希望这样做，请参见&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9c873a19166627d45cbe06c1e92f0fc64675a0f" translate="yes" xml:space="preserve">
          <source>Note that users fetching over dumb protocols will have to fetch the whole new pack in order to get any contained object, no matter how many other objects in that pack they already have locally.</source>
          <target state="translated">需要注意的是,用户通过哑巴协议取件时,必须取到整个新的包,才能得到任何包含的对象,不管他们在该包中已经有多少其他对象在本地。</target>
        </trans-unit>
        <trans-unit id="511b177ad0f4f309a1f22f8d5a0729bb57a27072" translate="yes" xml:space="preserve">
          <source>Note that we deliberately chose not to re-code the commit log message when a commit is made to force UTF-8 at the commit object level, because re-coding to UTF-8 is not necessarily a reversible operation.</source>
          <target state="translated">需要注意的是,当提交时,我们特意选择不对提交日志信息进行重新编码,在提交对象层面强制执行UTF-8,因为重新编码为UTF-8并不一定是可逆的操作。</target>
        </trans-unit>
        <trans-unit id="352feed71993cca2768c0de80ab4efdfef627645" translate="yes" xml:space="preserve">
          <source>Note that we pick a single island for each regex to go into, using &quot;last one wins&quot; ordering (which allows repo-specific config to take precedence over user-wide config, and so forth).</source>
          <target state="translated">需要注意的是,我们为每个regex挑选一个单独的岛,使用 &quot;最后一个获胜 &quot;的排序方式(允许repo特定的配置优先于用户范围的配置,等等)。</target>
        </trans-unit>
        <trans-unit id="0f413678af329d8b352f68927252d8a326f2b212" translate="yes" xml:space="preserve">
          <source>Note that when matching against a tree object, attributes are still obtained from working tree, not from the given tree object.</source>
          <target state="translated">请注意,当与树对象进行匹配时,属性仍然是从工作树中获取的,而不是从给定的树对象中获取的。</target>
        </trans-unit>
        <trans-unit id="6f16ff14e66ecdeaed0888755a04ec80e3903de7" translate="yes" xml:space="preserve">
          <source>Note that when providing a &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;, you must use &lt;code&gt;--list&lt;/code&gt;; otherwise the command may be interpreted as branch creation.</source>
          <target state="translated">请注意，提供 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 时，必须使用 &lt;code&gt;--list&lt;/code&gt; ；否则，该命令可以解释为分支创建。</target>
        </trans-unit>
        <trans-unit id="2e31fbecbd095ab339f753f545ee8ad3cdcfd7be" translate="yes" xml:space="preserve">
          <source>Note that when you&amp;rsquo;ve moved or copied a Git repository, your Git index file (which caches various information, notably some of the &quot;stat&quot; information for the files involved) will likely need to be refreshed. So after you do a &lt;code&gt;cp -a&lt;/code&gt; to create a new copy, you&amp;rsquo;ll want to do</source>
          <target state="translated">请注意，在移动或复制Git存储库后，可能需要刷新Git索引文件（该文件缓存各种信息，尤其是所涉及文件的某些&amp;ldquo;状态&amp;rdquo;信息）。因此，在执行 &lt;code&gt;cp -a&lt;/code&gt; 创建新副本之后，您将需要</target>
        </trans-unit>
        <trans-unit id="b6e7add23d70ae9c79a92003e95b0646493f7240" translate="yes" xml:space="preserve">
          <source>Note that without &lt;code&gt;--full-history&lt;/code&gt;, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked.</source>
          <target state="translated">请注意，如果没有 &lt;code&gt;--full-history&lt;/code&gt; ，这仍然会简化合并：如果父项之一是TREESAME，我们将仅遵循该父项，因此合并的另一端永远不会走。</target>
        </trans-unit>
        <trans-unit id="26c6b6e45f05961054f9762544f517daa6e3a44f" translate="yes" xml:space="preserve">
          <source>Note that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected.</source>
          <target state="translated">需要注意的是,如果不进行父子改写,还真谈不上承诺之间的父子关系,所以我们将其显示为断联。</target>
        </trans-unit>
        <trans-unit id="40996350a13d178ee15ae3215e9ae292d6702c1c" translate="yes" xml:space="preserve">
          <source>Note that you can get more information on a packfile by calling &lt;a href=&quot;git-verify-pack&quot;&gt;git-verify-pack[1]&lt;/a&gt;. However, as this command considers only the index file itself, it&amp;rsquo;s both faster and more flexible.</source>
          <target state="translated">请注意，您可以通过调用&lt;a href=&quot;git-verify-pack&quot;&gt;git-verify-pack [1]&lt;/a&gt;获得有关packfile的更多信息。但是，由于此命令仅考虑索引文件本身，因此既更快又更灵活。</target>
        </trans-unit>
        <trans-unit id="191247c1388c3f45dfe82bf6b2f0384fea86edc8" translate="yes" xml:space="preserve">
          <source>Note that you cannot generally put &lt;code&gt;git for-each-ref&lt;/code&gt; directly into the config value, as it does not take a repository path as an argument (but you can wrap the command above in a shell script).</source>
          <target state="translated">注意，通常不能将 &lt;code&gt;git for-each-ref&lt;/code&gt; 直接放入config值中，因为它没有将存储库路径作为参数（但是您可以将以上命令包装在shell脚本中）。</target>
        </trans-unit>
        <trans-unit id="0fb44a035d4df6f6306133b267ae1546e220d2ba" translate="yes" xml:space="preserve">
          <source>Note that you should not do Octopus just because you can. An octopus is a valid thing to do and often makes it easier to view the commit history if you are merging more than two independent changes at the same time. However, if you have merge conflicts with any of the branches you are merging in and need to hand resolve, that is an indication that the development happened in those branches were not independent after all, and you should merge two at a time, documenting how you resolved the conflicts, and the reason why you preferred changes made in one side over the other. Otherwise it would make the project history harder to follow, not easier.</source>
          <target state="translated">请注意,你不应该因为可以做章鱼就做章鱼。八爪鱼是一件很有效的事情,如果你同时合并了两个以上的独立变化,它通常会让你更容易查看提交历史。但是,如果你在合并的任何一个分支有合并冲突,需要手工解决,那就说明这些分支发生的开发毕竟不是独立的,你应该一次合并两个,记录下你是如何解决冲突的,以及你更倾向于一方所做的改动而不是另一方的原因。否则会使项目历史更难遵循,而不是更容易。</target>
        </trans-unit>
        <trans-unit id="482be6a864fbdcc5f9a936e9708b6d9c3eb14ff5" translate="yes" xml:space="preserve">
          <source>Note the addition of the &lt;code&gt;+&lt;/code&gt; sign. Alternatively, you can use the &lt;code&gt;-f&lt;/code&gt; flag to force the remote update, as in:</source>
          <target state="translated">请注意 &lt;code&gt;+&lt;/code&gt; 号的添加。或者，您可以使用 &lt;code&gt;-f&lt;/code&gt; 标志来强制进行远程更新，如下所示：</target>
        </trans-unit>
        <trans-unit id="c14d9654c43dfc38c5ce0e390578cf211f8eb175" translate="yes" xml:space="preserve">
          <source>Note the addition of the &lt;code&gt;+&lt;/code&gt; sign. Alternatively, you can use the &lt;code&gt;-f&lt;/code&gt; flag to force updates of all the fetched branches, as in:</source>
          <target state="translated">请注意 &lt;code&gt;+&lt;/code&gt; 号的添加。或者，您可以使用 &lt;code&gt;-f&lt;/code&gt; 标志来强制更新所有获取的分支，如下所示：</target>
        </trans-unit>
        <trans-unit id="2261964ad436001973909975a060cb501a98c780" translate="yes" xml:space="preserve">
          <source>Note the last point. Do &lt;code&gt;not&lt;/code&gt; use &lt;code&gt;git pull&lt;/code&gt; unless you actually want to merge the remote branch.</source>
          <target state="translated">注意最后一点。千万 &lt;code&gt;not&lt;/code&gt; 使用 &lt;code&gt;git pull&lt;/code&gt; ，除非你确实要合并的远程分支。</target>
        </trans-unit>
        <trans-unit id="b5d534f9876445dbbed162e13c3b9e1bade912b4" translate="yes" xml:space="preserve">
          <source>Note the major differences in &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, and &lt;code&gt;Q&lt;/code&gt; over &lt;code&gt;--full-history&lt;/code&gt;:</source>
          <target state="translated">请注意，在重大分歧 &lt;code&gt;N&lt;/code&gt; ， &lt;code&gt;P&lt;/code&gt; 和 &lt;code&gt;Q&lt;/code&gt; 在 &lt;code&gt;--full-history&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="592ed4ba86d62c504859114fd8d03df0827a06fa" translate="yes" xml:space="preserve">
          <source>Note the quotes around &lt;code&gt;*.c&lt;/code&gt;. The file &lt;code&gt;hello.c&lt;/code&gt; will also be checked out, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell).</source>
          <target state="translated">注意 &lt;code&gt;*.c&lt;/code&gt; 周围的引号。即使文件 &lt;code&gt;hello.c&lt;/code&gt; 不再存在于工作树中，也将被检出，这是因为文件globbing用于匹配索引中的条目（而不是外壳程序在工作树中的条目）。</target>
        </trans-unit>
        <trans-unit id="d840183324e7e2c4b1d9b149ae89bf837a67da9c" translate="yes" xml:space="preserve">
          <source>Note the quotes around &lt;code&gt;*.c&lt;/code&gt;. The file &lt;code&gt;hello.c&lt;/code&gt; will also be restored, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell).</source>
          <target state="translated">注意 &lt;code&gt;*.c&lt;/code&gt; 周围的引号。即使文件 &lt;code&gt;hello.c&lt;/code&gt; 不再位于工作树中，也将被还原，因为文件globbing用于匹配索引中的条目（而不是外壳程序在工作树中的条目）。</target>
        </trans-unit>
        <trans-unit id="86811ec658abf1645177c2f89c78cd1610e7ea04" translate="yes" xml:space="preserve">
          <source>Note what happens to the different &lt;code&gt;git diff-*&lt;/code&gt; versions here. After we&amp;rsquo;ve updated &lt;code&gt;hello&lt;/code&gt; in the index, &lt;code&gt;git diff-files -p&lt;/code&gt; now shows no differences, but &lt;code&gt;git diff-index -p HEAD&lt;/code&gt; still &lt;strong&gt;does&lt;/strong&gt; show that the current state is different from the state we committed. In fact, now &lt;code&gt;git diff-index&lt;/code&gt; shows the same difference whether we use the &lt;code&gt;--cached&lt;/code&gt; flag or not, since now the index is coherent with the working tree.</source>
          <target state="translated">注意这里不同的 &lt;code&gt;git diff-*&lt;/code&gt; 版本会发生什么。我们更新后 &lt;code&gt;hello&lt;/code&gt; 索引， &lt;code&gt;git diff-files -p&lt;/code&gt; 现在显示无显着差异，但 &lt;code&gt;git diff-index -p HEAD&lt;/code&gt; 仍然&lt;strong&gt;不&lt;/strong&gt;表明当前的状态是我们犯下的状态不同。实际上，无论是否使用 &lt;code&gt;--cached&lt;/code&gt; 标志，现在 &lt;code&gt;git diff-index&lt;/code&gt; 都显示相同的区别，因为现在索引与工作树是一致的。</target>
        </trans-unit>
        <trans-unit id="c96f5bf9205aae211cb148d5f8bcf4fb9ebed15b" translate="yes" xml:space="preserve">
          <source>Note, by the way, that lots of commands take a tree as an argument. But as we can see above, a tree can be referred to in many different ways&amp;mdash;​by the SHA-1 name for that tree, by the name of a commit that refers to the tree, by the name of a branch whose head refers to that tree, etc.--and most such commands can accept any of these names.</source>
          <target state="translated">请注意，顺便说一句，许多命令都将树作为参数。但是正如我们在上面看到的那样，可以用许多不同的方式来引用树-通过树的SHA-1名称，通过引用树的提交名称，通过其头部引用的分支的名称来引用到该树等），并且大多数此类命令可以接受这些名称中的任何一个。</target>
        </trans-unit>
        <trans-unit id="ba28d9bd22f696c9f9b774765c5cbeba6fcd1342" translate="yes" xml:space="preserve">
          <source>Note, for the reasons stated above usage of context-free patches is discouraged.</source>
          <target state="translated">请注意,基于上述原因,不鼓励使用无上下文补丁。</target>
        </trans-unit>
        <trans-unit id="22eddd855ac86c24360d06b5276ff8c7e192d879" translate="yes" xml:space="preserve">
          <source>Note, this safety check does not mean that a checkout will generate a file identical to the original file for a different setting of &lt;code&gt;core.eol&lt;/code&gt; and &lt;code&gt;core.autocrlf&lt;/code&gt;, but only for the current one. For example, a text file with &lt;code&gt;LF&lt;/code&gt; would be accepted with &lt;code&gt;core.eol=lf&lt;/code&gt; and could later be checked out with &lt;code&gt;core.eol=crlf&lt;/code&gt;, in which case the resulting file would contain &lt;code&gt;CRLF&lt;/code&gt;, although the original file contained &lt;code&gt;LF&lt;/code&gt;. However, in both work trees the line endings would be consistent, that is either all &lt;code&gt;LF&lt;/code&gt; or all &lt;code&gt;CRLF&lt;/code&gt;, but never mixed. A file with mixed line endings would be reported by the &lt;code&gt;core.safecrlf&lt;/code&gt; mechanism.</source>
          <target state="translated">请注意，此安全检查并不意味着对于不同的 &lt;code&gt;core.eol&lt;/code&gt; 和 &lt;code&gt;core.autocrlf&lt;/code&gt; 设置，签出将生成与原始文件相同的文件，而仅针对当前文件。例如，带有 &lt;code&gt;LF&lt;/code&gt; 的文本文件将被 &lt;code&gt;core.eol=lf&lt;/code&gt; 接受，随后可以被 &lt;code&gt;core.eol=crlf&lt;/code&gt; 检出，在这种情况下，尽管原始文件包含 &lt;code&gt;LF&lt;/code&gt; ，但结果文件将包含 &lt;code&gt;CRLF&lt;/code&gt; 。但是，在两个工作树中，行尾都是一致的，即全部为 &lt;code&gt;LF&lt;/code&gt; 或全部为 &lt;code&gt;CRLF&lt;/code&gt; ，但绝不混合。 &lt;code&gt;core.safecrlf&lt;/code&gt; 将报告包含混合行尾的文件 机制。</target>
        </trans-unit>
        <trans-unit id="955b317bd13857ee21eddce08c9664927a950a2e" translate="yes" xml:space="preserve">
          <source>Note. A single level of backslashes are eaten by the configuration file parser, so you would need to double the backslashes; the pattern above picks a line that begins with a backslash, and zero or more occurrences of &lt;code&gt;sub&lt;/code&gt; followed by &lt;code&gt;section&lt;/code&gt; followed by open brace, to the end of line.</source>
          <target state="translated">注意。配置文件解析器只使用一个级别的反斜杠，因此您需要将反斜杠加倍。上面的模式选择以反斜杠开头的行，然后出现零次或多次出现 &lt;code&gt;sub&lt;/code&gt; ,然后是 &lt;code&gt;section&lt;/code&gt; ,然后是大括号，直到行尾。</target>
        </trans-unit>
        <trans-unit id="c3a8d5b6840faaf677f5d3f6a79125e45b041b0b" translate="yes" xml:space="preserve">
          <source>Note. When the &quot;-C&quot; option is used with &lt;code&gt;--find-copies-harder&lt;/code&gt; option, &lt;code&gt;git diff-*&lt;/code&gt; commands feed unmodified filepairs to diffcore mechanism as well as modified ones. This lets the copy detector consider unmodified files as copy source candidates at the expense of making it slower. Without &lt;code&gt;--find-copies-harder&lt;/code&gt;, &lt;code&gt;git diff-*&lt;/code&gt; commands can detect copies only if the file that was copied happened to have been modified in the same changeset.</source>
          <target state="translated">注意。当&amp;ldquo; -C&amp;rdquo;选项与 &lt;code&gt;--find-copies-harder&lt;/code&gt; 选项一起使用时， &lt;code&gt;git diff-*&lt;/code&gt; 命令将未修改的文件对以及已修改的文件对馈入diffcore机制。这使复制检测器将未修改的文件视为候选复制源，但代价是使其变慢。如果没有 &lt;code&gt;--find-copies-harder&lt;/code&gt; &lt;code&gt;git diff-*&lt;/code&gt; ，则git diff- *命令仅在复制的文件碰巧已在同一变更集中被修改时，才能检测到副本。</target>
        </trans-unit>
        <trans-unit id="9ed1ac27dff5378ed96f590f4322050a04cabf6d" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;git revert&lt;/code&gt; is used to record some new commits to reverse the effect of some earlier commits (often only a faulty one). If you want to throw away all uncommitted changes in your working directory, you should see &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;, particularly the &lt;code&gt;--hard&lt;/code&gt; option. If you want to extract specific files as they were in another commit, you should see &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;, specifically the &lt;code&gt;--source&lt;/code&gt; option. Take care with these alternatives as both will discard uncommitted changes in your working directory.</source>
          <target state="translated">注意： &lt;code&gt;git revert&lt;/code&gt; 用于记录一些新的提交，以逆转某些较早提交的效果（通常只有一个错误的提交）。如果要丢弃工作目录中所有未提交的更改，则应看到&lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt;，尤其是 &lt;code&gt;--hard&lt;/code&gt; 选项。如果要提取特定文件，就像在另一个提交中一样，则应该看到&lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt;，特别是 &lt;code&gt;--source&lt;/code&gt; 选项。请谨慎使用这些替代方法，因为这两种方法都会丢弃工作目录中未提交的更改。</target>
        </trans-unit>
        <trans-unit id="6007883f602581f1393822506c41cbfbfd02c805" translate="yes" xml:space="preserve">
          <source>Note: A thin pack violates the packed archive format by omitting required objects and is thus unusable by Git without making it self-contained. Use &lt;code&gt;git index-pack --fix-thin&lt;/code&gt; (see &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack[1]&lt;/a&gt;) to restore the self-contained property.</source>
          <target state="translated">注意：精简包通过省略必需的对象而违反了打包的存档格式，因此，如果不使其独立，则Git无法使用它。使用 &lt;code&gt;git index-pack --fix-thin&lt;/code&gt; （请参阅&lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack [1]&lt;/a&gt;）恢复独立的属性。</target>
        </trans-unit>
        <trans-unit id="1f8f5701942fbb7ebefa9dee3f4f37f4528c7cfd" translate="yes" xml:space="preserve">
          <source>Note: Make sure you quote the result when passing it to &lt;code&gt;eval&lt;/code&gt;. See below for an example.</source>
          <target state="translated">注意：确保将结果传递给 &lt;code&gt;eval&lt;/code&gt; 时引用它。请参阅下面的示例。</target>
        </trans-unit>
        <trans-unit id="b0f0e4e61a2bb004cf3ec68d5169e8ba972a47ee" translate="yes" xml:space="preserve">
          <source>Note: Newer CVS versions (&amp;gt;= 1.12.11) also support specifying CVS_SERVER directly in CVSROOT like</source>
          <target state="translated">注意：较新的CVS版本（&amp;gt; = 1.12.11）也支持直接在CVSROOT中指定CVS_SERVER，例如</target>
        </trans-unit>
        <trans-unit id="b833243d544e1089f2767ea8843cab2eed5526b2" translate="yes" xml:space="preserve">
          <source>Note: Porcelain commands such as &lt;code&gt;git gc&lt;/code&gt; (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;), &lt;code&gt;git repack&lt;/code&gt; (see &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;) pass this option by default in modern Git when they put objects in your repository into pack files. So does &lt;code&gt;git bundle&lt;/code&gt; (see &lt;a href=&quot;git-bundle&quot;&gt;git-bundle[1]&lt;/a&gt;) when it creates a bundle.</source>
          <target state="translated">注意：诸如 &lt;code&gt;git gc&lt;/code&gt; （请参阅&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;）， &lt;code&gt;git repack&lt;/code&gt; （请参阅&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;）之类的瓷器命令在将存储库中的对象放入打包文件时，默认情况下会通过此选项。 &lt;code&gt;git bundle&lt;/code&gt; 创建捆绑时也是如此（请参阅&lt;a href=&quot;git-bundle&quot;&gt;git-bundle [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7a04bc9af081bc88d648e6675a2308737bd31c23" translate="yes" xml:space="preserve">
          <source>Note: Some inetd servers let you specify the name of the executable independently of the value of argv[0] (i.e. the name the program assumes it was executed with). In this case the correct line in /etc/inetd.conf looks like</source>
          <target state="translated">注意:有些 inetd 服务器允许你指定可执行文件的名称,而不是 argv[0]的值 (也就是程序假设执行时的名称)。在这种情况下,/etc/inetd.conf中的正确行数是这样的</target>
        </trans-unit>
        <trans-unit id="722ccad077353010f3a3bf5b634c417679782a2c" translate="yes" xml:space="preserve">
          <source>Note: Whenever the clean filter is changed, the repo should be renormalized: $ git add --renormalize .</source>
          <target state="translated">注意:无论何时改变清洁过滤器,都应该对repo进行重新归一化:$ git add --renormalize 。</target>
        </trans-unit>
        <trans-unit id="e979029bca285fbda95b190d7e0a6ad42b034f7b" translate="yes" xml:space="preserve">
          <source>Note: the first command (&lt;code&gt;label onto&lt;/code&gt;) labels the revision onto which the commits are rebased; The name &lt;code&gt;onto&lt;/code&gt; is just a convention, as a nod to the &lt;code&gt;--onto&lt;/code&gt; option.</source>
          <target state="translated">注意：第一个命令（ &lt;code&gt;label onto&lt;/code&gt; ）标记提交所依据的修订版本；名称 &lt;code&gt;onto&lt;/code&gt; 的名称只是约定，这是对 &lt;code&gt;--onto&lt;/code&gt; 选项的致意。</target>
        </trans-unit>
        <trans-unit id="c1bc321618eb470344ec0a0359d287ae90474ae5" translate="yes" xml:space="preserve">
          <source>Note: the following core Perl modules that may be installed with your distribution of Perl are required: MIME::Base64, MIME::QuotedPrint, Net::Domain and Net::SMTP. These additional Perl modules are also required: Authen::SASL and Mail::Address.</source>
          <target state="translated">注意:以下是需要安装在你的Perl发行版中的核心Perl模块。MIME::Base64,MIME::QuotedPrint,Net::Domain 和 Net::SMTP。这些附加的Perl模块也是必须的。Authen::SASL 和 Mail::Address。</target>
        </trans-unit>
        <trans-unit id="9ca0395056bb808a73d2de7297fac7a555e73c25" translate="yes" xml:space="preserve">
          <source>Note: you can specify the default pretty format in the repository configuration (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">注意：您可以在存储库配置中指定默认的漂亮格式（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="399df4ce8f932f9b96c0fdefbfc88e37bceafef0" translate="yes" xml:space="preserve">
          <source>Note: you need to ensure each user that is going to invoke &lt;code&gt;git-cvsserver&lt;/code&gt; has write access to the log file and to the database (see &lt;a href=&quot;#dbbackend&quot;&gt;Database Backend&lt;/a&gt;. If you want to offer write access over SSH, the users of course also need write access to the Git repository itself.</source>
          <target state="translated">注意：您需要确保每个将要调用 &lt;code&gt;git-cvsserver&lt;/code&gt; 的用户都具有对日志文件和数据库的写访问权限（请参阅&lt;a href=&quot;#dbbackend&quot;&gt;数据库后端&lt;/a&gt;。如果要通过SSH提供写访问权限，那么这些用户当然也需要写访问权限到Git仓库本身。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="803fb7d2ab5d83b44291b7856ec7ac09a4ad4990" translate="yes" xml:space="preserve">
          <source>Notes can also be added to patches prepared with &lt;code&gt;git format-patch&lt;/code&gt; by using the &lt;code&gt;--notes&lt;/code&gt; option. Such notes are added as a patch commentary after a three dash separator line.</source>
          <target state="translated">也可以使用 &lt;code&gt;--notes&lt;/code&gt; 选项将注释添加到使用 &lt;code&gt;git format-patch&lt;/code&gt; 准备的修补程序中。这些注释在三横线分隔线之后作为补丁注释添加。</target>
        </trans-unit>
        <trans-unit id="680f18d9848c14869bd7dca451d5f596480f4677" translate="yes" xml:space="preserve">
          <source>Notes merge strategies</source>
          <target state="translated">注释合并策略</target>
        </trans-unit>
        <trans-unit id="abd4e292c73314f22de94f0e2806350a1ebe4452" translate="yes" xml:space="preserve">
          <source>Notes on frequently confused options</source>
          <target state="translated">关于经常混淆的选项的说明</target>
        </trans-unit>
        <trans-unit id="2ae531e195e6eb05828dc645d74752ea4fda83e4" translate="yes" xml:space="preserve">
          <source>Notes on threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5aa58376045f00b2abde3758c9ee9232861fade" translate="yes" xml:space="preserve">
          <source>Notes ref to read and manipulate instead of &lt;code&gt;refs/notes/commits&lt;/code&gt;. Must be an unabbreviated ref name. This setting can be overridden through the environment and command line.</source>
          <target state="translated">Notes ref可以读取和操作，而不是 &lt;code&gt;refs/notes/commits&lt;/code&gt; 。必须是缩写的引用名称。可以通过环境和命令行覆盖此设置。</target>
        </trans-unit>
        <trans-unit id="27c7345a105341e9d7ed2a9f6b06c674d31c0796" translate="yes" xml:space="preserve">
          <source>Notice all types of potential whitespace errors known to Git. The tab width is taken from the value of the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable.</source>
          <target state="translated">注意Git已知的所有类型的潜在空白错误。制表符宽度取自 &lt;code&gt;core.whitespace&lt;/code&gt; 配置变量的值。</target>
        </trans-unit>
        <trans-unit id="b1fa74b0ca5d38d82ab602be416ab241bc186864" translate="yes" xml:space="preserve">
          <source>Notice that regardless of which checkout command we use, &lt;code&gt;HEAD&lt;/code&gt; now refers directly to commit &lt;code&gt;b&lt;/code&gt;. This is known as being in detached &lt;code&gt;HEAD&lt;/code&gt; state. It means simply that &lt;code&gt;HEAD&lt;/code&gt; refers to a specific commit, as opposed to referring to a named branch. Let&amp;rsquo;s see what happens when we create a commit:</source>
          <target state="translated">注意，无论我们使用哪种checkout命令， &lt;code&gt;HEAD&lt;/code&gt; 现在都直接引用commit &lt;code&gt;b&lt;/code&gt; 。这称为处于分离 &lt;code&gt;HEAD&lt;/code&gt; 状态。这仅表示 &lt;code&gt;HEAD&lt;/code&gt; 引用了特定的提交，而不是引用了命名分支。让我们看看创建提交时会发生什么：</target>
        </trans-unit>
        <trans-unit id="394d5767b4ce0798e4d7b91dc89c97c41a6b7f18" translate="yes" xml:space="preserve">
          <source>Notice that since &lt;code&gt;M&lt;/code&gt; is reachable from &lt;code&gt;R&lt;/code&gt;, the edge from &lt;code&gt;N&lt;/code&gt; to &lt;code&gt;M&lt;/code&gt; was simplified away. However, &lt;code&gt;N&lt;/code&gt; still appears in the history as an important commit because it &quot;pulled&quot; the change &lt;code&gt;R&lt;/code&gt; into the main branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="223ae08c12689ce4cda40425ac912a2b7bc15955" translate="yes" xml:space="preserve">
          <source>Notify the helper this is a clone request (i.e. the current repository is guaranteed empty).</source>
          <target state="translated">通知帮助者这是一个克隆请求(即保证当前仓库是空的)。</target>
        </trans-unit>
        <trans-unit id="4abfc187ad76ac88063d3dc9dd98a5854ac68fcf" translate="yes" xml:space="preserve">
          <source>Now add the changes to the index that you want to have in the first commit. You can use &lt;code&gt;git add&lt;/code&gt; (possibly interactively) or &lt;code&gt;git gui&lt;/code&gt; (or both) to do that.</source>
          <target state="translated">现在，将更改添加到您希望在第一次提交中拥有的索引。您可以使用 &lt;code&gt;git add&lt;/code&gt; （可能是交互方式）或 &lt;code&gt;git gui&lt;/code&gt; （或两者都使用）来做到这一点。</target>
        </trans-unit>
        <trans-unit id="f89d262ba51a934099d56714cbb679d531203dd2" translate="yes" xml:space="preserve">
          <source>Now clone the superproject:</source>
          <target state="translated">现在克隆超级项目。</target>
        </trans-unit>
        <trans-unit id="ba793c9ae00cb4d237b36de220bcaff0d64b7a28" translate="yes" xml:space="preserve">
          <source>Now create the branches in which you are going to work; these start out at the current tip of origin/master branch, and should be set up (using the &lt;code&gt;--track&lt;/code&gt; option to &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;) to merge changes in from Linus by default.</source>
          <target state="translated">现在创建要在其中工作的分支；这些开始于当前的origin / master分支尖端，并且应该进行设置（使用&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;的 &lt;code&gt;--track&lt;/code&gt; 选项）以默认情况下合并来自Linus的更改。</target>
        </trans-unit>
        <trans-unit id="b3aa6a5493fd6ad1a98101f846b1686abf42b2c1" translate="yes" xml:space="preserve">
          <source>Now create the superproject and add all the submodules:</source>
          <target state="translated">现在创建超级项目并添加所有的子模块。</target>
        </trans-unit>
        <trans-unit id="aec2ee2ebf7f0a1017c29bcb872a25ae6bf7b23d" translate="yes" xml:space="preserve">
          <source>Now is a good point to take a break to let this information sink in.</source>
          <target state="translated">现在是一个很好的点,可以休息一下,让这些信息沉淀下来。</target>
        </trans-unit>
        <trans-unit id="8125d3bd8f5c390de8746d2ef58ce50b7de72c0b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s suppose that commit J is bad and commit G is good and that we apply the bisection algorithm like it has been previously described.</source>
          <target state="translated">现在让我们假设提交J是错误的，提交G是良好的，并且像前面已经描述的那样应用了二等分算法。</target>
        </trans-unit>
        <trans-unit id="880aeec71bcb81a6f397f1be442543fc2e21cab4" translate="yes" xml:space="preserve">
          <source>Now suppose that Joe wants his middle name initial used, and Jane prefers her family name fully spelled out. A proper &lt;code&gt;.mailmap&lt;/code&gt; file would look like:</source>
          <target state="translated">现在假设Joe希望使用他的中间名作为首字母缩写，而Jane则希望将她的姓氏写清楚。正确的 &lt;code&gt;.mailmap&lt;/code&gt; 文件如下所示：</target>
        </trans-unit>
        <trans-unit id="3e7c06961fbf7a9468c5f87e472b9bdf95e1fa5a" translate="yes" xml:space="preserve">
          <source>Now to apply some patches from the community. Think of a short snappy name for a branch to hold this patch (or related group of patches), and create a new branch from a recent stable tag of Linus&amp;rsquo;s branch. Picking a stable base for your branch will: 1) help you: by avoiding inclusion of unrelated and perhaps lightly tested changes 2) help future bug hunters that use &lt;code&gt;git bisect&lt;/code&gt; to find problems</source>
          <target state="translated">现在应用社区中的一些补丁。想一个分支的简短活泼名称来保存此补丁程序（或相关的补丁程序组），然后根据Linus分支的最近稳定标记创建一个新分支。挑选一个稳定的基地，为您的分支将：1）帮助您：通过避免无关包容，或许轻轻测试变化2）使用帮助未来的bug猎人 &lt;code&gt;git bisect&lt;/code&gt; 发现问题</target>
        </trans-unit>
        <trans-unit id="31a13e21421ef92e8ef4a0a89bea77231f7d36fb" translate="yes" xml:space="preserve">
          <source>Now use &lt;code&gt;git submodule update&lt;/code&gt; to clone the repositories and check out the commits specified in the superproject:</source>
          <target state="translated">现在使用 &lt;code&gt;git submodule update&lt;/code&gt; 克隆存储库，并检查超级项目中指定的提交：</target>
        </trans-unit>
        <trans-unit id="93f7a0302cd464e3e88673ccf5b8a8b034507a50" translate="yes" xml:space="preserve">
          <source>Now we are ready to experiment with the merge by hand.</source>
          <target state="translated">现在我们准备用手来实验合并。</target>
        </trans-unit>
        <trans-unit id="0479e792f6adb8abb7cacffe33ca0f7a5b48ab2f" translate="yes" xml:space="preserve">
          <source>Now we will suppose that there is only one &quot;first bad commit&quot;. This means that all its descendants are &quot;bad&quot; and all the other commits are &quot;good&quot;. And we will suppose that all commits have an equal probability of being good or bad, or of being the first bad commit, so knowing the state of c commits gives always the same amount of information wherever these c commits are on the graph and whatever c is. (So we suppose that these commits being for example on a branch or near a good or a bad commit does not give more or less information).</source>
          <target state="translated">现在我们假设只有一个 &quot;第一个坏的提交&quot;。这意味着它的所有子孙都是 &quot;坏 &quot;的,而所有其他的提交都是 &quot;好 &quot;的。我们假设所有的提交都有相同的概率是好的或坏的,或者是第一个坏的提交,所以知道c个提交的状态,无论这些c个提交在图上的什么地方,也无论c是什么,得到的信息量总是相同的。(所以我们假设这些提交在一个分支上,或者靠近一个好的或坏的提交,并不会提供更多或更少的信息)。</target>
        </trans-unit>
        <trans-unit id="16cb16561e679da512d88420e76326b5c722ec8f" translate="yes" xml:space="preserve">
          <source>Now when the background process runs &lt;code&gt;git fetch origin&lt;/code&gt; the references on &lt;code&gt;origin-push&lt;/code&gt; won&amp;rsquo;t be updated, and thus commands like:</source>
          <target state="translated">现在，当后台进程运行 &lt;code&gt;git fetch origin&lt;/code&gt; 时， &lt;code&gt;origin-push&lt;/code&gt; 上的引用将不会更新，因此命令如下：</target>
        </trans-unit>
        <trans-unit id="3ecf9739a1d0abf420c43be7ddca1b7fc46c48f7" translate="yes" xml:space="preserve">
          <source>Now you apply the patch(es), run some tests, and commit the change(s). If the patch is a multi-part series, then you should apply each as a separate commit to this branch.</source>
          <target state="translated">现在,您可以应用这些补丁,运行一些测试,然后提交这些更改。如果这个补丁是一个多部分的系列,那么你应该将每个补丁作为一个单独的提交提交到这个分支。</target>
        </trans-unit>
        <trans-unit id="ac8b110d69f8df7d9503ad0a18549a8731f4daf9" translate="yes" xml:space="preserve">
          <source>Now you are wiser, because you know that it happened 940 revisions before v0.99.</source>
          <target state="translated">现在你聪明了,因为你知道在v0.99之前发生了940次修订。</target>
        </trans-unit>
        <trans-unit id="54796c29834d872153c55921bf00540d7c6165a5" translate="yes" xml:space="preserve">
          <source>Now you can proceed with the creation of the feature release. Apply a tag to the tip of &lt;code&gt;master&lt;/code&gt; indicating the release version:</source>
          <target state="translated">现在，您可以继续创建功能版本。在 &lt;code&gt;master&lt;/code&gt; 版的顶端应用标签，以指示发行版本：</target>
        </trans-unit>
        <trans-unit id="d60447094204d4dec9840c772eacade572f28205" translate="yes" xml:space="preserve">
          <source>Now you know that blob 4b9458b3 is missing, and that the tree 2d9263c6 points to it. If you could find just one copy of that missing blob object, possibly in some other repository, you could move it into &lt;code&gt;.git/objects/4b/9458b3&amp;hellip;​&lt;/code&gt; and be done. Suppose you can&amp;rsquo;t. You can still examine the tree that pointed to it with &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt;, which might output something like:</source>
          <target state="translated">现在您知道缺少blob 4b9458b3，并且树2d9263c6指向它。如果你能找到只有一个失踪Blob对象的副本，可能在其他一些库，你可以将其移动到 &lt;code&gt;.git/objects/4b/9458b3&amp;hellip;​&lt;/code&gt; 和完成。假设你做不到。您仍然可以使用&lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt;检查指向它的树，该树可能会输出以下内容：</target>
        </trans-unit>
        <trans-unit id="27bdc85bfa21b19b41e38ad33e104e7c138a6d4d" translate="yes" xml:space="preserve">
          <source>Now you know that blob 4b9458b3 is missing, and that the tree 2d9263c6 points to it. If you could find just one copy of that missing blob object, possibly in some other repository, you could move it into &lt;code&gt;.git/objects/4b/9458b3...&lt;/code&gt; and be done. Suppose you can&amp;rsquo;t. You can still examine the tree that pointed to it with &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt;, which might output something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93b9bdc902ddf8466cfefc51dc1f28429545152" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;ve split out many of the changes into their own commits, and might no longer use the patch mode of &lt;code&gt;git add&lt;/code&gt;, in order to select all remaining uncommitted changes.</source>
          <target state="translated">现在，您已将许多更改拆分为自己的提交，并且可能不再使用 &lt;code&gt;git add&lt;/code&gt; 的修补程序模式来选择所有剩余的未提交的更改。</target>
        </trans-unit>
        <trans-unit id="69b6ae43249b3d4c8e61d7b20084413cd49e5e3e" translate="yes" xml:space="preserve">
          <source>Now, for the meat:</source>
          <target state="translated">现在,对于肉。</target>
        </trans-unit>
        <trans-unit id="4449e60d3fdd6703a4970ef116187e4c17d80dc4" translate="yes" xml:space="preserve">
          <source>Now, in this case we&amp;rsquo;ve intentionally created a situation where the merge will need to be fixed up by hand, though, so Git will do as much of it as it can automatically (which in this case is just merge the &lt;code&gt;example&lt;/code&gt; file, which had no differences in the &lt;code&gt;mybranch&lt;/code&gt; branch), and say:</source>
          <target state="translated">现在，在这种情况下，我们故意创建了一种情况，需要手动解决合并问题，因此Git会自动执行尽可能多的操作（在这种情况下，只是合并 &lt;code&gt;example&lt;/code&gt; 文件，在 &lt;code&gt;mybranch&lt;/code&gt; 分支中没有任何区别），然后说：</target>
        </trans-unit>
        <trans-unit id="93036e7630aadf8fab80b9b1079ffb3d1ea1e18f" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s pretend you are the one who did all the work in &lt;code&gt;mybranch&lt;/code&gt;, and the fruit of your hard work has finally been merged to the &lt;code&gt;master&lt;/code&gt; branch. Let&amp;rsquo;s go back to &lt;code&gt;mybranch&lt;/code&gt;, and run &lt;code&gt;git merge&lt;/code&gt; to get the &quot;upstream changes&quot; back to your branch.</source>
          <target state="translated">现在，让我们假设您是在 &lt;code&gt;mybranch&lt;/code&gt; 中完成所有工作的人，而您辛勤工作的成果终于被合并到 &lt;code&gt;master&lt;/code&gt; 分支中。让我们回到 &lt;code&gt;mybranch&lt;/code&gt; ，然后运行 &lt;code&gt;git merge&lt;/code&gt; 将&amp;ldquo;上游更改&amp;rdquo;返回到您的分支。</target>
        </trans-unit>
        <trans-unit id="7c23965b9cba90dec960d959f0eea85b60ea2b28" translate="yes" xml:space="preserve">
          <source>Now, since we&amp;rsquo;ve updated &lt;code&gt;hello&lt;/code&gt; in the index, we can commit the new version. We could do it by writing the tree by hand again, and committing the tree (this time we&amp;rsquo;d have to use the &lt;code&gt;-p HEAD&lt;/code&gt; flag to tell commit that the HEAD was the &lt;strong&gt;parent&lt;/strong&gt; of the new commit, and that this wasn&amp;rsquo;t an initial commit any more), but you&amp;rsquo;ve done that once already, so let&amp;rsquo;s just use the helpful script this time:</source>
          <target state="translated">现在，由于我们已经更新了索引中的 &lt;code&gt;hello&lt;/code&gt; ，因此可以提交新版本。我们可以通过再次手动编写树并提交树来完成此操作（这一次，我们必须使用 &lt;code&gt;-p HEAD&lt;/code&gt; 标志来告诉提交HEAD是新提交的&lt;strong&gt;父级&lt;/strong&gt;，而这不是再进行一次初始提交），但您已经完成了一次，因此，这次我们只使用有用的脚本：</target>
        </trans-unit>
        <trans-unit id="dfab069f398c1bff7a8b8aa3dadd95d2ce84088a" translate="yes" xml:space="preserve">
          <source>Now, to make it a bit more interesting, let&amp;rsquo;s assume that somebody else does some work in the original branch, and simulate that by going back to the master branch, and editing the same file differently there:</source>
          <target state="translated">现在，让它变得更有趣，让我们假设其他人在原始分支中做了一些工作，并通过回到master分支并在那里不同地编辑相同文件来模拟该工作：</target>
        </trans-unit>
        <trans-unit id="83bf1df5f5028baeb9804ff8b012e2bfb43363e7" translate="yes" xml:space="preserve">
          <source>Now, we want to go to the next stage in Git, which is to take the files that Git knows about in the index, and commit them as a real tree. We do that in two phases: creating a &lt;code&gt;tree&lt;/code&gt; object, and committing that &lt;code&gt;tree&lt;/code&gt; object as a &lt;code&gt;commit&lt;/code&gt; object together with an explanation of what the tree was all about, along with information of how we came to that state.</source>
          <target state="translated">现在，我们要进入Git的下一个阶段，即将Git知道的文件放入索引中，并将其提交为一棵真正的树。我们分两个阶段进行操作：创建一个 &lt;code&gt;tree&lt;/code&gt; 对象，并将该 &lt;code&gt;tree&lt;/code&gt; 对象作为 &lt;code&gt;commit&lt;/code&gt; 对象进行提交，同时对树的含义进行解释，并提供有关如何达到该状态的信息。</target>
        </trans-unit>
        <trans-unit id="4b50314ab323fb71cb3292dbd2b0326c17673414" translate="yes" xml:space="preserve">
          <source>Now, you will get the rewritten history saved in HEAD.</source>
          <target state="translated">现在,你将得到保存在HEAD中的重写历史。</target>
        </trans-unit>
        <trans-unit id="575836ebc8e262c11aa86a9dd4e0c52f7d072bcd" translate="yes" xml:space="preserve">
          <source>Now, you&amp;rsquo;ve got two branches, and you decide that you want to merge the work done. Before we do that, let&amp;rsquo;s introduce a cool graphical tool that helps you view what&amp;rsquo;s going on:</source>
          <target state="translated">现在，您有两个分支，您决定要合并已完成的工作。在此之前，我们先介绍一个很酷的图形工具，以帮助您查看正在发生的事情：</target>
        </trans-unit>
        <trans-unit id="910f1e558e60364937a941e26d7def6b701f836e" translate="yes" xml:space="preserve">
          <source>Nowadays though gitweb should create HTML base tag when needed (to set base URI for relative links), so it should work automatically.</source>
          <target state="translated">不过现在gitweb应该会在需要的时候创建HTML基础标签(为相对链接设置基础URI),所以它应该会自动工作。</target>
        </trans-unit>
        <trans-unit id="9a11d4479b92e7b2c9a9fc979b41f6f7eb2a1edf" translate="yes" xml:space="preserve">
          <source>Nowadays, &lt;code&gt;git log&lt;/code&gt; is a builtin, which means that it is &lt;code&gt;contained&lt;/code&gt; in the command &lt;code&gt;git&lt;/code&gt;. The source side of a builtin is</source>
          <target state="translated">如今， &lt;code&gt;git log&lt;/code&gt; 是内置的，这意味着它 &lt;code&gt;contained&lt;/code&gt; 在命令 &lt;code&gt;git&lt;/code&gt; 中。内置的源端是</target>
        </trans-unit>
        <trans-unit id="33e31083ab9551e7141ee8a3ee7a0a4d045c20a2" translate="yes" xml:space="preserve">
          <source>Number of bytes of a pack file to map into memory in a single mapping operation. Larger window sizes may allow your system to process a smaller number of large pack files more quickly. Smaller window sizes will negatively affect performance due to increased calls to the operating system&amp;rsquo;s memory manager, but may improve performance when accessing a large number of large pack files.</source>
          <target state="translated">在单个映射操作中要映射到内存中的打包文件的字节数。较大的窗口大小可以使您的系统更快地处理少量的大包文件。由于增加了对操作系统内存管理器的调用，较小的窗口大小将对性能产生负面影响，但在访问大量大文件包文件时可能会提高性能。</target>
        </trans-unit>
        <trans-unit id="782270330831f0728fbf1b39424dcd7ac04c3bcf" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. If unset (or set to 0), 8 threads are used by default (for now).</source>
          <target state="translated">要使用的grep worker线程数,如果未设置(或设置为0),默认使用8个线程。如果未设置(或设置为0),默认使用8个线程(目前)。</target>
        </trans-unit>
        <trans-unit id="07386a7e3f4686f698d276d122f56af1a564e2f6" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. If unset (or set to 0), Git will use as many threads as the number of logical cores available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f7cd4c72eff1cd06e6ea960c75592f7883408d" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. See &lt;code&gt;grep.threads&lt;/code&gt; in &lt;a href=&quot;git-grep&quot;&gt;git-grep[1]&lt;/a&gt; for more information.</source>
          <target state="translated">要使用的grep工作线程数。见 &lt;code&gt;grep.threads&lt;/code&gt; 在&lt;a href=&quot;git-grep&quot;&gt;GIT-grep的[1]&lt;/a&gt;获得更多信息。</target>
        </trans-unit>
        <trans-unit id="340883bf973e4a0a0a15928c3b44200ef6d0edac" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. See &lt;code&gt;grep.threads&lt;/code&gt; in &lt;code&gt;CONFIGURATION&lt;/code&gt; for more information.</source>
          <target state="translated">要使用的grep工作线程数。见 &lt;code&gt;grep.threads&lt;/code&gt; 在 &lt;code&gt;CONFIGURATION&lt;/code&gt; 以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="4a06461d5cac364fcad71d6e428b30d7321d874b" translate="yes" xml:space="preserve">
          <source>Number of messages to be sent per connection, after that a relogin will happen. If the value is 0 or undefined, send all messages in one connection. See also the &lt;code&gt;--batch-size&lt;/code&gt; option of &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;.</source>
          <target state="translated">每个连接发送的消息数，之后将重新登录。如果值为0或未定义，则在一个连接中发送所有消息。另请参见&lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt;的 &lt;code&gt;--batch-size&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="263d5a12c4d7938e6b1945ed2d424a531e8ffd37" translate="yes" xml:space="preserve">
          <source>Number of parallel children to be used for all forms of fetching.</source>
          <target state="translated">所有形式的取材都要用到的平行子代数。</target>
        </trans-unit>
        <trans-unit id="5f124a70076360d6cdb202a3452dac6608d9c87a" translate="yes" xml:space="preserve">
          <source>Number of seconds to cache credentials (default: 900).</source>
          <target state="translated">缓存凭证的秒数(默认值:900)。</target>
        </trans-unit>
        <trans-unit id="0600a433ee142590b5ed0795ec15517899403cc1" translate="yes" xml:space="preserve">
          <source>OBJ_BLOB (3)</source>
          <target state="translated">OBJ_BLOB (3)</target>
        </trans-unit>
        <trans-unit id="20a9deedd57091e656a9ceb8afe723fea4c8ae28" translate="yes" xml:space="preserve">
          <source>OBJ_COMMIT (1)</source>
          <target state="translated">OBJ_COMMIT (1)</target>
        </trans-unit>
        <trans-unit id="33b36795cfe9033fd325f2c4f57ccf4bbcdb1c8c" translate="yes" xml:space="preserve">
          <source>OBJ_OFS_DELTA (6)</source>
          <target state="translated">OBJ_OFS_DELTA (6)</target>
        </trans-unit>
        <trans-unit id="ad63d6a2f7a5f774df4b60dc52ffc40dc66ab330" translate="yes" xml:space="preserve">
          <source>OBJ_REF_DELTA (7)</source>
          <target state="translated">OBJ_REF_DELTA (7)</target>
        </trans-unit>
        <trans-unit id="bf0dce0da3b6ff387e755df6e790a1cac5898dd7" translate="yes" xml:space="preserve">
          <source>OBJ_TAG (4)</source>
          <target state="translated">OBJ_TAG (4)</target>
        </trans-unit>
        <trans-unit id="2f77abc6705f39815a181a261b98c26e748660a6" translate="yes" xml:space="preserve">
          <source>OBJ_TREE (2)</source>
          <target state="translated">OBJ_TREE (2)</target>
        </trans-unit>
        <trans-unit id="bcb75e6bd3e418ec921606a22f47e84ce889c09d" translate="yes" xml:space="preserve">
          <source>OK, still with me? To give us an example to look at, let&amp;rsquo;s go back to the earlier repository with &quot;hello&quot; and &quot;example&quot; file, and bring ourselves back to the pre-merge state:</source>
          <target state="translated">好吧，还是和我在一起吗？让我们来看一个例子，让我们回到带有&amp;ldquo; hello&amp;rdquo;和&amp;ldquo; example&amp;rdquo;文件的早期存储库，然后使自己回到合并前的状态：</target>
        </trans-unit>
        <trans-unit id="6477da6d91ea639e6e30c40f69d7500177d55603" translate="yes" xml:space="preserve">
          <source>OK, this all sounds like a collection of totally nonsensical rules, but it&amp;rsquo;s actually exactly what you want in order to do a fast merge. The different stages represent the &quot;result tree&quot; (stage 0, aka &quot;merged&quot;), the original tree (stage 1, aka &quot;orig&quot;), and the two trees you are trying to merge (stage 2 and 3 respectively).</source>
          <target state="translated">好的，这听起来似乎是完全荒谬的规则的集合，但实际上正是您想要进行快速合并的目的。不同阶段代表&amp;ldquo;结果树&amp;rdquo;（阶段0，又称&amp;ldquo;合并&amp;rdquo;），原始树（阶段1，又称&amp;ldquo;原件&amp;rdquo;）和您要合并的两棵树（分别为阶段2和3）。</target>
        </trans-unit>
        <trans-unit id="30c34ea4528b5e99d721b2ada273c08402f70a1d" translate="yes" xml:space="preserve">
          <source>Object Traversal</source>
          <target state="translated">对象遍历</target>
        </trans-unit>
        <trans-unit id="e07348665c9e3f452362a58c36e1f55665279269" translate="yes" xml:space="preserve">
          <source>Object access and manipulation</source>
          <target state="translated">对象访问和操作</target>
        </trans-unit>
        <trans-unit id="d963c54afefdbe29bbc1f0380d42869afd8a753b" translate="yes" xml:space="preserve">
          <source>Object size identified by &amp;lt;object&amp;gt; is given in bytes, and right-justified with minimum width of 7 characters. Object size is given only for blobs (file) entries; for other entries &lt;code&gt;-&lt;/code&gt; character is used in place of size.</source>
          <target state="translated">由&amp;lt;object&amp;gt;标识的对象大小以字节为单位，并用7个字符的最小宽度右对齐。对象大小仅针对blob（文件）条目提供；对于其他条目 &lt;code&gt;-&lt;/code&gt; 使用字符代替大小。</target>
        </trans-unit>
        <trans-unit id="5a755e02f9fddc8d9863cff303858fc5c0963f4b" translate="yes" xml:space="preserve">
          <source>Object storage format</source>
          <target state="translated">对象存储格式</target>
        </trans-unit>
        <trans-unit id="4410a56144704dcadb0adeabc1f66b086332a778" translate="yes" xml:space="preserve">
          <source>Object store associated with this repository. Usually an object store is self sufficient (i.e. all the objects that are referred to by an object found in it are also found in it), but there are a few ways to violate it.</source>
          <target state="translated">与这个存储库相关联的对象存储。通常一个对象存储是自给自足的(即在其中找到的对象所引用的所有对象也在其中找到),但有一些方法可以违反它。</target>
        </trans-unit>
        <trans-unit id="66c888d10ab6a46198fcec7325df97ad7688050e" translate="yes" xml:space="preserve">
          <source>Object types</source>
          <target state="translated">对象类型</target>
        </trans-unit>
        <trans-unit id="397880af9235fafbc028a684c78f613458679a72" translate="yes" xml:space="preserve">
          <source>Objects that already exist in the repository will &lt;strong&gt;not&lt;/strong&gt; be unpacked from the packfile. Therefore, nothing will be unpacked if you use this command on a packfile that exists within the target repository.</source>
          <target state="translated">存储库中已存在的对象&lt;strong&gt;不会&lt;/strong&gt;从packfile中解压缩。因此，如果对目标存储库中存在的packfile使用此命令，则不会解包任何内容。</target>
        </trans-unit>
        <trans-unit id="f90e1faea66f4ee07afc15b9cfbe6b37aebe1076" translate="yes" xml:space="preserve">
          <source>Objects unreachable from the refs in packs named with --unpacked= option are added to the resulting pack, in addition to the reachable objects that are not in packs marked with *.keep files. This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">除了未在带有* .keep文件标记的包中的可访问对象之外，用--unpacked =选项命名的包中的引用中无法访问的对象也添加到了结果包中。这意味着 &lt;code&gt;--revs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4b47085e458e48bb4b0605ca6d2f6a3cc7755c2" translate="yes" xml:space="preserve">
          <source>Obsolete for: &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">已过时：&lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d42a49317326d6b79f20beebf76935d065ccac7f" translate="yes" xml:space="preserve">
          <source>Obviously, endless variations are possible; for example, to see all commits reachable from some head but not from any tag in the repository:</source>
          <target state="translated">显然,我们可以有无穷无尽的变化,例如,可以看到所有从某个头部提交的提交,而不是从版本库中的任何标签提交的提交。</target>
        </trans-unit>
        <trans-unit id="80e98962116f1f595b28a3f430e4b1f9c4dbde82" translate="yes" xml:space="preserve">
          <source>Occasionally, the maintainer may get merge conflicts when they try to pull changes from downstream. In this case, they can ask downstream to do the merge and resolve the conflicts themselves (perhaps they will know better how to resolve them). It is one of the rare cases where downstream &lt;code&gt;should&lt;/code&gt; merge from upstream.</source>
          <target state="translated">有时，维护者在尝试从下游拉出更改时可能会遇到合并冲突。在这种情况下，他们可以要求下游进行合并并自己解决冲突（也许他们会更好地解决问题）。这是少数情况下下游 &lt;code&gt;should&lt;/code&gt; 上游合并的情况之一。</target>
        </trans-unit>
        <trans-unit id="7c4df738049a7589e8637595f08e890f6ad9d98e" translate="yes" xml:space="preserve">
          <source>Of course some kind of software is developed, then used during some time without being improved on much, and then finally thrown away. In this case, of course, regressions may not be a big problem. But on the other hand, there is a lot of big software that is continually developed and maintained during years or even tens of years by a lot of people. And as there are often many people who depend (sometimes critically) on such software, regressions are a really big problem.</source>
          <target state="translated">当然某种软件开发出来后,在一段时间内使用,没有经过什么改进,最后就扔掉了。当然,在这种情况下,退步可能不是什么大问题。但另一方面,有很多大型软件是在几年甚至十几年的时间里,由很多人不断开发和维护的。而由于经常有很多人依赖(有时是关键性的)这样的软件,所以回归是一个非常大的问题。</target>
        </trans-unit>
        <trans-unit id="19fce424b8331b64c65b8a6acafb03304b015bfc" translate="yes" xml:space="preserve">
          <source>Of course the &quot;bad&quot; commit cannot be an ancestor of a &quot;good&quot; commit, because the ancestors of the good commits are supposed to be &quot;good&quot;. And all the &quot;good&quot; commits must be related to the bad commit. They cannot be on a branch that has no link with the branch of the &quot;bad&quot; commit. But it is possible for a good commit to be related to a bad commit and yet not be neither one of its ancestor nor one of its descendants.</source>
          <target state="translated">当然,&quot;坏 &quot;提交不可能是 &quot;好 &quot;提交的祖先,因为好提交的祖先应该是 &quot;好&quot;。而所有的 &quot;好 &quot;提交必须与 &quot;坏 &quot;提交有关。它们不能在一个与 &quot;坏 &quot;提交的分支没有联系的分支上。但是,一个好的提交与一个坏的提交有可能有关系,但既不是它的祖先,也不是它的子孙。</target>
        </trans-unit>
        <trans-unit id="7c78c10d5c75907a546f96553e9802bb23f4c982" translate="yes" xml:space="preserve">
          <source>Of course, there may be more than one answer&amp;mdash;​if the history branched after commit e05db0fd, then there could be multiple &quot;earliest&quot; tagged releases.</source>
          <target state="translated">当然，可能会有多个答案-如果在提交e05db0fd之后历史分支分支，那么可能会有多个``最早''的标记发行版。</target>
        </trans-unit>
        <trans-unit id="bc73231ef0df798acd7604c5e90f5ea460992bab" translate="yes" xml:space="preserve">
          <source>Often people use &lt;code&gt;git pull&lt;/code&gt; without giving any parameter. Traditionally, this has been equivalent to saying &lt;code&gt;git pull
origin&lt;/code&gt;. However, when configuration &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; is present while on branch &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, that value is used instead of &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">人们通常在不提供任何参数的情况下使用 &lt;code&gt;git pull&lt;/code&gt; 。传统上，这相当于说 &lt;code&gt;git pull origin&lt;/code&gt; 。然而，当配置 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 是在分支存在，而 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; ，则使用该值而不是 &lt;code&gt;origin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="813c6a487fc92be3bf23c6677bbfade25d37be89" translate="yes" xml:space="preserve">
          <source>Often the current branch head is an ancestor of the named commit. This is the most common case especially when invoked from &lt;code&gt;git pull&lt;/code&gt;: you are tracking an upstream repository, you have committed no local changes, and now you want to update to a newer upstream revision. In this case, a new commit is not needed to store the combined history; instead, the &lt;code&gt;HEAD&lt;/code&gt; (along with the index) is updated to point at the named commit, without creating an extra merge commit.</source>
          <target state="translated">当前分支头通常是指定提交的祖先。这是最常见的情况，尤其是从 &lt;code&gt;git pull&lt;/code&gt; 调用时：您正在跟踪上游存储库，尚未提交任何本地更改，现在想更新到较新的上游修订版。在这种情况下，不需要新的提交来存储组合的历史记录；相反，将 &lt;code&gt;HEAD&lt;/code&gt; （以及索引）更新为指向指定的提交，而不创建额外的合并提交。</target>
        </trans-unit>
        <trans-unit id="bc22c639538c04ca7d5608268e4dc9b34f324581" translate="yes" xml:space="preserve">
          <source>Often the overview of the change is useful to get a feel of each step</source>
          <target state="translated">通常情况下,变化的概述是有用的,以获得每个步骤的感觉</target>
        </trans-unit>
        <trans-unit id="a0ef5be0d5f74372c2549cc7906cdb110a910654" translate="yes" xml:space="preserve">
          <source>Often, &quot;please pull&quot; messages on the mailing list just provide two pieces of information: a repo URL and a branch name; this is designed to be easily cut&amp;amp;pasted at the end of a &lt;code&gt;git fetch&lt;/code&gt; command line:</source>
          <target state="translated">通常，邮件列表上的&amp;ldquo;请拉&amp;rdquo;消息仅提供两条信息：回购URL和分支名称；它的设计目的是在 &lt;code&gt;git fetch&lt;/code&gt; 命令行的末尾轻松剪切和粘贴：</target>
        </trans-unit>
        <trans-unit id="b90f5f996d698883902ffd1dba32d6eea369ef9a" translate="yes" xml:space="preserve">
          <source>Older documentation written before the packed-refs mechanism was introduced may still say things like &quot;.git/refs/heads/&amp;lt;branch&amp;gt; file exists&quot; when it means &quot;branch &amp;lt;branch&amp;gt; exists&quot;.</source>
          <target state="translated">引入packed-refs机制之前编写的较早的文档在其含义为&amp;ldquo; branch &amp;lt;branch&amp;gt;存在&amp;rdquo;时，仍可能会说诸如&amp;ldquo; .git / refs / heads / &amp;lt;branch&amp;gt;文件存在&amp;rdquo;之类的内容。</target>
        </trans-unit>
        <trans-unit id="a148aab8f38b980de65dd5f412fc336ae5d855f6" translate="yes" xml:space="preserve">
          <source>Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run &lt;code&gt;git merge&lt;/code&gt;. To make it easier to adjust such scripts to the updated behaviour, the environment variable &lt;code&gt;GIT_MERGE_AUTOEDIT&lt;/code&gt; can be set to &lt;code&gt;no&lt;/code&gt; at the beginning of them.</source>
          <target state="translated">较早的脚本可能取决于不允许用户编辑合并日志消息的历史行为。他们将在运行 &lt;code&gt;git merge&lt;/code&gt; 时看到一个打开的编辑器。为了更容易地将这些脚本调整为更新的行为，可以在它们的开头将环境变量 &lt;code&gt;GIT_MERGE_AUTOEDIT&lt;/code&gt; 设置为 &lt;code&gt;no&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a027c8ab6aede7960dbe3d141d016ee3e6589ef" translate="yes" xml:space="preserve">
          <source>Older versions of &lt;code&gt;meld&lt;/code&gt; do not support the &lt;code&gt;--output&lt;/code&gt; option. Git will attempt to detect whether &lt;code&gt;meld&lt;/code&gt; supports &lt;code&gt;--output&lt;/code&gt; by inspecting the output of &lt;code&gt;meld --help&lt;/code&gt;. Configuring &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; will make Git skip these checks and use the configured value instead. Setting &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; tells Git to unconditionally use the &lt;code&gt;--output&lt;/code&gt; option, and &lt;code&gt;false&lt;/code&gt; avoids using &lt;code&gt;--output&lt;/code&gt;.</source>
          <target state="translated">较早版本的 &lt;code&gt;meld&lt;/code&gt; 不支持 &lt;code&gt;--output&lt;/code&gt; 选项。 Git将通过检查 &lt;code&gt;meld --help&lt;/code&gt; 的输出来尝试检测 &lt;code&gt;meld&lt;/code&gt; 是否支持 &lt;code&gt;--output&lt;/code&gt; 。配置 &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; 将使Git跳过这些检查，而是使用配置的值。将 &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 会告诉Git无条件使用 &lt;code&gt;--output&lt;/code&gt; 选项，而 &lt;code&gt;false&lt;/code&gt; 则避免使用 &lt;code&gt;--output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8511fe9d48b84ff3883d162d35ccd3dcba224454" translate="yes" xml:space="preserve">
          <source>Older versions of Git (before 2.20) documented that the object names list should be sorted. This was never a requirement, the object names could appear in any order, but when reading the list we tracked whether the list was sorted for the purposes of an internal binary search implementation, which could save itself some work with an already sorted list. Unless you had a humongous list there was no reason to go out of your way to pre-sort the list. After Git version 2.20 a hash implementation is used instead, so there&amp;rsquo;s now no reason to pre-sort the list.</source>
          <target state="translated">较早版本的Git（2.20之前）记录了对象名称列表应进行排序。这从来都不是必需的，对象名称可以按任何顺序出现，但是在读取列表时，我们跟踪了列表是否出于内部二进制搜索实现的目的而进行了排序，这可以为已保存列表的工作节省一些时间。除非您的清单很大，否则没有理由不愿对清单进行预排序。在Git 2.20版本之后，使用哈希实现代替，因此现在没有理由对列表进行预排序。</target>
        </trans-unit>
        <trans-unit id="c51aaa3680fede028efcceee261b4919c277f552" translate="yes" xml:space="preserve">
          <source>Omit any commit that introduces the same change as another commit on the &amp;ldquo;other side&amp;rdquo; when the set of commits are limited with symmetric difference.</source>
          <target state="translated">当提交集受到对称差异限制时，请忽略任何与&amp;ldquo;另一端&amp;rdquo;上的另一次提交引入相同更改的提交。</target>
        </trans-unit>
        <trans-unit id="e35d3ce0c9ea9ff6d661fcb1cbc8e08ffef97df6" translate="yes" xml:space="preserve">
          <source>Omit diff output for unmerged entries and just show &quot;Unmerged&quot;. Can be used only when comparing the working tree with the index.</source>
          <target state="translated">省略未合并条目的差异输出,只显示 &quot;Unmerged&quot;。只能在比较工作树和索引时使用。</target>
        </trans-unit>
        <trans-unit id="3138b0b10501de06a44e08d0de4b10a83646644b" translate="yes" xml:space="preserve">
          <source>Omit objects that are known to be in the promisor remote. (This option has the purpose of operating only on locally created objects, so that when we repack, we still maintain a distinction between locally created objects [without .promisor] and objects from the promisor remote [with .promisor].) This is used with partial clone.</source>
          <target state="translated">省略那些已知在 promisor 远程中的对象。(这个选项的目的是只对本地创建的对象进行操作,这样当我们重新打包时,我们仍然会对本地创建的对象 [没有 .promonor]和来自 promisor remote [有 .promonor]的对象进行区分。)这个选项是和部分克隆一起使用的。</target>
        </trans-unit>
        <trans-unit id="fcfe3e3e988e33991f3ebb33b70ee9c58a79e5d0" translate="yes" xml:space="preserve">
          <source>Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and &lt;code&gt;/dev/null&lt;/code&gt;. The resulting patch is not meant to be applied with &lt;code&gt;patch&lt;/code&gt; or &lt;code&gt;git apply&lt;/code&gt;; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.</source>
          <target state="translated">忽略要删除的原映像，即仅输出标头，而不输出原映像和 &lt;code&gt;/dev/null&lt;/code&gt; 之间的差异。生成的补丁并不意味着要使用 &lt;code&gt;patch&lt;/code&gt; 或 &lt;code&gt;git apply&lt;/code&gt; ; 这仅适用于那些只希望在更改后专心阅读文本的人。另外，输出显然缺乏足够的信息来反向应用这种补丁，甚至是手动应用，因此是选项的名称。</target>
        </trans-unit>
        <trans-unit id="2c239b325c52048ed0e0df682e63161da794c522" translate="yes" xml:space="preserve">
          <source>Omitting &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; detaches &lt;code&gt;HEAD&lt;/code&gt; at the tip of the current branch.</source>
          <target state="translated">省略 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 会在当前分支的尖端分离 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f08ea1a85b441d7cdb4b9da4840e51d4a63074c" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;from&lt;/code&gt; command in the first commit of a new branch will cause fast-import to create that commit with no ancestor. This tends to be desired only for the initial commit of a project. If the frontend creates all files from scratch when making a new branch, a &lt;code&gt;merge&lt;/code&gt; command may be used instead of &lt;code&gt;from&lt;/code&gt; to start the commit with an empty tree. Omitting the &lt;code&gt;from&lt;/code&gt; command on existing branches is usually desired, as the current commit on that branch is automatically assumed to be the first ancestor of the new commit.</source>
          <target state="translated">在新分支的第一次提交中省略 &lt;code&gt;from&lt;/code&gt; 命令将导致快速导入在没有祖先的情况下创建该提交。仅对于项目的初始提交，这往往是期望的。如果前端在创建新分支时从头开始创建所有文件，则可以使用 &lt;code&gt;merge&lt;/code&gt; 命令而不是 &lt;code&gt;from&lt;/code&gt; 来从空树开始提交。通常希望在现有分支上省略 &lt;code&gt;from&lt;/code&gt; 命令，因为该分支上的当前提交会自动假定为新提交的第一个祖先。</target>
        </trans-unit>
        <trans-unit id="2e6ae0a1101e66bbdd1aff8c2583b81c23208b83" translate="yes" xml:space="preserve">
          <source>On Automatic following</source>
          <target state="translated">自动跟踪</target>
        </trans-unit>
        <trans-unit id="82b4aa90bf6690a7ed8e3558248667b070567fb7" translate="yes" xml:space="preserve">
          <source>On Backdating Tags</source>
          <target state="translated">关于追溯标签</target>
        </trans-unit>
        <trans-unit id="52c1ff7f8dbe6e1f6639547a437fb78c51994ab9" translate="yes" xml:space="preserve">
          <source>On Re-tagging</source>
          <target state="translated">关于重新标记</target>
        </trans-unit>
        <trans-unit id="a3e5a575b7ca5dced5a48ec2289cb57e77edaa64" translate="yes" xml:space="preserve">
          <source>On an inefficient filesystem with &lt;code&gt;core.ignorestat&lt;/code&gt; set</source>
          <target state="translated">在设置了 &lt;code&gt;core.ignorestat&lt;/code&gt; 的低效文件系统上</target>
        </trans-unit>
        <trans-unit id="3fc5d80f58915bdd0c5c8219fc8fa34ba2d1e212" translate="yes" xml:space="preserve">
          <source>On any other error, the exit status may be any other non-zero value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf984a0700972bcd62e51c87e569c1158e56007" translate="yes" xml:space="preserve">
          <source>On large repositories, Git depends on compression to keep the history information from taking up too much space on disk or in memory. Some Git commands may automatically run &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;, so you don&amp;rsquo;t have to worry about running it manually. However, compressing a large repository may take a while, so you may want to call &lt;code&gt;gc&lt;/code&gt; explicitly to avoid automatic compression kicking in when it is not convenient.</source>
          <target state="translated">在大型存储库上，Git依靠压缩来防止历史信息占用磁盘或内存中的过多空间。一些Git命令可能会自动运行&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;，因此您不必担心手动运行它。但是，压缩大型存储库可能需要一段时间，因此您可能需要显式调用 &lt;code&gt;gc&lt;/code&gt; ,以避免在不方便时自动进行压缩。</target>
        </trans-unit>
        <trans-unit id="d4d8aed3bf55796608219c0adac254008695a3f9" translate="yes" xml:space="preserve">
          <source>On some file system/operating system combinations, this is unreliable. Set this config setting to &lt;code&gt;rename&lt;/code&gt; there; However, This will remove the check that makes sure that existing object files will not get overwritten.</source>
          <target state="translated">在某些文件系统/操作系统组合上，这是不可靠的。设置此配置设置以在那里 &lt;code&gt;rename&lt;/code&gt; ；但是，这将删除确保现有目标文件不会被覆盖的检查。</target>
        </trans-unit>
        <trans-unit id="5895edccc183158d9e3740d2cebb6ada4fc33444" translate="yes" xml:space="preserve">
          <source>On submit, re-author changes to reflect the Git author, regardless of who invokes &lt;code&gt;git p4 submit&lt;/code&gt;.</source>
          <target state="translated">提交时，无论谁调用 &lt;code&gt;git p4 submit&lt;/code&gt; ，都要重新编写更改以反映Git作者。</target>
        </trans-unit>
        <trans-unit id="625dc8e72565a5aa6c893e4054fd5a7bd4cd4c77" translate="yes" xml:space="preserve">
          <source>On success, the command returns the exit code 0.</source>
          <target state="translated">成功后,命令返回退出代码0。</target>
        </trans-unit>
        <trans-unit id="55bf26a2244670497728b53622880350724b3943" translate="yes" xml:space="preserve">
          <source>On success, the exit status is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990e4d4ec388fa2b56426ae37da6b01c179599b8" translate="yes" xml:space="preserve">
          <source>On success, the exit status is &lt;code&gt;0&lt;/code&gt;. If the filter can&amp;rsquo;t find any commits to rewrite, the exit status is &lt;code&gt;2&lt;/code&gt;. On any other error, the exit status may be any other non-zero value.</source>
          <target state="translated">成功时，退出状态为 &lt;code&gt;0&lt;/code&gt; 。如果过滤器找不到任何要重写的提交，则退出状态为 &lt;code&gt;2&lt;/code&gt; 。在发生任何其他错误时，退出状态可以是任何其他非零值。</target>
        </trans-unit>
        <trans-unit id="9b26f7834b511fe2fcda898a4f6a6ea24bf02deb" translate="yes" xml:space="preserve">
          <source>On the filesystem, a submodule usually (but not always - see FORMS below) consists of (i) a Git directory located under the &lt;code&gt;$GIT_DIR/modules/&lt;/code&gt; directory of its superproject, (ii) a working directory inside the superproject&amp;rsquo;s working directory, and a &lt;code&gt;.git&lt;/code&gt; file at the root of the submodule&amp;rsquo;s working directory pointing to (i).</source>
          <target state="translated">在文件系统上，子模块通常（但不总是-参见下面的FORMS）由（i）位于其超级项目的 &lt;code&gt;$GIT_DIR/modules/&lt;/code&gt; 目录下的Git目录，（ii）超级项目的工作目录内的工作目录，以及一个 &lt;code&gt;.git&lt;/code&gt; 在子模块的工作目录指向的根文件于（i）。</target>
        </trans-unit>
        <trans-unit id="4db9025909f7f5bf5e13acbeaf805aa54cd01729" translate="yes" xml:space="preserve">
          <source>On the other hand if you do this often, then it can be worth having scripts to avoid too much typing.</source>
          <target state="translated">另一方面,如果你经常这样做,那么为了避免过多的打字,可以值得有脚本。</target>
        </trans-unit>
        <trans-unit id="683649c177c2041eda8a2d9bcca87e40a04a531c" translate="yes" xml:space="preserve">
          <source>On the other hand, if instead of merging at C you had rebased the history between Z to B on top of A, you would have gotten this linear history:</source>
          <target state="translated">另一方面,如果你不在C处合并,而是在A的基础上重新计算Z到B之间的历史,你就会得到这个线性历史。</target>
        </trans-unit>
        <trans-unit id="0322f18dd0193743bffa03c418d12c6fe0b24261" translate="yes" xml:space="preserve">
          <source>On the other hand, if you are fetching because you would want a one-shot merge from somebody else, you typically do not want to get tags from there. This happens more often for people near the toplevel but not limited to them. Mere mortals when pulling from each other do not necessarily want to automatically get private anchor point tags from the other person.</source>
          <target state="translated">另一方面,如果你是因为想从别人那里一次性合并而获取,你通常不希望从那里获取标签。这种情况更多发生在顶层附近的人身上,但不限于他们。单纯的凡人在从对方那里拉取时,不一定希望自动从对方那里获得私人锚点标签。</target>
        </trans-unit>
        <trans-unit id="ff26b6c1b15a595913b474bb862db9261a722064" translate="yes" xml:space="preserve">
          <source>On the other hand, when &lt;code&gt;git gc&lt;/code&gt; runs concurrently with another process, there is a risk of it deleting an object that the other process is using but hasn&amp;rsquo;t created a reference to. This may just cause the other process to fail or may corrupt the repository if the other process later adds a reference to the deleted object. Git has two features that significantly mitigate this problem:</source>
          <target state="translated">另一方面，当 &lt;code&gt;git gc&lt;/code&gt; 与另一个进程同时运行时，有可能会删除另一个进程正在使用但尚未创建引用的对象。如果其他进程以后添加对已删除对象的引用，则这可能只会导致另一个进程失败或损坏存储库。Git具有两个可以大大缓解此问题的功能：</target>
        </trans-unit>
        <trans-unit id="9cc6a0108c9ca30d35fc16f0e158699698e2687d" translate="yes" xml:space="preserve">
          <source>On the plus side, distributed revision control systems can much better integrate with external sources. In a centralized model, a single arbitrary snapshot of the external project is exported from its own revision control and then imported into the local revision control on a vendor branch. All the history is hidden. With distributed revision control you can clone the entire external history and much more easily follow development and re-merge local changes.</source>
          <target state="translated">从另一个方面来说,分布式的修订控制系统可以更好地与外部资源集成。在集中式模型中,外部项目的一个任意快照会从自己的修订控制中导出,然后导入到供应商分支上的本地修订控制中。所有的历史记录都是隐藏的。通过分布式修订控制,你可以克隆整个外部历史,并且更容易跟踪开发和重新合并本地变更。</target>
        </trans-unit>
        <trans-unit id="90597c320571938c2a30a9ec587f181632e3da9c" translate="yes" xml:space="preserve">
          <source>On the receiving side, failing fsckObjects will make those objects unreachable, see &quot;QUARANTINE ENVIRONMENT&quot; in &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;. On the fetch side, malformed objects will instead be left unreferenced in the repository.</source>
          <target state="translated">在接收方，失败的fsckObjects将使这些对象不可访问，请参见&lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]中的&lt;/a&gt; &amp;ldquo; QUARANTINE ENVIRONMENT&amp;rdquo; 。在获取方面，格式错误的对象将改为在存储库中未引用。</target>
        </trans-unit>
        <trans-unit id="0cb32cbc06583a961d1463cba3f54ceac091ac9b" translate="yes" xml:space="preserve">
          <source>Once a patch completes the great cycle (moving from test to release, then pulled by Linus, and finally coming back into your local &lt;code&gt;origin/master&lt;/code&gt; branch), the branch for this change is no longer needed. You detect this when the output from:</source>
          <target state="translated">一旦补丁完成了重要的周期（从测试到发布，然后由Linus拉动，最后回到您的本地 &lt;code&gt;origin/master&lt;/code&gt; 分支），则不再需要此更改的分支。当来自以下位置的输出时，您将检测到此情况：</target>
        </trans-unit>
        <trans-unit id="b9ebb68ceda33b5f55394a76815abe93f554d5a0" translate="yes" xml:space="preserve">
          <source>Once again, check to verify that you&amp;rsquo;ve included what you want to. You may also wish to verify that git diff doesn&amp;rsquo;t show any remaining changes to be committed later.</source>
          <target state="translated">再次检查以确保您已包含要包含的内容。您可能还希望验证git diff不显示任何剩余更改以供以后提交。</target>
        </trans-unit>
        <trans-unit id="90e05562a65001025b0b72d96c6a4e4b947387b5" translate="yes" xml:space="preserve">
          <source>Once housekeeping is triggered by exceeding the limits of configuration options such as &lt;code&gt;gc.auto&lt;/code&gt; and &lt;code&gt;gc.autoPackLimit&lt;/code&gt;, all other housekeeping tasks (e.g. rerere, working trees, reflog&amp;hellip;​) will be performed as well.</source>
          <target state="translated">一旦超出配置选项的限制（例如 &lt;code&gt;gc.auto&lt;/code&gt; 和 &lt;code&gt;gc.autoPackLimit&lt;/code&gt; ）触发了内务处理，所有其他内务处理任务（例如rerere，工作树，刷新日志等）也将执行。</target>
        </trans-unit>
        <trans-unit id="e4fac50f608beca9583acae6e66b5b839bc7af82" translate="yes" xml:space="preserve">
          <source>Once satisfied with the hunks you want to include, you should verify what has been prepared for the first commit by using &lt;code&gt;git diff --cached&lt;/code&gt;. This shows all the changes that have been moved into the index and are about to be committed.</source>
          <target state="translated">对要包含的块满意之后，应使用 &lt;code&gt;git diff --cached&lt;/code&gt; 验证为首次提交准备的内容。这显示了所有已移入索引并将要提交的更改。</target>
        </trans-unit>
        <trans-unit id="3dd9fb6970c316fd22de16c64bf93a0699f63f8d" translate="yes" xml:space="preserve">
          <source>Once the commits are ready to be sent, run the following command:</source>
          <target state="translated">一旦准备好要发送的提交,运行以下命令。</target>
        </trans-unit>
        <trans-unit id="40868be271f12676d4171e28016f98d26c82d485" translate="yes" xml:space="preserve">
          <source>Once the index has been created, the hash that goes into the name of the pack/idx file is printed to stdout. If --stdin was also used then this is prefixed by either &quot;pack\t&quot;, or &quot;keep\t&quot; if a new .keep file was successfully created. This is useful to remove a .keep file used as a lock to prevent the race with &lt;code&gt;git repack&lt;/code&gt; mentioned above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0e79bf062114aed97a847d2dbf78bde74bcedc" translate="yes" xml:space="preserve">
          <source>Once the index has been created, the list of object names is sorted and the SHA-1 hash of that list is printed to stdout. If --stdin was also used then this is prefixed by either &quot;pack\t&quot;, or &quot;keep\t&quot; if a new .keep file was successfully created. This is useful to remove a .keep file used as a lock to prevent the race with &lt;code&gt;git repack&lt;/code&gt; mentioned above.</source>
          <target state="translated">创建索引后，将对对象名称列表进行排序，并将该列表的SHA-1哈希打印到stdout。如果还使用了--stdin，则如果成功创建了新的.keep文件，则以&amp;ldquo; pack \ t&amp;rdquo;或&amp;ldquo; keep \ t&amp;rdquo;作为前缀。这对于删除用作锁定的.keep文件很有用，以防止上述 &lt;code&gt;git repack&lt;/code&gt; 竞争。</target>
        </trans-unit>
        <trans-unit id="267c8839170c35911e5505454167dce43ef8461e" translate="yes" xml:space="preserve">
          <source>Once the index is updated with the results of the conflict resolution, instead of creating a new commit, just run</source>
          <target state="translated">一旦根据冲突解决的结果更新了索引,就不需要创建新的提交,只需运行</target>
        </trans-unit>
        <trans-unit id="dce83a819a58902526be63ab88beb478ade1a830" translate="yes" xml:space="preserve">
          <source>Once tracking a Subversion repository (with any of the above methods), the Git repository can be updated from Subversion by the &lt;code&gt;fetch&lt;/code&gt; command and Subversion updated from Git by the &lt;code&gt;dcommit&lt;/code&gt; command.</source>
          <target state="translated">一旦跟踪了Subversion存储库（使用上述任何一种方法），就可以通过 &lt;code&gt;fetch&lt;/code&gt; 命令从Subversion更新Git存储库，并通过 &lt;code&gt;dcommit&lt;/code&gt; 命令从Git更新Subversion 。</target>
        </trans-unit>
        <trans-unit id="f7c323cf6aca82334469eb4ac31bb75f493bfcb2" translate="yes" xml:space="preserve">
          <source>Once you fetch from the remote repository, you &lt;code&gt;merge&lt;/code&gt; that with your current branch.</source>
          <target state="translated">从远程存储库中获取数据后， &lt;code&gt;merge&lt;/code&gt; 其与当前分支合并。</target>
        </trans-unit>
        <trans-unit id="196d7a30344d61fce15a29277d1febbefab63366" translate="yes" xml:space="preserve">
          <source>Once you have packed objects, you do not need to leave the unpacked objects that are contained in the pack file anymore.</source>
          <target state="translated">一旦你打包了对象,你就不需要再留下打包文件中包含的未打包的对象。</target>
        </trans-unit>
        <trans-unit id="19419c3fb2ffef21b9b034f5ca5d579751e9cffb" translate="yes" xml:space="preserve">
          <source>Once you have specified at least one bad and one good commit, &lt;code&gt;git
bisect&lt;/code&gt; selects a commit in the middle of that range of history, checks it out, and outputs something similar to the following:</source>
          <target state="translated">一旦指定了至少一个错误和一个良好的提交， &lt;code&gt;git bisect&lt;/code&gt; 将在该历史记录范围的中间选择一个提交，将其检出，并输出类似于以下内容的内容：</target>
        </trans-unit>
        <trans-unit id="a222e7e00ea22df97bc019f6fbda7d4a739d08f0" translate="yes" xml:space="preserve">
          <source>Once you know the three trees you are going to merge (the one &quot;original&quot; tree, aka the common tree, and the two &quot;result&quot; trees, aka the branches you want to merge), you do a &quot;merge&quot; read into the index. This will complain if it has to throw away your old index contents, so you should make sure that you&amp;rsquo;ve committed those&amp;mdash;​in fact you would normally always do a merge against your last commit (which should thus match what you have in your current index anyway).</source>
          <target state="translated">知道要合并的三棵树（一棵&amp;ldquo;原始&amp;rdquo;树，又称普通树，以及两棵&amp;ldquo;结果&amp;rdquo;树，又称要合并的分支）后，便进行&amp;ldquo;合并&amp;rdquo;读取到指数。如果必须丢弃旧的索引内容，这将会发出抱怨，因此您应该确保已提交了这些内容-实际上，您通常总是对上一次提交进行合并（因此应该与您的现有内容相匹配）当前索引）。</target>
        </trans-unit>
        <trans-unit id="2f6bdbc854c9f4a06850e81f40a40893a853f873" translate="yes" xml:space="preserve">
          <source>Once your commits are ready to be sent to the mailing list, run the following commands:</source>
          <target state="translated">一旦你的提交准备好了,就可以发送到邮件列表中,运行以下命令。</target>
        </trans-unit>
        <trans-unit id="1e3411b288c5ece442ec5affcc9ccff7867288ff" translate="yes" xml:space="preserve">
          <source>One can also modify context lines by staging them for removal (by converting &quot; &quot; to &quot;-&quot;) and adding a &quot;+&quot; line with the new content. Similarly, one can modify &quot;+&quot; lines for existing additions or modifications. In all cases, the new modification will appear reverted in the working tree.</source>
          <target state="translated">我们也可以修改上下文行,将它们分期删除(通过将&quot;&quot;转换为&quot;-&quot;),然后添加一个 &quot;+&quot;行,加上新的内容。同样,人们也可以为现有的添加或修改修改 &quot;+&quot;行。在所有情况下,新的修改都会在工作树中出现还原。</target>
        </trans-unit>
        <trans-unit id="cefda8701820e17ff3e5c1f9d74674c9ba3ca4b0" translate="yes" xml:space="preserve">
          <source>One feature worth pointing out is the three-way merge, which can help if you get conflicts: &lt;code&gt;git am -3&lt;/code&gt; will use index information contained in patches to figure out the merge base. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; for other options.</source>
          <target state="translated">值得指出的一项功能是三向合并，这在您遇到冲突 &lt;code&gt;git am -3&lt;/code&gt; 会有所帮助：git am -3将使用补丁程序中包含的索引信息来确定合并基础。有关其他选项，请参见&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91b115a828fd51fba09fc11d7213ae15c1c47544" translate="yes" xml:space="preserve">
          <source>One important aspect of Git is its distributed nature, which largely means there is no inherent &quot;upstream&quot; or &quot;downstream&quot; in the system. On the face of it, the above example might seem to indicate that the tag namespace is owned by the upper echelon of people and that tags only flow downwards, but that is not the case. It only shows that the usage pattern determines who are interested in whose tags.</source>
          <target state="translated">Git的一个重要方面是它的分布式特性,这很大程度上意味着系统中没有固有的 &quot;上游 &quot;或 &quot;下游&quot;。从表面上看,上面的例子似乎表明,标签命名空间是由上层人员拥有的,标签只能向下流动,但事实并非如此。它只是表明,使用模式决定了谁对谁的标签感兴趣。</target>
        </trans-unit>
        <trans-unit id="04ced8b13491984476dfed877ea62bd96c9df7a6" translate="yes" xml:space="preserve">
          <source>One major difference between &lt;code&gt;git submodule update&lt;/code&gt; and &lt;code&gt;git submodule add&lt;/code&gt; is that &lt;code&gt;git submodule update&lt;/code&gt; checks out a specific commit, rather than the tip of a branch. It&amp;rsquo;s like checking out a tag: the head is detached, so you&amp;rsquo;re not working on a branch.</source>
          <target state="translated">&lt;code&gt;git submodule update&lt;/code&gt; 和 &lt;code&gt;git submodule add&lt;/code&gt; 之间的主要区别是 &lt;code&gt;git submodule update&lt;/code&gt; 签出特定的提交，而不是分支的尖端。这就像签出一个标签：头部是分离的，所以您不在分支上工作。</target>
        </trans-unit>
        <trans-unit id="8d6438f7bb62b577ed24501432d3010343f7c06f" translate="yes" xml:space="preserve">
          <source>One nice about &quot;git bisect&quot; is that it is not only a developer tool. It can effectively be used by QA people or even end users (if they have access to the source code or if they can get access to all the builds).</source>
          <target state="translated">git bisect &quot;的一个好处是,它不仅仅是一个开发者工具。它可以有效地被QA人员甚至最终用户使用(如果他们能够访问源代码或者能够访问所有的构建)。</target>
        </trans-unit>
        <trans-unit id="142f19dfe765b1c5ce574050578fa3bc8f7c4c07" translate="yes" xml:space="preserve">
          <source>One note: the special &lt;code&gt;master&lt;/code&gt; head is the default branch, which is why the &lt;code&gt;.git/HEAD&lt;/code&gt; file was created points to it even if it doesn&amp;rsquo;t yet exist. Basically, the &lt;code&gt;HEAD&lt;/code&gt; link is supposed to always point to the branch you are working on right now, and you always start out expecting to work on the &lt;code&gt;master&lt;/code&gt; branch.</source>
          <target state="translated">注意：特殊的 &lt;code&gt;master&lt;/code&gt; 头是默认分支，这就是创建 &lt;code&gt;.git/HEAD&lt;/code&gt; 文件的原因，即使它不存在也是如此。基本上， &lt;code&gt;HEAD&lt;/code&gt; 链接应该总是指向您现在正在处理的分支，并且您总是开始期望在 &lt;code&gt;master&lt;/code&gt; 分支上工作。</target>
        </trans-unit>
        <trans-unit id="29a0c8f350324f991b248dd3aa593e11f5862130" translate="yes" xml:space="preserve">
          <source>One obvious improvement to this algorithm would be to look for a commit that has an associated value near the one of the best bisection commit, and that is on another branch, before using the PRNG. Because if such a commit exists, then it is not very likely to be untestable too, so it will probably give more information than a nearly randomly chosen one.</source>
          <target state="translated">对这个算法的一个明显改进是,在使用PRNG之前,先寻找一个相关值接近最佳二分法提交的提交,而且是在另一个分支上。因为如果存在这样的提交,那么它也不太可能是不可测试的,所以它可能会比一个近乎随机选择的提交提供更多的信息。</target>
        </trans-unit>
        <trans-unit id="e1159b72c8727d654a00df87bb5a62e68448d486" translate="yes" xml:space="preserve">
          <source>One of the following transports can be used to name the repository to download from:</source>
          <target state="translated">可以使用以下传输方式之一来命名要下载的版本库。</target>
        </trans-unit>
        <trans-unit id="f2e9320213d36179f9f718d529b707eca70ac72d" translate="yes" xml:space="preserve">
          <source>One of the ideas of having a branch is that you do some (possibly experimental) work in it, and eventually merge it back to the main branch. So assuming you created the above &lt;code&gt;mybranch&lt;/code&gt; that started out being the same as the original &lt;code&gt;master&lt;/code&gt; branch, let&amp;rsquo;s make sure we&amp;rsquo;re in that branch, and do some work there.</source>
          <target state="translated">拥有分支的想法之一是，您要在其中进行一些（可能是实验性的）工作，并最终将其合并回主分支。因此，假设您创建的 &lt;code&gt;mybranch&lt;/code&gt; 最初与原始 &lt;code&gt;master&lt;/code&gt; 分支相同，那么请确保我们在该分支中，并在那里进行一些工作。</target>
        </trans-unit>
        <trans-unit id="07b5c446feb269c31391e3ec2cd0376191f84e84" translate="yes" xml:space="preserve">
          <source>One of the identifiers &quot;&lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;#def_tree_object&quot;&gt;tree&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;#def_tag_object&quot;&gt;tag&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt;&quot; describing the type of an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;.</source>
          <target state="translated">标识符&amp;ldquo; &lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt; &amp;rdquo;，&amp;ldquo; &lt;a href=&quot;#def_tree_object&quot;&gt;tree&lt;/a&gt; &amp;rdquo;，&amp;ldquo; &lt;a href=&quot;#def_tag_object&quot;&gt;tag&lt;/a&gt; &amp;rdquo;或&amp;ldquo; &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; &amp;rdquo;之一，描述&lt;a href=&quot;#def_object&quot;&gt;对象&lt;/a&gt;的类型。</target>
        </trans-unit>
        <trans-unit id="4cfd499f1faa2bf47281b08252a27709dbf65c31" translate="yes" xml:space="preserve">
          <source>One or more of the options below may be used to determine the files shown:</source>
          <target state="translated">以下一个或多个选项可用于确定显示的文件。</target>
        </trans-unit>
        <trans-unit id="5fdc57e5472e4e105b70357796e6b6c7c9687799" translate="yes" xml:space="preserve">
          <source>One or more of the provided paths is ignored.</source>
          <target state="translated">忽略一个或多个提供的路径。</target>
        </trans-unit>
        <trans-unit id="fa8d672b6bbfcb201a67403df350a9a5a712d006" translate="yes" xml:space="preserve">
          <source>One phase in branch detection involves looking at p4 branches to find new ones to import. By default, all branches are inspected. This option limits the search to just those owned by the single user named in the variable.</source>
          <target state="translated">分支检测中的一个阶段包括查看p4分支,以找到新的分支来导入。默认情况下,所有的分支都会被检测。这个选项限制了搜索范围,只限于那些在变量中命名的单个用户所拥有的分支。</target>
        </trans-unit>
        <trans-unit id="11468bd4c23009003db390c522332f7c3d2a8eae" translate="yes" xml:space="preserve">
          <source>One problem with &quot;git replace&quot; is that currently it stores all the replacements refs in &quot;refs/replace/&quot;, but it would be perhaps better if the replacement refs that are useful only for bisecting would be in &quot;refs/replace/bisect/&quot;. This way the replacement refs could be used only for bisecting, while other refs directly in &quot;refs/replace/&quot; would be used nearly all the time.</source>
          <target state="translated">git replace 的一个问题是,目前它把所有的替换 refs 都存储在 &quot;refs/replace/&quot;中,但如果把只对二分法有用的替换 refs 放在 &quot;refs/replace/bisect/&quot;中也许会更好。这样一来,替换的参考文献就可以只用于二分法,而直接放在 &quot;refs/replace/&quot;中的其他参考文献几乎所有时间都会被使用。</target>
        </trans-unit>
        <trans-unit id="d1e2a86cedb580a377c28acdbf81410bf88bf79b" translate="yes" xml:space="preserve">
          <source>One record (for project / repository) per line; does not support line continuation (newline escaping).</source>
          <target state="translated">每行一条记录(针对项目/仓库);不支持续行(换行)。</target>
        </trans-unit>
        <trans-unit id="8e018f50410d5f4a4feb43d8b0ec18d17af4444c" translate="yes" xml:space="preserve">
          <source>One such software is the Linux kernel. And if we look at the Linux kernel, we can see that a lot of time and effort is spent to fight regressions. The release cycle start with a 2 weeks long merge window. Then the first release candidate (rc) version is tagged. And after that about 7 or 8 more rc versions will appear with around one week between each of them, before the final release.</source>
          <target state="translated">Linux内核就是这样一款软件。而如果我们看一下Linux内核,就会发现,我们花了很多时间和精力来对抗回归。发布周期从2周长的合并窗口开始。然后第一个发布候选版本(rc)被标记。在这之后,大约会出现7到8个更多的rc版本,每一个版本之间会相隔一周左右,然后才是最终的版本。</target>
        </trans-unit>
        <trans-unit id="bdac2081c61d66c365f2d2f97739c2e3f666a74e" translate="yes" xml:space="preserve">
          <source>One usage scenario is to run unit tests in the hook.</source>
          <target state="translated">一个使用场景是在钩子中运行单元测试。</target>
        </trans-unit>
        <trans-unit id="f9e9013eccf2a70e5a5f30b1ea62b3495fc5c835" translate="yes" xml:space="preserve">
          <source>One use of the content filtering is to massage the content into a shape that is more convenient for the platform, filesystem, and the user to use. For this mode of operation, the key phrase here is &quot;more convenient&quot; and not &quot;turning something unusable into usable&quot;. In other words, the intent is that if someone unsets the filter driver definition, or does not have the appropriate filter program, the project should still be usable.</source>
          <target state="translated">内容过滤的一个用途是将内容按摩成更方便平台、文件系统和用户使用的形状。对于这种操作模式,这里的关键词是 &quot;更方便&quot;,而不是 &quot;把不可用的东西变成可用的&quot;。换句话说,我们的意图是,如果有人取消了过滤驱动定义,或者没有相应的过滤程序,项目应该还是可以使用的。</target>
        </trans-unit>
        <trans-unit id="bf346c4d1c8b72f5f128424640398ae0ca4f5b99" translate="yes" xml:space="preserve">
          <source>One way to test if your MUA is set up correctly is:</source>
          <target state="translated">测试你的MUA设置是否正确的一个方法是。</target>
        </trans-unit>
        <trans-unit id="2d149b07bfc5760abe904c522d47cdc6ed806f7c" translate="yes" xml:space="preserve">
          <source>Only allow &lt;code&gt;--filter=tree:&amp;lt;n&amp;gt;&lt;/code&gt; when &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; is no more than the value of &lt;code&gt;uploadpackfilter.tree.maxDepth&lt;/code&gt;. If set, this also implies &lt;code&gt;uploadpackfilter.tree.allow=true&lt;/code&gt;, unless this configuration variable had already been set. Has no effect if unset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7da7d48889d5c708679796bf76623241882d879" translate="yes" xml:space="preserve">
          <source>Only allow viewing of repositories also shown on the overview page. This for example makes &lt;code&gt;$export_ok&lt;/code&gt; file decide if repository is available and not only if it is shown. If &lt;code&gt;$projects_list&lt;/code&gt; points to file with list of project, only those repositories listed would be available for gitweb. Can be set during building gitweb via &lt;code&gt;GITWEB_STRICT_EXPORT&lt;/code&gt;. By default this variable is not set, which means that you can directly access those repositories that are hidden from projects list page (e.g. the are not listed in the $projects_list file).</source>
          <target state="translated">只允许查看也在概述页面上显示的存储库。例如，这使 &lt;code&gt;$export_ok&lt;/code&gt; 文件决定存储库是否可用，不仅决定是否显示存储库。如果 &lt;code&gt;$projects_list&lt;/code&gt; 指向包含项目列表的文件，则只有列出的存储库可用于gitweb。可以在构建gitweb时通过 &lt;code&gt;GITWEB_STRICT_EXPORT&lt;/code&gt; 进行设置。默认情况下，未设置此变量，这意味着您可以直接访问从项目列表页面隐藏的存储库（例如，未在$ projects_list文件中列出的存储库）。</target>
        </trans-unit>
        <trans-unit id="a9db6957ecdccb26c443588b379fe63817da234e" translate="yes" xml:space="preserve">
          <source>Only anonymous access is provided by pserve by default. To commit you will have to create pserver accounts, simply add a gitcvs.authdb setting in the config file of the repositories you want the cvsserver to allow writes to, for example:</source>
          <target state="translated">pserve默认只提供匿名访问。如果要提交,你必须创建 pserver 账户,只需在你希望 cvsserver 允许写入的仓库的配置文件中添加 gitcvs.authdb 设置即可,例如</target>
        </trans-unit>
        <trans-unit id="f8de1f9ddde9f99ee756c31ae048d708dda7832c" translate="yes" xml:space="preserve">
          <source>Only bind the web server to the local IP (127.0.0.1).</source>
          <target state="translated">只将Web服务器绑定到本地IP(127.0.0.1)。</target>
        </trans-unit>
        <trans-unit id="914060d4007bba68d0e5b57a08eb8520cbc0281b" translate="yes" xml:space="preserve">
          <source>Only consider tags matching the given &lt;code&gt;glob(7)&lt;/code&gt; pattern, excluding the &quot;refs/tags/&quot; prefix. If used with &lt;code&gt;--all&lt;/code&gt;, it also considers local branches and remote-tracking references matching the pattern, excluding respectively &quot;refs/heads/&quot; and &quot;refs/remotes/&quot; prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated, and tags matching any of the patterns will be considered. Use &lt;code&gt;--no-match&lt;/code&gt; to clear and reset the list of patterns.</source>
          <target state="translated">仅考虑匹配给定 &lt;code&gt;glob(7)&lt;/code&gt; 模式的标签，但不包括&amp;ldquo; refs / tags /&amp;rdquo;前缀。如果与 &lt;code&gt;--all&lt;/code&gt; 一起使用，它还将考虑与该模式匹配的本地分支和远程跟踪引用，分别排除&amp;ldquo; refs / heads /&amp;rdquo;和&amp;ldquo; refs / remotes /&amp;rdquo;前缀；从不考虑其他类型的引用。如果多次给出，将累积模式列表，并考虑与任何模式匹配的标签。使用 &lt;code&gt;--no-match&lt;/code&gt; 清除并重置模式列表。</target>
        </trans-unit>
        <trans-unit id="941066ff4f5ea2a1056ac361a36573c125ff04f2" translate="yes" xml:space="preserve">
          <source>Only create a packed archive if it would contain at least one object.</source>
          <target state="translated">只有在至少包含一个对象的情况下,才会创建一个打包的存档。</target>
        </trans-unit>
        <trans-unit id="83ca14f8cd2c9566aaa74ad9a438e0a15bc783b9" translate="yes" xml:space="preserve">
          <source>Only expire loose objects older than &amp;lt;time&amp;gt;.</source>
          <target state="translated">仅使早于&amp;lt;time&amp;gt;的松散对象过期。</target>
        </trans-unit>
        <trans-unit id="d50becec82fb156672fd24c1ecb55cefe6d9b0c0" translate="yes" xml:space="preserve">
          <source>Only list branches of the given object.</source>
          <target state="translated">只列出给定对象的分支。</target>
        </trans-unit>
        <trans-unit id="ae8314faed018be3007d334a54cd4f7b3bde067a" translate="yes" xml:space="preserve">
          <source>Only list branches which contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">仅列出包含指定提交的分支（如果未指定，则为HEAD）。暗示 &lt;code&gt;--list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b39fcb7ccfd206d2a11b5cac77f876ebbcdc59a6" translate="yes" xml:space="preserve">
          <source>Only list branches which don&amp;rsquo;t contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">仅列出不包含指定提交的分支（如果未指定，则为HEAD）。暗示 &lt;code&gt;--list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d91bc93b24e96b92cd74b3016507c8892f02d8e" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are not reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;, incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">仅列出其提示无法从指定提交（如果未指定，则为HEAD）无法到达的分支。表示 &lt;code&gt;--list&lt;/code&gt; ，与 &lt;code&gt;--merged&lt;/code&gt; 不兼容。</target>
        </trans-unit>
        <trans-unit id="7f18c194fbea0e6a25127dd2c0242348888bebb8" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are not reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368e1f5311ab357c6579dd2598d3554e5f69ab7b" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;, incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">仅列出其提示可从指定提交（如果未指定，则为HEAD）可到达的分支。表示 &lt;code&gt;--list&lt;/code&gt; ，与 &lt;code&gt;--no-merged&lt;/code&gt; 不兼容。</target>
        </trans-unit>
        <trans-unit id="8e8c13c3ac0a7b1c9d8836463a5f79c31b1444a5" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc004fe98c7c853edcd721c4a4743bbe17dc0ceb" translate="yes" xml:space="preserve">
          <source>Only list refs which contain the specified commit (HEAD if not specified).</source>
          <target state="translated">只列出包含指定提交的refs(如果没有指定HEAD)。</target>
        </trans-unit>
        <trans-unit id="53301ab6d13e8c23069a84dba2acf3daf5a67784" translate="yes" xml:space="preserve">
          <source>Only list refs which don&amp;rsquo;t contain the specified commit (HEAD if not specified).</source>
          <target state="translated">仅列出不包含指定提交的引用（如果未指定，则为HEAD）。</target>
        </trans-unit>
        <trans-unit id="13917fddfb76486aac0b6b32382a8222d7ef7129" translate="yes" xml:space="preserve">
          <source>Only list refs which points at the given object.</source>
          <target state="translated">只列出指向给定对象的参考文献。</target>
        </trans-unit>
        <trans-unit id="d63446ed3ed439dd64fa48118858d7dc8f885568" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are not reachable from the specified commit (HEAD if not specified), incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">仅列出其提示无法从指定提交（如果未指定， &lt;code&gt;--merged&lt;/code&gt; HEAD）无法获得的列表引用，与--merged不兼容。</target>
        </trans-unit>
        <trans-unit id="a3045719971c55f87c34a7fd746215fdcca5bdb6" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are not reachable from the specified commit (HEAD if not specified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d24af2a09941026de883e7412997a62ab6d500" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are reachable from the specified commit (HEAD if not specified), incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">仅列出其提示可从指定提交（如果未指定，则为HEAD）可访问的列表引用，与 &lt;code&gt;--no-merged&lt;/code&gt; 不兼容。</target>
        </trans-unit>
        <trans-unit id="ba8f796a110a2bce3b3362030f4149e3e571d92d" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are reachable from the specified commit (HEAD if not specified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817a4e30ee524e4266621c0a4648ab3909ffeed4" translate="yes" xml:space="preserve">
          <source>Only list tags of the given object (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">仅列出给定对象的标签（如果未指定，则为HEAD）。暗示 &lt;code&gt;--list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83f1d08e3476b4b0f43eedc9885a23e56ff396f3" translate="yes" xml:space="preserve">
          <source>Only list tags which contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">仅列出包含指定提交的标签（如果未指定，则为HEAD）。暗示 &lt;code&gt;--list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bae480f98a8915919a61381cb993558ff75823a" translate="yes" xml:space="preserve">
          <source>Only list tags which don&amp;rsquo;t contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">仅列出不包含指定提交的标记（如果未指定，则为HEAD）。暗示 &lt;code&gt;--list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db9714bdab86b2c5263129a27ca40bb06f5dcdf2" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are not reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified), incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">仅列出其提交不能从指定提交（如果未指定， &lt;code&gt;--merged&lt;/code&gt; &lt;code&gt;HEAD&lt;/code&gt; ）无法与--merged兼容的标记。</target>
        </trans-unit>
        <trans-unit id="0941b6737a5c9cc5d8d6c699e027514c86f27e53" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are not reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c62aa2054943bc2c5749c5693c2757ab8e53449" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified), incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">仅列出可从指定提交（如果未指定，则为 &lt;code&gt;HEAD&lt;/code&gt; ）可实现提交的标记，与 &lt;code&gt;--no-merged&lt;/code&gt; 不兼容。</target>
        </trans-unit>
        <trans-unit id="bc01884094a83344ad50773c56388f9731a753fa" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cdb0cde0c40de0beaaced5d658f2a7018630fe" translate="yes" xml:space="preserve">
          <source>Only look at the history which touches the given subdirectory. The result will contain that directory (and only that) as its project root. Implies &lt;a href=&quot;#Remap_to_ancestor&quot;&gt;Remap to ancestor&lt;/a&gt;.</source>
          <target state="translated">只查看涉及给定子目录的历史记录。结果将包含该目录（并且仅包含该目录）作为其项目根目录。暗示重新&lt;a href=&quot;#Remap_to_ancestor&quot;&gt;映射到祖先&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2bbdf47a64eee45ee95696813788d11863c01152" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Lets the option parser stop at the first non-option argument. This can be used to parse sub-commands that take options themselves.</source>
          <target state="translated">仅在 &lt;code&gt;--parseopt&lt;/code&gt; 模式下有意义。使选项解析器在第一个非选项参数处停止。这可用于解析本身带有选项的子命令。</target>
        </trans-unit>
        <trans-unit id="d8057f98f6fd66c86adb34f091c531e316f7ca42" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Output the options in their long form if available, and with their arguments stuck.</source>
          <target state="translated">仅在 &lt;code&gt;--parseopt&lt;/code&gt; 模式下有意义。如果可用，则以其长格式输出选项，并且将其参数卡住。</target>
        </trans-unit>
        <trans-unit id="6000fe90599266e72e627572d6cdbc969916ee02" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Tells the option parser to echo out the first &lt;code&gt;--&lt;/code&gt; met instead of skipping it.</source>
          <target state="translated">仅在 &lt;code&gt;--parseopt&lt;/code&gt; 模式下有意义。告诉选项解析器回声出第一 &lt;code&gt;--&lt;/code&gt; 遇见的不是跳过它。</target>
        </trans-unit>
        <trans-unit id="fd3f5d99fba63ca8e5d281298074650f7e9548b0" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--verify&lt;/code&gt; mode. Do not output an error message if the first argument is not a valid object name; instead exit with non-zero status silently. SHA-1s for valid object names are printed to stdout on success.</source>
          <target state="translated">仅在 &lt;code&gt;--verify&lt;/code&gt; 模式下有意义。如果第一个参数不是有效的对象名称，则不输出错误消息；而是以非零状态静默退出。有效对象名称的SHA-1成功时将打印到标准输出。</target>
        </trans-unit>
        <trans-unit id="94590902338d0f64df58223a7c9238b6579f4aae" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--pathspec-from-file&lt;/code&gt;. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).</source>
          <target state="translated">仅对 &lt;code&gt;--pathspec-from-file&lt;/code&gt; 有意义。Pathspec元素用NUL字符分隔，所有其他字符按字面意义使用（包括换行符和引号）。</target>
        </trans-unit>
        <trans-unit id="0ecebefb0a1162c42954005e600970eacea40ab1" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--stdin&lt;/code&gt; or &lt;code&gt;--index-info&lt;/code&gt;; paths are separated with NUL character instead of LF.</source>
          <target state="translated">唯一有意义的与 &lt;code&gt;--stdin&lt;/code&gt; 或 &lt;code&gt;--index-info&lt;/code&gt; ; 路径用NUL字符而不是LF分隔。</target>
        </trans-unit>
        <trans-unit id="6ad4315a7f6c11660aa6c643c4b95eaab7a8d728" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--stdin&lt;/code&gt;; paths are separated with NUL character instead of LF.</source>
          <target state="translated">仅对 &lt;code&gt;--stdin&lt;/code&gt; 有意义；路径用NUL字符而不是LF分隔。</target>
        </trans-unit>
        <trans-unit id="2ebb91d27792ee23446f1d49f12e2e8cf850fef7" translate="yes" xml:space="preserve">
          <source>Only necessary if --compose is also set. If --compose is not set, this will be prompted for.</source>
          <target state="translated">只有在设置了--compose的情况下才需要。如果没有设置 ----组成,则会有提示。</target>
        </trans-unit>
        <trans-unit id="3a2cfa8e4dfa7576e427c217c4a335798a141827" translate="yes" xml:space="preserve">
          <source>Only one parameter should be set to &quot;1&quot; when the hook runs. The hook running passing &quot;1&quot;, &quot;1&quot; should not be possible.</source>
          <target state="translated">钩子运行时,只能设置一个参数为 &quot;1&quot;。钩子运行传递 &quot;1&quot;,&quot;1 &quot;应该是不可能的。</target>
        </trans-unit>
        <trans-unit id="bf7e12b67481a70907ee19a1cd34bdb9c2cfbcbb" translate="yes" xml:space="preserve">
          <source>Only output exact matches (a tag directly references the supplied commit). This is a synonym for --candidates=0.</source>
          <target state="translated">只输出完全匹配的内容(标签直接引用提供的提交)。这是 --candidates=0 的同义词。</target>
        </trans-unit>
        <trans-unit id="16dbfb260245eaec3998212f13b1a52e2d286e0a" translate="yes" xml:space="preserve">
          <source>Only p4 labels matching this regular expression will be exported. The default value is &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt;.</source>
          <target state="translated">仅匹配此正则表达式的p4标签将被导出。默认值为 &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eeb8bb30ea7ba21536e78e1ff49007a02268174b" translate="yes" xml:space="preserve">
          <source>Only p4 labels matching this regular expression will be imported. The default value is &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt;.</source>
          <target state="translated">仅匹配此正则表达式的p4标签将被导入。默认值为 &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2fdb861f4cc24f6e2448e8ab0d3c248ec24997f" translate="yes" xml:space="preserve">
          <source>Only perform tests on the working directory to make sure untracked cache can be used. You have to manually enable untracked cache using &lt;code&gt;--untracked-cache&lt;/code&gt; or &lt;code&gt;--force-untracked-cache&lt;/code&gt; or the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable afterwards if you really want to use it. If a test fails the exit code is 1 and a message explains what is not working as needed, otherwise the exit code is 0 and OK is printed.</source>
          <target state="translated">仅在工作目录上执行测试以确保可以使用未跟踪的缓存。您必须使用手动启用未跟踪缓存 &lt;code&gt;--untracked-cache&lt;/code&gt; 或 &lt;code&gt;--force-untracked-cache&lt;/code&gt; 或 &lt;code&gt;core.untrackedCache&lt;/code&gt; 配置变量之后，如果你真的想用它。如果测试失败，则退出代码为1，并显示一条消息，说明无法根据需要进行操作，否则退出代码为0，并打印OK。</target>
        </trans-unit>
        <trans-unit id="9b88e48a96d98ad3b76de8b5d274db692fc6b29c" translate="yes" xml:space="preserve">
          <source>Only print error and warning messages; all other output will be suppressed.</source>
          <target state="translated">只打印错误和警告信息,其他所有输出都将被抑制。</target>
        </trans-unit>
        <trans-unit id="3791d8648f923430d0795b4e9f5031ac211bf7f1" translate="yes" xml:space="preserve">
          <source>Only print error messages.</source>
          <target state="translated">只打印错误信息。</target>
        </trans-unit>
        <trans-unit id="affbeb73b1dd267a08167d9ea74afe477ad3529f" translate="yes" xml:space="preserve">
          <source>Only show the SHA-1 hash, not the reference name. When combined with --dereference the dereferenced tag will still be shown after the SHA-1.</source>
          <target state="translated">只显示SHA-1哈希值,不显示引用名称。当与--dereference结合使用时,在SHA-1之后仍然会显示被取消引用的标签。</target>
        </trans-unit>
        <trans-unit id="74a12c610ac9d71beb7074574ccb847224f9f712" translate="yes" xml:space="preserve">
          <source>Only show the given commits, but do not traverse their ancestors. This has no effect if a range is specified. If the argument &lt;code&gt;unsorted&lt;/code&gt; is given, the commits are shown in the order they were given on the command line. Otherwise (if &lt;code&gt;sorted&lt;/code&gt; or no argument was given), the commits are shown in reverse chronological order by commit time. Cannot be combined with &lt;code&gt;--graph&lt;/code&gt;.</source>
          <target state="translated">仅显示给定的提交，而不遍历其祖先。如果指定范围，则无效。如果给出了 &lt;code&gt;unsorted&lt;/code&gt; 参数，则按照在命令行中给出的顺序显示提交。否则（如果已 &lt;code&gt;sorted&lt;/code&gt; 或未提供任何参数），则提交将按提交时间以相反的时间顺序显示。不能与 &lt;code&gt;--graph&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="6ed956e65db38a49fac1dac50248e7edb1c43fb7" translate="yes" xml:space="preserve">
          <source>Only submodules using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will be removed from the work tree, as their repository lives inside the .git directory of the superproject. If a submodule (or one of those nested inside it) still uses a .git directory, &lt;code&gt;git rm&lt;/code&gt; will move the submodules git directory into the superprojects git directory to protect the submodule&amp;rsquo;s history. If it exists the submodule.&amp;lt;name&amp;gt; section in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file will also be removed and that file will be staged (unless --cached or -n are used).</source>
          <target state="translated">只有使用gitfile的子模块（这意味着它们是使用1.7.8或更高版本的Git版本克隆的）才会从工作树中删除，因为它们的存储库位于超级项目的.git目录中。如果子模块（或其中一个嵌套模块）仍使用.git目录，则 &lt;code&gt;git rm&lt;/code&gt; 会将子模块git目录移动到superprojects git目录中，以保护子模块的历史记录。如果存在，则&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;文件中的submodule。&amp;lt;name&amp;gt;部分也将被删除并暂存该文件（除非使用--cached或-n）。</target>
        </trans-unit>
        <trans-unit id="f3b6918bb732fd2722633a305233dd0ec34bff15" translate="yes" xml:space="preserve">
          <source>Only takes effect for dates shown in human-readable format, such as when using &lt;code&gt;--pretty&lt;/code&gt;. &lt;code&gt;log.date&lt;/code&gt; config variable sets a default value for the log command&amp;rsquo;s &lt;code&gt;--date&lt;/code&gt; option. By default, dates are shown in the original time zone (either committer&amp;rsquo;s or author&amp;rsquo;s). If &lt;code&gt;-local&lt;/code&gt; is appended to the format (e.g., &lt;code&gt;iso-local&lt;/code&gt;), the user&amp;rsquo;s local time zone is used instead.</source>
          <target state="translated">仅对以人类可读格式显示的日期生效，例如使用 &lt;code&gt;--pretty&lt;/code&gt; 时。 &lt;code&gt;log.date&lt;/code&gt; 配置变量为log命令的 &lt;code&gt;--date&lt;/code&gt; 选项设置默认值。默认情况下，日期显示在原始时区（提交者或作者的时间）中。如果将 &lt;code&gt;-local&lt;/code&gt; 附加到格式（例如 &lt;code&gt;iso-local&lt;/code&gt; ），则使用用户的本地时区。</target>
        </trans-unit>
        <trans-unit id="28227446e42814d459bad1017137f194a3d411bf" translate="yes" xml:space="preserve">
          <source>Only the initial ref advertisement is output, and the program exits immediately. This fits with the HTTP GET request model, where no request content is received but a response must be produced.</source>
          <target state="translated">只输出初始ref广告,程序立即退出。这符合HTTP GET请求模型,不接收请求内容,但必须产生响应。</target>
        </trans-unit>
        <trans-unit id="d70e32ee66c9f176a2ec41ee4464e248b98de054" translate="yes" xml:space="preserve">
          <source>Only the rev_map and refs/remotes/git-svn are changed (see &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; in the FILES section below for details). Follow &lt;code&gt;reset&lt;/code&gt; with a &lt;code&gt;fetch&lt;/code&gt; and then &lt;code&gt;git reset&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt; to move local branches onto the new tree.</source>
          <target state="translated">仅rev_map和refs / remotes / git-svn被更改（有关详细信息，请参见下面&amp;ldquo; FILES&amp;rdquo;部分中的 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; ）。按照 &lt;code&gt;reset&lt;/code&gt; 与 &lt;code&gt;fetch&lt;/code&gt; ，然后 &lt;code&gt;git reset&lt;/code&gt; 或 &lt;code&gt;git rebase&lt;/code&gt; 到移动本地分支到新树。</target>
        </trans-unit>
        <trans-unit id="32e7b8a674c1b57420afbf6e783864cc587eae94" translate="yes" xml:space="preserve">
          <source>Only the selected commits are shown, plus some to have a meaningful history.</source>
          <target state="translated">只显示选定的提交,加上一些有意义的历史。</target>
        </trans-unit>
        <trans-unit id="5988bcb17bfff8bdefbf4f11c653c30a84ac354c" translate="yes" xml:space="preserve">
          <source>Only untracked files in submodules will be ignored. Committed differences and modifications to tracked files will show up.</source>
          <target state="translated">只有子模块中未跟踪的文件会被忽略。已提交的差异和对已跟踪文件的修改会显示出来。</target>
        </trans-unit>
        <trans-unit id="a35d5f8b7ffccc1327ae3b4b170fadaf17be62a8" translate="yes" xml:space="preserve">
          <source>Only update and add files to the working directory, but don&amp;rsquo;t delete them, similar to how 'cp -R' would update the contents in the destination directory. This is the default mode in a &lt;a href=&quot;#def_checkout&quot;&gt;checkout&lt;/a&gt; when checking out files from the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; or a &lt;a href=&quot;#def_tree-ish&quot;&gt;tree-ish&lt;/a&gt;. In contrast, no-overlay mode also deletes tracked files not present in the source, similar to 'rsync --delete'.</source>
          <target state="translated">仅更新文件并将其添加到工作目录中，而不删除它们，类似于'cp -R'将更新目标目录中的内容。这是在默认模式&lt;a href=&quot;#def_checkout&quot;&gt;结账&lt;/a&gt;退房从文件时&lt;a href=&quot;#def_index&quot;&gt;指数&lt;/a&gt;或&lt;a href=&quot;#def_tree-ish&quot;&gt;树十岁上下&lt;/a&gt;。相反，无覆盖模式也会删除源中不存在的跟踪文件，类似于&amp;ldquo; rsync --delete&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a09a6feef23c1bf8bf8489c07fa754b0e3467e64" translate="yes" xml:space="preserve">
          <source>Only update and add files to the working directory, but don&amp;rsquo;t delete them, similar to how &lt;code&gt;cp -R&lt;/code&gt; would update the contents in the destination directory. This is the default mode in a &lt;a href=&quot;#def_checkout&quot;&gt;checkout&lt;/a&gt; when checking out files from the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; or a &lt;a href=&quot;#def_tree-ish&quot;&gt;tree-ish&lt;/a&gt;. In contrast, no-overlay mode also deletes tracked files not present in the source, similar to &lt;code&gt;rsync --delete&lt;/code&gt;.</source>
          <target state="translated">仅更新文件并将其添加到工作目录中，而不删除它们，类似于 &lt;code&gt;cp -R&lt;/code&gt; 将更新目标目录中的内容。这是在默认模式&lt;a href=&quot;#def_checkout&quot;&gt;结账&lt;/a&gt;退房从文件时&lt;a href=&quot;#def_index&quot;&gt;指数&lt;/a&gt;或&lt;a href=&quot;#def_tree-ish&quot;&gt;树十岁上下&lt;/a&gt;。相反，无覆盖模式也会删除源中不存在的跟踪文件，类似于 &lt;code&gt;rsync --delete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd6ac5160ec46e3d1df2371d183d50a5e06ffdbe" translate="yes" xml:space="preserve">
          <source>Only use refs whose names match a given shell pattern. The pattern can be one of branch name, tag name or fully qualified ref name. If given multiple times, use refs whose names match any of the given shell patterns. Use &lt;code&gt;--no-refs&lt;/code&gt; to clear any previous ref patterns given.</source>
          <target state="translated">仅使用名称与给定外壳模式匹配的引用。该模式可以是分支名称，标记名称或标准引用名称之一。如果多次给出，请使用名称与任何给定的shell模式匹配的refs。使用 &lt;code&gt;--no-refs&lt;/code&gt; 清除以前给定的所有引用模式。</target>
        </trans-unit>
        <trans-unit id="2d533153e7612cafa4bc7b83b50dd3abb697af0e" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;set-tree&lt;/code&gt; and &lt;code&gt;commit-diff&lt;/code&gt; commands.</source>
          <target state="translated">仅与 &lt;code&gt;dcommit&lt;/code&gt; ， &lt;code&gt;set-tree&lt;/code&gt; 和 &lt;code&gt;commit-diff&lt;/code&gt; 命令一起使用。</target>
        </trans-unit>
        <trans-unit id="901e1e4a237282bb48e582bb5bf0599881cd0084" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;init&lt;/code&gt; command. These are passed directly to &lt;code&gt;git init&lt;/code&gt;.</source>
          <target state="translated">仅与 &lt;code&gt;init&lt;/code&gt; 命令一起使用。这些直接传递给 &lt;code&gt;git init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5e61001de0ada8f2eb5dc9bbc0a16644112482b" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;set-tree&lt;/code&gt; command.</source>
          <target state="translated">仅与 &lt;code&gt;set-tree&lt;/code&gt; 命令一起使用。</target>
        </trans-unit>
        <trans-unit id="e227b5617ca7c2b377054ab1d12644a8cc591504" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--filter=&lt;/code&gt;; prints a list of the objects omitted by the filter. Object IDs are prefixed with a &amp;ldquo;~&amp;rdquo; character.</source>
          <target state="translated">仅对 &lt;code&gt;--filter=&lt;/code&gt; 有用；打印过滤器省略的对象列表。对象ID的前缀为&amp;ldquo;〜&amp;rdquo;字符。</target>
        </trans-unit>
        <trans-unit id="c898c5ecedbff05a6572c10f50d4d5872a590271" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; does not print the names of the object IDs that are found. This inverts &lt;code&gt;--object-names&lt;/code&gt;. This flag allows the output to be more easily parsed by commands such as &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt;.</source>
          <target state="translated">仅对 &lt;code&gt;--objects&lt;/code&gt; 有用；不打印找到的对象ID的名称。这会 &lt;code&gt;--object-names&lt;/code&gt; 。该标志允许通过&lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1]之&lt;/a&gt;类的命令更轻松地解析输出。</target>
        </trans-unit>
        <trans-unit id="cbbf115261d96b04c5005e948b7d150b4779f83e" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; print the names of the object IDs that are found. This is the default behavior.</source>
          <target state="translated">仅对 &lt;code&gt;--objects&lt;/code&gt; 有用；打印找到的对象ID的名称。这是默认行为。</target>
        </trans-unit>
        <trans-unit id="96aa4c0ed29b4ff25b67f82110d672c478c9f0a4" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; print the object IDs that are not in packs.</source>
          <target state="translated">仅对 &lt;code&gt;--objects&lt;/code&gt; 有用；打印不在包装中的对象ID。</target>
        </trans-unit>
        <trans-unit id="395c9938b3e2e6eaf4d1417f6499451782d5fa84" translate="yes" xml:space="preserve">
          <source>Only useful with one of the &lt;code&gt;--objects*&lt;/code&gt;; omits objects (usually blobs) from the list of printed objects. The &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; may be one of the following:</source>
          <target state="translated">仅对 &lt;code&gt;--objects*&lt;/code&gt; 之一有用；从打印对象列表中删除对象（通常是斑点）。所述 &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; 可以是下列之一：</target>
        </trans-unit>
        <trans-unit id="c55263ee2e693cf4a68e8c688a3aeedef8c016f1" translate="yes" xml:space="preserve">
          <source>Only valid setting is &quot;--unified=??&quot; or &quot;-u??&quot; to set the number of context lines shown when a unified diff is created. This takes precedence over any &quot;-U&quot; or &quot;--unified&quot; option value passed on the Git diff command line.</source>
          <target state="translated">只有&quot;--unified=? &quot;或&quot;-u? &quot;才是有效的设置,用于设置创建统一的 diff 时显示的上下文行数。它优先于Git diff命令行中传递的&quot;-U &quot;或&quot;--unified &quot;选项值。</target>
        </trans-unit>
        <trans-unit id="77fb8a535dafe4973135cbd89eaf06e8f07b4529" translate="yes" xml:space="preserve">
          <source>Only works if the changes (patch IDs based on the diff contents) on &lt;code&gt;subsystem&lt;/code&gt; are literally the same before and after the rebase &lt;code&gt;subsystem&lt;/code&gt; did.</source>
          <target state="translated">仅在 &lt;code&gt;subsystem&lt;/code&gt; 更改之前和之后， &lt;code&gt;subsystem&lt;/code&gt; 上的更改（基于diff内容的修补程序ID）在字面上相同时才起作用。</target>
        </trans-unit>
        <trans-unit id="5a64b44f8d7042d0b4832141c36a7e5d8d6c4434" translate="yes" xml:space="preserve">
          <source>Oops. That wasn&amp;rsquo;t very readable. It just spit out its own internal version of a &lt;code&gt;diff&lt;/code&gt;, but that internal version really just tells you that it has noticed that &quot;hello&quot; has been modified, and that the old object contents it had have been replaced with something else.</source>
          <target state="translated">哎呀。那不是很可读。它只是吐出了自己的 &lt;code&gt;diff&lt;/code&gt; 内部版本，但该内部版本实际上只是告诉您，它已经注意到&amp;ldquo; hello&amp;rdquo;已被修改，并且其旧对象内容已被其他内容替换。</target>
        </trans-unit>
        <trans-unit id="0e55d62611877e337f8aa065fb0b3d20e9fe0e5a" translate="yes" xml:space="preserve">
          <source>Open a compose window and click the external editor icon.</source>
          <target state="translated">打开编译窗口,点击外部编辑器图标。</target>
        </trans-unit>
        <trans-unit id="db4ff8c108e7b94773be0de613a7b629cb1df8fa" translate="yes" xml:space="preserve">
          <source>Open an editor and edit the text to explain what the branch is for, to be used by various other commands (e.g. &lt;code&gt;format-patch&lt;/code&gt;, &lt;code&gt;request-pull&lt;/code&gt;, and &lt;code&gt;merge&lt;/code&gt; (if enabled)). Multi-line explanations may be used.</source>
          <target state="translated">打开编辑器并编辑文本以解释分支的用途，该分支将由其他各种命令使用（例如 &lt;code&gt;format-patch&lt;/code&gt; ， &lt;code&gt;request-pull&lt;/code&gt; 和 &lt;code&gt;merge&lt;/code&gt; （如果启用））。可以使用多行说明。</target>
        </trans-unit>
        <trans-unit id="577c09c011d74bfddaa145d1c3817d3d9900cb19" translate="yes" xml:space="preserve">
          <source>Open the diff vs. the index in an editor and let the user edit it. After the editor was closed, adjust the hunk headers and apply the patch to the index.</source>
          <target state="translated">在编辑器中打开diff与index,让用户编辑。关闭编辑器后,调整hunk头,并将补丁应用到索引上。</target>
        </trans-unit>
        <trans-unit id="1e40bc8b6fc685aae183dd5f07e4256cd3e46abe" translate="yes" xml:space="preserve">
          <source>Open the matching files in the pager (not the output of &lt;code&gt;grep&lt;/code&gt;). If the pager happens to be &quot;less&quot; or &quot;vi&quot;, and the user specified only one pattern, the first file is positioned at the first match automatically. The &lt;code&gt;pager&lt;/code&gt; argument is optional; if specified, it must be stuck to the option without a space. If &lt;code&gt;pager&lt;/code&gt; is unspecified, the default pager will be used (see &lt;code&gt;core.pager&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">在分页器中打开匹配的文件（不是 &lt;code&gt;grep&lt;/code&gt; 的输出）。如果寻呼机恰好是&amp;ldquo;较少&amp;rdquo;或&amp;ldquo; vi&amp;rdquo;，并且用户仅指定了一个模式，则第一个文件将自动定位在第一个匹配项上。该 &lt;code&gt;pager&lt;/code&gt; 参数是可选的; 如果指定，则必须将其固定在选项中，且不能留空格。如果 &lt;code&gt;pager&lt;/code&gt; 未指定，则默认寻呼机将被使用（参见 &lt;code&gt;core.pager&lt;/code&gt; 在&lt;a href=&quot;git-config&quot;&gt;GIT-配置[1] &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8ab75f225f79420c5b860ca24bd40f7491c784f1" translate="yes" xml:space="preserve">
          <source>Opens an editor to modify the specified config file; either &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, or repository (default).</source>
          <target state="translated">打开编辑器来修改指定的配置文件；无论是 &lt;code&gt;--system&lt;/code&gt; ， &lt;code&gt;--global&lt;/code&gt; ，或储存库（默认值）。</target>
        </trans-unit>
        <trans-unit id="869e0439c9b6be4fa4547f64fcc46a677445443d" translate="yes" xml:space="preserve">
          <source>Operate quietly. Implies --no-progress.</source>
          <target state="translated">静静地运作。意味着没有进展。</target>
        </trans-unit>
        <trans-unit id="976297b1ff380abe9b067b3a1569ff64fe97ece7" translate="yes" xml:space="preserve">
          <source>Operate quietly. Progress is not reported to the standard error stream.</source>
          <target state="translated">静静地操作。不向标准误差流报告进度。</target>
        </trans-unit>
        <trans-unit id="09f22e6b29a644f35840ab8527beed58937c2452" translate="yes" xml:space="preserve">
          <source>Operating modes</source>
          <target state="translated">操作模式</target>
        </trans-unit>
        <trans-unit id="b5ddf3c63568d76ebc23d453be7fdb731eb8db1b" translate="yes" xml:space="preserve">
          <source>Operation Modes</source>
          <target state="translated">操作模式</target>
        </trans-unit>
        <trans-unit id="7196d0b4f156df0cb7286af7737967727f46300d" translate="yes" xml:space="preserve">
          <source>Operation modes</source>
          <target state="translated">操作模式</target>
        </trans-unit>
        <trans-unit id="1bc69d57cbb59ff5bdbc63f455c23bce178e5e54" translate="yes" xml:space="preserve">
          <source>Operations supported</source>
          <target state="translated">支持的业务</target>
        </trans-unit>
        <trans-unit id="573db325843d7fd90adea414c1ffec090ab48249" translate="yes" xml:space="preserve">
          <source>Optimize a pack that will be provided to a client with a shallow repository. This option, combined with --thin, can result in a smaller pack at the cost of speed.</source>
          <target state="translated">优化将提供给客户端的浅层存储库的数据包。这个选项和--thin结合起来,可以以牺牲速度为代价获得一个更小的包。</target>
        </trans-unit>
        <trans-unit id="4679da9817f2d593d1926870257534b31ee86cfa" translate="yes" xml:space="preserve">
          <source>Option commands must be the first commands on the input (not counting feature commands), to give an option command after any non-option command is an error.</source>
          <target state="translated">选项命令必须是输入的第一条命令(不算特征命令),在任何非选项命令之后给出选项命令是错误的。</target>
        </trans-unit>
        <trans-unit id="da44303dd559700c5ce39d2667eb27c2885407ef" translate="yes" xml:space="preserve">
          <source>Optional &amp;lt;path&amp;gt; arguments limit which submodules will be initialized. If no path is specified and submodule.active has been configured, submodules configured to be active will be initialized, otherwise all submodules are initialized.</source>
          <target state="translated">可选的&amp;lt;path&amp;gt;参数限制将初始化哪些子模块。如果未指定路径并且已配置submodule.active，则将初始化配置为活动的子模块，否则将初始化所有子模块。</target>
        </trans-unit>
        <trans-unit id="e95e402b64c3c594a37117914c5cb87d814b2b44" translate="yes" xml:space="preserve">
          <source>Optional modifiers can be provided in the beginning of the value to filter commands for specific actions: create (a), modify (m), delete (d). A &lt;code&gt;!&lt;/code&gt; can be included in the modifiers to negate the reference prefix entry. E.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be215efb6b35fec1e17ea79655a45bba1595ca40" translate="yes" xml:space="preserve">
          <source>Optionally a new branch could be created with either &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, automatically from a remote branch of same name (see &lt;code&gt;--guess&lt;/code&gt;), or detach the working tree from any branch with &lt;code&gt;--detach&lt;/code&gt;, along with switching.</source>
          <target state="translated">可选地，可以使用 &lt;code&gt;-c&lt;/code&gt; ， &lt;code&gt;-C&lt;/code&gt; 从同名的远程分支自动创建一个新分支（请参阅 &lt;code&gt;--guess&lt;/code&gt; ），或者使用 &lt;code&gt;--detach&lt;/code&gt; 将工作树与任何分支分离，并进行切换。</target>
        </trans-unit>
        <trans-unit id="d773dc6382eb3328de30b1c7224e0be840082992" translate="yes" xml:space="preserve">
          <source>Optionally may output a &lt;code&gt;lock &amp;lt;file&amp;gt;&lt;/code&gt; line indicating the full path of a file under &lt;code&gt;$GIT_DIR/objects/pack&lt;/code&gt; which is keeping a pack until refs can be suitably updated. The path must end with &lt;code&gt;.keep&lt;/code&gt;. This is a mechanism to name a &amp;lt;pack,idx,keep&amp;gt; tuple by giving only the keep component. The kept pack will not be deleted by a concurrent repack, even though its objects may not be referenced until the fetch completes. The &lt;code&gt;.keep&lt;/code&gt; file will be deleted at the conclusion of the fetch.</source>
          <target state="translated">（可选）可以输出一条 &lt;code&gt;lock &amp;lt;file&amp;gt;&lt;/code&gt; 行，该行指示 &lt;code&gt;$GIT_DIR/objects/pack&lt;/code&gt; 下文件的完整路径，该文件将保留一个包，直到可以适当更新引用为止。该路径必须以 &lt;code&gt;.keep&lt;/code&gt; 结尾。这是通过仅提供keep组件来命名&amp;lt;pack，idx，keep&amp;gt;元组的机制。即使在提取完成之前可能不会引用其对象，也不会通过并发重新打包删除保留的包。该 &lt;code&gt;.keep&lt;/code&gt; 文件将在抓取的结论被删除。</target>
        </trans-unit>
        <trans-unit id="66770b44a484bf62b3beb74f057263164da82747" translate="yes" xml:space="preserve">
          <source>Optionally with -m:</source>
          <target state="translated">可选择用-m。</target>
        </trans-unit>
        <trans-unit id="3e5a4f0fcbf7c88862ec022584d8faedebb202bf" translate="yes" xml:space="preserve">
          <source>Optionally, a &amp;lt;ref&amp;gt; parameter can be prefixed with a plus &lt;code&gt;+&lt;/code&gt; sign to disable the fast-forward check only on that ref.</source>
          <target state="translated">（可选）可以在&amp;lt;ref&amp;gt;参数前面加上加号 &lt;code&gt;+&lt;/code&gt; 以仅对该ref禁用快速转发检查。</target>
        </trans-unit>
        <trans-unit id="5ad18880dec3737f40f1be35d71296de89bc6175" translate="yes" xml:space="preserve">
          <source>Optionally, it can merge a tree into the index, perform a fast-forward (i.e. 2-way) merge, or a 3-way merge, with the &lt;code&gt;-m&lt;/code&gt; flag. When used with &lt;code&gt;-m&lt;/code&gt;, the &lt;code&gt;-u&lt;/code&gt; flag causes it to also update the files in the work tree with the result of the merge.</source>
          <target state="translated">可选地，它可以将树合并到索引中，使用 &lt;code&gt;-m&lt;/code&gt; 标志执行快进（即2向）合并或3向合并。与 &lt;code&gt;-m&lt;/code&gt; 一起使用时， &lt;code&gt;-u&lt;/code&gt; 标志会使它也使用合并结果来更新工作树中的文件。</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="c844411e7897e1475e2bbc7e1cd47d6ca3b70b75" translate="yes" xml:space="preserve">
          <source>Options for --parseopt</source>
          <target state="translated">--parseopt的选项</target>
        </trans-unit>
        <trans-unit id="9c25d7f1531501faea711b1933ac2734dd8f1324" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="7eec6c07b2d8ff28d282e8d3918c0430dfd638ff" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;expire&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expire&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="e73b9df34672d383e318c543fe1ed5467baa2316" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;show&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;show&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="fcc02e852676cd8c1162b2b42e5759f86fcae990" translate="yes" xml:space="preserve">
          <source>Options for Files</source>
          <target state="translated">文件的选项</target>
        </trans-unit>
        <trans-unit id="fd6ce8b428a235dff74127968e45c8e950a3e68b" translate="yes" xml:space="preserve">
          <source>Options for Filtering</source>
          <target state="translated">筛选选项</target>
        </trans-unit>
        <trans-unit id="f0e43560a9524e814096613f5d3adbb780ab9547" translate="yes" xml:space="preserve">
          <source>Options for Frontends</source>
          <target state="translated">幌子的选择</target>
        </trans-unit>
        <trans-unit id="6de07b5e7d3355f1ee784587e4e9b9310ce89167" translate="yes" xml:space="preserve">
          <source>Options for Objects</source>
          <target state="translated">对象的选项</target>
        </trans-unit>
        <trans-unit id="7bba8ce1354b61b02f672f2468b0b0f0c600077c" translate="yes" xml:space="preserve">
          <source>Options for Output</source>
          <target state="translated">输出选项</target>
        </trans-unit>
        <trans-unit id="b8bceb2d83c081f4f5d71559b2d0f07edc9ee034" translate="yes" xml:space="preserve">
          <source>Options for a credential context can be configured either in &lt;code&gt;credential.*&lt;/code&gt; (which applies to all credentials), or &lt;code&gt;credential.&amp;lt;url&amp;gt;.*&lt;/code&gt;, where &amp;lt;url&amp;gt; matches the context as described above.</source>
          <target state="translated">凭证上下文的选项可以在 &lt;code&gt;credential.*&lt;/code&gt; （适用于所有凭证）或 &lt;code&gt;credential.&amp;lt;url&amp;gt;.*&lt;/code&gt; ，其中&amp;lt;url&amp;gt;如上所述与上下文匹配。</target>
        </trans-unit>
        <trans-unit id="99e5139a65bfab6cb84777a431cb5c7403976793" translate="yes" xml:space="preserve">
          <source>Options related to fetching</source>
          <target state="translated">与获取相关的选项</target>
        </trans-unit>
        <trans-unit id="d96532d12a36cc4bb8cc0dcd0b87def47cb21823" translate="yes" xml:space="preserve">
          <source>Options related to merging</source>
          <target state="translated">与合并有关的选项</target>
        </trans-unit>
        <trans-unit id="d2ce95980d5d4dcb8790725834688357cc504679" translate="yes" xml:space="preserve">
          <source>Options with long option names can be negated by prefixing &lt;code&gt;--no-&lt;/code&gt;. For example, &lt;code&gt;git branch&lt;/code&gt; has the option &lt;code&gt;--track&lt;/code&gt; which is &lt;code&gt;on&lt;/code&gt; by default. You can use &lt;code&gt;--no-track&lt;/code&gt; to override that behaviour. The same goes for &lt;code&gt;--color&lt;/code&gt; and &lt;code&gt;--no-color&lt;/code&gt;.</source>
          <target state="translated">带有长选项名称的选项可以通过前缀 &lt;code&gt;--no-&lt;/code&gt; 来否定。例如， &lt;code&gt;git branch&lt;/code&gt; 有选择 &lt;code&gt;--track&lt;/code&gt; 这是 &lt;code&gt;on&lt;/code&gt; 默认情况下。您可以使用 &lt;code&gt;--no-track&lt;/code&gt; 覆盖该行为。这同样适用于 &lt;code&gt;--color&lt;/code&gt; 和 &lt;code&gt;--no-color&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28e5f716aa8e690cf7323a0d5515626aac785807" translate="yes" xml:space="preserve">
          <source>Or if you are looking for the commit that fixed a bug, you might use</source>
          <target state="translated">或者,如果您正在寻找修复了错误的提交,您可以使用</target>
        </trans-unit>
        <trans-unit id="9bcee5b07c3eb51996fe06466cb572259d48e74e" translate="yes" xml:space="preserve">
          <source>Or if you want more control, you can inspect the current state using for example &quot;git bisect visualize&quot;. It will launch gitk (or &quot;git log&quot; if the &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is not set) to help you find a better bisection point.</source>
          <target state="translated">或者，如果您想要更多控制，则可以使用&amp;ldquo; git bisect visualize&amp;rdquo;等检查当前状态。它将启动gitk（如果未设置 &lt;code&gt;DISPLAY&lt;/code&gt; 环境变量，则将启动git log ）以帮助您找到更好的平分点。</target>
        </trans-unit>
        <trans-unit id="ee046ba1657a42f0c8096ff30555d679415a486a" translate="yes" xml:space="preserve">
          <source>Or you could recall that the &lt;code&gt;&amp;hellip;​&lt;/code&gt; operator selects all commits reachable from either one reference or the other but not both; so</source>
          <target state="translated">或者你可以回顾一下， &lt;code&gt;&amp;hellip;​&lt;/code&gt; 运营商都选择从提交任何一个参考值或其他但不能同时到达; 所以</target>
        </trans-unit>
        <trans-unit id="9af1a9bbcb80d3a49080e3a67d92d5ab7f0cace1" translate="yes" xml:space="preserve">
          <source>Or you could recall that the &lt;code&gt;...&lt;/code&gt; operator selects all commits reachable from either one reference or the other but not both; so</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85642c3d553b535f4731e23589126805881407c" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;ve already committed the merge that you want to throw away,</source>
          <target state="translated">或者，如果您已经提交了要丢弃的合并，</target>
        </trans-unit>
        <trans-unit id="7ec7c556c34b1673fc7046a255bf7eb40c6a1622" translate="yes" xml:space="preserve">
          <source>Or, prepare and create the commit in one step:</source>
          <target state="translated">或者,准备和创建提交一步到位。</target>
        </trans-unit>
        <trans-unit id="6d9770079506b18bb9154a95e976f54ab47a2b44" translate="yes" xml:space="preserve">
          <source>Ordinary changed entries have the following format:</source>
          <target state="translated">普通的变更条目有以下格式:</target>
        </trans-unit>
        <trans-unit id="789d55cf79d409acbcc0305ff19dbfa36d82a93d" translate="yes" xml:space="preserve">
          <source>Ordinary commits are only included if they are !TREESAME (though this can be changed, see &lt;code&gt;--sparse&lt;/code&gt; below).</source>
          <target state="translated">普通提交仅在它们为！TREESAME时才包括在内（尽管可以更改，请参见下面的 &lt;code&gt;--sparse&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3b945495727bab8a02c63542fdf26a485a2839f4" translate="yes" xml:space="preserve">
          <source>Original (version 1) pack-*.idx files have the following format:</source>
          <target state="translated">原始(第1版)pack-*.idx文件的格式如下:</target>
        </trans-unit>
        <trans-unit id="cd07568ac3f8fe8b9f1ca323e6aea33ce69f4d0c" translate="yes" xml:space="preserve">
          <source>Originally, &lt;code&gt;git svn&lt;/code&gt; recommended that developers pulled or merged from the &lt;code&gt;git svn&lt;/code&gt; branch. This was because the author favored &lt;code&gt;git svn set-tree B&lt;/code&gt; to commit a single head rather than the &lt;code&gt;git svn set-tree A..B&lt;/code&gt; notation to commit multiple commits. Use of &lt;code&gt;git pull&lt;/code&gt; or &lt;code&gt;git merge&lt;/code&gt; with &lt;code&gt;git svn set-tree A..B&lt;/code&gt; will cause non-linear history to be flattened when committing into SVN and this can lead to merge commits unexpectedly reversing previous commits in SVN.</source>
          <target state="translated">最初， &lt;code&gt;git svn&lt;/code&gt; 建议开发人员从 &lt;code&gt;git svn&lt;/code&gt; 分支中拉出或合并。这是因为作者更喜欢 &lt;code&gt;git svn set-tree B&lt;/code&gt; 提交一个单独的头部，而不是 &lt;code&gt;git svn set-tree A..B&lt;/code&gt; 表示法来提交多个提交。与 &lt;code&gt;git svn set-tree A..B&lt;/code&gt; 一起使用 &lt;code&gt;git pull&lt;/code&gt; 或 &lt;code&gt;git merge&lt;/code&gt; 会导致非线性历史在提交到SVN中时变平，这可能导致合并提交意外地反转了SVN中的先前提交。</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="14bc34cb5d8d9f5a1986c4b4ced74a089ed31e83" translate="yes" xml:space="preserve">
          <source>Other &amp;lt;rev&amp;gt;^ Parent Shorthand Notations</source>
          <target state="translated">其他&amp;lt;rev&amp;gt; ^家长简写</target>
        </trans-unit>
        <trans-unit id="a3c040aeed88ddd482d5dec178bd5bb0b940738f" translate="yes" xml:space="preserve">
          <source>Other Items</source>
          <target state="translated">其他项目</target>
        </trans-unit>
        <trans-unit id="9cb6f2fb01dfa81e12bc1e11f0e7b676e54669fd" translate="yes" xml:space="preserve">
          <source>Other Options</source>
          <target state="translated">其他选择</target>
        </trans-unit>
        <trans-unit id="b66b145fc26fc91268f852efc133debcedca1335" translate="yes" xml:space="preserve">
          <source>Other ambiguity resolutions might be added in the future, but for now any other cases will error out with an error indicating what we tried, and depending on the &lt;code&gt;advice.pushUnqualifiedRefname&lt;/code&gt; configuration (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) suggest what refs/ namespace you may have wanted to push to.</source>
          <target state="translated">将来可能会添加其他歧义解决方案，但就目前而言，任何其他情况都会出错，并显示一个错误，指出我们尝试了什么，并根据 &lt;code&gt;advice.pushUnqualifiedRefname&lt;/code&gt; 配置（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）建议使用哪种refs /名称空间可能想推动。</target>
        </trans-unit>
        <trans-unit id="0d7c9916d5a97cfdd8b058afc3d1bac1c0a81b1f" translate="yes" xml:space="preserve">
          <source>Other arbitrary characters can also be encoded. For instance, &lt;code&gt;combine:tree:3+blob:none&lt;/code&gt; and &lt;code&gt;combine:tree%3A3+blob%3Anone&lt;/code&gt; are equivalent.</source>
          <target state="translated">其他任意字符也可以被编码。例如， &lt;code&gt;combine:tree%3A3+blob%3Anone&lt;/code&gt; &lt;code&gt;combine:tree:3+blob:none&lt;/code&gt; 和Combine：tree％3A3 + blob％3Anone是等效的。</target>
        </trans-unit>
        <trans-unit id="fca088ce123c6c3692799642c2a4b46b5050ca1e" translate="yes" xml:space="preserve">
          <source>Other consecutive asterisks are considered invalid.</source>
          <target state="translated">其他连续的星号视为无效。</target>
        </trans-unit>
        <trans-unit id="060f4f2bc2ee9b99f69af6360a0055db64443a39" translate="yes" xml:space="preserve">
          <source>Other consecutive asterisks are considered regular asterisks and will match according to the previous rules.</source>
          <target state="translated">其他连续的星号均视为常规星号,按照前面的规则进行匹配。</target>
        </trans-unit>
        <trans-unit id="3c7b99f717eee9f16429ca9a79551f060c8f8236" translate="yes" xml:space="preserve">
          <source>Other diff formats</source>
          <target state="translated">其他差异格式</target>
        </trans-unit>
        <trans-unit id="81458045196e38ce4846b13cecf95d14abe58433" translate="yes" xml:space="preserve">
          <source>Other git-related tools may and do use their own variables. When inventing new variables for use in your own tool, make sure their names do not conflict with those that are used by Git itself and other popular tools, and describe them in your documentation.</source>
          <target state="translated">其他与 git 相关的工具可能也会使用自己的变量。当你在自己的工具中发明新的变量时,请确保它们的名字不与 Git 本身和其他流行工具的名字冲突,并在文档中描述它们。</target>
        </trans-unit>
        <trans-unit id="97855915001e4fe7ef5deb1c023c4697931e633c" translate="yes" xml:space="preserve">
          <source>Other options are available to control how the manual page is displayed. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; for more information, because &lt;code&gt;git --help ...&lt;/code&gt; is converted internally into &lt;code&gt;git
help ...&lt;/code&gt;.</source>
          <target state="translated">其他选项可用于控制手册页的显示方式。见&lt;a href=&quot;git-help&quot;&gt;混帐的帮助[1]&lt;/a&gt;以获取更多信息，因为 &lt;code&gt;git --help ...&lt;/code&gt; 在内部转换成 &lt;code&gt;git help ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9c8373137a028157f66c53c01b431d29c570146" translate="yes" xml:space="preserve">
          <source>Other tools</source>
          <target state="translated">其他工具</target>
        </trans-unit>
        <trans-unit id="89cbbb5c1b80969d7050a561dcd36c87c0241792" translate="yes" xml:space="preserve">
          <source>Other tools to fight regressions</source>
          <target state="translated">其他对抗倒退的工具</target>
        </trans-unit>
        <trans-unit id="15219db000aadb43433107a930098d54a12a2bf5" translate="yes" xml:space="preserve">
          <source>Other types of dangling objects (blobs and trees) are also possible, and dangling objects can arise in other situations.</source>
          <target state="translated">其他类型的悬空物体(blobs和树)也是可能的,悬空物体也会在其他情况下出现。</target>
        </trans-unit>
        <trans-unit id="a8ad1c87f168347a129392343ff35eecf4e32d0a" translate="yes" xml:space="preserve">
          <source>Other variables</source>
          <target state="translated">其他变量</target>
        </trans-unit>
        <trans-unit id="dd705eff4c453915d022538452adca45ea549424" translate="yes" xml:space="preserve">
          <source>Other ways</source>
          <target state="translated">其他方式</target>
        </trans-unit>
        <trans-unit id="cf96d288cbee7ebb53d0ff80a9f63e5beaf8b0b4" translate="yes" xml:space="preserve">
          <source>Otherwise the remote branch of the first refspec is merged.</source>
          <target state="translated">否则将合并第一个refspec的远程分支。</target>
        </trans-unit>
        <trans-unit id="32a9647b920b895ad400011726c72473bb775600" translate="yes" xml:space="preserve">
          <source>Otherwise, a tag reference that points directly at the given object (i.e., a lightweight tag) is created.</source>
          <target state="translated">否则,将创建一个直接指向给定对象的标签引用(即轻量级标签)。</target>
        </trans-unit>
        <trans-unit id="4b4eb603a71c26301f006805965a2bb224fe1a8d" translate="yes" xml:space="preserve">
          <source>Otherwise, all you need to do is start &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt;; it will listen on port 9418. By default, it will allow access to any directory that looks like a Git directory and contains the magic file git-daemon-export-ok. Passing some directory paths as &lt;code&gt;git daemon&lt;/code&gt; arguments will further restrict the exports to those paths.</source>
          <target state="translated">否则，您只需要启动&lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]即可&lt;/a&gt;；它将侦听端口9418。默认情况下，它将允许访问任何看起来像Git目录且包含魔术文件git-daemon-export-ok的目录。将某些目录路径作为 &lt;code&gt;git daemon&lt;/code&gt; 参数传递将进一步限制导出到这些路径。</target>
        </trans-unit>
        <trans-unit id="83933e66c19657c277855328b7212d55be330b69" translate="yes" xml:space="preserve">
          <source>Otherwise, if the &lt;code&gt;SSH_ASKPASS&lt;/code&gt; environment variable is set, its value is used as above.</source>
          <target state="translated">否则，如果设置了 &lt;code&gt;SSH_ASKPASS&lt;/code&gt; 环境变量，则其值将如上使用。</target>
        </trans-unit>
        <trans-unit id="06aca3f538987dd4baec5bd30c2c8ddce8b7736e" translate="yes" xml:space="preserve">
          <source>Otherwise, if the &lt;code&gt;core.askPass&lt;/code&gt; configuration variable is set, its value is used as above.</source>
          <target state="translated">否则，如果设置了 &lt;code&gt;core.askPass&lt;/code&gt; 配置变量，则其值将如上使用。</target>
        </trans-unit>
        <trans-unit id="3a26962584221262caf565e9653ff026d1f2d21a" translate="yes" xml:space="preserve">
          <source>Otherwise, if the helper string begins with an absolute path, the verbatim helper string becomes the command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4215362e197715214628992e14b639b7a98dbd7a" translate="yes" xml:space="preserve">
          <source>Otherwise, show the index format.</source>
          <target state="translated">否则,显示索引格式。</target>
        </trans-unit>
        <trans-unit id="1bddd3a0b4a752779f115c3518d3c2b277475b51" translate="yes" xml:space="preserve">
          <source>Otherwise, success is indicated the Unix way, i.e. by simply exiting with a zero exit status.</source>
          <target state="translated">否则,就会以Unix方式表示成功,即以零退出状态退出。</target>
        </trans-unit>
        <trans-unit id="adf9fb3bc458cf17571d90a6a9fffeaa1b715a6a" translate="yes" xml:space="preserve">
          <source>Otherwise, the merge proceeds in the usual way.</source>
          <target state="translated">否则,合并按常规方式进行。</target>
        </trans-unit>
        <trans-unit id="682c927c4310cf70e63b7011c8ec332cb5444742" translate="yes" xml:space="preserve">
          <source>Otherwise, the string &quot;git credential-&quot; is prepended to the helper string, and the result becomes the command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d438a86f2545e54eff98d96612fdf5bccb833ed" translate="yes" xml:space="preserve">
          <source>Otherwise, the topic that was merged to suddenly contains more than a single (well-separated) change. The many resulting small merges will greatly clutter up history. Anyone who later investigates the history of a file will have to find out whether that merge affected the topic in development. An upstream might even inadvertently be merged into a &quot;more stable&quot; branch. And so on.</source>
          <target state="translated">否则,被合并到的主题突然包含了不止一个(分得很清楚)的变化。由此产生的许多小的合并将极大地混乱历史。任何后来调查一个文件历史的人,都必须找出那个合并是否影响了正在开发中的主题。一个上游甚至可能无意中被合并到一个 &quot;更稳定 &quot;的分支中。以此类推。</target>
        </trans-unit>
        <trans-unit id="9aea25a9a0905a830a51359c1723b329df787dff" translate="yes" xml:space="preserve">
          <source>Otherwise, the user is prompted on the terminal.</source>
          <target state="translated">否则,终端上会提示用户。</target>
        </trans-unit>
        <trans-unit id="38c6fc8779b3b84c1e5bc6184edd3674dd536e89" translate="yes" xml:space="preserve">
          <source>Otherwise, this command applies the arguments passed using the &lt;code&gt;--trailer&lt;/code&gt; option, if any, to the commit message part of each input file. The result is emitted on the standard output.</source>
          <target state="translated">否则，此命令 &lt;code&gt;--trailer&lt;/code&gt; 使用--trailer选项传递的参数（如果有）应用于每个输入文件的提交消息部分。结果在标准输出上发出。</target>
        </trans-unit>
        <trans-unit id="7befa93bf7555efa6c53836dd2ebb58604474c19" translate="yes" xml:space="preserve">
          <source>Otherwise, you need more information. How do you tell which version of the file has been lost?</source>
          <target state="translated">否则,你需要更多的信息。如何判断文件的哪个版本已经丢失?</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="bfba9983f4010a4e13ddf1f4da6c4d9462a74630" translate="yes" xml:space="preserve">
          <source>Output &quot;connectivity-ok&quot; if the received pack is self-contained and connected.</source>
          <target state="translated">如果接收到的数据包是自给自足并连接的,则输出 &quot;connectivity-ok&quot;。</target>
        </trans-unit>
        <trans-unit id="14d787baf83270b720015688dc1b0d825f139765" translate="yes" xml:space="preserve">
          <source>Output \0 instead of the character that normally follows a file name.</source>
          <target state="translated">输出/0代替通常文件名后的字符。</target>
        </trans-unit>
        <trans-unit id="02b83bf95635a4c88bd0634054e0b05541ae55d4" translate="yes" xml:space="preserve">
          <source>Output a condensed summary of extended header information such as creations, renames and mode changes.</source>
          <target state="translated">输出扩展头信息的精简摘要,如创建、重命名和模式变化。</target>
        </trans-unit>
        <trans-unit id="6dbea2796f7c2da05dc872fbc20cb3b286f106fd" translate="yes" xml:space="preserve">
          <source>Output a condensed summary of extended header information such as file creations or deletions (&quot;new&quot; or &quot;gone&quot;, optionally &quot;+l&quot; if it&amp;rsquo;s a symlink) and mode changes (&quot;+x&quot; or &quot;-x&quot; for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies &lt;code&gt;--stat&lt;/code&gt;.</source>
          <target state="translated">输出扩展头信息的简明摘要，例如文件创建或删除（&amp;ldquo;新&amp;rdquo;或&amp;ldquo;去&amp;rdquo;，如果是符号链接，则可选地为&amp;ldquo; + l&amp;rdquo;）和模式更改（&amp;ldquo; + x&amp;rdquo;或&amp;ldquo; -x&amp;rdquo;用于添加或删除）分别在diffstat中执行）。信息放在文件名部分和图形部分之间。暗示 &lt;code&gt;--stat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86b8e4f6e5044ecf1fc221aacfd89b826aa45a4b" translate="yes" xml:space="preserve">
          <source>Output all merge bases for the commits, instead of just one.</source>
          <target state="translated">输出所有提交的合并基础,而不是只输出一个。</target>
        </trans-unit>
        <trans-unit id="c4fd496863f1ea4adcfb9e1e5209189d8bcbae5b" translate="yes" xml:space="preserve">
          <source>Output an all-zero hash in each patch&amp;rsquo;s From header instead of the hash of the commit.</source>
          <target state="translated">在每个补丁的From头中输出全零哈希值，而不是提交的哈希值。</target>
        </trans-unit>
        <trans-unit id="646a42919af7ad3c76023f798af12df793449561" translate="yes" xml:space="preserve">
          <source>Output diff in reverse.</source>
          <target state="translated">输出差反。</target>
        </trans-unit>
        <trans-unit id="973b33dc2cc053fd8a3739d3b278f90232b34e64" translate="yes" xml:space="preserve">
          <source>Output excluded boundary commits. Boundary commits are prefixed with &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">输出排除的边界提交。边界提交的前缀为 &lt;code&gt;-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3872ebaf63738dccf26222059fb06a34ea9a53d" translate="yes" xml:space="preserve">
          <source>Output file names will be a simple number sequence without the default first line of the commit appended.</source>
          <target state="translated">输出文件名将是一个简单的数字序列,不附加默认的第一行提交。</target>
        </trans-unit>
        <trans-unit id="c03f08a8f205e4568e916e3cfaa50c6a48749706" translate="yes" xml:space="preserve">
          <source>Output format</source>
          <target state="translated">输出格式</target>
        </trans-unit>
        <trans-unit id="d018168db6adc860beb206930bf9272bcf4432cb" translate="yes" xml:space="preserve">
          <source>Output from &lt;code&gt;git describe&lt;/code&gt;; i.e. a closest tag, optionally followed by a dash and a number of commits, followed by a dash, a &lt;code&gt;g&lt;/code&gt;, and an abbreviated object name.</source>
          <target state="translated">&lt;code&gt;git describe&lt;/code&gt; 的输出；即最接近的标记，可以选择后面跟一个破折号和多个提交，然后跟一个破折号， &lt;code&gt;g&lt;/code&gt; 和一个缩写的对象名。</target>
        </trans-unit>
        <trans-unit id="57be6fd315ed7958a6a11b416634cb9af54c1202" translate="yes" xml:space="preserve">
          <source>Output information on each ref</source>
          <target state="translated">输出每个裁判的信息</target>
        </trans-unit>
        <trans-unit id="a471d58e2fcbf4f373e5dd800df97d7ecddc4b2a" translate="yes" xml:space="preserve">
          <source>Output only the last line of the &lt;code&gt;--stat&lt;/code&gt; format containing total number of modified files, as well as number of added and deleted lines.</source>
          <target state="translated">仅输出 &lt;code&gt;--stat&lt;/code&gt; 格式的最后一行，其中包含已修改文件的总数以及添加和删除的行数。</target>
        </trans-unit>
        <trans-unit id="09afa8b7712ce7db5d67e850045b13df59d4e1ae" translate="yes" xml:space="preserve">
          <source>Output only the names of config variables for &lt;code&gt;--list&lt;/code&gt; or &lt;code&gt;--get-regexp&lt;/code&gt;.</source>
          <target state="translated">仅输出 &lt;code&gt;--list&lt;/code&gt; 或 &lt;code&gt;--get-regexp&lt;/code&gt; 的配置变量的名称。</target>
        </trans-unit>
        <trans-unit id="86aa1f4dbf3c69df52c4dcdcb3513ddaac888349" translate="yes" xml:space="preserve">
          <source>Output only the trailers, not any other parts of the input.</source>
          <target state="translated">只输出拖车,不输出输入的任何其他部分。</target>
        </trans-unit>
        <trans-unit id="db37f07e7f23e51cc792b3b6ff625f7fbb6a099c" translate="yes" xml:space="preserve">
          <source>Output only trailers that exist in the input; do not add any from the command-line or by following configured &lt;code&gt;trailer.*&lt;/code&gt; rules.</source>
          <target state="translated">仅输出输入中存在的预告片；请勿从命令行或遵循已配置的 &lt;code&gt;trailer.*&lt;/code&gt; 规则添加任何内容。</target>
        </trans-unit>
        <trans-unit id="9f94a54620a30e7ce03e12a657369e604dddd0ea" translate="yes" xml:space="preserve">
          <source>Output stability</source>
          <target state="translated">输出稳定性</target>
        </trans-unit>
        <trans-unit id="eec068e91917644b4f85137aa6730536687188c8" translate="yes" xml:space="preserve">
          <source>Output the commits chosen to be shown (see Commit Limiting section above) in reverse order. Cannot be combined with &lt;code&gt;--walk-reflogs&lt;/code&gt;.</source>
          <target state="translated">以相反的顺序输出选择显示的提交（请参见上面的&amp;ldquo;提交限制&amp;rdquo;部分）。不能与 &lt;code&gt;--walk-reflogs&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="b5f16fa854dad4b03b2649c62b3407ce506ca41f" translate="yes" xml:space="preserve">
          <source>Output the distribution of relative amount of changes for each sub-directory. The behavior of &lt;code&gt;--dirstat&lt;/code&gt; can be customized by passing it a comma separated list of parameters. The defaults are controlled by the &lt;code&gt;diff.dirstat&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). The following parameters are available:</source>
          <target state="translated">输出每个子目录的相对变化量的分布。可以通过将 &lt;code&gt;--dirstat&lt;/code&gt; 的行为传递给逗号分隔的参数列表来进行自定义。默认值由 &lt;code&gt;diff.dirstat&lt;/code&gt; 配置变量控制（请参阅&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;）。可以使用以下参数：</target>
        </trans-unit>
        <trans-unit id="f44ba9d91e7de35dadf965ce7b9f83b740777703" translate="yes" xml:space="preserve">
          <source>Output to a specific file instead of stdout.</source>
          <target state="translated">输出到一个特定的文件,而不是stdout。</target>
        </trans-unit>
        <trans-unit id="1374322e99ee5a882a272ee284ec9ea86e209683" translate="yes" xml:space="preserve">
          <source>Output uses the same format as &lt;code&gt;git cat-file --batch&lt;/code&gt;:</source>
          <target state="translated">输出使用与 &lt;code&gt;git cat-file --batch&lt;/code&gt; 相同的格式：</target>
        </trans-unit>
        <trans-unit id="50880c18d623e2367f83a87791b3da910b72fa81" translate="yes" xml:space="preserve">
          <source>Output uses the same format as &lt;code&gt;git ls-tree &amp;lt;tree&amp;gt; -- &amp;lt;path&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">输出使用与 &lt;code&gt;git ls-tree &amp;lt;tree&amp;gt; -- &amp;lt;path&amp;gt;&lt;/code&gt; 相同的格式：</target>
        </trans-unit>
        <trans-unit id="12aec147318e848c7d54969418eb1ab7603e65c0" translate="yes" xml:space="preserve">
          <source>Outputs some statistics to stderr. Has a small performance penalty.</source>
          <target state="translated">向stderr输出一些统计数据。有一个小的性能惩罚。</target>
        </trans-unit>
        <trans-unit id="bb044abda9deb6fdc3e0634ed0f85ce258bcc5dc" translate="yes" xml:space="preserve">
          <source>Outputs the SHA1 of every commit in &lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt;, prefixed with &lt;code&gt;-&lt;/code&gt; for commits that have an equivalent in &amp;lt;upstream&amp;gt;, and &lt;code&gt;+&lt;/code&gt; for commits that do not.</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt; 中输出每个提交的SHA1 ，以 &lt;code&gt;-&lt;/code&gt; 表示在&amp;lt;upstream&amp;gt;中具有等效值的提交，以 &lt;code&gt;+&lt;/code&gt; 表示在不具有它们的提交时的前缀。</target>
        </trans-unit>
        <trans-unit id="27115802f1c296a1dfb4ce768084e3e086e70c8c" translate="yes" xml:space="preserve">
          <source>Override &lt;code&gt;tag.gpgSign&lt;/code&gt; configuration variable that is set to force each and every tag to be signed.</source>
          <target state="translated">覆盖 &lt;code&gt;tag.gpgSign&lt;/code&gt; 配置变量，该变量设置为强制对每个标签进行签名。</target>
        </trans-unit>
        <trans-unit id="f98c38feba04de33a87daf02cddb4bc0af45f925" translate="yes" xml:space="preserve">
          <source>Override earlier --rebase.</source>
          <target state="translated">覆盖早先的--rebase。</target>
        </trans-unit>
        <trans-unit id="bf7cdfd38925dba890e8c6c44d76b710ca912a26" translate="yes" xml:space="preserve">
          <source>Override the HTTP proxy, normally configured using the &lt;code&gt;http_proxy&lt;/code&gt;, &lt;code&gt;https_proxy&lt;/code&gt;, and &lt;code&gt;all_proxy&lt;/code&gt; environment variables (see &lt;code&gt;curl(1)&lt;/code&gt;). In addition to the syntax understood by curl, it is possible to specify a proxy string with a user name but no password, in which case git will attempt to acquire one in the same way it does for other credentials. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information. The syntax thus is &lt;code&gt;[protocol://][user[:password]@]proxyhost[:port]&lt;/code&gt;. This can be overridden on a per-remote basis; see remote.&amp;lt;name&amp;gt;.proxy</source>
          <target state="translated">覆盖通常使用 &lt;code&gt;http_proxy&lt;/code&gt; ， &lt;code&gt;https_proxy&lt;/code&gt; 和 &lt;code&gt;all_proxy&lt;/code&gt; 环境变量配置的HTTP代理（请参见 &lt;code&gt;curl(1)&lt;/code&gt; ）。除了curl可以理解的语法外，还可以使用用户名而不是密码来指定代理字符串，在这种情况下git将尝试以与其他凭据相同的方式获取一个。有关更多信息，请参见&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt;。因此，语法为 &lt;code&gt;[protocol://][user[:password]@]proxyhost[:port]&lt;/code&gt; 。可以逐个远程覆盖它；参见remote。&amp;lt;名称&amp;gt; .proxy</target>
        </trans-unit>
        <trans-unit id="ca2a7d0ade908f47d0a242141742817435033d82" translate="yes" xml:space="preserve">
          <source>Override the author date used in the commit.</source>
          <target state="translated">覆盖提交中使用的作者日期。</target>
        </trans-unit>
        <trans-unit id="afbb46ef37a88110fa3c814b4440b9bab3c588ca" translate="yes" xml:space="preserve">
          <source>Override the commit author. Specify an explicit author using the standard &lt;code&gt;A U Thor &amp;lt;author@example.com&amp;gt;&lt;/code&gt; format. Otherwise &amp;lt;author&amp;gt; is assumed to be a pattern and is used to search for an existing commit by that author (i.e. rev-list --all -i --author=&amp;lt;author&amp;gt;); the commit author is then copied from the first such commit found.</source>
          <target state="translated">覆盖提交作者。使用标准 &lt;code&gt;A U Thor &amp;lt;author@example.com&amp;gt;&lt;/code&gt; 格式指定明确的作者。否则，假定&amp;lt;author&amp;gt;是一种模式，并用于搜索该作者的现有提交（即rev-list --all -i --author = &amp;lt;author&amp;gt;）；然后从找到的第一个此类提交中复制提交作者。</target>
        </trans-unit>
        <trans-unit id="e3aa6564c96bc2c1fa2d64bc52314ce125c2e1b2" translate="yes" xml:space="preserve">
          <source>Override the default help format used by &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;. Values &lt;code&gt;man&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;html&lt;/code&gt; are supported. &lt;code&gt;man&lt;/code&gt; is the default. &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;html&lt;/code&gt; are the same.</source>
          <target state="translated">覆盖&lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt;使用的默认帮助格式。支持值 &lt;code&gt;man&lt;/code&gt; ， &lt;code&gt;info&lt;/code&gt; ， &lt;code&gt;web&lt;/code&gt; 和 &lt;code&gt;html&lt;/code&gt; 。 &lt;code&gt;man&lt;/code&gt; 是默认设置。 &lt;code&gt;web&lt;/code&gt; 和 &lt;code&gt;html&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="90af133b98db5fc195076e23392ec3cd67c3e89c" translate="yes" xml:space="preserve">
          <source>Override the default tempdir.</source>
          <target state="translated">覆盖默认的tempdir。</target>
        </trans-unit>
        <trans-unit id="5b51681506c224a8c47f1343a9ecd64433151e38" translate="yes" xml:space="preserve">
          <source>Override the executable bit of the added files. The executable bit is only changed in the index, the files on disk are left unchanged.</source>
          <target state="translated">覆盖新增文件的可执行位。可执行位只在索引中改变,磁盘上的文件保持不变。</target>
        </trans-unit>
        <trans-unit id="2478241e90c06d40d8344e2c734cc9e34ffd0d73" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool that may be used to browse HTML help (see &lt;code&gt;-w&lt;/code&gt; option in &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;) or a working repository in gitweb (see &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;).</source>
          <target state="translated">覆盖给定工具的路径，该工具可用于浏览HTML帮助（请参阅&lt;a href=&quot;git-help&quot;&gt;git-help [1]中的&lt;/a&gt; &lt;code&gt;-w&lt;/code&gt; 选项）或gitweb中的可用存储库（请参阅&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="eeb1b59c781a411c8a2ade9041a0a224d6888a83" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool that may be used to display help in the &lt;code&gt;man&lt;/code&gt; format. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;.</source>
          <target state="translated">覆盖给定工具的路径，该路径可用于以 &lt;code&gt;man&lt;/code&gt; 格式显示帮助。参见&lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="adf75a51b2ad5d1ae80303fa7c85676af23cae71" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool. This is useful in case your tool is not in the PATH.</source>
          <target state="translated">覆盖给定工具的路径。这在你的工具不在PATH中时很有用。</target>
        </trans-unit>
        <trans-unit id="d7b3947bcc6a75423b4dad1a16da833c821be77f" translate="yes" xml:space="preserve">
          <source>Override the up-to-date check.</source>
          <target state="translated">覆盖最新的检查。</target>
        </trans-unit>
        <trans-unit id="4f22a960f4dfa712696d5fbbb0afb1a8a1360ea3" translate="yes" xml:space="preserve">
          <source>Overrides a previous &lt;code&gt;--no-walk&lt;/code&gt;.</source>
          <target state="translated">覆盖先前的 &lt;code&gt;--no-walk&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcd0bd07179d4dab7adf6735a6d8e2d1ef6bb9e3" translate="yes" xml:space="preserve">
          <source>Overwrite the contents of the files that match the pathspec. When the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (most often a commit) is not given, overwrite working tree with the contents in the index. When the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; is given, overwrite both the index and the working tree with the contents at the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">覆盖与pathspec匹配的文件的内容。如果未给出 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; （通常是一次提交），请使用索引中的内容覆盖工作树。当 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 给出，覆盖这两个索引和与内容在工作树 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdd66a641be22e4e3d7b30653f72f1e5443e834b" translate="yes" xml:space="preserve">
          <source>P4 does not have the same concept of a branch as Git. Instead, p4 organizes its content as a directory tree, where by convention different logical branches are in different locations in the tree. The &lt;code&gt;p4 branch&lt;/code&gt; command is used to maintain mappings between different areas in the tree, and indicate related content. &lt;code&gt;git p4&lt;/code&gt; can use these mappings to determine branch relationships.</source>
          <target state="translated">P4的分支概念与Git不同。相反，p4将其内容组织为目录树，按照惯例，目录树中的不同逻辑分支位于其中。在 &lt;code&gt;p4 branch&lt;/code&gt; 命令是用来维护不同领域之间的映射在树上，并注明相关内容。 &lt;code&gt;git p4&lt;/code&gt; 可以使用这些映射来确定分支关系。</target>
        </trans-unit>
        <trans-unit id="c377e9687b993a1d0b2786f798f75e99668d5825" translate="yes" xml:space="preserve">
          <source>P4 repositories can be added to an existing Git repository using &lt;code&gt;git p4 sync&lt;/code&gt; too:</source>
          <target state="translated">也可以使用 &lt;code&gt;git p4 sync&lt;/code&gt; 将P4存储库添加到现有的Git存储库中：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
