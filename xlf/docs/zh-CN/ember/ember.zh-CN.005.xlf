<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="ember">
    <body>
      <group id="ember">
        <trans-unit id="dd53739e37c74c8b6af3c2762424c20a33a7a208" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;format-currency&lt;/code&gt; helper that takes an integer count of cents and turns it into formatted dollars.</source>
          <target state="translated">让我们创建一个 &lt;code&gt;format-currency&lt;/code&gt; 助手，它使用一个整数美分并将其转换为格式化的美元。</target>
        </trans-unit>
        <trans-unit id="4b2703dcd1f2ced6d41299af63d335c82cc175ac" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;people-list&lt;/code&gt; component that we can use in multiple places to show a list of people.</source>
          <target state="translated">让我们创建一个 &lt;code&gt;people-list&lt;/code&gt; 组件，该组件可以在多个地方使用以显示人员列表。</target>
        </trans-unit>
        <trans-unit id="50681b0bf964a4527a84e6e7e538f4ce2d598997" translate="yes" xml:space="preserve">
          <source>Let's create the &lt;code&gt;toggleImageSize&lt;/code&gt; function and toggle the &lt;code&gt;isWide&lt;/code&gt; property on our component:</source>
          <target state="translated">让我们创建 &lt;code&gt;toggleImageSize&lt;/code&gt; 函数并在组件上切换 &lt;code&gt;isWide&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="7b5c19d97e452ebeedb9123f50a533fb95f01188" translate="yes" xml:space="preserve">
          <source>Let's customize the &lt;code&gt;shopping-cart&lt;/code&gt; initializer to inject a &lt;code&gt;cart&lt;/code&gt; property into all the routes in your application:</source>
          <target state="translated">让我们自定义 &lt;code&gt;shopping-cart&lt;/code&gt; 初始化程序，以将 &lt;code&gt;cart&lt;/code&gt; 属性注入应用程序中的所有路由：</target>
        </trans-unit>
        <trans-unit id="e4575ed0bbc0fbaa9b5b0685f53318a958fa4b64" translate="yes" xml:space="preserve">
          <source>Let's define the structure of a rental object using the same attributes for our rental that we &lt;a href=&quot;../model-hook&quot;&gt;previously used&lt;/a&gt; in our hard-coded array of JavaScript objects - &lt;em&gt;title&lt;/em&gt;, &lt;em&gt;owner&lt;/em&gt;, &lt;em&gt;city&lt;/em&gt;, &lt;em&gt;property type&lt;/em&gt;, &lt;em&gt;image&lt;/em&gt;, &lt;em&gt;bedrooms&lt;/em&gt; and &lt;em&gt;description&lt;/em&gt;. Define attributes by giving them the result of the function &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.html#method_attr&quot;&gt;&lt;code&gt;DS.attr()&lt;/code&gt;&lt;/a&gt;. For more information on Ember Data Attributes, read the section called &lt;a href=&quot;https://guides.emberjs.com/models/defining-models/#toc_defining-attributes&quot;&gt;Defining Attributes&lt;/a&gt; in the guides.</source>
          <target state="translated">让我们使用与我们&lt;a href=&quot;../model-hook&quot;&gt;以前&lt;/a&gt;在JavaScript对象的硬编码数组中使用的出租属性相同的属性来定义出租对象的结构&lt;em&gt;-title&lt;/em&gt;，&lt;em&gt;owner&lt;/em&gt;，&lt;em&gt;city&lt;/em&gt;，&lt;em&gt;property type&lt;/em&gt;，&lt;em&gt;image&lt;/em&gt;，&lt;em&gt;bedrooms&lt;/em&gt;和&lt;em&gt;description&lt;/em&gt;。通过为它们提供函数&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.html#method_attr&quot;&gt; &lt;code&gt;DS.attr()&lt;/code&gt; &lt;/a&gt;的结果来定义属性。有关Ember数据属性的更多信息，请阅读指南中的&amp;ldquo; &lt;a href=&quot;https://guides.emberjs.com/models/defining-models/#toc_defining-attributes&quot;&gt;定义属性&lt;/a&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="42b2774cf0be3cfdf91e6720844b3fc03268684b" translate="yes" xml:space="preserve">
          <source>Let's explore these concepts using an example of a route displaying a blog post. Presume a &lt;code&gt;BlogPost&lt;/code&gt; model that is presented in a &lt;code&gt;blog-post&lt;/code&gt; template.</source>
          <target state="translated">让我们使用显示博客文章的路线示例来探讨这些概念。假定在 &lt;code&gt;blog-post&lt;/code&gt; 模板中显示的 &lt;code&gt;BlogPost&lt;/code&gt; 模型。</target>
        </trans-unit>
        <trans-unit id="26db41f1383be1d219153569142445a93005ef0d" translate="yes" xml:space="preserve">
          <source>Let's generate a &lt;code&gt;rental-listing&lt;/code&gt; component that will manage the behavior for each of our rentals. A dash is required in every component name to avoid conflicting with a possible HTML element, so &lt;code&gt;rental-listing&lt;/code&gt; is acceptable but &lt;code&gt;rental&lt;/code&gt; isn't.</source>
          <target state="translated">让我们生成一个 &lt;code&gt;rental-listing&lt;/code&gt; 组件，该组件将管理我们每个出租的行为。每个组件名称中都必须使用破折号，以避免与可能的HTML元素冲突，因此可以接受 &lt;code&gt;rental&lt;/code&gt; &lt;code&gt;rental-listing&lt;/code&gt; ，但不允许租赁。</target>
        </trans-unit>
        <trans-unit id="1e94e8c5fcbcdfe2fafa8482c52537ded890590a" translate="yes" xml:space="preserve">
          <source>Let's get started creating our service by generating it through Ember CLI, which will create the service file, as well as a unit test for it.</source>
          <target state="translated">让我们开始创建我们的服务,通过Ember CLI生成它,它将创建服务文件,以及它的单元测试。</target>
        </trans-unit>
        <trans-unit id="59c42fa1c4186808938dbdaa530634247e143009" translate="yes" xml:space="preserve">
          <source>Let's implement &lt;code&gt;double-clickable&lt;/code&gt; such that when it is clicked, an alert is displayed:</source>
          <target state="translated">让我们实现 &lt;code&gt;double-clickable&lt;/code&gt; ，以便在单击该控件时显示警报：</target>
        </trans-unit>
        <trans-unit id="80eba8bfca1ed78a5a3f72b4b1cdba111f9f76a2" translate="yes" xml:space="preserve">
          <source>Let's initialize our date picker by overriding the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement&quot;&gt;&lt;code&gt;didInsertElement()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">让我们通过重写&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement&quot;&gt; &lt;code&gt;didInsertElement()&lt;/code&gt; &lt;/a&gt;方法来初始化日期选择器。</target>
        </trans-unit>
        <trans-unit id="dfd8f43342f0e8e597ce5606445945b700d097d0" translate="yes" xml:space="preserve">
          <source>Let's look at a similar example that is optimized in Ember, starting with a &lt;code&gt;User&lt;/code&gt; object:</source>
          <target state="translated">让我们看一个从 &lt;code&gt;User&lt;/code&gt; 对象开始的在Ember中优化的类似示例：</target>
        </trans-unit>
        <trans-unit id="5fffb3b327aecf1a41680d27190812818f0ca4fd" translate="yes" xml:space="preserve">
          <source>Let's look at a simple example of how a component can use an action to communicate with its parent.</source>
          <target state="translated">让我们来看一个简单的例子,说明一个组件如何使用一个动作与它的父节点进行通信。</target>
        </trans-unit>
        <trans-unit id="f75a786fdb113fbc8a0687ed269e046e9fa4fe3b" translate="yes" xml:space="preserve">
          <source>Let's look at the parent component's JavaScript file. In this example, imagine we have a parent component called &lt;code&gt;user-profile&lt;/code&gt; that shows the user's profile to them.</source>
          <target state="translated">让我们看一下父组件的JavaScript文件。在此示例中，假设我们有一个名为 &lt;code&gt;user-profile&lt;/code&gt; 的父组件，该组件向他们显示用户的个人资料。</target>
        </trans-unit>
        <trans-unit id="1b66cbb003165185944800edb660d32eca31d034" translate="yes" xml:space="preserve">
          <source>Let's look at what happens if you request a record that the store already has in its cache.</source>
          <target state="translated">让我们看看如果你请求一个存储在缓存中已经有的记录会发生什么。</target>
        </trans-unit>
        <trans-unit id="590b9c6d802434b51a5191db38e2d406a9e971ad" translate="yes" xml:space="preserve">
          <source>Let's make sure everything is working properly. &lt;code&gt;cd&lt;/code&gt; into the application directory &lt;code&gt;ember-quickstart&lt;/code&gt; and start the development server by typing:</source>
          <target state="translated">让我们确保一切正常。 &lt;code&gt;cd&lt;/code&gt; 进入应用程序目录 &lt;code&gt;ember-quickstart&lt;/code&gt; 并通过键入以下内容启动开发服务器：</target>
        </trans-unit>
        <trans-unit id="aab21dd37a2f939f20050faef347b0ec430a0362" translate="yes" xml:space="preserve">
          <source>Let's now implement the helper. Helpers are functions that take one or more inputs and return a single output that should be put into the HTML.</source>
          <target state="translated">现在我们来实现助记器。助手是指接受一个或多个输入,并返回一个应放入HTML中的单一输出的函数。</target>
        </trans-unit>
        <trans-unit id="f6b204ac311c4ee4a0d190f78f5606bfd6113ee7" translate="yes" xml:space="preserve">
          <source>Let's open &lt;code&gt;app/routes/rentals.js&lt;/code&gt; and return an array of rental objects from the &lt;code&gt;model&lt;/code&gt; function:</source>
          <target state="translated">让我们打开 &lt;code&gt;app/routes/rentals.js&lt;/code&gt; 并从 &lt;code&gt;model&lt;/code&gt; 函数返回租赁对象的数组：</target>
        </trans-unit>
        <trans-unit id="d86ec598cd6b2af3f7fafff3f4e673d6c0cecb5b" translate="yes" xml:space="preserve">
          <source>Let's say we wanted to add a feature that would allow the user to toggle the display of the body section. To implement this, we would first modify our template to show the body only if the value of a new &lt;code&gt;isExpanded&lt;/code&gt; property is true.</source>
          <target state="translated">假设我们要添加一个功能，该功能将允许用户切换主体部分的显示。为了实现这一点，我们将首先修改模板以仅在新的 &lt;code&gt;isExpanded&lt;/code&gt; 属性的值为true时显示主体。</target>
        </trans-unit>
        <trans-unit id="18b2e4d7e3967cf6832dddd4b5cc115648948c9c" translate="yes" xml:space="preserve">
          <source>Let's see these core concepts in action by building a property rental application in the next lesson.</source>
          <target state="translated">下一节课我们就来看看这些核心概念的实际应用,建立一个房产租赁应用。</target>
        </trans-unit>
        <trans-unit id="f9bb85bb04d6e37a3d55dd2f9946f3e2bc2fae4c" translate="yes" xml:space="preserve">
          <source>Let's start by adding a &lt;code&gt;div&lt;/code&gt; element to the component template. This &lt;code&gt;div&lt;/code&gt; will act as a place for the 3rd party map API to render the map to.</source>
          <target state="translated">让我们从将 &lt;code&gt;div&lt;/code&gt; 元素添加到组件模板开始。此 &lt;code&gt;div&lt;/code&gt; 将充当第三方地图API渲染地图的地方。</target>
        </trans-unit>
        <trans-unit id="56d73e58f7a22994e9e7d10b8e3ff51f512b440e" translate="yes" xml:space="preserve">
          <source>Let's start by building our &quot;about&quot; page.</source>
          <target state="translated">让我们从建立我们的 &quot;关于 &quot;页面开始。</target>
        </trans-unit>
        <trans-unit id="0fb162b35ef315066c948b1304b9311aee16c4db" translate="yes" xml:space="preserve">
          <source>Let's start by creating an object that has a &lt;code&gt;computedFoo&lt;/code&gt; computed property based on a &lt;code&gt;foo&lt;/code&gt; property.</source>
          <target state="translated">让我们开始创建一个对象，该对象具有一个基于 &lt;code&gt;foo&lt;/code&gt; 属性的 &lt;code&gt;computedFoo&lt;/code&gt; 计算属性。</target>
        </trans-unit>
        <trans-unit id="ff7832d81c62993788fb20c37421c44bad0995e9" translate="yes" xml:space="preserve">
          <source>Let's start by looking at the changes to our Router (&lt;code&gt;app/router.js&lt;/code&gt;).</source>
          <target state="translated">让我们开始查看对路由器（ &lt;code&gt;app/router.js&lt;/code&gt; ）的更改。</target>
        </trans-unit>
        <trans-unit id="c2aa48423894ccede7d5d25c64e916771df1a170" translate="yes" xml:space="preserve">
          <source>Let's start by testing the helper by showing a simple unit test and then move on to testing with integration tests afterwards.</source>
          <target state="translated">我们先通过展示一个简单的单元测试来测试助手,之后再继续用集成测试来测试。</target>
        </trans-unit>
        <trans-unit id="565635cdbaba1baa8ed4a8401c8fea01e1ad7667" translate="yes" xml:space="preserve">
          <source>Let's take a look at the folders and files Ember CLI generates.</source>
          <target state="translated">让我们来看看Ember CLI生成的文件夹和文件。</target>
        </trans-unit>
        <trans-unit id="e1a879debe45fb25e88e56e0a9a4d2687e8b6e70" translate="yes" xml:space="preserve">
          <source>Let's take it step by step.</source>
          <target state="translated">让我们一步步来。</target>
        </trans-unit>
        <trans-unit id="043c80933b2a6a5bd8843f4d18a90fa90152c0fc" translate="yes" xml:space="preserve">
          <source>Let's update our &lt;code&gt;rental-listing&lt;/code&gt; component template to use our new helper and pass in &lt;code&gt;rental.propertyType&lt;/code&gt;:</source>
          <target state="translated">让我们更新 &lt;code&gt;rental-listing&lt;/code&gt; 组件模板以使用我们的新帮助程序并传递 &lt;code&gt;rental.propertyType&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="606a02e2fcda6a8a8667006df471f3c99bd32864" translate="yes" xml:space="preserve">
          <source>Let's update the default test to contain the scenarios we want to verify:</source>
          <target state="translated">让我们更新默认测试,以包含我们想要验证的场景。</target>
        </trans-unit>
        <trans-unit id="670783028da291a6a49d5996e531bc96807e06e5" translate="yes" xml:space="preserve">
          <source>Let's use Ember's route generator to start our &lt;code&gt;about&lt;/code&gt; route.</source>
          <target state="translated">让我们使用Ember的路由生成器启动我们的 &lt;code&gt;about&lt;/code&gt; 路由。</target>
        </trans-unit>
        <trans-unit id="1c89369985b54e2bd39755237a790278e410475d" translate="yes" xml:space="preserve">
          <source>Let's use the &lt;code&gt;{{if}}&lt;/code&gt; helper to show our current rental image larger only when &lt;code&gt;isWide&lt;/code&gt; is set to true, by setting the element class name to &lt;code&gt;wide&lt;/code&gt;. We'll also add some text to indicate that the image can be clicked on, and wrap both with an anchor element, giving it the &lt;code&gt;image&lt;/code&gt; class name so that our test can find it.</source>
          <target state="translated">让我们使用 &lt;code&gt;{{if}}&lt;/code&gt; 辅助工具，通过将元素类名称设置为 &lt;code&gt;wide&lt;/code&gt; ，仅在将 &lt;code&gt;isWide&lt;/code&gt; 设置为true时，将当前的租赁图像放大显示。我们还将添加一些文本来指示可以单击该图像，并用锚元素将二者包装起来，为其赋予 &lt;code&gt;image&lt;/code&gt; 类名称，以便我们的测试可以找到它。</target>
        </trans-unit>
        <trans-unit id="89d849f40b52e102654d51fd7d92dff536022969" translate="yes" xml:space="preserve">
          <source>Let's use the creation of a TinyMCE component as an example. Currently, TinyMCE provides a setup configuration option we can use to do some processing after the TinyMCE instance is initialized but before it is actually rendered. We can use that setup option to do some additional setup for our component. The component itself could look something like the following:</source>
          <target state="translated">我们以创建一个TinyMCE组件为例。目前,TinyMCE提供了一个设置配置选项,我们可以在TinyMCE实例初始化后,但在实际渲染之前进行一些处理。我们可以使用该设置选项为我们的组件做一些额外的设置。组件本身可以像下面的样子。</target>
        </trans-unit>
        <trans-unit id="67eb54f6056cb9b4a29c6a56cd99c5c9161ed991" translate="yes" xml:space="preserve">
          <source>Let's use the pressing of the escape key as an example. If you wanted to invoke a controller action when a user presses the escape key while on your field, you would use the &lt;code&gt;escape-press&lt;/code&gt; attribute on your field like so:</source>
          <target state="translated">让我们以按Escape键为例。如果要在用户在字段上按下转义键时调用控制器动作，则可以在字段上使用 &lt;code&gt;escape-press&lt;/code&gt; 属性，如下所示：</target>
        </trans-unit>
        <trans-unit id="0946f7fd87cca9c49382d10b9e9e28288b447771" translate="yes" xml:space="preserve">
          <source>Let's use this hook to cleanup our date picker and event listener from above:</source>
          <target state="translated">让我们使用这个钩子来清理上面的日期选择器和事件监听器。</target>
        </trans-unit>
        <trans-unit id="20e7c26e92650cd8cc308c911a7985599ad92d4f" translate="yes" xml:space="preserve">
          <source>Let's work through what we want to do on the home page. We want our application to:</source>
          <target state="translated">让我们来看看我们想在主页上做什么。我们希望我们的应用能够:</target>
        </trans-unit>
        <trans-unit id="635a95b002cf836140f8bfffc7a9737eb04db8de" translate="yes" xml:space="preserve">
          <source>Lets add some protective code to ensure our results do not get out of sync with our filter input. To do this we'll simply provide the filter text to the filter function, so that when the results come back we can compare the original filter value with the current filter value. We will update the results on screen only if the original filter value and the current filter value are the same.</source>
          <target state="translated">让我们添加一些保护代码,以确保我们的结果不会与我们的过滤器输入不同步。要做到这一点,我们将简单地提供过滤器文本给过滤器函数,这样当结果回来时,我们就可以比较原始的过滤器值和当前的过滤器值。只有当原始过滤值和当前过滤值相同时,我们才会在屏幕上更新结果。</target>
        </trans-unit>
        <trans-unit id="bc44f6fd03fb10139ad97676e11707e10e54b58c" translate="yes" xml:space="preserve">
          <source>Lets begin by opening the component integration test created when we generated our &lt;code&gt;list-filter&lt;/code&gt; component, &lt;code&gt;tests/integration/components/list-filter-test.js&lt;/code&gt;. Remove the default test, and create a new test that verifies that by default, the component will list all items.</source>
          <target state="translated">让我们首先打开在生成 &lt;code&gt;list-filter&lt;/code&gt; 组件 &lt;code&gt;tests/integration/components/list-filter-test.js&lt;/code&gt; 时创建的组件集成测试。删除默认测试，并创建一个新测试以验证默认情况下组件将列出所有项目。</target>
        </trans-unit>
        <trans-unit id="c885b189d5463a9de5e3e50647d490118201ec4c" translate="yes" xml:space="preserve">
          <source>Libraries on top of Ember can add initializers, like so:</source>
          <target state="translated">在Ember之上的库可以添加初始化器,比如这样。</target>
        </trans-unit>
        <trans-unit id="945316ced7cc6b53c759ff6f262d52bfcb61c767" translate="yes" xml:space="preserve">
          <source>Library Info</source>
          <target state="translated">图书馆信息</target>
        </trans-unit>
        <trans-unit id="c4a417c6c7ec6f5a4f9e827b354dbb85f2e88f9b" translate="yes" xml:space="preserve">
          <source>Library authors can customize how any object will display in the Inspector. By defining a &lt;code&gt;_debugInfo&lt;/code&gt; method, an object can tell the Inspector how it should be rendered. For an example on how to customize an object's properties, see &lt;a href=&quot;https://github.com/emberjs/data/blob/f1be2af71d7402d034bc034d9502733647cad295/packages/ember-data/lib/system/debug/debug_info.js&quot;&gt;Ember Data's customization&lt;/a&gt;.</source>
          <target state="translated">图书馆作者可以自定义任何对象在检查器中的显示方式。通过定义 &lt;code&gt;_debugInfo&lt;/code&gt; 方法，对象可以告诉Inspector应该如何呈现它。有关如何自定义对象属性的示例，请参见&lt;a href=&quot;https://github.com/emberjs/data/blob/f1be2af71d7402d034bc034d9502733647cad295/packages/ember-data/lib/system/debug/debug_info.js&quot;&gt;Ember Data的定制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="8226bf9e9b956346502b16db50675cd108dd1920" translate="yes" xml:space="preserve">
          <source>Life Without Prototype Extension</source>
          <target state="translated">没有原型扩展的生活</target>
        </trans-unit>
        <trans-unit id="57ec013a3d266c6865a25d72a7960cd8d6bed640" translate="yes" xml:space="preserve">
          <source>Lifecycle Hook Examples</source>
          <target state="translated">生命周期挂钩示例</target>
        </trans-unit>
        <trans-unit id="ec7756d2056b7d20b67e5f847928e2cf4a83f1d6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;find&lt;/code&gt;, but throws an error if the element selector returns no results.</source>
          <target state="translated">与 &lt;code&gt;find&lt;/code&gt; 相似，但是如果元素选择器不返回任何结果，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="b0ff675c379589d88041784c63e59222fb0ad141" translate="yes" xml:space="preserve">
          <source>Like any Ember object, a service is initialized and can have properties and methods of its own. Below, the shopping cart service manages an items array that represents the items currently in the shopping cart.</source>
          <target state="translated">像任何Ember对象一样,一个服务是初始化的,可以有自己的属性和方法。下面,购物车服务管理一个物品数组,代表当前购物车中的物品。</target>
        </trans-unit>
        <trans-unit id="f24ff1b32ab054733196fb79b66cf78f2352602e" translate="yes" xml:space="preserve">
          <source>Like any helper, the &lt;code&gt;unbound&lt;/code&gt; helper can accept a nested helper expression. This allows for custom helpers to be rendered unbound:</source>
          <target state="translated">像任何帮助程序一样， &lt;code&gt;unbound&lt;/code&gt; 帮助程序可以接受嵌套的帮助程序表达式。这允许自定义帮助程序变得不受约束：</target>
        </trans-unit>
        <trans-unit id="07aa5990e7980b9aa614cd12afffc38c4f316c64" translate="yes" xml:space="preserve">
          <source>Like normal attributes, actions can be a property on the component; the only difference is that the property is set to a function that knows how to trigger behavior.</source>
          <target state="translated">和普通属性一样,动作也可以是组件上的一个属性,唯一不同的是,该属性被设置为一个知道如何触发行为的函数。</target>
        </trans-unit>
        <trans-unit id="c2cac3e8601ae552602a520670e5074a8519074e" translate="yes" xml:space="preserve">
          <source>Like other helpers, the &lt;code&gt;{{#each}}&lt;/code&gt; helper is bound. If a new item is added to or removed from the iterated array, the DOM will be updated without having to write any additional code. That said, Ember requires that you use &lt;a href=&quot;https://guides.emberjs.com/object-model/enumerables/#toc_use-of-observable-methods-and-properties&quot;&gt;special methods&lt;/a&gt; to update bound arrays. Also be aware that &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#toc_specifying-keys&quot;&gt;using the &lt;code&gt;key&lt;/code&gt; option with an each helper&lt;/a&gt; can improve re-render performance when an array is replaced with another containing similar items.</source>
          <target state="translated">与其他助手一样， &lt;code&gt;{{#each}}&lt;/code&gt; 助手也被绑定。如果将新项目添加到迭代数组中或从迭代数组中删除，则DOM将被更新，而无需编写任何其他代码。也就是说，Ember要求您使用&lt;a href=&quot;https://guides.emberjs.com/object-model/enumerables/#toc_use-of-observable-methods-and-properties&quot;&gt;特殊的方法&lt;/a&gt;来更新绑定数组。还应注意，&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#toc_specifying-keys&quot;&gt;将 &lt;code&gt;key&lt;/code&gt; &lt;/a&gt;一个数组与另一个包含类似项目的数组替换时，将每个助手使用key选项可以提高重新渲染性能。</target>
        </trans-unit>
        <trans-unit id="5368091bb8913e46aa5ac099e90ff00c3876dcb1" translate="yes" xml:space="preserve">
          <source>Like the filtering methods, the &lt;code&gt;every()&lt;/code&gt; and &lt;code&gt;any()&lt;/code&gt; methods have analogous &lt;code&gt;isEvery()&lt;/code&gt; and &lt;code&gt;isAny()&lt;/code&gt; methods.</source>
          <target state="translated">像过滤方法一样， &lt;code&gt;every()&lt;/code&gt; 和 &lt;code&gt;any()&lt;/code&gt; 方法具有类似的 &lt;code&gt;isEvery()&lt;/code&gt; 和 &lt;code&gt;isAny()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="ace18740b81dab0322b75335cffde9805b53a9b6" translate="yes" xml:space="preserve">
          <source>Likewise, if you try to call &lt;code&gt;get&lt;/code&gt; on a property whose value is &lt;code&gt;undefined&lt;/code&gt;, the &lt;code&gt;unknownProperty()&lt;/code&gt; method will be called on the object. If this method returns any value other than &lt;code&gt;undefined&lt;/code&gt;, it will be returned instead. This allows you to implement &quot;virtual&quot; properties that are not defined upfront.</source>
          <target state="translated">同样，如果你尝试调用 &lt;code&gt;get&lt;/code&gt; 关于它的值是一个属性 &lt;code&gt;undefined&lt;/code&gt; 的 &lt;code&gt;unknownProperty()&lt;/code&gt; 方法将在对象上调用。如果此方法返回的值不是 &lt;code&gt;undefined&lt;/code&gt; ，则将返回它。这使您可以实现未预先定义的&amp;ldquo;虚拟&amp;rdquo;属性。</target>
        </trans-unit>
        <trans-unit id="f6c5555cae22b7bb9706107a4ca1a41e719e438c" translate="yes" xml:space="preserve">
          <source>Link to contact information</source>
          <target state="translated">联系信息的链接</target>
        </trans-unit>
        <trans-unit id="74076a27ecfcb330397619467fbee055750ed67b" translate="yes" xml:space="preserve">
          <source>Link to information about the company</source>
          <target state="translated">链接到公司信息</target>
        </trans-unit>
        <trans-unit id="5d77a7c8983578d904111c3bee72bdf79449008b" translate="yes" xml:space="preserve">
          <source>LinkComponent</source>
          <target state="translated">LinkComponent</target>
        </trans-unit>
        <trans-unit id="ac4a62a01d54a4764c6d144461d6c9e37e4819d1" translate="yes" xml:space="preserve">
          <source>LinkComponent.rel</source>
          <target state="translated">LinkComponent.rel</target>
        </trans-unit>
        <trans-unit id="940de94ebf96b39d03d62b9606182c5b87b78db6" translate="yes" xml:space="preserve">
          <source>Linking to a Specific Rental</source>
          <target state="translated">链接到特定的租赁</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="90f76386e11d7ad585627bc493ee7aedded009f6" translate="yes" xml:space="preserve">
          <source>Links beginning with &lt;code&gt;//&lt;/code&gt;, &lt;code&gt;http://&lt;/code&gt;, &lt;code&gt;https://&lt;/code&gt;, will be used as is, with no further manipulation.</source>
          <target state="translated">以 &lt;code&gt;//&lt;/code&gt; ， &lt;code&gt;http://&lt;/code&gt; ， &lt;code&gt;https://&lt;/code&gt; 开头的链接将按原样使用，无需进一步操作。</target>
        </trans-unit>
        <trans-unit id="9cf37ddbb4833e091bc4ad70d9b2018056400b70" translate="yes" xml:space="preserve">
          <source>Links beginning with a single &lt;code&gt;/&lt;/code&gt; will have the current adapter's &lt;code&gt;host&lt;/code&gt; value prepended to it.</source>
          <target state="translated">以 &lt;code&gt;/&lt;/code&gt; 开头的链接将使用当前适配器的 &lt;code&gt;host&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="f7264df21b6806560320b80c6b7fbb6558a5eb0e" translate="yes" xml:space="preserve">
          <source>Links with no beginning &lt;code&gt;/&lt;/code&gt; will have a parentURL prepended to it, via the current adapter's &lt;code&gt;buildURL&lt;/code&gt;.</source>
          <target state="translated">通过当前适配器的 &lt;code&gt;buildURL&lt;/code&gt; ，没有开始 &lt;code&gt;/&lt;/code&gt; 的链接将带有一个parentURL。</target>
        </trans-unit>
        <trans-unit id="66bf4d535a1ef04e79b6cdc89f1a06627656f756" translate="yes" xml:space="preserve">
          <source>Linter, linting</source>
          <target state="translated">绒毛机</target>
        </trans-unit>
        <trans-unit id="bbba5a3d0f934d3dca2995dd3e4663bd1ec20aff" translate="yes" xml:space="preserve">
          <source>Linux users can use &lt;a href=&quot;https://nodejs.org/en/download/package-manager/&quot;&gt;this guide for Node.js installation on Linux&lt;/a&gt;.</source>
          <target state="translated">Linux用户可以使用&lt;a href=&quot;https://nodejs.org/en/download/package-manager/&quot;&gt;本指南适用于Linux的Node.js安装&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29b74ca8265c653c34364f3d4acd28cd24128388" translate="yes" xml:space="preserve">
          <source>List of objects defining filters. The object should have a `name` and `desc` property.</source>
          <target state="translated">定义过滤器的对象清单。该对象应具有`name`和`desc`属性。</target>
        </trans-unit>
        <trans-unit id="00607eeb7342e3f04724c5834e4e2e8f7c2f6ff1" translate="yes" xml:space="preserve">
          <source>List the available rentals</source>
          <target state="translated">列出可用的租金</target>
        </trans-unit>
        <trans-unit id="d03c2905c8cd553f3f1f729734fe9cef1280d14a" translate="yes" xml:space="preserve">
          <source>Listed below are the component lifecycle hooks in order of execution according to render scenario.</source>
          <target state="translated">下面列出的是组件生命周期钩子,根据渲染场景的执行顺序。</target>
        </trans-unit>
        <trans-unit id="02afd43a11c4310cdd19459b87081ef2af547ad3" translate="yes" xml:space="preserve">
          <source>Loading / Error Substates</source>
          <target state="translated">加载/错误替代物</target>
        </trans-unit>
        <trans-unit id="0989b580dabe8ed18a9790d54605768f7b2e7f15" translate="yes" xml:space="preserve">
          <source>Loads a record in a belongs to relationship if it is not already loaded. If the relationship is already loaded this method does not trigger a new load.</source>
          <target state="translated">如果一个记录还没有被加载,则加载一个属于关系中的记录。如果关系已经被加载,本方法不会触发新的加载。</target>
        </trans-unit>
        <trans-unit id="1ed570ef8b28d2a9d4b5544de5723875a7b30ab7" translate="yes" xml:space="preserve">
          <source>Loads a route, sets up any controllers, and renders any templates associated with the route as though a real user had triggered the route change while using your app.</source>
          <target state="translated">加载路由,设置任何控制器,并渲染与路由相关联的任何模板,就像真实用户在使用您的应用程序时触发路由更改一样。</target>
        </trans-unit>
        <trans-unit id="8b618c79a59fd45e8d69fc13ceb218d48e4542b0" translate="yes" xml:space="preserve">
          <source>Loads the relationship if it is not already loaded. If the relationship is already loaded this method does not trigger a new load.</source>
          <target state="translated">如果还没有加载关系,则加载关系。如果关系已经被加载,这个方法不会触发新的加载。</target>
        </trans-unit>
        <trans-unit id="e3b0da20d6e4d3578fde73b0982ef39086f18d71" translate="yes" xml:space="preserve">
          <source>Location API</source>
          <target state="translated">位置API</target>
        </trans-unit>
        <trans-unit id="3c20cc766b3ed4cefd9c0f4868560b2be809f67b" translate="yes" xml:space="preserve">
          <source>Log generated controller</source>
          <target state="translated">控制器生成的日志</target>
        </trans-unit>
        <trans-unit id="5d5c719cb08629876124bf7f8b02dda0475b8203" translate="yes" xml:space="preserve">
          <source>Log object bindings</source>
          <target state="translated">日志对象绑定</target>
        </trans-unit>
        <trans-unit id="603c2cf3c52217f421f3b823673b4e845405e05d" translate="yes" xml:space="preserve">
          <source>Log router transitions</source>
          <target state="translated">记录路由器的转换</target>
        </trans-unit>
        <trans-unit id="aa00341e83ed481f80d9005fae06dbb9d29b533e" translate="yes" xml:space="preserve">
          <source>Log view lookups</source>
          <target state="translated">日志视图查询</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="f2e14633e86adb02560262087e31589175004916" translate="yes" xml:space="preserve">
          <source>Logging.</source>
          <target state="translated">Logging.</target>
        </trans-unit>
        <trans-unit id="1bfaba86c08ed86838f22fb60cceb822f0b9db4c" translate="yes" xml:space="preserve">
          <source>Mac users often prefer to install Node using &lt;a href=&quot;http://brew.sh/&quot;&gt;Homebrew&lt;/a&gt;. After installing Homebrew, run &lt;code&gt;brew install node&lt;/code&gt; to install Node.js. Alternatively, installer packages are available directly from &lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;Node.js&lt;/a&gt;.</source>
          <target state="translated">Mac用户通常喜欢使用&lt;a href=&quot;http://brew.sh/&quot;&gt;Homebrew&lt;/a&gt;安装Node 。安装Homebrew后，运行 &lt;code&gt;brew install node&lt;/code&gt; 安装Node.js。或者，可以直接从&lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;Node.js&lt;/a&gt;获得安装程序包。</target>
        </trans-unit>
        <trans-unit id="e2443f268bec1ac71f9689a446f93b5003aeaf34" translate="yes" xml:space="preserve">
          <source>Make sure the &quot;Display the Tomster&quot; checkbox is checked.</source>
          <target state="translated">确保 &quot;显示Tomster &quot;复选框被选中。</target>
        </trans-unit>
        <trans-unit id="6ad226711cb1283574db1e4c496932d2f5407750" translate="yes" xml:space="preserve">
          <source>Make sure the Inspector is active when you call this method.</source>
          <target state="translated">当你调用这个方法时,请确保检查员是活动的。</target>
        </trans-unit>
        <trans-unit id="5be8b4e32ecc791ac6bd4b6f06d2b9e2c830fcde" translate="yes" xml:space="preserve">
          <source>Make sure to use these accessor methods; otherwise, computed properties won't recalculate, observers won't fire, and templates won't update.</source>
          <target state="translated">一定要使用这些访问器方法,否则,计算出的属性不会重新计算,观察者不会启动,模板也不会更新。</target>
        </trans-unit>
        <trans-unit id="a10cf5cb44c73808cbd9b0ee95ade42559077f79" translate="yes" xml:space="preserve">
          <source>Make sure you are testing performance on real devices. Simulated mobile environments on a desktop computer give an optimistic-at-best representation of what your real world performance will be like. The more operating systems and hardware configurations you test, the more confident you can be.</source>
          <target state="translated">确保你是在真实设备上测试性能。在台式电脑上的模拟移动环境可以最乐观地反映出你的真实世界的性能。你测试的操作系统和硬件配置越多,你就越有信心。</target>
        </trans-unit>
        <trans-unit id="a4b28eac87396cdc54aabf1394e488ee8f47ac04" translate="yes" xml:space="preserve">
          <source>Make sure you list these dependencies so Ember knows when to update bindings that connect to a computed property. Changing a dependency will not immediately trigger an update of the computed property, but will instead clear the cache so that it is updated when the next &lt;code&gt;get&lt;/code&gt; is called on the property.</source>
          <target state="translated">确保列出这些依赖项，以便Ember知道何时更新连接到计算属性的绑定。更改依赖关系不会立即触发计算属性的更新，而是会清除缓存，以便在对该属性调用下一个 &lt;code&gt;get&lt;/code&gt; 时更新缓存。</target>
        </trans-unit>
        <trans-unit id="d867490c5d6df24c478defa0929214c97994571f" translate="yes" xml:space="preserve">
          <source>Makes a method available via an additional name.</source>
          <target state="translated">通过附加的名称使方法可用。</target>
        </trans-unit>
        <trans-unit id="c324510651548eb44cd83c2afb3351e2d31a161e" translate="yes" xml:space="preserve">
          <source>Making Google Maps Available</source>
          <target state="translated">提供谷歌地图</target>
        </trans-unit>
        <trans-unit id="6b2c35fea089f0887b25b17735fb5a1d326a2654" translate="yes" xml:space="preserve">
          <source>Making Updates to the Rendered DOM with &lt;code&gt;didRender&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;didRender&lt;/code&gt; 更新渲染的DOM</target>
        </trans-unit>
        <trans-unit id="70bfaf1566829005270d36f38f0ffe1bc5723469" translate="yes" xml:space="preserve">
          <source>Making changes to Ember Data records is as simple as setting the attribute you want to change:</source>
          <target state="translated">对Ember Data记录进行更改就像设置您要更改的属性一样简单。</target>
        </trans-unit>
        <trans-unit id="dcaec0425116cb667caf4bac2560e1cc169c5402" translate="yes" xml:space="preserve">
          <source>Managing Dependencies</source>
          <target state="translated">管理依赖性</target>
        </trans-unit>
        <trans-unit id="af5b5bc4db6b9a07519c515c5725d7ebc1a458e9" translate="yes" xml:space="preserve">
          <source>Many computed properties have dependencies on other properties. For example, in the above example, the &lt;code&gt;fullName&lt;/code&gt; property depends on &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; to determine its value. You can tell Ember about these dependencies like this:</source>
          <target state="translated">许多计算出的属性都依赖于其他属性。例如，在上面的示例中， &lt;code&gt;fullName&lt;/code&gt; 属性取决于 &lt;code&gt;firstName&lt;/code&gt; 和 &lt;code&gt;lastName&lt;/code&gt; 来确定其值。您可以像这样将这些依赖项告诉Ember：</target>
        </trans-unit>
        <trans-unit id="65b31bc269a60f245ce759ee19932b6d67fae66e" translate="yes" xml:space="preserve">
          <source>Many of the common HTML properties you would want to use like &lt;code&gt;class&lt;/code&gt;, and &lt;code&gt;rel&lt;/code&gt; will work. When adding class names, Ember will also apply the standard &lt;code&gt;ember-view&lt;/code&gt; and possibly &lt;code&gt;active&lt;/code&gt; class names.</source>
          <target state="translated">您想使用的许多常见HTML属性（例如 &lt;code&gt;class&lt;/code&gt; ）和 &lt;code&gt;rel&lt;/code&gt; 都可以使用。添加类名称时，Ember还将应用标准的 &lt;code&gt;ember-view&lt;/code&gt; 和可能的 &lt;code&gt;active&lt;/code&gt; 类名称。</target>
        </trans-unit>
        <trans-unit id="6b961b379063852ca79321587bc3a8c0ab661545" translate="yes" xml:space="preserve">
          <source>Many other libraries provide some kind of iterator or enumeration like facility. This is often where the most common API conflicts occur. Ember's API is designed to be as friendly as possible with other libraries by implementing only methods that mostly correspond to the JavaScript 1.8 API.</source>
          <target state="translated">许多其他库都提供了某种类似迭代器或枚举的设施。这通常是最常见的API冲突发生的地方。Ember的API被设计成尽可能地与其他库友好,只实现了与JavaScript 1.8 API相对应的方法。</target>
        </trans-unit>
        <trans-unit id="2ca19e6e187118e63e97c39edbdf6a65e72c04c2" translate="yes" xml:space="preserve">
          <source>Many servers, such as Rails and PHP, will automatically convert this URL-encoded array into an Array for you on the server-side. If you want to encode the IDs, differently, just override this (one-line) method.</source>
          <target state="translated">许多服务器,如 Rails 和 PHP,会在服务器端自动将这个 URL 编码的数组转换为 Array。如果你想对ID进行不同的编码,只需覆盖这个(单行)方法。</target>
        </trans-unit>
        <trans-unit id="1bee9fefa75d1483e8070e9750032eef28ff759d" translate="yes" xml:space="preserve">
          <source>Many-To-Many</source>
          <target state="translated">Many-To-Many</target>
        </trans-unit>
        <trans-unit id="c883031b9ab452aff47320db2b5868dd27dd5be3" translate="yes" xml:space="preserve">
          <source>Many-to-Many</source>
          <target state="translated">Many-to-Many</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="510afa932a8af5b85329d8ebc5ac4856e95f63ef" translate="yes" xml:space="preserve">
          <source>Map a controller's property to a different query param key</source>
          <target state="translated">将一个控制器的属性映射到一个不同的查询参数键。</target>
        </trans-unit>
        <trans-unit id="a89a789ab5fcdfe6e7cedcf5a3677beb9a16fe8f" translate="yes" xml:space="preserve">
          <source>Maps all of the items in the enumeration to another value, returning a new array. This method corresponds to &lt;code&gt;map()&lt;/code&gt; defined in JavaScript 1.6.</source>
          <target state="translated">将枚举中的所有项目映射到另一个值，并返回一个新数组。此方法对应于JavaScript 1.6中定义的 &lt;code&gt;map()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbe8601461d7ed761fcd5a028a86fa5c4bf1934e" translate="yes" xml:space="preserve">
          <source>Mark a string as safe for unescaped output with Ember templates. If you return HTML from a helper, use this function to ensure Ember's rendering layer does not escape the HTML.</source>
          <target state="translated">将一个字符串标记为安全的字符串,以便使用Ember模板进行未转义输出。如果你从帮助程序返回HTML,使用这个函数来确保Ember的渲染层不会转义HTML。</target>
        </trans-unit>
        <trans-unit id="fb8384f3697cae9999b84d6bff001ae61ca3ac5e" translate="yes" xml:space="preserve">
          <source>Marks the record as deleted but does not save it. You must call &lt;code&gt;save&lt;/code&gt; afterwards if you want to persist it. You might use this method if you want to allow the user to still &lt;code&gt;rollbackAttributes()&lt;/code&gt; after a delete was made.</source>
          <target state="translated">将记录标记为已删除，但不保存。如果要持久 &lt;code&gt;save&lt;/code&gt; ，则必须随后调用保存。如果要允许用户在执行删除操作后仍然使用 &lt;code&gt;rollbackAttributes()&lt;/code&gt; ，则可以使用此方法。</target>
        </trans-unit>
        <trans-unit id="1ef56709ca6a20c8e16b3f6b056dde8c7b15f5b0" translate="yes" xml:space="preserve">
          <source>Measure performance from the beginning, and keep testing as your app develops.</source>
          <target state="translated">从一开始就对性能进行衡量,并在应用开发过程中不断测试。</target>
        </trans-unit>
        <trans-unit id="8c2479a17e803025649242a9474178042dc135a9" translate="yes" xml:space="preserve">
          <source>Merge the contents of two objects together into the first object.</source>
          <target state="translated">将两个对象的内容合并到第一个对象中。</target>
        </trans-unit>
        <trans-unit id="8d546a6dea9ff90d517b51c25b35319931ae4e04" translate="yes" xml:space="preserve">
          <source>Meta</source>
          <target state="translated">Meta</target>
        </trans-unit>
        <trans-unit id="ea9fc818037e4c1eb523043b8c97a427dff9ed43" translate="yes" xml:space="preserve">
          <source>Metadata associated with the request for async hasMany relationships.</source>
          <target state="translated">与请求async hasMany关系相关的元数据。</target>
        </trans-unit>
        <trans-unit id="cdd0b54a13118c5e57a4f231ed1e30a46262760c" translate="yes" xml:space="preserve">
          <source>Method Implementation</source>
          <target state="translated">方法实施</target>
        </trans-unit>
        <trans-unit id="fb4e599fda756443d7e1a45a5e3f433bc0cffb30" translate="yes" xml:space="preserve">
          <source>Method to call to remove all observers</source>
          <target state="translated">调用方法以删除所有观察员</target>
        </trans-unit>
        <trans-unit id="f3f9a4f8e75f8f8fc949764d8a4323ec811afdd7" translate="yes" xml:space="preserve">
          <source>Method to call to remove all observers.</source>
          <target state="translated">调用该方法来删除所有观察者。</target>
        </trans-unit>
        <trans-unit id="3382975c2f98c7ed302504a43959793238b27e2b" translate="yes" xml:space="preserve">
          <source>Method to invoke. May be a function or a string. If you pass a string then it will be looked up on the passed target.</source>
          <target state="translated">要调用的方法。可以是一个函数或一个字符串。如果你传递了一个字符串,那么它将在传递的目标上被查找。</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="16e8c90b05ca8f10c04dfc691ff732fb574a0479" translate="yes" xml:space="preserve">
          <source>Mirage works by overriding the JavaScript code that makes network requests and instead returns the JSON you specify. We should note that this means you will not see any network requests in your development tools but will instead see the JSON logged in your console. Our update to &lt;code&gt;mirage/config.js&lt;/code&gt; configures Mirage so that whenever Ember Data makes a GET request to &lt;code&gt;/api/rentals&lt;/code&gt;, Mirage will return this JavaScript object as JSON and no network request is actually made. We also specified a &lt;code&gt;namespace&lt;/code&gt; of &lt;code&gt;/api&lt;/code&gt; in our mirage configuration. Without this change, navigation to &lt;code&gt;/rentals&lt;/code&gt; in our application would conflict with Mirage.</source>
          <target state="translated">Mirage通过覆盖发出网络请求的JavaScript代码来工作，而是返回您指定的JSON。我们应该注意，这意味着您将不会在开发工具中看到任何网络请求，而是会看到控制台中记录的JSON。我们对Mirage &lt;code&gt;mirage/config.js&lt;/code&gt; 更新配置了Mirage，以便每当Ember Data向 &lt;code&gt;/api/rentals&lt;/code&gt; 发出GET请求时，Mirage都会将此JavaScript对象作为JSON返回，并且实际上没有网络请求。我们还指定了一个 &lt;code&gt;namespace&lt;/code&gt; 的 &lt;code&gt;/api&lt;/code&gt; 在我们的海市蜃楼配置。如果不进行此更改，则在我们的应用程序中导航到 &lt;code&gt;/rentals&lt;/code&gt; 将与Mirage冲突。</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="1d21f12330d03b94dcb1cd6e01f79b79236abc39" translate="yes" xml:space="preserve">
          <source>Missing Promises</source>
          <target state="translated">缺少的承诺</target>
        </trans-unit>
        <trans-unit id="c0dcb865ad81a32e522b11fd1e33bae685e88709" translate="yes" xml:space="preserve">
          <source>Mixed</source>
          <target state="translated">Mixed</target>
        </trans-unit>
        <trans-unit id="8acb4f1a53ad0e32454267c61a794bb3188be2c6" translate="yes" xml:space="preserve">
          <source>Mixin</source>
          <target state="translated">Mixin</target>
        </trans-unit>
        <trans-unit id="7f1fa61246876b33a612f1bb51874527379a609d" translate="yes" xml:space="preserve">
          <source>Mobile Devices</source>
          <target state="translated">移动设备</target>
        </trans-unit>
        <trans-unit id="817f9d67353c530f2c6d64063a80813debd1618f" translate="yes" xml:space="preserve">
          <source>Model Relationships</source>
          <target state="translated">模型关系</target>
        </trans-unit>
        <trans-unit id="631fcdbb4433fd9a49c55ac2973f6d77e0d68f1d" translate="yes" xml:space="preserve">
          <source>Model-specific adapters can be created by putting your adapter class in an &lt;code&gt;app/adapters/&lt;/code&gt; + &lt;code&gt;model-name&lt;/code&gt; + &lt;code&gt;.js&lt;/code&gt; file of the application.</source>
          <target state="translated">可以通过将适配器类放在 &lt;code&gt;app/adapters/&lt;/code&gt; + &lt;code&gt;model-name&lt;/code&gt; + &lt;code&gt;.js&lt;/code&gt; 文件中来创建特定于模型的适配器。</target>
        </trans-unit>
        <trans-unit id="f3798f81c7b6fecad2cbfec741314f8a66c0eca3" translate="yes" xml:space="preserve">
          <source>Models</source>
          <target state="translated">Models</target>
        </trans-unit>
        <trans-unit id="aa3797a25b7cc382220d5723004f9b4aa101aa91" translate="yes" xml:space="preserve">
          <source>Models are objects that represent the underlying data that your application presents to the user. Different apps will have very different models, depending on what problems they're trying to solve.</source>
          <target state="translated">模型是表示您的应用程序向用户展示的基础数据的对象。不同的应用程序会有非常不同的模型,这取决于他们试图解决什么问题。</target>
        </trans-unit>
        <trans-unit id="019afea3eb207ecfb59621840f4278d323f8e988" translate="yes" xml:space="preserve">
          <source>Models define the type of data that will be provided by your server. For example, a &lt;code&gt;Person&lt;/code&gt; model might have a &lt;code&gt;firstName&lt;/code&gt; attribute that is a string, and a &lt;code&gt;birthday&lt;/code&gt; attribute that is a date:</source>
          <target state="translated">模型定义了服务器将提供的数据类型。例如，一个 &lt;code&gt;Person&lt;/code&gt; 模型可能具有一个 &lt;code&gt;firstName&lt;/code&gt; 属性（一个字符串）和一个 &lt;code&gt;birthday&lt;/code&gt; 属性（一个日期）：</target>
        </trans-unit>
        <trans-unit id="8840b4d964096eecdc906427cdbaf361ea0eb171" translate="yes" xml:space="preserve">
          <source>Models don't have any data themselves, they define the attributes, relationships and behavior of specific instances, which are called &lt;strong&gt;records&lt;/strong&gt;.</source>
          <target state="translated">模型本身没有任何数据，它们定义了特定实例的属性，关系和行为，称为&lt;strong&gt;记录&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5b1d06fa82763ab47944cd44ffa1f0114d490583" translate="yes" xml:space="preserve">
          <source>Models represent persistent state.</source>
          <target state="translated">模型表示持久状态。</target>
        </trans-unit>
        <trans-unit id="829196320118f53e8a87ca0f181c1208424d33f7" translate="yes" xml:space="preserve">
          <source>Models tend to be &lt;em&gt;persistent&lt;/em&gt;. That means the user does not expect model data to be lost when they close their browser window. To make sure no data is lost, if the user makes changes to a model, you need to store the model data somewhere that it will not be lost.</source>
          <target state="translated">模型往往是&lt;em&gt;持久的&lt;/em&gt;。这意味着用户不希望在关闭浏览器窗口时丢失模型数据。为确保没有数据丢失，如果用户对模型进行了更改，则需要将模型数据存储在不会丢失的位置。</target>
        </trans-unit>
        <trans-unit id="becbba5666aa6f8e8151efb9c6a064c94e791551" translate="yes" xml:space="preserve">
          <source>Models, records, adapters and the store are the core concepts you should understand to get the most out of Ember Data. The following sections go into more depth about each of these concepts, and how to use them together.</source>
          <target state="translated">模型、记录、适配器和存储是您应该理解的核心概念,以获得Ember Data的大部分功能。下面的章节将更深入地介绍这些概念,以及如何将它们结合起来使用。</target>
        </trans-unit>
        <trans-unit id="e33dda3590ab9e1e10e3d376c68eb2ddf127a98d" translate="yes" xml:space="preserve">
          <source>Modern application asset management (including concatenation, minification, and versioning).</source>
          <target state="translated">现代化的应用资产管理(包括连接、小型化和版本化)。</target>
        </trans-unit>
        <trans-unit id="4dc51b6f068ce224674bf3d77da2de0c1a9aa6fa" translate="yes" xml:space="preserve">
          <source>Modifying the action's first parameter</source>
          <target state="translated">修改动作的第一个参数</target>
        </trans-unit>
        <trans-unit id="d60ceaa995b9a7096628c7dee8145d8ce19d1838" translate="yes" xml:space="preserve">
          <source>Module:</source>
          <target state="translated">Module:</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="39760d15e024ca9e9dbb9f88fa69744a42526bab" translate="yes" xml:space="preserve">
          <source>More documentation about &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; are below.</source>
          <target state="translated">下面是有关 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 的更多文档。</target>
        </trans-unit>
        <trans-unit id="5a59199bd069e71ebec2691e36709a71e3b09cb6" translate="yes" xml:space="preserve">
          <source>More general than decamelize. Returns the lower_case_and_underscored form of a string.</source>
          <target state="translated">比 decamelize 更通用。返回字符串的小写和下划线形式。</target>
        </trans-unit>
        <trans-unit id="55272c5128cb978d842fea14f3de880b35c70fcf" translate="yes" xml:space="preserve">
          <source>Most Ember.js applications will only have a single &lt;code&gt;DS.Store&lt;/code&gt; that is automatically created by their &lt;code&gt;Ember.Application&lt;/code&gt;.</source>
          <target state="translated">大多数Ember.js应用程序只有一个 &lt;code&gt;DS.Store&lt;/code&gt; ，由其 &lt;code&gt;Ember.Application&lt;/code&gt; 自动创建。</target>
        </trans-unit>
        <trans-unit id="43ad4a5b784abcbbce3b199f0ed3a3291fc39b60" translate="yes" xml:space="preserve">
          <source>Most browsers support at least ES5, and some even have ES6 (also known as ES2015) support. You can check each browser's support (including yours) here:</source>
          <target state="translated">大多数浏览器至少支持ES5,有些甚至支持ES6(也称为ES2015)。你可以在这里查看每个浏览器的支持情况(包括你的)。</target>
        </trans-unit>
        <trans-unit id="7be23ccab1061cd0bab7344d8b6ec95b5a61502e" translate="yes" xml:space="preserve">
          <source>Most templates in an Ember codebase are instantly familiar, and look like any fragment of HTML. For example:</source>
          <target state="translated">Ember代码库中的大多数模板都是一目了然的,看起来就像任何一个HTML的片段。比如说</target>
        </trans-unit>
        <trans-unit id="e640b670a6bf70395bf924c1c54b5e4ad8cb46d5" translate="yes" xml:space="preserve">
          <source>Most traditional REST-like HTTP APIs will not use this method. Instead, the ID of the record will be set by the server, and your adapter will update the store with the new ID when it calls &lt;code&gt;didCreateRecord()&lt;/code&gt;. Only implement this method if you intend to generate record IDs on the client-side.</source>
          <target state="translated">大多数传统的类似REST的HTTP API不会使用此方法。相反，记录的ID将由服务器设置，并且适配器在调用 &lt;code&gt;didCreateRecord()&lt;/code&gt; 时将使用新的ID更新存储。仅当您打算在客户端上生成记录ID时，才实现此方法。</target>
        </trans-unit>
        <trans-unit id="ee7f1ca589520f1cb0e1adb76c8c5be4f8dbe4c3" translate="yes" xml:space="preserve">
          <source>Mouse events</source>
          <target state="translated">鼠标事件</target>
        </trans-unit>
        <trans-unit id="b96500fb0aaaecea42972538de1579921015f914" translate="yes" xml:space="preserve">
          <source>Mouse events:</source>
          <target state="translated">鼠标事件。</target>
        </trans-unit>
        <trans-unit id="624f9b2fa33d8646c194683a6d7fb00f33f859c5" translate="yes" xml:space="preserve">
          <source>Move jobs from &lt;code&gt;CURRENT_QUEUE&lt;/code&gt; into &lt;code&gt;WORK_QUEUE&lt;/code&gt;</source>
          <target state="translated">将作业从 &lt;code&gt;CURRENT_QUEUE&lt;/code&gt; 移至 &lt;code&gt;WORK_QUEUE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f1408efe0b6e95b82adc5c6940f59fe1a42275e" translate="yes" xml:space="preserve">
          <source>Move on to the &lt;a href=&quot;../hbs-helper&quot;&gt;next page&lt;/a&gt; for the next feature, or continue on here to test what you just wrote.</source>
          <target state="translated">转到&lt;a href=&quot;../hbs-helper&quot;&gt;下&lt;/a&gt;一个功能的下一页，或继续此处以测试您刚刚编写的内容。</target>
        </trans-unit>
        <trans-unit id="a5e023c96f99c12b700a944b69a5398f51a87bdf" translate="yes" xml:space="preserve">
          <source>Moving around our site is a bit of a pain right now, so let's make that easier. We'll put a link to the contact page on the about page, and a corresponding link to the about page on the contact page.</source>
          <target state="translated">现在移动我们的网站有点麻烦,所以我们让它变得更容易。我们会在关于页面上放一个链接到联系页面,在联系页面上放一个相应的链接到关于页面。</target>
        </trans-unit>
        <trans-unit id="3d79d467d10ff9f72b3957527d9055f1f2344c6b" translate="yes" xml:space="preserve">
          <source>Much like how our application's &lt;code&gt;index&lt;/code&gt; route doesn't appear in our Router, &lt;code&gt;index&lt;/code&gt; routes on sub-routes won't explicitly appear in the Router either. Ember knows that the default action is to take the user to the &lt;code&gt;index&lt;/code&gt; route. However, you can add the &lt;code&gt;index&lt;/code&gt; route if you want to customize it. For example, you can modify the &lt;code&gt;index&lt;/code&gt; route's path by specifying &lt;code&gt;this.route('index', { path: '/custom-path'})&lt;/code&gt;.</source>
          <target state="translated">就像我们的应用程序的 &lt;code&gt;index&lt;/code&gt; 路由没有出现在路由器中一样，子路由的 &lt;code&gt;index&lt;/code&gt; 路由也不会显式出现在路由器中。Ember知道默认操作是将用户带到 &lt;code&gt;index&lt;/code&gt; 路由。但是，如果要自定义 &lt;code&gt;index&lt;/code&gt; 路由，则可以添加它。例如，您可以通过指定 &lt;code&gt;this.route('index', { path: '/custom-path'})&lt;/code&gt; 来修改 &lt;code&gt;index&lt;/code&gt; 路由的路径。</target>
        </trans-unit>
        <trans-unit id="6d0892f97ba890bdd37e0b0d9f6b4dec5bbe6b06" translate="yes" xml:space="preserve">
          <source>Much of the power of promises comes from the fact that they can be chained together to perform sequential asynchronous operations:</source>
          <target state="translated">承诺的强大之处很大程度上来自于它们可以链在一起执行连续的异步操作。</target>
        </trans-unit>
        <trans-unit id="28a601b1de7007639b3f9e108f2a1ef5c64fd42c" translate="yes" xml:space="preserve">
          <source>Multi-word route names are conventionally dasherized, such as:</source>
          <target state="translated">多字路线名习惯上采用破折号,如:。</target>
        </trans-unit>
        <trans-unit id="78340660db0f24ef38760b67cbbddc4412bcd4c1" translate="yes" xml:space="preserve">
          <source>Multi-word route names that break this convention, such as:</source>
          <target state="translated">打破了这一惯例的多字途径名称,如:。</target>
        </trans-unit>
        <trans-unit id="3b38834946b176dd5d95ff88c4d70d97548594fa" translate="yes" xml:space="preserve">
          <source>Multiple Dependent Keys</source>
          <target state="translated">多个独立键</target>
        </trans-unit>
        <trans-unit id="b8d5b89d2e964353c630f9ded89e04d3e86caaf0" translate="yes" xml:space="preserve">
          <source>Multiple Models</source>
          <target state="translated">多种型号</target>
        </trans-unit>
        <trans-unit id="12cbb2ffc194012d392a1c4993f0c9984dfd0981" translate="yes" xml:space="preserve">
          <source>Multiple Models Example</source>
          <target state="translated">多模型示例</target>
        </trans-unit>
        <trans-unit id="d6553f22af5154a8bd1c4ad52c108a92da650f3c" translate="yes" xml:space="preserve">
          <source>Multiple dependents on the same object</source>
          <target state="translated">同一对象上的多个依赖者</target>
        </trans-unit>
        <trans-unit id="ffac1ed7d498ee17123d25a206c3251a5fdeee0f" translate="yes" xml:space="preserve">
          <source>Multiple models can be returned through an &lt;a href=&quot;http://emberjs.com/api/classes/RSVP.html#method_hash&quot;&gt;RSVP.hash&lt;/a&gt;. The &lt;code&gt;RSVP.hash&lt;/code&gt; takes parameters that return promises, and when all parameter promises resolve, then the &lt;code&gt;RSVP.hash&lt;/code&gt; promise resolves. For example:</source>
          <target state="translated">可以通过&lt;a href=&quot;http://emberjs.com/api/classes/RSVP.html#method_hash&quot;&gt;RSVP.hash&lt;/a&gt;返回多个模型。该 &lt;code&gt;RSVP.hash&lt;/code&gt; 采用参数回报的承诺，当所有参数的承诺的决心，那么 &lt;code&gt;RSVP.hash&lt;/code&gt; 承诺做出决议。例如：</target>
        </trans-unit>
        <trans-unit id="7c3482c9f462fff40115cc375f0938294535d352" translate="yes" xml:space="preserve">
          <source>Multiple models will be applied last to first recursively up the route tree.</source>
          <target state="translated">多个模型将从最后一个到第一个递归地应用到路线树上。</target>
        </trans-unit>
        <trans-unit id="8fe2c0eff1698d461f5e41a286301db51f73fef1" translate="yes" xml:space="preserve">
          <source>Multiple operations scheduled with &lt;code&gt;run.next&lt;/code&gt; will coalesce into the same later run loop, along with any other operations scheduled by &lt;code&gt;run.later&lt;/code&gt; that expire right around the same time that &lt;code&gt;run.next&lt;/code&gt; operations will fire.</source>
          <target state="translated">使用 &lt;code&gt;run.next&lt;/code&gt; 调度的多个操作将与同一个稍后的run循环合并，以及通过 &lt;code&gt;run.later&lt;/code&gt; 调度的其他 &lt;code&gt;run.next&lt;/code&gt; 操作将在run.next操作即将触发的同时终止。</target>
        </trans-unit>
        <trans-unit id="02209f8602f7d7995fe4c193c3f7d7b587ad5ab3" translate="yes" xml:space="preserve">
          <source>Multiple relationships can be requested using an &lt;code&gt;include&lt;/code&gt; parameter consisting of a comma-separated list (without white-space) while nested relationships can be specified using a dot-separated sequence of relationship names. So to request both the post's comments and the authors of those comments the request would look like this:</source>
          <target state="translated">可以使用 &lt;code&gt;include&lt;/code&gt; 参数（由逗号分隔的列表（不包含空格））来请求多个关系，而可以使用点分隔的关系名称序列来指定嵌套关系。因此，要请求帖子的评论以及这些评论的作者，请求都将如下所示：</target>
        </trans-unit>
        <trans-unit id="b1257af504d574f79a9e631c64fb0753d98ae623" translate="yes" xml:space="preserve">
          <source>Multiple relationships can be requested using an &lt;code&gt;include&lt;/code&gt; parameter consisting of a comma-separated list (without white-space) while nested relationships can be specified using a dot-separated sequence of relationship names. So to request both the posts' comments and the authors of those comments the request would look like this:</source>
          <target state="translated">可以使用 &lt;code&gt;include&lt;/code&gt; 参数（由逗号分隔的列表（不包含空格））来请求多个关系，而可以使用点分隔的关系名称序列来指定嵌套关系。因此，要同时请求帖子的评论和这些评论的作者，请求将如下所示：</target>
        </trans-unit>
        <trans-unit id="702d485741e89433e6e857322e216f0b9ae4a268" translate="yes" xml:space="preserve">
          <source>Must be truthy for the assertion to pass. If falsy, an exception will be thrown.</source>
          <target state="translated">必须是真实的,才能通过断言。如果是假的,将抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="3d3267ee70dd314e7858273af7bdce38d29cc032" translate="yes" xml:space="preserve">
          <source>MutableArray</source>
          <target state="translated">MutableArray</target>
        </trans-unit>
        <trans-unit id="b34428639511f271396957f0dadabc146059f39f" translate="yes" xml:space="preserve">
          <source>MutableEnumerable</source>
          <target state="translated">MutableEnumerable</target>
        </trans-unit>
        <trans-unit id="444db15bd436aba203a5f5249e2de3679767da5f" translate="yes" xml:space="preserve">
          <source>NOTE: For performance reasons, you cannot declare methods or computed properties during &lt;code&gt;create&lt;/code&gt;. You should instead declare methods and computed properties when using &lt;code&gt;extend&lt;/code&gt;.</source>
          <target state="translated">注意：由于性能原因，您不能在 &lt;code&gt;create&lt;/code&gt; 期间声明方法或计算的属性。相反，在使用 &lt;code&gt;extend&lt;/code&gt; 时应声明方法和计算属性。</target>
        </trans-unit>
        <trans-unit id="fc4154a7358ac4c037dceca9b28d5e787994cdb5" translate="yes" xml:space="preserve">
          <source>NOTE: If you do override &lt;code&gt;init&lt;/code&gt; for a framework class like &lt;code&gt;Ember.View&lt;/code&gt;, be sure to call &lt;code&gt;this._super(...arguments)&lt;/code&gt; in your &lt;code&gt;init&lt;/code&gt; declaration! If you don't, Ember may not have an opportunity to do important setup work, and you'll see strange behavior in your application.</source>
          <target state="translated">注意：如果确实要为 &lt;code&gt;Ember.View&lt;/code&gt; 之类的框架类覆盖 &lt;code&gt;init&lt;/code&gt; ，请确保在 &lt;code&gt;init&lt;/code&gt; 声明中调用 &lt;code&gt;this._super(...arguments)&lt;/code&gt; ！如果您不这样做，Ember可能没有机会进行重要的设置工作，并且您会在应用程序中看到奇怪的行为。</target>
        </trans-unit>
        <trans-unit id="f1955b8da16f9aa4c86eaa507166aa1db45a4ada" translate="yes" xml:space="preserve">
          <source>NOTE: The alias should not reuse a name from the bound property path.</source>
          <target state="translated">注意:别名不应重复使用绑定属性路径的名称。</target>
        </trans-unit>
        <trans-unit id="80a1546459fb296b75e903b673f8cc0ad0b7638a" translate="yes" xml:space="preserve">
          <source>Named Arguments</source>
          <target state="translated">已命名参数</target>
        </trans-unit>
        <trans-unit id="0449e1003dd0cdd92ab163e844540614258e8b38" translate="yes" xml:space="preserve">
          <source>Namespace</source>
          <target state="translated">Namespace</target>
        </trans-unit>
        <trans-unit id="1da3a41b20375b2f1b43865d0bbcd472ab17276d" translate="yes" xml:space="preserve">
          <source>Namespace for injection helper methods.</source>
          <target state="translated">注入辅助方法的命名空间。</target>
        </trans-unit>
        <trans-unit id="447fb7bdde41273609f10df97bcb34cfc64373fe" translate="yes" xml:space="preserve">
          <source>Namespaced attributes (e.g. &lt;code&gt;xlink:href&lt;/code&gt;) are supported, but have to be mapped, since &lt;code&gt;:&lt;/code&gt; is not a valid character for properties in Javascript:</source>
          <target state="translated">支持命名空间属性（例如 &lt;code&gt;xlink:href&lt;/code&gt; ），但必须进行映射，因为 &lt;code&gt;:&lt;/code&gt; 不是Javascript属性的有效字符：</target>
        </trans-unit>
        <trans-unit id="0194361330bfd11c031b2f9a21891a7b0c91227e" translate="yes" xml:space="preserve">
          <source>Native arrays will no longer implement the functionality needed to observe them. If you disable prototype extension and attempt to use native arrays with things like a template's &lt;code&gt;{{#each}}&lt;/code&gt; helper, Ember.js will have no way to detect changes to the array and the template will not update as the underlying array changes.</source>
          <target state="translated">本机数组将不再实现观察它们所需的功能。如果您禁用原型扩展，并尝试将本机数组与模板的 &lt;code&gt;{{#each}}&lt;/code&gt; 帮助器一起使用，则Ember.js将无法检测到数组的更改，并且模板不会随着基础数组的更改而更新。</target>
        </trans-unit>
        <trans-unit id="a2ad1cc0d104518d7f977f6281c3fcd146fbd3d7" translate="yes" xml:space="preserve">
          <source>NativeArray</source>
          <target state="translated">NativeArray</target>
        </trans-unit>
        <trans-unit id="f03a4f8a865506a656451836ba3d745b0e85935f" translate="yes" xml:space="preserve">
          <source>Navigating the Inspector</source>
          <target state="translated">导航检查员</target>
        </trans-unit>
        <trans-unit id="f5f74a08b7244da0d1e71c555988da0c10984a2a" translate="yes" xml:space="preserve">
          <source>Navigating with Links and the {{link-to}} Helper</source>
          <target state="translated">使用链接和{{链接到}}助手进行导航。</target>
        </trans-unit>
        <trans-unit id="fbdea6bea0c2482852e3f2071895d1585ec8e658" translate="yes" xml:space="preserve">
          <source>Nested &lt;code&gt;if&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 嵌套</target>
        </trans-unit>
        <trans-unit id="f39bf32df616d09a91ab62108acfaade500b9df8" translate="yes" xml:space="preserve">
          <source>Nested Helpers</source>
          <target state="translated">嵌套助手</target>
        </trans-unit>
        <trans-unit id="d7217f3faabc627d5f38d65ad54b2ccfdec8cc27" translate="yes" xml:space="preserve">
          <source>Nested Route with Query String Example</source>
          <target state="translated">带有查询字符串的嵌套路由示例</target>
        </trans-unit>
        <trans-unit id="bef32b44309c819256ef91505f3ce46153114806" translate="yes" xml:space="preserve">
          <source>Nested Routes</source>
          <target state="translated">嵌套路线</target>
        </trans-unit>
        <trans-unit id="412558433783fdb3414d06e750eef597720539fc" translate="yes" xml:space="preserve">
          <source>Nested Usage</source>
          <target state="translated">嵌套使用</target>
        </trans-unit>
        <trans-unit id="e165e036879af1052e8bdc5248b80fa0f1e05752" translate="yes" xml:space="preserve">
          <source>Nested relationships can be specified in the &lt;code&gt;include&lt;/code&gt; parameter as a dot-separated sequence of relationship names. So to request both the post's comments and the authors of those comments the request would look like this:</source>
          <target state="translated">可以在 &lt;code&gt;include&lt;/code&gt; 参数中将嵌套关系指定为以点分隔的关系名称序列。因此，要请求帖子的评论以及这些评论的作者，请求都将如下所示：</target>
        </trans-unit>
        <trans-unit id="3c887b79e918144869d1815b78826218b269b1e7" translate="yes" xml:space="preserve">
          <source>Nesting built-in helpers</source>
          <target state="translated">嵌套内置助手</target>
        </trans-unit>
        <trans-unit id="0a6f6b6b3aa81f4339caf3807d89ac25f55b20e0" translate="yes" xml:space="preserve">
          <source>New CP syntax RFC</source>
          <target state="translated">新的CP语法RFC</target>
        </trans-unit>
        <trans-unit id="b7923e40f58719cc79ac4b24075ea07f4e514c24" translate="yes" xml:space="preserve">
          <source>New array with specified slice</source>
          <target state="translated">新数组的指定片断</target>
        </trans-unit>
        <trans-unit id="33d942259592ddfbc46880fa0a69c8975fc1398b" translate="yes" xml:space="preserve">
          <source>New computed syntax explained in &quot;Ember 1.12 released&quot;</source>
          <target state="translated">&quot;Ember 1.12发布 &quot;中解释了新的计算语法。</target>
        </trans-unit>
        <trans-unit id="a6fffbbf5a5a931d1edec274552843e555a9575b" translate="yes" xml:space="preserve">
          <source>New features are added to Ember.js within conditional statements.</source>
          <target state="translated">Ember.js的条件语句中增加了新的功能。</target>
        </trans-unit>
        <trans-unit id="803ecd92179c0dd3c69731cdda3a859bd14900b2" translate="yes" xml:space="preserve">
          <source>Next let's look at testing logic found within an object's method. In this case the &lt;code&gt;testMethod&lt;/code&gt; method alters some internal state of the object (by updating the &lt;code&gt;foo&lt;/code&gt; property).</source>
          <target state="translated">接下来，让我们看看在对象的方法中发现的测试逻辑。在这种情况下， &lt;code&gt;testMethod&lt;/code&gt; 方法会更改对象的某些内部状态（通过更新 &lt;code&gt;foo&lt;/code&gt; 属性）。</target>
        </trans-unit>
        <trans-unit id="e6d2115d3a8d9cff7fd04e688c7081d086bf8c63" translate="yes" xml:space="preserve">
          <source>Next we use &lt;code&gt;this.subject()&lt;/code&gt; to get an instance of the &lt;code&gt;PostsController&lt;/code&gt; and write a test to check the action. &lt;code&gt;this.subject()&lt;/code&gt; is a helper method from the &lt;code&gt;ember-qunit&lt;/code&gt; library that returns a singleton instance of the module set up using &lt;code&gt;moduleFor&lt;/code&gt;.</source>
          <target state="translated">接下来我们使用 &lt;code&gt;this.subject()&lt;/code&gt; 获得的一个实例 &lt;code&gt;PostsController&lt;/code&gt; ，写一个测试，以检查行动。 &lt;code&gt;this.subject()&lt;/code&gt; 是 &lt;code&gt;ember-qunit&lt;/code&gt; 库中的一个辅助方法，该方法返回使用 &lt;code&gt;moduleFor&lt;/code&gt; 设置的模块的单例实例。</target>
        </trans-unit>
        <trans-unit id="4fcc0bdd99f88cb81ef0b1774094121f146d3dd1" translate="yes" xml:space="preserve">
          <source>Next, in the child component we will implement the logic to confirm that the user wants to take the action they indicated by clicking the button:</source>
          <target state="translated">接下来,在子组件中,我们将实现逻辑,以确认用户要采取他们点击按钮所指示的动作。</target>
        </trans-unit>
        <trans-unit id="d40ada7307cf0a9c838ea79345644c54523ae5fb" translate="yes" xml:space="preserve">
          <source>Next, update the component to append the map output to the &lt;code&gt;div&lt;/code&gt; element we created.</source>
          <target state="translated">接下来，更新组件以将地图输出附加到我们创建的 &lt;code&gt;div&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="a7d19405fca795913088d60133cbb443100ac674" translate="yes" xml:space="preserve">
          <source>Next, we can update the template for our show route (&lt;code&gt;app/templates/rentals/show.hbs&lt;/code&gt;) and list the information for our rental.</source>
          <target state="translated">接下来，我们可以更新展示路线的模板（ &lt;code&gt;app/templates/rentals/show.hbs&lt;/code&gt; ）并列出我们的租金信息。</target>
        </trans-unit>
        <trans-unit id="fc4983c90fa60bc1ce9b9cbde2c331eec343b491" translate="yes" xml:space="preserve">
          <source>Next, we want to edit our &lt;code&gt;show&lt;/code&gt; route to retrieve the requested rental:</source>
          <target state="translated">接下来，我们要编辑 &lt;code&gt;show&lt;/code&gt; 路线以检索请求的租金：</target>
        </trans-unit>
        <trans-unit id="eb92e1d792e18cf5b9e39f3b1be27814a2469e18" translate="yes" xml:space="preserve">
          <source>Next, we will want to create a sub-route that will list information for a specific rental. To do this, we will need to update a couple of files. To find a specific rental, we will want to use Ember Data's &lt;code&gt;findRecord&lt;/code&gt; function &lt;a href=&quot;https://guides.emberjs.com/models/finding-records/&quot;&gt;(see &quot;Finding Records&quot; for more details)&lt;/a&gt;. The &lt;code&gt;findRecord&lt;/code&gt; function requires that we search by a unique key.</source>
          <target state="translated">接下来，我们将要创建一个子路线，该路线将列出特定租金的信息。为此，我们将需要更新几个文件。要查找特定的租金，我们将要使用Ember Data的 &lt;code&gt;findRecord&lt;/code&gt; 函数&lt;a href=&quot;https://guides.emberjs.com/models/finding-records/&quot;&gt;（有关更多详细信息，请参见&amp;ldquo;查找记录&amp;rdquo;）&lt;/a&gt;。该 &lt;code&gt;findRecord&lt;/code&gt; 功能需要我们通过一个独特的键搜索。</target>
        </trans-unit>
        <trans-unit id="72fd14162a8fc6d22cf491834da27111df0b38b5" translate="yes" xml:space="preserve">
          <source>Next, we'll add the call to render the component to show the cities we've provided above.</source>
          <target state="translated">接下来,我们将添加调用渲染组件来显示我们上面提供的城市。</target>
        </trans-unit>
        <trans-unit id="c121b18448e09b0ec7e3e82982b599fd9f5138e7" translate="yes" xml:space="preserve">
          <source>Next, we'll update the template using the component to use the block form:</source>
          <target state="translated">接下来,我们将使用组件更新模板,使用块状形式。</target>
        </trans-unit>
        <trans-unit id="6238b29303602319e16359dcf2e606b1c95d24d7" translate="yes" xml:space="preserve">
          <source>No documented items</source>
          <target state="translated">无记录项目</target>
        </trans-unit>
        <trans-unit id="9f80f5f1ae4b98a019524e97caf59f7371e4c299" translate="yes" xml:space="preserve">
          <source>No matter how the URL gets set, the first thing that happens is that the Ember router maps the URL to a route handler.</source>
          <target state="translated">无论URL如何设置,首先发生的是Ember路由器将URL映射到路由处理程序。</target>
        </trans-unit>
        <trans-unit id="36d42b52bca7ec360e2ec2fd821e5d1d54eeed7e" translate="yes" xml:space="preserve">
          <source>Node.js and npm</source>
          <target state="translated">Node.js和npm</target>
        </trans-unit>
        <trans-unit id="0bf1b177f41054dc701a64cbc840b3185281c706" translate="yes" xml:space="preserve">
          <source>NoneLocation</source>
          <target state="translated">NoneLocation</target>
        </trans-unit>
        <trans-unit id="2b92c9cfcc2262b2f6c3b43f6b3500b694ae1ee6" translate="yes" xml:space="preserve">
          <source>Normal arguments are useful for passing data to be transformed into helper functions. However, because the order in which you pass arguments matters, it is usually best not to have helpers take more than one or two of them.</source>
          <target state="translated">普通参数对于传递要转化为帮助函数的数据很有用,但由于传递参数的顺序很重要,通常最好不要让帮助函数接受其中的一个或两个参数。然而,由于传递参数的顺序很重要,通常最好不要让帮助函数使用超过一个或两个参数。</target>
        </trans-unit>
        <trans-unit id="c758641d7044d0875a095185bfa3bfff0989861e" translate="yes" xml:space="preserve">
          <source>Normalize the record and recursively normalize/extract all the embedded records while pushing them into the store as they are encountered</source>
          <target state="translated">归一化记录,并递归归一化/提取所有嵌入的记录,同时在遇到记录时将其推送到存储中。</target>
        </trans-unit>
        <trans-unit id="507e2c4b6bfe50777b8493cb99f3d2061997fa17" translate="yes" xml:space="preserve">
          <source>Normalizes a part of the JSON payload returned by the server. You should override this method, munge the hash and call super if you have generic normalization to do.</source>
          <target state="translated">归一化服务器返回的JSON有效载荷的一部分。你应该重写这个方法,对哈希进行归一化,如果你要做通用的归一化,则调用super。</target>
        </trans-unit>
        <trans-unit id="93184070eecd1992aa3ceffecf5d7e446dd037ad" translate="yes" xml:space="preserve">
          <source>Normalizing adapter responses</source>
          <target state="translated">适配器响应的标准化</target>
        </trans-unit>
        <trans-unit id="36175f91b69faec22cd1a2cefc739e08dcc8e5d5" translate="yes" xml:space="preserve">
          <source>Normally you should not need to invoke this method yourself. However if you are implementing raw event handlers when interfacing with other libraries or plugins, you should probably wrap all of your code inside this call.</source>
          <target state="translated">通常情况下,你应该不需要自己调用这个方法,但如果你在与其他库或插件接口时实现了原始事件处理程序,你可能应该将所有的代码封装在这个调用中。然而,如果你在与其他库或插件接口时实现了原始事件处理程序,你可能应该将所有的代码封装在这个调用中。</target>
        </trans-unit>
        <trans-unit id="4468565835878ef17cd4b55bc5caa9b1777c240f" translate="yes" xml:space="preserve">
          <source>Normally, Ember's component model is &quot;write-only&quot;. The component takes a bunch of attributes that it got passed in, and uses them to render its template.</source>
          <target state="translated">通常,Ember的组件模型是 &quot;只写 &quot;的。组件会把它传入的一堆属性,用它们来渲染它的模板。</target>
        </trans-unit>
        <trans-unit id="c7e6a52c08a7259c6321ad9e83e1ba7332c71dcf" translate="yes" xml:space="preserve">
          <source>Normally, applications will use the &lt;code&gt;RESTSerializer&lt;/code&gt; by implementing the &lt;code&gt;normalize&lt;/code&gt; method.</source>
          <target state="translated">通常，应用程序将通过实现 &lt;code&gt;normalize&lt;/code&gt; 方法使用 &lt;code&gt;RESTSerializer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc8af1aedfdbf84e674633bf407822f6539d0133" translate="yes" xml:space="preserve">
          <source>Not all APIs follow the conventions that the &lt;code&gt;JSONAPISerializer&lt;/code&gt; uses with a data namespace and sideloaded relationship records. Some legacy APIs may return a simple JSON payload that is just the requested resource or an array of serialized records. The &lt;code&gt;JSONSerializer&lt;/code&gt; is a serializer that ships with Ember Data that can be used alongside the &lt;code&gt;RESTAdapter&lt;/code&gt; to serialize these simpler APIs.</source>
          <target state="translated">并非所有API都遵循 &lt;code&gt;JSONAPISerializer&lt;/code&gt; 与数据名称空间和侧载关系记录一起使用的约定。一些旧版API可能会返回简单的JSON负载，该负载只是请求的资源或序列化记录的数组。该 &lt;code&gt;JSONSerializer&lt;/code&gt; 是串行器附带的灰烬数据可以沿着被用来 &lt;code&gt;RESTAdapter&lt;/code&gt; 序列化这些简单的API。</target>
        </trans-unit>
        <trans-unit id="ffb02f7d9bf0cc53a282a795dbaa82e1fca2c00b" translate="yes" xml:space="preserve">
          <source>Not all combinations of the supported options are valid. See the documentation on &lt;code&gt;Ember.Application#visit&lt;/code&gt; for the supported configurations.</source>
          <target state="translated">并非所有受支持选项的组合都有效。有关受支持的配置，请参见 &lt;code&gt;Ember.Application#visit&lt;/code&gt; 上的文档。</target>
        </trans-unit>
        <trans-unit id="9023fcc452af3baa532d621308c25e1e7a89cfd0" translate="yes" xml:space="preserve">
          <source>Not all options need to be passed to &lt;code&gt;render&lt;/code&gt;. Default values will be used based on the name of the route specified in the router or the Route's &lt;code&gt;controllerName&lt;/code&gt; and &lt;code&gt;templateName&lt;/code&gt; properties.</source>
          <target state="translated">并非所有选项都需要传递才能进行 &lt;code&gt;render&lt;/code&gt; 。将基于路由器中指定的路由名称或路由的 &lt;code&gt;controllerName&lt;/code&gt; 和 &lt;code&gt;templateName&lt;/code&gt; 属性使用默认值。</target>
        </trans-unit>
        <trans-unit id="7ba9a00d7a0449cb290ce3ad1120d3aa3636a895" translate="yes" xml:space="preserve">
          <source>Not to be confused with Shadow DOM. The concept of a virtual DOM means abstracting your code (or in our case, Ember) away from using the browser's DOM in favor of a &quot;virtual&quot; DOM that can easily be accessed for read/writes or even serialized.</source>
          <target state="translated">不要和影子DOM混淆。虚拟DOM的概念意味着将你的代码(或者在我们的例子中,Ember)从使用浏览器的DOM中抽象出来,转而使用一个 &quot;虚拟 &quot;的DOM,这个DOM可以很容易地进行读写甚至序列化访问。</target>
        </trans-unit>
        <trans-unit id="8cdf5c376933ccf1cfee5b424cfd3739a998e8c7" translate="yes" xml:space="preserve">
          <source>Not to be confused with Virtual DOM. Shadow DOM is still a work in progress, but basically a proposed way to have an &quot;isolated&quot; DOM encapsulated within your app's DOM.</source>
          <target state="translated">不要和虚拟DOM混淆。影子DOM仍然是一个进展中的工作,但基本上是一种建议的方式,以拥有一个 &quot;隔离 &quot;的DOM封装在你的应用程序的DOM中。</target>
        </trans-unit>
        <trans-unit id="9e207619ed228ed5f64d1d93956ce95d0f0e4129" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@each&lt;/code&gt; only works one level deep. You cannot use nested forms like &lt;code&gt;todos.@each.owner.name&lt;/code&gt; or &lt;code&gt;todos.@each.owner.@each.name&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;@each&lt;/code&gt; 只能深入一层。您不能使用嵌套形式，例如 &lt;code&gt;todos.@each.owner.name&lt;/code&gt; 或 &lt;code&gt;todos.@each.owner.@each.name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b78a2d350219decae3de8dbd9a934a76cc3210ab" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;deleteCurrentUser&lt;/code&gt; is no longer in quotes here as opposed to &lt;a href=&quot;#toc_passing-the-action-to-the-component&quot;&gt;previously&lt;/a&gt;. Quotes are used to initially pass the action down the component tree, but at every subsequent level you are instead passing the actual function reference (without quotes) in the action helper.</source>
          <target state="translated">请注意，与&lt;a href=&quot;#toc_passing-the-action-to-the-component&quot;&gt;以前&lt;/a&gt;相比， &lt;code&gt;deleteCurrentUser&lt;/code&gt; 在这里不再用引号引起来。引号用于最初将操作传递到组件树，但是在每个后​​续级别，您都将在操作帮助器中传递实际的函数引用（不带引号）。</target>
        </trans-unit>
        <trans-unit id="d657c22ecaee4c7aa7dc607d48a3471b79573dbd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;frozenCopy()&lt;/code&gt; will only work if you also implement &lt;code&gt;Ember.Freezable&lt;/code&gt;.</source>
          <target state="translated">请注意，只有在您还实现 &lt;code&gt;Ember.Freezable&lt;/code&gt; 时， &lt;code&gt;frozenCopy()&lt;/code&gt; 才起作用。</target>
        </trans-unit>
        <trans-unit id="f6e566c79c98a818eb2e7a547fefdc2888a15607" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;species&lt;/code&gt; and &lt;code&gt;createPerson&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; valid on the &lt;code&gt;tom&lt;/code&gt; and &lt;code&gt;yehuda&lt;/code&gt; variables. They are only valid on &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">需要注意的是 &lt;code&gt;species&lt;/code&gt; 和 &lt;code&gt;createPerson&lt;/code&gt; 是&lt;em&gt;不是&lt;/em&gt;在有效 &lt;code&gt;tom&lt;/code&gt; 和 &lt;code&gt;yehuda&lt;/code&gt; 的变量。它们仅对 &lt;code&gt;Person&lt;/code&gt; 有效。</target>
        </trans-unit>
        <trans-unit id="06970be1fcab9740b07ebf6451f16d6c3ba5f22e" translate="yes" xml:space="preserve">
          <source>Note that Ember's default &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt;JSON API adapter&lt;/a&gt; does not provide the functionality needed to support &lt;code&gt;queryRecord()&lt;/code&gt; directly as it relies on REST request definitions that return result data in the form of an array.</source>
          <target state="translated">请注意，Ember的默认&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt;JSON API适配器&lt;/a&gt;不提供直接支持 &lt;code&gt;queryRecord()&lt;/code&gt; 所需的功能，因为它依赖于以数组形式返回结果数据的REST请求定义。</target>
        </trans-unit>
        <trans-unit id="b8f582b0e70af7be068ecb7c92ee2cd1ea0f779d" translate="yes" xml:space="preserve">
          <source>Note that JSON-API also allows for object-level errors to be placed in an object with pointer &lt;code&gt;data&lt;/code&gt;, signifying that the problem cannot be traced to a specific attribute:</source>
          <target state="translated">请注意，JSON-API还允许将对象级错误放置在带有指针 &lt;code&gt;data&lt;/code&gt; 的对象中，这表明无法将问题追溯到特定属性：</target>
        </trans-unit>
        <trans-unit id="32b55a648a9226930f8a0dc87f4729a007906a54" translate="yes" xml:space="preserve">
          <source>Note that Mixins are created with &lt;code&gt;Ember.Mixin.create&lt;/code&gt;, not &lt;code&gt;Ember.Mixin.extend&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;Ember.Mixin.create&lt;/code&gt; 是使用Ember.Mixin.create创建的，而不是 &lt;code&gt;Ember.Mixin.extend&lt;/code&gt; 创建的。</target>
        </trans-unit>
        <trans-unit id="56b757d1d62e955259b537c65a5b0f0df274acce" translate="yes" xml:space="preserve">
          <source>Note that actions may be attached to any element of the DOM, but not all respond to the &lt;code&gt;click&lt;/code&gt; event. For example, if an action is attached to an &lt;code&gt;a&lt;/code&gt; link without an &lt;code&gt;href&lt;/code&gt; attribute, or to a &lt;code&gt;div&lt;/code&gt;, some browsers won't execute the associated function. If it's really needed to define actions over such elements, a CSS workaround exists to make them clickable, &lt;code&gt;cursor: pointer&lt;/code&gt;. For example:</source>
          <target state="translated">请注意，动作可以附加到DOM的任何元素，但并非所有动作都响应 &lt;code&gt;click&lt;/code&gt; 事件。例如，如果将动作附加到没有 &lt;code&gt;href&lt;/code&gt; 属性 &lt;code&gt;a&lt;/code&gt; 链接或 &lt;code&gt;div&lt;/code&gt; 上，则某些浏览器将不会执行关联的功能。如果确实需要在此类元素上定义操作，则存在CSS解决方法以使它们可单击， &lt;code&gt;cursor: pointer&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="c0e6cdf5e195bb9b233c0037678ccb4b71a62dca" translate="yes" xml:space="preserve">
          <source>Note that although you can pass optional arguments these will not be considered when looking for duplicates. New arguments will replace previous calls.</source>
          <target state="translated">请注意,虽然您可以传递可选的参数,但在寻找重复的参数时,这些参数将不被考虑。新的参数将取代之前的调用。</target>
        </trans-unit>
        <trans-unit id="c9855a05b5c5c77b57064406fd84a06bcd0a8dc0" translate="yes" xml:space="preserve">
          <source>Note that an Array can change even if it does not implement this mixin. For example, one might implement a SparseArray that cannot be directly modified, but if its underlying enumerable changes, it will change also.</source>
          <target state="translated">请注意,即使一个Array没有实现这个混合器,它也可以改变。例如,我们可以实现一个不能直接修改的 SparseArray,但如果它的底层枚举数发生变化,它也会发生变化。</target>
        </trans-unit>
        <trans-unit id="3521e07c4a5492836c834d2874a2f36b14039567" translate="yes" xml:space="preserve">
          <source>Note that an Enumerable can change even if it does not implement this mixin. For example, a MappedEnumerable cannot be directly modified but if its underlying enumerable changes, it will change also.</source>
          <target state="translated">请注意,一个 Enumerable 即使没有实现这个 mixin 也可以改变。例如,一个MappedEnumerable不能被直接修改,但如果它的底层枚举单元发生变化,它也会发生变化。</target>
        </trans-unit>
        <trans-unit id="924886ebe747f409911384465b52739f93291a0f" translate="yes" xml:space="preserve">
          <source>Note that an optional parameter can be sent to a record's &lt;code&gt;send()&lt;/code&gt; method, which will be passed as the second parameter to the event handler.</source>
          <target state="translated">请注意，可以将可选参数发送到记录的 &lt;code&gt;send()&lt;/code&gt; 方法，该方法将作为第二个参数传递给事件处理程序。</target>
        </trans-unit>
        <trans-unit id="33c0dee324e64567f69ae25ca1d96c1e702d98c2" translate="yes" xml:space="preserve">
          <source>Note that at this point of the tutorial, the data is still provided by the &lt;code&gt;app/routes/rentals.js&lt;/code&gt; file. We will make use of the mirage data we set up here in the upcoming section called &lt;a href=&quot;../ember-data&quot;&gt;Using Ember Data&lt;/a&gt;.</source>
          <target state="translated">请注意，在本教程的这一点上，数据仍然由 &lt;code&gt;app/routes/rentals.js&lt;/code&gt; 文件提供。我们将在接下来的&amp;ldquo; &lt;a href=&quot;../ember-data&quot;&gt;使用余料数据&amp;rdquo;&lt;/a&gt;部分中利用我们在此处设置的海市rage楼数据。</target>
        </trans-unit>
        <trans-unit id="1e9fe44fe234ff341d449b15a171ed9251b8aad4" translate="yes" xml:space="preserve">
          <source>Note that because it's just a filter, the result will contain any locally created records of the type, however, it will not make a request to the backend to retrieve additional records. If you would like to request all the records from the backend please use &lt;a href=&quot;#method_findAll&quot;&gt;store.findAll&lt;/a&gt;.</source>
          <target state="translated">请注意，由于它只是一个过滤器，结果将包含任何本地创建的类型的记录，但是，它不会向后端发出检索其他记录的请求。如果您想从后端请求所有记录，请使用&lt;a href=&quot;#method_findAll&quot;&gt;store.findAll&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0838905b21f58bd42b79e4b1f7728fbd5f10b750" translate="yes" xml:space="preserve">
          <source>Note that bindings don't update immediately. Ember waits until all of your application code has finished running before synchronizing changes, so you can change a bound property as many times as you'd like without worrying about the overhead of syncing bindings when values are transient.</source>
          <target state="translated">注意绑定不会立即更新。Ember会等到你所有的应用程序代码运行完毕后才会同步更改,所以你可以随意更改一个绑定属性,而不用担心在值是瞬时的情况下同步绑定的开销。</target>
        </trans-unit>
        <trans-unit id="958456bed5d43bbdc211b8f3e852be80e1eafc1d" translate="yes" xml:space="preserve">
          <source>Note that destruction is scheduled for the end of the run loop and does not happen immediately. It will set an isDestroying flag immediately.</source>
          <target state="translated">请注意,销毁是计划在运行循环结束时进行的,不会立即发生。它将立即设置一个isDestroying标志。</target>
        </trans-unit>
        <trans-unit id="02fedd1822a65dfaf8b470cacfe5d1ddfd042c45" translate="yes" xml:space="preserve">
          <source>Note that embedded records will serialize with the serializer for their model instead of the serializer in which they are defined.</source>
          <target state="translated">请注意,嵌入式记录将使用其模型的序列化器而不是定义它们的序列化器进行序列化。</target>
        </trans-unit>
        <trans-unit id="bdf60f3cfbf501d3dcffb7089a351e863fd21b98" translate="yes" xml:space="preserve">
          <source>Note that for curly components (&lt;code&gt;{{my-component}}&lt;/code&gt;) the bindings are already mutable, making the &lt;code&gt;mut&lt;/code&gt; unnecessary.</source>
          <target state="translated">请注意，对于卷曲组件（ &lt;code&gt;{{my-component}}&lt;/code&gt; 来说，绑定已经是可变的，因此不需要 &lt;code&gt;mut&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fa797c14ae391330eeeed89571db0017aff4300" translate="yes" xml:space="preserve">
          <source>Note that for performance reasons, while calling &lt;code&gt;create()&lt;/code&gt; you cannot redefine an instance's computed properties and should not redefine existing or define new methods. You should only set simple properties when calling &lt;code&gt;create()&lt;/code&gt;. If you need to define or redefine methods or computed properties, create a new subclass and instantiate that.</source>
          <target state="translated">请注意，出于性能原因，在调用 &lt;code&gt;create()&lt;/code&gt; 时,您不能重新定义实例的计算属性，并且不应重新定义现有实例或定义新方法。您仅应在调用 &lt;code&gt;create()&lt;/code&gt; 时设置简单属性。如果需要定义或重新定义方法或计算的属性，请创建一个新的子类并将其实例化。</target>
        </trans-unit>
        <trans-unit id="3fce3689a0766225ec48133f04e1b60a1d8c9390" translate="yes" xml:space="preserve">
          <source>Note that for routes with dynamic segments, this hook is not always executed. If the route is entered through a transition (e.g. when using the &lt;code&gt;link-to&lt;/code&gt; Handlebars helper or the &lt;code&gt;transitionTo&lt;/code&gt; method of routes), and a model context is already provided this hook is not called.</source>
          <target state="translated">请注意，对于具有动态线段的路由，此挂钩不一定总是执行。如果通过过渡输入了路线（例如，使用 &lt;code&gt;link-to&lt;/code&gt; Handlebars助手或路由的 &lt;code&gt;transitionTo&lt;/code&gt; 方法时），并且已经提供了模型上下文，则不会调用此挂钩。</target>
        </trans-unit>
        <trans-unit id="40e020d503512efc885004b76ea4846ffd6830fc" translate="yes" xml:space="preserve">
          <source>Note that here, we are using the ES6 shorthand method definition syntax: &lt;code&gt;model()&lt;/code&gt; is the same as writing &lt;code&gt;model: function()&lt;/code&gt;.</source>
          <target state="translated">请注意，此处使用的是ES6速记方法定义语法： &lt;code&gt;model()&lt;/code&gt; 与编写 &lt;code&gt;model: function()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afeb106af344e9d52a516511d31b13a986723101" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;propertyKey&lt;/code&gt; is a computed property, the observer will be called when any of the property dependencies are changed, even if the resulting value of the computed property is unchanged. This is necessary because computed properties are not computed until &lt;code&gt;get&lt;/code&gt; is called.</source>
          <target state="translated">请注意，如果 &lt;code&gt;propertyKey&lt;/code&gt; 是一个已计算的属性，则即使更改了所计算的属性的结果值，也将在更改任何属性依赖项时调用观察者。这是必需的，因为只有在调用 &lt;code&gt;get&lt;/code&gt; 之前，才计算计算出的属性。</target>
        </trans-unit>
        <trans-unit id="3feff379f3ec37882e3c4043a045e926ad0b8051" translate="yes" xml:space="preserve">
          <source>Note that if the object itself is &lt;code&gt;undefined&lt;/code&gt;, this method will throw an error.</source>
          <target state="translated">请注意，如果对象本身 &lt;code&gt;undefined&lt;/code&gt; ，则此方法将引发错误。</target>
        </trans-unit>
        <trans-unit id="540f116cbff565163df0174c504c06f99d5cfbf7" translate="yes" xml:space="preserve">
          <source>Note that in addition to a callback, you can also pass an optional target object that will be set as &quot;this&quot; on the context. This is a good way to give your iterator function access to the current object.</source>
          <target state="translated">请注意,除了回调,你还可以传递一个可选的目标对象,该对象将在上下文中被设置为 &quot;this&quot;。这是一个让你的迭代函数访问当前对象的好方法。</target>
        </trans-unit>
        <trans-unit id="5c955a4684ca89b99f35640968f2c4ee63c05c39" translate="yes" xml:space="preserve">
          <source>Note that in addition to a callback, you can also pass an optional target object that will be set as &lt;code&gt;this&lt;/code&gt; on the context.</source>
          <target state="translated">请注意，除了回调之外，您还可以传递一个可选的目标对象，该对象将在上下文中设置 &lt;code&gt;this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f43847d45892775735670813b1ca175dda47767b" translate="yes" xml:space="preserve">
          <source>Note that in addition to a callback, you can also pass an optional target object that will be set as &lt;code&gt;this&lt;/code&gt; on the context. This is a good way to give your iterator function access to the current object.</source>
          <target state="translated">请注意，除了回调之外，您还可以传递一个可选的目标对象，该对象将在上下文中设置 &lt;code&gt;this&lt;/code&gt; 。这是使迭代器函数可以访问当前对象的好方法。</target>
        </trans-unit>
        <trans-unit id="f2e78eacf4a6f2eb923292be3495f30dd476f1f2" translate="yes" xml:space="preserve">
          <source>Note that it is traditional but not required to prefix localized string keys with an underscore or other character so you can easily identify localized strings.</source>
          <target state="translated">请注意,在本地化字符串键前加上下划线或其他字符是传统的,但不是必须的,这样你就可以很容易地识别本地化字符串。</target>
        </trans-unit>
        <trans-unit id="a511380c7d51e6b8aa92a6d9dbd7dd96985267fc" translate="yes" xml:space="preserve">
          <source>Note that like the native &lt;code&gt;Array.every&lt;/code&gt;, &lt;code&gt;isEvery&lt;/code&gt; will return true when called on any empty enumerable.</source>
          <target state="translated">请注意，就像本机 &lt;code&gt;Array.every&lt;/code&gt; 一样，在对任何空可枚举调用时， &lt;code&gt;isEvery&lt;/code&gt; 将返回true。</target>
        </trans-unit>
        <trans-unit id="3cbb28c77f6e351fc1928e6220e782dc362a1b2a" translate="yes" xml:space="preserve">
          <source>Note that mixins extend a constructor's prototype so arrays and object literals defined as properties will be shared amongst objects that implement the mixin. If you want to define a property in a mixin that is not shared, you can define it either as a computed property or have it be created on initialization of the object.</source>
          <target state="translated">请注意,mixins 扩展了构造函数的原型,因此定义为属性的数组和对象字元将在实现 mixin 的对象中共享。如果你想在 mixin 中定义一个不共享的属性,你可以把它定义为一个计算属性,或者在对象初始化时创建它。</target>
        </trans-unit>
        <trans-unit id="e0915ee7945263956963defb8eed8d82042531b8" translate="yes" xml:space="preserve">
          <source>Note that ordering only applies to initializers of the same type (i.e. application or application instance). Application initializers will always run before application instance initializers.</source>
          <target state="translated">请注意,排序只适用于相同类型(即应用程序或应用程序实例)的初始化器。应用程序初始化器将始终在应用程序实例初始化器之前运行。</target>
        </trans-unit>
        <trans-unit id="a01853252476693e8ba50c063c6d95f4b2768ee1" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;admin&lt;/code&gt; is now not included in the payload.</source>
          <target state="translated">请注意，现在 &lt;code&gt;admin&lt;/code&gt; 不包含在有效负载中。</target>
        </trans-unit>
        <trans-unit id="e181bf43f632a621775995506d04b89a64308a3a" translate="yes" xml:space="preserve">
          <source>Note that the Ember.Array mixin also incorporates the &lt;code&gt;Ember.Enumerable&lt;/code&gt; mixin. All &lt;code&gt;Ember.Array&lt;/code&gt;-like objects are also enumerable.</source>
          <target state="translated">请注意，Ember.Array混合也合并了 &lt;code&gt;Ember.Enumerable&lt;/code&gt; 混合。所有 &lt;code&gt;Ember.Array&lt;/code&gt; 的对象也是可枚举的。</target>
        </trans-unit>
        <trans-unit id="464a4e1a39f9e9d238321f795ebad418f97d241c" translate="yes" xml:space="preserve">
          <source>Note that the hash is an empty object with no prototype chain, therefore common methods like &lt;code&gt;toString&lt;/code&gt; are not available in the resulting hash. If you need to use such a method, you can use the &lt;code&gt;call&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt; approach:</source>
          <target state="translated">请注意，哈希是一个没有原型链的空对象，因此像 &lt;code&gt;toString&lt;/code&gt; 这样的通用方法在生成的哈希中不可用。如果需要使用这种方法，可以使用 &lt;code&gt;call&lt;/code&gt; 或 &lt;code&gt;apply&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="fc9566b0898e72178820bea560bb816fc27b12cd" translate="yes" xml:space="preserve">
          <source>Note that the object root can be pluralized for both a single-object response and an array response: the REST adapter is not strict on this. Further, if the HTTP server responds to a &lt;code&gt;GET&lt;/code&gt; request to &lt;code&gt;/posts/1&lt;/code&gt; (e.g. the response to a &lt;code&gt;findRecord&lt;/code&gt; query) with more than one object in the array, Ember Data will only display the object with the matching ID.</source>
          <target state="translated">请注意，对于单对象响应和数组响应，对象根可以是复数的：REST适配器对此并不严格。此外，如果HTTP服务器使用数组中的多个对象响应对 &lt;code&gt;/posts/1&lt;/code&gt; 的 &lt;code&gt;GET&lt;/code&gt; 请求（例如，对 &lt;code&gt;findRecord&lt;/code&gt; 查询的响应），则Ember Data将仅显示具有匹配ID的对象。</target>
        </trans-unit>
        <trans-unit id="7279e9a3c8ff0311e3ca69d4c929ddaff389ce17" translate="yes" xml:space="preserve">
          <source>Note that the type is &lt;code&gt;&quot;post&quot;&lt;/code&gt; to match the post model and the &lt;code&gt;relatedPosts&lt;/code&gt; relationship in the document matches the &lt;code&gt;relatedPosts: hasMany('post')&lt;/code&gt; on the model.</source>
          <target state="translated">请注意，该类型是 &lt;code&gt;&quot;post&quot;&lt;/code&gt; 相匹配的岗位模型和 &lt;code&gt;relatedPosts&lt;/code&gt; 文档中关系相匹配的 &lt;code&gt;relatedPosts: hasMany('post')&lt;/code&gt; 的模型。</target>
        </trans-unit>
        <trans-unit id="651d898d00f66933a50a90cbb6374067806121e6" translate="yes" xml:space="preserve">
          <source>Note that there are often alternatives to using &lt;code&gt;run.next&lt;/code&gt;. For instance, if you'd like to schedule an operation to happen after all DOM element operations have completed within the current run loop, you can make use of the &lt;code&gt;afterRender&lt;/code&gt; run loop queue (added by the &lt;code&gt;ember-views&lt;/code&gt; package, along with the preceding &lt;code&gt;render&lt;/code&gt; queue where all the DOM element operations happen).</source>
          <target state="translated">请注意，通常可以使用 &lt;code&gt;run.next&lt;/code&gt; 替代方法。例如，如果您希望安排在当前运行循环中所有DOM元素操作完成之后执行操作，则可以使用 &lt;code&gt;afterRender&lt;/code&gt; 运行循环队列（由 &lt;code&gt;ember-views&lt;/code&gt; 程序包添加，以及前面的发生所有DOM元素操作的 &lt;code&gt;render&lt;/code&gt; 队列）。</target>
        </trans-unit>
        <trans-unit id="378ebd8cb4393b5003287ca8dc8a822623b4efce" translate="yes" xml:space="preserve">
          <source>Note that this use of &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; is unrelated to the &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; that is defined as an option on &lt;code&gt;DS.attr&lt;/code&gt; as part of defining a model while working with the &lt;code&gt;ActiveModelSerializer&lt;/code&gt;. Nevertheless, using &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; as an option to &lt;code&gt;DS.attr&lt;/code&gt; is not a valid way to setup embedded records.</source>
          <target state="translated">请注意，这个使用 &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; 是毫无关系的 &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; 被定义为上的一个选项 &lt;code&gt;DS.attr&lt;/code&gt; 作为定义模型与工作时的一部分 &lt;code&gt;ActiveModelSerializer&lt;/code&gt; 。但是，使用 &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; 作为 &lt;code&gt;DS.attr&lt;/code&gt; 的选项不是设置嵌入式记录的有效方法。</target>
        </trans-unit>
        <trans-unit id="f0d39521c8d3386b3a34e9ced91037feeb0a7b2a" translate="yes" xml:space="preserve">
          <source>Note that this will cause &lt;code&gt;model&lt;/code&gt; hooks to fire even on routes that were provided a model object when the route was initially entered.</source>
          <target state="translated">请注意，这将甚至在最初输入路径时为模型对象提供的路径上触发 &lt;code&gt;model&lt;/code&gt; 挂钩。</target>
        </trans-unit>
        <trans-unit id="3ad6b52ecb990cca8134262cdb224e497f1a00b0" translate="yes" xml:space="preserve">
          <source>Note that unlike the other methods, this method does not allow you to pass a target object to set as this for the callback. It's part of the spec. Sorry.</source>
          <target state="translated">请注意,与其他方法不同的是,这个方法不允许你传递一个目标对象作为回调的设置。这是规范的一部分。对不起,我不知道。</target>
        </trans-unit>
        <trans-unit id="eb8695c270f1bbdd1d483514b31345a7b00a6573" translate="yes" xml:space="preserve">
          <source>Note that we've changed the title from a hard-coded string (&quot;List of Scientists&quot;) to a dynamic property (&lt;code&gt;{{title}}&lt;/code&gt;). We've also renamed &lt;code&gt;scientist&lt;/code&gt; to the more-generic &lt;code&gt;person&lt;/code&gt;, decreasing the coupling of our component to where it's used.</source>
          <target state="translated">请注意，我们已将标题从硬编码字符串（&amp;ldquo;科学家名单&amp;rdquo;）更改为动态属性（ &lt;code&gt;{{title}}&lt;/code&gt; ）。我们还将 &lt;code&gt;scientist&lt;/code&gt; 重命名为更普通的 &lt;code&gt;person&lt;/code&gt; ，从而减少了组件与使用位置之间的耦合。</target>
        </trans-unit>
        <trans-unit id="b5bce60538daed2815d21c307bbe23abc78831ea" translate="yes" xml:space="preserve">
          <source>Note that you cannot use &lt;code&gt;attr&lt;/code&gt; to define an attribute of &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">请注意，您不能使用 &lt;code&gt;attr&lt;/code&gt; 定义 &lt;code&gt;id&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="7bb46a8ed0ed5ba9c5b246982b813cc010e7976e" translate="yes" xml:space="preserve">
          <source>Note that you will not generally apply this mixin to classes yourself, but you will use the features provided by this module frequently, so it is important to understand how to use it.</source>
          <target state="translated">需要注意的是,一般情况下自己不会将这个mixin应用到类中,但会经常使用这个模块提供的功能,所以了解如何使用它很重要。</target>
        </trans-unit>
        <trans-unit id="b0597a69e13b4e14adaa25db22b7f0f4898ba79d" translate="yes" xml:space="preserve">
          <source>Note that, for polymorphism to work, Ember Data expects a &quot;type&quot; declaration polymorphic type via the reserved &lt;code&gt;type&lt;/code&gt; property on the model. Confused? See the API response below.</source>
          <target state="translated">请注意，为了使多态性起作用，Ember Data希望通过模型上的保留 &lt;code&gt;type&lt;/code&gt; 属性来实现&amp;ldquo;类型&amp;rdquo;声明多态性类型。困惑？请参阅下面的API响应。</target>
        </trans-unit>
        <trans-unit id="e1de6c308dc4f6fc162197eb2bbe65e4c36374d2" translate="yes" xml:space="preserve">
          <source>Note that, with default settings, &lt;code&gt;shouldBackgroundReloadAll&lt;/code&gt; will always re-fetch all the records in the background even if &lt;code&gt;shouldReloadAll&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. You can override &lt;code&gt;shouldBackgroundReloadAll&lt;/code&gt; if this does not suit your use case.</source>
          <target state="translated">请注意，使用默认设置，即使 &lt;code&gt;shouldReloadAll&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;shouldBackgroundReloadAll&lt;/code&gt; 将始终在后台重新获取所有记录。如果这不适合您的用例，则可以覆盖 &lt;code&gt;shouldBackgroundReloadAll&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d35e47cdfb2862962cfbd80e030c1179e5271e2" translate="yes" xml:space="preserve">
          <source>Note that, with default settings, &lt;code&gt;shouldBackgroundReloadRecord&lt;/code&gt; will always re-fetch the records in the background even if &lt;code&gt;shouldReloadRecord&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. You can override &lt;code&gt;shouldBackgroundReloadRecord&lt;/code&gt; if this does not suit your use case.</source>
          <target state="translated">请注意，使用默认设置，即使 &lt;code&gt;shouldReloadRecord&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;shouldBackgroundReloadRecord&lt;/code&gt; 将始终在后台重新获取记录。如果这不适合您的用例，则可以覆盖 &lt;code&gt;shouldBackgroundReloadRecord&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e7b0d071a0586986d448b602cae0e1b1e36d11b" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;defaultSerializer&lt;/code&gt; serializer has a lower priority than a model specific serializer (i.e. &lt;code&gt;PostSerializer&lt;/code&gt;) or the &lt;code&gt;application&lt;/code&gt; serializer.</source>
          <target state="translated">请注意， &lt;code&gt;defaultSerializer&lt;/code&gt; 序列化程序的优先级低于特定于模型的序列化程序（即 &lt;code&gt;PostSerializer&lt;/code&gt; ）或 &lt;code&gt;application&lt;/code&gt; 序列化程序。</target>
        </trans-unit>
        <trans-unit id="ba6d28dc5630809cf305ce67605b5bd4a3c6f88f" translate="yes" xml:space="preserve">
          <source>Note: A route with a dynamic segment will always have its &lt;code&gt;model&lt;/code&gt; hook called when it is entered via the URL. If the route is entered through a transition (e.g. when using the &lt;a href=&quot;https://guides.emberjs.com/templates/links&quot;&gt;link-to&lt;/a&gt; Handlebars helper), and a model context is provided (second argument to &lt;code&gt;link-to&lt;/code&gt;), then the hook is not executed. If an identifier (such as an id or slug) is provided instead then the model hook will be executed.</source>
          <target state="translated">注意：具有动态路段的路线在通过URL输入时始终会调用其 &lt;code&gt;model&lt;/code&gt; 挂钩。如果通过转换输入了路由（例如，当使用&lt;a href=&quot;https://guides.emberjs.com/templates/links&quot;&gt;链接至&lt;/a&gt; Handlebars帮助器时），并且提供了模型上下文（ &lt;code&gt;link-to&lt;/code&gt; 的第二个参数），则不会执行该挂钩。如果提供了标识符（例如id或slug），则将执行模型挂钩。</target>
        </trans-unit>
        <trans-unit id="3702f2df2efc5cbf72a1cc1e1abb9bfc0930161f" translate="yes" xml:space="preserve">
          <source>Note: Although an &lt;code&gt;Application&lt;/code&gt; serves as the primary registry for an app, each &lt;code&gt;ApplicationInstance&lt;/code&gt; can also serve as a registry. Instance-level registrations are useful for providing instance-level customizations, such as A/B testing of a feature.</source>
          <target state="translated">注意：尽管 &lt;code&gt;Application&lt;/code&gt; 充当应用程序的主要注册表，但是每个 &lt;code&gt;ApplicationInstance&lt;/code&gt; 也可以充当注册表。实例级注册对于提供实例级自定义（例如功能的A / B测试）很有用。</target>
        </trans-unit>
        <trans-unit id="4ecc03da2a0a560ac7c30c7b597fc46f4cada8d2" translate="yes" xml:space="preserve">
          <source>Note: If using ember-cli, this value is defaulted to &lt;code&gt;auto&lt;/code&gt; by the &lt;code&gt;locationType&lt;/code&gt; setting of &lt;code&gt;/config/environment.js&lt;/code&gt;</source>
          <target state="translated">注意：如果使用ember-cli，则 &lt;code&gt;/config/environment.js&lt;/code&gt; 的 &lt;code&gt;locationType&lt;/code&gt; 设置会将此值默认为 &lt;code&gt;auto&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4f5b5d130fcc7f35759471b87f796a64ba0bf18" translate="yes" xml:space="preserve">
          <source>Note: Requests coalescing rely on URL building strategy. So if you override &lt;code&gt;buildURL&lt;/code&gt; in your app &lt;code&gt;groupRecordsForFindMany&lt;/code&gt; more likely should be overridden as well in order for coalescing to work.</source>
          <target state="translated">注意：请求合并依赖于URL构建策略。因此，如果您在应用程序 &lt;code&gt;groupRecordsForFindMany&lt;/code&gt; 覆盖了 &lt;code&gt;buildURL&lt;/code&gt; ，则也有可能也应该覆盖它们，以便合并工作。</target>
        </trans-unit>
        <trans-unit id="855ed88d13b422515a3bdb028bbb0822265999aa" translate="yes" xml:space="preserve">
          <source>Note: When creating a new record using any of the above methods Ember Data will update &lt;code&gt;DS.RecordArray&lt;/code&gt;s such as those returned by &lt;code&gt;store#peekAll()&lt;/code&gt; or &lt;code&gt;store#findAll()&lt;/code&gt;. This means any data bindings or computed properties that depend on the RecordArray will automatically be synced to include the new or updated record values.</source>
          <target state="translated">注意：使用上述任何一种方法创建新记录时，Ember Data都会更新 &lt;code&gt;DS.RecordArray&lt;/code&gt; ,例如 &lt;code&gt;store#peekAll()&lt;/code&gt; 或 &lt;code&gt;store#findAll()&lt;/code&gt; 返回的那些记录。这意味着依赖于RecordArray的所有数据绑定或计算的属性都将自动同步以包括新的或更新的记录值。</target>
        </trans-unit>
        <trans-unit id="6ce211ff969df1a3d4d36731e89acfcb795675c6" translate="yes" xml:space="preserve">
          <source>Note: the primary use case for &lt;code&gt;store.queryRecord&lt;/code&gt; is when a single record is queried and the &lt;code&gt;id&lt;/code&gt; is not known beforehand. In all other cases &lt;code&gt;store.query&lt;/code&gt; and using the first item of the array is likely the preferred way:</source>
          <target state="translated">注意： &lt;code&gt;store.queryRecord&lt;/code&gt; 的主要用例是查询单个记录并且事先不知道 &lt;code&gt;id&lt;/code&gt; 。在所有其他情况下， &lt;code&gt;store.query&lt;/code&gt; 并使用数组的第一项可能是首选方式：</target>
        </trans-unit>
        <trans-unit id="4ac43534a384c67ff6a3d194bed22cd1673c95c8" translate="yes" xml:space="preserve">
          <source>Notice that below we &quot;wrap&quot; our rentals markup inside the open and closing mentions of &lt;code&gt;list-filter&lt;/code&gt; on lines 12 and 20. This is an example of the &lt;a href=&quot;https://guides.emberjs.com/components/wrapping-content-in-a-component&quot;&gt;&lt;strong&gt;block form&lt;/strong&gt;&lt;/a&gt; of a component, which allows a Handlebars template to be rendered &lt;em&gt;inside&lt;/em&gt; the component's template wherever the &lt;code&gt;{{yield}}&lt;/code&gt; expression appears.</source>
          <target state="translated">请注意，下面我们在第12行和第20行的 &lt;code&gt;list-filter&lt;/code&gt; 开头和结尾处&amp;ldquo;包装&amp;rdquo;了我们的租金标记。这是组件的&lt;a href=&quot;https://guides.emberjs.com/components/wrapping-content-in-a-component&quot;&gt;&lt;strong&gt;块形式&lt;/strong&gt;&lt;/a&gt;的示例，它允许将Handlebars模板呈现&lt;em&gt;在&lt;/em&gt;组件的模板中的任何地方 &lt;code&gt;{{yield}}&lt;/code&gt; 表达出现。</target>
        </trans-unit>
        <trans-unit id="ba2989c0bbd0d56ad53f312f0472d002b5558820" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;positionalParams&lt;/code&gt; property is added to the class as a static variable via &lt;code&gt;reopenClass&lt;/code&gt;. Positional params are always declared on the component class and cannot be changed while an application runs.</source>
          <target state="translated">请注意， &lt;code&gt;positionalParams&lt;/code&gt; 属性通过 &lt;code&gt;reopenClass&lt;/code&gt; 作为静态变量添加到类中。位置参数始终在组件类上声明，并且在应用程序运行时无法更改。</target>
        </trans-unit>
        <trans-unit id="22e1e0dd72c3b66a39bb942d9e6c86134bfd19d0" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;then&lt;/code&gt; function called on the result of calling the &lt;code&gt;filter&lt;/code&gt; function. The code expects the &lt;code&gt;filter&lt;/code&gt; function to return a promise. A &lt;a href=&quot;http://emberjs.com/api/classes/RSVP.Promise.html&quot;&gt;promise&lt;/a&gt; is a JavaScript object that represents the result of an asynchronous function. A promise may or may not be executed at the time you receive it. To account for this, it provides functions, like &lt;code&gt;then&lt;/code&gt; that let you give it code it will run when it eventually does receive a result.</source>
          <target state="translated">注意在调用 &lt;code&gt;filter&lt;/code&gt; 函数的结果上调用了 &lt;code&gt;then&lt;/code&gt; 函数。该代码期望 &lt;code&gt;filter&lt;/code&gt; 函数返回一个Promise。甲&lt;a href=&quot;http://emberjs.com/api/classes/RSVP.Promise.html&quot;&gt;诺&lt;/a&gt;是JavaScript对象，它表示一个异步函数的结果。收到承诺时，承诺可能会也可能不会执行。为了解决这个问题，它提供了一些功能，就像 &lt;code&gt;then&lt;/code&gt; ，您可以给它提供代码，使其最终收到结果时将运行。</target>
        </trans-unit>
        <trans-unit id="9730ce26ccf4f5b2837b3367e2458b83d31d5800" translate="yes" xml:space="preserve">
          <source>Now a malicious user simply needs to set their &lt;code&gt;firstName&lt;/code&gt; to a string containing HTML (like a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag that sends private customer data to their server, for example) and every user in that chat room has been compromised.</source>
          <target state="translated">现在，恶意用户只需将其 &lt;code&gt;firstName&lt;/code&gt; 设置为包含HTML的字符串（例如，将私人客户数据发送到其服务器的 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记），该聊天室中的每个用户都将受到危害。</target>
        </trans-unit>
        <trans-unit id="aed6bbb86311e08883196ef682fc7e18211c1a0d" translate="yes" xml:space="preserve">
          <source>Now both integration test scenarios should pass. You can verify this by starting up our test suite by typing &lt;code&gt;ember t -s&lt;/code&gt; at the command line.</source>
          <target state="translated">现在，两个集成测试方案都应该通过。您可以通过在命令行中键入 &lt;code&gt;ember t -s&lt;/code&gt; 来启动测试套件来验证这一点。</target>
        </trans-unit>
        <trans-unit id="f599c9023b4f51e1268c2391d3d70cb4d82d8142" translate="yes" xml:space="preserve">
          <source>Now browse to &lt;code&gt;localhost:4200/rentals/grand-old-mansion&lt;/code&gt; and you should see the information listed for that specific rental.</source>
          <target state="translated">现在浏览到 &lt;code&gt;localhost:4200/rentals/grand-old-mansion&lt;/code&gt; ，您应该看到列出的有关该特定租金的信息。</target>
        </trans-unit>
        <trans-unit id="3c097506f308ce3211348990a741b341f9e9c584" translate="yes" xml:space="preserve">
          <source>Now imagine we have the following template and route:</source>
          <target state="translated">现在想象一下,我们有以下模板和路线。</target>
        </trans-unit>
        <trans-unit id="f2091523f465fab3ba86b01fc47f04eb9b8fc8b8" translate="yes" xml:space="preserve">
          <source>Now implement the service as follows. Note that we check if a map already exists for the given location and use that one, otherwise we call a Google Maps utility to create one.</source>
          <target state="translated">现在实现服务如下。请注意,我们检查给定位置是否已经存在地图,并使用该地图,否则我们调用谷歌地图工具来创建一个地图。</target>
        </trans-unit>
        <trans-unit id="d5f166005bc10a443ff98a919b8aa3d2fcc4e964" translate="yes" xml:space="preserve">
          <source>Now in our &lt;code&gt;rentals.hbs&lt;/code&gt; template, let's replace the old HTML markup within our &lt;code&gt;{{#each}}&lt;/code&gt; loop with our new &lt;code&gt;rental-listing&lt;/code&gt; component:</source>
          <target state="translated">现在，在我们的 &lt;code&gt;rentals.hbs&lt;/code&gt; 模板中，让我们用新的 &lt;code&gt;rental-listing&lt;/code&gt; 组件替换 &lt;code&gt;{{#each}}&lt;/code&gt; 循环中的旧HTML标记：</target>
        </trans-unit>
        <trans-unit id="fa74a5445ac21a141ea80fae8c137247dd31ba9d" translate="yes" xml:space="preserve">
          <source>Now in our browser we should see that the first rental property is listed as &quot;Standalone&quot;, while the other two are listed as &quot;Community&quot;.</source>
          <target state="translated">现在在我们的浏览器中,我们应该看到第一个出租房源被列为 &quot;独立&quot;,而其他两个房源被列为 &quot;社区&quot;。</target>
        </trans-unit>
        <trans-unit id="02f78c37e1d7493e21b1b94978d032932bbcb8df" translate="yes" xml:space="preserve">
          <source>Now in the browser when a scientist's name is clicked, this function is called and the person's name is alerted.</source>
          <target state="translated">现在在浏览器中,当一个科学家的名字被点击时,这个功能就会被调用,并提醒这个人的名字。</target>
        </trans-unit>
        <trans-unit id="ed29b70e455c078562a5f430d4dbd6281287bd7b" translate="yes" xml:space="preserve">
          <source>Now let's add code that simulates a visitor arriving on our homepage, clicking one of our links and then visiting a new page.</source>
          <target state="translated">现在,让我们添加代码,模拟访问者到达我们的主页,点击我们的一个链接,然后访问一个新的页面。</target>
        </trans-unit>
        <trans-unit id="c09d33d498277510cb65c5bde600e541b65944ec" translate="yes" xml:space="preserve">
          <source>Now let's create a test which will call &lt;code&gt;levelUp&lt;/code&gt; on the player when they are level 4 to assert that the &lt;code&gt;levelName&lt;/code&gt; changes. We will use &lt;code&gt;moduleForModel&lt;/code&gt;:</source>
          <target state="translated">现在让我们创建一个测试，该测试将在播放器达到4级时在播放器上调用 &lt;code&gt;levelUp&lt;/code&gt; ，以断言 &lt;code&gt;levelName&lt;/code&gt; 发生了变化。我们将使用 &lt;code&gt;moduleForModel&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="37fd2a1099f983eece52ae774c4e471341b866db" translate="yes" xml:space="preserve">
          <source>Now let's create another route with contact details for the company. Once again, we'll start by generating a route:</source>
          <target state="translated">现在让我们创建另一条包含公司联系方式的路线。再一次,我们将从生成一条路线开始。</target>
        </trans-unit>
        <trans-unit id="311e7c28de846f6b4798420c4a5a9e440da7f54c" translate="yes" xml:space="preserve">
          <source>Now let's render our component using the &lt;code&gt;render&lt;/code&gt; function. The &lt;code&gt;render&lt;/code&gt; function allows us to pass a template string, so that we can declare the component in the same way we do in our templates. Since we set the &lt;code&gt;rentalObj&lt;/code&gt; variable to our local scope, we can access it as part of our render string.</source>
          <target state="translated">现在，让我们使用 &lt;code&gt;render&lt;/code&gt; 函数来渲染我们的组件。该 &lt;code&gt;render&lt;/code&gt; 功能可以让我们通过一个模板字符串，这样我们就可以在我们在我们的模板做同样的方式宣布该组件。由于我们将 &lt;code&gt;rentalObj&lt;/code&gt; 变量设置为本地范围，因此我们可以将其作为渲染字符串的一部分进行访问。</target>
        </trans-unit>
        <trans-unit id="ae22d53ed6893c6b12aeed6c790fd45587cc8f49" translate="yes" xml:space="preserve">
          <source>Now let's tell Ember how to turn that array of strings into HTML. Open the &lt;code&gt;scientists&lt;/code&gt; template and add the following code to loop through the array and print it:</source>
          <target state="translated">现在，让我们告诉Ember如何将字符串数组转换为HTML。打开 &lt;code&gt;scientists&lt;/code&gt; 模板，并添加以下代码以遍历数组并打印：</target>
        </trans-unit>
        <trans-unit id="7f913783707682a29aebe4955714ed5c947732a8" translate="yes" xml:space="preserve">
          <source>Now let's test that the map component is relying on our service to provide map elements.</source>
          <target state="translated">现在让我们测试一下地图组件是否依靠我们的服务来提供地图元素。</target>
        </trans-unit>
        <trans-unit id="96f7e41a4cd747d58701a050ee081913d14c9b5e" translate="yes" xml:space="preserve">
          <source>Now let's write a test that sets a property on our &lt;code&gt;post&lt;/code&gt; model in the &lt;code&gt;PostController&lt;/code&gt; that would be available on the &lt;code&gt;CommentsController&lt;/code&gt;.</source>
          <target state="translated">现在，让我们编写一个测试，在 &lt;code&gt;PostController&lt;/code&gt; 中的 &lt;code&gt;post&lt;/code&gt; 模型上设置一个属性，该属性将在 &lt;code&gt;CommentsController&lt;/code&gt; 上可用。</target>
        </trans-unit>
        <trans-unit id="c9f9ed10a2412df54c18588a43c8397490d4ba61" translate="yes" xml:space="preserve">
          <source>Now run &lt;code&gt;ember server&lt;/code&gt; (or &lt;code&gt;ember serve&lt;/code&gt;, or even &lt;code&gt;ember s&lt;/code&gt; for short) on your command line to start the Ember development server and then go to &lt;a href=&quot;http://localhost:4200/about&quot;&gt;&lt;code&gt;http://localhost:4200/about&lt;/code&gt;&lt;/a&gt; to see our new page in action!</source>
          <target state="translated">现在，在命令行上运行 &lt;code&gt;ember server&lt;/code&gt; （或 &lt;code&gt;ember serve&lt;/code&gt; ，或者甚至简称 &lt;code&gt;ember s&lt;/code&gt; ）以启动Ember开发服务器，然后转到&lt;a href=&quot;http://localhost:4200/about&quot;&gt; &lt;code&gt;http://localhost:4200/about&lt;/code&gt; &lt;/a&gt;来查看我们的新页面！</target>
        </trans-unit>
        <trans-unit id="84b050c16846a3214fdf9d603f7c5b69acbc94b6" translate="yes" xml:space="preserve">
          <source>Now run the tests by typing &lt;code&gt;ember test --server&lt;/code&gt; in the command line (or &lt;code&gt;ember t -s&lt;/code&gt; for short).</source>
          <target state="translated">现在，通过在命令行中键入 &lt;code&gt;ember test --server&lt;/code&gt; （或简称 &lt;code&gt;ember t -s&lt;/code&gt; ）来运行测试。</target>
        </trans-unit>
        <trans-unit id="34b197a6f48a8ab8f16c6e0063a35905a4b87cee" translate="yes" xml:space="preserve">
          <source>Now run your test suite with the CLI command, &lt;code&gt;ember test --server&lt;/code&gt;.</source>
          <target state="translated">现在，使用CLI命令 &lt;code&gt;ember test --server&lt;/code&gt; 运行测试套件。</target>
        </trans-unit>
        <trans-unit id="e32163bdf7a676f31ff681bf9c67e518f8ae20d2" translate="yes" xml:space="preserve">
          <source>Now that our API is ready to return individual rentals, we can generate our &lt;code&gt;show&lt;/code&gt; sub-route. Much like generating our &lt;code&gt;rentals&lt;/code&gt; route, we will use &lt;code&gt;ember g&lt;/code&gt; to create a nested route.</source>
          <target state="translated">现在我们的API已准备好退还个别租金，我们可以生成 &lt;code&gt;show&lt;/code&gt; 子路线了。就像生成我们的 &lt;code&gt;rentals&lt;/code&gt; 路线一样，我们将使用 &lt;code&gt;ember g&lt;/code&gt; 创建嵌套路线。</target>
        </trans-unit>
        <trans-unit id="390b956f83716b5d2b619a143ece53c88d58057b" translate="yes" xml:space="preserve">
          <source>Now that we are able to generate a map element, we will implement a maps service that will keep a reference to the Map object we create, and attach the map to an element in our application</source>
          <target state="translated">现在我们已经能够生成一个地图元素,我们将实现一个地图服务,该服务将保留对我们创建的地图对象的引用,并将地图附加到应用程序中的一个元素上。</target>
        </trans-unit>
        <trans-unit id="e29152200d11c3493e21bf49ce8fe2f07316838b" translate="yes" xml:space="preserve">
          <source>Now that we are returning all of our rentals to the nested route's model, we will also move the rental list markup from our main route template to our nested route index template.</source>
          <target state="translated">现在,我们将所有的租赁返回到嵌套路由的模型中,我们还将把主路由模板中的租赁列表标记移到嵌套路由索引模板中。</target>
        </trans-unit>
        <trans-unit id="74ca8a47289101b4d71bc8a893d38054ad494e17" translate="yes" xml:space="preserve">
          <source>Now that we can load pages for individual rentals, we'll add a link (using the &lt;code&gt;link-to&lt;/code&gt; helper) within our &lt;code&gt;rental-listing&lt;/code&gt; component to navigate to individual pages. Here, the &lt;code&gt;link-to&lt;/code&gt; helper takes the route name and the rental model object as arguments. When you pass an object as second argument into the &lt;code&gt;link-to&lt;/code&gt; block helper, it will by default &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_serialize&quot;&gt;serialize&lt;/a&gt; the object to the ID of the model into the URL. Alternately, you may just pass &lt;code&gt;rental.id&lt;/code&gt; for clarity.</source>
          <target state="translated">现在我们可以加载单个租赁的页面，我们将在 &lt;code&gt;rental-listing&lt;/code&gt; 组件内添加一个链接（使用 &lt;code&gt;link-to&lt;/code&gt; 帮助器）以导航到单个页面。在此， &lt;code&gt;link-to&lt;/code&gt; 帮助程序将路径名称和租赁模型对象作为参数。当您将对象作为第二个参数传递到 &lt;code&gt;link-to&lt;/code&gt; 块帮助器时，默认情况下，它将对象&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_serialize&quot;&gt;序列化为&lt;/a&gt; URL的模型ID。另外，为清晰起见，您也可以传递 &lt;code&gt;rental.id&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f51bc732dd5d0541e4168611797a812b626f2f08" translate="yes" xml:space="preserve">
          <source>Now that we have the maps API available to the application, we can create our map utility. Utility files can be generated using Ember CLI.</source>
          <target state="translated">现在我们已经将地图API提供给应用程序,我们可以创建我们的地图实用程序。实用程序文件可以使用Ember CLI生成。</target>
        </trans-unit>
        <trans-unit id="a4e52876f40ef26dc44f65cd5da56d10b2128afb" translate="yes" xml:space="preserve">
          <source>Now that we have various pages in our application, let's walk through how to build tests for them.</source>
          <target state="translated">现在,我们的应用程序中已经有了各种页面,让我们来看看如何为它们构建测试。</target>
        </trans-unit>
        <trans-unit id="6188cec92e3b92a3cd3573bff0b61954c555c273" translate="yes" xml:space="preserve">
          <source>Now that we've created a new component for filtering a list, we want to create a test to verify it. Let's use a &lt;a href=&quot;https://guides.emberjs.com/testing/testing-components&quot;&gt;component integration test&lt;/a&gt; to verify our component behavior, similar to &lt;a href=&quot;../simple-component#toc_an-integration-test&quot;&gt;how we tested our rental listing component earlier&lt;/a&gt;.</source>
          <target state="translated">现在，我们已经创建了一个用于过滤列表的新组件，我们想创建一个测试来验证它。让我们使用&lt;a href=&quot;https://guides.emberjs.com/testing/testing-components&quot;&gt;组件集成测试&lt;/a&gt;来验证我们的组件行为，类似于&lt;a href=&quot;../simple-component#toc_an-integration-test&quot;&gt;我们之前测试出租列表组件的方式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22d276eb5319d347792a8180152b4cf12d2f8003" translate="yes" xml:space="preserve">
          <source>Now that we've got the &lt;code&gt;scientists&lt;/code&gt; template rendering, let's give it some data to render. We do that by specifying a &lt;em&gt;model&lt;/em&gt; for that route, and we can specify a model by editing &lt;code&gt;app/routes/scientists.js&lt;/code&gt;.</source>
          <target state="translated">现在我们已经完成了 &lt;code&gt;scientists&lt;/code&gt; 模板渲染，让我们为它提供一些数据进行渲染。我们通过为该路由指定&lt;em&gt;模型&lt;/em&gt;来做到这一点，并且可以通过编辑 &lt;code&gt;app/routes/scientists.js&lt;/code&gt; 来指定模型。</target>
        </trans-unit>
        <trans-unit id="409a5bf3323ebbf783bca40b618202511ed25e9c" translate="yes" xml:space="preserve">
          <source>Now that we've tested that the &lt;code&gt;list-filter&lt;/code&gt; component behaves as expected, let's test that the page itself also behaves properly with an acceptance test. We'll verify that a user visiting the rentals page can enter text into the search field and narrow the list of rentals by city.</source>
          <target state="translated">现在，我们已经测试了 &lt;code&gt;list-filter&lt;/code&gt; 组件的行为是否符合预期，让我们通过接受测试来测试页面本身是否也表现正常。我们将验证访问租赁页面的用户是否可以在搜索字段中输入文字，并按城市缩小租赁列表。</target>
        </trans-unit>
        <trans-unit id="e9f934b876c6d18b3147c025ed6401410b05147e" translate="yes" xml:space="preserve">
          <source>Now that we've written our application and verified that it works in development, it's time to get it ready to deploy to our users.</source>
          <target state="translated">现在,我们已经写好了我们的应用程序,并在开发中验证了它的工作,是时候让它准备好部署给我们的用户了。</target>
        </trans-unit>
        <trans-unit id="fb98077b823bffbec7d94fef2fd368d976bda3cd" translate="yes" xml:space="preserve">
          <source>Now the same template above renders the following HTML:</source>
          <target state="translated">现在,上面同样的模板渲染出以下HTML。</target>
        </trans-unit>
        <trans-unit id="751cdc42f9ac3dfa5f8f1d9e4ef15bfaddd5edf2" translate="yes" xml:space="preserve">
          <source>Now the value passed into the helper has its HTML escaped, but the trusted &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; tags that we want to wrap the value in are &lt;em&gt;not&lt;/em&gt; escaped. A malicious user setting their &lt;code&gt;firstName&lt;/code&gt; to something containing HTML would see this:</source>
          <target state="translated">现在，传递给帮助器的值已经转义了HTML，但是我们要包装值的受信任的 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 标记&lt;em&gt;未&lt;/em&gt;转义。将其 &lt;code&gt;firstName&lt;/code&gt; 设置为包含HTML 的内容的恶意用户将看到以下内容：</target>
        </trans-unit>
        <trans-unit id="8b6b5009f8b7a2901d3d319dd17092db9a1ed606" translate="yes" xml:space="preserve">
          <source>Now visiting the root route at &lt;code&gt;/&lt;/code&gt; will result in the &lt;code&gt;/rentals&lt;/code&gt; URL loading.</source>
          <target state="translated">现在访问 &lt;code&gt;/&lt;/code&gt; 处的根路由将导致 &lt;code&gt;/rentals&lt;/code&gt; URL加载。</target>
        </trans-unit>
        <trans-unit id="6c6c7e593ed0c850f3e8190fef9191b81f3e28da" translate="yes" xml:space="preserve">
          <source>Now we are listing rentals, and verifying it with an acceptance test. This leaves us with 2 remaining acceptance test failures (and 1 eslint failure):</source>
          <target state="translated">现在,我们正在列出租金,并通过验收测试进行验证。这样我们就剩下2次验收测试失败(和1次eslint失败)。</target>
        </trans-unit>
        <trans-unit id="7108a8b8c763bba0f7398042020329fed4eaf6cc" translate="yes" xml:space="preserve">
          <source>Now we can add functionality that will show the image of a rental when requested by the user.</source>
          <target state="translated">现在,我们可以添加功能,当用户请求时,将显示租赁的图像。</target>
        </trans-unit>
        <trans-unit id="bfa9210fe58ffde8b4dcc9ff4b51a5ca9f882a82" translate="yes" xml:space="preserve">
          <source>Now we can move on to an integration test. Integration testing helpers is done with the &lt;code&gt;moduleForComponent&lt;/code&gt; helpers, as shown in &lt;a href=&quot;../unit-testing-basics&quot;&gt;Testing Components&lt;/a&gt;.</source>
          <target state="translated">现在，我们可以继续进行集成测试。集成测试帮助程序由 &lt;code&gt;moduleForComponent&lt;/code&gt; 帮助程序完成，如&amp;ldquo; &lt;a href=&quot;../unit-testing-basics&quot;&gt;测试组件&amp;rdquo;中&lt;/a&gt;所示。</target>
        </trans-unit>
        <trans-unit id="4adfea733a9bf47405887104fee15db7d39c58a6" translate="yes" xml:space="preserve">
          <source>Now we need to define a computed property of our category-filtered array that the &lt;code&gt;articles&lt;/code&gt; template will render:</source>
          <target state="translated">现在，我们需要为 &lt;code&gt;articles&lt;/code&gt; 模板定义的类别过滤数组定义一个计算属性：</target>
        </trans-unit>
        <trans-unit id="54e5a7d11514449fe0aca845de95725d318042b5" translate="yes" xml:space="preserve">
          <source>Now we need to make it so that the &lt;code&gt;userDidDeleteAccount()&lt;/code&gt; action defined in the parent component &lt;code&gt;user-profile&lt;/code&gt; can be triggered from within &lt;code&gt;button-with-confirmation&lt;/code&gt;. We'll do this by passing the action to the child component in exactly the same way that we pass other properties. This is possible since actions are simply functions, just like any other method on a component, and they can therefore be passed from one component to another like this:</source>
          <target state="translated">现在我们需 &lt;code&gt;userDidDeleteAccount()&lt;/code&gt; ，以便可以从 &lt;code&gt;button-with-confirmation&lt;/code&gt; 内部触发在父组件 &lt;code&gt;user-profile&lt;/code&gt; 中定义的userDidDeleteAccount（）操作。我们将通过将操作传递给子组件来完成此操作，方法与传递其他属性完全相同。之所以可行是因为动作是简单的功能，就像组件上的任何其他方法一样，因此可以将它们从一个组件传递到另一个组件，如下所示：</target>
        </trans-unit>
        <trans-unit id="638d79b6dc710ae90d1be166135c3fd4850c0c22" translate="yes" xml:space="preserve">
          <source>Now we've implemented our action, but we have not told Ember when we want this action to be triggered, which is the next step.</source>
          <target state="translated">现在我们已经实现了我们的动作,但是我们还没有告诉Ember什么时候要触发这个动作,这是下一步。</target>
        </trans-unit>
        <trans-unit id="8266b5a5c3d0155af7d2420da1952fd4bf225240" translate="yes" xml:space="preserve">
          <source>Now when the &lt;code&gt;system-preferences-editor&lt;/code&gt; handles the delete action, it receives only the user's account &lt;code&gt;id&lt;/code&gt; string.</source>
          <target state="translated">现在，当 &lt;code&gt;system-preferences-editor&lt;/code&gt; 处理delete操作时，它仅接收用户的帐户 &lt;code&gt;id&lt;/code&gt; 字符串。</target>
        </trans-unit>
        <trans-unit id="24e0f7c85a3653f2f8783ca8850aaea9de98c648" translate="yes" xml:space="preserve">
          <source>Now when we click the image or the &lt;code&gt;View Larger&lt;/code&gt; link in our browser, we see our image show larger. When we click the enlarged image again, we see it smaller.</source>
          <target state="translated">现在，当我们单击图像或在浏览器中 &lt;code&gt;View Larger&lt;/code&gt; 链接时，我们看到的图像显示较大。当我们再次单击放大的图像时，会看到较小的图像。</target>
        </trans-unit>
        <trans-unit id="5d245f0aef23eeedd834fcade7b3ff3025ac6d19" translate="yes" xml:space="preserve">
          <source>Now when we go to &lt;a href=&quot;http://localhost:4200/contact&quot;&gt;&lt;code&gt;http://localhost:4200/contact&lt;/code&gt;&lt;/a&gt;, we'll see our contact page.</source>
          <target state="translated">现在，当我们转到&lt;a href=&quot;http://localhost:4200/contact&quot;&gt; &lt;code&gt;http://localhost:4200/contact&lt;/code&gt; 时&lt;/a&gt;，将看到我们的联系页面。</target>
        </trans-unit>
        <trans-unit id="ce9483b052b5784076ba5b335a0118e44ab1c9e9" translate="yes" xml:space="preserve">
          <source>Now when you confirm deletion, the action goes straight to the &lt;code&gt;system-preferences-editor&lt;/code&gt; to be handled in its local context.</source>
          <target state="translated">现在，当您确认删除时，操作将直接转到要在其本地上下文中处理的 &lt;code&gt;system-preferences-editor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61a8b0d0ff011a9764ca1ad939461500c43c3744" translate="yes" xml:space="preserve">
          <source>Now, define your new controller like so:</source>
          <target state="translated">现在,像这样定义你的新控制器。</target>
        </trans-unit>
        <trans-unit id="f4fd3bbdfb6ab9a0619b9f651b994843f728f190" translate="yes" xml:space="preserve">
          <source>Now, let's add a list of available rentals to the rentals page we've just created.</source>
          <target state="translated">现在,让我们在刚刚创建的租房页面中添加一个可用的租房列表。</target>
        </trans-unit>
        <trans-unit id="a53ad0647104e578d8de2040723dfe077ba174b5" translate="yes" xml:space="preserve">
          <source>Now, let's switch over to our rentals page template. We can use the model attribute to display our list of rentals. Here, we'll use another common Handlebars helper called &lt;a href=&quot;https://guides.emberjs.com/templates/displaying-a-list-of-items/&quot;&gt;&lt;code&gt;{{each}}&lt;/code&gt;&lt;/a&gt;. This helper will let us loop through each of the rental objects in our model:</source>
          <target state="translated">现在，让我们切换到租赁页面模板。我们可以使用model属性来显示我们的租金清单。在这里，我们将使用另一个名为&lt;a href=&quot;https://guides.emberjs.com/templates/displaying-a-list-of-items/&quot;&gt; &lt;code&gt;{{each}}&lt;/code&gt; 的&lt;/a&gt;常见Handlebars帮助器。该帮助程序将使我们遍历模型中的每个租赁对象：</target>
        </trans-unit>
        <trans-unit id="15795f7ce89f935cc441a35c4b6d01a3b8f097c4" translate="yes" xml:space="preserve">
          <source>Now, we can use &lt;code&gt;onConfirm&lt;/code&gt; in the child component to invoke the action on the parent:</source>
          <target state="translated">现在，我们可以在子组件中使用 &lt;code&gt;onConfirm&lt;/code&gt; 来调用父组件上的操作：</target>
        </trans-unit>
        <trans-unit id="e8a74da24790015ebe84e057ae755a540ac6ffaa" translate="yes" xml:space="preserve">
          <source>Now, we can use the &lt;code&gt;{{blog-post}}&lt;/code&gt; component and pass it properties in another template:</source>
          <target state="translated">现在，我们可以使用 &lt;code&gt;{{blog-post}}&lt;/code&gt; 组件并将其属性传递到另一个模板中：</target>
        </trans-unit>
        <trans-unit id="fdf62c9f4192c9e36113ca42781fc9263390a9ef" translate="yes" xml:space="preserve">
          <source>Now, we'll add our corresponding link to the contact page so we can move back and forth between &lt;code&gt;about&lt;/code&gt; and &lt;code&gt;contact&lt;/code&gt;:</source>
          <target state="translated">现在，我们将相应的链接添加到联系页面，以便我们可以在 &lt;code&gt;about&lt;/code&gt; 和 &lt;code&gt;contact&lt;/code&gt; 之间来回移动：</target>
        </trans-unit>
        <trans-unit id="6b6222fa9f13976ca7ad6beffaa5b6d82e8a9acf" translate="yes" xml:space="preserve">
          <source>Now, when the user visits &lt;code&gt;/about&lt;/code&gt;, Ember will render the &lt;code&gt;about&lt;/code&gt; template. Visiting &lt;code&gt;/favs&lt;/code&gt; will render the &lt;code&gt;favorites&lt;/code&gt; template.</source>
          <target state="translated">现在，当用户访问 &lt;code&gt;/about&lt;/code&gt; ，灰烬将使 &lt;code&gt;about&lt;/code&gt; 模板。访问 &lt;code&gt;/favs&lt;/code&gt; 将呈现 &lt;code&gt;favorites&lt;/code&gt; 模板。</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="88edc4776d403507658bee878ccdd72f1066d6fc" translate="yes" xml:space="preserve">
          <source>Number of elements that should be removed from the array, starting at *idx*.</source>
          <target state="translated">从*idx*开始,应该从数组中删除的元素数量。</target>
        </trans-unit>
        <trans-unit id="0da649b10044d0f71d7a6905e9b6d63659072ba9" translate="yes" xml:space="preserve">
          <source>Number of milliseconds to space out requests.</source>
          <target state="translated">请求间隔的毫秒数。</target>
        </trans-unit>
        <trans-unit id="76f886e5f43af44774fe994d2bf9d8f584ccf233" translate="yes" xml:space="preserve">
          <source>Number of milliseconds to wait.</source>
          <target state="translated">等待的毫秒数。</target>
        </trans-unit>
        <trans-unit id="c96f8cfa04b2401642b632ab99c696e7b056b4c9" translate="yes" xml:space="preserve">
          <source>Number|Property</source>
          <target state="translated">Number|Property</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="046bbc130ff7274f6d64607d913605fb2889bf35" translate="yes" xml:space="preserve">
          <source>Object Inspector</source>
          <target state="translated">对象检查员</target>
        </trans-unit>
        <trans-unit id="e1513401bdad97eeec26a0df3ad83cdcfa1ea677" translate="yes" xml:space="preserve">
          <source>Object Root</source>
          <target state="translated">对象根</target>
        </trans-unit>
        <trans-unit id="a7b77dbe50791d31096e5af54a26e5c31a19b936" translate="yes" xml:space="preserve">
          <source>Object containing values to use within the new class</source>
          <target state="translated">包含在新类中使用的值的对象</target>
        </trans-unit>
        <trans-unit id="6b304869b69598961a9d35b37c6fa6c60971f424" translate="yes" xml:space="preserve">
          <source>Object | DS.AdapterError</source>
          <target state="translated">对象--DS.AdapterError</target>
        </trans-unit>
        <trans-unit id="43710f2ae099d35ce837e6f0eaa732de92f07067" translate="yes" xml:space="preserve">
          <source>Object...</source>
          <target state="translated">Object...</target>
        </trans-unit>
        <trans-unit id="509eaa966f59106fc4885b0bd87f377320887ef2" translate="yes" xml:space="preserve">
          <source>ObjectProxy</source>
          <target state="translated">ObjectProxy</target>
        </trans-unit>
        <trans-unit id="b6ab519ee4828e64cb84e7da4b0494d126262ccd" translate="yes" xml:space="preserve">
          <source>Objects are considered Array-like if any of the following are true:</source>
          <target state="translated">如果以下任何一项为真,对象被认为是类阵列。</target>
        </trans-unit>
        <trans-unit id="1f91056b2f2c5a87fefcf8263cdce9940569716e" translate="yes" xml:space="preserve">
          <source>Objects in Ember</source>
          <target state="translated">微光中的物体</target>
        </trans-unit>
        <trans-unit id="ea0a98c632b2c1b78a2d3889fe6a012055812ca8" translate="yes" xml:space="preserve">
          <source>Object|Function</source>
          <target state="translated">Object|Function</target>
        </trans-unit>
        <trans-unit id="d9008046621fd4aa468204fcfd6ca159f07a8852" translate="yes" xml:space="preserve">
          <source>Object|Promise</source>
          <target state="translated">Object|Promise</target>
        </trans-unit>
        <trans-unit id="c231f0cfa191393d14a834365263558785e900ee" translate="yes" xml:space="preserve">
          <source>Object|String</source>
          <target state="translated">Object|String</target>
        </trans-unit>
        <trans-unit id="c92258fa87a7fd87bfb0eac39b2cad3876c1531d" translate="yes" xml:space="preserve">
          <source>Observable</source>
          <target state="translated">Observable</target>
        </trans-unit>
        <trans-unit id="307932fe3fc8a6a623482336122238a18d63c345" translate="yes" xml:space="preserve">
          <source>Observable Equivalent</source>
          <target state="translated">观测当量</target>
        </trans-unit>
        <trans-unit id="03ec7d08aec77b2156c9347f0082c5eed203b4e0" translate="yes" xml:space="preserve">
          <source>Observer Methods</source>
          <target state="translated">观察员方法</target>
        </trans-unit>
        <trans-unit id="20c17cb09007fd332a06112b65f303ed65335037" translate="yes" xml:space="preserve">
          <source>Observer methods have the following signature:</source>
          <target state="translated">观察员方法具有以下特征:</target>
        </trans-unit>
        <trans-unit id="0618a214d16e39be75c6315a11d086a7dcbea1b6" translate="yes" xml:space="preserve">
          <source>Observers</source>
          <target state="translated">Observers</target>
        </trans-unit>
        <trans-unit id="853a6ea1725e790242a53c8b71d88a3606114195" translate="yes" xml:space="preserve">
          <source>Observers / Binding</source>
          <target state="translated">观察员/装订</target>
        </trans-unit>
        <trans-unit id="0ba30584277e971c04f0d982aa5c093fa641ac6a" translate="yes" xml:space="preserve">
          <source>Observers and asynchrony</source>
          <target state="translated">观察员和异步</target>
        </trans-unit>
        <trans-unit id="dd121fa26be2df8672e845b1537510d9b314c5cd" translate="yes" xml:space="preserve">
          <source>Observers and object initialization</source>
          <target state="translated">观察员和对象初始化</target>
        </trans-unit>
        <trans-unit id="e736f6b09fdaa953337c6d536a1450f9f94c9a91" translate="yes" xml:space="preserve">
          <source>Observers are annotated using &lt;code&gt;Ember.observer()&lt;/code&gt;:</source>
          <target state="translated">观察者使用 &lt;code&gt;Ember.observer()&lt;/code&gt; 进行注释：</target>
        </trans-unit>
        <trans-unit id="3077946aa34d8ec8d2b52fd810a985c5b86ca007" translate="yes" xml:space="preserve">
          <source>Observers in Ember are currently synchronous. This means that they will fire as soon as one of the properties they observe changes. Because of this, it is easy to introduce bugs where properties are not yet synchronized:</source>
          <target state="translated">Ember中的观测器目前是同步的。这意味着,一旦他们观察到的一个属性发生变化,他们就会立即启动。正因为如此,在属性尚未同步的情况下,很容易引入错误。</target>
        </trans-unit>
        <trans-unit id="0dcd8db6908df157727f62893615213904a58453" translate="yes" xml:space="preserve">
          <source>Observers never fire until after the initialization of an object is complete.</source>
          <target state="translated">观察者直到对象的初始化完成后才会开火。</target>
        </trans-unit>
        <trans-unit id="f5999f9bc2923f92d05e5b16aa536ea236796646" translate="yes" xml:space="preserve">
          <source>Observers should contain behavior that reacts to changes in another property. Observers are especially useful when you need to perform some behavior after a binding has finished synchronizing.</source>
          <target state="translated">观察者应该包含对另一个属性的变化做出反应的行为。当你需要在绑定完成同步后执行一些行为时,观察者特别有用。</target>
        </trans-unit>
        <trans-unit id="2e48525b5f6912ad099b4ea5d21fef8fb5a4b87c" translate="yes" xml:space="preserve">
          <source>Observing Property Changes</source>
          <target state="translated">观察属性变化</target>
        </trans-unit>
        <trans-unit id="49abd5a03a91a7274230eb2dc93800125ce2b2dc" translate="yes" xml:space="preserve">
          <source>Occasionally you may want to prevent the app from initializing during setup. This could enable extra configuration, or enable asserting prior to the app becoming ready.</source>
          <target state="translated">偶尔您可能希望在设置期间阻止应用程序初始化。这可以启用额外的配置,或者在应用程序准备好之前启用断言。</target>
        </trans-unit>
        <trans-unit id="8ff2f4ac5135f40e96e90d7929e9e452ea04a10c" translate="yes" xml:space="preserve">
          <source>Often actions perform asynchronous tasks, such as making an ajax request to a server. Since actions are functions that can be passed in by a parent component, they are able to return values when called. The most common scenario is for an action to return a promise so that the component can handle the action's completion.</source>
          <target state="translated">通常情况下,动作会执行异步任务,比如向服务器发出ajax请求。由于action是可以由父组件传递进来的函数,所以它们在被调用时能够返回值。最常见的情况是让一个动作返回一个承诺,这样组件就可以处理动作的完成。</target>
        </trans-unit>
        <trans-unit id="89cb7859835dee6ef77b5791366871c69a2d100f" translate="yes" xml:space="preserve">
          <source>Often times, your components will just encapsulate certain snippets of Handlebars templates that you find yourself using over and over. In those cases, you do not need to write any JavaScript at all. Define the Handlebars template as described above and use the component that is created.</source>
          <target state="translated">很多时候,你的组件只是封装了某些你发现自己反复使用的Handlebars模板的片段。在这些情况下,你根本不需要编写任何JavaScript。如上所述定义Handlebars模板,并使用创建的组件。</target>
        </trans-unit>
        <trans-unit id="5aaf5caa5b49b93e7119e86a70d536ce6664ca8a" translate="yes" xml:space="preserve">
          <source>Often you'll want to have a template that displays inside another template. For example, in a blogging application, instead of going from a list of blog posts to creating a new post, you might want to have the post creation page display next to the list.</source>
          <target state="translated">通常你会希望有一个模板显示在另一个模板里面。例如,在一个博客应用程序中,你可能想让文章创建页面显示在列表旁边,而不是从博客文章列表转到创建新文章。</target>
        </trans-unit>
        <trans-unit id="62bb97c24abd34d344b7c7e101be577c8280b132" translate="yes" xml:space="preserve">
          <source>Often, interacting with a component will cause asynchronous behavior to occur, such as HTTP requests, or timers. The &lt;code&gt;wait&lt;/code&gt; helper is designed to handle these scenarios, by providing a hook to ensure assertions are made after all Ajax requests and timers are complete.</source>
          <target state="translated">通常，与组件交互将导致发生异步行为，例如HTTP请求或计时器。在 &lt;code&gt;wait&lt;/code&gt; 助手是专门用来处理这些情况下，通过提供一个挂钩，以确保断言是由毕竟Ajax请求和计时器完成。</target>
        </trans-unit>
        <trans-unit id="50ea8ddf844ede9c0ec44349c06ad04be2998925" translate="yes" xml:space="preserve">
          <source>Often, services connect to third party APIs that are not desirable to include in automated tests. To stub these services we simply have to register a stub service that implements the same API, but does not have the dependencies that are problematic for the test suite.</source>
          <target state="translated">通常情况下,服务会连接到第三方API,而这些API并不适合包含在自动化测试中。要对这些服务进行存根,我们只需要注册一个实现相同API的存根服务,但不存在对测试套件有问题的依赖关系。</target>
        </trans-unit>
        <trans-unit id="0ce500ec9eb2726f6b12a95aabe734c404cd89eb" translate="yes" xml:space="preserve">
          <source>Often, the relationships in Ember Data applications will have an inverse. For example, imagine the following models are defined:</source>
          <target state="translated">通常情况下,Ember Data应用中的关系会有一个反向关系。例如,想象定义了以下模型。</target>
        </trans-unit>
        <trans-unit id="c1f047d78b062689ec81f8220591ae2637824e50" translate="yes" xml:space="preserve">
          <source>Often, you'll want a template to display data from a model. Loading the appropriate model is one job of a route.</source>
          <target state="translated">通常情况下,你会想要一个模板来显示一个模型的数据。加载合适的模型是路由的一项工作。</target>
        </trans-unit>
        <trans-unit id="2c3ffdb1abb5aafa99ed88d09e01065a059a00a9" translate="yes" xml:space="preserve">
          <source>On Component Destroy</source>
          <target state="translated">销毁组件时</target>
        </trans-unit>
        <trans-unit id="7871fb44d093405668420a934d855c398825b852" translate="yes" xml:space="preserve">
          <source>On Initial Render</source>
          <target state="translated">初始渲染时</target>
        </trans-unit>
        <trans-unit id="3b81a353de54248fb63ae86d5a82b1a0e405029d" translate="yes" xml:space="preserve">
          <source>On Mac and Linux, you can improve file watching performance by installing &lt;a href=&quot;https://facebook.github.io/watchman/docs/install.html&quot;&gt;Watchman&lt;/a&gt;.</source>
          <target state="translated">在Mac和Linux上，您可以通过安装&lt;a href=&quot;https://facebook.github.io/watchman/docs/install.html&quot;&gt;Watchman&lt;/a&gt;来提高文件监视性能。</target>
        </trans-unit>
        <trans-unit id="58e13e632d3a342d5053b03478a93981c741b85e" translate="yes" xml:space="preserve">
          <source>On Re-Render</source>
          <target state="translated">在重新渲染时</target>
        </trans-unit>
        <trans-unit id="79702120c7c021f8b09ee1afda618cd0df787a69" translate="yes" xml:space="preserve">
          <source>On a belongsTo relationship:</source>
          <target state="translated">在一个 belongsTo关系上。</target>
        </trans-unit>
        <trans-unit id="eb43fdb147dc2a32fcd7a2f1655715ba70c1d257" translate="yes" xml:space="preserve">
          <source>On a class-based helper, it may be useful to force a recomputation of that helpers value. This is akin to &lt;code&gt;rerender&lt;/code&gt; on a component.</source>
          <target state="translated">在基于类的帮助程序上，强制重新计算该帮助程序的值可能会很有用。这类似于 &lt;code&gt;rerender&lt;/code&gt; 在组件上。</target>
        </trans-unit>
        <trans-unit id="6861bce269e523e12d7da65c6da77edffe736f32" translate="yes" xml:space="preserve">
          <source>On all newer browsers, you only need to use this method to retrieve properties if the property might not be defined on the object and you want to respect the &lt;code&gt;unknownProperty&lt;/code&gt; handler. Otherwise you can ignore this method.</source>
          <target state="translated">在所有较新的浏览器上，如果可能未在对象上定义属性并且您要遵守 &lt;code&gt;unknownProperty&lt;/code&gt; 处理程序，则仅需要使用此方法来检索属性。否则，您可以忽略此方法。</target>
        </trans-unit>
        <trans-unit id="aeba23ad12f082d9bc5f8ea964d08e7ff1c2466b" translate="yes" xml:space="preserve">
          <source>On an Apache server, the rewrite engine (mod-rewrite) must be enabled in order for Ember routing to work properly. If you upload your dist folder, going to your main URL works, but when you try to go to a route such as '{main URL}/example' and it returns 404, your server has not been configured for &quot;friendly&quot; URLs.</source>
          <target state="translated">在Apache服务器上,重写引擎(mod-rewrite)必须被启用才能使Ember路由正常工作。如果你上传了你的dist文件夹,进入你的主URL可以工作,但是当你尝试进入诸如'{main URL}/example'这样的路由时,它返回404,这说明你的服务器没有为 &quot;友好 &quot;的URL配置。</target>
        </trans-unit>
        <trans-unit id="a9188633f146f1828663d4971118211e9bc5e119" translate="yes" xml:space="preserve">
          <source>On each call to the &lt;code&gt;normalize&lt;/code&gt; method, the third parameter (&lt;code&gt;prop&lt;/code&gt;) is always one of the keys that were in the original payload or in the result of another normalization as &lt;code&gt;normalizeResponse&lt;/code&gt;.</source>
          <target state="translated">在每次对 &lt;code&gt;normalize&lt;/code&gt; 方法的调用时，第三个参数（ &lt;code&gt;prop&lt;/code&gt; ）始终是原始有效负载中的键之一，或者是另一个规范化结果 &lt;code&gt;normalizeResponse&lt;/code&gt; 的键之一。</target>
        </trans-unit>
        <trans-unit id="8c9c6f59e26d3f950eadfc25af534272ba19cb77" translate="yes" xml:space="preserve">
          <source>On success, the request promise will be resolved with the full response payload.</source>
          <target state="translated">成功后,请求承诺将用完整的响应有效载荷来解决。</target>
        </trans-unit>
        <trans-unit id="78f324f1e8f3f3b4f5bff5c1b66a78f5e0759ff5" translate="yes" xml:space="preserve">
          <source>On the left side of each Guides page is a table of contents, organized into sections that can be expanded to show the topics they cover. Both the sections and the topics within each section are ordered from basic to advanced concepts.</source>
          <target state="translated">每个指南页面的左侧是一个目录,按章节组织,可以扩展以显示所涵盖的主题。各节和各节中的主题都是按基本概念到高级概念排序的。</target>
        </trans-unit>
        <trans-unit id="e32c960456f9b43f9166f605a702a559006007ce" translate="yes" xml:space="preserve">
          <source>Once a factory is registered, it can be &quot;injected&quot; where it is needed.</source>
          <target state="translated">工厂注册后,就可以在需要的地方 &quot;注入&quot;。</target>
        </trans-unit>
        <trans-unit id="bdec5004fb5c33e3b2c477c863020702ae402501" translate="yes" xml:space="preserve">
          <source>Once injected into a component, a service can also be used in the template. Note &lt;code&gt;cart&lt;/code&gt; being used below to get data from the cart.</source>
          <target state="translated">一旦注入到组件中，服务也可以在模板中使用。注意 &lt;code&gt;cart&lt;/code&gt; 正下方用于从购物车中获取数据。</target>
        </trans-unit>
        <trans-unit id="ccee3bf08a6536ea2be6c885ed850fbb3a399af9" translate="yes" xml:space="preserve">
          <source>Once inside the &lt;code&gt;articles&lt;/code&gt; route, any changes to the &lt;code&gt;category&lt;/code&gt; property on &lt;code&gt;controller:articles&lt;/code&gt; will cause the URL to update the query param. By default, a query param property change won't cause a full router transition (i.e. it won't call &lt;code&gt;model&lt;/code&gt; hooks and &lt;code&gt;setupController&lt;/code&gt;, etc.); it will only update the URL.</source>
          <target state="translated">一旦进入 &lt;code&gt;articles&lt;/code&gt; 路由，对 &lt;code&gt;controller:articles&lt;/code&gt; 上 &lt;code&gt;category&lt;/code&gt; 属性的任何更改都将导致URL更新查询参数。默认情况下，查询参数属性更改不会导致路由器完全过渡（即，它不会调用 &lt;code&gt;model&lt;/code&gt; 钩子和 &lt;code&gt;setupController&lt;/code&gt; 等）；只会更新网址。</target>
        </trans-unit>
        <trans-unit id="457d77836a439fdff49c3b23b258781eb29f6526" translate="yes" xml:space="preserve">
          <source>Once installed, go to an Ember application, open the Developer Tools, and click on the &lt;code&gt;Ember&lt;/code&gt; tab at the far right.</source>
          <target state="translated">安装后，转到Ember应用程序，打开开发人员工具，然后单击最右边的 &lt;code&gt;Ember&lt;/code&gt; 选项卡。</target>
        </trans-unit>
        <trans-unit id="d4986dfc0d963c8eec63b7840ddbc1ff83a864a8" translate="yes" xml:space="preserve">
          <source>Once installed, go to an Ember application, open the Developer Tools, and click on the &lt;code&gt;Ember&lt;/code&gt; tab.</source>
          <target state="translated">安装后，转到Ember应用程序，打开开发人员工具，然后单击 &lt;code&gt;Ember&lt;/code&gt; 选项卡。</target>
        </trans-unit>
        <trans-unit id="164742e39c4ca64cff90a3cf61eb5e20c381b0f7" translate="yes" xml:space="preserve">
          <source>Once installed, the addon works in 3 steps:</source>
          <target state="translated">安装后,该插件的工作分为3个步骤。</target>
        </trans-unit>
        <trans-unit id="cd5d0a583c546e922e7dd07f13b00126893c9cbb" translate="yes" xml:space="preserve">
          <source>Once loaded, a service will persist until the application exits.</source>
          <target state="translated">一旦加载,服务将持续存在,直到应用程序退出。</target>
        </trans-unit>
        <trans-unit id="9b7473ccb2808c3e1202cafe608e15eb9e87bf60" translate="yes" xml:space="preserve">
          <source>Once open, remove the component labeled &lt;code&gt;{{welcome-page}}&lt;/code&gt;. The application should now be a completely blank canvas to build our application on.</source>
          <target state="translated">打开后，删除标有 &lt;code&gt;{{welcome-page}}&lt;/code&gt; 的组件。现在，该应用程序应该是一个完全空白的画布，可用于构建我们的应用程序。</target>
        </trans-unit>
        <trans-unit id="1eca8732180d60ac42bab4f21f28e52ea9a48daf" translate="yes" xml:space="preserve">
          <source>Once rendered an element's &lt;code&gt;elementId&lt;/code&gt; is considered immutable and you should never change it. If you need to compute a dynamic value for the &lt;code&gt;elementId&lt;/code&gt;, you should do this when the component or element is being instantiated:</source>
          <target state="translated">呈现元素后， &lt;code&gt;elementId&lt;/code&gt; 被认为是不可变的，您永远不要更改它。如果需要计算 &lt;code&gt;elementId&lt;/code&gt; 的动态值，则应在实例化组件或元素时执行以下操作：</target>
        </trans-unit>
        <trans-unit id="4267347d40eb36c6cbbed253186fd37bf3007beb" translate="yes" xml:space="preserve">
          <source>Once the beta cycle has completed, the next stable release will include any features that were enabled during the beta cycle. At this point the feature flags will be removed from the canary and future beta branches, and the feature becomes part of the framework.</source>
          <target state="translated">一旦测试周期结束,下一个稳定版将包含在测试周期中启用的任何功能。此时,功能标志将从金丝雀和未来的测试分支中移除,该功能将成为框架的一部分。</target>
        </trans-unit>
        <trans-unit id="56051bb2517e89df5d91846d46bbeb555a7edbb5" translate="yes" xml:space="preserve">
          <source>Once the main transition into &lt;code&gt;slow-model&lt;/code&gt; completes, the &lt;code&gt;loading&lt;/code&gt; route will be exited and the transition to &lt;code&gt;slow-model&lt;/code&gt; will continue.</source>
          <target state="translated">一旦完成向 &lt;code&gt;slow-model&lt;/code&gt; 的主要转换，将退出 &lt;code&gt;loading&lt;/code&gt; 路径，并继续向 &lt;code&gt;slow-model&lt;/code&gt; 转换。</target>
        </trans-unit>
        <trans-unit id="d59a62a3f97ccc2bfdeef6fc089edaeadc6ceb33" translate="yes" xml:space="preserve">
          <source>Once the proxied promise has settled this will become &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">一旦履行了诺言，这将是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4398fd5039ae29bd335437e10b017a202f1021a5" translate="yes" xml:space="preserve">
          <source>Once the proxied promise has settled this will become &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">一旦履行了诺言，这便成为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4688c68d00bda5e6b4d6f0282ecb2274e65f3aa4" translate="yes" xml:space="preserve">
          <source>Once the request to the server returns with a JSON payload for the requested record, the adapter resolves the promise it returned to the store with the JSON.</source>
          <target state="translated">一旦向服务器发出的请求返回了请求记录的JSON有效载荷,适配器就会用JSON解析它返回给存储的承诺。</target>
        </trans-unit>
        <trans-unit id="a7341d0efec76622cf31b57420e0efd9cc42ff86" translate="yes" xml:space="preserve">
          <source>Once the stub service is registered the test simply needs to check that the stub data that is being returned from the service is reflected in the component output.</source>
          <target state="translated">一旦注册了存根服务,测试只需要检查从服务返回的存根数据是否反映在组件输出中。</target>
        </trans-unit>
        <trans-unit id="6f0dda9c0cb3a268c5b42422c783a5ad7cd0e1d9" translate="yes" xml:space="preserve">
          <source>Once we create this &quot;button with confirmation&quot; component, we want to be able to reuse it all over our application.</source>
          <target state="translated">一旦我们创建了这个 &quot;带确认的按钮 &quot;组件,我们希望能够在我们的应用程序中重复使用它。</target>
        </trans-unit>
        <trans-unit id="9fbeae9a67f6bd9c4e25f14b9f726db44131dc7a" translate="yes" xml:space="preserve">
          <source>Once we have a new project in place, we can confirm everything is working by starting the Ember development server:</source>
          <target state="translated">一旦我们有了一个新的项目,我们可以通过启动Ember开发服务器来确认一切工作。</target>
        </trans-unit>
        <trans-unit id="23b19ac1ee33b1618505282400756773afbf338c" translate="yes" xml:space="preserve">
          <source>Once yielded, the data can be accessed by the wrapped content by referencing the &lt;code&gt;post&lt;/code&gt; variable. Now a component called &lt;code&gt;markdown-style&lt;/code&gt; will be rendered in &lt;code&gt;{{post.body}}&lt;/code&gt;.</source>
          <target state="translated">一旦产生，包装的内容就可以通过引用 &lt;code&gt;post&lt;/code&gt; 变量来访问数据。现在，一个名为 &lt;code&gt;markdown-style&lt;/code&gt; 的组件将在 &lt;code&gt;{{post.body}}&lt;/code&gt; 中呈现。</target>
        </trans-unit>
        <trans-unit id="be2dc254dc6c7464981de655c454c5b817215603" translate="yes" xml:space="preserve">
          <source>Once you call this method, any time the key's value is set, your observer will be notified. Note that the observers are triggered any time the value is set, regardless of whether it has actually changed. Your observer should be prepared to handle that.</source>
          <target state="translated">一旦你调用这个方法,任何时候键的值被设置,你的观察者都会被通知。请注意,无论值是否实际发生了变化,任何时候都会触发观察者。你的观察者应该做好处理的准备。</target>
        </trans-unit>
        <trans-unit id="0e423cbca6b9df549f466352ce6ab4bd43120115" translate="yes" xml:space="preserve">
          <source>Once you have an understanding of Ember Data, you will have a much better way to manage the complexity of data loading in your application. This will allow your code to evolve without becoming a mess.</source>
          <target state="translated">一旦你了解了Ember Data,你将有一个更好的方法来管理应用程序中数据加载的复杂性。这将使您的代码能够不断发展,而不会变得一团糟。</target>
        </trans-unit>
        <trans-unit id="e7879c2db8a502cf08ab955e6b7189ce9ea7ec40" translate="yes" xml:space="preserve">
          <source>Once you have built your &lt;code&gt;deprecation-workflow.js&lt;/code&gt; file and your deprecations are silenced, you can begin to work on deprecations one by one at your own leisure. To find deprecations, you can change the handler value of that message to either &lt;code&gt;throw&lt;/code&gt; or &lt;code&gt;log&lt;/code&gt;. Throw will throw an actual exception when the deprecation is encountered, so that tests that use the deprecated feature will fail. Choosing to log will simply log a warning to the console as before. These settings give you some flexibility on how you want to go about fixing the deprecations.</source>
          <target state="translated">一旦构建了 &lt;code&gt;deprecation-workflow.js&lt;/code&gt; 文件并且弃用项被静音，您就可以开始随意地逐项处理弃用项。要查找弃用项，可以将该消息的处理程序值更改为 &lt;code&gt;throw&lt;/code&gt; 或 &lt;code&gt;log&lt;/code&gt; 。遇到弃用时，抛出将引发实际的异常，因此使用弃用功能的测试将失败。选择记录只会像以前一样将警告记录到控制台。这些设置为您提供了一些解决折旧的灵活性。</target>
        </trans-unit>
        <trans-unit id="297de7e31394aa2c72d2a09e3d3842f25dc27bdc" translate="yes" xml:space="preserve">
          <source>Once you have defined a class, you can create new &lt;em&gt;instances&lt;/em&gt; of that class by calling its &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_create&quot;&gt;&lt;code&gt;create()&lt;/code&gt;&lt;/a&gt; method. Any methods, properties and computed properties you defined on the class will be available to instances:</source>
          <target state="translated">一旦定义了一个类，就可以通过调用其&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_create&quot;&gt; &lt;code&gt;create()&lt;/code&gt; &lt;/a&gt;方法来创建该类的新&lt;em&gt;实例&lt;/em&gt;。您在类上定义的任何方法，属性和计算属性将可用于实例：</target>
        </trans-unit>
        <trans-unit id="0ae78f9453ab89e2b98b40a513549fd747f33aca" translate="yes" xml:space="preserve">
          <source>Once you have defined a route with a dynamic segment, Ember will extract the value of the dynamic segment from the URL for you and pass them as a hash to the &lt;code&gt;model&lt;/code&gt; hook as the first argument:</source>
          <target state="translated">一旦定义了带有动态分段的路线，Ember将从您的URL中提取动态分段的值，并将其作为哈希值作为第一个参数传递给 &lt;code&gt;model&lt;/code&gt; 挂钩：</target>
        </trans-unit>
        <trans-unit id="37dc9e0949005db31c3bef8749a046174ea22093" translate="yes" xml:space="preserve">
          <source>Once you have these two methods implemented, apply the &lt;code&gt;Ember.Enumerable&lt;/code&gt; mixin to your class and you will be able to enumerate the contents of your object like any other collection.</source>
          <target state="translated">一旦实现了这两种方法， &lt;code&gt;Ember.Enumerable&lt;/code&gt; mixin应用于您的类，您将可以像其他任何集合一样枚举对象的内容。</target>
        </trans-unit>
        <trans-unit id="d318d88b083e6a740e5695fcce549c330e442a4c" translate="yes" xml:space="preserve">
          <source>Once you've installed Ember CLI via npm, you will have access to a new &lt;code&gt;ember&lt;/code&gt; command in your terminal. You can use the &lt;code&gt;ember new&lt;/code&gt; command to create a new application.</source>
          <target state="translated">通过npm安装Ember CLI后，您将可以在终端中访问新的 &lt;code&gt;ember&lt;/code&gt; 命令。您可以使用 &lt;code&gt;ember new&lt;/code&gt; 命令来创建新的应用程序。</target>
        </trans-unit>
        <trans-unit id="fae22ba23783545c09734f8348d02996c94f94d2" translate="yes" xml:space="preserve">
          <source>Once you've loaded your models from storage, components know how to translate model data into a UI that your user can interact with. For more information about how components get model data, see the &lt;a href=&quot;https://guides.emberjs.com/routing/specifying-a-routes-model&quot;&gt;Specifying a Route's Model&lt;/a&gt; guide.</source>
          <target state="translated">从存储中加载模型后，组件便知道如何将模型数据转换为用户可以与之交互的UI。有关组件如何获取模型数据的更多信息，请参见&amp;ldquo; &lt;a href=&quot;https://guides.emberjs.com/routing/specifying-a-routes-model&quot;&gt;指定路线的模型&amp;rdquo;&lt;/a&gt;指南。</target>
        </trans-unit>
        <trans-unit id="946fb83a5b5f0d85f4cd4d0947e1d59cebfd37a1" translate="yes" xml:space="preserve">
          <source>Once you've removed deprecations that you may not need to immediately address, you may still be left with many deprecations. Also, your remaining deprecations may only occur in very specific scenarios that are not obvious. How then should you go about finding and fixing these? This is where the &lt;a href=&quot;http://emberobserver.com/addons/ember-cli-deprecation-workflow&quot;&gt;ember-cli-deprecation-workflow&lt;/a&gt; addon can be extremely helpful.</source>
          <target state="translated">删除不需要立即解决的弃用项之后，您可能仍然会遇到许多弃用项。此外，您剩余的折旧费仅可能在不太明显的非常特定的情况下发生。那您应该如何去寻找并解决这些问题呢？这是&lt;a href=&quot;http://emberobserver.com/addons/ember-cli-deprecation-workflow&quot;&gt;ember-cli-preprecation-workflow&lt;/a&gt;附加组件非常有用的地方。</target>
        </trans-unit>
        <trans-unit id="7d393feab7e66d7efa30902c007f830f56512202" translate="yes" xml:space="preserve">
          <source>One benefit of the above approach compared to using &lt;code&gt;run.next&lt;/code&gt; is that you will be able to perform DOM/CSS operations before unprocessed elements are rendered to the screen, which may prevent flickering or other artifacts caused by delaying processing until after rendering.</source>
          <target state="translated">与使用 &lt;code&gt;run.next&lt;/code&gt; 相比，上述方法的优点之一是您可以在将未处理的元素呈现到屏幕之前执行DOM / CSS操作，这可以防止由于延迟处理直到呈现之后而引起的闪烁或其他伪像。</target>
        </trans-unit>
        <trans-unit id="2017e7fd0f2a575b1a1bb39b33094a703f7dc923" translate="yes" xml:space="preserve">
          <source>One common example is when overriding the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalizeResponse&quot;&gt;&lt;code&gt;normalizeResponse()&lt;/code&gt;&lt;/a&gt; hook in one of Ember-Data's serializers.</source>
          <target state="translated">一个常见的示例是在Ember-Data的序列化程序之一中重写&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalizeResponse&quot;&gt; &lt;code&gt;normalizeResponse()&lt;/code&gt; &lt;/a&gt;挂钩时。</target>
        </trans-unit>
        <trans-unit id="ef72e13fa9c7abd23262b84daf45e66eae37d8b2" translate="yes" xml:space="preserve">
          <source>One common way of building web applications is to tightly couple user interface elements to data fetching. For example, imagine you are writing the admin section of a blogging app, which has a feature that lists the drafts for the currently logged in user.</source>
          <target state="translated">构建Web应用的一种常见方式是将用户界面元素与数据获取紧密耦合。例如,想象一下,你正在编写一个博客应用的管理部分,该应用有一个功能是列出当前登录用户的草稿。</target>
        </trans-unit>
        <trans-unit id="1fd57542548476a402566a40e7028672d63f27fb" translate="yes" xml:space="preserve">
          <source>One detail to keep in mind is that both branches of the &lt;code&gt;if&lt;/code&gt; helper will be evaluated, so if you have &lt;code&gt;{{if condition &quot;foo&quot; (expensive-operation &quot;bar&quot;)&lt;/code&gt;, &lt;code&gt;expensive-operation&lt;/code&gt; will always calculate.</source>
          <target state="translated">要记住的一个细节是，将对 &lt;code&gt;if&lt;/code&gt; 助手的两个分支进行评估，因此，如果您拥有 &lt;code&gt;{{if condition &quot;foo&quot; (expensive-operation &quot;bar&quot;)&lt;/code&gt; ，那么总是会进行 &lt;code&gt;expensive-operation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="921f9a649da7d3ee552d9bb46da95892c7504e20" translate="yes" xml:space="preserve">
          <source>One downside to returning a cached record is you may find the state of the data has changed since it was first loaded into the store's identity map. In order to prevent this stale data from being a problem for long, Ember Data will automatically make a request in the background each time a cached record is returned from the store. When the new data comes in, the record is updated, and if there have been changes to the record since the initial render, the template is re-rendered with the new information.</source>
          <target state="translated">返回缓存记录的一个缺点是,你可能会发现数据的状态在第一次加载到商店的身份图中后已经发生了变化。为了防止这种陈旧的数据长期存在,每次从商店返回缓存记录时,Ember Data都会在后台自动进行请求。当新的数据进来后,记录就会被更新,如果从初始渲染后记录有变化,就会用新的信息重新渲染模板。</target>
        </trans-unit>
        <trans-unit id="6e6e9d09355e2e6fdfee3fc6889b073f2cc7d11f" translate="yes" xml:space="preserve">
          <source>One job of a route handler is rendering the appropriate template to the screen.</source>
          <target state="translated">路由处理程序的一项工作是将适当的模板渲染到屏幕上。</target>
        </trans-unit>
        <trans-unit id="023b2e22d9619644336d8abd002c12ec4e3957f7" translate="yes" xml:space="preserve">
          <source>One nice thing about this model is that if you try to set a value to the same thing as last time, Ember (through HTMLBars) will avoid doing any work on the DOM.</source>
          <target state="translated">这种模式有一个很好的地方就是,如果你试图将一个值设置成和上次一样的东西,Ember(通过HTMLBars)会避免在DOM上做任何工作。</target>
        </trans-unit>
        <trans-unit id="2c25bd1df98cee9098780b27f236f384e2f2dd2d" translate="yes" xml:space="preserve">
          <source>One of the major issues in testing web applications is that all code is event-driven and therefore has the potential to be asynchronous (i.e. output can happen out of sequence from input). This has the ramification that code can be executed in any order.</source>
          <target state="translated">测试Web应用程序的主要问题之一是所有代码都是事件驱动的,因此有可能是异步的(即输出可能与输入的顺序不同)。这带来的后果是,代码可以以任何顺序执行。</target>
        </trans-unit>
        <trans-unit id="f22cb0dab0dc2d88fe000d648a9d5f8ff6c7e07a" translate="yes" xml:space="preserve">
          <source>One of the methods is &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_transitionTo&quot;&gt;&lt;code&gt;transitionTo()&lt;/code&gt;&lt;/a&gt;. Calling &lt;code&gt;transitionTo()&lt;/code&gt; from a route or &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Controller.html#method_transitionToRoute&quot;&gt;&lt;code&gt;transitionToRoute()&lt;/code&gt;&lt;/a&gt; from a controller will stop any transitions currently in progress and start a new one, functioning as a redirect. &lt;code&gt;transitionTo()&lt;/code&gt; behaves exactly like the &lt;a href=&quot;https://guides.emberjs.com/templates/links&quot;&gt;link-to&lt;/a&gt; helper.</source>
          <target state="translated">方法之一是&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_transitionTo&quot;&gt; &lt;code&gt;transitionTo()&lt;/code&gt; &lt;/a&gt;。调用 &lt;code&gt;transitionTo()&lt;/code&gt; 从路线或&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Controller.html#method_transitionToRoute&quot;&gt; &lt;code&gt;transitionToRoute()&lt;/code&gt; &lt;/a&gt;从控制器将停止当前执行的任何过渡正在进行中，并开始一个新的，作为重定向功能。 &lt;code&gt;transitionTo()&lt;/code&gt; 的行为与&lt;a href=&quot;https://guides.emberjs.com/templates/links&quot;&gt;链接到&lt;/a&gt;帮助器的行为完全相同。</target>
        </trans-unit>
        <trans-unit id="3d247fef3beb6617e410a9310b1691023a273f3f" translate="yes" xml:space="preserve">
          <source>One of the responsibilities of a route is to load a model.</source>
          <target state="translated">航线的职责之一就是装载模型。</target>
        </trans-unit>
        <trans-unit id="bc339cc993a1d0dfdea6070d19f55e3e10babcc4" translate="yes" xml:space="preserve">
          <source>One or more Mixin classes</source>
          <target state="translated">一个或多个Mixin班</target>
        </trans-unit>
        <trans-unit id="a4387dcdd8c21d687d201ae902808eab655aaeb6" translate="yes" xml:space="preserve">
          <source>One property can be mapped on to another by placing a &quot;:&quot; between the source property and the destination property:</source>
          <target state="translated">一个属性可以通过在源属性和目的属性之间放置一个&quot;:&quot;来映射到另一个属性上。</target>
        </trans-unit>
        <trans-unit id="ddd8ba8819277c241acfb17d9b513165c7a86664" translate="yes" xml:space="preserve">
          <source>One scenario would be to camelCase the meta keys of your payload. The example below shows how this could be done using &lt;code&gt;normalizeArrayResponse&lt;/code&gt; and &lt;code&gt;extractRelationship&lt;/code&gt;.</source>
          <target state="translated">一种情况是驼峰化有效负载的元密钥。下面的示例显示了如何使用 &lt;code&gt;normalizeArrayResponse&lt;/code&gt; 和 &lt;code&gt;extractRelationship&lt;/code&gt; 完成此操作。</target>
        </trans-unit>
        <trans-unit id="aa8da0e5204ecf2e3129f7e87c21cf719d86102c" translate="yes" xml:space="preserve">
          <source>One way to think about the store is as a cache of all of the records that have been loaded by your application. If a route or a controller in your app asks for a record, the store can return it immediately if it is in the cache. Otherwise, the store must ask the adapter to load it, which usually means a trip over the network to retrieve it from the server.</source>
          <target state="translated">有一种方法可以把商店看成是你的应用程序已经加载的所有记录的缓存。如果你的应用程序中的路由或控制器要求获取一条记录,如果它在缓存中,商店可以立即返回。否则,商店必须要求适配器加载它,这通常意味着要通过网络从服务器上检索它。</target>
        </trans-unit>
        <trans-unit id="206de582d9e42728271567f32cef1d2caa66c410" translate="yes" xml:space="preserve">
          <source>One-To-Many</source>
          <target state="translated">One-To-Many</target>
        </trans-unit>
        <trans-unit id="72ed6317b3c29cc659bd9726d64c0704e0a987b4" translate="yes" xml:space="preserve">
          <source>One-To-One</source>
          <target state="translated">One-To-One</target>
        </trans-unit>
        <trans-unit id="e8edf93e5fc748fcefb10c45b67f1fe2105f8341" translate="yes" xml:space="preserve">
          <source>One-Way Bindings</source>
          <target state="translated">单向装订</target>
        </trans-unit>
        <trans-unit id="a888cbb9d1975f7a372576caffb7acdfc8b16b4f" translate="yes" xml:space="preserve">
          <source>One-to-Many</source>
          <target state="translated">One-to-Many</target>
        </trans-unit>
        <trans-unit id="a2cab38603c3673e0e2b0a47873e43f0dbfdffa8" translate="yes" xml:space="preserve">
          <source>One-to-One</source>
          <target state="translated">One-to-One</target>
        </trans-unit>
        <trans-unit id="f2b45396a05b9e6a742a38dba57faf9bcaacbc0e" translate="yes" xml:space="preserve">
          <source>Open &lt;a href=&quot;http://localhost:4200&quot;&gt;&lt;code&gt;http://localhost:4200&lt;/code&gt;&lt;/a&gt; in your browser of choice. You should see an Ember welcome page and not much else. Congratulations! You just created and booted your first Ember app.</source>
          <target state="translated">在您选择的浏览器中打开&lt;a href=&quot;http://localhost:4200&quot;&gt; &lt;code&gt;http://localhost:4200&lt;/code&gt; &lt;/a&gt;。您应该看到一个Ember欢迎页面，没有其他内容。恭喜你！您刚刚创建并启动了第一个Ember应用程序。</target>
        </trans-unit>
        <trans-unit id="2f97601478ddfa30694a21e0aee77ce407626778" translate="yes" xml:space="preserve">
          <source>Open our existing acceptance test, &lt;code&gt;tests/acceptance/list-rentals-test.js&lt;/code&gt;, and implement the test labeled &quot;should filter the list of rentals by city&quot;.</source>
          <target state="translated">打开我们现有的验收测试， &lt;code&gt;tests/acceptance/list-rentals-test.js&lt;/code&gt; ，并实施标有&amp;ldquo;应按城市过滤出租清单&amp;rdquo;的测试。</target>
        </trans-unit>
        <trans-unit id="0cc801dfb3bc3822b07222ee8a7d8dcfc04c59ec" translate="yes" xml:space="preserve">
          <source>Open the newly-created template in &lt;code&gt;app/templates/scientists.hbs&lt;/code&gt; and add the following HTML:</source>
          <target state="translated">在 &lt;code&gt;app/templates/scientists.hbs&lt;/code&gt; 中打开新创建的模板，并添加以下HTML：</target>
        </trans-unit>
        <trans-unit id="bd792fbd2875bdf3718df2a36075e5b668af82a7" translate="yes" xml:space="preserve">
          <source>Opening an issue or pull request to &lt;a href=&quot;https://github.com/emberjs/guides/&quot;&gt;the GitHub repository&lt;/a&gt;</source>
          <target state="translated">打开一个问题或请求到&lt;a href=&quot;https://github.com/emberjs/guides/&quot;&gt;GitHub存储库&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c1dd165afc95895bd90768a2a8a39ca08acf8783" translate="yes" xml:space="preserve">
          <source>Opening that file will reveal some initial code that will try to go to the &lt;code&gt;list-rentals&lt;/code&gt; route and verify that the route is loaded. The initial code is there to help us build our first acceptance test.</source>
          <target state="translated">打开该文件将显示一些初始代码，这些代码将尝试转到 &lt;code&gt;list-rentals&lt;/code&gt; 路由并验证该路由是否已加载。那里的初始代码可帮助我们建立第一个验收测试。</target>
        </trans-unit>
        <trans-unit id="68394f0bdcf1b11a4905c9738f7ac23b35d3aca2" translate="yes" xml:space="preserve">
          <source>Opening the template for this route reveals an outlet underneath the route's general page information. At the bottom of the template, you'll notice an &lt;code&gt;{{outlet}}&lt;/code&gt; helper. This is where the active nested route will be rendered.</source>
          <target state="translated">打开此路线的模板会在路线的常规页面信息下方显示一个出口。在模板的底部，您会注意到一个 &lt;code&gt;{{outlet}}&lt;/code&gt; 助手。这是活动嵌套路线的渲染位置。</target>
        </trans-unit>
        <trans-unit id="84c592e4f2dcd576f7dfcf84d3f2fab2e7d1c377" translate="yes" xml:space="preserve">
          <source>Operations performed in initializers should be kept as lightweight as possible to minimize delays in loading your application. Although advanced techniques exist for allowing asynchrony in application initializers (i.e. &lt;code&gt;deferReadiness&lt;/code&gt; and &lt;code&gt;advanceReadiness&lt;/code&gt;), these techniques should generally be avoided. Any asynchronous loading conditions (e.g. user authorization) are almost always better handled in your application route's hooks, which allows for DOM interaction while waiting for conditions to resolve.</source>
          <target state="translated">在初始化程序中执行的操作应尽可能轻巧，以最大程度减少加载应用程序的延迟。尽管存在允许应用程序初始化程序中异步的高级技术（即 &lt;code&gt;deferReadiness&lt;/code&gt; 和 &lt;code&gt;advanceReadiness&lt;/code&gt; ），但通常应避免使用这些技术。几乎总是可以在应用程序路由的挂钩中更好地处理任何异步加载条件（例如，用户授权），这允许在等待条件解决的同时进行DOM交互。</target>
        </trans-unit>
        <trans-unit id="245a923eb00420b9baa12f359835e88308f803dd" translate="yes" xml:space="preserve">
          <source>Opting into a full transition</source>
          <target state="translated">选择全面过渡</target>
        </trans-unit>
        <trans-unit id="66b8b140d34ca56fe840cbf56dad53e263eb6056" translate="yes" xml:space="preserve">
          <source>Optional arguments to be passed to the queued method.</source>
          <target state="translated">要传递给排队方法的可选参数。</target>
        </trans-unit>
        <trans-unit id="7174acae61247527fa92ec0872c03eec9cf98de5" translate="yes" xml:space="preserve">
          <source>Optional arguments to pass on</source>
          <target state="translated">可选参数的传递</target>
        </trans-unit>
        <trans-unit id="f4fa0c5292f62f88297e792835dcb8ffe325cd65" translate="yes" xml:space="preserve">
          <source>Optional arguments to pass to the timeout.</source>
          <target state="translated">传递给超时的可选参数。</target>
        </trans-unit>
        <trans-unit id="a00dbf5de4ed7db7948c3423669d8aeb01e9edd2" translate="yes" xml:space="preserve">
          <source>Optional array of actions (listeners).</source>
          <target state="translated">可选的行动数组(监听者)。</target>
        </trans-unit>
        <trans-unit id="a7f4c5eb44535d1e4f3e27873e7fffaf8af0087e" translate="yes" xml:space="preserve">
          <source>Optional array of parameters to interpolate into string.</source>
          <target state="translated">可选的参数数组,用于插值到字符串中。</target>
        </trans-unit>
        <trans-unit id="6c4f35334f92330cec8db7b3c2ec6ce4d524729c" translate="yes" xml:space="preserve">
          <source>Optional hash of configuration options including `willChange` and `didChange` option.</source>
          <target state="translated">可选的配置选项哈希,包括 &quot;willChange &quot;和 &quot;didChange &quot;选项。</target>
        </trans-unit>
        <trans-unit id="2f6b7a5c6a5652ddfb412d45674a61749417b985" translate="yes" xml:space="preserve">
          <source>Optional meta to lookup listeners</source>
          <target state="translated">可选的元数据来查找监听者</target>
        </trans-unit>
        <trans-unit id="844e0186eb00638ab699a19704bf6b6030a59426" translate="yes" xml:space="preserve">
          <source>Optional parameters for each listener.</source>
          <target state="translated">每个监听器的可选参数。</target>
        </trans-unit>
        <trans-unit id="6f066f2da230be0f98eac3487bbb5312285fcf7e" translate="yes" xml:space="preserve">
          <source>Optionally supply a model for the route in question. The model will be serialized into the URL using the &lt;code&gt;serialize&lt;/code&gt; hook of the route:</source>
          <target state="translated">（可选）为相关路线提供模型。该模型将使用路线的 &lt;code&gt;serialize&lt;/code&gt; 挂钩被序列化为URL ：</target>
        </trans-unit>
        <trans-unit id="4afb26fd74d5f6e8ea7cbf72fa7921df56de5e90" translate="yes" xml:space="preserve">
          <source>Optionally you can pass a type which unload all records for a given type.</source>
          <target state="translated">你也可以通过一个类型来卸载给定类型的所有记录。</target>
        </trans-unit>
        <trans-unit id="d707d47d0d151fe2e1d8731df65d7ece3ccb76af" translate="yes" xml:space="preserve">
          <source>Optionally, a model type used to determine which serializer will be used</source>
          <target state="translated">可选地,用于确定将使用哪个序列器的模型类型。</target>
        </trans-unit>
        <trans-unit id="136ae3638c2d9288aced04a9905490f376059e3b" translate="yes" xml:space="preserve">
          <source>Optionally, if &lt;code&gt;adapter.shouldBackgroundReloadAll&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;, then a background reload is started. Once this resolves, the array with which the promise resolves, is updated automatically so it contains all the records in the store:</source>
          <target state="translated">（可选）如果 &lt;code&gt;adapter.shouldBackgroundReloadAll&lt;/code&gt; 评估为 &lt;code&gt;true&lt;/code&gt; ，则将启动后台重新加载。解决此问题后，promise解决的数组将自动更新，因此包含存储中的所有记录：</target>
        </trans-unit>
        <trans-unit id="f76ca3aa52e342e9e499538412c709f9fc9c6c82" translate="yes" xml:space="preserve">
          <source>Optionally, if &lt;code&gt;adapter.shouldBackgroundReloadRecord&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;, then a background reload is started, which updates the records' data, once it is available:</source>
          <target state="translated">（可选）如果 &lt;code&gt;adapter.shouldBackgroundReloadRecord&lt;/code&gt; 的计算结果为 &lt;code&gt;true&lt;/code&gt; ，则将启动后台重载，一旦可用，该后台重载将更新记录的数据：</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="056a298f55d85765827346a51abdb7d167ab8056" translate="yes" xml:space="preserve">
          <source>Options for `Ember.deprecate`.</source>
          <target state="translated">`Ember.deprecate'的选项:</target>
        </trans-unit>
        <trans-unit id="d84522ef4b97044a7b5036fbf48e647677689781" translate="yes" xml:space="preserve">
          <source>Or if you pass it an array with names it returns the parameters as a hash:</source>
          <target state="translated">或者如果你传给它一个带名字的数组,它就会以哈希的形式返回参数。</target>
        </trans-unit>
        <trans-unit id="37cdfe0b0058fe4edf3c475c18fb07ae927c2616" translate="yes" xml:space="preserve">
          <source>Or on a hasMany relationship:</source>
          <target state="translated">或在有多关系。</target>
        </trans-unit>
        <trans-unit id="64e13784e0e5fc4499c58a28e19a3b279f630bc2" translate="yes" xml:space="preserve">
          <source>Or perhaps you might want to boot two instances of your app on the same page for a split-screen multiplayer experience:</source>
          <target state="translated">或者你可能想在同一个页面上启动两个应用实例,以获得分屏多人游戏体验。</target>
        </trans-unit>
        <trans-unit id="50016e626900570663ecf9226b2c2f188c840413" translate="yes" xml:space="preserve">
          <source>Or, assign an action to an inline event handler in the template (which creates a closure action and does receive the event object as an argument).</source>
          <target state="translated">或者,将一个动作分配给模板中的一个内联事件处理程序(该处理程序创建了一个关闭动作,并且确实接收了事件对象作为参数)。</target>
        </trans-unit>
        <trans-unit id="a4cc74f7b298a6159af4768c4304193189c80184" translate="yes" xml:space="preserve">
          <source>Order of Lifecycle Hooks Called</source>
          <target state="translated">生命周期挂钩的顺序称为</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="519255ae1f74ffc5ddd29979295c7572f048ad81" translate="yes" xml:space="preserve">
          <source>Organization</source>
          <target state="translated">Organization</target>
        </trans-unit>
        <trans-unit id="f6011263f2c8df7e6d5838c01886ff0ab127d426" translate="yes" xml:space="preserve">
          <source>Organize records into groups, each of which is to be passed to separate calls to &lt;code&gt;findMany&lt;/code&gt;.</source>
          <target state="translated">将记录组织成组，每个组将传递给单独的 &lt;code&gt;findMany&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="5c2df0e1900518adaa51b92719f7b922310675ba" translate="yes" xml:space="preserve">
          <source>Other Assets</source>
          <target state="translated">其他资产</target>
        </trans-unit>
        <trans-unit id="d3a5d50dac3d2fd3be1db7f31ed808c7f8a1ff9f" translate="yes" xml:space="preserve">
          <source>Other assets</source>
          <target state="translated">其他资产</target>
        </trans-unit>
        <trans-unit id="05b2c2f5c7ef214490e816d188da36da6aead3a8" translate="yes" xml:space="preserve">
          <source>Other than these two restrictions, Ember Data's normalized JSON object follows the &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt; specification.</source>
          <target state="translated">除了这两个限制外，Ember Data的规范化JSON对象遵循&lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt;规范。</target>
        </trans-unit>
        <trans-unit id="0a59ae439add2f420237329f253278208031489d" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;filterByCity&lt;/code&gt; function is going to pretend to be the action function for our component, that does the actual filtering of the rental list.</source>
          <target state="translated">我们的 &lt;code&gt;filterByCity&lt;/code&gt; 函数将假装为组件的action函数，该函数对租赁列表进行实际过滤。</target>
        </trans-unit>
        <trans-unit id="1d2352d7289d1df632f9cdd6e7d02d2ec6a168ab" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;rentals&lt;/code&gt; route is going to serve multiple functions. From our &lt;a href=&quot;../acceptance-test&quot;&gt;acceptance tests&lt;/a&gt;, we've shown that we want our users to be able to browse and search rentals, as well as see detailed information for individual rentals. To satisfy that requirement, we are going to make use of Ember's &lt;a href=&quot;https://guides.emberjs.com/routing/defining-your-routes/#toc_nested-routes&quot;&gt;nested route capability&lt;/a&gt;.</source>
          <target state="translated">我们的 &lt;code&gt;rentals&lt;/code&gt; 路线将具有多种功能。通过&lt;a href=&quot;../acceptance-test&quot;&gt;验收测试&lt;/a&gt;，我们已经表明我们希望用户能够浏览和搜索租金，以及查看各个租金的详细信息。为了满足该要求，我们将使用Ember的&lt;a href=&quot;https://guides.emberjs.com/routing/defining-your-routes/#toc_nested-routes&quot;&gt;嵌套路由功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ceabe1dbf5cc8df0bb7eda712f95c063f04ae06b" translate="yes" xml:space="preserve">
          <source>Our app needs a single function, &lt;code&gt;createMap&lt;/code&gt;, which makes use of &lt;code&gt;google.maps.Map&lt;/code&gt; to create our map element, &lt;code&gt;google.maps.Geocoder&lt;/code&gt; to lookup the coordinates of our location, and &lt;code&gt;google.maps.Marker&lt;/code&gt; to pin our map based on the resolved location.</source>
          <target state="translated">我们的应用程序需要一个函数 &lt;code&gt;createMap&lt;/code&gt; ，该函数使用 &lt;code&gt;google.maps.Map&lt;/code&gt; 创建我们的地图元素，使用 &lt;code&gt;google.maps.Geocoder&lt;/code&gt; 查找我们位置的坐标，并使用 &lt;code&gt;google.maps.Marker&lt;/code&gt; 来基于地图固定地图已解决的位置。</target>
        </trans-unit>
        <trans-unit id="e07b0dd7549ed8c27ea39867fe2f2d1988667c3e" translate="yes" xml:space="preserve">
          <source>Our app should behave now as before, with the addition of an image for each rental item.</source>
          <target state="translated">我们的应用程序现在应该像以前一样,为每个租赁项目添加一个图像。</target>
        </trans-unit>
        <trans-unit id="6a20c7d31e256f685e6854e8af9656af5d1a7698" translate="yes" xml:space="preserve">
          <source>Our component integration test will test two different behaviors:</source>
          <target state="translated">我们的组件集成测试将测试两种不同的行为。</target>
        </trans-unit>
        <trans-unit id="cae96a04e9b7056dc33933f973849aed2afc24ae" translate="yes" xml:space="preserve">
          <source>Our goal is to help you avoid that mess and come up to speed as fast as possible; you can consider us your internet friend.</source>
          <target state="translated">我们的目标是帮助您避免这种混乱,并尽快上手;您可以把我们当作您的互联网朋友。</target>
        </trans-unit>
        <trans-unit id="939816c45abd273d6565fd8a68842401b6e05c49" translate="yes" xml:space="preserve">
          <source>Our launched Chrome web browser now shows 10 successful tests. If you toggle the box labeled &quot;Hide passed tests&quot;, you should see our successful acceptance test, along with 9 passing ESLint tests. Ember tests each file you create for syntax issues (known as &quot;linting&quot;) using &lt;a href=&quot;http://eslint.org/&quot;&gt;ESLint&lt;/a&gt;.</source>
          <target state="translated">我们推出的Chrome网络浏览器现在显示了10个成功的测试。如果您选中标有&amp;ldquo;隐藏通过的测试&amp;rdquo;的框，则应该会看到我们成功的验收测试以及9个通过ESLint的测试。Ember使用&lt;a href=&quot;http://eslint.org/&quot;&gt;ESLint&lt;/a&gt;测试您创建的每个文件是否存在语法问题（称为&amp;ldquo; 掉毛 &amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="bb08f510a40d4531dddec319cee316e84226d5d3" translate="yes" xml:space="preserve">
          <source>Our list-filter component takes a function as an argument, used to find the list of matching rentals based on the filter string provided by the user. We provide an action function by setting it to the local scope of our test by calling &lt;code&gt;this.on&lt;/code&gt;.</source>
          <target state="translated">我们的列表过滤器组件以函数作为参数，用于根据用户提供的过滤器字符串查找匹配的租赁列表。我们通过调用 &lt;code&gt;this.on&lt;/code&gt; 将动作函数设置为测试的本地范围来提供它。</target>
        </trans-unit>
        <trans-unit id="b06b1f865cc2e950e72d8ef25f106bf2e0d12435" translate="yes" xml:space="preserve">
          <source>Our new &lt;code&gt;rental-listing&lt;/code&gt; component will manage how a user sees and interacts with a rental. To start, let's move the rental display details for a single rental from the &lt;code&gt;rentals.hbs&lt;/code&gt; template into &lt;code&gt;rental-listing.hbs&lt;/code&gt; and add the image field:</source>
          <target state="translated">我们新的 &lt;code&gt;rental-listing&lt;/code&gt; 组件将管理用户如何查看租借并与之互动。首先，让我们将单个租赁的租赁显示详细信息从 &lt;code&gt;rentals.hbs&lt;/code&gt; 模板移至 &lt;code&gt;rental-listing.hbs&lt;/code&gt; 并添加图像字段：</target>
        </trans-unit>
        <trans-unit id="29373ffd294040aafa4cf834c59c8d7e6c803a1c" translate="yes" xml:space="preserve">
          <source>Our new helper starts out with some boilerplate code from the generator:</source>
          <target state="translated">我们的新助手从生成器的一些锅炉模板代码开始。</target>
        </trans-unit>
        <trans-unit id="a349524a1f4aadac769db82fd11c98cb24360fc6" translate="yes" xml:space="preserve">
          <source>Our new route is nested within our &lt;code&gt;rentals&lt;/code&gt; route. This tells Ember that it is a sub-route and will be accessed through &lt;code&gt;localhost:4200/rentals/show&lt;/code&gt;.</source>
          <target state="translated">我们的新路线嵌套在我们的 &lt;code&gt;rentals&lt;/code&gt; 路线中。这告诉Ember这是一条子路由，将通过 &lt;code&gt;localhost:4200/rentals/show&lt;/code&gt; 进行访问。</target>
        </trans-unit>
        <trans-unit id="4f76189ba851aa52d8190127cc50d8974b28cd36" translate="yes" xml:space="preserve">
          <source>Our primary focus with mirage will be in the &lt;code&gt;config.js&lt;/code&gt; file, which is where we can define our API endpoints and our data. We will be following the &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON-API specification&lt;/a&gt; which requires our data to be formatted a certain way. Let's configure Mirage to send back our rentals that we had defined above by updating &lt;code&gt;mirage/config.js&lt;/code&gt;:</source>
          <target state="translated">我们对 &lt;code&gt;config.js&lt;/code&gt; 主要关注将在config.js文件中，在该文件中我们可以定义API端点和数据。我们将遵循&lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON-API规范&lt;/a&gt;，该规范要求我们的数据以某种方式进行格式化。让我们将Mirage配置为通过更新Mirage &lt;code&gt;mirage/config.js&lt;/code&gt; 来发送上面定义的租金：</target>
        </trans-unit>
        <trans-unit id="1b24e7c85fa3198f703161c3ddef40fe3394011b" translate="yes" xml:space="preserve">
          <source>Our test fills out &quot;Seattle&quot; as the search criteria in the search field, and then sends a &lt;code&gt;keyup&lt;/code&gt; event to the same field with a code of &lt;code&gt;69&lt;/code&gt; (the &lt;code&gt;e&lt;/code&gt; key) to simulate a user typing.</source>
          <target state="translated">我们的测试在搜索字段中填写&amp;ldquo;西雅图&amp;rdquo;作为搜索条件，然后使用 &lt;code&gt;69&lt;/code&gt; （ &lt;code&gt;e&lt;/code&gt; 键）的代码将 &lt;code&gt;keyup&lt;/code&gt; 事件发送到同一字段，以模拟用户的输入。</target>
        </trans-unit>
        <trans-unit id="78d0fbfeeac956fe03189a14212a32e505b7af40" translate="yes" xml:space="preserve">
          <source>Outputting their name and age.</source>
          <target state="translated">输出他们的姓名和年龄。</target>
        </trans-unit>
        <trans-unit id="7f785f12de428c659f4e7bcaf5ae3019791cd9ca" translate="yes" xml:space="preserve">
          <source>Outside of class definitions</source>
          <target state="translated">在类定义之外</target>
        </trans-unit>
        <trans-unit id="6448c99bf69eeb2ba6848557375b741d43c476bb" translate="yes" xml:space="preserve">
          <source>Override this function when writing a class-based helper.</source>
          <target state="translated">当编写一个基于类的帮助程序时,重写这个函数。</target>
        </trans-unit>
        <trans-unit id="e7118e866bd2fbc9b87fc7380712b78a5ce41ae2" translate="yes" xml:space="preserve">
          <source>Override this method with your testing framework's false assertion. This function is called whenever an exception occurs causing the testing promise to fail.</source>
          <target state="translated">用你的测试框架的错误断言覆盖这个方法。每当发生异常导致测试承诺失败时,就会调用这个函数。</target>
        </trans-unit>
        <trans-unit id="78724f610daa7d335490afd0afef134897e80478" translate="yes" xml:space="preserve">
          <source>Override this to call your framework's methods that handle async operations.</source>
          <target state="translated">重写这个来调用你的框架中处理异步操作的方法。</target>
        </trans-unit>
        <trans-unit id="6d464e9e96aeb92e00f8be7c60b6ca811e20cee2" translate="yes" xml:space="preserve">
          <source>Override to implement teardown.</source>
          <target state="translated">覆盖实现拆迁。</target>
        </trans-unit>
        <trans-unit id="72f33b6fd8ce9f99ebb8295cb19dd840fcca6242" translate="yes" xml:space="preserve">
          <source>Overrides &lt;code&gt;RegistryProxy#unregister&lt;/code&gt; in order to clear any cached instances of the unregistered factory.</source>
          <target state="translated">覆盖 &lt;code&gt;RegistryProxy#unregister&lt;/code&gt; ，以清除未注册工厂的所有缓存实例。</target>
        </trans-unit>
        <trans-unit id="e441b8e9bc7405861b187f25fbe7e852d75948a0" translate="yes" xml:space="preserve">
          <source>Overriding Application-wide Defaults</source>
          <target state="translated">覆盖应用程序范围的默认值</target>
        </trans-unit>
        <trans-unit id="fff1ab70d9215d47433358aa873ef34fdced6c34" translate="yes" xml:space="preserve">
          <source>Overriding Parent Class Methods</source>
          <target state="translated">覆盖父类方法</target>
        </trans-unit>
        <trans-unit id="bfaaaf32788c2fd06d3c8e0c98eb03bc280e18a2" translate="yes" xml:space="preserve">
          <source>Overriding attributes</source>
          <target state="translated">覆盖属性</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="9fbe29d4d76ec756421aee06e0f34f17fa488ff3" translate="yes" xml:space="preserve">
          <source>PATCH</source>
          <target state="translated">PATCH</target>
        </trans-unit>
        <trans-unit id="61ff81c30aa3c76e78afea62b2e3bd1dfa49e854" translate="yes" xml:space="preserve">
          <source>POST</source>
          <target state="translated">POST</target>
        </trans-unit>
        <trans-unit id="8e19661733745ef4b2adef80a34cf5d1556477ae" translate="yes" xml:space="preserve">
          <source>Pagination is a common example of using metadata. Imagine a blog with far more posts than you can display at once. You might query it like so:</source>
          <target state="translated">分页是使用元数据的一个常见例子。想象一下,一个博客的文章数量远远超过了你可以同时显示的数量。你可以这样查询。</target>
        </trans-unit>
        <trans-unit id="53b2b4d9664c2f7ba6c736b20cc936678a185b0b" translate="yes" xml:space="preserve">
          <source>Parent:&lt;a href=&quot;ember&quot;&gt;ember&lt;/a&gt;</source>
          <target state="translated">Parent:&lt;a href=&quot;ember&quot;&gt;ember&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e82d2ab7546c96cb9a5574e03456855e889721d" translate="yes" xml:space="preserve">
          <source>Part of what makes components so useful is that they let you take complete control of a section of the DOM. This allows for direct DOM manipulation, listening and responding to browser events, and using 3rd party JavaScript libraries in your Ember app.</source>
          <target state="translated">组件如此有用的部分原因是它们让你完全控制DOM的一部分。这允许直接操作DOM,监听和响应浏览器事件,并在你的Ember应用中使用第三方JavaScript库。</target>
        </trans-unit>
        <trans-unit id="1fd681d8590147352e763485982ff52042383b47" translate="yes" xml:space="preserve">
          <source>Passing Arguments</source>
          <target state="translated">传递参数</target>
        </trans-unit>
        <trans-unit id="1e7148ce0c1621aba30d240c1c19ad8aaf313466" translate="yes" xml:space="preserve">
          <source>Passing Properties to a Component</source>
          <target state="translated">将属性传递给一个组件</target>
        </trans-unit>
        <trans-unit id="d7b6892060d3ef827e6332e1ab8d7813ce2e7481" translate="yes" xml:space="preserve">
          <source>Passing functions with the action helper</source>
          <target state="translated">用动作助手传递函数</target>
        </trans-unit>
        <trans-unit id="8b910b718628891639ad10590baddf47ec63bfe2" translate="yes" xml:space="preserve">
          <source>Passing the Action to the Component</source>
          <target state="translated">将动作传递给组件</target>
        </trans-unit>
        <trans-unit id="bc9542bcb8c51a85721c7d88e5203af136f9bb1f" translate="yes" xml:space="preserve">
          <source>Path Customization</source>
          <target state="translated">路径定制</target>
        </trans-unit>
        <trans-unit id="356cd3bf86420c7cad5947142df308e6e29392c9" translate="yes" xml:space="preserve">
          <source>Pathname customization</source>
          <target state="translated">自定义路径名</target>
        </trans-unit>
        <trans-unit id="4d370c50b556b5821596079c3ed48ddf2fbe93ad" translate="yes" xml:space="preserve">
          <source>Pauses the current test - this is useful for debugging while testing or for test-driving. It allows you to inspect the state of your application at any point. Example (The test will pause before clicking the button):</source>
          <target state="translated">暂停当前的测试--这对测试时的调试或测试驱动很有用。它允许你在任何时候检查你的应用程序的状态。例如(在点击按钮之前,测试将暂停)。</target>
        </trans-unit>
        <trans-unit id="4946af784e3408745353f1accc2c18f8c0f6d02d" translate="yes" xml:space="preserve">
          <source>Perform a synchronous transition into another route without attempting to resolve promises, update the URL, or abort any currently active asynchronous transitions (i.e. regular transitions caused by &lt;code&gt;transitionTo&lt;/code&gt; or URL changes).</source>
          <target state="translated">在不尝试解析承诺，更新URL或中止任何当前活动的异步过渡（即由 &lt;code&gt;transitionTo&lt;/code&gt; 或URL更改引起的常规过渡）的情况下，执行到另一个路由的同步过渡。</target>
        </trans-unit>
        <trans-unit id="f12c5f85d68b2c1cf86b757e8d7188dc87be03b5" translate="yes" xml:space="preserve">
          <source>Persisting Records</source>
          <target state="translated">持续记录</target>
        </trans-unit>
        <trans-unit id="7681a0376373e3089f3cc1d9cb621f731b425cd6" translate="yes" xml:space="preserve">
          <source>Picking different components to render in response to the data allows you to have different template and behavior for each case. The &lt;code&gt;{{component}}&lt;/code&gt; helper is a powerful tool for improving code modularity.</source>
          <target state="translated">选择不同的组件以响应数据进行渲染，使您可以针对每种情况使用不同的模板和行为。该 &lt;code&gt;{{component}}&lt;/code&gt; 帮手是提高代码的模块化的强大工具。</target>
        </trans-unit>
        <trans-unit id="e1a35f314bf2633bdff792cb61a30fd24db73276" translate="yes" xml:space="preserve">
          <source>Planning Your App</source>
          <target state="translated">规划您的应用程序</target>
        </trans-unit>
        <trans-unit id="10ab891c24a563405b3a70b1ca34ebe464adb253" translate="yes" xml:space="preserve">
          <source>Please note: This is not for normal usage, and should be used sparingly.</source>
          <target state="translated">请注意:这不是正常使用,应尽量少用。</target>
        </trans-unit>
        <trans-unit id="651987c8f13c93d564a719b93607cd420d73a63f" translate="yes" xml:space="preserve">
          <source>Please note: any property changes made during this event will have no effect on object observers.</source>
          <target state="translated">请注意:在此活动期间所做的任何属性更改都不会对对象观察者产生影响。</target>
        </trans-unit>
        <trans-unit id="97a8fb33f7301b7d070bb6b9b6f5697d38d45f2d" translate="yes" xml:space="preserve">
          <source>Pluralization Customization</source>
          <target state="translated">多元化定制</target>
        </trans-unit>
        <trans-unit id="861260cecd797e42301015d1972945d6ccce6883" translate="yes" xml:space="preserve">
          <source>Polyfill</source>
          <target state="translated">Polyfill</target>
        </trans-unit>
        <trans-unit id="989fc91d044783d05d714e433d3e90dca9bdf4da" translate="yes" xml:space="preserve">
          <source>Polymorphism</source>
          <target state="translated">Polymorphism</target>
        </trans-unit>
        <trans-unit id="b60b227dfc72ce2592d5e011bdf46ba68f6f3eeb" translate="yes" xml:space="preserve">
          <source>Polymorphism is a powerful concept which allows a developer to abstract common functionality into a base class. Consider the following example: a user with multiple payment methods. They could have a linked PayPal account, and a couple credit cards on file.</source>
          <target state="translated">多态是一个强大的概念,它允许开发人员将通用功能抽象到一个基类中。考虑下面的例子:一个用户有多种支付方式。他们可以有一个链接的PayPal账户,还有几张信用卡的档案。</target>
        </trans-unit>
        <trans-unit id="4cb4bbf7cc3d4bc42049240fc08ab58851cd946a" translate="yes" xml:space="preserve">
          <source>Pop object from array or nil if none are left. Works just like &lt;code&gt;pop()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">从数组中弹出对象，如果没有剩余则从nil中弹出。就像 &lt;code&gt;pop()&lt;/code&gt; 一样工作，但是它兼容KVO。</target>
        </trans-unit>
        <trans-unit id="dc996b0d24beeb1d3c79bbc55469c48d769e7cfb" translate="yes" xml:space="preserve">
          <source>Positional Params</source>
          <target state="translated">位置参数</target>
        </trans-unit>
        <trans-unit id="f2684504bc0f6384c84c477f8be4a0311c5832d7" translate="yes" xml:space="preserve">
          <source>Preloading</source>
          <target state="translated">Preloading</target>
        </trans-unit>
        <trans-unit id="4b1fb7e1484b0ba94928623eb8f36f404667ac59" translate="yes" xml:space="preserve">
          <source>Preventing Transitions via &lt;code&gt;willTransition&lt;/code&gt;</source>
          <target state="translated">通过 &lt;code&gt;willTransition&lt;/code&gt; 防止过渡</target>
        </trans-unit>
        <trans-unit id="d802d61c8a7392e75323ae02de35b9864c66709a" translate="yes" xml:space="preserve">
          <source>Preventing and Retrying Transitions</source>
          <target state="translated">防止和重新尝试过渡</target>
        </trans-unit>
        <trans-unit id="5013daf65503f91d54eccc1797b76d7e4dcd2880" translate="yes" xml:space="preserve">
          <source>Previously, in the &lt;a href=&quot;../routes-and-templates&quot;&gt;Routes and Templates tutorial&lt;/a&gt;, we set up a &lt;code&gt;rentals&lt;/code&gt; route.</source>
          <target state="translated">以前，在&amp;ldquo; &lt;a href=&quot;../routes-and-templates&quot;&gt;路线和模板&amp;rdquo;教程中&lt;/a&gt;，我们设置了一条 &lt;code&gt;rentals&lt;/code&gt; 路线。</target>
        </trans-unit>
        <trans-unit id="f9baaec4106faea48eaf7fcd6f074b9e97eaf3ab" translate="yes" xml:space="preserve">
          <source>Process all the jobs sequentially in &lt;code&gt;WORK_QUEUE&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;WORK_QUEUE&lt;/code&gt; 中依次处理所有作业</target>
        </trans-unit>
        <trans-unit id="fe5671922bc7f67cfabfa60ab97a9542ac21f39f" translate="yes" xml:space="preserve">
          <source>Promise</source>
          <target state="translated">Promise</target>
        </trans-unit>
        <trans-unit id="eb5d6e800790dcdd19447fac47669042de50dde8" translate="yes" xml:space="preserve">
          <source>Promise Example;</source>
          <target state="translated">答应例。</target>
        </trans-unit>
        <trans-unit id="7763424e70cdeb92b8efa1ce1e7ab2fb3c67f143" translate="yes" xml:space="preserve">
          <source>Promise States and Filtering</source>
          <target state="translated">承诺状态和过滤</target>
        </trans-unit>
        <trans-unit id="5ea8f6f7f55aefad94d6f37edf953a84817d34aa" translate="yes" xml:space="preserve">
          <source>Promise objects represent the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its &lt;code&gt;then&lt;/code&gt; method, which registers callbacks to receive either a promise&amp;rsquo;s eventual value or the reason why the promise cannot be fulfilled.</source>
          <target state="translated">承诺对象表示异步操作的最终结果。与承诺进行交互的主要方式是通过其 &lt;code&gt;then&lt;/code&gt; 方法，该方法注册回调以接收承诺的最终值或无法实现承诺的原因。</target>
        </trans-unit>
        <trans-unit id="46847c5528bf36a862876e82e64f9301b7d8c435" translate="yes" xml:space="preserve">
          <source>Promise that resolves to the passed value.</source>
          <target state="translated">承诺,解析到传递的值。</target>
        </trans-unit>
        <trans-unit id="f90fc3965e7f0b82d63fa7168a48a06bdbb2d8a7" translate="yes" xml:space="preserve">
          <source>Promise&amp;lt;Ember.ApplicationInstance, Error&amp;gt;</source>
          <target state="translated">Promise &amp;lt;Ember.ApplicationInstance，错误&amp;gt;</target>
        </trans-unit>
        <trans-unit id="20dfb17fbcb83737eb52f26791ace1434823d825" translate="yes" xml:space="preserve">
          <source>Promise&amp;lt;record&amp;gt;</source>
          <target state="translated">Promise&amp;lt;record&amp;gt;</target>
        </trans-unit>
        <trans-unit id="203fae2a257dd496efa85980bf0ba4c7773be142" translate="yes" xml:space="preserve">
          <source>Promise&amp;lt;record&amp;gt; a promise for the value (record or relationship)</source>
          <target state="translated">Promise &amp;lt;record&amp;gt;对值的承诺（记录或关系）</target>
        </trans-unit>
        <trans-unit id="1e8da2708d11a179d860eb37dfe66600b1bd2b46" translate="yes" xml:space="preserve">
          <source>PromiseProxyMixin</source>
          <target state="translated">PromiseProxyMixin</target>
        </trans-unit>
        <trans-unit id="b1d472e424c03ff52490d1edc8a0e23f95babb92" translate="yes" xml:space="preserve">
          <source>Promises</source>
          <target state="translated">Promises</target>
        </trans-unit>
        <trans-unit id="f44a75e9345297610dff0ce9a97e4b57b6b46aab" translate="yes" xml:space="preserve">
          <source>Promises A+ specifies that any exceptions that occur with a promise must be caught by the promises implementation and bubbled to the last handler. For this reason, it is recommended that you always specify a second rejection handler function to &lt;code&gt;then&lt;/code&gt;. However, &lt;code&gt;RSVP.rethrow&lt;/code&gt; will throw the exception outside of the promise, so it bubbles up to your console if in the browser, or domain/cause uncaught exception in Node. &lt;code&gt;rethrow&lt;/code&gt; will also throw the error again so the error can be handled by the promise per the spec.</source>
          <target state="translated">Promises A +规定，由Promise实现必须捕获与Promise一起发生的任何异常，并冒泡到最后一个处理程序。因此，建议您始终向 &lt;code&gt;then&lt;/code&gt; 指定第二个拒绝处理程序函数。但是， &lt;code&gt;RSVP.rethrow&lt;/code&gt; 会在Promise之外抛出异常，因此，如果在浏览器中或Node中的域/原因未捕获的异常，它会冒泡到您的控制台。 &lt;code&gt;rethrow&lt;/code&gt; 也会再次抛出错误，因此可以按照规范通过承诺处理错误。</target>
        </trans-unit>
        <trans-unit id="216c902fd90fd7f61531c27c5a86d60085ec25e9" translate="yes" xml:space="preserve">
          <source>Promises Not Detected</source>
          <target state="translated">未检测到的承诺</target>
        </trans-unit>
        <trans-unit id="aaca97f965d2c31995d03cad0b27e350c3445416" translate="yes" xml:space="preserve">
          <source>Promises can also be said to &lt;em&gt;resolve&lt;/em&gt; a value. If this value is also a promise, then the original promise's settled state will match the value's settled state. So a promise that &lt;em&gt;resolves&lt;/em&gt; a promise that rejects will itself reject, and a promise that &lt;em&gt;resolves&lt;/em&gt; a promise that fulfills will itself fulfill.</source>
          <target state="translated">也可以说承诺&lt;em&gt;解决&lt;/em&gt;了一个价值。如果此值也是承诺，则原始承诺的结算状态将与该值的结算状态匹配。因此，&lt;em&gt;解决&lt;/em&gt;了被拒绝的诺言的诺言本身将被拒绝，而&lt;em&gt;解决&lt;/em&gt;被实现的诺言的诺言本身将被实现。</target>
        </trans-unit>
        <trans-unit id="9f4ddbbce9b9a96df78d3c916a6239398660cebc" translate="yes" xml:space="preserve">
          <source>Promises generated by Ember are all labeled by default. You can also label your own RSVP Promises to find them in the Inspector's Promises tab. All RSVP methods can take a label as the final argument.</source>
          <target state="translated">Ember生成的承诺都是默认的标签。你也可以给自己的RSVP承诺打上标签,在检查员的承诺选项卡中找到它们。所有的RSVP方法都可以接受一个标签作为最终参数。</target>
        </trans-unit>
        <trans-unit id="763b5a177da3472a739c49add6d1a21b1ef06c5d" translate="yes" xml:space="preserve">
          <source>Promises have different colors based on their state.</source>
          <target state="translated">承诺根据其状态有不同的颜色。</target>
        </trans-unit>
        <trans-unit id="f72d01a967e01e14a4a0fa223b3309202aa7c45b" translate="yes" xml:space="preserve">
          <source>Promises shine when abstracting away asynchronous interactions such as &lt;code&gt;XMLHttpRequest&lt;/code&gt;s.</source>
          <target state="translated">当抽象出诸如 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 之类的异步交互时，承诺会大放异彩。</target>
        </trans-unit>
        <trans-unit id="9229a94589162572814117eb770a291cf02fddad" translate="yes" xml:space="preserve">
          <source>Promises that are fulfilled have a fulfillment value and are in the fulfilled state. Promises that are rejected have a rejection reason and are in the rejected state. A fulfillment value is never a thenable.</source>
          <target state="translated">被履行的承诺有一个履行值,处于履行状态。被拒绝的承诺有拒绝原因,处于拒绝状态。履行值永远不是一个可然后。</target>
        </trans-unit>
        <trans-unit id="03590df139443945075f2a3bc957119a024699ce" translate="yes" xml:space="preserve">
          <source>Promise|Object</source>
          <target state="translated">Promise|Object</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="536b9006793cf5c3c1070e09df19893db8668d7a" translate="yes" xml:space="preserve">
          <source>Properties and observers allow one object to observe changes to a property on another object. This is one of the fundamental ways that models, controllers and views communicate with each other in an Ember application.</source>
          <target state="translated">属性和观察者允许一个对象观察另一个对象的属性变化。这是模型、控制器和视图在Ember应用中相互沟通的基本方式之一。</target>
        </trans-unit>
        <trans-unit id="82033eb711807359e0eec9de4a43a4d74d92c987" translate="yes" xml:space="preserve">
          <source>Properties can be chained as well:</source>
          <target state="translated">属性也是可以连锁的。</target>
        </trans-unit>
        <trans-unit id="5c379650924c833d1858287bc08588ceb832a8a0" translate="yes" xml:space="preserve">
          <source>Properties that are defined on the model but are omitted in the normalized JSON API document object will not be updated. Properties that are included in the normalized JSON API document object but not defined on the Model will be ignored.</source>
          <target state="translated">在模型上定义但在规范化JSON API文档对象中省略的属性将不会被更新。包含在规范化JSON API文档对象中但未在模型上定义的属性将被忽略。</target>
        </trans-unit>
        <trans-unit id="8d9e37b396787a5cb09465045bf0f0a4eab7185e" translate="yes" xml:space="preserve">
          <source>Property Observers</source>
          <target state="translated">物业观察员</target>
        </trans-unit>
        <trans-unit id="3249cd85365c1d97e6d4a3239b88af5d064671ab" translate="yes" xml:space="preserve">
          <source>Provide the asset path as the first argument, and the list of modules and exports as the second.</source>
          <target state="translated">提供资产路径作为第一个参数,提供模块和出口列表作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="4e7ccdfdc46e55a1f8f8e8698100457fdda15b9f" translate="yes" xml:space="preserve">
          <source>Provide the asset path as the first argument:</source>
          <target state="translated">提供资产路径作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="804a830ba49ef5270d658059a3cc0bf26f755759" translate="yes" xml:space="preserve">
          <source>Providing Markup to a Component</source>
          <target state="translated">为组件提供标记</target>
        </trans-unit>
        <trans-unit id="5c9b1ac36b5021ea213e2a9b52e09401d0c16a5b" translate="yes" xml:space="preserve">
          <source>Proxies to the serializer's &lt;code&gt;serialize&lt;/code&gt; method.</source>
          <target state="translated">代理序列化器的 &lt;code&gt;serialize&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="127bb9e4bb030d22e2337f3c5cdd29d2359e0a2d" translate="yes" xml:space="preserve">
          <source>ProxyMixin</source>
          <target state="translated">ProxyMixin</target>
        </trans-unit>
        <trans-unit id="c4a9924b7849758c869d4fd5e52d97bd8b26ff5e" translate="yes" xml:space="preserve">
          <source>Push some data for a given type into the store.</source>
          <target state="translated">将给定类型的一些数据推送到存储中。</target>
        </trans-unit>
        <trans-unit id="9536ee10c3ab2432a5e6558f3207239d0d2ea555" translate="yes" xml:space="preserve">
          <source>Push some raw data into the store.</source>
          <target state="translated">将一些原始数据推送到商店。</target>
        </trans-unit>
        <trans-unit id="9b601bad7a8b3234afd2de3a37d3cb2f2f119973" translate="yes" xml:space="preserve">
          <source>Push the object onto the end of the array if it is not already present in the array.</source>
          <target state="translated">如果对象没有出现在数组中,则将其推到数组的末端。</target>
        </trans-unit>
        <trans-unit id="5a5340b1561d715113dc2d332842eae59747ca32" translate="yes" xml:space="preserve">
          <source>Push the object onto the end of the array. Works just like &lt;code&gt;push()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">将对象推到数组的末尾。就像 &lt;code&gt;push()&lt;/code&gt; 一样工作，但是它兼容KVO。</target>
        </trans-unit>
        <trans-unit id="700f90c6bd512a32dbfb55478282f3c7731cdb78" translate="yes" xml:space="preserve">
          <source>Pushing Records</source>
          <target state="translated">唱片公司</target>
        </trans-unit>
        <trans-unit id="08491627624f56833d6474da961363d94fe64101" translate="yes" xml:space="preserve">
          <source>Pushing Records into the Store</source>
          <target state="translated">将唱片推入商店</target>
        </trans-unit>
        <trans-unit id="ba83f3a04b35edb4a33611352a88476fef56f328" translate="yes" xml:space="preserve">
          <source>QUnit example:</source>
          <target state="translated">QUnit的例子。</target>
        </trans-unit>
        <trans-unit id="c5aad12964a69eb6cc9ccef39e0f740e43015f0f" translate="yes" xml:space="preserve">
          <source>QUnit passes in an object called an &lt;a href=&quot;https://api.qunitjs.com/assert/&quot;&gt;&lt;code&gt;assert&lt;/code&gt;&lt;/a&gt; to each test function. An &lt;code&gt;assert&lt;/code&gt; has functions, such as &lt;code&gt;equal()&lt;/code&gt;, that allow your test to check for conditions within the test environment. A test must have one passing assert to be successful.</source>
          <target state="translated">QUnit将一个称为&lt;a href=&quot;https://api.qunitjs.com/assert/&quot;&gt; &lt;code&gt;assert&lt;/code&gt; &lt;/a&gt;的对象传递给每个测试函数。一个 &lt;code&gt;assert&lt;/code&gt; 具有的功能，如 &lt;code&gt;equal()&lt;/code&gt; ，允许您的测试，以检查测试环境中的条件。一个测试必须有一个通过的断言才能成功。</target>
        </trans-unit>
        <trans-unit id="3229861d9c9111cf61a19e43da48ddbbd1b48efd" translate="yes" xml:space="preserve">
          <source>Query Parameters</source>
          <target state="translated">查询参数</target>
        </trans-unit>
        <trans-unit id="5139ef15ef3085f1688a1e87d332dfd36e0ceff6" translate="yes" xml:space="preserve">
          <source>Query param values are cast to the same datatype as the default value, e.g. a URL change from &lt;code&gt;/?page=3&lt;/code&gt; to &lt;code&gt;/?page=2&lt;/code&gt; will set &lt;code&gt;controller:articles&lt;/code&gt;'s &lt;code&gt;page&lt;/code&gt; property to the number &lt;code&gt;2&lt;/code&gt;, rather than the string &lt;code&gt;&quot;2&quot;&lt;/code&gt;. The same also applies to boolean default values. If the default value is an array, the string will be parsed using &lt;code&gt;JSON.parse&lt;/code&gt;.</source>
          <target state="translated">查询参数值将转换为与默认值相同的数据类型，例如，将URL从 &lt;code&gt;/?page=3&lt;/code&gt; 更改为 &lt;code&gt;/?page=2&lt;/code&gt; 会将 &lt;code&gt;controller:articles&lt;/code&gt; 的 &lt;code&gt;page&lt;/code&gt; 属性设置为数字 &lt;code&gt;2&lt;/code&gt; ，而不是字符串 &lt;code&gt;&quot;2&quot;&lt;/code&gt; 。布尔默认值也是如此。如果默认值为数组，则将使用 &lt;code&gt;JSON.parse&lt;/code&gt; 解析字符串。</target>
        </trans-unit>
        <trans-unit id="0aca39e962863236da8c92fd756de102fb200868" translate="yes" xml:space="preserve">
          <source>Query parameters are optional key-value pairs that appear to the right of the &lt;code&gt;?&lt;/code&gt; in a URL. For example, the following URL has two query params, &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;page&lt;/code&gt;, with respective values &lt;code&gt;ASC&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;:</source>
          <target state="translated">查询参数是可选的键值对，显示在 &lt;code&gt;?&lt;/code&gt; 的右侧。在网址中。例如，以下URL具有两个查询参数 &lt;code&gt;sort&lt;/code&gt; 和 &lt;code&gt;page&lt;/code&gt; ，分别具有值 &lt;code&gt;ASC&lt;/code&gt; 和 &lt;code&gt;2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b0f8ce0e88182d09e5b36ad33c8efbb1f3a42a78" translate="yes" xml:space="preserve">
          <source>Query params allow for additional application state to be serialized into the URL that can't otherwise fit into the &lt;em&gt;path&lt;/em&gt; of the URL (i.e. everything to the left of the &lt;code&gt;?&lt;/code&gt;). Common use cases for query params include representing the current page number in a paginated collection, filter criteria, or sorting criteria.</source>
          <target state="translated">查询参数允许将其他应用程序状态序列化到URL中，否则该状态不能适合URL 的&lt;em&gt;路径&lt;/em&gt;（即， &lt;code&gt;?&lt;/code&gt; 左边的所有内容）。查询参数的常见用例包括在分页集合中表示当前页码，过滤条件或排序条件。</target>
        </trans-unit>
        <trans-unit id="b1782f7b18226435ee790bf1a339595b9fcaafce" translate="yes" xml:space="preserve">
          <source>Query params are declared on route-driven controllers. For example, to configure query params that are active within the &lt;code&gt;articles&lt;/code&gt; route, they must be declared on &lt;code&gt;controller:articles&lt;/code&gt;.</source>
          <target state="translated">查询参数在路由驱动的控制器上声明。例如，要配置在 &lt;code&gt;articles&lt;/code&gt; 路由中处于活动状态的查询参数，必须在 &lt;code&gt;controller:articles&lt;/code&gt; 上声明它们。</target>
        </trans-unit>
        <trans-unit id="b1e8c5f9eb6a51268771357d73e5c3d414ee77b7" translate="yes" xml:space="preserve">
          <source>Query params that require additional customization can be provided along with strings in the &lt;code&gt;queryParams&lt;/code&gt; array.</source>
          <target state="translated">可以提供需要额外自定义的查询参数以及 &lt;code&gt;queryParams&lt;/code&gt; 数组中的字符串。</target>
        </trans-unit>
        <trans-unit id="84d51a6c79840a7e20e6f3b3c232167ddd101fdb" translate="yes" xml:space="preserve">
          <source>Querying for A Single Record</source>
          <target state="translated">查询单条记录</target>
        </trans-unit>
        <trans-unit id="bab1721e2fbda766f83183971199264a105762c8" translate="yes" xml:space="preserve">
          <source>Querying for Multiple Records</source>
          <target state="translated">查询多个记录</target>
        </trans-unit>
        <trans-unit id="455083cac2ae96eabe3895762b6080aa09e6afa4" translate="yes" xml:space="preserve">
          <source>Quick Start</source>
          <target state="translated">快速入门</target>
        </trans-unit>
        <trans-unit id="9e2ff6c5483cb39d97a402f850cb39e32d0c9dbc" translate="yes" xml:space="preserve">
          <source>RSVP</source>
          <target state="translated">RSVP</target>
        </trans-unit>
        <trans-unit id="cc85f8587031356b78b2448d63c222acc180e5f9" translate="yes" xml:space="preserve">
          <source>RSVP.EventTarget</source>
          <target state="translated">RSVP.EventTarget</target>
        </trans-unit>
        <trans-unit id="8c3018eec21a26738e481a8b5ea2b8b6ade95786" translate="yes" xml:space="preserve">
          <source>RSVP.Promise</source>
          <target state="translated">RSVP.Promise</target>
        </trans-unit>
        <trans-unit id="4e1ef1585228db21136c63e2c103fa2fc8cba9b0" translate="yes" xml:space="preserve">
          <source>RSVP.Promise&amp;lt;any&amp;gt;</source>
          <target state="translated">RSVP.Promise&amp;lt;any&amp;gt;</target>
        </trans-unit>
        <trans-unit id="02ed91fc301225e19af656a773481bbe02910c4f" translate="yes" xml:space="preserve">
          <source>RSVP.Promise&amp;lt;undefined&amp;gt;</source>
          <target state="translated">RSVP.Promise&amp;lt;undefined&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0e57c7077cfdd6dccd21781d8c00850d345148e3" translate="yes" xml:space="preserve">
          <source>Rather than create an arbitrary set of conventions, Ember Data is designed to work out of the box with &lt;a href=&quot;http://jsonapi.org&quot;&gt;JSON API&lt;/a&gt;. JSON API is a formal specification for building conventional, robust, and performant APIs that allow clients and servers to communicate model data.</source>
          <target state="translated">Ember Data并非创建任意的约定集，而是设计为使用&lt;a href=&quot;http://jsonapi.org&quot;&gt;JSON API即开即用&lt;/a&gt;。JSON API是用于构建常规，健壮和高性能的API的正式规范，该API允许客户端和服务器通信模型数据。</target>
        </trans-unit>
        <trans-unit id="20a3458f1862c89f455c490634fb5f573475fbc2" translate="yes" xml:space="preserve">
          <source>Rather than writing the higher level app code that internally invokes the various run loop scheduling functions, we have stripped away the covers, and shown the raw run-loop interactions.</source>
          <target state="translated">我们没有编写更高层次的应用代码,在内部调用各种运行循环调度函数,而是剥去了封面,展示了原始的运行循环交互。</target>
        </trans-unit>
        <trans-unit id="02143f2c5abf0fcc77c1815c31c2586f2ab77a8d" translate="yes" xml:space="preserve">
          <source>Re-route to the existing url</source>
          <target state="translated">重新路由到现有的网址</target>
        </trans-unit>
        <trans-unit id="c853a28871d264d43a0d86e34fdf1c1f3e7482f4" translate="yes" xml:space="preserve">
          <source>Readonly Nested Data</source>
          <target state="translated">只读嵌套数据</target>
        </trans-unit>
        <trans-unit id="b129f9f5e547d2585b00b80301e33d0ccd886142" translate="yes" xml:space="preserve">
          <source>Record States and Filtering</source>
          <target state="translated">记录状态和过滤</target>
        </trans-unit>
        <trans-unit id="779639f77d26423e55093890463c73df4117f2b4" translate="yes" xml:space="preserve">
          <source>RecordReference</source>
          <target state="translated">RecordReference</target>
        </trans-unit>
        <trans-unit id="e51c55255be9007d473b3c04b4553c2a27d6f03b" translate="yes" xml:space="preserve">
          <source>Records</source>
          <target state="translated">Records</target>
        </trans-unit>
        <trans-unit id="09f48f492f46fd16811c910592ad171170771ab8" translate="yes" xml:space="preserve">
          <source>Records in Ember Data are persisted on a per-instance basis. Call &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Model.html#method_save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; on any instance of &lt;code&gt;DS.Model&lt;/code&gt; and it will make a network request.</source>
          <target state="translated">Ember Data中的记录将按实例持久保存。在 &lt;code&gt;DS.Model&lt;/code&gt; 的任何实例上调用&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Model.html#method_save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt;，它将发出网络请求。</target>
        </trans-unit>
        <trans-unit id="93f89c3ab4a799a6a0aab99eb1bb7100ea88724d" translate="yes" xml:space="preserve">
          <source>Records that already exist on the backend are updated using the HTTP &lt;code&gt;PATCH&lt;/code&gt; verb.</source>
          <target state="translated">使用HTTP &lt;code&gt;PATCH&lt;/code&gt; 动词来更新后端上已经存在的记录。</target>
        </trans-unit>
        <trans-unit id="2f7c32c0b4917effc40dd0a0959efa8e648135b6" translate="yes" xml:space="preserve">
          <source>Records without an &lt;code&gt;id&lt;/code&gt; property are not considered embedded records, model instances must have an &lt;code&gt;id&lt;/code&gt; property to be used with Ember Data.</source>
          <target state="translated">没有 &lt;code&gt;id&lt;/code&gt; 属性的记录不被视为嵌入式记录，模型实例必须具有 &lt;code&gt;id&lt;/code&gt; 属性才能与Ember Data一起使用。</target>
        </trans-unit>
        <trans-unit id="5ac9a9807e12ead40a070a8626218b2274db6816" translate="yes" xml:space="preserve">
          <source>Recovering from Rejection</source>
          <target state="translated">从拒绝中恢复</target>
        </trans-unit>
        <trans-unit id="60e22121bdd0bc71cdb2bae2a3aa577006b2eae9" translate="yes" xml:space="preserve">
          <source>Redirecting</source>
          <target state="translated">Redirecting</target>
        </trans-unit>
        <trans-unit id="6bfa4764dfd3c083f396267379ee172ae1854a8d" translate="yes" xml:space="preserve">
          <source>Refer to documentation for &lt;code&gt;beforeModel&lt;/code&gt; for a description of transition-pausing semantics when a promise is returned from this hook.</source>
          <target state="translated">有关从该挂钩返回promise时过渡暂停语义的描述，请参考 &lt;code&gt;beforeModel&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="99f62095529c6af5ce3c4c2976cf5e8e543250eb" translate="yes" xml:space="preserve">
          <source>References to other records should be done by ID. For example, if you have a model with a &lt;code&gt;hasMany&lt;/code&gt; relationship:</source>
          <target state="translated">对其他记录的引用应通过ID完成。例如，如果您的模型具有 &lt;code&gt;hasMany&lt;/code&gt; 关系：</target>
        </trans-unit>
        <trans-unit id="69f6bad51245a7a68b6a5d503ecf8f42a933df09" translate="yes" xml:space="preserve">
          <source>Reflexive Relations</source>
          <target state="translated">反思性关系</target>
        </trans-unit>
        <trans-unit id="6224a939ef652c56dddd065c6b6575aface1416e" translate="yes" xml:space="preserve">
          <source>Refresh the model on this route and any child routes, firing the &lt;code&gt;beforeModel&lt;/code&gt;, &lt;code&gt;model&lt;/code&gt;, and &lt;code&gt;afterModel&lt;/code&gt; hooks in a similar fashion to how routes are entered when transitioning in from other route. The current route params (e.g. &lt;code&gt;article_id&lt;/code&gt;) will be passed in to the respective model hooks, and if a different model is returned, &lt;code&gt;setupController&lt;/code&gt; and associated route hooks will re-fire as well.</source>
          <target state="translated">刷新此路线和所有 &lt;code&gt;beforeModel&lt;/code&gt; &lt;code&gt;model&lt;/code&gt; ，以类似于从其他路线过渡时输入路线的方式触发beforeModel，model和 &lt;code&gt;afterModel&lt;/code&gt; 挂钩。当前的路由参数（例如 &lt;code&gt;article_id&lt;/code&gt; ）将传递到相应的模型钩子中，如果返回了不同的模型， &lt;code&gt;setupController&lt;/code&gt; 和关联的路由钩子也会重新触发。</target>
        </trans-unit>
        <trans-unit id="ca5db4fe93ba98fe1b576309acf2388052f2a36a" translate="yes" xml:space="preserve">
          <source>RegExp</source>
          <target state="translated">RegExp</target>
        </trans-unit>
        <trans-unit id="06b326b8df4964d11fe7f98ffc257e678212ac9e" translate="yes" xml:space="preserve">
          <source>Regardless of how the URL becomes set, the Ember router then maps the current URL to one or more route handlers. A route handler can do several things:</source>
          <target state="translated">无论URL如何设置,Ember路由器都会将当前URL映射到一个或多个路由处理程序。一个路由处理程序可以做几件事。</target>
        </trans-unit>
        <trans-unit id="13ef3793fbf15d676e0da171536ccb7a8b55c72a" translate="yes" xml:space="preserve">
          <source>Regardless of the serializer used, this metadata is extracted from the response. You can then read it with &lt;code&gt;.get('meta')&lt;/code&gt;.</source>
          <target state="translated">无论使用哪种序列化程序，都将从响应中提取此元数据。然后，您可以使用 &lt;code&gt;.get('meta')&lt;/code&gt; 阅读它。</target>
        </trans-unit>
        <trans-unit id="580b18a39e5b39765415c0eed123af6da265aa11" translate="yes" xml:space="preserve">
          <source>Register options for a particular factory.</source>
          <target state="translated">注册特定工厂的选项。</target>
        </trans-unit>
        <trans-unit id="6291ba0522621d5582aa26e4decc87be7d141a60" translate="yes" xml:space="preserve">
          <source>Register/Unregister additional test helpers.</source>
          <target state="translated">注册/取消注册其他测试助手。</target>
        </trans-unit>
        <trans-unit id="57ac94516e6ba3226fa58ffc652e3e7312c91e5d" translate="yes" xml:space="preserve">
          <source>Registered factories are &lt;strong&gt;instantiated&lt;/strong&gt; by having &lt;code&gt;create&lt;/code&gt; called on them. Additionally they are &lt;strong&gt;singletons&lt;/strong&gt;, each time they are looked up they return the same instance.</source>
          <target state="translated">已注册的工厂通过调用 &lt;code&gt;create&lt;/code&gt; 来&lt;strong&gt;实例化&lt;/strong&gt;。此外，它们是&lt;strong&gt;单例&lt;/strong&gt;，每次查找时，它们都返回相同的实例。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="63c9b0772d57be72a0c5d903431a873fcdb8a6f2" translate="yes" xml:space="preserve">
          <source>Registering Already Instantiated Objects</source>
          <target state="translated">注册已经实例化的对象</target>
        </trans-unit>
        <trans-unit id="4e4aa5ae30460fc62431c4dbebe42f4477bbe300" translate="yes" xml:space="preserve">
          <source>Registering Singletons vs. Non-Singletons</source>
          <target state="translated">注册单子与非单子。</target>
        </trans-unit>
        <trans-unit id="aba41c3a5d53b4b36fb1b8a0fdb902b0488d3a7a" translate="yes" xml:space="preserve">
          <source>Registering a Library</source>
          <target state="translated">注册图书馆</target>
        </trans-unit>
        <trans-unit id="0803d3a3d9f15e36c86ae2132d20124795a72459" translate="yes" xml:space="preserve">
          <source>Registers a factory that can be used for dependency injection (with &lt;code&gt;inject&lt;/code&gt;) or for service lookup. Each factory is registered with a full name including two parts: &lt;code&gt;type:name&lt;/code&gt;.</source>
          <target state="translated">注册一个工厂，该工厂可用于依赖项注入（带有 &lt;code&gt;inject&lt;/code&gt; ）或用于服务查找。每个工厂都注册有全名，包括两个部分： &lt;code&gt;type:name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f7e42ab82b7c92882f8e66014048c4f809e7e13" translate="yes" xml:space="preserve">
          <source>Registration keys have two segments split by a colon (&lt;code&gt;:&lt;/code&gt;). The first segment is the framework factory type, and the second is the name of the particular factory. Hence, the &lt;code&gt;index&lt;/code&gt; template has the key &lt;code&gt;template:index&lt;/code&gt;. Ember has several built-in factory types, such as &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;route&lt;/code&gt;, &lt;code&gt;template&lt;/code&gt;, and &lt;code&gt;component&lt;/code&gt;.</source>
          <target state="translated">登记键有一个冒号分开两个段（ &lt;code&gt;:&lt;/code&gt; ）。第一部分是框架工厂类型，第二部分是特定工厂的名称。因此， &lt;code&gt;index&lt;/code&gt; 模板具有键 &lt;code&gt;template:index&lt;/code&gt; 。Ember具有几种内置的工厂类型，例如 &lt;code&gt;service&lt;/code&gt; ， &lt;code&gt;route&lt;/code&gt; ， &lt;code&gt;template&lt;/code&gt; 和 &lt;code&gt;component&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74bb08da802a694a3d25bf4c3835ded58d2f6fc6" translate="yes" xml:space="preserve">
          <source>RegistryProxy</source>
          <target state="translated">RegistryProxy</target>
        </trans-unit>
        <trans-unit id="0a580368138bbedf511a06592637b0c30c98bec4" translate="yes" xml:space="preserve">
          <source>RegistryProxyMixin</source>
          <target state="translated">RegistryProxyMixin</target>
        </trans-unit>
        <trans-unit id="63a6a6ef6785a3cb9c1352a24ea4357d90e0f58f" translate="yes" xml:space="preserve">
          <source>RegistryProxyMixin  (private)</source>
          <target state="translated">RegistryProxyMixin (私人)</target>
        </trans-unit>
        <trans-unit id="0db97526891b25965235d31bf6cc3d8269a10d30" translate="yes" xml:space="preserve">
          <source>RegistryProxyMixin is used to provide public access to specific registry functionality.</source>
          <target state="translated">RegistryProxyMixin用于提供对特定注册表功能的公共访问。</target>
        </trans-unit>
        <trans-unit id="5f5b133edab536327af2bd039bb8a3451c0c686b" translate="yes" xml:space="preserve">
          <source>Rejected model promises halt transitions, but because promises are chainable, you can catch promise rejects within the &lt;code&gt;model&lt;/code&gt; hook itself and convert them into fulfills that won't halt the transition.</source>
          <target state="translated">拒绝的模型承诺会终止转换，但是由于承诺是可链接的，因此您可以在 &lt;code&gt;model&lt;/code&gt; 挂钩本身中捕获承诺拒绝，并将它们转换为不会停止过渡的实现。</target>
        </trans-unit>
        <trans-unit id="229981dd1dc44fcc3bf72493583bb63fa236cecf" translate="yes" xml:space="preserve">
          <source>Relationships</source>
          <target state="translated">Relationships</target>
        </trans-unit>
        <trans-unit id="7ebee1cc4a1ef9624d817353b136be3fe22ab7fc" translate="yes" xml:space="preserve">
          <source>Relationships are usually represented by ids to the record in the relationship. The related records can then be sideloaded in the response under a key for the type.</source>
          <target state="translated">关系通常由关系中的记录的id来表示。然后,相关的记录可以在响应中侧载到类型的键下。</target>
        </trans-unit>
        <trans-unit id="d4abfee2fa163eac14a7ded7bb1fdab42b33f49a" translate="yes" xml:space="preserve">
          <source>Relationships as Promises</source>
          <target state="translated">作为承诺的关系</target>
        </trans-unit>
        <trans-unit id="282e0c1116f45802ea510d978c4bb1aaeda3e638" translate="yes" xml:space="preserve">
          <source>Reload the record from the adapter.</source>
          <target state="translated">从适配器上重新加载记录。</target>
        </trans-unit>
        <trans-unit id="b9032b6f32f6e2281f4ae7c18e28a848286c6415" translate="yes" xml:space="preserve">
          <source>Reloading</source>
          <target state="translated">Reloading</target>
        </trans-unit>
        <trans-unit id="4d8114b387125160739c4384d9e4a3715ae113c8" translate="yes" xml:space="preserve">
          <source>Reloads all of the records in the manyArray. If the manyArray holds a relationship that was originally fetched using a links url Ember Data will revisit the original links url to repopulate the relationship.</source>
          <target state="translated">重新加载manyArray中的所有记录。如果manyArray持有一个最初使用链接网址获取的关系,Ember Data将重新访问最初的链接网址来重新填充关系。</target>
        </trans-unit>
        <trans-unit id="d6324829793579791ae457de1efbafabdce16f68" translate="yes" xml:space="preserve">
          <source>Reloads the record if it is already loaded. If the record is not loaded it will load the record via &lt;code&gt;store.findRecord&lt;/code&gt;</source>
          <target state="translated">重新加载记录（如果已加载）。如果未加载记录， &lt;code&gt;store.findRecord&lt;/code&gt; 通过store.findRecord加载记录</target>
        </trans-unit>
        <trans-unit id="5bd1485c9bed37c1cf2bf2094bc180edee39e981" translate="yes" xml:space="preserve">
          <source>Reloads this has-many relationship.</source>
          <target state="translated">重新加载这个has-many关系。</target>
        </trans-unit>
        <trans-unit id="f4276922880097708e01378b7c926ae47b0ca730" translate="yes" xml:space="preserve">
          <source>Relying on autoruns is not a rigorous or efficient way to use the run loop. Wrapping event handlers manually are preferred.</source>
          <target state="translated">依靠自动运行并不是使用运行循环的严格或有效方式。最好是手动封装事件处理程序。</target>
        </trans-unit>
        <trans-unit id="4656fc9d7b003300b618f2b5e454b26fe556d1b6" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;{{firstName}}&lt;/code&gt; and &lt;code&gt;{{lastName}}&lt;/code&gt; are bound data. That means if the value of one of those properties changes, the DOM will be updated automatically.</source>
          <target state="translated">请记住， &lt;code&gt;{{firstName}}&lt;/code&gt; 和 &lt;code&gt;{{lastName}}&lt;/code&gt; 是绑定数据。这意味着，如果这些属性之一的值更改，则DOM将自动更新。</target>
        </trans-unit>
        <trans-unit id="685e29f4b662e2c0f1a0744e653894d1da2671ad" translate="yes" xml:space="preserve">
          <source>Remember that &lt;em&gt;only events&lt;/em&gt; should ever cause a state transition. You should never call &lt;code&gt;transitionTo()&lt;/code&gt; from outside a state's event handler. If you are tempted to do so, create a new event and send that to the state manager.</source>
          <target state="translated">请记住，&lt;em&gt;只有事件&lt;/em&gt;才能引起状态转换。您永远不要从状态的事件处理程序外部调用 &lt;code&gt;transitionTo()&lt;/code&gt; 。如果您愿意这样做，请创建一个新事件并将其发送给状态管理器。</target>
        </trans-unit>
        <trans-unit id="2772f3979b8490dfd9afc9103221e01e92eba84f" translate="yes" xml:space="preserve">
          <source>Remove a previously added helper method.</source>
          <target state="translated">删除之前添加的帮助方法。</target>
        </trans-unit>
        <trans-unit id="6c924c7cc754f0fab9bce280a8c42f9e3cff21cd" translate="yes" xml:space="preserve">
          <source>Remove all elements from the array. This is useful if you want to reuse an existing array without having to recreate it.</source>
          <target state="translated">从数组中删除所有元素。如果你想重复使用一个现有的数组而不需要重新创建它,这很有用。</target>
        </trans-unit>
        <trans-unit id="f6355dee47de1f32bf6f9799d78b6fee6bcd492e" translate="yes" xml:space="preserve">
          <source>Remove all occurrences of an object in the array.</source>
          <target state="translated">删除数组中所有对象的出现。</target>
        </trans-unit>
        <trans-unit id="152c1eaa085138cfa9d77a0942ce9534a3d76fe7" translate="yes" xml:space="preserve">
          <source>Remove an event listener</source>
          <target state="translated">移除事件监听器</target>
        </trans-unit>
        <trans-unit id="4aa91b51bc12a3f5d89e5b53340b91ffc806cb11" translate="yes" xml:space="preserve">
          <source>Remove an object at the specified index using the &lt;code&gt;replace()&lt;/code&gt; primitive method. You can pass either a single index, or a start and a length.</source>
          <target state="translated">使用 &lt;code&gt;replace()&lt;/code&gt; 基本方法删除指定索引处的对象。您可以传递单个索引，也可以传递起点和长度。</target>
        </trans-unit>
        <trans-unit id="b8553b7b30d27bd6e52896284d645032511283c5" translate="yes" xml:space="preserve">
          <source>Remove an observer you have previously registered on this object. Pass the same key, target, and method you passed to &lt;code&gt;addObserver()&lt;/code&gt; and your target will no longer receive notifications.</source>
          <target state="translated">删除您先前在该对象上注册的观察者。传递与传递给 &lt;code&gt;addObserver()&lt;/code&gt; 相同的键，目标和方法，目标将不再接收通知。</target>
        </trans-unit>
        <trans-unit id="1fff707f00d08e1f5dfe2689260813207706b7e3" translate="yes" xml:space="preserve">
          <source>Removes an array observer from the object if the observer is current registered. Calling this method multiple times with the same object will have no effect.</source>
          <target state="translated">如果数组观察者是当前注册的,则从对象中删除该观察者。对同一对象多次调用此方法将不会有任何影响。</target>
        </trans-unit>
        <trans-unit id="18f9a7bd887e2ad04e12b6586614eadc5a5bf73f" translate="yes" xml:space="preserve">
          <source>Removes each object in the passed enumerable from the receiver.</source>
          <target state="translated">从接收器中删除传递的枚举对象。</target>
        </trans-unit>
        <trans-unit id="53ebb1fef0864af0278ae31f4ac0ec30dc3e82ad" translate="yes" xml:space="preserve">
          <source>Removing Objects</source>
          <target state="translated">移除对象</target>
        </trans-unit>
        <trans-unit id="6d84c2db53b8c4b4553001a5c3d3b995a8fc5d9b" translate="yes" xml:space="preserve">
          <source>Removing Relationships</source>
          <target state="translated">移除关系</target>
        </trans-unit>
        <trans-unit id="041f6ca8e2d2dc5b856e1d078db74ba2885f4518" translate="yes" xml:space="preserve">
          <source>Rendering Performance</source>
          <target state="translated">渲染性能</target>
        </trans-unit>
        <trans-unit id="0985a0ecfabc2231124bd8de762617aaeafd5bd5" translate="yes" xml:space="preserve">
          <source>Rendering a Template</source>
          <target state="translated">渲染模板</target>
        </trans-unit>
        <trans-unit id="3bf2cfd82c10e27a15ca73d1aff040c4b9aabd81" translate="yes" xml:space="preserve">
          <source>Renders the view again. This will work regardless of whether the view is already in the DOM or not. If the view is in the DOM, the rendering process will be deferred to give bindings a chance to synchronize.</source>
          <target state="translated">再次渲染视图。无论视图是否已经在DOM中,这都是有效的。如果视图在DOM中,渲染过程将被推迟,以便给绑定一个同步的机会。</target>
        </trans-unit>
        <trans-unit id="90fcf58a93bf37c133e53c27b59ac552b7f86095" translate="yes" xml:space="preserve">
          <source>Reopening Classes and Instances</source>
          <target state="translated">重开类和实例</target>
        </trans-unit>
        <trans-unit id="68fd737319a0b0cb58525f439e8f98a23d49c821" translate="yes" xml:space="preserve">
          <source>Replace all the receiver's content with content of the argument. If argument is an empty array receiver will be cleared.</source>
          <target state="translated">用参数的内容替换接收器的所有内容。如果参数是一个空数组,接收器将被清空。</target>
        </trans-unit>
        <trans-unit id="12205427cfdf5328a7ffdc0d916e8bdc2aeef4ed" translate="yes" xml:space="preserve">
          <source>Replacement for &lt;code&gt;Ember.RSVP.resolve&lt;/code&gt; The only difference is this uses an instance of &lt;code&gt;Ember.Test.Promise&lt;/code&gt;</source>
          <target state="translated">替换为 &lt;code&gt;Ember.RSVP.resolve&lt;/code&gt; 唯一的区别是，这使用了一个 &lt;code&gt;Ember.Test.Promise&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="38df34ec5043e01b14b58ab782972627050d5e4e" translate="yes" xml:space="preserve">
          <source>Replaces underscores, spaces, or camelCase with dashes.</source>
          <target state="translated">用破折号代替下划线、空格或大写字母。</target>
        </trans-unit>
        <trans-unit id="551c187c4562e07235299d81c81fb5553d3be6b8" translate="yes" xml:space="preserve">
          <source>Replacing history entries</source>
          <target state="translated">替换历史条目</target>
        </trans-unit>
        <trans-unit id="db33df2b86e0548c5026c0e2feca083dd46c73b8" translate="yes" xml:space="preserve">
          <source>Reporting a problem</source>
          <target state="translated">报告问题</target>
        </trans-unit>
        <trans-unit id="5a3259ad102284e341592f2a49ccbc5935cfc92a" translate="yes" xml:space="preserve">
          <source>Represents a list of records whose membership is determined by the store. As records are created, loaded, or modified, the store evaluates them to determine if they should be part of the record array.</source>
          <target state="translated">表示记录的列表,其成员资格由存储决定。当记录被创建、加载或修改时,存储会对它们进行评估,以确定它们是否应该成为记录数组的一部分。</target>
        </trans-unit>
        <trans-unit id="97471577bb242ec38248e3746d99aa261e14fdfd" translate="yes" xml:space="preserve">
          <source>Represents an ordered list of records whose order and membership is determined by the adapter. For example, a query sent to the adapter may trigger a search on the server, whose results would be loaded into an instance of the &lt;code&gt;AdapterPopulatedRecordArray&lt;/code&gt;.</source>
          <target state="translated">表示记录的有序列表，其顺序和成员资格由适配器确定。例如，发送给适配器的查询可能会触发服务器上的搜索，其结果将被加载到 &lt;code&gt;AdapterPopulatedRecordArray&lt;/code&gt; 的实例中。</target>
        </trans-unit>
        <trans-unit id="f983e24377129faa7d20942c23e23254dfe09a06" translate="yes" xml:space="preserve">
          <source>Represents the URL of the root of the application, often '/'. This prefix is assumed on all routes defined on this router.</source>
          <target state="translated">代表应用程序根的URL,通常是'/'。该路由器上定义的所有路由都使用这个前缀。</target>
        </trans-unit>
        <trans-unit id="99a531ee74a48c9f139d54302917c31212c36e9a" translate="yes" xml:space="preserve">
          <source>Represents the model's class name as a string. This can be used to look up the model's class name through &lt;code&gt;DS.Store&lt;/code&gt;'s modelFor method.</source>
          <target state="translated">将模型的类名称表示为字符串。这可以用于通过 &lt;code&gt;DS.Store&lt;/code&gt; 的modelFor方法查找模型的类名。</target>
        </trans-unit>
        <trans-unit id="6a446bfa5dd57c064db5b7db62b9216d2d4fe7f6" translate="yes" xml:space="preserve">
          <source>Requests for &lt;code&gt;person&lt;/code&gt; would now target &lt;code&gt;/person/1&lt;/code&gt;. Requests for &lt;code&gt;user-profile&lt;/code&gt; would now target &lt;code&gt;/user_profile/1&lt;/code&gt;.</source>
          <target state="translated">现在，请求 &lt;code&gt;person&lt;/code&gt; 的目标是 &lt;code&gt;/person/1&lt;/code&gt; 。现在，对 &lt;code&gt;user-profile&lt;/code&gt; 请求将以 &lt;code&gt;/user_profile/1&lt;/code&gt; 为目标。</target>
        </trans-unit>
        <trans-unit id="e23fb7f5045063dea88f661c92bdf8761f6d2db8" translate="yes" xml:space="preserve">
          <source>Requests for &lt;code&gt;person&lt;/code&gt; would now target &lt;code&gt;http://emberjs.com/api/1/people/1&lt;/code&gt;.</source>
          <target state="translated">现在，对 &lt;code&gt;person&lt;/code&gt; 请求将定位为 &lt;code&gt;http://emberjs.com/api/1/people/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbed8372b111ece5b7dea26366e56a504eeb78ba" translate="yes" xml:space="preserve">
          <source>Requests for &lt;code&gt;person&lt;/code&gt; would now target &lt;code&gt;https://api.example.com/people/1&lt;/code&gt;.</source>
          <target state="translated">现在，针对 &lt;code&gt;person&lt;/code&gt; 请求将定位到 &lt;code&gt;https://api.example.com/people/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39adf7b336b15481b1d246e2d2e38d4faf23c063" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;Person&lt;/code&gt; model would now target &lt;code&gt;/api/1/people/1&lt;/code&gt;.</source>
          <target state="translated">现在，对 &lt;code&gt;Person&lt;/code&gt; 模型的请求将定位 &lt;code&gt;/api/1/people/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5a6ae7596913135d59e602a8445cd7c591187b4" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;Post&lt;/code&gt; model would now target &lt;code&gt;/api/1/post/&lt;/code&gt;.</source>
          <target state="translated">现在，对 &lt;code&gt;Post&lt;/code&gt; 模型的请求将定位 &lt;code&gt;/api/1/post/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47352f3ca02fa7dd1203791432c99adf3ee88922" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;Post&lt;/code&gt; model would now target &lt;code&gt;https://api.example.com/post/&lt;/code&gt;.</source>
          <target state="translated">现在，对 &lt;code&gt;Post&lt;/code&gt; 模型的请求将定位到 &lt;code&gt;https://api.example.com/post/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="507eba662c0bdfc5e6dcd2e527c591cbe849d43c" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;person&lt;/code&gt; model would now target &lt;code&gt;/api/1/people/1&lt;/code&gt;.</source>
          <target state="translated">现在，针对 &lt;code&gt;person&lt;/code&gt; 模型的请求将定位 &lt;code&gt;/api/1/people/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c77ddbd00374e8cd6c0cc4272b91fdfbb3d601e3" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;person&lt;/code&gt; model would now target &lt;code&gt;https://api.example.com/people/1&lt;/code&gt;.</source>
          <target state="translated">现在，针对 &lt;code&gt;person&lt;/code&gt; 模型的请求将定位为 &lt;code&gt;https://api.example.com/people/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d1ce0dbae3dcf8f899bd4893d4663dda4cf2c7d" translate="yes" xml:space="preserve">
          <source>Rerun your test suite as you make updates to your workflow file and you should validate that your deprecations are gone. Once that is completed, you can proceed with enhancing your application without the sea of deprecation warnings clouding your log.</source>
          <target state="translated">当你对工作流文件进行更新时,重新运行你的测试套件,你应该会确认你的废弃文件已经消失了。一旦完成,你就可以继续增强你的应用程序,而不用再被海量的弃用警告所困扰。</target>
        </trans-unit>
        <trans-unit id="1459337c0ecc835d1d2041391957329cf96ed92d" translate="yes" xml:space="preserve">
          <source>Reset the application. This is typically used only in tests. It cleans up the application in the following order:</source>
          <target state="translated">重置应用程序。这通常只在测试中使用。它按以下顺序清理应用程序。</target>
        </trans-unit>
        <trans-unit id="9799189643ce709a24fb886e74561834ed7c1a6f" translate="yes" xml:space="preserve">
          <source>Resetting Presentation State on Attribute Change with &lt;code&gt;didUpdateAttrs&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;didUpdateAttrs&lt;/code&gt; 在属性更改上重置演示状态</target>
        </trans-unit>
        <trans-unit id="14de0ea979680e88715bf0fb25e6a27c36244df1" translate="yes" xml:space="preserve">
          <source>Responding to Browser Events</source>
          <target state="translated">响应浏览器事件</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="5dd10def5c86f482d9171ac3d500c6b0ae25364b" translate="yes" xml:space="preserve">
          <source>Resumes a test paused by &lt;code&gt;pauseTest&lt;/code&gt;.</source>
          <target state="translated">恢复由 &lt;code&gt;pauseTest&lt;/code&gt; 暂停的测试。</target>
        </trans-unit>
        <trans-unit id="c136ec01ad8662f631bfe9cf5dd76daebe9695f1" translate="yes" xml:space="preserve">
          <source>Retrieves the value of a property from an Object, or a default value in the case that the property returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">从Object检索属性的值，如果属性返回 &lt;code&gt;undefined&lt;/code&gt; ，则检索默认值。</target>
        </trans-unit>
        <trans-unit id="97f8358f1a7527129a6026137d59d3b142bea4da" translate="yes" xml:space="preserve">
          <source>Retrieves the value of a property from the object.</source>
          <target state="translated">检索对象的属性值。</target>
        </trans-unit>
        <trans-unit id="c2507d71833d1926fc8ca2bfcba6650b2356a523" translate="yes" xml:space="preserve">
          <source>Retrieves the value of a property, or a default value in the case that the property returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">检索属性的值，如果属性返回 &lt;code&gt;undefined&lt;/code&gt; ，则检索默认值。</target>
        </trans-unit>
        <trans-unit id="c9b109a01cbb856b78796ff1f23e3ed037d6d59e" translate="yes" xml:space="preserve">
          <source>Retrieving Multiple Records</source>
          <target state="translated">检索多个记录</target>
        </trans-unit>
        <trans-unit id="f585070c87519f1f46d5aa282e338ef3ef4cffe8" translate="yes" xml:space="preserve">
          <source>Retrieving Related Model Records</source>
          <target state="translated">检索相关模型记录</target>
        </trans-unit>
        <trans-unit id="5763b513c21e726fa47e619aeec98e7a63c47120" translate="yes" xml:space="preserve">
          <source>Retrieving Related Records</source>
          <target state="translated">检索相关记录</target>
        </trans-unit>
        <trans-unit id="3ea11ae149c9ff5b4ef4d8e06d23a82d3df6baab" translate="yes" xml:space="preserve">
          <source>Retrieving a Single Record</source>
          <target state="translated">检索单个记录</target>
        </trans-unit>
        <trans-unit id="9cd9632ea5c6744340a949d9498150ea0dd8d956" translate="yes" xml:space="preserve">
          <source>Return a specific registered option for a particular factory.</source>
          <target state="translated">返回特定工厂的特定注册选项。</target>
        </trans-unit>
        <trans-unit id="29ebe6c216062fb1ce4cf798a7f1e3baeab920a9" translate="yes" xml:space="preserve">
          <source>Return registered options for a particular factory.</source>
          <target state="translated">返回特定工厂的注册选项。</target>
        </trans-unit>
        <trans-unit id="26b22776384430c648a6b859ff17b84f59ea040d" translate="yes" xml:space="preserve">
          <source>Return the new cumulative value.</source>
          <target state="translated">返回新的累积值。</target>
        </trans-unit>
        <trans-unit id="edee4fec8219eea58f41fb844b109d44f9727045" translate="yes" xml:space="preserve">
          <source>Return the registered options for all factories of a type.</source>
          <target state="translated">返回一个类型的所有工厂的注册选项。</target>
        </trans-unit>
        <trans-unit id="3f2c37eae2ce5f96df692aaeedf57af072ef9d9e" translate="yes" xml:space="preserve">
          <source>Return to Step 1</source>
          <target state="translated">返回步骤1</target>
        </trans-unit>
        <trans-unit id="86661c3a6c5cd6befa4e37cc90df459f0d9bf691" translate="yes" xml:space="preserve">
          <source>Return value from invoking the passed function. Please note, when called within an existing loop, no return value is possible.</source>
          <target state="translated">调用传递的函数的返回值。请注意,在现有循环中调用时,不可能返回值。</target>
        </trans-unit>
        <trans-unit id="19e15fef1135e42fb3ddbd944fd5ba42b4c44461" translate="yes" xml:space="preserve">
          <source>Return values from a component with &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">从具有 &lt;code&gt;yield&lt;/code&gt; 的组件返回值</target>
        </trans-unit>
        <trans-unit id="f303cd37013bf328626e038174b28974872e0cbc" translate="yes" xml:space="preserve">
          <source>Returning a &lt;code&gt;DS.InvalidError&lt;/code&gt; from this method will cause the record to transition into the &lt;code&gt;invalid&lt;/code&gt; state and make the &lt;code&gt;errors&lt;/code&gt; object available on the record. When returning an &lt;code&gt;DS.InvalidError&lt;/code&gt; the store will attempt to normalize the error data returned from the server using the serializer's &lt;code&gt;extractErrors&lt;/code&gt; method.</source>
          <target state="translated">从此方法返回 &lt;code&gt;DS.InvalidError&lt;/code&gt; 将导致记录转换为 &lt;code&gt;invalid&lt;/code&gt; 状态，并使 &lt;code&gt;errors&lt;/code&gt; 对象在记录上可用。返回 &lt;code&gt;DS.InvalidError&lt;/code&gt; 时，存储区将尝试使用序列化程序的 &lt;code&gt;extractErrors&lt;/code&gt; 方法来标准化从服务器返回的错误数据。</target>
        </trans-unit>
        <trans-unit id="85b812af2c70b17fb4a0e4704404e2e2663bc781" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed function returns true for any item in the enumeration.</source>
          <target state="translated">如果传递的函数对枚举中的任何项目返回 &lt;code&gt;true&lt;/code&gt; ,则返回true。</target>
        </trans-unit>
        <trans-unit id="0ca1e9e1279673b31d55774d9185dc03beed7b19" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed function returns true for every item in the enumeration. This corresponds with the &lt;code&gt;every()&lt;/code&gt; method in JavaScript 1.6.</source>
          <target state="translated">如果传递的函数对枚举中的每个项目都返回 &lt;code&gt;true&lt;/code&gt; ,则返回true。这与JavaScript 1.6中的 &lt;code&gt;every()&lt;/code&gt; 方法相对应。</target>
        </trans-unit>
        <trans-unit id="48e8bff0730db4951905ce3907f251ae28d439c0" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed object can be found in the array. This method is a Polyfill for ES 2016 Array.includes. If no &lt;code&gt;startAt&lt;/code&gt; argument is given, the starting location to search is 0. If it's negative, searches from the index of &lt;code&gt;this.length + startAt&lt;/code&gt; by asc.</source>
          <target state="translated">如果可以在数组中找到传递的对象，则返回 &lt;code&gt;true&lt;/code&gt; 。此方法是ES 2016 Array.includes的Polyfill。如果未给出 &lt;code&gt;startAt&lt;/code&gt; 参数，则搜索的起始位置为0。如果为负，则从 &lt;code&gt;this.length + startAt&lt;/code&gt; 的索引中按asc搜索。</target>
        </trans-unit>
        <trans-unit id="97d2d4c6d57998537e2ece3978bd7eda8781ffbc" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed object can be found in the enumerable.</source>
          <target state="translated">如果可以在枚举中找到传递的对象，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e0cff20c4e03c114bb589de045dad56c4977ab9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed property resolves to the value of the second argument for all items in the enumerable. This method is often simpler/faster than using a callback.</source>
          <target state="translated">如果传递的属性解析为可枚举中所有项目的第二个参数的值，则返回 &lt;code&gt;true&lt;/code&gt; 。与使用回调相比，此方法通常更简单/更快。</target>
        </trans-unit>
        <trans-unit id="785710d311908f0da91ca0999d02fda0b1b3f90e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed property resolves to the value of the second argument for any item in the enumerable. This method is often simpler/faster than using a callback.</source>
          <target state="translated">如果传递的属性解析为可枚举中任何项目的第二个参数的值，则返回 &lt;code&gt;true&lt;/code&gt; 。与使用回调相比，此方法通常更简单/更快。</target>
        </trans-unit>
        <trans-unit id="125bbdbd31c014a3c75ab73874ead547c5f9f32b" translate="yes" xml:space="preserve">
          <source>Returns a consistent type for the passed object.</source>
          <target state="translated">返回传递对象的一致类型。</target>
        </trans-unit>
        <trans-unit id="d5e31a7796519c4db2aefafeb16832aabfafcd9e" translate="yes" xml:space="preserve">
          <source>Returns a copy of the array with all &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; elements removed.</source>
          <target state="translated">返回删除了所有 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 元素的数组的副本。</target>
        </trans-unit>
        <trans-unit id="2b92287589187fde80aa3c9745f11bf4566c0019" translate="yes" xml:space="preserve">
          <source>Returns a hash containing the parameters of an ancestor route.</source>
          <target state="translated">返回一个包含祖先路由参数的哈希值。</target>
        </trans-unit>
        <trans-unit id="2703351044d1524246ab647abe9d450da6a2453f" translate="yes" xml:space="preserve">
          <source>Returns a jQuery object for this component's element. If you pass in a selector string, this method will return a jQuery object, using the current element as its buffer. For example, calling &lt;code&gt;component.$('li')&lt;/code&gt; will return a jQuery object containing all of the &lt;code&gt;li&lt;/code&gt; elements inside the DOM element of this component.</source>
          <target state="translated">返回此组件元素的jQuery对象。如果传入选择器字符串，则此方法将返回jQuery对象，并使用当前元素作为其缓冲区。例如，调用 &lt;code&gt;component.$('li')&lt;/code&gt; 将返回一个jQuery对象，其中包含该组件DOM元素内的所有 &lt;code&gt;li&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="8a47cf2c5ff6ea84daf5839f6f90517c7d1d2ada" translate="yes" xml:space="preserve">
          <source>Returns a jQuery object for this view's element. If you pass in a selector string, this method will return a jQuery object, using the current element as its buffer.</source>
          <target state="translated">返回此视图元素的jQuery对象。如果传入选择器字符串,本方法将返回一个jQuery对象,使用当前元素作为缓冲区。</target>
        </trans-unit>
        <trans-unit id="926fcdedb193ee950b728d011e0592df4e16f0a0" translate="yes" xml:space="preserve">
          <source>Returns a new array that is a slice of the receiver. This implementation uses the observable array methods to retrieve the objects for the new slice.</source>
          <target state="translated">返回一个新的数组,它是接收器的一个分片。本实现使用observable数组方法为新的分片检索对象。</target>
        </trans-unit>
        <trans-unit id="f490c002b2bf76e65c1ef0218a8c11e0b2f0ba00" translate="yes" xml:space="preserve">
          <source>Returns a new enumerable that contains only items containing a unique property value. The default implementation returns an array regardless of the receiver type.</source>
          <target state="translated">返回一个新的数组,它只包含包含唯一属性值的项目。默认的实现返回一个数组,与接收者类型无关。</target>
        </trans-unit>
        <trans-unit id="bdd3af7ab7b2da54382d05f7328e37ab891fb2d3" translate="yes" xml:space="preserve">
          <source>Returns a new enumerable that contains only unique values. The default implementation returns an array regardless of the receiver type.</source>
          <target state="translated">返回一个只包含唯一值的新枚举。默认的实现是返回一个数组,而不考虑接收器的类型。</target>
        </trans-unit>
        <trans-unit id="31c2891af58e7eda6b60e3cadcd876d663730e1c" translate="yes" xml:space="preserve">
          <source>Returns a new enumerable that excludes the passed value. The default implementation returns an array regardless of the receiver type. If the receiver does not contain the value it returns the original enumerable.</source>
          <target state="translated">返回一个新的不包含传递值的枚举值。默认的实现返回一个数组,而不考虑接收者的类型。如果接收方不包含值,则返回原来的枚举值。</target>
        </trans-unit>
        <trans-unit id="79b5522f2b1ae4f90cc466e02013320e2a3ad2b8" translate="yes" xml:space="preserve">
          <source>Returns a polymorphic relationship formatted as a JSON-API &quot;relationship object&quot;.</source>
          <target state="translated">Returns a polymorphic relationship formatted as a JSON-API &quot;relation object&quot;.</target>
        </trans-unit>
        <trans-unit id="da5d72f3f51387291e0c92700f8ccbb22c667d59" translate="yes" xml:space="preserve">
          <source>Returns a promise that is fulfilled when all the given promises have been fulfilled, or rejected if any of them become rejected. The returned promise is fulfilled with a hash that has the same key names as the &lt;code&gt;promises&lt;/code&gt; object argument. If any of the values in the object are not promises, they will simply be copied over to the fulfilled object.</source>
          <target state="translated">返回当所有给定的诺言都已兑现时已兑现的诺言，或者如果其中任何一个诺言被拒绝，则将其拒绝。返回的promise通过哈希实现，该哈希具有与 &lt;code&gt;promises&lt;/code&gt; 对象参数相同的键名。如果对象中的任何值都不是promise，则将它们简单地复制到实现的对象中。</target>
        </trans-unit>
        <trans-unit id="82c815d0ca08ef29364305f689eaaae5497c95e1" translate="yes" xml:space="preserve">
          <source>Returns a promise that is fulfilled when all the given promises have been settled, or rejected if the passed parameters are invalid.</source>
          <target state="translated">当所有给定的承诺都被解决后,返回一个承诺,如果传递的参数无效,则返回拒绝。</target>
        </trans-unit>
        <trans-unit id="6d3f9c4b4397f9ef81ee1535035150e16652f8d6" translate="yes" xml:space="preserve">
          <source>Returns a promise that is fulfilled when all the given promises have been settled. The return promise is fulfilled with an array of the states of the promises passed into the &lt;code&gt;promises&lt;/code&gt; array argument.</source>
          <target state="translated">返回已兑现所有给定诺言的诺言。返回承诺通过将 &lt;code&gt;promises&lt;/code&gt; 数组传递到promises数组参数中来实现。</target>
        </trans-unit>
        <trans-unit id="f6e385587e066b24048df3bceae7d07c05eb9136" translate="yes" xml:space="preserve">
          <source>Returns a relationship formatted as a JSON-API &quot;relationship object&quot;.</source>
          <target state="translated">返回一个以JSON-API &quot;关系对象 &quot;格式化的关系。</target>
        </trans-unit>
        <trans-unit id="52a97236412e0d9a5ce17c93a028e57570cea2e1" translate="yes" xml:space="preserve">
          <source>Returns a special object that can be used to observe individual properties on the array. Just get an equivalent property on this object and it will return an enumerable that maps automatically to the named key on the member objects.</source>
          <target state="translated">返回一个特殊的对象,可以用来观察数组上的各个属性。只要在这个对象上得到一个等价的属性,它就会返回一个自动映射到成员对象上的命名键的枚举对象。</target>
        </trans-unit>
        <trans-unit id="f1bb9132b749d70b8d6303a10f424698c9fb0eed" translate="yes" xml:space="preserve">
          <source>Returns a string representation which attempts to provide more information than Javascript's &lt;code&gt;toString&lt;/code&gt; typically does, in a generic way for all Ember objects.</source>
          <target state="translated">以通用方式返回所有Ember对象的字符串表示形式，该字符串表示试图提供比Java语言的 &lt;code&gt;toString&lt;/code&gt; 通常更多的信息。</target>
        </trans-unit>
        <trans-unit id="1baffde3c198a82c1a9f24fd1699b9537bf5a9f0" translate="yes" xml:space="preserve">
          <source>Returns a unique id for the object. If the object does not yet have a guid, one will be assigned to it. You can call this on any object, &lt;code&gt;Ember.Object&lt;/code&gt;-based or not, but be aware that it will add a &lt;code&gt;_guid&lt;/code&gt; property.</source>
          <target state="translated">返回对象的唯一ID。如果该对象还没有GUID，则会为其分配一个GUID。您可以在任何基于 &lt;code&gt;Ember.Object&lt;/code&gt; 的对象上调用此函数，但请注意，它将添加 &lt;code&gt;_guid&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="1f4ec976109d986b5a79d48479eb69b877f9ce1c" translate="yes" xml:space="preserve">
          <source>Returns an array mapped to the specified key.</source>
          <target state="translated">返回一个映射到指定键的数组。</target>
        </trans-unit>
        <trans-unit id="b64d16ac418315ac651a71cfd903dcf3f4c1950a" translate="yes" xml:space="preserve">
          <source>Returns an array mapped via the callback</source>
          <target state="translated">返回一个通过回调映射的数组</target>
        </trans-unit>
        <trans-unit id="829d878e18002574178651ec68a61b50ed634687" translate="yes" xml:space="preserve">
          <source>Returns an array with all of the items in the enumeration that the passed function returns true for. This method corresponds to &lt;code&gt;filter()&lt;/code&gt; defined in JavaScript 1.6.</source>
          <target state="translated">返回一个数组，其中包含所传递函数为其返回true的枚举中的所有项目。此方法对应于JavaScript 1.6中定义的 &lt;code&gt;filter()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c71aa9a7da9062c13eb9514b5d81794253550ff0" translate="yes" xml:space="preserve">
          <source>Returns an array with all of the items in the enumeration where the passed function returns false. This method is the inverse of filter().</source>
          <target state="translated">返回一个数组,其中包含枚举中所有项目,传递的函数返回false。本方法是filter()的反演。</target>
        </trans-unit>
        <trans-unit id="78ff059f5f0f8f4ba1bb336fa61257c52bc1e554" translate="yes" xml:space="preserve">
          <source>Returns an array with just the items with the matched property. You can pass an optional second argument with the target value. Otherwise this will match any property that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">返回仅包含具有match属性的项目的数组。您可以传递带有目标值的可选第二个参数。否则，它将匹配任何评估为 &lt;code&gt;true&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="f5d725514851c9b11eac282307b62e805938ccc7" translate="yes" xml:space="preserve">
          <source>Returns an array with the items that do not have truthy values for key. You can pass an optional second argument with the target value. Otherwise this will match any property that evaluates to false.</source>
          <target state="translated">返回一个包含没有真值的项目的数组。你可以传递一个带有目标值的可选的第二个参数。否则将匹配任何评估为false的属性。</target>
        </trans-unit>
        <trans-unit id="1a3670a2d50cfc92881b423c60b1f1c2575feb6e" translate="yes" xml:space="preserve">
          <source>Returns an instance of the adapter for a given type. For example, &lt;code&gt;adapterFor('person')&lt;/code&gt; will return an instance of &lt;code&gt;App.PersonAdapter&lt;/code&gt;.</source>
          <target state="translated">返回给定类型的适配器的实例。例如， &lt;code&gt;adapterFor('person')&lt;/code&gt; 将返回 &lt;code&gt;App.PersonAdapter&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="673a33da06126a5640a2ab9e96c90786fc9c52f9" translate="yes" xml:space="preserve">
          <source>Returns an instance of the serializer for a given type. For example, &lt;code&gt;serializerFor('person')&lt;/code&gt; will return an instance of &lt;code&gt;App.PersonSerializer&lt;/code&gt;.</source>
          <target state="translated">返回给定类型的序列化程序的实例。例如， &lt;code&gt;serializerFor('person')&lt;/code&gt; 将返回 &lt;code&gt;App.PersonSerializer&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="57c8785371bfdb428b7960568f1bb17a9b411222" translate="yes" xml:space="preserve">
          <source>Returns an object that can be used to provide an owner to a manually created instance.</source>
          <target state="translated">返回一个可用于为手动创建的实例提供所有者的对象。</target>
        </trans-unit>
        <trans-unit id="fd2a4f6967074c15ba164a31f50b2fef12d1c233" translate="yes" xml:space="preserve">
          <source>Returns an object, whose keys are changed properties, and value is an [oldProp, newProp] array.</source>
          <target state="translated">返回一个对象,其键是改变了的属性,值是一个[oldProp,newProp]数组。</target>
        </trans-unit>
        <trans-unit id="eb72d59dd2b98c9d1f57e9369a6432daa8505854" translate="yes" xml:space="preserve">
          <source>Returns errors for a given attribute</source>
          <target state="translated">返回给定属性的错误</target>
        </trans-unit>
        <trans-unit id="c53cee14bf3f2dd98c4f832e2cfc8603ac6576e6" translate="yes" xml:space="preserve">
          <source>Returns the Capitalized form of a string</source>
          <target state="translated">返回字符串的大写形式</target>
        </trans-unit>
        <trans-unit id="27bef32d6017037bf8ae7ec87140c840faa058d7" translate="yes" xml:space="preserve">
          <source>Returns the UpperCamelCase form of a string.</source>
          <target state="translated">返回字符串的UpperCamelCase形式。</target>
        </trans-unit>
        <trans-unit id="3ea8d719e010027a981f551b7907ffaf6428b3c0" translate="yes" xml:space="preserve">
          <source>Returns the available classes a given type.</source>
          <target state="translated">Returns the available classes a given type.</target>
        </trans-unit>
        <trans-unit id="559a00b1190b2d1cae3fc144a9dbab5ae67bb15d" translate="yes" xml:space="preserve">
          <source>Returns the cached value for a property, if one exists. This can be useful for peeking at the value of a computed property that is generated lazily, without accidentally causing it to be created.</source>
          <target state="translated">返回一个属性的缓存值,如果存在的话。这对于偷看一个被计算的属性的值是很有用的,因为这个属性是懒惰生成的,不会意外地导致它被创建。</target>
        </trans-unit>
        <trans-unit id="c7c90e8f44c4bb41743551254bcbc3f92e3bc124" translate="yes" xml:space="preserve">
          <source>Returns the cached value of a computed property, if it exists. This allows you to inspect the value of a computed property without accidentally invoking it if it is intended to be generated lazily.</source>
          <target state="translated">返回一个计算过的属性的缓存值,如果它存在的话。这允许你检查一个计算过的属性的值,而不会意外地调用它,如果它打算被懒惰地生成的话。</target>
        </trans-unit>
        <trans-unit id="fc4ee2b850450a7e973ddd1ed839152228fa5e24" translate="yes" xml:space="preserve">
          <source>Returns the controller of the current route, or a parent (or any ancestor) route in a route hierarchy.</source>
          <target state="translated">返回当前路由的控制器,或者路由层次结构中的父路由(或任何祖先)。</target>
        </trans-unit>
        <trans-unit id="9725708a8c5defae2f7c0cd978776509197591b1" translate="yes" xml:space="preserve">
          <source>Returns the current DOM element for the view.</source>
          <target state="translated">返回当前视图的DOM元素。</target>
        </trans-unit>
        <trans-unit id="b98b32c89ebbfef46cceba77784cc4659c5bbd7e" translate="yes" xml:space="preserve">
          <source>Returns the current URL.</source>
          <target state="translated">返回当前的URL。</target>
        </trans-unit>
        <trans-unit id="603c43d141eff0347fdae1c71f24b3fffbceee88" translate="yes" xml:space="preserve">
          <source>Returns the current path.</source>
          <target state="translated">返回当前路径。</target>
        </trans-unit>
        <trans-unit id="5f1aa9ae053c0edabb551d28c02b549a6462af84" translate="yes" xml:space="preserve">
          <source>Returns the currently active route name.</source>
          <target state="translated">返回当前活动的途径名称。</target>
        </trans-unit>
        <trans-unit id="f9fe31d2ca8c909a9d417483d744e509af227d01" translate="yes" xml:space="preserve">
          <source>Returns the first item in the array for which the callback returns true. This method works similar to the &lt;code&gt;filter()&lt;/code&gt; method defined in JavaScript 1.6 except that it will stop working on the array once a match is found.</source>
          <target state="translated">返回数组中回调为其返回true的第一项。此方法的工作方式类似于JavaScript 1.6中定义的 &lt;code&gt;filter()&lt;/code&gt; 方法，不同之处在于，一旦找到匹配项，它将停止在数组上工作。</target>
        </trans-unit>
        <trans-unit id="2e59a22f6a7f2a23baf41260a3a174ae4dda651e" translate="yes" xml:space="preserve">
          <source>Returns the first item with a property matching the passed value. You can pass an optional second argument with the target value. Otherwise this will match any property that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">返回具有与传递的值匹配的属性的第一项。您可以传递带有目标值的可选第二个参数。否则，它将匹配任何评估为 &lt;code&gt;true&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="a5a026a77c75bacd53505cdcc6e9f209285cfdf2" translate="yes" xml:space="preserve">
          <source>Returns the index of the given object's first occurrence. If no &lt;code&gt;startAt&lt;/code&gt; argument is given, the starting location to search is 0. If it's negative, will count backward from the end of the array. Returns -1 if no match is found.</source>
          <target state="translated">返回给定对象首次出现的索引。如果未提供 &lt;code&gt;startAt&lt;/code&gt; 参数，则搜索的起始位置为0。如果为负，将从数组末尾开始倒数。如果找不到匹配项，则返回-1。</target>
        </trans-unit>
        <trans-unit id="b0b515aad064fd3b288bb9d89c67df97fc51d2b5" translate="yes" xml:space="preserve">
          <source>Returns the index of the given object's last occurrence. If no &lt;code&gt;startAt&lt;/code&gt; argument is given, the search starts from the last position. If it's negative, will count backward from the end of the array. Returns -1 if no match is found.</source>
          <target state="translated">返回给定对象最后一次出现的索引。如果未给出 &lt;code&gt;startAt&lt;/code&gt; 参数，则搜索从最后一个位置开始。如果为负数，将从数组末尾开始倒数。如果找不到匹配项，则返回-1。</target>
        </trans-unit>
        <trans-unit id="53b4efc0ec12b66bfb72581aacfd1278f1182232" translate="yes" xml:space="preserve">
          <source>Returns the lowerCamelCase form of a string.</source>
          <target state="translated">Returns the lowerCamelCase form of a string。</target>
        </trans-unit>
        <trans-unit id="9578d2b6bd478f1d1d2ab145665ede9e0378f6c2" translate="yes" xml:space="preserve">
          <source>Returns the model class for the particular &lt;code&gt;modelName&lt;/code&gt;.</source>
          <target state="translated">返回特定 &lt;code&gt;modelName&lt;/code&gt; 的模型类。</target>
        </trans-unit>
        <trans-unit id="0bab782f8ac9d0f882b41382a9b9eba4f7d1cced" translate="yes" xml:space="preserve">
          <source>Returns the object at the given &lt;code&gt;index&lt;/code&gt;. If the given &lt;code&gt;index&lt;/code&gt; is negative or is greater or equal than the array length, returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">返回给定 &lt;code&gt;index&lt;/code&gt; 处的对象。如果给定的 &lt;code&gt;index&lt;/code&gt; 为负或大于或等于数组长度，则返回 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3f7b4ca85546523dc009d25cb0b789a874b05c9" translate="yes" xml:space="preserve">
          <source>Returns the resolved model of a parent (or any ancestor) route in a route hierarchy. During a transition, all routes must resolve a model object, and if a route needs access to a parent route's model in order to resolve a model (or just reuse the model from a parent), it can call &lt;code&gt;this.modelFor(theNameOfParentRoute)&lt;/code&gt; to retrieve it. If the ancestor route's model was a promise, its resolved result is returned.</source>
          <target state="translated">返回路由层次结构中父（或任何祖先）路由的解析模型。在过渡期间，所有路由都必须解析一个模型对象，如果路由需要访问父路由的模型以解析模型（或者只是重用父路由的模型），则可以调用 &lt;code&gt;this.modelFor(theNameOfParentRoute)&lt;/code&gt; 来找回它。如果祖先路线的模型是promise，则返回其解析结果。</target>
        </trans-unit>
        <trans-unit id="a84d41130ac37df9542127b00978dea35fe64b87" translate="yes" xml:space="preserve">
          <source>Returns the resource's ID.</source>
          <target state="translated">返回资源的ID。</target>
        </trans-unit>
        <trans-unit id="bf66565ff73540d9dd7fc00f9444426f536c7d08" translate="yes" xml:space="preserve">
          <source>Returns the resource's attributes formatted as a JSON-API &quot;attributes object&quot;.</source>
          <target state="translated">返回资源的属性,格式为JSON-API &quot;属性对象&quot;。</target>
        </trans-unit>
        <trans-unit id="415b933c18c5478e404754280a5d65c8ca1940a0" translate="yes" xml:space="preserve">
          <source>Returns the resource's relationships formatted as a JSON-API &quot;relationships object&quot;.</source>
          <target state="translated">返回资源的关系,格式为JSON-API &quot;关系对象&quot;。</target>
        </trans-unit>
        <trans-unit id="afc70541a8fa4d9fce60946294448cc54071c811" translate="yes" xml:space="preserve">
          <source>Returns true if it is possible to catalog a list of available classes in the resolver for a given type.</source>
          <target state="translated">如果可以为给定类型在解析器中编目一个可用的类的列表,则返回true。</target>
        </trans-unit>
        <trans-unit id="dbd27005b9eb80ac7f03ed6d41eccecffd320423" translate="yes" xml:space="preserve">
          <source>Returns true if the passed object is an array or Array-like.</source>
          <target state="translated">如果传递的对象是一个数组或类数组,则返回true。</target>
        </trans-unit>
        <trans-unit id="2cbfc0edc2a1571a31104dc3ac6c9e8701099f18" translate="yes" xml:space="preserve">
          <source>Returns true if the passed value is null or undefined. This avoids errors from JSLint complaining about use of ==, which can be technically confusing.</source>
          <target state="translated">如果传递的值为空或未定义,返回true。这就避免了JSLint抱怨使用==的错误,因为这在技术上可能会引起混淆。</target>
        </trans-unit>
        <trans-unit id="cb7fd3ff2c053ac1f7adced8bb08e8be1c57f557" translate="yes" xml:space="preserve">
          <source>Reusing Route Context</source>
          <target state="translated">重用路由上下文</target>
        </trans-unit>
        <trans-unit id="f7a260f32f2ae28e993f2a321848e1adcfad19eb" translate="yes" xml:space="preserve">
          <source>Reverse objects in the array. Works just like &lt;code&gt;reverse()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">反转数组中的对象。就像 &lt;code&gt;reverse()&lt;/code&gt; 一样工作，但是它兼容KVO。</target>
        </trans-unit>
        <trans-unit id="4999528efe0f94f8f66b1dc05aad8ebaaae7b2be" translate="yes" xml:space="preserve">
          <source>Route</source>
          <target state="translated">Route</target>
        </trans-unit>
        <trans-unit id="20bb4efd64b3d8c3fbab0cab5b9e525a3f5f3641" translate="yes" xml:space="preserve">
          <source>Route Handlers</source>
          <target state="translated">路线处理程序</target>
        </trans-unit>
        <trans-unit id="6dcf16e1c5d3e9fd2ae4a4d54c174448fe43e1b6" translate="yes" xml:space="preserve">
          <source>Router</source>
          <target state="translated">Router</target>
        </trans-unit>
        <trans-unit id="15507cd11e5f36e3bd1000cd0d459f39fb04d158" translate="yes" xml:space="preserve">
          <source>Router and Route Handlers</source>
          <target state="translated">路由器和路由处理程序</target>
        </trans-unit>
        <trans-unit id="eb04e4102ddcdddd2b4ad8996248c661dcd7e77f" translate="yes" xml:space="preserve">
          <source>RouterService</source>
          <target state="translated">RouterService</target>
        </trans-unit>
        <trans-unit id="a9d3b175c69e17dc9060b2a51d5088436b3d7c7d" translate="yes" xml:space="preserve">
          <source>RouterService  (public)</source>
          <target state="translated">RouterService (public)</target>
        </trans-unit>
        <trans-unit id="bbe3002d2245379df83a5467ffff0fec18ef89e8" translate="yes" xml:space="preserve">
          <source>Routes and Templates</source>
          <target state="translated">路线和模板</target>
        </trans-unit>
        <trans-unit id="8987ca9f541ce3e64483abe2d701eb7b2b6a9540" translate="yes" xml:space="preserve">
          <source>Routes in this example application can now access the injected logger:</source>
          <target state="translated">本示例应用程序中的路由现在可以访问注入的记录器。</target>
        </trans-unit>
        <trans-unit id="64588f6aefa7085fb2efbbcac558cdfba1c74948" translate="yes" xml:space="preserve">
          <source>Routes without dynamic segments will always execute the model hook.</source>
          <target state="translated">没有动态段的路由将始终执行模型钩子。</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="1442914c6ee08b64a917d4c330cde7b015a3686d" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;ember t -s&lt;/code&gt; to verify that our new test is passing. To find the new test, locate &quot;Integration | Component | rental listing&quot; in the &quot;Module&quot; field of the test UI.</source>
          <target state="translated">运行 &lt;code&gt;ember t -s&lt;/code&gt; 验证我们的新测试通过了。要查找新测试，请在测试UI的&amp;ldquo;模块&amp;rdquo;字段中找到&amp;ldquo;集成|组件|租赁清单&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2dbbc67840c5e39c504d798d6593f53821d2cc88" translate="yes" xml:space="preserve">
          <source>Run a function meant for debugging.</source>
          <target state="translated">运行一个用于调试的函数。</target>
        </trans-unit>
        <trans-unit id="66a5ecdab45965e437f71333f302f2e5bab78442" translate="yes" xml:space="preserve">
          <source>Run in a full browser environment.</source>
          <target state="translated">在全浏览器环境下运行。</target>
        </trans-unit>
        <trans-unit id="edc3981913706bf02d5feb303f21804148ecbc99" translate="yes" xml:space="preserve">
          <source>Run the following command to install the addon:</source>
          <target state="translated">运行以下命令来安装插件。</target>
        </trans-unit>
        <trans-unit id="6f6ff3e3092b35d4ef3929076640b57e0d508a29" translate="yes" xml:space="preserve">
          <source>Run the tests again using the command &lt;code&gt;ember t -s&lt;/code&gt;, and toggle &quot;Hide passed tests&quot; to show your new passing test.</source>
          <target state="translated">使用命令 &lt;code&gt;ember t -s&lt;/code&gt; 再次运行测试，然后切换&amp;ldquo;隐藏通过的测试&amp;rdquo;以显示新的通过测试。</target>
        </trans-unit>
        <trans-unit id="113d8c01f0ce1a9637e7e61d07f886f1ce894435" translate="yes" xml:space="preserve">
          <source>Run time, where we begin executing the application once everything has loaded.</source>
          <target state="translated">运行时,当一切加载完毕后,我们开始执行应用程序。</target>
        </trans-unit>
        <trans-unit id="8cbc363f50b4971680e11de197253d5ebff17363" translate="yes" xml:space="preserve">
          <source>Run your tests with &lt;code&gt;ember test&lt;/code&gt; on the command-line. You can re-run your tests on every file-change with &lt;code&gt;ember test --server&lt;/code&gt;.</source>
          <target state="translated">在命令行上使用 &lt;code&gt;ember test&lt;/code&gt; 运行测试。您可以使用 &lt;code&gt;ember test --server&lt;/code&gt; 在每个文件更改上重新运行测试。</target>
        </trans-unit>
        <trans-unit id="2ce92b8f8a607252af27b98ddec45308f2f8137b" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;ember test --server&lt;/code&gt; will now show 7 failing tests (out of 15). Each of the 6 tests we setup above will fail, plus one ESLint test will fail saying, &lt;code&gt;assert is defined but never used&lt;/code&gt;. The tests above fail because QUnit requires at least one check for a specific condition (known as an &lt;code&gt;assert&lt;/code&gt;).</source>
          <target state="translated">运行 &lt;code&gt;ember test --server&lt;/code&gt; 现在将显示7个失败的测试（共15个）。我们在上面设置的6个测试中的每一个都会失败，再加上一个ESLint测试将失败，说明 &lt;code&gt;assert is defined but never used&lt;/code&gt; 。上面的测试失败了，因为QUnit要求至少检查一次特定条件（称为 &lt;code&gt;assert&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="52d1f9fc84c72f964d3e2290880c642e3e33c2c8" translate="yes" xml:space="preserve">
          <source>Running this command generates three files: a component JavaScript file, a template, and a test file.</source>
          <target state="translated">运行该命令会生成三个文件:一个组件JavaScript文件、一个模板和一个测试文件。</target>
        </trans-unit>
        <trans-unit id="42272791157160739ed302e320a2062a5ebaa316" translate="yes" xml:space="preserve">
          <source>Runs the passed target and method inside of a RunLoop, ensuring any deferred actions including bindings and views updates are flushed at the end.</source>
          <target state="translated">在RunLoop中运行通过的目标和方法,确保任何延迟的操作,包括绑定和视图更新在最后被刷新。</target>
        </trans-unit>
        <trans-unit id="429ee37aaa10a7c1e1dbc7f3832b6b87b1b491c2" translate="yes" xml:space="preserve">
          <source>SSR</source>
          <target state="translated">SSR</target>
        </trans-unit>
        <trans-unit id="3345733b5704ef652ed8eb46f076938ea03125bd" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;deleteRecord&lt;/code&gt;, but saves the record immediately.</source>
          <target state="translated">与 &lt;code&gt;deleteRecord&lt;/code&gt; 相同，但立即保存记录。</target>
        </trans-unit>
        <trans-unit id="4a7e069bd507c730311a8b251060b5b9997cb937" translate="yes" xml:space="preserve">
          <source>Sass/Less Comparison</source>
          <target state="translated">Sass/Less比较</target>
        </trans-unit>
        <trans-unit id="25818b0851afccf72a718a0e15e8c5e40a99b3fc" translate="yes" xml:space="preserve">
          <source>Save the record and persist any changes to the record to an external source via the adapter.</source>
          <target state="translated">保存记录,并通过适配器将对记录的任何更改持久化到外部源。</target>
        </trans-unit>
        <trans-unit id="6db7e04098ce89e31bb81c3fc95a3a70f998a013" translate="yes" xml:space="preserve">
          <source>Save this template and switch back to the &lt;code&gt;scientists&lt;/code&gt; template. Replace all our old code with our new componentized version. Components look like HTML tags but instead of using angle brackets (&lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt;) they use double curly braces (&lt;code&gt;{{component}}&lt;/code&gt;).</source>
          <target state="translated">保存此模板，然后切换回 &lt;code&gt;scientists&lt;/code&gt; 模板。用新的组件化版本替换所有旧代码。组件看起来像HTML标记，但是它们使用双花括号（ &lt;code&gt;{{component}}&lt;/code&gt; 代替了尖括号（ &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="75008fab400537d9213cc7b35f572e830001bbbb" translate="yes" xml:space="preserve">
          <source>Saves all of the records in the &lt;code&gt;ManyArray&lt;/code&gt;.</source>
          <target state="translated">将所有记录保存在 &lt;code&gt;ManyArray&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="df3feb104ba2e45607091340bd579e0e82e620de" translate="yes" xml:space="preserve">
          <source>Saves all of the records in the &lt;code&gt;RecordArray&lt;/code&gt;.</source>
          <target state="translated">将所有记录保存在 &lt;code&gt;RecordArray&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="3fe2b6866788c46de111214341e6e46e2056460c" translate="yes" xml:space="preserve">
          <source>Say your API namespaces the type of a model and expects the following payload when you update the &lt;code&gt;post&lt;/code&gt; model, which has a polymorphic &lt;code&gt;user&lt;/code&gt; relationship:</source>
          <target state="translated">假设您的API名称空间是模型的类型，并且在更新具有多态 &lt;code&gt;user&lt;/code&gt; 关系的 &lt;code&gt;post&lt;/code&gt; 模型时，需要以下有效负载：</target>
        </trans-unit>
        <trans-unit id="d136d61c474d3b91c7e154860b021ed3fbba6838" translate="yes" xml:space="preserve">
          <source>Say your API namespaces the type of a model and expects the following payload when you update the &lt;code&gt;post&lt;/code&gt; model:</source>
          <target state="translated">假设您的API名称空间是模型的类型，并且在更新 &lt;code&gt;post&lt;/code&gt; 模型时需要以下有效负载：</target>
        </trans-unit>
        <trans-unit id="ea662432dbe1c412446984e3028f23c30fe1a705" translate="yes" xml:space="preserve">
          <source>Say your API namespaces the type of a model and returns the following payload for the &lt;code&gt;post&lt;/code&gt; model, which has a polymorphic &lt;code&gt;user&lt;/code&gt; relationship:</source>
          <target state="translated">假设您的API命名空间是模型的类型，并为具有多态 &lt;code&gt;user&lt;/code&gt; 关系的 &lt;code&gt;post&lt;/code&gt; 模型返回以下负载：</target>
        </trans-unit>
        <trans-unit id="a903a2095a7bcdbfa11fb73fb67d71d335131cd8" translate="yes" xml:space="preserve">
          <source>Say your API namespaces the type of a model and returns the following payload for the &lt;code&gt;post&lt;/code&gt; model:</source>
          <target state="translated">假设您的API名称空间是模型的类型，并为 &lt;code&gt;post&lt;/code&gt; 模型返回以下有效负载：</target>
        </trans-unit>
        <trans-unit id="bc16a7d79cd8b9582ffe6cf1c9f51f2a4e6b9968" translate="yes" xml:space="preserve">
          <source>Schedule a function to run one time during the current RunLoop. This is equivalent to calling &lt;code&gt;scheduleOnce&lt;/code&gt; with the &quot;actions&quot; queue.</source>
          <target state="translated">安排一个函数在当前RunLoop中运行一次。这等效于使用&amp;ldquo;操作&amp;rdquo;队列调用 &lt;code&gt;scheduleOnce&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fa9c050bafdf85859c52a24173e46d2b0a60bfa" translate="yes" xml:space="preserve">
          <source>Schedules a function to run one time in a given queue of the current RunLoop. Calling this method with the same queue/target/method combination will have no effect (past the initial call).</source>
          <target state="translated">在当前RunLoop的给定队列中安排函数运行一次。用相同的队列/目标/方法组合调用这个方法不会有任何影响(超过了初始调用)。</target>
        </trans-unit>
        <trans-unit id="415823adc474692ea63ccbfdd4bf9285fdf51e36" translate="yes" xml:space="preserve">
          <source>Schedules an item to run from within a separate run loop, after control has been returned to the system. This is equivalent to calling &lt;code&gt;run.later&lt;/code&gt; with a wait time of 1ms.</source>
          <target state="translated">在控制权返回给系统之后，计划在单独的运行循环中运行的项目。这等效于以1毫秒的等待时间调用 &lt;code&gt;run.later&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2da8e5963f5b139e60b530201737776279520ba2" translate="yes" xml:space="preserve">
          <source>Second value to compare</source>
          <target state="translated">第二个比较值</target>
        </trans-unit>
        <trans-unit id="fbb14676cc33f6f4135e4da0888670ea8bff400b" translate="yes" xml:space="preserve">
          <source>Second, attribute and relationship names in the JSON API document should exactly match the name and casing of the &lt;code&gt;DS.attr()&lt;/code&gt;, &lt;code&gt;DS.belongsTo()&lt;/code&gt; and &lt;code&gt;DS.hasMany()&lt;/code&gt;, properties defined on the Model.</source>
          <target state="translated">其次，JSON API文档中的属性和关系名称应与模型上定义的 &lt;code&gt;DS.attr()&lt;/code&gt; ， &lt;code&gt;DS.belongsTo()&lt;/code&gt; 和 &lt;code&gt;DS.hasMany()&lt;/code&gt; 的名称和大小写完全匹配。</target>
        </trans-unit>
        <trans-unit id="2505c754e96c76956a7be1f711c7c15d871a6591" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#method_findRecord&quot;&gt;findRecord&lt;/a&gt; if you would like to request this record from the backend.</source>
          <target state="translated">如果您想从后端请求此记录，请参见&lt;a href=&quot;#method_findRecord&quot;&gt;findRecord&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6b7139c565ccba6b41646265abe63665bc0e0fb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#method_peekAll&quot;&gt;peekAll&lt;/a&gt; to get an array of current records in the store, without waiting until a reload is finished.</source>
          <target state="translated">请参阅&lt;a href=&quot;#method_peekAll&quot;&gt;peekAll&lt;/a&gt;以获取存储中的当前记录数组，而无需等到重新加载完成。</target>
        </trans-unit>
        <trans-unit id="886ff4d1e817dd0f2c949c0a7b4ce296faa34a4f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#method_peekRecord&quot;&gt;peekRecord&lt;/a&gt; to get the cached version of a record.</source>
          <target state="translated">请参阅&lt;a href=&quot;#method_peekRecord&quot;&gt;peekRecord&lt;/a&gt;以获取记录的缓存版本。</target>
        </trans-unit>
        <trans-unit id="61ccab3b58667205608bc05c31f4f4471dba3cbc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#method_query&quot;&gt;query&lt;/a&gt; to only get a subset of records from the server.</source>
          <target state="translated">请参阅&lt;a href=&quot;#method_query&quot;&gt;查询&lt;/a&gt;以仅从服务器获取记录的子集。</target>
        </trans-unit>
        <trans-unit id="46d9795971c80ea476d0b1500751d7a511c3ccff" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../passing-properties-to-a-component&quot;&gt;Passing Properties to a Component&lt;/a&gt; for more.</source>
          <target state="translated">有关更多信息，请参见将&lt;a href=&quot;../passing-properties-to-a-component&quot;&gt;属性传递给组件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3db6252e2ca3a79d9351ce05c47a2d29d1a3f0d3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component#event-names&quot;&gt;&quot;Event Names&quot;&lt;/a&gt; for a list of acceptable DOM event names.</source>
          <target state="translated">有关可接受的DOM事件名称的列表，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component#event-names&quot;&gt;&amp;ldquo;事件名称&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8789001d899131f2e85e2f5f2831793db5bede0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.ComputedProperty.html&quot;&gt;Ember.ComputedProperty&lt;/a&gt;, &lt;a href=&quot;https://emberjs.com/api/classes/Ember.computed.html&quot;&gt;Ember.computed&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://emberjs.com/api/classes/Ember.ComputedProperty.html&quot;&gt;Ember.ComputedProperty&lt;/a&gt;，&lt;a href=&quot;https://emberjs.com/api/classes/Ember.computed.html&quot;&gt;Ember.computed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65ead4fce2d577717cfc6277eb28eb28c8681b44" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.LinkComponent.html&quot;&gt;Ember.LinkComponent&lt;/a&gt; for a complete list of overrideable properties. Be sure to also check out inherited properties of &lt;code&gt;LinkComponent&lt;/code&gt;.</source>
          <target state="translated">有关&lt;a href=&quot;https://emberjs.com/api/classes/Ember.LinkComponent.html&quot;&gt;可&lt;/a&gt;重写属性的完整列表，请参见Ember.LinkComponent。一定还要检查出 &lt;code&gt;LinkComponent&lt;/code&gt; 的继承属性。</target>
        </trans-unit>
        <trans-unit id="045265cfa59bb6f41aaac98fec78959fdd19abe6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.HashLocation&quot;&gt;Ember.Location.HashLocation&lt;/a&gt;. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.HistoryLocation&quot;&gt;Ember.Location.HistoryLocation&lt;/a&gt;. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.NoneLocation&quot;&gt;Ember.Location.NoneLocation&lt;/a&gt;. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.AutoLocation&quot;&gt;Ember.Location.AutoLocation&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.HashLocation&quot;&gt;Ember.Location.HashLocation&lt;/a&gt;。请参阅&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.HistoryLocation&quot;&gt;Ember.Location.HistoryLocation&lt;/a&gt;。请参阅&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.NoneLocation&quot;&gt;Ember.Location.NoneLocation&lt;/a&gt;。请参阅&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.AutoLocation&quot;&gt;Ember.Location.AutoLocation&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01062a6ca91683116a2e4f5f08c832a71f5fe8f8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Route.html#method_replaceWith&quot;&gt;Route.replaceWith&lt;/a&gt; for more info.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Route.html#method_replaceWith&quot;&gt;Route.replaceWith&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="857a99c53ed3cf0419cf7f9b690df0548804f0cb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Route.html#method_transitionTo&quot;&gt;Route.transitionTo&lt;/a&gt; for more info.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Route.html#method_transitionTo&quot;&gt;Route.transitionTo&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="881033150b0297e5f01d4a625bd73488021b52e6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.String.html#method_loc&quot;&gt;Ember.String.loc&lt;/a&gt; for how to set up localized string references.</source>
          <target state="translated">有关如何设置本地化的字符串引用，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.String.html#method_loc&quot;&gt;Ember.String.loc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6112da6f0d617231dc4dbb1b45eeb398b827508d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_action&quot;&gt;Ember.Templates.helpers.action&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_action&quot;&gt;Ember.Templates.helpers.action&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e320b1d30f80cb3e78ed752a8fd867c8ef8c8dc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;Ember.Templates.helpers.input&lt;/a&gt; for usage details.</source>
          <target state="translated">有关用法的详细信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;Ember.Templates.helpers.input&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03d11afa96477f44a066fa485ba8101cf284b0ae" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_textarea&quot;&gt;Ember.Templates.helpers.textarea&lt;/a&gt; for usage details.</source>
          <target state="translated">有关用法的详细信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_textarea&quot;&gt;Ember.Templates.helpers.textarea&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47faa79acc3c86a2306cd182fa2b1e0dd8b6cb51" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_yield&quot;&gt;Ember.Templates.helpers.yield&lt;/a&gt; for more information.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_yield&quot;&gt;Ember.Templates.helpers.yield&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d084a39940c5ca6a3dc230b8703de366598062d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/guides/templates/the-application-template/&quot;&gt;templates guide&lt;/a&gt; for additional information on using &lt;code&gt;{{outlet}}&lt;/code&gt; in &lt;code&gt;application.hbs&lt;/code&gt;. You may also specify a name for the &lt;code&gt;{{outlet}}&lt;/code&gt;, which is useful when using more than one &lt;code&gt;{{outlet}}&lt;/code&gt; in a template:</source>
          <target state="translated">有关在 &lt;code&gt;application.hbs&lt;/code&gt; 中使用 &lt;code&gt;{{outlet}}&lt;/code&gt; 的更多信息，请参见&lt;a href=&quot;https://emberjs.com/guides/templates/the-application-template/&quot;&gt;模板指南&lt;/a&gt;。您还可以为 &lt;code&gt;{{outlet}}&lt;/code&gt; 指定一个名称，这在模板中使用多个 &lt;code&gt;{{outlet}}&lt;/code&gt; 时非常有用：</target>
        </trans-unit>
        <trans-unit id="da7f7101e86e008a15c9fc249f9d10eeeb8ad692" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;Ember.observer&lt;/code&gt;.</source>
          <target state="translated">请参阅 &lt;code&gt;Ember.observer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb6d38f9f2619d3888781eee8439db883f2023dd" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;Ember.on&lt;/code&gt;.</source>
          <target state="translated">参见 &lt;code&gt;Ember.on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5654e29a2f9b281a9e8375d997a1390c911e728" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;serialize&lt;/code&gt; for information on how to customize the serialized form of a record.</source>
          <target state="translated">有关如何自定义记录的序列化形式的信息，请参见 &lt;code&gt;serialize&lt;/code&gt; 化。</target>
        </trans-unit>
        <trans-unit id="c586195d203dee29ed62d91d26341ea7df6918eb" translate="yes" xml:space="preserve">
          <source>See Ember.Application.initializer for discussion on the usage of before and after.</source>
          <target state="translated">关于前后的用法,请参见Ember.Application.initializer的讨论。</target>
        </trans-unit>
        <trans-unit id="e38cd17e666018827e69a44432616458686394b7" translate="yes" xml:space="preserve">
          <source>See RSVP.Promise.catch.</source>
          <target state="translated">见RSVP.Promise.catch。</target>
        </trans-unit>
        <trans-unit id="392314b527dfbd25d9b7ed433a5cad392661aecf" translate="yes" xml:space="preserve">
          <source>See RSVP.Promise.finally.</source>
          <target state="translated">见RSVP.Promise.最后。</target>
        </trans-unit>
        <trans-unit id="2192c68214bde1365823cd88f18083860287db7d" translate="yes" xml:space="preserve">
          <source>See RSVP.Promise.then.</source>
          <target state="translated">见RSVP.Promise.然后。</target>
        </trans-unit>
        <trans-unit id="e4f6b4832e77e568563e9f9654dc677db5ef2bd6" translate="yes" xml:space="preserve">
          <source>See all observers for an object, key</source>
          <target state="translated">查看一个对象的所有观察者,键</target>
        </trans-unit>
        <trans-unit id="f44d1816a0f33954c0c1b606d935226b15a7a275" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#method_replaceWith&quot;&gt;replaceWith&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#method_replaceWith&quot;&gt;replaceWith&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65b6e8e3055ab3ad8943a84067c6dde10eeb6b38" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://emberjs.com/api/classes/Ember.ControllerMixin.html#method_replaceRoute&quot;&gt;replaceRoute&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.ControllerMixin.html#method_replaceRoute&quot;&gt;replaceRoute&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1131debc15fa7b2f9872d39240142f424b1f9d69" translate="yes" xml:space="preserve">
          <source>See more about &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component.html&quot;&gt;Ember components&lt;/a&gt;</source>
          <target state="translated">进一步了解&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component.html&quot;&gt;Ember组件&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ba9f21e3fbfc35d0ad9d88b57d28f52f45794dc" translate="yes" xml:space="preserve">
          <source>See more about &lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextArea.html&quot;&gt;Text Support Actions&lt;/a&gt;</source>
          <target state="translated">查看有关&lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextArea.html&quot;&gt;文本支持操作的&lt;/a&gt;更多信息</target>
        </trans-unit>
        <trans-unit id="d8d27c03873709d7fb4d40eef28f6d91b6c1accb" translate="yes" xml:space="preserve">
          <source>See more about &lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;Text Support Actions&lt;/a&gt;</source>
          <target state="translated">查看有关&lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;文本支持操作的&lt;/a&gt;更多信息</target>
        </trans-unit>
        <trans-unit id="5aa5055098c1d7f1ee4bd170e24743c3af2dcaa6" translate="yes" xml:space="preserve">
          <source>See that we have used &lt;code&gt;moduleFor&lt;/code&gt;, one of the several unit-test helpers provided by Ember-Qunit. Test helpers provide us with some conveniences, such as the &lt;code&gt;subject&lt;/code&gt; function that handles lookup and instantiation for our object under test. Note that in a unit test you can customize the initialization of your object under test by passing to the &lt;code&gt;subject&lt;/code&gt; function an object containing the instance variables you would like to initialize. For example, to initialize the property 'foo' in our object under test, we would call &lt;code&gt;this.subject({ foo: 'bar' });&lt;/code&gt;</source>
          <target state="translated">看到我们使用了 &lt;code&gt;moduleFor&lt;/code&gt; ，这是Ember-Qunit提供的几个单元测试助手之一。测试助手为我们提供了一些便利，例如 &lt;code&gt;subject&lt;/code&gt; 函数可以处理被测对象的查找和实例化。请注意，在单元测试中，您可以通过将包含要初始化的实例变量的对象传递给 &lt;code&gt;subject&lt;/code&gt; 函数，来自定义被测对象的初始化。例如，要在测试对象中初始化属性&amp;ldquo; foo&amp;rdquo;，我们将调用 &lt;code&gt;this.subject({ foo: 'bar' });&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae9382bccb52583673509854efe6c33c1551b8a4" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://emberjs.com/guides/routing/rendering-a-template/&quot;&gt;routing guide&lt;/a&gt; for more information on how your &lt;code&gt;route&lt;/code&gt; interacts with the &lt;code&gt;{{outlet}}&lt;/code&gt; helper. Note: Your content &lt;strong&gt;will not render&lt;/strong&gt; if there isn't an &lt;code&gt;{{outlet}}&lt;/code&gt; for it.</source>
          <target state="translated">有关您的 &lt;code&gt;route&lt;/code&gt; 如何与 &lt;code&gt;{{outlet}}&lt;/code&gt; 帮助程序进行交互的更多信息，请参见&lt;a href=&quot;https://emberjs.com/guides/routing/rendering-a-template/&quot;&gt;路由指南&lt;/a&gt;。注意：如果没有 &lt;code&gt;{{outlet}}&lt;/code&gt; ，您的内容&lt;strong&gt;将不会呈现&lt;/strong&gt;。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a57805751973ea57faaaae7c6e36d1170562cb5e" translate="yes" xml:space="preserve">
          <source>See the &lt;code&gt;normalize&lt;/code&gt; documentation for more information.</source>
          <target state="translated">有关更多信息，请参见 &lt;code&gt;normalize&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="466a6e9c7a1e57a171042a7f153306f2eec6b51f" translate="yes" xml:space="preserve">
          <source>See the Handlebars documentation on &lt;a href=&quot;http://handlebarsjs.com/#block-expressions&quot;&gt;block expressions&lt;/a&gt; for more.</source>
          <target state="translated">有关更多信息，请参见有关&lt;a href=&quot;http://handlebarsjs.com/#block-expressions&quot;&gt;表达式&lt;/a&gt;的Handlebars文档。</target>
        </trans-unit>
        <trans-unit id="9f864ff30f39009bee652eeaa77b5d4e2cb3c219" translate="yes" xml:space="preserve">
          <source>See the documentation for &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; for more information.</source>
          <target state="translated">有关更多信息，请参见 &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="9d1186a24f13f7ddf3bb7bc489fbe38dfa0116f7" translate="yes" xml:space="preserve">
          <source>See the documentation on &lt;code&gt;Ember.Applications&lt;/code&gt;'s &lt;code&gt;rootElement&lt;/code&gt; for details.</source>
          <target state="translated">有关详细信息，请参见 &lt;code&gt;Ember.Applications&lt;/code&gt; 的 &lt;code&gt;rootElement&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="1adc341f4763a89fa8173df93fc2565a43324631" translate="yes" xml:space="preserve">
          <source>See the documentation on the &lt;code&gt;isBrowser&lt;/code&gt;, &lt;code&gt;document&lt;/code&gt; and &lt;code&gt;rootElement&lt;/code&gt; properties on &lt;code&gt;Ember.ApplicationInstance.BootOptions&lt;/code&gt; for details.</source>
          <target state="translated">查看该文档 &lt;code&gt;isBrowser&lt;/code&gt; ， &lt;code&gt;document&lt;/code&gt; 和 &lt;code&gt;rootElement&lt;/code&gt; 的对性能的 &lt;code&gt;Ember.ApplicationInstance.BootOptions&lt;/code&gt; 了解详情。</target>
        </trans-unit>
        <trans-unit id="1824d460f7c3833816d20ccdd7e4598d1c806c7e" translate="yes" xml:space="preserve">
          <source>See the list of event names at the end of this page. Any event can be defined as an event handler in your component.</source>
          <target state="translated">请看本页末尾的事件名称列表。任何事件都可以在你的组件中被定义为事件处理程序。</target>
        </trans-unit>
        <trans-unit id="1a127955b9093eefeadddc3e86e6bc2ecfb11432" translate="yes" xml:space="preserve">
          <source>See {{#crossLink &quot;Ember.String/pluralize&quot;}}{{/crossLink}}</source>
          <target state="translated">见{{#crossLink &quot;Ember.String/pluralize&quot;}}{{/crossLink}}。</target>
        </trans-unit>
        <trans-unit id="b2ec09c4221cd9352fad5f335a19d089d3aff099" translate="yes" xml:space="preserve">
          <source>See {{#crossLink &quot;Ember.String/singularize&quot;}}{{/crossLink}}</source>
          <target state="translated">见{{#crossLink &quot;Ember.String/singularize&quot;}}{{/crossLink}}。</target>
        </trans-unit>
        <trans-unit id="4908850b77074857fa2902c9a0c51ac951c3d066" translate="yes" xml:space="preserve">
          <source>Send an event. The execution of suspended listeners is skipped, and once listeners are removed. A listener without a target is executed on the passed object. If an array of actions is not passed, the actions stored on the passed object are invoked.</source>
          <target state="translated">发送一个事件。跳过执行暂停的监听器,一旦监听器被删除。没有目标的监听器会在传递的对象上执行。如果没有传递动作数组,则调用存储在传递对象上的动作。</target>
        </trans-unit>
        <trans-unit id="a7cbd3195b0b1848a603028087345561cbdb3c83" translate="yes" xml:space="preserve">
          <source>Sending Actions</source>
          <target state="translated">发送动作</target>
        </trans-unit>
        <trans-unit id="090be3d6246540fa8c78341d0fd9ec8bb7d44ef7" translate="yes" xml:space="preserve">
          <source>Sending from the Console to the Inspector</source>
          <target state="translated">从控制台发送至检查员</target>
        </trans-unit>
        <trans-unit id="064119347ce21be3830f42ad99fd305e6bb36ddb" translate="yes" xml:space="preserve">
          <source>Sending from the Inspector to the Console</source>
          <target state="translated">从检查员发送至控制台</target>
        </trans-unit>
        <trans-unit id="37adf51f8e931f4ac6beffdc0bce4b8c9a345a4c" translate="yes" xml:space="preserve">
          <source>Sends a delete request for the record to the server.</source>
          <target state="translated">向服务器发送删除记录的请求。</target>
        </trans-unit>
        <trans-unit id="291d83532f286c48f65ce13d9158d367234e5871" translate="yes" xml:space="preserve">
          <source>Sends an action to the router, which will delegate it to the currently active route hierarchy per the bubbling rules explained under &lt;code&gt;actions&lt;/code&gt;.</source>
          <target state="translated">向路由器发送一个操作，该操作将根据 &lt;code&gt;actions&lt;/code&gt; 下说明的冒泡规则将其委派给当前活动的路由层次结构。</target>
        </trans-unit>
        <trans-unit id="21f60515d4413efa1948ac110388d426adab17c9" translate="yes" xml:space="preserve">
          <source>Serialize &lt;code&gt;belongsTo&lt;/code&gt; relationship when it is configured as an embedded object.</source>
          <target state="translated">序列化 &lt;code&gt;belongsTo&lt;/code&gt; 当它被配置作为嵌入对象的关系。</target>
        </trans-unit>
        <trans-unit id="77f5a897d372d976dbdf3ed3fd84a1f9fe2c636a" translate="yes" xml:space="preserve">
          <source>Serializes &lt;code&gt;hasMany&lt;/code&gt; relationships when it is configured as embedded objects.</source>
          <target state="translated">将 &lt;code&gt;hasMany&lt;/code&gt; 关系配置为嵌入式对象时，将其序列化。</target>
        </trans-unit>
        <trans-unit id="859739a640dcccec7d3c89114d041ab46afff14a" translate="yes" xml:space="preserve">
          <source>Serializes the record and sends it to the server.</source>
          <target state="translated">将记录序列化并发送至服务器。</target>
        </trans-unit>
        <trans-unit id="aa92b22d8e89b667210a07e5334e64f079da918f" translate="yes" xml:space="preserve">
          <source>Serializes the record update and sends it to the server.</source>
          <target state="translated">将记录更新序列化并发送至服务器。</target>
        </trans-unit>
        <trans-unit id="761efa682a827fca2803f8da4a302dc39dc2208e" translate="yes" xml:space="preserve">
          <source>Serializing a &lt;code&gt;belongsTo&lt;/code&gt; relationship removes the property that refers to the parent record</source>
          <target state="translated">序列化一个 &lt;code&gt;belongsTo&lt;/code&gt; 关系会删除引用父记录的属性</target>
        </trans-unit>
        <trans-unit id="5fe4ca86767cc1bd91544bb1b9f91724e637ec8b" translate="yes" xml:space="preserve">
          <source>Serializing a &lt;code&gt;hasMany&lt;/code&gt; relationship does not remove the property that refers to the parent record.</source>
          <target state="translated">序列化 &lt;code&gt;hasMany&lt;/code&gt; 关系不会删除引用父记录的属性。</target>
        </trans-unit>
        <trans-unit id="b6798f213d4815c22490d46bda891a2bbd22a2a8" translate="yes" xml:space="preserve">
          <source>Serializing records</source>
          <target state="translated">记录的序列化</target>
        </trans-unit>
        <trans-unit id="01fe9a20a8fdeb0f312fdcea1363c6a939cf772b" translate="yes" xml:space="preserve">
          <source>Server-Side Rendering</source>
          <target state="translated">服务器端渲染</target>
        </trans-unit>
        <trans-unit id="d4b08fda9668f41846dc7fb238475372e5a87571" translate="yes" xml:space="preserve">
          <source>Server-Side Rendering (also known as FastBoot)</source>
          <target state="translated">服务器端渲染(也称为FastBoot)</target>
        </trans-unit>
        <trans-unit id="ddedf41976a8db9f179e56d77dad30a5828aa47a" translate="yes" xml:space="preserve">
          <source>Server-Side Resource Discovery</source>
          <target state="translated">服务器端资源发现</target>
        </trans-unit>
        <trans-unit id="626629d0773ba5b8e704de2a8cf4d1b2671d6966" translate="yes" xml:space="preserve">
          <source>Server-backed API calls that may not fit Ember Data.</source>
          <target state="translated">服务器支持的API调用,可能不适合Ember Data。</target>
        </trans-unit>
        <trans-unit id="3788673593a9fb3cb0da7a56e2684739ac286fa2" translate="yes" xml:space="preserve">
          <source>Server-sent events or notifications.</source>
          <target state="translated">服务器发送的事件或通知。</target>
        </trans-unit>
        <trans-unit id="acca64b83535b9a1dff37a13cd176f393be7c195" translate="yes" xml:space="preserve">
          <source>Servers</source>
          <target state="translated">Servers</target>
        </trans-unit>
        <trans-unit id="329cb8b6ba8c427be7c09b298295c655415c7ac9" translate="yes" xml:space="preserve">
          <source>Service</source>
          <target state="translated">Service</target>
        </trans-unit>
        <trans-unit id="5cbd584046863bc7b753e57e8681a98a87f36f0f" translate="yes" xml:space="preserve">
          <source>Services</source>
          <target state="translated">Services</target>
        </trans-unit>
        <trans-unit id="8c95ce8ed53a712d7d11fe978a559e8aacdfb5cc" translate="yes" xml:space="preserve">
          <source>Services and Utilities</source>
          <target state="translated">服务和公用事业</target>
        </trans-unit>
        <trans-unit id="973e47a9c7779d6a3f292ac37ac9d79ba9c45893" translate="yes" xml:space="preserve">
          <source>Services are useful for features that require shared state or persistent connections. Example uses of services might include:</source>
          <target state="translated">服务对于需要共享状态或持久连接的功能非常有用。服务的使用实例可能包括:</target>
        </trans-unit>
        <trans-unit id="44de33fce9e667d81467d696283b746a2b89ae0f" translate="yes" xml:space="preserve">
          <source>Services can be generated using Ember CLI's &lt;code&gt;service&lt;/code&gt; generator. For example, the following command will create the &lt;code&gt;ShoppingCart&lt;/code&gt; service:</source>
          <target state="translated">可以使用Ember CLI的 &lt;code&gt;service&lt;/code&gt; 生成器生成服务。例如，以下命令将创建 &lt;code&gt;ShoppingCart&lt;/code&gt; 服务：</target>
        </trans-unit>
        <trans-unit id="f28ef67c082d95db9b197a590c7d6ac777b73ad0" translate="yes" xml:space="preserve">
          <source>Services must extend the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Service.html&quot;&gt;&lt;code&gt;Ember.Service&lt;/code&gt;&lt;/a&gt; base class:</source>
          <target state="translated">服务必须扩展&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Service.html&quot;&gt; &lt;code&gt;Ember.Service&lt;/code&gt; &lt;/a&gt;基类：</target>
        </trans-unit>
        <trans-unit id="ac2ee51eb0d899834a5e76d58a0d52b264a8975b" translate="yes" xml:space="preserve">
          <source>Set a list of properties on an object. These properties are set inside a single &lt;code&gt;beginPropertyChanges&lt;/code&gt; and &lt;code&gt;endPropertyChanges&lt;/code&gt; batch, so observers will be buffered.</source>
          <target state="translated">设置对象的属性列表。这些属性设置在单个 &lt;code&gt;beginPropertyChanges&lt;/code&gt; 和 &lt;code&gt;endPropertyChanges&lt;/code&gt; 批处理中，因此将缓冲观察者。</target>
        </trans-unit>
        <trans-unit id="bb507d8cf4504dfd969277729f9d6cb3da94b46d" translate="yes" xml:space="preserve">
          <source>Set the value of a boolean property to the opposite of its current value.</source>
          <target state="translated">将布尔属性的值设置为与其当前值相反的值。</target>
        </trans-unit>
        <trans-unit id="354b450dc637fea87122e449b4c6d64fd161d127" translate="yes" xml:space="preserve">
          <source>Set the value of a property to the current value minus some amount.</source>
          <target state="translated">将属性的值设置为当前值减去某个金额。</target>
        </trans-unit>
        <trans-unit id="0a474206fc22982beb1518f159723d7d5b1a7bd6" translate="yes" xml:space="preserve">
          <source>Set the value of a property to the current value plus some amount.</source>
          <target state="translated">将属性的价值设置为当前价值加上一定的金额。</target>
        </trans-unit>
        <trans-unit id="022856defe2402ee0a7880769473d89d1b0fd118" translate="yes" xml:space="preserve">
          <source>Set this to provide an alternate class to &lt;code&gt;Ember.DefaultResolver&lt;/code&gt;</source>
          <target state="translated">设置此项以提供 &lt;code&gt;Ember.DefaultResolver&lt;/code&gt; 的替代类。</target>
        </trans-unit>
        <trans-unit id="b2871131570de12ffc4fe0e0fa49f2aa7a81352e" translate="yes" xml:space="preserve">
          <source>Sets a list of properties at once. These properties are set inside a single &lt;code&gt;beginPropertyChanges&lt;/code&gt; and &lt;code&gt;endPropertyChanges&lt;/code&gt; batch, so observers will be buffered.</source>
          <target state="translated">一次设置属性列表。这些属性设置在单个 &lt;code&gt;beginPropertyChanges&lt;/code&gt; 和 &lt;code&gt;endPropertyChanges&lt;/code&gt; 批处理中，因此将缓冲观察者。</target>
        </trans-unit>
        <trans-unit id="e54a99e025defe6d81185356e0087e36fb02c41f" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;rel&lt;/code&gt; attribute of the &lt;code&gt;LinkComponent&lt;/code&gt;'s HTML element.</source>
          <target state="translated">设置 &lt;code&gt;LinkComponent&lt;/code&gt; 的HTML元素的 &lt;code&gt;rel&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="d5e1f88540ae2f1f6c34ad87101fb61aaa2e4704" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;tabindex&lt;/code&gt; attribute of the &lt;code&gt;LinkComponent&lt;/code&gt;'s HTML element.</source>
          <target state="translated">设置 &lt;code&gt;LinkComponent&lt;/code&gt; 的HTML元素的 &lt;code&gt;tabindex&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="2bdac2845cc69ea660701ca0222c09a0c44c26f0" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;target&lt;/code&gt; attribute of the &lt;code&gt;LinkComponent&lt;/code&gt;'s HTML element.</source>
          <target state="translated">设置 &lt;code&gt;LinkComponent&lt;/code&gt; 的HTML元素的 &lt;code&gt;target&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="fcf346b3d86476123ef32bd696299134f1d94520" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;title&lt;/code&gt; attribute of the &lt;code&gt;LinkComponent&lt;/code&gt;'s HTML element.</source>
          <target state="translated">设置 &lt;code&gt;LinkComponent&lt;/code&gt; 的HTML元素的 &lt;code&gt;title&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="b72787353f86d425923f841fb4aef6f74ac404b9" translate="yes" xml:space="preserve">
          <source>Sets the dependent keys on this computed property. Pass any number of arguments containing key paths that this computed property depends on.</source>
          <target state="translated">设置此计算属性的依赖键。传递任意数量的参数,这些参数包含这个计算属性所依赖的键路径。</target>
        </trans-unit>
        <trans-unit id="8dcc21cc9416b36d9a48400e5dcfa0b900385d0e" translate="yes" xml:space="preserve">
          <source>Sets the provided key or path to the value.</source>
          <target state="translated">将提供的键或路径设置为值。</target>
        </trans-unit>
        <trans-unit id="871a5db89a47b1c8ac126c47ae45dbaed6801707" translate="yes" xml:space="preserve">
          <source>Sets the value of a property on an object, respecting computed properties and notifying observers and other listeners of the change. If the property is not defined but the object implements the &lt;code&gt;setUnknownProperty&lt;/code&gt; method then that will be invoked as well.</source>
          <target state="translated">设置对象上的属性值，同时尊重计算所得的属性并将更改通知给观察者和其他侦听器。如果未定义属性，但是对象实现 &lt;code&gt;setUnknownProperty&lt;/code&gt; 方法，则该方法也会被调用。</target>
        </trans-unit>
        <trans-unit id="290a8a4289954bb2a5ee87f2331ca5e9d2142b2b" translate="yes" xml:space="preserve">
          <source>Sets the value on the named property for each member. This is more ergonomic than using other methods defined on this helper. If the object implements Ember.Observable, the value will be changed to &lt;code&gt;set(),&lt;/code&gt; otherwise it will be set directly. &lt;code&gt;null&lt;/code&gt; objects are skipped.</source>
          <target state="translated">在每个成员的命名属性上设置值。与使用此助手上定义的其他方法相比，这更符合人体工程学。如果对象实现Ember.Observable，则该值将更改为 &lt;code&gt;set(),&lt;/code&gt; 否则将直接设置。 &lt;code&gt;null&lt;/code&gt; 对象将被跳过。</target>
        </trans-unit>
        <trans-unit id="b425d7e560cd8c0761f98a652da8de1351923229" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;sortQueryParams&lt;/code&gt; to a falsey value will respect the original order.</source>
          <target state="translated">将 &lt;code&gt;sortQueryParams&lt;/code&gt; 设置为falsey值将遵循原始顺序。</target>
        </trans-unit>
        <trans-unit id="da33b396a5b97cdc6b9f02bcd176c913528421e0" translate="yes" xml:space="preserve">
          <source>Setting Computed Properties</source>
          <target state="translated">设置计算属性</target>
        </trans-unit>
        <trans-unit id="b2159831f0f013e12890235b72b76c9ed8107ba6" translate="yes" xml:space="preserve">
          <source>Setting any dependent property will propagate changes through any computed properties that depend on them, all the way down the chain of computed properties you've created.</source>
          <target state="translated">设置任何依赖性属性都会通过任何依赖它们的计算属性传播改变,一直到你创建的计算属性链。</target>
        </trans-unit>
        <trans-unit id="5789f3a613624c39e98b0a04a128ab506fbe4ddc" translate="yes" xml:space="preserve">
          <source>Setting coalesceFindRequests to &lt;code&gt;true&lt;/code&gt; also works for &lt;code&gt;store.find&lt;/code&gt; requests and &lt;code&gt;belongsTo&lt;/code&gt; relationships accessed within the same runloop. If you set &lt;code&gt;coalesceFindRequests: true&lt;/code&gt;</source>
          <target state="translated">将 &lt;code&gt;store.find&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 也适用于在同一运行循环中访问的store.find请求和 &lt;code&gt;belongsTo&lt;/code&gt; 关系。如果您设置 &lt;code&gt;coalesceFindRequests: true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afe29c914c9d854075bf9ebee96af7585fe24770" translate="yes" xml:space="preserve">
          <source>Setting properties on the component in &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement&quot;&gt;&lt;code&gt;didInsertElement()&lt;/code&gt;&lt;/a&gt; triggers a re-render, and for performance reasons, is not allowed.</source>
          <target state="translated">在&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement&quot;&gt; &lt;code&gt;didInsertElement()&lt;/code&gt; 中&lt;/a&gt;在组件上设置属性会触发重新渲染，并且出于性能原因，这是不允许的。</target>
        </trans-unit>
        <trans-unit id="f02aee210f24787a1e623ad68c0d1a1b060d3aeb" translate="yes" xml:space="preserve">
          <source>Setting query-params</source>
          <target state="translated">设置查询参数</target>
        </trans-unit>
        <trans-unit id="3d7cc07cf937737b1517c6bf9374d4cc18998479" translate="yes" xml:space="preserve">
          <source>Setting up Data for the Nested Detail Route</source>
          <target state="translated">设置嵌套的详细路线的数据</target>
        </trans-unit>
        <trans-unit id="04b56454c3e76a73bcf804097a9d07a7e2424bf3" translate="yes" xml:space="preserve">
          <source>Setup callbacks to be fired when the test helpers are injected into your application.</source>
          <target state="translated">设置回调,当测试辅助程序被注入到你的应用程序中时,回调将被触发。</target>
        </trans-unit>
        <trans-unit id="7fd361ad8b078a558ea7b7da0dad0bbe6c028891" translate="yes" xml:space="preserve">
          <source>Several of the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html&quot;&gt;Ember.computed&lt;/a&gt; macros utilize the &lt;code&gt;[]&lt;/code&gt; key to implement common use-cases. For instance, to create a computed property that mapped properties from an array, you could use &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html#method_map&quot;&gt;Ember.computed.map&lt;/a&gt; or build the computed property yourself:</source>
          <target state="translated">一些&lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html&quot;&gt;Ember.computed&lt;/a&gt;宏利用 &lt;code&gt;[]&lt;/code&gt; 键来实现常见的用例。例如，要创建一个从数组映射属性的计算属性，可以使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html#method_map&quot;&gt;Ember.computed.map&lt;/a&gt;或自己构建该计算属性：</target>
        </trans-unit>
        <trans-unit id="56671d09d11f94a0111d047a53973e69ddd5107c" translate="yes" xml:space="preserve">
          <source>Shadow DOM</source>
          <target state="translated">影子DOM</target>
        </trans-unit>
        <trans-unit id="a07efaea553500b80c6b1e25c2a1ad7f85b92746" translate="yes" xml:space="preserve">
          <source>Sharing Component Data with its Wrapped Content</source>
          <target state="translated">共享组件数据与其封装的内容</target>
        </trans-unit>
        <trans-unit id="5765ccb23e0fb8bade85df4ffb0d4efcfedb02e5" translate="yes" xml:space="preserve">
          <source>Shift an object from start of array or nil if none are left. Works just like &lt;code&gt;shift()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">将对象从数组的开头移至nil（如果不留任何对象）。就像 &lt;code&gt;shift()&lt;/code&gt; 一样工作，但是它兼容KVO。</target>
        </trans-unit>
        <trans-unit id="bcb7f8e893a6eec69601e5f12cb167564cd7ea66" translate="yes" xml:space="preserve">
          <source>Should I use controllers in my application? I've heard they're going away!</source>
          <target state="translated">我应该在应用中使用控制器吗?我听说它们要消失了!</target>
        </trans-unit>
        <trans-unit id="6c4c063ccc2f6265cd6469510436e8100e2e23a9" translate="yes" xml:space="preserve">
          <source>Should actually retrieve the object at the specified index from the content. You can override this method in subclasses to transform the content item to something new.</source>
          <target state="translated">实际上应该从内容中检索指定索引处的对象。你可以在子类中重写这个方法,将内容项转化为新的东西。</target>
        </trans-unit>
        <trans-unit id="e3cbebe0c33c59b226e4d26667ceeeb607570eb4" translate="yes" xml:space="preserve">
          <source>Show more details for a selected rental</source>
          <target state="translated">显示所选租金的更多细节</target>
        </trans-unit>
        <trans-unit id="63295e39bc7e2edd921e15de80cf52a0162dce6f" translate="yes" xml:space="preserve">
          <source>Show rentals on the home page</source>
          <target state="translated">在主页上显示租房信息</target>
        </trans-unit>
        <trans-unit id="a6df6bc849e9ed5bad5bd1b761e2d78888c983b9" translate="yes" xml:space="preserve">
          <source>Showing a property</source>
          <target state="translated">显示房产</target>
        </trans-unit>
        <trans-unit id="5feabe6b60582bbf4b541103f30632fee297466c" translate="yes" xml:space="preserve">
          <source>Sideloaded Data</source>
          <target state="translated">侧载数据</target>
        </trans-unit>
        <trans-unit id="f5028052c614a640caa81611333680ece76b35e0" translate="yes" xml:space="preserve">
          <source>Silencing Deprecation Warnings During Compile</source>
          <target state="translated">在编译过程中消除弃用警告。</target>
        </trans-unit>
        <trans-unit id="af61b24dae3801016bbf21366ede7ddbe142922e" translate="yes" xml:space="preserve">
          <source>Similar to how the default &lt;code&gt;loading&lt;/code&gt; event handlers are implemented, the default &lt;code&gt;error&lt;/code&gt; handlers will look for an appropriate error substate to enter, if one can be found.</source>
          <target state="translated">与实现默认 &lt;code&gt;loading&lt;/code&gt; 事件处理程序的方式类似，如果可以找到默认 &lt;code&gt;error&lt;/code&gt; 处理程序，默认错误处理程序将寻找要输入的适当错误子状态。</target>
        </trans-unit>
        <trans-unit id="717acf41849b10523800fa58b23cc2b20a9ef6da" translate="yes" xml:space="preserve">
          <source>Similar to map, this specialized function returns the value of the named property on all items in the enumeration.</source>
          <target state="translated">与map类似,这个专门的函数返回命名属性在枚举中所有项上的值。</target>
        </trans-unit>
        <trans-unit id="74e714802d7db3b86e903677715205f93a921c22" translate="yes" xml:space="preserve">
          <source>Similarly, if your backend store provides data in a format other than JSON API, you can use the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalizeResponse&quot;&gt;&lt;code&gt;normalizeResponse()&lt;/code&gt;&lt;/a&gt; hook. Using the same example as above, if the server provides data that looks like:</source>
          <target state="translated">同样，如果后端存储以JSON API以外的格式提供数据，则可以使用&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalizeResponse&quot;&gt; &lt;code&gt;normalizeResponse()&lt;/code&gt; &lt;/a&gt;挂钩。使用与上述相同的示例，如果服务器提供的数据如下所示：</target>
        </trans-unit>
        <trans-unit id="e5ba23a2acdb58eae654126aeb02c16cfa736653" translate="yes" xml:space="preserve">
          <source>Similarly, in response to a &lt;code&gt;GET&lt;/code&gt; request for &lt;code&gt;/posts&lt;/code&gt;, the JSON should look like this:</source>
          <target state="translated">同样，响应对 &lt;code&gt;/posts&lt;/code&gt; 的 &lt;code&gt;GET&lt;/code&gt; 请求，JSON应如下所示：</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="translated">简单的例子</target>
        </trans-unit>
        <trans-unit id="5d072a0f490db522bd703110a84349b2f76d1d40" translate="yes" xml:space="preserve">
          <source>Simple Transition Example</source>
          <target state="translated">简单过渡示例</target>
        </trans-unit>
        <trans-unit id="7b4ed4e4198e38ae80e5b6a6af9aeb8f248f3233" translate="yes" xml:space="preserve">
          <source>Simply converts the enumerable into a genuine array. The order is not guaranteed. Corresponds to the method implemented by Prototype.</source>
          <target state="translated">只需将enumerable转换为真正的数组。顺序不保证。对应于Prototype实现的方法。</target>
        </trans-unit>
        <trans-unit id="fe202f68e7bb9a71a693a3787ee7684995266c8a" translate="yes" xml:space="preserve">
          <source>Simply define a template called &lt;code&gt;loading&lt;/code&gt; (and optionally a corresponding route) that Ember will transition to. The intermediate transition into the loading substate happens immediately (synchronously), the URL won't be updated, and, unlike other transitions, the currently active transition won't be aborted.</source>
          <target state="translated">只需定义一个称为 &lt;code&gt;loading&lt;/code&gt; （以及可选的相应路线）的模板，Ember将过渡到该模板。到加载子状态的中间过渡会立即（同步）发生，不会更新URL，并且与其他过渡不同，当前活动的过渡不会中止。</target>
        </trans-unit>
        <trans-unit id="97cf625e23a87e8fb775cd15dcb177e76da7d713" translate="yes" xml:space="preserve">
          <source>Simulates a key event type, e.g. &lt;code&gt;keypress&lt;/code&gt;, &lt;code&gt;keydown&lt;/code&gt;, &lt;code&gt;keyup&lt;/code&gt; with the desired keyCode on element found by the selector.</source>
          <target state="translated">用选择器找到的元素上的所需keyCode 模拟键事件类型，例如 &lt;code&gt;keypress&lt;/code&gt; ， &lt;code&gt;keydown&lt;/code&gt; ， &lt;code&gt;keyup&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d573de332969d08498e24e616e22a931b37eb39" translate="yes" xml:space="preserve">
          <source>Simulates a key event, e.g. &lt;code&gt;keypress&lt;/code&gt;, &lt;code&gt;keydown&lt;/code&gt;, &lt;code&gt;keyup&lt;/code&gt; with the desired keyCode Example:</source>
          <target state="translated">模拟一个按键事件，例如使用所需的keyCode进行 &lt;code&gt;keypress&lt;/code&gt; ， &lt;code&gt;keydown&lt;/code&gt; ， &lt;code&gt;keyup&lt;/code&gt; 的代码示例：</target>
        </trans-unit>
        <trans-unit id="fe22422d207cd0772ccfa88aaa36392c7d87ecf6" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;didUpdateAttrs&lt;/code&gt; is called prior to rerender, you can use this hook to execute code when specific attributes are changed. This hook can be an effective alternative to an observer, as it will run prior to a re-render, but after an attribute has changed.</source>
          <target state="translated">由于 &lt;code&gt;didUpdateAttrs&lt;/code&gt; 是在重新渲染之前调用的，因此可以在更改特定属性时使用此挂钩执行代码。该挂钩可以替代观察者，因为它会在重新渲染之前运行，但是在属性更改之后才能运行。</target>
        </trans-unit>
        <trans-unit id="b527d855f262ec89fbcbd6c18de1d551d43311d9" translate="yes" xml:space="preserve">
          <source>Since Ember addons are npm packages, &lt;code&gt;ember install&lt;/code&gt; installs them in the &lt;code&gt;node_modules&lt;/code&gt; directory, and makes an entry in &lt;code&gt;package.json&lt;/code&gt;. Be sure to restart your server after the addon has installed successfully. Restarting the server will incorporate the new CSS and refreshing the browser window will give you this:</source>
          <target state="translated">由于Ember插件是npm软件包，因此 &lt;code&gt;ember install&lt;/code&gt; 将它们安装在 &lt;code&gt;node_modules&lt;/code&gt; 目录中，并在 &lt;code&gt;package.json&lt;/code&gt; 中进行输入。确保插件成功安装后，重新启动服务器。重新启动服务器将包含新的CSS，刷新浏览器窗口将为您提供以下信息：</target>
        </trans-unit>
        <trans-unit id="5760823c11d76bb4f0f8aa397fbe539249ff2741" translate="yes" xml:space="preserve">
          <source>Since a JSON API Document can have meta defined in multiple locations you can use the specific serializer hooks if you need to customize the meta.</source>
          <target state="translated">由于一个JSON API Document可以在多个位置定义元,如果你需要自定义元,你可以使用特定的序列器钩子。</target>
        </trans-unit>
        <trans-unit id="a3a256154d2dce95ced059699c91ae1f2f5c9d2c" translate="yes" xml:space="preserve">
          <source>Since a route's &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_beforeModel&quot;&gt;&lt;code&gt;beforeModel()&lt;/code&gt;&lt;/a&gt; executes before the &lt;code&gt;model()&lt;/code&gt; hook, it's a good place to do a redirect if you don't need any information that is contained in the model.</source>
          <target state="translated">由于路由的&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_beforeModel&quot;&gt; &lt;code&gt;beforeModel()&lt;/code&gt; &lt;/a&gt;在 &lt;code&gt;model()&lt;/code&gt; 挂钩之前执行，因此如果您不需要模型中包含的任何信息，则是进行重定向的好地方。</target>
        </trans-unit>
        <trans-unit id="1df2b7cd90ba8966b9e8733c80dc430ec4b6a752" translate="yes" xml:space="preserve">
          <source>Since our component is expecting the filter process to be asynchronous, we return promises from our filter, using &lt;a href=&quot;http://emberjs.com/api/classes/RSVP.html&quot;&gt;Ember's RSVP library&lt;/a&gt;.</source>
          <target state="translated">由于我们的组件期望过滤器过程是异步的，因此我们使用&lt;a href=&quot;http://emberjs.com/api/classes/RSVP.html&quot;&gt;Ember的RSVP库&lt;/a&gt;从过滤器返回了Promise。</target>
        </trans-unit>
        <trans-unit id="410a75600d988e5e0052e587fd06ad0d2fe20811" translate="yes" xml:space="preserve">
          <source>Since our data is hard-coded in Mirage, we know that there is only one rental with a city name of &quot;Seattle&quot;, so we assert that the number of listings is one and that the location it displays is named, &quot;Seattle&quot;.</source>
          <target state="translated">由于我们的数据在Mirage中是硬编码的,所以我们知道只有一个城市名为 &quot;西雅图 &quot;的租房,所以我们断言房源数量是一个,而且它显示的位置名为,&quot;西雅图&quot;。</target>
        </trans-unit>
        <trans-unit id="ba722444287b7c4015475cc81a6d6d752afc68bd" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;didReceiveAttrs&lt;/code&gt; hook is called every time a component's attributes are updated whether on render or re-render, you can use the hook to effectively act as an observer, ensuring code is executed every time an attribute changes.</source>
          <target state="translated">由于 &lt;code&gt;didReceiveAttrs&lt;/code&gt; 挂钩是在组件的属性每次在渲染或重新渲染时更新时调用的，因此您可以使用该挂钩有效地充当观察者，确保每次属性更改时都执行代码。</target>
        </trans-unit>
        <trans-unit id="28d7c278a30e6ec4d4f3023b775fa6840cb84e97" translate="yes" xml:space="preserve">
          <source>Since the specific &lt;code&gt;id&lt;/code&gt; of the &lt;code&gt;user&lt;/code&gt; is not known beforehand, we can use &lt;code&gt;queryRecord&lt;/code&gt; to get the user:</source>
          <target state="translated">由于特定 &lt;code&gt;id&lt;/code&gt; 的的 &lt;code&gt;user&lt;/code&gt; 事先不知道，我们可以使用 &lt;code&gt;queryRecord&lt;/code&gt; 获取用户：</target>
        </trans-unit>
        <trans-unit id="51f0b4a52b8cebee35dc789d53b13ace54ffb771" translate="yes" xml:space="preserve">
          <source>Since there is no access to jQuery in the non-browser environment, you must also specify a DOM &lt;code&gt;Element&lt;/code&gt; object in the same &lt;code&gt;document&lt;/code&gt; for the &lt;code&gt;rootElement&lt;/code&gt; option (as opposed to a selector string like &lt;code&gt;&quot;body&quot;&lt;/code&gt;).</source>
          <target state="translated">由于在非浏览器环境中无法访问jQuery，因此还必须在同一 &lt;code&gt;document&lt;/code&gt; 为 &lt;code&gt;rootElement&lt;/code&gt; 选项指定DOM &lt;code&gt;Element&lt;/code&gt; 对象（与选择器字符串（如 &lt;code&gt;&quot;body&quot;&lt;/code&gt; ））。</target>
        </trans-unit>
        <trans-unit id="bd76475c68e526debe88fcdc606730652138849e" translate="yes" xml:space="preserve">
          <source>Since we added &lt;code&gt;:rental_id&lt;/code&gt; to the &lt;code&gt;show&lt;/code&gt; path in our router, &lt;code&gt;rental_id&lt;/code&gt; is now available in our &lt;code&gt;model&lt;/code&gt; hook. When we call &lt;code&gt;this.get('store').findRecord('rental', params.rental_id)&lt;/code&gt;, Ember Data queries &lt;code&gt;/rentals/our-id&lt;/code&gt; using a HTTP GET request (&lt;a href=&quot;https://guides.emberjs.com/models/&quot;&gt;learn more about that here&lt;/a&gt;).</source>
          <target state="translated">因为我们在路由器的 &lt;code&gt;show&lt;/code&gt; 路径中添加了 &lt;code&gt;:rental_id&lt;/code&gt; ， &lt;code&gt;rental_id&lt;/code&gt; 现在在 &lt;code&gt;model&lt;/code&gt; 挂钩中可以使用rental_id。当我们调用 &lt;code&gt;this.get('store').findRecord('rental', params.rental_id)&lt;/code&gt; ，Ember Data 使用HTTP GET请求查询 &lt;code&gt;/rentals/our-id&lt;/code&gt; （&lt;a href=&quot;https://guides.emberjs.com/models/&quot;&gt;在此处了解更多信息&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a193b3400008fcdd68f61cf30910ac15e02de1ad" translate="yes" xml:space="preserve">
          <source>Since we have already set up Ember Mirage in our development environment, Mirage will return the data we requested without actually making a network request.</source>
          <target state="translated">由于我们已经在开发环境中设置了Ember Mirage,所以Mirage将返回我们所请求的数据,而不需要实际进行网络请求。</target>
        </trans-unit>
        <trans-unit id="d50f255275c91b6d41ca18a9a609fd25ba369850" translate="yes" xml:space="preserve">
          <source>Since we haven't added any functionality to our application yet, we'll use this first test to get started on running tests in our app.</source>
          <target state="translated">由于我们还没有为我们的应用程序添加任何功能,我们将使用这个第一个测试来开始在我们的应用程序中运行测试。</target>
        </trans-unit>
        <trans-unit id="59ca8024809d59f43c02b2a1ec4a73e4e2d23ac4" translate="yes" xml:space="preserve">
          <source>Since we want to remove this namespace, we can define a serializer for the application that will remove &quot;blog/&quot; from the payload key whenver it's encountered by Ember Data:</source>
          <target state="translated">由于我们想要删除这个命名空间,我们可以为应用程序定义一个序列化器,当Ember Data遇到 &quot;blog/&quot;时,这个序列化器将从payload键中删除。</target>
        </trans-unit>
        <trans-unit id="a516a3ce4b9fd1e3a2a9186564fe4ca0d9da8218" translate="yes" xml:space="preserve">
          <source>Skipping tests</source>
          <target state="translated">跳过测试</target>
        </trans-unit>
        <trans-unit id="de370e832d39727a0c5b9309d06edd07070c125e" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; is shorthand for: &lt;code&gt;{ serialize: 'records', deserialize: 'records' }&lt;/code&gt;</source>
          <target state="translated">因此， &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; 的缩写为： &lt;code&gt;{ serialize: 'records', deserialize: 'records' }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92b64ffe3c61fe82b2f00e41e184a5ff233a2011" translate="yes" xml:space="preserve">
          <source>So far in our example, the action we have passed to &lt;code&gt;button-with-confirmation&lt;/code&gt; is a function that accepts one argument, &lt;code&gt;messageType&lt;/code&gt;. Suppose we want to extend this by allowing &lt;code&gt;sendMessage&lt;/code&gt; to take a second argument, the actual text of the message the user is sending:</source>
          <target state="translated">到目前为止，在我们的示例中，我们传递给 &lt;code&gt;button-with-confirmation&lt;/code&gt; 的操作是一个接受一个参数 &lt;code&gt;messageType&lt;/code&gt; 的函数。假设我们想通过允许 &lt;code&gt;sendMessage&lt;/code&gt; 接受第二个参数（用户正在发送的消息的实际文本）来扩展它：</target>
        </trans-unit>
        <trans-unit id="860179c222e257dfd377a3ba0841f6fa360f92ff" translate="yes" xml:space="preserve">
          <source>So far, our app is directly showing the user data from our Ember Data models. As our app grows, we will want to manipulate data further before presenting it to our users. For this reason, Ember offers Handlebars template helpers to decorate the data in our templates. Let's use a handlebars helper to allow our users to quickly see if a property is &quot;Standalone&quot; or part of a &quot;Community&quot;.</source>
          <target state="translated">到目前为止,我们的应用是直接显示来自我们Ember数据模型的用户数据。随着我们应用的发展,我们会希望在向用户展示数据之前进一步操作数据。为此,Ember提供了Handlebars模板助手来装饰我们模板中的数据。让我们使用一个handlebars助手来让我们的用户快速看到一个属性是 &quot;独立 &quot;还是 &quot;社区 &quot;的一部分。</target>
        </trans-unit>
        <trans-unit id="4beaba805d3a97bce58afc2f7cb86863c0470f86" translate="yes" xml:space="preserve">
          <source>So far, your application is listing data, but there is no way for the user to interact with the information. In web applications you often want to listen for user events like clicks or hovers. Ember makes this easy to do. First add an &lt;code&gt;action&lt;/code&gt; helper to the &lt;code&gt;li&lt;/code&gt; in your &lt;code&gt;people-list&lt;/code&gt; component.</source>
          <target state="translated">到目前为止，您的应用程序正在列出数据，但是用户无法与信息进行交互。在Web应用程序中，您通常希望侦听诸如单击或悬停之类的用户事件。灰烬使这容易做到。首先添加一个 &lt;code&gt;action&lt;/code&gt; 助手的 &lt;code&gt;li&lt;/code&gt; 在 &lt;code&gt;people-list&lt;/code&gt; 的组成部分。</target>
        </trans-unit>
        <trans-unit id="82dbd01dbf5e166342277657acc79af70412fa18" translate="yes" xml:space="preserve">
          <source>So this change to &lt;code&gt;firstName&lt;/code&gt; was observed by &lt;code&gt;fullName&lt;/code&gt; computed property, which was itself observed by the &lt;code&gt;description&lt;/code&gt; property.</source>
          <target state="translated">所以这个变化 &lt;code&gt;firstName&lt;/code&gt; 被观察到 &lt;code&gt;fullName&lt;/code&gt; 计算的属性，它本身就是观察到的 &lt;code&gt;description&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="7c179ab2cf598954fd3d4e13b9ad80cb323f34c9" translate="yes" xml:space="preserve">
          <source>So too with JSON API. By using JSON API to interop between your Ember app and your server, you can entirely change your backend stack without breaking your frontend. And as you add apps for other platforms, such as iOS and Android, you will be able to leverage JSON API libraries for those platforms to easily consume the same API your Ember app uses.</source>
          <target state="translated">JSON API也是如此。通过使用JSON API在你的Ember应用和服务器之间进行互操作,你可以完全改变你的后端堆栈而不破坏你的前端。而当你为其他平台(如iOS和Android)添加应用时,你将能够利用这些平台的JSON API库来轻松地消耗你的Ember应用所使用的相同的API。</target>
        </trans-unit>
        <trans-unit id="1b4ae5f1c58dc8bb8ea15838b3e9682246652530" translate="yes" xml:space="preserve">
          <source>So, how can we provide some visual feedback during the transition?</source>
          <target state="translated">那么,在过渡期间,我们如何提供一些视觉反馈呢?</target>
        </trans-unit>
        <trans-unit id="fd7b7f2884ce4c1630ffc4f76897bd0d01d7ef54" translate="yes" xml:space="preserve">
          <source>So, if we want to display a purchase total we can pass the value into the template in cents:</source>
          <target state="translated">所以,如果我们想显示购买总数,我们可以将数值以分值传入模板。</target>
        </trans-unit>
        <trans-unit id="820ab04fe6d1513548b6823192b5113a17600f54" translate="yes" xml:space="preserve">
          <source>Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary headers can be set as key/value pairs on the &lt;code&gt;JSONAPIAdapter&lt;/code&gt;'s &lt;code&gt;headers&lt;/code&gt; object and Ember Data will send them along with each ajax request.</source>
          <target state="translated">某些API需要HTTP标头，例如提供API密钥。可以在 &lt;code&gt;JSONAPIAdapter&lt;/code&gt; 的 &lt;code&gt;headers&lt;/code&gt; 对象上将任意标头设置为键/值对，Ember Data会将它们与每个ajax请求一起发送。</target>
        </trans-unit>
        <trans-unit id="8b2ac0c846f9c6b1368c32fcb57645817bd2729e" translate="yes" xml:space="preserve">
          <source>Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary headers can be set as key/value pairs on the &lt;code&gt;RESTAdapter&lt;/code&gt;'s &lt;code&gt;headers&lt;/code&gt; object and Ember Data will send them along with each ajax request.</source>
          <target state="translated">某些API需要HTTP标头，例如提供API密钥。可以在 &lt;code&gt;RESTAdapter&lt;/code&gt; 的 &lt;code&gt;headers&lt;/code&gt; 对象上将任意标头设置为键/值对，Ember Data会将它们与每个ajax请求一起发送。</target>
        </trans-unit>
        <trans-unit id="1ff79da2240d73d23b85815d98e514154e6babb3" translate="yes" xml:space="preserve">
          <source>Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary headers can be set as key/value pairs on the &lt;code&gt;RESTAdapter&lt;/code&gt;'s &lt;code&gt;headers&lt;/code&gt; object and Ember Data will send them along with each ajax request. For dynamic headers see &lt;a href=&quot;https://emberjs.com/api/data/classes/DS.RESTAdapter.html#toc_headers-customization&quot;&gt;headers customization&lt;/a&gt;.</source>
          <target state="translated">某些API需要HTTP标头，例如提供API密钥。可以在 &lt;code&gt;RESTAdapter&lt;/code&gt; 的 &lt;code&gt;headers&lt;/code&gt; 对象上将任意标头设置为键/值对，Ember Data会将它们与每个ajax请求一起发送。有关动态标题，请参见&lt;a href=&quot;https://emberjs.com/api/data/classes/DS.RESTAdapter.html#toc_headers-customization&quot;&gt;标题定制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="589305bc3eb0d013e4fe10cb12d21b40cca5f01f" translate="yes" xml:space="preserve">
          <source>Some addons might conditionally include polyfills only if needed. Some linters may emit warnings when using features not yet fully supported in your targets. Some addons may even automatically prefix unsupported CSS properties.</source>
          <target state="translated">一些插件可能仅在需要时才会有条件地包含polyfills。当使用目标中尚未完全支持的功能时,一些插件可能会发出警告。有些插件甚至会自动给不支持的CSS属性加前缀。</target>
        </trans-unit>
        <trans-unit id="17a6dac8bf912ce569cbeab14f1bf531b4c08379" translate="yes" xml:space="preserve">
          <source>Some examples modifying that default behavior:</source>
          <target state="translated">一些修改该默认行为的例子。</target>
        </trans-unit>
        <trans-unit id="82534b5183631ee9d5eeba124dc1c2d8a8efa3a1" translate="yes" xml:space="preserve">
          <source>Some examples of how names are resolved:</source>
          <target state="translated">一些关于如何解决名字的例子。</target>
        </trans-unit>
        <trans-unit id="9d5184c34d7d66d58908b766bee8f66460408f46" translate="yes" xml:space="preserve">
          <source>Some models may have properties that are deeply nested objects of readonly data. The na&amp;iuml;ve solution would be to define models for each nested object and use &lt;code&gt;hasMany&lt;/code&gt; and &lt;code&gt;belongsTo&lt;/code&gt; to recreate the nested relationship. However, since readonly data will never need to be updated and saved this often results in the creation of a great deal of code for very little benefit. An alternate approach is to define these relationships using an attribute with no transform (&lt;code&gt;DS.attr()&lt;/code&gt;). This makes it easy to access readonly values in computed properties and templates without the overhead of defining extraneous models.</source>
          <target state="translated">某些模型的属性可能是只读数据的深层嵌套对象。幼稚的解决方案是为每个嵌套对象定义模型，并使用 &lt;code&gt;hasMany&lt;/code&gt; 和 &lt;code&gt;belongsTo&lt;/code&gt; 重新创建嵌套关系。但是，由于永远不需要更新和保存只读数据，因此这通常会导致创建大量代码，而带来的好处却很少。另一种方法是使用没有变换的属性（ &lt;code&gt;DS.attr()&lt;/code&gt; ）定义这些关系。这使访问已计算的属性和模板中的只读值变得容易，而无需定义无关模型的开销。</target>
        </trans-unit>
        <trans-unit id="0c345287ac108fa43e40986e9e0b206ee82b4fe8" translate="yes" xml:space="preserve">
          <source>Some of Ember's test helpers are promises that wait for the run loop to empty before resolving. If your application has code that runs &lt;em&gt;outside&lt;/em&gt; a run loop, these will resolve too early and give erroneous test failures which are difficult to find. Disabling autoruns help you identify these scenarios and helps both your testing and your application!</source>
          <target state="translated">Ember的一些测试助手承诺在解决之前要等待运行循环清空。如果您的应用程序具有&lt;em&gt;在&lt;/em&gt;运行循环&lt;em&gt;之外&lt;/em&gt;运行的代码，则这些代码将过早解决，并导致错误的测试失败，很难找到。禁用自动运行可以帮助您识别这些情况，并有助于测试和应用程序！</target>
        </trans-unit>
        <trans-unit id="4979198f37570d49855015976a8e9dfdb6023e02" translate="yes" xml:space="preserve">
          <source>Some of the helpers we'll use commonly are:</source>
          <target state="translated">我们会常用到的一些助手有。</target>
        </trans-unit>
        <trans-unit id="3748e66aa53dcbbdabc1f3d7af1f40169fdff824" translate="yes" xml:space="preserve">
          <source>Some of the more common ways to report a problem with the guides are:</source>
          <target state="translated">一些比较常见的报告指南问题的方式是:</target>
        </trans-unit>
        <trans-unit id="5337883a101c091bf437d743927429e7f9b3a8dc" translate="yes" xml:space="preserve">
          <source>Some of the reasons this may happen:</source>
          <target state="translated">可能发生这种情况的一些原因:</target>
        </trans-unit>
        <trans-unit id="822e1f477acc562b0e523818fa99c2731cc5d901" translate="yes" xml:space="preserve">
          <source>Some of these features that you'll learn about in the guides are:</source>
          <target state="translated">这些功能中,你将在指南中了解到一些。</target>
        </trans-unit>
        <trans-unit id="66952b6d0704d8bd5ed88829a1728002186d07f9" translate="yes" xml:space="preserve">
          <source>Some other event in the app causes the URL to change.</source>
          <target state="translated">应用中的一些其他事件导致URL发生变化。</target>
        </trans-unit>
        <trans-unit id="6662963cf7cb67b19d16e3797446e1a4df2164ae" translate="yes" xml:space="preserve">
          <source>Some properties are not only grouped by inheritance, but also by framework level semantics. For example, if you inspect an Ember Data model, you can see &lt;code&gt;Attributes&lt;/code&gt;, &lt;code&gt;Belongs To&lt;/code&gt;, &lt;code&gt;Has Many&lt;/code&gt;, and &lt;code&gt;Flags&lt;/code&gt; groups.</source>
          <target state="translated">一些属性不仅按继承进行分组，还按框架级语义进行分组。例如，如果检查Ember Data模型，则可以看到 &lt;code&gt;Attributes&lt;/code&gt; ， &lt;code&gt;Belongs To&lt;/code&gt; ， &lt;code&gt;Has Many&lt;/code&gt; 和 &lt;code&gt;Flags&lt;/code&gt; 组。</target>
        </trans-unit>
        <trans-unit id="325238f44bc39a7d51558fbf18caf5277d0da375" translate="yes" xml:space="preserve">
          <source>Some reasons for customizing an Adapter include using &lt;code&gt;underscores_case&lt;/code&gt; in your urls, using a medium other than REST to communicate with your backend API or even using a &lt;a href=&quot;https://github.com/locks/ember-localstorage-adapter&quot;&gt;local storage backend&lt;/a&gt;.</source>
          <target state="translated">定制适配器的一些原因包括在URL中使用 &lt;code&gt;underscores_case&lt;/code&gt; ，使用REST以外的媒体与后端API进行通信，甚至使用&lt;a href=&quot;https://github.com/locks/ember-localstorage-adapter&quot;&gt;本地存储后端&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2244f25ae871987e59d131e17c8c7397712981aa" translate="yes" xml:space="preserve">
          <source>Some routes always display the same model. For example, the &lt;code&gt;/photos&lt;/code&gt; route will always display the same list of photos available in the application. If your user leaves this route and comes back later, the model does not change.</source>
          <target state="translated">有些路线总是显示相同的模型。例如， &lt;code&gt;/photos&lt;/code&gt; 路由将始终显示应用程序中可用的相同照片列表。如果您的用户离开了这条路线并稍后返回，则模型不会更改。</target>
        </trans-unit>
        <trans-unit id="dfada9d7be3abdb25489a10a3babdd4c487f5a91" translate="yes" xml:space="preserve">
          <source>Some specific examples of units tests are:</source>
          <target state="translated">单位测试的一些具体例子是:</target>
        </trans-unit>
        <trans-unit id="f4c0047cd154d80ed200c3a10a6e33a060f165c8" translate="yes" xml:space="preserve">
          <source>Some times you might be working on a feature, but know that a certain test will fail so you might want to skip it. You can do it by using &lt;code&gt;skip&lt;/code&gt;:</source>
          <target state="translated">有时您可能正在使用某个功能，但是知道某个测试将失败，因此您可能希望跳过它。您可以使用 &lt;code&gt;skip&lt;/code&gt; 来做到这一点：</target>
        </trans-unit>
        <trans-unit id="e8353c07cd51f4950ee2ad76a1992e4ffb81690e" translate="yes" xml:space="preserve">
          <source>Some types of computed properties are very common. Ember provides a number of computed property macros, which are shorter ways of expressing certain types of computed property.</source>
          <target state="translated">有些类型的计算属性是非常常见的。Ember提供了许多计算属性宏,这些宏是表达某些类型计算属性的较短方式。</target>
        </trans-unit>
        <trans-unit id="86c891d4cd8c7cba722589fb8d2aa6a1abb982b5" translate="yes" xml:space="preserve">
          <source>Sometimes a service may or may not exist, like when an initializer conditionally registers a service. Since normal injection will throw an error if the service doesn't exist, you must look up the service using Ember's &lt;a href=&quot;https://emberjs.com/api/classes/Ember.html#method_getOwner&quot;&gt;&lt;code&gt;getOwner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">有时服务可能存在或不存在，例如初始化程序有条件地注册服务时。由于如果服务不存在，正常注入将引发错误，因此必须使用Ember的&lt;a href=&quot;https://emberjs.com/api/classes/Ember.html#method_getOwner&quot;&gt; &lt;code&gt;getOwner&lt;/code&gt; &lt;/a&gt;查找服务。</target>
        </trans-unit>
        <trans-unit id="3155e1aa9ca809aad16247d1dc430dba0afcf4d9" translate="yes" xml:space="preserve">
          <source>Sometimes controllers have dependencies on other controllers. This is accomplished by injecting one controller into another. For example, here are two simple controllers. The &lt;code&gt;CommentsController&lt;/code&gt; uses the &lt;code&gt;PostController&lt;/code&gt; via &lt;code&gt;inject&lt;/code&gt;:</source>
          <target state="translated">有时，控制器对其他控制器有依赖性。这是通过将一个控制器注入另一个控制器来实现的。例如，这是两个简单的控制器。该 &lt;code&gt;CommentsController&lt;/code&gt; 使用 &lt;code&gt;PostController&lt;/code&gt; 中通过 &lt;code&gt;inject&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9e4d9e623bb94a60e9ac83b620b9d575221d6a19" translate="yes" xml:space="preserve">
          <source>Sometimes the parent component invoking an action has some context needed for the action that the child component doesn't. Consider, for example, the case where the &lt;code&gt;button-with-confirmation&lt;/code&gt; component we've defined is used within &lt;code&gt;send-message&lt;/code&gt;. The &lt;code&gt;sendMessage&lt;/code&gt; action that we pass to the child component may expect a message type parameter to be provided as an argument:</source>
          <target state="translated">有时，调用动作的父组件具有某些动作所需的上下文，而子组件则不需要。例如，考虑在 &lt;code&gt;send-message&lt;/code&gt; 中使用我们定义 &lt;code&gt;button-with-confirmation&lt;/code&gt; 组件的情况。我们传递给子组件的 &lt;code&gt;sendMessage&lt;/code&gt; 操作可能希望将消息类型参数作为参数提供：</target>
        </trans-unit>
        <trans-unit id="b795927e172ff54b29fd66e4ef2233525e286ec2" translate="yes" xml:space="preserve">
          <source>Sometimes the value you want to propagate to a downstream promise can only be retrieved asynchronously. This can be achieved by returning a promise in the fulfillment or rejection handler. The downstream promise will then be pending until the returned promise is settled. This is called &lt;em&gt;assimilation&lt;/em&gt;.</source>
          <target state="translated">有时，您要传播到下游Promise的值只能异步获取。这可以通过在实现或拒绝处理程序中返回承诺来实现。然后，下游承诺将待定，直到解决了返回的承诺。这称为&lt;em&gt;同化&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fb6b416b736de5984855b00b7181426c6ea9cfe1" translate="yes" xml:space="preserve">
          <source>Sometimes we want to set relationships on already existing records. We can simply set a &lt;code&gt;belongsTo&lt;/code&gt; relationship:</source>
          <target state="translated">有时我们想在已经存在的记录上设置关系。我们可以简单地设置一个 &lt;code&gt;belongsTo&lt;/code&gt; 关系：</target>
        </trans-unit>
        <trans-unit id="e3938ef49fd1f00900f13ab44705cfe380190afd" translate="yes" xml:space="preserve">
          <source>Sometimes you don't care if properties of individual array items change. In this case use the &lt;code&gt;[]&lt;/code&gt; key instead of &lt;code&gt;@each&lt;/code&gt;. Computed properties dependent on an array using the &lt;code&gt;[]&lt;/code&gt; key will only update if items are added to or removed from the array, or if the array property is set to a different array. For example:</source>
          <target state="translated">有时您不在乎单个数组项的属性是否发生变化。在这种情况下，请使用 &lt;code&gt;[]&lt;/code&gt; 键而不是 &lt;code&gt;@each&lt;/code&gt; 。使用 &lt;code&gt;[]&lt;/code&gt; 键依赖于数组的计算属性仅在将项目添加到数组中或从数组中删除时，或者如果将数组属性设置为其他数组时才更新。例如：</target>
        </trans-unit>
        <trans-unit id="59593e85c482d9ccffbf9cb3f10447cbf9a7e137" translate="yes" xml:space="preserve">
          <source>Sometimes you have a computed property whose value depends on the properties of items in an array. For example, you may have an array of todo items, and want to calculate the incomplete todo's based on their &lt;code&gt;isDone&lt;/code&gt; property.</source>
          <target state="translated">有时您有一个计算属性，其值取决于数组中各项的属性。例如，您可能有一个待办事项数组，并想根据其 &lt;code&gt;isDone&lt;/code&gt; 属性计算不完整的待办事项。</target>
        </trans-unit>
        <trans-unit id="416096650446b210755d175075d7e07b083b9ad1" translate="yes" xml:space="preserve">
          <source>Sometimes you need to fetch a model, but your route doesn't have the parameters, because it's a child route and the route directly above or a few levels above has the parameters that your route needs.</source>
          <target state="translated">有时你需要获取一个模型,但你的路由没有参数,因为它是一个子路由,而直接上面或上面几层的路由有你的路由需要的参数。</target>
        </trans-unit>
        <trans-unit id="559f553ca9e321ad0a7cbfeb49c2a261a0036395" translate="yes" xml:space="preserve">
          <source>Sometimes you need to retain the &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">有时您需要保留 &lt;code&gt;this&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="069522e3125331b06bf7bf0225dd816607897fe7" translate="yes" xml:space="preserve">
          <source>Sometimes you want to redirect a user to a different page than what they requested for.</source>
          <target state="translated">有时候,你想把用户重定向到一个不同于他们请求的页面。</target>
        </trans-unit>
        <trans-unit id="2baef004d709137087990a2c9d850371fca71c1c" translate="yes" xml:space="preserve">
          <source>Sometimes, you may want to define a component that wraps content provided by other templates.</source>
          <target state="translated">有时,你可能想定义一个组件来包装其他模板提供的内容。</target>
        </trans-unit>
        <trans-unit id="96659bf5510b1ddbf595565c481a37824bc493f8" translate="yes" xml:space="preserve">
          <source>Specifies how records can be filtered. Records returned will need to have a &lt;code&gt;filterValues&lt;/code&gt; property with a key for every name in the returned array.</source>
          <target state="translated">指定如何过滤记录。返回的记录将需要具有 &lt;code&gt;filterValues&lt;/code&gt; 属性，并为返回的数组中的每个名称提供键。</target>
        </trans-unit>
        <trans-unit id="95f6dd8dc212ba5d85302c1420a17db8da9053f3" translate="yes" xml:space="preserve">
          <source>Specify a method that observes property changes.</source>
          <target state="translated">指定一个观察属性变化的方法。</target>
        </trans-unit>
        <trans-unit id="223591aeca04cad98919771b70c08a1289123a53" translate="yes" xml:space="preserve">
          <source>Specifying DOM event type</source>
          <target state="translated">指定DOM事件类型</target>
        </trans-unit>
        <trans-unit id="9dc9de0aa5ed554b19547386f6cca49a1ec57918" translate="yes" xml:space="preserve">
          <source>Specifying Initializer Order</source>
          <target state="translated">指定初始化器顺序</target>
        </trans-unit>
        <trans-unit id="5fdf0dd083e563032f5e6602ce7e005cc574889d" translate="yes" xml:space="preserve">
          <source>Specifying Keys</source>
          <target state="translated">指定键</target>
        </trans-unit>
        <trans-unit id="35833528563ce69a1f68854f07be8e7aa16a509d" translate="yes" xml:space="preserve">
          <source>Specifying Query Parameters</source>
          <target state="translated">指定查询参数</target>
        </trans-unit>
        <trans-unit id="7c35f3946da6ff79b8757a6ceb8ee8d49df16369" translate="yes" xml:space="preserve">
          <source>Specifying a Root URL</source>
          <target state="translated">指定一个根网址</target>
        </trans-unit>
        <trans-unit id="3178f09d7674b2ba76416a9f78ffa51e9d2fdd63" translate="yes" xml:space="preserve">
          <source>Specifying a Route&amp;#x27;s Model</source>
          <target state="translated">指定路线的模型</target>
        </trans-unit>
        <trans-unit id="0aab4ef25ec9e8d4b45fcc096abf64fe7a154c92" translate="yes" xml:space="preserve">
          <source>Specifying a Route's Model</source>
          <target state="translated">指定路线的模式</target>
        </trans-unit>
        <trans-unit id="9d13a540e07e9718658fc51f3532a2a9665ff955" translate="yes" xml:space="preserve">
          <source>Specifying a Target</source>
          <target state="translated">指定目标</target>
        </trans-unit>
        <trans-unit id="0576f645f0df389ae6ff04ea0100cb46c490b756" translate="yes" xml:space="preserve">
          <source>Specifying the Type of Event</source>
          <target state="translated">指定事件类型</target>
        </trans-unit>
        <trans-unit id="d91b92c60fdffefa96bc27ffdf887f5e281d0a13" translate="yes" xml:space="preserve">
          <source>Specifying the URL Type</source>
          <target state="translated">指定URL类型</target>
        </trans-unit>
        <trans-unit id="c69285edae5096eb75f15a92d92d9083fbcd550c" translate="yes" xml:space="preserve">
          <source>Specifying whitelisted modifier keys</source>
          <target state="translated">指定白名单修饰键</target>
        </trans-unit>
        <trans-unit id="9d4fa9e78c183321cef3a8e36a830b3610a9a700" translate="yes" xml:space="preserve">
          <source>Splits a string into separate units separated by spaces, eliminating any empty strings in the process. This is a convenience method for split that is mostly useful when applied to the &lt;code&gt;String.prototype&lt;/code&gt;.</source>
          <target state="translated">将字符串拆分成用空格分隔的单独单元，从而消除了该过程中的任何空字符串。这是一种方便的拆分方法，在应用于 &lt;code&gt;String.prototype&lt;/code&gt; 时最有用。</target>
        </trans-unit>
        <trans-unit id="0d1e61286aa50eb30bfbfd7083574b6c91fc2ff1" translate="yes" xml:space="preserve">
          <source>Standard CSS class names to apply to the view's outer element. This property automatically inherits any class names defined by the view's superclasses as well.</source>
          <target state="translated">应用于视图外层元素的标准 CSS 类名。此属性会自动继承任何由视图的超级类定义的类名。</target>
        </trans-unit>
        <trans-unit id="8d2e5c61163ac5addfc66cdf3663694e20d997c0" translate="yes" xml:space="preserve">
          <source>Standard Method</source>
          <target state="translated">标准方法</target>
        </trans-unit>
        <trans-unit id="bbbc2d09acef9d54bec542a8902adc3b0bd87a72" translate="yes" xml:space="preserve">
          <source>Start by running &lt;code&gt;ember g controller rentals/index&lt;/code&gt; to create an index controller for our nested route.</source>
          <target state="translated">首先运行 &lt;code&gt;ember g controller rentals/index&lt;/code&gt; 来为我们的嵌套路线创建一个指数控制器。</target>
        </trans-unit>
        <trans-unit id="ed3689b34944e00b45a933d94ff2ffb05b06064e" translate="yes" xml:space="preserve">
          <source>Starting index in the array to replace. If idx &amp;gt;= length, then append to the end of the array.</source>
          <target state="translated">数组中要替换的起始索引。如果idx&amp;gt; = length，则附加到数组的末尾。</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="e2943b559f079da6407626d86e22f36963a935be" translate="yes" xml:space="preserve">
          <source>Statements like &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_unless&quot;&gt;&lt;code&gt;unless&lt;/code&gt;&lt;/a&gt; are implemented as built-in helpers. Helpers can be invoked three ways, each of which is illustrated below with conditionals.</source>
          <target state="translated">之类的语句&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt;并&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_unless&quot;&gt; &lt;code&gt;unless&lt;/code&gt; &lt;/a&gt;有内置的助手实施。可以通过三种方式调用帮助程序，每种方式在下面都通过条件进行说明。</target>
        </trans-unit>
        <trans-unit id="c1feba1e46ddf6c53b1adc00d9107a1d9ebc21a7" translate="yes" xml:space="preserve">
          <source>States are hierarchical and every state is a substate of the &lt;code&gt;RootState&lt;/code&gt;. For example, a record can be in the &lt;code&gt;root.deleted.uncommitted&lt;/code&gt; state, then transition into the &lt;code&gt;root.deleted.inFlight&lt;/code&gt; state. If a child state does not implement an event handler, the state manager will attempt to invoke the event on all parent states until the root state is reached. The state hierarchy of a record is described in terms of a path string. You can determine a record's current state by getting the state's &lt;code&gt;stateName&lt;/code&gt; property:</source>
          <target state="translated">状态是分层的，每个状态都是 &lt;code&gt;RootState&lt;/code&gt; 的子状态。例如，一条记录可以处于 &lt;code&gt;root.deleted.uncommitted&lt;/code&gt; 状态，然后过渡到 &lt;code&gt;root.deleted.inFlight&lt;/code&gt; 状态。如果子状态未实现事件处理程序，则状态管理器将尝试在所有父状态上调用事件，直到到达根状态为止。记录的状态层次结构是根据路径字符串描述的。您可以通过获取状态的 &lt;code&gt;stateName&lt;/code&gt; 属性来确定记录的当前状态：</target>
        </trans-unit>
        <trans-unit id="00eb37c2ad8ac597d25ead8c96dc4b915e4541c5" translate="yes" xml:space="preserve">
          <source>Sticky Query Param Values</source>
          <target state="translated">Sticky查询参数值</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="f1666d2bcbc1f1662ac087a581ceacb42b38e437" translate="yes" xml:space="preserve">
          <source>Store createRecord() vs. push() vs. pushPayload()</source>
          <target state="translated">存储createRecord()vs.push()vs.pushPayload()</target>
        </trans-unit>
        <trans-unit id="9c9e836e042084875f2706702835fd50f3d499b1" translate="yes" xml:space="preserve">
          <source>Storing and Retrying a Transition</source>
          <target state="translated">储存和重试过渡</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="b3d17fda1094db33050217bb63ea9c24bd2b99dc" translate="yes" xml:space="preserve">
          <source>String or Function</source>
          <target state="translated">字符串或函数</target>
        </trans-unit>
        <trans-unit id="1c9540a017269c9feb496d71189bffe50f7d5885" translate="yes" xml:space="preserve">
          <source>String...|Array</source>
          <target state="translated">String...|Array</target>
        </trans-unit>
        <trans-unit id="f0d3c25699981cc6a89aac831ec30d8b3c22399b" translate="yes" xml:space="preserve">
          <source>String.w()</source>
          <target state="translated">String.w()</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="5e2de559df2862cc71558e06f2eeae9cf0efe5c0" translate="yes" xml:space="preserve">
          <source>Strings will no longer have the convenience methods described in the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html&quot;&gt;&lt;code&gt;Ember.String&lt;/code&gt; API reference&lt;/a&gt;. Instead, you can use the similarly-named methods of the &lt;code&gt;Ember.String&lt;/code&gt; object and pass the string to use as the first parameter:</source>
          <target state="translated">字符串将不再具有&lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html&quot;&gt; &lt;code&gt;Ember.String&lt;/code&gt; API参考中&lt;/a&gt;描述的便捷方法。相反，您可以使用 &lt;code&gt;Ember.String&lt;/code&gt; 对象的类似名称的方法，并将该字符串用作第一个参数：</target>
        </trans-unit>
        <trans-unit id="3524a89f0508fdccd88639d09b323af881a667b5" translate="yes" xml:space="preserve">
          <source>String|Function</source>
          <target state="translated">String|Function</target>
        </trans-unit>
        <trans-unit id="096cde0b9a1b5f451a441cdfbe8d57859fd850e0" translate="yes" xml:space="preserve">
          <source>String|Integer</source>
          <target state="translated">String|Integer</target>
        </trans-unit>
        <trans-unit id="7dffcf19da01173ef7755fae671bcdb375a056de" translate="yes" xml:space="preserve">
          <source>String|Number</source>
          <target state="translated">String|Number</target>
        </trans-unit>
        <trans-unit id="c54337b559e9f029d16387ab04f89b68d4a2d8c3" translate="yes" xml:space="preserve">
          <source>String|Number|Object</source>
          <target state="translated">String|Number|Object</target>
        </trans-unit>
        <trans-unit id="7510182a2f01b9f70534bd7ab87456330ddc7be5" translate="yes" xml:space="preserve">
          <source>String|Object</source>
          <target state="translated">String|Object</target>
        </trans-unit>
        <trans-unit id="baca1a7147855eb5795ff280775be4b9cf07d961" translate="yes" xml:space="preserve">
          <source>String|Property</source>
          <target state="translated">String|Property</target>
        </trans-unit>
        <trans-unit id="7087dd5b60a0e5d36d078de3709bb645d286db69" translate="yes" xml:space="preserve">
          <source>Stubbing Services</source>
          <target state="translated">存根服务</target>
        </trans-unit>
        <trans-unit id="27aa4c7ccfa314309a981fe2957b63393d5fce5e" translate="yes" xml:space="preserve">
          <source>Stubbing Services in Acceptance Tests</source>
          <target state="translated">验收测试中的存根服务</target>
        </trans-unit>
        <trans-unit id="87fc913c19cccd1420f6549019e6ab07d2652eb8" translate="yes" xml:space="preserve">
          <source>Submitting a post without a title displays a red validation state on the field and gives the user text indicating that the title is required.</source>
          <target state="translated">在没有标题的情况下提交帖子,会在字段上显示红色的验证状态,并给用户提示需要标题的文字。</target>
        </trans-unit>
        <trans-unit id="12d390f8025584ad2ceb29d8156199827eb766f2" translate="yes" xml:space="preserve">
          <source>Submodules</source>
          <target state="translated">Submodules</target>
        </trans-unit>
        <trans-unit id="6ef9815ada2a0398b68221d1261a977ff08f7246" translate="yes" xml:space="preserve">
          <source>Subscribe to a listener by using &lt;code&gt;Ember.subscribe&lt;/code&gt;:</source>
          <target state="translated">通过使用 &lt;code&gt;Ember.subscribe&lt;/code&gt; 订阅侦听器：</target>
        </trans-unit>
        <trans-unit id="eb7e7cd9296878731ca54a308b73da381671370f" translate="yes" xml:space="preserve">
          <source>Subscribes a function to a named event and then cancels the subscription after the first time the event is triggered. It is good to use &lt;code&gt;one&lt;/code&gt; when you only care about the first time an event has taken place.</source>
          <target state="translated">将函数订阅到命名事件，然后在第一次触发事件后取消订阅。当您只关心事件的第一次发生时，最好使用 &lt;code&gt;one&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a236ce5c458753d003516cfdb6d3fbc2147baa0" translate="yes" xml:space="preserve">
          <source>Subscribes to a named event with given function.</source>
          <target state="translated">用给定的函数订阅一个命名的事件。</target>
        </trans-unit>
        <trans-unit id="21ff0eedd4b3be556de21a3ebae1bcf1865e815e" translate="yes" xml:space="preserve">
          <source>Success and failure</source>
          <target state="translated">成功与失败</target>
        </trans-unit>
        <trans-unit id="d566bb22908b1ec9a9610a20f300bf499e0d3e6f" translate="yes" xml:space="preserve">
          <source>Supplying a model</source>
          <target state="translated">提供一个模型</target>
        </trans-unit>
        <trans-unit id="307ad7bba7045cbdfbe8ab3762416f0cfe2eeea8" translate="yes" xml:space="preserve">
          <source>Supplying a tagName</source>
          <target state="translated">提供一个标签名</target>
        </trans-unit>
        <trans-unit id="2a1281cd7b34a3b437d33cc93541bd5fe0eac5b8" translate="yes" xml:space="preserve">
          <source>Supplying an explicit dynamic segment value</source>
          <target state="translated">提供一个明确的动态段值</target>
        </trans-unit>
        <trans-unit id="ac7e6f74b23299de001ce35020dda39ed87fccdf" translate="yes" xml:space="preserve">
          <source>Supplying multiple models</source>
          <target state="translated">提供多种型号</target>
        </trans-unit>
        <trans-unit id="3c4685eb55ed20aeb850f996709d097128114b51" translate="yes" xml:space="preserve">
          <source>Support for ES2015/ES6 JavaScript via the &lt;a href=&quot;https://babeljs.io/learn-es2015/&quot;&gt;Babel&lt;/a&gt; project. This includes support for &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;JavaScript modules&lt;/a&gt;, which are used throughout this guide.</source>
          <target state="translated">通过&lt;a href=&quot;https://babeljs.io/learn-es2015/&quot;&gt;Babel&lt;/a&gt;项目支持ES2015 / ES6 JavaScript 。这包括对&lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;JavaScript模块的&lt;/a&gt;支持，本指南通篇使用。</target>
        </trans-unit>
        <trans-unit id="e2c0191bfc5d5b1bd1375a04ab5288df11a1e581" translate="yes" xml:space="preserve">
          <source>Supported Scenarios</source>
          <target state="translated">支持的场景</target>
        </trans-unit>
        <trans-unit id="f158e8ae8a0fd5a1bbca7308d27f425549f52faa" translate="yes" xml:space="preserve">
          <source>Supporting both block and non-block component usage in one template</source>
          <target state="translated">支持在一个模板中同时使用块和非块组件。</target>
        </trans-unit>
        <trans-unit id="21d313eca972677af60300d5c32cdc508135a054" translate="yes" xml:space="preserve">
          <source>Supporting different editing styles will require different body components to provide special validation and highlighting. To load a different body component based on editing style, you can yield the component using the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt;&lt;code&gt;component helper&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_hash&quot;&gt;&lt;code&gt;hash helper&lt;/code&gt;&lt;/a&gt;. Here, the appropriate component is assigned to a hash using nested helpers and yielded to the template. Notice &lt;code&gt;editStyle&lt;/code&gt; being used as an argument to the component helper.</source>
          <target state="translated">支持不同的编辑样式将需要不同的正文组件以提供特殊的验证和突出显示。要基于编辑样式加载不同的主体组件，可以使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt; &lt;code&gt;component helper&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_hash&quot;&gt; &lt;code&gt;hash helper&lt;/code&gt; &lt;/a&gt;产生该组件。在这里，使用嵌套的帮助器将适当的组件分配给哈希，并提供给模板。注意 &lt;code&gt;editStyle&lt;/code&gt; 被用作组件帮助器的参数。</target>
        </trans-unit>
        <trans-unit id="870b6a43f9969937a6b78668e5f67b305829ac03" translate="yes" xml:space="preserve">
          <source>Suppose we have an object that has a property and a method observing that property.</source>
          <target state="translated">假设我们有一个对象,它有一个属性和一个观察该属性的方法。</target>
        </trans-unit>
        <trans-unit id="9675587d4669654928b069872d4f2938fc8dc804" translate="yes" xml:space="preserve">
          <source>Suppose you want to integrate your favorite date picker library into an Ember project. Typically, 3rd party JS/jQuery libraries require a DOM element to bind to. So, where is the best place to initialize and attach the library?</source>
          <target state="translated">假设你想把你最喜欢的日期选择器库集成到Ember项目中。通常,第三方JS/jQuery库需要一个DOM元素来绑定。那么,哪里是初始化和附加库的最佳位置?</target>
        </trans-unit>
        <trans-unit id="20aeee9b0344b503f9d7a448f7aba7ca9a8c5cca" translate="yes" xml:space="preserve">
          <source>Synchronous Example</source>
          <target state="translated">同步实例</target>
        </trans-unit>
        <trans-unit id="495d2949869c7e350f566c1678a60431b1cc2fcf" translate="yes" xml:space="preserve">
          <source>Synchronous Helpers</source>
          <target state="translated">同步助手</target>
        </trans-unit>
        <trans-unit id="342d5495308e369e444baf3f33f246d0bcc29b75" translate="yes" xml:space="preserve">
          <source>Synchronous example:</source>
          <target state="translated">同步的例子。</target>
        </trans-unit>
        <trans-unit id="d54e57d31e1997c6a23c5f4f4a2538763d613e21" translate="yes" xml:space="preserve">
          <source>Synchronous helpers are performed immediately when triggered.</source>
          <target state="translated">触发时立即执行同步帮助。</target>
        </trans-unit>
        <trans-unit id="7863003b76de30fb0d39d091532fa48c8ca6a75e" translate="yes" xml:space="preserve">
          <source>Tackling Deprecations</source>
          <target state="translated">处理弃用问题</target>
        </trans-unit>
        <trans-unit id="1d6f3b9629d6275a16e909978a30680b410d16c9" translate="yes" xml:space="preserve">
          <source>Tag name for the view's outer element. The tag name is only used when an element is first created. If you change the &lt;code&gt;tagName&lt;/code&gt; for an element, you must destroy and recreate the view element.</source>
          <target state="translated">视图外部元素的标签名称。标签名称仅在首次创建元素时使用。如果更改元素的 &lt;code&gt;tagName&lt;/code&gt; ，则必须销毁并重新创建view元素。</target>
        </trans-unit>
        <trans-unit id="eb8e3e9f7283008461ee747f3e130db27bb0a277" translate="yes" xml:space="preserve">
          <source>Take for example the following routes:</source>
          <target state="translated">以下列路线为例:</target>
        </trans-unit>
        <trans-unit id="2c60cfa4ea62384dd026b50e8f6e0eed19938e00" translate="yes" xml:space="preserve">
          <source>Takes an ajax response, and returns the json payload or an error.</source>
          <target state="translated">获取ajax响应,并返回json有效载荷或错误。</target>
        </trans-unit>
        <trans-unit id="ab8aad230fdba67c86441e29f313daf20e0add73" translate="yes" xml:space="preserve">
          <source>TargetActionSupport</source>
          <target state="translated">TargetActionSupport</target>
        </trans-unit>
        <trans-unit id="d1e8254c86f37cbe15667c32cc8a8a8fff4cd1ef" translate="yes" xml:space="preserve">
          <source>Template compilation.</source>
          <target state="translated">模板汇编。</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="f26dba0d688990ff76ff8c4eada0b9b5921db5b4" translate="yes" xml:space="preserve">
          <source>Templates are backed with a context. A context is an object from which Handlebars expressions read their properties. In Ember this is often a component. For templates rendered by a route (like &lt;code&gt;application.hbs&lt;/code&gt;), the context is a controller.</source>
          <target state="translated">模板带有上下文支持。上下文是一个对象，Handlebars表达式可从该对象读取其属性。在Ember中，这通常是一个组成部分。对于由路由渲染的模板（例如 &lt;code&gt;application.hbs&lt;/code&gt; ），上下文是控制器。</target>
        </trans-unit>
        <trans-unit id="bca019d1b04ef7b9ee38e243a74a67fd82e673fa" translate="yes" xml:space="preserve">
          <source>Templates can also display properties provided to them from their context, which is either a component or a route's controller. For example:</source>
          <target state="translated">模板还可以显示从其上下文中提供给它们的属性,上下文是一个组件或路由的控制器。例如</target>
        </trans-unit>
        <trans-unit id="517698063a175f12911d21c0535adc2e76938ecf" translate="yes" xml:space="preserve">
          <source>Templates manage the flow of an application's UI, and display state (through the DOM) to a user. For example, given a component with the property &quot;name&quot;, that component's template can use the name in several ways:</source>
          <target state="translated">模板管理应用程序的UI流程,并向用户显示状态(通过DOM)。例如,给定一个具有 &quot;name &quot;属性的组件,该组件的模板可以以多种方式使用该名称。</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="51813b0814adc6202a7752710fd028f16f5bf477" translate="yes" xml:space="preserve">
          <source>Test Helpers</source>
          <target state="translated">测试助手</target>
        </trans-unit>
        <trans-unit id="aed406fa903d6e94bc7feee88a130462ff9783a9" translate="yes" xml:space="preserve">
          <source>Test visiting our About and Contact pages</source>
          <target state="translated">测试访问我们的关于和联系页面</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="c59410bf3ca2f20fd8b0393728deccf2dc47f93a" translate="yes" xml:space="preserve">
          <source>Testing Actions</source>
          <target state="translated">测试行动</target>
        </trans-unit>
        <trans-unit id="06b38cb08494d08dd0969ccda46c766ca333f501" translate="yes" xml:space="preserve">
          <source>Testing Components</source>
          <target state="translated">测试组件</target>
        </trans-unit>
        <trans-unit id="111ae9c10175e16d69526c94a465e0225d9f1710" translate="yes" xml:space="preserve">
          <source>Testing Computed Properties</source>
          <target state="translated">测试计算属性</target>
        </trans-unit>
        <trans-unit id="91816ac28cf876440112f405559c1a49b916b2f0" translate="yes" xml:space="preserve">
          <source>Testing Controller Actions</source>
          <target state="translated">测试控制器的动作</target>
        </trans-unit>
        <trans-unit id="bbdb40de641b7bd903d12a3a7d8dcdf9f0d4da40" translate="yes" xml:space="preserve">
          <source>Testing Controller Needs</source>
          <target state="translated">测试控制器的需求</target>
        </trans-unit>
        <trans-unit id="a3634a65dd330502bee5446e899329476bf7ded2" translate="yes" xml:space="preserve">
          <source>Testing Controllers</source>
          <target state="translated">测试控制器</target>
        </trans-unit>
        <trans-unit id="fcc10e5ab4dd75f9eb46dbd24ec0395685a9aa13" translate="yes" xml:space="preserve">
          <source>Testing Frameworks</source>
          <target state="translated">测试框架</target>
        </trans-unit>
        <trans-unit id="e309e778695eab20a3a8bc01dba2b39e99684bfe" translate="yes" xml:space="preserve">
          <source>Testing Helpers</source>
          <target state="translated">测试助手</target>
        </trans-unit>
        <trans-unit id="f487e84bdaccef5eb28911d350ffc027190e112c" translate="yes" xml:space="preserve">
          <source>Testing Models</source>
          <target state="translated">测试模型</target>
        </trans-unit>
        <trans-unit id="82df70ae5a532aff7c33f9b6a39a13c4ceb157d6" translate="yes" xml:space="preserve">
          <source>Testing Object Methods</source>
          <target state="translated">测试对象方法</target>
        </trans-unit>
        <trans-unit id="10598855856ed90e10e02c787702f60e5e73921b" translate="yes" xml:space="preserve">
          <source>Testing Observers</source>
          <target state="translated">测试观察员</target>
        </trans-unit>
        <trans-unit id="c2719b0d81b37187b81d8b3c83b30f393e2ac71c" translate="yes" xml:space="preserve">
          <source>Testing Our Application As We Go</source>
          <target state="translated">边走边测试我们的应用</target>
        </trans-unit>
        <trans-unit id="a6c9220ff39e33f54e9415c82938ea24da9ff5cf" translate="yes" xml:space="preserve">
          <source>Testing Relationships</source>
          <target state="translated">测试关系</target>
        </trans-unit>
        <trans-unit id="3beda4357979b576777318de0cd80c86b2eba9a4" translate="yes" xml:space="preserve">
          <source>Testing Routes</source>
          <target state="translated">测试路线</target>
        </trans-unit>
        <trans-unit id="48d04cd7bff00c397a2449e46bae4e190877dce0" translate="yes" xml:space="preserve">
          <source>Testing User Interaction</source>
          <target state="translated">测试用户交互</target>
        </trans-unit>
        <trans-unit id="627445291b103d97223f554921c6a4122db19397" translate="yes" xml:space="preserve">
          <source>Testing is a core part of the Ember framework and its development cycle.</source>
          <target state="translated">测试是Ember框架及其开发周期的核心部分。</target>
        </trans-unit>
        <trans-unit id="9829d58d7519decb98a016ef2876759597109cbf" translate="yes" xml:space="preserve">
          <source>Testing routes can be done both via acceptance or unit tests. Acceptance tests will likely provide better coverage for routes because routes are typically used to perform transitions and load data, both of which are tested more easily in full context rather than isolation.</source>
          <target state="translated">测试路由既可以通过验收测试,也可以通过单元测试。验收测试可能会为路由提供更好的覆盖率,因为路由通常用于执行转换和加载数据,这两者都更容易在全上下文中而不是孤立地进行测试。</target>
        </trans-unit>
        <trans-unit id="c06feb4db18fe22ca99f672e2f6701eab0410aae" translate="yes" xml:space="preserve">
          <source>Tests can also be executed when you are running a local development server (started by running &lt;code&gt;ember server&lt;/code&gt;), at the &lt;code&gt;/tests&lt;/code&gt; URI which renders the &lt;code&gt;tests/index.html&lt;/code&gt; template. A word of caution using this approach: Tests run using &lt;code&gt;ember server&lt;/code&gt; have the environment configuration &lt;code&gt;development&lt;/code&gt;, whereas tests executed under &lt;code&gt;ember test --server&lt;/code&gt; are run with the configuration &lt;code&gt;test&lt;/code&gt;. This could cause differences in execution, such as which libraries are loaded and available. Therefore its recommended that you use &lt;code&gt;ember test --server&lt;/code&gt; for test execution.</source>
          <target state="translated">当您运行本地开发服务器（以运行 &lt;code&gt;ember server&lt;/code&gt; 开头）时，也可以在呈现 &lt;code&gt;tests/index.html&lt;/code&gt; 模板的 &lt;code&gt;/tests&lt;/code&gt; URI上执行测试。使用这种方法时要小心：使用 &lt;code&gt;ember server&lt;/code&gt; 运行的测试具有环境配置 &lt;code&gt;development&lt;/code&gt; ，而在 &lt;code&gt;ember test --server&lt;/code&gt; 下执行的测试则与配置 &lt;code&gt;test&lt;/code&gt; 一起运行。这可能会导致执行方面的差异，例如哪些库已加载和可用。因此，建议您使用 &lt;code&gt;ember test --server&lt;/code&gt; 进行测试执行。</target>
        </trans-unit>
        <trans-unit id="397b6080e414f58dca5e208b2d6e35210d1b3660" translate="yes" xml:space="preserve">
          <source>Text Areas</source>
          <target state="translated">文本区域</target>
        </trans-unit>
        <trans-unit id="dc7b11db79436bd2c512f4d9967fc73904ef80da" translate="yes" xml:space="preserve">
          <source>Text field</source>
          <target state="translated">文本领域</target>
        </trans-unit>
        <trans-unit id="f9168144e4f6dc56ba8e02f8cb5754a06a331b7a" translate="yes" xml:space="preserve">
          <source>Text fields</source>
          <target state="translated">文本领域</target>
        </trans-unit>
        <trans-unit id="6803da9ee11ff492530f9c8867cacf0bf23256dc" translate="yes" xml:space="preserve">
          <source>TextArea</source>
          <target state="translated">TextArea</target>
        </trans-unit>
        <trans-unit id="ed595662ad10d27de0f2faece995e2ca2b8e7012" translate="yes" xml:space="preserve">
          <source>TextField</source>
          <target state="translated">TextField</target>
        </trans-unit>
        <trans-unit id="18d077a1a2979a8d6bce31e5dbe43320be8e25bf" translate="yes" xml:space="preserve">
          <source>TextField.max</source>
          <target state="translated">TextField.max</target>
        </trans-unit>
        <trans-unit id="5f0b052f28a0bd79ca6d930fe4c63eb5ecf68887" translate="yes" xml:space="preserve">
          <source>TextField.min</source>
          <target state="translated">TextField.min</target>
        </trans-unit>
        <trans-unit id="18e5d205fad575a252d1a26dc2fa9ef4f4a1b761" translate="yes" xml:space="preserve">
          <source>TextField.size</source>
          <target state="translated">TextField.size</target>
        </trans-unit>
        <trans-unit id="5c2de3d7d34ecad27d764569b0d805502a88a8e0" translate="yes" xml:space="preserve">
          <source>TextField.type</source>
          <target state="translated">TextField.type</target>
        </trans-unit>
        <trans-unit id="27df24da0e29d9bd616074b4f3101aac223ebbe7" translate="yes" xml:space="preserve">
          <source>TextSupport</source>
          <target state="translated">TextSupport</target>
        </trans-unit>
        <trans-unit id="b3412c92e9c7c36dbce60a4d0caa17409de5decd" translate="yes" xml:space="preserve">
          <source>Thanks to its use of the &lt;em&gt;adapter pattern&lt;/em&gt;, Ember Data can be configured to work with many different kinds of backends. There is &lt;a href=&quot;http://emberobserver.com/categories/ember-data-adapters&quot;&gt;an entire ecosystem of adapters&lt;/a&gt; that allow your Ember app to talk to different types of servers without you writing any networking code.</source>
          <target state="translated">由于使用了&lt;em&gt;适配器模式&lt;/em&gt;，因此可以将Ember Data配置为与许多不同种类的后端一起使用。有&lt;a href=&quot;http://emberobserver.com/categories/ember-data-adapters&quot;&gt;适配器的整个生态系统&lt;/a&gt;，让您的灰烬应用跟不同类型的服务器没有你编写任何网络代码。</target>
        </trans-unit>
        <trans-unit id="318520d5f37197c6df1e09018c18e851802ae7ae" translate="yes" xml:space="preserve">
          <source>That being said, sometimes it is important to unit test your routes. For example, let's say we'd like to have an alert that can be triggered from anywhere within our application. The alert function &lt;code&gt;displayAlert&lt;/code&gt; should be put into the &lt;code&gt;ApplicationRoute&lt;/code&gt; because all actions and events bubble up to it from sub-routes and controllers.</source>
          <target state="translated">话虽如此，有时对单元进行单元测试很重要。例如，假设我们希望有一个警报，该警报可以从应用程序内的任何位置触发。警报功能 &lt;code&gt;displayAlert&lt;/code&gt; 应该放在 &lt;code&gt;ApplicationRoute&lt;/code&gt; 中,因为所有操作和事件都会从子路由和控制器冒泡到它。</target>
        </trans-unit>
        <trans-unit id="a36f83caf5ff2b93a1e4e5fcdc3584558ac63704" translate="yes" xml:space="preserve">
          <source>That default configuration matches the wider set of browsers that Ember.js itself supports. However, if your app does not need to support IE anymore, you can change it to:</source>
          <target state="translated">该默认配置与Ember.js本身支持的更广泛的浏览器集相匹配。不过,如果你的应用不需要再支持IE了,你可以将其改为。</target>
        </trans-unit>
        <trans-unit id="1c82a49b447f0a46a1e511a5df799dfb0834560f" translate="yes" xml:space="preserve">
          <source>That file should export a function wrapped with &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html&quot;&gt;&lt;code&gt;Ember.Helper.helper()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">该文件应导出一个用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html&quot;&gt; &lt;code&gt;Ember.Helper.helper()&lt;/code&gt; &lt;/a&gt;包装的函数：</target>
        </trans-unit>
        <trans-unit id="3b922bfea8e08f9290c3bf2fa6bff5f3b54ebd4c" translate="yes" xml:space="preserve">
          <source>That is Ember telling you that it has created:</source>
          <target state="translated">那是微光告诉你,它已经创造了。</target>
        </trans-unit>
        <trans-unit id="e0de9e3a4d4633aeeb18a289a56bd4805b9cfcbf" translate="yes" xml:space="preserve">
          <source>That is why Ember CLI exposes a way of configuring what browsers your app targets. It can figure out automatically what features are supported by the browsers you are targeting, and apply the minimum set of transformations possible to your code.</source>
          <target state="translated">这就是为什么Ember CLI提供了一种配置你的应用所针对的浏览器的方法。它可以自动找出你所针对的浏览器所支持的功能,并对你的代码应用尽可能少的转换集。</target>
        </trans-unit>
        <trans-unit id="9c3ec01be68e48073d9e918cf0f3b59651463160" translate="yes" xml:space="preserve">
          <source>That makes it easy to remember how to add an action to a component. It's like passing an attribute, but you use the &lt;code&gt;action&lt;/code&gt; helper to pass a function instead.</source>
          <target state="translated">这使您很容易记住如何向组件添加操作。就像传递属性一样，但是您可以使用 &lt;code&gt;action&lt;/code&gt; 助手来传递函数。</target>
        </trans-unit>
        <trans-unit id="78ba75708cf1770d1ec144b19670b70c95278a4c" translate="yes" xml:space="preserve">
          <source>That said, sometimes you may want to make behavior of helpers configurable by the developers that call them from their templates. For example, let's abandon our Americentric ways and update our &lt;code&gt;format-currency&lt;/code&gt; helper to take an optional configuration for which currency symbol to display.</source>
          <target state="translated">就是说，有时您可能希望使从模板调用助手的开发人员可配置其行为。例如，让我们放弃我们的&amp;ldquo;以美国为中心&amp;rdquo;的方式，并更新 &lt;code&gt;format-currency&lt;/code&gt; 帮助器以采用可选配置来显示货币符号。</target>
        </trans-unit>
        <trans-unit id="d7606bb113640faa278cf7a28f2eb3e24d5170f8" translate="yes" xml:space="preserve">
          <source>That state is what the &lt;code&gt;ApplicationInstance&lt;/code&gt; manages: it is responsible for creating the container that contains all application state, and disposing of it once the particular test run or FastBoot request has finished.</source>
          <target state="translated">该状态是 &lt;code&gt;ApplicationInstance&lt;/code&gt; 管理的状态：它负责创建包含所有应用程序状态的容器，并在特定测试运行或FastBoot请求完成后将其处理。</target>
        </trans-unit>
        <trans-unit id="e53c9021b9ec9d905f7edbfc8bee2fd601077a71" translate="yes" xml:space="preserve">
          <source>That way the generated URL will be deterministic and that simplifies caching mechanisms in the backend.</source>
          <target state="translated">这样生成的URL将是确定性的,这就简化了后台的缓存机制。</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="cca06a831613fdc449a54b01a0421b8fde878db7" translate="yes" xml:space="preserve">
          <source>The &quot;this&quot; binding for the callback</source>
          <target state="translated">回调的 &quot;this &quot;绑定</target>
        </trans-unit>
        <trans-unit id="ccc5b4bf89b158d0eb41c14adb3ba628e5e78e8e" translate="yes" xml:space="preserve">
          <source>The 'Whoops' error will be thrown on the next turn of the event loop and you can watch for it in your console. You can also handle it using a rejection handler given to &lt;code&gt;.then&lt;/code&gt; or &lt;code&gt;.catch&lt;/code&gt; on the returned promise.</source>
          <target state="translated">下一轮事件循环将引发&amp;ldquo; Whoops&amp;rdquo;错误，您可以在控制台中进行观察。您也可以使用给予拒绝处理程序处理它 &lt;code&gt;.then&lt;/code&gt; 或 &lt;code&gt;.catch&lt;/code&gt; 对返回的承诺。</target>
        </trans-unit>
        <trans-unit id="12f898edea55f5f355fe5f02c909ee411cb027ea" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Router.html#method_map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; method of your Ember application's router can be invoked to define URL mappings. When calling &lt;code&gt;map()&lt;/code&gt;, you should pass a function that will be invoked with the value &lt;code&gt;this&lt;/code&gt; set to an object which you can use to create routes.</source>
          <target state="translated">可以调用Ember应用程序路由器的&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Router.html#method_map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt;方法来定义URL映射。当调用 &lt;code&gt;map()&lt;/code&gt; ，你应该通过将与该值调用的函数 &lt;code&gt;this&lt;/code&gt; 设置为一个对象，你可以用它来创建路线。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
