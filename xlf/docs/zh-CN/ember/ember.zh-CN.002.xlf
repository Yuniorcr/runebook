<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="ember">
    <body>
      <group id="ember">
        <trans-unit id="46cc27dcedc983269fe3dae4fb3c917ec22990eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Native&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Native&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="52751513d2493dd0d64f888941864b8be8e5ce5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nested invocation&lt;/strong&gt; is another way to use a helper. Like inline helpers, nested helpers generate and return a single value. For example, this template only renders &lt;code&gt;&quot;zoooom&quot;&lt;/code&gt; if both &lt;code&gt;isFast&lt;/code&gt; and &lt;code&gt;isFueled&lt;/code&gt; are true:</source>
          <target state="translated">&lt;strong&gt;嵌套调用&lt;/strong&gt;是使用助手的另一种方法。像内联帮助程序一样，嵌套帮助程序会生成并返回一个值。例如，如果 &lt;code&gt;isFast&lt;/code&gt; 和 &lt;code&gt;isFueled&lt;/code&gt; 均为true ，则此模板仅呈现 &lt;code&gt;&quot;zoooom&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="275460f523b118049b10ae5f0f999ee575431a37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Never&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Never&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5938f985ae4a6eb7f469289b3da82078aa94ed7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-native classes&lt;/strong&gt;. Octane apps say goodbye to &lt;code&gt;extend()&lt;/code&gt;, &lt;code&gt;create()&lt;/code&gt;, and mixins, and use Native Classes instead.</source>
          <target state="translated">&lt;strong&gt;非本地类&lt;/strong&gt;。辛烷值应用程序告别了 &lt;code&gt;extend()&lt;/code&gt; ， &lt;code&gt;create()&lt;/code&gt; 和mixins，而改用本机类。</target>
        </trans-unit>
        <trans-unit id="65dcf051b0f8d4d6b70a92dd10d98dbbb05e7cdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c6706d4e671914b516408c09188cf03534b10db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Promises&lt;/strong&gt; - the native way to deal with asynchrony in your JavaScript code. See the relevant &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Mozilla Developer Network&lt;/a&gt; section.</source>
          <target state="translated">&lt;strong&gt;Promises-&lt;/strong&gt;处理JavaScript代码中异步性的本机方法。请参阅相关的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Mozilla开发人员网络&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="4f0e6c795f05f3b5db2a12a168e52bcd194b048a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Promises&lt;/strong&gt; - the native way to deal with asynchrony in your JavaScript code. See the relevant &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Mozilla Developer Network&lt;/a&gt; section. In addition, modern &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await&quot;&gt;&lt;code&gt;async/await&lt;/code&gt; function syntax&lt;/a&gt; is good to know.</source>
          <target state="translated">&lt;strong&gt;Promises-&lt;/strong&gt;处理JavaScript代码中异步性的本机方法。请参阅相关的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Mozilla开发人员网络&lt;/a&gt;部分。此外，现代&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await&quot;&gt; &lt;code&gt;async/await&lt;/code&gt; 功能语法&lt;/a&gt;也很不错。</target>
        </trans-unit>
        <trans-unit id="e950934efea9cd4f355fb7ad4df86e0c64315506" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Required.&lt;/strong&gt; You must implement this method to apply this mixin.</source>
          <target state="translated">&lt;strong&gt;需要。&lt;/strong&gt;您必须实现此方法才能应用此混合。</target>
        </trans-unit>
        <trans-unit id="24993c189d4cd762b7eb2181ccc6ac96dd1f9b1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The getter does not need any special annotations.&lt;/strong&gt; As long as you've marked the properties that can change with &lt;code&gt;@tracked&lt;/code&gt;, you can use JavaScript to compute new values from those properties.</source>
          <target state="translated">&lt;strong&gt;吸气剂不需要任何特殊的注释。&lt;/strong&gt;只要标记了可以通过 &lt;code&gt;@tracked&lt;/code&gt; 更改的属性，就可以使用JavaScript从这些属性计算新值。</target>
        </trans-unit>
        <trans-unit id="dcea3a8103a14becd4a075465bc5c402fa88c01e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The run loop&lt;/strong&gt;. App developers should never have to write code that interacts with the Ember run loop, even in tests.</source>
          <target state="translated">&lt;strong&gt;运行循环&lt;/strong&gt;。即使在测试中，应用程序开发人员也不必编写与Ember运行循环交互的代码。</target>
        </trans-unit>
        <trans-unit id="0c04ca3a7f9dd255e30a26a61897792a828611c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is how we normally write helpers in Ember&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;这就是我们通常在Ember中编写帮助程序的方式&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="881babe651a21a62e7364b7b9cfa1794d6395225" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When customizing a serializer it is important to grok what the customizations are. Please read the docs for the methods this mixin provides, in case you need to modify it to fit your specific needs.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;自定义序列化程序时，务必了解自定义项是什么。如果需要修改它以适合您的特定需求，请阅读文档以了解此mixin提供的方法。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="470600606588a32d9557241101058912ab50961d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app&lt;/strong&gt;: This is where folders and files for models, components, routes, templates and styles are stored. The majority of your coding on an Ember project happens in this folder.</source>
          <target state="translated">&lt;strong&gt;app&lt;/strong&gt;：这是用于存储模型，零部件，路线，模板和样式的文件夹和文件的位置。您在Ember项目上的大部分编码都在此文件夹中进行。</target>
        </trans-unit>
        <trans-unit id="8481c210d2bfd9e765791e4f4a3dd04bd9d6ec83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;config&lt;/strong&gt;: The config directory contains the &lt;code&gt;environment.js&lt;/code&gt; where you can configure settings for your app.</source>
          <target state="translated">&lt;strong&gt;config&lt;/strong&gt;：config目录包含 &lt;code&gt;environment.js&lt;/code&gt; ，您可以在其中配置应用程序的设置。</target>
        </trans-unit>
        <trans-unit id="3bbd1fe48c75d123d9b241aa7cf37249e8f60f3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ember-cli-build.js&lt;/strong&gt;: This file describes how Ember CLI should build our app.</source>
          <target state="translated">&lt;strong&gt;ember-cli-build.js&lt;/strong&gt;：此文件描述了Ember CLI如何构建我们的应用程序。</target>
        </trans-unit>
        <trans-unit id="68cdacf9491924b75172e8dab39d04533551eca8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery&lt;/strong&gt;. For DOM interaction, developers should use templates or native DOM APIs.</source>
          <target state="translated">&lt;strong&gt;jQuery的&lt;/strong&gt;。对于DOM交互，开发人员应使用模板或本机DOM API。</target>
        </trans-unit>
        <trans-unit id="14c6cdacb081a9f0a62d6e02a0564a76df9ce816" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;key&lt;/strong&gt;String the name of this relationship on the Model</source>
          <target state="translated">&lt;strong&gt;key&lt;/strong&gt; String在Model上此关系的名称</target>
        </trans-unit>
        <trans-unit id="1fd7a0b34963fb6134b8ae17d1ecaed1cb1f794e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;kind&lt;/strong&gt;String &quot;hasMany&quot; or &quot;belongsTo&quot;</source>
          <target state="translated">&lt;strong&gt;kind&lt;/strong&gt;字符串&amp;ldquo; hasMany&amp;rdquo;或&amp;ldquo; belongsTo&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="df54a76dfc05f7feb93b9870ae131f74a3c72a4d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;node_modules / package.json&lt;/strong&gt;: This directory and file are from npm. npm is the package manager for Node.js. Ember is built with Node and uses a variety of Node.js modules for operation. The &lt;code&gt;package.json&lt;/code&gt; file maintains the list of current npm dependencies for the app. Any Ember CLI addons you install will also show up here. Packages listed in &lt;code&gt;package.json&lt;/code&gt; are installed in the node_modules directory.</source>
          <target state="translated">&lt;strong&gt;node_modules / package.json&lt;/strong&gt;：此目录和文件来自npm。npm是Node.js的软件包管理器。Ember是使用Node构建的，并使用各种Node.js模块进行操作。该 &lt;code&gt;package.json&lt;/code&gt; 文件维护当前NPM依赖于应用程序的列表。您安装的所有Ember CLI插件也将显示在此处。 &lt;code&gt;package.json&lt;/code&gt; 中列出的软件包安装在node_modules目录中。</target>
        </trans-unit>
        <trans-unit id="efbedcbe9d2e3a12d8d8b0d88ed61054a887ebe9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;options&lt;/strong&gt;Object the original options hash passed when the relationship was declared</source>
          <target state="translated">&lt;strong&gt;options&lt;/strong&gt;声明声明关系时传递的原始选项哈希</target>
        </trans-unit>
        <trans-unit id="6840a435ff71567b4b4a941b6847beb0ddb59330" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;parentType&lt;/strong&gt;DS.Model the type of the Model that owns this relationship</source>
          <target state="translated">&lt;strong&gt;parentType&lt;/strong&gt; DS.Model拥有此关系的Model的类型</target>
        </trans-unit>
        <trans-unit id="7b360785b08f4c59c21ddaf3671eb93c0740f054" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;public&lt;/strong&gt;: This directory contains assets such as images and fonts.</source>
          <target state="translated">&lt;strong&gt;public&lt;/strong&gt;：此目录包含资产，例如图像和字体。</target>
        </trans-unit>
        <trans-unit id="2661328b5b44a9913111324f3cea23d911fa3e0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tests / testem.js&lt;/strong&gt;: Automated tests for our app go in the &lt;code&gt;tests&lt;/code&gt; folder, and Ember CLI's test runner &lt;strong&gt;testem&lt;/strong&gt; is configured in &lt;code&gt;testem.js&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;tests / testem.js&lt;/strong&gt;：针对我们应用程序的自动化测试位于 &lt;code&gt;tests&lt;/code&gt; 文件夹中，而Ember CLI的测试运行程序&lt;strong&gt;testem&lt;/strong&gt;在 &lt;code&gt;testem.js&lt;/code&gt; 中进行配置。</target>
        </trans-unit>
        <trans-unit id="fa2ab6088b7133c1145df75bf15fd8ea46566d39" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;type&lt;/strong&gt;String the type name of the related Model</source>
          <target state="translated">&lt;strong&gt;type&lt;/strong&gt; String相关模型的类型名称</target>
        </trans-unit>
        <trans-unit id="4fb59e3a73663d5b9fc22e94c07aa74fe28020a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;vendor&lt;/strong&gt;: This directory is where front-end dependencies (such as JavaScript or CSS) that are not managed by Bower go.</source>
          <target state="translated">&lt;strong&gt;vendor&lt;/strong&gt;：该目录是不由Bower管理的前端依赖项（例如JavaScript或CSS）所在的位置。</target>
        </trans-unit>
        <trans-unit id="9e550e6978bf8ce363e735f61a5329a94d3e4b94" translate="yes" xml:space="preserve">
          <source>@action, {{on}} and {{fn}}</source>
          <target state="translated">@action，{{on}}和{{fn}}</target>
        </trans-unit>
        <trans-unit id="5a104720fd47e5de4a82907b888ca895f1310a23" translate="yes" xml:space="preserve">
          <source>@each</source>
          <target state="translated">@each</target>
        </trans-unit>
        <trans-unit id="b63a5032a4f6d06544f05b54829328428a4671e6" translate="yes" xml:space="preserve">
          <source>@eachpublic</source>
          <target state="translated">@eachpublic</target>
        </trans-unit>
        <trans-unit id="a84832d8a317b79048cb747460807cd5f0c21e79" translate="yes" xml:space="preserve">
          <source>@ember-data/adapter</source>
          <target state="translated">@ember-data/adapter</target>
        </trans-unit>
        <trans-unit id="d27df9e14ef39d7153a975a41c7989ec9ec8a82d" translate="yes" xml:space="preserve">
          <source>@ember-data/model</source>
          <target state="translated">@ember-data/model</target>
        </trans-unit>
        <trans-unit id="651d8952598e49c77f68ef8643a3baaaa29e5602" translate="yes" xml:space="preserve">
          <source>@ember-data/serializer</source>
          <target state="translated">@ember-data/serializer</target>
        </trans-unit>
        <trans-unit id="41116ecbc4089ac14813bf72e5e43318c2be5504" translate="yes" xml:space="preserve">
          <source>@ember-data/store</source>
          <target state="translated">@ember-data/store</target>
        </trans-unit>
        <trans-unit id="53b9c81505e4ada6bd2f7e384935ac0aefecebed" translate="yes" xml:space="preserve">
          <source>@ember/application</source>
          <target state="translated">@ember/application</target>
        </trans-unit>
        <trans-unit id="61d1d6a0a1d2d0effe9e5e736bcb8a416e1ab90e" translate="yes" xml:space="preserve">
          <source>@ember/array</source>
          <target state="translated">@ember/array</target>
        </trans-unit>
        <trans-unit id="4fb3770c46984b4dc92bb7bd246d55a899f071a9" translate="yes" xml:space="preserve">
          <source>@ember/component</source>
          <target state="translated">@ember/component</target>
        </trans-unit>
        <trans-unit id="2aa2a6db9ebec37324c30ab650396636ffff2c94" translate="yes" xml:space="preserve">
          <source>@ember/component/helper</source>
          <target state="translated">@ember/component/helper</target>
        </trans-unit>
        <trans-unit id="bfd12969bf83fd1feb2ae5371c53bbf08e6c6d97" translate="yes" xml:space="preserve">
          <source>@ember/controller</source>
          <target state="translated">@ember/controller</target>
        </trans-unit>
        <trans-unit id="8d77a255ce4e3f4d03a7386c7b0d609e206736a4" translate="yes" xml:space="preserve">
          <source>@ember/debug</source>
          <target state="translated">@ember/debug</target>
        </trans-unit>
        <trans-unit id="25be50a77683c04ed884ca466e6d454a12bf5089" translate="yes" xml:space="preserve">
          <source>@ember/destroyable</source>
          <target state="translated">@ember/destroyable</target>
        </trans-unit>
        <trans-unit id="ca2a52f826dbf85cd3957b3dea8b7057165ca911" translate="yes" xml:space="preserve">
          <source>@ember/engine</source>
          <target state="translated">@ember/engine</target>
        </trans-unit>
        <trans-unit id="4c4a82c37ea6f5646760817ba97742b1e71a0aed" translate="yes" xml:space="preserve">
          <source>@ember/enumerable</source>
          <target state="translated">@ember/enumerable</target>
        </trans-unit>
        <trans-unit id="a0e0fde7d923c22553982f115f401c51cafbb99e" translate="yes" xml:space="preserve">
          <source>@ember/error</source>
          <target state="translated">@ember/error</target>
        </trans-unit>
        <trans-unit id="24e867317ba3a1a9f57bb896e1220fe076d661da" translate="yes" xml:space="preserve">
          <source>@ember/helper</source>
          <target state="translated">@ember/helper</target>
        </trans-unit>
        <trans-unit id="e61c1957261d6c6b6085aa1b3441eeeaddfa44c1" translate="yes" xml:space="preserve">
          <source>@ember/object</source>
          <target state="translated">@ember/object</target>
        </trans-unit>
        <trans-unit id="798360581537d58ae389b8a8f6752c4f1f0868e8" translate="yes" xml:space="preserve">
          <source>@ember/object/compat</source>
          <target state="translated">@ember/object/compat</target>
        </trans-unit>
        <trans-unit id="3c4c2741b0b49235cec15ef4795eac1978a1ee86" translate="yes" xml:space="preserve">
          <source>@ember/object/computed</source>
          <target state="translated">@ember/object/computed</target>
        </trans-unit>
        <trans-unit id="7d86f26ef80776b9b559fcdeab2cbf4376df7346" translate="yes" xml:space="preserve">
          <source>@ember/object/evented</source>
          <target state="translated">@ember/object/evented</target>
        </trans-unit>
        <trans-unit id="aaa81b3c4fef267aebd1b415e21bb6042db7550b" translate="yes" xml:space="preserve">
          <source>@ember/object/events</source>
          <target state="translated">@ember/object/events</target>
        </trans-unit>
        <trans-unit id="4ddbd2982c7200305644ab2f67826e425fe7f852" translate="yes" xml:space="preserve">
          <source>@ember/object/internals</source>
          <target state="translated">@ember/object/internals</target>
        </trans-unit>
        <trans-unit id="a3b2ed0c37ed21a2c34eb2aa0a53c279598b8ed5" translate="yes" xml:space="preserve">
          <source>@ember/object/mixin</source>
          <target state="translated">@ember/object/mixin</target>
        </trans-unit>
        <trans-unit id="d50fc146481d3aebb15ba0d167bdaa4aec33ca69" translate="yes" xml:space="preserve">
          <source>@ember/object/observers</source>
          <target state="translated">@ember/object/observers</target>
        </trans-unit>
        <trans-unit id="e925711e4b0506df036523eb257a0dbdca7178a7" translate="yes" xml:space="preserve">
          <source>@ember/polyfills</source>
          <target state="translated">@ember/polyfills</target>
        </trans-unit>
        <trans-unit id="c23ad30937b00a6f8d32bb1518874cf6fe7126e8" translate="yes" xml:space="preserve">
          <source>@ember/routing</source>
          <target state="translated">@ember/routing</target>
        </trans-unit>
        <trans-unit id="a380c7830f5e13c406c71913fedc6bfdb871da98" translate="yes" xml:space="preserve">
          <source>@ember/runloop</source>
          <target state="translated">@ember/runloop</target>
        </trans-unit>
        <trans-unit id="d2f50634a34661826cc2378889ae5b80e7f22a92" translate="yes" xml:space="preserve">
          <source>@ember/service</source>
          <target state="translated">@ember/service</target>
        </trans-unit>
        <trans-unit id="1cba11baa70229b9c6d0cec32f2c7ee14f74e5f6" translate="yes" xml:space="preserve">
          <source>@ember/string</source>
          <target state="translated">@ember/string</target>
        </trans-unit>
        <trans-unit id="9f6d55042d91454cf9ac6e6e6b5ff437fab33876" translate="yes" xml:space="preserve">
          <source>@ember/template</source>
          <target state="translated">@ember/template</target>
        </trans-unit>
        <trans-unit id="cad3aefdc2a7e736b76ab54a28fc3320e12d1315" translate="yes" xml:space="preserve">
          <source>@ember/test</source>
          <target state="translated">@ember/test</target>
        </trans-unit>
        <trans-unit id="43b98a8c4c0513b9c2417ab6d724adee5fcb8b9b" translate="yes" xml:space="preserve">
          <source>@ember/utils</source>
          <target state="translated">@ember/utils</target>
        </trans-unit>
        <trans-unit id="c74d444a6300a7850693a4126a85d1093b82c7c7" translate="yes" xml:space="preserve">
          <source>@glimmer/tracking</source>
          <target state="translated">@glimmer/tracking</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="105e706c5a0b406113be39077dfee881b1f52efb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Controller&quot;&gt;Controller&lt;/a&gt; is routable object which receives a single property from the Route &amp;ndash; &lt;code&gt;model&lt;/code&gt; &amp;ndash; which is the return value of the Route's &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#model&quot;&gt;&lt;code&gt;model()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">甲&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Controller&quot;&gt;控制器&lt;/a&gt;是可路由的对象，其从路径接收单个属性- &lt;code&gt;model&lt;/code&gt; -这是该路由的的返回值&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#model&quot;&gt; &lt;code&gt;model()&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="750249ccf178076eaee9557b46a05f046f177bef" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Service&quot;&gt;&lt;code&gt;Service&lt;/code&gt;&lt;/a&gt; is an Ember object that lives for the duration of the application, and can be made available in different parts of your application.</source>
          <target state="translated">一个&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Service&quot;&gt; &lt;code&gt;Service&lt;/code&gt; &lt;/a&gt;是灰烬对象为居住该应用程序的持续时间，并且可以使你的应用程序的不同部分可用。</target>
        </trans-unit>
        <trans-unit id="0ae76bfb5590e0d3b4555f9006461154c7e304f0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://en.wikipedia.org/wiki/Cron&quot;&gt;cron&lt;/a&gt; utility parses an input string into an object that can be used for UI</source>
          <target state="translated">甲&lt;a href=&quot;https://en.wikipedia.org/wiki/Cron&quot;&gt;的cron&lt;/a&gt;工具分析输入串转换成可以被用于UI对象</target>
        </trans-unit>
        <trans-unit id="acbed7901f13c3b1fe7d038fff4169f30c4a94de" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;AbortError&lt;/code&gt; is used by an adapter to signal that a request to the external API was aborted. For example, this can occur if the user navigates away from the current page after a request to the external API has been initiated but before a response has been received.</source>
          <target state="translated">甲 &lt;code&gt;AbortError&lt;/code&gt; 使用由适配器用信号通知给外部API的请求被中止。例如，如果在启动对外部API的请求之后但在收到响应之前用户导航离开当前页面，则可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="ae30432ae2e8254e69f769cc2cfe15c73786d284" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BelongsToReference&lt;/code&gt; is a low-level API that allows users and addon authors to perform meta-operations on a belongs-to relationship.</source>
          <target state="translated">一个 &lt;code&gt;BelongsToReference&lt;/code&gt; 是一个低级别的API，允许用户和插件的作者来执行元操作上属于对关系。</target>
        </trans-unit>
        <trans-unit id="302756143b6827ecfb1ea16432cf0c68d2519077" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ConflictError&lt;/code&gt; equates to a HTTP &lt;code&gt;409 Conflict&lt;/code&gt; response status. It is used by an adapter to indicate that the request could not be processed because of a conflict in the request. An example scenario would be when creating a record with a client-generated ID but that ID is already known to the external API.</source>
          <target state="translated">一个 &lt;code&gt;ConflictError&lt;/code&gt; 相当于一个HTTP &lt;code&gt;409 Conflict&lt;/code&gt; 响应状态。适配器使用它来指示由于请求中的冲突而无法处理该请求。一个示例场景是在创建具有客户端生成的ID的记录时，但外部API已经知道该ID。</target>
        </trans-unit>
        <trans-unit id="dc93c37be1f7b5aeb90bd5062ef7ac95cab7a0d5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DS.AbortError&lt;/code&gt; is used by an adapter to signal that a request to the external API was aborted. For example, this can occur if the user navigates away from the current page after a request to the external API has been initiated but before a response has been received.</source>
          <target state="translated">甲 &lt;code&gt;DS.AbortError&lt;/code&gt; 使用由适配器用信号通知给外部API的请求被中止。例如，如果在启动对外部API的请求之后但在收到响应之前用户导航离开当前页面，则会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="b480f5113d03af2cb8949938c6b4a9c2c5f36c44" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DS.AdapterError&lt;/code&gt; is used by an adapter to signal that an error occurred during a request to an external API. It indicates a generic error, and subclasses are used to indicate specific error states. The following subclasses are provided:</source>
          <target state="translated">甲 &lt;code&gt;DS.AdapterError&lt;/code&gt; 使用由适配器以信号通知给外部API的请求的过程中出现了错误。它指示一般错误，子类用于指示特定的错误状态。提供了以下子类：</target>
        </trans-unit>
        <trans-unit id="48d0b507fdfd4bea3540108d5aac765d760b6398" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DS.ConflictError&lt;/code&gt; equates to a HTTP &lt;code&gt;409 Conflict&lt;/code&gt; response status. It is used by an adapter to indicate that the request could not be processed because of a conflict in the request. An example scenario would be when creating a record with a client generated id but that id is already known to the external API.</source>
          <target state="translated">一个 &lt;code&gt;DS.ConflictError&lt;/code&gt; 相当于一个HTTP &lt;code&gt;409 Conflict&lt;/code&gt; 响应状态。适配器使用它来指示由于请求冲突而无法处理该请求。一个示例场景是当使用客户端生成的ID创建记录但外部API已经知道该ID时。</target>
        </trans-unit>
        <trans-unit id="22e82437db6f702331073bf754017df1fe2a4dc3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DS.ForbiddenError&lt;/code&gt; equates to a HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; response status. It is used by an adapter to signal that a request to the external API was valid but the server is refusing to respond to it. If authorization was provided and is valid, then the authenticated user does not have the necessary permissions for the request.</source>
          <target state="translated">甲 &lt;code&gt;DS.ForbiddenError&lt;/code&gt; 相当于一个HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; 响应状态。适配器使用它来表示对外部API的请求有效，但是服务器拒绝响应。如果提供了授权并且该授权是有效的，则经过身份验证的用户没有该请求的必要权限。</target>
        </trans-unit>
        <trans-unit id="be67fdd797c0eb7f63b2a4e3626f22fb402351b0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DS.InvalidError&lt;/code&gt; is used by an adapter to signal the external API was unable to process a request because the content was not semantically correct or meaningful per the API. Usually this means a record failed some form of server side validation. When a promise from an adapter is rejected with a &lt;code&gt;DS.InvalidError&lt;/code&gt; the record will transition to the &lt;code&gt;invalid&lt;/code&gt; state and the errors will be set to the &lt;code&gt;errors&lt;/code&gt; property on the record.</source>
          <target state="translated">甲 &lt;code&gt;DS.InvalidError&lt;/code&gt; 使用由适配器用信号通知外部API无法处理请求，因为该内容不是语义正确或每API有意义。通常，这意味着记录无法通过某种形式的服务器端验证。当使用 &lt;code&gt;DS.InvalidError&lt;/code&gt; 拒绝来自适配器的承诺时，记录将转换为 &lt;code&gt;invalid&lt;/code&gt; 状态，并且错误将设置为记录上的 &lt;code&gt;errors&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="8cef967c37ad7234867dac1b8fc34dc617e9de59" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DS.NotFoundError&lt;/code&gt; equates to a HTTP &lt;code&gt;404 Not Found&lt;/code&gt; response status. It is used by an adapter to signal that a request to the external API was rejected because the resource could not be found on the API.</source>
          <target state="translated">甲 &lt;code&gt;DS.NotFoundError&lt;/code&gt; 相当于一个HTTP &lt;code&gt;404 Not Found&lt;/code&gt; 响应状态。适配器使用它来表示对外部API的请求已被拒绝，因为在API上找不到该资源。</target>
        </trans-unit>
        <trans-unit id="9cf86b2e9084693ddc33e7078b13973eaf62d580" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DS.ServerError&lt;/code&gt; equates to a HTTP &lt;code&gt;500 Internal Server Error&lt;/code&gt; response status. It is used by the adapter to indicate that a request has failed because of an error in the external API.</source>
          <target state="translated">一个 &lt;code&gt;DS.ServerError&lt;/code&gt; 相当于一个HTTP &lt;code&gt;500 Internal Server Error&lt;/code&gt; 响应状态。适配器使用它来指示由于外部API中的错误而导致请求失败。</target>
        </trans-unit>
        <trans-unit id="10dcb401dc6e95359c2a133a95b5c2c685bb25ce" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DS.TimeoutError&lt;/code&gt; is used by an adapter to signal that a request to the external API has timed out. I.e. no response was received from the external API within an allowed time period.</source>
          <target state="translated">甲 &lt;code&gt;DS.TimeoutError&lt;/code&gt; 使用由适配器用信号通知给外部API的请求已超时。也就是说，在允许的时间内没有收到来自外部API的响应。</target>
        </trans-unit>
        <trans-unit id="7d7f67b6c2d390180b7b780e2376e0d612463234" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DS.UnauthorizedError&lt;/code&gt; equates to a HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; response status. It is used by an adapter to signal that a request to the external API was rejected because authorization is required and has failed or has not yet been provided.</source>
          <target state="translated">一个 &lt;code&gt;DS.UnauthorizedError&lt;/code&gt; 相当于一个HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; 响应状态。适配器使用它来表示对外部API的请求已被拒绝，因为需要授权并且授权失败或尚未提供。</target>
        </trans-unit>
        <trans-unit id="741333828bcb11a03f9d231b9f1bcacd39a479f8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ForbiddenError&lt;/code&gt; equates to a HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; response status. It is used by an adapter to signal that a request to the external API was valid but the server is refusing to respond to it. If authorization was provided and is valid, then the authenticated user does not have the necessary permissions for the request.</source>
          <target state="translated">甲 &lt;code&gt;ForbiddenError&lt;/code&gt; 相当于一个HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; 响应状态。适配器使用它来表示对外部API的请求有效，但是服务器拒绝响应。如果提供了授权并且该授权是有效的，则经过身份验证的用户没有该请求的必要权限。</target>
        </trans-unit>
        <trans-unit id="96e65b5a5ff084c70cd62752035b375432e0ecad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HasManyReference&lt;/code&gt; is a low-level API that allows users and addon authors to perform meta-operations on a has-many relationship.</source>
          <target state="translated">一个 &lt;code&gt;HasManyReference&lt;/code&gt; 是一个低级别的API，允许用户和插件的作者对一个具有一对多的关系进行元操作。</target>
        </trans-unit>
        <trans-unit id="0d8334b569a762d2cc8017cde582e0867cb0a80c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;InvalidError&lt;/code&gt; is used by an adapter to signal the external API was unable to process a request because the content was not semantically correct or meaningful per the API. Usually, this means a record failed some form of server-side validation. When a promise from an adapter is rejected with a &lt;code&gt;InvalidError&lt;/code&gt; the record will transition to the &lt;code&gt;invalid&lt;/code&gt; state and the errors will be set to the &lt;code&gt;errors&lt;/code&gt; property on the record.</source>
          <target state="translated">甲 &lt;code&gt;InvalidError&lt;/code&gt; 使用由适配器用信号通知外部API无法处理请求，因为该内容不是语义正确或每API有意义。通常，这意味着记录无法通过某种形式的服务器端验证。当通过 &lt;code&gt;InvalidError&lt;/code&gt; 拒绝来自适配器的承诺时，记录将转换为 &lt;code&gt;invalid&lt;/code&gt; 状态，并且错误将设置为记录上的 &lt;code&gt;errors&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="5930d1bcd72b59f96480c5ab195a8bd1cff6b953" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ManyArray&lt;/code&gt; is a &lt;code&gt;MutableArray&lt;/code&gt; that represents the contents of a has-many relationship.</source>
          <target state="translated">一个 &lt;code&gt;ManyArray&lt;/code&gt; 是 &lt;code&gt;MutableArray&lt;/code&gt; 代表的具有一对多的关系的内容。</target>
        </trans-unit>
        <trans-unit id="d2bb6f9087c5cdb7bc8ca4e278beb6a66c417990" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NotFoundError&lt;/code&gt; equates to a HTTP &lt;code&gt;404 Not Found&lt;/code&gt; response status. It is used by an adapter to signal that a request to the external API was rejected because the resource could not be found on the API.</source>
          <target state="translated">甲 &lt;code&gt;NotFoundError&lt;/code&gt; 相当于一个HTTP &lt;code&gt;404 Not Found&lt;/code&gt; 响应状态。适配器使用它来表示由于无法在API上找到资源而拒绝了对外部API的请求。</target>
        </trans-unit>
        <trans-unit id="d3e54ab3b27e58aa830c56ed18933ccea43ca083" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;PromiseArray&lt;/code&gt; is an object that acts like both an &lt;code&gt;Ember.Array&lt;/code&gt; and a promise. When the promise is resolved the resulting value will be set to the &lt;code&gt;PromiseArray&lt;/code&gt;'s &lt;code&gt;content&lt;/code&gt; property. This makes it easy to create data bindings with the &lt;code&gt;PromiseArray&lt;/code&gt; that will be updated when the promise resolves.</source>
          <target state="translated">甲 &lt;code&gt;PromiseArray&lt;/code&gt; 是作用像两者的对象 &lt;code&gt;Ember.Array&lt;/code&gt; 和一个承诺。兑现承诺后，结果值将设置为 &lt;code&gt;PromiseArray&lt;/code&gt; 的 &lt;code&gt;content&lt;/code&gt; 属性。这使创建带有 &lt;code&gt;PromiseArray&lt;/code&gt; 的数据绑定变得容易，而PromiseArray将在承诺解决后更新。</target>
        </trans-unit>
        <trans-unit id="0d19be6669052c929ac43d73e3cd38063b850ca8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;PromiseObject&lt;/code&gt; is an object that acts like both an &lt;code&gt;Ember.Object&lt;/code&gt; and a promise. When the promise is resolved, then the resulting value will be set to the &lt;code&gt;PromiseObject&lt;/code&gt;'s &lt;code&gt;content&lt;/code&gt; property. This makes it easy to create data bindings with the &lt;code&gt;PromiseObject&lt;/code&gt; that will be updated when the promise resolves.</source>
          <target state="translated">甲 &lt;code&gt;PromiseObject&lt;/code&gt; 是作用像两者的对象 &lt;code&gt;Ember.Object&lt;/code&gt; 和一个承诺。兑现承诺后，将把结果值设置为 &lt;code&gt;PromiseObject&lt;/code&gt; 的 &lt;code&gt;content&lt;/code&gt; 属性。这使创建带有 &lt;code&gt;PromiseObject&lt;/code&gt; 的数据绑定变得容易，而PromiseObject将在承诺解决后更新。</target>
        </trans-unit>
        <trans-unit id="bf00cf93ac9058c2b77290c956b867ba045e304f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;PromiseObject&lt;/code&gt; is an object that acts like both an &lt;code&gt;EmberObject&lt;/code&gt; and a promise. When the promise is resolved, then the resulting value will be set to the &lt;code&gt;PromiseObject&lt;/code&gt;'s &lt;code&gt;content&lt;/code&gt; property. This makes it easy to create data bindings with the &lt;code&gt;PromiseObject&lt;/code&gt; that will be updated when the promise resolves.</source>
          <target state="translated">甲 &lt;code&gt;PromiseObject&lt;/code&gt; 是作用像两者的对象 &lt;code&gt;EmberObject&lt;/code&gt; 和一个承诺。兑现承诺后，将把结果值设置为 &lt;code&gt;PromiseObject&lt;/code&gt; 的 &lt;code&gt;content&lt;/code&gt; 属性。这使创建带有 &lt;code&gt;PromiseObject&lt;/code&gt; 的数据绑定变得容易，而PromiseObject将在承诺解决后更新。</target>
        </trans-unit>
        <trans-unit id="b3cfbc96c8e5deb10ba90483ae8e16126a18ff07" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RecordReference&lt;/code&gt; is a low-level API that allows users and addon authors to perform meta-operations on a record.</source>
          <target state="translated">一个 &lt;code&gt;RecordReference&lt;/code&gt; 是一个低级别的API，允许用户和插件的作者对一个记录执行元操作。</target>
        </trans-unit>
        <trans-unit id="b8d7c0e2541a6f547442db488ca8e54fdd7b6a6b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Route&lt;/code&gt; object that fetches the model used by that template.</source>
          <target state="translated">一个 &lt;code&gt;Route&lt;/code&gt; 对象，用于获取该模板使用的模型。</target>
        </trans-unit>
        <trans-unit id="4c7a82877c9457589c254b559a3807fc6ca762ef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RouteInfoWithAttributes&lt;/code&gt; is an object that contains metadata, including the resolved value from the routes &lt;code&gt;model&lt;/code&gt; hook. Like &lt;code&gt;RouteInfo&lt;/code&gt;, a &lt;code&gt;RouteInfoWithAttributes&lt;/code&gt; represents a specific route within a Transition. It is read-only and internally immutable. It is also not observable, because a Transition instance is never changed after creation.</source>
          <target state="translated">甲 &lt;code&gt;RouteInfoWithAttributes&lt;/code&gt; 是包含元数据，包括从所述路由解析值的对象 &lt;code&gt;model&lt;/code&gt; 钩。与 &lt;code&gt;RouteInfo&lt;/code&gt; 一样， &lt;code&gt;RouteInfoWithAttributes&lt;/code&gt; 表示Transition中的特定路由。它是只读的，并且在内部是不可变的。这也是不可观察的，因为Transition实例在创建后再也不会更改。</target>
        </trans-unit>
        <trans-unit id="3189b91bdb61e1aa43efbe6b908d636d8780c481" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ServerError&lt;/code&gt; equates to a HTTP &lt;code&gt;500 Internal Server Error&lt;/code&gt; response status. It is used by the adapter to indicate that a request has failed because of an error in the external API.</source>
          <target state="translated">一个 &lt;code&gt;ServerError&lt;/code&gt; 相当于一个HTTP &lt;code&gt;500 Internal Server Error&lt;/code&gt; 响应状态。适配器使用它来指示由于外部API中的错误而导致请求失败。</target>
        </trans-unit>
        <trans-unit id="4611c23711ab67a25910c645225ba21fac86e48c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TimeoutError&lt;/code&gt; is used by an adapter to signal that a request to the external API has timed out. I.e. no response was received from the external API within an allowed time period.</source>
          <target state="translated">甲 &lt;code&gt;TimeoutError&lt;/code&gt; 使用由适配器用信号通知给外部API的请求已超时。也就是说，在允许的时间内没有收到来自外部API的响应。</target>
        </trans-unit>
        <trans-unit id="6ed120dd6aba7caf374487db58fc8248bfcbd00e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;UnauthorizedError&lt;/code&gt; equates to a HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; response status. It is used by an adapter to signal that a request to the external API was rejected because authorization is required and has failed or has not yet been provided.</source>
          <target state="translated">一个 &lt;code&gt;UnauthorizedError&lt;/code&gt; 相当于一个HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; 响应状态。适配器使用它来表示对外部API的请求已被拒绝，因为需要授权并且授权失败或尚未提供。</target>
        </trans-unit>
        <trans-unit id="9588efe0c39e2ffc672357010bf320a5487d6e55" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;contact&lt;/code&gt; route, with information on how to contact the company.</source>
          <target state="translated">一个 &lt;code&gt;contact&lt;/code&gt; 途径，并就如何对公司的联系信息。</target>
        </trans-unit>
        <trans-unit id="281545c9885e4a727fda20cf21f27e4ba744b228" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;model&lt;/code&gt; hook can return just about any type of data, like a string, object, or array, but the most common pattern is to return a JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;Promise&lt;/a&gt;.</source>
          <target state="translated">甲 &lt;code&gt;model&lt;/code&gt; 钩可以返回几乎任何类型的数据，比如串，对象或数组，但最常见的模式是返回一个JavaScript&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;无极&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2bc5cbe09603512428383da80d9a6ee76ec9be4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;multiple&lt;/code&gt;, a piece of state that represents the number to multiply the &lt;code&gt;count&lt;/code&gt; by</source>
          <target state="translated">阿 &lt;code&gt;multiple&lt;/code&gt; ，一块状态的，它表示数乘以 &lt;code&gt;count&lt;/code&gt; 由</target>
        </trans-unit>
        <trans-unit id="a9050abb1ae594c1f1f0da538d55ea7a5103db87" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;rentals/index&lt;/code&gt; route that displays the rental page's general information, and also lists available rentals. The index nested route is shown by default when the user visits the &lt;code&gt;rentals&lt;/code&gt; URL.</source>
          <target state="translated">一个 &lt;code&gt;rentals/index&lt;/code&gt; 航线，显示租赁页面的一般信息，同时还列举的出租房。当用户访问 &lt;code&gt;rentals&lt;/code&gt; URL 时，默认情况下会显示索引嵌套路线。</target>
        </trans-unit>
        <trans-unit id="266676ab249e8dd99a7c2bba6678cb01bbffbe07" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;rentals/show&lt;/code&gt; route that still displays the rental page's general information, while also showing detailed information about a selected rental. The &lt;code&gt;show&lt;/code&gt; route will get substituted with the id of the rental being shown (for example &lt;code&gt;rentals/grand-old-mansion&lt;/code&gt;).</source>
          <target state="translated">一个 &lt;code&gt;rentals/show&lt;/code&gt; 路由仍显示租金页的一般信息，同时也显示有关选定租赁的详细信息。该 &lt;code&gt;show&lt;/code&gt; 路线将得到取代有示出（例如，租赁之中的id &lt;code&gt;rentals/grand-old-mansion&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="383e441262c8c5fbe48093166f54c371460609af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;rentals&lt;/code&gt; route, where we will allow users to browse rental properties.</source>
          <target state="translated">一个 &lt;code&gt;rentals&lt;/code&gt; 路线，在那里我们将允许用户浏览的出租物业。</target>
        </trans-unit>
        <trans-unit id="67c9c63cc4aa645596774790c058c9a59c6f4f4a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;target&lt;/code&gt; option can be provided to the helper to change which object will receive the method call. This option must be a path to an object, accessible in the current context:</source>
          <target state="translated">甲 &lt;code&gt;target&lt;/code&gt; 选项可以被提供给助手，以改变对象将接收方法调用。此选项必须是在当前上下文中可访问的对象的路径：</target>
        </trans-unit>
        <trans-unit id="c339a2cfacfc5553acf33536d8c780714946440d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;templates/posts.hbs&lt;/code&gt; file has the following:</source>
          <target state="translated">一个 &lt;code&gt;templates/posts.hbs&lt;/code&gt; 文件有以下几点：</target>
        </trans-unit>
        <trans-unit id="638e1c5e3bb2ad1544bc9f1f7413ef6418c0198d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;component&lt;/em&gt; is a chunk of HTML that can be included in another component using HTML tag syntax.</source>
          <target state="translated">甲&lt;em&gt;组件&lt;/em&gt;是HTML的块，也可以被包含在其他部件中使用HTML标签的语法。</target>
        </trans-unit>
        <trans-unit id="48f2e8ad0c526974fe8246bf7dd7ebe3c99dc071" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;component&lt;/em&gt; is kind of like your own custom HTML tag. You can tell that a tag refers to an Ember component because it starts with a capital letter. Built-in HTML tags start with lowercase letters (&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;). Our component is called &lt;code&gt;&amp;lt;ReceivedMessage&amp;gt;&lt;/code&gt;, based on its name on the file system.</source>
          <target state="translated">一个&lt;em&gt;组件&lt;/em&gt;是那种喜欢自己的自定义HTML标记。您可以说标签是指Ember组件，因为它以大写字母开头。内置HTML标记以小写字母（ &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; ）开头。根据其在文件系统上的名称，我们的组件称为 &lt;code&gt;&amp;lt;ReceivedMessage&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="130dc192c9096f24701a513b2a2c27a343bad925" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;record&lt;/strong&gt; is an instance of a model that contains data loaded from a server. Your application can also create new records and save them back to the server.</source>
          <target state="translated">一个&lt;strong&gt;记录&lt;/strong&gt;是一个包含从服务器加载数据模型的实例。您的应用程序还可以创建新记录并将其保存回服务器。</target>
        </trans-unit>
        <trans-unit id="876ccb109e961a4b09a85146113a95696e15e3a0" translate="yes" xml:space="preserve">
          <source>A BelongsToReference is a low level API that allows users and addon author to perform meta-operations on a belongs-to relationship.</source>
          <target state="translated">BelongsToReference是一个低级的API,它允许用户和addon作者对一个所属关系进行元操作。</target>
        </trans-unit>
        <trans-unit id="33bcbf1fa40871cef0ad8c28e7954bc4dc4fa0a8" translate="yes" xml:space="preserve">
          <source>A Contact Route</source>
          <target state="translated">一条联系路线</target>
        </trans-unit>
        <trans-unit id="69e5bae8c7d262dd926c678c2a23dba63883fa53" translate="yes" xml:space="preserve">
          <source>A Controller is usually paired with an individual Route of the same name.</source>
          <target state="translated">控制器通常与同名的单个路由配对。</target>
        </trans-unit>
        <trans-unit id="0a4e6fd668747ce7aeec451a94588f515bfd0824" translate="yes" xml:space="preserve">
          <source>A DOM Element, Document, or jQuery to use as context</source>
          <target state="translated">一个DOM元素、Document或jQuery作为上下文使用。</target>
        </trans-unit>
        <trans-unit id="e0196e0a77e857a693a7c87aed43dc1ad6cb6d8d" translate="yes" xml:space="preserve">
          <source>A HasManyReference is a low level API that allows users and addon author to perform meta-operations on a has-many relationship.</source>
          <target state="translated">HasManyReference是一个低级的API,它允许用户和addon作者对一个has-many关系进行元操作。</target>
        </trans-unit>
        <trans-unit id="dc49bf05f59922fe942dc3948a9fcec444115457" translate="yes" xml:space="preserve">
          <source>A JSON representation of the object.</source>
          <target state="translated">对象的JSON表示。</target>
        </trans-unit>
        <trans-unit id="566d602e8aba629a425a2851f6b745033bce78a7" translate="yes" xml:space="preserve">
          <source>A JSON:API Document containing a single JSON:API Resource as its primary data.</source>
          <target state="translated">一个JSON:API文档,包含一个JSON:API资源作为其主要数据。</target>
        </trans-unit>
        <trans-unit id="60fa463e99c3c03b377886df80f4e7bcb5cc5e3d" translate="yes" xml:space="preserve">
          <source>A JavaScript source file (&lt;code&gt;app/components/rental-listing.js&lt;/code&gt;) that defines how it will behave.</source>
          <target state="translated">定义其行为方式的JavaScript源文件（ &lt;code&gt;app/components/rental-listing.js&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1c7bd2551c35b4d1aef2a15ba7dd5b8fa1898930" translate="yes" xml:space="preserve">
          <source>A Namespace is an object usually used to contain other objects or methods such as an application or framework. Create a namespace anytime you want to define one of these new containers.</source>
          <target state="translated">命名空间是一个对象,通常用于包含其他对象或方法,如应用程序或框架。只要你想定义其中一个新的容器,就可以创建一个命名空间。</target>
        </trans-unit>
        <trans-unit id="ee5fdcd91d1afa37536b1d90788cbb67385724a5" translate="yes" xml:space="preserve">
          <source>A Note on Mobile Performance</source>
          <target state="translated">关于移动性能的说明</target>
        </trans-unit>
        <trans-unit id="b1c5b38b8b094aa864efd71136414bf39accba33" translate="yes" xml:space="preserve">
          <source>A PromiseManyArray is a PromiseArray that also proxies certain method calls to the underlying manyArray. Right now we proxy:</source>
          <target state="translated">PromiseManyArray是一个PromiseArray,它也代理某些方法调用底层的manyArray。现在我们代理。</target>
        </trans-unit>
        <trans-unit id="1624fc693be4f921262d9df0488c32380d02f7fa" translate="yes" xml:space="preserve">
          <source>A Rentals Route</source>
          <target state="translated">A租车路线</target>
        </trans-unit>
        <trans-unit id="779ecff1e7b65a8089d63aed050e7eba24c33e75" translate="yes" xml:space="preserve">
          <source>A RouteInfo is an object that contains metadata about a specific route within a Transition. It is read-only and internally immutable. It is also not observable, because a Transition instance is never changed after creation.</source>
          <target state="translated">RouteInfo 是一个对象,它包含了关于 Transition 中特定路由的元数据。它是只读的,内部不可更改。它也是不可观察的,因为过渡期实例在创建后永远不会改变。</target>
        </trans-unit>
        <trans-unit id="4665625ba231935a86d8466b1f238bf318fbd0f0" translate="yes" xml:space="preserve">
          <source>A Snapshot containing the parent record's current data</source>
          <target state="translated">包含父记录当前数据的快照。</target>
        </trans-unit>
        <trans-unit id="11517f05e5bab18a8978aef16ef5e83f167c4efd" translate="yes" xml:space="preserve">
          <source>A Snapshot containing the record's current data</source>
          <target state="translated">包含记录当前数据的快照。</target>
        </trans-unit>
        <trans-unit id="694ca6b0efcd76bb616b72d48b7baf100528f381" translate="yes" xml:space="preserve">
          <source>A Snapshot for the record to serialize</source>
          <target state="translated">要序列化记录的快照</target>
        </trans-unit>
        <trans-unit id="ebbb498b1c51089825914bd7c4a31668cc640804" translate="yes" xml:space="preserve">
          <source>A Transition is a thennable (a promise-like object) that represents an attempt to transition to another route. It can be aborted, either explicitly via &lt;code&gt;abort&lt;/code&gt; or by attempting another transition while a previous one is still underway. An aborted transition can also be &lt;code&gt;retry()&lt;/code&gt;d later.</source>
          <target state="translated">过渡是一个令人难以置信的（类似于诺言的对象），表示尝试过渡到另一条路线。它可以被中止，无论是通过明确地 &lt;code&gt;abort&lt;/code&gt; 或再次尝试转型，而前一个仍在进行。异常终止的转换也可以稍后 &lt;code&gt;retry()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="719747ea16d59c2504369345f8ab69b7a5c5a51a" translate="yes" xml:space="preserve">
          <source>A Word on Promises...</source>
          <target state="translated">一句话的承诺...</target>
        </trans-unit>
        <trans-unit id="fe7be7da2076011e394aa9ca0ac3951f9bcb6487" translate="yes" xml:space="preserve">
          <source>A `QueryParams` object for `{{link-to}}`</source>
          <target state="translated">`{{链接到}}`的`QueryParams`对象;</target>
        </trans-unit>
        <trans-unit id="58cdbd4e4749375a003884d9f4eb272538b31a8e" translate="yes" xml:space="preserve">
          <source>A basic example:</source>
          <target state="translated">一个基本的例子。</target>
        </trans-unit>
        <trans-unit id="1a1d2a91012c1180a1265fe02c186ceaa77fd396" translate="yes" xml:space="preserve">
          <source>A blog post component allows two modes&amp;mdash;view and edit</source>
          <target state="translated">博客文章组件允许两种模式-查看和编辑</target>
        </trans-unit>
        <trans-unit id="bf063feb31c2f2586aed52dc94ac7da1bb1a2bf5" translate="yes" xml:space="preserve">
          <source>A boolean flag to tell if the component is in the process of destroying. This is set to true before &lt;code&gt;willDestroy&lt;/code&gt; is called.</source>
          <target state="translated">一个布尔型标志，用于指示组件是否正在销毁过程中。在 &lt;code&gt;willDestroy&lt;/code&gt; 之前，将其设置为true 。</target>
        </trans-unit>
        <trans-unit id="c1a192e1daf2ac12c65780180efe0404fb2fe22c" translate="yes" xml:space="preserve">
          <source>A boolean to tell if the component has been fully destroyed. This is set to true after &lt;code&gt;willDestroy&lt;/code&gt; is called.</source>
          <target state="translated">指示组件是否已完全销毁的布尔值。调用 &lt;code&gt;willDestroy&lt;/code&gt; 后将其设置为true 。</target>
        </trans-unit>
        <trans-unit id="2783679ee9b5feef49fa9a1dc7330bcc282cae5f" translate="yes" xml:space="preserve">
          <source>A boolean. If falsy, the deprecation will be displayed.</source>
          <target state="translated">一个布尔值。如果为假,则显示弃用情况。</target>
        </trans-unit>
        <trans-unit id="15f66f52c048c665323928b0faac199d9003256f" translate="yes" xml:space="preserve">
          <source>A button component satisfies accessibility for various arguments and actions</source>
          <target state="translated">一个按钮组件满足各种参数和动作的可访问性。</target>
        </trans-unit>
        <trans-unit id="fa29d7665d4ee1f7ccfae273841d018be10e5378" translate="yes" xml:space="preserve">
          <source>A button in the template that calls the action</source>
          <target state="translated">在模板中调用动作的按钮</target>
        </trans-unit>
        <trans-unit id="4429b3200e4fae0b282b590256f1e6d3936cb9b1" translate="yes" xml:space="preserve">
          <source>A complete &lt;a href=&quot;https://qunitjs.com/&quot;&gt;QUnit&lt;/a&gt; test harness.</source>
          <target state="translated">完整的&lt;a href=&quot;https://qunitjs.com/&quot;&gt;QUnit&lt;/a&gt;测试工具。</target>
        </trans-unit>
        <trans-unit id="408139e87592a3dc2244b1d85e4bacd8095b3285" translate="yes" xml:space="preserve">
          <source>A component consists of two parts:</source>
          <target state="translated">一个部件由两部分组成。</target>
        </trans-unit>
        <trans-unit id="5462371b0d7bf67e4e8839de22f49197e4ab6678" translate="yes" xml:space="preserve">
          <source>A component is a reusable UI element that consists of a &lt;code&gt;.hbs&lt;/code&gt; template and an optional JavaScript class that defines its behavior. For example, someone might make a &lt;code&gt;button&lt;/code&gt; in the template and handle the click behavior in the JavaScript file that shares the same name as the template.</source>
          <target state="translated">组件是可重用的UI元素，由 &lt;code&gt;.hbs&lt;/code&gt; 模板和定义其行为的可选JavaScript类组成。例如，某人可能会在模板中创建一个 &lt;code&gt;button&lt;/code&gt; ，并处理与模板具有相同名称的JavaScript文件中的单击行为。</target>
        </trans-unit>
        <trans-unit id="d2d3cc41142be1cc6e10ffbccff054f3ae945eb2" translate="yes" xml:space="preserve">
          <source>A component to display a map on each rental listing.</source>
          <target state="translated">一个用于在每个租赁列表中显示地图的组件。</target>
        </trans-unit>
        <trans-unit id="7b0befc8893bf1028121a69e186f099fab314a02" translate="yes" xml:space="preserve">
          <source>A component will often not know what information a parent needs to process an action, and will just pass all the information it has. For example, our &lt;code&gt;UserProfile&lt;/code&gt; component is going to notify its parent, &lt;code&gt;SystemPreferencesEditor&lt;/code&gt;, that a user's account was deleted, and passes along with it the full user profile object.</source>
          <target state="translated">组件通常不知道父母要处理一个动作需要什么信息，而只会传递其拥有的所有信息。例如，我们的 &lt;code&gt;UserProfile&lt;/code&gt; 组件将通知其父系统 &lt;code&gt;SystemPreferencesEditor&lt;/code&gt; ，该用户的帐户已删除，并将完整的用户配置文件对象与之一起传递。</target>
        </trans-unit>
        <trans-unit id="add9482b9d424e511fa42bb4e768ec8fac92907d" translate="yes" xml:space="preserve">
          <source>A component will often not know what information a parent needs to process an action, and will just pass all the information it has. For example, our &lt;code&gt;user-profile&lt;/code&gt; component is going to notify its parent, &lt;code&gt;system-preferences-editor&lt;/code&gt;, that a user's account was deleted, and passes along with it the full user profile object.</source>
          <target state="translated">组件通常不知道父母要处理一个动作需要什么信息，而只会传递它拥有的所有信息。例如，我们的 &lt;code&gt;user-profile&lt;/code&gt; 组件将通知其父 &lt;code&gt;system-preferences-editor&lt;/code&gt; 用户帐户已被删除，并将完整的用户配置文件对象与它一起传递。</target>
        </trans-unit>
        <trans-unit id="71286ede7d62eb4434708ac285eaba45858488f2" translate="yes" xml:space="preserve">
          <source>A component's &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#method__&quot;&gt;&lt;code&gt;$()&lt;/code&gt;&lt;/a&gt; method allows you to access the component's DOM element by returning a JQuery element. For example, you can set an attribute using jQuery's &lt;code&gt;attr()&lt;/code&gt; method:</source>
          <target state="translated">组件的&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#method__&quot;&gt; &lt;code&gt;$()&lt;/code&gt; &lt;/a&gt;方法允许您通过返回JQuery元素来访问组件的DOM元素。例如，您可以使用jQuery的 &lt;code&gt;attr()&lt;/code&gt; 方法设置属性：</target>
        </trans-unit>
        <trans-unit id="1e3404a6d6fa6e76a98547de4542bc8673bfc94c" translate="yes" xml:space="preserve">
          <source>A component's name is derived from its file name. We capitalize the first letter and every letter after &lt;code&gt;-&lt;/code&gt;, then remove the hyphens. This is known as pascal case.</source>
          <target state="translated">组件的名称是从其文件名派生的。我们将首字母大写，将 &lt;code&gt;-&lt;/code&gt; 后面的每个字母都大写，然后删除连字符。这被称为帕斯卡案。</target>
        </trans-unit>
        <trans-unit id="8ec444d9b75b946d530971861321f9f5a86edb89" translate="yes" xml:space="preserve">
          <source>A component, by itself, doesn't have direct access to DOM elements. We have to render the page, push an element back up into the component class, and only then can we safely refer to that element. This can sometimes require us to render the component's HTML twice in order for things to start working. Modifiers let us avoid this possible performance issue.</source>
          <target state="translated">一个组件,本身并不能直接访问DOM元素,我们必须渲染页面,将一个元素推回到组件类中,只有这样才能安全地引用该元素。我们必须渲染页面,将一个元素推回到组件类中,只有这样我们才能安全地引用该元素。这有时会要求我们两次渲染组件的HTML,以便开始工作。修改器让我们避免了这个可能的性能问题。</target>
        </trans-unit>
        <trans-unit id="c7e359f11d406c8a4b7955e07923f8361f0de365" translate="yes" xml:space="preserve">
          <source>A computed property macro that returns true if the value of the dependent property is null, an empty string, empty array, or empty function.</source>
          <target state="translated">一个计算属性宏,如果依赖属性的值为空、空字符串、空数组或空函数,则返回true。</target>
        </trans-unit>
        <trans-unit id="4c763479bfbc76e7d7940ef300f676a3ddbd8a2c" translate="yes" xml:space="preserve">
          <source>A computed property that calculates the maximum value in the dependent array. This will return &lt;code&gt;-Infinity&lt;/code&gt; when the dependent array is empty.</source>
          <target state="translated">计算属性，用于计算从属数组中的最大值。当从属数组为空时，它将返回 &lt;code&gt;-Infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afccd490e5f901b8a36308f4997ce0f6e3f7597b" translate="yes" xml:space="preserve">
          <source>A computed property that calculates the minimum value in the dependent array. This will return &lt;code&gt;Infinity&lt;/code&gt; when the dependent array is empty.</source>
          <target state="translated">计算属性，用于计算从属数组中的最小值。当从属数组为空时，它将返回 &lt;code&gt;Infinity&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9974b4654e469b8db57a1fcbec50896d455ccac1" translate="yes" xml:space="preserve">
          <source>A computed property that converts the provided dependent property into a boolean value.</source>
          <target state="translated">一个将所提供的依赖属性转换为布尔值的计算属性。</target>
        </trans-unit>
        <trans-unit id="fd8c6f196c803ddc9c26e77339d13d81362adfa6" translate="yes" xml:space="preserve">
          <source>A computed property that performs a logical &lt;code&gt;and&lt;/code&gt; on the original values for the provided dependent properties.</source>
          <target state="translated">对提供的从属属性执行逻辑运算 &lt;code&gt;and&lt;/code&gt; 原始值执行逻辑运算的属性。</target>
        </trans-unit>
        <trans-unit id="945b3b8ed6c6878bf7cc23d303cb20832f65993c" translate="yes" xml:space="preserve">
          <source>A computed property that returns the array of values for the provided dependent properties.</source>
          <target state="translated">一个计算过的属性,返回所提供的依赖属性的值的数组。</target>
        </trans-unit>
        <trans-unit id="d0b6149975025bb8da048400ba0227d90a7df300" translate="yes" xml:space="preserve">
          <source>A computed property that returns the inverse boolean value of the original value for the dependent property.</source>
          <target state="translated">一个计算过的属性,返回依赖属性的原始值的反布尔值。</target>
        </trans-unit>
        <trans-unit id="7a4c3da6b9a0ff1602bbda04536c0e6dce3f9392" translate="yes" xml:space="preserve">
          <source>A computed property that returns the sum of the values in the dependent array.</source>
          <target state="translated">一个计算过的属性,返回依赖数组中值的总和。</target>
        </trans-unit>
        <trans-unit id="0259bcabf1fff133ec03f302136afb061587a1e8" translate="yes" xml:space="preserve">
          <source>A computed property that returns true if the provided dependent property is equal to the given value.</source>
          <target state="translated">一个计算过的属性,如果所提供的依赖属性等于给定值,则返回true。</target>
        </trans-unit>
        <trans-unit id="43791b5f383cb17dd17a48ea10639cb5fbcf38fa" translate="yes" xml:space="preserve">
          <source>A computed property that returns true if the provided dependent property is greater than or equal to the provided value.</source>
          <target state="translated">如果所提供的从属属性大于或等于所提供的值,则返回true的计算属性。</target>
        </trans-unit>
        <trans-unit id="44459f27f904760e8a8a159ca0cff425ac024805" translate="yes" xml:space="preserve">
          <source>A computed property that returns true if the provided dependent property is greater than the provided value.</source>
          <target state="translated">如果所提供的依赖属性大于所提供的值,则返回true的计算属性。</target>
        </trans-unit>
        <trans-unit id="833a09f6f4b8923a267d472a1a55b997f80954c1" translate="yes" xml:space="preserve">
          <source>A computed property that returns true if the provided dependent property is less than or equal to the provided value.</source>
          <target state="translated">一个计算过的属性,如果所提供的从属属性小于或等于所提供的值,则返回true。</target>
        </trans-unit>
        <trans-unit id="5dbdded579e19770a07ba120d2a79f594c5bbcb1" translate="yes" xml:space="preserve">
          <source>A computed property that returns true if the provided dependent property is less than the provided value.</source>
          <target state="translated">一个计算过的属性,如果所提供的依赖属性小于所提供的值,则返回true。</target>
        </trans-unit>
        <trans-unit id="2fd2d52f530113373926a1bd4c1cfc461521a921" translate="yes" xml:space="preserve">
          <source>A computed property that returns true if the value of the dependent property is NOT null, an empty string, empty array, or empty function.</source>
          <target state="translated">一个计算过的属性,如果依赖属性的值不是空、空字符串、空数组或空函数,则返回true。</target>
        </trans-unit>
        <trans-unit id="1809faaeee90bdd62f88903099dc08048f92510f" translate="yes" xml:space="preserve">
          <source>A computed property that returns true if the value of the dependent property is null or undefined. This avoids errors from JSLint complaining about use of ==, which can be technically confusing.</source>
          <target state="translated">一个计算过的属性,如果依赖属性的值为空或未定义,则返回true。这避免了 JSLint 抱怨使用 ==的错误,因为这在技术上可能会引起混淆。</target>
        </trans-unit>
        <trans-unit id="06706f50e47c13c840dc77e9fe586ddf67f4d763" translate="yes" xml:space="preserve">
          <source>A computed property that returns true if the value of the dependent property is null, an empty string, empty array, or empty function.</source>
          <target state="translated">如果依赖属性的值为空、空字符串、空数组或空函数,则返回true的计算属性。</target>
        </trans-unit>
        <trans-unit id="bfba4061445759538ca93b92b23b86ab9bc4e76a" translate="yes" xml:space="preserve">
          <source>A computed property transforms an object literal with object's accessor function(s) into a property.</source>
          <target state="translated">计算属性将对象的访问函数的对象文字转化为属性。</target>
        </trans-unit>
        <trans-unit id="fd867b71051d6985840f7332a75c1cfaabd25b0a" translate="yes" xml:space="preserve">
          <source>A computed property which matches the original value for the dependent property against a given RegExp, returning &lt;code&gt;true&lt;/code&gt; if the value matches the RegExp and &lt;code&gt;false&lt;/code&gt; if it does not.</source>
          <target state="translated">一个已计算的属性，它与给定的RegExp匹配从属属性的原始值，如果该值与RegExp匹配，则返回 &lt;code&gt;true&lt;/code&gt; ,否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34473f32afac3e5624fa4d2072d2b42e8c3a6d02" translate="yes" xml:space="preserve">
          <source>A computed property which performs a logical &lt;code&gt;or&lt;/code&gt; on the original values for the provided dependent properties.</source>
          <target state="translated">对提供的从属属性执行逻辑 &lt;code&gt;or&lt;/code&gt; 原始值的计算属性。</target>
        </trans-unit>
        <trans-unit id="b1f7277073dcf905d770a71a52bba7d2664f93f5" translate="yes" xml:space="preserve">
          <source>A computed property which returns a new array with all the elements two or more dependent arrays have in common.</source>
          <target state="translated">一个计算过的属性,它返回一个新的数组,其中包含两个或多个依赖数组共同的所有元素。</target>
        </trans-unit>
        <trans-unit id="04f70fc8fd22a538518b37ff920f6cc48d385c51" translate="yes" xml:space="preserve">
          <source>A computed property which returns a new array with all the properties from the first dependent array sorted based on a property or sort function.</source>
          <target state="translated">一个计算过的属性,它返回一个新的数组,该数组中的所有属性根据属性或排序函数进行排序。</target>
        </trans-unit>
        <trans-unit id="b945dc0224d1ec0a214b00edce76b1817d383a7d" translate="yes" xml:space="preserve">
          <source>A computed property which returns a new array with all the properties from the first dependent array sorted based on a property or sort function. The sort macro can be used in two different ways:</source>
          <target state="translated">一个计算过的属性,它返回一个新的数组,该数组中的所有属性根据属性或排序函数进行排序。排序宏可以用两种不同的方式使用。</target>
        </trans-unit>
        <trans-unit id="d514e6791f78a7ee6387baf89be943feeb58920b" translate="yes" xml:space="preserve">
          <source>A computed property which returns a new array with all the properties from the first dependent array that are not in the second dependent array.</source>
          <target state="translated">一个计算过的属性,它返回一个新的数组,其中包含了第一个依赖数组中所有不在第二个依赖数组中的属性。</target>
        </trans-unit>
        <trans-unit id="9ae49a81f1b7b136ef1c3f3879fc002266d05133" translate="yes" xml:space="preserve">
          <source>A computed property which returns a new array with all the unique elements from an array, with uniqueness determined by specific key.</source>
          <target state="translated">一个计算过的属性,返回一个新的数组,其中包含一个数组中所有的唯一元素,唯一性由特定的键决定。</target>
        </trans-unit>
        <trans-unit id="a491d7db177839d7b7b347173e49e99aae9fafae" translate="yes" xml:space="preserve">
          <source>A computed property which returns a new array with all the unique elements from one or more dependent arrays.</source>
          <target state="translated">一个计算过的属性,返回一个新的数组,其中包含一个或多个依赖数组的所有唯一元素。</target>
        </trans-unit>
        <trans-unit id="e03280469acba4765062b9db611d7f54939166e1" translate="yes" xml:space="preserve">
          <source>A conventional project layout, making existing Ember applications easy to approach.</source>
          <target state="translated">传统的项目布局,使现有的Ember应用易于接近。</target>
        </trans-unit>
        <trans-unit id="3b14a4be92d27b0b93957122d2e638b03b636e3b" translate="yes" xml:space="preserve">
          <source>A corollary is that these tests differ in performance. The more parts used (the closer to the real app), the slower the tests. As your app gets bigger, you will want to maintain a healthy mix of unit, rendering, and application tests so that you can enjoy both broad test coverage and short feedback loop.</source>
          <target state="translated">一个必然的结果是,这些测试的性能不同。使用的部件越多(越接近真实应用),测试就越慢。随着你的应用越来越大,你会希望保持单元、渲染和应用测试的健康组合,这样你就可以享受到广泛的测试覆盖率和短暂的反馈循环。</target>
        </trans-unit>
        <trans-unit id="131025c2bde366d3f442178cd7e3ea45867ac44b" translate="yes" xml:space="preserve">
          <source>A custom serializer will also need to define a &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Serializer.html#method_normalize&quot;&gt;normalize&lt;/a&gt; method. This method is called by &lt;code&gt;store.normalize(type, payload)&lt;/code&gt; and is often used for normalizing requests made outside of Ember Data because they do not fall into the normal CRUD flow that the adapter provides.</source>
          <target state="translated">自定义序列化器还需要定义&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Serializer.html#method_normalize&quot;&gt;规范化&lt;/a&gt;方法。该方法由 &lt;code&gt;store.normalize(type, payload)&lt;/code&gt; 调用，通常用于规范在Ember Data之外发出的请求，因为它们不属于适配器提供的常规CRUD流。</target>
        </trans-unit>
        <trans-unit id="7385fb2685774f2f425893eaf1d1c9914af271f4" translate="yes" xml:space="preserve">
          <source>A custom serializer will also need to define a &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/Serializer/methods#normalize&quot;&gt;normalize&lt;/a&gt; method. This method is called by &lt;code&gt;store.normalize(type, payload)&lt;/code&gt; and is often used for normalizing requests made outside of Ember Data because they do not fall into the normal CRUD flow that the adapter provides.</source>
          <target state="translated">自定义序列化器还需要定义&lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/Serializer/methods#normalize&quot;&gt;规范化&lt;/a&gt;方法。该方法由 &lt;code&gt;store.normalize(type, payload)&lt;/code&gt; 调用，通常用于规范在Ember Data之外发出的请求，因为它们不属于适配器提供的常规CRUD流。</target>
        </trans-unit>
        <trans-unit id="965f0eae3b6dbd1496b2dd524354b0b41151afae" translate="yes" xml:space="preserve">
          <source>A debug message to display.</source>
          <target state="translated">要显示的调试信息。</target>
        </trans-unit>
        <trans-unit id="39f7b0f3c0a437ac794c87fc0c76129e28e5f4d6" translate="yes" xml:space="preserve">
          <source>A description of the assertion. This will become the text of the Error thrown if the assertion fails.</source>
          <target state="translated">断言的描述。如果断言失败,这将成为错误的文本。</target>
        </trans-unit>
        <trans-unit id="0f6dbf6476ba31036654b5f4ca962c84db32b964" translate="yes" xml:space="preserve">
          <source>A description of the deprecation.</source>
          <target state="translated">废弃的说明;</target>
        </trans-unit>
        <trans-unit id="1837e75640fb82328a65573e9d0ce100611583e4" translate="yes" xml:space="preserve">
          <source>A development server.</source>
          <target state="translated">一个开发服务器。</target>
        </trans-unit>
        <trans-unit id="5a8e30bda1a4f84944f370b4cb01736e9bdb1809" translate="yes" xml:space="preserve">
          <source>A dynamic segment is a portion of a URL that starts with a &lt;code&gt;:&lt;/code&gt; and is followed by an identifier.</source>
          <target state="translated">动态段是与开头的URL的一部分 &lt;code&gt;:&lt;/code&gt; 和之后的标识符。</target>
        </trans-unit>
        <trans-unit id="69b27e633e9aff3b70d00dcb2578883f3a25b095" translate="yes" xml:space="preserve">
          <source>A factory can represent any part of your application, like a &lt;em&gt;route&lt;/em&gt;, &lt;em&gt;template&lt;/em&gt;, or custom class. Every factory is registered with a particular key. For example, the index template is registered with the key &lt;code&gt;template:index&lt;/code&gt;, and the application route is registered with the key &lt;code&gt;route:application&lt;/code&gt;.</source>
          <target state="translated">工厂可以代表应用程序的任何部分，例如&lt;em&gt;route&lt;/em&gt;，&lt;em&gt;template&lt;/em&gt;或custom class。每个工厂都注册有特定的密钥。例如，索引模板已注册到key &lt;code&gt;template:index&lt;/code&gt; ，而应用程序路由已注册到key &lt;code&gt;route:application&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a7864153dc09f9dae9356338ebaf73309bce87f" translate="yes" xml:space="preserve">
          <source>A factory function which receives an optional owner, and returns a helper manager</source>
          <target state="translated">一个工厂函数,它接收一个可选的所有者,并返回一个帮助管理器。</target>
        </trans-unit>
        <trans-unit id="42b713eddbb7bc164ea440e78db3a8399814ac7e" translate="yes" xml:space="preserve">
          <source>A factory function, which receives the &lt;code&gt;owner&lt;/code&gt; and returns an instance of a helper manager.</source>
          <target state="translated">工厂函数，该函数接收 &lt;code&gt;owner&lt;/code&gt; 并返回帮助程序管理器的实例。</target>
        </trans-unit>
        <trans-unit id="777a6c4f022e5b47c8f56cfb49c2647d252ae153" translate="yes" xml:space="preserve">
          <source>A feature can have one of a three flags:</source>
          <target state="translated">一个功能可以有三个标志之一。</target>
        </trans-unit>
        <trans-unit id="4395ec9193a1fb8614031a07974b0dbad33102b4" translate="yes" xml:space="preserve">
          <source>A few of things to note in this simple test:</source>
          <target state="translated">在这个简单的测试中要注意的几个问题。</target>
        </trans-unit>
        <trans-unit id="e5e53ecd6c75835250a1d932992921cd834b98ff" translate="yes" xml:space="preserve">
          <source>A filtered array.</source>
          <target state="translated">一个过滤的数组。</target>
        </trans-unit>
        <trans-unit id="c09238b0f4cf63a731d526d78fb6ced46c4f1d50" translate="yes" xml:space="preserve">
          <source>A flag whether a function should only be called once</source>
          <target state="translated">一个函数是否只能被调用一次的标志。</target>
        </trans-unit>
        <trans-unit id="ac5049c57055d0ded9b551e91917eb661bb1d992" translate="yes" xml:space="preserve">
          <source>A fullname attribute is computed which combines the &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; attributes.</source>
          <target state="translated">计算出一个包含 &lt;code&gt;firstName&lt;/code&gt; 和 &lt;code&gt;lastName&lt;/code&gt; 属性的全名属性。</target>
        </trans-unit>
        <trans-unit id="195ea75b25518974cc8b5249e7d76b0d2cc15566" translate="yes" xml:space="preserve">
          <source>A fully-Octane app has the following configuration in &lt;code&gt;config/optional-features.json&lt;/code&gt;:</source>
          <target state="translated">十全十美的应用程序在 &lt;code&gt;config/optional-features.json&lt;/code&gt; 中具有以下配置：</target>
        </trans-unit>
        <trans-unit id="d39970261feb2edc9d7f8f08ee054bbf461369df" translate="yes" xml:space="preserve">
          <source>A function may be assigned to &lt;code&gt;Ember.onerror&lt;/code&gt; to be called when Ember internals encounter an error. This is useful for specialized error handling and reporting code.</source>
          <target state="translated">当Ember内部遇到错误时，可以将一个函数分配给 &lt;code&gt;Ember.onerror&lt;/code&gt; 进行调用。这对于专门的错误处理和报告代码很有用。</target>
        </trans-unit>
        <trans-unit id="11ca89654a12a432d4643c385fb7f15885d79579" translate="yes" xml:space="preserve">
          <source>A function or the name of a function to be called on `target`</source>
          <target state="translated">`target`上要调用的函数或函数名称。</target>
        </trans-unit>
        <trans-unit id="8d3d5bdef706170c1b43cf8ceb032823792398a5" translate="yes" xml:space="preserve">
          <source>A function to handle deprecation calls.</source>
          <target state="translated">一个处理弃用调用的函数。</target>
        </trans-unit>
        <trans-unit id="fc0569c63add1c0c2e9141312a0d1a21e3605cd4" translate="yes" xml:space="preserve">
          <source>A function to handle warnings.</source>
          <target state="translated">一个处理警告的函数。</target>
        </trans-unit>
        <trans-unit id="772e9928418182b0dcd98ed018442a809993c477" translate="yes" xml:space="preserve">
          <source>A good example is preventing navigation when a form is half-filled out:</source>
          <target state="translated">一个很好的例子是当表单填写一半时,防止导航。</target>
        </trans-unit>
        <trans-unit id="1c5d4033dfd88de07d9946b713597e389f38850f" translate="yes" xml:space="preserve">
          <source>A good example is sending some analytics when the route has transitioned:</source>
          <target state="translated">一个很好的例子是当路由已经过渡时发送一些分析。</target>
        </trans-unit>
        <trans-unit id="8ecf0ed232f0cc7c688861b1533c21916b08befb" translate="yes" xml:space="preserve">
          <source>A group is an array of snapshots meant to be fetched together by a single &lt;code&gt;findMany&lt;/code&gt; request.</source>
          <target state="translated">群组是一组快照，旨在通过单个 &lt;code&gt;findMany&lt;/code&gt; 请求将其一起提取。</target>
        </trans-unit>
        <trans-unit id="f0f874a612d4e0dc43e458950caf8d91e56e8ac2" translate="yes" xml:space="preserve">
          <source>A handy shortcut for this is to use a &quot;spread operator&quot;, like &lt;code&gt;...arguments&lt;/code&gt;:</source>
          <target state="translated">一个方便的快捷方式是使用&amp;ldquo;扩展运算符&amp;rdquo;，例如 &lt;code&gt;...arguments&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2bc58c2ebbcac31ed3b573d8eb9a7356a8b07577" translate="yes" xml:space="preserve">
          <source>A hash containing lists of the model's relationships, grouped by the relationship kind. For example, given a model with this definition:</source>
          <target state="translated">一个包含模型关系列表的哈希,按关系种类分组。例如,给定一个具有以下定义的模型:</target>
        </trans-unit>
        <trans-unit id="ec8ad7e0c442a611775e6bdc63a83d6c045465c6" translate="yes" xml:space="preserve">
          <source>A helper definition, which is the object or function to associate the factory function with.</source>
          <target state="translated">助手定义,就是要把工厂函数与对象或函数关联起来。</target>
        </trans-unit>
        <trans-unit id="063632d2d12e1801d8c7de89a45d4c80eb2fa5e3" translate="yes" xml:space="preserve">
          <source>A helper, which uses &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat&quot;&gt;&lt;code&gt;Intl.NumberFormat&lt;/code&gt;&lt;/a&gt;, formats a price depending on the currency and number of digits to show</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat&quot;&gt; &lt;code&gt;Intl.NumberFormat&lt;/code&gt; 的&lt;/a&gt;帮助程序根据要显示的货币和数字位数来格式化价格</target>
        </trans-unit>
        <trans-unit id="002cbcf56bee0a507c862ecd66564cde14d0ae7d" translate="yes" xml:space="preserve">
          <source>A hook you can implement to convert the URL into the model for this route.</source>
          <target state="translated">你可以实现一个钩子,把URL转换成这个路由的模型。</target>
        </trans-unit>
        <trans-unit id="e523ddb9cb0077f0e7e9efea1c6ca53b0e4f74df" translate="yes" xml:space="preserve">
          <source>A hook you can implement to convert the route's model into parameters for the URL.</source>
          <target state="translated">你可以实现一个钩子,将路由的模型转换为URL的参数。</target>
        </trans-unit>
        <trans-unit id="c79ab8868a30ae091433886b3b9b677dbdb3c517" translate="yes" xml:space="preserve">
          <source>A hook you can implement to optionally redirect to another route.</source>
          <target state="translated">你可以实现一个钩子来选择重定向到另一个路由。</target>
        </trans-unit>
        <trans-unit id="c821816d4745b2e732eb4a319568f5a0e3771e9e" translate="yes" xml:space="preserve">
          <source>A hook you can use to render the template for the current route.</source>
          <target state="translated">一个钩子,可以用来渲染当前途径的模板。</target>
        </trans-unit>
        <trans-unit id="b7d35522f785d5d2f17eb10043e9b0e22702615b" translate="yes" xml:space="preserve">
          <source>A hook you can use to reset controller values either when the model changes or the route is exiting.</source>
          <target state="translated">当模型改变或路径退出时,您可以使用一个钩子来重置控制器的值。</target>
        </trans-unit>
        <trans-unit id="09ba4354b8baac4169d50a77d1cac438e656e83b" translate="yes" xml:space="preserve">
          <source>A hook you can use to setup the controller for the current route.</source>
          <target state="translated">可以用来设置当前途径的控制器的钩子。</target>
        </trans-unit>
        <trans-unit id="ee079a76318bbe3fd0ae4177e7a0fc30647a2f50" translate="yes" xml:space="preserve">
          <source>A link will be active if &lt;code&gt;current-when&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or the current route is the route this link would transition to.</source>
          <target state="translated">如果 &lt;code&gt;current-when&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 或当前路由是此链接将转换到的路由，则该链接将处于活动状态。</target>
        </trans-unit>
        <trans-unit id="3863557073365f326c78ed7bed868b03ceb14513" translate="yes" xml:space="preserve">
          <source>A list of boot-time configuration options for customizing the behavior of an &lt;code&gt;ApplicationInstance&lt;/code&gt;.</source>
          <target state="translated">用于自定义 &lt;code&gt;ApplicationInstance&lt;/code&gt; 行为的引导时配置选项列表。</target>
        </trans-unit>
        <trans-unit id="0e649bc595abbffa19a4461f93d3e6cdb54a49bc" translate="yes" xml:space="preserve">
          <source>A list of boot-time configuration options for customizing the behavior of an &lt;code&gt;Ember.ApplicationInstance&lt;/code&gt;.</source>
          <target state="translated">用于自定义 &lt;code&gt;Ember.ApplicationInstance&lt;/code&gt; 行为的引导时配置选项列表。</target>
        </trans-unit>
        <trans-unit id="b430585ba8f0f6e9d04f0dc1006753364e999c54" translate="yes" xml:space="preserve">
          <source>A list of properties of the view to apply as attributes. If the property is a string value, the value of that string will be applied as the value for an attribute of the property's name.</source>
          <target state="translated">视图中要应用为属性的属性列表。如果属性是一个字符串值,则该字符串的值将被应用为属性名称的属性值。</target>
        </trans-unit>
        <trans-unit id="e52f350b6064cc52433762ffe29ca02248ba6cb9" translate="yes" xml:space="preserve">
          <source>A list of properties of the view to apply as class names. If the property is a string value, the value of that string will be applied as a class name.</source>
          <target state="translated">视图中要应用为类名的属性列表。如果属性是字符串值,该字符串的值将被应用为类名。</target>
        </trans-unit>
        <trans-unit id="735c8c616470156006424a3f6186395cc8775efd" translate="yes" xml:space="preserve">
          <source>A low level mixin making ObjectProxy promise-aware.</source>
          <target state="translated">一个使ObjectProxy具有承兑能力的低级 mixin。</target>
        </trans-unit>
        <trans-unit id="1067f525a37aaeec1e9620550374097824a883ec" translate="yes" xml:space="preserve">
          <source>A map whose keys are the attributes of the model (properties described by DS.attr) and whose values are the meta object for the property.</source>
          <target state="translated">一个映射,其键是模型的属性(由DS.attr描述的属性),其值是属性的元对象。</target>
        </trans-unit>
        <trans-unit id="d84b89baf6ba3181355eed803540fe64dfc2f91f" translate="yes" xml:space="preserve">
          <source>A map whose keys are the attributes of the model (properties described by DS.attr) and whose values are type of transformation applied to each attribute. This map does not include any attributes that do not have an transformation type.</source>
          <target state="translated">一个映射,其键是模型的属性(由 DS.attr 描述的属性),其值是应用于每个属性的转换类型。该映射不包括任何没有转换类型的属性。</target>
        </trans-unit>
        <trans-unit id="e9e395907f08ec2a339ee6073d6cb8677ded4443" translate="yes" xml:space="preserve">
          <source>A map whose keys are the attributes of the model (properties described by attr) and whose values are the meta object for the property.</source>
          <target state="translated">一个映射,其键是模型的属性(attr描述的属性),其值是属性的元对象。</target>
        </trans-unit>
        <trans-unit id="e683ca43722cd5bf157a9d2e1bccc16708fe5acb" translate="yes" xml:space="preserve">
          <source>A map whose keys are the attributes of the model (properties described by attr) and whose values are type of transformation applied to each attribute. This map does not include any attributes that do not have an transformation type.</source>
          <target state="translated">一个映射,其键是模型的属性(attr描述的属性),其值是应用于每个属性的转换类型。这个图谱不包括任何没有转换类型的属性。</target>
        </trans-unit>
        <trans-unit id="cc8aa238af5d9e1a69672acd9e86581953ac5d26" translate="yes" xml:space="preserve">
          <source>A map whose keys are the fields of the model and whose values are strings describing the kind of the field. A model's fields are the union of all of its attributes and relationships.</source>
          <target state="translated">一个映射,其键是模型的字段,其值是描述字段种类的字符串。一个模型的字段是其所有属性和关系的结合。</target>
        </trans-unit>
        <trans-unit id="b84a1b3938a51ee6595167fbc1b64d1c26d0eb97" translate="yes" xml:space="preserve">
          <source>A map whose keys are the relationships of a model and whose values are relationship descriptors.</source>
          <target state="translated">一个地图,其键是模型的关系,其值是关系描述符。</target>
        </trans-unit>
        <trans-unit id="5c749d8d38dbb6efe5efc0f01db27302cb7dec7f" translate="yes" xml:space="preserve">
          <source>A model also describes its relationships with other objects. For example, an &lt;code&gt;order&lt;/code&gt; may have many &lt;code&gt;line-items&lt;/code&gt;, and a &lt;code&gt;line-item&lt;/code&gt; may belong to a particular &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">模型还描述了它与其他对象的关系。例如，一个 &lt;code&gt;order&lt;/code&gt; 可能有许多 &lt;code&gt;line-items&lt;/code&gt; ，而一个 &lt;code&gt;line-item&lt;/code&gt; 可能属于某个特定 &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4f874113ec32c7d5b7fafdaa6e0741a1c0923cd" translate="yes" xml:space="preserve">
          <source>A model context does not include a primitive string or number, which does cause the model hook to be called.</source>
          <target state="translated">模型上下文不包括一个基元字符串或数字,这确实会导致模型钩子被调用。</target>
        </trans-unit>
        <trans-unit id="37871220571a57fe035f4bab6084f491f85da8be" translate="yes" xml:space="preserve">
          <source>A model is a class that defines the properties and behavior of the data that you present to the user. Anything that the user expects to see if they leave your app and come back later (or if they refresh the page) should be represented by a model.</source>
          <target state="translated">模型是一个定义你向用户展示的数据的属性和行为的类。如果用户离开你的应用程序并稍后回来(或如果他们刷新页面),他们期望看到的任何东西都应该由一个模型来表示。</target>
        </trans-unit>
        <trans-unit id="c1a07c2973ef7c81f865a5219b3d0bdb813af4e8" translate="yes" xml:space="preserve">
          <source>A model typically persists information to a web server, although models can be configured to save to anywhere else, such as the browser's Local Storage.</source>
          <target state="translated">一个模型通常将信息持久化到Web服务器上,尽管模型可以被配置为保存到其他任何地方,例如浏览器的本地存储。</target>
        </trans-unit>
        <trans-unit id="d93e695b3fd763d9a4bfbaf97085b3d02c97d87c" translate="yes" xml:space="preserve">
          <source>A navigation component recursively renders child nav items</source>
          <target state="translated">导航组件递归显示子导航项。</target>
        </trans-unit>
        <trans-unit id="7949529a103a62a4eabcba8f895a43f2a8303271" translate="yes" xml:space="preserve">
          <source>A nested route name includes the names of its ancestors. If you want to transition to a route (either via &lt;code&gt;transitionTo&lt;/code&gt; or &lt;code&gt;&amp;lt;LinkTo /&amp;gt;&lt;/code&gt;), make sure to use the full route name (&lt;code&gt;posts.new&lt;/code&gt;, not &lt;code&gt;new&lt;/code&gt;).</source>
          <target state="translated">嵌套的路线名称包括其祖先的名称。如果要转换到路由（通过 &lt;code&gt;transitionTo&lt;/code&gt; 或 &lt;code&gt;&amp;lt;LinkTo /&amp;gt;&lt;/code&gt; ），请确保使用完整的路由名称（ &lt;code&gt;posts.new&lt;/code&gt; ，而不是 &lt;code&gt;new&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f35406968e2a350aa9010aed9c3e6268ad14047e" translate="yes" xml:space="preserve">
          <source>A nested route name includes the names of its ancestors. If you want to transition to a route (either via &lt;code&gt;transitionTo&lt;/code&gt; or &lt;code&gt;{{#link-to}}&lt;/code&gt;), make sure to use the full route name (&lt;code&gt;posts.new&lt;/code&gt;, not &lt;code&gt;new&lt;/code&gt;).</source>
          <target state="translated">嵌套的路线名称包括其祖先的名称。如果要转换到路由（通过 &lt;code&gt;transitionTo&lt;/code&gt; 或 &lt;code&gt;{{#link-to}}&lt;/code&gt; ），请确保使用完整的路由名称（ &lt;code&gt;posts.new&lt;/code&gt; ，而不是 &lt;code&gt;new&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="616c4cf0d50a10888409b3e924452935f2743bdd" translate="yes" xml:space="preserve">
          <source>A nested router like this:</source>
          <target state="translated">这样的嵌套路由器。</target>
        </trans-unit>
        <trans-unit id="690c6d22d7fe0f6b900233bca2ce30f9306667f4" translate="yes" xml:space="preserve">
          <source>A new project will be created inside your current directory. You can now go to your &lt;code&gt;super-rentals&lt;/code&gt; project directory and start working on it.</source>
          <target state="translated">将在当前目录中创建一个新项目。现在，您可以转到 &lt;code&gt;super-rentals&lt;/code&gt; 项目目录并开始进行处理。</target>
        </trans-unit>
        <trans-unit id="f1b98522c77a33eec52a4f899428271445b931ef" translate="yes" xml:space="preserve">
          <source>A newly-flagged feature is only available in canary builds and can be enabled at runtime through your project's configuration file.</source>
          <target state="translated">一个新标记的功能只在金丝雀构建中可用,并且可以在运行时通过项目的配置文件启用。</target>
        </trans-unit>
        <trans-unit id="69067fafebff49c361b07bcca3e6380a630f46ce" translate="yes" xml:space="preserve">
          <source>A one-way binding only propagates changes in one direction, using &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html#method_oneWay&quot;&gt;&lt;code&gt;computed.oneWay()&lt;/code&gt;&lt;/a&gt;. Often, one-way bindings are a performance optimization and you can safely use a two-way binding (which are de facto one-way bindings if you only ever change one side). Sometimes one-way bindings are useful to achieve specific behaviour such as a default that is the same as another property but can be overridden (e.g. a shipping address that starts the same as a billing address but can later be changed)</source>
          <target state="translated">单向绑定仅使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html#method_oneWay&quot;&gt; &lt;code&gt;computed.oneWay()&lt;/code&gt; &lt;/a&gt;在一个方向上传播更改。通常，单向绑定是一种性能优化，您可以安全地使用双向绑定（如果您只更改一侧，则实际上是单向绑定）。有时，单向绑定对于实现特定行为很有用，例如与另一个属性相同但可以被覆盖的默认值（例如，送货地址与帐单地址相同但以后可以更改）</target>
        </trans-unit>
        <trans-unit id="3b0f3e16a598d49e410a51000efb66784c1b64b7" translate="yes" xml:space="preserve">
          <source>A payload with an attr configured for embedded records needs to be extracted:</source>
          <target state="translated">需要提取一个为嵌入式记录配置了attr的有效载荷。</target>
        </trans-unit>
        <trans-unit id="754b7ce544d748dc371ba0357de8219729b68a15" translate="yes" xml:space="preserve">
          <source>A payload with an attribute configured for embedded records can serialize the records together under the root attribute's payload:</source>
          <target state="translated">为嵌入式记录配置了属性的有效载荷,可以在根属性的有效载荷下将记录序列化在一起。</target>
        </trans-unit>
        <trans-unit id="560e271658f0e996c59f5c2cfa87ca60059c5e39" translate="yes" xml:space="preserve">
          <source>A primary language should be defined on the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; element's &lt;code&gt;lang&lt;/code&gt; attribute. For new apps, you can use the &lt;code&gt;--lang&lt;/code&gt; option on the &lt;code&gt;ember new&lt;/code&gt; command to set the language for a new application.</source>
          <target state="translated">应在 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 元素的 &lt;code&gt;lang&lt;/code&gt; 属性上定义主要语言。对于新应用程序，可以在 &lt;code&gt;ember new&lt;/code&gt; 命令上使用 &lt;code&gt;--lang&lt;/code&gt; 选项来设置新应用程序的语言。</target>
        </trans-unit>
        <trans-unit id="7e0ae96f3c9091427eb9feb731cecfd8d355b870" translate="yes" xml:space="preserve">
          <source>A promise can be in one of three states: pending, fulfilled, or rejected.</source>
          <target state="translated">一个承诺可以处于三种状态之一:待定、实现或拒绝。</target>
        </trans-unit>
        <trans-unit id="24e22e61d207f240f5044b1681adf8be22829d85" translate="yes" xml:space="preserve">
          <source>A promise that resolves with the new value in this belongs-to relationship.</source>
          <target state="translated">一个承诺,以这个属于关系中的新价值来解决。</target>
        </trans-unit>
        <trans-unit id="03249110696adf7d9fce18f021bbef08ff6080e2" translate="yes" xml:space="preserve">
          <source>A promise that will never resolve</source>
          <target state="translated">一个永远无法解决的承诺</target>
        </trans-unit>
        <trans-unit id="b7d10474223d0a597541e2cfcfdd2a9576dbaf03" translate="yes" xml:space="preserve">
          <source>A property descriptor containing the getter and setter (when used in classic classes)</source>
          <target state="translated">一个包含getter和setter的属性描述符(当在经典类中使用时)。</target>
        </trans-unit>
        <trans-unit id="5a4be102aa0858e349eb66775a64bb7344eb05fe" translate="yes" xml:space="preserve">
          <source>A record array is an array that contains records of a certain modelName. The record array materializes records as needed when they are retrieved for the first time. You should not create record arrays yourself. Instead, an instance of &lt;code&gt;DS.RecordArray&lt;/code&gt; or its subclasses will be returned by your application's store in response to queries.</source>
          <target state="translated">记录数组是包含特定modelName记录的数组。第一次检索记录时，记录数组将根据需要实现记录。您不应该自己创建记录数组。而是，应用程序的存储将返回 &lt;code&gt;DS.RecordArray&lt;/code&gt; 的实例或其子类以响应查询。</target>
        </trans-unit>
        <trans-unit id="9a689b2a254c28f3224517a5be192a1ac20c3801" translate="yes" xml:space="preserve">
          <source>A record array is an array that contains records of a certain modelName. The record array materializes records as needed when they are retrieved for the first time. You should not create record arrays yourself. Instead, an instance of &lt;code&gt;RecordArray&lt;/code&gt; or its subclasses will be returned by your application's store in response to queries.</source>
          <target state="translated">记录数组是包含特定modelName记录的数组。首次检索记录时，记录数组会根据需要实现记录。您不应该自己创建记录数组。而是，应用程序的存储将返回 &lt;code&gt;RecordArray&lt;/code&gt; 的实例或其子类，以响应查询。</target>
        </trans-unit>
        <trans-unit id="bb6710d1a1b95fb46edef7d88de3b44dc9a78763" translate="yes" xml:space="preserve">
          <source>A record is uniquely identified by its model &lt;strong&gt;type&lt;/strong&gt; and &lt;strong&gt;ID&lt;/strong&gt;.</source>
          <target state="translated">记录由其模型&lt;strong&gt;类型&lt;/strong&gt;和&lt;strong&gt;ID&lt;/strong&gt;唯一标识。</target>
        </trans-unit>
        <trans-unit id="21b8acb556631becaba134bf80dba6137f8e76c1" translate="yes" xml:space="preserve">
          <source>A record will be in the &lt;code&gt;valid&lt;/code&gt; state when the adapter did not report any server-side validation failures.</source>
          <target state="translated">当适配器未报告任何服务器端验证失败时，记录将处于 &lt;code&gt;valid&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="120893b9cdbc49b546ba87c5a1ec41b17ddf8aa8" translate="yes" xml:space="preserve">
          <source>A reference to the child route's &lt;code&gt;RouteInfo&lt;/code&gt;. This can be used to traverse downward to the leafmost &lt;code&gt;RouteInfo&lt;/code&gt;.</source>
          <target state="translated">对子路由的 &lt;code&gt;RouteInfo&lt;/code&gt; 的引用。这可用于向下遍历到最叶的 &lt;code&gt;RouteInfo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24f55ab745279069aaf93aa450b314a6df3a0414" translate="yes" xml:space="preserve">
          <source>A reference to the child route's RouteInfo. This can be used to traverse downward to the leafmost &lt;code&gt;RouteInfo&lt;/code&gt;.</source>
          <target state="translated">对子路由的RouteInfo的引用。这可用于向下遍历到最叶的 &lt;code&gt;RouteInfo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7efe61c1ca0992c278d663d9f67e16b8b1e0ef9" translate="yes" xml:space="preserve">
          <source>A reference to the parent route's &lt;code&gt;RouteInfo&lt;/code&gt;. This can be used to traverse upward to the topmost &lt;code&gt;RouteInfo&lt;/code&gt;.</source>
          <target state="translated">对父路由的 &lt;code&gt;RouteInfo&lt;/code&gt; 的引用。这可用于向上遍历最顶层的 &lt;code&gt;RouteInfo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b646d7aec78613fee236e641889066c0c56909b" translate="yes" xml:space="preserve">
          <source>A reference to the parent route's RouteInfo. This can be used to traverse upward to the topmost &lt;code&gt;RouteInfo&lt;/code&gt;.</source>
          <target state="translated">对父路由的RouteInfo的引用。这可用于向上遍历最顶层的 &lt;code&gt;RouteInfo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b0df2c4aaeb3477c2c604989aaf5ff0dc482665" translate="yes" xml:space="preserve">
          <source>A rejected array.</source>
          <target state="translated">一个被拒绝的数组。</target>
        </trans-unit>
        <trans-unit id="3e51bd2682d6b7c660dde73493a3071b6d63cb7e" translate="yes" xml:space="preserve">
          <source>A resource's &lt;code&gt;attrs&lt;/code&gt; option may be set to use &lt;code&gt;ids&lt;/code&gt;, &lt;code&gt;records&lt;/code&gt; or false for the &lt;code&gt;serialize&lt;/code&gt; and &lt;code&gt;deserialize&lt;/code&gt; settings.</source>
          <target state="translated">可以将资源的 &lt;code&gt;attrs&lt;/code&gt; 选项设置为使用 &lt;code&gt;ids&lt;/code&gt; ， &lt;code&gt;records&lt;/code&gt; 或false进行 &lt;code&gt;serialize&lt;/code&gt; 和 &lt;code&gt;deserialize&lt;/code&gt; 序列化设置。</target>
        </trans-unit>
        <trans-unit id="68e5af032f9f3bca13e5f3c4b42f77a9b868af85" translate="yes" xml:space="preserve">
          <source>A response that contains multiple records may have an array in its &lt;code&gt;data&lt;/code&gt; property.</source>
          <target state="translated">包含多个记录的响应可能在其 &lt;code&gt;data&lt;/code&gt; 属性中具有一个数组。</target>
        </trans-unit>
        <trans-unit id="221dbbb4bdc294822dea4e47a95dceb0c0f3504a" translate="yes" xml:space="preserve">
          <source>A route handler file, which sets up what should happen when that route is loaded &lt;em&gt;&lt;code&gt;(app/routes/about.js)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">路由处理程序文件，用于设置加载该路由时应发生的情况&lt;em&gt; &lt;code&gt;(app/routes/about.js)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd76f689c1b1cf2edecf43c5ef43576011182f5f" translate="yes" xml:space="preserve">
          <source>A route template, which is where we display the actual content for the page &lt;em&gt;&lt;code&gt;(app/templates/about.hbs)&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">路由模板，这是我们显示页面实际内容的位置&lt;em&gt; &lt;code&gt;(app/templates/about.hbs)&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="72aec06e2cbfcfd34da65ec3ca635d41cbd75f07" translate="yes" xml:space="preserve">
          <source>A route's JavaScript file is one of the best places in an app to make requests to an API. In this section of the guides, you'll learn how to use the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#model&quot;&gt;&lt;code&gt;model&lt;/code&gt;&lt;/a&gt; method to fetch data by making a HTTP request, and render it in a route's &lt;code&gt;hbs&lt;/code&gt; template, or pass it down to a component.</source>
          <target state="translated">路线的JavaScript文件是应用中向API发出请求的最佳位置之一。在指南的这一部分中，您将学习如何使用&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#model&quot;&gt; &lt;code&gt;model&lt;/code&gt; &lt;/a&gt;方法通过发出HTTP请求来获取数据，并将其呈现在路由的 &lt;code&gt;hbs&lt;/code&gt; 模板中，或将其传递给组件。</target>
        </trans-unit>
        <trans-unit id="f80c0f471744d70fd7d49ec2b0c3b6ae236eac6b" translate="yes" xml:space="preserve">
          <source>A sample component template could look like this:</source>
          <target state="translated">一个示例组件模板可以是这样的。</target>
        </trans-unit>
        <trans-unit id="313eb4ae7397faa5f4909972c2ad73f65f3cff0d" translate="yes" xml:space="preserve">
          <source>A serializer has two main roles in Ember Data. First, it is responsible for taking a response from an adapter and serializing it into the normalized JSON format that Ember Data understands. Secondly, it transforms snapshots of records into a payload the adapter will send to the server when creating, updating, or deleting a record.</source>
          <target state="translated">序列化器在Ember Data中有两个主要作用。首先,它负责从适配器获取响应,并将其序列化为Ember Data可以理解的标准化JSON格式。其次,它将记录的快照转换为有效载荷,适配器将在创建、更新或删除记录时发送给服务器。</target>
        </trans-unit>
        <trans-unit id="37af9017b42e56fbbcb87cffc4954a5d243ed7da" translate="yes" xml:space="preserve">
          <source>A serializer in Ember Data is responsible for normalizing a payload from an adapter into the format that Ember Data understands. It is also responsible for transforming a snapshot of a record into the payload that an adapter will send to the backend.</source>
          <target state="translated">Ember Data中的序列化器负责将来自适配器的有效载荷规范化为Ember Data能够理解的格式,它还负责将记录的快照转化为适配器向后端发送的有效载荷。它还负责将记录的快照转换为适配器将发送至后端的有效载荷。</target>
        </trans-unit>
        <trans-unit id="7c895b90222fc81da588c9e0646d2df62e5cf424" translate="yes" xml:space="preserve">
          <source>A service to keep a cache of rendered maps to use in different places in the application.</source>
          <target state="translated">一个用于保存渲染地图缓存的服务,以便在应用程序的不同地方使用。</target>
        </trans-unit>
        <trans-unit id="3c3d903ea99c2476f16cbf3393899fe9f15b0928" translate="yes" xml:space="preserve">
          <source>A simple example of usage:</source>
          <target state="translated">一个简单的使用实例。</target>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="translated">一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="7c5a6abc5e310dfe6a84055df1ea6d3961e87d8a" translate="yes" xml:space="preserve">
          <source>A skip navigation link, or skip link, is a useful feature for users who want to bypass content that is repeated on multiple pages (i.e., a site header). This can especially helpful to users with assistive technology, who have to browse website content in a more linear fashion, but it can also be useful for power users who prefer to navigate websites only using a keyboard.</source>
          <target state="translated">跳过导航链接或跳过链接是一个有用的功能,对于那些想要绕过在多个页面上重复的内容的用户(例如,网站标题)。这对使用辅助技术的用户特别有帮助,因为他们必须以更线性的方式浏览网站内容,但对于喜欢只使用键盘浏览网站的能力型用户来说也很有用。</target>
        </trans-unit>
        <trans-unit id="d4d274a36ee6e757d5a75282c192d27af9d7b6bf" translate="yes" xml:space="preserve">
          <source>A sophisticated text editor for code, markup and prose.</source>
          <target state="translated">一个复杂的代码、标记和散文的文本编辑器。</target>
        </trans-unit>
        <trans-unit id="efe2accf54d3a5f4254784eb6d5cfb9db1888678" translate="yes" xml:space="preserve">
          <source>A standard promise hook that resolves if the transition succeeds and rejects if it fails/redirects/aborts.</source>
          <target state="translated">一个标准的承诺钩子,如果过渡成功则解析,如果失败/重定向/中止则拒绝。</target>
        </trans-unit>
        <trans-unit id="3a5bc1ec0036ae274060ccd389cd6f0b1ea67333" translate="yes" xml:space="preserve">
          <source>A state may implement zero or more events and flags.</source>
          <target state="translated">一个状态可以实现零个或多个事件和标志。</target>
        </trans-unit>
        <trans-unit id="32cd32f434617976faf72a74fb5d07b5c8ed826d" translate="yes" xml:space="preserve">
          <source>A string that will not be HTML escaped by Handlebars.</source>
          <target state="translated">一个不会被Handlebars转义的HTML字符串。</target>
        </trans-unit>
        <trans-unit id="bdc38e38a317499db1d65de43d85943675b74110" translate="yes" xml:space="preserve">
          <source>A stub stands in place of the real object in your application and simulates its behavior. In the stub service, define a method that will fetch the map based on location, called &lt;code&gt;getMapElement&lt;/code&gt;.</source>
          <target state="translated">存根代替应用程序中的实际对象并模拟其行为。在存根服务中，定义一个将根据位置获取地图的方法，称为 &lt;code&gt;getMapElement&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aeef60b43ff081b31523ea1c338caf0f4d76bf9e" translate="yes" xml:space="preserve">
          <source>A subclass of the JavaScript Error object for use in Ember.</source>
          <target state="translated">在Ember中使用的JavaScript Error对象的一个子类。</target>
        </trans-unit>
        <trans-unit id="296c7fcd6cedd62993531604b81b2ac120760f97" translate="yes" xml:space="preserve">
          <source>A target object or a function</source>
          <target state="translated">一个目标对象或一个函数</target>
        </trans-unit>
        <trans-unit id="cb536b028ba547a17fc771e9b4531254772e08f5" translate="yes" xml:space="preserve">
          <source>A template that defines how it will look (&lt;code&gt;app/templates/components/rental-listing.hbs&lt;/code&gt;)</source>
          <target state="translated">定义外观的 &lt;code&gt;app/templates/components/rental-listing.hbs&lt;/code&gt; （app / templates / components / rental-listing.hbs）</target>
        </trans-unit>
        <trans-unit id="acfe9143c927cfb089cd2845d43a1eeff971a8a8" translate="yes" xml:space="preserve">
          <source>A template to be displayed when the user visits &lt;code&gt;/scientists&lt;/code&gt;.</source>
          <target state="translated">用户访问 &lt;code&gt;/scientists&lt;/code&gt; 时要显示的模板。</target>
        </trans-unit>
        <trans-unit id="48d4844f1559cb2de2f2064f2fcbdfefc8d2bee8" translate="yes" xml:space="preserve">
          <source>A top most object of the request payload onto which to append the serialized record</source>
          <target state="translated">请求有效载荷的最上层对象,用于附加序列化记录。</target>
        </trans-unit>
        <trans-unit id="7c16b851b5bfa04503f2f1a6303edf6dc213b40e" translate="yes" xml:space="preserve">
          <source>A transform has two functions: &lt;code&gt;serialize&lt;/code&gt; and &lt;code&gt;deserialize&lt;/code&gt;. Deserialization converts a value to a format that the client expects. Serialization does the reverse and converts a value to the format expected by the persistence layer.</source>
          <target state="translated">转换具有两个功能： &lt;code&gt;serialize&lt;/code&gt; 和 &lt;code&gt;deserialize&lt;/code&gt; 序列化。反序列化将值转换为客户端期望的格式。序列化执行相反的操作，并将值转换为持久层所需的格式。</target>
        </trans-unit>
        <trans-unit id="e8e324271ace94d3ca83d71a5940c8b717bc62ba" translate="yes" xml:space="preserve">
          <source>A unit test for this route.</source>
          <target state="translated">该路线的单元测试。</target>
        </trans-unit>
        <trans-unit id="4e4c72968c6c63750c88efcc1df92843dcdc01e1" translate="yes" xml:space="preserve">
          <source>A user is able to create a blog post.</source>
          <target state="translated">用户能够创建一个博客文章。</target>
        </trans-unit>
        <trans-unit id="14ac3739ecbc3cce41527a43c02dac69610f63a1" translate="yes" xml:space="preserve">
          <source>A user is able to log in via the login form.</source>
          <target state="translated">用户能够通过登录形式进行登录。</target>
        </trans-unit>
        <trans-unit id="89ef66d96328015790ebfc7c576d8ad66ef363e3" translate="yes" xml:space="preserve">
          <source>A user is prevented from typing more than 50 characters into post's title field.</source>
          <target state="translated">防止用户在帖子的标题栏中输入超过50个字符。</target>
        </trans-unit>
        <trans-unit id="58af9c9e350819c582740d5ff4808115ce6132cb" translate="yes" xml:space="preserve">
          <source>A utility function to create a map from the Google Maps API.</source>
          <target state="translated">一个从谷歌地图API创建地图的实用函数。</target>
        </trans-unit>
        <trans-unit id="bb4771b943bff95e54d8589ba98dd97636cf52e6" translate="yes" xml:space="preserve">
          <source>A validation tool which checks for common issues in your JavaScript. You'd usually use this in your build process to enforce quality in your codebase. A great example of something to check for: &lt;em&gt;making sure you've always got your semicolons&lt;/em&gt;.</source>
          <target state="translated">验证工具，用于检查JavaScript中的常见问题。您通常会在构建过程中使用它来增强代码库的质量。一个要检查的东西的很好的例子：&lt;em&gt;确保总是有分号&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="7229154626a7e638f8dfb8f3853f864acc34490b" translate="yes" xml:space="preserve">
          <source>A valuable attribute of the Ember framework is its use of &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt; to aid projects in keeping up with changes to the framework. Before any functionality or API is removed it first goes through a deprecation period where the functionality is still supported, but usage of it generates a warning logged to the browser console. These warnings can pile up between major releases to a point where the amount of deprecation warnings that scroll through the console becomes overwhelming.</source>
          <target state="translated">Ember框架的一个有价值的属性是它使用&lt;a href=&quot;http://semver.org/&quot;&gt;语义版本控制&lt;/a&gt;来帮助项目跟上框架的变化。在删除任何功能或API之前，它首先会经过一个弃用期，在该期间内仍支持该功能，但是使用该功能会生成一条警告，并记录到浏览器控制台中。这些警告可能会在主要发行版之间堆积起来，以至于在控制台中滚动的弃用警告数量变得不堪重负。</target>
        </trans-unit>
        <trans-unit id="d11138bbe4d4307c7e11d7cf9bc1fbd666ddcc73" translate="yes" xml:space="preserve">
          <source>A value is blank if it is empty or a whitespace string.</source>
          <target state="translated">如果是空值或空白字符串,则该值为空白。</target>
        </trans-unit>
        <trans-unit id="8d1f021a0c0f2b13574b49fae2a1d6d476e7e060" translate="yes" xml:space="preserve">
          <source>A value is present if it not &lt;code&gt;isBlank&lt;/code&gt;.</source>
          <target state="translated">如果不是 &lt;code&gt;isBlank&lt;/code&gt; ,则存在一个值。</target>
        </trans-unit>
        <trans-unit id="f48d0a670e99edf05724ed7e949ae0349d64236c" translate="yes" xml:space="preserve">
          <source>A visitor does not have access to the admin panel.</source>
          <target state="translated">访客无法进入管理面板。</target>
        </trans-unit>
        <trans-unit id="9cefa9b15bf3ec23b34cb0c6282bcc551ba027cd" translate="yes" xml:space="preserve">
          <source>A warning to display.</source>
          <target state="translated">要显示的警告。</target>
        </trans-unit>
        <trans-unit id="778f927c7f135cd674b23e2ba49a161af1a2ded2" translate="yes" xml:space="preserve">
          <source>AEmber.NativeArraypublic</source>
          <target state="translated">AEmber.NativeArraypublic</target>
        </trans-unit>
        <trans-unit id="9879dc23cf752ded0d3c709d57d87b803f4e81e2" translate="yes" xml:space="preserve">
          <source>AJAX callbacks</source>
          <target state="translated">AJAX回调</target>
        </trans-unit>
        <trans-unit id="a9046dbb4daece424db4f9e1cb3852669b9ef68d" translate="yes" xml:space="preserve">
          <source>AMD JavaScript modules</source>
          <target state="translated">AMD JavaScript模块</target>
        </trans-unit>
        <trans-unit id="00e38421a40e481837442f1e838c95ebda36e489" translate="yes" xml:space="preserve">
          <source>API Overview</source>
          <target state="translated">API概述</target>
        </trans-unit>
        <trans-unit id="ca8ef9a45d6a496b147a5eb817fc9fcaef9a74fc" translate="yes" xml:space="preserve">
          <source>API requests can be made almost anywhere in an Ember app, however the most common place is the &lt;code&gt;model&lt;/code&gt; hook of a Route.</source>
          <target state="translated">几乎可以在Ember应用程序中的任何位置发出API请求，但是最常见的地方是Route的 &lt;code&gt;model&lt;/code&gt; 挂钩。</target>
        </trans-unit>
        <trans-unit id="414dc2de6205a888f5a4098c07424abb4fdb4856" translate="yes" xml:space="preserve">
          <source>API responses will be translated into instances of &lt;code&gt;DS.Errors&lt;/code&gt; differently, depending on the specific combination of adapter and serializer used. You may want to check the documentation or the source code of the libraries that you are using, to know how they expect errors to be communicated.</source>
          <target state="translated">API响应将转换为 &lt;code&gt;DS.Errors&lt;/code&gt; 实例的方式有所不同，具体取决于所使用的适配器和序列化程序的特定组合。您可能需要查看正在使用的库的文档或源代码，以了解他们期望如何传达错误。</target>
        </trans-unit>
        <trans-unit id="5fe041530ba8558c321bac220e1c8de3c4e1f021" translate="yes" xml:space="preserve">
          <source>API responses will be translated into instances of &lt;code&gt;Errors&lt;/code&gt; differently, depending on the specific combination of adapter and serializer used. You may want to check the documentation or the source code of the libraries that you are using, to know how they expect errors to be communicated.</source>
          <target state="translated">根据所使用的适配器和序列化程序的特定组合，API响应将以不同的方式转换为 &lt;code&gt;Errors&lt;/code&gt; 实例。您可能需要查看正在使用的库的文档或源代码，以了解他们期望如何传达错误。</target>
        </trans-unit>
        <trans-unit id="324cefd2fcd2f4bbcb04a1db3ecabb3920ce6198" translate="yes" xml:space="preserve">
          <source>AbortError</source>
          <target state="translated">AbortError</target>
        </trans-unit>
        <trans-unit id="2e8d2dae567e5b401c938574cd5a980faa892739" translate="yes" xml:space="preserve">
          <source>Aborted transitions can be retried at a later time. A common use case for this is having an authenticated route redirect the user to a login page, and then redirecting them back to the authenticated route once they've logged in.</source>
          <target state="translated">终止的转换可以在以后的时间重新尝试。一个常见的用例是让一个已认证的路由将用户重定向到一个登录页面,然后在他们登录后将他们重定向回已认证的路由。</target>
        </trans-unit>
        <trans-unit id="7f822f9e40f9b5173117f5f39ac274176470b8ba" translate="yes" xml:space="preserve">
          <source>Aborting Transitions Within &lt;code&gt;model&lt;/code&gt;, &lt;code&gt;beforeModel&lt;/code&gt;, &lt;code&gt;afterModel&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;model&lt;/code&gt; ， &lt;code&gt;beforeModel&lt;/code&gt; 和 &lt;code&gt;afterModel&lt;/code&gt; 中终止过渡</target>
        </trans-unit>
        <trans-unit id="3ea678ab865304fc908e56076cf840e30979fc06" translate="yes" xml:space="preserve">
          <source>Aborts the Transition. Note you can also implicitly abort a transition by initiating another transition while a previous one is underway.</source>
          <target state="translated">中止过渡。请注意,您也可以通过在前一个转换进行时启动另一个转换来隐式地中止转换。</target>
        </trans-unit>
        <trans-unit id="9f37869865287c799aa5a03f4a625dae9b804236" translate="yes" xml:space="preserve">
          <source>Abstracting the Logic Into a Custom Modifier</source>
          <target state="translated">将逻辑抽象到一个自定义修饰符中</target>
        </trans-unit>
        <trans-unit id="ff4e81eb7658715d12bb057c6976bab2d9e1b4bb" translate="yes" xml:space="preserve">
          <source>Acceptance Testing the Rental List</source>
          <target state="translated">验收测试租赁清单</target>
        </trans-unit>
        <trans-unit id="44a09c418324158dfd048b7b23925eb42035c677" translate="yes" xml:space="preserve">
          <source>Acceptance Tests</source>
          <target state="translated">验收测试</target>
        </trans-unit>
        <trans-unit id="0e265262b61a3e40190ac74373b3099a1e2b2304" translate="yes" xml:space="preserve">
          <source>Acceptance tests are setup by calling the function &lt;code&gt;moduleForAcceptance&lt;/code&gt;. This function ensures that your Ember application is started and shut down between each test.</source>
          <target state="translated">通过调用功能 &lt;code&gt;moduleForAcceptance&lt;/code&gt; 来设置验收测试。此功能可确保在每次测试之间启动和关闭Ember应用程序。</target>
        </trans-unit>
        <trans-unit id="27656383c861b3221a09a8e2857ac96875ead638" translate="yes" xml:space="preserve">
          <source>Acceptance tests are used to test user interaction and application flow. The tests interact with the application in the same ways that a user would, by doing things like filling out form fields and clicking buttons. Acceptance tests ensure that the features within a project are basically functional, and are valuable in ensuring the core features of a project have not regressed, and that the project's goals are being met.</source>
          <target state="translated">验收测试用于测试用户交互和应用程序流程。测试以用户与应用程序相同的方式进行交互,比如填写表格字段和点击按钮。验收测试可以确保项目中的功能基本正常,对于确保项目的核心功能没有退步,以及项目的目标得到实现是很有价值的。</target>
        </trans-unit>
        <trans-unit id="8a5f638cc1d0f0efc4d9a9b92ac6c43085673983" translate="yes" xml:space="preserve">
          <source>Accepting Input to a Component</source>
          <target state="translated">接受一个组件的输入</target>
        </trans-unit>
        <trans-unit id="d660049bc1f2f54fc0e3f4ace6fa5eb205f2f1e0" translate="yes" xml:space="preserve">
          <source>Accessibility</source>
          <target state="translated">Accessibility</target>
        </trans-unit>
        <trans-unit id="bc03dfb41cf672c9544f728deff319cd4d6c8f77" translate="yes" xml:space="preserve">
          <source>Accessibility Strategy</source>
          <target state="translated">无障碍战略</target>
        </trans-unit>
        <trans-unit id="a39a9bcdb3565667f2811d0907a6d5f065eb9cff" translate="yes" xml:space="preserve">
          <source>Accessibility addons</source>
          <target state="translated">可访问性附加组件</target>
        </trans-unit>
        <trans-unit id="3e0dbeb454867393e2d95531904ae42de1326c30" translate="yes" xml:space="preserve">
          <source>Accessibility should be considered at the start of a project, whether that project has named accessibility an explicit goal or not. Since no one can predict anyone else's future (including whether or not they will need assistive technology at some point), and because in many places around the world it is legally required to make websites digitally accessible, accessibility should be thought about in the same way as performance- a necessity for any web-based product.</source>
          <target state="translated">无论该项目是否将无障碍作为明确的目标,都应在项目开始时就考虑到无障碍问题。由于没有人能够预测其他人的未来(包括他们是否会在某些时候需要辅助技术),而且在世界许多地方,法律要求网站必须是数字无障碍的,因此,应该以同样的方式来考虑无障碍性--任何基于网络的产品都是必要的。</target>
        </trans-unit>
        <trans-unit id="ccd5843fad36a0b4ae613f2e2045972bcab9f656" translate="yes" xml:space="preserve">
          <source>Accessible Color Palette Builder</source>
          <target state="translated">无障碍调色板生成器</target>
        </trans-unit>
        <trans-unit id="9bd2618007c94ee34aa19377671346876e369595" translate="yes" xml:space="preserve">
          <source>Accessible Rich Internet Applications (ARIA) 1.1</source>
          <target state="translated">可访问的富互联网应用(ARIA)1.1</target>
        </trans-unit>
        <trans-unit id="f07619cb27c8b1f57f6fc623b700d0ed621288a0" translate="yes" xml:space="preserve">
          <source>Accessible name</source>
          <target state="translated">可使用的名称</target>
        </trans-unit>
        <trans-unit id="2f344ca153944c9ec54979a9301bb2d6de3bdda3" translate="yes" xml:space="preserve">
          <source>Accessing Object Properties</source>
          <target state="translated">访问对象属性</target>
        </trans-unit>
        <trans-unit id="c35e20fb739a4737e5fef9dcd31a2c6baf677b39" translate="yes" xml:space="preserve">
          <source>Accessing Services</source>
          <target state="translated">获取服务</target>
        </trans-unit>
        <trans-unit id="cfc5b1dde1e2c63523e0ed02ea95577bd5e3c1d2" translate="yes" xml:space="preserve">
          <source>Accessing an item's &lt;code&gt;index&lt;/code&gt;</source>
          <target state="translated">访问项目的 &lt;code&gt;index&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca4a305307e0ff27e9f11dedc446bb26089db652" translate="yes" xml:space="preserve">
          <source>Accessing our maps API through a &lt;a href=&quot;https://guides.emberjs.com/applications/services&quot;&gt;service&lt;/a&gt; will give us several benefits</source>
          <target state="translated">通过&lt;a href=&quot;https://guides.emberjs.com/applications/services&quot;&gt;服务&lt;/a&gt;访问我们的地图API 将为我们带来一些好处</target>
        </trans-unit>
        <trans-unit id="9b47ccf55149807d853d44259738ef66e00d80b4" translate="yes" xml:space="preserve">
          <source>Accessing the Google Maps API with a Utility</source>
          <target state="translated">使用实用程序访问谷歌地图API</target>
        </trans-unit>
        <trans-unit id="f5b0e226ed894764db92e76b6c1f1203c0b805bb" translate="yes" xml:space="preserve">
          <source>Accessors</source>
          <target state="translated">Accessors</target>
        </trans-unit>
        <trans-unit id="38ed25f645dcfc2df115d6a387d5f2679551323f" translate="yes" xml:space="preserve">
          <source>Accessors can be defined with the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; keywords:</source>
          <target state="translated">可以使用 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 关键字定义访问器：</target>
        </trans-unit>
        <trans-unit id="900e02bcf9381fc252334366f1222273386991f8" translate="yes" xml:space="preserve">
          <source>Accessors, also known as getters and setters</source>
          <target state="translated">存取器,也被称为getters和setters。</target>
        </trans-unit>
        <trans-unit id="05ae864fba470c2ed48b02c13385b6ad4c84ead4" translate="yes" xml:space="preserve">
          <source>Accessors, also known as getters/setters, allow you to define a special function that is &lt;em&gt;accessed&lt;/em&gt; like a property. For example:</source>
          <target state="translated">访问器（也称为获取器/设置器）允许您定义一个特殊的函数，该函数像属性一样被&lt;em&gt;访问&lt;/em&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="12a3a4f498b28cbec01c44aacf0dc5e3a1b828ef" translate="yes" xml:space="preserve">
          <source>Accuracy</source>
          <target state="translated">Accuracy</target>
        </trans-unit>
        <trans-unit id="97b101eb4a96a947309ad20d6017680103e3f95d" translate="yes" xml:space="preserve">
          <source>Across the Board Normalization</source>
          <target state="translated">全面正常化</target>
        </trans-unit>
        <trans-unit id="97c89a4d6630adeb18fa12ba9976a31413fe293e" translate="yes" xml:space="preserve">
          <source>Action</source>
          <target state="translated">Action</target>
        </trans-unit>
        <trans-unit id="0f1609148ca60a0b757b4b6ef200dcfe2f0a0af5" translate="yes" xml:space="preserve">
          <source>Action Fundamentals</source>
          <target state="translated">行动基本原则</target>
        </trans-unit>
        <trans-unit id="617f82299f3621e8f106b178792e79a9d42f9c01" translate="yes" xml:space="preserve">
          <source>Action Parameters</source>
          <target state="translated">动作参数</target>
        </trans-unit>
        <trans-unit id="9ead969fd194363deaca0f030c3df01bbaee4b1b" translate="yes" xml:space="preserve">
          <source>ActionHandler</source>
          <target state="translated">ActionHandler</target>
        </trans-unit>
        <trans-unit id="c81e8765f02fbfe34ff71f82e9a3d6c35bf7b012" translate="yes" xml:space="preserve">
          <source>ActionSupport</source>
          <target state="translated">ActionSupport</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="dca4d295973c33e1b157a02a2e6f659654a2ead2" translate="yes" xml:space="preserve">
          <source>Actions are JavaScript methods that you can call from a template. Find out how you can use actions with recommended patterns from the chapter &lt;a href=&quot;https://guides.emberjs.com/in-depth-topics/patterns-for-actions/&quot;&gt;Patterns for Actions&lt;/a&gt;.</source>
          <target state="translated">操作是可以从模板调用的JavaScript方法。在&amp;ldquo;动作模式&amp;rdquo;一章中找到如何使用具有推荐&lt;a href=&quot;https://guides.emberjs.com/in-depth-topics/patterns-for-actions/&quot;&gt;模式的动作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c38647e8052fef0032f19d5d819d8ac4390cb154" translate="yes" xml:space="preserve">
          <source>Actions are always looked up on the &lt;code&gt;actions&lt;/code&gt; property of the current context. This avoids collisions in the naming of common actions, such as &lt;code&gt;destroy&lt;/code&gt;. Two options can be passed to the &lt;code&gt;action&lt;/code&gt; helper when it is used in this way.</source>
          <target state="translated">总是在当前上下文的 &lt;code&gt;actions&lt;/code&gt; 属性上查找动作。这样可以避免在常见动作（例如 &lt;code&gt;destroy&lt;/code&gt; )的命名中发生冲突。以这种方式使用时，可以将两个选项传递给 &lt;code&gt;action&lt;/code&gt; 帮助器。</target>
        </trans-unit>
        <trans-unit id="ac13185fa12701db033762c764d4e1def30c4909" translate="yes" xml:space="preserve">
          <source>Actions are the primary method for updating state in an Ember application, and as such they have lots of uses and patterns. This guide covers some of the more common action patterns that can be used in Ember.</source>
          <target state="translated">动作是Ember应用中更新状态的主要方法,因此它们有很多用途和模式。本指南涵盖了Ember中一些比较常见的动作模式。</target>
        </trans-unit>
        <trans-unit id="ef321ee173e7ba5a99a3e27aa555cb83c2a83923" translate="yes" xml:space="preserve">
          <source>Actions can also be invoked from other parts of your application via &lt;code&gt;ActionHandler#send&lt;/code&gt;.</source>
          <target state="translated">也可以通过 &lt;code&gt;ActionHandler#send&lt;/code&gt; 从应用程序的其他部分调用动作。</target>
        </trans-unit>
        <trans-unit id="d265dabb987eaae69a060cfd294d552f86de3822" translate="yes" xml:space="preserve">
          <source>Actions can be invoked on objects other than the component directly from the template. For example, in our &lt;code&gt;SendMessage&lt;/code&gt; component we might include a service that processes the &lt;code&gt;sendMessage&lt;/code&gt; logic.</source>
          <target state="translated">可以直接从模板对组件以外的对象调用操作。例如，在我们的 &lt;code&gt;SendMessage&lt;/code&gt; 组件中，我们可能包括处理 &lt;code&gt;sendMessage&lt;/code&gt; 逻辑的服务。</target>
        </trans-unit>
        <trans-unit id="ac67e5ce98c087908f39f11cea90bf623ccb17fb" translate="yes" xml:space="preserve">
          <source>Actions can be invoked on objects other than the component directly from the template. For example, in our &lt;code&gt;send-message&lt;/code&gt; component we might include a service that processes the &lt;code&gt;sendMessage&lt;/code&gt; logic.</source>
          <target state="translated">可以直接从模板对除组件以外的对象调用操作。例如，在我们的 &lt;code&gt;send-message&lt;/code&gt; 组件中，我们可能包括处理 &lt;code&gt;sendMessage&lt;/code&gt; 逻辑的服务。</target>
        </trans-unit>
        <trans-unit id="3ce8f13218eb402c2df429715fa272511ad7668d" translate="yes" xml:space="preserve">
          <source>Actions in components allow you to decouple an event happening from how it's handled, leading to modular, more reusable components.</source>
          <target state="translated">组件中的动作允许你将事件的发生与处理方式解耦,从而实现模块化、更可重用的组件。</target>
        </trans-unit>
        <trans-unit id="c612ed0140667c0e62d9f7a1d523831c7041d1d2" translate="yes" xml:space="preserve">
          <source>Actions invoked with &lt;code&gt;sendAction&lt;/code&gt; have the same currying behavior as demonstrated with &lt;code&gt;on-input&lt;/code&gt; above. For example:</source>
          <target state="translated">用 &lt;code&gt;sendAction&lt;/code&gt; 调用的动作具有与上面的 &lt;code&gt;on-input&lt;/code&gt; 所示的相同的周期性行为。例如：</target>
        </trans-unit>
        <trans-unit id="9dd2a9395182a0837e5a69ceb089926159b2de79" translate="yes" xml:space="preserve">
          <source>Activating a Canary Feature</source>
          <target state="translated">激活金丝雀功能</target>
        </trans-unit>
        <trans-unit id="38273a4f69f8fe135938b7cf85ee84ff3bcecc9e" translate="yes" xml:space="preserve">
          <source>Active CSS Class</source>
          <target state="translated">活动CSS类</target>
        </trans-unit>
        <trans-unit id="965c8c2299fd94833f9b672ad404956bad4b8f47" translate="yes" xml:space="preserve">
          <source>Ad Hoc Injections</source>
          <target state="translated">特别注射</target>
        </trans-unit>
        <trans-unit id="e6b4616c0b930c121c72c82e34550e44bce3ed0f" translate="yes" xml:space="preserve">
          <source>Adapter</source>
          <target state="translated">Adapter</target>
        </trans-unit>
        <trans-unit id="7b1c67e650668dc5c12c97e47344ef19be296223" translate="yes" xml:space="preserve">
          <source>Adapter Resolution</source>
          <target state="translated">适配器分辨率</target>
        </trans-unit>
        <trans-unit id="c23ed806f99e9163d07877e070940fd1a866b9a5" translate="yes" xml:space="preserve">
          <source>AdapterError</source>
          <target state="translated">AdapterError</target>
        </trans-unit>
        <trans-unit id="f8e64b89ee4585758e2437b11b782091a8c1c19d" translate="yes" xml:space="preserve">
          <source>AdapterPopulatedRecordArray</source>
          <target state="translated">AdapterPopulatedRecordArray</target>
        </trans-unit>
        <trans-unit id="381e6f2969f7ac5cc8e8450cfd8670f3522246c0" translate="yes" xml:space="preserve">
          <source>Adapters let you completely change how your API is implemented without impacting your Ember application code.</source>
          <target state="translated">适配器让你完全改变你的API实现方式而不影响你的Ember应用代码。</target>
        </trans-unit>
        <trans-unit id="cc9a7760101cd3e6a4bd47590a9a5d54bf1cbc35" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;await pauseTest();&lt;/code&gt; in your test code.</source>
          <target state="translated">添加一个 &lt;code&gt;await pauseTest();&lt;/code&gt; 在您的测试代码中。</target>
        </trans-unit>
        <trans-unit id="d30306e1b80780b8434ef1b39907be0a658b8dcf" translate="yes" xml:space="preserve">
          <source>Add an event listener</source>
          <target state="translated">添加一个事件监听器</target>
        </trans-unit>
        <trans-unit id="5b58e56f9360e98d1bf073d232c8e385133a2666" translate="yes" xml:space="preserve">
          <source>Add the following bookmark:</source>
          <target state="translated">添加以下书签:</target>
        </trans-unit>
        <trans-unit id="13be4fa81c316c889b22a98a584e5b3e01b4b1a6" translate="yes" xml:space="preserve">
          <source>Add the following code after the imports to our acceptance test:</source>
          <target state="translated">在导入到我们的验收测试后,添加以下代码。</target>
        </trans-unit>
        <trans-unit id="68f57af06da9563227acf6cc2a382d91ef1267e5" translate="yes" xml:space="preserve">
          <source>Add the objects in the passed array to the end of the array. Defers notifying observers of the change until all objects are added.</source>
          <target state="translated">将通过的数组中的对象添加到数组的末尾。推迟通知观察者这个变化,直到所有对象被添加。</target>
        </trans-unit>
        <trans-unit id="0efe1c0250f3fc188e6a8e3737351d8dca2b0ce1" translate="yes" xml:space="preserve">
          <source>Add the objects in the passed numerable to the end of the array. Defers notifying observers of the change until all objects are added.</source>
          <target state="translated">在数组的末尾添加传来的numerable中的对象。推迟通知观察者,直到所有对象都添加完毕。</target>
        </trans-unit>
        <trans-unit id="29f7f9468ccd168471a49cc00c77dd9437fadf66" translate="yes" xml:space="preserve">
          <source>Adding Data Attributes</source>
          <target state="translated">添加数据属性</target>
        </trans-unit>
        <trans-unit id="a46bd6a48506d37840e26e455b21f72457e13b3b" translate="yes" xml:space="preserve">
          <source>Adding Nested Routes</source>
          <target state="translated">添加嵌套路由</target>
        </trans-unit>
        <trans-unit id="bb915848f121656d8082caf271f5e286b5d703a8" translate="yes" xml:space="preserve">
          <source>Adding Objects</source>
          <target state="translated">添加对象</target>
        </trans-unit>
        <trans-unit id="fbf5e48b6a9cd3118543626736e3af2ed0bf0b8f" translate="yes" xml:space="preserve">
          <source>Adding Your Application Goals as Acceptance Tests</source>
          <target state="translated">将您的申请目标添加为验收测试</target>
        </trans-unit>
        <trans-unit id="86b41c8a927c8c5a757118ad1ffaf3f422c6de5a" translate="yes" xml:space="preserve">
          <source>Adding a Banner with Navigation</source>
          <target state="translated">添加一个带导航的横幅</target>
        </trans-unit>
        <trans-unit id="7907b3231eba85b6e9a0d3e1a77b8c0e0b253aa8" translate="yes" xml:space="preserve">
          <source>Adding a breakpoint</source>
          <target state="translated">增加一个断点</target>
        </trans-unit>
        <trans-unit id="75af891187566cd5974854a2145ffd749735c23c" translate="yes" xml:space="preserve">
          <source>Adding a label to an input element</source>
          <target state="translated">为输入元素添加标签</target>
        </trans-unit>
        <trans-unit id="5e4c7f27c3bc07ce79145dc9d90e9c65138713e1" translate="yes" xml:space="preserve">
          <source>Adding a single property that is not an array will just add it in the array:</source>
          <target state="translated">添加一个不是数组的单项属性,只是将其添加到数组中。</target>
        </trans-unit>
        <trans-unit id="961b1847cb50852ed3ea64456047c5d703ca8190" translate="yes" xml:space="preserve">
          <source>Adding additional attributes on a link</source>
          <target state="translated">在链接上添加附加属性</target>
        </trans-unit>
        <trans-unit id="7a1dec12e5bd06e88edffee0dd45da20527d5fc2" translate="yes" xml:space="preserve">
          <source>Adding arguments to action callbacks:</source>
          <target state="translated">为动作回调添加参数。</target>
        </trans-unit>
        <trans-unit id="014b5a0a8439fb714c677ef423ab10b27d2ab8e2" translate="yes" xml:space="preserve">
          <source>Adding event handlers to elements (when used as a modifier):</source>
          <target state="translated">为元素添加事件处理程序(当作为修饰符使用时)。</target>
        </trans-unit>
        <trans-unit id="238f58072f55a746c0c6427be164278d95ececaa" translate="yes" xml:space="preserve">
          <source>Adding explicit injections in general is a highly recommended practice.</source>
          <target state="translated">一般情况下,增加明确的注射是一种非常值得推荐的做法。</target>
        </trans-unit>
        <trans-unit id="fbef15dbce6c895851b8526e25a336b3def8281b" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;static&lt;/code&gt; keyword to a class element definition puts it on the &lt;em&gt;class&lt;/em&gt; itself, instead of instances:</source>
          <target state="translated">在类元素定义中添加 &lt;code&gt;static&lt;/code&gt; 关键字会将其放置在&lt;em&gt;类&lt;/em&gt;本身上，而不是实例上：</target>
        </trans-unit>
        <trans-unit id="e2eb56110c25a5dfc7c53bd0e0fb918c3c99c20e" translate="yes" xml:space="preserve">
          <source>Adding the Rental To Our Template</source>
          <target state="translated">在我们的模板上添加租赁</target>
        </trans-unit>
        <trans-unit id="84afde926b540b2f7f426749497948e02d4b57b2" translate="yes" xml:space="preserve">
          <source>Additional resources:</source>
          <target state="translated">其他资源:</target>
        </trans-unit>
        <trans-unit id="fc881ca94ae041edddea26c0df1a4f655bbb2bb8" translate="yes" xml:space="preserve">
          <source>Additionally a helper can be called as a nested helper (sometimes called a subexpression). In this example, the computed value of a helper is passed to a component named &lt;code&gt;show-money&lt;/code&gt;:</source>
          <target state="translated">另外，可以将帮助程序称为嵌套帮助程序（有时称为子表达式）。在此示例中，助手的计算值传递给名为 &lt;code&gt;show-money&lt;/code&gt; 的组件：</target>
        </trans-unit>
        <trans-unit id="09683c9869179610982cef3cb6331d7ae0d62eb5" translate="yes" xml:space="preserve">
          <source>Additionally a helper can be called as a nested helper. In this example, we show the formatted currency value if the &lt;code&gt;showMoney&lt;/code&gt; named argument is truthy.</source>
          <target state="translated">另外，可以将帮助程序称为嵌套帮助程序。在此示例中，如果 &lt;code&gt;showMoney&lt;/code&gt; 命名参数为true ，则显示格式化的货币值。</target>
        </trans-unit>
        <trans-unit id="7dc2b7d3e370a211f92cf1b5d003a240af3bd462" translate="yes" xml:space="preserve">
          <source>Additionally you can &lt;code&gt;yield&lt;/code&gt; properties into the context for use by the consumer:</source>
          <target state="translated">此外，您可以 &lt;code&gt;yield&lt;/code&gt; 性能成由消费者使用情境：</target>
        </trans-unit>
        <trans-unit id="84d8720737180b39ffa90df8c9aac2f8c5c75e43" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;args&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; mutable, and is frozen in development modes. This is partially to prevent folks from trying to accomplish two-way bindings (which doesn't work, this is discussed in more detail below) and partially to ensure that &lt;code&gt;args&lt;/code&gt; always stays in sync with the arguments passed to the component, so it can be the canonical &quot;single source of truth&quot;. If you want to provide defaults to an argument, you should use a getter.</source>
          <target state="translated">此外， &lt;code&gt;args&lt;/code&gt; 是&lt;em&gt;不会&lt;/em&gt;变的，而且是在发展模式冻结。这部分是为了防止人们尝试完成双向绑定（这是行不通的，下面将对此进行详细讨论），部分是确保 &lt;code&gt;args&lt;/code&gt; 始终与传递给组件的参数保持同步，因此可以成为规范的&amp;ldquo;真理的单一来源&amp;rdquo;。如果要为参数提供默认值，则应使用getter。</target>
        </trans-unit>
        <trans-unit id="bb3b1f7bd23ed7ecbacd0d8766335c2e64464779" translate="yes" xml:space="preserve">
          <source>Additionally, certain Ember objects still require the use of &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;, such as &lt;code&gt;ObjectProxy&lt;/code&gt; and &lt;code&gt;ArrayProxy&lt;/code&gt;. These will continue to function with tracked, but you &lt;em&gt;must&lt;/em&gt; use &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. Likewise, KVO methods on Ember's &lt;code&gt;Enumerable&lt;/code&gt; class, such as &lt;code&gt;objectAt&lt;/code&gt; and &lt;code&gt;pushObject&lt;/code&gt;, and the various implementations of it will &lt;em&gt;generally&lt;/em&gt; continue to be tracked.</source>
          <target state="translated">此外，某些Ember对象仍然需要使用 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; ，例如 &lt;code&gt;ObjectProxy&lt;/code&gt; 和 &lt;code&gt;ArrayProxy&lt;/code&gt; 。这些将继续运行并具有跟踪功能，但是您&lt;em&gt;必须&lt;/em&gt;使用 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 。同样，Ember的 &lt;code&gt;Enumerable&lt;/code&gt; 类上的KVO方法（例如 &lt;code&gt;objectAt&lt;/code&gt; 和 &lt;code&gt;pushObject&lt;/code&gt; ）及其各种实现&lt;em&gt;通常&lt;/em&gt;将继续被跟踪。</target>
        </trans-unit>
        <trans-unit id="fb1b6e0c9ed4043e184646f1976b2c49188e9088" translate="yes" xml:space="preserve">
          <source>Additionally, class helpers can call &lt;code&gt;recompute&lt;/code&gt; to force a new computation.</source>
          <target state="translated">此外，类助手可以调用 &lt;code&gt;recompute&lt;/code&gt; 以强制进行新的计算。</target>
        </trans-unit>
        <trans-unit id="aff8c2a0852aaa3dedd9b762f5dfaf585b559da0" translate="yes" xml:space="preserve">
          <source>Additionally, if you try to set the model of an &lt;code&gt;Ember.ArrayController&lt;/code&gt; to a plain native array, it will raise an exception since it no longer implements the &lt;code&gt;Ember.Array&lt;/code&gt; interface.</source>
          <target state="translated">此外，如果尝试将 &lt;code&gt;Ember.ArrayController&lt;/code&gt; 的模型设置为纯本机数组，则由于它不再实现 &lt;code&gt;Ember.Array&lt;/code&gt; 接口，因此将引发异常。</target>
        </trans-unit>
        <trans-unit id="06fd6762790bb2f63ab0bf1fbfa1923a15db1e1a" translate="yes" xml:space="preserve">
          <source>Additionally, it causes less churn to decide to implement basic accessibility considerations at the start of the project, than trying to add it on later or pivoting mid-project. Semantic HTML doesn't take any additional time to write than non-semantic markup, provides a lower cognitive burden for development, typically produces less markup which will help an application be more performant, and is better for SEO.</source>
          <target state="translated">此外,与试图在项目后期添加或在项目中期调整相比,在项目开始时就决定实施基本的可访问性考虑因素,会造成较少的流失。与非语义标记相比,语义HTML不需要任何额外的时间来编写,为开发提供了较低的认知负担,通常会产生较少的标记,这将有助于提高应用程序的性能,并且更有利于SEO。</target>
        </trans-unit>
        <trans-unit id="614b01d739cbbf475bc18a379a6da866937a8964" translate="yes" xml:space="preserve">
          <source>Additionally, since the component isn't instantiated until the block content is rendered, we can add arguments within the block. In this case we'll add a text style option which will dictate the style of the body text we want in our post. When &lt;code&gt;{{post.body}}&lt;/code&gt; is instantiated, it will have both the &lt;code&gt;editStyle&lt;/code&gt; and &lt;code&gt;postData&lt;/code&gt; given by its wrapping component, as well as the &lt;code&gt;bodyStyle&lt;/code&gt; declared in the template.</source>
          <target state="translated">此外，由于在呈现块内容之前不会实例化该组件，因此我们可以在块内添加参数。在这种情况下，我们将添加一个文本样式选项，该选项将决定我们想要的帖子正文样式。当 &lt;code&gt;{{post.body}}&lt;/code&gt; 实例化时，将同时拥有 &lt;code&gt;editStyle&lt;/code&gt; 和 &lt;code&gt;postData&lt;/code&gt; 其包装组件给出，还有 &lt;code&gt;bodyStyle&lt;/code&gt; 模板声明。</target>
        </trans-unit>
        <trans-unit id="f0bc0d6c761728ed6eb684dcbbdb607b74c8e87f" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;mut&lt;/code&gt; helper can be combined with the &lt;code&gt;action&lt;/code&gt; helper to mutate a value. For example:</source>
          <target state="translated">另外，可以将 &lt;code&gt;mut&lt;/code&gt; helper与 &lt;code&gt;action&lt;/code&gt; helper 结合使用以对值进行突变。例如：</target>
        </trans-unit>
        <trans-unit id="69b34585bfd0f9f9d781705ff2180e2bef8489c3" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;mut&lt;/code&gt; helper can be combined with the &lt;code&gt;fn&lt;/code&gt; helper to mutate a value. For example:</source>
          <target state="translated">另外，可以将 &lt;code&gt;mut&lt;/code&gt; helper与 &lt;code&gt;fn&lt;/code&gt; helper结合使用以对值进行突变。例如：</target>
        </trans-unit>
        <trans-unit id="720976c9268821443e37ad99700c74bf4f06c7b7" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;mut&lt;/code&gt; helper generally can't be used for the same reason:</source>
          <target state="translated">此外，出于相同原因，通常不能使用 &lt;code&gt;mut&lt;/code&gt; helper：</target>
        </trans-unit>
        <trans-unit id="ff38fbaef4688ee36ebaf956ca46ea7564c61799" translate="yes" xml:space="preserve">
          <source>Additionally, to retrieve the first and last objects in an array in an observable fashion, you should use &lt;code&gt;myArray.get('firstObject')&lt;/code&gt; and &lt;code&gt;myArray.get('lastObject')&lt;/code&gt;, respectively.</source>
          <target state="translated">此外，要以可观察的方式检索数组中的第一个和最后一个对象，应分别使用 &lt;code&gt;myArray.get('firstObject')&lt;/code&gt; 和 &lt;code&gt;myArray.get('lastObject')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e5d0b1302110e26dae48d761f60bb9682109f97" translate="yes" xml:space="preserve">
          <source>Additionally, you can also pass in a &lt;code&gt;model&lt;/code&gt; argument that will be set as the engines model. This can be an existing object:</source>
          <target state="translated">此外，您还可以传入将被设置为引擎模型的 &lt;code&gt;model&lt;/code&gt; 参数。这可以是现有对象：</target>
        </trans-unit>
        <trans-unit id="3e91e7b78e6370c74b0939a3277d0018c3be62f0" translate="yes" xml:space="preserve">
          <source>Additionally, you will have to continue using &lt;em&gt;accessor&lt;/em&gt; functions for arrays if you want arrays to update as expected. These functions are covered in more detail in the &lt;a href=&quot;https://guides.emberjs.com/components/looping-through-lists/&quot;&gt;Looping Through Lists&lt;/a&gt; guide.</source>
          <target state="translated">此外，如果要按预期更新阵列，则必须继续对阵列使用&lt;em&gt;访问器&lt;/em&gt;函数。这些功能在&amp;ldquo;&lt;a href=&quot;https://guides.emberjs.com/components/looping-through-lists/&quot;&gt;循环遍历列表&amp;rdquo;&lt;/a&gt;指南中有更详细的介绍。</target>
        </trans-unit>
        <trans-unit id="f32c2dbcf34398cc50e6a6697df547ab5ac9a6bc" translate="yes" xml:space="preserve">
          <source>Addons</source>
          <target state="translated">Addons</target>
        </trans-unit>
        <trans-unit id="2411a924cd0f94fc35324331e68f85ad745420cc" translate="yes" xml:space="preserve">
          <source>Addons are JavaScript packages that integrate with Ember. For example, &lt;a href=&quot;https://github.com/adopted-ember-addons/ember-cli-sass&quot;&gt;&lt;code&gt;ember-cli-sass&lt;/code&gt;&lt;/a&gt; is an addon that allows you to use SASS/SCSS in your applications. You can install it using the Ember CLI with the following command:</source>
          <target state="translated">附加组件是与Ember集成的JavaScript软件包。例如，&lt;a href=&quot;https://github.com/adopted-ember-addons/ember-cli-sass&quot;&gt; &lt;code&gt;ember-cli-sass&lt;/code&gt; &lt;/a&gt;是允许您在应用程序中使用SASS / SCSS的插件。您可以使用Ember CLI通过以下命令进行安装：</target>
        </trans-unit>
        <trans-unit id="838e38c65403d79db60dcc3e55c156ab7110af36" translate="yes" xml:space="preserve">
          <source>Adds an array observer to the receiving array. The array observer object normally must implement two methods:</source>
          <target state="translated">为接收数组添加一个数组观察者。数组观察者对象通常必须实现两个方法。</target>
        </trans-unit>
        <trans-unit id="0ad9f3590163f2505aed3ffe90e450b29bdb9ba0" translate="yes" xml:space="preserve">
          <source>Adds an observer on a property.</source>
          <target state="translated">在属性上添加一个观察者。</target>
        </trans-unit>
        <trans-unit id="9bb27d5e0611cced09effb7935991fe177224108" translate="yes" xml:space="preserve">
          <source>Adds each object in the passed array to the receiver.</source>
          <target state="translated">将传入的数组中的每个对象添加到接收器中。</target>
        </trans-unit>
        <trans-unit id="07b8f978e5c477465a6baeff452966da87c1e3f5" translate="yes" xml:space="preserve">
          <source>Adds each object in the passed enumerable to the receiver.</source>
          <target state="translated">将传入的枚举对象中的每个对象添加到接收器中。</target>
        </trans-unit>
        <trans-unit id="c9c6a3d472cf059b5a0ab4b9951d7e76bd529bf2" translate="yes" xml:space="preserve">
          <source>Adds identifiers to the &lt;code&gt;RecordArray&lt;/code&gt; without duplicates</source>
          <target state="translated">将标识符添加到 &lt;code&gt;RecordArray&lt;/code&gt; 而不重复</target>
        </trans-unit>
        <trans-unit id="818f401e00e97f49fd796b6b2e9da04207c31113" translate="yes" xml:space="preserve">
          <source>Adds the named objects to the beginning of the array. Defers notifying observers until all objects have been added.</source>
          <target state="translated">将命名的对象添加到数组的开头。推迟通知观察者,直到所有对象被添加。</target>
        </trans-unit>
        <trans-unit id="3c5e5d99dd32a203dcc72a428b5b6629786bd068" translate="yes" xml:space="preserve">
          <source>Adds the passed target/method and any optional arguments to the named queue to be executed at the end of the RunLoop. If you have not already started a RunLoop when calling this method one will be started for you automatically.</source>
          <target state="translated">将传递的目标/方法和任何可选的参数添加到命名的队列中,以便在RunLoop结束时执行。如果你在调用本方法时还没有启动RunLoop,那么将自动为你启动一个RunLoop。</target>
        </trans-unit>
        <trans-unit id="1dca87d49eb6bfa992ae0a731eefcd208543b8d6" translate="yes" xml:space="preserve">
          <source>Advance to the next level</source>
          <target state="translated">更上一层楼</target>
        </trans-unit>
        <trans-unit id="66931511954ef5ba588177fe993eecfba55f8306" translate="yes" xml:space="preserve">
          <source>Advanced Example</source>
          <target state="translated">高级示例</target>
        </trans-unit>
        <trans-unit id="186b4c5c3b7976b349d51e4508670ebdde03183d" translate="yes" xml:space="preserve">
          <source>Advanced Example:</source>
          <target state="translated">先进的例子。</target>
        </trans-unit>
        <trans-unit id="aeed9b4c741b5cb4e55f198c89190812e9900514" translate="yes" xml:space="preserve">
          <source>Advanced Usage:</source>
          <target state="translated">高级用法。</target>
        </trans-unit>
        <trans-unit id="a6a21e5c434254c6803b80cd6fc8d57bcbe220ac" translate="yes" xml:space="preserve">
          <source>Advanced: Class Helpers</source>
          <target state="translated">高级。班级助手</target>
        </trans-unit>
        <trans-unit id="a5215acd515beaa16e202387d73fa33b51b6a698" translate="yes" xml:space="preserve">
          <source>After a component successfully renders its backing HTML element into the DOM, it will trigger its &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement&quot;&gt;&lt;code&gt;didInsertElement()&lt;/code&gt;&lt;/a&gt; hook.</source>
          <target state="translated">在组件成功将其支持HTML元素呈现到DOM中之后，它将触发其&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement&quot;&gt; &lt;code&gt;didInsertElement()&lt;/code&gt; &lt;/a&gt;挂钩。</target>
        </trans-unit>
        <trans-unit id="5202159cfac89de0f36afb291d224809df2dbeac" translate="yes" xml:space="preserve">
          <source>After a few seconds, you should see output that looks like this:</source>
          <target state="translated">几秒钟后,你应该看到这样的输出。</target>
        </trans-unit>
        <trans-unit id="c3da6b85eaa54589f8ced34a483e30ea26758f57" translate="yes" xml:space="preserve">
          <source>After fixing a deprecation and getting your scenarios working again, you might want to leave the deprecation message in the workflow file with the throw handler enabled. This will ensure you haven't missed anything, and ensure no new deprecated calls of that type are introduced to your project. Next, it's just a matter of going down the list, updating the handler, and fixing each remaining deprecation.</source>
          <target state="translated">在修复了弃用问题并使你的方案重新工作后,你可能想在工作流文件中留下弃用信息,并启用抛出处理程序。这将确保你没有遗漏任何东西,并确保没有新的该类型的废弃调用被引入到你的项目中。接下来,就只需要往下看,更新处理程序,并修复剩余的弃用信息。</target>
        </trans-unit>
        <trans-unit id="e8a563a03588b4ce19824d10483066c169e84711" translate="yes" xml:space="preserve">
          <source>After reading it, &lt;code&gt;meta.total&lt;/code&gt; can be used to calculate how many pages of posts you'll have.</source>
          <target state="translated">阅读后， &lt;code&gt;meta.total&lt;/code&gt; 可以用于计算您将拥有多少页面。</target>
        </trans-unit>
        <trans-unit id="acfbbd52bbbb4ced17ca3ce859f416e93cba3255" translate="yes" xml:space="preserve">
          <source>After refreshing, Ember Data will appropriately look up the &quot;post&quot; model.</source>
          <target state="translated">刷新后,微光数据会适当查询 &quot;岗位 &quot;模型。</target>
        </trans-unit>
        <trans-unit id="8e61b4bb84fed97f4f7b6123711e139bd5112710" translate="yes" xml:space="preserve">
          <source>After saving a new post successfully, a user is then shown the list of prior posts.</source>
          <target state="translated">在成功保存一个新帖子后,用户就会看到之前的帖子列表。</target>
        </trans-unit>
        <trans-unit id="235f56f22416c84a49c97407d786c0884e7cf673" translate="yes" xml:space="preserve">
          <source>After starting the server we should now see some end to end maps functionality show up on our front page!</source>
          <target state="translated">启动服务器后,我们现在应该可以看到一些端到端的地图功能显示在我们的首页上了!</target>
        </trans-unit>
        <trans-unit id="98d297497aa50ba76e205142532b5510d9c48570" translate="yes" xml:space="preserve">
          <source>After updating our mirage configuration, we should see a simple filter on the home screen that will update the rental list as you type:</source>
          <target state="translated">更新了我们的海市蜃楼配置后,我们应该会在主屏幕上看到一个简单的过滤器,它会随着你的输入更新租赁列表。</target>
        </trans-unit>
        <trans-unit id="19ad05f957b79b38ceb81dd6312675b3cd75ce1c" translate="yes" xml:space="preserve">
          <source>After you have defined a model class, you can start &lt;a href=&quot;../finding-records&quot;&gt;finding&lt;/a&gt; and &lt;a href=&quot;../creating-updating-and-deleting-records&quot;&gt;working with records&lt;/a&gt; of that type.</source>
          <target state="translated">定义模型类后，就可以开始&lt;a href=&quot;../finding-records&quot;&gt;查找&lt;/a&gt;并&lt;a href=&quot;../creating-updating-and-deleting-records&quot;&gt;使用&lt;/a&gt;该类型的记录。</target>
        </trans-unit>
        <trans-unit id="13f2d652f70945cb85fc5562fc3600a535ffb359" translate="yes" xml:space="preserve">
          <source>After:</source>
          <target state="translated">After:</target>
        </trans-unit>
        <trans-unit id="f1cd78ce91ac71db82cb5bb2b15ba7b56dad3762" translate="yes" xml:space="preserve">
          <source>Afterwards we add a further initializer named &lt;code&gt;pre&lt;/code&gt;, this time specifying that it should run before the initializer named &lt;code&gt;first&lt;/code&gt;:</source>
          <target state="translated">之后，我们添加另一个名为 &lt;code&gt;pre&lt;/code&gt; 的初始化器，这次指定它应该在名为 &lt;code&gt;first&lt;/code&gt; 的初始化器之前运行：</target>
        </trans-unit>
        <trans-unit id="114f0fdf38dcb7f9f7e8fbac3f9f386224c4f06f" translate="yes" xml:space="preserve">
          <source>Afterwards, we can refactor the initial components.</source>
          <target state="translated">之后,我们可以对初始组件进行重构。</target>
        </trans-unit>
        <trans-unit id="abc0ed35fab8b9af4bc688962a9cd85ef53ae193" translate="yes" xml:space="preserve">
          <source>Again, note that these features will continue to work for apps that need them. An edition is not a breaking change, just a minor release. But for someone starting a new Ember app today, this is complexity they can safely skip learning.</source>
          <target state="translated">再次注意,这些功能将继续为需要它们的应用程序工作。一个版本不是一个突破性的变化,只是一个小的版本。但对于今天开始使用新的Ember应用的人来说,这是他们可以安全地跳过学习的复杂性。</target>
        </trans-unit>
        <trans-unit id="3eb065953fd69ec084a86ff8a162790324b40790" translate="yes" xml:space="preserve">
          <source>Again, the two components look similar. The first component has an &lt;code&gt;is-active&lt;/code&gt; class, while the second a &lt;code&gt;current-user&lt;/code&gt; class. How should we unify the components into one?</source>
          <target state="translated">同样，这两个组件看起来相似。第一个组件具有 &lt;code&gt;is-active&lt;/code&gt; 类，而第二个组件具有 &lt;code&gt;current-user&lt;/code&gt; 类。我们应该如何将这些组件统一为一个组件？</target>
        </trans-unit>
        <trans-unit id="626d0adc94dcedaf3af61d87e54f26c480c7bd5c" translate="yes" xml:space="preserve">
          <source>Aggregate Information (Every or Any)</source>
          <target state="translated">汇总信息(每个或任何)</target>
        </trans-unit>
        <trans-unit id="70de51fa75e9edd99e6b4963a49d84a2bf27b1ce" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;mapBy&lt;/code&gt;</source>
          <target state="translated">别名 &lt;code&gt;mapBy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d000f39170991f1fd43318c904daa38dd3efa366" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;mapBy&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mapBy&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="bf6896081e96ffaab61b811f72dddb265a71d05a" translate="yes" xml:space="preserve">
          <source>Alias for jQuery</source>
          <target state="translated">jQuery的别称</target>
        </trans-unit>
        <trans-unit id="e209a5d4078b378b87ac5499ddf7812b6b95e027" translate="yes" xml:space="preserve">
          <source>All Ember Data classes, methods and functions are defined inside of this namespace.</source>
          <target state="translated">所有的Ember Data类、方法和函数都定义在这个命名空间内。</target>
        </trans-unit>
        <trans-unit id="3698aeba7ff5a69d3c6f22b01d9c336e6bef20fc" translate="yes" xml:space="preserve">
          <source>All assets located in the &lt;code&gt;public/&lt;/code&gt; folder will be copied as is to the final output directory, &lt;code&gt;dist/&lt;/code&gt;.</source>
          <target state="translated">位于 &lt;code&gt;public/&lt;/code&gt; 文件夹中的所有资产都将原样复制到最终输出目录 &lt;code&gt;dist/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd8aae95d9b2813640907de0ca9b623b6dbcba4e" translate="yes" xml:space="preserve">
          <source>All ember models have an id property. This is an identifier managed by an external source. These are always coerced to be strings before being used internally. Note when declaring the attributes for a model it is an error to declare an id attribute.</source>
          <target state="translated">所有的微光蛋模型都有一个id属性。这是一个由外部来源管理的标识符。在内部使用之前,这些总是被强制为字符串。注意当声明一个模型的属性时,声明一个id属性是错误的。</target>
        </trans-unit>
        <trans-unit id="3486d672b565e38796bbf374c641258f59a55692" translate="yes" xml:space="preserve">
          <source>All enumerables expose &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#property_firstObject&quot;&gt;&lt;code&gt;firstObject&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#property_lastObject&quot;&gt;&lt;code&gt;lastObject&lt;/code&gt;&lt;/a&gt; properties that you can bind to.</source>
          <target state="translated">所有可枚举都公开您可以绑定到的&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#property_firstObject&quot;&gt; &lt;code&gt;firstObject&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#property_lastObject&quot;&gt; &lt;code&gt;lastObject&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="0926465db0dcb951cc1f0003cb0577400b2d4022" translate="yes" xml:space="preserve">
          <source>All examples in this guide follow QUnit. Rest assured, the best practices for testing that we present in this guide are independent of your choice of testing framework. Keep in mind, the setup functions from &lt;a href=&quot;https://github.com/emberjs/ember-qunit&quot;&gt;ember-qunit&lt;/a&gt;&amp;mdash;&lt;code&gt;setupTest&lt;/code&gt;, &lt;code&gt;setupRenderingTest&lt;/code&gt;, and &lt;code&gt;setupApplicationTest&lt;/code&gt;&amp;mdash;need to be replaced with those from &lt;a href=&quot;https://github.com/emberjs/ember-mocha&quot;&gt;ember-mocha&lt;/a&gt;.</source>
          <target state="translated">本指南中的所有示例均遵循QUnit。请放心，我们在本指南中介绍的最佳测试实践独立于您选择的测试框架。请记住，需要将&lt;a href=&quot;https://github.com/emberjs/ember-qunit&quot;&gt;ember-qunit中&lt;/a&gt;的设置功能（ &lt;code&gt;setupTest&lt;/code&gt; ， &lt;code&gt;setupRenderingTest&lt;/code&gt; 和 &lt;code&gt;setupApplicationTest&lt;/code&gt; )替换为&lt;a href=&quot;https://github.com/emberjs/ember-mocha&quot;&gt;ember-mocha的功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4d7744eabcb9058f40daea2a118601b2428e49c" translate="yes" xml:space="preserve">
          <source>All interactive elements must have an accessible name. But what does that mean, exactly?</source>
          <target state="translated">所有的交互式元素都必须有一个可访问的名字。但这到底是什么意思呢?</target>
        </trans-unit>
        <trans-unit id="f7a9be30367f4a27730e81fbccce7fd0aad0bcd4" translate="yes" xml:space="preserve">
          <source>All of the Ember.js conveniences are available for modifying attributes. For example, you can use &lt;code&gt;Ember.Object&lt;/code&gt;'s &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_incrementProperty&quot;&gt;&lt;code&gt;incrementProperty&lt;/code&gt;&lt;/a&gt; helper:</source>
          <target state="translated">所有的Ember.js便利都可用于修改属性。例如，可以使用 &lt;code&gt;Ember.Object&lt;/code&gt; 的&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_incrementProperty&quot;&gt; &lt;code&gt;incrementProperty&lt;/code&gt; &lt;/a&gt;属性帮助器：</target>
        </trans-unit>
        <trans-unit id="6bc42e572e5de321dbd2d066b83cbd5d2ec99a88" translate="yes" xml:space="preserve">
          <source>All of the event handling approaches described above respond to the same set of events. The names of the built-in events are listed below. (The hash of built-in events exists in &lt;code&gt;Ember.EventDispatcher&lt;/code&gt;.) Additional, custom events can be registered by using &lt;code&gt;Ember.Application.customEvents&lt;/code&gt;.</source>
          <target state="translated">上述所有事件处理方法都响应同一组事件。内置事件的名称在下面列出。（内置事件的哈希存在于 &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; 中。）另外，可以使用 &lt;code&gt;Ember.Application.customEvents&lt;/code&gt; 注册自定义事件。</target>
        </trans-unit>
        <trans-unit id="46e22ed99a22840595b1de896dbcc655416932c3" translate="yes" xml:space="preserve">
          <source>All our &lt;code&gt;SystemPreferencesEditor&lt;/code&gt; component really needs to process a user deletion is an account ID. For this case, the &lt;code&gt;fn&lt;/code&gt; helper provides the value via partial application to allow a parent component to dig into the passed object to pull out only what it needs.</source>
          <target state="translated">我们所有需要处理用户删除操作的 &lt;code&gt;SystemPreferencesEditor&lt;/code&gt; 组件实际上都是一个帐户ID。对于这种情况， &lt;code&gt;fn&lt;/code&gt; 帮助程序通过部分应用程序提供了该值，以允许父组件挖掘所传递的对象以仅提取其需要的对象。</target>
        </trans-unit>
        <trans-unit id="229c0c6ae7ddf3e9e24fb42c05923cbeb93f534f" translate="yes" xml:space="preserve">
          <source>All our &lt;code&gt;system-preferences-editor&lt;/code&gt; component really needs to process a user deletion is an account ID. For this case, the action helper provides the &lt;code&gt;value&lt;/code&gt; attribute to allow a parent component to dig into the passed object to pull out only what it needs.</source>
          <target state="translated">我们处理用户删除所需的所有 &lt;code&gt;system-preferences-editor&lt;/code&gt; 组件实际上都是一个帐户ID。对于这种情况，动作帮助器提供了 &lt;code&gt;value&lt;/code&gt; 属性，以允许父组件深入传递的对象以仅提取其需要的对象。</target>
        </trans-unit>
        <trans-unit id="a86c6bb7f6d22f1e653e780827b3ff7ed83481b8" translate="yes" xml:space="preserve">
          <source>All parameters are optional. The function should return &lt;code&gt;true&lt;/code&gt; to include the item in the results, and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">所有参数都是可选的。该函数应返回 &lt;code&gt;true&lt;/code&gt; ,以将项目包括在结果中，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a787c960fc606e377560ffac4417e44624088fc" translate="yes" xml:space="preserve">
          <source>All params are optional. The method should return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">所有参数都是可选的。该方法应返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d01f87b07aec86e2d4e07c2a66e7e783b689f3f" translate="yes" xml:space="preserve">
          <source>All style assets added this way will be concatenated and output as &lt;code&gt;/assets/vendor-823a77210dbe57c0736fbbda596cb84f.css&lt;/code&gt;.</source>
          <target state="translated">以这种方式添加的所有样式资产将被串联并输出为 &lt;code&gt;/assets/vendor-823a77210dbe57c0736fbbda596cb84f.css&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="718cc7b8864472ef4e74b1ea16436f4fc7ff3d96" translate="yes" xml:space="preserve">
          <source>All style assets added this way will be concatenated and output as &lt;code&gt;/assets/vendor.css&lt;/code&gt;.</source>
          <target state="translated">以这种方式添加的所有样式资产将被串联并输出为 &lt;code&gt;/assets/vendor.css&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f16b71ca628fe8405ecbd9361993f54c50fc073b" translate="yes" xml:space="preserve">
          <source>All third-party assets, included either manually in &lt;code&gt;vendor/&lt;/code&gt; or via a package manager like Bower, must be added via &lt;code&gt;import()&lt;/code&gt;.</source>
          <target state="translated">所有第三方资产（包括在 &lt;code&gt;vendor/&lt;/code&gt; 或通过包管理器（如Bower）手动包含）必须通过 &lt;code&gt;import()&lt;/code&gt; 添加。</target>
        </trans-unit>
        <trans-unit id="d2180ccdea1ed0c1ef5a5028b5fe7fe6b47fd2c8" translate="yes" xml:space="preserve">
          <source>All third-party assets, included either manually in &lt;code&gt;vendor/&lt;/code&gt; or via a package manager like npm, must be added via &lt;code&gt;app.import()&lt;/code&gt;.</source>
          <target state="translated">必须通过 &lt;code&gt;app.import()&lt;/code&gt; 添加所有第三方资产（包括在 &lt;code&gt;vendor/&lt;/code&gt; 或通过软件包管理器（如npm）手动添加）。</target>
        </trans-unit>
        <trans-unit id="9bf786e288505f7c89875c65f38709ab6e7774d0" translate="yes" xml:space="preserve">
          <source>All we want to do when a user visits the root (&lt;code&gt;/&lt;/code&gt;) URL is transition to &lt;code&gt;/rentals&lt;/code&gt;. To do this we will add code to our index route handler by implementing a route lifecycle hook, called &lt;code&gt;beforeModel&lt;/code&gt;.</source>
          <target state="translated">当用户访问根（ &lt;code&gt;/&lt;/code&gt; ）URL 时，我们要做的就是过渡到 &lt;code&gt;/rentals&lt;/code&gt; 。为此，我们将通过实现称为 &lt;code&gt;beforeModel&lt;/code&gt; 的路由生命周期钩子，将代码添加到索引路由处理程序中。</target>
        </trans-unit>
        <trans-unit id="9eeaa2e6065909ce6be50386af9debc71d210cc6" translate="yes" xml:space="preserve">
          <source>Allow registering options for all factories of a type.</source>
          <target state="translated">允许注册一个类型的所有工厂的选项。</target>
        </trans-unit>
        <trans-unit id="fd31d681ad2597760c29143eaee7f311d122c3ee" translate="yes" xml:space="preserve">
          <source>Allowing Default Action</source>
          <target state="translated">允许默认动作</target>
        </trans-unit>
        <trans-unit id="6e08a097c0ce32e8ba1e1d6b95a4b1a44cc0234c" translate="yes" xml:space="preserve">
          <source>Allowing Default Browser Action</source>
          <target state="translated">允许默认浏览器操作</target>
        </trans-unit>
        <trans-unit id="225e76fc1cc7d4b77c063f838f10b18b298b1023" translate="yes" xml:space="preserve">
          <source>Allowing Modifier Keys</source>
          <target state="translated">允许使用修饰键</target>
        </trans-unit>
        <trans-unit id="5539cdfc08868b3d1b8aa4cec0319ad286612a49" translate="yes" xml:space="preserve">
          <source>Allows for runtime registration of handler functions that override the default deprecation behavior. Deprecations are invoked by calls to &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/@ember%2Fdebug/methods#deprecate&quot;&gt;@ember/debug/deprecate&lt;/a&gt;. The following example demonstrates its usage by registering a handler that throws an error if the message contains the word &quot;should&quot;, otherwise defers to the default handler.</source>
          <target state="translated">允许在处理程序函数上进行运行时注册，这些处理程序函数将覆盖默认的弃用行为。通过调用&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/@ember%2Fdebug/methods#deprecate&quot;&gt;@ ember / debug / deprecate&lt;/a&gt;来调用弃用。下面的示例通过注册一个处理程序来演示其用法，如果该处理程序在消息中包含单词&amp;ldquo; should&amp;rdquo;，则抛出该错误，否则将遵循默认处理程序。</target>
        </trans-unit>
        <trans-unit id="6992de9a0552f0a40afb55475fda253a35b85c36" translate="yes" xml:space="preserve">
          <source>Allows for runtime registration of handler functions that override the default deprecation behavior. Deprecations are invoked by calls to &lt;a href=&quot;https://emberjs.com/api/classes/Ember.html#method_deprecate&quot;&gt;Ember.deprecate&lt;/a&gt;. The following example demonstrates its usage by registering a handler that throws an error if the message contains the word &quot;should&quot;, otherwise defers to the default handler.</source>
          <target state="translated">允许处理程序函数在运行时注册，这些处理程序函数将覆盖默认的弃用行为。通过调用&lt;a href=&quot;https://emberjs.com/api/classes/Ember.html#method_deprecate&quot;&gt;Ember.deprecate&lt;/a&gt;来调用不推荐使用。下面的示例通过注册一个处理程序来演示其用法，如果消息中包含单词&amp;ldquo; should&amp;rdquo;，该处理程序将引发错误，否则将遵循默认处理程序。</target>
        </trans-unit>
        <trans-unit id="dba10f2663bbb76e24470fcd8ecfd8c5d8ab476d" translate="yes" xml:space="preserve">
          <source>Allows for runtime registration of handler functions that override the default warning behavior. Warnings are invoked by calls made to &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/@ember%2Fdebug/methods#warn&quot;&gt;@ember/debug/warn&lt;/a&gt;. The following example demonstrates its usage by registering a handler that does nothing overriding Ember's default warning behavior.</source>
          <target state="translated">允许对处理程序功能进行运行时注册，这些处理程序功能将覆盖默认警告行为。警告通过调用&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/@ember%2Fdebug/methods#warn&quot;&gt;@ ember / debug / warn&lt;/a&gt;来调用。下面的示例通过注册一个不执行任何操作来覆盖Ember的默认警告行为的操作程序来演示其用法。</target>
        </trans-unit>
        <trans-unit id="2a893a2d17b48de5fc7573df951096b2dcef5f22" translate="yes" xml:space="preserve">
          <source>Allows for runtime registration of handler functions that override the default warning behavior. Warnings are invoked by calls made to &lt;a href=&quot;https://emberjs.com/api/classes/Ember.html#method_warn&quot;&gt;Ember.warn&lt;/a&gt;. The following example demonstrates its usage by registering a handler that does nothing overriding Ember's default warning behavior.</source>
          <target state="translated">允许对处理程序功能进行运行时注册，这些处理程序功能将覆盖默认警告行为。警告通过调用&lt;a href=&quot;https://emberjs.com/api/classes/Ember.html#method_warn&quot;&gt;Ember.warn&lt;/a&gt;来调用。以下示例通过注册一个不执行任何操作来覆盖Ember的默认警告行为的操作程序来演示其用法。</target>
        </trans-unit>
        <trans-unit id="152a5267639ede0c60e32fd51b44b36e075fbc25" translate="yes" xml:space="preserve">
          <source>Allows you to produce custom metadata for the route. The return value of this method will be attached to its corresponding RouteInfoWithAttributes object.</source>
          <target state="translated">允许您为路由生成自定义元数据。该方法的返回值将被附加到对应的RouteInfoWithAttributes对象上。</target>
        </trans-unit>
        <trans-unit id="8837c765f5879bdcfaa68e31e606df42e35fcec1" translate="yes" xml:space="preserve">
          <source>Allows you to specify which context to call the specified function in while adding the execution of that function to the Ember run loop. This ability makes this method a great way to asynchronously integrate third-party libraries into your Ember application.</source>
          <target state="translated">允许你指定在哪个上下文中调用指定的函数,同时将该函数的执行加入到Ember运行循环中。这个能力使得这个方法成为异步整合第三方库到你的Ember应用的好方法。</target>
        </trans-unit>
        <trans-unit id="43d09e474472eda4635ad21f8b5f03cfd24b6cf5" translate="yes" xml:space="preserve">
          <source>Allows you to traverse through the linked list of &lt;code&gt;RouteInfo&lt;/code&gt;s from the topmost to leafmost. Returns the first &lt;code&gt;RouteInfo&lt;/code&gt; in the linked list for which the callback returns true.</source>
          <target state="translated">允许您从最顶层到最 &lt;code&gt;RouteInfo&lt;/code&gt; 遍历RouteInfo的链接列表。返回 &lt;code&gt;RouteInfo&lt;/code&gt; 中的第一个RouteInfo，回调将为其返回true。</target>
        </trans-unit>
        <trans-unit id="a1bea53958709685d1c2ec20b3089e9eb98236df" translate="yes" xml:space="preserve">
          <source>Almost every test has a pattern of visiting a route, interacting with the page (using the helpers), and checking for expected changes in the DOM.</source>
          <target state="translated">几乎每个测试都有一个模式,即访问一个路由,与页面交互(使用帮助程序),并检查DOM中的预期变化。</target>
        </trans-unit>
        <trans-unit id="5eb585a5d8debb39a2e408f32ce5f5d2d0b65dfb" translate="yes" xml:space="preserve">
          <source>Along the way, you might need to study up on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class&quot;&gt;Native JavaScript Classes&lt;/a&gt; too. Otherwise, it may be confusing about which parts of code are special to Ember, and which are not.</source>
          <target state="translated">在此过程中，您可能还需要学习本&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class&quot;&gt;机JavaScript类&lt;/a&gt;。否则，可能会混淆哪些代码部分是Ember专用的，哪些不是。</target>
        </trans-unit>
        <trans-unit id="d32eb76d385644f5902d1a58a747a9b7a890957b" translate="yes" xml:space="preserve">
          <source>Along with the records returned from your store, you'll likely need to handle some kind of metadata. &lt;em&gt;Metadata&lt;/em&gt; is data that goes along with a specific &lt;em&gt;model&lt;/em&gt; or &lt;em&gt;type&lt;/em&gt; instead of a record.</source>
          <target state="translated">除了从商店返回的记录之外，您可能还需要处理某种元数据。&lt;em&gt;元数据&lt;/em&gt;是与特定&lt;em&gt;模型&lt;/em&gt;或&lt;em&gt;类型（&lt;/em&gt;而不是记录）一起出现的数据。</target>
        </trans-unit>
        <trans-unit id="a4a29874e43397b867c35bbb4bac2e6ddf1c6ef7" translate="yes" xml:space="preserve">
          <source>Along with two types of modifiers that can be applied to methods, accessors, and fields:</source>
          <target state="translated">以及可以应用于方法、访问器和字段的两类修饰符。</target>
        </trans-unit>
        <trans-unit id="287aa9efd6d0131e0e8c3a8ab6310d9c9f9f13ca" translate="yes" xml:space="preserve">
          <source>Also available as &lt;code&gt;Function.prototype.observes&lt;/code&gt; if prototype extensions are enabled.</source>
          <target state="translated">也可作为 &lt;code&gt;Function.prototype.observes&lt;/code&gt; 查看是否启用了原型扩展。</target>
        </trans-unit>
        <trans-unit id="20716f0097f6e369fad1156fe013f9e2b4ee343c" translate="yes" xml:space="preserve">
          <source>Also note how the callback function passed to the test helper is marked with the keyword &lt;code&gt;async&lt;/code&gt;. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;ECMAScript 2017 feature async/await&lt;/a&gt; allows us to write asynchronous code in an easy-to-read, seemingly synchronous manner. We can better see what this means, once we start writing out our first test case:</source>
          <target state="translated">还要注意，传递给测试助手的回调函数是如何用关键字 &lt;code&gt;async&lt;/code&gt; 标记的。所述&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;的ECMAScript 2017特征异步/ AWAIT&lt;/a&gt;允许我们以容易阅读的，看似同步的方式写入异步代码。开始编写第一个测试用例后，我们可以更好地了解这意味着什么：</target>
        </trans-unit>
        <trans-unit id="0d405afc403e701b0ff791113a507d6d4c38813e" translate="yes" xml:space="preserve">
          <source>Also note that for &lt;code&gt;scheduleOnce&lt;/code&gt; to prevent additional calls, you need to pass the same function instance. The following case works as expected:</source>
          <target state="translated">还要注意，对于 &lt;code&gt;scheduleOnce&lt;/code&gt; 以防止进行其他调用，您需要传递相同的函数实例。以下情况可以正常工作：</target>
        </trans-unit>
        <trans-unit id="6a71db6d5d517b8977003666223226fe7a669b73" translate="yes" xml:space="preserve">
          <source>Also note that multiple calls to &lt;code&gt;peekAll&lt;/code&gt; for a given type will always return the same &lt;code&gt;RecordArray&lt;/code&gt;.</source>
          <target state="translated">还要注意，针对给定类型的对 &lt;code&gt;peekAll&lt;/code&gt; 的多次调用将始终返回相同的 &lt;code&gt;RecordArray&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d86077b483479586784301fa189115176eddf0ef" translate="yes" xml:space="preserve">
          <source>Also note that passing an anonymous function to &lt;code&gt;run.scheduleOnce&lt;/code&gt; will not prevent additional calls with an identical anonymous function from scheduling the items multiple times, e.g.:</source>
          <target state="translated">还要注意，将匿名函数传递给 &lt;code&gt;run.scheduleOnce&lt;/code&gt; 不会阻止具有相同匿名函数的其他调用多次调度项目，例如：</target>
        </trans-unit>
        <trans-unit id="809a8d162707850d38fd3de439436fce60c769a5" translate="yes" xml:space="preserve">
          <source>Also note, how both creating a record and updating properties on the record through the &lt;code&gt;levelUp&lt;/code&gt; method requires us to wrap these operations into a &lt;code&gt;run&lt;/code&gt; function. You can read more the Ember run loop &lt;a href=&quot;https://guides.emberjs.com/applications/run-loop/&quot;&gt;over here&lt;/a&gt;.</source>
          <target state="translated">还要注意，如何通过 &lt;code&gt;levelUp&lt;/code&gt; 方法创建记录和更新记录的属性都需要我们将这些操作包装到 &lt;code&gt;run&lt;/code&gt; 函数中。您可以&lt;a href=&quot;https://guides.emberjs.com/applications/run-loop/&quot;&gt;在此处&lt;/a&gt;阅读更多的Ember运行循环。</target>
        </trans-unit>
        <trans-unit id="855f6f073c4f90c4033dda3d95e4edd38622472a" translate="yes" xml:space="preserve">
          <source>Also take a look at &lt;a href=&quot;#method_modelNameFromPayloadType&quot;&gt;modelNameFromPayloadType&lt;/a&gt; to customize how the model name from should be mapped from the payload.</source>
          <target state="translated">还要看看&lt;a href=&quot;#method_modelNameFromPayloadType&quot;&gt;modelNameFromPayloadType，&lt;/a&gt;以自定义应如何从有效负载映射模型名称。</target>
        </trans-unit>
        <trans-unit id="5a40e9c25fcd68dadcf28a840e0a3ba09ababcc4" translate="yes" xml:space="preserve">
          <source>Also take a look at &lt;a href=&quot;#method_payloadTypeFromModelName&quot;&gt;payloadTypeFromModelName&lt;/a&gt; to customize how the type of a record should be serialized.</source>
          <target state="translated">还可以看一下&lt;a href=&quot;#method_payloadTypeFromModelName&quot;&gt;payloadTypeFromModelName，&lt;/a&gt;以自定义应如何序列化记录的类型。</target>
        </trans-unit>
        <trans-unit id="765058281b41d2406ccda100d75aeebf9d049d08" translate="yes" xml:space="preserve">
          <source>Also, note that the second test uses a dummy object as the returned map element (defined on line 4). Our map element can be substituted with any object because we are only asserting that the cache has been accessed (see line 32).</source>
          <target state="translated">另外,请注意,第二个测试使用了一个虚拟对象作为返回的map元素(定义在第4行)。我们的map元素可以用任何对象代替,因为我们只是断言缓存已经被访问了(见第32行)。</target>
        </trans-unit>
        <trans-unit id="d3e4f6316a7cf691def638bdca1ad5d8ea6d9564" translate="yes" xml:space="preserve">
          <source>Also, these helpers register themselves in the order that you call them and will be run in a chain; each one is only called after the previous one finishes. You can rest assured, therefore, that the order you call them in will also be their execution order, and that the previous helper has finished before the next one starts.</source>
          <target state="translated">此外,这些助手按照你调用的顺序注册,并将以链式方式运行;每个助手都是在前一个助手完成后才被调用。因此,你可以放心,你调用它们的顺序也将是它们的执行顺序,而且在下一个助手开始之前,前一个助手已经完成。</target>
        </trans-unit>
        <trans-unit id="ab11f9ebfff84692e7c7903b624652206fc57659" translate="yes" xml:space="preserve">
          <source>Alternatively (and recommended), you can also define &lt;code&gt;EmberENV.FEATURES&lt;/code&gt; if you need to enable features flagged at runtime.</source>
          <target state="translated">另外（并推荐），如果需要启用运行时标记的功能，则还可以定义 &lt;code&gt;EmberENV.FEATURES&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2441af84c835069d960f8b18d73f19906e7e58b" translate="yes" xml:space="preserve">
          <source>Alternatively you can pass an id into the call to &lt;code&gt;store.createRecord&lt;/code&gt; directly.</source>
          <target state="translated">或者，您可以将ID直接传递给对 &lt;code&gt;store.createRecord&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="3b1c338c009761bfc062cee666109779d3ebafd0" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;pushPayload&lt;/code&gt; will accept a model type which will determine which serializer will process the payload.</source>
          <target state="translated">另外， &lt;code&gt;pushPayload&lt;/code&gt; 将接受一个模型类型，该类型将确定哪个序列化程序将处理有效载荷。</target>
        </trans-unit>
        <trans-unit id="02613cd77a36c4f02b5d61f696c09cd217233003" translate="yes" xml:space="preserve">
          <source>Alternatively, if called within an existing run loop:</source>
          <target state="translated">另外,如果在现有的运行循环中调用。</target>
        </trans-unit>
        <trans-unit id="5a85d30b9c88f8fdb857d54755da58e0796aa6eb" translate="yes" xml:space="preserve">
          <source>Alternatively, we could update the &lt;code&gt;hasMany&lt;/code&gt; relationship by pushing a record into the relationship:</source>
          <target state="translated">另外，我们可以通过将记录推送到关系中来更新 &lt;code&gt;hasMany&lt;/code&gt; 关系：</target>
        </trans-unit>
        <trans-unit id="efbf21138b1b23ce19aaa165231cf9248bf29028" translate="yes" xml:space="preserve">
          <source>Alternatively, you can accept an arbitrary number of parameters by setting &lt;code&gt;positionalParams&lt;/code&gt; to a string, e.g. &lt;code&gt;positionalParams: 'params'&lt;/code&gt;. This will allow you to access those params as an array like so:</source>
          <target state="translated">另外，您可以通过将 &lt;code&gt;positionalParams&lt;/code&gt; 设置为字符串来接受任意数量的参数，例如 &lt;code&gt;positionalParams: 'params'&lt;/code&gt; 。这样，您就可以像数组那样访问这些参数：</target>
        </trans-unit>
        <trans-unit id="6faf54c18e0980c4d4c1d13783729370498e78a4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can explicitly provide a serialized &lt;code&gt;id&lt;/code&gt;, in place of passing a model object:</source>
          <target state="translated">或者，您可以显式提供序列化的 &lt;code&gt;id&lt;/code&gt; ，以代替传递模型对象：</target>
        </trans-unit>
        <trans-unit id="c92bca942c96ee4ac6c5528df059e247f3940328" translate="yes" xml:space="preserve">
          <source>Alternatively, you can pass the &lt;code&gt;outlet&lt;/code&gt; name directly as a string.</source>
          <target state="translated">或者，您可以将 &lt;code&gt;outlet&lt;/code&gt; 名称直接作为字符串传递。</target>
        </trans-unit>
        <trans-unit id="b11c114b6aa556375b6458321ebe1447d05fce62" translate="yes" xml:space="preserve">
          <source>Alternatively, you could pass both a photo's ID and a comment to the component:</source>
          <target state="translated">另外,你也可以将照片的ID和注释同时传递给组件。</target>
        </trans-unit>
        <trans-unit id="2a9f9d2ee2674d44b3b938a426ec795bfaf36b31" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;createRecord&lt;/code&gt; is fairly straightforward, the only thing to watch out for is that you cannot assign a promise as a relationship, currently.</source>
          <target state="translated">尽管 &lt;code&gt;createRecord&lt;/code&gt; 非常简单，但是唯一需要注意的是，当前您不能将promise分配为关系。</target>
        </trans-unit>
        <trans-unit id="eef2a7c411f8622d7eba3b860aa0cd53b1790a3f" translate="yes" xml:space="preserve">
          <source>Although Ember Data encourages you to sideload your relationships, sometimes when working with legacy APIs you may discover you need to deal with JSON that contains relationships embedded inside other records. The &lt;code&gt;EmbeddedRecordsMixin&lt;/code&gt; is meant to help with this problem.</source>
          <target state="translated">尽管Ember Data鼓励您减轻关系负担，但有时在使用旧版API时，您可能会发现需要处理包含嵌入在其他记录中的关系的JSON。该 &lt;code&gt;EmbeddedRecordsMixin&lt;/code&gt; 意味着此问题的帮助。</target>
        </trans-unit>
        <trans-unit id="1c3f267874e2789ed75f6f7073e54490c6c0a9b5" translate="yes" xml:space="preserve">
          <source>Although autoruns are convenient, they are suboptimal. The current JS frame is allowed to end before the run loop is flushed, which sometimes means the browser will take the opportunity to do other things, like garbage collection. GC running in between data changing and DOM rerendering can cause visual lag and should be minimized.</source>
          <target state="translated">虽然自动运行很方便,但却是次优的。在运行循环被刷新之前,当前的JS框架被允许结束,这有时意味着浏览器会趁机做其他事情,比如垃圾收集。GC在数据变化和DOM重新渲染之间运行会造成视觉滞后,应该尽量减少。</target>
        </trans-unit>
        <trans-unit id="5a8abe7c0e83297852d4f67da4842abb482c2b8a" translate="yes" xml:space="preserve">
          <source>Although these methods are efficient, they do add a layer of indirection to your application so it is a good idea to use them only when you need the flexibility of using both true JavaScript arrays and &quot;virtual&quot; arrays such as controllers and collections.</source>
          <target state="translated">虽然这些方法很有效,但它们确实给你的应用程序增加了一层间接性,所以只有当你需要灵活地使用真正的JavaScript数组和 &quot;虚拟 &quot;数组(如控制器和集合)时,才是使用它们的好主意。</target>
        </trans-unit>
        <trans-unit id="ccfc88ef2112665ae2b825601a633790b9a7f125" translate="yes" xml:space="preserve">
          <source>Although this is the most common way to add an observer, this capability is actually built into the &lt;code&gt;Ember.Object&lt;/code&gt; class on top of two methods defined in this mixin: &lt;code&gt;addObserver&lt;/code&gt; and &lt;code&gt;removeObserver&lt;/code&gt;. You can use these two methods to add and remove observers yourself if you need to do so at runtime.</source>
          <target state="translated">尽管这是添加观察者的最常用方法，但实际上此功能已内置在 &lt;code&gt;Ember.Object&lt;/code&gt; 类中，该类在此mixin中定义的两个方法之上： &lt;code&gt;addObserver&lt;/code&gt; 和 &lt;code&gt;removeObserver&lt;/code&gt; 。如果需要在运行时，可以使用这两种方法自己添加和删除观察者。</target>
        </trans-unit>
        <trans-unit id="0bedd4c4463cb2876fa7d45887958ccfb2bc89cf" translate="yes" xml:space="preserve">
          <source>Although this is the most common way to add an observer, this capability is actually built into the &lt;code&gt;EmberObject&lt;/code&gt; class on top of two methods defined in this mixin: &lt;code&gt;addObserver&lt;/code&gt; and &lt;code&gt;removeObserver&lt;/code&gt;. You can use these two methods to add and remove observers yourself if you need to do so at runtime.</source>
          <target state="translated">尽管这是添加观察者的最常用方法，但实际上此功能已内置在 &lt;code&gt;EmberObject&lt;/code&gt; 类中，该类是在此mixin中定义的两个方法之上的： &lt;code&gt;addObserver&lt;/code&gt; 和 &lt;code&gt;removeObserver&lt;/code&gt; 。如果需要在运行时，可以使用这两种方法自己添加和删除观察者。</target>
        </trans-unit>
        <trans-unit id="2fdf3acda5570ed5cbb53880e6ef30466d75ee58" translate="yes" xml:space="preserve">
          <source>Always check to see if someone has already written an addon or library that helps connect to your API host or style</source>
          <target state="translated">经常检查是否有人已经写了一个插件或库,帮助连接到你的API主机或风格。</target>
        </trans-unit>
        <trans-unit id="2c97fd3f322b72a3d4c4d7d442eaf826aed2dd2b" translate="yes" xml:space="preserve">
          <source>Always give your class a name, e.g. ✅ &lt;code&gt;class MyClass {}&lt;/code&gt; and not 🛑 &lt;code&gt;class {}&lt;/code&gt;</source>
          <target state="translated">始终给您的班级起一个名字，例如✅class &lt;code&gt;class MyClass {}&lt;/code&gt; 而不是🛑class &lt;code&gt;class {}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73adb7629ca2f26a20ecbd91717b58bf8e26e808" translate="yes" xml:space="preserve">
          <source>Always test on real, representative mobile devices.</source>
          <target state="translated">始终在真实的、有代表性的移动设备上进行测试。</target>
        </trans-unit>
        <trans-unit id="7e624e8c287aa2c3b7ac91a4518796513fe4bb5b" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Application.html&quot;&gt;&lt;code&gt;Ember.Application&lt;/code&gt;&lt;/a&gt; serves as a &quot;registry&quot; for dependency declarations. Factories (i.e. classes) are registered with an application, as well as rules about &quot;injecting&quot; dependencies that are applied when objects are instantiated.</source>
          <target state="translated">一个&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Application.html&quot;&gt; &lt;code&gt;Ember.Application&lt;/code&gt; &lt;/a&gt;充当&amp;ldquo;注册表&amp;rdquo;的依赖声明。工厂（即类）以及在实例化对象时应用的有关&amp;ldquo;注入&amp;rdquo;依赖项的规则都向应用程序注册。</target>
        </trans-unit>
        <trans-unit id="de948038346f8af9fc0cb6320df6101f3e94f5dc" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://emberjs.com/api/classes/Ember.ApplicationInstance.html&quot;&gt;&lt;code&gt;Ember.ApplicationInstance&lt;/code&gt;&lt;/a&gt; serves as the &quot;owner&quot; for objects that are instantiated from registered factories. Application instances provide a means to &quot;look up&quot; (i.e. instantiate and / or retrieve) objects.</source>
          <target state="translated">一个&lt;a href=&quot;http://emberjs.com/api/classes/Ember.ApplicationInstance.html&quot;&gt; &lt;code&gt;Ember.ApplicationInstance&lt;/code&gt; &lt;/a&gt;作为&amp;ldquo;主人&amp;rdquo;为从注册工厂实例对象。应用程序实例提供了一种&amp;ldquo;查找&amp;rdquo;（即实例化和/或检索）对象的方法。</target>
        </trans-unit>
        <trans-unit id="ac779e3c2cb123d5adaf74e6554e7d130c4a9eaf" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Service.html&quot;&gt;&lt;code&gt;Ember.Service&lt;/code&gt;&lt;/a&gt; is an Ember object that lives for the duration of the application, and can be made available in different parts of your application.</source>
          <target state="translated">一个&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Service.html&quot;&gt; &lt;code&gt;Ember.Service&lt;/code&gt; &lt;/a&gt;是灰烬对象为居住该应用程序的持续时间，并且可以使你的应用程序的不同部分可用。</target>
        </trans-unit>
        <trans-unit id="150cadffc6234f6dd95528843d3a3b767e3d2c1a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Application&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; serves as a &quot;registry&quot; for dependency declarations. Factories (i.e. classes) are registered with an application, as well as rules about &quot;injecting&quot; dependencies that are applied when objects are instantiated.</source>
          <target state="translated">一个&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Application&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt;作为一个&amp;ldquo;注册表&amp;rdquo;的依赖声明。工厂（即类）以及在实例化对象时应用的有关&amp;ldquo;注入&amp;rdquo;依赖项的规则都向应用程序注册。</target>
        </trans-unit>
        <trans-unit id="f32c6f3234e84ad02ca6286961ff387ee08af23d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/ApplicationInstance&quot;&gt;&lt;code&gt;ApplicationInstance&lt;/code&gt;&lt;/a&gt; serves as the &quot;owner&quot; for objects that are instantiated from registered factories. Application instances provide a means to &quot;look up&quot; (i.e. instantiate and / or retrieve) objects.</source>
          <target state="translated">一个&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/ApplicationInstance&quot;&gt; &lt;code&gt;ApplicationInstance&lt;/code&gt; &lt;/a&gt;作为&amp;ldquo;主人&amp;rdquo;为从注册工厂实例对象。应用程序实例提供了一种&amp;ldquo;查找&amp;rdquo;（即实例化和/或检索）对象的方法。</target>
        </trans-unit>
        <trans-unit id="80570aee16848a546fc70644c93965861edf257c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://guides.emberjs.com/templates/actions/&quot;&gt;actions hash&lt;/a&gt; is an object in the component that contains functions. These functions are called when the user interacts with the UI, such as clicking.</source>
          <target state="translated">一个&lt;a href=&quot;https://guides.emberjs.com/templates/actions/&quot;&gt;动作散列&lt;/a&gt;是包含功能组件中的对象。当用户与UI交互（例如单击）时，将调用这些功能。</target>
        </trans-unit>
        <trans-unit id="7f4bee16270cf0cb6f61f70a26b58e0e0c94a92f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Ember.Component&lt;/code&gt; is a view that is completely isolated. Properties accessed in its templates go to the view object and actions are targeted at the view object. There is no access to the surrounding context or outer controller; all contextual information must be passed in.</source>
          <target state="translated">一个 &lt;code&gt;Ember.Component&lt;/code&gt; 是完全隔离的图。在其模板中访问的属性将转到视图对象，而操作则针对该视图对象。无法访问周围的上下文或外部控制器；所有上下文信息都必须传递。</target>
        </trans-unit>
        <trans-unit id="1883bb873b7fcf60158adf7d837aa6b927c0e6a2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;about&lt;/code&gt; route, that gives information on our application.</source>
          <target state="translated">一个 &lt;code&gt;about&lt;/code&gt; 路由，即给出了我们的应用程序的信息。</target>
        </trans-unit>
        <trans-unit id="bb1448a6a4f0771288c7f687937892fa7ef13e01" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;adapter&lt;/strong&gt; is an object that translates requests from Ember (such as &quot;find the user with an ID of 1&quot;) into requests to a server.</source>
          <target state="translated">一个&lt;strong&gt;适配器&lt;/strong&gt;是转换来自灰烬请求（例如&amp;ldquo;找到为1的ID的用户&amp;rdquo;）转换请求到服务器的对象。</target>
        </trans-unit>
        <trans-unit id="5902d993be6eb634955e5fd9227b9df48f126894" translate="yes" xml:space="preserve">
          <source>An About Route</source>
          <target state="translated">关于路线</target>
        </trans-unit>
        <trans-unit id="f642fc2a91377aca2824b91dca244f58751396c3" translate="yes" xml:space="preserve">
          <source>An ArrayProxy wraps any other object that implements &lt;code&gt;Array&lt;/code&gt; and/or &lt;code&gt;MutableArray,&lt;/code&gt; forwarding all requests. This makes it very useful for a number of binding use cases or other cases where being able to swap out the underlying array is useful.</source>
          <target state="translated">ArrayProxy包装实现 &lt;code&gt;Array&lt;/code&gt; 和/或 &lt;code&gt;MutableArray,&lt;/code&gt; 任何其他对象，转发所有请求。这对于许多绑定用例或其他能够换出基础数组的情况非常有用。</target>
        </trans-unit>
        <trans-unit id="9500428fb1d2f5abb8fba66420e17f6fcc1234b3" translate="yes" xml:space="preserve">
          <source>An ArrayProxy wraps any other object that implements &lt;code&gt;Ember.Array&lt;/code&gt; and/or &lt;code&gt;Ember.MutableArray,&lt;/code&gt; forwarding all requests. This makes it very useful for a number of binding use cases or other cases where being able to swap out the underlying array is useful.</source>
          <target state="translated">ArrayProxy包装实现 &lt;code&gt;Ember.Array&lt;/code&gt; 和/或 &lt;code&gt;Ember.MutableArray,&lt;/code&gt; 任何其他对象，以转发所有请求。这对于许多绑定用例或其他能够换出基础数组的情况非常有用。</target>
        </trans-unit>
        <trans-unit id="9a6039258cfcdc862552cfdba43389f97b2d891a" translate="yes" xml:space="preserve">
          <source>An Ember route is built with three parts:</source>
          <target state="translated">一条微光通道由三部分组成。</target>
        </trans-unit>
        <trans-unit id="596f4894284d1bf94fc6151d59724cd243050588" translate="yes" xml:space="preserve">
          <source>An ID is usually assigned to a record by the server when you save it for the first time, but you can also generate IDs client-side.</source>
          <target state="translated">当你第一次保存一条记录时,ID通常由服务器分配给它,但你也可以在客户端生成ID。</target>
        </trans-unit>
        <trans-unit id="c76edccb2007be97c5102cf9e80f944ae7a8691f" translate="yes" xml:space="preserve">
          <source>An Index Route</source>
          <target state="translated">索引路线</target>
        </trans-unit>
        <trans-unit id="e5e7d7f7cc5134380d134c786308635abca89e80" translate="yes" xml:space="preserve">
          <source>An Integration Test</source>
          <target state="translated">集成测试</target>
        </trans-unit>
        <trans-unit id="50fad2554ce7e95a53c65017699fe62afba1cc76" translate="yes" xml:space="preserve">
          <source>An RecordReference is a low level API that allows users and addon author to perform meta-operations on a record.</source>
          <target state="translated">RecordReference是一个低级的API,允许用户和addon作者对记录进行元操作。</target>
        </trans-unit>
        <trans-unit id="f4c5e8a55d8da65f8eb359d5bfadfcc73a0ee14e" translate="yes" xml:space="preserve">
          <source>An action to double the &lt;code&gt;multiple&lt;/code&gt;</source>
          <target state="translated">一个动作的双 &lt;code&gt;multiple&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="608cdc5facc35a250421503c369c58512fc16f58" translate="yes" xml:space="preserve">
          <source>An adapter can target other hosts by setting the &lt;code&gt;host&lt;/code&gt; property.</source>
          <target state="translated">适配器可以通过设置 &lt;code&gt;host&lt;/code&gt; 属性来定位其他主机。</target>
        </trans-unit>
        <trans-unit id="9a5775bac8afbc0c3d7f8686c2d570e43392de66" translate="yes" xml:space="preserve">
          <source>An adapter is an object that receives requests from a store and translates them into the appropriate action to take against your persistence layer. The persistence layer is usually an HTTP API, but may be anything, such as the browser's local storage. Typically the adapter is not invoked directly instead its functionality is accessed through the &lt;code&gt;store&lt;/code&gt;.</source>
          <target state="translated">适配器是一个对象，它接收来自商店的请求并将其转换为适当的操作，以对您的持久层进行处理。持久层通常是HTTP API，但可以是任何东西，例如浏览器的本地存储。通常，不直接调用适配器，而是通过 &lt;code&gt;store&lt;/code&gt; 访问其功能。</target>
        </trans-unit>
        <trans-unit id="9fc80751fda7c43b7d6a2db08d919277d3465e27" translate="yes" xml:space="preserve">
          <source>An additional benefit is that you no longer have to use &lt;code&gt;set&lt;/code&gt; to update these values, you can use standard JavaScript syntax instead!</source>
          <target state="translated">另一个好处是您不再需要使用 &lt;code&gt;set&lt;/code&gt; 来更新这些值，而是可以使用标准JavaScript语法！</target>
        </trans-unit>
        <trans-unit id="6f3a86affe2d7220ce0e01e6dbfde7c83555af2d" translate="yes" xml:space="preserve">
          <source>An alias to the proxied promise's &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">别名的代理的承诺的 &lt;code&gt;catch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29c43cebb44c8dee95e990d1d5f3c186f19709c0" translate="yes" xml:space="preserve">
          <source>An alias to the proxied promise's &lt;code&gt;finally&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt; promise的别名。</target>
        </trans-unit>
        <trans-unit id="29d2587b6a6e14a31cba73d06ed8ee8231089637" translate="yes" xml:space="preserve">
          <source>An alias to the proxied promise's &lt;code&gt;then&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;then&lt;/code&gt; 是promise的pron的别名。</target>
        </trans-unit>
        <trans-unit id="0fae4849e3919222e3cba2482fe020e2bb1f1ddf" translate="yes" xml:space="preserve">
          <source>An app can use a different version than what it specifies as it's compatibility version. For instance, an App could be using &lt;code&gt;3.16&lt;/code&gt; while specifying compatibility with &lt;code&gt;3.12&lt;/code&gt;. This would remove any deprecations that were present in or before &lt;code&gt;3.12&lt;/code&gt; but keep support for anything deprecated in or abvoe &lt;code&gt;3.13&lt;/code&gt;.</source>
          <target state="translated">应用可以使用与其指定的兼容版本不同的版本。例如，某个应用在指定与 &lt;code&gt;3.12&lt;/code&gt; 的兼容性时可能正在使用 &lt;code&gt;3.16&lt;/code&gt; 。这将删除 &lt;code&gt;3.12&lt;/code&gt; 或之前存在的所有不赞成使用的内容，但仍支持 &lt;code&gt;3.13&lt;/code&gt; 或以后不赞成使用的任何内容。</target>
        </trans-unit>
        <trans-unit id="33e753b000ae156d9d8ea5bb3a387e513289c376" translate="yes" xml:space="preserve">
          <source>An array containing all of the error messages for this record. This is useful for displaying all errors to the user.</source>
          <target state="translated">一个包含该记录所有错误信息的数组。这对于向用户显示所有错误信息很有用。</target>
        </trans-unit>
        <trans-unit id="3c7090dadd43a75eefba2c31824359b0ff59d071" translate="yes" xml:space="preserve">
          <source>An array of Snapshot arrays</source>
          <target state="translated">一组快照阵列</target>
        </trans-unit>
        <trans-unit id="b61e2b6273b8fdc31ef8e26f8d2af48ae022708a" translate="yes" xml:space="preserve">
          <source>An array of columns of the following format: name: {String} The name of the column. desc: {String} Humanized description (what would show in a table column name).</source>
          <target state="translated">列的数组,格式如下:name:{String}。列名。 desc:{String}。人性化描述(表列名中会显示的内容)。</target>
        </trans-unit>
        <trans-unit id="81b72d7bef0000bbe49e0a833c3532585f1a79a0" translate="yes" xml:space="preserve">
          <source>An array of indexes of items to return.</source>
          <target state="translated">要返回的项目索引数组。</target>
        </trans-unit>
        <trans-unit id="8122272945877e94daf5c84ee2ad4d0a13df3286" translate="yes" xml:space="preserve">
          <source>An array of records. This array will be observed for changes, so it should update when new records are added/removed.</source>
          <target state="translated">一个记录数组。这个数组将观察变化,所以当有新记录添加/删除时,它应该更新。</target>
        </trans-unit>
        <trans-unit id="5e75799df15196f7a25ed796714cc70426f54776" translate="yes" xml:space="preserve">
          <source>An array of snapshots</source>
          <target state="translated">一系列的快照</target>
        </trans-unit>
        <trans-unit id="2fbb22315f2e30f32aa62fad0bad0532be1e2c84" translate="yes" xml:space="preserve">
          <source>An array of snapshots of the available data for the resources to fetch</source>
          <target state="translated">要获取的资源的可用数据的快照数组。</target>
        </trans-unit>
        <trans-unit id="eb58ab5ebfb56d5e2bfd8b9296c584c2ccf48594" translate="yes" xml:space="preserve">
          <source>An array of strings.</source>
          <target state="translated">一个字符串数组。</target>
        </trans-unit>
        <trans-unit id="5887d2bd2f0ddf7e42b115ac99e306e4fbbb7769" translate="yes" xml:space="preserve">
          <source>An array of the ids of the resources to fetch</source>
          <target state="translated">要获取的资源的ID数组。</target>
        </trans-unit>
        <trans-unit id="1120aaa0a87d2dd213ed0158edf71c2454297f52" translate="yes" xml:space="preserve">
          <source>An array of these arguments is passed to the helper function:</source>
          <target state="translated">这些参数的数组被传递给帮助函数。</target>
        </trans-unit>
        <trans-unit id="fda1ec9d59264d818647834489da811f90f6a33d" translate="yes" xml:space="preserve">
          <source>An array of types directly related to a model. Each type will be included once, regardless of the number of relationships it has with the model.</source>
          <target state="translated">与模型直接相关的类型数组。每个类型将被包含一次,无论它与模型有多少关系。</target>
        </trans-unit>
        <trans-unit id="aa341318cbc6694b07d1e5032577eaf030d13bdc" translate="yes" xml:space="preserve">
          <source>An array of zero or more objects that should be inserted into the array at *idx*</source>
          <target state="translated">一个由0个或多个对象组成的数组,这些对象应插入到*idx*的数组中。</target>
        </trans-unit>
        <trans-unit id="1fe90876a1b798c907c82e0db130ed1fa8029f0a" translate="yes" xml:space="preserve">
          <source>An author's full name and date are properly displayed in a blog post.</source>
          <target state="translated">作者的全名和日期在博客文章中正确显示。</target>
        </trans-unit>
        <trans-unit id="639f2e84401c149f296033a7bb9384842745aa11" translate="yes" xml:space="preserve">
          <source>An empty Array.</source>
          <target state="translated">一个空数组。</target>
        </trans-unit>
        <trans-unit id="62fed3b9378eaf6151f1cae0fb4e68e38624c81f" translate="yes" xml:space="preserve">
          <source>An engine instance.</source>
          <target state="translated">一个发动机实例。</target>
        </trans-unit>
        <trans-unit id="5c12b0fcbf2f75e8c43db741b03984a0468e7065" translate="yes" xml:space="preserve">
          <source>An entry in the Ember router (&lt;code&gt;/app/router.js&lt;/code&gt;), which maps between our route name and a specific URI</source>
          <target state="translated">Ember路由器（ &lt;code&gt;/app/router.js&lt;/code&gt; ）中的条目，该条目在我们的路由名称和特定URI之间进行映射</target>
        </trans-unit>
        <trans-unit id="9a58bf8a890e6bbec14734c7fd86bd9ac0f0c1f9" translate="yes" xml:space="preserve">
          <source>An entry in the application's router (located in &lt;code&gt;app/router.js&lt;/code&gt;).</source>
          <target state="translated">应用程序路由器中的一项（位于 &lt;code&gt;app/router.js&lt;/code&gt; 中）。</target>
        </trans-unit>
        <trans-unit id="b565f8e5e3cdc9e58b5e0baabeea00d8be83e64b" translate="yes" xml:space="preserve">
          <source>An event handler takes a function as its second argument. When there are no arguments to the function, you can pass it directly, just like in JavaScript. Otherwise, you can build a function inline by using the &lt;code&gt;fn&lt;/code&gt; syntax.</source>
          <target state="translated">事件处理程序将一个函数作为第二个参数。如果该函数没有参数，则可以直接传递它，就像在JavaScript中一样。否则，您可以使用 &lt;code&gt;fn&lt;/code&gt; 语法内联构建函数。</target>
        </trans-unit>
        <trans-unit id="565168f03af98242da9412c8a3b9f2424ed1c113" translate="yes" xml:space="preserve">
          <source>An event object will be passed as the argument to the event handler method.</source>
          <target state="translated">一个事件对象将作为参数传递给事件处理方法。</target>
        </trans-unit>
        <trans-unit id="b90a6d1a7f3af0170568124207d8fe96a4cf9503" translate="yes" xml:space="preserve">
          <source>An example may help here: Let's say a user clicks two buttons, one after another and both load data from different servers. They take different times to respond.</source>
          <target state="translated">这里举个例子可能会有帮助。假设一个用户点击了两个按钮,一个接一个,并且都从不同的服务器加载数据。它们需要不同的时间来响应。</target>
        </trans-unit>
        <trans-unit id="2451a04315b1c74c5afabdc5516cb2823698620f" translate="yes" xml:space="preserve">
          <source>An example of ordering initializers, we create an initializer named &lt;code&gt;first&lt;/code&gt;:</source>
          <target state="translated">一个订购初始化程序的示例，我们创建一个名为 &lt;code&gt;first&lt;/code&gt; 的初始化程序：</target>
        </trans-unit>
        <trans-unit id="f7fd1537334865abb1ac63354a604b5cb0c99abf" translate="yes" xml:space="preserve">
          <source>An example of providing a session object to all controllers:</source>
          <target state="translated">向所有控制器提供会话对象的一个例子。</target>
        </trans-unit>
        <trans-unit id="fa7f52aa1b03dcc4378de659015523d44d1a571b" translate="yes" xml:space="preserve">
          <source>An example of registering a controller with a non-standard name:</source>
          <target state="translated">一个用非标准名称注册控制器的例子。</target>
        </trans-unit>
        <trans-unit id="9c172c992da769bfd8273ffa63f0953f84dc83b5" translate="yes" xml:space="preserve">
          <source>An example of some of the options you can configure: &lt;a href=&quot;http://eslint.org/docs/rules/&quot;&gt;ESLint&lt;/a&gt;&lt;a href=&quot;http://jshint.com/docs/options/&quot;&gt;JSlint&lt;/a&gt;</source>
          <target state="translated">您可以配置的一些选项的示例：&lt;a href=&quot;http://eslint.org/docs/rules/&quot;&gt;ESLint &lt;/a&gt;&lt;a href=&quot;http://jshint.com/docs/options/&quot;&gt;JSlint&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9976c8abcf03ae85cfba8fcdc9e6e5d66a8621e3" translate="yes" xml:space="preserve">
          <source>An example of the internals</source>
          <target state="translated">内部的一个例子</target>
        </trans-unit>
        <trans-unit id="0b071b91906b2689dd25d0849d30729ed7b9644c" translate="yes" xml:space="preserve">
          <source>An example of this scenario in action is a profile editor component. As you are editing one user, and the user attribute is changed, you can use &lt;code&gt;didUpdateAttrs&lt;/code&gt; to clear any error state that was built up from editing the previous user.</source>
          <target state="translated">实际情况中的一个示例是概要文件编辑器组件。编辑一个用户并更改用户属性时，可以使用 &lt;code&gt;didUpdateAttrs&lt;/code&gt; 清除由编辑前一个用户所建立的任何错误状态。</target>
        </trans-unit>
        <trans-unit id="5a019624ad0e8c382a95c9a56ab5a27f3fa03376" translate="yes" xml:space="preserve">
          <source>An example real-world use case is implementing timeouts:</source>
          <target state="translated">一个真实世界的用例是实现超时。</target>
        </trans-unit>
        <trans-unit id="f7fd4c1b5f79277887b9af3301a467a5a1810dd6" translate="yes" xml:space="preserve">
          <source>An example usage of this method is re-querying the server for the latest information using the same parameters as when the route was first entered.</source>
          <target state="translated">这个方法的一个例子是使用与第一次输入途径时相同的参数重新查询服务器的最新信息。</target>
        </trans-unit>
        <trans-unit id="a4ea86d5180bf384ebb676f2abebaee5f42c159f" translate="yes" xml:space="preserve">
          <source>An example use case would be to detect if the user has entered a route for a specific model that does not exist. For example:</source>
          <target state="translated">一个用例是检测用户是否输入了一个不存在的特定模型的路由。例如:</target>
        </trans-unit>
        <trans-unit id="5441cf6ba6543e259ec5e71bc7109f11c26b46b9" translate="yes" xml:space="preserve">
          <source>An example use case would be to redirect the user to a log in route if a request is unauthorized:</source>
          <target state="translated">一个用例是,如果请求未经授权,则将用户重定向到一个登录路径。</target>
        </trans-unit>
        <trans-unit id="efe097bb10a2f31742bb7369946ae5bef9e910dc" translate="yes" xml:space="preserve">
          <source>An example use case would be to redirect the user to a login route if a request is unauthorized:</source>
          <target state="translated">一个用例是,如果请求未经授权,则将用户重定向到一个登录路径。</target>
        </trans-unit>
        <trans-unit id="f3a16fd76648c5969d4f7924c3292d90decadb74" translate="yes" xml:space="preserve">
          <source>An example use case would be to warn the user to check their internet connection if an adapter operation has timed out:</source>
          <target state="translated">一个用例是在适配器操作超时时,警告用户检查他们的互联网连接。</target>
        </trans-unit>
        <trans-unit id="40a990dc842a897e946e5ebc92c2a2fb7bb24729" translate="yes" xml:space="preserve">
          <source>An honorable mention to Neovim, a hyper-extensible Vim-based text editor with a range of ember extensions. You'll want to remove any linter / completion manager you currently have installed (or disable them for &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.ts&lt;/code&gt; or &lt;code&gt;.hbs&lt;/code&gt; files), and follow the install guides for the following packages:</source>
          <target state="translated">荣誉奖Neovim，这是一种基于Vim的超可扩展文本编辑器，具有一系列余烬扩展。您将要删除当前已安装的所有linter / completion Manager（或对 &lt;code&gt;.js&lt;/code&gt; ， &lt;code&gt;.ts&lt;/code&gt; 或 &lt;code&gt;.hbs&lt;/code&gt; 文件禁用它们），并按照以下软件包的安装指南进行操作：</target>
        </trans-unit>
        <trans-unit id="053593634953b29a961890378abe6d4ebd0d43fe" translate="yes" xml:space="preserve">
          <source>An important note: &lt;code&gt;RSVP.hash&lt;/code&gt; is intended for plain JavaScript objects that are just a set of keys and values. &lt;code&gt;RSVP.hash&lt;/code&gt; will NOT preserve prototype chains.</source>
          <target state="translated">重要说明： &lt;code&gt;RSVP.hash&lt;/code&gt; 用于纯JavaScript对象，这些对象只是一组键和值。 &lt;code&gt;RSVP.hash&lt;/code&gt; 不会保留原型链。</target>
        </trans-unit>
        <trans-unit id="9a3e26d24bc233ea862be6868f841a9990b7ffb8" translate="yes" xml:space="preserve">
          <source>An important note: &lt;code&gt;RSVP.hashSettled&lt;/code&gt; is intended for plain JavaScript objects that are just a set of keys and values. &lt;code&gt;RSVP.hashSettled&lt;/code&gt; will NOT preserve prototype chains.</source>
          <target state="translated">重要说明： &lt;code&gt;RSVP.hashSettled&lt;/code&gt; 用于纯JavaScript对象，这些对象只是一组键和值。 &lt;code&gt;RSVP.hashSettled&lt;/code&gt; 将不保留原型链。</target>
        </trans-unit>
        <trans-unit id="e41e26772b5317538ad716acbd80baf24b49b4c0" translate="yes" xml:space="preserve">
          <source>An important note: &lt;code&gt;hash&lt;/code&gt; is intended for plain JavaScript objects that are just a set of keys and values. &lt;code&gt;hash&lt;/code&gt; will NOT preserve prototype chains.</source>
          <target state="translated">重要说明： &lt;code&gt;hash&lt;/code&gt; 用于纯JavaScript对象，这些对象只是一组键和值。 &lt;code&gt;hash&lt;/code&gt; 将不保留原型链。</target>
        </trans-unit>
        <trans-unit id="df5686560984b8de66c98919292e042c711c8d10" translate="yes" xml:space="preserve">
          <source>An important note: &lt;code&gt;hashSettled&lt;/code&gt; is intended for plain JavaScript objects that are just a set of keys and values. &lt;code&gt;hashSettled&lt;/code&gt; will NOT preserve prototype chains.</source>
          <target state="translated">重要说明： &lt;code&gt;hashSettled&lt;/code&gt; 用于纯JavaScript对象，这些对象只是一组键和值。 &lt;code&gt;hashSettled&lt;/code&gt; 将不保留原型链。</target>
        </trans-unit>
        <trans-unit id="7da72e9ee57598df3d953627dc3016f9052a9342" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Application&lt;/code&gt; is the starting point for every Ember application. It instantiates, initializes and coordinates the objects that make up your app.</source>
          <target state="translated">&lt;code&gt;Application&lt;/code&gt; 实例是每个Ember应用程序的起点。它实例化，初始化和协调组成应用程序的对象。</target>
        </trans-unit>
        <trans-unit id="89f4ef225775e32cbb05ad354ffda0cbce66f59f" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Ember.Application&lt;/code&gt; is the starting point for every Ember application. It helps to instantiate, initialize and coordinate the many objects that make up your app.</source>
          <target state="translated">&lt;code&gt;Ember.Application&lt;/code&gt; 的实例是每个Ember应用程序的起点。它有助于实例化，初始化和协调构成应用程序的许多对象。</target>
        </trans-unit>
        <trans-unit id="d2389c217e67fa49543428f4121e5a3895c6210e" translate="yes" xml:space="preserve">
          <source>An instantiated &lt;code&gt;Model&lt;/code&gt; is referred to as a &lt;code&gt;record&lt;/code&gt;.</source>
          <target state="translated">实例化的 &lt;code&gt;Model&lt;/code&gt; 称为 &lt;code&gt;record&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3153e3c65cd1fb3412d51bd91b8f730d9b3fdbb" translate="yes" xml:space="preserve">
          <source>An item is added to the &lt;code&gt;todos&lt;/code&gt; array.</source>
          <target state="translated">将一项添加到 &lt;code&gt;todos&lt;/code&gt; 数组。</target>
        </trans-unit>
        <trans-unit id="8a385c702881a44cf0bfe43e07e259405c173c6f" translate="yes" xml:space="preserve">
          <source>An item is removed from the &lt;code&gt;todos&lt;/code&gt; array.</source>
          <target state="translated">从 &lt;code&gt;todos&lt;/code&gt; 数组中删除了一个项目。</target>
        </trans-unit>
        <trans-unit id="e77b109133f483882d852df1ac18105151423dee" translate="yes" xml:space="preserve">
          <source>An object instance.</source>
          <target state="translated">一个对象实例。</target>
        </trans-unit>
        <trans-unit id="2bc5157ce7d5d52f47e0dd7999ba37bc76cad2e2" translate="yes" xml:space="preserve">
          <source>An object that can be used to pass a unique `id` for this warning. The `id` can be used by Ember debugging tools to change the behavior (raise, log, or silence) for that specific warning. The `id` should be namespaced by dots, e.g. &quot;ember-debug.feature-flag-with-features-stripped&quot;</source>
          <target state="translated">一个对象,可以用来为这个警告传递一个唯一的`id`。`id`可以被Ember调试工具用来改变该特定警告的行为(引发、记录或沉默)。`id`应该用点来命名,例如 &quot;ember-debug.feature-flag-with-features-stripped&quot; 。</target>
        </trans-unit>
        <trans-unit id="179502adbd250c5f946552b0e15aec102a262e09" translate="yes" xml:space="preserve">
          <source>An object with an owner.</source>
          <target state="translated">一个有主人的对象。</target>
        </trans-unit>
        <trans-unit id="d1ac5cfeeafef69c45bf9b57a3215ee36cbc969f" translate="yes" xml:space="preserve">
          <source>An object with methods for accessing information about the type, attributes and relationships of the primary type associated with the request.</source>
          <target state="translated">一个对象,包含访问与请求相关联的主类型的类型、属性和关系信息的方法。</target>
        </trans-unit>
        <trans-unit id="e5d355e4a637ec26fe9ad11ba1f1279d9d68495b" translate="yes" xml:space="preserve">
          <source>An object's keys will be listed in the same order as the array returned from calling &lt;code&gt;Object.keys&lt;/code&gt; on that object. If you want a different sort order, you should use &lt;code&gt;Object.keys&lt;/code&gt; to get an array, sort that array with the built-in JavaScript tools, and use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each-in&quot;&gt;&lt;code&gt;{{#each}}&lt;/code&gt;&lt;/a&gt; helper instead.</source>
          <target state="translated">对象的键将以与调用该对象的 &lt;code&gt;Object.keys&lt;/code&gt; 返回的数组相同的顺序列出。如果需要不同的排序顺序，则应使用 &lt;code&gt;Object.keys&lt;/code&gt; 来获取一个数组，并使用内置的JavaScript工具对该数组进行排序，然后使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each-in&quot;&gt; &lt;code&gt;{{#each}}&lt;/code&gt; &lt;/a&gt;帮助器。</target>
        </trans-unit>
        <trans-unit id="80d4108f227752b8367ec493d7779bc4eb094232" translate="yes" xml:space="preserve">
          <source>An object's keys will be listed in the same order as the array returned from calling &lt;code&gt;Object.keys&lt;/code&gt; on that object. If you want a different sort order, you should use &lt;code&gt;Object.keys&lt;/code&gt; to get an array, sort that array with the built-in JavaScript tools, and use the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#each&quot;&gt;&lt;code&gt;{{#each}}&lt;/code&gt;&lt;/a&gt; helper instead.</source>
          <target state="translated">对象的键将以与调用该对象的 &lt;code&gt;Object.keys&lt;/code&gt; 返回的数组相同的顺序列出。如果需要不同的排序顺序，则应使用 &lt;code&gt;Object.keys&lt;/code&gt; 来获取一个数组，并使用内置的JavaScript工具对该数组进行排序，然后使用&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#each&quot;&gt; &lt;code&gt;{{#each}}&lt;/code&gt; &lt;/a&gt;帮助器。</target>
        </trans-unit>
        <trans-unit id="2260b59f8a4149ec98c09e5d99e706e2a95c3711" translate="yes" xml:space="preserve">
          <source>An open standard for sound, interoperable JavaScript promises</source>
          <target state="translated">一个健全的、可互操作的JavaScript承诺的开放标准。</target>
        </trans-unit>
        <trans-unit id="259617466814dab7ee239a6cb08ccd0c6cf63ad9" translate="yes" xml:space="preserve">
          <source>An optional boolean. If falsy, the warning will be displayed.</source>
          <target state="translated">一个可选的布尔值。如果是假的,将显示警告。</target>
        </trans-unit>
        <trans-unit id="27fa9677b27a4b0ee61247242b260ea08da55285" translate="yes" xml:space="preserve">
          <source>An optional function that produces args</source>
          <target state="translated">一个产生args的可选函数</target>
        </trans-unit>
        <trans-unit id="a3d4d0e2726f270a0b0e1eb3d24d277ebb5e98e4" translate="yes" xml:space="preserve">
          <source>An optional label. This is useful for tooling.</source>
          <target state="translated">一个可选的标签。这对工具很有用。</target>
        </trans-unit>
        <trans-unit id="1ade0e9c435f407193894ad24428f419ab10cca7" translate="yes" xml:space="preserve">
          <source>An optional model argument can be used for routes whose paths contain dynamic segments. This argument will become the model context of the linked route:</source>
          <target state="translated">对于路径中包含动态段的途径,可以使用一个可选的模型参数。这个参数将成为链接途径的模型上下文。</target>
        </trans-unit>
        <trans-unit id="5578f6c7adb66c4e71c478fd4f253de05d686cc8" translate="yes" xml:space="preserve">
          <source>An optional paramter that if set to `true` causes the promise to fulfill with the callback's success arguments as an array. This is useful if the node function has multiple success paramters. If you set this paramter to an array with names, the promise will fulfill with a hash with these names as keys and the success parameters as values.</source>
          <target state="translated">一个可选的参数,如果设置为 &quot;true&quot;,将导致承诺履行,回调的成功参数为一个数组。如果节点函数有多个成功参数,这很有用。如果你把这个参数设置为一个包含名字的数组,承诺将以这些名字作为键和成功参数作为值的哈希值来实现。</target>
        </trans-unit>
        <trans-unit id="29c842c186926290569207c94c1496fbea50ae71" translate="yes" xml:space="preserve">
          <source>An optional string for identifying the promise.</source>
          <target state="translated">用于识别承诺的可选字符串。</target>
        </trans-unit>
        <trans-unit id="33b5c7ed975b395b86706ece50e898ec81ef5be8" translate="yes" xml:space="preserve">
          <source>An optional target can be passed in as the 2nd argument that will be set as the &quot;this&quot; for the callback. This is a good way to give your function access to the object triggering the event. When the target parameter is used the callback becomes the third argument.</source>
          <target state="translated">一个可选的目标可以作为第二个参数传入,它将被设置为回调的 &quot;this&quot;。这是一个让你的函数访问触发事件的对象的好方法。当目标参数被使用时,回调就成为第三个参数。</target>
        </trans-unit>
        <trans-unit id="629fe19ce0fbe90b07d4d86ab6b8fbd3201252d8" translate="yes" xml:space="preserve">
          <source>An optional target can be passed in as the 2nd argument that will be set as the &quot;this&quot; for the callback. This is a good way to give your function access to the object triggering the event. When the target parameter is used the callback method becomes the third argument.</source>
          <target state="translated">一个可选的目标可以作为第二个参数传入,它将被设置为回调的 &quot;this&quot;。这是一个让你的函数访问触发事件的对象的好方法。当目标参数被使用时,回调方法将成为第三个参数。</target>
        </trans-unit>
        <trans-unit id="ad56b83e88617534d6efc0455f3cba813e7c5b29" translate="yes" xml:space="preserve">
          <source>An options hash with a &lt;code&gt;queryParams&lt;/code&gt; property may be provided as the final argument to add query parameters to the destination URL.</source>
          <target state="translated">可以提供带有 &lt;code&gt;queryParams&lt;/code&gt; 属性的选项哈希作为最终参数，以将查询参数添加到目标URL。</target>
        </trans-unit>
        <trans-unit id="e99bd8851a8c1e21e0899057936304d4f9f5ec02" translate="yes" xml:space="preserve">
          <source>An overridable method called when objects are instantiated. By default, does nothing unless it is overridden during class definition.</source>
          <target state="translated">在实例化对象时调用的可重写方法。默认情况下,什么都不做,除非在类定义时被重写。</target>
        </trans-unit>
        <trans-unit id="1a185885182ba5b812ef8fd0d0b7d413f174dd3d" translate="yes" xml:space="preserve">
          <source>An owner object.</source>
          <target state="translated">一个所有者对象。</target>
        </trans-unit>
        <trans-unit id="0eda0fc1a49d4da33d8de7ed9e252a116506debb" translate="yes" xml:space="preserve">
          <source>Analogous to the &lt;code&gt;loading&lt;/code&gt; event, you could manage the &lt;code&gt;error&lt;/code&gt; event at the application level to avoid writing the same code for multiple routes.</source>
          <target state="translated">与 &lt;code&gt;loading&lt;/code&gt; 事件类似，您可以在应用程序级别管理 &lt;code&gt;error&lt;/code&gt; 事件，以避免为多个路由编写相同的代码。</target>
        </trans-unit>
        <trans-unit id="b021894f7f8f33dda1f7bee7b102509639d55af1" translate="yes" xml:space="preserve">
          <source>Anatomy of an Ember App</source>
          <target state="translated">琥珀应用程序的解剖</target>
        </trans-unit>
        <trans-unit id="3270f7bfa9cfbfb16e0304d6f3e70d4952490dc0" translate="yes" xml:space="preserve">
          <source>And Ember makes use of our new helper function to replace the content inside the &lt;code&gt;{{ }}&lt;/code&gt; with the formatted amount.</source>
          <target state="translated">Ember利用我们的新辅助函数将 &lt;code&gt;{{ }}&lt;/code&gt; 的内容替换为格式化后的数量。</target>
        </trans-unit>
        <trans-unit id="a606b6661260a7a59324c809666dc5fe86f26a95" translate="yes" xml:space="preserve">
          <source>And calling &lt;code&gt;modelFor&lt;/code&gt; returned the result of the &lt;code&gt;model&lt;/code&gt; hook.</source>
          <target state="translated">并调用 &lt;code&gt;modelFor&lt;/code&gt; 返回 &lt;code&gt;model&lt;/code&gt; 挂钩的结果。</target>
        </trans-unit>
        <trans-unit id="d930c4217f924dfa7432e8ab0f217c1d57139a50" translate="yes" xml:space="preserve">
          <source>And can then be detected in an application and used to send the user to an &lt;code&gt;under-maintenance&lt;/code&gt; route:</source>
          <target state="translated">然后可以在应用程序中检测到并用于将用户发送到 &lt;code&gt;under-maintenance&lt;/code&gt; 路线：</target>
        </trans-unit>
        <trans-unit id="f808f9f869b6b3a7f5f8b0cb1aa83e5f8cc1f1ab" translate="yes" xml:space="preserve">
          <source>And here's what our generator prints out:</source>
          <target state="translated">这是我们的发电机打印出来的东西。</target>
        </trans-unit>
        <trans-unit id="def5b530cd508c093916372400b1e3caa792e7ae" translate="yes" xml:space="preserve">
          <source>And if the adapter for the &lt;code&gt;User&lt;/code&gt; model defines a &lt;code&gt;queryRecord()&lt;/code&gt; method that targets that endpoint:</source>
          <target state="translated">并且如果 &lt;code&gt;User&lt;/code&gt; 模型的适配器定义了针对该端点的 &lt;code&gt;queryRecord()&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="48305643331cfa0bcc55d0f34c5d29663ab786a6" translate="yes" xml:space="preserve">
          <source>And in that component, we can apply the class to the paragraph using &lt;code&gt;...attributes&lt;/code&gt;:</source>
          <target state="translated">在该组件中，我们可以使用 &lt;code&gt;...attributes&lt;/code&gt; 将类应用于段落：</target>
        </trans-unit>
        <trans-unit id="bf3e2f83e5ca47a26c3d390b8788c344f1177ca8" translate="yes" xml:space="preserve">
          <source>And in the component class, we'll add the &lt;code&gt;addMessage&lt;/code&gt; action. This action will create the new message from the text that the &lt;code&gt;&amp;lt;NewMessageInput&amp;gt;&lt;/code&gt; component gives us, and push it into the messages array. In order for the messages array to react to that change, we'll also need to convert it into an &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/EmberArray&quot;&gt;&lt;code&gt;EmberArray&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;EmberArray&lt;/code&gt; provides special methods that tell Ember when changes occur to the array itself.</source>
          <target state="translated">在组件类中，我们将添加 &lt;code&gt;addMessage&lt;/code&gt; 操作。此操作将根据 &lt;code&gt;&amp;lt;NewMessageInput&amp;gt;&lt;/code&gt; 组件提供给我们的文本创建新消息，并将其推送到messages数组中。为了使message数组对更改做出反应，我们还需要将其转换为&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/EmberArray&quot;&gt; &lt;code&gt;EmberArray&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;EmberArray&lt;/code&gt; 提供了一些特殊的方法，这些方法会在阵列本身发生更改时告诉Ember。</target>
        </trans-unit>
        <trans-unit id="3f6f1a793e66022cf16ad811eeaac6a0fae8ad16" translate="yes" xml:space="preserve">
          <source>And include it in our &lt;code&gt;application.hbs&lt;/code&gt; file.</source>
          <target state="translated">并将其包含在我们的 &lt;code&gt;application.hbs&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="e344023512079b32b7b9912bb0077c2b75831af0" translate="yes" xml:space="preserve">
          <source>And it returns a Cache instance that contains the most recent value of the helper. You can access the helper using &lt;code&gt;getValue()&lt;/code&gt; like any other cache. The cache is also destroyable, and using the &lt;code&gt;destroy()&lt;/code&gt; function on it will cause the helper to be torn down.</source>
          <target state="translated">并且它返回一个包含实例的最新值的Cache实例。您可以像使用其他任何缓存一样使用 &lt;code&gt;getValue()&lt;/code&gt; 访问帮助程序。缓存也是可 &lt;code&gt;destroy()&lt;/code&gt; 在其上使用destroy（）函数将导致助手被拆除。</target>
        </trans-unit>
        <trans-unit id="b7ccfb227e02188d1a6099f47dec4a2899ab2cb3" translate="yes" xml:space="preserve">
          <source>And our API might setup these relationships like so:</source>
          <target state="translated">而我们的API可能会这样设置这些关系。</target>
        </trans-unit>
        <trans-unit id="858587f15e1784f314286bdd2d9574a8f10a0682" translate="yes" xml:space="preserve">
          <source>And our test might look like this:</source>
          <target state="translated">而我们的测试可能是这样的。</target>
        </trans-unit>
        <trans-unit id="bd3b5d4c652aa41a2bf3cb0e322c393e12452e25" translate="yes" xml:space="preserve">
          <source>And putting it after:</source>
          <target state="translated">而把它放在后。</target>
        </trans-unit>
        <trans-unit id="093ac7197a3ab6824a8db25169552604bf3185ba" translate="yes" xml:space="preserve">
          <source>And so we need to change it to look like:</source>
          <target state="translated">所以我们需要把它改成这样。</target>
        </trans-unit>
        <trans-unit id="56cfc8651344f1ea80613714a0d182bc8475717d" translate="yes" xml:space="preserve">
          <source>And that's it!</source>
          <target state="translated">就是这样!</target>
        </trans-unit>
        <trans-unit id="3c3b783be1e07defa8d5fdd993d1c5f973e18323" translate="yes" xml:space="preserve">
          <source>And the content passed in between the brackets of the component would be rendered in the same place as the &lt;code&gt;{{yield}}&lt;/code&gt; within it, replacing it.</source>
          <target state="translated">并且在组件方括号之间传递的内容将与其中的 &lt;code&gt;{{yield}}&lt;/code&gt; 呈现在相同的位置，以替换它。</target>
        </trans-unit>
        <trans-unit id="41bf132516ee160b661225a174fe8ef6b99ab116" translate="yes" xml:space="preserve">
          <source>And the following application code:</source>
          <target state="translated">而下面的应用代码。</target>
        </trans-unit>
        <trans-unit id="bb7c832f55b6bf0ad54136a9b9a4c99e15beebd3" translate="yes" xml:space="preserve">
          <source>And the following component template:</source>
          <target state="translated">而下面的组件模板。</target>
        </trans-unit>
        <trans-unit id="bfd57da9ac459cb354e27395ee58a9b5ea9450b4" translate="yes" xml:space="preserve">
          <source>And then add the &lt;code&gt;{{outlet}}&lt;/code&gt; helper to your template where you want the nested template to display:</source>
          <target state="translated">然后将 &lt;code&gt;{{outlet}}&lt;/code&gt; 帮助程序添加到模板中要显示嵌套模板的位置：</target>
        </trans-unit>
        <trans-unit id="f11afecc22f8319d64744b13769de65d8b8e7542" translate="yes" xml:space="preserve">
          <source>And then let's update our new template (&lt;code&gt;/app/templates/rentals.hbs&lt;/code&gt;) with some initial content. We'll come back to this page in a bit to add in the actual rental properties.</source>
          <target state="translated">然后让我们用一些初始内容更新我们的新模板（ &lt;code&gt;/app/templates/rentals.hbs&lt;/code&gt; ）。我们将稍后返回此页面以添加实际的出租物业。</target>
        </trans-unit>
        <trans-unit id="7de96cbb44a1491ee841ac09e0486623ee14a153" translate="yes" xml:space="preserve">
          <source>And then use it in the component's template:</source>
          <target state="translated">然后在组件的模板中使用它。</target>
        </trans-unit>
        <trans-unit id="93bb7cea089a59a66a8c88a8ec0b2a43d54d618b" translate="yes" xml:space="preserve">
          <source>And two named arguments:</source>
          <target state="translated">还有两个命名的论点。</target>
        </trans-unit>
        <trans-unit id="22187ae87c41840c4ba6a0cc6a831932b5588f5c" translate="yes" xml:space="preserve">
          <source>And we're all done! If we try to click the plus, minus, or double buttons in any order, we can watch as these three outputs stay up-to-date perfectly.</source>
          <target state="translated">我们就完成了! 如果我们尝试以任何顺序点击加号、减号或双号按钮,我们就可以看着这三个输出完美地保持最新状态。</target>
        </trans-unit>
        <trans-unit id="f14ab158b4527060b12f9265e1c0a0852d58cc34" translate="yes" xml:space="preserve">
          <source>And without block params:</source>
          <target state="translated">而且没有区块参数。</target>
        </trans-unit>
        <trans-unit id="14c291e4ba7a0d7d9d4db7adb6563d3f90f88340" translate="yes" xml:space="preserve">
          <source>And you attempted to save a record that did not validate on the backend:</source>
          <target state="translated">而你试图保存的记录,在后台没有验证。</target>
        </trans-unit>
        <trans-unit id="0f667d37fa5f016a26f06a9872a7f2160c41fbaa" translate="yes" xml:space="preserve">
          <source>And you can optionally override the following methods:</source>
          <target state="translated">而且你可以选择性地覆盖以下方法。</target>
        </trans-unit>
        <trans-unit id="fbb92e00845dc889a1c690c9730efd2d0c510419" translate="yes" xml:space="preserve">
          <source>Angle Bracket Syntax</source>
          <target state="translated">角括号语法</target>
        </trans-unit>
        <trans-unit id="ad055c150c2fec190996fe9d3d2d911b44e7939c" translate="yes" xml:space="preserve">
          <source>Angle Brackets have a number of benefits:</source>
          <target state="translated">角钢支架有很多好处。</target>
        </trans-unit>
        <trans-unit id="be01cf55d15a848b8d1511a18b96dff878bd9334" translate="yes" xml:space="preserve">
          <source>Angle bracket syntax works for invoking components of any type, whether they are classic components, Glimmer components, or any other type of component.</source>
          <target state="translated">角括号语法适用于调用任何类型的组件,无论是经典组件、Glimmer组件,还是任何其他类型的组件。</target>
        </trans-unit>
        <trans-unit id="9950e90df2c4c70fa95d66b36d973c47cc5723e3" translate="yes" xml:space="preserve">
          <source>Anonymous AMD JavaScript modules</source>
          <target state="translated">匿名的AMD JavaScript模块</target>
        </trans-unit>
        <trans-unit id="d2c53a5609268d8cc3b657e64edfd02e22ffa9dc" translate="yes" xml:space="preserve">
          <source>Another common task to perform on an enumerable is to take the enumerable as input, and return an Array after filtering it based on some criteria.</source>
          <target state="translated">另一个常见的任务是将enumerable作为输入,并根据一些标准过滤后返回一个Array。</target>
        </trans-unit>
        <trans-unit id="d52db59bec7e29f9ab90f3fbd743f54f3368a885" translate="yes" xml:space="preserve">
          <source>Another difference is that unlike &lt;code&gt;_super()&lt;/code&gt;, if the method doesn't exist on the parent class then an error will be thrown. In most cases, the method should exist or not, and you shouldn't need to guard it one way or the other.</source>
          <target state="translated">另一个区别是，与 &lt;code&gt;_super()&lt;/code&gt; 不同，如果该方法在父类上不存在，则将引发错误。在大多数情况下，该方法应该存在或不存在，并且您不需要一种或另一种方式来保护它。</target>
        </trans-unit>
        <trans-unit id="d8461c31aaae42ec56856084e31327466738e04d" translate="yes" xml:space="preserve">
          <source>Another use case for pushing in records is if your application has a streaming connection to a backend. If a record is created or modified, you want to update the UI immediately.</source>
          <target state="translated">推送记录的另一个用例是,如果你的应用程序与后端有一个流式连接。如果一条记录被创建或修改,你想立即更新UI。</target>
        </trans-unit>
        <trans-unit id="1068c7d1ed158eed896ddf549ac83db6a4145848" translate="yes" xml:space="preserve">
          <source>Another way that a tracked property could be updated is asynchronously, if you're sending a request to the server. For instance, maybe we would want to load the user's preferred language:</source>
          <target state="translated">另一种可以更新跟踪属性的方式是异步更新,如果你正在向服务器发送一个请求。例如,也许我们想加载用户的首选语言。</target>
        </trans-unit>
        <trans-unit id="399d18ba6bf9bfa67cb5837c23ceeeee5ffa2afc" translate="yes" xml:space="preserve">
          <source>Another way to inject a service is to provide the name of the service as an argument to the decorator.</source>
          <target state="translated">注入服务的另一种方法是将服务的名称作为参数提供给装饰器。</target>
        </trans-unit>
        <trans-unit id="ea03de2438b80b08c0d2d6fd50c0f66b720e4691" translate="yes" xml:space="preserve">
          <source>Another way to inject a service is to provide the name of the service as the argument.</source>
          <target state="translated">另一种注入服务的方式是提供服务的名称作为参数。</target>
        </trans-unit>
        <trans-unit id="e550138b92434dcdf6b44555879aa1edcad0aa02" translate="yes" xml:space="preserve">
          <source>Another way to preserve native event behaviors and use an action, is to assign a (closure) action to an inline event handler. Consider the template below which includes an &lt;code&gt;onclick&lt;/code&gt; handler on a &lt;code&gt;button&lt;/code&gt; element:</source>
          <target state="translated">保留本机事件行为和使用操作的另一种方法是将（关闭）操作分配给内联事件处理程序。考虑下面的模板，该模板在 &lt;code&gt;button&lt;/code&gt; 元素上包括一个 &lt;code&gt;onclick&lt;/code&gt; 处理程序：</target>
        </trans-unit>
        <trans-unit id="7cb070bee6806669fac22f1d37552f007d2c7985" translate="yes" xml:space="preserve">
          <source>Another way to say this is that the &lt;code&gt;value&lt;/code&gt; property of &lt;code&gt;input&lt;/code&gt; is &lt;a href=&quot;https://guides.emberjs.com/object-model/bindings/&quot;&gt;&lt;strong&gt;bound&lt;/strong&gt;&lt;/a&gt; to the &lt;code&gt;value&lt;/code&gt; property of the component. If the property changes, either by the user typing in the input field, or by assigning a new value to it in our program, the new value of the property is present in both the rendered web page and in the code.</source>
          <target state="translated">以另一种说法是， &lt;code&gt;value&lt;/code&gt; 的财产 &lt;code&gt;input&lt;/code&gt; 被&lt;a href=&quot;https://guides.emberjs.com/object-model/bindings/&quot;&gt;&lt;strong&gt;绑定&lt;/strong&gt;&lt;/a&gt;到 &lt;code&gt;value&lt;/code&gt; 组件的属性。如果通过用户在输入字段中键入或通过在我们的程序中为其分配新值来更改属性，则该属性的新值将同时出现在呈现的网页和代码中。</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="61705f9b76ff585c3fc229ef27f86a4bd443f9b1" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;belongsTo&lt;/code&gt; relationships in the JSON representation should be the dasherized version of the property's name. For example, if you have a model:</source>
          <target state="translated">JSON表示形式中的所有 &lt;code&gt;belongsTo&lt;/code&gt; 关系都应为属性名称的反划线形式。例如，如果您有一个模型：</target>
        </trans-unit>
        <trans-unit id="6c59b3640b4d3b9b99e2c131e33c0fdea90e9d34" translate="yes" xml:space="preserve">
          <source>Any adapter in &lt;code&gt;app/adapters/&lt;/code&gt; can be looked up by &lt;code&gt;name&lt;/code&gt; using &lt;code&gt;store.adapterFor(name)&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;store.adapterFor(name)&lt;/code&gt; 来按 &lt;code&gt;name&lt;/code&gt; 查找 &lt;code&gt;app/adapters/&lt;/code&gt; 任何适配器。</target>
        </trans-unit>
        <trans-unit id="4aa59a9bfdd546f74777b72ed6d3a1e7e76147ff" translate="yes" xml:space="preserve">
          <source>Any additional arguments you wish to pass to the method.</source>
          <target state="translated">任何你想传递给该方法的附加参数。</target>
        </trans-unit>
        <trans-unit id="dc7cbe307affe607de815c79b0d58e0d2d610aaf" translate="yes" xml:space="preserve">
          <source>Any addon that will provide UI elements to the application should be evaluated for accessibility before use.</source>
          <target state="translated">任何将为应用程序提供UI元素的插件都应该在使用前进行无障碍性评估。</target>
        </trans-unit>
        <trans-unit id="e8d93ab8dd51e3f38d20c35d5f03147f74fccc7b" translate="yes" xml:space="preserve">
          <source>Any callbacks registered with &lt;code&gt;onInjectHelpers&lt;/code&gt; will be called once the helpers have been injected.</source>
          <target state="translated">一旦注入了助手，将调用在 &lt;code&gt;onInjectHelpers&lt;/code&gt; 上注册的所有回调。</target>
        </trans-unit>
        <trans-unit id="a072dbbde5d03120c8988ec1ff83fbcc8adb2d48" translate="yes" xml:space="preserve">
          <source>Any instances created via the factory's &lt;code&gt;.create()&lt;/code&gt; method &lt;em&gt;must&lt;/em&gt; be destroyed manually by the caller of &lt;code&gt;.create()&lt;/code&gt;. Typically, this is done during the creating objects own &lt;code&gt;destroy&lt;/code&gt; or &lt;code&gt;willDestroy&lt;/code&gt; methods.</source>
          <target state="translated">通过工厂的 &lt;code&gt;.create()&lt;/code&gt; 方法创建的任何实例都&lt;em&gt;必须&lt;/em&gt;由 &lt;code&gt;.create()&lt;/code&gt; 的调用者手动销毁。通常，这是在创建对象自己的 &lt;code&gt;destroy&lt;/code&gt; 或 &lt;code&gt;willDestroy&lt;/code&gt; 方法期间完成的。</target>
        </trans-unit>
        <trans-unit id="2c6784962c5c85317454cd4e07dd7e38080869c4" translate="yes" xml:space="preserve">
          <source>Any object that has this mixin applied can be used in observer operations. That includes &lt;code&gt;Ember.Object&lt;/code&gt; and most objects you will interact with as you write your Ember application.</source>
          <target state="translated">任何应用了此mixin的对象都可以在观察者操作中使用。其中包括 &lt;code&gt;Ember.Object&lt;/code&gt; 和编写Ember应用程序时将与之交互的大多数对象。</target>
        </trans-unit>
        <trans-unit id="ee3a012d09f7745a765f1f81efbddddba645caa4" translate="yes" xml:space="preserve">
          <source>Any object that has this mixin applied can be used in observer operations. That includes &lt;code&gt;EmberObject&lt;/code&gt; and most objects you will interact with as you write your Ember application.</source>
          <target state="translated">任何应用了此mixin的对象都可以在观察者操作中使用。其中包括 &lt;code&gt;EmberObject&lt;/code&gt; 和编写Ember应用程序时将与之交互的大多数对象。</target>
        </trans-unit>
        <trans-unit id="b1cf3a8104333652f9a4172ac27fadbfcd65150a" translate="yes" xml:space="preserve">
          <source>Any other status codes will be treated as an &quot;adapter error&quot;. The request promise will be rejected, similarly to the &quot;invalid&quot; case, but with an instance of &lt;code&gt;AdapterError&lt;/code&gt; instead.</source>
          <target state="translated">任何其他状态代码将被视为&amp;ldquo;适配器错误&amp;rdquo;。与&amp;ldquo;无效&amp;rdquo;的情况类似，请求承诺将被拒绝，但是使用 &lt;code&gt;AdapterError&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="5c13cc317849a06291912ab3d658733cd2683f03" translate="yes" xml:space="preserve">
          <source>Any other status codes will be treated as an &quot;adapter error&quot;. The request promise will be rejected, similarly to the &quot;invalid&quot; case, but with an instance of &lt;code&gt;DS.AdapterError&lt;/code&gt; instead.</source>
          <target state="translated">任何其他状态代码将被视为&amp;ldquo;适配器错误&amp;rdquo;。与&amp;ldquo;无效&amp;rdquo;的情况类似，该请求承诺将被拒绝，但使用 &lt;code&gt;DS.AdapterError&lt;/code&gt; 实例代替。</target>
        </trans-unit>
        <trans-unit id="bf1406d398e033ac639a1464581a15a5e25635d4" translate="yes" xml:space="preserve">
          <source>Any other status codes will be treated as an adapter error. The request promise will be rejected, similarly to the invalid case, but with an instance of &lt;code&gt;AdapterError&lt;/code&gt; instead.</source>
          <target state="translated">任何其他状态代码将被视为适配器错误。与无效情况类似，该请求承诺将被拒绝，但使用 &lt;code&gt;AdapterError&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="c6df25135550e72ebbfba360e5b60bb4aa2e8483" translate="yes" xml:space="preserve">
          <source>Any other status codes will be treated as an adapter error. The request promise will be rejected, similarly to the invalid case, but with an instance of &lt;code&gt;DS.AdapterError&lt;/code&gt; instead.</source>
          <target state="translated">任何其他状态代码将被视为适配器错误。与无效情况类似，该请求承诺将被拒绝，但使用 &lt;code&gt;DS.AdapterError&lt;/code&gt; 实例代替。</target>
        </trans-unit>
        <trans-unit id="d902258615b966c9b7918a4dabf813ec90db7e42" translate="yes" xml:space="preserve">
          <source>Any serializer in &lt;code&gt;app/serializers/&lt;/code&gt; can be looked up by &lt;code&gt;name&lt;/code&gt; using &lt;code&gt;store.serializerFor(name)&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;store.serializerFor(name)&lt;/code&gt; 来按 &lt;code&gt;name&lt;/code&gt; 查找 &lt;code&gt;app/serializers/&lt;/code&gt; 任何序列化器。</target>
        </trans-unit>
        <trans-unit id="964c6055e03db34dbdbce82677a4153ec608b92b" translate="yes" xml:space="preserve">
          <source>Any time the &quot;name&quot; property on the component changes, the DOM will be updated.</source>
          <target state="translated">只要组件上的 &quot;name &quot;属性发生变化,DOM就会被更新。</target>
        </trans-unit>
        <trans-unit id="32134b0e43d18da466539ef39c3442aa4a2e7c83" translate="yes" xml:space="preserve">
          <source>Any | Promise&amp;lt;any&amp;gt;</source>
          <target state="translated">任何| 承诺&amp;lt;任何&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0b5958b0f53cb499388dd9ee04a106a30b02c5d1" translate="yes" xml:space="preserve">
          <source>Apache</source>
          <target state="translated">Apache</target>
        </trans-unit>
        <trans-unit id="b291beb8793f4f3308c463951165dad483715a6c" translate="yes" xml:space="preserve">
          <source>Application</source>
          <target state="translated">Application</target>
        </trans-unit>
        <trans-unit id="c84b28805bf79f21bca3da75574bdcfebfd9553b" translate="yes" xml:space="preserve">
          <source>Application Considerations</source>
          <target state="translated">应用方面的考虑</target>
        </trans-unit>
        <trans-unit id="db44f1a1d5a0bed952609e71cb45a89b07826b89" translate="yes" xml:space="preserve">
          <source>Application Initializers</source>
          <target state="translated">应用程序初始化器</target>
        </trans-unit>
        <trans-unit id="28077dc5dca8cfd41ec7bf28339c995ce45280cf" translate="yes" xml:space="preserve">
          <source>Application Instance Initializers</source>
          <target state="translated">应用实例初始化器</target>
        </trans-unit>
        <trans-unit id="41cd6078ee3f41ce5693a80f97b81ee8bc05d2b3" translate="yes" xml:space="preserve">
          <source>Application Tests</source>
          <target state="translated">应用测试</target>
        </trans-unit>
        <trans-unit id="02fbb2c871fdfdcb61f55fa6840fac8c9796223c" translate="yes" xml:space="preserve">
          <source>Application initializers are run as your application boots, and provide the primary means to configure &lt;a href=&quot;../dependency-injection&quot;&gt;dependency injections&lt;/a&gt; in your application.</source>
          <target state="translated">应用程序初始化程序在应用程序启动时运行，并提供了在应用程序中配置&lt;a href=&quot;../dependency-injection&quot;&gt;依赖项注入&lt;/a&gt;的主要方法。</target>
        </trans-unit>
        <trans-unit id="c1ae28ca7909073017188af82529c637aece67b6" translate="yes" xml:space="preserve">
          <source>Application initializers can be created with Ember CLI's &lt;code&gt;initializer&lt;/code&gt; generator:</source>
          <target state="translated">可以使用Ember CLI的 &lt;code&gt;initializer&lt;/code&gt; 生成器创建应用程序初始化程序：</target>
        </trans-unit>
        <trans-unit id="440287943b422ada5a57c6872c80bdf5f6e2f6bf" translate="yes" xml:space="preserve">
          <source>Application initializers can be used for a variety of reasons including:</source>
          <target state="translated">应用初始化器可用于多种原因,包括:1:</target>
        </trans-unit>
        <trans-unit id="0327b249608fb10533fa4bc5c32423fb329e7456" translate="yes" xml:space="preserve">
          <source>Application instance initializers are run as an application instance is loaded. They provide a way to configure the initial state of your application, as well as to set up dependency injections that are local to the application instance (e.g. A/B testing configurations).</source>
          <target state="translated">应用程序实例初始化器在应用程序实例加载时运行。它们提供了一种方法来配置应用程序的初始状态,以及设置应用程序实例的本地依赖注入(例如A/B测试配置)。</target>
        </trans-unit>
        <trans-unit id="bd764e59f8aa96def75203a863b05b52311f69c0" translate="yes" xml:space="preserve">
          <source>Application instance initializers can be created with Ember CLI's &lt;code&gt;instance-initializer&lt;/code&gt; generator:</source>
          <target state="translated">可以使用Ember CLI的 &lt;code&gt;instance-initializer&lt;/code&gt; 生成器创建应用程序实例初始化程序：</target>
        </trans-unit>
        <trans-unit id="f43feef2b58cdfeed8d85c69f39aeaa788357d99" translate="yes" xml:space="preserve">
          <source>Application is not Detected Without Reload</source>
          <target state="translated">在没有重新加载的情况下,无法检测到应用程序。</target>
        </trans-unit>
        <trans-unit id="604e339cdd3f3c07c450870cce58cb44984d68bf" translate="yes" xml:space="preserve">
          <source>Application tests (previously known as acceptance tests)</source>
          <target state="translated">应用测试(以前称为验收测试)</target>
        </trans-unit>
        <trans-unit id="8e1affc69c98578fb01fd4087754635f88ebfbd2" translate="yes" xml:space="preserve">
          <source>Application tests are slower than unit and rendering tests because they create an instance of the Ember application.</source>
          <target state="translated">应用测试比单元测试和渲染测试慢,因为它们会创建一个Ember应用的实例。</target>
        </trans-unit>
        <trans-unit id="648fe13fc82c6051d3bb53145789d54915e9d45f" translate="yes" xml:space="preserve">
          <source>Application tests help you see how well different components interact with each other. For nested or contextual components, you can get by with rendering tests. If components are unrelated, however, application tests may be the only way.</source>
          <target state="translated">应用测试可以帮助你了解不同组件之间的交互情况。对于嵌套的或上下文的组件,你可以通过渲染测试来解决。然而,如果组件是不相关的,应用测试可能是唯一的方法。</target>
        </trans-unit>
        <trans-unit id="573a080ef2363bb5ed2ae5d7c4dbda02e5cb947b" translate="yes" xml:space="preserve">
          <source>ApplicationInstance</source>
          <target state="translated">ApplicationInstance</target>
        </trans-unit>
        <trans-unit id="6151f974f0ae8d7efd8100118eeb0f606e6e512a" translate="yes" xml:space="preserve">
          <source>ApplicationInstance.BootOptions</source>
          <target state="translated">ApplicationInstance.BootOptions</target>
        </trans-unit>
        <trans-unit id="e1f46a19d20b853668d9e13a3d5f5eb836a9cb36" translate="yes" xml:space="preserve">
          <source>Applications and Instances</source>
          <target state="translated">应用和实例</target>
        </trans-unit>
        <trans-unit id="58b72e59fa1d3f8773afc2294edde2f653d27e9a" translate="yes" xml:space="preserve">
          <source>Applications and application instances each serve a role in Ember's DI implementation.</source>
          <target state="translated">应用程序和应用程序实例在Ember的DI实现中各司其职。</target>
        </trans-unit>
        <trans-unit id="43322b8c083c52b41ec49152dfdbce1ae6848d05" translate="yes" xml:space="preserve">
          <source>Applications whose API's structure endpoint URLs &lt;em&gt;very close to&lt;/em&gt; or &lt;em&gt;exactly&lt;/em&gt; the &lt;strong&gt;REST&lt;/strong&gt; or &lt;strong&gt;JSON:API&lt;/strong&gt; convention, the &lt;code&gt;@ember-data/adapter&lt;/code&gt; package contains implementations these applications can extend.</source>
          <target state="translated">应用其API的结构端点的URL&lt;em&gt;非常接近&lt;/em&gt;或&lt;em&gt;正好&lt;/em&gt;在&lt;strong&gt;REST&lt;/strong&gt;或&lt;strong&gt;JSON：API&lt;/strong&gt;惯例， &lt;code&gt;@ember-data/adapter&lt;/code&gt; 包中包含实现这些应用程序可以延长。</target>
        </trans-unit>
        <trans-unit id="77cbe978decf7e18ac53e8ff64911f09e83509bc" translate="yes" xml:space="preserve">
          <source>Architecture Overview</source>
          <target state="translated">架构概述</target>
        </trans-unit>
        <trans-unit id="4bc8e2f847bb9ebb4315a87b3fcf3b69861d47bf" translate="yes" xml:space="preserve">
          <source>Are you wondering what the Octane equivalent is for some classic Ember features? Have a look at the &lt;a href=&quot;https://ember-learn.github.io/ember-octane-vs-classic-cheat-sheet/&quot;&gt;cheat sheet&lt;/a&gt;!</source>
          <target state="translated">您是否想知道某些经典Ember功能的Octane等效功能是什么？看看&lt;a href=&quot;https://ember-learn.github.io/ember-octane-vs-classic-cheat-sheet/&quot;&gt;备忘单&lt;/a&gt;！</target>
        </trans-unit>
        <trans-unit id="09cbbe460eb0d2e33ef2f69fa66f50d49a830be2" translate="yes" xml:space="preserve">
          <source>Argument Defaults</source>
          <target state="translated">参数默认值</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="fb3a7abeb9142225b4ee4fbb50f25cf053c3bf3f" translate="yes" xml:space="preserve">
          <source>Arguments always refer to the original value that was passed in, so you don't have to track down confusing code in hooks or computed property definitions that modifies the value of the argument.</source>
          <target state="translated">参数总是引用传入的原始值,所以你不必在钩子或计算的属性定义中追踪修改参数值的混乱代码。</target>
        </trans-unit>
        <trans-unit id="9a6f65ca0bd8caddf93848c7f15dcb21e290e761" translate="yes" xml:space="preserve">
          <source>Arguments are also namespaced on &lt;code&gt;this.args&lt;/code&gt; within Glimmer components, which is an immutable object. This means that:</source>
          <target state="translated">在Glimmer组件中的 &lt;code&gt;this.args&lt;/code&gt; 上，参数也是命名空间，这是一个不可变的对象。这意味着：</target>
        </trans-unit>
        <trans-unit id="611f09a5ce77eceb72172af01ffa01cee12813fe" translate="yes" xml:space="preserve">
          <source>Arguments passed when using &lt;code&gt;new&lt;/code&gt; will be accessible in the &lt;code&gt;constructor&lt;/code&gt; of the class:</source>
          <target state="translated">使用 &lt;code&gt;new&lt;/code&gt; 时传递的参数可以在该类的 &lt;code&gt;constructor&lt;/code&gt; 中访问：</target>
        </trans-unit>
        <trans-unit id="39b312ee2ba740cc6cf8c66435bc1ab39c75b14a" translate="yes" xml:space="preserve">
          <source>Arguments should match those passed to &lt;code&gt;Ember.addListener&lt;/code&gt;.</source>
          <target state="translated">参数应与传递给 &lt;code&gt;Ember.addListener&lt;/code&gt; 的参数匹配。</target>
        </trans-unit>
        <trans-unit id="99fa043302210093a135d04cf8a73aa2c0b569e3" translate="yes" xml:space="preserve">
          <source>Arguments should match those passed to &lt;code&gt;addListener&lt;/code&gt;.</source>
          <target state="translated">参数应与传递给 &lt;code&gt;addListener&lt;/code&gt; 的参数匹配。</target>
        </trans-unit>
        <trans-unit id="21a55ff69bb1ff3fd2c38215faa9031998bc70e0" translate="yes" xml:space="preserve">
          <source>Arguments, like &lt;code&gt;{{@name}}&lt;/code&gt;, are automatically tracked, so if they change and are used somewhere in your component, the component will update accordingly.</source>
          <target state="translated">像 &lt;code&gt;{{@name}}&lt;/code&gt; 之类的参数会被自动跟踪，因此，如果它们发生更改并在组件中的某个位置使用，则组件将相应更新。</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="e72896fe1492e71f21a94a64857102dbaaa2693c" translate="yes" xml:space="preserve">
          <source>Array of promises.</source>
          <target state="translated">一系列的承诺。</target>
        </trans-unit>
        <trans-unit id="c8ae3652fe542bc0967199e29e0acc4616cf7bcb" translate="yes" xml:space="preserve">
          <source>Array&amp;lt;Array&amp;lt;Snapshot&amp;gt;&amp;gt;</source>
          <target state="translated">Array&amp;lt;Array&amp;lt;Snapshot&amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="554ec7f9295c25b13a23965968534f530c666139" translate="yes" xml:space="preserve">
          <source>Array&amp;lt;Snapshot&amp;gt;</source>
          <target state="translated">Array&amp;lt;Snapshot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6bc9c855eef6ffa566a6c76708b7ae43b8ea1d71" translate="yes" xml:space="preserve">
          <source>Array&amp;lt;string&amp;gt;</source>
          <target state="translated">Array&amp;lt;string&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3e3da0e5afcc95be3e15b8063c5fa0302b0266c1" translate="yes" xml:space="preserve">
          <source>Array.[]</source>
          <target state="translated">Array.[]</target>
        </trans-unit>
        <trans-unit id="aba67a4b44f8228cd28b9688b767e7ce828d9382" translate="yes" xml:space="preserve">
          <source>ArrayProxy</source>
          <target state="translated">ArrayProxy</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="08461a5115a2a0f38cef54d472eed75041f3b96f" translate="yes" xml:space="preserve">
          <source>Arrays and objects defined directly on any &lt;code&gt;Ember.Object&lt;/code&gt; are shared across all instances of that class.</source>
          <target state="translated">直接在任何 &lt;code&gt;Ember.Object&lt;/code&gt; 上定义的数组和对象在该类的所有实例之间共享。</target>
        </trans-unit>
        <trans-unit id="5e040cb0b00cdbc7434b067156a33541a49f7887" translate="yes" xml:space="preserve">
          <source>Arrays are another example of a type of object where you can't enumerate every possible value - after all, there are an infinite number of integers (though you &lt;em&gt;may&lt;/em&gt; run out of bits in your computer at some point!). Instead, you can continue to use &lt;code&gt;EmberArray&lt;/code&gt;, which will continue to work with tracking and will cause any dependencies that use it to invalidate correctly.</source>
          <target state="translated">数组是对象类型的另一个示例，其中您无法枚举每个可能的值-毕竟，存在无限数量的整数（尽管有时您的计算机中的位&lt;em&gt;可能&lt;/em&gt;用完了！）。相反，您可以继续使用 &lt;code&gt;EmberArray&lt;/code&gt; ，它将继续与跟踪一起使用，并会导致使用它的所有依赖项导致正确无效。</target>
        </trans-unit>
        <trans-unit id="51fca31fb04e58d6c6096ec6d3f367922c2d2c5c" translate="yes" xml:space="preserve">
          <source>Array|Promise</source>
          <target state="translated">Array|Promise</target>
        </trans-unit>
        <trans-unit id="7f7804c4ad6b8ec101018686c9b412921306b2e4" translate="yes" xml:space="preserve">
          <source>As Ember CLI runs, it takes the &lt;code&gt;ember-tutorial&lt;/code&gt; CSS file and puts it in a file called &lt;code&gt;vendor.css&lt;/code&gt;. The &lt;code&gt;vendor.css&lt;/code&gt; file is referenced in &lt;code&gt;app/index.html&lt;/code&gt;, making the styles available at runtime.</source>
          <target state="translated">在Ember CLI运行时，它将使用 &lt;code&gt;ember-tutorial&lt;/code&gt; CSS文件并将其放入名为 &lt;code&gt;vendor.css&lt;/code&gt; 的文件中。该 &lt;code&gt;vendor.css&lt;/code&gt; 文件中引用 &lt;code&gt;app/index.html&lt;/code&gt; ，使得在运行时可用的样式。</target>
        </trans-unit>
        <trans-unit id="3addcbfe9779e3c434f4307dffe878d46aed0782" translate="yes" xml:space="preserve">
          <source>As a result of this type injection, all factories of the type &lt;code&gt;route&lt;/code&gt; will be instantiated with the property &lt;code&gt;logger&lt;/code&gt; injected. The value of &lt;code&gt;logger&lt;/code&gt; will come from the factory named &lt;code&gt;logger:main&lt;/code&gt;.</source>
          <target state="translated">作为这种类型注入的结果，将使用注入的属性 &lt;code&gt;logger&lt;/code&gt; 实例化所有类型 &lt;code&gt;route&lt;/code&gt; 工厂。 &lt;code&gt;logger&lt;/code&gt; 的值将来自名为 &lt;code&gt;logger:main&lt;/code&gt; 的工厂。</target>
        </trans-unit>
        <trans-unit id="311ea72dae21bedf22e80bf4e5eb3f57f08f802c" translate="yes" xml:space="preserve">
          <source>As a user looks through our list of rentals, they may want to have some interactive options to help them make a decision. Let's add the ability to toggle the size of the image for each rental. To do this, we'll use a component.</source>
          <target state="translated">当用户浏览我们的租房列表时,他们可能希望有一些互动选项来帮助他们做出决定。让我们为每个租房添加切换图片大小的功能。要做到这一点,我们将使用一个组件。</target>
        </trans-unit>
        <trans-unit id="122dcca7a8a0de9f8e49a807d3d18e056bffe6f9" translate="yes" xml:space="preserve">
          <source>As an analogy, JSON API is to JavaScript apps and API servers what SQL is to server-side frameworks and databases. Popular frameworks like Ruby on Rails, Laravel, Django, Spring and more work out of the box with many different databases, like MySQL, PostgreSQL, SQL Server, and more.</source>
          <target state="translated">打个比方,JSON API之于JavaScript应用和API服务器,就像SQL之于服务器端框架和数据库。像Ruby on Rails、Laravel、Django、Spring等流行的框架,都能与MySQL、PostgreSQL、SQL Server等多种不同的数据库开箱即用。</target>
        </trans-unit>
        <trans-unit id="a9a6716ba26e03617c92f53fd2352147c7252db8" translate="yes" xml:space="preserve">
          <source>As an application grows in size, it will have many templates backed by controllers and components.</source>
          <target state="translated">随着应用程序规模的扩大,它将拥有许多由控制器和组件支持的模板。</target>
        </trans-unit>
        <trans-unit id="aa189213dcb346106d5e9872d77e6451881b369f" translate="yes" xml:space="preserve">
          <source>As an example, consider the router:</source>
          <target state="translated">举个例子,考虑路由器。</target>
        </trans-unit>
        <trans-unit id="1576ebe2d9b67dd183a72d25dc37d740c1367d47" translate="yes" xml:space="preserve">
          <source>As an exercise, here is the above &lt;code&gt;format-currency&lt;/code&gt; helper re-factored into a class-based helper:</source>
          <target state="translated">作为练习，这是将上述 &lt;code&gt;format-currency&lt;/code&gt; 帮助程序重构为基于类的帮助程序：</target>
        </trans-unit>
        <trans-unit id="abfeef8dd340e62de1345b3bdb4f7d25f54691a8" translate="yes" xml:space="preserve">
          <source>As another example, let's make a helper utilizing an authentication service that welcomes users by their name if they're logged in:</source>
          <target state="translated">再举一个例子,让我们做一个利用认证服务的帮助程序,如果用户登录了,就用他们的名字欢迎他们。</target>
        </trans-unit>
        <trans-unit id="da0df0da65c3ae7e6622548b6eab04753b236bfe" translate="yes" xml:space="preserve">
          <source>As before when we created the &lt;a href=&quot;../simple-component&quot;&gt;&lt;code&gt;rental-listing&lt;/code&gt; component&lt;/a&gt;, the &quot;generate component&quot; CLI command creates</source>
          <target state="translated">和以前一样，当我们创建&lt;a href=&quot;../simple-component&quot;&gt; &lt;code&gt;rental-listing&lt;/code&gt; 组件时&lt;/a&gt;，&amp;ldquo; generate component&amp;rdquo; CLI命令会创建</target>
        </trans-unit>
        <trans-unit id="e4f8b74691d28ef085474c5c7e3a4ee5281aefb5" translate="yes" xml:space="preserve">
          <source>As components are rendered, re-rendered and finally removed, Ember provides &lt;em&gt;lifecycle hooks&lt;/em&gt; that allow you to run code at specific times in a component's life.</source>
          <target state="translated">在渲染，重新渲染并最终删除组件时，Ember提供了&lt;em&gt;生命周期挂钩&lt;/em&gt;，使您可以在组件生命周期中的特定时间运行代码。</target>
        </trans-unit>
        <trans-unit id="c976c994a38ead0b719af8c1f9b88cc662ef8b66" translate="yes" xml:space="preserve">
          <source>As for the &lt;code&gt;current-user&lt;/code&gt; class, it may have been just one of a few classes that can be applied to the &lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt; element. Let's use &lt;code&gt;...attributes&lt;/code&gt; to apply the &lt;code&gt;current-user&lt;/code&gt; class.</source>
          <target state="translated">对于 &lt;code&gt;current-user&lt;/code&gt; 类，它可能只是可以应用于 &lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt; 元素的少数几个类之一。让我们使用 &lt;code&gt;...attributes&lt;/code&gt; 来应用 &lt;code&gt;current-user&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="49eff526078dcae910ad5947d7b287b225607e5e" translate="yes" xml:space="preserve">
          <source>As illustrated in the diagram above, the adapter cannot always return the requested record immediately. In this case, the adapter must make an &lt;em&gt;asynchronous&lt;/em&gt; request to the server, and only when that request finishes loading can the record be created with its backing data.</source>
          <target state="translated">如上图所示，适配器不能总是始终立即返回请求的记录。在这种情况下，适配器必须向服务器发出&lt;em&gt;异步&lt;/em&gt;请求，并且只有在该请求完成加载后，才能使用其备份数据创建记录。</target>
        </trans-unit>
        <trans-unit id="99ca4fb1beac8d51bfa495913434c4c345bda40c" translate="yes" xml:space="preserve">
          <source>As in the case of &lt;code&gt;store.query()&lt;/code&gt;, a query object can also be passed to &lt;code&gt;store.queryRecord()&lt;/code&gt; and is available for the adapter's &lt;code&gt;queryRecord()&lt;/code&gt; to use to qualify the request. However the adapter must return a single model object, not an array containing one element, otherwise Ember Data will throw an exception.</source>
          <target state="translated">与 &lt;code&gt;store.query()&lt;/code&gt; 一样，查询对象也可以传递到 &lt;code&gt;store.queryRecord()&lt;/code&gt; ，并且可用于适配器的 &lt;code&gt;queryRecord()&lt;/code&gt; 来限定请求。但是，适配器必须返回单个模型对象，而不是包含一个元素的数组，否则Ember Data将引发异常。</target>
        </trans-unit>
        <trans-unit id="97635391398fda444388d21e716aa21408aa8b50" translate="yes" xml:space="preserve">
          <source>As in the earlier examples, the comment's &lt;code&gt;belongsTo&lt;/code&gt; relationship will also be cleared by Ember Data.</source>
          <target state="translated">与前面的示例一样，Ember Data也将清除注释的 &lt;code&gt;belongsTo&lt;/code&gt; 关系。</target>
        </trans-unit>
        <trans-unit id="003bea68cedf87e1780da824c13d59df1ff7af25" translate="yes" xml:space="preserve">
          <source>As instances, these helpers also have access to the container an will accept injected dependencies.</source>
          <target state="translated">作为实例,这些帮助程序也可以访问容器,并接受注入的依赖关系。</target>
        </trans-unit>
        <trans-unit id="18534661125f74bf6346b215141eb236e05b22fc" translate="yes" xml:space="preserve">
          <source>As instances, these helpers also have access to the container and will accept injected dependencies.</source>
          <target state="translated">作为实例,这些帮助程序也可以访问容器,并将接受注入的依赖。</target>
        </trans-unit>
        <trans-unit id="cacc2d627b5f266fe9cf7bfe4a641b468cba56ef" translate="yes" xml:space="preserve">
          <source>As it is the basic object type in Ember, being able to test a simple &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html&quot;&gt;&lt;code&gt;Ember.Object&lt;/code&gt;&lt;/a&gt; sets the foundation for testing more specific parts of your Ember application such as controllers, components, etc. Testing an &lt;code&gt;Ember.Object&lt;/code&gt; is as simple as creating an instance of the object, setting its state, and running assertions against the object. By way of example, let's look at a few common cases.</source>
          <target state="translated">由于它是Ember中的基本对象类型，因此能够测试简单的&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html&quot;&gt; &lt;code&gt;Ember.Object&lt;/code&gt; &lt;/a&gt;为测试Ember应用程序的更多特定部分（例如控制器，组件等）奠定了基础。测试 &lt;code&gt;Ember.Object&lt;/code&gt; 就像创建一个Ember.Object一样简单。对象的实例，设置其状态并针对该对象运行断言。通过示例，让我们看一些常见的情况。</target>
        </trans-unit>
        <trans-unit id="53f8a854604d6c0b8e88a2e75222bcf223f2515a" translate="yes" xml:space="preserve">
          <source>As long as the properties are tracked, and accessed when rendering the template directly or indirectly, everything should update as expected</source>
          <target state="translated">只要跟踪属性,并在渲染模板时直接或间接访问,一切都应按预期更新。</target>
        </trans-unit>
        <trans-unit id="9b26474ccf1de5f731e6454e022ad86eac498963" translate="yes" xml:space="preserve">
          <source>As mentioned above, we recommend that you use &lt;code&gt;npx @ember/octanify&lt;/code&gt; to ensure these flags are set to the appropriate values. To learn what each option does, check out the &lt;a href=&quot;../../configuring-ember/optional-features&quot;&gt;Optional Features&lt;/a&gt; guide.</source>
          <target state="translated">如上所述，我们建议您使用 &lt;code&gt;npx @ember/octanify&lt;/code&gt; 来确保将这些标志设置为适当的值。要了解每个选项的功能，请查看&amp;ldquo;&lt;a href=&quot;../../configuring-ember/optional-features&quot;&gt;可选功能&amp;rdquo;&lt;/a&gt;指南。</target>
        </trans-unit>
        <trans-unit id="41dc958fa2ea76e6ba5543e57f4cb5c6b24e746f" translate="yes" xml:space="preserve">
          <source>As mentioned above, we recommend that you use &lt;code&gt;npx @ember/octanify&lt;/code&gt; to ensure these flags are set to the appropriate values. To learn what each option does, check out the &lt;a href=&quot;https://guides.emberjs.com/configuring-ember/optional-features/&quot;&gt;Optional Features&lt;/a&gt; guide.</source>
          <target state="translated">如上所述，我们建议您使用 &lt;code&gt;npx @ember/octanify&lt;/code&gt; 来确保将这些标志设置为适当的值。要了解每个选项的功能，请查看&amp;ldquo;&lt;a href=&quot;https://guides.emberjs.com/configuring-ember/optional-features/&quot;&gt;可选功能&amp;rdquo;&lt;/a&gt;指南。</target>
        </trans-unit>
        <trans-unit id="3138a71e853aa2b60d90fb77188c71cc96882ed8" translate="yes" xml:space="preserve">
          <source>As mentioned above, you should wrap any non-Ember async callbacks in &lt;code&gt;Ember.run&lt;/code&gt;. If you don't, Ember will try to approximate a beginning and end for you. Consider the following callback:</source>
          <target state="translated">如上所述，您应该在 &lt;code&gt;Ember.run&lt;/code&gt; 中包装所有非Ember异步回调。如果您不这样做，Ember将尝试为您近似一个起点和终点。考虑以下回调：</target>
        </trans-unit>
        <trans-unit id="f6634d6a8d88308b3254746b73f8e595c194c13b" translate="yes" xml:space="preserve">
          <source>As mentioned before, our initial test just made sure everything was running properly. Now let's replace that test with the list of tasks we want our app to handle (described up above).</source>
          <target state="translated">如前所述,我们的初始测试只是确保一切正常运行。现在,让我们用我们希望我们的应用程序处理的任务列表(上面已经描述过了)来替换这个测试。</target>
        </trans-unit>
        <trans-unit id="a2be8e0adcfa1aa4f96496cec6a785cbd688f7be" translate="yes" xml:space="preserve">
          <source>As mentioned earlier on the &lt;a href=&quot;../acceptance-test&quot;&gt;Planning the Application page&lt;/a&gt;, an Ember acceptance test automates interacting with our app in a similar way to a visitor.</source>
          <target state="translated">如前所述，在&amp;ldquo; &lt;a href=&quot;../acceptance-test&quot;&gt;规划应用程序&amp;rdquo;页面上&lt;/a&gt;，Ember验收测试以与访问者类似的方式自动进行与我们的应用程序的交互。</target>
        </trans-unit>
        <trans-unit id="26aba4ddf9df1ce20c811d263d5fbec26355bc10" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, we schedule work (in the form of function invocations) on queues, and these queues are processed to completion in priority order.</source>
          <target state="translated">如前所述,我们将工作(以函数调用的形式)安排在队列上,这些队列按照优先级顺序处理完成。</target>
        </trans-unit>
        <trans-unit id="7556317ab0ca3832a43ca1c6c682a597423fe38d" translate="yes" xml:space="preserve">
          <source>As mentioned in the previous section, we use the &lt;code&gt;concat&lt;/code&gt; helper to render both &lt;code&gt;person.givenName&lt;/code&gt; and &lt;code&gt;person.familyName&lt;/code&gt; in one go. But we also want to make sure that the names are capitalized. It gets a bit repetitive to keep writing &lt;code&gt;capitalize&lt;/code&gt; and honestly, we might just forget it at some point. Thankfully, we can use the &lt;code&gt;{{let}}&lt;/code&gt; helper to fix this:</source>
          <target state="translated">如上一节所述，我们使用 &lt;code&gt;concat&lt;/code&gt; 帮助器 &lt;code&gt;person.familyName&lt;/code&gt; 渲染了 &lt;code&gt;person.givenName&lt;/code&gt; 和person.familyName。但我们也要确保名称大写。保持 &lt;code&gt;capitalize&lt;/code&gt; 和诚实的做法有点重复，我们有时可能会忘记它。幸运的是，我们可以使用 &lt;code&gt;{{let}}&lt;/code&gt; 帮助程序来解决此问题：</target>
        </trans-unit>
        <trans-unit id="35b6f125ee3d6d0295e5a3907e1391e9db734bb3" translate="yes" xml:space="preserve">
          <source>As part of making your app upgrades as smooth as possible, the Inspector gathers your deprecations, groups them, and displays them in a way that helps you fix them.</source>
          <target state="translated">作为使你的应用程序升级尽可能顺利的一部分,检查员收集你的废弃,将它们分组,并以帮助你修复它们的方式显示。</target>
        </trans-unit>
        <trans-unit id="1d09613c1dfb00458167443cf419d127edf67f08" translate="yes" xml:space="preserve">
          <source>As seen in the &lt;a href=&quot;https://guides.emberjs.com/templates/writing-helpers&quot;&gt;Writing Helpers&lt;/a&gt; guide. The helper function expects the unnamed arguments as an array as the first argument. It expects the named arguments as an object as the second argument.</source>
          <target state="translated">如&lt;a href=&quot;https://guides.emberjs.com/templates/writing-helpers&quot;&gt;写作助手&lt;/a&gt;指南所示。helper函数期望将未命名参数作为数组作为第一个参数。它期望将命名参数作为对象作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="8f68455579dd856d56240eb43c7fe7a9dbf3fb19" translate="yes" xml:space="preserve">
          <source>As seen in the &lt;a href=&quot;https://guides.emberjs.com/templates/writing-helpers/&quot;&gt;Writing Helpers&lt;/a&gt; guide. The helper function expects the unnamed arguments as an array as the first argument. It expects the named arguments as an object as the second argument.</source>
          <target state="translated">如&lt;a href=&quot;https://guides.emberjs.com/templates/writing-helpers/&quot;&gt;写作助手&lt;/a&gt;指南所示。helper函数期望将未命名参数作为数组作为第一个参数。它期望将命名参数作为对象作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="d84ef0ba5d97aba9769a584c2d26fe83b58a26a8" translate="yes" xml:space="preserve">
          <source>As shown here, we can pass different content into the tag. The content of the tag is also referred to as &lt;em&gt;the block&lt;/em&gt;. The &lt;code&gt;{{yield}}&lt;/code&gt; syntax yields to the block once the block is passed into the component.</source>
          <target state="translated">如此处所示，我们可以将不同的内容传递到标签中。标签的内容也称为&lt;em&gt;block&lt;/em&gt;。一旦将块传递到组件中， &lt;code&gt;{{yield}}&lt;/code&gt; 语法就会产生该块。</target>
        </trans-unit>
        <trans-unit id="63cd927a14867ce3ef7598750785a48449a7e9ac" translate="yes" xml:space="preserve">
          <source>As the proxy is an ObjectProxy, and the json now its content, all the json properties will be available directly from the proxy.</source>
          <target state="translated">由于代理是一个ObjectProxy,而json现在是它的内容,所有的json属性将直接从代理中获得。</target>
        </trans-unit>
        <trans-unit id="839921acedf01a62de2ab72624945f1296874da4" translate="yes" xml:space="preserve">
          <source>As the user inputs text, this property is updated to reflect the &lt;code&gt;value&lt;/code&gt; property of the HTML element.</source>
          <target state="translated">当用户输入文本时，此属性将更新以反映HTML元素的 &lt;code&gt;value&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="1c0114ed3606496cbcb98afe5e657a3825b6b500" translate="yes" xml:space="preserve">
          <source>As they search for a rental, users might also want to narrow their search to a specific city. While our &lt;a href=&quot;../simple-component&quot;&gt;initial&lt;/a&gt; rental listing component only displayed rental information, this new filter component will also allow the user to provide input in the form of filter criteria.</source>
          <target state="translated">在搜索租金时，用户可能还希望将搜索范围缩小到特定城市。虽然我们的&lt;a href=&quot;../simple-component&quot;&gt;初始&lt;/a&gt;租赁清单组件仅显示租赁信息，但此新的筛选器组件还将允许用户以筛选条件的形式提供输入。</target>
        </trans-unit>
        <trans-unit id="3ef82893252744a1b499132ad853ca79e552d0e0" translate="yes" xml:space="preserve">
          <source>As usual, there's a generator that makes this easy for us. Make a new component by typing:</source>
          <target state="translated">一样平常来说,有一个生成器可以让我们很轻松。通过键入以下内容来创建一个新的组件。</target>
        </trans-unit>
        <trans-unit id="6fa2afaa305f9094baad3a3f54af0876278af656" translate="yes" xml:space="preserve">
          <source>As we can see from the warning, &lt;code&gt;@ember/optional-features&lt;/code&gt; has created a file in &lt;code&gt;config/optional-features.json&lt;/code&gt; to store the configuration for your project. We commit it to our repository and we are off to the races!</source>
          <target state="translated">从警告中可以看出， &lt;code&gt;@ember/optional-features&lt;/code&gt; 已在 &lt;code&gt;config/optional-features.json&lt;/code&gt; 中创建了一个文件，用于存储项目的配置。我们将其提交到我们的存储库中，然后开始比赛了！</target>
        </trans-unit>
        <trans-unit id="306d333a4f71d5816d13abcfd58bba336166f4ce" translate="yes" xml:space="preserve">
          <source>As we continue through this tutorial, we'll use these acceptance tests as our checklist. Once all the tests are passing, we'll have accomplished our high level goals.</source>
          <target state="translated">当我们继续学习本教程时,我们将把这些验收测试作为我们的检查表。一旦所有的测试都通过了,我们就完成了我们的高层目标。</target>
        </trans-unit>
        <trans-unit id="4bf007fb0c2f3c34cd58000ff2b4a5b6d680c969" translate="yes" xml:space="preserve">
          <source>As we mentioned above, components only have two lifecycle hooks, &lt;code&gt;constructor&lt;/code&gt; and &lt;code&gt;willDestroy&lt;/code&gt;. There were a number of other lifecycle hooks that existed on classic components which were generally related to updating component state or DOM manipulation:</source>
          <target state="translated">如上所述，组件只有两个生命周期挂钩， &lt;code&gt;constructor&lt;/code&gt; 和 &lt;code&gt;willDestroy&lt;/code&gt; 。经典组件上还存在许多其他生命周期挂钩，这些挂钩通常与更新组件状态或DOM操作有关：</target>
        </trans-unit>
        <trans-unit id="fc114a9d701db960551865117ad7391d9cc045ea" translate="yes" xml:space="preserve">
          <source>As we mentioned above, for all intents and purposes the methods, fields, and accessors are only usable on &lt;em&gt;instances&lt;/em&gt; of the class. However, sometimes you may want to place them &lt;em&gt;directly&lt;/em&gt; on the class, for instance if you want to share some state between all instances of the class. You can do this by adding the &lt;code&gt;static&lt;/code&gt; keyword in front of the definition:</source>
          <target state="translated">如上所述，出于所有意图和目的，方法，字段和访问器仅可用于类的&lt;em&gt;实例&lt;/em&gt;。但是，有时您可能希望将它们&lt;em&gt;直接&lt;/em&gt;放在类上，例如，如果要在类的所有实例之间共享某些状态。您可以通过在定义前面添加 &lt;code&gt;static&lt;/code&gt; 关键字来做到这一点：</target>
        </trans-unit>
        <trans-unit id="762369d4378b2482bf59c8e52491cc7542fb6f49" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;findAll&lt;/code&gt;, the final result after normalization to &lt;code&gt;JSON:API&lt;/code&gt; will be added to store via &lt;code&gt;store.push&lt;/code&gt; where it will merge with any existing records for &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;findAll&lt;/code&gt; 一样，对 &lt;code&gt;JSON:API&lt;/code&gt; 进行规范化之后的最终结果将通过 &lt;code&gt;store.push&lt;/code&gt; 添加到store中，在这里它将与 &lt;code&gt;type&lt;/code&gt; 的任何现有记录合并。</target>
        </trans-unit>
        <trans-unit id="7796b3fe19b6a004e5933a00e42c6dcd9bb59bf3" translate="yes" xml:space="preserve">
          <source>As with the &lt;code&gt;loading&lt;/code&gt; substate, on a thrown error or rejected promise returned from the &lt;code&gt;articles.overview&lt;/code&gt; route's &lt;code&gt;model&lt;/code&gt; hook (or &lt;code&gt;beforeModel&lt;/code&gt; or &lt;code&gt;afterModel&lt;/code&gt;) Ember will look for an error template or route in the following order:</source>
          <target state="translated">与 &lt;code&gt;loading&lt;/code&gt; 子状态一样，在 &lt;code&gt;articles.overview&lt;/code&gt; 路由的 &lt;code&gt;model&lt;/code&gt; 钩子（或 &lt;code&gt;beforeModel&lt;/code&gt; 或 &lt;code&gt;afterModel&lt;/code&gt; ）抛出抛出错误或被拒绝的承诺时，Ember将按以下顺序查找错误模板或路由：</target>
        </trans-unit>
        <trans-unit id="5b3029597944ed54983bca9a138b492cee282e0c" translate="yes" xml:space="preserve">
          <source>As you can see, both literal and bound values can be set on attributes, and attributes can be used &lt;em&gt;without&lt;/em&gt; setting a value at all, just like HTML attributes. The component you are invoking decides where to put these attributes by using the special &lt;code&gt;...attributes&lt;/code&gt; syntax. This will be discussed later in the section on components.</source>
          <target state="translated">如您所见，可以在属性上设置文字值和绑定值，并且可以像HTML属性一样使用属性&lt;em&gt;而无需&lt;/em&gt;设置任何值。您要调用的组件通过使用特殊的 &lt;code&gt;...attributes&lt;/code&gt; 语法来决定将这些属性放在何处。稍后将在有关组件的部分中对此进行讨论。</target>
        </trans-unit>
        <trans-unit id="89b005a7c253dc1a312a426ca896f387b7d8fbcf" translate="yes" xml:space="preserve">
          <source>As you can see, it functions a little bit differently that the &lt;code&gt;_super()&lt;/code&gt; method. When used in a constructor, you call it directly like a function. You &lt;em&gt;must&lt;/em&gt; do this before using &lt;code&gt;this&lt;/code&gt; in the constructor, otherwise it's a syntax error. However, when used in any other method, you must &lt;em&gt;explicitly&lt;/em&gt; specify the function you are calling on the parent class.</source>
          <target state="translated">如您所见，它的功能与 &lt;code&gt;_super()&lt;/code&gt; 方法略有不同。在构造函数中使用时，可以像函数一样直接调用它。您&lt;em&gt;必须&lt;/em&gt;在使用前做 &lt;code&gt;this&lt;/code&gt; 在构造函数中，否则这是一个语法错误。但是，在任何其他方法中使用时，必须&lt;em&gt;显式&lt;/em&gt;指定要在父类上调用的函数。</target>
        </trans-unit>
        <trans-unit id="91b02e3a13a7b798f9d11208cf0cde6353127b34" translate="yes" xml:space="preserve">
          <source>As you can see, the Inspector shows the routes you defined as well as the routes automatically generated by Ember.</source>
          <target state="translated">如你所见,检查器显示了你定义的路由以及Ember自动生成的路由。</target>
        </trans-unit>
        <trans-unit id="6f17c2c0791521047c64cdf9285d0e75e021ffab" translate="yes" xml:space="preserve">
          <source>As you learn about Ember, you'll see code like &lt;code&gt;Ember.Component.extend()&lt;/code&gt; and &lt;code&gt;DS.Model.extend()&lt;/code&gt;. Here, you'll learn about this &lt;code&gt;extend()&lt;/code&gt; method, as well as other major features of the Ember object model.</source>
          <target state="translated">在了解Ember时，您会看到类似 &lt;code&gt;Ember.Component.extend()&lt;/code&gt; 和 &lt;code&gt;DS.Model.extend()&lt;/code&gt; 的代码。在这里，您将了解此 &lt;code&gt;extend()&lt;/code&gt; 方法以及Ember对象模型的其他主要功能。</target>
        </trans-unit>
        <trans-unit id="8f06ca2c81b8c26f02d96e6329c0db6f670de11b" translate="yes" xml:space="preserve">
          <source>As you move forward with these template guides, keep in mind that a helper can be used anywhere a normal value can be used.</source>
          <target state="translated">在您使用这些模板指南时,请记住,助记符可以在任何可以使用正常值的地方使用。</target>
        </trans-unit>
        <trans-unit id="85ba2b8e94ac60de39a520e332a62669c801c7e1" translate="yes" xml:space="preserve">
          <source>As you upgrade between releases, you might also notice that your terminal log begins to stream template-related deprecation warnings during the compile process, making it difficult to review your compilation logs.</source>
          <target state="translated">当你在两个版本之间升级时,你可能也会注意到,你的终端日志在编译过程中开始流转与模板相关的废弃警告,这使得你很难查看编译日志。</target>
        </trans-unit>
        <trans-unit id="4292ff646216ec9688bcaac6b8d2d1ecaca767ce" translate="yes" xml:space="preserve">
          <source>As you're developing your Ember app, you are likely to run into common scenarios that aren't addressed by Ember itself. Perhaps you want to use a CSS preprocessor to write your stylesheets, or you want to use a popular JS library, or maybe you want to import components written by a different department within your organization.</source>
          <target state="translated">当你在开发Ember应用时,你很可能会遇到Ember本身没有解决的常见场景。也许你想使用一个CSS预处理器来编写你的样式表,或者你想使用一个流行的JS库,或者你想导入组织内不同部门编写的组件。</target>
        </trans-unit>
        <trans-unit id="8030db38771f4501e97ea4289def0f67f21d001c" translate="yes" xml:space="preserve">
          <source>As you're developing your Ember app, you'll likely run into common scenarios that aren't addressed by Ember itself, such as authentication or using SASS for your stylesheets. Ember CLI provides a common format called &lt;a href=&quot;#toc_addons&quot;&gt;Ember Addons&lt;/a&gt; for distributing reusable libraries to solve these problems. Additionally, you may want to make use of front-end dependencies like a CSS framework or a JavaScript datepicker that aren't specific to Ember apps.</source>
          <target state="translated">在开发Ember应用程序时，您可能会遇到Ember本身无法解决的常见情况，例如身份验证或将SASS用于样式表。Ember CLI提供了一种称为&lt;a href=&quot;#toc_addons&quot;&gt;Ember Addons&lt;/a&gt;的通用格式，用于分发可重用的库来解决这些问题。此外，您可能想利用不是Ember应用特定的前端依赖项，例如CSS框架或JavaScript datepicker。</target>
        </trans-unit>
        <trans-unit id="d41f5be85b9fec5163ff038a3caf2635c6cc436c" translate="yes" xml:space="preserve">
          <source>As your application boots, it creates an &lt;a href=&quot;http://emberjs.com/api/classes/Ember.ApplicationInstance.html&quot;&gt;&lt;code&gt;Ember.ApplicationInstance&lt;/code&gt;&lt;/a&gt; that is used to manage its stateful aspects. This instance acts as the &quot;owner&quot; of objects instantiated for your app.</source>
          <target state="translated">在您的应用程序启动时，它将创建一个&lt;a href=&quot;http://emberjs.com/api/classes/Ember.ApplicationInstance.html&quot;&gt; &lt;code&gt;Ember.ApplicationInstance&lt;/code&gt; &lt;/a&gt;，用于管理其有状态方面。此实例充当为您的应用实例化的对象的&amp;ldquo;所有者&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b3b5c6211be811b100cf62298dade3daaebff438" translate="yes" xml:space="preserve">
          <source>As your application boots, it creates an &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/ApplicationInstance&quot;&gt;&lt;code&gt;ApplicationInstance&lt;/code&gt;&lt;/a&gt; that is used to manage its stateful aspects. This instance acts as the &quot;owner&quot; of objects instantiated for your app.</source>
          <target state="translated">在您的应用程序启动时，它将创建一个&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/ApplicationInstance&quot;&gt; &lt;code&gt;ApplicationInstance&lt;/code&gt; &lt;/a&gt;，用于管理其有状态方面。此实例充当为您的应用实例化的对象的&amp;ldquo;所有者&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="85482f7bde92f968b723a7c1cccba703446c7834" translate="yes" xml:space="preserve">
          <source>As your application grows, you will notice you are sharing UI elements between multiple pages, or using them multiple times on the same page. Ember makes it easy to refactor your templates into reusable components.</source>
          <target state="translated">随着您的应用程序的增长,您会注意到您在多个页面之间共享UI元素,或者在同一个页面上多次使用它们。Ember让您很容易将模板重构成可重用的组件。</target>
        </trans-unit>
        <trans-unit id="dd8b717c424aec19d8b46e728b8a3e6e7d6654ad" translate="yes" xml:space="preserve">
          <source>Assertions are removed from production builds, so they can be freely added for documentation and debugging purposes without worries of incuring any performance penalty. However, because of that, they should not be used for checks that could reasonably fail during normal usage. Furthermore, care should be taken to avoid accidentally relying on side-effects produced from evaluating the condition itself, since the code will not run in production.</source>
          <target state="translated">断言是从生产版本中删除的,所以它们可以自由地添加到文档和调试中,而不用担心会造成任何性能上的损失。然而,正因为如此,它们不应该被用于正常使用时可能会失败的检查。此外,应注意避免意外地依赖评估条件本身产生的副作用,因为代码不会在生产中运行。</target>
        </trans-unit>
        <trans-unit id="4d2cec2e9dfda4b6eb086f48956a67e9aa6066ef" translate="yes" xml:space="preserve">
          <source>Assimilation</source>
          <target state="translated">Assimilation</target>
        </trans-unit>
        <trans-unit id="d55c9f6900701a0c15d2e9897b19c81c1438d26a" translate="yes" xml:space="preserve">
          <source>Assume that a &lt;code&gt;User&lt;/code&gt; can own a &lt;code&gt;Profile&lt;/code&gt;.</source>
          <target state="translated">假设 &lt;code&gt;User&lt;/code&gt; 可以拥有一个 &lt;code&gt;Profile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a79520fe869c6590342ba964e1e8196743a9b60" translate="yes" xml:space="preserve">
          <source>Assuming an &lt;code&gt;article&lt;/code&gt; route with a model that looks like:</source>
          <target state="translated">假设 &lt;code&gt;article&lt;/code&gt; 路线采用以下模型：</target>
        </trans-unit>
        <trans-unit id="0fe8e98ba709beda34fca658dee0e3c113d54233" translate="yes" xml:space="preserve">
          <source>Assuming the &lt;code&gt;@developers&lt;/code&gt; argument contains this array:</source>
          <target state="translated">假设 &lt;code&gt;@developers&lt;/code&gt; 参数包含以下数组：</target>
        </trans-unit>
        <trans-unit id="fc0eae4a846d9c5ab77883eacc28131689ac5ea1" translate="yes" xml:space="preserve">
          <source>Assuming you have already generated the &lt;code&gt;posts&lt;/code&gt; route, to generate the above nested route you would run:</source>
          <target state="translated">假设您已经生成了 &lt;code&gt;posts&lt;/code&gt; 路线，则要生成上述嵌套路线，可以运行：</target>
        </trans-unit>
        <trans-unit id="8b593995c88f61a609044a01e37e8e4ccc22e065" translate="yes" xml:space="preserve">
          <source>Assumptions</source>
          <target state="translated">Assumptions</target>
        </trans-unit>
        <trans-unit id="d113e9e9b47b09d806bb34df02a659f0a2190023" translate="yes" xml:space="preserve">
          <source>Async helpers also come in handy when you want to group interaction into one helper. For example:</source>
          <target state="translated">当你想把交互分组到一个助手中时,异步助手也很方便。比如说</target>
        </trans-unit>
        <trans-unit id="fc31882cb59aefb1303d4facff868ae43726b8fd" translate="yes" xml:space="preserve">
          <source>Async observers are more performant than those that run synchronously and can help you to manage your application state in a more predictable manner. This is one of the reasons, why the &lt;code&gt;default-async-observers&lt;/code&gt; feature is &lt;strong&gt;enabled by default&lt;/strong&gt; in newly created, modern Ember applications.</source>
          <target state="translated">异步观察者比同步观察者更具性能，并且可以帮助您以更可预测的方式管理应用程序状态。这是为什么在新创建的现代Ember应用程序中&lt;strong&gt;默认启用&lt;/strong&gt; &lt;code&gt;default-async-observers&lt;/code&gt; 功能的原因之一。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a694f132ffd5ee023d8bfe4db469892d873344c" translate="yes" xml:space="preserve">
          <source>Asynchronous Helpers</source>
          <target state="translated">异步助手</target>
        </trans-unit>
        <trans-unit id="b882aa063e2d0be0004d24a29b1095b58191cf32" translate="yes" xml:space="preserve">
          <source>Asynchronous Routing</source>
          <target state="translated">异步路由</target>
        </trans-unit>
        <trans-unit id="9d1e1b8e9ce65e96225bf275b064f8840bc64f84" translate="yes" xml:space="preserve">
          <source>Asynchronous calls typically return a promise (or deferred). This is an object which has a state: it can be given handlers for when it's fulfilled or rejected.</source>
          <target state="translated">异步调用通常会返回一个承诺(或延迟)。这是一个有状态的对象:它可以被赋予处理程序,以便在履行或拒绝时处理。</target>
        </trans-unit>
        <trans-unit id="f6afba5345b52f9fe856d72fb2e116d021abf742" translate="yes" xml:space="preserve">
          <source>Asynchronous example:</source>
          <target state="translated">异步的例子。</target>
        </trans-unit>
        <trans-unit id="024ed461313ea710758c8440ffa3aac3c8cae37e" translate="yes" xml:space="preserve">
          <source>Asynchronous helpers are &quot;aware&quot; of (and wait for) asynchronous behavior within your application, making it much easier to write deterministic tests.</source>
          <target state="translated">异步助记器可以 &quot;意识到&quot;(并等待)应用程序中的异步行为,这使得编写确定性测试变得更加容易。</target>
        </trans-unit>
        <trans-unit id="7474c0015a7cbc566fad6bd0c470876572283c8e" translate="yes" xml:space="preserve">
          <source>At a high-level, we break application boot into two distinct phases:</source>
          <target state="translated">在高层次上,我们将应用引导分为两个不同的阶段。</target>
        </trans-unit>
        <trans-unit id="604422ae04a00582512d890ad9756cc860609209" translate="yes" xml:space="preserve">
          <source>At every level of nesting (including the top level), Ember automatically provides a route for the &lt;code&gt;/&lt;/code&gt; path named &lt;code&gt;index&lt;/code&gt;. To see when a new level of nesting occurs, check the router, whenever you see a &lt;code&gt;function&lt;/code&gt;, that's a new level.</source>
          <target state="translated">在嵌套的每个级别（包括顶层），Ember都会自动为名为 &lt;code&gt;index&lt;/code&gt; 的 &lt;code&gt;/&lt;/code&gt; 路径提供一条路由。要查看何时出现新级别的嵌套，请在每当看到 &lt;code&gt;function&lt;/code&gt; 时检查路由器，这是一个新级别。</target>
        </trans-unit>
        <trans-unit id="1a72286828b045fa20348b567c081a976787f702" translate="yes" xml:space="preserve">
          <source>At first, using Ember Data may feel different than the way you're used to writing JavaScript applications. Many developers are familiar with using AJAX to fetch raw JSON data from an endpoint, which may appear easy at first. Over time, however, complexity leaks out into your application code, making it hard to maintain.</source>
          <target state="translated">起初,使用Ember Data可能会感觉与你习惯的编写JavaScript应用程序的方式不同。许多开发人员都熟悉使用AJAX从端点获取原始JSON数据,这在一开始可能看起来很容易。然而,随着时间的推移,复杂性会泄漏到你的应用程序代码中,使其难以维护。</target>
        </trans-unit>
        <trans-unit id="eb0419aa6a91b702ea23dfa212b1276fa15fbd08" translate="yes" xml:space="preserve">
          <source>At first, using Ember Data may feel different than the way you're used to writing JavaScript applications. Many developers are familiar with using Ajax to fetch raw JSON data from an endpoint, which may appear easy at first. Over time, however, complexity leaks out into your application code, making it hard to maintain.</source>
          <target state="translated">起初,使用Ember Data可能会感觉与你习惯的编写JavaScript应用程序的方式不同。许多开发人员都熟悉使用Ajax从端点获取原始JSON数据,这在一开始可能看起来很容易。然而,随着时间的推移,复杂性会泄漏到你的应用程序代码中,使其难以维护。</target>
        </trans-unit>
        <trans-unit id="3aacf12182d97bd84ec57121482defb62321f637" translate="yes" xml:space="preserve">
          <source>At its core, Ember's UIs are &lt;em&gt;HTML&lt;/em&gt; driven - every part of the UI that is shown to the user is defined in an HTML template somewhere in your application. Because of this, templates are central to Ember, and one of the most important parts of the framework.</source>
          <target state="translated">Ember的UI的核心是&lt;em&gt;HTML&lt;/em&gt;驱动的-向用户显示的UI的每个部分都在应用程序中某个位置的HTML模板中定义。因此，模板是Ember的核心，也是框架最重要的部分之一。</target>
        </trans-unit>
        <trans-unit id="9e76c294bed3108976242f61fd1d7d056da52ddb" translate="yes" xml:space="preserve">
          <source>At most one model for each &lt;a href=&quot;https://guides.emberjs.com/routing/defining-your-routes/#toc_dynamic-segments&quot;&gt;dynamic segment&lt;/a&gt;. By default, Ember.js will replace each segment with the value of the corresponding object's &lt;code&gt;id&lt;/code&gt; property. In the example above, the second argument is each &lt;code&gt;photo&lt;/code&gt; object, and the &lt;code&gt;id&lt;/code&gt; property is used to fill in the dynamic segment with either &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;3&lt;/code&gt;. If there is no model to pass to the component, you can provide an explicit value instead:</source>
          <target state="translated">每个&lt;a href=&quot;https://guides.emberjs.com/routing/defining-your-routes/#toc_dynamic-segments&quot;&gt;动态段&lt;/a&gt;最多一个模型。默认情况下，Ember.js将用相应对象的 &lt;code&gt;id&lt;/code&gt; 属性的值替换每个段。在上面的例子中，第二个参数是每个 &lt;code&gt;photo&lt;/code&gt; 对象，并且 &lt;code&gt;id&lt;/code&gt; 属性被用于填充在与任一动态段 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; ，或 &lt;code&gt;3&lt;/code&gt; 。如果没有模型传递给组件，则可以提供一个显式值：</target>
        </trans-unit>
        <trans-unit id="69c3a590946da3c24ad7291ea76832f83ea93d52" translate="yes" xml:space="preserve">
          <source>At some point, you may want to add default values to your arguments if one wasn't passed to your component. Arguments are not mutable, so if you attempt to reassign a value on &lt;code&gt;this.args&lt;/code&gt;, it'll fail. Instead, you should define a getter on your component that provides the default value if the argument was not provided.</source>
          <target state="translated">在某些时候，如果未将默认值传递给组件，则可能需要向其参数添加默认值。参数不是可变的，因此，如果您尝试在 &lt;code&gt;this.args&lt;/code&gt; 上重新分配一个值，它将失败。相反，如果未提供参数，则应在组件上定义一个提供默认值的吸气剂。</target>
        </trans-unit>
        <trans-unit id="dd6d3b2c1e01895160e35c6131f96028ebae6938" translate="yes" xml:space="preserve">
          <source>At the end of a RunLoop, any methods scheduled in this way will be invoked. Methods will be invoked in an order matching the named queues defined in the &lt;code&gt;queues&lt;/code&gt; property.</source>
          <target state="translated">在RunLoop结束时，将调用以这种方式调度的任何方法。将按照与 &lt;code&gt;queues&lt;/code&gt; 属性中定义的命名队列匹配的顺序调用方法。</target>
        </trans-unit>
        <trans-unit id="bec9405efb0386846a8807b3a31fe58f288690e6" translate="yes" xml:space="preserve">
          <source>At the end of a RunLoop, any methods scheduled in this way will be invoked. Methods will be invoked in an order matching the named queues defined in the &lt;code&gt;run.queues&lt;/code&gt; property.</source>
          <target state="translated">在RunLoop结束时，将调用以这种方式调度的任何方法。将按照与 &lt;code&gt;run.queues&lt;/code&gt; 属性中定义的命名队列匹配的顺序调用方法。</target>
        </trans-unit>
        <trans-unit id="12f96c29406b183c26ea71c6b64edde12cc58a84" translate="yes" xml:space="preserve">
          <source>At the heart of Ember is Ember-Runtime, a set of core functions that provide cross-platform compatibility and object property observing. Ember-Runtime is small and performance-focused so you can use it alongside other cross-platform libraries such as jQuery. For more details, see &lt;a href=&quot;https://emberjs.com/api/modules/ember-runtime.html&quot;&gt;Ember-Runtime&lt;/a&gt;.</source>
          <target state="translated">Ember的核心是Ember-Runtime，它是一组提供跨平台兼容性和对象属性观察的核心功能。 Ember-Runtime很小且注重性能，因此您可以将其与其他跨平台库（例如jQuery）一起使用。有关更多详细信息，请参见&lt;a href=&quot;https://emberjs.com/api/modules/ember-runtime.html&quot;&gt;Ember-Runtime&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43473effc2c8cbc495a11ccde511f0bb67d7a225" translate="yes" xml:space="preserve">
          <source>At the start of a beta cycle the Ember core team evaluates each new feature. Features deemed stable are made available in the next beta and enabled by default.</source>
          <target state="translated">在测试周期开始时,Ember核心团队会评估每个新功能。被认为稳定的功能将在下一个测试版中提供,并默认启用。</target>
        </trans-unit>
        <trans-unit id="02fcc07119232c1ede969118b71afe87945155cc" translate="yes" xml:space="preserve">
          <source>At this point all our tests should pass, including the &lt;a href=&quot;../acceptance-test&quot;&gt;list of acceptance tests&lt;/a&gt; we created as our beginning requirements.</source>
          <target state="translated">在这一点上，我们所有的测试都应该通过，包括我们作为开始要求而创建&lt;a href=&quot;../acceptance-test&quot;&gt;的验收测试列表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58954f132b5aa897d1883f8a43334615e25f69ec" translate="yes" xml:space="preserve">
          <source>At this point you can do a &lt;a href=&quot;../deploying&quot;&gt;deployment&lt;/a&gt; and share your Super Rentals application to the world or you can use this as a base to explore other Ember features and addons. Regardless, we hope this has helped you get started with creating your own ambitious applications with Ember!</source>
          <target state="translated">此时，您可以进行&lt;a href=&quot;../deploying&quot;&gt;部署&lt;/a&gt;并将您的Super Rentals应用程序共享给全世界，也可以以此为基础探索其他Ember功能和附加组件。无论如何，我们希望这可以帮助您开始使用Ember创建自己的雄心勃勃的应用程序！</target>
        </trans-unit>
        <trans-unit id="1bd9b5e5f7f22993de86e7de87f658cef6b36b95" translate="yes" xml:space="preserve">
          <source>At this point, our block content has access to everything it needs to render, via the wrapping &lt;code&gt;blog-post&lt;/code&gt; component's template helpers.</source>
          <target state="translated">至此，我们的块内容可以通过包装 &lt;code&gt;blog-post&lt;/code&gt; 组件的模板帮助程序访问其需要呈现的所有内容。</target>
        </trans-unit>
        <trans-unit id="59905693b637d9aa355e39ca35e76a2ee37223da" translate="yes" xml:space="preserve">
          <source>At this point, we should be able to navigate between our &lt;code&gt;about&lt;/code&gt;, &lt;code&gt;contact&lt;/code&gt;, and &lt;code&gt;rentals&lt;/code&gt; pages.</source>
          <target state="translated">在这一点上，我们应该能够我们之间导航 &lt;code&gt;about&lt;/code&gt; ， &lt;code&gt;contact&lt;/code&gt; 和 &lt;code&gt;rentals&lt;/code&gt; 的网页。</target>
        </trans-unit>
        <trans-unit id="8b835a3f78cc768ce62c5e13c229075402e14a03" translate="yes" xml:space="preserve">
          <source>At this point, you can continue to the &lt;a href=&quot;../routes-and-templates&quot;&gt;next page&lt;/a&gt; or read more about Ember testing below.</source>
          <target state="translated">此时，您可以继续&lt;a href=&quot;../routes-and-templates&quot;&gt;下一页，&lt;/a&gt;或者在下面阅读有关Ember测试的更多信息。</target>
        </trans-unit>
        <trans-unit id="2586793eebaa431e6679b739ad4e25168985bbad" translate="yes" xml:space="preserve">
          <source>At this point, you can either persist your changes via &lt;code&gt;save()&lt;/code&gt; or you can roll back your changes. Calling &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Model.html#method_rollbackAttributes&quot;&gt;&lt;code&gt;rollbackAttributes()&lt;/code&gt;&lt;/a&gt; for a saved record reverts all the &lt;code&gt;changedAttributes&lt;/code&gt; to their original value. If the record &lt;code&gt;isNew&lt;/code&gt; it will be removed from the store.</source>
          <target state="translated">此时，您可以通过 &lt;code&gt;save()&lt;/code&gt; 保留更改，也可以回滚更改。调用保存的记录的&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Model.html#method_rollbackAttributes&quot;&gt; &lt;code&gt;rollbackAttributes()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;changedAttributes&lt;/code&gt; 所有changedAttributes还原为其原始值。如果记录 &lt;code&gt;isNew&lt;/code&gt; 记录，它将从商店中删除。</target>
        </trans-unit>
        <trans-unit id="4d614c57b309b40243828266c6acc885207e6186" translate="yes" xml:space="preserve">
          <source>At this point, you can either persist your changes via &lt;code&gt;save()&lt;/code&gt; or you can roll back your changes. Calling &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/Model/methods#rollbackAttributes&quot;&gt;&lt;code&gt;rollbackAttributes()&lt;/code&gt;&lt;/a&gt; for a saved record reverts all the &lt;code&gt;changedAttributes&lt;/code&gt; to their original value. If the record &lt;code&gt;isNew&lt;/code&gt; it will be removed from the store.</source>
          <target state="translated">此时，您可以通过 &lt;code&gt;save()&lt;/code&gt; 保留更改，也可以回滚更改。调用保存的记录的&lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/Model/methods#rollbackAttributes&quot;&gt; &lt;code&gt;rollbackAttributes()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;changedAttributes&lt;/code&gt; 所有changedAttributes还原为其原始值。如果记录 &lt;code&gt;isNew&lt;/code&gt; 记录，它将从商店中删除。</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="33b12658f55b6f8b7cd0a5aad6c5efd4551092e5" translate="yes" xml:space="preserve">
          <source>Atom is hackable text editor for the 21st Century.</source>
          <target state="translated">Atom是21世纪的可黑客化文本编辑器。</target>
        </trans-unit>
        <trans-unit id="eaadbd3b4c608776e71642462b140b1a321d4080" translate="yes" xml:space="preserve">
          <source>Attaching Actions to Non-Clickable Elements</source>
          <target state="translated">将动作附加到不可点击的元素上</target>
        </trans-unit>
        <trans-unit id="977cdd4c60c3eae70e9b9de3d34e8c4109852a3f" translate="yes" xml:space="preserve">
          <source>Attaching actions to DOM elements</source>
          <target state="translated">为DOM元素附加动作</target>
        </trans-unit>
        <trans-unit id="8e3da4707f8656a453fa96b571d97b75794ccd21" translate="yes" xml:space="preserve">
          <source>Attempts to add the passed object to the receiver if the object is not already present in the collection. If the object is present, this method has no effect.</source>
          <target state="translated">如果对象还没有出现在集合中,则尝试将传递的对象添加到接收器中。如果对象已经存在,本方法没有任何效果。</target>
        </trans-unit>
        <trans-unit id="4f777a9ed3b994806a472032ec849e0ef34ecf7d" translate="yes" xml:space="preserve">
          <source>Attempts to remove the passed object from the receiver collection if the object is present in the collection. If the object is not present, this method has no effect.</source>
          <target state="translated">如果对象存在于接收器集合中,则尝试从接收器集合中移除传递的对象。如果对象不存在,本方法没有任何效果。</target>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="6ec6d89f423d9e38d748baf4b1f1836781f0fcbf" translate="yes" xml:space="preserve">
          <source>Attribute Names</source>
          <target state="translated">属性名称</target>
        </trans-unit>
        <trans-unit id="b1b547d1ff50678c20d8048258a2a244b72d2277" translate="yes" xml:space="preserve">
          <source>Attribute Ordering</source>
          <target state="translated">属性排序</target>
        </trans-unit>
        <trans-unit id="73a05430770622de21c0faf0e251227cc79d971d" translate="yes" xml:space="preserve">
          <source>Attribute names in your JSON payload should be the camelCased versions of the attributes in your Ember.js models.</source>
          <target state="translated">你的JSON有效载荷中的属性名应该是你的Ember.js模型中的属性的camelCased版本。</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="e31898f142563b3823600180d1ec6a160deb8abb" translate="yes" xml:space="preserve">
          <source>Attributes are also available to classic components, and &lt;code&gt;...attributes&lt;/code&gt; is applied automatically to the wrapping element. If you're converting a component from classic components, you should be sure to add &lt;code&gt;...attributes&lt;/code&gt; to the wrapper element.</source>
          <target state="translated">属性也可用于经典组件，并且 &lt;code&gt;...attributes&lt;/code&gt; 自动应用于包装元素。如果要从经典组件转换组件，则应确保将 &lt;code&gt;...attributes&lt;/code&gt; 添加到wrapper元素。</target>
        </trans-unit>
        <trans-unit id="15394d673370c824cbd9257b3097ca11b176e7b1" translate="yes" xml:space="preserve">
          <source>Attributes are used when turning the JSON payload returned from your server into a record, and when serializing a record to save back to the server after it has been modified.</source>
          <target state="translated">当把服务器返回的JSON有效载荷转化为记录时,以及在修改记录后将其序列化保存回服务器时,都会用到属性。</target>
        </trans-unit>
        <trans-unit id="b11af515f8211c7c98f45b87b9cafd501804421e" translate="yes" xml:space="preserve">
          <source>Attributes can be applied to multiple elements as well:</source>
          <target state="translated">属性也可以应用于多个元素。</target>
        </trans-unit>
        <trans-unit id="d56438642f0ab238478bbefcab98fbaa14d46450" translate="yes" xml:space="preserve">
          <source>Augments a constructor's own properties and functions:</source>
          <target state="translated">增强构造函数的自身属性和功能。</target>
        </trans-unit>
        <trans-unit id="a2f9b618879ca0736d07b6619b258226caebaa0e" translate="yes" xml:space="preserve">
          <source>Augments a constructor's prototype with additional properties and functions:</source>
          <target state="translated">为构造函数的原型增加额外的属性和功能。</target>
        </trans-unit>
        <trans-unit id="011acab72ef31d6e6dae85d00b4256899c4da349" translate="yes" xml:space="preserve">
          <source>Authoring Adapters</source>
          <target state="translated">创作适配器</target>
        </trans-unit>
        <trans-unit id="0e5647323a0775b905f99dd49c5c2ec27e1e176a" translate="yes" xml:space="preserve">
          <source>Authoring Serializers</source>
          <target state="translated">编写序列器</target>
        </trans-unit>
        <trans-unit id="56874b2f851d69474fb406c3ad51fd76a8ff5fb2" translate="yes" xml:space="preserve">
          <source>AutoLocation</source>
          <target state="translated">AutoLocation</target>
        </trans-unit>
        <trans-unit id="7db19ea1a02598dc4c77a174c421e0eb0a38f24b" translate="yes" xml:space="preserve">
          <source>Autoruns are Embers way of not punishing you in production if you forget to open a run loop before you schedule callbacks on it. While this is useful in production, these are still situations that should be revealed in testing to help you find and fix them.</source>
          <target state="translated">Autoruns是Embers在生产中不惩罚你的方式,如果你忘记在其上安排回调之前打开运行循环。虽然这在生产中很有用,但这些情况还是应该在测试中揭示出来,以帮助你发现和修复它们。</target>
        </trans-unit>
        <trans-unit id="59a379f080719fed1325dfc72ce9981cf59d3b60" translate="yes" xml:space="preserve">
          <source>Autoruns are disabled in testing for several reasons:</source>
          <target state="translated">在测试中禁用自动运行有几个原因。</target>
        </trans-unit>
        <trans-unit id="20d149ddd2196d6f8efa70e37fd6b28dd46d788b" translate="yes" xml:space="preserve">
          <source>Autotracking Basics</source>
          <target state="translated">自动跟踪基础知识</target>
        </trans-unit>
        <trans-unit id="3e18869592ca032d6936bfa8215ab000533c143f" translate="yes" xml:space="preserve">
          <source>Autotracking In-Depth</source>
          <target state="translated">自动跟踪深入浅出</target>
        </trans-unit>
        <trans-unit id="3f4c5699e9c3bf292e3cd89a6bb5cd43636b1385" translate="yes" xml:space="preserve">
          <source>Autotracking is how Ember's &lt;em&gt;reactivity&lt;/em&gt; model works - how it decides what to rerender, and when. This guide covers tracking in more depth, including how it can be used in various types of classes, and how it interacts with arrays and POJOs.</source>
          <target state="translated">自动跟踪是Ember的&lt;em&gt;反应性&lt;/em&gt;模型的工作方式-它决定如何渲染以及何时渲染。本指南涵盖了更深入的跟踪，包括如何在各种类型的类中使用它以及如何与数组和POJO交互。</target>
        </trans-unit>
        <trans-unit id="e1c149dbe1fafb85369b896c781475811578d179" translate="yes" xml:space="preserve">
          <source>Available queues, and their order, can be found at &lt;code&gt;queues&lt;/code&gt;</source>
          <target state="translated">可用队列及其顺序可在 &lt;code&gt;queues&lt;/code&gt; 找到</target>
        </trans-unit>
        <trans-unit id="37a6cbb6987ffc5fdcbe4fb1796799b4e5212e38" translate="yes" xml:space="preserve">
          <source>Available queues, and their order, can be found at &lt;code&gt;run.queues&lt;/code&gt;</source>
          <target state="translated">可用队列及其顺序可以在 &lt;code&gt;run.queues&lt;/code&gt; 中找到</target>
        </trans-unit>
        <trans-unit id="235a0577d09184162900c3504628ba592f4d3362" translate="yes" xml:space="preserve">
          <source>Available since v1.0.0</source>
          <target state="translated">自v1.0.0起可用</target>
        </trans-unit>
        <trans-unit id="9173eab37655a6d1e8d5df3ee6f99aea42dae55a" translate="yes" xml:space="preserve">
          <source>Available since v1.10.0</source>
          <target state="translated">自v1.10.0版起可用</target>
        </trans-unit>
        <trans-unit id="27e3767a3f684d5cd6bb77aac2e2a02d7235fc69" translate="yes" xml:space="preserve">
          <source>Available since v1.11.0</source>
          <target state="translated">自v1.11.0版起可用</target>
        </trans-unit>
        <trans-unit id="5a7587ad16163cbd54ec329e7f86bcfae9abcfe5" translate="yes" xml:space="preserve">
          <source>Available since v1.13.0</source>
          <target state="translated">自v1.13.0版起可用</target>
        </trans-unit>
        <trans-unit id="9cbed5ce0a0c543f083cb94ba0794ccecc4c7fa4" translate="yes" xml:space="preserve">
          <source>Available since v1.2.0</source>
          <target state="translated">自v1.2.0版起可用</target>
        </trans-unit>
        <trans-unit id="3c1817a5987e844dea83caa7b5ea95d6df0e6a0d" translate="yes" xml:space="preserve">
          <source>Available since v1.3.0</source>
          <target state="translated">自v1.3.0版起可用</target>
        </trans-unit>
        <trans-unit id="68f3b82fb3769ad0453fc817aa75703f30589b78" translate="yes" xml:space="preserve">
          <source>Available since v1.4.0</source>
          <target state="translated">自v1.4.0版起可用</target>
        </trans-unit>
        <trans-unit id="c3ec6cd66fd1830f6599c5c745a0cb1135a248a2" translate="yes" xml:space="preserve">
          <source>Available since v1.5.0</source>
          <target state="translated">自v1.5.0版起可用</target>
        </trans-unit>
        <trans-unit id="637029e5d8e1b0b52723ee6ae2c2860f4e78a37f" translate="yes" xml:space="preserve">
          <source>Available since v1.6.0</source>
          <target state="translated">自v1.6.0版起可用</target>
        </trans-unit>
        <trans-unit id="f64e7928c287e36eafc378e5accbf9c372753679" translate="yes" xml:space="preserve">
          <source>Available since v1.7.0</source>
          <target state="translated">自v1.7.0版起可用</target>
        </trans-unit>
        <trans-unit id="0a0c38a3e59a457a63c7004251b4b6898207e35c" translate="yes" xml:space="preserve">
          <source>Available since v1.8.0</source>
          <target state="translated">自v1.8.0版起可用</target>
        </trans-unit>
        <trans-unit id="2b3744b5b921ed6915cf8361b3b798c70410086e" translate="yes" xml:space="preserve">
          <source>Available since v1.9.0</source>
          <target state="translated">自v1.9.0版起可用</target>
        </trans-unit>
        <trans-unit id="8e8388dd9fd983d82070267383a7f6f51b7c9d13" translate="yes" xml:space="preserve">
          <source>Available since v2.1.0</source>
          <target state="translated">自v2.1.0起可用</target>
        </trans-unit>
        <trans-unit id="e3434e05be6f8fede400b06a662f0990561f952a" translate="yes" xml:space="preserve">
          <source>Available since v2.10.0</source>
          <target state="translated">自v2.10.0起可用</target>
        </trans-unit>
        <trans-unit id="df0c23dfcecfbbeed284e6e4641709d56c94d97e" translate="yes" xml:space="preserve">
          <source>Available since v2.3.0</source>
          <target state="translated">自v2.3.0起可用</target>
        </trans-unit>
        <trans-unit id="1ca4bb62c431adc047492d8e3e960cc6eab8ecde" translate="yes" xml:space="preserve">
          <source>Available since v2.5.0</source>
          <target state="translated">自v2.5.0起可用</target>
        </trans-unit>
        <trans-unit id="dcb0c66ed5a56f2f99d4dd12b1790eaab3bc3e60" translate="yes" xml:space="preserve">
          <source>Available since v3.10.0</source>
          <target state="translated">自v3.10.0起可用</target>
        </trans-unit>
        <trans-unit id="2533280aed0656aa4282b97bccc15bd70975d7b1" translate="yes" xml:space="preserve">
          <source>Available since v3.11.0</source>
          <target state="translated">自v3.11.0起可用</target>
        </trans-unit>
        <trans-unit id="59036079aac72fc3643c54d16e1571e06b975c70" translate="yes" xml:space="preserve">
          <source>Available since v3.8.0</source>
          <target state="translated">自v3.8.0起可用</target>
        </trans-unit>
        <trans-unit id="91a962c55f21c6425bddac7366fbb0fe07122f56" translate="yes" xml:space="preserve">
          <source>Avoid using class state in field definitions, use the constructor instead:</source>
          <target state="translated">避免在字段定义中使用类状态,使用构造函数代替。</target>
        </trans-unit>
        <trans-unit id="f922b385a7e9f8d156ca4612a64f10a2b41eefb6" translate="yes" xml:space="preserve">
          <source>Backburner has support for stitching the stacktraces together so that you can track down where an erroring &lt;code&gt;Ember.run.later&lt;/code&gt; is being initiated from. Unfortunately, this is quite slow and is not appropriate for production or even normal development.</source>
          <target state="translated">Backburner支持将 &lt;code&gt;Ember.run.later&lt;/code&gt; 跟踪缝合在一起，因此您可以跟踪从何处启动错误的Ember.run.later。不幸的是，这非常慢，不适用于生产甚至正常的开发。</target>
        </trans-unit>
        <trans-unit id="5565b8908d86a903cc35e6eae119d03aeaae8b40" translate="yes" xml:space="preserve">
          <source>Background Reloading</source>
          <target state="translated">背景重装</target>
        </trans-unit>
        <trans-unit id="57702bfb28ed9547528aa68a728d20b92c526740" translate="yes" xml:space="preserve">
          <source>Backwards Compatibility</source>
          <target state="translated">向后兼容性</target>
        </trans-unit>
        <trans-unit id="43441f538606a9564acd9157577fcf3dba0f20ef" translate="yes" xml:space="preserve">
          <source>Based on what we've already learned, we'll need:</source>
          <target state="translated">根据我们已经了解到的情况,我们需要:</target>
        </trans-unit>
        <trans-unit id="a68ef3a01126fe18f2427232120e8a7d3b05edf8" translate="yes" xml:space="preserve">
          <source>Basic Controller Example</source>
          <target state="translated">基本控制器示例</target>
        </trans-unit>
        <trans-unit id="724fb49b1a2edb91c740412ddea2584f33b4cf3a" translate="yes" xml:space="preserve">
          <source>Basic Routes</source>
          <target state="translated">基本路线</target>
        </trans-unit>
        <trans-unit id="630b1b43052c22e1bd9799b5673582e36f998969" translate="yes" xml:space="preserve">
          <source>Basic Usage:</source>
          <target state="translated">基本用途。</target>
        </trans-unit>
        <trans-unit id="8ada93b2847db3d5c94fbfbd017b469ec1eecca6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;/posts&lt;/code&gt; represents a fixed model, we don't need any additional information to know what to retrieve. However, if we want a route to represent a single post, we would not want to have to hardcode every possible post into the router.</source>
          <target state="translated">因为 &lt;code&gt;/posts&lt;/code&gt; 代表一个固定的模型，所以我们不需要任何其他信息即可知道要检索的内容。但是，如果我们希望一条路线代表一个帖子，则不需要将每个可能的帖子硬编码到路由器中。</target>
        </trans-unit>
        <trans-unit id="703c87a452fefa1f8cdf42778798eae571808aea" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Application&lt;/code&gt; ultimately inherits from &lt;code&gt;Ember.Namespace&lt;/code&gt;, any classes you create will have useful string representations when calling &lt;code&gt;toString()&lt;/code&gt;. See the &lt;code&gt;Ember.Namespace&lt;/code&gt; documentation for more information.</source>
          <target state="translated">由于 &lt;code&gt;Application&lt;/code&gt; 最终继承自 &lt;code&gt;Ember.Namespace&lt;/code&gt; ，因此您创建的任何类在调用 &lt;code&gt;toString()&lt;/code&gt; 时都将具有有用的字符串表示形式。有关更多信息，请参见 &lt;code&gt;Ember.Namespace&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="94ccc7f51247a5205c6481d94736daa12929e2a1" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Ember.Application&lt;/code&gt; inherits from &lt;code&gt;Ember.Namespace&lt;/code&gt;, any classes you create will have useful string representations when calling &lt;code&gt;toString()&lt;/code&gt;. See the &lt;code&gt;Ember.Namespace&lt;/code&gt; documentation for more information.</source>
          <target state="translated">由于 &lt;code&gt;Ember.Application&lt;/code&gt; 继承自 &lt;code&gt;Ember.Namespace&lt;/code&gt; ，因此您创建的任何类在调用 &lt;code&gt;toString()&lt;/code&gt; 时都将具有有用的字符串表示形式。有关更多信息，请参见 &lt;code&gt;Ember.Namespace&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="55a8c0c55c4e28bb69a194bcb179205c321affcc" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;get&lt;/code&gt; unifies the syntax for accessing all these kinds of properties, it can make many refactorings easier, such as replacing a simple property with a computed property, or vice versa.</source>
          <target state="translated">因为 &lt;code&gt;get&lt;/code&gt; 统一了访问所有这些类型属性的语法，所以它可以使许多重构更加容易，例如用计算属性替换简单属性，反之亦然。</target>
        </trans-unit>
        <trans-unit id="67b77ee71ee30bcbfde972fdbc6ab17a5e638e72" translate="yes" xml:space="preserve">
          <source>Because HTML &lt;code&gt;input&lt;/code&gt; elements are self closing &lt;code&gt;layout&lt;/code&gt; and &lt;code&gt;layoutName&lt;/code&gt; properties will not be applied.</source>
          <target state="translated">由于HTML &lt;code&gt;input&lt;/code&gt; 元素是自动关闭的 &lt;code&gt;layout&lt;/code&gt; 和 &lt;code&gt;layoutName&lt;/code&gt; 属性将不会应用。</target>
        </trans-unit>
        <trans-unit id="be9f1a41d095d76e52560e285eb25bb5dd766819" translate="yes" xml:space="preserve">
          <source>Because HTML &lt;code&gt;input&lt;/code&gt; elements are self closing &lt;code&gt;layout&lt;/code&gt; and &lt;code&gt;layoutName&lt;/code&gt; properties will not be applied. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.View.html&quot;&gt;Ember.View&lt;/a&gt;'s layout section for more information.</source>
          <target state="translated">由于HTML &lt;code&gt;input&lt;/code&gt; 元素是自动关闭的 &lt;code&gt;layout&lt;/code&gt; 和 &lt;code&gt;layoutName&lt;/code&gt; 属性将不会应用。有关更多信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.View.html&quot;&gt;Ember.View&lt;/a&gt;的布局部分。</target>
        </trans-unit>
        <trans-unit id="602c7bf83c39faf41cf7612a43c086d011bc111a" translate="yes" xml:space="preserve">
          <source>Because HTML &lt;code&gt;textarea&lt;/code&gt; elements do not contain inner HTML the &lt;code&gt;layout&lt;/code&gt; and &lt;code&gt;layoutName&lt;/code&gt; properties will not be applied. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.View.html&quot;&gt;Ember.View&lt;/a&gt;'s layout section for more information.</source>
          <target state="translated">因为HTML &lt;code&gt;textarea&lt;/code&gt; 元素不包含内部HTML ， &lt;code&gt;layoutName&lt;/code&gt; 不会应用 &lt;code&gt;layout&lt;/code&gt; 和layoutName属性。有关更多信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.View.html&quot;&gt;Ember.View&lt;/a&gt;的布局部分。</target>
        </trans-unit>
        <trans-unit id="ba56f36cf9504193e7d77883e84347df4194d7b2" translate="yes" xml:space="preserve">
          <source>Because of Ember's support for bindings and observers, you will always access properties using the get method, and set properties using the set method. This allows the observing objects to be notified and computed properties to be handled properly.</source>
          <target state="translated">由于Ember对绑定和观察者的支持,你将始终使用get方法访问属性,并使用set方法设置属性。这使得观察对象得到通知,计算出的属性得到正确的处理。</target>
        </trans-unit>
        <trans-unit id="a8ae91d71186c8162e9906575f83ad0c71bb6c38" translate="yes" xml:space="preserve">
          <source>Because of this asynchronicity, the store immediately returns a &lt;em&gt;promise&lt;/em&gt; from the &lt;code&gt;find()&lt;/code&gt; method. Similarly, any requests that the store makes to the adapter also return promises.</source>
          <target state="translated">由于这种异步性，存储立即从 &lt;code&gt;find()&lt;/code&gt; 方法返回一个&lt;em&gt;Promise&lt;/em&gt;。同样，存储对适配器的任何请求也会返回promise。</target>
        </trans-unit>
        <trans-unit id="1906f295c19ea94c0e84848fcd2a5f2d27ed3c73" translate="yes" xml:space="preserve">
          <source>Because of this asynchronicity, the store immediately returns a &lt;em&gt;promise&lt;/em&gt; from the &lt;code&gt;findRecord()&lt;/code&gt; method. Similarly, any request that the store makes to the adapter also returns promises.</source>
          <target state="translated">由于这种异步性，商店立即返回一个&lt;em&gt;承诺&lt;/em&gt;从 &lt;code&gt;findRecord()&lt;/code&gt; 方法。同样，存储对适配器发出的任何请求也将返回promise。</target>
        </trans-unit>
        <trans-unit id="d641c61aa5f85907b53d2a176b90a86200658fbd" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;fullName&lt;/code&gt; computed property depends on &lt;code&gt;firstName&lt;/code&gt;, updating &lt;code&gt;firstName&lt;/code&gt; will fire observers on &lt;code&gt;fullName&lt;/code&gt; as well.</source>
          <target state="translated">因为 &lt;code&gt;fullName&lt;/code&gt; 计算的属性取决于 &lt;code&gt;firstName&lt;/code&gt; ，所以更新 &lt;code&gt;firstName&lt;/code&gt; 也会激发 &lt;code&gt;fullName&lt;/code&gt; 的观察者。</target>
        </trans-unit>
        <trans-unit id="eb7c7a31498a049b34a25cec1fe640a98027671a" translate="yes" xml:space="preserve">
          <source>Because the code that is written must be readable by other machines (assistive tech like screen readers, for example), there is documentation about how this accessible name is determined: &lt;a href=&quot;https://www.w3.org/TR/accname-1.1/&quot;&gt;Accessible Name and Description Computation&lt;/a&gt;.</source>
          <target state="translated">由于所编写的代码必须可由其他机器（例如，诸如屏幕阅读器之类的辅助技术）读取，因此存在有关如何确定此可访问名称的文档：&lt;a href=&quot;https://www.w3.org/TR/accname-1.1/&quot;&gt;可访问名称和描述计算&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fc82e24ccce33a201125d0a9e25397d88d38a3a" translate="yes" xml:space="preserve">
          <source>Because the priority is first to last, the &quot;sync&quot; queue has higher priority than the &quot;render&quot; or &quot;destroy&quot; queue.</source>
          <target state="translated">因为优先级从先到后,所以 &quot;同步 &quot;队列的优先级高于 &quot;渲染 &quot;或 &quot;销毁 &quot;队列。</target>
        </trans-unit>
        <trans-unit id="ca516588fe4aad411d8ce205b4c2db67008a7f2e" translate="yes" xml:space="preserve">
          <source>Because we only plan to display static content on our about page, we won't adjust the &lt;code&gt;/app/routes/about.js&lt;/code&gt; route handler file right now. Instead, let's open our &lt;code&gt;/app/templates/about.hbs&lt;/code&gt; template file and add some info about Super Rentals:</source>
          <target state="translated">因为我们仅打算在 &lt;code&gt;/app/routes/about.js&lt;/code&gt; 页面上显示静态内容，所以我们现在不会调整/app/routes/about.js路由处理程序文件。相反，让我们打开 &lt;code&gt;/app/templates/about.hbs&lt;/code&gt; 模板文件，并添加一些有关Super Rentals的信息：</target>
        </trans-unit>
        <trans-unit id="fdd6c7e36bfcc169635cb2a250fa0ec9a5191758" translate="yes" xml:space="preserve">
          <source>Becomes true whenever the array currently has observers watching changes on the array.</source>
          <target state="translated">每当数组当前有观察者在观察数组的变化时,就会变成true。</target>
        </trans-unit>
        <trans-unit id="a15ca45f6217e208c1d6bbd430b7df52f8019e01" translate="yes" xml:space="preserve">
          <source>Before classes were available in JavaScript, Ember developers still got to use some class-like features thanks to &lt;code&gt;@ember/object&lt;/code&gt;. Now that classes are available in JavaScript, we can do away with some of the &lt;code&gt;@ember/object&lt;/code&gt; quirks.</source>
          <target state="translated">在使用JavaScript提供类之前，由于 &lt;code&gt;@ember/object&lt;/code&gt; ，Ember开发人员仍然必须使用一些类类功能。现在可以在JavaScript中使用类，我们可以消除一些 &lt;code&gt;@ember/object&lt;/code&gt; 怪癖。</target>
        </trans-unit>
        <trans-unit id="17a6eefa17e5e40fcc7e29e936936740d9b86b04" translate="yes" xml:space="preserve">
          <source>Before implementing a map, we need to make a 3rd party map API available to our Ember app. There are several ways to include 3rd party libraries in Ember. See the guides section on &lt;a href=&quot;https://guides.emberjs.com/addons-and-dependencies/managing-dependencies/&quot;&gt;managing dependencies&lt;/a&gt; as a starting point when you need to add one.</source>
          <target state="translated">实施地图之前，我们需要为Ember应用程序提供一个第三方地图API。有几种方法可以在Ember中包含3rd party库。需要添加&lt;a href=&quot;https://guides.emberjs.com/addons-and-dependencies/managing-dependencies/&quot;&gt;依赖项时&lt;/a&gt;，请参阅有关管理依赖项的指南部分。</target>
        </trans-unit>
        <trans-unit id="04482d2da333522926f72a356a5bfba9d31b6e01" translate="yes" xml:space="preserve">
          <source>Before making an assertion, wait for the execution of each asynchronous helper to finish with the &lt;code&gt;await&lt;/code&gt; keyword:</source>
          <target state="translated">在进行断言之前，请等待每个异步帮助程序的执行以 &lt;code&gt;await&lt;/code&gt; 关键字结束：</target>
        </trans-unit>
        <trans-unit id="184486c397e2c3cf6e270cc0294995f58c89b4c2" translate="yes" xml:space="preserve">
          <source>Before you start writing any Ember code, it's a good idea to get an overview of how an Ember application works.</source>
          <target state="translated">在你开始编写任何Ember代码之前,最好先了解一下Ember应用程序的工作原理。</target>
        </trans-unit>
        <trans-unit id="842beb51ca9c5417a27f472386d0e0d52dcc074f" translate="yes" xml:space="preserve">
          <source>Before:</source>
          <target state="translated">Before:</target>
        </trans-unit>
        <trans-unit id="8240b85129915e6d5d39790b593e31a4e70811e9" translate="yes" xml:space="preserve">
          <source>Begins a new RunLoop. Any deferred actions invoked after the begin will be buffered until you invoke a matching call to &lt;code&gt;end()&lt;/code&gt;. This is a lower-level way to use a RunLoop instead of using &lt;code&gt;run()&lt;/code&gt;.</source>
          <target state="translated">开始一个新的RunLoop。在begin之后调用的所有延迟动作都将被缓冲，直到您调用对 &lt;code&gt;end()&lt;/code&gt; 的匹配调用为止。这是使用RunLoop而不是 &lt;code&gt;run()&lt;/code&gt; 的较低层方法。</target>
        </trans-unit>
        <trans-unit id="b1c8d5f7603f2678d521765ce966807c817dad7a" translate="yes" xml:space="preserve">
          <source>Begins a new RunLoop. Any deferred actions invoked after the begin will be buffered until you invoke a matching call to &lt;code&gt;run.end()&lt;/code&gt;. This is a lower-level way to use a RunLoop instead of using &lt;code&gt;run()&lt;/code&gt;.</source>
          <target state="translated">开始一个新的RunLoop。在begin之后调用的所有延迟动作都将被缓冲，直到您对 &lt;code&gt;run.end()&lt;/code&gt; 进行匹配的调用为止。这是使用RunLoop而不是 &lt;code&gt;run()&lt;/code&gt; 的较低层方法。</target>
        </trans-unit>
        <trans-unit id="9773bb2a4e6fbd3e49a503a393c63119abf5b295" translate="yes" xml:space="preserve">
          <source>Behind the scenes, the CDN will distribute your content geographically with the goal of end-users being able to fetch your content with the lowest latency possible. For example, if a user is in India, they'd likely get content served from India faster than from the United States.</source>
          <target state="translated">在幕后,CDN将按地域分布你的内容,目标是让终端用户能够以尽可能低的延迟获取你的内容。例如,如果用户在印度,他们从印度获得的内容可能比从美国获得的更快。</target>
        </trans-unit>
        <trans-unit id="906f6d01a6b90b3a4f2198b043497bcdff757722" translate="yes" xml:space="preserve">
          <source>Behind the scenes, what is happening is that the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#setupController&quot;&gt;route's controller&lt;/a&gt; receives the results of the model hook, and Ember makes the model hook results available to the template. Your app may not have a controller file for the route, but the behavior is the same regardless.</source>
          <target state="translated">在幕后，发生的事情是&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#setupController&quot;&gt;路线的控制器&lt;/a&gt;接收到了模型钩子的结果，而Ember使模型钩子的结果可用于模板。您的应用程序可能没有用于该路由的控制器文件，但是无论如何，其行为都是相同的。</target>
        </trans-unit>
        <trans-unit id="85bf548552e758a473fb421db7fd35efa4f3e605" translate="yes" xml:space="preserve">
          <source>BelongsTo: &lt;code&gt;{ serialize: 'id', deserialize: 'id' }&lt;/code&gt; HasMany: &lt;code&gt;{ serialize: false, deserialize: 'ids' }&lt;/code&gt;</source>
          <target state="translated">BelongsTo： &lt;code&gt;{ serialize: 'id', deserialize: 'id' }&lt;/code&gt; HasMany： &lt;code&gt;{ serialize: false, deserialize: 'ids' }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92540263d683ad033101e89c7ab3438af02cd9e3" translate="yes" xml:space="preserve">
          <source>BelongsToReference</source>
          <target state="translated">BelongsToReference</target>
        </trans-unit>
        <trans-unit id="34bcf95e632553eda17103e231139562411bada0" translate="yes" xml:space="preserve">
          <source>Below are some common issues you may encounter when using the Inspector, along with the necessary steps to solve them. If your issue is not listed below, please submit an issue to the Inspector's &lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;GitHub repo&lt;/a&gt;.</source>
          <target state="translated">以下是使用Inspector时可能遇到的一些常见问题，以及解决这些问题的必要步骤。如果您的问题未在下面列出，请向Inspector的&lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;GitHub存储库&lt;/a&gt;提交问题。</target>
        </trans-unit>
        <trans-unit id="695b0847861d155aac843f4e4ca8e305041ec8f4" translate="yes" xml:space="preserve">
          <source>Below are some samples of ways to use lifecycle hooks within your components.</source>
          <target state="translated">下面是一些在组件中使用生命周期钩子的方法示例。</target>
        </trans-unit>
        <trans-unit id="291e904f8a7fa5eaebfe7e0fa23177cf263270c5" translate="yes" xml:space="preserve">
          <source>Below is a description of each of the methods on the interface and their functions.</source>
          <target state="translated">下面是接口上每个方法的描述及其功能。</target>
        </trans-unit>
        <trans-unit id="7b3e9556caf521f66e82350368ec5ac768ca0c64" translate="yes" xml:space="preserve">
          <source>Below is an example of a per-type serializer (&lt;code&gt;post&lt;/code&gt; type).</source>
          <target state="translated">以下是每个类型的序列化器（ &lt;code&gt;post&lt;/code&gt; 类型）的示例。</target>
        </trans-unit>
        <trans-unit id="a5e6e234b7ed9fe5a6c682b1f355706eb29a9173" translate="yes" xml:space="preserve">
          <source>Below is the documentation for Classic components. If you are looking for the API documentation for Template-only or Glimmer components, it is &lt;a href=&quot;https://api.emberjs.com/ember/release/modules/@glimmer%2Fcomponent&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">以下是Classic组件的文档。如果您正在寻找纯模板或Glimmer组件的API文档，&lt;a href=&quot;https://api.emberjs.com/ember/release/modules/@glimmer%2Fcomponent&quot;&gt;请点击此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5214898b090fa876877b6b5782df9c4ca539a4ab" translate="yes" xml:space="preserve">
          <source>Below is the documentation for Template-only and Glimmer components. If you are looking for the API documentation for Classic components, it is &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Component&quot;&gt;available here&lt;/a&gt;. The source code for Glimmer components can be found in &lt;a href=&quot;https://github.com/glimmerjs/glimmer.js/tree/master/packages/%40glimmer/component&quot;&gt;&lt;code&gt;@glimmer/component&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以下是仅模板和Glimmer组件的文档。如果您正在寻找Classic组件的API文档，&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Component&quot;&gt;请点击此处&lt;/a&gt;。可以在&lt;a href=&quot;https://github.com/glimmerjs/glimmer.js/tree/master/packages/%40glimmer/component&quot;&gt; &lt;code&gt;@glimmer/component&lt;/code&gt; &lt;/a&gt;找到Glimmer组件的源代码。</target>
        </trans-unit>
        <trans-unit id="44f7d46e71b9894cafca4065f881ca95a83b2f4d" translate="yes" xml:space="preserve">
          <source>Below is the same deprecation-workflow file as above, now with a regular expression on line 7 to remove some redundant messages. Note that the double quotes around &lt;code&gt;matchMessage&lt;/code&gt; have also been replaced with forward slashes.</source>
          <target state="translated">下面是与上述相同的弃用工作流文件，现在在第7行带有一个正则表达式以删除一些多余的消息。请注意， &lt;code&gt;matchMessage&lt;/code&gt; 周围的双引号也已替换为正斜杠。</target>
        </trans-unit>
        <trans-unit id="960ac88bd1d4540756c95bea14732962f11a19f9" translate="yes" xml:space="preserve">
          <source>Below we add a remove action to the &lt;code&gt;cart-contents&lt;/code&gt; component.</source>
          <target state="translated">在下面，我们向 &lt;code&gt;cart-contents&lt;/code&gt; 组件添加一个remove动作。</target>
        </trans-unit>
        <trans-unit id="e8a9a448876963b1a5013979ed02936a580daf1c" translate="yes" xml:space="preserve">
          <source>Below we add a remove action to the &lt;code&gt;cart-contents&lt;/code&gt; component. Notice that below we access the &lt;code&gt;cart&lt;/code&gt; service with a call to&lt;code&gt;this.get&lt;/code&gt;.</source>
          <target state="translated">在下面，我们将删除操作添加到 &lt;code&gt;cart-contents&lt;/code&gt; 组件。注意，下面我们通过调用 &lt;code&gt;this.get&lt;/code&gt; 访问 &lt;code&gt;cart&lt;/code&gt; 服务。</target>
        </trans-unit>
        <trans-unit id="51b4cff8c754b5b9b24475fc5afafb96a504a228" translate="yes" xml:space="preserve">
          <source>Benefits of &lt;code&gt;@action&lt;/code&gt;, &lt;code&gt;{{on}}&lt;/code&gt;, and &lt;code&gt;{{fn}}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@action&lt;/code&gt; ， &lt;code&gt;{{on}}&lt;/code&gt; 和 &lt;code&gt;{{fn}}&lt;/code&gt; 的好处</target>
        </trans-unit>
        <trans-unit id="cf5993b6fe592213a9dee75afd9977b364d041cf" translate="yes" xml:space="preserve">
          <source>Benefits of &lt;code&gt;this&lt;/code&gt; in templates</source>
          <target state="translated">的好处 &lt;code&gt;this&lt;/code&gt; 模板</target>
        </trans-unit>
        <trans-unit id="c2d805670dc60d575e2674fc162ed5333fdaf9ed" translate="yes" xml:space="preserve">
          <source>Benefits of Angle Brackets</source>
          <target state="translated">角钢支架的优点</target>
        </trans-unit>
        <trans-unit id="ecf7e8222edbd1952d167ab4f155593b14ed8f5c" translate="yes" xml:space="preserve">
          <source>Benefits of Glimmer Components</source>
          <target state="translated">Glimmer组件的优点</target>
        </trans-unit>
        <trans-unit id="ffa0cef06f33464183b43f7427091e72e76b7594" translate="yes" xml:space="preserve">
          <source>Benefits of Named Arguments</source>
          <target state="translated">命名论证的好处</target>
        </trans-unit>
        <trans-unit id="603930dfc6b353770972149ffe4795e9a9a59760" translate="yes" xml:space="preserve">
          <source>Benefits of Native Classes</source>
          <target state="translated">本地班的好处</target>
        </trans-unit>
        <trans-unit id="e2b755469ac3ec99d13fd59add395b3ab0022475" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;{{action}}&lt;/code&gt;, it is also possible to pass any arbitrary element modifiers using the angle bracket invocation syntax.</source>
          <target state="translated">除了 &lt;code&gt;{{action}}&lt;/code&gt; 之外，还可以使用尖括号调用语法传递任意元素修饰符。</target>
        </trans-unit>
        <trans-unit id="3473ae839d7876b9c12e956bc85aa276fbfee546" translate="yes" xml:space="preserve">
          <source>Besides ES6, you'll see a lot of content about compiling/transpiling CoffeeScript, a short-hand language which can &quot;compile&quot; to JavaScript.</source>
          <target state="translated">除了ES6之外,你还会看到很多关于编译/转换CoffeeScript的内容,CoffeeScript是一种可以 &quot;编译 &quot;为JavaScript的简短语言。</target>
        </trans-unit>
        <trans-unit id="7bd0ed1d9030f89c91af701f519d5b94d60de999" translate="yes" xml:space="preserve">
          <source>Besides properties, double curly braces (&lt;code&gt;{{}}&lt;/code&gt;) may also contain helpers and components, which we'll discuss later.</source>
          <target state="translated">除属性外，双花括号（ &lt;code&gt;{{}}&lt;/code&gt; ）还可能包含辅助函数和组件，我们将在后面讨论。</target>
        </trans-unit>
        <trans-unit id="47be2ca9b139f48a82092d21ad3c72eab6501a34" translate="yes" xml:space="preserve">
          <source>Besides the custom class name for the value being &lt;code&gt;true&lt;/code&gt;, you can also specify a class name which is used when the value is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">除了自定义类名的值为 &lt;code&gt;true&lt;/code&gt; 之外，您还可以指定在值为 &lt;code&gt;false&lt;/code&gt; 时使用的类名：</target>
        </trans-unit>
        <trans-unit id="e41f7d1bc0d0c7928ac6d1fa13f85a10f010279b" translate="yes" xml:space="preserve">
          <source>Beta features that receive negative feedback from the community are disabled in the next beta point release, and are not included in the next stable release. They may still be included in the next beta cycle if the issues/concerns are resolved.</source>
          <target state="translated">收到社区负面反馈的测试版功能将在下一个测试点版本中禁用,并且不包含在下一个稳定版本中。如果问题/关注点得到解决,它们仍可能被包含在下一个测试周期中。</target>
        </trans-unit>
        <trans-unit id="24f5a3e51e94cbb9080af9327164878aa332067a" translate="yes" xml:space="preserve">
          <source>Binding Element Attributes</source>
          <target state="translated">绑定元素属性</target>
        </trans-unit>
        <trans-unit id="9f37cd8b58ca3436726a232f6276b6be473416cd" translate="yes" xml:space="preserve">
          <source>Binding dynamic attribute</source>
          <target state="translated">绑定动态属性</target>
        </trans-unit>
        <trans-unit id="967382f86044b6efc91dfee8f4e2b4ed941211cd" translate="yes" xml:space="preserve">
          <source>Bindings</source>
          <target state="translated">Bindings</target>
        </trans-unit>
        <trans-unit id="0fd5e5702c2a2b8d9bd0d8e5ff6ccbb97a1c033a" translate="yes" xml:space="preserve">
          <source>Block &lt;code&gt;if&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 阻止</target>
        </trans-unit>
        <trans-unit id="6e0fc82b79b091f59214a16221b95376c703b10e" translate="yes" xml:space="preserve">
          <source>Block Content</source>
          <target state="translated">屏蔽内容</target>
        </trans-unit>
        <trans-unit id="f9fb8189ac6f1cb7e0b9631557e27da8a854c72c" translate="yes" xml:space="preserve">
          <source>Block Form</source>
          <target state="translated">块状</target>
        </trans-unit>
        <trans-unit id="557758c8174336d6369c72e1c97a88e6c9ef1fba" translate="yes" xml:space="preserve">
          <source>Block Parameters</source>
          <target state="translated">块参数</target>
        </trans-unit>
        <trans-unit id="c105cc5dcc58a17f4df8de56aee738e2affa3ce3" translate="yes" xml:space="preserve">
          <source>Block form</source>
          <target state="translated">块状</target>
        </trans-unit>
        <trans-unit id="49100a3290d374e27e83d19e957ac12342793e83" translate="yes" xml:space="preserve">
          <source>Block params, like function arguments in JavaScript, are positional. &lt;code&gt;person&lt;/code&gt; is what each item is named in the above template, but &lt;code&gt;human&lt;/code&gt; would work just as well.</source>
          <target state="translated">块参数（如JavaScript中的函数参数）是位置性的。 &lt;code&gt;person&lt;/code&gt; 是上面模板中每个项目的名称，但是 &lt;code&gt;human&lt;/code&gt; 也可以工作。</target>
        </trans-unit>
        <trans-unit id="89cdbb7139e3739622efe0d88dcc4fd99073a62a" translate="yes" xml:space="preserve">
          <source>Blocks are executed in their original context, meaning they have access to the scope and any in-scope variables where they were defined.</source>
          <target state="translated">块在它们的原始上下文中执行,这意味着它们可以访问它们定义的作用域和任何作用域内的变量。</target>
        </trans-unit>
        <trans-unit id="7c713ca305dca3bf7efdc467b2029c62aa3cd50c" translate="yes" xml:space="preserve">
          <source>Blocks can also pass values back into the template, similar to a callback function in JavaScript. Consider for instance a simple &lt;code&gt;BlogPost&lt;/code&gt; component.</source>
          <target state="translated">块也可以将值传递回模板中，类似于JavaScript中的回调函数。例如，考虑一个简单的 &lt;code&gt;BlogPost&lt;/code&gt; 组件。</target>
        </trans-unit>
        <trans-unit id="b9eec850bd8792a378b84e4f28265bdea7e3c7a6" translate="yes" xml:space="preserve">
          <source>Blog dates are properly formatted.</source>
          <target state="translated">博客日期格式正确。</target>
        </trans-unit>
        <trans-unit id="e963a85c0c8a238f5361e2429d62278cf5e7dc39" translate="yes" xml:space="preserve">
          <source>Bookmark Me</source>
          <target state="translated">收藏我</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="5c7f3b824274f00a1a1136adcf6ac0c94cc5233f" translate="yes" xml:space="preserve">
          <source>Boolean value class name bindings whose property names are in a camelCase-style format will be converted to a dasherized format:</source>
          <target state="translated">布尔值类名绑定,其属性名为camelCase风格的格式将被转换为dasherized格式。</target>
        </trans-unit>
        <trans-unit id="da3d2f1c6bd8c47dc3e21495ee821cf23c600c93" translate="yes" xml:space="preserve">
          <source>BooleanTransform</source>
          <target state="translated">BooleanTransform</target>
        </trans-unit>
        <trans-unit id="73d63b221c33e6a800a0a8b60a2835cfc7c99d59" translate="yes" xml:space="preserve">
          <source>Boolean|Array</source>
          <target state="translated">Boolean|Array</target>
        </trans-unit>
        <trans-unit id="a0ce6d436df7b39ce692560a8fcae315bc3649d0" translate="yes" xml:space="preserve">
          <source>Boot a new instance of &lt;code&gt;ApplicationInstance&lt;/code&gt; for the current application and navigate it to the given &lt;code&gt;url&lt;/code&gt;. Returns a &lt;code&gt;Promise&lt;/code&gt; that resolves with the instance when the initial routing and rendering is complete, or rejects with any error that occurred during the boot process.</source>
          <target state="translated">为当前应用程序启动一个新的 &lt;code&gt;ApplicationInstance&lt;/code&gt; 实例，并将其导航到给定的 &lt;code&gt;url&lt;/code&gt; 。返回一个 &lt;code&gt;Promise&lt;/code&gt; ，当初始路由和渲染完成时，该Promise会与实例一起解析，否则会因引导过程中发生的任何错误而被拒绝。</target>
        </trans-unit>
        <trans-unit id="b662f901820aa84703a5ab27406f020b71d12fac" translate="yes" xml:space="preserve">
          <source>Boot a new instance of &lt;code&gt;Ember.ApplicationInstance&lt;/code&gt; for the current application and navigate it to the given &lt;code&gt;url&lt;/code&gt;. Returns a &lt;code&gt;Promise&lt;/code&gt; that resolves with the instance when the initial routing and rendering is complete, or rejects with any error that occurred during the boot process.</source>
          <target state="translated">为当前应用程序启动新的 &lt;code&gt;Ember.ApplicationInstance&lt;/code&gt; 实例，并将其导航到给定的 &lt;code&gt;url&lt;/code&gt; 。返回一个 &lt;code&gt;Promise&lt;/code&gt; ，当初始路由和渲染完成时，该Promise会与实例一起解析，否则会因引导过程中发生的任何错误而拒绝。</target>
        </trans-unit>
        <trans-unit id="ce578ae18e3ade88013885d6663439b3efff0f30" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;classNames&lt;/code&gt; and &lt;code&gt;classNameBindings&lt;/code&gt; are concatenated properties. See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/EmberObject&quot;&gt;EmberObject&lt;/a&gt; documentation for more information about concatenated properties.</source>
          <target state="translated">这两个 &lt;code&gt;classNames&lt;/code&gt; 和 &lt;code&gt;classNameBindings&lt;/code&gt; 是级联特性。有关串联属性的更多信息，请参见&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/EmberObject&quot;&gt;EmberObject&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="95fba81bae1171011d3f83b597f4397b483f650b" translate="yes" xml:space="preserve">
          <source>Both LESS and Sass are types of CSS preprocessor markup intended to give you much more control over your CSS. During the build process, the LESS or Sass resources compile down to vanilla CSS (which can be executed in a browser).</source>
          <target state="translated">LESS和Sass都是CSS预处理标记的类型,目的是让你对CSS有更多的控制。在构建过程中,LESS或Sass资源会被编译成普通的CSS(可以在浏览器中执行)。</target>
        </trans-unit>
        <trans-unit id="75850e5e7412f29fd9186adb3afcb9b8ecaa0835" translate="yes" xml:space="preserve">
          <source>Both assistive technologies and conventional user agents can render text more accurately when the language of the Web page is identified. Screen readers can load the correct pronunciation rules. Visual browsers can display characters and scripts correctly. Media players can show captions correctly. As a result, users with disabilities will be better able to understand the content. &lt;a href=&quot;https://www.w3.org/WAI/WCAG21/Understanding/language-of-page.html#intent&quot;&gt;WCAG Success Criterion 3.1.1: Intent&lt;/a&gt;</source>
          <target state="translated">识别网页的语言时，辅助技术和常规用户代理都可以更准确地呈现文本。屏幕阅读器可以加载正确的发音规则。视觉浏览器可以正确显示字符和脚本。媒体播放器可以正确显示字幕。结果，残疾用户将能够更好地理解内容。&lt;a href=&quot;https://www.w3.org/WAI/WCAG21/Understanding/language-of-page.html#intent&quot;&gt;WCAG成功标准3.1.1：意图&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89800a13eb0f94d7dbcccff2650f44de3da79f96" translate="yes" xml:space="preserve">
          <source>Both callbacks will be passed the observed object, starting index of the change as well as a count of the items to be removed and added. You can use these callbacks to optionally inspect the array during the change, clear caches, or do any other bookkeeping necessary.</source>
          <target state="translated">这两个回调都会传递观察到的对象、变化的起始索引以及要删除和添加的项目的数量。你可以使用这些回调在变化过程中选择性地检查数组,清除缓存,或做任何其他必要的记账。</target>
        </trans-unit>
        <trans-unit id="f84f09199f3be61351b1b4385a55c855a5ce2cc8" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;{{this.count}}&lt;/code&gt; and the &lt;code&gt;{{this.timesTen}}&lt;/code&gt; properties in the template will update whenever the button is clicked. Any tracked properties that are used in any way to calculate a value that is used in the template will cause a rerender when updated - this includes through method calls and other means:</source>
          <target state="translated">每当单击按钮时，模板中的 &lt;code&gt;{{this.count}}&lt;/code&gt; 和 &lt;code&gt;{{this.timesTen}}&lt;/code&gt; 属性都会更新。任何以任何方式用于计算模板中使用的值的跟踪属性都将在更新时导致重新呈现-这包括通过方法调用和其他方式进行：</target>
        </trans-unit>
        <trans-unit id="0ca7b25a12ee371fde32a1fae5ec55c746045403" translate="yes" xml:space="preserve">
          <source>Both the HTML and ARIA specifications have been written in a way that make them work together. Semantic HTML provides the necessary &lt;em&gt;context&lt;/em&gt; to screen readers.</source>
          <target state="translated">HTML和ARIA规范的编写方式都使其可以协同工作。语义HTML为屏幕阅读器提供了必要的&lt;em&gt;上下文&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="4f8a0bed1ace1b0a0bdc6b8c1770fd716ea80639" translate="yes" xml:space="preserve">
          <source>Both will result in:</source>
          <target state="translated">都会导致。</target>
        </trans-unit>
        <trans-unit id="ed6f071f5d1cc63649929752e477025e55f321df" translate="yes" xml:space="preserve">
          <source>Bound template names</source>
          <target state="translated">绑定模板名称</target>
        </trans-unit>
        <trans-unit id="2d322fc75b209892986aecddff9f51e3a71cdf28" translate="yes" xml:space="preserve">
          <source>Bound:</source>
          <target state="translated">Bound:</target>
        </trans-unit>
        <trans-unit id="1f688a06e547b5c3a43787858bd62f64749948d7" translate="yes" xml:space="preserve">
          <source>Bower</source>
          <target state="translated">Bower</target>
        </trans-unit>
        <trans-unit id="79db4f10279d627796ca873c8258739a62aa8ab0" translate="yes" xml:space="preserve">
          <source>Breaking Components Down Further</source>
          <target state="translated">进一步分解组件</target>
        </trans-unit>
        <trans-unit id="8044e0e2cd7a5d532114324b6f745ced2e7d0cca" translate="yes" xml:space="preserve">
          <source>Breaking it into pieces</source>
          <target state="translated">把它打成碎片</target>
        </trans-unit>
        <trans-unit id="3d1b3fb569c8c631d02d11ef9aec80f1758c78ab" translate="yes" xml:space="preserve">
          <source>Broadly speaking, these tests differ in two aspects:</source>
          <target state="translated">大体上,这些测试在两个方面有所不同。</target>
        </trans-unit>
        <trans-unit id="b025f7993f95344119634bb5b50e594147ae1a68" translate="yes" xml:space="preserve">
          <source>Browser Applications (Manual Boot)</source>
          <target state="translated">浏览器应用程序(手动启动</target>
        </trans-unit>
        <trans-unit id="8b8f118d4bcfd41266285e6076c5e95f509a6757" translate="yes" xml:space="preserve">
          <source>Browser events may bubble up the DOM which potentially target parent component(s) in succession. To enable bubbling &lt;code&gt;return true;&lt;/code&gt; from the event handler method in your component.</source>
          <target state="translated">浏览器事件可能会使DOM泛滥，而DOM可能连续地以父组件为目标。要启用冒泡，请 &lt;code&gt;return true;&lt;/code&gt; 从组件中的事件处理程序方法中。</target>
        </trans-unit>
        <trans-unit id="dea4f8853fb3a2f492dbca9fc45fc7edbced2316" translate="yes" xml:space="preserve">
          <source>Browsers have implemented the spec in a way that provides functionality for free. For example, consider this code sample:</source>
          <target state="translated">浏览器以免费提供功能的方式实现了该规范。例如,考虑这个代码示例。</target>
        </trans-unit>
        <trans-unit id="b15d854cfd26c3a30d616d8c01e10ae84ecf8196" translate="yes" xml:space="preserve">
          <source>Browsers that support the &lt;code&gt;history&lt;/code&gt; API will use &lt;code&gt;HistoryLocation&lt;/code&gt;, those that do not, but still support the &lt;code&gt;hashchange&lt;/code&gt; event will use &lt;code&gt;HashLocation&lt;/code&gt;, and in the rare case neither is supported will use &lt;code&gt;NoneLocation&lt;/code&gt;.</source>
          <target state="translated">支持 &lt;code&gt;history&lt;/code&gt; API的浏览器将使用 &lt;code&gt;HistoryLocation&lt;/code&gt; ，不支持但仍支持 &lt;code&gt;hashchange&lt;/code&gt; 事件的浏览器将使用 &lt;code&gt;HashLocation&lt;/code&gt; ，在极少数情况下，都不支持的浏览器将使用 &lt;code&gt;NoneLocation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a9ec828f41619019abe66fcb1522f78d729dcdd" translate="yes" xml:space="preserve">
          <source>Browsers that update themselves (without user intervention).</source>
          <target state="translated">浏览器可自行更新(无需用户干预)。</target>
        </trans-unit>
        <trans-unit id="e4f261aee464809e1efb47e6e6abe22ebb1ee313" translate="yes" xml:space="preserve">
          <source>Bubbling</source>
          <target state="translated">Bubbling</target>
        </trans-unit>
        <trans-unit id="9692f5b1d0f56ef48cf5214d3d7cc75fc9d32e16" translate="yes" xml:space="preserve">
          <source>Build Time Configuration</source>
          <target state="translated">构建时间配置</target>
        </trans-unit>
        <trans-unit id="5dae71cf45c8a0e9183a358920801e89f36db04b" translate="yes" xml:space="preserve">
          <source>Build targets</source>
          <target state="translated">建立目标</target>
        </trans-unit>
        <trans-unit id="c1abd6bb45baaafc89778e0a9b4a7b6c23db4a86" translate="yes" xml:space="preserve">
          <source>Build targets can also be leveraged in other ways.</source>
          <target state="translated">构建目标还可以通过其他方式进行利用。</target>
        </trans-unit>
        <trans-unit id="949f39e87da5e3d727e3238031714d8c0c9b09db" translate="yes" xml:space="preserve">
          <source>BuildURLMixin</source>
          <target state="translated">BuildURLMixin</target>
        </trans-unit>
        <trans-unit id="00fa25106b200476be5023b7fcc1482fb3e8d675" translate="yes" xml:space="preserve">
          <source>Building For Production</source>
          <target state="translated">生产用建筑</target>
        </trans-unit>
        <trans-unit id="2c95c403d24822dffbdf94a7023c8ec2a153b6c4" translate="yes" xml:space="preserve">
          <source>Building a Complex Component</source>
          <target state="translated">构建一个复杂的组件</target>
        </trans-unit>
        <trans-unit id="c9f06e233758385d11a72ecfb17f98f65687a46c" translate="yes" xml:space="preserve">
          <source>Building a Data Custom Adapter</source>
          <target state="translated">构建数据自定义适配器</target>
        </trans-unit>
        <trans-unit id="17241a49497275e3e421151e5f4ee28e0a030424" translate="yes" xml:space="preserve">
          <source>Building a Simple Component</source>
          <target state="translated">构建一个简单的组件</target>
        </trans-unit>
        <trans-unit id="f3245d43f4e9a449ac5c57e3e7dc226da1811bda" translate="yes" xml:space="preserve">
          <source>Building your app to be deployed to production.</source>
          <target state="translated">构建您的应用程序以部署到生产中。</target>
        </trans-unit>
        <trans-unit id="6d640a1770c22e89b504595a96b4dce39204681f" translate="yes" xml:space="preserve">
          <source>Builds a URL for a &lt;code&gt;record.save()&lt;/code&gt; call when the record has been deleted locally.</source>
          <target state="translated">当在本地删除记录时，为 &lt;code&gt;record.save()&lt;/code&gt; 调用构建URL 。</target>
        </trans-unit>
        <trans-unit id="289ae0cc6ffa2786ea63f4cedac431aa1484e1cd" translate="yes" xml:space="preserve">
          <source>Builds a URL for a &lt;code&gt;record.save()&lt;/code&gt; call when the record has been update locally.</source>
          <target state="translated">当记录已在本地更新时，为 &lt;code&gt;record.save()&lt;/code&gt; 调用构建URL 。</target>
        </trans-unit>
        <trans-unit id="972541165054c599d0a7b044c37ee45fe27f745f" translate="yes" xml:space="preserve">
          <source>Builds a URL for a &lt;code&gt;record.save()&lt;/code&gt; call when the record has been updated locally.</source>
          <target state="translated">当记录已在本地更新时，为 &lt;code&gt;record.save()&lt;/code&gt; 调用构建URL 。</target>
        </trans-unit>
        <trans-unit id="d350078e26d21f68136280426da67e8a907f343e" translate="yes" xml:space="preserve">
          <source>Builds a URL for a &lt;code&gt;record.save()&lt;/code&gt; call when the record was created locally using &lt;code&gt;store.createRecord()&lt;/code&gt;.</source>
          <target state="translated">构建一个网址给 &lt;code&gt;record.save()&lt;/code&gt; 时，记录使用本地创建的通话 &lt;code&gt;store.createRecord()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dfb681ca48cfff21ea2a7ad620205777787d787" translate="yes" xml:space="preserve">
          <source>Builds a URL for a &lt;code&gt;store.findAll(type)&lt;/code&gt; call.</source>
          <target state="translated">为 &lt;code&gt;store.findAll(type)&lt;/code&gt; 调用构建URL 。</target>
        </trans-unit>
        <trans-unit id="e7d2314d8c9f05f30039eb7bae0132751cf51c6b" translate="yes" xml:space="preserve">
          <source>Builds a URL for a &lt;code&gt;store.findRecord(type, id)&lt;/code&gt; call.</source>
          <target state="translated">为 &lt;code&gt;store.findRecord(type, id)&lt;/code&gt; 调用构建URL 。</target>
        </trans-unit>
        <trans-unit id="82391b65699069ed3c665e2b23aac1e08fddb98f" translate="yes" xml:space="preserve">
          <source>Builds a URL for a &lt;code&gt;store.query(type, query)&lt;/code&gt; call.</source>
          <target state="translated">为 &lt;code&gt;store.query(type, query)&lt;/code&gt; 调用构建URL 。</target>
        </trans-unit>
        <trans-unit id="b32be656fe1758525ec4dd75f03d80311884b6b3" translate="yes" xml:space="preserve">
          <source>Builds a URL for a &lt;code&gt;store.queryRecord(type, query)&lt;/code&gt; call.</source>
          <target state="translated">为 &lt;code&gt;store.queryRecord(type, query)&lt;/code&gt; 调用构建URL 。</target>
        </trans-unit>
        <trans-unit id="40808a15f11cbe2c37ecc100f6b988095474cdc8" translate="yes" xml:space="preserve">
          <source>Builds a URL for a given type and optional ID.</source>
          <target state="translated">为给定的类型和可选的ID建立一个URL。</target>
        </trans-unit>
        <trans-unit id="25e79b0b1e91c20a07cd7f9cd8210c28d74d38d8" translate="yes" xml:space="preserve">
          <source>Builds a URL for coalesceing multiple &lt;code&gt;store.findRecord(type, id)&lt;/code&gt; records into 1 request when the adapter's &lt;code&gt;coalesceFindRequests&lt;/code&gt; property is true.</source>
          <target state="translated">当适配器的 &lt;code&gt;coalesceFindRequests&lt;/code&gt; 属性为true 时 &lt;code&gt;store.findRecord(type, id)&lt;/code&gt; 构建用于合并多个store.findRecord（type，id）记录到1个请求中的URL 。</target>
        </trans-unit>
        <trans-unit id="8e1ddfdef5a8a0027c4aa848724449adf561c0d2" translate="yes" xml:space="preserve">
          <source>Builds a URL for coalescing multiple &lt;code&gt;store.findRecord(type, id)&lt;/code&gt; records into 1 request when the adapter's &lt;code&gt;coalesceFindRequests&lt;/code&gt; property is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">当适配器的 &lt;code&gt;coalesceFindRequests&lt;/code&gt; 属性为 &lt;code&gt;true&lt;/code&gt; 时 &lt;code&gt;store.findRecord(type, id)&lt;/code&gt; 构建用于将多个store.findRecord（type，id）记录合并为1个请求的URL 。</target>
        </trans-unit>
        <trans-unit id="e1c2479aa18da61dd22009ae36e8b89dfec12911" translate="yes" xml:space="preserve">
          <source>Builds a URL for fetching a async belongsTo relationship when a url is not provided by the server.</source>
          <target state="translated">当服务器没有提供url时,构建一个用于获取异步 belongsTo关系的URL。</target>
        </trans-unit>
        <trans-unit id="a35268be645341dac3e743b249648a36a1e1d1d2" translate="yes" xml:space="preserve">
          <source>Builds a URL for fetching a async hasMany relationship when a url is not provided by the server.</source>
          <target state="translated">当服务器没有提供URL时,构建一个URL用于获取async hasMany关系。</target>
        </trans-unit>
        <trans-unit id="4373a991c55677910bdd0b033632b1b6527b05fa" translate="yes" xml:space="preserve">
          <source>Builds a URL for fetching an async &lt;code&gt;belongsTo&lt;/code&gt; relationship when a url is not provided by the server.</source>
          <target state="translated">当服务器未提供url时，构建一个URL来获取异步 &lt;code&gt;belongsTo&lt;/code&gt; 关系。</target>
        </trans-unit>
        <trans-unit id="37287c4a278164a757cb95ff1781ecdfbe7e50aa" translate="yes" xml:space="preserve">
          <source>Builds a URL for fetching an async &lt;code&gt;hasMany&lt;/code&gt; relationship when a URL is not provided by the server.</source>
          <target state="translated">当服务器未提供URL时，构建用于获取异步 &lt;code&gt;hasMany&lt;/code&gt; 关系的URL。</target>
        </trans-unit>
        <trans-unit id="6408bfefa5794bb4225a8f01f57427e9c8517b2c" translate="yes" xml:space="preserve">
          <source>Built-in Components</source>
          <target state="translated">内置元件</target>
        </trans-unit>
        <trans-unit id="7998e59d701a8696fc25146f2f6266408261fbbd" translate="yes" xml:space="preserve">
          <source>Built-in Helpers</source>
          <target state="translated">内置助手</target>
        </trans-unit>
        <trans-unit id="8946a7120570480ad6f64547621ff0e3a3252d35" translate="yes" xml:space="preserve">
          <source>But ES5 code is usually more verbose than the original Javascript, and over time, as browsers gain the ability to execute the new features in JavaScript and older browsers lose users, many users won't really want this verbose code as it increases their app's size and load times.</source>
          <target state="translated">但ES5代码通常比原来的Javascript更啰嗦,随着时间的推移,随着浏览器获得执行JavaScript新功能的能力,以及老浏览器的用户流失,很多用户不会真正需要这些啰嗦的代码,因为它会增加他们的应用程序的大小和加载时间。</target>
        </trans-unit>
        <trans-unit id="cd136bf9fc0af13e9982e53db70c41367980fbfd" translate="yes" xml:space="preserve">
          <source>But once loaded on a model instance, it will behave as an object:</source>
          <target state="translated">但一旦加载到一个模型实例上,它将表现为一个对象。</target>
        </trans-unit>
        <trans-unit id="70648fb1a98c6183bbac202e5d24fe2d631d6029" translate="yes" xml:space="preserve">
          <source>But our server expects data in this format:</source>
          <target state="translated">但我们的服务器希望数据是这种格式。</target>
        </trans-unit>
        <trans-unit id="9edfc7552deebbb18f0fcd23aa280b2438c4b3da" translate="yes" xml:space="preserve">
          <source>But the following will:</source>
          <target state="translated">但下面将。</target>
        </trans-unit>
        <trans-unit id="a788cef036130d6b8fd8fd213fc2929e639d7b6c" translate="yes" xml:space="preserve">
          <source>But this other case will schedule the function multiple times:</source>
          <target state="translated">但这种另一种情况下,会多次安排功能。</target>
        </trans-unit>
        <trans-unit id="105761152a1448c15df936786b070c1da391811a" translate="yes" xml:space="preserve">
          <source>But we'll also need a way to multiply the &lt;code&gt;count&lt;/code&gt; by the &lt;code&gt;multiple&lt;/code&gt; and show it in the template.</source>
          <target state="translated">但是，我们还需要一种方法来乘以 &lt;code&gt;count&lt;/code&gt; 由 &lt;code&gt;multiple&lt;/code&gt; 并显示在模板中。</target>
        </trans-unit>
        <trans-unit id="dac8b3afa0ebd029a579db73918b0978c18de432" translate="yes" xml:space="preserve">
          <source>But what about the opposite direction? How does data flow back out of the component to the parent? In Ember, components use &lt;strong&gt;actions&lt;/strong&gt; to communicate events and changes.</source>
          <target state="translated">但是相反的方向呢？数据如何从组件流回父对象？在Ember中，组件使用&lt;strong&gt;动作&lt;/strong&gt;来传达事件和更改。</target>
        </trans-unit>
        <trans-unit id="fed83b386ca22cd097b5f221caba2b9ded956d8f" translate="yes" xml:space="preserve">
          <source>But what if you have an Ember.js app that you need to embed into an existing page, or run alongside other JavaScript frameworks, or serve from the same domain as another app?</source>
          <target state="translated">但是,如果你有一个Ember.js应用,你需要嵌入到现有的页面中,或与其他JavaScript框架一起运行,或从同一域名作为另一个应用服务,怎么办?</target>
        </trans-unit>
        <trans-unit id="44849edc12fbad6421a2a5d67b046e93c35939f6" translate="yes" xml:space="preserve">
          <source>But when you need to add static methods or static properties to the class itself you can use &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_reopenClass&quot;&gt;&lt;code&gt;reopenClass()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">但是，当您需要向类本身添加静态方法或静态属性时，可以使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_reopenClass&quot;&gt; &lt;code&gt;reopenClass()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d94eb2b1e7432dbcbffc3890c7ed0270a6876866" translate="yes" xml:space="preserve">
          <source>By calling &lt;code&gt;setupTest()&lt;/code&gt;, you gain access to a few things. First is Ember's &lt;a href=&quot;https://guides.emberjs.com/applications/dependency-injection/&quot;&gt;Dependency Injection&lt;/a&gt; system. In short, you can &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/ApplicationInstance/methods#lookup&quot;&gt;look up&lt;/a&gt; anything in your application, with a little help from &lt;code&gt;this.owner&lt;/code&gt;. Second, you gain access to some common utility functions, &lt;code&gt;this.get()&lt;/code&gt; and &lt;code&gt;this.set()&lt;/code&gt;, in your tests. Finally, you can use &lt;code&gt;pauseTest()&lt;/code&gt; to &lt;a href=&quot;../index#toc_how-to-debug-tests&quot;&gt;debug your tests&lt;/a&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;setupTest()&lt;/code&gt; ，您可以访问一些内容。首先是Ember的&lt;a href=&quot;https://guides.emberjs.com/applications/dependency-injection/&quot;&gt;依赖注入&lt;/a&gt;系统。简而言之，在 &lt;code&gt;this.owner&lt;/code&gt; 的帮助下，您可以在应用程序中&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/ApplicationInstance/methods#lookup&quot;&gt;查找&lt;/a&gt;任何内容。其次，你获得了一些常见的实用功能， &lt;code&gt;this.get()&lt;/code&gt; 和 &lt;code&gt;this.set()&lt;/code&gt; ，在您的测试。最后，你可以使用 &lt;code&gt;pauseTest()&lt;/code&gt; 来&lt;a href=&quot;../index#toc_how-to-debug-tests&quot;&gt;调试你的测试&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af15bb4c3ad741a787ed9fcac10a5493b70ceee7" translate="yes" xml:space="preserve">
          <source>By comparison, using the computed macro abstracts some of this away:</source>
          <target state="translated">相比之下,使用计算的宏就抽象掉了一部分。</target>
        </trans-unit>
        <trans-unit id="4bb2b99cc531eb6e5f54f2b2cc13877e3bf5e2b6" translate="yes" xml:space="preserve">
          <source>By convention these property names are camelCase in Ember Data models. As with the &lt;code&gt;type&lt;/code&gt; names, this is different from the example attribute and relationship names shown in the &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON API spec&lt;/a&gt;. The examples in the spec use dash-case for attribute and relationship names. However, the spec does not require attribute or relationship names to follow any specific casing convention. If you are using Ember Data's own &lt;code&gt;JSONAPISerializer&lt;/code&gt; it will assume the attribute and relationship names from your API are dash-case and automatically transform them to camelCase when it creates the normalized JSON object.</source>
          <target state="translated">按照惯例，这些属性名称在Ember Data模型中为camelCase。与 &lt;code&gt;type&lt;/code&gt; 名称一样，这与&lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON API规范中&lt;/a&gt;显示的示例属性和关系名称不同。规范中的示例使用双引号表示属性和关系名称。但是，该规范不要求属性或关系名称遵循任何特定的大小写约定。如果您使用的是Ember Data自己的 &lt;code&gt;JSONAPISerializer&lt;/code&gt; ，它将假定API中的属性和关系名称是破折号，并在创建标准化JSON对象时自动将它们转换为camelCase。</target>
        </trans-unit>
        <trans-unit id="c87cfd9c921af917ed12e49fad2d762850e48642" translate="yes" xml:space="preserve">
          <source>By convention these property names are camelCase in Ember Data models. As with the &lt;code&gt;type&lt;/code&gt; names, this is different from the example attribute and relationship names shown in the &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON:API spec&lt;/a&gt;. The examples in the spec use dash-case for attribute and relationship names. However, the spec does not require attribute or relationship names to follow any specific casing convention. If you are using Ember Data's own &lt;code&gt;JSONAPISerializer&lt;/code&gt; it will assume the attribute and relationship names from your API are dash-case and automatically transform them to camelCase when it creates the normalized JSON object.</source>
          <target state="translated">按照惯例，这些属性名称在Ember Data模型中为camelCase。与 &lt;code&gt;type&lt;/code&gt; 名称一样，这与&lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON：API spec中&lt;/a&gt;显示的示例属性和关系名称不同。规范中的示例使用双引号表示属性和关系名称。但是，该规范不要求属性或关系名称遵循任何特定的大小写约定。如果您使用的是Ember Data自己的 &lt;code&gt;JSONAPISerializer&lt;/code&gt; ，它将假定API中的属性和关系名称是破折号，并在创建标准化JSON对象时自动将它们转换为camelCase。</target>
        </trans-unit>
        <trans-unit id="a94cca917e76603ba78868852ea9942b1e2e7611" translate="yes" xml:space="preserve">
          <source>By convention, properties or variables that hold classes are PascalCased, while instances are not. So, for example, the variable &lt;code&gt;Person&lt;/code&gt; would point to a class, while &lt;code&gt;person&lt;/code&gt; would point to an instance (usually of the &lt;code&gt;Person&lt;/code&gt; class). You should stick to these naming conventions in your Ember applications.</source>
          <target state="translated">按照惯例，保存类的属性或变量是PascalCased的，而实例则不是。因此，例如，变量 &lt;code&gt;Person&lt;/code&gt; 将指向一个类，而 &lt;code&gt;person&lt;/code&gt; 将指向一个实例（通常是 &lt;code&gt;Person&lt;/code&gt; 类的实例）。您应该在Ember应用程序中遵守这些命名约定。</target>
        </trans-unit>
        <trans-unit id="c713163e4371828a83c7c3cc3e1ef652942dc783" translate="yes" xml:space="preserve">
          <source>By convention, the name of a given model (its &lt;code&gt;type&lt;/code&gt;) matches the name of the file in the &lt;code&gt;app/models&lt;/code&gt; folder and should be lowercase, singular and dasherized.</source>
          <target state="translated">按照惯例，给定模型的名称（其 &lt;code&gt;type&lt;/code&gt; ）与 &lt;code&gt;app/models&lt;/code&gt; 文件夹中的文件名匹配，并且应小写，单数和反斜线。</target>
        </trans-unit>
        <trans-unit id="c939f448f0f040b28693e1777c233f4bca9b76d4" translate="yes" xml:space="preserve">
          <source>By convention, the name of a given model (its &lt;code&gt;type&lt;/code&gt;) matches the name of the file in the &lt;code&gt;app/models&lt;/code&gt; folder and should be lowercase, singular and dasherized. @mainName @ember-data/model @tag main</source>
          <target state="translated">按照惯例，给定模型的名称（其 &lt;code&gt;type&lt;/code&gt; ）与 &lt;code&gt;app/models&lt;/code&gt; 文件夹中的文件名匹配，并且应小写，单数和反斜线。@mainName @ ember-data / model @tag main</target>
        </trans-unit>
        <trans-unit id="ab7fef8badbfed80576079ff75199dd7efbf2f94" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;{{link-to}}&lt;/code&gt; is enabled. any passed value to the &lt;code&gt;disabled&lt;/code&gt; component property will disable the &lt;code&gt;link-to&lt;/code&gt; component.</source>
          <target state="translated">默认情况下， &lt;code&gt;{{link-to}}&lt;/code&gt; 是启用的。任何传递给 &lt;code&gt;disabled&lt;/code&gt; 组件属性的值都将禁用 &lt;code&gt;link-to&lt;/code&gt; 组件。</target>
        </trans-unit>
        <trans-unit id="5bd831ff22c0fdce17ff2fbad1e0840c3c362767" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;{{link-to}}&lt;/code&gt; renders an &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; element. This can be overridden for a single use of &lt;code&gt;{{link-to}}&lt;/code&gt; by supplying a &lt;code&gt;tagName&lt;/code&gt; option:</source>
          <target state="translated">默认情况下， &lt;code&gt;{{link-to}}&lt;/code&gt; 呈现一个 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 元素。可以通过提供 &lt;code&gt;tagName&lt;/code&gt; 选项来覆盖 &lt;code&gt;{{link-to}}&lt;/code&gt; 的单次使用：</target>
        </trans-unit>
        <trans-unit id="0398305836f98f70adca9c5d83e3d35006a6fa44" translate="yes" xml:space="preserve">
          <source>By default Ember Data comes with several built-in adapters. Feel free to use these adapters as a starting point for creating your own custom adapter.</source>
          <target state="translated">默认情况下,Ember Data有几个内置适配器。您可以自由使用这些适配器作为创建您自己的自定义适配器的起点。</target>
        </trans-unit>
        <trans-unit id="8e7c5bdd0380508662b5ce4ff9cdb98e82cbd0f2" translate="yes" xml:space="preserve">
          <source>By default calling &lt;code&gt;post.get('comments')&lt;/code&gt; will trigger the following requests(assuming the comments haven't been loaded before):</source>
          <target state="translated">默认情况下，调用 &lt;code&gt;post.get('comments')&lt;/code&gt; 将触发以下请求（假设之前未加载评论）：</target>
        </trans-unit>
        <trans-unit id="24e2f9a6d447981369ed080c338531747c959b0c" translate="yes" xml:space="preserve">
          <source>By default if this method is not implemented EmberData will call &lt;code&gt;findMany&lt;/code&gt; once with all requested records as a single group when &lt;code&gt;coalesceFindRequests&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">默认情况下，如果未实现此方法，则当 &lt;code&gt;coalesceFindRequests&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时，EmberData将以所有请求的记录作为一个组调用一次 &lt;code&gt;findMany&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55f744dfe5755ba94f817529b5907fd07da58d65" translate="yes" xml:space="preserve">
          <source>By default initializer names are derived from their module name. This initializer will be given the name &lt;code&gt;logger&lt;/code&gt;:</source>
          <target state="translated">默认情况下，初始化程序名称是从其模块名称派生的。该初始化程序将被命名为 &lt;code&gt;logger&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="50c99f06a230a7b8dc8be85d2e84262b5e663b7b" translate="yes" xml:space="preserve">
          <source>By default new Ember apps include &lt;a href=&quot;https://guides.emberjs.com/models/&quot;&gt;Ember Data&lt;/a&gt;, which is a separate data library that integrates with Ember and provides a solid, conventional model layer. We'll see Ember Data in action in the tutorial in the next section.</source>
          <target state="translated">默认情况下，新的Ember应用程序包括&lt;a href=&quot;https://guides.emberjs.com/models/&quot;&gt;Ember Data&lt;/a&gt;，Ember Data是与Ember集成并提供可靠的常规模型层的独立数据库。我们将在下一节的教程中看到Ember Data的实际应用。</target>
        </trans-unit>
        <trans-unit id="070c47d4fcdaf580813f4f637a17230422adb384" translate="yes" xml:space="preserve">
          <source>By default only many-to-many and many-to-none relationships are serialized. This could be configured per relationship by Serializer's &lt;code&gt;attrs&lt;/code&gt; object.</source>
          <target state="translated">默认情况下，仅对多对多和对多关系进行序列化。可以通过序列化程序的 &lt;code&gt;attrs&lt;/code&gt; 对象针对每个关系进行配置。</target>
        </trans-unit>
        <trans-unit id="eb7ced8ab34ae69dc13ee5e220022b7b95fba3cd" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;JSONAPIAdapter&lt;/code&gt; will attempt to pluralize and dasherize the model name to generate the path name. If this convention does not conform to your backend you can override the &lt;code&gt;pathForType&lt;/code&gt; method.</source>
          <target state="translated">默认情况下， &lt;code&gt;JSONAPIAdapter&lt;/code&gt; 将尝试对模型名称进行复数和反串化处理以生成路径名。如果此约定不符合您的后端，则可以重写 &lt;code&gt;pathForType&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="6d58a10585b3658a8e0ee4f17436744695172053" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;{{action}}&lt;/code&gt; helper will ignore click events with pressed modifier keys. You can supply an &lt;code&gt;allowedKeys&lt;/code&gt; option to specify which keys should not be ignored.</source>
          <target state="translated">默认情况下， &lt;code&gt;{{action}}&lt;/code&gt; 助手将忽略按下修改键的点击事件。您可以提供 &lt;code&gt;allowedKeys&lt;/code&gt; 选项来指定不应忽略的键。</target>
        </trans-unit>
        <trans-unit id="3166c3a64a70eab5fdd5e557efed5160e0e5900a" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;{{link-to}}&lt;/code&gt; component prevents the default browser action by calling &lt;code&gt;preventDefault()&lt;/code&gt; as this sort of action bubbling is normally handled internally and we do not want to take the browser to a new URL (for example).</source>
          <target state="translated">默认情况下， &lt;code&gt;{{link-to}}&lt;/code&gt; 组件通过调用 &lt;code&gt;preventDefault()&lt;/code&gt; 阻止默认的浏览器操作，因为这种操作冒泡通常是在内部处理的，我们不希望将浏览器带到新的URL（例如）。</target>
        </trans-unit>
        <trans-unit id="01b7dee22c48ccfb7d072f4ae78b8ba2ffa57fed" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;{{link-to}}&lt;/code&gt; component will bind to the &lt;code&gt;active&lt;/code&gt;, &lt;code&gt;loading&lt;/code&gt;, and &lt;code&gt;disabled&lt;/code&gt; classes. It is discouraged to override these directly.</source>
          <target state="translated">默认情况下， &lt;code&gt;{{link-to}}&lt;/code&gt; 组件将绑定到 &lt;code&gt;active&lt;/code&gt; ， &lt;code&gt;loading&lt;/code&gt; 和 &lt;code&gt;disabled&lt;/code&gt; 类。不建议直接覆盖它们。</target>
        </trans-unit>
        <trans-unit id="b6794c13710418e025c164e113b742dab502de0a" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;{{link-to}}&lt;/code&gt; component will bind to the &lt;code&gt;href&lt;/code&gt; and &lt;code&gt;title&lt;/code&gt; attributes. It's discouraged that you override these defaults, however you can push onto the array if needed.</source>
          <target state="translated">默认情况下， &lt;code&gt;{{link-to}}&lt;/code&gt; 组件将绑定到 &lt;code&gt;href&lt;/code&gt; 和 &lt;code&gt;title&lt;/code&gt; 属性。不鼓励您覆盖这些默认值，但是如果需要，您可以推送到该数组。</target>
        </trans-unit>
        <trans-unit id="06e4f4feb085cf8d074a20af9a83d65b953097b4" translate="yes" xml:space="preserve">
          <source>By default the JSONAPIAdapter will send each find request coming from a &lt;code&gt;store.find&lt;/code&gt; or from accessing a relationship separately to the server. If your server supports passing ids as a query string, you can set coalesceFindRequests to true to coalesce all find requests within a single runloop.</source>
          <target state="translated">默认情况下，JSONAPIAdapter将发送来自 &lt;code&gt;store.find&lt;/code&gt; 或来自分别访问服务器的关系的每个查找请求。如果您的服务器支持将id作为查询字符串传递，则可以将coalesceFindRequests设置为true，以合并单个runloop中的所有查找请求。</target>
        </trans-unit>
        <trans-unit id="504f6aacc74b51a8d89f5e840d19d39dc16e91db" translate="yes" xml:space="preserve">
          <source>By default the RESTAdapter will send each find request coming from a &lt;code&gt;store.find&lt;/code&gt; or from accessing a relationship separately to the server. If your server supports passing ids as a query string, you can set coalesceFindRequests to true to coalesce all find requests within a single runloop.</source>
          <target state="translated">默认情况下，RESTAdapter将发送来自 &lt;code&gt;store.find&lt;/code&gt; 或来自单独访问关系的每个查找请求到服务器。如果您的服务器支持将id作为查询字符串传递，则可以将coalesceFindRequests设置为true，以合并单个runloop中的所有查找请求。</target>
        </trans-unit>
        <trans-unit id="af6edefa7d3f9a325dcac88789a517e9953f3829" translate="yes" xml:space="preserve">
          <source>By default the adapter will target the current domain. If you would like to specify a new domain you can do so by setting the &lt;code&gt;host&lt;/code&gt; property on the adapter.</source>
          <target state="translated">默认情况下，适配器将定位当前域。如果要指定新域，可以通过在适配器上设置 &lt;code&gt;host&lt;/code&gt; 属性来指定。</target>
        </trans-unit>
        <trans-unit id="cc72cda19d335e0c30a7dffc44c4b6e212506ce4" translate="yes" xml:space="preserve">
          <source>By default the boolean transform only allows for values of &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. You can opt into allowing &lt;code&gt;null&lt;/code&gt; values for boolean attributes via &lt;code&gt;DS.attr('boolean', { allowNull: true })&lt;/code&gt;</source>
          <target state="translated">默认情况下，布尔转换仅允许值为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。您可以通过 &lt;code&gt;DS.attr('boolean', { allowNull: true })&lt;/code&gt; 选择允许为布尔属性提供 &lt;code&gt;null&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="387da59df6f8a56a8fbef265b3e9683a41f7097b" translate="yes" xml:space="preserve">
          <source>By default the controller's &lt;code&gt;model&lt;/code&gt; will be the route's model, so it does not need to be passed unless you wish to change which model is being used.</source>
          <target state="translated">默认情况下，控制器的 &lt;code&gt;model&lt;/code&gt; 将是路线的模型，因此除非您希望更改使用的模型，否则不需要传递它。</target>
        </trans-unit>
        <trans-unit id="88f29fafe048e43628ee4aec43e238b5dc79cec5" translate="yes" xml:space="preserve">
          <source>By default the function backing the computed property will only be called once and the result will be cached. You can specify various properties that your computed property depends on. This will force the cached result to be recomputed if the dependencies are modified.</source>
          <target state="translated">默认情况下,支持计算属性的函数只会被调用一次,结果会被缓存。你可以指定你的计算属性所依赖的各种属性,这将迫使缓存的结果在依赖关系被修改时被重新计算。如果依赖关系被修改,这将迫使缓存的结果被重新计算。</target>
        </trans-unit>
        <trans-unit id="c137c99672cba4b157461ab3d46594e1a5abe4d5" translate="yes" xml:space="preserve">
          <source>By default the modelName for a model is its name in dasherized form. This means that a payload key like &quot;blogPost&quot; would be normalized to &quot;blog-post&quot; when Ember Data looks up the model. Usually, Ember Data can use the correct inflection to do this for you. Most of the time, you won't need to override &lt;code&gt;modelNameFromPayloadKey&lt;/code&gt; for this purpose.</source>
          <target state="translated">默认情况下，模型的modelName是其名称以反斜线形式表示。这意味着当Ember Data查找模型时，有效负载密钥（例如&amp;ldquo; blogPost&amp;rdquo;）将被标准化为&amp;ldquo; blog-post&amp;rdquo;。通常，Ember Data可以使用正确的变形为您执行此操作。在大多数情况下，您无需为此覆盖 &lt;code&gt;modelNameFromPayloadKey&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c77ad946e971938391972b9f793a7a818ea528c" translate="yes" xml:space="preserve">
          <source>By default the modelName for a model is its name in dasherized form. Usually, Ember Data can use the correct inflection to do this for you. Most of the time, you won't need to override &lt;code&gt;modelNameFromPayloadType&lt;/code&gt; for this purpose.</source>
          <target state="translated">默认情况下，模型的modelName是其名称以反斜线形式表示。通常，Ember Data可以使用正确的变形为您执行此操作。大多数情况下，您无需为此覆盖 &lt;code&gt;modelNameFromPayloadType&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de92b9f8150e4df8e69de5b8e22cae5f3178e5c9" translate="yes" xml:space="preserve">
          <source>By default the modelName for a model is its singularized name in dasherized form. Usually, Ember Data can use the correct inflection to do this for you. Most of the time, you won't need to override &lt;code&gt;modelNameFromPayloadType&lt;/code&gt; for this purpose.</source>
          <target state="translated">默认情况下，模型的modelName是其单数形式的名称（以反斜线形式表示）。通常，Ember Data可以使用正确的变形为您执行此操作。大多数情况下，您无需为此覆盖 &lt;code&gt;modelNameFromPayloadType&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6800977c0484482dcb2cb2742379c10c0625d474" translate="yes" xml:space="preserve">
          <source>By default the payload type is the camelized model name. Usually, Ember Data can use the correct inflection to do this for you. Most of the time, you won't need to override &lt;code&gt;payloadTypeFromModelName&lt;/code&gt; for this purpose.</source>
          <target state="translated">默认情况下，有效负载类型是驼峰模型名称。通常，Ember Data可以使用正确的变形为您执行此操作。在大多数情况下，您不需要为此目的覆盖 &lt;code&gt;payloadTypeFromModelName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f18c6cc0cf8419c23c178cfc2fc4de15f7a881e" translate="yes" xml:space="preserve">
          <source>By default the payload type is the pluralized model name. Usually, Ember Data can use the correct inflection to do this for you. Most of the time, you won't need to override &lt;code&gt;payloadTypeFromModelName&lt;/code&gt; for this purpose.</source>
          <target state="translated">默认情况下，有效负载类型为复数型号名称。通常，Ember Data可以使用正确的变形为您执行此操作。在大多数情况下，您不需要为此目的覆盖 &lt;code&gt;payloadTypeFromModelName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f27d0d1c29dc7731cfb2b55d2d8109145de649bd" translate="yes" xml:space="preserve">
          <source>By default the snapshot's id (String) is set on the json hash via json[primaryKey] = snapshot.id.</source>
          <target state="translated">默认情况下,快照的id(String)是通过json[primaryKey]=snapshot.id在json哈希中设置的。</target>
        </trans-unit>
        <trans-unit id="b8d86af84b8ba24fc9bbc906d3fc240124920b92" translate="yes" xml:space="preserve">
          <source>By default the store will try to coalesce all &lt;code&gt;fetchRecord&lt;/code&gt; calls within the same runloop into as few requests as possible by calling groupRecordsForFindMany and passing it into a findMany call. You can opt out of this behaviour by either not implementing the findMany hook or by setting coalesceFindRequests to false.</source>
          <target state="translated">默认情况下，商店将通过调用groupRecordsForFindMany并将其传递给findMany调用，尝试将同一runloop中的所有 &lt;code&gt;fetchRecord&lt;/code&gt; 调用合并为尽可能少的请求。您可以通过不实现findMany挂钩或将CoalesceFindRequests设置为false来选择退出此行为。</target>
        </trans-unit>
        <trans-unit id="481a70ca186a88fd4ee402205ad3861d43ae6686" translate="yes" xml:space="preserve">
          <source>By default the value of the &lt;code&gt;headers&lt;/code&gt; property of the adapter is returned.</source>
          <target state="translated">默认情况下，返回适配器的 &lt;code&gt;headers&lt;/code&gt; 属性的值。</target>
        </trans-unit>
        <trans-unit id="e2b894ed448ac9a0c0501fc3970e12fff7eb9064" translate="yes" xml:space="preserve">
          <source>By default this component will forward &lt;code&gt;href&lt;/code&gt;, &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;rel&lt;/code&gt;, &lt;code&gt;tabindex&lt;/code&gt;, and &lt;code&gt;target&lt;/code&gt; arguments to attributes on the component's element. When invoked with &lt;code&gt;{{link-to}}&lt;/code&gt;, you can only customize these attributes. When invoked with &lt;code&gt;&amp;lt;LinkTo&amp;gt;&lt;/code&gt;, you can just use HTML attributes directly.</source>
          <target state="translated">默认情况下，此组件会将 &lt;code&gt;href&lt;/code&gt; ， &lt;code&gt;title&lt;/code&gt; ， &lt;code&gt;rel&lt;/code&gt; ， &lt;code&gt;tabindex&lt;/code&gt; 和 &lt;code&gt;target&lt;/code&gt; 参数转发给组件元素上的属性。当使用 &lt;code&gt;{{link-to}}&lt;/code&gt; 调用时，您只能自定义这些属性。用 &lt;code&gt;&amp;lt;LinkTo&amp;gt;&lt;/code&gt; 调用时，您可以直接使用HTML属性。</target>
        </trans-unit>
        <trans-unit id="cb483213b1cc75913f05136b8de82588bdd10989" translate="yes" xml:space="preserve">
          <source>By default this component will forward a number of arguments to attributes on the the component's element:</source>
          <target state="translated">默认情况下,该组件会将一些参数转发给组件元素上的属性。</target>
        </trans-unit>
        <trans-unit id="121d9b12b56756adf43f98fdc9bf2ae06c92793b" translate="yes" xml:space="preserve">
          <source>By default this component will set classes on its element when any of the following arguments are truthy:</source>
          <target state="translated">默认情况下,当以下任何一个参数为truthhy时,该组件将在其元素上设置类。</target>
        </trans-unit>
        <trans-unit id="1358c19a54d35cea536679b1310b38c92948d937" translate="yes" xml:space="preserve">
          <source>By default this hook just returns the json payload passed to it. You might want to override it in two cases:</source>
          <target state="translated">默认情况下,这个钩子只是返回传递给它的json有效载荷。你可能想在两种情况下重写它。</target>
        </trans-unit>
        <trans-unit id="7e463052a16e66f773f873c51aab318423fe874f" translate="yes" xml:space="preserve">
          <source>By default this hook returns &lt;code&gt;false&lt;/code&gt;, as most UIs should not block user interactions while waiting on data update.</source>
          <target state="translated">默认情况下，此挂钩返回 &lt;code&gt;false&lt;/code&gt; ，因为大多数UI在等待数据更新时不应阻止用户交互。</target>
        </trans-unit>
        <trans-unit id="35b897102d575e89bf0a2b71be0d85083134b480" translate="yes" xml:space="preserve">
          <source>By default this hook returns &lt;code&gt;true&lt;/code&gt; so the data for the record is updated in the background.</source>
          <target state="translated">默认情况下，此挂钩返回 &lt;code&gt;true&lt;/code&gt; ,因此记录的数据在后台更新。</target>
        </trans-unit>
        <trans-unit id="9ac5e2eb4137e0a7f4543e8db2fadbbd1949b391" translate="yes" xml:space="preserve">
          <source>By default this method returns &lt;code&gt;true&lt;/code&gt;, indicating that a background reload should always be triggered.</source>
          <target state="translated">默认情况下，此方法返回 &lt;code&gt;true&lt;/code&gt; ，指示应始终触发后台重新加载。</target>
        </trans-unit>
        <trans-unit id="c15feeb92091ec4574c102af2950a0b12b0095a4" translate="yes" xml:space="preserve">
          <source>By default this methods returns &lt;code&gt;true&lt;/code&gt; if the passed &lt;code&gt;snapshotRecordArray&lt;/code&gt; is empty (meaning that there are no records locally available yet), otherwise it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">默认情况下，如果传递的 &lt;code&gt;snapshotRecordArray&lt;/code&gt; 为空（表示尚无本地可用记录），则此方法返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac286970e65a66ed46573d9fb4eebe5d33dc9ce0" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;import&lt;/code&gt;ed assets will be copied to &lt;code&gt;dist/&lt;/code&gt; as they are, with the existing directory structure maintained.</source>
          <target state="translated">默认情况下， &lt;code&gt;import&lt;/code&gt; 资产将按原样复制到 &lt;code&gt;dist/&lt;/code&gt; ，并保留现有目录结构。</target>
        </trans-unit>
        <trans-unit id="fcfd723bf5a7dbc5a600bf49491f8d54a7c6be67" translate="yes" xml:space="preserve">
          <source>By default, Ember CLI does not generate a file for its application route. To extend the behavior of the ember application route we will run the command &lt;code&gt;ember generate route application&lt;/code&gt;. Ember CLI does however generate an application template, so when asked whether we want to overwrite &lt;code&gt;app/templates/application.hbs&lt;/code&gt; we will answer 'n'.</source>
          <target state="translated">默认情况下，Ember CLI不会为其应用程序路由生成文件。为了扩展ember应用程序路由的行为，我们将运行命令 &lt;code&gt;ember generate route application&lt;/code&gt; 。但是，Ember CLI确实会生成一个应用程序模板，因此当被问及是否要覆盖 &lt;code&gt;app/templates/application.hbs&lt;/code&gt; 时,我们将回答'n'。</target>
        </trans-unit>
        <trans-unit id="ae742c3fe061fb2c8c5eb3f656182d05648e1322" translate="yes" xml:space="preserve">
          <source>By default, Ember Data is designed to work out of the box with &lt;a href=&quot;http://jsonapi.org&quot;&gt;JSON:API&lt;/a&gt;. JSON:API is a formal specification for building conventional, robust, and performant APIs that allow clients and servers to communicate model data.</source>
          <target state="translated">默认情况下，Ember Data旨在与&lt;a href=&quot;http://jsonapi.org&quot;&gt;JSON：API一起使用&lt;/a&gt;。JSON：API是用于构建常规，健壮和高性能的API的正式规范，该API允许客户端和服务器通信模型数据。</target>
        </trans-unit>
        <trans-unit id="1eb67730642c060b291fd8097d1a3f7e283b32d8" translate="yes" xml:space="preserve">
          <source>By default, Ember Data uses and recommends the &lt;code&gt;JSONAPISerializer&lt;/code&gt;.</source>
          <target state="translated">默认情况下，Ember Data使用并推荐 &lt;code&gt;JSONAPISerializer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="884276af340a1350bf8ad5600a0271ca7bf2151f" translate="yes" xml:space="preserve">
          <source>By default, Ember Data will &lt;code&gt;POST&lt;/code&gt; newly created records to their type URL.</source>
          <target state="translated">默认情况下，子玉的数据将 &lt;code&gt;POST&lt;/code&gt; 新创建的记录，其类型URL。</target>
        </trans-unit>
        <trans-unit id="8b421f430e90e01048a2284b47bf293a3d391586" translate="yes" xml:space="preserve">
          <source>By default, Ember Data will &lt;code&gt;POST&lt;/code&gt; newly created records to their type url.</source>
          <target state="translated">默认情况下，子玉的数据将 &lt;code&gt;POST&lt;/code&gt; 新创建的记录，其类型的URL。</target>
        </trans-unit>
        <trans-unit id="6c869aec8d2659935383ec77d6d8a3c83c0857bd" translate="yes" xml:space="preserve">
          <source>By default, Ember assumes that none of the values that are rendered will ever change. In some cases this is clearly true - for instance, the punctuation in the template will always be the same, so Ember doesn't need to do anything to update it. These are static, state-less parts of the template. In other cases, like &lt;code&gt;this.greeting&lt;/code&gt; or &lt;code&gt;@name&lt;/code&gt; argument, that's less clear. It appears &lt;code&gt;language&lt;/code&gt; might be something we want to update, and if we do, then &lt;code&gt;greeting&lt;/code&gt; should probably change, right? At the least, we should &lt;em&gt;check&lt;/em&gt; to see if it should change.</source>
          <target state="translated">默认情况下，Ember假定呈现的任何值都不会更改。在某些情况下，这显然是正确的-例如，模板中的标点符号将始终相同，因此Ember无需执行任何操作即可对其进行更新。这些是模板的静态，无状态部分。在其他情况下，例如 &lt;code&gt;this.greeting&lt;/code&gt; 或 &lt;code&gt;@name&lt;/code&gt; 参数，则不太清楚。看来 &lt;code&gt;language&lt;/code&gt; 可能是我们想要更新的东西，如果这样做， &lt;code&gt;greeting&lt;/code&gt; 可能应该改变，对吗？至少，我们应该&lt;em&gt;检查&lt;/em&gt;它是否应该更改。</target>
        </trans-unit>
        <trans-unit id="fc388b9f9fbf30c27d4c38581e1dfed911c7e214" translate="yes" xml:space="preserve">
          <source>By default, Ember will attempt to instantiate a registered factory when it is looked up. When registering an already instantiated object instead of a class, use the &lt;code&gt;instantiate: false&lt;/code&gt; option to avoid attempts to re-instantiate it during lookups.</source>
          <target state="translated">默认情况下，Ember将在查找时尝试实例化已注册的工厂。当注册一个已经实例化的对象而不是一个类时，请使用 &lt;code&gt;instantiate: false&lt;/code&gt; 选项，以避免在查找期间尝试重新实例化它。</target>
        </trans-unit>
        <trans-unit id="f2d76a4c9eebb602f6b3e859ce500dd273905c1e" translate="yes" xml:space="preserve">
          <source>By default, Ember will lookup a route's controller that matches the name of the route (i.e. &lt;code&gt;App.PostController&lt;/code&gt; for &lt;code&gt;App.PostRoute&lt;/code&gt;). However, if you would like to define a specific controller to use, you can do so using this property.</source>
          <target state="translated">默认情况下，Ember将查找与该路由名称匹配的路由控制器（即 &lt;code&gt;App.PostController&lt;/code&gt; 为 &lt;code&gt;App.PostRoute&lt;/code&gt; ）。但是，如果您想定义要使用的特定控制器，则可以使用此属性。</target>
        </trans-unit>
        <trans-unit id="f46ea5c2c2ea47e7d75eaa37ae6824cd1d6c7f3f" translate="yes" xml:space="preserve">
          <source>By default, Ember will lookup a route's controller that matches the name of the route (i.e. &lt;code&gt;posts.new&lt;/code&gt;). However, if you would like to define a specific controller to use, you can do so using this property.</source>
          <target state="translated">默认情况下，Ember将查找与该路由名称匹配的路由控制器（即 &lt;code&gt;posts.new&lt;/code&gt; ）。但是，如果要定义要使用的特定控制器，则可以使用此属性。</target>
        </trans-unit>
        <trans-unit id="cca133aebe6d5f58f902cdeb7505db4d5e9e8caf" translate="yes" xml:space="preserve">
          <source>By default, Ember will use &lt;code&gt;pushState&lt;/code&gt; to update the URL in the address bar in response to a controller query param property change. If you would like to use &lt;code&gt;replaceState&lt;/code&gt; instead, which prevents an additional item from being added to your browser's history, you can specify this as follows:</source>
          <target state="translated">默认情况下，Ember将使用 &lt;code&gt;pushState&lt;/code&gt; 更新地址栏中的URL，以响应控制器查询参数属性的更改。如果要改用 &lt;code&gt;replaceState&lt;/code&gt; ，以防止将其他项添加到浏览器的历史记录中，则可以如下指定：</target>
        </trans-unit>
        <trans-unit id="8b1135bc0a8d2816333641964de7a779056ffc03" translate="yes" xml:space="preserve">
          <source>By default, Ember.js will extend the prototypes of native JavaScript objects in the following ways:</source>
          <target state="translated">默认情况下,Ember.js会以以下方式扩展原生JavaScript对象的原型。</target>
        </trans-unit>
        <trans-unit id="75a501cb01ffff8dd03c68d44ea685ad6fff5d58" translate="yes" xml:space="preserve">
          <source>By default, Ember.js will replace each dynamic segment in the URL with the model object's &lt;code&gt;id&lt;/code&gt; property. In the example above, the &lt;code&gt;@model&lt;/code&gt; argument is the &lt;code&gt;photo&lt;/code&gt; objects, and their &lt;code&gt;id&lt;/code&gt; properties are used to fill in the dynamic segment in the URL; in this case, either &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;3&lt;/code&gt;. This behavior can be customized within &lt;code&gt;PhotoEditRoute&lt;/code&gt;'s &lt;code&gt;serialize&lt;/code&gt; hook.</source>
          <target state="translated">默认情况下，Ember.js将用模型对象的 &lt;code&gt;id&lt;/code&gt; 属性替换URL中的每个动态段。在上面的示例中， &lt;code&gt;@model&lt;/code&gt; 参数是 &lt;code&gt;photo&lt;/code&gt; 对象，其 &lt;code&gt;id&lt;/code&gt; 属性用于填充URL中的动态段；在这种情况下，无论是 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; ，或 &lt;code&gt;3&lt;/code&gt; 。可以在 &lt;code&gt;PhotoEditRoute&lt;/code&gt; 的 &lt;code&gt;serialize&lt;/code&gt; 挂钩中自定义此行为。</target>
        </trans-unit>
        <trans-unit id="80642b442dac8d83d1e353bcf810ebb7af998671" translate="yes" xml:space="preserve">
          <source>By default, Octane does not include jQuery. Continuing to use jQuery in your app will not conflict with Octane features, however you should follow the deprecation instructions for &lt;a href=&quot;https://deprecations.emberjs.com/v3.x/#toc_jquery-apis&quot;&gt;&lt;code&gt;jquery-apis&lt;/code&gt;&lt;/a&gt; if you need to keep using it.</source>
          <target state="translated">默认情况下，Octane不包含jQuery。继续在您的应用程序中使用jQuery不会与Octane功能冲突，但是，如果需要继续使用它，则应遵循&lt;a href=&quot;https://deprecations.emberjs.com/v3.x/#toc_jquery-apis&quot;&gt; &lt;code&gt;jquery-apis&lt;/code&gt; &lt;/a&gt;的弃用说明。</target>
        </trans-unit>
        <trans-unit id="2346823cdf60d6253f5a11f022e58817de7bef12" translate="yes" xml:space="preserve">
          <source>By default, a route handler will render the template with the same name as the route. Take this router:</source>
          <target state="translated">默认情况下,路由处理程序会呈现与路由同名的模板。以这个路由为例。</target>
        </trans-unit>
        <trans-unit id="2f5cfecead5797053c6caf503b3b9088ec223de1" translate="yes" xml:space="preserve">
          <source>By default, an action will stop bubbling once a handler defined on the &lt;code&gt;actions&lt;/code&gt; hash handles it. To continue bubbling the action, you must return &lt;code&gt;true&lt;/code&gt; from the handler:</source>
          <target state="translated">默认情况下，一旦在 &lt;code&gt;actions&lt;/code&gt; 哈希中定义的处理程序对其进行处理，该动作将停止冒泡。要继续冒该动作，必须从处理程序中返回 &lt;code&gt;true&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="287b919ecdecf0e2a44e4911ab979d269cbe408c" translate="yes" xml:space="preserve">
          <source>By default, applications will have a single &lt;code&gt;Store&lt;/code&gt; service that is automatically created.</source>
          <target state="translated">默认情况下，应用程序将具有一个自动创建的 &lt;code&gt;Store&lt;/code&gt; 服务。</target>
        </trans-unit>
        <trans-unit id="db95e1ddc416ca4dcc871a866afbc49b8abcf3d8" translate="yes" xml:space="preserve">
          <source>By default, attributes are passed through as-is, unless you specified an attribute type (&lt;code&gt;DS.attr('date')&lt;/code&gt;). If you specify a transform, the JavaScript value will be serialized when inserted into the JSON hash.</source>
          <target state="translated">默认情况下，除非您指定属性类型（ &lt;code&gt;DS.attr('date')&lt;/code&gt; ），否则属性按原样传递。如果指定转换，则将JavaScript值插入JSON哈希后将被序列化。</target>
        </trans-unit>
        <trans-unit id="0340bfa8c6531c91607059be240efc863fe50fd6" translate="yes" xml:space="preserve">
          <source>By default, attributes are passed through as-is, unless you specified an attribute type (&lt;code&gt;attr('date')&lt;/code&gt;). If you specify a transform, the JavaScript value will be serialized when inserted into the JSON hash.</source>
          <target state="translated">默认情况下，属性是按原样传递的，除非您指定了属性类型（ &lt;code&gt;attr('date')&lt;/code&gt; ）。如果指定转换，则将JavaScript值插入JSON哈希后将被序列化。</target>
        </trans-unit>
        <trans-unit id="e1b2b7d2b99362e2156353bd07439b10a9f15d39" translate="yes" xml:space="preserve">
          <source>By default, belongs-to relationships are converted into IDs when inserted into the JSON hash.</source>
          <target state="translated">默认情况下,当插入JSON哈希时,belongs-to关系被转换为ID。</target>
        </trans-unit>
        <trans-unit id="d439431cda7033139db4a539bfbf7a27c9249cbe" translate="yes" xml:space="preserve">
          <source>By default, calling &lt;code&gt;Ember.Application.create()&lt;/code&gt; will automatically initialize your application by calling the &lt;code&gt;Ember.Application.initialize()&lt;/code&gt; method. If you need to delay initialization, you can call your app's &lt;code&gt;deferReadiness()&lt;/code&gt; method. When you are ready for your app to be initialized, call its &lt;code&gt;advanceReadiness()&lt;/code&gt; method.</source>
          <target state="translated">默认情况下，调用 &lt;code&gt;Ember.Application.create()&lt;/code&gt; 将通过调用 &lt;code&gt;Ember.Application.initialize()&lt;/code&gt; 方法自动初始化您的应用程序。如果需要延迟初始化，则可以调用应用程序的 &lt;code&gt;deferReadiness()&lt;/code&gt; 方法。准备好初始化您的应用程序时，请调用其 &lt;code&gt;advanceReadiness()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="b3921b9dc08e373e9d7465188c32b5c7838b109f" translate="yes" xml:space="preserve">
          <source>By default, each component is backed by a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; element. If you were to look at a rendered component in your developer tools, you would see a DOM representation that looked something like:</source>
          <target state="translated">默认情况下，每个组件都有一个 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 元素支持。如果要在开发人员工具中查看呈现的组件，则会看到一个类似于DOM的表示形式：</target>
        </trans-unit>
        <trans-unit id="b939d68aa4956ef0e362b83dce5142a34a01e09f" translate="yes" xml:space="preserve">
          <source>By default, helpers and components do not accept &lt;em&gt;data attributes&lt;/em&gt;. For example</source>
          <target state="translated">默认情况下，助手和组件不接受&lt;em&gt;数据属性&lt;/em&gt;。例如</target>
        </trans-unit>
        <trans-unit id="6cf516ec9031f8a0657f90941a4445c3807f4cd4" translate="yes" xml:space="preserve">
          <source>By default, helpers are &lt;em&gt;stateless&lt;/em&gt;. They are passed inputs (parameters and a hash), they perform an operation on those inputs, and return a single output. They have no side-effects and don't save any information that is used on subsequent runs of the function.</source>
          <target state="translated">默认情况下，助手是&lt;em&gt;无状态的&lt;/em&gt;。它们是传递的输入（参数和哈希），它们对这些输入执行操作，并返回单个输出。它们没有副作用，并且不会保存该函数的后续运行中使用的任何信息。</target>
        </trans-unit>
        <trans-unit id="e61f18b8cb9b58e044b028111987ced90ec2b750" translate="yes" xml:space="preserve">
          <source>By default, if a model promise rejects during a transition, the transition is aborted, no new destination route templates are rendered, and an error is logged to the console.</source>
          <target state="translated">默认情况下,如果模型承诺在过渡期间拒绝,过渡就会被中止,不会呈现新的目的路径模板,并将错误记录到控制台。</target>
        </trans-unit>
        <trans-unit id="f523b2abe862b013a9c330366793eecbc8c121a3" translate="yes" xml:space="preserve">
          <source>By default, if your route has a dynamic segment ending in &lt;code&gt;_id&lt;/code&gt;:</source>
          <target state="translated">默认情况下，如果您的路线具有以 &lt;code&gt;_id&lt;/code&gt; 结尾的动态路段：</target>
        </trans-unit>
        <trans-unit id="8d54476788d0aaf696ac7249976396c8f62fcb0b" translate="yes" xml:space="preserve">
          <source>By default, it creates a JSON object with a key for each attribute and belongsTo relationship.</source>
          <target state="translated">默认情况下,它为每个属性和 belongsTo关系创建一个带有键的JSON对象。</target>
        </trans-unit>
        <trans-unit id="4dc01aca9ddad6593518924f00fc71526261dc06" translate="yes" xml:space="preserve">
          <source>By default, it pluralizes the type's name (for example, 'post' becomes 'posts' and 'person' becomes 'people').</source>
          <target state="translated">默认情况下,它将类型的名称复数化(例如,'post'变成了'post','person'变成了'people')。</target>
        </trans-unit>
        <trans-unit id="f39e95b2bceecaa468b43bc7bc3713edfbdc52ab" translate="yes" xml:space="preserve">
          <source>By default, it pluralizes the type's name (for example, 'post' becomes 'posts' and 'person' becomes 'people'). To override the pluralization see &lt;a href=&quot;#method_pathForType&quot;&gt;pathForType&lt;/a&gt;.</source>
          <target state="translated">默认情况下，它将类型的名称复数（例如，&amp;ldquo; post&amp;rdquo;变为&amp;ldquo; posts&amp;rdquo;，&amp;ldquo; person&amp;rdquo;变为&amp;ldquo; people&amp;rdquo;）。要覆盖复数，请参阅&lt;a href=&quot;#method_pathForType&quot;&gt;pathForType&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fe85a44dc226429c73a8e9260c97bab7bcdb231" translate="yes" xml:space="preserve">
          <source>By default, it pluralizes the type's name (for example, 'post' becomes 'posts' and 'person' becomes 'people'). To override the pluralization see &lt;a href=&quot;buildurlmixin/methods#pathForType&quot;&gt;pathForType&lt;/a&gt;.</source>
          <target state="translated">默认情况下，它将类型的名称复数（例如，&amp;ldquo; post&amp;rdquo;变为&amp;ldquo; posts&amp;rdquo;，&amp;ldquo; person&amp;rdquo;变为&amp;ldquo; people&amp;rdquo;）。要覆盖复数，请参阅&lt;a href=&quot;buildurlmixin/methods#pathForType&quot;&gt;pathForType&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b9ce8f8dc442252e04d7b7433af6a43768e10cf" translate="yes" xml:space="preserve">
          <source>By default, query param values in Ember are &quot;sticky&quot;, in that if you make changes to a query param and then leave and re-enter the route, the new value of that query param will be preserved (rather than reset to its default). This is a particularly handy default for preserving sort/filter parameters as you navigate back and forth between routes.</source>
          <target state="translated">默认情况下,Ember中的查询参数值是 &quot;粘性 &quot;的,如果你修改了一个查询参数,然后离开并重新进入路由,该查询参数的新值将被保留(而不是重置为默认值)。当你在路由之间来回浏览时,这是一个特别方便的保存排序/过滤参数的默认值。</target>
        </trans-unit>
        <trans-unit id="6cdcbdedd1009d87591c7874cc98d33d692ece43" translate="yes" xml:space="preserve">
          <source>By default, registrations are treated as &quot;singletons&quot;. This simply means that an instance will be created when it is first looked up, and this same instance will be cached and returned from subsequent lookups.</source>
          <target state="translated">默认情况下,注册被视为 &quot;单子&quot;。这简单地意味着,当第一次查询时,将创建一个实例,而这个相同的实例将被缓存并从后续的查询中返回。</target>
        </trans-unit>
        <trans-unit id="db37c21ab60a34deca18f6033d7aba2d4e5552c0" translate="yes" xml:space="preserve">
          <source>By default, specifying &lt;code&gt;foo&lt;/code&gt; as a controller query param property will bind to a query param whose key is &lt;code&gt;foo&lt;/code&gt;, e.g. &lt;code&gt;?foo=123&lt;/code&gt;. You can also map a controller property to a different query param key using the following configuration syntax:</source>
          <target state="translated">默认情况下，将 &lt;code&gt;foo&lt;/code&gt; 指定为控制器的查询参数属性将绑定到键为 &lt;code&gt;foo&lt;/code&gt; 的查询参数，例如 &lt;code&gt;?foo=123&lt;/code&gt; 。您还可以使用以下配置语法将控制器属性映射到其他查询参数键：</target>
        </trans-unit>
        <trans-unit id="0073a1ec75825f7d847ed41eec405ae5254f86db" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_action&quot;&gt;&lt;code&gt;{{action}}&lt;/code&gt;&lt;/a&gt; helper listens for click events and triggers the action when the user clicks on the element.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_action&quot;&gt; &lt;code&gt;{{action}}&lt;/code&gt; &lt;/a&gt;帮助器会监听单击事件，并在用户单击元素时触发该操作。</target>
        </trans-unit>
        <trans-unit id="1aaa2e9dda7d7c708a9dac3261825adab8e82b2a" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;JSONAPIAdapter&lt;/code&gt; will attempt to pluralize and dasherize the model name to generate the path name. If this convention does not conform to your backend you can override the &lt;code&gt;pathForType&lt;/code&gt; method.</source>
          <target state="translated">默认情况下， &lt;code&gt;JSONAPIAdapter&lt;/code&gt; 会尝试对模型名称进行复数和反序列化以生成路径名。如果此约定不符合您的后端，则可以重写 &lt;code&gt;pathForType&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="fbed8bdb5ac81c386a4c87a428dd6cd0d8fcf5e0" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;setupController&lt;/code&gt; hook sets the &lt;code&gt;model&lt;/code&gt; property of the controller to the &lt;code&gt;model&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;setupController&lt;/code&gt; 挂钩将控制器的 &lt;code&gt;model&lt;/code&gt; 属性设置为 &lt;code&gt;model&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21ae0557a45b6b70ca6eeb21d6add95c7f2352fe" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;setupController&lt;/code&gt; hook sets the &lt;code&gt;model&lt;/code&gt; property of the controller to the specified &lt;code&gt;model&lt;/code&gt; when it is not &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">默认情况下， &lt;code&gt;setupController&lt;/code&gt; 挂钩在 &lt;code&gt;undefined&lt;/code&gt; 时将控制器的 &lt;code&gt;model&lt;/code&gt; 属性设置为指定的 &lt;code&gt;model&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aff6c981fe4aced844298461f508dffc81659763" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;{{action}}&lt;/code&gt; helper prevents the default browser action of the DOM event. If you want to allow the browser action, you can stop Ember from preventing it.</source>
          <target state="translated">默认情况下， &lt;code&gt;{{action}}&lt;/code&gt; 帮助器将阻止DOM事件的默认浏览器操作。如果要允许浏览器操作，可以阻止Ember阻止它。</target>
        </trans-unit>
        <trans-unit id="1cffaa4862efc54226cf88901c712194f75c8576" translate="yes" xml:space="preserve">
          <source>By default, the RESTAdapter will send the query params sorted alphabetically to the server.</source>
          <target state="translated">默认情况下,RESTAdapter会将按字母顺序排列的查询参数发送到服务器。</target>
        </trans-unit>
        <trans-unit id="921e00e5dedf98782420379db324a08f350606a9" translate="yes" xml:space="preserve">
          <source>By default, the action handler receives the first parameter of the event listener, the event object the browser passes to the handler, so &lt;code&gt;bandDidChange&lt;/code&gt; prints &lt;code&gt;Event {}&lt;/code&gt;.</source>
          <target state="translated">默认情况下，动作处理程序接收事件侦听器的第一个参数，即浏览器传递给处理程序的事件对象，因此 &lt;code&gt;bandDidChange&lt;/code&gt; 打印 &lt;code&gt;Event {}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22698cd4cf1064e1b2491d3aa6a13ff729c00c58" translate="yes" xml:space="preserve">
          <source>By default, the adapter will target the current domain. If you would like to specify a new domain you can do so by setting the &lt;code&gt;host&lt;/code&gt; property on the adapter.</source>
          <target state="translated">默认情况下，适配器将以当前域为目标。如果您想指定一个新域，则可以通过在适配器上设置 &lt;code&gt;host&lt;/code&gt; 属性来指定。</target>
        </trans-unit>
        <trans-unit id="9db4e9a65c7168d1e0ee06a4bff3243460adb1bd" translate="yes" xml:space="preserve">
          <source>By default, the application sets up these event listeners on the document body. However, in cases where you are embedding an Ember application inside an existing page, you may want it to set up the listeners on an element inside the body.</source>
          <target state="translated">默认情况下,应用程序会在文档主体上设置这些事件监听器。然而,当你在现有的页面中嵌入Ember应用程序时,你可能希望它在正文中的元素上设置监听器。</target>
        </trans-unit>
        <trans-unit id="c05478471a1decbce75890fa12c2d46840e12aa7" translate="yes" xml:space="preserve">
          <source>By default, the application's &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; listens for a set of standard DOM events, such as &lt;code&gt;mousedown&lt;/code&gt; and &lt;code&gt;keyup&lt;/code&gt;, and delegates them to your application's &lt;code&gt;Ember.View&lt;/code&gt; instances.</source>
          <target state="translated">默认情况下，应用程序的 &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; 侦听一组标准DOM事件，例如 &lt;code&gt;mousedown&lt;/code&gt; 和 &lt;code&gt;keyup&lt;/code&gt; ，并将它们委托给应用程序的 &lt;code&gt;Ember.View&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="930afa4a1a6e3b3b34db33c1060e36b230b89cf6" translate="yes" xml:space="preserve">
          <source>By default, the boolean transform only allows for values of &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. You can opt into allowing &lt;code&gt;null&lt;/code&gt; values for boolean attributes via &lt;code&gt;attr('boolean', { allowNull: true })&lt;/code&gt;</source>
          <target state="translated">默认情况下，布尔转换仅允许值为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。您可以通过 &lt;code&gt;attr('boolean', { allowNull: true })&lt;/code&gt; 选择允许为布尔属性提供 &lt;code&gt;null&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="4c82a0d32d4ba3b8aa8a3e3616a54138c3fd231e" translate="yes" xml:space="preserve">
          <source>By default, the data will be deserialized using a default serializer (the application serializer if it exists).</source>
          <target state="translated">默认情况下,数据将使用默认的序列化器(应用序列化器,如果它存在的话)进行反序列化。</target>
        </trans-unit>
        <trans-unit id="790465ab5555e9fbfb798b4e477576ff07b98827" translate="yes" xml:space="preserve">
          <source>By default, the name of the Boolean property is dasherized. You can customize the class name applied by delimiting it with a colon:</source>
          <target state="translated">默认情况下,布尔属性的名称是破折号。您可以通过用冒号划线来自定义应用的类名。</target>
        </trans-unit>
        <trans-unit id="5c617b39af17acb89a63dac6e50e0941fe679624" translate="yes" xml:space="preserve">
          <source>By default, the render buffer will use a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; tag for views.</source>
          <target state="translated">默认情况下，渲染缓冲区将对视图使用 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 标签。</target>
        </trans-unit>
        <trans-unit id="15fe058599ba8351b2ae7aa80bb97bec6a180d05" translate="yes" xml:space="preserve">
          <source>By default, the router will begin trying to translate the current URL into application state once the browser emits the &lt;code&gt;DOMContentReady&lt;/code&gt; event. If you need to defer routing, you can call the application's &lt;code&gt;deferReadiness()&lt;/code&gt; method. Once routing can begin, call the &lt;code&gt;advanceReadiness()&lt;/code&gt; method.</source>
          <target state="translated">默认情况下，一旦浏览器发出 &lt;code&gt;DOMContentReady&lt;/code&gt; 事件，路由器将开始尝试将当前URL转换为应用程序状态。如果需要延迟路由，则可以调用应用程序的 &lt;code&gt;deferReadiness()&lt;/code&gt; 方法。一旦路由可以开始，请调用 &lt;code&gt;advanceReadiness()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="2b81d8fed92bf147220dfee742151538020231ee" translate="yes" xml:space="preserve">
          <source>By default, the store will talk to your backend using a standard REST mechanism. You can customize how the store talks to your backend by specifying a custom adapter:</source>
          <target state="translated">默认情况下,商店将使用标准的REST机制与您的后端对话。您可以通过指定一个自定义适配器来定制商店与您的后端对话的方式。</target>
        </trans-unit>
        <trans-unit id="483b91ed636b9ad3863e53255b6f4826d53bcfb2" translate="yes" xml:space="preserve">
          <source>By default, the value of the target property is set to the router, and is injected when a controller is instantiated. This injection is applied as part of the application's initialization process. In most cases the &lt;code&gt;target&lt;/code&gt; property will automatically be set to the logical consumer of actions for the controller.</source>
          <target state="translated">默认情况下，target属性的值设置为路由器，并在实例化控制器时注入。这种注入是应用程序初始化过程的一部分。在大多数情况下， &lt;code&gt;target&lt;/code&gt; 属性将自动设置为控制器操作的逻辑使用者。</target>
        </trans-unit>
        <trans-unit id="2f7deecf58415489ee625ccf2605c22daec721ec" translate="yes" xml:space="preserve">
          <source>By default, this component will add the &lt;code&gt;ember-checkbox&lt;/code&gt; class to the component's element.</source>
          <target state="translated">默认情况下，此组件会将 &lt;code&gt;ember-checkbox&lt;/code&gt; 类添加到该组件的元素中。</target>
        </trans-unit>
        <trans-unit id="bb1a5507484e7ed494b30ee63988a502f6b31ec9" translate="yes" xml:space="preserve">
          <source>By default, this component will add the &lt;code&gt;ember-text-field&lt;/code&gt; class to the component's element.</source>
          <target state="translated">默认情况下，此组件会将 &lt;code&gt;ember-text-field&lt;/code&gt; 类添加到该组件的元素中。</target>
        </trans-unit>
        <trans-unit id="d19e6853dd7fb6061aaba1d722c2a462daf0297c" translate="yes" xml:space="preserve">
          <source>By default, this hook returns &lt;code&gt;true&lt;/code&gt; so the data for the record is updated in the background.</source>
          <target state="translated">默认情况下，此挂钩返回 &lt;code&gt;true&lt;/code&gt; ,因此记录的数据在后台更新。</target>
        </trans-unit>
        <trans-unit id="69e0d28fc15f177e3e7b1c552240fa4abc15e57f" translate="yes" xml:space="preserve">
          <source>By default, this method is called automatically on &quot;DOM ready&quot;; however, if autoboot is disabled, this is automatically called when the first application instance is created via &lt;code&gt;visit&lt;/code&gt;.</source>
          <target state="translated">默认情况下，在&amp;ldquo; DOM ready&amp;rdquo;上自动调用此方法。但是，如果禁用了自动引导，则通过 &lt;code&gt;visit&lt;/code&gt; 创建第一个应用程序实例时，将自动调用此方法。</target>
        </trans-unit>
        <trans-unit id="fd9049dafb4bc2774b669f241e3f958af8185082" translate="yes" xml:space="preserve">
          <source>By default, this method returns &lt;code&gt;true&lt;/code&gt; if the passed &lt;code&gt;snapshotRecordArray&lt;/code&gt; is empty (meaning that there are no records locally available yet), otherwise, it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">默认情况下，如果传递的 &lt;code&gt;snapshotRecordArray&lt;/code&gt; 为空（表示本地没有可用的记录），则此方法返回 &lt;code&gt;true&lt;/code&gt; ，否则，返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="036035b3ac14079944e74693c433e3ade8ad0077" translate="yes" xml:space="preserve">
          <source>By default, when you extend an Ember class a property defined in the subclass overrides a property with the same name that is defined in the superclass. However, there are some cases where it is preferable to build up a property's value by combining the superclass' property value with the subclass' value. An example of this in use within Ember is the &lt;code&gt;classNames&lt;/code&gt; property of &lt;code&gt;Component&lt;/code&gt; from &lt;code&gt;@ember/component&lt;/code&gt;.</source>
          <target state="translated">默认情况下，扩展Ember类时，子类中定义的属性将覆盖与超类中定义的名称相同的属性。但是，在某些情况下，最好通过将超类的属性值与子类的值相结合来建立属性的值。在灰烬中使用这样的一个例子是 &lt;code&gt;classNames&lt;/code&gt; 的属性 &lt;code&gt;Component&lt;/code&gt; 从 &lt;code&gt;@ember/component&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60286e5362a48018810276af0272f1c5f23d0897" translate="yes" xml:space="preserve">
          <source>By default, when you extend an Ember class a property defined in the subclass overrides a property with the same name that is defined in the superclass. However, there are some cases where it is preferable to build up a property's value by combining the superclass' property value with the subclass' value. An example of this in use within Ember is the &lt;code&gt;classNames&lt;/code&gt; property of &lt;code&gt;Ember.View&lt;/code&gt;.</source>
          <target state="translated">默认情况下，扩展Ember类时，子类中定义的属性将覆盖与超类中定义的名称相同的属性。但是，在某些情况下，最好通过组合超类的属性值和子类的值来建立属性的值。在Ember中使用的一个示例是 &lt;code&gt;Ember.View&lt;/code&gt; 的 &lt;code&gt;classNames&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="141551cc0f38eb0e3405d80788a76b219cd01eab" translate="yes" xml:space="preserve">
          <source>By default, when you extend an Ember class a property defined in the subclass overrides a property with the same name that is defined in the superclass. However, there are some cases where it is preferable to build up a property's value by merging the superclass property value with the subclass property's value. An example of this in use within Ember is the &lt;code&gt;queryParams&lt;/code&gt; property of routes.</source>
          <target state="translated">默认情况下，扩展Ember类时，子类中定义的属性将覆盖与超类中定义的名称相同的属性。但是，在某些情况下，最好通过将超类属性值与子类属性值合并来建立属性值。在Ember中使用的一个示例是路由的 &lt;code&gt;queryParams&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="7ad3553f9d6ef3c9e3238830ddef88e713377559" translate="yes" xml:space="preserve">
          <source>By default, when you run &lt;code&gt;ember test --server&lt;/code&gt;, Ember CLI runs the &lt;a href=&quot;https://github.com/testem/testem&quot;&gt;Testem test runner&lt;/a&gt;, which runs Qunit in Chrome and &lt;a href=&quot;http://phantomjs.org/&quot;&gt;PhantomJS&lt;/a&gt;.</source>
          <target state="translated">默认情况下，运行 &lt;code&gt;ember test --server&lt;/code&gt; 时，Ember CLI运行&lt;a href=&quot;https://github.com/testem/testem&quot;&gt;Testem测试&lt;/a&gt;运行程序，该运行程序在Chrome和&lt;a href=&quot;http://phantomjs.org/&quot;&gt;PhantomJS中&lt;/a&gt;运行Qunit 。</target>
        </trans-unit>
        <trans-unit id="c0850d5e1a158bd3b887c16df76f38a385718772" translate="yes" xml:space="preserve">
          <source>By default, your application will render the &lt;a href=&quot;https://guides.emberjs.com/routing/defining-your-routes/#toc_the-application-route&quot;&gt;application template&lt;/a&gt; and attach it to the document's &lt;code&gt;body&lt;/code&gt; element.</source>
          <target state="translated">默认情况下，您的应用程序将呈现&lt;a href=&quot;https://guides.emberjs.com/routing/defining-your-routes/#toc_the-application-route&quot;&gt;应用程序模板&lt;/a&gt;并将其附加到文档的 &lt;code&gt;body&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="668fd716e178e64e4f5546e3cf5dfc624509d725" translate="yes" xml:space="preserve">
          <source>By doing so, Ember will use the value of the property specified (&lt;code&gt;person.name&lt;/code&gt; in the example) to find a &quot;match&quot; from the previous render. That is, if Ember has previously seen an object from the &lt;code&gt;@developers&lt;/code&gt; array with a matching name, its DOM elements will be re-used.</source>
          <target state="translated">这样，Ember将使用指定属性的值（在示例中为 &lt;code&gt;person.name&lt;/code&gt; ）从先前的渲染中查找&amp;ldquo;匹配项&amp;rdquo;。也就是说，如果Ember以前从 &lt;code&gt;@developers&lt;/code&gt; 数组中看到了一个具有匹配名称的对象，则将重新使用其DOM元素。</target>
        </trans-unit>
        <trans-unit id="ff3b597e0cf19fb03a609816b67c53bcc0cc4cd1" translate="yes" xml:space="preserve">
          <source>By example having a user that has many pets:</source>
          <target state="translated">比如说有一个用户,有很多宠物。</target>
        </trans-unit>
        <trans-unit id="7d4b6843174da27b5c04b7a61f8ca2ee85bb64f4" translate="yes" xml:space="preserve">
          <source>By keeping state in the component and handling DOM method calls in a modifier, we can use autotracking and stick to 1-way data flow in the component. Further, we could change the component's own design later &lt;em&gt;without&lt;/em&gt; having to change how we interact with the DOM element.</source>
          <target state="translated">通过在组件中保持状态并在修饰符中处理DOM方法调用，我们可以使用自动跟踪并在组件中坚持1路数据流。此外，我们可以稍后更改组件自己的设计，&lt;em&gt;而&lt;/em&gt;不必更改我们与DOM元素交互的方式。</target>
        </trans-unit>
        <trans-unit id="a624260d0566cc20f22f14a0ac7301e20a74df48" translate="yes" xml:space="preserve">
          <source>By looking at how we use the &lt;code&gt;&amp;lt;Message&amp;gt;&lt;/code&gt; component, we can see that some of the arguments are fairly repetitive. Both &lt;code&gt;@avatarTitle&lt;/code&gt; and &lt;code&gt;@avatarInitial&lt;/code&gt; are based on the user's &lt;code&gt;@username&lt;/code&gt;, but the title has more text, and the initial is only the first letter of the name. We'd rather just pass a username to the &lt;code&gt;&amp;lt;Message&amp;gt;&lt;/code&gt; component and &lt;em&gt;compute&lt;/em&gt; the value of the title and initial.</source>
          <target state="translated">通过查看我们如何使用 &lt;code&gt;&amp;lt;Message&amp;gt;&lt;/code&gt; 组件，我们可以看到某些参数是相当重复的。无论 &lt;code&gt;@avatarTitle&lt;/code&gt; 和 &lt;code&gt;@avatarInitial&lt;/code&gt; 是基于用户的 &lt;code&gt;@username&lt;/code&gt; ，但标题有更多的文本，初始只是名字的第一个字母。我们宁愿只是将用户名传递给 &lt;code&gt;&amp;lt;Message&amp;gt;&lt;/code&gt; 组件并&lt;em&gt;计算&lt;/em&gt;标题和首字母的值。</target>
        </trans-unit>
        <trans-unit id="bf547008e8efe197154dbdf1126f1f6ccd7729f9" translate="yes" xml:space="preserve">
          <source>By measuring the render time, the Inspector adds a slight delay to the rendering process. As such, the duration is not an exact representation of expected rendering time for a production application. Thus, the rendering duration is more useful to compare times than as an absolute measure of performance.</source>
          <target state="translated">通过测量渲染时间,Inspector会在渲染过程中增加一点延迟。因此,持续时间并不能准确代表生产应用程序的预期渲染时间。因此,渲染持续时间更有助于比较时间,而不是作为性能的绝对衡量标准。</target>
        </trans-unit>
        <trans-unit id="737735ccfb0b0b447ca4c19d08766c885d30f5b8" translate="yes" xml:space="preserve">
          <source>By overwriting &lt;code&gt;modelNameFromPayloadType&lt;/code&gt; you can specify that the &lt;code&gt;administrator&lt;/code&gt; model should be used:</source>
          <target state="translated">通过覆盖 &lt;code&gt;modelNameFromPayloadType&lt;/code&gt; ，可以指定应使用 &lt;code&gt;administrator&lt;/code&gt; 模型：</target>
        </trans-unit>
        <trans-unit id="023a30eaf5a49f0481c0ef84076c43c8239bcdd2" translate="yes" xml:space="preserve">
          <source>By overwriting &lt;code&gt;modelNameFromPayloadType&lt;/code&gt; you can specify that the &lt;code&gt;post&lt;/code&gt; model should be used:</source>
          <target state="translated">通过覆盖 &lt;code&gt;modelNameFromPayloadType&lt;/code&gt; ,您可以指定应使用 &lt;code&gt;post&lt;/code&gt; 模型：</target>
        </trans-unit>
        <trans-unit id="429e37999eda7e7026bbcc4685fdb4cba268e8ca" translate="yes" xml:space="preserve">
          <source>By overwriting &lt;code&gt;payloadTypeFromModelName&lt;/code&gt; you can specify that the namespaces model name for the &lt;code&gt;administrator&lt;/code&gt; should be used:</source>
          <target state="translated">通过覆盖有效 &lt;code&gt;payloadTypeFromModelName&lt;/code&gt; 自模型名称，可以指定应使用 &lt;code&gt;administrator&lt;/code&gt; 的名称空间模型名称：</target>
        </trans-unit>
        <trans-unit id="bef8b706f04806f62e4f3468b01e30a26956abbe" translate="yes" xml:space="preserve">
          <source>By overwriting &lt;code&gt;payloadTypeFromModelName&lt;/code&gt; you can specify that the namespaces model name for the &lt;code&gt;post&lt;/code&gt; should be used:</source>
          <target state="translated">通过覆盖 &lt;code&gt;payloadTypeFromModelName&lt;/code&gt; ，可以指定应使用 &lt;code&gt;post&lt;/code&gt; 的名称空间模型名称：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
