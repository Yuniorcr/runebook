<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="ember">
    <body>
      <group id="ember">
        <trans-unit id="fa74a5445ac21a141ea80fae8c137247dd31ba9d" translate="yes" xml:space="preserve">
          <source>Now in our browser we should see that the first rental property is listed as &quot;Standalone&quot;, while the other two are listed as &quot;Community&quot;.</source>
          <target state="translated">现在在我们的浏览器中,我们应该看到第一个出租房源被列为 &quot;独立&quot;,而其他两个房源被列为 &quot;社区&quot;。</target>
        </trans-unit>
        <trans-unit id="02f78c37e1d7493e21b1b94978d032932bbcb8df" translate="yes" xml:space="preserve">
          <source>Now in the browser when a scientist's name is clicked, this function is called and the person's name is alerted.</source>
          <target state="translated">现在在浏览器中,当一个科学家的名字被点击时,这个功能就会被调用,并提醒这个人的名字。</target>
        </trans-unit>
        <trans-unit id="ed29b70e455c078562a5f430d4dbd6281287bd7b" translate="yes" xml:space="preserve">
          <source>Now let's add code that simulates a visitor arriving on our homepage, clicking one of our links and then visiting a new page.</source>
          <target state="translated">现在,让我们添加代码,模拟访问者到达我们的主页,点击我们的一个链接,然后访问一个新的页面。</target>
        </trans-unit>
        <trans-unit id="697e0df1cf9b32cc42300e9918ecad3b0cea695c" translate="yes" xml:space="preserve">
          <source>Now let's create a test which will call &lt;code&gt;levelUp&lt;/code&gt; on the player when they are level 4 to assert that the &lt;code&gt;levelName&lt;/code&gt; changes. We will use &lt;code&gt;module&lt;/code&gt; together with the &lt;code&gt;setupTest&lt;/code&gt; helper method:</source>
          <target state="translated">现在让我们创建一个测试，该测试将在播放器处于4级时在播放器上调用 &lt;code&gt;levelUp&lt;/code&gt; ，以断言 &lt;code&gt;levelName&lt;/code&gt; 发生了变化。我们将 &lt;code&gt;module&lt;/code&gt; 与 &lt;code&gt;setupTest&lt;/code&gt; 帮助器方法一起使用：</target>
        </trans-unit>
        <trans-unit id="c09d33d498277510cb65c5bde600e541b65944ec" translate="yes" xml:space="preserve">
          <source>Now let's create a test which will call &lt;code&gt;levelUp&lt;/code&gt; on the player when they are level 4 to assert that the &lt;code&gt;levelName&lt;/code&gt; changes. We will use &lt;code&gt;moduleForModel&lt;/code&gt;:</source>
          <target state="translated">现在让我们创建一个测试，该测试将在播放器达到4级时在播放器上调用 &lt;code&gt;levelUp&lt;/code&gt; ，以断言 &lt;code&gt;levelName&lt;/code&gt; 发生了变化。我们将使用 &lt;code&gt;moduleForModel&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="37fd2a1099f983eece52ae774c4e471341b866db" translate="yes" xml:space="preserve">
          <source>Now let's create another route with contact details for the company. Once again, we'll start by generating a route:</source>
          <target state="translated">现在让我们创建另一条包含公司联系方式的路线。再一次,我们将从生成一条路线开始。</target>
        </trans-unit>
        <trans-unit id="311e7c28de846f6b4798420c4a5a9e440da7f54c" translate="yes" xml:space="preserve">
          <source>Now let's render our component using the &lt;code&gt;render&lt;/code&gt; function. The &lt;code&gt;render&lt;/code&gt; function allows us to pass a template string, so that we can declare the component in the same way we do in our templates. Since we set the &lt;code&gt;rentalObj&lt;/code&gt; variable to our local scope, we can access it as part of our render string.</source>
          <target state="translated">现在，让我们使用 &lt;code&gt;render&lt;/code&gt; 函数来渲染我们的组件。该 &lt;code&gt;render&lt;/code&gt; 功能可以让我们通过一个模板字符串，这样我们就可以在我们在我们的模板做同样的方式宣布该组件。由于我们将 &lt;code&gt;rentalObj&lt;/code&gt; 变量设置为本地范围，因此我们可以将其作为渲染字符串的一部分进行访问。</target>
        </trans-unit>
        <trans-unit id="431b5430f4b40181fa2b80add538cc5e19028acf" translate="yes" xml:space="preserve">
          <source>Now let's say your template is starting to get a bit cluttered and you want to clean up the logic in your templates. This can be achieved with the &lt;code&gt;let&lt;/code&gt; block helper. The &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#let&quot;&gt;&lt;code&gt;{{let}}&lt;/code&gt;&lt;/a&gt; helper lets you create new bindings (or temporary variables) in your template.</source>
          <target state="translated">现在，让我们说您的模板开始变得有些混乱，您想清理模板中的逻辑。这可以通过 &lt;code&gt;let&lt;/code&gt; 块帮助器来实现。使用&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#let&quot;&gt; &lt;code&gt;{{let}}&lt;/code&gt; &lt;/a&gt;帮助程序，您可以在模板中创建新的绑定（或临时变量）。</target>
        </trans-unit>
        <trans-unit id="ae22d53ed6893c6b12aeed6c790fd45587cc8f49" translate="yes" xml:space="preserve">
          <source>Now let's tell Ember how to turn that array of strings into HTML. Open the &lt;code&gt;scientists&lt;/code&gt; template and add the following code to loop through the array and print it:</source>
          <target state="translated">现在，让我们告诉Ember如何将字符串数组转换为HTML。打开 &lt;code&gt;scientists&lt;/code&gt; 模板，并添加以下代码以遍历数组并打印：</target>
        </trans-unit>
        <trans-unit id="7f913783707682a29aebe4955714ed5c947732a8" translate="yes" xml:space="preserve">
          <source>Now let's test that the map component is relying on our service to provide map elements.</source>
          <target state="translated">现在让我们测试一下地图组件是否依靠我们的服务来提供地图元素。</target>
        </trans-unit>
        <trans-unit id="96f7e41a4cd747d58701a050ee081913d14c9b5e" translate="yes" xml:space="preserve">
          <source>Now let's write a test that sets a property on our &lt;code&gt;post&lt;/code&gt; model in the &lt;code&gt;PostController&lt;/code&gt; that would be available on the &lt;code&gt;CommentsController&lt;/code&gt;.</source>
          <target state="translated">现在，让我们编写一个测试，在 &lt;code&gt;PostController&lt;/code&gt; 中的 &lt;code&gt;post&lt;/code&gt; 模型上设置一个属性，该属性将在 &lt;code&gt;CommentsController&lt;/code&gt; 上可用。</target>
        </trans-unit>
        <trans-unit id="c9f9ed10a2412df54c18588a43c8397490d4ba61" translate="yes" xml:space="preserve">
          <source>Now run &lt;code&gt;ember server&lt;/code&gt; (or &lt;code&gt;ember serve&lt;/code&gt;, or even &lt;code&gt;ember s&lt;/code&gt; for short) on your command line to start the Ember development server and then go to &lt;a href=&quot;http://localhost:4200/about&quot;&gt;&lt;code&gt;http://localhost:4200/about&lt;/code&gt;&lt;/a&gt; to see our new page in action!</source>
          <target state="translated">现在，在命令行上运行 &lt;code&gt;ember server&lt;/code&gt; （或 &lt;code&gt;ember serve&lt;/code&gt; ，或者甚至简称 &lt;code&gt;ember s&lt;/code&gt; ）以启动Ember开发服务器，然后转到&lt;a href=&quot;http://localhost:4200/about&quot;&gt; &lt;code&gt;http://localhost:4200/about&lt;/code&gt; &lt;/a&gt;来查看我们的新页面！</target>
        </trans-unit>
        <trans-unit id="84b050c16846a3214fdf9d603f7c5b69acbc94b6" translate="yes" xml:space="preserve">
          <source>Now run the tests by typing &lt;code&gt;ember test --server&lt;/code&gt; in the command line (or &lt;code&gt;ember t -s&lt;/code&gt; for short).</source>
          <target state="translated">现在，通过在命令行中键入 &lt;code&gt;ember test --server&lt;/code&gt; （或简称 &lt;code&gt;ember t -s&lt;/code&gt; ）来运行测试。</target>
        </trans-unit>
        <trans-unit id="34b197a6f48a8ab8f16c6e0063a35905a4b87cee" translate="yes" xml:space="preserve">
          <source>Now run your test suite with the CLI command, &lt;code&gt;ember test --server&lt;/code&gt;.</source>
          <target state="translated">现在，使用CLI命令 &lt;code&gt;ember test --server&lt;/code&gt; 运行测试套件。</target>
        </trans-unit>
        <trans-unit id="787a23779b90cc388529dd5a1d0792e8596631dc" translate="yes" xml:space="preserve">
          <source>Now that data can be used in the &lt;code&gt;favorite-posts&lt;/code&gt; template:</source>
          <target state="translated">现在，可以在&amp;ldquo; &lt;code&gt;favorite-posts&lt;/code&gt; 模板中使用数据了：</target>
        </trans-unit>
        <trans-unit id="e32163bdf7a676f31ff681bf9c67e518f8ae20d2" translate="yes" xml:space="preserve">
          <source>Now that our API is ready to return individual rentals, we can generate our &lt;code&gt;show&lt;/code&gt; sub-route. Much like generating our &lt;code&gt;rentals&lt;/code&gt; route, we will use &lt;code&gt;ember g&lt;/code&gt; to create a nested route.</source>
          <target state="translated">现在我们的API已准备好退还个别租金，我们可以生成 &lt;code&gt;show&lt;/code&gt; 子路线了。就像生成我们的 &lt;code&gt;rentals&lt;/code&gt; 路线一样，我们将使用 &lt;code&gt;ember g&lt;/code&gt; 创建嵌套路线。</target>
        </trans-unit>
        <trans-unit id="390b956f83716b5d2b619a143ece53c88d58057b" translate="yes" xml:space="preserve">
          <source>Now that we are able to generate a map element, we will implement a maps service that will keep a reference to the Map object we create, and attach the map to an element in our application</source>
          <target state="translated">现在我们已经能够生成一个地图元素,我们将实现一个地图服务,该服务将保留对我们创建的地图对象的引用,并将地图附加到应用程序中的一个元素上。</target>
        </trans-unit>
        <trans-unit id="e29152200d11c3493e21bf49ce8fe2f07316838b" translate="yes" xml:space="preserve">
          <source>Now that we are returning all of our rentals to the nested route's model, we will also move the rental list markup from our main route template to our nested route index template.</source>
          <target state="translated">现在,我们将所有的租赁返回到嵌套路由的模型中,我们还将把主路由模板中的租赁列表标记移到嵌套路由索引模板中。</target>
        </trans-unit>
        <trans-unit id="74ca8a47289101b4d71bc8a893d38054ad494e17" translate="yes" xml:space="preserve">
          <source>Now that we can load pages for individual rentals, we'll add a link (using the &lt;code&gt;link-to&lt;/code&gt; helper) within our &lt;code&gt;rental-listing&lt;/code&gt; component to navigate to individual pages. Here, the &lt;code&gt;link-to&lt;/code&gt; helper takes the route name and the rental model object as arguments. When you pass an object as second argument into the &lt;code&gt;link-to&lt;/code&gt; block helper, it will by default &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_serialize&quot;&gt;serialize&lt;/a&gt; the object to the ID of the model into the URL. Alternately, you may just pass &lt;code&gt;rental.id&lt;/code&gt; for clarity.</source>
          <target state="translated">现在我们可以加载单个租赁的页面，我们将在 &lt;code&gt;rental-listing&lt;/code&gt; 组件内添加一个链接（使用 &lt;code&gt;link-to&lt;/code&gt; 帮助器）以导航到单个页面。在此， &lt;code&gt;link-to&lt;/code&gt; 帮助程序将路径名称和租赁模型对象作为参数。当您将对象作为第二个参数传递到 &lt;code&gt;link-to&lt;/code&gt; 块帮助器时，默认情况下，它将对象&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_serialize&quot;&gt;序列化为&lt;/a&gt; URL的模型ID。另外，为清晰起见，您也可以传递 &lt;code&gt;rental.id&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7449048b4c1f507cba589b5896f56bc6e59ebf2b" translate="yes" xml:space="preserve">
          <source>Now that we have a button, we need to wire it up to do &lt;em&gt;something&lt;/em&gt; when a user clicks on it. For simplicity, let's say we want to show an &lt;code&gt;alert&lt;/code&gt; dialog with the person's name when the button is clicked.</source>
          <target state="translated">现在我们有了一个按钮，我们需要将其连接起来以在用户单击它时执行&lt;em&gt;某些&lt;/em&gt;操作。为简单起见，假设我们要在单击按钮时显示一个带有该人姓名的 &lt;code&gt;alert&lt;/code&gt; 对话框。</target>
        </trans-unit>
        <trans-unit id="4255feacf5239fbecd768d0253861a9694b0f109" translate="yes" xml:space="preserve">
          <source>Now that we have implemented the desired behavior, we can go back to the component's template and wire everything up:</source>
          <target state="translated">现在我们已经实现了所需的行为,我们可以回到组件的模板中,将所有的东西连接起来。</target>
        </trans-unit>
        <trans-unit id="f51bc732dd5d0541e4168611797a812b626f2f08" translate="yes" xml:space="preserve">
          <source>Now that we have the maps API available to the application, we can create our map utility. Utility files can be generated using Ember CLI.</source>
          <target state="translated">现在我们已经将地图API提供给应用程序,我们可以创建我们的地图实用程序。实用程序文件可以使用Ember CLI生成。</target>
        </trans-unit>
        <trans-unit id="a4e52876f40ef26dc44f65cd5da56d10b2128afb" translate="yes" xml:space="preserve">
          <source>Now that we have various pages in our application, let's walk through how to build tests for them.</source>
          <target state="translated">现在,我们的应用程序中已经有了各种页面,让我们来看看如何为它们构建测试。</target>
        </trans-unit>
        <trans-unit id="a9325da4991f12e5819676980260f75961e78b11" translate="yes" xml:space="preserve">
          <source>Now that we see &lt;em&gt;why&lt;/em&gt; we want to use a modifier for our audio component, let's walk through &lt;em&gt;how&lt;/em&gt; to create one. We will start with the component (to manage the state) and then implement the modifier (the manage the DOM).</source>
          <target state="translated">现在我们知道了&lt;em&gt;为什么&lt;/em&gt;要对音频组件使用修饰符，让我们逐步&lt;em&gt;介绍如何&lt;/em&gt;创建一个修饰符。我们将从组件（管理状态）开始，然后实现修饰符（管理DOM）。</target>
        </trans-unit>
        <trans-unit id="6188cec92e3b92a3cd3573bff0b61954c555c273" translate="yes" xml:space="preserve">
          <source>Now that we've created a new component for filtering a list, we want to create a test to verify it. Let's use a &lt;a href=&quot;https://guides.emberjs.com/testing/testing-components&quot;&gt;component integration test&lt;/a&gt; to verify our component behavior, similar to &lt;a href=&quot;../simple-component#toc_an-integration-test&quot;&gt;how we tested our rental listing component earlier&lt;/a&gt;.</source>
          <target state="translated">现在，我们已经创建了一个用于过滤列表的新组件，我们想创建一个测试来验证它。让我们使用&lt;a href=&quot;https://guides.emberjs.com/testing/testing-components&quot;&gt;组件集成测试&lt;/a&gt;来验证我们的组件行为，类似于&lt;a href=&quot;../simple-component#toc_an-integration-test&quot;&gt;我们之前测试出租列表组件的方式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f98c7ad85c92ecc814c29c3767c5a61cece2013" translate="yes" xml:space="preserve">
          <source>Now that we've created this modifier, we can use it in our &lt;code&gt;modal&lt;/code&gt; component, and add some logic to invoke a passed-in action whenever the user clicks outside the modal.</source>
          <target state="translated">现在，我们已经创建了该修饰符，可以在 &lt;code&gt;modal&lt;/code&gt; 组件中使用它，并添加一些逻辑以在用户在模态外部单击时调用传递的动作。</target>
        </trans-unit>
        <trans-unit id="22d276eb5319d347792a8180152b4cf12d2f8003" translate="yes" xml:space="preserve">
          <source>Now that we've got the &lt;code&gt;scientists&lt;/code&gt; template rendering, let's give it some data to render. We do that by specifying a &lt;em&gt;model&lt;/em&gt; for that route, and we can specify a model by editing &lt;code&gt;app/routes/scientists.js&lt;/code&gt;.</source>
          <target state="translated">现在我们已经完成了 &lt;code&gt;scientists&lt;/code&gt; 模板渲染，让我们为它提供一些数据进行渲染。我们通过为该路由指定&lt;em&gt;模型&lt;/em&gt;来做到这一点，并且可以通过编辑 &lt;code&gt;app/routes/scientists.js&lt;/code&gt; 来指定模型。</target>
        </trans-unit>
        <trans-unit id="409a5bf3323ebbf783bca40b618202511ed25e9c" translate="yes" xml:space="preserve">
          <source>Now that we've tested that the &lt;code&gt;list-filter&lt;/code&gt; component behaves as expected, let's test that the page itself also behaves properly with an acceptance test. We'll verify that a user visiting the rentals page can enter text into the search field and narrow the list of rentals by city.</source>
          <target state="translated">现在，我们已经测试了 &lt;code&gt;list-filter&lt;/code&gt; 组件的行为是否符合预期，让我们通过接受测试来测试页面本身是否也表现正常。我们将验证访问租赁页面的用户是否可以在搜索字段中输入文字，并按城市缩小租赁列表。</target>
        </trans-unit>
        <trans-unit id="e9f934b876c6d18b3147c025ed6401410b05147e" translate="yes" xml:space="preserve">
          <source>Now that we've written our application and verified that it works in development, it's time to get it ready to deploy to our users.</source>
          <target state="translated">现在,我们已经写好了我们的应用程序,并在开发中验证了它的工作,是时候让它准备好部署给我们的用户了。</target>
        </trans-unit>
        <trans-unit id="9242ac3aa654e84ff49bf7dcc4f82def076c3580" translate="yes" xml:space="preserve">
          <source>Now that you have the basics down, are you feeling creative and adventurous? The Ember community has created hundreds of addons that you can use for free in your app. Addons let you quickly add features like calendars, navbars, payments, authentication, themes, and more. Visit &lt;a href=&quot;https://emberobserver.com&quot;&gt;Ember Observer&lt;/a&gt; to browse the possibilities!</source>
          <target state="translated">现在您已经掌握了基础知识，您是否有创造力和冒险精神？Ember社区已经创建了数百个可在您的应用程序中免费使用的插件。附加组件使您可以快速添加日历，导航栏，付款，身份验证，主题等功能。访问&lt;a href=&quot;https://emberobserver.com&quot;&gt;Ember Observer&lt;/a&gt;，浏览各种可能性！</target>
        </trans-unit>
        <trans-unit id="42a2fba2bd604ccca37641fca53a4a2fc6b8507c" translate="yes" xml:space="preserve">
          <source>Now that your app is deployed, what should you do next?</source>
          <target state="translated">现在你的应用已经部署好了,下一步应该怎么做?</target>
        </trans-unit>
        <trans-unit id="84e818bed748241b2d7235584a3e41d2b94d2146" translate="yes" xml:space="preserve">
          <source>Now the Text component doesn't have any internal state, it defers to the parent Form component, and when the Form component toggles its disabled state, it clears the state of the text. The mutation of state is centralized in the action where it occurs, making our program easier to reason about as a whole.</source>
          <target state="translated">现在Text组件没有任何内部状态,它服从于父Form组件,当Form组件切换其禁用状态时,它就会清除文本的状态。状态的突变集中在动作发生的地方,使得我们的程序整体上更容易推理。</target>
        </trans-unit>
        <trans-unit id="fb98077b823bffbec7d94fef2fd368d976bda3cd" translate="yes" xml:space="preserve">
          <source>Now the same template above renders the following HTML:</source>
          <target state="translated">现在,上面同样的模板渲染出以下HTML。</target>
        </trans-unit>
        <trans-unit id="751cdc42f9ac3dfa5f8f1d9e4ef15bfaddd5edf2" translate="yes" xml:space="preserve">
          <source>Now the value passed into the helper has its HTML escaped, but the trusted &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; tags that we want to wrap the value in are &lt;em&gt;not&lt;/em&gt; escaped. A malicious user setting their &lt;code&gt;firstName&lt;/code&gt; to something containing HTML would see this:</source>
          <target state="translated">现在，传递给帮助器的值已经转义了HTML，但是我们要包装值的受信任的 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 标记&lt;em&gt;未&lt;/em&gt;转义。将其 &lt;code&gt;firstName&lt;/code&gt; 设置为包含HTML 的内容的恶意用户将看到以下内容：</target>
        </trans-unit>
        <trans-unit id="8b6b5009f8b7a2901d3d319dd17092db9a1ed606" translate="yes" xml:space="preserve">
          <source>Now visiting the root route at &lt;code&gt;/&lt;/code&gt; will result in the &lt;code&gt;/rentals&lt;/code&gt; URL loading.</source>
          <target state="translated">现在访问 &lt;code&gt;/&lt;/code&gt; 处的根路由将导致 &lt;code&gt;/rentals&lt;/code&gt; URL加载。</target>
        </trans-unit>
        <trans-unit id="6c6c7e593ed0c850f3e8190fef9191b81f3e28da" translate="yes" xml:space="preserve">
          <source>Now we are listing rentals, and verifying it with an acceptance test. This leaves us with 2 remaining acceptance test failures (and 1 eslint failure):</source>
          <target state="translated">现在,我们正在列出租金,并通过验收测试进行验证。这样我们就剩下2次验收测试失败(和1次eslint失败)。</target>
        </trans-unit>
        <trans-unit id="7108a8b8c763bba0f7398042020329fed4eaf6cc" translate="yes" xml:space="preserve">
          <source>Now we can add functionality that will show the image of a rental when requested by the user.</source>
          <target state="translated">现在,我们可以添加功能,当用户请求时,将显示租赁的图像。</target>
        </trans-unit>
        <trans-unit id="0eb5f04b662c492a3092ec0f4d3de3f94910b7d1" translate="yes" xml:space="preserve">
          <source>Now we can either set the &lt;code&gt;belongsTo&lt;/code&gt; relationship in our new comment, or, update the blogPost's &lt;code&gt;hasMany&lt;/code&gt; relationship. As you might observe, we don't need to set both &lt;code&gt;hasMany&lt;/code&gt; and &lt;code&gt;belongsTo&lt;/code&gt; for a record. Ember Data will do that for us.</source>
          <target state="translated">现在，我们可以在新注释中设置 &lt;code&gt;belongsTo&lt;/code&gt; 关系，或者更新blogPost的 &lt;code&gt;hasMany&lt;/code&gt; 关系。您可能会看到，我们不需要同时设置 &lt;code&gt;hasMany&lt;/code&gt; 和 &lt;code&gt;belongsTo&lt;/code&gt; 来进行记录。灰烬数据将为我们做到这一点。</target>
        </trans-unit>
        <trans-unit id="fe4c933206df8d089a9a5f5490e91df59c0228d5" translate="yes" xml:space="preserve">
          <source>Now we can move on to a more complex test case that ensures our helper is rendered correctly as well. This can be done with the &lt;code&gt;setupRenderingTest&lt;/code&gt; helper, as shown in &lt;a href=&quot;../testing-components&quot;&gt;Testing Components&lt;/a&gt;.</source>
          <target state="translated">现在，我们可以进入一个更复杂的测试用例，以确保我们的助手也正确呈现。可以使用 &lt;code&gt;setupRenderingTest&lt;/code&gt; 帮助器完成此操作，如&amp;ldquo;&lt;a href=&quot;../testing-components&quot;&gt;测试组件&amp;rdquo;中&lt;/a&gt;所示。</target>
        </trans-unit>
        <trans-unit id="bfa9210fe58ffde8b4dcc9ff4b51a5ca9f882a82" translate="yes" xml:space="preserve">
          <source>Now we can move on to an integration test. Integration testing helpers is done with the &lt;code&gt;moduleForComponent&lt;/code&gt; helpers, as shown in &lt;a href=&quot;../unit-testing-basics&quot;&gt;Testing Components&lt;/a&gt;.</source>
          <target state="translated">现在，我们可以继续进行集成测试。集成测试帮助程序由 &lt;code&gt;moduleForComponent&lt;/code&gt; 帮助程序完成，如&amp;ldquo; &lt;a href=&quot;../unit-testing-basics&quot;&gt;测试组件&amp;rdquo;中&lt;/a&gt;所示。</target>
        </trans-unit>
        <trans-unit id="d378360c77a1435b23b3e8fbbda88e19e03f54b9" translate="yes" xml:space="preserve">
          <source>Now we can open and close the modal dialog at will! Next, we'll setup the component to send its &lt;em&gt;own&lt;/em&gt; events when the user clicks the &quot;OK&quot; and &quot;Cancel&quot; buttons.</source>
          <target state="translated">现在，我们可以随意打开和关闭模式对话框！接下来，我们将设置组件以在用户单击&amp;ldquo;确定&amp;rdquo;和&amp;ldquo;取消&amp;rdquo;按钮时发送其&lt;em&gt;自己的&lt;/em&gt;事件。</target>
        </trans-unit>
        <trans-unit id="11398bb83489e7573750eb0b3ecfd3dc7203a6e0" translate="yes" xml:space="preserve">
          <source>Now we can use our custom &lt;code&gt;{{autofocus}}&lt;/code&gt; modifier throughout our application.</source>
          <target state="translated">现在，我们可以在整个应用程序中使用自定义的 &lt;code&gt;{{autofocus}}&lt;/code&gt; 修饰符。</target>
        </trans-unit>
        <trans-unit id="6fdad371bc9df138ad834391faad276517ce8b68" translate="yes" xml:space="preserve">
          <source>Now we have a button that can receive some text as an argument, with a modal confirmation that will show conditionally based on its &lt;code&gt;isConfirming&lt;/code&gt; property. You'll notice this property is decorated with the &lt;code&gt;@tracked&lt;/code&gt; decorator - this is known as a &lt;em&gt;tracked property&lt;/em&gt;, and indicates to Ember that the field will change in value over the lifetime of the component. You can learn more about tracked properties in the &lt;a href=&quot;../autotracking-in-depth&quot;&gt;Autotracking In-Depth&lt;/a&gt; guide.</source>
          <target state="translated">现在，我们有了一个可以接收一些文本作为参数的按钮，并带有模式确认，该模式确认将基于其 &lt;code&gt;isConfirming&lt;/code&gt; 属性有条件地显示。您会注意到此属性是用 &lt;code&gt;@tracked&lt;/code&gt; 装饰器修饰的-称为&lt;em&gt;tracked属性&lt;/em&gt;，它向Ember指示该字段的值将在组件的生存期内发生变化。您可以在《&lt;a href=&quot;../autotracking-in-depth&quot;&gt;自动&lt;/a&gt;跟踪深度》指南中了解有关跟踪属性的更多信息。</target>
        </trans-unit>
        <trans-unit id="4adfea733a9bf47405887104fee15db7d39c58a6" translate="yes" xml:space="preserve">
          <source>Now we need to define a computed property of our category-filtered array that the &lt;code&gt;articles&lt;/code&gt; template will render:</source>
          <target state="translated">现在，我们需要为 &lt;code&gt;articles&lt;/code&gt; 模板定义的类别过滤数组定义一个计算属性：</target>
        </trans-unit>
        <trans-unit id="0a9ade858770208815604908e8c6a68cfd6d052d" translate="yes" xml:space="preserve">
          <source>Now we need to define a getter for our category-filtered array, which the &lt;code&gt;articles&lt;/code&gt; template will render. For the getter to recompute when values change, &lt;code&gt;category&lt;/code&gt; and &lt;code&gt;model&lt;/code&gt; should be marked as tracked properties:</source>
          <target state="translated">现在，我们需要定义我们的类别过滤的阵列，其中一个getter &lt;code&gt;articles&lt;/code&gt; 模板将呈现。为了使getter在值更改时重新计算，应该将 &lt;code&gt;category&lt;/code&gt; 和 &lt;code&gt;model&lt;/code&gt; 标记为跟踪属性：</target>
        </trans-unit>
        <trans-unit id="54e5a7d11514449fe0aca845de95725d318042b5" translate="yes" xml:space="preserve">
          <source>Now we need to make it so that the &lt;code&gt;userDidDeleteAccount()&lt;/code&gt; action defined in the parent component &lt;code&gt;user-profile&lt;/code&gt; can be triggered from within &lt;code&gt;button-with-confirmation&lt;/code&gt;. We'll do this by passing the action to the child component in exactly the same way that we pass other properties. This is possible since actions are simply functions, just like any other method on a component, and they can therefore be passed from one component to another like this:</source>
          <target state="translated">现在我们需 &lt;code&gt;userDidDeleteAccount()&lt;/code&gt; ，以便可以从 &lt;code&gt;button-with-confirmation&lt;/code&gt; 内部触发在父组件 &lt;code&gt;user-profile&lt;/code&gt; 中定义的userDidDeleteAccount（）操作。我们将通过将操作传递给子组件来完成此操作，方法与传递其他属性完全相同。之所以可行是因为动作是简单的功能，就像组件上的任何其他方法一样，因此可以将它们从一个组件传递到另一个组件，如下所示：</target>
        </trans-unit>
        <trans-unit id="638d79b6dc710ae90d1be166135c3fd4850c0c22" translate="yes" xml:space="preserve">
          <source>Now we've implemented our action, but we have not told Ember when we want this action to be triggered, which is the next step.</source>
          <target state="translated">现在我们已经实现了我们的动作,但是我们还没有告诉Ember什么时候要触发这个动作,这是下一步。</target>
        </trans-unit>
        <trans-unit id="eb138d4ac2039ca6f91d7778d49a1e0c080f7905" translate="yes" xml:space="preserve">
          <source>Now we've implemented our action, but we have not told Ember when we want this action to be triggered. In order to trigger the action when the user clicks &quot;OK&quot; in the &lt;code&gt;ButtonWithConfirmation&lt;/code&gt; component, we'll need to pass the action &lt;em&gt;down&lt;/em&gt; to it as an argument:</source>
          <target state="translated">现在，我们已经执行了动作，但是当我们希望触发该动作时，我们没有告诉Ember。为了触发操作，当用户点击&amp;ldquo;确定&amp;rdquo;，在 &lt;code&gt;ButtonWithConfirmation&lt;/code&gt; 组件，我们需要通过行动&lt;em&gt;下来&lt;/em&gt;，以它作为参数：</target>
        </trans-unit>
        <trans-unit id="55a49ef66b489e2e182e74e6d1a108e56c676795" translate="yes" xml:space="preserve">
          <source>Now when called like so:</source>
          <target state="translated">现在当这样叫。</target>
        </trans-unit>
        <trans-unit id="9c2fddefdc4b37f652575c4a9980122a108feeff" translate="yes" xml:space="preserve">
          <source>Now when the &lt;code&gt;SystemPreferencesEditor&lt;/code&gt; handles the delete action, it receives only the user's account &lt;code&gt;id&lt;/code&gt; string.</source>
          <target state="translated">现在，当 &lt;code&gt;SystemPreferencesEditor&lt;/code&gt; 处理删除操作时，它仅接收用户的帐户 &lt;code&gt;id&lt;/code&gt; 字符串。</target>
        </trans-unit>
        <trans-unit id="8266b5a5c3d0155af7d2420da1952fd4bf225240" translate="yes" xml:space="preserve">
          <source>Now when the &lt;code&gt;system-preferences-editor&lt;/code&gt; handles the delete action, it receives only the user's account &lt;code&gt;id&lt;/code&gt; string.</source>
          <target state="translated">现在，当 &lt;code&gt;system-preferences-editor&lt;/code&gt; 处理delete操作时，它仅接收用户的帐户 &lt;code&gt;id&lt;/code&gt; 字符串。</target>
        </trans-unit>
        <trans-unit id="24e0f7c85a3653f2f8783ca8850aaea9de98c648" translate="yes" xml:space="preserve">
          <source>Now when we click the image or the &lt;code&gt;View Larger&lt;/code&gt; link in our browser, we see our image show larger. When we click the enlarged image again, we see it smaller.</source>
          <target state="translated">现在，当我们单击图像或在浏览器中 &lt;code&gt;View Larger&lt;/code&gt; 链接时，我们看到的图像显示较大。当我们再次单击放大的图像时，会看到较小的图像。</target>
        </trans-unit>
        <trans-unit id="5d245f0aef23eeedd834fcade7b3ff3025ac6d19" translate="yes" xml:space="preserve">
          <source>Now when we go to &lt;a href=&quot;http://localhost:4200/contact&quot;&gt;&lt;code&gt;http://localhost:4200/contact&lt;/code&gt;&lt;/a&gt;, we'll see our contact page.</source>
          <target state="translated">现在，当我们转到&lt;a href=&quot;http://localhost:4200/contact&quot;&gt; &lt;code&gt;http://localhost:4200/contact&lt;/code&gt; 时&lt;/a&gt;，将看到我们的联系页面。</target>
        </trans-unit>
        <trans-unit id="be877b75fca57439ff66da3a78bca6da09e90e67" translate="yes" xml:space="preserve">
          <source>Now when you confirm deletion, the action goes straight to the &lt;code&gt;SystemPreferencesEditor&lt;/code&gt; to be handled in its local context.</source>
          <target state="translated">现在，当您确认删除时，操作将直接转到 &lt;code&gt;SystemPreferencesEditor&lt;/code&gt; ，以在其本地上下文中进行处理。</target>
        </trans-unit>
        <trans-unit id="ce9483b052b5784076ba5b335a0118e44ab1c9e9" translate="yes" xml:space="preserve">
          <source>Now when you confirm deletion, the action goes straight to the &lt;code&gt;system-preferences-editor&lt;/code&gt; to be handled in its local context.</source>
          <target state="translated">现在，当您确认删除时，操作将直接转到要在其本地上下文中处理的 &lt;code&gt;system-preferences-editor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="473068e00c295cfcafcd8f45ee6f410ef05f53fa" translate="yes" xml:space="preserve">
          <source>Now, almost anywhere in your app, you can use the various jQuery integration.</source>
          <target state="translated">现在,几乎在你的应用程序的任何地方,你可以使用各种jQuery集成。</target>
        </trans-unit>
        <trans-unit id="c492595dd56aaada785857fc9c9edf375ab46697" translate="yes" xml:space="preserve">
          <source>Now, as long as your template is wrapped in the &lt;code&gt;let&lt;/code&gt; helper, you can access the capitalized given name and family name as &lt;code&gt;givenName&lt;/code&gt; and &lt;code&gt;familyName&lt;/code&gt; instead of &lt;code&gt;(capitalize this.person.givenName)&lt;/code&gt;.</source>
          <target state="translated">现在，只要将模板包装在 &lt;code&gt;let&lt;/code&gt; 助手中，就可以访问大写的给定名称和姓氏，如 &lt;code&gt;givenName&lt;/code&gt; 和 &lt;code&gt;familyName&lt;/code&gt; ,而不是 &lt;code&gt;(capitalize this.person.givenName)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61a8b0d0ff011a9764ca1ad939461500c43c3744" translate="yes" xml:space="preserve">
          <source>Now, define your new controller like so:</source>
          <target state="translated">现在,像这样定义你的新控制器。</target>
        </trans-unit>
        <trans-unit id="2bd21344ef8f95330e5f178d2999e6351e5140b4" translate="yes" xml:space="preserve">
          <source>Now, if we use our &lt;code&gt;ErrorDialog&lt;/code&gt; component without a block, we'll get the default message.</source>
          <target state="translated">现在，如果我们使用不带任何块的 &lt;code&gt;ErrorDialog&lt;/code&gt; 组件，则将获得默认消息。</target>
        </trans-unit>
        <trans-unit id="f4fd3bbdfb6ab9a0619b9f651b994843f728f190" translate="yes" xml:space="preserve">
          <source>Now, let's add a list of available rentals to the rentals page we've just created.</source>
          <target state="translated">现在,让我们在刚刚创建的租房页面中添加一个可用的租房列表。</target>
        </trans-unit>
        <trans-unit id="a53ad0647104e578d8de2040723dfe077ba174b5" translate="yes" xml:space="preserve">
          <source>Now, let's switch over to our rentals page template. We can use the model attribute to display our list of rentals. Here, we'll use another common Handlebars helper called &lt;a href=&quot;https://guides.emberjs.com/templates/displaying-a-list-of-items/&quot;&gt;&lt;code&gt;{{each}}&lt;/code&gt;&lt;/a&gt;. This helper will let us loop through each of the rental objects in our model:</source>
          <target state="translated">现在，让我们切换到租赁页面模板。我们可以使用model属性来显示我们的租金清单。在这里，我们将使用另一个名为&lt;a href=&quot;https://guides.emberjs.com/templates/displaying-a-list-of-items/&quot;&gt; &lt;code&gt;{{each}}&lt;/code&gt; 的&lt;/a&gt;常见Handlebars帮助器。该帮助程序将使我们遍历模型中的每个租赁对象：</target>
        </trans-unit>
        <trans-unit id="1c7b54e01c4ec08044f348cb31fc93794811e59a" translate="yes" xml:space="preserve">
          <source>Now, suppose we want to add comments to an existing blogPost. We can do this in two ways, but for both of them, we first need to look up a blog post that is already loaded in the store, using its id:</source>
          <target state="translated">现在,假设我们想在一个现有的blogPost中添加评论。我们可以通过两种方式来实现,但对于这两种方式,我们首先需要使用它的id来查找一个已经在商店中加载的博客文章。</target>
        </trans-unit>
        <trans-unit id="f5634ffbc151b6f602493d24fb1795397f8549ec" translate="yes" xml:space="preserve">
          <source>Now, the Counter calls the &lt;code&gt;updateMultiple&lt;/code&gt; argument (which we expect to be a function) with the new value for &lt;code&gt;multiple&lt;/code&gt;, and the parent component can update the multiple.</source>
          <target state="translated">现在，Counter调用带有 &lt;code&gt;multiple&lt;/code&gt; 的新值的 &lt;code&gt;updateMultiple&lt;/code&gt; 参数（我们期望它是一个函数），并且父组件可以更新倍数。</target>
        </trans-unit>
        <trans-unit id="15795f7ce89f935cc441a35c4b6d01a3b8f097c4" translate="yes" xml:space="preserve">
          <source>Now, we can use &lt;code&gt;onConfirm&lt;/code&gt; in the child component to invoke the action on the parent:</source>
          <target state="translated">现在，我们可以在子组件中使用 &lt;code&gt;onConfirm&lt;/code&gt; 来调用父组件上的操作：</target>
        </trans-unit>
        <trans-unit id="e8a74da24790015ebe84e057ae755a540ac6ffaa" translate="yes" xml:space="preserve">
          <source>Now, we can use the &lt;code&gt;{{blog-post}}&lt;/code&gt; component and pass it properties in another template:</source>
          <target state="translated">现在，我们可以使用 &lt;code&gt;{{blog-post}}&lt;/code&gt; 组件并将其属性传递到另一个模板中：</target>
        </trans-unit>
        <trans-unit id="fdf62c9f4192c9e36113ca42781fc9263390a9ef" translate="yes" xml:space="preserve">
          <source>Now, we'll add our corresponding link to the contact page so we can move back and forth between &lt;code&gt;about&lt;/code&gt; and &lt;code&gt;contact&lt;/code&gt;:</source>
          <target state="translated">现在，我们将相应的链接添加到联系页面，以便我们可以在 &lt;code&gt;about&lt;/code&gt; 和 &lt;code&gt;contact&lt;/code&gt; 之间来回移动：</target>
        </trans-unit>
        <trans-unit id="a879d50bf8c09faae5535f3cab8516120420f26f" translate="yes" xml:space="preserve">
          <source>Now, when the &lt;code&gt;+1&lt;/code&gt; and &lt;code&gt;-1&lt;/code&gt; buttons get clicked, the number displayed will change.</source>
          <target state="translated">现在，当单击 &lt;code&gt;+1&lt;/code&gt; 和 &lt;code&gt;-1&lt;/code&gt; 按钮时，显示的数字将更改。</target>
        </trans-unit>
        <trans-unit id="6b6222fa9f13976ca7ad6beffaa5b6d82e8a9acf" translate="yes" xml:space="preserve">
          <source>Now, when the user visits &lt;code&gt;/about&lt;/code&gt;, Ember will render the &lt;code&gt;about&lt;/code&gt; template. Visiting &lt;code&gt;/favs&lt;/code&gt; will render the &lt;code&gt;favorites&lt;/code&gt; template.</source>
          <target state="translated">现在，当用户访问 &lt;code&gt;/about&lt;/code&gt; ，灰烬将使 &lt;code&gt;about&lt;/code&gt; 模板。访问 &lt;code&gt;/favs&lt;/code&gt; 将呈现 &lt;code&gt;favorites&lt;/code&gt; 模板。</target>
        </trans-unit>
        <trans-unit id="894378d414e7ebe678c18c3f781dba0645530766" translate="yes" xml:space="preserve">
          <source>Now, when we click on the confirm button, the &lt;code&gt;submitConfirm&lt;/code&gt; action will also call the &lt;code&gt;deleteAccount&lt;/code&gt; action, which was passed down as an argument to the confirmation button component. In this way, the &lt;code&gt;@onConfirm&lt;/code&gt; argument is like an event which our &lt;code&gt;ButtonWithConfirmation&lt;/code&gt; component triggers.</source>
          <target state="translated">现在，当我们单击确认按钮时， &lt;code&gt;submitConfirm&lt;/code&gt; 操作还将调用 &lt;code&gt;deleteAccount&lt;/code&gt; 操作，该操作作为参数传递给了确认按钮组件。这样， &lt;code&gt;@onConfirm&lt;/code&gt; 参数就像我们的 &lt;code&gt;ButtonWithConfirmation&lt;/code&gt; 组件触发的事件。</target>
        </trans-unit>
        <trans-unit id="714db7ba4265493aac8451d6fdd39218363b66cb" translate="yes" xml:space="preserve">
          <source>Now, whenever we change the value of the &lt;code&gt;select&lt;/code&gt;, it'll call the action method, which will set the value of &lt;code&gt;language&lt;/code&gt;. Since &lt;code&gt;language&lt;/code&gt; is marked as tracked, and was used in rendering &lt;code&gt;greeting&lt;/code&gt;, Ember will know that &lt;code&gt;greeting&lt;/code&gt; needs to be re-rendered in the template, and will update.</source>
          <target state="translated">现在，无论何时更改 &lt;code&gt;select&lt;/code&gt; 的值，它都会调用action方法，该方法将设置 &lt;code&gt;language&lt;/code&gt; 的值。由于 &lt;code&gt;language&lt;/code&gt; 被标记为已跟踪，并且已用于呈现 &lt;code&gt;greeting&lt;/code&gt; ，因此Ember将知道需要在模板中重新呈现 &lt;code&gt;greeting&lt;/code&gt; 并进行更新。</target>
        </trans-unit>
        <trans-unit id="e024f13e16917f40a23bcb1554e9bce6943df6d7" translate="yes" xml:space="preserve">
          <source>Now, whenever we type a value and submit it in the form, a new message object will be added to the array, and the &lt;code&gt;{{each}}&lt;/code&gt; will update with the new item.</source>
          <target state="translated">现在，无论何时我们键入一个值并将其提交到表单中，都会将一个新的消息对象添加到数组中，并且 &lt;code&gt;{{each}}&lt;/code&gt; 将使用新项进行更新。</target>
        </trans-unit>
        <trans-unit id="a5cd41af69260a04d94db9c599bc1850243572fb" translate="yes" xml:space="preserve">
          <source>Now, you have a choice to make, and the right answer varies based on how your team operates and what your app is like. Consider which path has the least mental overhead for your engineering team, including both experienced and beginner Ember developers.</source>
          <target state="translated">现在,你要做一个选择,正确的答案根据你的团队的运作方式和你的应用是怎样的而有所不同。考虑哪种路径对你的工程团队来说精神开销最小,包括有经验的和初学者的Ember开发者。</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="88edc4776d403507658bee878ccdd72f1066d6fc" translate="yes" xml:space="preserve">
          <source>Number of elements that should be removed from the array, starting at *idx*.</source>
          <target state="translated">从*idx*开始,应该从数组中删除的元素数量。</target>
        </trans-unit>
        <trans-unit id="0da649b10044d0f71d7a6905e9b6d63659072ba9" translate="yes" xml:space="preserve">
          <source>Number of milliseconds to space out requests.</source>
          <target state="translated">请求间隔的毫秒数。</target>
        </trans-unit>
        <trans-unit id="76f886e5f43af44774fe994d2bf9d8f584ccf233" translate="yes" xml:space="preserve">
          <source>Number of milliseconds to wait.</source>
          <target state="translated">等待的毫秒数。</target>
        </trans-unit>
        <trans-unit id="dd4ba91b29d32edc1f365c3bd6735151219f7f8b" translate="yes" xml:space="preserve">
          <source>NumberTransform</source>
          <target state="translated">NumberTransform</target>
        </trans-unit>
        <trans-unit id="c96f8cfa04b2401642b632ab99c696e7b056b4c9" translate="yes" xml:space="preserve">
          <source>Number|Property</source>
          <target state="translated">Number|Property</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="046bbc130ff7274f6d64607d913605fb2889bf35" translate="yes" xml:space="preserve">
          <source>Object Inspector</source>
          <target state="translated">对象检查员</target>
        </trans-unit>
        <trans-unit id="e1513401bdad97eeec26a0df3ad83cdcfa1ea677" translate="yes" xml:space="preserve">
          <source>Object Root</source>
          <target state="translated">对象根</target>
        </trans-unit>
        <trans-unit id="a7b77dbe50791d31096e5af54a26e5c31a19b936" translate="yes" xml:space="preserve">
          <source>Object containing values to use within the new class</source>
          <target state="translated">包含在新类中使用的值的对象</target>
        </trans-unit>
        <trans-unit id="f1d7548ccd9210fe9f2413508f315d38d0d8c629" translate="yes" xml:space="preserve">
          <source>Object that will be set as the model of the engine.</source>
          <target state="translated">将被设置为引擎模型的对象。</target>
        </trans-unit>
        <trans-unit id="d2fff7b4d950616ac3bef1a515c9329ec963f60e" translate="yes" xml:space="preserve">
          <source>Object | AdapterError</source>
          <target state="translated">适配器错误</target>
        </trans-unit>
        <trans-unit id="6b304869b69598961a9d35b37c6fa6c60971f424" translate="yes" xml:space="preserve">
          <source>Object | DS.AdapterError</source>
          <target state="translated">对象--DS.AdapterError</target>
        </trans-unit>
        <trans-unit id="b4784d7acbd2702fa6271cd5462cc264f381f5af" translate="yes" xml:space="preserve">
          <source>Object | undefined</source>
          <target state="translated">对象|未定义</target>
        </trans-unit>
        <trans-unit id="43710f2ae099d35ce837e6f0eaa732de92f07067" translate="yes" xml:space="preserve">
          <source>Object...</source>
          <target state="translated">Object...</target>
        </trans-unit>
        <trans-unit id="509eaa966f59106fc4885b0bd87f377320887ef2" translate="yes" xml:space="preserve">
          <source>ObjectProxy</source>
          <target state="translated">ObjectProxy</target>
        </trans-unit>
        <trans-unit id="b6ab519ee4828e64cb84e7da4b0494d126262ccd" translate="yes" xml:space="preserve">
          <source>Objects are considered Array-like if any of the following are true:</source>
          <target state="translated">如果以下任何一项为真,对象被认为是类阵列。</target>
        </trans-unit>
        <trans-unit id="1f91056b2f2c5a87fefcf8263cdce9940569716e" translate="yes" xml:space="preserve">
          <source>Objects in Ember</source>
          <target state="translated">微光中的物体</target>
        </trans-unit>
        <trans-unit id="ea0a98c632b2c1b78a2d3889fe6a012055812ca8" translate="yes" xml:space="preserve">
          <source>Object|Function</source>
          <target state="translated">Object|Function</target>
        </trans-unit>
        <trans-unit id="d9008046621fd4aa468204fcfd6ca159f07a8852" translate="yes" xml:space="preserve">
          <source>Object|Promise</source>
          <target state="translated">Object|Promise</target>
        </trans-unit>
        <trans-unit id="c231f0cfa191393d14a834365263558785e900ee" translate="yes" xml:space="preserve">
          <source>Object|String</source>
          <target state="translated">Object|String</target>
        </trans-unit>
        <trans-unit id="c92258fa87a7fd87bfb0eac39b2cad3876c1531d" translate="yes" xml:space="preserve">
          <source>Observable</source>
          <target state="translated">Observable</target>
        </trans-unit>
        <trans-unit id="307932fe3fc8a6a623482336122238a18d63c345" translate="yes" xml:space="preserve">
          <source>Observable Equivalent</source>
          <target state="translated">观测当量</target>
        </trans-unit>
        <trans-unit id="03ec7d08aec77b2156c9347f0082c5eed203b4e0" translate="yes" xml:space="preserve">
          <source>Observer Methods</source>
          <target state="translated">观察员方法</target>
        </trans-unit>
        <trans-unit id="20c17cb09007fd332a06112b65f303ed65335037" translate="yes" xml:space="preserve">
          <source>Observer methods have the following signature:</source>
          <target state="translated">观察员方法具有以下特征:</target>
        </trans-unit>
        <trans-unit id="0618a214d16e39be75c6315a11d086a7dcbea1b6" translate="yes" xml:space="preserve">
          <source>Observers</source>
          <target state="translated">Observers</target>
        </trans-unit>
        <trans-unit id="853a6ea1725e790242a53c8b71d88a3606114195" translate="yes" xml:space="preserve">
          <source>Observers / Binding</source>
          <target state="translated">观察员/装订</target>
        </trans-unit>
        <trans-unit id="0ba30584277e971c04f0d982aa5c093fa641ac6a" translate="yes" xml:space="preserve">
          <source>Observers and asynchrony</source>
          <target state="translated">观察员和异步</target>
        </trans-unit>
        <trans-unit id="dd121fa26be2df8672e845b1537510d9b314c5cd" translate="yes" xml:space="preserve">
          <source>Observers and object initialization</source>
          <target state="translated">观察员和对象初始化</target>
        </trans-unit>
        <trans-unit id="e736f6b09fdaa953337c6d536a1450f9f94c9a91" translate="yes" xml:space="preserve">
          <source>Observers are annotated using &lt;code&gt;Ember.observer()&lt;/code&gt;:</source>
          <target state="translated">观察者使用 &lt;code&gt;Ember.observer()&lt;/code&gt; 进行注释：</target>
        </trans-unit>
        <trans-unit id="3077946aa34d8ec8d2b52fd810a985c5b86ca007" translate="yes" xml:space="preserve">
          <source>Observers in Ember are currently synchronous. This means that they will fire as soon as one of the properties they observe changes. Because of this, it is easy to introduce bugs where properties are not yet synchronized:</source>
          <target state="translated">Ember中的观测器目前是同步的。这意味着,一旦他们观察到的一个属性发生变化,他们就会立即启动。正因为如此,在属性尚未同步的情况下,很容易引入错误。</target>
        </trans-unit>
        <trans-unit id="0dcd8db6908df157727f62893615213904a58453" translate="yes" xml:space="preserve">
          <source>Observers never fire until after the initialization of an object is complete.</source>
          <target state="translated">观察者直到对象的初始化完成后才会开火。</target>
        </trans-unit>
        <trans-unit id="f5999f9bc2923f92d05e5b16aa536ea236796646" translate="yes" xml:space="preserve">
          <source>Observers should contain behavior that reacts to changes in another property. Observers are especially useful when you need to perform some behavior after a binding has finished synchronizing.</source>
          <target state="translated">观察者应该包含对另一个属性的变化做出反应的行为。当你需要在绑定完成同步后执行一些行为时,观察者特别有用。</target>
        </trans-unit>
        <trans-unit id="e3b3d585c4b8fcab8db62fcf152d3716f7e04235" translate="yes" xml:space="preserve">
          <source>Observes all relevant properties and re-sends the wrapped record when a change occurs.</source>
          <target state="translated">观察所有相关属性,并在发生变化时重新发送包裹记录。</target>
        </trans-unit>
        <trans-unit id="2e48525b5f6912ad099b4ea5d21fef8fb5a4b87c" translate="yes" xml:space="preserve">
          <source>Observing Property Changes</source>
          <target state="translated">观察属性变化</target>
        </trans-unit>
        <trans-unit id="49abd5a03a91a7274230eb2dc93800125ce2b2dc" translate="yes" xml:space="preserve">
          <source>Occasionally you may want to prevent the app from initializing during setup. This could enable extra configuration, or enable asserting prior to the app becoming ready.</source>
          <target state="translated">偶尔您可能希望在设置期间阻止应用程序初始化。这可以启用额外的配置,或者在应用程序准备好之前启用断言。</target>
        </trans-unit>
        <trans-unit id="5998747d026b2e17f67c947965996ccf455b6d78" translate="yes" xml:space="preserve">
          <source>Octane provides a set of new conventional APIs for creating and adding event handlers and actions to your components and templates:</source>
          <target state="translated">Octane提供了一套新的常规API,用于创建和添加事件处理程序和动作到你的组件和模板。</target>
        </trans-unit>
        <trans-unit id="767e6f8a96c4ae852ffc759490d9c6e73f237304" translate="yes" xml:space="preserve">
          <source>Octane upgrade strategy</source>
          <target state="translated">辛烷值升级战略</target>
        </trans-unit>
        <trans-unit id="1004ee76d68d2440e2104c1c0f8c10a40b78ea70" translate="yes" xml:space="preserve">
          <source>Octane was a big shift in Ember's syntax, features, and mental models! If you are in the process of upgrading an existing app to use Octane patterns, check out our dedicated &lt;a href=&quot;current-edition&quot;&gt;Octane Update Guide&lt;/a&gt;.</source>
          <target state="translated">Octane在Ember的语法，功能和思维模型方面发生了巨大变化！如果您正在升级现有应用程序以使用Octane模式，请查看我们专用的&lt;a href=&quot;current-edition&quot;&gt;Octane更新指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ff2f4ac5135f40e96e90d7929e9e452ea04a10c" translate="yes" xml:space="preserve">
          <source>Often actions perform asynchronous tasks, such as making an ajax request to a server. Since actions are functions that can be passed in by a parent component, they are able to return values when called. The most common scenario is for an action to return a promise so that the component can handle the action's completion.</source>
          <target state="translated">通常情况下,动作会执行异步任务,比如向服务器发出ajax请求。由于action是可以由父组件传递进来的函数,所以它们在被调用时能够返回值。最常见的情况是让一个动作返回一个承诺,这样组件就可以处理动作的完成。</target>
        </trans-unit>
        <trans-unit id="bc5a51fbbacf924217ea79e869e7741f73181329" translate="yes" xml:space="preserve">
          <source>Often this is unnecessary, but to ensure robust auto-tracking behavior it is advisable to mark tracked state appropriately wherever possible.</source>
          <target state="translated">通常这是不必要的,但为了确保强大的自动跟踪行为,建议尽可能对跟踪状态进行适当的标记。</target>
        </trans-unit>
        <trans-unit id="89cb7859835dee6ef77b5791366871c69a2d100f" translate="yes" xml:space="preserve">
          <source>Often times, your components will just encapsulate certain snippets of Handlebars templates that you find yourself using over and over. In those cases, you do not need to write any JavaScript at all. Define the Handlebars template as described above and use the component that is created.</source>
          <target state="translated">很多时候,你的组件只是封装了某些你发现自己反复使用的Handlebars模板的片段。在这些情况下,你根本不需要编写任何JavaScript。如上所述定义Handlebars模板,并使用创建的组件。</target>
        </trans-unit>
        <trans-unit id="5aaf5caa5b49b93e7119e86a70d536ce6664ca8a" translate="yes" xml:space="preserve">
          <source>Often you'll want to have a template that displays inside another template. For example, in a blogging application, instead of going from a list of blog posts to creating a new post, you might want to have the post creation page display next to the list.</source>
          <target state="translated">通常你会希望有一个模板显示在另一个模板里面。例如,在一个博客应用程序中,你可能想让文章创建页面显示在列表旁边,而不是从博客文章列表转到创建新文章。</target>
        </trans-unit>
        <trans-unit id="62bb97c24abd34d344b7c7e101be577c8280b132" translate="yes" xml:space="preserve">
          <source>Often, interacting with a component will cause asynchronous behavior to occur, such as HTTP requests, or timers. The &lt;code&gt;wait&lt;/code&gt; helper is designed to handle these scenarios, by providing a hook to ensure assertions are made after all Ajax requests and timers are complete.</source>
          <target state="translated">通常，与组件交互将导致发生异步行为，例如HTTP请求或计时器。在 &lt;code&gt;wait&lt;/code&gt; 助手是专门用来处理这些情况下，通过提供一个挂钩，以确保断言是由毕竟Ajax请求和计时器完成。</target>
        </trans-unit>
        <trans-unit id="474dbfb11cc1f0dc8c12a795f79767e73fcd2a35" translate="yes" xml:space="preserve">
          <source>Often, interacting with a component will cause asynchronous behavior to occur, such as HTTP requests, or timers. The module &lt;code&gt;@ember/test-helpers&lt;/code&gt; provides you with several &lt;a href=&quot;https://github.com/emberjs/ember-test-helpers/blob/master/API.md&quot;&gt;useful helpers&lt;/a&gt; that will allow you to wait for any asynchronous behavior to complete that is triggered by a DOM interaction induced by those. To use them in your tests, you can &lt;code&gt;await&lt;/code&gt; any of them to make sure that subsequent assertions are executed once the asynchronous behavior has fully settled:</source>
          <target state="translated">通常，与组件交互将导致发生异步行为，例如HTTP请求或计时器。 &lt;code&gt;@ember/test-helpers&lt;/code&gt; 模块为您提供了几个&lt;a href=&quot;https://github.com/emberjs/ember-test-helpers/blob/master/API.md&quot;&gt;有用的帮助器&lt;/a&gt;，这些帮助器将使您等待由异步交互行为引起的任何异步行为完成。要在测试中使用它们，您可以 &lt;code&gt;await&lt;/code&gt; 它们中的任何一个，以确保异步行为完全解决后，将执行后续的断言：</target>
        </trans-unit>
        <trans-unit id="50ea8ddf844ede9c0ec44349c06ad04be2998925" translate="yes" xml:space="preserve">
          <source>Often, services connect to third party APIs that are not desirable to include in automated tests. To stub these services we simply have to register a stub service that implements the same API, but does not have the dependencies that are problematic for the test suite.</source>
          <target state="translated">通常情况下,服务会连接到第三方API,而这些API并不适合包含在自动化测试中。要对这些服务进行存根,我们只需要注册一个实现相同API的存根服务,但不存在对测试套件有问题的依赖关系。</target>
        </trans-unit>
        <trans-unit id="0ce500ec9eb2726f6b12a95aabe734c404cd89eb" translate="yes" xml:space="preserve">
          <source>Often, the relationships in Ember Data applications will have an inverse. For example, imagine the following models are defined:</source>
          <target state="translated">通常情况下,Ember Data应用中的关系会有一个反向关系。例如,想象定义了以下模型。</target>
        </trans-unit>
        <trans-unit id="c1f047d78b062689ec81f8220591ae2637824e50" translate="yes" xml:space="preserve">
          <source>Often, you'll want a template to display data from a model. Loading the appropriate model is one job of a route.</source>
          <target state="translated">通常情况下,你会想要一个模板来显示一个模型的数据。加载合适的模型是路由的一项工作。</target>
        </trans-unit>
        <trans-unit id="d6ad0b4e0abbf304dee7a1c87c639ad156bc354a" translate="yes" xml:space="preserve">
          <source>Oftentimes we'll need to repeat a component multiple times in a row, with different data for each usage of the component. We can use the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#each&quot;&gt;&lt;code&gt;{{#each}}&lt;/code&gt;&lt;/a&gt; helper to loop through lists of items like this, repeating a section of template for each item in the list.</source>
          <target state="translated">通常，我们需要连续重复一个组件多次，每次使用该组件时都使用不同的数据。我们可以使用&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#each&quot;&gt; &lt;code&gt;{{#each}}&lt;/code&gt; &lt;/a&gt;帮助程序来遍历这样的项目列表，为列表中的每个项目重复模板的一部分。</target>
        </trans-unit>
        <trans-unit id="2c3ffdb1abb5aafa99ed88d09e01065a059a00a9" translate="yes" xml:space="preserve">
          <source>On Component Destroy</source>
          <target state="translated">销毁组件时</target>
        </trans-unit>
        <trans-unit id="7871fb44d093405668420a934d855c398825b852" translate="yes" xml:space="preserve">
          <source>On Initial Render</source>
          <target state="translated">初始渲染时</target>
        </trans-unit>
        <trans-unit id="3b81a353de54248fb63ae86d5a82b1a0e405029d" translate="yes" xml:space="preserve">
          <source>On Mac and Linux, you can improve file watching performance by installing &lt;a href=&quot;https://facebook.github.io/watchman/docs/install.html&quot;&gt;Watchman&lt;/a&gt;.</source>
          <target state="translated">在Mac和Linux上，您可以通过安装&lt;a href=&quot;https://facebook.github.io/watchman/docs/install.html&quot;&gt;Watchman&lt;/a&gt;来提高文件监视性能。</target>
        </trans-unit>
        <trans-unit id="58e13e632d3a342d5053b03478a93981c741b85e" translate="yes" xml:space="preserve">
          <source>On Re-Render</source>
          <target state="translated">在重新渲染时</target>
        </trans-unit>
        <trans-unit id="79702120c7c021f8b09ee1afda618cd0df787a69" translate="yes" xml:space="preserve">
          <source>On a belongsTo relationship:</source>
          <target state="translated">在一个 belongsTo关系上。</target>
        </trans-unit>
        <trans-unit id="eb43fdb147dc2a32fcd7a2f1655715ba70c1d257" translate="yes" xml:space="preserve">
          <source>On a class-based helper, it may be useful to force a recomputation of that helpers value. This is akin to &lt;code&gt;rerender&lt;/code&gt; on a component.</source>
          <target state="translated">在基于类的帮助程序上，强制重新计算该帮助程序的值可能会很有用。这类似于 &lt;code&gt;rerender&lt;/code&gt; 在组件上。</target>
        </trans-unit>
        <trans-unit id="6861bce269e523e12d7da65c6da77edffe736f32" translate="yes" xml:space="preserve">
          <source>On all newer browsers, you only need to use this method to retrieve properties if the property might not be defined on the object and you want to respect the &lt;code&gt;unknownProperty&lt;/code&gt; handler. Otherwise you can ignore this method.</source>
          <target state="translated">在所有较新的浏览器上，如果可能未在对象上定义属性并且您要遵守 &lt;code&gt;unknownProperty&lt;/code&gt; 处理程序，则仅需要使用此方法来检索属性。否则，您可以忽略此方法。</target>
        </trans-unit>
        <trans-unit id="aeba23ad12f082d9bc5f8ea964d08e7ff1c2466b" translate="yes" xml:space="preserve">
          <source>On an Apache server, the rewrite engine (mod-rewrite) must be enabled in order for Ember routing to work properly. If you upload your dist folder, going to your main URL works, but when you try to go to a route such as '{main URL}/example' and it returns 404, your server has not been configured for &quot;friendly&quot; URLs.</source>
          <target state="translated">在Apache服务器上,重写引擎(mod-rewrite)必须被启用才能使Ember路由正常工作。如果你上传了你的dist文件夹,进入你的主URL可以工作,但是当你尝试进入诸如'{main URL}/example'这样的路由时,它返回404,这说明你的服务器没有为 &quot;友好 &quot;的URL配置。</target>
        </trans-unit>
        <trans-unit id="a9188633f146f1828663d4971118211e9bc5e119" translate="yes" xml:space="preserve">
          <source>On each call to the &lt;code&gt;normalize&lt;/code&gt; method, the third parameter (&lt;code&gt;prop&lt;/code&gt;) is always one of the keys that were in the original payload or in the result of another normalization as &lt;code&gt;normalizeResponse&lt;/code&gt;.</source>
          <target state="translated">在每次对 &lt;code&gt;normalize&lt;/code&gt; 方法的调用时，第三个参数（ &lt;code&gt;prop&lt;/code&gt; ）始终是原始有效负载中的键之一，或者是另一个规范化结果 &lt;code&gt;normalizeResponse&lt;/code&gt; 的键之一。</target>
        </trans-unit>
        <trans-unit id="8c9c6f59e26d3f950eadfc25af534272ba19cb77" translate="yes" xml:space="preserve">
          <source>On success, the request promise will be resolved with the full response payload.</source>
          <target state="translated">成功后,请求承诺将用完整的响应有效载荷来解决。</target>
        </trans-unit>
        <trans-unit id="78f324f1e8f3f3b4f5bff5c1b66a78f5e0759ff5" translate="yes" xml:space="preserve">
          <source>On the left side of each Guides page is a table of contents, organized into sections that can be expanded to show the topics they cover. Both the sections and the topics within each section are ordered from basic to advanced concepts.</source>
          <target state="translated">每个指南页面的左侧是一个目录,按章节组织,可以扩展以显示所涵盖的主题。各节和各节中的主题都是按基本概念到高级概念排序的。</target>
        </trans-unit>
        <trans-unit id="e3e4d1cf6f4dc0ce1d411fc45282d9de13cdd984" translate="yes" xml:space="preserve">
          <source>On the other hand, if you're looking at JavaScript documentation that tells you to set a property on an element object, you can use &lt;code&gt;{{prop&lt;/code&gt; to set the prop</source>
          <target state="translated">另一方面，如果您正在查看告诉您在元素对象上设置属性的JavaScript文档，则可以使用 &lt;code&gt;{{prop&lt;/code&gt; 来设置prop</target>
        </trans-unit>
        <trans-unit id="e32c960456f9b43f9166f605a702a559006007ce" translate="yes" xml:space="preserve">
          <source>Once a factory is registered, it can be &quot;injected&quot; where it is needed.</source>
          <target state="translated">工厂注册后,就可以在需要的地方 &quot;注入&quot;。</target>
        </trans-unit>
        <trans-unit id="f9cbd543588086a92219171a559bd29b089ae9bc" translate="yes" xml:space="preserve">
          <source>Once defined, a class exists like a variable does in the current scope:</source>
          <target state="translated">一旦被定义,一个类就像变量一样存在于当前的作用域中。</target>
        </trans-unit>
        <trans-unit id="bdec5004fb5c33e3b2c477c863020702ae402501" translate="yes" xml:space="preserve">
          <source>Once injected into a component, a service can also be used in the template. Note &lt;code&gt;cart&lt;/code&gt; being used below to get data from the cart.</source>
          <target state="translated">一旦注入到组件中，服务也可以在模板中使用。注意 &lt;code&gt;cart&lt;/code&gt; 正下方用于从购物车中获取数据。</target>
        </trans-unit>
        <trans-unit id="ccee3bf08a6536ea2be6c885ed850fbb3a399af9" translate="yes" xml:space="preserve">
          <source>Once inside the &lt;code&gt;articles&lt;/code&gt; route, any changes to the &lt;code&gt;category&lt;/code&gt; property on &lt;code&gt;controller:articles&lt;/code&gt; will cause the URL to update the query param. By default, a query param property change won't cause a full router transition (i.e. it won't call &lt;code&gt;model&lt;/code&gt; hooks and &lt;code&gt;setupController&lt;/code&gt;, etc.); it will only update the URL.</source>
          <target state="translated">一旦进入 &lt;code&gt;articles&lt;/code&gt; 路由，对 &lt;code&gt;controller:articles&lt;/code&gt; 上 &lt;code&gt;category&lt;/code&gt; 属性的任何更改都将导致URL更新查询参数。默认情况下，查询参数属性更改不会导致路由器完全过渡（即，它不会调用 &lt;code&gt;model&lt;/code&gt; 钩子和 &lt;code&gt;setupController&lt;/code&gt; 等）；只会更新网址。</target>
        </trans-unit>
        <trans-unit id="457d77836a439fdff49c3b23b258781eb29f6526" translate="yes" xml:space="preserve">
          <source>Once installed, go to an Ember application, open the Developer Tools, and click on the &lt;code&gt;Ember&lt;/code&gt; tab at the far right.</source>
          <target state="translated">安装后，转到Ember应用程序，打开开发人员工具，然后单击最右边的 &lt;code&gt;Ember&lt;/code&gt; 选项卡。</target>
        </trans-unit>
        <trans-unit id="d4986dfc0d963c8eec63b7840ddbc1ff83a864a8" translate="yes" xml:space="preserve">
          <source>Once installed, go to an Ember application, open the Developer Tools, and click on the &lt;code&gt;Ember&lt;/code&gt; tab.</source>
          <target state="translated">安装后，转到Ember应用程序，打开开发人员工具，然后单击 &lt;code&gt;Ember&lt;/code&gt; 选项卡。</target>
        </trans-unit>
        <trans-unit id="164742e39c4ca64cff90a3cf61eb5e20c381b0f7" translate="yes" xml:space="preserve">
          <source>Once installed, the addon works in 3 steps:</source>
          <target state="translated">安装后,该插件的工作分为3个步骤。</target>
        </trans-unit>
        <trans-unit id="cd5d0a583c546e922e7dd07f13b00126893c9cbb" translate="yes" xml:space="preserve">
          <source>Once loaded, a service will persist until the application exits.</source>
          <target state="translated">一旦加载,服务将持续存在,直到应用程序退出。</target>
        </trans-unit>
        <trans-unit id="9b7473ccb2808c3e1202cafe608e15eb9e87bf60" translate="yes" xml:space="preserve">
          <source>Once open, remove the component labeled &lt;code&gt;{{welcome-page}}&lt;/code&gt;. The application should now be a completely blank canvas to build our application on.</source>
          <target state="translated">打开后，删除标有 &lt;code&gt;{{welcome-page}}&lt;/code&gt; 的组件。现在，该应用程序应该是一个完全空白的画布，可用于构建我们的应用程序。</target>
        </trans-unit>
        <trans-unit id="1eca8732180d60ac42bab4f21f28e52ea9a48daf" translate="yes" xml:space="preserve">
          <source>Once rendered an element's &lt;code&gt;elementId&lt;/code&gt; is considered immutable and you should never change it. If you need to compute a dynamic value for the &lt;code&gt;elementId&lt;/code&gt;, you should do this when the component or element is being instantiated:</source>
          <target state="translated">呈现元素后， &lt;code&gt;elementId&lt;/code&gt; 被认为是不可变的，您永远不要更改它。如果需要计算 &lt;code&gt;elementId&lt;/code&gt; 的动态值，则应在实例化组件或元素时执行以下操作：</target>
        </trans-unit>
        <trans-unit id="82a9545fb47f95fd5c00cdd70a3ecca8110ee2b0" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;DEBUG&lt;/code&gt; value is set to &lt;code&gt;true&lt;/code&gt;, when you are at a breakpoint you can navigate back up the stack to the &lt;code&gt;flush&lt;/code&gt; method in and check the &lt;code&gt;errorRecordedForStack.stack&lt;/code&gt; value, which will be the captured stack when this job was scheduled.</source>
          <target state="translated">一旦 &lt;code&gt;DEBUG&lt;/code&gt; 值设置为 &lt;code&gt;true&lt;/code&gt; ，当您在断点处时，您可以将堆栈导航回使用 &lt;code&gt;flush&lt;/code&gt; 方法，并检查 &lt;code&gt;errorRecordedForStack.stack&lt;/code&gt; 值，该值将是计划此作业时捕获的堆栈。</target>
        </trans-unit>
        <trans-unit id="4267347d40eb36c6cbbed253186fd37bf3007beb" translate="yes" xml:space="preserve">
          <source>Once the beta cycle has completed, the next stable release will include any features that were enabled during the beta cycle. At this point the feature flags will be removed from the canary and future beta branches, and the feature becomes part of the framework.</source>
          <target state="translated">一旦测试周期结束,下一个稳定版将包含在测试周期中启用的任何功能。此时,功能标志将从金丝雀和未来的测试分支中移除,该功能将成为框架的一部分。</target>
        </trans-unit>
        <trans-unit id="56051bb2517e89df5d91846d46bbeb555a7edbb5" translate="yes" xml:space="preserve">
          <source>Once the main transition into &lt;code&gt;slow-model&lt;/code&gt; completes, the &lt;code&gt;loading&lt;/code&gt; route will be exited and the transition to &lt;code&gt;slow-model&lt;/code&gt; will continue.</source>
          <target state="translated">一旦完成向 &lt;code&gt;slow-model&lt;/code&gt; 的主要转换，将退出 &lt;code&gt;loading&lt;/code&gt; 路径，并继续向 &lt;code&gt;slow-model&lt;/code&gt; 转换。</target>
        </trans-unit>
        <trans-unit id="d59a62a3f97ccc2bfdeef6fc089edaeadc6ceb33" translate="yes" xml:space="preserve">
          <source>Once the proxied promise has settled this will become &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">一旦履行了诺言，这将是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4398fd5039ae29bd335437e10b017a202f1021a5" translate="yes" xml:space="preserve">
          <source>Once the proxied promise has settled this will become &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">一旦履行了诺言，这便成为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4688c68d00bda5e6b4d6f0282ecb2274e65f3aa4" translate="yes" xml:space="preserve">
          <source>Once the request to the server returns with a JSON payload for the requested record, the adapter resolves the promise it returned to the store with the JSON.</source>
          <target state="translated">一旦向服务器发出的请求返回了请求记录的JSON有效载荷,适配器就会用JSON解析它返回给存储的承诺。</target>
        </trans-unit>
        <trans-unit id="035a2dea0fa0be24848d3ad0692450c6fa370306" translate="yes" xml:space="preserve">
          <source>Once the routes are defined, how do we go about transitioning between them within our application? It depends on where the transition needs to take place:</source>
          <target state="translated">一旦定义了路由,我们如何在我们的应用程序中进行过渡?这要看过渡需要在哪里进行。</target>
        </trans-unit>
        <trans-unit id="a7341d0efec76622cf31b57420e0efd9cc42ff86" translate="yes" xml:space="preserve">
          <source>Once the stub service is registered the test simply needs to check that the stub data that is being returned from the service is reflected in the component output.</source>
          <target state="translated">一旦注册了存根服务,测试只需要检查从服务返回的存根数据是否反映在组件输出中。</target>
        </trans-unit>
        <trans-unit id="f005b56256f8b41ba8bc28347de5eacad0139afb" translate="yes" xml:space="preserve">
          <source>Once the stub service is registered, the test needs to check that the stub data from the service is reflected in the component output.</source>
          <target state="translated">一旦注册了存根服务,测试需要检查服务的存根数据是否反映在组件输出中。</target>
        </trans-unit>
        <trans-unit id="a047160287303cb08554e10e09d6a4704cbf7198" translate="yes" xml:space="preserve">
          <source>Once we &lt;code&gt;await&lt;/code&gt; the execution of the asynchronous helpers this way, we will ensure that all subsequent assertions are always made &lt;strong&gt;after&lt;/strong&gt; the previous steps in the test have completed.</source>
          <target state="translated">一旦我们以这种方式 &lt;code&gt;await&lt;/code&gt; 异步助手的执行，我们将确保在测试中的先前步骤完成&lt;strong&gt;之后&lt;/strong&gt;，始终进行所有后续断言。</target>
        </trans-unit>
        <trans-unit id="6f0dda9c0cb3a268c5b42422c783a5ad7cd0e1d9" translate="yes" xml:space="preserve">
          <source>Once we create this &quot;button with confirmation&quot; component, we want to be able to reuse it all over our application.</source>
          <target state="translated">一旦我们创建了这个 &quot;带确认的按钮 &quot;组件,我们希望能够在我们的应用程序中重复使用它。</target>
        </trans-unit>
        <trans-unit id="9fbeae9a67f6bd9c4e25f14b9f726db44131dc7a" translate="yes" xml:space="preserve">
          <source>Once we have a new project in place, we can confirm everything is working by starting the Ember development server:</source>
          <target state="translated">一旦我们有了一个新的项目,我们可以通过启动Ember开发服务器来确认一切工作。</target>
        </trans-unit>
        <trans-unit id="23b19ac1ee33b1618505282400756773afbf338c" translate="yes" xml:space="preserve">
          <source>Once yielded, the data can be accessed by the wrapped content by referencing the &lt;code&gt;post&lt;/code&gt; variable. Now a component called &lt;code&gt;markdown-style&lt;/code&gt; will be rendered in &lt;code&gt;{{post.body}}&lt;/code&gt;.</source>
          <target state="translated">一旦产生，包装的内容就可以通过引用 &lt;code&gt;post&lt;/code&gt; 变量来访问数据。现在，一个名为 &lt;code&gt;markdown-style&lt;/code&gt; 的组件将在 &lt;code&gt;{{post.body}}&lt;/code&gt; 中呈现。</target>
        </trans-unit>
        <trans-unit id="a140d5eab4a5bae85d89e8c5e6d02aa38933424a" translate="yes" xml:space="preserve">
          <source>Once you are logged-in to your Netlify account and in the &quot;Sites&quot; section, you should see the Netlify drag and drop area</source>
          <target state="translated">一旦您登录到您的Netlify账户,在 &quot;网站 &quot;部分,您应该会看到Netlify的拖放区域。</target>
        </trans-unit>
        <trans-unit id="be2dc254dc6c7464981de655c454c5b817215603" translate="yes" xml:space="preserve">
          <source>Once you call this method, any time the key's value is set, your observer will be notified. Note that the observers are triggered any time the value is set, regardless of whether it has actually changed. Your observer should be prepared to handle that.</source>
          <target state="translated">一旦你调用这个方法,任何时候键的值被设置,你的观察者都会被通知。请注意,无论值是否实际发生了变化,任何时候都会触发观察者。你的观察者应该做好处理的准备。</target>
        </trans-unit>
        <trans-unit id="c2c34893439eddc0041c09c4f5e714db935f2904" translate="yes" xml:space="preserve">
          <source>Once you click the &quot;Deploy site&quot; button, you will be taken to your website &quot;Overview&quot; and you should see the status of your deployment</source>
          <target state="translated">一旦你点击 &quot;部署网站 &quot;按钮,你将被带到你的网站 &quot;概述&quot;,你应该看到你的部署状态。</target>
        </trans-unit>
        <trans-unit id="9adc765189962af6b2b054d5d23f3d48e08dcdbd" translate="yes" xml:space="preserve">
          <source>Once you have an understanding of Ember Data, you will have a much better way to manage the complexity of data loading in your application. This will allow your code to evolve and grow, with better maintainability.</source>
          <target state="translated">一旦您了解了Ember Data,您将有一个更好的方法来管理应用程序中数据加载的复杂性。这将使您的代码能够发展和成长,具有更好的可维护性。</target>
        </trans-unit>
        <trans-unit id="0e423cbca6b9df549f466352ce6ab4bd43120115" translate="yes" xml:space="preserve">
          <source>Once you have an understanding of Ember Data, you will have a much better way to manage the complexity of data loading in your application. This will allow your code to evolve without becoming a mess.</source>
          <target state="translated">一旦你了解了Ember Data,你将有一个更好的方法来管理应用程序中数据加载的复杂性。这将使您的代码能够不断发展,而不会变得一团糟。</target>
        </trans-unit>
        <trans-unit id="e7879c2db8a502cf08ab955e6b7189ce9ea7ec40" translate="yes" xml:space="preserve">
          <source>Once you have built your &lt;code&gt;deprecation-workflow.js&lt;/code&gt; file and your deprecations are silenced, you can begin to work on deprecations one by one at your own leisure. To find deprecations, you can change the handler value of that message to either &lt;code&gt;throw&lt;/code&gt; or &lt;code&gt;log&lt;/code&gt;. Throw will throw an actual exception when the deprecation is encountered, so that tests that use the deprecated feature will fail. Choosing to log will simply log a warning to the console as before. These settings give you some flexibility on how you want to go about fixing the deprecations.</source>
          <target state="translated">一旦构建了 &lt;code&gt;deprecation-workflow.js&lt;/code&gt; 文件并且弃用项被静音，您就可以开始随意地逐项处理弃用项。要查找弃用项，可以将该消息的处理程序值更改为 &lt;code&gt;throw&lt;/code&gt; 或 &lt;code&gt;log&lt;/code&gt; 。遇到弃用时，抛出将引发实际的异常，因此使用弃用功能的测试将失败。选择记录只会像以前一样将警告记录到控制台。这些设置为您提供了一些解决折旧的灵活性。</target>
        </trans-unit>
        <trans-unit id="297de7e31394aa2c72d2a09e3d3842f25dc27bdc" translate="yes" xml:space="preserve">
          <source>Once you have defined a class, you can create new &lt;em&gt;instances&lt;/em&gt; of that class by calling its &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_create&quot;&gt;&lt;code&gt;create()&lt;/code&gt;&lt;/a&gt; method. Any methods, properties and computed properties you defined on the class will be available to instances:</source>
          <target state="translated">一旦定义了一个类，就可以通过调用其&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_create&quot;&gt; &lt;code&gt;create()&lt;/code&gt; &lt;/a&gt;方法来创建该类的新&lt;em&gt;实例&lt;/em&gt;。您在类上定义的任何方法，属性和计算属性将可用于实例：</target>
        </trans-unit>
        <trans-unit id="0ae78f9453ab89e2b98b40a513549fd747f33aca" translate="yes" xml:space="preserve">
          <source>Once you have defined a route with a dynamic segment, Ember will extract the value of the dynamic segment from the URL for you and pass them as a hash to the &lt;code&gt;model&lt;/code&gt; hook as the first argument:</source>
          <target state="translated">一旦定义了带有动态分段的路线，Ember将从您的URL中提取动态分段的值，并将其作为哈希值作为第一个参数传递给 &lt;code&gt;model&lt;/code&gt; 挂钩：</target>
        </trans-unit>
        <trans-unit id="d56fddae181db8c2b78a84601bce87e7de8acc10" translate="yes" xml:space="preserve">
          <source>Once you have installed canary, feature-flags can be activated at build-time by an environment variable or at runtime using &lt;code&gt;window.EmberDataENV&lt;/code&gt;.</source>
          <target state="translated">一旦安装了canary，就可以在构建时通过环境变量或在运行时使用 &lt;code&gt;window.EmberDataENV&lt;/code&gt; 激活功能标记。</target>
        </trans-unit>
        <trans-unit id="aa5d0d138ce115e372b6db1d89430c67ac960c72" translate="yes" xml:space="preserve">
          <source>Once you have successfully connected your GitHub account with Netlify, you should see a list of repositories to choose from. Select or search for your GitHub repository that you wish to deploy</source>
          <target state="translated">一旦你成功地将你的GitHub帐户与Netlify连接,你应该看到一个可供选择的版本库列表,选择或搜索你想部署的GitHub版本库。选择或搜索你想要部署的GitHub仓库。</target>
        </trans-unit>
        <trans-unit id="37dc9e0949005db31c3bef8749a046174ea22093" translate="yes" xml:space="preserve">
          <source>Once you have these two methods implemented, apply the &lt;code&gt;Ember.Enumerable&lt;/code&gt; mixin to your class and you will be able to enumerate the contents of your object like any other collection.</source>
          <target state="translated">一旦实现了这两种方法， &lt;code&gt;Ember.Enumerable&lt;/code&gt; mixin应用于您的类，您将可以像其他任何集合一样枚举对象的内容。</target>
        </trans-unit>
        <trans-unit id="b15e1b20d0b0af628b5179c016082022baa8c7ff" translate="yes" xml:space="preserve">
          <source>Once you have upgraded an app's version, some new features may be available out of the box. On the other hand, some features will require that you enable them specifically in your app's configuration, since they may change the app's default behavior.</source>
          <target state="translated">一旦您升级了应用程序的版本,一些新功能可能会开箱即用。另一方面,有些功能需要您在应用程序的配置中专门启用,因为它们可能会改变应用程序的默认行为。</target>
        </trans-unit>
        <trans-unit id="33ebab4951d433891c0e76e835d2372486c21e1f" translate="yes" xml:space="preserve">
          <source>Once you see &quot;Your site is deployed&quot; as shown above, your website is now live and you can click on the link provided above the &quot;Getting started&quot; section to view your site</source>
          <target state="translated">一旦您看到 &quot;您的网站已部署&quot;,如上图所示,您的网站现在已经上线,您可以点击 &quot;开始 &quot;部分上方提供的链接来查看您的网站。</target>
        </trans-unit>
        <trans-unit id="1b9d85c5deeeb3704876076fe0a38dc0383e0843" translate="yes" xml:space="preserve">
          <source>Once you see a feature that you would like to toggle for your project you can run one of two commands, &lt;code&gt;ember feature:enable &amp;lt;feature&amp;gt;&lt;/code&gt; and &lt;code&gt;ember feature:disable &amp;lt;feature&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">一旦看到要为项目切换的功能，就可以运行以下两个命令之一 &lt;code&gt;ember feature:enable &amp;lt;feature&amp;gt;&lt;/code&gt; 和 &lt;code&gt;ember feature:disable &amp;lt;feature&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d318d88b083e6a740e5695fcce549c330e442a4c" translate="yes" xml:space="preserve">
          <source>Once you've installed Ember CLI via npm, you will have access to a new &lt;code&gt;ember&lt;/code&gt; command in your terminal. You can use the &lt;code&gt;ember new&lt;/code&gt; command to create a new application.</source>
          <target state="translated">通过npm安装Ember CLI后，您将可以在终端中访问新的 &lt;code&gt;ember&lt;/code&gt; 命令。您可以使用 &lt;code&gt;ember new&lt;/code&gt; 命令来创建新的应用程序。</target>
        </trans-unit>
        <trans-unit id="ed008ddc2ecf4254729fcc7abac70a4419caad53" translate="yes" xml:space="preserve">
          <source>Once you've loaded your models from storage, components know how to translate model data into a UI that your user can interact with. For more information about how components get model data, see the &lt;a href=&quot;../routing/specifying-a-routes-model&quot;&gt;Specifying a Route's Model&lt;/a&gt; guide.</source>
          <target state="translated">从存储中加载模型后，组件便知道如何将模型数据转换为用户可以与之交互的UI。有关组件如何获取模型数据的更多信息，请参见《&lt;a href=&quot;../routing/specifying-a-routes-model&quot;&gt;指定路线的模型》&lt;/a&gt;指南。</target>
        </trans-unit>
        <trans-unit id="fae22ba23783545c09734f8348d02996c94f94d2" translate="yes" xml:space="preserve">
          <source>Once you've loaded your models from storage, components know how to translate model data into a UI that your user can interact with. For more information about how components get model data, see the &lt;a href=&quot;https://guides.emberjs.com/routing/specifying-a-routes-model&quot;&gt;Specifying a Route's Model&lt;/a&gt; guide.</source>
          <target state="translated">从存储中加载模型后，组件便知道如何将模型数据转换为用户可以与之交互的UI。有关组件如何获取模型数据的更多信息，请参见&amp;ldquo; &lt;a href=&quot;https://guides.emberjs.com/routing/specifying-a-routes-model&quot;&gt;指定路线的模型&amp;rdquo;&lt;/a&gt;指南。</target>
        </trans-unit>
        <trans-unit id="ec5fbc573c5964663edea838c458902fcef9408a" translate="yes" xml:space="preserve">
          <source>Once you've loaded your models from storage, components know how to translate model data into a UI that your user can interact with. For more information about how components get model data, see the &lt;a href=&quot;https://guides.emberjs.com/routing/specifying-a-routes-model/&quot;&gt;Specifying a Route's Model&lt;/a&gt; guide.</source>
          <target state="translated">从存储中加载模型后，组件便知道如何将模型数据转换为用户可以与之交互的UI。有关组件如何获取模型数据的更多信息，请参见《&lt;a href=&quot;https://guides.emberjs.com/routing/specifying-a-routes-model/&quot;&gt;指定路线的模型》&lt;/a&gt;指南。</target>
        </trans-unit>
        <trans-unit id="946fb83a5b5f0d85f4cd4d0947e1d59cebfd37a1" translate="yes" xml:space="preserve">
          <source>Once you've removed deprecations that you may not need to immediately address, you may still be left with many deprecations. Also, your remaining deprecations may only occur in very specific scenarios that are not obvious. How then should you go about finding and fixing these? This is where the &lt;a href=&quot;http://emberobserver.com/addons/ember-cli-deprecation-workflow&quot;&gt;ember-cli-deprecation-workflow&lt;/a&gt; addon can be extremely helpful.</source>
          <target state="translated">删除不需要立即解决的弃用项之后，您可能仍然会遇到许多弃用项。此外，您剩余的折旧费仅可能在不太明显的非常特定的情况下发生。那您应该如何去寻找并解决这些问题呢？这是&lt;a href=&quot;http://emberobserver.com/addons/ember-cli-deprecation-workflow&quot;&gt;ember-cli-preprecation-workflow&lt;/a&gt;附加组件非常有用的地方。</target>
        </trans-unit>
        <trans-unit id="9b5a236db997313e379baebf8b99be646172bb5f" translate="yes" xml:space="preserve">
          <source>One benefit of the above approach compared to using &lt;code&gt;next&lt;/code&gt; is that you will be able to perform DOM/CSS operations before unprocessed elements are rendered to the screen, which may prevent flickering or other artifacts caused by delaying processing until after rendering.</source>
          <target state="translated">与使用 &lt;code&gt;next&lt;/code&gt; 方法相比，上述方法的一个好处是您可以在将未处理的元素呈现到屏幕之前执行DOM / CSS操作，这可以防止由于延迟处理直到呈现之后而引起的闪烁或其他伪像。</target>
        </trans-unit>
        <trans-unit id="7d393feab7e66d7efa30902c007f830f56512202" translate="yes" xml:space="preserve">
          <source>One benefit of the above approach compared to using &lt;code&gt;run.next&lt;/code&gt; is that you will be able to perform DOM/CSS operations before unprocessed elements are rendered to the screen, which may prevent flickering or other artifacts caused by delaying processing until after rendering.</source>
          <target state="translated">与使用 &lt;code&gt;run.next&lt;/code&gt; 相比，上述方法的优点之一是您可以在将未处理的元素呈现到屏幕之前执行DOM / CSS操作，这可以防止由于延迟处理直到呈现之后而引起的闪烁或其他伪像。</target>
        </trans-unit>
        <trans-unit id="2017e7fd0f2a575b1a1bb39b33094a703f7dc923" translate="yes" xml:space="preserve">
          <source>One common example is when overriding the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalizeResponse&quot;&gt;&lt;code&gt;normalizeResponse()&lt;/code&gt;&lt;/a&gt; hook in one of Ember-Data's serializers.</source>
          <target state="translated">一个常见的示例是在Ember-Data的序列化程序之一中重写&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalizeResponse&quot;&gt; &lt;code&gt;normalizeResponse()&lt;/code&gt; &lt;/a&gt;挂钩时。</target>
        </trans-unit>
        <trans-unit id="24d60b4229d3dd8c3b6979867083b6a314e88b0d" translate="yes" xml:space="preserve">
          <source>One common example is when overriding the &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/JSONAPISerializer/methods#normalizeResponse&quot;&gt;&lt;code&gt;normalizeResponse()&lt;/code&gt;&lt;/a&gt; hook in one of Ember Data's serializers.</source>
          <target state="translated">一个常见的示例是在Ember Data的序列化程序之一中重写&lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/JSONAPISerializer/methods#normalizeResponse&quot;&gt; &lt;code&gt;normalizeResponse()&lt;/code&gt; &lt;/a&gt;挂钩时。</target>
        </trans-unit>
        <trans-unit id="ef72e13fa9c7abd23262b84daf45e66eae37d8b2" translate="yes" xml:space="preserve">
          <source>One common way of building web applications is to tightly couple user interface elements to data fetching. For example, imagine you are writing the admin section of a blogging app, which has a feature that lists the drafts for the currently logged in user.</source>
          <target state="translated">构建Web应用的一种常见方式是将用户界面元素与数据获取紧密耦合。例如,想象一下,你正在编写一个博客应用的管理部分,该应用有一个功能是列出当前登录用户的草稿。</target>
        </trans-unit>
        <trans-unit id="1fd57542548476a402566a40e7028672d63f27fb" translate="yes" xml:space="preserve">
          <source>One detail to keep in mind is that both branches of the &lt;code&gt;if&lt;/code&gt; helper will be evaluated, so if you have &lt;code&gt;{{if condition &quot;foo&quot; (expensive-operation &quot;bar&quot;)&lt;/code&gt;, &lt;code&gt;expensive-operation&lt;/code&gt; will always calculate.</source>
          <target state="translated">要记住的一个细节是，将对 &lt;code&gt;if&lt;/code&gt; 助手的两个分支进行评估，因此，如果您拥有 &lt;code&gt;{{if condition &quot;foo&quot; (expensive-operation &quot;bar&quot;)&lt;/code&gt; ，那么总是会进行 &lt;code&gt;expensive-operation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="921f9a649da7d3ee552d9bb46da95892c7504e20" translate="yes" xml:space="preserve">
          <source>One downside to returning a cached record is you may find the state of the data has changed since it was first loaded into the store's identity map. In order to prevent this stale data from being a problem for long, Ember Data will automatically make a request in the background each time a cached record is returned from the store. When the new data comes in, the record is updated, and if there have been changes to the record since the initial render, the template is re-rendered with the new information.</source>
          <target state="translated">返回缓存记录的一个缺点是,你可能会发现数据的状态在第一次加载到商店的身份图中后已经发生了变化。为了防止这种陈旧的数据长期存在,每次从商店返回缓存记录时,Ember Data都会在后台自动进行请求。当新的数据进来后,记录就会被更新,如果从初始渲染后记录有变化,就会用新的信息重新渲染模板。</target>
        </trans-unit>
        <trans-unit id="3e384e5b15606da3e69fd4ec7b0e22e51cb4eec4" translate="yes" xml:space="preserve">
          <source>One example is to add computed properties to your component:</source>
          <target state="translated">一个例子是在你的组件中添加计算属性。</target>
        </trans-unit>
        <trans-unit id="6e6e9d09355e2e6fdfee3fc6889b073f2cc7d11f" translate="yes" xml:space="preserve">
          <source>One job of a route handler is rendering the appropriate template to the screen.</source>
          <target state="translated">路由处理程序的一项工作是将适当的模板渲染到屏幕上。</target>
        </trans-unit>
        <trans-unit id="023b2e22d9619644336d8abd002c12ec4e3957f7" translate="yes" xml:space="preserve">
          <source>One nice thing about this model is that if you try to set a value to the same thing as last time, Ember (through HTMLBars) will avoid doing any work on the DOM.</source>
          <target state="translated">这种模式有一个很好的地方就是,如果你试图将一个值设置成和上次一样的东西,Ember(通过HTMLBars)会避免在DOM上做任何工作。</target>
        </trans-unit>
        <trans-unit id="2c25bd1df98cee9098780b27f236f384e2f2dd2d" translate="yes" xml:space="preserve">
          <source>One of the major issues in testing web applications is that all code is event-driven and therefore has the potential to be asynchronous (i.e. output can happen out of sequence from input). This has the ramification that code can be executed in any order.</source>
          <target state="translated">测试Web应用程序的主要问题之一是所有代码都是事件驱动的,因此有可能是异步的(即输出可能与输入的顺序不同)。这带来的后果是,代码可以以任何顺序执行。</target>
        </trans-unit>
        <trans-unit id="f22cb0dab0dc2d88fe000d648a9d5f8ff6c7e07a" translate="yes" xml:space="preserve">
          <source>One of the methods is &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_transitionTo&quot;&gt;&lt;code&gt;transitionTo()&lt;/code&gt;&lt;/a&gt;. Calling &lt;code&gt;transitionTo()&lt;/code&gt; from a route or &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Controller.html#method_transitionToRoute&quot;&gt;&lt;code&gt;transitionToRoute()&lt;/code&gt;&lt;/a&gt; from a controller will stop any transitions currently in progress and start a new one, functioning as a redirect. &lt;code&gt;transitionTo()&lt;/code&gt; behaves exactly like the &lt;a href=&quot;https://guides.emberjs.com/templates/links&quot;&gt;link-to&lt;/a&gt; helper.</source>
          <target state="translated">方法之一是&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_transitionTo&quot;&gt; &lt;code&gt;transitionTo()&lt;/code&gt; &lt;/a&gt;。调用 &lt;code&gt;transitionTo()&lt;/code&gt; 从路线或&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Controller.html#method_transitionToRoute&quot;&gt; &lt;code&gt;transitionToRoute()&lt;/code&gt; &lt;/a&gt;从控制器将停止当前执行的任何过渡正在进行中，并开始一个新的，作为重定向功能。 &lt;code&gt;transitionTo()&lt;/code&gt; 的行为与&lt;a href=&quot;https://guides.emberjs.com/templates/links&quot;&gt;链接到&lt;/a&gt;帮助器的行为完全相同。</target>
        </trans-unit>
        <trans-unit id="d7fa6909d82a904c6cff8f9a667268e7d78933f3" translate="yes" xml:space="preserve">
          <source>One of the methods is &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#transitionTo&quot;&gt;&lt;code&gt;transitionTo()&lt;/code&gt;&lt;/a&gt;. Calling &lt;code&gt;transitionTo()&lt;/code&gt; from a route or &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Controller/methods#transitionToRoute&quot;&gt;&lt;code&gt;transitionToRoute()&lt;/code&gt;&lt;/a&gt; from a controller will stop any transitions currently in progress and start a new one, functioning as a redirect. &lt;code&gt;transitionTo()&lt;/code&gt; behaves exactly like the &lt;a href=&quot;https://guides.emberjs.com/templates/links/&quot;&gt;&lt;code&gt;LinkTo&lt;/code&gt;&lt;/a&gt; helper.</source>
          <target state="translated">方法之一是&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#transitionTo&quot;&gt; &lt;code&gt;transitionTo()&lt;/code&gt; &lt;/a&gt;。调用 &lt;code&gt;transitionTo()&lt;/code&gt; 从路线或&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Controller/methods#transitionToRoute&quot;&gt; &lt;code&gt;transitionToRoute()&lt;/code&gt; &lt;/a&gt;从控制器将停止当前执行的任何过渡正在进行中，并开始一个新的，作为重定向功能。 &lt;code&gt;transitionTo()&lt;/code&gt; 的行为与&lt;a href=&quot;https://guides.emberjs.com/templates/links/&quot;&gt; &lt;code&gt;LinkTo&lt;/code&gt; &lt;/a&gt;帮助器完全相同。</target>
        </trans-unit>
        <trans-unit id="3d247fef3beb6617e410a9310b1691023a273f3f" translate="yes" xml:space="preserve">
          <source>One of the responsibilities of a route is to load a model.</source>
          <target state="translated">航线的职责之一就是装载模型。</target>
        </trans-unit>
        <trans-unit id="4db10af2705c05b2352d5ae0b313303226020bab" translate="yes" xml:space="preserve">
          <source>One of the ways that Ember releases guarantee stability is by following &lt;a href=&quot;https://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt; (SemVer). For the Ember project this means that any feature that is to be removed must first be deprecated, and only removed when a major version is released. It also means that new features are introduced in a backwards compatible way.</source>
          <target state="translated">Ember发布保证稳定性的方法之一是遵循&lt;a href=&quot;https://semver.org/&quot;&gt;语义版本控制&lt;/a&gt;（SemVer）。对于Ember项目，这意味着必须先弃用要删除的任何功能，并且仅在发布主版本时才将其删除。这也意味着以向后兼容的方式引入了新功能。</target>
        </trans-unit>
        <trans-unit id="bc339cc993a1d0dfdea6070d19f55e3e10babcc4" translate="yes" xml:space="preserve">
          <source>One or more Mixin classes</source>
          <target state="translated">一个或多个Mixin班</target>
        </trans-unit>
        <trans-unit id="a4387dcdd8c21d687d201ae902808eab655aaeb6" translate="yes" xml:space="preserve">
          <source>One property can be mapped on to another by placing a &quot;:&quot; between the source property and the destination property:</source>
          <target state="translated">一个属性可以通过在源属性和目的属性之间放置一个&quot;:&quot;来映射到另一个属性上。</target>
        </trans-unit>
        <trans-unit id="ddd8ba8819277c241acfb17d9b513165c7a86664" translate="yes" xml:space="preserve">
          <source>One scenario would be to camelCase the meta keys of your payload. The example below shows how this could be done using &lt;code&gt;normalizeArrayResponse&lt;/code&gt; and &lt;code&gt;extractRelationship&lt;/code&gt;.</source>
          <target state="translated">一种情况是驼峰化有效负载的元密钥。下面的示例显示了如何使用 &lt;code&gt;normalizeArrayResponse&lt;/code&gt; 和 &lt;code&gt;extractRelationship&lt;/code&gt; 完成此操作。</target>
        </trans-unit>
        <trans-unit id="467f5c1f11f4fc8b09ce3a5b43a54f0e1c05570d" translate="yes" xml:space="preserve">
          <source>One simple way to add page titles is to create a &lt;code&gt;title&lt;/code&gt; helper:</source>
          <target state="translated">添加页面标题的一种简单方法是创建 &lt;code&gt;title&lt;/code&gt; 助手：</target>
        </trans-unit>
        <trans-unit id="97e7553844cde0e577049d9ab7cc94f72565fa90" translate="yes" xml:space="preserve">
          <source>One thing that makes Ember special is that every app you create has a &lt;em&gt;lot&lt;/em&gt; in common with apps that other people have made. This means that chances are good that you can connect with other developers who share both your interests and technical challenges. Visit the &lt;a href=&quot;https://emberjs.com/community/&quot;&gt;Ember Community page&lt;/a&gt; to learn about the ways you can get connected. Find a nearby meetup, ask questions, follow a newsletter, and more! We hope to see you around!</source>
          <target state="translated">使Ember与众不同的一件事是，您创建的每个应用程序与他人制作的应用程序都有&lt;em&gt;很多&lt;/em&gt;共同点。这意味着您有机会与拥有共同兴趣和技术挑战的其他开发人员建立联系。访问&lt;a href=&quot;https://emberjs.com/community/&quot;&gt;Ember社区页面&lt;/a&gt;以了解建立联系的方式。寻找附近的聚会，提问，关注新闻通讯等等！我们希望能与您见面！</target>
        </trans-unit>
        <trans-unit id="867d5906f67405a74420e9289d5c01bc85d7ba3c" translate="yes" xml:space="preserve">
          <source>One way to organize is to mimic the folder structure of &lt;code&gt;app/routes&lt;/code&gt;. In other words, for every route, you create an application test file. If this would result in too many files, you can instead create a file for each parent route.</source>
          <target state="translated">一种组织方式是模仿 &lt;code&gt;app/routes&lt;/code&gt; 的文件夹结构。换句话说，对于每条路由，您都将创建一个应用程序测试文件。如果这会导致文件过多，则可以为每个父路由创建一个文件。</target>
        </trans-unit>
        <trans-unit id="aa8da0e5204ecf2e3129f7e87c21cf719d86102c" translate="yes" xml:space="preserve">
          <source>One way to think about the store is as a cache of all of the records that have been loaded by your application. If a route or a controller in your app asks for a record, the store can return it immediately if it is in the cache. Otherwise, the store must ask the adapter to load it, which usually means a trip over the network to retrieve it from the server.</source>
          <target state="translated">有一种方法可以把商店看成是你的应用程序已经加载的所有记录的缓存。如果你的应用程序中的路由或控制器要求获取一条记录,如果它在缓存中,商店可以立即返回。否则,商店必须要求适配器加载它,这通常意味着要通过网络从服务器上检索它。</target>
        </trans-unit>
        <trans-unit id="8c24dfe505a974aee3ed176f59d17fbda0bb9ffa" translate="yes" xml:space="preserve">
          <source>One, unit tests are typically isolated and focus on individual methods and functions, so it is easy to debug when your tests fail.</source>
          <target state="translated">其一,单元测试通常是孤立的,专注于单个方法和函数,所以当你的测试失败时,很容易调试。</target>
        </trans-unit>
        <trans-unit id="206de582d9e42728271567f32cef1d2caa66c410" translate="yes" xml:space="preserve">
          <source>One-To-Many</source>
          <target state="translated">One-To-Many</target>
        </trans-unit>
        <trans-unit id="72ed6317b3c29cc659bd9726d64c0704e0a987b4" translate="yes" xml:space="preserve">
          <source>One-To-One</source>
          <target state="translated">One-To-One</target>
        </trans-unit>
        <trans-unit id="e8edf93e5fc748fcefb10c45b67f1fe2105f8341" translate="yes" xml:space="preserve">
          <source>One-Way Bindings</source>
          <target state="translated">单向装订</target>
        </trans-unit>
        <trans-unit id="a888cbb9d1975f7a372576caffb7acdfc8b16b4f" translate="yes" xml:space="preserve">
          <source>One-to-Many</source>
          <target state="translated">One-to-Many</target>
        </trans-unit>
        <trans-unit id="a2cab38603c3673e0e2b0a47873e43f0dbfdffa8" translate="yes" xml:space="preserve">
          <source>One-to-One</source>
          <target state="translated">One-to-One</target>
        </trans-unit>
        <trans-unit id="69039b055f29859716cd66c6b480ac6e9f39194e" translate="yes" xml:space="preserve">
          <source>One-way Data Flow</source>
          <target state="translated">单向数据流</target>
        </trans-unit>
        <trans-unit id="7cd4094ddfbc83c812c552f23a48ae51c79c9bda" translate="yes" xml:space="preserve">
          <source>Only one helper manager is guaranteed to exist per &lt;code&gt;owner&lt;/code&gt; and per usage of &lt;code&gt;setHelperManager&lt;/code&gt;, so many helpers will end up using the same instance of the helper manager. As such, you should only store state that is related to the manager itself. If you want to store state specific to a particular helper definition, you should assign a unique helper manager to that helper. In general, most managers should either be stateless, or only have the &lt;code&gt;owner&lt;/code&gt; they were created with as state.</source>
          <target state="translated">确保每个 &lt;code&gt;owner&lt;/code&gt; 和 &lt;code&gt;setHelperManager&lt;/code&gt; 的每次使用仅存在一个助手管理器，因此许多助手最终将使用该助手管理器的同一实例。因此，您应该只存储与管理器本身相关的状态。如果要存储特定于特定助手定义的状态，则应为该助手分配一个唯一的助手管理器。通常，大多数管理器应该是无状态的，或者只将其创建时的 &lt;code&gt;owner&lt;/code&gt; 作为状态。</target>
        </trans-unit>
        <trans-unit id="56312e9de33823d672f614456c13a57c2666c655" translate="yes" xml:space="preserve">
          <source>Only specific decorators provided by Ember can be applied this way in classic classes.</source>
          <target state="translated">在经典类中,只有Ember提供的特定装饰器可以这样应用。</target>
        </trans-unit>
        <trans-unit id="d328cfa965ffcc50cbae46e22f7eacf54dc6ea0e" translate="yes" xml:space="preserve">
          <source>Only valid HTML elements in a &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag can be used</source>
          <target state="translated">只能使用 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 标记中的有效HTML元素</target>
        </trans-unit>
        <trans-unit id="bfa59a0348d458088b021847d4beef2f800c063e" translate="yes" xml:space="preserve">
          <source>Open &lt;a href=&quot;http://localhost:4200&quot;&gt;&lt;code&gt;http://localhost:4200&lt;/code&gt;&lt;/a&gt; in your browser of choice. You should see an Ember welcome page and not much else.</source>
          <target state="translated">在您选择的浏览器中打开&lt;a href=&quot;http://localhost:4200&quot;&gt; &lt;code&gt;http://localhost:4200&lt;/code&gt; &lt;/a&gt;。您应该看到一个Ember欢迎页面，而没有其他内容。</target>
        </trans-unit>
        <trans-unit id="f2b45396a05b9e6a742a38dba57faf9bcaacbc0e" translate="yes" xml:space="preserve">
          <source>Open &lt;a href=&quot;http://localhost:4200&quot;&gt;&lt;code&gt;http://localhost:4200&lt;/code&gt;&lt;/a&gt; in your browser of choice. You should see an Ember welcome page and not much else. Congratulations! You just created and booted your first Ember app.</source>
          <target state="translated">在您选择的浏览器中打开&lt;a href=&quot;http://localhost:4200&quot;&gt; &lt;code&gt;http://localhost:4200&lt;/code&gt; &lt;/a&gt;。您应该看到一个Ember欢迎页面，没有其他内容。恭喜你！您刚刚创建并启动了第一个Ember应用程序。</target>
        </trans-unit>
        <trans-unit id="2f97601478ddfa30694a21e0aee77ce407626778" translate="yes" xml:space="preserve">
          <source>Open our existing acceptance test, &lt;code&gt;tests/acceptance/list-rentals-test.js&lt;/code&gt;, and implement the test labeled &quot;should filter the list of rentals by city&quot;.</source>
          <target state="translated">打开我们现有的验收测试， &lt;code&gt;tests/acceptance/list-rentals-test.js&lt;/code&gt; ，并实施标有&amp;ldquo;应按城市过滤出租清单&amp;rdquo;的测试。</target>
        </trans-unit>
        <trans-unit id="0cc801dfb3bc3822b07222ee8a7d8dcfc04c59ec" translate="yes" xml:space="preserve">
          <source>Open the newly-created template in &lt;code&gt;app/templates/scientists.hbs&lt;/code&gt; and add the following HTML:</source>
          <target state="translated">在 &lt;code&gt;app/templates/scientists.hbs&lt;/code&gt; 中打开新创建的模板，并添加以下HTML：</target>
        </trans-unit>
        <trans-unit id="ca4a95be4af61aa0fce1e5925d32c5bcc4963385" translate="yes" xml:space="preserve">
          <source>Opening an issue or pull request to &lt;a href=&quot;https://github.com/ember-learn/guides-source/&quot;&gt;the GitHub repository&lt;/a&gt;</source>
          <target state="translated">打开一个问题或请求到&lt;a href=&quot;https://github.com/ember-learn/guides-source/&quot;&gt;GitHub存储库&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd792fbd2875bdf3718df2a36075e5b668af82a7" translate="yes" xml:space="preserve">
          <source>Opening an issue or pull request to &lt;a href=&quot;https://github.com/emberjs/guides/&quot;&gt;the GitHub repository&lt;/a&gt;</source>
          <target state="translated">打开一个问题或请求到&lt;a href=&quot;https://github.com/emberjs/guides/&quot;&gt;GitHub存储库&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c1dd165afc95895bd90768a2a8a39ca08acf8783" translate="yes" xml:space="preserve">
          <source>Opening that file will reveal some initial code that will try to go to the &lt;code&gt;list-rentals&lt;/code&gt; route and verify that the route is loaded. The initial code is there to help us build our first acceptance test.</source>
          <target state="translated">打开该文件将显示一些初始代码，这些代码将尝试转到 &lt;code&gt;list-rentals&lt;/code&gt; 路由并验证该路由是否已加载。那里的初始代码可帮助我们建立第一个验收测试。</target>
        </trans-unit>
        <trans-unit id="68394f0bdcf1b11a4905c9738f7ac23b35d3aca2" translate="yes" xml:space="preserve">
          <source>Opening the template for this route reveals an outlet underneath the route's general page information. At the bottom of the template, you'll notice an &lt;code&gt;{{outlet}}&lt;/code&gt; helper. This is where the active nested route will be rendered.</source>
          <target state="translated">打开此路线的模板会在路线的常规页面信息下方显示一个出口。在模板的底部，您会注意到一个 &lt;code&gt;{{outlet}}&lt;/code&gt; 助手。这是活动嵌套路线的渲染位置。</target>
        </trans-unit>
        <trans-unit id="84c592e4f2dcd576f7dfcf84d3f2fab2e7d1c377" translate="yes" xml:space="preserve">
          <source>Operations performed in initializers should be kept as lightweight as possible to minimize delays in loading your application. Although advanced techniques exist for allowing asynchrony in application initializers (i.e. &lt;code&gt;deferReadiness&lt;/code&gt; and &lt;code&gt;advanceReadiness&lt;/code&gt;), these techniques should generally be avoided. Any asynchronous loading conditions (e.g. user authorization) are almost always better handled in your application route's hooks, which allows for DOM interaction while waiting for conditions to resolve.</source>
          <target state="translated">在初始化程序中执行的操作应尽可能轻巧，以最大程度减少加载应用程序的延迟。尽管存在允许应用程序初始化程序中异步的高级技术（即 &lt;code&gt;deferReadiness&lt;/code&gt; 和 &lt;code&gt;advanceReadiness&lt;/code&gt; ），但通常应避免使用这些技术。几乎总是可以在应用程序路由的挂钩中更好地处理任何异步加载条件（例如，用户授权），这允许在等待条件解决的同时进行DOM交互。</target>
        </trans-unit>
        <trans-unit id="245a923eb00420b9baa12f359835e88308f803dd" translate="yes" xml:space="preserve">
          <source>Opting into a full transition</source>
          <target state="translated">选择全面过渡</target>
        </trans-unit>
        <trans-unit id="1c49b1643c903074dd04faa3ee683900d824639b" translate="yes" xml:space="preserve">
          <source>Optional Features</source>
          <target state="translated">可选功能</target>
        </trans-unit>
        <trans-unit id="878e1e97652f92b3656ef534228d846d629e2052" translate="yes" xml:space="preserve">
          <source>Optional addons for Neovim's Ember Language Server:</source>
          <target state="translated">Neovim的Ember语言服务器的可选附加组件。</target>
        </trans-unit>
        <trans-unit id="66b8b140d34ca56fe840cbf56dad53e263eb6056" translate="yes" xml:space="preserve">
          <source>Optional arguments to be passed to the queued method.</source>
          <target state="translated">要传递给排队方法的可选参数。</target>
        </trans-unit>
        <trans-unit id="7174acae61247527fa92ec0872c03eec9cf98de5" translate="yes" xml:space="preserve">
          <source>Optional arguments to pass on</source>
          <target state="translated">可选参数的传递</target>
        </trans-unit>
        <trans-unit id="f4fa0c5292f62f88297e792835dcb8ffe325cd65" translate="yes" xml:space="preserve">
          <source>Optional arguments to pass to the timeout.</source>
          <target state="translated">传递给超时的可选参数。</target>
        </trans-unit>
        <trans-unit id="a00dbf5de4ed7db7948c3423669d8aeb01e9edd2" translate="yes" xml:space="preserve">
          <source>Optional array of actions (listeners).</source>
          <target state="translated">可选的行动数组(监听者)。</target>
        </trans-unit>
        <trans-unit id="1fddf763cfe0151919fd12f5694dc361ffe0744c" translate="yes" xml:space="preserve">
          <source>Optional array of objects to insert or null if no objects.</source>
          <target state="translated">可选的插入对象数组,如果没有对象则为空。</target>
        </trans-unit>
        <trans-unit id="a7f4c5eb44535d1e4f3e27873e7fffaf8af0087e" translate="yes" xml:space="preserve">
          <source>Optional array of parameters to interpolate into string.</source>
          <target state="translated">可选的参数数组,用于插值到字符串中。</target>
        </trans-unit>
        <trans-unit id="ff1789bb5d4aa8d68c7ab51838333480e8e224d2" translate="yes" xml:space="preserve">
          <source>Optional dependent keys that trigger this computed property.</source>
          <target state="translated">触发该计算属性的可选从属键。</target>
        </trans-unit>
        <trans-unit id="8ce8b2338198547d4dbc4f7c5014302632a59a0d" translate="yes" xml:space="preserve">
          <source>Optional features in Octane</source>
          <target state="translated">Octane的可选功能</target>
        </trans-unit>
        <trans-unit id="6c4f35334f92330cec8db7b3c2ec6ce4d524729c" translate="yes" xml:space="preserve">
          <source>Optional hash of configuration options including `willChange` and `didChange` option.</source>
          <target state="translated">可选的配置选项哈希,包括 &quot;willChange &quot;和 &quot;didChange &quot;选项。</target>
        </trans-unit>
        <trans-unit id="2f6b7a5c6a5652ddfb412d45674a61749417b985" translate="yes" xml:space="preserve">
          <source>Optional meta to lookup listeners</source>
          <target state="translated">可选的元数据来查找监听者</target>
        </trans-unit>
        <trans-unit id="844e0186eb00638ab699a19704bf6b6030a59426" translate="yes" xml:space="preserve">
          <source>Optional parameters for each listener.</source>
          <target state="translated">每个监听器的可选参数。</target>
        </trans-unit>
        <trans-unit id="6f066f2da230be0f98eac3487bbb5312285fcf7e" translate="yes" xml:space="preserve">
          <source>Optionally supply a model for the route in question. The model will be serialized into the URL using the &lt;code&gt;serialize&lt;/code&gt; hook of the route:</source>
          <target state="translated">（可选）为相关路线提供模型。该模型将使用路线的 &lt;code&gt;serialize&lt;/code&gt; 挂钩被序列化为URL ：</target>
        </trans-unit>
        <trans-unit id="4afb26fd74d5f6e8ea7cbf72fa7921df56de5e90" translate="yes" xml:space="preserve">
          <source>Optionally you can pass a type which unload all records for a given type.</source>
          <target state="translated">你也可以通过一个类型来卸载给定类型的所有记录。</target>
        </trans-unit>
        <trans-unit id="d707d47d0d151fe2e1d8731df65d7ece3ccb76af" translate="yes" xml:space="preserve">
          <source>Optionally, a model type used to determine which serializer will be used</source>
          <target state="translated">可选地,用于确定将使用哪个序列器的模型类型。</target>
        </trans-unit>
        <trans-unit id="136ae3638c2d9288aced04a9905490f376059e3b" translate="yes" xml:space="preserve">
          <source>Optionally, if &lt;code&gt;adapter.shouldBackgroundReloadAll&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;, then a background reload is started. Once this resolves, the array with which the promise resolves, is updated automatically so it contains all the records in the store:</source>
          <target state="translated">（可选）如果 &lt;code&gt;adapter.shouldBackgroundReloadAll&lt;/code&gt; 评估为 &lt;code&gt;true&lt;/code&gt; ，则将启动后台重新加载。解决此问题后，promise解决的数组将自动更新，因此包含存储中的所有记录：</target>
        </trans-unit>
        <trans-unit id="f76ca3aa52e342e9e499538412c709f9fc9c6c82" translate="yes" xml:space="preserve">
          <source>Optionally, if &lt;code&gt;adapter.shouldBackgroundReloadRecord&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;, then a background reload is started, which updates the records' data, once it is available:</source>
          <target state="translated">（可选）如果 &lt;code&gt;adapter.shouldBackgroundReloadRecord&lt;/code&gt; 的计算结果为 &lt;code&gt;true&lt;/code&gt; ，则将启动后台重载，一旦可用，该后台重载将更新记录的数据：</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="056a298f55d85765827346a51abdb7d167ab8056" translate="yes" xml:space="preserve">
          <source>Options for `Ember.deprecate`.</source>
          <target state="translated">`Ember.deprecate'的选项:</target>
        </trans-unit>
        <trans-unit id="56daff5148c17e197dc8b310ce65f94faf88f205" translate="yes" xml:space="preserve">
          <source>Options for `deprecate`.</source>
          <target state="translated">`deprecate'的选项:</target>
        </trans-unit>
        <trans-unit id="da90baa9e342d697ce99637be813aa29582aef4f" translate="yes" xml:space="preserve">
          <source>Or an inline &lt;code&gt;hash&lt;/code&gt;, and you can even pass components:</source>
          <target state="translated">或内联 &lt;code&gt;hash&lt;/code&gt; ，甚至可以传递组件：</target>
        </trans-unit>
        <trans-unit id="009e8dbddb1a9a2e364046dc2b7da46c91d93f02" translate="yes" xml:space="preserve">
          <source>Or by using a helper in the template:</source>
          <target state="translated">或者通过使用模板中的助手。</target>
        </trans-unit>
        <trans-unit id="a6e1814cb1ede5b914af8ed5b9da5330939a141d" translate="yes" xml:space="preserve">
          <source>Or equivalently, &lt;code&gt;{{person/short-profile}}&lt;/code&gt;:</source>
          <target state="translated">或等效地， &lt;code&gt;{{person/short-profile}}&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d84522ef4b97044a7b5036fbf48e647677689781" translate="yes" xml:space="preserve">
          <source>Or if you pass it an array with names it returns the parameters as a hash:</source>
          <target state="translated">或者如果你传给它一个带名字的数组,它就会以哈希的形式返回参数。</target>
        </trans-unit>
        <trans-unit id="37cdfe0b0058fe4edf3c475c18fb07ae927c2616" translate="yes" xml:space="preserve">
          <source>Or on a hasMany relationship:</source>
          <target state="translated">或在有多关系。</target>
        </trans-unit>
        <trans-unit id="64e13784e0e5fc4499c58a28e19a3b279f630bc2" translate="yes" xml:space="preserve">
          <source>Or perhaps you might want to boot two instances of your app on the same page for a split-screen multiplayer experience:</source>
          <target state="translated">或者你可能想在同一个页面上启动两个应用实例,以获得分屏多人游戏体验。</target>
        </trans-unit>
        <trans-unit id="50016e626900570663ecf9226b2c2f188c840413" translate="yes" xml:space="preserve">
          <source>Or, assign an action to an inline event handler in the template (which creates a closure action and does receive the event object as an argument).</source>
          <target state="translated">或者,将一个动作分配给模板中的一个内联事件处理程序(该处理程序创建了一个关闭动作,并且确实接收了事件对象作为参数)。</target>
        </trans-unit>
        <trans-unit id="852f185db9f10db5ab3f8319e0a877a87def8abb" translate="yes" xml:space="preserve">
          <source>Orca, available for integration in Ubuntu, otherwise available as a download</source>
          <target state="translated">Orca,可以集成到Ubuntu中,也可以下载。</target>
        </trans-unit>
        <trans-unit id="a4cc74f7b298a6159af4768c4304193189c80184" translate="yes" xml:space="preserve">
          <source>Order of Lifecycle Hooks Called</source>
          <target state="translated">生命周期挂钩的顺序称为</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="519255ae1f74ffc5ddd29979295c7572f048ad81" translate="yes" xml:space="preserve">
          <source>Organization</source>
          <target state="translated">Organization</target>
        </trans-unit>
        <trans-unit id="f6011263f2c8df7e6d5838c01886ff0ab127d426" translate="yes" xml:space="preserve">
          <source>Organize records into groups, each of which is to be passed to separate calls to &lt;code&gt;findMany&lt;/code&gt;.</source>
          <target state="translated">将记录组织成组，每个组将传递给单独的 &lt;code&gt;findMany&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="5c2df0e1900518adaa51b92719f7b922310675ba" translate="yes" xml:space="preserve">
          <source>Other Assets</source>
          <target state="translated">其他资产</target>
        </trans-unit>
        <trans-unit id="050073d537a7166c91b8fc6249ae7d68937485e8" translate="yes" xml:space="preserve">
          <source>Other Ember-specific addons for data loading. Search for them on &lt;a href=&quot;https://emberobserver.com&quot;&gt;Ember Observer&lt;/a&gt;</source>
          <target state="translated">其他用于数据加载的特定于Ember的插件。在&lt;a href=&quot;https://emberobserver.com&quot;&gt;Ember Observer&lt;/a&gt;上搜索它们</target>
        </trans-unit>
        <trans-unit id="2cebb63339c152392cb23339f7e974429533abe9" translate="yes" xml:space="preserve">
          <source>Other HTML Attributes</source>
          <target state="translated">其他HTML属性</target>
        </trans-unit>
        <trans-unit id="a18cb54e465ff4fb1bb3202ed20081c8f7fe153e" translate="yes" xml:space="preserve">
          <source>Other Useful Articles</source>
          <target state="translated">其他有用的文章</target>
        </trans-unit>
        <trans-unit id="d3a5d50dac3d2fd3be1db7f31ed808c7f8a1ff9f" translate="yes" xml:space="preserve">
          <source>Other assets</source>
          <target state="translated">其他资产</target>
        </trans-unit>
        <trans-unit id="be657d8c6d64e6d3d350289bde7b2fdefa384a70" translate="yes" xml:space="preserve">
          <source>Other decorators exist, including &lt;code&gt;@tracked&lt;/code&gt; which will be discussed later on, and the &lt;code&gt;@action&lt;/code&gt; decorator. The &lt;code&gt;@action&lt;/code&gt; decorator replaces the &lt;code&gt;actions&lt;/code&gt; hash on routes, controllers, and components:</source>
          <target state="translated">存在其他装饰器，包括 &lt;code&gt;@tracked&lt;/code&gt; 将讨论的 &lt;code&gt;@action&lt;/code&gt; 和@action装饰器。该 &lt;code&gt;@action&lt;/code&gt; 装饰取代了 &lt;code&gt;actions&lt;/code&gt; 哈希航线上，控制器和组件：</target>
        </trans-unit>
        <trans-unit id="e4dafe89467b908579e92440e9dade6a6a530c6d" translate="yes" xml:space="preserve">
          <source>Other than that, fields can generally safely replace properties.</source>
          <target state="translated">除此之外,字段一般可以安全地替换属性。</target>
        </trans-unit>
        <trans-unit id="72938e69e43228a9d4d754a44650fe08dcd71b15" translate="yes" xml:space="preserve">
          <source>Other than that, go to town!</source>
          <target state="translated">除此以外,去镇上吧!</target>
        </trans-unit>
        <trans-unit id="05b2c2f5c7ef214490e816d188da36da6aead3a8" translate="yes" xml:space="preserve">
          <source>Other than these two restrictions, Ember Data's normalized JSON object follows the &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt; specification.</source>
          <target state="translated">除了这两个限制外，Ember Data的规范化JSON对象遵循&lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt;规范。</target>
        </trans-unit>
        <trans-unit id="d677034ba96b86d96a07c3b5f23a48edcbc95ef6" translate="yes" xml:space="preserve">
          <source>Other than these two restrictions, Ember Data's normalized JSON object follows the &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON:API&lt;/a&gt; specification.</source>
          <target state="translated">除了这两个限制，Ember Data的规范化JSON对象遵循&lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON：API&lt;/a&gt;规范。</target>
        </trans-unit>
        <trans-unit id="2d1570f0454b1699f4dd4b984290a82643a03560" translate="yes" xml:space="preserve">
          <source>Otherwise, when using native class syntax, native class rules and behaviors apply, and when using classic class syntax, classic class rules apply.</source>
          <target state="translated">否则,当使用原生类语法时,适用原生类规则和行为,当使用经典类语法时,适用经典类规则。</target>
        </trans-unit>
        <trans-unit id="0a59ae439add2f420237329f253278208031489d" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;filterByCity&lt;/code&gt; function is going to pretend to be the action function for our component, that does the actual filtering of the rental list.</source>
          <target state="translated">我们的 &lt;code&gt;filterByCity&lt;/code&gt; 函数将假装为组件的action函数，该函数对租赁列表进行实际过滤。</target>
        </trans-unit>
        <trans-unit id="1d2352d7289d1df632f9cdd6e7d02d2ec6a168ab" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;rentals&lt;/code&gt; route is going to serve multiple functions. From our &lt;a href=&quot;../acceptance-test&quot;&gt;acceptance tests&lt;/a&gt;, we've shown that we want our users to be able to browse and search rentals, as well as see detailed information for individual rentals. To satisfy that requirement, we are going to make use of Ember's &lt;a href=&quot;https://guides.emberjs.com/routing/defining-your-routes/#toc_nested-routes&quot;&gt;nested route capability&lt;/a&gt;.</source>
          <target state="translated">我们的 &lt;code&gt;rentals&lt;/code&gt; 路线将具有多种功能。通过&lt;a href=&quot;../acceptance-test&quot;&gt;验收测试&lt;/a&gt;，我们已经表明我们希望用户能够浏览和搜索租金，以及查看各个租金的详细信息。为了满足该要求，我们将使用Ember的&lt;a href=&quot;https://guides.emberjs.com/routing/defining-your-routes/#toc_nested-routes&quot;&gt;嵌套路由功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ceabe1dbf5cc8df0bb7eda712f95c063f04ae06b" translate="yes" xml:space="preserve">
          <source>Our app needs a single function, &lt;code&gt;createMap&lt;/code&gt;, which makes use of &lt;code&gt;google.maps.Map&lt;/code&gt; to create our map element, &lt;code&gt;google.maps.Geocoder&lt;/code&gt; to lookup the coordinates of our location, and &lt;code&gt;google.maps.Marker&lt;/code&gt; to pin our map based on the resolved location.</source>
          <target state="translated">我们的应用程序需要一个函数 &lt;code&gt;createMap&lt;/code&gt; ，该函数使用 &lt;code&gt;google.maps.Map&lt;/code&gt; 创建我们的地图元素，使用 &lt;code&gt;google.maps.Geocoder&lt;/code&gt; 查找我们位置的坐标，并使用 &lt;code&gt;google.maps.Marker&lt;/code&gt; 来基于地图固定地图已解决的位置。</target>
        </trans-unit>
        <trans-unit id="e07b0dd7549ed8c27ea39867fe2f2d1988667c3e" translate="yes" xml:space="preserve">
          <source>Our app should behave now as before, with the addition of an image for each rental item.</source>
          <target state="translated">我们的应用程序现在应该像以前一样,为每个租赁项目添加一个图像。</target>
        </trans-unit>
        <trans-unit id="6a20c7d31e256f685e6854e8af9656af5d1a7698" translate="yes" xml:space="preserve">
          <source>Our component integration test will test two different behaviors:</source>
          <target state="translated">我们的组件集成测试将测试两种不同的行为。</target>
        </trans-unit>
        <trans-unit id="bc927403c3f4e27e29509ea224d204579314bd1e" translate="yes" xml:space="preserve">
          <source>Our component is called &lt;code&gt;&amp;lt;PeopleList&amp;gt;&lt;/code&gt;, based on its name on the file system. Please note that the letters P and L are capitalized.</source>
          <target state="translated">根据其在文件系统上的名称，我们的组件称为 &lt;code&gt;&amp;lt;PeopleList&amp;gt;&lt;/code&gt; 。请注意，字母P和L大写。</target>
        </trans-unit>
        <trans-unit id="aac6bcc3102b1ecd24b4fb91e8b2669dc6aa577c" translate="yes" xml:space="preserve">
          <source>Our counter has two different actions, &lt;code&gt;increment&lt;/code&gt; and &lt;code&gt;decrement&lt;/code&gt;. But both actions are mostly doing the same thing. The only difference is that &lt;code&gt;increment&lt;/code&gt; changes the count by &lt;code&gt;+1&lt;/code&gt;, while &lt;code&gt;decrement&lt;/code&gt; changes it by &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">我们的计数器有两个不同的动作， &lt;code&gt;increment&lt;/code&gt; 和 &lt;code&gt;decrement&lt;/code&gt; 。但是这两种动作大多在做同一件事。唯一的区别是， &lt;code&gt;increment&lt;/code&gt; 会将计数更改 &lt;code&gt;+1&lt;/code&gt; ，而 &lt;code&gt;decrement&lt;/code&gt; 会将计数更改 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cae96a04e9b7056dc33933f973849aed2afc24ae" translate="yes" xml:space="preserve">
          <source>Our goal is to help you avoid that mess and come up to speed as fast as possible; you can consider us your internet friend.</source>
          <target state="translated">我们的目标是帮助您避免这种混乱,并尽快上手;您可以把我们当作您的互联网朋友。</target>
        </trans-unit>
        <trans-unit id="939816c45abd273d6565fd8a68842401b6e05c49" translate="yes" xml:space="preserve">
          <source>Our launched Chrome web browser now shows 10 successful tests. If you toggle the box labeled &quot;Hide passed tests&quot;, you should see our successful acceptance test, along with 9 passing ESLint tests. Ember tests each file you create for syntax issues (known as &quot;linting&quot;) using &lt;a href=&quot;http://eslint.org/&quot;&gt;ESLint&lt;/a&gt;.</source>
          <target state="translated">我们推出的Chrome网络浏览器现在显示了10个成功的测试。如果您选中标有&amp;ldquo;隐藏通过的测试&amp;rdquo;的框，则应该会看到我们成功的验收测试以及9个通过ESLint的测试。Ember使用&lt;a href=&quot;http://eslint.org/&quot;&gt;ESLint&lt;/a&gt;测试您创建的每个文件是否存在语法问题（称为&amp;ldquo; 掉毛 &amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="bb08f510a40d4531dddec319cee316e84226d5d3" translate="yes" xml:space="preserve">
          <source>Our list-filter component takes a function as an argument, used to find the list of matching rentals based on the filter string provided by the user. We provide an action function by setting it to the local scope of our test by calling &lt;code&gt;this.on&lt;/code&gt;.</source>
          <target state="translated">我们的列表过滤器组件以函数作为参数，用于根据用户提供的过滤器字符串查找匹配的租赁列表。我们通过调用 &lt;code&gt;this.on&lt;/code&gt; 将动作函数设置为测试的本地范围来提供它。</target>
        </trans-unit>
        <trans-unit id="b06b1f865cc2e950e72d8ef25f106bf2e0d12435" translate="yes" xml:space="preserve">
          <source>Our new &lt;code&gt;rental-listing&lt;/code&gt; component will manage how a user sees and interacts with a rental. To start, let's move the rental display details for a single rental from the &lt;code&gt;rentals.hbs&lt;/code&gt; template into &lt;code&gt;rental-listing.hbs&lt;/code&gt; and add the image field:</source>
          <target state="translated">我们新的 &lt;code&gt;rental-listing&lt;/code&gt; 组件将管理用户如何查看租借并与之互动。首先，让我们将单个租赁的租赁显示详细信息从 &lt;code&gt;rentals.hbs&lt;/code&gt; 模板移至 &lt;code&gt;rental-listing.hbs&lt;/code&gt; 并添加图像字段：</target>
        </trans-unit>
        <trans-unit id="29373ffd294040aafa4cf834c59c8d7e6c803a1c" translate="yes" xml:space="preserve">
          <source>Our new helper starts out with some boilerplate code from the generator:</source>
          <target state="translated">我们的新助手从生成器的一些锅炉模板代码开始。</target>
        </trans-unit>
        <trans-unit id="a349524a1f4aadac769db82fd11c98cb24360fc6" translate="yes" xml:space="preserve">
          <source>Our new route is nested within our &lt;code&gt;rentals&lt;/code&gt; route. This tells Ember that it is a sub-route and will be accessed through &lt;code&gt;localhost:4200/rentals/show&lt;/code&gt;.</source>
          <target state="translated">我们的新路线嵌套在我们的 &lt;code&gt;rentals&lt;/code&gt; 路线中。这告诉Ember这是一条子路由，将通过 &lt;code&gt;localhost:4200/rentals/show&lt;/code&gt; 进行访问。</target>
        </trans-unit>
        <trans-unit id="4f76189ba851aa52d8190127cc50d8974b28cd36" translate="yes" xml:space="preserve">
          <source>Our primary focus with mirage will be in the &lt;code&gt;config.js&lt;/code&gt; file, which is where we can define our API endpoints and our data. We will be following the &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON-API specification&lt;/a&gt; which requires our data to be formatted a certain way. Let's configure Mirage to send back our rentals that we had defined above by updating &lt;code&gt;mirage/config.js&lt;/code&gt;:</source>
          <target state="translated">我们对 &lt;code&gt;config.js&lt;/code&gt; 主要关注将在config.js文件中，在该文件中我们可以定义API端点和数据。我们将遵循&lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON-API规范&lt;/a&gt;，该规范要求我们的数据以某种方式进行格式化。让我们将Mirage配置为通过更新Mirage &lt;code&gt;mirage/config.js&lt;/code&gt; 来发送上面定义的租金：</target>
        </trans-unit>
        <trans-unit id="1b24e7c85fa3198f703161c3ddef40fe3394011b" translate="yes" xml:space="preserve">
          <source>Our test fills out &quot;Seattle&quot; as the search criteria in the search field, and then sends a &lt;code&gt;keyup&lt;/code&gt; event to the same field with a code of &lt;code&gt;69&lt;/code&gt; (the &lt;code&gt;e&lt;/code&gt; key) to simulate a user typing.</source>
          <target state="translated">我们的测试在搜索字段中填写&amp;ldquo;西雅图&amp;rdquo;作为搜索条件，然后使用 &lt;code&gt;69&lt;/code&gt; （ &lt;code&gt;e&lt;/code&gt; 键）的代码将 &lt;code&gt;keyup&lt;/code&gt; 事件发送到同一字段，以模拟用户的输入。</target>
        </trans-unit>
        <trans-unit id="01bb65c5738545e59a2a76289dfe05d3a8130803" translate="yes" xml:space="preserve">
          <source>Out of the box, Ember provides 2 components for building a form:</source>
          <target state="translated">开箱即用,Ember提供了2个构建表单的组件。</target>
        </trans-unit>
        <trans-unit id="bea2ea8d295526b6de7ab08ba561f86c1192c9c8" translate="yes" xml:space="preserve">
          <source>Out-of-Component Modifications</source>
          <target state="translated">组件外的修改</target>
        </trans-unit>
        <trans-unit id="8169481c0bf47ccddb7f0929954e65aedb10ffd6" translate="yes" xml:space="preserve">
          <source>Outer HTML</source>
          <target state="translated">外部HTML</target>
        </trans-unit>
        <trans-unit id="78d0fbfeeac956fe03189a14212a32e505b7af40" translate="yes" xml:space="preserve">
          <source>Outputting their name and age.</source>
          <target state="translated">输出他们的姓名和年龄。</target>
        </trans-unit>
        <trans-unit id="7f785f12de428c659f4e7bcaf5ae3019791cd9ca" translate="yes" xml:space="preserve">
          <source>Outside of class definitions</source>
          <target state="translated">在类定义之外</target>
        </trans-unit>
        <trans-unit id="eafba9b212384c69a2a6dba1d05842ab6585a134" translate="yes" xml:space="preserve">
          <source>Over the past few years, many new features have been added to Ember with the goal of introducing a new programming model for the framework. This new model brings major gains in productivity and performance, incrementally via a series of minor (non-breaking) releases. This allows for new apps to have the best features enabled automatically, while teams working on existing apps can migrate over time, while still keeping their apps up-to-date with the latest release.</source>
          <target state="translated">在过去的几年里,Ember增加了许多新的功能,目标是为框架引入一种新的编程模式。这种新模式通过一系列次要的(非突破性的)发布,逐步带来生产力和性能的重大提升。这使得新的应用程序可以自动启用最好的功能,而在现有应用程序上工作的团队可以随着时间的推移而迁移,同时仍然保持他们的应用程序与最新版本保持一致。</target>
        </trans-unit>
        <trans-unit id="6448c99bf69eeb2ba6848557375b741d43c476bb" translate="yes" xml:space="preserve">
          <source>Override this function when writing a class-based helper.</source>
          <target state="translated">当编写一个基于类的帮助程序时,重写这个函数。</target>
        </trans-unit>
        <trans-unit id="e7118e866bd2fbc9b87fc7380712b78a5ce41ae2" translate="yes" xml:space="preserve">
          <source>Override this method with your testing framework's false assertion. This function is called whenever an exception occurs causing the testing promise to fail.</source>
          <target state="translated">用你的测试框架的错误断言覆盖这个方法。每当发生异常导致测试承诺失败时,就会调用这个函数。</target>
        </trans-unit>
        <trans-unit id="78724f610daa7d335490afd0afef134897e80478" translate="yes" xml:space="preserve">
          <source>Override this to call your framework's methods that handle async operations.</source>
          <target state="translated">重写这个来调用你的框架中处理异步操作的方法。</target>
        </trans-unit>
        <trans-unit id="6d464e9e96aeb92e00f8be7c60b6ca811e20cee2" translate="yes" xml:space="preserve">
          <source>Override to implement teardown.</source>
          <target state="translated">覆盖实现拆迁。</target>
        </trans-unit>
        <trans-unit id="72f33b6fd8ce9f99ebb8295cb19dd840fcca6242" translate="yes" xml:space="preserve">
          <source>Overrides &lt;code&gt;RegistryProxy#unregister&lt;/code&gt; in order to clear any cached instances of the unregistered factory.</source>
          <target state="translated">覆盖 &lt;code&gt;RegistryProxy#unregister&lt;/code&gt; ，以清除未注册工厂的所有缓存实例。</target>
        </trans-unit>
        <trans-unit id="e441b8e9bc7405861b187f25fbe7e852d75948a0" translate="yes" xml:space="preserve">
          <source>Overriding Application-wide Defaults</source>
          <target state="translated">覆盖应用程序范围的默认值</target>
        </trans-unit>
        <trans-unit id="fff1ab70d9215d47433358aa873ef34fdced6c34" translate="yes" xml:space="preserve">
          <source>Overriding Parent Class Methods</source>
          <target state="translated">覆盖父类方法</target>
        </trans-unit>
        <trans-unit id="bfaaaf32788c2fd06d3c8e0c98eb03bc280e18a2" translate="yes" xml:space="preserve">
          <source>Overriding attributes</source>
          <target state="translated">覆盖属性</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="9fbe29d4d76ec756421aee06e0f34f17fa488ff3" translate="yes" xml:space="preserve">
          <source>PATCH</source>
          <target state="translated">PATCH</target>
        </trans-unit>
        <trans-unit id="61ff81c30aa3c76e78afea62b2e3bd1dfa49e854" translate="yes" xml:space="preserve">
          <source>POST</source>
          <target state="translated">POST</target>
        </trans-unit>
        <trans-unit id="9290a0c61239f22dc109f2cd18743bbd807cdfac" translate="yes" xml:space="preserve">
          <source>Package @ember-data/adapter</source>
          <target state="translated">包@ember-data/adapter</target>
        </trans-unit>
        <trans-unit id="e48b0cb91fa97df93af72ee439134098689f0194" translate="yes" xml:space="preserve">
          <source>Package @ember-data/canary-features</source>
          <target state="translated">包 @ember-data/canary-features</target>
        </trans-unit>
        <trans-unit id="0df8a2ed461206098f5b4f4bb6b0b2f49d2c5424" translate="yes" xml:space="preserve">
          <source>Package @ember-data/debug</source>
          <target state="translated">包 @ember-data/debug</target>
        </trans-unit>
        <trans-unit id="9b7005ba2cff12f87eed22566914ec8bc55ebaf0" translate="yes" xml:space="preserve">
          <source>Package @ember-data/deprecations</source>
          <target state="translated">包@ember-data/deprecations</target>
        </trans-unit>
        <trans-unit id="003e7b5f1273dcc0898f2a9cd0b132fbd688696d" translate="yes" xml:space="preserve">
          <source>Package @ember-data/model</source>
          <target state="translated">包@ember-data/model</target>
        </trans-unit>
        <trans-unit id="47ad3c107b0e54a7ac1944c31fed17b5bb0710b2" translate="yes" xml:space="preserve">
          <source>Package @ember-data/record-data</source>
          <target state="translated">包 @ember-data/record-data</target>
        </trans-unit>
        <trans-unit id="0fd4f67405e1b8aaeb42c2b813a453272e96702d" translate="yes" xml:space="preserve">
          <source>Package @ember-data/serializer</source>
          <target state="translated">包 @ember-data/serializer</target>
        </trans-unit>
        <trans-unit id="b1428f30eaa099cc623d9e5875f2945adcbf8b3f" translate="yes" xml:space="preserve">
          <source>Package @ember-data/store</source>
          <target state="translated">包@ember-data/store</target>
        </trans-unit>
        <trans-unit id="5fc9be9110da4f7fb13626f72e62a26c36c3285a" translate="yes" xml:space="preserve">
          <source>Package @ember/application</source>
          <target state="translated">包@ember/应用</target>
        </trans-unit>
        <trans-unit id="734ddb7d2dec1da49f5a7fc4629acf3a0da89742" translate="yes" xml:space="preserve">
          <source>Package @ember/array</source>
          <target state="translated">包@ember/array</target>
        </trans-unit>
        <trans-unit id="b42065785fb6162ff0afee19170bdb1dd62e3f3e" translate="yes" xml:space="preserve">
          <source>Package @ember/canary-features</source>
          <target state="translated">包 @ember/canary-features</target>
        </trans-unit>
        <trans-unit id="d68e9ad98654a50df7ef78f05cf1891259317b6f" translate="yes" xml:space="preserve">
          <source>Package @ember/component</source>
          <target state="translated">包@ember/component</target>
        </trans-unit>
        <trans-unit id="5d695465b0e4cf906ffdacae17d59c894af69af4" translate="yes" xml:space="preserve">
          <source>Package @ember/component/template-only</source>
          <target state="translated">包@ember/component/template-only。</target>
        </trans-unit>
        <trans-unit id="a7efd390eff02546d1f737fae51a9b0fce7d5272" translate="yes" xml:space="preserve">
          <source>Package @ember/controller</source>
          <target state="translated">包@ember/controller</target>
        </trans-unit>
        <trans-unit id="2f1b639937499523a3c3c4afcd3c6b9aa0f47a5b" translate="yes" xml:space="preserve">
          <source>Package @ember/debug</source>
          <target state="translated">包 @ember/debug</target>
        </trans-unit>
        <trans-unit id="15b3cc89b5948c441515371238505ac6bdc640a2" translate="yes" xml:space="preserve">
          <source>Package @ember/destroyable</source>
          <target state="translated">包裹 @ember/estroyable</target>
        </trans-unit>
        <trans-unit id="288f71afaeef2694e4f64440becbe75db3414274" translate="yes" xml:space="preserve">
          <source>Package @ember/engine</source>
          <target state="translated">包@ember/engine</target>
        </trans-unit>
        <trans-unit id="22cdfc249e93751bc4e29af9207596016371912e" translate="yes" xml:space="preserve">
          <source>Package @ember/enumerable</source>
          <target state="translated">包@ember/enumerable</target>
        </trans-unit>
        <trans-unit id="91262918ea03b8ce2ce4191feee99570cfde1a47" translate="yes" xml:space="preserve">
          <source>Package @ember/error</source>
          <target state="translated">包@ember/error</target>
        </trans-unit>
        <trans-unit id="39640ebf9a47fcd005b23845b0a078c1994e86be" translate="yes" xml:space="preserve">
          <source>Package @ember/helper</source>
          <target state="translated">包@ember/helper</target>
        </trans-unit>
        <trans-unit id="cce16c7338b5d8b924f1cc6f3d1bbcd885119379" translate="yes" xml:space="preserve">
          <source>Package @ember/object</source>
          <target state="translated">包@ember/对象</target>
        </trans-unit>
        <trans-unit id="06e0c1a06b356a4bb4ea26a54c36bcd05dca95e6" translate="yes" xml:space="preserve">
          <source>Package @ember/polyfills</source>
          <target state="translated">包装@ember/polyfills</target>
        </trans-unit>
        <trans-unit id="b8957e0676c9cdd531464db23eece45a24eebf23" translate="yes" xml:space="preserve">
          <source>Package @ember/routing</source>
          <target state="translated">包@ember/routing</target>
        </trans-unit>
        <trans-unit id="2fac61a119c4b8c50423c769ea4f236d4573336b" translate="yes" xml:space="preserve">
          <source>Package @ember/runloop</source>
          <target state="translated">包@ember/runloop</target>
        </trans-unit>
        <trans-unit id="4b0836fca2e2abdb0c5955b1f8d2b052a49b9757" translate="yes" xml:space="preserve">
          <source>Package @ember/service</source>
          <target state="translated">包@ember/service</target>
        </trans-unit>
        <trans-unit id="167799b5dc9f55026cd1b693dbf9e2db4a456aab" translate="yes" xml:space="preserve">
          <source>Package @ember/string</source>
          <target state="translated">包@ember/string</target>
        </trans-unit>
        <trans-unit id="60870d470295461c33c93fcdaab465250cc3710c" translate="yes" xml:space="preserve">
          <source>Package @ember/template</source>
          <target state="translated">包@ember/template</target>
        </trans-unit>
        <trans-unit id="0527976ce9e613c1af2c657cfcd35ca62ed6e24a" translate="yes" xml:space="preserve">
          <source>Package @ember/test</source>
          <target state="translated">包@ember/test</target>
        </trans-unit>
        <trans-unit id="25f0d5bb78f64057f00284b3938d011e12e60d25" translate="yes" xml:space="preserve">
          <source>Package @ember/utils</source>
          <target state="translated">包@ember/utils</target>
        </trans-unit>
        <trans-unit id="5493c735a2970d00426d269a6a115776da490027" translate="yes" xml:space="preserve">
          <source>Package @glimmer/component</source>
          <target state="translated">包 @glimmer/component</target>
        </trans-unit>
        <trans-unit id="f9d00a0b930fb49d15a31cc517fd94f6342ceb3d" translate="yes" xml:space="preserve">
          <source>Package @glimmer/tracking</source>
          <target state="translated">包@glimmer/跟踪</target>
        </trans-unit>
        <trans-unit id="1f6cd1e1b9b2885f0f08a829e5728420fd9cdd78" translate="yes" xml:space="preserve">
          <source>Package ember</source>
          <target state="translated">包裹微光</target>
        </trans-unit>
        <trans-unit id="d1d327c69c7c0d03ff923e3dd13072724f7f2692" translate="yes" xml:space="preserve">
          <source>Package rsvp</source>
          <target state="translated">套餐预订</target>
        </trans-unit>
        <trans-unit id="c03c75ad187275e61e870b10c1663f828100a587" translate="yes" xml:space="preserve">
          <source>Page Template Considerations</source>
          <target state="translated">页面模板注意事项</target>
        </trans-unit>
        <trans-unit id="4aeab6c0b8647d5f1be2e4da4b067b9dd6c2ef73" translate="yes" xml:space="preserve">
          <source>Page Title</source>
          <target state="translated">网页标题</target>
        </trans-unit>
        <trans-unit id="8e19661733745ef4b2adef80a34cf5d1556477ae" translate="yes" xml:space="preserve">
          <source>Pagination is a common example of using metadata. Imagine a blog with far more posts than you can display at once. You might query it like so:</source>
          <target state="translated">分页是使用元数据的一个常见例子。想象一下,一个博客的文章数量远远超过了你可以同时显示的数量。你可以这样查询。</target>
        </trans-unit>
        <trans-unit id="758bd025ac3588ef2bf1ea78e2ec92a078d36580" translate="yes" xml:space="preserve">
          <source>Parent components can pass actions to child components through templates alone without adding JavaScript code to those child components.</source>
          <target state="translated">父组件可以单独通过模板将动作传递给子组件,而无需向这些子组件添加JavaScript代码。</target>
        </trans-unit>
        <trans-unit id="53b2b4d9664c2f7ba6c736b20cc936678a185b0b" translate="yes" xml:space="preserve">
          <source>Parent:&lt;a href=&quot;ember&quot;&gt;ember&lt;/a&gt;</source>
          <target state="translated">Parent:&lt;a href=&quot;ember&quot;&gt;ember&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e82d2ab7546c96cb9a5574e03456855e889721d" translate="yes" xml:space="preserve">
          <source>Part of what makes components so useful is that they let you take complete control of a section of the DOM. This allows for direct DOM manipulation, listening and responding to browser events, and using 3rd party JavaScript libraries in your Ember app.</source>
          <target state="translated">组件如此有用的部分原因是它们让你完全控制DOM的一部分。这允许直接操作DOM,监听和响应浏览器事件,并在你的Ember应用中使用第三方JavaScript库。</target>
        </trans-unit>
        <trans-unit id="6d4b8ab5dc9107f2d41ceec11911caf0fa5785aa" translate="yes" xml:space="preserve">
          <source>Pass a function that is costly to compute to &lt;code&gt;createCache&lt;/code&gt;.</source>
          <target state="translated">将一个计算成本 &lt;code&gt;createCache&lt;/code&gt; 的函数传递给createCache。</target>
        </trans-unit>
        <trans-unit id="cd0f0c84bbea848ebc99a6d8b09e02c0b6c2687a" translate="yes" xml:space="preserve">
          <source>Passing Actions With Angle Bracket Invocation</source>
          <target state="translated">通过角括号调用传递动作。</target>
        </trans-unit>
        <trans-unit id="1fd681d8590147352e763485982ff52042383b47" translate="yes" xml:space="preserve">
          <source>Passing Arguments</source>
          <target state="translated">传递参数</target>
        </trans-unit>
        <trans-unit id="e653b24bf9e209d80df6a1f3355da460f12ffc78" translate="yes" xml:space="preserve">
          <source>Passing Arguments to Actions</source>
          <target state="translated">将参数传递给动作</target>
        </trans-unit>
        <trans-unit id="1e7148ce0c1621aba30d240c1c19ad8aaf313466" translate="yes" xml:space="preserve">
          <source>Passing Properties to a Component</source>
          <target state="translated">将属性传递给一个组件</target>
        </trans-unit>
        <trans-unit id="3da03a376688d5fb14e52c7f63a1a27343631407" translate="yes" xml:space="preserve">
          <source>Passing arguments</source>
          <target state="translated">传递参数</target>
        </trans-unit>
        <trans-unit id="5d1352dd442d4cfba0e5fd622749a8a67bb427c2" translate="yes" xml:space="preserve">
          <source>Passing classes to an invocation (i.e. &lt;code&gt;{{my-component class=&quot;...&quot;}}&lt;/code&gt;) will no longer result in those classes being present on any element. This could be a change in behavior which impacts any reflected attribute passed as an argument, such as &lt;code&gt;id=&lt;/code&gt; or &lt;code&gt;tagName=&lt;/code&gt;.</source>
          <target state="translated">将类传递给调用（即 &lt;code&gt;{{my-component class=&quot;...&quot;}}&lt;/code&gt; ）将不再导致这些类出现在任何元素上。这可能是行为上的变化，它会影响作为参数传递的任何反射属性，例如 &lt;code&gt;id=&lt;/code&gt; 或 &lt;code&gt;tagName=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7b6892060d3ef827e6332e1ab8d7813ce2e7481" translate="yes" xml:space="preserve">
          <source>Passing functions with the action helper</source>
          <target state="translated">用动作助手传递函数</target>
        </trans-unit>
        <trans-unit id="1f6f9f64dca762b74228ae921a682024bab888c8" translate="yes" xml:space="preserve">
          <source>Passing multiple blocks</source>
          <target state="translated">传递多个区块</target>
        </trans-unit>
        <trans-unit id="974e5a0b0533d8543bc9f8c28e441ee3eaff1431" translate="yes" xml:space="preserve">
          <source>Passing parameters to blocks</source>
          <target state="translated">向块传递参数</target>
        </trans-unit>
        <trans-unit id="84eae16350232d0e4ebbc64979eac30603537f4e" translate="yes" xml:space="preserve">
          <source>Passing parameters to named bxlocks</source>
          <target state="translated">向命名的bxlocks传递参数</target>
        </trans-unit>
        <trans-unit id="8b910b718628891639ad10590baddf47ec63bfe2" translate="yes" xml:space="preserve">
          <source>Passing the Action to the Component</source>
          <target state="translated">将动作传递给组件</target>
        </trans-unit>
        <trans-unit id="3ae4de702d5188523f33d4b5bc1b974cacf49f52" translate="yes" xml:space="preserve">
          <source>Passing three arguments:</source>
          <target state="translated">传递三个参数。</target>
        </trans-unit>
        <trans-unit id="27ba0b50b608b03349c7157edc6ddef068a469a8" translate="yes" xml:space="preserve">
          <source>Passing two arguments:</source>
          <target state="translated">传递两个参数。</target>
        </trans-unit>
        <trans-unit id="bc9542bcb8c51a85721c7d88e5203af136f9bb1f" translate="yes" xml:space="preserve">
          <source>Path Customization</source>
          <target state="translated">路径定制</target>
        </trans-unit>
        <trans-unit id="356cd3bf86420c7cad5947142df308e6e29392c9" translate="yes" xml:space="preserve">
          <source>Pathname customization</source>
          <target state="translated">自定义路径名</target>
        </trans-unit>
        <trans-unit id="acf84c0cf396ae71011ae919f3466523baa1c7b1" translate="yes" xml:space="preserve">
          <source>Patterns for Actions</source>
          <target state="translated">行动模式</target>
        </trans-unit>
        <trans-unit id="e703641d8deb06b53efdd58ac5208df544778810" translate="yes" xml:space="preserve">
          <source>Patterns for Components</source>
          <target state="translated">组件的模式</target>
        </trans-unit>
        <trans-unit id="4d370c50b556b5821596079c3ed48ddf2fbe93ad" translate="yes" xml:space="preserve">
          <source>Pauses the current test - this is useful for debugging while testing or for test-driving. It allows you to inspect the state of your application at any point. Example (The test will pause before clicking the button):</source>
          <target state="translated">暂停当前的测试--这对测试时的调试或测试驱动很有用。它允许你在任何时候检查你的应用程序的状态。例如(在点击按钮之前,测试将暂停)。</target>
        </trans-unit>
        <trans-unit id="61b6cd1258641f0b4de19e16db4a9ed827fe2c16" translate="yes" xml:space="preserve">
          <source>Percy</source>
          <target state="translated">Percy</target>
        </trans-unit>
        <trans-unit id="4946af784e3408745353f1accc2c18f8c0f6d02d" translate="yes" xml:space="preserve">
          <source>Perform a synchronous transition into another route without attempting to resolve promises, update the URL, or abort any currently active asynchronous transitions (i.e. regular transitions caused by &lt;code&gt;transitionTo&lt;/code&gt; or URL changes).</source>
          <target state="translated">在不尝试解析承诺，更新URL或中止任何当前活动的异步过渡（即由 &lt;code&gt;transitionTo&lt;/code&gt; 或URL更改引起的常规过渡）的情况下，执行到另一个路由的同步过渡。</target>
        </trans-unit>
        <trans-unit id="f66eb1046fbcbd1e99aff53dcfd1c6c3e96fed3d" translate="yes" xml:space="preserve">
          <source>Performance can be a concern with fields, since they eagerly create new values for &lt;em&gt;every&lt;/em&gt; instance of the component. This is generally not a problem, but is something to be aware of.</source>
          <target state="translated">对于字段，性能可能是一个问题，因为它们会为组件的&lt;em&gt;每个&lt;/em&gt;实例创建新的值。这通常不是问题，但需要注意。</target>
        </trans-unit>
        <trans-unit id="c97446af9643bcb61ef246b84f5ae53f1e5a2243" translate="yes" xml:space="preserve">
          <source>Perhaps the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; itself was the target of styles (e.g. &lt;code&gt;body &amp;gt; div &amp;gt; .some-child&lt;/code&gt;).</source>
          <target state="translated">也许 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 本身就是样式的目标（例如 &lt;code&gt;body &amp;gt; div &amp;gt; .some-child&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="55048dbb27d1bf87f25ec1c140008767e958cd27" translate="yes" xml:space="preserve">
          <source>Perhaps the application relied on the root &lt;code&gt;.ember-view&lt;/code&gt; for styles (CSS).</source>
          <target state="translated">也许应用程序依赖于样式的根 &lt;code&gt;.ember-view&lt;/code&gt; （CSS）。</target>
        </trans-unit>
        <trans-unit id="f12c5f85d68b2c1cf86b757e8d7188dc87be03b5" translate="yes" xml:space="preserve">
          <source>Persisting Records</source>
          <target state="translated">持续记录</target>
        </trans-unit>
        <trans-unit id="7681a0376373e3089f3cc1d9cb621f731b425cd6" translate="yes" xml:space="preserve">
          <source>Picking different components to render in response to the data allows you to have different template and behavior for each case. The &lt;code&gt;{{component}}&lt;/code&gt; helper is a powerful tool for improving code modularity.</source>
          <target state="translated">选择不同的组件以响应数据进行渲染，使您可以针对每种情况使用不同的模板和行为。该 &lt;code&gt;{{component}}&lt;/code&gt; 帮手是提高代码的模块化的强大工具。</target>
        </trans-unit>
        <trans-unit id="53a53cee8d77f69a554611c87983d1a34a9295ae" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;...attributes&lt;/code&gt;&lt;strong&gt;before&lt;/strong&gt; your attributes only if you want to disallow tags from overriding your attributes. This is likely to be unusual.</source>
          <target state="translated">仅当您要禁止标记覆盖属性时，才将 &lt;code&gt;...attributes&lt;/code&gt; 置于属性&lt;strong&gt;之前&lt;/strong&gt;。这很可能是不寻常的。</target>
        </trans-unit>
        <trans-unit id="9f5cbf3b9054a982345706be838f8ffee79e5683" translate="yes" xml:space="preserve">
          <source>Plain Old JavaScript Objects (POJOs)</source>
          <target state="translated">普通的老式JavaScript对象(POJOs)</target>
        </trans-unit>
        <trans-unit id="fdc10446ecd38ca13652c931db183d1cff77fdfe" translate="yes" xml:space="preserve">
          <source>Plain Properties</source>
          <target state="translated">平原地产</target>
        </trans-unit>
        <trans-unit id="e1a35f314bf2633bdff792cb61a30fd24db73276" translate="yes" xml:space="preserve">
          <source>Planning Your App</source>
          <target state="translated">规划您的应用程序</target>
        </trans-unit>
        <trans-unit id="0a8d7e61a508ccfa82dd401015443674854d4316" translate="yes" xml:space="preserve">
          <source>Please note that jQuery integration is off by default and this feature will not work properly. To enable this feature, you can read the instructions in the &lt;a href=&quot;https://guides.emberjs.com/release/configuring-ember/optional-features/#toc_jquery-integration&quot;&gt;jquery-integration optional feature guide&lt;/a&gt;.</source>
          <target state="translated">请注意，jQuery集成默认情况下处于关闭状态，此功能将无法正常使用。要启用此功能，您可以阅读&lt;a href=&quot;https://guides.emberjs.com/release/configuring-ember/optional-features/#toc_jquery-integration&quot;&gt;jquery-integration可选功能指南中的说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="10ab891c24a563405b3a70b1ca34ebe464adb253" translate="yes" xml:space="preserve">
          <source>Please note: This is not for normal usage, and should be used sparingly.</source>
          <target state="translated">请注意:这不是正常使用,应尽量少用。</target>
        </trans-unit>
        <trans-unit id="651987c8f13c93d564a719b93607cd420d73a63f" translate="yes" xml:space="preserve">
          <source>Please note: any property changes made during this event will have no effect on object observers.</source>
          <target state="translated">请注意:在此活动期间所做的任何属性更改都不会对对象观察者产生影响。</target>
        </trans-unit>
        <trans-unit id="0f86931da96969bb0d673e6eb85b8c9d2da0aefa" translate="yes" xml:space="preserve">
          <source>Please see the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#if&quot;&gt;API documentation of the &lt;code&gt;if&lt;/code&gt; helper&lt;/a&gt; for more patterns.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt;帮助程序的API文档以获取更多模式。</target>
        </trans-unit>
        <trans-unit id="97a8fb33f7301b7d070bb6b9b6f5697d38d45f2d" translate="yes" xml:space="preserve">
          <source>Pluralization Customization</source>
          <target state="translated">多元化定制</target>
        </trans-unit>
        <trans-unit id="861260cecd797e42301015d1972945d6ccce6883" translate="yes" xml:space="preserve">
          <source>Polyfill</source>
          <target state="translated">Polyfill</target>
        </trans-unit>
        <trans-unit id="989fc91d044783d05d714e433d3e90dca9bdf4da" translate="yes" xml:space="preserve">
          <source>Polymorphism</source>
          <target state="translated">Polymorphism</target>
        </trans-unit>
        <trans-unit id="b60b227dfc72ce2592d5e011bdf46ba68f6f3eeb" translate="yes" xml:space="preserve">
          <source>Polymorphism is a powerful concept which allows a developer to abstract common functionality into a base class. Consider the following example: a user with multiple payment methods. They could have a linked PayPal account, and a couple credit cards on file.</source>
          <target state="translated">多态是一个强大的概念,它允许开发人员将通用功能抽象到一个基类中。考虑下面的例子:一个用户有多种支付方式。他们可以有一个链接的PayPal账户,还有几张信用卡的档案。</target>
        </trans-unit>
        <trans-unit id="4cb4bbf7cc3d4bc42049240fc08ab58851cd946a" translate="yes" xml:space="preserve">
          <source>Pop object from array or nil if none are left. Works just like &lt;code&gt;pop()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">从数组中弹出对象，如果没有剩余则从nil中弹出。就像 &lt;code&gt;pop()&lt;/code&gt; 一样工作，但是它兼容KVO。</target>
        </trans-unit>
        <trans-unit id="dc996b0d24beeb1d3c79bbc55469c48d769e7cfb" translate="yes" xml:space="preserve">
          <source>Positional Params</source>
          <target state="translated">位置参数</target>
        </trans-unit>
        <trans-unit id="b3f0b82d15093c4f3eefcefcd7c265667c8881d6" translate="yes" xml:space="preserve">
          <source>Positional arguments (e.g. &lt;code&gt;{{my-component this.someValue}}&lt;/code&gt;) are &lt;em&gt;not&lt;/em&gt; available in angle bracket invocation, since there is some ambiguity between their behavior and the behavior of standard HTML attributes (HTML attributes without &lt;code&gt;=&lt;/code&gt; default to truthy). If you still need positional arguments, you &lt;em&gt;must&lt;/em&gt; use the component with curly bracket syntax.</source>
          <target state="translated">位置参数（例如 &lt;code&gt;{{my-component this.someValue}}&lt;/code&gt; ）在尖括号调用中&lt;em&gt;不可&lt;/em&gt;用，因为它们的行为与标准HTML属性（不带HTML属性 &lt;code&gt;=&lt;/code&gt; 默认为true）的行为之间存在歧义。如果仍然需要位置参数，则&lt;em&gt;必须&lt;/em&gt;使用带有大括号语法的组件。</target>
        </trans-unit>
        <trans-unit id="5e660f41bf1644faff28e9b935d929c729609d44" translate="yes" xml:space="preserve">
          <source>Practical Resources</source>
          <target state="translated">实用资源</target>
        </trans-unit>
        <trans-unit id="bacc2b59c813afe0d96367410de97912289853d4" translate="yes" xml:space="preserve">
          <source>Prefer the &lt;code&gt;constructor&lt;/code&gt; function, unless the class extends &lt;code&gt;EmberObject&lt;/code&gt;, in which case prefer &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">最好使用 &lt;code&gt;constructor&lt;/code&gt; 函数，除非该类扩展了 &lt;code&gt;EmberObject&lt;/code&gt; ，在这种情况下，最好使用 &lt;code&gt;init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2684504bc0f6384c84c477f8be4a0311c5832d7" translate="yes" xml:space="preserve">
          <source>Preloading</source>
          <target state="translated">Preloading</target>
        </trans-unit>
        <trans-unit id="1ac28a409b05010e5dbd603d91ab6fbe68e42feb" translate="yes" xml:space="preserve">
          <source>Preparing an Addon to use a Canary Feature</source>
          <target state="translated">准备使用金丝雀功能的附加组件。</target>
        </trans-unit>
        <trans-unit id="8fa8462b8d7a18af6be6a7e1a411e11684ed8f8f" translate="yes" xml:space="preserve">
          <source>Pretty nice, right?</source>
          <target state="translated">很不错吧?</target>
        </trans-unit>
        <trans-unit id="4b1fb7e1484b0ba94928623eb8f36f404667ac59" translate="yes" xml:space="preserve">
          <source>Preventing Transitions via &lt;code&gt;willTransition&lt;/code&gt;</source>
          <target state="translated">通过 &lt;code&gt;willTransition&lt;/code&gt; 防止过渡</target>
        </trans-unit>
        <trans-unit id="d802d61c8a7392e75323ae02de35b9864c66709a" translate="yes" xml:space="preserve">
          <source>Preventing and Retrying Transitions</source>
          <target state="translated">防止和重新尝试过渡</target>
        </trans-unit>
        <trans-unit id="5013daf65503f91d54eccc1797b76d7e4dcd2880" translate="yes" xml:space="preserve">
          <source>Previously, in the &lt;a href=&quot;../routes-and-templates&quot;&gt;Routes and Templates tutorial&lt;/a&gt;, we set up a &lt;code&gt;rentals&lt;/code&gt; route.</source>
          <target state="translated">以前，在&amp;ldquo; &lt;a href=&quot;../routes-and-templates&quot;&gt;路线和模板&amp;rdquo;教程中&lt;/a&gt;，我们设置了一条 &lt;code&gt;rentals&lt;/code&gt; 路线。</target>
        </trans-unit>
        <trans-unit id="f9baaec4106faea48eaf7fcd6f074b9e97eaf3ab" translate="yes" xml:space="preserve">
          <source>Process all the jobs sequentially in &lt;code&gt;WORK_QUEUE&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;WORK_QUEUE&lt;/code&gt; 中依次处理所有作业</target>
        </trans-unit>
        <trans-unit id="fe5671922bc7f67cfabfa60ab97a9542ac21f39f" translate="yes" xml:space="preserve">
          <source>Promise</source>
          <target state="translated">Promise</target>
        </trans-unit>
        <trans-unit id="eb5d6e800790dcdd19447fac47669042de50dde8" translate="yes" xml:space="preserve">
          <source>Promise Example;</source>
          <target state="translated">答应例。</target>
        </trans-unit>
        <trans-unit id="7763424e70cdeb92b8efa1ce1e7ab2fb3c67f143" translate="yes" xml:space="preserve">
          <source>Promise States and Filtering</source>
          <target state="translated">承诺状态和过滤</target>
        </trans-unit>
        <trans-unit id="5ea8f6f7f55aefad94d6f37edf953a84817d34aa" translate="yes" xml:space="preserve">
          <source>Promise objects represent the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its &lt;code&gt;then&lt;/code&gt; method, which registers callbacks to receive either a promise&amp;rsquo;s eventual value or the reason why the promise cannot be fulfilled.</source>
          <target state="translated">承诺对象表示异步操作的最终结果。与承诺进行交互的主要方式是通过其 &lt;code&gt;then&lt;/code&gt; 方法，该方法注册回调以接收承诺的最终值或无法实现承诺的原因。</target>
        </trans-unit>
        <trans-unit id="46847c5528bf36a862876e82e64f9301b7d8c435" translate="yes" xml:space="preserve">
          <source>Promise that resolves to the passed value.</source>
          <target state="translated">承诺,解析到传递的值。</target>
        </trans-unit>
        <trans-unit id="031404877d6971f9d9a6925cfa325d146b1c8336" translate="yes" xml:space="preserve">
          <source>Promise&amp;lt;Application,Error&amp;gt;</source>
          <target state="translated">Promise&amp;lt;Application,Error&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f3922bee8d393adcf25c00ee1087ae678555fbab" translate="yes" xml:space="preserve">
          <source>Promise&amp;lt;ApplicationInstance, Error&amp;gt;</source>
          <target state="translated">Promise &amp;lt;ApplicationInstance，错误&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f90fc3965e7f0b82d63fa7168a48a06bdbb2d8a7" translate="yes" xml:space="preserve">
          <source>Promise&amp;lt;Ember.ApplicationInstance, Error&amp;gt;</source>
          <target state="translated">Promise &amp;lt;Ember.ApplicationInstance，错误&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b8fc6774f9e5c60ba40f1272fa1455b64359b716" translate="yes" xml:space="preserve">
          <source>Promise&amp;lt;EngineInstance,Error&amp;gt;</source>
          <target state="translated">Promise&amp;lt;EngineInstance,Error&amp;gt;</target>
        </trans-unit>
        <trans-unit id="20dfb17fbcb83737eb52f26791ace1434823d825" translate="yes" xml:space="preserve">
          <source>Promise&amp;lt;record&amp;gt;</source>
          <target state="translated">Promise&amp;lt;record&amp;gt;</target>
        </trans-unit>
        <trans-unit id="203fae2a257dd496efa85980bf0ba4c7773be142" translate="yes" xml:space="preserve">
          <source>Promise&amp;lt;record&amp;gt; a promise for the value (record or relationship)</source>
          <target state="translated">Promise &amp;lt;record&amp;gt;对值的承诺（记录或关系）</target>
        </trans-unit>
        <trans-unit id="dbab246007bbd1239c5f27c1517a97b421235a50" translate="yes" xml:space="preserve">
          <source>PromiseArray</source>
          <target state="translated">PromiseArray</target>
        </trans-unit>
        <trans-unit id="9507c3c92d0c3333ad409798f6bbbe601a9c7186" translate="yes" xml:space="preserve">
          <source>PromiseObject</source>
          <target state="translated">PromiseObject</target>
        </trans-unit>
        <trans-unit id="1e8da2708d11a179d860eb37dfe66600b1bd2b46" translate="yes" xml:space="preserve">
          <source>PromiseProxyMixin</source>
          <target state="translated">PromiseProxyMixin</target>
        </trans-unit>
        <trans-unit id="b1d472e424c03ff52490d1edc8a0e23f95babb92" translate="yes" xml:space="preserve">
          <source>Promises</source>
          <target state="translated">Promises</target>
        </trans-unit>
        <trans-unit id="f44a75e9345297610dff0ce9a97e4b57b6b46aab" translate="yes" xml:space="preserve">
          <source>Promises A+ specifies that any exceptions that occur with a promise must be caught by the promises implementation and bubbled to the last handler. For this reason, it is recommended that you always specify a second rejection handler function to &lt;code&gt;then&lt;/code&gt;. However, &lt;code&gt;RSVP.rethrow&lt;/code&gt; will throw the exception outside of the promise, so it bubbles up to your console if in the browser, or domain/cause uncaught exception in Node. &lt;code&gt;rethrow&lt;/code&gt; will also throw the error again so the error can be handled by the promise per the spec.</source>
          <target state="translated">Promises A +规定，由Promise实现必须捕获与Promise一起发生的任何异常，并冒泡到最后一个处理程序。因此，建议您始终向 &lt;code&gt;then&lt;/code&gt; 指定第二个拒绝处理程序函数。但是， &lt;code&gt;RSVP.rethrow&lt;/code&gt; 会在Promise之外抛出异常，因此，如果在浏览器中或Node中的域/原因未捕获的异常，它会冒泡到您的控制台。 &lt;code&gt;rethrow&lt;/code&gt; 也会再次抛出错误，因此可以按照规范通过承诺处理错误。</target>
        </trans-unit>
        <trans-unit id="f087fe7714b99fc26f67b90d3aebac0b1e3a66e9" translate="yes" xml:space="preserve">
          <source>Promises A+ specifies that any exceptions that occur with a promise must be caught by the promises implementation and bubbled to the last handler. For this reason, it is recommended that you always specify a second rejection handler function to &lt;code&gt;then&lt;/code&gt;. However, &lt;code&gt;rethrow&lt;/code&gt; will throw the exception outside of the promise, so it bubbles up to your console if in the browser, or domain/cause uncaught exception in Node. &lt;code&gt;rethrow&lt;/code&gt; will also throw the error again so the error can be handled by the promise per the spec.</source>
          <target state="translated">Promises A +规定，由Promise实现必须捕获与Promise一起发生的任何异常，并冒泡到最后一个处理程序。因此，建议您始终向 &lt;code&gt;then&lt;/code&gt; 指定第二个拒绝处理程序函数。但是， &lt;code&gt;rethrow&lt;/code&gt; 会将异常抛出到Promise之外，因此如果在浏览器中，或者在Node中的域/原因未捕获的异常中，它都会冒泡到您的控制台。 &lt;code&gt;rethrow&lt;/code&gt; 也会再次抛出错误，因此可以按照规范通过承诺处理错误。</target>
        </trans-unit>
        <trans-unit id="216c902fd90fd7f61531c27c5a86d60085ec25e9" translate="yes" xml:space="preserve">
          <source>Promises Not Detected</source>
          <target state="translated">未检测到的承诺</target>
        </trans-unit>
        <trans-unit id="aaca97f965d2c31995d03cad0b27e350c3445416" translate="yes" xml:space="preserve">
          <source>Promises can also be said to &lt;em&gt;resolve&lt;/em&gt; a value. If this value is also a promise, then the original promise's settled state will match the value's settled state. So a promise that &lt;em&gt;resolves&lt;/em&gt; a promise that rejects will itself reject, and a promise that &lt;em&gt;resolves&lt;/em&gt; a promise that fulfills will itself fulfill.</source>
          <target state="translated">也可以说承诺&lt;em&gt;解决&lt;/em&gt;了一个价值。如果此值也是承诺，则原始承诺的结算状态将与该值的结算状态匹配。因此，&lt;em&gt;解决&lt;/em&gt;了被拒绝的诺言的诺言本身将被拒绝，而&lt;em&gt;解决&lt;/em&gt;被实现的诺言的诺言本身将被实现。</target>
        </trans-unit>
        <trans-unit id="9f4ddbbce9b9a96df78d3c916a6239398660cebc" translate="yes" xml:space="preserve">
          <source>Promises generated by Ember are all labeled by default. You can also label your own RSVP Promises to find them in the Inspector's Promises tab. All RSVP methods can take a label as the final argument.</source>
          <target state="translated">Ember生成的承诺都是默认的标签。你也可以给自己的RSVP承诺打上标签,在检查员的承诺选项卡中找到它们。所有的RSVP方法都可以接受一个标签作为最终参数。</target>
        </trans-unit>
        <trans-unit id="763b5a177da3472a739c49add6d1a21b1ef06c5d" translate="yes" xml:space="preserve">
          <source>Promises have different colors based on their state.</source>
          <target state="translated">承诺根据其状态有不同的颜色。</target>
        </trans-unit>
        <trans-unit id="f72d01a967e01e14a4a0fa223b3309202aa7c45b" translate="yes" xml:space="preserve">
          <source>Promises shine when abstracting away asynchronous interactions such as &lt;code&gt;XMLHttpRequest&lt;/code&gt;s.</source>
          <target state="translated">当抽象出诸如 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 之类的异步交互时，承诺会大放异彩。</target>
        </trans-unit>
        <trans-unit id="9229a94589162572814117eb770a291cf02fddad" translate="yes" xml:space="preserve">
          <source>Promises that are fulfilled have a fulfillment value and are in the fulfilled state. Promises that are rejected have a rejection reason and are in the rejected state. A fulfillment value is never a thenable.</source>
          <target state="translated">被履行的承诺有一个履行值,处于履行状态。被拒绝的承诺有拒绝原因,处于拒绝状态。履行值永远不是一个可然后。</target>
        </trans-unit>
        <trans-unit id="03590df139443945075f2a3bc957119a024699ce" translate="yes" xml:space="preserve">
          <source>Promise|Object</source>
          <target state="translated">Promise|Object</target>
        </trans-unit>
        <trans-unit id="4d27d8f128502f9f8111caae7ff62cbb3ed8d690" translate="yes" xml:space="preserve">
          <source>Proper use of loading and error states result in better user experience</source>
          <target state="translated">正确使用加载状态和错误状态可以带来更好的用户体验。</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="7ed31ad18cd5e9f2707ad799a56faddf17019c6d" translate="yes" xml:space="preserve">
          <source>Properties and Fields</source>
          <target state="translated">属性和领域</target>
        </trans-unit>
        <trans-unit id="536b9006793cf5c3c1070e09df19893db8668d7a" translate="yes" xml:space="preserve">
          <source>Properties and observers allow one object to observe changes to a property on another object. This is one of the fundamental ways that models, controllers and views communicate with each other in an Ember application.</source>
          <target state="translated">属性和观察者允许一个对象观察另一个对象的属性变化。这是模型、控制器和视图在Ember应用中相互沟通的基本方式之一。</target>
        </trans-unit>
        <trans-unit id="82033eb711807359e0eec9de4a43a4d74d92c987" translate="yes" xml:space="preserve">
          <source>Properties can be chained as well:</source>
          <target state="translated">属性也是可以连锁的。</target>
        </trans-unit>
        <trans-unit id="78f31ba10d57ca9b7adea36e3e53f11fe1911b58" translate="yes" xml:space="preserve">
          <source>Properties passed to &lt;code&gt;create&lt;/code&gt; will be available on the instance by the time &lt;code&gt;init&lt;/code&gt; runs, so any code that requires these values should work at that time.</source>
          <target state="translated">传递给 &lt;code&gt;create&lt;/code&gt; 的属性将在 &lt;code&gt;init&lt;/code&gt; 运行时在实例上可用，因此任何需要这些值的代码都应在那时运行。</target>
        </trans-unit>
        <trans-unit id="5c379650924c833d1858287bc08588ceb832a8a0" translate="yes" xml:space="preserve">
          <source>Properties that are defined on the model but are omitted in the normalized JSON API document object will not be updated. Properties that are included in the normalized JSON API document object but not defined on the Model will be ignored.</source>
          <target state="translated">在模型上定义但在规范化JSON API文档对象中省略的属性将不会被更新。包含在规范化JSON API文档对象中但未在模型上定义的属性将被忽略。</target>
        </trans-unit>
        <trans-unit id="8abb7eb3c6d007528a186713bf1812adcaa9791f" translate="yes" xml:space="preserve">
          <source>Properties that are defined on the model but are omitted in the normalized JSON:API document object will not be updated. Properties that are included in the normalized JSON:API document object but not defined on the Model will be ignored.</source>
          <target state="translated">在模型上定义但在规范化的 JSON:API 文档对象中省略的属性将不会被更新。包含在规范化JSON:API文档对象中但未在模型上定义的属性将被忽略。</target>
        </trans-unit>
        <trans-unit id="8d9e37b396787a5cb09465045bf0f0a4eab7185e" translate="yes" xml:space="preserve">
          <source>Property Observers</source>
          <target state="translated">物业观察员</target>
        </trans-unit>
        <trans-unit id="36a5c5d127ff74bc8923ef2c6b095fb263a73471" translate="yes" xml:space="preserve">
          <source>PropertyDecorator</source>
          <target state="translated">PropertyDecorator</target>
        </trans-unit>
        <trans-unit id="1663fd75547a6135b01b3df3236c0070aa5f0920" translate="yes" xml:space="preserve">
          <source>PropertyDescriptor|undefined</source>
          <target state="translated">PropertyDescriptor|undefined</target>
        </trans-unit>
        <trans-unit id="3249cd85365c1d97e6d4a3239b88af5d064671ab" translate="yes" xml:space="preserve">
          <source>Provide the asset path as the first argument, and the list of modules and exports as the second.</source>
          <target state="translated">提供资产路径作为第一个参数,提供模块和出口列表作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="4e7ccdfdc46e55a1f8f8e8698100457fdda15b9f" translate="yes" xml:space="preserve">
          <source>Provide the asset path as the first argument:</source>
          <target state="translated">提供资产路径作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="804a830ba49ef5270d658059a3cc0bf26f755759" translate="yes" xml:space="preserve">
          <source>Providing Markup to a Component</source>
          <target state="translated">为组件提供标记</target>
        </trans-unit>
        <trans-unit id="5c9b1ac36b5021ea213e2a9b52e09401d0c16a5b" translate="yes" xml:space="preserve">
          <source>Proxies to the serializer's &lt;code&gt;serialize&lt;/code&gt; method.</source>
          <target state="translated">代理序列化器的 &lt;code&gt;serialize&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="127bb9e4bb030d22e2337f3c5cdd29d2359e0a2d" translate="yes" xml:space="preserve">
          <source>ProxyMixin</source>
          <target state="translated">ProxyMixin</target>
        </trans-unit>
        <trans-unit id="942ee8718427c820129c01d74733d07d8f832498" translate="yes" xml:space="preserve">
          <source>Pure native classes, sharing functionality via class inheritance.</source>
          <target state="translated">纯原生类,通过类继承共享功能。</target>
        </trans-unit>
        <trans-unit id="c4a9924b7849758c869d4fd5e52d97bd8b26ff5e" translate="yes" xml:space="preserve">
          <source>Push some data for a given type into the store.</source>
          <target state="translated">将给定类型的一些数据推送到存储中。</target>
        </trans-unit>
        <trans-unit id="9536ee10c3ab2432a5e6558f3207239d0d2ea555" translate="yes" xml:space="preserve">
          <source>Push some raw data into the store.</source>
          <target state="translated">将一些原始数据推送到商店。</target>
        </trans-unit>
        <trans-unit id="9b601bad7a8b3234afd2de3a37d3cb2f2f119973" translate="yes" xml:space="preserve">
          <source>Push the object onto the end of the array if it is not already present in the array.</source>
          <target state="translated">如果对象没有出现在数组中,则将其推到数组的末端。</target>
        </trans-unit>
        <trans-unit id="5a5340b1561d715113dc2d332842eae59747ca32" translate="yes" xml:space="preserve">
          <source>Push the object onto the end of the array. Works just like &lt;code&gt;push()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">将对象推到数组的末尾。就像 &lt;code&gt;push()&lt;/code&gt; 一样工作，但是它兼容KVO。</target>
        </trans-unit>
        <trans-unit id="700f90c6bd512a32dbfb55478282f3c7731cdb78" translate="yes" xml:space="preserve">
          <source>Pushing Records</source>
          <target state="translated">唱片公司</target>
        </trans-unit>
        <trans-unit id="08491627624f56833d6474da961363d94fe64101" translate="yes" xml:space="preserve">
          <source>Pushing Records into the Store</source>
          <target state="translated">将唱片推入商店</target>
        </trans-unit>
        <trans-unit id="ba83f3a04b35edb4a33611352a88476fef56f328" translate="yes" xml:space="preserve">
          <source>QUnit example:</source>
          <target state="translated">QUnit的例子。</target>
        </trans-unit>
        <trans-unit id="c5aad12964a69eb6cc9ccef39e0f740e43015f0f" translate="yes" xml:space="preserve">
          <source>QUnit passes in an object called an &lt;a href=&quot;https://api.qunitjs.com/assert/&quot;&gt;&lt;code&gt;assert&lt;/code&gt;&lt;/a&gt; to each test function. An &lt;code&gt;assert&lt;/code&gt; has functions, such as &lt;code&gt;equal()&lt;/code&gt;, that allow your test to check for conditions within the test environment. A test must have one passing assert to be successful.</source>
          <target state="translated">QUnit将一个称为&lt;a href=&quot;https://api.qunitjs.com/assert/&quot;&gt; &lt;code&gt;assert&lt;/code&gt; &lt;/a&gt;的对象传递给每个测试函数。一个 &lt;code&gt;assert&lt;/code&gt; 具有的功能，如 &lt;code&gt;equal()&lt;/code&gt; ，允许您的测试，以检查测试环境中的条件。一个测试必须有一个通过的断言才能成功。</target>
        </trans-unit>
        <trans-unit id="8efa9f9b516b6bc7822720c80c7291bdcd7559ed" translate="yes" xml:space="preserve">
          <source>QUnit, QUnit DOM</source>
          <target state="translated">QUnit,QUnit DOM</target>
        </trans-unit>
        <trans-unit id="3229861d9c9111cf61a19e43da48ddbbd1b48efd" translate="yes" xml:space="preserve">
          <source>Query Parameters</source>
          <target state="translated">查询参数</target>
        </trans-unit>
        <trans-unit id="0fd0190c18a1b0c89567786d2da87abd9ad2e6a8" translate="yes" xml:space="preserve">
          <source>Query Params</source>
          <target state="translated">查询参数</target>
        </trans-unit>
        <trans-unit id="5139ef15ef3085f1688a1e87d332dfd36e0ceff6" translate="yes" xml:space="preserve">
          <source>Query param values are cast to the same datatype as the default value, e.g. a URL change from &lt;code&gt;/?page=3&lt;/code&gt; to &lt;code&gt;/?page=2&lt;/code&gt; will set &lt;code&gt;controller:articles&lt;/code&gt;'s &lt;code&gt;page&lt;/code&gt; property to the number &lt;code&gt;2&lt;/code&gt;, rather than the string &lt;code&gt;&quot;2&quot;&lt;/code&gt;. The same also applies to boolean default values. If the default value is an array, the string will be parsed using &lt;code&gt;JSON.parse&lt;/code&gt;.</source>
          <target state="translated">查询参数值将转换为与默认值相同的数据类型，例如，将URL从 &lt;code&gt;/?page=3&lt;/code&gt; 更改为 &lt;code&gt;/?page=2&lt;/code&gt; 会将 &lt;code&gt;controller:articles&lt;/code&gt; 的 &lt;code&gt;page&lt;/code&gt; 属性设置为数字 &lt;code&gt;2&lt;/code&gt; ，而不是字符串 &lt;code&gt;&quot;2&quot;&lt;/code&gt; 。布尔默认值也是如此。如果默认值为数组，则将使用 &lt;code&gt;JSON.parse&lt;/code&gt; 解析字符串。</target>
        </trans-unit>
        <trans-unit id="0aca39e962863236da8c92fd756de102fb200868" translate="yes" xml:space="preserve">
          <source>Query parameters are optional key-value pairs that appear to the right of the &lt;code&gt;?&lt;/code&gt; in a URL. For example, the following URL has two query params, &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;page&lt;/code&gt;, with respective values &lt;code&gt;ASC&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;:</source>
          <target state="translated">查询参数是可选的键值对，显示在 &lt;code&gt;?&lt;/code&gt; 的右侧。在网址中。例如，以下URL具有两个查询参数 &lt;code&gt;sort&lt;/code&gt; 和 &lt;code&gt;page&lt;/code&gt; ，分别具有值 &lt;code&gt;ASC&lt;/code&gt; 和 &lt;code&gt;2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b0f8ce0e88182d09e5b36ad33c8efbb1f3a42a78" translate="yes" xml:space="preserve">
          <source>Query params allow for additional application state to be serialized into the URL that can't otherwise fit into the &lt;em&gt;path&lt;/em&gt; of the URL (i.e. everything to the left of the &lt;code&gt;?&lt;/code&gt;). Common use cases for query params include representing the current page number in a paginated collection, filter criteria, or sorting criteria.</source>
          <target state="translated">查询参数允许将其他应用程序状态序列化到URL中，否则该状态不能适合URL 的&lt;em&gt;路径&lt;/em&gt;（即， &lt;code&gt;?&lt;/code&gt; 左边的所有内容）。查询参数的常见用例包括在分页集合中表示当前页码，过滤条件或排序条件。</target>
        </trans-unit>
        <trans-unit id="b1782f7b18226435ee790bf1a339595b9fcaafce" translate="yes" xml:space="preserve">
          <source>Query params are declared on route-driven controllers. For example, to configure query params that are active within the &lt;code&gt;articles&lt;/code&gt; route, they must be declared on &lt;code&gt;controller:articles&lt;/code&gt;.</source>
          <target state="translated">查询参数在路由驱动的控制器上声明。例如，要配置在 &lt;code&gt;articles&lt;/code&gt; 路由中处于活动状态的查询参数，必须在 &lt;code&gt;controller:articles&lt;/code&gt; 上声明它们。</target>
        </trans-unit>
        <trans-unit id="b1e8c5f9eb6a51268771357d73e5c3d414ee77b7" translate="yes" xml:space="preserve">
          <source>Query params that require additional customization can be provided along with strings in the &lt;code&gt;queryParams&lt;/code&gt; array.</source>
          <target state="translated">可以提供需要额外自定义的查询参数以及 &lt;code&gt;queryParams&lt;/code&gt; 数组中的字符串。</target>
        </trans-unit>
        <trans-unit id="84d51a6c79840a7e20e6f3b3c232167ddd101fdb" translate="yes" xml:space="preserve">
          <source>Querying for A Single Record</source>
          <target state="translated">查询单条记录</target>
        </trans-unit>
        <trans-unit id="bab1721e2fbda766f83183971199264a105762c8" translate="yes" xml:space="preserve">
          <source>Querying for Multiple Records</source>
          <target state="translated">查询多个记录</target>
        </trans-unit>
        <trans-unit id="455083cac2ae96eabe3895762b6080aa09e6afa4" translate="yes" xml:space="preserve">
          <source>Quick Start</source>
          <target state="translated">快速入门</target>
        </trans-unit>
        <trans-unit id="230411ef89f03596bd363a86e0479171061c9d26" translate="yes" xml:space="preserve">
          <source>RESTAdapter</source>
          <target state="translated">RESTAdapter</target>
        </trans-unit>
        <trans-unit id="d951635668302f4b57a9b19aab103a9dba73ce9f" translate="yes" xml:space="preserve">
          <source>RESTSerializer</source>
          <target state="translated">RESTSerializer</target>
        </trans-unit>
        <trans-unit id="9e2ff6c5483cb39d97a402f850cb39e32d0c9dbc" translate="yes" xml:space="preserve">
          <source>RSVP</source>
          <target state="translated">RSVP</target>
        </trans-unit>
        <trans-unit id="cc85f8587031356b78b2448d63c222acc180e5f9" translate="yes" xml:space="preserve">
          <source>RSVP.EventTarget</source>
          <target state="translated">RSVP.EventTarget</target>
        </trans-unit>
        <trans-unit id="8c3018eec21a26738e481a8b5ea2b8b6ade95786" translate="yes" xml:space="preserve">
          <source>RSVP.Promise</source>
          <target state="translated">RSVP.Promise</target>
        </trans-unit>
        <trans-unit id="4e1ef1585228db21136c63e2c103fa2fc8cba9b0" translate="yes" xml:space="preserve">
          <source>RSVP.Promise&amp;lt;any&amp;gt;</source>
          <target state="translated">RSVP.Promise&amp;lt;any&amp;gt;</target>
        </trans-unit>
        <trans-unit id="02ed91fc301225e19af656a773481bbe02910c4f" translate="yes" xml:space="preserve">
          <source>RSVP.Promise&amp;lt;undefined&amp;gt;</source>
          <target state="translated">RSVP.Promise&amp;lt;undefined&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0e57c7077cfdd6dccd21781d8c00850d345148e3" translate="yes" xml:space="preserve">
          <source>Rather than create an arbitrary set of conventions, Ember Data is designed to work out of the box with &lt;a href=&quot;http://jsonapi.org&quot;&gt;JSON API&lt;/a&gt;. JSON API is a formal specification for building conventional, robust, and performant APIs that allow clients and servers to communicate model data.</source>
          <target state="translated">Ember Data并非创建任意的约定集，而是设计为使用&lt;a href=&quot;http://jsonapi.org&quot;&gt;JSON API即开即用&lt;/a&gt;。JSON API是用于构建常规，健壮和高性能的API的正式规范，该API允许客户端和服务器通信模型数据。</target>
        </trans-unit>
        <trans-unit id="20a3458f1862c89f455c490634fb5f573475fbc2" translate="yes" xml:space="preserve">
          <source>Rather than writing the higher level app code that internally invokes the various run loop scheduling functions, we have stripped away the covers, and shown the raw run-loop interactions.</source>
          <target state="translated">我们没有编写更高层次的应用代码,在内部调用各种运行循环调度函数,而是剥去了封面,展示了原始的运行循环交互。</target>
        </trans-unit>
        <trans-unit id="02143f2c5abf0fcc77c1815c31c2586f2ab77a8d" translate="yes" xml:space="preserve">
          <source>Re-route to the existing url</source>
          <target state="translated">重新路由到现有的网址</target>
        </trans-unit>
        <trans-unit id="555768dd72554ce46dd9aaba0b928945c0c45add" translate="yes" xml:space="preserve">
          <source>Read some blog posts about data loading in Ember. Apps and APIs come in so many different shapes and sizes that it's helpful to seek out examples that are similar to your goals before digging into the details.</source>
          <target state="translated">阅读一些关于Ember中数据加载的博文。应用程序和API有许多不同的形状和大小,因此在挖掘细节之前,寻找与你的目标相似的例子是很有帮助的。</target>
        </trans-unit>
        <trans-unit id="4762fc07015da670d25188e13fd68f6f63cbbe2e" translate="yes" xml:space="preserve">
          <source>Read-only Attributes</source>
          <target state="translated">只读属性</target>
        </trans-unit>
        <trans-unit id="c853a28871d264d43a0d86e34fdf1c1f3e7482f4" translate="yes" xml:space="preserve">
          <source>Readonly Nested Data</source>
          <target state="translated">只读嵌套数据</target>
        </trans-unit>
        <trans-unit id="a541f922c72dc2bbd61c03c85126d821763fdbd8" translate="yes" xml:space="preserve">
          <source>Recall that our modifier will manage the DOM (i.e. calling the audio element's &lt;code&gt;play&lt;/code&gt; or &lt;code&gt;pause&lt;/code&gt; method). All the component needs to do is to track whether the audio is playing:</source>
          <target state="translated">回想一下，我们的修饰符将管理DOM（即，调用音频元素的 &lt;code&gt;play&lt;/code&gt; 或 &lt;code&gt;pause&lt;/code&gt; 方法）。组件所需要做的就是跟踪音频是否正在播放：</target>
        </trans-unit>
        <trans-unit id="ced23c694be11636b1a1057eb27e72fe6d077ceb" translate="yes" xml:space="preserve">
          <source>Recall that there were a few exceptions. The following input attributes must be passed as arguments (i.e. do prepend &lt;code&gt;@&lt;/code&gt;) to the &lt;code&gt;&amp;lt;Input&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">回想一下，有一些例外。必须将以下输入属性作为参数（即在 &lt;code&gt;@&lt;/code&gt; 前面添加）传递给 &lt;code&gt;&amp;lt;Input&amp;gt;&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="0c10e60d11c6190929e46b216e3485144d573585" translate="yes" xml:space="preserve">
          <source>Receives a destroyable and a destructor function, and de-associates the destructor from the destroyable.</source>
          <target state="translated">接收destroyable和destructor函数,并将destructor与destroyable解除关联。</target>
        </trans-unit>
        <trans-unit id="3d7346f83dd4ebab78f9b401d93fec94888fd513" translate="yes" xml:space="preserve">
          <source>Receives a destroyable object and a destructor function, and associates the function with it. When the destroyable is destroyed with destroy, or when its parent is destroyed, the destructor function will be called.</source>
          <target state="translated">接收一个可销毁对象和一个destructor函数,并将函数与之关联。当用destroy摧毁可摧毁对象时,或当其父对象被摧毁时,将调用destructor函数。</target>
        </trans-unit>
        <trans-unit id="cfb21c34cc91761b59549492bc38bb22aee9aa80" translate="yes" xml:space="preserve">
          <source>Receives a destroyable, and returns true if the destroyable has begun destroying. Otherwise returns false.</source>
          <target state="translated">接收一个可销毁对象,如果该对象已经开始销毁,则返回true。否则返回false。</target>
        </trans-unit>
        <trans-unit id="22c4309d8d736af351252e3939d38e7b00f34610" translate="yes" xml:space="preserve">
          <source>Receives a destroyable, and returns true if the destroyable has finished destroying. Otherwise returns false.</source>
          <target state="translated">接收一个可销毁对象,如果该可销毁对象已经完成销毁,则返回true。否则返回false。</target>
        </trans-unit>
        <trans-unit id="698fcc6e06623ab7a1f886a395c6817e24d08745" translate="yes" xml:space="preserve">
          <source>Recomputing is fine in most cases. If the computation that happens in the getter is very expensive, however, you will want to cache the value and retrieve it when the dependencies haven't changed. You want to recompute only if a dependency has been updated.</source>
          <target state="translated">在大多数情况下,重新计算是没有问题的。然而,如果在getter中发生的计算非常昂贵,你会希望缓存该值,并在依赖关系没有改变时检索它。只有当依赖关系被更新时,你才会想要重新计算。</target>
        </trans-unit>
        <trans-unit id="b129f9f5e547d2585b00b80301e33d0ccd886142" translate="yes" xml:space="preserve">
          <source>Record States and Filtering</source>
          <target state="translated">记录状态和过滤</target>
        </trans-unit>
        <trans-unit id="c4612a8c735947d2f4860fb003a9cdd796980b66" translate="yes" xml:space="preserve">
          <source>RecordArray</source>
          <target state="translated">RecordArray</target>
        </trans-unit>
        <trans-unit id="779639f77d26423e55093890463c73df4117f2b4" translate="yes" xml:space="preserve">
          <source>RecordReference</source>
          <target state="translated">RecordReference</target>
        </trans-unit>
        <trans-unit id="e51c55255be9007d473b3c04b4553c2a27d6f03b" translate="yes" xml:space="preserve">
          <source>Records</source>
          <target state="translated">Records</target>
        </trans-unit>
        <trans-unit id="09f48f492f46fd16811c910592ad171170771ab8" translate="yes" xml:space="preserve">
          <source>Records in Ember Data are persisted on a per-instance basis. Call &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Model.html#method_save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; on any instance of &lt;code&gt;DS.Model&lt;/code&gt; and it will make a network request.</source>
          <target state="translated">Ember Data中的记录将按实例持久保存。在 &lt;code&gt;DS.Model&lt;/code&gt; 的任何实例上调用&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Model.html#method_save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt;，它将发出网络请求。</target>
        </trans-unit>
        <trans-unit id="ed751fe2f444ff45c31b40f1861107d5255a6d0f" translate="yes" xml:space="preserve">
          <source>Records in Ember Data are persisted on a per-instance basis. Call &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/Model/methods#save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; on any instance of &lt;code&gt;Model&lt;/code&gt; and it will make a network request.</source>
          <target state="translated">Ember Data中的记录将按实例持久保存。在 &lt;code&gt;Model&lt;/code&gt; 的任何实例上调用&lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/Model/methods#save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt;，它将发出网络请求。</target>
        </trans-unit>
        <trans-unit id="93f89c3ab4a799a6a0aab99eb1bb7100ea88724d" translate="yes" xml:space="preserve">
          <source>Records that already exist on the backend are updated using the HTTP &lt;code&gt;PATCH&lt;/code&gt; verb.</source>
          <target state="translated">使用HTTP &lt;code&gt;PATCH&lt;/code&gt; 动词来更新后端上已经存在的记录。</target>
        </trans-unit>
        <trans-unit id="2f7c32c0b4917effc40dd0a0959efa8e648135b6" translate="yes" xml:space="preserve">
          <source>Records without an &lt;code&gt;id&lt;/code&gt; property are not considered embedded records, model instances must have an &lt;code&gt;id&lt;/code&gt; property to be used with Ember Data.</source>
          <target state="translated">没有 &lt;code&gt;id&lt;/code&gt; 属性的记录不被视为嵌入式记录，模型实例必须具有 &lt;code&gt;id&lt;/code&gt; 属性才能与Ember Data一起使用。</target>
        </trans-unit>
        <trans-unit id="5ac9a9807e12ead40a070a8626218b2274db6816" translate="yes" xml:space="preserve">
          <source>Recovering from Rejection</source>
          <target state="translated">从拒绝中恢复</target>
        </trans-unit>
        <trans-unit id="60e22121bdd0bc71cdb2bae2a3aa577006b2eae9" translate="yes" xml:space="preserve">
          <source>Redirecting</source>
          <target state="translated">Redirecting</target>
        </trans-unit>
        <trans-unit id="d0b1214393f95eb4505b13838fbc94ad949a9823" translate="yes" xml:space="preserve">
          <source>Refactor some components to use &lt;a href=&quot;../../components&quot;&gt;Glimmer Components&lt;/a&gt;. Good components to refactor first are those that do not rely on two-way bindings, computed properties, or observers. These components will serve as examples that your coworkers can refer back to.</source>
          <target state="translated">重构某些组件以使用&lt;a href=&quot;../../components&quot;&gt;Glimmer组件&lt;/a&gt;。首先要重构的好组件是那些不依赖双向绑定，计算属性或观察者的组件。这些组件将作为示例供您的同事参考。</target>
        </trans-unit>
        <trans-unit id="699246f530a0f9bdddf368649ef2dcc19173ed67" translate="yes" xml:space="preserve">
          <source>Refactor some components to use &lt;a href=&quot;https://guides.emberjs.com/components/&quot;&gt;Glimmer Components&lt;/a&gt;. Good components to refactor first are those that do not rely on two-way bindings, computed properties, or observers. These components will serve as examples that your coworkers can refer back to.</source>
          <target state="translated">重构某些组件以使用&lt;a href=&quot;https://guides.emberjs.com/components/&quot;&gt;Glimmer组件&lt;/a&gt;。首先要重构的好组件是那些不依赖双向绑定，计算属性或观察者的组件。这些组件将作为示例供您的同事参考。</target>
        </trans-unit>
        <trans-unit id="f398f3fd3d702745528a0e9f42da80b185589162" translate="yes" xml:space="preserve">
          <source>Refactoring checklist</source>
          <target state="translated">重构检查表</target>
        </trans-unit>
        <trans-unit id="6bfa4764dfd3c083f396267379ee172ae1854a8d" translate="yes" xml:space="preserve">
          <source>Refer to documentation for &lt;code&gt;beforeModel&lt;/code&gt; for a description of transition-pausing semantics when a promise is returned from this hook.</source>
          <target state="translated">有关从该挂钩返回promise时过渡暂停语义的描述，请参考 &lt;code&gt;beforeModel&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="99f62095529c6af5ce3c4c2976cf5e8e543250eb" translate="yes" xml:space="preserve">
          <source>References to other records should be done by ID. For example, if you have a model with a &lt;code&gt;hasMany&lt;/code&gt; relationship:</source>
          <target state="translated">对其他记录的引用应通过ID完成。例如，如果您的模型具有 &lt;code&gt;hasMany&lt;/code&gt; 关系：</target>
        </trans-unit>
        <trans-unit id="69f6bad51245a7a68b6a5d503ecf8f42a933df09" translate="yes" xml:space="preserve">
          <source>Reflexive Relations</source>
          <target state="translated">反思性关系</target>
        </trans-unit>
        <trans-unit id="6224a939ef652c56dddd065c6b6575aface1416e" translate="yes" xml:space="preserve">
          <source>Refresh the model on this route and any child routes, firing the &lt;code&gt;beforeModel&lt;/code&gt;, &lt;code&gt;model&lt;/code&gt;, and &lt;code&gt;afterModel&lt;/code&gt; hooks in a similar fashion to how routes are entered when transitioning in from other route. The current route params (e.g. &lt;code&gt;article_id&lt;/code&gt;) will be passed in to the respective model hooks, and if a different model is returned, &lt;code&gt;setupController&lt;/code&gt; and associated route hooks will re-fire as well.</source>
          <target state="translated">刷新此路线和所有 &lt;code&gt;beforeModel&lt;/code&gt; &lt;code&gt;model&lt;/code&gt; ，以类似于从其他路线过渡时输入路线的方式触发beforeModel，model和 &lt;code&gt;afterModel&lt;/code&gt; 挂钩。当前的路由参数（例如 &lt;code&gt;article_id&lt;/code&gt; ）将传递到相应的模型钩子中，如果返回了不同的模型， &lt;code&gt;setupController&lt;/code&gt; 和关联的路由钩子也会重新触发。</target>
        </trans-unit>
        <trans-unit id="ca5db4fe93ba98fe1b576309acf2388052f2a36a" translate="yes" xml:space="preserve">
          <source>RegExp</source>
          <target state="translated">RegExp</target>
        </trans-unit>
        <trans-unit id="06b326b8df4964d11fe7f98ffc257e678212ac9e" translate="yes" xml:space="preserve">
          <source>Regardless of how the URL becomes set, the Ember router then maps the current URL to one or more route handlers. A route handler can do several things:</source>
          <target state="translated">无论URL如何设置,Ember路由器都会将当前URL映射到一个或多个路由处理程序。一个路由处理程序可以做几件事。</target>
        </trans-unit>
        <trans-unit id="13ef3793fbf15d676e0da171536ccb7a8b55c72a" translate="yes" xml:space="preserve">
          <source>Regardless of the serializer used, this metadata is extracted from the response. You can then read it with &lt;code&gt;.get('meta')&lt;/code&gt;.</source>
          <target state="translated">无论使用哪种序列化程序，都将从响应中提取此元数据。然后，您可以使用 &lt;code&gt;.get('meta')&lt;/code&gt; 阅读它。</target>
        </trans-unit>
        <trans-unit id="6bf45590a3ae91521f07c3e91845970cf7b6a81b" translate="yes" xml:space="preserve">
          <source>Regardless of the serializer used, this metadata is extracted from the response. You can then read it with &lt;code&gt;.meta&lt;/code&gt;.</source>
          <target state="translated">无论使用哪种序列化程序，都将从响应中提取此元数据。然后，您可以使用 &lt;code&gt;.meta&lt;/code&gt; 阅读它。</target>
        </trans-unit>
        <trans-unit id="580b18a39e5b39765415c0eed123af6da265aa11" translate="yes" xml:space="preserve">
          <source>Register options for a particular factory.</source>
          <target state="translated">注册特定工厂的选项。</target>
        </trans-unit>
        <trans-unit id="6291ba0522621d5582aa26e4decc87be7d141a60" translate="yes" xml:space="preserve">
          <source>Register/Unregister additional test helpers.</source>
          <target state="translated">注册/取消注册其他测试助手。</target>
        </trans-unit>
        <trans-unit id="57ac94516e6ba3226fa58ffc652e3e7312c91e5d" translate="yes" xml:space="preserve">
          <source>Registered factories are &lt;strong&gt;instantiated&lt;/strong&gt; by having &lt;code&gt;create&lt;/code&gt; called on them. Additionally they are &lt;strong&gt;singletons&lt;/strong&gt;, each time they are looked up they return the same instance.</source>
          <target state="translated">已注册的工厂通过调用 &lt;code&gt;create&lt;/code&gt; 来&lt;strong&gt;实例化&lt;/strong&gt;。此外，它们是&lt;strong&gt;单例&lt;/strong&gt;，每次查找时，它们都返回相同的实例。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="63c9b0772d57be72a0c5d903431a873fcdb8a6f2" translate="yes" xml:space="preserve">
          <source>Registering Already Instantiated Objects</source>
          <target state="translated">注册已经实例化的对象</target>
        </trans-unit>
        <trans-unit id="4e4aa5ae30460fc62431c4dbebe42f4477bbe300" translate="yes" xml:space="preserve">
          <source>Registering Singletons vs. Non-Singletons</source>
          <target state="translated">注册单子与非单子。</target>
        </trans-unit>
        <trans-unit id="aba41c3a5d53b4b36fb1b8a0fdb902b0488d3a7a" translate="yes" xml:space="preserve">
          <source>Registering a Library</source>
          <target state="translated">注册图书馆</target>
        </trans-unit>
        <trans-unit id="0803d3a3d9f15e36c86ae2132d20124795a72459" translate="yes" xml:space="preserve">
          <source>Registers a factory that can be used for dependency injection (with &lt;code&gt;inject&lt;/code&gt;) or for service lookup. Each factory is registered with a full name including two parts: &lt;code&gt;type:name&lt;/code&gt;.</source>
          <target state="translated">注册一个工厂，该工厂可用于依赖项注入（带有 &lt;code&gt;inject&lt;/code&gt; ）或用于服务查找。每个工厂都注册有全名，包括两个部分： &lt;code&gt;type:name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f7e42ab82b7c92882f8e66014048c4f809e7e13" translate="yes" xml:space="preserve">
          <source>Registration keys have two segments split by a colon (&lt;code&gt;:&lt;/code&gt;). The first segment is the framework factory type, and the second is the name of the particular factory. Hence, the &lt;code&gt;index&lt;/code&gt; template has the key &lt;code&gt;template:index&lt;/code&gt;. Ember has several built-in factory types, such as &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;route&lt;/code&gt;, &lt;code&gt;template&lt;/code&gt;, and &lt;code&gt;component&lt;/code&gt;.</source>
          <target state="translated">登记键有一个冒号分开两个段（ &lt;code&gt;:&lt;/code&gt; ）。第一部分是框架工厂类型，第二部分是特定工厂的名称。因此， &lt;code&gt;index&lt;/code&gt; 模板具有键 &lt;code&gt;template:index&lt;/code&gt; 。Ember具有几种内置的工厂类型，例如 &lt;code&gt;service&lt;/code&gt; ， &lt;code&gt;route&lt;/code&gt; ， &lt;code&gt;template&lt;/code&gt; 和 &lt;code&gt;component&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74bb08da802a694a3d25bf4c3835ded58d2f6fc6" translate="yes" xml:space="preserve">
          <source>RegistryProxy</source>
          <target state="translated">RegistryProxy</target>
        </trans-unit>
        <trans-unit id="0a580368138bbedf511a06592637b0c30c98bec4" translate="yes" xml:space="preserve">
          <source>RegistryProxyMixin</source>
          <target state="translated">RegistryProxyMixin</target>
        </trans-unit>
        <trans-unit id="63a6a6ef6785a3cb9c1352a24ea4357d90e0f58f" translate="yes" xml:space="preserve">
          <source>RegistryProxyMixin  (private)</source>
          <target state="translated">RegistryProxyMixin (私人)</target>
        </trans-unit>
        <trans-unit id="0db97526891b25965235d31bf6cc3d8269a10d30" translate="yes" xml:space="preserve">
          <source>RegistryProxyMixin is used to provide public access to specific registry functionality.</source>
          <target state="translated">RegistryProxyMixin用于提供对特定注册表功能的公共访问。</target>
        </trans-unit>
        <trans-unit id="b4fc9c8d52106a97dfa0edae4264e66eed1c5b26" translate="yes" xml:space="preserve">
          <source>Regular npm packages</source>
          <target state="translated">常规npm包</target>
        </trans-unit>
        <trans-unit id="5f5b133edab536327af2bd039bb8a3451c0c686b" translate="yes" xml:space="preserve">
          <source>Rejected model promises halt transitions, but because promises are chainable, you can catch promise rejects within the &lt;code&gt;model&lt;/code&gt; hook itself and convert them into fulfills that won't halt the transition.</source>
          <target state="translated">拒绝的模型承诺会终止转换，但是由于承诺是可链接的，因此您可以在 &lt;code&gt;model&lt;/code&gt; 挂钩本身中捕获承诺拒绝，并将它们转换为不会停止过渡的实现。</target>
        </trans-unit>
        <trans-unit id="4345bd81dfdc7be3c7d907680b6150899b9077a3" translate="yes" xml:space="preserve">
          <source>RelationshipSchema</source>
          <target state="translated">RelationshipSchema</target>
        </trans-unit>
        <trans-unit id="229981dd1dc44fcc3bf72493583bb63fa236cecf" translate="yes" xml:space="preserve">
          <source>Relationships</source>
          <target state="translated">Relationships</target>
        </trans-unit>
        <trans-unit id="7ebee1cc4a1ef9624d817353b136be3fe22ab7fc" translate="yes" xml:space="preserve">
          <source>Relationships are usually represented by ids to the record in the relationship. The related records can then be sideloaded in the response under a key for the type.</source>
          <target state="translated">关系通常由关系中的记录的id来表示。然后,相关的记录可以在响应中侧载到类型的键下。</target>
        </trans-unit>
        <trans-unit id="d4abfee2fa163eac14a7ded7bb1fdab42b33f49a" translate="yes" xml:space="preserve">
          <source>Relationships as Promises</source>
          <target state="translated">作为承诺的关系</target>
        </trans-unit>
        <trans-unit id="34bad3622d708d6c624e5f19e7f5f5bb00dbbb2d" translate="yes" xml:space="preserve">
          <source>Relevant keywords for search.</source>
          <target state="translated">相关关键词进行搜索。</target>
        </trans-unit>
        <trans-unit id="282e0c1116f45802ea510d978c4bb1aaeda3e638" translate="yes" xml:space="preserve">
          <source>Reload the record from the adapter.</source>
          <target state="translated">从适配器上重新加载记录。</target>
        </trans-unit>
        <trans-unit id="b9032b6f32f6e2281f4ae7c18e28a848286c6415" translate="yes" xml:space="preserve">
          <source>Reloading</source>
          <target state="translated">Reloading</target>
        </trans-unit>
        <trans-unit id="4d8114b387125160739c4384d9e4a3715ae113c8" translate="yes" xml:space="preserve">
          <source>Reloads all of the records in the manyArray. If the manyArray holds a relationship that was originally fetched using a links url Ember Data will revisit the original links url to repopulate the relationship.</source>
          <target state="translated">重新加载manyArray中的所有记录。如果manyArray持有一个最初使用链接网址获取的关系,Ember Data将重新访问最初的链接网址来重新填充关系。</target>
        </trans-unit>
        <trans-unit id="d6324829793579791ae457de1efbafabdce16f68" translate="yes" xml:space="preserve">
          <source>Reloads the record if it is already loaded. If the record is not loaded it will load the record via &lt;code&gt;store.findRecord&lt;/code&gt;</source>
          <target state="translated">重新加载记录（如果已加载）。如果未加载记录， &lt;code&gt;store.findRecord&lt;/code&gt; 通过store.findRecord加载记录</target>
        </trans-unit>
        <trans-unit id="5bd1485c9bed37c1cf2bf2094bc180edee39e981" translate="yes" xml:space="preserve">
          <source>Reloads this has-many relationship.</source>
          <target state="translated">重新加载这个has-many关系。</target>
        </trans-unit>
        <trans-unit id="59de02ca246fcb0ddd1b90d1b40ad31e348afc0d" translate="yes" xml:space="preserve">
          <source>Reloads this has-many relationship. This causes a request to the specified relationship link or reloads all items currently in the relationship.</source>
          <target state="translated">重新加载这个has-many关系。这将导致对指定关系链接的请求,或者重载关系中当前的所有项目。</target>
        </trans-unit>
        <trans-unit id="f4276922880097708e01378b7c926ae47b0ca730" translate="yes" xml:space="preserve">
          <source>Relying on autoruns is not a rigorous or efficient way to use the run loop. Wrapping event handlers manually are preferred.</source>
          <target state="translated">依靠自动运行并不是使用运行循环的严格或有效方式。最好是手动封装事件处理程序。</target>
        </trans-unit>
        <trans-unit id="4656fc9d7b003300b618f2b5e454b26fe556d1b6" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;{{firstName}}&lt;/code&gt; and &lt;code&gt;{{lastName}}&lt;/code&gt; are bound data. That means if the value of one of those properties changes, the DOM will be updated automatically.</source>
          <target state="translated">请记住， &lt;code&gt;{{firstName}}&lt;/code&gt; 和 &lt;code&gt;{{lastName}}&lt;/code&gt; 是绑定数据。这意味着，如果这些属性之一的值更改，则DOM将自动更新。</target>
        </trans-unit>
        <trans-unit id="685e29f4b662e2c0f1a0744e653894d1da2671ad" translate="yes" xml:space="preserve">
          <source>Remember that &lt;em&gt;only events&lt;/em&gt; should ever cause a state transition. You should never call &lt;code&gt;transitionTo()&lt;/code&gt; from outside a state's event handler. If you are tempted to do so, create a new event and send that to the state manager.</source>
          <target state="translated">请记住，&lt;em&gt;只有事件&lt;/em&gt;才能引起状态转换。您永远不要从状态的事件处理程序外部调用 &lt;code&gt;transitionTo()&lt;/code&gt; 。如果您愿意这样做，请创建一个新事件并将其发送给状态管理器。</target>
        </trans-unit>
        <trans-unit id="2772f3979b8490dfd9afc9103221e01e92eba84f" translate="yes" xml:space="preserve">
          <source>Remove a previously added helper method.</source>
          <target state="translated">删除之前添加的帮助方法。</target>
        </trans-unit>
        <trans-unit id="6c924c7cc754f0fab9bce280a8c42f9e3cff21cd" translate="yes" xml:space="preserve">
          <source>Remove all elements from the array. This is useful if you want to reuse an existing array without having to recreate it.</source>
          <target state="translated">从数组中删除所有元素。如果你想重复使用一个现有的数组而不需要重新创建它,这很有用。</target>
        </trans-unit>
        <trans-unit id="f6355dee47de1f32bf6f9799d78b6fee6bcd492e" translate="yes" xml:space="preserve">
          <source>Remove all occurrences of an object in the array.</source>
          <target state="translated">删除数组中所有对象的出现。</target>
        </trans-unit>
        <trans-unit id="152c1eaa085138cfa9d77a0942ce9534a3d76fe7" translate="yes" xml:space="preserve">
          <source>Remove an event listener</source>
          <target state="translated">移除事件监听器</target>
        </trans-unit>
        <trans-unit id="4aa91b51bc12a3f5d89e5b53340b91ffc806cb11" translate="yes" xml:space="preserve">
          <source>Remove an object at the specified index using the &lt;code&gt;replace()&lt;/code&gt; primitive method. You can pass either a single index, or a start and a length.</source>
          <target state="translated">使用 &lt;code&gt;replace()&lt;/code&gt; 基本方法删除指定索引处的对象。您可以传递单个索引，也可以传递起点和长度。</target>
        </trans-unit>
        <trans-unit id="b8553b7b30d27bd6e52896284d645032511283c5" translate="yes" xml:space="preserve">
          <source>Remove an observer you have previously registered on this object. Pass the same key, target, and method you passed to &lt;code&gt;addObserver()&lt;/code&gt; and your target will no longer receive notifications.</source>
          <target state="translated">删除您先前在该对象上注册的观察者。传递与传递给 &lt;code&gt;addObserver()&lt;/code&gt; 相同的键，目标和方法，目标将不再接收通知。</target>
        </trans-unit>
        <trans-unit id="1fff707f00d08e1f5dfe2689260813207706b7e3" translate="yes" xml:space="preserve">
          <source>Removes an array observer from the object if the observer is current registered. Calling this method multiple times with the same object will have no effect.</source>
          <target state="translated">如果数组观察者是当前注册的,则从对象中删除该观察者。对同一对象多次调用此方法将不会有任何影响。</target>
        </trans-unit>
        <trans-unit id="3723e36afe7e7b4392638a97cc108f54843aa4a5" translate="yes" xml:space="preserve">
          <source>Removes each object in the passed array from the receiver.</source>
          <target state="translated">从接收者的数组中删除每个对象。</target>
        </trans-unit>
        <trans-unit id="18f9a7bd887e2ad04e12b6586614eadc5a5bf73f" translate="yes" xml:space="preserve">
          <source>Removes each object in the passed enumerable from the receiver.</source>
          <target state="translated">从接收器中删除传递的枚举对象。</target>
        </trans-unit>
        <trans-unit id="878c0c65b88d3bf26a4e986890bfb205e92a4a9b" translate="yes" xml:space="preserve">
          <source>Removes identifiers from the &lt;code&gt;RecordArray&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;RecordArray&lt;/code&gt; 中删除标识符。</target>
        </trans-unit>
        <trans-unit id="53ebb1fef0864af0278ae31f4ac0ec30dc3e82ad" translate="yes" xml:space="preserve">
          <source>Removing Objects</source>
          <target state="translated">移除对象</target>
        </trans-unit>
        <trans-unit id="6d84c2db53b8c4b4553001a5c3d3b995a8fc5d9b" translate="yes" xml:space="preserve">
          <source>Removing Relationships</source>
          <target state="translated">移除关系</target>
        </trans-unit>
        <trans-unit id="9f698ccebc9b22f6dbcefd96182ce1c685d4fb77" translate="yes" xml:space="preserve">
          <source>Removing jQuery completely</source>
          <target state="translated">完全删除jQuery</target>
        </trans-unit>
        <trans-unit id="041f6ca8e2d2dc5b856e1d078db74ba2885f4518" translate="yes" xml:space="preserve">
          <source>Rendering Performance</source>
          <target state="translated">渲染性能</target>
        </trans-unit>
        <trans-unit id="78e1949446438590a34392113638b5521c9fcf75" translate="yes" xml:space="preserve">
          <source>Rendering Tests</source>
          <target state="translated">渲染测试</target>
        </trans-unit>
        <trans-unit id="0985a0ecfabc2231124bd8de762617aaeafd5bd5" translate="yes" xml:space="preserve">
          <source>Rendering a Template</source>
          <target state="translated">渲染模板</target>
        </trans-unit>
        <trans-unit id="67db7b0b091d6d767654968bfc75b8a1cf8456c3" translate="yes" xml:space="preserve">
          <source>Rendering tests (integration tests) check how a &lt;strong&gt;component looks and behaves&lt;/strong&gt;. Ember CLI creates rendering tests for &lt;a href=&quot;https://guides.emberjs.com/components/defining-a-component/&quot;&gt;components&lt;/a&gt; and &lt;a href=&quot;https://guides.emberjs.com/templates/writing-helpers/&quot;&gt;helpers&lt;/a&gt;.</source>
          <target state="translated">渲染测试（集成测试）检查&lt;strong&gt;组件的外观和行为&lt;/strong&gt;。Ember CLI为&lt;a href=&quot;https://guides.emberjs.com/components/defining-a-component/&quot;&gt;组件&lt;/a&gt;和&lt;a href=&quot;https://guides.emberjs.com/templates/writing-helpers/&quot;&gt;助手&lt;/a&gt;创建渲染测试。</target>
        </trans-unit>
        <trans-unit id="f641e50ecb0ef4a6143f745a23c883acd88a466b" translate="yes" xml:space="preserve">
          <source>Rendering tests (previously known as integration tests)</source>
          <target state="translated">渲染测试(以前称为集成测试)</target>
        </trans-unit>
        <trans-unit id="7e00afed9568e851f563f95aa0fc07a60bfd0ba4" translate="yes" xml:space="preserve">
          <source>Rendering tests let you test components using Ember's rendering engine. This means, a component created in your rendering test will behave as it would in the real app. You are guaranteed that the component will follow its lifecycle hooks. You can also interact with the component like an end-user would.</source>
          <target state="translated">渲染测试可以让你使用Ember的渲染引擎测试组件。这意味着,在你的渲染测试中创建的组件将和真实应用中一样。你可以保证组件将遵循其生命周期的钩子。你也可以像终端用户一样与组件进行交互。</target>
        </trans-unit>
        <trans-unit id="3bf2cfd82c10e27a15ca73d1aff040c4b9aabd81" translate="yes" xml:space="preserve">
          <source>Renders the view again. This will work regardless of whether the view is already in the DOM or not. If the view is in the DOM, the rendering process will be deferred to give bindings a chance to synchronize.</source>
          <target state="translated">再次渲染视图。无论视图是否已经在DOM中,这都是有效的。如果视图在DOM中,渲染过程将被推迟,以便给绑定一个同步的机会。</target>
        </trans-unit>
        <trans-unit id="90fcf58a93bf37c133e53c27b59ac552b7f86095" translate="yes" xml:space="preserve">
          <source>Reopening Classes and Instances</source>
          <target state="translated">重开类和实例</target>
        </trans-unit>
        <trans-unit id="68fd737319a0b0cb58525f439e8f98a23d49c821" translate="yes" xml:space="preserve">
          <source>Replace all the receiver's content with content of the argument. If argument is an empty array receiver will be cleared.</source>
          <target state="translated">用参数的内容替换接收器的所有内容。如果参数是一个空数组,接收器将被清空。</target>
        </trans-unit>
        <trans-unit id="12205427cfdf5328a7ffdc0d916e8bdc2aeef4ed" translate="yes" xml:space="preserve">
          <source>Replacement for &lt;code&gt;Ember.RSVP.resolve&lt;/code&gt; The only difference is this uses an instance of &lt;code&gt;Ember.Test.Promise&lt;/code&gt;</source>
          <target state="translated">替换为 &lt;code&gt;Ember.RSVP.resolve&lt;/code&gt; 唯一的区别是，这使用了一个 &lt;code&gt;Ember.Test.Promise&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="38df34ec5043e01b14b58ab782972627050d5e4e" translate="yes" xml:space="preserve">
          <source>Replaces underscores, spaces, or camelCase with dashes.</source>
          <target state="translated">用破折号代替下划线、空格或大写字母。</target>
        </trans-unit>
        <trans-unit id="551c187c4562e07235299d81c81fb5553d3be6b8" translate="yes" xml:space="preserve">
          <source>Replacing history entries</source>
          <target state="translated">替换历史条目</target>
        </trans-unit>
        <trans-unit id="db33df2b86e0548c5026c0e2feca083dd46c73b8" translate="yes" xml:space="preserve">
          <source>Reporting a problem</source>
          <target state="translated">报告问题</target>
        </trans-unit>
        <trans-unit id="5a3259ad102284e341592f2a49ccbc5935cfc92a" translate="yes" xml:space="preserve">
          <source>Represents a list of records whose membership is determined by the store. As records are created, loaded, or modified, the store evaluates them to determine if they should be part of the record array.</source>
          <target state="translated">表示记录的列表,其成员资格由存储决定。当记录被创建、加载或修改时,存储会对它们进行评估,以确定它们是否应该成为记录数组的一部分。</target>
        </trans-unit>
        <trans-unit id="97471577bb242ec38248e3746d99aa261e14fdfd" translate="yes" xml:space="preserve">
          <source>Represents an ordered list of records whose order and membership is determined by the adapter. For example, a query sent to the adapter may trigger a search on the server, whose results would be loaded into an instance of the &lt;code&gt;AdapterPopulatedRecordArray&lt;/code&gt;.</source>
          <target state="translated">表示记录的有序列表，其顺序和成员资格由适配器确定。例如，发送给适配器的查询可能会触发服务器上的搜索，其结果将被加载到 &lt;code&gt;AdapterPopulatedRecordArray&lt;/code&gt; 的实例中。</target>
        </trans-unit>
        <trans-unit id="f983e24377129faa7d20942c23e23254dfe09a06" translate="yes" xml:space="preserve">
          <source>Represents the URL of the root of the application, often '/'. This prefix is assumed on all routes defined on this router.</source>
          <target state="translated">代表应用程序根的URL,通常是'/'。该路由器上定义的所有路由都使用这个前缀。</target>
        </trans-unit>
        <trans-unit id="99a531ee74a48c9f139d54302917c31212c36e9a" translate="yes" xml:space="preserve">
          <source>Represents the model's class name as a string. This can be used to look up the model's class name through &lt;code&gt;DS.Store&lt;/code&gt;'s modelFor method.</source>
          <target state="translated">将模型的类名称表示为字符串。这可以用于通过 &lt;code&gt;DS.Store&lt;/code&gt; 的modelFor方法查找模型的类名。</target>
        </trans-unit>
        <trans-unit id="46266c1e4f3d4db7ab26dd4974b725ba8d500a8c" translate="yes" xml:space="preserve">
          <source>Represents the model's class name as a string. This can be used to look up the model's class name through &lt;code&gt;Store&lt;/code&gt;'s modelFor method.</source>
          <target state="translated">将模型的类名称表示为字符串。这可以用于通过 &lt;code&gt;Store&lt;/code&gt; 的modelFor方法查找模型的类名。</target>
        </trans-unit>
        <trans-unit id="1a4d728aaa71b622cd6daaefae1957da6eba6abf" translate="yes" xml:space="preserve">
          <source>Request Errors</source>
          <target state="translated">请求错误</target>
        </trans-unit>
        <trans-unit id="ddf10a02bb0396e1c0bcad5c8cea1e4177da9463" translate="yes" xml:space="preserve">
          <source>Request Flow</source>
          <target state="translated">申请流程</target>
        </trans-unit>
        <trans-unit id="6a446bfa5dd57c064db5b7db62b9216d2d4fe7f6" translate="yes" xml:space="preserve">
          <source>Requests for &lt;code&gt;person&lt;/code&gt; would now target &lt;code&gt;/person/1&lt;/code&gt;. Requests for &lt;code&gt;user-profile&lt;/code&gt; would now target &lt;code&gt;/user_profile/1&lt;/code&gt;.</source>
          <target state="translated">现在，请求 &lt;code&gt;person&lt;/code&gt; 的目标是 &lt;code&gt;/person/1&lt;/code&gt; 。现在，对 &lt;code&gt;user-profile&lt;/code&gt; 请求将以 &lt;code&gt;/user_profile/1&lt;/code&gt; 为目标。</target>
        </trans-unit>
        <trans-unit id="e23fb7f5045063dea88f661c92bdf8761f6d2db8" translate="yes" xml:space="preserve">
          <source>Requests for &lt;code&gt;person&lt;/code&gt; would now target &lt;code&gt;http://emberjs.com/api/1/people/1&lt;/code&gt;.</source>
          <target state="translated">现在，对 &lt;code&gt;person&lt;/code&gt; 请求将定位为 &lt;code&gt;http://emberjs.com/api/1/people/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8662a972a8167c817a2396b8c370f76230f2940" translate="yes" xml:space="preserve">
          <source>Requests for &lt;code&gt;person&lt;/code&gt; would now target &lt;code&gt;https://api.emberjs.com/api/1/people/1&lt;/code&gt;.</source>
          <target state="translated">现在，对 &lt;code&gt;person&lt;/code&gt; 请求将定位到 &lt;code&gt;https://api.emberjs.com/api/1/people/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbed8372b111ece5b7dea26366e56a504eeb78ba" translate="yes" xml:space="preserve">
          <source>Requests for &lt;code&gt;person&lt;/code&gt; would now target &lt;code&gt;https://api.example.com/people/1&lt;/code&gt;.</source>
          <target state="translated">现在，针对 &lt;code&gt;person&lt;/code&gt; 请求将定位到 &lt;code&gt;https://api.example.com/people/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39adf7b336b15481b1d246e2d2e38d4faf23c063" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;Person&lt;/code&gt; model would now target &lt;code&gt;/api/1/people/1&lt;/code&gt;.</source>
          <target state="translated">现在，对 &lt;code&gt;Person&lt;/code&gt; 模型的请求将定位 &lt;code&gt;/api/1/people/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5a6ae7596913135d59e602a8445cd7c591187b4" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;Post&lt;/code&gt; model would now target &lt;code&gt;/api/1/post/&lt;/code&gt;.</source>
          <target state="translated">现在，对 &lt;code&gt;Post&lt;/code&gt; 模型的请求将定位 &lt;code&gt;/api/1/post/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47352f3ca02fa7dd1203791432c99adf3ee88922" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;Post&lt;/code&gt; model would now target &lt;code&gt;https://api.example.com/post/&lt;/code&gt;.</source>
          <target state="translated">现在，对 &lt;code&gt;Post&lt;/code&gt; 模型的请求将定位到 &lt;code&gt;https://api.example.com/post/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="507eba662c0bdfc5e6dcd2e527c591cbe849d43c" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;person&lt;/code&gt; model would now target &lt;code&gt;/api/1/people/1&lt;/code&gt;.</source>
          <target state="translated">现在，针对 &lt;code&gt;person&lt;/code&gt; 模型的请求将定位 &lt;code&gt;/api/1/people/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c77ddbd00374e8cd6c0cc4272b91fdfbb3d601e3" translate="yes" xml:space="preserve">
          <source>Requests for the &lt;code&gt;person&lt;/code&gt; model would now target &lt;code&gt;https://api.example.com/people/1&lt;/code&gt;.</source>
          <target state="translated">现在，针对 &lt;code&gt;person&lt;/code&gt; 模型的请求将定位为 &lt;code&gt;https://api.example.com/people/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e190e5d005c3ed64981ff2ea4572bff204aed4b0" translate="yes" xml:space="preserve">
          <source>Requests in Components</source>
          <target state="translated">组件中的请求</target>
        </trans-unit>
        <trans-unit id="51c8ad35eaad89bb264b06a831b0f1c6c203b261" translate="yes" xml:space="preserve">
          <source>Requests in Services</source>
          <target state="translated">服务中的请求</target>
        </trans-unit>
        <trans-unit id="a1c0056db49c0064449972ec5b173f83fa648732" translate="yes" xml:space="preserve">
          <source>Requests in a Route's &lt;code&gt;model&lt;/code&gt; hook</source>
          <target state="translated">路线 &lt;code&gt;model&lt;/code&gt; 挂钩中的请求</target>
        </trans-unit>
        <trans-unit id="bd278c9727c891a2d697427de980af3125d812f7" translate="yes" xml:space="preserve">
          <source>Requests in services have the same drawbacks as Components. Functions and state in a Service can be used almost anywhere in the app.</source>
          <target state="translated">服务中的请求具有与组件相同的缺点。服务中的函数和状态几乎可以在应用程序的任何地方使用。</target>
        </trans-unit>
        <trans-unit id="ef47fdb02ee01d8a4e88ea5e1d94c9f92f4cd4c9" translate="yes" xml:space="preserve">
          <source>Required &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">需要 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ea99c4b89bd3e73a15c7dfe3ef60bd94d5f0728" translate="yes" xml:space="preserve">
          <source>Required &lt;code&gt;this&lt;/code&gt; in templates</source>
          <target state="translated">模板中需要 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d1ce0dbae3dcf8f899bd4893d4663dda4cf2c7d" translate="yes" xml:space="preserve">
          <source>Rerun your test suite as you make updates to your workflow file and you should validate that your deprecations are gone. Once that is completed, you can proceed with enhancing your application without the sea of deprecation warnings clouding your log.</source>
          <target state="translated">当你对工作流文件进行更新时,重新运行你的测试套件,你应该会确认你的废弃文件已经消失了。一旦完成,你就可以继续增强你的应用程序,而不用再被海量的弃用警告所困扰。</target>
        </trans-unit>
        <trans-unit id="1459337c0ecc835d1d2041391957329cf96ed92d" translate="yes" xml:space="preserve">
          <source>Reset the application. This is typically used only in tests. It cleans up the application in the following order:</source>
          <target state="translated">重置应用程序。这通常只在测试中使用。它按以下顺序清理应用程序。</target>
        </trans-unit>
        <trans-unit id="9799189643ce709a24fb886e74561834ed7c1a6f" translate="yes" xml:space="preserve">
          <source>Resetting Presentation State on Attribute Change with &lt;code&gt;didUpdateAttrs&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;didUpdateAttrs&lt;/code&gt; 在属性更改上重置演示状态</target>
        </trans-unit>
        <trans-unit id="bed023e0df790a0e66439a5a1e1a05337670d105" translate="yes" xml:space="preserve">
          <source>Respecting the URL results in better user experience</source>
          <target state="translated">尊重URL会带来更好的用户体验。</target>
        </trans-unit>
        <trans-unit id="14de0ea979680e88715bf0fb25e6a27c36244df1" translate="yes" xml:space="preserve">
          <source>Responding to Browser Events</source>
          <target state="translated">响应浏览器事件</target>
        </trans-unit>
        <trans-unit id="86514db4ea326cca476f8161d03fbe8c00199720" translate="yes" xml:space="preserve">
          <source>Responding to user interactions</source>
          <target state="translated">回应用户的互动</target>
        </trans-unit>
        <trans-unit id="38ad8517f1dfe99e4d87fbdbdd90a3a14b28b872" translate="yes" xml:space="preserve">
          <source>Restrictions</source>
          <target state="translated">Restrictions</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">结果在:</target>
        </trans-unit>
        <trans-unit id="5dd10def5c86f482d9171ac3d500c6b0ae25364b" translate="yes" xml:space="preserve">
          <source>Resumes a test paused by &lt;code&gt;pauseTest&lt;/code&gt;.</source>
          <target state="translated">恢复由 &lt;code&gt;pauseTest&lt;/code&gt; 暂停的测试。</target>
        </trans-unit>
        <trans-unit id="ea776300d8aba3829da1ffb0408566a09e4e259f" translate="yes" xml:space="preserve">
          <source>Retries a previously-aborted transition (making sure to abort the transition if it's still active). Returns a new transition that represents the new attempt to transition.</source>
          <target state="translated">重试一个先前中止的过渡(如果过渡仍然有效,请确保中止该过渡)。返回一个新的过渡,代表新的过渡尝试。</target>
        </trans-unit>
        <trans-unit id="c136ec01ad8662f631bfe9cf5dd76daebe9695f1" translate="yes" xml:space="preserve">
          <source>Retrieves the value of a property from an Object, or a default value in the case that the property returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">从Object检索属性的值，如果属性返回 &lt;code&gt;undefined&lt;/code&gt; ，则检索默认值。</target>
        </trans-unit>
        <trans-unit id="97f8358f1a7527129a6026137d59d3b142bea4da" translate="yes" xml:space="preserve">
          <source>Retrieves the value of a property from the object.</source>
          <target state="translated">检索对象的属性值。</target>
        </trans-unit>
        <trans-unit id="c2507d71833d1926fc8ca2bfcba6650b2356a523" translate="yes" xml:space="preserve">
          <source>Retrieves the value of a property, or a default value in the case that the property returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">检索属性的值，如果属性返回 &lt;code&gt;undefined&lt;/code&gt; ，则检索默认值。</target>
        </trans-unit>
        <trans-unit id="c9b109a01cbb856b78796ff1f23e3ed037d6d59e" translate="yes" xml:space="preserve">
          <source>Retrieving Multiple Records</source>
          <target state="translated">检索多个记录</target>
        </trans-unit>
        <trans-unit id="f585070c87519f1f46d5aa282e338ef3ef4cffe8" translate="yes" xml:space="preserve">
          <source>Retrieving Related Model Records</source>
          <target state="translated">检索相关模型记录</target>
        </trans-unit>
        <trans-unit id="5763b513c21e726fa47e619aeec98e7a63c47120" translate="yes" xml:space="preserve">
          <source>Retrieving Related Records</source>
          <target state="translated">检索相关记录</target>
        </trans-unit>
        <trans-unit id="f42b92f006ec325e98a3d7f40334441d8ddf5a15" translate="yes" xml:space="preserve">
          <source>Retrieving Specific Fields by Type</source>
          <target state="translated">按类型检索特定字段</target>
        </trans-unit>
        <trans-unit id="3ea11ae149c9ff5b4ef4d8e06d23a82d3df6baab" translate="yes" xml:space="preserve">
          <source>Retrieving a Single Record</source>
          <target state="translated">检索单个记录</target>
        </trans-unit>
        <trans-unit id="9cd9632ea5c6744340a949d9498150ea0dd8d956" translate="yes" xml:space="preserve">
          <source>Return a specific registered option for a particular factory.</source>
          <target state="translated">返回特定工厂的特定注册选项。</target>
        </trans-unit>
        <trans-unit id="29ebe6c216062fb1ce4cf798a7f1e3baeab920a9" translate="yes" xml:space="preserve">
          <source>Return registered options for a particular factory.</source>
          <target state="translated">返回特定工厂的注册选项。</target>
        </trans-unit>
        <trans-unit id="26b22776384430c648a6b859ff17b84f59ea040d" translate="yes" xml:space="preserve">
          <source>Return the new cumulative value.</source>
          <target state="translated">返回新的累积值。</target>
        </trans-unit>
        <trans-unit id="edee4fec8219eea58f41fb844b109d44f9727045" translate="yes" xml:space="preserve">
          <source>Return the registered options for all factories of a type.</source>
          <target state="translated">返回一个类型的所有工厂的注册选项。</target>
        </trans-unit>
        <trans-unit id="3f2c37eae2ce5f96df692aaeedf57af072ef9d9e" translate="yes" xml:space="preserve">
          <source>Return to Step 1</source>
          <target state="translated">返回步骤1</target>
        </trans-unit>
        <trans-unit id="86661c3a6c5cd6befa4e37cc90df459f0d9bf691" translate="yes" xml:space="preserve">
          <source>Return value from invoking the passed function. Please note, when called within an existing loop, no return value is possible.</source>
          <target state="translated">调用传递的函数的返回值。请注意,在现有循环中调用时,不可能返回值。</target>
        </trans-unit>
        <trans-unit id="19e15fef1135e42fb3ddbd944fd5ba42b4c44461" translate="yes" xml:space="preserve">
          <source>Return values from a component with &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">从具有 &lt;code&gt;yield&lt;/code&gt; 的组件返回值</target>
        </trans-unit>
        <trans-unit id="f303cd37013bf328626e038174b28974872e0cbc" translate="yes" xml:space="preserve">
          <source>Returning a &lt;code&gt;DS.InvalidError&lt;/code&gt; from this method will cause the record to transition into the &lt;code&gt;invalid&lt;/code&gt; state and make the &lt;code&gt;errors&lt;/code&gt; object available on the record. When returning an &lt;code&gt;DS.InvalidError&lt;/code&gt; the store will attempt to normalize the error data returned from the server using the serializer's &lt;code&gt;extractErrors&lt;/code&gt; method.</source>
          <target state="translated">从此方法返回 &lt;code&gt;DS.InvalidError&lt;/code&gt; 将导致记录转换为 &lt;code&gt;invalid&lt;/code&gt; 状态，并使 &lt;code&gt;errors&lt;/code&gt; 对象在记录上可用。返回 &lt;code&gt;DS.InvalidError&lt;/code&gt; 时，存储区将尝试使用序列化程序的 &lt;code&gt;extractErrors&lt;/code&gt; 方法来标准化从服务器返回的错误数据。</target>
        </trans-unit>
        <trans-unit id="d76aa8210cf0dafd3f5542c252c74215e7c0d82e" translate="yes" xml:space="preserve">
          <source>Returning a &lt;code&gt;InvalidError&lt;/code&gt; from this method will cause the record to transition into the &lt;code&gt;invalid&lt;/code&gt; state and make the &lt;code&gt;errors&lt;/code&gt; object available on the record. When returning an &lt;code&gt;InvalidError&lt;/code&gt; the store will attempt to normalize the error data returned from the server using the serializer's &lt;code&gt;extractErrors&lt;/code&gt; method.</source>
          <target state="translated">从此方法返回 &lt;code&gt;InvalidError&lt;/code&gt; 将导致记录转换为 &lt;code&gt;invalid&lt;/code&gt; 状态，并使 &lt;code&gt;errors&lt;/code&gt; 对象在记录中可用。返回 &lt;code&gt;InvalidError&lt;/code&gt; 时，存储区将尝试使用序列化程序的 &lt;code&gt;extractErrors&lt;/code&gt; 方法对从服务器返回的错误数据进行规范化。</target>
        </trans-unit>
        <trans-unit id="cee47736237de7f8bb7ea807b0ee3fa5be36f81b" translate="yes" xml:space="preserve">
          <source>Returns -1 if no match is found.</source>
          <target state="translated">如果没有找到匹配,则返回-1。</target>
        </trans-unit>
        <trans-unit id="5eb7b0965957835e626048810b6a5e9b19ca1f4e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;routeName/models/queryParams&lt;/code&gt; is the active route, where &lt;code&gt;models&lt;/code&gt; and &lt;code&gt;queryParams&lt;/code&gt; are optional. See &lt;a href=&quot;api/ember/release/classes/route/methods#model&quot;&gt;model&lt;/a&gt; and &lt;a href=&quot;https://api.emberjs.com/api/ember/3.7/classes/Route/properties#queryParams&quot;&gt;queryParams&lt;/a&gt; for more information about these arguments.</source>
          <target state="translated">如果 &lt;code&gt;routeName/models/queryParams&lt;/code&gt; 是活动路由，则返回 &lt;code&gt;true&lt;/code&gt; ，其中 &lt;code&gt;models&lt;/code&gt; 和 &lt;code&gt;queryParams&lt;/code&gt; 是可选的。有关这些参数的更多信息，请参见&lt;a href=&quot;api/ember/release/classes/route/methods#model&quot;&gt;model&lt;/a&gt;和&lt;a href=&quot;https://api.emberjs.com/api/ember/3.7/classes/Route/properties#queryParams&quot;&gt;queryParams&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85b812af2c70b17fb4a0e4704404e2e2663bc781" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed function returns true for any item in the enumeration.</source>
          <target state="translated">如果传递的函数对枚举中的任何项目返回 &lt;code&gt;true&lt;/code&gt; ,则返回true。</target>
        </trans-unit>
        <trans-unit id="f60ba937bfb0a86b00fcc64b5fa06c54faa1208f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed function returns true for every item in the enumeration. This corresponds with the &lt;code&gt;Array.prototype.every()&lt;/code&gt; method defined in ES5.</source>
          <target state="translated">如果传递的函数对枚举中的每个项目都返回 &lt;code&gt;true&lt;/code&gt; ,则返回true。这与ES5中定义的 &lt;code&gt;Array.prototype.every()&lt;/code&gt; 方法相对应。</target>
        </trans-unit>
        <trans-unit id="0ca1e9e1279673b31d55774d9185dc03beed7b19" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed function returns true for every item in the enumeration. This corresponds with the &lt;code&gt;every()&lt;/code&gt; method in JavaScript 1.6.</source>
          <target state="translated">如果传递的函数对枚举中的每个项目都返回 &lt;code&gt;true&lt;/code&gt; ,则返回true。这与JavaScript 1.6中的 &lt;code&gt;every()&lt;/code&gt; 方法相对应。</target>
        </trans-unit>
        <trans-unit id="48e8bff0730db4951905ce3907f251ae28d439c0" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed object can be found in the array. This method is a Polyfill for ES 2016 Array.includes. If no &lt;code&gt;startAt&lt;/code&gt; argument is given, the starting location to search is 0. If it's negative, searches from the index of &lt;code&gt;this.length + startAt&lt;/code&gt; by asc.</source>
          <target state="translated">如果可以在数组中找到传递的对象，则返回 &lt;code&gt;true&lt;/code&gt; 。此方法是ES 2016 Array.includes的Polyfill。如果未给出 &lt;code&gt;startAt&lt;/code&gt; 参数，则搜索的起始位置为0。如果为负，则从 &lt;code&gt;this.length + startAt&lt;/code&gt; 的索引中按asc搜索。</target>
        </trans-unit>
        <trans-unit id="97d2d4c6d57998537e2ece3978bd7eda8781ffbc" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed object can be found in the enumerable.</source>
          <target state="translated">如果可以在枚举中找到传递的对象，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59ba394095833f93ec360f4386b9490268271009" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed property resolves to the value of the second argument for all items in the array. This method is often simpler/faster than using a callback.</source>
          <target state="translated">如果传递的属性解析为数组中所有项目的第二个参数的值，则返回 &lt;code&gt;true&lt;/code&gt; 。与使用回调相比，此方法通常更简单/更快。</target>
        </trans-unit>
        <trans-unit id="5e0cff20c4e03c114bb589de045dad56c4977ab9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed property resolves to the value of the second argument for all items in the enumerable. This method is often simpler/faster than using a callback.</source>
          <target state="translated">如果传递的属性解析为可枚举中所有项目的第二个参数的值，则返回 &lt;code&gt;true&lt;/code&gt; 。与使用回调相比，此方法通常更简单/更快。</target>
        </trans-unit>
        <trans-unit id="19694ec1d241ea3ac0257cd094f61a4584115eaf" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed property resolves to the value of the second argument for any item in the array. This method is often simpler/faster than using a callback.</source>
          <target state="translated">如果传递的属性解析为数组中任何项目的第二个参数的值，则返回 &lt;code&gt;true&lt;/code&gt; 。与使用回调相比，此方法通常更简单/更快。</target>
        </trans-unit>
        <trans-unit id="785710d311908f0da91ca0999d02fda0b1b3f90e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the passed property resolves to the value of the second argument for any item in the enumerable. This method is often simpler/faster than using a callback.</source>
          <target state="translated">如果传递的属性解析为可枚举中任何项目的第二个参数的值，则返回 &lt;code&gt;true&lt;/code&gt; 。与使用回调相比，此方法通常更简单/更快。</target>
        </trans-unit>
        <trans-unit id="125bbdbd31c014a3c75ab73874ead547c5f9f32b" translate="yes" xml:space="preserve">
          <source>Returns a consistent type for the passed object.</source>
          <target state="translated">返回传递对象的一致类型。</target>
        </trans-unit>
        <trans-unit id="d5e31a7796519c4db2aefafeb16832aabfafcd9e" translate="yes" xml:space="preserve">
          <source>Returns a copy of the array with all &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; elements removed.</source>
          <target state="translated">返回删除了所有 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 元素的数组的副本。</target>
        </trans-unit>
        <trans-unit id="2b92287589187fde80aa3c9745f11bf4566c0019" translate="yes" xml:space="preserve">
          <source>Returns a hash containing the parameters of an ancestor route.</source>
          <target state="translated">返回一个包含祖先路由参数的哈希值。</target>
        </trans-unit>
        <trans-unit id="b4ada03057da551460d8be699ac1083dbb48fb4c" translate="yes" xml:space="preserve">
          <source>Returns a jQuery object for this component's element. If you pass in a selector string, this method will return a jQuery object, using the current element as its buffer.</source>
          <target state="translated">返回该组件元素的jQuery对象。如果你传递了一个选择器字符串,这个方法将返回一个jQuery对象,使用当前元素作为它的缓冲区。</target>
        </trans-unit>
        <trans-unit id="2703351044d1524246ab647abe9d450da6a2453f" translate="yes" xml:space="preserve">
          <source>Returns a jQuery object for this component's element. If you pass in a selector string, this method will return a jQuery object, using the current element as its buffer. For example, calling &lt;code&gt;component.$('li')&lt;/code&gt; will return a jQuery object containing all of the &lt;code&gt;li&lt;/code&gt; elements inside the DOM element of this component.</source>
          <target state="translated">返回此组件元素的jQuery对象。如果传入选择器字符串，则此方法将返回jQuery对象，并使用当前元素作为其缓冲区。例如，调用 &lt;code&gt;component.$('li')&lt;/code&gt; 将返回一个jQuery对象，其中包含该组件DOM元素内的所有 &lt;code&gt;li&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="8a47cf2c5ff6ea84daf5839f6f90517c7d1d2ada" translate="yes" xml:space="preserve">
          <source>Returns a jQuery object for this view's element. If you pass in a selector string, this method will return a jQuery object, using the current element as its buffer.</source>
          <target state="translated">返回此视图元素的jQuery对象。如果传入选择器字符串,本方法将返回一个jQuery对象,使用当前元素作为缓冲区。</target>
        </trans-unit>
        <trans-unit id="4ed70d04f3ee7207358048712104fcd24783ff91" translate="yes" xml:space="preserve">
          <source>Returns a new array that contains only items containing a unique property value. The default implementation returns an array regardless of the receiver type.</source>
          <target state="translated">返回一个新的数组,该数组只包含包含唯一属性值的项目。默认的实现是返回一个数组,与接收者类型无关。</target>
        </trans-unit>
        <trans-unit id="3ee49ab71f088094d7a6ef65373cff6aea3b838c" translate="yes" xml:space="preserve">
          <source>Returns a new array that contains only unique values. The default implementation returns an array regardless of the receiver type.</source>
          <target state="translated">返回一个只包含唯一值的新数组。默认的实现会返回一个数组,而不考虑接收器的类型。</target>
        </trans-unit>
        <trans-unit id="f535e0230de6304fca3d92bc4f17beb2ef84342a" translate="yes" xml:space="preserve">
          <source>Returns a new array that excludes the passed value. The default implementation returns an array regardless of the receiver type. If the receiver does not contain the value it returns the original array.</source>
          <target state="translated">返回一个新的数组,该数组不包括传递的值。默认的实现是返回一个数组,而不考虑接收方的类型。如果接收方不包含值,则返回原始数组。</target>
        </trans-unit>
        <trans-unit id="926fcdedb193ee950b728d011e0592df4e16f0a0" translate="yes" xml:space="preserve">
          <source>Returns a new array that is a slice of the receiver. This implementation uses the observable array methods to retrieve the objects for the new slice.</source>
          <target state="translated">返回一个新的数组,它是接收器的一个分片。本实现使用observable数组方法为新的分片检索对象。</target>
        </trans-unit>
        <trans-unit id="332a3f58f30615456cdeb690333df10511405cb9" translate="yes" xml:space="preserve">
          <source>Returns a new array with all of the items in the enumeration that the provided callback function returns true for. This method corresponds to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt;Array.prototype.filter()&lt;/a&gt;.</source>
          <target state="translated">返回一个新的数组，其中包含所提供的回调函数为其返回true的枚举中的所有项目。此方法对应于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt;Array.prototype.filter（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f490c002b2bf76e65c1ef0218a8c11e0b2f0ba00" translate="yes" xml:space="preserve">
          <source>Returns a new enumerable that contains only items containing a unique property value. The default implementation returns an array regardless of the receiver type.</source>
          <target state="translated">返回一个新的数组,它只包含包含唯一属性值的项目。默认的实现返回一个数组,与接收者类型无关。</target>
        </trans-unit>
        <trans-unit id="bdd3af7ab7b2da54382d05f7328e37ab891fb2d3" translate="yes" xml:space="preserve">
          <source>Returns a new enumerable that contains only unique values. The default implementation returns an array regardless of the receiver type.</source>
          <target state="translated">返回一个只包含唯一值的新枚举。默认的实现是返回一个数组,而不考虑接收器的类型。</target>
        </trans-unit>
        <trans-unit id="31c2891af58e7eda6b60e3cadcd876d663730e1c" translate="yes" xml:space="preserve">
          <source>Returns a new enumerable that excludes the passed value. The default implementation returns an array regardless of the receiver type. If the receiver does not contain the value it returns the original enumerable.</source>
          <target state="translated">返回一个新的不包含传递值的枚举值。默认的实现返回一个数组,而不考虑接收者的类型。如果接收方不包含值,则返回原来的枚举值。</target>
        </trans-unit>
        <trans-unit id="79b5522f2b1ae4f90cc466e02013320e2a3ad2b8" translate="yes" xml:space="preserve">
          <source>Returns a polymorphic relationship formatted as a JSON-API &quot;relationship object&quot;.</source>
          <target state="translated">Returns a polymorphic relationship formatted as a JSON-API &quot;relation object&quot;.</target>
        </trans-unit>
        <trans-unit id="da5d72f3f51387291e0c92700f8ccbb22c667d59" translate="yes" xml:space="preserve">
          <source>Returns a promise that is fulfilled when all the given promises have been fulfilled, or rejected if any of them become rejected. The returned promise is fulfilled with a hash that has the same key names as the &lt;code&gt;promises&lt;/code&gt; object argument. If any of the values in the object are not promises, they will simply be copied over to the fulfilled object.</source>
          <target state="translated">返回当所有给定的诺言都已兑现时已兑现的诺言，或者如果其中任何一个诺言被拒绝，则将其拒绝。返回的promise通过哈希实现，该哈希具有与 &lt;code&gt;promises&lt;/code&gt; 对象参数相同的键名。如果对象中的任何值都不是promise，则将它们简单地复制到实现的对象中。</target>
        </trans-unit>
        <trans-unit id="82c815d0ca08ef29364305f689eaaae5497c95e1" translate="yes" xml:space="preserve">
          <source>Returns a promise that is fulfilled when all the given promises have been settled, or rejected if the passed parameters are invalid.</source>
          <target state="translated">当所有给定的承诺都被解决后,返回一个承诺,如果传递的参数无效,则返回拒绝。</target>
        </trans-unit>
        <trans-unit id="6d3f9c4b4397f9ef81ee1535035150e16652f8d6" translate="yes" xml:space="preserve">
          <source>Returns a promise that is fulfilled when all the given promises have been settled. The return promise is fulfilled with an array of the states of the promises passed into the &lt;code&gt;promises&lt;/code&gt; array argument.</source>
          <target state="translated">返回已兑现所有给定诺言的诺言。返回承诺通过将 &lt;code&gt;promises&lt;/code&gt; 数组传递到promises数组参数中来实现。</target>
        </trans-unit>
        <trans-unit id="f6e385587e066b24048df3bceae7d07c05eb9136" translate="yes" xml:space="preserve">
          <source>Returns a relationship formatted as a JSON-API &quot;relationship object&quot;.</source>
          <target state="translated">返回一个以JSON-API &quot;关系对象 &quot;格式化的关系。</target>
        </trans-unit>
        <trans-unit id="52a97236412e0d9a5ce17c93a028e57570cea2e1" translate="yes" xml:space="preserve">
          <source>Returns a special object that can be used to observe individual properties on the array. Just get an equivalent property on this object and it will return an enumerable that maps automatically to the named key on the member objects.</source>
          <target state="translated">返回一个特殊的对象,可以用来观察数组上的各个属性。只要在这个对象上得到一个等价的属性,它就会返回一个自动映射到成员对象上的命名键的枚举对象。</target>
        </trans-unit>
        <trans-unit id="f1bb9132b749d70b8d6303a10f424698c9fb0eed" translate="yes" xml:space="preserve">
          <source>Returns a string representation which attempts to provide more information than Javascript's &lt;code&gt;toString&lt;/code&gt; typically does, in a generic way for all Ember objects.</source>
          <target state="translated">以通用方式返回所有Ember对象的字符串表示形式，该字符串表示试图提供比Java语言的 &lt;code&gt;toString&lt;/code&gt; 通常更多的信息。</target>
        </trans-unit>
        <trans-unit id="1baffde3c198a82c1a9f24fd1699b9537bf5a9f0" translate="yes" xml:space="preserve">
          <source>Returns a unique id for the object. If the object does not yet have a guid, one will be assigned to it. You can call this on any object, &lt;code&gt;Ember.Object&lt;/code&gt;-based or not, but be aware that it will add a &lt;code&gt;_guid&lt;/code&gt; property.</source>
          <target state="translated">返回对象的唯一ID。如果该对象还没有GUID，则会为其分配一个GUID。您可以在任何基于 &lt;code&gt;Ember.Object&lt;/code&gt; 的对象上调用此函数，但请注意，它将添加 &lt;code&gt;_guid&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="4fe073685bcbe50133bcaf9d9680a9bc1a21e5a7" translate="yes" xml:space="preserve">
          <source>Returns a unique id for the object. If the object does not yet have a guid, one will be assigned to it. You can call this on any object, &lt;code&gt;EmberObject&lt;/code&gt;-based or not.</source>
          <target state="translated">返回对象的唯一ID。如果该对象还没有GUID，则会为其分配一个GUID。您可以在任何基于 &lt;code&gt;EmberObject&lt;/code&gt; 的对象上调用此函数。</target>
        </trans-unit>
        <trans-unit id="1f4ec976109d986b5a79d48479eb69b877f9ce1c" translate="yes" xml:space="preserve">
          <source>Returns an array mapped to the specified key.</source>
          <target state="translated">返回一个映射到指定键的数组。</target>
        </trans-unit>
        <trans-unit id="b64d16ac418315ac651a71cfd903dcf3f4c1950a" translate="yes" xml:space="preserve">
          <source>Returns an array mapped via the callback</source>
          <target state="translated">返回一个通过回调映射的数组</target>
        </trans-unit>
        <trans-unit id="829d878e18002574178651ec68a61b50ed634687" translate="yes" xml:space="preserve">
          <source>Returns an array with all of the items in the enumeration that the passed function returns true for. This method corresponds to &lt;code&gt;filter()&lt;/code&gt; defined in JavaScript 1.6.</source>
          <target state="translated">返回一个数组，其中包含所传递函数为其返回true的枚举中的所有项目。此方法对应于JavaScript 1.6中定义的 &lt;code&gt;filter()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c71aa9a7da9062c13eb9514b5d81794253550ff0" translate="yes" xml:space="preserve">
          <source>Returns an array with all of the items in the enumeration where the passed function returns false. This method is the inverse of filter().</source>
          <target state="translated">返回一个数组,其中包含枚举中所有项目,传递的函数返回false。本方法是filter()的反演。</target>
        </trans-unit>
        <trans-unit id="78ff059f5f0f8f4ba1bb336fa61257c52bc1e554" translate="yes" xml:space="preserve">
          <source>Returns an array with just the items with the matched property. You can pass an optional second argument with the target value. Otherwise this will match any property that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">返回仅包含具有match属性的项目的数组。您可以传递带有目标值的可选第二个参数。否则，它将匹配任何评估为 &lt;code&gt;true&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="f5d725514851c9b11eac282307b62e805938ccc7" translate="yes" xml:space="preserve">
          <source>Returns an array with the items that do not have truthy values for key. You can pass an optional second argument with the target value. Otherwise this will match any property that evaluates to false.</source>
          <target state="translated">返回一个包含没有真值的项目的数组。你可以传递一个带有目标值的可选的第二个参数。否则将匹配任何评估为false的属性。</target>
        </trans-unit>
        <trans-unit id="3b041d1644fe8d55b45f0896022ff7a3e5e96227" translate="yes" xml:space="preserve">
          <source>Returns an array with the items that do not have truthy values for the provided key. You can pass an optional second argument with a target value to reject for the key. Otherwise this will reject objects where the provided property evaluates to false.</source>
          <target state="translated">返回一个数组,其中包含对所提供的键没有真值的项目。你可以传递一个可选的第二个参数,其中包含一个目标值来拒绝键。否则,将拒绝所提供的属性值为false的对象。</target>
        </trans-unit>
        <trans-unit id="1a3670a2d50cfc92881b423c60b1f1c2575feb6e" translate="yes" xml:space="preserve">
          <source>Returns an instance of the adapter for a given type. For example, &lt;code&gt;adapterFor('person')&lt;/code&gt; will return an instance of &lt;code&gt;App.PersonAdapter&lt;/code&gt;.</source>
          <target state="translated">返回给定类型的适配器的实例。例如， &lt;code&gt;adapterFor('person')&lt;/code&gt; 将返回 &lt;code&gt;App.PersonAdapter&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="673a33da06126a5640a2ab9e96c90786fc9c52f9" translate="yes" xml:space="preserve">
          <source>Returns an instance of the serializer for a given type. For example, &lt;code&gt;serializerFor('person')&lt;/code&gt; will return an instance of &lt;code&gt;App.PersonSerializer&lt;/code&gt;.</source>
          <target state="translated">返回给定类型的序列化程序的实例。例如， &lt;code&gt;serializerFor('person')&lt;/code&gt; 将返回 &lt;code&gt;App.PersonSerializer&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="57c8785371bfdb428b7960568f1bb17a9b411222" translate="yes" xml:space="preserve">
          <source>Returns an object that can be used to provide an owner to a manually created instance.</source>
          <target state="translated">返回一个可用于为手动创建的实例提供所有者的对象。</target>
        </trans-unit>
        <trans-unit id="fd2a4f6967074c15ba164a31f50b2fef12d1c233" translate="yes" xml:space="preserve">
          <source>Returns an object, whose keys are changed properties, and value is an [oldProp, newProp] array.</source>
          <target state="translated">返回一个对象,其键是改变了的属性,值是一个[oldProp,newProp]数组。</target>
        </trans-unit>
        <trans-unit id="eb72d59dd2b98c9d1f57e9369a6432daa8505854" translate="yes" xml:space="preserve">
          <source>Returns errors for a given attribute</source>
          <target state="translated">返回给定属性的错误</target>
        </trans-unit>
        <trans-unit id="84982465e39ac847f3650a8b4a93110951755c44" translate="yes" xml:space="preserve">
          <source>Returns keywords to match when searching records.</source>
          <target state="translated">返回搜索记录时要匹配的关键字。</target>
        </trans-unit>
        <trans-unit id="c53cee14bf3f2dd98c4f832e2cfc8603ac6576e6" translate="yes" xml:space="preserve">
          <source>Returns the Capitalized form of a string</source>
          <target state="translated">返回字符串的大写形式</target>
        </trans-unit>
        <trans-unit id="27bef32d6017037bf8ae7ec87140c840faa058d7" translate="yes" xml:space="preserve">
          <source>Returns the UpperCamelCase form of a string.</source>
          <target state="translated">返回字符串的UpperCamelCase形式。</target>
        </trans-unit>
        <trans-unit id="9e667554d12ea03a5ae716d11d67d4c4964f3096" translate="yes" xml:space="preserve">
          <source>Returns the associated child for convenience.</source>
          <target state="translated">为方便起见,返回关联的子代。</target>
        </trans-unit>
        <trans-unit id="3ea8d719e010027a981f551b7907ffaf6428b3c0" translate="yes" xml:space="preserve">
          <source>Returns the available classes a given type.</source>
          <target state="translated">Returns the available classes a given type.</target>
        </trans-unit>
        <trans-unit id="559a00b1190b2d1cae3fc144a9dbab5ae67bb15d" translate="yes" xml:space="preserve">
          <source>Returns the cached value for a property, if one exists. This can be useful for peeking at the value of a computed property that is generated lazily, without accidentally causing it to be created.</source>
          <target state="translated">返回一个属性的缓存值,如果存在的话。这对于偷看一个被计算的属性的值是很有用的,因为这个属性是懒惰生成的,不会意外地导致它被创建。</target>
        </trans-unit>
        <trans-unit id="c7c90e8f44c4bb41743551254bcbc3f92e3bc124" translate="yes" xml:space="preserve">
          <source>Returns the cached value of a computed property, if it exists. This allows you to inspect the value of a computed property without accidentally invoking it if it is intended to be generated lazily.</source>
          <target state="translated">返回一个计算过的属性的缓存值,如果它存在的话。这允许你检查一个计算过的属性的值,而不会意外地调用它,如果它打算被懒惰地生成的话。</target>
        </trans-unit>
        <trans-unit id="fc4ee2b850450a7e973ddd1ed839152228fa5e24" translate="yes" xml:space="preserve">
          <source>Returns the controller of the current route, or a parent (or any ancestor) route in a route hierarchy.</source>
          <target state="translated">返回当前路由的控制器,或者路由层次结构中的父路由(或任何祖先)。</target>
        </trans-unit>
        <trans-unit id="9725708a8c5defae2f7c0cd978776509197591b1" translate="yes" xml:space="preserve">
          <source>Returns the current DOM element for the view.</source>
          <target state="translated">返回当前视图的DOM元素。</target>
        </trans-unit>
        <trans-unit id="b98b32c89ebbfef46cceba77784cc4659c5bbd7e" translate="yes" xml:space="preserve">
          <source>Returns the current URL.</source>
          <target state="translated">返回当前的URL。</target>
        </trans-unit>
        <trans-unit id="603c43d141eff0347fdae1c71f24b3fffbceee88" translate="yes" xml:space="preserve">
          <source>Returns the current path.</source>
          <target state="translated">返回当前路径。</target>
        </trans-unit>
        <trans-unit id="5f1aa9ae053c0edabb551d28c02b549a6462af84" translate="yes" xml:space="preserve">
          <source>Returns the currently active route name.</source>
          <target state="translated">返回当前活动的途径名称。</target>
        </trans-unit>
        <trans-unit id="813b9ecb5f8511435272f62810e6b41f7e57a004" translate="yes" xml:space="preserve">
          <source>Returns the first item in the array for which the callback returns true. This method is similar to the &lt;code&gt;find()&lt;/code&gt; method defined in ECMAScript 2015.</source>
          <target state="translated">返回数组中回调为其返回true的第一项。此方法类似于ECMAScript 2015中定义的 &lt;code&gt;find()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="f9fe31d2ca8c909a9d417483d744e509af227d01" translate="yes" xml:space="preserve">
          <source>Returns the first item in the array for which the callback returns true. This method works similar to the &lt;code&gt;filter()&lt;/code&gt; method defined in JavaScript 1.6 except that it will stop working on the array once a match is found.</source>
          <target state="translated">返回数组中回调为其返回true的第一项。此方法的工作方式类似于JavaScript 1.6中定义的 &lt;code&gt;filter()&lt;/code&gt; 方法，不同之处在于，一旦找到匹配项，它将停止在数组上工作。</target>
        </trans-unit>
        <trans-unit id="2e59a22f6a7f2a23baf41260a3a174ae4dda651e" translate="yes" xml:space="preserve">
          <source>Returns the first item with a property matching the passed value. You can pass an optional second argument with the target value. Otherwise this will match any property that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">返回具有与传递的值匹配的属性的第一项。您可以传递带有目标值的可选第二个参数。否则，它将匹配任何评估为 &lt;code&gt;true&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="4e4749aa6dc27e7bce3a78184551818e1fd4702e" translate="yes" xml:space="preserve">
          <source>Returns the index of the given &lt;code&gt;object&lt;/code&gt;'s last occurrence.</source>
          <target state="translated">返回给定 &lt;code&gt;object&lt;/code&gt; 最后一次出现的索引。</target>
        </trans-unit>
        <trans-unit id="a5a026a77c75bacd53505cdcc6e9f209285cfdf2" translate="yes" xml:space="preserve">
          <source>Returns the index of the given object's first occurrence. If no &lt;code&gt;startAt&lt;/code&gt; argument is given, the starting location to search is 0. If it's negative, will count backward from the end of the array. Returns -1 if no match is found.</source>
          <target state="translated">返回给定对象首次出现的索引。如果未提供 &lt;code&gt;startAt&lt;/code&gt; 参数，则搜索的起始位置为0。如果为负，将从数组末尾开始倒数。如果找不到匹配项，则返回-1。</target>
        </trans-unit>
        <trans-unit id="b0b515aad064fd3b288bb9d89c67df97fc51d2b5" translate="yes" xml:space="preserve">
          <source>Returns the index of the given object's last occurrence. If no &lt;code&gt;startAt&lt;/code&gt; argument is given, the search starts from the last position. If it's negative, will count backward from the end of the array. Returns -1 if no match is found.</source>
          <target state="translated">返回给定对象最后一次出现的索引。如果未给出 &lt;code&gt;startAt&lt;/code&gt; 参数，则搜索从最后一个位置开始。如果为负数，将从数组末尾开始倒数。如果找不到匹配项，则返回-1。</target>
        </trans-unit>
        <trans-unit id="53b4efc0ec12b66bfb72581aacfd1278f1182232" translate="yes" xml:space="preserve">
          <source>Returns the lowerCamelCase form of a string.</source>
          <target state="translated">Returns the lowerCamelCase form of a string。</target>
        </trans-unit>
        <trans-unit id="9578d2b6bd478f1d1d2ab145665ede9e0378f6c2" translate="yes" xml:space="preserve">
          <source>Returns the model class for the particular &lt;code&gt;modelName&lt;/code&gt;.</source>
          <target state="translated">返回特定 &lt;code&gt;modelName&lt;/code&gt; 的模型类。</target>
        </trans-unit>
        <trans-unit id="6084c6c52d8f4610c165db1925af06fb94911fbb" translate="yes" xml:space="preserve">
          <source>Returns the name of the model class.</source>
          <target state="translated">返回模型类的名称。</target>
        </trans-unit>
        <trans-unit id="0bab782f8ac9d0f882b41382a9b9eba4f7d1cced" translate="yes" xml:space="preserve">
          <source>Returns the object at the given &lt;code&gt;index&lt;/code&gt;. If the given &lt;code&gt;index&lt;/code&gt; is negative or is greater or equal than the array length, returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">返回给定 &lt;code&gt;index&lt;/code&gt; 处的对象。如果给定的 &lt;code&gt;index&lt;/code&gt; 为负或大于或等于数组长度，则返回 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3f7b4ca85546523dc009d25cb0b789a874b05c9" translate="yes" xml:space="preserve">
          <source>Returns the resolved model of a parent (or any ancestor) route in a route hierarchy. During a transition, all routes must resolve a model object, and if a route needs access to a parent route's model in order to resolve a model (or just reuse the model from a parent), it can call &lt;code&gt;this.modelFor(theNameOfParentRoute)&lt;/code&gt; to retrieve it. If the ancestor route's model was a promise, its resolved result is returned.</source>
          <target state="translated">返回路由层次结构中父（或任何祖先）路由的解析模型。在过渡期间，所有路由都必须解析一个模型对象，如果路由需要访问父路由的模型以解析模型（或者只是重用父路由的模型），则可以调用 &lt;code&gt;this.modelFor(theNameOfParentRoute)&lt;/code&gt; 来找回它。如果祖先路线的模型是promise，则返回其解析结果。</target>
        </trans-unit>
        <trans-unit id="a84d41130ac37df9542127b00978dea35fe64b87" translate="yes" xml:space="preserve">
          <source>Returns the resource's ID.</source>
          <target state="translated">返回资源的ID。</target>
        </trans-unit>
        <trans-unit id="bf66565ff73540d9dd7fc00f9444426f536c7d08" translate="yes" xml:space="preserve">
          <source>Returns the resource's attributes formatted as a JSON-API &quot;attributes object&quot;.</source>
          <target state="translated">返回资源的属性,格式为JSON-API &quot;属性对象&quot;。</target>
        </trans-unit>
        <trans-unit id="415b933c18c5478e404754280a5d65c8ca1940a0" translate="yes" xml:space="preserve">
          <source>Returns the resource's relationships formatted as a JSON-API &quot;relationships object&quot;.</source>
          <target state="translated">返回资源的关系,格式为JSON-API &quot;关系对象&quot;。</target>
        </trans-unit>
        <trans-unit id="cdf54eb05e0fa1e3d781a566f01099e76afe41b7" translate="yes" xml:space="preserve">
          <source>Returns the value of the named property on all items in the enumeration.</source>
          <target state="translated">返回命名属性在枚举中所有项目上的值。</target>
        </trans-unit>
        <trans-unit id="7070d6237ca8bd3631e5672cdd05bb5c80f183e0" translate="yes" xml:space="preserve">
          <source>Returns the values of filters defined by &lt;code&gt;getFilters&lt;/code&gt;.</source>
          <target state="translated">返回由 &lt;code&gt;getFilters&lt;/code&gt; 定义的过滤器的值。</target>
        </trans-unit>
        <trans-unit id="afc70541a8fa4d9fce60946294448cc54071c811" translate="yes" xml:space="preserve">
          <source>Returns true if it is possible to catalog a list of available classes in the resolver for a given type.</source>
          <target state="translated">如果可以为给定类型在解析器中编目一个可用的类的列表,则返回true。</target>
        </trans-unit>
        <trans-unit id="dbd27005b9eb80ac7f03ed6d41eccecffd320423" translate="yes" xml:space="preserve">
          <source>Returns true if the passed object is an array or Array-like.</source>
          <target state="translated">如果传递的对象是一个数组或类数组,则返回true。</target>
        </trans-unit>
        <trans-unit id="2cbfc0edc2a1571a31104dc3ac6c9e8701099f18" translate="yes" xml:space="preserve">
          <source>Returns true if the passed value is null or undefined. This avoids errors from JSLint complaining about use of ==, which can be technically confusing.</source>
          <target state="translated">如果传递的值为空或未定义,返回true。这就避免了JSLint抱怨使用==的错误,因为这在技术上可能会引起混淆。</target>
        </trans-unit>
        <trans-unit id="cb7fd3ff2c053ac1f7adced8bb08e8be1c57f557" translate="yes" xml:space="preserve">
          <source>Reusing Route Context</source>
          <target state="translated">重用路由上下文</target>
        </trans-unit>
        <trans-unit id="f7a260f32f2ae28e993f2a321848e1adcfad19eb" translate="yes" xml:space="preserve">
          <source>Reverse objects in the array. Works just like &lt;code&gt;reverse()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">反转数组中的对象。就像 &lt;code&gt;reverse()&lt;/code&gt; 一样工作，但是它兼容KVO。</target>
        </trans-unit>
        <trans-unit id="ef58b6655b1d174bf86dcad644fe5f14396fd1de" translate="yes" xml:space="preserve">
          <source>Review the refactoring checklist below to create a plan for handling existing code. Note that some steps have codemods available!</source>
          <target state="translated">查看下面的重构检查表,制定处理现有代码的计划。请注意,有些步骤有codemods可用!</target>
        </trans-unit>
        <trans-unit id="6209537eda0bb676e9c1139d4542bb71b587c921" translate="yes" xml:space="preserve">
          <source>RootState</source>
          <target state="translated">RootState</target>
        </trans-unit>
        <trans-unit id="4999528efe0f94f8f66b1dc05aad8ebaaae7b2be" translate="yes" xml:space="preserve">
          <source>Route</source>
          <target state="translated">Route</target>
        </trans-unit>
        <trans-unit id="20bb4efd64b3d8c3fbab0cab5b9e525a3f5f3641" translate="yes" xml:space="preserve">
          <source>Route Handlers</source>
          <target state="translated">路线处理程序</target>
        </trans-unit>
        <trans-unit id="3e5b526bf5c2870cc328f02613777cab7924648b" translate="yes" xml:space="preserve">
          <source>RouteInfo</source>
          <target state="translated">RouteInfo</target>
        </trans-unit>
        <trans-unit id="836d21b73cac9b2da1021cc61047f6d87e32ce66" translate="yes" xml:space="preserve">
          <source>RouteInfoWithAttributes</source>
          <target state="translated">RouteInfoWithAttributes</target>
        </trans-unit>
        <trans-unit id="6dcf16e1c5d3e9fd2ae4a4d54c174448fe43e1b6" translate="yes" xml:space="preserve">
          <source>Router</source>
          <target state="translated">Router</target>
        </trans-unit>
        <trans-unit id="15507cd11e5f36e3bd1000cd0d459f39fb04d158" translate="yes" xml:space="preserve">
          <source>Router and Route Handlers</source>
          <target state="translated">路由器和路由处理程序</target>
        </trans-unit>
        <trans-unit id="eb04e4102ddcdddd2b4ad8996248c661dcd7e77f" translate="yes" xml:space="preserve">
          <source>RouterService</source>
          <target state="translated">RouterService</target>
        </trans-unit>
        <trans-unit id="a9d3b175c69e17dc9060b2a51d5088436b3d7c7d" translate="yes" xml:space="preserve">
          <source>RouterService  (public)</source>
          <target state="translated">RouterService (public)</target>
        </trans-unit>
        <trans-unit id="03730e58401ef5d9e79d1f674df0a5f9cf756e33" translate="yes" xml:space="preserve">
          <source>Routes</source>
          <target state="translated">Routes</target>
        </trans-unit>
        <trans-unit id="bbe3002d2245379df83a5467ffff0fec18ef89e8" translate="yes" xml:space="preserve">
          <source>Routes and Templates</source>
          <target state="translated">路线和模板</target>
        </trans-unit>
        <trans-unit id="8987ca9f541ce3e64483abe2d701eb7b2b6a9540" translate="yes" xml:space="preserve">
          <source>Routes in this example application can now access the injected logger:</source>
          <target state="translated">本示例应用程序中的路由现在可以访问注入的记录器。</target>
        </trans-unit>
        <trans-unit id="64588f6aefa7085fb2efbbcac558cdfba1c74948" translate="yes" xml:space="preserve">
          <source>Routes without dynamic segments will always execute the model hook.</source>
          <target state="translated">没有动态段的路由将始终执行模型钩子。</target>
        </trans-unit>
        <trans-unit id="0e523b39cf9ec96ace784b7a343ed0d9faa3ec4c" translate="yes" xml:space="preserve">
          <source>Routine minor version maintenance upgrades</source>
          <target state="translated">常规的小版本维护升级</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="0cd39bd2ed21b982743ecb7fd781003d0e3b3062" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;ember server&lt;/code&gt;.</source>
          <target state="translated">运行 &lt;code&gt;ember server&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1442914c6ee08b64a917d4c330cde7b015a3686d" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;ember t -s&lt;/code&gt; to verify that our new test is passing. To find the new test, locate &quot;Integration | Component | rental listing&quot; in the &quot;Module&quot; field of the test UI.</source>
          <target state="translated">运行 &lt;code&gt;ember t -s&lt;/code&gt; 验证我们的新测试通过了。要查找新测试，请在测试UI的&amp;ldquo;模块&amp;rdquo;字段中找到&amp;ldquo;集成|组件|租赁清单&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="64e27783b0104ad18b07f55f262e7f7444bb57e6" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;npx @ember/octanify&lt;/code&gt; to add any missing Octane related dependencies and enable the set of Octane optional features.</source>
          <target state="translated">运行 &lt;code&gt;npx @ember/octanify&lt;/code&gt; 以添加所有丢失的与Octane相关的依赖项，并启用该组Octane可选功能。</target>
        </trans-unit>
        <trans-unit id="2dbbc67840c5e39c504d798d6593f53821d2cc88" translate="yes" xml:space="preserve">
          <source>Run a function meant for debugging.</source>
          <target state="translated">运行一个用于调试的函数。</target>
        </trans-unit>
        <trans-unit id="72b319733a3cbd1a60f4223245198cfc2ad86b61" translate="yes" xml:space="preserve">
          <source>Run any application initializers and run the application load hook. These hooks may choose to defer readiness. For example, an authentication hook might want to defer readiness until the auth token has been retrieved.</source>
          <target state="translated">运行任何应用程序初始化器并运行应用程序加载钩子。这些钩子可以选择推迟就绪。例如,验证钩子可能希望推迟就绪,直到检索到 auth 令牌。</target>
        </trans-unit>
        <trans-unit id="66a5ecdab45965e437f71333f302f2e5bab78442" translate="yes" xml:space="preserve">
          <source>Run in a full browser environment.</source>
          <target state="translated">在全浏览器环境下运行。</target>
        </trans-unit>
        <trans-unit id="edc3981913706bf02d5feb303f21804148ecbc99" translate="yes" xml:space="preserve">
          <source>Run the following command to install the addon:</source>
          <target state="translated">运行以下命令来安装插件。</target>
        </trans-unit>
        <trans-unit id="2acab689db555e5a40a3ad5f90d7b5a3c8c74f42" translate="yes" xml:space="preserve">
          <source>Run the following commands to install the addon and generate a new modifier:</source>
          <target state="translated">运行以下命令安装插件并生成一个新的修改器。</target>
        </trans-unit>
        <trans-unit id="6f6ff3e3092b35d4ef3929076640b57e0d508a29" translate="yes" xml:space="preserve">
          <source>Run the tests again using the command &lt;code&gt;ember t -s&lt;/code&gt;, and toggle &quot;Hide passed tests&quot; to show your new passing test.</source>
          <target state="translated">使用命令 &lt;code&gt;ember t -s&lt;/code&gt; 再次运行测试，然后切换&amp;ldquo;隐藏通过的测试&amp;rdquo;以显示新的通过测试。</target>
        </trans-unit>
        <trans-unit id="113d8c01f0ce1a9637e7e61d07f886f1ce894435" translate="yes" xml:space="preserve">
          <source>Run time, where we begin executing the application once everything has loaded.</source>
          <target state="translated">运行时,当一切加载完毕后,我们开始执行应用程序。</target>
        </trans-unit>
        <trans-unit id="18856dbed1e97664803502cb153a1b07dd530799" translate="yes" xml:space="preserve">
          <source>Run your tests to make sure everything still works as expected.</source>
          <target state="translated">运行你的测试,以确保一切仍按预期工作。</target>
        </trans-unit>
        <trans-unit id="8cbc363f50b4971680e11de197253d5ebff17363" translate="yes" xml:space="preserve">
          <source>Run your tests with &lt;code&gt;ember test&lt;/code&gt; on the command-line. You can re-run your tests on every file-change with &lt;code&gt;ember test --server&lt;/code&gt;.</source>
          <target state="translated">在命令行上使用 &lt;code&gt;ember test&lt;/code&gt; 运行测试。您可以使用 &lt;code&gt;ember test --server&lt;/code&gt; 在每个文件更改上重新运行测试。</target>
        </trans-unit>
        <trans-unit id="2ce92b8f8a607252af27b98ddec45308f2f8137b" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;ember test --server&lt;/code&gt; will now show 7 failing tests (out of 15). Each of the 6 tests we setup above will fail, plus one ESLint test will fail saying, &lt;code&gt;assert is defined but never used&lt;/code&gt;. The tests above fail because QUnit requires at least one check for a specific condition (known as an &lt;code&gt;assert&lt;/code&gt;).</source>
          <target state="translated">运行 &lt;code&gt;ember test --server&lt;/code&gt; 现在将显示7个失败的测试（共15个）。我们在上面设置的6个测试中的每一个都会失败，再加上一个ESLint测试将失败，说明 &lt;code&gt;assert is defined but never used&lt;/code&gt; 。上面的测试失败了，因为QUnit要求至少检查一次特定条件（称为 &lt;code&gt;assert&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="52d1f9fc84c72f964d3e2290880c642e3e33c2c8" translate="yes" xml:space="preserve">
          <source>Running this command generates three files: a component JavaScript file, a template, and a test file.</source>
          <target state="translated">运行该命令会生成三个文件:一个组件JavaScript文件、一个模板和一个测试文件。</target>
        </trans-unit>
        <trans-unit id="42272791157160739ed302e320a2062a5ebaa316" translate="yes" xml:space="preserve">
          <source>Runs the passed target and method inside of a RunLoop, ensuring any deferred actions including bindings and views updates are flushed at the end.</source>
          <target state="translated">在RunLoop中运行通过的目标和方法,确保任何延迟的操作,包括绑定和视图更新在最后被刷新。</target>
        </trans-unit>
        <trans-unit id="222cad2bd37e45b5f33d5d967590f4b613622bfd" translate="yes" xml:space="preserve">
          <source>Runtime Configuration</source>
          <target state="translated">运行时配置</target>
        </trans-unit>
        <trans-unit id="429ee37aaa10a7c1e1dbc7f3832b6b87b1b491c2" translate="yes" xml:space="preserve">
          <source>SSR</source>
          <target state="translated">SSR</target>
        </trans-unit>
        <trans-unit id="50fce6d02899850101b1865a947b45128c5350eb" translate="yes" xml:space="preserve">
          <source>SVG</source>
          <target state="translated">SVG</target>
        </trans-unit>
        <trans-unit id="34e3d9fa2efb3b7c73f3535f9e2462b7e96c9177" translate="yes" xml:space="preserve">
          <source>Safari &amp;amp; VoiceOver (MacOS)</source>
          <target state="translated">Safari和VoiceOver（MacOS）</target>
        </trans-unit>
        <trans-unit id="5d8e270a3b478909d95ca7c40279e9043d659c52" translate="yes" xml:space="preserve">
          <source>SafeString</source>
          <target state="translated">SafeString</target>
        </trans-unit>
        <trans-unit id="3345733b5704ef652ed8eb46f076938ea03125bd" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;deleteRecord&lt;/code&gt;, but saves the record immediately.</source>
          <target state="translated">与 &lt;code&gt;deleteRecord&lt;/code&gt; 相同，但立即保存记录。</target>
        </trans-unit>
        <trans-unit id="4a7e069bd507c730311a8b251060b5b9997cb937" translate="yes" xml:space="preserve">
          <source>Sass/Less Comparison</source>
          <target state="translated">Sass/Less比较</target>
        </trans-unit>
        <trans-unit id="25818b0851afccf72a718a0e15e8c5e40a99b3fc" translate="yes" xml:space="preserve">
          <source>Save the record and persist any changes to the record to an external source via the adapter.</source>
          <target state="translated">保存记录,并通过适配器将对记录的任何更改持久化到外部源。</target>
        </trans-unit>
        <trans-unit id="6c84a72cd3751d9f682a3838ae1434b6568e663c" translate="yes" xml:space="preserve">
          <source>Save this template and switch back to the &lt;code&gt;scientists&lt;/code&gt; template.</source>
          <target state="translated">保存此模板，然后切换回 &lt;code&gt;scientists&lt;/code&gt; 模板。</target>
        </trans-unit>
        <trans-unit id="6db7e04098ce89e31bb81c3fc95a3a70f998a013" translate="yes" xml:space="preserve">
          <source>Save this template and switch back to the &lt;code&gt;scientists&lt;/code&gt; template. Replace all our old code with our new componentized version. Components look like HTML tags but instead of using angle brackets (&lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt;) they use double curly braces (&lt;code&gt;{{component}}&lt;/code&gt;).</source>
          <target state="translated">保存此模板，然后切换回 &lt;code&gt;scientists&lt;/code&gt; 模板。用新的组件化版本替换所有旧代码。组件看起来像HTML标记，但是它们使用双花括号（ &lt;code&gt;{{component}}&lt;/code&gt; 代替了尖括号（ &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="75008fab400537d9213cc7b35f572e830001bbbb" translate="yes" xml:space="preserve">
          <source>Saves all of the records in the &lt;code&gt;ManyArray&lt;/code&gt;.</source>
          <target state="translated">将所有记录保存在 &lt;code&gt;ManyArray&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="df3feb104ba2e45607091340bd579e0e82e620de" translate="yes" xml:space="preserve">
          <source>Saves all of the records in the &lt;code&gt;RecordArray&lt;/code&gt;.</source>
          <target state="translated">将所有记录保存在 &lt;code&gt;RecordArray&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="3fe2b6866788c46de111214341e6e46e2056460c" translate="yes" xml:space="preserve">
          <source>Say your API namespaces the type of a model and expects the following payload when you update the &lt;code&gt;post&lt;/code&gt; model, which has a polymorphic &lt;code&gt;user&lt;/code&gt; relationship:</source>
          <target state="translated">假设您的API名称空间是模型的类型，并且在更新具有多态 &lt;code&gt;user&lt;/code&gt; 关系的 &lt;code&gt;post&lt;/code&gt; 模型时，需要以下有效负载：</target>
        </trans-unit>
        <trans-unit id="d136d61c474d3b91c7e154860b021ed3fbba6838" translate="yes" xml:space="preserve">
          <source>Say your API namespaces the type of a model and expects the following payload when you update the &lt;code&gt;post&lt;/code&gt; model:</source>
          <target state="translated">假设您的API名称空间是模型的类型，并且在更新 &lt;code&gt;post&lt;/code&gt; 模型时需要以下有效负载：</target>
        </trans-unit>
        <trans-unit id="ea662432dbe1c412446984e3028f23c30fe1a705" translate="yes" xml:space="preserve">
          <source>Say your API namespaces the type of a model and returns the following payload for the &lt;code&gt;post&lt;/code&gt; model, which has a polymorphic &lt;code&gt;user&lt;/code&gt; relationship:</source>
          <target state="translated">假设您的API命名空间是模型的类型，并为具有多态 &lt;code&gt;user&lt;/code&gt; 关系的 &lt;code&gt;post&lt;/code&gt; 模型返回以下负载：</target>
        </trans-unit>
        <trans-unit id="a903a2095a7bcdbfa11fb73fb67d71d335131cd8" translate="yes" xml:space="preserve">
          <source>Say your API namespaces the type of a model and returns the following payload for the &lt;code&gt;post&lt;/code&gt; model:</source>
          <target state="translated">假设您的API名称空间是模型的类型，并为 &lt;code&gt;post&lt;/code&gt; 模型返回以下有效负载：</target>
        </trans-unit>
        <trans-unit id="b6d33be0f5b1eaf876dc704dde51d9330f8ce358" translate="yes" xml:space="preserve">
          <source>Say your template now looks like this:</source>
          <target state="translated">说你的模板现在是这样的。</target>
        </trans-unit>
        <trans-unit id="bc16a7d79cd8b9582ffe6cf1c9f51f2a4e6b9968" translate="yes" xml:space="preserve">
          <source>Schedule a function to run one time during the current RunLoop. This is equivalent to calling &lt;code&gt;scheduleOnce&lt;/code&gt; with the &quot;actions&quot; queue.</source>
          <target state="translated">安排一个函数在当前RunLoop中运行一次。这等效于使用&amp;ldquo;操作&amp;rdquo;队列调用 &lt;code&gt;scheduleOnce&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fa9c050bafdf85859c52a24173e46d2b0a60bfa" translate="yes" xml:space="preserve">
          <source>Schedules a function to run one time in a given queue of the current RunLoop. Calling this method with the same queue/target/method combination will have no effect (past the initial call).</source>
          <target state="translated">在当前RunLoop的给定队列中安排函数运行一次。用相同的队列/目标/方法组合调用这个方法不会有任何影响(超过了初始调用)。</target>
        </trans-unit>
        <trans-unit id="1b04067c753c9231c4ab1631929ac85a00912241" translate="yes" xml:space="preserve">
          <source>Schedules an item to run from within a separate run loop, after control has been returned to the system. This is equivalent to calling &lt;code&gt;later&lt;/code&gt; with a wait time of 1ms.</source>
          <target state="translated">在将控制权返回给系统之后，安排一个项目在单独的运行循环中运行。这等效于 &lt;code&gt;later&lt;/code&gt; 以1毫秒的等待时间进行呼叫。</target>
        </trans-unit>
        <trans-unit id="415823adc474692ea63ccbfdd4bf9285fdf51e36" translate="yes" xml:space="preserve">
          <source>Schedules an item to run from within a separate run loop, after control has been returned to the system. This is equivalent to calling &lt;code&gt;run.later&lt;/code&gt; with a wait time of 1ms.</source>
          <target state="translated">在控制权返回给系统之后，计划在单独的运行循环中运行的项目。这等效于以1毫秒的等待时间调用 &lt;code&gt;run.later&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d41e78b236856ccbed77627ade3d088d216acb1c" translate="yes" xml:space="preserve">
          <source>Screen Reader and Browser Combinations</source>
          <target state="translated">读屏器和浏览器的组合</target>
        </trans-unit>
        <trans-unit id="5b35f99d17c2b4cd3489d04e3e8a0753839e2f05" translate="yes" xml:space="preserve">
          <source>Scrolling to a Component in the Browser</source>
          <target state="translated">在浏览器中滚动到一个组件</target>
        </trans-unit>
        <trans-unit id="2da8e5963f5b139e60b530201737776279520ba2" translate="yes" xml:space="preserve">
          <source>Second value to compare</source>
          <target state="translated">第二个比较值</target>
        </trans-unit>
        <trans-unit id="fbb14676cc33f6f4135e4da0888670ea8bff400b" translate="yes" xml:space="preserve">
          <source>Second, attribute and relationship names in the JSON API document should exactly match the name and casing of the &lt;code&gt;DS.attr()&lt;/code&gt;, &lt;code&gt;DS.belongsTo()&lt;/code&gt; and &lt;code&gt;DS.hasMany()&lt;/code&gt;, properties defined on the Model.</source>
          <target state="translated">其次，JSON API文档中的属性和关系名称应与模型上定义的 &lt;code&gt;DS.attr()&lt;/code&gt; ， &lt;code&gt;DS.belongsTo()&lt;/code&gt; 和 &lt;code&gt;DS.hasMany()&lt;/code&gt; 的名称和大小写完全匹配。</target>
        </trans-unit>
        <trans-unit id="034dffe4f830c683fca9562126a5ca88d70ebe7c" translate="yes" xml:space="preserve">
          <source>Second, attribute and relationship names in the JSON:API document should exactly match the name and casing of the &lt;code&gt;@attr&lt;/code&gt;, &lt;code&gt;@belongsTo&lt;/code&gt; and &lt;code&gt;@hasMany&lt;/code&gt;, properties defined on the Model.</source>
          <target state="translated">其次，JSON：API文档中的属性和关系名称应与模型上定义的 &lt;code&gt;@attr&lt;/code&gt; ， &lt;code&gt;@belongsTo&lt;/code&gt; 和 &lt;code&gt;@hasMany&lt;/code&gt; 属性的名称和大小写完全匹配。</target>
        </trans-unit>
        <trans-unit id="db838ce03ec02cddf2e180b605abba62ccb78900" translate="yes" xml:space="preserve">
          <source>Second, you can use Ember CLI to create an application test. Because application tests can cover anything in your app, you will want to organize the files in some natural manner. This will help you quickly find tests and prevent writing duplicates.</source>
          <target state="translated">其次,你可以使用Ember CLI来创建一个应用测试。因为应用测试可以覆盖你的应用中的任何东西,你会希望以某种自然的方式组织文件。这将帮助你快速找到测试并防止编写重复的测试。</target>
        </trans-unit>
        <trans-unit id="2505c754e96c76956a7be1f711c7c15d871a6591" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#method_findRecord&quot;&gt;findRecord&lt;/a&gt; if you would like to request this record from the backend.</source>
          <target state="translated">如果您想从后端请求此记录，请参见&lt;a href=&quot;#method_findRecord&quot;&gt;findRecord&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6b7139c565ccba6b41646265abe63665bc0e0fb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#method_peekAll&quot;&gt;peekAll&lt;/a&gt; to get an array of current records in the store, without waiting until a reload is finished.</source>
          <target state="translated">请参阅&lt;a href=&quot;#method_peekAll&quot;&gt;peekAll&lt;/a&gt;以获取存储中的当前记录数组，而无需等到重新加载完成。</target>
        </trans-unit>
        <trans-unit id="886ff4d1e817dd0f2c949c0a7b4ce296faa34a4f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#method_peekRecord&quot;&gt;peekRecord&lt;/a&gt; to get the cached version of a record.</source>
          <target state="translated">请参阅&lt;a href=&quot;#method_peekRecord&quot;&gt;peekRecord&lt;/a&gt;以获取记录的缓存版本。</target>
        </trans-unit>
        <trans-unit id="61ccab3b58667205608bc05c31f4f4471dba3cbc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#method_query&quot;&gt;query&lt;/a&gt; to only get a subset of records from the server.</source>
          <target state="translated">请参阅&lt;a href=&quot;#method_query&quot;&gt;查询&lt;/a&gt;以仅从服务器获取记录的子集。</target>
        </trans-unit>
        <trans-unit id="3105a13b11f9cc2079e6d9c9697d486cac446dad" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../classes/store/methods#findRecord&quot;&gt;findRecord&lt;/a&gt; if you would like to request this record from the backend.</source>
          <target state="translated">如果您想从后端请求此记录，请参见&lt;a href=&quot;../classes/store/methods#findRecord&quot;&gt;findRecord&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="767b15fbf66aebbc4c1178cfc66ef2addeaff7a7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../classes/store/methods#peekAll&quot;&gt;peekAll&lt;/a&gt; to get an array of current records in the store, without waiting until a reload is finished.</source>
          <target state="translated">请参阅&lt;a href=&quot;../classes/store/methods#peekAll&quot;&gt;peekAll&lt;/a&gt;以获取存储中的当前记录数组，而无需等到重新加载完成。</target>
        </trans-unit>
        <trans-unit id="301e5555d56099e927bafe66085f45d680ad09fd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../classes/store/methods#peekRecord&quot;&gt;peekRecord&lt;/a&gt; to get the cached version of a record.</source>
          <target state="translated">请参阅&lt;a href=&quot;../classes/store/methods#peekRecord&quot;&gt;peekRecord&lt;/a&gt;以获取记录的缓存版本。</target>
        </trans-unit>
        <trans-unit id="52b9c1d58375374ce85b3db6e92e1d22b6f76771" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../classes/store/methods#query&quot;&gt;query&lt;/a&gt; to only get a subset of records from the server.</source>
          <target state="translated">请参阅&lt;a href=&quot;../classes/store/methods#query&quot;&gt;查询&lt;/a&gt;以仅从服务器获取记录的子集。</target>
        </trans-unit>
        <trans-unit id="46d9795971c80ea476d0b1500751d7a511c3ccff" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../passing-properties-to-a-component&quot;&gt;Passing Properties to a Component&lt;/a&gt; for more.</source>
          <target state="translated">有关更多信息，请参见将&lt;a href=&quot;../passing-properties-to-a-component&quot;&gt;属性传递给组件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0319da9f087136e4a227ecabe7592e7410d686a7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Component&quot;&gt;&quot;Event Names&quot;&lt;/a&gt; for a list of acceptable DOM event names.</source>
          <target state="translated">有关可接受的DOM事件名称的列表，请参见&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Component&quot;&gt;&amp;ldquo;事件名称&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="59c230214dd323fd59b372f5662d59a31f4e058f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.components/methods#Input&quot;&gt;Ember.Templates.components.Input&lt;/a&gt; for usage details.</source>
          <target state="translated">有关用法的详细信息，请参见&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.components/methods#Input&quot;&gt;Ember.Templates.components.Input&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c606b9d8595a50fa7aa94676800966aac8b31e0c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.components/methods#Input&quot;&gt;Ember.Templates.components.Input&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.components/methods#Input&quot;&gt;Ember.Templates.components.Input&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b59e94468bbac79b422f95f86d51ba6d3357a3b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.components/methods#LinkTo&quot;&gt;Ember.Templates.components.LinkTo&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.components/methods#LinkTo&quot;&gt;Ember.Templates.components.LinkTo&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d8ef01c673e480de87f9a30258d0cc3c0b91e52" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#action&quot;&gt;Ember.Templates.helpers.action&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#action&quot;&gt;Ember.Templates.helpers.action&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff6fbd0c84895ac5a1183d822bece1572d790301" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#input&quot;&gt;Ember.Templates.helpers.input&lt;/a&gt; for usage details.</source>
          <target state="translated">有关用法的详细信息，请参见&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.Templates.helpers/methods#input&quot;&gt;Ember.Templates.helpers.input&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f4195a0e3a0053f1daea3c2b0663c242da9aae2" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/HashLocation&quot;&gt;HashLocation&lt;/a&gt;. See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/HistoryLocation&quot;&gt;HistoryLocation&lt;/a&gt;. See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/NoneLocation&quot;&gt;NoneLocation&lt;/a&gt;. See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/AutoLocation&quot;&gt;AutoLocation&lt;/a&gt;.</source>
          <target state="translated">参见&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/HashLocation&quot;&gt;HashLocation&lt;/a&gt;。请参阅&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/HistoryLocation&quot;&gt;HistoryLocation&lt;/a&gt;。参见&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/NoneLocation&quot;&gt;NoneLocation&lt;/a&gt;。请参阅&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/AutoLocation&quot;&gt;自动定位&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30783607813c38b446462004a03e85001d9c1d18" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Location&quot;&gt;Location&lt;/a&gt; for more information.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Location&quot;&gt;位置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7cd238cafae20ea63e84d678404ca936763fda5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#replaceWith&quot;&gt;replaceWith&lt;/a&gt; for more info.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#replaceWith&quot;&gt;replaceWith&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1495cd26c813c59a09e8d41995ed5d2e6a8db9b7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#transitionTo&quot;&gt;transitionTo&lt;/a&gt; for more info.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#transitionTo&quot;&gt;transitionTo&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aead30c4035a153b7292346def1a11abd9b74534" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/RouteInfo&quot;&gt;RouteInfo&lt;/a&gt; for more info.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/RouteInfo&quot;&gt;RouteInfo&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3db6252e2ca3a79d9351ce05c47a2d29d1a3f0d3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component#event-names&quot;&gt;&quot;Event Names&quot;&lt;/a&gt; for a list of acceptable DOM event names.</source>
          <target state="translated">有关可接受的DOM事件名称的列表，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component#event-names&quot;&gt;&amp;ldquo;事件名称&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8789001d899131f2e85e2f5f2831793db5bede0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.ComputedProperty.html&quot;&gt;Ember.ComputedProperty&lt;/a&gt;, &lt;a href=&quot;https://emberjs.com/api/classes/Ember.computed.html&quot;&gt;Ember.computed&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://emberjs.com/api/classes/Ember.ComputedProperty.html&quot;&gt;Ember.ComputedProperty&lt;/a&gt;，&lt;a href=&quot;https://emberjs.com/api/classes/Ember.computed.html&quot;&gt;Ember.computed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65ead4fce2d577717cfc6277eb28eb28c8681b44" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.LinkComponent.html&quot;&gt;Ember.LinkComponent&lt;/a&gt; for a complete list of overrideable properties. Be sure to also check out inherited properties of &lt;code&gt;LinkComponent&lt;/code&gt;.</source>
          <target state="translated">有关&lt;a href=&quot;https://emberjs.com/api/classes/Ember.LinkComponent.html&quot;&gt;可&lt;/a&gt;重写属性的完整列表，请参见Ember.LinkComponent。一定还要检查出 &lt;code&gt;LinkComponent&lt;/code&gt; 的继承属性。</target>
        </trans-unit>
        <trans-unit id="045265cfa59bb6f41aaac98fec78959fdd19abe6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.HashLocation&quot;&gt;Ember.Location.HashLocation&lt;/a&gt;. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.HistoryLocation&quot;&gt;Ember.Location.HistoryLocation&lt;/a&gt;. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.NoneLocation&quot;&gt;Ember.Location.NoneLocation&lt;/a&gt;. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.AutoLocation&quot;&gt;Ember.Location.AutoLocation&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.HashLocation&quot;&gt;Ember.Location.HashLocation&lt;/a&gt;。请参阅&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.HistoryLocation&quot;&gt;Ember.Location.HistoryLocation&lt;/a&gt;。请参阅&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.NoneLocation&quot;&gt;Ember.Location.NoneLocation&lt;/a&gt;。请参阅&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Location.AutoLocation&quot;&gt;Ember.Location.AutoLocation&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01062a6ca91683116a2e4f5f08c832a71f5fe8f8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Route.html#method_replaceWith&quot;&gt;Route.replaceWith&lt;/a&gt; for more info.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Route.html#method_replaceWith&quot;&gt;Route.replaceWith&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="857a99c53ed3cf0419cf7f9b690df0548804f0cb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Route.html#method_transitionTo&quot;&gt;Route.transitionTo&lt;/a&gt; for more info.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Route.html#method_transitionTo&quot;&gt;Route.transitionTo&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="881033150b0297e5f01d4a625bd73488021b52e6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.String.html#method_loc&quot;&gt;Ember.String.loc&lt;/a&gt; for how to set up localized string references.</source>
          <target state="translated">有关如何设置本地化的字符串引用，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.String.html#method_loc&quot;&gt;Ember.String.loc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6112da6f0d617231dc4dbb1b45eeb398b827508d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_action&quot;&gt;Ember.Templates.helpers.action&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_action&quot;&gt;Ember.Templates.helpers.action&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e320b1d30f80cb3e78ed752a8fd867c8ef8c8dc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;Ember.Templates.helpers.input&lt;/a&gt; for usage details.</source>
          <target state="translated">有关用法的详细信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;Ember.Templates.helpers.input&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03d11afa96477f44a066fa485ba8101cf284b0ae" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_textarea&quot;&gt;Ember.Templates.helpers.textarea&lt;/a&gt; for usage details.</source>
          <target state="translated">有关用法的详细信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_textarea&quot;&gt;Ember.Templates.helpers.textarea&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="47faa79acc3c86a2306cd182fa2b1e0dd8b6cb51" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_yield&quot;&gt;Ember.Templates.helpers.yield&lt;/a&gt; for more information.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_yield&quot;&gt;Ember.Templates.helpers.yield&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d084a39940c5ca6a3dc230b8703de366598062d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://emberjs.com/guides/templates/the-application-template/&quot;&gt;templates guide&lt;/a&gt; for additional information on using &lt;code&gt;{{outlet}}&lt;/code&gt; in &lt;code&gt;application.hbs&lt;/code&gt;. You may also specify a name for the &lt;code&gt;{{outlet}}&lt;/code&gt;, which is useful when using more than one &lt;code&gt;{{outlet}}&lt;/code&gt; in a template:</source>
          <target state="translated">有关在 &lt;code&gt;application.hbs&lt;/code&gt; 中使用 &lt;code&gt;{{outlet}}&lt;/code&gt; 的更多信息，请参见&lt;a href=&quot;https://emberjs.com/guides/templates/the-application-template/&quot;&gt;模板指南&lt;/a&gt;。您还可以为 &lt;code&gt;{{outlet}}&lt;/code&gt; 指定一个名称，这在模板中使用多个 &lt;code&gt;{{outlet}}&lt;/code&gt; 时非常有用：</target>
        </trans-unit>
        <trans-unit id="da7f7101e86e008a15c9fc249f9d10eeeb8ad692" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;Ember.observer&lt;/code&gt;.</source>
          <target state="translated">请参阅 &lt;code&gt;Ember.observer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb6d38f9f2619d3888781eee8439db883f2023dd" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;Ember.on&lt;/code&gt;.</source>
          <target state="translated">参见 &lt;code&gt;Ember.on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5654e29a2f9b281a9e8375d997a1390c911e728" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;serialize&lt;/code&gt; for information on how to customize the serialized form of a record.</source>
          <target state="translated">有关如何自定义记录的序列化形式的信息，请参见 &lt;code&gt;serialize&lt;/code&gt; 化。</target>
        </trans-unit>
        <trans-unit id="d9a00896f41c599da76dc20f479edb128563ac86" translate="yes" xml:space="preserve">
          <source>See Application.initializer for discussion on the usage of before and after.</source>
          <target state="translated">关于前后的用法,请参见Application.initializer的讨论。</target>
        </trans-unit>
        <trans-unit id="c586195d203dee29ed62d91d26341ea7df6918eb" translate="yes" xml:space="preserve">
          <source>See Ember.Application.initializer for discussion on the usage of before and after.</source>
          <target state="translated">关于前后的用法,请参见Ember.Application.initializer的讨论。</target>
        </trans-unit>
        <trans-unit id="bede171d87f7cb61701998037e437c80414a95a2" translate="yes" xml:space="preserve">
          <source>See Ember.Templates.components.Textarea.</source>
          <target state="translated">参见Ember.Templates.component.Textarea。</target>
        </trans-unit>
        <trans-unit id="e38cd17e666018827e69a44432616458686394b7" translate="yes" xml:space="preserve">
          <source>See RSVP.Promise.catch.</source>
          <target state="translated">见RSVP.Promise.catch。</target>
        </trans-unit>
        <trans-unit id="392314b527dfbd25d9b7ed433a5cad392661aecf" translate="yes" xml:space="preserve">
          <source>See RSVP.Promise.finally.</source>
          <target state="translated">见RSVP.Promise.最后。</target>
        </trans-unit>
        <trans-unit id="2192c68214bde1365823cd88f18083860287db7d" translate="yes" xml:space="preserve">
          <source>See RSVP.Promise.then.</source>
          <target state="translated">见RSVP.Promise.然后。</target>
        </trans-unit>
        <trans-unit id="e4f6b4832e77e568563e9f9654dc677db5ef2bd6" translate="yes" xml:space="preserve">
          <source>See all observers for an object, key</source>
          <target state="translated">查看一个对象的所有观察者,键</target>
        </trans-unit>
        <trans-unit id="f44d1816a0f33954c0c1b606d935226b15a7a275" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#method_replaceWith&quot;&gt;replaceWith&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;#method_replaceWith&quot;&gt;replaceWith&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1988f100a0c69901fb6b7c62063558d170fe6707" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.ControllerMixin/methods#replaceRoute&quot;&gt;replaceRoute&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Ember.ControllerMixin/methods#replaceRoute&quot;&gt;replaceRoute&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65b6e8e3055ab3ad8943a84067c6dde10eeb6b38" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://emberjs.com/api/classes/Ember.ControllerMixin.html#method_replaceRoute&quot;&gt;replaceRoute&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.ControllerMixin.html#method_replaceRoute&quot;&gt;replaceRoute&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97dd9bb1a71a2721679fe0253b5d472ea10ebad5" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;partial application&lt;/a&gt;.</source>
          <target state="translated">另请参阅&lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;部分应用程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b99a8f14eeb215db8b265ce373ed6b7c06c3bcdc" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;findMany&lt;/code&gt; and &lt;code&gt;coalesceFindRequests&lt;/code&gt;</source>
          <target state="translated">又见 &lt;code&gt;findMany&lt;/code&gt; 和 &lt;code&gt;coalesceFindRequests&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9055a79315a92197a81491b2935920ef41434f7b" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;groupRecordsForFindMany&lt;/code&gt; and &lt;code&gt;coalesceFindRequests&lt;/code&gt;</source>
          <target state="translated">另请参见 &lt;code&gt;groupRecordsForFindMany&lt;/code&gt; 和 &lt;code&gt;coalesceFindRequests&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6e0086846357bfe5efd4585bcddabbf01147a92" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;shouldReloadAll&lt;/code&gt; and &lt;code&gt;shouldBackgroundReloadAll&lt;/code&gt;</source>
          <target state="translated">另请参见 &lt;code&gt;shouldReloadAll&lt;/code&gt; 和 &lt;code&gt;shouldBackgroundReloadAll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9f85b38eecb68cbfa9743890c0ab6a9e7d97afa" translate="yes" xml:space="preserve">
          <source>See also the documentation for &lt;code&gt;shouldBackgroundReloadRecord&lt;/code&gt; which defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">另请参见 &lt;code&gt;shouldBackgroundReloadRecord&lt;/code&gt; 的文档，该文档默认为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1131debc15fa7b2f9872d39240142f424b1f9d69" translate="yes" xml:space="preserve">
          <source>See more about &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component.html&quot;&gt;Ember components&lt;/a&gt;</source>
          <target state="translated">进一步了解&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component.html&quot;&gt;Ember组件&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ba9f21e3fbfc35d0ad9d88b57d28f52f45794dc" translate="yes" xml:space="preserve">
          <source>See more about &lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextArea.html&quot;&gt;Text Support Actions&lt;/a&gt;</source>
          <target state="translated">查看有关&lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextArea.html&quot;&gt;文本支持操作的&lt;/a&gt;更多信息</target>
        </trans-unit>
        <trans-unit id="d8d27c03873709d7fb4d40eef28f6d91b6c1accb" translate="yes" xml:space="preserve">
          <source>See more about &lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;Text Support Actions&lt;/a&gt;</source>
          <target state="translated">查看有关&lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;文本支持操作的&lt;/a&gt;更多信息</target>
        </trans-unit>
        <trans-unit id="962ed2719e85d5ea79a83fc6aacb86ed6c442ba1" translate="yes" xml:space="preserve">
          <source>See that first, we are creating a new testing module using the &lt;a href=&quot;https://api.qunitjs.com/QUnit/module&quot;&gt;&lt;code&gt;QUnit.module&lt;/code&gt;&lt;/a&gt; function. This will scope all of our tests together into one group that can be configured and run independently from other modules defined in our test suite. Also, we have used &lt;code&gt;setupTest&lt;/code&gt;, one of the several test helpers provided by &lt;a href=&quot;https://github.com/emberjs/ember-qunit&quot;&gt;ember-qunit&lt;/a&gt;. The &lt;code&gt;setupTest&lt;/code&gt; helper provides us with some conveniences, such as the &lt;code&gt;this.owner&lt;/code&gt; object, that helps us to create or lookup objects which are needed to setup our test. In this example, we use the &lt;code&gt;this.owner&lt;/code&gt; object to lookup the service instance that becomes our test subject: &lt;code&gt;someThing&lt;/code&gt;. Note that in a unit test you can customize any object under test by setting its properties accordingly. We can use the &lt;code&gt;set&lt;/code&gt; method of the test object to achieve this.</source>
          <target state="translated">首先，我们要使用&lt;a href=&quot;https://api.qunitjs.com/QUnit/module&quot;&gt; &lt;code&gt;QUnit.module&lt;/code&gt; &lt;/a&gt;函数创建一个新的测试模块。这会将我们所有的测试归为一组，可以独立于我们的测试套件中定义的其他模块进行配置和运行。另外，我们使用了 &lt;code&gt;setupTest&lt;/code&gt; ，这是&lt;a href=&quot;https://github.com/emberjs/ember-qunit&quot;&gt;ember-qunit&lt;/a&gt;提供的几个测试助手之一。该 &lt;code&gt;setupTest&lt;/code&gt; 助手为我们提供了一些便利，比如 &lt;code&gt;this.owner&lt;/code&gt; 对象，可以帮助我们创建或查询对象这是需要设置我们的测试。在此示例中，我们使用 &lt;code&gt;this.owner&lt;/code&gt; 对象查找成为测试对象的服务实例： &lt;code&gt;someThing&lt;/code&gt; 。请注意，在单元测试中，您可以通过相应地设置其属性来自定义任何被测对象。我们可以使用测试对象的 &lt;code&gt;set&lt;/code&gt; 方法来实现这一点。</target>
        </trans-unit>
        <trans-unit id="5aa5055098c1d7f1ee4bd170e24743c3af2dcaa6" translate="yes" xml:space="preserve">
          <source>See that we have used &lt;code&gt;moduleFor&lt;/code&gt;, one of the several unit-test helpers provided by Ember-Qunit. Test helpers provide us with some conveniences, such as the &lt;code&gt;subject&lt;/code&gt; function that handles lookup and instantiation for our object under test. Note that in a unit test you can customize the initialization of your object under test by passing to the &lt;code&gt;subject&lt;/code&gt; function an object containing the instance variables you would like to initialize. For example, to initialize the property 'foo' in our object under test, we would call &lt;code&gt;this.subject({ foo: 'bar' });&lt;/code&gt;</source>
          <target state="translated">看到我们使用了 &lt;code&gt;moduleFor&lt;/code&gt; ，这是Ember-Qunit提供的几个单元测试助手之一。测试助手为我们提供了一些便利，例如 &lt;code&gt;subject&lt;/code&gt; 函数可以处理被测对象的查找和实例化。请注意，在单元测试中，您可以通过将包含要初始化的实例变量的对象传递给 &lt;code&gt;subject&lt;/code&gt; 函数，来自定义被测对象的初始化。例如，要在测试对象中初始化属性&amp;ldquo; foo&amp;rdquo;，我们将调用 &lt;code&gt;this.subject({ foo: 'bar' });&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae9382bccb52583673509854efe6c33c1551b8a4" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://emberjs.com/guides/routing/rendering-a-template/&quot;&gt;routing guide&lt;/a&gt; for more information on how your &lt;code&gt;route&lt;/code&gt; interacts with the &lt;code&gt;{{outlet}}&lt;/code&gt; helper. Note: Your content &lt;strong&gt;will not render&lt;/strong&gt; if there isn't an &lt;code&gt;{{outlet}}&lt;/code&gt; for it.</source>
          <target state="translated">有关您的 &lt;code&gt;route&lt;/code&gt; 如何与 &lt;code&gt;{{outlet}}&lt;/code&gt; 帮助程序进行交互的更多信息，请参见&lt;a href=&quot;https://emberjs.com/guides/routing/rendering-a-template/&quot;&gt;路由指南&lt;/a&gt;。注意：如果没有 &lt;code&gt;{{outlet}}&lt;/code&gt; ，您的内容&lt;strong&gt;将不会呈现&lt;/strong&gt;。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2edbaf0ad072472661c6c4f6ea9bc0de07118fdf" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://guides.emberjs.com/release/configuring-ember/feature-flags/&quot;&gt;feature flag guide&lt;/a&gt; for more details.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;https://guides.emberjs.com/release/configuring-ember/feature-flags/&quot;&gt;功能标志指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ddb5210f337735b81962ad926f8b222ce36247c9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://guides.emberjs.com/release/routing/rendering-a-template/&quot;&gt;routing guide&lt;/a&gt; for more information on how your &lt;code&gt;route&lt;/code&gt; interacts with the &lt;code&gt;{{outlet}}&lt;/code&gt; helper. Note: Your content &lt;strong&gt;will not render&lt;/strong&gt; if there isn't an &lt;code&gt;{{outlet}}&lt;/code&gt; for it.</source>
          <target state="translated">有关您的 &lt;code&gt;route&lt;/code&gt; 如何与 &lt;code&gt;{{outlet}}&lt;/code&gt; 帮助程序进行交互的更多信息，请参见&lt;a href=&quot;https://guides.emberjs.com/release/routing/rendering-a-template/&quot;&gt;路由指南&lt;/a&gt;。注意：如果没有 &lt;code&gt;{{outlet}}&lt;/code&gt; ，您的内容&lt;strong&gt;将不会呈现&lt;/strong&gt;。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a57805751973ea57faaaae7c6e36d1170562cb5e" translate="yes" xml:space="preserve">
          <source>See the &lt;code&gt;normalize&lt;/code&gt; documentation for more information.</source>
          <target state="translated">有关更多信息，请参见 &lt;code&gt;normalize&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="466a6e9c7a1e57a171042a7f153306f2eec6b51f" translate="yes" xml:space="preserve">
          <source>See the Handlebars documentation on &lt;a href=&quot;http://handlebarsjs.com/#block-expressions&quot;&gt;block expressions&lt;/a&gt; for more.</source>
          <target state="translated">有关更多信息，请参见有关&lt;a href=&quot;http://handlebarsjs.com/#block-expressions&quot;&gt;表达式&lt;/a&gt;的Handlebars文档。</target>
        </trans-unit>
        <trans-unit id="9f864ff30f39009bee652eeaa77b5d4e2cb3c219" translate="yes" xml:space="preserve">
          <source>See the documentation for &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; for more information.</source>
          <target state="translated">有关更多信息，请参见 &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="f9ec3fb36372bb7e739319f5901a89f1c01950e5" translate="yes" xml:space="preserve">
          <source>See the documentation on &lt;code&gt;Application&lt;/code&gt;'s &lt;code&gt;rootElement&lt;/code&gt; for details.</source>
          <target state="translated">有关详细信息，请参见 &lt;code&gt;Application&lt;/code&gt; 的 &lt;code&gt;rootElement&lt;/code&gt; 上的文档。</target>
        </trans-unit>
        <trans-unit id="ea7a7d93a5f6e7b777d76bb4492e53852bacf5fc" translate="yes" xml:space="preserve">
          <source>See the documentation on &lt;code&gt;BootOptions&lt;/code&gt; for the options it takes.</source>
          <target state="translated">请参阅 &lt;code&gt;BootOptions&lt;/code&gt; 上的文档以获取所需的选项。</target>
        </trans-unit>
        <trans-unit id="9d1186a24f13f7ddf3bb7bc489fbe38dfa0116f7" translate="yes" xml:space="preserve">
          <source>See the documentation on &lt;code&gt;Ember.Applications&lt;/code&gt;'s &lt;code&gt;rootElement&lt;/code&gt; for details.</source>
          <target state="translated">有关详细信息，请参见 &lt;code&gt;Ember.Applications&lt;/code&gt; 的 &lt;code&gt;rootElement&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="dea9dace86fce4ca0506d1cbbe4c73c1b60d132e" translate="yes" xml:space="preserve">
          <source>See the documentation on the &lt;code&gt;isBrowser&lt;/code&gt;, &lt;code&gt;document&lt;/code&gt; and &lt;code&gt;rootElement&lt;/code&gt; properties on &lt;code&gt;ApplicationInstance.BootOptions&lt;/code&gt; for details.</source>
          <target state="translated">有关详细信息，请参见 &lt;code&gt;ApplicationInstance.BootOptions&lt;/code&gt; 上 &lt;code&gt;isBrowser&lt;/code&gt; ， &lt;code&gt;document&lt;/code&gt; 和 &lt;code&gt;rootElement&lt;/code&gt; 属性上的文档。</target>
        </trans-unit>
        <trans-unit id="1adc341f4763a89fa8173df93fc2565a43324631" translate="yes" xml:space="preserve">
          <source>See the documentation on the &lt;code&gt;isBrowser&lt;/code&gt;, &lt;code&gt;document&lt;/code&gt; and &lt;code&gt;rootElement&lt;/code&gt; properties on &lt;code&gt;Ember.ApplicationInstance.BootOptions&lt;/code&gt; for details.</source>
          <target state="translated">查看该文档 &lt;code&gt;isBrowser&lt;/code&gt; ， &lt;code&gt;document&lt;/code&gt; 和 &lt;code&gt;rootElement&lt;/code&gt; 的对性能的 &lt;code&gt;Ember.ApplicationInstance.BootOptions&lt;/code&gt; 了解详情。</target>
        </trans-unit>
        <trans-unit id="1824d460f7c3833816d20ccdd7e4598d1c806c7e" translate="yes" xml:space="preserve">
          <source>See the list of event names at the end of this page. Any event can be defined as an event handler in your component.</source>
          <target state="translated">请看本页末尾的事件名称列表。任何事件都可以在你的组件中被定义为事件处理程序。</target>
        </trans-unit>
        <trans-unit id="1a127955b9093eefeadddc3e86e6bc2ecfb11432" translate="yes" xml:space="preserve">
          <source>See {{#crossLink &quot;Ember.String/pluralize&quot;}}{{/crossLink}}</source>
          <target state="translated">见{{#crossLink &quot;Ember.String/pluralize&quot;}}{{/crossLink}}。</target>
        </trans-unit>
        <trans-unit id="b2ec09c4221cd9352fad5f335a19d089d3aff099" translate="yes" xml:space="preserve">
          <source>See {{#crossLink &quot;Ember.String/singularize&quot;}}{{/crossLink}}</source>
          <target state="translated">见{{#crossLink &quot;Ember.String/singularize&quot;}}{{/crossLink}}。</target>
        </trans-unit>
        <trans-unit id="091a6847e80f8f6e58ab446255013d6e21fc3d12" translate="yes" xml:space="preserve">
          <source>Self-Closing Tags</source>
          <target state="translated">自闭式标签</target>
        </trans-unit>
        <trans-unit id="4908850b77074857fa2902c9a0c51ac951c3d066" translate="yes" xml:space="preserve">
          <source>Send an event. The execution of suspended listeners is skipped, and once listeners are removed. A listener without a target is executed on the passed object. If an array of actions is not passed, the actions stored on the passed object are invoked.</source>
          <target state="translated">发送一个事件。跳过执行暂停的监听器,一旦监听器被删除。没有目标的监听器会在传递的对象上执行。如果没有传递动作数组,则调用存储在传递对象上的动作。</target>
        </trans-unit>
        <trans-unit id="a7cbd3195b0b1848a603028087345561cbdb3c83" translate="yes" xml:space="preserve">
          <source>Sending Actions</source>
          <target state="translated">发送动作</target>
        </trans-unit>
        <trans-unit id="090be3d6246540fa8c78341d0fd9ec8bb7d44ef7" translate="yes" xml:space="preserve">
          <source>Sending from the Console to the Inspector</source>
          <target state="translated">从控制台发送至检查员</target>
        </trans-unit>
        <trans-unit id="064119347ce21be3830f42ad99fd305e6bb36ddb" translate="yes" xml:space="preserve">
          <source>Sending from the Inspector to the Console</source>
          <target state="translated">从检查员发送至控制台</target>
        </trans-unit>
        <trans-unit id="37adf51f8e931f4ac6beffdc0bce4b8c9a345a4c" translate="yes" xml:space="preserve">
          <source>Sends a delete request for the record to the server.</source>
          <target state="translated">向服务器发送删除记录的请求。</target>
        </trans-unit>
        <trans-unit id="291d83532f286c48f65ce13d9158d367234e5871" translate="yes" xml:space="preserve">
          <source>Sends an action to the router, which will delegate it to the currently active route hierarchy per the bubbling rules explained under &lt;code&gt;actions&lt;/code&gt;.</source>
          <target state="translated">向路由器发送一个操作，该操作将根据 &lt;code&gt;actions&lt;/code&gt; 下说明的冒泡规则将其委派给当前活动的路由层次结构。</target>
        </trans-unit>
        <trans-unit id="21f60515d4413efa1948ac110388d426adab17c9" translate="yes" xml:space="preserve">
          <source>Serialize &lt;code&gt;belongsTo&lt;/code&gt; relationship when it is configured as an embedded object.</source>
          <target state="translated">序列化 &lt;code&gt;belongsTo&lt;/code&gt; 当它被配置作为嵌入对象的关系。</target>
        </trans-unit>
        <trans-unit id="59bee72c1fd17c82da45c231f035a209dfdee94a" translate="yes" xml:space="preserve">
          <source>Serializer</source>
          <target state="translated">Serializer</target>
        </trans-unit>
        <trans-unit id="ba84cd3aab23d1d10e849506dac174ba63cacf16" translate="yes" xml:space="preserve">
          <source>Serializer Resolution</source>
          <target state="translated">序列器分辨率</target>
        </trans-unit>
        <trans-unit id="77f5a897d372d976dbdf3ed3fd84a1f9fe2c636a" translate="yes" xml:space="preserve">
          <source>Serializes &lt;code&gt;hasMany&lt;/code&gt; relationships when it is configured as embedded objects.</source>
          <target state="translated">将 &lt;code&gt;hasMany&lt;/code&gt; 关系配置为嵌入式对象时，将其序列化。</target>
        </trans-unit>
        <trans-unit id="859739a640dcccec7d3c89114d041ab46afff14a" translate="yes" xml:space="preserve">
          <source>Serializes the record and sends it to the server.</source>
          <target state="translated">将记录序列化并发送至服务器。</target>
        </trans-unit>
        <trans-unit id="aa92b22d8e89b667210a07e5334e64f079da918f" translate="yes" xml:space="preserve">
          <source>Serializes the record update and sends it to the server.</source>
          <target state="translated">将记录更新序列化并发送至服务器。</target>
        </trans-unit>
        <trans-unit id="761efa682a827fca2803f8da4a302dc39dc2208e" translate="yes" xml:space="preserve">
          <source>Serializing a &lt;code&gt;belongsTo&lt;/code&gt; relationship removes the property that refers to the parent record</source>
          <target state="translated">序列化一个 &lt;code&gt;belongsTo&lt;/code&gt; 关系会删除引用父记录的属性</target>
        </trans-unit>
        <trans-unit id="5fe4ca86767cc1bd91544bb1b9f91724e637ec8b" translate="yes" xml:space="preserve">
          <source>Serializing a &lt;code&gt;hasMany&lt;/code&gt; relationship does not remove the property that refers to the parent record.</source>
          <target state="translated">序列化 &lt;code&gt;hasMany&lt;/code&gt; 关系不会删除引用父记录的属性。</target>
        </trans-unit>
        <trans-unit id="b6798f213d4815c22490d46bda891a2bbd22a2a8" translate="yes" xml:space="preserve">
          <source>Serializing records</source>
          <target state="translated">记录的序列化</target>
        </trans-unit>
        <trans-unit id="01fe9a20a8fdeb0f312fdcea1363c6a939cf772b" translate="yes" xml:space="preserve">
          <source>Server-Side Rendering</source>
          <target state="translated">服务器端渲染</target>
        </trans-unit>
        <trans-unit id="d4b08fda9668f41846dc7fb238475372e5a87571" translate="yes" xml:space="preserve">
          <source>Server-Side Rendering (also known as FastBoot)</source>
          <target state="translated">服务器端渲染(也称为FastBoot)</target>
        </trans-unit>
        <trans-unit id="ddedf41976a8db9f179e56d77dad30a5828aa47a" translate="yes" xml:space="preserve">
          <source>Server-Side Resource Discovery</source>
          <target state="translated">服务器端资源发现</target>
        </trans-unit>
        <trans-unit id="626629d0773ba5b8e704de2a8cf4d1b2671d6966" translate="yes" xml:space="preserve">
          <source>Server-backed API calls that may not fit Ember Data.</source>
          <target state="translated">服务器支持的API调用,可能不适合Ember Data。</target>
        </trans-unit>
        <trans-unit id="3788673593a9fb3cb0da7a56e2684739ac286fa2" translate="yes" xml:space="preserve">
          <source>Server-sent events or notifications.</source>
          <target state="translated">服务器发送的事件或通知。</target>
        </trans-unit>
        <trans-unit id="9b6a5da899565637a0947288637800a9aafb0780" translate="yes" xml:space="preserve">
          <source>ServerError</source>
          <target state="translated">ServerError</target>
        </trans-unit>
        <trans-unit id="acca64b83535b9a1dff37a13cd176f393be7c195" translate="yes" xml:space="preserve">
          <source>Servers</source>
          <target state="translated">Servers</target>
        </trans-unit>
        <trans-unit id="329cb8b6ba8c427be7c09b298295c655415c7ac9" translate="yes" xml:space="preserve">
          <source>Service</source>
          <target state="translated">Service</target>
        </trans-unit>
        <trans-unit id="24bd63c80b86894e4c67eb6439773461722ba2f2" translate="yes" xml:space="preserve">
          <source>Service injections and arguments are available in the constructor.</source>
          <target state="translated">服务注入和参数在构造函数中是可用的。</target>
        </trans-unit>
        <trans-unit id="5cbd584046863bc7b753e57e8681a98a87f36f0f" translate="yes" xml:space="preserve">
          <source>Services</source>
          <target state="translated">Services</target>
        </trans-unit>
        <trans-unit id="8c95ce8ed53a712d7d11fe978a559e8aacdfb5cc" translate="yes" xml:space="preserve">
          <source>Services and Utilities</source>
          <target state="translated">服务和公用事业</target>
        </trans-unit>
        <trans-unit id="973e47a9c7779d6a3f292ac37ac9d79ba9c45893" translate="yes" xml:space="preserve">
          <source>Services are useful for features that require shared state or persistent connections. Example uses of services might include:</source>
          <target state="translated">服务对于需要共享状态或持久连接的功能非常有用。服务的使用实例可能包括:</target>
        </trans-unit>
        <trans-unit id="44de33fce9e667d81467d696283b746a2b89ae0f" translate="yes" xml:space="preserve">
          <source>Services can be generated using Ember CLI's &lt;code&gt;service&lt;/code&gt; generator. For example, the following command will create the &lt;code&gt;ShoppingCart&lt;/code&gt; service:</source>
          <target state="translated">可以使用Ember CLI的 &lt;code&gt;service&lt;/code&gt; 生成器生成服务。例如，以下命令将创建 &lt;code&gt;ShoppingCart&lt;/code&gt; 服务：</target>
        </trans-unit>
        <trans-unit id="f28ef67c082d95db9b197a590c7d6ac777b73ad0" translate="yes" xml:space="preserve">
          <source>Services must extend the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Service.html&quot;&gt;&lt;code&gt;Ember.Service&lt;/code&gt;&lt;/a&gt; base class:</source>
          <target state="translated">服务必须扩展&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Service.html&quot;&gt; &lt;code&gt;Ember.Service&lt;/code&gt; &lt;/a&gt;基类：</target>
        </trans-unit>
        <trans-unit id="05197f4ec7c1ead15af7cb4af2fab7e9ba449c55" translate="yes" xml:space="preserve">
          <source>Services must extend the &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Service&quot;&gt;&lt;code&gt;Service&lt;/code&gt;&lt;/a&gt; base class:</source>
          <target state="translated">服务必须扩展&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Service&quot;&gt; &lt;code&gt;Service&lt;/code&gt; &lt;/a&gt;基类：</target>
        </trans-unit>
        <trans-unit id="8d8ded186c4b66ab76f84a5c45d66e048959d458" translate="yes" xml:space="preserve">
          <source>Services which can be injected into multiple classes, sharing functionality and state between them.</source>
          <target state="translated">可以注入到多个类中的服务,它们之间共享功能和状态。</target>
        </trans-unit>
        <trans-unit id="ca477a114f59f850145f1a7532f31375acde781f" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;EmberENV.FEATURES&lt;/code&gt; in your application's &lt;code&gt;config/environment.js&lt;/code&gt; file to enable canary features in your application.</source>
          <target state="translated">在应用程序的 &lt;code&gt;config/environment.js&lt;/code&gt; 文件中设置 &lt;code&gt;EmberENV.FEATURES&lt;/code&gt; ,以在应用程序中启用canary功能。</target>
        </trans-unit>
        <trans-unit id="ac2ee51eb0d899834a5e76d58a0d52b264a8975b" translate="yes" xml:space="preserve">
          <source>Set a list of properties on an object. These properties are set inside a single &lt;code&gt;beginPropertyChanges&lt;/code&gt; and &lt;code&gt;endPropertyChanges&lt;/code&gt; batch, so observers will be buffered.</source>
          <target state="translated">设置对象的属性列表。这些属性设置在单个 &lt;code&gt;beginPropertyChanges&lt;/code&gt; 和 &lt;code&gt;endPropertyChanges&lt;/code&gt; 批处理中，因此将缓冲观察者。</target>
        </trans-unit>
        <trans-unit id="bb507d8cf4504dfd969277729f9d6cb3da94b46d" translate="yes" xml:space="preserve">
          <source>Set the value of a boolean property to the opposite of its current value.</source>
          <target state="translated">将布尔属性的值设置为与其当前值相反的值。</target>
        </trans-unit>
        <trans-unit id="354b450dc637fea87122e449b4c6d64fd161d127" translate="yes" xml:space="preserve">
          <source>Set the value of a property to the current value minus some amount.</source>
          <target state="translated">将属性的值设置为当前值减去某个金额。</target>
        </trans-unit>
        <trans-unit id="0a474206fc22982beb1518f159723d7d5b1a7bd6" translate="yes" xml:space="preserve">
          <source>Set the value of a property to the current value plus some amount.</source>
          <target state="translated">将属性的价值设置为当前价值加上一定的金额。</target>
        </trans-unit>
        <trans-unit id="e42433abf46583349e14e913f6b0bddd60fc0563" translate="yes" xml:space="preserve">
          <source>Set this to provide an alternate class to &lt;code&gt;DefaultResolver&lt;/code&gt;</source>
          <target state="translated">设置此项 &lt;code&gt;DefaultResolver&lt;/code&gt; 提供替代类</target>
        </trans-unit>
        <trans-unit id="022856defe2402ee0a7880769473d89d1b0fd118" translate="yes" xml:space="preserve">
          <source>Set this to provide an alternate class to &lt;code&gt;Ember.DefaultResolver&lt;/code&gt;</source>
          <target state="translated">设置此项以提供 &lt;code&gt;Ember.DefaultResolver&lt;/code&gt; 的替代类。</target>
        </trans-unit>
        <trans-unit id="b2871131570de12ffc4fe0e0fa49f2aa7a81352e" translate="yes" xml:space="preserve">
          <source>Sets a list of properties at once. These properties are set inside a single &lt;code&gt;beginPropertyChanges&lt;/code&gt; and &lt;code&gt;endPropertyChanges&lt;/code&gt; batch, so observers will be buffered.</source>
          <target state="translated">一次设置属性列表。这些属性设置在单个 &lt;code&gt;beginPropertyChanges&lt;/code&gt; 和 &lt;code&gt;endPropertyChanges&lt;/code&gt; 批处理中，因此将缓冲观察者。</target>
        </trans-unit>
        <trans-unit id="2478dff276ae3c77d7f495b39bbafe7dedf46174" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;disabled&lt;/code&gt; attribute of the &lt;code&gt;Checkbox&lt;/code&gt;'s element</source>
          <target state="translated">设置 &lt;code&gt;Checkbox&lt;/code&gt; 元素的 &lt;code&gt;disabled&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="e54a99e025defe6d81185356e0087e36fb02c41f" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;rel&lt;/code&gt; attribute of the &lt;code&gt;LinkComponent&lt;/code&gt;'s HTML element.</source>
          <target state="translated">设置 &lt;code&gt;LinkComponent&lt;/code&gt; 的HTML元素的 &lt;code&gt;rel&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="d5e1f88540ae2f1f6c34ad87101fb61aaa2e4704" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;tabindex&lt;/code&gt; attribute of the &lt;code&gt;LinkComponent&lt;/code&gt;'s HTML element.</source>
          <target state="translated">设置 &lt;code&gt;LinkComponent&lt;/code&gt; 的HTML元素的 &lt;code&gt;tabindex&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="2bdac2845cc69ea660701ca0222c09a0c44c26f0" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;target&lt;/code&gt; attribute of the &lt;code&gt;LinkComponent&lt;/code&gt;'s HTML element.</source>
          <target state="translated">设置 &lt;code&gt;LinkComponent&lt;/code&gt; 的HTML元素的 &lt;code&gt;target&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="fcf346b3d86476123ef32bd696299134f1d94520" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;title&lt;/code&gt; attribute of the &lt;code&gt;LinkComponent&lt;/code&gt;'s HTML element.</source>
          <target state="translated">设置 &lt;code&gt;LinkComponent&lt;/code&gt; 的HTML元素的 &lt;code&gt;title&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="51b9025622045e7bea6fb4165ada413012de1269" translate="yes" xml:space="preserve">
          <source>Sets the URL-changing method to be employed at the end of a successful transition. By default, a new Transition will just use &lt;code&gt;updateURL&lt;/code&gt;, but passing 'replace' to this method will cause the URL to update using 'replaceWith' instead. Omitting a parameter will disable the URL change, allowing for transitions that don't update the URL at completion (this is also used for handleURL, since the URL has already changed before the transition took place).</source>
          <target state="translated">设置成功转换结束时要使用的URL更改方法。默认情况下，新的Transition将仅使用 &lt;code&gt;updateURL&lt;/code&gt; ，但是将'replace'传递给此方法将导致URL使用'replaceWith'进行更新。省略参数将禁用URL更改，从而允许在转换完成时不更新URL的转换（这也用于handleURL，因为URL在转换之前已经更改了）。</target>
        </trans-unit>
        <trans-unit id="b72787353f86d425923f841fb4aef6f74ac404b9" translate="yes" xml:space="preserve">
          <source>Sets the dependent keys on this computed property. Pass any number of arguments containing key paths that this computed property depends on.</source>
          <target state="translated">设置此计算属性的依赖键。传递任意数量的参数,这些参数包含这个计算属性所依赖的键路径。</target>
        </trans-unit>
        <trans-unit id="2f675f90939d774f421170557b095c97251f63f9" translate="yes" xml:space="preserve">
          <source>Sets the helper manager for an object or function.</source>
          <target state="translated">设置对象或函数的辅助管理器。</target>
        </trans-unit>
        <trans-unit id="8dcc21cc9416b36d9a48400e5dcfa0b900385d0e" translate="yes" xml:space="preserve">
          <source>Sets the provided key or path to the value.</source>
          <target state="translated">将提供的键或路径设置为值。</target>
        </trans-unit>
        <trans-unit id="871a5db89a47b1c8ac126c47ae45dbaed6801707" translate="yes" xml:space="preserve">
          <source>Sets the value of a property on an object, respecting computed properties and notifying observers and other listeners of the change. If the property is not defined but the object implements the &lt;code&gt;setUnknownProperty&lt;/code&gt; method then that will be invoked as well.</source>
          <target state="translated">设置对象上的属性值，同时尊重计算所得的属性并将更改通知给观察者和其他侦听器。如果未定义属性，但是对象实现 &lt;code&gt;setUnknownProperty&lt;/code&gt; 方法，则该方法也会被调用。</target>
        </trans-unit>
        <trans-unit id="4d62cb5e39e4fa575e3defe17489ed6fd18a914c" translate="yes" xml:space="preserve">
          <source>Sets the value of a property on an object, respecting computed properties and notifying observers and other listeners of the change. If the specified property is not defined on the object and the object implements the &lt;code&gt;setUnknownProperty&lt;/code&gt; method, then instead of setting the value of the property on the object, its &lt;code&gt;setUnknownProperty&lt;/code&gt; handler will be invoked with the two parameters &lt;code&gt;keyName&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">设置对象上的属性值，同时尊重计算所得的属性并将更改通知给观察者和其他侦听器。如果未在对象上定义指定的属性，并且该对象实现了 &lt;code&gt;setUnknownProperty&lt;/code&gt; 方法，则将使用两个参数 &lt;code&gt;keyName&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 调用其 &lt;code&gt;setUnknownProperty&lt;/code&gt; 处理程序，而不是在该对象上设置属性的值。</target>
        </trans-unit>
        <trans-unit id="290a8a4289954bb2a5ee87f2331ca5e9d2142b2b" translate="yes" xml:space="preserve">
          <source>Sets the value on the named property for each member. This is more ergonomic than using other methods defined on this helper. If the object implements Ember.Observable, the value will be changed to &lt;code&gt;set(),&lt;/code&gt; otherwise it will be set directly. &lt;code&gt;null&lt;/code&gt; objects are skipped.</source>
          <target state="translated">在每个成员的命名属性上设置值。与使用此助手上定义的其他方法相比，这更符合人体工程学。如果对象实现Ember.Observable，则该值将更改为 &lt;code&gt;set(),&lt;/code&gt; 否则将直接设置。 &lt;code&gt;null&lt;/code&gt; 对象将被跳过。</target>
        </trans-unit>
        <trans-unit id="742c211cf05d64e5ad624ceb43a028370924a427" translate="yes" xml:space="preserve">
          <source>Sets the value on the named property for each member. This is more ergonomic than using other methods defined on this helper. If the object implements Observable, the value will be changed to &lt;code&gt;set(),&lt;/code&gt; otherwise it will be set directly. &lt;code&gt;null&lt;/code&gt; objects are skipped.</source>
          <target state="translated">在每个成员的命名属性上设置值。与使用此助手上定义的其他方法相比，这更符合人体工程学。如果对象实现Observable，则该值将更改为 &lt;code&gt;set(),&lt;/code&gt; 否则将直接设置。 &lt;code&gt;null&lt;/code&gt; 对象将被跳过。</target>
        </trans-unit>
        <trans-unit id="8bb3a4f26234490d92af65a4b7728511ce022d83" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;serialize&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; enforces serialization for hasMany relationships even if it's neither a many-to-many nor many-to-none relationship.</source>
          <target state="translated">将 &lt;code&gt;serialize&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 可以强制hasMany关系进行序列化，即使它既不是多对多关系也不是多对无关系。</target>
        </trans-unit>
        <trans-unit id="b425d7e560cd8c0761f98a652da8de1351923229" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;sortQueryParams&lt;/code&gt; to a falsey value will respect the original order.</source>
          <target state="translated">将 &lt;code&gt;sortQueryParams&lt;/code&gt; 设置为falsey值将遵循原始顺序。</target>
        </trans-unit>
        <trans-unit id="da33b396a5b97cdc6b9f02bcd176c913528421e0" translate="yes" xml:space="preserve">
          <source>Setting Computed Properties</source>
          <target state="translated">设置计算属性</target>
        </trans-unit>
        <trans-unit id="b2159831f0f013e12890235b72b76c9ed8107ba6" translate="yes" xml:space="preserve">
          <source>Setting any dependent property will propagate changes through any computed properties that depend on them, all the way down the chain of computed properties you've created.</source>
          <target state="translated">设置任何依赖性属性都会通过任何依赖它们的计算属性传播改变,一直到你创建的计算属性链。</target>
        </trans-unit>
        <trans-unit id="4c811f11c80da676754851d73427229f494eb7e2" translate="yes" xml:space="preserve">
          <source>Setting attributes on &lt;code&gt;&amp;lt;Input&amp;gt;&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;Input&amp;gt;&lt;/code&gt; 上设置属性</target>
        </trans-unit>
        <trans-unit id="3caba60e55b03843eed07241fa6a00961df6443b" translate="yes" xml:space="preserve">
          <source>Setting attributes on &lt;code&gt;&amp;lt;Textarea&amp;gt;&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;&amp;lt;Textarea&amp;gt;&lt;/code&gt; 上设置属性</target>
        </trans-unit>
        <trans-unit id="5789f3a613624c39e98b0a04a128ab506fbe4ddc" translate="yes" xml:space="preserve">
          <source>Setting coalesceFindRequests to &lt;code&gt;true&lt;/code&gt; also works for &lt;code&gt;store.find&lt;/code&gt; requests and &lt;code&gt;belongsTo&lt;/code&gt; relationships accessed within the same runloop. If you set &lt;code&gt;coalesceFindRequests: true&lt;/code&gt;</source>
          <target state="translated">将 &lt;code&gt;store.find&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 也适用于在同一运行循环中访问的store.find请求和 &lt;code&gt;belongsTo&lt;/code&gt; 关系。如果您设置 &lt;code&gt;coalesceFindRequests: true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e771b554952852c7a0bf2e49bb60a2514950d6a7" translate="yes" xml:space="preserve">
          <source>Setting properties on an HTML element, on the other hand, is a different story, because there's no way to set a property using HTML syntax.</source>
          <target state="translated">而在HTML元素上设置属性则是另一回事,因为没有办法使用HTML语法来设置属性。</target>
        </trans-unit>
        <trans-unit id="afe29c914c9d854075bf9ebee96af7585fe24770" translate="yes" xml:space="preserve">
          <source>Setting properties on the component in &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement&quot;&gt;&lt;code&gt;didInsertElement()&lt;/code&gt;&lt;/a&gt; triggers a re-render, and for performance reasons, is not allowed.</source>
          <target state="translated">在&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#event_didInsertElement&quot;&gt; &lt;code&gt;didInsertElement()&lt;/code&gt; 中&lt;/a&gt;在组件上设置属性会触发重新渲染，并且出于性能原因，这是不允许的。</target>
        </trans-unit>
        <trans-unit id="f02aee210f24787a1e623ad68c0d1a1b060d3aeb" translate="yes" xml:space="preserve">
          <source>Setting query-params</source>
          <target state="translated">设置查询参数</target>
        </trans-unit>
        <trans-unit id="3d7cc07cf937737b1517c6bf9374d4cc18998479" translate="yes" xml:space="preserve">
          <source>Setting up Data for the Nested Detail Route</source>
          <target state="translated">设置嵌套的详细路线的数据</target>
        </trans-unit>
        <trans-unit id="04b56454c3e76a73bcf804097a9d07a7e2424bf3" translate="yes" xml:space="preserve">
          <source>Setup callbacks to be fired when the test helpers are injected into your application.</source>
          <target state="translated">设置回调,当测试辅助程序被注入到你的应用程序中时,回调将被触发。</target>
        </trans-unit>
        <trans-unit id="7fd361ad8b078a558ea7b7da0dad0bbe6c028891" translate="yes" xml:space="preserve">
          <source>Several of the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html&quot;&gt;Ember.computed&lt;/a&gt; macros utilize the &lt;code&gt;[]&lt;/code&gt; key to implement common use-cases. For instance, to create a computed property that mapped properties from an array, you could use &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html#method_map&quot;&gt;Ember.computed.map&lt;/a&gt; or build the computed property yourself:</source>
          <target state="translated">一些&lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html&quot;&gt;Ember.computed&lt;/a&gt;宏利用 &lt;code&gt;[]&lt;/code&gt; 键来实现常见的用例。例如，要创建一个从数组映射属性的计算属性，可以使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html#method_map&quot;&gt;Ember.computed.map&lt;/a&gt;或自己构建该计算属性：</target>
        </trans-unit>
        <trans-unit id="56671d09d11f94a0111d047a53973e69ddd5107c" translate="yes" xml:space="preserve">
          <source>Shadow DOM</source>
          <target state="translated">影子DOM</target>
        </trans-unit>
        <trans-unit id="a07efaea553500b80c6b1e25c2a1ad7f85b92746" translate="yes" xml:space="preserve">
          <source>Sharing Component Data with its Wrapped Content</source>
          <target state="translated">共享组件数据与其封装的内容</target>
        </trans-unit>
        <trans-unit id="5765ccb23e0fb8bade85df4ffb0d4efcfedb02e5" translate="yes" xml:space="preserve">
          <source>Shift an object from start of array or nil if none are left. Works just like &lt;code&gt;shift()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">将对象从数组的开头移至nil（如果不留任何对象）。就像 &lt;code&gt;shift()&lt;/code&gt; 一样工作，但是它兼容KVO。</target>
        </trans-unit>
        <trans-unit id="bcb7f8e893a6eec69601e5f12cb167564cd7ea66" translate="yes" xml:space="preserve">
          <source>Should I use controllers in my application? I've heard they're going away!</source>
          <target state="translated">我应该在应用中使用控制器吗?我听说它们要消失了!</target>
        </trans-unit>
        <trans-unit id="beeea36abf2de6573612e2054086e5dc5b962f2d" translate="yes" xml:space="preserve">
          <source>Should actually replace the specified objects on the content array. You can override this method in subclasses to transform the content item into something new.</source>
          <target state="translated">实际上应该替换内容数组上的指定对象。你可以在子类中重写这个方法,将内容项转化为新的东西。</target>
        </trans-unit>
        <trans-unit id="6c4c063ccc2f6265cd6469510436e8100e2e23a9" translate="yes" xml:space="preserve">
          <source>Should actually retrieve the object at the specified index from the content. You can override this method in subclasses to transform the content item to something new.</source>
          <target state="translated">实际上应该从内容中检索指定索引处的对象。你可以在子类中重写这个方法,将内容项转化为新的东西。</target>
        </trans-unit>
        <trans-unit id="ce6b3b9a9ec11b6f601d2c791d118fb24339f616" translate="yes" xml:space="preserve">
          <source>Should cause Ember to rerender if and when they change</source>
          <target state="translated">如果他们改变了,应该会导致微光城重新渲染。</target>
        </trans-unit>
        <trans-unit id="283dd7128cd25f308270c83f4e6274499295d261" translate="yes" xml:space="preserve">
          <source>Should we use controllers in my application? I've heard they're going away!</source>
          <target state="translated">我们应该在我的应用程序中使用控制器吗?我听说它们要消失了!</target>
        </trans-unit>
        <trans-unit id="e3cbebe0c33c59b226e4d26667ceeeb607570eb4" translate="yes" xml:space="preserve">
          <source>Show more details for a selected rental</source>
          <target state="translated">显示所选租金的更多细节</target>
        </trans-unit>
        <trans-unit id="63295e39bc7e2edd921e15de80cf52a0162dce6f" translate="yes" xml:space="preserve">
          <source>Show rentals on the home page</source>
          <target state="translated">在主页上显示租房信息</target>
        </trans-unit>
        <trans-unit id="a6df6bc849e9ed5bad5bd1b761e2d78888c983b9" translate="yes" xml:space="preserve">
          <source>Showing a property</source>
          <target state="translated">显示房产</target>
        </trans-unit>
        <trans-unit id="5feabe6b60582bbf4b541103f30632fee297466c" translate="yes" xml:space="preserve">
          <source>Sideloaded Data</source>
          <target state="translated">侧载数据</target>
        </trans-unit>
        <trans-unit id="f5028052c614a640caa81611333680ece76b35e0" translate="yes" xml:space="preserve">
          <source>Silencing Deprecation Warnings During Compile</source>
          <target state="translated">在编译过程中消除弃用警告。</target>
        </trans-unit>
        <trans-unit id="41b23908c12c4f5949e08b4e02f7c021d977337b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;transitionTo&lt;/code&gt;, but instead of adding the destination to the browser's URL history, it replaces the entry for the current route. When the user clicks the &quot;back&quot; button in the browser, there will be fewer steps. This is most commonly used to manage redirects in a way that does not cause confusing additions to the user's browsing history.</source>
          <target state="translated">与 &lt;code&gt;transitionTo&lt;/code&gt; 相似，但是它没有将目的地添加到浏览器的URL历史记录中，而是替换了当前路由的条目。当用户单击浏览器中的&amp;ldquo;后退&amp;rdquo;按钮时，步骤将更少。这最常用于管理重定向，其方式不会引起用户浏览历史记录的混乱。</target>
        </trans-unit>
        <trans-unit id="af61b24dae3801016bbf21366ede7ddbe142922e" translate="yes" xml:space="preserve">
          <source>Similar to how the default &lt;code&gt;loading&lt;/code&gt; event handlers are implemented, the default &lt;code&gt;error&lt;/code&gt; handlers will look for an appropriate error substate to enter, if one can be found.</source>
          <target state="translated">与实现默认 &lt;code&gt;loading&lt;/code&gt; 事件处理程序的方式类似，如果可以找到默认 &lt;code&gt;error&lt;/code&gt; 处理程序，默认错误处理程序将寻找要输入的适当错误子状态。</target>
        </trans-unit>
        <trans-unit id="717acf41849b10523800fa58b23cc2b20a9ef6da" translate="yes" xml:space="preserve">
          <source>Similar to map, this specialized function returns the value of the named property on all items in the enumeration.</source>
          <target state="translated">与map类似,这个专门的函数返回命名属性在枚举中所有项上的值。</target>
        </trans-unit>
        <trans-unit id="74e714802d7db3b86e903677715205f93a921c22" translate="yes" xml:space="preserve">
          <source>Similarly, if your backend store provides data in a format other than JSON API, you can use the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalizeResponse&quot;&gt;&lt;code&gt;normalizeResponse()&lt;/code&gt;&lt;/a&gt; hook. Using the same example as above, if the server provides data that looks like:</source>
          <target state="translated">同样，如果后端存储以JSON API以外的格式提供数据，则可以使用&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalizeResponse&quot;&gt; &lt;code&gt;normalizeResponse()&lt;/code&gt; &lt;/a&gt;挂钩。使用与上述相同的示例，如果服务器提供的数据如下所示：</target>
        </trans-unit>
        <trans-unit id="3618bd19508f0430379f994f5efcc9f7fdc1d229" translate="yes" xml:space="preserve">
          <source>Similarly, if your backend store provides data in a format other than JSON:API, you can use the &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/JSONAPISerializer/methods#normalizeResponse&quot;&gt;&lt;code&gt;normalizeResponse()&lt;/code&gt;&lt;/a&gt; hook. Using the same example as above, if the server provides data that looks like:</source>
          <target state="translated">同样，如果您的后端存储以JSON：API以外的格式提供数据，则可以使用&lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/JSONAPISerializer/methods#normalizeResponse&quot;&gt; &lt;code&gt;normalizeResponse()&lt;/code&gt; &lt;/a&gt;挂钩。使用与上述相同的示例，如果服务器提供的数据如下所示：</target>
        </trans-unit>
        <trans-unit id="e5ba23a2acdb58eae654126aeb02c16cfa736653" translate="yes" xml:space="preserve">
          <source>Similarly, in response to a &lt;code&gt;GET&lt;/code&gt; request for &lt;code&gt;/posts&lt;/code&gt;, the JSON should look like this:</source>
          <target state="translated">同样，响应对 &lt;code&gt;/posts&lt;/code&gt; 的 &lt;code&gt;GET&lt;/code&gt; 请求，JSON应如下所示：</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="translated">简单的例子</target>
        </trans-unit>
        <trans-unit id="5d072a0f490db522bd703110a84349b2f76d1d40" translate="yes" xml:space="preserve">
          <source>Simple Transition Example</source>
          <target state="translated">简单过渡示例</target>
        </trans-unit>
        <trans-unit id="38e622f586624128158ede91d1097cbecc68bbfa" translate="yes" xml:space="preserve">
          <source>Simply add &lt;code&gt;await pauseTest();&lt;/code&gt; to your test code, then save. When the test reaches this line, it will pause, allowing you to inspect the state of your application. When you are done, type &lt;code&gt;resumeTest()&lt;/code&gt; in the browser console to continue the test.</source>
          <target state="translated">只需添加一个 &lt;code&gt;await pauseTest();&lt;/code&gt; 到您的测试代码，然后保存。测试到达此行时，它将暂停，使您可以检查应用程序的状态。完成后，在浏览器控制台中键入 &lt;code&gt;resumeTest()&lt;/code&gt; 继续测试。</target>
        </trans-unit>
        <trans-unit id="7b4ed4e4198e38ae80e5b6a6af9aeb8f248f3233" translate="yes" xml:space="preserve">
          <source>Simply converts the enumerable into a genuine array. The order is not guaranteed. Corresponds to the method implemented by Prototype.</source>
          <target state="translated">只需将enumerable转换为真正的数组。顺序不保证。对应于Prototype实现的方法。</target>
        </trans-unit>
        <trans-unit id="58e976acf9398464f5580a302f815169000d3a0c" translate="yes" xml:space="preserve">
          <source>Simply converts the object into a genuine array. The order is not guaranteed. Corresponds to the method implemented by Prototype.</source>
          <target state="translated">只需将对象转换为一个真正的数组。顺序不保证。对应于Prototype实现的方法。</target>
        </trans-unit>
        <trans-unit id="fe202f68e7bb9a71a693a3787ee7684995266c8a" translate="yes" xml:space="preserve">
          <source>Simply define a template called &lt;code&gt;loading&lt;/code&gt; (and optionally a corresponding route) that Ember will transition to. The intermediate transition into the loading substate happens immediately (synchronously), the URL won't be updated, and, unlike other transitions, the currently active transition won't be aborted.</source>
          <target state="translated">只需定义一个称为 &lt;code&gt;loading&lt;/code&gt; （以及可选的相应路线）的模板，Ember将过渡到该模板。到加载子状态的中间过渡会立即（同步）发生，不会更新URL，并且与其他过渡不同，当前活动的过渡不会中止。</target>
        </trans-unit>
        <trans-unit id="97cf625e23a87e8fb775cd15dcb177e76da7d713" translate="yes" xml:space="preserve">
          <source>Simulates a key event type, e.g. &lt;code&gt;keypress&lt;/code&gt;, &lt;code&gt;keydown&lt;/code&gt;, &lt;code&gt;keyup&lt;/code&gt; with the desired keyCode on element found by the selector.</source>
          <target state="translated">用选择器找到的元素上的所需keyCode 模拟键事件类型，例如 &lt;code&gt;keypress&lt;/code&gt; ， &lt;code&gt;keydown&lt;/code&gt; ， &lt;code&gt;keyup&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d573de332969d08498e24e616e22a931b37eb39" translate="yes" xml:space="preserve">
          <source>Simulates a key event, e.g. &lt;code&gt;keypress&lt;/code&gt;, &lt;code&gt;keydown&lt;/code&gt;, &lt;code&gt;keyup&lt;/code&gt; with the desired keyCode Example:</source>
          <target state="translated">模拟一个按键事件，例如使用所需的keyCode进行 &lt;code&gt;keypress&lt;/code&gt; ， &lt;code&gt;keydown&lt;/code&gt; ， &lt;code&gt;keyup&lt;/code&gt; 的代码示例：</target>
        </trans-unit>
        <trans-unit id="5ff3adcfa93d61b2bd68be16bf0530824ab668cd" translate="yes" xml:space="preserve">
          <source>Simulating API requests</source>
          <target state="translated">模拟API请求</target>
        </trans-unit>
        <trans-unit id="fe22422d207cd0772ccfa88aaa36392c7d87ecf6" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;didUpdateAttrs&lt;/code&gt; is called prior to rerender, you can use this hook to execute code when specific attributes are changed. This hook can be an effective alternative to an observer, as it will run prior to a re-render, but after an attribute has changed.</source>
          <target state="translated">由于 &lt;code&gt;didUpdateAttrs&lt;/code&gt; 是在重新渲染之前调用的，因此可以在更改特定属性时使用此挂钩执行代码。该挂钩可以替代观察者，因为它会在重新渲染之前运行，但是在属性更改之后才能运行。</target>
        </trans-unit>
        <trans-unit id="f64ef341b1692fc1922e959a50c6efb02dd93401" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;srcObject&lt;/code&gt; is a property and not an HTML attribute, you can use the &lt;code&gt;prop&lt;/code&gt; element modifier from &lt;a href=&quot;https://www.npmjs.com/package/ember-prop-modifier&quot;&gt;ember-prop-modifier&lt;/a&gt; like this:</source>
          <target state="translated">由于 &lt;code&gt;srcObject&lt;/code&gt; 是属性而不是HTML属性，因此可以使用&lt;a href=&quot;https://www.npmjs.com/package/ember-prop-modifier&quot;&gt;ember-prop-modifier中&lt;/a&gt;的 &lt;code&gt;prop&lt;/code&gt; 元素修饰符，如下所示：</target>
        </trans-unit>
        <trans-unit id="b527d855f262ec89fbcbd6c18de1d551d43311d9" translate="yes" xml:space="preserve">
          <source>Since Ember addons are npm packages, &lt;code&gt;ember install&lt;/code&gt; installs them in the &lt;code&gt;node_modules&lt;/code&gt; directory, and makes an entry in &lt;code&gt;package.json&lt;/code&gt;. Be sure to restart your server after the addon has installed successfully. Restarting the server will incorporate the new CSS and refreshing the browser window will give you this:</source>
          <target state="translated">由于Ember插件是npm软件包，因此 &lt;code&gt;ember install&lt;/code&gt; 将它们安装在 &lt;code&gt;node_modules&lt;/code&gt; 目录中，并在 &lt;code&gt;package.json&lt;/code&gt; 中进行输入。确保插件成功安装后，重新启动服务器。重新启动服务器将包含新的CSS，刷新浏览器窗口将为您提供以下信息：</target>
        </trans-unit>
        <trans-unit id="ec8081d027ecc0077fdd772e1c50ff82e993f556" translate="yes" xml:space="preserve">
          <source>Since Ember is a template-oriented framework, not all developers need to use JavaScript when working on Ember apps. Some developers may be more focused on the structure of an app's templates, its styles, or the accessibility of an app. However, it's good to have some general knowledge of JavaScript for the places where it is used.</source>
          <target state="translated">由于Ember是一个面向模板的框架,并不是所有的开发者在处理Ember应用时都需要使用JavaScript。有些开发者可能更关注应用的模板结构、风格或应用的可访问性。不过,对于使用JavaScript的地方,掌握一些JavaScript的一般知识还是不错的。</target>
        </trans-unit>
        <trans-unit id="5760823c11d76bb4f0f8aa397fbe539249ff2741" translate="yes" xml:space="preserve">
          <source>Since a JSON API Document can have meta defined in multiple locations you can use the specific serializer hooks if you need to customize the meta.</source>
          <target state="translated">由于一个JSON API Document可以在多个位置定义元,如果你需要自定义元,你可以使用特定的序列器钩子。</target>
        </trans-unit>
        <trans-unit id="a3a256154d2dce95ced059699c91ae1f2f5c9d2c" translate="yes" xml:space="preserve">
          <source>Since a route's &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_beforeModel&quot;&gt;&lt;code&gt;beforeModel()&lt;/code&gt;&lt;/a&gt; executes before the &lt;code&gt;model()&lt;/code&gt; hook, it's a good place to do a redirect if you don't need any information that is contained in the model.</source>
          <target state="translated">由于路由的&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_beforeModel&quot;&gt; &lt;code&gt;beforeModel()&lt;/code&gt; &lt;/a&gt;在 &lt;code&gt;model()&lt;/code&gt; 挂钩之前执行，因此如果您不需要模型中包含的任何信息，则是进行重定向的好地方。</target>
        </trans-unit>
        <trans-unit id="682b1a98a4f99c8285fdf96f23e6c200bb6255b0" translate="yes" xml:space="preserve">
          <source>Since a route's &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#beforeModel&quot;&gt;&lt;code&gt;beforeModel()&lt;/code&gt;&lt;/a&gt; executes before the &lt;code&gt;model()&lt;/code&gt; hook, it's a good place to do a redirect if you don't need any information that is contained in the model.</source>
          <target state="translated">由于路由的&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/Route/methods#beforeModel&quot;&gt; &lt;code&gt;beforeModel()&lt;/code&gt; &lt;/a&gt;在 &lt;code&gt;model()&lt;/code&gt; 挂钩之前执行，因此如果您不需要模型中包含的任何信息，则是进行重定向的好地方。</target>
        </trans-unit>
        <trans-unit id="1df2b7cd90ba8966b9e8733c80dc430ec4b6a752" translate="yes" xml:space="preserve">
          <source>Since our component is expecting the filter process to be asynchronous, we return promises from our filter, using &lt;a href=&quot;http://emberjs.com/api/classes/RSVP.html&quot;&gt;Ember's RSVP library&lt;/a&gt;.</source>
          <target state="translated">由于我们的组件期望过滤器过程是异步的，因此我们使用&lt;a href=&quot;http://emberjs.com/api/classes/RSVP.html&quot;&gt;Ember的RSVP库&lt;/a&gt;从过滤器返回了Promise。</target>
        </trans-unit>
        <trans-unit id="410a75600d988e5e0052e587fd06ad0d2fe20811" translate="yes" xml:space="preserve">
          <source>Since our data is hard-coded in Mirage, we know that there is only one rental with a city name of &quot;Seattle&quot;, so we assert that the number of listings is one and that the location it displays is named, &quot;Seattle&quot;.</source>
          <target state="translated">由于我们的数据在Mirage中是硬编码的,所以我们知道只有一个城市名为 &quot;西雅图 &quot;的租房,所以我们断言房源数量是一个,而且它显示的位置名为,&quot;西雅图&quot;。</target>
        </trans-unit>
        <trans-unit id="cd893f3a53047516be9e73d4b5f5e2369b6477ff" translate="yes" xml:space="preserve">
          <source>Since tests are a core part of the Ember framework and your development cycle, we will dedicate several sections to learning how to write tests.</source>
          <target state="translated">由于测试是Ember框架和你的开发周期的核心部分,我们将用几个章节来学习如何编写测试。</target>
        </trans-unit>
        <trans-unit id="ba722444287b7c4015475cc81a6d6d752afc68bd" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;didReceiveAttrs&lt;/code&gt; hook is called every time a component's attributes are updated whether on render or re-render, you can use the hook to effectively act as an observer, ensuring code is executed every time an attribute changes.</source>
          <target state="translated">由于 &lt;code&gt;didReceiveAttrs&lt;/code&gt; 挂钩是在组件的属性每次在渲染或重新渲染时更新时调用的，因此您可以使用该挂钩有效地充当观察者，确保每次属性更改时都执行代码。</target>
        </trans-unit>
        <trans-unit id="a20cf75b3f9d9576789e92d06b30e1f775773a29" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;model&lt;/code&gt; hook is Promise-aware, it is great for making API requests (using tools like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;fetch&lt;/a&gt;) and returning the results.</source>
          <target state="translated">由于 &lt;code&gt;model&lt;/code&gt; 挂钩支持Promise，因此非常适合发出API请求（使用诸如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;fetch之类的&lt;/a&gt;工具）并返回结果。</target>
        </trans-unit>
        <trans-unit id="0f47663319ab899455b89bcb7770d1bba128290a" translate="yes" xml:space="preserve">
          <source>Since the scientist route is nested under the application route, Ember will render its content inside the application route template's &lt;code&gt;{{outlet}}&lt;/code&gt; directive.</source>
          <target state="translated">由于科学家路线嵌套在应用程序路线下，因此Ember会将其内容呈现在应用程序路线模板的 &lt;code&gt;{{outlet}}&lt;/code&gt; 指令中。</target>
        </trans-unit>
        <trans-unit id="28d7c278a30e6ec4d4f3023b775fa6840cb84e97" translate="yes" xml:space="preserve">
          <source>Since the specific &lt;code&gt;id&lt;/code&gt; of the &lt;code&gt;user&lt;/code&gt; is not known beforehand, we can use &lt;code&gt;queryRecord&lt;/code&gt; to get the user:</source>
          <target state="translated">由于特定 &lt;code&gt;id&lt;/code&gt; 的的 &lt;code&gt;user&lt;/code&gt; 事先不知道，我们可以使用 &lt;code&gt;queryRecord&lt;/code&gt; 获取用户：</target>
        </trans-unit>
        <trans-unit id="fb26b8bc3ae369feedef6c08efb8cf5ba34752ca" translate="yes" xml:space="preserve">
          <source>Since the title is just the &lt;code&gt;@username&lt;/code&gt; plus some extra stuff, we can replace &lt;code&gt;@avatarTitle&lt;/code&gt; by &lt;em&gt;interpolating&lt;/em&gt; the &lt;code&gt;@username&lt;/code&gt; argument in a string literal passed to &lt;code&gt;&amp;lt;Message::Avatar&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">由于标题只是 &lt;code&gt;@username&lt;/code&gt; 再加上一些额外的东西，我们可以更换 &lt;code&gt;@avatarTitle&lt;/code&gt; 通过&lt;em&gt;插值&lt;/em&gt;的 &lt;code&gt;@username&lt;/code&gt; 传递给一个字符串参数 &lt;code&gt;&amp;lt;Message::Avatar&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51f0b4a52b8cebee35dc789d53b13ace54ffb771" translate="yes" xml:space="preserve">
          <source>Since there is no access to jQuery in the non-browser environment, you must also specify a DOM &lt;code&gt;Element&lt;/code&gt; object in the same &lt;code&gt;document&lt;/code&gt; for the &lt;code&gt;rootElement&lt;/code&gt; option (as opposed to a selector string like &lt;code&gt;&quot;body&quot;&lt;/code&gt;).</source>
          <target state="translated">由于在非浏览器环境中无法访问jQuery，因此还必须在同一 &lt;code&gt;document&lt;/code&gt; 为 &lt;code&gt;rootElement&lt;/code&gt; 选项指定DOM &lt;code&gt;Element&lt;/code&gt; 对象（与选择器字符串（如 &lt;code&gt;&quot;body&quot;&lt;/code&gt; ））。</target>
        </trans-unit>
        <trans-unit id="bd76475c68e526debe88fcdc606730652138849e" translate="yes" xml:space="preserve">
          <source>Since we added &lt;code&gt;:rental_id&lt;/code&gt; to the &lt;code&gt;show&lt;/code&gt; path in our router, &lt;code&gt;rental_id&lt;/code&gt; is now available in our &lt;code&gt;model&lt;/code&gt; hook. When we call &lt;code&gt;this.get('store').findRecord('rental', params.rental_id)&lt;/code&gt;, Ember Data queries &lt;code&gt;/rentals/our-id&lt;/code&gt; using a HTTP GET request (&lt;a href=&quot;https://guides.emberjs.com/models/&quot;&gt;learn more about that here&lt;/a&gt;).</source>
          <target state="translated">因为我们在路由器的 &lt;code&gt;show&lt;/code&gt; 路径中添加了 &lt;code&gt;:rental_id&lt;/code&gt; ， &lt;code&gt;rental_id&lt;/code&gt; 现在在 &lt;code&gt;model&lt;/code&gt; 挂钩中可以使用rental_id。当我们调用 &lt;code&gt;this.get('store').findRecord('rental', params.rental_id)&lt;/code&gt; ，Ember Data 使用HTTP GET请求查询 &lt;code&gt;/rentals/our-id&lt;/code&gt; （&lt;a href=&quot;https://guides.emberjs.com/models/&quot;&gt;在此处了解更多信息&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a193b3400008fcdd68f61cf30910ac15e02de1ad" translate="yes" xml:space="preserve">
          <source>Since we have already set up Ember Mirage in our development environment, Mirage will return the data we requested without actually making a network request.</source>
          <target state="translated">由于我们已经在开发环境中设置了Ember Mirage,所以Mirage将返回我们所请求的数据,而不需要实际进行网络请求。</target>
        </trans-unit>
        <trans-unit id="d50f255275c91b6d41ca18a9a609fd25ba369850" translate="yes" xml:space="preserve">
          <source>Since we haven't added any functionality to our application yet, we'll use this first test to get started on running tests in our app.</source>
          <target state="translated">由于我们还没有为我们的应用程序添加任何功能,我们将使用这个第一个测试来开始在我们的应用程序中运行测试。</target>
        </trans-unit>
        <trans-unit id="59ca8024809d59f43c02b2a1ec4a73e4e2d23ac4" translate="yes" xml:space="preserve">
          <source>Since we want to remove this namespace, we can define a serializer for the application that will remove &quot;blog/&quot; from the payload key whenver it's encountered by Ember Data:</source>
          <target state="translated">由于我们想要删除这个命名空间,我们可以为应用程序定义一个序列化器,当Ember Data遇到 &quot;blog/&quot;时,这个序列化器将从payload键中删除。</target>
        </trans-unit>
        <trans-unit id="36cf3d73436a3652e530541299f44a225f1e4f9e" translate="yes" xml:space="preserve">
          <source>Since you're writing an HTML template, you can use dynamic substitution inside of an attribute's value; whenever the value changes, the attribute will change.</source>
          <target state="translated">因为你要写一个HTML模板,所以你可以在一个属性的值里面使用动态替换,只要值发生变化,属性就会发生变化。</target>
        </trans-unit>
        <trans-unit id="ea807664a1d8b2ab5af2d6a9b45e6b93f54d047b" translate="yes" xml:space="preserve">
          <source>Since your app is made up of multiple components, you want to ensure that each is correct before testing them as a group. If a component is reusable, you want to guarantee that it works for all (if not, many) permutations of &lt;a href=&quot;https://guides.emberjs.com/components/component-arguments-and-html-attributes/&quot;&gt;arguments&lt;/a&gt; and &lt;a href=&quot;https://guides.emberjs.com/components/component-state-and-actions/&quot;&gt;actions&lt;/a&gt;.</source>
          <target state="translated">由于您的应用是由多个组件组成的，因此您需要在对每个组件进行分组测试之前确保每个组件都是正确的。如果组件是可重用的，则要保证该组件适用于&lt;a href=&quot;https://guides.emberjs.com/components/component-arguments-and-html-attributes/&quot;&gt;参数&lt;/a&gt;和&lt;a href=&quot;https://guides.emberjs.com/components/component-state-and-actions/&quot;&gt;操作的&lt;/a&gt;所有（如果不是很多的话）排列。</target>
        </trans-unit>
        <trans-unit id="4434cedbc25a9b21d7d06d3713a6484879933703" translate="yes" xml:space="preserve">
          <source>Since:</source>
          <target state="translated">Since:</target>
        </trans-unit>
        <trans-unit id="aea64bd0a70c382637df038e21dc5f4ef10a121b" translate="yes" xml:space="preserve">
          <source>Single word component names are completely OK in angle bracket form.</source>
          <target state="translated">单字组件名称完全可以采用角括号形式。</target>
        </trans-unit>
        <trans-unit id="bf8e78bc810b7c1f530dd6d72d017daf1c3887b6" translate="yes" xml:space="preserve">
          <source>SingleResourceDocument</source>
          <target state="translated">SingleResourceDocument</target>
        </trans-unit>
        <trans-unit id="39ca4feb35676630d8f746e3036b880a54da9d5c" translate="yes" xml:space="preserve">
          <source>Skip Navigation Links</source>
          <target state="translated">跳过导航链接</target>
        </trans-unit>
        <trans-unit id="a516a3ce4b9fd1e3a2a9186564fe4ca0d9da8218" translate="yes" xml:space="preserve">
          <source>Skipping tests</source>
          <target state="translated">跳过测试</target>
        </trans-unit>
        <trans-unit id="b08ae37ed0218a85800a574ce852c8c93ad73b28" translate="yes" xml:space="preserve">
          <source>Snapshot</source>
          <target state="translated">Snapshot</target>
        </trans-unit>
        <trans-unit id="5fd5c5d29b3c095a89a560172a9860a1ee047466" translate="yes" xml:space="preserve">
          <source>SnapshotRecordArray</source>
          <target state="translated">SnapshotRecordArray</target>
        </trans-unit>
        <trans-unit id="de370e832d39727a0c5b9309d06edd07070c125e" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; is shorthand for: &lt;code&gt;{ serialize: 'records', deserialize: 'records' }&lt;/code&gt;</source>
          <target state="translated">因此， &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; 的缩写为： &lt;code&gt;{ serialize: 'records', deserialize: 'records' }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0dbbff918236c7712aa927da66b932a496597385" translate="yes" xml:space="preserve">
          <source>So far in our example, the action we have passed to &lt;code&gt;ButtonWithConfirmation&lt;/code&gt; is a function that accepts one argument, &lt;code&gt;messageType&lt;/code&gt;. Suppose we want to extend this by allowing &lt;code&gt;sendMessage&lt;/code&gt; to take a second argument, the actual text of the message the user is sending:</source>
          <target state="translated">到目前为止，在我们的示例中，我们传递给 &lt;code&gt;ButtonWithConfirmation&lt;/code&gt; 的操作是一个接受一个参数 &lt;code&gt;messageType&lt;/code&gt; 的函数。假设我们想通过允许 &lt;code&gt;sendMessage&lt;/code&gt; 接受第二个参数（用户正在发送的消息的实际文本）来扩展它：</target>
        </trans-unit>
        <trans-unit id="92b64ffe3c61fe82b2f00e41e184a5ff233a2011" translate="yes" xml:space="preserve">
          <source>So far in our example, the action we have passed to &lt;code&gt;button-with-confirmation&lt;/code&gt; is a function that accepts one argument, &lt;code&gt;messageType&lt;/code&gt;. Suppose we want to extend this by allowing &lt;code&gt;sendMessage&lt;/code&gt; to take a second argument, the actual text of the message the user is sending:</source>
          <target state="translated">到目前为止，在我们的示例中，我们传递给 &lt;code&gt;button-with-confirmation&lt;/code&gt; 的操作是一个接受一个参数 &lt;code&gt;messageType&lt;/code&gt; 的函数。假设我们想通过允许 &lt;code&gt;sendMessage&lt;/code&gt; 接受第二个参数（用户正在发送的消息的实际文本）来扩展它：</target>
        </trans-unit>
        <trans-unit id="19c36a10e1948ddfdc6257320833f42dd10fde96" translate="yes" xml:space="preserve">
          <source>So far we've only shown tracked properties working through getters, but tracking works through &lt;em&gt;methods&lt;/em&gt; or &lt;em&gt;functions&lt;/em&gt; as well:</source>
          <target state="translated">到目前为止，我们仅显示了通过getter进行跟踪的属性，但是跟踪也通过&lt;em&gt;方法&lt;/em&gt;或&lt;em&gt;函数&lt;/em&gt;进行了工作：</target>
        </trans-unit>
        <trans-unit id="80a65522f1652c5d00122d3950c2523b284f1750" translate="yes" xml:space="preserve">
          <source>So far, our &lt;code&gt;&amp;lt;PeopleList&amp;gt;&lt;/code&gt; component is purely presentational &amp;ndash; it takes some inputs as arguments and renders them using a template. To introduce &lt;em&gt;behavior&lt;/em&gt; to our component &amp;ndash; handling the button click in this case, we will need to attach some &lt;em&gt;code&lt;/em&gt; to the component.</source>
          <target state="translated">到目前为止，我们的 &lt;code&gt;&amp;lt;PeopleList&amp;gt;&lt;/code&gt; 组件纯粹是表示性的&amp;ndash;它接受一些输入作为参数，并使用模板对其进行呈现。为了向我们的组件引入&lt;em&gt;行为&lt;/em&gt;-在这种情况下处理按钮单击，我们需要向该组件附加一些&lt;em&gt;代码&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="860179c222e257dfd377a3ba0841f6fa360f92ff" translate="yes" xml:space="preserve">
          <source>So far, our app is directly showing the user data from our Ember Data models. As our app grows, we will want to manipulate data further before presenting it to our users. For this reason, Ember offers Handlebars template helpers to decorate the data in our templates. Let's use a handlebars helper to allow our users to quickly see if a property is &quot;Standalone&quot; or part of a &quot;Community&quot;.</source>
          <target state="translated">到目前为止,我们的应用是直接显示来自我们Ember数据模型的用户数据。随着我们应用的发展,我们会希望在向用户展示数据之前进一步操作数据。为此,Ember提供了Handlebars模板助手来装饰我们模板中的数据。让我们使用一个handlebars助手来让我们的用户快速看到一个属性是 &quot;独立 &quot;还是 &quot;社区 &quot;的一部分。</target>
        </trans-unit>
        <trans-unit id="5a240f0aacaf6090843d2fe6aff9163a4d3416bb" translate="yes" xml:space="preserve">
          <source>So far, our application is listing data, but there is no way for the user to interact with the information. In web applications we often want to respond to user actions like clicks or hovers. Ember makes this easy to do.</source>
          <target state="translated">到目前为止,我们的应用程序正在列出数据,但没有办法让用户与信息进行交互。在web应用中,我们经常希望对用户的点击或悬停等操作做出响应。Ember可以轻松实现这一点。</target>
        </trans-unit>
        <trans-unit id="5b117a8a88428d25b4b1e4a7c06468ec66a59e3f" translate="yes" xml:space="preserve">
          <source>So far, we've talked about how to populate an attribute with the value of a variable. But what if we want the value of an attribute to differ based upon whether the variable is truthy or falsy?</source>
          <target state="translated">到目前为止,我们已经谈到了如何用变量的值来填充一个属性,但如果我们想让一个属性的值根据变量的真假而有所不同呢?但是,如果我们想让一个属性的值根据变量是真还是假而有所不同呢?</target>
        </trans-unit>
        <trans-unit id="e2d06f6c5fcf83668c50dcf5e00a42ff400f7c2d" translate="yes" xml:space="preserve">
          <source>So far, we've talked about web APIs that work by setting attributes as well as web APIs that work by setting properties. But what about web APIs that work by calling methods, like setting focus on an element?</source>
          <target state="translated">到目前为止,我们已经谈到了通过设置属性工作的Web API以及通过设置属性工作的Web API。但是通过调用方法工作的Web API呢,比如对元素设置焦点?</target>
        </trans-unit>
        <trans-unit id="4beaba805d3a97bce58afc2f7cb86863c0470f86" translate="yes" xml:space="preserve">
          <source>So far, your application is listing data, but there is no way for the user to interact with the information. In web applications you often want to listen for user events like clicks or hovers. Ember makes this easy to do. First add an &lt;code&gt;action&lt;/code&gt; helper to the &lt;code&gt;li&lt;/code&gt; in your &lt;code&gt;people-list&lt;/code&gt; component.</source>
          <target state="translated">到目前为止，您的应用程序正在列出数据，但是用户无法与信息进行交互。在Web应用程序中，您通常希望侦听诸如单击或悬停之类的用户事件。灰烬使这容易做到。首先添加一个 &lt;code&gt;action&lt;/code&gt; 助手的 &lt;code&gt;li&lt;/code&gt; 在 &lt;code&gt;people-list&lt;/code&gt; 的组成部分。</target>
        </trans-unit>
        <trans-unit id="82dbd01dbf5e166342277657acc79af70412fa18" translate="yes" xml:space="preserve">
          <source>So this change to &lt;code&gt;firstName&lt;/code&gt; was observed by &lt;code&gt;fullName&lt;/code&gt; computed property, which was itself observed by the &lt;code&gt;description&lt;/code&gt; property.</source>
          <target state="translated">所以这个变化 &lt;code&gt;firstName&lt;/code&gt; 被观察到 &lt;code&gt;fullName&lt;/code&gt; 计算的属性，它本身就是观察到的 &lt;code&gt;description&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="7c179ab2cf598954fd3d4e13b9ad80cb323f34c9" translate="yes" xml:space="preserve">
          <source>So too with JSON API. By using JSON API to interop between your Ember app and your server, you can entirely change your backend stack without breaking your frontend. And as you add apps for other platforms, such as iOS and Android, you will be able to leverage JSON API libraries for those platforms to easily consume the same API your Ember app uses.</source>
          <target state="translated">JSON API也是如此。通过使用JSON API在你的Ember应用和服务器之间进行互操作,你可以完全改变你的后端堆栈而不破坏你的前端。而当你为其他平台(如iOS和Android)添加应用时,你将能够利用这些平台的JSON API库来轻松地消耗你的Ember应用所使用的相同的API。</target>
        </trans-unit>
        <trans-unit id="1b4ae5f1c58dc8bb8ea15838b3e9682246652530" translate="yes" xml:space="preserve">
          <source>So, how can we provide some visual feedback during the transition?</source>
          <target state="translated">那么,在过渡期间,我们如何提供一些视觉反馈呢?</target>
        </trans-unit>
        <trans-unit id="fd7b7f2884ce4c1630ffc4f76897bd0d01d7ef54" translate="yes" xml:space="preserve">
          <source>So, if we want to display a purchase total we can pass the value into the template in cents:</source>
          <target state="translated">所以,如果我们想显示购买总数,我们可以将数值以分值传入模板。</target>
        </trans-unit>
        <trans-unit id="820ab04fe6d1513548b6823192b5113a17600f54" translate="yes" xml:space="preserve">
          <source>Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary headers can be set as key/value pairs on the &lt;code&gt;JSONAPIAdapter&lt;/code&gt;'s &lt;code&gt;headers&lt;/code&gt; object and Ember Data will send them along with each ajax request.</source>
          <target state="translated">某些API需要HTTP标头，例如提供API密钥。可以在 &lt;code&gt;JSONAPIAdapter&lt;/code&gt; 的 &lt;code&gt;headers&lt;/code&gt; 对象上将任意标头设置为键/值对，Ember Data会将它们与每个ajax请求一起发送。</target>
        </trans-unit>
        <trans-unit id="8b2ac0c846f9c6b1368c32fcb57645817bd2729e" translate="yes" xml:space="preserve">
          <source>Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary headers can be set as key/value pairs on the &lt;code&gt;RESTAdapter&lt;/code&gt;'s &lt;code&gt;headers&lt;/code&gt; object and Ember Data will send them along with each ajax request.</source>
          <target state="translated">某些API需要HTTP标头，例如提供API密钥。可以在 &lt;code&gt;RESTAdapter&lt;/code&gt; 的 &lt;code&gt;headers&lt;/code&gt; 对象上将任意标头设置为键/值对，Ember Data会将它们与每个ajax请求一起发送。</target>
        </trans-unit>
        <trans-unit id="470ef24de909d94ebda0dd114d92e50df150b44d" translate="yes" xml:space="preserve">
          <source>Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary headers can be set as key/value pairs on the &lt;code&gt;RESTAdapter&lt;/code&gt;'s &lt;code&gt;headers&lt;/code&gt; object and Ember Data will send them along with each ajax request. For dynamic headers see &lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/RESTAdapter&quot;&gt;headers customization&lt;/a&gt;.</source>
          <target state="translated">一些API需要HTTP标头，例如以提供API密钥。可以在 &lt;code&gt;RESTAdapter&lt;/code&gt; 的 &lt;code&gt;headers&lt;/code&gt; 对象上将任意标头设置为键/值对，Ember Data会将它们与每个ajax请求一起发送。有关动态标题，请参见&lt;a href=&quot;https://api.emberjs.com/ember-data/release/classes/RESTAdapter&quot;&gt;标题定制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ff79da2240d73d23b85815d98e514154e6babb3" translate="yes" xml:space="preserve">
          <source>Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary headers can be set as key/value pairs on the &lt;code&gt;RESTAdapter&lt;/code&gt;'s &lt;code&gt;headers&lt;/code&gt; object and Ember Data will send them along with each ajax request. For dynamic headers see &lt;a href=&quot;https://emberjs.com/api/data/classes/DS.RESTAdapter.html#toc_headers-customization&quot;&gt;headers customization&lt;/a&gt;.</source>
          <target state="translated">某些API需要HTTP标头，例如提供API密钥。可以在 &lt;code&gt;RESTAdapter&lt;/code&gt; 的 &lt;code&gt;headers&lt;/code&gt; 对象上将任意标头设置为键/值对，Ember Data会将它们与每个ajax请求一起发送。有关动态标题，请参见&lt;a href=&quot;https://emberjs.com/api/data/classes/DS.RESTAdapter.html#toc_headers-customization&quot;&gt;标题定制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="589305bc3eb0d013e4fe10cb12d21b40cca5f01f" translate="yes" xml:space="preserve">
          <source>Some addons might conditionally include polyfills only if needed. Some linters may emit warnings when using features not yet fully supported in your targets. Some addons may even automatically prefix unsupported CSS properties.</source>
          <target state="translated">一些插件可能仅在需要时才会有条件地包含polyfills。当使用目标中尚未完全支持的功能时,一些插件可能会发出警告。有些插件甚至会自动给不支持的CSS属性加前缀。</target>
        </trans-unit>
        <trans-unit id="3ff258fab639787350b4d162b7b89ec9d01856b6" translate="yes" xml:space="preserve">
          <source>Some common tools for making &lt;a href=&quot;https://en.wikipedia.org/wiki/Create,_read,_update_and_delete&quot;&gt;CRUD&lt;/a&gt; (create, read, update, delete) requests in Ember include:</source>
          <target state="translated">在Ember中发出&lt;a href=&quot;https://en.wikipedia.org/wiki/Create,_read,_update_and_delete&quot;&gt;CRUD&lt;/a&gt;（创建，读取，更新，删除）请求的一些常用工具包括：</target>
        </trans-unit>
        <trans-unit id="6e74245b72df6c829e572b3d6fe97cf270bbb1d9" translate="yes" xml:space="preserve">
          <source>Some common use cases include:</source>
          <target state="translated">一些常见的使用案例包括:</target>
        </trans-unit>
        <trans-unit id="fb8a1601e22971013d244a3199654c426856db1e" translate="yes" xml:space="preserve">
          <source>Some decorators can also receive arguments:</source>
          <target state="translated">有些装饰器也可以接收参数。</target>
        </trans-unit>
        <trans-unit id="17a6dac8bf912ce569cbeab14f1bf531b4c08379" translate="yes" xml:space="preserve">
          <source>Some examples modifying that default behavior:</source>
          <target state="translated">一些修改该默认行为的例子。</target>
        </trans-unit>
        <trans-unit id="85e58413d75b43a1155e92c311ad52664b36bef1" translate="yes" xml:space="preserve">
          <source>Some examples of how &lt;em&gt;enabling&lt;/em&gt; this feature impacts app code are:</source>
          <target state="translated">&lt;em&gt;启用&lt;/em&gt;此功能如何影响应用程序代码的一些示例如下：</target>
        </trans-unit>
        <trans-unit id="82534b5183631ee9d5eeba124dc1c2d8a8efa3a1" translate="yes" xml:space="preserve">
          <source>Some examples of how names are resolved:</source>
          <target state="translated">一些关于如何解决名字的例子。</target>
        </trans-unit>
        <trans-unit id="d36a638a9881c1c5bedbe70a1f5fac81a45f759e" translate="yes" xml:space="preserve">
          <source>Some models may have properties that are deeply nested objects of readonly data. The na&amp;iuml;ve solution would be to define models for each nested object and use &lt;code&gt;hasMany&lt;/code&gt; and &lt;code&gt;belongsTo&lt;/code&gt; to recreate the nested relationship. However, since readonly data will never need to be updated and saved this often results in the creation of a great deal of code for very little benefit. An alternate approach is to define these relationships using an attribute with no transform (&lt;code&gt;@attr&lt;/code&gt;). This makes it easy to access readonly values in other objects and templates without the overhead of defining extraneous models.</source>
          <target state="translated">某些模型的属性可能是只读数据的深层嵌套对象。幼稚的解决方案是为每个嵌套对象定义模型，并使用 &lt;code&gt;hasMany&lt;/code&gt; 和 &lt;code&gt;belongsTo&lt;/code&gt; 重新创建嵌套关系。但是，由于永远不需要更新和保存只读数据，因此，这通常会导致创建大量代码，而带来的好处却很少。另一种方法是使用没有变换的属性（ &lt;code&gt;@attr&lt;/code&gt; ）定义这些关系。这使得访问其他对象和模板中的只读值变得容易，而无需定义无关模型的开销。</target>
        </trans-unit>
        <trans-unit id="9d5184c34d7d66d58908b766bee8f66460408f46" translate="yes" xml:space="preserve">
          <source>Some models may have properties that are deeply nested objects of readonly data. The na&amp;iuml;ve solution would be to define models for each nested object and use &lt;code&gt;hasMany&lt;/code&gt; and &lt;code&gt;belongsTo&lt;/code&gt; to recreate the nested relationship. However, since readonly data will never need to be updated and saved this often results in the creation of a great deal of code for very little benefit. An alternate approach is to define these relationships using an attribute with no transform (&lt;code&gt;DS.attr()&lt;/code&gt;). This makes it easy to access readonly values in computed properties and templates without the overhead of defining extraneous models.</source>
          <target state="translated">某些模型的属性可能是只读数据的深层嵌套对象。幼稚的解决方案是为每个嵌套对象定义模型，并使用 &lt;code&gt;hasMany&lt;/code&gt; 和 &lt;code&gt;belongsTo&lt;/code&gt; 重新创建嵌套关系。但是，由于永远不需要更新和保存只读数据，因此这通常会导致创建大量代码，而带来的好处却很少。另一种方法是使用没有变换的属性（ &lt;code&gt;DS.attr()&lt;/code&gt; ）定义这些关系。这使访问已计算的属性和模板中的只读值变得容易，而无需定义无关模型的开销。</target>
        </trans-unit>
        <trans-unit id="9b4ade66ce72953c75feeb49b9c6df4d4fc8e7c5" translate="yes" xml:space="preserve">
          <source>Some notes about &lt;code&gt;class&lt;/code&gt; usage:</source>
          <target state="translated">有关 &lt;code&gt;class&lt;/code&gt; 用法的一些注意事项：</target>
        </trans-unit>
        <trans-unit id="0c345287ac108fa43e40986e9e0b206ee82b4fe8" translate="yes" xml:space="preserve">
          <source>Some of Ember's test helpers are promises that wait for the run loop to empty before resolving. If your application has code that runs &lt;em&gt;outside&lt;/em&gt; a run loop, these will resolve too early and give erroneous test failures which are difficult to find. Disabling autoruns help you identify these scenarios and helps both your testing and your application!</source>
          <target state="translated">Ember的一些测试助手承诺在解决之前要等待运行循环清空。如果您的应用程序具有&lt;em&gt;在&lt;/em&gt;运行循环&lt;em&gt;之外&lt;/em&gt;运行的代码，则这些代码将过早解决，并导致错误的测试失败，很难找到。禁用自动运行可以帮助您识别这些情况，并有助于测试和应用程序！</target>
        </trans-unit>
        <trans-unit id="b1bbf5eaf965f38fe34ca676ba670d7b7e3a16eb" translate="yes" xml:space="preserve">
          <source>Some of the features that Ember relies on, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Field_declarations&quot;&gt;class fields&lt;/a&gt; and &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;decorators&lt;/a&gt; have not yet been fully finalized in JavaScript just yet, so we'll cover these here with the assumption that you've had a chance to familiarize yourself with classes before. If you haven't, you can also check out &lt;a href=&quot;https://guides.emberjs.com/in-depth-topics/native-classes-in-depth/&quot;&gt;our detailed class primer&lt;/a&gt;.</source>
          <target state="translated">Ember依赖的某些功能（例如，&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Field_declarations&quot;&gt;类字段&lt;/a&gt;和&lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;装饰器）&lt;/a&gt;尚未在JavaScript中完全完成，因此我们在这里将以您已经有机会熟悉类的假设为前提来进行介绍。如果您还没有的话，还可以查看&lt;a href=&quot;https://guides.emberjs.com/in-depth-topics/native-classes-in-depth/&quot;&gt;我们的详细课程入门&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4979198f37570d49855015976a8e9dfdb6023e02" translate="yes" xml:space="preserve">
          <source>Some of the helpers we'll use commonly are:</source>
          <target state="translated">我们会常用到的一些助手有。</target>
        </trans-unit>
        <trans-unit id="3748e66aa53dcbbdabc1f3d7af1f40169fdff824" translate="yes" xml:space="preserve">
          <source>Some of the more common ways to report a problem with the guides are:</source>
          <target state="translated">一些比较常见的报告指南问题的方式是:</target>
        </trans-unit>
        <trans-unit id="5337883a101c091bf437d743927429e7f9b3a8dc" translate="yes" xml:space="preserve">
          <source>Some of the reasons this may happen:</source>
          <target state="translated">可能发生这种情况的一些原因:</target>
        </trans-unit>
        <trans-unit id="822e1f477acc562b0e523818fa99c2731cc5d901" translate="yes" xml:space="preserve">
          <source>Some of these features that you'll learn about in the guides are:</source>
          <target state="translated">这些功能中,你将在指南中了解到一些。</target>
        </trans-unit>
        <trans-unit id="013194aba18ba879d16afd5810abb441525b32e0" translate="yes" xml:space="preserve">
          <source>Some of these handy helpers are:</source>
          <target state="translated">这些方便的帮手有:</target>
        </trans-unit>
        <trans-unit id="66952b6d0704d8bd5ed88829a1728002186d07f9" translate="yes" xml:space="preserve">
          <source>Some other event in the app causes the URL to change.</source>
          <target state="translated">应用中的一些其他事件导致URL发生变化。</target>
        </trans-unit>
        <trans-unit id="57317550a3c27511c883be0f3369988d320cb4f4" translate="yes" xml:space="preserve">
          <source>Some people choose to load data in their Components. The drawback is that requires more work from developers to handle async, rendering, errors, concurrency, and URL state themselves - functionality they would get automatically if they used a Route's &lt;code&gt;model&lt;/code&gt; hook. However there are valid use cases for loading data in a component, for developers who are comfortable handling the router's features themselves.</source>
          <target state="translated">有些人选择将数据加载到其组件中。缺点是开发人员需要自己做更多工作来处理异步，呈现，错误，并发和URL状态-如果使用Route的 &lt;code&gt;model&lt;/code&gt; 钩子，它们将自动获得功能。但是，对于那些愿意自己处理路由器功能的开发人员，有一些有效的用例可用于在组件中加载数据。</target>
        </trans-unit>
        <trans-unit id="6662963cf7cb67b19d16e3797446e1a4df2164ae" translate="yes" xml:space="preserve">
          <source>Some properties are not only grouped by inheritance, but also by framework level semantics. For example, if you inspect an Ember Data model, you can see &lt;code&gt;Attributes&lt;/code&gt;, &lt;code&gt;Belongs To&lt;/code&gt;, &lt;code&gt;Has Many&lt;/code&gt;, and &lt;code&gt;Flags&lt;/code&gt; groups.</source>
          <target state="translated">一些属性不仅按继承进行分组，还按框架级语义进行分组。例如，如果检查Ember Data模型，则可以看到 &lt;code&gt;Attributes&lt;/code&gt; ， &lt;code&gt;Belongs To&lt;/code&gt; ， &lt;code&gt;Has Many&lt;/code&gt; 和 &lt;code&gt;Flags&lt;/code&gt; 组。</target>
        </trans-unit>
        <trans-unit id="d53376f049cded3ffe42cdb45579f580b958c176" translate="yes" xml:space="preserve">
          <source>Some raw JSON data to be normalized into a JSON:API Resource.</source>
          <target state="translated">一些原始JSON数据要规范化为JSON:API资源。</target>
        </trans-unit>
        <trans-unit id="325238f44bc39a7d51558fbf18caf5277d0da375" translate="yes" xml:space="preserve">
          <source>Some reasons for customizing an Adapter include using &lt;code&gt;underscores_case&lt;/code&gt; in your urls, using a medium other than REST to communicate with your backend API or even using a &lt;a href=&quot;https://github.com/locks/ember-localstorage-adapter&quot;&gt;local storage backend&lt;/a&gt;.</source>
          <target state="translated">定制适配器的一些原因包括在URL中使用 &lt;code&gt;underscores_case&lt;/code&gt; ，使用REST以外的媒体与后端API进行通信，甚至使用&lt;a href=&quot;https://github.com/locks/ember-localstorage-adapter&quot;&gt;本地存储后端&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2244f25ae871987e59d131e17c8c7397712981aa" translate="yes" xml:space="preserve">
          <source>Some routes always display the same model. For example, the &lt;code&gt;/photos&lt;/code&gt; route will always display the same list of photos available in the application. If your user leaves this route and comes back later, the model does not change.</source>
          <target state="translated">有些路线总是显示相同的模型。例如， &lt;code&gt;/photos&lt;/code&gt; 路由将始终显示应用程序中可用的相同照片列表。如果您的用户离开了这条路线并稍后返回，则模型不会更改。</target>
        </trans-unit>
        <trans-unit id="dfada9d7be3abdb25489a10a3babdd4c487f5a91" translate="yes" xml:space="preserve">
          <source>Some specific examples of units tests are:</source>
          <target state="translated">单位测试的一些具体例子是:</target>
        </trans-unit>
        <trans-unit id="f4c0047cd154d80ed200c3a10a6e33a060f165c8" translate="yes" xml:space="preserve">
          <source>Some times you might be working on a feature, but know that a certain test will fail so you might want to skip it. You can do it by using &lt;code&gt;skip&lt;/code&gt;:</source>
          <target state="translated">有时您可能正在使用某个功能，但是知道某个测试将失败，因此您可能希望跳过它。您可以使用 &lt;code&gt;skip&lt;/code&gt; 来做到这一点：</target>
        </trans-unit>
        <trans-unit id="e8353c07cd51f4950ee2ad76a1992e4ffb81690e" translate="yes" xml:space="preserve">
          <source>Some types of computed properties are very common. Ember provides a number of computed property macros, which are shorter ways of expressing certain types of computed property.</source>
          <target state="translated">有些类型的计算属性是非常常见的。Ember提供了许多计算属性宏,这些宏是表达某些类型计算属性的较短方式。</target>
        </trans-unit>
        <trans-unit id="e242b0e25372bca745a56f2ef24c52a13c526d4c" translate="yes" xml:space="preserve">
          <source>Sometimes a service may or may not exist, like when an initializer conditionally registers a service. Since normal injection will throw an error if the service doesn't exist, you must look up the service using Ember's &lt;a href=&quot;https://api.emberjs.com/ember/release/classes/@ember%2Fapplication/methods#getOwner&quot;&gt;&lt;code&gt;getOwner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">有时服务可能存在或可能不存在，例如初始化程序有条件地注册服务时。由于如果服务不存在，正常注入将引发错误，因此必须使用Ember的&lt;a href=&quot;https://api.emberjs.com/ember/release/classes/@ember%2Fapplication/methods#getOwner&quot;&gt; &lt;code&gt;getOwner&lt;/code&gt; &lt;/a&gt;查找服务。</target>
        </trans-unit>
        <trans-unit id="86c891d4cd8c7cba722589fb8d2aa6a1abb982b5" translate="yes" xml:space="preserve">
          <source>Sometimes a service may or may not exist, like when an initializer conditionally registers a service. Since normal injection will throw an error if the service doesn't exist, you must look up the service using Ember's &lt;a href=&quot;https://emberjs.com/api/classes/Ember.html#method_getOwner&quot;&gt;&lt;code&gt;getOwner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">有时服务可能存在或不存在，例如初始化程序有条件地注册服务时。由于如果服务不存在，正常注入将引发错误，因此必须使用Ember的&lt;a href=&quot;https://emberjs.com/api/classes/Ember.html#method_getOwner&quot;&gt; &lt;code&gt;getOwner&lt;/code&gt; &lt;/a&gt;查找服务。</target>
        </trans-unit>
        <trans-unit id="3155e1aa9ca809aad16247d1dc430dba0afcf4d9" translate="yes" xml:space="preserve">
          <source>Sometimes controllers have dependencies on other controllers. This is accomplished by injecting one controller into another. For example, here are two simple controllers. The &lt;code&gt;CommentsController&lt;/code&gt; uses the &lt;code&gt;PostController&lt;/code&gt; via &lt;code&gt;inject&lt;/code&gt;:</source>
          <target state="translated">有时，控制器对其他控制器有依赖性。这是通过将一个控制器注入另一个控制器来实现的。例如，这是两个简单的控制器。该 &lt;code&gt;CommentsController&lt;/code&gt; 使用 &lt;code&gt;PostController&lt;/code&gt; 中通过 &lt;code&gt;inject&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ec494ae7d5dc61d3450971f28ceab15c4a31768f" translate="yes" xml:space="preserve">
          <source>Sometimes the parent component invoking an action has some context needed for the action that the child component doesn't. Consider, for example, the case where the &lt;code&gt;ButtonWithConfirmation&lt;/code&gt; component we've defined is used within &lt;code&gt;SendMessage&lt;/code&gt;. The &lt;code&gt;sendMessage&lt;/code&gt; action that we pass to the child component may expect a message type parameter to be provided as an argument:</source>
          <target state="translated">有时，调用操作的父组件具有某些操作所需的上下文，而子组件则不需要。例如，考虑在 &lt;code&gt;SendMessage&lt;/code&gt; 中使用我们定义的 &lt;code&gt;ButtonWithConfirmation&lt;/code&gt; 组件的情况。我们传递给子组件的 &lt;code&gt;sendMessage&lt;/code&gt; 操作可能期望将消息类型参数作为参数提供：</target>
        </trans-unit>
        <trans-unit id="9e4d9e623bb94a60e9ac83b620b9d575221d6a19" translate="yes" xml:space="preserve">
          <source>Sometimes the parent component invoking an action has some context needed for the action that the child component doesn't. Consider, for example, the case where the &lt;code&gt;button-with-confirmation&lt;/code&gt; component we've defined is used within &lt;code&gt;send-message&lt;/code&gt;. The &lt;code&gt;sendMessage&lt;/code&gt; action that we pass to the child component may expect a message type parameter to be provided as an argument:</source>
          <target state="translated">有时，调用动作的父组件具有某些动作所需的上下文，而子组件则不需要。例如，考虑在 &lt;code&gt;send-message&lt;/code&gt; 中使用我们定义 &lt;code&gt;button-with-confirmation&lt;/code&gt; 组件的情况。我们传递给子组件的 &lt;code&gt;sendMessage&lt;/code&gt; 操作可能希望将消息类型参数作为参数提供：</target>
        </trans-unit>
        <trans-unit id="b795927e172ff54b29fd66e4ef2233525e286ec2" translate="yes" xml:space="preserve">
          <source>Sometimes the value you want to propagate to a downstream promise can only be retrieved asynchronously. This can be achieved by returning a promise in the fulfillment or rejection handler. The downstream promise will then be pending until the returned promise is settled. This is called &lt;em&gt;assimilation&lt;/em&gt;.</source>
          <target state="translated">有时，您要传播到下游Promise的值只能异步获取。这可以通过在实现或拒绝处理程序中返回承诺来实现。然后，下游承诺将待定，直到解决了返回的承诺。这称为&lt;em&gt;同化&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fb6b416b736de5984855b00b7181426c6ea9cfe1" translate="yes" xml:space="preserve">
          <source>Sometimes we want to set relationships on already existing records. We can simply set a &lt;code&gt;belongsTo&lt;/code&gt; relationship:</source>
          <target state="translated">有时我们想在已经存在的记录上设置关系。我们可以简单地设置一个 &lt;code&gt;belongsTo&lt;/code&gt; 关系：</target>
        </trans-unit>
        <trans-unit id="e3938ef49fd1f00900f13ab44705cfe380190afd" translate="yes" xml:space="preserve">
          <source>Sometimes you don't care if properties of individual array items change. In this case use the &lt;code&gt;[]&lt;/code&gt; key instead of &lt;code&gt;@each&lt;/code&gt;. Computed properties dependent on an array using the &lt;code&gt;[]&lt;/code&gt; key will only update if items are added to or removed from the array, or if the array property is set to a different array. For example:</source>
          <target state="translated">有时您不在乎单个数组项的属性是否发生变化。在这种情况下，请使用 &lt;code&gt;[]&lt;/code&gt; 键而不是 &lt;code&gt;@each&lt;/code&gt; 。使用 &lt;code&gt;[]&lt;/code&gt; 键依赖于数组的计算属性仅在将项目添加到数组中或从数组中删除时，或者如果将数组属性设置为其他数组时才更新。例如：</target>
        </trans-unit>
        <trans-unit id="59593e85c482d9ccffbf9cb3f10447cbf9a7e137" translate="yes" xml:space="preserve">
          <source>Sometimes you have a computed property whose value depends on the properties of items in an array. For example, you may have an array of todo items, and want to calculate the incomplete todo's based on their &lt;code&gt;isDone&lt;/code&gt; property.</source>
          <target state="translated">有时您有一个计算属性，其值取决于数组中各项的属性。例如，您可能有一个待办事项数组，并想根据其 &lt;code&gt;isDone&lt;/code&gt; 属性计算不完整的待办事项。</target>
        </trans-unit>
        <trans-unit id="02020eb76a56d4e096072529eb83ef7b6e6a7883" translate="yes" xml:space="preserve">
          <source>Sometimes you need to change a value directly or indirectly without actually calling &lt;code&gt;get()&lt;/code&gt; or &lt;code&gt;set()&lt;/code&gt; on it. In this case, you can use this method instead. Calling this method will notify all observers that the property has potentially changed value.</source>
          <target state="translated">有时，您需要直接或间接更改值，而无需实际对其调用 &lt;code&gt;get()&lt;/code&gt; 或 &lt;code&gt;set()&lt;/code&gt; 。在这种情况下，您可以改用此方法。调用此方法将通知所有观察者该属性的值可能已更改。</target>
        </trans-unit>
        <trans-unit id="416096650446b210755d175075d7e07b083b9ad1" translate="yes" xml:space="preserve">
          <source>Sometimes you need to fetch a model, but your route doesn't have the parameters, because it's a child route and the route directly above or a few levels above has the parameters that your route needs.</source>
          <target state="translated">有时你需要获取一个模型,但你的路由没有参数,因为它是一个子路由,而直接上面或上面几层的路由有你的路由需要的参数。</target>
        </trans-unit>
        <trans-unit id="204181322499311f46007cd4bc07ef725e80b57a" translate="yes" xml:space="preserve">
          <source>Sometimes you need to fetch a model, but your route doesn't have the parameters, because it's a child route and the route directly above or a few levels above has the parameters that your route needs. You might run into this if you have a URL like &lt;code&gt;/album/4/songs/18&lt;/code&gt;, and when you're in the songs route, you need an album ID.</source>
          <target state="translated">有时您需要获取一个模型，但是您的路线没有参数，因为它是子路线，而直接在其上方或上方几层的路线具有您的路线所需的参数。如果您拥有类似 &lt;code&gt;/album/4/songs/18&lt;/code&gt; 之类的URL，那么您可能会遇到此问题，并且在进入歌曲路线时，您需要一个专辑ID。</target>
        </trans-unit>
        <trans-unit id="559f553ca9e321ad0a7cbfeb49c2a261a0036395" translate="yes" xml:space="preserve">
          <source>Sometimes you need to retain the &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">有时您需要保留 &lt;code&gt;this&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="069522e3125331b06bf7bf0225dd816607897fe7" translate="yes" xml:space="preserve">
          <source>Sometimes you want to redirect a user to a different page than what they requested for.</source>
          <target state="translated">有时候,你想把用户重定向到一个不同于他们请求的页面。</target>
        </trans-unit>
        <trans-unit id="0b639c578441ab69ca93cfe6eacb7e5c4ffe28f4" translate="yes" xml:space="preserve">
          <source>Sometimes, we may want to provide some default content if the user of a component hasn't provided a block. For instance, consider an error message dialog that has a default message in cases where we don't know what error occurred. We could show the default message using the &lt;code&gt;(has-block)&lt;/code&gt; syntax in an &lt;code&gt;ErrorDialog&lt;/code&gt; component.</source>
          <target state="translated">有时，如果组件的用户未提供阻止，我们可能希望提供一些默认内容。例如，在我们不知道发生什么错误的情况下，考虑一个带有默认消息的错误消息对话框。我们可以在 &lt;code&gt;ErrorDialog&lt;/code&gt; 组件中使用 &lt;code&gt;(has-block)&lt;/code&gt; 语法显示默认消息。</target>
        </trans-unit>
        <trans-unit id="ff1deea5816647c86f04dab422bbd3f177c20025" translate="yes" xml:space="preserve">
          <source>Sometimes, you may need to generate links for nested routes which can have multiple &lt;a href=&quot;https://guides.emberjs.com/routing/defining-your-routes/#toc_dynamic-segments&quot;&gt;dynamic segments&lt;/a&gt;. For example, consider the following route definitions:</source>
          <target state="translated">有时，您可能需要为嵌套路线生成链接，这些路线可以具有多个&lt;a href=&quot;https://guides.emberjs.com/routing/defining-your-routes/#toc_dynamic-segments&quot;&gt;动态路段&lt;/a&gt;。例如，考虑以下路由定义：</target>
        </trans-unit>
        <trans-unit id="2baef004d709137087990a2c9d850371fca71c1c" translate="yes" xml:space="preserve">
          <source>Sometimes, you may want to define a component that wraps content provided by other templates.</source>
          <target state="translated">有时,你可能想定义一个组件来包装其他模板提供的内容。</target>
        </trans-unit>
        <trans-unit id="2395a368ce28ec5ec373220c01e2fc1461af523a" translate="yes" xml:space="preserve">
          <source>Sometimes, you might see helpers invoked by placing them inside parentheses, &lt;code&gt;()&lt;/code&gt;. This means that a Helper is being used inside of another Helper or Component. This is referred to as a &quot;nested&quot; Helper Invocation. Parentheses must be used because curly braces &lt;code&gt;{{}}&lt;/code&gt; cannot be nested.</source>
          <target state="translated">有时，您可能会看到通过将辅助函数放在括号 &lt;code&gt;()&lt;/code&gt; 中来调用的辅助函数。这意味着在另一个帮助程序或组件内部使用了一个帮助程序。这称为&amp;ldquo;嵌套&amp;rdquo;助手调用。必须使用括号，因为花括号 &lt;code&gt;{{}}&lt;/code&gt; 无法嵌套。</target>
        </trans-unit>
        <trans-unit id="8ed644784dc95f21d324b17adf99f942121d6a63" translate="yes" xml:space="preserve">
          <source>Sometimes, you will want to conditionally set an argument or attribute.</source>
          <target state="translated">有时,你会想有条件地设置一个参数或属性。</target>
        </trans-unit>
        <trans-unit id="064d7374612367c011789ae5321e5d060ef161dd" translate="yes" xml:space="preserve">
          <source>Sorts the array by the keys specified in the argument.</source>
          <target state="translated">按参数中指定的键对数组进行排序。</target>
        </trans-unit>
        <trans-unit id="03d664c8a7630fa11c74ace4dc1511eeaa4841f2" translate="yes" xml:space="preserve">
          <source>Special HTML elements like &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;</source>
          <target state="translated">特殊的HTML元素，例如 &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96659bf5510b1ddbf595565c481a37824bc493f8" translate="yes" xml:space="preserve">
          <source>Specifies how records can be filtered. Records returned will need to have a &lt;code&gt;filterValues&lt;/code&gt; property with a key for every name in the returned array.</source>
          <target state="translated">指定如何过滤记录。返回的记录将需要具有 &lt;code&gt;filterValues&lt;/code&gt; 属性，并为返回的数组中的每个名称提供键。</target>
        </trans-unit>
        <trans-unit id="95f6dd8dc212ba5d85302c1420a17db8da9053f3" translate="yes" xml:space="preserve">
          <source>Specify a method that observes property changes.</source>
          <target state="translated">指定一个观察属性变化的方法。</target>
        </trans-unit>
        <trans-unit id="223591aeca04cad98919771b70c08a1289123a53" translate="yes" xml:space="preserve">
          <source>Specifying DOM event type</source>
          <target state="translated">指定DOM事件类型</target>
        </trans-unit>
        <trans-unit id="9dc9de0aa5ed554b19547386f6cca49a1ec57918" translate="yes" xml:space="preserve">
          <source>Specifying Initializer Order</source>
          <target state="translated">指定初始化器顺序</target>
        </trans-unit>
        <trans-unit id="5fdf0dd083e563032f5e6602ce7e005cc574889d" translate="yes" xml:space="preserve">
          <source>Specifying Keys</source>
          <target state="translated">指定键</target>
        </trans-unit>
        <trans-unit id="35833528563ce69a1f68854f07be8e7aa16a509d" translate="yes" xml:space="preserve">
          <source>Specifying Query Parameters</source>
          <target state="translated">指定查询参数</target>
        </trans-unit>
        <trans-unit id="7c35f3946da6ff79b8757a6ceb8ee8d49df16369" translate="yes" xml:space="preserve">
          <source>Specifying a Root URL</source>
          <target state="translated">指定一个根网址</target>
        </trans-unit>
        <trans-unit id="3178f09d7674b2ba76416a9f78ffa51e9d2fdd63" translate="yes" xml:space="preserve">
          <source>Specifying a Route&amp;#x27;s Model</source>
          <target state="translated">指定路线的模型</target>
        </trans-unit>
        <trans-unit id="0aab4ef25ec9e8d4b45fcc096abf64fe7a154c92" translate="yes" xml:space="preserve">
          <source>Specifying a Route's Model</source>
          <target state="translated">指定路线的模式</target>
        </trans-unit>
        <trans-unit id="9d13a540e07e9718658fc51f3532a2a9665ff955" translate="yes" xml:space="preserve">
          <source>Specifying a Target</source>
          <target state="translated">指定目标</target>
        </trans-unit>
        <trans-unit id="0576f645f0df389ae6ff04ea0100cb46c490b756" translate="yes" xml:space="preserve">
          <source>Specifying the Type of Event</source>
          <target state="translated">指定事件类型</target>
        </trans-unit>
        <trans-unit id="d91b92c60fdffefa96bc27ffdf887f5e281d0a13" translate="yes" xml:space="preserve">
          <source>Specifying the URL Type</source>
          <target state="translated">指定URL类型</target>
        </trans-unit>
        <trans-unit id="c69285edae5096eb75f15a92d92d9083fbcd550c" translate="yes" xml:space="preserve">
          <source>Specifying whitelisted modifier keys</source>
          <target state="translated">指定白名单修饰键</target>
        </trans-unit>
        <trans-unit id="9d4fa9e78c183321cef3a8e36a830b3610a9a700" translate="yes" xml:space="preserve">
          <source>Splits a string into separate units separated by spaces, eliminating any empty strings in the process. This is a convenience method for split that is mostly useful when applied to the &lt;code&gt;String.prototype&lt;/code&gt;.</source>
          <target state="translated">将字符串拆分成用空格分隔的单独单元，从而消除了该过程中的任何空字符串。这是一种方便的拆分方法，在应用于 &lt;code&gt;String.prototype&lt;/code&gt; 时最有用。</target>
        </trans-unit>
        <trans-unit id="be240ad179556a0e830c1c4a80ede62ad10a9099" translate="yes" xml:space="preserve">
          <source>StableRecordIdentifier[]</source>
          <target state="translated">StableRecordIdentifier[]</target>
        </trans-unit>
        <trans-unit id="0d1e61286aa50eb30bfbfd7083574b6c91fc2ff1" translate="yes" xml:space="preserve">
          <source>Standard CSS class names to apply to the view's outer element. This property automatically inherits any class names defined by the view's superclasses as well.</source>
          <target state="translated">应用于视图外层元素的标准 CSS 类名。此属性会自动继承任何由视图的超级类定义的类名。</target>
        </trans-unit>
        <trans-unit id="8d2e5c61163ac5addfc66cdf3663694e20d997c0" translate="yes" xml:space="preserve">
          <source>Standard Method</source>
          <target state="translated">标准方法</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
